data8 = VideoPortReadPortUchar(CRT_DATA_REG);

    if ((data8 & 0xf0) != 0xc0)
        failure = 1;

    //
    // make sure there is an entry in the M parameter table for this mode
    //

    MIndex = (HwDeviceExtension->AdapterMemorySize < 0x200000) ? 0 : 12;

    switch (HwDeviceExtension->ActiveFrequencyEntry->ScreenWidth) {

    case 640:
        MIndex += 0;
        break;

    case 800:
        MIndex += 4;
        break;

    case 1024:
        MIndex += 8;
        break;

    default:
        failure = 1;
        break;
    }

    switch (HwDeviceExtension->ActiveFrequencyEntry->BitsPerPel) {

    case 8:
        MIndex += 0;
        break;

    case 16:
        MIndex += 2;
        break;

    default:
        failure = 1;
        break;
    }

    switch (HwDeviceExtension->ActiveFrequencyEntry->ScreenFrequency) {

    case 60:
        MIndex += 0;
        break;

    case 72:
        MIndex += 1;
        break;

    default:
        failure = 1;
        break;
    }

    if (failure) {
        // reset lock registers to previous state
        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x38);
        VideoPortWritePortUchar(CRT_DATA_REG, old38);
        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x39);
        VideoPortWritePortUchar(CRT_DATA_REG, old39);

        return (FALSE);
    }

    //
    // set and enable L parameter, 1 Mb frame buffer configurations are
    // restricted to a 32 bit data path and therefore make twice as many
    // transfers
    //

    ScreenWidth = HwDeviceExtension->ActiveFrequencyEntry->ScreenWidth;
    ColorDepth  = HwDeviceExtension->ActiveFrequencyEntry->BitsPerPel;

    if (HwDeviceExtension->AdapterMemorySize < 0x200000)
        data16 = (USHORT) ((ScreenWidth * (ColorDepth / 8)) / 4);
    else
        data16 = (USHORT) ((ScreenWidth * (ColorDepth / 8)) / 8);

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x62);
    VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) (data16 & 0xff));
    data16 = (data16 >> 8) & 0x07;
    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x61);
    VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) ((data16 & 0x07) | 0x80));

    //
    // set Start Display FIFO register
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5d);
    data8 = VideoPortReadPortUchar(CRT_DATA_REG);
    data16 = data8 & 0x01;
    data16 <<= 8;
    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x00);
    data8 = VideoPortReadPortUchar(CRT_DATA_REG);
    data16 |= data8;
    data16 -= 5;        // typical CR3B is CR0 - 5 (with extension bits)

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x3b);
    VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) (data16 & 0xff));
    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5d);
    data8 = VideoPortReadPortUchar(CRT_DATA_REG);
    data8 &= 0xbf;
    data8 = data8 | (UCHAR) ((data16 & 0x100) >> 2);
    VideoPortWritePortUchar(CRT_DATA_REG, data8);

    //
    // enable Start Display FIFO register
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x34);
    data8 = VideoPortReadPortUchar(CRT_DATA_REG);
    data8 |= 0x10;
    VideoPortWritePortUchar(CRT_DATA_REG, data8);

    //
    // set M parameter
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x54);
    VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) MParameterTable[MIndex]);

    //
    // set N parameter
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x60);
    VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) 0xff);

    //
    // restore lock registers to previous state
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x38);
    VideoPortWritePortUchar(CRT_DATA_REG, old38);
    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x39);
    VideoPortWritePortUchar(CRT_DATA_REG, old39);

    return (TRUE);

}


VP_STATUS
QueryStreamsParameters(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    VIDEO_QUERY_STREAMS_MODE *pStreamsMode,
    VIDEO_QUERY_STREAMS_PARAMETERS *pStreamsParameters
    )

/*++

Routine Description:

    Queries various attributes of the card for later determine streams
    parameters for minimum horizontal stretch and FIFO control

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    RefreshRate - Supplies the exact refresh rate (a default rate of '1' will
                  not do).

    pWidthRatio - Returns the corresponding minimum horizontal stretch factor,
                  expressed as a multiple of 1000.

    pFifoValue - Returns the corresponding FIFO setting.

Return Value:

    TRUE if success, FALSE if failure

--*/

{
    ULONG BitsPerPel;
    ULONG ScreenWidth;
    ULONG RefreshRate;
    UCHAR MemoryFlags;
    ULONG n;
    ULONG m;
    ULONG r;
    ULONG mclock;
    ULONG MemorySpeed;
    K2TABLE* pEntry;
    ULONG MatchRefreshRate;
    ULONG MatchMemorySpeed;

    //
    // Copy the input parameters and round 15 up to 16.
    //

    BitsPerPel = (pStreamsMode->BitsPerPel + 1) & ~7;
    ScreenWidth = pStreamsMode->ScreenWidth;
    RefreshRate = pStreamsMode->RefreshRate;

    //
    // Determine the memory type and memory size.
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x36);
    MemoryFlags = (VideoPortReadPortUchar(CRT_DATA_REG) & 0x0c) >> 2;

    if (HwDeviceExtension->AdapterMemorySize != 0x100000) {

        MemoryFlags |= MEM_2MB;
    }

    //
    // Unlock sequencer registers.
    //

    VideoPortWritePortUshort(SEQ_ADDRESS_REG, 0x0608);

    //
    // Get memory speed, using some inexplicable code from S3.
    //

    VideoPortWritePortUchar(SEQ_ADDRESS_REG, 0x10);
    n = VideoPortReadPortUchar(SEQ_DATA_REG);
    VideoPortWritePortUchar(SEQ_ADDRESS_REG, 0x11);
    m = VideoPortReadPortUchar(SEQ_DATA_REG) & 0x7f;

    MemorySpeed = n | (m << 8);

    switch (MemorySpeed) {

    case 0x1A40:    // Known power-on default value
    case 0x2841:    // 50MHz
        MemorySpeed = 50;
        break;

    case 0x4142:    // 60MHz
        MemorySpeed = 60;
        break;

    case 0x3643:    // 40MHz
        MemorySpeed = 40;
        break;

    default:        // All others:
        r = (n >> 5) & 0x03;
        if (r == 0)
            r = 1;
        else
            r = 2 << (r-1);

        n = n & 0x1f;
        mclock = ((m + 2) * 14318L) / (((n + 2) * r) * 100L);
        MemorySpeed = mclock / 10;
        if ((mclock % 10) >= 5)
            MemorySpeed++;

        if (MemorySpeed < 40)
            MemorySpeed = 40;
        break;
    }

    pEntry = &K2WidthRatio[0];
    MatchRefreshRate = 0;
    MatchMemorySpeed = 0;

    while (pEntry->ScreenWidth != 0) {

        //
        // First find an exact match based on resolution, bits-per-pel,
        // memory type and size.
        //

        if ((pEntry->ScreenWidth == ScreenWidth) &&
            (pEntry->BitsPerPel == BitsPerPel) &&
            (pEntry->MemoryFlags == MemoryFlags)) {

            //
            // Now find the entry with the refresh rate and memory speed the
            // closest to, but not more than, our refresh rate and memory
            // speed.
            //

            if ((pEntry->RefreshRate <= RefreshRate) &&
                (pEntry->RefreshRate >= MatchRefreshRate) &&
                (pEntry->MemorySpeed <= MemorySpeed) &&
                (pEntry->MemorySpeed >= MatchMemorySpeed)) {

                MatchRefreshRate = pEntry->RefreshRate;
                MatchMemorySpeed = pEntry->MemorySpeed;
                pStreamsParameters->MinOverlayStretch = pEntry->Value;
            }
        }

        pEntry++;
    }

    if (MatchRefreshRate == 0) {

        return ERROR_INVALID_PARAMETER;
    }

    pEntry = &K2FifoValue[0];
    MatchRefreshRate = 0;
    MatchMemorySpeed = 0;

    while (pEntry->ScreenWidth != 0) {

        //
        // First find an exact match based on resolution, bits-per-pel,
        // memory type and size.
        //

        if ((pEntry->ScreenWidth == ScreenWidth) &&
            (pEntry->BitsPerPel == BitsPerPel) &&
            (pEntry->MemoryFlags == MemoryFlags)) {

            //
            // Now find the entry with the refresh rate and memory speed the
            // closest to, but not more than, our refresh rate and memory
            // speed.
            //

            if ((pEntry->RefreshRate <= RefreshRate) &&
                (pEntry->RefreshRate >= MatchRefreshRate) &&
                (pEntry->MemorySpeed <= MemorySpeed) &&
                (pEntry->MemorySpeed >= MatchMemorySpeed)) {

                MatchRefreshRate = pEntry->RefreshRate;
                MatchMemorySpeed = pEntry->MemorySpeed;
                pStreamsParameters->FifoValue = pEntry->Value;
            }
        }

        pEntry++;
    }

    if (MatchRefreshRate == 0) {

        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

/*****************************************************************************
 *
 *  FUNCTION NAME:  isMach()
 *
 *  DESCRIPTIVE NAME:
 *
 *  FUNCTION:       Determine if system is an IBM Mach
 *
 *
 *  NOTES:          Query the Vital Product Data (VPD) area
 *                  F000:FFA0 in ROM.
 *                  MACH Systems have "N", "P", "R", or "T" at location D
 *                  i.e. at F000:FFAD location
 *
 *  EXIT:           return code FALSE if not an IBM MACH System
 *                  return code TRUE  if a IBM MACH System
 *
 *  INTERNAL REFERENCES:
 *    ROUTINES:
 *
 *  EXTERNAL REFERENCES:
 *    ROUTINES:
 *
 ****************************************************************************/
BOOLEAN isMach(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    BOOLEAN ret = FALSE;
    PVOID   MappedVPDAddr = NULL;
    PHYSICAL_ADDRESS VPDPhysAddr;
    VPDPhysAddr.LowPart = 0x000fffad ;
    VPDPhysAddr.HighPart = 0x00000000 ;

    // Get the mapped address of the physical address F000:FFA0
    MappedVPDAddr = VideoPortGetDeviceBase(HwDeviceExtension,
                       VPDPhysAddr,
                       0x20,
                       0);

    if (MappedVPDAddr != NULL)
    {
        if ((VideoPortScanRom(HwDeviceExtension,
                                MappedVPDAddr,
                                1,
                                "N"))||
            (VideoPortScanRom(HwDeviceExtension,
                                MappedVPDAddr,
                                1,
                                "P"))||
            (VideoPortScanRom(HwDeviceExtension,
                                MappedVPDAddr,
                                1,
                                "R"))||
            (VideoPortScanRom(HwDeviceExtension,
                                MappedVPDAddr,
                                1,
                                "T")))
        {
            VideoPortFreeDeviceBase(HwDeviceExtension,
                                    MappedVPDAddr);
            ret = TRUE;
        }
    }

    return(ret);

}

VOID
WorkAroundForMach(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine will attempt to determine if we are running on an
    IBM Mach system.  If so, and and 868 card was detected, we
    will treat the card as an 864.

Arguments:

    HwDeviceExtension - pointer to the miniports device extension.

Return:

    none.

--*/

{
    if ((HwDeviceExtension->SubTypeID == SUBTYPE_868) &&
        isMach(HwDeviceExtension))
    {
        VideoDebugPrint((1, "S3 868 detected on IBM Mach.  Treat as 864.\n"));

        HwDeviceExtension->ChipID = S3_864;
        HwDeviceExtension->SubTypeID = SUBTYPE_864;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\mini\s3.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    s3.h

Abstract:

    This module contains the definitions for the S3 miniport driver.

Environment:

    Kernel mode

Revision History:

--*/

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

//
// We don't use the CRT 'min' function because that would drag in
// unwanted CRT baggage.
//

#define MIN(a, b) ((a) < (b) ? (a) : (b))

//
// Size of the ROM we map in
//

#define MAX_ROM_SCAN    512

//
// Number of access ranges used by an S3.
//

#define NUM_S3_ACCESS_RANGES 36
#define NUM_S3_ACCESS_RANGES_USED 22
#define NUM_S3_PCI_ACCESS_RANGES 2
#define S3_EXTENDED_RANGE_START 4

//
// Index of Frame buffer in access range array
//

#define A000_FRAME_BUF   1
#define LINEAR_FRAME_BUF 36

//
// Constants defining 'New Memory-mapped I/O' window:
//

#define NEW_MMIO_WINDOW_SIZE    0x4000000   // Total window size -- 64 MB
#define NEW_MMIO_IO_OFFSET      0x1000000   // Offset to start of little endian
                                            //   control registers -- 16 MB
#define NEW_MMIO_IO_LENGTH      0x0020000   // Length of control registers
                                            //   -- 128 KB

////////////////////////////////////////////////////////////////////////
// Capabilities flags
//
// These are private flags passed to the S3 display driver.  They're
// put in the high word of the 'AttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to the display driver via an 'VIDEO_QUERY_AVAIL_MODES' or
// 'VIDEO_QUERY_CURRENT_MODE' IOCTL.
//
// NOTE: These definitions must match those in the S3 display driver's
//       'driver.h'!

typedef enum {
    CAPS_STREAMS_CAPABLE    = 0x00000040,   // Has overlay streams processor
    CAPS_FORCE_DWORD_REREADS= 0x00000080,   // Dword reads occasionally return
                                            //   an incorrect result, so always
                                            //   retry the reads
    CAPS_NEW_MMIO           = 0x00000100,   // Can use 'new memory-mapped
                                            //   I/O' scheme introduced with
                                            //   868/968
    CAPS_POLYGON            = 0x00000200,   // Can do polygons in hardware
    CAPS_24BPP              = 0x00000400,   // Has 24bpp capability
    CAPS_BAD_24BPP          = 0x00000800,   // Has 868/968 early rev chip bugs
                                            //   when at 24bpp
    CAPS_PACKED_EXPANDS     = 0x00001000,   // Can do 'new 32-bit transfers'
    CAPS_PIXEL_FORMATTER    = 0x00002000,   // Can do colour space conversions,
                                            //   and one-dimensional hardware
                                            //   stretches
    CAPS_BAD_DWORD_READS    = 0x00004000,   // Dword or word reads from the
                                            //   frame buffer will occasionally
                                            //   return an incorrect result,
                                            //   so always do byte reads
    CAPS_NO_DIRECT_ACCESS   = 0x00008000,   // Frame buffer can't be directly
                                            //   accessed by GDI or DCI --
                                            //   because dword or word reads
                                            //   would crash system, or Alpha
                                            //   is running in sparse space

    CAPS_HW_PATTERNS        = 0x00010000,   // 8x8 hardware pattern support
    CAPS_MM_TRANSFER        = 0x00020000,   // Memory-mapped image transfers
    CAPS_MM_IO              = 0x00040000,   // Memory-mapped I/O
    CAPS_MM_32BIT_TRANSFER  = 0x00080000,   // Can do 32bit bus size transfers
    CAPS_16_ENTRY_FIFO      = 0x00100000,   // At least 16 entries in FIFO
    CAPS_SW_POINTER         = 0x00200000,   // No hardware pointer; use software
                                            //   simulation
    CAPS_BT485_POINTER      = 0x00400000,   // Use Brooktree 485 pointer
    CAPS_TI025_POINTER      = 0x00800000,   // Use TI TVP3020/3025 pointer
    CAPS_SCALE_POINTER      = 0x01000000,   // Set if the S3 hardware pointer
                                            //   x position has to be scaled by
                                            //   two
    CAPS_SPARSE_SPACE       = 0x02000000,   // Frame buffer is mapped in sparse
                                            //   space on the Alpha
    CAPS_NEW_BANK_CONTROL   = 0x04000000,   // Set if 801/805/928 style banking
    CAPS_NEWER_BANK_CONTROL = 0x08000000,   // Set if 864/964 style banking
    CAPS_RE_REALIZE_PATTERN = 0x10000000,   // Set if we have to work around the
                                            //   864/964 hardware pattern bug
    CAPS_SLOW_MONO_EXPANDS  = 0x20000000,   // Set if we have to slow down
                                            //   monochrome expansions
    CAPS_MM_GLYPH_EXPAND    = 0x40000000,   // Use memory-mapped I/O glyph-
                                            //   expand method of drawing text
    CAPS_WAIT_ON_PALETTE    = 0x80000000,   // Wait for vertical retrace before
                                            //   setting the palette registers
} CAPS;

#define CAPS_DAC_POINTER    (CAPS_BT485_POINTER | CAPS_TI025_POINTER)

//
// Supported board definitions.
//

typedef enum _S3_BOARDS {
    S3_GENERIC = 0,
    S3_ORCHID,
    S3_NUMBER_NINE,
    S3_DELL,
    S3_METHEUS,
    S3_DIAMOND,
    S3_HP,
    S3_IBM_PS2,
    MAX_S3_BOARD
} S3_BOARDS;

//
// Chip type definitions -- for families of chips
//
// if you change this typedef it will change the size of the second element
// (named Fixed) of the union in the typedef for S3_VIDEO_FREQUENCIES and
// PS3_VIDEO_FREQUENCIES, look at that typedef for a caution about the effect
// this will have on autoinitialization
//

typedef enum _S3_CHIPSETS {
    S3_911 = 0,    // 911 and 924 boards
    S3_801,        // 801 and 805 boards
    S3_928,        // 928 boards
    S3_864,        // 864, 964, 732, 764, and 765 boards
    S3_866,        // 866, 868, and 968 boards
    MAX_S3_CHIPSET
} S3_CHIPSETS;

//
// Chip subtypes -- for more differentiation within families
//
// Note that ordering is important.
//

typedef enum _S3_SUBTYPE {
    SUBTYPE_911 = 0,    // 911 and 924
    SUBTYPE_80x,        // 801 and 805
    SUBTYPE_928,        // 928 and 928PCI
    SUBTYPE_805i,       // 805i
    SUBTYPE_864,        // 864
    SUBTYPE_964,        // 964
    SUBTYPE_764,        // Trio64
    SUBTYPE_732,        // Trio32
    SUBTYPE_866,        // 866
    SUBTYPE_868,        // 868
    SUBTYPE_765,        // Trio64 V+
    SUBTYPE_968,        // 968
    MAX_S3_SUBTYPE
} S3_SUBTYPE;

//
// DAC type definitions
//

typedef enum _S3_DACS {
    UNKNOWN_DAC = 0,    // unknown DAC type
    BT_485,             // Brooktree's Bt 485
    TI_3020,            // TI's 3020 or 3025
    S3_SDAC,            // S3's SDAC
    MAX_S3_DACS
} S3_DACS;

//
// Hardware pointer capabilities flags
//

typedef enum _POINTER_CAPABILITY {
    POINTER_BUILT_IN            = 0x01, // A pointer is built in to the hardware
    POINTER_WORKS_ONLY_AT_8BPP  = 0x02, // If set, the hardware pointer works
                                        //   only at 8bpp, and only for modes
                                        //   1024x768 or less
    POINTER_NEEDS_SCALING       = 0x04, // x-coordinate must be scaled by 2 at
                                        //   32bpp
} POINTER_CAPABILITY;

//
// Characteristics of each mode
//

typedef struct _S3_VIDEO_MODES {

    USHORT Int10ModeNumberContiguous;
    USHORT Int10ModeNumberNoncontiguous;
    ULONG ScreenStrideContiguous;

    VIDEO_MODE_INFORMATION ModeInformation;

} S3_VIDEO_MODES, *PS3_VIDEO_MODES;

//
// Mode-set specific information.
//

typedef struct _S3_VIDEO_FREQUENCIES {

    ULONG BitsPerPel;
    ULONG ScreenWidth;
    ULONG ScreenFrequency;
    union {

        //
        // The compiler uses the first element of a union to determine where
        // it places the values given when the union is autoinitialized.
        //
        // If size of the Fixed element of this union is changed by adding
        // chips to the enum typedef for S3_CHIPSET then the Int10 element
        // needs to be padded with dummy fields to make autoinitialization
        // of the Fixed element work correctly.
        //
        // If values are removed from the S3_CHIPSET typedef then either the
        // Int10 element should shrunk by removing pads or the Fixed element
        // should be padded.
        //

        struct {

            ULONG_PTR FrequencyPrimarySet;
            ULONG_PTR FrequencyPrimaryMask;
            ULONG_PTR FrequencySecondarySet;
            ULONG_PTR FrequencySecondaryMask;
            ULONG_PTR SizePad0;             // make struct sizes match

        } Int10;

        struct {

            union {

                //
                // This is done so that Clock overlays FrequencyPrimarySet
                // and CRTCTable[1] overlays FrequencyPrimaryMask, whether
                // we are compiling for 32 or 64 bits.
                //

                ULONG Clock;
                ULONG_PTR Pad;
            };
            PUSHORT CRTCTable[MAX_S3_CHIPSET];

        } Fixed;
    };

    PS3_VIDEO_MODES ModeEntry;
    ULONG ModeIndex;
    UCHAR ModeValid;

} S3_VIDEO_FREQUENCIES, *PS3_VIDEO_FREQUENCIES;

//
// Streams parameter information.
//

typedef struct _K2TABLE {
    USHORT  ScreenWidth;
    UCHAR   BitsPerPel;
    UCHAR   RefreshRate;
    UCHAR   MemoryFlags;
    UCHAR   MemorySpeed;
    ULONG   Value;
} K2TABLE;

#define MEM_1EDO 0x0
#define MEM_2EDO 0x2
#define MEM_FAST 0x3
#define MEM_TYPE_MASK 0x3

#define MEM_1MB 0x0
#define MEM_2MB 0x10
#define MEM_SIZE_MASK 0x10

//
// Private IOCTL for communicating S3 streams parameters.  These definitions
// must match those in the display driver!
//

#define IOCTL_VIDEO_S3_QUERY_STREAMS_PARAMETERS                        \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _VIDEO_QUERY_STREAMS_MODE {
    ULONG ScreenWidth;
    ULONG BitsPerPel;
    ULONG RefreshRate;
} VIDEO_QUERY_STREAMS_MODE;

typedef struct _VIDEO_QUERY_STREAMS_PARAMETERS {
    ULONG MinOverlayStretch;
    ULONG FifoValue;
} VIDEO_QUERY_STREAMS_PARAMETERS;


//
// Register definitions used with VideoPortRead/Write functions
//
// It's a good idea to write your miniport to allow for easy register
// re-mapping, but I wouldn't recommend that anyone use this particular
// implementation because it's pretty dumb.
//

#define DAC_PIXEL_MASK_REG     (PVOID)((PUCHAR)((PHW_DEVICE_EXTENSION)HwDeviceExtension)->MappedAddress[2] + (0x03C6 - 0x03C0))
#define BT485_ADDR_CMD_REG0    (PVOID)((PUCHAR)((PHW_DEVICE_EXTENSION)HwDeviceExtension)->MappedAddress[2] + (0x03C6 - 0x03C0))
#define TI025_INDEX_REG        (PVOID)((PUCHAR)((PHW_DEVICE_EXTENSION)HwDeviceExtension)->MappedAddress[2] + (0x03C6 - 0x03C0))
#define TI025_DATA_REG         (PVOID)((PUCHAR)((PHW_DEVICE_EXTENSION)HwDeviceExtension)->MappedAddress[2] + (0x03C7 - 0x03C0))
#define CRT_DATA_REG           (PVOID)((PUCHAR)((PHW_DEVICE_EXTENSION)HwDeviceExtension)->MappedAddress[3] + (0x03D5 - 0x03D4))
#define SYSTEM_CONTROL_REG     (PVOID)((PUCHAR)((PHW_DEVICE_EXTENSION)HwDeviceExtension)->MappedAddress[3] + (0x03DA - 0x03D4))

#define CRT_ADDRESS_REG        ((PHW_DEVICE_EXTENSION)HwDeviceExtension)->MappedAddress[3]
#define GP_STAT                ((PHW_DEVICE_EXTENSION)HwDeviceExtension)->MappedAddress[12]        // 0x9AE8

#define DAC_ADDRESS_WRITE_PORT (PVOID)((PUCHAR)HwDeviceExtension->MappedAddress[2] + (0x03C8 - 0x03C0))
#define DAC_DATA_REG_PORT      (PVOID)((PUCHAR)HwDeviceExtension->MappedAddress[2] + (0x03C9 - 0x03C0))
#define MISC_OUTPUT_REG_WRITE  (PVOID)((PUCHAR)HwDeviceExtension->MappedAddress[2] + (0x03C2 - 0x03C0))
#define MISC_OUTPUT_REG_READ   (PVOID)((PUCHAR)HwDeviceExtension->MappedAddress[2] + (0x03CC - 0x03C0))
#define SEQ_ADDRESS_REG        (PVOID)((PUCHAR)HwDeviceExtension->MappedAddress[2] + (0x03C4 - 0x03C0))
#define SEQ_DATA_REG           (PVOID)((PUCHAR)HwDeviceExtension->MappedAddress[2] + (0x03C5 - 0x03C0))




#define IOCTL_PRIVATE_GET_FUNCTIONAL_UNIT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x180, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _FUNCTIONAL_UNIT_INFO {
    ULONG FunctionalUnitID;
    ULONG Reserved;
} FUNCTIONAL_UNIT_INFO, *PFUNCTIONAL_UNIT_INFO;

//
// Define device extension structure. This is device dependent/private
// information.
//

typedef struct _HW_DEVICE_EXTENSION {
    PHYSICAL_ADDRESS PhysicalFrameAddress;
    ULONG PhysicalFrameIoSpace;
    ULONG FrameLength;
    PHYSICAL_ADDRESS PhysicalRegisterAddress;
    ULONG RegisterLength;
    UCHAR RegisterSpace;
    PHYSICAL_ADDRESS PhysicalMmIoAddress;
    ULONG MmIoLength;
    ULONG ChildCount;
    UCHAR MmIoSpace;
    UCHAR FrequencySecondaryIndex;
    UCHAR BiosPresent;
    UCHAR CR5C;
    BOOLEAN bNeedReset;
    PUCHAR MmIoBase;
    PS3_VIDEO_MODES ActiveModeEntry;
    PS3_VIDEO_FREQUENCIES ActiveFrequencyEntry;
    PS3_VIDEO_FREQUENCIES Int10FrequencyTable;
    PS3_VIDEO_FREQUENCIES FixedFrequencyTable;
    USHORT PCIDeviceID;
    ULONG FunctionalUnitID;
    ULONG BoardID;
    S3_CHIPSETS ChipID;
    S3_SUBTYPE  SubTypeID;
    ULONG DacID;
    ULONG Capabilities;
    ULONG NumAvailableModes;
    ULONG NumTotalModes;
    ULONG AdapterMemorySize;
    PVOID MappedAddress[NUM_S3_ACCESS_RANGES];
} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


//
// SDAC M and N paramaters
//

typedef struct {
    UCHAR   m;
    UCHAR   n;
} SDAC_PLL_PARMS;

#define SDAC_TABLE_SIZE         16


//
// Highest valid DAC color register index.
//

#define VIDEO_MAX_COLOR_REGISTER  0xFF

//
// Data
//

//
// Global Physical Access Ranges.
// Logical access ranges must be stored in the HwDeviceExtension so different
// addresses can be used for different boards.
//

extern VIDEO_ACCESS_RANGE S3AccessRanges[];

//
// Memory Size array
//

extern ULONG gacjMemorySize[];

//
// nnlck.c clock generator table
//

extern long vclk_range[];

//
// Hard-coded modeset tables
//

extern USHORT  s3_set_vga_mode[];
extern USHORT  s3_set_vga_mode_no_bios[];

extern USHORT  S3_911_Enhanced_Mode[];
extern USHORT  S3_801_Enhanced_Mode[];
extern USHORT  S3_928_Enhanced_Mode[];
extern USHORT  S3_928_1280_Enhanced_Mode[];

//
//  Externs for 864 PPC board
//

extern USHORT  S3_864_Enhanced_Mode[];
extern USHORT  S3_864_1280_Enhanced_Mode[];
extern SDAC_PLL_PARMS SdacTable[];
extern UCHAR MParameterTable[];

//
// Hard-coded modeset frequency tables
//

extern S3_VIDEO_FREQUENCIES GenericFixedFrequencyTable[];
extern S3_VIDEO_FREQUENCIES OrchidFixedFrequencyTable[];
extern S3_VIDEO_FREQUENCIES NumberNine928NewFixedFrequencyTable[];

//
// Int 10 frequency tables
//

extern S3_VIDEO_FREQUENCIES GenericFrequencyTable[];
extern S3_VIDEO_FREQUENCIES Dell805FrequencyTable[];
extern S3_VIDEO_FREQUENCIES NumberNine928NewFrequencyTable[];
extern S3_VIDEO_FREQUENCIES NumberNine928OldFrequencyTable[];
extern S3_VIDEO_FREQUENCIES Metheus928FrequencyTable[];
extern S3_VIDEO_FREQUENCIES Generic64NewFrequencyTable[];
extern S3_VIDEO_FREQUENCIES Generic64OldFrequencyTable[];
extern S3_VIDEO_FREQUENCIES NumberNine64FrequencyTable[];
extern S3_VIDEO_FREQUENCIES Diamond64FrequencyTable[];
extern S3_VIDEO_FREQUENCIES HerculesFrequencyTable[];
extern S3_VIDEO_FREQUENCIES Hercules64FrequencyTable[];
extern S3_VIDEO_FREQUENCIES Hercules68FrequencyTable[];
//
// Mode Tables
//

extern S3_VIDEO_MODES S3Modes[];
extern ULONG NumS3VideoModes;

//
// Streams Tables
//

extern K2TABLE K2WidthRatio[];
extern K2TABLE K2FifoValue[];

//
// Function prototypes
//

//
// sdac.c
//

BOOLEAN
InitializeSDAC(
    PHW_DEVICE_EXTENSION
    );

BOOLEAN
FindSDAC(
    PHW_DEVICE_EXTENSION
    );

//
// nnclk.c
//

long calc_clock(long, int);
long gcd(long, long);
VOID set_clock(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    LONG clock_value);

//
// S3.c
//

ULONG
S3GetChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    );

VP_STATUS
GetDeviceDataCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PVOID Identifier,
    ULONG IdentifierLength,
    PVOID ConfigurationData,
    ULONG ConfigurationDataLength,
    PVOID ComponentInformation,
    ULONG ComponentInformationLength
    );

VP_STATUS
S3FindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
S3Initialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
S3ResetHw(
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    );

BOOLEAN
S3StartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

VP_STATUS
S3SetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    );

VOID
SetHWMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pusCmdStream
    );

VP_STATUS
S3RegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

LONG
CompareRom(
    PUCHAR Rom,
    PUCHAR String
    );

VOID
MapLinearControlSpace(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
S3IsaDetection(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PULONG key
    );

VOID
S3GetInfo(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    POINTER_CAPABILITY *PointerCapability,
    VIDEO_ACCESS_RANGE accessRange[]
    );

VOID
S3DetermineFrequencyTable(
    PVOID HwDeviceExtension,
    VIDEO_ACCESS_RANGE accessRange[],
    INTERFACE_TYPE AdapterInterfaceType
    );

VOID
S3DetermineDACType(
    PVOID HwDeviceExtension,
    POINTER_CAPABILITY *PointerCapability
    );

VOID
S3ValidateModes(
    PVOID HwDeviceExtension,
    POINTER_CAPABILITY *PointerCapability
    );

VOID
S3DetermineMemorySize(
    PVOID HwDeviceExtension
    );

VOID
S3RecordChipType(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PULONG key
    );

VOID
AlphaDetermineMemoryUsage(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    VIDEO_ACCESS_RANGE accessRange[]
    );


ULONG
UnlockExtendedRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
LockExtendedRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG key
    );

//
// Non-int 10 platform support
//

VOID
ZeroMemAndDac(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VP_STATUS
Set_Oem_Clock(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VP_STATUS
Wait_VSync(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
Bus_Test(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
Set864MemoryTiming(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );



BOOLEAN
S3ConfigurePCI(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PULONG NumPCIAccessRanges,
    PVIDEO_ACCESS_RANGE PCIAccessRanges
    );

VP_STATUS
QueryStreamsParameters(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    VIDEO_QUERY_STREAMS_MODE *pStreamsMode,
    VIDEO_QUERY_STREAMS_PARAMETERS *pStreamsParameters
    );

VOID
WorkAroundForMach(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );


//
// ddc.c
//

BOOLEAN
GetDdcInformation (
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PUCHAR QueryBuffer,
    ULONG BufferSize
    );

//
// power management
//

VP_STATUS
S3GetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    );

VP_STATUS
S3SetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    );

#define VESA_POWER_FUNCTION 0x4f10
#define VESA_POWER_ON       0x0000
#define VESA_POWER_STANDBY  0x0100
#define VESA_POWER_SUSPEND  0x0200
#define VESA_POWER_OFF      0x0400
#define VESA_GET_POWER_FUNC 0x0000
#define VESA_SET_POWER_FUNC 0x0001
#define VESA_STATUS_SUCCESS 0x004f
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\mini\sdac.c ===
/*++

Copyright (c) 1994-1995  International Buisness Machines Corporation
Copyright (c) 1994-1995  Microsoft Corporation

Module Name:

    sdac.c

Abstract:

    This module contains the code that initializes the S3 SDAC.

Environment:

    Kernel mode

Revision History:

--*/

#include    "s3.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,InitializeSDAC)
#pragma alloc_text(PAGE,FindSDAC)
#endif


BOOLEAN
InitializeSDAC( PHW_DEVICE_EXTENSION HwDeviceExtension )

/*++

Routine Description:

    Initializes the SDAC.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

    Always TRUE

--*/

{

    SDAC_PLL_PARMS
        *SdacClk0;

    ULONG
        tablebase;

    UCHAR
        i,
        clk,
        dval,
        old55;


    tablebase = HwDeviceExtension->ActiveFrequencyEntry->Fixed.Clock;
    clk = (UCHAR) tablebase;

    tablebase = (tablebase < 8) ? 0 : ((tablebase - 2) / 6) * 6;
    SdacClk0 = &SdacTable[tablebase];

    clk -= (UCHAR) tablebase;
    clk |= 0x20;

    // set RS[2] with CR55[0];
    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x55);
    dval  = VideoPortReadPortUchar(CRT_DATA_REG);
    old55 = dval;
    dval &= 0xfc;
    dval |= 0x01;
    VideoPortWritePortUchar(CRT_DATA_REG, dval);
    VideoPortReadPortUchar(CRT_DATA_REG);

    // Enhanced Command Register
    if( HwDeviceExtension->ActiveFrequencyEntry->BitsPerPel == 16 )
        VideoPortWritePortUchar(DAC_PIXEL_MASK_REG, 0x50);
    else
        VideoPortWritePortUchar(DAC_PIXEL_MASK_REG, 0x00);

    // Program CLK0 registers
    for( i = 2; i < 8; ++i )    // write registers f2 - f7 only
        {
        // make sure we don't run off the end of the table
        if( (ULONG_PTR) &SdacClk0[i] >= (ULONG_PTR) &SdacTable[SDAC_TABLE_SIZE] )
            break;

        if( SdacClk0[i].m || SdacClk0[i].n )
            {
            VideoPortWritePortUchar(DAC_ADDRESS_WRITE_PORT, i);
            VideoPortWritePortUchar(DAC_DATA_REG_PORT, SdacClk0[i].m);
            VideoPortWritePortUchar(DAC_DATA_REG_PORT, SdacClk0[i].n);
            }
        }

    // Program CLK1
    VideoPortWritePortUchar(DAC_ADDRESS_WRITE_PORT, 0x0a);
    VideoPortWritePortUchar(DAC_DATA_REG_PORT, 0x41);
    VideoPortWritePortUchar(DAC_DATA_REG_PORT, 0x26);

    // select CLK0 with the PLL control register
    VideoPortWritePortUchar(DAC_ADDRESS_WRITE_PORT, 0x0e);
    VideoPortWritePortUchar(DAC_DATA_REG_PORT, clk);

    // restore CR55
    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x55);
    VideoPortWritePortUchar(CRT_DATA_REG, old55);

    return( TRUE );

}



BOOLEAN
FindSDAC( PHW_DEVICE_EXTENSION HwDeviceExtension )

/*++

Routine Description:

    Detects and S3 SDAC.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

    TRUE if SDAC detected; FALSE if not.

--*/

{

    UCHAR
            regval,
            old55;


    // 4 consecutive reads of the SDAC's Pixel Mask Register cause
    // the next access to that register to be redirected to the
    // SDAC's Enhanced Command Register, additionally the 4th read
    // returns 0x70 to identify the SDAC

    // set CR55[0] to access the Pixel Mask Register
    VideoPortWritePortUchar( CRT_ADDRESS_REG, 0x55 );
    old55 = VideoPortReadPortUchar( CRT_DATA_REG );
    VideoPortWritePortUchar( CRT_DATA_REG, (UCHAR) (old55 & 0xfc) );

    // look for the SDAC's ID
    VideoPortWritePortUchar( DAC_PIXEL_MASK_REG, 0 );
    VideoPortWritePortUchar( DAC_PIXEL_MASK_REG, 0xff );
    VideoPortReadPortUchar(  DAC_PIXEL_MASK_REG );
    VideoPortReadPortUchar(  DAC_PIXEL_MASK_REG );
    VideoPortReadPortUchar(  DAC_PIXEL_MASK_REG );

    regval = VideoPortReadPortUchar( DAC_PIXEL_MASK_REG );

    if( (regval & 0xf0) == 0x70 )
        {
        // clear the redirection
        VideoPortReadPortUchar( DAC_PIXEL_MASK_REG );
        return( TRUE );
        }

    // restore the contents of register 55
    VideoPortWritePortUchar( CRT_ADDRESS_REG, 0x55 );
    VideoPortWritePortUchar( CRT_DATA_REG, old55 );

    return( FALSE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\moninf\comalias.cpp ===
#include "stdafx.h"
#include "mon.h"

CCommonAlias gCommonAlias;

int compareCommonAlias(LPCOMMON_ALIAS p1, LPCOMMON_ALIAS p2)
{
   return (stricmp(p1->lpAlias, p2->lpAlias));
}

CCommonAlias::CCommonAlias()
{
	m_Alias.RemoveAll();
}

CCommonAlias::~CCommonAlias()
{
	ClearAll();
}
VOID CCommonAlias::ClearAll(VOID)
{
	for (int i = 0; i < m_Alias.GetSize(); i++)
		free (m_Alias[i]);
	m_Alias.RemoveAll();
}

LPCOMMON_ALIAS CCommonAlias::AddOneAlias(LPSTR lpAlias, LPSTR lpContents)
{
	LPCOMMON_ALIAS pNewAlias = (PCOMMON_ALIAS)malloc(sizeof(COMMON_ALIAS)
                                                     + lstrlen(lpAlias)
                                                     + lstrlen(lpContents) + 2);
	if (pNewAlias == NULL)
    {
        ASSERT(FALSE);
        return NULL;
    }

	pNewAlias->lpAlias = (LPSTR)(pNewAlias + 1);
    pNewAlias->lpContents = pNewAlias->lpAlias + lstrlen(lpAlias)+1;
    strcpy(pNewAlias->lpAlias, lpAlias);
	strcpy(pNewAlias->lpContents, lpContents);

	int comp = 1;
	for (int i = 0; i < m_Alias.GetSize(); i++)
	{
		LPCOMMON_ALIAS pAlias = (LPCOMMON_ALIAS)m_Alias[i];
		comp = compareCommonAlias(pNewAlias, pAlias);

		if (comp > 0)
			continue;
		else if (comp < 0)
            break;

        if (strcmp(pNewAlias->lpContents, pAlias->lpContents))
        {
            sprintf(gszMsg, "Alias %%%s%% has conflicting contents:\n\n%s\n%s", 
                    lpAlias, pNewAlias->lpContents, pAlias->lpContents);
            MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);

            ASSERT(FALSE);
        }

        break;
	}
	if (comp == 0)
	{
		free(pNewAlias);
	}
	else
	{
		m_Alias.InsertAt(i, (LPVOID)pNewAlias);
	}

	return (LPCOMMON_ALIAS)m_Alias[i];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\mini\s3ddc.c ===
//***************************************************************************
//  Module Name:    s3ddc.c
//
//  Description:    This module checks for a DDC monitor, and returns the 
//                  128 bytes of EDID table if found.  
//
//  Notes:          The routine, DdcSetupRefresh, keeps track of resolution
//                  changes in the registry.  On a resolution change,
//                  DdcSetupRefresh will select the optimal refresh rate.  If
//                  there is NOT any change in the resolution, the user can 
//                  select any refresh rate, as long as the monitor and
//                  driver can support it.
//
//  Copyright (c) 1996  S3, Inc.
//
//***************************************************************************
//@@BEGIN_S3MSINTERNAL
//
//  Revision History:
//
//  $Log:   Q:/SOFTDEV/VCS/NT/MINIPORT/s3ddc.c_v  $
//
//   Rev 1.13   04 Feb 1997 23:40:52   kkarnos
//Added BEGIN/END S3MSINTERNAL blocks.
//
//   Rev 1.12   30 Jan 1997 14:56:24   bryhti
//Fixed the refresh frequency calculation in the Detailed Timing section
//of DdcMaxRefresh - was causing problems in NT 3.51.
//
//   Rev 1.11   30 Jan 1997 09:47:36   bryhti
//Fixed the "for" loop count for Standard Timings in DdcMaxRefresh.
//
//   Rev 1.10   16 Jan 1997 09:21:28   bryhti
//Added CheckDDCType routine to return monitor DDC type.
//
//   Rev 1.9   11 Dec 1996 10:24:38   kkarnos
//
//Fix Set_VSYNC.
//
//   Rev 1.8   10 Dec 1996 16:45:42   kkarnos
//Just added a comment to explain the source of some odd 764 code (EKL input)
//
//   Rev 1.7   10 Dec 1996 16:37:08   kkarnos
//Use register and register bit defines.  Correct assignment of SET VSYNC bit
//
//   Rev 1.6   02 Dec 1996 07:46:16   bryhti
//
//Moved GetDdcInformation () prototype to S3.H.  Added code to
//DdcMaxRefresh () to also check the Detailed Timing Descriptions.
//
//   Rev 1.5   13 Nov 1996 10:14:08   bryhti
//Major cleanup/rewrite to get DDC1 and DDC2 support on M65.  Also got DDC1
//support working on 765.
//
//   Rev 1.4   02 Oct 1996 13:56:42   elau
//765 and new chips support DDC; the newer chip must have a serial port at FF20
//
//   Rev 1.3   22 Aug 1996 11:44:40   elau
//Change int to ULONG to remove warning
//
//   Rev 1.2   18 Aug 1996 16:30:42   elau
//Use HW default setting for DDC if supports
//
//   Rev 1.1   24 Jul 1996 15:37:42   elau
//DDC support for 764
//
//   Rev 1.0   12 Jul 1996 11:52:36   elau
//Initial revision.
//
//@@END_S3MSINTERNAL
//***************************************************************************

#include "s3.h"
#include "cmdcnst.h"

#include "s3ddc.h"

#define     MMFF20  (PVOID) ((ULONG)(HwDeviceExtension->MmIoBase) + SERIAL_PORT_MM)

#define     NO_FLAGS        0
#define     VERIFY_CHECKSUM 1

//
//  Function Prototypes
//
VOID    I2C_Out (PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData);
VOID    I2C_Setup (PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID    I2C_StartService (PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID    I2C_StopService (PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID    I2C_BitWrite (PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData);
VOID    I2C_AckWrite (PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID    I2C_NackWrite (PHW_DEVICE_EXTENSION HwDeviceExtension);
UCHAR   I2C_ByteWrite (PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData);
UCHAR   I2C_BitRead (PHW_DEVICE_EXTENSION HwDeviceExtension);
UCHAR   I2C_ByteRead (PHW_DEVICE_EXTENSION HwDeviceExtension);
UCHAR   I2C_Data_Request (PHW_DEVICE_EXTENSION, UCHAR, long, long, UCHAR *);

VOID    Wait_For_Active (PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID    Set_Vsync (PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucFlag);
VOID    Provide_Fake_VSYNC (PHW_DEVICE_EXTENSION HwDeviceExtension);
UCHAR   Read_EDID_Byte (PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID    Disable_DAC_Video (PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID    Enable_DAC_Video (PHW_DEVICE_EXTENSION HwDeviceExtension);
UCHAR   Read_EDID_Bit (PHW_DEVICE_EXTENSION HwDeviceExtension);
UCHAR   Read_EDID_Byte (PHW_DEVICE_EXTENSION HwDeviceExtension);

UCHAR   Sync_EDID_Header (PHW_DEVICE_EXTENSION HwDeviceExtension);
UCHAR   EDID_Buffer_Xfer (PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR* pBuffer);

UCHAR   Check_DDC1_Monitor (PHW_DEVICE_EXTENSION HwDeviceExtension);
UCHAR   Configure_Chip_DDC_Caps (PHW_DEVICE_EXTENSION HwDeviceExtension);
UCHAR   GetDdcInformation (PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR* pBuffer);


/****************************************************************
;       I2C_Out
;
;       Controls the individual toggling of bits in MMFF20 to produce
;       clock and data pulses, and in the end provides a delay.
;
; MMIO FF20h is defined as follows:
;
;      ...  3   2   1   0    SCW = CLK  Write
; --------|---|---|---|---|  SDW = DATA Write
;      ...|SDR|SCR|SDW|SCW|  SCR = CLK  Read
; -------------------------  SDR = DATA Read
;
;       Input:  
;               Using MMIO Base in PHW_DEVICE_EXTENSION 
;               UCHAR ucData
;                   Bit 7:2 = 0
;                   Bit 1   = SDA
;                   Bit 0   = SCL
;       Output:
;
;****************************************************************/

VOID I2C_Out (PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData)
{

    UCHAR ucPortData;
    unsigned int uCount;

    //
    //  read the current value, clear the clock and data bits, and add
    //  the new clock and data values
    //
        
    ucPortData = (VideoPortReadRegisterUchar (MMFF20) & 0xFC) | ucData;

    VideoPortWriteRegisterUchar (MMFF20, ucPortData);

    //
    //  if we set the clock high, wait for target to set clock high
    //

    if (ucData & 0x01)
    {
        uCount = 2000;
        do
        {
            --uCount;
            ucPortData = VideoPortReadRegisterUchar (MMFF20) & 0x04;

        } while ( !ucPortData && uCount );
    }

    VideoPortStallExecution(5);
}		



/****************************************************************
;   I2C_Setup
;
;   Allow one very long low clock pulse so that monitor has time 
;   to switch to DDC2 mode.
;
;   Input:  
;       Using MMIO Base in PHW_DEVICE_EXTENSION 
;
;   Output:
;
;****************************************************************/

VOID I2C_Setup (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    //
    //  CLK=low,  DATA=high
    //

    I2C_Out (HwDeviceExtension, 0x02); 

    Wait_For_Active (HwDeviceExtension);
    Wait_For_Active (HwDeviceExtension);

    //
    //  CLK=high, DATA=high
    //

    I2C_Out (HwDeviceExtension, 0x03); 

    Wait_For_Active (HwDeviceExtension);
    Wait_For_Active (HwDeviceExtension);

}

/****************************************************************
;   I2C_StartService
;
;   Provide start sequence for talking to I2C bus.
;
;   Input:  
;       Using MMIO Base in PHW_DEVICE_EXTENSION 
;
;   Output:
;
;****************************************************************/

VOID I2C_StartService (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    //
    //  CLK=low, DATA=high
    //

    I2C_Out (HwDeviceExtension, 0x02); 

    //
    //  CLK=high, DATA=high
    //

    I2C_Out (HwDeviceExtension, 0x03); 


    //
    //  CLK=high, DATA=low
    //

    I2C_Out (HwDeviceExtension, 0x01); 

    //
    //  CLK=low, DATA=low
    //

    I2C_Out (HwDeviceExtension, 0x00); 

}

/****************************************************************
;   I2C_StopService
;
;   Provide stop sequence to the I2C bus.
;
;   Input:  
;       Using MMIO Base in PHW_DEVICE_EXTENSION 
;
;   Output:
;
;***************************************************************/

VOID I2C_StopService (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    //
    //  CLK=low, DATA=low
    //

    I2C_Out (HwDeviceExtension, 0x00); 

    //
    //  CLK=high, DATA=low
    //

    I2C_Out (HwDeviceExtension, 0x01); 

    //
    //  CLK=high, DATA=high
    //

    I2C_Out (HwDeviceExtension, 0x03); 

    //
    //  CLK=low, DATA=high
    //

    I2C_Out (HwDeviceExtension, 0x02); 
}



/****************************************************************
;   I2C_BitWrite
;
;   Writes one SDA bit to the I2C bus.
;
;   Input:  
;       Using MMIO Base in PHW_DEVICE_EXTENSION 
;       Bit 1 of ucData = Bit to be written.
;
;   Output:
;
;***************************************************************/

VOID I2C_BitWrite (PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData)
{

    //
    //  save valid data bit
    //

    ucData &= 0x02;

    //
    // CLK=low,  DATA=xxxx
    //

    I2C_Out (HwDeviceExtension, ucData);

    //
    // CLK=high, DATA=xxxx
    //

    I2C_Out (HwDeviceExtension, (UCHAR) (ucData | 0x01));

    //
    // CLK=low,  DATA=xxxx
    //

    I2C_Out(HwDeviceExtension, ucData);

}



/****************************************************************
;   I2C_ByteWrite
;
;   Output a byte of information to the Display.
;
;   Input:  
;       Using MMIO Base in PHW_DEVICE_EXTENSION 
;       ucData = Byte to be written.
;
;   Output:
;       TRUE - write successfully
;       FALSE - write failure
;
;***************************************************************/

UCHAR I2C_ByteWrite (PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData)
{
    UCHAR uOutData;
    int i;

    uOutData = ucData;

    //
    //  send MSB first
    //

    for (i=6; i >= 0; i--)
    {
        //
        //  move data bit to bit 1
        //

        uOutData = (ucData >> i);
        I2C_BitWrite (HwDeviceExtension, uOutData);
    }

    //
    //  now send LSB
    //

    uOutData = (ucData << 1);
    I2C_BitWrite (HwDeviceExtension, uOutData);

    //
    //  float the data line high for ACK
    //

    I2C_BitWrite (HwDeviceExtension, 2);
    
    return (TRUE);
}

/****************************************************************
;   I2C_AckWrite
;
;   Send Acknowledgement when reading info.
;
;   Input:  
;       Using MMIO Base in PHW_DEVICE_EXTENSION 
;
;   Output:
;
;***************************************************************/

VOID I2C_AckWrite (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    I2C_BitWrite (HwDeviceExtension, 0);
}


/****************************************************************
;   I2C_NackWrite
;
;   Send Not ACKnowledgement when reading information.
;   A NACK is DATA high during one clock pulse.
;
;   Input:  
;       Using MMIO Base in PHW_DEVICE_EXTENSION 
;
;   Output: 
;
;***************************************************************/

VOID I2C_NackWrite (PHW_DEVICE_EXTENSION HwDeviceExtension)
{

    I2C_BitWrite (HwDeviceExtension, 02);
}


/****************************************************************
;   I2C_BitRead
;
;   Reads in 1 bit from SDA via the GIP.
;
;   Input:
;       Using MMIO Base in PHW_DEVICE_EXTENSION 
;
;   Output:
;       Bit 0 of return value contains bit read
;
;***************************************************************/

UCHAR I2C_BitRead (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    UCHAR ucRetval;

    //
    //  CLK=low,  DATA=high
    //

    I2C_Out (HwDeviceExtension, 0x02); 

    //
    //  CLK=high,  DATA=high
    //

    I2C_Out (HwDeviceExtension, 0x03); 

    //
    //  now read in the data bit
    //

    ucRetval = (VideoPortReadRegisterUchar (MMFF20) & 0x08) >> 3;

    //
    //  CLK=low,  DATA=high
    //

    I2C_Out (HwDeviceExtension, 0x02); 

    return (ucRetval);
}


/****************************************************************
;   I2C_ByteRead
;
;   Read a byte of information from the Display
;
;   Input:  
;       Using MMIO Base in PHW_DEVICE_EXTENSION 
;
;   Output:
;       return value is the byte read
;
;***************************************************************/

UCHAR I2C_ByteRead (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    UCHAR ucRetval;
    int i;

    ucRetval = 0;
    for (i=0; i < 8; i++)
    {
        ucRetval <<= 1;
        ucRetval |= I2C_BitRead (HwDeviceExtension);
    }

    return (ucRetval);
        
}


/****************************************************************
;   I2C_DATA_Request
;
;   Setup Display to query EDID or VDIF information depending
;   upon the offset given.
;
;   Input:  
;       Using MMIO Base in PHW_DEVICE_EXTENSION 
;       ucWriteAddr Write Address of info
;       lLength     Length to read, 
;       lFlags      VERIFY_CHECKSUM
;       pBuffer     pointer to buffer to receive data
;        
;   Output:
;       TRUE    successful read
;       FALSE   read failure or bad checksum
;
;****************************************************************/

UCHAR I2C_Data_Request (    PHW_DEVICE_EXTENSION    HwDeviceExtension,
                            UCHAR                   ucWriteAddr, 
                            long                    lLength, 
                            long                    lFlags,
                            UCHAR                   *pBuffer )
{
    UCHAR ucData;
    UCHAR ucCheckSum = 0;
    long lCount;
    
    I2C_StartService (HwDeviceExtension);
    I2C_ByteWrite (HwDeviceExtension, 0xA0); //Send Device Address + write

    I2C_ByteWrite (HwDeviceExtension, ucWriteAddr); //Send Write Address

    I2C_StartService (HwDeviceExtension);
    I2C_ByteWrite (HwDeviceExtension, 0xA1); //Send Device Address + read

    for (lCount = 0; lCount < lLength - 1; lCount++)
    {
        ucData= I2C_ByteRead (HwDeviceExtension);
        I2C_AckWrite (HwDeviceExtension);
        *pBuffer++ = ucData;
        ucCheckSum += ucData;
    }

    ucData= I2C_ByteRead (HwDeviceExtension);
    I2C_NackWrite (HwDeviceExtension);
    *pBuffer = ucData;
    ucCheckSum += ucData;
    I2C_StopService (HwDeviceExtension);

    
    if (lFlags & VERIFY_CHECKSUM)
    {
        if (ucCheckSum)
        {
            return (FALSE);     // bad checksum
        }
    }

    return TRUE;


}


/****************************************************************
;   GetDdcInformation
;
;   Get 128 bytes EDID information if the monitor supports it.
;   The caller is responsible for allocating the memory.
;        
;   Input:  
;       Using MMIO Base in PHW_DEVICE_EXTENSION 
;       Buffer to receive information
;
;   Output:
;       TRUE    successful
;       FALSE   cannot get DdcInformation 
;        
;***************************************************************/

UCHAR GetDdcInformation (PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR* pBuffer)
{
    UCHAR ucOldCr40;
    UCHAR ucOldCr53;
    UCHAR ucOldCr55;
    UCHAR ucOldCr5C;
    UCHAR ucOldSr0D;
    UCHAR ucOldSr08;
    UCHAR ucOldMMFF20;
    UCHAR ucData;
    UCHAR ucRetval;

    //
    //  unlock the Sequencer registers
    //

    VideoPortWritePortUchar (SEQ_ADDRESS_REG, UNLOCK_SEQREG); 
    ucOldSr08 = ucData = VideoPortReadPortUchar (SEQ_DATA_REG);
    ucData = UNLOCK_SEQ; 
    VideoPortWritePortUchar (SEQ_DATA_REG, ucData);


    VideoPortWritePortUchar (SEQ_ADDRESS_REG, SRD_SEQREG); 
    ucOldSr0D = ucData = VideoPortReadPortUchar (SEQ_DATA_REG);
    ucData &= DISAB_FEATURE_BITS;    // Disable feature connector

    VideoPortWritePortUchar (SEQ_DATA_REG, ucData);

    //
    //  Enable access to the enhanced registers
    //

    VideoPortWritePortUchar (CRT_ADDRESS_REG, SYS_CONFIG_S3EXTREG);
    ucOldCr40 = ucData = VideoPortReadPortUchar (CRT_DATA_REG);
    ucData |= ENABLE_ENH_REG_ACCESS;
    VideoPortWritePortUchar (CRT_DATA_REG, ucData);

    //
    // Enable MMIO
    //

    VideoPortWritePortUchar (CRT_ADDRESS_REG, EXT_MEM_CTRL1_S3EXTREG);
    ucOldCr53 = ucData = VideoPortReadPortUchar (CRT_DATA_REG);
    ucData |= (ENABLE_OLDMMIO | ENABLE_NEWMMIO);    
    VideoPortWritePortUchar (CRT_DATA_REG, ucData);

    //
    // GOP_1:0=00b, select MUX channel 0
    //
    
    VideoPortWritePortUchar (CRT_ADDRESS_REG, GENERAL_OUT_S3EXTREG);
    ucOldCr5C = ucData = VideoPortReadPortUchar (CRT_DATA_REG);
    ucData |= 0x03;    
    VideoPortWritePortUchar (CRT_DATA_REG, ucData);

    //
    //  enable general input port
    //

    VideoPortWritePortUchar (CRT_ADDRESS_REG, EXT_DAC_S3EXTREG);
    ucOldCr55 = VideoPortReadPortUchar (CRT_DATA_REG);

    //
    //  the 764 doesn't support MMFF20
    //
    //  enable the General Input Port
    //

    if (HwDeviceExtension->SubTypeID == SUBTYPE_764)
    {
        VideoPortWritePortUchar (CRT_DATA_REG,
                                (UCHAR) (ucOldCr55 | ENABLE_GEN_INPORT_READ));
    }
    else
    {
        //
        //  enable the serial port
        //

        ucOldMMFF20 = VideoPortReadRegisterUchar (MMFF20);
        VideoPortWriteRegisterUchar (MMFF20, 0x13);
    }

    //
    //  determine DDC capabilities and branch accordingly
    //
        
    switch ( Configure_Chip_DDC_Caps (HwDeviceExtension) )
    {
    case DDC2:
        I2C_Setup (HwDeviceExtension);
    
        ucRetval = I2C_Data_Request ( 
                                HwDeviceExtension, 
                                0,                  // address offset
                                128,                // read 128 bytes
                                VERIFY_CHECKSUM,    // verify checksum
                                pBuffer);           // buffer to put data
        break;

    case DDC1:
        Disable_DAC_Video (HwDeviceExtension);

        //
        //  first try to sync with the EDID header
        //

        if (ucRetval = Sync_EDID_Header (HwDeviceExtension))
        {
            //
            //  now read in the remainder of the information
            //

            ucRetval = EDID_Buffer_Xfer (HwDeviceExtension, pBuffer);
        }
        Enable_DAC_Video (HwDeviceExtension);
        break;

    default:
        ucRetval = FALSE;       // failure
        break;

    }

    //
    // restore the original register values
    //

    if (HwDeviceExtension->SubTypeID != SUBTYPE_764)
    {
        VideoPortWriteRegisterUchar (MMFF20, ucOldMMFF20);
    }

    VideoPortWritePortUchar (CRT_ADDRESS_REG, EXT_DAC_S3EXTREG);
    VideoPortWritePortUchar (CRT_DATA_REG, ucOldCr55);


    VideoPortWritePortUchar (CRT_ADDRESS_REG, GENERAL_OUT_S3EXTREG);
    VideoPortWritePortUchar (CRT_DATA_REG, ucOldCr5C);

    VideoPortWritePortUchar (CRT_ADDRESS_REG, EXT_MEM_CTRL1_S3EXTREG);
    VideoPortWritePortUchar (CRT_DATA_REG, ucOldCr53);

    VideoPortWritePortUchar (CRT_ADDRESS_REG, SYS_CONFIG_S3EXTREG);
    VideoPortWritePortUchar (CRT_DATA_REG, ucOldCr40);

    VideoPortWritePortUchar (SEQ_ADDRESS_REG, SRD_SEQREG);
    VideoPortWritePortUchar (SEQ_DATA_REG, ucOldSr0D);

    VideoPortWritePortUchar (SEQ_ADDRESS_REG, UNLOCK_SEQREG);
    VideoPortWritePortUchar (SEQ_DATA_REG, ucOldSr08);

    return (ucRetval);

}



/****************************************************************
;   Wait_For_Active
;
;   Use two loop method to find VSYNC then return just after the 
;   falling edge.
;
;   Input:  
;       Using MMIO Base in PHW_DEVICE_EXTENSION 
;
;   Output:
;
;***************************************************************/

VOID Wait_For_Active (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    PUCHAR InStatPort = SYSTEM_CONTROL_REG;

    while ((VideoPortReadPortUchar (InStatPort) & VSYNC_ACTIVE) != 0) ;
    while ((VideoPortReadPortUchar (InStatPort) & VSYNC_ACTIVE) == 0) ;
}

/****************************************************************
;   Set_VSYNC
;
;   Read the current polarity of the sync, then toggle it on
;   if ucFlag=1, or off if ucFlag=0.
;
;   Input:  
;       using Seq. registers PHW_DEVICE_EXTENSION 
;       ucFlag - see above comment   
;           
;   Output:
;                   
;****************************************************************/

VOID Set_Vsync (PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucFlag)
{

    UCHAR ucData;

    //
    //  read Sequencer Register D and clear VSYNC bits
    //

    VideoPortWritePortUchar (SEQ_ADDRESS_REG, SRD_SEQREG);
    ucData = VideoPortReadPortUchar (SEQ_DATA_REG) & CLEAR_VSYNC;

    //
    //  set VSYNC per the input flag
    //

    if (ucFlag)
        ucData = ((ucData & CLEAR_VSYNC) | SET_VSYNC1);  
    else
        ucData = ((ucData & CLEAR_VSYNC) | SET_VSYNC0);  

    VideoPortWritePortUchar (SEQ_DATA_REG, ucData);
}

/****************************************************************
;   Provide_Fake_VSYNC
;
;   Use loop delays to create a fake VSYNC signal. (~14.9KHz)
;
;   Input:  
;       using Seq. registers PHW_DEVICE_EXTENSION 
;           
;   Output:
;
;***************************************************************/

VOID Provide_Fake_VSYNC (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    int i;

    Set_Vsync (HwDeviceExtension, 0x01);     // Turn on VSYNC
    VideoPortStallExecution(5);

    Set_Vsync (HwDeviceExtension, 0x00);     // Turn off VSYNC
    VideoPortStallExecution(5);

}


/****************************************************************
;   Disable_DAC_Video
;
;   Disable the DAC video driving BLANK active high. This is
;   done by setting bit D5 of sequencer register 01.
;****************************************************************/

VOID Disable_DAC_Video (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    UCHAR ucIndex;
    UCHAR ucData;


    ucIndex = VideoPortReadPortUchar (SEQ_ADDRESS_REG);


    VideoPortWritePortUchar (SEQ_ADDRESS_REG, CLK_MODE_SEQREG);

    //
    //  set screen off bit
    //

    ucData = VideoPortReadPortUchar (SEQ_DATA_REG) | SCREEN_OFF_BIT;

    VideoPortWritePortUchar (SEQ_DATA_REG, ucData);

    //
    // restore old index value
    //

    VideoPortWritePortUchar (SEQ_ADDRESS_REG, ucIndex);

}

/****************************************************************
;   Disable_DAC_Video
;
;   Enable the DAC video by clearing bit D5 in sequencer register 01
;***************************************************************/

VOID Enable_DAC_Video (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    UCHAR ucIndex;
    UCHAR ucData;


    ucIndex = VideoPortReadPortUchar (SEQ_ADDRESS_REG);


    VideoPortWritePortUchar (SEQ_ADDRESS_REG, CLK_MODE_SEQREG);

    //
    //  clear screen off bit
    //

    ucData = VideoPortReadPortUchar (SEQ_DATA_REG) & (~SCREEN_OFF_BIT);

    VideoPortWritePortUchar (SEQ_DATA_REG, ucData);

    //
    // restore old Index value
    //

    VideoPortWritePortUchar (SEQ_ADDRESS_REG, ucIndex);

}


/****************************************************************
;   Read_EDID_Bit:
;
;   Read the next DDC1 EDID data bit
;       
;   Inputs:     
;       PHW_DEVICE_EXTENSION HwDeviceExtension
;
;   Return:     
;       UCHAR   ucData - data in bit 0
;
;***************************************************************/

UCHAR Read_EDID_Bit (PHW_DEVICE_EXTENSION HwDeviceExtension)

{
    switch (HwDeviceExtension->SubTypeID)
    {
    case SUBTYPE_764:
        return (VideoPortReadPortUchar (DAC_ADDRESS_WRITE_PORT) & 1);
        break;

    default:
        return ((VideoPortReadRegisterUchar (MMFF20) & 8) >> 3);
        break;
    }

}

/****************************************************************
;   Read_EDID_Byte
;
;   Reads eight bits from the EDID string
;
;   Input:
;       Using MMIO Base in PHW_DEVICE_EXTENSION 
;       
;   Output:
;       return byte value 
;
;****************************************************************/

UCHAR Read_EDID_Byte (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    long    i;
    UCHAR   ucRetData;

    ucRetData = 0;
    for (i=0; i < 8; i++)
    {
        ucRetData <<= 1;
        Provide_Fake_VSYNC (HwDeviceExtension);
        ucRetData |= Read_EDID_Bit (HwDeviceExtension);
    }

    return (ucRetData);
}


/****************************************************************
;   Sync_EDID_Header
;
;   Find and sync to the header - 00 FF FF FF FF FF FF 00
;   
;   Inputs:
;           Using MMIO Base in PHW_DEVICE_EXTENSION 
;
;   Outputs:
;           TRUE  = Header Found
;           FALSE = Header NOT Found
;
;***************************************************************/

UCHAR Sync_EDID_Header (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
            
    long lBitCount;
    long lEndCount;
    UCHAR uInSync;
    UCHAR ucEdidData;

    //
    //  there are 8 * 128 bits total, but we could start reading near
    //  the end of the header and realize the error after starting into
    //  the beginning of the header and have to read the entire header
    //  again, so we will try reading up to 144 bytes for safety
    //
    //  the header is 00 FF FF FF FF FF FF 00
    //

    lBitCount = 0;              // init bit counter
    do
    {
        uInSync = TRUE;         // assume found header

        //
        //  looking for 00
        //  checking first bit
        //

        for (lEndCount = lBitCount + 8; lBitCount < lEndCount; lBitCount++)
        {
            Provide_Fake_VSYNC (HwDeviceExtension);
            ucEdidData = Read_EDID_Bit (HwDeviceExtension);
            
            if (ucEdidData == 1)
            {
                uInSync = FALSE;
                break;
            }
        }

        if (!uInSync)
            continue;           // start all over

        //
        // send ACK
        //

        Provide_Fake_VSYNC (HwDeviceExtension);

        //
        //  looking for FF FF FF FF FF FF
        //  8 data bits 
        //  1 bit of acknowledgement
        //

        for (lEndCount = lBitCount + 6 * 8; lBitCount < lEndCount; lBitCount++)
        {
            Provide_Fake_VSYNC (HwDeviceExtension);
            ucEdidData = Read_EDID_Bit (HwDeviceExtension);

            if (ucEdidData == 0)
            {
                uInSync = FALSE;
                break;
            }

            //
            //  send an ACK if we have read 8 bits
            //

            if (!((lEndCount - lBitCount + 1) % 8))
            {
                Provide_Fake_VSYNC (HwDeviceExtension);
            }

        }
        if (!uInSync)
            continue;           // start all over

        //
        //  now looking for last 00 of header
        //

        for (lEndCount = lBitCount + 8; lBitCount < lEndCount; lBitCount++)
        {
            Provide_Fake_VSYNC (HwDeviceExtension);
            ucEdidData = Read_EDID_Bit (HwDeviceExtension);

            if (ucEdidData == 1)
            {
                uInSync = FALSE;
                break;
            }
        }

        if(!uInSync)
            continue;           // start all over

        //
        // Acknowledgment
        //

        Provide_Fake_VSYNC (HwDeviceExtension);


    } while ( (!uInSync) && (lBitCount < (8 * 144)) );

    return (uInSync);
}


/****************************************************************
;   EDID_Buffer_Xfer
;
;   Transfer all EDID data to pBuffer. Caller must allocate enough 
;   memory to receive 128 bytes.
;
;   Input:  
;       Using MMIO Base in PHW_DEVICE_EXTENSION 
;       Pointer to receive buffer
;
;   Output:
;       TRUE    data in buffer & checksum is correct
;       FALSE   error or bad checksum
;
;****************************************************************/

UCHAR EDID_Buffer_Xfer (PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR* pBuffer)
{
    UCHAR ucChecksum = 0x0FA;
    UCHAR ucEdidData;
    unsigned int uCount;

    //
    //  put the 8 header bytes in the buffer
    //

    *pBuffer = 0;
    for (uCount = 1; uCount < 7; uCount++)
        *(pBuffer+uCount) = 0xFF;

    *(pBuffer+uCount) = 0x00;

    for (uCount = 8; uCount < 128; uCount++)
    {
        ucEdidData = Read_EDID_Byte (HwDeviceExtension);

        //
        //  send Acknowledgment
        //  add data to buffer
        //  add data to checksum
        //

        Provide_Fake_VSYNC (HwDeviceExtension);
        *(pBuffer+uCount) = ucEdidData;
        ucChecksum += ucEdidData;
    }

    if (!ucChecksum)
    {
        return (TRUE);           // checksum is OK
    }

    return (FALSE);              // checksum is NOT
}


/****************************************************************
;   Check_DDC1_Monitor
;   
;   Check for a DDC1 monitor using current vsync.
;
;   Input:  
;           Using MMIO Base in PHW_DEVICE_EXTENSION 
;
;   Output:
;           TRUE    possible DDC1 monitor 
;           FALSE   no EDID data detected on input port
;
;****************************************************************/

UCHAR Check_DDC1_Monitor (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    
    UCHAR ucSaveOldData;
    UCHAR ucData;
    UCHAR ucGD0;
    unsigned int uCount;
    UCHAR ucDDC1;

    //
    //  assume not DDC1
    //

    ucDDC1 = FALSE;
    
    switch (HwDeviceExtension->SubTypeID)
    {
    //
    //  use reads from 3C8 on the 764 (undocumented, but this use
    //  of the DAC register comes from the 764 BIOS source code).
    //

    case SUBTYPE_764:
        ucSaveOldData = VideoPortReadPortUchar (MISC_OUTPUT_REG_READ);

        //
        // Bit 7 = 0 Positive VSYNC
        //
        VideoPortWritePortUchar (MISC_OUTPUT_REG_WRITE, 
                                (UCHAR) (ucSaveOldData & SEL_POS_VSYNC));
        Wait_For_Active (HwDeviceExtension);


        ucData = VideoPortReadPortUchar (DAC_ADDRESS_WRITE_PORT);

        //
        // Another read for VL systems. (Data left on the GD/SD lines)
        //

        ucGD0 = VideoPortReadPortUchar (DAC_ADDRESS_WRITE_PORT) & 0x01;

        //
        //  read up to 350 bits looking for the data to toggle, indicating
        //  DDC1 data is being sent
        //

        for (uCount = 0; uCount < 350; uCount++)
        {
            Wait_For_Active (HwDeviceExtension);
            ucData = VideoPortReadPortUchar (DAC_ADDRESS_WRITE_PORT) & 0x01;
            if (ucData != ucGD0)
            {
                //
                //  data line toggled, assume DDC1 data is being sent
                //

                ucDDC1 = TRUE;
                break;
            }
        }

        //
        // restore old value
        //

        VideoPortWritePortUchar (MISC_OUTPUT_REG_WRITE, ucSaveOldData);
        break;

    //
    //  else use MMFF20 on the other chips
    //

    default:
        Disable_DAC_Video (HwDeviceExtension);
        Provide_Fake_VSYNC (HwDeviceExtension);
        ucGD0 = VideoPortReadRegisterUchar (MMFF20) & 8;

        for (uCount = 0; uCount < 350; uCount++)
        {
            Provide_Fake_VSYNC (HwDeviceExtension);
            ucData = VideoPortReadRegisterUchar (MMFF20) & 8;
        
            if (ucData != ucGD0)
            {
                //
                //  data line toggled, assume DDC1 data is being sent
                //

                ucDDC1 = TRUE;
                break;
            }
        }
        Enable_DAC_Video (HwDeviceExtension);
        break;

    }

    return (ucDDC1);

}
    
/****************************************************************
;   Configure_Chip_DDC_Caps
;
;   Determine DDC capabilities of display.
;
;   Input:
;           Using MMIO Base in PHW_DEVICE_EXTENSION 
;
;   Output:
;           NO_DDC
;           DDC1: Support DDC1
;           DDC2: Support DDC2
;
;****************************************************************/

UCHAR Configure_Chip_DDC_Caps (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    UCHAR ucBuffer[2];

    //
    //  we will only use DDC1 on 764
    //

    if (HwDeviceExtension->SubTypeID != SUBTYPE_764)
    {
        //
        //  first check if DDC2 capable
        //

        I2C_Setup (HwDeviceExtension);
        I2C_Data_Request (  HwDeviceExtension, 
                            0,                  // address offset
                            2,                  // look at first 2 bytes
                            NO_FLAGS,           // don't verify checksum
                            ucBuffer );         // buffer to place data

        //
        //  check if the first 2 bytes of the EDID header look correct
        //

        if ( (ucBuffer [0] == 0)    &&
             (ucBuffer [1] == 0xFF) )
        {
            return (DDC2);      // assume DDC2 capable
        }
    }

    //
    //  try DDC1
    //

    if (Check_DDC1_Monitor (HwDeviceExtension))
    {
        return (DDC1);
    }

    return (NO_DDC);
}


//---------------------------------------------------------------------------


ULONG DdcMaxRefresh(ULONG uXresolution, UCHAR * pEdid)
{
    ULONG uMaxFreq = 0;
    ULONG uEdidRes;
    ULONG uEdidFreq;
    ULONG HorRes, VertRes;
    ULONG i, Index;

    //
    // Detailed timing 
    //

    for (i = 0; i < 4; ++i)     // 4 Detailed Descriptions
    {
        Index = 54 + i * 18;
        if ( (pEdid [Index] == 0)       &&
             (pEdid [Index + 1] == 0)   &&
             (pEdid [Index + 2] == 0) )
        {
            continue;   // Monitor descriptor block, skip it
        }

        HorRes = ((ULONG) (pEdid [Index + 4] & 0xF0)) << 4;
        HorRes += (ULONG) pEdid [Index + 2];

        if (HorRes == uXresolution)
        {
            //
            //  add Horizontal blanking
            //

            HorRes += (ULONG) pEdid [Index + 3];
            HorRes += ((ULONG) (pEdid [Index + 4] & 0x0F)) << 8;

            //
            //  now get Vertical Total (Active & Blanking)
            //
                        
            VertRes =  ((ULONG) (pEdid [Index + 7] & 0xF0)) << 4;
            VertRes += ((ULONG) (pEdid [Index + 7] & 0x0F)) << 8;
            VertRes += (ULONG) pEdid [Index + 5];
            VertRes += (ULONG) pEdid [Index + 6];

            uEdidFreq = (((ULONG) pEdid [Index + 1]) << 8) +
                         ((ULONG) pEdid [Index]);

            uEdidFreq = uEdidFreq * 10000 / HorRes / VertRes;

            if (uEdidFreq > uMaxFreq)
            {
                uMaxFreq = uEdidFreq;
            }
        }
    }
    //
    // Standard timing id.
    //

    for (i = 38; i < 54; i += 2)
    {
        uEdidRes = (((ULONG) pEdid[i]) + 31) * 8;
        if (uXresolution == uEdidRes)
        {
            uEdidFreq = (((ULONG) pEdid[i+1]) & 0x3F) + 60;
            if (uEdidFreq > uMaxFreq)
            {
                uMaxFreq = uEdidFreq;
            }
        }
    }

    //    
    // Established timing
    //
        
    switch (uXresolution)
    {
        case 640:
            uEdidFreq = (ULONG)pEdid[0x23];
            if (uEdidFreq & 0x020)
            {
                if (uMaxFreq < 60)
                {
                    uMaxFreq = 60;
                }
            }
            if (uEdidFreq & 0x08)
            {
                if (uMaxFreq < 72)
                {
                    uMaxFreq = 72;
                }
            }
            if (uEdidFreq & 0x04)
            {
                if (uMaxFreq < 75)
                {
                    uMaxFreq = 75;
                }
            }
            break;

        case 800:
            uEdidFreq = (ULONG)pEdid[0x23];
            if (uEdidFreq & 0x02)
            {
                if (uMaxFreq < 56)
                {
                    uMaxFreq = 56;
                }
            }
            if (uEdidFreq & 0x01)
            {
                if (uMaxFreq < 60)
                {
                    uMaxFreq = 60;
                }
            }

            uEdidFreq = (ULONG)pEdid[0x24];
            if (uEdidFreq & 0x80)
            {
                if (uMaxFreq < 72)
                {
                    uMaxFreq = 72;
                }
            }
            if (uEdidFreq & 0x40)
            {
                if (uMaxFreq < 75)
                {
                    uMaxFreq = 75;
                }
            }
            break;

        case 1024:
            uEdidFreq = (ULONG)pEdid[0x24];
            if (uEdidFreq & 0x08)
            {
                if (uMaxFreq < 60)
                {
                    uMaxFreq = 60;
                }
            }
            if (uEdidFreq & 0x04)
            {
                if (uMaxFreq < 70)
                {
                    uMaxFreq = 70;
                }
            }
            if (uEdidFreq & 0x02)
            {
                if (uMaxFreq < 75)
                {
                    uMaxFreq = 75;
                }
            }
            break;

        case 1280:
            uEdidFreq = (ULONG)pEdid[0x24];
            if (uEdidFreq & 0x01)
            {
                if (uMaxFreq < 75)
                {
                    uMaxFreq = 75;
                }
            }
            break;
    }

    return(uMaxFreq);

}

//---------------------------------------------------------------------------

ULONG DdcRefresh (PHW_DEVICE_EXTENSION hwDeviceExtension, ULONG uXResolution)
{

    ULONG  lRefresh = 0;
    char szBuffer[200];

                        
    if (GetDdcInformation (hwDeviceExtension, szBuffer))
    {
        lRefresh = DdcMaxRefresh (uXResolution, szBuffer);
    }

    return lRefresh;
}


/****************************************************************
;   CheckDDCType
;
;   Check the monitor for DDC type.
;        
;   Input:  
;       Using MMIO Base in PHW_DEVICE_EXTENSION 
;
;   Output:
;       NO_DDC  non-DDC monitor
;       DDC1    DDC1 monitor
;       DDC2    DDC2 monitor
;       
;***************************************************************/

UCHAR CheckDDCType (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    UCHAR ucOldCr40;
    UCHAR ucOldCr53;
    UCHAR ucOldCr55;
    UCHAR ucOldCr5C;
    UCHAR ucOldSr0D;
    UCHAR ucOldSr08;
    UCHAR ucOldMMFF20;
    UCHAR ucData;
    UCHAR ucRetval;

    //
    //  unlock the Sequencer registers
    //

    VideoPortWritePortUchar (SEQ_ADDRESS_REG, UNLOCK_SEQREG); 
    ucOldSr08 = ucData = VideoPortReadPortUchar (SEQ_DATA_REG);
    ucData = UNLOCK_SEQ; 
    VideoPortWritePortUchar (SEQ_DATA_REG, ucData);


    VideoPortWritePortUchar (SEQ_ADDRESS_REG, SRD_SEQREG); 
    ucOldSr0D = ucData = VideoPortReadPortUchar (SEQ_DATA_REG);
    ucData &= DISAB_FEATURE_BITS;    // Disable feature connector

    VideoPortWritePortUchar (SEQ_DATA_REG, ucData);

    //
    //  Enable access to the enhanced registers
    //

    VideoPortWritePortUchar (CRT_ADDRESS_REG, SYS_CONFIG_S3EXTREG);
    ucOldCr40 = ucData = VideoPortReadPortUchar (CRT_DATA_REG);
    ucData |= ENABLE_ENH_REG_ACCESS;
    VideoPortWritePortUchar (CRT_DATA_REG, ucData);

    //
    // Enable MMIO
    //

    VideoPortWritePortUchar (CRT_ADDRESS_REG, EXT_MEM_CTRL1_S3EXTREG);
    ucOldCr53 = ucData = VideoPortReadPortUchar (CRT_DATA_REG);
    ucData |= (ENABLE_OLDMMIO | ENABLE_NEWMMIO);    
    VideoPortWritePortUchar (CRT_DATA_REG, ucData);

    //
    // GOP_1:0=00b, select MUX channel 0
    //
    
    VideoPortWritePortUchar (CRT_ADDRESS_REG, GENERAL_OUT_S3EXTREG);
    ucOldCr5C = ucData = VideoPortReadPortUchar (CRT_DATA_REG);
    ucData |= 0x03;    
    VideoPortWritePortUchar (CRT_DATA_REG, ucData);

    //
    //  enable general input port
    //

    VideoPortWritePortUchar (CRT_ADDRESS_REG, EXT_DAC_S3EXTREG);
    ucOldCr55 = VideoPortReadPortUchar (CRT_DATA_REG);

    //
    //  the 764 doesn't support MMFF20
    //
    //  enable the General Input Port
    //

    if (HwDeviceExtension->SubTypeID == SUBTYPE_764)
    {
        VideoPortWritePortUchar (CRT_DATA_REG,
                                (UCHAR) (ucOldCr55 | ENABLE_GEN_INPORT_READ));
    }
    else
    {
        //
        //  enable the serial port
        //

        ucOldMMFF20 = VideoPortReadRegisterUchar (MMFF20);
        VideoPortWriteRegisterUchar (MMFF20, 0x13);
    }

    //
    //  determine DDC capabilities and branch accordingly
    //
        
    ucRetval = Configure_Chip_DDC_Caps (HwDeviceExtension);

    //
    // restore the original register values
    //

    if (HwDeviceExtension->SubTypeID != SUBTYPE_764)
    {
        VideoPortWriteRegisterUchar (MMFF20, ucOldMMFF20);
    }

    VideoPortWritePortUchar (CRT_ADDRESS_REG, EXT_DAC_S3EXTREG);
    VideoPortWritePortUchar (CRT_DATA_REG, ucOldCr55);


    VideoPortWritePortUchar (CRT_ADDRESS_REG, GENERAL_OUT_S3EXTREG);
    VideoPortWritePortUchar (CRT_DATA_REG, ucOldCr5C);

    VideoPortWritePortUchar (CRT_ADDRESS_REG, EXT_MEM_CTRL1_S3EXTREG);
    VideoPortWritePortUchar (CRT_DATA_REG, ucOldCr53);

    VideoPortWritePortUchar (CRT_ADDRESS_REG, SYS_CONFIG_S3EXTREG);
    VideoPortWritePortUchar (CRT_DATA_REG, ucOldCr40);

    VideoPortWritePortUchar (SEQ_ADDRESS_REG, SRD_SEQREG);
    VideoPortWritePortUchar (SEQ_DATA_REG, ucOldSr0D);

    VideoPortWritePortUchar (SEQ_ADDRESS_REG, UNLOCK_SEQREG);
    VideoPortWritePortUchar (SEQ_DATA_REG, ucOldSr08);

    return (ucRetval);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\moninf\comsect.cpp ===
#include "stdafx.h"
#include "mon.h"

CCommonSection gCommonSections;

int compareCommonSection(LPCOMMON_SECTION p1, LPCOMMON_SECTION p2)
{
   return (stricmp(p1->sectName, p2->sectName));
}

CCommonSection::CCommonSection()
{
	m_sections.RemoveAll();
}

CCommonSection::~CCommonSection()
{
	ClearAll();
}
VOID CCommonSection::ClearAll(VOID)
{
	for (int i = 0; i < m_sections.GetSize(); i++)
		delete((LPCOMMON_SECTION)m_sections[i]);
	m_sections.RemoveAll();
}

LPCOMMON_SECTION CCommonSection::AddOneSection(LPSTR sectName, LPSTR contents)
{
	LPCOMMON_SECTION pNewSection = new(COMMON_SECTION);
	if (pNewSection == NULL)
    {
        ASSERT(FALSE);
        return NULL;
    }

	strcpy(pNewSection->sectName, sectName);
	strcpy(pNewSection->contents, contents);
	LPSTR pEndSectName = pNewSection->sectName + lstrlen(pNewSection->sectName);
	int   dupSectCount = 1;

	int comp = 1;
	for (int i = 0; i < m_sections.GetSize(); i++)
	{
		LPCOMMON_SECTION pSection = (LPCOMMON_SECTION)m_sections[i];
		comp = compareCommonSection(pNewSection, pSection);

		if (comp > 0)
			continue;
		else if (comp < 0)
            break;

		if (stricmp(pNewSection->contents, pSection->contents) == 0)
			break;
		///////////////////////////////////////////////////////////////
		// Come here, we found a section with same section name but
		// different contents.  Need rename the section Name to make
		// it distinct
		sprintf(pEndSectName, "%c", 'A'+dupSectCount);
		dupSectCount++;
	}
	if (comp == 0)
	{
		delete pNewSection;
	}
	else
	{
		m_sections.InsertAt(i, (LPVOID)pNewSection);
	}

	return (LPCOMMON_SECTION)m_sections[i];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\mini\s3ddc.h ===
//
// LOCAL PERIPHERAL BUS REGISTERS
//
// These values are used as offsets to the memory mapped IO base stored in
// the HW device extension.
//

#define LPB_MODE_MM             0x0FF00 // LPB mode
#define SERIAL_PORT_MM          0x0FF20 // Serial Communications Port

#define UNLOCK_SEQREG           0x08  // Unlock Extended Sequencer

#define UNLOCK_SEQ      0x06    // unlock accessing to all S3 extensions to
                                // the standard VGA sequencer register set

#define SR9_SEQREG              0x09  // Extended Sequencer 9 register
#define SRA_SEQREG              0x0A  // Extended Sequencer A register
#define SRD_SEQREG              0x0D  // Extended Sequencer D register

#define LPB_ENAB_BIT    0x01    // bit 0 of SRD is LPB enable (pin control)
                                // on some chips (M65).

#define DISAB_FEATURE_BITS 0xFC // AND mask to turn off LPB/Feature Connector
                                // on ViRGE (NOT ViRGE GX).

#define SYS_CONFIG_S3EXTREG     0x40  // System Configuration

//
// Bit masks for System Configuration register (CR40)
//
#define ENABLE_ENH_REG_ACCESS  0x01  // bit 0 set = enhanced reg access enabled

#define EXT_MEM_CTRL1_S3EXTREG  0x53  // Extended Memory Control 1

//
// Bit masks for the Extended Memory Control 1 register (CR53)
//
#define ENABLE_OLDMMIO  0x10     // bit 4 set = enable Trio64-type MMIO
#define ENABLE_NEWMMIO  0x08     // bit 3 set = New MMIO (relocatable) enabled

#define GENERAL_OUT_S3EXTREG    0x5C  // General Out Port

#define EXT_DAC_S3EXTREG        0x55  // Extended DAC Control

#define ENABLE_GEN_INPORT_READ   0x04  // On the 764, CR55 bit 2 set enables
                                       // General Input Port read

//
//  defines for return information for CheckDDCType & Configure_Chip_DDC_Caps
//
#define     NO_DDC  0
#define     DDC1    1
#define     DDC2    2

//
// Bit mask for Backward Compatibility Register 2 (CR33, BWD_COMPAT2_S3EXTREG)
//
#define DISPLAY_MODE_INACTIVE   0x01    // bit 1 set = controller is not in
                                        // active display area. (M3, M5, GX2)
#define VSYNC_ACTIVE_BIT        0x04    // bit 2 set = controller is in vertical
                                        // retrace area (M3, M5, GX2).  Paired
                                        // with 3?Ah bit 3 for IGA1.

//
// Bit masks for SYSTEM_CONTROL_REGISTER (3?A)
//
#define VSSL_BIT        0x08    // Bit 3 of Feature Control Register (3?A,
                                // write-only 3CA) is Vertical Sync Type Select
#define VSYNC_ACTIVE    0x08    // Bit 3 of Input Status 1 Register (3CA in
                                // read-only) is Vertical Sync Active.  If set,
                                // then display is in the vertical retrace mode;
                                // if clear, then display is in display mode.

#define CLEAR_VSYNC     0x3F    // AND mask to clear VSYNC Control bits
                                // (setting normal operation).
#define SET_VSYNC0      0x40    // OR mask to set VSYNC Control to VSYNC = 0
#define SET_VSYNC1      0x80    // OR mask to set VSYNC Control to VSYNC = 1

#define CLK_MODE_SEQREG         0x01  // Clocking Mode Register

//
// Bit mask for Clocking Mode Register (SR1)
//
#define SCREEN_OFF_BIT             0x20     // bit 5 set turns the screen off.


#define SEL_POS_VSYNC   0x7F    // AND mask to clear bit 7 of 3C2, selecting
                                // positive vertical retrace sync pulse


//
// Macro to access the serial port
//

#define  MMFF20 (PVOID) ((ULONG_PTR)(HwDeviceExtension->MmIoBase) + SERIAL_PORT_MM)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\moninf\dumpinf.cpp ===
#include "stdafx.h"
#include "mon.h"

const TCHAR GenericMannufacturerSection[] =
"[Generic]\n\
%Unknown.DeviceDesc%=Unknown.Install,Monitor\\Default_Monitor	; for auto-install\n\
%Unknown.DeviceDesc%=Unknown.Install	; for pick list\n\
%*PNP09FF.DeviceDesc%=VESADDC.Install,*PNP09FF\n\
\n\
%Laptop640.DeviceDesc%=Laptop640.Install,Monitor\\MS_0001\n\
%Laptop800.DeviceDesc%=Laptop800.Install,Monitor\\MS_0002\n\
%Laptop1024.DeviceDesc%=Laptop1024.Install,Monitor\\MS_0003\n\
%Laptop1152.DeviceDesc%=Laptop1152.Install,Monitor\\MS_0004\n\
%Laptop1280.DeviceDesc%=Laptop1280.Install,Monitor\\MS_0005\n\
%Laptop1600.DeviceDesc%=Laptop1600.Install,Monitor\\MS_0006\n\
\n\
%TVGen.DeviceDesc%=640.Install,Monitor\\PNP09FE\n\
%TVGen.DeviceDesc%=640.Install,Monitor\\*PNP09FE\n\
\n\
%640.DeviceDesc%=640.Install,Monitor\\MS_0640\n\
%800.DeviceDesc%=800.Install,Monitor\\MS_0800\n\
%1024.DeviceDesc%=1024.Install,Monitor\\MS_1024\n\
%1280.DeviceDesc%=1280.Install,Monitor\\MS_1280\n\
%1600.DeviceDesc%=1600.Install,Monitor\\MS_1600\n\n";

const TCHAR GenericInstallSection[] =
"; -------------- Generic types\n\
[Unknown.Install]\n\
DelReg=DCR\n\
AddReg=Unknown.AddReg\n\
\n\
[VESADDC.Install]\n\
DelReg=DCR\n\
AddReg=VESADDC.AddReg, 1600, DPMS\n\
\n\
[Laptop640.Install]\n\
DelReg=DCR\n\
AddReg=640VESA60, DPMS\n\
\n\
[Laptop800.Install]\n\
DelReg=DCR\n\
AddReg=800VESA60, DPMS\n\
\n\
[Laptop1024.Install]\n\
DelReg=DCR\n\
AddReg=1024VESA60, DPMS\n\
\n\
[Laptop1152.Install]\n\
DelReg=DCR\n\
AddReg=1152VESA60, DPMS\n\
\n\
[Laptop1280.Install]\n\
DelReg=DCR\n\
AddReg=1280VESA60, DPMS\n\
\n\
[Laptop1600.Install]\n\
DelReg=DCR\n\
AddReg=1600VESA60, DPMS\n\
\n\
[640.Install]\n\
DelReg=DCR\n\
AddReg=640\n\
\n\
[800.Install]\n\
DelReg=DCR\n\
AddReg=800\n\
\n\
[1024.Install]\n\
DelReg=DCR\n\
AddReg=1024\n\
\n\
[1280.Install]\n\
DelReg=DCR\n\
AddReg=1280\n\
\n\
[1600.Install]\n\
DelReg=DCR\n\
AddReg=1600\n\n";

const TCHAR GenericAddRegSection[] =
"; -------------- Generic types\n\
[Unknown.AddReg]\n\
HKR,\"MODES\\640,480\"\n\
\n\
[VESADDC.AddReg]\n\
HKR,\"MODES\\1600,1200\"\n\
\n\
[VGA.AddReg]\n\
HKR,\"MODES\\640,480\",Mode1,,\"31.5,50.0-70.0,-,-\"\n\
\n\
[640VESA60]\n\
HKR,\"MODES\\640,480\",Mode1,,\"60.0,50.0,-,-\"\n\
HKR,,PreferredMode,,\"640,480,60\"\n\
\n\
[800VESA60]\n\
HKR,\"MODES\\640,480\",Mode1,,\"60.0,50.0,-,-\"\n\
HKR,\"MODES\\800,600\",Mode1,,\"60.0,60.0,+,+\"\n\
HKR,,PreferredMode,,\"800,600,60\"\n\
\n\
[1024VESA60]\n\
HKR,\"MODES\\640,480\",Mode1,,\"60.0,50.0,-,-\"\n\
HKR,\"MODES\\1024,768\",Mode1,,\"60.0,60.0,+,+\"\n\
HKR,,PreferredMode,,\"1024,768,60\"\n\
\n\
[1152VESA60]\n\
HKR,\"MODES\\640,480\",Mode1,,\"60.0,50.0,-,-\"\n\
HKR,\"MODES\\1152,864\",Mode1,,\"60.0,60.0,+,+\"\n\
HKR,,PreferredMode,,\"1152,864,60\"\n\
\n\
[1280VESA60]\n\
HKR,\"MODES\\640,480\",Mode1,,\"60.0,50.0,-,-\"\n\
HKR,\"MODES\\1280,1024\",Mode1,,\"48.0,65.0,+,+\"\n\
HKR,,PreferredMode,,\"1280,1024,60\"\n\
\n\
[1600VESA60]\n\
HKR,\"MODES\\640,480\",Mode1,,\"60.0,60.0,-,-\"\n\
HKR,\"MODES\\1600,1200\",Mode1,,\"48.0,75.0,+,+\"\n\
HKR,,PreferredMode,,\"1600,1200,60\"\n\n";

const TCHAR GenericStrings[] =
"MonitorClassName=\"Monitors\"\n\
MS=\"Microsoft\"\n\
\n\
Generic=\"(Standard monitor types)\"\n\
Unknown.DeviceDesc=\"Default Monitor\"\n\
\n\
*PNP09FF.DeviceDesc = \"Plug and Play Monitor\"\n\
\n\
Laptop640.DeviceDesc = \"Digital Flat Panel (640x480)\"\n\
Laptop800.DeviceDesc = \"Digital Flat Panel (800x600)\"\n\
Laptop1024.DeviceDesc =\"Digital Flat Panel (1024x768)\"\n\
Laptop1152.DeviceDesc =\"Digital Flat Panel (1152x864)\"\n\
Laptop1280.DeviceDesc =\"Digital Flat Panel (1280x1024)\"\n\
Laptop1600.DeviceDesc =\"Digital Flat Panel (1600x1200)\"\n\
\n\
TVGen.DeviceDesc =\"Generic Television\"\n\
\n\
640.DeviceDesc  = \"Standard VGA 640x480\"\n\
800.DeviceDesc  = \"Super VGA 800x600\"\n\
1024.DeviceDesc = \"Super VGA 1024x768\"\n\
1280.DeviceDesc = \"Super VGA 1280x1024\"\n\
1600.DeviceDesc = \"Super VGA 1600x1200\"\n\n";


VOID CSumInf::DumpMonitorInf(LPCSTR DumpFilePath, int sizeLimit)
{
	TCHAR DumpFileName[256];
    sprintf(DumpFileName, "%s\\tmp.txt", DumpFilePath);

    ASSERT(m_ManufacturerArray.GetSize());
    
    if (sizeLimit == 0xFFFFFFFF)
    {
        sprintf(DumpFileName, "%s\\MONITOR.INF", DumpFilePath);
        DumpManufacturers(DumpFileName, 0, m_ManufacturerArray.GetSize(), 1);
        return;
    }

    int fileBreaks[64], numFileBreaks = 0, fileSize = 0;
    int start = 0, end = 0;

    // 0
    // 0 1 2
    // 0 1 2 | 3 4 | 5
    //         e     e e=6
    while (1)
    {
        end++;
        if (end >= m_ManufacturerArray.GetSize())
        {
            fileBreaks[numFileBreaks++] = end;
            break;
        }
        fileSize = DumpManufacturers(DumpFileName, start, end-start, (start == 0) ? 6 : 0);
        if (fileSize >= sizeLimit)
        {
            fileBreaks[numFileBreaks++] = end;
            start = end;
            fileSize = 0;
        }
    }

    sprintf(DumpFileName, "%s\\MONITOR.INF", DumpFilePath);
    DumpManufacturers(DumpFileName, 0, fileBreaks[0], numFileBreaks);
    for (int i = 0; i < (numFileBreaks-1); i++)
    {
        sprintf(DumpFileName, "%s\\MONITOR%d.INF", DumpFilePath, i+2);
        DumpManufacturers(DumpFileName, fileBreaks[i], fileBreaks[i+1]-fileBreaks[i], 0);
    }
}

int CSumInf::DumpManufacturers(LPCSTR DumpFileName, int start, int num, int numInfs)
{
    FILE *fpOut = fopen(DumpFileName, "w");

    LPCSTR lpFileName = strrchr(DumpFileName, '\\');
    ASSERT(lpFileName != NULL);
    lpFileName++;

	if (fpOut == NULL)
		return 0;

    fprintf(fpOut, "; %s\n;\n", lpFileName);

    DumpCommonHeader(fpOut, numInfs);
    
    int end = min(start+num, m_ManufacturerArray.GetSize());
    for (int i = start; i < end; i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)m_ManufacturerArray[i];
        fprintf(fpOut, "%s=%s\n", pManufacturer->AliasName, pManufacturer->name);
    }

    fprintf(fpOut, "\n\n;-------------------------------------------------\n");
    fprintf(fpOut, "; Manufacturer Sections\n\n");

    if (numInfs)
    {
        fprintf(fpOut, "%s", GenericMannufacturerSection);
    }
    
    for (i = start; i < end; i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)m_ManufacturerArray[i];
        DumpManufactureSection(fpOut, pManufacturer);
    }

    fprintf(fpOut, "\n;-------------------------------------------------\n");
    fprintf(fpOut, "; Install sections\n\n");

    if (numInfs)
    {
        fprintf(fpOut, "%s", GenericInstallSection);
    }
    
    for (i = start; i < end; i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)m_ManufacturerArray[i];
        DumpInstallSection(fpOut, pManufacturer);
    }
    
    fprintf(fpOut, "\n;-------------------------------------------------\n");
    fprintf(fpOut, "; Common AddReg sections\n");

    DumpCommonAddRegSection(fpOut, start, end);

    fprintf(fpOut, "\n;-------------------------------------------------\n");
    fprintf(fpOut, "; Model AddReg sections\n\n");

    if (numInfs)
    {
        fprintf(fpOut, "%s", GenericAddRegSection);
    }
    
    for (i = start; i < end; i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)m_ManufacturerArray[i];
        DumpAddRegSection(fpOut, pManufacturer);
    }

    fprintf(fpOut, "\n;-------------------------------------------------\n");
    fprintf(fpOut, "; User visible strings\n\n");
    fprintf(fpOut, "[Strings]\n");

    if (numInfs)
    {
        fprintf(fpOut, "%s", GenericStrings);
    }
    else
        fprintf(fpOut, "MS=\"Microsoft\"\n\n");

    DumpCommonStringSection(fpOut, start, end);

    fpos_t fileSize = 0;
    ASSERT( fgetpos(fpOut, &fileSize) == 0 );

    fclose(fpOut);

    return (int)fileSize;
}

VOID CSumInf::DumpManufactureSection(FILE *fp, CManufacturer *pManufacturer)
{
    fprintf(fp, "[%s]\n", pManufacturer->name);
    for (int i = 0; i < pManufacturer->MonitorArray.GetSize(); i++)
    {
        CMonitor *pMonitor = (CMonitor*)pManufacturer->MonitorArray[i];
        fprintf(fp, "%s=%s, %s\n",
                pMonitor->AliasName,
                pMonitor->InstallSectionName,
                pMonitor->ID);
    }
    fprintf(fp, "\n");
}

VOID CSumInf::DumpInstallSection(FILE *fp, CManufacturer *pManufacturer)
{
    fprintf(fp, "; -------------- %s\n", pManufacturer->name);
    for (int i = 0; i < pManufacturer->MonitorArray.GetSize(); i++)
    {
        CMonitor *pMonitor = (CMonitor*)pManufacturer->MonitorArray[i];
        /////////////////////////////////////////////////////////////
        // If this Monitor has duplicated section, ignore it
        if (pMonitor->bDupInstSection)
        {
            continue;
        }
        fprintf(fp, "[%s]\n", pMonitor->InstallSectionName);
        fprintf(fp, "DelReg=DCR\n");
        fprintf(fp, "AddReg=%s", pMonitor->AddRegSectionName);
        for (int j = 0; j < pMonitor->numCommonSects; j++)
            fprintf(fp, ", %s", pMonitor->CommonSects[j]->sectName);
        fprintf(fp, "\n\n");
    }
}

VOID CSumInf::DumpCommonAddRegSection(FILE *fp, int start, int end)
{
    fprintf(fp, "\n[DCR]\n");
    fprintf(fp, "HKR,MODES\n");
    fprintf(fp, "HKR,,MaxResolution\n");
    fprintf(fp, "HKR,,DPMS\n");
    fprintf(fp, "HKR,,ICMProfile\n\n");

    for (int i = 0; i < gCommonSections.GetSize(); i++)
    {
        LPCOMMON_SECTION pSection = gCommonSections.GetAt(i);
        pSection->refCount = 0;
    }
    
    for (i = start; i < end; i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)m_ManufacturerArray[i];
        for (int j = 0; j < pManufacturer->MonitorArray.GetSize(); j++)
        {
            CMonitor *pMonitor = (CMonitor*)pManufacturer->MonitorArray[j];
            for (int k = 0; k < pMonitor->numCommonSects; k++)
                pMonitor->CommonSects[k]->refCount++;
        }
    }

    ////////////////////////////////////////////////////////
    // For generic common sections
    if (start == 0)
    {
        for (int i = 0; i < gCommonSections.GetSize(); i++)
        {
            LPCOMMON_SECTION pSection = gCommonSections.GetAt(i);
            if (stricmp(pSection->sectName, "DPMS") == 0 ||
                stricmp(pSection->sectName, "1600") == 0 ||
                stricmp(pSection->sectName, "640") == 0  ||
                stricmp(pSection->sectName, "800") == 0  ||
                stricmp(pSection->sectName, "1024") == 0 ||
                stricmp(pSection->sectName, "1280") == 0)
                pSection->refCount++;
        }
    }
    
    for (i = 0; i < gCommonSections.GetSize(); i++)
    {
        LPCOMMON_SECTION pSection = gCommonSections.GetAt(i);
        if (pSection->refCount == 0)
            continue;
        fprintf(fp, "[%s]\n", pSection->sectName);
        fprintf(fp, "%s\n\n", pSection->contents);
    }
}

VOID CSumInf::DumpAddRegSection(FILE *fp, CManufacturer *pManufacturer)
{
    fprintf(fp, "; -------------- %s\n", pManufacturer->name);
    for (int i = 0; i < pManufacturer->MonitorArray.GetSize(); i++)
    {
        CMonitor *pMonitor = (CMonitor*)pManufacturer->MonitorArray[i];

        /////////////////////////////////////////////////////////////
        // If this Monitor has duplicated section, ignore it
        if (pMonitor->bDupInstSection)
        {
            continue;
        }

        ASSERT(lstrlen(pMonitor->AddRegSectionBuf) != 0);
        fprintf(fp, "[%s]\n", pMonitor->AddRegSectionName);
        fprintf(fp, "%s\n", pMonitor->AddRegSectionBuf);
    }
}

VOID CSumInf::DumpCommonStringSection(FILE *fp, int start, int end)
{
    LPCOMMON_ALIAS pAlias;
    
    for (int i = 0; i < gCommonAlias.GetSize(); i++)
    {
        pAlias = gCommonAlias.GetAt(i);
        pAlias->refCount = 0;
    }
    
    ///////////////////////////////////////////
    // Calculate RefCount
    for (i = start; i < end; i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)m_ManufacturerArray[i];
        pAlias = pManufacturer->pAlias;
        ASSERT(pAlias != NULL);
        pAlias->refCount++;
        for (int j = 0; j < pManufacturer->MonitorArray.GetSize(); j++)
        {
            CMonitor *pMonitor = (CMonitor*)pManufacturer->MonitorArray[j];
            pAlias = pMonitor->pAlias;
            ASSERT(pAlias != NULL);
            pAlias->refCount++;
        }
    }

    ///////////////////////////////////////////
    // Actual dump
    for (i = start; i < end; i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)m_ManufacturerArray[i];
        pAlias = pManufacturer->pAlias;
        ASSERT(pAlias != NULL);
        if (pAlias->refCount == 1)
        {
            fprintf(fp, "%s=%s\n", pAlias->lpAlias, pAlias->lpContents);
        }
        else
        {
            pAlias->refCount--;
        }
    }
    fprintf(fp, "\n");

    for (i = start; i < end; i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)m_ManufacturerArray[i];
        for (int j = 0; j < pManufacturer->MonitorArray.GetSize(); j++)
        {
            CMonitor *pMonitor = (CMonitor*)pManufacturer->MonitorArray[j];
            pAlias = pMonitor->pAlias;
            ASSERT(pAlias != NULL);
            if (pAlias->refCount == 1)
            {
                fprintf(fp, "%s=%s\n", pAlias->lpAlias, pAlias->lpContents);
            }
            else
            {
                pAlias->refCount--;
            }
        }
        fprintf(fp, "\n");
    }
}

VOID CSumInf::DumpCommonHeader(FILE *fp, int numInfs)
{
    if (numInfs == 0)
    {
        fprintf(fp, "; This is a Setup information file for monitors\n");
        fprintf(fp, "; supported in the Windows 2000 product.\n;\n");
        fprintf(fp, "; Copyright (c) 2000-2001, Microsoft Corporation\n\n");

        fprintf(fp, "[VERSION]\n");
        fprintf(fp, "Signature=\"$CHICAGO$\"\n");
        fprintf(fp, "Class=Monitor\n");
        fprintf(fp, "ClassGUID={4d36e96e-e325-11ce-bfc1-08002be10318}\n");
        fprintf(fp, "Provider=%%MS%%\n");
        fprintf(fp, "DriverVer=11/01/2000\n\n\n");

        fprintf(fp, ";-------------------------------------------------\n");
        fprintf(fp, "; Manufacturers\n\n");
        fprintf(fp, "[Manufacturer]\n");
    }
    else
    {
        fprintf(fp, "; This is Setup information file for monitors \n");
        fprintf(fp, ";\n");
        fprintf(fp, "; Copyright (c) 2000-2001, Microsoft Corporation\n\n");

        fprintf(fp, "[version]\n");
        fprintf(fp, "LayoutFile=layout.inf, layout1.inf\n");
        fprintf(fp, "signature=\"$CHICAGO$\"\n");
        fprintf(fp, "Class=Monitor\n");
        fprintf(fp, "ClassGUID={4d36e96e-e325-11ce-bfc1-08002be10318}\n");
        fprintf(fp, "Provider=%%MS%%\n");
        fprintf(fp, "SetupClass=BASE\n");
        fprintf(fp, "DriverVer=11/01/2000\n\n");

        fprintf(fp, "[DestinationDirs]\n");
        fprintf(fp, "DefaultDestDir    = 11          ; LDID_SYS\n");
        fprintf(fp, "monitor.infs.copy = 17          ; LDID_INF\n\n\n");

        fprintf(fp, "; Base Install Sections\n");
        fprintf(fp, ";-------------------------------------------------\n");
        fprintf(fp, "[BaseWinOptions]\n");
        fprintf(fp, "MonitorBase\n\n");

        fprintf(fp, "[MonitorBase]\n");
        fprintf(fp, "CopyFiles=monitor.infs.copy\n");

        fprintf(fp, "[monitor.infs.copy]\n");
        fprintf(fp, "monitor.inf\n");
        for (int i = 1; i < numInfs; i++)
        {
            fprintf(fp, "monitor%d.inf\n", i+1);
        }

        fprintf(fp, "\n[SysCfgClasses]\n");
        fprintf(fp, "Monitor, %%Unknown.DeviceDesc%%,MONITOR,4,%%MonitorClassName%%   ; Default to \"Unknown Monitor\"\n\n\n");

        fprintf(fp, "; Install class \"Monitor\"\n");
        fprintf(fp, ";-------------------------------------------------\n");
        fprintf(fp, "[ClassInstall]\n");
        fprintf(fp, "AddReg=ClassAddReg\n");

        fprintf(fp, "[ClassAddReg]\n");
        fprintf(fp, "HKR,,,,%%MonitorClassName%%\n");
        fprintf(fp, "HKR,,Installer,,\"SetupX.Dll, Monitor_ClassInstaller\"\n");
        fprintf(fp, "HKR,,Icon,,\"-1\"\n\n");

        fprintf(fp, "[ClassDelReg]\n\n\n");

        fprintf(fp, "[ClassInstall32.NT]\n");
        fprintf(fp, "AddReg=monitor_class_addreg\n");

        fprintf(fp, "[monitor_class_addreg]\n");
        fprintf(fp, "HKR,,,,%%MonitorClassName%%\n");
        fprintf(fp, "HKR,,Installer32,,\"Desk.Cpl,MonitorClassInstaller\"\n");
        fprintf(fp, "HKR,,Icon,,\"-1\"\n");
        fprintf(fp, "HKR,,NoInstallClass,,\"1\"\n");
        fprintf(fp, "HKR,,TroubleShooter-0,,\"hcp://help/tshoot/tsdisp.htm\"\n");
        fprintf(fp, "HKR,,SilentInstall,,1\n\n");

        fprintf(fp, "; Monitors to hide from pick list\n");
        fprintf(fp, ";-------------------------------------------------\n");
        fprintf(fp, "[ControlFlags]\n");
        fprintf(fp, "ExcludeFromSelect=Monitor\\Default_Monitor\n\n");

        fprintf(fp, ";-------------------------------------------------\n");
        fprintf(fp, "; Manufacturers\n\n");
        fprintf(fp, "[Manufacturer]\n");
        fprintf(fp, "%%Generic%%=Generic\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\moninf\moninf.cpp ===
// moninf.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "moninf.h"
#include "moninfDlg.h"
#include "mon.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMoninfApp

BEGIN_MESSAGE_MAP(CMoninfApp, CWinApp)
	//{{AFX_MSG_MAP(CMoninfApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMoninfApp construction

CMoninfApp::CMoninfApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMoninfApp object

CMoninfApp theApp;

/////////////////////////////////////////////////////////////////////////////
// Private Functions

void ReadMonitorInfs(LPCSTR);

/////////////////////////////////////////////////////////////////////////////
// CMoninfApp initialization

BOOL CMoninfApp::InitInstance()
{
    gSumInf.Initialize(REPORT_FILE_NAME);
    
    ReadMonitorInfs(SRC_INF_PATH);

    gSumInf.CheckDupSections();
    gSumInf.CheckDupMonIDs();
    gSumInf.CheckDupAlias();
    gSumInf.DumpMonitorInf(DEST_INF_PATH, FILE_BREAK_SIZE);

    return FALSE;
}

void ReadMonitorInfs(LPCSTR srcDir)
{
    CString     fileName;
    
    fileName = CString(srcDir) + "\\*.*";

    CFileFind finder;

    if (finder.FindFile(fileName))
    {
        BOOL bWorking = TRUE;
        while (bWorking)
        {
            bWorking = finder.FindNextFile();

            if (finder.IsDots())
                continue;

            if (finder.IsDirectory())
            {
                ReadMonitorInfs((LPCSTR)finder.GetFilePath());
                continue;
            }

            //////////////////////////////////////////////
            // Check if it's INF file
            CString fName = finder.GetFileName();
            if (stricmp(fName.Right(4), ".inf") != 0)
                continue;
            
            CMonitorInf *pMonitorInf = new(CMonitorInf);
            if (pMonitorInf == NULL)
                continue;

            //////////////////////////////////////////////
            // Check if it's INF file
            ReadOneMonitorInf(finder.GetFilePath(), pMonitorInf);

            for (int i = 0; i < pMonitorInf->ManufacturerArray.GetSize(); i++)
                gSumInf.AddOneManufacturer((CManufacturer*)pMonitorInf->ManufacturerArray[i]);

            pMonitorInf->ManufacturerArray.RemoveAll();

            delete pMonitorInf;
        }
    }
}

VOID ReadOneMonitorInf(LPCSTR fileName, CMonitorInf *pMonitorInf)
{
    lstrcpy(gszInputFileName, fileName);
    fprintf(gSumInf.m_fpReport, "Handling %s\n", gszInputFileName);

    CFile InfFile(fileName, CFile::modeRead);

    DWORD len = InfFile.GetLength();
    if (len > MAX_INFFILE_SIZE || len <= 20)
        return;
    pMonitorInf->pReadFileBuf = (LPSTR)malloc(len+1024);
    if (pMonitorInf->pReadFileBuf == NULL)
        return;
    
    if (InfFile.Read(pMonitorInf->pReadFileBuf, len) < len)
    {
        free(pMonitorInf->pReadFileBuf);
        return;
    }

    TokenizeInf((LPSTR)pMonitorInf->pReadFileBuf, pMonitorInf);
    
    pMonitorInf->ParseInf();

    free(pMonitorInf->pReadFileBuf);
    pMonitorInf->pReadFileBuf = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\moninf\moninf.h ===
// moninf.h : main header file for the MONINF application
//

#if !defined(AFX_MONINF_H__E201B3A5_9C4D_438D_8248_BAB399E78763__INCLUDED_)
#define AFX_MONINF_H__E201B3A5_9C4D_438D_8248_BAB399E78763__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CMoninfApp:
// See moninf.cpp for the implementation of this class
//

class CMoninfApp : public CWinApp
{
public:
	CMoninfApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMoninfApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMoninfApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MONINF_H__E201B3A5_9C4D_438D_8248_BAB399E78763__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\moninf\moninfdlg.cpp ===
// moninfDlg.cpp : implementation file
//

#include "stdafx.h"
#include "moninf.h"
#include "moninfDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMoninfDlg dialog

CMoninfDlg::CMoninfDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CMoninfDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CMoninfDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CMoninfDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMoninfDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMoninfDlg, CDialog)
	//{{AFX_MSG_MAP(CMoninfDlg)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMoninfDlg message handlers

BOOL CMoninfDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CMoninfDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CMoninfDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\moninf\mon.h ===
#include "stdafx.h"

#define MAX_INFFILE_SIZE	0x60000
#define MAX_LINE_NUMBER     5000
#define MAX_SECTION_NUMBER  1000

const char REPORT_FILE_NAME[] = "d:\\outinf\\report.txt";
const char SRC_INF_PATH[] = "d:\\temp";
const char DEST_INF_PATH[] = "d:\\outinf";
const int  FILE_BREAK_SIZE = 0xFFFFFFFF;   // 0xFFFFFFFF means dump to only one inf

typedef struct tagCommonAlias
{
    DWORD refCount;
    LPSTR lpAlias;
    LPSTR lpContents;
} COMMON_ALIAS, *PCOMMON_ALIAS, *LPCOMMON_ALIAS;

class CCommonAlias
{
public:
    CCommonAlias();
    ~CCommonAlias();
    VOID ClearAll(VOID);
    int  GetSize() const  { return m_Alias.GetSize(); }
    LPCOMMON_ALIAS GetAt(int i) { return (LPCOMMON_ALIAS)m_Alias[i]; }
    LPCOMMON_ALIAS AddOneAlias(LPSTR, LPSTR);

private:
    CPtrArray   m_Alias;
};

typedef struct tagCommonSection
{
    DWORD refCount;
    TCHAR sectName[32];
    TCHAR contents[128];
} COMMON_SECTION, *PCOMMON_SECTION, *LPCOMMON_SECTION;

class CCommonSection
{
public:
    CCommonSection();
    ~CCommonSection();
    VOID ClearAll(VOID);
    int  GetSize() const  { return m_sections.GetSize(); }
    LPCOMMON_SECTION GetAt(int i) const   { return (LPCOMMON_SECTION)m_sections[i]; }
    LPCOMMON_SECTION AddOneSection(LPSTR, LPSTR);

private:
    CPtrArray   m_sections;   
};

typedef struct _SECTION
{
    TCHAR   name[256];
    UINT    startLine, endLine;
} SECTION, *PSECTION, *LPSECTION;

class CMonitor
{
public:
    CMonitor()  { bDupInstSection = FALSE; 
                  pAlias = NULL;
                  AddRegSectionBuf = NULL;
                  numCommonSects = 0; }
    ~CMonitor() { if (AddRegSectionBuf) free(AddRegSectionBuf); }

public:
    BOOL    bDupInstSection;
    TCHAR   AliasName[48];
    LPCOMMON_ALIAS pAlias;
    TCHAR   InstallSectionName[64];
    TCHAR   AddRegSectionName[64];
    TCHAR   ID[16];

    int     numCommonSects;
    LPCOMMON_SECTION CommonSects[8];

    LPSTR   AddRegSectionBuf;
};

class CManufacturer
{
public:
    CManufacturer() { pAlias = NULL; }
    ~CManufacturer();

public:
    TCHAR   name[64];
    TCHAR   AliasName[64];
    LPCOMMON_ALIAS pAlias;

    CPtrArray MonitorArray;
    CPtrArray m_MonitorIDArray;
};

class CMonitorInf
{
public:
    CMonitorInf() { pReadFileBuf = NULL; } 

public:
    LPSTR   pReadFileBuf;
    UINT    numLines;
    LPSTR   lines[MAX_LINE_NUMBER];
    UINT    numSections;
    SECTION sections[MAX_SECTION_NUMBER];

    CPtrArray ManufacturerArray;

private:
    CHAR  m_lineBuf[256];
    LPSTR m_tokens[10];

public:
    ~CMonitorInf();
    
    LPSECTION SeekSection(LPCSTR);
    BOOL      ParseInf(VOID);

private:
    BOOL      ParseOneManufacturer(CManufacturer *);
    BOOL      ParseOneMonitor(CMonitor *);
    VOID      Pack(VOID);
    BOOL      FillupAlias(VOID);
    LPCOMMON_ALIAS LookupCommonAlias(LPCSTR, LPCOMMON_ALIAS, UINT);
};

class CSumInf
{
public:
    CSumInf();
    ~CSumInf();
    VOID Initialize(LPCSTR);
    VOID AddOneManufacturer(CManufacturer*);
    VOID CheckDupSections(VOID);
    VOID CheckDupMonIDs(VOID);
    VOID CheckDupAlias(VOID);
    VOID DumpMonitorInf(LPCSTR, int);

private:
    VOID MergeOneManufacturer(CManufacturer *, CManufacturer *);

    int  DumpManufacturers(LPCSTR, int, int, int);
    VOID DumpManufactureSection(FILE *, CManufacturer *);
    VOID DumpInstallSection(FILE *, CManufacturer *);
    VOID DumpCommonAddRegSection(FILE *, int, int);
    VOID DumpAddRegSection(FILE *, CManufacturer *);
    VOID DumpCommonStringSection(FILE *, int, int);
    VOID DumpCommonHeader(FILE *, int);

private:
    CPtrArray m_ManufacturerArray;
    CPtrArray m_SectionNameArray;
public:
    FILE    *m_fpReport;
};

///////////////////////////////////////////////////////////
// Global variables
extern CCommonSection gCommonSections;
extern CCommonAlias   gCommonAlias;
extern CSumInf        gSumInf;
extern TCHAR          gszMsg[];
extern TCHAR          gszInputFileName[];

///////////////////////////////////////////////////////////
// Global Functions
extern VOID TokenizeInf(LPSTR, CMonitorInf *);
extern UINT TokenOneLine(LPSTR, CHAR, LPSTR);

extern VOID ReadOneMonitorInf(LPCSTR, CMonitorInf *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\moninf\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by MONINF.RC
//
#define IDR_MAINFRAME					128
#define IDD_MONINF_DIALOG				102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE	129
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		101
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\moninf\parseinf.cpp ===
#include "stdafx.h"
#include "mon.h"

TCHAR gszMsg[256];
TCHAR gszInputFileName[512];
    
int compareMonitors(CMonitor *p1, CMonitor *p2)
{
   return (stricmp(&p1->ID[8], &p2->ID[8]));
}

int compareManufacturers(CManufacturer *p1, CManufacturer *p2)
{
   return (stricmp(p1->name, p2->name));
}

////////////////////////////////////////////////////////////////////
// Strip off blank lines and comments
VOID TokenizeInf(LPSTR orgBuf, CMonitorInf *pMonitorInf)
{
    LPSTR linePtr = orgBuf, startPtr, endPtr, outPtr = orgBuf;

    strcat(orgBuf, "\n");
    
    pMonitorInf->numLines = 0;
    
    while (1)
    {
        startPtr = linePtr;
        endPtr  = strchr(linePtr, '\n');
        if (endPtr == NULL)
            break;
        else
            linePtr = endPtr+1;
        *endPtr = '\0';

        // Remove leading space
        while (*startPtr <= ' ' && *startPtr != '\0')
            startPtr++;

        if (strchr(startPtr, ';'))
            endPtr = strchr(startPtr, ';');
        
        //remove trailing space
        while (startPtr != endPtr)
        {
            if (*(endPtr-1) > ' ')
                break; 
            endPtr--;
        }
        *endPtr = '\0';

        // If not blank line, put it back to buf
        if (*startPtr != '\0')
        {
            pMonitorInf->lines[pMonitorInf->numLines] = outPtr;
            pMonitorInf->numLines++;
            ASSERT(pMonitorInf->numLines < MAX_LINE_NUMBER);

            while (*startPtr != '\0')
            {
                *outPtr = *startPtr;
                startPtr++;   outPtr++;
            }
            *outPtr = '\0';
            outPtr++;
        }
    }
    *outPtr = '\0';

    LPSECTION pSection = &pMonitorInf->sections[0];
    pMonitorInf->numSections = 0;
    for (UINT line = 0;
         line < pMonitorInf->numLines;
         line++)
    {
        LPSTR ptr = pMonitorInf->lines[line];
        if (*ptr == '[')
        {
            pSection = &pMonitorInf->sections[pMonitorInf->numSections];
            pSection->startLine = pSection->endLine = line;
            pMonitorInf->numSections++;

            ASSERT(strlen(ptr) <= 250);
            ASSERT(pMonitorInf->numSections < MAX_SECTION_NUMBER);

            strcpy(pSection->name, ptr+1);
            ptr = strchr(pSection->name, ']');
            ASSERT(ptr != NULL);
            *ptr = '\0';
            CString sectionName(pSection->name);
            sectionName.MakeUpper();
            strcpy(pSection->name, sectionName);
        }
        else
            pSection->endLine = line;
    }
}

UINT TokenOneLine(LPSTR line, CHAR token, LPSTR *tokens)
{
    UINT numToken = 0;
    LPSTR ptr;;

    while (ptr = strchr(line, token))
    {
        tokens[numToken] = line;
        *ptr = '\0';
        line = ptr + 1;
        numToken++;
    }
    tokens[numToken] = line;
    numToken++;

    /////////////////////////////////////////////
    // Remove leading and trailing spaces
    for (UINT i = 0; i < numToken; i++)
    {
        ptr = tokens[i];
        while (*ptr <= ' ' && *ptr != '\0')
            ptr++;
        tokens[i] = ptr;

        ptr = ptr+strlen(ptr);
        while (ptr != tokens[i])
        {
            if (*(ptr-1) > ' ')
                break; 
            ptr--;
        }
        *ptr = '\0';
    }

    return numToken;
}

CManufacturer::~CManufacturer()
{
    for (int i = 0; i < MonitorArray.GetSize(); i++)
        delete ((CMonitor *)MonitorArray[i]);
    MonitorArray.RemoveAll();
    m_MonitorIDArray.RemoveAll();
}

CMonitorInf::~CMonitorInf()
{
    for (int i = 0; i < ManufacturerArray.GetSize(); i++)
        delete ((CManufacturer *)ManufacturerArray[i]);
    ManufacturerArray.RemoveAll();

    if (pReadFileBuf)
        free(pReadFileBuf);
}

BOOL CMonitorInf::ParseInf(VOID)
{
    LPSECTION pSection = SeekSection("version");
    if (pSection == NULL)
        return FALSE;

    /////////////////////////////////////////////////////
    // Confirm it's Monitor Class
    for (UINT i = pSection->startLine + 1;
         i <= pSection->endLine;
         i++)
    {
        strcpy(m_lineBuf, lines[i]);
        if (TokenOneLine(m_lineBuf, '=', m_tokens) != 2)
            return FALSE;
        if (stricmp(m_tokens[0], "Class") == 0 &&
            stricmp(m_tokens[1], "Monitor") == 0)
            break;
    }
    if (i > pSection->endLine)
        return FALSE;

    /////////////////////////////////////////////////////
    // Look for Manufacturers 
    //
    // [Manufacturer]
    // %MagCompu%=MagCompu

    pSection = SeekSection("Manufacturer");
    if (pSection == NULL)
        return FALSE;

    for (i = pSection->startLine + 1;
         i <= pSection->endLine;
         i++)
    {
        strcpy(m_lineBuf, lines[i]);
        if (TokenOneLine(m_lineBuf, '=', m_tokens) != 2)
        {
            ASSERT(FALSE);
            return FALSE;
        }

        ////////////////////////////////////////////////////////////
        // Microsoft Generic is special.  Need to be added manually
        if (stricmp(m_tokens[1], "Generic") == 0)
            continue;

        CManufacturer *pManufacturer = new(CManufacturer);
        if (pManufacturer == NULL)
        {
            ASSERT(FALSE);
            return FALSE;
        }
        strcpy(pManufacturer->name, m_tokens[1]);
        strcpy(pManufacturer->AliasName, m_tokens[0]);

        if (!ParseOneManufacturer(pManufacturer))
        {
            sprintf(gszMsg, "Manufacturer %s contains empty contents.", 
                    &pManufacturer->name);
            MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
            ASSERT(FALSE);
            return FALSE;
        }

    	/////////////////////////////////////////////////
        // Insert the manufacturer into the array.
        // It's sorted by name
    	int comp = 1;
        for (int k = 0; k < ManufacturerArray.GetSize(); k++)
    	{
	    	CManufacturer *pMan = (CManufacturer *)ManufacturerArray[k];
    		comp = compareManufacturers(pManufacturer, pMan);

    		if (comp > 0)
	    		continue;
		    else if (comp < 0)
                break;

    		////////////////////////////////////////////
            // Duplicated Manufacturer in one inf ?
            ASSERT(FALSE);

            break;
    	}
    	if (comp == 0)
	    {
		    delete pManufacturer;
    	}
    	else
    	{
		    ManufacturerArray.InsertAt(k, (LPVOID)pManufacturer);
	    }
    }

    ///////////////////////////////////////////////////////
    // Remove Manufacturers with empty monitors
    Pack();

    ASSERT(FillupAlias());

    return TRUE;
}


BOOL CMonitorInf::ParseOneManufacturer(CManufacturer *pManufacturer)
{
    ///////////////////////////////////////////////////////////
    // [NEC]
    // %NEC-XE15%=NEC-XE15, Monitor\NEC3C00
    LPSECTION pSection = SeekSection(pManufacturer->name);
    if (pSection == NULL)
        return FALSE;

    for (UINT i = pSection->startLine + 1; i <= pSection->endLine; i++)
    {
        strcpy(m_lineBuf, lines[i]);
        if (TokenOneLine(m_lineBuf, '=', m_tokens) != 2)
        {
            ASSERT(FALSE);
            return FALSE;
        }
        UINT k = TokenOneLine(m_tokens[1], ',', &m_tokens[2]);
        if (k == 1)
            continue;
        else if (k != 2)
        {
            sprintf(gszMsg, "Manufacturer %s has a bad monitor line %s", 
                    &pManufacturer->name, lines[i]);
            MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
            ASSERT(FALSE);
            return FALSE;
        }

        ///////////////////////////////////////////////////////////
        // Ignore non-pnp monitors
        if (strnicmp(m_tokens[3], "Monitor\\", strlen("Monitor\\")))
            continue;
        if (strlen(m_tokens[3]) != strlen("Monitor\\NEC3C00"))
        {
            sprintf(gszMsg, "Manufacturer %s has a bad monitor line %s", 
                    &pManufacturer->name, lines[i]);
            MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
            ASSERT(FALSE);
            continue;
        }

        CMonitor *pMonitor = new(CMonitor);
        if (pMonitor == NULL)
        {
            ASSERT(FALSE);
            return FALSE;
        }
        strcpy(pMonitor->AliasName, m_tokens[0]);
        strcpy(pMonitor->InstallSectionName, m_tokens[2]);
        strcpy(pMonitor->ID, m_tokens[3]);

        for (k = 8; k < (UINT)lstrlen(pMonitor->ID); k++)
            pMonitor->ID[k] = toupper(pMonitor->ID[k]);

        if (!ParseOneMonitor(pMonitor))
        {
            ASSERT(FALSE);
            return FALSE;
        }

    	/////////////////////////////////////////////////
        // Insert the monitor into the array.
        // It's sorted by ID
    	int comp = 1;
        for (k = 0; k < (UINT)pManufacturer->MonitorArray.GetSize(); k++)
    	{
	    	CMonitor *pMon = (CMonitor *)pManufacturer->MonitorArray[k];
    		comp = compareMonitors(pMonitor, pMon);

    		if (comp > 0)
	    		continue;
		    else if (comp < 0)
                break;

    		////////////////////////////////////////////
            // Duplicated Monitor ?
            sprintf(gszMsg, "Manufacturer %s has duplicated monitor line %s", 
                    &pManufacturer->name, &pMonitor->ID[8]);
            MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
            ASSERT(FALSE);

            break;
    	}
    	if (comp == 0)
	    {
		    delete pMonitor;
    	}
    	else
    	{
		    pManufacturer->MonitorArray.InsertAt(k, (LPVOID)pMonitor);
	    }
    }
    return TRUE;
}

BOOL CMonitorInf::ParseOneMonitor(CMonitor *pMonitor)
{
    ///////////////////////////////////////////////////////////
    // [NEC-XE15]
    // DelReg=DCR
    // AddReg=NEC-XE15.Add, 1280, DPMS, ICM12
    //
    // [NEC-XE15.Add]
    // HKR,"MODES\1024,768",Mode1,,"31.0-65.0,55.0-120.0,+,+"
    LPSECTION pSection = SeekSection(pMonitor->InstallSectionName);
    if (pSection == NULL)
    {
        sprintf(gszMsg, "Monitor %s/%s misses InstallSection\n", 
                &pMonitor->ID[8], pMonitor->InstallSectionName);
        MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
        ASSERT(FALSE);
        return FALSE;
    }

    for (UINT i = pSection->startLine + 1; i <= pSection->endLine; i++)
    {
        TCHAR buf[256];
        strcpy(buf, lines[i]);
        if (TokenOneLine(buf, '=', m_tokens) != 2)
        {
            ASSERT(FALSE);
            return FALSE;
        }

        if (stricmp(m_tokens[0], "DelReg") == 0)
        {
            ASSERT(TokenOneLine(m_tokens[1], ',', &m_tokens[2]) == 1);
        }
        else if (stricmp(m_tokens[0], "AddReg") == 0)
        {
            int numAddReg = TokenOneLine(m_tokens[1], ',', &m_tokens[2]);
            strcpy(pMonitor->AddRegSectionName, m_tokens[2]);
            for (int j = 1; j < numAddReg; j++)
            {
                //////////////////////////////////////////////////////
                // Ignore ICM sectione
                if (strnicmp(m_tokens[j+2], "ICM", lstrlen("ICM")) == 0)
                    continue;
                LPSECTION pSection1 = SeekSection(m_tokens[j+2]);
                if (pSection1 == NULL)
                {
                    sprintf(gszMsg, "Monitor %s/%s misses common InstallSection %s\n", 
                            &pMonitor->ID[8], pMonitor->InstallSectionName, m_tokens[j+2]);
                    MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
                    ASSERT(FALSE);
                    return FALSE;
                }
                ASSERT(pSection1->endLine == (pSection1->startLine+1));
                pMonitor->CommonSects[pMonitor->numCommonSects] = 
                    gCommonSections.AddOneSection(m_tokens[j+2], lines[pSection1->endLine]);
                pMonitor->numCommonSects++;
            }
        }
    }

    pSection = SeekSection(pMonitor->AddRegSectionName);
    if (pSection == NULL)
    {
        sprintf(gszMsg, "Monitor %s/%s misses AddRegSection %s\n", 
                &pMonitor->ID[8], pMonitor->InstallSectionName, pMonitor->AddRegSectionName);
        MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
        ASSERT(FALSE);
        return FALSE;
    }

    int lenBuf = 0;
    for (i = pSection->startLine + 1; i <= pSection->endLine; i++)
    {
        lenBuf += strlen(lines[i])+3;
    }
    if (lenBuf == 0)
    {
        sprintf(gszMsg, "Monitor %s/%s has empty AddRegSection\n", 
                &pMonitor->ID[8], pMonitor->InstallSectionName);
        MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
        ASSERT(FALSE);
    }
    pMonitor->AddRegSectionBuf = (LPSTR)malloc(sizeof(TCHAR)*lenBuf);
    if (pMonitor->AddRegSectionBuf == NULL)
    {
        ASSERT(FALSE);
        return FALSE;
    }

    pMonitor->AddRegSectionBuf[0] = '\0';
    for (i = pSection->startLine + 1; i <= pSection->endLine; i++)
    {
        if ((strnicmp(lines[i], "HKR,\"MODES\\", lstrlen("HKR,\"MODES\\")) == 0) ||
            (stricmp(lines[i], "HKR,,DPMS,,0") == 0))
        {
            sprintf(pMonitor->AddRegSectionBuf + strlen(pMonitor->AddRegSectionBuf),
                    "%s\n", lines[i]);
        }
        else if (strnicmp(lines[i], "HKR,,ICMProfile,0,", lstrlen("HKR,,ICMProfile,1,")) == 0)
        {
        }
        //////////////////////////////////////////////////////////////
        // Anything other than modes, put them into common section
        else if (strnicmp(lines[i], "HKR,,ICMProfile,1,", lstrlen("HKR,,ICMProfile,1,")) == 0)
        {
            // Ignore ICMs
            /*
            TCHAR buf[16];
            LPSTR ptr = lines[i] + lstrlen("HKR,,ICMProfile,1,"), stopPtr;
            ASSERT(lstrlen(ptr) == 1 || lstrlen(ptr) == 2);
            *ptr = tolower(*ptr);
            long icmNum = strtoul(ptr, &stopPtr, 16);
            sprintf(buf, "ICM%d", icmNum);
            pMonitor->CommonSects[pMonitor->numCommonSects] = 
                gCommonSections.AddOneSection(buf, lines[i]);
            pMonitor->numCommonSects++;
            */
        }
        else if (stricmp(lines[i], "HKR,,DPMS,,1") == 0)
        {
            pMonitor->CommonSects[pMonitor->numCommonSects] = 
                gCommonSections.AddOneSection("DPMS", lines[i]);
            pMonitor->numCommonSects++;
        }
        else if (strnicmp(lines[i], "HKR,,MaxResolution,,\"", lstrlen("HKR,,MaxResolution,,\"")) == 0)
        {
            TCHAR buf[64];
            LPSTR ptr;
            strcpy(buf, lines[i] + lstrlen("HKR,,MaxResolution,,\""));
            ptr = strchr(buf, ',');
            ASSERT(ptr != NULL);
            *ptr = '\0';
            pMonitor->CommonSects[pMonitor->numCommonSects] = 
                gCommonSections.AddOneSection(buf, lines[i]);
            pMonitor->numCommonSects++;
        }
        /////////////////////////////////////////////////////////////////////////
        // Something common in specific Manufacturers
        else if ((strnicmp(lines[i], "HKR,,LF,0,1", lstrlen("HKR,,LF,0,1")) == 0) ||
                 (strnicmp(lines[i], "HKR,,VE,0,1", lstrlen("HKR,,LF,0,1")) == 0))
        {
        }
        else
        {
            sprintf(gszMsg, "Monitor %s/%s has unexpected AddReg Section %s", 
                    &pMonitor->ID[8], pMonitor->InstallSectionName, lines[i]);
            MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
            ASSERT(FALSE);
        }
    }

    return TRUE;
}

LPSECTION CMonitorInf::SeekSection(LPCSTR sectionName)
{
    for (UINT i = 0; i < numSections; i++)
    {
        if (stricmp(sections[i].name, sectionName) == 0)
            return &sections[i];
    }
    return NULL;
}

VOID CMonitorInf::Pack(VOID)
{
    for (int i = 0; i < ManufacturerArray.GetSize(); i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)ManufacturerArray[i];
        if (pManufacturer->MonitorArray.GetSize() == 0)
        {
            delete pManufacturer;
            ManufacturerArray.RemoveAt(i);
            i--;
        }
    }
}

LPCOMMON_ALIAS CMonitorInf::LookupCommonAlias(LPCSTR lpAliasName, LPCOMMON_ALIAS AliasHead, UINT numAlias)
{
    TCHAR name[64];
    lstrcpy(name, lpAliasName+1);

    ASSERT(lpAliasName[0] == '%');
    ASSERT(lpAliasName[lstrlen(name)] == '%');

    name[lstrlen(name)-1] = '\0';
    for (UINT i = 0; i < numAlias; i++)
    {
        if (stricmp(name, AliasHead[i].lpAlias) == 0)
            return &AliasHead[i];
    }
    return NULL;
}

BOOL CMonitorInf::FillupAlias(VOID)
{
    /////////////////////////////////////////////////////////////////////
    // First read in all strings
    LPSECTION pSection = SeekSection("Strings");
    if (pSection == NULL)
    {
        ASSERT(FALSE);
        return FALSE;
    }

    int numAlias = pSection->endLine - pSection->startLine;
    ASSERT(numAlias > 0);
    LPCOMMON_ALIAS pInfAlias = (LPCOMMON_ALIAS)malloc(numAlias * sizeof(COMMON_ALIAS));
    if (pInfAlias == NULL)
    {
        ASSERT(FALSE);
        return FALSE;
    }

    LPCOMMON_ALIAS pAlias = pInfAlias;
    for (UINT i = pSection->startLine + 1; i <= pSection->endLine; i++, pAlias++)
    {
        if (TokenOneLine(lines[i], '=', m_tokens) != 2)
        {
            sprintf(gszMsg, "A wrong string line %s.", lines[i]);
            MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
            ASSERT(FALSE);
            free(pInfAlias);
            return FALSE;
        }
        pAlias->lpAlias    = m_tokens[0];
        pAlias->lpContents = m_tokens[1];
        ASSERT(pAlias->lpContents[0] == '\"');
    }

    //////////////////////////////////////////////////////////
    // Go through Manufacturers and Monitors to fill up alias
    for (i = 0; i < (UINT)ManufacturerArray.GetSize(); i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)ManufacturerArray[i];
        pAlias = LookupCommonAlias(pManufacturer->AliasName, pInfAlias, numAlias);
        if (pAlias == NULL)
        {
            ASSERT(FALSE);
            free(pInfAlias);
            return FALSE;
        }
        pAlias = gCommonAlias.AddOneAlias(pAlias->lpAlias, pAlias->lpContents);
        if (pAlias == NULL)
        {
            ASSERT(FALSE);
            free(pInfAlias);
            return FALSE;
        }
        pManufacturer->pAlias = pAlias;

        for (int j = 0; j < pManufacturer->MonitorArray.GetSize(); j++)
        {
            CMonitor *pMonitor = (CMonitor*)pManufacturer->MonitorArray[j];
            pAlias = LookupCommonAlias(pMonitor->AliasName, pInfAlias, numAlias);
            if (pAlias == NULL)
            {
                ASSERT(FALSE);
                free(pInfAlias);
                return FALSE;
            }
            pAlias = gCommonAlias.AddOneAlias(pAlias->lpAlias, pAlias->lpContents);
            if (pAlias == NULL)
            {
                ASSERT(FALSE);
                free(pInfAlias);
                return FALSE;
            }
            pMonitor->pAlias = pAlias;
        }
    }

    free(pInfAlias);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\moninf\moninfdlg.h ===
// moninfDlg.h : header file
//

#if !defined(AFX_MONINFDLG_H__AFA00218_49B2_4ECE_B50B_2B4346F8568F__INCLUDED_)
#define AFX_MONINFDLG_H__AFA00218_49B2_4ECE_B50B_2B4346F8568F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CMoninfDlg dialog

class CMoninfDlg : public CDialog
{
// Construction
public:
	CMoninfDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CMoninfDlg)
	enum { IDD = IDD_MONINF_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMoninfDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CMoninfDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MONINFDLG_H__AFA00218_49B2_4ECE_B50B_2B4346F8568F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\moninf\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__7B6427A5_8935_44EF_B39F_82AFC0FF0B3E__INCLUDED_)
#define AFX_STDAFX_H__7B6427A5_8935_44EF_B39F_82AFC0FF0B3E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7B6427A5_8935_44EF_B39F_82AFC0FF0B3E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\moninf\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	moninf.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\moninf\suminf.cpp ===
#include "stdafx.h"
#include "mon.h"

extern int compareManufacturers(CManufacturer *, CManufacturer *);
extern int compareMonitors(CMonitor *, CMonitor *);

CSumInf gSumInf;

CSumInf::CSumInf()
{
    m_fpReport = NULL;
}
CSumInf::~CSumInf()
{
    if (m_fpReport)
        fclose(m_fpReport);

    for (int i = 0; i < m_ManufacturerArray.GetSize(); i++)
    {
		delete((CManufacturer *)m_ManufacturerArray[i]);
    }
    
    m_ManufacturerArray.RemoveAll();
    m_SectionNameArray.RemoveAll();
}

VOID CSumInf::Initialize(LPCSTR reportFileName)
{
	m_fpReport = fopen(reportFileName, "w");
	if (m_fpReport == NULL)
	{
		ASSERT(FALSE);
	}
    m_ManufacturerArray.RemoveAll();
    m_SectionNameArray.RemoveAll();
}

VOID CSumInf::AddOneManufacturer(CManufacturer *pManufacturer)
{
    /////////////////////////////////////////////////
    // Insert the manufacturer into the array.
    // It's sorted by name
    int comp = 1;
    for (int i = 0; i < m_ManufacturerArray.GetSize(); i++)
    {
    	comp = compareManufacturers(pManufacturer, (CManufacturer *)m_ManufacturerArray[i]);

    	if (comp <= 0)
            break;
    }
    if (comp == 0)
	{
		MergeOneManufacturer((CManufacturer *)m_ManufacturerArray[i], pManufacturer);
        delete pManufacturer;
    }
    else
    {
		m_ManufacturerArray.InsertAt(i, (LPVOID)pManufacturer);
	}
}

VOID CSumInf::MergeOneManufacturer(CManufacturer *pDestManufacturer,
                                   CManufacturer *pSrcManufacturer)
{
    CPtrArray &SrcMonitorArray = pSrcManufacturer->MonitorArray,
              &DestMonitorArray = pDestManufacturer->MonitorArray;

    for (int i = 0; i < SrcMonitorArray.GetSize(); i++)
    {
        CMonitor *pMonitor = (CMonitor *)SrcMonitorArray[i];
        
        /////////////////////////////////////////////////
        // Insert the monitor into the array.
        // It's sorted by ID
    	int comp = 1;
        for (int k = 0; k < DestMonitorArray.GetSize(); k++)
    	{
    		comp = compareMonitors(pMonitor, (CMonitor *)DestMonitorArray[k]);

    		if (comp <= 0)
                break;
    	}
    	if (comp == 0)
	    {
            fprintf(m_fpReport, "Warning: %s is duplicated.  Please Check.\n", pMonitor->ID);
            delete pMonitor;
    	}
    	else
    	{
		    DestMonitorArray.InsertAt(k, (LPVOID)pMonitor);
	    }
    }
    SrcMonitorArray.RemoveAll();
}

VOID CSumInf::CheckDupSections(VOID)
{
    fprintf(m_fpReport, "\n");

    CPtrArray sectionNameArray;
    
    int comp = 1;
    for (int i = 0; i < m_ManufacturerArray.GetSize(); i++)
    {
	    CManufacturer *pMan = (CManufacturer *)m_ManufacturerArray[i];

        sectionNameArray.Add(pMan->name);

        /////////////////////////////////////////////////////////////
        // Search for duplicated Install section inside one manufacturer
        // Only this duplication is allowed.
        for (int j = 0; j < pMan->MonitorArray.GetSize(); j++)
        {
            CMonitor *pMon = (CMonitor*)pMan->MonitorArray[j];

            if (pMon->bDupInstSection)
                continue;
            
            for (int k = j+1; k < pMan->MonitorArray.GetSize(); k++)
            {
                CMonitor *pMon1 = (CMonitor*)pMan->MonitorArray[k];
                if (stricmp(pMon->InstallSectionName, pMon1->InstallSectionName) == 0)
                {
                    pMon1->bDupInstSection = TRUE;
                    fprintf(m_fpReport, "Information: \"%s\" AND \"%s\" have same install section [%s].  Please check.\n",
                            &pMon->ID[8], &pMon1->ID[8], pMon->InstallSectionName);
                }
            }

            sectionNameArray.Add(pMon->InstallSectionName);
            sectionNameArray.Add(pMon->AddRegSectionName);
        }
    }

    fprintf(m_fpReport, "\n");

    for (i = 0; i < sectionNameArray.GetSize(); i++)
    {
        LPCSTR pName = (LPCSTR)sectionNameArray[i]; 
        /////////////////////////////////////////////////
        // Insert the sectionName into m_SectionNameArray.
        // It's sorted by name
        int comp = 1;
        for (int j = 0; j < m_SectionNameArray.GetSize(); j++)
        {
    	    comp = stricmp(pName, (LPCSTR)m_SectionNameArray[j]);

            if (comp <= 0)
                break;
        }
        if (comp == 0)
        {
            fprintf(m_fpReport, "Error: Found duplicated section %s\n", pName);
        }
        else
        {
            m_SectionNameArray.InsertAt(j, (LPVOID)pName);
        }
    }
    fprintf(m_fpReport, "\n");
}

////////////////////////////////////////////////////////////////////
// Check if different manufacturers may contain same IDs
// So these manufacturers can be potentialy merged
VOID CSumInf::CheckDupMonIDs(VOID)
{
    for (int i = 0; i < m_ManufacturerArray.GetSize(); i++)
    {
	    CManufacturer *pMan = (CManufacturer *)m_ManufacturerArray[i];
        pMan->m_MonitorIDArray.RemoveAll();

        ASSERT(pMan->MonitorArray.GetSize() > 0);
        
        LPCTSTR pID = ((CMonitor*)pMan->MonitorArray[0])->ID;
        pMan->m_MonitorIDArray.Add((LPVOID)pID);
        
        for (int j = 1; j < pMan->MonitorArray.GetSize(); j++)
        {
            CMonitor *pMon = (CMonitor*)pMan->MonitorArray[j];

            if (strnicmp(pID, pMon->ID, lstrlen("Monitor\\NEC")) != 0)
            {
                pID = pMon->ID;
                pMan->m_MonitorIDArray.Add((LPVOID)pID);
            }
        }
    }

    for (i = 0; i < m_ManufacturerArray.GetSize(); i++)
    {
	    CManufacturer *pMan = (CManufacturer *)m_ManufacturerArray[i];

        for (int j = 0; j < pMan->m_MonitorIDArray.GetSize(); j++)
        {
            LPCTSTR pID = (LPCTSTR)pMan->m_MonitorIDArray[j];

            for (int i1 = i+1; i1 < m_ManufacturerArray.GetSize(); i1++)
            {
        	    CManufacturer *pMan1 = (CManufacturer *)m_ManufacturerArray[i1];
                for (int j1 = 0; j1 < pMan1->m_MonitorIDArray.GetSize(); j1++)
                {
                    LPCTSTR pID1 = (LPCTSTR)pMan1->m_MonitorIDArray[j1];
                    if (strnicmp(pID, pID1, lstrlen("Monitor\\NEC")) == 0)
                    {
                        fprintf(m_fpReport, "Warning: \"%s\" AND \"%s\" have same monitor ID %c%c%c.  Consider merging.\n",
                                pMan->name, pMan1->name, pID[8], pID[9], pID[10]);
                    }
                }
            }
        }
    }

    fprintf(m_fpReport, "\n");
}


VOID CSumInf::CheckDupAlias(VOID)
{
    LPCOMMON_ALIAS pAlias;
    
    for (int i = 0; i < gCommonAlias.GetSize(); i++)
    {
        pAlias = gCommonAlias.GetAt(i);
        pAlias->refCount = 0;
    }
    
    ///////////////////////////////////////////
    // Calculate RefCount
    for (i = 0; i < m_ManufacturerArray.GetSize(); i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)m_ManufacturerArray[i];
        pAlias = pManufacturer->pAlias;
        ASSERT(pAlias != NULL);
        pAlias->refCount++;
        for (int j = 0; j < pManufacturer->MonitorArray.GetSize(); j++)
        {
            CMonitor *pMonitor = (CMonitor*)pManufacturer->MonitorArray[j];
            pAlias = pMonitor->pAlias;
            ASSERT(pAlias != NULL);
            pAlias->refCount++;
        }
    }

    for (i = 0; i < gCommonAlias.GetSize(); i++)
    {
        pAlias = gCommonAlias.GetAt(i);

        if (pAlias->refCount != 1)
        {
            fprintf(m_fpReport, "Information: String %%%s%% has RefCount %d\n",
                    pAlias->lpAlias, pAlias->refCount);
        }
    }
    fprintf(m_fpReport, "\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\vchk\ilimpchk.h ===
#ifndef __ILLEGAL_IMPORTS_CHECK_H__
#define __ILLEGAL_IMPORTS_CHECK_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
    LPSTR   Ptr;
    int     Num;
} Names;

BOOL    InitIllegalImportsSearch (LPCSTR FileName, LPCSTR SectionNames /*, LPCSTR AllowedImportDLLs*/);
Names   CheckSectionsForImports (void);
Names   GetImportsList (LPCSTR ModuleName);
void    FinilizeIllegalImportsSearch (void);
LPSTR   GetNextName(LPSTR NamePtr);

#ifdef __cplusplus
}
#endif

#endif  // __ILLEGAL_IMPORTS_CHECK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\vchk\allowed.h ===
#pragma once

/*
class ImportsModule : public CString {
public:
    ImportsModule (LPCSTR name);
    void AddImport (LPCSTR name);
    void AddImport (LPCSTR name, LPCSTR msg);
    BOOL Lookup (LPCSTR name);
    int  CountImports (void);
private:
    CStringList         m_illegal;
    CMapStringToString  m_messages;
};
*/

class ModulesAndImports {
public:
    ModulesAndImports();
    virtual ~ModulesAndImports();
    void SetModule (LPCSTR name);
    void AddImport (LPCSTR name, LPCSTR msg = "");
    // LPCSTR CurrentModule (void);
    // BOOL AnyImports (void); // are any imports disallowed with the last module defined?
    BOOL IsModule (LPCSTR name);
    BOOL Lookup (LPCSTR name, CString& msg);
    BOOL Lookup (LPCSTR name);
private:
    // ImportsModule* m_curr_module;
    CString        m_curr_module;
    // CPtrList       m_modules;
    CMapStringToString  m_imports;
};

/*
inline
ImportsModule::ImportsModule (LPCSTR name) :
    CString (name)
{
}

inline
void
ImportsModule::AddImport (LPCSTR name)
{
    m_illegal.AddTail (name);
}

inline
void
ImportsModule::AddImport (LPCSTR name, LPCSTR msg)
{
    this->AddImport (name);
    m_messages[msg] = name;
}

inline
BOOL
ImportsModule::Lookup (LPCSTR name)
{
    return (m_illegal.Find (name) != NULL);
}

inline
int
ImportsModule::CountImports (void)
{
    return m_illegal.GetCount();
}
*/

inline
ModulesAndImports::ModulesAndImports () :
    m_curr_module ("")
{
}

inline
void
ModulesAndImports::SetModule (LPCSTR name)
{
    /*
    m_curr_module = new ImportsModule (name);
    // if (!m_curr_module) ...
    m_curr_module->MakeUpper();
    m_modules.AddTail(m_curr_module);
    */
    m_curr_module = name;
    m_imports.SetAt (m_curr_module, "");
}

inline
void
ModulesAndImports::AddImport (LPCSTR name, LPCSTR msg)
{
    /*
    if (m_curr_module)
        m_curr_module->AddImport (name);
    */
    m_imports.SetAt (m_curr_module+CString("!")+CString(name), msg);
}

/*
inline
BOOL
ModulesAndImports::AnyImports (void)
{
    return (m_imports->CountImports () != 0);
}
*/

/*
inline
LPCSTR
ModulesAndImports::CurrentModule (void)
{
    if (m_curr_module)
        return (LPCSTR)(CString)(*m_curr_module);
}
*/

inline
BOOL
ModulesAndImports::Lookup (LPCSTR name)
{
    CString msg;
    return Lookup (name, msg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\vchk\ilimpchk.cpp ===
#include "stdafx.h"
#include <io.h>
#include "vchk.h"
#include "ilimpchk.h"
#include "pefile.h"

#define NAMES_LIST_BUFSIZE  (1024)
#define TMP_BUFFERS (1024)

char    ImportSectionNames [NAMES_LIST_BUFSIZE];
// char    AllowedImportDLLsNames [NAMES_LIST_BUFSIZE];

// extern AllowedAndIllegals allowx;

Names Modules = { NULL, 0 };

LPSTR  FoundSectionName = NULL;

LPVOID FileData = NULL;

BOOL
InitIllegalImportsSearch (LPCSTR FileName, LPCSTR SectionNames/*, AllowedAndIllegals& allowx*/)
/*
    SectionNames        -   possible names of import sections, despite .idata
    AllowedImportDLLs   -   DLLs, which are allowed to be among importers
*/
{
    int ofs = 0;
    int fno = 0;
    size_t flen = 0;
    FILE* fp = fopen (FileName,"rb");
    if (!fp)
        return FALSE;
    fno = _fileno( fp );
    flen = (size_t)_filelength (fno);
    if (flen<=0)
        return FALSE;
    if (FileData)
        free (FileData);
    FileData = malloc (flen);
    if (!FileData)
        return FALSE;
    if (fread (FileData, 1, flen, fp) != flen)
        return FALSE;
    fclose (fp);
    
    ofs = 0;
    if (SectionNames) {
        LPCSTR SecName;
        for (SecName = SectionNames; *SecName; SecName++, ofs++) {
            strcpy (ImportSectionNames+ofs, SecName);
            ofs += strlen (SecName);
            SecName += strlen (SecName);
        }
        *(ImportSectionNames+ofs) = 0;
    }
    else {
        ImportSectionNames[0] = 0;
        ImportSectionNames[1] = 0;
    }

    ofs=0;
    /*
    if (AllowedImportDLLs) {
        LPCSTR DllName;
        for (DllName = AllowedImportDLLs; *DllName; DllName++, ofs++) {
            strcpy (AllowedImportDLLsNames+ofs, DllName);
            ofs += strlen (DllName);
            DllName += strlen (DllName);
        }
        *(AllowedImportDLLsNames+ofs) = 0;
    }
    else {
        AllowedImportDLLsNames[0] = 0;
        AllowedImportDLLsNames[1] = 0;
    }
    */

    Modules.Ptr = NULL;
    Modules.Num = 0;
    return TRUE;
}

LPSTR GetNextName(LPSTR NamePtr)
{
    if (!NamePtr || !*NamePtr)
        return NULL;
    NamePtr += (strlen (NamePtr) + 1);
    if (*NamePtr)
        return NamePtr;
    return NULL;
}

/*
BOOL
IsAllowedModuleName (LPCSTR ModuleName)
{
    LPCSTR AllowedName;

    for (AllowedName = AllowedImportDLLsNames;
         *AllowedName;
         AllowedName += (strlen(AllowedName)+1)) {

             if (!strcmp (AllowedName, ModuleName))
                 return TRUE;
         }
    
    return FALSE;
}
*/

void
FreeName (Names name)
{
    HeapFree (GetProcessHeap(), 0, name.Ptr);
}

Names
CheckSectionsForImports (void)
/*
    Returns buffer with the names of import sections.
    This memory is been freed during FinilizeIllegalImportsSearch,
    one need not free it manually.
*/
{
    char* SectionName;

    Modules.Num = GetImportModuleNames (FileData, ".idata", &Modules.Ptr);
    if (Modules.Num <= 0) {
        for (SectionName = ImportSectionNames; *SectionName; SectionName++) {

            Modules.Num = GetImportModuleNames (FileData, SectionName, &Modules.Ptr);

            if (Modules.Num > 0) {
                FoundSectionName = SectionName;
                break;
            }
            SectionName += strlen (SectionName);
        }
    }
    return Modules;
}

Names GetImportsList (LPCSTR ModuleName)
/*
    Returns buffer with the names of import functions for ModuleName.
    This memory is been freed during FinilizeIllegalImportsSearch,
    one need not free it manually.
*/
{
    Names Imports = {NULL, 0};
    Imports.Num = GetImportFunctionNamesByModule (FileData,
                                                  FoundSectionName,
                                                  (char*)ModuleName,
                                                  &Imports.Ptr);
    return Imports;
}

void
FinilizeIllegalImportsSearch (void)
/*
    Frees temporarily allocated memory.
*/
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\tseng\mini\cmdcnst.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cmdcnst.h

Abstract:

    This is the command string interpreter definitions

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//--------------------------------------------------------------------------
//   Definition of the set/clear mode command language.
//
//   Each command is composed of a major portion and a minor portion.
//   The major portion of a command can be found in the most significant
//   nibble of a command byte, while the minor portion is in the least
//   significant portion of a command byte.
//
//   maj  minor      Description
//   ---- -----      --------------------------------------------
//   00              End of data
//
//   10              in and out type commands as described by flags
//        flags:
//
//        xxxx
//        ||||
//        |||+-------- unused
//        ||+--------- 0/1 single/multiple values to output (in's are always 
//        |+---------- 0/1 8/16 bit operation                  single)
//        +----------- 0/1 out/in instruction
//
//       Outs
//       ----------------------------------------------
//       0           reg:W val:B
//       2           reg:W cnt:W val1:B val2:B...valN:B
//       4           reg:W val:W
//       6           reg:W cnt:W val1:W val2:W...valN:W
//
//       Ins
//       ----------------------------------------------
//       8           reg:W
//       a           reg:W cnt:W
//       c           reg:W
//       e           reg:W cnt:W
//
//   20              Special purpose outs
//       00          do indexed outs for seq, crtc, and gdc
//                   indexreg:W cnt:B startindex:B val1:B val2:B...valN:B
//       01          do indexed outs for atc
//                   index-data_reg:W cnt:B startindex:B val1:B val2:B...valN:B
//       02          do masked outs
//                   indexreg:W andmask:B xormask:B
//
//   F0              Nop
//
//---------------------------------------------------------------------------

// some useful equates - major commands

#define EOD     0x000                   // end of data
#define INOUT   0x010                   // do ins or outs
#define METAOUT 0x020                   // do special types of outs
#define NCMD    0x0f0                   // Nop command


// flags for INOUT major command

//#define UNUSED    0x01                    // reserved
#define MULTI   0x02                    // multiple or single outs
#define BW      0x04                    // byte/word size of operation
#define IO      0x08                    // out/in instruction

// minor commands for metout

#define INDXOUT 0x00                    // do indexed outs
#define ATCOUT  0x01                    // do indexed outs for atc
#define MASKOUT 0x02                    // do masked outs using and-xor masks


// composite inout type commands

#define OB      (INOUT)                 // output 8 bit value
#define OBM     (INOUT+MULTI)           // output multiple bytes
#define OW      (INOUT+BW)              // output single word value
#define OWM     (INOUT+BW+MULTI)        // output multiple words

#define IB      (INOUT+IO)              // input byte
#define IBM     (INOUT+IO+MULTI)        // input multiple bytes
#define IW      (INOUT+IO+BW)           // input word
#define IWM     (INOUT+IO+BW+MULTI)     // input multiple words
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\vchk\allowed.cpp ===
#include "stdafx.h"
#include "allowed.h"

using namespace std;

ModulesAndImports::~ModulesAndImports ()
{
    /*
    while (!m_modules.IsEmpty())
        delete (ImportsModule*)m_modules.RemoveTail();
    */
}

BOOL
ModulesAndImports::IsModule (LPCSTR name)
{
    CString str;
    m_curr_module = name;
    return m_imports.Lookup (name, str);


    /*
    CString strname (name);
    strname.MakeUpper ();
    for (POSITION pos = m_modules.GetHeadPosition();pos != NULL;m_modules.GetNext(pos)) {
        m_curr_module = (ImportsModule*)m_modules.GetAt(pos);

        // cerr << "comparing " << (LPCSTR)strname << " and " << (LPCSTR)(*m_curr_module) << endl;

        if (strname == *m_curr_module)
            return TRUE;
    }

    m_curr_module = NULL;
    return FALSE;
    */
}

BOOL
ModulesAndImports::Lookup (LPCSTR name, CString& msg)
{
    /*
    if (m_curr_module) {
        // cerr << "checking for " << name << endl;
        return m_curr_module->Lookup (name);
    }
    return FALSE;
    */
    msg = "";
    return m_imports.Lookup (m_curr_module+CString("!")+CString(name), msg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\vchk\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__8F396420_7660_4704_9B99_07785DF4F2B4__INCLUDED_)
#define AFX_STDAFX_H__8F396420_7660_4704_9B99_07785DF4F2B4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afx.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <iostream>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8F396420_7660_4704_9B99_07785DF4F2B4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\vchk\vchk.cpp ===
// vchk.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "windows.h"
#include "allowed.h"
#include "vchk.h"
#include "ilimpchk.h"
// #include "dispinfo.h"
#include <devguid.h>
#include <setupapi.h>
#include <regstr.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

using namespace std;

/////////////////////////////////////////////////////////////////////////////
// The one and only application object

inline
void
CDrvchkApp::PrintOut (LPCSTR str)
{
    if (m_logf)
        fprintf (m_logf, "%s", str);
    else
        cerr << str;
}

inline
void
CDrvchkApp::PrintOut (unsigned num)
{
    if (m_logf)
        fprintf (m_logf, "%d", num);
    else
        cerr << num;
}

ModulesAndImports allowed_modules;
ModulesAndImports known_illegal;
ModulesAndImports illegal_msgs;

void BuildInAllowedAndIllegal (void)
{
    allowed_modules.SetModule ("VIDEOPRT.SYS");

    known_illegal.SetModule ("HAL.dll");
    illegal_msgs.SetModule ("HAL.dll");

    illegal_msgs.AddImport ("HalAllocateCommonBuffer", "use VideoPortAllocateCommonBuffer");
    illegal_msgs.AddImport ("HalFreeCommonBuffer", "use VideoPortFreeCommonBuffer");

    known_illegal.AddImport ("HalGetAdapter", "obsolete; see DDK manual");
    known_illegal.AddImport ("HalGetBusData", "obsolete; see DDK manual");


    known_illegal.AddImport ("HalGetBusDataByOffset");              //  warning
    known_illegal.AddImport ("HalSetBusData");                      //  warning
    known_illegal.AddImport ("HalSetBusDataByOffset");              //  warning

    illegal_msgs.AddImport ("KeGetCurrentIrql", "use VideoPortGetCurrentIrql");
    illegal_msgs.AddImport ("KfAcquireSpinLock", "use VideoPortAcquireSpinLock");
    illegal_msgs.AddImport ("KfReleaseSpinLock", "use VideoPortReleaseSpinLock");
    illegal_msgs.AddImport ("READ_PORT_ULONG", "use VideoPortReadPortUlong");
    illegal_msgs.AddImport ("WRITE_PORT_ULONG", "use VideoPortWritePortUlong");


    known_illegal.SetModule ("NTOSKRNL.EXE");
    illegal_msgs.SetModule ("NTOSKRNL.EXE");
    known_illegal.AddImport ("MmQuerySystemSize");                  //  warning
    known_illegal.AddImport ("_except_handler3");                   //  warning
    known_illegal.AddImport ("ZwMapViewOfSection");                 //  warning
    known_illegal.AddImport ("ZwUnmapViewOfSection");               //  warning
    known_illegal.AddImport ("IoAllocateMdl");                      //  warning
    known_illegal.AddImport ("IoFreeMdl");                          //  warning
    known_illegal.AddImport ("MmBuildMdlForNonPagedPool");          //  warning
    known_illegal.AddImport ("MmGetPhysicalAddress");               //  warning
    known_illegal.AddImport ("ObReferenceObjectByHandle");          //  warning
    known_illegal.AddImport ("RtlUnwind");                          //  warning
    known_illegal.AddImport ("ZwOpenSection");                      //  warning

    illegal_msgs.AddImport ("ExAllocatePool", "use VideoPortAllocatePool");
    illegal_msgs.AddImport ("ExAllocatePoolWithTag", "use VideoPortAllocatePool");
    illegal_msgs.AddImport ("ExFreePool", "use VideoPortFreePool");
    illegal_msgs.AddImport ("ExFreePoolWithTag", "use VideoPortFreePool");
    illegal_msgs.AddImport ("KeClearEvent", "use VideoPortClearEvent");
    illegal_msgs.AddImport ("KeDelayExecutionThread", "use VideoPortStallExecution");
    illegal_msgs.AddImport ("KeInitializeDpc", "use VideoPortQueueDpc");
    illegal_msgs.AddImport ("KeInsertQueueDpc", "use VideoPortQueueDpc");
    illegal_msgs.AddImport ("KeInitializeSpinLock", "use VideoPortXxxSpinLockXxx");
    illegal_msgs.AddImport ("KeSetEvent", "use VideoPortSetEvent");
    illegal_msgs.AddImport ("MmAllocateContiguousMemory", "use VideoPortAllocateContiguousMemory");
    illegal_msgs.AddImport ("READ_REGISTER_UCHAR", "use VideoPortReadRegisterUchar");
    illegal_msgs.AddImport ("wcslen", "link to libcntpr.lib instead");
    illegal_msgs.AddImport ("WRITE_REGISTER_USHORT", "use VideoPortWriteRegisterUshort");
    illegal_msgs.AddImport ("WRITE_REGISTER_UCHAR", "use VideoPortWriteRegisterUchar");
}

int __cdecl _tmain(int argc, TCHAR* argv[], TCHAR* envp[])
{
	int nRetCode = 0;

    // cerr << ::GetCommandLine() << endl;

	// initialize MFC and print and error on failure
	if (AfxWinInit(::GetModuleHandle(NULL), NULL, ::GetCommandLine(), 0))
	{
        CDrvchkApp theApp;
        theApp.InitInstance ();
	}

	return nRetCode;
}

/////////////////////////////////////////////////////////////////////////////
// CDrvchkApp construction

CDrvchkApp::CDrvchkApp() :
    m_logf(NULL),
	m_drv_name ("")
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CDrvchkApp object

/*------------------------------------------------------------------------

  vchk /drv driver.dll /log logname.log /allow videoptr.sys

  /allowed_modules module1.sys FnName1 FnName2 FnName3 /allowed_modules module2.dll FnName4

  ------------------------------------------------------------------------*/

void
CommandLine::ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast )
{

    if (m_parse_error)
        return;

    CString param (lpszParam);

    if (bFlag) {

        param.MakeUpper();

        if (m_last_flag.GetLength()) {
            m_parse_error = TRUE;
            m_error_msg = CString("Flag ") + m_last_flag + CString(" requires a parameter.");
        } else if ((param==CString("LOG")) || (param==CString("DRV")) || (param==CString("MON")) ||
                   (param==CString("ALLOW")) || (param==CString("allowed_modules"))) {
            m_last_flag = param;
            m_first_param = TRUE;
        } else {
            m_last_flag = "";
            m_parse_error = TRUE;
            m_error_msg = CString("Unrecognized flag: ") + param;
        }

    } else {

        if (m_last_flag==CString("ALLOW")) {
            allowed_modules.SetModule(param);
            /*
            sprintf (m_allowed, "%s", (LPCSTR)param);
            m_allowed += strlen (m_allowed);
            m_allowed[0] = 0;
            m_allowed[1] = 0;
            m_allowed++;
            */
        } else if (m_last_flag==CString("allowed_modules")) {

            if (m_first_param) {
                allowed_modules.SetModule(param);
                m_first_param = FALSE;
            } else {
                allowed_modules.AddImport(param);
            }

        } else if (m_last_flag==CString("DRV")) {
            m_drv_fname = param;
            m_last_flag="";
        } else if (m_last_flag==CString("LOG")) {
            m_log_fname = param;
            m_last_flag="";
        } else if (m_last_flag==CString("MON")) {
            if (param.GetLength()==1) {
                char c = ((LPCSTR)param)[0];
                m_monitor = c - '1';
            } else {
                m_monitor = -1;
                m_error_msg = "bad command line: /MON flag has wrong parameter";
                m_parse_error = TRUE;
            }
            m_last_flag="";
        } else {
            m_parse_error = TRUE;
            m_error_msg = CString("Wrong parameter: ") + param;
            m_last_flag="";
        }
    }

    if (bLast) {
        if (m_last_flag==CString("LOG") || m_last_flag==CString("DRV")) {
            m_parse_error = TRUE;
            m_error_msg = CString("Flag ") + m_last_flag + CString(" requires a parameter.");
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
// CDrvchkApp initialization

BOOL CDrvchkApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size

    m_os_ver_info.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx (&m_os_ver_info);
    if (m_os_ver_info.dwPlatformId != VER_PLATFORM_WIN32_NT) {  //  doesn't work on Win9x
        PrintOut ("warning: unsupported OS (Win9x), nothing done.\n");
        return FALSE;
    }
    if (m_os_ver_info.dwMajorVersion!=5) {                       //  doesn't work on NT version prior to Win2K
        PrintOut ("warning: unsupported OS (");
        PrintOut (m_os_ver_info.dwMajorVersion);
        PrintOut (".");
        PrintOut (m_os_ver_info.dwMinorVersion);
        PrintOut ("): nothing done.\n");
        return FALSE;
    }

    ParseCommandLine (m_cmd_line);
    BuildInAllowedAndIllegal();

    if (m_cmd_line.m_log_fname.GetLength()) {
        m_logf = fopen (m_cmd_line.m_log_fname, "a+");
    }

    if (m_cmd_line.m_parse_error) {

        PrintOut ("error: ");
        PrintOut ((LPCSTR)m_cmd_line.m_error_msg);
        PrintOut ("\n");

    } else {

        int device_num = m_cmd_line.m_monitor;

        if (m_cmd_line.m_drv_fname.GetLength()) {

            ChkDriver (m_cmd_line.m_drv_fname);

        } else {

            HDEVINFO hDevInfo;
            SP_DEVINFO_DATA did;
            // TCHAR szBuffer[256];
            DWORD index = 0; 
            HKEY hkTest;

            HKEY                hKey;
            ULONG               ulType = 0;
            DWORD               cbData = 0;
            DEVMODE             dmCurrent;
            TCHAR               szDeviceDescription[10000];
            TCHAR               szImagePath[256]; 
            TCHAR               szVarImagePath[256]; 
            TCHAR               szExpImagePath[256]; 

            CString dev_desc_CtrlSet;

            hKey = 0;
            
            //
            // Let's find all the video drivers that are installed in the system
            //
            DISPLAY_DEVICE DisplayDevice;
            DisplayDevice.cb = sizeof (DisplayDevice);

            // cerr << "looking for device #" << device_num << endl;

            for (DWORD d=0, index=0; EnumDisplayDevices(NULL, index, &DisplayDevice, 0); index++) {

                // cerr << "device #" << d << endl;

                if (DisplayDevice.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) {
                    // cerr << "DisplayDevice.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER\n";
                    continue;
                }

                if (device_num!=d++) {
                    // cerr << "device_num!=d\n";
                    continue;
                }

                CString service_path = GetServiceRegistryPath (DisplayDevice);

                if (!service_path.GetLength()) {
                    PrintOut ("error: cannot find video service\n");
                    continue;
                }

                ///// service known /////

                hKey = 0;
                cbData = sizeof szImagePath;
                if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE, _TEXT(service_path), 0, KEY_READ, &hKey) != ERROR_SUCCESS) ||
                    (RegQueryValueEx(hKey, _TEXT("ImagePath"), 0, &ulType, (LPBYTE)szImagePath, &cbData) != ERROR_SUCCESS) ||
                    (cbData == 0)) {
                        cbData = 0;
                        PrintOut ("error: cannot find video driver\n");
                }

                if (hKey)
                    RegCloseKey(hKey);

                if (cbData) {
                    sprintf (szVarImagePath, "%%WINDIR%%\\%s", szImagePath);
                    ExpandEnvironmentStrings (szVarImagePath, szExpImagePath, 256);
                    // cerr << "szExpImagePath = " << szExpImagePath << endl;
                    ChkDriver (szExpImagePath);
                }


            } // for each device

        } // look for system drivers

    }   // if no cmd line error

    if (m_logf)
        fclose (m_logf);
    m_logf = NULL;

	return TRUE;
}

#define REGISTRY_MACHINE_OFS _tcslen(_TEXT("\\registry\\machine\\"))

CString CDrvchkApp::GetServiceRegistryPath (DISPLAY_DEVICE& DisplayDevice)
{
    HKEY hKey = NULL;
    CString result_service_path = CString("");;
    /*
    // dump Display Device
    //
    FILE* f=fopen("hjhj.txt", "wb");
    BYTE* p = (BYTE*)&DisplayDevice;
    for (int i=0; i<sizeof(DISPLAY_DEVICE); i++)
        fwrite (p+i, 1, 1, f);
    fclose(f);
    */

    TCHAR device_key[256];     // Name of service (drivers)

    _tcscpy (device_key, DisplayDevice.DeviceKey+18); 

    // cut the "\Device0" or "\0000" tail...
    TCHAR* pch = _tcsrchr(device_key, _TEXT('\\'));
    if (pch != NULL)
	    *pch = 0;

    // cerr << "DisplayDevice.DeviceKey: " << device_key << endl;

    switch (m_os_ver_info.dwMinorVersion) {

    case 0:
        // cerr << "DisplayDevice.DeviceKey: " << device_key << endl;
        result_service_path = CString(device_key);
        break;

    case 1:
        {
            size_t len = _tcslen(device_key);
            sprintf (device_key+len, "\\Video");
            // cerr << "DisplayDevice.DeviceKey+REGISTRY_MACHINE_OFS: " << device_key << endl;

            BYTE service_name[256];
            ULONG ulReserved = 0;
            DWORD cbData = sizeof service_name;
            CString key_name = device_key;
            // cerr << key_name << endl;

            if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE, _TEXT(key_name), 0, KEY_READ, &hKey) != ERROR_SUCCESS) ||
                (RegQueryValueEx(hKey, _TEXT("Service"), 0, &ulReserved, (LPBYTE)service_name, &cbData) != ERROR_SUCCESS) ||
                (cbData == 0)) {
                    break;
                }

            // cerr << "Service reg name: " << service_name << endl;
            result_service_path = "SYSTEM\\CurrentControlSet\\Services\\";
            result_service_path += CString(service_name);
            // cerr << "Service reg path: " << (LPCSTR)result_service_path << endl;
        }
        break;

    default:
        PrintOut ("warning: unknown system version 5.");
        PrintOut (m_os_ver_info.dwMinorVersion);
        PrintOut ("\n");
    }

    if (hKey)
        RegCloseKey(hKey);
    return result_service_path;
}

void CDrvchkApp::ChkDriver (CString drv_name)
{
    m_drv_name = drv_name;
    cerr << (LPCSTR)m_drv_name << endl;
    InitIllegalImportsSearch (m_drv_name, "INIT");
    if (CheckDriverAndPrintResults ()) {
        PrintOut ("success: no illegal imports in ");
        PrintOut (m_drv_name);
        PrintOut ("\n");
    }
}

BOOL CDrvchkApp::CheckDriverAndPrintResults ()
{

    Names Modules = CheckSectionsForImports ();

    if (!Modules.Ptr) {
        PrintOut ("error: cannot retrieve import information from ");
        PrintOut (m_drv_name);
        PrintOut ("\n");
        return FALSE;
    }

    int errors_found = 0;

    for (int i=0;
         i<Modules.Num;
         Modules.Ptr = GetNextName(Modules.Ptr), i++) {

        Names Imports = GetImportsList (Modules.Ptr);

        // cerr << "Checking " << (LPCSTR)Modules.Ptr << endl;

        CString module_name (Modules.Ptr);

        if (allowed_modules.IsModule(module_name)) {
            // cerr << "ALLOWED " << (LPCSTR)module_name << endl;
            continue;
        }

        BOOL KnownIllegals = known_illegal.IsModule(module_name);
        if (KnownIllegals) {
            // cerr << "KNOWN ILLEGALS FROM " << (LPCSTR)module_name << endl;
        }

        LPSTR ImportsPtr = Imports.Ptr;

        // cerr << "Imports.Num = " << Imports.Num << endl;
        
        for (int j=0;
             j<Imports.Num;
             Imports.Ptr = GetNextName (Imports.Ptr), j++) {

                // cerr << "j=" << j << "\n";
                CString msg = "";

                CString ImportFnName =  CString(Modules.Ptr) +
                                        CString("!") +
                                        CString(Imports.Ptr);

                if (KnownIllegals && known_illegal.Lookup(Imports.Ptr, msg))
                    PrintOut ("warning: ");
                else {
                    errors_found ++;
                    illegal_msgs.Lookup(Imports.Ptr, msg);
                    PrintOut ("error: ");
                }

                PrintOut (m_drv_name);
                PrintOut (": ");
                PrintOut (ImportFnName);
                if (msg.GetLength()) {
                    PrintOut (" -- ");
                    PrintOut (msg);
                }
                PrintOut ("\n");
        }
        
        
        if (ImportsPtr)
            HeapFree (GetProcessHeap(), 0, ImportsPtr);

    }

    /*
    char buf[1024];
    sprintf (buf, "%d modules; %d imports", Modules.Num, errors_found);

    if (m_listf) {
        fprintf (m_listf, "\n%s\n\n", buf);
    }
    */

    return (errors_found==0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\vchk\pefile.c ===
#include "pefile.h"


HANDLE	  hDll;

/*
BOOL  WINAPI DLLEntry (
    HANDLE    hModule,
    DWORD     dwFunction,
    LPVOID    lpNot)
{
    hDll = hModule;

    return TRUE;
}
*/



/* copy dos header information to structure */
BOOL  WINAPI GetDosHeader (
    LPVOID		 lpFile,
    PIMAGE_DOS_HEADER	 pHeader)
{
    /* dos header rpresents first structure of bytes in file */
    if (*(USHORT *)lpFile == IMAGE_DOS_SIGNATURE)
	CopyMemory ((LPVOID)pHeader, lpFile, sizeof (IMAGE_DOS_HEADER));
    else
	return FALSE;

    return TRUE;
}




/* return file signature */
DWORD  WINAPI ImageFileType (
    LPVOID    lpFile)
{
    /* dos file signature comes first */
    if (*(USHORT *)lpFile == IMAGE_DOS_SIGNATURE)
	{
	/* determine location of PE File header from dos header */
	if (LOWORD (*(DWORD *)NTSIGNATURE (lpFile)) == IMAGE_OS2_SIGNATURE ||
	    LOWORD (*(DWORD *)NTSIGNATURE (lpFile)) == IMAGE_OS2_SIGNATURE_LE)
	    return (DWORD)LOWORD(*(DWORD *)NTSIGNATURE (lpFile));

	else if (*(DWORD *)NTSIGNATURE (lpFile) == IMAGE_NT_SIGNATURE)
	    return IMAGE_NT_SIGNATURE;

	else
	    return IMAGE_DOS_SIGNATURE;
	}

    else
	/* unknown file type */
	return 0;
}




/* copy file header information to structure */
BOOL  WINAPI GetPEFileHeader (
    LPVOID		  lpFile,
    PIMAGE_FILE_HEADER	  pHeader)
{
    /* file header follows dos header */
    if (ImageFileType (lpFile) == IMAGE_NT_SIGNATURE)
	CopyMemory ((LPVOID)pHeader, PEFHDROFFSET (lpFile), sizeof (IMAGE_FILE_HEADER));

    else
	return FALSE;

    return TRUE;
}





/* copy optional header info to structure */
BOOL WINAPI GetPEOptionalHeader (
    LPVOID		      lpFile,
    PIMAGE_OPTIONAL_HEADER    pHeader)
{
    /* optional header follows file header and dos header */
    if (ImageFileType (lpFile) == IMAGE_NT_SIGNATURE)
	CopyMemory ((LPVOID)pHeader, OPTHDROFFSET (lpFile), sizeof (IMAGE_OPTIONAL_HEADER));

    else
	return FALSE;

    return TRUE;
}




/* function returns the entry point for an exe module lpFile must
   be a memory mapped file pointer to the beginning of the image file */
LONG_PTR	WINAPI GetModuleEntryPoint (
    LPVOID    lpFile)
{
    PIMAGE_OPTIONAL_HEADER   poh = (PIMAGE_OPTIONAL_HEADER)OPTHDROFFSET (lpFile);

    if (poh != NULL)
	return (LONG_PTR)(poh->AddressOfEntryPoint);
    else
	return 0L;
}




/* return the total number of sections in the module */
int   WINAPI NumOfSections (
    LPVOID    lpFile)
{
    /* number os sections is indicated in file header */
    return ((int)((PIMAGE_FILE_HEADER)PEFHDROFFSET (lpFile))->NumberOfSections);
}




/* retrieve entry point */
LPVOID	WINAPI GetImageBase (
    LPVOID    lpFile)
{
    PIMAGE_OPTIONAL_HEADER   poh = (PIMAGE_OPTIONAL_HEADER)OPTHDROFFSET (lpFile);

    if (poh != NULL)
	return (LPVOID)(poh->ImageBase);
    else
	return NULL;
}




/* return offset to specified IMAGE_DIRECTORY entry */
LPVOID	WINAPI ImageDirectoryOffset (
	LPVOID	  lpFile,
	DWORD	  dwIMAGE_DIRECTORY)
{
    PIMAGE_OPTIONAL_HEADER   poh = (PIMAGE_OPTIONAL_HEADER)OPTHDROFFSET (lpFile);
    PIMAGE_SECTION_HEADER    psh = (PIMAGE_SECTION_HEADER)SECHDROFFSET (lpFile);
    int 		     nSections = NumOfSections (lpFile);
    int 		     i = 0;
    LONG_PTR	     VAImageDir;

    /* must be 0 thru (NumberOfRvaAndSizes-1) */
    if (dwIMAGE_DIRECTORY >= poh->NumberOfRvaAndSizes)
	return NULL;

    /* locate specific image directory's relative virtual address */
    VAImageDir = (LONG_PTR)poh->DataDirectory[dwIMAGE_DIRECTORY].VirtualAddress;

    /* locate section containing image directory */
    while (i++<nSections)
	{
	if (psh->VirtualAddress <= (DWORD)VAImageDir &&
	    psh->VirtualAddress + psh->SizeOfRawData > (DWORD)VAImageDir)
	    break;
	psh++;
	}

    if (i > nSections)
	return NULL;

    /* return image import directory offset */
    return (LPVOID)(((LONG_PTR)lpFile + (LONG_PTR)VAImageDir - psh->VirtualAddress) +
				   (LONG_PTR)psh->PointerToRawData);
}




/* function retrieve names of all the sections in the file */
int WINAPI GetSectionNames (
    LPVOID    lpFile,
    HANDLE    hHeap,
    char      **pszSections)
{
    int 		     nSections = NumOfSections (lpFile);
    int 		     i, nCnt = 0;
    PIMAGE_SECTION_HEADER    psh;
    char		     *ps;


    if (ImageFileType (lpFile) != IMAGE_NT_SIGNATURE ||
	(psh = (PIMAGE_SECTION_HEADER)SECHDROFFSET (lpFile)) == NULL)
	return 0;

    /* count the number of chars used in the section names */
    for (i=0; i<nSections; i++)
	nCnt += strlen (psh[i].Name) + 1;

    /* allocate space for all section names from heap */
    ps = *pszSections = (char *)HeapAlloc (hHeap, HEAP_ZERO_MEMORY, nCnt);


    for (i=0; i<nSections; i++)
	{
	strcpy (ps, psh[i].Name);
	ps += strlen (psh[i].Name) + 1;
	}

    return nCnt;
}




/* function gets the function header for a section identified by name */
BOOL	WINAPI GetSectionHdrByName (
    LPVOID		     lpFile,
    IMAGE_SECTION_HEADER     *sh,
    char		     *szSection)
{
    PIMAGE_SECTION_HEADER    psh;
    int 		     nSections = NumOfSections (lpFile);
    int 		     i;


    if ((psh = (PIMAGE_SECTION_HEADER)SECHDROFFSET (lpFile)) != NULL)
	{
	/* find the section by name */
	for (i=0; i<nSections; i++)
	    {
	    if (!strcmp (psh->Name, szSection))
		{
		/* copy data to header */
		CopyMemory ((LPVOID)sh, (LPVOID)psh, sizeof (IMAGE_SECTION_HEADER));
		return TRUE;
		}
	    else
		psh++;
	    }
	}

    return FALSE;
}




/* get import modules names separated by null terminators, return module count */
int  WINAPI GetImportModuleNames (
    LPVOID    lpFile,
    // HANDLE    hHeap,
    char*     SectionName,
    char      **pszModules)
{
    PIMAGE_IMPORT_MODULE_DIRECTORY  pid = (PIMAGE_IMPORT_MODULE_DIRECTORY)
	ImageDirectoryOffset (lpFile, IMAGE_DIRECTORY_ENTRY_IMPORT);
    IMAGE_SECTION_HEADER     idsh;
    BYTE		     *pData = (BYTE *)pid;
    int 		     nCnt = 0, nSize = 0, i;
    char		     *pModule[1024];  /* hardcoded maximum number of modules?? */
    char		     *psz;

    /* locate section header for ".idata" section */
    if (!GetSectionHdrByName (lpFile, &idsh, SectionName /*".idata" "INIT"*/))
	return 0;

    /* extract all import modules */
    while (pid->dwRVAModuleName)
	{
	/* allocate temporary buffer for absolute string offsets */
	pModule[nCnt] = (char *)(pData + (pid->dwRVAModuleName-idsh.VirtualAddress));
	nSize += strlen (pModule[nCnt]) + 1;

	/* increment to the next import directory entry */
	pid++;
	nCnt++;
	}

    /* copy all strings to one chunk of heap memory */
    *pszModules = HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, nSize);
    psz = *pszModules;
    for (i=0; i<nCnt; i++)
	{
	strcpy (psz, pModule[i]);
	psz += strlen (psz) + 1;
	}

    return nCnt;
}




/* get import module function names separated by null terminators, return function count */
int  WINAPI GetImportFunctionNamesByModule (
    LPVOID    lpFile,
    // HANDLE    hHeap,
    char*     SectionName,
    char      *pszModule,
    char      **pszFunctions)
{
    PIMAGE_IMPORT_MODULE_DIRECTORY  pid = (PIMAGE_IMPORT_MODULE_DIRECTORY)
	ImageDirectoryOffset (lpFile, IMAGE_DIRECTORY_ENTRY_IMPORT);
    IMAGE_SECTION_HEADER     idsh;
    LONG_PTR	     dwBase;
    int 		     nCnt = 0, nSize = 0;
    DWORD		     dwFunction;
    char		     *psz;

    /* locate section header for ".idata" section */
    if (!GetSectionHdrByName (lpFile, &idsh, SectionName/*".idata" "INIT"*/))
	return 0;

    dwBase = ((LONG_PTR)pid - idsh.VirtualAddress);

    /* find module's pid */
    while (pid->dwRVAModuleName &&
	   strcmp (pszModule, (char *)(pid->dwRVAModuleName+dwBase)))
	pid++;

    /* exit if the module is not found */
    if (!pid->dwRVAModuleName)
	return 0;

    /* count number of function names and length of strings */
    dwFunction = pid->dwRVAFunctionNameList;
    while (dwFunction			   &&
	   *(DWORD *)(dwFunction + dwBase) &&
	   *(char *)((*(DWORD *)(dwFunction + dwBase)) + dwBase+2))
	{
	nSize += strlen ((char *)((*(DWORD *)(dwFunction + dwBase)) + dwBase+2)) + 1;
	dwFunction += 4;
	nCnt++;
	}

    /* allocate memory off heap for function names */
    *pszFunctions = HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, nSize);
    psz = *pszFunctions;

    /* copy function names to mempry pointer */
    dwFunction = pid->dwRVAFunctionNameList;
    while (dwFunction			   &&
	   *(DWORD *)(dwFunction + dwBase) &&
	   *((char *)((*(DWORD *)(dwFunction + dwBase)) + dwBase+2)))
	{
	strcpy (psz, (char *)((*(DWORD *)(dwFunction + dwBase)) + dwBase+2));
	psz += strlen ((char *)((*(DWORD *)(dwFunction + dwBase)) + dwBase+2)) + 1;
	dwFunction += 4;
	}

    return nCnt;
}




/* get exported function names separated by null terminators, return count of functions */
int  WINAPI GetExportFunctionNames (
    LPVOID    lpFile,
    HANDLE    hHeap,
    char      **pszFunctions)
{
    IMAGE_SECTION_HEADER       sh;
    PIMAGE_EXPORT_DIRECTORY    ped;
    char		       *pNames, *pCnt;
    int 		       i, nCnt;

    /* get section header and pointer to data directory for .edata section */
    if ((ped = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryOffset
		    (lpFile, IMAGE_DIRECTORY_ENTRY_EXPORT)) == NULL)
	return 0;
    GetSectionHdrByName (lpFile, &sh, ".edata");

    /* determine the offset of the export function names */
    pNames = (char *)(*(int *)((int)ped->AddressOfNames -
			       (int)sh.VirtualAddress	+
			       (int)sh.PointerToRawData +
			       (LONG_PTR)lpFile)    -
		      (int)sh.VirtualAddress   +
		      (int)sh.PointerToRawData +
		      (LONG_PTR)lpFile);

    /* figure out how much memory to allocate for all strings */
    pCnt = pNames;
    for (i=0; i<(int)ped->NumberOfNames; i++)
	while (*pCnt++);
    nCnt = (int)(pCnt - pNames);

    /* allocate memory off heap for function names */
    *pszFunctions = HeapAlloc (hHeap, HEAP_ZERO_MEMORY, nCnt);

    /* copy all string to buffer */
    CopyMemory ((LPVOID)*pszFunctions, (LPVOID)pNames, nCnt);

    return nCnt;
}




/* return the number of exported functions in the module */
int	WINAPI GetNumberOfExportedFunctions (
    LPVOID    lpFile)
{
    PIMAGE_EXPORT_DIRECTORY    ped;

    /* get section header and pointer to data directory for .edata section */
    if ((ped = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryOffset
		    (lpFile, IMAGE_DIRECTORY_ENTRY_EXPORT)) == NULL)
	return 0;
    else
	return (int)ped->NumberOfNames;
}




/* return a pointer to the list of function entry points */
LPVOID	 WINAPI GetExportFunctionEntryPoints (
    LPVOID    lpFile)
{
    IMAGE_SECTION_HEADER       sh;
    PIMAGE_EXPORT_DIRECTORY    ped;

    /* get section header and pointer to data directory for .edata section */
    if ((ped = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryOffset
		    (lpFile, IMAGE_DIRECTORY_ENTRY_EXPORT)) == NULL)
	return NULL;
    GetSectionHdrByName (lpFile, &sh, ".edata");

    /* determine the offset of the export function entry points */
    return (LPVOID) ((int)ped->AddressOfFunctions -
		     (int)sh.VirtualAddress   +
		     (int)sh.PointerToRawData +
		     (LONG_PTR)lpFile);
}




/* return a pointer to the list of function ordinals */
LPVOID	 WINAPI GetExportFunctionOrdinals (
    LPVOID    lpFile)
{
    IMAGE_SECTION_HEADER       sh;
    PIMAGE_EXPORT_DIRECTORY    ped;

    /* get section header and pointer to data directory for .edata section */
    if ((ped = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryOffset
		    (lpFile, IMAGE_DIRECTORY_ENTRY_EXPORT)) == NULL)
	return NULL;
    GetSectionHdrByName (lpFile, &sh, ".edata");

    /* determine the offset of the export function entry points */
    return (LPVOID) ((int)ped->AddressOfNameOrdinals -
		     (int)sh.VirtualAddress   +
		     (int)sh.PointerToRawData +
		     (LONG_PTR)lpFile);
}




/* determine the total number of resources in the section */
int	WINAPI GetNumberOfResources (
    LPVOID    lpFile)
{
    PIMAGE_RESOURCE_DIRECTORY	       prdRoot, prdType;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY    prde;
    int 			       nCnt=0, i;


    /* get root directory of resource tree */
    if ((prdRoot = (PIMAGE_RESOURCE_DIRECTORY)ImageDirectoryOffset
		    (lpFile, IMAGE_DIRECTORY_ENTRY_RESOURCE)) == NULL)
	return 0;

    /* set pointer to first resource type entry */
    prde = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((LONG_PTR)prdRoot + sizeof (IMAGE_RESOURCE_DIRECTORY));

    /* loop through all resource directory entry types */
    for (i=0; i<prdRoot->NumberOfIdEntries; i++)
	{
	/* locate directory or each resource type */
	prdType = (PIMAGE_RESOURCE_DIRECTORY)((LONG_PTR)prdRoot + (LONG_PTR)prde->OffsetToData);

	/* mask off most significant bit of the data offset */
	prdType = (PIMAGE_RESOURCE_DIRECTORY)((LONG_PTR)prdType ^ 0x80000000);

	/* increment count of name'd and ID'd resources in directory */
	nCnt += prdType->NumberOfNamedEntries + prdType->NumberOfIdEntries;

	/* increment to next entry */
	prde++;
	}

    return nCnt;
}




/* name each type of resource in the section */
int	WINAPI GetListOfResourceTypes (
    LPVOID    lpFile,
    HANDLE    hHeap,
    char      **pszResTypes)
{
    PIMAGE_RESOURCE_DIRECTORY	       prdRoot;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY    prde;
    char			       *pMem;
    int 			       nCnt, i;


    /* get root directory of resource tree */
    if ((prdRoot = (PIMAGE_RESOURCE_DIRECTORY)ImageDirectoryOffset
		    (lpFile, IMAGE_DIRECTORY_ENTRY_RESOURCE)) == NULL)
	return 0;

    /* allocate enuff space from heap to cover all types */
    nCnt = prdRoot->NumberOfIdEntries * (MAXRESOURCENAME + 1);
    *pszResTypes = (char *)HeapAlloc (hHeap,
				      HEAP_ZERO_MEMORY,
				      nCnt);
    if ((pMem = *pszResTypes) == NULL)
	return 0;

    /* set pointer to first resource type entry */
    prde = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((LONG_PTR)prdRoot + sizeof (IMAGE_RESOURCE_DIRECTORY));

    /* loop through all resource directory entry types */
    for (i=0; i<prdRoot->NumberOfIdEntries; i++)
	{
	if (LoadString (hDll, prde->Name, pMem, MAXRESOURCENAME))
	    pMem += strlen (pMem) + 1;

	prde++;
	}

    return nCnt;
}




/* function indicates whether debug  info has been stripped from file */
BOOL	WINAPI IsDebugInfoStripped (
    LPVOID    lpFile)
{
    PIMAGE_FILE_HEADER	  pfh;

    pfh = (PIMAGE_FILE_HEADER)PEFHDROFFSET (lpFile);

    return (pfh->Characteristics & IMAGE_FILE_DEBUG_STRIPPED);
}




/* retrieve the module name from the debug misc. structure */
int    WINAPI RetrieveModuleName (
    LPVOID    lpFile,
    HANDLE    hHeap,
    char      **pszModule)
{

    PIMAGE_DEBUG_DIRECTORY    pdd;
    PIMAGE_DEBUG_MISC	      pdm = NULL;
    int 		      nCnt;

    if (!(pdd = (PIMAGE_DEBUG_DIRECTORY)ImageDirectoryOffset (lpFile, IMAGE_DIRECTORY_ENTRY_DEBUG)))
	return 0;

    while (pdd->SizeOfData)
	{
	if (pdd->Type == IMAGE_DEBUG_TYPE_MISC)
	    {
	    pdm = (PIMAGE_DEBUG_MISC)((DWORD)pdd->PointerToRawData + (LONG_PTR)lpFile);

	    *pszModule = (char *)HeapAlloc (hHeap,
					    HEAP_ZERO_MEMORY,
					    (nCnt = (lstrlen (pdm->Data)*(pdm->Unicode?2:1)))+1);
	    CopyMemory (*pszModule, pdm->Data, nCnt);

	    break;
	    }

	pdd ++;
	}

    if (pdm != NULL)
	return nCnt;
    else
	return 0;
}





/* determine if this is a valid debug file */
BOOL	WINAPI IsDebugFile (
    LPVOID    lpFile)
{
    PIMAGE_SEPARATE_DEBUG_HEADER    psdh;

    psdh = (PIMAGE_SEPARATE_DEBUG_HEADER)lpFile;

    return (psdh->Signature == IMAGE_SEPARATE_DEBUG_SIGNATURE);
}




/* copy separate debug header structure from debug file */
BOOL	WINAPI GetSeparateDebugHeader (
    LPVOID			    lpFile,
    PIMAGE_SEPARATE_DEBUG_HEADER    psdh)
{
    PIMAGE_SEPARATE_DEBUG_HEADER    pdh;

    pdh = (PIMAGE_SEPARATE_DEBUG_HEADER)lpFile;

    if (pdh->Signature == IMAGE_SEPARATE_DEBUG_SIGNATURE)
	{
	CopyMemory ((LPVOID)psdh, (LPVOID)pdh, sizeof (IMAGE_SEPARATE_DEBUG_HEADER));
	return TRUE;
	}

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\vchk\pefile.h ===
#include <windows.h>

#define IDS_ERRBADFILENAME	1000
#define IDR_CURSOR		1
#define IDR_BITMAP		2
#define IDR_ICON		3
#define IDR_MENU		4
#define IDR_DIALOG		5
#define IDR_STRING		6
#define IDR_FONTDIR		7
#define IDR_FONT		8
#define IDR_ACCELERATOR 	9
#define IDR_RCDATA		10
#define IDR_MESSAGETABLE	11

#define SIZE_OF_NT_SIGNATURE	sizeof (DWORD)
#define MAXRESOURCENAME 	13

/* global macros to define header offsets into file */
/* offset to PE file signature				       */
#define NTSIGNATURE(a) ((LPVOID)((BYTE *)a		     +	\
			((PIMAGE_DOS_HEADER)a)->e_lfanew))

/* DOS header identifies the NT PEFile signature dword
   the PEFILE header exists just after that dword	       */
#define PEFHDROFFSET(a) ((LPVOID)((BYTE *)a		     +	\
			 ((PIMAGE_DOS_HEADER)a)->e_lfanew    +	\
			 SIZE_OF_NT_SIGNATURE))

/* PE optional header is immediately after PEFile header       */
#define OPTHDROFFSET(a) ((LPVOID)((BYTE *)a		     +	\
			 ((PIMAGE_DOS_HEADER)a)->e_lfanew    +	\
			 SIZE_OF_NT_SIGNATURE		     +	\
			 sizeof (IMAGE_FILE_HEADER)))

/* section headers are immediately after PE optional header    */
#define SECHDROFFSET(a) ((LPVOID)((BYTE *)a		     +	\
			 ((PIMAGE_DOS_HEADER)a)->e_lfanew    +	\
			 SIZE_OF_NT_SIGNATURE		     +	\
			 sizeof (IMAGE_FILE_HEADER)	     +	\
			 sizeof (IMAGE_OPTIONAL_HEADER)))

#ifdef __cplusplus

extern "C" {

#endif


typedef struct tagImportDirectory
    {
    DWORD    dwRVAFunctionNameList;
    DWORD    dwUseless1;
    DWORD    dwUseless2;
    DWORD    dwRVAModuleName;
    DWORD    dwRVAFunctionAddressList;
    }IMAGE_IMPORT_MODULE_DIRECTORY, * PIMAGE_IMPORT_MODULE_DIRECTORY;


/* global prototypes for functions in pefile.c */
/* PE file header info */
BOOL	WINAPI GetDosHeader (LPVOID, PIMAGE_DOS_HEADER);
DWORD	WINAPI ImageFileType (LPVOID);
BOOL	WINAPI GetPEFileHeader (LPVOID, PIMAGE_FILE_HEADER);

/* PE optional header info */
BOOL	WINAPI GetPEOptionalHeader (LPVOID, PIMAGE_OPTIONAL_HEADER);
LONG_PTR	WINAPI GetModuleEntryPoint (LPVOID);
int	WINAPI NumOfSections (LPVOID);
LPVOID	WINAPI GetImageBase (LPVOID);
LPVOID	WINAPI ImageDirectoryOffset (LPVOID, DWORD);

/* PE section header info */
int	WINAPI GetSectionNames (LPVOID, HANDLE, char **);
BOOL	WINAPI GetSectionHdrByName (LPVOID, PIMAGE_SECTION_HEADER, char *);

/* import section info */
int	WINAPI GetImportModuleNames (LPVOID, char*, char  **);
int	WINAPI GetImportFunctionNamesByModule (LPVOID, char*, char *, char  **);

/* export section info */
int	WINAPI GetExportFunctionNames (LPVOID, HANDLE, char **);
int	WINAPI GetNumberOfExportedFunctions (LPVOID);
LPVOID	WINAPI GetExportFunctionEntryPoints (LPVOID);
LPVOID	WINAPI GetExportFunctionOrdinals (LPVOID);

/* resource section info */
int	WINAPI GetNumberOfResources (LPVOID);
int	WINAPI GetListOfResourceTypes (LPVOID, HANDLE, char **);

/* debug section info */
BOOL	WINAPI IsDebugInfoStripped (LPVOID);
int	WINAPI RetrieveModuleName (LPVOID, HANDLE, char **);
BOOL	WINAPI IsDebugFile (LPVOID);
BOOL	WINAPI GetSeparateDebugHeader (LPVOID, PIMAGE_SEPARATE_DEBUG_HEADER);

#ifdef __cplusplus

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\test\vchk\vchk.h ===
#if !defined(AFX_VCHK_H__759990C4_C5B1_44C5_8CAE_C55BAE0E2D81__INCLUDED_)
#define AFX_VCHK_H__759990C4_C5B1_44C5_8CAE_C55BAE0E2D81__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// #include "driverlist.h"

class CommandLine : public CCommandLineInfo {
public:
    CommandLine() :
      m_last_flag (""),
      m_log_fname (""),
      m_drv_fname (""),
      m_parse_error (FALSE),
      m_error_msg (""),
      m_allowed(m_allowed_buf),
      m_append (TRUE),
      m_first_param(FALSE),
      CCommandLineInfo(),
      m_monitor(0)
      {
          m_allowed[0] = 0;
          m_allowed[1] = 0;
      }

    virtual void ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast );

    BOOL        m_append;

    char        m_allowed_buf[2048];

    BOOL        m_parse_error;
    CString     m_error_msg;
    CString     m_log_fname;
    CString     m_drv_fname;
    int         m_monitor;

private:
    char*       m_allowed;
    CString     m_last_flag;
    BOOL        m_first_param;
};

/////////////////////////////////////////////////////////////////////////////
// CDrvchkApp:
// See drvchk.cpp for the implementation of this class
//

class CDrvchkApp : public CWinApp
{
public:
	CDrvchkApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDrvchkApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

protected:
    void ChkDriver (CString drv_name);
	BOOL CheckDriverAndPrintResults (void);
    void PrintOut (LPCSTR str);
    void PrintOut (unsigned num);
    CString GetServiceRegistryPath (DISPLAY_DEVICE& DisplayDevice);

private:
    FILE*       m_logf;
    CommandLine m_cmd_line;
    OSVERSIONINFO m_os_ver_info;
	CString     m_drv_name;
    // CDriverList m_drv_list;
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(AFX_VCHK_H__759990C4_C5B1_44C5_8CAE_C55BAE0E2D81__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\tseng\mini\et400dat.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    et400dat.c

Abstract:

    This module contains all the global data used by the et4000 driver.

Environment:

    Kernel mode

Revision History:


--*/

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "et4000.h"

#include "cmdcnst.h"

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE")
#endif

//
// This structure describes to which ports access is required.
//

VIDEO_ACCESS_RANGE VgaAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,                // 64-bit linear base address
                                                 // of range
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1, // # of ports
    1,                                           // range is in I/O space
    1,                                           // range should be visible
    0                                            // range should be shareable
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    0
},
{
    CRTCB_IO_PORT_BASE, 0x00000000,       // 64-bit linear base address
    CRTCB_IO_PORT_LEN,                    // # of ports
    1,                                    // range is in I/O space
    1,                                    // range should be visible
    0                                     // range should be shareable
},
{
    0x000A0000, 0x00000000,
    0x00020000,
    0,
    1,
    0
},

//
// Linear frame buffer access range (uninitialized)
//

{
    0x00000000, 0x00000000,
    0x00000000,
    0,
    1,
    0
}
};

//
// PUBLIC ACCESS RANGE OFFSETS
//
// This table contains the offsets from the start of the frame
// buffer for each of the MMU ranges.
//

RANGE_OFFSETS RangeOffsets[2][2] =
{
    {
        {BANKED_MMU_BUFFER_MEMORY_ADDR,
         BANKED_MMU_BUFFER_MEMORY_LEN},
        {BANKED_MMU_MEMORY_MAPPED_REGS_ADDR,
         BANKED_MMU_MEMORY_MAPPED_REGS_LEN}
    },
    {
        {MMU_BUFFER_MEMORY_ADDR,
         MMU_BUFFER_MEMORY_LEN},
        {MMU_MEMORY_MAPPED_REGS_ADDR,
         MMU_MEMORY_MAPPED_REGS_LEN}
    }
};


//
// Validator Port list.
// This structure describes all the ports that must be hooked out of the V86
// emulator when a DOS app goes to full-screen mode.
// The structure determines to which routine the data read or written to a
// specific port should be sent.
//

EMULATOR_ACCESS_ENTRY VgaEmulatorAccessEntries[] = {

    //
    // Traps for byte OUTs.
    //

    {
        0x000003b0,                   // range start I/O address
        0xC,                         // range length
        Uchar,                        // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                        // does not support string accesses
        (PVOID)VgaValidatorUcharEntry // routine to which to trap
    },

    {
        0x000003c0,                   // range start I/O address
        0x20,                         // range length
        Uchar,                        // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                        // does not support string accesses
        (PVOID)VgaValidatorUcharEntry // routine to which to trap
    },

    //
    // Traps for word OUTs.
    //

    {
        0x000003b0,
        0x06,
        Ushort,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUshortEntry
    },

    {
        0x000003c0,
        0x10,
        Ushort,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUshortEntry
    },

    //
    // Traps for dword OUTs.
    //

    {
        0x000003b0,
        0x03,
        Ulong,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUlongEntry
    },

    {
        0x000003c0,
        0x08,
        Ulong,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUlongEntry
    }

};


//
// Used to trap only the sequncer and the misc output registers
//

VIDEO_ACCESS_RANGE MinimalVgaValidatorAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1,
    1,
    1,        // <- enable range IOPM so that it is not trapped.
    0
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    0
},
{
    VGA_BASE_IO_PORT + MISC_OUTPUT_REG_WRITE_PORT, 0x00000000,
    0x00000001,
    1,
    0,
    0
},
{
    VGA_BASE_IO_PORT + SEQ_ADDRESS_PORT, 0x00000000,
    0x00000002,
    1,
    0,
    0
}
};

//
// Used to trap all registers
//

VIDEO_ACCESS_RANGE FullVgaValidatorAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1,
    1,
    0,        // <- disable range in the IOPM so that it is trapped.
    0
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    0,
    0
}
};

USHORT ET4K_1K_WIDE[] = {
    OW,                             // stretch scans to 1k
    CRTC_ADDRESS_PORT_COLOR,
    0x8013,

    EOD
};

// This is the only value that avoids broken rasters (at least they're not
// broken within the visible portion of the bitmap)
USHORT ET4K_1928_WIDE[] = {
    OW,                             // stretch scans to 1928
    CRTC_ADDRESS_PORT_COLOR,
    0xF113,

    EOD
};

USHORT MODESET_MODEX_320_200[] = {
    OW,
    SEQ_ADDRESS_PORT,
    0x0604,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    2,
    0xe317,
    0x0014,

    EOD
};

USHORT MODESET_MODEX_320_240[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0604,
    0x0100,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,
    SEQ_ADDRESS_PORT,
    0x0300,

    OB,
    CRTC_ADDRESS_PORT_COLOR,
    0x11,

    METAOUT+MASKOUT,
    CRTC_DATA_PORT_COLOR,
    0x7f, 0x00,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    10,
    0x0d06,
    0x3e07,
    0x4109,
    0xea10,
    0xac11,
    0xdf12,
    0x0014,
    0xe715,
    0x0616,
    0xe317,

    OW,
    SEQ_ADDRESS_PORT,
    0x0f02,

    EOD
};

USHORT MODESET_MODEX_320_400[] = {
    OW,
    SEQ_ADDRESS_PORT,
    0x0604,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    3,
    0xe317,
    0x0014,
    0x4009,

    EOD
};

USHORT MODESET_MODEX_320_480[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0604,
    0x0100,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,
    SEQ_ADDRESS_PORT,
    0x0300,

    OB,
    CRTC_ADDRESS_PORT_COLOR,
    0x11,

    METAOUT+MASKOUT,
    CRTC_DATA_PORT_COLOR,
    0x7f, 0x00,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    10,
    0x0d06,
    0x3e07,
    0x4109,
    0xea10,
    0xac11,
    0xdf12,
    0x0014,
    0xe715,
    0x0616,
    0xe317,

    OW,
    SEQ_ADDRESS_PORT,
    0x0f02,

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x4009,

    EOD
};

//
// Memory map table -
//
// These memory maps are used to save and restore the physical video buffer.
//

MEMORYMAPS MemoryMaps[] = {

//               length      start
//               ------      -----
    {           0x08000,    0xB0000},   // all mono text modes (7)
    {           0x08000,    0xB8000},   // all color text modes (0, 1, 2, 3,
    {           0x10000,    0xA0000},   // all VGA graphics modes
};

//
// Video mode table - contains information and commands for initializing each
// mode. These entries must correspond with those in VIDEO_MODE_VGA. The first
// entry is commented; the rest follow the same format, but are not so
// heavily commented.
//

VIDEOMODE ModesVGA[] = {

//
// Standard VGA modes.
//

//
// Mode index 0
// Color text mode 3, 720x400, 9x16 char cell (VGA).
//

{
  VIDEO_MODE_COLOR,  // flags that this mode is a color mode, but not graphics
  4,                 // four planes
  1,                 // one bit of colour per plane
  80, 25,            // 80x25 text resolution
  720, 400,          // 720x400 pixels on screen
  160, 0x10000,      // 160 bytes per scan line, 64K of CPU-addressable bitmap
  0, 0,              // only support one frequency, non-interlaced
  NoBanking,         // no banking supported or needed in this mode
  MemMap_CGA,        // the memory mapping is the standard CGA memory mapping
                     //  of 32K at B8000
  FALSE,             // Mode is not available by default
  0x3,               // int 10 modesset value
  NULL,              // scan line stretching option
},

//
// Color text mode 3, 640x350, 8x14 char cell (EGA).
//

{ VIDEO_MODE_COLOR, 4, 1, 80, 25,
  640, 350, 160, 0x10000, 0, 0, NoBanking, MemMap_CGA,
  FALSE,
  0x3,
  NULL,
},

//
// Standard VGA Color graphics mode 0x12, 640x480 16 colors.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 80, 30,
  640, 480, 80, 0x10000, 60, 0, NoBanking, MemMap_VGA,
  FALSE,
  0x12,
  NULL,
},

//
// Standard VGA Color graphics mode 0x12, 640x480 16 colors. 72Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 80, 30,
  640, 480, 80, 0x10000, 72, 0, NoBanking, MemMap_VGA,
  FALSE,
  0x12,
  NULL,
},

//
// Standard ModeX Color graphics mode 0x13, 320x200 256 colors.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 8, 1, 80, 30,
  320, 200, 80, 0x10000, 70, 0, NoBanking, MemMap_VGA,
  FALSE,
  0x13,
  MODESET_MODEX_320_200,
},

//
// Standard ModeX Color graphics mode 0x13, 320x240 256 colors.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 8, 1, 80, 30,
  320, 240, 80, 0x10000, 60, 0, NoBanking, MemMap_VGA,
  FALSE,
  0x13,
  MODESET_MODEX_320_240,
},

//
// Standard ModeX Color graphics mode 0x13, 320x400 256 colors.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 8, 1, 80, 30,
  320, 400, 80, 0x10000, 70, 0, NoBanking, MemMap_VGA,
  FALSE,
  0x13,
  MODESET_MODEX_320_400,
},

//
// Standard ModeX Color graphics mode 0x13, 320x480 256 colors.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 8, 1, 80, 30,
  320, 480, 80, 0x10000, 60, 0, NoBanking, MemMap_VGA,
  FALSE,
  0x13,
  MODESET_MODEX_320_480,
},

//
// Beginning of SVGA modes
//

//
// 800x600 16 colors.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000, 60, 0, NoBanking, MemMap_VGA,
  FALSE,
  0x29,
  NULL,
},

//
// 800x600 16 colors. 72 hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000, 72, 0, NoBanking, MemMap_VGA,
  FALSE,
  0x29,
  NULL,
},

//
// 800x600 16 colors. 56 hz for 8514/a monitors... (fixed freq)
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000, 56, 0, NoBanking, MemMap_VGA,
  FALSE,
  0x29,
  NULL,
},

//
// 1024x768 non-interlaced 16 colors.
// Assumes 512K.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000, 60, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x37,
  NULL,
},

//
// 1024x768 non-interlaced 16 colors. 70hz
// Assumes 512K.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000, 70, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x37,
  NULL
},

//
// 1024x768 non-interlaced 16 colors. Interlaced (45 hz)
// Assumes 512K.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000, 45, 1, NormalBanking, MemMap_VGA,
  FALSE,
  0x37,
  NULL
},

//////////////////////////////////////////////////////////////////
// Non Planar Modes
//

//
// 640x480x256
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1K_WIDE
},

//
// 640x480x256 72 Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 72, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1K_WIDE
},

//
// 640x480x256 75 Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 75, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1K_WIDE
},

//
// 640x480x256 85 Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 85, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1K_WIDE
},

//
// 640x480x256 90 Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 90, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1K_WIDE
},

// NOTE: 800x600 modes need 1Meg until we support broken rasters

//
// 800x600x256  56Hz
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 56, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x30,
  ET4K_1K_WIDE
},

//
// 800x600x256 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x30,
  ET4K_1K_WIDE
},

//
// 800x600x256 72Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 72, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x30,
  ET4K_1K_WIDE
},

//
// 800x600x256  75Hz
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 75, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x30,
  ET4K_1K_WIDE
},

//
// 800x600x256  85Hz
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 85, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x30,
  ET4K_1K_WIDE
},

//
// 800x600x256  90Hz
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 90, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x30,
  ET4K_1K_WIDE
},

//
// 1024x768x256 45Hz (Interlaced)
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1024, 768, 1024, 0x100000, 45, 1, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1024x768x256 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1024, 768, 1024, 0x100000, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1024x768x256 70Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1024, 768, 1024, 0x100000, 70, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1024x768x256 72Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1024, 768, 1024, 0x100000, 72, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1024x768x256 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1024, 768, 1024, 0x100000, 75, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 640x480x64K
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1928, 0x100000, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1928_WIDE
},

//
// 640x480x64K 72Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1928, 0x100000, 72, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1928_WIDE
},

//
// 640x480x64K 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1928, 0x80000, 75, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1928_WIDE
},

//
// 640x480x64K 90Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1928, 0x80000, 90, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1928_WIDE
},

//
// 800x600x64K
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  800, 600, 800*2, 0x100000, 60, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 800x600x64K 72Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  800, 600, 800*2, 0x100000, 72, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 800x600x64K 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  800, 600, 800*2, 0x100000, 75, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 800x600x64K 90Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  800, 600, 800*2, 0x100000, 90, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 1024x768x64K
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  1024, 768, 1024*2, 0x200000, 60, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1024x768x64K 70Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  1024, 768, 1024*2, 0x200000, 70, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1024x768x64K 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  1024, 768, 1024*2, 0x200000, 75, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1280x1024x256 45Hz (interlaced)
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1280, 1024, 1280, 0x200000, 45, 1, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x3F,
  NULL
},

//
// 1280x1024 8bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1280, 1024, 1280, 0x200000, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x3F,
  NULL
},

//
// 1280x1024 8bpp 70Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1280, 1024, 1280, 0x200000, 70, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x3F,
  NULL
},

//
// 1280x1024 8bpp 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1280, 1024, 1280, 0x200000, 75, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x3F,
  NULL
},

//
// 640x480 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 640*3, 640*480*3, 60, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x2E,
  NULL
},

//
// 640x480 24bpp 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 640*3, 640*480*3, 75, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x2E,
  NULL
},

//
// 640x480 24bpp 90Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 640*3, 640*480*3, 90, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x2E,
  NULL
},

//
// 800x600 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  800, 600, 800*3, 800*600*3, 60, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 800x600 24bpp 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  800, 600, 800*3, 800*600*3, 75, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 800x600 24bpp 90Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  800, 600, 800*3, 800*600*3, 90, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

#if 0
//
// 1024x768 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  1024, 768, 1024*3, 1024*768*3, 60, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 1024x768 24bpp 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  1024, 768, 1024*3, 1024*768*3, 75, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},
#endif

//////////////////////////////////////////////////////////////////////
// DirectDraw modes
//

//
// 320x200 8bpp 70Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  320, 200, 320, 320*200, 70, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x13,
  NULL
},

//
// 320x200 16bpp 70Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  320, 200, 320*2, 320*200*2, 70, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x13,
  NULL
},

//
// 320x200 24bpp 70Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  320, 200, 320*3, 320*200*3, 70, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x13,
  NULL
},

//
// 320x240 8bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  320, 240, 320, 320*240, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x1e,
  NULL
},

//
// 320x240 16bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  320, 240, 320*2, 320*240*2, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x1e,
  NULL
},

//
// 320x240 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  320, 240, 320*3, 320*240*3, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x1e,
  NULL
},

//
// 512x384 8bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  512, 384, 512, 512*384, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x1f,
  NULL
},

//
// 512x384 16bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  512, 384, 512*2, 512*384*2, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x1f,
  NULL
},

//
// 512x384 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  512, 384, 512*3, 512*384*3, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x1f,
  NULL
},

//
// 640x400 8bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 400, 640, 640*400, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2f,
  NULL
},

//
// 640x400 16bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 400, 640*2, 640*400*2, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2f,
  NULL
},

//
// 640x400 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 400, 640*3, 640*400*3, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2f,
  NULL
},

};

ULONG NumVideoModes = sizeof(ModesVGA) / sizeof(VIDEOMODE);


//
//
// Data used to set the Graphics and Sequence Controllers to put the
// VGA into a planar state at A0000 for 64K, with plane 2 enabled for
// reads and writes, so that a font can be loaded, and to disable that mode.
//

// Settings to enable planar mode with plane 2 enabled.
//

USHORT EnableA000Data[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    1,
    0x0100,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0204,     // Read Map = plane 2
    0x0005, // Graphics Mode = read mode 0, write mode 0
    0x0406, // Graphics Miscellaneous register = A0000 for 64K, not odd/even,
            //  graphics mode
    OWM,
    SEQ_ADDRESS_PORT,
    3,
    0x0402, // Map Mask = write to plane 2 only
    0x0404, // Memory Mode = not odd/even, not full memory, graphics mode
    0x0300,  // end sync reset
    EOD
};

//
// Settings to disable the font-loading planar mode.
//

USHORT DisableA000Color[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    1,
    0x0100,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0004, 0x1005, 0x0E06,

    OWM,
    SEQ_ADDRESS_PORT,
    3,
    0x0302, 0x0204, 0x0300,  // end sync reset
    EOD

};

#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\tseng\mini\et4000.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    et4000.h

Abstract:

    This module contains the definitions for the code that implements the
    tseng et4000 device driver.

Environment:

    Kernel mode

Revision History:


--*/

#ifndef NO_INT10_MODE_SET
#define INT10_MODE_SET 1
#endif


//////////////////////////////////////////////////////////////////////////////
// private IOCTL info - if you touch this, do the same to the display drivers
//

#define IOCTL_VIDEO_GET_VIDEO_CARD_INFO \
        CTL_CODE (FILE_DEVICE_VIDEO, 2048, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _VIDEO_COPROCESSOR_INFORMATION {
    ULONG ulChipID;         // ET3000, ET4000, W32, W32I, W32P, or ET6000
    ULONG ulRevLevel;       // REV_A, REV_B, REV_C, REV_D, REV_UNDEF
    ULONG ulVideoMemory;    // in bytes
} VIDEO_COPROCESSOR_INFORMATION, *PVIDEO_COPROCESSOR_INFORMATION;

typedef enum _CHIP_TYPE {
    ET3000 = 1,
    ET4000,
    W32,
    W32I,
    W32P,
    ET6000
} CHIP_TYPE;

typedef enum _REV_TYPE {
    REV_UNDEF = 1,
    REV_A,
    REV_B,
    REV_C,
    REV_D,
} REV_TYPE;

//
//  ET6000 PCI defines
//
#define ET6000_VENDOR_ID    0x100C
#define ET6000_DEVICE_ID    0x3208

//////////////////////////////////////////////////////////////////////////////

//
// Do full save and restore.
//

#define EXTENDED_REGISTER_SAVE_RESTORE 1

//
// BIOS Variables
//

#define BIOS_INFO_1 0x488
#define PRODESIGNER_BIOS_INFO 0x4E8

//
// Define type of ET4000 boards
//

typedef enum _BOARD_TYPE {
    SPEEDSTARPLUS = 1,
    SPEEDSTAR24,
    SPEEDSTAR,
    PRODESIGNERIISEISA,
    PRODESIGNERIIS,
    PRODESIGNER2,
    TSENG3000,
    TSENG4000,
    TSENG4000W32,
    STEALTH32,
    TSENG6000,
    OTHER
} BOARD_TYPE;


//
// Base address of VGA memory range.  Also used as base address of VGA
// memory when loading a font, which is done with the VGA mapped at A0000.
//

#define MEM_VGA      0xA0000
#define MEM_VGA_SIZE 0x20000

#define BANKED_FRAME_BUFFER 3
#define LINEAR_FRAME_BUFFER 4

//
// W32 MMU stuff
//

#define PORT_IO_ADDR                0
#define PORT_IO_LEN                 0x10000

// When we are banked

#define BANKED_MMU_BUFFER_MEMORY_ADDR          0xB8000
#define BANKED_MMU_BUFFER_MEMORY_LEN           (0xBE000 - 0xB8000)
#define BANKED_MMU_MEMORY_MAPPED_REGS_ADDR     0xBFF00
#define BANKED_MMU_MEMORY_MAPPED_REGS_LEN      (0xC0000 - 0xBFF00)
#define BANKED_MMU_EXTERNAL_MAPPED_REGS_ADDR   0xBE000
#define BANKED_MMU_EXTERNAL_MAPPED_REGS_LEN    (0xBF000 - 0xBE000)

#define BANKED_APERTURE_0_OFFSET   0x0000
#define BANKED_APERTURE_1_OFFSET   0x2000
#define BANKED_APERTURE_2_OFFSET   0x4000

// When we are linear

#define MMU_BUFFER_MEMORY_ADDR          0x200000
#define MMU_BUFFER_MEMORY_LEN           0x180000
#define MMU_MEMORY_MAPPED_REGS_ADDR     0x3FFF00
#define MMU_MEMORY_MAPPED_REGS_LEN      0x000100
#define MMU_EXTERNAL_MAPPED_REGS_ADDR   0x3FE000
#define MMU_EXTERNAL_MAPPED_REGS_LEN    0x001000

typedef struct {
    ULONG  ulOffset;
    ULONG  ulLength;
} RANGE_OFFSETS;

#define APERTURE_0_OFFSET   0x000000
#define APERTURE_1_OFFSET   0x080000
#define APERTURE_2_OFFSET   0x100000

#define MMU_APERTURE_2_ACL_BIT  0x04

typedef struct {
    ULONG   ulPhysicalAddress;
    ULONG   ulLength;
    ULONG   ulInIoSpace;
    PVOID   pvVirtualAddress;
} W32_ADDRESS_MAPPING_INFORMATION, *PW32_ADDRESS_MAPPING_INFORMATION;


//
// Port definitions for filling the ACCESS_RANGES structure in the miniport
// information, defines the range of I/O ports the VGA spans.
// There is a break in the IO ports - a few ports are used for the parallel
// port. Those cannot be defined in the ACCESS_RANGE, but are still mapped
// so all VGA ports are in one address range.
//

#define VGA_BASE_IO_PORT      0x000003B0
#define VGA_START_BREAK_PORT  0x000003BB
#define VGA_END_BREAK_PORT    0x000003C0
#define VGA_MAX_IO_PORT       0x000003DF

//
// W32 CRTCB port addresses (used for ID)
//

#define CRTCB_IO_PORT_BASE    0x0000217A
#define CRTCB_IO_PORT_LEN     0x00000002

#define CRTCB_IO_PORT_INDEX   CRTCB_IO_PORT_BASE
#define CRTCB_IO_PORT_DATA    (CRTCB_IO_PORT_INDEX+1)
#define IND_CRTCB_CHIP_ID     0xEC


//
// VGA register definitions
//
                                            // ports in monochrome mode
#define CRTC_ADDRESS_PORT_MONO      0x03B4  // CRT Controller Address and
#define CRTC_DATA_PORT_MONO         0x03B5  // Data registers in mono mode
#define MODE_CONTROL_PORT_MONO      0x03B8  // Tseng Mode Control port, used
                                            //  here only for unlocking the
                                            //  key so we can get at extended
                                            //  registers
#define FEAT_CTRL_WRITE_PORT_MONO   0x03BA  // Feature Control write port
                                            // in mono mode
#define INPUT_STATUS_1_MONO         0x03BA  // Input Status 1 register read
                                            // port in mono mode
#define ATT_INITIALIZE_PORT_MONO    INPUT_STATUS_1_MONO
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in mono mode
#define HERCULES_COMPATIBILITY_PORT 0x03BF  // used to unlock Tseng key to
                                            //  get at extended ports

#define ATT_ADDRESS_PORT            0x03C0  // Attribute Controller Address and
#define ATT_DATA_WRITE_PORT         0x03C0  // Data registers share one port
                                            // for writes, but only Address is
                                            // readable at 0x010
#define ATT_DATA_READ_PORT          0x03C1  // Attribute Controller Data reg is
                                            // readable here
#define MISC_OUTPUT_REG_WRITE_PORT  0x03C2  // Miscellaneous Output reg write
                                            // port
#define INPUT_STATUS_0_PORT         0x03C2  // Input Status 0 register read
                                            // port
#define VIDEO_SUBSYSTEM_ENABLE_PORT 0x03C3  // Bit 0 enables/disables the
                                            // entire VGA subsystem
#define SEQ_ADDRESS_PORT            0x03C4  // Sequence Controller Address and
#define SEQ_DATA_PORT               0x03C5  // Data registers
#define DAC_PIXEL_MASK_PORT         0x03C6  // DAC pixel mask reg
#define DAC_ADDRESS_READ_PORT       0x03C7  // DAC register read index reg,
                                            // write-only
#define DAC_STATE_PORT              0x03C7  // DAC state (read/write),
                                            // read-only
#define DAC_ADDRESS_WRITE_PORT      0x03C8  // DAC register write index reg
#define DAC_DATA_REG_PORT           0x03C9  // DAC data transfer reg
#define FEAT_CTRL_READ_PORT         0x03CA  // Feature Control read port
#define MISC_OUTPUT_REG_READ_PORT   0x03CC  // Miscellaneous Output reg read
                                            // port
#define SEGMENT_SELECT_PORT         0x03CD  // Tseng banking control register
#define SEGMENT_SELECT_HIGH         0x03CB  // Tseng W32 SegSel extension
#define GRAPH_ADDRESS_PORT          0x03CE  // Graphics Controller Address
#define GRAPH_DATA_PORT             0x03CF  // and Data registers

                                            // ports in color mode
#define CRTC_ADDRESS_PORT_COLOR     0x03D4  // CRT Controller Address and
#define CRTC_DATA_PORT_COLOR        0x03D5  // Data registers in color mode
#define MODE_CONTROL_PORT_COLOR     0x03D8  // Tseng Mode Control port, used
                                            //  here only for unlocking the
                                            //  key so we can get at extended
                                            //  registers
#define FEAT_CTRL_WRITE_PORT_COLOR  0x03DA  // Feature Control write port
#define INPUT_STATUS_1_COLOR        0x03DA  // Input Status 1 register read
                                            // port in color mode
#define ATT_INITIALIZE_PORT_COLOR   INPUT_STATUS_1_COLOR
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in color mode
//
// Offsets in HardwareStateHeader->PortValue[] of save areas for non-indexed
// VGA registers.
//

#define CRTC_ADDRESS_MONO_OFFSET      0x04
#define FEAT_CTRL_WRITE_MONO_OFFSET   0x0A
#define ATT_ADDRESS_OFFSET            0x10
#define MISC_OUTPUT_REG_WRITE_OFFSET  0x12
#define VIDEO_SUBSYSTEM_ENABLE_OFFSET 0x13
#define SEQ_ADDRESS_OFFSET            0x14
#define DAC_PIXEL_MASK_OFFSET         0x16
#define DAC_STATE_OFFSET              0x17
#define DAC_ADDRESS_WRITE_OFFSET      0x18
#define GRAPH_ADDRESS_OFFSET          0x1E
#define CRTC_ADDRESS_COLOR_OFFSET     0x24
#define FEAT_CTRL_WRITE_COLOR_OFFSET  0x2A

//
// VGA indexed register indexes.
//

#define IND_CURSOR_START        0x0A    // index in CRTC of the Cursor Start
#define IND_CURSOR_END          0x0B    //  and End registers
#define IND_CURSOR_HIGH_LOC     0x0E    // index in CRTC of the Cursor Location
#define IND_CURSOR_LOW_LOC      0x0F    //  High and Low Registers
#define IND_VSYNC_END           0x11    // index in CRTC of the Vertical Sync
                                        //  End register, which has the bit
                                        //  that protects/unprotects CRTC
                                        //  index registers 0-7
#define IND_SET_RESET_ENABLE    0x01    // index of Set/Reset Enable reg in GC
#define IND_DATA_ROTATE         0x03    // index of Data Rotate reg in GC
#define IND_READ_MAP            0x04    // index of Read Map reg in Graph Ctlr
#define IND_GRAPH_MODE          0x05    // index of Mode reg in Graph Ctlr
#define IND_GRAPH_MISC          0x06    // index of Misc reg in Graph Ctlr
#define IND_BIT_MASK            0x08    // index of Bit Mask reg in Graph Ctlr
#define IND_SYNC_RESET          0x00    // index of Sync Reset reg in Seq
#define IND_MAP_MASK            0x02    // index of Map Mask in Sequencer
#define IND_MEMORY_MODE         0x04    // index of Memory Mode reg in Seq
#define IND_STATE_CONTROL       0x06    // index of TS State Control reg in Seq
#define IND_TS_AUX_MODE         0x07    // index of TS Aux Mode reg in Seq
#define IND_CRTC_PROTECT        0x11    // index of reg containing regs 0-7 in
                                        //  CRTC
#define IND_RAS_CAS_CONFIG      0x32    // index of RAS/CAS Config reg in CRTC
#define IND_EXT_START_ADDR      0x33    // index of Extended Start Address reg
                                        //  in CRTC
#define IND_CRTC_COMPAT         0x34    // index of CRTC Compatibility reg
                                        //  in CRTC
#define IND_OFLOW_HIGH          0x35    // index of Overflow High reg in CRTC
#define IND_VID_SYS_CONFIG_1    0x36    // index of Video System Configuration
#define IND_VID_SYS_CONFIG_2    0x37    //  1 & 2 registers in CRTC
#define IND_ATC_MISC            0x16    // index of Miscellaneous reg in ATC

#define START_SYNC_RESET_VALUE  0x01    // value for Sync Reset reg to start
                                        //  synchronous reset
#define END_SYNC_RESET_VALUE    0x03    // value for Sync Reset reg to end
                                        //  synchronous reset

#define UNLOCK_KEY_1            0x03    // value to output to Herc Compat
                                        //  register as first step in unlocking
                                        //  key so Tseng registers can be set
#define UNLOCK_KEY_2            0xA0    // value to output to Mode Control Port
                                        //  register as 2nd step in unlocking
                                        //  key so Tseng registers can be set
#define LOCK_KEY_1              0x00    // value to output to Herc Compat
                                        //  register as first step in locking
                                        //  key so Tseng registers can't be set
#define LOCK_KEY_2              0x00    // value to output to Mode Control Port
                                        //  register as 2nd step in locking
                                        //  key so Tseng registers can't be set
#define HERCULES_COMPATIBILITY_DEFAULT 0x00
                                        // value to output to Herc Compat
                                        //  register to put back to MDA
                                        //  compatibility

#define MODE_CONTROL_PORT_COLOR_DEFAULT 0x00
#define MODE_CONTROL_PORT_MONO_DEFAULT 0x00
                                        // values to output to CGA and MDA mode
                                        //  registers to put to default state
                                        //  (video disabled).

//
// Values for Attribute Controller Index register to turn video off
// and on, by setting bit 5 to 0 (off) or 1 (on).
//

#define VIDEO_DISABLE 0
#define VIDEO_ENABLE  0x20

// Masks to keep only the significant bits of the Graphics Controller and
// Sequencer Address registers. Masking is necessary because some VGAs, such
// as S3-based ones, don't return unused bits set to 0, and some SVGAs use
// these bits if extensions are enabled.
//

#define GRAPH_ADDR_MASK 0x0F
#define SEQ_ADDR_MASK   0x07

//
// Mask used to toggle Chain4 bit in the Sequencer's Memory Mode register.
//

#define CHAIN4_MASK 0x08

//
// Value written to the Read Map register when identifying the existence of
// a VGA in VgaInitialize. This value must be different from the final test
// value written to the Bit Mask in that routine.
//

#define READ_MAP_TEST_SETTING 0x03

//
// Default text mode setting for various registers, used to restore their
// states if VGA detection fails after they've been modified.
//

#define MEMORY_MODE_TEXT_DEFAULT 0x02
#define BIT_MASK_DEFAULT 0xFF
#define READ_MAP_DEFAULT 0x00

//
// Palette-related info.
//

//
// Highest valid DAC color register index.
//

#define VIDEO_MAX_COLOR_REGISTER  0xFF

//
// Highest valid palette register index
//

#define VIDEO_MAX_PALETTE_REGISTER 0x0F


//
// Indices for type of memory mapping; used in ModesVGA[], must match
// MemoryMap[].
//

typedef enum _VIDEO_MEMORY_MAP {
    MemMap_Mono,
    MemMap_CGA,
    MemMap_VGA
} VIDEO_MEMORY_MAP, *PVIDEO_MEMORY_MAP;

//
// Memory map table definition
//

typedef struct {
    ULONG   MaxSize;        // Maximum addressable size of memory
    ULONG   Start;          // Start address of display memory
} MEMORYMAPS;

//
// For a mode, the type of banking supported. Controls the information
// returned in VIDEO_BANK_SELECT. PlanarHCBanking includes NormalBanking.
//

typedef enum _BANK_TYPE {
    NoBanking = 0,
    MemMgrBanking,
    NormalBanking,
    PlanarHCBanking
} BANK_TYPE, *PBANK_TYPE;


//
// Structure used to describe each video mode in ModesVGA[].
//

typedef struct {
    USHORT  fbType;             // color or monochrome, text or graphics, via
                                //  VIDEO_MODE_COLOR and VIDEO_MODE_GRAPHICS
    USHORT  numPlanes;          // # of video memory planes
    USHORT  bitsPerPlane;       // # of bits of color in each plane
    SHORT   col;                // # of text columns across screen with default font

    SHORT   row;                // # of text rows down screen with default font
    USHORT  hres;               // # of pixels across screen
    USHORT  vres;               // # of scan lines down screen
    USHORT  wbytes;             // # of bytes from start of one scan line to start of next
    ULONG   sbytes;             // total size of addressable display memory in bytes
    ULONG   Frequency;          // Vertical Frequency
    ULONG   Interlaced;         // Determines if the mode is interlaced or not
    BANK_TYPE banktype;         // NoBanking, NormalBanking, PlanarHCBanking
    VIDEO_MEMORY_MAP MemMap;    // index from VIDEO_MEMORY_MAP of memory
                                //  mapping used by this mode
    BOOLEAN ValidMode;          // Determines which modes are valid.
    ULONG   Int10ModeNumber;    // Mode number via Int 10
    PUSHORT CmdStrings;         // pointer to array of register-setting commands
} VIDEOMODE, *PVIDEOMODE;


//
// Mode into which to put the VGA before starting a VDM, so it's a plain
// vanilla VGA.  (This is the mode's index in ModesVGA[], currently standard
// 80x25 text mode.)
//

#define DEFAULT_MODE 0


//
// Info used by the Validator functions and save/restore code.
// Structure used to trap register accesses that must be done atomically.
//


//
// Number of each type of indexed register in a standard VGA, used by
// validator and state save/restore functions.
//
// Note: VDMs currently only support basic VGAs only.
//

#define VGA_NUM_SEQUENCER_PORTS     5
#define VGA_NUM_CRTC_PORTS         25
#define VGA_NUM_GRAPH_CONT_PORTS    9
#define VGA_NUM_ATTRIB_CONT_PORTS  21
#define VGA_NUM_DAC_ENTRIES       256

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

//
// Indices to start save/restore in extension registers:
// For both chip types

#define ET4000_SEQUENCER_EXT_START     0x06
#define ET4000_SEQUENCER_EXT_END       0x07

#define ET4000_CRTC_EXT_START          0x31
#define ET4000_CRTC_EXT_END            0x37
#define ET4000_CRTC_1_EXT_START        0x3F
#define ET4000_CRTC_1_EXT_END          0x3F

#define ET4000_ATTRIB_EXT_START        0x16
#define ET4000_ATTRIB_EXT_END          0x16

//
// Number of extended regs for both chip types.
//

#define ET4000_NUM_SEQUENCER_EXT_PORTS (ET4000_SEQUENCER_EXT_END - ET4000_SEQUENCER_EXT_START + 1)
#define ET4000_NUM_CRTC_EXT_PORTS      (ET4000_CRTC_EXT_END - ET4000_CRTC_EXT_START + 1) + \
                                       (ET4000_CRTC_1_EXT_END - ET4000_CRTC_1_EXT_START + 1)
#define ET4000_NUM_ATTRIB_EXT_PORTS    (ET4000_ATTRIB_EXT_END - ET4000_ATTRIB_EXT_START + 1)

//
// set values for save/restore area based on largest value for a chipset.
//

#define EXT_NUM_GRAPH_CONT_PORTS    0
#define EXT_NUM_SEQUENCER_PORTS     ET4000_NUM_SEQUENCER_EXT_PORTS
#define EXT_NUM_CRTC_PORTS          ET4000_NUM_CRTC_EXT_PORTS
#define EXT_NUM_ATTRIB_CONT_PORTS   ET4000_NUM_ATTRIB_EXT_PORTS
#define EXT_NUM_DAC_ENTRIES         0

#else

#define EXT_NUM_GRAPH_CONT_PORTS    0
#define EXT_NUM_SEQUENCER_PORTS     0
#define EXT_NUM_CRTC_PORTS          0
#define EXT_NUM_ATTRIB_CONT_PORTS   0
#define EXT_NUM_DAC_ENTRIES         0

#endif


#define VGA_MAX_VALIDATOR_DATA       100

#define VGA_VALIDATOR_UCHAR_ACCESS   1
#define VGA_VALIDATOR_USHORT_ACCESS  2
#define VGA_VALIDATOR_ULONG_ACCESS   3

typedef struct _VGA_VALIDATOR_DATA {
   ULONG Port;
   UCHAR AccessType;
   ULONG Data;
} VGA_VALIDATOR_DATA, *PVGA_VALIDATOR_DATA;

//
// Number of bytes to save in each plane.
//

#define VGA_PLANE_SIZE 0x10000

//
// These constants determine the offsets within the
// VIDEO_HARDWARE_STATE_HEADER structure that are used to save and
// restore the VGA's state.
//

#define VGA_HARDWARE_STATE_SIZE sizeof(VIDEO_HARDWARE_STATE_HEADER)

#define VGA_BASIC_SEQUENCER_OFFSET (VGA_HARDWARE_STATE_SIZE + 0)
#define VGA_BASIC_CRTC_OFFSET (VGA_BASIC_SEQUENCER_OFFSET + \
         VGA_NUM_SEQUENCER_PORTS)
#define VGA_BASIC_GRAPH_CONT_OFFSET (VGA_BASIC_CRTC_OFFSET + \
         VGA_NUM_CRTC_PORTS)
#define VGA_BASIC_ATTRIB_CONT_OFFSET (VGA_BASIC_GRAPH_CONT_OFFSET + \
         VGA_NUM_GRAPH_CONT_PORTS)
#define VGA_BASIC_DAC_OFFSET (VGA_BASIC_ATTRIB_CONT_OFFSET + \
         VGA_NUM_ATTRIB_CONT_PORTS)
#define VGA_BASIC_LATCHES_OFFSET (VGA_BASIC_DAC_OFFSET + \
         (3 * VGA_NUM_DAC_ENTRIES))

#define VGA_EXT_SEQUENCER_OFFSET (VGA_BASIC_LATCHES_OFFSET + 4)
#define VGA_EXT_CRTC_OFFSET (VGA_EXT_SEQUENCER_OFFSET + \
         EXT_NUM_SEQUENCER_PORTS)
#define VGA_EXT_GRAPH_CONT_OFFSET (VGA_EXT_CRTC_OFFSET + \
         EXT_NUM_CRTC_PORTS)
#define VGA_EXT_ATTRIB_CONT_OFFSET (VGA_EXT_GRAPH_CONT_OFFSET +\
         EXT_NUM_GRAPH_CONT_PORTS)
#define VGA_EXT_DAC_OFFSET (VGA_EXT_ATTRIB_CONT_OFFSET + \
         EXT_NUM_ATTRIB_CONT_PORTS)

#define VGA_VALIDATOR_OFFSET (VGA_EXT_DAC_OFFSET + 4 * EXT_NUM_DAC_ENTRIES)

#define VGA_VALIDATOR_AREA_SIZE  sizeof (ULONG) + (VGA_MAX_VALIDATOR_DATA * \
                                 sizeof (VGA_VALIDATOR_DATA)) +             \
                                 sizeof (ULONG) +                           \
                                 sizeof (ULONG) +                           \
                                 sizeof (PVIDEO_ACCESS_RANGE)

#define VGA_MISC_DATA_AREA_OFFSET VGA_VALIDATOR_OFFSET + VGA_VALIDATOR_AREA_SIZE

#define VGA_MISC_DATA_AREA_SIZE  0

#define VGA_PLANE_0_OFFSET VGA_MISC_DATA_AREA_OFFSET + VGA_MISC_DATA_AREA_SIZE

#define VGA_PLANE_1_OFFSET VGA_PLANE_0_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_2_OFFSET VGA_PLANE_1_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_3_OFFSET VGA_PLANE_2_OFFSET + VGA_PLANE_SIZE

//
// Space needed to store all state data.
//

#define VGA_TOTAL_STATE_SIZE VGA_PLANE_3_OFFSET + VGA_PLANE_SIZE


//
// Device extension for the driver object.  This data is only used
// locally, so this structure can be added to as needed.
//

typedef struct _HW_DEVICE_EXTENSION {

    PUCHAR  IOAddress;            // base I/O address of VGA ports
    PVOID   VideoMemoryAddress;   // base virtual memory address of VGA memory
    ULONG   AdapterMemorySize;    // size, in bytes, of the memory on the
                                  // board.
    ULONG   ModeIndex;            // index of current mode in ModesVGA[]
    ULONG   NumAvailableModes;    // number of valid modes on this device
    PVIDEOMODE  CurrentMode;      // pointer to VIDEOMODE structure for
                                  // current mode.

    CHIP_TYPE   ulChipID;
    REV_TYPE    ulRevLevel;

    USHORT  FontPelColumns;       // Width of the font in pels
    USHORT  FontPelRows;          // height of the font in pels

    VIDEO_CURSOR_POSITION CursorPosition;  // current cursor position


    UCHAR CursorEnable;           // whether cursor is enabled or not
    UCHAR CursorTopScanLine;      // Cursor Start register setting (top scan)
    UCHAR CursorBottomScanLine;   // Cursor End register setting (bottom scan)

    UCHAR BoardID;                // Used to Identify Diamond boards

    PHYSICAL_ADDRESS PhysicalVideoMemoryBase; // physical memory address and
    ULONG PhysicalVideoMemoryLength;          // length of display memory
    PHYSICAL_ADDRESS PhysicalFrameBase;  // physical memory address and
    ULONG PhysicalFrameLength;           // length of display memory for the
                                         // current mode.

    PUSHORT BiosArea;             // address of the BIOS area
    USHORT OriginalBiosData;      // Orignal value in the Bios data area.

    BOOLEAN bLinearModeSupported; // Do we support linear modes?
    BOOLEAN bInLinearMode;        // Are we currently in a linear mode?
    ULONG ulSlot;                 // the slot that the card is in

    //
    // These 4 fields must be at the end of the device extension and must be
    // kept in this order since this data will be copied to and from the save
    // state buffer that is passed to and from the VDM.
    //

    ULONG TrappedValidatorCount;   // number of entries in the Trapped
                                   // validator data Array.
    VGA_VALIDATOR_DATA TrappedValidatorData[VGA_MAX_VALIDATOR_DATA];
                                   // Data trapped by the validator routines
                                   // but not yet played back into the VGA
                                   // register.

    ULONG SequencerAddressValue;   // Determines if the Sequencer Address Port
                                   // is currently selecting the SyncReset data
                                   // register.

    ULONG CurrentNumVdmAccessRanges;           // Number of access ranges in
                                               // the access range array pointed
                                               // to by the next field
    PVIDEO_ACCESS_RANGE CurrentVdmAccessRange; // Access range currently
                                               // associated to the VDM

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


//
// Function prototypes.
//

//
// Entry points for the VGA validator. Used in VgaEmulatorAccessEntries[].
//

VP_STATUS
VgaValidatorUcharEntry (
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    );

VP_STATUS
VgaValidatorUshortEntry (
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    );

VP_STATUS
VgaValidatorUlongEntry (
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    );

BOOLEAN
VgaPlaybackValidatorData (
    PVOID Context
    );

//
// Bank switch code start and end labels, define in HARDWARE.ASM
//

extern UCHAR BankSwitchStart;
extern UCHAR PlanarHCBankSwitchStart;
extern UCHAR EnablePlanarHCStart;
extern UCHAR DisablePlanarHCStart;
extern UCHAR BankSwitchEnd;

//
// Vga init scripts for font loading
//

extern USHORT EnableA000Data[];
extern USHORT DisableA000Color[];

extern MEMORYMAPS MemoryMaps[];

extern VIDEOMODE ModesVGA[];
extern ULONG NumVideoModes;

extern RANGE_OFFSETS RangeOffsets[2][2];

#define NUM_VGA_ACCESS_RANGES  3
extern VIDEO_ACCESS_RANGE VgaAccessRange[];

#define VGA_NUM_EMULATOR_ACCESS_ENTRIES     6
extern EMULATOR_ACCESS_ENTRY VgaEmulatorAccessEntries[];

#define NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE 4
extern VIDEO_ACCESS_RANGE MinimalVgaValidatorAccessRange[];

#define NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE 2
extern VIDEO_ACCESS_RANGE FullVgaValidatorAccessRange[];


//
// functions used in both modules.
//

VOID
UnlockET4000ExtendedRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
LockET4000ExtendedRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

#define VESA_POWER_FUNCTION 0x4f10
#define VESA_POWER_ON       0x0000
#define VESA_POWER_STANDBY  0x0100
#define VESA_POWER_SUSPEND  0x0200
#define VESA_POWER_OFF      0x0400
#define VESA_GET_POWER_FUNC 0x0000
#define VESA_SET_POWER_FUNC 0x0001
#define VESA_STATUS_SUCCESS 0x004f

#define QUERY_MONITOR_ID            0x22446688
#define QUERY_NONDDC_MONITOR_ID     0x11223344
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\tseng\mini\et4000.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    et4000.c

Abstract:

    This is the miniport driver for the Tseng card.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "et4000.h"

extern VOID vInitDebugValidators(
    PHW_DEVICE_EXTENSION    phwDeviceExtension,
    EMULATOR_ACCESS_ENTRY   *pVgaEmulatorAccessEntries,
    ULONG                   nEmulatorAccessEntries
    );


//
// Function declarations
//
// Functions that start with 'VGA' are entry points for the OS port driver.
//

VP_STATUS
VgaFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
VgaInitialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
VgaStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

//
// Private function prototypes.
//

VP_STATUS
VgaQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    );

VP_STATUS
VgaLoadAndSetFont(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_LOAD_FONT_INFORMATION FontInformation,
    ULONG FontInformationSize
    );

VP_STATUS
VgaQueryCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize
    );

VP_STATUS
VgaQueryCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize
    );

BOOLEAN
VgaIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
ET4000IsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
ET6000IsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_ACCESS_RANGE pAccessRange
    );

VOID
VgaInterpretCmdStream(
    PVOID HwDeviceExtension,
    PUSHORT pusCmdStream
    );

VP_STATUS
VgaSetPaletteReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_PALETTE_DATA PaletteBuffer,
    ULONG PaletteBufferSize
    );

VP_STATUS
VgaSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    );

VP_STATUS
VgaRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize
    );

VP_STATUS
VgaSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize,
    PULONG OutputSize
    );

VP_STATUS
VgaGetBankSelectCode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_BANK_SELECT BankSelect,
    ULONG BankSelectSize,
    PULONG OutputSize
    );

VOID
LockET4000ExtendedRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
UnlockET4000ExtendedRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
ResetACToggle(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

ULONG
ET4000GetMemorySize(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
ET6000GetMemorySize(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

USHORT
GetIndexedRegisterPacked(
    PUCHAR AddressPort,
    UCHAR index
    );

VOID
ET4000SaveAndSetLinear(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT SaveArray
    );

VOID
ET4000RestoreFromLinear(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT SaveArray
    );

VOID
vBankMap(
    LONG iBankRead,
    LONG iBankWrite,
    PVOID pvContext
    );

BOOLEAN
ET4000With1MegMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
ET4000w32With256KDrams(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT SegmentOffset
    );

VOID
VgaValidateModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );


//
// New entry points added for NT 5.0.
//

#if (_WIN32_WINNT >= 500)

VP_STATUS
ET4000GetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    );

VP_STATUS
ET4000SetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    );

//
// Routine to retrieve the Enhanced Display ID structure via DDC
//
ULONG
ET4000GetVideoChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    );
#endif  // _WIN32_WINNT >= 500


#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,VgaFindAdapter)
#pragma alloc_text(PAGE,VgaInitialize)
#pragma alloc_text(PAGE,VgaStartIO)
#pragma alloc_text(PAGE,VgaLoadAndSetFont)
#pragma alloc_text(PAGE,VgaQueryCursorPosition)
#pragma alloc_text(PAGE,VgaSetCursorPosition)
#pragma alloc_text(PAGE,VgaQueryCursorAttributes)
#pragma alloc_text(PAGE,VgaSetCursorAttributes)
#pragma alloc_text(PAGE,VgaIsPresent)
#pragma alloc_text(PAGE,ET4000IsPresent)
#pragma alloc_text(PAGE,ET6000IsPresent)
#pragma alloc_text(PAGE,VgaSetPaletteReg)
#pragma alloc_text(PAGE,VgaSetColorLookup)
#pragma alloc_text(PAGE,VgaRestoreHardwareState)
#pragma alloc_text(PAGE,VgaSaveHardwareState)
#pragma alloc_text(PAGE,VgaGetBankSelectCode)
#pragma alloc_text(PAGE,LockET4000ExtendedRegs)
#pragma alloc_text(PAGE,UnlockET4000ExtendedRegs)
#pragma alloc_text(PAGE,ResetACToggle)
#pragma alloc_text(PAGE,ET4000GetMemorySize)
#pragma alloc_text(PAGE,ET6000GetMemorySize)
#pragma alloc_text(PAGE,GetIndexedRegisterPacked)
#pragma alloc_text(PAGE,ET4000SaveAndSetLinear)
#pragma alloc_text(PAGE,ET4000RestoreFromLinear)
#pragma alloc_text(PAGE,ET4000With1MegMemory)
#pragma alloc_text(PAGE,ET4000w32With256KDrams)

#pragma alloc_text(PAGE,VgaValidatorUcharEntry)
#pragma alloc_text(PAGE,VgaValidatorUshortEntry)
#pragma alloc_text(PAGE,VgaValidatorUlongEntry)

#if (_WIN32_WINNT >= 500)
#pragma alloc_text(PAGE_COM, ET4000SetPowerState)
#pragma alloc_text(PAGE_COM, ET4000GetPowerState)
#pragma alloc_text(PAGE_COM, ET4000GetVideoChildDescriptor)
#endif  // _WIN32_WINNT >= 500

#endif



ULONG
DriverEntry(
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    Context1 - First context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

    Context2 - Second context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

Return Value:

    Status from VideoPortInitialize()

--*/

{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG status;
    ULONG initializationStatus;

    INTERFACE_TYPE aBusType[] = {PCIBus, Isa, Eisa, MicroChannel,
                                 InterfaceTypeUndefined};
    INTERFACE_TYPE *pBusType = aBusType;

    //
    // Zero out structure.
    //

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    //
    // Specify sizes of structure and extension.
    //

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitData.HwFindAdapter = VgaFindAdapter;
    hwInitData.HwInitialize = VgaInitialize;
    hwInitData.HwInterrupt = NULL;
    hwInitData.HwStartIO = VgaStartIO;

#if (_WIN32_WINNT >= 500)

    //
    // Set new entry points added for NT 5.0.
    //

    hwInitData.HwSetPowerState = ET4000SetPowerState;
    hwInitData.HwGetPowerState = ET4000GetPowerState;
    hwInitData.HwGetVideoChildDescriptor = ET4000GetVideoChildDescriptor;

    hwInitData.HwLegacyResourceList = VgaAccessRange;
    hwInitData.HwLegacyResourceCount = 4;

#endif // _WIN32_WINNT >= 500


    //
    // Determine the size we require for the device extension.
    //

    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    //
    // Always start with parameters for device0 in this case.
    // We can leave it like this since we know we will only ever find one
    // VGA type adapter in a machine.
    //

//    hwInitData.StartingDeviceNumber = 0;

    //
    // Once all the relevant information has been stored, call the video
    // port driver to do the initialization.
    // For this device we will repeat this call three times, for ISA, EISA
    // and MCA.
    // We will return the minimum of all return values.
    //

    while (*pBusType != InterfaceTypeUndefined)
    {
        hwInitData.AdapterInterfaceType = *pBusType;

        initializationStatus = VideoPortInitialize(Context1,
                                                   Context2,
                                                   &hwInitData,
                                                   NULL);

        if (initializationStatus == NO_ERROR)
        {
            return initializationStatus;
        }

        pBusType++;
    }

    //
    // We didn't find the card on any bus type, so lets
    // return the last error.
    //

    return initializationStatus;

} // end DriverEntry()


VP_STATUS
VgaFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

/*++

Routine Description:

    This routine is called to determine if the adapter for this driver
    is present in the system.
    If it is present, the function fills out some information describing
    the adapter.

Arguments:

    HwDeviceExtension - Supplies the miniport driver's adapter storage. This
        storage is initialized to zero before this call.

    HwContext - Supplies the context value which was passed to
        VideoPortInitialize(). Must be NULL for PnP drivers.

    ArgumentString - Supplies a NULL terminated ASCII string. This string
        originates from the user.

    ConfigInfo - Returns the configuration information structure which is
        filled by the miniport driver. This structure is initialized with
        any known configuration information (such as SystemIoBusNumber) by
        the port driver. Where possible, drivers should have one set of
        defaults which do not require any supplied configuration information.

    Again - Indicates if the miniport driver wants the port driver to call
        its VIDEO_HW_FIND_ADAPTER function again with a new device extension
        and the same config info. This is used by the miniport drivers which
        can search for several adapters on a bus.

Return Value:

    This routine must return:

    NO_ERROR - Indicates a host adapter was found and the
        configuration information was successfully determined.

    ERROR_INVALID_PARAMETER - Indicates an adapter was found but there was an
        error obtaining the configuration information. If possible an error
        should be logged.

    ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
        supplied configuration information.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;
    ULONG numAccessRanges=NUM_VGA_ACCESS_RANGES;
    int i;

    //
    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).
    //

    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO)) {

        VideoDebugPrint((1, "VgaFindAdapter - *** Failed *** wrong config info size\n"));
        return ERROR_INVALID_PARAMETER;

    }

    //
    // No interrupt information is necessary.
    //

    //
    // If we are on a PCI bus, lets check and see if an ET6000
    // device is present.  If so, we'll adjust the access ranges.
    //

    if (ConfigInfo->AdapterInterfaceType == PCIBus)
    {
        //
        //  WARNING: this routine really checks for PCI devices.
        //  There are ET4000s mounted on W32P boards. But the bottom line
        //  here is that this routine can return TRUE for ET4000s.
        //  Hence, the extra checks for ulChipID.
        //

        if (ET6000IsPresent(hwDeviceExtension, VgaAccessRange))
        {
            //
            // If we found an ET6000 we will use a linear frame buffer
            //
            hwDeviceExtension->bLinearModeSupported = FALSE;

            if (hwDeviceExtension->ulChipID == ET6000)
                hwDeviceExtension->bLinearModeSupported = TRUE;

            //
            // If we will map the frame buffer linearly, then we need
            // to make sure to verify its access range.
            //
            //  Idiots. They have to verify the memory even if it's
            //  banked.
            //

            numAccessRanges++;
        }
        else
        {
            //
            // All other devices are currently NOT on the PCI bus.  They
            // are just detected as ISA cards.
            //
            // So just fail for the PCI bus.
            //

            VideoDebugPrint((1, "VgaFindAdapter - *** Failed *** PCI, but nto et6000\n"));
            return ERROR_DEV_NOT_EXIST;
        }
    }

    //
    // Check to see if there is a hardware resource conflict.
    //

    status = VideoPortVerifyAccessRanges(HwDeviceExtension,
                                         numAccessRanges,
                                         VgaAccessRange);

    if (status != NO_ERROR) {

        VideoDebugPrint((1, "VgaFindAdapter - *** Failed *** VerifyAccessRanges failed\n"));
        return status;

    }

    //
    // Get logical IO port addresses.
    //

    for (i = 0; i < 3; i++) {

        PUCHAR IOAddress;

        if ( (IOAddress =
                  VideoPortGetDeviceBase(hwDeviceExtension,
                                         VgaAccessRange[i].RangeStart,
                                         VgaAccessRange[i].RangeLength,
                                         VgaAccessRange[i].RangeInIoSpace)) == NULL) {

            VideoDebugPrint((1, "VgaFindAdapter - *** Failed *** to get io address ndx(%d) start(%xh) len(%d)\n",
                                 i,
                                 VgaAccessRange[i].RangeStart.LowPart,
                                 VgaAccessRange[i].RangeLength
                                 ));

            return ERROR_INVALID_PARAMETER;

        } else {

            VideoDebugPrint((1, "VgaFindAdapter - Succeeded to get io address ndx(%d) start(%xh) len(%d)\n",
                                 i,
                                 VgaAccessRange[i].RangeStart.LowPart,
                                 VgaAccessRange[i].RangeLength
                                 ));

            if (i == 0) {

                //
                // The difference between the PORT address we asked for and the address we
                // were given is the offset at which the system is mapping the port i/o
                // space.  On x86 systems this should be 0 and on other systems it will
                // probably not be 0.
                //

                hwDeviceExtension->IOAddress = IOAddress;

                VideoDebugPrint((1, "VgaFindAdapter - port(%x) mapped at (%x)\n",
                                     VgaAccessRange[i].RangeStart.LowPart,
                                     hwDeviceExtension->IOAddress));

                hwDeviceExtension->IOAddress -= VgaAccessRange[i].RangeStart.LowPart;

                VideoDebugPrint((1, "VgaFindAdapter - ports are mapped at offset (%x)\n",
                                     hwDeviceExtension->IOAddress));

            }

        }

    }

    //
    // Determine whether a VGA is present.
    //

    if (!VgaIsPresent(hwDeviceExtension)) {

        VideoDebugPrint((1, "VgaFindAdapter - *** Failed *** No VGA\n"));
        return ERROR_DEV_NOT_EXIST;

    }

    //
    // Video memory information
    //

    hwDeviceExtension->PhysicalVideoMemoryBase.HighPart = 0x00000000;
    hwDeviceExtension->PhysicalVideoMemoryBase.LowPart = MEM_VGA;
    hwDeviceExtension->PhysicalVideoMemoryLength = MEM_VGA_SIZE;

    //
    // Map the video memory into the system virtual address space so we can
    // clear it out and use it for save and restore.
    //

    if ( (hwDeviceExtension->VideoMemoryAddress =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->PhysicalVideoMemoryBase,
              hwDeviceExtension->PhysicalVideoMemoryLength, FALSE)) == NULL) {

        VideoDebugPrint((1, "VgaFindAdapter - Fail to get memory address\n"));

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  If an ET6000 is present, then we already found it above.  If we
    //  have not located an ET6000, then see if we are running on an
    //  ET4000.
    //

    if (hwDeviceExtension->ulChipID != ET6000)
    {
        //
        // Determine whether an ET4000 is present.
        //

        if (!ET4000IsPresent(hwDeviceExtension))
        {
            VideoDebugPrint((1, "VgaFindAdapter - *** Failed *** !et4000 and !et6000\n"));
            return ERROR_DEV_NOT_EXIST;
        }
    }

    //
    // Pass a pointer to the emulator range we are using.
    //

    ConfigInfo->NumEmulatorAccessEntries = VGA_NUM_EMULATOR_ACCESS_ENTRIES;
    ConfigInfo->EmulatorAccessEntries = VgaEmulatorAccessEntries;
    ConfigInfo->EmulatorAccessEntriesContext = (ULONG) hwDeviceExtension;

    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart = MEM_VGA;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryLength = MEM_VGA_SIZE;

    //
    // Minimum size of the buffer required to store the hardware state
    // information returned by IOCTL_VIDEO_SAVE_HARDWARE_STATE.
    //

    ConfigInfo->HardwareStateSize = VGA_TOTAL_STATE_SIZE;

    //
    // Indicate we do not wish to be called again for another initialization.
    //

    *Again = 0;

    //
    // Indicate a successful completion status.
    //

    return NO_ERROR;

} // VgaFindAdapter()


BOOLEAN
VgaInitialize(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine does one time initialization of the device.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    None.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    //
    // set up the default cursor position and type.
    //

    hwDeviceExtension->CursorPosition.Column = 0;
    hwDeviceExtension->CursorPosition.Row = 0;
    hwDeviceExtension->CursorTopScanLine = 0;
    hwDeviceExtension->CursorBottomScanLine = 31;
    hwDeviceExtension->CursorEnable = TRUE;

    hwDeviceExtension->BiosArea = (PUSHORT)NULL;

    //
    //  We use VideoPortInt10 to retrieve the ET6000's memory size
    //  information.  We are doing only the ET6000 only so we can
    //  minimize the impact to any other boards.  By using Int10, we
    //  can save ourselves some possibly tedious work in recognizing
    //  the board's memory configuration.
    //

    if (hwDeviceExtension->ulChipID == ET6000)
    {
        return(ET6000GetMemorySize(hwDeviceExtension));
    }

    return TRUE;

} // VgaInitialize()

BOOLEAN
VgaStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    acceptss a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

    RequestPacket - Pointer to the video request packet. This structure
        contains all the parameters passed to the VideoIoControl function.

Return Value:

    This routine will return error codes from the various support routines
    and will also return ERROR_INSUFFICIENT_BUFFER for incorrectly sized
    buffers and ERROR_INVALID_FUNCTION for unsupported functions.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;
    VIDEO_MODE videoMode;
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    ULONG inIoSpace;

    PVIDEO_SHARE_MEMORY pShareMemory;
    PVIDEO_SHARE_MEMORY_INFORMATION pShareMemoryInformation;
    PHYSICAL_ADDRESS shareAddress;
    PVOID virtualAddress;
    ULONG sharedViewSize;

    //
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //
    VideoDebugPrint((2, "W32StartIO Entry - %08.8x\n", RequestPacket->IoControlCode));

    switch (RequestPacket->IoControlCode) {

    case IOCTL_VIDEO_SHARE_VIDEO_MEMORY:

        VideoDebugPrint((2, "W32StartIO - ShareVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength < sizeof(VIDEO_SHARE_MEMORY_INFORMATION)) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) {

            VideoDebugPrint((1, "IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        pShareMemory = RequestPacket->InputBuffer;

        if ( (pShareMemory->ViewOffset > hwDeviceExtension->AdapterMemorySize) ||
             ((pShareMemory->ViewOffset + pShareMemory->ViewSize) >
                  hwDeviceExtension->AdapterMemorySize) ) {

            VideoDebugPrint((1, "IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INVALID_PARAMETER\n"));
            status = ERROR_INVALID_PARAMETER;
            break;
        }

        RequestPacket->StatusBlock->Information =
                                    sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

        //
        // Beware: the input buffer and the output buffer are the same
        // buffer, and therefore data should not be copied from one to the
        // other
        //

        virtualAddress = pShareMemory->ProcessHandle;
        sharedViewSize = pShareMemory->ViewSize;

#if defined(ALPHA)
        inIoSpace = 4;
#else
        inIoSpace = 0;
#endif

        //
        // NOTE: we are ignoring ViewOffset
        //

        shareAddress.QuadPart = VgaAccessRange[4].RangeStart.QuadPart;
            // hwDeviceExtension->PhysicalFrameBase.QuadPart;

        status = VideoPortMapMemory(hwDeviceExtension,
                                    shareAddress,
                                    &sharedViewSize,
                                    &inIoSpace,
                                    &virtualAddress);

        pShareMemoryInformation = RequestPacket->OutputBuffer;

        pShareMemoryInformation->SharedViewOffset = pShareMemory->ViewOffset;
        pShareMemoryInformation->VirtualAddress = virtualAddress;
        pShareMemoryInformation->SharedViewSize = sharedViewSize;

        break;


    case IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY:

        VideoDebugPrint((2, "W32StartIO - UnshareVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_SHARE_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;

        }

        pShareMemory = RequestPacket->InputBuffer;

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      pShareMemory->RequestedVirtualAddress,
                                      pShareMemory->ProcessHandle);

        break;

    case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:

        VideoDebugPrint((1, "VgaStartIO - Map W32 MMU or ACL\n"));

        if (RequestPacket->OutputBufferLength <
            3 * sizeof(VIDEO_PUBLIC_ACCESS_RANGES))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            PVIDEO_PUBLIC_ACCESS_RANGES portAccess;
            PHYSICAL_ADDRESS            base, pa;
            ULONG                       length;
            ULONG                       ulIndex;

            RequestPacket->StatusBlock->Information =
                3 * sizeof(VIDEO_PUBLIC_ACCESS_RANGES);

            portAccess = RequestPacket->OutputBuffer;

            if (hwDeviceExtension->bInLinearMode)
            {
                base = VgaAccessRange[LINEAR_FRAME_BUFFER].RangeStart;
                ulIndex = 1;
            }
            else
            {
                base = VgaAccessRange[BANKED_FRAME_BUFFER].RangeStart;
                ulIndex = 0;
            }

            //
            // Map the first range
            //

            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = portAccess->InIoSpace;

            //
            // We don't map this range if we are linear!
            //

            if (!hwDeviceExtension->bInLinearMode)
            {
                pa = base;
                pa.LowPart = RangeOffsets[ulIndex][0].ulOffset;
                length     = RangeOffsets[ulIndex][0].ulLength;

                status = VideoPortMapMemory(hwDeviceExtension,
                                            pa,
                                            &length,
                                            &(portAccess->MappedInIoSpace),
                                            &(portAccess->VirtualAddress));

                if (status != NO_ERROR)
                {
                    break;
                }
            }

            //
            // Map the second range
            //

            portAccess++;
            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = portAccess->InIoSpace;

            pa = base;
            pa.LowPart = RangeOffsets[ulIndex][1].ulOffset;
            length     = RangeOffsets[ulIndex][1].ulLength;

            VideoDebugPrint((1, "\n\n**** pa = 0x%x\n", pa.LowPart));

            status = VideoPortMapMemory(hwDeviceExtension,
                                        pa,
                                        &length,
                                        &(portAccess->MappedInIoSpace),
                                        &(portAccess->VirtualAddress));

            if (status != NO_ERROR)
            {
                break;
            }

            //
            // Map the third range
            //

            portAccess++;

            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = TRUE;
            portAccess->MappedInIoSpace = portAccess->InIoSpace;

            pa.LowPart = PORT_IO_ADDR;
            length = PORT_IO_LEN;

            status = VideoPortMapMemory(hwDeviceExtension,
                                        pa,
                                        &length,
                                        &(portAccess->MappedInIoSpace),
                                        &(portAccess->VirtualAddress));

        }

        break;

    case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:

        VideoDebugPrint((2, "VgaStartIO - FreePublicAccessRanges\n"));

        {
            PVIDEO_MEMORY mappedMemory;

            if (RequestPacket->InputBufferLength < 2 * sizeof(VIDEO_MEMORY)) {

                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            status = NO_ERROR;

            mappedMemory = RequestPacket->InputBuffer;

            if (mappedMemory->RequestedVirtualAddress != NULL) {

                status = VideoPortUnmapMemory(hwDeviceExtension,
                                              mappedMemory->
                                                   RequestedVirtualAddress,
                                              0);
            }
        }

        break;


    case IOCTL_VIDEO_MAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "VgaStartIO - MapVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength <
              (RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_MEMORY_INFORMATION))) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;
        }

        memoryInformation = RequestPacket->OutputBuffer;

        memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
                (RequestPacket->InputBuffer))->RequestedVirtualAddress;

#if defined(ALPHA)
        inIoSpace = 4;
#else
        inIoSpace = 0;
#endif

        if (hwDeviceExtension->bInLinearMode)
        {
            //
            // Map in the linear frame buffer
            //

            memoryInformation->VideoRamLength = hwDeviceExtension->AdapterMemorySize;

            status = VideoPortMapMemory(hwDeviceExtension,
                                        VgaAccessRange[4].RangeStart,
                                        &(memoryInformation->VideoRamLength),
                                        &(inIoSpace),
                                        &(memoryInformation->VideoRamBase));

            memoryInformation->FrameBufferLength = memoryInformation->VideoRamLength;
            memoryInformation->FrameBufferBase = memoryInformation->VideoRamBase;

        }
        else
        {
            //
            // Map in the banked frame buffer
            //

            memoryInformation->VideoRamLength = hwDeviceExtension->PhysicalVideoMemoryLength;

            status = VideoPortMapMemory(hwDeviceExtension,
                                        hwDeviceExtension->PhysicalVideoMemoryBase,
                                        &(memoryInformation->VideoRamLength),
                                        &inIoSpace,
                                        &(memoryInformation->VideoRamBase));

            memoryInformation->FrameBufferLength = hwDeviceExtension->PhysicalFrameLength;

            memoryInformation->FrameBufferBase =
            ((PUCHAR) (memoryInformation->VideoRamBase)) +
                (hwDeviceExtension->PhysicalFrameBase.LowPart -
                hwDeviceExtension->PhysicalVideoMemoryBase.LowPart);
        }

        break;


    case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "VgaStartIO - UnMapVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
        }

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      ((PVIDEO_MEMORY)
                                       (RequestPacket->InputBuffer))->
                                           RequestedVirtualAddress,
                                      0);

        break;


    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

        VideoDebugPrint((2, "VgaStartIO - QueryAvailableModes\n"));

        status = VgaQueryAvailableModes(HwDeviceExtension,
                                        (PVIDEO_MODE_INFORMATION)
                                            RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        &RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        VideoDebugPrint((2, "VgaStartIO - QueryNumAvailableModes\n"));

        status = VgaQueryNumberOfAvailableModes(HwDeviceExtension,
                                                (PVIDEO_NUM_MODES)
                                                    RequestPacket->OutputBuffer,
                                                RequestPacket->OutputBufferLength,
                                                &RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_QUERY_CURRENT_MODE:

        VideoDebugPrint((2, "VgaStartIO - QueryCurrentMode\n"));

        status = VgaQueryCurrentMode(HwDeviceExtension,
                                     (PVIDEO_MODE_INFORMATION) RequestPacket->OutputBuffer,
                                     RequestPacket->OutputBufferLength,
                                     &RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_SET_CURRENT_MODE:

        VideoDebugPrint((2, "VgaStartIO - SetCurrentModes\n"));

        status = VgaRestoreHardwareState(HwDeviceExtension,
                                         (PVIDEO_HARDWARE_STATE) RequestPacket->InputBuffer,
                                         RequestPacket->InputBufferLength);

        status = VgaSetMode(HwDeviceExtension,
                              (PVIDEO_MODE) RequestPacket->InputBuffer,
                              RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_RESET_DEVICE:

        VideoDebugPrint((2, "VgaStartIO - Reset Device\n"));

        videoMode.RequestedMode = DEFAULT_MODE;

        status = VgaSetMode(HwDeviceExtension,
                                 (PVIDEO_MODE) &videoMode,
                                 sizeof(videoMode));

        break;


    case IOCTL_VIDEO_LOAD_AND_SET_FONT:

        VideoDebugPrint((2, "VgaStartIO - LoadAndSetFont\n"));

        status = VgaLoadAndSetFont(HwDeviceExtension,
                                   (PVIDEO_LOAD_FONT_INFORMATION) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_QUERY_CURSOR_POSITION:

        VideoDebugPrint((2, "VgaStartIO - QueryCursorPosition\n"));

        status = VgaQueryCursorPosition(HwDeviceExtension,
                                        (PVIDEO_CURSOR_POSITION) RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        &RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_SET_CURSOR_POSITION:

        VideoDebugPrint((2, "VgaStartIO - SetCursorPosition\n"));

        status = VgaSetCursorPosition(HwDeviceExtension,
                                      (PVIDEO_CURSOR_POSITION)
                                          RequestPacket->InputBuffer,
                                      RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_QUERY_CURSOR_ATTR:

        VideoDebugPrint((2, "VgaStartIO - QueryCursorAttributes\n"));

        status = VgaQueryCursorAttributes(HwDeviceExtension,
                                          (PVIDEO_CURSOR_ATTRIBUTES) RequestPacket->OutputBuffer,
                                          RequestPacket->OutputBufferLength,
                                          &RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_SET_CURSOR_ATTR:

        VideoDebugPrint((2, "VgaStartIO - SetCursorAttributes\n"));

        status = VgaSetCursorAttributes(HwDeviceExtension,
                                        (PVIDEO_CURSOR_ATTRIBUTES) RequestPacket->InputBuffer,
                                        RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_SET_PALETTE_REGISTERS:

        VideoDebugPrint((2, "VgaStartIO - SetPaletteRegs\n"));

        status = VgaSetPaletteReg(HwDeviceExtension,
                                  (PVIDEO_PALETTE_DATA) RequestPacket->InputBuffer,
                                  RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_SET_COLOR_REGISTERS:

        VideoDebugPrint((2, "VgaStartIO - SetColorRegs\n"));

        status = VgaSetColorLookup(HwDeviceExtension,
                                   (PVIDEO_CLUT) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_ENABLE_VDM:

        VideoDebugPrint((2, "VgaStartIO - EnableVDM\n"));

        hwDeviceExtension->TrappedValidatorCount = 0;
        hwDeviceExtension->SequencerAddressValue = 0;

        hwDeviceExtension->CurrentNumVdmAccessRanges =
            NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE;
        hwDeviceExtension->CurrentVdmAccessRange =
            MinimalVgaValidatorAccessRange;

        VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                         hwDeviceExtension->CurrentNumVdmAccessRanges,
                                         hwDeviceExtension->CurrentVdmAccessRange);

        status = NO_ERROR;

        break;


    case IOCTL_VIDEO_RESTORE_HARDWARE_STATE:

        VideoDebugPrint((2, "VgaStartIO - RestoreHardwareState\n"));

        status = VgaRestoreHardwareState(HwDeviceExtension,
                                         (PVIDEO_HARDWARE_STATE) RequestPacket->InputBuffer,
                                         RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_SAVE_HARDWARE_STATE:

        VideoDebugPrint((2, "VgaStartIO - SaveHardwareState\n"));

        status = VgaSaveHardwareState(HwDeviceExtension,
                                      (PVIDEO_HARDWARE_STATE) RequestPacket->OutputBuffer,
                                      RequestPacket->OutputBufferLength,
                                      &RequestPacket->StatusBlock->Information);

        break;

    case IOCTL_VIDEO_GET_BANK_SELECT_CODE:

        VideoDebugPrint((2, "VgaStartIO - GetBankSelectCode\n"));

#if defined(i386)
        status = VgaGetBankSelectCode(HwDeviceExtension,
                                        (PVIDEO_BANK_SELECT) RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        &RequestPacket->StatusBlock->Information);
#else
        status = ERROR_INVALID_FUNCTION;
#endif
        break;


    //
    // Private IOCTLs established with the driver
    //

    case IOCTL_VIDEO_GET_VIDEO_CARD_INFO:

        VideoDebugPrint((2, "VgaStartIO - Get video card info\n"));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information =
            sizeof(VIDEO_COPROCESSOR_INFORMATION)) )
        {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        // return the Coproc Base Address.

        ((PVIDEO_COPROCESSOR_INFORMATION) RequestPacket->OutputBuffer)->ulChipID =
            hwDeviceExtension->ulChipID;

        ((PVIDEO_COPROCESSOR_INFORMATION) RequestPacket->OutputBuffer)->ulRevLevel =
            hwDeviceExtension->ulRevLevel;

        status = NO_ERROR;

        break;

    //
    // if we get here, an invalid IoControlCode was specified.
    //

    default:

        VideoDebugPrint((1, "Fell through vga startIO routine - invalid command\n"));

        status = ERROR_INVALID_FUNCTION;

        break;

    }

    RequestPacket->StatusBlock->Status = status;

#if DBG
    VideoDebugPrint((2, "W32StartIO Exit  - %08.8x\n", RequestPacket->IoControlCode));
#endif

    return TRUE;

} // VgaStartIO()

//
// private routines
//

VP_STATUS
VgaLoadAndSetFont(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_LOAD_FONT_INFORMATION FontInformation,
    ULONG FontInformationSize
    )

/*++

Routine Description:

    Takes a buffer containing a user-defined font and loads it into the
    VGA soft font memory and programs the VGA to the appropriate character
    cell size.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FontInformation - Pointer to the structure containing the information
        about the loadable ROM font to be set.

    FontInformationSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    PUCHAR destination;
    PUCHAR source;
    USHORT width;
    ULONG i;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check if the size of the data in the input buffer is large enough
    // and that it contains all the data.
    //

    if ( (FontInformationSize < sizeof(VIDEO_LOAD_FONT_INFORMATION)) ||
         (FontInformationSize < sizeof(VIDEO_LOAD_FONT_INFORMATION) +
                        sizeof(UCHAR) * (FontInformation->FontSize - 1)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check for the width and height of the font
    //

    if ( ((FontInformation->WidthInPixels != 8) &&
          (FontInformation->WidthInPixels != 9)) ||
         (FontInformation->HeightInPixels > 32) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check the size of the font buffer is the right size for the size
    // font being passed down.
    //

    if (FontInformation->FontSize < FontInformation->HeightInPixels * 256 *
                                    sizeof(UCHAR) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Since the font parameters are valid, store the parameters in the
    // device extension and load the font.
    //

    HwDeviceExtension->FontPelRows = FontInformation->HeightInPixels;
    HwDeviceExtension->FontPelColumns = FontInformation->WidthInPixels;

    HwDeviceExtension->CurrentMode->row =
        HwDeviceExtension->CurrentMode->vres / HwDeviceExtension->FontPelRows;

    width =
      HwDeviceExtension->CurrentMode->hres / HwDeviceExtension->FontPelColumns;

    if (width < (USHORT)HwDeviceExtension->CurrentMode->col) {

        HwDeviceExtension->CurrentMode->col = width;

    }

    source = &(FontInformation->Font[0]);

    //
    // Set up the destination and source pointers for the font
    //

    destination = (PUCHAR)HwDeviceExtension->VideoMemoryAddress;

    //
    // Map font buffer at A0000
    //

    VgaInterpretCmdStream(HwDeviceExtension, EnableA000Data);

    //
    // Move the font to its destination
    //

    for (i = 1; i <= 256; i++) {

        VideoPortWriteRegisterBufferUchar(destination,
                                          source,
                                          FontInformation->HeightInPixels);

        destination += 32;
        source += FontInformation->HeightInPixels;

    }

    VgaInterpretCmdStream(HwDeviceExtension, DisableA000Color);

    //
    // Restore to a text mode.
    //

    //
    // Set Height of font.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0x9);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR,
            (UCHAR)(FontInformation->HeightInPixels - 1));

    //
    // Set Width of font.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0x12);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR,
            (UCHAR)(((USHORT)FontInformation->HeightInPixels *
            (USHORT)HwDeviceExtension->CurrentMode->row) - 1));

    i = HwDeviceExtension->CurrentMode->vres /
        HwDeviceExtension->CurrentMode->row;

    //
    // Set Cursor End
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0xb);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR)--i);

    //
    // Set Cursor Statr
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0xa);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR)--i);

    return NO_ERROR;

} //end VgaLoadAndSetFont()

VP_STATUS
VgaQueryCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the row and column of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorPosition - Pointer to the output buffer supplied by the user. This
        is where the cursor position is stored.

    CursorPositionSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        *OutputSize = 0;
        return ERROR_INVALID_PARAMETER;

    }

    //
    // If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (CursorPositionSize < (*OutputSize = sizeof(VIDEO_CURSOR_POSITION)) ) {

        *OutputSize = 0;
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the postition of the cursor into the buffer.
    //

    CursorPosition->Column = HwDeviceExtension->CursorPosition.Column;
    CursorPosition->Row = HwDeviceExtension->CursorPosition.Row;

    return NO_ERROR;

} // end VgaQueryCursorPosition()

VP_STATUS
VgaSetCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize
    )

/*++

Routine Description:

    This routine verifies that the requested cursor position is within
    the row and column bounds of the current mode and font. If valid, then
    it sets the row and column of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorPosition - Pointer to the structure containing the cursor position.

    CursorPositionSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    USHORT position;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (CursorPositionSize < sizeof(VIDEO_CURSOR_POSITION)) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check if the new values for the cursor positions are in the valid
    // bounds for the screen.
    //

    if ((CursorPosition->Column >= HwDeviceExtension->CurrentMode->col) ||
        (CursorPosition->Row >= HwDeviceExtension->CurrentMode->row)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Store these new values in the device extension so we can use them in
    // a QUERY.
    //

    HwDeviceExtension->CursorPosition.Column = CursorPosition->Column;
    HwDeviceExtension->CursorPosition.Row = CursorPosition->Row;

    //
    // Calculate the position on the screen at which the cursor must be
    // be displayed
    //

    position = (USHORT) (HwDeviceExtension->CurrentMode->col *
                         CursorPosition->Row + CursorPosition->Column);


    //
    // Address Cursor Location Low Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, IND_CURSOR_LOW_LOC);

    //
    // Set Cursor Location Low Register
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR) (position & 0x00FF));

    //
    // Address Cursor Location High Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, IND_CURSOR_HIGH_LOC);

    //
    // Set Cursor Location High Register
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR) (position >> 8));

    return NO_ERROR;

} // end VgaSetCursorPosition()

VP_STATUS
VgaQueryCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns information about the height and visibility of the
    cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorAttributes - Pointer to the output buffer supplied by the user.
        This is where the cursor type is stored.

    CursorAttributesSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        *OutputSize = 0;
        return ERROR_INVALID_PARAMETER;

    }

    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (CursorAttributesSize < (*OutputSize =
            sizeof(VIDEO_CURSOR_ATTRIBUTES)) ) {

        *OutputSize = 0;
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the cursor information into the buffer.
    //

    CursorAttributes->Height = (USHORT) HwDeviceExtension->CursorTopScanLine;
    CursorAttributes->Width = (USHORT) HwDeviceExtension->CursorBottomScanLine;
    CursorAttributes->Enable = HwDeviceExtension->CursorEnable;

    return NO_ERROR;

} // end VgaQueryCursorAttributes()

VP_STATUS
VgaSetCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize
    )

/*++

Routine Description:

    This routine verifies that the requested cursor height is within the
    bounds of the character cell. If valid, then it sets the new
    visibility and height of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorType - Pointer to the structure containing the cursor information.

    CursorTypeSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    UCHAR cursorLine;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (CursorAttributesSize < sizeof(VIDEO_CURSOR_ATTRIBUTES)) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check if the new values for the cursor type are in the valid range.
    //

    if ((CursorAttributes->Height >= HwDeviceExtension->FontPelRows) ||
        (CursorAttributes->Width > 31)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Store the cursor information in the device extension so we can use
    // them in a QUERY.
    //

    HwDeviceExtension->CursorTopScanLine = (UCHAR) CursorAttributes->Height;
    HwDeviceExtension->CursorBottomScanLine = (UCHAR) CursorAttributes->Width;
    HwDeviceExtension->CursorEnable = CursorAttributes->Enable;

    //
    // Address Cursor Start Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_COLOR,
                            IND_CURSOR_START);

    //
    // Set Cursor Start Register by writting to CRTCtl Data Register
    // Preserve the high three bits of this register.
    //
    // Only the Five low bits are used for the cursor height.
    // Bit 5 is cursor enable, bit 6 and 7 preserved.
    //

    cursorLine = (UCHAR) CursorAttributes->Height & 0x1F;

    cursorLine |= VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
        CRTC_DATA_PORT_COLOR) & 0xC0;

    if (!CursorAttributes->Enable) {

        cursorLine |= 0x20; // Flip cursor off bit

    }

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + CRTC_DATA_PORT_COLOR,
                            cursorLine);

    //
    // Address Cursor End Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_COLOR,
                            IND_CURSOR_END);

    //
    // Set Cursor End Register. Preserve the high three bits of this
    // register.
    //

    cursorLine =
        (CursorAttributes->Width < (USHORT)(HwDeviceExtension->FontPelRows - 1)) ?
        CursorAttributes->Width : (HwDeviceExtension->FontPelRows - 1);

    cursorLine &= 0x1f;

    cursorLine |= VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR) & 0xE0;

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + CRTC_DATA_PORT_COLOR,
                            cursorLine);

    return NO_ERROR;

} // end VgaSetCursorAttributes()

BOOLEAN
VgaIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine returns TRUE if a VGA is present. Determining whether a VGA
    is present is a two-step process. First, this routine walks bits through
    the Bit Mask register, to establish that there are readable indexed
    registers (EGAs normally don't have readable registers, and other adapters
    are unlikely to have indexed registers). This test is done first because
    it's a non-destructive EGA rejection test (correctly rejects EGAs, but
    doesn't potentially mess up the screen or the accessibility of display
    memory). Normally, this would be an adequate test, but some EGAs have
    readable registers, so next, we check for the existence of the Chain4 bit
    in the Memory Mode register; this bit doesn't exist in EGAs. It's
    conceivable that there are EGAs with readable registers and a register bit
    where Chain4 is stored, although I don't know of any; if a better test yet
    is needed, memory could be written to in Chain4 mode, and then examined
    plane by plane in non-Chain4 mode to make sure the Chain4 bit did what it's
    supposed to do. However, the current test should be adequate to eliminate
    just about all EGAs, and 100% of everything else.

    If this function fails to find a VGA, it attempts to undo any damage it
    may have inadvertently done while testing. The underlying assumption for
    the damage control is that if there's any non-VGA adapter at the tested
    ports, it's an EGA or an enhanced EGA, because: a) I don't know of any
    other adapters that use 3C4/5 or 3CE/F, and b), if there are other
    adapters, I certainly don't know how to restore their original states. So
    all error recovery is oriented toward putting an EGA back in a writable
    state, so that error messages are visible. The EGA's state on entry is
    assumed to be text mode, so the Memory Mode register is restored to the
    default state for text mode.

    If a VGA is found, the VGA is returned to its original state after
    testing is finished.

Arguments:

    None.

Return Value:

    TRUE if a VGA is present, FALSE if not.

--*/

{
    UCHAR originalGCAddr;
    UCHAR originalSCAddr;
    UCHAR originalBitMask;
    UCHAR originalReadMap;
    UCHAR originalMemoryMode;
    UCHAR testMask;
    BOOLEAN returnStatus;

    //
    // Remember the original state of the Graphics Controller Address register.
    //

    originalGCAddr = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT);

    //
    // Write the Read Map register with a known state so we can verify
    // that it isn't changed after we fool with the Bit Mask. This ensures
    // that we're dealing with indexed registers, since both the Read Map and
    // the Bit Mask are addressed at GRAPH_DATA_PORT.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    //
    // If we can't read back the Graphics Address register setting we just
    // performed, it's not readable and this isn't a VGA.
    //

    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
        GRAPH_ADDRESS_PORT) & GRAPH_ADDR_MASK) != IND_READ_MAP) {

        return FALSE;
    }

    //
    // Set the Read Map register to a known state.
    //

    originalReadMap = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, READ_MAP_TEST_SETTING);

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) != READ_MAP_TEST_SETTING) {

        //
        // The Read Map setting we just performed can't be read back; not a
        // VGA. Restore the default Read Map state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);

        return FALSE;
    }

    //
    // Remember the original setting of the Bit Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_BIT_MASK);
    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT) & GRAPH_ADDR_MASK) != IND_BIT_MASK) {

        //
        // The Graphics Address register setting we just made can't be read
        // back; not a VGA. Restore the default Read Map state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, IND_READ_MAP);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);

        return FALSE;
    }

    originalBitMask = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);

    //
    // Set up the initial test mask we'll write to and read from the Bit Mask.
    //

    testMask = 0xBB;

    do {

        //
        // Write the test mask to the Bit Mask.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, testMask);

        //
        // Make sure the Bit Mask remembered the value.
        //

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT) != testMask) {

            //
            // The Bit Mask is not properly writable and readable; not a VGA.
            // Restore the Bit Mask and Read Map to their default states.
            //

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT, BIT_MASK_DEFAULT);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_ADDRESS_PORT, IND_READ_MAP);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT, READ_MAP_DEFAULT);

            return FALSE;
        }

        //
        // Cycle the mask for next time.
        //

        testMask >>= 1;

    } while (testMask != 0);

    //
    // There's something readable at GRAPH_DATA_PORT; now switch back and
    // make sure that the Read Map register hasn't changed, to verify that
    // we're dealing with indexed registers.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);
    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT) != READ_MAP_TEST_SETTING) {

        //
        // The Read Map is not properly writable and readable; not a VGA.
        // Restore the Bit Mask and Read Map to their default states, in case
        // this is an EGA, so subsequent writes to the screen aren't garbled.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, IND_BIT_MASK);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, BIT_MASK_DEFAULT);

        return FALSE;
    }

    //
    // We've pretty surely verified the existence of the Bit Mask register.
    // Put the Graphics Controller back to the original state.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, originalReadMap);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_BIT_MASK);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, originalBitMask);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, originalGCAddr);

    //
    // Now, check for the existence of the Chain4 bit.
    //

    //
    // Remember the original states of the Sequencer Address and Memory Mode
    // registers.
    //

    originalSCAddr = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT) & SEQ_ADDR_MASK) != IND_MEMORY_MODE) {

        //
        // Couldn't read back the Sequencer Address register setting we just
        // performed.
        //

        return FALSE;
    }
    originalMemoryMode = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT);

    //
    // Toggle the Chain4 bit and read back the result. This must be done during
    // sync reset, since we're changing the chaining state.
    //

    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
             SEQ_ADDRESS_PORT),
             (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Toggle the Chain4 bit.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT, (UCHAR)(originalMemoryMode ^ CHAIN4_MASK));

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT) != (UCHAR) (originalMemoryMode ^ CHAIN4_MASK)) {

        //
        // Chain4 bit not there; not a VGA.
        // Set text mode default for Memory Mode register.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, MEMORY_MODE_TEXT_DEFAULT);
        //
        // End sync reset.
        //

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT),
                (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

        returnStatus = FALSE;

    } else {

        //
        // It's a VGA.
        //

        //
        // Restore the original Memory Mode setting.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, originalMemoryMode);

        //
        // End sync reset.
        //

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT),
                (USHORT)(IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

        //
        // Restore the original Sequencer Address setting.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT, originalSCAddr);

        returnStatus = TRUE;
    }

    return returnStatus;

} // VgaIsPresent()

BOOLEAN
ET4000IsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine returns TRUE if an ET4000 is present. It assumes that it's
    already been established that a VGA is present.  It performs the Tseng
    Labs-recommended ID test: we try to enable the extension registers, toggle
    AC16 bit 4, and modify CRTC33.  If all this works, then this is indeed an
    ET4000.

    If this function fails to find an ET4000, it attempts to undo any damage it
    may have inadvertently done while testing. Because unlocking the
    extensions involves touching the CGA/Mono Mode and Hercules Compatibility
    registers, we'll restore them to their default states in case there's
    one of those adapters or something emulating them at those addresses.

    If an ET4000 is found, the adapter is returned to its original state after
    testing is finished, except that extensions are left disabled.

Arguments:

    None.

Return Value:

    TRUE if an ET4000 is present, FALSE if not.

--*/

{
    //
    // SpeedSTAR message somewhere in first 4K of ROM (s/b around 0Axx)
    //

    #define MAX_ROM_SCAN 4096

    UCHAR originalACIndex;
    UCHAR originalAC16;
    UCHAR originalCRTCIndex;
    UCHAR originalCRTC33;
    UCHAR temp1, temp2;
    UCHAR videoEnable;
    ULONG CRTCAddressPort, CRTCDataPort;

    UCHAR   *pRomAddr;
    PHYSICAL_ADDRESS paRom = {0x000C0000,0x00000000};

    PWSTR pwszChip, pwszAdapterString;
    ULONG cbChip, cbAdapterString;

    //
    // Unlock the ET4000 extended registers.
    //

    UnlockET4000ExtendedRegs(HwDeviceExtension);

    //
    // Try to toggle AC16, bit 4.
    //

    ResetACToggle(HwDeviceExtension);    // set the AC toggle to the Index state

    //
    // Save the original state of the AC Index.
    //

    originalACIndex = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            ATT_ADDRESS_PORT);

    //
    // Remember whether video was enabled or not.
    //

    videoEnable = originalACIndex & VIDEO_ENABLE;

    //
    // Try to toggle AC16, bit 4.
    //

    ResetACToggle(HwDeviceExtension);    // set the AC toggle to the Index state

    //
    // Set the AC Index to 0x16.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +  ATT_ADDRESS_PORT,
                            (UCHAR)(videoEnable | 0x16));

    //
    // Save the original state of AC register 16.
    //

    originalAC16 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            ATT_DATA_READ_PORT);

    //
    // Write one possible AC16 bit 4 state and read it back.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            ATT_DATA_WRITE_PORT, (UCHAR) (originalAC16 ^ 0x10));
    temp1 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            ATT_DATA_READ_PORT);

    //
    // Write the other possible AC16 bit 4 state and read it back.  This also
    // restores the original state of AC16.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +  ATT_ADDRESS_PORT,
                            (UCHAR) (videoEnable | 0x16));
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            ATT_DATA_WRITE_PORT, originalAC16);
    temp2 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            ATT_DATA_READ_PORT);

    //
    // Restore the original AC Index.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            ATT_ADDRESS_PORT, originalACIndex);

    //
    // See if AC16 bit 4 toggled properly.
    //

    if ((temp2 != originalAC16) || (temp1 != (UCHAR) (originalAC16 ^ 0x10))) {

        //
        // Didn't toggle properly; not an ET4000.
        //

        //
        // Restore CGA/MDA and Hercules registers that were potentially written
        // to by the extensions enable sequence.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                HERCULES_COMPATIBILITY_PORT, HERCULES_COMPATIBILITY_DEFAULT);

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    MISC_OUTPUT_REG_READ_PORT) & 0x01) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    MODE_CONTROL_PORT_COLOR, MODE_CONTROL_PORT_COLOR_DEFAULT);
        } else {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    MODE_CONTROL_PORT_MONO, MODE_CONTROL_PORT_MONO_DEFAULT);
        }

        return FALSE;

    }

    //
    // At this point, it's either an ET3000 or an ET4000. See if CRTC33 is
    // read/writable; if it is, this is an ET4000.
    //

    //
    // Determine where the CRTC registers are addressed (color or mono).
    //

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                MISC_OUTPUT_REG_READ_PORT) & 0x01) {

        CRTCAddressPort = CRTC_ADDRESS_PORT_COLOR;
        CRTCDataPort = CRTC_DATA_PORT_COLOR;

    } else {

        CRTCAddressPort = CRTC_ADDRESS_PORT_MONO;
        CRTCDataPort = CRTC_DATA_PORT_MONO;

    }

    //
    // Save the original state of the CRTC Index.
    //

    originalCRTCIndex = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            CRTCAddressPort);

    //
    // Try to modify CRTC33.
    //

    //
    // Set the CRTC Index to 0x33.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +  CRTCAddressPort,
            0x33);

    //
    // Save the original state of CRTC register 33.
    //

    originalCRTC33 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            CRTCDataPort);

    //
    // Write out inverted CRTC33 state and read it back.
    //

    temp2 = ~originalCRTC33;

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + CRTCDataPort, temp2);
    temp1 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            CRTCDataPort);

    //
    // Restore the original CRTC33 state.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + CRTCDataPort,
            originalCRTC33);

    //
    // Restore the original CRTC Index.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + CRTCAddressPort,
                            originalCRTCIndex);

    //
    // Leave the Tseng extended registers locked.
    //

    LockET4000ExtendedRegs(HwDeviceExtension);

    //
    // See how CRTC33 changed.
    //

    // if all bits the same than must be W32, if just bits 0-3 then ET4000
    // otherwise must be an ET3000
    //

    if (temp1 == temp2) {

        UCHAR   jID;

        HwDeviceExtension->BoardID = TSENG4000W32;
        pwszAdapterString = L"TSENG ET4000W32 Compatible";
        cbAdapterString = sizeof(L"TSENG ET4000W32 Compatible");

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTCB_IO_PORT_INDEX,
                                IND_CRTCB_CHIP_ID);

        {
            UCHAR vfy;

            vfy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                         CRTCB_IO_PORT_INDEX);
            if (vfy != IND_CRTCB_CHIP_ID)
            {
                VideoDebugPrint((1,"Write to CRTCB_IO_PORT_INDEX didn't work\n"));
                VideoDebugPrint((1,"Wrote 0x%x, read back 0x%x\n", IND_CRTCB_CHIP_ID, vfy));
            }
        }

        jID = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                CRTCB_IO_PORT_DATA);

        jID = (jID >> 4) & 0xF;

        switch (jID) {

            case 0x00:  // W32 Rev Undefined

                pwszChip = L"W32";
                cbChip = sizeof(L"W32");
                HwDeviceExtension->ulChipID   = W32;
                HwDeviceExtension->ulRevLevel = REV_UNDEF;
                break;

            case 0x01:  // W32i Rev A

                pwszChip = L"W32i, rev A";
                cbChip = sizeof(L"W32i, rev A");
                HwDeviceExtension->ulChipID   = W32I;
                HwDeviceExtension->ulRevLevel = REV_A;
                break;

            case 0x02:  // W32p Rev A

                pwszChip = L"W32p, rev A";
                cbChip = sizeof(L"W32p, rev A");
                HwDeviceExtension->ulChipID   = W32P;
                HwDeviceExtension->ulRevLevel = REV_A;
                break;

            case 0x03:  // W32i Rev B

                pwszChip = L"W32i, rev B";
                cbChip = sizeof(L"W32i, rev B");
                HwDeviceExtension->ulChipID   = W32I;
                HwDeviceExtension->ulRevLevel = REV_B;
                break;

            case 0x05:  // W32p Rev B

                pwszChip = L"W32p, rev B";
                cbChip = sizeof(L"W32p, rev B");
                HwDeviceExtension->ulChipID   = W32P;
                HwDeviceExtension->ulRevLevel = REV_B;
                break;

            case 0x06:  // W32p Rev D

                pwszChip = L"W32p, rev D";
                cbChip = sizeof(L"W32p, rev D");
                HwDeviceExtension->ulChipID   = W32P;
                HwDeviceExtension->ulRevLevel = REV_D;
                break;

            case 0x07:  // W32p Rev C

                pwszChip = L"W32p, rev C";
                cbChip = sizeof(L"W32p, rev C");
                HwDeviceExtension->ulChipID   = W32P;
                HwDeviceExtension->ulRevLevel = REV_C;
                break;

            case 0x0b:  // W32i Rev C

                //
                // This puppy is rare (non production)
                //
                pwszChip = L"W32i, rev C";
                cbChip = sizeof(L"W32i, rev C");
                HwDeviceExtension->ulChipID   = W32I;
                HwDeviceExtension->ulRevLevel = REV_C;
                break;

            default:

                //
                // it must be a new rev of one of the W32 chips
                //
                pwszChip = L"W32 family, ID unknown";
                cbChip = sizeof(L"W32 family, ID unknown");

                //
                // NOTE: Assume any unidentified W32 must be a W32p or newer
                //

                HwDeviceExtension->ulChipID   = W32P;
                HwDeviceExtension->ulRevLevel = REV_C;

                VideoDebugPrint((1,"The video chip cannot be identified (0x%x)\n", jID));
                break;

        }

    } else {

        if ((temp1 & 0xf) == (temp2 & 0xf)) {

            HwDeviceExtension->BoardID = TSENG4000;
            pwszAdapterString = L"TSENG ET4000 Compatible";
            cbAdapterString = sizeof(L"TSENG ET4000 Compatible");
            HwDeviceExtension->ulChipID   = ET4000;
            HwDeviceExtension->ulRevLevel = REV_UNDEF;

            pwszChip = L"ET4000";
            cbChip = sizeof(L"ET4000");

        } else {

            //
            // Didn't change properly; not an ET4000.
            //

            HwDeviceExtension->BoardID = TSENG3000;
            HwDeviceExtension->ulChipID   = ET3000;
            HwDeviceExtension->ulRevLevel = REV_UNDEF;

            VideoDebugPrint((1, "ET4000 not found\n"));

            return FALSE;

        }
    }

    //
    // It *is* an ET4000 or a W32!
    //


    //
    // Map in the ROM address space at 0xc000:0
    //

    pRomAddr = VideoPortGetDeviceBase(HwDeviceExtension,
                                      paRom,
                                      MAX_ROM_SCAN,
                                      FALSE);

    if (pRomAddr) {       // Valid ROM address?

        //
        // Look for brand name signatures (from DIAMOND) in the ROM.
        //

        //
        // We will try to recognize a few boards.
        // make sure we are looking at a bios!
        //

        //if (*((PUSHORT) pRomAddr) == 0xAA55) {

        if (VideoPortReadRegisterUshort((PUSHORT)pRomAddr) == 0xAA55) {

            if (VideoPortScanRom(HwDeviceExtension,
                                 pRomAddr,
                                 MAX_ROM_SCAN,
                                 "Stealth 32 ")) {

                HwDeviceExtension->BoardID = STEALTH32;

                pwszAdapterString = L"Diamond Stealth 32";
                cbAdapterString = sizeof(L"Diamond Stealth 32");


            } else if (VideoPortScanRom(HwDeviceExtension,
                                 pRomAddr,
                                 MAX_ROM_SCAN,
                                 "SpeedSTAR 24 ")) {

                HwDeviceExtension->BoardID = SPEEDSTAR24;

                pwszAdapterString = L"Diamond SpeedSTAR 24";
                cbAdapterString = sizeof(L"Diamond SpeedSTAR 24");


            } else if (VideoPortScanRom(HwDeviceExtension,
                                         pRomAddr,
                                         MAX_ROM_SCAN,
                                         "SpeedSTAR Plus ")) {

                HwDeviceExtension->BoardID = SPEEDSTARPLUS;

                pwszAdapterString = L"Diamond SpeedSTAR Plus";
                cbAdapterString = sizeof(L"Diamond SpeedSTAR Plus");


            } else if (VideoPortScanRom(HwDeviceExtension,
                                        pRomAddr,
                                        MAX_ROM_SCAN,
                                        "SpeedSTAR ")) {

                HwDeviceExtension->BoardID = SPEEDSTAR;

                pwszAdapterString = L"Diamond SpeedSTAR";
                cbAdapterString = sizeof(L"Diamond SpeedSTAR");


            } else if (VideoPortScanRom(HwDeviceExtension,
                                        pRomAddr,
                                        MAX_ROM_SCAN,
                                        "ProDesigner IIs/EISA")) {

                HwDeviceExtension->BoardID = PRODESIGNERIISEISA;

                pwszAdapterString = L"Orchid ProDesigner IIs/EISA";
                cbAdapterString = sizeof(L"Orchid ProDesigner IIs/EISA");


            } else if (VideoPortScanRom(HwDeviceExtension,
                                        pRomAddr,
                                        MAX_ROM_SCAN,
                                        "ProDesigner IIs")) {

                HwDeviceExtension->BoardID = PRODESIGNERIIS;

                pwszAdapterString = L"Orchid ProDesigner IIs";
                cbAdapterString = sizeof(L"Orchid ProDesigner IIs");


            } else if (VideoPortScanRom(HwDeviceExtension,
                                        pRomAddr,
                                        MAX_ROM_SCAN,
                                        "ProDesigner II")) {

                HwDeviceExtension->BoardID = PRODESIGNER2;

                pwszAdapterString = L"Orchid ProDesigner II";
                cbAdapterString = sizeof(L"Orchid ProDesigner II");

            }

        }

        VideoPortFreeDeviceBase(HwDeviceExtension, pRomAddr);
    }

    //
    // Get the adapter memory size
    //

    HwDeviceExtension->AdapterMemorySize =
        ET4000GetMemorySize(HwDeviceExtension);


    //
    // Finally, just validate the list of modes.
    //

    VgaValidateModes(HwDeviceExtension);

    //
    // We now have a complete hardware description of the hardware.
    // Save the information to the registry so it can be used by
    // configuration programs - such as the display applet
    //

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.ChipType",
                                   pwszChip,
                                   cbChip);

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &HwDeviceExtension->AdapterMemorySize,
                                   sizeof(ULONG));

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.AdapterString",
                                   pwszAdapterString,
                                   cbAdapterString);

    return TRUE;

} // Et4000IsPresent()

ULONG
ET4000GetMemorySize(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine returns the amount of memory in bytes on the ET4000 based
    device.  It assumes that it has already been established that an ET4000
    is present.

Arguments:

    None.

Return Value:

    Device Memory Size in Bytes (256K, 512K, 1M, 2M, or 4M).

--*/

{
    UCHAR originalCRTCIndex;
    UCHAR VideoSystemConfig2;
    USHORT Width32, factor, SizeInfo;
    ULONG CRTCAddressPort, CRTCDataPort;
    ULONG Size;

    //
    // Unlock the ET4000 extended registers.
    //

    UnlockET4000ExtendedRegs(HwDeviceExtension);
    //
    // Determine where the CRTC registers are addressed (color or mono).
    //

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                MISC_OUTPUT_REG_READ_PORT) & 0x01) {

        CRTCAddressPort = CRTC_ADDRESS_PORT_COLOR;
        CRTCDataPort = CRTC_DATA_PORT_COLOR;

    } else {

        CRTCAddressPort = CRTC_ADDRESS_PORT_MONO;
        CRTCDataPort = CRTC_DATA_PORT_MONO;

    }

    //
    // Save the original state of the CRTC Index.
    //

    originalCRTCIndex = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            CRTCAddressPort);


    //
    // Set the CRTC Index to Video System Configuration Register 2
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +  CRTCAddressPort,
            IND_VID_SYS_CONFIG_2);

    //
    // Get the Config 2 reg
    //

    VideoSystemConfig2 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            CRTCDataPort);

    //
    // The ET4000/W32 and ET4000/AX have different register settings for
    // determining memory size.
    //

    if (HwDeviceExtension->ulChipID >= W32) {

         // It's a W32

         //
         // memory bus width determines whether to factor up by 2x
         //

         Width32 = (VideoSystemConfig2 & 1);

         //
         // Set up minimum memory size and determine multiplier factors
         // based on Dram type and bus width
         //

         Size = 0x80000;

         //
         // check DRAM type
         //

        if (VideoSystemConfig2 & 0x8) {  // either 256Kxn or 512Kxn

            // We can determine if the chip type is 256Kxn by checking if
            // mem location 0 is the same as memory location 512K (16 bit mem)
            // or 1M (32 bit) (256K chips don't have ROW_ADR<9>)

            if (ET4000w32With256KDrams(HwDeviceExtension,(USHORT) (8 << Width32)))

                factor = 1;
            else

                // 512K drams
                factor = 2;
        }
        else {

            // 1M drams

            factor = 4;
        }

        // calculate size based on factor and bus width

        Size *= (factor << Width32);
        VideoDebugPrint((1, "\nET4000GetMemorySize(w32): size(%08x),factor(%d),width32(%d)\n\n",Size,factor,Width32));

    } else {

        // ET4000 (not w32)
        // Assume 256K (ie. either 64K Drams or VideoConfig2 (bits 0-1) == 1)

        Size = 0x40000;

        if (VideoSystemConfig2 & 8) {  // Not 64K chips

            // bits 0-1 indicate memory size 3=>1M, 2=>512K, 1=>256K
            //                        (except 2 w/ VRAM might be 1M)
            SizeInfo = (VideoSystemConfig2 & 3);
            if (SizeInfo > 2)
                Size = 0x100000;
            else if (SizeInfo == 2) {
                // Check VRAM bit
                if (VideoSystemConfig2 & 0x80)
                    // Has VRAM - Check for 1 Meg
                    Size = (ET4000With1MegMemory(HwDeviceExtension))
                                   ? 0x100000 : 0x80000;
                else
                    Size = 0x80000;
            }
        }
        VideoDebugPrint((1, "ET4000GetMemorySize(non-w32): size(%08x)\n",Size));

    }  // ET4000

    //
    // Restore the original CRTC Index.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + CRTCAddressPort,
                            originalCRTCIndex);

    //
    // Leave the Tseng extended registers locked.
    //

    LockET4000ExtendedRegs(HwDeviceExtension);


    // Give'm what they asked for

    return Size;


} // Et4000GetMemorySize()

BOOLEAN
ET6000IsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_ACCESS_RANGE pAccessRange
    )

/*++

Routine Description:

    This routine returns TRUE if an ET6000 is present. It assumes that it's
    already been established that a VGA is present.  It will look at the PCI
    vendor and chip ID registers to identify the board.

Arguments:

    Input:  hwDeviceExtension

Return Value:

    TRUE if an ET6000 is present, FALSE if not.

--*/

{
    VP_STATUS status;
    UCHAR   originalCRTCIndex;
    UCHAR   videoEnable;
    ULONG   CRTCAddressPort, CRTCDataPort;
    UCHAR   temp;
    PWSTR   pwszChip, pwszAdapterString;
    ULONG   cbChip = 0, cbAdapterString = 0;

    VIDEO_ACCESS_RANGE PCIAccessRanges[3];

    ULONG   ulSlot     = 0;
    USHORT  usDeviceId = ET6000_DEVICE_ID;
    USHORT  usVendorId = ET6000_VENDOR_ID;
    ULONG   Address = 0;
    UCHAR   bits;
    BOOLEAN bIsET4000  = FALSE;
    PCI_COMMON_CONFIG ConfigData;   /* Configuration information about PCI device */

    if (VideoPortGetAccessRanges(HwDeviceExtension,
                                 0,
                                 NULL,
                                 3,
                                 PCIAccessRanges,
                                 &usVendorId,
                                 &usDeviceId,
                                 &ulSlot) != NO_ERROR)
    {
        VideoDebugPrint((1, "Did not find an ET6000 in any pci slot\n"));
        return FALSE;
    }
    else
    {
        VideoDebugPrint((1,"Found an ETX000 in pci slot %d\n", ulSlot));
        HwDeviceExtension->ulSlot = ulSlot;

        VideoPortGetBusData(HwDeviceExtension,
                            PCIConfiguration,
                            ulSlot,
                            (PVOID) &ConfigData,
                            0,
                            sizeof(ULONG));

        //
        //  Check for either 4000 or 6000!!!
        //

        if ((ConfigData.DeviceID == 0x3202 ) ||
            (ConfigData.DeviceID == 0x3206 ) ||
            (ConfigData.DeviceID == 0x3207))
            {
            VideoDebugPrint((1,"Found an ET4000 in pci slot %d\n", ulSlot));
            bIsET4000 = TRUE;

            HwDeviceExtension->BoardID = W32P;
            pwszChip = L"ET4000";
            cbChip = sizeof(L"ET4000");

            pwszAdapterString = L"TSENG ET4000 Compatible";
            cbAdapterString = sizeof(L"TSENG ET4000 Compatible");
            HwDeviceExtension->ulChipID   = ET4000;
            HwDeviceExtension->ulRevLevel = REV_UNDEF;
            }
        else if (ConfigData.DeviceID == ET6000_DEVICE_ID )
            {
            VideoDebugPrint((1,"Found an ET6000 in pci slot %d\n", ulSlot));
            pwszChip = L"ET6000";
            cbChip = sizeof(L"ET6000");
            pwszAdapterString = L"ET6000";
            cbAdapterString = sizeof(L"ET6000");
            HwDeviceExtension->ulChipID   = ET6000;
            HwDeviceExtension->ulRevLevel = REV_UNDEF;
            HwDeviceExtension->BoardID = TSENG6000;
            }
        else
            {
                ASSERT(FALSE);
            }
    }

    //
    //  Store the location of the linear frame buffer in the
    //  HwDeviceExtension.
    //
    //  The frame buffer is returned in location 0.  We do not
    //  need to store any of the other access ranges which
    //  may have been returned.
    //

    pAccessRange[LINEAR_FRAME_BUFFER].RangeStart = PCIAccessRanges[0].RangeStart;
    pAccessRange[LINEAR_FRAME_BUFFER].RangeLength = PCIAccessRanges[0].RangeLength;

    //
    //  Modify the entries in the RangeOffset array.  This array
    //  contains offsets within the frame buffer from which
    //  to map access ranges.
    //

    RangeOffsets[1][0].ulOffset += PCIAccessRanges[0].RangeStart.LowPart;
    RangeOffsets[1][1].ulOffset += PCIAccessRanges[0].RangeStart.LowPart;

    //
    //  Make sure the frame buffer access range is stored in the
    //  pci configuration space.
    //

    VideoPortGetBusData(HwDeviceExtension,
                        PCIConfiguration,
                        ulSlot,
                        (PVOID) &Address,
                        FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.BaseAddresses),
                        sizeof(ULONG));

    if (!bIsET4000 && (Address != PCIAccessRanges[0].RangeStart.LowPart))
    {
        VideoDebugPrint((1, "I really wish they we're equal, but\n"
                            "they're not, so make them equal!\n"));

        VideoPortSetBusData(HwDeviceExtension,
                            PCIConfiguration,
                            ulSlot,
                            (PVOID) &PCIAccessRanges[0].RangeStart.LowPart,
                            FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.BaseAddresses),
                            sizeof(ULONG));

    }

    //
    // We  now have a complete hardware description of the hardware.
    // Sa ve the information to the registry so it can be used by
    // co nfiguration programs - such as the display applet
    //
    if (cbChip)
    {
        VideoPortSetRegistryParameters(HwDeviceExtension,
                                       L"HardwareInformation.ChipType",
                                       pwszChip,
                                       cbChip);
    }

    if (cbAdapterString)
    {
        VideoPortSetRegistryParameters(HwDeviceExtension,
                                       L"HardwareInformation.AdapterString",
                                       pwszAdapterString,
                                       cbAdapterString);
    }

    return TRUE;

} // Et6000IsPresent()

BOOLEAN
ET6000GetMemorySize(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    VP_STATUS status;

    VideoDebugPrint((1,"ET6000GetMemorySize - enter\n"));

    //
    // Get the adapter memory size
    //

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    biosArguments.Eax = 0x1203;
    biosArguments.Ebx = 0x00F2;
    status = VideoPortInt10(HwDeviceExtension, &biosArguments);
    if (status != NO_ERROR)
    {
        VideoDebugPrint((1,"ET6000GetMemorySize - exit with error\n"));
        return FALSE;
    }

    HwDeviceExtension->AdapterMemorySize = (biosArguments.Ebx & 0x0000FFFF) * 64 * 1024;

    //
    // Finally, just validate the list of modes.
    //

    VgaValidateModes(HwDeviceExtension);

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &HwDeviceExtension->AdapterMemorySize,
                                   sizeof(ULONG));

    VideoDebugPrint((1,"ET6000GetMemorySize - exit\n"));
    return TRUE;
}



USHORT
GetIndexedRegisterPacked(
    PUCHAR AddressPort,
    UCHAR index
    )
{

// - Returns the value of the indexed register encoded with
// with index value in a form for easy restoration.
// The format of the return value is :
//  bits 0-7  contain the index
//  bits 8-15 contains the value at the index
//
//  *** Assumes the Data Port Address is always next port

        USHORT usData;

        VideoPortWritePortUchar(AddressPort++, index);
        usData = (USHORT) VideoPortReadPortUchar(AddressPort);
        return((USHORT) index + (usData << 8));
}


VOID
ET4000SaveAndSetLinear(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT SaveArray
    )
{
    ULONG i=0;

    //
    // Save the GRAPH and SEQ Index Registers
    //

    SaveArray[i++] = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT);

    SaveArray[i++] = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT);

    //
    // Save the Segment Select Registers
    //

    SaveArray[i++] = (USHORT) VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEGMENT_SELECT_PORT);
    SaveArray[i++] = (USHORT) VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEGMENT_SELECT_HIGH);  // W32 specific

    //
    // Save the Sequence registers and setup for linear mode
    //

    SaveArray[i++] = GetIndexedRegisterPacked(HwDeviceExtension->IOAddress+SEQ_ADDRESS_PORT,IND_MAP_MASK);

    //
    // Set to write to all planes
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
          SEQ_ADDRESS_PORT), (USHORT) (IND_MAP_MASK + (0x0F << 8)));

    SaveArray[i++] = GetIndexedRegisterPacked(HwDeviceExtension->IOAddress +
                                   SEQ_ADDRESS_PORT,IND_MEMORY_MODE);

    //
    // set to chain 4
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
          SEQ_ADDRESS_PORT), (USHORT) (IND_MEMORY_MODE + (0x0E << 8)));

    SaveArray[i++]=GetIndexedRegisterPacked(HwDeviceExtension->IOAddress +
                                   GRAPH_ADDRESS_PORT,IND_SET_RESET_ENABLE);

    //
    // set to no set/reset
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
          GRAPH_ADDRESS_PORT), (USHORT) (IND_SET_RESET_ENABLE + (0x0 << 8)));



    SaveArray[i++]=GetIndexedRegisterPacked(HwDeviceExtension->IOAddress +
                                   GRAPH_ADDRESS_PORT,IND_DATA_ROTATE);

    //
    // set to no rotate / move
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
          GRAPH_ADDRESS_PORT), (USHORT) (IND_DATA_ROTATE + (0x0 << 8)));

    SaveArray[i]=GetIndexedRegisterPacked(HwDeviceExtension->IOAddress +
                                     GRAPH_ADDRESS_PORT,IND_GRAPH_MODE);

    //
    // preserve ATT bits and set read/write mode, not odd/even
    // *** value is in upper bits of SaveArray[i]. See format
    // *** GetIndexedRegisterPacked call
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
          GRAPH_ADDRESS_PORT), (USHORT) (SaveArray[i++] & 0x60FF));

    SaveArray[i++]=GetIndexedRegisterPacked(HwDeviceExtension->IOAddress +
                                      GRAPH_ADDRESS_PORT,IND_GRAPH_MISC);

    //
    // set A000/graphics not odd/even
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
          GRAPH_ADDRESS_PORT), (USHORT) (IND_GRAPH_MISC + (0x05 << 8)));

    SaveArray[i]=GetIndexedRegisterPacked(HwDeviceExtension->IOAddress +
                                      GRAPH_ADDRESS_PORT,IND_BIT_MASK);

    //
    // set to all bits
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
          GRAPH_ADDRESS_PORT), (USHORT) (IND_BIT_MASK + (0xff << 8)));

} // ET4000SaveAndSetLinear


VOID
ET4000RestoreFromLinear(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT SaveArray
    )
{
    ULONG i=0;
    USHORT GraphAddr, SeqAddr;
    ULONG j;

    //
    // Get stored Graph and Seq Ports
    //

    SeqAddr = SaveArray[i++];
    GraphAddr = SaveArray[i++];

    //
    // Restore Saved Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEGMENT_SELECT_PORT,
                                (UCHAR) SaveArray[i++]);  // W32 specific


    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEGMENT_SELECT_HIGH,
                                (UCHAR) SaveArray[i++]);

    for (j=0; j<2; j++) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                 SEQ_ADDRESS_PORT), SaveArray[i++]);

    }

    for (j=0; j<5; j++) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                 GRAPH_ADDRESS_PORT), SaveArray[i++]);

    }

    //
    // Restore Graph and Seq index registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
        (UCHAR)SeqAddr);

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + GRAPH_ADDRESS_PORT,
        (UCHAR)GraphAddr);

} // ET4000RestoreFromLinear


VOID
vBankMap(
    LONG iBankRead,
    LONG iBankWrite,
    PVOID pvContext
    )
{
    PHW_DEVICE_EXTENSION HwDeviceExtension = pvContext;

    //
    // This function is not pageable because it is called by the memory manager
    // during some page fault handling.
    //

    #define SEG_READ_SHIFT_LO   4
    #define SEG_READ_SHIFT_HI   0
    #define SEG_WRITE_SHIFT_LO  0
    #define SEG_WRITE_SHIFT_HI  4

    #define SEG_READ_MASK_LO    0x0F
    #define SEG_READ_MASK_HI    0x30
    #define SEG_WRITE_MASK_LO   0x0F
    #define SEG_WRITE_MASK_HI   0x30

    UCHAR jSegLo, jSegHi;

    //
    // map the read segement to iBankRead
    // map the write segement to iBankWrite
    //

    jSegLo = (UCHAR)(((iBankRead & SEG_READ_MASK_LO) << SEG_READ_SHIFT_LO) |
                     ((iBankWrite & SEG_WRITE_MASK_LO) << SEG_WRITE_SHIFT_LO));

    jSegHi = (UCHAR)(((iBankRead & SEG_READ_MASK_HI) >> SEG_READ_SHIFT_HI) |
                     ((iBankWrite & SEG_WRITE_MASK_HI) >> SEG_WRITE_SHIFT_HI));

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEGMENT_SELECT_PORT, jSegLo);

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEGMENT_SELECT_HIGH, jSegHi);

    //VideoDebugPrint((1, "vBankMap(%d,%d)\n", iBankRead, iBankWrite));
} // vBankMap


BOOLEAN
ET4000With1MegMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    //
    // Check if 1 Meg of memory on ET4000 (not W32)
    //

    UCHAR save1;
    UCHAR temp1;
    PUCHAR memory = HwDeviceExtension->VideoMemoryAddress;
    ULONG j;
    BOOLEAN ret = TRUE;       // assume we'll find it

    USHORT SaveArray[12];     // Array to save values when setting linear mode

    //
    // Set to Linear Graphics Mode and save previous state
    //

    ET4000SaveAndSetLinear(HwDeviceExtension, SaveArray);

    //
    // Set to read/write segment 8 (linear) which == segment 2 (planar)
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress+SEGMENT_SELECT_PORT,
                                0x88);

    //
    // Save original memory value
    //

    save1 = VideoPortReadRegisterUchar(HwDeviceExtension->VideoMemoryAddress);

    //
    // Write values to display memory page and check if returned
    // for now try 0x55 and 0xAA
    //

    temp1 = 0x55;

    for (j=0; j<2 ;j++) {

        //
        // Write a value to memory
        //

        VideoPortWriteRegisterUchar(memory, temp1);

        //
        // Now read the value back
        // If not the same then not 1 MEG
        //

        if (VideoPortReadRegisterUchar(memory) != temp1) {

             ret = FALSE;
             break;

        }

        //
        // Force value to change.
        //

        temp1 ^= 0xff;

    }

    //
    // restore original memory value
    //

    VideoPortWriteRegisterUchar(memory, save1);

    //
    // get back to original mode
    //

    ET4000RestoreFromLinear(HwDeviceExtension, SaveArray);

    return ret;

} // ET4000w32With1Meg

BOOLEAN
ET4000w32With256KDrams(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT SegmentOffset
    )
{
    //
    // Check if memory location 0 is identical to the memory location
    // provided at the given SegmentOffset.  If so, than the w32 based
    // board must be using 256Kxn DRAM Chips.  This routine is w32 specific
    // and does not save the segment registers.  It is assumed that the
    // calling routine will save the regs.
    //

    UCHAR save1, save2;
    UCHAR temp1;
    PUCHAR flush, memory = HwDeviceExtension->VideoMemoryAddress;
    UCHAR SelectValLo, SelectValHi, CurSelLo, CurSelHi ;
    ULONG j;
    BOOLEAN ret = TRUE;       // assume we'll find 256K chips

    USHORT SaveArray[12];     // Memory to save original state

    //
    // Set to Linear Graphics Mode and save previous state
    //

    ET4000SaveAndSetLinear(HwDeviceExtension,SaveArray);

    //
    // Point to segment 0 R/W
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress+SEGMENT_SELECT_PORT,
                            0x0);

    //
    // high order bits now (w32 specific)
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress+SEGMENT_SELECT_HIGH,
                                0x0);

    //
    // save byte at seg 0
    //

    save1 = VideoPortReadRegisterUchar(memory);

    //
    // setup selector offset values for both read & write
    //

    SelectValLo = (SegmentOffset & 0x0f);
    SelectValLo += (SelectValLo << 4);
    SelectValHi = (SegmentOffset & 0x30);
    SelectValHi += (SelectValHi >> 4);

    //
    // Point to passed in segment R/W
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress+SEGMENT_SELECT_PORT,
                                SelectValLo);

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress+SEGMENT_SELECT_HIGH,
                                SelectValHi);

    //
    // Save original memory value
    //

    save2 = VideoPortReadRegisterUchar(memory);

    //
    // Write values to display memory and check if duplicated at
    // segment offset; for now try 0x55 and 0xAA
    //

    CurSelLo = CurSelHi = 0;
    temp1 = 0x55;

    for (j=0; j<2 ;j++) {

        //
        // Write a value to memory
        //

        VideoPortWriteRegisterUchar(memory, temp1);

        //
        // point to other segment
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEGMENT_SELECT_PORT, CurSelLo);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                  SEGMENT_SELECT_HIGH, CurSelHi);

        //
        // Flush the W32 cache before reading
        //

        for (flush=memory; flush <= memory+256; flush+=32)
           VideoPortReadRegisterUchar(flush);

        //
        // Now read the value back
        // If not the same then not 256Kxn chips
        //

        if (VideoPortReadRegisterUchar(memory) != temp1) {
             ret = FALSE;
             break;
        }

        //
        // switch to other segment
        //

        CurSelLo = (CurSelLo) ? 0 : SelectValLo;
        CurSelHi = (CurSelHi) ? 0 : SelectValHi;

        //
        // Force value to change.
        //

        temp1 ^= 0xff;

    }

    //
    // restore original memory values
    // Point to segment 0 R/W
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress+SEGMENT_SELECT_PORT,
                            0x0);

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress+SEGMENT_SELECT_HIGH,
                            0x0);

    //
    // restore byte at seg 0
    //

    VideoPortWriteRegisterUchar(memory, save1);

    //
    // Point to passed in segment R/W
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress+SEGMENT_SELECT_PORT,
                            SelectValLo);

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress+SEGMENT_SELECT_HIGH,
                            SelectValHi);

    //
    // Save original memory value
    //

    VideoPortWriteRegisterUchar(memory, save2);

    //
    // Restore it to previous mode
    //

    ET4000RestoreFromLinear(HwDeviceExtension,SaveArray);

    return ret;

} // ET4000With256KDrams


VP_STATUS
VgaSetPaletteReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_PALETTE_DATA PaletteBuffer,
    ULONG PaletteBufferSize
    )

/*++

Routine Description:

    This routine sets a specified portion of the EGA (not DAC) palette
    registers.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    PaletteBuffer - Pointer to the structure containing the palette data.

    PaletteBufferSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid palette size.

--*/

{
    USHORT i;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ((PaletteBufferSize) < (sizeof(VIDEO_PALETTE_DATA)) ||
        (PaletteBufferSize < (sizeof(VIDEO_PALETTE_DATA) +
                (sizeof(USHORT) * (PaletteBuffer->NumEntries -1)) ))) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (PaletteBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER ) ||
         (PaletteBuffer->NumEntries == 0) ||
         (PaletteBuffer->FirstEntry + PaletteBuffer->NumEntries >
             VIDEO_MAX_PALETTE_REGISTER + 1 ) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Reset ATC to index mode
    //

    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                           ATT_INITIALIZE_PORT_COLOR);

    //
    // Blast out our palette values.
    //

    for (i = 0; i < PaletteBuffer->NumEntries; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ATT_ADDRESS_PORT,
                                (UCHAR)(i+PaletteBuffer->FirstEntry));

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    ATT_DATA_WRITE_PORT,
                                (UCHAR)PaletteBuffer->Colors[i]);
    }

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ATT_ADDRESS_PORT,
                            VIDEO_ENABLE);

    return NO_ERROR;

} // end VgaSetPaletteReg()


VP_STATUS
VgaSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )

/*++

Routine Description:

    This routine sets a specified portion of the DAC color lookup table
    settings.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ClutBufferSize - Length of the input buffer supplied by the user.

    ClutBuffer - Pointer to the structure containing the color lookup table.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid clut size.

--*/

{
    USHORT i;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ( (ClutBufferSize < sizeof(VIDEO_CLUT) - sizeof(ULONG)) ||
         (ClutBufferSize < sizeof(VIDEO_CLUT) +
                     (sizeof(ULONG) * (ClutBuffer->NumEntries - 1)) ) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (ClutBuffer->NumEntries == 0) ||
         (ClutBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER) ||
         (ClutBuffer->FirstEntry + ClutBuffer->NumEntries >
             VIDEO_MAX_COLOR_REGISTER + 1) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  Set CLUT registers directly on the hardware
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_ADDRESS_WRITE_PORT,
                            (UCHAR) ClutBuffer->FirstEntry);

    for (i = 0; i < ClutBuffer->NumEntries; i++) {

        VideoPortWritePortBufferUchar((PUCHAR)HwDeviceExtension->IOAddress +
                                          DAC_DATA_REG_PORT,
                                      &(ClutBuffer->LookupTable[i].RgbArray.Red),
                                          0x03);

    }

    return NO_ERROR;

} // end VgaSetColorLookup()

VP_STATUS
VgaRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize
    )

/*++

Routine Description:

    Restores all registers and memory of the VGA.

    Note: HardwareState points to the actual buffer from which the state
    is to be restored. This buffer will always be big enough (we specified
    the required size at DriverEntry).

    Note: The offset in the hardware state header from which each general
    register is restored is the offset of the write address of that register
    from the base I/O address of the VGA.


Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    HardwareState - Pointer to a structure from which the saved state is to be
        restored (actually only info about and a pointer to the actual save
        buffer).

    HardwareStateSize - Length of the input buffer supplied by the user.
        (Actually only the size of the HardwareState structure, not the
        buffer it points to from which the state is actually restored. The
        pointed-to buffer is assumed to be big enough.)

Return Value:

    NO_ERROR - restore performed successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough to provide data

--*/

{
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;
    ULONG i;
    UCHAR dummy;
    PUCHAR pScreen;
    PUCHAR pucLatch;
    PULONG pulBuffer;
    PUCHAR port;
    PUCHAR portValue;
    PUCHAR portValueDAC;
    ULONG bIsColor;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ((HardwareStateSize < sizeof(VIDEO_HARDWARE_STATE)) ||
            (HardwareState->StateLength < VGA_TOTAL_STATE_SIZE)) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Point to the buffer where the restore data is actually stored.
    //

    hardwareStateHeader = HardwareState->StateHeader;

    //
    // Make sure the offset are in the structure ...
    //

    if ((hardwareStateHeader->BasicSequencerOffset + VGA_NUM_SEQUENCER_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicCrtContOffset + VGA_NUM_CRTC_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicGraphContOffset + VGA_NUM_GRAPH_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicAttribContOffset + VGA_NUM_ATTRIB_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicDacOffset + (3 * VGA_NUM_DAC_ENTRIES) >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicLatchesOffset + 4 >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedSequencerOffset + EXT_NUM_SEQUENCER_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedCrtContOffset + EXT_NUM_CRTC_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedGraphContOffset + EXT_NUM_GRAPH_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedAttribContOffset + EXT_NUM_ATTRIB_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedDacOffset + (4 * EXT_NUM_DAC_ENTRIES) >
            HardwareState->StateLength) ||

        //
        // Only check the validator state offset if there is unemulated data.
        //

        ((hardwareStateHeader->VGAStateFlags & VIDEO_STATE_UNEMULATED_VGA_STATE) &&
            (hardwareStateHeader->ExtendedValidatorStateOffset + VGA_VALIDATOR_AREA_SIZE >
            HardwareState->StateLength)) ||

        (hardwareStateHeader->ExtendedMiscDataOffset + VGA_MISC_DATA_AREA_OFFSET >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane1Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane2Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane3Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane4Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->DIBOffset +
            hardwareStateHeader->DIBBitsPerPixel / 8 *
            hardwareStateHeader->DIBXResolution *
            hardwareStateHeader->DIBYResolution  > HardwareState->StateLength) ||

        (hardwareStateHeader->DIBXlatOffset + hardwareStateHeader->DIBXlatLength >
            HardwareState->StateLength)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Turn off the screen to avoid flickering. The screen will turn back on
    // when we restore the DAC state at the end of this routine.
    //

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            MISC_OUTPUT_REG_READ_PORT) & 0x01) {
        port = INPUT_STATUS_1_COLOR + HwDeviceExtension->IOAddress;
    } else {
        port = INPUT_STATUS_1_MONO + HwDeviceExtension->IOAddress;
    }

    //
    // Set DAC register 0 to display black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);

    //
    // Set the DAC mask register to force DAC register 0 to display all the
    // time (this is the register we just set to display black). From now on,
    // nothing but black will show up on the screen.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT, 0);


    //
    // Restore the latches and the contents of display memory.
    //
    // Set up the VGA's hardware to allow us to copy to each plane in turn.
    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Turn off Chain mode and map display memory at A0000 for 64K.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MISC);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, (UCHAR) ((VideoPortReadPortUchar(
            HwDeviceExtension->IOAddress + GRAPH_DATA_PORT) & 0xF1) | 0x04));

    //
    // Turn off Chain4 mode and odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT) & 0xF3) | 0x04));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (END_SYNC_RESET_VALUE << 8)));

    //
    // Set the write mode to 0, the read mode to 0, and turn off odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xE4) | 0x00));

    //
    // Set the Bit Mask to 0xFF to allow all CPU bits through.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_BIT_MASK + (0xFF << 8)));

    //
    // Set the Data Rotation and Logical Function fields to 0 to allow CPU
    // data through unmodified.
    //

    VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_DATA_ROTATE + (0 << 8)));

    //
    // Set Set/Reset Enable to 0 to select CPU data for all planes.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_SET_RESET_ENABLE + (0 << 8)));

    //
    // Point the Sequencer Index to the Map Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
             SEQ_ADDRESS_PORT, IND_MAP_MASK);

    //
    // Restore the latches.
    //
    // Point to the saved data for the first latch.
    //

    pucLatch = ((PUCHAR) (hardwareStateHeader)) +
            hardwareStateHeader->BasicLatchesOffset;

    //
    // Point to first byte of display memory.
    //

    pScreen = (PUCHAR) HwDeviceExtension->VideoMemoryAddress;

    //
    // Write the contents to be restored to each of the four latches in turn.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Map Mask to select the plane we want to restore next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, (UCHAR)(1<<i));

        //
        // Write this plane's latch.
        //

        VideoPortWriteRegisterUchar(pScreen, *pucLatch++);

    }

    //
    // Read the latched data into the latches, and the latches are set.
    //

    dummy = VideoPortReadRegisterUchar(pScreen);


    //
    // Point to the offset of the saved data for the first plane.
    //

    pulBuffer = &(hardwareStateHeader->Plane1Offset);

    //
    // Restore each of the four planes in turn.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Map Mask to select the plane we want to restore next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, (UCHAR)(1<<i));

        //
        // Restore this plane from the buffer.
        //

        VideoPortMoveMemory((PUCHAR) HwDeviceExtension->VideoMemoryAddress,
                           ((PUCHAR) (hardwareStateHeader)) + *pulBuffer,
                           hardwareStateHeader->PlaneLength);

        pulBuffer++;

    }

    //
    // If we have some unemulated data, put it back into the buffer
    //

    if (hardwareStateHeader->VGAStateFlags & VIDEO_STATE_UNEMULATED_VGA_STATE) {

        if (!hardwareStateHeader->ExtendedValidatorStateOffset) {

            return ERROR_INVALID_PARAMETER;

        }

        //
        // Get the right offset in the struct and save all the data associated
        // with the trapped validator data.
        //

        VideoPortMoveMemory(&(HwDeviceExtension->TrappedValidatorCount),
                            ((PUCHAR) (hardwareStateHeader)) +
                                hardwareStateHeader->ExtendedValidatorStateOffset,
                            VGA_VALIDATOR_AREA_SIZE);

        //
        // Check to see if this is an appropriate access range.
        // We are trapping - so we must have the trapping access range enabled.
        //

        if (((HwDeviceExtension->CurrentVdmAccessRange != FullVgaValidatorAccessRange) ||
             (HwDeviceExtension->CurrentNumVdmAccessRanges != NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE)) &&
            ((HwDeviceExtension->CurrentVdmAccessRange != MinimalVgaValidatorAccessRange) ||
             (HwDeviceExtension->CurrentNumVdmAccessRanges != NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE))) {

            return ERROR_INVALID_PARAMETER;

        }

        VideoPortSetTrappedEmulatorPorts(HwDeviceExtension,
                                         HwDeviceExtension->CurrentNumVdmAccessRanges,
                                         HwDeviceExtension->CurrentVdmAccessRange);

    }

    //
    // Unlock et4000 extended regsiters so we can restore extended registers
    //

    UnlockET4000ExtendedRegs(HwDeviceExtension);


    //
    // Set the critical registers (clock and timing states) during sync reset.
    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (START_SYNC_RESET_VALUE << 8)));

    //
    // Restore the Miscellaneous Output register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            MISC_OUTPUT_REG_WRITE_PORT,
            (UCHAR) (hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_OFFSET] & 0xF7));

    //
    // Restore all Sequencer registers except the Sync Reset register, which
    // is always not in reset (except when we send out a batched sync reset
    // register set, but that can't be interrupted, so we know we're never in
    // sync reset at save/restore time).
    //

    portValue = ((PUCHAR) hardwareStateHeader) +
            hardwareStateHeader->BasicSequencerOffset + 1;

    for (i = 1; i < VGA_NUM_SEQUENCER_PORTS; i++) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT), (USHORT) (i + ((*portValue++) << 8)) );

    }


    //
    // Restore extended sequencer registers
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    if (hardwareStateHeader->ExtendedSequencerOffset) {

        portValue = ((PUCHAR) hardwareStateHeader) +
                          hardwareStateHeader->ExtendedSequencerOffset;

        for (i = ET4000_SEQUENCER_EXT_START; i <= ET4000_SEQUENCER_EXT_END; i++) {

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                         SEQ_ADDRESS_PORT),
                                     (USHORT) (i + ((*portValue++) << 8)) );

        }
    }

#endif
    //
    // Restore the Graphics Controller Miscellaneous register, which contains
    // the Chain bit.
    //

    portValue = ((PUCHAR) hardwareStateHeader) +
                hardwareStateHeader->BasicGraphContOffset + IND_GRAPH_MISC;

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT)(IND_GRAPH_MISC + (*portValue << 8)));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (END_SYNC_RESET_VALUE << 8)));

    //
    // Figure out if color/mono switchable registers are at 3BX or 3DX.
    // At the same time, save the state of the Miscellaneous Output register
    // which is read from 3CC but written at 3C2.
    //

    if (hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_OFFSET] & 0x01) {
        bIsColor = TRUE;
    } else {
        bIsColor = FALSE;
    }

    //
    // Restore the CRT Controller indexed registers.
    //
    // Unlock CRTC registers 0-7.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicCrtContOffset;

    if (bIsColor) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR), (USHORT) (IND_CRTC_PROTECT +
                (((*(portValue + IND_CRTC_PROTECT)) & 0x7F) << 8)));

    } else {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO), (USHORT) (IND_CRTC_PROTECT +
                (((*(portValue + IND_CRTC_PROTECT)) & 0x7F) << 8)));

    }



    //
    // Restore extended crtc registers.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    if (hardwareStateHeader->ExtendedCrtContOffset) {

        portValue = (PUCHAR) hardwareStateHeader +
                         hardwareStateHeader->ExtendedCrtContOffset;

        for (i = ET4000_CRTC_EXT_START; i <= ET4000_CRTC_EXT_END; i++) {

            if (bIsColor) {

                VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                             CRTC_ADDRESS_PORT_COLOR),
                                         (USHORT) (i + ((*portValue++) << 8)));

            } else {

                VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                             CRTC_ADDRESS_PORT_MONO),
                                         (USHORT) (i + ((*portValue++) << 8)));

            }
        }

        //
        // Second set of crtc registers
        //

        for (i = ET4000_CRTC_1_EXT_START; i <= ET4000_CRTC_1_EXT_END; i++) {

            if (bIsColor) {

                VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                             CRTC_ADDRESS_PORT_COLOR),
                                         (USHORT) (i + ((*portValue++) << 8)));

            } else {

                VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                             CRTC_ADDRESS_PORT_MONO),
                                         (USHORT) (i + ((*portValue++) << 8)));

            }
        }
    }

#endif

    //
    // Now restore the CRTC registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicCrtContOffset;

    for (i = 0; i < VGA_NUM_CRTC_PORTS; i++) {

        if (bIsColor) {

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_COLOR),
                    (USHORT) (i + ((*portValue++) << 8)));

        } else {

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_MONO),
                    (USHORT) (i + ((*portValue++) << 8)));

        }

    }


    //
    // Restore the Graphics Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicGraphContOffset;

    for (i = 0; i < VGA_NUM_GRAPH_CONT_PORTS; i++) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT), (USHORT) (i + ((*portValue++) << 8)));

    }


    //
    // Restore the Attribute Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicAttribContOffset;

    //
    // Reset the AC index/data toggle, then blast out all the register
    // settings.
    //

    if (bIsColor) {
        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                INPUT_STATUS_1_COLOR);
    } else {
        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                INPUT_STATUS_1_MONO);
    }

    for (i = 0; i < VGA_NUM_ATTRIB_CONT_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (UCHAR)i);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_WRITE_PORT, *portValue++);

    }

    //
    // Restore extended attribute controller registers.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    if (hardwareStateHeader->ExtendedAttribContOffset) {

        portValue = (PUCHAR) hardwareStateHeader +
                             hardwareStateHeader->ExtendedAttribContOffset;

        for (i = ET4000_ATTRIB_EXT_START; i <= ET4000_ATTRIB_EXT_END; i++) {

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                         ATT_ADDRESS_PORT),
                                     (USHORT) (i + ((*portValue++) << 8)));

        }
    }

#endif


    //
    // Lock et4000 extended regsiters back up
    //

    LockET4000ExtendedRegs(HwDeviceExtension);

    //
    // Restore DAC registers 1 through 255. We'll do register 0, the DAC Mask,
    // and the index registers later.
    // Set the DAC address port Index, then write out the DAC Data registers.
    // Each three reads get Red, Green, and Blue components for that register.
    //
    // Write them one at a time due to problems on local bus machines.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader +
                   hardwareStateHeader->BasicDacOffset + 3;

    for (i = 1; i < VGA_NUM_DAC_ENTRIES; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_ADDRESS_WRITE_PORT, (UCHAR)i);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT, *portValueDAC++);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT, *portValueDAC++);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT, *portValueDAC++);

    }

    //
    // Is this color or mono ?
    //

    if (bIsColor) {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_COLOR;
    } else {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_MONO;
    }

    //
    // Restore the Feature Control register.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                FEAT_CTRL_WRITE_PORT_COLOR,
                hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_COLOR]);

    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                FEAT_CTRL_WRITE_PORT_MONO,
                hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_MONO]);

    }


    //
    // Restore the Sequencer Index.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT,
            hardwareStateHeader->PortValue[SEQ_ADDRESS_OFFSET]);

    //
    // Restore the CRT Controller Index.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR,
                hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_COLOR]);

    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO,
                hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_MONO]);

    }


    //
    // Restore the Graphics Controller Index.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT,
            hardwareStateHeader->PortValue[GRAPH_ADDRESS_OFFSET]);


    //
    // Restore the Attribute Controller Index and index/data toggle state.
    //

    if (bIsColor) {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_COLOR;
    } else {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_MONO;
    }

    VideoPortReadPortUchar(port);  // reset the toggle to Index state

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            ATT_ADDRESS_PORT,  // restore the AC Index
            hardwareStateHeader->PortValue[ATT_ADDRESS_OFFSET]);

    //
    // If the toggle should be in Data state, we're all set. If it should be in
    // Index state, reset it to that condition.
    //

    if (hardwareStateHeader->AttribIndexDataState == 0) {

        //
        // Reset the toggle to Index state.
        //

        VideoPortReadPortUchar(port);

    }


    //
    // Restore DAC register 0 and the DAC Mask, to unblank the screen.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicDacOffset;

    //
    // Restore the DAC Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT,
            hardwareStateHeader->PortValue[DAC_PIXEL_MASK_OFFSET]);

    //
    // Restore DAC register 0.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);


    //
    // Restore the read/write state and the current index of the DAC.
    //
    // See whether the Read or Write Index was written to most recently.
    // (The upper nibble stored at DAC_STATE_PORT is the # of reads/writes
    // for the current index.)
    //

    if ((hardwareStateHeader->PortValue[DAC_STATE_OFFSET] & 0x0F) == 3) {

        //
        // The DAC Read Index was written to last. Restore the DAC by setting
        // up to read from the saved index - 1, because the way the Read
        // Index works is that it autoincrements after reading, so you actually
        // end up reading the data for the index you read at the DAC Write
        // Mask register - 1.
        //
        // Set the Read Index to the index we read, minus 1, accounting for
        // wrap from 255 back to 0. The DAC hardware immediately reads this
        // register into a temporary buffer, then adds 1 to the index.
        //

        if (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_OFFSET] == 0) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_READ_PORT, 255);

        } else {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_READ_PORT, (UCHAR)
                    (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_OFFSET] -
                    1));

        }

        //
        // Now read the hardware however many times are required to get to
        // the partial read state we saved.
        //

        for (i = hardwareStateHeader->PortValue[DAC_STATE_OFFSET] >> 4;
                i > 0; i--) {

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT);

        }

    } else {

        //
        // The DAC Write Index was written to last. Set the Write Index to the
        // index value we read out of the DAC. Then, if a partial write
        // (partway through an RGB triplet) was in place, write the partial
        // values, which we obtained by writing them to the current DAC
        // register. This DAC register will be wrong until the write is
        // completed, but at least the values will be right once the write is
        // finished, and most importantly we won't have messed up the sequence
        // of RGB writes (which can be as long as 768 in a row).
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_ADDRESS_WRITE_PORT,
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_OFFSET]);

        //
        // Now write to the hardware however many times are required to get to
        // the partial write state we saved (if any).
        //
        // Point to the saved value for the DAC register that was in the
        // process of being written to; we wrote the partial value out, so now
        // we can restore it.
        //

        portValueDAC = (PUCHAR) hardwareStateHeader +
                hardwareStateHeader->BasicDacOffset +
                (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_OFFSET] * 3);

        for (i = hardwareStateHeader->PortValue[DAC_STATE_OFFSET] >> 4;
                i > 0; i--) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT, *portValueDAC++);

        }

    }

    return NO_ERROR;

} // end VgaRestoreHardwareState()

VP_STATUS
VgaSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    Saves all registers and memory of the VGA.

    Note: HardwareState points to the actual buffer in which the state
    is saved. This buffer will always be big enough (we specified
    the required size at DriverEntry).

    Note: This routine leaves registers in any state it cares to, except
    that it will not mess with any of the CRT or Sequencer parameters that
    might make the monitor unhappy. It leaves the screen blanked by setting
    the DAC Mask and DAC register 0 to all zero values. The next video
    operation we expect after this is a mode set to take us back to Win32.

    Note: The offset in the hardware state header in which each general
    register is saved is the offset of the write address of that register from
    the base I/O address of the VGA.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    HardwareState - Pointer to a structure in which the saved state will be
        returned (actually only info about and a pointer to the actual save
        buffer).

    HardwareStateSize - Length of the output buffer supplied by the user.
        (Actually only the size of the HardwareState structure, not the
        buffer it points to where the state is actually saved. The pointed-
        to buffer is assumed to be big enough.)

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data returned in the buffer.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

--*/

{
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;
    PUCHAR port;
    PUCHAR pScreen;
    PUCHAR portValue;
    PUCHAR portValueDAC;
    PUCHAR bufferPointer;
    ULONG i;
    UCHAR dummy, originalACIndex, originalACData;
    UCHAR ucCRTC03;
    ULONG bIsColor;


    //
    // See if the buffer is big enough to hold the hardware state structure.
    // (This is only the HardwareState structure itself, not the buffer it
    // points to.)
    //

    if (HardwareStateSize < sizeof(VIDEO_HARDWARE_STATE) ) {

        *OutputSize = 0;  // nothing returned
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Amount of data we're going to return in the output buffer.
    // (The VIDEO_HARDWARE_STATE in the output buffer points to the actual
    // buffer in which the state is stored, which is assumed to be large
    // enough.)
    //

    *OutputSize = sizeof(VIDEO_HARDWARE_STATE);

    //
    // Indicate the size of the full state save info.
    //

    HardwareState->StateLength = VGA_TOTAL_STATE_SIZE;

    //
    // hardwareStateHeader is a structure of offsets at the start of the
    // actual save area that indicates the locations in which various VGA
    // register and memory components are saved.
    //

    hardwareStateHeader = HardwareState->StateHeader;

    //
    // Zero out the structure.
    //

    VideoPortZeroMemory(hardwareStateHeader, sizeof(VIDEO_HARDWARE_STATE_HEADER));

    //
    // Set the Length field, which is basically a version ID.
    //

    hardwareStateHeader->Length = sizeof(VIDEO_HARDWARE_STATE_HEADER);

    //
    // Set the basic register offsets properly.
    //

    hardwareStateHeader->BasicSequencerOffset = VGA_BASIC_SEQUENCER_OFFSET;
    hardwareStateHeader->BasicCrtContOffset = VGA_BASIC_CRTC_OFFSET;
    hardwareStateHeader->BasicGraphContOffset = VGA_BASIC_GRAPH_CONT_OFFSET;
    hardwareStateHeader->BasicAttribContOffset = VGA_BASIC_ATTRIB_CONT_OFFSET;
    hardwareStateHeader->BasicDacOffset = VGA_BASIC_DAC_OFFSET;
    hardwareStateHeader->BasicLatchesOffset = VGA_BASIC_LATCHES_OFFSET;

    //
    // Set the entended register offsets properly.
    //

    hardwareStateHeader->ExtendedSequencerOffset = VGA_EXT_SEQUENCER_OFFSET;
    hardwareStateHeader->ExtendedCrtContOffset = VGA_EXT_CRTC_OFFSET;
    hardwareStateHeader->ExtendedGraphContOffset = VGA_EXT_GRAPH_CONT_OFFSET;
    hardwareStateHeader->ExtendedAttribContOffset = VGA_EXT_ATTRIB_CONT_OFFSET;
    hardwareStateHeader->ExtendedDacOffset = VGA_EXT_DAC_OFFSET;

    //
    // Figure out if color/mono switchable registers are at 3BX or 3DX.
    // At the same time, save the state of the Miscellaneous Output register
    // which is read from 3CC but written at 3C2.
    //

    if ((hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_OFFSET] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    MISC_OUTPUT_REG_READ_PORT))
            & 0x01) {
        bIsColor = TRUE;
    } else {
        bIsColor = FALSE;
    }

    //
    // Force the video subsystem enable state to enabled.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            VIDEO_SUBSYSTEM_ENABLE_PORT, 1);

    //
    // Save the DAC state first, so we can set the DAC to blank the screen
    // so nothing after this shows up at all.
    //
    // Save the DAC Mask register.
    //

    hardwareStateHeader->PortValue[DAC_PIXEL_MASK_OFFSET] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_PIXEL_MASK_PORT);

    //
    // Save the DAC Index register. Note that there is actually only one DAC
    // Index register, which functions as either the Read Index or the Write
    // Index as needed.
    //

    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_OFFSET] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT);

    //
    // Save the DAC read/write state. We determine if the DAC has been written
    // to or read from at the current index 0, 1, or 2 times (the application
    // is in the middle of reading or writing a DAC register triplet if the
    // count is 1 or 2), and save enough info so we can restore things
    // properly. The only hole is if the application writes to the Write Index,
    // then reads from instead of writes to the Data register, or vice-versa,
    // or if they do a partial read write, then never finish it.
    // This is fairly ridiculous behavior, however, and anyway there's nothing
    // we can do about it.
    //

    hardwareStateHeader->PortValue[DAC_STATE_OFFSET] =
             VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_STATE_PORT);

    if (hardwareStateHeader->PortValue[DAC_STATE_OFFSET] == 3) {

        //
        // The DAC Read Index was written to last. Figure out how many reads
        // have been done from the current index. We'll restart this on restore
        // by setting the Read Index to the current index - 1 (the read index
        // is one greater than the index being read), then doing the proper
        // number of reads.
        //
        // Read the Data register once, and see if the index changes.
        //

        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                DAC_DATA_REG_PORT);

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT) !=
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_OFFSET]) {

            //
            // The DAC Index changed, so two reads had already been done from
            // the current index. Store the count "2" in the upper nibble of
            // the read/write state field.
            //

            hardwareStateHeader->PortValue[DAC_STATE_OFFSET] |= 0x20;

        } else {

            //
            // Read the Data register again, and see if the index changes.
            //

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT);

            if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        DAC_ADDRESS_WRITE_PORT) !=
                    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_OFFSET]) {

                //
                // The DAC Index changed, so one read had already been done
                // from the current index. Store the count "1" in the upper
                // nibble of the read/write state field.
                //

                hardwareStateHeader->PortValue[DAC_STATE_OFFSET] |= 0x10;
            }

            //
            // If neither 2 nor 1 reads had been done from the current index,
            // then 0 reads were done, and we're all set, since the upper
            // nibble of the read/write state field is already 0.
            //

        }

    } else {

        //
        // The DAC Write Index was written to last. Figure out how many writes
        // have been done to the current index. We'll restart this on restore
        // by setting the Write Index to the proper index, then doing the
        // proper number of writes. When we do the DAC register save, we'll
        // read out the value that gets written (if there was a partial write
        // in progress), so we can restore the proper data later. This will
        // cause this current DAC location to be briefly wrong in the 1- and
        // 2-bytes-written case (until the app finishes the write), but that's
        // better than having the wrong DAC values written for good.
        //
        // Write the Data register once, and see if the index changes.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_DATA_REG_PORT, 0);

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT) !=
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_OFFSET]) {

            //
            // The DAC Index changed, so two writes had already been done to
            // the current index. Store the count "2" in the upper nibble of
            // the read/write state field.
            //

            hardwareStateHeader->PortValue[DAC_STATE_OFFSET] |= 0x20;

        } else {

            //
            // Write the Data register again, and see if the index changes.
            //

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT, 0);

            if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        DAC_ADDRESS_WRITE_PORT) !=
                    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_OFFSET]) {

                //
                // The DAC Index changed, so one write had already been done
                // to the current index. Store the count "1" in the upper
                // nibble of the read/write state field.
                //

                hardwareStateHeader->PortValue[DAC_STATE_OFFSET] |= 0x10;
            }

            //
            // If neither 2 nor 1 writes had been done to the current index,
            // then 0 writes were done, and we're all set.
            //

        }

    }


    //
    // Now, read out the 256 18-bit DAC palette registers (256 RGB triplets),
    // and blank the screen.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader + VGA_BASIC_DAC_OFFSET;

    //
    // Read out DAC register 0, so we can set it to black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                            DAC_ADDRESS_READ_PORT, 0);

    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                             DAC_DATA_REG_PORT);

    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                             DAC_DATA_REG_PORT);

    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                             DAC_DATA_REG_PORT);

    //
    // Set DAC register 0 to display black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);

    //
    // Set the DAC mask register to force DAC register 0 to display all the
    // time (this is the register we just set to display black). From now on,
    // nothing but black will show up on the screen.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT, 0);

    //
    // The next line is a bug fix for the w32p
    //

    ResetACToggle(HwDeviceExtension);    // set the AC toggle to the Index state

    //
    // Read out the Attribute Controller Index state, and deduce the Index/Data
    // toggle state at the same time.
    //
    // Save the state of the Attribute Controller, both Index and Data,
    // so we can test in which state the toggle currently is.
    //

    originalACIndex = hardwareStateHeader->PortValue[ATT_ADDRESS_OFFSET] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    ATT_ADDRESS_PORT);
    originalACData = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            ATT_DATA_READ_PORT);

    //
    // The next line is a bug fix for the w32p
    //

    ResetACToggle(HwDeviceExtension);    // set the AC toggle to the Index state

    //
    // Sequencer Index.
    //

    hardwareStateHeader->PortValue[SEQ_ADDRESS_OFFSET] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    SEQ_ADDRESS_PORT);

    //
    // Begin sync reset, just in case this is an SVGA and the currently
    // indexed Attribute Controller register controls clocking stuff (a
    // normal VGA won't require this).
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Now, write a different Index setting to the Attribute Controller, and
    // see if the Index changes.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            ATT_ADDRESS_PORT, (UCHAR) (originalACIndex ^ 0x10));

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT) == originalACIndex) {

        //
        // The Index didn't change, so the toggle was in the Data state.
        //

        hardwareStateHeader->AttribIndexDataState = 1;

        //
        // Restore the original Data state; we just corrupted it, and we need
        // to read it out later; also, it may glitch the screen if not
        // corrected. The toggle is already in the Index state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, originalACIndex);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_WRITE_PORT, originalACData);

    } else {

        //
        // The Index did change, so the toggle was in the Index state.
        // No need to restore anything, because the Data register didn't
        // change, and we've already read out the Index register.
        //

        hardwareStateHeader->AttribIndexDataState = 0;

    }

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));


    //
    // Save the rest of the DAC registers.
    // Set the DAC address port Index, then read out the DAC Data registers.
    // Each three reads get Red, Green, and Blue components for that register.
    //
    // Read them one at a time due to problems on local bus machines.
    //

    for (i = 1; i < VGA_NUM_DAC_ENTRIES; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_ADDRESS_READ_PORT, (UCHAR)i);

        *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                 DAC_DATA_REG_PORT);

        *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                 DAC_DATA_REG_PORT);

        *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                 DAC_DATA_REG_PORT);

    }

    //
    // Is this color or mono ?
    //

    if (bIsColor) {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_COLOR;
    } else {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_MONO;
    }

    //
    // The Feature Control register is read from 3CA but written at 3BA/3DA.
    //

    if (bIsColor) {

        hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_COLOR] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        FEAT_CTRL_READ_PORT);

    } else {

        hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_MONO] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        FEAT_CTRL_READ_PORT);

    }



    //
    // CRT Controller Index.
    //

    if (bIsColor) {

        hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_COLOR] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_ADDRESS_PORT_COLOR);

    } else {

        hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_MONO] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_ADDRESS_PORT_MONO);

    }


    //
    // Graphics Controller Index.
    //

    hardwareStateHeader->PortValue[GRAPH_ADDRESS_OFFSET] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_ADDRESS_PORT);


    //
    // Sequencer indexed registers.
    //

    portValue = ((PUCHAR) hardwareStateHeader) + VGA_BASIC_SEQUENCER_OFFSET;

    for (i = 0; i < VGA_NUM_SEQUENCER_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT, (UCHAR)i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT);

    }

    //
    // Save extended sequencer registers.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    portValue = ((PUCHAR) hardwareStateHeader) + VGA_EXT_SEQUENCER_OFFSET;

    for (i = ET4000_SEQUENCER_EXT_START; i <= ET4000_SEQUENCER_EXT_END; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, (UCHAR)i);

        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                              SEQ_DATA_PORT);

    }

#endif

    //
    // CRT Controller indexed registers.
    //

    //
    // Remember the state of CRTC register 3, then force bit 7
    // to 1 so we will read back the Vertical Retrace start and
    // end registers rather than the light pen info.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR, 3);
        ucCRTC03 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_DATA_PORT_COLOR);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_DATA_PORT_COLOR, (UCHAR) (ucCRTC03 | 0x80));
    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO, 3);
        ucCRTC03 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_DATA_PORT_MONO);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_DATA_PORT_MONO, (UCHAR) (ucCRTC03 | 0x80));
    }

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_CRTC_OFFSET;

    for (i = 0; i < VGA_NUM_CRTC_PORTS; i++) {

        if (bIsColor) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_COLOR, (UCHAR)i);
            *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            CRTC_DATA_PORT_COLOR);
        } else {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_MONO, (UCHAR)i);
            *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            CRTC_DATA_PORT_MONO);
        }

    }


    //
    // Save extended crtc registers.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    portValue = (PUCHAR) hardwareStateHeader + VGA_EXT_CRTC_OFFSET;

    for (i = ET4000_CRTC_EXT_START; i <= ET4000_CRTC_EXT_END; i++) {

        if (bIsColor) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    CRTC_ADDRESS_PORT_COLOR, (UCHAR)i);

            *portValue++ =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                       CRTC_DATA_PORT_COLOR);

        } else {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    CRTC_ADDRESS_PORT_MONO, (UCHAR)i);

            *portValue++ =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                       CRTC_DATA_PORT_MONO);
        }
    }

    //
    // Save second set of crtc registers.
    //

    for (i = ET4000_CRTC_1_EXT_START; i <= ET4000_CRTC_1_EXT_END; i++) {

        if (bIsColor) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    CRTC_ADDRESS_PORT_COLOR, (UCHAR)i);

            *portValue++ =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                       CRTC_DATA_PORT_COLOR);

        } else {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    CRTC_ADDRESS_PORT_MONO, (UCHAR)i);

            *portValue++ =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                       CRTC_DATA_PORT_MONO);
        }
    }

#endif


    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_CRTC_OFFSET;
    portValue[3] = ucCRTC03;


    //
    // Graphics Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_GRAPH_CONT_OFFSET;

    for (i = 0; i < VGA_NUM_GRAPH_CONT_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, (UCHAR)i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT);

    }


    //
    // Attribute Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_ATTRIB_CONT_OFFSET;

    //
    // For each indexed AC register, reset the flip-flop for reading the
    // attribute register, then write the desired index to the AC Index,
    // then read the value of the indexed register from the AC Data register.
    //

    for (i = 0; i < VGA_NUM_ATTRIB_CONT_PORTS; i++) {

        if (bIsColor) {
            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_COLOR);
        } else {
            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_MONO);
        }

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (UCHAR)i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_READ_PORT);

    }

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    //
    // Extended Attribute Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader + VGA_EXT_ATTRIB_CONT_OFFSET;

    //
    // For each indexed AC register, reset the flip-flop for reading the
    // attribute register, then write the desired index to the AC Index,
    // then read the value of the indexed register from the AC Data register.
    //

    for (i = ET4000_ATTRIB_EXT_START; i <= ET4000_ATTRIB_EXT_END; i++) {

        if (bIsColor) {
            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_COLOR);
        } else {
            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_MONO);
        }

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (UCHAR)i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_READ_PORT);

    }

#endif

    //
    // Save the latches. This destroys one byte of display memory in each
    // plane, which is unfortunate but unavoidable. Chips that provide
    // a way to read back the latches can avoid this problem.
    //
    // Set up the VGA's hardware so we can write the latches, then read them
    // back.
    //

    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Set the Miscellaneous register to make sure we can access video RAM.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            MISC_OUTPUT_REG_WRITE_PORT, (UCHAR)(
            hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_OFFSET] |
            0x02));

    //
    // Turn off Chain mode and map display memory at A0000 for 64K.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MISC);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xF1) | 0x04));

    //
    // Turn off Chain4 mode and odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT) & 0xF3) | 0x04));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

    //
    // Set the Map Mask to write to all planes.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_MAP_MASK + (0x0F << 8)));

    //
    // Set the write mode to 0, the read mode to 0, and turn off odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xE4) | 0x01));

    //
    // Point to the last byte of display memory.
    //

    pScreen = (PUCHAR) HwDeviceExtension->VideoMemoryAddress +
            VGA_PLANE_SIZE - 1;

    //
    // Write the latches to the last byte of display memory.
    //

    VideoPortWriteRegisterUchar(pScreen, 0);

    //
    // Cycle through the four planes, reading the latch data from each plane.
    //

    //
    // Point the Graphics Controller Index to the Read Map register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_LATCHES_OFFSET;

    for (i=0; i<4; i++) {

        //
        // Set the Read Map for the current plane.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, (UCHAR)i);

        //
        // Read the latched data we've written to memory.
        //

        *portValue++ = VideoPortReadRegisterUchar(pScreen);

    }

    //
    // Set the VDM flags
    // We are a standard VGA, and then check if we have unemulated state.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    hardwareStateHeader->VGAStateFlags |= VIDEO_STATE_NON_STANDARD_VGA;

#endif

    if (HwDeviceExtension->TrappedValidatorCount) {

        hardwareStateHeader->VGAStateFlags |= VIDEO_STATE_UNEMULATED_VGA_STATE;

        //
        // Save the VDM Emulator data
        // No need to save the state of the seuencer port register for our
        // emulated data since it may change when we come back. It will be
        // recomputed.
        //

        hardwareStateHeader->ExtendedValidatorStateOffset = VGA_VALIDATOR_OFFSET;

        VideoPortMoveMemory(((PUCHAR) (hardwareStateHeader)) +
                                hardwareStateHeader->ExtendedValidatorStateOffset,
                            &(HwDeviceExtension->TrappedValidatorCount),
                            VGA_VALIDATOR_AREA_SIZE);

    } else {

        hardwareStateHeader->ExtendedValidatorStateOffset = 0;

    }

    //
    // ET4000 feature:
    //
    // We also set the PACKED_CHAIN4_MODE for this adapter since it's memory
    // does not follow the vga standard in 256 color mode (mode 13)
    //

    hardwareStateHeader->VGAStateFlags |= VIDEO_STATE_PACKED_CHAIN4_MODE;

    //
    // Set the size of each plane.
    //

    hardwareStateHeader->PlaneLength = VGA_PLANE_SIZE;

    //
    // Store all the offsets for the planes in the structure.
    //

    hardwareStateHeader->Plane1Offset = VGA_PLANE_0_OFFSET;
    hardwareStateHeader->Plane2Offset = VGA_PLANE_1_OFFSET;
    hardwareStateHeader->Plane3Offset = VGA_PLANE_2_OFFSET;
    hardwareStateHeader->Plane4Offset = VGA_PLANE_3_OFFSET;

    //
    // Now copy the contents of video VRAM into the buffer.
    //
    // The VGA hardware is already set up so that video memory is readable;
    // we already turned off Chain mode, mapped in at A0000, turned off Chain4,
    // turned off odd/even, and set read mode 0 when we saved the latches.
    //
    // Point the Graphics Controller Index to the Read Map register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    //
    // Point to the save area for the first plane.
    //

    bufferPointer = ((PUCHAR) (hardwareStateHeader)) +
                     hardwareStateHeader->Plane1Offset;

    //
    // Save the four planes consecutively.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Read Map to select the plane we want to save next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, (UCHAR)i);

        //
        // Copy this plane into the buffer.
        //

        VideoPortMoveMemory(bufferPointer,
                           (PUCHAR) HwDeviceExtension->VideoMemoryAddress,
                           VGA_PLANE_SIZE);
        //
        // Point to the next plane's save area.
        //

        bufferPointer += VGA_PLANE_SIZE;
    }

    return NO_ERROR;

} // end VgaSaveHardwareState()


#if defined(i386)

VP_STATUS
VgaGetBankSelectCode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_BANK_SELECT BankSelect,
    ULONG BankSelectSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    Returns information needed in order for caller to implement bank
         management.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BankSelect - Pointer to a VIDEO_BANK_SELECT structure in which the bank
             select data will be returned (output buffer).

    BankSelectSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a variable in which to return the actual size of
        the data returned in the output buffer.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_MORE_DATA - output buffer not large enough to hold all info (but
        Size is returned, so caller can tell how large a buffer to allocate)

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

    ERROR_INVALID_PARAMETER - invalid video mode selection

--*/

{
    ULONG codeSize = ((ULONG)&BankSwitchEnd) - ((ULONG)&BankSwitchStart);
    PUCHAR pCode = (PUCHAR)BankSelect + sizeof(VIDEO_BANK_SELECT);
    PVIDEOMODE pMode;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // The minimum passed buffer size is a VIDEO_BANK_SELECT
    // structure, so that we can return the required size; we can't do
    // anything if we don't have at least that much buffer.
    //

    if (BankSelectSize < sizeof(VIDEO_BANK_SELECT)) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Size of banking info.
    //

    BankSelect->Length = sizeof(VIDEO_BANK_SELECT);
    BankSelect->Size = sizeof(VIDEO_BANK_SELECT) + codeSize;

    //
    // There's room enough for everything, so fill in all fields in
    // VIDEO_BANK_SELECT. (All fields are always returned; the caller can
    // just choose to ignore them, based on BankingFlags and BankingType.)
    //

    pMode = HwDeviceExtension->CurrentMode;

    BankSelect->BitmapWidthInBytes = pMode->wbytes;
    BankSelect->BitmapSize = pMode->sbytes;
    BankSelect->Granularity = 0x10000;  // 64K bank start adjustment normally

    //
    // Set whether any banking is actually supported in this mode.
    //

    switch(pMode->banktype) {
        case NoBanking:
        case MemMgrBanking:

            BankSelect->BankingType = VideoNotBanked;
            BankSelect->PlanarHCBankingType = VideoNotBanked;
            BankSelect->BankingFlags = 0;

            break;

        case NormalBanking:

            //
            // The ET4000 supports independent 64K read and write banks.
            //

            BankSelect->BankingType = VideoBanked1R1W;
            BankSelect->PlanarHCBankingType = VideoNotBanked;
            BankSelect->BankingFlags = 0;

            break;

        case PlanarHCBanking:

            //
            // The ET4000 supports independent 64K read and write banks
            // in both non-planar and planar modes when using high-color.
            //

            BankSelect->BankingType = VideoBanked1R1W;
            BankSelect->PlanarHCBankingType = VideoBanked1R1W;
            BankSelect->BankingFlags = PLANAR_HC;

            // 64K bank start adjustment in planar HC mode as well

            BankSelect->PlanarHCGranularity = 0x10000;

            BankSelect->PlanarHCBankCodeOffset = &PlanarHCBankSwitchStart -
                                                 &BankSwitchStart +
                                                 sizeof(VIDEO_BANK_SELECT);
            BankSelect->PlanarHCEnableCodeOffset = &EnablePlanarHCStart -
                                                   &BankSwitchStart +
                                                   sizeof(VIDEO_BANK_SELECT);
            BankSelect->PlanarHCDisableCodeOffset = &DisablePlanarHCStart -
                                                    &BankSwitchStart +
                                                    sizeof(VIDEO_BANK_SELECT);

            break;
    }

    //
    // If the buffer isn't big enough to hold all info, just return
    // ERROR_MORE_DATA; Size is already set.
    //

    if (BankSelectSize < BankSelect->Size ) {

        //
        // We're returning only the VIDEO_BANK_SELECT structure.
        //

        *OutputSize = sizeof(VIDEO_BANK_SELECT);
        return ERROR_MORE_DATA;
    }

    //
    // Set the bank switch code's location in the returned buffer.
    //

    BankSelect->CodeOffset = sizeof(VIDEO_BANK_SELECT);

    //
    // Copy all banking code into the output buffer.
    //

    VideoPortMoveMemory(pCode,
                        &BankSwitchStart,
                        codeSize);

    //
    // Number of bytes we're returning is the full banking info size.
    //

    *OutputSize = BankSelect->Size;

    return NO_ERROR;

} // end VgaGetBankSelectCode()
#endif


VP_STATUS
VgaValidatorUcharEntry(
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    )

/*++

Routine Description:

    Entry point into the validator for byte I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;

    if (hwDeviceExtension->TrappedValidatorCount) {

        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                *Data &= 0xF7;

            }

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_UCHAR_ACCESS;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;

            hwDeviceExtension->TrappedValidatorCount++;

            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //

            if ( (Port == SEQ_DATA_PORT) &&
                 ((*Data & END_SYNC_RESET_VALUE) == END_SYNC_RESET_VALUE) &&
                 (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {

                endEmulation = 1;

            } else {

                //
                // If we are accessing the seq address port, keep track of the
                // data value
                //

                if (Port == SEQ_ADDRESS_PORT) {

                    hwDeviceExtension->SequencerAddressValue = *Data;

                }

                //
                // If the buffer is not full, then just return right away.
                //

                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {

                    return NO_ERROR;

                }

                endEmulation = 0;
            }
        }

        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));

        hwDeviceExtension->TrappedValidatorCount++;

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);

        //
        // Write back the real value of the sequencer address port.
        //

        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT,
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);

        //
        // If we are in a READ path, read the data
        //

        if (AccessMode & EMULATOR_READ_ACCESS) {

            *Data = VideoPortReadPortUchar(hwDeviceExtension->IOAddress + Port);

            endEmulation = 0;

        }

        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //

        if (endEmulation) {

            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE,
                                             MinimalVgaValidatorAccessRange);

            return NO_ERROR;

        }

        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //

        hwDeviceExtension->TrappedValidatorCount = 1;

        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));

    } else {

        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                                  SEQ_ADDRESS_PORT);

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + Port,
                                         (UCHAR) (*Data & 0xF7) );

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                            SEQ_ADDRESS_PORT,
                                        temp);

                return NO_ERROR;

            }

            //
            // If we get an access to the sequencer register, start trapping.
            //

            if ( (Port == SEQ_DATA_PORT) &&
                 ((*Data & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 (VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                         SEQ_ADDRESS_PORT) == IND_SYNC_RESET)) {

                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                                 NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE,
                                                 FullVgaValidatorAccessRange);

                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_UCHAR_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;

                //
                // Start keeping track of the state of the sequencer port.
                //

                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;

            } else {

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + Port,
                                        *Data);

            }

        } else {

            *Data = VideoPortReadPortUchar(hwDeviceExtension->IOAddress + Port);

        }
    }

    return NO_ERROR;

} // end VgaValidatorUcharEntry()

VP_STATUS
VgaValidatorUshortEntry(
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    )

/*++

Routine Description:

    Entry point into the validator for word I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;

    if (hwDeviceExtension->TrappedValidatorCount) {

        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                *Data &= 0xFFF7;

            }

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;

            hwDeviceExtension->TrappedValidatorCount++;

            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //

            if (Port == SEQ_ADDRESS_PORT) {

                //
                // If we are accessing the seq address port, keep track of its
                // value
                //

                hwDeviceExtension->SequencerAddressValue = (*Data & 0xFF);

            }

            if ((Port == SEQ_ADDRESS_PORT) &&
                ( ((*Data >> 8) & END_SYNC_RESET_VALUE) ==
                   END_SYNC_RESET_VALUE) &&
                (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {

                endEmulation = 1;

            } else {

                //
                // If the buffer is not full, then just return right away.
                //

                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {

                    return NO_ERROR;

                }

                endEmulation = 0;
            }
        }

        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));

        hwDeviceExtension->TrappedValidatorCount++;

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);

        //
        // Write back the real value of the sequencer address port.
        //

        VideoPortWritePortUchar((PUCHAR) (hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT),
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);

        //
        // If we are in a READ path, read the data
        //

        if (AccessMode & EMULATOR_READ_ACCESS) {

            *Data = VideoPortReadPortUshort((PUSHORT)(hwDeviceExtension->IOAddress
                                                + Port));

            endEmulation = 0;

        }

        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //

        if (endEmulation) {

            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE,
                                             MinimalVgaValidatorAccessRange);

            return NO_ERROR;

        }

        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //

        hwDeviceExtension->TrappedValidatorCount = 1;

        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));

    } else {

        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                                  SEQ_ADDRESS_PORT);

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             (ULONG)Port),
                                         (USHORT) (*Data & 0xFFF7) );

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                        temp);

                return NO_ERROR;

            }

            if ( (Port == SEQ_ADDRESS_PORT) &&
                 (((*Data>> 8) & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 ((*Data & 0xFF) == IND_SYNC_RESET)) {

                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                                 NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE,
                                                 FullVgaValidatorAccessRange);

                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_USHORT_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;

                //
                // Start keeping track of the state of the sequencer port.
                //

                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;

            } else {

                VideoPortWritePortUshort((PUSHORT)(hwDeviceExtension->IOAddress +
                                             Port),
                                         *Data);

            }

        } else {

            *Data = VideoPortReadPortUshort((PUSHORT)(hwDeviceExtension->IOAddress +
                                            Port));

        }
    }

    return NO_ERROR;

} // end VgaValidatorUshortEntry()

VP_STATUS
VgaValidatorUlongEntry(
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    )

/*++

Routine Description:

    Entry point into the validator for dword I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;

    if (hwDeviceExtension->TrappedValidatorCount) {

        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                *Data &= 0xFFFFFFF7;

            }

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_ULONG_ACCESS;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;

            hwDeviceExtension->TrappedValidatorCount++;

            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //

            if (Port == SEQ_ADDRESS_PORT) {

                //
                // If we are accessing the seq address port, keep track of its
                // value
                //

                hwDeviceExtension->SequencerAddressValue = (*Data & 0xFF);

            }

            if ((Port == SEQ_ADDRESS_PORT) &&
                ( ((*Data >> 8) & END_SYNC_RESET_VALUE) ==
                   END_SYNC_RESET_VALUE) &&
                (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {

                endEmulation = 1;

            } else {

                //
                // If the buffer is not full, then just return right away.
                //

                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {

                    return NO_ERROR;

                }

                endEmulation = 0;
            }
        }

        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));

        hwDeviceExtension->TrappedValidatorCount++;

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);

        //
        // Write back the real value of the sequencer address port.
        //

        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT,
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);

        //
        // If we are in a READ path, read the data
        //

        if (AccessMode & EMULATOR_READ_ACCESS) {

            *Data = VideoPortReadPortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                               Port));

            endEmulation = 0;

        }

        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //

        if (endEmulation) {

            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE,
                                             MinimalVgaValidatorAccessRange);

            return NO_ERROR;

        }

        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //

        hwDeviceExtension->TrappedValidatorCount = 1;

        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));

    } else {

        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                                  SEQ_ADDRESS_PORT);

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                             Port),
                                         (ULONG) (*Data & 0xFFFFFFF7) );

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                        temp);

                return NO_ERROR;

            }

            if ( (Port == SEQ_ADDRESS_PORT) &&
                 (((*Data>> 8) & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 ((*Data & 0xFF) == IND_SYNC_RESET)) {

                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                                 NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE,
                                                 FullVgaValidatorAccessRange);

                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_ULONG_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;

                //
                // Start keeping track of the state of the sequencer port.
                //

                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;

            } else {

                VideoPortWritePortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                            Port),
                                        *Data);

            }

        } else {

            *Data = VideoPortReadPortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                           Port));

        }
    }

    return NO_ERROR;

} // end VgaValidatorUlongEntry()


BOOLEAN
VgaPlaybackValidatorData(
    PVOID Context
    )

/*++

Routine Description:

    Performs all the DOS apps IO port accesses that were trapped by the
    validator. Only IO accesses that can be processed are WRITEs

    The number of outstanding IO access in deviceExtension is set to
    zero as a side effect.

    This function must be called via a call to VideoPortSynchronizeRoutine.

Arguments:

    Context - Context parameter passed to the synchronized routine.
        Must be a pointer to the miniport driver's device extension.

Return Value:

    TRUE.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = Context;
    ULONG ioBaseAddress = (ULONG) hwDeviceExtension->IOAddress;
    ULONG i;
    PVGA_VALIDATOR_DATA validatorData = hwDeviceExtension->TrappedValidatorData;

    //
    // Loop through the array of data and do instructions one by one.
    //

    for (i = 0; i < hwDeviceExtension->TrappedValidatorCount;
         i++, validatorData++) {

        //
        // Calculate base address first
        //

        ioBaseAddress = (ULONG)hwDeviceExtension->IOAddress +
                            validatorData->Port;


        //
        // This is a write operation. We will automatically stop when the
        // buffer is empty.
        //

        switch (validatorData->AccessType) {

        case VGA_VALIDATOR_UCHAR_ACCESS :

            VideoPortWritePortUchar((PUCHAR)ioBaseAddress,
                                    (UCHAR) validatorData->Data);

            break;

        case VGA_VALIDATOR_USHORT_ACCESS :

            VideoPortWritePortUshort((PUSHORT)ioBaseAddress,
                                     (USHORT) validatorData->Data);

            break;

        case VGA_VALIDATOR_ULONG_ACCESS :

            VideoPortWritePortUlong((PULONG)ioBaseAddress,
                                    (ULONG) validatorData->Data);

            break;

        default:

            VideoDebugPrint((1, "InvalidValidatorAccessType\n" ));

        }
    }

    hwDeviceExtension->TrappedValidatorCount = 0;

    return TRUE;

} // end VgaPlaybackValidatorData()


VOID
UnlockET4000ExtendedRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Allows access to the ET4000's extended (non-standard) registers.

Arguments:

    None.

Return Value:

    None.

--*/

{

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            HERCULES_COMPATIBILITY_PORT, UNLOCK_KEY_1);

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                MISC_OUTPUT_REG_READ_PORT) & 0x01) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                MODE_CONTROL_PORT_COLOR, UNLOCK_KEY_2);

    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            MODE_CONTROL_PORT_MONO, UNLOCK_KEY_2);

    }

} // end UnlockET4000ExtendedRegs()

VOID
LockET4000ExtendedRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Turns off access to the ET4000's extended (non-standard) registers.

Arguments:

    None.

Return Value:

    None.

--*/

{

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            HERCULES_COMPATIBILITY_PORT, LOCK_KEY_1);

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                MISC_OUTPUT_REG_READ_PORT) & 0x01) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                MODE_CONTROL_PORT_COLOR, LOCK_KEY_2);
    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                MODE_CONTROL_PORT_MONO, LOCK_KEY_2);
    }

} // end LockET4000ExtendedRegs()

VOID
ResetACToggle(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Resets the Attribute Controller Index/Data toggle to the Index state.

Arguments:

    None.

Return Value:

    None.

--*/

{

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                MISC_OUTPUT_REG_READ_PORT) & 0x01) {

        VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                INPUT_STATUS_1_COLOR);

    } else {

        VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                INPUT_STATUS_1_MONO);

    }

} // end ResetACToggle()


#if (_WIN32_WINNT >= 500)

VP_STATUS
ET4000GetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    )

/*++

Routine Description:

    This function is called to see if a given device can go into a given
    power state.

Arguments:

    HwDeviceExtension    - Pointer to our hardware device extension structure.


    HwDeviceId           - Private unique 32 bit ID identifing the device.
                           0xFFFFFFFF indicates the S3 card itself.

    VideoPowerManagement - Pointer to the power management structure which
                           indicates the power state in question.

Return Value:

    NO_ERROR if the device can go into the requested power state,
    otherwise an appropriate error code is returned.

--*/

{
    //
    // We only support power setting for the monitor.  Make sure the
    // HwDeviceId matches one the the monitors we could report.
    //

    if ((HwDeviceId == QUERY_NONDDC_MONITOR_ID) ||
        (HwDeviceId == QUERY_MONITOR_ID)) {

        VIDEO_X86_BIOS_ARGUMENTS biosArguments;

        //
        // We are querying the power support for the monitor.
        //

        if ((VideoPowerManagement->PowerState == VideoPowerOn) ||
            (VideoPowerManagement->PowerState == VideoPowerHibernate)) {

            return NO_ERROR;
        }

        VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

        biosArguments.Eax = VESA_POWER_FUNCTION;
        biosArguments.Ebx = VESA_GET_POWER_FUNC;

        VideoPortInt10(HwDeviceExtension, &biosArguments);

        if ((biosArguments.Eax & 0xffff) == VESA_STATUS_SUCCESS) {

            switch (VideoPowerManagement->PowerState) {

            case VideoPowerStandBy:
                return (biosArguments.Ebx & VESA_POWER_STANDBY) ?
                       NO_ERROR : ERROR_INVALID_FUNCTION;

            case VideoPowerSuspend:
                return (biosArguments.Ebx & VESA_POWER_SUSPEND) ?
                       NO_ERROR : ERROR_INVALID_FUNCTION;

            case VideoPowerOff:
                return (biosArguments.Ebx & VESA_POWER_OFF) ?
                       NO_ERROR : ERROR_INVALID_FUNCTION;

            default:

                break;
            }
        }

        VideoDebugPrint((1, "This device does not support Power Management.\n"));
        return ERROR_INVALID_FUNCTION;


    } else if (HwDeviceId == DISPLAY_ADAPTER_HW_ID) {

        //
        // We are querying power support for the graphics card.
        //

        switch (VideoPowerManagement->PowerState) {

            case VideoPowerOn:
            case VideoPowerStandBy:
            case VideoPowerHibernate:

                return NO_ERROR;

            case VideoPowerOff:
            case VideoPowerSuspend:

                //
                // Indicate that we can't do VideoPowerOff, because
                // we have no way of coming back when power is re-applied
                // to the card.
                //

                return ERROR_INVALID_FUNCTION;

            default:

                ASSERT(FALSE);
                return ERROR_INVALID_FUNCTION;
        }

    } else {

        VideoDebugPrint((1, "Unknown HwDeviceId"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}

VP_STATUS
ET4000SetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    )

/*++

Routine Description:

    Set the power state for a given device.

Arguments:

    HwDeviceExtension - Pointer to our hardware device extension structure.

    HwDeviceId        - Private unique 32 bit ID identifing the device.

    VideoPowerManagement - Power state information.

Return Value:

    TRUE if power state can be set,
    FALSE otherwise.

--*/

{
    //
    // Make sure we recognize the device.
    //

    if ((HwDeviceId == QUERY_NONDDC_MONITOR_ID) ||
        (HwDeviceId == QUERY_MONITOR_ID)) {

        VIDEO_X86_BIOS_ARGUMENTS biosArguments;

        VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

        biosArguments.Eax = VESA_POWER_FUNCTION;
        biosArguments.Ebx = VESA_SET_POWER_FUNC;

        switch (VideoPowerManagement->PowerState) {
        case VideoPowerOn:
        case VideoPowerHibernate:
            biosArguments.Ebx |= VESA_POWER_ON;
            break;

        case VideoPowerStandBy:
            biosArguments.Ebx |= VESA_POWER_STANDBY;
            break;

        case VideoPowerSuspend:
            biosArguments.Ebx |= VESA_POWER_SUSPEND;
            break;

        case VideoPowerOff:
            biosArguments.Ebx |= VESA_POWER_OFF;
            break;

        default:
            VideoDebugPrint((1, "Unknown power state.\n"));
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
        }

        VideoPortInt10(HwDeviceExtension, &biosArguments);

        return NO_ERROR;

    } else if (HwDeviceId == DISPLAY_ADAPTER_HW_ID) {

        switch (VideoPowerManagement->PowerState) {

            case VideoPowerOn:
            case VideoPowerStandBy:
            case VideoPowerSuspend:
            case VideoPowerOff:
            case VideoPowerHibernate:

                return NO_ERROR;

            default:

                ASSERT(FALSE);
                return ERROR_INVALID_PARAMETER;
        }

    } else {

        VideoDebugPrint((1, "Unknown HwDeviceId"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}

//
// Routine to retrieve the Enhanced Display ID structure via DDC
//
ULONG
ET4000GetVideoChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    )
{
    PHW_DEVICE_EXTENSION pHwDeviceExtension = HwDeviceExtension;
    ULONG                Status;

    ASSERT(pHwDeviceExtension != NULL && pMoreChildren != NULL);

    VideoDebugPrint((2, "ET4000.SYS ET4000GetVideoChildDescriptor: *** Entry point ***\n"));

    //
    // Determine if the graphics adapter in the system supports
    // DDC2 (our miniport only supports DDC2, not DDC1). This has
    // the side effect (assuming both monitor and card support
    // DDC2) of switching the monitor from DDC1 mode (repeated
    // "blind" broadcast of EDID clocked by the vertical sync
    // signal) to DDC2 mode (query/response not using any of the
    // normal video lines - can transfer information rapidly
    // without first disrupting the screen by switching into
    // a pseudo-mode with a high vertical sync frequency).
    //
    // Since we must support hot-plugging of monitors, and our
    // routine to obtain the EDID structure via DDC2 assumes that
    // the monitor is in DDC2 mode, we must make this test each
    // time this entry point is called.
    //

    switch (ChildEnumInfo->ChildIndex) {
    case 0:

        //
        // Case 0 is used to enumerate devices found by the ACPI firmware.
        //
        // Since we do not support ACPI devices yet, we must return failure.
        //

        Status = ERROR_NO_MORE_DEVICES;
        break;

    case 1:

        //
        // We do not support monitor enumeration
        //

        Status = ERROR_NO_MORE_DEVICES;
        break;

    case DISPLAY_ADAPTER_HW_ID:
        {

        PUSHORT     pPnpDeviceDescription = NULL;
        ULONG       stringSize = sizeof(L"*PNPXXXX");

        //
        // Special ID to handle return legacy PnP IDs for root enumerated
        // devices.
        //

        *pChildType = VideoChip;
        *pHwId      = DISPLAY_ADAPTER_HW_ID;

        //
        //  Figure out which card type and set pPnpDeviceDescription at
        //  associated string.
        //

        if ((pHwDeviceExtension->ulChipID == ET4000) ||
             (pHwDeviceExtension->ulChipID == ET6000))
            pPnpDeviceDescription = L"*PNP0906";

        else if (pHwDeviceExtension->ulChipID == W32)
            pPnpDeviceDescription = L"*PNP0912";

        else if (pHwDeviceExtension->ulChipID == W32P)
                pPnpDeviceDescription = L"*PNP091A";

        else if (pHwDeviceExtension->ulChipID == W32I)
                pPnpDeviceDescription = L"*PNP091A";

        //
        //  Now just copy the string into memory provided.
        //

        if (pPnpDeviceDescription)
            memcpy(pvChildDescriptor, pPnpDeviceDescription, stringSize);

        Status = ERROR_MORE_DATA;
        break;
        }

    default:

        Status = ERROR_NO_MORE_DEVICES;
        break;
    }


    return Status;
}

#endif  // _WIN32_WINNT >= 500
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\tseng\mini\modeset.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    modeset.c

Abstract:

    This is the modeset code for the et4000 miniport driver.

Environment:

    kernel mode only

Notes:

Revision History:

--*/
#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "et4000.h"

#include "cmdcnst.h"


VP_STATUS
VgaInterpretCmdStream(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pusCmdStream
    );

VP_STATUS
VgaSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    );

VP_STATUS
VgaQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VOID
VgaZeroVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
VgaValidateModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,VgaInterpretCmdStream)
#pragma alloc_text(PAGE,VgaSetMode)
#pragma alloc_text(PAGE,VgaQueryAvailableModes)
#pragma alloc_text(PAGE,VgaQueryNumberOfAvailableModes)
#pragma alloc_text(PAGE,VgaQueryCurrentMode)
#pragma alloc_text(PAGE,VgaZeroVideoMemory)
#pragma alloc_text(PAGE,VgaValidateModes)
#endif


VP_STATUS
VgaInterpretCmdStream(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pusCmdStream
    )

/*++

Routine Description:

    Interprets the appropriate command array to set up VGA registers for the
    requested mode. Typically used to set the VGA into a particular mode by
    programming all of the registers

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    pusCmdStream - array of commands to be interpreted.

Return Value:

    The status of the operation (can only fail on a bad command); TRUE for
    success, FALSE for failure.

--*/

{
    ULONG ulCmd;
    ULONG ulPort;
    UCHAR jValue;
    USHORT usValue;
    ULONG culCount;
    ULONG ulIndex;
    ULONG ulBase;

    if (pusCmdStream == NULL) {

        VideoDebugPrint((1, "VgaInterpretCmdStream - Invalid pusCmdStream\n"));
        return TRUE;
    }

    ulBase = (ULONG)HwDeviceExtension->IOAddress;

    //
    // Now set the adapter to the desired mode.
    //

    while ((ulCmd = *pusCmdStream++) != EOD) {

        //
        // Determine major command type
        //

        switch (ulCmd & 0xF0) {

            //
            // Basic input/output command
            //

            case INOUT:

                //
                // Determine type of inout instruction
                //

                if (!(ulCmd & IO)) {

                    //
                    // Out instruction. Single or multiple outs?
                    //

                    if (!(ulCmd & MULTI)) {

                        //
                        // Single out. Byte or word out?
                        //

                        if (!(ulCmd & BW)) {

                            //
                            // Single byte out
                            //

                            ulPort = *pusCmdStream++;
                            jValue = (UCHAR) *pusCmdStream++;
                            VideoPortWritePortUchar((PUCHAR)(ulBase+ulPort),
                                    jValue);

                        } else {

                            //
                            // Single word out
                            //

                            ulPort = *pusCmdStream++;
                            usValue = *pusCmdStream++;
                            VideoPortWritePortUshort((PUSHORT)(ulBase+ulPort),
                                    usValue);

                        }

                    } else {

                        //
                        // Output a string of values
                        // Byte or word outs?
                        //

                        if (!(ulCmd & BW)) {

                            //
                            // String byte outs. Do in a loop; can't use
                            // VideoPortWritePortBufferUchar because the data
                            // is in USHORT form
                            //

                            ulPort = ulBase + *pusCmdStream++;
                            culCount = *pusCmdStream++;

                            while (culCount--) {
                                jValue = (UCHAR) *pusCmdStream++;
                                VideoPortWritePortUchar((PUCHAR)ulPort,
                                        jValue);

                            }

                        } else {

                            //
                            // String word outs
                            //

                            ulPort = *pusCmdStream++;
                            culCount = *pusCmdStream++;
                            VideoPortWritePortBufferUshort((PUSHORT)
                                    (ulBase + ulPort), pusCmdStream, culCount);
                            pusCmdStream += culCount;

                        }
                    }

                } else {

                    // In instruction
                    //
                    // Currently, string in instructions aren't supported; all
                    // in instructions are handled as single-byte ins
                    //
                    // Byte or word in?
                    //

                    if (!(ulCmd & BW)) {
                        //
                        // Single byte in
                        //

                        ulPort = *pusCmdStream++;
                        jValue = VideoPortReadPortUchar((PUCHAR)ulBase+ulPort);

                    } else {

                        //
                        // Single word in
                        //

                        ulPort = *pusCmdStream++;
                        usValue = VideoPortReadPortUshort((PUSHORT)
                                (ulBase+ulPort));

                    }

                }

                break;

            //
            // Higher-level input/output commands
            //

            case METAOUT:

                //
                // Determine type of metaout command, based on minor
                // command field
                //
                switch (ulCmd & 0x0F) {

                    //
                    // Indexed outs
                    //

                    case INDXOUT:

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            usValue = (USHORT) (ulIndex +
                                      (((ULONG)(*pusCmdStream++)) << 8));
                            VideoPortWritePortUshort((PUSHORT)ulPort, usValue);

                            ulIndex++;

                        }

                        break;

                    //
                    // Masked out (read, AND, XOR, write)
                    //

                    case MASKOUT:

                        ulPort = *pusCmdStream++;
                        jValue = VideoPortReadPortUchar((PUCHAR)ulBase+ulPort);
                        jValue &= *pusCmdStream++;
                        jValue ^= *pusCmdStream++;
                        VideoPortWritePortUchar((PUCHAR)ulBase + ulPort,
                                jValue);
                        break;

                    //
                    // Attribute Controller out
                    //

                    case ATCOUT:

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            // Write Attribute Controller index
                            VideoPortWritePortUchar((PUCHAR)ulPort,
                                    (UCHAR)ulIndex);

                            // Write Attribute Controller data
                            jValue = (UCHAR) *pusCmdStream++;
                            VideoPortWritePortUchar((PUCHAR)ulPort, jValue);

                            ulIndex++;

                        }

                        break;

                    //
                    // None of the above; error
                    //
                    default:

                        return FALSE;

                }


                break;

            //
            // NOP
            //

            case NCMD:

                break;

            //
            // Unknown command; error
            //

            default:

                return FALSE;

        }

    }

    return TRUE;

} // end VgaInterpretCmdStream()



VP_STATUS
VgaSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    )

/*++

Routine Description:

    This routine sets the vga into the requested mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    Mode - Pointer to the structure containing the information about the
        font to be set.

    ModeSize - Length of the input buffer supplied by the user.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    ERROR_INVALID_PARAMETER if the mode number is invalid.

    NO_ERROR if the operation completed successfully.

--*/

{

    PVIDEOMODE pRequestedMode;
    VP_STATUS status;
    USHORT usDataSet, usTemp, usDataClr;
    PUSHORT  pBios = NULL;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;


    VideoDebugPrint((1, "VgaSetMode - entry\n"));

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (ModeSize < sizeof(VIDEO_MODE)) {

        VideoDebugPrint((1, "VgaSetMode - ERROR_INSUFFICIENT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Extract the map linear bits.
    //

    HwDeviceExtension->bInLinearMode = FALSE;

    if (Mode->RequestedMode & VIDEO_MODE_MAP_MEM_LINEAR)
    {
        if (!HwDeviceExtension->bLinearModeSupported)
        {
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            HwDeviceExtension->bInLinearMode = TRUE;
            Mode->RequestedMode &= ~VIDEO_MODE_MAP_MEM_LINEAR;
        }
    }

    //
    // Extract the clear memory bit.
    //

    if (Mode->RequestedMode & VIDEO_MODE_NO_ZERO_MEMORY) {

        Mode->RequestedMode &= ~VIDEO_MODE_NO_ZERO_MEMORY;

    }  else {

        VgaZeroVideoMemory(HwDeviceExtension);

    }

    //
    // Check to see if we are requesting a valid mode
    //

    if ( (Mode->RequestedMode >= NumVideoModes) ||
         (!ModesVGA[Mode->RequestedMode].ValidMode) ) {

        VideoDebugPrint((1, "VgaSetMode - ERROR_INVALID_PARAMETER\n"));
        return ERROR_INVALID_PARAMETER;

    }

    pRequestedMode = &ModesVGA[Mode->RequestedMode];

    //
    // If the chip is a W32 and it's not a planar color so we're using the
    // accelerated W32 driver.  We don't want stretched scans for that driver,
    // so...  No stretched scans!
    //

    if ((HwDeviceExtension->ulChipID >= W32) &&
        (pRequestedMode->bitsPerPlane != 1)) {

        pRequestedMode->wbytes = (pRequestedMode->hres *
                                  pRequestedMode->bitsPerPlane *
                                  pRequestedMode->numPlanes) >> 3;

        pRequestedMode->CmdStrings = NULL;

    }

    //
    // Set the vertical refresh frequency
    //

    //
    // This code is used to determine if the BIOS call to set frequencies
    // is available.  If you can, then after the BIOS call AL=12.
    // See page 233 of the W32p data book for details.
    //

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    biosArguments.Eax = 0x1200;
    biosArguments.Ebx = 0xf1;
    biosArguments.Ecx = 0x0;
    status = VideoPortInt10(HwDeviceExtension, &biosArguments);

    if (status != NO_ERROR) {

        VideoDebugPrint((1, "VgaSetMode - VideoPortInt10 failed (%d)\n", __LINE__));
        return status;

    }

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    biosArguments.Eax = 0x1200;
    biosArguments.Ebx = 0xf1;
    biosArguments.Ecx = 0x1;
    status = VideoPortInt10(HwDeviceExtension, &biosArguments);

    if (status != NO_ERROR) {

        VideoDebugPrint((1, "VgaSetMode - VideoPortInt10 failed (%d)\n", __LINE__));
        return status;

    }

    VideoDebugPrint((1, "VgaSetMode - BIOS returned %x in AL\n",
                    (biosArguments.Eax & 0xff)));

    if ((biosArguments.Eax & 0xff) == 0x12) {

        VideoDebugPrint((1, "VgaSetMode - using BIOS to set refresh rate\n"));

        VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
        biosArguments.Eax = 0x1200;

        switch (pRequestedMode->hres) {

        case 320:
        case 512:
        case 640:

            biosArguments.Ebx = 0xf1;

            if (pRequestedMode->Frequency == 60)
                biosArguments.Ecx = 0x0;
            else if (pRequestedMode->Frequency == 72)
                biosArguments.Ecx = 0x1;
            else if (pRequestedMode->Frequency == 75)
                biosArguments.Ecx = 0x2;
            else if (pRequestedMode->Frequency == 85)
                biosArguments.Ecx = 0x3;
            else if (pRequestedMode->Frequency == 90)
                biosArguments.Ecx = 0x4;
            break;

        case 800:

            biosArguments.Ebx = 0x1f1;

            if (pRequestedMode->Frequency == 56)
                biosArguments.Ecx = 0x0;
            else if (pRequestedMode->Frequency == 60)
                biosArguments.Ecx = 0x1;
            else if (pRequestedMode->Frequency == 72)
                biosArguments.Ecx = 0x2;
            else if (pRequestedMode->Frequency == 75)
                biosArguments.Ecx = 0x3;
            else if (pRequestedMode->Frequency == 85)
                biosArguments.Ecx = 0x4;
            else if (pRequestedMode->Frequency == 90)
                biosArguments.Ecx = 0x5;
            break;

        case 1024:

            biosArguments.Ebx = 0x2f1;

            if (pRequestedMode->Frequency == 45)
                biosArguments.Ecx = 0x0;
            else if (pRequestedMode->Frequency == 60)
                biosArguments.Ecx = 0x1;
            else if (pRequestedMode->Frequency == 70)
                biosArguments.Ecx = 0x2;

            // For some BIOS 3 will give us 72 Hz, and
            // on others, 3 will give us 75

            else if (pRequestedMode->Frequency == 72)
                biosArguments.Ecx = 0x3;
            else if (pRequestedMode->Frequency == 75)
                biosArguments.Ecx = 0x3;
            break;

        case 1280:

            biosArguments.Ebx = 0x3f1;

            if (pRequestedMode->Frequency == 45)
                biosArguments.Ecx = 0x0;
            else if (pRequestedMode->Frequency == 60)
                biosArguments.Ecx = 0x1;
            else if (pRequestedMode->Frequency == 70)
                biosArguments.Ecx = 0x2;

            // For some BIOS 3 will give us 72 Hz, and
            // on others, 3 will give us 75

            else if (pRequestedMode->Frequency == 72)
                biosArguments.Ecx = 0x3;
            else if (pRequestedMode->Frequency == 75)
                biosArguments.Ecx = 0x3;
            break;

        default:

            biosArguments.Ebx = 0xf1;
            biosArguments.Ecx = 0x0;
            break;
        }

        status = VideoPortInt10(HwDeviceExtension, &biosArguments);

        if (status != NO_ERROR) {

           VideoDebugPrint((1, "VgaSetMode - VideoPortInt10 failed (%d)\n", __LINE__));

        }

        VideoDebugPrint((1, "VgaSetMode - BIOS returned %x in CL\n",
                        (biosArguments.Ecx & 0xff)));
    }

    else if (HwDeviceExtension->BoardID == STEALTH32) {

        usTemp = 0xffff;  // flag value, this is reserved

        switch (pRequestedMode->hres) {

        case 640:

            if (pRequestedMode->Frequency == 90) {

                usTemp = 4;

            } else if (pRequestedMode->Frequency == 75) {

                usTemp = 2;

            } else if (pRequestedMode->Frequency == 72) {

                usTemp = 0;

            } else if (pRequestedMode->Frequency == 60) {

                usTemp = 8;

            }

            break;


        case 800:

            if (pRequestedMode->Frequency == 90) {

                usTemp = 4;

            } else if (pRequestedMode->Frequency == 75) {

                usTemp = 2;

            } else if (pRequestedMode->Frequency == 72) {

                usTemp = 1;

            } else if (pRequestedMode->Frequency == 60) {

                usTemp = 0;

            } else if (pRequestedMode->Frequency == 56) {

                usTemp = 8;

            }

            break;


        case 1024:

            if (pRequestedMode->Frequency == 75) {

                usTemp = 2;

            } else if (pRequestedMode->Frequency == 72) {

                usTemp = 4;

            } else if (pRequestedMode->Frequency == 70) {

                usTemp = 3;

            } else if (pRequestedMode->Frequency == 60) {

                usTemp = 5;

            } else if (pRequestedMode->Frequency == 43) {

                usTemp = 0;

            }

            break;

        case 1280:

            if (pRequestedMode->Frequency == 75) {

                usTemp = 2;

            } else if (pRequestedMode->Frequency == 72) {

                usTemp = 4;

            } else if (pRequestedMode->Frequency == 60) {

                usTemp = 5;

            } else if (pRequestedMode->Frequency == 43) {

                usTemp = 6;

            }

            break;

        default:

            //
            // !!! Reset for DOS modes?
            //

            // usDataSet = HwDeviceExtension->OriginalBiosData;

            break;

        }

        if (usTemp != 0xffff)
        {
            USHORT usOldBits;

            UnlockET4000ExtendedRegs(HwDeviceExtension);

            //
            // select CRTC.31 and write usTemp to bits 3-0
            //

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    CRTC_ADDRESS_PORT_COLOR, 0x31);

            usOldBits = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                    CRTC_DATA_PORT_COLOR);

            usTemp    = ((usTemp & 0x0f) | (usOldBits & 0xf0));

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    CRTC_DATA_PORT_COLOR, (UCHAR)usTemp);

            LockET4000ExtendedRegs(HwDeviceExtension);
        }

    } // HwDeviceExtension->BoardID == STEALTH32

#if defined(i386)

    //
    // Ok, we'll try to stuff the right values in to the bios data
    // area so that the int10 modeset sets the freq for us.
    //

    else {

        //
        // NOTE :
        //
        // We assume an int10 was made as some point before we reach this code.
        // This ensures the BiosData got initialized properly.
        //

        //
        // Get the BiosData area value and save the original value.
        //

        if (!HwDeviceExtension->BiosArea) {

            switch (HwDeviceExtension->BoardID) {

            case PRODESIGNERIISEISA:

                //
                // Initialize this to something.
                // It is not used however, since we always use hardware defaults
                // for this card.
                //

                HwDeviceExtension->BiosArea = (PUSHORT)PRODESIGNER_BIOS_INFO;

                break;

            case PRODESIGNER2:
            case PRODESIGNERIIS:

                HwDeviceExtension->BiosArea = (PUSHORT)PRODESIGNER_BIOS_INFO;
                HwDeviceExtension->OriginalBiosData =
                    VideoPortReadRegisterUshort(HwDeviceExtension->BiosArea);

                break;

            case SPEEDSTAR:
            case SPEEDSTARPLUS:
            case SPEEDSTAR24:
            case OTHER:
            default:

                HwDeviceExtension->BiosArea = (PUSHORT)BIOS_INFO_1;
                HwDeviceExtension->OriginalBiosData =
                    VideoPortReadRegisterUshort(HwDeviceExtension->BiosArea);

                break;
            }
        }

        pBios = HwDeviceExtension->BiosArea;

        //
        // Set the refresh rates for the various boards
        //

        switch(HwDeviceExtension->BoardID) {

        case SPEEDSTAR:
        case SPEEDSTARPLUS:
        case SPEEDSTAR24:

            switch (pRequestedMode->hres) {

            case 640:
                if (pRequestedMode->Frequency == 72)
                    usDataSet = 2;
                else usDataSet = 1;
                break;

            case 800:
                if (pRequestedMode->Frequency == 72)
                    usDataSet = 2;
                else if (pRequestedMode->Frequency == 56)
                    usDataSet = 1;
                else usDataSet = 3;
                break;

            case 1024:
                if (pRequestedMode->Frequency == 70)
                    usDataSet = 4;
                else if (pRequestedMode->Frequency == 45)
                    usDataSet = 1;
                else usDataSet = 2;
                break;

            default:
                usDataSet = 1;
                break;

            }

            //
            // now we got to unlock the CRTC extension registers!?!
            //

            UnlockET4000ExtendedRegs(HwDeviceExtension);

            if (HwDeviceExtension->BoardID == SPEEDSTAR24) {

                //
                // SpeedSTAR 24 uses 31.0 for LSB select CRTC.31 and read it
                //

                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_ADDRESS_PORT_COLOR, 0x31);

                usTemp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                CRTC_DATA_PORT_COLOR) & ~0x01;

                //
                // CRTC.31 bit 0 is the LSB of the monitor type on SpeedSTAR 24
                //

                usTemp |= (usDataSet&1);
                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_DATA_PORT_COLOR, (UCHAR)usTemp);

            } else {                    // SpeedSTAR and SpeedSTAR Plus use 37.4 for LSB

                //
                // select CRTC.37 and read it
                //

                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_ADDRESS_PORT_COLOR, 0x37);

                usTemp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                CRTC_DATA_PORT_COLOR) & ~0x10;

                //
                // CRTC.37 bit 4 is the LSB of the monitor type on SpeedSTAR PLUS
                //

                usTemp |= (usDataSet&1)<<4;
                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_DATA_PORT_COLOR, (UCHAR)usTemp);
            }

            LockET4000ExtendedRegs(HwDeviceExtension);

            //
            // these two bits are the rest of the monitor type...
            //

            usTemp = VideoPortReadRegisterUshort(pBios) & ~0x6000;
            usTemp |= (usDataSet&6)<<12;
            usTemp |= VideoPortReadRegisterUshort(pBios);
            VideoPortWriteRegisterUshort(pBios,usTemp);

            break;

        //
        // Do nothing for the EISA machine - use the default in the EISA config.
        //

        case PRODESIGNERIISEISA:

            break;

        //
        // The old prodesigner 2 is not able toset refresh rates
        //

        case PRODESIGNER2:

            break;

        case PRODESIGNERIIS:

            switch (pRequestedMode->hres) {

            case 640:

                //
                // Bit 0:  1=72Hz 0=60Hz
                //

                if (pRequestedMode->Frequency == 72) {

                    usDataSet = 0x0001;

                } else { // 60 Hz

                    usDataSet = 0x0000;

                }

                break;


            case 800:

                //
                // Bit 1-2: 10=72Hz 01=60Hz 00=56Hz
                //

                if (pRequestedMode->Frequency == 72) {

                    usDataSet = 0x0004;

                } else {

                    if (pRequestedMode->Frequency == 56) {

                        usDataSet = 0x0000;

                    } else {   // 60 Hz

                        usDataSet = 0x0002;

                    }
                }

                break;


            case 1024:

                //
                // Bit 3-4: 10=70Hz 01=60Hz 00=45Hz
                //

                if (pRequestedMode->Frequency == 70) {

                    usDataSet = 0x0010;

                } else {

                    if (pRequestedMode->Frequency == 45) {

                        usDataSet = 0x0000;

                    } else { // 60 Hz

                        usDataSet = 0x0008;

                    }
                }

                break;

            // case 1280

                //
                // Bit 5  1=45Hz 0=43 Hz
                //


            default:

                //
                // Reset for DOS modes
                //

                usDataSet = HwDeviceExtension->OriginalBiosData;

                break;

            }

            VideoPortWriteRegisterUshort(pBios,usDataSet);

            break;


        case OTHER:
        default:

            {

                VideoDebugPrint((2, "### VgaSetMode - hres(%d) freq(%d)\n",
                                    pRequestedMode->hres,
                                    pRequestedMode->Frequency
                ));


                VideoDebugPrint((2, "### VgaSetMode - NOT using BIOS to set refresh rate\n"));

                switch (pRequestedMode->hres) {

                case 640:

                    if (pRequestedMode->Frequency == 72) {

                        usDataSet = 0x0040;               // set bit 6
                        usDataClr = (USHORT)~0;           // no bits to be cleared

                    } else { // 60 Hz

                        usDataSet = 0;                    // no bits to set
                        usDataClr = (USHORT)~0x0040;      // clear bit 6

                    }

                    break;


                case 800:

                    if (pRequestedMode->Frequency == 72) {

                        usDataSet = 0x4020;               // set bits 5 and 14
                        usDataClr = (USHORT)~0;           // no bits to clear

                    } else {

                        if (pRequestedMode->Frequency == 56) {

                            usDataSet = 0x4000;           // set bit 14
                            usDataClr = (USHORT)~0x0020;  // clr bit 5

                        } else {   // 60 Hz

                            usDataSet = 0;                // no bits to set
                            usDataClr = (USHORT)~0x4020;  // clr bits 5 and 14

                        }
                    }

                    break;


                case 1024:

                    if (pRequestedMode->Frequency == 70) {

                        usDataSet = 0x2010;               // set bits 4 and 13
                        usDataClr = (USHORT)~0;           // no bits to clear

                    } else {

                        if (pRequestedMode->Frequency == 45) { //interlaced

                            usDataSet = 0;                // no bits to set
                            usDataClr = (USHORT)~0x2010;  // clear bits 4 and 13

                        } else { // 60 Hz

                            usDataSet = 0x2000;           // set bit 13
                            usDataClr = (USHORT)~0x0010;  // clear bit 4

                        }
                    }

                    break;

                default:

                    //
                    // Restore to original Value
                    //

                    usDataSet = HwDeviceExtension->OriginalBiosData;
                    usDataClr = 0x0000;

                    break;

                }

                usTemp = VideoPortReadRegisterUshort(pBios) & usDataClr;
                usTemp |= usDataSet;
                VideoPortWriteRegisterUshort(pBios,usTemp);

            }

            break;

        }

    }

#endif

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    biosArguments.Eax = pRequestedMode->Int10ModeNumber;

    status = VideoPortInt10(HwDeviceExtension, &biosArguments);

    if (status != NO_ERROR) {

        VideoDebugPrint((1, "VgaSetMode - VideoPortInt10 failed (%d)\n", __LINE__));
        return status;

    }

    if (HwDeviceExtension->ulChipID == ET4000 &&
        HwDeviceExtension->AdapterMemorySize < 0x100000) {

        //
        // ET4000 less than 1 meg set TLI mode in CRTC.36
        //

        UnlockET4000ExtendedRegs(HwDeviceExtension);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR, 0x36);

        usTemp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                CRTC_DATA_PORT_COLOR) | 0x20;

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_DATA_PORT_COLOR, (UCHAR)usTemp);
        LockET4000ExtendedRegs(HwDeviceExtension);

    }

    //
    // If this is a 16bpp or 24bpp mode, call the bios to switch it from
    // 8bpp to the new mode.
    //

    if (pRequestedMode->bitsPerPlane == 16) {

        VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

        biosArguments.Eax = 0x10F0;
        biosArguments.Ebx = pRequestedMode->Int10ModeNumber;

        status = VideoPortInt10(HwDeviceExtension, &biosArguments);

        if (status != NO_ERROR) {

            VideoDebugPrint((1, "VgaSetMode - VideoPortInt10 failed (%d)\n", __LINE__));
            return status;

        }
    } else if (pRequestedMode->bitsPerPlane == 24) {

        VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

        biosArguments.Eax = 0x10F0;
        biosArguments.Ebx = pRequestedMode->Int10ModeNumber;
        biosArguments.Ebx <<= 8;
        biosArguments.Ebx |= 0xff;

        status = VideoPortInt10(HwDeviceExtension, &biosArguments);

        if (status != NO_ERROR) {

            VideoDebugPrint((1, "VgaSetMode - VideoPortInt10 failed (%d)\n", __LINE__));
            return status;

        }
    }

    if (pRequestedMode->hres >= 800) {
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEGMENT_SELECT_PORT,0);
    }

    if (pRequestedMode->CmdStrings != NULL) {
        VgaInterpretCmdStream(HwDeviceExtension, pRequestedMode->CmdStrings);
    }

    //
    // Reset the Bios Value to the default so DOS modes will work.
    // Do this for all cards except the EISA prodesigner
    //

    if ((pBios != NULL) &&
        (HwDeviceExtension->BoardID != PRODESIGNERIISEISA))
    {
        VideoPortWriteRegisterUshort(pBios,
                                     HwDeviceExtension->OriginalBiosData);
    }



{
    UCHAR temp;
    UCHAR dummy;
    UCHAR bIsColor;

    if (!(pRequestedMode->fbType & VIDEO_MODE_GRAPHICS)) {

        //
        // Fix to make sure we always set the colors in text mode to be
        // intensity, and not flashing
        // For this zero out the Mode Control Regsiter bit 3 (index 0x10
        // of the Attribute controller).
        //

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                MISC_OUTPUT_REG_READ_PORT) & 0x01) {

            bIsColor = TRUE;

        } else {

            bIsColor = FALSE;

        }

        if (bIsColor) {

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_COLOR);
        } else {

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_MONO);
        }

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (0x10 | VIDEO_ENABLE));
        temp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_READ_PORT);

        temp &= 0xF7;

        if (bIsColor) {

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_COLOR);
        } else {

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_MONO);
        }

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (0x10 | VIDEO_ENABLE));
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_WRITE_PORT, temp);
    }
}

    //
    //  Set up the card to use the linear address ranges
    //

    {
        UCHAR bits;

        VideoPortGetBusData(HwDeviceExtension,
                            PCIConfiguration,
                            HwDeviceExtension->ulSlot,
                            (PVOID) &bits,
                            0x40,
                            1);

        bits &= ~0x6;

        if (HwDeviceExtension->bInLinearMode)
        {
            //
            // set low 4 bits to 1011
            //

            bits |= 0xb;
        }
        else
        {
            //
            // set low 4 bits to 0110
            //

            bits |= 0x6;
        }

        VideoPortSetBusData(HwDeviceExtension,
                            PCIConfiguration,
                            HwDeviceExtension->ulSlot,
                            (PVOID) &bits,
                            0x40,
                            1);
    }

    //
    // Update the location of the physical frame buffer within video memory.
    //

    HwDeviceExtension->PhysicalFrameLength =
            MemoryMaps[pRequestedMode->MemMap].MaxSize;

    HwDeviceExtension->PhysicalFrameBase.HighPart = 0;
    HwDeviceExtension->PhysicalFrameBase.LowPart =
            MemoryMaps[pRequestedMode->MemMap].Start;


    //
    // Store the new mode value.
    //

    HwDeviceExtension->CurrentMode = pRequestedMode;
    HwDeviceExtension->ModeIndex = Mode->RequestedMode;

    VideoDebugPrint((1, "VgaSetMode - exit\n"));
    return NO_ERROR;

} //end VgaSetMode()


VP_STATUS
VgaQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the list of all available available modes on the
    card.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ModeInformation - Pointer to the output buffer supplied by the user.
        This is where the list of all valid modes is stored.

    ModeInformationSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    PVIDEO_MODE_INFORMATION videoModes = ModeInformation;
    ULONG i;

    //
    // Find out the size of the data to be put in the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (ModeInformationSize < (*OutputSize =
            HwDeviceExtension->NumAvailableModes *
            sizeof(VIDEO_MODE_INFORMATION)) ) {

        VideoDebugPrint((1,"VgaQueryAvailableModes: ERROR_INSUFFICIENT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // For each mode supported by the card, store the mode characteristics
    // in the output buffer.
    //

    for (i = 0; i < NumVideoModes; i++) {

        if (ModesVGA[i].ValidMode) {

            videoModes->Length = sizeof(VIDEO_MODE_INFORMATION);
            videoModes->ModeIndex  = i;
            videoModes->VisScreenWidth = ModesVGA[i].hres;
            videoModes->ScreenStride = ModesVGA[i].wbytes;
            videoModes->VisScreenHeight = ModesVGA[i].vres;
            videoModes->NumberOfPlanes = ModesVGA[i].numPlanes;
            videoModes->BitsPerPlane = ModesVGA[i].bitsPerPlane;
            videoModes->Frequency = ModesVGA[i].Frequency;
            videoModes->XMillimeter = 320;        // temporary hardcoded constant
            videoModes->YMillimeter = 240;        // temporary hardcoded constant
            videoModes->NumberRedBits = 6;
            videoModes->NumberGreenBits = 6;
            videoModes->NumberBlueBits = 6;

            videoModes->AttributeFlags = ModesVGA[i].fbType;
            videoModes->AttributeFlags |= ModesVGA[i].Interlaced ?
                 VIDEO_MODE_INTERLACED : 0;

            //
            // Calculate the VideoMemoryBitmapWidth
            //

            {
                LONG x;

                x = videoModes->BitsPerPlane;

                if( x == 15 ) x = 16;

                videoModes->VideoMemoryBitmapWidth =
                    (videoModes->ScreenStride * 8 ) / x;
            }

            videoModes->VideoMemoryBitmapHeight =
                     HwDeviceExtension->AdapterMemorySize / videoModes->ScreenStride;

            if (ModesVGA[i].bitsPerPlane == 16) {

                videoModes->RedMask = 0x7c00;
                videoModes->GreenMask = 0x03e0;
                videoModes->BlueMask = 0x001f;

            } else if (ModesVGA[i].bitsPerPlane == 24) {

                videoModes->RedMask =   0xff0000;
                videoModes->GreenMask = 0x00ff00;
                videoModes->BlueMask =  0x0000ff;

            } else {

                videoModes->RedMask = 0;
                videoModes->GreenMask = 0;
                videoModes->BlueMask = 0;
                videoModes->AttributeFlags |= VIDEO_MODE_PALETTE_DRIVEN |
                        VIDEO_MODE_MANAGED_PALETTE;
            }

            videoModes++;

        }
    }

    return NO_ERROR;

} // end VgaGetAvailableModes()

VP_STATUS
VgaQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the number of available modes for this particular
    video card.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    NumModes - Pointer to the output buffer supplied by the user. This is
        where the number of modes is stored.

    NumModesSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (NumModesSize < (*OutputSize = sizeof(VIDEO_NUM_MODES)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the number of modes into the buffer.
    //

    NumModes->NumModes = HwDeviceExtension->NumAvailableModes;
    NumModes->ModeInformationLength = sizeof(VIDEO_MODE_INFORMATION);

    VideoDebugPrint((1,"NumAvailableModes = %d\n", HwDeviceExtension->NumAvailableModes));
    return NO_ERROR;

} // end VgaGetNumberOfAvailableModes()

VP_STATUS
VgaQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns a description of the current video mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ModeInformation - Pointer to the output buffer supplied by the user.
        This is where the current mode information is stored.

    ModeInformationSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (ModeInformationSize < (*OutputSize = sizeof(VIDEO_MODE_INFORMATION))) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the characteristics of the current mode into the buffer.
    //

    ModeInformation->Length = sizeof(VIDEO_MODE_INFORMATION);
    ModeInformation->ModeIndex = HwDeviceExtension->ModeIndex;
    ModeInformation->VisScreenWidth = HwDeviceExtension->CurrentMode->hres;
    ModeInformation->ScreenStride = HwDeviceExtension->CurrentMode->wbytes;
    ModeInformation->VisScreenHeight = HwDeviceExtension->CurrentMode->vres;
    ModeInformation->NumberOfPlanes = HwDeviceExtension->CurrentMode->numPlanes;
    ModeInformation->BitsPerPlane = HwDeviceExtension->CurrentMode->bitsPerPlane;
    ModeInformation->Frequency = HwDeviceExtension->CurrentMode->Frequency;
    ModeInformation->XMillimeter = 320;        // temporary hardcoded constant
    ModeInformation->YMillimeter = 240;        // temporary hardcoded constant
    ModeInformation->NumberRedBits = 6;
    ModeInformation->NumberGreenBits = 6;
    ModeInformation->NumberBlueBits = 6;
    ModeInformation->RedMask = 0;
    ModeInformation->GreenMask = 0;
    ModeInformation->BlueMask = 0;
    ModeInformation->AttributeFlags = HwDeviceExtension->CurrentMode->fbType |
             VIDEO_MODE_PALETTE_DRIVEN | VIDEO_MODE_MANAGED_PALETTE;
    ModeInformation->AttributeFlags |= HwDeviceExtension->CurrentMode->Interlaced ?
             VIDEO_MODE_INTERLACED : 0;

    //
    // Calculate the VideoMemoryBitmapWidth
    //

    {
        LONG x;

        x = ModeInformation->BitsPerPlane;

        if( x == 15 ) x = 16;

        ModeInformation->VideoMemoryBitmapWidth =
            (ModeInformation->ScreenStride * 8 ) / x;
    }

    ModeInformation->VideoMemoryBitmapHeight =
             HwDeviceExtension->AdapterMemorySize / ModeInformation->ScreenStride;

    return NO_ERROR;

} // end VgaQueryCurrentMode()


VOID
VgaZeroVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine zeros the first 256K on the VGA.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.


Return Value:

    None.

--*/
{
//    return;

    {
        UCHAR temp;

        VideoDebugPrint((1, "VgaZeroVideoMemory - entry et4000\n"));

        //
        // Map font buffer at A0000
        //

        VgaInterpretCmdStream(HwDeviceExtension, EnableA000Data);

        //
        // Enable all planes.
        //
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                IND_MAP_MASK);

        temp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT) | (UCHAR)0x0F;

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
                temp);

        //
        // Zero the memory.
        //

        VideoPortZeroDeviceMemory(HwDeviceExtension->VideoMemoryAddress, 0xFFFF);

        VgaInterpretCmdStream(HwDeviceExtension, DisableA000Color);
        VideoDebugPrint((1, "VgaZeroVideoMemory - exit et4000\n"));
    }
}


VOID
VgaValidateModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Determines which modes are valid and which are not.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/
{

    ULONG i;

    HwDeviceExtension->NumAvailableModes = 0;

    VideoDebugPrint((2, "NumVideoModes(%d)\n",NumVideoModes));

    for (i = 0; i < NumVideoModes; i++) {

        if (ModesVGA[i].fbType & VIDEO_MODE_GRAPHICS) {

#if !defined(i386)
            if (ModesVGA[i].bitsPerPlane < 8) {

                //
                // no 16 color allowed on non x86
                //

                continue;

            }
#endif

            switch (HwDeviceExtension->ulChipID) {

                case ET6000:

                //
                // can do all modes
                //

                break;

            case W32P:

                //
                // Can't do 24bpp if banking, which this is.
                // Can't do modes below 640x480.
                //

                if ((ModesVGA[i].bitsPerPlane == 24) ||
                    (ModesVGA[i].vres < 480)) {

                    continue;

                }

                break;

            case W32I:
            case W32:

                //
                // Can't do 24bpp if banking, which this is,
                // or if resolution > 640x480.
                // Can't do modes below 640x480.
                //

                //
                // !!! fix this expression
                //

                if ((ModesVGA[i].bitsPerPlane == 24) ||
                    (ModesVGA[i].vres < 480) ||
                    ((ModesVGA[i].hres > 800) &&
                     (ModesVGA[i].bitsPerPlane > 8))) {

                    continue;

                }

                break;

            default:

                //
                // Can't do 1280x1024 or 24bpp.
                // Can't do modes below 640x480.
                //

                if ((ModesVGA[i].hres > 1024) ||
                    (ModesVGA[i].vres < 480) ||
                    (ModesVGA[i].bitsPerPlane > 16)) {

                    continue;

                }

                //
                // can't do 16bpp if resolution > 640x480
                //

                if ((ModesVGA[i].hres > 640) &&
                    (ModesVGA[i].bitsPerPlane > 8)) {

                    continue;

                }

                break;

            }

            if ((HwDeviceExtension->ulChipID != ET6000) &&
                (HwDeviceExtension->BoardID != STEALTH32)) {

                switch (ModesVGA[i].hres) {

                case 640:

                    if ((ModesVGA[i].Frequency == 90) ||
                        (ModesVGA[i].Frequency == 85) ||
                        (ModesVGA[i].Frequency == 75)) {

                         continue;

                    }

                    break;


                case 800:

                    if ((ModesVGA[i].Frequency == 90) ||
                        (ModesVGA[i].Frequency == 85) ||
                        (ModesVGA[i].Frequency == 75)) {

                         continue;

                    }

                    break;


                case 1024:

                    if ((ModesVGA[i].Frequency == 75) ||
                        (ModesVGA[i].Frequency == 72)) {

                         continue;

                    }

                    break;


                case 1280:

                    if ((ModesVGA[i].Frequency == 75) ||
                        (ModesVGA[i].Frequency == 72)) {

                         continue;

                    }

                    break;

                }
            }

            if (HwDeviceExtension->BoardID == PRODESIGNER2) {

                //
                // Original Pro designer 2 only supports
                //     640x480x60Hz
                //     800x600x56Hz
                //     1024x768x60Hz
                //

                if (ModesVGA[i].bitsPerPlane >= 16) {

                    continue;

                }

                if ( ((ModesVGA[i].hres == 640) && (ModesVGA[i].Frequency != 60)) ||
                     ((ModesVGA[i].hres == 800) && (ModesVGA[i].Frequency != 56)) ||
                     ((ModesVGA[i].hres == 1024) && (ModesVGA[i].Frequency != 60)) ) {

                    continue;

                }
            }

        }

        //
        // Do not support refresh rates with the EISA pro designer card.
        //

        if (HwDeviceExtension->BoardID == PRODESIGNERIISEISA) {

            ModesVGA[i].Frequency = 1;
            ModesVGA[i].Interlaced = 0;

        }

        //
        // Make modes that fit in video memory valid.
        //

        if (HwDeviceExtension->AdapterMemorySize >=
            ModesVGA[i].numPlanes * ModesVGA[i].sbytes) {

            ModesVGA[i].ValidMode = TRUE;
            HwDeviceExtension->NumAvailableModes++;
            VideoDebugPrint((2, "mode[%d] valid\n",i));
            VideoDebugPrint((2, "         hres(%d)\n",ModesVGA[i].hres));
            VideoDebugPrint((2, "         bitsPerPlane(%d)\n",ModesVGA[i].bitsPerPlane));
            VideoDebugPrint((2, "         freq(%d)\n",ModesVGA[i].Frequency));
            VideoDebugPrint((2, "         interlace(%d)\n",ModesVGA[i].Interlaced));
            VideoDebugPrint((2, "         numPlanes(%d)\n",ModesVGA[i].numPlanes));
            VideoDebugPrint((2, "         sbytes(%d)\n",ModesVGA[i].sbytes));
            VideoDebugPrint((2, "         memory reqd(%d)\n",ModesVGA[i].numPlanes * ModesVGA[i].sbytes));
            VideoDebugPrint((2, "         memory pres(%d)\n",HwDeviceExtension->AdapterMemorySize));

        } else {
            VideoDebugPrint((2, "mode[%d] invalid\n",i));
            VideoDebugPrint((2, "         hres(%d)\n",ModesVGA[i].hres));
            VideoDebugPrint((2, "         bitsPerPlane(%d)\n",ModesVGA[i].bitsPerPlane));
            VideoDebugPrint((2, "         freq(%d)\n",ModesVGA[i].Frequency));
            VideoDebugPrint((2, "         interlace(%d)\n",ModesVGA[i].Interlaced));
            VideoDebugPrint((2, "         numPlanes(%d)\n",ModesVGA[i].numPlanes));
            VideoDebugPrint((2, "         sbytes(%d)\n",ModesVGA[i].sbytes));
            VideoDebugPrint((2, "         memory reqd(%d)\n",ModesVGA[i].numPlanes * ModesVGA[i].sbytes));
            VideoDebugPrint((2, "         memory pres(%d)\n",HwDeviceExtension->AdapterMemorySize));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\16bpp\bankmgr.c ===
/*****************************************************************************\
* Smart 64k Color Bank Manager
*
* Copyright (c) 1992 Microsoft Corporation
\*****************************************************************************/

#include "driver.h"

/*****************************************************************************\
* pcoBankStart - Start the bank enumeration using the clip object.
*
* Used when the destination is the screen and we can't do the clipping
* ourselves (as we can for blt's).
\*****************************************************************************/

CLIPOBJ* pcoBankStart(
    PPDEV       ppdev,
    RECTL*      prclScans,
    SURFOBJ*    pso,
    CLIPOBJ*    pco)
{
    LONG iTopScan;

    // Remember what the last scan is that we're going to, and
    // make sure we only try to go as far as we need to.  It could
    // happen that when get a prclScans bigger than the screen:

    ppdev->iLastScan = min(prclScans->bottom, (LONG) ppdev->cyScreen);

    // Adjust for those weird cases where we're asked to start enumerating
    // above or below the bottom of the screen:

    iTopScan = max(0, prclScans->top);
    iTopScan = min(iTopScan, (LONG) ppdev->cyScreen - 1);

    if (pco->iDComplexity != DC_TRIVIAL)
    {
        iTopScan         = max(pco->rclBounds.top,    iTopScan);
        ppdev->iLastScan = min(pco->rclBounds.bottom, ppdev->iLastScan);
    }

    // Map in the top bank:

    if (iTopScan <  ppdev->rcl1WindowClip.top ||
        iTopScan >= ppdev->rcl1WindowClip.bottom)
    {
        ppdev->pfnBankControl(ppdev, iTopScan, JustifyTop);
    }

    pso->pvScan0 = ppdev->pvBitmapStart;

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        // The call may have come down to us as having no clipping, but
        // we have to clip to the banks, so use our own clip object:

        pco            = ppdev->pcoNull;
        pco->rclBounds = ppdev->rcl1WindowClip;

        ASSERTVGA(pco->fjOptions & OC_BANK_CLIP, "Default BANK_CLIP not set");
        ASSERTVGA(pco->iDComplexity == DC_RECT, "Default clip not DC_RECT");
    }
    else
    {
        // Save the engine's clip object data that we'll be tromping on:

        ppdev->rclSaveBounds    = pco->rclBounds;
        ppdev->iSaveDComplexity = pco->iDComplexity;
        ppdev->fjSaveOptions    = pco->fjOptions;

        // Let engine know it has to pay attention to the rclBounds of the
        // clip object:

        pco->fjOptions |= OC_BANK_CLIP;

        // Use the bank bounds if they are tighter than the existing
        // bounds.

        if (pco->rclBounds.top <= ppdev->rcl1WindowClip.top)
            pco->rclBounds.top = ppdev->rcl1WindowClip.top;

        if (pco->rclBounds.bottom >= ppdev->rcl1WindowClip.bottom)
            pco->rclBounds.bottom = ppdev->rcl1WindowClip.bottom;

        if ((pco->rclBounds.top  >= pco->rclBounds.bottom) ||
            (pco->rclBounds.left >= pco->rclBounds.right))
        {
            // It's conceivable that we could get a situation where our
            // draw rectangle is completely disjoint from the specified
            // rectangle's rclBounds.  Make sure we don't puke on our
            // shoes:

            pco->rclBounds.left   = 0;
            pco->rclBounds.top    = 0;
            pco->rclBounds.right  = 0;
            pco->rclBounds.bottom = 0;
            ppdev->iLastScan      = 0;
        }
    }

    return(pco);
}

/*****************************************************************************\
* bBankEnum - Continue the bank enumeration.
\*****************************************************************************/

BOOL bBankEnum(PPDEV ppdev, SURFOBJ* pso, CLIPOBJ* pco)
{
    LONG yNewTop = ppdev->rcl1WindowClip.bottom;

    if (yNewTop >= ppdev->iLastScan)
    {
        // Okay, that was the last bank, so restore our structures:

        if (pco != ppdev->pcoNull)
        {
            pco->rclBounds    = ppdev->rclSaveBounds;
            pco->iDComplexity = ppdev->iSaveDComplexity;
            pco->fjOptions    = ppdev->fjSaveOptions;
        }

        return(FALSE);
    }

    ppdev->pfnBankControl(ppdev, yNewTop, JustifyTop);

    ASSERTVGA(yNewTop >= ppdev->rcl1WindowClip.top &&
              yNewTop <  ppdev->rcl1WindowClip.bottom, "Out of bounds");

    // Adjust the pvScan0 because we've moved the window to view
    // a different area:

    pso->pvScan0 = ppdev->pvBitmapStart;

    // Set the bounds to the new bank:

    pco->rclBounds.top    = yNewTop;
    pco->rclBounds.left   = ppdev->rcl1WindowClip.left;
    pco->rclBounds.bottom = ppdev->rcl1WindowClip.bottom;
    pco->rclBounds.right  = ppdev->rcl1WindowClip.right;

    if (pco != ppdev->pcoNull)
    {
        // If we were originally given a non-trivial clip object, we have
        // to clip to the original bounds:

        if (pco->rclBounds.left <= ppdev->rclSaveBounds.left)
            pco->rclBounds.left  = ppdev->rclSaveBounds.left;

        if (pco->rclBounds.right >= ppdev->rclSaveBounds.right)
            pco->rclBounds.right  = ppdev->rclSaveBounds.right;

        if (pco->rclBounds.bottom >= ppdev->rclSaveBounds.bottom)
            pco->rclBounds.bottom  = ppdev->rclSaveBounds.bottom;
    }

    return(TRUE);
}

/***************************************************************************\
* vBankStartBltSrc - Start the bank enumeration for when the screen is
*                   the source.
\***************************************************************************/

VOID vBankStartBltSrc(
    PPDEV       ppdev,
    SURFOBJ*    pso,
    POINTL*     pptlSrc,
    RECTL*      prclDest,
    POINTL*     pptlNewSrc,
    RECTL*      prclNewDest)
{
    LONG xRightSrc;
    LONG yBottomSrc;
    LONG iTopScan = max(0, pptlSrc->y);

    if (iTopScan >= (LONG) ppdev->cyScreen)
    {
    // In some instances we may be asked to start on a scan below the screen.
    // Since we obviously won't be drawing anything, don't bother mapping in
    // a bank:

        return;
    }

    // Map in the bank:

    if (iTopScan <  ppdev->rcl1WindowClip.top ||
        iTopScan >= ppdev->rcl1WindowClip.bottom)
    {
        ppdev->pfnBankControl(ppdev, iTopScan, JustifyTop);
    }

    if (ppdev->rcl1WindowClip.right <= pptlSrc->x)
    {
    // We have to watch out for those rare cases where we're starting
    // on a broken raster and we won't be drawing on the first part:

        ASSERTVGA(ppdev->flBank & BANK_BROKEN_RASTER1, "Weird start bounds");

        ppdev->pfnBankNext(ppdev);
    }

    pso->pvScan0 = ppdev->pvBitmapStart;

    // Adjust the source:

    pptlNewSrc->x = pptlSrc->x;
    pptlNewSrc->y = pptlSrc->y;

    // Adjust the destination:

    prclNewDest->left = prclDest->left;
    prclNewDest->top  = prclDest->top;

    yBottomSrc = pptlSrc->y + prclDest->bottom - prclDest->top;
    prclNewDest->bottom = min(ppdev->rcl1WindowClip.bottom, yBottomSrc);
    prclNewDest->bottom += prclDest->top - pptlSrc->y;

    xRightSrc = pptlSrc->x + prclDest->right - prclDest->left;
    prclNewDest->right = min(ppdev->rcl1WindowClip.right, xRightSrc);
    prclNewDest->right += prclDest->left - pptlSrc->x;
}

/***************************************************************************\
* bBankEnumBltSrc - Continue the bank enumeration for when the screen is
*                   the source.
\***************************************************************************/

BOOL bBankEnumBltSrc(
    PPDEV       ppdev,
    SURFOBJ*    pso,
    POINTL*     pptlSrc,
    RECTL*      prclDest,
    POINTL*     pptlNewSrc,
    RECTL*      prclNewDest)
{
    LONG xLeftSrc;
    LONG xRightSrc;
    LONG yBottomSrc;

    LONG cx = prclDest->right  - prclDest->left;
    LONG cy = prclDest->bottom - prclDest->top;

    LONG dx;
    LONG dy;

    LONG yBottom = min(pptlSrc->y + cy, (LONG) ppdev->cyScreen);
    LONG yNewTop = ppdev->rcl1WindowClip.bottom;

    if (ppdev->flBank & BANK_BROKEN_RASTER1)
    {
        ppdev->pfnBankNext(ppdev);
        if (ppdev->rcl1WindowClip.left >= pptlSrc->x + cx)
        {
            if (ppdev->rcl1WindowClip.bottom < yBottom)
                ppdev->pfnBankNext(ppdev);
            else
            {
                // We're done:

                return(FALSE);
            }
        }
    }
    else if (yNewTop < yBottom)
    {
        ppdev->pfnBankControl(ppdev, yNewTop, JustifyTop);
        if (ppdev->rcl1WindowClip.right <= pptlSrc->x)
        {
            ASSERTVGA(ppdev->flBank & BANK_BROKEN_RASTER1, "Weird bounds");
            ppdev->pfnBankNext(ppdev);
        }
    }
    else
    {
        // We're done:

        return(FALSE);
    }

    // Adjust the source:

    pso->pvScan0 = ppdev->pvBitmapStart;

    pptlNewSrc->x = max(ppdev->rcl1WindowClip.left, pptlSrc->x);
    pptlNewSrc->y = yNewTop;

    // Adjust the destination:

    dy = prclDest->top - pptlSrc->y;        // y delta from source to dest

    prclNewDest->top = yNewTop + dy;

    yBottomSrc = pptlSrc->y + cy;
    prclNewDest->bottom = min(ppdev->rcl1WindowClip.bottom, yBottomSrc) + dy;

    dx = prclDest->left - pptlSrc->x;       // x delta from source to dest

    xLeftSrc = pptlSrc->x;
    prclNewDest->left = pptlNewSrc->x + dx;

    xRightSrc = pptlSrc->x + cx;
    prclNewDest->right = min(ppdev->rcl1WindowClip.right, xRightSrc) + dx;

    return(TRUE);
}

/***************************************************************************\
* vBankStartBltDest - Start the bank enumeration for when the screen is
*                     the destination.
\***************************************************************************/

VOID vBankStartBltDest(
    PPDEV       ppdev,
    SURFOBJ*    pso,
    POINTL*     pptlSrc,
    RECTL*      prclDest,
    POINTL*     pptlNewSrc,
    RECTL*      prclNewDest)
{
    LONG iTopScan = max(0, prclDest->top);

    if (iTopScan >= (LONG) ppdev->cyScreen)
    {
    // In some instances we may be asked to start on a scan below the screen.
    // Since we obviously won't be drawing anything, don't bother mapping in
    // a bank:

        return;
    }

    // Map in the bank:

    if (iTopScan <  ppdev->rcl1WindowClip.top ||
        iTopScan >= ppdev->rcl1WindowClip.bottom)
    {
        ppdev->pfnBankControl(ppdev, iTopScan, JustifyTop);
    }

    if (ppdev->rcl1WindowClip.right <= prclDest->left)
    {
    // We have to watch out for those rare cases where we're starting
    // on a broken raster and we won't be drawing on the first part:

        ASSERTVGA(ppdev->flBank & BANK_BROKEN_RASTER1, "Weird start bounds");
        ppdev->pfnBankNext(ppdev);
    }

    pso->pvScan0 = ppdev->pvBitmapStart;

    // Adjust the destination:

    prclNewDest->left   = prclDest->left;
    prclNewDest->top    = prclDest->top;
    prclNewDest->bottom = min(ppdev->rcl1WindowClip.bottom, prclDest->bottom);
    prclNewDest->right  = min(ppdev->rcl1WindowClip.right,  prclDest->right);

    // Adjust the source if there is one:

    if (pptlSrc != NULL)
        *pptlNewSrc = *pptlSrc;
}

/***************************************************************************\
* bBankEnumBltDest - Continue the bank enumeration for when the screen is
*                   the destination.
\***************************************************************************/

BOOL bBankEnumBltDest(
    PPDEV       ppdev,
    SURFOBJ*    pso,
    POINTL*     pptlSrc,
    RECTL*      prclDest,
    POINTL*     pptlNewSrc,
    RECTL*      prclNewDest)
{
    LONG yBottom = min(prclDest->bottom, (LONG) ppdev->cyScreen);
    LONG yNewTop = ppdev->rcl1WindowClip.bottom;

    if (ppdev->flBank & BANK_BROKEN_RASTER1)
    {
        ppdev->pfnBankNext(ppdev);
        if (ppdev->rcl1WindowClip.left >= prclDest->right)
        {
            if (ppdev->rcl1WindowClip.bottom < yBottom)
                ppdev->pfnBankNext(ppdev);
            else
            {
                // We're done:

                return(FALSE);
            }
        }
    }
    else if (yNewTop < yBottom)
    {
        ppdev->pfnBankControl(ppdev, yNewTop, JustifyTop);
        if (ppdev->rcl1WindowClip.right <= prclDest->left)
        {
            ASSERTVGA(ppdev->flBank & BANK_BROKEN_RASTER1, "Weird bounds");
            ppdev->pfnBankNext(ppdev);
        }
    }
    else
    {
        // We're done:

        return(FALSE);
    }

    pso->pvScan0 = ppdev->pvBitmapStart;

    // Adjust the destination:

    prclNewDest->top    = yNewTop;
    prclNewDest->left   = max(ppdev->rcl1WindowClip.left,   prclDest->left);
    prclNewDest->bottom = min(ppdev->rcl1WindowClip.bottom, prclDest->bottom);
    prclNewDest->right  = min(ppdev->rcl1WindowClip.right,  prclDest->right);

    // Adjust the source if there is one:

    if (pptlSrc != NULL)
    {
        pptlNewSrc->x = pptlSrc->x + (prclNewDest->left - prclDest->left);
        pptlNewSrc->y = pptlSrc->y + (prclNewDest->top  - prclDest->top);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\tseng\mini\i386\et4hard.asm ===
title  "ET4000 ASM routines"
;++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;     vgahard.asm
;
; Abstract:
;
;     This module implements the baning code for the et4000.
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;
;--

.386p
        .xlist
include callconv.inc
        .list

;---------------------------------------
;
; ET4000 banking control port.
;

SEGMENT_SELECT_PORT_LO equ     03cdh      ;banking control here
SEGMENT_SELECT_PORT_HI equ     03cbh      ;banking control here
SEQ_ADDRESS_PORT       equ     03C4h      ;Sequencer Address register
IND_MEMORY_MODE        equ     04h        ;Memory Mode register index in Sequencer
CHAIN4_MASK            equ     08h        ;Chain4 bit in Memory Mode register

;---------------------------------------

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
;
;    Bank switching code. This is a 1-64K-read/1-64K-write bank adapter
;    (VideoBanked1R1W).
;
;    Input:
;          EAX = desired read bank mapping
;          EDX = desired write bank mapping
;
;    Note: values must be correct, with no stray bits set; no error
;       checking is performed.
;
        public _BankSwitchStart, _BankSwitchEnd, _PlanarHCBankSwitchStart
        public _EnablePlanarHCStart, _DisablePlanarHCStart
        align 4

_BankSwitchStart proc                      ;start of bank switch code
_PlanarHCBankSwitchStart:                  ;start of planar HC bank switch code,
                                           ; which is the same code as normal
                                           ; bank switching
        mov     ah, al
        mov     dh, dl
        and     al, 0fh
        and     dl, 0fh
        shl     al, 4
        or      al, dl
                                           ; in bits 3-0
        mov     dx,SEGMENT_SELECT_PORT_LO  ;banking control port
        out     dx,al                      ;select the banks

        mov     al, ah
        mov     dl, dh
        and     al, 30h
        and     dl, 30h
        shr     dl, 4

        mov     dx, SEGMENT_SELECT_PORT_HI
        out     dx, al

        ret

        align 4
_EnablePlanarHCStart:
        mov     dx,SEQ_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the state of the Seq Address
        mov     al,IND_MEMORY_MODE
        out     dx,al                   ;point to the Memory Mode register
        inc     edx
        in      al,dx                   ;get the state of the Memory Mode reg
        and     al,NOT CHAIN4_MASK      ;turn off Chain4 to make memory planar
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Seq Address
        ret

        align 4
_DisablePlanarHCStart:
        mov     dx,SEQ_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the state of the Seq Address
        mov     al,IND_MEMORY_MODE
        out     dx,al                   ;point to the Memory Mode register
        inc     edx
        in      al,dx                   ;get the state of the Memory Mode reg
        or      al,CHAIN4_MASK          ;turn on Chain4 to make memory linear
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Seq Address
        ret

;
;    Just here to generate end-of-bank-switch code label.
;

_BankSwitchEnd:

_BankSwitchStart endp


_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\16bpp\bitblt.c ===
/******************************Module*Header*******************************\
* Module Name: bitblt.c
*
* Banked Frame Buffer bitblit
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

/************************************************************************\
* bIntersectRect
*
* Calculates the intersection between *prcSrc1 and *prcSrc2,
* returning the resulting rect in *prcDst.  Returns TRUE if
* *prcSrc1 intersects *prcSrc2, FALSE otherwise.  If there is no
* intersection, an empty rect is returned in *prcDst.
\************************************************************************/

static const RECTL rclEmpty = { 0, 0, 0, 0 };

BOOL bIntersectRect(
    PRECTL prcDst,
    PRECTL prcSrc1,
    PRECTL prcSrc2)

{
    prcDst->left  = max(prcSrc1->left, prcSrc2->left);
    prcDst->right = min(prcSrc1->right, prcSrc2->right);

    // check for empty rect

    if (prcDst->left < prcDst->right)
    {
        prcDst->top    = max(prcSrc1->top, prcSrc2->top);
        prcDst->bottom = min(prcSrc1->bottom, prcSrc2->bottom);

        // check for empty rect

        if (prcDst->top < prcDst->bottom)
            return(TRUE);        // not empty
    }

    // empty rect

    *prcDst = rclEmpty;

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bPuntScreenToScreenCopyBits(ppdev, pco, pxlo, prclDest, pptlSrc)
*
* Performs a screen-to-screen CopyBits entirely using an intermediate
* temporary buffer and GDI.
*
* We found that on most machines it was faster to have the engine copy
* the source to a buffer, then blit the buffer to the destination, than
* to have optimized ASM code that copies a word at a time.  The reason?
* The engine does d-word moves, which are faster than word moves even
* going over the bus to a 16 bit display device.
*
* We could also write optimized ASM code that does d-word moves, but the
* win will be marginal, we're time constrained, we also need a routine
* like this to handle complex clip objects and palette translates, and
* most of the other times we can use planar copies for important things
* like scrolls, anyways.
*
\**************************************************************************/

BOOL bPuntScreenToScreenCopyBits(
PPDEV     ppdev,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDest,
POINTL*   pptlSrc)
{
    RECTL    rclDest;
    POINTL   ptlSrc;
    BOOL     b = TRUE;

    SURFOBJ* pso    = ppdev->pSurfObj;
    SURFOBJ* psoTmp = ppdev->psoTmp;

    if (prclDest->top < pptlSrc->y)
    {
        ////////////////////////////////////////////////////////////////
        // Do a top-to-bottom copy:
        ////////////////////////////////////////////////////////////////

        LONG ySrcBottom;
        LONG yDestBottom;

        LONG yDestTop = prclDest->top;
        LONG ySrcTop  = pptlSrc->y;
        LONG ySrcLast = ySrcTop + (prclDest->bottom - prclDest->top);

        if (ySrcTop <  ppdev->rcl1WindowClip.top ||
            ySrcTop >= ppdev->rcl1WindowClip.bottom)
        {
            ppdev->pfnBankControl(ppdev, ySrcTop, JustifyTop);
        }

        pso->pvScan0 = ppdev->pvBitmapStart;

        while (TRUE)
        {
            // Copy an entire source bank into the temporary buffer:

            ySrcBottom     = min(ySrcLast, ppdev->rcl1WindowClip.bottom);

            ptlSrc.x       = pptlSrc->x;
            ptlSrc.y       = ySrcTop;

            rclDest.left   = prclDest->left;
            rclDest.top    = 0;
            rclDest.right  = prclDest->right;
            rclDest.bottom = ySrcBottom - ySrcTop;

            b &= EngCopyBits(psoTmp, pso, NULL, NULL, &rclDest, &ptlSrc);

            yDestBottom = yDestTop + rclDest.bottom;

            if (ppdev->rcl1WindowClip.top >= yDestBottom)
            {
                ppdev->pfnBankControl(ppdev, yDestBottom - 1, JustifyBottom);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            while (TRUE)
            {
                // Copy the temporary buffer into one or more destination
                // banks:

                LONG yThisTop;
                LONG yThisBottom;
                LONG yOffset;

                yThisBottom    = min(yDestBottom, ppdev->rcl1WindowClip.bottom);
                yThisTop       = max(yDestTop, ppdev->rcl1WindowClip.top);
                yOffset        = yThisTop - yDestTop;

                ptlSrc.x       = prclDest->left;
                ptlSrc.y       = yOffset;

                rclDest.left   = prclDest->left;
                rclDest.top    = yThisTop;
                rclDest.right  = prclDest->right;
                rclDest.bottom = yThisBottom;

                b &= EngCopyBits(pso, psoTmp, pco, pxlo, &rclDest, &ptlSrc);

                if (yOffset == 0)
                    break;

                ppdev->pfnBankControl(ppdev, yThisTop - 1, JustifyBottom);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            if (ySrcBottom >= ySrcLast)
                break;

            yDestTop = yDestBottom;
            ySrcTop  = ySrcBottom;

            ppdev->pfnBankControl(ppdev, ySrcTop, JustifyTop);
            pso->pvScan0 = ppdev->pvBitmapStart;
        }
    }
    else
    {
        ////////////////////////////////////////////////////////////////
        // Do a bottom-to-top copy:
        ////////////////////////////////////////////////////////////////

        LONG ySrcTop;
        LONG yDestTop;

        LONG yDestBottom = prclDest->bottom;
        LONG ySrcFirst   = pptlSrc->y;
        LONG ySrcBottom  = ySrcFirst + (prclDest->bottom - prclDest->top);

        if (ySrcBottom <= ppdev->rcl1WindowClip.top ||
            ySrcBottom > ppdev->rcl1WindowClip.bottom)
        {
            ppdev->pfnBankControl(ppdev, ySrcBottom - 1, JustifyBottom);
        }

        pso->pvScan0 = ppdev->pvBitmapStart;

        while (TRUE)
        {
            // Copy an entire source bank into the temporary buffer:

            ySrcTop        = max(ySrcFirst, ppdev->rcl1WindowClip.top);

            ptlSrc.x       = pptlSrc->x;
            ptlSrc.y       = ySrcTop;

            rclDest.left   = prclDest->left;
            rclDest.top    = 0;
            rclDest.right  = prclDest->right;
            rclDest.bottom = ySrcBottom - ySrcTop;

            b &= EngCopyBits(psoTmp, pso, NULL, NULL, &rclDest, &ptlSrc);

            yDestTop = yDestBottom - rclDest.bottom;

            if (ppdev->rcl1WindowClip.bottom <= yDestTop)
            {
                ppdev->pfnBankControl(ppdev, yDestTop, JustifyTop);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            while (TRUE)
            {
                // Copy the temporary buffer into one or more destination
                // banks:

                LONG yThisTop;
                LONG yThisBottom;
                LONG yOffset;

                yThisTop       = max(yDestTop, ppdev->rcl1WindowClip.top);
                yThisBottom    = min(yDestBottom, ppdev->rcl1WindowClip.bottom);
                yOffset        = yThisTop - yDestTop;

                ptlSrc.x       = prclDest->left;
                ptlSrc.y       = yOffset;

                rclDest.left   = prclDest->left;
                rclDest.top    = yThisTop;
                rclDest.right  = prclDest->right;
                rclDest.bottom = yThisBottom;

                b &= EngCopyBits(pso, psoTmp, pco, pxlo, &rclDest, &ptlSrc);

                if (yThisBottom == yDestBottom)
                    break;

                ppdev->pfnBankControl(ppdev, yThisBottom, JustifyTop);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            if (ySrcTop <= ySrcFirst)
                break;

            yDestBottom = yDestTop;
            ySrcBottom  = ySrcTop;

            ppdev->pfnBankControl(ppdev, ySrcBottom - 1, JustifyBottom);
            pso->pvScan0 = ppdev->pvBitmapStart;
        }
    }

    return(b);
}

/******************************Public*Routine******************************\
* BOOL bPuntScreenToScreenBitBlt(...)
*
* Performs a screen-to-screen BitBlt entirely using an intermediate temporary
* buffer and GDI.
*
* This function is basically a clone of bPuntScreenToScreenCopyBits,
* except that it can handle funky ROPs and stuff.
\**************************************************************************/

BOOL bPuntScreenToScreenBitBlt(
PPDEV     ppdev,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDest,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    RECTL    rclDest;           // Temporary destination rectangle
    POINTL   ptlSrc;            // Temporary source point
    POINTL   ptlMask;           // Temporary mask offset
    POINTL   ptlMaskAdjust;     // Adjustment for mask offset
    BOOL     b = TRUE;

    SURFOBJ* pso    = ppdev->pSurfObj;
    SURFOBJ* psoTmp = ppdev->psoTmp;

    if (psoMask != NULL)
    {
        ptlMaskAdjust.x = prclDest->left - pptlMask->x;
        ptlMaskAdjust.y = prclDest->top  - pptlMask->y;
    }

    if (prclDest->top < pptlSrc->y)
    {
        ////////////////////////////////////////////////////////////////
        // Do a top-to-bottom copy:
        ////////////////////////////////////////////////////////////////

        LONG ySrcBottom;
        LONG yDestBottom;

        LONG yDestTop = prclDest->top;
        LONG ySrcTop  = pptlSrc->y;
        LONG ySrcLast = ySrcTop + (prclDest->bottom - prclDest->top);

        if (ySrcTop <  ppdev->rcl1WindowClip.top ||
            ySrcTop >= ppdev->rcl1WindowClip.bottom)
        {
            ppdev->pfnBankControl(ppdev, ySrcTop, JustifyTop);
        }

        pso->pvScan0 = ppdev->pvBitmapStart;

        while (TRUE)
        {
            // Copy an entire source bank into the temporary buffer:

            ySrcBottom     = min(ySrcLast, ppdev->rcl1WindowClip.bottom);

            ptlSrc.x       = pptlSrc->x;
            ptlSrc.y       = ySrcTop;

            rclDest.left   = prclDest->left;
            rclDest.top    = 0;
            rclDest.right  = prclDest->right;
            rclDest.bottom = ySrcBottom - ySrcTop;

            b &= EngCopyBits(psoTmp, pso, NULL, NULL, &rclDest, &ptlSrc);

            yDestBottom = yDestTop + rclDest.bottom;

            if (ppdev->rcl1WindowClip.top >= yDestBottom)
            {
                ppdev->pfnBankControl(ppdev, yDestBottom - 1, JustifyBottom);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            while (TRUE)
            {
                // Copy the temporary buffer into one or more destination
                // banks:

                LONG yThisTop;
                LONG yThisBottom;
                LONG yOffset;

                yThisBottom    = min(yDestBottom, ppdev->rcl1WindowClip.bottom);
                yThisTop       = max(yDestTop, ppdev->rcl1WindowClip.top);
                yOffset        = yThisTop - yDestTop;

                ptlSrc.x       = prclDest->left;
                ptlSrc.y       = yOffset;

                rclDest.left   = prclDest->left;
                rclDest.top    = yThisTop;
                rclDest.right  = prclDest->right;
                rclDest.bottom = yThisBottom;

                ptlMask.x = rclDest.left - ptlMaskAdjust.x;
                ptlMask.y = rclDest.top  - ptlMaskAdjust.y;

                b &= EngBitBlt(pso, psoTmp, psoMask, pco, pxlo, &rclDest,
                               &ptlSrc, &ptlMask, pbo, pptlBrush, rop4);

                if (yOffset == 0)
                    break;

                ppdev->pfnBankControl(ppdev, yThisTop - 1, JustifyBottom);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            if (ySrcBottom >= ySrcLast)
                break;

            yDestTop = yDestBottom;
            ySrcTop  = ySrcBottom;

            ppdev->pfnBankControl(ppdev, ySrcTop, JustifyTop);
            pso->pvScan0 = ppdev->pvBitmapStart;
        }
    }
    else
    {
        ////////////////////////////////////////////////////////////////
        // Do a bottom-to-top copy:
        ////////////////////////////////////////////////////////////////

        LONG ySrcTop;
        LONG yDestTop;

        LONG yDestBottom = prclDest->bottom;
        LONG ySrcFirst   = pptlSrc->y;
        LONG ySrcBottom  = ySrcFirst + (prclDest->bottom - prclDest->top);

        if (ySrcBottom <= ppdev->rcl1WindowClip.top ||
            ySrcBottom > ppdev->rcl1WindowClip.bottom)
        {
            ppdev->pfnBankControl(ppdev, ySrcBottom - 1, JustifyBottom);
        }

        pso->pvScan0 = ppdev->pvBitmapStart;

        while (TRUE)
        {
            // Copy an entire source bank into the temporary buffer:

            ySrcTop        = max(ySrcFirst, ppdev->rcl1WindowClip.top);

            ptlSrc.x       = pptlSrc->x;
            ptlSrc.y       = ySrcTop;

            rclDest.left   = prclDest->left;
            rclDest.top    = 0;
            rclDest.right  = prclDest->right;
            rclDest.bottom = ySrcBottom - ySrcTop;

            b &= EngCopyBits(psoTmp, pso, NULL, NULL, &rclDest, &ptlSrc);

            yDestTop = yDestBottom - rclDest.bottom;

            if (ppdev->rcl1WindowClip.bottom <= yDestTop)
            {
                ppdev->pfnBankControl(ppdev, yDestTop, JustifyTop);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            while (TRUE)
            {
                // Copy the temporary buffer into one or more destination
                // banks:

                LONG yThisTop;
                LONG yThisBottom;
                LONG yOffset;

                yThisTop       = max(yDestTop, ppdev->rcl1WindowClip.top);
                yThisBottom    = min(yDestBottom, ppdev->rcl1WindowClip.bottom);
                yOffset        = yThisTop - yDestTop;

                ptlSrc.x       = prclDest->left;
                ptlSrc.y       = yOffset;

                rclDest.left   = prclDest->left;
                rclDest.top    = yThisTop;
                rclDest.right  = prclDest->right;
                rclDest.bottom = yThisBottom;

                ptlMask.x = rclDest.left - ptlMaskAdjust.x;
                ptlMask.y = rclDest.top  - ptlMaskAdjust.y;

                b &= EngBitBlt(pso, psoTmp, psoMask, pco, pxlo, &rclDest,
                               &ptlSrc, &ptlMask, pbo, pptlBrush, rop4);

                if (yThisBottom == yDestBottom)
                    break;

                ppdev->pfnBankControl(ppdev, yThisBottom, JustifyTop);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            if (ySrcTop <= ySrcFirst)
                break;

            yDestBottom = yDestTop;
            ySrcBottom  = ySrcTop;

            ppdev->pfnBankControl(ppdev, ySrcBottom - 1, JustifyBottom);
            pso->pvScan0 = ppdev->pvBitmapStart;
        }
    }

    return(b);
}

/******************************Public*Data*********************************\
* ROP to mix translation table
*
* Table to translate ternary raster ops to mixes (binary raster ops). Ternary
* raster ops that can't be translated to mixes are translated to 0 (0 is not
* a valid mix).
*
\**************************************************************************/

UCHAR jRop3ToMix[256] = {
    R2_BLACK, 0, 0, 0, 0, R2_NOTMERGEPEN, 0, 0,
    0, 0, R2_MASKNOTPEN, 0, 0, 0, 0, R2_NOTCOPYPEN,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    R2_MASKPENNOT, 0, 0, 0, 0, R2_NOT, 0, 0,
    0, 0, R2_XORPEN, 0, 0, 0, 0, R2_NOTMASKPEN,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    R2_MASKPEN, 0, 0, 0, 0, R2_NOTXORPEN, 0, 0,
    0, 0, R2_NOP, 0, 0, 0, 0, R2_MERGENOTPEN,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    R2_COPYPEN, 0, 0, 0, 0, R2_MERGEPENNOT, 0, 0,
    0, 0, R2_MERGEPEN, 0, 0, 0, 0, R2_WHITE
};

/******************************Public*Routine******************************\
* BOOL DrvBitBlt(psoDest, psoSrc, psoMask, pco, pxlo, prclDest, pptlSrc,
*                pptlMask, pbo, pptlBrush, rop4)
*
* This routine will handle any blit.  Perhaps glacially, but it will be
* handled.
\**************************************************************************/

BOOL DrvBitBlt(
SURFOBJ*  psoDest,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDest,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL     b;
    POINTL   ptlSrc;
    RECTL    rclDest;
    PPDEV    ppdev;
    SURFOBJ* pso;
    BYTE     jClipping;
    RECTL    rclTmp;
    POINTL   ptlTmp;
    BBENUM   bben;          // Clip enumerator
    BOOL     bMore;         // Clip continuation flag
    POINTL   ptlMask;       // Temporary mask for engine call-backs
    POINTL   ptlMaskAdjust; // Adjustment for mask
    INT      iCopyDir;

    // Set up the clipping type
    if (pco == (CLIPOBJ *) NULL) {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    } else {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    // Get the correct surface object for the target and the source

    if (psoDest->iType == STYPE_DEVICE) {

        if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE)) {

            ////////////////////////////////////////////////////////////////
            // BitBlt screen-to-screen:
            ////////////////////////////////////////////////////////////////

            ppdev = (PPDEV) psoDest->dhsurf;

            // See if we can do a simple CopyBits:

            if (rop4 == 0x0000CCCC)
            {
                ppdev = (PPDEV) psoDest->dhsurf;

                // We can handle quadpixel-aligned screen-to-screen blts with
                // no translation:

                if ((((pptlSrc->x ^ prclDest->left) & 1) == 0) &&
                    (ppdev->fl & DRIVER_PLANAR_CAPABLE) &&
                    ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
                {
                    switch(jClipping)
                    {
                    case DC_TRIVIAL:
                        vPlanarCopyBits(ppdev, prclDest, pptlSrc);
                        return(TRUE);

                    case DC_RECT:

                        // Clip the target rectangle to the clip rectangle:

                        if (!bIntersectRect(&rclTmp, prclDest, &pco->rclBounds))
                        {
                            DISPDBG((0, "DrvBitBlt: Nothing to draw."));
                            return(TRUE);
                        }

                        ptlTmp.x = pptlSrc->x + rclTmp.left - prclDest->left;
                        ptlTmp.y = pptlSrc->y + rclTmp.top  - prclDest->top;

                        vPlanarCopyBits(ppdev, &rclTmp, &ptlTmp);
                        return(TRUE);

                    case DC_COMPLEX:
                        if (pptlSrc->y >= prclDest->top)
                        {
                            if (pptlSrc->x >= prclDest->left)
                                iCopyDir = CD_RIGHTDOWN;
                            else
                                iCopyDir = CD_LEFTDOWN;
                        }
                        else
                        {
                            if (pptlSrc->x >= prclDest->left)
                                iCopyDir = CD_RIGHTUP;
                            else
                                iCopyDir = CD_LEFTUP;
                        }

                        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, iCopyDir, 0);

                        do {
                            RECTL* prcl;
                            RECTL* prclEnd;

                            bMore = CLIPOBJ_bEnum(pco, (ULONG) sizeof(bben),
                                                  (PVOID) &bben);

                            prclEnd = &bben.arcl[bben.c];
                            for (prcl = bben.arcl; prcl < prclEnd; prcl++)
                            {
                                if (bIntersectRect(prcl, prclDest, prcl))
                                {
                                    ptlTmp.x = pptlSrc->x + prcl->left - prclDest->left;
                                    ptlTmp.y = pptlSrc->y + prcl->top  - prclDest->top;

                                    vPlanarCopyBits(ppdev, prcl, &ptlTmp);
                                }
                            }
                        } while (bMore);

                        return(TRUE);
                    }
                }

                // Can't handle in hardware, so punt:

                return(bPuntScreenToScreenCopyBits(ppdev,
                                                   pco,
                                                   pxlo,
                                                   prclDest,
                                                   pptlSrc));
            }

            // It's more complicated than a CopyBits, so punt it:

            return(bPuntScreenToScreenBitBlt(ppdev,
                                             psoMask,
                                             pco,
                                             pxlo,
                                             prclDest,
                                             pptlSrc,
                                             pptlMask,
                                             pbo,
                                             pptlBrush,
                                             rop4));
        }

        ////////////////////////////////////////////////////////////////
        // BitBlt to screen:
        ////////////////////////////////////////////////////////////////

        ppdev = (PPDEV) psoDest->dhsurf;

        // Punt the memory-to-screen call back to the engine:

        if (psoMask != NULL)
        {
            ptlMaskAdjust.x = prclDest->left - pptlMask->x;
            ptlMaskAdjust.y = prclDest->top  - pptlMask->y;
        }

        pso = ppdev->pSurfObj;

        vBankStartBltDest(ppdev, pso, pptlSrc, prclDest, &ptlSrc, &rclDest);

        do {
            ptlMask.x = rclDest.left - ptlMaskAdjust.x;
            ptlMask.y = rclDest.top  - ptlMaskAdjust.y;

            b = EngBitBlt(pso,
                          psoSrc,
                          psoMask,
                          pco,
                          pxlo,
                          &rclDest,
                          &ptlSrc,
                          &ptlMask,
                          pbo,
                          pptlBrush,
                          rop4);

        } while (b && bBankEnumBltDest(ppdev, pso, pptlSrc, prclDest,
                                       &ptlSrc, &rclDest));

        return(b);
    }
    else if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE))
    {
        ////////////////////////////////////////////////////////////////
        // BitBlt from screen:
        ////////////////////////////////////////////////////////////////

        if (psoMask != NULL)
        {
            ptlMaskAdjust.x = prclDest->left - pptlMask->x;
            ptlMaskAdjust.y = prclDest->top  - pptlMask->y;
        }

        ppdev = (PPDEV) psoSrc->dhsurf;
        pso   = ppdev->pSurfObj;

        vBankStartBltSrc(ppdev, pso, pptlSrc, prclDest, &ptlSrc, &rclDest);

        do {
            ptlMask.x = rclDest.left - ptlMaskAdjust.x;
            ptlMask.y = rclDest.top  - ptlMaskAdjust.y;

            b = EngBitBlt(psoDest,
                          pso,
                          psoMask,
                          pco,
                          pxlo,
                          &rclDest,
                          &ptlSrc,
                          &ptlMask,
                          pbo,
                          pptlBrush,
                          rop4);

        } while (b && bBankEnumBltSrc(ppdev, pso, pptlSrc, prclDest,
                                      &ptlSrc, &rclDest));

        return(b);
    }

    RIP("Got a funky format?");
    return(FALSE);
}

/***************************************************************************\
* DrvCopyBits
\***************************************************************************/

BOOL DrvCopyBits(
SURFOBJ*  psoDest,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDest,
POINTL*   pptlSrc)
{
    BOOL     b;
    POINTL   ptlSrc;
    RECTL    rclDest;
    PPDEV    ppdev;
    SURFOBJ* pso;
    BBENUM   bben;
    BOOL     bMore;
    BYTE     jClipping;
    POINTL   ptlTmp;
    RECTL    rclTmp;
    INT      iCopyDir;

    // Get the correct surface object for the target and the source

    if (psoDest->iType == STYPE_DEVICE)
    {
        // We have to special case screen-to-screen operations:

        if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE))
        {

            ////////////////////////////////////////////////////////////////
            // CopyBits screen-to-screen:
            ////////////////////////////////////////////////////////////////

            ppdev = (PPDEV) psoDest->dhsurf;

            // We check to see if we can do a planar copy, because usually
            // it will be faster.  But the hardware has to be capable of
            // doing it, and the source and destination must be 4-pel
            // aligned.

            if ((((pptlSrc->x ^ prclDest->left) & 1) == 0) &&
                (ppdev->fl & DRIVER_PLANAR_CAPABLE) &&
                ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
            {
                jClipping = (pco != NULL) ? pco->iDComplexity : DC_TRIVIAL;

                switch(jClipping)
                {
                case DC_TRIVIAL:
                    vPlanarCopyBits(ppdev, prclDest, pptlSrc);
                    return(TRUE);

                case DC_RECT:
                    // Clip the target rectangle to the clip rectangle:

                    if (!bIntersectRect(&rclTmp, prclDest, &pco->rclBounds))
                    {
                        DISPDBG((0, "DrvCopyBits: Nothing to draw."));
                        return(TRUE);
                    }

                    ptlTmp.x = pptlSrc->x + rclTmp.left - prclDest->left;
                    ptlTmp.y = pptlSrc->y + rclTmp.top  - prclDest->top;

                    vPlanarCopyBits(ppdev, &rclTmp, &ptlTmp);
                    return(TRUE);

                case DC_COMPLEX:
                    if (pptlSrc->y >= prclDest->top)
                    {
                        if (pptlSrc->x >= prclDest->left)
                            iCopyDir = CD_RIGHTDOWN;
                        else
                            iCopyDir = CD_LEFTDOWN;
                    }
                    else
                    {
                        if (pptlSrc->x >= prclDest->left)
                            iCopyDir = CD_RIGHTUP;
                        else
                            iCopyDir = CD_LEFTUP;
                    }

                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, iCopyDir, 0);

                    do {
                        RECTL* prcl;
                        RECTL* prclEnd;

                        bMore = CLIPOBJ_bEnum(pco, (ULONG) sizeof(bben),
                                              (PVOID) &bben);

                        prclEnd = &bben.arcl[bben.c];
                        for (prcl = bben.arcl; prcl < prclEnd; prcl++)
                        {
                            if (bIntersectRect(prcl, prclDest, prcl))
                            {
                                ptlTmp.x = pptlSrc->x + prcl->left - prclDest->left;
                                ptlTmp.y = pptlSrc->y + prcl->top  - prclDest->top;

                                vPlanarCopyBits(ppdev, prcl, &ptlTmp);
                            }
                        }
                    } while (bMore);

                    return(TRUE);
                }
            }

            return(bPuntScreenToScreenCopyBits(ppdev,
                                               pco,
                                               pxlo,
                                               prclDest,
                                               pptlSrc));
        }

        ppdev = (PPDEV) psoDest->dhsurf;

        // Fall back to the engine:

        pso = ppdev->pSurfObj;
        vBankStartBltDest(ppdev, pso, pptlSrc, prclDest, &ptlSrc, &rclDest);

        do {
            b = EngCopyBits(pso,
                            psoSrc,
                            pco,
                            pxlo,
                            &rclDest,
                            &ptlSrc);

        } while (b && bBankEnumBltDest(ppdev, pso, pptlSrc, prclDest,
                                       &ptlSrc, &rclDest));

        return(b);
    }
    else if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE))
    {
        ////////////////////////////////////////////////////////////////
        // CopyBits from screen:
        ////////////////////////////////////////////////////////////////

        ppdev = (PPDEV) psoSrc->dhsurf;
        pso   = ppdev->pSurfObj;

        vBankStartBltSrc(ppdev, pso, pptlSrc, prclDest, &ptlSrc, &rclDest);

        do {
            b = EngCopyBits(psoDest,
                            pso,
                            pco,
                            pxlo,
                            &rclDest,
                            &ptlSrc);

        } while (b && bBankEnumBltSrc(ppdev, pso, pptlSrc, prclDest,
                                      &ptlSrc, &rclDest));

        return(b);
    }

    /* we should never be here */
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\16bpp\color.c ===
/******************************Module*Header*******************************\
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft product is
* prohibited without written permission from Microsoft.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-6 and 248-255 of the Windows standard (required)
* 256-color palette, where vertices 0-6 and 248 are the vertices of the inner
* color cube, and 0 plus 249-255 are the vertices of the full color cube.
* Vertex 7 is 75% gray; this could be used in the dither, but that would break
* apps that depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

typedef struct _VERTEX_DATA {
    ULONG ulCount;  // # of pixels in this vertex
    ULONG ulVertex; // vertex #
} VERTEX_DATA;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDwordWithConvert[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.

BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA colors
*
\**************************************************************************/

ULONG DrvDitherColor(
IN  DHPDEV dhpdev,
IN  ULONG  iMode,
IN  ULONG  rgb,
OUT ULONG *pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulSymmetry;
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;
    VERTEX_DATA *pvVertexDataEnd;
    ULONG  *pulDitherOrder;
    ULONG   ulNumPixels;
    BYTE    jColor;
    ULONG   ulColor;
    VERTEX_DATA *pvMaxVertex;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;
    BYTE   *pjDither = (BYTE *)pul;

    // Figure out if we need a full color dither or only a monochrome dither
    if (iMode != DM_MONOCHROME) {

        // Full color dither

        // Split the color into red, green, and blue components
        ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
        ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
        ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

        // Sort the RGB so that the point is transformed into subspace 0, and
        // keep track of the swaps in ulSymmetry so we can unravel it again
        // later.  We want r >= g >= b (subspace 0).
        ulSymmetry = 0;
        if (ulBlueTemp > ulRedTemp) {
            SWAPTHEM(ulBlueTemp,ulRedTemp);
            ulSymmetry = SWAP_RB;
        }

        if (ulBlueTemp > ulGreenTemp) {
            SWAPTHEM(ulBlueTemp,ulGreenTemp);
            ulSymmetry |= SWAP_GB;
        }

        if (ulGreenTemp > ulRedTemp) {
            SWAPTHEM(ulGreenTemp,ulRedTemp);
            ulSymmetry |= SWAP_RG;
        }

        ulSymmetry <<= 4;   // for lookup purposes

        // Scale the values from 0-255 to 0-64. Note that the scaling is not
        // symmetric at the ends; this is done to match Windows 3.1 dithering
        ulRed = (ulRedTemp + 1) >> 2;
        ulGre = (ulGreenTemp + 1) >> 2;
        ulBlu = (ulBlueTemp + 1) >> 2;

        // Compute the subsubspace within subspace 0 in which the point lies,
        // then calculate the # of pixels to dither in the colors that are the
        // four vertexes of the tetrahedron bounding the color we're emulating.
        // Only vertices with more than zero pixels are stored, and the
        // vertices are stored in order of increasing intensity, saving us the
        // need to sort them later
        if ((ulRedTemp + ulGreenTemp) > 256) {
            // Subsubspace 2 or 3
            if ((ulRedTemp + ulBlueTemp) > 256) {
                // Subsubspace 3
                // Calculate the number of pixels per vertex, still in
                // subsubspace 3, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 3 is:
                // 7, 9, 0x0B, 0x0F
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                ulVertex2Temp = ulGre - ulBlu;
                ulVertex3Temp = (ulRed - 64) + ulBlu;
                if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
                }
            } else {
                // Subsubspace 2
                // Calculate the number of pixels per vertex, still in
                // subsubspace 2, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 2 is:
                // 3, 7, 9, 0x0B
                pvVertexData = vVertexData;
                ulVertex1Temp = ulBlu << 1;
                ulVertex2Temp = ulRed - ulGre;
                ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
                if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                            ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex1Temp != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
                }
            }
        } else {
            // Subsubspace 0 or 1
            if (ulRedTemp > 128) {
                // Subsubspace 1
                // Calculate the number of pixels per vertex, still in
                // subsubspace 1, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 1 is:
                // 1, 3, 7, 9
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
                }
                ulVertex2Temp = ulBlu << 1;
                ulVertex3Temp = (ulRed - 32) << 1;
                if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
            } else {
                // Subsubspace 0
                // Calculate the number of pixels per vertex, still in
                // subsubspace 0, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 0 is:
                // 0, 1, 3, 7
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
                }
                if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
                }
                ulVertex3Temp = ulBlu << 1;
                if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex1Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
            }
        }

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = pvVertexData - vVertexData;    // # of vertices with more than
                                                // zero pixels
        if (ulTemp > 2) {

            // There are 3 or 4 vertices in this dither

            if (ulTemp == 3) {

                // There are 3 vertices in this dither

                // Find the vertex with the most pixels, and fill the whole
                // destination bitmap with that vertex's color, which is faster
                // than dithering it
                if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                    pvMaxVertex = &vVertexData[1];
                    ulTemp = vVertexData[1].ulCount;
                } else {
                    pvMaxVertex = &vVertexData[2];
                    ulTemp = vVertexData[2].ulCount;
                }

            } else {

                // There are 4 vertices in this dither

                // Find the vertex with the most pixels, and fill the whole
                // destination bitmap with that vertex's color, which is faster
                // than dithering it
                if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                    pvMaxVertex = &vVertexData[2];
                    ulTemp = vVertexData[2].ulCount;
                } else {
                    pvMaxVertex = &vVertexData[3];
                    ulTemp = vVertexData[3].ulCount;
                }
            }

            if (vVertexData[1].ulCount > ulTemp) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            }
            if (vVertexData[0].ulCount > ulTemp) {
                pvMaxVertex = &vVertexData[0];
            }

            pvVertexDataEnd = pvVertexData;

            // Prepare a dword version of the most common vertex number (color)
            ulColor = ulNibbleToDwordWithConvert[pvMaxVertex->ulVertex];

            // Mark that the vertex we're about to do doesn't need to be done
            // later
            pvMaxVertex->ulVertex = 0xFF;

            // Block fill the dither pattern with the more common vertex
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;

            // Now dither all the remaining vertices in order 0->2 or 0->3
            // (in order of increasing intensity)
            pulDitherOrder = aulDitherOrder;
            pvVertexData = vVertexData;
            do {
                if (pvVertexData->ulVertex == 0xFF) {
                    // This is the max vertex, which we already did, but we
                    // have to account for it in the dither order
                    pulDitherOrder += pvVertexData->ulCount;
                } else {
                    jColor = ajConvert[pvVertexData->ulVertex];
                    ulNumPixels = pvVertexData->ulCount;
                    switch (ulNumPixels & 3) {
                        case 3:
                            pjDither[*(pulDitherOrder+2)] = jColor;
                        case 2:
                            pjDither[*(pulDitherOrder+1)] = jColor;
                        case 1:
                            pjDither[*(pulDitherOrder+0)] = jColor;
                            pulDitherOrder += ulNumPixels & 3;
                        case 0:
                            break;
                    }
                    if ((ulNumPixels >>= 2) != 0) {
                        do {
                            pjDither[*pulDitherOrder] = jColor;
                            pjDither[*(pulDitherOrder+1)] = jColor;
                            pjDither[*(pulDitherOrder+2)] = jColor;
                            pjDither[*(pulDitherOrder+3)] = jColor;
                            pulDitherOrder += 4;
                        } while (--ulNumPixels);
                    }
                }
            } while (++pvVertexData < pvVertexDataEnd);

        } else if (ulTemp == 2) {

            // There are exactly two vertices with more than zero pixels; fill
            // in the dither array as follows: block fill with vertex with more
            // points first, then dither in the other vertex
            if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
                // There are no more vertex 1 than vertex 0 pixels, so do
                // the block fill with vertex 0
                ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
                // Do the dither with vertex 1
                jColor = ajConvert[vVertexData[1].ulVertex];
                ulNumPixels = vVertexData[1].ulCount;
                // Set where to start dithering with vertex 1 (vertex 0 is
                // lower intensity, so its pixels come first in the dither
                // order)
                pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
            } else {
                // There are more vertex 1 pixels, so do the block fill
                // with vertex 1
                ulColor = ulNibbleToDwordWithConvert[vVertexData[1].ulVertex];
                // Do the dither with vertex 0
                jColor = ajConvert[vVertexData[0].ulVertex];
                ulNumPixels = vVertexData[0].ulCount;
                // Set where to start dithering with vertex 0 (vertex 0 is
                // lower intensity, so its pixels come first in the dither
                // order)
                pulDitherOrder = aulDitherOrder;
            }

            // Block fill the dither pattern with the more common vertex
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;

            // Dither in the less common vertex
            switch (ulNumPixels & 3) {
                case 3:
                    pjDither[*(pulDitherOrder+2)] = jColor;
                case 2:
                    pjDither[*(pulDitherOrder+1)] = jColor;
                case 1:
                    pjDither[*(pulDitherOrder+0)] = jColor;
                    pulDitherOrder += ulNumPixels & 3;
                case 0:
                    break;
            }
            if ((ulNumPixels >>= 2) != 0) {
                do {
                    pjDither[*pulDitherOrder] = jColor;
                    pjDither[*(pulDitherOrder+1)] = jColor;
                    pjDither[*(pulDitherOrder+2)] = jColor;
                    pjDither[*(pulDitherOrder+3)] = jColor;
                    pulDitherOrder += 4;
                } while (--ulNumPixels);
            }

        } else {

            // There is only one vertex in this dither

            // No sorting or dithering is needed for just one color; we can
            // just generate the final DIB directly
            ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;
        }

    } else {

        // For monochrome we will only use the Intensity (grey level)
        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\16bpp\debug.h ===
/***************************************************************************\
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\***************************************************************************/


#if DBG

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#define DISPDBG(arg) DebugPrint arg
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#define ASSERTVGA(x, y) if (!(x)) RIP (y)

#else

#define DISPDBG(arg)
#define RIP(x)
#define ASSERTVGA(x, y)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\16bpp\bank.c ===
/******************************Module*Header*******************************\
* Module Name: bank.c
*
* Functions to control 64k color VGA banking.
*
* Currently doesn't handle or even detect broken rasters; assumes broken
* rasters, if present, are off the right side of the visible bitmap.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"
#include "limits.h"

VOID vBankErrorTrap(PPDEV, ULONG, BANK_JUST);
VOID vBank2Window(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vBank2Window2RW(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vBank2Window1RW(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vBank1Window2RW(PPDEV, ULONG, BANK_JUST);
VOID vBank1Window(PPDEV, ULONG, BANK_JUST);
VOID vPlanar2Window(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vPlanar2Window2RW(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vPlanar2Window1RW(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vPlanar1Window2RW(PPDEV, ULONG, BANK_JUST);
VOID vPlanar1Window(PPDEV, ULONG, BANK_JUST);

/******************************Public*Routine******************************\
* bInitializeNonPlanar(ppdev, pBankInfo)
*
* Initialize for non-planar mode banking.
*
* NOTE: Allocates ppdev->pbiBankInfo and ppdev->pjJustifyTopBank buffers!
\**************************************************************************/

BOOL bInitializeNonPlanar(PPDEV ppdev, VIDEO_BANK_SELECT* pBankInfo)
{
    LONG  lTotalScans;
    LONG  lTotalBanks;
    ULONG cjBankSize;

    ULONG cjGranularity = pBankInfo->Granularity;
    LONG  lDelta        = pBankInfo->BitmapWidthInBytes;
    ULONG cjBitmapSize  = pBankInfo->BitmapSize;

    ASSERTVGA(cjBitmapSize >= ppdev->cyScreen * lDelta, "Not enough vram");

    // Set up for non-planar banking:

    ppdev->lNextScan         = lDelta;
    ppdev->vbtBankingType    = pBankInfo->BankingType;

    ppdev->pfnBankSwitchCode =
                (PFN) (((BYTE*)pBankInfo) + pBankInfo->CodeOffset);

    // Set all clip rects to invalid; they'll be updated when the first
    // bank is mapped in

    ppdev->rcl1WindowClip.bottom    = -1;
    ppdev->rcl2WindowClip[0].bottom = -1;
    ppdev->rcl2WindowClip[1].bottom = -1;

    // Set up to call the appropriate banking control routines

    switch(pBankInfo->BankingType)
    {
    case VideoBanked1RW:
        ppdev->pfnBankControl        = vBank1Window;
        ppdev->pfnBankControl2Window = vBank2Window1RW;
        break;

    case VideoBanked1R1W:
        ppdev->pfnBankControl        = vBank1Window;
        ppdev->pfnBankControl2Window = vBank2Window;
        break;

    case VideoBanked2RW:
        ppdev->pfnBankControl        = vBank1Window2RW;
        ppdev->pfnBankControl2Window = vBank2Window2RW;

        // Offset from one bank index to next to make two 32k banks
        // appear to be one seamless 64k bank:

        ppdev->ulBank2RWSkip = BANK_SIZE_2RW_WINDOW / cjGranularity;
        break;

    default:
        RIP("Bad BankingType");
        return(FALSE);
    }

    // Set up the bank control tables with clip rects for banks
    // Note: lTotalBanks is generally an overestimate when granularity
    // is less than window size, because we ignore any banks after the
    // first one that includes the last scan line of the bitmap. A bit
    // of memory could be saved by sizing lTotalBanks exactly. Note too,
    // though, that the 2 RW window case may require more entries then,
    // because its windows are shorter, so you'd have to make sure there
    // were enough entries for the 2 RW window case, or recalculate
    // lTotalBanks for the 2 RW case

    lTotalBanks = (cjBitmapSize + cjGranularity - 1) / cjGranularity;
    lTotalScans = cjBitmapSize / lDelta;

    ppdev->cTotalScans = lTotalScans;
    ppdev->pbiBankInfo = (PBANK_INFO) EngAllocMem(FL_ZERO_MEMORY,
                          lTotalBanks * sizeof(BANK_INFO), ALLOC_TAG);
    if (ppdev->pbiBankInfo == NULL)
    {
        RIP("Couldn't get memory for bank info");
        return(FALSE);
    }

    ppdev->pjJustifyTopBank = (BYTE*) EngAllocMem(0, lTotalScans, ALLOC_TAG);
    if (ppdev->pjJustifyTopBank == NULL)
    {
        RIP("Couldn't get memory for JustifyTopBank table");
        return(FALSE);
    }

    // For 2 RW windows, windows are assumed to be 32k in size, otherwise
    // assumed to be 64k:

    if (pBankInfo->BankingType == VideoBanked2RW)
        cjBankSize = BANK_SIZE_2RW_WINDOW;
    else
        cjBankSize = BANK_SIZE_1_WINDOW;

//    if ((cjGranularity + lDelta) >= cjBankSize &&
//        (cjGranularity % lDelta) != 0)
//    {
//        // Oh no, we've got broken rasters (where a scan line crosses
//        // a bank boundary):
//
//        RIP("Oops, broken rasters not yet handled");
//        return(FALSE);
//    }
//    else
    {
        // We now fill in the scan-to-bank look-up and bank tables:

        LONG        iScan         = 0;
        ULONG       iBank         = 0;
        ULONG       cjScan        = 0;
        ULONG       cjNextBank    = cjGranularity;
        ULONG       cjEndOfBank   = cjBankSize;
        PBANK_INFO  pbiWorking    = ppdev->pbiBankInfo;

        while (TRUE)
        {
            pbiWorking->ulBankOffset         = cjNextBank - cjGranularity;

            // There are no broken rasters (or if they are, they're off the
            // right edge of the visible bitmap), so don't worry about left and
            // right edges:

            pbiWorking->rclBankBounds.left   = LONG_MIN + 1; // +1 to avoid
                                                             // compiler warn
            pbiWorking->rclBankBounds.right  = LONG_MAX;
            pbiWorking->rclBankBounds.top    = iScan;
            pbiWorking->rclBankBounds.bottom =
                    (cjEndOfBank + lDelta - 1) / lDelta;
                    // this rounds up to handle broken rasters that are off the
                    // right side of the visible bitmap

            // We don't need any more banks if we can see to the end
            // of the bitmap with the current bank:

            if (cjScan + cjBankSize >= cjBitmapSize)
                break;

            while (cjScan < cjNextBank)
            {
                ppdev->pjJustifyTopBank[iScan++] = (BYTE) iBank;
                cjScan += lDelta;
            }

            // Get ready for next bank:

            cjNextBank  += cjGranularity;
            cjEndOfBank += cjGranularity;
            pbiWorking++;
            iBank++;
        }

        // Clean up the last scans:

        ppdev->iLastBank = iBank;
        pbiWorking->rclBankBounds.bottom = lTotalScans;
        while (iScan < lTotalScans)
        {
            ppdev->pjJustifyTopBank[iScan++] = (BYTE) iBank;
        }

        // We've just computed the precise table for JustifyTop; we now
        // compute the scan offset for determining JustifyBottom:

        ASSERTVGA(cjBankSize >= cjGranularity,
               "Device says granularity more than bank size?");

        ppdev->ulJustifyBottomOffset = (cjBankSize - cjGranularity) / lDelta;

        // ulJustifyBottomOffset must be less than the number of scans
        // that fit entirely in any bank less the granularity size; if
        // our width doesn't divide evenly into the granularity, we'll
        // have to adjust the value to account for the first scan not
        // starting at offset 0 in any bank:

        if ((cjGranularity % lDelta) != 0 && ppdev->ulJustifyBottomOffset > 0)
            ppdev->ulJustifyBottomOffset--;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bInitializePlanar(ppdev, pBankInfo)
*
* Initialize for non-planar mode banking.
*
* NOTE: Allocates ppdev->pbiPlanarInfo and ppdev->pjJustifyTopPlanar buffers!
\**************************************************************************/

BOOL bInitializePlanar(PPDEV ppdev, VIDEO_BANK_SELECT* pBankInfo)
{
    LONG  lTotalScans;
    LONG  lTotalBanks;
    ULONG cjBankSize;
    ULONG cjGranularity = pBankInfo->PlanarHCGranularity;

    // Since we're in planar mode, every byte we see actually represents
    // four bytes of video memory:

    LONG  lDelta        = pBankInfo->BitmapWidthInBytes / 4;
    ULONG cjBitmapSize  = pBankInfo->BitmapSize / 4;

    ppdev->fl |= DRIVER_PLANAR_CAPABLE;

    // Set all clip rects to invalid; they'll be updated when the first
    // bank is mapped in

    ppdev->rcl1PlanarClip.bottom    = -1;
    ppdev->rcl2PlanarClip[0].bottom = -1;
    ppdev->rcl2PlanarClip[1].bottom = -1;

    // Set up for planar banking:

    ppdev->pfnPlanarSwitchCode =
                (PFN) (((BYTE*)pBankInfo) + pBankInfo->PlanarHCBankCodeOffset);
    ppdev->pfnPlanarEnable     =
                (PFN) (((BYTE*)pBankInfo) + pBankInfo->PlanarHCEnableCodeOffset);
    ppdev->pfnPlanarDisable     =
                (PFN) (((BYTE*)pBankInfo) + pBankInfo->PlanarHCDisableCodeOffset);

    ppdev->lPlanarNextScan = lDelta;
    ppdev->vbtPlanarType   = pBankInfo->PlanarHCBankingType;

    // Set up to call the appropriate banking control routines

    switch(ppdev->vbtPlanarType)
    {
    case VideoBanked1RW:
        ppdev->pfnPlanarControl  = vPlanar1Window;
        ppdev->pfnPlanarControl2 = vPlanar2Window1RW;
        break;

    case VideoBanked1R1W:
        ppdev->pfnPlanarControl  = vPlanar1Window;
        ppdev->pfnPlanarControl2 = vPlanar2Window;
        break;

    case VideoBanked2RW:
        ppdev->pfnPlanarControl  = vPlanar1Window2RW;
        ppdev->pfnPlanarControl2 = vPlanar2Window2RW;

        // Offset from one bank index to next to make two 32k banks
        // appear to be one seamless 64k bank:

        ppdev->ulPlanar2RWSkip = BANK_SIZE_2RW_WINDOW / cjGranularity;
        break;

    default:
        RIP("Bad BankingType");
        return(FALSE);
    }

    lTotalBanks = (cjBitmapSize + cjGranularity - 1) / cjGranularity;
    lTotalScans = cjBitmapSize / lDelta;

    ppdev->pbiPlanarInfo = (PBANK_INFO) EngAllocMem(FL_ZERO_MEMORY,
                          lTotalBanks * sizeof(BANK_INFO), ALLOC_TAG);
    if (ppdev->pbiPlanarInfo == NULL)
    {
        RIP("Couldn't get memory for bank info");
        return(FALSE);
    }

    ppdev->pjJustifyTopPlanar = (BYTE*) EngAllocMem(0, lTotalScans, ALLOC_TAG);
    if (ppdev->pjJustifyTopPlanar == NULL)
    {
        RIP("Couldn't get memory for JustifyTopBank table");
        return(FALSE);
    }

    // For 2 RW windows, windows are assumed to be 32k in size, otherwise
    // assumed to be 64k:

    if (pBankInfo->BankingType == VideoBanked2RW)
        cjBankSize = BANK_SIZE_2RW_WINDOW;
    else
        cjBankSize = BANK_SIZE_1_WINDOW;

//    if ((cjGranularity + lDelta) >= cjBankSize &&
//        (cjGranularity % lDelta) != 0)
//    {
//        // Oh no, we've got broken rasters (where a scan line crosses
//        // a bank boundary):
//
//        DISPDBG((0, "Can't handle broken planar rasters"));
//
//        ppdev->fl &= ~DRIVER_PLANAR_CAPABLE;// !!! Temporary, until we handle
//        return(TRUE);                       // broken rasters in planar copy
//    }
//    else
    {
        // We now fill in the scan-to-bank look-up and bank tables:

        LONG        iScan         = 0;
        ULONG       iBank         = 0;
        ULONG       cjScan        = 0;
        ULONG       cjNextBank    = cjGranularity;
        ULONG       cjEndOfBank   = cjBankSize;
        PBANK_INFO  pbiWorking    = ppdev->pbiPlanarInfo;

        while (TRUE)
        {
            pbiWorking->ulBankOffset         = cjNextBank - cjGranularity;

        // There are no broken rasters, so don't worry about left and right
        // edges:

            pbiWorking->rclBankBounds.left   = LONG_MIN + 1; // +1 to avoid
                                                             // compiler warn
            pbiWorking->rclBankBounds.right  = LONG_MAX;
            pbiWorking->rclBankBounds.top    = iScan;
            pbiWorking->rclBankBounds.bottom = iScan +
                (cjEndOfBank - cjScan + lDelta - 1) / lDelta;
                    // this rounds up to handle broken rasters that are off the
                    // right side of the visible bitmap

            // We don't need any more banks if we can see to the end
            // of the bitmap with the current bank:

            if (cjScan + cjBankSize >= cjBitmapSize)
                break;

            while (cjScan < cjNextBank)
            {
                ppdev->pjJustifyTopPlanar[iScan++] = (BYTE) iBank;
                cjScan += lDelta;
            }

            // Get ready for next bank:

            cjNextBank  += cjGranularity;
            cjEndOfBank += cjGranularity;
            pbiWorking++;
            iBank++;
        }

        // Clean up the last scans:

        ppdev->iLastPlanar = iBank;
        pbiWorking->rclBankBounds.bottom = lTotalScans;
        while (iScan < lTotalScans)
        {
            ppdev->pjJustifyTopPlanar[iScan++] = (BYTE) iBank;
        }

        // We've just computed the precise table for JustifyTop; we now
        // compute the scan offset for determining JustifyBottom:

        ASSERTVGA(cjBankSize >= cjGranularity,
               "Device says granularity more than bank size?");

        ppdev->ulPlanarBottomOffset = (cjBankSize - cjGranularity) / lDelta;

        // ulPlanarBottomOffset must be less than the number of scans
        // that fit entirely in any bank less the granularity size; if
        // our width doesn't divide evenly into the granularity, we'll
        // have to adjust the value to account for the first scan not
        // starting at offset 0 in any bank:

        if ((cjGranularity % lDelta) != 0 && ppdev->ulPlanarBottomOffset > 0)
            ppdev->ulPlanarBottomOffset--;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bEnableBanking(ppdev)
*
* Set up banking for the current mode
* pdsurf and ppdev are the pointers to the current surface and device
* Relevant fields in the surface are set up for banking
\**************************************************************************/

BOOL bEnableBanking(PPDEV ppdev)
{
    PVIDEO_BANK_SELECT  pBankInfo;
    UINT                ReturnedDataLength;
    VIDEO_BANK_SELECT   TempBankInfo;
    DWORD               status;

    // Make sure we've set to NULL any pointers to buffers that we allocate,
    // so that we can free them in our error path:

    ppdev->pBankInfo          = NULL;
    ppdev->pjJustifyTopBank   = NULL;
    ppdev->pbiBankInfo        = NULL;
    ppdev->pjJustifyTopPlanar = NULL;
    ppdev->pbiPlanarInfo      = NULL;

    // Query the miniport for banking info for this mode.
    //
    // First, figure out how big a buffer we need for the banking info
    // (returned in TempBankInfo->Size).

    if (status = EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_GET_BANK_SELECT_CODE,
                         NULL,                      // input buffer
                         0,
                         (LPVOID) &TempBankInfo,    // output buffer
                         sizeof(VIDEO_BANK_SELECT),
                         &ReturnedDataLength))
    {
        // We expect this call to fail, because we didn't allow any room
        // for the code; we just want to get the required output buffer
        // size. Make sure we got the expected error, ERROR_MORE_DATA.
    }

    // Now, allocate a buffer of the required size and get the banking info.

    pBankInfo = (PVIDEO_BANK_SELECT) EngAllocMem(FL_ZERO_MEMORY,
                    TempBankInfo.Size, ALLOC_TAG);
    if (pBankInfo == NULL)
    {
        RIP("Initialization error-couldn't get memory for bank info");
        goto error;
    }

    // Remember it so we can free it later:

    ppdev->pBankInfo    = pBankInfo;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_GET_BANK_SELECT_CODE,
                         NULL,
                         0,
                         (LPVOID) pBankInfo,
                         TempBankInfo.Size,
                         &ReturnedDataLength))
    {
        RIP("Initialization error-GetBankSelectCode, second call");
        goto error;
    }

    // Set up for banking:

    ppdev->ulBitmapSize = pBankInfo->BitmapSize;

    if (!bInitializeNonPlanar(ppdev, pBankInfo))
        goto error;

    if (pBankInfo->BankingFlags & PLANAR_HC)
    {
        ppdev->fl |= DRIVER_PLANAR_CAPABLE;
        if (!bInitializePlanar(ppdev, pBankInfo))
            goto error;
    }

    // Map in scan line 0 for read & write, to put things in a known state:

    ppdev->pfnBankControl(ppdev, 0, JustifyTop);

    return(TRUE);

// Error path:

error:
    vDisableBanking(ppdev);

    return(FALSE);
}

/******************************Public*Routine******************************\
* vDisableBanking(ppdev)
*
* Disable banking for the current mode
\**************************************************************************/

VOID vDisableBanking(PPDEV ppdev)
{
    EngFreeMem((LPVOID) ppdev->pBankInfo);
    EngFreeMem((LPVOID) ppdev->pjJustifyTopBank);
    EngFreeMem((LPVOID) ppdev->pbiBankInfo);
    EngFreeMem((LPVOID) ppdev->pjJustifyTopPlanar);
    EngFreeMem((LPVOID) ppdev->pbiPlanarInfo);
}

/******************************Private*Routine******************************\
* vBankErrorTrap
*
* Traps calls to bank control functions in non-banked modes
*
\**************************************************************************/

VOID vBankErrorTrap(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
    DISPDBG((0,"Call to bank manager in unbanked mode"));
}

/******************************Private*Routine******************************\
* vBank1Window
*
* Maps in a single R/W window that allows access to lScan. Applies to both
* 1 RW window and 1R1W window banking schemes.
*
\**************************************************************************/

VOID vBank1Window(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
             ULONG      ulBank;
             PBANK_INFO pbiWorking;
    volatile ULONG      ulBank0;
    volatile PFN        pBankFn;
             BANK_POSITION BankPosition;
             ULONG      ulReturn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a double-window set-up is currently active, so invalidate double-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl1WindowClip.bottom == -1)
    {
        if (ppdev->flBank & BANK_PLANAR)
        {
            ppdev->flBank &= ~BANK_PLANAR;
            ppdev->pfnPlanarDisable();
        }

        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;
    }

    ASSERTVGA(!(ppdev->flBank & BANK_PLANAR), "Shouldn't be in planar mode");

    // Find the bank containing the scan line with the desired justification:

    {
        register LONG lSearchScan = lScan;
        if (ulJustification == JustifyBottom)
        {
            lSearchScan -= ppdev->ulJustifyBottomOffset;
            if (lSearchScan <= 0)
                lSearchScan = 0;
        }

        ulBank     = (ULONG) ppdev->pjJustifyTopBank[lSearchScan];
        pbiWorking = &ppdev->pbiBankInfo[ulBank];
    }

    ASSERTVGA(pbiWorking->rclBankBounds.top <= (LONG)lScan &&
           pbiWorking->rclBankBounds.bottom > (LONG)lScan,
           "Oops, scan not in bank");

    ppdev->rcl1WindowClip = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with
    // the banking window. The source and destination are set only so 1 R/W
    // aligned blits will work without having to be specifically aware of
    // the adapter type (some of the same code works with 1R/1W adapters too).

    ppdev->pvBitmapStart = (PVOID) (ppdev->pjScreen - pbiWorking->ulBankOffset);
    ppdev->pvBitmapStart2Window[0] = ppdev->pvBitmapStart;
    ppdev->pvBitmapStart2Window[1] = ppdev->pvBitmapStart;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank for both read and write
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = ulBank;
    pBankFn = ppdev->pfnBankSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,eax;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd

    if (ppdev->BankIoctlSupported) {

        static ULONG ulBankOld = -1;

        if (ulBankOld != ulBank0) {

            BankPosition.ReadBankPosition = ulBank0;
            BankPosition.WriteBankPosition = ulBank0;

            ulBankOld = ulBank0;

            EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_BANK_POSITION,
                             &BankPosition,
                             sizeof(BANK_POSITION),
                             NULL,
                             0,
                             &ulReturn);
        }
    }
}

/******************************Private*Routine******************************\
* vBank1Window2RW
*
* Maps in two 32K RW windows so that they form a single 64K R/W window that
* allows access to lScan. Applies only to 2 RW window schemes.
*
\**************************************************************************/

VOID vBank1Window2RW(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
             ULONG      ulBank0;
             ULONG      ulBank1;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a double-window set-up is currently active, so invalidate double-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl1WindowClip.bottom == -1)
    {
        if (ppdev->flBank & BANK_PLANAR)
        {
            ppdev->flBank &= ~BANK_PLANAR;
            ppdev->pfnPlanarDisable();
        }

        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;
    }

    ASSERTVGA(!(ppdev->flBank & BANK_PLANAR), "Shouldn't be in planar mode");

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyTop)
    {
        ulBank0 = ppdev->pjJustifyTopBank[lScan];
        ulBank1 = ulBank0 + ppdev->ulBank2RWSkip;
        if (ulBank1 >= ppdev->iLastBank)
        {
            ulBank1 = ppdev->iLastBank;
            ulBank0 = ulBank1 - ppdev->ulBank2RWSkip;
        }
    }
    else
    {
        lScan -= ppdev->ulJustifyBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;

        ulBank1 = ppdev->pjJustifyTopBank[lScan];
        ulBank0 = ulBank1 - ppdev->ulBank2RWSkip;
        if ((LONG) ulBank0 < 0)
        {
            ulBank0 = 0;
            ulBank1 = ppdev->ulBank2RWSkip;
        }
    }

    ppdev->rcl1WindowClip.left   = ppdev->pbiBankInfo[ulBank0].rclBankBounds.left;
    ppdev->rcl1WindowClip.top    = ppdev->pbiBankInfo[ulBank0].rclBankBounds.top;
    ppdev->rcl1WindowClip.bottom = ppdev->pbiBankInfo[ulBank1].rclBankBounds.bottom;
    ppdev->rcl1WindowClip.right  = ppdev->pbiBankInfo[ulBank1].rclBankBounds.right;

    // Shift the bitmap start address so that the desired bank aligns with
    // the banking window. The source and destination are set only so 1 R/W
    // aligned blits will work without having to be specifically aware of
    // the adapter type (some of the same code works with 1R/1W adapters too).

    ppdev->pvBitmapStart = (PVOID) ((BYTE*)ppdev->pjScreen
                         - ppdev->pbiBankInfo[ulBank0].ulBankOffset);

    ppdev->pvBitmapStart2Window[0] = ppdev->pvBitmapStart;
    ppdev->pvBitmapStart2Window[1] = ppdev->pvBitmapStart;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank for both read and write; this is accomplished
    // by mapping in the desired 32K bank, followed by the next 32K bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    pBankFn = ppdev->pfnBankSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vBank2Window
*
* Maps in one of two windows, either the source window (window 0) or the dest
* window (window 1), to allows access to lScan. Applies to 1R1W window
* banking scheme; should never be called for 1 RW window schemes, because
* there's only one window in that case.
*
\**************************************************************************/

VOID vBank2Window(
    PPDEV       ppdev,
    ULONG       lScan,
    BANK_JUST   ulJustification,
    ULONG       ulWindowToMap)
{
             ULONG       ulBank;
             PBANK_INFO  pbiWorking;
    volatile ULONG       ulBank0;
    volatile ULONG       ulBank1;
    volatile PFN         pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulJustifyBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopBank[lScan];
    pbiWorking = &ppdev->pbiBankInfo[ulBank];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2WindowClip[ulWindowToMap].bottom == -1)
    {
        ULONG ulOtherWindow = ulWindowToMap ^ 1;

        if (ppdev->flBank & BANK_PLANAR)
        {
            ppdev->flBank &= ~BANK_PLANAR;
            ppdev->pfnPlanarDisable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;

        // Neither of the 2 window windows was active, so we have to set up the
        // variables for the other bank (the one other than the one we were
        // called to set) as well, to make it valid. The other bank is set to
        // the same state as the bank we were called to set

        ppdev->rcl2WindowClip[ulOtherWindow]       = pbiWorking->rclBankBounds;
        ppdev->ulWindowBank[ulOtherWindow]         = ulBank;
        ppdev->pvBitmapStart2Window[ulOtherWindow] =
                (PVOID) ((BYTE*)ppdev->pjScreen - pbiWorking->ulBankOffset);
    }

    ASSERTVGA(!(ppdev->flBank & BANK_PLANAR), "Shouldn't be in planar mode");

    ppdev->rcl2WindowClip[ulWindowToMap] = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    ppdev->pvBitmapStart2Window[ulWindowToMap] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset);

    // Map in the desired bank; also map in the other bank to whatever its
    // current state is

    ppdev->ulWindowBank[ulWindowToMap] = ulBank;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Set both banks at once, because we may have just initialized the other
    // bank, and because this way the bank switch code doesn't have to do a
    // read before write to obtain the state of the other bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers


    ulBank0 = ppdev->ulWindowBank[0];
    ulBank1 = ppdev->ulWindowBank[1];
    pBankFn = ppdev->pfnBankSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vBank2Window1RW
*
* Maps in the one window in 1R/W case.  Does exactly the same thing as the
* one window case, because there's only one window, but has to be a separate
* entry point because of the extra parameter (because we're using STDCALL).
\**************************************************************************/

VOID vBank2Window1RW(PPDEV ppdev, ULONG lScan,
    BANK_JUST ulJustification, ULONG ulWindowToMap)
{
    vBank1Window(ppdev, lScan, ulJustification);
}

/******************************Private*Routine******************************\
* vBank2Window2RW
*
* Maps in one of two windows, either the source window (window 0) or the dest
* window (window 1), to allows access to lScan. Applies to 2RW window
* banking scheme; should never be called for 1 RW window schemes, because
* there's only one window in that case.
\**************************************************************************/

VOID vBank2Window2RW(
    PPDEV       ppdev,
    ULONG       lScan,
    BANK_JUST   ulJustification,
    ULONG       ulWindowToMap)
{
             ULONG      ulBank;
             PBANK_INFO pbiWorking;
    volatile ULONG      ulBank0;
    volatile ULONG      ulBank1;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulJustifyBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopBank[lScan];
    pbiWorking = &ppdev->pbiBankInfo[ulBank];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2WindowClip[ulWindowToMap].bottom == -1)
    {
        if (ppdev->flBank & BANK_PLANAR)
        {
            ppdev->flBank &= ~BANK_PLANAR;
            ppdev->pfnPlanarDisable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;

        // Neither of the 2 window windows was active, so we have to set up the
        // variables for the other bank (the one other than the one we were
        // called to set) as well, to make it valid. The other bank is set to
        // the same state as the bank we were called to set

        ppdev->rcl2WindowClip[ulWindowToMap^1] = pbiWorking->rclBankBounds;
        if (ulWindowToMap == 1)
        {
            ppdev->pvBitmapStart2Window[0] =
                (PVOID) ((BYTE*)ppdev->pjScreen - pbiWorking->ulBankOffset);
        }
        else
        {
            ppdev->pvBitmapStart2Window[1] =
                (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset +
                BANK_SIZE_2RW_WINDOW);
        }
        ppdev->ulWindowBank[ulWindowToMap^1] = ulBank;
    }

    ASSERTVGA(!(ppdev->flBank & BANK_PLANAR), "Shouldn't be in planar mode");

    ppdev->rcl2WindowClip[ulWindowToMap] = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    if (ulWindowToMap == 0)
    {
        ppdev->pvBitmapStart2Window[0] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset);
    }
    else
    {
        ppdev->pvBitmapStart2Window[1] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset +
            BANK_SIZE_2RW_WINDOW);
    }

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank; also map in the other bank to whatever its
    // current state is

    ppdev->ulWindowBank[ulWindowToMap] = ulBank;

    // Set both banks at once, because we may have just initialized the other
    // bank, and because this way the bank switch code doesn't have to do a
    // read before write to obtain the state of the other bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = ppdev->ulWindowBank[0];
    ulBank1 = ppdev->ulWindowBank[1];
    pBankFn = ppdev->pfnBankSwitchCode;
    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vPlanar1Window
*
* Maps in a single R/W window that allows access to lScan. Applies to both
* 1 RW window and 1R1W window banking schemes.
\**************************************************************************/

VOID vPlanar1Window(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
             ULONG      ulBank;
             PBANK_INFO pbiWorking;
    volatile ULONG      ulBank0;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a double-window set-up is currently active, so invalidate double-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl1PlanarClip.bottom == -1)
    {
        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulPlanarBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopPlanar[lScan];
    pbiWorking = &ppdev->pbiPlanarInfo[ulBank];

    ppdev->rcl1PlanarClip = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with
    // the banking window. The source and destination are set only so 1 R/W
    // aligned blits will work without having to be specifically aware of
    // the adapter type (some of the same code works with 1R/1W adapters too).

    ppdev->pvBitmapStart = (PVOID) (ppdev->pjScreen - pbiWorking->ulBankOffset);
    ppdev->pvBitmapStart2Window[0] = ppdev->pvBitmapStart;
    ppdev->pvBitmapStart2Window[1] = ppdev->pvBitmapStart;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank for both read and write
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = ulBank;
    pBankFn = ppdev->pfnPlanarSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,eax;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd
}

/******************************Private*Routine******************************\
* vPlanar1Window2RW
*
* Maps in two 32K RW windows so that they form a single 64K R/W window that
* allows access to lScan. Applies only to 2 RW window schemes.
*
\**************************************************************************/

VOID vPlanar1Window2RW(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
             ULONG      ulBank0;
             ULONG      ulBank1;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a double-window set-up is currently active, so invalidate double-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)


    if (ppdev->rcl1PlanarClip.bottom == -1)
    {
        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyTop)
    {
        ulBank0 = ppdev->pjJustifyTopPlanar[lScan];
        ulBank1 = ulBank0 + ppdev->ulPlanar2RWSkip;
        if (ulBank1 >= ppdev->iLastPlanar)
            ulBank1 = ppdev->iLastPlanar;
    }
    else
    {
        lScan -= ppdev->ulPlanarBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;

        ulBank1 = ppdev->pjJustifyTopPlanar[lScan];
        ulBank0 = ulBank1 - ppdev->ulPlanar2RWSkip;
        if ((LONG) ulBank0 < 0)
            ulBank0 = 0;
    }

    ppdev->rcl1PlanarClip.left   = ppdev->pbiPlanarInfo[ulBank0].rclBankBounds.left;
    ppdev->rcl1PlanarClip.top    = ppdev->pbiPlanarInfo[ulBank0].rclBankBounds.top;
    ppdev->rcl1PlanarClip.bottom = ppdev->pbiPlanarInfo[ulBank1].rclBankBounds.bottom;
    ppdev->rcl1PlanarClip.right  = ppdev->pbiPlanarInfo[ulBank1].rclBankBounds.right;

    // Shift the bitmap start address so that the desired bank aligns with
    // the banking window. The source and destination are set only so 1 R/W
    // aligned blits will work without having to be specifically aware of
    // the adapter type (some of the same code works with 1R/1W adapters too).

    ppdev->pvBitmapStart = (PVOID) ((BYTE*)ppdev->pjScreen
                         - ppdev->pbiPlanarInfo[ulBank0].ulBankOffset);

    ppdev->pvBitmapStart2Window[0] = ppdev->pvBitmapStart;
    ppdev->pvBitmapStart2Window[1] = ppdev->pvBitmapStart;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank for both read and write; this is accomplished
    // by mapping in the desired 32K bank, followed by the next 32K bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    pBankFn = ppdev->pfnPlanarSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vPlanar2Window
*
* Maps in one of two windows, either the source window (window 0) or the dest
* window (window 1), to allows access to lScan. Applies to 1R1W window
* banking scheme; should never be called for 1 RW window schemes, because
* there's only one window in that case.
*
\**************************************************************************/

VOID vPlanar2Window(
    PPDEV       ppdev,
    ULONG       lScan,
    BANK_JUST   ulJustification,
    ULONG       ulWindowToMap)
{
             ULONG       ulBank;
             PBANK_INFO  pbiWorking;
    volatile ULONG       ulBank0;
    volatile ULONG       ulBank1;
    volatile PFN         pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulPlanarBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopPlanar[lScan];
    pbiWorking = &ppdev->pbiPlanarInfo[ulBank];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2PlanarClip[ulWindowToMap].bottom == -1)
    {
        ULONG ulOtherWindow = ulWindowToMap ^ 1;

        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;

        // Neither of the 2 window windows was active, so we have to set up the
        // variables for the other bank (the one other than the one we were
        // called to set) as well, to make it valid. The other bank is set to
        // the same state as the bank we were called to set

        ppdev->rcl2PlanarClip[ulOtherWindow]       = pbiWorking->rclBankBounds;
        ppdev->ulWindowBank[ulOtherWindow]         = ulBank;
        ppdev->pvBitmapStart2Window[ulOtherWindow] =
                (PVOID) ((BYTE*)ppdev->pjScreen - pbiWorking->ulBankOffset);
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    ppdev->rcl2PlanarClip[ulWindowToMap] = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    ppdev->pvBitmapStart2Window[ulWindowToMap] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset);

    // Map in the desired bank; also map in the other bank to whatever its
    // current state is

    ppdev->ulWindowBank[ulWindowToMap] = ulBank;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Set both banks at once, because we may have just initialized the other
    // bank, and because this way the bank switch code doesn't have to do a
    // read before write to obtain the state of the other bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers


    ulBank0 = ppdev->ulWindowBank[0];
    ulBank1 = ppdev->ulWindowBank[1];
    pBankFn = ppdev->pfnPlanarSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vPlanar2Window1RW
*
* Maps in the one window in 1R/W case.  Does exactly the same thing as the
* one window case, because there's only one window, but has to be a separate
* entry point because of the extra parameter (because we're using STDCALL).
\**************************************************************************/

VOID vPlanar2Window1RW(PPDEV ppdev, ULONG lScan,
    BANK_JUST ulJustification, ULONG ulWindowToMap)
{
    vPlanar1Window(ppdev, lScan, ulJustification);
}

/******************************Private*Routine******************************\
* vPlanar2Window2RW
*
* Maps in one of two windows, either the source window (window 0) or the dest
* window (window 1), to allows access to lScan. Applies to 2RW window
* banking scheme; should never be called for 1 RW window schemes, because
* there's only one window in that case.
\**************************************************************************/

VOID vPlanar2Window2RW(
    PPDEV       ppdev,
    ULONG       lScan,
    BANK_JUST   ulJustification,
    ULONG       ulWindowToMap)
{
             ULONG      ulBank;
             PBANK_INFO pbiWorking;
    volatile ULONG      ulBank0;
    volatile ULONG      ulBank1;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulPlanarBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopPlanar[lScan];
    pbiWorking = &ppdev->pbiPlanarInfo[ulBank];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2PlanarClip[ulWindowToMap].bottom == -1)
    {
        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;

        // Neither of the 2 window windows was active, so we have to set up the
        // variables for the other bank (the one other than the one we were
        // called to set) as well, to make it valid. The other bank is set to
        // the same state as the bank we were called to set

        ppdev->rcl2PlanarClip[ulWindowToMap^1] = pbiWorking->rclBankBounds;
        if (ulWindowToMap == 1)
        {
            ppdev->pvBitmapStart2Window[0] =
                (PVOID) ((BYTE*)ppdev->pjScreen - pbiWorking->ulBankOffset);
        }
        else
        {
            ppdev->pvBitmapStart2Window[1] =
                (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset +
                BANK_SIZE_2RW_WINDOW);
        }
        ppdev->ulWindowBank[ulWindowToMap^1] = ulBank;
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    ppdev->rcl2PlanarClip[ulWindowToMap] = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    if (ulWindowToMap == 0)
    {
        ppdev->pvBitmapStart2Window[0] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset);
    }
    else
    {
        ppdev->pvBitmapStart2Window[1] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset +
            BANK_SIZE_2RW_WINDOW);
    }

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank; also map in the other bank to whatever its
    // current state is

    ppdev->ulWindowBank[ulWindowToMap] = ulBank;

    // Set both banks at once, because we may have just initialized the other
    // bank, and because this way the bank switch code doesn't have to do a
    // read before write to obtain the state of the other bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = ppdev->ulWindowBank[0];
    ulBank1 = ppdev->ulWindowBank[1];
    pBankFn = ppdev->pfnPlanarSwitchCode;
    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}


/******************************Private*Routine******************************\
* vPlanarDouble
*
* Maps in two windows simultaneously, both the source window (window 0)
* and the dest window (window 1), to allows access to the scans.
* Applies to 1R1W and 2R/w window banking schemes; should never be called
* for 1 RW window schemes, because there's only one window in that case.
*
\**************************************************************************/

VOID vPlanarDouble(
    PPDEV       ppdev,
    LONG        lScan0,          // Source bank
    BANK_JUST   ulJustification0,// Source justification
    LONG        lScan1,          // Destination bank
    BANK_JUST   ulJustification1)// Destination justification
{
             PBANK_INFO  pbi0;
             PBANK_INFO  pbi1;
             ULONG       ulBank0;
             ULONG       ulBank1;
    volatile ULONG       ulBank0_vol;
    volatile ULONG       ulBank1_vol;
    volatile PFN         pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the banks containing the scan lines with the desired justification:

    if (ulJustification0 == JustifyBottom)
    {
        lScan0 -= ppdev->ulPlanarBottomOffset;
        if (lScan0 <= 0)
            lScan0 = 0;
    }
    if (ulJustification1 == JustifyBottom)
    {
        lScan1 -= ppdev->ulPlanarBottomOffset;
        if (lScan1 <= 0)
            lScan1 = 0;
    }

    ulBank0    = (ULONG) ppdev->pjJustifyTopPlanar[lScan0];
    ulBank1    = (ULONG) ppdev->pjJustifyTopPlanar[lScan1];
    pbi0       = &ppdev->pbiPlanarInfo[ulBank0];
    pbi1       = &ppdev->pbiPlanarInfo[ulBank1];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2PlanarClip[0].bottom == -1)
    {
        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    ppdev->rcl2PlanarClip[0] = pbi0->rclBankBounds;
    ppdev->rcl2PlanarClip[1] = pbi1->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    ppdev->pvBitmapStart2Window[0] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbi0->ulBankOffset);
    ppdev->pvBitmapStart2Window[1] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbi1->ulBankOffset);

    if (ppdev->vbtPlanarType == VideoBanked2RW)
    {
        ppdev->pvBitmapStart2Window[1] = (PVOID) ((BYTE*)
            ppdev->pvBitmapStart2Window[1] + BANK_SIZE_2RW_WINDOW);
    }

    // Map in the desired banks.

    ppdev->ulWindowBank[0] = ulBank0;
    ppdev->ulWindowBank[1] = ulBank1;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Set both banks at once.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0_vol = ulBank0;
    ulBank1_vol = ulBank1;
    pBankFn = ppdev->pfnPlanarSwitchCode;

    _asm mov eax,ulBank0_vol;
    _asm mov edx,ulBank1_vol;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\16bpp\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

#if DBG

ULONG DebugLevel = 0;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
    }

    va_end(ap);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\16bpp\textout.c ===
/******************************Module*Header*******************************\
* Module Name: TextOut.c
*
* Text
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

/****************************************************************************
 * DrvTextOut
 ***************************************************************************/

BOOL DrvTextOut(
    SURFOBJ*  pso,
    STROBJ*   pstro,
    FONTOBJ*  pfo,
    CLIPOBJ*  pco,
    RECTL*    prclExtra,
    RECTL*    prclOpaque,
    BRUSHOBJ* pboFore,
    BRUSHOBJ* pboOpaque,
    POINTL*   pptlOrg,
    MIX       mix)
{
    BOOL   b;
    PPDEV  ppdev;

    ppdev = (PPDEV) pso->dhpdev;
    pso = ppdev->pSurfObj;

    // It may be that the opaquing rectangle is larger than the text rectangle,
    // so we'll want to use that to tell the bank manager which banks to
    // enumerate:

    pco = pcoBankStart(ppdev,
                       (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround,
                       pso,
                       pco);

    do {
        b = EngTextOut(pso,
                       pstro,
                       pfo,
                       pco,
                       prclExtra,
                       prclOpaque,
                       pboFore,
                       pboOpaque,
                       pptlOrg,
                       mix);

    } while (b && bBankEnum(ppdev, pso, pco));

    return(b);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\16bpp\paint.c ===
/******************************Module*Header*******************************\
* Module Name: paint.c
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaMix[] =
{
    0xFF,  // R2_WHITE        - Allow rop = gaMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE
};


/**************************************************************************\
* DrvPaint
*
* Paint the clipping region with the specified brush
*
\**************************************************************************/

BOOL DrvPaint
(
    SURFOBJ  *pso,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    MIX       mix
)
{
    ROP4         rop4;

    rop4  = (gaMix[(mix >> 8) & 0x0F]) << 8;
    rop4 |= ((ULONG) gaMix[mix & 0x0F]);

    return(DrvBitBlt(
        pso,
        (SURFOBJ *) NULL,
        (SURFOBJ *) NULL,
        pco,
        (XLATEOBJ *) NULL,
        &pco->rclBounds,
        (POINTL *)  NULL,
        (POINTL *)  NULL,
        pbo,
        pptlBrush,
        rop4));
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\16bpp\lines.c ===
/******************************Module*Header*******************************\
* Module Name: lines.c
*
* Banked Frame Buffer Line support
*
* Copyright (c) 1993 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

/******************************************************************************
 * DrvStrokePath
 *****************************************************************************/
BOOL DrvStrokePath(
SURFOBJ   *pso,
PATHOBJ   *ppo,
CLIPOBJ   *pco,
XFORMOBJ  *pxo,
BRUSHOBJ  *pbo,
POINTL    *pptlBrushOrg,
LINEATTRS *plineattrs,
MIX       mix)
{
    BOOL    b;
    PPDEV   ppdev;
    RECTL   rclScans;
    RECTFX  rcfx;
    FLOAT_LONG  elSavedStyleState = plineattrs->elStyleState;

    PATHOBJ_vGetBounds(ppo, &rcfx);

    // We add 15 to yBottom before dividing by 16 to get its ceiling,
    // plus add 16 to make the rectangle lower exclusive:

    rclScans.bottom = (rcfx.yBottom + 31) >> 4;
    rclScans.top    = (rcfx.yTop) >> 4;

    ppdev = (PPDEV) pso->dhpdev;
    pso = ppdev->pSurfObj;

    pco = pcoBankStart(ppdev, &rclScans, pso, pco);

    do
    {
        // we pass the entire line through each time, so we
        // must reset the style state to the beginning of
        // the line (because the engine updates it).

        plineattrs->elStyleState = elSavedStyleState;

        b = EngStrokePath(pso,
                          ppo,
                          pco,
                          pxo,
                          pbo,
                          pptlBrushOrg,
                          plineattrs,
                          mix);

    } while (b && bBankEnum(ppdev, pso, pco));

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\16bpp\enable.c ===
/******************************Module*Header*******************************\
* Module Name: enable.c
*
* This module contains the functions that enable and disable the
* driver, the pdev, and the surface.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

//
// Build the driver function table gadrvfn with function index/address pairs
//

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },
    {   INDEX_DrvPaint,                 (PFN) DrvPaint              }
};

BOOL bInitDefaultPalette(PPDEV ppdev, DEVINFO *pDevInfo);

/******************************Public*Routine******************************\
* DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
    ULONG iEngineVersion,
    ULONG cj,
    PDRVENABLEDATA pded)
{
    UNREFERENCED_PARAMETER(iEngineVersion);

// Engine Version is passed down so future drivers can support previous
// engine versions.  A next generation driver can support both the old
// and new engine conventions if told what version of engine it is
// working with.  For the first version the driver does nothing with it.

// Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = sizeof(gadrvfn) / sizeof(DRVFN);

// DDI version this driver was targeted for is passed back to engine.
// Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    return;
}

/******************************Public*Routine******************************\
* DrvEnablePDEV
*
* DDI function, Enables the Physical Device.
*
* Return Value: device handle to pdev.
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
    DEVMODEW   *pDevmode,       // Pointer to DEVMODE
    PWSTR       pwszLogAddress, // Logical address
    ULONG       cPatterns,      // number of patterns
    HSURF      *ahsurfPatterns, // return standard patterns
    ULONG       cjGdiInfo,      // Length of memory pointed to by pGdiInfo
    ULONG      *pGdiInfo,       // Pointer to GdiInfo structure
    ULONG       cjDevInfo,      // Length of following PDEVINFO structure
    DEVINFO    *pDevInfo,       // physical device information structure
    HDEV        hdev,           // HDEV, used for callbacks
    PWSTR       pwszDeviceName, // DeviceName - not used
    HANDLE      hDriver)        // Handle to base driver
{
    GDIINFO GdiInfo;
    DEVINFO DevInfo;
    PPDEV   ppdev;

    UNREFERENCED_PARAMETER(pwszLogAddress);
    UNREFERENCED_PARAMETER(pwszDeviceName);

    // Allocate a physical device structure.

    ppdev = (PPDEV) EngAllocMem(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG);

    if (ppdev == (PPDEV) NULL)
    {
        RIP("Couldn't allocate PDEV buffer");
        goto error0;
    }

    // Set up pointers in PDEV to temporary structures we build up to return.

    ppdev->pGdiInfo = &GdiInfo;
    ppdev->pDevInfo = &DevInfo;

    // Save the screen handle in the PDEV.

    ppdev->hDriver = hDriver;

    // Get the current screen mode information.  Set up device caps and devinfo.

    if (!bInitPDEV(ppdev,pDevmode))
    {
        DISPDBG((0,"vga64k Couldn't initialize PDEV"));
        goto error1;
    }

    // Initialize palette information.

    if (!bInitDefaultPalette(ppdev, &DevInfo))
    {
        RIP("vga64k DrvEnablePDEV failed bInitPalette\n");
        goto error1a;
    }

    // Copy the devinfo into the engine buffer.

    memcpy(pDevInfo, ppdev->pDevInfo, min(sizeof(DEVINFO), cjDevInfo));

    // Set the pdevCaps with GdiInfo we have prepared to the list of caps for this
    // pdev.

    memcpy(pGdiInfo, ppdev->pGdiInfo, min(cjGdiInfo, sizeof(GDIINFO)));

    // Set NULL into pointers for stack allocated memory.

    ppdev->pGdiInfo = (GDIINFO *) NULL;
    ppdev->pDevInfo = (DEVINFO *) NULL;

    // Create a clip object we can use when we're given a NULL clip object:

    ppdev->pcoNull = EngCreateClip();
    if (ppdev->pcoNull == NULL)
    {
        RIP("Couldn't create clip");
        goto error2;
    }

    ppdev->pcoNull->iDComplexity     = DC_RECT;
    ppdev->pcoNull->rclBounds.left   = 0;
    ppdev->pcoNull->rclBounds.top    = 0;
    ppdev->pcoNull->rclBounds.right  = ppdev->cxScreen;
    ppdev->pcoNull->rclBounds.bottom = ppdev->cyScreen;
    ppdev->pcoNull->fjOptions        = OC_BANK_CLIP;

    // pvSaveScan0 is non-NULL only when enumerating banks:

    ppdev->pvSaveScan0 = NULL;

    // We're all done:

    return((DHPDEV) ppdev);

error2:  //@@@
error1a: //@@@
error1:
    EngFreeMem(ppdev);

error0:
    return((DHPDEV) 0);
}

/******************************Public*Routine******************************\
* DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    ((PPDEV) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
\**************************************************************************/

VOID DrvDisablePDEV(
    DHPDEV dhpdev)
{
    PPDEV ppdev = (PPDEV) dhpdev;

    EngDeleteClip(ppdev->pcoNull);
    EngFreeMem(dhpdev);
}

/******************************Public*Routine******************************\
* DrvEnableSurface
*
* Enable the surface for the device.  Hook the calls this driver supports.
*
* Return: Handle to the surface if successful, 0 for failure.
*
\**************************************************************************/

HSURF DrvEnableSurface(
    DHPDEV dhpdev)
{
    PPDEV ppdev;
    HSURF hsurf;
    HSURF hsurfBm;
    SIZEL sizl;
    ULONG ulBitmapType;
    FLONG flHooks;

    // Create engine bitmap around frame buffer.

    ppdev = (PPDEV) dhpdev;

    if (!bInitSURF(ppdev, TRUE))
        goto error0;

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    ulBitmapType = BMF_16BPP;
    flHooks      = HOOKS_BMF16BPP;

    ASSERTVGA(ppdev->ulBitCount == 16, "Can only handle 16bpp VGAs");

    hsurfBm = (HSURF) EngCreateBitmap(sizl,
                                      ppdev->lDeltaScreen,
                                      (ULONG) (ulBitmapType),
                                      (FLONG) (((ppdev->lDeltaScreen > 0)
                                          ? BMF_TOPDOWN
                                          : 0)),
                                      (PVOID) (ppdev->pjScreen));
    if (hsurfBm == 0)
    {
        RIP("Couldn't create surface");
        goto error0;
    }

    if (!EngAssociateSurface(hsurfBm, ppdev->hdevEng, 0))
    {
        RIP("Couldn't create or associate surface");
        goto error1;
    }

    ppdev->hsurfBm = hsurfBm;

    ppdev->pSurfObj = EngLockSurface(hsurfBm);
    if (ppdev->pSurfObj == NULL)
    {
        RIP("Couldn't lock surface");
        goto error1;
    }

    hsurf = EngCreateDeviceSurface((DHSURF) ppdev, sizl, BMF_16BPP);
    if (hsurf == 0)
    {
        RIP("Couldn't create surface");
        goto error2;
    }

    if (!EngAssociateSurface(hsurf, ppdev->hdevEng, flHooks))
    {
        RIP("Couldn't associate surface");
        goto error3;
    }

    ppdev->hsurfEng = hsurf;

    // Disable all the clipping.

    if (!bEnableBanking(ppdev))
    {
        RIP("Couldn't initialize banking");
        goto error3;
    }

    ppdev->pvTmp = (PVOID) EngAllocMem(0, TMP_BUFFER_SIZE, ALLOC_TAG);
    if (ppdev->pvTmp == NULL)
    {
        RIP("Couldn't allocate temporary buffer");
        goto error4;
    }

    ASSERTVGA(ppdev->lNextScan != 0, "lNextScan shouldn't be zero");

    sizl.cx = ppdev->cxScreen;
    sizl.cy = TMP_BUFFER_SIZE / (sizl.cx * 2);

    ppdev->hbmTmp = EngCreateBitmap(sizl, sizl.cx*2, BMF_16BPP, 0,
                                    ppdev->pvTmp);
    if (ppdev->hbmTmp == (HBITMAP) 0)
    {
        RIP("Couldn't create temporary bitmap");
        goto error5;
    }

    ppdev->psoTmp = EngLockSurface((HSURF) ppdev->hbmTmp);
    if (ppdev->psoTmp == (SURFOBJ*) NULL)
    {
        RIP("Couldn't lock temporary surface");
        goto error6;
    }

    return(hsurf);

error6:
    EngDeleteSurface((HSURF) ppdev->hbmTmp);

error5:
    EngFreeMem(ppdev->pvTmp);

error4:
    vDisableBanking(ppdev);

error3:
    EngDeleteSurface(hsurf);

error2:
    EngUnlockSurface(ppdev->pSurfObj);

error1:
    EngDeleteSurface(hsurfBm);

error0:

//@@@
    DISPDBG((0,"Exiting DrvEnableSurface... \n"));
//@@@

    return((HSURF) 0);
}

/******************************Public*Routine******************************\
* DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
\**************************************************************************/

VOID DrvDisableSurface(
    DHPDEV dhpdev)
{
    PPDEV ppdev = (PPDEV) dhpdev;

    EngUnlockSurface(ppdev->psoTmp);
    EngDeleteSurface((HSURF) ppdev->hbmTmp);
    EngFreeMem(ppdev->pvTmp);
    EngDeleteSurface(ppdev->hsurfEng);
    vDisableSURF(ppdev);
    ppdev->hsurfEng = (HSURF) 0;
    vDisableBanking(ppdev);
}

/******************************Public*Routine******************************\
* DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL
DrvAssertMode(
    DHPDEV dhpdev,
    BOOL bEnable)
{
    PPDEV   ppdev = (PPDEV) dhpdev;
    ULONG   ulReturn;

    if (bEnable)
    {
        // The screen must be reenabled, reinitialize the device to
        // a clean state.

        return(bInitSURF(ppdev, FALSE));
    }
    else
    {
        // Call the kernel driver to reset the device to a known state.

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_RESET_DEVICE,
                             NULL,
                             0,
                             NULL,
                             0,
                             &ulReturn))
        {
            RIP("VIDEO_RESET_DEVICE failed");
            return(FALSE);
        }
        else
        {
            return(TRUE);
        }
    }
}

/******************************Public*Routine******************************\
* DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE hDriver,
ULONG cjSize,
DEVMODEW *pdm)

{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation, pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    DISPDBG((2, "Vga64k.dll: DrvGetModes\n"));

    cModes = getAvailableModes(hDriver,
                               (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                               &cbModeSize);

    if (cModes == 0)
    {
        DISPDBG((0, "VGA64k DISP DrvGetModes failed to get mode information"));
        return 0;
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the output
        // buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG)pdm) + sizeof(DEVMODEW) +
                                                   DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);

        } while (--cModes);
    }

    EngFreeMem(pVideoModeInformation);

    return cbOutputSize;

}


/******************************Public*Routine******************************\
* bInitDefaultPalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitDefaultPalette(PPDEV ppdev, DEVINFO *pDevInfo)
{
    ppdev->hpalDefault =
    pDevInfo->hpalDefault = EngCreatePalette(PAL_BITFIELDS,
                                               0,(PULONG) NULL,
                                               ppdev->flRed,
                                               ppdev->flGreen,
                                               ppdev->flBlue);

    if (ppdev->hpalDefault == (HPALETTE) 0)
    {
        RIP("DISP bInitDefaultPalette failed EngCreatePalette\n");
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\16bpp\driver.h ===
/******************************Module*Header*******************************\
* Module Name: driver.h
*
* Contains prototypes for the 64k color VGA driver.
*
* NOTE: Must mirror driver.inc!
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#ifndef _DRIVER_
#define _DRIVER_

#include "stdlib.h"
#include "stddef.h"
#include "windows.h"
#include "winddi.h"
#include "devioctl.h"
#include "ntddvdeo.h"

#include "debug.h"

typedef struct _PDEV PDEV, *PPDEV;

//
// A mode requires broken rasters if the stride is a power of 2 and the video ram
// accessed is greater than 64K.
//

#define POW2(stride) (!((stride) & ((stride)-1)))   // TRUE if stride is power of 2
#define BROKEN_RASTERS(stride,cy) ((!(POW2(stride))) && ((stride*cy) > 0x10000))

//
// Sizes assumed for 1-window and 2 RW-window banks.
//

#define BANK_SIZE_1_WINDOW      0x10000L
#define BANK_SIZE_2RW_WINDOW    0x08000L

//
// Temporary buffer must be at least as large as a bank.
// Must also be a multiple of 4.
//

#define TMP_BUFFER_SIZE         (BANK_SIZE_1_WINDOW)

/**************************************************************************\
*
* Specifies desired justification for requested scan line within bank window
*
\**************************************************************************/

typedef enum {
    JustifyTop = 0,
    JustifyBottom,
} BANK_JUST;

/**************************************************************************\
*
* Specifies which window is to be mapped by two-window bank handler.
*
\**************************************************************************/

typedef enum {
    MapSourceBank = 0,
    MapDestBank,
} BANK_JUST;

/**************************************************************************\
*
* Bank clipping info
*
\**************************************************************************/

typedef struct {
    RECTL rclBankBounds;    // describes pixels addressable in this bank
    ULONG ulBankOffset;     // offset of bank start from bitmap start, if
                            // the bitmap were linearly addressable
} BANK_INFO, *PBANK_INFO;

/**************************************************************************\
*
* Bank control function vector
*
\**************************************************************************/

typedef VOID (*PFN_PlanarEnable)();
typedef VOID (*PFN_PlanarDisable)();
typedef VOID (*PFN_PlanarControl)(PPDEV, ULONG, BANK_JUST);
typedef VOID (*PFN_PlanarControl2)(PPDEV, ULONG, BANK_JUST, ULONG);
typedef VOID (*PFN_PlanarNext)(PPDEV);
typedef VOID (*PFN_PlanarNext2)(PPDEV, ULONG);
typedef VOID (*PFN_BankControl)(PPDEV, ULONG, BANK_JUST);
typedef VOID (*PFN_BankControl2)(PPDEV, ULONG, BANK_JUST, ULONG);
typedef VOID (*PFN_BankNext)(PPDEV);
typedef VOID (*PFN_BankNext2)(PPDEV, ULONG);

/**************************************************************************\
*
* Miscellaneous driver flags
*
\**************************************************************************/

#define DRIVER_PLANAR_CAPABLE   0x01L
#define DRIVER_USE_OFFSCREEN    0x02L  // if not set, don't use offscreen memory
                                       //   for long operations (because the
                                       //   memory won't be refreshed)
#define DRIVER_HAS_OFFSCREEN    0x04L  // if not set, can't use any offscreen
                                       //   memory

/**************************************************************************\
*
* Bank status flags
*
\**************************************************************************/

#define BANK_BROKEN_RASTER1     0x01L // If bank1 or read bank has broken raster
#define BANK_BROKEN_RASTER2     0x02L // If bank2 or write bank has broken raster
#define BANK_BROKEN_RASTERS    (BANK_BROKEN_RASTER1 | BANK_BROKEN_RASTER2)
#define BANK_PLANAR             0x04L // If in planar mode

/**************************************************************************\
*
* Physical device data structure
*
\**************************************************************************/

// ***********************************************************
// *** MUST match the assembler version in i386\driver.inc ***
// ***********************************************************

typedef struct _PDEV
{
    FLONG       fl;                     // Driver flags (DRIVER_xxx)
    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfEng;               // Engine's handle to surface
    HANDLE      hsurfBm;                // Handle to the "punt" surface
    SURFOBJ*    pSurfObj;               // pointer to the locked "punt" surface

    HPALETTE    hpalDefault;            // Handle to the default palette for device.

    PBYTE       pjScreen;               // This is pointer to base screen address
    ULONG       cxScreen;               // Visible screen width
    ULONG       cyScreen;               // Visible screen height
    ULONG       ulMode;                 // Mode the mini-port driver is in.
    LONG        lDeltaScreen;           // Distance from one scan to the next.

    FLONG       flRed;                  // For bitfields device, Red Mask
    FLONG       flGreen;                // For bitfields device, Green Mask
    FLONG       flBlue;                 // For bitfields device, Blue Mask
    ULONG       ulBitCount;             // # of bits per pel -- can be only 16

    GDIINFO*    pGdiInfo;               // Pointer to temporary buffer for GDIINFO struct
    DEVINFO*    pDevInfo;               // Pointer to temporary buffer for DEVINFO struct

    ULONG       ulrm0_wmX;              // Four values (one per byte) to set
                                        //  GC5 to to select read mode 0
                                        //  together with write modes 0-3
// Off screen save stuff:

    HBITMAP     hbmTmp;                 // Handle to temporary buffer
    SURFOBJ*    psoTmp;                 // Temporary surface
    PVOID       pvTmp;                  // Pointer to temporary buffer
    ULONG       cyTmp;                  // # of scans in temporary surface

// DCI stuff:

    BOOL        bSupportDCI;            // True if miniport supports DCI

// Bank manager stuff common between planar and non-planar modes:

    LONG        cTotalScans;            // Number of usable on and off-screen
                                        //  scans
    PVIDEO_BANK_SELECT pBankInfo;       // Bank info for current mode returned
                                        //  by miniport

    FLONG       flBank;                 // Flags for current bank state

    ULONG       ulBitmapSize;           // Length of bitmap if there were no
                                        //  banking, in CPU addressable bytes
    ULONG       ulWindowBank[2];        // Current banks mapped into windows
                                        //  0 & 1
    PVOID       pvBitmapStart;          // Single-window bitmap start pointer
                                        //  (adjusted as necessary to make
                                        //  window map in at proper offset)
    PVOID       pvBitmapStart2Window[2];// Double-window window 0 and 1 bitmap
                                        // start

// Non-planar mode specific bank management control stuff:

    VIDEO_BANK_TYPE  vbtBankingType;        // Type of banking
    PFN              pfnBankSwitchCode;     // Pointer to bank switch code

    LONG             lNextScan;             // Offset to next bank in bytes
    BYTE*            pjJustifyTopBank;      // Pointer to lookup table for
                                            //  converting scans to banks
    BANK_INFO*       pbiBankInfo;           // Array of bank clip info
    ULONG            ulJustifyBottomOffset; // # of scans from top to bottom
                                            //  of bank, for bottom justifying
    ULONG            iLastBank;             // Index of last valid bank in
                                            //  pbiBankInfo table
    ULONG            ulBank2RWSkip;         // Offset from one bank index to next
                                            //  to make two 32K banks appear to be
                                            //  one seamless 64K bank

    PFN_BankControl  pfnBankControl;        // Pointer to bank control function
    PFN_BankControl2 pfnBankControl2Window; // Pointer to double-window bank
                                            //  control function
    PFN_BankNext     pfnBankNext;           // Pointer to next bank function
    PFN_BankNext2    pfnBankNext2Window;    // Pointer to double-window next
                                            //  bank function

    RECTL            rcl1WindowClip;        // Single-window banking clip rect
    RECTL            rcl2WindowClip[2];     // Double-window banking clip rects for
                                            //  windows 0 & 1

// Planar mode specific bank management control stuff:

    VIDEO_BANK_TYPE    vbtPlanarType;       // Type of planar banking

    PFN                pfnPlanarSwitchCode; // Pointer to planar bank switch
                                            //  code

    LONG               lPlanarNextScan;     // Offset to next planar bank in
                                            //  bytes
    BYTE*              pjJustifyTopPlanar;  // Pointer to lookup table for
                                            //  converting scans to banks
    BANK_INFO*         pbiPlanarInfo;       // Array of bank clip info
    ULONG              ulPlanarBottomOffset;// # of scans from top to bottom
                                            //  of bank, for bottom justifying
    ULONG              iLastPlanar;         // Index of last valid bank in
                                            //  pbiPlanarInfo table
    ULONG              ulPlanar2RWSkip;     // Offset from one bank index to next
                                            //  to make two 32K banks appear to be
                                            //  one seamless 64K bank

    PFN_PlanarControl  pfnPlanarControl;    // Planar one window bank control
    PFN_PlanarControl2 pfnPlanarControl2;   // Planar two window bank control

    PFN_PlanarNext     pfnPlanarNext;       // Planar one window next bank
    PFN_PlanarNext2    pfnPlanarNext2;      // Planar two window next bank

    RECTL              rcl1PlanarClip;      // Single-window banking clip rect
    RECTL              rcl2PlanarClip[2];   // Double-window banking clip rects for
                                            //  windows 0 & 1

    PFN_PlanarEnable   pfnPlanarEnable;     // Function to enable planar mode
    PFN_PlanarDisable  pfnPlanarDisable;    // Function to disable planar mode

// Smart bank manager stuff:

    LONG        iLastScan;              // Last scan we want to enumerate
    PVOID       pvSaveScan0;            // Surface's original pvScan0
    RECTL       rclSaveBounds;          // Clip Object's original bounds
    CLIPOBJ*    pcoNull;                // Points to an empty clip object
                                        //  we can use when we're given a
                                        //  NULL CLIPOBJ pointer
    BYTE        iSaveDComplexity;       // Clip Object's original complexity
    BYTE        fjSaveOptions;          // Clip Object's original flags
    BYTE        ajFiller[2];            // Pack dword alignment

    BOOLEAN     BankIoctlSupported;     // does the miniport support ioctl
                                        // based banking?
};                                  /* pdev */

// Size of the driver extra information in the DEVMODe structure passed
// to and from the display driver

#define DRIVER_EXTRA_SIZE 0

#define DLL_NAME                L"vga64k"       // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "VGA64K: "      // All debug output is prefixed
#define ALLOC_TAG               '6gvD'          // 4 byte TAG for memory allocations

// When calling vEnumStart, make sure you set bAll to FALSE.  This will tell
// the Engine to only enumerate rectangles in rclBounds.

// Hooks and Driver function table.

#define HOOKS_BMF16BPP  (HOOK_BITBLT     | HOOK_TEXTOUT    | HOOK_COPYBITS | \
                         HOOK_STROKEPATH | HOOK_PAINT)

#define BB_RECT_LIMIT   50

typedef struct _BBENUM
{
    ULONG   c;
    RECTL   arcl[BB_RECT_LIMIT];
} BBENUM;

// Initialization stuff:

BOOL bEnableBanking(PPDEV);
VOID vDisableBanking(PPDEV);
BOOL bInitPDEV(PPDEV,PDEVMODEW);
BOOL bInitSURF(PPDEV,BOOL);
VOID vDisableSURF(PPDEV);
VOID vInitRegs(PPDEV);
DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION *, DWORD *);

// Smart bank manager stuff:

CLIPOBJ* pcoBankStart(PPDEV, RECTL*, SURFOBJ*, CLIPOBJ*);
BOOL     bBankEnum(PPDEV, SURFOBJ*, CLIPOBJ*);
VOID     vBankStartBltSrc(PPDEV, SURFOBJ*, POINTL*, RECTL*, POINTL*, RECTL*);
BOOL     bBankEnumBltSrc(PPDEV, SURFOBJ*, POINTL*, RECTL*, POINTL*, RECTL*);
VOID     vBankStartBltDest(PPDEV, SURFOBJ*, POINTL*, RECTL*, POINTL*, RECTL*);
BOOL     bBankEnumBltDest(PPDEV, SURFOBJ*, POINTL*, RECTL*, POINTL*, RECTL*);

// Other prototypes:

VOID vPlanarCopyBits(PPDEV, RECTL*, POINTL*);
BOOL bIntersectRect(RECTL*, RECTL*, RECTL*);
VOID vSetWriteModes(ULONG *);

#endif // _DRIVER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\16bpp\i386\driver.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: driver.inc
;
; Contains prototypes for the 256 colour VGA driver.
;
; NOTE: Must mirror driver.h!
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

; Sizes assumed for 1-window and 2 RW-window banks.

BANK_SIZE_1_WINDOW      equ 10000h
BANK_SIZE_2RW_WINDOW    equ 8000h

; Specifies desired justification for requestion scan line within bank window

JustifyTop              equ 0
JustifyBottom           equ 1

; Specifies which window is to be mapped by two-window bank handler.

MapSourceBank           equ 0
MapDestBank             equ 1

;------------------------------------------------------------------------;

; Miscellaneous driver flags

DRIVER_PLANAR_CAPABLE   equ 1

; Bank status flags

BANK_BROKEN_RASTER1     equ 1       ; If bank1 or read bank has broken raster
BANK_BROKEN_RASTER2     equ 2       ; If bank2 or write bank has broken raster
BANK_BROKEN_RASTERS     equ (BANK_BROKEN_RASTER1 + BANK_BROKEN_RASTER2)

;------------------------------------------------------------------------;
; The Physical Device data structure.

PDEV struc
pdev_fl                     dd  ?   ; Driver flags
pdev_hDriver                dd  ?   ; Handle to \Device\Screen
pdev_hdevEng                dd  ?   ; Engine's handle to PDEV
pdev_hsurfEng               dd  ?   ; Engine's handle to surface
pdev_hsurfBm                dd  ?   ; Handle to the "punt" surface
pdev_pSurfObj               dd  ?   ; Pointer to the locked "punt" surface

pdev_hpalDefault            dd  ?   ; Handle to the default palette for device.

pdev_pjScreen               dd  ?   ; This is pointer to base screen address
pdev_cxScreen               dd  ?   ; Visible screen width
pdev_cyScreen               dd  ?   ; Visible screen height
pdev_ulMode                 dd  ?   ; Mode in which the mini-port driver is
pdev_lDeltaScreen           dd  ?   ; Distance from one scan to the next

pdev_flRed                  dd  ?   ; For bitfields device, Red Mask
pdev_flGreen                dd  ?   ; For bitfields device, Green Mask
pdev_flBlue                 dd  ?   ; For bitfields device, Blue Mask
pdev_ulBitCount             dd  ?   ; # of bits per pel 16 is only supported

pdev_pGdiInfo               dd  ?   ; Pointer to temporary buffer for GDIINFO struct
pdev_pDevInfo               dd  ?   ; Pointer to temporary buffer for DEVINFO struct

pdev_ulrm0_wmX              dd  ?   ; Values to set GC5 to to select read mode
                                    ;  0 together with write modes 0-3

; Off Screen Save Stuff:

pdev_hbmTmp                 dd  ?   ; Handle to temporary buffer
pdev_psoTmp                 dd  ?   ; Temporary surface
pdev_pvTmp                  dd  ?   ; Pointer to temporary buffer
pdev_cyTmp                  dd  ?   ; # of scans in temporary surface

; DCI Stuff:

pdev_bSupportDCI            dd  ?   ; Does miniport support DCI?

; Bank manager stuff common between planar and non-planar modes:

pdev_cTotalScans            dd  ?   ; Number of usable on & off screen scans
pdev_pBankInfo              dd  ?   ; Bank info for current mode
pdev_flBank                 dd  ?   ; Flags for current bank state
pdev_ulBitmapSize           dd  ?   ; Length of bitmap if there were no
                                    ;  banking, in CPU addressable bytes

pdev_ulWindowBank           dd  ?,? ; Current banks mapped into windows
                                    ;  0 & 1 (used in 2 window mode only)

pdev_pvBitmapStart          dd  ?   ; Single-window bitmap start pointer
                                    ;  (adjusted as necessary to make
                                    ;  window map in at proper offset)
pdev_pvBitmapStart2Window   dd  ?,? ; Double-window window 0 and 1 bitmap
                                    ; start

; Non-planar mode specific bank management control stuff:

pdev_vbtBankingType         dd  ?   ; Type of banking
pdev_pfnBankSwitchCode      dd  ?   ; Pointer to bank switch code
pdev_lNextScan              dd  ?   ; Offset to next bank in bytes
pdev_pjJustifyTopBank       dd  ?   ; Pointer to lookup table for
                                    ;  converting scans to banks
pdev_pbiBankInfo            dd  ?   ; Pointer to array of bank clip info
pdev_ulJustifyBottomOffset  dd  ?   ; Number of scans from top to bottom
                                    ;  of bank, for bottom justifying
pdev_iLastBank              dd  ?   ; Index of last valid bank in
pdev_ulBank2RWSkip          dd  ?   ; Offset from one bank index to next
                                    ;  to make two 32K banks appear to be
                                    ;  one seamless 64K bank

pdev_pfnBankControl         dd  ?   ; Pointer to bank control function
pdev_pfnBankControl2Window  dd  ?   ; Pointer to double-window bank
                                    ;  control function

pdev_pfnBankNext            dd  ?   ; Pointer to next bank function
pdev_pfnBankNext2Window     dd  ?   ; Pointer to double-window next bank
                                    ;  function
pdev_rcl1WindowClip         db  (size RECTL) dup (?)
                                    ; Single-window banking clip rect
pdev_rcl2WindowClip         db  (2*(size RECTL)) dup (?)
                                    ; Double-window banking clip rects for
                                    ;  windows 0 & 1

; Planar mode specific bank management control stuff:

pdev_vbtPlanarType          dd  ?   ; Type of planar banking
pdev_pfnPlanarSwitchCode    dd  ?   ; Pointer to planar bank switch code
pdev_lPlanarNextScan        dd  ?   ; Offset to next planar bank in bytes
pdev_pjJustifyTopPlanar     dd  ?   ; Pointer to lookup table for
                                    ;  converting scans to planar banks
pdev_pbiPlanarInfo          dd  ?   ; Pointer to array of bank clip info
pdev_ulPlanarBottomOffset   dd  ?   ; Number of scans from top to bottom
                                    ;  of bank, for bottom justifying
pdev_iLastPlanar            dd  ?   ; Index of last valid bank in
pdev_ulPlanar2RWSkip        dd  ?   ; Offset from one bank index to next
                                    ;  to make two 32K banks appear to be
                                    ;  one seamless 64K bank

pdev_pfnPlanarControl       dd  ?   ; Pointer to bank control function
pdev_pfnPlanarControl2      dd  ?   ; Pointer to double-window bank
                                    ;  control function

pdev_pfnPlanarNext          dd  ?   ; Pointer to next bank function
pdev_pfnPlanarNext2         dd  ?   ; Pointer to double-window next bank
                                    ;  function
pdev_rcl1PlanarClip         db  (size RECTL) dup (?)
                                    ; Single-window banking clip rect
pdev_rcl2PlanarClip         db  (2*(size RECTL)) dup (?)
                                    ; Double-window banking clip rects for

pdev_pfnPlanarEnable        dd  ?   ; Function to enable planar mode
pdev_pfnPlanarDisable       dd  ?   ; Function to disable planar mode

; Smart bank management stuff:

pdev_iLastScan              dd  ?   ; Last scan we want to enumerate
pdev_pvScanScan0            dd  ?   ; Surface's original pvScan0
pdev_rclSaveBounds          db  (size RECTL) dup (?)
                                    ; Clip object's original bounds
pdev_pcoNull                dd  ?   ; Pointer to empty clip object
pdev_iSaveDComplexity       db  ?   ; Clip object's original complexity
pdev_fjSaveOptions          db  ?   ; Clip object's original flags
pdev_ajFiller               db  ?,? ; Pack to dword alignment
PDEV ends

pdev_rcl2WindowClipS        equ     (pdev_rcl2WindowClip)
pdev_rcl2WindowClipD        equ     (pdev_rcl2WindowClip + (size RECTL))

pdev_rcl2PlanarClipS        equ     (pdev_rcl2PlanarClip)
pdev_rcl2PlanarClipD        equ     (pdev_rcl2PlanarClip + (size RECTL))

pdev_pvBitmapStart2WindowS  equ     (pdev_pvBitmapStart2Window)
pdev_pvBitmapStart2WindowD  equ     (pdev_pvBitmapStart2Window + dword)

;------------------------------------------------------------------------;

; Macro to do a simple RET, with no stack stuff, in a proc.

PLAIN_RET macro
        db      0c3h
        endm

; Macro to replace a CALL followed immediately by a JMP:

CALL_AND_JUMP macro CALL_ADDR,JUMP_ADDR
        push    offset JUMP_ADDR
        jmp     CALL_ADDR
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\16bpp\i386\egavga.inc ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:	EGAVGA.INC
;
; This file contains the external definitions of the EGA/VGA specific
; locations which driver output routines need to reference.
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
; Restrictions:
;
;	The following rules apply to the use of the EGA/VGA registers
;	for the drivers (excluding pointer code and state detection
;	code):
;
;
;	1)  Routines are allowed to alter the following registers:
;
;	    Sequencer:
;
;		SEQ_DATA		SEQ_MAP_MASK
;
;	    Graphics Controller:
;
;		GRAF_ADDR
;		GRAF_DATA		GRAF_DATA_ROT
;		GRAF_SET_RESET		GRAF_READ_MAP
;		GRAF_ENAB_SR		GRAF_MODE
;		GRAF_COL_COMP		GRAF_BIT_MASK
;
;
;	2)  The following registers will always contain the indicated
;	    value.  Routines are not allowed to alter them:
;
;	    Sequencer:
;
;		SEQ_ADDR	set to point SEQ_MAP_MASK
;
;	    Graphics Controller:
;
;		GRAF_CDC	set appropriately for color model
;
;
;	3)  Rotation counts for GRAF_DATA_ROT are not allowed.
;
;
;	4)  The following EGA/VGA registers will contain the indicated
;	    value upon entry to a routine.  Any routine which alters
;	    them must restore them to the indicated state.
;
;		Map Mask	    all planes enabled
;		Enable Set/Reset    all planes disabled
;		Data Rotate	    Set, no rotation
;		Mode		    Processor write, data read
;		Bit Mask	    all bits enabled
;
;
;	5)  The Mode Register is always shadowed in EGA/VGA memory for
;	    the state detection code.  At interrupt time, the mode
;	    will be restored from the structure "shadowed_graf_mode".
;	    Any routine altering the Mode Register must keep this location
;	    current.  This is the only EGA/VGA register which requires
;	    shadowing.
;
;
;	6)  Pointer drawing will save and restore the contents of
;	    the processor latches.
;
;
;	7)  Pointer drawing will leave GRAF_ADDR set to GRAF_BIT_MASK.
;
;-----------------------------------------------------------------------;

;	Miscellaneous Registers used only at EGA/VGA initialization time

MISC_OUTPUT	EQU	0C2h		;Miscellaneous Output Register
CRTC_ADDR	EQU	0D4h		;CRTC Address Register for color mode
CRTC_DATA	EQU	0D5h		;CRTC Data    Register for color mode
GRAF_1_POS	EQU	0CCh		;Graphics 1 Address Register
GRAF_2_POS	EQU	0CAh		;Graphics 2 Address Register
ATTR_READ	EQU	0DAh		;Attribute Controler Read  Address
ATTR_WRITE	EQU	0C0h		;Attribute Controler Write Address
IN_STAT_0	EQU	0C2h		;Input Status Register 0
IN_STAT_1	EQU	0DAh		;Input Status Register 1



;	EGA/VGA Register Definitions.
;
;	The following definitions are the EGA/VGA registers and values
;	used by this driver.  All other registers are set up at
;	when the EGA/VGA is placed into graphics mode and never altered
;	afterwards.
;
;	All unspecified bits in the following registers must be 0.


EGA_BASE	EQU	300h		;Base address of the EGA (3xx)
VGA_BASE	EQU	300h		;Base address of the VGA (3xx)



;	EGA/VGA Register Definitions.

EGA_BASE	EQU	300h		;Base address of the EGA (3xx)
VGA_BASE	EQU	300h		;Base address of the VGA (3xx)

;	SEQUencer Registers Used

SEQ_ADDR	EQU	0C4h		;SEQUencer Address Register
SEQ_DATA	EQU	0C5h		;SEQUencer Data    Register

SEQ_MAP_MASK	EQU	02h		;Write Plane Enable Mask
MM_C0		EQU	00000001b	;  C0 plane enable
MM_C1		EQU	00000010b	;  C1 plane enable
MM_C2		EQU	00000100b	;  C2 plane enable
MM_C3		EQU	00001000b	;  C3 plane enable
MM_ALL		EQU	00001111b	;  All planes

SEQ_MODE	EQU	04h		;Memory Mode
SM_ALPHA	EQU	00000001b	;  Char map select enable
SM_EXTENDED	EQU	00000010b	;  Extended memory present
SM_ODD_PLANE	EQU	00000100b	;  Odd/even bytes to same plane


;	Graphics Controller Registers Used

GRAF_ADDR	EQU	0CEh		;Graphics Controller Address Register
GRAF_DATA	EQU	0CFh		;Graphics Controller Data    Register

GRAF_SET_RESET	EQU	00h		;  Set/Reset Plane Color
GRAF_ENAB_SR	EQU	01h		;  Set/Reset Enable
GRAF_COL_COMP	EQU	02h		;  Color Compare Register

GRAF_DATA_ROT	EQU	03h		;  Data Rotate Register
DR_ROT_CNT	EQU	00000111b	;    Data Rotate Count
DR_SET		EQU	00000000b	;    Data Unmodified
DR_AND		EQU	00001000b	;    Data ANDed with latches
DR_OR		EQU	00010000b	;    Data ORed	with latches
DR_XOR		EQU	00011000b	;    Data XORed with latches

GRAF_READ_MAP	EQU	04h		;  Read Map Select Register
RM_C0		EQU	00000000b	;    Read C0 plane
RM_C1		EQU	00000001b	;    Read C1 plane
RM_C2		EQU	00000010b	;    Read C2 plane
RM_C3		EQU	00000011b	;    Read C3 plane

GRAF_MODE	EQU	05h		;  Mode Register
M_PROC_WRITE	EQU	00000000b	;    Write processor data rotated
M_LATCH_WRITE	EQU	00000001b	;    Write latched data
M_COLOR_WRITE	EQU	00000010b	;    Write processor data as color
M_AND_WRITE	EQU	00000011b	;    Write (procdata AND bitmask)
M_DATA_READ	EQU	00000000b	;    Read selected plane
M_COLOR_READ	EQU	00001000b	;    Read color compare

GRAF_MISC	EQU	06h		;  Miscellaneous Register
MS_NON_ALPHA	EQU	00000001b	;    Char generator disabled
MS_ODD_EVEN	EQU	00000010b	;    Map odd addresses to even
MS_A0000_128K	EQU	00000000b	;    Memory present at A0000, 128kb
MS_A0000_64K	EQU	00000100b	;    Memory present at A0000, 64kb
MS_B0000_32K	EQU	00001000b	;    Memory present at B0000, 32kb
MS_B8000_32K	EQU	00001100b	;    Memory present at B8000, 32kb
MS_ADDR_MASK	EQU	00001100b

GRAF_CDC	EQU	07h		;  Color Don't Care Register
GRAF_BIT_MASK	EQU	08h		;  Bit Mask Register


;       Various sizes for EGA/VGA data structures

;-----------------------------------------------------------------------;
; On the EGA/VGA, the number of bits/pel is 4
; The number of bytes per scan is 80
;-----------------------------------------------------------------------;

BITS_PEL        EQU     4

;-----------------------------------------------------------------------;
; Helper flags for the xyCreateMasks call
;-----------------------------------------------------------------------;

PTRI_INVERT     EQU     1   ; !!! In WINGDIP.H when H2INC works
PTRI_ANIMATE    EQU     2   ; !!! In WINGDIP.H when H2INC works

;-----------------------------------------------------------------------;
; The pointer parameters are the size of the pointer as received from
; DeviceSetCursor.
;-----------------------------------------------------------------------;

PTR_HEIGHT	EQU	32
PTR_WIDTH	EQU	4			;Width in bytes of pointer
PTR_WIDTH_BITS	EQU	PTR_WIDTH*8		;Width in bits of pointer

;-----------------------------------------------------------------------;
; The work width/height is the size of a pointer as manipulated by
; the pointer drawing code.
;-----------------------------------------------------------------------;

WORK_WIDTH	EQU	PTR_WIDTH+1		;Width of mask, work area
WORK_HEIGHT	EQU	PTR_HEIGHT+0		;Height of mask, work area
MASK_LENGTH	EQU	WORK_WIDTH*WORK_HEIGHT	;#bytes in mask, work area
CLR_MASK_LENGTH	EQU	WORK_WIDTH*WORK_HEIGHT*BITS_PEL	;#bytes in color mask
	.errnz	BITS_PEL-4

;-----------------------------------------------------------------------;
; The save area parameters control the size of the buffer used for
; saveing the bits underneath the pointer image.  It should be a
; power of two to allow for easy wrap calculations.
;-----------------------------------------------------------------------;

SAVE_BUFFER_WIDTH  EQU	  8			  ;Width  of the save area
SAVE_BUFFER_HEIGHT EQU	  32			  ;Height of the save area
		   .errnz  PTR_WIDTH  GT SAVE_BUFFER_WIDTH
		   .errnz  PTR_HEIGHT GT SAVE_BUFFER_HEIGHT



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\16bpp\screen.c ===
/******************************Module*Header*******************************\
* Module Name: screen.c
*
* Initializes the GDIINFO and DEVINFO structures for DrvEnablePDEV.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,  \
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,VARIABLE_PITCH | \
                       FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,  \
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,VARIABLE_PITCH | \
                       FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,  \
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,FIXED_PITCH |    \
                       FF_DONTCARE, L"Courier"}

// This is the basic devinfo for a default driver.  This is used as a base and customized based
// on information passed back from the miniport driver.

const DEVINFO gDevInfoFrameBuffer = {
    (GCAPS_OPAQUERECT | GCAPS_MONO_DITHER), /* Graphics capabilities         */

     // Should also implement GCAPS_HORIZSTRIKE so that the underlines
     // aren't drawn using DrvBitBlt

    SYSTM_LOGFONT,      // Default font description
    HELVE_LOGFONT,      // ANSI variable font description
    COURI_LOGFONT,      // ANSI fixed font description
    0,                  // Count of device fonts
    BMF_16BPP,          // Preferred DIB format
    8,                  // Width of dither
    8,                  // Height of dither
    0                   // Default palette to use for this device
};

/******************************Public*Routine******************************\
* bInitSURF
*
* Enables the surface.  Maps the frame buffer into memory.
*
\**************************************************************************/

BOOL bInitSURF(PPDEV ppdev, BOOL bFirst)
{
    VIDEO_MEMORY             VideoMemory;
    VIDEO_MEMORY_INFORMATION VideoMemoryInfo;
    DWORD                    ReturnedDataLength;

    // Set the mode.

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_CURRENT_MODE,
                         (LPVOID) &ppdev->ulMode,  // input buffer
                         sizeof(DWORD),
                         NULL,
                         0,
                         &ReturnedDataLength))
    {
        DISPDBG((0, "vga64k.dll: Failed SET_CURRENT_MODE\n"));
        return(FALSE);
    }

    if (bFirst)
    {
        // Get the linear memory address range.

        VideoMemory.RequestedVirtualAddress = NULL;

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                             (PVOID) &VideoMemory, // input buffer
                             sizeof (VIDEO_MEMORY),
                             (PVOID) &VideoMemoryInfo, // output buffer
                             sizeof (VideoMemoryInfo),
                             &ReturnedDataLength))
        {
            DISPDBG((0, "vga64k.dll: Failed MAP_VIDEO_MEMORY\n"));
            return(FALSE);
        }
    }

    // Record the Frame Buffer Linear Address.

    if (bFirst)
    {
        ppdev->pjScreen =  (PBYTE) VideoMemoryInfo.FrameBufferBase;
    }

    // Set the various write mode values, so we don't have to read before write
    // later on

    vSetWriteModes(&ppdev->ulrm0_wmX);

    // Initialize the VGA registers to their default states, so that we
    // can be sure of drawing properly even when the miniport didn't
    // happen to set them the way we like them:

    vInitRegs(ppdev);

    // Since we just did a mode-set, we'll be in non-planar mode.  And make
    // sure we reset the bank manager (otherwise, after a switch from full-
    // screen, we may think we've got one bank mapped in, when in fact there's
    // a different one mapped in, and bad things would happen...).

    ppdev->flBank &= ~BANK_PLANAR;

    ppdev->rcl1WindowClip.bottom    = -1;
    ppdev->rcl2WindowClip[0].bottom = -1;
    ppdev->rcl2WindowClip[1].bottom = -1;

    ppdev->rcl1PlanarClip.bottom    = -1;
    ppdev->rcl2PlanarClip[0].bottom = -1;
    ppdev->rcl2PlanarClip[1].bottom = -1;

    return(TRUE);
}

/******************************Public*Routine******************************\
* vDisableSURF
*
* Disable the surface. Un-Maps the frame in memory.
*
\**************************************************************************/

VOID vDisableSURF(PPDEV ppdev)
{
    DWORD returnedDataLength;
    VIDEO_MEMORY videoMemory;

    videoMemory.RequestedVirtualAddress = (PVOID) ppdev->pjScreen;

    if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                        (LPVOID) &videoMemory,
                        sizeof(VIDEO_MEMORY),
                        NULL,
                        0,
                        &returnedDataLength))
    {
        RIP("Failed UNMAP_VIDEO_MEMORY");
    }
}

/******************************Public*Routine******************************\
* bInitPDEV
*
* Determine the mode we should be in based on the DEVMODE passed in.
* Query mini-port to get information needed to fill in the DevInfo and the
* GdiInfo .
*
\**************************************************************************/

BOOL bInitPDEV(
PPDEV ppdev,
DEVMODEW *pDevMode)
{
    GDIINFO *pGdiInfo;
    ULONG cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer, pVideoModeSelected, pVideoTemp;
    VIDEO_COLOR_CAPABILITIES colorCapabilities;
    ULONG ulTemp;
    BOOL bSelectDefault;
    ULONG cbModeSize;
    BANK_POSITION BankPosition;
    ULONG ulReturn;

    pGdiInfo = ppdev->pGdiInfo;

    //
    // calls the miniport to get mode information.
    //

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);

    if (cModes == 0)
    {
        DISPDBG((0, "vga64k.dll: no available modes\n"));
        return(FALSE);
    }

    //
    // Determine if we are looking for a default mode.
    //

    if ( ((pDevMode->dmPelsWidth) ||
          (pDevMode->dmPelsHeight) ||
          (pDevMode->dmBitsPerPel) ||
          (pDevMode->dmDisplayFlags) ||
          (pDevMode->dmDisplayFrequency)) == 0)
    {
        bSelectDefault = TRUE;
    }
    else
    {
        bSelectDefault = FALSE;
    }

    //
    // Now see if the requested mode has a match in that table.
    //

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pDevMode->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pDevMode->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                    pVideoTemp->NumberOfPlanes  == pDevMode->dmBitsPerPel) &&
                 (pVideoTemp->Frequency  == pDevMode->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((2, "vga64k: Found a match\n")) ;
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);
    }

    //
    // If no mode has been found, return an error
    //

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((0, "vga64k.dll: no valid modes\n"));
        EngFreeMem(pVideoBuffer);
        return(FALSE);
    }

    //
    // Fill in the GDIINFO data structure with the information returned from
    // the kernel driver.
    //

    ppdev->ulMode = pVideoModeSelected->ModeIndex;
    ppdev->cxScreen = pVideoModeSelected->VisScreenWidth;
    ppdev->cyScreen = pVideoModeSelected->VisScreenHeight;
    ppdev->ulBitCount = pVideoModeSelected->BitsPerPlane *
                        pVideoModeSelected->NumberOfPlanes;
    ppdev->lDeltaScreen = pVideoModeSelected->ScreenStride;

    ppdev->flRed = pVideoModeSelected->RedMask;
    ppdev->flGreen = pVideoModeSelected->GreenMask;
    ppdev->flBlue = pVideoModeSelected->BlueMask;

    if (!(pVideoModeSelected->AttributeFlags & VIDEO_MODE_NO_OFF_SCREEN))
    {
        ppdev->fl |= DRIVER_USE_OFFSCREEN;
    }

    pGdiInfo->ulVersion    = GDI_DRIVER_VERSION;
    pGdiInfo->ulTechnology = DT_RASDISPLAY;
    pGdiInfo->ulHorzSize   = pVideoModeSelected->XMillimeter;
    pGdiInfo->ulVertSize   = pVideoModeSelected->YMillimeter;

    pGdiInfo->ulHorzRes        = ppdev->cxScreen;
    pGdiInfo->ulVertRes        = ppdev->cyScreen;
    pGdiInfo->ulPanningHorzRes = ppdev->cxScreen;
    pGdiInfo->ulPanningVertRes = ppdev->cyScreen;
    pGdiInfo->cBitsPixel       = pVideoModeSelected->BitsPerPlane;
    pGdiInfo->cPlanes          = pVideoModeSelected->NumberOfPlanes;
    pGdiInfo->ulVRefresh       = pVideoModeSelected->Frequency;
    pGdiInfo->ulBltAlignment   = 1;     // We're not accelerated, and we don't
                                        //   care about window alignment

    pGdiInfo->ulLogPixelsX = pDevMode->dmLogPixels;
    pGdiInfo->ulLogPixelsY = pDevMode->dmLogPixels;

    pGdiInfo->flTextCaps   = TC_RA_ABLE | TC_SCROLLBLT;
    pGdiInfo->flRaster     = 0;         // DDI reservers flRaster

    pGdiInfo->ulDACRed     = pVideoModeSelected->NumberRedBits;
    pGdiInfo->ulDACGreen   = pVideoModeSelected->NumberGreenBits;
    pGdiInfo->ulDACBlue    = pVideoModeSelected->NumberBlueBits;

    pGdiInfo->ulAspectX    = 0x24;      // One-to-one aspect ratio
    pGdiInfo->ulAspectY    = 0x24;
    pGdiInfo->ulAspectXY   = 0x33;

    pGdiInfo->xStyleStep   = 1;         // A style unit is 3 pels
    pGdiInfo->yStyleStep   = 1;
    pGdiInfo->denStyleStep = 3;

    pGdiInfo->ptlPhysOffset.x = 0;
    pGdiInfo->ptlPhysOffset.y = 0;
    pGdiInfo->szlPhysSize.cx  = 0;
    pGdiInfo->szlPhysSize.cy  = 0;

    // RGB and CMY color info.

    // try to get it from the miniport.
    // if the miniport doesn ot support this feature, use defaults.

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES,
                         NULL,
                         0,
                         &colorCapabilities,
                         sizeof(VIDEO_COLOR_CAPABILITIES),
                         &ulTemp))
    {
        DISPDBG((1, "vga64k DISP getcolorCapabilities failed \n"));

        pGdiInfo->ciDevice.Red.x = 6700;
        pGdiInfo->ciDevice.Red.y = 3300;
        pGdiInfo->ciDevice.Red.Y = 0;
        pGdiInfo->ciDevice.Green.x = 2100;
        pGdiInfo->ciDevice.Green.y = 7100;
        pGdiInfo->ciDevice.Green.Y = 0;
        pGdiInfo->ciDevice.Blue.x = 1400;
        pGdiInfo->ciDevice.Blue.y = 800;
        pGdiInfo->ciDevice.Blue.Y = 0;
        pGdiInfo->ciDevice.AlignmentWhite.x = 3127;
        pGdiInfo->ciDevice.AlignmentWhite.y = 3290;
        pGdiInfo->ciDevice.AlignmentWhite.Y = 0;

        pGdiInfo->ciDevice.RedGamma = 20000;
        pGdiInfo->ciDevice.GreenGamma = 20000;
        pGdiInfo->ciDevice.BlueGamma = 20000;

    }
    else
    {

        pGdiInfo->ciDevice.Red.x = colorCapabilities.RedChromaticity_x;
        pGdiInfo->ciDevice.Red.y = colorCapabilities.RedChromaticity_y;
        pGdiInfo->ciDevice.Red.Y = 0;
        pGdiInfo->ciDevice.Green.x = colorCapabilities.GreenChromaticity_x;
        pGdiInfo->ciDevice.Green.y = colorCapabilities.GreenChromaticity_y;
        pGdiInfo->ciDevice.Green.Y = 0;
        pGdiInfo->ciDevice.Blue.x = colorCapabilities.BlueChromaticity_x;
        pGdiInfo->ciDevice.Blue.y = colorCapabilities.BlueChromaticity_y;
        pGdiInfo->ciDevice.Blue.Y = 0;
        pGdiInfo->ciDevice.AlignmentWhite.x = colorCapabilities.WhiteChromaticity_x;
        pGdiInfo->ciDevice.AlignmentWhite.y = colorCapabilities.WhiteChromaticity_y;
        pGdiInfo->ciDevice.AlignmentWhite.Y = colorCapabilities.WhiteChromaticity_Y;

        // if we have a color device store the three color gamma values,
        // otherwise store the unique gamma value in all three.

        if (colorCapabilities.AttributeFlags & VIDEO_DEVICE_COLOR)
        {
            pGdiInfo->ciDevice.RedGamma = colorCapabilities.RedGamma;
            pGdiInfo->ciDevice.GreenGamma = colorCapabilities.GreenGamma;
            pGdiInfo->ciDevice.BlueGamma = colorCapabilities.BlueGamma;
        }
        else
        {
            pGdiInfo->ciDevice.RedGamma = colorCapabilities.WhiteGamma;
            pGdiInfo->ciDevice.GreenGamma = colorCapabilities.WhiteGamma;
            pGdiInfo->ciDevice.BlueGamma = colorCapabilities.WhiteGamma;
        }

    };

    pGdiInfo->ciDevice.Cyan.x = 0;
    pGdiInfo->ciDevice.Cyan.y = 0;
    pGdiInfo->ciDevice.Cyan.Y = 0;
    pGdiInfo->ciDevice.Magenta.x = 0;
    pGdiInfo->ciDevice.Magenta.y = 0;
    pGdiInfo->ciDevice.Magenta.Y = 0;
    pGdiInfo->ciDevice.Yellow.x = 0;
    pGdiInfo->ciDevice.Yellow.y = 0;
    pGdiInfo->ciDevice.Yellow.Y = 0;

    // No dye correction for raster displays.

    pGdiInfo->ciDevice.MagentaInCyanDye = 0;
    pGdiInfo->ciDevice.YellowInCyanDye = 0;
    pGdiInfo->ciDevice.CyanInMagentaDye = 0;
    pGdiInfo->ciDevice.YellowInMagentaDye = 0;
    pGdiInfo->ciDevice.CyanInYellowDye = 0;
    pGdiInfo->ciDevice.MagentaInYellowDye = 0;

    // Fill in the rest of the devinfo and GdiInfo structures.

    pGdiInfo->ulNumColors = (ULONG)-1;
    pGdiInfo->ulNumPalReg = 0;

    pGdiInfo->ulDevicePelsDPI  = 0;   // For printers only
    pGdiInfo->ulPrimaryOrder   = PRIMARY_ORDER_CBA;
    pGdiInfo->ulHTPatternSize  = HT_PATSIZE_4x4_M;
    pGdiInfo->ulHTOutputFormat = HT_FORMAT_16BPP;
    pGdiInfo->flHTFlags        = HT_FLAG_ADDITIVE_PRIMS;

    // Fill in the basic devinfo structure

    *(ppdev->pDevInfo) = gDevInfoFrameBuffer;

    EngFreeMem(pVideoBuffer);

    //
    // Check to see if the miniport supports
    // IOCTL_VIDEO_SET_BANK_POSITION.
    //

    BankPosition.ReadBankPosition = 0;
    BankPosition.WriteBankPosition = 0;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_BANK_POSITION,
                         &BankPosition,
                         sizeof(BANK_POSITION),
                         NULL,
                         0,
                         &ulReturn) == NO_ERROR)
    {
        ppdev->BankIoctlSupported = TRUE;

    } else {

        ppdev->BankIoctlSupported = FALSE;
    }


    return(TRUE);
}

/******************************Public*Routine******************************\
* getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE hDriver,
PVIDEO_MODE_INFORMATION *modeInformation,
DWORD *cbModeSize)
{
    ULONG ulTemp;
    VIDEO_NUM_MODES modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
            NULL,
            0,
            &modes,
            sizeof(VIDEO_NUM_MODES),
            &ulTemp))
    {
        DISPDBG((0, "vga64k getAvailableModes failed VIDEO_QUERY_NUM_AVAIL_MODES\n"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        EngAllocMem(FL_ZERO_MEMORY,
                                   modes.NumModes *
                                   modes.ModeInformationLength, ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "vga64k getAvailableModes failed EngAllocMem\n"));

        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_AVAIL_MODES,
            NULL,
            0,
            *modeInformation,
            modes.NumModes * modes.ModeInformationLength,
            &ulTemp))
    {

        DISPDBG((0, "vga64k getAvailableModes failed VIDEO_QUERY_AVAIL_MODES\n"));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 16 bits per pel (that is all the vga64k currently supports)
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
             (pVideoTemp->AttributeFlags & VIDEO_MODE_LINEAR) ||
            (pVideoTemp->BitsPerPlane != 16) ||

             //
             // This next condition says that either the mode doesn't
             // require broken rasters, or else the ScreenStride has
             // already been set to some funky value.  Some miniports
             // choose strides that have broken rasters, but they're
             // limited to unused areas of video memory.  I only know of
             // 1928, so we'll special case that.
             //

            (BROKEN_RASTERS(pVideoTemp->ScreenStride,
                            pVideoTemp->VisScreenHeight) &&
             (pVideoTemp->ScreenStride != 1928)))

        {
            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return modes.NumModes;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\16bpp\i386\scroll.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: scroll.asm
;
; Copyright (c) 1992-1993 Microsoft Corporation
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; VOID vPlanarCopyBits(ppdev, prclDest, pptlSrc);
;
; Input:
;
;  ppdev    - surface on which to copy
;  prcldest - pointer to destination rectangle
;  pptlsrc  - pointer to source upper left corner
;
; Performs accelerated SRCCOPY screen-to-screen blts.
;
;-----------------------------------------------------------------------;
;
; NOTE: This handles only quad-pixel aligned blits!
;
; NOTE: Assumes all rectangles have positive heights and widths. Will
; not work properly if this is not the case.
;
;-----------------------------------------------------------------------;


;-----------------------------------------------------------------------;
; Set LOOP_UNROLL_SHIFT to the log2 of the number of times you want loops in
; this module unrolled. For example, LOOP_UNROLL_SHIFT of 3 yields 2**3 = 8
; times unrolling. This is the only thing you need to change to control
; unrolling.

LOOP_UNROLL_SHIFT equ 1

;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc
        include i386\unroll.inc
        include i386\egavga.inc

        .list

;-----------------------------------------------------------------------;

        .code

        EXTRNP          bPuntScreenToScreenCopyBits,20

        .data

; Bits for block copier tables:

BLOCK_RIGHT_TO_LEFT     equ 4
BLOCK_LEFT_EDGE         equ 2
BLOCK_RIGHT_EDGE        equ 1

;-----------------------------------------------------------------------;
; Table of block copiers for various horizontal directions, with the
; look-up index a 3-bit field as follows:
;
; Bit 2 (BLOCK_RIGHT_TO_LEFT) = 1 if right-to-left copy
; Bit 1 (BLOCK_LEFT_EDGE)     = 1 if left edge must be copied
; Bit 0 (BLOCK_RIGHT_EDGE)    = 1 if right edge must be copied

        align   4
MasterBlockTable label dword

        dd      copy_just_middle_block
        dd      Block_WR
        dd      Block_LW
        dd      Block_LWR

        dd      copy_just_middle_block
        dd      Block_RW
        dd      Block_WL
        dd      Block_RWL

        align   4
TopToBottomLoopTable label dword
        dd      0                               ;Not used - unbanked case
        dd      top_to_bottom_1RW
        dd      top_to_bottom_2RW
        dd      top_to_bottom_2RW

        align   4
BottomToTopLoopTable label dword
        dd      0                               ;Not used - unbanked case
        dd      bottom_to_top_1RW
        dd      bottom_to_top_2RW
        dd      bottom_to_top_2RW

        align   4
SetUpForCopyDirection label dword
        dd      left_to_right_top_to_bottom     ;CD_RIGHTDOWN
        dd      right_to_left_top_to_bottom     ;CD_LEFTDOWN
        dd      left_to_right_bottom_to_top     ;CD_RIGHTUP
        dd      right_to_left_bottom_to_top     ;CD_LEFTUP

LeftMaskTable label dword
        dd      01111b
        dd      01100b

RightMaskTable label dword
        dd      00000b
        dd      00011b

;-----------------------------------------------------------------------;

        .code

Block_WR:
        push    offset copy_right_block
        jmp     copy_middle_block

Block_LW:
        push    offset copy_middle_block
        jmp     copy_left_block

Block_LWR:
        push    offset copy_right_block
        push    offset copy_middle_block
        jmp     copy_left_block

Block_RW:
        push    offset copy_middle_block
        jmp     copy_right_block

Block_WL:
        push    offset copy_left_block
        jmp     copy_middle_block

Block_RWL:
        push    offset copy_left_block
        push    offset copy_middle_block
        jmp     copy_right_block

;-----------------------------------------------------------------------;

cProc   vPlanarCopyBits,12,<    \
        uses esi edi ebx,       \
        ppdev:    ptr PDEV,     \
        prclDest: ptr RECTL,    \
        pptlSrc:  ptr POINTL    >

; Variables used in block copiers:

        local pfnCopyBlocks:       ptr   ;pointer to block copy routines

        local ulMiddleSrc:         dword ;bitmap offset to 1st source
        local ulMiddleDest:        dword ;bitmap offset to 1st dest
        local lMiddleDelta:        dword ;delta from end of middle scan to next
        local ulBlockHeight:       dword ;number of scans to be copied in block
        local cjMiddle:            dword ;number of bytes to be copied on scan

        local ulLeftSrc:           dword ;bitmap offset to left source byte edge
        local ulLeftDest:          dword ;bitmap offset to left dest byte edge
        local ulRightSrc:          dword ;bitmap offset to right source byte edge
        local ulRightDest:         dword ;bitmap offset to right dest byte edge
        local lDelta:              dword ;delta between scans

        local ulLeftMask:          dword ;byte mask for left-edge copies
        local ulRightMask:         dword ;byte mask for right-edge copies

        local rclDest[size RECTL]: byte  ;left and right values always valid
        local ptlSrc[size POINTL]: byte  ;x value always valid

        local ulCurrentSrcScan:    dword ;real current source scan
        local ulCurrentDestScan:   dword ;real current destination scan
        local ulLastDestScan:      dword ;last destination scan

; Set the bit mask to disable all bits, so we can copy through the latches:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0 shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Figure out which direction to do the copies:

        mov     esi,pptlSrc
        mov     edi,prclDest
        mov     eax,[esi].ptl_y
        cmp     eax,[edi].yTop
        jl      planar_bottom_to_top

        mov     eax,[esi].ptl_x
        cmp     eax,[edi].xLeft
        jge     short left_to_right_top_to_bottom       ; CD_RIGHTDOWN
        jmp     right_to_left_top_to_bottom             ; CD_LEFTDOWN

planar_bottom_to_top:
        mov     eax,[esi].ptl_x
        cmp     eax,[edi].xLeft
        jge     left_to_right_bottom_to_top             ; CD_RIGHTUP
        jmp     right_to_left_bottom_to_top             ; CD_LEFTUP

all_done:

; Enable bit mask for all bits:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Enable writes to all planes and reset direction flag:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        cld

        cRet    vPlanarCopyBits

;=======================================================================;
;==================== Direction Dependent Setup ========================;
;=======================================================================;

;-----------------------------------------------------------------------;
; Set-up code for left-to-right, top-to-bottom copies.
;
; Input:
;       esi - pptlSrc
;       edi - prclDest
;-----------------------------------------------------------------------;

        public left_to_right_top_to_bottom
left_to_right_top_to_bottom::

; Need to set-up: ulMiddleSrc, ulMiddleDest, lMiddleDelta, cjMiddle
;                 ulLeftSrc, ulLeftDest, ulLeftMask
;                 lDelta
;                 ulRightSrc, ulRightDest, ulRightMask
;                 ulCurrentDestScan, ulLastDestScan
;                 pfnCopyBlocks
;                 ptlSrc.x, rclDest.left, rclDest.right

; lDelta = ppdev->lPlanarScan
; ulCurrentSrcScan  = pptl->y
; ulLeftSrc         = pptl->y       * lDelta + (pptl->x >> 1)
; ulCurrentDestScan = prclDest->top
; ulLeftDest        = prclDest->top * lDelta + (prclDest->left >> 1)
;
; ulMiddleSrc  = ulLeftSrc
; ulMiddleDest = ulLeftDest
;
; cjMiddle = (prclDest->right >> 1) - (prclDest->left >> 1)
; if (prclDest->left & 3)
;     ulLeftMask = LeftMaskTable[prclDest->left & 1]
;     fl |= BLOCK_LEFT_EDGE
;     ulMiddleSrc++
;     ulMiddleDest++
;     cjMiddle--
;
; lMiddleDelta = lDelta - cjMiddle
;
; if (prclDest->right & 1)
;     ulRightMask = RightMaskTable[prclDest->right & 1]
;     fl |= BLOCK_RIGHT_EDGE
;     ulRightSrc  = ulMiddleSrc  + cjMiddle
;     ulRightDest = ulMiddleDest + cjMiddle

        mov     edx,ppdev
        mov     eax,[edi].yBottom
        mov     edx,[edx].pdev_lPlanarNextScan ;edx = lDelta
        mov     ulLastDestScan,eax      ;ulLastDestScan = prclDest->bottom

        mov     ecx,[esi].ptl_y
        mov     eax,edx
        mov     ulCurrentSrcScan,ecx    ;ulCurrentSrcScan = pptlSrc->y
        imul    eax,ecx
        mov     ecx,[esi].ptl_x
        mov     ptlSrc.ptl_x,ecx        ;ptlSrc.x = pptlSrc->x
        shr     ecx,1
        add     eax,ecx                 ;eax = ulLeftSrc = pptlSrc->y *
                                        ;  lDelta + (pptlSrc->x >> 1)

        xor     esi,esi                 ;initialize flags

        mov     ecx,[edi].yTop
        mov     ebx,edx
        mov     ulCurrentDestScan,ecx   ;ulCurrentDestScan = prclDest->top
        imul    ebx,ecx
        mov     ecx,[edi].xLeft
        mov     rclDest.xLeft,ecx       ;rclDest.left = prclDest->left
        shr     ecx,1
        add     ebx,ecx                 ;ebx = ulLeftDest = prclDest->top *
                                        ;  lDelta + (prclDest->left >> 1)

        mov     edi,[edi].xRight
        mov     rclDest.xRight,edi
        shr     edi,1
        sub     edi,ecx                 ;cjMiddle = (prclDest->right >> 1) -
                                        ;  (prclDest->left >> 1)

        mov     ecx,rclDest.xLeft
        and     ecx,1
        jz      short l_t_done_left_edge ;skip if we don't need a left edge

        or      esi,BLOCK_LEFT_EDGE
        mov     ecx,LeftMaskTable[ecx*4]
        mov     ulLeftMask,ecx          ;ulLeftMask =
                                        ;  LeftMaskTable[prclDest->left & 1]

        mov     ulLeftSrc,eax           ;ulLeftSrc
        mov     ulLeftDest,ebx          ;ulLeftDest
        inc     eax
        inc     ebx
        dec     edi

l_t_done_left_edge:
        mov     ulMiddleSrc,eax         ;ulMiddleSrc
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        mov     ecx,rclDest.xRight
        and     ecx,1
        jz      short l_t_done_right_edge ;skip if we don't need a right edge

        or      esi,BLOCK_RIGHT_EDGE
        mov     ecx,RightMaskTable[ecx*4]
        mov     ulRightMask,ecx         ;ulRightMask =
                                        ;  RightMaskTable[prclDest->right & 1]

        add     eax,edi
        add     ebx,edi
        mov     ulRightSrc,eax          ;ulRightSrc = ulMiddleSrc + cjMiddle
        mov     ulRightDest,ebx         ;ulRightDest = ulMiddleDest + cjMiddle

; We special case here blits that are less than 2 pels wide and begin and end
; in the same 4-pel quadruple:

        cmp     edi,0
        jge     l_t_done_right_edge

; We make sure the 'middle' count of bytes is zero (we'll just let the code
; fall through the 'middle' copy code), turn off the right-edge flag, and
; give ulLeftMask the composite mask:

        inc     edi
        xor     esi,BLOCK_RIGHT_EDGE
        and     ecx,ulLeftMask
        mov     ulLeftMask,ecx

l_t_done_right_edge:
        mov     cjMiddle,edi            ;cjMiddle

        mov     lDelta,edx              ;lDelta = ppdev->lPlanarNextScan
        sub     edx,edi
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta - cjMiddle

        mov     ebx,ppdev
        mov     eax,MasterBlockTable[esi*4]
        mov     pfnCopyBlocks,eax       ;copy blocks between video memory

; Branch to the appropriate top-to-bottom bank enumeration loop:

        mov     eax,[ebx].pdev_vbtPlanarType
        jmp     TopToBottomLoopTable[eax*4]

;-----------------------------------------------------------------------;
; Set-up code for right-to-left, top-to-bottom copies.
;
; Input:
;       esi - pptlSrc
;       edi - prclDest
;-----------------------------------------------------------------------;

        public right_to_left_top_to_bottom
right_to_left_top_to_bottom::

        std                             ;copy middle blocks right-to-left

        mov     edx,ppdev
        mov     eax,[edi].yBottom
        mov     edx,[edx].pdev_lPlanarNextScan ;edx = lDelta
        mov     ulLastDestScan,eax      ;ulLastDestScan = prclDest->bottom

        mov     ecx,[esi].ptl_y
        mov     eax,edx
        mov     ulCurrentSrcScan,ecx    ;ulCurrentSrcScan = pptlSrc->y
        imul    eax,ecx
        mov     ecx,[esi].ptl_x
        mov     ptlSrc.ptl_x,ecx        ;ptlSrc.x = pptlSrc->x
        add     ecx,[edi].xRight
        sub     ecx,[edi].xLeft
        shr     ecx,1
        add     eax,ecx                 ;eax = ulRightSrc = pptlSrc->y *
                                        ; lDelta + (pptlSrc->x +
                                        ; prclDest->right - prclDest->left) / 2

        mov     esi,BLOCK_RIGHT_TO_LEFT ;initialize flags

        mov     ecx,[edi].yTop
        mov     ebx,edx
        mov     ulCurrentDestScan,ecx   ;ulCurrentDestScan = prclDest->top
        imul    ebx,ecx
        mov     ecx,[edi].xRight
        mov     rclDest.xRight,ecx      ;rclDest.right = prclDest->right
        shr     ecx,1
        add     ebx,ecx                 ;ebx = ulRightDest = prclDest->top *
                                        ; lDelta + prclDest->right / 2

        mov     edi,[edi].xLeft
        mov     rclDest.xLeft,edi
        shr     edi,1
        neg     edi
        add     edi,ecx                 ;cjMiddle = prclDest->right / 2 -
                                        ;  prclDest->left / 2

        mov     ecx,rclDest.xRight
        and     ecx,1
        jz      short r_t_done_right_edge ;skip if we don't need a right edge

        or      esi,BLOCK_RIGHT_EDGE
        mov     ecx,RightMaskTable[ecx*4]
        mov     ulRightMask,ecx         ;ulRightMask =
                                        ;  RightMaskTable[prclDest->right & 1]

        mov     ulRightSrc,eax          ;ulRightSrc
        mov     ulRightDest,ebx         ;ulRightDest

r_t_done_right_edge:
        dec     eax
        dec     ebx
        mov     ulMiddleSrc,eax         ;ulMiddleSrc
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        mov     ecx,rclDest.xLeft
        and     ecx,1
        jz      short r_t_done_left_edge ;skip if we don't need a right edge
        or      esi,BLOCK_LEFT_EDGE
        mov     ecx,LeftMaskTable[ecx*4]
        mov     ulLeftMask,ecx          ;ulLeftMask =
                                        ;  LeftMaskTable[prclDest->left & 1]

        dec     edi                     ;adjust middle block length because
                                        ;  we're effectively doing one less
                                        ;  middle byte

        sub     eax,edi
        sub     ebx,edi
        mov     ulLeftSrc,eax           ;ulLeftSrc = ulMiddleSrc - cjMiddle
        mov     ulLeftDest,ebx          ;ulLeftDest = ulMiddleDest - cjMiddle

; We special case here blits that are less than 2 pels wide and begin and end
; in the same 4-pel quadruple:

        cmp     edi,0
        jge     r_t_done_left_edge

; We make sure the 'middle' count of bytes is zero (we'll just let the code
; fall through the 'middle' copy code), turn off the right-edge flag, and
; give ulRightMask the composite mask:

        inc     edi
        xor     esi,BLOCK_LEFT_EDGE
        and     ecx,ulRightMask
        mov     ulRightMask,ecx

r_t_done_left_edge:
        mov     cjMiddle,edi            ;cjMiddle

        mov     lDelta,edx              ;lDelta = ppdev->lPlanarNextScan
        add     edx,edi
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta + cjMiddle

        mov     ebx,ppdev
        mov     eax,MasterBlockTable[esi*4]
        mov     pfnCopyBlocks,eax       ;copy blocks between video memory

; Branch to the appropriate top-to-bottom bank enumeration loop:

        mov     eax,[ebx].pdev_vbtPlanarType
        jmp     TopToBottomLoopTable[eax*4]

;-----------------------------------------------------------------------;
; Set-up code for left-to-right, bottom-to-top copies.
;
; Input:
;       esi - pptlSrc
;       edi - prclDest
;-----------------------------------------------------------------------;

        public left_to_right_bottom_to_top
left_to_right_bottom_to_top::

        mov     edx,ppdev
        mov     eax,[edi].yTop
        mov     edx,[edx].pdev_lPlanarNextScan ;edx = lDelta
        mov     ulLastDestScan,eax      ;ulLastDestScan = prclDest->top

        mov     ecx,[esi].ptl_y
        add     ecx,[edi].yBottom
        sub     ecx,[edi].yTop
        mov     eax,edx
        mov     ulCurrentSrcScan,ecx    ;ulCurrentSrcScan = pptlSrc->y +
                                        ;  (prclDest->bottom - prclDest->top)
        dec     ecx
        imul    eax,ecx
        mov     ecx,[esi].ptl_x
        mov     ptlSrc.ptl_x,ecx        ;ptlSrc.x = pptlSrc->x
        shr     ecx,1
        add     eax,ecx                 ;eax = ulLeftSrc = (ulCurrentSrcScan - 1)
                                        ;  * lDelta + (pptlSrc->x >> 1)

        xor     esi,esi                 ;initialize flags

        mov     ecx,[edi].yBottom
        mov     ebx,edx
        mov     ulCurrentDestScan,ecx   ;ulCurrentDestScan = prclDest->bottom
        dec     ecx
        imul    ebx,ecx
        mov     ecx,[edi].xLeft
        mov     rclDest.xLeft,ecx       ;rclDest.left = prclDest->left
        shr     ecx,1
        add     ebx,ecx                 ;ebx = ulLeftDest = (prclDest->bottom - 1)
                                        ;  * lDelta + (prclDest->left >> 1)

        mov     edi,[edi].xRight
        mov     rclDest.xRight,edi
        shr     edi,1
        sub     edi,ecx                 ;cjMiddle = (prclDest->right >> 1) -
                                        ;  (prclDest->left >> 1)

        mov     ecx,rclDest.xLeft
        and     ecx,1
        jz      short l_b_done_left_edge ;skip if we don't need a left edge

        or      esi,BLOCK_LEFT_EDGE
        mov     ecx,LeftMaskTable[ecx*4]
        mov     ulLeftMask,ecx          ;ulLeftMask =
                                        ;  LeftMaskTable[prclDest->left & 3]

        mov     ulLeftSrc,eax           ;ulLeftSrc
        mov     ulLeftDest,ebx          ;ulLeftDest
        inc     eax
        inc     ebx
        dec     edi

l_b_done_left_edge:
        mov     ulMiddleSrc,eax         ;ulMiddleSrc
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        mov     ecx,rclDest.xRight
        and     ecx,1
        jz      short l_b_done_right_edge ;skip if we don't need a right edge

        or      esi,BLOCK_RIGHT_EDGE
        mov     ecx,RightMaskTable[ecx*4]
        mov     ulRightMask,ecx         ;ulRightMask =
                                        ;  RightMaskTable[prclDest->right & 1]

        add     eax,edi
        add     ebx,edi
        mov     ulRightSrc,eax          ;ulRightSrc = ulMiddleSrc + cjMiddle
        mov     ulRightDest,ebx         ;ulRightDest = ulMiddleDest + cjMiddle

; We special case here blits that are less than 2 pels wide and begin and end
; in the same 4-pel quadruple:

        cmp     edi,0
        jge     l_b_done_right_edge

; We make sure the 'middle' count of bytes is zero (we'll just let the code
; fall through the 'middle' copy code), turn off the right-edge flag, and
; give ulLeftMask the composite mask:

        inc     edi
        xor     esi,BLOCK_RIGHT_EDGE
        and     ecx,ulLeftMask
        mov     ulLeftMask,ecx

l_b_done_right_edge:
        mov     cjMiddle,edi            ;cjMiddle

        neg     edx
        mov     lDelta,edx              ;lDelta = -ppdev->lPlanarNextScan
        sub     edx,edi
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta - cjMiddle

        mov     ebx,ppdev
        mov     eax,MasterBlockTable[esi*4]
        mov     pfnCopyBlocks,eax       ;copy blocks between video memory

; Branch to the appropriate top-to-bottom bank enumeration loop:

        mov     eax,[ebx].pdev_vbtPlanarType
        jmp     BottomToTopLoopTable[eax*4]

;-----------------------------------------------------------------------;
; Set-up code for right-to-left, bottom-to-top copies.
;
; Input:
;       esi - pptlSrc
;       edi - prclDest
;-----------------------------------------------------------------------;

        public right_to_left_bottom_to_top
right_to_left_bottom_to_top::

        std                             ;copy middle blocks right-to-left

        mov     edx,ppdev
        mov     eax,[edi].yTop
        mov     edx,[edx].pdev_lPlanarNextScan ;edx = lDelta
        mov     ulLastDestScan,eax      ;ulLastDestScan = prclDest->top

        mov     ecx,[esi].ptl_y
        add     ecx,[edi].yBottom
        sub     ecx,[edi].yTop
        mov     eax,edx
        mov     ulCurrentSrcScan,ecx    ;ulCurrentSrcScan = pptlSrc->y +
                                        ;  (prclDest->bottom - prclDest->top)
        dec     ecx
        imul    eax,ecx
        mov     ecx,[esi].ptl_x
        mov     ptlSrc.ptl_x,ecx        ;ptlSrc.x = pptlSrc->x
        add     ecx,[edi].xRight
        sub     ecx,[edi].xLeft
        shr     ecx,1
        add     eax,ecx                 ;eax = ulRightSrc = (ulCurrentSrcScan
                                        ; - 1) * lDelta + (pptlSrc->x +
                                        ; prclDest->right - prclDest->left) / 2

        mov     esi,BLOCK_RIGHT_TO_LEFT ;initialize flags

        mov     ecx,[edi].yBottom
        mov     ebx,edx
        mov     ulCurrentDestScan,ecx   ;ulCurrentDestScan = prclDest->bottom
        dec     ecx
        imul    ebx,ecx
        mov     ecx,[edi].xRight
        mov     rclDest.xRight,ecx      ;rclDest.right = prclDest->right
        shr     ecx,1
        add     ebx,ecx                 ;ebx = ulRightDest = (ulCurrentDestScan
                                        ; - 1) * lDelta + prclDest->right / 2

        mov     edi,[edi].xLeft
        mov     rclDest.xLeft,edi
        shr     edi,1
        neg     edi
        add     edi,ecx                 ;cjMiddle = prclDest->right / 2 -
                                        ;  prclDest->left / 2

        mov     ecx,rclDest.xRight
        and     ecx,1
        jz      short r_b_done_right_edge ;skip if we don't need a right edge

        or      esi,BLOCK_RIGHT_EDGE
        mov     ecx,RightMaskTable[ecx*4]
        mov     ulRightMask,ecx         ;ulRightMask =
                                        ;  RightMaskTable[prclDest->right & 1]

        mov     ulRightSrc,eax          ;ulRightSrc
        mov     ulRightDest,ebx         ;ulRightDest

r_b_done_right_edge:
        dec     eax
        dec     ebx
        mov     ulMiddleSrc,eax         ;ulMiddleSrc
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        mov     ecx,rclDest.xLeft
        and     ecx,1
        jz      short r_b_done_left_edge ;skip if we don't need a right edge

        or      esi,BLOCK_LEFT_EDGE
        mov     ecx,LeftMaskTable[ecx*4]
        mov     ulLeftMask,ecx          ;ulLeftMask =
                                        ;  LeftMaskTable[prclDest->left & 1]

        dec     edi                     ;adjust middle block length because
                                        ;  we're effectively doing one less
                                        ;  middle byte

        sub     eax,edi
        sub     ebx,edi
        mov     ulLeftSrc,eax           ;ulLeftSrc = ulMiddleSrc - cjMiddle
        mov     ulLeftDest,ebx          ;ulLeftDest = ulMiddleDest - cjMiddle

; We special case here blits that are less than 2 pels wide and begin and end
; in the same 4-pel quadruple:

        cmp     edi,0
        jge     r_b_done_left_edge

; We make sure the 'middle' count of bytes is zero (we'll just let the code
; fall through the 'middle' copy code), turn off the right-edge flag, and
; give ulRightMask the composite mask:

        inc     edi
        xor     esi,BLOCK_LEFT_EDGE
        and     ecx,ulRightMask
        mov     ulRightMask,ecx

r_b_done_left_edge:
        mov     cjMiddle,edi            ;cjMiddle

        neg     edx
        mov     lDelta,edx              ;lDelta = -ppdev->lPlanarNextScan
        add     edx,edi
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta + cjMiddle

        mov     ebx,ppdev
        mov     eax,MasterBlockTable[esi*4]
        mov     pfnCopyBlocks,eax       ;copy blocks between video memory

; Branch to the appropriate top-to-bottom bank enumeration loop:

        mov     eax,[ebx].pdev_vbtPlanarType
        jmp     BottomToTopLoopTable[eax*4]

;=======================================================================;
;============================= Banking =================================;
;=======================================================================;

;-----------------------------------------------------------------------;
; Banking for 1 R/W adapters, top to bottom.
;
; Input:
;       ulCurrentSrcScan
;       ulCurrentDestScan
;       ulLastDestScan
;       Plus some other stuff for split rasters and block copiers
;-----------------------------------------------------------------------;
        public  top_to_bottom_1RW
top_to_bottom_1RW::

; LATER: Should check to see if there's any chance that the source and
;     destination overlap in the same window, so that we can use planar
;     copies -- otherwise, it's faster to directly call of to
;     bPuntScreenToScreenCopyBits

; We're going top to bottom. Map in the source and dest, top-justified.

        mov     ebx,ppdev
        mov     edi,ulCurrentDestScan

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yTop
        jl      short top_1RW_map_init_bank

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yBottom
        jl      short top_1RW_init_bank_mapped

top_1RW_map_init_bank:

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>

top_1RW_init_bank_mapped:

        mov     eax,ulCurrentSrcScan
        cmp     eax,[ebx].pdev_rcl1PlanarClip.yBottom

        jl      short top_1RW_do_planar_copy

; ulCurrentSrcScan >= ppdev->rcl1PlanarClip.bottom, which means that
; the window can't overlap the source and destination at all.  We'll
; have to use an intermediate temporary buffer:

; ebx = ppdev
; eax = ulCurrentSrcScan
; edi = ulCurrentDestScan

        mov     ptlSrc.ptl_y,eax        ;ptlSrc.y = ulCurrentSrcScan
        mov     rclDest.yTop,edi        ;rclDest.top = ulCurrentDestScan

        mov     esi,[ebx].pdev_rcl1PlanarClip.yBottom
        mov     eax,ulLastDestScan
        sub     eax,esi
        sbb     ecx,ecx
        and     ecx,eax
        add     esi,ecx
        mov     rclDest.yBottom,esi     ;rclDest.bottom = min(ulLastDestScan,
                                        ;  ppdev->pdev_rcl1PlanarClip.bottom)

; Enable bit mask for all bits:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Enable writes to all planes and reset direction flag:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        pushfd
        cld

; Call our routine that copies bits the slow way, preserving EBX, ESI and EDI
; according to C calling conventions:

        lea     ecx,rclDest
        lea     edx,ptlSrc

        cCall   bPuntScreenToScreenCopyBits,<ebx,0,0,ecx,edx>

        popfd

; Set the bit mask to disable all bits, so we can copy through latches again:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(000h shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Update our position variables:

        mov     ulCurrentDestScan,esi   ;ulCurrentDestScan = rclDest.bottom

        sub     esi,edi                 ;ulBlockHeight = rclDest.bottom -
                                        ;  rclDest.top

        add     ulCurrentSrcScan,esi    ;ulCurrentSrcScan += ulBlockHeight

; We have to adjust the offsets for all our block copiers, according to the
; number of scans we copied:

        mov     edx,lDelta
        imul    edx,esi                 ;edx = lDelta * ulBlockHeight
        add     ulLeftSrc,edx
        add     ulLeftDest,edx
        add     ulMiddleSrc,edx
        add     ulMiddleDest,edx
        add     ulRightSrc,edx
        add     ulRightDest,edx

        jmp     short top_1RW_see_if_done

top_1RW_do_planar_copy:

; ebx = ppdev
; eax = ulCurrentSrcScan
; edi = ulCurrentDestScan

        mov     ebx,[ebx].pdev_rcl1PlanarClip.yBottom
        sub     ebx,eax                 ;ebx = ppdev->rcl1PlanarClip.bottom -
                                        ;  ulCurrentSrcScan
                                        ;ebx is the available number of scans
                                        ;  we have in the source

        mov     edx,ulLastDestScan
        sub     edx,edi                 ;edx = ulLastDestScan - ulCurrentDestScan
                                        ;edx is the available number of scans
                                        ;  in the destination

; (Because the source starts lower in the window than the destination,
; the bottom of the bank always limits the source number of scans before
; it does the destination.)

        sub     ebx,edx
        sbb     ecx,ecx
        and     ecx,ebx
        add     edx,ecx                 ;edx = min(source available,
                                        ;  destination available)
        mov     ulBlockHeight,edx

        add     eax,edx                 ;We have to adjust our current scans
        add     edi,edx
        mov     ulCurrentSrcScan,eax
        mov     ulCurrentDestScan,edi

; Now copy the puppy:

        call    pfnCopyBlocks

; See if we're done:

top_1RW_see_if_done:
        mov     edi,ulCurrentDestScan
        cmp     edi,ulLastDestScan
        jge     all_done

        mov     ebx,ppdev

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>

        jmp     top_1RW_init_bank_mapped

;-----------------------------------------------------------------------;
; Banking for 1 R/W adapters, bottom to top.
;
; Input:
;       ulCurrentSrcScan  - Actually, 1 more current source scan
;       ulCurrentDestScan - Actually, 1 more current destination scan
;       ulLastDestScan
;       Plus some other stuff for split rasters and block copiers
;-----------------------------------------------------------------------;
        public  bottom_to_top_1RW
bottom_to_top_1RW::

; We're going top to bottom. Map in the source and dest, top-justified.

        mov     ebx,ppdev
        mov     edi,ulCurrentDestScan

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yTop
        jle     short bot_1RW_map_init_bank

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yBottom
        jle     short bot_1RW_init_bank_mapped

bot_1RW_map_init_bank:

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     edi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>
        inc     edi

bot_1RW_init_bank_mapped:

        mov     eax,ulCurrentSrcScan
        cmp     eax,[ebx].pdev_rcl1PlanarClip.yTop

        jg      short bot_1RW_do_planar_copy

; ulCurrentSrcScan <= ppdev->rcl1PlanarClip.top, which means that
; the window can't overlap the source and destination at all.  We'll
; have to use an intermediate temporary buffer:

; ebx = ppdev
; eax = ulCurrentSrcScan
; edi = ulCurrentDestScan

        mov     esi,[ebx].pdev_rcl1PlanarClip.yTop
        mov     edx,ulLastDestScan
        cmp     esi,edx
        jg      @F
        mov     esi,edx
@@:
        mov     rclDest.yTop,esi        ;rclDest.top = max(ulLastDestScan,
                                        ;  ppdev->rcl1PlanarClip.top)

        mov     rclDest.yBottom,edi     ;rclDest.bottom = ulCurrentDestScan
        add     eax,esi
        sub     eax,edi
        mov     ptlSrc.ptl_y,eax        ;ptlSrc.y = ulCurrentSrcScan -
                                        ;  (rclDest.bottom - rclDest.top)

; Enable bit mask for all bits:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Enable writes to all planes and reset direction flag:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        pushfd
        cld

; Call our routine that copies bits the slow way, preserving EBX, ESI and EDI
; according to C calling conventions:

        lea     ecx,rclDest
        lea     edx,ptlSrc

        cCall   bPuntScreenToScreenCopyBits,<ebx,0,0,ecx,edx>

        popfd

; Set the bit mask to disable all bits, so we can copy through latches again:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(000h shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Update our position variables:

        mov     ulCurrentDestScan,esi   ;ulCurrentDestScan = rclDest.top

        sub     edi,esi                 ;ulBlockHeight = rclDest.bottom -
                                        ;  rclDest.top

        sub     ulCurrentSrcScan,edi    ;ulCurrentSrcScan -= ulBlockHeight

; We have to adjust the offsets for all our block copiers, according to the
; number of scans we copied:

        mov     edx,lDelta
        imul    edx,edi                 ;edx = lDelta * ulBlockHeight
        add     ulLeftSrc,edx
        add     ulLeftDest,edx
        add     ulMiddleSrc,edx
        add     ulMiddleDest,edx
        add     ulRightSrc,edx
        add     ulRightDest,edx

        jmp     short bot_1RW_see_if_done

bot_1RW_do_planar_copy:

; ebx = ppdev
; eax = ulCurrentSrcScan
; edi = ulCurrentDestScan

        sub     eax,[ebx].pdev_rcl1PlanarClip.yTop
                                        ;eax = ulCurrentSrcScan -
                                        ;  ppdev->rcl1PlanarClip.top

        sub     edi,ulLastDestScan      ;edi = ulCurrentDestScan - ulLastDestScan
                                        ;edi is the available number of scans
                                        ;  in the destination


; (Because the source starts higher in the window than the destination,
; the bottom of the bank always limits the source number of scans before
; it does the destination.)

        sub     eax,edi
        sbb     ecx,ecx
        and     ecx,eax
        add     edi,ecx                 ;edi = min(source available,
                                        ;  destination available)

        mov     ulBlockHeight,edi

        sub     ulCurrentSrcScan,edi    ;We have to adjust our current scans
        sub     ulCurrentDestScan,edi

; Now copy the puppy:

        call    pfnCopyBlocks

; See if we're done:

bot_1RW_see_if_done:
        mov     edi,ulCurrentDestScan
        cmp     edi,ulLastDestScan
        jle     all_done

        mov     ebx,ppdev

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     edi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>
        inc     edi

        jmp     bot_1RW_init_bank_mapped

;-----------------------------------------------------------------------;
; Banking for 1R/1W or 2R/W adapters, top to bottom.
;
; Input:
;       ulCurrentSrcScan
;       ulCurrentDestScan
;       ulLastDestScan
;       Plus some other stuff for split rasters and block copiers
;-----------------------------------------------------------------------;
        public  top_to_bottom_2RW
top_to_bottom_2RW::

; We're going top to bottom. Map in the destination, top-justified.

        mov     ebx,ppdev
        mov     edi,ulCurrentDestScan
        mov     esi,ulCurrentSrcScan

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yTop
        jl      short top_2RW_map_init_dest_bank

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yBottom
        jl      short top_2RW_init_dest_bank_mapped

top_2RW_map_init_dest_bank:

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyTop,MapDestBank>

top_2RW_init_dest_bank_mapped:

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yTop
        jl      short top_2RW_map_init_src_bank

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yBottom
        jl      short top_2RW_main_loop

top_2RW_map_init_src_bank:

; Map bank containing the top source scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,esi,JustifyTop,MapSourceBank>

top_2RW_main_loop:
        mov     ecx,[ebx].pdev_rcl2PlanarClipD.yBottom
        mov     edx,ulLastDestScan

        sub     ecx,edx
        sbb     eax,eax
        and     eax,ecx
        add     edx,eax                 ;edx = min(ulLastDestScan,
                                        ;  ppdev->rcl2PlanarClipD.bottom)

        mov     ecx,[ebx].pdev_rcl2PlanarClipS.yBottom

        sub     edx,edi                 ;edx = available scans in destination
                                        ;  bank
        sub     ecx,esi                 ;ecx = available scans in source bank

        sub     ecx,edx
        sbb     eax,eax
        and     eax,ecx
        add     edx,eax

        mov     ulBlockHeight,edx       ;ulBlockHeight = min(source available,
                                        ;  dest available)

        add     esi,edx                 ;adjust our currents scans accordingly
        add     edi,edx
        mov     ulCurrentSrcScan,esi
        mov     ulCurrentDestScan,edi

; Do the actual copy:

        call    pfnCopyBlocks

        mov     edi,ulCurrentDestScan   ;check if done
        cmp     edi,ulLastDestScan
        jge     all_done

        mov     ebx,ppdev

; We'll have to map a new source bank, destination bank, or both:

        mov     esi,ulCurrentSrcScan
        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yBottom
        jl      short top_2RW_map_next_src_bank

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyTop,MapDestBank>

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yBottom
        jl      short top_2RW_main_loop

top_2RW_map_next_src_bank:

; Map bank containing the top source scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,esi,JustifyTop,MapSourceBank>

        jmp     short top_2RW_main_loop

;-----------------------------------------------------------------------;
; Banking for 1R/1W or 2R/W adapters, bottom to top.
;
; Input:
;       ulCurrentSrcScan
;       ulCurrentDestScan
;       ulLastDestScan
;       Plus some other stuff for split rasters and block copiers
;-----------------------------------------------------------------------;
        public  bottom_to_top_2RW
bottom_to_top_2RW::

; We're going bottom to top. Map in the destination, bottom-justified.

        mov     ebx,ppdev
        mov     edi,ulCurrentDestScan   ; 1 more than actual destination scan
        mov     esi,ulCurrentSrcScan    ; 1 more than actual source scan

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yTop
        jle     short bot_2RW_map_init_dest_bank

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yBottom
        jle     short bot_2RW_init_dest_bank_mapped

bot_2RW_map_init_dest_bank:

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     edi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyBottom,MapDestBank>
        inc     edi

bot_2RW_init_dest_bank_mapped:

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yTop
        jle     short bot_2RW_map_init_src_bank

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yBottom
        jle     short bot_2RW_main_loop

bot_2RW_map_init_src_bank:

; Map bank containing the top source scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     esi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,esi,JustifyBottom,MapSourceBank>
        inc     esi

bot_2RW_main_loop:
        mov     ecx,[ebx].pdev_rcl2PlanarClipD.yTop
        mov     edx,ulLastDestScan

        cmp     edx,ecx
        jg      @F
        mov     edx,ecx                 ;edx = max(ulLastDestScan,
@@:                                     ;  ppdev->rcl2PlanarClipD.top)

        sub     edi,edx                 ;edi = available scans in destination
                                        ;  bank
        sub     esi,[ebx].pdev_rcl2PlanarClipS.yTop
                                        ;esi = available scans in source bank

        sub     esi,edi
        sbb     eax,eax
        and     eax,esi
        add     edi,eax

        mov     ulBlockHeight,edi       ;ulBlockHeight = min(source available,
                                        ;  dest available)

        sub     ulCurrentSrcScan,edi    ;adjust our current scans
        sub     ulCurrentDestScan,edi

; Do the actual copy:

        call    pfnCopyBlocks

        mov     edi,ulCurrentDestScan   ;check if done
        cmp     edi,ulLastDestScan
        jle     all_done

        mov     ebx,ppdev

; We'll have to map a new source bank, destination bank, or both:

        mov     esi,ulCurrentSrcScan
        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yTop
        jg      short bot_2RW_map_next_src_bank

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     edi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyBottom,MapDestBank>
        inc     edi

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yTop
        jg      short bot_2RW_main_loop

bot_2RW_map_next_src_bank:

; Map bank containing the top source scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     esi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,esi,JustifyBottom,MapSourceBank>
        inc     esi

        jmp     short bot_2RW_main_loop

;=======================================================================;
;=========================== Block Copiers =============================;
;=======================================================================;

;-----------------------------------------------------------------------;
; Input:
;       Direction flag  - set to the appropriate direction
;       ulMiddleSrc     - offset in bitmap to source
;       ulMiddleDest    - offset in bitmap to destination
;       lMiddleDelta    - distance from end of current scan to start of next
;       ulBlockHeight   - # of scans to copy
;       cjMiddle        - # of planar bytes to copy on every scan
;
; Output:
;       Advances ulMiddleSrc and ulMiddleDest to next strip
;-----------------------------------------------------------------------;

        public  copy_middle_block
copy_middle_block::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

copy_just_middle_block::

; Calculate full start addresses:

        mov     edi,ppdev
        mov     eax,cjMiddle
        mov     ebx,ulBlockHeight
        mov     edx,lMiddleDelta
        mov     esi,[edi].pdev_pvBitmapStart2WindowS
        mov     edi,[edi].pdev_pvBitmapStart2WindowD
        add     esi,ulMiddleSrc
        add     edi,ulMiddleDest

        SET_UP_UNROLL_VARS ebx,ecx,ebx,pfnCopyMiddleEntry, \
                                LOOP_UNROLL_SHIFT

        jmp     ecx

        UNROLL_LOOP_ENTRY_TABLE pfnCopyMiddleEntry,MIDDLE, \
                                LOOP_UNROLL_COUNT

COPY_MIDDLE macro ENTRY_LABEL,ENTRY_INDEX
&ENTRY_LABEL&ENTRY_INDEX&:
        mov     ecx,eax
        rep     movsb
        add     esi,edx
        add     edi,edx
        endm    ;-----------------------------------;

;  EAX = # of bytes to copy
;  EBX = count of unrolled loop iterations
;  EDX = offset from end of one scan's fill to start of next
;  ESI = source address from which to copy
;  EDI = target address to which to copy

middle_loop:
        UNROLL_LOOP     COPY_MIDDLE,MIDDLE,LOOP_UNROLL_COUNT
        dec     ebx
        jnz     middle_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     esi,[ecx].pdev_pvBitmapStart2WindowS
        sub     edi,[ecx].pdev_pvBitmapStart2WindowD
        mov     ulMiddleSrc,esi
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; Input:
;       ulLeftSrc     - offset in bitmap to source
;       ulLeftDest    - offset in bitmap to destination
;       lDelta        - distance from between planar scans
;       ulBlockHeight - # of scans to copy
;
; Output:
;       Advances ulLeftSrc and ulLeftDest to next strip
;-----------------------------------------------------------------------;

        public  copy_left_block
copy_left_block::

; Set left mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulLeftMask
        out     dx,al

; Calculate full start addresses:

        mov     ecx,ppdev
        mov     ebx,ulBlockHeight
        mov     edx,lDelta
        mov     esi,[ecx].pdev_pvBitmapStart2WindowS
        mov     edi,[ecx].pdev_pvBitmapStart2WindowD
        add     esi,ulLeftSrc
        add     edi,ulLeftDest

        SET_UP_UNROLL_VARS ebx,eax,ebx,pfnCopyLeftEntry, \
                                LOOP_UNROLL_SHIFT

        jmp     eax

        UNROLL_LOOP_ENTRY_TABLE pfnCopyLeftEntry,LEFT, \
                                LOOP_UNROLL_COUNT

COPY_LEFT macro ENTRY_LABEL,ENTRY_INDEX
&ENTRY_LABEL&ENTRY_INDEX&:
        mov     al,[esi]
        mov     [edi],al
        add     esi,edx
        add     edi,edx
        endm    ;-----------------------------------;

;  EBX = count of unrolled loop iterations
;  EDX = offset from one scan to next
;  ESI = source address from which to copy
;  EDI = target address to which to copy

left_loop:
        UNROLL_LOOP     COPY_LEFT,LEFT,LOOP_UNROLL_COUNT
        dec     ebx
        jnz     left_loop

; get ready for next time:

        sub     esi,[ecx].pdev_pvBitmapStart2WindowS
        sub     edi,[ecx].pdev_pvBitmapStart2WindowD
        mov     ulLeftSrc,esi
        mov     ulLeftDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; Input:
;       ulRightSrc    - offset in bitmap to source
;       ulRightDest   - offset in bitmap to destination
;       lDelta        - distance from between planar scans
;       ulBlockHeight - # of scans to copy
;
; Output:
;       Advances ulRightSrc and ulRightDest to next strip
;-----------------------------------------------------------------------;

        public  copy_right_block
copy_right_block::

; Set right mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulRightMask
        out     dx,al

; Calculate full start addresses:

        mov     ecx,ppdev
        mov     ebx,ulBlockHeight
        mov     edx,lDelta
        mov     esi,[ecx].pdev_pvBitmapStart2WindowS
        mov     edi,[ecx].pdev_pvBitmapStart2WindowD
        add     esi,ulRightSrc
        add     edi,ulRightDest

        SET_UP_UNROLL_VARS ebx,eax,ebx,pfnCopyRightEntry, \
                                LOOP_UNROLL_SHIFT

        jmp     eax

        UNROLL_LOOP_ENTRY_TABLE pfnCopyRightEntry,RIGHT, \
                                LOOP_UNROLL_COUNT

COPY_RIGHT macro ENTRY_LABEL,ENTRY_INDEX
&ENTRY_LABEL&ENTRY_INDEX&:
        mov     al,[esi]
        mov     [edi],al
        add     esi,edx
        add     edi,edx
        endm    ;-----------------------------------;

;  EBX = count of unrolled loop iterations
;  EDX = offset from one scan to next
;  ESI = source address from which to copy
;  EDI = target address to which to copy

right_loop:
        UNROLL_LOOP     COPY_RIGHT,RIGHT,LOOP_UNROLL_COUNT
        dec     ebx
        jnz     right_loop

; get ready for next time:

        sub     esi,[ecx].pdev_pvBitmapStart2WindowS
        sub     edi,[ecx].pdev_pvBitmapStart2WindowD
        mov     ulRightSrc,esi
        mov     ulRightDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;

endProc vPlanarCopyBits

        end


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\16bpp\i386\unroll.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: unroll.inc
;
; Equates and macros for loop unrolling.
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

; Module including this must define LOOP_UNROLL_SHIFT. the log2 of the number
; of times you want loops in this module unrolled. For example,
; LOOP_UNROLL_SHIFT of 3 yields 2**3 = 8 times unrolling. This is the only
; thing you need to change to control unrolling.

; # of times to unroll the loop, calculated as 2**n, where n is the
; user-specified log2 of # of times to unroll the loop.

LOOP_UNROLL_COUNT equ   (1 shl LOOP_UNROLL_SHIFT)

;-----------------------------------------------------------------------;
; Macro to generate an unrolled loop of UNROLL_COUNT instances of BASE_MACRO,
; passing the base macro the info needed to construct a label of the form
; BASE_LABELxxx, where xxx is UNROLL_COUNT the first time, and counts down by
; one each time thereafter.

UNROLL_LOOP macro BASE_MACRO,BASE_LABEL,UNROLL_COUNT

INDEX=UNROLL_COUNT
        rept UNROLL_COUNT ;-------------------------;
        &BASE_MACRO &BASE_LABEL,%INDEX
INDEX=INDEX-1
        endm    ;-----------------------------------;

        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;
; Macro to generate a dword memory variable that points to the label
; specified by concatenating the label and the index.

DEFINE_DD macro BASE_LABEL,INDEX ;------------------;
        dd      &BASE_LABEL&INDEX
        endm    ;-----------------------------------;
        
;-----------------------------------------------------------------------;
; Macro to generate a table of vectors into an unrolled loop, for entering
; to handle all possible fractional loops.

UNROLL_LOOP_ENTRY_TABLE macro TABLE,BASE_LABEL,UNROLL_COUNT
        align   4
TABLE label  dword
        DEFINE_DD       BASE_LABEL,%&UNROLL_COUNT

INDEX=1
        rept    UNROLL_COUNT-1
        DEFINE_DD       BASE_LABEL,%INDEX
INDEX=INDEX+1
        endm    ;-----------------------------------;

        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;
; Given a loop count, a vector table, and unrolling parameters, this generates
; COUNT_DEST = # of times to execute unrolled loop, VEC_DEST = entry point into
; unrolled loop to perform whatever fractional loop is needed. Assumes dests
; are registers.
        
SET_UP_UNROLL_VARS macro COUNT_DEST,VEC_DEST,COUNT_SOURCE,VEC_TABLE,UNROLL_SHIFT
        mov     &VEC_DEST&,&COUNT_SOURCE&       ;copy count to vector dest to
                                                ; work with it
        ifdifi  <&COUNT_SOURCE&>,<&COUNT_DEST&>
        mov     &COUNT_DEST&,&COUNT_SOURCE&     ;copy to count dest too, if not
        endif                                   ; same as count source
        add     &COUNT_DEST&,(1 shl LOOP_UNROLL_SHIFT)-1 ;round count up
        and     &VEC_DEST&,(1 shl LOOP_UNROLL_SHIFT)-1
                                            ;fractional part of unrolled loop
        shr     &COUNT_DEST&,UNROLL_SHIFT    ;# of repetitions of unrolled loop
        mov     &VEC_DEST&,&VEC_TABLE&[&VEC_DEST&*4]
                                            ;place to jump into the unrolled
                                            ; loop so as to handle the
                                            ; fractional part first
        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;
; Given a loop count, a vector table, and unrolling parameters, this generates
; COUNT_DEST = # of times to execute unrolled loop, VEC_DEST = entry point into
; unrolled loop to perform whatever fractional loop is needed. Assumes dests
; are registers.
        
SET_UP_UNROLL_AND_BRANCH macro COUNT_REG,VEC_REG,VEC_TABLE,UNROLL_SHIFT
        mov     &VEC_REG&,&COUNT_REG&       ;copy count to vector dest to
                                            ; work with it
        add     &COUNT_reg&,(1 shl LOOP_UNROLL_SHIFT)-1 ;round count up
        and     &VEC_REG&,(1 shl LOOP_UNROLL_SHIFT)-1
                                            ;fractional part of unrolled loop
        shr     &COUNT_REG&,UNROLL_SHIFT    ;# of repetitions of unrolled loop
        jmp     dword ptr &VEC_TABLE&[&VEC_REG&*4]
                                            ;jump into the unrolled loop so as
					    ; to handle the fractional part
					    ; first
        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\16bpp\i386\ropdefs.inc ===
;----------------------------Module-Header------------------------------;
; Module Name: ROPDEFS.BLT
;
; Constants relating to raster operation definitions.
;
; Copyright (c) 1988 - 1992  Microsoft Corporation
;
; These constants are used mainly in the file ROPTABLE.BLT, in which
; the raster operation code templates are defined.
;
; This file is part of a set that makes up the Windows BitBLT function
; at driver-level.
;-----------------------------------------------------------------------;

        subttl  Raster Operation Definitions
        page


if 0                                    ; Not passed to us anymore !!!

;       Raster Op Definitions
;
;
;       The include file COMMENT.BLT contains a good description
;       of the encoding of the raster operations.  It should be
;       read before examining the definitions that follow.
;
;       The sixteen-bit number indicating which raster Op is to be
;       performed is encoded in the following manner:


EPS_OFF =       0000000000000011b       ;Offset within parse string
EPS_INDEX =     0000000000011100b       ;Parse string index
LogPar  =       0000000000100000b       ;(1 indicates implied NOT as Logop6)
LogOp1  =       0000000011000000b       ;Logical Operation #1
LogOp2  =       0000001100000000b       ;Logical Operation #2
LogOp3  =       0000110000000000b       ;Logical Operation #3
LogOp4  =       0011000000000000b       ;Logical Operation #4
LogOp5  =       1100000000000000b       ;Logical Operation #5


;       The parity bit is used to encode an optional sixth logical operation
;       which will always be a "NOT".  In most cases this is used to get an
;       even number of "NOT"s so that reduction can take place (two sequential
;       trailing "NOT"s cancel each other out and thus are eliminated).



;       Each LogOp (Logical Operation) is encoded as follows:

LogNOT  =       00b                     ;NOT result
LogXOR  =       01b                     ;XOR result with next operand
LogOR   =       10b                     ;OR  result with next operand
LogAND  =       11b                     ;AND result with next operand



;       The parse string is a string which contains the operands for
;       the logical operation sequences (source, destination, pattern).
;       The logic opcodes are applied to the current result and the next
;       element of the given string (unless the LogOp is a NOT which only
;       affects the result).
;
;       The string is encoded as eight two-bit numbers indicating which
;       operand is to be used

opDefs          struc
  OpSpec        db      ?                 ;Special Operand as noted below
  OpSrc         db      ?                 ;Operand is source field
  OpDest        db      ?                 ;Operand is destination field
  OpPat         db      ?                 ;Operand is pattern field
opDefs          ends



;       The special operand is used for a few rops that would not fit into
;       an RPN format.  On the first occurance of an OpSpec, the current result
;       is "PUSHED", and the next operand is loaded.  On the second occurance
;       of the OpSpec, the given logic operation is performed between the
;       current result and the "PUSHED" value.
;
;       **NOTE**  Since there can be no guarantee that the client will call
;       the BLT routine with one of the 256 published raster ops, it is
;       possible that a value might be "PUSHED" and then never "POPPED".
;       If these "PUSHES" are made to the stack, then care must be made to
;       remove the "PUSHED" value.
;
;       In any case, since the raster op was not one of the published
;       "magic numbers", the BLT can be aborted or the result can be
;       computed to the extent possible.  The only restriction is that it
;       must not crash the system (i.e. don't leave extra stuff on the stack).
;
;               Simply: Compute garbage, but don't crash!




;       Define the parse strings to be allocated later.
;
;       An example parse string for the pattern "SDPSDPSD" would be
;       "0110110110110110b"


parseStr0       =       07AAAh          ;src,pat,dest,dest,dest,dest,dest,dest
parseStr1       =       079E7h          ;src,pat,dest,src,pat,dest,src,pat
parseStr2       =       06DB6h          ;src,dest,pat,src,dest,pat,src,dest
parseStr3       =       0AAAAh          ;dest,dest,dest,dest,dest,dest,dest,dest
parseStr4       =       0AAAAh          ;dest,dest,dest,dest,dest,dest,dest,dest
parseStr5       =       04725h          ;src,spec,src,pat,spec,dest,src,src
parseStr6       =       04739h          ;src,spec,src,pat,spec,pat,dest,src
parseStr7       =       04639h          ;src,spec,src,dest,spec,pat,dest,src



;       The following equates are for certain special functions that are
;       derived from the very first string (index of SpecParseStrIndex).
;
;       These strings will have their innerloops special cased for
;       speed enhancements (i.e MOVSx and STOSx for pattern copys and
;       white/black fill, and MOVSx for source copy if possible)

PAT_COPY        equ     0021h           ;P    - dest = Pattern
NOTPAT_COPY     equ     0001h           ;Pn   - dest = NOT Pattern
FILL_BLACK      equ     0042h           ;DDx  - dest = 0 (black)
FILL_WHITE      equ     0062h           ;DDxn - dest = 1
SOURCE_COPY     equ     0020h           ;S    - dest = source


        errnz   LogXOR-01b              ;These must hold true for above equates
        errnz   LogOp1-0000000011000000b
        errnz   LogPar-0000000000100000b
        errnz   parseStr0-7AAAh         ;  plus the string must be SPDD


SPEC_PARSE_STR_INDEX equ        0       ;Special cased strings index

endif

;       The raster operation table consists of a word for each of
;       the first 128 raster operations (00 through 7F).  The second
;       half of the raster operations (FF through 80) are the inverse
;       of the first half.
;
;       The table is encoded as follows:
;
;           N S P LLL OOOOOOOOOO
;           | | |  |      |
;           | | |  |      |_____  Offset of code from roptable.
;           | | |  |
;           | | |  |____________  Length index
;           | | |
;           | | |_______________  Pattern is present
;           | |
;           | |_________________  Source is present
;           |
;           |___________________  Generate trailing NOT
;
;
;       To map the ROPS 80h through FFh to 00h through 7Fh, take the
;       1's complement of the ROP, and invert 'N' above.
;
;
;       Notes:
;
;           1)  An offset of 0 is reserved for source copy.  This
;               was done to reduce the number of LLLs to 8, so that
;               the above encoding could fit into a 16-bit integer.
;
;
;           2)  LLL only allows a maximum of 8 different template sizes!
;               Actual length is at roptable+256+LLL.
;
;
;
;
;       ROP is the macro that generates the equates which will be
;       stored into the roptable as specified above.
;
;       Usage:
;
;           ROPDEF      Pattern,Number
;
;       Where
;
;           Pattern     Is the RPN definition of the raster operation.
;                       It is used as the label of the first byte of
;                       the template.  It also is used to determine
;                       is there is a (S)ource, (P)attern, and if the
;                       final result is to be (n)egated.
;
;           Number      is the boolean result of the raster operation
;                       based on a P=F0, S=CC, and D=AA.  These labels
;                       and indexes can be found in the file COMMENT.BLT
;
;                       Since there are many equivelent boolean expresions,
;                       some of the rops will not match the label given.
;                       The label is for reference only.  The final result
;                       is what counts.



ROPOffset       equ     0000001111111111b
ROPLength       equ     0001110000000000b
SOURCE_PRESENT  equ     0010000000000000b
PATTERN_PRESENT equ     0100000000000000b
NEGATE_NEEDED   equ     1000000000000000b


;       Define the eight template length indices.

ROPLen0         equ     0
ROPLen2         equ     1
ROPLen4         equ     2
ROPLen6         equ     3
ROPLen8         equ     4
ROPLen10        equ     5
ROPLen12        equ     6
ROPLen14        equ     7

; Binary raster ops
R2_BLACK            equ 1
R2_NOTMERGEPEN      equ 2
R2_MASKNOTPEN       equ 3
R2_NOTCOPYPEN       equ 4
R2_MASKPENNOT       equ 5
R2_NOT              equ 6
R2_XORPEN           equ 7
R2_NOTMASKPEN       equ 8
R2_MASKPEN          equ 9
R2_NOTXORPEN        equ 10
R2_NOP              equ 11
R2_MERGENOTPEN      equ 12
R2_COPYPEN          equ 13
R2_MERGEPENNOT      equ 14
R2_MERGEPEN         equ 15
R2_WHITE            equ 16
R2_LAST             equ 16



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\bitblt.h ===
/******************************Module*Header*******************************\
* Module Name: bitblt.h
*
* BitBlt
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

/// Define the A vector polynomial bits
//
// Each bit corresponds to one of the terms in the polynomial
//
// Rop(D,S,P) = a + a D + a S + a P + a  DS + a  DP + a  SP + a   DSP
//               0   d     s     p     ds      dp      sp      dsp

#define AVEC_NOT    0x01
#define AVEC_D      0x02
#define AVEC_S      0x04
#define AVEC_P      0x08
#define AVEC_DS     0x10
#define AVEC_DP     0x20
#define AVEC_SP     0x40
#define AVEC_DSP    0x80

#define AVEC_NEED_SOURCE  (AVEC_S | AVEC_DS | AVEC_SP | AVEC_DSP)
#define AVEC_NEED_PATTERN (AVEC_P | AVEC_DP | AVEC_SP | AVEC_DSP)

#define BB_TARGET_SCREEN    0x0001
#define BB_TARGET_ONLY      0x0002
#define BB_SOURCE_COPY      0x0004
#define BB_PATTERN_COPY     0x0008


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\bank.c ===
/******************************Module*Header*******************************\
* Module Name: bank.c
*
* Functions to control VGA banking
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/


#include "driver.h"                 // private driver defines

void BankErrorTrap(PDEVSURF, LONG, BANK_JUST);
void Bank2Window(PDEVSURF, LONG, BANK_JUST, ULONG);
void Bank2Window2RW(PDEVSURF, LONG, BANK_JUST, ULONG);
void Bank2Window1RW(PDEVSURF, LONG, BANK_JUST, ULONG);
void Bank1Window2RW(PDEVSURF, LONG, BANK_JUST);
void Bank1Window(PDEVSURF, LONG, BANK_JUST);

LPBYTE pPtrWork;
LPBYTE pPtrSave;

/******************************Public*Routine******************************\
* SetUpBanking
*
* Set up banking for the current mode
* pdsurf and ppdev are the pointers to the current surface and device
* Relevant fields in the surface are set up for banking
\**************************************************************************/

BOOL SetUpBanking(PDEVSURF pdsurf, PPDEV ppdev)
{
    INT i;
    LONG lTemp;
    LONG lScansPerBank, lScan, lTotalScans, lTotalBanks;
    LONG lScansBetweenBanks;
    ULONG ulOffset;
    PVIDEO_BANK_SELECT BankInfo;
    UINT ReturnedDataLength;
    VIDEO_BANK_SELECT TempBankInfo;
    PBANK_INFO pbiWorking;
    DWORD status;

    //
    // Query the miniport for banking info for this mode.
    //
    // First, figure out how big a buffer we need for the banking info
    // (returned in TempBankInfo->Size).
    //

    if (status = EngDeviceIoControl(ppdev->hDriver,
                                    IOCTL_VIDEO_GET_BANK_SELECT_CODE,
                                    NULL,
                                    0,
                                    &TempBankInfo,
                                    sizeof(VIDEO_BANK_SELECT),
                                    &ReturnedDataLength)) {

        //
        // We expect this call to fail, because we didn't allow any room
        // for the code; we just want to get the required output buffer
        // size. Make sure we got the expected error, ERROR_MORE_DATA.
        //

        if (status != ERROR_MORE_DATA) {
            //
            // Should post error and return FALSE
            //

            //RIP("Initialization error-GetBankSelectCode, first call\n");
            //return FALSE;
        }

    }


    //
    // Now, allocate a buffer of the required size and get the banking info.
    //

    if ((BankInfo = (PVIDEO_BANK_SELECT)
            EngAllocMem(0, TempBankInfo.Size, ALLOC_TAG)) == NULL) {

        //
        // Should post error and return FALSE
        //

        RIP("Initialization error-couldn't get memory for bank info\n");
        return FALSE;


    }

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_GET_BANK_SELECT_CODE,
                           NULL,
                           0,
                           BankInfo,
                           TempBankInfo.Size,
                           &ReturnedDataLength)) {

        //
        // Should post error and return FALSE
        //

        RIP("Initialization error-GetBankSelectCode, second call\n");
        return FALSE;

    }

    //
    // Set up for banking.
    //

    // Set up variables that are the same whether the adapter is banked or not

    pdsurf->pBankSelectInfo = BankInfo;
    pdsurf->pfnBankSwitchCode =
         (PFN) (((UCHAR *)BankInfo) + BankInfo->CodeOffset);
    pdsurf->vbtBankingType = BankInfo->BankingType;
    pdsurf->ulBitmapSize = BankInfo->BitmapSize;
    pdsurf->lNextScan = BankInfo->BitmapWidthInBytes;

    // Set up the pointer off-screen work areas at the very end of display
    // memory (values are relative to bitmap start)
    ppdev->pPtrWork = pPtrWork = (LPBYTE) pdsurf->ulBitmapSize - POINTER_WORK_AREA_SIZE;
    ppdev->pPtrSave = pPtrSave = pPtrWork - POINTER_SAVE_AREA_SIZE;

    ppdev->sizlMem.cx = BankInfo->BitmapWidthInBytes *
                        (PLANAR_PELS_PER_CPU_ADDRESS);
    ppdev->sizlMem.cy = BankInfo->BitmapSize / BankInfo->BitmapWidthInBytes;

    DISPDBG((1,"ppdev->sizlMem.cx = %lu\n",ppdev->sizlMem.cx));
    DISPDBG((1,"ppdev->sizlMem.cy = %lu\n",ppdev->sizlMem.cy));
    DISPDBG((1,"BankInfo->Size = %lu\n",BankInfo->Size));
    DISPDBG((1,"BankInfo->Length = %lu\n",BankInfo->Length));

    //
    // calculate how many scans of offscreen memory are used by the pointer
    //

    ppdev->cNumScansUsedByPointer =
        (POINTER_SAVE_AREA_SIZE + POINTER_WORK_AREA_SIZE +
         BankInfo->BitmapWidthInBytes - 1) /
        (BankInfo->BitmapWidthInBytes);

    DISPDBG((1,"Software pointer uses %lu scans\n", ppdev->cNumScansUsedByPointer));

    //
    // for 1280x1024x16 in 1M, check to see that we actually have the
    // scans to put the pointer in offscreen video memory.  If not,
    // lie and set flag that keeps the driver from trying.
    //

    if ((LONG)ppdev->cNumScansUsedByPointer > (ppdev->sizlMem.cy - ppdev->sizlSurf.cy))
    {
        ppdev->fl &= ~DRIVER_OFFSCREEN_REFRESHED;
    }

    // Set up info that depends on whether or not the adapter is banked

    if (BankInfo->BankingType == VideoNotBanked) {

        lTotalScans = BankInfo->BitmapSize / BankInfo->BitmapWidthInBytes;

        // Unbanked; set all clip rects for the full bitmap, so the bank never
        // needs to be changed, and set the banking vectors to error traps,
        // since they should never be called

        pdsurf->rcl1WindowClip.left = pdsurf->rcl2WindowClip[0].left =
            pdsurf->rcl2WindowClip[1].left = pdsurf->rcl1WindowClip.top =
            pdsurf->rcl2WindowClip[0].top = pdsurf->rcl2WindowClip[1].top = 0;

        pdsurf->rcl1WindowClip.right = pdsurf->rcl2WindowClip[0].right =
            pdsurf->rcl2WindowClip[1].right =
                    BankInfo->BitmapWidthInBytes << 8;

        pdsurf->rcl1WindowClip.bottom = pdsurf->rcl2WindowClip[0].bottom =
            pdsurf->rcl2WindowClip[1].bottom = lTotalScans;

        pdsurf->pfnBankControl = BankErrorTrap;
        pdsurf->pfnBankControl2Window = BankErrorTrap;

        pdsurf->ulWindowBank[0] = pdsurf->ulWindowBank[1] = (ULONG)0;
        pdsurf->pvBitmapStart = pdsurf->pvBitmapStart2Window[0] =
            pdsurf->pvBitmapStart2Window[1] = pdsurf->pvStart;

        // Scan line to be used with JustifyBottom to map in the bank
        // containing the pointer work and save areas, which are guaranteed not
        // to span banks. Is only used to determine that the bank never needs
        // to be changed to map in the pointer in unbanked case
        pdsurf->ulPtrBankScan = 0;

        // Mark that the bank info pointers are unused, so we don't try to
        // deallocate the memory they point to
        pdsurf->pbiBankInfo = pdsurf->pbiBankInfo2RW = NULL;

        // Allocate space for the temp buffer.

        if ((pdsurf->pvBankBufferPlane0 =
                (PVOID) EngAllocMem(0, BANK_BUFFER_SIZE_UNBANKED, ALLOC_TAG))
            == NULL) {

            //
            // Should post error and return FALSE
            //

            RIP("Couldn't get memory for temp buffer");
            return FALSE;

        }

        pdsurf->ulTempBufferSize = BANK_BUFFER_SIZE_UNBANKED;

        // These should never be used
        pdsurf->pvBankBufferPlane1 =
            pdsurf->pvBankBufferPlane2 =
            pdsurf->pvBankBufferPlane3 = (PVOID) NULL;

    } else {

        // Banked, so set up all banking variables and initialize the bank
        // control routines and their data tables

        // Reject if there are broken rasters (a broken raster is a scan line
        // that crosses a bank boundary); that's not handled in this driver

        if (BankInfo->BankingType != VideoBanked2RW) {

            // For the 1 RW window and 1R1W window cases, windows are
            // assumed to be BANK_SIZE_1_WINDOW in size (generally 64K)
            lTemp = BANK_SIZE_1_WINDOW;

        } else {

            // For the 2 RW window case, windows are assumed to be
            // BANK_SIZE_2RW_WINDOW in size (generally 32K)
            lTemp = BANK_SIZE_2RW_WINDOW;

        }

        if ((lTemp % BankInfo->BitmapWidthInBytes) != 0) {

            //
            // Should post error and return FALSE
            //

            RIP("Broken rasters not supported");
            return FALSE;

        }

        // These will be set properly on first call to bank controller, below,
        // or something's wrong
        pdsurf->ulWindowBank[0] = (ULONG)-1;
        pdsurf->ulWindowBank[1] = (ULONG)-1;
        pdsurf->pvBitmapStart = pdsurf->pvBitmapStart2Window[0] =
            pdsurf->pvBitmapStart2Window[1] = (PVOID) 0;

        // Set all clip rects to invalid; they'll be updated when the first
        // bank is mapped in

        pdsurf->rcl1WindowClip.left = pdsurf->rcl2WindowClip[0].left =
            pdsurf->rcl2WindowClip[1].left = pdsurf->rcl1WindowClip.top =
            pdsurf->rcl2WindowClip[0].top = pdsurf->rcl2WindowClip[1].top =
            pdsurf->rcl1WindowClip.right = pdsurf->rcl2WindowClip[0].right =
            pdsurf->rcl2WindowClip[1].right = pdsurf->rcl1WindowClip.bottom =
            pdsurf->rcl2WindowClip[0].bottom =
            pdsurf->rcl2WindowClip[1].bottom = -1;

        // Set up to call the appropriate banking control routines

        switch(BankInfo->BankingType) {

            case VideoBanked1RW:

                pdsurf->pfnBankControl = Bank1Window;
                pdsurf->pfnBankControl2Window = Bank2Window1RW;

                if ((pdsurf->pvBankBufferPlane0 =
                        (PVOID) EngAllocMem(0, BANK_BUFFER_SIZE_1RW, ALLOC_TAG))
                    == NULL) {

                    //
                    // Should post error and return FALSE
                    //

                    RIP("Couldn't get memory for temp buffer");
                    return FALSE;

                }

                pdsurf->ulTempBufferSize = BANK_BUFFER_SIZE_1RW;

                pdsurf->pvBankBufferPlane1 =
                        ((LPBYTE)pdsurf->pvBankBufferPlane0) +
                        BANK_BUFFER_PLANE_SIZE;
                pdsurf->pvBankBufferPlane2 =
                        ((LPBYTE)pdsurf->pvBankBufferPlane1) +
                        BANK_BUFFER_PLANE_SIZE;
                pdsurf->pvBankBufferPlane3 =
                        ((LPBYTE)pdsurf->pvBankBufferPlane2) +
                        BANK_BUFFER_PLANE_SIZE;

                break;


            case VideoBanked1R1W:

                pdsurf->pfnBankControl = Bank1Window;
                pdsurf->pfnBankControl2Window = Bank2Window;

                if ((pdsurf->pvBankBufferPlane0 =
                        (PVOID) EngAllocMem(0, BANK_BUFFER_SIZE_1R1W, ALLOC_TAG))
                    == NULL) {

                    //
                    // Should post error and return FALSE
                    //

                    RIP("Couldn't get memory for temp buffer");
                    return FALSE;

                }

                pdsurf->ulTempBufferSize = BANK_BUFFER_SIZE_1R1W;

                // These should never be used
                pdsurf->pvBankBufferPlane1 =
                        pdsurf->pvBankBufferPlane2 =
                        pdsurf->pvBankBufferPlane3 = (PVOID) NULL;

                break;


            case VideoBanked2RW:

                pdsurf->pfnBankControl = Bank1Window2RW;
                pdsurf->pfnBankControl2Window = Bank2Window2RW;

                if ((pdsurf->pvBankBufferPlane0 =
                        (PVOID) EngAllocMem(0, BANK_BUFFER_SIZE_2RW, ALLOC_TAG))
                     == NULL) {

                    //
                    // Should post error and return FALSE
                    //

                    RIP("Couldn't get memory for temp buffer");
                    return FALSE;

                }

                pdsurf->ulTempBufferSize = BANK_BUFFER_SIZE_2RW;

                // These should never be used
                pdsurf->pvBankBufferPlane1 =
                    pdsurf->pvBankBufferPlane2 =
                    pdsurf->pvBankBufferPlane3 = (PVOID) NULL;

                break;

            default:

                //
                // Should post error and return FALSE
                //

                RIP("bad BankingType");
                return FALSE;

        }

        // Set up the bank control tables with clip rects for banks
        // Note: lTotalBanks is generally an overestimate when granularity
        // is less than window size, because we ignore any banks after the
        // first one that includes the last scan line of the bitmap. A bit
        // of memory could be saved by sizing lTotalBanks exactly. Note too,
        // though, that the 2 RW window case may require more entries then,
        // because its windows are shorter, so you'd have to make sure there
        // were enough entries for the 2 RW window case, or recalculate
        // lTotalBanks for the 2 RW case

        lTotalBanks = BankInfo->BitmapSize / BankInfo->Granularity;
        lTotalScans = BankInfo->BitmapSize / BankInfo->BitmapWidthInBytes;
        lScansBetweenBanks =
                BankInfo->Granularity / BankInfo->BitmapWidthInBytes;

        // Allocate memory for bank control info

        if ((pdsurf->pbiBankInfo = (PBANK_INFO)
                EngAllocMem(0, lTotalBanks * sizeof(BANK_INFO), ALLOC_TAG))
             == NULL) {

            //
            // Should post error and return FALSE
            //

            RIP("Couldn't get memory for bank info #2");
            return FALSE;

        }

        // Build the list of bank rects & offsets assuming standard window
        // size

        lScansPerBank = BANK_SIZE_1_WINDOW / BankInfo->BitmapWidthInBytes;
        ulOffset = 0;
        lScan = -lScansBetweenBanks;    // precompensate for 1st time in loop
        i = 0;
        pbiWorking = pdsurf->pbiBankInfo;

        do {

            lScan += lScansBetweenBanks;
            pbiWorking->rclBankBounds.left = 0;
            pbiWorking->rclBankBounds.right = pdsurf->sizlSurf.cx;
            pbiWorking->rclBankBounds.top = lScan;
            pbiWorking->rclBankBounds.bottom = lScan + lScansPerBank;
            pbiWorking->ulBankOffset = ulOffset;
            ulOffset += BankInfo->Granularity;
            i++;
            pbiWorking++;

        } while ((lScan + lScansPerBank) < lTotalScans);

        pdsurf->ulBankInfoLength = i;

        // If this is a 2RW bank adapter, build a table for that too, with
        // 32K windows

        if (BankInfo->BankingType == VideoBanked2RW) {

            // Offset from one bank index to next to make two 32K banks
            // appear to be one seamless 64K bank
            pdsurf->ulBank2RWSkip =
                    (BANK_SIZE_2RW_WINDOW / BankInfo->Granularity);

            // Allocate memory for 2RW case bank control info
            if ((pdsurf->pbiBankInfo2RW =
                    (PBANK_INFO) EngAllocMem(0, lTotalBanks * sizeof(BANK_INFO), ALLOC_TAG))
                == NULL) {

                //
                // Should post error and return FALSE
                //

                RIP("Couldn't get memory for bank info #3");
                return FALSE;

            }

            // Build the list of bank rects & offsets for 2RW case
            lScansPerBank =
                    BANK_SIZE_2RW_WINDOW / BankInfo->BitmapWidthInBytes;
            lScan = -lScansBetweenBanks;    // precompensate for 1st time
            ulOffset = 0;
            i = 0;
            pbiWorking = pdsurf->pbiBankInfo2RW;

            do {

                lScan += lScansBetweenBanks;
                pbiWorking->rclBankBounds.left = 0;
                pbiWorking->rclBankBounds.right =  pdsurf->sizlSurf.cx;
                pbiWorking->rclBankBounds.top = lScan;
                pbiWorking->rclBankBounds.bottom = lScan + lScansPerBank;
                pbiWorking->ulBankOffset = ulOffset;
                ulOffset += BankInfo->Granularity;
                i++;
                pbiWorking++;

            } while ((lScan + lScansPerBank) < lTotalScans);

            pdsurf->ulBankInfo2RWLength = i;

        } else {

            // Not a 2RW bank adapter

            pdsurf->pbiBankInfo2RW = NULL;
            pdsurf->ulBankInfo2RWLength = 0;

        }

        // Map in scan line 0 for read & write, to put things in a known state

        pdsurf->pfnBankControl(pdsurf, 0, JustifyTop);

        // Scan line to be used with JustifyBottom to map in the bank
        // containing the pointer work and save areas, which are guaranteed not
        // to span banks
        pdsurf->ulPtrBankScan = (pdsurf->ulBitmapSize/pdsurf->lNextScan) - 1;

    }


    return TRUE;
}

/******************************Private*Routine******************************\
* BankErrorTrap
*
* Traps calls to bank control functions in non-banked modes
*
\**************************************************************************/

void BankErrorTrap(PDEVSURF pdsurf, LONG lScan,
    BANK_JUST ulJustification)
{
    DISPDBG((0, "Call to bank manager in unbanked mode\n"));
}


/******************************Private*Routine******************************\
* Bank1Window
*
* Maps in a single R/W window that allows access to lScan. Applies to both
* 1 RW window and 1R1W window banking schemes.
*
* Note: in the 1 R/W adapter case, this may be called with a fourth parameter
* (the source/dest selector), which is ignored. This is so that we can use the
* same routine as the destination for 1 R/W 2-window calls; those calls don't
* map in separate banks, of course, but they let us get away with common code
* for 1 R/W and 1R/1W in some cases (such as aligned blits).
*
\**************************************************************************/

void Bank1Window(PDEVSURF pdsurf, LONG lScan,
    BANK_JUST ulJustification)
{
    ULONG ulBank;
    PBANK_INFO pbiWorking;
    volatile ULONG ulBank0;
    volatile PFN pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification
    if (ulJustification == JustifyTop) {

        // Map scan line in as near as possible to the top of the window
        ulBank = pdsurf->ulBankInfoLength-1;
        pbiWorking = pdsurf->pbiBankInfo + ulBank;
        while (pbiWorking->rclBankBounds.top > lScan) {
            ulBank--;
            pbiWorking--;
        }

    } else {

        // Map scan line in as near as possible to the bottom of the window
        ulBank = 0;
        pbiWorking = pdsurf->pbiBankInfo;
        while (pbiWorking->rclBankBounds.bottom <= lScan) {
            ulBank++;
            pbiWorking++;
        }

    }

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a double-window set-up is currently active, so invalidate double-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (pdsurf->rcl1WindowClip.top == -1) {

        pdsurf->rcl2WindowClip[0].top =
        pdsurf->rcl2WindowClip[0].bottom =
        pdsurf->rcl2WindowClip[0].right =
        pdsurf->rcl2WindowClip[0].left =
        pdsurf->rcl2WindowClip[1].top =
        pdsurf->rcl2WindowClip[1].bottom =
        pdsurf->rcl2WindowClip[1].right =
        pdsurf->rcl2WindowClip[1].left = -1;
        pdsurf->pvBitmapStart2Window[0] = (PDEVSURF) 0;
        pdsurf->pvBitmapStart2Window[1] = (PDEVSURF) 0;

    } else {
//        ASSERT(pdsurf->rcl2WindowClip[0].top == -1,
//                "BANK.C: 2 bank src not mapped out");
//        ASSERT(pdsurf->rcl2WindowClip[1].top == -1,
//                "BANK.C: 2 bank src not mapped out");
    }


    pdsurf->rcl1WindowClip = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with
    // the banking window. The source and destination are set only so 1 R/W
    // aligned blits will work without having to be specifically aware of
    // the adapter type (some of the same code works with 1R/1W adapters too).

    pdsurf->pvBitmapStart =
    pdsurf->pvBitmapStart2Window[0] =
    pdsurf->pvBitmapStart2Window[1] =
            (PVOID) ((UCHAR *)pdsurf->pvStart - pbiWorking->ulBankOffset);

    // Map in the desired bank for both read and write
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = ulBank;
    pBankFn = pdsurf->pfnBankSwitchCode;
    _asm mov eax,ulBank0;
    _asm mov edx,eax;
    _asm call pBankFn;    // actually switch the banks

    _asm    popfd
}


/******************************Private*Routine******************************\
* Bank1Window2RW
*
* Maps in two 32K RW windows so that they form a single 64K R/W window that
* allows access to lScan. Applies only to 2 RW window schemes.
*
\**************************************************************************/

void Bank1Window2RW(PDEVSURF pdsurf, LONG lScan,
    BANK_JUST ulJustification)
{
    ULONG ulBank;
    PBANK_INFO pbiWorking;
    volatile ULONG ulBank0;
    volatile ULONG ulBank1;
    volatile PFN pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification
    if (ulJustification == JustifyTop) {

        // Map scan line in as near as possible to the top of the window
        ulBank = pdsurf->ulBankInfoLength-1;
        pbiWorking = pdsurf->pbiBankInfo + ulBank;
        while (pbiWorking->rclBankBounds.top > lScan) {
            ulBank--;
            pbiWorking--;
        }

    } else {

        // Map scan line in as near as possible to the bottom of the window
        ulBank = 0;
        pbiWorking = pdsurf->pbiBankInfo;
        while (pbiWorking->rclBankBounds.bottom <= lScan) {
            ulBank++;
            pbiWorking++;
        }

    }

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a double-window set-up is currently active, so invalidate double-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (pdsurf->rcl1WindowClip.top == -1) {

        pdsurf->rcl2WindowClip[0].top =
        pdsurf->rcl2WindowClip[0].bottom =
        pdsurf->rcl2WindowClip[0].right =
        pdsurf->rcl2WindowClip[0].left =
        pdsurf->rcl2WindowClip[1].top =
        pdsurf->rcl2WindowClip[1].bottom =
        pdsurf->rcl2WindowClip[1].right =
        pdsurf->rcl2WindowClip[1].left = -1;
        pdsurf->pvBitmapStart2Window[0] = (PDEVSURF) 0;
        pdsurf->pvBitmapStart2Window[1] = (PDEVSURF) 0;

    } else {
//        ASSERT(pdsurf->rcl2WindowClip[0].top == -1,
//                "BANK.C: 2 bank src not mapped out");
//        ASSERT(pdsurf->rcl2WindowClip[1].top == -1,
//                "BANK.C: 2 bank src not mapped out");
    }


    pdsurf->rcl1WindowClip = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with
    // the banking window. The source and destination are set only so 1 R/W
    // aligned blits will work without having to be specifically aware of
    // the adapter type (some of the same code works with 1R/1W adapters too).

    pdsurf->pvBitmapStart =
    pdsurf->pvBitmapStart2Window[0] =
    pdsurf->pvBitmapStart2Window[1] =
            (PVOID) ((UCHAR *)pdsurf->pvStart - pbiWorking->ulBankOffset);

    // Map in the desired bank for both read and write; this is accomplished
    // by mapping in the desired 32K bank, followed by the next 32K bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = ulBank;
    ulBank1 = ulBank0 + pdsurf->ulBank2RWSkip;
    pBankFn = pdsurf->pfnBankSwitchCode;
    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm    popfd
}


/******************************Private*Routine******************************\
* Bank2Window
*
* Maps in one of two windows, either the source window (window 0) or the dest
* window (window 1), to allows access to lScan. Applies to 1R1W window
* banking scheme; should never be called for 1 RW window schemes, because
* there's only one window in that case.
*
\**************************************************************************/

void Bank2Window(PDEVSURF pdsurf, LONG lScan,
    BANK_JUST ulJustification, ULONG ulWindowToMap)
{
    ULONG ulBank;
    PBANK_INFO pbiWorking;
    volatile ULONG ulBank0, ulBank1;
    volatile PFN pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification
    if (ulJustification == JustifyTop) {

        // Map scan line in as near as possible to the top of the window
        ulBank = pdsurf->ulBankInfoLength-1;
        pbiWorking = pdsurf->pbiBankInfo + ulBank;
        while (pbiWorking->rclBankBounds.top > lScan) {
            ulBank--;
            pbiWorking--;
        }

    } else {

        // Map scan line in as near as possible to the bottom of the window
        ulBank = 0;
        pbiWorking = pdsurf->pbiBankInfo;
        while (pbiWorking->rclBankBounds.bottom <= lScan) {
            ulBank++;
            pbiWorking++;
        }

    }

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (pdsurf->rcl2WindowClip[ulWindowToMap].top == -1) {

        pdsurf->rcl1WindowClip.top =
        pdsurf->rcl1WindowClip.bottom =
        pdsurf->rcl1WindowClip.right =
        pdsurf->rcl1WindowClip.left = -1;
        pdsurf->pvBitmapStart = (PDEVSURF) 0;

        // Neither of the 2 window windows was active, so we have to set up the
        // variables for the other bank (the one other than the one we were
        // called to set) as well, to make it valid. The other bank is set to
        // the same state as the bank we were called to set
        pdsurf->rcl2WindowClip[ulWindowToMap^1] = pbiWorking->rclBankBounds;
        pdsurf->pvBitmapStart2Window[ulWindowToMap^1] =
                (PVOID) ((UCHAR *)pdsurf->pvStart - pbiWorking->ulBankOffset);
        pdsurf->ulWindowBank[ulWindowToMap^1] = ulBank;
    } else {
//        ASSERT(pdsurf->rcl1WindowClip.top == -1,
//                "BANK.C: 1 bank not mapped out");
    }

    pdsurf->rcl2WindowClip[ulWindowToMap] = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    pdsurf->pvBitmapStart2Window[ulWindowToMap] =
            (PVOID) ((UCHAR *)pdsurf->pvStart - pbiWorking->ulBankOffset);

    // Map in the desired bank; also map in the other bank to whatever its
    // current state is

    pdsurf->ulWindowBank[ulWindowToMap] = ulBank;

    // Set both banks at once, because we may have just initialized the other
    // bank, and because this way the bank switch code doesn't have to do a
    // read before write to obtain the state of the other bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = pdsurf->ulWindowBank[0];
    ulBank1 = pdsurf->ulWindowBank[1];
    pBankFn = pdsurf->pfnBankSwitchCode;
    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm    popfd
}


/******************************Private*Routine******************************\
* Bank2Window1RW
*
* Maps in the one window in 1R/W case.  Does exactly the same thing as the
* one window case, because there's only one window, but has to be a separate
* entry point because of the extra parameter (because we're using STDCALL).
\**************************************************************************/

void Bank2Window1RW(PDEVSURF pdsurf, LONG lScan,
    BANK_JUST ulJustification, ULONG ulWindowToMap)
{
    Bank1Window(pdsurf, lScan, ulJustification);
}


/******************************Private*Routine******************************\
* Bank2Window2RW
*
* Maps in one of two windows, either the source window (window 0) or the dest
* window (window 1), to allows access to lScan. Applies to 2RW window
* banking scheme; should never be called for 1 RW window schemes, because
* there's only one window in that case.
\**************************************************************************/

void Bank2Window2RW(PDEVSURF pdsurf, LONG lScan,
    BANK_JUST ulJustification, ULONG ulWindowToMap)
{
    ULONG ulBank;
    PBANK_INFO pbiWorking;
    volatile ULONG ulBank0, ulBank1;
    volatile PFN pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification
    if (ulJustification == JustifyTop) {

        // Map scan line in as near as possible to the top of the window
        ulBank = pdsurf->ulBankInfo2RWLength-1;
        pbiWorking = pdsurf->pbiBankInfo2RW + ulBank;
        while (pbiWorking->rclBankBounds.top > lScan) {
            ulBank--;
            pbiWorking--;
        }

    } else {

        // Map scan line in as near as possible to the bottom of the window
        ulBank = 0;
        pbiWorking = pdsurf->pbiBankInfo2RW;
        while (pbiWorking->rclBankBounds.bottom <= lScan) {
            ulBank++;
            pbiWorking++;
        }

    }

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (pdsurf->rcl2WindowClip[ulWindowToMap].top == -1) {

        pdsurf->rcl1WindowClip.top =
        pdsurf->rcl1WindowClip.bottom =
        pdsurf->rcl1WindowClip.right =
        pdsurf->rcl1WindowClip.left = -1;
        pdsurf->pvBitmapStart = (PDEVSURF) 0;

        // Neither of the 2 window windows was active, so we have to set up the
        // variables for the other bank (the one other than the one we were
        // called to set) as well, to make it valid. The other bank is set to
        // the same state as the bank we were called to set
        pdsurf->rcl2WindowClip[ulWindowToMap^1] = pbiWorking->rclBankBounds;
        if (ulWindowToMap == 1) {
            pdsurf->pvBitmapStart2Window[0] =
                (PVOID) ((UCHAR *)pdsurf->pvStart - pbiWorking->ulBankOffset);
        } else {
            pdsurf->pvBitmapStart2Window[1] =
                (PVOID) ((UCHAR *)pdsurf->pvStart - pbiWorking->ulBankOffset +
                BANK_SIZE_2RW_WINDOW);
        }
        pdsurf->ulWindowBank[ulWindowToMap^1] = ulBank;
    } else {
//        ASSERT(pdsurf->rcl1WindowClip.top == -1,
//                "BANK.C: 1 bank not mapped out");
    }

    pdsurf->rcl2WindowClip[ulWindowToMap] = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    if (ulWindowToMap == 0) {
        pdsurf->pvBitmapStart2Window[0] =
            (PVOID) ((UCHAR *)pdsurf->pvStart - pbiWorking->ulBankOffset);
    } else {
        pdsurf->pvBitmapStart2Window[1] =
            (PVOID) ((UCHAR *)pdsurf->pvStart - pbiWorking->ulBankOffset +
            BANK_SIZE_2RW_WINDOW);
    }

    // Map in the desired bank; also map in the other bank to whatever its
    // current state is

    pdsurf->ulWindowBank[ulWindowToMap] = ulBank;

    // Set both banks at once, because we may have just initialized the other
    // bank, and because this way the bank switch code doesn't have to do a
    // read before write to obtain the state of the other bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = pdsurf->ulWindowBank[0];
    ulBank1 = pdsurf->ulWindowBank[1];
    pBankFn = pdsurf->pfnBankSwitchCode;
    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm    popfd
}


/************************************************************************\
* DrvIntersectRect
*
* Calculates the intersection between *prcSrc1 and *prcSrc2,
* returning the resulting rect in *prcDst.  Returns TRUE if
* *prcSrc1 intersects *prcSrc2, FALSE otherwise.  If there is no
* intersection, an empty rect is returned in *prcDst
\************************************************************************/
static const RECTL rclEmpty = { 0, 0, 0, 0 };

BOOL DrvIntersectRect(
    PRECTL prcDst,
    PRECTL prcSrc1,
    PRECTL prcSrc2)

{
    prcDst->left  = max(prcSrc1->left, prcSrc2->left);
    prcDst->right = min(prcSrc1->right, prcSrc2->right);

    /*
     * check for empty rect
     */
    if (prcDst->left < prcDst->right) {

        prcDst->top = max(prcSrc1->top, prcSrc2->top);
        prcDst->bottom = min(prcSrc1->bottom, prcSrc2->bottom);

        /*
         * check for empty rect
         */
        if (prcDst->top < prcDst->bottom) {
            return TRUE;        // not empty
        }
    }

    /*
     * empty rect
     */
    *prcDst = rclEmpty;

    return FALSE;
}

/************************************************************************\
* vForceBank0
*
* Forces the VGA to map in bank 0 if there's banking. Intended for use
* when returning from fullscreen, so a known bank is mapped.
\************************************************************************/
VOID vForceBank0(
PPDEV ppdev)
{
    PDEVSURF pdsurf = ppdev->pdsurf;

    if (pdsurf->vbtBankingType != VideoNotBanked) {

        // Set all clip rects to invalid; they'll be updated when we map in
        // bank 0
        pdsurf->rcl1WindowClip.left = pdsurf->rcl2WindowClip[0].left =
            pdsurf->rcl2WindowClip[1].left = pdsurf->rcl1WindowClip.top =
            pdsurf->rcl2WindowClip[0].top = pdsurf->rcl2WindowClip[1].top =
            pdsurf->rcl1WindowClip.right = pdsurf->rcl2WindowClip[0].right =
            pdsurf->rcl2WindowClip[1].right = pdsurf->rcl1WindowClip.bottom =
            pdsurf->rcl2WindowClip[0].bottom =
            pdsurf->rcl2WindowClip[1].bottom = -1;

        // Map in scan line 0 for read & write, to put things in a known state
        pdsurf->pfnBankControl(pdsurf, 0, JustifyTop);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\16bpp\i386\strucs.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: stucts.inc
;
; Defines common structures.
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; POINTB is used for points with a range of -128..+127.
;-----------------------------------------------------------------------;

POINTB          STRUC
ptb_x           DB      0
ptb_y           DB      0
POINTB          ENDS

;-----------------------------------------------------------------------;
; POINTL is used for points with a range of +/- 2G.
;-----------------------------------------------------------------------;

POINTL          STRUC
ptl_x           DD      0
ptl_y           DD      0
POINTL          ENDS


;-----------------------------------------------------------------------;
; SIZEB is used for extents with a range of -128..+127.
;-----------------------------------------------------------------------;

SIZEB           STRUC
sizb_cx         DB      0
sizb_cy         DB      0
SIZEB           ENDS


;-----------------------------------------------------------------------;
; SIZEL is used for extents with a range of +/- 2G
;-----------------------------------------------------------------------;

SIZEL           STRUC
sizl_cx         DD      0
sizl_cy         DD      0
SIZEL           ENDS

;-----------------------------------------------------------------------;
; Definition of a rectangle
;-----------------------------------------------------------------------;


RECTL               struc           ; /* rcl */
xLeft               dd      ?
yTop                dd      ?
xRight              dd      ?
yBottom             dd      ?
RECTL               ends


;-----------------------------------------------------------------------;
; Definitions for dsurf_iFormat
;-----------------------------------------------------------------------;

BMF_DEVICE          equ     0
BMF_1BPP            equ     1
BMF_4BPP            equ     2
BMF_8BPP            equ     3
BMF_16BPP           equ     4
BMF_24BPP           equ     5
BMF_32BPP           equ     6
BMF_4RLE            equ     8
BMF_8RLE            equ     9
BMF_PHYSDEVICE      equ     0FFh


;-----------------------------------------------------------------------;
; Definitions for text output
;-----------------------------------------------------------------------;


GLYPHPOS    struc           ; /* gp */
gp_hg       dd      ?       ; hglyph (unused by vga)
gp_pgdf     dd      ?       ; glyphdef
gp_x        dd      ?       ; glyph x position
gp_y        dd      ?       ; glyph y position
GLYPHPOS    ends


GLYPHDEF struc              ; /* gdf */
gdf_pgb     dd      ?       ; points to GLYPHBITS
GLYPHDEF ends


GLYPHBITS struc             ; /* gb */
gb_x        dd      ?       ; glyph x offset
gb_y        dd      ?       ; glyph y offset
gb_cx       dd      ?       ; glyph width in pels
gb_cy       dd      ?       ; glyph height in pels
gb_aj       db      ?       ; glyph bit mask
GLYPHBITS ends

;-----------------------------------------------------------------------;
; Information block for RLE blts
;-----------------------------------------------------------------------;

RLEINFO struc
RLE_pjTrg        dd  ?
RLE_pjSrcBits    dd  ?
RLE_pjSrcBitsMax dd  ?
RLE_prctlClip    dd  ?
RLE_pulTranslate dd  ?
RLE_xBegin       dd  ?
RLE_lNextScan    dd  ?
RLE_lNextPlane   dd  ?
RLE_prctlTrg     dd  ?
RLE_dwFormat     dd  ?
Rle_pdsurfTrg    dd  ?
RLEINFO ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\16bpp\i386\vgaregs.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: vgaregs.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; VOID vInitRegs(void)
;
; Sets the VGA's data control registers to their default states.
;
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc
        include i386\egavga.inc

        .list

        .code

cProc vInitRegs,4,<             \
        uses esi edi ebx,       \
        ppdev: ptr PDEV         >

        mov     esi,ppdev

;       Initialize sequencer to its defaults (all planes enabled, index
;       pointing to Map Mask).

        mov     dx,VGA_BASE + SEQ_ADDR
        mov     ax,(MM_ALL shl 8) + SEQ_MAP_MASK
        out     dx,ax

;       Initialize graphics controller to its defaults (set/reset disabled for
;       all planes, no rotation & ALU function == replace, write mode 0 & read
;       mode 0, color compare ignoring all planes (read mode 1 reads always
;       return 0ffh, handy for ANDing), and the bit mask == 0ffh, gating all
;       bytes from the CPU.

        mov     dl,GRAF_ADDR
        mov     ax,(0 shl 8) + GRAF_ENAB_SR
        out     dx,ax

        mov     ax,(DR_SET shl 8) + GRAF_DATA_ROT
        out     dx,ax

;       Default to read mode 0, write mode 0:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     ah,byte ptr [esi].pdev_ulrm0_wmX[0]
        mov     al,GRAF_MODE
        out     dx,ax                   ;write mode 0, read mode 0

        mov     ax,(0 shl 8) + GRAF_CDC
        out     dx,ax

        mov     ax,(0FFh shl 8) + GRAF_BIT_MASK
        out     dx,ax

        cRet    vInitRegs


endProc vInitRegs

;-----------------------------------------------------------------------;
; VOID vSetWriteModes(ULONG * pulWriteModes);
;
; Sets the four bytes at *pulWriteModes to the values to be written to
; the Graphics Mode register to select read mode 0 and:
;  write mode 0, write mode 1, write mode 2, and write mode 3,
; respectively.
;
; Must already be in graphics mode when this is called.
;-----------------------------------------------------------------------;

cProc vSetWriteModes,4,<   \
        pulWriteModes:ptr  >

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_MODE
        out     dx,al           ;point the GC Index to the Graphics Mode reg
        inc     edx             ;point to the GC Data reg
        in      al,dx           ;get the current setting of the Graphics Mode
        and     eax,0fch        ;mask off the write mode fields
        mov     ah,al
        mov     edx,eax
        shl     edx,16
        or      eax,edx         ;put the Graphics Mode setting in all 4 bytes
        mov     edx,pulWriteModes ;the mode values go here
        or      eax,03020100h   ;insert the write mode fields
        mov     [edx],eax       ;store the Graphics Mode settings

        cRet    vSetWriteModes

endProc vSetWriteModes

        end


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\bitblt.c ===
/******************************Module*Header*******************************\
* Module Name: bitblt.c
*
* BitBlt
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/
#include "driver.h"
#include "bitblt.h"


BOOL bConvertBrush(BRUSHINST *pbri);
VOID vCompiledBlt(PDEVSURF,LONG,LONG,PDEVSURF,LONG,LONG,
                  LONG,LONG,ULONG,BRUSHINST *,ULONG,ULONG,ULONG *,POINTL *);

/******************************Public*Data*********************************\
* ROP translation table
*
* Translates the usual ternary rop into A-vector notation.  Each bit in
* this new notation corresponds to a term in a polynomial translation of
* the rop.
*
* Rop(D,S,P) = a + a D + a S + a P + a  DS + a  DP + a  SP + a   DSP
*               0   d     s     p     ds      dp      sp      dsp
*
* History:
*  24-Aug-1990 -by- Donald Sidoroff [donalds]
* Added it as a global table for the VGA driver.
\**************************************************************************/

BYTE gajRop[] =
{
    0x00, 0xff, 0xb2, 0x4d, 0xd4, 0x2b, 0x66, 0x99,
    0x90, 0x6f, 0x22, 0xdd, 0x44, 0xbb, 0xf6, 0x09,
    0xe8, 0x17, 0x5a, 0xa5, 0x3c, 0xc3, 0x8e, 0x71,
    0x78, 0x87, 0xca, 0x35, 0xac, 0x53, 0x1e, 0xe1,
    0xa0, 0x5f, 0x12, 0xed, 0x74, 0x8b, 0xc6, 0x39,
    0x30, 0xcf, 0x82, 0x7d, 0xe4, 0x1b, 0x56, 0xa9,
    0x48, 0xb7, 0xfa, 0x05, 0x9c, 0x63, 0x2e, 0xd1,
    0xd8, 0x27, 0x6a, 0x95, 0x0c, 0xf3, 0xbe, 0x41,
    0xc0, 0x3f, 0x72, 0x8d, 0x14, 0xeb, 0xa6, 0x59,
    0x50, 0xaf, 0xe2, 0x1d, 0x84, 0x7b, 0x36, 0xc9,
    0x28, 0xd7, 0x9a, 0x65, 0xfc, 0x03, 0x4e, 0xb1,
    0xb8, 0x47, 0x0a, 0xf5, 0x6c, 0x93, 0xde, 0x21,
    0x60, 0x9f, 0xd2, 0x2d, 0xb4, 0x4b, 0x06, 0xf9,
    0xf0, 0x0f, 0x42, 0xbd, 0x24, 0xdb, 0x96, 0x69,
    0x88, 0x77, 0x3a, 0xc5, 0x5c, 0xa3, 0xee, 0x11,
    0x18, 0xe7, 0xaa, 0x55, 0xcc, 0x33, 0x7e, 0x81,
    0x80, 0x7f, 0x32, 0xcd, 0x54, 0xab, 0xe6, 0x19,
    0x10, 0xef, 0xa2, 0x5d, 0xc4, 0x3b, 0x76, 0x89,
    0x68, 0x97, 0xda, 0x25, 0xbc, 0x43, 0x0e, 0xf1,
    0xf8, 0x07, 0x4a, 0xb5, 0x2c, 0xd3, 0x9e, 0x61,
    0x20, 0xdf, 0x92, 0x6d, 0xf4, 0x0b, 0x46, 0xb9,
    0xb0, 0x4f, 0x02, 0xfd, 0x64, 0x9b, 0xd6, 0x29,
    0xc8, 0x37, 0x7a, 0x85, 0x1c, 0xe3, 0xae, 0x51,
    0x58, 0xa7, 0xea, 0x15, 0x8c, 0x73, 0x3e, 0xc1,
    0x40, 0xbf, 0xf2, 0x0d, 0x94, 0x6b, 0x26, 0xd9,
    0xd0, 0x2f, 0x62, 0x9d, 0x04, 0xfb, 0xb6, 0x49,
    0xa8, 0x57, 0x1a, 0xe5, 0x7c, 0x83, 0xce, 0x31,
    0x38, 0xc7, 0x8a, 0x75, 0xec, 0x13, 0x5e, 0xa1,
    0xe0, 0x1f, 0x52, 0xad, 0x34, 0xcb, 0x86, 0x79,
    0x70, 0x8f, 0xc2, 0x3d, 0xa4, 0x5b, 0x16, 0xe9,
    0x08, 0xf7, 0xba, 0x45, 0xdc, 0x23, 0x6e, 0x91,
    0x98, 0x67, 0x2a, 0xd5, 0x4c, 0xb3, 0xfe, 0x01
};


/******************************Public*Data*********************************\
* ROP to mix translation table
*
* Table to translate ternary raster ops to mixes (binary raster ops). Ternary
* raster ops that can't be translated to mixes are translated to 0 (0 is not
* a valid mix).
*
\**************************************************************************/

UCHAR jRop3ToMix[256] = {
    R2_BLACK, 0, 0, 0, 0, R2_NOTMERGEPEN, 0, 0,
    0, 0, R2_MASKNOTPEN, 0, 0, 0, 0, R2_NOTCOPYPEN,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    R2_MASKPENNOT, 0, 0, 0, 0, R2_NOT, 0, 0,
    0, 0, R2_XORPEN, 0, 0, 0, 0, R2_NOTMASKPEN,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    R2_MASKPEN, 0, 0, 0, 0, R2_NOTXORPEN, 0, 0,
    0, 0, R2_NOP, 0, 0, 0, 0, R2_MERGENOTPEN,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    R2_COPYPEN, 0, 0, 0, 0, R2_MERGEPENNOT, 0, 0,
    0, 0, R2_MERGEPEN, 0, 0, 0, 0, R2_WHITE
};


/******************************Public*Routine******************************\
* VOID DrvBitBlt(pso,pso,pso,pco,pxlo,prcl,pptl,pptl,pdbrush,pptl,rop4)
*
* Bitblt.
*
\**************************************************************************/

BOOL DrvBitBlt
(
    SURFOBJ    *psoTrg,             // Target surface
    SURFOBJ    *psoSrc,             // Source surface
    SURFOBJ    *psoMask,            // Mask
    CLIPOBJ    *pco,                // Clip through this
    XLATEOBJ   *pxlo,               // Color translation
    RECTL      *prclTrg,            // Target offset and extent
    POINTL     *pptlSrc,            // Source offset
    POINTL     *pptlMask,           // Mask offset
    BRUSHOBJ   *pbo,                // Pointer to brush object
    POINTL     *pptlBrush,          // Brush offset
    ROP4        rop4                // Raster operation
)
{
    BYTE        jForeRop;           // Foreground rop in A-vector notation
    BYTE        jBackRop;           // Background rop in A-vector notation
    BYTE        jORedRops;          // jForeRop | jBackRop
    BRUSHINST   bri;                // Instance of a brush
    BRUSHINST  *pbri;               // Pointer to a brush instance

    DEVSURF     dsurfSrc;           // For source if a DIB
    PDEVSURF    pdsurfTrg;          // Pointer for target
    PDEVSURF    pdsurfSrc;          // Pointer for source if present

    ULONG       iSolidColor;        // Solid color for solid brushes
    BOOL        bMore;              // Clip continuation flag
    ULONG       ircl;               // Clip enumeration rectangle index
    RECT_ENUM   bben;               // Clip enumerator
    ULONG      *pulXlate;           // Pointer to color xlate vector
    BYTE        jClipping;
    MIX         mix;                // Mix, when solid fill performed
    RECTL       rclTemp;
    ULONG       ulBkColor;
    ULONG       ulFgColor;
    PRECTL      prcl;
    POINTL      ptlTemp;
    VOID        (*pfnPatBlt)(PDEVSURF,ULONG,PRECTL,MIX, BRUSHINST *,PPOINTL);
    VOID        (*pfnFillSolid)(PDEVSURF,ULONG,PRECTL,MIX,ULONG);
    ULONG       x;
    BOOL        bFillTooComplex = FALSE;
    LONG        xSrc;
    LONG        ySrc;


    //
    // Note: if no source is involved, then no xlateobj will have been passed.
    //

    //
    // We can't handle actual rop4s
    //

    if ((rop4 & 0x000000FF) != ((rop4 >> 8) & 0x000000FF))
    {
        return(EngBitBlt(psoTrg,psoSrc,psoMask,
                          pco,pxlo,prclTrg,pptlSrc,pptlMask,
                          pbo,pptlBrush,rop4));
    }

    //
    // if you remove the following code that sets pxlo to NULL for trivial
    // XLATEOBJs then you must go find all checks the text pxlo, and add
    // a check for (pxlo->flXlate & XO_TRIVIAL)
    //
    // ie. change all pxlo => (pxlo && !(pxlo->flXlate & XO_TRIVIAL))
    //

    if (pxlo && (pxlo->flXlate & XO_TRIVIAL))
    {
        pxlo = NULL;
    }

    //
    // until we find out otherwise, assume solid fills are to the screen
    //

    pfnFillSolid = vTrgBlt;

    if (psoTrg->iType == STYPE_DEVBITMAP)
    {
        //
        // if there is a psoSrc then this stuff won't get used, so check for it
        //

        if (!psoSrc)
        {

            //
            // we can do the following, because only mixes (rop2s) have no SRC
            //

            mix = jRop3ToMix[rop4 & 0xFF];

            //
            // we found out otherwise, solid fills are to a DFB
            //

            pfnFillSolid = vDFBFILL;

            switch (mix & 0xff) {
                case R2_NOP:
                    return(TRUE);       // make sure this doesn't cause a blt compile!
                case R2_WHITE:
                case R2_BLACK:
                case R2_COPYPEN:
                    break;
                case R2_NOTCOPYPEN:
                    if (pbo->iSolidColor != -1) {
                        break;          // solid color
                    }
                    //
                    // WE ARE FALLING THROUGH BECAUSE WE ONLY SUPPORT
                    // PATTERNS FOR COPYPEN!
                    //
                default:
                    bFillTooComplex = TRUE;
            }
        }
    }

    if (psoSrc)
    {
        //
        // For now, if it's VGA=>DFB, punt to engine.  The code to bank
        // would be considerable, and it is a VERY rare case.
        //

        if ((psoSrc->iType == STYPE_DEVICE) &&
            (psoTrg->iType == STYPE_DEVBITMAP))
        {
            return EngBitBlt (psoTrg, psoSrc, psoMask, pco, pxlo, prclTrg,
                              pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }

        if ((psoSrc->iBitmapFormat != BMF_1BPP) &&
            (psoSrc->iBitmapFormat != BMF_4BPP) &&
            (psoSrc->iBitmapFormat != BMF_8BPP) &&
            (psoSrc->iType != STYPE_DEVICE) &&
            (psoSrc->iType != STYPE_DEVBITMAP))
        {
            return(EngBitBlt(psoTrg,psoSrc,psoMask,
                             pco,pxlo,prclTrg,pptlSrc,pptlMask,
                             pbo,pptlBrush,rop4));
        }
        else
        {
            // We only handle SRCCOPY screen-to-screen blts right now
            if ((psoSrc->iType == STYPE_DEVICE) &&
                (psoTrg->iType == STYPE_DEVICE) &&
                (rop4 != 0x0000CCCC))
            {
                return(EngBitBlt(psoTrg,psoSrc,psoMask,
                                  pco,pxlo,prclTrg,pptlSrc,pptlMask,
                                  pbo,pptlBrush,rop4));
            }
        }
    }

    // Get the target surface's pointer. The target must always be a device
    // surface

    pdsurfTrg = (PDEVSURF) psoTrg->dhsurf;

    // Set up the clipping type
    if (pco == (CLIPOBJ *) NULL)
    {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    }
    else
    {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    // Break the rops with the VGA as the destination surface into two classes,
    // those that can call special case static code (currently: (*pfnFillSolid)(solid
    // fills) and vAlignedSrcCopy (aligned srccopy blts)), and those that must
    // call the compiled blt code

    if ((psoTrg->iType == STYPE_DEVICE) || (psoTrg->iType == STYPE_DEVBITMAP))
    {
        // We punted earlier if a mask was present

        ASSERT (((rop4 & 0xFF) == ((rop4 >> 8) & 0xFF)), "DrvBitBlt: Rop 4 did not get properly handled");

        // Special case static code for no-mask cases

        // Calculate mix from ROP if possible (not possible if it's truly a
        // ternary rop or a real rop4, but we can treat all pure binary
        // rops as mixes rather than rop4s)
        mix = jRop3ToMix[rop4 & 0xFF];
        pbri = (BRUSHINST *)NULL;

        if (!bFillTooComplex)
        {
            switch (mix)
            {
                case R2_MASKNOTPEN:
                case R2_NOTCOPYPEN:
                case R2_XORPEN:
                case R2_MASKPEN:
                case R2_NOTXORPEN:
                case R2_MERGENOTPEN:
                case R2_COPYPEN:
                case R2_MERGEPEN:
                case R2_NOTMERGEPEN:
                case R2_MASKPENNOT:
                case R2_NOTMASKPEN:
                case R2_MERGEPENNOT:
                    if ((psoTrg->iType == STYPE_DEVBITMAP) && (mix != R2_COPYPEN))
                        break;

                    // (*pfnFillSolid) can only handle solid color fills
                    if (pbo->iSolidColor != -1)
                    {
                        iSolidColor = pbo->iSolidColor;
                    }
                    else
                    {
                        // TrgBlt can only handle solid brushes, but let's
                        // see if we can use our special case pattern code.
                        //
                        pbri = (BRUSHINST *)pbo->pvRbrush;
                        if (pbri == (BRUSHINST *)NULL)
                        {
                            pbri = (BRUSHINST *)BRUSHOBJ_pvGetRbrush(pbo);

                            if (pbri == (BRUSHINST *)NULL)
                            {
                                return(EngBitBlt(psoTrg, psoSrc, psoMask, pco,
                                        pxlo, prclTrg, pptlSrc, pptlMask, pbo,
                                        pptlBrush, rop4));
                            }
                        }

                        if (psoTrg->iType == STYPE_DEVBITMAP)
                        {
                            pfnPatBlt = vClrPatDFB;

                            if (!bConvertBrush(pbri))
                            {
                                return(EngBitBlt(psoTrg, psoSrc, psoMask, pco,
                                        pxlo, prclTrg, pptlSrc, pptlMask, pbo,
                                        pptlBrush, rop4));
                            }
                        }
                        else
                        {
                            pfnPatBlt = vMonoPatBlt;
                            if (pbri->usStyle != BRI_MONO_PATTERN)
                                   pfnPatBlt = vClrPatBlt;
                        }

                        // We only support non-8 wide brushes with R2_COPYPEN

                        if ((mix != R2_COPYPEN) && (pbri->RealWidth != 8))
                            break;
                    }
                // Rops that are implicit solid colors

                case R2_NOT:
                case R2_WHITE:
                case R2_BLACK:
                    // We can do a special-case solid fill

                    switch(jClipping)
                    {
                        case DC_TRIVIAL:

                            // Just fill the rectangle with a solid color
                            if (pbri == (BRUSHINST *)NULL)
                            {
                                (*pfnFillSolid)(pdsurfTrg, 1, prclTrg, mix,
                                        iSolidColor);
                            }
                            else
                            {
                                (*pfnPatBlt)(pdsurfTrg, 1, prclTrg, mix,
                                        pbri, pptlBrush);
                            }
                            break;

                        case DC_RECT:

                            // Clip the solid fill to the clip rectangle
                            if (!DrvIntersectRect(&rclTemp, prclTrg,
                                    &pco->rclBounds))
                            {
                                return(TRUE);
                            }

                            // Fill the clipped rectangle
                            if (pbri == (BRUSHINST *)NULL)
                            {
                                (*pfnFillSolid)(pdsurfTrg, 1, &rclTemp, mix,
                                        iSolidColor);
                            }
                            else
                            {
                                (*pfnPatBlt)(pdsurfTrg, 1, &rclTemp, mix,
                                        pbri, pptlBrush);
                            }
                            break;

                        case DC_COMPLEX:

                            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                               CD_ANY, ENUM_RECT_LIMIT);

                            do {
                                bMore = CLIPOBJ_bEnum(pco,(ULONG) sizeof(bben),
                                                      (PVOID) &bben);

                                for (ircl = 0; ircl < bben.c; ircl++)
                                {
                                    PRECTL prcl = &bben.arcl[ircl];

                                    DrvIntersectRect(prcl,prcl,prclTrg);

                                    if (pbri == (BRUSHINST *)NULL)
                                    {
                                        (*pfnFillSolid)(pdsurfTrg, 1, prcl, mix,
                                                iSolidColor);
                                    }
                                    else
                                    {
                                        (*pfnPatBlt)(pdsurfTrg, 1, prcl, mix,
                                            pbri, pptlBrush);
                                    }
                                }
                            } while(bMore);
                    }

                case R2_NOP:
                    return TRUE;

                default:
                    break;
            }
        }

        // Not a special-case solid fill; see if it's a
        // screen to screen or DIB4 to (dfb or screen)
        // SRCCOPY blt, another of our special cases

        if (rop4 == 0x0000CCCC)
        {
            // SRCCOPY blt

            if (psoSrc->iType == STYPE_DEVICE && psoTrg->iType == STYPE_DEVICE)
            {

                INT iCopyDir;
                PFN_ScreenToScreenBlt pfn_Blt;

                // It's a screen-to-screen SRCCOPY; special-case it

                // Determine the direction in which the copy must proceed
                // Note that although we could detect cases where the source
                // and dest don't overlap and handle them top to bottom, all
                // copy directions are equally fast, so there's no reason to go
                // top to bottom except possibly that it looks better. But it
                // also takes time to detect non-overlap, so I'm not doing it

                if (pptlSrc->y >= prclTrg->top)
                {
                    if (pptlSrc->x >= prclTrg->left)
                    {
                        iCopyDir = CD_RIGHTDOWN;
                    }
                    else
                    {
                        iCopyDir = CD_LEFTDOWN;
                    }
                }
                else
                {
                    if (pptlSrc->x >= prclTrg->left)
                    {
                        iCopyDir = CD_RIGHTUP;
                    }
                    else
                    {
                        iCopyDir = CD_LEFTUP;
                    }
                }

                // These values are expected by vAlignedSrcCopy

                switch(jClipping)
                {

                case DC_TRIVIAL:
                    // Just copy the rectangle
                    if ((((prclTrg->left ^ pptlSrc->x) & 0x07) == 0))
                    {
                        vAlignedSrcCopy(pdsurfTrg, prclTrg,
                                        pptlSrc, iCopyDir);
                    }
                    else
                    {
                        vNonAlignedSrcCopy(pdsurfTrg, prclTrg,
                                           pptlSrc, iCopyDir);
                    }
                    break;

                case DC_RECT:
                    // Clip the solid fill to the clip rectangle
                    if (!DrvIntersectRect(&rclTemp, prclTrg, &pco->rclBounds))
                    {
                        return(TRUE);
                    }

                    // Adjust the source point for clipping too
                    ptlTemp.x = pptlSrc->x + rclTemp.left - prclTrg->left;
                    ptlTemp.y = pptlSrc->y + rclTemp.top - prclTrg->top;

                    // Copy the clipped rectangle
                    if ((((prclTrg->left ^ pptlSrc->x) & 0x07) == 0)) {
                        vAlignedSrcCopy(pdsurfTrg, &rclTemp, &ptlTemp,
                                        iCopyDir);
                    }
                    else
                    {
                        vNonAlignedSrcCopy(pdsurfTrg, &rclTemp, &ptlTemp,
                                           iCopyDir);
                    }
                    break;

                case DC_COMPLEX:

                    if ((((prclTrg->left ^ pptlSrc->x) & 0x07) == 0))
                    {
                        pfn_Blt = vAlignedSrcCopy;
                    }
                    else
                    {
                        pfn_Blt = vNonAlignedSrcCopy;
                    }

                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                       iCopyDir, ENUM_RECT_LIMIT);

                    do {
                        bMore = CLIPOBJ_bEnum(pco,(ULONG) sizeof(bben),
                                              (PVOID) &bben);

                        for (ircl = 0; ircl < bben.c; ircl++)
                        {
                            PRECTL prcl = &bben.arcl[ircl];

                            DrvIntersectRect(prcl,prcl,prclTrg);

                            // Adjust the source point for clipping too
                            ptlTemp.x = pptlSrc->x + prcl->left -
                                    prclTrg->left;
                            ptlTemp.y = pptlSrc->y + prcl->top -
                                    prclTrg->top;
                            pfn_Blt(pdsurfTrg, prcl,
                                    &ptlTemp, iCopyDir);
                        }
                    } while(bMore);
                    break;
                }

                return TRUE;

            }
            else if ((psoSrc->iType == STYPE_BITMAP) &&
                     (psoSrc->iBitmapFormat == BMF_4BPP) &&
                     (pxlo == NULL))
            {
                //
                // DIB4 -> VGA or
                // DIB4 -> DFB
                // SRCCOPY with no XLATE
                //
                return(DrvCopyBits(psoTrg, psoSrc, pco, NULL, prclTrg, pptlSrc));
            }
        }
    }

// Couldn't be special cased.  Set up to call the blt compiler

    // Translate the rop from old notation into two A-vector rops

    jForeRop = gajRop[rop4 & 0xff];
    jBackRop = gajRop[(rop4 >> 8) & 0xff];
    jORedRops = jForeRop | jBackRop;


    // Get the source surface if a source is needed.  The source may be any of
    // 1) the screen, 2) a device managed bitmap, 3) an engine bitmap

    if (jORedRops & AVEC_NEED_SOURCE)
    {

        if (psoSrc->dhsurf == (DHSURF) 0)
        {
            // Source is an engine bitmap
#if DBG
            dsurfSrc.ident = 0x46525354;         // "TSRF"
#endif
            dsurfSrc.flSurf   = DS_DIB;          // Supporting a DIB
            dsurfSrc.iFormat  = (BYTE)psoSrc->iBitmapFormat;
            dsurfSrc.sizlSurf = psoSrc->sizlBitmap;
            dsurfSrc.lNextScan = psoSrc->lDelta;
            dsurfSrc.pvScan0   = psoSrc->pvScan0;
            dsurfSrc.pvBitmapStart = psoSrc->pvScan0;
            dsurfSrc.pvConv    = pdsurfTrg->pvConv;

            pdsurfSrc = &dsurfSrc;      // Construct source into here

        }
        else
        {
            // Source is a device format bitmap or the device itself
            pdsurfSrc = (PDEVSURF) psoSrc->dhsurf;
        }
    }
    else
    {
        pdsurfSrc  = (PDEVSURF) NULL;       // Assume no source
    }


    // If a brush is required, do what is necessary to get it.  We might be
    // able to just use the solid color accelerator, we might have to force it
    // to be realized (which could fail).

    if (jORedRops & AVEC_NEED_PATTERN)
    {

        // See if there is a solid color accelerator for the brush.  If so
        // we can just pick it up and use it.

        if (pbo->iSolidColor != -1)
        {
            bri.usStyle = BRI_SOLID;
            bri.fjAccel =
                    (BYTE)((pbo->iSolidColor & COLOR_BITS) | SOLID_BRUSH);
            pbri = &bri;
        }
        else
        {
        // If there is no realization of the brush, we must force it

            if (pbo->pvRbrush == (PVOID)NULL)
            {
                pbri = (BRUSHINST *)BRUSHOBJ_pvGetRbrush(pbo);

                if (pbri == (BRUSHINST *)NULL)
                {
                    return(EngBitBlt(psoTrg, psoSrc, psoMask, pco, pxlo,
                            prclTrg, pptlSrc, pptlMask, pbo, pptlBrush,
                            rop4));
                }
            }
            else
            {
                pbri = (BRUSHINST *)pbo->pvRbrush;
            }

            if (!bConvertBrush(pbri))
            {
                return(EngBitBlt(psoTrg, psoSrc, psoMask, pco, pxlo,
                        prclTrg, pptlSrc, pptlMask, pbo, pptlBrush, rop4));
            }
        }
    }


    // Determine if color translation is required.  If so, then get the
    // color translation vector.  if no source is involved, then no
    // xlateobj will have been passed.

    if ((jORedRops & AVEC_NEED_SOURCE) &&
        (pxlo != NULL) &&
        (pxlo->flXlate & XO_TABLE))
    {
        pulXlate = pxlo->pulXlate;
        ulFgColor = pulXlate[0] << 24;  // Mono --> color translation
        ulBkColor = pulXlate[1] << 24;
    }
    else
    {
        pulXlate   = (PULONG) NULL;         // No xlate vector
    }

    if (psoTrg && (psoTrg->iType == STYPE_DEVICE))
    {

        switch(jClipping)
        {

            RECTL   rclTemp;

            case DC_RECT:
                if (!DrvIntersectRect(&rclTemp, prclTrg, &pco->rclBounds))
                {
                    break;
                }

                // Adjust the source (if any) accordingly
                if (jORedRops & AVEC_NEED_SOURCE)
                {
                    pptlSrc->x += rclTemp.left - prclTrg->left;
                    pptlSrc->y += rclTemp.top - prclTrg->top;
                }

                *prclTrg = rclTemp;

            case DC_TRIVIAL:

                // Cycle through all banks that the blt dest spans

                // If the proper bank for the top scan line of
                // the blt dest isn't mapped in, map it in
                if ((prclTrg->top < pdsurfTrg->rcl1WindowClip.top) ||
                       (prclTrg->top >= pdsurfTrg->rcl1WindowClip.bottom))
                {

                    // Map in the bank containing the top line of the blt dest
                    pdsurfTrg->pfnBankControl(pdsurfTrg,
                                           prclTrg->top,
                                           JustifyTop);
                }

                // Now draw the part of the rect that's in each bank
                for (;;)
                {

                    // Clip the blt dest to the bank
                    DrvIntersectRect(&rclTemp, prclTrg,
                            &pdsurfTrg->rcl1WindowClip);

                    // Adjust the source (if any) accordingly
                    if (jORedRops & AVEC_NEED_SOURCE)
                    {
                        xSrc = pptlSrc->x + rclTemp.left - prclTrg->left;
                        ySrc = pptlSrc->y + rclTemp.top - prclTrg->top;
                    }

                    vCompiledBlt(pdsurfTrg,
                                 rclTemp.left,
                                 rclTemp.top,
                                 pdsurfSrc,
                                 xSrc,
                                 ySrc,
                                 rclTemp.right  - rclTemp.left,
                                 rclTemp.bottom - rclTemp.top,
                                 rop4,
                                 pbri,
                                 ulBkColor,
                                 ulFgColor,
                                 pulXlate,
                                 pptlBrush);

                    // Done if this bank contains the last line of the blt
                    if (prclTrg->bottom <=
                            pdsurfTrg->rcl1WindowClip.bottom)
                    {
                        break;
                    }

                    // Map in the next bank
                    pdsurfTrg->pfnBankControl(pdsurfTrg,
                                              pdsurfTrg->rcl1WindowClip.bottom,
                                              JustifyTop);
                }

                break;


            case DC_COMPLEX:

                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, ENUM_RECT_LIMIT);
                bMore = TRUE;

                do {
                    if (bMore)
                    {
                        // Enumerate more clip rects
                        bMore = CLIPOBJ_bEnum(pco,(ULONG) sizeof(bben),
                                              (PVOID) &bben);
                    }

                    // Draw the portion of the blt dest that intersects each
                    // clip rect in turn
                    for (ircl = 0; ircl < bben.c; ircl++)
                    {

                        prcl = &bben.arcl[ircl];

                        // Find the intersection of the target rect and the
                        // current clip rect, then draw all banks of the
                        // clipped target rect, if it's not NULL
                        DrvIntersectRect(prcl, prcl, prclTrg);

                        // Cycle through all banks that the blt dest spans

                        // If the proper bank for the top scan line of
                        // the blt dest isn't mapped in, map it in
                        if ((prcl->top <
                             pdsurfTrg->rcl1WindowClip.top) ||
                            (prcl->top >=
                             pdsurfTrg->rcl1WindowClip.bottom))
                        {

                            // Map in the bank containing the top line of
                            // the blt dest
                            pdsurfTrg->pfnBankControl(pdsurfTrg,
                                                      prcl->top,
                                                      JustifyTop);
                        }

                        // Now draw the part of the clipped rect that's in
                        // each bank
                        for (;;)
                        {

                            RECTL   rclTemp;

                            // Clip the blt dest to the bank
                            DrvIntersectRect(&rclTemp, prcl,
                                             &pdsurfTrg->rcl1WindowClip);

                            // Adjust the source (if any) accordingly
                            if (jORedRops & AVEC_NEED_SOURCE)
                            {
                                xSrc = pptlSrc->x + rclTemp.left -
                                        prclTrg->left;
                                ySrc = pptlSrc->y + rclTemp.top -
                                        prclTrg->top;
                            }

                            vCompiledBlt(pdsurfTrg,
                                         rclTemp.left,
                                         rclTemp.top,
                                         pdsurfSrc,
                                         xSrc,
                                         ySrc,
                                         rclTemp.right  - rclTemp.left,
                                         rclTemp.bottom - rclTemp.top,
                                         rop4,
                                         pbri,
                                         ulBkColor,
                                         ulFgColor,
                                         pulXlate,
                                         pptlBrush);

                            // Done if this bank contains the last line of
                            // the blt
                            if (prcl->bottom <=
                                    pdsurfTrg->rcl1WindowClip.bottom)
                            {
                                break;
                            }

                            // Map in the next bank
                            pdsurfTrg->pfnBankControl(pdsurfTrg,
                                          pdsurfTrg->rcl1WindowClip.bottom,
                                          JustifyTop);
                        }
                    }
                } while(bMore);

                break;

        }   // switch(jClipping);
    }
    else
    {
        if (pdsurfTrg == NULL)
        {
            // We used to fall through to the blt compiler for
            // the case of a 0x6666 BitBlt from an STYPE_DEVBITMAP
            // to an STYPE_BITMAP, with a 'pdsurfTrg' value of NULL.
            // Unfortunately, my attempt at constructing a fake
            // 'dsurfTrg' didn't work, so I am now going to simply
            // (and slowly) punt this case...

            return(EngBitBlt(psoTrg,psoSrc,psoMask,
                             pco,pxlo,prclTrg,pptlSrc,pptlMask,
                             pbo,pptlBrush,rop4));
        }

        switch(jClipping)
        {

            RECTL   rclTemp;

            case DC_RECT:
                if (!DrvIntersectRect(&rclTemp, prclTrg, &pco->rclBounds))
                {
                    break;
                }

                // Adjust the source (if any) accordingly
                if (jORedRops & AVEC_NEED_SOURCE)
                {
                    pptlSrc->x += rclTemp.left - prclTrg->left;
                    pptlSrc->y += rclTemp.top - prclTrg->top;
                }

                *prclTrg = rclTemp;

            case DC_TRIVIAL:

                //
                // no clipping
                //

                // Set the source (if any)
                if (jORedRops & AVEC_NEED_SOURCE)
                {
                    xSrc = pptlSrc->x;
                    ySrc = pptlSrc->y;
                }

                vCompiledBlt(pdsurfTrg,
                             prclTrg->left,
                             prclTrg->top,
                             pdsurfSrc,
                             xSrc,
                             ySrc,
                             prclTrg->right  - prclTrg->left,
                             prclTrg->bottom - prclTrg->top,
                             rop4,
                             pbri,
                             ulBkColor,
                             ulFgColor,
                             pulXlate,
                             pptlBrush);


                break;


            case DC_COMPLEX:

                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, ENUM_RECT_LIMIT);
                bMore = TRUE;

                do {
                    if (bMore)
                    {
                        // Enumerate more clip rects
                        bMore = CLIPOBJ_bEnum(pco,(ULONG) sizeof(bben),
                                              (PVOID) &bben);
                    }

                    // Draw the portion of the blt dest that intersects each
                    // clip rect in turn
                    for (ircl = 0; ircl < bben.c; ircl++)
                    {

                        prcl = &bben.arcl[ircl];

                        // Find the intersection of the target rect and the
                        // current clip rect, then draw all banks of the
                        // clipped target rect, if it's not NULL
                        DrvIntersectRect(&rclTemp, prcl, prclTrg);

                        // Adjust the source (if any) accordingly
                        if (jORedRops & AVEC_NEED_SOURCE)
                        {
                            xSrc = pptlSrc->x + rclTemp.left -
                                    prclTrg->left;
                            ySrc = pptlSrc->y + rclTemp.top -
                                    prclTrg->top;
                        }

                        vCompiledBlt(pdsurfTrg,
                                     rclTemp.left,
                                     rclTemp.top,
                                     pdsurfSrc,
                                     xSrc,
                                     ySrc,
                                     rclTemp.right  - rclTemp.left,
                                     rclTemp.bottom - rclTemp.top,
                                     rop4,
                                     pbri,
                                     ulBkColor,
                                     ulFgColor,
                                     pulXlate,
                                     pptlBrush);

                    }
                } while(bMore);

                break;

        }   // switch(jClipping);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

#if DBG

ULONG DebugLevel = 0;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
    }

    va_end(ap);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\brush.h ===
/******************************Module*Header*******************************\
* Module Name: brush.h
*
* Contains the brush realization and dithering definitions.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

typedef struct  _BRUSHINST
{
    // We need to removed ajC0-3 when color pattern code is complete!!!
    //
    BYTE    ajC0[8];                    // Color bits for plane 0
    BYTE    ajC1[8];                    // Color bits for plane 1
    BYTE    ajC2[8];                    // Color bits for plane 2
    BYTE    ajC3[8];                    // Color bits for plane 3

    BYTE    ajPattern[32];                // Color bits for the mask
    USHORT  usStyle;                    // Brush style
    BYTE    fjAccel;                    // Accelerator flags
    BYTE    jFgColor;                   // Current foreground color
    BYTE    jBkColor;                   // Current background color
    BYTE    RealWidth;                  //
    BYTE    YShiftValue;                //
    BYTE    jOldBrushRealized;          //
    DWORD   Width;                      // Width of brush
    DWORD   Height;
    BYTE    *pPattern;              //Pointer to realized mono pattern
} BRUSHINST;

#define BRI_SOLID           0
#define BRI_HOLLOW          1
#define BRI_HATCHED         2
#define BRI_PATTERN         3
#define BRI_MONO_PATTERN    4
#define BRI_COLOR_PATTERN   5


//      Definitions for the pcol_C3 byte of the physical color
//
//      Some of these definitions have limitations as to when they
//      are valid.  They are as follows:
//
//      C0_BIT          color device, phys color, solid brushes if SOLID_COLOR
//      C1_BIT          color device, phys color, solid brushes if SOLID_COLOR
//      C2_BIT          color device, phys color, solid brushes if SOLID_COLOR
//      C3_BIT          color device, phys color, solid brushes if SOLID_COLOR
//      MONO_BIT        mono  device, phys color
//      ONES_OR_ZEROS   color device, phys color, solid brushes if SOLID_COLOR
//      GREY_SCALE      color device, dithered solid and hatched brushes
//      SOLID_BRUSH     color device, solid brush qualifier
//
//      There may be brushes where the accelerators could have been set,
//      but wasn't.  That's life.

#define C0_BIT          0x01            // C0 color
#define C1_BIT          0x02            // C1 color
#define C2_BIT          0x04            // C2 color
#define C3_BIT          0x08            // C3 color
#define COLOR_BITS      0x0f            // All the color bits
#define MONO_BIT        0x10            // Monochrome bit
#define ONES_OR_ZEROS   0x20            // Color is really all 1's or all 0's
#define GREY_SCALE      0x40            // Indicates a real grey scale brush
#define SOLID_BRUSH     0x80            // Indicates a solid color brush

#define PTRI_INVERT     0x0001
#define PTRI_ANIMATE    0x0002

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\brush.c ===
/******************************Module*Header*******************************\
* Module Name: brush.c
*
* Contains the brush realization and dithering code.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/
#include "driver.h"

#define OBR_REALIZED 1
#define OBR_4BPP     2

// aulDefBitMapping is used to translate packed pel into Planar

extern  ULONG aulDefBitMapping[8];

typedef VOID (*PFNV)();

/******************************Public*Routine******************************\
* DrvRealizeBrush
*
*
\**************************************************************************/

BOOL DrvRealizeBrush(
BRUSHOBJ *pbo,
SURFOBJ  *psoTarget,
SURFOBJ  *psoPattern,
SURFOBJ  *psoMask,
XLATEOBJ *pxlo,
ULONG    iHatch)
{
    ULONG           cx;                 // Height of pattern surface
    ULONG           cy;                 // Width  of pattern surface
    LONG            cbScan;             // Width in bytes of one scan
    PVOID           pvBits;             // Source bits
    ULONG          *pulXlate;           // Color translation
    HBITMAP         hbmTmp;             // Temp bmp handle for brush conversion
    BRUSHINST      *pbri;               // pointer to where realization goes
    BYTE            jBkColor, jFgColor; // local copies of mono attributes
    PFNV            pfnConvert;         // function pointer to mono conversion
    BYTE            jColors[2];         // place holder for special color->mono
                                        // conversion.
    BYTE            jTemp;
    BOOL            bConversion = FALSE; // True if we converted to 4bpp

    //
    // Allocate space for the realization.
    //
    if ((pbri = BRUSHOBJ_pvAllocRbrush(pbo,sizeof(BRUSHINST))) ==
            (BRUSHINST *)NULL) {

        return(FALSE);
    }

    //
    // If the dither-and-realize flag is set, the brush hasn't been dithered
    // yet and there is no pattern; we get to do it all here at once, with
    // the lower 24 bits being the RGB to dither. We can generate the dither
    // directly into our internal format, and we can know without counting how
    // many colors there are in the dither.
    //
    if (iHatch & RB_DITHERCOLOR) {

        vRealizeDitherPattern(pbri, iHatch);
        return(TRUE);
    }

    cx = psoPattern->sizlBitmap.cx;
    cy = psoPattern->sizlBitmap.cy;

    if ((cy != 8) || (cx > 16))
    {
        return(FALSE);
    }

    pbri->RealWidth = (BYTE)cx;

    switch (psoPattern->iBitmapFormat)
    {
    case BMF_1BPP:
    case BMF_4BPP:
    case BMF_8BPP:
        break;

    default:
        if ((cx != 8) && (cx != 16))
            return(FALSE);

        // Convert to 4bpp

        psoPattern = DrvConvertBrush(psoPattern, &hbmTmp, pxlo, cx, cy);
        if (psoPattern == (SURFOBJ *)NULL)
            return(FALSE);

        bConversion = TRUE;
        break;
    }

    //
    // Setup the pointer to the bits, and the scan-to-scan advance direction.
    //
    cbScan = psoPattern->lDelta;
    pvBits = psoPattern->pvScan0;

    if (psoPattern->iBitmapFormat == BMF_1BPP)
    {
        switch (cx) {
            case 16:
                if ((bShrinkPattern)((BYTE *)pvBits, cbScan))
                {
                    pbri->RealWidth = (BYTE)cx = 8;
                } else {
                    pfnConvert = vMono16Wide;
                    break;
                }
            case 8:
                pfnConvert = vMono8Wide;
                break;

            default:
                return(FALSE);
        }

        pbri->usStyle = BRI_MONO_PATTERN;
        pbri->fjAccel = 0;
        pbri->jBkColor =  (BYTE)pxlo->pulXlate[0];
        pbri->jFgColor =  (BYTE)pxlo->pulXlate[1];
        pbri->Width = 16;
        pbri->pPattern = (BYTE *)&(pbri->ajPattern[0]);
        pbri->jOldBrushRealized = 0;

        (*pfnConvert)(pbri->pPattern, pvBits, cbScan);

        if (bQuickPattern(pbri->pPattern, 8))
        {
            pbri->Height = 2;
            pbri->YShiftValue = 1;
        }
        else
        {
            pbri->Height = 8;
            pbri->YShiftValue = 3;
        }

        return(TRUE);
    }

    if ((cx != 8) && (cx != 16))
        return(FALSE);

    // We always have a table, because the input is 4 or 8-bpp; see if we even
    // need to pay attention to it.
    pulXlate = NULL;
    if (!(pxlo->flXlate & XO_TRIVIAL)) {
        pulXlate = pxlo->pulXlate;
    }

    if ((psoPattern->iBitmapFormat == BMF_4BPP) &&
        (psoTarget->iType != STYPE_DEVBITMAP) &&
            (CountColors(pvBits, cx, (WORD *)&jColors, cbScan) == 2)) {

        if ((cx == 16) && (bShrinkPattern)((BYTE *)pvBits, cbScan)) {
            cx = 8;
            pbri->RealWidth = (BYTE)cx;
        }

        pbri->usStyle = BRI_MONO_PATTERN;
        pbri->Height = 8;
        pbri->YShiftValue = 3;
        pbri->Width = 16;
        pbri->fjAccel = 0;
        pbri->pPattern = (BYTE *)&(pbri->ajPattern[0]);
        pbri->jOldBrushRealized = OBR_4BPP;

        if (pulXlate != (PULONG)NULL) {

            jBkColor = (BYTE)pulXlate[jColors[0]];
            jFgColor = (BYTE)pulXlate[jColors[1]];
        } else {

            jBkColor = jColors[0];
            jFgColor = jColors[1];
        }

        if (jBkColor > jFgColor) {
            pbri->jBkColor = jBkColor;
            pbri->jFgColor = jFgColor;
            jTemp = jColors[0];
        } else {
            pbri->jBkColor = jFgColor;
            pbri->jFgColor = jBkColor;
            jTemp = jColors[1];
        }


        vBrush2ColorToMono(pbri->pPattern, (BYTE *)pvBits, cbScan,
                cx, jTemp);

        if (bQuickPattern(pbri->pPattern, 8))
        {
            pbri->Height = 2;
            pbri->YShiftValue = 1;
        }

        vCopyOrgBrush(&(pbri->ajC0[0]),pvBits, cbScan, pxlo);

        if (bConversion) {
            EngUnlockSurface(psoPattern);
            EngDeleteSurface((HSURF)hbmTmp);
        }

        return(TRUE);

    } else if (cx != 8) {

        return(FALSE);
    }

    pbri->pPattern = (BYTE *)&(pbri->ajC0[0]);

    // At this point we know we have an 8x8 color pattern in either a
    // 4bpp or 8bpp format.

    if (psoPattern->iBitmapFormat == BMF_4BPP){

        vConvert4BppToPlanar(pbri->pPattern, (BYTE *)pvBits, cbScan, pulXlate);

    } else { // 8bpp

        vConvert8BppToPlanar(pbri->pPattern, (BYTE *)pvBits, cbScan, pulXlate);
    }

    // Set proper accelerators in the brush for the output code.

    pbri->usStyle = BRI_COLOR_PATTERN;  // Brush style is arbitrary pattern
    pbri->Height = 8;
    pbri->YShiftValue = 3;
    pbri->Width = 8;
    pbri->fjAccel = 0;
    pbri->jOldBrushRealized = OBR_REALIZED|OBR_4BPP;

    if (bConversion) {
        EngUnlockSurface(psoPattern);
        EngDeleteSurface((HSURF)hbmTmp);
    }

    return(TRUE);
}

/****************************************************************************\
* DrvConvertBrush()
*
* Converts a brush to a 4bpp bmp
*
\****************************************************************************/

SURFOBJ *DrvConvertBrush(
    SURFOBJ  *psoPattern,
    HBITMAP  *phbmTmp,
    XLATEOBJ *pxlo,
    ULONG    cx,
    ULONG    cy)
{
    SURFOBJ *psoTmp;
    RECTL    rclTmp;
    SIZEL    sizlTmp;
    POINTL   ptl;

    ptl.x       = 0;
    ptl.y       = 0;
    rclTmp.top  = 0;
    rclTmp.left = 0;
    rclTmp.right  = cx;
    sizlTmp.cx = cx;
    rclTmp.bottom = cy;
    sizlTmp.cy = cy;

    // Create bitmap in our compatible format.

    *phbmTmp = EngCreateBitmap(sizlTmp, (LONG) cx / 2, BMF_4BPP, 0, NULL);

    if ((*phbmTmp) && ((psoTmp = EngLockSurface((HSURF)*phbmTmp)) != NULL))
    {
        if (EngCopyBits(psoTmp, psoPattern, NULL, pxlo, &rclTmp, &ptl))
            return(psoTmp);

        EngUnlockSurface(psoTmp);
        EngDeleteSurface((HSURF)*phbmTmp);
    }

    return((SURFOBJ *)NULL);
}


/****************************************************************************\
* vCopyOrgBrush
*
* When we realize a mono or 2 color brush, we copy the original 4bpp brush
* to the ajC0 area of the realized brush. If we are called to do a
* rop that we don't directly support, vConvertBrush will be called to
* convert the orginal 4bpp brush to a planar brush that the blt compiler can
* use. Since this is a rare event, we do this on request instead of at
* realization time.
*
\****************************************************************************/

VOID vCopyOrgBrush(
    BYTE   *pDest,
    BYTE   *pSrc,
    LONG   lScan,
    XLATEOBJ *pxlo)
{
    ULONG *pulXlate, *pulDest;
    BYTE jByte, jColor;
    INT i;

    if ((pxlo != NULL) && (pxlo->flXlate & XO_TABLE)) {
        pulXlate = pxlo->pulXlate;

        for (i=0; i<8; i++) {
            INT j;
            for (j=0; j<4; j++) {
                jColor = *pSrc++;         // Get Next byte
                jByte = jColor;

                jByte = (BYTE) pulXlate[jByte & 0xf];
                jByte |= (BYTE) pulXlate[(jColor >> 4) & 0xf] << 4;
                *pDest++ = jByte;
            }
            pSrc += lScan - 4;
            }
    } else {
        pulDest = (ULONG *)pDest;

        for (i=0;i<8;i++) {
            *pulDest = *(ULONG *)pSrc;

            pSrc += lScan;
            pulDest++;
        }

    }
}


/****************************************************************************\
* vConvertBrush()
*
* This called when we are going to do a rop3 with a non-solid brush. We have
* to convert our brush back to the old blt compiler format in order for this
* blt to work properly.
*
\****************************************************************************/

BOOL bConvertBrush(
    BRUSHINST   *pbri)
{
    BYTE jPattern[32];
    if (pbri->jOldBrushRealized & OBR_REALIZED)
        return(TRUE);

    //
    // The blt compiler only handles 8x8
    //
    if (pbri->RealWidth != 8)
        return(FALSE);

    if (pbri->jOldBrushRealized & OBR_4BPP) {
        // It's stored as a DIB, so convert the DIB to planar form
        memcpy(&(jPattern[0]), &(pbri->ajC0[0]), 32);
        vConvert4BppToPlanar(&(pbri->ajC0[0]), &(jPattern[0]), 4, NULL);
        pbri->jOldBrushRealized |= OBR_REALIZED;

        return(TRUE);
    } else {
        // It started life as a monochrome bitmap, so we have nothing else with
        // which to work. Convert the monochrome to planar, based on the colors
        // with which the brush was realized.
        // Only 8-wide can be handled by the blt compiler
        {
            PBYTE pMono = pbri->pPattern;
            PBYTE pMonoTemp;
            PBYTE pColor = (BYTE *)&(pbri->ajC0[0]);
            ULONG fgColor = pbri->jFgColor;
            ULONG bkColor = pbri->jBkColor;
            ULONG PlaneMask = 1;
            INT i, j;

            ASSERT((pbri->Width == 16), "mono brush width != 16");

            // Expand the pattern for each plane, according to the fg & bg
            for (i=0; i<4; i++) {
                if (fgColor & PlaneMask) {
                    if (bkColor & PlaneMask) {
                        // fg = bg = 1 for this plane
                        *(LONG *)pColor = -1;
                        *(((LONG *)pColor) + 1) = -1;
                        pColor += 8;    // point to next plane's storage loc
                    } else {
                        // fg = 1, bg = 0 for this plane
                        pMonoTemp = pMono;
                        for (j = 0; j < 8; j++) {
                            *pColor++ = *pMonoTemp;
                            pMonoTemp += 2;
                        }
                    }
                } else {
                    if (bkColor & PlaneMask) {
                        // fg = 0, bg = 1 for this plane
                        pMonoTemp = pMono;
                        for (j = 0; j < 8; j++) {
                            *pColor++ = ~*pMonoTemp;
                            pMonoTemp += 2;
                        }
                    } else {
                        // fg = bg = 0 for this plane
                        *(ULONG *)pColor = 0;
                        *(((ULONG *)pColor) + 1) = 0;
                        pColor += 8;    // point to next plane's storage loc
                    }
                }
                PlaneMask <<= 1;    // select next plane
            }

            pbri->usStyle = BRI_COLOR_PATTERN;
            pbri->Height = 8;
            pbri->YShiftValue = 3;
            pbri->Width = 8;
            pbri->fjAccel = 0;
            pbri->pPattern = (BYTE *)&(pbri->ajC0[0]);

            // Mark that this brush is realized and is a full-color brush from
            // now on (ideally, we'd keep both the mono and color versions
            // around, but this is not a major performance issue and rarely
            // happens)
            pbri->jOldBrushRealized |= OBR_REALIZED | OBR_4BPP;

            return(TRUE);
        }
    }

    return(FALSE);
}

/****************************************************************************\
* vRealizeDitherPattern()
*
* Generates an 8x8 dither pattern, in our internal realization format, for
* the color RGBToDither. Note that the high byte of RGBToDither does not
* need to be set to zero, because ComputeSubspaces ignores it.
*
* Note: this routine can be made a great deal faster for 2-color patterns by
* simply prestoring all 64 possible monochrome patterns, for a cost of 512
* bytes, then looking up the appropriate pattern based on the # of foreground
* pixels in the dither. This would save all the time required to reverse-
* engineer the monochrome pattern out of the 4-bpp DIB, as well as almost all
* the time required to generate the dithered DIB. Color patterns could be
* made faster by not having vDitherColor pack the DIB into 4-bpp form; this
* would save the DIB packing time, but then we'd need new DIB->planar
* routines. This is not as big a win as the monochrome case. So far, I
* haven't figured out a way to dither directly into planar format more
* efficiently than dithering to the DIB and then converting to planar form.
*
* It would also be faster to generate the DIB back from the monochrome
* pattern in the monochrome case, so we don't have to copy the DIB for
* later translation (this would be required if we dithered two-color
* patterns directly into monochrome bitmaps, to support the blt compiler).
*
\****************************************************************************/
VOID vRealizeDitherPattern(BRUSHINST *pbri, ULONG RGBToDither)
{
    BYTE jDitherBuffer[32];
    ULONG ulNumVertices;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;

//    BYTE jBkColor, jFgColor; // local copies of mono attributes
//    BYTE jColors[2];         // place holder for special color->mono conversion


    // Generate the dither into a stack buffer

    // Calculate what color subspaces are involved in the dither
    pvVertexData = ComputeSubspaces(RGBToDither, vVertexData);

    // Now that we have found the bounding vertices and the number of
    // pixels to dither for each vertex, we can create the dither pattern

    ulNumVertices = pvVertexData - vVertexData;
                      // # of vertices with more than zero pixels in the dither

    // Do the actual dithering
    vDitherColor((ULONG *)jDitherBuffer, vVertexData, pvVertexData,
                 ulNumVertices);

    pbri->RealWidth = 8;
    pbri->Height = 8;
    pbri->YShiftValue = 3;
    pbri->fjAccel = 0;

    // Special-case monochrome by storing monochrome masks for acceleration

    if (ulNumVertices == 2) {

        pbri->usStyle = BRI_MONO_PATTERN;
        pbri->Width = 16;
        pbri->pPattern = (BYTE *)&(pbri->ajPattern[0]);
        pbri->jOldBrushRealized = OBR_4BPP; // 4-plane form not yet realized

        // vBrush2ColorToMono requires that the smaller color map to the
        // 1-bits, so switch the foreground and background if necessary
        // to make this the case
        pbri->jBkColor = (BYTE) vVertexData[0].ulVertex;
        pbri->jFgColor = (BYTE) vVertexData[1].ulVertex;

        if (vVertexData[0].ulVertex < vVertexData[1].ulVertex) {

            pbri->jBkColor = (BYTE) vVertexData[1].ulVertex;
            pbri->jFgColor = (BYTE) vVertexData[0].ulVertex;
        }


        // Convert the brush to a monochrome bitmap
        vBrush2ColorToMono(pbri->pPattern, jDitherBuffer, 4,
                8, pbri->jBkColor);

        // Shrink the brush to 2 scans high if possible
        if (bQuickPattern(pbri->pPattern, 8))
        {
            pbri->Height = 2;
            pbri->YShiftValue = 1;
        }

        // Remember the original DIB in case we need the 4-plane form later
        vCopyOrgBrush(&(pbri->ajC0[0]), jDitherBuffer, 4, NULL);

        return;
    }

    // The realized (planar) pattern goes in ajC0
    pbri->pPattern = (BYTE *)&(pbri->ajC0[0]);

    // Because we're dithering, we always have an 8x8 color pattern in a 4bpp
    // format, with no translation
    vConvert4BppToPlanar(pbri->pPattern, jDitherBuffer, 4, NULL);

    // Set proper accelerators in the brush for the output code.
    pbri->usStyle = BRI_COLOR_PATTERN;  // brush style is 4-bpp planar
    pbri->Width = 8;
    pbri->jOldBrushRealized = OBR_REALIZED | OBR_4BPP;
                                        // the 4-plane realization that we use
                                        // is the same format the blt compiler
                                        // wants
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\color.c ===
/******************************Module*Header*******************************\
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft product is
* prohibited without written permission from Microsoft.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-7 and 9-15 of the Windows standard (required)
* 16-color palette, where vertices 0-7 are the vertices of the inner color
* cube, and 0 plus 9-15 are the vertices of the full color cube. Vertex 8 is
* 75% gray; this could be used in the dither, but that would break apps that
* depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDword[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0x07070707,
    0x08080808,
    0x09090909,
    0x0A0A0A0A,
    0x0B0B0B0B,
    0x0C0C0C0C,
    0x0D0D0D0D,
    0x0E0E0E0E,
    0x0F0F0F0F
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity. This is organized in the following form, for
// efficiency: every set of 8 pixels (0-7, 8-15, 16-23, ... ,56-63) is
// placed in the dither pattern in the order: 0 2 4 6 1 3 5 7. This is
// done so that two longs can be combined to put 8 pixels in DIB4 format
// at once (the first dword is shifted left 4, then the two dwords are
// ORed, to produce 0 1 2 3 4 5 6 7 order in memory), which is much faster than
// combining the output of the straight dither ordering.
// The effective dither ordering after we combine each pair of ULONGS at the
// end (the desired dither ordering) is:
//
//  0, 36,  4, 32, 18, 54, 22, 50,
//  2, 38,  6, 34, 16, 52, 20, 48,
//  9, 45, 13, 41, 27, 63, 31, 59,
// 11, 47, 15, 43, 25, 61, 29, 57,
//  1, 37,  5, 33, 19, 55, 23, 51,
//  3, 39,  7, 35, 17, 53, 21, 49,
//  8, 44, 12, 40, 26, 62, 30, 58,
// 10, 46, 14, 42, 24, 60, 28, 56,
//
ULONG aulDitherOrder[] = {
  0, 34,  2, 32, 17, 51, 19, 49,
  1, 35,  3, 33, 16, 50, 18, 48,
 12, 46, 14, 44, 29, 63, 31, 61,
 13, 47, 15, 45, 28, 62, 30, 60,
  4, 38,  6, 36, 21, 55, 23, 53,
  5, 39,  7, 37, 20, 54, 22, 52,
  8, 42, 10, 40, 25, 59, 27, 57,
  9, 43, 11, 41, 24, 58, 26, 56,
};

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA colors
*
\**************************************************************************/

ULONG DrvDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG *pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;

    // Figure out if we need a full color dither or only a monochrome dither
    if (iMode != DM_MONOCHROME) {

        // Full color dither

        // Calculate what color subspaces are involved in the dither
        pvVertexData = ComputeSubspaces(rgb, vVertexData);

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = pvVertexData - vVertexData;    // # of vertices with more than
                                                //  zero pixels in the dither

        vDitherColor(pul, vVertexData, pvVertexData, ulTemp);

    } else {

        // For monochrome we will only use the Intensity (grey level)
        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}

/******************************Public*Routine******************************\
* ComputeSubspaces
*
* Calculates the subspace data associated with rgb, stores the data at
* pvVertexData, in the form of an array of VERTEX_DATA structures,
* suitable for vDitherColor. Returns a pointer to the byte after the
* last VERTEX_DATA structure.
*
* Ignores the high byte of rgb.
*
\**************************************************************************/

VERTEX_DATA * ComputeSubspaces(ULONG rgb, VERTEX_DATA *pvVertexData)
{
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulSymmetry;
    ULONG   ulRed, ulGre, ulBlu, ulTemp;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;

    // Split the color into red, green, and blue components
    ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
    ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
    ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

    // Sort the RGB so that the point is transformed into subspace 0, and
    // keep track of the swaps in ulSymmetry so we can unravel it again
    // later.  We want r >= g >= b (subspace 0).
    ulSymmetry = 0;
    if (ulBlueTemp > ulRedTemp) {
        SWAPTHEM(ulBlueTemp,ulRedTemp);
        ulSymmetry = SWAP_RB;
    }

    if (ulBlueTemp > ulGreenTemp) {
        SWAPTHEM(ulBlueTemp,ulGreenTemp);
        ulSymmetry |= SWAP_GB;
    }

    if (ulGreenTemp > ulRedTemp) {
        SWAPTHEM(ulGreenTemp,ulRedTemp);
        ulSymmetry |= SWAP_RG;
    }

    ulSymmetry <<= 4;   // for lookup purposes

    // Scale the values from 0-255 to 0-64. Note that the scaling is not
    // symmetric at the ends; this is done to match Windows 3.1 dithering
    ulRed = (ulRedTemp + 1) >> 2;
    ulGre = (ulGreenTemp + 1) >> 2;
    ulBlu = (ulBlueTemp + 1) >> 2;

    // Compute the subsubspace within subspace 0 in which the point lies,
    // then calculate the # of pixels to dither in the colors that are the
    // four vertexes of the tetrahedron bounding the color we're emulating.
    // Only vertices with more than zero pixels are stored, and the
    // vertices are stored in order of increasing intensity, saving us the
    // need to sort them later
    if ((ulRedTemp + ulGreenTemp) > 256) {
        // Subsubspace 2 or 3
        if ((ulRedTemp + ulBlueTemp) > 256) {
            // Subsubspace 3
            // Calculate the number of pixels per vertex, still in
            // subsubspace 3, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 3 is:
            // 7, 9, 0x0B, 0x0F
            if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            ulVertex2Temp = ulGre - ulBlu;
            ulVertex3Temp = (ulRed - 64) + ulBlu;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
            }
        } else {
            // Subsubspace 2
            // Calculate the number of pixels per vertex, still in
            // subsubspace 2, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 2 is:
            // 3, 7, 9, 0x0B
            ulVertex1Temp = ulBlu << 1;
            ulVertex2Temp = ulRed - ulGre;
            ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
            if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex1Temp != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
        }
    } else {
        // Subsubspace 0 or 1
        if (ulRedTemp > 128) {
            // Subsubspace 1
            // Calculate the number of pixels per vertex, still in
            // subsubspace 1, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 1 is:
            // 1, 3, 7, 9
            if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex2Temp = ulBlu << 1;
            ulVertex3Temp = (ulRed - 32) << 1;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
        } else {
            // Subsubspace 0
            // Calculate the number of pixels per vertex, still in
            // subsubspace 0, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 0 is:
            // 0, 1, 3, 7
            if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
            }
            if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex3Temp = ulBlu << 1;
            if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex1Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
        }
    }

    return(pvVertexData);
}

/******************************Public*Routine******************************\
* vDitherColor
*
* Dithers the ulNumVertices vertices described by vVertexData into pulDest.
*
\**************************************************************************/

VOID vDitherColor(ULONG * pulDest, VERTEX_DATA * vVertexData,
    VERTEX_DATA * pvVertexDataEnd, ULONG ulNumVertices)
{
    ULONG ulTemp, ulNumPixels, ulColor;
    VERTEX_DATA *pvMaxVertex, *pvVertexData;
    ULONG  *pulTemp, *pulDitherOrder;
    BYTE    jColor;
    BYTE    ajDither[64];

    if (ulNumVertices > 2) {

        // There are 3 or 4 vertices in this dither
        if (ulNumVertices == 3) {

            // There are 3 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            } else {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            }

        } else {

            // There are 4 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            } else {
                pvMaxVertex = &vVertexData[3];
                ulTemp = vVertexData[3].ulCount;
            }
        }

        if (vVertexData[1].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[1];
            ulTemp = vVertexData[1].ulCount;
        }
        if (vVertexData[0].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[0];
        }

        // Prepare a dword version of the most common vertex number (color)
        ulColor = ulNibbleToDword[pvMaxVertex->ulVertex];

        // Mark that the vertex we're about to do doesn't need to be done
        // later
        pvMaxVertex->ulVertex = 0xFF;

        // Block fill the dither pattern with the more common vertex
        pulTemp = (ULONG *)ajDither;
        *pulTemp = ulColor;
        *(pulTemp+1) = ulColor;
        *(pulTemp+2) = ulColor;
        *(pulTemp+3) = ulColor;
        *(pulTemp+4) = ulColor;
        *(pulTemp+5) = ulColor;
        *(pulTemp+6) = ulColor;
        *(pulTemp+7) = ulColor;
        *(pulTemp+8) = ulColor;
        *(pulTemp+9) = ulColor;
        *(pulTemp+10) = ulColor;
        *(pulTemp+11) = ulColor;
        *(pulTemp+12) = ulColor;
        *(pulTemp+13) = ulColor;
        *(pulTemp+14) = ulColor;
        *(pulTemp+15) = ulColor;

        // Now dither all the remaining vertices in order 0->2 or 0->3
        // (in order of increasing intensity)
        pulDitherOrder = aulDitherOrder;
        pvVertexData = vVertexData;
        do {
            if (pvVertexData->ulVertex == 0xFF) {
                // This is the max vertex, which we already did, but we
                // have to account for it in the dither order
                pulDitherOrder += pvVertexData->ulCount;
            } else {
                jColor = (BYTE) pvVertexData->ulVertex;
                ulNumPixels = pvVertexData->ulCount;
                switch (ulNumPixels & 3) {
                    case 3:
                        ajDither[*(pulDitherOrder+2)] = jColor;
                    case 2:
                        ajDither[*(pulDitherOrder+1)] = jColor;
                    case 1:
                        ajDither[*(pulDitherOrder+0)] = jColor;
                        pulDitherOrder += ulNumPixels & 3;
                    case 0:
                        break;
                }
                if ((ulNumPixels >>= 2) != 0) {
                    do {
                        ajDither[*pulDitherOrder] = jColor;
                        ajDither[*(pulDitherOrder+1)] = jColor;
                        ajDither[*(pulDitherOrder+2)] = jColor;
                        ajDither[*(pulDitherOrder+3)] = jColor;
                        pulDitherOrder += 4;
                    } while (--ulNumPixels);
                }
            }
        } while (++pvVertexData < pvVertexDataEnd);

    } else if (ulNumVertices == 2) {

        // There are exactly two vertices with more than zero pixels; fill
        // in the dither array as follows: block fill with vertex with more
        // points first, then dither in the other vertex
        if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
            // There are no more vertex 1 than vertex 0 pixels, so do
            // the block fill with vertex 0
            ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
            // Do the dither with vertex 1
            jColor = (BYTE) vVertexData[1].ulVertex;
            ulNumPixels = vVertexData[1].ulCount;
            // Set where to start dithering with vertex 1 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
        } else {
            // There are more vertex 1 pixels, so do the block fill
            // with vertex 1
            ulColor = ulNibbleToDword[vVertexData[1].ulVertex];
            // Do the dither with vertex 0
            jColor = (BYTE) vVertexData[0].ulVertex;
            ulNumPixels = vVertexData[0].ulCount;
            // Set where to start dithering with vertex 0 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder;
        }

        // Block fill the dither pattern with the more common vertex
        pulTemp = (ULONG *)ajDither;
        *pulTemp = ulColor;
        *(pulTemp+1) = ulColor;
        *(pulTemp+2) = ulColor;
        *(pulTemp+3) = ulColor;
        *(pulTemp+4) = ulColor;
        *(pulTemp+5) = ulColor;
        *(pulTemp+6) = ulColor;
        *(pulTemp+7) = ulColor;
        *(pulTemp+8) = ulColor;
        *(pulTemp+9) = ulColor;
        *(pulTemp+10) = ulColor;
        *(pulTemp+11) = ulColor;
        *(pulTemp+12) = ulColor;
        *(pulTemp+13) = ulColor;
        *(pulTemp+14) = ulColor;
        *(pulTemp+15) = ulColor;

        // Dither in the less common vertex
        switch (ulNumPixels & 3) {
            case 3:
                ajDither[*(pulDitherOrder+2)] = jColor;
            case 2:
                ajDither[*(pulDitherOrder+1)] = jColor;
            case 1:
                ajDither[*(pulDitherOrder+0)] = jColor;
                pulDitherOrder += ulNumPixels & 3;
            case 0:
                break;
        }
        if ((ulNumPixels >>= 2) != 0) {
            do {
                ajDither[*pulDitherOrder] = jColor;
                ajDither[*(pulDitherOrder+1)] = jColor;
                ajDither[*(pulDitherOrder+2)] = jColor;
                ajDither[*(pulDitherOrder+3)] = jColor;
                pulDitherOrder += 4;
            } while (--ulNumPixels);
        }

    } else {

        // There is only one vertex in this dither

        // No sorting or dithering is needed for just one color; we can
        // just generate the final DIB directly
        ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
        ulColor |= ulColor << 4;
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;

        return;
    }

    // Now convert the 64 bytes into the 4BPP Engine Format Bitmap
    pulTemp = (ULONG *)ajDither;

    *pulDest = (*pulTemp << 4) | *(pulTemp + 1);
    *(pulDest + 1) = (*(pulTemp + 2) << 4) | *(pulTemp + 3);
    *(pulDest + 2) = (*(pulTemp + 4) << 4) | *(pulTemp + 5);
    *(pulDest + 3) = (*(pulTemp + 6) << 4) | *(pulTemp + 7);
    *(pulDest + 4) = (*(pulTemp + 8) << 4) | *(pulTemp + 9);
    *(pulDest + 5) = (*(pulTemp + 10) << 4) | *(pulTemp + 11);
    *(pulDest + 6) = (*(pulTemp + 12) << 4) | *(pulTemp + 13);
    *(pulDest + 7) = (*(pulTemp + 14) << 4) | *(pulTemp + 15);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\creatdfb.c ===
/******************************Module*Header*******************************\
* Module Name: creatdfb.c
*
* Functions to create and delete device managed bitmaps
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

extern ajConvertBuffer[1];            // Arbitrary sized array!

/******************************Public*Routine******************************\
* HBITMAP DrvCreateDeviceBitmap
*
* Possibly create a device managed bitmap.
*
\**************************************************************************/

HBITMAP DrvCreateDeviceBitmap (DHPDEV dhpdev, SIZEL  sizl, ULONG  iFormat)
{
    PPDEV       pDevice = (PPDEV)dhpdev;
    HBITMAP     hbmDevice;
    PDEVSURF    pdsurf;                 // Handle & poiner to allocated surface
    ULONG       cjPlane;                // # bytes for one plane  of a scan
    ULONG       cjScan;                 // # bytes for all planes of a scan
    ULONG       cjBitmap;               // # bytes for entire bitmap + header

    //
    // We only support 4 bit-per-pel and device format bitmaps that are
    // 1280 or less wide.  Otherwise the BLT compiler dies.
    //

    if ((sizl.cx > 1280) ||
        (iFormat != BMF_4BPP))
        return ((HBITMAP) NULL);           // Tell the engine to manage it

    //
    // cjPlane = size of monoplane scan (rounded up to DWORD) in bytes
    //

    cjPlane  = ((sizl.cx + 31) & ~31) >> 3;
    cjScan   = cjPlane * 4;
    cjBitmap = (cjScan * (sizl.cy + 1)) + sizeof(DEVSURF);

    //
    // alloc some memory (not zeroed - engine will do it when we return)
    //

    pdsurf = (PDEVSURF) EngAllocMem(0, cjBitmap, ALLOC_TAG);

    if (pdsurf == (PDEVSURF) NULL)
    {
        return ((HBITMAP) NULL);            // Tell the engine to manage it
    }

// Fill in the non-zero fields of the DEVSURF structure

    pdsurf->ident        = DEVSURF_IDENT;
    pdsurf->iFormat      = BMF_DFB;
    pdsurf->ppdev        = (PPDEV) dhpdev;
    pdsurf->sizlSurf     = sizl;

    pdsurf->lNextScan    = cjScan;
    pdsurf->lNextPlane   = cjPlane;
    pdsurf->pvBitmapStart= &pdsurf->ajBits[0];
    pdsurf->pvStart      = &pdsurf->ajBits[0];
    pdsurf->pvConv       = (BYTE *) &pdsurf->ajBits[0] + (cjScan * sizl.cy);
    pdsurf->pvBankBufferPlane0 = NULL;

    hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf,sizl,iFormat);

    if (hbmDevice)
    {
        if (EngAssociateSurface((HSURF) hbmDevice,pDevice->hdevEng,
                HOOK_COPYBITS
                | HOOK_TEXTOUT
                | HOOK_STROKEPATH
                | HOOK_BITBLT
                | HOOK_PAINT
                | HOOK_FILLPATH
                //
                // Since the drawing code for the screen and for compatible
                // bitmaps (including the blt compiler) uses global buffers...
                //
                // We need HOOK_SYNCHRONIZEACCESS, which guarentees that
                // access to this bitmap, any others created with this flag,
                // and the screen will be mutually exclusive.
                //
                // The driver will then be effectively single threaded.
                //
                | HOOK_SYNCHRONIZEACCESS
               ))
        {
            return(hbmDevice);
        }

        EngDeleteSurface((HSURF) hbmDevice);
    }

    EngFreeMem(pdsurf);

    return(0);
}



/******************************Public*Routine******************************\
* VOID DrvDeleteDeviceBitmap(dhsurf)
*
* Release the device managed bitmap
*
\**************************************************************************/

VOID  DrvDeleteDeviceBitmap(DHSURF dhsurf)
{
    EngFreeMem(dhsurf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\copybits.c ===
/******************************Module*Header*******************************\
* Module Name: copybits.c
*
* DrvCopyBits
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/
#include "driver.h"
#include "bitblt.h"


BOOL DrvCopyBits
(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    PRECTL    prclTrg,
    PPOINTL   pptlSrc
)
{
    PDEVSURF    pdsurf;             // Pointer to a device surface

    LONG        lDelta;             // Delta to next scan of destination
    PVOID       pjDstScan0;         // Pointer to scan 0 of destination DIB
    ULONG      *pulXlate;           // Pointer to color xlate vector

    BOOL        bMore;              // Clip continuation flag
    ULONG       ircl;               // Clip enumeration rectangle index
    RECT_ENUM   cben;               // Clip enumerator
    RECTL       rclTemp;
    PRECTL      prcl;
    POINTL      ptlTemp;
    DEVSURF     dsurfTmp;
    PDEVSURF    pdsurfTrg;          // Pointer for target
    PDEVSURF    pdsurfSrc;          // Pointer for source if present
    INT         iCopyDir;
    PFN_ScreenToScreenBlt pfn_Blt;
    RECT_ENUM   bben;               // Clip enumerator
    BYTE        jClipping;
    UCHAR      *pucDIB4ToVGAConvTables;

    ULONG       ulWidth;
    ULONG       ulNumSlices;
    ULONG       ulRight;

    ULONG       x;


    //
    // if you remove the following code that sets pxlo to NULL for trivial
    // XLATEOBJs then you must go find all checks the text pxlo, and add
    // a check for (pxlo->flXlate & XO_TRIVIAL)
    //
    // ie. change all pxlo => (pxlo && !(pxlo->flXlate & XO_TRIVIAL))
    //

    if (pxlo && (pxlo->flXlate & XO_TRIVIAL))
    {
        pxlo = NULL;
    }

    if (pxlo &&
        ((psoTrg->iType == STYPE_DEVICE)||(psoTrg->iType == STYPE_DEVBITMAP)))
    {
            //
            // send through blt compiler because we won't do translates for DFBs
            //
            // note: blt compiler can't handle DIB targets
            //

            return(DrvBitBlt(psoTrg,
                             psoSrc,
                             (SURFOBJ *) NULL,
                             pco,
                             pxlo,
                             prclTrg,
                             pptlSrc,
                             (POINTL *) NULL,
                             (BRUSHOBJ *) NULL,
                             (POINTL *) NULL,
                             0x0000cccc));
    }

    // Check for device surface to device surface

    if ((psoTrg->iType == STYPE_DEVICE) && (psoSrc->iType == STYPE_DEVICE)) {
        pdsurfTrg = (PDEVSURF) psoTrg->dhsurf;
        pdsurfSrc = (PDEVSURF) psoSrc->dhsurf;

    // It's a screen-to-screen aligned SRCCOPY; special-case it

    // Determine the direction in which the copy must proceed
    // Note that although we could detect cases where the source
    // and dest don't overlap and handle them top to bottom, all
    // copy directions are equally fast, so there's no reason to go
    // top to bottom except possibly that it looks better. But it
    // also takes time to detect non-overlap, so I'm not doing it

    // Set up the clipping type

        if (pco == (CLIPOBJ *) NULL)
        {
        // No CLIPOBJ provided, so we don't have to worry about clipping

            jClipping = DC_TRIVIAL;
        }
        else
        {
        // Use the CLIPOBJ-provided clipping

            jClipping = pco->iDComplexity;
        }


        if (pptlSrc->y >= prclTrg->top) {
            if (pptlSrc->x >= prclTrg->left) {
                iCopyDir = CD_RIGHTDOWN;
            } else {
                iCopyDir = CD_LEFTDOWN;
            }
        } else {
            if (pptlSrc->x >= prclTrg->left) {
                iCopyDir = CD_RIGHTUP;
            } else {
                iCopyDir = CD_LEFTUP;
            }
        }

        //
        // These values are expected by vAlignedSrcCopy
        //

        switch(jClipping) {

            case DC_TRIVIAL:
                // Just copy the rectangle
                if ((((prclTrg->left ^ pptlSrc->x) & 0x07) == 0)) {
                    vAlignedSrcCopy(pdsurfTrg, prclTrg,
                                    pptlSrc, iCopyDir);
                } else {
                    vNonAlignedSrcCopy(pdsurfTrg, prclTrg,
                                       pptlSrc, iCopyDir);
                }
                break;

            case DC_RECT:
                // Clip the solid fill to the clip rectangle
                if (!DrvIntersectRect(&rclTemp, prclTrg,
                                      &pco->rclBounds)) {
                    // Nothing to draw; completely clipped
                    return TRUE;
                }

                // Adjust the source point for clipping too
                ptlTemp.x = pptlSrc->x + rclTemp.left - prclTrg->left;
                ptlTemp.y = pptlSrc->y + rclTemp.top - prclTrg->top;

                // Copy the clipped rectangle
                if ((((prclTrg->left ^ pptlSrc->x) & 0x07) == 0)) {
                    vAlignedSrcCopy(pdsurfTrg, &rclTemp, &ptlTemp,
                                    iCopyDir);
                } else {
                    vNonAlignedSrcCopy(pdsurfTrg, &rclTemp, &ptlTemp,
                                       iCopyDir);
                }
                break;

            case DC_COMPLEX:

                if ((((prclTrg->left ^ pptlSrc->x) & 0x07) == 0)) {
                    pfn_Blt = vAlignedSrcCopy;
                } else {
                    pfn_Blt = vNonAlignedSrcCopy;
                }

                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                   iCopyDir, ENUM_RECT_LIMIT);

                do {
                    bMore = CLIPOBJ_bEnum(pco,(ULONG) sizeof(bben),
                                          (PVOID) &bben);

                    prcl = bben.arcl;
                    for (ircl = 0; ircl < bben.c; ircl++, prcl++) {

                        DrvIntersectRect(prcl,prcl,prclTrg);

                        // Adjust the source point for clipping too
                        ptlTemp.x = pptlSrc->x + prcl->left -
                                prclTrg->left;
                        ptlTemp.y = pptlSrc->y + prcl->top -
                                prclTrg->top;
                        pfn_Blt(pdsurfTrg, prcl,
                                &ptlTemp, iCopyDir);

                    }
                } while(bMore);
                break;
        }
        return TRUE;
    }

    if ((psoSrc->iType == STYPE_DEVBITMAP) && (psoTrg->iType == STYPE_BITMAP)) {
        //
        // DFB to DIB
        //

        switch(psoTrg->iBitmapFormat)
        {
        case BMF_4BPP:  // special case compatible DIBs with no translation

            if (pxlo == NULL)
            {
                // Make just enough of a fake DEVSURF for the dest so that
                // the DFB to DIB code can work

                dsurfTmp.lNextScan = psoTrg->lDelta;
                dsurfTmp.pvBitmapStart = psoTrg->pvScan0;

                // Clip as needed

                if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL)) {

                    // No clipping, just copy the DFB to the DIB

                    ulWidth = prclTrg->right - prclTrg->left;

                    if (ulWidth <= MAX_SCAN_WIDTH) {
                        vDFB2DIB(&dsurfTmp, (PDEVSURF) psoSrc->dhsurf,
                                 prclTrg, pptlSrc);
                    } else {
                        rclTemp.left = prclTrg->left;
                        rclTemp.right = prclTrg->right;
                        rclTemp.top = prclTrg->top;
                        rclTemp.bottom = prclTrg->bottom;

                        //
                        // cut rect into slices MAX_SCAN_WIDTH wide
                        //
                        ulRight = rclTemp.right;   // save right edge
                        rclTemp.right = rclTemp.left+MAX_SCAN_WIDTH;
                        ulNumSlices = (ulWidth+MAX_SCAN_WIDTH-1) / MAX_SCAN_WIDTH;
                        for (x=0; x<ulNumSlices-1; x++) {
                            // Adjust the source point for clipping too
                            ptlTemp.x = pptlSrc->x + rclTemp.left - prclTrg->left;
                            ptlTemp.y = pptlSrc->y + rclTemp.top - prclTrg->top;
                            vDFB2DIB(&dsurfTmp, (PDEVSURF) psoSrc->dhsurf,
                                     &rclTemp, &ptlTemp);
                            rclTemp.left = rclTemp.right;
                            rclTemp.right += MAX_SCAN_WIDTH;
                        }
                        rclTemp.right = ulRight;
                        // Adjust the source point for clipping too
                        ptlTemp.x = pptlSrc->x + rclTemp.left - prclTrg->left;
                        ptlTemp.y = pptlSrc->y + rclTemp.top - prclTrg->top;
                        vDFB2DIB(&dsurfTmp, (PDEVSURF) psoSrc->dhsurf,
                                 &rclTemp, &ptlTemp);
                    }
                }
                else if (pco->iDComplexity == DC_RECT) {

                    // Clip the destination to the clip rectangle; we
                    // should never get a NULL result

                    if (DrvIntersectRect(&rclTemp, prclTrg, &pco->rclBounds)) {

                        ulWidth = rclTemp.right - rclTemp.left;

                        if (ulWidth <= MAX_SCAN_WIDTH) {
                            // Adjust the source point for clipping too
                            ptlTemp.x = pptlSrc->x + rclTemp.left - prclTrg->left;
                            ptlTemp.y = pptlSrc->y + rclTemp.top - prclTrg->top;
                            vDFB2DIB(&dsurfTmp, (PDEVSURF) psoSrc->dhsurf,
                                     &rclTemp, &ptlTemp);
                        } else {
                            //
                            // cut rect into slices MAX_SCAN_WIDTH wide
                            //
                            ulRight = rclTemp.right;   // save right edge
                            rclTemp.right = rclTemp.left+MAX_SCAN_WIDTH;
                            ulNumSlices = (ulWidth+MAX_SCAN_WIDTH-1) / MAX_SCAN_WIDTH;
                            for (x=0; x<ulNumSlices-1; x++) {
                                // Adjust the source point for clipping too
                                ptlTemp.x = pptlSrc->x + rclTemp.left - prclTrg->left;
                                ptlTemp.y = pptlSrc->y + rclTemp.top - prclTrg->top;
                                vDFB2DIB(&dsurfTmp, (PDEVSURF) psoSrc->dhsurf,
                                         &rclTemp, &ptlTemp);
                                rclTemp.left = rclTemp.right;
                                rclTemp.right += MAX_SCAN_WIDTH;
                            }
                            rclTemp.right = ulRight;
                            // Adjust the source point for clipping too
                            ptlTemp.x = pptlSrc->x + rclTemp.left - prclTrg->left;
                            ptlTemp.y = pptlSrc->y + rclTemp.top - prclTrg->top;
                            vDFB2DIB(&dsurfTmp, (PDEVSURF) psoSrc->dhsurf,
                                     &rclTemp, &ptlTemp);
                        }
                    }
                    return(TRUE);

                } else {    // DC_COMPLEX:

                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                       CD_ANY, ENUM_RECT_LIMIT);

                    do {
                        bMore = CLIPOBJ_bEnum(pco,(ULONG) sizeof(bben),
                                              (PVOID) &bben);
                        prcl = bben.arcl;
                        for (ircl = 0; ircl < bben.c; ircl++, prcl++) {

                            // Clip the destination to the clip rectangle;
                            // we should never get a NULL result
                            DrvIntersectRect(prcl,prcl,prclTrg);

                            ulWidth = prcl->right - prcl->left;

                            if (ulWidth <= MAX_SCAN_WIDTH) {
                                // Adjust the source point for clipping too
                                ptlTemp.x = pptlSrc->x + prcl->left - prclTrg->left;
                                ptlTemp.y = pptlSrc->y + prcl->top - prclTrg->top;
                                vDFB2DIB(&dsurfTmp, (PDEVSURF) psoSrc->dhsurf,
                                         prcl, &ptlTemp);
                            } else {
                                //
                                // cut rect into slices MAX_SCAN_WIDTH wide
                                //
                                ulRight = prcl->right;   // save right edge
                                prcl->right = prcl->left+MAX_SCAN_WIDTH;
                                ulNumSlices = (ulWidth+MAX_SCAN_WIDTH-1) / MAX_SCAN_WIDTH;
                                for (x=0; x<ulNumSlices-1; x++) {
                                    // Adjust the source point for clipping too
                                    ptlTemp.x = pptlSrc->x + prcl->left - prclTrg->left;
                                    ptlTemp.y = pptlSrc->y + prcl->top - prclTrg->top;
                                    vDFB2DIB(&dsurfTmp, (PDEVSURF) psoSrc->dhsurf,
                                             prcl, &ptlTemp);
                                    prcl->left = prcl->right;
                                    prcl->right += MAX_SCAN_WIDTH;
                                }
                                prcl->right = ulRight;
                                // Adjust the source point for clipping too
                                ptlTemp.x = pptlSrc->x + prcl->left - prclTrg->left;
                                ptlTemp.y = pptlSrc->y + prcl->top - prclTrg->top;
                                vDFB2DIB(&dsurfTmp, (PDEVSURF) psoSrc->dhsurf,
                                         prcl, &ptlTemp);
                            }
                        }
                    } while(bMore);

                }

                return(TRUE);
            }
            break;
        }
    }

    if ((psoSrc->iType == STYPE_DEVBITMAP) && (psoTrg->iType == STYPE_DEVBITMAP)) {
        //
        // DFB to DFB
        //

        if (psoSrc==psoTrg)                        // Src and Trg are same DFB
        {
            rclTemp.top =    pptlSrc->y;
            rclTemp.left =   pptlSrc->x;
            rclTemp.bottom = pptlSrc->y + (prclTrg->bottom - prclTrg->top);
            rclTemp.right =  pptlSrc->x + (prclTrg->right - prclTrg->left);

            //
            // if the copy overlaps and the dst is lower than or equal to the
            // src, then corruption would occur if we use a left to right, top
            // to bottom copy.  Therefore, we would copy through the blt
            // compiler which will copy the other way
            //

            if (prclTrg->top >= pptlSrc->y)
            {
                if (DrvIntersectRect(&rclTemp,&rclTemp,prclTrg))
                {
                    return(DrvBitBlt(psoTrg,                // send through blt compiler
                                     psoSrc,
                                     (SURFOBJ *) NULL,
                                     pco,
                                     pxlo,
                                     prclTrg,
                                     pptlSrc,
                                     (POINTL *) NULL,
                                     (BRUSHOBJ *) NULL,
                                     (POINTL *) NULL,
                                     0x0000cccc));
                }
            }
        }

        if (pxlo == NULL)
        {
            // Clip as needed

            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL)) {

                // No clipping, just copy the DFB to the DFB

                vDFB2DFB((PDEVSURF) psoTrg->dhsurf, (PDEVSURF) psoSrc->dhsurf, prclTrg,
                        pptlSrc);

            } else if (pco->iDComplexity == DC_RECT) {

                // Clip the destination to the clip rectangle; we
                // should never get a NULL result
                if (DrvIntersectRect(&rclTemp, prclTrg, &pco->rclBounds)) {

                    // Adjust the source point for clipping too
                    ptlTemp.x = pptlSrc->x + rclTemp.left - prclTrg->left;
                    ptlTemp.y = pptlSrc->y + rclTemp.top - prclTrg->top;

                    // Blt the clipped rectangle
                    vDFB2DFB((PDEVSURF) psoTrg->dhsurf, (PDEVSURF) psoSrc->dhsurf,
                            &rclTemp, &ptlTemp);
                }
                return(TRUE);

            } else {    // DC_COMPLEX:

                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                   CD_ANY, ENUM_RECT_LIMIT);

                do {
                    bMore = CLIPOBJ_bEnum(pco,(ULONG) sizeof(bben),
                                          (PVOID) &bben);
                    prcl = bben.arcl;
                    for (ircl = 0; ircl < bben.c; ircl++, prcl++) {

                        // Clip the destination to the clip rectangle;
                        // we should never get a NULL result
                        DrvIntersectRect(prcl,prcl,prclTrg);

                        // Adjust the source point for clipping too
                        ptlTemp.x = pptlSrc->x + prcl->left -
                                prclTrg->left;
                        ptlTemp.y = pptlSrc->y + prcl->top -
                                prclTrg->top;

                        // Blt the clipped rectangle
                        vDFB2DFB((PDEVSURF) psoTrg->dhsurf,
                                 (PDEVSURF) psoSrc->dhsurf, prcl, &ptlTemp);
                    }
                } while(bMore);

            }

            return(TRUE);
        }
    }

    if ((psoSrc->iType == STYPE_DEVBITMAP) && (psoTrg->iType == STYPE_DEVICE)) {
        //
        // DFB to screen
        //

        if (pxlo == NULL)
        {
            // Clip as needed

            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL)) {

                // No clipping, just copy the DFB to the VGA

                vDFB2VGA((PDEVSURF) psoTrg->dhsurf, (PDEVSURF) psoSrc->dhsurf, prclTrg,
                        pptlSrc);

            } else if (pco->iDComplexity == DC_RECT) {

                // Clip the destination to the clip rectangle; we
                // should never get a NULL result
                if (DrvIntersectRect(&rclTemp, prclTrg, &pco->rclBounds)) {

                    // Adjust the source point for clipping too
                    ptlTemp.x = pptlSrc->x + rclTemp.left - prclTrg->left;
                    ptlTemp.y = pptlSrc->y + rclTemp.top - prclTrg->top;

                    // Blt the clipped rectangle
                    vDFB2VGA((PDEVSURF) psoTrg->dhsurf, (PDEVSURF) psoSrc->dhsurf,
                            &rclTemp, &ptlTemp);
                }
                return(TRUE);

            } else {    // DC_COMPLEX:

                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                   CD_ANY, ENUM_RECT_LIMIT);

                do {
                    bMore = CLIPOBJ_bEnum(pco,(ULONG) sizeof(bben),
                                          (PVOID) &bben);
                    prcl = bben.arcl;
                    for (ircl = 0; ircl < bben.c; ircl++, prcl++) {

                        // Clip the destination to the clip rectangle;
                        // we should never get a NULL result
                        DrvIntersectRect(prcl,prcl,prclTrg);

                        // Adjust the source point for clipping too
                        ptlTemp.x = pptlSrc->x + prcl->left -
                                prclTrg->left;
                        ptlTemp.y = pptlSrc->y + prcl->top -
                                prclTrg->top;

                        // Blt the clipped rectangle
                        vDFB2VGA((PDEVSURF) psoTrg->dhsurf,
                                 (PDEVSURF) psoSrc->dhsurf, prcl, &ptlTemp);
                    }
                } while(bMore);

            }

            return(TRUE);
        }
    }

    if ((psoSrc->iType == STYPE_BITMAP) && (psoTrg->iType == STYPE_DEVBITMAP)) {
        //
        // DIB to DFB
        //

        switch(psoSrc->iBitmapFormat)
        {
        case BMF_4BPP:  // special case compatible DIBs with no translation

            if (pxlo == NULL)
            {
                pucDIB4ToVGAConvTables =
                            ((PDEVSURF) psoTrg->dhsurf)->ppdev->
                            pucDIB4ToVGAConvTables;

                // Make just enough of a fake DEVSURF for the source so that
                // the DIB to DFB code can work

                dsurfTmp.lNextScan = psoSrc->lDelta;
                dsurfTmp.pvBitmapStart = psoSrc->pvScan0;

                // Clip as needed

                if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL)) {

                    // No clipping, just copy the DFB to the DIB

                    ulWidth = prclTrg->right - prclTrg->left;

                    if (ulWidth <= MAX_SCAN_WIDTH) {
                        vDIB2VGA((PDEVSURF) psoTrg->dhsurf, &dsurfTmp, prclTrg,
                                 pptlSrc, pucDIB4ToVGAConvTables, DFB_TARGET);
                    } else {
                        rclTemp.left = prclTrg->left;
                        rclTemp.right = prclTrg->right;
                        rclTemp.top = prclTrg->top;
                        rclTemp.bottom = prclTrg->bottom;

                        //
                        // cut rect into slices MAX_SCAN_WIDTH wide
                        //
                        ulRight = rclTemp.right;   // save right edge
                        rclTemp.right = rclTemp.left+MAX_SCAN_WIDTH;
                        ulNumSlices = (ulWidth+MAX_SCAN_WIDTH-1) / MAX_SCAN_WIDTH;
                        for (x=0; x<ulNumSlices-1; x++) {
                            // Adjust the source point for clipping too
                            ptlTemp.x = pptlSrc->x + rclTemp.left - prclTrg->left;
                            ptlTemp.y = pptlSrc->y + rclTemp.top - prclTrg->top;
                            vDIB2VGA((PDEVSURF) psoTrg->dhsurf, &dsurfTmp,
                                     &rclTemp, &ptlTemp, pucDIB4ToVGAConvTables, DFB_TARGET);
                            rclTemp.left = rclTemp.right;
                            rclTemp.right += MAX_SCAN_WIDTH;
                        }
                        rclTemp.right = ulRight;
                        // Adjust the source point for clipping too
                        ptlTemp.x = pptlSrc->x + rclTemp.left - prclTrg->left;
                        ptlTemp.y = pptlSrc->y + rclTemp.top - prclTrg->top;
                        vDIB2VGA((PDEVSURF) psoTrg->dhsurf, &dsurfTmp,
                                 &rclTemp, &ptlTemp, pucDIB4ToVGAConvTables, DFB_TARGET);
                    }
                }
                else if (pco->iDComplexity == DC_RECT) {

                    // Clip the destination to the clip rectangle; we
                    // should never get a NULL result

                    if (DrvIntersectRect(&rclTemp, prclTrg, &pco->rclBounds)) {

                        ulWidth = rclTemp.right - rclTemp.left;

                        if (ulWidth <= MAX_SCAN_WIDTH) {
                            // Adjust the source point for clipping too
                            ptlTemp.x = pptlSrc->x + rclTemp.left - prclTrg->left;
                            ptlTemp.y = pptlSrc->y + rclTemp.top - prclTrg->top;
                            vDIB2VGA((PDEVSURF) psoTrg->dhsurf, &dsurfTmp,
                                     &rclTemp, &ptlTemp, pucDIB4ToVGAConvTables, DFB_TARGET);
                        } else {
                            //
                            // cut rect into slices MAX_SCAN_WIDTH wide
                            //
                            ulRight = rclTemp.right;   // save right edge
                            rclTemp.right = rclTemp.left+MAX_SCAN_WIDTH;
                            ulNumSlices = (ulWidth+MAX_SCAN_WIDTH-1) / MAX_SCAN_WIDTH;
                            for (x=0; x<ulNumSlices-1; x++) {
                                // Adjust the source point for clipping too
                                ptlTemp.x = pptlSrc->x + rclTemp.left - prclTrg->left;
                                ptlTemp.y = pptlSrc->y + rclTemp.top - prclTrg->top;
                                vDIB2VGA((PDEVSURF) psoTrg->dhsurf, &dsurfTmp,
                                         &rclTemp, &ptlTemp, pucDIB4ToVGAConvTables, DFB_TARGET);
                                rclTemp.left = rclTemp.right;
                                rclTemp.right += MAX_SCAN_WIDTH;
                            }
                            rclTemp.right = ulRight;
                            // Adjust the source point for clipping too
                            ptlTemp.x = pptlSrc->x + rclTemp.left - prclTrg->left;
                            ptlTemp.y = pptlSrc->y + rclTemp.top - prclTrg->top;
                            vDIB2VGA((PDEVSURF) psoTrg->dhsurf, &dsurfTmp,
                                     &rclTemp, &ptlTemp, pucDIB4ToVGAConvTables, DFB_TARGET);
                        }
                    }
                    return(TRUE);

                } else {    // DC_COMPLEX:

                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                       CD_ANY, ENUM_RECT_LIMIT);

                    do {
                        bMore = CLIPOBJ_bEnum(pco,(ULONG) sizeof(bben),
                                              (PVOID) &bben);
                        prcl = bben.arcl;
                        for (ircl = 0; ircl < bben.c; ircl++, prcl++) {

                            // Clip the destination to the clip rectangle;
                            // we should never get a NULL result
                            DrvIntersectRect(prcl,prcl,prclTrg);

                            ulWidth = prcl->right - prcl->left;

                            if (ulWidth <= MAX_SCAN_WIDTH) {
                                // Adjust the source point for clipping too
                                ptlTemp.x = pptlSrc->x + prcl->left - prclTrg->left;
                                ptlTemp.y = pptlSrc->y + prcl->top - prclTrg->top;
                                vDIB2VGA((PDEVSURF) psoTrg->dhsurf, &dsurfTmp,
                                         prcl, &ptlTemp, pucDIB4ToVGAConvTables, DFB_TARGET);
                            } else {
                                //
                                // cut rect into slices MAX_SCAN_WIDTH wide
                                //
                                ulRight = prcl->right;   // save right edge
                                prcl->right = prcl->left+MAX_SCAN_WIDTH;
                                ulNumSlices = (ulWidth+MAX_SCAN_WIDTH-1) / MAX_SCAN_WIDTH;
                                for (x=0; x<ulNumSlices-1; x++) {
                                    // Adjust the source point for clipping too
                                    ptlTemp.x = pptlSrc->x + prcl->left - prclTrg->left;
                                    ptlTemp.y = pptlSrc->y + prcl->top - prclTrg->top;
                                    vDIB2VGA((PDEVSURF) psoTrg->dhsurf, &dsurfTmp,
                                             prcl, &ptlTemp, pucDIB4ToVGAConvTables, DFB_TARGET);
                                    prcl->left = prcl->right;
                                    prcl->right += MAX_SCAN_WIDTH;
                                }
                                prcl->right = ulRight;
                                // Adjust the source point for clipping too
                                ptlTemp.x = pptlSrc->x + prcl->left - prclTrg->left;
                                ptlTemp.y = pptlSrc->y + prcl->top - prclTrg->top;
                                vDIB2VGA((PDEVSURF) psoTrg->dhsurf, &dsurfTmp,
                                         prcl, &ptlTemp, pucDIB4ToVGAConvTables, DFB_TARGET);
                            }
                        }
                    } while(bMore);

                }

                return(TRUE);
            }
            break;

        case BMF_1BPP:
        case BMF_8BPP:
            return(DrvBitBlt(psoTrg,                // send through blt compiler
                             psoSrc,
                             (SURFOBJ *) NULL,
                             pco,
                             pxlo,
                             prclTrg,
                             pptlSrc,
                             (POINTL *) NULL,
                             (BRUSHOBJ *) NULL,
                             (POINTL *) NULL,
                             0x0000cccc));
        }
    }

    if ((psoSrc->iType == STYPE_BITMAP) && (psoTrg->iType == STYPE_DEVICE)) {
        //
        // DIB to screen
        //

        switch(psoSrc->iBitmapFormat)
        {
        case BMF_4BPP:  // special case compatible DIBs with no translation

            if (pxlo == NULL)
            {
                pucDIB4ToVGAConvTables =
                            ((PDEVSURF) psoTrg->dhsurf)->ppdev->
                            pucDIB4ToVGAConvTables;

                // Make just enough of a fake DEVSURF for the source so that
                // the DIB to VGA code can work

                dsurfTmp.lNextScan = psoSrc->lDelta;
                dsurfTmp.pvBitmapStart = psoSrc->pvScan0;

                // Clip as needed

                if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL)) {

                    // No clipping, just copy the DIB to the VGA

                    vDIB2VGA((PDEVSURF) psoTrg->dhsurf, &dsurfTmp, prclTrg,
                            pptlSrc, pucDIB4ToVGAConvTables, VGA_TARGET);

                } else if (pco->iDComplexity == DC_RECT) {

                    // Clip the destination to the clip rectangle; we
                    // should never get a NULL result
                    if (DrvIntersectRect(&rclTemp, prclTrg, &pco->rclBounds)) {

                        // Adjust the source point for clipping too
                        ptlTemp.x = pptlSrc->x + rclTemp.left - prclTrg->left;
                        ptlTemp.y = pptlSrc->y + rclTemp.top - prclTrg->top;

                        // Blt the clipped rectangle
                        vDIB2VGA((PDEVSURF) psoTrg->dhsurf, &dsurfTmp,
                                &rclTemp, &ptlTemp, pucDIB4ToVGAConvTables, VGA_TARGET);
                    }
                    return(TRUE);

                } else {    // DC_COMPLEX:

                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                       CD_ANY, ENUM_RECT_LIMIT);

                    do {
                        bMore = CLIPOBJ_bEnum(pco,(ULONG) sizeof(bben),
                                              (PVOID) &bben);
                        prcl = bben.arcl;
                        for (ircl = 0; ircl < bben.c; ircl++, prcl++) {

                            // Clip the destination to the clip rectangle;
                            // we should never get a NULL result
                            DrvIntersectRect(prcl,prcl,prclTrg);

                            // Adjust the source point for clipping too
                            ptlTemp.x = pptlSrc->x + prcl->left -
                                    prclTrg->left;
                            ptlTemp.y = pptlSrc->y + prcl->top -
                                    prclTrg->top;

                            // Blt the clipped rectangle
                            vDIB2VGA((PDEVSURF) psoTrg->dhsurf,
                                    &dsurfTmp, prcl, &ptlTemp,
                                    pucDIB4ToVGAConvTables, VGA_TARGET);
                        }
                    } while(bMore);

                }

                return(TRUE);
            }
            break;

        case BMF_1BPP:
        case BMF_8BPP:
            return(DrvBitBlt(psoTrg,                // send through blt compiler
                             psoSrc,
                             (SURFOBJ *) NULL,
                             pco,
                             pxlo,
                             prclTrg,
                             pptlSrc,
                             (POINTL *) NULL,
                             (BRUSHOBJ *) NULL,
                             (POINTL *) NULL,
                             0x0000cccc));

        case BMF_8RLE:
        case BMF_4RLE:
            return(bRleBlt(psoTrg, psoSrc, pco, pxlo, prclTrg, pptlSrc));

        }
    }

    if ((psoSrc->iType == STYPE_DEVICE) && (psoTrg->iType == STYPE_BITMAP)) {
        //
        // screen to DIB
        //

        if (psoTrg->iBitmapFormat == BMF_4BPP)
        {
            pdsurf = (PDEVSURF) psoSrc->dhsurf;

        // Get the data for the destination DIB.

            lDelta = psoTrg->lDelta;
            pjDstScan0 = (PBYTE) psoTrg->pvScan0;

        // Setup for any color translation which may be needed !!! Is any needed at all?

            if (pxlo == NULL)
            {
                pulXlate = NULL;
            }
            else
            {
                if (pxlo->flXlate & XO_TABLE)
                    pulXlate = pxlo->pulXlate;
                else
                {
                    pulXlate = (PULONG) NULL;
                }
            }

        // Set up for clip enumeration.

            if (pco != (CLIPOBJ *) NULL)
            {
                switch(pco->iDComplexity)
                {
                case DC_TRIVIAL:
                    bMore = FALSE;
                    cben.c = 1;
                    cben.arcl[0] = *prclTrg;        // Use the target for clipping
                    break;

                case DC_RECT:
                    bMore = FALSE;
                    cben.c = 1;
                    cben.arcl[0] = pco->rclBounds; // Use the bounds for clipping
                    break;

                case DC_COMPLEX:
                    bMore = TRUE;
                    cben.c = 0;
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, ENUM_RECT_LIMIT);
                    break;
                }
            }
            else
            {
                bMore = FALSE;
                cben.c = 1;
                cben.arcl[0] = *prclTrg;            // Use the target for clipping
            }

        // Call the VGA conversion routine, adjusted for each rectangle

            do
            {
                LONG    xSrc;
                LONG    ySrc;
                RECTL  *prcl;

                if (bMore)
                    bMore = CLIPOBJ_bEnum(pco,(ULONG) sizeof(cben), (PVOID) &cben);

                for (ircl = 0; ircl < cben.c; ircl++)
                {
                    prcl = &cben.arcl[ircl];

                    if (DrvIntersectRect(&rclTemp, prclTrg, prcl))
                    {
                        xSrc = pptlSrc->x + rclTemp.left - prclTrg->left;
                        ySrc = pptlSrc->y + rclTemp.top  - prclTrg->top;
    
                        vConvertVGA2DIB(pdsurf,
                                        xSrc,
                                        ySrc,
                                        pjDstScan0,
                                        rclTemp.left,
                                        rclTemp.top,
                                        rclTemp.right - rclTemp.left,
                                        rclTemp.bottom - rclTemp.top,
                                        lDelta,
                                        psoTrg->iBitmapFormat,
                                        pulXlate);
                    }
                }
            } while (bMore);

            return(TRUE);
        }
    }

//
// This is how we do any formats that we don't support in our inner loops.
//

    return(SimCopyBits(psoTrg, psoSrc, pco, pxlo, prclTrg, pptlSrc));
}

/******************************Public*Routine******************************\
* SimCopyBits
*
* This function simulates CopyBits for the driver when the driver is asked
* to blt to formats it does not support.  It converts any blt to be between
* the device's preferred format and the screen.
*
\**************************************************************************/

BOOL SimCopyBits
(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    PRECTL    prclTrg,
    PPOINTL   pptlSrc
)
{
    HBITMAP  hbmTmp;
    SURFOBJ *psoTmp;
    RECTL    rclTmp;
    SIZEL    sizlTmp;
    BOOL     bReturn = FALSE;
    POINTL   ptl00 = {0,0};

    DISPDBG((1,"SimCopyBits %lu-%lu => %lu-%lu (%08x, %08x)\n",
                     psoSrc->iType,
                     psoSrc->iBitmapFormat,
                     psoTrg->iType,
                     psoTrg->iBitmapFormat,
                     pco  ? pco->iDComplexity : 0,
                     pxlo));

    rclTmp.top = rclTmp.left = 0;
    rclTmp.right  = sizlTmp.cx = prclTrg->right - prclTrg->left;
    rclTmp.bottom = sizlTmp.cy = prclTrg->bottom - prclTrg->top;

// Create bitmap in our compatible format.

    hbmTmp = EngCreateBitmap(sizlTmp, sizlTmp.cx / 2, BMF_4BPP, 0, NULL);

    if (hbmTmp)
    {
        if ((psoTmp = EngLockSurface((HSURF)hbmTmp)) != NULL)
        {
            if (((psoSrc->iType == STYPE_BITMAP) && (psoTrg->iType == STYPE_DEVICE)) ||
                ((psoSrc->iType == STYPE_BITMAP) && (psoTrg->iType == STYPE_DEVBITMAP)))
            {
                //
                // DIB to VGA  or  DIB to DFB
                //

                if (EngCopyBits(psoTmp, psoSrc, NULL, pxlo, &rclTmp, pptlSrc))
                {
                    //
                    // Let DrvCopyBits do this easy case copy to screen.
                    //
                    bReturn = DrvCopyBits(psoTrg, psoTmp, pco, NULL, prclTrg, &ptl00);
                }
                else
                {
                    DISPDBG((0, "SimCopyBits: EngCopyBits DIB -> DEV failed"));
                }
            }
            else if (((psoSrc->iType == STYPE_DEVICE) && (psoTrg->iType == STYPE_BITMAP)) ||
                     ((psoSrc->iType == STYPE_DEVBITMAP) && (psoTrg->iType == STYPE_BITMAP)))
            {
                //
                // VGA to DIB  or  DFB to DIB
                //

                if (DrvCopyBits(psoTmp, psoSrc, NULL, NULL, &rclTmp, pptlSrc))
                {
                    //
                    // Let EngCopyBits copy between DIBS
                    //
                    bReturn = EngCopyBits(psoTrg, psoTmp, pco, pxlo, prclTrg, &ptl00);
                }
                else
                {
                    DISPDBG((0, "SimCopyBits: DrvCopyBits DEV -> DIB failed"));
                }
            }
            else if (((psoSrc->iType == STYPE_DEVICE) || (psoSrc->iType == STYPE_DEVBITMAP)) &&
                     ((psoTrg->iType == STYPE_DEVICE) || (psoTrg->iType == STYPE_DEVBITMAP)))
            {
                //
                // VGA or DFB  to  VGA or DFB
                //

                if (DrvCopyBits(psoTmp, psoSrc, NULL, NULL, &rclTmp, pptlSrc))
                {
                    bReturn = DrvCopyBits(psoTrg, psoTmp, pco, pxlo, prclTrg, &ptl00);
                }
                else
                {
                    DISPDBG((0, "SimCopyBits: DrvCopyBits DEV -> DEV failed"));
                }
            }

            EngUnlockSurface(psoTmp);
        }
        else
        {
            DISPDBG((0, "SimCopyBits: EngLockSurface failed (psoTmp == NULL)"));
        }

        EngDeleteSurface((HSURF)hbmTmp);
    }
    else
    {
        DISPDBG((0, "SimCopyBits: EngCreateBitmap failed (hbmTmp == NULL)"));
    }

    if (!bReturn)
    {
        DISPDBG((0,"SimCopyBits failed %lu-%lu => %lu-%lu (%08x, %08x)\n",
                         psoSrc->iType,
                         psoSrc->iBitmapFormat,
                         psoTrg->iType,
                         psoTrg->iBitmapFormat,
                         pco  ? pco->iDComplexity : 0,
                         pxlo));
    }

    return(bReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\cursor.c ===
/******************************Module*Header*******************************\
* Module Name: cursor.c                                                    *
*                                                                          *
* Cursor management.                                                       *
*                                                                          *
* Copyright (c) 1992-1995 Microsoft Corporation                            *
\**************************************************************************/


#include "driver.h"


VOID   vShowCursor(PPDEV ppdev);
VOID   vHideCursor(PPDEV ppdev);
VOID   vComputePointerRect(PPDEV ppdev,RECTL *prcl);

VOID   vYankPointer(PPDEV,BOOL);              // POINTER.ASM
VOID   vDrawPointer(PPDEV,LONG,LONG,BOOL);    // POINTER.ASM

ULONG xyCreateMasks                     // POINTER.ASM
(
    PPDEV  ppdev,
    PVOID  pvMask,
    PVOID  pvColor,
    LONG   cy,
    ULONG *pulXlate,
    FSHORT fs,
    ULONG  fIsDFB
);

BOOL bSetHardwarePointerShape
(
    SURFOBJ  *pso,
    SURFOBJ  *psoMask,
    SURFOBJ  *psoColor,
    FLONG     fl);

BOOL bCopyInNewCursor(
    PPDEV    ppdev,
    SURFOBJ *pso);

/******************************Public*Routine******************************\
* DrvMovePointer (pso,x,y,prcl)                                            *
*                                                                          *
* Move the cursor to the specified location.                               *
*                                                                          *
\**************************************************************************/

VOID DrvMovePointer(SURFOBJ *pso,LONG x,LONG y,RECTL *prcl)
{
    PPDEV ppdev = (PPDEV) pso->dhpdev;

// (-1,-1) indicates that the cursor should be torn down.

    if (x == -1)
    {
        vHideCursor(ppdev);
        return;
    }

// Note where we want it to be drawn and do it.

    ppdev->xyCursor.x = (USHORT) x;
    ppdev->xyCursor.y = (USHORT) y;
    vShowCursor(ppdev);

// Return the new rectangle occupied by the pointer.

    if (prcl != (RECTL *) NULL)
        vComputePointerRect(ppdev,prcl);
    return;
}

/******************************Public*Routine******************************\
* DrvSetPointerShape (pso,psoMask,psoColor,pxlo,xHot,yHot,x,y,prcl,fl)     *
*                                                                          *
* Set a new pointer shape.                                                 *
*                                                                          *
\**************************************************************************/

ULONG DrvSetPointerShape
(
    SURFOBJ  *pso,
    SURFOBJ  *psoMask,
    SURFOBJ  *psoColor,
    XLATEOBJ *pxlo,
    LONG      xHot,
    LONG      yHot,
    LONG      x,
    LONG      y,
    RECTL    *prcl,
    FLONG     fl
)
{
    // Always let the cursor be drawn by GDI using the sprite code.

    return(SPS_DECLINE);
}

/******************************Public*Routine******************************\
* vComputePointerRect (ppdev,prcl)                                         *
*                                                                          *
* Computes the boundary around the pointer that GDI should avoid writing   *
* on.                                                                      *
*                                                                          *
\**************************************************************************/

VOID vComputePointerRect(PPDEV ppdev,RECTL *prcl)
{
    XYPAIR  xy;
    XYPAIR  xyHotSpot;

    xy        = ppdev->xyCursor;
    xyHotSpot = ppdev->xyHotSpot;

    prcl->left   = (xy.x - xyHotSpot.x) & POINTER_MASK;
    prcl->right  = prcl->left + ppdev->cExtent;
    prcl->top    = xy.y - xyHotSpot.y;
    prcl->bottom = prcl->top + ppdev->ptlExtent.y;
}

/*****************************Private*Routine******************************\
* VOID vShowCursor(ppdev)                                                  *
*                                                                          *
* Try to draw the cursor.                                                  *
*                                                                          *
\**************************************************************************/

VOID vShowCursor(PPDEV ppdev)
{
    XYPAIR  xy;
    XYPAIR  xyHotSpot;

    xy = ppdev->xyCursor;
    xyHotSpot = ppdev->xyHotSpot;

    if (ppdev->flCursor & CURSOR_HW_ACTIVE)
    {
        DWORD returnedDataLength;
        VIDEO_POINTER_POSITION PointerPosition;

        PointerPosition.Column = ppdev->pPointerAttributes->Column =
                (SHORT)(xy.x - xyHotSpot.x);
        PointerPosition.Row = ppdev->pPointerAttributes->Row =
                (SHORT)(xy.y - xyHotSpot.y);

        //
        // Call miniport to move pointer.
        //
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_POINTER_POSITION,
                               &PointerPosition,
                               sizeof(VIDEO_POINTER_POSITION),
                               NULL,
                               0,
                               &returnedDataLength))

        {
           DISPDBG((0, "vShowCursor fail IOCTL_VIDEO_SET_POINTER_POSITION\n"));
        }
    }
    else
    {
        vDrawPointer(ppdev, (LONG) (xy.x - xyHotSpot.x),
                     (LONG) (xy.y - xyHotSpot.y),
                     ppdev->flCursor & CURSOR_COLOR);
    }

    ppdev->flCursor &= ~CURSOR_DOWN;
}

/*****************************Private*Routine******************************\
* VOID vHideCursor(ppdev)                                                  *
*                                                                          *
* Try to hide the cursor                                                   *
*                                                                          *
\**************************************************************************/

VOID vHideCursor(PPDEV ppdev)
{
    if (ppdev->flCursor & CURSOR_DOWN)
       return;

    //
    // if this is a hardware cursor, hide it by moving it off the
    // screen.
    //
    if (ppdev->flCursor & CURSOR_HW_ACTIVE)
    {
        DWORD returnedDataLength;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_DISABLE_POINTER,
                               NULL,
                               0,
                               NULL,
                               0,
                               &returnedDataLength))

        {
            //
            // It should never be possible to fail.
            //

            DISPDBG((0, "vHideCursor failed IOCTL_VIDEO_DISABLE_POINTER\n"));
        }
    }
    else
    {
        vYankPointer(ppdev, ppdev->flCursor & CURSOR_COLOR);
    }

    ppdev->flCursor |= CURSOR_DOWN;
}

/******************************Public*Routine******************************\
* bSetHardwarePointerShape
*
* Changes the shape of the Hardware Pointer.
*
* Returns: True if successful, False if Pointer shape can't be hardware.
*
\**************************************************************************/

BOOL bSetHardwarePointerShape(
    SURFOBJ  *pso,
    SURFOBJ  *psoMask,
    SURFOBJ  *psoColor,
    FLONG     fl)
{
    PPDEV     ppdev = (PPDEV) pso->dhpdev;
    PVIDEO_POINTER_ATTRIBUTES pPointerAttributes = ppdev->pPointerAttributes;
    DWORD     returnedDataLength;

    pPointerAttributes->Flags = 0;

    // Only supports monochrome cursor for now
    if (psoColor != (SURFOBJ *) NULL)
    {
        return(FALSE);
    } else {
        pPointerAttributes->Flags |= VIDEO_MODE_MONO_POINTER;
    }

    if (fl & SPS_ANIMATESTART) {
        pPointerAttributes->Flags |= VIDEO_MODE_ANIMATE_START;
    } else if (fl & SPS_ANIMATEUPDATE) {
        pPointerAttributes->Flags |= VIDEO_MODE_ANIMATE_UPDATE;
    }

    // Copy the pixels into the buffer.

    if (!bCopyInNewCursor(ppdev, psoMask))
    {
        return(FALSE);
    }

    // Initialize cursor attributes and position

    pPointerAttributes->Column = ppdev->xyCursor.x - ppdev->xyHotSpot.x;
    pPointerAttributes->Row    = ppdev->xyCursor.y - ppdev->xyHotSpot.y;
    pPointerAttributes->Enable = 1;


    if (!(ppdev->flCursor & CURSOR_HW_ACTIVE)) {
        vHideCursor(ppdev);
    }


    // Set the new cursor shape.

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SET_POINTER_ATTR,
                           pPointerAttributes,
                           ppdev->cjPointerAttributes,
                           NULL,
                           0,
                           &returnedDataLength)) {

        return(FALSE);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bCopyInNewCursor
*
* Copies two monochrome masks into a buffer of the maximum size handled by the
* miniport, with any extra bits set to 0.  The masks are converted to topdown
* form if they aren't already.  Returns TRUE if we can handle this pointer in
* hardware, FALSE if not.
*
\**************************************************************************/

BOOL bCopyInNewCursor(
    PPDEV    ppdev,
    SURFOBJ *pso)
{
    ULONG cx;
    ULONG cy;
    PBYTE pjSrcAnd, pjSrcXor;
    LONG  lDeltaSrc, lDeltaDst;
    LONG  lSrcWidthInBytes;
    ULONG cxSrc = pso->sizlBitmap.cx;
    ULONG cySrc = pso->sizlBitmap.cy;
    ULONG cxSrcBytes;
    PVIDEO_POINTER_ATTRIBUTES pPointerAttributes = ppdev->pPointerAttributes;
    PBYTE pjDstAnd = pPointerAttributes->Pixels;
    PBYTE pjDstXor = pPointerAttributes->Pixels + ppdev->XorMaskStartOffset;

    // Make sure the new pointer isn't too big to handle
    // (*2 because both masks are in there)
    if ((cxSrc > ppdev->PointerCapabilities.MaxWidth) ||
        (cySrc > (ppdev->PointerCapabilities.MaxHeight * 2)))
    {
        return(FALSE);
    }

    // Pad the XOR mask with -1's
    memset(pjDstXor, 0xFFFFFFFF, ppdev->pPointerAttributes->WidthInBytes *
            ppdev->pPointerAttributes->Height);

    // Pad the AND mask with 0's
    memset(pjDstAnd, 0, ppdev->pPointerAttributes->WidthInBytes *
            ppdev->pPointerAttributes->Height);

    cxSrcBytes = (cxSrc + 7) / 8;

    if ((lDeltaSrc = pso->lDelta) < 0)
    {
        lSrcWidthInBytes = -lDeltaSrc;
    }
    else
    {
        lSrcWidthInBytes = lDeltaSrc;
    }

    pjSrcAnd = (PBYTE) pso->pvBits;

    // If the incoming pointer bitmap is bottomup, we'll flip it to topdown to
    // save the miniport some work
    if (!(pso->fjBitmap & BMF_TOPDOWN))
    {
        // Copy from the bottom
        pjSrcAnd += lSrcWidthInBytes * (cySrc - 1);
    }

    // Height of just AND mask
    cySrc = cySrc / 2;

    // Point to XOR mask
    pjSrcXor = pjSrcAnd + (cySrc * lDeltaSrc);

    // Offset to next source scan line
    lDeltaSrc -= cxSrcBytes;

    // Offset from end of one dest scan to start of next
    lDeltaDst = ppdev->pPointerAttributes->WidthInBytes - cxSrcBytes;

    for (cy = 0; cy < cySrc; ++cy)
    {
        // Copy however many mask bytes are on this scan line
        for (cx = 0; cx < cxSrcBytes; ++cx)
        {
            *pjDstAnd++ = *pjSrcAnd++;
            *pjDstXor++ = *pjSrcXor++;
        }

        // Point to next source and dest scans
        pjSrcAnd += lDeltaSrc;
        pjSrcXor += lDeltaSrc;
        pjDstAnd += lDeltaDst;
        pjDstXor += lDeltaDst;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bInitPointer
*
* Initialize the Cursor attributes.
*
\**************************************************************************/

BOOL bInitPointer(PPDEV ppdev)
{
    DWORD    returnedDataLength;
    ULONG    MaxWidthB, MaxHeight;

    ppdev->flCursor &= ~CURSOR_HW;  // assume there's no hardware pointer

    ppdev->pPointerAttributes = (PVIDEO_POINTER_ATTRIBUTES) NULL;

    // Ask the miniport whether it provides pointer support.
    // If it fails assume there is no hardware pointer.

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES,
                           NULL,
                           0,
                           &ppdev->PointerCapabilities,
                           sizeof(ppdev->PointerCapabilities),
                           &returnedDataLength))
    {
        // miniport does not support a hardware pointer.

        ppdev->PointerCapabilities.Flags = 0;
        ppdev->PointerCapabilities.MaxWidth = 0;
        ppdev->PointerCapabilities.MaxHeight = 0;
        ppdev->PointerCapabilities.HWPtrBitmapStart = 0;
        ppdev->PointerCapabilities.HWPtrBitmapEnd = 0;
    }

    // If neither mono nor color hardware pointer is supported, there's no
    // hardware pointer support and we're done.

    if ((!(ppdev->PointerCapabilities.Flags & VIDEO_MODE_MONO_POINTER)) &&
            (!(ppdev->PointerCapabilities.Flags & VIDEO_MODE_COLOR_POINTER)))
    {
        return(TRUE);
    }

    // It's a hardware pointer; set up pointer attributes.

    MaxHeight = ppdev->PointerCapabilities.MaxHeight;

    if (ppdev->PointerCapabilities.Flags & VIDEO_MODE_COLOR_POINTER)
    {
        // If color supported, allocate space for two 4-bpp DIBs (data/mask;
        // mask is actually 1-bpp, but it has the same width in bytes as the
        // data for convenience)

        // Width rounded up to nearest byte multiple
        MaxWidthB = (ppdev->PointerCapabilities.MaxWidth + 1) / 2;
    }
    else
    {
        // If color not supported, must be mono, allocate space for two 1-bpp
        // DIBs (data/mask).

        // Width rounded up to nearest byte multiple
        MaxWidthB = (ppdev->PointerCapabilities.MaxWidth + 7) / 8;
    }

    ppdev->cjPointerAttributes =
            sizeof(VIDEO_POINTER_ATTRIBUTES) +
            ((sizeof(UCHAR) * MaxWidthB * MaxHeight) * 2);

    ppdev->pPointerAttributes = (PVIDEO_POINTER_ATTRIBUTES)
            EngAllocMem(0, ppdev->cjPointerAttributes, ALLOC_TAG);

    if (ppdev->pPointerAttributes == NULL) {
        DISPDBG((0, "bInitPointer EngAllocMem failed\n"));
        return(FALSE);
    }

    ppdev->XorMaskStartOffset = MaxWidthB * MaxHeight;
    ppdev->pPointerAttributes->Flags = ppdev->PointerCapabilities.Flags;
    ppdev->pPointerAttributes->WidthInBytes = MaxWidthB;
    ppdev->pPointerAttributes->Width = ppdev->PointerCapabilities.MaxWidth;
    ppdev->pPointerAttributes->Height = MaxHeight;
    ppdev->pPointerAttributes->Column = 0;
    ppdev->pPointerAttributes->Row = 0;
    ppdev->pPointerAttributes->Enable = 0;


    // Set the asynchronous support status (async means miniport is capable of
    // drawing the cursor at any time, with no interference with any ongoing
    // drawing operation)

    if (ppdev->PointerCapabilities.Flags & VIDEO_MODE_ASYNC_POINTER)
    {
       ppdev->devinfo.flGraphicsCaps |= GCAPS_ASYNCMOVE;
    }
    else
    {
       ppdev->devinfo.flGraphicsCaps &= ~GCAPS_ASYNCMOVE;
    }

    // set flag in flCursor that says HW cursor is present and clear flag in
    // fl that says offscreen video memory is usable

    ppdev->flCursor |= CURSOR_HW;
    ppdev->fl &= ~DRIVER_OFFSCREEN_REFRESHED;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\debug.h ===
/***************************************************************************\
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\***************************************************************************/


#if DBG

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#define DISPDBG(arg) DebugPrint arg
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#define ASSERT(x, y) if (!(x)) RIP (y)

#else

#define DISPDBG(arg)
#define RIP(x)
#define ASSERT(x, y)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\driver.h ===
/******************************Module*Header*******************************\
* Module Name: driver.h
*
* driver prototypes
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "stddef.h"
#include <stdarg.h>
#include "windef.h"
#include "wingdi.h"
#include "winddi.h"
#include "devioctl.h"
#include "ntddvdeo.h"
#include "debug.h"
#include "winerror.h"

#include "brush.h"
/* gflDrv */

#define DRV_ENABLED_ONCE        0x00000001
#define DRV_ENABLED_PDEV        0x00000002


//
// A mode requires broken rasters if the stride is a power of 2 and the video ram
// accessed is greater than 64K.
//

#define POW2(stride) (!((stride) & ((stride)-1)))   // TRUE if stride is power of 2
#define BROKEN_RASTERS(stride,cy) ((!(POW2(stride))) && ((stride*cy) > 0x10000))

// # of bytes at end of display memory required for the pointer work and save
// areas
#define POINTER_WORK_AREA_SIZE   1024
#define POINTER_SAVE_AREA_SIZE   256

#define MIN_TEMP_BUFFER_SIZE    0x1000  // Minimum size of buffer used to
                                        //  build text (may be bigger because
                                        //  it's shared with blt buffer)

// Space required for working storage when working with banking on adapters
// that support only one window, with no independent read and write bank
// selection. The largest supported bank is 64K; this constant provides for
// storing four 64K planes.

#define BANK_BUFFER_PLANE_SIZE  0x10000
#define BANK_BUFFER_SIZE_1RW    (((ULONG)BANK_BUFFER_PLANE_SIZE)*4)
#define PLANE_0_OFFSET          0
#define PLANE_1_OFFSET          BANK_BUFFER_PLANE_SIZE
#define PLANE_2_OFFSET          (BANK_BUFFER_PLANE_SIZE*2)
#define PLANE_3_OFFSET          (BANK_BUFFER_PLANE_SIZE*3)

// Space required for working storage when working with banking on adapters
// that support one readable window and one writable window, but not two
// independently read/write addressable windows. This is space for storing
// one bank's worth of edge words for each of four planes, or for the text
// building buffer, whichever is larger.

#define BANK_MAX_HEIGHT 512     // tallest supported bank
#define BANK_BUFFER_SIZE_1R1W   (max((((ULONG)BANK_MAX_HEIGHT)*4*2), \
                                    MIN_TEMP_BUFFER_SIZE))

// On a 2RW or unbanked adapter, just make space for the text building buffer.
#define BANK_BUFFER_SIZE_UNBANKED MIN_TEMP_BUFFER_SIZE
#define BANK_BUFFER_SIZE_2RW      MIN_TEMP_BUFFER_SIZE

// !!! this will go away entirely, but for now don't waste the space
#define PREALLOC_SSB_SIZE   0x10

/* This device can have only one PDEV */

#define DRV_ONE_PDEV    1

//
// Check if drawing to DFB or screen (takes PDEVSURF name as param)
//

#define DRAW_TO_DFB(x)  ((x)->iFormat==BMF_DFB)
#define DRAW_TO_VGA(x)  ((x)->iFormat==BMF_PHYSDEVICE)

//
// Sizes assumed for 1-window and 2 RW-window banks.
//
#define BANK_SIZE_1_WINDOW      0x10000
#define BANK_SIZE_2RW_WINDOW    0x08000

//
// The following value allows us to set rounding for cursor exclusion.
//

#define POINTER_ROUNDING_SIZE 8

#define POINTER_ROUND (POINTER_ROUNDING_SIZE - 1)
#define POINTER_MASK  (-POINTER_ROUNDING_SIZE)

//
// Determines the size of the DriverExtra information in the DEVMODE
// structure passed to and from the display driver.
//

#define DRIVER_EXTRA_SIZE 0

#define DLL_NAME                L"vga"       // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "VGA: "      // All debug output is prefixed
#define ALLOC_TAG               'agvD'        // Four byte tag (characters in
                                              // reverse order) used for memory
                                              // allocations

//
// Miscellaneous driver flags in pdev.fl
// Must be mirrored in i386\driver.inc
//

// NOTE:  The driver currently will not use any offscreen memory if a hardware
//        cursor is used.

#define MAX_SCAN_WIDTH              2048   // pixels
#define DRIVER_OFFSCREEN_REFRESHED  0x04L  // if not set, don't use offscreen memory
#define PLANAR_PELS_PER_CPU_ADDRESS 8
#define PACKED_PELS_PER_CPU_ADDRESS 2

//
// General Rectangle Enumeration structure
//

#define ENUM_RECT_LIMIT   25

typedef struct _RECT_ENUM
{
    ULONG   c;
    RECTL   arcl[ENUM_RECT_LIMIT];
} RECT_ENUM;


/**************************************************************************\
*
* Descriptor for a saved screen bits block
*
\**************************************************************************/

typedef struct  _SAVED_SCREEN_BITS
{
    BOOL  bFlags;
    PBYTE pjBuffer;  // pointer to save buffer start
    ULONG ulSize;    // size of save buffer (per plane; display memory only)
    ULONG ulSaveWidthInBytes; // # of bytes across save area (including
                              //  partial edge bytes, if any)
    ULONG ulDelta;   // # of bytes from end of one saved scan's saved bits to
                     //  start of next (system memory only)
    PVOID pvNextSSB; // pointer to next saved screen bits block
                     // for system memory blocks, saved bits start immediately
                     //  after this structure
} SAVED_SCREEN_BITS, *PSAVED_SCREEN_BITS;
#define SSB_IN_PREALLOC_BUFFER  0x02    // true if block saved in preallocated
                                        //  buffer

/**************************************************************************\
*
* Bank clipping info
*
\**************************************************************************/

typedef struct {
    RECTL rclBankBounds;    // describes pixels addressable in this bank
    ULONG ulBankOffset;     // offset of bank start from bitmap start, if
                            // the bitmap were linearly addressable
} BANK_INFO, *PBANK_INFO;


/**************************************************************************\
*
* Bank control function vector
*
\**************************************************************************/

typedef VOID (*PFN_BankControl)(PDEVSURF, ULONG, BANK_JUST);


/**************************************************************************\
*
* Physical device description block
*
\**************************************************************************/

#define CURSOR_DOWN      0x00000001
#define CURSOR_COLOR     0x00000004
#define CURSOR_HW        0x00000010
#define CURSOR_HW_ACTIVE 0x00000020
#define CURSOR_ANIMATE   0x00000040

// The XYPAIR structure is used to allow ATOMIC read/write of the cursor
// position.  NEVER, NEVER, NEVER get or set the cursor position without
// doing this.  There is no semaphore protection of this data structure,
// nor will there ever be any. [donalds]

typedef struct  _XYPAIR
{
    USHORT  x;
    USHORT  y;
} XYPAIR;

// Must be mirrored in i386\strucs.inc

typedef struct  _PDEV
{
    FLONG   fl;                         // Driver flags (DRIVER_xxx)
    IDENT   ident;                      // Identifier
    HANDLE  hDriver;                    // Handle to the miniport
    HDEV    hdevEng;                    // Engine's handle to PDEV
    HSURF   hsurfEng;                   // Engine's handle to surface
    PVOID   pdsurf;                     // Associated surface
    SIZEL   sizlSurf;                   // Displayed size of the surface
    PBYTE   pjScreen;                   // Pointer to the frame buffer base
    XYPAIR  xyCursor;                   // Where the cursor should be
    POINTL  ptlExtent;                  // Cursor extent
    ULONG   cExtent;                    // Effective cursor extent.
    XYPAIR  xyHotSpot;                  // Cursor hot spot
    FLONG   flCursor;                   // Cursor status
    DEVINFO devinfo;                    // Device info
    GDIINFO GdiInfo;                    // Device capabilities
    ULONG   ulModeNum;                  // Mode index for current VGA mode
    PVIDEO_POINTER_ATTRIBUTES pPointerAttributes; // HW Pointer Attributes
    ULONG   XorMaskStartOffset;         // Start offset of hardware pointer
                                        //  XOR mask relative to AND mask for
                                        //  passing to HW pointer
    DWORD   cjPointerAttributes;        // Size of buffer allocated
    DWORD   flPreallocSSBBufferInUse;   // True if preallocated saved screen
                                        //  bits buffer is in use
    PUCHAR  pjPreallocSSBBuffer;        // Pointer to preallocated saved screen
                                        //  bits buffer, if there is one
    ULONG   ulPreallocSSBSize;          // Size of preallocated saved screen
                                        //  bits buffer
    HPALETTE hpalDefault;               // GDI handle to the default palette
    VIDEO_POINTER_CAPABILITIES PointerCapabilities; // HW pointer abilities
    PUCHAR  pucDIB4ToVGAConvBuffer;     // Pointer to DIB4->VGA conversion
                                        //  table buffer
    PUCHAR  pucDIB4ToVGAConvTables;     // Pointer to DIB4->VGA conversion
                                        //  table start in buffer (must be on a
                                        //  256-byte boundary)
// Saved screen bits stuff
    RECTL       rclSavedBitsRight;      // right rect of vga memory that's
                                        //  not visible
    RECTL       rclSavedBitsBottom;     // bottom rect of vga memory that's
                                        //  not visible
    BOOL        bBitsSaved;             // TRUE if bits are currently saved
    SIZEL       sizlMem;                // actual size (in pixels) of video memory
    LONG        cNumScansUsedByPointer; // # scans of offscreen memory used by
                                        //   software pointer code
    LPBYTE pPtrWork;                    // ptr to working buffer for cursor
    LPBYTE pPtrSave;                    // ptr to save buffer for cursor
} PDEV, *PPDEV;


/**************************************************************************\
*
* Specifies desired justification for requestion scan line within bank window
*
\**************************************************************************/

typedef enum {
    JustifyTop = 0,
    JustifyBottom,
} BANK_JUST;


/**************************************************************************\
*
* Specifies which window is to be mapped by two-window bank handler.
*
\**************************************************************************/

typedef enum {
    MapSourceBank = 0,
    MapDestBank,
} BANK_JUST;


/**************************************************************************\
*
* Definition of a surface as seen and used by the various VGA drivers
*
\**************************************************************************/

// Must be mirrored in i386\strucs.inc

typedef struct _DEVSURF                 /* dsurf */
{
    IDENT       ident;                  // Identifier for debugging ease
    ULONG       flSurf;                 // DS_ flags as defined below
    BYTE        iColor;                 // Solid color surface if DS_SOLIDBRUSH

// If DS_SOLIDBRUSH, the following fields are undefined and not guaranteed to
// have been allocated!

    BYTE        iFormat;                // BMF_*, BMF_PHYSDEVICE
    BYTE        jReserved1;             // Reserved
    BYTE        jReserved2;             // Reserved
    PPDEV       ppdev;                  // Pointer to associated PDEV
    SIZEL       sizlSurf;               // Size of the surface
    ULONG       lNextScan;              // Offset from scan  "n" to "n+1"
    ULONG       lNextPlane;             // Offset from plane "n" to "n+1"
    PVOID       pvScan0;                // Pointer to scan 0 of bitmap
                                        //  (actual address of start of bank,
                                        //  for banked VGA surface)
    PVOID       pvStart;                // Pointer to start of bitmap
    PVOID       pvConv;                 // Pointer to DIB/Planer conversion buffer
                                        // Banking variables; used only for
                                        //  banked VGA surfaces
    PVIDEO_BANK_SELECT pBankSelectInfo; // Pointer to bank select info
                                        //  returned by miniport
    ULONG       ulBank2RWSkip;          // Offset from one bank index to next
                                        //  to make two 32K banks appear to be
                                        //  one seamless 64K bank
    PFN         pfnBankSwitchCode;      // Pointer to bank switch code
    VIDEO_BANK_TYPE vbtBankingType;     // Type of banking
    ULONG       ulBitmapSize;           // Length of bitmap if there were no
                                        //  banking, in CPU addressable bytes
    ULONG       ulPtrBankScan;          // Last scan line in pointer work bank
    RECTL       rcl1WindowClip;         // Single-window banking clip rect
    RECTL       rcl2WindowClip[2];      // Double-window banking clip rects for
                                        //  windows 0 & 1
    ULONG       ulWindowBank[2];        // Current banks mapped into windows
                                        //  0 & 1 (used in 2 window mode only)
    PBANK_INFO  pbiBankInfo;            // Pointer to array of bank clip info
    ULONG       ulBankInfoLength;       // Length of pbiBankInfo, in entries
    PBANK_INFO  pbiBankInfo2RW;         // Same as above, but for 2RW window
    ULONG       ulBankInfo2RWLength;    // case
    PFN_BankControl pfnBankControl;     // Pointer to bank control function
    PFN_BankControl pfnBankControl2Window; // Pointer to double-window bank
                                        //  control function
    PVOID       pvBitmapStart;          // Single-window bitmap start pointer
                                        //  (adjusted as necessary to make
                                        //  window map in at proper offset)
    PVOID       pvBitmapStart2Window[2]; // Double-window window 0 and 1 bitmap
                                         // start
    PVOID       pvBankBufferPlane0;     // Pointer to temp buffer capable of
                                        //  storing one full bank for plane 0
                                        //  for 1 R/W case; capable of storing
                                        //  one full bank height of edge bytes
                                        //  for all four planes for the 1R/1W
                                        //  case. Also used to point to text
                                        //  building buffer in all cases
                                        // This is the pointer used to dealloc
                                        //  bank working storage for all four
                                        //  planes
                                        // The following 3 pointers used by
                                        //  1 R/W banked devices
    PVOID       pvBankBufferPlane1;     // Like above, but for plane 1
    PVOID       pvBankBufferPlane2;     // Like above, but for plane 2
    PVOID       pvBankBufferPlane3;     // Like above, but for plane 3
    ULONG       ulTempBufferSize;       // Full size of temp buffer pointed to
                                        //  by pvBankBufferPlane0

    ULONG       ajBits[1];              // Bits will start here for device bitmaps
    PSAVED_SCREEN_BITS ssbList;         // Pointer to start of linked list of
                                        //  saved screen bit blocks
} DEVSURF, * PDEVSURF;


// Identifier stored in ds.ident for debugging

#define PDEV_IDENT      ('V' + ('P' << 8) + ('D' << 16) + ('V' << 24))
#define DEVSURF_IDENT   ('V' + ('S' << 8) + ('R' << 16) + ('F' << 24))


// Definition of the BMF_PHYSDEVICE format type

#define BMF_PHYSDEVICE  0xFF
#define BMF_DFB         0xFE


// Defines for BLT target type

#define VGA_TARGET      0
#define DFB_TARGET      1
#define NO_TARGET       2


// Flags for flSurf

#define DS_SOLIDBRUSH   0x00000001      // Surface is a solid color representing a brush
#define DS_GREYBRUSH    0x00000002      // Surface is a grey color representing a brush
#define DS_BRUSH        0x00000004      // Surface is a brush
#define DS_DIB          0x00000008      // Surface is supporting an Engine DIB


// Describes a single color tetrahedron vertex for dithering

typedef struct _VERTEX_DATA {
    ULONG ulCount;  // # of pixels in this vertex
    ULONG ulVertex; // vertex #
} VERTEX_DATA;

extern BYTE gaajRealizedPat[HS_DDI_MAX][16];
extern BYTE gaajPat[HS_DDI_MAX][32];


/**************************************************************************\
*
* Function prototypes shared by all C files.
*
\**************************************************************************/


VOID vInitRegs(void);
BOOL bInitVGA(PPDEV, BOOL);
BOOL bInitPDEV(PPDEV, DEVMODEW *, GDIINFO *, DEVINFO *);
VOID vInitSavedBits(PPDEV);

DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION *, DWORD *);
typedef VOID (*PFN_ScreenToScreenBlt)(PDEVSURF, PRECTL, PPOINTL, INT);

VOID vDFBFILL(DEVSURF * pdsurfDst,ULONG cRect, RECTL * prclDst, ULONG junk, ULONG ulColor);
VOID vDFB2VGA(PDEVSURF pdsurfDst, PDEVSURF pdsurfSrc,
              RECTL * prclDst, POINTL * pptlSrc);
VOID vDFB2DFB(PDEVSURF pdsurfDst, PDEVSURF pdsurfSrc,
              RECTL * prclDst, POINTL * pptlSrc);
VOID vDFB2DIB(PDEVSURF pdsurfDst, PDEVSURF pdsurfSrc,
              RECTL * prclDst, POINTL * pptlSrc);

VOID vDIB2VGA(DEVSURF * pdsurfDst, DEVSURF * pdsurfSrc,
              RECTL * prclDst, POINTL * pptlSrc, UCHAR * pucConv, BOOL fDfbTrg);
BOOL DrvIntersectRect(PRECTL prcDst, PRECTL prcSrc1, PRECTL prcSrc2);
VOID vMonoPatBlt(PDEVSURF,ULONG,PRECTL,MIX, BRUSHINST *,PPOINTL);
VOID vClrPatBlt(PDEVSURF,ULONG,PRECTL,MIX, BRUSHINST *,PPOINTL);
VOID vClrPatDFB(PDEVSURF,ULONG,PRECTL,MIX, BRUSHINST *,PPOINTL);
VOID vTrgBlt(PDEVSURF,ULONG,PRECTL,MIX,ULONG);
VOID vAlignedSrcCopy(PDEVSURF,PRECTL,PPOINTL,INT);
VOID vNonAlignedSrcCopy(PDEVSURF,PRECTL,PPOINTL,INT);
VOID vDibToDev(PDEVSURF pdsurf, SURFOBJ *pso, PVOID pvConv);
VOID vConvertVGA2DIB(PDEVSURF, LONG, LONG, VOID *, LONG, LONG, ULONG, ULONG,
    LONG, ULONG, ULONG *);
BOOL SimCopyBits(SURFOBJ *psoTrg, SURFOBJ *psoSrc, CLIPOBJ *pco,
                 XLATEOBJ *pxlo, PRECTL prclTrg, PPOINTL pptlSrc);
VOID vConvertVGA2DIB(PDEVSURF, LONG, LONG, VOID *, LONG, LONG, ULONG, ULONG, LONG,
    ULONG, ULONG *);
BOOL bRleBlt(SURFOBJ *,SURFOBJ *, CLIPOBJ *, XLATEOBJ *, RECTL *, POINTL *);
VOID vSetDIB4ToVGATables(UCHAR *);
BOOL DrvFillPath (SURFOBJ *pso, PATHOBJ *ppo, CLIPOBJ *pco, BRUSHOBJ *pbo,
    POINTL *pptlBrush, MIX mix, FLONG flOptions);
VOID vClearMemDword(ULONG * pulBuffer, ULONG ulDwordCount);
VOID vForceBank0(PPDEV ppdev);
VERTEX_DATA * ComputeSubspaces(ULONG rgb, VERTEX_DATA *pvVertexData);
VOID vDitherColor(ULONG * pul, VERTEX_DATA * vVertexData,
    VERTEX_DATA * vVertexDataEnd, ULONG ulNumVertices);
ULONG CountColors(VOID *, ULONG, WORD *, DWORD);
BOOL bQuickPattern(BYTE *, ULONG);
BOOL bShrinkPattern(BYTE *, ULONG);
VOID vMono16Wide(DWORD *, DWORD *, DWORD);
VOID vMono8Wide(DWORD *, DWORD *, DWORD);
VOID vMono4Wide(DWORD *, DWORD *, DWORD);
VOID vMono2Wide(DWORD *, DWORD *, DWORD);
VOID vBrush2ColorToMono(BYTE *, BYTE *, DWORD, DWORD, BYTE);
VOID vConvert4BppToPlanar(BYTE *, BYTE *, DWORD, DWORD *);
VOID vConvert8BppToPlanar(BYTE *, BYTE *, DWORD, DWORD *);
VOID vCopyOrgBrush(BYTE   *pDest, BYTE   *pSrc, LONG   lScan, XLATEOBJ *pxlo);
SURFOBJ *DrvConvertBrush(SURFOBJ *psoPattern, HBITMAP *phbmTmp, XLATEOBJ *pxlo,
    ULONG cx, ULONG cy);
VOID vRealizeDitherPattern(BRUSHINST *pbri, ULONG RGBToDither);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\fillpath.c ===
/******************************Module*Header*******************************\
* Module Name: fillpath.c
*
* DrvFillPath
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

// LATER identify convex polygons and special-case?
// LATER identify vertical edges and special-case?
// LATER move pointed-to variables into automatics in search loops

#include "driver.h"
#include "bitblt.h"

// Maximum number of rects we'll fill per call to
// the fill code
#define MAX_PATH_RECTS  50  // 16 bytes per == 800 bytes
#define MAX_EDGES       50  // 40 bytes per == 2000 bytes

// Describe a single non-horizontal edge of a path to fill.
typedef struct _EDGE {
    PVOID pNext;
    INT iScansLeft;
    INT X;
    INT Y;
    INT iErrorTerm;
    INT iErrorAdjustUp;
    INT iErrorAdjustDown;
    INT iXWhole;
    INT iXDirection;
    INT iWindingDirection;
} EDGE, *PEDGE;

//MIX translation table. Translates a mix 1-16, into an old style Rop 0-255.
extern BYTE gaMix[];

VOID AdvanceAETEdges(EDGE *pAETHead);
VOID XSortAETEdges(EDGE *pAETHead);
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY);
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge, POINTFIX *ppfxEdgeStart,
        POINTFIX *ppfxEdgeEnd);
VOID ConstructGET(EDGE *pGETHead, EDGE *pFreeEdges, PATHOBJ *ppo,
        PATHDATA *pd, BOOL bMore);

/******************************Public*Routine******************************\
* DrvFillPath
*
* Fill the specified path with the specified brush and ROP.
*
\**************************************************************************/

BOOL DrvFillPath
(
    SURFOBJ  *pso,
    PATHOBJ  *ppo,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    MIX       mix,
    FLONG    flOptions
)
{
    ULONG iSolidColor;     // Solid color for solid brushes
    PDEVSURF pdsurf;
    BRUSHINST *pbri;       // Pointer to a brush instance
    BYTE jClipping;        // clipping type
    EDGE *pCurrentEdge;
    EDGE AETHead;          // dummy head/tail node & sentinel for Active Edge Table
    EDGE *pAETHead;        // pointer to AETHead
    EDGE GETHead;          // dummy head/tail node & sentinel for Global Edge Table
    EDGE *pGETHead;        // pointer to GETHead
    EDGE *pFreeEdges=NULL; // pointer to memory free for use to store edges
    ULONG ulNumRects;      // # of rectangles to draw currently in rectangle list
    RECTL *prclRects;      // pointer to start of rectangle draw list
    INT iCurrentY;         // scan line for which we're currently scanning out the
                           //  fill
    BOOL     bMore;
    PATHDATA pd;
    BOOL retval;
    RECTL aRectBuf[MAX_PATH_RECTS];

    VOID (*pfnFill)(PDEVSURF,ULONG,PRECTL,MIX,BRUSHINST*,PPOINTL);
    VOID (*pfnFillSolid)(PDEVSURF,ULONG,PRECTL,MIX,ULONG);


    // We don't handle ROP4s
    if ((mix & 0xFF) != ((mix >> 8) & 0xFF)) {
        return(FALSE);  // it's a ROP4; let GDI fill the path
    }

    pfnFillSolid = vTrgBlt;

    if (DRAW_TO_DFB((PDEVSURF)pso->dhsurf))
    {
        pfnFillSolid = vDFBFILL;
        switch (mix & 0xff)
        {
            case R2_NOP:
                return(TRUE);       // make sure this doesn't cause a punt!
            case R2_WHITE:
            case R2_BLACK:
                break;
            case R2_NOTCOPYPEN:
            case R2_COPYPEN:
                if (pbo->iSolidColor != 0xffffffff) {
                    break;          // solid color
                }
                //
                // WE ARE FALLING THROUGH BECAUSE PENS MUST BE SOLID!
                //
            default:
                return EngFillPath(pso, ppo, pco, pbo, pptlBrush, mix, flOptions);
        }
    }

    // The drawing surface
    pdsurf = (PDEVSURF) pso->dhsurf;

    // Is there clipping? We don't handle that
    // LATER handle rectangle clipping

    // Set up the clipping type
    if (pco == (CLIPOBJ *) NULL) {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    } else {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    if (jClipping != DC_TRIVIAL) {
        return(FALSE);  // there is clipping; let GDI fill the path
    }

    // There's nothing to do if there's only one point
    // LATER is this needed?
    if (ppo->cCurves <= 1) {
        return(TRUE);
    }

    // See if we can use the solid brush accelerators, or have to draw a
    // pattern

    mix &= 0xFF;

    ASSERT(mix != 0, "DrvFillPath: Mix was 0");

    switch (mix) {
        case R2_MASKNOTPEN:
        case R2_NOTCOPYPEN:
        case R2_XORPEN:
        case R2_MASKPEN:
        case R2_NOTXORPEN:
        case R2_MERGENOTPEN:
        case R2_COPYPEN:
        case R2_MERGEPEN:
        case R2_NOTMERGEPEN:
        case R2_MASKPENNOT:
        case R2_NOTMASKPEN:
        case R2_MERGEPENNOT:

            if (pbo->iSolidColor != 0xffffffff) {

                // Solid fill
                iSolidColor = pbo->iSolidColor;
                pbri = (BRUSHINST *)NULL;   // marks fill as solid

            } else {

                // We'll use our special case pattern code
                if (pbo->pvRbrush == (PVOID)NULL)
                {
                    pbri = (BRUSHINST *)BRUSHOBJ_pvGetRbrush(pbo);

                    if (pbri == (BRUSHINST *)NULL)
                        return(FALSE);          // couldn't realize the brush; let GDI
                                                //  fill the path
                }
                else
                {
                    pbri = (BRUSHINST *)pbo->pvRbrush;
                }

                // Handle color and mono patterns differently
                if (pbri->usStyle == BRI_MONO_PATTERN) {
                    pfnFill = vMonoPatBlt;
                } else {
                    pfnFill = vClrPatBlt;
                }

                // We only support non-8 wide brushes with R2_COPYPEN
                // LATER do we need to check for 16 wide for R2_COPYPEN?

                if ((mix != R2_COPYPEN) && (pbri->RealWidth != 8)) {
                    return(FALSE);          // not R2_COPYPEN and not 8 wide; let GDI
                                            //  fill the path
                }

                break;
            }

        // Rops that are implicit solid colors

        case R2_NOT:
        case R2_WHITE:
        case R2_BLACK:

            // Brush color parameter doesn't matter for these rops
            // LATER then why do we set it?
            iSolidColor = pbo->iSolidColor;
            pbri = (BRUSHINST *)NULL;   // marks fill as solid
            break;

        case R2_NOP:
            return(TRUE);
    }

    // set up working storage in the temporary buffer

    prclRects = aRectBuf; // storage for list of rectangles
                          //  to draw

    // enumerate path here first time  to  check  for  special
    // cases (rectangles,  single pixel and monotone polygons)

    // it is too difficult to  determine  interaction  between
    // multiple paths,   if there is more than one,  skip this

    if (! (bMore = PATHOBJ_bEnum(ppo, &pd))) {

        // if the count is less than three than it is at best a
        // line which means nothing gets drawn so get  out  now

        if (pd.count < 3) {
            return(TRUE);
        }

        // if the count is four, check to see if the polygon is
        // really a rectangle since we can really speed that up

        if (pd.count == 4) {
            prclRects = prclRects;

            // we have to start somewhere so assume that most
            // applications specify the top left point  first

            // we want to check that the first two points are
            // either vertically or horizontally aligned.  if
            // they are then we check that the last point [3]
            // is either horizontally or  vertically  aligned,
            // and finally that the 3rd point [2] is  aligned
            // with both the second point and the last  point

            // start by taking floor of the points  to  deter-
            // mine if the GIQ points are in the  same  pixel

#define FIX_SHIFT 4L
#define FIX_MASK (- (1L << FIX_SHIFT))

            prclRects->top   = pd.pptfx[0].y + 15 & FIX_MASK;
            prclRects->left  = pd.pptfx[0].x + 15 & FIX_MASK;
            prclRects->right = pd.pptfx[1].x + 15 & FIX_MASK;

            if (prclRects->left ^ prclRects->right) {
                if (prclRects->top  ^ (pd.pptfx[1].y + 15 & FIX_MASK))
                    goto not_rectangle;

                if (prclRects->left ^ (pd.pptfx[3].x + 15 & FIX_MASK))
                    goto not_rectangle;

                if (prclRects->right ^ (pd.pptfx[2].x + 15 & FIX_MASK))
                    goto not_rectangle;

                prclRects->bottom = pd.pptfx[2].y + 15 & FIX_MASK;
                if (prclRects->bottom ^ (pd.pptfx[3].y + 15 & FIX_MASK))
                    goto not_rectangle;

            } else {
                if (prclRects->top ^ (pd.pptfx[3].y + 15 & FIX_MASK))
                    goto not_rectangle;

                prclRects->bottom = pd.pptfx[1].y + 15 & FIX_MASK;
                if (prclRects->bottom ^ (pd.pptfx[2].y + 15 & FIX_MASK))
                    goto not_rectangle;

                prclRects->right = pd.pptfx[2].x + 15 & FIX_MASK;
                if (prclRects->right ^ (pd.pptfx[3].x + 15 & FIX_MASK))
                    goto not_rectangle;
            }

            // if the left is greater than the right then
            // swap them so the blt code doesn't wig  out

            if (prclRects->left > prclRects->right) {
                FIX temp;

                temp = prclRects->left;
                prclRects->left = prclRects->right;
                prclRects->right = temp;

            } else {

                // if left == right there's nothing to draw

                if (prclRects->left == prclRects->right) {
                    return(TRUE);
                }
            }

            // shift the values to get pixel coordinates

            prclRects->left  = prclRects->left  >> FIX_SHIFT;
            prclRects->right = prclRects->right >> FIX_SHIFT;

            if (prclRects->top > prclRects->bottom) {
                FIX temp;

                temp = prclRects->top;
                prclRects->top = prclRects->bottom;
                prclRects->bottom = temp;

            } else {
                if (prclRects->top == prclRects->bottom) {
                    return(TRUE);
                }
            }

            // shift the values to get pixel coordinates

            prclRects->top    = prclRects->top    >> FIX_SHIFT;
            prclRects->bottom = prclRects->bottom >> FIX_SHIFT;

            // if we get here then the polygon is a rectangle,
            // set count  to  1  and  goto  bottom to draw it

            ulNumRects = 1;
            goto draw_remaining_rectangles;
        }
    }

    //  if this is not one of the special cases then we find
    //  ourselves here and we scan convert by building edges

not_rectangle:

    pFreeEdges = (EDGE *) EngAllocMem(0, ppo->cCurves * sizeof(EDGE),
                                      ALLOC_TAG);

    if (pFreeEdges == (EDGE *) NULL)
    {
        return(FALSE);  // too many edges; let GDI fill the path
    }

    // Initialize an empty list of rectangles to fill
    ulNumRects = 0;

    // Enumerate the path edges and build a Global Edge Table (GET) from them
    // in YX-sorted order.
    pGETHead = &GETHead;
    ConstructGET(pGETHead, pFreeEdges, ppo, &pd, bMore);

    // Create an empty AET with the head node also a tail sentinel
    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;  // mark that the AET is empty
    AETHead.X = 0x7FFFFFFF;    // this is greater than any valid X value, so
                               //  searches will always terminate

    // Top scan of polygon is the top of the first edge we come to
    iCurrentY = ((EDGE *)GETHead.pNext)->Y;

    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out
    while (1) {

        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)
        if (AETHead.pNext != pAETHead) {
            AdvanceAETEdges(pAETHead);
        }

        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET
        if (AETHead.pNext == pAETHead) {
            if (GETHead.pNext == pGETHead) {
                // Done if there are no edges in either the AET or the GET
                break;
            }
            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET
            iCurrentY = ((EDGE *)GETHead.pNext)->Y;
        } else {
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)
            if (((EDGE *)AETHead.pNext)->pNext != pAETHead) {
                XSortAETEdges(pAETHead);
            }
        }

        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add
        if (((EDGE *)GETHead.pNext)->Y == iCurrentY) {
            MoveNewEdges(pGETHead, pAETHead, iCurrentY);
        }

        // Scan the AET into rectangles to fill (there's always at least one
        // edge pair in the AET)
        pCurrentEdge = AETHead.pNext;   // point to the first edge
        do {

            INT iLeftEdge;

            // The left edge of any given edge pair is easy to find; it's just
            // wherever we happen to be currently
            iLeftEdge = pCurrentEdge->X;

            // Find the matching right edge according to the current fill rule
            if ((flOptions & FP_WINDINGMODE) != 0) {

                INT iWindingCount;

                // Do winding fill; scan across until we've found equal numbers
                // of up and down edges
                iWindingCount = pCurrentEdge->iWindingDirection;
                do {
                    pCurrentEdge = pCurrentEdge->pNext;
                    iWindingCount += pCurrentEdge->iWindingDirection;
                } while (iWindingCount != 0);
            } else {
                // Odd-even fill; the next edge is the matching right edge
                pCurrentEdge = pCurrentEdge->pNext;
            }

            // See if the resulting span encompasses at least one pixel, and
            // add it to the list of rectangles to draw if so
            if (iLeftEdge < pCurrentEdge->X) {

                // We've got an edge pair to add to the list to be filled; see
                // if there's room for one more rectangle
                if (ulNumRects >= MAX_PATH_RECTS) {
                    // No more room; draw the rectangles in the list and reset
                    // it to empty
                    if (pbri == (BRUSHINST *)NULL)
                    {
                        (*pfnFillSolid)(pdsurf, ulNumRects, prclRects, mix,
                                iSolidColor);
                    }
                    else
                    {
                        (*pfnFill)(pdsurf, ulNumRects, prclRects, mix, pbri,
                                   pptlBrush);
                    }

                    // Reset the list to empty
                    ulNumRects = 0;
                }

                // Add the rectangle representing the current edge pair
                // LATER coalesce rectangles
                prclRects[ulNumRects].top = iCurrentY;
                prclRects[ulNumRects].bottom = iCurrentY+1;
                prclRects[ulNumRects].left = iLeftEdge;
                prclRects[ulNumRects].right = pCurrentEdge->X;
                ulNumRects++;
            }
        } while ((pCurrentEdge = pCurrentEdge->pNext) != pAETHead);

        iCurrentY++;    // next scan
    }

/* draw the remaining rectangles,  if there are any */

draw_remaining_rectangles:

    if (ulNumRects > 0) {
        if (pbri == (BRUSHINST *)NULL)
        {
            (*pfnFillSolid)(pdsurf, ulNumRects, prclRects, mix, iSolidColor);
        }
        else
        {
            (*pfnFill)(pdsurf, ulNumRects, prclRects, mix, pbri, pptlBrush);
        }
    }

    retval = TRUE;

    //
    // if you get to here, we may have allocated memory...
    //
    if (pFreeEdges) {

        //
        // we did allocate memory, so release it
        //

        EngFreeMem(pFreeEdges);
    }

    return(retval);   // done
}

// Advance the edges in the AET to the next scan, dropping any for which we've
// done all scans. Assumes there is at least one edge in the AET.
VOID AdvanceAETEdges(EDGE *pAETHead)
{
    EDGE *pLastEdge, *pCurrentEdge;

    pLastEdge = pAETHead;
    pCurrentEdge = pLastEdge->pNext;
    do {

        // Count down this edge's remaining scans
        if (--pCurrentEdge->iScansLeft == 0) {
            // We've done all scans for this edge; drop this edge from the AET
            pLastEdge->pNext = pCurrentEdge->pNext;
        } else {
            // Advance the edge's X coordinate for a 1-scan Y advance
            // Advance by the minimum amount
            pCurrentEdge->X += pCurrentEdge->iXWhole;
            // Advance the error term and see if we got one extra pixel this
            // time
            pCurrentEdge->iErrorTerm += pCurrentEdge->iErrorAdjustUp;
            if (pCurrentEdge->iErrorTerm >= 0) {
                // The error term turned over, so adjust the error term and
                // advance the extra pixel
                pCurrentEdge->iErrorTerm -= pCurrentEdge->iErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->iXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = pLastEdge->pNext) != pAETHead);
}

// X-sort the AET, because the edges may have moved around relative to
// one another when we advanced them. We'll use a multipass bubble
// sort, which is actually okay for this application because edges
// rarely move relative to one another, so we usually do just one pass.
// Also, this makes it easy to keep just a singly-linked list. Assumes there
// are at least two edges in the AET.
VOID XSortAETEdges(EDGE *pAETHead)
{
    BOOL bEdgesSwapped;
    EDGE *pLastEdge, *pCurrentEdge, *pNextEdge;

    do {

        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = pLastEdge->pNext;
        pNextEdge = pCurrentEdge->pNext;

        do {
            if (pNextEdge->X < pCurrentEdge->X) {

                // Next edge is to the left of the current edge; swap them
                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;
                pCurrentEdge = pNextEdge;   // continue sorting before the edge
                                            //  we just swapped; it might move
                                            //  farther yet
            }
            pLastEdge = pCurrentEdge;
            pCurrentEdge = pLastEdge->pNext;
        } while ((pNextEdge = pCurrentEdge->pNext) != pAETHead);
    } while (bEdgesSwapped);
}

// Moves all edges that start on the current scan from the GET to the AET in
// X-sorted order. Parameters are pointer to head of GET and pointer to dummy
// edge at head of AET, plus current scan line. Assumes there's at least one
// edge to be moved.
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY)
{
    EDGE *pCurrentEdge = pAETHead;
    EDGE *pGETNext = pGETHead->pNext;

    do {

        // Scan through the AET until the X-sorted insertion point for this
        // edge is found. We can continue from where the last search left
        // off because the edges in the GET are in X sorted order, as is
        // the AET. The search always terminates because the AET sentinel
        // is greater than any valid X
        while (pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X) {
            pCurrentEdge = pCurrentEdge->pNext;
        }

        // We've found the insertion point; add the GET edge to the AET, and
        // remove it from the GET
        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = pGETHead->pNext;

    } while (pGETNext->Y == iCurrentY);
}





// Build the Global Edge Table from the path. There must be enough memory in
// the free edge area to hold all edges. The GET is constructed in Y-X order,
// and has a head/tail/sentinel node at pGETHead.

VOID ConstructGET(
   EDGE     *pGETHead,
   EDGE     *pFreeEdges,
   PATHOBJ  *ppo,
   PATHDATA *ppd,
   BOOL      bMore)
{
    POINTFIX pfxPathStart;    // point that started the current subpath
    POINTFIX pfxPathPrevious; // point before the current point in a subpath;
                              //  starts the current edge

    // Create an empty GET with the head node also a tail sentinel

    pGETHead->pNext = pGETHead; // mark that the GET is empty
    pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                //  searches will always terminate

    // PATHOBJ_vEnumStart is implicitly  performed  by  engine
    // already and first path  is  enumerated  by  the  caller

next_subpath:

    // Make sure the PATHDATA is not empty (is this necessary)

    if (ppd->count != 0) {

        // If first point starts a subpath, remember it as such
        // and go on to the next point,   so we can get an edge

        if (ppd->flags & PD_BEGINSUBPATH) {

            // the first point starts the subpath;   remember it

            pfxPathStart    = *ppd->pptfx; // the subpath starts here
            pfxPathPrevious = *ppd->pptfx; // this points starts next edge
            ppd->pptfx++;                  // advance to the next point
            ppd->count--;                  // count off this point
        }

       // add edges in PATHDATA to GET,  in Y-X  sorted  order

        while (ppd->count--) {
            pFreeEdges =
                AddEdgeToGET(pGETHead, pFreeEdges,&pfxPathPrevious,ppd->pptfx);
            pfxPathPrevious = *ppd->pptfx; // current point becomes previous
            ppd->pptfx++;                  // advance to the next point
        }

     // If last point ends the subpath, insert the edge that
     // connects to first point   (is this built in already)

        if (ppd->flags & PD_ENDSUBPATH) {
            pFreeEdges = AddEdgeToGET
                (pGETHead, pFreeEdges, &pfxPathPrevious, &pfxPathStart);
        }
    }

    // the initial loop conditions preclude a do, while or for

    if (bMore) {
        bMore = PATHOBJ_bEnum(ppo, ppd);
        goto next_subpath;
    }
}

// Adds the edge described by the two passed-in points to the Global Edge
// Table, if the edge spans at least one pixel vertically.
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge,
        POINTFIX *ppfxEdgeStart, POINTFIX *ppfxEdgeEnd)
{
    INT iYStart, iYEnd, iXStart, iXEnd, iYHeight, iXWidth;

    // Set the winding-rule direction of the edge, and put the endpoints in
    // top-to-bottom order
    iYHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;
    if (iYHeight >= 0) {
        iXStart = ppfxEdgeStart->x;
        iYStart = ppfxEdgeStart->y;
        iXEnd = ppfxEdgeEnd->x;
        iYEnd = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = 1;
    } else {
        iYHeight = -iYHeight;
        iXEnd = ppfxEdgeStart->x;
        iYEnd = ppfxEdgeStart->y;
        iXStart = ppfxEdgeEnd->x;
        iYStart = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = -1;
    }

    // First pixel scan line (non-fractional GIQ Y coordinate) edge intersects.
    // Dividing by 16 with a shift is okay because Y is always positive
    pFreeEdge->Y = (iYStart + 15) >> 4;

    // Calculate the number of pixels spanned by this edge
    pFreeEdge->iScansLeft = ((iYEnd + 15) >> 4) - pFreeEdge->Y;
    if (pFreeEdge->iScansLeft <= 0) {
        return(pFreeEdge);  // no pixels at all are spanned, so we can ignore
                            //  this edge
    }

    // Set the error term and adjustment factors, all in GIQ coordinates for
    // now
    iXWidth = iXEnd - iXStart;
    if (iXWidth >= 0) {
        // Left to right, so we change X as soon as we move at all
        pFreeEdge->iXDirection = 1;
        pFreeEdge->iErrorTerm = -1;
    } else {
        // Right to left, so we don't change X until we've moved a full GIQ
        // coordinate
        iXWidth = -iXWidth;
        pFreeEdge->iXDirection = -1;
        pFreeEdge->iErrorTerm = -iYHeight;
    }

    if (iXWidth >= iYHeight) {
        // Calculate base run length (minimum distance advanced in X for a 1-
        // scan advance in Y)
        pFreeEdge->iXWhole = iXWidth / iYHeight;
        // Add sign back into base run length if going right to left
        if (pFreeEdge->iXDirection == -1) {
            pFreeEdge->iXWhole = -pFreeEdge->iXWhole;
        }
        pFreeEdge->iErrorAdjustUp = iXWidth % iYHeight;
    } else {
        // Base run length is 0, because line is closer to vertical than
        // horizontal
        pFreeEdge->iXWhole = 0;
        pFreeEdge->iErrorAdjustUp = iXWidth;
    }
    pFreeEdge->iErrorAdjustDown = iYHeight;

    // If the edge doesn't start on a pixel scan (that is, it starts at a
    // fractional GIQ coordinate), advance it to the first pixel scan it
    // intersects
    // LATER might be faster to use multiplication and division to jump ahead,
    // rather than looping
    while ((iYStart & 0x0F) != 0) {
        // Starts at a fractional GIQ coordinate, not exactly on a pixel scan

        // Advance the edge's GIQ X coordinate for a 1-GIQ-pixel Y advance
        // Advance by the minimum amount
        iXStart += pFreeEdge->iXWhole;
        // Advance the error term and see if we got one extra pixel this time
        pFreeEdge->iErrorTerm += pFreeEdge->iErrorAdjustUp;
        if (pFreeEdge->iErrorTerm >= 0) {
            // The error term turned over, so adjust the error term and
            // advance the extra pixel
            pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown;
            iXStart += pFreeEdge->iXDirection;
        }
        iYStart++;  // advance to the next GIQ Y coordinate
    }

    // Turn the calculations into pixel rather than GIQ calculations

    // Move the X coordinate to the nearest pixel, and adjust the error term
    // accordingly
    // Dividing by 16 with a shift is okay because X is always positive
    pFreeEdge->X = (iXStart + 15) >> 4; // convert from GIQ to pixel coordinates

    // LATER adjust only if needed (if prestepped above)?
    if (pFreeEdge->iXDirection == 1) {
        // Left to right
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                (((iXStart + 15) & ~0x0F) - iXStart);
    } else {
        // Right to left
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                ((iXStart - 1) & 0x0F);
    }

    // Scale the error adjusts up by 16 times, to move 16 GIQ pixels at a time.
    // Shifts work to do the multiplying because these values are always
    // non-negative
    pFreeEdge->iErrorAdjustUp <<= 4;
    pFreeEdge->iErrorAdjustDown <<= 4;

    // Insert the edge into the GET in YX-sorted order. The search always ends
    // because the GET has a sentinel with a greater-than-possible Y value
    while ((pFreeEdge->Y > ((EDGE *)pGETHead->pNext)->Y) ||
            ((pFreeEdge->Y == ((EDGE *)pGETHead->pNext)->Y) &&
            (pFreeEdge->X > ((EDGE *)pGETHead->pNext)->X))) {
        pGETHead = pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    return(++pFreeEdge);    // point to the next edge storage location for next
                            //  time
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\enable.c ===
/******************************Module*Header*******************************\
* Module Name: enable.c
*
* Functions to enable and disable the driver
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

extern GDIINFO gaulCap;             // in gdiinfo.c
extern LOGPALETTE logPalVGA;        // in gdiinfo.c
extern DEVINFO devinfoVGA;          // in gdiinfo.c

extern LPBYTE pPtrSave;
extern LPBYTE pPtrWork;

BOOL SetUpBanking(PDEVSURF, PPDEV);
BOOL bInitPointer(PPDEV);

extern ajConvertBuffer[1];            // Arbitrary sized array!

static  DRVFN   gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV             },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV           },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV            },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface          },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface         },
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush           },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap     },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap     },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt                 },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut                },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape        },
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer            },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath             },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits               },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor            },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode             },
    {   INDEX_DrvSaveScreenBits,        (PFN) DrvSaveScreenBits         },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes               },
    {   INDEX_DrvFillPath,              (PFN) DrvFillPath               },
    {   INDEX_DrvPaint,                 (PFN) DrvPaint                  }
};

/******************************Public*Routine******************************\
* BOOL bEnableDriver(iEngineVersion, cb, pded)
*
* Enables the driver by filling the function table.  This call is made by
* the Engine to fill its driver function table in the LDEV (Logical DEVice).
* This call should only be made once per driver but we can handle being
* called multiple times.
*
\**************************************************************************/

BOOL DrvEnableDriver
(
    ULONG           iEngineVersion,
    ULONG           cb,
    PDRVENABLEDATA  pded
)
{
    DISPDBG((2, "enabling Driver\n"));

    cb /= sizeof(ULONG);

    switch(cb)
    {
    case 3:
        pded->pdrvfn = gadrvfn;
    case 2:
        pded->c = sizeof(gadrvfn) / sizeof(DRVFN);
    case 1:
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Enable the Physical DEVice
*
* Warnings:
*   The PDEV isn't complete until bCompletePDEV is called.
*
\**************************************************************************/

DHPDEV DrvEnablePDEV
(
    DEVMODEW *pdrivw,
    PWSTR     pwszLogAddress,
    ULONG     cPatterns,
    HSURF    *ahsurfPatterns,
    ULONG     cjGdiInfo,
    ULONG    *pdevcaps,
    ULONG     cb,
    PDEVINFO  pdevinfo,
    HDEV      hdev,           // HDEV, used for callbacks
    PWSTR     pwszDeviceName,
    HANDLE    hDriver          // Handle to base driver
)
{
    PPDEV   ppdev;

    DISPDBG((2, "enabling PDEV\n"));

    //
    // Define flag to keep track of allocation
    //

    ppdev = (PPDEV) EngAllocMem(0, sizeof(PDEV), ALLOC_TAG);

    if (ppdev == NULL)
    {
        goto errorAllocPDEV;
    }


    memset(ppdev, 0, sizeof(PDEV));

    //
    // Identifier, for debugging purposes
    //

    ppdev->ident = PDEV_IDENT;

    //
    // Cache the device driver handle away for later use.
    //

    ppdev->hDriver = hDriver;

    //
    // Initialize the cursor stuff.  We can violate the atomic rule here
    // since nobody can talk to the driver yet.
    //

    ppdev->xyCursor.x = 320;            // Non-atomic
    ppdev->xyCursor.y = 240;            // Non-atomic

    ppdev->ptlExtent.x = 0;
    ppdev->ptlExtent.y = 0;
    ppdev->cExtent = 0;

    ppdev->flCursor = CURSOR_DOWN;

    //
    // Get the current screen mode information.  Set up device caps and devinfo.
    //

    if (!bInitPDEV(ppdev, pdrivw, &gaulCap, NULL))
    {
        DISPDBG((1, "DrvEnablePDEV failed bInitPDEV\n"));
        goto errorbInitPDEV;
    }

    cjGdiInfo=min(cjGdiInfo, sizeof(GDIINFO));

    memcpy(pdevcaps, &gaulCap, cjGdiInfo);

     // Now let's pass back the devinfo

    ppdev->hpalDefault = EngCreatePalette(PAL_INDEXED, 16,
                                              (PULONG) (logPalVGA.palPalEntry),
                                              0, 0, 0);

    if (ppdev->hpalDefault == (HPALETTE) 0)
    {
        goto errorEngCreatePalette;
    }

    *pdevinfo = devinfoVGA;

    pdevinfo->hpalDefault = ppdev->hpalDefault;

    // Try to preallocate a saved screen bits buffer. If we fail, set the flag
    // to indicate the buffer is in use, so that we'll never attempt to use it.
    // If we succeed, mark the buffer as free.

    if ((ppdev->pjPreallocSSBBuffer = (PUCHAR)
              EngAllocMem(0, PREALLOC_SSB_SIZE, ALLOC_TAG)) != NULL)
    {
        ppdev->flPreallocSSBBufferInUse = FALSE;
        ppdev->ulPreallocSSBSize = PREALLOC_SSB_SIZE;
    }
    else
    {
        ppdev->flPreallocSSBBufferInUse = TRUE;
    }

    // Fill in the DIB4->VGA conversion tables. Allow 256 extra bytes so that
    // we can always safely align the tables to a 256-byte boundary, for
    // look-up reasons. There are four tables, each 256 bytes long

    ppdev->pucDIB4ToVGAConvBuffer =
            (UCHAR *) EngAllocMem(0, (256*4+256)*sizeof(UCHAR), ALLOC_TAG);

    if (ppdev->pucDIB4ToVGAConvBuffer == NULL)
    {
        goto errorAllocpucDIB4ToVGAConvBuffer;
    }

    // Round the table start up to the nearest 256 byte boundary, because the
    // tables must start on 256-byte boundaries for look-up reasons

    ppdev->pucDIB4ToVGAConvTables =
            (UCHAR *) ((ULONG) (ppdev->pucDIB4ToVGAConvBuffer + 0xFF) & ~0xFF);

    vSetDIB4ToVGATables(ppdev->pucDIB4ToVGAConvTables);

    return((DHPDEV) ppdev);

errorAllocpucDIB4ToVGAConvBuffer:

    //
    // Free the preallocated saved screen bits buffer, if there is one.
    //

    if (ppdev->pjPreallocSSBBuffer != NULL)
    {
        EngFreeMem(ppdev->pjPreallocSSBBuffer);
    }

    EngDeletePalette(ppdev->hpalDefault);

errorEngCreatePalette:
errorbInitPDEV:

    EngFreeMem(ppdev);

errorAllocPDEV:

    return((DHPDEV) 0);

    UNREFERENCED_PARAMETER(cb);
    UNREFERENCED_PARAMETER(pwszLogAddress);
    UNREFERENCED_PARAMETER(pwszDeviceName);
}

/******************************Public*Routine******************************\
* BOOL bCompletePDEV(dhpdev, hpdev)
*
* Complete the initialization of the PDEV
*
\**************************************************************************/

VOID DrvCompletePDEV(
    DHPDEV dhpdev,
    HDEV  hdev)
{
    PPDEV   ppdev;

    ppdev = (PPDEV) dhpdev;

    ppdev->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* VOID DrvDisablePDEV(dhpdev)
*
* Shutdown this physical device.
*
* Warnings:
*   If a surface is still active for this PDEV it will be freed.
*

\**************************************************************************/

VOID DrvDisablePDEV(DHPDEV dhpdev)
{
    PPDEV   ppdev;

    ppdev = (PPDEV) dhpdev;

    DISPDBG((2, "disabling PDEV\n"));

    EngDeletePalette(ppdev->hpalDefault);

// Free the preallocated saved screen bits buffer, if there is one.

    if (ppdev->pjPreallocSSBBuffer != NULL)
    {
        EngFreeMem(ppdev->pjPreallocSSBBuffer);
    }

// Free the conversion table buffer

    if (ppdev->pucDIB4ToVGAConvBuffer != NULL)
    {
        EngFreeMem(ppdev->pucDIB4ToVGAConvBuffer);
    }

// Delete the PDEV

    EngFreeMem(dhpdev);

    DISPDBG((2, "disabled PDEV\n"));

}

/******************************Public*Routine******************************\
* HSURF DrvEnableSurface(dhpdev)
*
* Enable the surface for the device.  This will actually intialize the
* screen on the VGA.
*
* Warnings:
*   This routine should only be called ONCE per PDEV.
*
\**************************************************************************/

HSURF DrvEnableSurface(DHPDEV dhpdev)
{
    PPDEV    ppdev;
    PDEVSURF pdsurf;
    DHSURF   dhsurf;
    HSURF    hsurf;

    DISPDBG((2, "enabling Surface\n"));

    ppdev = (PPDEV) dhpdev;

    //
    // Initialize the VGA device into the selected mode which will also map
    // the video frame buffer
    //

    if (!bInitVGA(ppdev, TRUE))
    {
        goto error_done;
    }

    dhsurf = (DHSURF) EngAllocMem(0, sizeof(DEVSURF), ALLOC_TAG);

    if (dhsurf == (DHSURF) 0)
    {
        goto error_done;
    }

    pdsurf = (PDEVSURF) dhsurf;

    pdsurf->ident           = DEVSURF_IDENT;
    pdsurf->flSurf          = 0;
    pdsurf->iFormat         = BMF_PHYSDEVICE;
    pdsurf->jReserved1      = 0;
    pdsurf->jReserved2      = 0;
    pdsurf->ppdev           = ppdev;
    pdsurf->sizlSurf.cx     = ppdev->sizlSurf.cx;
    pdsurf->sizlSurf.cy     = ppdev->sizlSurf.cy;
    pdsurf->lNextPlane      = 0;
    pdsurf->pvScan0         = ppdev->pjScreen;
    pdsurf->pvBitmapStart   = ppdev->pjScreen;
    pdsurf->pvStart         = ppdev->pjScreen;
    pdsurf->pvConv          = &ajConvertBuffer[0];

    // Initialize pointer information.

    //
    // bInitPointer must be called before bInitSavedBits.
    //

    if (!bInitPointer(ppdev)) {
        DISPDBG((0, "DrvEnablePDEV failed bInitPointer\n"));
        goto error_clean;
    }

    if (!SetUpBanking(pdsurf, ppdev)) {
        DISPDBG((0, "DrvEnablePDEV failed SetUpBanking\n"));
        goto error_clean;
    }

    if ((hsurf = EngCreateDeviceSurface(dhsurf, ppdev->sizlSurf, BMF_4BPP)) ==
        (HSURF) 0)
    {
        DISPDBG((0, "DrvEnablePDEV failed EngCreateDeviceSurface\n"));
        goto error_clean;
    }

    //
    // vInitSavedBits must be called after bInitPointer.
    //

    vInitSavedBits(ppdev);

    if (EngAssociateSurface(hsurf, ppdev->hdevEng,
                        HOOK_BITBLT | HOOK_TEXTOUT | HOOK_STROKEPATH |
                        HOOK_COPYBITS | HOOK_PAINT | HOOK_FILLPATH
                        ))
    {
        ppdev->hsurfEng = hsurf;
        ppdev->pdsurf = pdsurf;

        // Set up an empty saved screen block list
        pdsurf->ssbList = NULL;

        DISPDBG((2, "enabled surface\n"));

        return(hsurf);
    }

    DISPDBG((0, "DrvEnablePDEV failed EngDeleteSurface\n"));
    EngDeleteSurface(hsurf);

error_clean:
    // We created the surface, so delete it
    EngFreeMem(dhsurf);

error_done:
    return((HSURF) 0);
}


/******************************Public*Routine******************************\
* DrvDisableSurface
*
* Free resources associated with this surface.
*
\**************************************************************************/

VOID DrvDisableSurface(DHPDEV dhpdev)
{
    PPDEV   ppdev = (PPDEV) dhpdev;
    PDEVSURF pdsurf = ppdev->pdsurf;
    PSAVED_SCREEN_BITS pSSB, pSSBNext;

    DISPDBG((2, "disabling surface\n"));

    // Free up banking-related stuff.
    EngFreeMem(pdsurf->pBankSelectInfo);

    if (pdsurf->pbiBankInfo != NULL) {
        EngFreeMem(pdsurf->pbiBankInfo);
    }

    if (pdsurf->pbiBankInfo2RW != NULL) {
        EngFreeMem(pdsurf->pbiBankInfo2RW);
    }

    if (pdsurf->pvBankBufferPlane0 != NULL) {
        EngFreeMem(pdsurf->pvBankBufferPlane0);
    }

    if (ppdev->pPointerAttributes != NULL) {
        EngFreeMem(ppdev->pPointerAttributes);
    }

    // Free any pending saved screen bit blocks.
    pSSB = pdsurf->ssbList;
    while (pSSB != (PSAVED_SCREEN_BITS) NULL) {

        //
        // Point to the next saved screen bits block
        //

        pSSBNext = (PSAVED_SCREEN_BITS) pSSB->pvNextSSB;

        //
        // Free the current block
        //

        EngFreeMem(pSSB);
        pSSB = pSSBNext;
    }

    EngDeleteSurface((HSURF) ppdev->hsurfEng);

    EngFreeMem(pdsurf);  // free the surface

    DISPDBG((2, "disabled surface\n"));

}

/******************************Public*Routine******************************\
* DrvAssertMode
*
* Ping the device back into its last known mode
*
\**************************************************************************/

BOOL DrvAssertMode(DHPDEV dhpdev, BOOL Enable)
{
    PPDEV   ppdev = (PPDEV) dhpdev;
    ULONG   returnedDataLength;

    DISPDBG((2, "DrvAssertMode\n"));

    if (Enable) {

        //
        // The screen must be reenabled since we had gone to full screen,
        // or another pdev.
        // Re-initialize the device.
        //

        pPtrSave = ppdev->pPtrSave;
        pPtrWork = ppdev->pPtrWork;

        if (!bInitVGA(ppdev, FALSE))
        {
            RIP("DrvAssertMode failed bInitVGA\n");
            return FALSE;
        }

        vForceBank0(ppdev);

        // Restore the off screen data.  This protects the Desktop
        // from a DOS application that might trash the off screen
        // memory.

        ppdev->bBitsSaved = FALSE;  // clear the DrvSaveScreenBits info flag
                                    // ie. blow away cached screen region

    } else {

        //
        // We must give up the display.
        // Call the kernel driver to reset the device to a known state.
        //

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_RESET_DEVICE,
                               NULL,
                               0,
                               NULL,
                               0,
                               &returnedDataLength))
        {
            RIP("Reset Device Failed");
            return FALSE;

        }
    }

    return TRUE;
}

/******************************Public*Routine******************************\
* DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE hDriver,
ULONG cjSize,
DEVMODEW *pdm)

{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation, pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    DISPDBG((2, "DrvGetModes\n"));

    cModes = getAvailableModes(hDriver,
                               (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                               &cbModeSize);

    if (cModes == 0)
    {
        DISPDBG((0, "DrvGetModes failed to get mode information"));
        return 0;
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the output
        // buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG)pdm) + sizeof(DEVMODEW) +
                                                   DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);

        } while (--cModes);
    }

    EngFreeMem(pVideoModeInformation);

    return cbOutputSize;

}

/******************************Public*Routine******************************\
* VOID vInitSavedBits(ppdev)
*
* Initializes saved bits structures.  Must be done after bank
* initialization and vInitBrushCache.
*
\**************************************************************************/

VOID vInitSavedBits(PPDEV ppdev)
{
    if (!(ppdev->fl & DRIVER_OFFSCREEN_REFRESHED))
    {
        return;
    }

    //
    // set up rect to right of visible screen
    //
    ppdev->rclSavedBitsRight.left   = ppdev->sizlSurf.cx;
    ppdev->rclSavedBitsRight.top    = 0;
    ppdev->rclSavedBitsRight.right  = ppdev->sizlMem.cx-PLANAR_PELS_PER_CPU_ADDRESS;
    ppdev->rclSavedBitsRight.bottom = ppdev->sizlSurf.cy;

    if ((ppdev->rclSavedBitsRight.right <= ppdev->rclSavedBitsRight.left) ||
        (ppdev->rclSavedBitsRight.bottom <= ppdev->rclSavedBitsRight.top))
    {
        ppdev->rclSavedBitsRight.left   = 0;
        ppdev->rclSavedBitsRight.top    = 0;
        ppdev->rclSavedBitsRight.right  = 0;
        ppdev->rclSavedBitsRight.bottom = 0;
    }

    //
    // set up rect below visible screen
    //
    ppdev->rclSavedBitsBottom.left   = 0;
    ppdev->rclSavedBitsBottom.top    = ppdev->sizlSurf.cy;
    ppdev->rclSavedBitsBottom.right  = ppdev->sizlMem.cx-PLANAR_PELS_PER_CPU_ADDRESS;
    ppdev->rclSavedBitsBottom.bottom = ppdev->sizlMem.cy - ppdev->cNumScansUsedByPointer;

    if ((ppdev->rclSavedBitsBottom.right <= ppdev->rclSavedBitsBottom.left) ||
        (ppdev->rclSavedBitsBottom.bottom <= ppdev->rclSavedBitsBottom.top))
    {
        ppdev->rclSavedBitsBottom.left   = 0;
        ppdev->rclSavedBitsBottom.top    = 0;
        ppdev->rclSavedBitsBottom.right  = 0;
        ppdev->rclSavedBitsBottom.bottom = 0;
    }

    DISPDBG((1,"rclSavedBitsRight: (%4x,%4x,%4x,%4x)\n",
               ppdev->rclSavedBitsRight.left,
               ppdev->rclSavedBitsRight.top,
               ppdev->rclSavedBitsRight.right,
               ppdev->rclSavedBitsRight.bottom
            ));

    DISPDBG((1,"rclSavedBitsBottom: (%4x,%4x,%4x,%4x)\n",
               ppdev->rclSavedBitsBottom.left,
               ppdev->rclSavedBitsBottom.top,
               ppdev->rclSavedBitsBottom.right,
               ppdev->rclSavedBitsBottom.bottom
            ));

    //
    // NOTE: we have subtracted one DWORD from the right edge.  This is because
    //       later it is assumed that we can align by right shifting by up to
    //       one DWORD (unless of course, the width of the buffer is 0).
    //

    ppdev->bBitsSaved = FALSE;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\gdiinfo.c ===
/******************************Module*Header*******************************\
* Module Name: gdiinfo.c
*
* This contains the static data structures in the VGA driver.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

/******************************Public*Data*Struct*************************\
* This contains the GDIINFO structure that contains the device capabilities
* which are passed to the NT GDI engine during dhpdevEnablePDEV.
*
\**************************************************************************/

GDIINFO gaulCap = {

     GDI_DRIVER_VERSION,
     DT_RASDISPLAY,         // ulTechnology
     0,                     // ulHorzSize
     0,                     // ulVertSize
     0,                     // ulHorzRes (filled in at initialization)
     0,                     // ulVertRes (filled in at initialization)
     4,                     // cBitsPixel
     1,                     // cPlanes
     16,                    // ulNumColors
     0,                     // flRaster (DDI reserved field)

     0,                     // ulLogPixelsX (filled in at initialization)
     0,                     // ulLogPixelsY (filled in at initialization)

     TC_RA_ABLE | TC_SCROLLBLT,  // flTextCaps

     6,                     // ulDACRed
     6,                     // ulDACGree
     6,                     // ulDACBlue

     0x0024,                // ulAspectX  (one-to-one aspect ratio)
     0x0024,                // ulAspectY
     0x0033,                // ulAspectXY

     1,                     // xStyleStep
     1,                     // yStyleSte;
     3,                     // denStyleStep

     { 0, 0 },              // ptlPhysOffset
     { 0, 0 },              // szlPhysSize

     0,                     // ulNumPalReg (win3.1 16 color drivers say 0 too)

// These fields are for halftone initialization.

     {                                          // ciDevice, ColorInfo
        { 6700, 3300, 0 },                      // Red
        { 2100, 7100, 0 },                      // Green
        { 1400,  800, 0 },                      // Blue
        { 1750, 3950, 0 },                      // Cyan
        { 4050, 2050, 0 },                      // Magenta
        { 4400, 5200, 0 },                      // Yellow
        { 3127, 3290, 0 },                      // AlignmentWhite
        20000,                                  // RedGamma
        20000,                                  // GreenGamma
        20000,                                  // BlueGamma
        0, 0, 0, 0, 0, 0
     },

     0,                      // ulDevicePelsDPI  (filled in at initialization)
     PRIMARY_ORDER_CBA,                         // ulPrimaryOrder
     HT_PATSIZE_4x4_M,                          // ulHTPatternSize
     HT_FORMAT_4BPP_IRGB,                       // ulHTOutputFormat
     HT_FLAG_ADDITIVE_PRIMS,                    // flHTFlags

     0,                                         // ulVRefresh
     8,                      // ulBltAlignment (preferred window alignment
                             //   for fast-text routines)
     0,                                         // ulPanningHorzRes
     0,                                         // ulPanningVertRes
};

/******************************Public*Data*Struct*************************\
* LOGPALETTE
*
* This is the palette for the VGA.
*
\**************************************************************************/

// Little bit of hacking to get this to compile happily.

typedef struct _VGALOGPALETTE
{
    USHORT ident;
    USHORT NumEntries;
    PALETTEENTRY palPalEntry[16];
} VGALOGPALETTE;

const VGALOGPALETTE logPalVGA =
{

0x400,  // driver version
16,     // num entries
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0x80,0x80,0x80,0 },       // 7

    { 0xC0,0xC0,0xC0,0 },       // 8
    { 0xFF,0,   0,   0 },       // 9
    { 0,   0xFF,0,   0 },       // 10
    { 0xFF,0xFF,0,   0 },       // 11
    { 0,   0,   0xFF,0 },       // 12
    { 0xFF,0,   0xFF,0 },       // 13
    { 0,   0xFF,0xFF,0 },       // 14
    { 0xFF,0xFF,0xFF,0 }        // 15
}
};


/******************************Public*Routine******************************\
* DEVINFO
*
* This is the devinfo structure passed back to the engine in DrvEnablePDEV
*
\**************************************************************************/

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_STROKE_PRECIS,PROOF_QUALITY,VARIABLE_PITCH | FF_DONTCARE,  L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_STROKE_PRECIS,PROOF_QUALITY,FIXED_PITCH | FF_DONTCARE,    L"Courier"}

DEVINFO devinfoVGA =
{
    (GCAPS_OPAQUERECT | GCAPS_HORIZSTRIKE | GCAPS_ALTERNATEFILL | GCAPS_MONO_DITHER | GCAPS_COLOR_DITHER |
     GCAPS_WINDINGFILL | GCAPS_DITHERONREALIZE
     ),       // Graphics capabilities

    SYSTM_LOGFONT,  // Default font description
    HELVE_LOGFONT,  // ANSI variable font description
    COURI_LOGFONT,  // ANSI fixed font description
    0,              // Count of device fonts
    BMF_4BPP,       // preferred DIB format
    8,              // Width of color dither
    8,              // Height of color dither
    0               // Default palette to use for this device
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\lines.h ===
/******************************Module*Header*******************************\
* Module Name: lines.h
*
* Line drawing constants and structures.
*
* NOTE: This file mirrors LINES.INC.  Changes here must be reflected in
* the .inc file!
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16
#define STYLE_MAX_VALUE     0x3fffL
#define RUN_MAX             20
#define STRIP_MAX           100
#define STYLE_DENSITY       3           // For VGA

// For the ROP table:

#define MIX_XOR_OFFSET      8

#define AND_ZERO            0L
#define AND_PEN             1L
#define AND_NOTPEN          2L
#define AND_ONE             3L

#define XOR_ZERO            (AND_ZERO   << MIX_XOR_OFFSET)
#define XOR_PEN             (AND_PEN    << MIX_XOR_OFFSET)
#define XOR_NOTPEN          (AND_NOTPEN << MIX_XOR_OFFSET)
#define XOR_ONE             (AND_ONE    << MIX_XOR_OFFSET)

// Flip and round flags:

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00008000L     // 1... .... .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_ARBITRARYSTYLED      0x00000400L     // .... .1.. .... ....
#define FL_MASKSTYLED           0x00000800L     // .... 1... .... ....
#define FL_STYLED              (FL_ARBITRARYSTYLED | FL_MASKSTYLED)
#define FL_ALTERNATESTYLED      0x00001000L     // ...1 .... .... ....

#define FL_STYLE_MASK           0x00000C00L
#define FL_STYLE_SHIFT          10

// Simpler flag bits in high byte:

#define FL_DONT_DO_HALF_FLIP    0x00002000L     // ..1. .... .... ....
#define FL_PHYSICAL_DEVICE      0x00004000L     // .1.. .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + F/2 - ((flRoundDown) > 0)) >> 4)
#define F                     16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (F - 1))

struct _STRIP;
struct _LINESTATE;

typedef VOID (*PFNSTRIP)(struct _STRIP*, struct _LINESTATE*, LONG*);

typedef struct _STRIP {

// Updated by strip drawers:

    BYTE*           pjScreen;       // Points to the first pixel of the line
    BYTE            jBitMask;       // Bit making for pixel in byte
    BYTE            jFiller1[3];    //   jBitMask sometimes treated as a ULONG
    BYTE            jStyleMask;     // Are we working on a gap in the style?
    BYTE            jFiller2[3];    //   jStyleMask sometimes treated as a ULONG

    STYLEPOS*       psp;            // Pointer to current style entry
    STYLEPOS        spRemaining;    // To go in current style

// Not modified by strip drawers:

    LONG            lNextScan;      // Signed increment to next scan
    LONG*           plStripEnd;     // Points one element past last strip
    LONG            flFlips;        // Indicates if line goes up or down
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    ULONG           ulBitmapROP;    // ROP info for DFBs
    ULONG           xyDensity;      // Density of style

// We leave room for a couple of extra dwords at the end of the strips
// array that can be used by the strip drawers:

    LONG            alStrips[STRIP_MAX + 2]; // Array of strips
} STRIP;

typedef struct _LINESTATE {

    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            ulStartMask;    // Determines if first element in style
                                    // array is for a gap or a dash

// Used for 2 pass ROPs and/or device-format bitmaps:

    PFNSTRIP*       apfnStrip;      // Actual strip table if doing 2-pass ROP
                                    // or a DFB

    ULONG           iColor;         // Color for 2nd pass of 2-pass ROP
                                    // or color index for DFB pen

    ULONG           ulVgaMode;      // VGA mode for 2nd pass of 2-pass ROP

    ULONG           ulDrawModeIndex;// Set to mix - 1
    ULONG           ulBitmapROP;    // ROP info for DFB strip drawer
    LONG            lNextPlane;     // Offset to next plane, same scan line

} LINESTATE;                    /* ls */

BOOL bLinesSimple(PDEVSURF, POINTFIX*, POINTFIX*, RUN* prun, ULONG, LINESTATE*,
                  RECTL*, PFNSTRIP*, FLONG);

BOOL bLines(PDEVSURF, POINTFIX*, POINTFIX*, RUN* prun, ULONG,
            LINESTATE*, RECTL*, PFNSTRIP*, FLONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\hardware.c ===
/******************************Module*Header*******************************\
* Module Name: hardware.c
*
* Hardware dependent initialization
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/


#include "driver.h"


/******************************Module*Header*******************************\
* Color tables
\**************************************************************************/

// Values for the internal, EGA-compatible palette.

static WORD PaletteBuffer[] = {

        16, // 16 entries
        0,  // start with first palette register

// On the VGA, the palette contains indices into the array of color DACs.
// Since we can program the DACs as we please, we'll just put all the indices
// down at the beginning of the DAC array (that is, pass pixel values through
// the internal palette unchanged).

        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
};


// These are the values for the first 16 DAC registers, the only ones we'll
// work with. These correspond to the RGB colors (6 bits for each primary, with
// the fourth entry unused) for pixel values 0-15.

static BYTE ColorBuffer[] = {

      16, // 16 entries
      0,
      0,
      0,  // start with first palette register
                0x00, 0x00, 0x00, 0x00, // black
                0x2A, 0x00, 0x15, 0x00, // red
                0x00, 0x2A, 0x15, 0x00, // green
                0x2A, 0x2A, 0x15, 0x00, // mustard/brown
                0x00, 0x00, 0x2A, 0x00, // blue
                0x2A, 0x15, 0x2A, 0x00, // magenta
                0x15, 0x2A, 0x2A, 0x00, // cyan
                0x21, 0x22, 0x23, 0x00, // dark gray   2A
                0x30, 0x31, 0x32, 0x00, // light gray  39
                0x3F, 0x00, 0x00, 0x00, // bright red
                0x00, 0x3F, 0x00, 0x00, // bright green
                0x3F, 0x3F, 0x00, 0x00, // bright yellow
                0x00, 0x00, 0x3F, 0x00, // bright blue
                0x3F, 0x00, 0x3F, 0x00, // bright magenta
                0x00, 0x3F, 0x3F, 0x00, // bright cyan
                0x3F, 0x3F, 0x3F, 0x00  // bright white
};

/******************************Public*Routine******************************\
* bInitPDEV
*
* Determine the mode we should be in based on the DEVMODE passed in.
* Query mini-port to get information needed to fill in the DevInfo and the
* GdiInfo .
*
\**************************************************************************/

BOOL bInitPDEV(
PPDEV ppdev,
DEVMODEW *pDevMode,
GDIINFO *pGdiInfo,
DEVINFO *pDevInfo)
{
    ULONG cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer, pVideoModeSelected, pVideoTemp;
    BOOL bSelectDefault;
    ULONG cbModeSize;

    //
    // calls the miniport to get mode information.
    //

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);

    if (cModes == 0)
    {
        DISPDBG((0, "no available modes\n"));
        return(FALSE);
    }

    //
    // Determine if we are looking for a default mode.
    //

    if ( ((pDevMode->dmPelsWidth) ||
          (pDevMode->dmPelsHeight) ||
          (pDevMode->dmBitsPerPel) ||
          (pDevMode->dmDisplayFlags) ||
          (pDevMode->dmDisplayFrequency)) == 0)
    {
        bSelectDefault = TRUE;
    }
    else
    {
        bSelectDefault = FALSE;
    }

    //
    // Now see if the requested mode has a match in that table.
    //

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    //
    // Note: Not all vga minports support the frequency field. Those
    // that do not support fill it in with zero. Also, if the registry
    // entry is set to 0, we will ignore the freq.
    //

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pDevMode->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pDevMode->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                    pVideoTemp->NumberOfPlanes  == pDevMode->dmBitsPerPel) &&
                 (pVideoTemp->Frequency  == pDevMode->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((1, "Found a match\n")) ;
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);
    }

    //
    // If no mode has been found, return an error
    //

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((0, "no valid modes\n"));

        EngFreeMem(pVideoBuffer);
        return(FALSE);
    }

    //
    // Save the mode number we selected
    //

    ppdev->ulModeNum = pVideoModeSelected->ModeIndex;

    //
    // Set the displayed surface dimensions from the DEVMODE
    //

    ppdev->sizlSurf.cx = pVideoModeSelected->VisScreenWidth;
    ppdev->sizlSurf.cy = pVideoModeSelected->VisScreenHeight;

    //
    // Set the GDI info that varies with resolution
    //

    pGdiInfo->ulHorzRes = pVideoModeSelected->VisScreenWidth;
    pGdiInfo->ulVertRes = pVideoModeSelected->VisScreenHeight;
    pGdiInfo->ulPanningHorzRes = pVideoModeSelected->VisScreenWidth;
    pGdiInfo->ulPanningVertRes = pVideoModeSelected->VisScreenHeight;
    pGdiInfo->ulHorzSize = pVideoModeSelected->XMillimeter;
    pGdiInfo->ulVertSize = pVideoModeSelected->YMillimeter;
    pGdiInfo->ulDevicePelsDPI = (pVideoModeSelected->VisScreenWidth * 254)/2400;

    pGdiInfo->ulVRefresh   = pVideoModeSelected->Frequency;

    pGdiInfo->ulLogPixelsX = pDevMode->dmLogPixels;
    pGdiInfo->ulLogPixelsY = pDevMode->dmLogPixels;

    if (!(pVideoModeSelected->AttributeFlags & VIDEO_MODE_NO_OFF_SCREEN))
    {
        ppdev->fl |= DRIVER_OFFSCREEN_REFRESHED;
    }

    EngFreeMem(pVideoBuffer);
    return TRUE;
}

/******************************Public*Routine******************************\
* PBYTE pjInitVGA(PPDEV ppdev)
*
* Initializes the VGA display to the mode specified in the ppdev
* If
*
\**************************************************************************/

BOOL bInitVGA(PPDEV ppdev, BOOL bFirst)
{
    VIDEO_MEMORY VideoMemory;
    VIDEO_MEMORY_INFORMATION VideoMemoryInfo;
    UINT ReturnedDataLength;

    //
    // Set the desired mode. (Must come before IOCTL_VIDEO_MAP_VIDEO_MEMORY;
    // that IOCTL returns information for the current mode, so there must be a
    // current mode for which to return information.)
    //

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SET_CURRENT_MODE,
                           &ppdev->ulModeNum,  // input buffer
                           sizeof(VIDEO_MODE),
                           NULL,
                           0,
                           &ReturnedDataLength)) {

        return(FALSE);

    }

    //
    // Set up the internal palette.
    //

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SET_PALETTE_REGISTERS,
                           (PVOID) PaletteBuffer, // input buffer
                           sizeof (PaletteBuffer),
                           NULL,    // output buffer
                           0,
                           &ReturnedDataLength)) {

        return(FALSE);

    }

    //
    // Set up the DAC.
    //

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SET_COLOR_REGISTERS,
                           (PVOID) ColorBuffer, // input buffer
                           sizeof (ColorBuffer),
                           NULL,    // output buffer
                           0,
                           &ReturnedDataLength)) {

        return(FALSE);

    }



    if (bFirst) {

        //
        // Map video memory into virtual memory.
        //

        VideoMemory.RequestedVirtualAddress = NULL;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                               (PVOID) &VideoMemory, // input buffer
                               sizeof (VIDEO_MEMORY),
                               (PVOID) &VideoMemoryInfo, // output buffer
                               sizeof (VideoMemoryInfo),
                               &ReturnedDataLength)) {

            RIP("Initialization error-Map buffer address");
            return (FALSE);

        }

        ppdev->pjScreen = VideoMemoryInfo.FrameBufferBase;

    }

    //
    // Initialize the VGA/EGA sequencer and graphics controller to their
    // default states, so that we can be sure of drawing properly even if the
    // miniport didn't happen to set these registers the way we like them.
    //

    vInitRegs();


    return(TRUE);
}


/******************************Public*Routine******************************\
* getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE hDriver,
PVIDEO_MODE_INFORMATION *modeInformation,
DWORD *cbModeSize)
{
    ULONG ulTemp;
    VIDEO_NUM_MODES modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //

    if (EngDeviceIoControl(hDriver,
                           IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
                           NULL,
                           0,
                           &modes,
                           sizeof(VIDEO_NUM_MODES),
                           &ulTemp))
    {
        DISPDBG((0, "getAvailableModes failed VIDEO_QUERY_NUM_AVAIL_MODES\n"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        EngAllocMem(0, modes.NumModes *
                                    modes.ModeInformationLength, ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes failed EngAllocMem\n"));

        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (EngDeviceIoControl(hDriver,
                           IOCTL_VIDEO_QUERY_AVAIL_MODES,
                           NULL,
                           0,
                           *modeInformation,
                           modes.NumModes * modes.ModeInformationLength,
                           &ulTemp))
    {

        DISPDBG((0, "getAvailableModes failed VIDEO_QUERY_AVAIL_MODES\n"));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not 4 planes, or not graphics, or is not
    // one of 1 bits per pel.
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 4 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
            (pVideoTemp->BitsPerPlane != 1) ||
            BROKEN_RASTERS(pVideoTemp->ScreenStride,
                            pVideoTemp->VisScreenHeight))

        {
            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return modes.NumModes;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\paint.c ===
/******************************Module*Header*******************************\
* Module Name: paint.c
*
* DrvPaint
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/
#include "driver.h"
#include "bitblt.h"

/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaMix[] =
{
    0xFF,  // R2_WHITE        - Allow rop = gaMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE
};

/******************************Public*Routine******************************\
* bPaintRgn
*
* Paint the clipping region with the specified color and mode
*
\**************************************************************************/

BOOL bPaintRgn
(
    SURFOBJ     *pso,
    CLIPOBJ     *pco,
    ULONG       iColor,
    MIX         mix,
    BRUSHINST   *pbri,
    POINTL      *pptlBrush,
    BOOL        bIsDFB
)
{
    RECT_ENUM   bben;
    PDEVSURF    pdsurf;
    BOOL        bMore;
    VOID        (*pfnPatBlt)(PDEVSURF,ULONG,PRECTL,MIX,BRUSHINST*,PPOINTL);
    VOID        (*pfnFillSolid)(PDEVSURF,ULONG,PRECTL,MIX,ULONG);

    if (bIsDFB) {
        pfnFillSolid = vDFBFILL;
    }
    else {
        pfnFillSolid = vTrgBlt;
    }

    if (pbri != (BRUSHINST *)NULL) {
        if (pbri->usStyle != BRI_MONO_PATTERN) {
            pfnPatBlt = vClrPatBlt;
        } else {
            pfnPatBlt = vMonoPatBlt;
        }
    }

    // Get the target surface information.
    pdsurf = (PDEVSURF) pso->dhsurf;

    switch(pco->iMode) {

        case TC_RECTANGLES:

            // Rectangular clipping can be handled without enumeration.
            // Note that trivial clipping is not possible, since the clipping
            // region defines the area to fill
            if (pco->iDComplexity == DC_RECT) {
                if (pbri == (BRUSHINST *)NULL)
                    (*pfnFillSolid)(pdsurf, 1, &pco->rclBounds, mix, iColor);
                else
                    (*pfnPatBlt)(pdsurf, 1, &pco->rclBounds, mix, pbri,pptlBrush);

            } else {

                // Enumerate all the rectangles and draw them

                CLIPOBJ_cEnumStart(pco,FALSE,CT_RECTANGLES,CD_ANY,ENUM_RECT_LIMIT);

                do {
                    bMore = CLIPOBJ_bEnum(pco, sizeof(bben), (PVOID) &bben);

                    if (pbri == (BRUSHINST *)NULL)
                        (*pfnFillSolid)(pdsurf, bben.c, &bben.arcl[0], mix, iColor);
                    else
                        (*pfnPatBlt)(pdsurf, bben.c, &bben.arcl[0], mix, pbri,
                                pptlBrush);

                } while (bMore);
            }

            return(TRUE);

        default:
            RIP("bPaintRgn: unhandled TC_xxx\n");
            return(FALSE);
    }
}


/******************************Public*Routine******************************\
* DrvPaint
*
* Paint the clipping region with the specified brush
*
\**************************************************************************/

BOOL DrvPaint
(
    SURFOBJ  *pso,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    MIX       mix
)
{
    ROP4        rop4;
    ULONG       iSolidColor;         // Solid color for solid brushes
    BRUSHINST   *pbri;               // Pointer to a brush instance
    BOOL        bIsDFB;

    pbri = (BRUSHINST *)NULL;
    iSolidColor = 0;

    bIsDFB = 0 ;

    if (DRAW_TO_DFB((PDEVSURF)pso->dhsurf))
    {
        bIsDFB = 1;
        switch (mix & 0xff) {
            case R2_WHITE:
            case R2_BLACK:
                break;
            case R2_NOTCOPYPEN:
            case R2_COPYPEN:
                if (pbo->iSolidColor != 0xffffffff) {
                    break;          // solid color
                }
                //
                // WE ARE FALLING THROUGH BECAUSE PENS MUST BE SOLID!
                //
            default:
                //
                // R2_NOP will be done by DrvBitBlt if mix is indeed not a rop4
                //
                goto punt;      // DFBs with other ROPs or non-solid
                                // brushes are punted to DrvBitBlt
        }
    }

    // If the foreground and background mixes are the same,
    // (LATER or if there's no brush mask)
    // then see if we can use the solid brush accelerators

    if ((mix & 0xFF) == ((mix >> 8) & 0xFF)) {

        switch (mix & 0xFF) {
            case 0:
                break;

            // vTrgBlt can only handle solid color fills where if the
            // destination is inverted, no other action is also required
            case R2_MASKNOTPEN:
            case R2_NOTCOPYPEN:
            case R2_XORPEN:
            case R2_MASKPEN:
            case R2_NOTXORPEN:
            case R2_MERGENOTPEN:
            case R2_COPYPEN:
            case R2_MERGEPEN:
            case R2_NOTMERGEPEN:
            case R2_MASKPENNOT:
            case R2_NOTMASKPEN:
            case R2_MERGEPENNOT:

                // vTrgBlt can only handle solid color fills

                if (pbo->iSolidColor != 0xffffffff)
                    iSolidColor = pbo->iSolidColor;

                else
                {
                    // TrgBlt can only handle solid brushes, but let's
                    // see if we can use our special case pattern code.
                    //
                    if (pbo->pvRbrush == (PVOID)NULL)
                    {
                        pbri = (BRUSHINST *)BRUSHOBJ_pvGetRbrush(pbo);

                        if (pbri == (BRUSHINST *)NULL)
                            break;
                    }
                    else
                    {
                        pbri = (BRUSHINST *)pbo->pvRbrush;
                    }

                    // We only support non-8 wide brushes with R2_COPYPEN

                    if (((mix & 0xFF) != R2_COPYPEN) && (pbri->RealWidth != 8))
                        break;

                }

            // Rops that are implicit solid colors

            case R2_NOT:
            case R2_WHITE:
            case R2_BLACK:

                // Brush color parameter doesn't matter for these rops

                return(bPaintRgn(pso, pco, iSolidColor, mix, pbri, pptlBrush, bIsDFB));

            case R2_NOP:
                return(TRUE);

            default:
                break;
        }
    }

punt:

    rop4  = (gaMix[(mix >> 8) & 0x0F]) << 8;
    rop4 |= ((ULONG) gaMix[mix & 0x0F]);

    return(DrvBitBlt(
        pso,
        (SURFOBJ *) NULL,
        (SURFOBJ *) NULL,
        pco,
        (XLATEOBJ *) NULL,
        &pco->rclBounds,
        (POINTL *)  NULL,
        (POINTL *)  NULL,
        pbo,
        pptlBrush,
        rop4));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\rleblt.c ===
/******************************Module*Header*******************************\
* Module Name: rleblt.c
*
* Blt from RLE format bitmap to VGA.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/
#include "driver.h"
#include "bitblt.h"

typedef struct _RLEINFO
{
    PBYTE   pjTrg;
    PBYTE   pjSrc;
    PBYTE   pjSrcEnd;
    PRECTL  prclClip;
    PULONG  pulXlate;
    LONG    xBegin;
    ULONG   lNextScan;         // Offset to the next scan line - DDB Only.
    ULONG   lNextPlane;        // Offset to the next plane     - DDB Only.
    PRECTL  prclTrg;
    DWORD   Format;
    PDEVSURF pdsurfTrg;
}RLEINFO, *PRLEINFO;

VOID vRle8ToVga(PRLEINFO);
VOID vRle4ToVga(PRLEINFO);
BOOL DrvIntersectRect(PRECTL, PRECTL, PRECTL);
typedef VOID (*PFN_RleToVga)(PRLEINFO);

/******************************Public*Routine******************************\
* BOOL bRleBlt(*psoTrg, *psoSrc, *pco, *pxlo, *prclTrg, *pptlSrc)
*
* Blt from RLE format bitmap to VGA.
*
\**************************************************************************/

BOOL bRleBlt
(
    SURFOBJ    *psoTrg,             // Target surface
    SURFOBJ    *psoSrc,             // Source surface
    CLIPOBJ    *pco,                // Clip through this
    XLATEOBJ   *pxlo,               // Color translation
    RECTL      *prclTrg,            // Target offset and extent
    POINTL     *pptlSrc             // Source offset
)
{
    BOOL        bMore;              // Clip continuation flag
    ULONG       ircl;               // Clip enumeration rectangle index
    RECT_ENUM   bben;               // Clip enumerator
    PFN_RleToVga pfnRleToVga;       // Pointer to either Rle8ToVga or Rle4ToVga

    PDEVSURF    pdsurf;
    RECTL       rclTrg;
    PDEV        *ppdevTrg;
    RLEINFO     rleInfo;
    PRECTL      prcl;               // Pointer to the current cliprect
    PRECTL      prclNext;           // Pointer to the next cliprect

    PBYTE       pjTrgTmp;           // For saving fields in rleInfo.
    PBYTE       pjSrcTmp;
    LONG        lTrgBottomTmp;
    LONG        xBeginTmp;
    ULONG       aulTriv[16];        // In case a null pxlo is passed in

    int         x;


// Get the target surface information.  This is guaranteed to be a device
// surface or a device format bitmap.

    pdsurf   = (PDEVSURF) psoTrg->dhsurf;
    ppdevTrg = pdsurf->ppdev;


// Get the source surface information.  Common to the screen and DFB's

    rleInfo.pjSrc = psoSrc->pvBits;
    rleInfo.pjSrcEnd = (PBYTE)(psoSrc->pvBits) + (psoSrc->cjBits);

// Determine if color translation is required.  If so, then get the color
// translation vector.

    if (!pxlo)
    {
        for (x = 0; x < 16; x++) aulTriv[x] = x;
        rleInfo.pulXlate = &aulTriv[0];
    }
    else
    {
        rleInfo.pulXlate = pxlo->pulXlate;
    }

// Enlarge the destination rectangle to include area that would have to be
// drawn if ptlSrc is (0, 0).

    rclTrg.left   = prclTrg->left - pptlSrc->x;
    rclTrg.top    = prclTrg->top;
    rclTrg.right  = prclTrg->right;
    rclTrg.bottom = prclTrg->top + psoSrc->sizlBitmap.cy - pptlSrc->y;

    rleInfo.prclTrg = &rclTrg;
    rleInfo.xBegin  = rclTrg.left;

// Calculate our starting address in the bitmap & get our blt function

    // First (bottom) dest scan, *exclusive*
    // Offset within bitmap of first (bottom) dest scan, *inclusive*
    rleInfo.pjTrg = (PBYTE) ((rclTrg.bottom - 1) * pdsurf->lNextScan);
    rleInfo.pdsurfTrg = pdsurf;
    if (psoSrc->iBitmapFormat == BMF_8RLE)
        pfnRleToVga = vRle8ToVga;
    else
        pfnRleToVga = vRle4ToVga;

// Everything is ready.  Let's go draw on the VGA.  Shooby Doobie Doo.  Whee.

    switch(pco->iDComplexity)
    {
    case DC_TRIVIAL:
        rleInfo.prclClip = prclTrg;
        pfnRleToVga(&rleInfo);
        break;

    case DC_RECT:
        rleInfo.prclClip = &pco->rclBounds;
        pfnRleToVga(&rleInfo);
        break;

    case DC_COMPLEX:
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTUP, ENUM_RECT_LIMIT);

        do
        {
        // Fill n slots with (n - 1) rectangles.

            bMore = CLIPOBJ_bEnum(pco,(ULONG) (sizeof(bben) - sizeof(RECT)),
                                  (PVOID) &bben);

        // Force save and restore rleInfo for the last rect.

            bben.arcl[bben.c].bottom = bben.arcl[bben.c - 1].bottom;

            for (ircl = 0; ircl < bben.c; ircl++)
            {
                prcl = &bben.arcl[ircl];

            // If the clipping rect is above the target rect, don't
            // enumerate any more clipprect.  Since the direction of
            // enumeration is bottom up, nothing is visible in new cliprect.

                if (prcl->bottom <= rleInfo.prclTrg->top)
                {
                    break;
                    bMore = FALSE;
                }

            // We check for NULL or inverted rectanges because we may get them.

                if ((prcl->top < prcl->bottom) && (prcl->left < prcl->right))
                {
                    rleInfo.prclClip = prcl;
                    prclNext = &bben.arcl[ircl + 1];

                    // Pass the same rleInfo for next cliprect if the next
                    // cliprect is on the same scan as the current cliprect

                    if (prcl->bottom == prclNext->bottom)
                    {
                    // save rleInfo.

                        pjTrgTmp = rleInfo.pjTrg;
                        pjSrcTmp = rleInfo.pjSrc;
                        lTrgBottomTmp = rleInfo.prclTrg->bottom;
                        xBeginTmp = rleInfo.xBegin;


                        pfnRleToVga(&rleInfo);

                    // restore rleinfo

                        rleInfo.pjTrg = pjTrgTmp;
                        rleInfo.pjSrc = pjSrcTmp;
                        rleInfo.prclTrg->bottom = lTrgBottomTmp;
                        rleInfo.xBegin = xBeginTmp;
                    }
                    else
                    {
                        pfnRleToVga(&rleInfo);
                    }
                }
            }
        } while(bMore);

        //DbgBreakPoint();

        break;

    default:
        RIP("ERROR bRleBlt invalid clip complexity\n");
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\textout.h ===
/******************************Module*Header*******************************\
* Module Name: textout.h
*
* include file for textout.c
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

// Various constants

#define MAX_GLYPH_HEIGHT 256

// Flags for flStr internally used by DrvTextOut()

#define TO_TARGET_SCREEN        0x00000001L // Output to screen
#define TO_NO_OPAQUE_RECT       0x00000002L // No opaque rectangle
#define TO_HORIZ_ALIGN_TEXT     0x00000004L // The string lies on one scanline
#define TO_NON_JUSTIFIED_TEXT   0x00000008L // The string is non-justified
#define TO_FIXED_PITCH          0x00000010L // Fixed-pitch glyphs
#define TO_MULTIPLE_BYTE        0x00000020L // Fixed-pitch multiple byte glyphs
#define TO_BYTE_ALIGNED         0x00000040L // byte-aligned string

// Flags for flOption--hints to vGlyphBlt() & vStrBlt()

#define VGB_HORIZ_CLIPPED_GLYPH 0x00000001L // The glyph is horizontally clipped
#define VGB_VERT_CLIPPED_GLYPH  0x00000002L // The glyph is vertically clipped
#define VGB_OPAQUE_BKGRND       0x00000004L // The opaque background glyphs
#define VGB_ENTIRE_STRING_BLT   0x00000008L // The entire string is bltted
#define VGB_FIXED_PITCH         0x00000010L // Fixed-pitch glyph
#define VGB_MULTIPLE_BYTE       0x00000020L // glyph is multiple byte fixed-pitch
#define VGB_BYTE_ALIGNED        0x00000040L // byte-aligned string

// Private Macros

#define BINVALIDRECT(rcl)   ((rcl.right <= rcl.left) || (rcl.bottom <= rcl.top))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\stroke.c ===
/******************************Module*Header*******************************\
* Module Name: Stroke.c
*
* DrvStrokePath for VGA driver
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

#include "lines.h"

// External calls

VOID vSetStrips(ULONG, ULONG);
VOID vClearStrips(ULONG);

#define MIN(A,B)    ((A) < (B) ? (A) : (B))

// Prototypes to go to the screen:

VOID vStripSolidHorizontal(STRIP*, LINESTATE*, LONG*);
VOID vStripSolidHorizontalSet(STRIP*, LINESTATE*, LONG*);
VOID vStripSolidVertical(STRIP*, LINESTATE*, LONG*);
VOID vStripSolidDiagonalHorizontal(STRIP*, LINESTATE*, LONG*);
VOID vStripSolidDiagonalVertical(STRIP*, LINESTATE*, LONG*);

VOID vStripStyledHorizontal(STRIP*, LINESTATE*, LONG*);
VOID vStripStyledVertical(STRIP*, LINESTATE*, LONG*);

VOID vStripMaskedHorizontal(STRIP*, LINESTATE*, LONG*);
VOID vStripMaskedVertical(STRIP*, LINESTATE*, LONG*);

PFNSTRIP gapfnStripSolidSet[] = {

// Special strip drawers for solid lines with SET style ROPs:

    vStripSolidHorizontalSet,
    vStripSolidVertical,
    vStripSolidDiagonalHorizontal,
    vStripSolidDiagonalVertical
};

PFNSTRIP gapfnStrip[] = {

// The order of these first 3 sets of strip drawers is determined by
// the FL_STYLE_MASK bits of the line flags:

    vStripSolidHorizontal,
    vStripSolidVertical,
    vStripSolidDiagonalHorizontal,
    vStripSolidDiagonalVertical,

    vStripStyledHorizontal,
    vStripStyledVertical,
    NULL,    // Diagonal goes here
    NULL,    // Diagonal goes here

    vStripMaskedHorizontal,
    vStripMaskedVertical,
    NULL,    // Diagonal goes here
    NULL,    // Diagonal goes here
};


STYLEPOS gaspAlternateStyle[] = { 1 };


// Prototypes to go to a device-format bitmap:

VOID vBitmapSolidHorizontal(STRIP*, LINESTATE*, LONG*);
VOID vBitmapSolidVertical(STRIP*, LINESTATE*, LONG*);
VOID vBitmapSolidDiagonal(STRIP*, LINESTATE*, LONG*);

VOID vBitmapStyledHorizontal(STRIP*, LINESTATE*, LONG*);
VOID vBitmapStyledVertical(STRIP*, LINESTATE*, LONG*);

VOID vCatchDFB(STRIP*, LINESTATE*, LONG*);

PFNSTRIP gapfnCatchDFB[] = {
    vCatchDFB,
    vCatchDFB,
    vCatchDFB,
    vCatchDFB
};

PFNSTRIP gapfnDFB[] = {
    vBitmapSolidHorizontal,
    vBitmapSolidVertical,
    vBitmapSolidDiagonal,
    vBitmapSolidDiagonal,

    vBitmapStyledHorizontal,
    vBitmapStyledVertical,
    NULL,   // Diagonal goes here
    NULL    // Diagonal goes here
};

// For two-pass ROPs:

VOID vCatchTwoPass(STRIP*, LINESTATE*, LONG*);

PFNSTRIP gapfnCatchTwoPass[] = {
    vCatchTwoPass,
    vCatchTwoPass,
    vCatchTwoPass,
    vCatchTwoPass
};

// VGA ulVgaMode constants:

#define DR_SET   0x00
#define DR_AND   0x08
#define DR_OR    0x10
#define DR_XOR   0x18

// Bit flag set if two passes needed:

#define DR_2PASS 0x80

// Table to convert ROP to usable information:

static struct {
    ULONG ulColorAnd;
    ULONG ulColorXor;
    ULONG ulVgaMode;
} arop[] = {
    {0x00, 0xff, DR_SET},          //  1   R2_WHITE
    {0x00, 0x00, DR_SET},          //  0   R2_BLACK
    {0xff, 0xff, DR_AND|DR_2PASS}, // DPon R2_NOTMERGEPEN   Dest invert + DPna
    {0xff, 0xff, DR_AND},          // DPna R2_MASKNOTPEN
    {0xff, 0xff, DR_SET},          // PN   R2_NOTCOPYPEN
    {0xff, 0x00, DR_AND|DR_2PASS}, // PDna R2_MASKPENNOT    Dest invert + DPa
    {0x00, 0xff, DR_XOR},          // Dn   R2_NOT           Invert dest without pen
    {0xff, 0x00, DR_XOR},          // DPx  R2_XORPEN
    {0xff, 0xff, DR_OR|DR_2PASS},  // DPan R2_NOTMASKPEN    Dest invert + DPno
    {0xff, 0x00, DR_AND},          // DPa  R2_MASKPEN
    {0xff, 0xff, DR_XOR},          // DPxn R2_NOTXORPEN     DPxn == DPnx
    {0x00, 0x00, DR_OR},           // D    R2_NOP           Silliness!
    {0xff, 0xff, DR_OR},           // DPno R2_MERGENOTPEN
    {0xff, 0x00, DR_SET},          // P    R2_COPYPEN
    {0xff, 0x00, DR_OR|DR_2PASS},  // PDno R2_MERGEPENNOT   Dest invert + DPo
    {0xff, 0x00, DR_OR},           // DPo  R2_MERGEPEN
};

// The gaulAndXorTable contains and-masks and xor-masks for setting
// pels to one of four possible values.	 The and-masks have been
// inverted, and are stored in the low byte of each word.  The
// xor-masks are stored in the high bytes.
//
//	ROP	XOR    ~AND
//	-------------------
//	DDx	00	FF	  Set to zero
//	Dn	FF	00	  Not destination
//	D	00	00	  Leave alone
//	DDxn	FF	FF	  Set to one

ULONG gaulAndXorTable[] = {
    0x00ff,     // Set to zero
    0xff00,     // Not destination
    0x0000,     // Leave alone
    0xffff      // Set to one
};

ULONG gaulInitMasksLtoR[] = { 0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f };
ULONG gaulInitMasksRtoL[] = { 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe };

/******************************Public*Routine******************************\
* BOOL DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrushOrg, pla, mix)
*
* Strokes the path.
*
\**************************************************************************/

BOOL DrvStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
LINEATTRS* pla,
MIX        mix)
{
    STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
    STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
    LINESTATE ls;
    PFNSTRIP* apfn;
    FLONG     fl;
    PDEVSURF  pdsurf;
    ULONG     ulVgaMode;

    UNREFERENCED_PARAMETER(pxo);
    UNREFERENCED_PARAMETER(pptlBrushOrg);

// Get the device ready:

    pdsurf = (PDEVSURF) pso->dhsurf;

    fl = 0;

// Look after styling initialization:

    if (pla->fl & LA_ALTERNATE)
    {
        ASSERT(pla->pstyle == (FLOAT_LONG*) NULL && pla->cstyle == 0,
               "DrvStrokePath: Non-empty style array for PS_ALTERNATE");

        ls.spNext       = HIWORD(pla->elStyleState.l) & 1;
                                                    // Light first pixel if
                                                    //   a multiple of 2

        ls.spTotal      = 1;                        // Sum of style array
        ls.spTotal2     = 2;                        // Twice the sum
        ls.xyDensity    = 1;                        // Each 'dot' is one
                                                    //   pixel long
                                                    
        if (pdsurf->iFormat == BMF_DFB)
        {
            fl |= (FL_ARBITRARYSTYLED);

            ls.cStyle  = 1;                         // Size of style array
            ls.aspRtoL = &gaspAlternateStyle[0];    // Right-to-left array
            ls.aspLtoR = &gaspAlternateStyle[0];    // Left-to-right array
            ls.ulStartMask = 0;                     // First pel is a dash
        }
        else
        {
            fl |= (FL_ALTERNATESTYLED | FL_MASKSTYLED);
        }
    }
    else if (pla->pstyle != (FLOAT_LONG*) NULL)
    {
        PFLOAT_LONG pstyle;

        pstyle = &pla->pstyle[pla->cstyle];

        ls.xyDensity = STYLE_DENSITY;
        ls.spTotal   = 0;
        while (pstyle-- > pla->pstyle)
        {
            ls.spTotal += pstyle->l;
        }
        ls.spTotal *= STYLE_DENSITY;
        ls.spTotal2 = 2 * ls.spTotal;

    // Compute starting style position (this is guaranteed not to overflow):

        ls.spNext = HIWORD(pla->elStyleState.l) * STYLE_DENSITY +
                    LOWORD(pla->elStyleState.l);

    // We optimize the style arrays that are even length and sum to 8.  We
    // also don't have any masked strip drawers for DFBs:

        if (ls.spTotal == (8 * STYLE_DENSITY) &&
            (pla->cstyle & 1) == 0            &&
            pdsurf->iFormat != BMF_DFB)
        {
        // Do "masked" styles.
        // -------------------
        //
        // This case is merely an optimization; you can remove it and
        // all style lines will still work.  It just so happens that the
        // default styles (such as PS_DOT, PS_DASHDOT, etc.) will all
        // sum to 8, and there are some optimizations we can do on the
        // VGA for that case.
        //
        // We make an 8 bit mask that represents each style unit in the
        // style array, and we pass this to the "Masked" strip drawers
        // (instead of calling the "Styled" strip drawers which still
        // handle the arbitrary styles).

            LONG ii;

            ls.ulStyleMaskLtoR = 0;
            ls.ulStyleMaskRtoL = 0;

            for (pstyle = pla->pstyle, ii = 8; ii > 0;)
            {
                LONG l1 = (pstyle++)->l;
                LONG l2 = (pstyle++)->l;

                ls.ulStyleMaskRtoL >>= l1 + l2;
                ls.ulStyleMaskRtoL |= gaulInitMasksRtoL[l2];

                ls.ulStyleMaskLtoR <<= l1 + l2;
                ls.ulStyleMaskLtoR |= gaulInitMasksLtoR[l2];

                ii -= (l1 + l2);
            }

        // Replicate byte and initialize to style position zero:

            ls.ulStyleMaskLtoR |= (ls.ulStyleMaskLtoR << 8);
            ls.ulStyleMaskLtoR |= (ls.ulStyleMaskLtoR << 16);

            ls.ulStyleMaskRtoL |= (ls.ulStyleMaskRtoL << 8);
            ls.ulStyleMaskRtoL |= (ls.ulStyleMaskRtoL << 16);

        // Check if we should start with a gap or start with a dash:

            if (pla->fl & LA_STARTGAP)
            {
                ls.ulStyleMaskLtoR = ~ls.ulStyleMaskLtoR;
                ls.ulStyleMaskRtoL = ~ls.ulStyleMaskRtoL;
            }

        // Initialize some other state:

            fl |= FL_MASKSTYLED;
        }
        else

    // Okay, we've got to do it the slow way:

        {
        // Handle Arbitrary Styles
        // -----------------------
        //
        // Because arbitrary styles are new to Win32, many apps won't
        // know about them and will use the default styles (which will
        // be handled by the "Masked" optimization case above), and so
        // this code path won't get exercised too often.  (See GDI's
        // ExtCreatePen API.)
        //
        // But you still have to handle them, and do them right!

            FLOAT_LONG* pstyle;
            STYLEPOS*   pspDown;
            STYLEPOS*   pspUp;

            fl        |= FL_ARBITRARYSTYLED;
            ls.cStyle  = pla->cstyle;
            ls.aspRtoL = aspRtoL;
            ls.aspLtoR = aspLtoR;

            if (pla->fl & LA_STARTGAP)
                ls.ulStartMask = 0xffffffffL;
            else
                ls.ulStartMask = 0L;

            pstyle  = pla->pstyle;
            pspDown = &ls.aspRtoL[ls.cStyle - 1];
            pspUp   = &ls.aspLtoR[0];

        // We always draw strips left-to-right, but styles have to be laid
        // down in the direction of the original line.  This means that in
        // the strip code we have to traverse the style array in the
        // opposite direction;

            while (pspDown >= &ls.aspRtoL[0])
            {
                *pspDown = pstyle->l * STYLE_DENSITY;
                *pspUp   = *pspDown;

                pspUp++;
                pspDown--;
                pstyle++;
            }
        }
    }

    if (pdsurf->iFormat == BMF_DFB)
    {
        ULONG iStripIndex;

    // Handle device-format bitmaps.

    // The table we give to the line routine will have all entries pointing
    // to the vCatchDFB function; it will intercept the strip draw call and
    // in turn break it into 4 calls to the appropriate DFB strip drawing
    // routines, once for each plane.

        apfn = gapfnCatchDFB;

        ls.ulDrawModeIndex = mix - 1;
        ls.lNextPlane      = pdsurf->lNextPlane;
        ls.iColor          = pbo->iSolidColor;

        iStripIndex        = 4 * ((fl & FL_ARBITRARYSTYLED) >> FL_STYLE_SHIFT);
        ls.apfnStrip       = &gapfnDFB[iStripIndex];

    }
    else
    {
        ULONG iColor;
        ULONG iStripIndex;

        fl |= FL_PHYSICAL_DEVICE;

    // Compute the pointer to the correct strip drawing table.  We
    // have a special table for solid lines done with VGA mode == SET:

        iStripIndex = 4 * ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT);
        apfn = &gapfnStrip[iStripIndex];

        mix &= 0xf;
        ulVgaMode = arop[mix].ulVgaMode;

        if (ulVgaMode == DR_SET && iStripIndex == 0)
            apfn = &gapfnStripSolidSet[0];

    // Compute the correct color, based on the ROP we're doing:

        iColor = (pbo->iSolidColor & arop[mix].ulColorAnd)
               ^ (arop[mix].ulColorXor);

        if (!(ulVgaMode & DR_2PASS))
            vSetStrips(iColor, ulVgaMode);
        else
        {
        // If the ROP requires 2 passes, we sneakily change our strip
        // table pointer to point to only our own routine, and it
        // handles calling the appropriate strip routines twice:

            ls.ulVgaMode = ulVgaMode ^ DR_2PASS;
            ls.iColor    = iColor;
            ls.apfnStrip = apfn;
            apfn         = gapfnCatchTwoPass;
        }
    }

// Set up to enumerate the path:

    if (pco->iDComplexity != DC_COMPLEX)
    {
        RECTL     arclClip[4];                   // For rectangular clipping
        PATHDATA  pd;
        RECTL*    prclClip = (RECTL*) NULL;
        BOOL      bMore;
        ULONG     cptfx;
        POINTFIX  ptfxStartFigure;
        POINTFIX  ptfxLast;
        POINTFIX* pptfxFirst;
        POINTFIX* pptfxBuf;

        if (pco->iDComplexity == DC_RECT)
        {
            fl |= FL_SIMPLE_CLIP;

            arclClip[0]        =  pco->rclBounds;

        // FL_FLIP_D:

            arclClip[1].top    =  pco->rclBounds.left;
            arclClip[1].left   =  pco->rclBounds.top;
            arclClip[1].bottom =  pco->rclBounds.right;
            arclClip[1].right  =  pco->rclBounds.bottom;

        // FL_FLIP_V:

            arclClip[2].top    = -pco->rclBounds.bottom + 1;
            arclClip[2].left   =  pco->rclBounds.left;
            arclClip[2].bottom = -pco->rclBounds.top + 1;
            arclClip[2].right  =  pco->rclBounds.right;

        // FL_FLIP_V | FL_FLIP_D:

            arclClip[3].top    =  pco->rclBounds.left;
            arclClip[3].left   = -pco->rclBounds.bottom + 1;
            arclClip[3].bottom =  pco->rclBounds.right;
            arclClip[3].right  = -pco->rclBounds.top + 1;

            prclClip = arclClip;
        }

        PATHOBJ_vEnumStart(ppo);

        do {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            cptfx = pd.count;
            if (cptfx == 0)
            {
                break;
            }

            if (pd.flags & PD_BEGINSUBPATH)
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                cptfx--;
            }
            else
            {
                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;
            }

            if (pd.flags & PD_RESETSTYLE)
                ls.spNext = 0;

        // We have to check for cptfx == 0 because the only point in the
        // subpath may have been the StartFigure point:

            if (cptfx > 0)
            {
                if (!bLines(pdsurf,
                            pptfxFirst,
                            pptfxBuf,
                            (RUN*) NULL,
                            cptfx,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                    return(FALSE);
            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if (pd.flags & PD_CLOSEFIGURE)
            {
                if (!bLines(pdsurf,
                            &ptfxLast,
                            &ptfxStartFigure,
                            (RUN*) NULL,
                            1,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                    return(FALSE);
            }
        } while (bMore);

        if (fl & FL_STYLED)
        {
        // Save the style state:

            ULONG ulHigh;
            ULONG ulLow;

        // !!! The engine handles unnormalized style states.  This can
        // !!! be removed.  Might have to remove some asserts in the
        // !!! engine.

        // Masked styles don't normalize the style state.  It's a good
        // thing to do, so let's do it now:

            if ((ULONG) ls.spNext >= (ULONG) ls.spTotal2)
                ls.spNext = (ULONG) ls.spNext % (ULONG) ls.spTotal2;

            ulHigh = ls.spNext / ls.xyDensity;
            ulLow  = ls.spNext % ls.xyDensity;

            pla->elStyleState.l = MAKELONG(ulLow, ulHigh);
        }
    }
    else
    {
    // Local state for path enumeration:

        BOOL bMore;
        union {
            BYTE     aj[offsetof(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
            CLIPLINE cl;
        } cl;

        fl |= FL_COMPLEX_CLIP;

    // We use the clip object when non-simple clipping is involved:

        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

        do {
            bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
            if (cl.cl.c != 0)
            {
                if (fl & FL_STYLED)
                {
                    ls.spComplex = HIWORD(cl.cl.lStyleState) * ls.xyDensity
                                 + LOWORD(cl.cl.lStyleState);
                }
                if (!bLines(pdsurf,
                            &cl.cl.ptfxA,
                            &cl.cl.ptfxB,
                            &cl.cl.arun[0],
                            cl.cl.c,
                            &ls,
                            (RECTL*) NULL,
                            apfn,
                            fl))
                    return(FALSE);
            }
        } while (bMore);
    }

    if (fl & FL_PHYSICAL_DEVICE)
        vClearStrips(ulVgaMode);

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vCatchTwoPass(pstrip, pls, plStripEnd)
*
* Handles ROPs that cannot be done in a single pass using the VGA
* hardware.  In order not to have a check in our main drawing loop for
* two-pass ROPs, we change the strip function table so that this function
* intercepts the call to draw the strips.
*
* This routine then figures out the appropriate actual strip drawer, and
* makes two calls to it: first to invert the destination, then to do the
* rest of the ROP.
*
\**************************************************************************/

VOID vCatchTwoPass(STRIP* pstrip, LINESTATE* pls, LONG* plStripEnd)
{
    BYTE*     pjScreen    = pstrip->pjScreen;
    BYTE      jBitMask    = pstrip->jBitMask;
    BYTE      jStyleMask  = pstrip->jStyleMask;
    STYLEPOS* psp         = pstrip->psp;
    STYLEPOS  spRemaining = pstrip->spRemaining;

// Figure out the actual strip routine we're supposed to call:

    PFNSTRIP pfn = pls->apfnStrip[(pstrip->flFlips & FL_STRIP_MASK) >>
                                  FL_STRIP_SHIFT];

// On the first pass, we invert the destination:

    vSetStrips(0xff, DR_XOR);

    (*pfn)(pstrip, pls, plStripEnd);

// We reset our strip variables for the second pass and handle the rest
// of the ROP:

    pstrip->pjScreen    = pjScreen;
    pstrip->jBitMask    = jBitMask;
    pstrip->jStyleMask  = jStyleMask;
    pstrip->psp         = psp;
    pstrip->spRemaining = spRemaining;

    vSetStrips(pls->iColor, pls->ulVgaMode);

    (*pfn)(pstrip, pls, plStripEnd);
}

/******************************Public*Routine******************************\
* VOID vCatchDFB(pstrip, pls, plStripEnd)
*
* Intercepts the strip draw call and in turn breaks it into 4 calls
* to the appropriate DFB strip drawing routines, once for each plane.
*
\**************************************************************************/

VOID vCatchDFB(STRIP* pstrip, LINESTATE* pls, LONG* plStripEnd)
{
    BYTE*     pjScreen    = pstrip->pjScreen;
    BYTE      jBitMask    = pstrip->jBitMask;
    BYTE      jStyleMask  = pstrip->jStyleMask;
    STYLEPOS* psp         = pstrip->psp;
    STYLEPOS  spRemaining = pstrip->spRemaining;

    BYTE*     pjScreenNextPass;
    LONG      lNextPlane = pls->lNextPlane;
    ULONG     ulPen0     = gaulAndXorTable[
                                (pls->ulDrawModeIndex) & 3];
    ULONG     ulPen1     = gaulAndXorTable[
                                (pls->ulDrawModeIndex >> 2) & 3];

// Figure out the actual strip routine we're supposed to call:

    PFNSTRIP  pfn = pls->apfnStrip[(pstrip->flFlips & FL_STRIP_MASK) >>
                                  FL_STRIP_SHIFT];

    pstrip->ulBitmapROP = (pls->iColor & 1) ? ulPen1 : ulPen0;
    (*pfn)(pstrip, pls, plStripEnd);        // Plane 0
    pjScreenNextPass = pstrip->pjScreen;

    pstrip->ulBitmapROP = (pls->iColor & 2) ? ulPen1 : ulPen0;
    pjScreen += lNextPlane;
    pstrip->pjScreen    = pjScreen;
    pstrip->jBitMask    = jBitMask;
    pstrip->jStyleMask  = jStyleMask;
    pstrip->psp         = psp;
    pstrip->spRemaining = spRemaining;
    (*pfn)(pstrip, pls, plStripEnd);        // Plane 1

    pstrip->ulBitmapROP = (pls->iColor & 4) ? ulPen1 : ulPen0;
    pjScreen += lNextPlane;
    pstrip->pjScreen    = pjScreen;
    pstrip->jBitMask    = jBitMask;
    pstrip->jStyleMask  = jStyleMask;
    pstrip->psp         = psp;
    pstrip->spRemaining = spRemaining;
    (*pfn)(pstrip, pls, plStripEnd);        // Plane 2

    pstrip->ulBitmapROP = (pls->iColor & 8) ? ulPen1 : ulPen0;
    pjScreen += lNextPlane;
    pstrip->pjScreen    = pjScreen;
    pstrip->jBitMask    = jBitMask;
    pstrip->jStyleMask  = jStyleMask;
    pstrip->psp         = psp;
    pstrip->spRemaining = spRemaining;
    (*pfn)(pstrip, pls, plStripEnd);        // Plane 3

    pstrip->pjScreen = pjScreenNextPass;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\savescr.c ===
/******************************Module*Header*******************************\
* Module Name: savescr.c                                                   *
*                                                                          *
* DrvSaveScreenBits                                                        *
*                                                                          *
* Copyright (c) 1992-1995 Microsoft Corporation                            *
\**************************************************************************/


#include <driver.h>

// This is just a unique ID that the driver will recongize.  Hopefully,
// nothing will ever call with this ID by pure chance.  We need something that
// can't possibly be a result of one of the Allocs done by the driver for
// the saves to system memory, and it can't be 0 (which indicates failure).

#define     SAVED_OFFSCREEN_ID      ((ULONG)-1)

ULONG
ulSaveOrRestoreBits(
    SURFOBJ *,
    PPDEV,
    RECTL *,
    BOOL);

VOID
vRestoreScreenBitsFromMemory(
   PDEVSURF pdsurf,
   PRECTL prcl,
   PBYTE pjSrcBuffer,
   ULONG ulRestoreWidthInBytes,
   ULONG ulSrcDelta
   );

VOID
vSaveScreenBitsToMemory(
   PDEVSURF pdsurf,
   PRECTL prcl,
   PVOID pjDestBuffer,
   ULONG ulSaveWidthInBytes,
   ULONG ulSaveHeight,
   ULONG ulDestScanWidth
   );


/******************************Public*Routine******************************\
* DrvSaveScreenBits(pso,iMode,iIdent,prcl)                                 *
*                                                                          *
* Saves and restores the specified area of the screen                      *
*                                                                          *
\**************************************************************************/

ULONG DrvSaveScreenBits(SURFOBJ *pso, ULONG iMode, ULONG iIdent, RECTL *prcl)
{
    PDEVSURF pdsurf;
    PPDEV ppdev;
    PSAVED_SCREEN_BITS pSSB, *pLastSSBPtr, pSSBTemp;
    BOOL bIdentFound;
    ULONG ulSaveSize, ulSaveHeight;
    ULONG ulSaveWidthInBytes, ulSaveWidthInAlignedBytes;
    ULONG ulRet;

    pdsurf = (PDEVSURF) pso->dhsurf;
    ppdev = pdsurf->ppdev;  // find the PDEV that goes with this surface

    //
    // Save, restore, or free a block of screen bits.
    //

    switch(iMode)
    {
        //
        // Save a block of screen bits.
        //

        case SS_SAVE:
            if ((ppdev->fl & DRIVER_OFFSCREEN_REFRESHED) && !ppdev->bBitsSaved)
            {
                //
                // Save bits to offscreen memory.
                //

                ulRet = ulSaveOrRestoreBits(pso, ppdev, prcl, TRUE);
                if (ulRet)
                {
                    ppdev->bBitsSaved = TRUE;
                    return(ulRet);
                }

                //
                // If you get to here, save to offscreen failed.  Maybe the
                // region was too large.  Anyway, fall through to the code
                // which saves to system memory.
                //
            }

            //
            // For one reason or another, the offscreen memory cannot be used.
            //

            // Figure out how big the save area will be
            ulSaveHeight = prcl->bottom - prcl->top;
            ulSaveWidthInBytes =
                    ((ULONG)((prcl->right + 7) - (prcl->left & ~0x07))) >> 3;

            // Not enough offscreen memory; store in system memory.
            // Calculate new buffer width, allowing for padding so we can
            // dword align
            ulSaveWidthInAlignedBytes =
                (((ULONG)((prcl->right + 31) - (prcl->left & ~0x1F)))
                              >> 5) << 2;

            // # of bytes to hold all 4 planes of save rect in memory
            ulSaveSize = ((ulSaveHeight * ulSaveWidthInAlignedBytes) << 2)
                    + sizeof(SAVED_SCREEN_BITS);

            // If the preallocated saved screen bits buffer is free and big
            // enough to handle this save, we'll use that
            if ((ppdev->flPreallocSSBBufferInUse == FALSE) &&
                (ulSaveSize <= ppdev->ulPreallocSSBSize))
            {
                // Save in preallocated buffer

                pSSB = (PSAVED_SCREEN_BITS) ppdev->pjPreallocSSBBuffer;

                // Mark that we're saving in the preallocated buffer
                pSSB->bFlags = SSB_IN_PREALLOC_BUFFER;

                // Make sure no other screen bits save tries to use the
                //  buffer
                ppdev->flPreallocSSBBufferInUse = TRUE;
            }
            else
            {
                // Save in system memory buffer

                // Allocate a structure to contain the save info and the
                // save buffer (four planes' worth)
                //

                pSSB = (PSAVED_SCREEN_BITS) EngAllocMem(0, ulSaveSize, ALLOC_TAG);

                if (pSSB == NULL)
                {
                    // Couldn't get memory, so fail this call
                    return((ULONG)0);
                }

                // Mark that we're not saving in display memory
                pSSB->bFlags = 0;
            }

            // Start address at which to save, accounting for
            // the number of bytes by which to pad on the left to dword
            // align (assumes each scan line starts dword aligned, which is
            // true in 640, 800, and 1024 wide cases)
            pSSB->pjBuffer = ((PBYTE) pSSB) + sizeof(SAVED_SCREEN_BITS) +
                             ((prcl->left >> 3) & 0x03);

            pSSB->ulSaveWidthInBytes = ulSaveWidthInBytes;

            // Distance from end of one scan to start of next (number of
            // padding bytes for dword alignment purposes)
            pSSB->ulDelta =
                    ulSaveWidthInAlignedBytes - pSSB->ulSaveWidthInBytes;

            // Save the rectangle to system memory
            vSaveScreenBitsToMemory(pdsurf,
                                    prcl,
                                    pSSB->pjBuffer,
                                    pSSB->ulSaveWidthInBytes,
                                    ulSaveHeight,
                                    ulSaveWidthInAlignedBytes);

            // Link the new saved screen bits block into the list
            pSSB->pvNextSSB = pdsurf->ssbList;
            pdsurf->ssbList = pSSB;

            return((ULONG) pSSB);

        //
        // Restore a saved screen bits block to the screen, then free it.
        //

        case SS_RESTORE:
            if (iIdent == SAVED_OFFSCREEN_ID)
            {
                if (!ppdev->bBitsSaved)
                {
                    //
                    // We must have blown the offscreen cache
                    //
                    return(FALSE);
                }

                ppdev->bBitsSaved = FALSE;  // successful or not, destroy the bits
                if (!ulSaveOrRestoreBits(pso, ppdev, prcl, FALSE))
                {
                    RIP("DrvSaveScreenBits (restore): restore failed\n");
                }
                return(TRUE);
            }

            // Point to the first block in the saved screen bits list
            pSSB = pdsurf->ssbList;

            // Try to find the specified saved screen bits block
            bIdentFound = FALSE;
            while ((pSSB != (PSAVED_SCREEN_BITS) NULL) && !bIdentFound)
            {
                if (pSSB == (PSAVED_SCREEN_BITS) iIdent)
                {

                    // Handle copies from offscreen memory and system memory
                    // separately
                    vRestoreScreenBitsFromMemory(pdsurf,
                                                 prcl,
                                                 pSSB->pjBuffer,
                                                 pSSB->ulSaveWidthInBytes,
                                                 pSSB->ulDelta);

                    bIdentFound = TRUE;
                }
                else
                {
                    // Not a match, so check another block, if there is one.
                    // Point to the next saved screen bits block
                    pSSB = (PSAVED_SCREEN_BITS) pSSB->pvNextSSB;
                }
            }

            // See if we succeeded in finding a block to restore
            if (!bIdentFound)
            {
                // It was a bad identifier, so we'll return failure

                DISPDBG((0, "DrvSaveScreenBits SS_RESTORE invalid iIdent"));
                return(FALSE);
            }

            // Always free the saved screen bits block after restoring it

        //
        // Free up the saved screen bits block.
        //

        case SS_FREE:
            if (iIdent == SAVED_OFFSCREEN_ID)
            {
                ppdev->bBitsSaved = FALSE;
                return(TRUE);
            }

            // Point to the first block in the saved screen bits list
            pSSB = pdsurf->ssbList;

            // Point to the pointer to the first block, so we can unlink the
            // first block if it's the one we're freeing
            pLastSSBPtr = &pdsurf->ssbList;

            // Try to find the specified saved screen bits block
            while (pSSB != (PSAVED_SCREEN_BITS) NULL)
            {
                if (pSSB == (PSAVED_SCREEN_BITS) iIdent)
                {
                    // It's a match; free up this block

                    // Unlink the block from the list
                    *pLastSSBPtr = (PSAVED_SCREEN_BITS) pSSB->pvNextSSB;

                    if (pSSB->bFlags & SSB_IN_PREALLOC_BUFFER)
                    {
                        // If the block's save area is in the preallocated
                        // buffer, mark that the buffer is no longer in use
                        // and is free for reuse
                        ppdev->flPreallocSSBBufferInUse = FALSE;

                        // We're done; there's nothing to free up
                        return(TRUE);
                    }

                    // Deallocate the block's memory
                    EngFreeMem(pSSB);

                    // We've successfully freed the block
                    return(TRUE);
                }

                // Not a match, so check another block, if there is one
                // Remember the block that points to the block we're advancing
                // to, for unlinking later
                pLastSSBPtr = (PSAVED_SCREEN_BITS *) &pSSB->pvNextSSB;

                // Point to the next saved screen bits block
                pSSB = (PSAVED_SCREEN_BITS) pSSB->pvNextSSB;
            }

            // It was a bad identifier, so we'll do nothing. We won't return
            // FALSE because SS_FREE always returns TRUE

            DISPDBG((0, "DrvSaveScreenBits SS_FREE invalid iIdent"));

            return(TRUE);

        //
        // An unknown mode was passed in.
        //

        default:
            DISPDBG((0, "DrvSaveScreenBits invalid iMode"));

            return(FALSE);
            break;
    }
}


/******************************Public*Routine******************************\
* vCopyRects(pso,ppdev,prclSrc,prclTrg,cxPad,bIsSave)                      *
*                                                                          *
* Breaks prclSrc up and copies the parts into prclTrg                      *
*                                                                          *
\**************************************************************************/

VOID vCopyRects(SURFOBJ *pso, PPDEV ppdev, RECTL * prclSrc, RECTL * prclTrg,
                LONG cxPad,  BOOL bIsSave)
{
    RECTL rclOnScreen;
    RECTL rclOffScreen;
    POINTL * pptlSrcTmp;
    RECTL * prclTrgTmp;
    ULONG cx, cy;
    ULONG cAlign;

    // We are assuming here that either the Trg is wider than the Src, or
    // the Trg is taller than the src.

    // We are assuming that if there is a nonzero cxPad, we are copying to
    // a rectangle such that the src is taller than the dst.
    // In other words, the prclTrg is a rectangle in the bottom offscreen
    // memory region, and the prclSrc needs to be broken up.

    ASSERT(cxPad == 0 ||
           (prclSrc->bottom - prclSrc->top > prclTrg->bottom - prclTrg->top),
           "DrvSaveScreenBits: vCopyRects - cxPad is invalid\n");

    // Make sure that the src and trg are dword aligned.

    cAlign = (((prclSrc->left) - (prclTrg->left)) & (PLANAR_PELS_PER_CPU_ADDRESS - 1));

    if ((prclSrc->right - prclSrc->left) > prclTrg->right - prclTrg->left)
    {
        if ((prclSrc->bottom - prclSrc->top) >= prclTrg->bottom - prclTrg->top)
        {
            RIP("DrvSaveScreenBits: vCopyRects src is bigger than trg\n");
        }

        //
        // we need to break it up into vertical strips
        //

        cx = prclTrg->right - prclTrg->left;
        cy = prclSrc->bottom - prclSrc->top;

        ASSERT(cx != 0, "DrvSaveScreenBits: vCopyRects (v save width == 0)\n");
        ASSERT(cy != 0, "DrvSaveScreenBits: vCopyRects (v save height == 0)\n");

        rclOnScreen.right  = prclSrc->left;
        rclOnScreen.top    = prclSrc->top;
        rclOnScreen.bottom = prclSrc->top + cy;

        rclOffScreen.left  = prclTrg->left;
        rclOffScreen.bottom = prclTrg->top;

        // align offscreen rect to src

        rclOffScreen.left += cAlign;

        /* variable used before being initialized */
        // rclOffScreen.right += cAlign;

        while (rclOnScreen.right < prclSrc->right)
        {
            cx = min(cx,(ULONG)(prclSrc->right - rclOnScreen.right));
            ASSERT(cx != 0, "DrvSaveScreenBits: vCopyRects (cx == 0)\n");
            rclOnScreen.left = rclOnScreen.right;
            rclOnScreen.right += cx;
            rclOffScreen.right = rclOffScreen.left + cx; // in case cx is thinner
                                                         //   on last strip
            rclOffScreen.top = rclOffScreen.bottom;
            rclOffScreen.bottom += cy;

            if (rclOffScreen.bottom > prclTrg->bottom)
            {
                RIP("DrvSaveScreenBits: "
                    "vCopyRects can't fit src into trg (vertical)\n");
            }

            if (bIsSave)
            {
                // save
                pptlSrcTmp = (POINTL *) &rclOnScreen;
                prclTrgTmp = &rclOffScreen;

                DISPDBG((1,"DrvSaveScreenBits (v save):    "));
            }
            else
            {
                // restore
                pptlSrcTmp = (POINTL *) &rclOffScreen;
                prclTrgTmp = &rclOnScreen;

                DISPDBG((1,"DrvSaveScreenBits (v restore): "));
            }

            DISPDBG((1,"%08x,%08x,%08x,%08x    %lux%lu\n",
                    rclOffScreen.left,
                    rclOffScreen.top,
                    rclOffScreen.right,
                    rclOffScreen.bottom,
                    rclOffScreen.right - rclOffScreen.left,
                    rclOffScreen.bottom - rclOffScreen.top
                    ));

            ASSERT(((prclTrgTmp->left ^ pptlSrcTmp->x) &
                    (PLANAR_PELS_PER_CPU_ADDRESS - 1)) == 0,
                   "DrvSaveScreenBits (v): Src and Target are not aligned\n");

            DrvCopyBits(pso,                // psoDst   (screen)
                        pso,                // psoSrc   (screen)
                        NULL,               // pco      (none)
                        NULL,               // pxlo     (none)
                        prclTrgTmp,         // prclDst
                        pptlSrcTmp);        // pptlSrc
        }
    }
    else if ((prclSrc->bottom - prclSrc->top) > prclTrg->bottom - prclTrg->top)
    {
        //
        // we need to break it up into horizontal strips
        //

        cx = prclSrc->right - prclSrc->left;
        cy = prclTrg->bottom - prclTrg->top;

        ASSERT(cx != 0, "DrvSaveScreenBits: vCopyRects (h save width == 0)\n");
        ASSERT(cy != 0, "DrvSaveScreenBits: vCopyRects (h save height == 0)\n");

        rclOnScreen.bottom = prclSrc->top;
        rclOnScreen.left   = prclSrc->left;
        rclOnScreen.right  = prclSrc->left + cx;

        rclOffScreen.top  = prclTrg->top;
        rclOffScreen.right = prclTrg->left - cxPad;

        // align offscreen rect to src

        rclOffScreen.right += cAlign;

        while (rclOnScreen.bottom < prclSrc->bottom)
        {
            cy = min(cy,(ULONG)(prclSrc->bottom - rclOnScreen.bottom));
            ASSERT(cy != 0, "DrvSaveScreenBits: vCopyRects (cy == 0)\n");
            rclOnScreen.top = rclOnScreen.bottom;
            rclOnScreen.bottom += cy;
            rclOffScreen.bottom = rclOffScreen.top + cy; // in case cy is shorter
                                                         //   on last strip
            rclOffScreen.left = rclOffScreen.right + cxPad;
            rclOffScreen.right = rclOffScreen.left + cx;

            if (rclOffScreen.right > (prclTrg->right + (LONG)cAlign))
            {
                RIP("DrvSaveScreenBits: "
                    "vCopyRects can't fit src into trg (horizontal)\n");
            }

            if (bIsSave)
            {
                // save
                pptlSrcTmp = (POINTL *) &rclOnScreen;
                prclTrgTmp = &rclOffScreen;

                DISPDBG((1,"DrvSaveScreenBits (h save):    "));
            }
            else
            {
                // restore
                pptlSrcTmp = (POINTL *) &rclOffScreen;
                prclTrgTmp = &rclOnScreen;

                DISPDBG((1,"DrvSaveScreenBits (h restore): "));
            }

            DISPDBG((1,"%08x,%08x,%08x,%08x    %lux%lu\n",
                    rclOffScreen.left,
                    rclOffScreen.top,
                    rclOffScreen.right,
                    rclOffScreen.bottom,
                    rclOffScreen.right - rclOffScreen.left,
                    rclOffScreen.bottom - rclOffScreen.top
                    ));

            ASSERT(((prclTrgTmp->left ^ pptlSrcTmp->x) &
                    (PLANAR_PELS_PER_CPU_ADDRESS - 1)) == 0,
                   "DrvSaveScreenBits (h): Src and Target are not aligned\n");

            DrvCopyBits(pso,                // psoDst   (screen)
                        pso,                // psoSrc   (screen)
                        NULL,               // pco      (none)
                        NULL,               // pxlo     (none)
                        prclTrgTmp,         // prclDst
                        pptlSrcTmp);        // pptlSrc
        }
    }
    else
    {
        // we don't need to break it up at all

        cx = prclSrc->right - prclSrc->left;
        cy = prclSrc->bottom - prclSrc->top;

        ASSERT(cx != 0, "DrvSaveScreenBits: vCopyRects (save width == 0)\n");
        ASSERT(cy != 0, "DrvSaveScreenBits: vCopyRects (save height == 0)\n");

        rclOffScreen.left   = prclTrg->left;
        rclOffScreen.right  = prclTrg->left + cx;
        rclOffScreen.top    = prclTrg->top;
        rclOffScreen.bottom = prclTrg->top + cy;

        // align offscreen rect to src

        rclOffScreen.left += cAlign;
        rclOffScreen.right += cAlign;

        if (bIsSave)
        {
            // save
            pptlSrcTmp = (POINTL *) prclSrc;
            prclTrgTmp = &rclOffScreen;

            DISPDBG((1,"DrvSaveScreenBits (save):    "));
        }
        else
        {
            // restore
            pptlSrcTmp = (POINTL *) &rclOffScreen;
            prclTrgTmp = prclSrc;

            DISPDBG((1,"DrvSaveScreenBits (restore): "));
        }

        DISPDBG((1,"%08x,%08x,%08x,%08x    %lux%lu\n",
                rclOffScreen.left,
                rclOffScreen.top,
                rclOffScreen.right,
                rclOffScreen.bottom,
                rclOffScreen.right - rclOffScreen.left,
                rclOffScreen.bottom - rclOffScreen.top
                ));

        ASSERT(((prclTrgTmp->left ^ pptlSrcTmp->x) &
                (PLANAR_PELS_PER_CPU_ADDRESS - 1)) == 0,
               "DrvSaveScreenBits: Src and Target are not aligned\n");

        DrvCopyBits(pso,                // psoDst   (screen)
                    pso,                // psoSrc   (screen)
                    NULL,               // pco      (none)
                    NULL,               // pxlo     (none)
                    prclTrgTmp,         // prclDst
                    pptlSrcTmp);        // pptlSrc
    }

    return;
}


/******************************Public*Routine******************************\
* ulSaveOrRestoreBits(pso, ppdev,prcl,bIsSave)                             *
*                                                                          *
* Saves or restores the specified area of the screen                       *
*                                                                          *
\**************************************************************************/

ULONG ulSaveOrRestoreBits(SURFOBJ *pso, PPDEV ppdev, RECTL * prcl, BOOL bIsSave)
{
    ULONG dxDstBottom, dyDstBottom; // width, height of bottom edge off screen area
    ULONG dxDstRight, dyDstRight;   // width, height of right edge off screen area
    ULONG dxSrc,  dySrc;            // width, height of screen area to copy
    RECTL rclSrcRight;              // portion of *prcl to go into right edge area
    RECTL rclSrcBottom;             // portion of *prcl to go into bottom edge area
    ULONG dxPadBottom;              // width of spacer required to keep all copies
                                    //   after the first aligned in the bottom
                                    //   rectangle
    //
    // Saves bits from visible VGA memory in unused VGA memory
    //

    dxDstBottom = ppdev->rclSavedBitsBottom.right - ppdev->rclSavedBitsBottom.left;
    dyDstBottom = ppdev->rclSavedBitsBottom.bottom - ppdev->rclSavedBitsBottom.top;
    dxDstRight  = ppdev->rclSavedBitsRight.right - ppdev->rclSavedBitsRight.left;
    dyDstRight  = ppdev->rclSavedBitsRight.bottom - ppdev->rclSavedBitsRight.top;
    dxSrc       = prcl->right - prcl->left;
    dySrc       = prcl->bottom - prcl->top;

    // see if rect fits in lower rect, unbroken
    // this is the most common case!

    if (dySrc <= dyDstBottom  && dxSrc <= dxDstBottom)
    {
        // YES!

        DISPDBG((1,"DrvSaveScreenBits: bits all fit into bottom rect\n"));
        vCopyRects(pso,
                   ppdev,
                   prcl,
                   &ppdev->rclSavedBitsBottom,
                   0,
                   bIsSave);
        return(SAVED_OFFSCREEN_ID);
    }

    // see if rect fits in right rect, unbroken

    if (dySrc <= dyDstRight && dxSrc <= dxDstRight)
    {
        // YES!

        DISPDBG((1,"DrvSaveScreenBits: bits all fit into right rect\n"));
        vCopyRects(pso,
                   ppdev,
                   prcl,
                   &ppdev->rclSavedBitsRight,
                   0,
                   bIsSave);
        return(SAVED_OFFSCREEN_ID);
    }

    //
    // before we bother to break it up, see if it could even POSSIBLY fit
    //

    if ((dxSrc * dySrc) > ((dxDstRight * dyDstRight) + (dxDstBottom * dyDstBottom)))
    {
        // Forget it bud.  There are more bytes to save than we have total.
        // Don't bother checking for best fit.

        return(0);
    }

    // ARGGGHHHH!

    //
    // split source rectangle into two rectangles and see if they fit
    //

    rclSrcRight = rclSrcBottom = *prcl;

    //
    // see how many strips of height dySrc we can get into the rclDstRight
    // (of height dyDstRight) and then divide the rclSrc rectangles so
    // that rclSrcRight has that many strips and rclSrcBottom has what's left
    //
    rclSrcBottom.left = rclSrcRight.right =
        min(rclSrcBottom.right,
            rclSrcRight.left + (LONG)(dxDstRight * (dyDstRight/dySrc)));

    //
    // FYI: rclSrcRight WILL fit into ppdev->rclSavedBitsBottom because that's
    //      how its size was determined
    //

    // dxPadBottom = (-x)&(PLANAR_PELS_PER_CPU_ADDRESS-1) where x is the width of
    // the rectangle that we want to break up and put into the bottom offscreen
    // area.  Therefore, ((rclSrcBottom.right-rclSrcBottom.left)+dxPadBottom)
    // will be a number of pels that is a DWORD multiple.

    dxPadBottom = (rclSrcBottom.left-rclSrcBottom.right) &
                  (PLANAR_PELS_PER_CPU_ADDRESS - 1);

    if (((rclSrcBottom.right-rclSrcBottom.left) == 0) ||
        ((dySrc/dyDstBottom) <
         (dxDstBottom/((rclSrcBottom.right-rclSrcBottom.left)+dxPadBottom))))
    {
        //
        // rclSrcBottom fits into ppdev->rclSavedBitsBottom
        //

        if ((rclSrcRight.right - rclSrcRight.left) > 0)
        {
            //
            // there is data that should go into the right edge area
            //

            vCopyRects(pso,
                       ppdev,
                       &rclSrcRight,
                       &ppdev->rclSavedBitsRight,
                       0,
                       bIsSave);
        }

        if (((rclSrcBottom.right - rclSrcBottom.left) > 0) &&
            ((rclSrcBottom.bottom - rclSrcBottom.top) > 0))
        {
            //
            // there is data that should go into the bottom area
            //

            vCopyRects(pso,
                       ppdev,
                       &rclSrcBottom,
                       &ppdev->rclSavedBitsBottom,
                       dxPadBottom,
                       bIsSave);
        }

        return(SAVED_OFFSCREEN_ID);

    }

    // All that @#!&ing work, and we just barely missed fitting in.

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\textout.c ===
/******************************Module*Header*******************************\
* Module Name: textout.c
*
* VGA DrvTextOut Entry point
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/
#include "driver.h"
#include "textout.h"

#define SO_MASK                \
(                              \
SO_FLAG_DEFAULT_PLACEMENT |    \
SO_ZERO_BEARINGS          |    \
SO_CHAR_INC_EQUAL_BM_BASE |    \
SO_MAXEXT_EQUAL_BM_SIDE        \
)


#define     TEXT_BUFFER_SIZE    2048
#define     FIFTEEN_BITS        ((1 << 15)-1)


// accelerator masks for four canonical directions of
// writing (multiples of 90 degrees)

#define SO_LTOR          (SO_MASK | SO_HORIZONTAL)
#define SO_RTOL          (SO_LTOR | SO_REVERSED)
#define SO_TTOB          (SO_MASK | SO_VERTICAL)
#define SO_BTOT          (SO_TTOB | SO_REVERSED)

/**************************************************************************\
* Function Declarations
\**************************************************************************/

VOID  lclFillRect(CLIPOBJ *pco, ULONG culRcl, PRECTL prcl, PDEVSURF pdsurf,
    INT iColor, ULONG iTrgType);
VOID vFastText(GLYPHPOS *, ULONG, PBYTE, ULONG, ULONG, DEVSURF *, RECTL *,
    RECTL *, INT, INT, ULONG, RECTL *, RECTL *, ULONG);


/******************************Public*Routine******************************\
* BOOL DrvTextOut(pso,pstro,pfo,pco,prclExtra,prcOpaque,
*                 pvFore,pvBack,pptOrg,r2Fore,r2Back)
*
\**************************************************************************/

BOOL DrvTextOut(
 SURFOBJ  *pso,
 STROBJ   *pstro,
 FONTOBJ  *pfo,
 CLIPOBJ  *pco,
 PRECTL    prclExtra,
 PRECTL    prclOpaque,
 BRUSHOBJ *pboFore,
 BRUSHOBJ *pboOpaque,
 PPOINTL   pptlOrg,
 MIX       mix)
{
    PDEVSURF        pdsurf;                 // Pointer to device surface
    ULONG           iClip;                  // Clip object's complexity
    BOOL            bMore;                  // Flag for clip enumeration
    RECT_ENUM       txen;                   // Clip enumeration object
    GLYPHPOS       *pgp;                    // pointer to the 1st glyph
    BOOL            bMoreGlyphs;            // Glyph enumeration flag
    ULONG           cGlyph;                 // number of glyphs in one batch
    ULONG           iSolidForeColor;        // Solid foreground color
    ULONG           iSolidBkColor;          // Solid background color
    FLONG           flStr = 0;              // Accelator flag for DrvTextOut()
    FLONG           flOption = 0;           // Accelator flag for pfnBlt
    RECTL           arclTmp[4];             // Temp storage for portions of
                                            //  opaquing rect
    RECTL          *prclClip;               // ptr to list of clip rectangles
    ULONG           culRcl;                 // Temp rectangle count
    ULONG           ulBufferWidthInBytes;
    ULONG           ulBufferHeight;
    ULONG           ulBufferBytes;
    BOOL            bTextPerfectFit;
    ULONG           fDrawFlags;
    BYTE           *pjTempBuffer;
    ULONG           ulTempBufAlign;         // What to add to temp buff to dword
                                            // align with the dest
    BOOL            bTempAlloc;
    ULONG           iTrgType;
    VOID            (*pfnFillSolid)(PDEVSURF,ULONG,PRECTL,MIX,ULONG);
    BYTE            szTextBuffer[TEXT_BUFFER_SIZE];


    //---------------------------------------------------------------------
    // Note: the mix passed in is always guarenteed to be SRCCOPY
    //---------------------------------------------------------------------


    //---------------------------------------------------------------------
    // Get the target surface information
    //---------------------------------------------------------------------

    iTrgType = VGA_TARGET;
    pfnFillSolid = vTrgBlt;

    if (!DRAW_TO_VGA((PDEVSURF)pso->dhsurf))
    {
        iTrgType = DFB_TARGET;
        pfnFillSolid = vDFBFILL;
    }

    pdsurf = (PDEVSURF) pso->dhsurf;

    //---------------------------------------------------------------------
    // Get information about clip object.
    //---------------------------------------------------------------------

    iClip = DC_TRIVIAL;

    if (pco != NULL) {
        iClip = pco->iDComplexity;
    }

    //---------------------------------------------------------------------
    // Get text color.
    //---------------------------------------------------------------------

    iSolidForeColor = pboFore->iSolidColor;

    // See if the temp buffer is big enough for the text; if not,
    // try to allocate enough memory.
    // Round up to the nearest dword multiple.

    ulBufferWidthInBytes = ((((pstro->rclBkGround.right + 31) & ~31) -
                            (pstro->rclBkGround.left & ~31)) >> 3);

    ulBufferHeight = pstro->rclBkGround.bottom - pstro->rclBkGround.top;

    ulBufferBytes = ulBufferWidthInBytes * ulBufferHeight;

    if ((ulBufferWidthInBytes > FIFTEEN_BITS) ||
        (ulBufferHeight > FIFTEEN_BITS))
    {
        // the math will have overflowed
        return(FALSE);
    }

    if ((pso->iType == STYPE_DEVICE) &&
        (ulBufferBytes <= pdsurf->ulTempBufferSize))
    {
        // The screen's temp buffer is big enough, so we'll use it
        pjTempBuffer = pdsurf->pvBankBufferPlane0;
        bTempAlloc = FALSE;
    }
    else if ((pso->iType == STYPE_DEVBITMAP) &&
             (ulBufferBytes <= TEXT_BUFFER_SIZE))
    {
        // The temp buffer on the stack is big enough, so we'll use it
        pjTempBuffer = szTextBuffer;
        bTempAlloc = FALSE;
    }
    else
    {
        // The temp buffer isn't big enough, so we'll try to allocate
        // enough memory
        if ((pjTempBuffer = EngAllocUserMem(ulBufferBytes, ALLOC_TAG)) == NULL) {
            // We couldn't get enough memory, we're dead
                return(FALSE);
        }

        // Mark that we have to free the buffer when we're done
        bTempAlloc = TRUE;
    }

    // One way or another, we've found a buffer that's big enough; set up
    // for accelerated text drawing

    // Set fixed pitch, overlap, and top & bottom Y alignment flags
    if ((!(pstro->flAccel & SO_HORIZONTAL)) || (pstro->flAccel & SO_REVERSED))
    {
        fDrawFlags = 0;
    }
    else
    {
        fDrawFlags = ((pstro->ulCharInc != 0) ? 0x01 : 0) |
                     (((pstro->flAccel & (SO_ZERO_BEARINGS |
                      SO_FLAG_DEFAULT_PLACEMENT)) !=
                      (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT))
                      ? 0x02 : 0) |
                     (((pstro->flAccel & (SO_ZERO_BEARINGS |
                      SO_FLAG_DEFAULT_PLACEMENT |
                      SO_MAXEXT_EQUAL_BM_SIDE)) ==
                      (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
                      SO_MAXEXT_EQUAL_BM_SIDE)) ? 0x04 : 0);
    }

    // If there's an opaque rectangle, we'll do as much opaquing as
    // possible as we do the text. If the opaque rectangle is larger than
    // the text rectangle, then we'll do the fringe areas right now, and
    // the text and associated background areas together later
    if (prclOpaque != (PRECTL) NULL) {

        // This driver only handles solid brushes
        iSolidBkColor = pboOpaque->iSolidColor;

        // See if we have fringe areas to do. If so, build a list of
        // rectangles to fill, in rightdown order

        culRcl = 0;

        // Top fragment
        if (pstro->rclBkGround.top > prclOpaque->top) {
            arclTmp[culRcl].top = prclOpaque->top;
            arclTmp[culRcl].left = prclOpaque->left;
            arclTmp[culRcl].right = prclOpaque->right;
            arclTmp[culRcl++].bottom = pstro->rclBkGround.top;
        }

        // Left fragment
        if (pstro->rclBkGround.left > prclOpaque->left) {
            arclTmp[culRcl].top = pstro->rclBkGround.top;
            arclTmp[culRcl].left = prclOpaque->left;
            arclTmp[culRcl].right = pstro->rclBkGround.left;
            arclTmp[culRcl++].bottom = pstro->rclBkGround.bottom;
        }

        // Right fragment
        if (pstro->rclBkGround.right < prclOpaque->right) {
            arclTmp[culRcl].top = pstro->rclBkGround.top;
            arclTmp[culRcl].right = prclOpaque->right;
            arclTmp[culRcl].left = pstro->rclBkGround.right;
            arclTmp[culRcl++].bottom = pstro->rclBkGround.bottom;
        }

        // Bottom fragment
        if (pstro->rclBkGround.bottom < prclOpaque->bottom) {
            arclTmp[culRcl].bottom = prclOpaque->bottom;
            arclTmp[culRcl].left = prclOpaque->left;
            arclTmp[culRcl].right = prclOpaque->right;
            arclTmp[culRcl++].top = pstro->rclBkGround.bottom;
        }

        // Fill any fringe rectangles we found
        if (culRcl != 0) {
            if (iClip == DC_TRIVIAL) {
                (*pfnFillSolid)(pdsurf, culRcl, arclTmp, R2_COPYPEN,
                        iSolidBkColor);
            } else {
                lclFillRect(pco, culRcl, arclTmp, pdsurf,
                            iSolidBkColor,iTrgType);
            }
        }
    }


    // We're done with separate opaquing; any further opaquing will happen
    // as part of the text drawing

    // Clear the buffer if the text isn't going to set every bit
    bTextPerfectFit = (pstro->flAccel & (SO_ZERO_BEARINGS |
            SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE |
            SO_CHAR_INC_EQUAL_BM_BASE)) ==
            (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
            SO_MAXEXT_EQUAL_BM_SIDE | SO_CHAR_INC_EQUAL_BM_BASE);

    if (!bTextPerfectFit) {
        // Note that we already rounded up to a dword multiple size.
        vClearMemDword((ULONG *)pjTempBuffer, ulBufferBytes >> 2);
    }

    ulTempBufAlign = ((pstro->rclBkGround.left >> 3) & 3);

    // Draw the text into the temp buffer, and thence to the screen

    do
    {
        // Get the next batch of glyphs

        if (pstro->pgp != NULL)
        {
            // There's only the one batch of glyphs, so save ourselves a call
            pgp = pstro->pgp;
            cGlyph = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro,&cGlyph,&pgp);
        }

        //--------------------------------------------------------------------
        //  No glyph, no work!
        //--------------------------------------------------------------------

        if (cGlyph)
        {
        #if DBG
        if (pstro->ulCharInc == 0) // if not fixed pitch font
        {
            LONG xL, xR, yT, yB;
            ULONG ii;
            for (ii=0; ii<cGlyph; ii++)
            {
                xL = pgp[ii].ptl.x + pgp[ii].pgdf->pgb->ptlOrigin.x;
                xR = xL + pgp[ii].pgdf->pgb->sizlBitmap.cx;
                yT = pgp[ii].ptl.y + pgp[ii].pgdf->pgb->ptlOrigin.y;
                yB = yT + pgp[ii].pgdf->pgb->sizlBitmap.cy;

                if (xL < pstro->rclBkGround.left)
                    RIP("xL < pstro->rclBkGround.left\n");
                if (xR > pstro->rclBkGround.right)
                    RIP("xR > pstro->rclBkGround.right\n");
                if (yT < pstro->rclBkGround.top)
                    RIP("yT < pstro->rclBkGround.top\n");
                if (yB > pstro->rclBkGround.bottom)
                    RIP("yB > pstro->rclBkGround.bottom\n");
            }
        }
        #endif // DBG


            prclClip = NULL;

            switch (iClip)
            {
                case DC_RECT:
                    arclTmp[0] = pco->rclBounds;    // copy clip rect to arclTmp[0]
                    arclTmp[1].bottom = 0;          // make arclTmp[1] a null rect
                    prclClip = &arclTmp[0];
                    // falling through !!!

                case DC_TRIVIAL:
                    vFastText(pgp,
                              cGlyph,
                              (PBYTE) (pjTempBuffer + ulTempBufAlign),
                              ulBufferWidthInBytes,
                              pstro->ulCharInc,
                              pdsurf,
                              &pstro->rclBkGround,
                              prclOpaque,
                              iSolidForeColor,
                              iSolidBkColor,
                              fDrawFlags,
                              prclClip,
                              prclExtra,
                              bMoreGlyphs ? NO_TARGET : iTrgType);
                    break;

                case DC_COMPLEX:
                    prclClip = &txen.arcl[0];

                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    do
                    {
                        bMore = CLIPOBJ_bEnum(pco,
                                (ULONG) (sizeof(txen) - sizeof(RECT)),
                                (PVOID) &txen);

                        txen.arcl[txen.c].bottom = 0;   // terminate txen.arcl[]
                                                        // with a null rect
                        vFastText(pgp,
                                  cGlyph,
                                  (PBYTE) (pjTempBuffer + ulTempBufAlign),
                                  ulBufferWidthInBytes,
                                  pstro->ulCharInc,
                                  pdsurf,
                                  &pstro->rclBkGround,
                                  prclOpaque,
                                  iSolidForeColor,
                                  iSolidBkColor,
                                  fDrawFlags,
                                  prclClip,
                                  prclExtra,
                                  bMoreGlyphs ? NO_TARGET : iTrgType);
                    } while (bMore);
                    break;
            }
        }
    } while (bMoreGlyphs);

    // Free up any memory we allocated for the temp buffer
    if (bTempAlloc)
    {
        EngFreeUserMem(pjTempBuffer);
    }

    return(TRUE);
}


//--------------------------------------------------------------------------
// Fills the specified rectangles on the specified surface with the
// specified color, honoring the requested clipping. No more than four
// rectangles should be passed in. Intended for drawing the areas of the
// opaquing rectangle that extended beyond the text box. The rectangles must
// be in left to right, top to bottom order. Assumes there is at least one
// rectangle in the list.
//--------------------------------------------------------------------------

VOID lclFillRect(
 CLIPOBJ *pco,
 ULONG culRcl,
 PRECTL prcl,
 PDEVSURF pdsurf,
 INT iColor,
 ULONG iTrgType)
{
    BOOL  bMore;                  // Flag for clip enumeration
    RECT_ENUM txen;                // Clip enumeration object
    ULONG i, j;
    RECTL arclTmp[4];
    ULONG culRclTmp;
    RECTL *prclTmp, *prclClipTmp;
    INT   iLastBottom;
    RECTL *pClipRcl;
    INT iClip;
    VOID (*pfnFillSolid)(PDEVSURF,ULONG,PRECTL,MIX,ULONG);

    if (iTrgType == DFB_TARGET)
    {
        pfnFillSolid = vDFBFILL;
    }
    else
    {
        pfnFillSolid = vTrgBlt;
    }

    ASSERT(culRcl <= 4, "DrvTextOut: Too many rects to lclFillRect");

    iClip = DC_TRIVIAL;

    if (pco != NULL) {
        iClip = pco->iDComplexity;
    }

    switch ( iClip ) {

        case DC_TRIVIAL:

            (*pfnFillSolid)(pdsurf, culRcl, prcl, R2_COPYPEN, iColor);

            break;

        case DC_RECT:

            prclTmp = &pco->rclBounds;

            // Generate a list of clipped rects
            for (culRclTmp=0, i=0; i<culRcl; i++, prcl++) {

                // Intersect fill and clip rectangles
                if (DrvIntersectRect(&arclTmp[culRclTmp], prcl, prclTmp)) {

                    // Add to list if anything's left to draw
                    culRclTmp++;
                }
            }

            // Draw the clipped rects
            if (culRclTmp != 0) {
                (*pfnFillSolid)(pdsurf, culRclTmp, arclTmp, R2_COPYPEN, iColor);
            }

            break;

        case DC_COMPLEX:

            // Bottom of last rectangle to fill
            iLastBottom = prcl[culRcl-1].bottom;

            // Initialize the clip rectangle enumeration to rightdown so we can
            // take advantage of the rectangle list being rightdown
            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN, 0);

            // Scan through all the clip rectangles, looking for intersects
            // of fill areas with region rectangles
            do {

                // Get a batch of region rectangles
                bMore = CLIPOBJ_bEnum(pco, (ULONG)sizeof(txen), (PVOID)&txen);

                // Clip the rect list to each region rect
                for (j = txen.c, pClipRcl = txen.arcl; j-- > 0; pClipRcl++) {

                    // Since the rectangles and the region enumeration are both
                    // rightdown, we can zip through the region until we reach
                    // the first fill rect, and are done when we've passed the
                    // last fill rect.

                    if (pClipRcl->top >= iLastBottom) {
                        // Past last fill rectangle; nothing left to do
                        return;
                    }

                    // Do intersection tests only if we've reached the top of
                    // the first rectangle to fill
                    if (pClipRcl->bottom > prcl->top) {

                        // We've reached the top Y scan of the first rect, so
                        // it's worth bothering checking for intersection

                        // Generate a list of the rects clipped to this region
                        // rect
                        prclTmp = prcl;
                        prclClipTmp = arclTmp;
                        for (i = culRcl, culRclTmp=0; i-- > 0; prclTmp++) {

                            // Intersect fill and clip rectangles
                            if (DrvIntersectRect(prclClipTmp, prclTmp,
                                    pClipRcl)) {

                                // Add to list if anything's left to draw
                                culRclTmp++;
                                prclClipTmp++;
                            }
                        }

                        // Draw the clipped rects
                        if (culRclTmp != 0) {
                            (*pfnFillSolid)(pdsurf, culRclTmp, arclTmp, R2_COPYPEN,
                                    iColor);
                        }
                    }
                }
            } while (bMore);

            break;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\bitblt.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: bitblt.inc
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
;	INCREASE is the flag used to show that the BLT operation will be
;	increasing in Y (Y+).
;
;	DECREASE is the flag used to show that the BLT operation will be
;	decreasing in Y (Y-).
;
;	STEPLEFT is the flag used to show that the BLT will be stepping
;	left (i.e. start at the right hand corner of the source, stepping
;	left, or X-).
;
;	STEPRIGHT is the flag used to show that the BLT will be stepping
;	right (i.e. start at the left hand corner of the source, stepping
;	right, or X+).
;-----------------------------------------------------------------------;

INCREASE	equ	1		;Incrementing
DECREASE	equ	-1		;Decrementing
STEPLEFT	equ	0		;Stepping to the left
STEPRIGHT	equ	1		;Stepping to the right

;-----------------------------------------------------------------------;
;	gl_the_flags
;
;	F0_GAG_CHOKE	Set if the source and destination are of different
;			color formats.	When set, some form of color
;			conversion will be required.
;
;			Once you see what all is involved with color
;			conversion, you'll understand why this flag is
;			called this.
;
;	F0_COLOR_PAT	Set if color pattern fetch code will be used.  If
;			clear, then mono pattern fetch code will be used.
;			Mono/color pattern fetch is always based on the
;			destination being mono/color (it is the same).
;
;	F0_PAT_PRESENT	Set if a pattern is involved in the BLT.
;
;	F0_SRC_PRESENT	Set if a source  is involved in the BLT.
;
;	F0_SRC_IS_DEV	Set if the source is the physical device.  Clear if
;			the source is a memory bitmap.
;
;	F0_SRC_IS_COLOR	Set if the source is color, clear if monochrome.
;
;	F0_DEST_IS_DEV	Set if the destination is the physical device.
;			Clear if the destination is a memory bitmap.
;
;	F0_DEST_IS_COLOR
;			Set if the destination is color, clear if
;			monochrome.
;-----------------------------------------------------------------------;

F0_GAG_CHOKE		equ	10000000b	;Going mono <==> color
F0_COLOR_PAT		equ	01000000b	;Use color pattern fetch code
F0_PAT_PRESENT		equ	00100000b	;Pattern is involved in blt
F0_SRC_PRESENT		equ	00010000b	;Source is involved in blt
F0_SRC_IS_DEV		equ	00001000b	;Source is the device
F0_SRC_IS_COLOR		equ	00000100b	;Source is color
F0_DEST_IS_DEV		equ	00000010b	;Destination is the device
F0_DEST_IS_COLOR	equ	00000001b	;Destination is color

;-----------------------------------------------------------------------;
; Definitions for fbFetch
;-----------------------------------------------------------------------;

FF_NO_LAST_FETCH	equ	00000010b	;Final fetch might GP
FF_TWO_INIT_FETCHES	equ	00000001b	;Two initial fetches needed
FF_ONE_INIT_FETCH       equ            0        ;One initial fetch   needed
FF_ONLY_1_DEST_BYTE	equ	00000100b	;Only one destination byte
FF_ONLY_1_SRC_BYTE	equ	00001000b	;Only one source byte

;-----------------------------------------------------------------------;
;	MAX_BLT_SIZE is the maximum stack space required for the BITBLT
;	code.  This is a hard number to compute.  It must be based on
;	the worst case situation:
;
;		worst phase alignment
;		worst color conversions
;		first byte present
;		last byte present
;		full inner loop
;		jump into the inner loop
;
;	and any other factor which could increase the size of the code.
;-----------------------------------------------------------------------;

MAX_BLT_SIZE    =      400h             ;Max stack space a BLT will require

;-----------------------------------------------------------------------;
;	The following flags are used in the inner loops to both control
;	the EGA read/write enable registers, and the plane loop count.
;
;	They are based on a simple relationship of the EGA's Map Mask
;	register and Read Map Select Register when used as a three plane
;	system:
;
;	Map Mask:     D3 D2 D1 D0	   Read Map: D2 D1 D0
;
;	  C0 plane     0  0  0	1		      0  0  0
;	  C1 plane     0  0  1	0		      0  0  1
;	  C2 plane     0  1  0	0		      0  1  0
;
;
;	Note that to convert the map mask into a read mask for the
;	same plane only requires a "SHR x,1" instruction.  This trick
;	would not work if all four planes were used.
;
;	In four plane mode, when the above mapping occurs becomes:
;
;	  C3 plane     1  0  0	0		      1  0  0
;
;	  To map this into the correct read map register of 11b:
;
;		cmp	mask,100b	;Set 'C' if not C3
;		adc	mask,-1 	;sub -1 only if C3
;
;
;
;	The "loop counter" will consist of a bit shifted left every
;	interation of the loop, which will be used as stated above.
;	When this bit mask reaches a predetermined value, the loop
;	will terminate.
;-----------------------------------------------------------------------;

COLOR_OP        equ     C0_BIT                  ;Color ops start with C0
MONO_OP         equ     MONO_BIT                ;Mono ops start with mono bit
PLANE_1         equ     00010001b               ;Loop starting bits
END_OP		equ	(C3_BIT+MONO_BIT) SHL 1	;Loop terminating bits

;-----------------------------------------------------------------------;
;	dl_moore_flags
;
;	dl_moore_flags pertain to color conversion only.  If color
;	conversion doesn't apply to the BLT, these flags will not
;	be defined.
;
;
;	F1_REP_OK		When F1_REP_OK is set, then the innerloop code can
;			use a REP MOVSx instruction.  This will be the
;			case if:
;
;			a)  The source is the EGA and the color compare
;			    register can be used to do the conversion
;			    from color to monochrome.
;
;			b)  The source is monochrome, the background
;			    color white, and the foreground color black,
;			    in which case color converison of the source
;			    would just give the source.
;
;	F1_NO_MUNGE 	Set under the same conditions as "b" above.
;-----------------------------------------------------------------------;

F1_REP_OK	equ	10000000b	;Using REP is ok (when F0_GAG_CHOKE)
F1_NO_MUNGE 	equ	01000000b	;No mono ==> color conversion table

;-----------------------------------------------------------------------;
;	The DEV structure contains all the information taken from the
;	PDevices passed in.  PDevices are copied to the frame to reduce
;	the number of long pointer loads required.  Having the data
;	contained in the structure allows MOVSW to be used when copying
;	the data.
;
;	width_bits	The number of pixels wide the device is.
;
;	height		The number of scans high the device is.
;
;	width_b		The width of a scan in bytes.
;
;	lp_bits		The pointer to the actual bits of the device.
;			It will be adjusted as necessary to point to the
;			first byte to be modified by the BLT operation.
;
;	dev_flags	Device Specific Flags
;			IS_DEVICE   - This is the physical device
;			COLOR_UP    - Generate color scan line update
;			IS_COLOR    - Device is a color device
;
;	next_scan	Bias to get to the next (previous) scan line.
;-----------------------------------------------------------------------;

DEV             struc
width_bits      dw      ?               ;Width in bits
height          dw      ?               ;Height in scans
width_b         dw      ?               ;Width in bytes
lp_bits         dd      ?               ;Pointer to the bits
dev_flags       db      ?               ;Device flags as given above
                db      ?               ;Alignment
next_scan       dd      ?               ;Index to next scan
next_plane      dd      ?               ;Index to next plane
DEV		ends

;	Constants for use in dev_flags field of DEV structure:

IS_COLOR 	equ	00000001b	;Device is color
IS_DEVICE	equ	00000010b	;Physical Device
COLOR_UP 	equ	00000100b	;Color scan line update

;-----------------------------------------------------------------------;
; The following structure is used to define all the local variables
; we will be accessing.  We do this since there are no cmacros for
; flatland and masm386 put scope in.
;-----------------------------------------------------------------------;

FRAME       struc

; Copys of the passed parameters, so called functions can get them

pdsurfDst           dd      ?
DestxOrg            dw      ?
DestyOrg            dw      ?
pdsurfSrc           dd      ?
SrcxOrg             dw      ?
SrcyOrg             dw      ?
xExt                dw      ?
yExt                dw      ?
Rop                 dd      ?
lpPBrush            dd      ?
bkColor             dd      ?
TextColor           dd      ?
pptlBrush           dd      ?

; locals

phase_h             db      ?           ;Horizontal phase (rotate count)
pat_row             db      ?           ;Current row for patterns [0..7]
direction           db      ?           ;Increment/decrement flag
the_flags           db      ?
first_fetch         db      ?           ;Number of first fetches needed
step_direction      db      ?           ;Direction of move (left right)
start_mask          dw      ?           ;Mask for first dest byte
last_mask           dw      ?           ;Mask for last  dest byte
mask_p              dw      ?           ;Horizontal phase mask
inner_loop_count    dd      ?           ;# of entire bytes to BLT in innerloop
operands            dw      ?           ;Operand string
start_fl            dd      ?           ;Start of fetch/logic operation
end_fl              dd      ?           ;End   of fetch/logic operation
end_fls             dd      ?           ;End   of fetch/logic/store operation
blt_addr            dd      ?           ;BLT address
cFetchCode          dd      ?           ;size of the fetch code alone
both_colors         dw      ?           ;Foreground and Background colors
brush_accel         db      ?           ;Brush accelerator
moore_flags         db      ?           ;More flags
addr_brush_index    dd      ?           ;Address of brush index in code
pNextPlane          dd      ?           ;Address of next plane logic

; variable sized locals

ppcBlt      db  (SIZE PACKEDPELCONV) dup (?);Packed pel conversion data
src         db  (SIZE DEV) dup (?)          ;Source device data
dest        db  (SIZE DEV) dup (?)          ;Destination device data
ajM2C       db  (NUMBER_PLANES * 2) dup (?) ;Mono ==> color munge table
a_brush     db  (NUMBER_PLANES * SIZE_PATTERN) dup (?)  ;Temp brush
aulMap      dd  16 dup (?)                  ;Packed pel conversion table

FRAME       ends


if 0

;-----------------------------------------------------------------------;
; Definitions of the bitblt frame for enterframe, useframe, leaveframe
;-----------------------------------------------------------------------;


; Define the frame for bitblt, using PASCAL conventions

parm_bitblt     struc
pdsurfDst       dd      ?       ;Pointer to destination DEVSURF
DestxOrg        dd      ?       ;Destination X origin
DestyOrg        dd      ?       ;Destination Y origin
pdsurfSrc       dd      ?       ;Pointer to optional source DEVSURF
SrcxOrg         dd      ?       ;Source X origin
SrcyOrg         dd      ?       ;Source Y origin
xExt            dd      ?       ;X extent of the blt
yExt            dd      ?       ;Y extent of the blt
Rop             dd      ?       ;Mix mode
lpPBrush        dd      ?       ;Pointer to the brush
bkColor         dd      ?       ;Background color for mono==>color blts
TextColor       dd      ?       ;Foreground color for mono==>color blts
pulXlateVec     dd      ?       ;Color translation vector
pptlBrush       dd      ?       ;Pointer to POINTL for brush origin
parm_bitblt     ends


loc_bitblt      struc
ppcBlt          db  (SIZE PACKEDPELCONV) dup (?);Packed pel conversion data
src             db  (SIZE DEV) dup (?)          ;Source device data
dest            db  (SIZE DEV) dup (?)          ;Destination device data
ajM2C           db  (NUMBER_PLANES * 2) dup (?) ;Mono ==> color munge table
a_brush         db  (NUMBER_PLANES * SIZE_PATTERN) dup (?)  ;Temp brush
aulMap          dd  16 dup (?)                  ;Packed pel conversion table


phase_h         db      ?           ;Horizontal phase (rotate count)
pat_row         db      ?           ;Current row for patterns [0..7]
direction       db      ?           ;Increment/decrement flag
the_flags       db      ?
first_fetch     db      ?           ;Number of first fetches needed
step_direction  db      ?           ;Direction of move (left right)
brush_accel     db      ?           ;Brush accelerator
moore_flags     db      ?           ;More flags

start_mask      dw      ?           ;Mask for first dest byte
last_mask       dw      ?           ;Mask for last  dest byte
mask_p          dw      ?           ;Horizontal phase mask
operands        dw      ?           ;Operand string
both_colors     dw      ?           ;Foreground and Background colors
                dw      ?           ;Alignment

inner_loop_count dd     ?           ;# of entire bytes to BLT in innerloop
start_fl        dd      ?           ;Start of fetch/logic operation
end_fl          dd      ?           ;End   of fetch/logic operation
end_fls         dd      ?           ;End   of fetch/logic/store operation
blt_addr        dd      ?           ;BLT address
cFetchCode      dd      ?           ;size of the fetch code alone
addr_brush_index dd     ?           ;Address of brush index in code
pNextPlane      dd      ?           ;Address of next plane logic
loc_bitblt  ends



endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\alignblt.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: alignblt.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; VOID vAlignedSrcCopy(PDEVSURF pdsurf, RECTL * prcldst, PPOINTL * pptlsrc,
;                      INT icopydir);
; Input:
;  pdsurf - surface on which to copy
;  prcldest - pointer to destination rectangle
;  pptlsrc - pointer to source upper left corner
;  icopydir - direction in which copy must proceed to avoid overlap problems
;             and synchronize with the clip enumeration visually, according to
;             constants CD_RIGHTDOWN, CD_LEFTDOWN, CD_RIGHTUP, and CD_LEFTUP in
;             WINDDI.H
;
; Performs accelarated aligned SRCCOPY VGA-to-VGA blts.
;
;-----------------------------------------------------------------------;
;
; Note: Assumes all rectangles have positive heights and widths. Will not
; work properly if this is not the case.
;
;-----------------------------------------------------------------------;

        comment $

The overall approach of this module for each rectangle to copy is:

1) Precalculate the masks and whole byte widths, and determine which of
partial left edge, partial right edge, and whole middle bytes are required
for this copy.

2) Set up the starting pointers for each of the areas (left, whole middle,
right), the start and stop scan lines, the copying direction (left-to-right
or right-to-left, and top-to-bottom or bottom-to-top), the threading
(sequence of calls required to do the left/whole/right components in the
proper sequence), based on the passed-in copy direction, which in turn is
dictated by the nature of the overlap between the source and destination.

3) Execute a loop, based on adapter type (2 R/W windows, 1R/1W window,
1 R/W window, unbanked), that sequences through the intersection of each
bank with the source and destination rectangles in the proper direction
(top-to-bottom or bottom-to-top, based on the passed-in copy direction),
and performs the copy in each such rectangle. The threading vector is used
to call the required routines (copy left/whole/right bytes). For 1 R/W and
1R/1W adapters, there is a second threading vector that is called when the
source and the destination are both adequately (for the copy purposes)
addressable simultaneously (because they're in the same bank), so there's
no need to copy through a temp buffer. Obviously, we want to avoid the temp
buffer whenever we can, because it's much slower and doesn't let us take
advantage of the VGA's hardware.

Note: 1 R/W and 1R/1W edges are copied through a temporary buffer. However,
each plane's bytes are not stored in the corresponding plane's temp buffer, but
rather consecutively in the plane 0 temp buffer. This is to reduce page
faulting, and also so that 1R/1W adapters only need a temp buffer large enough
to hold 4*tallest bank bytes (2K will do here, but nalgnblt.asm needs 4K).
1 R/W adapters still copy whole bytes through the full temp buffer, using all
four planes' temp buffers, so they require a temp buffer big enough to hold a
full bank (256K will do).

        commend $

;-----------------------------------------------------------------------;
; This is no longer used, but is needed by unroll.inc.

LOOP_UNROLL_SHIFT equ 1

;-----------------------------------------------------------------------;
; Maximum # of edge bytes to process before switching to next plane. Larger
; means faster, but there's more potential for flicker, since the raster scan
; has a better chance of catching bytes that have changed in some planes but
; not all planes. Larger also means bigger.

EDGE_CHUNK_SIZE equ     4

;-----------------------------------------------------------------------;
; Macro to push the current threading sequence (string of routine calls) on the
; stack, then jump to the first threading entry. The threading pointer can be
; specified, or defaults to pCurrentThread. The return address can be
; immediately after the JMP, or can be specified.

THREAD_AND_START macro THREADING,RETURN_ADDR
        local   push_base, return_address

ifb <&RETURN_ADDR&>
        push    offset return_address   ;after all the threaded routines, we
                                        ; return here
else
        push    offset &RETURN_ADDR&    ;return here
endif

ifb <&THREADING&>
        mov     eax,pCurrentThread
else
        mov     eax,&THREADING&
endif

        mov     ecx,[eax]               ;# of routines to thread (at least 1)
        lea     ecx,[ecx*2+ecx]         ;pushes below are 3 bytes each
        mov     edx,offset push_base+3
        sub     edx,ecx
        jmp     edx                     ;branch to push or jmp below

; Push the threading addresses on to the stack, so routines perform the
; threading as they return.

        push    dword ptr [eax+12]       ;3 byte instruction
        push    dword ptr [eax+8]
push_base:
        jmp     dword ptr [eax+4]        ;jump to the first threaded routine

return_address:
        endm

;-----------------------------------------------------------------------;

                .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc
        include i386\unroll.inc
        include i386\ropdefs.inc

        .list

;-----------------------------------------------------------------------;

        .data

; Threads for stringing together left, whole byte, and right operations
; in various orders, both using a temp buffer and not. Data format is:
;
; DWORD +0 = # of calls in thread (1, 2, or 3)
;       +4 = first call (required)
;       +8 = second call (optional)
;      +12 = third call (optional)

        align   4

; Copies not involving the temp buffer.

Thread_L        dd      1
                dd      copy_left_edge

Thread_W        dd      1
                dd      copy_whole_bytes

Thread_R        dd      1
                dd      copy_right_edge

Thread_LR       dd      2
                dd      copy_left_edge
                dd      copy_right_edge

Thread_RL       dd      2
                dd      copy_right_edge
                dd      copy_left_edge

Thread_LW       dd      2
                dd      copy_left_edge
                dd      copy_whole_bytes

Thread_WL       dd      2
                dd      copy_whole_bytes
                dd      copy_left_edge

Thread_WR       dd      2
                dd      copy_whole_bytes
                dd      copy_right_edge

Thread_RW       dd      2
                dd      copy_right_edge
                dd      copy_whole_bytes

Thread_LWR      dd      3
                dd      copy_left_edge
                dd      copy_whole_bytes
                dd      copy_right_edge

Thread_RWL      dd      3
                dd      copy_right_edge
                dd      copy_whole_bytes
                dd      copy_left_edge

; Copies involving the temp buffer.

Thread_Lb       dd      1
                dd      copy_left_edge_via_buffer

Thread_Wb       dd      1
                dd      copy_whole_bytes_via_buffer

Thread_Rb       dd      1
                dd      copy_right_edge_via_buffer

Thread_LbRb     dd      2
                dd      copy_left_edge_via_buffer
                dd      copy_right_edge_via_buffer

Thread_RbLb     dd      2
                dd      copy_right_edge_via_buffer
                dd      copy_left_edge_via_buffer

Thread_LbW      dd      2
                dd      copy_left_edge_via_buffer
                dd      copy_whole_bytes

Thread_LbWb     dd      2
                dd      copy_left_edge_via_buffer
                dd      copy_whole_bytes_via_buffer

Thread_WLb      dd      2
                dd      copy_whole_bytes
                dd      copy_left_edge_via_buffer

Thread_WbLb     dd      2
                dd      copy_whole_bytes_via_buffer
                dd      copy_left_edge_via_buffer

Thread_WRb      dd      2
                dd      copy_whole_bytes
                dd      copy_right_edge_via_buffer

Thread_WbRb     dd      2
                dd      copy_whole_bytes_via_buffer
                dd      copy_right_edge_via_buffer

Thread_RbW      dd      2
                dd      copy_right_edge_via_buffer
                dd      copy_whole_bytes

Thread_RbWb     dd      2
                dd      copy_right_edge_via_buffer
                dd      copy_whole_bytes_via_buffer

Thread_LbWRb    dd      3
                dd      copy_left_edge_via_buffer
                dd      copy_whole_bytes
                dd      copy_right_edge_via_buffer

Thread_LbWbRb   dd      3
                dd      copy_left_edge_via_buffer
                dd      copy_whole_bytes_via_buffer
                dd      copy_right_edge_via_buffer

Thread_RbWLb    dd      3
                dd      copy_right_edge_via_buffer
                dd      copy_whole_bytes
                dd      copy_left_edge_via_buffer

Thread_RbWbLb   dd      3
                dd      copy_right_edge_via_buffer
                dd      copy_whole_bytes_via_buffer
                dd      copy_left_edge_via_buffer

;-----------------------------------------------------------------------;
; Table of thread selection for various horizontal copy directions, with
; the look-up index a 4-bit field as follows:
;
; Bit 3 = 1 if left-to-right copy, 0 if right-to-left
; Bit 2 = 1 if left edge must be copied
; Bit 1 = 1 if whole bytes must be copied
; Bit 0 = 1 if right edge must be copied
;
; This is used for all cases where both the source and destination are
; simultaneously addressable for our purposes, so there's no need to go
; through the temp buffer (unbanked, 2 R/W, and sometimes for 1 R/W and 1R/1W).

MasterThreadTable label dword
                                ;right-to-left
        dd      0               ;<not used>
        dd      Thread_R        ;R->L, R
        dd      Thread_W        ;R->L, W
        dd      Thread_RW       ;R->L, RW
        dd      Thread_L        ;R->L, L
        dd      Thread_RL       ;R->L, RL
        dd      Thread_WL       ;R->L, WL
        dd      Thread_RWL      ;R->L, RWL
                                ;left-to-right
        dd      0               ;<not used>
        dd      Thread_R        ;L->R, R
        dd      Thread_W        ;L->R, W
        dd      Thread_WR       ;L->R, WR
        dd      Thread_L        ;L->R, L
        dd      Thread_LR       ;L->R, LR
        dd      Thread_LW       ;L->R, LW
        dd      Thread_LWR      ;L->R, LWR


; Table of thread selection for various adapter types and horizontal
; copy directions, with the look-up index a 6-bit field as follows:
;
; Bit 5 = adapter type high bit
; Bit 4 = adapter type low bit
; Bit 3 = 1 if left-to-right copy, 0 if right-to-left
; Bit 2 = 1 if left edge must be copied
; Bit 1 = 1 if whole bytes must be copied
; Bit 0 = 1 if right edge must be copied
;
; This is used for all cases where the source and destination are not both
; simultaneously addressable for our purposes, so we need to go through the
; temp buffer (only for 1 R/W and 1R/1W, and only sometimes).

MasterThreadTableViaBuffer label dword
                                ;unbanked (no need for buffer)
                                ;right-to-left
        dd      0               ;<not used>
        dd      Thread_R        ;R->L, R
        dd      Thread_W        ;R->L, W
        dd      Thread_RW       ;R->L, RW
        dd      Thread_L        ;R->L, L
        dd      Thread_RL       ;R->L, RL
        dd      Thread_WL       ;R->L, WL
        dd      Thread_RWL      ;R->L, RWL
                                ;left-to-right
        dd      0               ;<not used>
        dd      Thread_R        ;L->R, R
        dd      Thread_W        ;L->R, W
        dd      Thread_WR       ;L->R, WR
        dd      Thread_L        ;L->R, L
        dd      Thread_LR       ;L->R, LR
        dd      Thread_LW       ;L->R, LW
        dd      Thread_LWR      ;L->R, LWR

                                ;1 R/W banking window (everything goes through
                                ;                       buffer)
                                ;right-to-left
        dd      0               ;<not used>
        dd      Thread_Rb       ;R->L, R
        dd      Thread_Wb       ;R->L, W
        dd      Thread_RbWb     ;R->L, RW
        dd      Thread_Lb       ;R->L, L
        dd      Thread_RbLb     ;R->L, RL
        dd      Thread_WbLb     ;R->L, WL
        dd      Thread_RbWbLb   ;R->L, RWL
                                ;left-to-right
        dd      0               ;<not used>
        dd      Thread_Rb       ;L->R, R
        dd      Thread_Wb       ;L->R, W
        dd      Thread_WbRb     ;L->R, WR
        dd      Thread_Lb       ;L->R, L
        dd      Thread_LbRb     ;L->R, LR
        dd      Thread_LbWb     ;L->R, LW
        dd      Thread_LbWbRb   ;L->R, LWR

                                ;1R/1W banking window (edge go through buffer)
                                ;right-to-left
        dd      0               ;<not used>
        dd      Thread_Rb       ;R->L, R
        dd      Thread_W        ;R->L, W
        dd      Thread_RbW      ;R->L, RW
        dd      Thread_Lb       ;R->L, L
        dd      Thread_RbLb     ;R->L, RL
        dd      Thread_WLb      ;R->L, WL
        dd      Thread_RbWLb    ;R->L, RWL
                                ;left-to-right
        dd      0               ;<not used>
        dd      Thread_Rb       ;L->R, R
        dd      Thread_W        ;L->R, W
        dd      Thread_WRb      ;L->R, WR
        dd      Thread_Lb       ;L->R, L
        dd      Thread_LbRb     ;L->R, LR
        dd      Thread_LbW      ;L->R, LW
        dd      Thread_LbWRb    ;L->R, LWR

                                ;2 R/W banking window (no need for buffer)
                                ;right-to-left
        dd      0               ;<not used>
        dd      Thread_R        ;R->L, R
        dd      Thread_W        ;R->L, W
        dd      Thread_RW       ;R->L, RW
        dd      Thread_L        ;R->L, L
        dd      Thread_RL       ;R->L, RL
        dd      Thread_WL       ;R->L, WL
        dd      Thread_RWL      ;R->L, RWL
                                ;left-to-right
        dd      0               ;<not used>
        dd      Thread_R        ;L->R, R
        dd      Thread_W        ;L->R, W
        dd      Thread_WR       ;L->R, WR
        dd      Thread_L        ;L->R, L
        dd      Thread_LR       ;L->R, LR
        dd      Thread_LW       ;L->R, LW
        dd      Thread_LWR      ;L->R, LWR


; Amount to shift adapter type field left for use in MasterThreadTableViaBuffer.

ADAPTER_FIELD_SHIFT     equ     4

; Mask for setting left-to-right bit to "left-to-right true" for use in both
; MasterThread tables.

LEFT_TO_RIGHT_FIELD_SET equ     1000b


; Table of top-to-bottom loops for adapter types.

        align   4
TopToBottomLoopTable label dword
        dd      top_to_bottom_2RW       ;unbanked is same as 2RW
        dd      top_to_bottom_1RW
        dd      top_to_bottom_1R1W
        dd      top_to_bottom_2RW


; Table of bottom-to-top loops for adapter types.

        align   4
BottomToTopLoopTable label dword
        dd      bottom_to_top_2RW       ;unbanked is same as 2RW
        dd      bottom_to_top_1RW
        dd      bottom_to_top_1R1W
        dd      bottom_to_top_2RW


; Table of routines for setting up to copy in various directions.

        align   4
SetUpForCopyDirection   label   dword
        dd      left_to_right_top_to_bottom     ;CD_RIGHTDOWN
        dd      right_to_left_top_to_bottom     ;CD_LEFTDOWN
        dd      left_to_right_bottom_to_top     ;CD_RIGHTUP
        dd      right_to_left_bottom_to_top     ;CD_LEFTUP

;-----------------------------------------------------------------------;
; Left edge clip masks for intrabyte start addresses 0 through 7.
; Whole byte cases are flagged as 0ffh.

jLeftMaskTable  label   byte
        db      0ffh,07fh,03fh,01fh,00fh,007h,003h,001h

;-----------------------------------------------------------------------;
; Right edge clip masks for intrabyte end addresses (non-inclusive)
; 0 through 7. Whole byte cases are flagged as 0ffh.

jRightMaskTable label   byte
        db      0ffh,080h,0c0h,0e0h,0f0h,0f8h,0fch,0feh

;-----------------------------------------------------------------------;

        .code

_TEXT$03   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;-----------------------------------------------------------------------;

cProc   vAlignedSrcCopy,16,<        \
        uses    esi edi ebx,    \
        pdsurf: ptr DEVSURF,    \
        prcldest : ptr RECTL,   \
        pptlsrc : ptr POINTL,   \
        icopydir : dword

        local   culWholeBytesWidth : dword ;# of bytes to copy across each scan
        local   ulBlockHeight : dword   ;# of scans to copy per bank block
        local   ulWholeScanDelta : dword;offset from end of one whole bytes
                                        ; scan to start of next
        local   ulWholeBytesSrc : dword ;offset in bitmap of first source whole
                                        ; byte to copy from
        local   ulWholeBytesDest : dword;offset in bitmap of first source whole
                                        ; byte to copy to
        local   ulLeftEdgeSrc : dword   ;offset in bitmap of first source left
                                        ; edge byte to copy from
        local   ulLeftEdgeDest : dword  ;offset in bitmap of first dest left
                                        ; edge byte to copy to
        local   ulRightEdgeSrc : dword  ;offset in bitmap of first source right
                                        ; edge byte to copy from
        local   ulRightEdgeDest : dword ;offset in bitmap of first dest right
                                        ; edge byte to copy to
        local   ulNextScan : dword      ;width of scan, in bytes
        local   jLeftMask : dword       ;left edge clip mask
        local   jRightMask : dword      ;right edge clip mask
        local   culTempCount : dword    ;handy temporary counter
        local   pTempEntry : dword      ;temporary storage for vector into
                                        ; unrolled loop
        local   pTempPlane : dword      ;pointer to storage in temp buffer for
                                        ; edge bytes (which are stored
                                        ; consecutively, not in each plane's
                                        ; temp buffer, to reduce possible page
                                        ; faulting
        local   ppTempPlane0 : dword    ;pointer to pointer to storage in temp
                                        ; buffer for plane 0, immediately
                                        ; preceded by storage for planes 1, 2,
                                        ; and 3
        local   ppTempPlane3 : dword    ;like above, but for plane 3
        local   ulOffsetInBank : dword  ;offset relative to bank start
        local   pSrcAddr : dword        ;working pointer to first source
                                        ; byte to copy from
        local   pDestAddr : dword       ;working pointer to first dest
                                        ; byte to copy to
        local   ulCurrentJustification:dword ;justification used to map in
                                             ; banks; top for top to bottom
                                             ; copies, bottom for bottom to top
        local   ulCurrentSrcScan :dword ;scan line used to map in current
                                        ; source bank
        local   ulCurrentDestScan:dword ;scan line used to map in current dest
                                        ; bank
        local   ulLastDestScan :dword   ;scan in target rect at which we stop
                                        ; advancing through banks
        local   pCurrentThread : dword  ;pointer to data describing the
                                        ; threaded calls to be performed to
                                        ; perform the current copy
        local   pCurrentThreadViaBuffer:dword
                                        ;pointer to data describing the
                                        ; threaded calls to be performed to
                                        ; perform the current copy in the case
                                        ; where the source and destination are
                                        ; not simultaneously adequately
                                        ; accessible, so the copy has to go
                                        ; through a temp buffer (used only for
                                        ; 1 R/W and 1R/1W banking)
        local   ulAdapterType : dword   ;adapter type code, per VIDEO_BANK_TYPE
        local   ulLWRType : dword       ;whether left edge, whole bytes, and
                                        ; right edge are involved in the
                                        ; current operation;
                                        ; bit 2 = 1 if left edge involved
                                        ; bit 1 = 1 if whole bytes involved
                                        ; bit 0 = 1 if right edge involved
        local   ulLeftEdgeAdjust :dword ;used to bump the whole bytes start
                                        ; address past the left edge when the
                                        ; left edge is partial

;-----------------------------------------------------------------------;

; Set pointers to temp buffer plane pointers (used only by 1 R/W and 1R/1W
; adapters), and other rectangle-independent variables.

        mov     esi,pdsurf
        mov     eax,[esi].dsurf_pvBankBufferPlane0
        mov     pTempPlane,eax
        lea     eax,[esi].dsurf_pvBankBufferPlane0
        mov     ppTempPlane0,eax
        lea     eax,[esi].dsurf_pvBankBufferPlane3
        mov     ppTempPlane3,eax

        mov     eax,[esi].dsurf_vbtBankingType
        mov     ulAdapterType,eax

; Copy the rectangle.

        call    copy_rect

;-----------------------------------------------------------------------;
; Set the VGA registers back to their default state.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax           ;enable bit mask for all bits

        mov     dl,SEQ_DATA
        mov     al,MM_ALL
        out     dx,al           ;enable writes to all planes

        cld                     ;restore default direction flag

        cRet    vAlignedSrcCopy ;done


;***********************************************************************;
;
; Copies the specified rectangle.
;
;***********************************************************************;

copy_rect:

; Set up masks and whole bytes count, and build left/whole/right index
; indicating which of those parts are involved in the copy.

        mov     edi,prcldest            ;point to rectangle to copy

        mov     ebx,[edi].xRight        ;right edge of fill (non-inclusive)
        mov     ecx,ebx
        and     ecx,0111b               ;intrabyte address of right edge
        mov     ah,jRightMaskTable[ecx] ;right edge mask

        mov     esi,[edi].xLeft         ;left edge of fill (inclusive)
        mov     ecx,esi
        shr     ecx,3                   ;/8 for start offset from left edge
                                        ; of scan line
        sub     ebx,esi                 ;width in pixels of fill

        and     esi,0111b               ;intrabyte address of left edge
        mov     al,jLeftMaskTable[esi]  ;left edge mask

        dec     ebx                     ;make inclusive on right
        add     ebx,esi                 ;inclusive width, starting counting at
                                        ; the beginning of the left edge byte
        shr     ebx,3                   ;width of fill in bytes touched - 1
        jnz     short more_than_1_byte  ;more than 1 byte is involved

; Only one byte will be affected. Combine first/last masks.

        and     al,ah                   ;we'll use first byte mask only
        xor     ah,ah                   ;want last byte mask to be 0 to
                                        ; indicate right edge not involved
        inc     ebx                     ;so there's one count to subtract below
                                        ; if this isn't a whole edge byte
more_than_1_byte:

; If all pixels in the left edge are altered, combine the first byte into the
; whole byte count, because we can handle solid edge bytes faster as part of
; the whole bytes. Ditto for the right edge.

        sub     ecx,ecx                 ;edge whole-status accumulator
        cmp     al,-1                   ;is left edge a whole byte or partial?
        adc     ecx,ecx                 ;ECX=1 if left edge partial, 0 if whole
        sub     ebx,ecx                 ;if left edge partial, deduct it from
                                        ; the whole bytes count
        mov     ulLeftEdgeAdjust,ecx    ;for skipping over the left edge if
                                        ; it's partial when pointing to the
                                        ; whole bytes
        and     ah,ah                   ;is right edge mask 0, meaning this
                                        ; fill is only 1 byte wide?
        jz      short save_masks        ;yes, no need to do anything
        or      ecx,40h                 ;assume there's a partial right edge
        cmp     ah,-1                   ;is right edge a whole byte or partial?
        jnz     short save_masks        ;partial
                                        ;bit 1=0 if left edge partial, 1 whole
        inc     ebx                     ;if right edge whole, include it in the
                                        ; whole bytes count
        and     ecx,not 40h             ;there's no partial right edge
save_masks:
        cmp     ebx,1                   ;do we have any whole bytes?
        cmc                             ;CF set if whole byte count > 0
        adc     ecx,ecx                 ;if any whole bytes, set whole bytes
                                        ; bit in left/whole/right accumulator
        rol     cl,1                    ;align the left/whole/right bits
        mov     ulLWRType,ecx           ;save left/whole/right status

        mov     byte ptr jLeftMask,al   ;save left and right clip masks
        mov     byte ptr jRightMask,ah
        mov     culWholeBytesWidth,ebx  ;save # of whole bytes

; Copy the rectangle in the specified direction.

        mov     eax,icopydir
        jmp     SetUpForCopyDirection[eax*4]


;***********************************************************************;
;
; The following routines set up to handle the four possible copy
; directions.
;
;***********************************************************************;


;-----------------------------------------------------------------------;
; Set-up code for left-to-right, top-to-bottom copies.
;-----------------------------------------------------------------------;

left_to_right_top_to_bottom::

        cld                             ;we'll copy left to right

        mov     esi,pdsurf
        mov     eax,[esi].dsurf_lNextScan
        mov     ulNextScan,eax          ;copy top to bottom
        sub     eax,culWholeBytesWidth  ;offset from end of one whole byte scan
        mov     ulWholeScanDelta,eax    ; to start of next

        mov     esi,ulLWRType           ;3-bit flag field for left, whole, and
                                        ; right involvement in operation
        or      esi,LEFT_TO_RIGHT_FIELD_SET   ;add left-to-right into the index
        mov     eax,MasterThreadTable[esi*4]
        mov     pCurrentThread,eax      ;threading when no buffering is needed
        mov     edx,ulAdapterType
        shl     edx,ADAPTER_FIELD_SHIFT
        or      esi,edx                 ;factor adapter type into the index
        mov     eax,MasterThreadTableViaBuffer[esi*4]
        mov     pCurrentThreadViaBuffer,eax ;threading when buffering is needed

        mov     ulCurrentJustification,JustifyTop ;copy top to bottom

        mov     esi,prcldest
        mov     eax,[esi].yBottom
        mov     ulLastDestScan,eax      ;end at bottom of dest copy rect
        mov     eax,[esi].yTop
        mov     ulCurrentDestScan,eax   ;start at top of dest copy rect
        mul     ulNextScan              ;offset in bitmap of top dest rect scan
        mov     edx,[esi].xLeft
        shr     edx,3                   ;byte X address
        add     eax,edx                 ;offset in bitmap of first dest byte
        mov     ulLeftEdgeDest,eax      ;that's where the left dest edge is
        add     eax,ulLeftEdgeAdjust    ;the whole bytes start at the next
                                        ; byte, unless the left edge is a whole
                                        ; byte and is thus part of the whole
                                        ; bytes already
        mov     ulWholeBytesDest,eax    ;where the whole dest bytes start
        add     eax,culWholeBytesWidth  ;point to the right edge
        mov     ulRightEdgeDest,eax     ;where the right dest edge starts

        mov     esi,pptlsrc
        mov     eax,[esi].ptl_y
        mov     ulCurrentSrcScan,eax    ;start at top of source copy rect
        mul     ulNextScan              ;offset in bitmap of top dest rect scan
        mov     edx,[esi].ptl_x
        shr     edx,3                   ;byte X address
        add     eax,edx                 ;offset in bitmap of first source byte
        mov     ulLeftEdgeSrc,eax       ;that's where the left src edge is
        add     eax,ulLeftEdgeAdjust    ;the whole bytes start at the next
                                        ; byte, unless the left edge is a whole
                                        ; byte and is thus part of the whole
                                        ; bytes already
        mov     ulWholeBytesSrc,eax     ;where the src whole bytes start
        add     eax,culWholeBytesWidth  ;point to the right edge
        mov     ulRightEdgeSrc,eax      ;where the right src edge starts

; Branch to the appropriate top-to-bottom bank enumeration loop.

        mov     eax,ulAdapterType
        jmp     TopToBottomLoopTable[eax*4]


;-----------------------------------------------------------------------;
; Set-up code for right-to-left, top-to-bottom copies.
;-----------------------------------------------------------------------;

right_to_left_top_to_bottom::

        std                             ;we'll copy right to left

        mov     esi,pdsurf
        mov     eax,[esi].dsurf_lNextScan
        mov     ulNextScan,eax          ;copy top to bottom
        add     eax,culWholeBytesWidth  ;offset from end of one whole byte scan
        mov     ulWholeScanDelta,eax    ; to start of next, given that we're
                                        ; copying one way and going scan-to-
                                        ; scan the other way
        mov     esi,ulLWRType           ;3-bit flag field for left, whole, and
                                        ; right involvement in operation
                                        ;leave left-to-right field cleared, so
                                        ; we look up right-to-left entries
        mov     eax,MasterThreadTable[esi*4]
        mov     pCurrentThread,eax      ;threading when no buffering is needed
        mov     edx,ulAdapterType
        shl     edx,ADAPTER_FIELD_SHIFT
        or      esi,edx                 ;factor adapter type into the index
        mov     eax,MasterThreadTableViaBuffer[esi*4]
        mov     pCurrentThreadViaBuffer,eax ;threading when buffering is needed

        mov     ulCurrentJustification,JustifyTop ;copy top to bottom

        mov     esi,prcldest
        mov     eax,[esi].yBottom
        mov     ulLastDestScan,eax      ;end at bottom of dest copy rect
        mov     eax,[esi].yTop
        mov     ulCurrentDestScan,eax   ;start at top of dest copy rect
        mul     ulNextScan              ;offset in bitmap of top dest rect scan
        mov     edx,[esi].xLeft
        shr     edx,3                   ;byte X address
        add     eax,edx                 ;offset in bitmap of first dest byte
        mov     ulLeftEdgeDest,eax      ;that's where the left dest edge is
        add     eax,ulLeftEdgeAdjust    ;the whole bytes start at the next
                                        ; byte, unless the left edge is a whole
                                        ; byte and is thus part of the whole
                                        ; bytes already
        add     eax,culWholeBytesWidth  ;point to the right edge
        mov     ulRightEdgeDest,eax     ;where the right dest edge starts
        dec     eax                     ;back up to the last whole byte
        mov     ulWholeBytesDest,eax    ;where the whole dest bytes start

        mov     esi,pptlsrc
        mov     eax,[esi].ptl_y
        mov     ulCurrentSrcScan,eax    ;start at top of source copy rect
        mul     ulNextScan              ;offset in bitmap of top dest rect scan
        mov     edx,[esi].ptl_x
        shr     edx,3                   ;byte X address
        add     eax,edx                 ;offset in bitmap of first source byte
        mov     ulLeftEdgeSrc,eax       ;that's where the left src edge is
        add     eax,ulLeftEdgeAdjust    ;the whole bytes start at the next
                                        ; byte, unless the left edge is a whole
                                        ; byte and is thus part of the whole
                                        ; bytes already
        add     eax,culWholeBytesWidth  ;point to the right edge
        mov     ulRightEdgeSrc,eax      ;where the right src edge starts
        dec     eax                     ;back up to the last whole byte
        mov     ulWholeBytesSrc,eax     ;where the src whole bytes start

; Branch to the appropriate top-to-bottom bank enumeration loop.

        mov     eax,ulAdapterType
        jmp     TopToBottomLoopTable[eax*4]



;-----------------------------------------------------------------------;
; Set-up code for left-to-right, bottom-to-top copies.
;-----------------------------------------------------------------------;

left_to_right_bottom_to_top::

        cld                             ;we'll copy left to right

        mov     edi,pdsurf
        mov     eax,[edi].dsurf_lNextScan
        neg     eax
        mov     ulNextScan,eax          ;copy bottom to top
        sub     eax,culWholeBytesWidth  ;offset from end of one whole byte scan
        mov     ulWholeScanDelta,eax    ; to start of next, given that we're
                                        ; copying one way and going scan-to-
                                        ; scan the other way
        mov     esi,ulLWRType           ;3-bit flag field for left, whole, and
                                        ; right involvement in operation
        or      esi,LEFT_TO_RIGHT_FIELD_SET   ;add left-to-right into the index
        mov     eax,MasterThreadTable[esi*4]
        mov     pCurrentThread,eax      ;threading when no buffering is needed
        mov     edx,ulAdapterType
        shl     edx,ADAPTER_FIELD_SHIFT
        or      esi,edx                 ;factor adapter type into the index
        mov     eax,MasterThreadTableViaBuffer[esi*4]
        mov     pCurrentThreadViaBuffer,eax ;threading when buffering is needed

        mov     ulCurrentJustification,JustifyBottom ;copy bottom to top

        mov     esi,prcldest
        mov     edx,[esi].yTop
        mov     ulLastDestScan,edx      ;end at top of dest copy rect
        mov     eax,[esi].yBottom
        dec     eax                     ;rectangle definition is non-inclusive,
                                        ; so advance to first scan we'll copy
        sub     edx,eax                 ;-(offset from rect top to bottom)
        push    edx                     ;remember for use with source
        mov     ulCurrentDestScan,eax   ;start at bottom of dest copy rect
        mul     [edi].dsurf_lNextScan   ;offset in bitmap of bottom dest rect
                                        ; scan (first scan to which to copy)
        mov     edx,[esi].xLeft
        shr     edx,3                   ;byte X address
        add     eax,edx                 ;offset in bitmap of first dest byte
        mov     ulLeftEdgeDest,eax      ;that's where the left dest edge is
        add     eax,ulLeftEdgeAdjust    ;the whole bytes start at the next
                                        ; byte, unless the left edge is a whole
                                        ; byte and is thus part of the whole
                                        ; bytes already
        mov     ulWholeBytesDest,eax    ;where the whole dest bytes start
        add     eax,culWholeBytesWidth  ;point to the right edge
        mov     ulRightEdgeDest,eax     ;where the right dest edge starts

        mov     esi,pptlsrc
        mov     eax,[esi].ptl_y
        pop     edx                     ;retrieve -(offset from top to bottom)
        sub     eax,edx                 ;advance to bottom of source rect
                                        ; (inclusive; this is first scan from
                                        ; which to copy)
        mov     ulCurrentSrcScan,eax    ;start at bottom of source copy rect
        mul     [edi].dsurf_lNextScan   ;offset in bitmap of bottom dest rect
                                        ; scan
        mov     edx,[esi].ptl_x
        shr     edx,3                   ;byte X address
        add     eax,edx                 ;offset in bitmap of first source byte
        mov     ulLeftEdgeSrc,eax       ;that's where the left src edge is
        add     eax,ulLeftEdgeAdjust    ;the whole bytes start at the next
                                        ; byte, unless the left edge is a whole
                                        ; byte and is thus part of the whole
                                        ; bytes already
        mov     ulWholeBytesSrc,eax     ;where the src whole bytes start
        add     eax,culWholeBytesWidth  ;point to the right edge
        mov     ulRightEdgeSrc,eax      ;where the right src edge starts

; Branch to the appropriate bottom-to-top bank enumeration loop.

        mov     eax,ulAdapterType
        jmp     BottomToTopLoopTable[eax*4]


;-----------------------------------------------------------------------;
; Set-up code for right-to-left, bottom-to-top copies.
;-----------------------------------------------------------------------;

right_to_left_bottom_to_top::

        std                             ;we'll copy right to left

        mov     edi,pdsurf
        mov     eax,[edi].dsurf_lNextScan
        neg     eax
        mov     ulNextScan,eax          ;copy bottom to top
        add     eax,culWholeBytesWidth  ;offset from end of one whole byte scan
        mov     ulWholeScanDelta,eax    ; to start of next
        mov     esi,ulLWRType           ;3-bit flag field for left, whole, and
                                        ; right involvement in operation
                                        ;leave left-to-right field cleared, so
                                        ; we look up right-to-left entries
        mov     eax,MasterThreadTable[esi*4]
        mov     pCurrentThread,eax      ;threading when no buffering is needed
        mov     edx,ulAdapterType
        shl     edx,ADAPTER_FIELD_SHIFT
        or      esi,edx                 ;factor adapter type into the index
        mov     eax,MasterThreadTableViaBuffer[esi*4]
        mov     pCurrentThreadViaBuffer,eax ;threading when buffering is needed

        mov     ulCurrentJustification,JustifyBottom ;copy bottom to top

        mov     esi,prcldest
        mov     edx,[esi].yTop
        mov     ulLastDestScan,edx      ;end at top of dest copy rect
        mov     eax,[esi].yBottom
        dec     eax                     ;rectangle definition is non-inclusive,
                                        ; so advance to first scan we'll copy
        sub     edx,eax                 ;-(offset from rect top to bottom)
        push    edx                     ;remember for use with source
        mov     ulCurrentDestScan,eax   ;start at bottom of dest copy rect
        mul     [edi].dsurf_lNextScan   ;offset in bitmap of bottom dest rect
                                        ; scan (first scan to which to copy)
        mov     edx,[esi].xLeft
        shr     edx,3                   ;byte X address
        add     eax,edx
        mov     ulLeftEdgeDest,eax      ;that's where the left dest edge is
        add     eax,ulLeftEdgeAdjust    ;the whole bytes start at the next
                                        ; byte, unless the left edge is a whole
                                        ; byte and is thus part of the whole
                                        ; bytes already
        add     eax,culWholeBytesWidth  ;point to the right edge
        mov     ulRightEdgeDest,eax     ;where the right dest edge starts
        dec     eax                     ;back up to the last whole byte
        mov     ulWholeBytesDest,eax    ;where the whole dest bytes start

        mov     esi,pptlsrc
        mov     eax,[esi].ptl_y
        pop     edx                     ;retrieve -(offset from top to bottom)
        sub     eax,edx                 ;advance to bottom of source rect
                                        ; (inclusive; this is first scan from
                                        ; which to copy)
        mov     ulCurrentSrcScan,eax    ;start at bottom of source copy rect
        mul     [edi].dsurf_lNextScan   ;offset in bitmap of bottom dest rect
                                        ; scan
        mov     edx,[esi].ptl_x
        shr     edx,3                   ;byte X address
        add     eax,edx                 ;offset in bitmap of first source byte
        mov     ulLeftEdgeSrc,eax       ;that's where the left src edge is
        add     eax,ulLeftEdgeAdjust    ;the whole bytes start at the next
                                        ; byte, unless the left edge is a whole
                                        ; byte and is thus part of the whole
                                        ; bytes already
        add     eax,culWholeBytesWidth  ;point to the right edge
        mov     ulRightEdgeSrc,eax      ;where the right src edge starts
        dec     eax                     ;back up to the last whole byte
        mov     ulWholeBytesSrc,eax     ;where the src whole bytes start

; Branch to the appropriate bottom-to-top bank enumeration loop.

        mov     eax,ulAdapterType
        jmp     BottomToTopLoopTable[eax*4]


;***********************************************************************;
;
; The following routines are the banking loops.
;
;***********************************************************************;


;-----------------------------------------------------------------------;
; Banking for 2 R/W and unbanked adapters, top to bottom.
;-----------------------------------------------------------------------;
top_to_bottom_2RW::

; We're going top to bottom. Map in the source and dest, top-justified.

        mov     ebx,pdsurf
        mov     edx,ulCurrentSrcScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yTop ;is source top less than
                                                     ; current source bank?
        jl      short top_2RW_map_init_src_bank      ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yBottom ;source top greater than
                                                        ; current source bank?
        jl      short top_2RW_init_src_bank_mapped
                                                ;no, proper bank already mapped
top_2RW_map_init_src_bank:

; Map bank containing the top source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyTop,MapSourceBank>

top_2RW_init_src_bank_mapped:

        mov     edx,ulCurrentDestScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yTop ;is dest top less than
                                                     ; current dest bank?
        jl      short top_2RW_map_init_dest_bank     ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yBottom ;dest top greater than
                                                        ; current dest bank?
        jl      short top_2RW_init_dest_bank_mapped
                                                ;no, proper bank already mapped
top_2RW_map_init_dest_bank:

; Map bank containing the top dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyTop,MapDestBank>

top_2RW_init_dest_bank_mapped:

; Bank-by-bank top-to-bottom copy loop.

top_2RW_bank_loop:

; Decide how far we can go before we run out of bank or rectangle to copy.

        mov     edx,ulLastDestScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yBottom
        jl      short @F        ;copy rectangle bottom is in this bank
        mov     edx,[ebx].dsurf_rcl2WindowClipD.yBottom ;dest extends to end
                                                        ; of bank, at least
@@:
        sub     edx,ulCurrentDestScan   ;# of scans we can and want to do in
                                        ; the dest bank
        mov     eax,[ebx].dsurf_rcl2WindowClipS.yBottom
        sub     eax,ulCurrentSrcScan    ;# of scans we can do in the src bank

        cmp     edx,eax
        jb      short @F        ;source bank isn't limiting
        mov     edx,eax         ;source bank is limiting
@@:
        mov     ulBlockHeight,edx ;# of scans we'll do in this bank

; We're ready to copy this block.

        THREAD_AND_START

; Any more scans to copy?

        mov     eax,ulCurrentDestScan
        mov     esi,ulBlockHeight
        add     eax,esi                 ;we've copied to dest up to here
        cmp     ulLastDestScan,eax      ;are we at the dest rect bottom?
        jz      short top_2RW_done      ;yes, we're done
        mov     ulCurrentDestScan,eax

; Now advance either or both banks, as needed.

        mov     ebx,pdsurf
        cmp     eax,[ebx].dsurf_rcl2WindowClipD.yBottom ;dest scan greater than
                                                        ; current dest bank?
        jl      short top_2RW_dest_bank_mapped    ;no, proper bank still mapped

; Map bank containing the current dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,eax,JustifyTop,MapDestBank>

top_2RW_dest_bank_mapped:

        add     esi,ulCurrentSrcScan    ;we've copied from source up to here
        mov     ulCurrentSrcScan,esi

        cmp     esi,[ebx].dsurf_rcl2WindowClipS.yBottom ;src scan greater than
                                                        ; current src bank?
        jl      short top_2RW_src_bank_mapped     ;no, proper bank still mapped

; Map bank containing the current source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,esi,JustifyTop,MapSourceBank>

top_2RW_src_bank_mapped:

        jmp     top_2RW_bank_loop

top_2RW_done:
        PLAIN_RET


;-----------------------------------------------------------------------;
; Banking for 2 R/W and unbanked adapters, bottom to top.
;-----------------------------------------------------------------------;
bottom_to_top_2RW::

; We're going bottom to top. Map in the source and dest, bottom-justified.

        mov     ebx,pdsurf
        mov     edx,ulCurrentSrcScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yTop ;is source bottom less than
                                                     ; current source bank?
        jl      short bot_2RW_map_init_src_bank      ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yBottom ;source bottom greater
                                                        ; than current src bank?
        jl      short bot_2RW_init_src_bank_mapped
                                                ;no, proper bank already mapped
bot_2RW_map_init_src_bank:

; Map bank containing the bottom source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyBottom,MapSourceBank>

bot_2RW_init_src_bank_mapped:

        mov     edx,ulCurrentDestScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yTop ;is dest bottom less than
                                                     ; current dest bank?
        jl      short bot_2RW_map_init_dest_bank     ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yBottom ;dest bottom greater
                                                        ; than current dst bank?
        jl      short bot_2RW_init_dest_bank_mapped
                                                ;no, proper bank already mapped
bot_2RW_map_init_dest_bank:

; Map bank containing the bottom dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyBottom,MapDestBank>

bot_2RW_init_dest_bank_mapped:

; Bank-by-bank bottom-to-top copy loop.

bot_2RW_bank_loop:

; Decide how far we can go before we run out of bank or rectangle to copy.

        mov     edx,ulLastDestScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yTop
        jg      short @F        ;copy rectangle top is in this bank
        mov     edx,[ebx].dsurf_rcl2WindowClipD.yTop ;dest extends to end
                                                     ; of bank, at least
@@:
        neg     edx
        add     edx,ulCurrentDestScan   ;# of scans we can and want to do in
        inc     edx                     ; the dest bank

        mov     eax,ulCurrentSrcScan
        sub     eax,[ebx].dsurf_rcl2WindowClipS.yTop
        inc     eax                     ;# of scans we can do in the src bank

        cmp     edx,eax
        jb      short @F        ;source bank isn't limiting
        mov     edx,eax         ;source bank is limiting
@@:
        mov     ulBlockHeight,edx ;# of scans we'll do in this bank

; We're ready to copy this block.

        THREAD_AND_START

; Any more scans to copy?

        mov     eax,ulCurrentDestScan
        mov     esi,ulBlockHeight
        sub     eax,esi                 ;we've copied to dest up to here
        cmp     ulLastDestScan,eax      ;are we past the dest rect top?
        jg      short bot_2RW_done      ;yes, we're done
        mov     ulCurrentDestScan,eax

; Now advance either or both banks, as needed.

        mov     ebx,pdsurf
        cmp     eax,[ebx].dsurf_rcl2WindowClipD.yTop ;dest scan less than
                                                     ; current dest bank?
        jge     short bot_2RW_dest_bank_mapped    ;no, proper bank still mapped

; Map bank containing the current dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,eax,JustifyBottom,MapDestBank>

bot_2RW_dest_bank_mapped:

        mov     eax,ulCurrentSrcScan
        sub     eax,esi         ;we've copied from source up to here
        mov     ulCurrentSrcScan,eax

        cmp     eax,[ebx].dsurf_rcl2WindowClipS.yTop ;src scan less than
                                                     ; current src bank?
        jge     short bot_2RW_src_bank_mapped     ;no, proper bank still mapped

; Map bank containing the current source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,eax,JustifyBottom,MapSourceBank>

bot_2RW_src_bank_mapped:

        jmp     bot_2RW_bank_loop

bot_2RW_done:
        PLAIN_RET


;-----------------------------------------------------------------------;
; Banking for 1R/1W adapters, top to bottom.
;-----------------------------------------------------------------------;
top_to_bottom_1R1W::

; We're going top to bottom. Map in the source and dest, top-justified.

        mov     ebx,pdsurf
        mov     edx,ulCurrentSrcScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yTop ;is source top less than
                                                     ; current source bank?
        jl      short top_1R1W_map_init_src_bank      ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yBottom ;source top greater than
                                                        ; current source bank?
        jl      short top_1R1W_init_src_bank_mapped
                                                ;no, proper bank already mapped
top_1R1W_map_init_src_bank:

; Map bank containing the top source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyTop,MapSourceBank>

top_1R1W_init_src_bank_mapped:

        mov     edx,ulCurrentDestScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yTop ;is dest top less than
                                                     ; current dest bank?
        jl      short top_1R1W_map_init_dest_bank     ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yBottom ;dest top greater than
                                                        ; current dest bank?
        jl      short top_1R1W_init_dest_bank_mapped
                                                ;no, proper bank already mapped
top_1R1W_map_init_dest_bank:

; Map bank containing the top dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyTop,MapDestBank>

top_1R1W_init_dest_bank_mapped:

; Bank-by-bank top-to-bottom copy loop.

top_1R1W_bank_loop:

; Decide how far we can go before we run out of bank or rectangle to copy.

        mov     edx,ulLastDestScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yBottom
        jl      short @F        ;copy rectangle bottom is in this bank
        mov     edx,[ebx].dsurf_rcl2WindowClipD.yBottom ;dest extends to end
                                                        ; of bank, at least
@@:
        sub     edx,ulCurrentDestScan   ;# of scans we can and want to do in
                                        ; the dest bank
        mov     eax,[ebx].dsurf_rcl2WindowClipS.yBottom
        sub     eax,ulCurrentSrcScan    ;# of scans we can do in the src bank

        cmp     edx,eax
        jb      short @F        ;source bank isn't limiting
        mov     edx,eax         ;source bank is limiting
@@:
        mov     ulBlockHeight,edx ;# of scans we'll do in this bank

; We're ready to copy this block.
; Select different threading, depending on whether the source and destination
; are currently in the same bank; we can do edges faster if they are.

        mov     eax,[ebx].dsurf_ulWindowBank
        cmp     eax,[ebx].dsurf_ulWindowBank[4]
        jz      short top_1R1W_copy_same_bank

; Source and dest are currently in different banks, must go through temp buffer.

        THREAD_AND_START pCurrentThreadViaBuffer,top_1R1W_check_more_scans

; Source and dest are currently in the same bank.

top_1R1W_copy_same_bank:
        THREAD_AND_START

; Any more scans to copy?

top_1R1W_check_more_scans:

        mov     eax,ulCurrentDestScan
        mov     esi,ulBlockHeight
        add     eax,esi                 ;we've copied to dest up to here
        cmp     ulLastDestScan,eax      ;are we at the dest rect bottom?
        jz      short top_1R1W_done     ;yes, we're done
        mov     ulCurrentDestScan,eax

; Now advance either or both banks, as needed.

        mov     ebx,pdsurf
        cmp     eax,[ebx].dsurf_rcl2WindowClipD.yBottom ;dest scan greater than
                                                        ; current dest bank?
        jl      short top_1R1W_dest_bank_mapped   ;no, proper bank still mapped

; Map bank containing the current dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,eax,JustifyTop,MapDestBank>

top_1R1W_dest_bank_mapped:

        add     esi,ulCurrentSrcScan    ;we've copied from source up to here
        mov     ulCurrentSrcScan,esi

        cmp     esi,[ebx].dsurf_rcl2WindowClipS.yBottom ;src scan greater than
                                                        ; current src bank?
        jl      short top_1R1W_src_bank_mapped     ;no, proper bank still mapped

; Map bank containing the current source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,esi,JustifyTop,MapSourceBank>

top_1R1W_src_bank_mapped:

        jmp     top_1R1W_bank_loop

top_1R1W_done:
        PLAIN_RET


;-----------------------------------------------------------------------;
; Banking for 1R/1W adapters, bottom to top.
;-----------------------------------------------------------------------;
bottom_to_top_1R1W::

; We're going bottom to top. Map in the source and dest, bottom-justified.

        mov     ebx,pdsurf
        mov     edx,ulCurrentSrcScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yTop ;is source bottom less than
                                                     ; current source bank?
        jl      short bot_1R1W_map_init_src_bank      ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yBottom ;source bottom greater
                                                        ; than current src bank?
        jl      short bot_1R1W_init_src_bank_mapped
                                                ;no, proper bank already mapped
bot_1R1W_map_init_src_bank:

; Map bank containing the bottom source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyBottom,MapSourceBank>

bot_1R1W_init_src_bank_mapped:

        mov     edx,ulCurrentDestScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yTop ;is dest bottom less than
                                                     ; current dest bank?
        jl      short bot_1R1W_map_init_dest_bank     ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yBottom ;dest bottom greater
                                                        ; than current dst bank?
        jl      short bot_1R1W_init_dest_bank_mapped
                                                ;no, proper bank already mapped
bot_1R1W_map_init_dest_bank:

; Map bank containing the bottom dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyBottom,MapDestBank>

bot_1R1W_init_dest_bank_mapped:

; Bank-by-bank bottom-to-top copy loop.

bot_1R1W_bank_loop:

; Decide how far we can go before we run out of bank or rectangle to copy.

        mov     edx,ulLastDestScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yTop
        jg      short @F        ;copy rectangle top is in this bank
        mov     edx,[ebx].dsurf_rcl2WindowClipD.yTop ;dest extends to end
                                                     ; of bank, at least
@@:
        neg     edx
        add     edx,ulCurrentDestScan   ;# of scans we can and want to do in
        inc     edx                     ; the dest bank

        mov     eax,ulCurrentSrcScan
        sub     eax,[ebx].dsurf_rcl2WindowClipS.yTop
        inc     eax                     ;# of scans we can do in the src bank

        cmp     edx,eax
        jb      short @F        ;source bank isn't limiting
        mov     edx,eax         ;source bank is limiting
@@:
        mov     ulBlockHeight,edx ;# of scans we'll do in this bank

; We're ready to copy this block.
; Select different threading, depending on whether the source and destination
; are currently in the same bank; we can do edges faster if they are.

        mov     al,byte ptr [ebx].dsurf_ulWindowBank
        cmp     al,byte ptr [ebx].dsurf_ulWindowBank[4]
        jz      short bot_1R1W_copy_same_bank

; Source and dest are currently in different banks, must go through temp buffer.

        THREAD_AND_START pCurrentThreadViaBuffer,bot_1R1W_check_more_scans

; Source and dest are currently in the same bank.

bot_1R1W_copy_same_bank:
        THREAD_AND_START

; Any more scans to copy?

bot_1R1W_check_more_scans:

        mov     eax,ulCurrentDestScan
        mov     esi,ulBlockHeight
        sub     eax,esi                 ;we've copied to dest up to here
        cmp     ulLastDestScan,eax      ;are we past the dest rect top?
        jg      short bot_1R1W_done     ;yes, we're done
        mov     ulCurrentDestScan,eax

; Now advance either or both banks, as needed.

        mov     ebx,pdsurf
        cmp     eax,[ebx].dsurf_rcl2WindowClipD.yTop ;dest scan less than
                                                     ; current dest bank?
        jge     short bot_1R1W_dest_bank_mapped   ;no, proper bank still mapped

; Map bank containing the current dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,eax,JustifyBottom,MapDestBank>

bot_1R1W_dest_bank_mapped:

        mov     eax,ulCurrentSrcScan
        sub     eax,esi         ;we've copied from source up to here
        mov     ulCurrentSrcScan,eax

        cmp     eax,[ebx].dsurf_rcl2WindowClipS.yTop ;src scan less than
                                                     ; current src bank?
        jge     short bot_1R1W_src_bank_mapped    ;no, proper bank still mapped

; Map bank containing the current source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,eax,JustifyBottom,MapSourceBank>

bot_1R1W_src_bank_mapped:

        jmp     bot_1R1W_bank_loop

bot_1R1W_done:
        PLAIN_RET


;-----------------------------------------------------------------------;
; Banking for 1 R/W adapters, top to bottom.
;-----------------------------------------------------------------------;
top_to_bottom_1RW::

; We're going top to bottom. Map in the dest, top-justified.

        mov     ebx,pdsurf
        mov     esi,ulCurrentDestScan
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yTop  ;is dest top less than
                                                     ; current bank?
        jl      short top_1RW_map_init_dest_bank     ;yes, map in proper bank
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yBottom ;dest top greater than
                                                        ; current bank?
        jl      short top_1RW_init_dest_bank_mapped
                                                ;no, proper bank already mapped
top_1RW_map_init_dest_bank:

; Map bank containing the top dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl>,<ebx,esi,JustifyTop>

top_1RW_init_dest_bank_mapped:

; Bank-by-bank top-to-bottom copy loop.

top_1RW_bank_loop:

; Decide how far we can go before we run out of bank or rectangle to copy.

        mov     edi,ulLastDestScan
        cmp     edi,[ebx].dsurf_rcl1WindowClip.yBottom
        jl      short @F        ;copy rectangle bottom is in this bank
        mov     edi,[ebx].dsurf_rcl1WindowClip.yBottom ;dest extends to end
                                                       ; of bank, at least
@@:
        sub     edi,esi   ;# of scans we can and want to do in the dest bank

; Now make sure source is mapped in. This is the condition the copying routines
; expect, and we need to figure out how far we can go in the source.

        sub     edx,edx                 ;assume source and dest are in the same
                                        ; bank
        mov     esi,ulCurrentSrcScan
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yTop ;src scan less than
                                                    ; current bank?
        jl      short top_1RW_map_src_Bank          ;yes, must map in
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yBottom ;src scan greater than
                                                       ; current bank?
        jl      short top_1RW_src_bank_mapped     ;no, proper bank still mapped

top_1RW_map_src_Bank:

; Map bank containing the current source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl>,<ebx,esi,JustifyTop>

        mov     edx,1                   ;mark that source and dest are not in
                                        ; the same bank
top_1RW_src_bank_mapped:

        mov     eax,[ebx].dsurf_rcl1WindowClip.yBottom
        sub     eax,esi         ;# of scans we can do in the src bank

        cmp     edi,eax
        jb      short @F        ;source bank isn't limiting
        mov     edi,eax         ;source bank is limiting
@@:
        mov     ulBlockHeight,edi ;# of scans we'll do in this bank

; We're ready to copy this block.
; Select different threading, depending on whether the source and destination
; are currently in the same bank; we can do edges faster if they are.

        and     edx,edx
        jz      short top_1RW_copy_same_bank

; Source and dest are currently in different banks, must go through temp buffer.

        THREAD_AND_START pCurrentThreadViaBuffer,top_1RW_check_more_scans

; Source and dest are currently in the same bank.

top_1RW_copy_same_bank:
        THREAD_AND_START

; Any more scans to copy?

top_1RW_check_more_scans:

        mov     esi,ulCurrentDestScan
        mov     edi,ulBlockHeight
        add     esi,edi                 ;we've copied to dest up to here
        cmp     ulLastDestScan,esi      ;are we at the dest rect bottom?
        jz      short top_1RW_done      ;yes, we're done
        mov     ulCurrentDestScan,esi

; Now make sure the dest bank is mapped in.

        mov     ebx,pdsurf
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yTop ;dest scan less than
                                                    ; current bank?
        jl      short top_1RW_map_dest_bank         ;yes, map in dest bank
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yBottom ;dest scan greater than
                                                        ; current bank?
        jl      short top_1RW_dest_bank_mapped   ;no, proper bank mapped

top_1RW_map_dest_bank:

; Map bank containing the current dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl>,<ebx,esi,JustifyTop>

top_1RW_dest_bank_mapped:

        add     ulCurrentSrcScan,edi    ;we've copied from source up to here

        jmp     top_1RW_bank_loop

top_1RW_done:
        PLAIN_RET


;-----------------------------------------------------------------------;
; Banking for 1 R/W adapters, bottom to top.
;-----------------------------------------------------------------------;
bottom_to_top_1RW::

; We're going bottom to top. Map in the dest, bottom-justified.

        mov     ebx,pdsurf
        mov     esi,ulCurrentDestScan
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yTop  ;is dest bottom less than
                                                     ; current dest bank?
        jl      short bot_1RW_map_init_dest_bank     ;yes, map in proper bank
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yBottom ;dest bottom greater
                                                       ; than current dst bank?
        jl      short bot_1RW_init_dest_bank_mapped
                                                ;no, proper bank already mapped
bot_1RW_map_init_dest_bank:

; Map bank containing the bottom dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl>,<ebx,esi,JustifyBottom>

bot_1RW_init_dest_bank_mapped:

; Bank-by-bank bottom-to-top copy loop.

bot_1RW_bank_loop:

; Decide how far we can go before we run out of bank or rectangle to copy.

        mov     edi,ulLastDestScan
        cmp     edi,[ebx].dsurf_rcl1WindowClip.yTop
        jg      short @F        ;copy rectangle top is in this bank
        mov     edi,[ebx].dsurf_rcl1WindowClip.yTop ;dest extends to end
                                                    ; of bank, at least
@@:
        neg     edi
        add     edi,esi                 ;# of scans we can and want to do in
        inc     edi                     ; the dest bank

; Now make sure source is mapped in. This is the condition the copying routines
; expect, and we need to figure out how far we can go in the source.

        sub     edx,edx                 ;assume source and dest are in the same
                                        ; bank
        mov     esi,ulCurrentSrcScan
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yTop ;src scan less than
                                                    ; current bank?
        jl      short bot_1RW_map_src_Bank          ;yes, must map in
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yBottom ;src scan greater than
                                                       ; current bank?
        jl      short bot_1RW_src_bank_mapped     ;no, proper bank still mapped

bot_1RW_map_src_Bank:

; Map bank containing the current source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl>,<ebx,esi,JustifyBottom>

        mov     edx,1                   ;mark that source and dest are not in
                                        ; the same bank
bot_1RW_src_bank_mapped:

        sub     esi,[ebx].dsurf_rcl1WindowClip.yTop
        inc     esi                     ;# of scans we can do in the src bank

        cmp     edi,esi
        jb      short @F        ;source bank isn't limiting
        mov     edi,esi         ;source bank is limiting
@@:
        mov     ulBlockHeight,edi ;# of scans we'll do in this bank

; We're ready to copy this block.
; Select different threading, depending on whether the source and destination
; are currently in the same bank; we can copy much faster if they are.

        and     edx,edx
        jz      short bot_1RW_copy_same_bank

; Source and dest are currently in different banks, must go through temp buffer.

        THREAD_AND_START pCurrentThreadViaBuffer,bot_1RW_check_more_scans

; Source and dest are currently in the same bank.

bot_1RW_copy_same_bank:
        THREAD_AND_START

; Any more scans to copy?

bot_1RW_check_more_scans:

        mov     esi,ulCurrentDestScan
        mov     edi,ulBlockHeight
        sub     esi,edi                 ;we've copied to dest up to here
        cmp     ulLastDestScan,esi      ;are we past the dest rect top?
        jg      short bot_1RW_done      ;yes, we're done
        mov     ulCurrentDestScan,esi

; Now make sure the dest bank is mapped in.

        mov     ebx,pdsurf
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yTop ;dest scan less than
                                                    ; current bank?
        jl      short bot_1RW_map_dest_bank         ;yes, map in dest bank
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yBottom ;dest scan greater than
                                                        ; current bank?
        jl      short bot_1RW_dest_bank_mapped   ;no, proper bank mapped

bot_1RW_map_dest_bank:

; Map bank containing the current dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl>,<ebx,esi,JustifyBottom>

bot_1RW_dest_bank_mapped:

        sub     ulCurrentSrcScan,edi    ;we've copied from source up to here

        jmp     bot_1RW_bank_loop

bot_1RW_done:
        PLAIN_RET


;***********************************************************************;
;
; The following routines are the low-level copying routines. They know
; almost nothing about banks (the routines that copy through a temp
; buffer know how to switch banks after filling the temp buffer, but
; that's it). Banking should be taken care of at a higher level.
;
;***********************************************************************;

;-----------------------------------------------------------------------;
; Copies a block of solid bytes from the source to the destination via the
; latches. Can only be used by 2 R/W or 1R/1W window banking, or by
; unbanked modes, or by 1 R/W adapters when the source and dest are in the
; same bank. 1 R/W adapters must go through an intermediate local buffer
; when the source and the destination aren't in the same bank.
;
; Input:
;       Direction Flag set for desired direction of copy
;       culWholeBytesWidth = # of bytes to copy across each scan line
;       ulWholeScanDelta = distance to start of next scan from end of current
;       ulBlockHeight = # of scans to copy
;       ulWholeBytesSrc = start source offset in bitmap
;       ulWholeBytesDest = start dest offset in bitmap
;
; Output:
;       Advances ulWholeBytesSrc and ulWholeBytesDest to scan after last
;               scan processed
;-----------------------------------------------------------------------;

copy_whole_bytes::

; Set the bit mask to disable all bits, so we can copy through the latches.

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(000h shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Set Map Mask to enable writes to all planes.

        mov     dl,SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

; Set up to copy the whole bytes via the latches.

        mov     eax,culWholeBytesWidth
        mov     ebx,ulBlockHeight
        mov     edx,ulWholeScanDelta

; Calculate full start addresses.

        mov     ecx,pdsurf
        mov     esi,ulWholeBytesSrc
        add     esi,[ecx].dsurf_pvBitmapStart2WindowS
        mov     edi,ulWholeBytesDest
        add     edi,[ecx].dsurf_pvBitmapStart2WindowD

;  EAX = # of bytes to copy
;  EBX = count of unrolled loop iterations
;  EDX = offset from end of one scan's fill to start of next
;  ESI = source address to copy from
;  EDI = target address to copy to

whole_latches_loop:
        mov     ecx,eax         ;# of whole bytes to copy
        rep     movsb           ;copy the bytes via the latches
        add     esi,edx         ;point to next source scan
        add     edi,edx         ;point to next dest scan

        dec     ebx
        jnz     whole_latches_loop

; Remember where we left off, for next time.

        mov     ecx,pdsurf
        sub     esi,[ecx].dsurf_pvBitmapStart2WindowS
        mov     ulWholeBytesSrc,esi
        sub     edi,[ecx].dsurf_pvBitmapStart2WindowD
        mov     ulWholeBytesDest,edi

        PLAIN_RET


;-----------------------------------------------------------------------;
; Copies a block of solid bytes from the source to the destination via
; the temp buffer. This should only be used by 1 R/W adapters, and then
; only when the source and dest are in different banks.
;
; All relevant bytes are copied from the source to a temp buffer that's an
; image of the source first. Then, we copy each of the four planes for one scan
; line from the temp buffer to the screen before going on to the next scan line.
; It would be faster to do all scans in one plane, then all in the next, and so
; on, but that would give nasty color effects from pixels that were changed in
; some planes but not in others. A compromise would be to do several scans at a
; pop per plane, as is done with the edge bytes; however, given that there can
; be 128 (or more) bytes across a single whole-bytes scan, if we do 16 scan
; lines per chunk, we're going to be performing up to 128*4*16 accesses per
; chunk; at an assumed 1 microsecond per access, that's 8 millisecond per scan
; line, or about 1/2 of a frame time. We're definitely going to see flicker or
; sparkles from partially updated bytes at that point, in my opinion. Another
; alternative would be to dynamically adjust the number of scans processed at a
; pop per plane, depending on the copy width, with more scans copied for
; narrower widths. For all but very narrow copies, though, it seems to me that
; the actual copy time would far outweigh the time for the OUTs to switch
; planes, and the return for some rather complex code would be marginal.
;
; It would be nice if we copied bytes a word or dword at a time. However, it
; becomes rather complex handling fractional words or dwords, especially when
; copying right-to-left, so this is left for LATER. I haven't unrolled these
; loops because of the possibility of this further word/dword optimization;
; no point in fine-tuning sub-optimal code.
;
; Input:
;       Direction Flag set for desired direction of copy
;       culWholeBytesWidth = # of bytes to copy across each scan line
;       ulWholeScanDelta = distance to start of next scan from end of current
;       ulBlockHeight = # of scans to copy
;       ulWholeBytesSrc = start source offset in bitmap
;       ulWholeBytesDest = start dest offset in bitmap
;       ppTempPlane0 = pointer to pointer to plane 0 storage in temp buffer
;       ppTempPlane3 = pointer to pointer to plane 3 storage in temp buffer
;       Expects the source bank to be mapped in; source bank is mapped in on
;               exit
;
; Output:
;       Advances ulWholeBytesSrc and ulWholeBytesDest to scan after last
;               scan processed
;-----------------------------------------------------------------------;

copy_whole_bytes_via_buffer::

; Calculate start source address from bitmap start address and offset within
; bitmap.

        mov     ecx,pdsurf
        mov     eax,ulWholeBytesSrc
        add     eax,[ecx].dsurf_pvBitmapStart
        mov     pSrcAddr,eax
        sub     eax,[ecx].dsurf_pvStart
        mov     ulOffsetInBank,eax ;will come in handy because we treat the
                                   ; temp buffer as an image of the current
                                   ; bank

; First, copy all the bytes into the temporary buffer.

; Leave the GC Index pointing to the Read Map.

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_READ_MAP
        out     dx,al

        mov     eax,3           ;start by copying plane 3
copy_whole_to_buffer_plane_loop:
        mov     ebx,ulBlockHeight  ;# of scans to copy
        mov     esi,pSrcAddr       ;source offset in screen
        mov     edi,ppTempPlane0
        mov     edi,[edi+eax*4]    ;pointer to current plane in temp buffer
        add     edi,ulOffsetInBank ;dest for plane in temp buffer

        mov     edx,VGA_BASE + GRAF_DATA
        out     dx,al            ;set Read Map to plane we're copying from.

        push    eax             ;remember plane index
        mov     eax,ulWholeScanDelta ;offset to next scan
        mov     edx,culWholeBytesWidth ;# of bytes per scan
copy_whole_to_buffer_scan_loop:
        mov     ecx,edx         ;# of bytes per scan
        rep     movsb           ;copy the scan line to the temp buffer
        add     esi,eax         ;point to next source scan
        add     edi,eax         ;point to next dest scan

        dec     ebx              ;count down scan lines
        jnz     copy_whole_to_buffer_scan_loop

        pop     eax             ;get back plane index
        dec     eax             ;count down planes
        jns     copy_whole_to_buffer_plane_loop

; Remember where we left off, for next time.

        mov     ebx,pdsurf
        sub     esi,[ebx].dsurf_pvBitmapStart
        mov     ulWholeBytesSrc,esi


; Now copy the temp buffer to the screen.

; Map in the destination bank, so we can read/write to it  and let the Bit Mask
; work.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl>, \
                <ebx,ulCurrentDestScan,ulCurrentJustification>

; Calculate dest start address (if this is a 1 R/W adapter, we had to wait
; until now to calculate this, because the dest bank wasn't mapped earlier).

        mov     eax,ulWholeBytesDest
        add     eax,[ebx].dsurf_pvBitmapStart
        mov     pDestAddr,eax

; Set the bit mask to enable all bits.

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax

        mov     dl,SEQ_DATA     ;leave DX pointing to the SC Data reg

; Set up to copy the whole bytes from the buffer.

        mov     eax,ulBlockHeight ;# of scans to copy
        mov     culTempCount,eax

copy_whole_from_buffer_scan_loop:

        mov     ebx,ppTempPlane3  ;point to plane 3's temp buffer offset
        mov     al,MM_C3        ;start by copying plane 3

copy_whole_from_buffer_plane_loop:

; Set Map Mask to enable writes to the plane we're copying.

        out     dx,al

; Select the corresponding plane from the temp buffer.

        mov     esi,[ebx]          ;point to plane start in temp buffer
        add     esi,ulOffsetInBank ;point to current scan start in temp buffer
        mov     edi,pDestAddr      ;point to destination start

        mov     ecx,culWholeBytesWidth  ;# of whole bytes to copy
        rep     movsb           ;copy the bytes from the buffer to the screen

; Do next plane, if any.

        sub     ebx,4                   ;point to next temp buffer plane ptr
        shr     al,1                    ;advance to next plane
        jnz     copy_whole_from_buffer_plane_loop

; Remember where we left off, for next scan.

        add     edi,ulWholeScanDelta    ;point to next dest scan
        mov     pDestAddr,edi
        mov     eax,ulNextScan
        add     ulOffsetInBank,eax      ;next scan's start in temp buffer,
                                        ; relative to start of plane's storage

; Count down scan lines.

        dec     culTempCount
        jnz     copy_whole_from_buffer_scan_loop

; Remember where we left off, for next time.

        mov     ebx,pdsurf
        sub     edi,[ebx].dsurf_pvBitmapStart
        mov     ulWholeBytesDest,edi

; Put back the original source bank.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl>, \
                <ebx,ulCurrentSrcScan,ulCurrentJustification>

        PLAIN_RET


;-----------------------------------------------------------------------;
; Copies a strip of left edge bytes from the source to the destination,
; assuming both the source and the destination are both readable and
; writable. Can only be used by 2 R/W window banking, or by unbanked
; modes. 1 R/W and 1R/1W adapters must go through an intermediate local
; buffer when the source and dest are in different banks. Processes up to
; EDGE_CHUNK_SIZE bytes in each plane at a pop; more bytes might cause
; flicker.
;
; Input:
;       ulNextScan = width of scan, in bytes
;       ulBlockHeight = # of scans to copy
;       ulLeftEdgeSrc = start source offset in bitmap
;       ulLeftEdgeDest = start dest offset in bitmap
;       jLeftMask = left edge clip mask
;
; Output:
;       Advances ulLeftEdgeSrc and ulLeftEdgeDest to scan after last
;               scan processed
;-----------------------------------------------------------------------;

copy_left_edge::

; Calculate start source and dest addresses from bitmap start addresses and
; offsets within bitmap.

        mov     ecx,pdsurf
        mov     esi,ulLeftEdgeSrc
        add     esi,[ecx].dsurf_pvBitmapStart2WindowS
        mov     edi,ulLeftEdgeDest
        add     edi,[ecx].dsurf_pvBitmapStart2WindowD

; Copy the edge.

        mov     ah,byte ptr jLeftMask   ;clip mask for this edge
        call    copy_edge

; Remember where we left off, for next time.

        mov     ecx,pdsurf
        sub     esi,[ecx].dsurf_pvBitmapStart2WindowS
        mov     ulLeftEdgeSrc,esi
        sub     edi,[ecx].dsurf_pvBitmapStart2WindowD
        mov     ulLeftEdgeDest,edi

        PLAIN_RET


;-----------------------------------------------------------------------;
; Copies a strip of right edge bytes from the source to the destination,
; assuming both the source and the destination are both readable and
; writable. Can only be used by 2 R/W window banking, or by unbanked
; modes. 1 R/W and 1R/1W adapters must go through an intermediate local
; buffer when the source and dest are in different banks. Processes up to
; EDGE_CHUNK_SIZE bytes in each plane at a pop; more bytes might cause
; flicker.
;
; Input:
;       ulNextScan = width of scan, in bytes
;       ulBlockHeight = # of scans to copy
;       ulRightEdgeSrc = start source offset in bitmap
;       ulRightEdgeDest = start dest offset in bitmap
;       jRightMask = right edge clip mask
;
; Output:
;       Advances ulRightEdgeSrc and ulRightEdgeDest to scan after last
;               scan processed
;-----------------------------------------------------------------------;

copy_right_edge::

; Calculate start source and dest addresses from bitmap start addresses and
; offsets within bitmap.

        mov     ecx,pdsurf
        mov     esi,ulRightEdgeSrc
        add     esi,[ecx].dsurf_pvBitmapStart2WindowS
        mov     edi,ulRightEdgeDest
        add     edi,[ecx].dsurf_pvBitmapStart2WindowD

; Copy the edge.

        mov     ah,byte ptr jRightMask  ;clip mask for this edge
        call    copy_edge

; Remember where we left off, for next time

        mov     ecx,pdsurf
        sub     esi,[ecx].dsurf_pvBitmapStart2WindowS
        mov     ulRightEdgeSrc,esi
        sub     edi,[ecx].dsurf_pvBitmapStart2WindowD
        mov     ulRightEdgeDest,edi

        PLAIN_RET


;-----------------------------------------------------------------------;
; Copies an edge from the source to the destination on the screen.
; Entry:
;       AH = bit mask setting for edge
;       ESI = source address
;       EDI = destination address
;       ulBlockHeight = # of bytes to copy per plane
;       ulNextScan = scan width
;       Source readable, and destination readable and writable
; Exit:
;       ESI = next source address
;       EDI = next destination address
;
; Preserved: EBP
;-----------------------------------------------------------------------;

copy_edge:
        mov     pSrcAddr,esi
        mov     pDestAddr,edi

; Set the clip mask for this edge.

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_BIT_MASK
        out     dx,ax

; Leave the GC Index pointing to the Read Map.

        mov     al,GRAF_READ_MAP
        out     dx,al

        mov     ecx,offset copy_edge_rw_full_chunk
                                ;entry point into unrolled loop to copy first
                                ; chunk, assuming it's a full chunk
        mov     ebx,ulBlockHeight

; Copy the edge in a series of chunks.

copy_edge_chunk_loop:

        sub     ebx,EDGE_CHUNK_SIZE ;scans remaining after this chunk, assuming
                                    ; a full chunk
        jge     short @F            ;do a full chunk
        add     ebx,EDGE_CHUNK_SIZE ;not a full chunk; process all remaining
                                    ; scans
        mov     ecx,pfnCopyEdgeRWEntry[-4][ebx*4]
                                ;entry point into unrolled loop to copy desired
                                ; chunk size
        sub     ebx,ebx         ;no scans after this
@@:
        push    ebx             ;remember remaining scan count

        mov     ah,MM_C3        ;start by copying plane 3
        mov     ebx,ulNextScan

copy_edge_plane_loop:

; Set Map Mask to enable writes to plane we're copying.

        mov     al,ah
        mov     dl,SEQ_DATA
        out     dx,al

; Set Read Map to same plane.

        shr     al,1                    ;map plane into ReadMask
        cmp     al,100b                 ;set Carry if not C3 (plane 3)
        adc     al,-1                   ;sub 1 only if C3
        mov     dl,GRAF_DATA
        out     dx,al

        mov     esi,pSrcAddr
        mov     edi,pDestAddr

        jmp     ecx                     ;copy the left edge


;-----------------------------------------------------------------------;
; Table of unrolled edge loop entry points. First entry point is to copy
; 1 byte, last entry point is to copy EDGE_CHUNK_SIZE bytes.
;-----------------------------------------------------------------------;

pfnCopyEdgeRWEntry label dword
INDEX = 1
        rept    EDGE_CHUNK_SIZE
        DEFINE_DD       EDGE_RW,%INDEX
INDEX = INDEX+1
        endm


;-----------------------------------------------------------------------;
; Unrolled loop for copying a strip of edge bytes, with source and
; destination both readable and writable.
;-----------------------------------------------------------------------;

COPY_EDGE_RW macro ENTRY_LABEL,ENTRY_INDEX
ENTRY_LABEL&ENTRY_INDEX:
        mov     al,[esi]        ;get byte to copy
        add     esi,ebx         ;point to next source scan
        mov     dl,[edi]        ;read to load latches (value doesn't matter)
        mov     [edi],al        ;write, with the Bit Mask clipping
        add     edi,ebx         ;point to next dest scan
        endm    ;-----------------------------------;

;  EBX = scan line width
;  ESI = source address to copy from
;  EDI = target address to copy to
;  Bit Mask set to desired clipping
;  Read Map and Map Mask set to enable the desired plane for read and write

copy_edge_rw_full_chunk:
        UNROLL_LOOP     COPY_EDGE_RW,EDGE_RW,EDGE_CHUNK_SIZE

; Do next plane within this chunk, if any.

        shr     ah,1                    ;advance to next plane
        jnz     copy_edge_plane_loop

; Remember where we left off, for the next chunk.

        mov     pSrcAddr,esi
        mov     pDestAddr,edi

; Do next chunk within this bank block, if any.

        pop     ebx                     ;retrieve remaining scan count
        and     ebx,ebx                 ;any scans left?
        jnz     copy_edge_chunk_loop    ;more scans to do

        PLAIN_RET


;-----------------------------------------------------------------------;
; Copies a strip of left edge bytes from the source to the destination
; through an intermediate RAM buffer. This is the approach required by
; 1 R/W and 1R/1W adapters when the source and dest are in different banks.
; Writes up to EDGE_CHUNK_SIZE bytes in each plane at a pop; more bytes might
; cause flicker.
;
; Input:
;       ulNextScan = width of scan, in bytes
;       ulBlockHeight = # of scans to copy
;       ulLeftEdgeSrc = start source offset in bitmap
;       ulLeftEdgeDest = start dest offset in bitmap
;       jLeftMask = left edge clip mask
;       pTempPlane = pointer to temp storage buffer
;       ulCurrentSrcScan = scan used to map in source bank
;       ulCurrentDestScan = scan used to map in dest bank
;       ulCurrentJustification = justification used to map in current bank
;       For 1 R/W adapters, expects the source bank to be mapped in; banking
;               is the same at exit as it was at entry
;
; Output:
;       Advances ulLeftEdgeSrc and ulLeftEdgeDest to scan after last
;               scan processed
;
; Note that this should never be called for an unbanked or 2 R/W adapter,
; because the source and dest are always both addressable simultaneously then.
;-----------------------------------------------------------------------;

copy_left_edge_via_buffer::

; First, copy all the bytes into the temporary buffer.

; Calculate start source and dest addresses from bitmap start addresses and
; offsets within bitmap.

        mov     ecx,pdsurf
        mov     esi,ulLeftEdgeSrc
        add     esi,[ecx].dsurf_pvBitmapStart2WindowS

; Copy the edge from the source to the temp buffer.

        call    copy_screen_to_buffered_edge

; Remember where we left off, for next time

        mov     ebx,pdsurf
        sub     esi,[ebx].dsurf_pvBitmapStart2WindowS
        mov     ulLeftEdgeSrc,esi

; Now copy the temp buffer to the screen.

; Map in the source bank to match the destination, so we can read/write to it
; and let the Bit Mask work. Note that on a 1 R/W adapter, both banks will be
; mapped by this call, which is fine.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,ulCurrentDestScan,ulCurrentJustification,MapSourceBank>

; Calculate dest start address (if this is a 1 R/W adapter, we had to wait
; until now to calculate this, because the dest bank wasn't mapped earlier).

        mov     edi,ulLeftEdgeDest
        add     edi,[ebx].dsurf_pvBitmapStart2WindowD

        mov     ah,byte ptr jLeftMask           ;clip mask for this edge
        call    copy_buffered_edge_to_screen    ;do the copy

; Remember where we left off, for next time.

        mov     ebx,pdsurf
        sub     edi,[ebx].dsurf_pvBitmapStart2WindowD
        mov     ulLeftEdgeDest,edi

; Put back the original source bank.  Note that on a 1 R/W adapter, both banks
; will be mapped by this call, which is fine.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,ulCurrentSrcScan,ulCurrentJustification,MapSourceBank>

        PLAIN_RET


;-----------------------------------------------------------------------;
; Copies a strip of right edge bytes from the source to the destination
; through an intermediate RAM buffer. This is the approach required by
; 1 R/W and 1R/1W adapters when the source and dest are in different banks.
; Writes up to EDGE_CHUNK_SIZE bytes in each plane at a pop; more bytes might
; cause flicker.
;
; Input:
;       ulNextScan = width of scan, in bytes
;       ulBlockHeight = # of scans to copy
;       ulRightEdgeSrc = start source offset in bitmap
;       ulRightEdgeDest = start dest offset in bitmap
;       jRightMask = right edge clip mask
;       pTempPlane = pointer to temp storage buffer
;       ulCurrentSrcScan = scan used to map in source bank
;       ulCurrentDestScan = scan used to map in dest bank
;       ulCurrentJustification = justification used to map in current bank
;       For 1 R/W adapters, expects the source bank to be mapped in; banking
;               is the same at exit as it was at entry
;
; Output:
;       Advances ulRightEdgeSrc and ulRightEdgeDest to scan after last
;               scan processed
;
; Note that this should never be called for an unbanked or 2 R/W adapter,
; because the source and dest are always both addressable simultaneously then.
;-----------------------------------------------------------------------;

copy_right_edge_via_buffer::

; First, copy all the bytes into the temporary buffer.

; Calculate start source address from bitmap start addresses and
; offsets within bitmap.

        mov     ecx,pdsurf
        mov     esi,ulRightEdgeSrc
        add     esi,[ecx].dsurf_pvBitmapStart2WindowS

; Copy the edge from the source to the temp buffer.

        call    copy_screen_to_buffered_edge

; Remember where we left off, for next time

        mov     ebx,pdsurf
        sub     esi,[ebx].dsurf_pvBitmapStart2WindowS
        mov     ulRightEdgeSrc,esi

; Now copy the temp buffer to the screen.

; Map in the source bank to match the destination, so we can read/write to it
; and let the Bit Mask work. Note that on a 1 R/W adapter, both banks will be
; mapped by this call, which is correct.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,ulCurrentDestScan,ulCurrentJustification,MapSourceBank>

; Calculate dest start address (if this is a 1 R/W adapter, we had to wait
; until now to calculate this, because the dest bank wasn't mapped earlier).

        mov     edi,ulRightEdgeDest
        add     edi,[ebx].dsurf_pvBitmapStart2WindowD

        mov     ah,byte ptr jRightMask          ;clip mask for this edge
        call    copy_buffered_edge_to_screen    ;do the copy

; Remember where we left off, for next time.

        mov     ebx,pdsurf
        sub     edi,[ebx].dsurf_pvBitmapStart2WindowD
        mov     ulRightEdgeDest,edi

; Put back the original source bank.  Note that on a 1 R/W adapter, both banks
; will be mapped by this call, which is fine.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,ulCurrentSrcScan,ulCurrentJustification,MapSourceBank>

        PLAIN_RET


;-----------------------------------------------------------------------;
; Copies an edge from the temp buffer to the screen.
; Entry:
;       AH = bit mask setting for edge
;       EDI = destination address
;       pTempPlane = temp buffer from which to copy
;       ulBlockHeight = # of bytes to copy per plane
;       ulNextScan = scan width
;       Source and dest banks both pointing to destination
; Exit:
;       EDI = next destination address
;
; Preserved: EBP
;-----------------------------------------------------------------------;

copy_buffered_edge_to_screen:

        mov     pDestAddr,edi

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_BIT_MASK
        out     dx,ax

        mov     pTempEntry,offset copy_edge_from_buf_full_chunk
                                ;entry point into unrolled loop to copy first
                                ; chunk, assuming it's a full chunk
        mov     ecx,pTempPlane  ;temp buffer start (copy from here)
        mov     ebx,ulBlockHeight ;total # of scans to copy

; Copy the edge in a series of chunks, to avoid flicker.

copy_from_buffer_chunk_loop:

        sub     ebx,EDGE_CHUNK_SIZE ;scans remaining after this chunk, assuming
                                    ; a full chunk
        jge     short @F            ;do a full chunk
        add     ebx,EDGE_CHUNK_SIZE ;not a full chunk; process all remaining
                                    ; scans
        mov     ebx,pfnCopyEdgesFromBufferEntry[-4][ebx*4]
        mov     pTempEntry,ebx  ;entry point into unrolled loop to copy desired
                                ; chunk size
        sub     ebx,ebx         ;no scans after this
@@:
        push    ebx             ;remember remaining scan count

        mov     al,MM_C3        ;start by copying plane 3
        mov     ebx,ulNextScan

        push    ecx             ;remember current temp buffer start

copy_from_buffer_plane_loop:

; Set Map Mask to enable writes to plane we're copying.

        mov     dl,SEQ_DATA     ;leave DX pointing to Sequencer Data reg
        out     dx,al

; Calculate the equivalent Read Map, and use that to select the correct plane
; from the temp buffer.

        mov     esi,ecx                 ;point to current plane's source byte
        add     ecx,ulBlockHeight       ;point to next plane's source byte

        mov     edi,pDestAddr

        jmp     pTempEntry              ;copy the left edge


;-----------------------------------------------------------------------;
; Table of unrolled edge copy-from-buffer loop entry points. First entry
; point is to copy 1 byte, last entry point is to copy EDGE_CHUNK_SIZE
; bytes.
;-----------------------------------------------------------------------;

pfnCopyEdgesFromBufferEntry label dword
INDEX = 1
        rept    EDGE_CHUNK_SIZE
        DEFINE_DD       EDGE_FROM_BUFFER,%INDEX
INDEX = INDEX+1
        endm


;-----------------------------------------------------------------------;
; Unrolled loop for copying a strip of edge bytes from the temp buffer.
;-----------------------------------------------------------------------;

COPY_EDGE_FROM_BUFFER macro ENTRY_LABEL,ENTRY_INDEX
ENTRY_LABEL&ENTRY_INDEX:
        mov     ah,[esi]        ;get byte to copy
        inc     esi             ;point to next source (temp buffer) byte
        mov     dl,[edi]        ;latch the destination (value doesn't matter)
        mov     [edi],ah        ;write, with the Bit Mask clipping
        add     edi,ebx         ;point to next dest (screen) scan
        endm    ;-----------------------------------;

;  EBX = scan line width
;  ESI = source address to copy from (temp buffer)
;  EDI = target address to copy to (screen)
;  Bit Mask set to desired clipping
;  Map Mask set to enable the desired plane for write

copy_edge_from_buf_full_chunk:
        UNROLL_LOOP     COPY_EDGE_FROM_BUFFER,EDGE_FROM_BUFFER,EDGE_CHUNK_SIZE

; Do next plane within this chunk, if any.

        shr     al,1                    ;advance to next plane
        jnz     copy_from_buffer_plane_loop

; Remember where we left off, for next chunk.

        mov     pDestAddr,edi
        pop     ecx             ;get back current temp buffer start
        add     ecx,EDGE_CHUNK_SIZE ;point to next chunk's start

; Do next chunk within this bank block, if any.

        pop     ebx                     ;retrieve remaining scan count
        and     ebx,ebx                 ;any scans left?
        jnz     copy_from_buffer_chunk_loop    ;more scans to do

        PLAIN_RET


;-----------------------------------------------------------------------;
; Copies an edge from the screen to the temp buffer.
; Entry:
;       ESI = source address
;       pTempPlane = temp buffer from which to copy
;       ulBlockHeight = # of bytes to copy per plane
;       ulNextScan = scan width
;       Source bank pointing to source
; Exit:
;       DH = VGA_BASE SHR 8
;       ESI = next source address
;
; Preserved: EBP
;-----------------------------------------------------------------------;

copy_screen_to_buffered_edge:

        mov     pSrcAddr,esi

; Leave the GC Index pointing to the Read Map.

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_READ_MAP
        out     dx,al

        mov     ecx,ulNextScan
        mov     edi,pTempPlane  ;dest offset in temp buffer for plane 3 bytes.
                                ;The rest of the planes are stored
                                ; consecutively
        mov     al,3            ;start by copying plane 3
        mov     dl,GRAF_DATA    ;leave DX pointing to GC Data reg
copy_edge_to_buffer_plane_loop:
        mov     esi,pSrcAddr ;source pointer

        out     dx,al            ;set Read Map to plane we're copying from.

        mov     ebx,ulBlockHeight ;# of unrolled loop iterations

;  EBX = count of unrolled loop iterations
;  ECX = offset from end of one scan's fill to start of next
;  ESI = source address to copy from (screen)
;  EDI = target address to copy to (temp buffer)
;  Read Map set to enable the desired plane for read

edge_to_buffer_loop:
        mov     ah,[esi]        ;get byte to copy
        add     esi,ecx         ;point to next source scan
        mov     [edi],ah        ;copy byte to temp buffer
        inc     edi             ;point to next temp buffer byte

        dec     ebx
        jnz     edge_to_buffer_loop

        dec     al               ;count down planes
        jns     copy_edge_to_buffer_plane_loop

        PLAIN_RET


;-----------------------------------------------------------------------;

endProc vAlignedSrcCopy

_TEXT$03   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\blt.asm ===
page    ,132
        title   BitBLT
;---------------------------Module-Header------------------------------;
; Module Name: blt.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
        .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .code

_TEXT$02   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        .xlist
        include stdcall.inc         ; calling convention cmacros

        include i386\cmacFLAT.inc   ; FLATland cmacros
        include i386\display.inc    ; Display specific structures
        include i386\ppc.inc        ; Pack pel conversion structure
        include i386\bitblt.inc     ; General definitions
        include i386\ropdefs.inc    ; Rop definitions
        include i386\roptable.inc   ; Raster op tables
        include i386\egavga.inc     ; EGA register definitions
        include i386\strucs.inc     ; Structure definitions
        .list


        EXTRNP  cblt
        EXTRNP  packed_pel_comp_y
        EXTRNP  vDIB4Preprocess
        EXTRNP  vDIB8Preprocess

; The following two bitmask tables are used for fetching
; the first and last byte used-bits bitmask.

        public bitmask_tbl1
bitmask_tbl1    label   byte
        db      11111111b               ;Masks for leftmost byte
        db      01111111b
        db      00111111b
        db      00011111b
        db      00001111b
        db      00000111b
        db      00000011b
        db      00000001b

        public  bitmask_tbl2
bitmask_tbl2    label   byte
        db      10000000b               ;Masks for rightmost byte
        db      11000000b
        db      11100000b
        db      11110000b
        db      11111000b
        db      11111100b
        db      11111110b
        db      11111111b

; phase_tbl1 is used for loading the "used" bits and "saved" bits
; bitmasks for cases 1,2,3 where the step direction is left to
; right.  If it weren't for the case of zero, this could be done
; with a simple rotate of 00FF.   For cases 4,5,6, a simple rotate
; can create the mask needed.

        public  phase_tbl1
phase_tbl1      label   word
        db      11111111b,00000000b             ;Used bits, saved bits
        db      00000001b,11111110b
        db      00000011b,11111100b
        db      00000111b,11111000b
        db      00001111b,11110000b
        db      00011111b,11100000b
        db      00111111b,11000000b
        db      01111111b,10000000b

ProcName    xxxvCompiledBlt,vCompiledBlt,56

xxxvCompiledBlt proc uses esi edi ebx,\
        __pdsurfDst   :ptr,   \
        __DestxOrg    :dword, \
        __DestyOrg    :dword, \
        __pdsurfSrc   :ptr,   \
        __SrcxOrg     :dword, \
        __SrcyOrg     :dword, \
        __xExt        :dword, \
        __yExt        :dword, \
        __Rop         :dword, \
        __lpPBrush    :ptr,   \
        __bkColor     :dword, \
        __TextColor   :dword, \
        __pulXlateVec :dword, \
        __pptlBrush   :ptr

        local       fr[SIZE FRAME]:byte

        cld                             ;Let's make no assumptions about this!

; We be hacking, so copy all the parameters into the local frame right now,
; so that the subroutines will have access to them.

        mov         eax,__pdsurfDst
        mov         fr.pdsurfDst,eax
        mov         eax,__DestxOrg
        mov         fr.DestxOrg,ax
        mov         eax,__DestyOrg
        mov         fr.DestyOrg,ax
        mov         eax,__pdsurfSrc
        mov         fr.pdsurfSrc,eax
        mov         eax,__SrcxOrg
        mov         fr.SrcxOrg,ax
        mov         eax,__SrcyOrg
        mov         fr.SrcyOrg,ax
        mov         eax,__xExt
        mov         fr.xExt,ax
        mov         eax,__yExt
        mov         fr.yExt,ax
        mov         eax,__Rop
        mov         fr.Rop,eax
        mov         eax,__lpPBrush
        mov         fr.lpPBrush,eax
        mov         eax,__bkColor
        mov         fr.bkColor,eax
        mov         eax,__TextColor
        mov         fr.TextColor,eax
        mov         eax,__pulXlateVec
        mov         fr.ppcBlt.pulXlate,eax
        mov         eax,__pptlBrush
        mov         fr.pptlBrush,eax

        subttl  ROP Preprocessing
        page

;-----------------------------------------------------------------------;
; Get the encoded raster operation, and map the raster op if needed.
;
; To map the ROPS 80h through FFh to 00h through 7Fh, take the
; 1's complement of the ROP, and invert the "negate needed" flag.
;-----------------------------------------------------------------------;

        xor     ax,ax                   ;Assume not 80h : FFh
        mov     bl,byte ptr fr.Rop
        or      bl,bl                   ;Is this in the second half (80-FF)?
        jns     parse_10                ;  No, rop index is correct
        not     bl                      ;  Yes, want the inverse
        mov     ah,HIGH NEGATE_NEEDED   ;Want to invert the not flag
        errnz   <LOW NEGATE_NEEDED>

parse_10:
        movzx   ebx,bl
        xor     ax,roptable[ebx*2]      ;Get ROP, maybe toggle negate flag
        mov     fr.operands,ax          ;Save the encoded raster operation

        mov     bl,ah                   ;Set fr.the_flags for source and pattern
        and     bl,HIGH (SOURCE_PRESENT+PATTERN_PRESENT)
        ror     bl,1

        errnz    <SOURCE_PRESENT - 0010000000000000b>
        errnz   <PATTERN_PRESENT - 0100000000000000b>
        errnz    <F0_SRC_PRESENT - 00010000b>
        errnz    <F0_PAT_PRESENT - 00100000b>

parse_end:


;-----------------------------------------------------------------------;
; pdevice_processing
;
; Check the required bitmaps for validity, get their parameters
; and store the information locally.
;
;       BL = Initial fr.the_flags
;            F0_SRC_PRESENT set if source needed
;            F0_PAT_PRESENT set if pattern needed
;-----------------------------------------------------------------------;

        xor     bh,bh                   ;BH = real fr.the_flags
        mov     fr.ppcBlt.fb,bh          ;No packed pel converison
        test    bl,F0_SRC_PRESENT       ;Is a source needed?
        jz      pdevice_decode_dest     ;  No, skip source validation
        mov     esi,fr.pdsurfSrc        ;Get pointer to source
        lea     edi,fr.src              ;--> where parameters will go
        push    ebp
        lea     ebp,fr.ppcBlt
        cCall   copy_dev                ;Get all the data
        pop     ebp
        test    fr.ppcBlt.fb,PPC_NEEDED ;Will we be converting from packed pel?
        jz      pdevice_decode_dest     ;  No
        MovAddr eax,vDIB8Preprocess,0
        cmp     fr.ppcBlt.iFormat,BMF_8BPP
        je      short @F
        MovAddr eax,vDIB4Preprocess,0
@@:
        push    ebp                     ;  Yes, do serious messing around
        lea     ebp,fr                  ;  Needs a frame pointer
        call    eax
        pop     ebp

pdevice_decode_dest:
        mov     esi,fr.pdsurfDst        ;Get pointer to destination
        lea     edi,fr.dest             ;--> where parameters will go
        cCall   copy_dev                ;Get all the data

; The pattern fetch code will be based on the color format of the
; destination.  If the destination is mono, then a mono fetch will be
; performed.  If the destination is color, then a color fetch will be
; performed.

        or      bh,bl                   ;Merge in F0_SRC_PRESENT, F0_PAT_PRESENT
        test    bh,F0_DEST_IS_COLOR     ;Show color pattern needed if
        jz      pdevice_chk_color_conv  ;  destination is color
        or      bh,F0_COLOR_PAT

;       Check for color conversion.  If so, then set F0_GAG_CHOKE.
;       Color conversion will exist if the source and destination are of
;       different color formats.

pdevice_chk_color_conv:
        test    bh,F0_SRC_PRESENT       ;Is there a source?
        jz      pdevice_set_dest_flag   ;  No, cannot be converting.
        mov     al,bh
        and     al,F0_SRC_IS_COLOR+F0_DEST_IS_COLOR
        jz      pdevice_set_src_flag    ;Both are monochrome
        xor     al,F0_SRC_IS_COLOR+F0_DEST_IS_COLOR
        jz      pdevice_set_src_flag    ;Both are color
        or      bh,F0_GAG_CHOKE         ;Mono ==> color or color ==> mono
        mov     al,fr.bkColor.SPECIAL
        mov     ah,fr.TextColor.SPECIAL
        errnz   C0_BIT+C1_BIT+C2_BIT+C3_BIT-0Fh
        and     ax,0F0Fh
        mov     fr.both_colors,ax

; Setup the scan line update flag in the source device structure.
; The source will use a monochrome style update if it is the display,
; it is monochrome, or it is color and the destination device is
; monochrome.

pdevice_set_src_flag:
        mov     al,bh                   ;Set 'Z' if to use color update
        and     al,F0_SRC_IS_DEV+F0_SRC_IS_COLOR+F0_DEST_IS_COLOR
        xor     al,F0_SRC_IS_COLOR+F0_DEST_IS_COLOR
        jnz     pdevice_set_dest_flag   ;Use the mono update
        or      fr.src.dev_flags,COLOR_UP;Show color scan update

; Setup the scan line update flag in the destination device
; structure.  The destination will use a monochrome update
; if it is monochrome or the display.  It will use a color
; update if it is a color bitmap.

pdevice_set_dest_flag:
        mov     al,bh                   ;Set 'Z' if to use color destination
        and     al,F0_DEST_IS_DEV+F0_DEST_IS_COLOR;  update code
        xor     al,F0_DEST_IS_COLOR
        jnz     pdevice_proc_end        ;Mono update
        or      fr.dest.dev_flags,COLOR_UP;Show color scan update
pdevice_proc_end:


        push    ebp                     ;Set up pointer to frame variables
        lea     ebp,fr
        cCall   pattern_preprocessing
        pop     ebp

        subttl  Phase Processing (X)
        page

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;       Now the real work comes along:  In which direction will the
;       copy be done?  Refer to the 10 possible types of overlap that
;       can occur (10 cases, 4 resulting types of action required).
;
;       If there is no source bitmap involved in this particular BLT,
;       then the path followed must allow for this.  This is done by
;       setting both the destination and source parameters equal.
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

phase_processing:
phase_processing_x:
        mov     dx,fr.xExt              ;Get X extent
        dec     dx                      ;Make X extent inclusive
        mov     bx,fr.DestxOrg          ;Get destination X origin
        mov     di,bx
        and     bx,00000111b            ;Get offset of destination within byte

; If there is no source, then just use the pointer to the destination
; bitmap and load the same parameters, which will cause the "equality"
; path to be followed in the set-up code.  This path is the favored
; path for the case of no source bitmap.

        mov     ax,di                   ;Assume no source needed
        test    fr.the_flags,F0_SRC_PRESENT;Is a source needed?
        jz      phase_proc_10           ;  No, just use destination parameters
        mov     ax,fr.SrcxOrg           ;  Yes, get source origin X
        mov     fr.first_fetch,FF_TWO_INIT_FETCHES
                                        ;  Assume two initial fetches (if no
                                        ;    source, then it will be set = 1
                                        ;    later)
phase_proc_10:
        mov     si,ax
        and     ax,00000111b            ;Get offset of source within byte
        cmp     si,di                   ;Which direction will we be moving?
        jl      phase_proc_30           ;Move from right to left

; The starting X of the source rectangle is >= the starting X of
; the destination rectangle, therefore we will be moving bytes
; starting from the left and stepping right.
;
; Alternatively, this is the path taken if there is no source
; bitmap for the current BLT.
;
; Rectangle cases: 3,4,5,6,8

        sub     al,bl                   ;Compute horiz. phase  (source-dest)
        mov     fr.step_direction,STEPRIGHT ;Set direction of move
        movzx   ebx,bx
        mov     ah,[ebx].bitmask_tbl1   ;Get starting byte mask
        ja      phase_proc_two_fetches  ;Scan line case 2, everything is
                                        ;  already set for this case.

; Scan line cases 1 and 3:
;
; The correct first byte fetch needs to be set for the beginning
; of the outer loop, and the phase must be made into a positive
; number.
;
; This is the path that will be followed if there is no source bitmap
; for the current BLT.

        mov     fr.first_fetch,FF_ONE_INIT_FETCH;Set one initial fetch
        jmp     short pp_only_one_init_fetch

;-----------------------------------------------------------------------;
; If we get all the bits we need in the first fetch then a second
; (unnecessary) fetch could cause a GP Fault.  So let's examine this:
; The number of bits from (SI mod 8) to the end of the byte is the number
; of available bits we get on the first fetch.  This is (8 - (SI mod 8)).
; If this is greater than or equal to xExt then we have all the bits we
; need and we better not do the second fetch (even though the phase
; relationship may suggest we need it).
;
; Conclusion: If (8 - (SI mod 8)) >= xExt then DO NOT make second fetch.
;-----------------------------------------------------------------------;

phase_proc_two_fetches:
        mov     cx,8
        sub     cl,bl
        sub     cl,al

; We can save a couple cycles here since xExt - 1 is already in DX.
; The condition CX >= xExt is the same as CX > DX.

        cmp     cx,dx                   ;CX = (SI mod 8), DX = (xExt - 1)
        jle     pp_second_fetch_really_needed


;-----------------------------------------------------------------------;
; We are here BECAUSE the xExt is so small that we can get all the bits
; on the scanline with a single lodsb (no byte boundary is crossed) AND
; the phase relationship indicates that a second initial fetch is needed.
;
; We will override it and only do one fetch.  However, if we simply
; fail to do the second fetch then the phase code will give us trouble.
; It will be expecting the bits to get fetched in the first fetch, saved
; after the rotate, and mixed in in the second fetch's phase code.
; So after the first fetch the bits have been saved in BH, and ANDed out
; of the src data in AL.
;
; The solution is to set a flag here that tells the phase generation code
; not to generate the usual masking part of the phase code.
;
; Short Bitblt Cases:                   (8 bits or less)
;
;       1) neither crosses byte boundary.
;
;          a) phase requires second initial fetch
;
;             Kill the phase masking.  It will cause us trouble.  There will
;             be just one lodsb and one stosb and the first byte mask
;             will protect the dest bits that should not get hit.
;
;          b) phase requires only one initial fetch
;
;             Phase masking is irrelevant.  Removing it would
;             be an optimiztation.
;
;       2) dest crosses byte boundary, but src does not
;
;          a) phase requires second initial fetch
;
;             impossible situation:  the way we determine that a 2nd fetch
;             is necessary is if the first fetch does not get enough needed
;             bits to satisfy the first dest byte.  Here the first fetch
;             gets ALL the bits and the first dest byte needs less than
;             ALL because it crosses a byte boundary.
;
;          b) phase requires only one initial fetch
;
;             Intervention would be bad.  None is necessary since the 2nd
;             initial fetch will not be done.  If we do intervene we will
;             cause trouble:  Killing the masking will prevent the
;             "saved bits" from being saved.  The first byte masking
;             can kill off these bits in AL and they will never
;             make it to the second stosb.
;
;       3) src crosses byte boundary  (dest may or may not)
;          (this is known to be untrue at this point)
;
;          There are bits we need in the second fetch, so a second
;          initial fetch can not cause a GP fault.  Therefore do
;          everything the same as we would have before.
;
;
; Conclusion:  Intervention to kill the phase masking is
;              necessary iff
;                 [src does not cross byte boundary] AND
;                 dest does not cross byte boundary  AND
;                 [phase requires second initial fetch].
;              and bad if
;                 dest crosses byte boundary, but [src does not]
;
; Statements in [] are known to be true at this point.
;
; Solution:
;
; If we always kill the phase-masking when neither crosses a byte
; boundary and never kill it otherwise then everyone will be happy
; (regardless of other conditions like whether phase requests a 2nd
; initial fetch).
;-----------------------------------------------------------------------;

        mov     fr.first_fetch,FF_ONLY_1_SRC_BYTE
        .errnz  FF_ONE_INIT_FETCH

pp_second_fetch_really_needed:
pp_only_one_init_fetch:
        mov     ch,ah

;-----------------------------------------------------------------------;
;       We now have the correct phase and the correct first character fetch
;       routine set.  Save the phase and ...
;
;       currently:   AL = phase
;                    BL = dest start mod 8
;                    CH = first byte mask
;                    DX = inclusive X bit count
;                    SI = source X start (if there is a source)
;                    DI = destination X start
;-----------------------------------------------------------------------;

phase_proc_20:
        add     al,8                    ;Phase must be positive
        and     al,00000111b

; To calculate the last byte mask, the inclusive count can be
; added to the start X MOD 8 value, and the result taken MOD 8.
; This is attractive since this is what is needed later for
; calculating the inclusive byte count, so save the result
; of the addition for later.

        add     bx,dx                   ;Add inclusive extent to dest MOD 8
        mov     dx,bx                   ;Save for innerloop count !!!
        and     ebx,00000111b           ;Set up bx for a base reg
        mov     cl,[ebx].bitmask_tbl2   ;Get last byte mask

;-----------------------------------------------------------------------;
; To avoid GP faults, we must never do an extra fetch we don't need.
; When we're ready for the last fetch there may already be enough bits
; saved from the previous fetch (which we plan to combine with the bits
; in the fetch we are about to do).  If so then we'd better not do this
; last fetch (it could cause a GP fault).
;
; The number of bits we have left from the previous byte is (8 - AL)
; AL is the phase.  (1 + BL) is the number of bits we actually need
; to write to the final destination byte.
;
; So if  (8 - AL) >= (1 + BL)  then DO NOT do the last fetch.  This
; simplifies:  if  (BL + AL) <= 7  then DO NOT do the last fetch.
;-----------------------------------------------------------------------;

        add     bl,al
        cmp     bl,7
        jg      phase_proc_last_fetch_needed
        or      fr.first_fetch,FF_NO_LAST_FETCH
phase_proc_last_fetch_needed:

        mov     bl,al                   ;Compute offset into phase mask table
        movzx   ebx,bx
        mov     bx,[ebx*2].phase_tbl1   ;Get the phase mask

;       Currently:
;               AL = phase
;               BX = phase mask
;               CL = last byte mask
;               CH = first byte mask
;               DX = inclusive bit count + dest start MOD 8
;               SI = source X start (if there is a source)
;               DI = destination starting X

        jmp     phase_proc_50           ;Finish here

; The starting X of the source rectangle is < the X of the destination
; rectangle, therefore we will be moving bytes starting from the right
; and stepping left.
;
; This code should never be reached if there is no source bitmap
; for the current BLT.
;
; Rectangle cases: 1,2,7

phase_proc_30:
        mov     fr.step_direction,ah    ;Set direction of move
        errnz   STEPLEFT
        movzx   ebx,bx
        mov     cl,[ebx].bitmask_tbl1   ;Get last byte mask
        push    bx
        add     ax,dx                   ;Find end of the source

; To calculate the first byte mask, the inclusive count is
; added to the start MOD 8 value, and the result taken MOD 8.
; This is attractive since this is what is needed later for
; calculating the inclusive byte count, so save the result
; of the addition for later.

        add     bx,dx                   ;Find end of the destination
        add     di,dx                   ;Will need to update dest start address
        add     si,dx                   ;  and source's too
        mov     dx,bx                   ;Save inclusive bit count + start MOD 8
        and     ax,00000111b            ;Get source offset within byte
        and     ebx,00000111b           ;Get dest   offset within byte
        mov     ch,[ebx].bitmask_tbl2   ;Get start byte mask
        cmp     al,bl                   ;Compute horiz. phase  (source-dest)
        jb      pp_double_fetch         ;Scan line case 5, everything is
                                        ;  already set for this case.

; Scan line cases 4 and 6:
;
; The correct first byte fetch needs to be set for the beginning
; of the outer loop

        mov     fr.first_fetch,FF_ONE_INIT_FETCH;Set initial fetch routine
        jmp     short pp_one_initial_fetch

;-----------------------------------------------------------------------;
; If only-one-fetch is already set, then the following is a NOP.
; It doesn't seem worth the effort to check and jmp around.
;
; If we get all the bits we need in the first fetch then a second
; (unnecessary) fetch could cause a GP Fault.  So let's examine this:
;
; (DX + SI) points to the first pel (remember we're stepping left).
; So the number of needed bits we get in the first fetch is
; ((DX + SI + 1) mod 8).  This is currently equal to AX.
; If AX >= xExt then we'd better not do two init fetches.
;-----------------------------------------------------------------------;

pp_double_fetch:
        dec     fr.xExt
        cmp     ax,fr.xExt
        jl      pp_double_fetch_really_needed
        mov     fr.first_fetch,FF_ONLY_1_SRC_BYTE
        .errnz  FF_ONE_INIT_FETCH
pp_double_fetch_really_needed:
        inc     fr.xExt

pp_one_initial_fetch:
        sub     al,bl                   ;Compute horiz. phase  (source-dest)
        add     al,8                    ;Ensure phase positive
        and     al,00000111b

;-----------------------------------------------------------------------;
; To avoid GP faults must never do an extra fetch we don't need.
; The last byte fetch is unnecessary if Phase is greater than or equal
; to 8 - BL.  Phase is the number of bits we still have from the previous
; fetch. 8 - BL is the number of bits we actually need to write to the
; final destination byte.  So if AL - (8 - BL) >= 0  skip the last fetch.
;-----------------------------------------------------------------------;

        pop     bx
        add     bl,al
        sub     bl,8
        jl      pp_need_last_fetch
        or      fr.first_fetch,FF_NO_LAST_FETCH
pp_need_last_fetch:
phase_proc_40:

;-----------------------------------------------------------------------;
;       We now have the correct phase and the correct first character fetch
;       routine set.  Generate the phase mask and save it.
;
;       currently:   AL = phase
;                    CH = first byte mask
;                    CL = last byte mask
;                    DX = inclusive bit count + start MOD 8

        mov     ah,cl                   ;Save last mask
        mov     cl,al                   ;Create the phase mask
        mov     bx,00FFh                ;  by shifting this
        shl     bx,cl                   ;  according to the phase
        mov     cl,ah                   ;Restore last mask
;       jmp     phase_proc_50           ;Go compute # of bytes to BLT
        errn$   phase_proc_50


; The different processing for the different X directions has been
; completed, and the processing which is the same regardless of
; the X direction is about to begin.
;
; The phase mask, the first/last byte masks, the X byte offsets,
; and the number of innerloop bytes must be calculated.
;
;
; Nasty stuff coming up here!  We now have to determine how
; many bits will be BLTed and how they are aligned within the bytes.
; This is how it's done (or how I'm going to do it):
;
; The number of bits (inclusive number that is) is added to the
; start MOD 8 value ( the left side of the rectangle, minimum X
; value), then the result is divided by 8. Then:
;
;
;    1) If the result is 0, then only one destination byte is being
;       BLTed.  In this case, the start & ending masks will be ANDed
;       together, the innerloop count (# of full bytes to BLT) will
;       be zeroed, and the fr.last_mask set to all 0's (don't alter any
;       bits in last byte which will be the byte following the first
;       (and only) byte).
;
;               |      x x x x x|               |
;               |_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|
;                0 1 2 3 4 5 6 7
;
;               start MOD 8 = 3,  extent-1 = 4
;               3+7 DIV 8 = 0, only altering one byte
;
;
;
;    2) If the result is 1, then only two bytes will be BLTed.
;       In this case, the start and ending masks are valid, and
;       all that needs to be done is set the innerloop count to 0.
;       (it is true that the last byte could have all bits affected
;       the same as if the innerloop count was set to 1 and the
;       last byte mask was set to 0, but I don't think there would be
;       much time saved special casing this).
;
;               |  x x x x x x x|x x x x x x x|
;               |_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|
;                0 1 2 3 4 5 6 7
;
;               start MOD 8 = 1,  extent-1 = 14
;               3+14 DIV 8 = 1.  There is a first and last
;               byte but no innerloop count
;
;
;
;    3) If the result is >1, then there is some number of entire
;       bytes to be BLted by the innerloop.  In this case the
;       number of innerloop bytes will be the result - 1.
;
;               |              x|x x x x x x x x|x
;               |_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|
;                0 1 2 3 4 5 6 7
;
;               start MOD 8 = 7,  extent-1 = 9
;               7+9  DIV 8 = 2.  There is a first and last
;               byte and an innerloop count of 1 (result - 1)
;
;       Currently:      AL = horizontal phase
;                       BX = horizontal phase mask
;                       CH = first byte mask
;                       CL = last byte mask
;                       DX = left side X MOD 8 + inclusive X count
;                       SI = source start X
;                       DI = dest   start X

phase_proc_50:
        mov     fr.phase_h,al           ;Save horizontal phase
        mov     fr.mask_p,bx            ;Save phase mask
        shr     dx,3                    ;/8 to get full byte count
        jnz     phase_proc_60           ;Result is >0, check it out

; There will only be one byte affected.  Therefore the two byte masks
; must be combined, the last byte mask cleared, and the innerloop
; count set to zero.

        or      fr.first_fetch,FF_ONLY_1_DEST_BYTE
        and     ch,cl                   ;Combine the two masks
        xor     cl,cl                   ;Clear out the last byte mask
        inc     dx                      ;Now just fall through to set
        errn$   phase_proc_60           ;  the innerloop count to 0!

phase_proc_60:
        dec     dx                      ;Dec count (might become 0 just like
        movzx   edx,dx                  ;  we want), and save it
        mov     fr.inner_loop_count,edx
        mov     bl,ch
        mov     ch,cl                   ;Compute last byte mask
        not     cl                      ;  and save it
        mov     fr.last_mask,cx
        mov     bh,bl                   ;Compute start byte mask
        not     bl                      ;  and save it
        mov     fr.start_mask,bx

; There may or may not be a source bitmap for the following address
; computation.  If there is no source, then the vertical setup code
; will be entered with both the source and destination Y's set to the
; destination Y and the address calculation skipped.  If there is a
; source, then the address calculation will be performed and the
; vertical setup code entered with both the source and destination Y's.

phase_processing_y:
        shr     di,3                    ;Compute byte offset of destination
        movzx   edi,di                  ;  and add to current destination
        add     fr.dest.lp_bits,edi      ;  offset

        mov     dx,fr.DestyOrg          ;Get destination Y origin
        mov     ax,dx                   ;Assume no source
        mov     cl,fr.the_flags
        test    cl,F0_SRC_PRESENT       ;Is a source needed?
        jz      phase_proc_70           ;  No, skip source set-up
        shr     si,3                    ;Compute byte offset of source
        movzx   esi,si                  ;  and add to current source offset
        add     fr.src.lp_bits,esi
        mov     ax,fr.SrcyOrg           ;Get source Y origin


        subttl  Phase Processing (Y)
        page

; The horizontal parameters have been calculated.  Now the vertical
; parameters must be calculated.
;
; Currently:
;         DX = destination Y origin
;         AX = source Y origin (destination origin if no source)
;         CL = fr.the_flags

phase_proc_70:
        mov     bx,fr.yExt              ;Get the Y extent of the BLT
        dec     bx                      ;Make it inclusive


; The BLT will be Y+ if the top of the source is below or equal
; to the top of the destination (cases: 1,4,5,7,8).  The BLT
; will be Y- if the top of the source is above the top of the
; destination (cases: 2,3,6)
;
;
;                 !...................!
;                 !D                  !
;             ____!             ..x   !
;            |S   !               :   !     Start at top of S walking down
;            |    !                   !
;            |    !...................!
;            |                    :
;            |____________________:
;
;
;             __________________
;            |S                 |
;            |    .....................     Start at bottom of S walking up
;            |    !D                  !
;            |    !             :     !
;            |____!           ..x     !
;                 !                   !
;                 !....................


        mov     ch,INCREASE             ;Set Y direction for top to bottom
        cmp     ax,dx                   ;Which direction do we move?
        jge     phase_proc_80           ;Step down screen (cases: 1,4,5,7,8)


; Direction will be from bottom of the screen up (Y-)
;
; This code will not be executed if there is no source since
; both Y's were set to the destination Y.


        add     dx,bx                   ;Find bottom scan line index for
        add     ax,bx                   ;  destination and source
        mov     ch,DECREASE             ;Set pattern increment

phase_proc_80:
        mov     fr.pat_row,dl           ;Set pattern row and increment
        mov     fr.direction,ch
        sar     ch,1                    ;Map FF==>FF, 01==>00
        errnz   DECREASE-0FFFFFFFFh
        errnz   INCREASE-00001h


; The Y direction has been computed.  Compute the rest of the
; Y parameters.  These include the actual starting address,
; the scan line and plane increment values, and whether or not
; the extents will cross a 64K boundary.
;
; Currently:
;         DX = Y of starting destination scan
;         AX = Y of starting source scan
;         CH = BLT direction
;                00 = increasing BLT, Y+
;                FF = decreasing BLT, Y-
;         CL = fr.the_flags
;         BX = inclusive Y extent


phase_proc_90:
        test    cl,F0_SRC_PRESENT       ;Is a source needed?
        movsx   ecx,ch                  ;  (Want ECX = +/- 1)
        jz      phase_proc_100          ;  No, skip source set-up
        test    fr.ppcBlt.fb,PPC_NEEDED ;Packed pel conversion needed?
        jz      phase_proc_95           ;  No, use normal setup
        push    ebp                     ;  Yes, perform packed pel work
        lea     ebp,fr
        cCall   packed_pel_comp_y
        pop     ebp
        jmp     short phase_proc_100

phase_proc_95:
        push    dx                      ;Save destination Y
        push    ebp                     ;Mustn't trash frame pointer
        lea     ebp,fr.src              ;--> source data structure
        cCall   compute_y               ;Process as needed
        pop     ebp
        pop     dx                      ;Restore destination Y

phase_proc_100:
        push    ebp                     ;Mustn't trash frame pointer
        mov     ax,dx                   ;Put destination Y in ax
        lea     ebp,fr.dest             ;--> destination data structure
        cCall   compute_y
        pop     ebp                     ;Restore frame pointer

        subttl  Memory allocation for BLT compilation
        page
cblt_allocate:
        sub     esp,MAX_BLT_SIZE
        mov     edi,esp
        mov     fr.blt_addr,edi         ;Save the address for later
        push    ebp
        lea     ebp,fr
        cCall   cblt                    ;compile the BLT onto the stack
        pop     ebp

; The BLT has been created on the stack.  Set up the initial registers,
; set the direction flag as needed, and execute the BLT.

        mov     esi,fr.src.lp_bits      ;--> source device's first byte
        mov     edi,fr.dest.lp_bits     ;--> destination device's first byte
        mov     cx,fr.yExt              ;Get count of lines to BLT
        cld                             ;Assume this is the direction
        cmp     fr.step_direction,STEPRIGHT ;Stepping to the right?
        jz      call_blt_do_it          ;  Yes
        std
call_blt_do_it:
        push    ebp                     ;MUST SAVE THIS
        call    fr.blt_addr             ;Call the FAR process
        pop     ebp
        add     esp,MAX_BLT_SIZE        ;Return BLT space
        errn$   bitblt_exit

bitblt_exit:

; Here we test if the VGA was involved and skip reseting the VGA state if
; it was not involved.

        test    fr.the_flags,F0_DEST_IS_DEV + F0_SRC_IS_DEV
        jz      ega_not_involved

; Restore EGA registers to the default state.

        mov     dx,EGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al
        mov     dl,GRAF_ADDR
        mov     ax,0FF00h + GRAF_BIT_MASK
        out     dx,ax
        mov     ax,DR_SET shl 8 + GRAF_DATA_ROT
        out     dx,ax
        mov     ax,GRAF_ENAB_SR
        out     dx,ax
ega_not_involved:

        mov     eax,1                   ;Clear out error register (good exit)
        cld                             ;Leave direction cleared
        cRet    vCompiledBlt

xxxvCompiledBlt endp



;----------------------------Private-Routine----------------------------;
; copy_device
;
; Copy device information to frame.
;
; Entry:
;       ESI = pdsurf
;       EDI --> frame DEV structure
;       EBP --> PPC structure (for source only)
;       BH     =  fr.the_flags, accumulated so far
; Returns:
;       BH     =  fr.the_flags, accumulated so far
;       Carry clear if no error
;       EBP --> PPC structure
; Error Returns:
;       None
; Calls:
;       None
; History:
;  Sun 22-Feb-1987 16:29:09 -by-  Walt Moore [waltm]
; Created.
;-----------------------------------------------------------------------;

cProc   copy_dev

        mov     eax,[esi].dsurf_sizlSurf.sizl_cx
        mov     [edi].width_bits,ax
        mov     eax,[esi].dsurf_sizlSurf.sizl_cy
        mov     [edi].height,ax
        mov     eax,[esi].dsurf_lNextScan
        mov     [edi].width_b,ax
        mov     eax,[esi].dsurf_pvBitmapStart
        mov     [edi].lp_bits,eax
        mov     eax,[esi].dsurf_lNextPlane
        mov     [edi].next_plane,eax
        mov     al,[esi].dsurf_iFormat
        shl     bh,1
        cmp     al,BMF_PHYSDEVICE
        sete    ah
        or      bh,ah
        errnz   F0_SRC_IS_DEV-00001000b
        errnz   F0_DEST_IS_DEV-0000010b

        shl     bh,1
        cmp     al,BMF_1BPP
        je      copy_dev_20             ;Mono, color bit is clear
        or      bh,F0_DEST_IS_COLOR
        errnz   F0_SRC_IS_COLOR-00000100b
        errnz   F0_DEST_IS_COLOR-00000001b

; The source may be a packed pel source, which will have to be converted

        cmp     al,BMF_DEVICE           ;4 plane format
        je      copy_dev_20             ;  Yes, no packed pel conversion
        cmp     al,BMF_PHYSDEVICE
        je      copy_dev_20             ;  ditto

        mov     [ebp].iFormat,al        ;Save source format
        mov     [ebp].fb,PPC_NEEDED     ;Show conversion needed
copy_dev_20:

        mov     al,bh                   ;Set IS_COLOR and IS_DEVICE
        and     al,IS_COLOR+IS_DEVICE   ;  flags in the Device Flags
        errnz   IS_COLOR-F0_DEST_IS_COLOR ;Must be same bits
        mov     [edi].dev_flags,al
        cRet    copy_dev

endProc copy_dev


;----------------------------Private-Routine----------------------------;
; pattern_preprocessing
;
; If a pattern is needed, make sure that it isn't a hollow
; brush. If it is a hollow brush, then return an error.
;
; The type of brush to use will be set, and the brush pointer
; updated to point to the mono bits if the mono brush will be
; used.  The type of brush used will match the destination device.
;
; If the destination is mono and the source is color, then a mono
; brush fetch will be used, with the color brush munged in advance
; according to the background/foreground colors passed:
;
;     All brush pixels which match the background color should be set
;     to white (1).  All other brush pixels should be set to black (0).
;
;     If the physical color is stored as all 1's or 0's for each
;     plane, then by XORing the physical color for a plane with the
;     corresponding byte in the brush, and ORing the results, this
;     will give 0's where the color matched, and  1's where the colors
;     didn't match.  Inverting this result will then give 1's where
;     the brush matched the background color and 0's where it did not.
;
; If both the source and destination are color, or the source is mono
; and the destination color, then the color portion of the brush will
; be used.
;
; If both the source and destination are mono, then the monochrome
; portion of the brush will be used.
;
; Entry:
;       BH = fr.the_flags
;       EBP = fr
; Returns:
;       Carry flag clear if no error
; Error Returns:
;       Carry flag set if error (null lpPBrush, or hollow brush)
; Registers Preserved:
;       EBP
; Registers Destroyed:
;       AX,BX,CX,DX,SI,DI,DS,ES,flags
; Calls:
;       None
; History:
;  Sat 15-Aug-1987 18:20:34 -by-  Wesley O. Rupel [wesleyr]
; Added 4-plane support.
;  Sun 22-Feb-1987 16:29:09 -by-  Walt Moore [waltm]
; Created.
;-----------------------------------------------------------------------;

;------------------------------Pseudo-Code------------------------------;
; {
; }
;-----------------------------------------------------------------------;

cProc   pattern_preprocessing

        mov     [ebp].the_flags,bh      ;Save flag values
        test    bh,F0_PAT_PRESENT       ;Pattern required?
        jz      pattern_preproc_end     ;  No, skip pattern check
        mov     esi,[ebp].lpPBrush      ;--> physical brush
        mov     dl,[esi].oem_brush_accel;Save brush accelerator
        mov     [ebp].brush_accel,dl    ; in local variable frame
        test    dl,SOLID_BRUSH          ;Don't need to rotate a solid brush
        jnz     pattern_preproc_end

; !!! hack-o-ramma.  rotate the brush on the frame for now.

        push    ebx
        mov     edx,00000111b
        lea     edi,[ebp].a_brush.oem_brush_C0  ;EDI --> temp brush area
        mov     [ebp].lpPBrush,edi
        mov     ebx,[ebp].pptlBrush
        mov     ecx,dword ptr [ebx][0]
        and     ecx,edx
        mov     ebx,dword ptr [ebx][4]
        and     ebx,edx
        mov     ch,4

pattern_preproc_color:
        lodsb
        and     ebx,edx
        ror     al,cl
        mov     byte ptr [edi][ebx],al
        inc     ebx

        lodsb
        and     ebx,edx
        ror     al,cl
        mov     byte ptr [edi][ebx],al
        inc     ebx

        lodsb
        and     ebx,edx
        ror     al,cl
        mov     byte ptr [edi][ebx],al
        inc     ebx

        lodsb
        and     ebx,edx
        ror     al,cl
        mov     byte ptr [edi][ebx],al
        inc     ebx

        lodsb
        and     ebx,edx
        ror     al,cl
        mov     byte ptr [edi][ebx],al
        inc     ebx

        lodsb
        and     ebx,edx
        ror     al,cl
        mov     byte ptr [edi][ebx],al
        inc     ebx

        lodsb
        and     ebx,edx
        ror     al,cl
        mov     byte ptr [edi][ebx],al
        inc     ebx

        lodsb
        and     ebx,edx
        ror     al,cl
        mov     byte ptr [edi][ebx],al
        inc     ebx

        add     edi,8
        dec     ch
        jnz     pattern_preproc_color
        pop     ebx

pattern_preproc_end:
        clc
        cRet    pattern_preprocessing

endProc pattern_preprocessing


;----------------------------Private-Routine----------------------------;
; compute_y
;
; Compute y-related parameters.
;
; The parameters related to the Y coordinate and BLT direction
; are computed.  The parameters include:
;
;       a) Index to next scan line
;       b) Starting Y address calculation
;       d) Index to next plane
;
; Entry:
;       EBP --> DEV structure to use (src or dest)
;       AX  =  Y coordinate
;       ECX =  BLT direction
;              0000 = Y+
;              FFFF = Y-
;       BX  =  inclusive Y extent
; Returns:
;       ECX  =  BLT direction
;       EBX  =  inclusive count
; Registers Preserved:
;       EBP
; Registers Destroyed:
;       AX,DX,SI,DI,flags
; Calls:
;       None
; History:
;-----------------------------------------------------------------------;

cProc   compute_y

        movsx   esi,[ebp].width_b       ;Need bmWidthBytes a couple of times
        movzx   eax,ax
        mul     esi                     ;Compute Y address
        add     [ebp].lp_bits,eax
        xor     esi,ecx                 ;1's complement if Y-
        sub     esi,ecx                 ;2's complement if Y-

        test    [ebp].dev_flags,IS_DEVICE
        jnz     compute_y_done
        test    [ebp].dev_flags,IS_COLOR
        jz      compute_y_done


; !!! I need to rewrite how next scan is handled.  Currently, for +Y, next scan is 0,
; !!! and for -Y it is 2* -lNextScan

        add     esi,esi                 ;Assume -Y (comp 2 * -lNextScan)
        and     esi,ecx                 ;ESI = 0 if +Y, or 2 * -lNextScan

compute_y_done:
        mov     [ebp].next_scan,esi     ;Set index to next scan line
        cRet    compute_y               ;All done with device, small bitmaps

endProc compute_y

_TEXT$02   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\colorpat.asm ===
;-----------------------------------------------------------------------;
                .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc
        include i386\ropdefs.inc
        include i386\display.inc         ; Display specific structures

        .list

;-----------------------------------------------------------------------;

        .data

;
; We share some tables with vgablts.asm
;

extrn   jALUFuncTable :byte
extrn   jLeftMask  :byte
extrn   jRightMask :byte
extrn   jForceOnTable :byte
extrn   jNotTable :byte
extrn   jInvertDest :byte
extrn   jForceOffTable :byte
extrn   vTrgBlt@20 :dword

;-----------------------------------------------------------------------;
; Table of routines to be called to draw edges, according to which edges are
; partial and which edges are whole bytes.
        align   4
        public pfnClrEdgeDrawing
pfnClrEdgeDrawing  label   dword
        dd      clr_edge_byte_setup
        dd      clr_edge_byte_setup
        dd      clr_check_next_bank
        dd      clr_edge_byte_setup


;-----------------------------------------------------------------------;
; Table of pointers to in-line code top copy a whole 8x8 planar pattern
; to the first whole byte on the screen

        align   4
        public  PlaneCopyTable
PlaneCopyTable label dword
        dd      do_1_line
        dd      do_2_lines
        dd      do_3_lines
        dd      do_4_lines
        dd      do_5_lines
        dd      do_6_lines
        dd      do_7_lines
        dd      do_8_lines

        align   4
        public  QuickMul
QuickMul label dword
        dd      quick_add_0
        dd      quick_add_1
        dd      quick_add_2
        dd      quick_add_3
        dd      quick_add_4
        dd      quick_add_5
        dd      quick_add_6

;-----------------------------------------------------------------------;
; Table of pointers to tables used to find entries points in wide whole
; byte code.

        align   4
        public pfnWideWholeRepClr
pfnWideWholeRepClr label   dword
        dd      draw_wide_00_clr
        dd      draw_wide_01_clr
        dd      draw_wide_10_clr
        dd      draw_wide_11_clr

;-----------------------------------------------------------------------;
; Table of pointers to tables used to find entry points in narrow, special-
; cased replace whole byte code.

; Note: The breakpoint where one should switch from special-casing to
;  REP STOS is purely a guess on my part. 8 seemed reasonable.

; Start address MOD 2 is 0.
        align   4
        public pfnWholeBytesMod0Color
pfnWholeBytesMod0Color  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_clr_even_loop
        dd      draw_2_clr_even_loop
        dd      draw_3_clr_even_loop
        dd      draw_4_clr_even_loop
        dd      draw_5_clr_even_loop
        dd      draw_6_clr_even_loop
        dd      draw_7_clr_even_loop
        dd      draw_8_clr_even_loop
MAX_REPLACE_SPECIAL equ     ($-pfnWholeBytesMod0Color)/4

; Start address MOD 2 is 1.
        align   4
        public pfnWholeBytesMod1Color
pfnWholeBytesMod1Color  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_clr_odd_loop
        dd      draw_2_clr_odd_loop
        dd      draw_3_clr_odd_loop
        dd      draw_4_clr_odd_loop
        dd      draw_5_clr_odd_loop
        dd      draw_6_clr_odd_loop
        dd      draw_7_clr_odd_loop
        dd      draw_8_clr_odd_loop


;-----------------------------------------------------------------------;
; Table of pointers to tables used to find entries points in narrow, special-
; cased non-replace whole byte code.

; Note: The breakpoint where one should switch from special-casing to
;  REP MOVSB is purely a guess on my part. 5 seemed reasonable.

        align   4
pfnWholeBytesNonRepClr  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_wide_clr_rop
        dd      draw_2_wide_clr_rop
        dd      draw_3_wide_clr_rop
        dd      draw_4_wide_clr_rop
MAX_NON_REPLACE_SPECIAL equ     ($-pfnWholeBytesNonRepClr)/4

; Master MOD 2 alignment look-up table for entry tables for two possible
; alignments for narrow, special-cased replace whole byte code.
        align   4
        public pfnWholeBytesSpecColor
pfnWholeBytesSpecColor      label   dword
        dd      pfnWholeBytesMod0Color
        dd      pfnWholeBytesMod1Color

        .code

;=============================================================================

cProc   vClrPatBlt,24,<    \
        uses esi edi ebx, \
        pdsurf: ptr DEVSURF, \
        culRcl: dword,       \
        prcl:   ptr RECTL,   \
        ulMix:  dword,       \
        pBrush: ptr oem_brush_def, \
        pBrushOrg: ptr POINTL >

        local        ulRowOffset :dword      ;Offset from start of scan line
                                        ; first byte to fill
        local   ulWholeBytes :dword     ;# of whole bytes to fill
        local   ulWholeWords :dword     ;# of whole words to fill excluding
                                        ;leading and/or trailing bytes
        local   pfnWholeFn  :dword      ;pointer to routine used to draw
                                        ; whole bytes
        local   ulScanWidth :dword      ;offset from start of one scan to start
                                        ; of next
        local   ulNextScan  :dword      ;offset from end of one scan line's
                                        ; fill to start of next
        local   ulCurrentTopScan :dword ;top scan line to fill in current bank
        local   ulMasks     :dword      ;low byte = right mask, high byte =
                                        ; left mask
        local   ulBottomScan :dword     ;bottom scan line of fill rectangle

        local   jALUFunc   :dword       ;VGA ALU logical operation (SET, AND,
                                        ; OR, or XOR)
        local   pfnStartDrawing :dword  ;pointer to function to call to start
                                        ; drawing
        local   pfnContinueDrawing :dword ;pointer to function to call to
                                        ; continue drawing after doing whole
                                        ; bytes
        local   ulLeftEdgeAdjust :dword ;used to bump the whole bytes start
                                        ; address past the left edge when the
                                        ; left edge is partial
        local   pfnWholeBytes :dword    ;pointer to table of entry points
                                        ; into loops for whole byte filling
        local   ulSpecialBytes          ;If we are doing a special case wide
                                        ; fill, this will be the width of the
                                        ; fill. We need this so we can properly
                                        ; increment to the next line.
        local   ulVbNextScan :dword     ;Offset from the end of the current
                                        ; wide fill drawing operation to the
                                        ; top of the next venetian blind line
        local   fdInvertDestFirst :dword;1 if the rop requires a pass to invert
                                        ; the destination before the normal
                                        ; pass
        local   jAndMask;               ;Color processing mask for ROP blts

        local   jOrMask;                ;Color processing mask for ROP blts

        local   jXorMask;               ;Color processing mask for ROP blts

        local   ulPatternOrgY: dword    ;Local copy of the pattern offset Y

        local   ulVbBlindCount :dword   ;Temp Height of pattern.

        local   ulRopNextScan:dword     ;

        local   ulVbTopScan :dword      ;slats in our blinds

        local   pUlVbPattern:dword      ;inner loop pattern pointer

        local   pUlPattern:dword        ;current pattern with proper Y offset

        local   RotatedPat[64]:byte     ;Aligned pattern buffer

        local   pfnReadModWrite:dword   ;Pointer to the desired inner loop
                                        ;for partial byte/ROP code.
        cld

MASKOFFSET=64           ;offset from pattern data to mask data

;-----------------------------------------------------------------------;
; Make sure there's something to draw; clip enumerations can be empty.
;-----------------------------------------------------------------------;

        cmp     culRcl,0                ;any rects to fill?
        jz      vClrPatBlts_done         ;no, we're done

        mov     esi,pBrush                ;point to the brush
        xor     eax,eax

;-----------------------------------------------------------------------;
; Set up for the desired raster op.
;-----------------------------------------------------------------------;
        sub     ebx,ebx                 ;ignore any background mix; we're only
        mov     bl,byte ptr ulMix       ; concerned with the foreground in this
                                        ; module
        cmp     ebx,R2_NOP              ;is this NOP?
        jz      vClrPatBlts_done         ;yes, we're done

        sub     eax,eax                 ;we want a dword
        mov     al,jInvertDest[ebx]     ;remember whether we need to invert the
        mov     fdInvertDestFirst,eax   ; destination before finishing the rop

        xor     eax,eax

        mov     al,byte ptr jForceOffTable[ebx]  ;force color to 0 if necessary
        mov     jAndMask,eax                     ; (R2_BLACK)

        mov     al,byte ptr jForceOnTable[ebx]   ;force color to 0ffh if necessary
        mov     jOrMask,eax                     ; (R2_WHITE, R2_NOT)

        mov     al,byte ptr jNotTable[ebx]       ;invert color if necessary (any Pn mix)
        mov     jXorMask,eax

        mov     ah,jALUFuncTable[ebx]   ;get the ALU logical function
        and     ah,ah                   ;is the logical function DR_SET?
        .errnz  DR_SET
        jz      short skip_ALU_set      ;yes, don't have to set because that's
                                        ; the VGA's default state
        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_DATA_ROT
        out     dx,ax                   ;set the ALU logical function
skip_ALU_set:
        mov     byte ptr jALUFunc,ah    ;remember the ALU logical function

;-----------------------------------------------------------------------;
; Set up variables that are constant for the entire time we're in this
; module.
;-----------------------------------------------------------------------;
        mov     edx,pBrushOrg                ;point to the brush origin

        mov     ecx,[edx].ptl_y
        mov     ulPatternOrgY,ecx

        mov     ecx,[edx].ptl_x
        and     ecx,7                        ;eax mod 8

        ;We are now going to make a copy of our rotated copy of our pattern.
        ;The reason that we do this is because we may be called with several
        ;rectangles and we don't really want to rotate the pattern data for
        ;each rectangle. We copy this rectangle to be double high so that
        ;we can incorperate our Y offest later without having to worry
        ;about running off the end of the pattern.

        lea     edi,RotatedPat                  ;Pattern Dest
        mov     esi,[esi + oem_brush_pmono]     ;Pattern Src

        mov     ah,byte ptr ulMix       ; concerned with the foreground in this
                                        ; module
        cmp     ah,R2_COPYPEN           ;If we are doing the ROP, we will
        jne     rotate_pattern_ROP      ;process the color as we rotate
        or      ecx,ecx
        jnz     rotate_pattern_ROP
        ; Since there is no rotation we just need to expand our pattern
        ; to be double tall.
INDEX=0
DSTINDEX=0
        rept    4
        mov     eax,[esi+INDEX]
        mov     [edi+DSTINDEX],eax
        mov     [edi+8+DSTINDEX],eax
INDEX=INDEX+4
DSTINDEX=DSTINDEX+4
        mov     eax,[esi+INDEX]
        mov     [edi+DSTINDEX],eax
        mov     [edi+8+DSTINDEX],eax
INDEX=INDEX+4
DSTINDEX=DSTINDEX+12
        endm    ;-----------------
        jmp     copy_masks


rotate_pattern_ROP:
        mov     ch,4                    ;Loop count
        mov     bl,byte ptr jAndMask    ;Load up color processing masks
        mov     bh,byte ptr jOrMask
        mov     dl,byte ptr jXorMask

shift_pattern_loop_ROP:
INDEX=0
        rept    8                       ;patterns are 8x8 planar (4*8)
        mov     al,[esi+INDEX]          ;load bytes for shift
        ror     al,cl                   ;shift into position
        and     al,bl
        or      al,bh
        xor     al,dl
        mov     [edi+INDEX],al          ;save result
        mov     [edi+8+INDEX],al        ;save result to second copy
INDEX=INDEX+1
        endm    ;-----------------
        add     edi,16
        add     esi,8
        dec     ch
        jnz     shift_pattern_loop_ROP

copy_masks:
fill_rect_loop:
;-----------------------------------------------------------------------;
; Set up masks and widths.
;-----------------------------------------------------------------------;
        mov     edi,prcl                ;point to rectangle to fill

        sub     eax,eax
        mov     ulLeftEdgeAdjust,eax    ;initalize variable
        mov     ulSpecialBytes,eax        ;initalize variable

        mov     eax,[edi].yBottom
        mov     ulBottomScan,eax        ;remember the bottom scan line of fill

        mov     ebx,[edi].xRight        ;right edge of fill (non-inclusive)
        mov     ecx,ebx
        and     ecx,0111b               ;intrabyte address of right edge
        mov     ah,jRightMask[ecx]      ;right edge mask

        mov     esi,[edi].xLeft         ;left edge of fill (inclusive)
        mov     ecx,esi
        shr     ecx,3                   ;/8 for start offset from left edge
                                        ; of scan line
        mov     ulRowOffset,ecx         ;remember offset from start of scan
                                        ; line
        sub     ebx,esi                 ;width in pixels of fill

        and     esi,0111b               ;intrabyte address of left edge
        mov     al,jLeftMask[esi]       ;left edge mask

        dec     ebx                     ;make inclusive on right
        add     ebx,esi                 ;inclusive width, starting counting at
                                        ; the beginning of the left edge byte
        shr     ebx,3                   ;width of fill in bytes touched - 1
        jnz     short more_than_1_byte  ;more than 1 byte is involved

; Only one byte will be affected. Combine first/last masks.

        and     al,ah                   ;we'll use first byte mask only
        xor     ah,ah                   ;want last byte mask to be 0
        inc     ebx                     ;so there's one count to subtract below
                                        ; if this isn't a whole edge byte
more_than_1_byte:

; If all pixels in the left edge are altered, combine the first byte into the
; whole byte count and clear the first byte mask, because we can handle solid
; edge bytes faster as part of the whole bytes. Ditto for the right edge.

        sub     ecx,ecx                 ;edge whole-status accumulator
        cmp     al,-1                   ;is left edge a whole byte or partial?
        adc     ecx,ecx                 ;ECX=1 if left edge partial, 0 if whole
        sub     ebx,ecx                 ;if left edge partial, deduct it from
                                        ; the whole bytes count
        mov     ulLeftEdgeAdjust,ecx    ;for skipping over the left edge if
                                        ; it's partial when pointing to the
                                        ; whole bytes
        and     ah,ah                   ;is right edge mask 0, meaning this
                                        ; fill is only 1 byte wide?
        jz      short save_masks        ;yes, no need to do anything
        cmp     ah,-1                   ;is right edge a whole byte or partial?
        jnz     short save_masks        ;partial
        mov     ah,0                    ;
        add     ecx,2                   ;bit 1 of ECX=0 if right edge partial,
                                        ; 1 if whole;
                                        ;bit 1=0 if left edge partial, 1 whole
        inc     ebx                     ;if right edge whole, include it in the
                                        ; whole bytes count
save_masks:
        mov     ulMasks,eax             ;save left and right clip masks
        mov     ulWholeBytes,ebx        ;save # of whole bytes

        mov     ecx,pfnClrEdgeDrawing[ecx*4] ;set address of routine to draw
        mov     pfnContinueDrawing,ecx    ; all partial (non-whole) edges

        and     ebx,ebx                 ;any whole bytes?
        jz      start_vec_set           ;no
                                        ;yes, so draw the whole bytes before
                                        ; the edge bytes

; The whole bytes loop depends on the type of operation being done. If the
; operation is one which uses DR_SET, then we can use a STOS-type operation,
; else we have to use a MOVSB-type operation (to load the latches with the
; existing contents of display memory to allow the ALUs to work).
        cmp     byte ptr jALUFunc,DR_SET ;is it a replace-type rop?
        jz      short is_replace_type   ;yes
                                        ;no, set up for non-replace whole bytes
        mov     ecx,offset non_replace_wide_clr

        cmp     ebx,MAX_NON_REPLACE_SPECIAL ;too wide to special case?
        jb      short non_replace_spec     ;nope

                                        ;assume too wide to special-case
        mov     pfnWholeBytes,offset draw_wide_rop_clr ; table for width

        jmp     short start_vec_set

non_replace_spec:

        mov     eax,pfnWholeBytesNonRepClr[ebx*4] ;no, point to entry
        mov     pfnWholeBytes,eax       ; table for width
        mov     ulSpecialBytes,ebx
                                        ;narrow enough to special case. Look up
                                        ; the entry table for the special case
                                        ; base on the start alignment

        jmp     short start_vec_set

is_replace_type:                        ;set up for replace-type rop
        cmp     ebx,MAX_REPLACE_SPECIAL ;too wide to special case?
        jnb     short is_wide_replace   ;yes

        mov     ulSpecialBytes,ebx
                                        ;narrow enough to special case. Look up
                                        ; the entry table for the special case
                                        ; base on the start alignment
        mov     ecx,ulRowOffset
        add     ecx,ulLeftEdgeAdjust    ;left edge whole bytes start offset
        and     ecx,01b                 ;left edge whole bytes start alignment
                                        ; MOD 2
        mov     ecx,pfnWholeBytesSpecColor[ecx*4] ;look up table of entry
                                                      ; tables for alignment
        mov     ecx,[ecx+ebx*4]         ;look up entry table for width
        mov     pfnWholeBytes,ecx       ; table for width
        mov     ecx,offset clr_whole_bytes_rep_wide

        jmp     short start_vec_set

is_wide_replace:                        ;set up for wide replace-type op
                                        ;Note: assumes there is at least one
                                        ; full word involved!
        mov     ecx,ulRowOffset
        add     ecx,ulLeftEdgeAdjust    ;left edge whole bytes start offset
        neg     ecx
        and     ecx,01b
        mov     edx,ebx
        sub     edx,ecx                 ;ignore odd leading bytes
        mov     eax,edx
        shr     edx,1                   ;# of whole words across (not counting
                                        ; odd leading & trailing bytes)
        mov     ulWholeWords,edx
        and     eax,01b                 ;# of odd (fractional) trailing bytes
        add     ecx,ecx
        or      ecx,eax                 ;build a look-up index from the number
                                        ; of leading and trailing bytes
        mov     ecx,pfnWideWholeRepClr[ecx*4] ;proper drawing handler for front/
        mov     pfnWholeBytes,ecx          ; back alignment
        mov     ecx,offset clr_whole_bytes_rep_wide
                                        ;set up to call routine to perform wide
                                        ; whole bytes fill

start_vec_set:
        mov     pfnStartDrawing,ecx     ; all partial (non-whole) edges

        mov     ecx,pdsurf
        mov     eax,[ecx].dsurf_lNextScan
        mov     ulScanWidth,eax         ;local copy of scan line width
        sub     eax,ebx                 ;EAX = delta to next scan
        mov     ulNextScan,eax

        mov     eax,UlScanWidth
        shl     eax,3                   ;ulNextScan * 8
        mov     ulVbNextScan,eax        ;

        cmp     fdInvertDestFirst,1     ;is this an invert-dest-plus-something-
                                        ; else rop that requires two passes?
        jnz     short do_single_pass

        lea     eax,vTrgBlt@20
        ptrCall <eax>,<pdsurf, culRcl, prcl, R2_NOT, -1>

        mov     ah,byte ptr jALUFunc    ;reset the ALU logical function
        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_DATA_ROT
        out     dx,ax                   ;set the ALU logical function

do_single_pass:
        call    draw_banks

;-----------------------------------------------------------------------;
; See if there are any more rectangles to fill.
;-----------------------------------------------------------------------;

        add     prcl,(size RECTL) ;point to the next rectangle, if there is one
        dec     culRcl            ;count down the rectangles to fill
        jnz     fill_rect_loop


;-----------------------------------------------------------------------;
; We have filled all rectangles.  Restore the VGA to its default state.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,0000h + GRAF_ENAB_SR ;disable set/reset
        out     dx,ax
        mov     eax,GRAF_MODE + ((M_PROC_WRITE + M_DATA_READ) SHL 8)
        out     dx,ax                  ;restore read mode 0 and write mode 0
        mov     eax,(DR_SET shl 8) + GRAF_DATA_ROT ;set the logical function to
        out     dx,ax                             ; SET
vClrPatBlts_done:
        cRet    vClrPatBlt

;-----------------------------------------------------------------------;
; Fills all banks in the current fill rectangle. Called once per fill
; rectangle, except for destination-inversion-plus-something-else rops.
;-----------------------------------------------------------------------;

draw_banks:

;-----------------------------------------------------------------------;
; Map in the bank containing the top scan to fill, if it's not mapped in
; already.
;-----------------------------------------------------------------------;

        mov     edi,prcl                ;point to rectangle to fill
        mov     ecx,pdsurf              ;point to surface
        mov     eax,[edi].yTop          ;top scan line of fill
        mov     ulCurrentTopScan,eax    ;this will be the fill top in 1st bank

        cmp     eax,[ecx].dsurf_rcl1WindowClip.yTop ;is fill top less than
                                                    ; current bank?
        jl      short map_init_bank                 ;yes, map in proper bank
        cmp     eax,[ecx].dsurf_rcl1WindowClip.yBottom ;fill top greater than
                                                       ; current bank?
        jl      short init_bank_mapped          ;no, proper bank already mapped
map_init_bank:

; Map in the bank containing the top scan line of the fill.

        ptrCall <dword ptr [ecx].dsurf_pfnBankControl>,<ecx,eax,JustifyTop>

init_bank_mapped:

;-----------------------------------------------------------------------;
; Main loop for processing fill in each bank.
;-----------------------------------------------------------------------;

; Compute the starting address and scan line count for the initial bank.

        mov     eax,pdsurf              ;EAX->target surface
        mov     ebx,ulBottomScan        ;bottom of destination rectangle
        cmp     ebx,[eax].dsurf_rcl1WindowClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; dest rect or the bottom of the
                                        ; current bank?
        jl      short BottomScanSet     ;fill bottom comes first, so draw to
                                        ; that; this is the last bank in fill
        mov     ebx,[eax].dsurf_rcl1WindowClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
BottomScanSet:
        mov     edi,ulCurrentTopScan    ;top scan line to fill in current bank
        sub     ebx,edi                 ;# of scans to fill in bank
        imul    edi,ulScanWidth         ;offset of starting scan line

; Note that the start of the bitmap will change each time through the
; bank loop, because the start of the bitmap is varied to map the
; desired scan line to the banking window.

        add     edi,[eax].dsurf_pvBitmapStart ;start of scan in bitmap
        add     edi,ulRowOffset         ;EDI = start offset of fill in bitmap

; We have computed the starting address and scan count. Time to start drawing
; in the initial bank.

        mov     esi,pBrush                ;edx = min(PatternHeight,BltHeight)
        mov     ecx,[esi + oem_brush_height]
        sub     ecx,ebx
        sbb     edx,edx
        and     edx,ecx
        add     edx,ebx
        mov     ulVbBlindCount,edx

; Brush alignment. We need to look at pptlBrush

        mov     eax,ulCurrentTopScan    ;top scan line to fill in current bank
        sub     eax,ulPatternOrgY       ;

        jns     short pos_y_offset      ;
        neg     eax                     ;
        and     eax,7                   ;-eax mod 8
        neg     eax                     ;
        add     eax,8                   ;
        jmp     short save_pat_pointer
pos_y_offset:
        and     eax,7                   ;eax mod 8
save_pat_pointer:

        lea     edx,RotatedPat          ;Pattern Dest
        add     eax,edx
        mov     pulPattern,eax          ;Drawing code uses this as the
                                        ;source for the pattern

        jmp     pfnStartDrawing


;-----------------------------------------------------------------------;
; Whole byte fills.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Handles non-replace whole byte fills wider than the maximum special
; case width.
;
; The destination is not involved, so a STOS (or equivalent) can be used
; (no read needed before write).
;-----------------------------------------------------------------------;

        public clr_whole_bytes_rep_wide
clr_whole_bytes_rep_wide::
        push    ebx                     ;save scan count
        push    edi                     ;save starting address

        add     edi,ulLeftEdgeAdjust    ;point to first whole byte to fill

        mov     ulVbTopScan,ebx         ;our pattern is 8 high so we don't
        add     ebx,7                   ;Calc the number of lines to do
        shr     ebx,3                   ;only need to go through the code
                                        ; count/8 times. We will handle any
                                        ; extra lines at the bottom
                                        ; (ulVbTopScan mod 8) in our loops.
        push    ulVbBlindCount
        mov     esi,pulPattern          ; pointer to pattern bits

        ;
        ; Copy whole pattern to screen
        ;
        push    edi                             ;save dest pointer
        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,GRAF_MODE + ((M_PROC_WRITE + M_COLOR_READ) SHL 8)
        out     dx,ax                           ;write mode 0, read mode 0

        mov     ecx,ulVbBlindCount
        mov     eax,ulScanWidth
        dec     ecx                     ;zero base this for our lookup later
        mov     edx,eax
        cmp     ecx,7                   ;We need to mul the ScanWidth by the
        jne     do_quick_mul            ;height. If it is the common case of
        shl     eax,3                   ;8, we just shift. Otherwise we jump
                                        ;down to the special case code to do
                                        ;the adding.
        sub     edi,edx                 ;Dest += (height - 1) * ulScanWidth
        add     edi,eax
        push    edi                         ;Save pointer to bottom line

        mov     al,MM_C0                ;Setup plane mask to plane 0
        mov     edx,VGA_BASE + SEQ_DATA
        out     dx,al
        mov     ecx,PlaneCopyTable[ecx*4] ;jmp into do_?_lines where ? = ecx+1
        jmp     ecx

do_quick_mul:
        jmp     QuickMul[ecx*4]
quick_add_6::
        add     eax,edx
quick_add_5::
        add     eax,edx
quick_add_4::
        add     eax,edx
quick_add_3::
        add     eax,edx
quick_add_2::
        add     eax,edx
quick_add_1::
        add     eax,edx
quick_add_0::

        sub     edi,edx                 ;Dest += (height - 1) * ulScanWidth
        add     edi,eax
        push    edi                     ;Save pointer to bottom line

        mov     al,MM_C0                ;Setup plane mask to plane 0
        mov     edx,VGA_BASE + SEQ_DATA
        out     dx,al
        mov     ecx,PlaneCopyTable[ecx*4] ;jmp into do_?_lines where ? = ecx+1
        jmp     ecx


        ; ah  = data
        ; al  = plane mask
        ; ebx = scan count (not used)
        ; ecx = pointer into the in-line copy code
        ; edx = VGA_BASE+SEQ_DATA
        ; esi = pattern source
        ; edi = screen
        ; esp = points to our saved dest (edi)
        ;

do_8_lines::
        mov     ah,[esi+7]
        mov     [edi],ah
        sub     edi,ulScanWidth
do_7_lines::
        mov     ah,[esi+6]
        mov     [edi],ah
        sub     edi,ulScanWidth
do_6_lines::
        mov     ah,[esi+5]
        mov     [edi],ah
        sub     edi,ulScanWidth
do_5_lines::
        mov     ah,[esi+4]
        mov     [edi],ah
        sub     edi,ulScanWidth
do_4_lines::
        mov     ah,[esi+3]
        mov     [edi],ah
        sub     edi,ulScanWidth
do_3_lines::
        mov     ah,[esi+2]
        mov     [edi],ah
        sub     edi,ulScanWidth
do_2_lines::
        mov     ah,[esi+1]
        mov     [edi],ah
        sub     edi,ulScanWidth
do_1_line::
        mov     ah,[esi]
        mov     [edi],ah
do_next_plane:
        add     al,al                   ; Move to the next plane
        test    al,010h                 ; Are we finished?
        jnz     @f                      ;  if yes, jump
        add     esi,16                  ; move source ptr to next plane
        out     dx,al                   ; set mask to next plane
        mov     edi,[esp]               ; reload dest ptr
        jmp     ecx                     ; copy over next plane
@@:
        pop     eax                     ; removed saved dest ptr from stack
        mov     al,0fh                  ; restore access to all planes
        out     dx,al
        pop     edi                     ;restore screen dest pointer

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,GRAF_MODE + ((M_LATCH_WRITE + M_COLOR_READ) SHL 8)
        out     dx,ax                   ;write mode 2 so we can write the
                                        ; latches, read mode 1 so we can
                                        ; read 0xFF from memory always, for
                                        ; ANDing (because Color Don't Care is
                                        ; all zeros)

        ; Now we venetian blind the pattern that we just copied to display
        ; memory across the rest of the target rectangle.

        mov     edx,ulVbNextScan        ;offset from end of one scan line to
                                        ; start of next the same scan line
                                        ; in the next pattern.
        sub     edx,ulWholeBytes
        add     edx,ulSpecialBytes
        push    edx                     ; save for later

        public clr_wide_bytes_loop
clr_wide_bytes_loop::

        mov     al,[edi]                ; read the latches

        mov     esi,ulWholeWords        ;number of aligned word writes
        mov     edx,[esp]

        ; VGA Latches = rotated pattern
        ;
        ; ebx = count
        ; edx = ulVbNextScan
        ; esi = ulFvWholeWords
        ; edi = pDest
        ;
        push    edi                     ;save out dest pointer
        call    pfnWholeBytes           ;draw the wide whole bytes
        pop     edi                     ;restore out dest pointer

        add     edi,ulScanWidth         ;advance to next scan line

        dec     ulVbBlindCount
        jz      short clr_wide_bytes_end

        mov     ebx,ulVbTopScan         ;restore scan count
        dec     ebx                     ;Subtract off completed top line
        mov     ulVbTopScan,ebx
        add     ebx,7                   ;Calc the number of lines to do
        shr     ebx,3                   ;for this venetian blind pass
                                        ;including any partial patterns
                                        ; at the bottom
        jmp     clr_wide_bytes_loop

clr_wide_bytes_end:
        pop     eax                     ;removed scan line offset from stack
        pop     ulVbBlindCount
        pop     edi                     ;restore screen pointer
        pop     ebx                     ;restore fill scan count

        jmp     pfnContinueDrawing      ;either keep drawing or we're done

;-----------------------------------------------------------------------;
; Handle case where both edges are partial (non-whole) bytes.
;-----------------------------------------------------------------------;

        public        non_replace_wide_clr
non_replace_wide_clr::
        push    ebx                        ;Save line count
        push    edi                        ;Save Dest Addr

        add     edi,ulLeftEdgeAdjust    ;point to first whole byte to fill

        mov     eax,pfnWholeBytes
        mov     pfnReadModWrite,eax

        mov     eax,ulVbNextScan
        sub     eax,ulWholeBytes
        add     eax,ulSpecialBytes
        mov     ulROPNextScan,eax

;save the width count and pfn here

        call    ReadModWrite

        pop     edi
        pop     ebx

        jmp     pfnContinueDrawing      ;either keep drawing or we're done

;-----------------------------------------------------------------------;
; Process any left/right columns that that have to be done.
;
;   Currently:
;       EBX =   height to fill, in scans
;       EDI --> first byte of left edge
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Handle case where both edges are partial (non-whole) bytes.
;-----------------------------------------------------------------------;

        public        clr_edge_byte_setup
clr_edge_byte_setup::
        mov     pfnReadModWrite,offset draw_1_wide_clr_rop

        mov     eax,ulVbNextScan
        mov     ulROPNextScan,eax

        mov     eax,ulLeftEdgeAdjust
        or      eax,eax
        jz      short do_right_edge

        mov     eax,ulMasks                ;Get Left/Right edge Masks
        mov     ah,al
        mov     al,GRAF_BIT_MASK
        mov     edx,EGA_BASE+GRAF_ADDR
        out     dx,ax

        push    ebx                        ;Save line count
        push    edi                        ;Save Dest Addr
        call    ReadModWrite
        pop     edi
        pop     ebx

        mov     eax,ulMasks                ;restore Left/Right edge Masks

do_right_edge:
        mov     eax,ulMasks                ;Get Left/Right edge Masks
        and     ah,0ffh
        jz      edge_done

        mov     al,GRAF_BIT_MASK
        mov     edx,EGA_BASE+GRAF_ADDR
        out     dx,ax

        add     edi,ulLeftEdgeAdjust    ;point to first whole byte to fill
        add     edi,ulWholeBytes        ;point to right edge byte to fill
        call    ReadModWrite

edge_done:
        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al


        mov     edx,EGA_BASE+GRAF_ADDR
        mov     eax,GRAF_BIT_MASK+0ff00h
        out     dx,ax

;-----------------------------------------------------------------------;
; See if there are any more banks to process.
;-----------------------------------------------------------------------;

        public clr_check_next_bank
clr_check_next_bank::

        mov     edi,pdsurf
        mov     eax,[edi].dsurf_rcl1WindowClip.yBottom ;is the fill bottom in
        cmp     ulBottomScan,eax                       ; the current bank?
        jle     short banks_done        ;yes, so we're done
                                        ;no, map in the next bank and fill it
        mov     ulCurrentTopScan,eax    ;remember where the top of the bank
                                        ; we're about to map in is (same as
                                        ; bottom of bank we just did)

        ptrCall <dword ptr [edi].dsurf_pfnBankControl>,<edi,eax,JustifyTop>
                                        ;map in the bank

; Compute the starting address and scan line count in this bank.

        mov     eax,pdsurf              ;EAX->target surface
        mov     ebx,ulBottomScan        ;bottom of destination rectangle
        cmp     ebx,[eax].dsurf_rcl1WindowClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; dest rect or the bottom of the
                                        ; current bank?
        jl      short BottomScanSet2    ;fill bottom comes first, so draw to
                                        ; that; this is the last bank in fill
        mov     ebx,[eax].dsurf_rcl1WindowClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
BottomScanSet2:
        mov     edi,ulCurrentTopScan    ;top scan line to fill in current bank
        sub     ebx,edi                 ;# of scans to fill in bank
        imul    edi,ulScanWidth         ;offset of starting scan line

; Note that the start of the bitmap will change each time through the
; bank loop, because the start of the bitmap is varied to map the
; desired scan line to the banking window.

        add     edi,[eax].dsurf_pvBitmapStart ;start of scan in bitmap
        add     edi,ulRowOffset         ;EDI = start offset of fill in bitmap

; We have computed the starting address and scan count. Time to start drawing
; in the initial bank.

        mov     esi,pBrush                ;edx = min(PatternHeight,BltHeight)
        mov     ecx,[esi + oem_brush_height]
        sub     ecx,ebx
        sbb     edx,edx
        and     edx,ecx
        add     edx,ebx
        mov     ulVbBlindCount,edx

; Brush alignment. We need to look at pptlBrush

        mov     eax,ulCurrentTopScan    ;top scan line to fill in current bank
        sub     eax,ulPatternOrgY        ;

        jns     short pos_y_offset1        ;
        neg     eax                        ;
        and     eax,7                        ;-eax mod 8
        neg     eax                        ;
        add     eax,8                        ;
        jmp     short save_pat_pointer1
pos_y_offset1:
        and     eax,7                        ;eax mod 8
save_pat_pointer1:

        lea     edx,RotatedPat                ;Pattern Dest
        add     eax,edx
        mov     pulPattern,eax                ;Drawing code uses this as the
                                        ;source for the pattern

; Draw in the new bank.

        jmp     pfnStartDrawing


;-----------------------------------------------------------------------;
; Done with all banks in this fill.

banks_done:
        PLAIN_RET

        public  ReadModWrite
ReadModWrite::
        mov     ulVbTopScan,ebx         ;our pattern is 8 high so we don't
        add     ebx,7                   ;Calc the number of lines to do
        shr     ebx,3                   ;only need to go through the code
                                        ; count/8 times. We will handle any
                                        ; extra lines at the bottom
                                        ; (ulVbTopScan mod 8) in our loops.

        push    ulVbBlindCount          ;Save blind count

        mov     esi,pulPattern          ; pointer to pattern bits
        mov     pulVbPattern,esi        ;load a byte of each plane of pattern

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,GRAF_MODE + ((M_PROC_WRITE + M_COLOR_READ) SHL 8)
        out     dx,ax                        ;write mode 0, read mode 0

        public clr_wide_bytes_loop
rmw_bytes_loop::

        ; ebx = count
        ; edi = pDest

        mov     ah,[esi]                ; Load Data Byte
        mov     al,MM_C0
        mov     edx,VGA_BASE + SEQ_DATA
        out     dx,al

        push    edi                     ;save out dest pointer
        push    esi
        push    ebx

        mov     esi,ulWholeBytes
        mov     edx,ulROPNextScan       ;offset from one scan to next

        call    pfnReadModWrite         ;draw the wide whole bytes

        pop     ebx
        pop     esi
        pop     edi                     ;restore out dest pointer

do_plane_1:
        mov     ah,[esi+16]                ; Load Data Byte
        mov     al,MM_C1
        mov     edx,VGA_BASE + SEQ_DATA
        out     dx,al

        push    edi                     ;save out dest pointer
        push    esi
        push    ebx

        mov     esi,ulWholeBytes
        mov     edx,ulROPNextScan       ;offset from one scan to next

        call    pfnReadModWrite         ;draw the wide whole bytes
        pop     ebx
        pop     esi
        pop     edi                     ;restore out dest pointer

do_plane_2:
        mov     ah,[esi+32]                ; Load Data Byte
        mov     al,MM_C2
        mov     edx,VGA_BASE + SEQ_DATA
        out     dx,al

        push    edi                     ;save out dest pointer
        push    esi
        push    ebx

        mov     esi,ulWholeBytes
        mov     edx,ulROPNextScan        ;offset from one scan to next

        call    pfnReadModWrite         ;draw the wide whole bytes

        pop     ebx
        pop     esi
        pop     edi                     ;restore out dest pointer

do_plane_3:
        mov     ah,[esi+48]                ; Load Data Byte
        mov     al,MM_C3
        mov     edx,VGA_BASE + SEQ_DATA
        out     dx,al

        push    edi                     ;save out dest pointer

        mov     esi,ulWholeBytes
        mov     edx,ulROPNextScan        ;offset from one scan to next

        call    pfnReadModWrite         ;draw the wide whole bytes

        pop     edi                     ;restore out dest pointer

finished_one_pass:
        add     edi,ulScanWidth         ;advance to next scan line

        dec     ulVbBlindCount
        jz      short rmw_end

        mov     eax,ulVbTopScan         ;restore scan count
        dec     eax                     ;Subtract off completed top line
        mov     ulVbTopScan,eax
        add     eax,7                   ;Calc the number of lines to do
        shr     eax,3                   ;for this venetian blind pass
        mov     ebx,eax                 ;including any partial patterns
                                        ; at the bottom
        mov     esi,pulVbPattern        ;Setup pattern pointer for next loop
        inc     esi
        mov     pulVbPattern,esi

        jmp     rmw_bytes_loop

rmw_end:
        pop     ulVbBlindCount

        mov     edx,VGA_BASE + GRAF_ADDR ;restore proper read/write modes
        mov     eax,GRAF_MODE + ((M_PROC_WRITE + M_DATA_READ) SHL 8)
        out     dx,ax

        PLAIN_RET

endProc vClrPatBlt

;-----------------------------------------------------------------------;
; Drawing loops.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;

; N-wide write-only, 0 leading bytes, 0 trailing bytes.
;  EAX = Pattern Byte
;  EBX = count of scans to fill ((total scans/ pattern height) + partial)
;  EDX = offset from end of one scan's fill to start of next similar line
;  ESI = pattern data
;  EDI = target address to fill

draw_wide_00_clr     proc    near
        mov     ecx,esi         ;# of whole words
        rep     stosw           ;fill all whole bytes as dwords
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_00_clr

        ret

draw_wide_00_clr     endp


;-----------------------------------------------------------------------;

; N-wide write-only, 0 leading bytes, 0 trailing bytes.
;  EAX = Pattern Byte
;  EBX = count of scans to fill ((total scans/ pattern height) + partial)
;  EDX = offset from end of one scan's fill to start of next similar line
;  ESI = pattern data
;  EDI = target address to fill

draw_wide_01_clr     proc    near
        mov     ecx,esi         ;# of whole words
        rep     stosw           ;fill all whole bytes as dwords
        mov     [edi],al        ;trailing byte
        inc     edi
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_01_clr
        ret

draw_wide_01_clr     endp


;-----------------------------------------------------------------------;

; N-wide write-only, 0 leading bytes, 0 trailing bytes.
;  EAX = Pattern Byte
;  EBX = count of scans to fill ((total scans/ pattern height) + partial)
;  EDX = offset from end of one scan's fill to start of next similar line
;  ESI = pattern data
;  EDI = target address to fill

draw_wide_10_clr     proc    near
        mov     [edi],ah        ;do leading byte
        inc     edi                ;advance poitner
        mov     ecx,esi         ;# of whole words
        rep     stosw           ;fill all whole bytes as dwords
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_10_clr
        ret

draw_wide_10_clr     endp

;-----------------------------------------------------------------------;

; N-wide write-only, 0 leading bytes, 0 trailing bytes.
;  EAX = Pattern Byte
;  EBX = count of scans to fill ((total scans/ pattern height) + partial)
;  EDX = offset from end of one scan's fill to start of next similar line
;  ESI = pattern data
;  EDI = target address to fill

draw_wide_11_clr     proc    near
        mov     [edi],ah        ;do leading byte
        inc     edi                ;advance poitner
        mov     ecx,esi         ;# of whole words
        rep     stosw           ;fill all whole bytes as dwords
        mov     [edi],al        ;trailing byte
        inc     edi
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_11_clr
        ret

draw_wide_11_clr     endp

;-----------------------------------------------------------------------;
; Drawing stuff for cases where read before write is NOT required.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; 1-, 2-, 3-, and 4-wide write-only edge-drawing loops.
;
; Entry:
;       AL/AX/EAX = pixel mask (if AX or EAX, then 0xFFFF or 0xFFFFFFFF)
;       EBX = loop count
;       ECX = scan line width in bytes
;       EDI = start offset
;
; EBX, EDI modified. All other registers preserved.

;-----------------------------------------------------------------------;

; 1-wide write-only.

draw_1_clr_even_loop     proc    near
        mov     [edi],al                ;we always read 0xFF, so AL is written
                                        ; as-is; because we're in write mode 3,
                                        ; AL becomes the Bit Mask
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_1_clr_even_loop

        ret

draw_1_clr_even_loop     endp


; 1-wide write-only.

draw_1_clr_odd_loop     proc    near
        mov     [edi],ah                ;we always read 0xFF, so AL is written
                                        ; as-is; because we're in write mode 3,
                                        ; AL becomes the Bit Mask
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_1_clr_odd_loop

        ret

draw_1_clr_odd_loop     endp

;-----------------------------------------------------------------------;

; 2-wide write-only.

draw_2_clr_even_loop     proc    near
        mov     [edi],ax
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_2_clr_even_loop

        ret

draw_2_clr_even_loop     endp


; 2-wide write-only.

draw_2_clr_odd_loop     proc    near
        mov     [edi],ah
        mov     [edi+1],al
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_2_clr_odd_loop

        ret

draw_2_clr_odd_loop     endp

;-----------------------------------------------------------------------;

; 3-wide write-only, starting at an even address.

draw_3_clr_even_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],al
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_3_clr_even_loop

        ret

draw_3_clr_even_loop     endp

;-----------------------------------------------------------------------;

; 3-wide write-only, starting at an odd address.

draw_3_clr_odd_loop     proc    near
        mov     [edi],ah
        mov     [edi+1],ax
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_3_clr_odd_loop

        ret

draw_3_clr_odd_loop     endp


;-----------------------------------------------------------------------;

; 4-wide write-only, starting at an even address.

draw_4_clr_even_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],ax
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_4_clr_even_loop

        ret

draw_4_clr_even_loop     endp

;-----------------------------------------------------------------------;

; 4-wide write-only, starting at an odd address.

draw_4_clr_odd_loop     proc    near
        mov     [edi],ah
        mov     [edi+1],ax
        mov     [edi+3],al
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_4_clr_odd_loop

        ret

draw_4_clr_odd_loop     endp

;-----------------------------------------------------------------------;

; 5-wide write-only, starting at an even address.

draw_5_clr_even_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],ax
        mov     [edi+4],al
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_5_clr_even_loop

        ret

draw_5_clr_even_loop     endp

;-----------------------------------------------------------------------;

; 5-wide write-only, starting at an odd address.

draw_5_clr_odd_loop     proc    near
        mov     [edi],ah
        mov     [edi+1],ax
        mov     [edi+3],ax
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_5_clr_odd_loop

        ret

draw_5_clr_odd_loop     endp

;-----------------------------------------------------------------------;

; 6-wide write-only, starting at an even address.

draw_6_clr_even_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],ax
        mov     [edi+4],ax
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_6_clr_even_loop

        ret

draw_6_clr_even_loop     endp

;-----------------------------------------------------------------------;

; 6-wide write-only, starting at an odd address.

draw_6_clr_odd_loop     proc    near
        mov     [edi],ah
        mov     [edi+1],ax
        mov     [edi+3],ax
        mov     [edi+5],al
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_6_clr_odd_loop

        ret

draw_6_clr_odd_loop     endp

;-----------------------------------------------------------------------;

; 7-wide write-only, starting at an even address.

draw_7_clr_even_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],ax
        mov     [edi+4],ax
        mov     [edi+6],al
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_7_clr_even_loop

        ret

draw_7_clr_even_loop     endp

;-----------------------------------------------------------------------;

; 7-wide write-only, starting at an odd address.

draw_7_clr_odd_loop     proc    near
        mov     [edi],ah
        mov     [edi+1],ax
        mov     [edi+3],ax
        mov     [edi+5],ax
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_7_clr_odd_loop

        ret

draw_7_clr_odd_loop     endp

;-----------------------------------------------------------------------;

; 8-wide write-only, starting at an even address.

draw_8_clr_even_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],ax
        mov     [edi+4],ax
        mov     [edi+6],ax
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_8_clr_even_loop

        ret

draw_8_clr_even_loop     endp

;-----------------------------------------------------------------------;

; 8-wide write-only, starting at an odd address.

draw_8_clr_odd_loop     proc    near
        mov     [edi],ah
        mov     [edi+1],ax
        mov     [edi+3],ax
        mov     [edi+5],ax
        mov     [edi+7],al
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_8_clr_odd_loop

        ret

draw_8_clr_odd_loop     endp

;-----------------------------------------------------------------------;
; 1-, 2-, 3-, and 4-wide read before write drawing loops.
;
; Entry:
;       AL  = pixel mask
;       EBX = loop count
;       ECX = scan line width in bytes
;       EDI = start offset
;
; EBX, EDI modified. All other registers preserved.

;-----------------------------------------------------------------------;

; 1-wide read/write.

draw_1_wide_clr_rop     proc    near
        mov     al,[edi]
        mov     [edi],ah
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_1_wide_clr_rop

        ret

draw_1_wide_clr_rop     endp

;-----------------------------------------------------------------------;

; 2-wide read/write.

draw_2_wide_clr_rop     proc    near
        mov     al,[edi]
        mov     [edi],ah
        mov     al,[edi+1]
        mov     [edi+1],ah
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_2_wide_clr_rop

        ret

draw_2_wide_clr_rop     endp

;-----------------------------------------------------------------------;

; 3-wide read/write.

draw_3_wide_clr_rop     proc    near
        mov     al,[edi]
        mov     [edi],ah
        mov     al,[edi+1]
        mov     [edi+1],ah
        mov     al,[edi+2]
        mov     [edi+2],ah
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_3_wide_clr_rop

        ret

draw_3_wide_clr_rop     endp

;-----------------------------------------------------------------------;

; 4-wide read/write.

draw_4_wide_clr_rop     proc    near
        mov     al,[edi]
        mov     [edi],ah
        mov     al,[edi+1]
        mov     [edi+1],ah
        mov     al,[edi+2]
        mov     [edi+2],ah
        mov     al,[edi+3]
        mov     [edi+3],ah
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_4_wide_clr_rop

        ret

draw_4_wide_clr_rop     endp

;-----------------------------------------------------------------------;
; 5-or-wider read before write loop.
;
; Entry:
;       EAX = # of bytes to fill across scan line (needed only by 5-or-wider
;               handler)
;       EBX = loop count
;       EDX = offset from end of one scan line to the start of the next next
;       EDI = start offset
;
; EBX, ECX, ESI, EDI modified. All other registers preserved.

;-----------------------------------------------------------------------;

; 5-or-wider read/write.

draw_wide_rop_clr proc  near
        mov     ecx,esi
@@:     mov     al,[edi]
        mov     [edi],ah
        inc     edi
        dec     ecx
        jnz     @b
        add     edi,edx

        dec     ebx
        jnz     draw_wide_rop_clr

        ret

draw_wide_rop_clr endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\brushes.asm ===
.386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc
        include i386\ropdefs.inc
        include i386\display.inc         ; Display specific structures

        .list

;-----------------------------------------------------------------------;

        .data

        align        4
ifdef LATER
        public  CmpPlanes
CmpPlanes  label dword
        dd      check_plane_1
        dd      check_plane_2
        dd      check_plane_3
        dd      0
endif;LATER

        public  pCountTable
pCountTable  label dword
        dd      1h
        dd      2h
        dd      4h
        dd      8h
        dd      10h
        dd      20h
        dd      40h
        dd      80h
        dd      100h
        dd      200h
        dd      400h
        dd      800h
        dd      1000h
        dd      2000h
        dd      4000h
        dd      8000h

        align        4
        public  pPixelCount
pPixelCount label dword
        dd      0                ;//0
        dd      1                ;//1
        dd      1                ;//2
        dd      2                ;//3
        dd      1                ;//4
        dd      2                ;//5
        dd      2                ;//6
        dd      3                ;//7
        dd      1                ;//8
        dd      2                ;//9
        dd      2                ;//10
        dd      3                ;//11
        dd      2                ;//12
        dd      3                ;//13
        dd      3                ;//14
        dd      3                ;//15
        dd      4                ;//16

        align        4
PackedToPlanar0  label dword
        dd      0               ;//0
        dd      00000001h       ;//1
        dd      00000100h       ;//2
        dd      00000101h       ;//3
        dd      00010000h       ;//4
        dd      00010001h       ;//5
        dd      00010100h       ;//6
        dd      00010101h       ;//7
        dd      01000000h       ;//8
        dd      01000001h       ;//9
        dd      01000100h       ;//10
        dd      01000101h       ;//11
        dd      01010000h       ;//12
        dd      01010001h       ;//13
        dd      01010100h       ;//14
        dd      01010101h       ;//15

        align    4
PackedToPlanar1 label dword
        dd      0                 ;//0
        dd      (00000001h SHL 1) ;//1
        dd      (00000100h SHL 1) ;//2
        dd      (00000101h SHL 1) ;//3
        dd      (00010000h SHL 1) ;//4
        dd      (00010001h SHL 1) ;//5
        dd      (00010100h SHL 1) ;//6
        dd      (00010101h SHL 1) ;//7
        dd      (01000000h SHL 1) ;//8
        dd      (01000001h SHL 1) ;//9
        dd      (01000100h SHL 1) ;//10
        dd      (01000101h SHL 1) ;//11
        dd      (01010000h SHL 1) ;//12
        dd      (01010001h SHL 1) ;//13
        dd      (01010100h SHL 1) ;//14
        dd      (01010101h SHL 1) ;//15

        align   4
PackedToPlanar2 label dword
        dd      0                 ;//0
        dd      (00000001h SHL 2) ;//1
        dd      (00000100h SHL 2) ;//2
        dd      (00000101h SHL 2) ;//3
        dd      (00010000h SHL 2) ;//4
        dd      (00010001h SHL 2) ;//5
        dd      (00010100h SHL 2) ;//6
        dd      (00010101h SHL 2) ;//7
        dd      (01000000h SHL 2) ;//8
        dd      (01000001h SHL 2) ;//9
        dd      (01000100h SHL 2) ;//10
        dd      (01000101h SHL 2) ;//11
        dd      (01010000h SHL 2) ;//12
        dd      (01010001h SHL 2) ;//13
        dd      (01010100h SHL 2) ;//14
        dd      (01010101h SHL 2) ;//15

        align        4
PackedToPlanar3         label dword
        dd      0                        ;//0
        dd      (00000001h SHL 3) ;//1
        dd      (00000100h SHL 3) ;//2
        dd      (00000101h SHL 3) ;//3
        dd      (00010000h SHL 3) ;//4
        dd      (00010001h SHL 3) ;//5
        dd      (00010100h SHL 3) ;//6
        dd      (00010101h SHL 3) ;//7
        dd      (01000000h SHL 3) ;//8
        dd      (01000001h SHL 3) ;//9
        dd      (01000100h SHL 3) ;//10
        dd      (01000101h SHL 3) ;//11
        dd      (01010000h SHL 3) ;//12
        dd      (01010001h SHL 3) ;//13
        dd      (01010100h SHL 3) ;//14
        dd      (01010101h SHL 3) ;//15

        align        4
PackedToPlanar4         label dword
        dd      0                        ;//0
        dd      (00000001h SHL 4) ;//1
        dd      (00000100h SHL 4) ;//2
        dd      (00000101h SHL 4) ;//3
        dd      (00010000h SHL 4) ;//4
        dd      (00010001h SHL 4) ;//5
        dd      (00010100h SHL 4) ;//6
        dd      (00010101h SHL 4) ;//7
        dd      (01000000h SHL 4) ;//8
        dd      (01000001h SHL 4) ;//9
        dd      (01000100h SHL 4) ;//10
        dd      (01000101h SHL 4) ;//11
        dd      (01010000h SHL 4) ;//12
        dd      (01010001h SHL 4) ;//13
        dd      (01010100h SHL 4) ;//14
        dd      (01010101h SHL 4) ;//15

        align        4
PackedToPlanar5         label dword
        dd      0                        ;//0
        dd      (00000001h SHL 5) ;//1
        dd      (00000100h SHL 5) ;//2
        dd      (00000101h SHL 5) ;//3
        dd      (00010000h SHL 5) ;//4
        dd      (00010001h SHL 5) ;//5
        dd      (00010100h SHL 5) ;//6
        dd      (00010101h SHL 5) ;//7
        dd      (01000000h SHL 5) ;//8
        dd      (01000001h SHL 5) ;//9
        dd      (01000100h SHL 5) ;//10
        dd      (01000101h SHL 5) ;//11
        dd      (01010000h SHL 5) ;//12
        dd      (01010001h SHL 5) ;//13
        dd      (01010100h SHL 5) ;//14
        dd      (01010101h SHL 5) ;//15

        align        4
PackedToPlanar6         label dword
        dd      0                        ;//0
        dd      (00000001h SHL 6) ;//1
        dd      (00000100h SHL 6) ;//2
        dd      (00000101h SHL 6) ;//3
        dd      (00010000h SHL 6) ;//4
        dd      (00010001h SHL 6) ;//5
        dd      (00010100h SHL 6) ;//6
        dd      (00010101h SHL 6) ;//7
        dd      (01000000h SHL 6) ;//8
        dd      (01000001h SHL 6) ;//9
        dd      (01000100h SHL 6) ;//10
        dd      (01000101h SHL 6) ;//11
        dd      (01010000h SHL 6) ;//12
        dd      (01010001h SHL 6) ;//13
        dd      (01010100h SHL 6) ;//14
        dd      (01010101h SHL 6) ;//15

        align  4
PackedToPlanar7         label dword
        dd      0                        ;//0
        dd      (00000001h SHL 7) ;//1
        dd      (00000100h SHL 7) ;//2
        dd      (00000101h SHL 7) ;//3
        dd      (00010000h SHL 7) ;//4
        dd      (00010001h SHL 7) ;//5
        dd      (00010100h SHL 7) ;//6
        dd      (00010101h SHL 7) ;//7
        dd      (01000000h SHL 7) ;//8
        dd      (01000001h SHL 7) ;//9
        dd      (01000100h SHL 7) ;//10
        dd      (01000101h SHL 7) ;//11
        dd      (01010000h SHL 7) ;//12
        dd      (01010001h SHL 7) ;//13
        dd      (01010100h SHL 7) ;//14
        dd      (01010101h SHL 7) ;//15



        .code

;==============================================================================
; CountColors(pBuffer, Count)
;
; This routine will count the number of unique colors in a packed pel 4bpp
; bitmap. The total number of colors is returned.
;
;==============================================================================

_TEXT$03   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

cProc   CountColors,16,<     \
        uses esi edi ebx,   \
        pBuffer: ptr dword, \
        count:dword,        \
        pColors: ptr dword, \
        cbScan: dword       >

        ; This could be much faster. This routine really only needs to
        ; find out if there are two colors and return those two colors.
        ; If there are more, we can just return.

        mov     ecx,8
        mov     esi,pBuffer
        lea     edi,pCountTable
        xor     edx,edx


@@:     mov     ebx,[esi]               ; read in a dword of the bitmap

        rept    7

        mov     eax,ebx                 ;copy colors to eax
        and     eax,0fh                 ;isolate nibble
        shr     ebx,4                   ;remove current nibble from ebx
        or      edx,[edi+eax*4]         ;or color count flags into edx
        endm    ;-----------------------

        or      edx,[edi+ebx*4]         ;do last nibble

        cmp     count,16                ;if this is 16x8 we need to
        jne     short continue_count    ; process the second dword on this
                                        ; scan.

        mov     ebx,[esi+4]             ;read second dword

        rept    7

        mov     eax,ebx                 ;copy colors to eax
        and     eax,0fh                 ;isolate nibble
        shr     ebx,4                   ;remove current nibble from ebx
        or      edx,[edi+eax*4]         ;or color count flags into edx
        endm    ;-----------------------

        or      edx,[edi+ebx*4]         ;do last nibble
continue_count:
        add     esi,cbScan
        dec     ecx                     ;do next dword
        jnz     @b

        ; Now count the number of bits on in each nibble

        mov     ecx,edx                    ;save bit mask
        mov     ebx,edx
        shr     edx,4
        and     ebx,0fh
        mov     eax,pPixelCount[ebx*4]

        mov     ebx,edx
        shr     edx,4
        and     ebx,0fh
        add     eax,pPixelCount[ebx*4]

        mov     ebx,edx
        shr     edx,4
        and     ebx,0fh
        add     eax,pPixelCount[ebx*4]

        add     eax,pPixelCount[edx*4]

        cmp     eax,2
        jne     short cc_exit

        mov     al,16

@@:     dec     al
        add     cx,cx
        jnc     @b
        mov     ah,al

@@:     dec     al
        add     cx,cx
        jnc     @b

        mov     edi,pColors
        mov     [edi],ax
        mov     ax,2
cc_exit:
        cRet    CountColors

endProc CountColors

;==============================================================================
; bQuickPattern
;
; We special case patterns that are repeating two line patterns (like the
; grey/hatch brush). This allows us to do two passes instead of eight in the
; venetian blind patblt code.
;
;==============================================================================

cProc   bQuickPattern,8,<     \
        uses edi,           \
        pBuffer: ptr dword, \
        count:dword         >

        ; Count must be 8 or 16;

        xor     eax,eax         ;Set ret value to false
        mov     edi,pBuffer     ;get pointer to pattern
        mov     edx,[edi]       ;Get first dword (first two lines of pattern)
        mov     ecx,count       ;dword count

qp_loop:
INDEX=4
        rept    7
        cmp     edx,[edi+INDEX]
        jne     short qp_exit
INDEX=INDEX+4
        endm    ;----------------------

        sub     ecx,8
        jz      exit_true

        add     edi,32
        cmp     edx,[edi]
        jne     short qp_exit
        jmp     short qp_loop

exit_true:
        inc     eax
qp_exit:
        cRet    bQuickPattern
endProc bQuickPattern

_TEXT$03        ends

        .code

;==============================================================================
; bShrinkPattern
;
; Test to see if we can shrink an 16x8 pattern to an 8x8 pattern.
;
;==============================================================================

cProc   bShrinkPattern,8,<     \
        uses edi,           \
        pBuffer: ptr dword, \
        cbScan:dword         >

        xor     eax,eax
        mov     ecx,cbScan
        mov     edi,pBuffer        ;get pointer to pattern

        rept     8
        mov     edx,[edi]
        cmp     edx,[edi+4]
        jne     @f
        add     edi,ecx
        endm     ;---------------

        inc     eax
@@:

        cRet        bShrinkPattern
endProc bShrinkPattern

;==============================================================================
;vMono8Wide
;
; Copies an 8x8 pattern to a 16x16 buffer
;
;==============================================================================

_TEXT$04   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

cProc   vMono8Wide,12,<        \
        uses ebx edi esi,      \
        pDest: ptr dword,      \
        pBuffer: ptr dword,    \
        cbScan:ptr dword      >

        mov     edi,pDest                         ;Load up edi with our dest
        mov     esi,pBuffer                        ;load esi with the source
        mov     ebx,cbScan                        ;dest line delta

        rept     8

        mov     al,[esi]                        ;Read in first line of pattern
        add     esi,ebx                                ;inc dest pointer
        mov     ah,al                                ;make pattern 16 wide
        mov     [edi],ax                        ;write first line of pattern
        add     edi,2
        endm     ;----------------------

        cRet vMono8Wide
endProc vMono8Wide

_TEXT$04        ends

        .code

;==============================================================================
;vMono16Wide
;
; Copies an 16x8 pattern to a 16x16 buffer
;
;==============================================================================

cProc   vMono16Wide,12,<       \
        uses ebx edi esi,      \
        pDest: ptr dword,      \
        pBuffer: ptr dword,    \
        cbScan:ptr dword       >

        mov     edi,pDest                         ;Load up edi with our dest
        mov     esi,pBuffer                        ;load esi with the source
        mov     ebx,cbScan                        ;dest line delta

        rept     8

        mov     ax,[esi]                        ;Read in first line of pattern
        add     esi,ebx                                ;inc dest pointer
        mov     [edi],ax                        ;write first line of pattern
        add     edi,2

        endm        ;----------------------

        cRet vMono16Wide
endProc vMono16Wide

;==============================================================================
; Brush2ColorToMono
;
;
;==============================================================================

_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

cProc   vBrush2ColorToMono,20,<  \
        uses esi edi ebx,      \
        pDest: ptr dword,      \
        pSrc: ptr dword,       \
        cbScan: dword,         \
        ulWidth: dword,               \
        jColor: dword          >

        local ulHeight : dword

        mov     ulHeight,8

        ;This routine relies on this: It only works on an 8x8
        ;two color 4bpp packed pel pattern. It creates a 1bpp bitmap
        ;with the foreground color being the smaller of the two numbers.
        ;This is key because the way we set the bit in the monochrome bmp
        ;is by comparing the background color (the larger of the two colors)
        ;with the current nibble. If this nibble contains the foreground
        ;color (the smaller color) then a carry will result from the compare.
        ;We then use adc ebx,ebx to set the lsb to zero or one depending on
        ;the result of the compare and also to shift ebx left by one.

        mov     ecx,jColor    ;jColor is the larger of the two colors
        mov     ch,cl         ;Save jcolor in cl for comparisions with the low
        shl     ch,4          ;nibble and ch for the high nibble

        mov     edi,pDest     ;Load Dest
        mov     esi,pSrc      ;Load Src
        mov     edx,cbScan

        cmp     ulWidth,8
        jnz     do_16_wide

x8_wide_loop:
SRCINDEX=0
        xor     ebx,ebx         ;clear out place where we store the dest byte.
        rept    4
        mov     al,[esi+SRCINDEX] ;get src byte
        cmp     al,ch             ;Is the top nibble fg or bk?
        adc     ebx,ebx           ;carry will be set if fg. Set bit in mask
        and     al,0fh            ;mask off high nibble
        cmp     al,cl             ;Is the bottom nibble fg or bk?
        adc     ebx,ebx           ;carry will be set if fg. Set bit in mask
SRCINDEX=SRCINDEX+1
        endm        ;------------------
        add     esi,edx           ;increment src to next line

        mov     [edi],bl          ;Write out first byte (8 Pixels)
        mov     [edi+1],bl        ;We expand this to 16 pixels
        add     edi,2

        dec     ulHeight
        jnz     x8_wide_loop
        jmp     convert_exit


do_16_wide:
x16_wide_loop:
        xor     ebx,ebx         ;clear out place where we store the dest byte.

SRCINDEX=0
        rept    4
        mov     al,[esi+SRCINDEX] ;get src byte
        cmp     al,ch             ;Is the top nibble fg or bk?
        adc     ebx,ebx           ;carry will be set if fg. Set bit in mask
        and     al,0fh            ;mask off high nibble
        cmp     al,cl             ;Is the bottom nibble fg or bk?
        adc     ebx,ebx           ;carry will be set if fg. Set bit in mask
SRCINDEX=SRCINDEX+1
        endm        ;------------------

        mov     [edi],bl          ;Write out first byte (8 Pixels)
        inc     edi
        xor     ebx,ebx           ;clear out place where we store the dest byte.

        rept    4
        mov     al,[esi+SRCINDEX] ;get src byte
        cmp     al,ch             ;Is the top nibble fg or bk?
        adc     ebx,ebx           ;carry will be set if fg. Set bit in mask
        and     al,0fh            ;mask off high nibble
        cmp     al,cl             ;Is the bottom nibble fg or bk?
        adc     ebx,ebx           ;carry will be set if fg. Set bit in mask
SRCINDEX=SRCINDEX+1
        endm        ;------------------

        add     esi,edx           ;increment src to next line
        mov     [edi],bl          ;Write out Second byte (8 Pixels)
        inc     edi
        dec     ulHeight
        jnz     x16_wide_loop
convert_exit:
        cRet vBrush2ColorToMono
endProc vBrush2ColorToMono


;==============================================================================
; vConvert4BppToPlanar
;
;
;==============================================================================

cProc   vConvert4BppToPlanar,16,<  \
        uses esi edi ebx,      \
        pDest: ptr dword,      \
        pSrc: ptr dword,       \
        cbScan: dword,         \
        pulXlate: ptr dword          >

        local ulHeight : dword

        xor     eax,eax
        mov     esi,pSrc
        mov     edi,pDest

        mov     edx,pulXlate
        or      edx,edx
        jz      do_convert4toplanar

        mov     ulHeight,8
convert4xlate:
        mov     ebx,[esi]                  ;Get 8 4bpp pixels
        and     ebx,0f0f0f0fh              ;Mask off the high nibbles
        shl     ebx,2                      ;multiply by four (size of dword)
        mov     al,bl                      ;move into eax to use an index
        mov     eax,[edx][eax]             ;xlate color
        mov     ecx,PackedToPlanar6[eax*4] ;build planar bytes
        mov     al,bh                      ;move into eax to use an index
        shr     ebx,16                     ;get access to high word
        mov     eax,[edx][eax]             ;xlate color
        or      ecx,PackedToPlanar4[eax*4] ;build planar bytes
        mov     al,bl                      ;move into eax to use an index
        mov     eax,[edx][eax]             ;xlate color
        or      ecx,PackedToPlanar2[eax*4] ;build planar bytes
        mov     al,bh                      ;move into eax to use an index
        mov     eax,[edx][eax]             ;xlate color
        or      ecx,PackedToPlanar0[eax*4] ;build planar bytes

        mov     ebx,[esi]                  ;Get same dword again so we
        add     esi,cbScan                 ; can do the high nibbles

        and     ebx,0f0f0f0f0h             ;Mask off the low nibbles
        shr     ebx,2                      ;shift into low nible and
                                           ;multiply by four ((>> 4) << 2)

        mov     al,bl                      ;move into eax to use an index
        mov     eax,[edx][eax]             ;xlate color
        or      ecx,PackedToPlanar7[eax*4] ;build planar bytes
        mov     al,bh                      ;move into eax to use an index
        shr     ebx,16                     ;get access to high word
        mov     eax,[edx][eax]             ;xlate color
        or      ecx,PackedToPlanar5[eax*4] ;build planar bytes
        mov     al,bl                      ;move into eax to use an index
        mov     eax,[edx][eax]             ;xlate color
        or      ecx,PackedToPlanar3[eax*4] ;build planar bytes
        mov     al,bh                      ;move into eax to use an index
        mov     eax,[edx][eax]             ;xlate color
        or      ecx,PackedToPlanar1[eax*4] ;build planar bytes

        mov     [edi],cl                   ;Write the bytes out in planar
        mov     [edi+8],ch                 ;format. We have to store them
        shr     ecx,16                     ;this way because this is how
        mov     [edi+16],cl                ;the blt compiler expects it.
        mov     [edi+24],ch
        add     edi,1                      ;increment dest pointer

        dec     ulHeight                   ;Check height
        jnz     convert4xlate              ;do next line
        jmp     short convert4exit         ;exit

do_convert4toplanar:
        mov     edx,8

convert4toplanar:
        mov     ebx,[esi]                       ;Get 8 4bpp pixels
        and     ebx,0f0f0f0fh                   ;Mask off the high nibbles
        shl     ebx,2                           ;multiply by four each nibble
                                                ; by four (size of dword)
        mov     al,bl                           ;move into eax to use an index
        mov     ecx,PackedToPlanar6[eax]        ;build planar bytes
        mov     al,bh                           ;move into eax to use an index
        shr     ebx,16                          ;get access to high word
        or      ecx,PackedToPlanar4[eax]        ;build planar bytes
        mov     al,bh                           ;move into eax to use an index
        and     ebx,03ch                        ;mask off unneeded bits
        or      ecx,PackedToPlanar2[ebx]        ;build planar bytes
        or      ecx,PackedToPlanar0[eax]        ;build planar bytes

        mov     ebx,[esi]                       ;Get same dword again so we
        add     esi,cbScan                      ; can do the high nibbles

        and     ebx,0f0f0f0f0h                  ;Mask off the low nibbles
        shr     ebx,2                           ;shift into low nible and
                                                ;multiply by four ((>> 4) << 2)

        mov     al,bl                           ;move into eax to use an index
        or      ecx,PackedToPlanar7[eax]        ;build planar bytes
        mov     al,bh                           ;move into eax to use an index
        shr     ebx,16                          ;get access to high word
        or      ecx,PackedToPlanar5[eax]        ;build planar bytes
        mov     al,bh                           ;move into eax to use an index
        and     ebx,03ch                        ;mask off unneeded bits
        or      ecx,PackedToPlanar3[ebx]        ;build planar bytes
        or      ecx,PackedToPlanar1[eax]        ;build planar bytes

        mov     [edi],cl                        ;Write the bytes out in planar
        mov     [edi+8],ch                      ;format. We have to store them
        shr     ecx,16                          ;this way because this is how
        mov     [edi+16],cl                     ;the blt compiler expects it.
        mov     [edi+24],ch
        add     edi,1                           ;increment dest pointer

        dec     edx                             ;check scan count
        jnz     convert4toplanar                ;

convert4exit:
        cRet vConvert4BpptoPlanar
endProc vConvert4BppToPlanar

;==============================================================================
; vConvert8BppToPlanar
;
;
;==============================================================================

cProc   vConvert8BppToPlanar,16,<  \
        uses esi edi ebx,      \
        pDest: ptr dword,      \
        pSrc: ptr dword,       \
        cbScan: dword,         \
        pulXlate: ptr dword          >

        local ulHeight : dword

        xor     eax,eax
        mov     esi,pSrc
        mov     edi,pDest

        mov     edx,pulXlate
        or      edx,edx
        jz      do_convert8toplanar

        mov     ulHeight,8
convert8xlate:
        xor     ecx,ecx
        mov     ebx,[esi]                  ;Get 4 8bpp pixels
        mov     al,bl                      ;move into eax to use an index
        mov     eax,[edx][eax*4]           ;xlate color
        or      ecx,PackedToPlanar7[eax*4] ;build planar bytes
        mov     al,bh                      ;move into eax to use an index
        shr     ebx,16                     ;get access to high word
        mov     eax,[edx][eax*4]           ;xlate color
        or      ecx,PackedToPlanar6[eax*4] ;build planar bytes
        mov     al,bl                      ;move into eax to use an index
        mov     eax,[edx][eax*4]           ;xlate color
        or      ecx,PackedToPlanar5[eax*4] ;build planar bytes
        mov     al,bh                      ;move into eax to use an index
        mov     eax,[edx][eax*4]             ;xlate color
        or      ecx,PackedToPlanar4[eax*4] ;build planar bytes

        mov     ebx,[esi+4]                ;Get same dword again so we
        add     esi,cbScan                 ; can do the high nibbles

        mov     al,bl                      ;move into eax to use an index
        mov     eax,[edx][eax*4]           ;xlate color
        or      ecx,PackedToPlanar3[eax*4] ;build planar bytes
        mov     al,bh                      ;move into eax to use an index
        shr     ebx,16                     ;get access to high word
        mov     eax,[edx][eax*4]           ;xlate color
        or      ecx,PackedToPlanar2[eax*4] ;build planar bytes
        mov     al,bl                      ;move into eax to use an index
        mov     eax,[edx][eax*4]           ;xlate color
        or      ecx,PackedToPlanar1[eax*4] ;build planar bytes
        mov     al,bh                      ;move into eax to use an index
        mov     eax,[edx][eax*4]           ;xlate color
        or      ecx,PackedToPlanar0[eax*4] ;build planar bytes

        mov     [edi],cl                   ;Write the bytes out in planar
        mov     [edi+8],ch                 ;format. We have to store them
        shr     ecx,16                     ;this way because this is how
        mov     [edi+16],cl                ;the blt compiler expects it.
        mov     [edi+24],ch
        add     edi,1                      ;increment dest pointer

        dec     ulHeight                   ;Check height
        jnz     convert8xlate              ;do next line
        jmp     short convert8exit         ;exit

do_convert8toplanar:
        mov     edx,8

convert8toplanar:
        xor     ecx,ecx
        mov     ebx,[esi]                       ;Get 8 4bpp pixels
        mov     al,bl                           ;move into eax to use an index
        or      ecx,PackedToPlanar7[eax*4]      ;build planar bytes
        mov     al,bh                           ;move into eax to use an index
        shr     ebx,16                          ;get access to high word
        or      ecx,PackedToPlanar6[eax*4]      ;build planar bytes
        mov     al,bl                           ;move into eax to use an index
        or      ecx,PackedToPlanar5[eax*4]      ;build planar bytes
        mov     al,bh                           ;move into eax to use an index
        or      ecx,PackedToPlanar4[ebx*4]      ;build planar bytes

        mov     ebx,[esi+4]                     ;Get same dword again so we
        add     esi,cbScan                      ; can do the high nibbles

        mov     al,bl                           ;move into eax to use an index
        or      ecx,PackedToPlanar3[eax*4]      ;build planar bytes
        mov     al,bh                           ;move into eax to use an index
        shr     ebx,16                          ;get access to high word
        or      ecx,PackedToPlanar2[eax*4]      ;build planar bytes
        mov     al,bl                           ;move into eax to use an index
        or      ecx,PackedToPlanar1[eax*4]      ;build planar bytes
        mov     al,bh                           ;move into eax to use an index
        or      ecx,PackedToPlanar0[ebx*4]      ;build planar bytes

        mov     [edi],cl                        ;Write the bytes out in planar
        mov     [edi+8],ch                      ;format. We have to store them
        shr     ecx,16                          ;this way because this is how
        mov     [edi+16],cl                     ;the blt compiler expects it.
        mov     [edi+24],ch
        add     edi,1                           ;increment dest pointer

        dec     edx                             ;check scan count
        jnz     convert8toplanar                ;

convert8exit:
        cRet vConvert8BpptoPlanar
endProc vConvert8BppToPlanar

_TEXT$01   ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\cblt.asm ===
page    ,132
        title   BitBLT
;---------------------------Module-Header------------------------------;
; Module Name: cblt.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
        .386

;!!! All the code to convert from color to mono in this file needs to
;!!! be deleted.  We don't need to do it anymore.




ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .code

_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        .xlist
        include stdcall.inc         ; calling convention cmacros

        include i386\cmacFLAT.inc   ; FLATland cmacros
        include i386\display.inc    ; Display specific structures
        include i386\ppc.inc        ; Pack pel conversion structure
        include i386\bitblt.inc     ; General definitions
        include i386\ropdefs.inc    ; Rop definitions
        include i386\egavga.inc   ; EGA register definitions
        include i386\devdata.inc
        .list

        extrn   roptable:byte
;-----------------------------Public-Routine----------------------------;
; CBLT
;
; Compile a BLT onto the stack.
;
; Entry:
;       EDI --> memory on stack to receive BLT program
;       EBP --> fr structure
; Returns:
;       Nothing
;-----------------------------------------------------------------------;

fr      equ     [ebp]                   ;For consistancy with other sources

cProc   cblt

        subttl  Compile - Outer Loop
        page

; If converting a packed pel format to planer format, add the code
; to convert one source scan into planer format

        test    fr.ppcBlt.fb,PPC_NEEDED
        jz      no_pack_pel_conversion
        mov     al,I_MOV_EBP_DWORD_I    ;Give conversion routine access
        stosb                           ;  to conversion data
        lea     eax,fr.ppcBlt
        stosd
        mov     al,I_CALL_DISP32        ;Call the static conversion code
        stosb
        mov     eax,fr.ppcBlt.pfnConvert
        sub     eax,edi
        sub     eax,4                   ;4 for length of displacement
        stosd
no_pack_pel_conversion:

; Initialize plane indicator.

        mov     ax,(PLANE_1*256)+I_MOV_BL_BYTE_I
        stosw

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; Create the outerloop code.  The first part of this code will save
; the scan line count register, destination pointer, and the source
; pointer (if there is a source).
;
; The generated code should look like:
;
;       push    ecx             ;Save scan line count
;       push    edi             ;Save destination pointer
; <     push    esi     >       ;Save source pointer
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        mov     fr.pNextPlane,edi       ;Save address of next plane code
        mov     bl,fr.the_flags
        mov     ax,I_PUSH_ECX_PUSH_EDI  ;Save scan line count, destination ptr
        stosw
        test    bl,F0_SRC_PRESENT       ;Is a source needed?
        jz      cblt_2020               ;  No
        mov     al,I_PUSH_ESI           ;  Yes, save source pointer
        stosb
cblt_2020:

        subttl  Compile - Plane Selection
        page
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; If the destination device is color and the display is involved in
; the blt, then the color plane selection logic must be added in.
; If the destination is monochrome, then no plane logic is needed.
; Two color memory bitmaps will not cause the plane selection logic
; to be copied.
;
; The generated code should look like:
;
; <     push    ebx     >       ;Save plane index
; <     plane selection >       ;Select plane
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        test    bl,F0_DEST_IS_COLOR     ;Is the destination color?
        jz      cblt_pattern_fetch      ;  No
        mov     al,I_PUSH_EBX           ;Save plane index
        stosb
        test    bl,F0_DEST_IS_DEV+F0_SRC_IS_DEV ;Is the device involved?
        jz      cblt_pattern_fetch              ;  No

; The device is involved for a color blt.  Copy the logic for selecting
; the read/write plane

        mov     esi,offset FLAT:cps     ;--> plane select logic
        mov     ecx,LENGTH_CPS
        rep     movsb

        subttl  Compile - Pattern Fetch
        page

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; Set up any pattern fetch code that might be needed.
; The pattern code has many fixups, so it isn't taken from a
; template.  It is just stuffed as it is created.
;
; Entry:  None
;
; Exit:   DH = pattern
;
; Uses:   AX,BX,CX,DH,flags
;
; For solid color brushes:
;
;     mov     dh,color
;
; For monochrome brushes:
;
;     mov     ebx,12345678h       ;Load address of the brush
;     mov     dh,7[ebx]           ;Get next brush byte
;     mov     al,[12345678h]      ;Get brush index
;     add     al,direction        ;Add displacement to next byte (+1/-1)
;     and     al,00000111b        ;Keep it in range
;     mov     [12345678h],al      ;Store displacement to next plane's bits
;
; For color brushes:
;
;     mov     ebx,12345678h       ;Load address of the brush
;     mov     dh,7[bx]            ;Get next brush byte
;     mov     al,[12345678h]      ;Get brush index
;     add     al,SIZE Pattern     ;Add displacement to next plane's bits
;     and     al,00011111b        ;Keep it within the brush
;     mov     [12345678h],al      ;Store displacement to next plane's bits
;
;     The address of the increment for the brush is saved for
;     the plane looping logic if the destination is a three plane
;     color device.  For a four plane color device, the AND
;     automatically handles the wrap and no fixup is needed at
;     the end of the plane loop.
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

cblt_pattern_fetch:
        test    bl,F0_PAT_PRESENT       ;Is a pattern needed?
        jz      cblt_initial_byte_fetch ;  No, skip pattern code
        mov     al,fr.brush_accel       ;Solid color needs no fetch logic
        test    al,SOLID_BRUSH
        jz      cblt_nonsolid_brush
        and     al,MM_ALL
        shl     eax,16
        mov     ax,I_TEST_BL_BYTE_I
        stosd
        dec     edi                     ;Was only a three byte instruction
        mov     eax,I_SETNZ_DH
        stosd
        dec     edi                     ;Was only a three byte instruction
        mov     ax,I_NEG_DH
        stosw
        jmp     short cblt_initial_byte_fetch

cblt_nonsolid_brush:
        mov     al,I_MOV_EBX_DWORD_I    ;mov ebx,lpPBrush
        stosb
        mov     eax,fr.lpPBrush
        stosd
        mov     ax,I_MOV_DH_EBX_DISP8   ;mov dh,pat_row[ebx]
        stosw
        mov     edx,edi                 ;Save address of the brush index
        mov     al,fr.pat_row           ;Set initial pattern row
        mov     bh,00000111b            ;Set brush index mask
        and     al,bh                   ;Make sure it's legal at start
        stosb
        mov     al,I_MOV_AL_MEM
        stosb                           ;mov al,[xxxxxxxx]
        mov     eax,edx
        stosd
        mov     al,I_ADD_AL_BYTE_I
        mov     ah,direction            ;Set brush index
        errnz   INCREASE-1              ;Must be a 1
        errnz   DECREASE+1              ;Must be a -1

        test    bl,F0_COLOR_PAT         ;Color pattern required?
        jz      cblt_2060               ;  No
        mov     fr.addr_brush_index,edx ;Save address of brush index
        mov     ah,SIZE_PATTERN         ;Set increment to next plane
        mov     bh,00011111b            ;Set brush index mask

cblt_2060:
        stosw
        mov     ah,bh                   ;and al,BrushIndexMask
        mov     al,I_AND_AL_BYTE_I
        stosw
        mov     al,I_MOV_MEM_AL
        stosb                           ;mov [xxxxxxxx],al
        mov     eax,edx
        stosd


        subttl  Compile - Initial Byte Fetch
        page
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; Create the initial byte code.  This may consist of one or two
; initial fetches (if there is a source), followed by the required
; logic action.  The code should look something like:
;
; BLTouterloop:
;   <       mov     bp,mask_p   >   ;Load phase mask for entire loop
;   <       xor     bh,bh       >   ;Clear previous unused bits
;
; ; Perform first byte fetch
;
;   <       lodsb               >   ;Get source byte
;   <       color<==>mono munge >   ;Color <==> mono conversion
;   <       phase alignment     >   ;Align bits as needed
;
; ; If an optional second fetch is needed, perform one
;
;   <       lodsb               >   ;Get source byte
;   <       color to mono munge >   ;Color to mono munging
;   <       phase alignment     >   ;Align bits as needed
;
;           logical action          ;Perform logical action required
;
;           mov     ah,[edi]        ;Get destination
;           and     ax,cx           ;Saved unaltered bits
;           or      al,ah           ;  and mask in altered bits
;           stosb                   ;Save the result
;
; The starting address of the first fetch/logical combination will be
; saved so that the code can be copied later instead of recreating it
; (if there are two fecthes, the first fetch will not be copied)
;
; The length of the code up to the masking for altered/unaltered bits
; will be saved so the code can be copied into the inner loop.
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

cblt_initial_byte_fetch:
        xor     dx,dx
        or      dh,fr.phase_h           ;Is the phase 0? (also get the phase)
        jz      cblt_3020               ;  Yes, so no phase alignment needed
        mov     al,I_SIZE_OVERRIDE
        stosb
        mov     al,I_MOV_BP_WORD_I      ;Set up the phase mask
        stosb
        mov     ax,fr.mask_p            ;Place the mask into the instruction
        stosw
        mov     ax,I_XOR_BH_BH          ;Clear previous unused bits
        stosw

cblt_3020:
        mov     fr.start_fl,edi             ;Save starting address of action
        test    fr.the_flags,F0_SRC_PRESENT ;Is there a source?
        jz      cblt_4000                   ;  No, don't generate fetch code


; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; Generate the required sequence of instructions for a fetch
; sequence.  Only the minimum code required is generated.
;
; The code generated will look something like the following:
;
; BLTfetch:
;   <       lodsb                 > ;Get the next byte
;   <       color munging         > ;Mono <==> color munging
;
; ; If the phase alignment isn't zero, then generate the minimum
; ; phase alignment needed.  RORs or ROLs will be generated,
; ; depending on the fastest sequence.  If the phase alignment
; ; is zero, than no phase alignment code will be generated.
;
;   <       ror     al,n          > ;Rotate as needed
;   <       mov     ah,al         > ;Mask used, unused bits
;   <       and     ax,bp         > ;(BP) = phase mask
;   <       or      al,bh         > ;Mask in old unused bits
;   <       mov     bh,ah         > ;Save new unused bits
;
;
; The nice thing about the above is it is possible for the fetch to
; degenerate into a simple LODSB instruction.
;
; Currently:      BL = the_flags
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

cblt_3040:
        mov     fr.moore_flags,0        ;Assume REP cannot be used
        shl     bl,1                    ;Color conversion?
        jnc     cblt_3180               ;  No, we were lucky this time
        errnz   F0_GAG_CHOKE-10000000b
        js      cblt_3100               ;Mono ==> color
        errnz   F0_COLOR_PAT-01000000b

        subttl  Compile - Initial Byte Fetch, Color ==> Mono
        page

; !!!  Color to mono should not be needed anymore since the Engine will
; !!! not be calling me to do it!  Let's remove this code!


; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; Generate the code to go from color to mono.  Color to mono
; should map all colors that are background to 1's (white), and
; all colors which aren't background to 0's (black).  If the source
; is the display, then the color compare register will be used.
; If the source is a memory bitmap, each byte of the plane will be
; XORed with the color from that plane, with the results all ORed
; together.  The final result will then be complemented, giving
; the desired result.
;
; The generated code for bitmaps should look something like:
;
;     mov     al,next_plane[esi]            ;Get C1 byte of source
;     mov     ah,2*next_plane[esi]          ;Get C2 byte of source
;     xor     ax,C1BkColor+(C2BkColor*256)  ;XOR with plane's color
;     or      ah,al                         ;OR the result
;     mov     al,3*next_plane[esi]          ;Get C3 byte of source
;     xor     al,C3BkColor
;     or      ah,al
;     lodsb                                 ;Get C0 source
;     xor     al,C0BkColor                  ;XOR with C0BkColor
;     or      al,ah                         ;OR with previous result
;     not     al                            ;NOT to give 1's where background
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

cblt_3070:
        test    bl,F0_SRC_IS_DEV SHL 1  ;If device, use color compare register
        jz      cblt_3080               ;It's a memory bitmap

; We're in luck, the color compare register can be used.  Set up
; for a color read, and use the normal mono fetch code.  Show the
; innerloop code that the REP instruction can be used if this is
; a source copy.

        mov     fr.moore_flags,F1_REP_OK
        mov     ecx,edx                 ;Save dx
        mov     ah,fr.bkColor.SPECIAL   ;Get SPECIAL byte of color
        and     ah,MM_ALL
        mov     al,GRAF_COL_COMP        ;Stuff color into compare register
        mov     dx,EGA_BASE+GRAF_ADDR
        out     dx,ax
        mov     ax,GRAF_CDC             ;Set Color Don't Care register
        out     dx,ax
        mov     ax,M_COLOR_READ SHL 8 + GRAF_MODE
        out     dx,ax
        mov     edx,ecx
        jmp     cblt_3180               ;Go generate mono fetch code

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;       The source is a memory bitmap.  Generate the code to compute
;       the result of the four planes:
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

cblt_3080:
        mov     ax,I_MOV_AL_ESI_DISP32
        stosw
        mov     eax,fr.src.next_plane
        stosd
        mov     ebx,eax                 ;Save plane width
        mov     ax,I_MOV_AH_ESI_DISP32
        stosw
        lea     eax,[ebx*2]
        stosd
        mov     al,I_SIZE_OVERRIDE
        stosb
        mov     al,I_XOR_AX_WORD_I
        stosb
        mov     al,fr.bkColor.SPECIAL   ;get the color index byte
        mov     ah,al                   ;have the same in AH
        and     ax,(C2_BIT shl 8) or C1_BIT
        neg     al
        sbb     al,al                   ;al will be 0ffh if plane bit is 1
        neg     ah
        sbb     ah,ah                   ;ah wil be 0ffh if plane bit is 1
        stosw
        mov     ax,I_OR_AH_AL
        stosw

        mov     ax,I_MOV_AL_ESI_DISP32
        stosw
        lea     eax,[ebx*2][ebx]
        stosd
        mov     al,I_XOR_AL_BYTE_I
        mov     ah,fr.bkColor.SPECIAL
        and     ah,C3_BIT
        neg     ah
        sbb     ah,ah
        stosw
        mov     ax,I_OR_AH_AL
        stosw

        mov     ax,I_LODSB+(I_XOR_AL_BYTE_I*256)
        stosw
        mov     al,fr.bkColor.SPECIAL
        shr     al,1                    ;get C0_BIT into carry
        sbb     al,al                   ;make it 0ffh if bit was set
        .errnz C0_BIT - 00000001b
        stosb                           ;save the modified value
        errnz   pcol_C0
        mov     ax,I_OR_AL_AH
        stosw
        mov     ax,I_NOT_AL
        stosw
        jmp     cblt_3240               ;Go create logic code

        subttl  Compile - Initial Byte Fetch, Mono ==> Color
        page
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; The conversion is mono to color.  Generate the code to
; do the conversion, and generate the table which will
; have the conversion values in it.
;
; When going from mono to color, 1 bits are considered to be
; the background color, and 0 bits are considered to be the
; foreground color.
;
; For each plane:
;
;   If the foreground=background=1, then 1 can be used in
;   place of the source.
;
;   If the foreground=background=0, then 0 can be used in
;   place of the source.
;
;   If the foreground=0 and background=1, then the source
;   can be used as is.
;
;   If the foreground=1 and background=0, then the source
;   must be complemented before using.
;
;   Looks like a boolean function to me.
;
; An AND mask and an XOR mask will be computed for each plane,
; based on the above.  The source will then be processed against
; the table.  The generated code should look like
;
;         lodsb
;         and     al,[xxxx]
;         xor     al,[xxxx+1]
;
; The table for munging the colors as stated above should look like:
;
;      BackGnd   ForeGnd    Result    AND  XOR
;         1         1         1        00   FF
;         0         0         0        00   00
;         1         0         S        FF   00
;         0         1     not S        FF   FF
;
; From this, it can be seen that the XOR mask is the same as the
; foreground color.  The AND mask is the XOR of the foreground
; and the background color.  Not too hard to compute
;
; It can also be seen that if the background color is white and the
; foreground (text) color is black, then the conversion needn't be
; generated (it just gives the source).  This is advantageous since
; it will allow phased aligned source copies to use REP MOVSW.
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

; Check to see if the background color is black, and the
; foreground color is white.  This can be determined by
; looking at the accelerator flags in the physical color.

cblt_3100:
        mov     ah,fr.TextColor.SPECIAL
        xor     ah,MONO_BIT             ;Map black to white
        and     ah,fr.bkColor.SPECIAL   ;AND in background color
        cmp     ah,MONO_BIT+ONES_OR_ZEROS
        jne     cblt_3110               ;Not black
        mov     fr.moore_flags,F1_REP_OK+F1_NO_MUNGE ;Show reps as ok, no color munge table
        jmp     short cblt_3180         ;Normal fetch required

; No way around it.  The color conversion table and code
; must be generated.

cblt_3110:
        mov     cl,fr.bkColor.SPECIAL   ;Get BackGround Colors
        mov     ch,fr.TextColor.SPECIAL ;Get ForeGround Colors
        xor     cl,ch
        shr     cl,1
        sbb     al,al
        shr     ch,1
        sbb     ah,ah
        mov     word ptr fr.ajM2C.(pcol_C0 * 2),ax
        shr     cl,1
        sbb     al,al
        shr     ch,1
        sbb     ah,ah
        mov     word ptr fr.ajM2C.(pcol_C1 * 2),ax
        shr     cl,1
        sbb     al,al
        shr     ch,1
        sbb     ah,ah
        mov     word ptr fr.ajM2C.(pcol_C2 * 2),ax
        shr     cl,1
        sbb     al,al
        shr     ch,1
        sbb     ah,ah
        mov     word ptr fr.ajM2C.(pcol_C3 * 2),ax
        errnz   <TextColor - bkColor - 4>

;       Generate the code for munging the color as stated above.

        mov     ax,I_LODSB
        stosb                           ;lodsb
        mov     ax,I_AND_AL_MEM         ;and al,[xxxx]
        stosw
        lea     eax,fr.ajM2C            ;  Set address of color munge
        stosd
        mov     ebx,eax                 ;  Save address
        mov     ax,I_XOR_AL_MEM         ;xor al,[xxxx]
        stosw
        lea     eax,1[ebx]              ;  Set address of XOR mask
        stosd
        jmp     short cblt_3240

; Just need to generate the normal fetch sequence (lodsb)

cblt_3180:
        mov     al,I_LODSB              ;Generate source fetch
        stosb

        subttl  Compile - Phase Alignment
        page
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; Generate the phase alignment if any.
;
; It is assumed that AL contains the source byte
;
; Currently:
;     DH = phase alignment
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

cblt_3240:
        mov     ecx,edi                 ;end of fetch code
        sub     ecx,fr.start_fl         ;start of fetch code
        mov     fr.cFetchCode,ecx       ;save size of fetch code
        xor     ecx,ecx                 ;Might have garbage in it
        or      dh,dh                   ;Any phase alignment?
        jz      cblt_3280               ;  No, so skip alignment
        mov     cl,dh                   ;Get horizontal phase for rotating
        mov     ax,I_ROL_AL_N           ;Assume rotate left n times
        cmp     cl,5                    ;4 or less rotates?
        jc      cblt_3260               ;  Yes
        neg     cl                      ;  No, compute ROR count
        add     cl,8
        mov     ah,HIGH I_ROR_AL_N
        errnz   <(LOW I_ROL_AL_N)-(LOW I_ROR_AL_N)>

cblt_3260:
        stosw                           ;Stuff the phase alignment rotates
        mov     al,cl                   ;  then the phase alignment code
        stosb

; Do not generate phase masking if there is only 1 src And only 1 dest byte.
; This is not just an optimization, see comments where these flags are set.

        xor     ch,ch
        mov     al,fr.first_fetch
        and     al,FF_ONLY_1_SRC_BYTE or FF_ONLY_1_DEST_BYTE
        xor     al,FF_ONLY_1_SRC_BYTE or FF_ONLY_1_DEST_BYTE
        jz      cblt_3280
        mov     esi,offset FLAT:phase_align
        mov     ecx,PHASE_ALIGN_LEN
        rep     movsb

cblt_3280:
        test    fr.first_fetch,FF_TWO_INIT_FETCHES  ;Generate another fetch?
        jz      cblt_4000                           ;  No

; A second fetch needs to be stuffed.  Copy the one just created.

        mov     esi,fr.start_fl         ;Set new start, get old
        mov     fr.start_fl,edi
        mov     ecx,edi                 ;Compute how long fetch is
        sub     ecx,esi                 ;  and move the bytes
        rep     movsb

        subttl  Compile - ROP Generation
        page
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; Create the logic action code
;
; The given ROP will be converted into the actual code that
; performs the ROP.
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

; Copy the ROP template into the BLT

cblt_4000:
        mov     ax,fr.operands          ;Get back rop data
        mov     bl,ah                   ;Get count of number of bits to move
        and     ebx,HIGH ROPLength
        shr     ebx,2
        movzx   ecx,roptable+256[ebx] ;Get length into cx
        errnz   ROPLength-0001110000000000b

        mov     ebx,eax                 ;Get offset of the template
        and     ebx,ROPOffset
        lea     esi,roptable[ebx]       ;--> the template
        rep     movsb                   ;Move the template

cblt_4020:
        mov     bx,ax                   ;Keep rop around
        or      ah,ah                   ;Generate a negate?
        jns     cblt_4040               ; No
        mov     ax,I_NOT_AL
        stosw

public cblt_4040
cblt_4040::
        mov     fr.end_fl,edi           ;Save end of fetch/logic operation

        subttl  Compile - Mask And Save
        page
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; Generate code to mask and save the result.  If the destination
; isn't in a register, it will be loaded from ES:[DI] first.  The
; mask operation will then be performed, and the result stored.
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        mov     ax,I_MOV_AH_DEST        ; ah,[edi]
        stosw

        mov     esi,offset FLAT:masked_store;Move rest of masked store template
        movsb                           ;Move size override
        movsd
        movsw
        errnz   MASKED_STORE_LEN-7      ;Must be seven bytes long
        mov     ax,fr.start_mask        ;Stuff start mask into
        xchg    ah,al                   ;  the template

        mov     [edi][MASKED_STORE_MASK],ax

        mov     fr.end_fls,edi          ;Save end of fetch/logic/store operation

        subttl  Compile - Inner Loop Generation
        page
;-----------------------------------------------------------------------;
; Now for the hard stuff; The inner loop (said with a "gasp!").
;
; If there is no innerloop, then no code will be generated
; (now that's fast!).
;-----------------------------------------------------------------------;

cblt_5000:
        mov     edx,fr.inner_loop_count ;Get the loop count
        or      dx,dx                   ;If the count is null
        jz      cblt_6000               ;  don't generate any code

;!!! Since we no longer pass in the old style rops, we can;t enable this code
;!!! and shold remove/alter it someday.  Besides, most of it is in special.asm
if 0                                    ;!!!

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; We have something for a loop count.  If this just happens to be
; a source copy (S) with a phase of zero, then the innerloop degenerates
; to a repeated MOVSB instruction.  This little special case is
; worth checking for and handling!
;
; Also, if this is one of the special cases {P, Pn, DDx, DDxn}, then it
; will also be special cased since these are all pattern fills (pattern,
; not pattern, 0, 1).
;
; The same code can be shared for these routines, with the exception
; that patterns use a STOSx instruction instead of a MOVSx instruction
; and need a value loaded in AX
;
; So we lied a little.  If a color conversion is going on, then the
; REP MOVSB might not be usable.  If the F1_REP_OK flag has been set, then
; we can use it.  The F1_REP_OK flag will be set for a mono ==> color
; conversion where the background color is white and the foreground
; color is black, or for a color ==> mono conversion with the screen
; as the source (the color compare register will be used).
;
; For the special cases {P, Pn, DDx, DDxn}, color conversion is
; not possible, so ignore it for them.
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        mov     bl,byte ptr fr.Rop      ;Get the raster op
        test    bl,EPS_INDEX            ;Can this be special cased?
        jnz     cblt_5500               ;  No
        errnz   <HIGH EPS_INDEX>
        errnz   SPEC_PARSE_STR_INDEX    ;The special case index must be 0

        test    bl,EPS_OFF              ;Is this a source copy
        jz      cblt_5040               ;  Yes
        errnz   <SOURCE_COPY AND 11b>   ;Offset for source copy must be 0

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; We should have one of the following fill operations:
;
;   P       - Pattern
;   Pn      - NOT pattern
;   DDx     - 0 fill
;   DDxn    - 1 fill
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        mov     ax,I_MOV_AL_0FFH        ;Assume this is a 0 or 1 fill
        test    bl,01h                  ;Is it 0 or 1 fill?
        jz      cblt_5020               ;  Yes, initialize AX with 0FFh
        mov     ax,I_MOV_AL_DH          ;  No,  initialize AX with pattern

        errnz      PAT_COPY-0000000000100001b
        errnz   NOTPAT_COPY-0000000000000001b
        errnz    FILL_BLACK-0000000001000010b
        errnz    FILL_WHITE-0000000001100010b

cblt_5020:
        stosw
        mov     ax,I_MOV_AH_AL
        stosw
        mov     si,I_STOSB              ;Set up for repeated code processor
        test    bl,LogPar               ;If Pn or 0, then complement pattern
        jnz     cblt_5060               ;  Is just P or 1
        errnz   <HIGH LogPar>
        mov     al,I_SIZE_OVERRIDE
        stosb
        mov     ax,I_NOT_AX             ;  Is Pn or 0, complement AX
        stosw
        jmp     short cblt_5060

        errnz      PAT_COPY-00100001b
        errnz   NOTPAT_COPY-00000001b
        errnz    FILL_BLACK-01000010b
        errnz    FILL_WHITE-01100010b


; This is a source copy.  The phase must be zero for a source copy
; to be condensed into a REP MOVSx.

cblt_5040:
        test    fr.phase_h,0FFh         ;Is horizontal phase zero?
        jnz     cblt_5500               ;  No, can't condense source copy
        mov     si,I_MOVSB              ;Set register for moving bytes

; For a color conversion, F1_REP_OK must be set.

        test    fr.the_flags,F0_GAG_CHOKE   ;Color conversion?
        jz      cblt_5060                   ;  No, rep is OK to use
        test    fr.moore_flags,F1_REP_OK    ;  Yes, can we rep it?
        jz      cblt_5500                   ;    No, do it the hard way


;-----------------------------------------------------------------------;
; This is a source copy or pattern fill.  Process an odd byte with
; a MOVSB or STOSB, then process the rest of the bytes with a REP
; MOVSW or a REP STOSW.  If the REP isn't needed, leave it out.
;
; Don't get caught on this like I did!  If the direction of the
; BLT is from right to left (decrementing addresses), then both
; the source and destination pointers must be decremented by one
; so that the next two bytes are processed, not the next byte and
; the byte just processed.  Also, after all words have been processed,
; the source and destination pointers must be incremented by one to
; point to the last byte (since the last MOVSW or STOSW would have
; decremented both pointers by 2).
;
; If the target machine is an 8086, then it would be well worth the
; extra logic to align the fields on word boundaries before the MOVSxs
; if at all possible.
;
; The generated code should look something like:
;
; WARP8:                               ;This code for moving left to right
;         movsb                        ;Process an odd byte
;         mov     ecx,gl_inner_loop_count/2 ;Set word count
;         rep                          ;If a count, then repeat is needed
;         movsw                        ;Move words until done
;
;
; WARP8:                               ;This code for moving left to right
;         movsb                        ;Process an odd byte
;         dec     si                   ;adjust pointer for moving words
;         dec     di
;         mov     ecx,gl_inner_loop_count/2 ;Set word count
;         rep                          ;If a count, then repeat is needed
;         movsw                        ;Move words until done
;         inc     si                   ;adjust since words were moved
;         inc     di
;
;
; Of course, if any part of the above routine isn't needed, it isn't
; generated (i.e. the generated code might just be a single MOVSB)
;-----------------------------------------------------------------------;

cblt_5060:
        shr     edx,1                   ;Byte count / 2 for words
        jnc     cblt_5080               ;  No odd byte to move
        mov     ax,si                   ;  Odd byte, move it
        stosb

cblt_5080:
        jz      cblt_5140               ;No more bytes to move
        xor     bx,bx                   ;Flag as stepping from left to right
        cmp     bl,fr.step_direction    ;Moving from the right to the left?
        errnz   STEPLEFT                ;  (left direction must be zero)
        jnz     cblt_5100               ;  No
        mov     ax,I_DEC_ESI_DEC_EDI    ;  Yes, decrement both pointers
        stosw
        mov     bx,I_INC_ESI_INC_EDI      ;Set up to increment the pointers later

0cblt_5100:
        cmp     edx,1                   ;Move one word or many words?
        jz      cblt_5120               ;  Only one word
        mov     al,I_MOV_ECX_DWORD_I    ;  Many words, load count
        stosb
        mov     eax,edx
        stosd
        mov     al,I_REP                ;a repeat instruction
        stosb

cblt_5120:
        mov     al,I_SIZE_OVERRIDE
        stosb
        mov     ax,si                   ;Set the word instruction
        inc     ax
        stosb
        errnz   I_MOVSW-I_MOVSB-1       ;The word form of the instruction
        errnz   I_STOSW-I_STOSB-1       ;  must be the byte form + 1

        or      bx,bx                   ;Need to increment the pointers?
        jz      cblt_5140               ;  No
        mov     ax,bx                   ;  Yes, increment both pointers
        stosw

cblt_5140:
        jmp     cblt_6000               ;Done setting up the innerloop
        page

endif

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; There is some count for the innerloop of the BLT.  Generate the
; required BLT. Two or four copies of the BLT will be placed on the
; stack.   This allows the LOOP instruction at the end to be distributed
; over two or four bytes instead of 1, saving 11 or 12 clocks for each
; byte (for 4).  Multiply 12 clocks by ~ 16K and you save a lot of
; clocks!
;
; If there are less than four (two) bytes to be BLTed, then no looping
; instructions will be generated.  If there are more than four (two)
; bytes, then there is the possibility of an initial jump instruction
; to enter the loop to handle the modulo n result of the loop count.
;
; The innerloop code will look something like:
;
;   <       mov     cx,loopcount/n> ;load count if >n innerloop bytes
;   <       jmp     short ???     > ;If a first jump is needed, do one
;
; BLTloop:
;         replicate initial byte BLT code up to n times
;
;   <       loop    BLTloop >       ;Loop until all bytes processed
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

cblt_5500:
        mov     ebx,fr.end_fl           ;Compute size of the fetch code
        sub     ebx,fr.start_fl
        inc     ebx                     ;A stosb will be appended
        mov     esi,4                   ;Assume replication 4 times
        mov     cl,2                    ;  (shift count two bits left)
        cmp     ebx,32                  ;Small enough for 4 times?
        jc      cblt_5520               ;  Yes, replicate 4 times
        shr     esi,1                   ;  No,  replicate 2 times
        dec     ecx

cblt_5520:
        cmp     edx,esi                 ;Generate a loop? (edx = loopcount)
        jle     cblt_5540               ;  No, just copy code
        mov     al,I_MOV_ECX_DWORD_I
        stosb                           ;mov cx,loopcount/n
        mov     eax,edx                 ;Compute loop count
        shr     eax,cl
        stosd
        shl     eax,cl                  ;See if loopcount MOD n is 0
        sub     eax,edx
        jz      cblt_5540               ;Zero, no odd count to handle

        page
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; There is an odd portion of bytes to be processed.  Increment
; the loop counter for the odd pass through the loop and then
; compute the displacement for entering the loop.
;
; To compute the displacement, subtract the number of odd bytes
; from the modulus being used  (i.e. 4-3=1).  This gives the
; number of bytes to skip over the first time through the loop.
;
; Multiply this by the number of bytes for a logic sequence,
; and the result will be the displacement for the jump.
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        inc     dword ptr [edi][-4]     ;Not zero, adjust for partial loop
        add     eax,esi                 ;Compute where to enter the loop at
        push    edx
        mul     ebx
        pop     edx
        mov     ecx,eax
        mov     al,I_JMP_DISP32         ;Stuff jump instruction
        stosb
        mov     eax,ecx                 ;Stuff displacement for jump
        stosd

;-----------------------------------------------------------------------;
; Currently:      EDX = loop count
;                 ESI = loop modulus
;                 EBX = size of one logic operation
;                 EDI --> next location in the loop
;-----------------------------------------------------------------------;

cblt_5540:
        mov     ecx,ebx                 ;Set move count
        mov     ebx,edx                 ;Set maximum for move
        cmp     ebx,esi                 ;Is the max > what's left?
        jle     cblt_5560               ;  No, just use what's left
        mov     ebx,esi                 ;  Yes, copy the max

cblt_5560:
        sub     edx,esi                 ;If dx > 0, then loop logic needed
        mov     esi,fr.start_fl         ;--> fetch code to copy
        mov     eax,ecx                 ;Save a copy of fetch length
        rep     movsb                   ;Move fetch code and stuff stosb
        mov     esi,edi                   ;--> new source (and top of loop)
        sub     esi,eax
        mov     byte ptr [edi][-1],I_STOSB
        dec     ebx                     ;One copy has been made
        push    edx
        mul     ebx                     ;Compute # bytes left to move
        pop     edx
        mov     ecx,eax                 ;Set move count
        rep     movsb                   ;Move the fetches
        sub     esi,eax                 ;Restore pointer to start of loop

        page

; The innermost BLT code has been created and needs the looping
; logic added to it.  If there is any looping to be done, then
; generate the loop code.  The code within the innerloop may be
; greater than 126 bytes, so a LOOP instruction may not be used
; in this case.

cblt_5580:
        or      edx,edx                 ;Need a loop?
        jle     cblt_6000               ;  No, don't generate one
        mov     al,I_DEC_ECX
        stosb
        mov     ax,I_JNZ_DISP32
        stosw
        mov     eax,esi                 ;Compute offset of loop
        sub     eax,edi
        sub     eax,4                   ;Bias by DISP32
        stosd


        subttl  Compile - Last Byte Processing
        page
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; All the innerloop stuff has been processed.  Now generate the code for
; the final byte if there is one.  This code is almost identical to the
; code for the first byte except there will only be one fetch (if a
; fetch is needed at all).
;
; The code generated will look something like:
;
; <       fetch           >       ;Get source byte
; <       align           >       ;Align source if needed
;         action                  ;Perform desired action
;         mask and store
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

cblt_6000:
        mov     dx,fr.last_mask         ;Get last byte mask
        or      dh,dh                   ;Is there a last byte to be processed?
        jz      cblt_6100               ;  No.

        mov     ecx,fr.end_fls          ;Get end of fetch/logic/store operation
        mov     esi,fr.start_fl         ;Get start of fetch/logic sequence
        sub     ecx,esi                 ;Compute length of the code
        test    fr.first_fetch,FF_NO_LAST_FETCH
        jz      cblt_include_fetch
        test    fr.the_flags,F0_SRC_PRESENT ; was there a fetch?
        jz      cblt_was_no_fetch
        cmp     fr.phase_h,0            ; Phase zero case is not combined
                                        ; into innerloop as it should be.
                                        ; If the final byte is full then we
                                        ; better not remove the lodsb ( i.e.
        je      cblt_include_fetch      ; 0 - 0 = 0 would make us think we could)

        mov     eax,fr.cFetchCode       ; don't copy the fetch (lodsb)
        add     esi,eax
        sub     ecx,eax

cblt_was_no_fetch:
cblt_include_fetch:

        rep     movsb                       ;Copy the fetch/action/store code
        xchg    dh,dl
        mov     [edi][MASKED_STORE_MASK],dx ;Stuff last byte mask into the code
skip_save:
        subttl  Compile - Looping Logic
        page

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; Looping logic.
;
; The looping logic must handle monochrome bitmaps, color bitmaps,
; huge bitmaps, the device, the presence or absence of a source
; or pattern, and mono <==> color interactions.
;
; The type of looping logic is always based on the destination.
;
; Plane Update Facts:
;
; 1)  If the destination device is color, then there will be
;     logic for plane selection.  Plane selection is performed
;     at the start of the loop for the display.  Plane selection
;     for bitmaps is performed at the end of the loop in anticipation
;     of the next plane.
;
;     The following applies when the destination is color:
;
;     a)  The destination update consists of:
;
;         1)  If the destination is the display, the next plane will
;             be selected by the plane selection code at the start
;             of the scan line loop.
;
;         2)  If not the display, then the PDevice must a bitmap.
;             The next plane will be selected by updating the
;             destination offset by the next_plane value.
;
;
;     b)  If F0_GAG_CHOKE isn't specified, then there may be a source.
;         If there is a source, it must be color, and the update
;         consists of:
;
;         1)  If the source is the display, the next plane will be
;             selected by the plane selection code at the start of
;             the loop.
;
;         2)  If not the display, then the PDevice must a bitmap.
;             The next plane will be selected by updating the
;             destination offset by the next_plane value.
;
;
;     c)  If F0_GAG_CHOKE is specified, then the source must be a
;         monochrome bitmap which is undergoing mono to color
;         conversion.  The AND & XOR mask table which is used
;         for the conversion will have to be updated, unless
;         the F1_NO_MUNGE flag is set indicating that the color
;         conversion really wasn't needed.
;
;         The source's pointer will not be updated.  It will
;         remain pointing to the same scan of the source until
;         all planes of the destination have been processed.
;
;
;     d)  In all cases, the plane mask rotation code will be
;         generated.  If the plane indicator doesn't overflow,
;         then start at the top of the scan line loop for the
;         next plane.
;
;         If the plane indicator overflows, then:
;
;             1)  If there is a pattern present, it's a color
;                 pattern fetch.  The index of which scan of
;                 the brush to use will have to be updated.
;
;             2)  Enter the scan line update routine
;
;
; 2)      If the destination is monochrome, then there will be no
;         plane selection logic.
;
;         If F0_GAG_CHOKE is specified, then color ==> mono conversion
;         is taking place.  Any plane selection logic is internal
;         to the ROP byte fetch code.  Any color brush was pre-
;         processed into a monochrome brush, so no brush updating
;               need be done
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        subttl  Looping Logic - Plane Selection
        page

; Get saved parameters off of the stack.
;
; <       pop     ebx            > ;Get plane indicator
; <       pop     esi            > ;Get source pointer
;         pop     edi              ;Get destination pointer
;         pop     ecx              ;Get loop count

cblt_6100:
        mov     bh,fr.the_flags         ;These flags will be used a lot
        test    bh,F0_DEST_IS_COLOR     ;Is the destination color?
        jz      cblt_6120               ;  No
        mov     al,I_POP_EBX            ;Restore plane index
        stosb

cblt_6120:
        test    bh,F0_SRC_PRESENT       ;Is a source needed?
        jz      cblt_6140               ;  No
        mov     al,I_POP_ESI            ;  Yes, get source pointer
        stosb

cblt_6140:
        mov     ax,I_POP_EDI_POP_ECX    ;Get destination pointer
        stosw                           ;Get loop count
        test    bh,F0_DEST_IS_COLOR     ;Color scanline update?
        jz      cblt_6300               ;  No, just do the mono scanline update

; The scanline update is for color.  Generate the logic to update
; a brush, perform plane selection, process mono ==> color conversion,
; and test for plane overflow.

cblt_6160:
        or      bh,bh                   ;Color conversion?
        jns     cblt_6180               ;  No
        errnz   F0_GAG_CHOKE-10000000b

        page
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; The source is monochrome.  Handle mono ==> color conversion.
; The AND & XOR mask table will need to be rotated for the next
; pass over the source.
;
; The source scanline pointer will not be updated until all planes
; have been processed for the current scan.
;
; If F1_NO_MUNGE has been specified, then the color conversion table
; and the color conversion code was not generated, and no update
; code will be needed.
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        test    fr.moore_flags,F1_NO_MUNGE  ;Is there really a conversion table?
        jnz     short cblt_6200             ;  No, so skip the code

        mov     al,I_MOV_EBP_DWORD_I        ;lea ebp,fr.ajM2C
        stosb
        lea     eax,fr.ajM2c                ;Get address of table
        stosd
        mov     esi,offset FLAT:rot_and_xor ;--> rotate code
        mov     cx,LEN_ROT_AND_XOR
        rep     movsb
        jmp     short cblt_6200

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; If there is a source, it must be color.  If it is a memory
; bitmap, then the next plane must be selected, else it is
; the display and the next plane will be selected through
; the hardware registers.
;
; <       add     si,next_plane>
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

cblt_6180:
        test    bh,F0_SRC_PRESENT       ;Is there really a source?
        jz      cblt_6200               ;No source.
        test    bh,F0_SRC_IS_DEV        ;Is the source the display?
        jnz     cblt_6200               ;  Yes, use hardware plane selection
        mov     ax,I_ADD_ESI_DWORD_I    ;  No, generate plane update
        stosw                           ;Add si,next_plane
        mov     eax,fr.src.next_plane
        stosd

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; If the destination isn't the device, then it must be a color
; memory bitamp, and it's pointer will have to be updated by
; bmWidthPlanes.  If it is the display, then the next plane
; will be selected through the hardware registers.
;
; <       add     di,next_plane>
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

cblt_6200:
        test    bh,F0_DEST_IS_DEV       ;Is the destination the display
        jnz     cblt_6220               ;  Yes, don't generate update code
        mov     ax,I_ADD_EDI_DWORD_I    ;  No, update bitmap to the next plane
        stosw
        mov     eax,fr.dest.next_plane
        stosd


; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; The source and destination pointers have been updated.
; Now generate the plane looping logic.
;
; <       shl     bl,1           > ;Select next plane
; <       jnc     StartOfLoop    > ;  Yes, go process next
; <       mov     bl,PLANE_1     > ;Reset plane indicator
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

cblt_6220:
        mov     ax,I_SHL_BL_1           ;Stuff plane looping logic
        stosw

        mov     edx,fr.pNextPlane       ;Compute relative offset of
        sub     edx,edi                 ;  start of loop
        sub     edx,6                   ;Bias offset by length of jnc inst.
        mov     ax,I_JNC_DISP32
        stosw                           ;jnc StartOfLoop
        mov     eax,edx
        stosd

        subttl  Looping Logic - Color Brush Update
        page

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; The plane update logic has been copied.  If a pattern was
; involved for a color BLT, then the pattern index will need
; to be updated to the next scanline for three plane mode.
;
; This will involve subtracting off 3*SIZE_PATTERN (MonoPlane),
; and adding in the increment.  The result must be masked with
; 00000111b to select the correct source.  Note that the update
; can be done with an add instruction and a mask operation.
;
; inc   index+MonoPlane   inc-MonoPlane   result   AND 07h
;
;  1       0+32 = 32        1-32 = -31       1         1
;  1       7+32 = 39        1-32 = -31       8         0
; -1       0+32 = 32       -1-32 = -33      FF         7
; -1       7+32 = 39       -1-32 = -33       6         6
;
; <       mov     al,[12345678] > ;Get brush index
; <       add     al,n          > ;Add displacement to next byte
; <       and     al,00000111b  > ;Keep it in range
; <       mov     [12345678],al > ;Store displacement to next byte
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

        test    bh,F0_PAT_PRESENT       ;Is a pattern involved?
        jz      cblt_6300               ;  No
        test    fr.brush_accel,SOLID_BRUSH
        jnz     cblt_6300               ;Solid color fetch needs no updating
        mov     al,I_MOV_AL_MEM
        stosb                           ;mov al,[xxxxxxxx]
        mov     edx,fr.addr_brush_index
        mov     eax,edx
        stosd
        mov     al,I_ADD_AL_BYTE_I
        mov     ah,fr.direction         ;add al,bais
        sub     ah,oem_brush_mono       ;Anybody ever fly one of these things?
        errnz   INCREASE-1              ;Must be a 1
        errnz   DECREASE+1              ;Must be a -1
        stosw
        mov     ax,0700h+I_AND_AL_BYTE_I        ;and al,00000111b
        stosw
        mov     al,I_MOV_MEM_AL
        stosb                           ;mov [xxxxxxxx],al
        mov     eax,edx
        stosd

        subttl  Looping Logic - Scan Line Update
        page
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; Generate the next scanline code.  The next scan line code must
; handle monochrome bitmaps, the device, the presence or absence
; of a source.
;
; Also color bitmaps, and mono <==> color interactions.
;
; <       add si,gl_src.next_scan> ;Normal source scan line update
;         add di,gl_dest.next_scan ;Normal destination scan line update
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

;!!! We have the problem in that this code assumes that cPlanes*cjBytesScan
;!!! is the same as next_scan.  This might not always be the case, and we
;!!! should do somehting about fixing this.  This would require pushing an
;!!! extra copy of pScan_n_Plane0 and then adding next-scan to this when we
;!!! have exhausted the planes for scan n

cblt_6300:
        test    bh,F0_SRC_PRESENT       ;Is there a source?
        jz      cblt_6340               ;  No, skip source processing
        mov     ax,I_ADD_ESI_DWORD_I    ;add esi,increment
        stosw
        mov     eax,fr.src.next_scan
        stosd

cblt_6340:
        mov     ax,I_ADD_EDI_DWORD_I    ;add edi,increment
        stosw
        mov     eax,fr.dest.next_scan
        stosd

; Compile the scan line loop.  The code simply jumps to the start
; of the outer loop if more scans exist to be processed.

cblt_6380:
        mov     al,I_DEC_ECX
        stosb
        mov     ax,I_JNZ_DISP32
        stosw
        mov     eax,fr.blt_addr         ;Compute relative offset of
        sub     eax,edi                 ;  start of loop
        sub     eax,4                   ;Adjust jump bias for DISP32
        stosd                           ;  and store it into jump

cblt_6420:
        mov     al,I_RET                ;Stuff the far return instruction
        stosb

     cRet    cblt
endProc cblt

_TEXT$01   ends

        end


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\cpybits.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: cpybits.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
        page    ,132
        title   DrvCopyBits Support
        .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc         ;VGA register definitions
        include i386\strucs.inc
        .list

;-----------------------------------------------------------------------;

        .data

; Reuse the work area from the dib conversion code.

        extrn   ajConvertBuffer:byte    ;Buffer for converting to/from display

CJ_WORK_PLANE   equ     cj_max_scan+1   ;Width of each plane in ajConvertBuffer

        .code

; ausLo16 is used to convert the low nibble of a byte into 4bpp packed pel

ausLo16 label   word

        dw          0000h                   ;0000
        dw          0100h                   ;0001
        dw          1000h                   ;0010
        dw          1100h                   ;0011
        dw          0001h                   ;0100
        dw          0101h                   ;0101
        dw          1001h                   ;0110
        dw          1101h                   ;0111
        dw          0010h                   ;1000
        dw          0110h                   ;1001
        dw          1010h                   ;1010
        dw          1110h                   ;1011
        dw          0011h                   ;1100
        dw          0111h                   ;1101
        dw          1011h                   ;1110
        dw          1111h                   ;1111

; aulHi16 is used to convert the hi nibble of a byte into 4bpp packed pel

aulHi16 label   dword

        dd          00000000h               ;0000
        dd          01000000h               ;0001
        dd          10000000h               ;0010
        dd          11000000h               ;0011
        dd          00010000h               ;0100
        dd          01010000h               ;0101
        dd          10010000h               ;0110
        dd          11010000h               ;0111
        dd          00100000h               ;1000
        dd          01100000h               ;1001
        dd          10100000h               ;1010
        dd          11100000h               ;1011
        dd          00110000h               ;1100
        dd          01110000h               ;1101
        dd          10110000h               ;1110
        dd          11110000h               ;1111

; ajRightMasks turns an exclusive bit position (0-7) into a mask of bits
; to alter for the right hand side of the blt

ajRightMasks    label   byte

        db          11111111b               ;0 should never be used
        db          01111111b               ;1
        db          00111111b               ;2
        db          00011111b               ;3
        db          00001111b               ;4
        db          00000111b               ;5
        db          00000011b               ;6
        db          00000001b               ;7

; ajLeftMasks turns a bit position (0-7) into a mask of bits to alter for
; the left hand side of the blt

ajLeftMasks     label   byte

        db          11111111b               ;0 should never be used
        db          10000000b               ;1
        db          11000000b               ;2
        db          11100000b               ;3
        db          11110000b               ;4
        db          11111000b               ;5
        db          11111100b               ;6
        db          11111110b               ;7


CB_4BPP_SCAN    equ (CX_SCREEN_MAX / 2)     ;# bytes for a 4bpp screen scan

;-----------------------------Public-Routine----------------------------;
; vConvertVGAScan
;
; Converts a VGA scan into a 4bpp format with a given phase alignment,
; and returns a pointer to the converted buffer.
;
; pdsurfsrc - pointer to source surface (must be VGA display memory)
; xSrc      - X origin of the source
; ySrc      - Y origin of the source
; pjDstBase - Base address of the destination
; xDst      - X origin of the destination
; yDst      - Y origin of the destination
; cxPels    - Number of pels in X
; cyTotalScans - Number of scans in overall operation
; lDelta    - Width in bytes of a destination scan
; iFormat   - Format of destination
; pulXlate  - Color translation vector
;-----------------------------------------------------------------------;

ProcName    xxxvConvertVGA2DIB,vConvertVGA2DIB,44

xxxvConvertVGA2DIB proc uses esi edi ebx,\
        pdsurfsrc       :ptr DEVSURF,   \
        xSrc            :dword,         \
        ySrc            :dword,         \
        pjDstBase       :dword,         \
        xDst            :dword,         \
        yDst            :dword,         \
        cxPels          :dword,         \
        cyTotalScans    :dword,         \
        lDelta          :dword,         \
        iFormat         :dword,         \
        pulXlate        :dword

;-----------------------------------------------------------------------;
; Local variables and their meaning
;
; cjScreenCopy      This is the number of bytes to copy from each scan
;                   into ajConvertBuffer.
; jLeftMask         This is the left-hand side (lhs) mask used when copying
;                   the converted data to the destination
; jRightMask        This is the right-hand side (lhs) mask used when copying
;                   the converted data to the destination
; cRightShift       This is the number of bits that the converted data needs
;                   to be shifted right to align with the destination.
; cjRightShift      This is the number of bytes which must be shifted right
;                   by cRightShift
; cCopy             This is the number of full (e.g. not masked) bytes which
;                   must be copied to the destination
; pjWork            Pointer to the work area where
;                       a)  color converted data is written into
;                       b)  bits are phase-aligned if needed
;                       c)  data is read from for the final copy to the DIB
; pjSrc             Address of scan 0 in memory
; pjDst             Address of scan 0 in memory
; cyScans           Number of scans to do in current bank
; ulScanWidth       Offset from start of one scan to start of next
; ulBottomSrcScan   Bottom scan line of source rectangle (non-inclusive)
;-----------------------------------------------------------------------;

        local   cjScreenCopy    :dword
        local   jLeftMask       :byte
        local   jRightMask      :byte
        local   cRightShift     :byte
        local   cjRightShift    :dword
        local   cCopy           :dword
        local   pfnXlate        :ptr
        local   pjWork          :ptr
        local   cjSkip          :dword
        local   pjSrc           :dword
        local   pjDst           :dword
        local   cyScans         :dword
        local   ulScanWidth     :dword
        local   ulBottomSrcScan :dword

        local   ajColorConv[16]:byte
        local   ajWork[CB_4BPP_SCAN+4]:byte
        local   aj8bpp[CX_SCREEN_MAX+8]:byte


;----------------------------------------------------------------------;
; Loop through source banks, copying & converting one bank at a time.

; Calculate the bottom scan line of the source rectangle (non-inclusive).

        mov     eax,ySrc
        add     eax,cyTotalScans
        mov     ulBottomSrcScan,eax

        mov     ecx,pdsurfsrc           ;point to source surface
        mov     eax,[ecx].dsurf_lNextScan
        mov     ulScanWidth,eax         ;local copy of scan line width

; Map in the bank containing the top scan to fill, if it's not mapped in
; already.

        mov     eax,ySrc                ;top scan line of source

        cmp     eax,[ecx].dsurf_rcl1WindowClip.yTop ;is fill top less than
                                                    ; current bank?
        jl      short map_init_bank             ;yes, map in proper bank
        cmp     eax,[ecx].dsurf_rcl1WindowClip.yBottom ;fill top greater than
                                                       ; current bank?
        jl      short init_bank_mapped          ;no, proper bank already mapped
map_init_bank:

; Map in the bank containing the top scan line of the fill.

        ptrCall <dword ptr [ecx].dsurf_pfnBankControl>,<ecx,eax,JustifyTop>

init_bank_mapped:

bank_loop:

; Set the start address of the source bitmap.
; Note that the start of the bitmap will change each time through the
; bank loop, because the start of the bitmap is varied to map the
; desired scan line to the banking window.

        mov     eax,pdsurfsrc           ;point to source surface
        mov     ebx,[eax].dsurf_pvBitmapStart ;start of scan 0 in bitmap
        mov     pjSrc,ebx

; Set the start address of the destination bitmap.

        mov     ebx,pjDstBase
        mov     pjDst,ebx

; Figure out how many scan lines we'll fill in the current bank.

        mov     ebx,ulBottomSrcScan     ;bottom of destination rectangle
        cmp     ebx,[eax].dsurf_rcl1WindowClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; dest rect or the bottom of the
                                        ; current bank?
        jl      short BottomScanSet     ;fill bottom comes first, so draw to
                                        ; that; this is the last bank in fill
        mov     ebx,[eax].dsurf_rcl1WindowClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
BottomScanSet:
        sub     ebx,ySrc        ;# of scans to fill in bank
        mov     cyScans,ebx
        push    ebx             ;remember # of scans in bank

        call    DoOneBank       ;copy and convert within the current bank

        pop     ebx             ;restore # of scans in bank

        sub     cyTotalScans,ebx        ;count off this bank's scans from total
        jz      short banks_done        ;no more scans; done
        add     yDst,ebx                ;advance to the next destination scan
                                        ; to copy to
        mov     edi,pdsurfsrc
        mov     eax,[edi].dsurf_rcl1WindowClip.yBottom
        mov     ySrc,eax                ;remember where the top of the bank
                                        ; we're about to map in is (same as
                                        ; bottom of bank we just did)

        ptrCall <dword ptr [edi].dsurf_pfnBankControl>,<edi,eax,JustifyTop>
                                        ;map in the bank

        jmp     bank_loop               ;fill the next bank


; Done.

        align   4
banks_done:

        cRet    vConvertVGA2DIB

;----------------------------------------------------------------------;
; Copies and converts bits within a single bank.

        align   4
DoOneBank:

        cld

; Compute the number of bytes to copy from the screen, and the starting
; address of the source

        mov     eax,ySrc                ;Compute addr of first source scan
        mov     ebx,xSrc
        imul    eax,ulScanWidth
        mov     ecx,ebx
        shr     ebx,3
        add     eax,ebx
        add     pjSrc,eax

; Compute the number of bytes to actually transfer from the screen

        mov     eax,cxPels              ;Compute rhs
        add     eax,ecx
        dec     eax                     ;Make rhs inclusive
        shr     ecx,3                   ;Compute byte of lhs
        shr     eax,3                   ;Compute byte of rhs
        sub     eax,ecx                 ;Compute number of bytes for copy
        inc     eax                     ;(because rhs inclusive, always inc)
        mov     cjScreenCopy,eax

; Compute the address of the starting destination scan.

        mov     eax,yDst
        imul    lDelta
        add     pjDst,eax

; Set up for the preprocess loops and invoke the correct one.  First make
; some assumptions about defaults

        xor     eax,eax
        mov     cRightShift,al          ;No shifting needed
        mov     jLeftMask,al            ;No left masking needed
        mov     jRightMask,al           ;No right masking needed
        lea     eax,ajWork              ;Intermediate work area
        mov     pjWork,eax

        mov     esi,cxPels
        mov     ebx,xSrc
        mov     edx,xDst

        mov     eax,iFormat
        dec     eax
        jz      preproc_1bpp
        dec     eax
        jz      preproc_4bpp
        .errnz  BMF_1BPP-1
        .errnz  BMF_4BPP-2
        .errnz  BMF_8BPP-3

; Destination is 8bpp.  Copy will be phased aligned from the conversion buffer
; to the destination.

preproc_8bpp:
        add     pjDst,edx               ;Offset to first pel in DIB
        and     ebx,7                   ;Offset to first pel for final copy
        mov     cjSkip,ebx
        mov     cCopy,esi               ;Number of bytes for final copy
        lea     eax,aj8bpp              ;Intermediate work area
        mov     pjWork,eax
        mov     pfnXlate,offset FLAT:cvt_to_8bpp
        jmp     preproc_done


; Destination is 4bpp.  Copy will either be phase aligned or be off by 4 in
; which case we will phase align the entire buffer before copying.

preproc_4bpp:
        lea     eax,[esi][edx]          ;Compute rhs for later
        test    dl,1                    ;Odd if left mask needed
        jz      @F
        mov     jLeftMask,11110000b
        dec     esi                     ;One less pel in inner loop
@@:
        test    al,1                    ;Odd if right mask needed
        jz      @F
        mov     jRightMask,00001111b
        dec     esi                     ;One less pel in inner loop
@@:

        and     ebx,7                   ;Offset for final copy is xSrc mod 8

; If the source and destination have different alignments, we'll have to
; compute phase alignment stuff.

        mov     eax,ebx
        xor     eax,edx
        shr     eax,1
        jnc     @F
        mov     eax,cjScreenCopy        ;* 4 for size of data in buffer
        shl     eax,2
        inc     eax                     ;+ 1 to shift into last byte!
        mov     cjRightShift,eax
        mov     cRightShift,4           ;Shift entire buffer right 4 pels
        inc     ebx                     ;First pel just moved right
@@:

; Finish calculating the other parameters

        shr     edx,1                   ;Offset to first pel in DIB
        add     pjDst,edx
        shr     ebx,1
        mov     cjSkip,ebx
        shr     esi,1
        mov     cCopy,esi               ;# of inner bytes for final copy

        mov     eax,offset FLAT:copy_to_dest;Assume no color translation needed
        cmp     pulXlate,0
        je      @F
        mov     eax,offset FLAT:cvt_to_4bpp ;Addreess of color xlate routine
@@:
        mov     pfnXlate,eax
        jmp     preproc_done


; Destination is 1bpp.  Copy most likely will require masking and phase
; alignment.

preproc_1bpp:
        mov     edi,00000007h           ;A handy mask used a lot
        xor     ecx,ecx                 ;CL = lhs mask, CH = rhs mask
        lea     eax,[esi][edx]          ;Compute rhs for later
        test    edx,edi                 ;See if partial byte
        jz      preproc_1bpp_done_lhs   ;No partial lhs byte
        mov     ecx,edx
        neg     ecx
        and     ecx,edi                 ;CL = # bits in lhs, CH = 0
        sub     esi,ecx                 ;Compute # remaining bytes
        mov     cl,ajLeftMasks[ecx]     ;Get lhs mask
        jnc     preproc_1bpp_done_lhs   ;Didn't combine into one byte
        and     eax,edi                 ;Combine rhs mask with lhs mask
        and     cl,ajRightMasks[eax]
        xor     esi,esi                 ;No more bytes
        xor     eax,eax                 ;To show no rhs
        jmp     short preproc_1bpp_have_masks

preproc_1bpp_done_lhs:
        and     eax,edi                 ;See if partial rhs byte
        jz      preproc_1bpp_have_masks ;No partial rhs byte
        mov     ch,ajRightMasks[eax]
        sub     esi,eax                 ;Compute # remaining bytes

preproc_1bpp_have_masks:
        mov     jLeftMask,cl            ;Set left and right masks
        mov     jRightMask,ch
        shr     esi,3                   ;# of inner bytes for final copy
        mov     cCopy,esi

; Compute offset to first byte in destination DIB

        mov     eax,edx
        shr     eax,3
        add     pjDst,eax

; Compute phase alignment parameters

        xor     ecx,ecx                 ;Assume cjSkip is 0
        and     edx,edi
        and     ebx,edi
        sub     edx,ebx                 ;Determine phase alignment
        jz      preproc_finish_1bpp     ;No phase alignment needed

; We're really shifting left, so we'll set it up to shift right a lot, and
; get the first byte of the final move from byte 1 of the work area.

        adc     ecx,ecx                 ;Set cjSkip = 0 or 1
        and     edx,edi                 ;3 LSBs is shift count
        mov     cRightShift,dl          ;Phase for the shift
        mov     eax,cjScreenCopy        ;Size of data in buffer
        inc     eax                     ;+ 1 to shift into last byte!
        mov     cjRightShift,eax
preproc_finish_1bpp:
        mov     cjSkip,ecx              ;No skipping needed
        mov     esi,pulXlate            ;Copy color translation table to the
        lea     edi,ajColorConv         ;  frame because we are out of regs.
        mov     ecx,16
@@:
        lodsd
        stosb
        dec     ecx
        jnz     @B

        mov     pfnXlate,offset FLAT:cvt_to_1bpp

preproc_done:

process_next_scan:

        mov     edi,offset FLAT:ajConvertBuffer
        mov     edx,EGA_BASE + GRAF_ADDR
        mov     eax,GRAF_READ_MAP

copy_planes_012:
        mov     esi,pjSrc               ;ESI --> first Source byte
        out     dx,ax                   ;Set read plane
        mov     ecx,cjScreenCopy        ;Set number of bytes to read
        mov     ebx,edi
        rep     movsb
        lea     edi,[ebx][CJ_WORK_PLANE];EDI --> next scan in convert buf
        inc     ah                      ;Set next read plane

        mov     esi,pjSrc               ;ESI --> first Source byte
        out     dx,ax                   ;Set read plane
        mov     ecx,cjScreenCopy        ;Set number of bytes to read
        mov     ebx,edi
        rep     movsb
        lea     edi,[ebx][CJ_WORK_PLANE];EDI --> next scan in convert buf
        inc     ah                      ;Set next read plane

        mov     esi,pjSrc               ;ESI --> first Source byte
        out     dx,ax                   ;Set read plane
        mov     ecx,cjScreenCopy        ;Set number of bytes to read
        mov     ebx,edi
        rep     movsb
        lea     edi,[ebx][CJ_WORK_PLANE];EDI --> next scan in convert buf
        inc     ah                      ;Set next read plane

copy_plane_3:
        mov     esi,pjSrc               ;ESI --> first Source byte
        out     dx,ax                   ;Set read plane
        mov     ecx,cjScreenCopy        ;Set number of bytes to read
        mov     ebx,edi

;-----------------------------------------------------------------------;
; [BUGFIX] - byte reads from plane 3 of video memory must be done twice
;            on the VLB CL5434 or they don't always work
;-----------------------------------------------------------------------;

        ;---------------------------------------
        ; do a "movsb" with double reads
        ; was  "rep movsb"

        push    eax
        ; any more bytes to copy?
next_byte:
        dec     ecx
        jl      done_movs
        mov     al,[esi]
        mov     al,[esi]
        mov     [edi],al
        inc     edi
        inc     esi
        jmp     next_byte
        ; done with "movsb"
done_movs:
        sub     ecx,ecx
        pop     eax
        ;---------------------------------------

; The scan has been read in from the VGA.  Convert it into 4bpp format which
; will be needed for doing the color conversion.

        lea     edi,ajWork              ;Convert dwords into here
        mov     esi,offset FLAT:ajConvertBuffer
        mov     ecx,cjScreenCopy        ;# of source bytes to convert

cvt_next_src_byte:
        xor     eax,eax
        mov     al,[esi][CJ_WORK_PLANE*3]   ;Get data for plane C3
        mov     ebx,eax
        and     ebx,00001111b
        shr     eax,4
        mov     edx,aulHi16[ebx*4]
        or      dx,ausLo16[eax*2]
        shl     edx,1
        mov     al,[esi][CJ_WORK_PLANE*2]   ;Get data for plane C2
        mov     ebx,eax
        and     ebx,00001111b
        shr     eax,4
        or      edx,aulHi16[ebx*4]
        or      dx,ausLo16[eax*2]
        shl     edx,1
        mov     al,[esi][CJ_WORK_PLANE*1]   ;Get data for plane C1
        mov     ebx,eax
        and     ebx,00001111b
        shr     eax,4
        or      edx,aulHi16[ebx*4]
        or      dx,ausLo16[eax*2]
        shl     edx,1
        lodsb                               ;Get data for plane C0
        mov     ebx,eax
        and     ebx,00001111b
        shr     eax,4
        or      edx,aulHi16[ebx*4]
        or      dx,ausLo16[eax*2]
        mov     eax,edx
        stosd                               ;8 pels down!
        dec     ecx
        jnz     cvt_next_src_byte


; Perform the format conversion
        mov     ecx,cjScreenCopy        ;Set lopp count
        lea     esi,ajWork              ;Set source pointer
        mov     edi,pjWork              ;Set destination pointer
        mov     ebx,pulXlate            ;Set color translate vector
        xor     eax,eax                 ;Init D31:D8 to 0
        jmp     pfnXlate                ;Invoke correct conversion routine

; Convert from 4bpp to 8bpp with color translation

cvt_to_8bpp:
        lodsb                           ;Get two nibbles worth
        mov     edx,eax
        shr     eax,4
        and     edx,00001111b
        mov     al,[ebx][eax*4]
        stosb
        mov     al,[ebx][edx*4]
        stosb
        lodsb                           ;Get two nibbles worth
        mov     edx,eax
        shr     eax,4
        and     edx,00001111b
        mov     al,[ebx][eax*4]
        stosb
        mov     al,[ebx][edx*4]
        stosb
        lodsb                           ;Get two nibbles worth
        mov     edx,eax
        shr     eax,4
        and     edx,00001111b
        mov     al,[ebx][eax*4]
        stosb
        mov     al,[ebx][edx*4]
        stosb
        lodsb                           ;Get two nibbles worth
        mov     edx,eax
        shr     eax,4
        and     edx,00001111b
        mov     al,[ebx][eax*4]
        stosb
        mov     al,[ebx][edx*4]
        stosb
        dec     ecx
        jnz     cvt_to_8bpp
        jmp     copy_to_dest

; Convert from 4bpp to 4bpp with color translation.

cvt_to_4bpp:
        lodsb                           ;Get two nibbles worth
        mov     edx,eax
        shr     eax,4
        and     edx,00001111b
        mov     al,[ebx][eax*4]
        shl     al,4
        or      al,[ebx][edx*4]
        stosb
        lodsb                           ;Get two nibbles worth
        mov     edx,eax
        shr     eax,4
        and     edx,00001111b
        mov     al,[ebx][eax*4]
        shl     al,4
        or      al,[ebx][edx*4]
        stosb
        lodsb                           ;Get two nibbles worth
        mov     edx,eax
        shr     eax,4
        and     edx,00001111b
        mov     al,[ebx][eax*4]
        shl     al,4
        or      al,[ebx][edx*4]
        stosb
        lodsb                           ;Get two nibbles worth
        mov     edx,eax
        shr     eax,4
        and     edx,00001111b
        mov     al,[ebx][eax*4]
        shl     al,4
        or      al,[ebx][edx*4]
        stosb
        dec     ecx
        jnz     cvt_to_4bpp
        jmp     copy_to_dest


; Convert from 4bpp to 1bpp with color translation.


cvt_to_1bpp:
        lodsb                           ;Get two nibbles worth
        mov     edx,eax
        shr     eax,4
        and     edx,00001111b
        mov     bl,ajColorConv[eax]
        shl     bl,1
        or      bl,ajColorConv[edx]
        lodsb
        mov     edx,eax
        shr     eax,4
        and     edx,00001111b
        shl     bl,1
        or      bl,ajColorConv[eax]
        shl     bl,1
        or      bl,ajColorConv[edx]
        lodsb                           ;Get two nibbles worth
        mov     edx,eax
        shr     eax,4
        and     edx,00001111b
        shl     bl,1
        or      bl,ajColorConv[eax]
        shl     bl,1
        or      bl,ajColorConv[edx]
        lodsb                           ;Get two nibbles worth
        mov     edx,eax
        shr     eax,4
        and     edx,00001111b
        shl     bl,1
        or      bl,ajColorConv[eax]
        shl     bl,1
        or      bl,ajColorConv[edx]
        mov     al,bl
        stosb
        dec     ecx
        jnz     cvt_to_1bpp


; Copy to the destination.  This unfortunately may involve phase alignment

copy_to_dest:
        movzx   ecx,cRightShift
        jecxz   copy_aligned_to_dest
        mov     edi,pjWork
        mov     ebx,cjRightShift
phase_align_it:
        mov     ah,dl                   ;Get previous unused bits
        mov     al,byte ptr [edi]
        mov     dl,al
        shr     eax,cl
        stosb
        dec     ebx
        jnz     phase_align_it

copy_aligned_to_dest:
        mov     esi,pjWork
        add     esi,cjSkip
        mov     edi,pjDst

        mov     dl,jLeftMask
        or      dl,dl
        jz      @F
        lodsb
        mov     ah,byte ptr [edi]
        xor     ah,al
        and     ah,dl
        xor     al,ah
        stosb
@@:
        mov     ecx,cCopy
        rep     movsb

        mov     dl,jRightMask
        or      dl,dl
        jz      @F
        lodsb
        mov     ah,byte ptr [edi]
        xor     ah,al
        and     ah,dl
        xor     al,ah
        stosb
@@:

        mov     eax,ulScanWidth
        add     pjSrc,eax
        mov     eax,lDelta
        add     pjDst,eax
        dec     cyScans
        jnz     process_next_scan

        PLAIN_RET       ;we're done with this bank

xxxvConvertVGA2DIB endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\devdata.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: devdata.inc
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

; Instructions used in the compiler.  Word quantities have already been
; swapped so that they come out correctly when stored.

I_ADD_AL_BYTE_I         equ       004h      ; ADD   al,12h
I_ADD_EDI_DWORD_I       equ     0C781h      ; ADD   edi,12345678h
I_ADD_ESI_DWORD_I       equ     0C681h      ; ADD   esi,12345678h
I_AND_AL_BYTE_I         equ       024h      ; AND   al,12h
I_AND_AL_MEM            equ     00522h      ; AND   al,[byteaddr]
I_CALL_DISP32           equ       0E8h      ; CALL  12345678h
I_DEC_ECX               equ       049h      ; DEC   ecx
I_DEC_ESI_DEC_EDI       equ     04F4Eh      ; DEC   esi
                                            ; DEC   edi
I_INC_ESI_INC_EDI       equ     04746h      ; INC   esi
                                            ; INC   edi
I_JMP_DISP32            equ       0E9h      ; JMP   12345678h
I_JNC_DISP32            equ     0830Fh      ; JNC   $+12345678h
I_JNZ_DISP32            equ     0850fh      ; JNZ   $+12345678h
I_LODSB                 equ       0ACh      ; LODSB
I_LOOP                  equ       0E2h      ; LOOP  $
I_MOVSB                 equ       0A4h      ; MOVSB
I_MOV_AH_AL             equ     0E08Ah      ; MOV   ah,al
I_MOV_AH_DEST           equ     0278Ah      ; MOV   ah,[edi]
I_MOV_AH_ESI_DISP32     equ     0A68Ah      ; MOV   ah,12345678h[esi]
I_MOV_AL_0FFH           equ     0FFB0h      ; MOV   al,0FFH
I_MOV_AL_DH             equ     0C68Ah      ; MOV   al,dh
I_MOV_AL_ESI_DISP32     equ     0868Ah      ; MOV   al,12345678h[esi]
I_MOV_AL_MEM            equ       0A0h      ; MOV   al,[byteaddr]
I_MOV_BL_BYTE_I         equ       0B3h      ; MOV   bl,12h
I_MOV_DH_EBX_DISP8      equ     0738Ah      ; MOV   dh,12h[ebx]
I_MOV_EBP_DWORD_I       equ       0BDh      ; MOV   ebp,12345678h
I_MOV_EBX_DWORD_I       equ       0BBh      ; MOV   ebx,12345678h
I_MOV_ECX_DWORD_I       equ       0B9h      ; MOV   ecx,12345678h
I_MOV_EDX_DWORD_I       equ       0BAh      ; MOV   ecx,12345678h
I_MOV_MEM_AL            equ       0A2h      ; MOV   [byteaddr],al

I_NEG_DH                equ     0DEF6h      ; NEG   dh
I_NOT_AL                equ     0D0F6h      ; NOT   al
I_OR_AH_AL              equ     0E00Ah      ; OR    ah,al
I_OR_AL_AH              equ     0C40Ah      ; OR    al,ah
I_POP_EBX               equ       05Bh      ; POP   ebx
I_POP_EDI_POP_ECX       equ     0595Fh      ; POP   edi
                                            ; POP   ecx
I_POP_ESI               equ       05Eh      ; POP   esi
I_PUSH_EBX              equ       053h      ; PUSH  ebx
I_PUSH_ECX_PUSH_EDI     equ     05751h      ; PUSH  ecx
                                            ; PUSH  edi
I_PUSH_ESI              equ       056h      ; PUSH  esi
I_REP                   equ       0F3h      ; REP
I_RET                   equ       0C3h      ; RET
I_ROL_AL_N              equ     0C0C0h      ; ROL   al,2
I_ROR_AL_N              equ     0C8C0h      ; ROR   al,2
I_SETNZ_DH              equ   0C6950Fh      ; SETNZ dh
I_SHL_BL_1              equ     0E3D0h      ; SHL   bl,1
I_SIZE_OVERRIDE         equ       066h      ; size override
I_STOSB                 equ       0AAh      ; STOSB
I_TEST_BL_BYTE_I        equ     0C3F6h      ; TEST  bl,12h
I_XOR_AL_BYTE_I         equ       034h      ; XOR   al,12h
I_XOR_AL_MEM            equ     00532h      ; XOR   al,[byteaddr]
I_XOR_BH_BH             equ     0FF32h      ; XOR   BH,BH

; The following instructions require that I_SIZE_OVERRIDE preceed them

I_MOVSW                 equ       0A5h      ; MOVSW
I_MOV_BP_WORD_I         equ       0BDh      ; MOV   bp,1234h
I_NOT_AX                equ     0D0F7h      ; NOT   ax
I_STOSW                 equ       0ABh      ; STOSW
I_XOR_AX_WORD_I         equ       035h      ; XOR   ax,12h
I_XOR_EAX_EAX           equ     0C033h      ; xor eax, eax


;-----------------------------------------------------------------------;
; phase_align - Template for phase alignment code
;
; The following code is the template that performs the phase
; alignment masking.  The source has already been aligned to
; the destination.
;
; A copy of the aligned source is made.  The phase mask is then
; applied to the source and the copy.  The previously unused
; bits are ORed into the used bits of the current source, and
; the unused bits of the current source then become the unused
; bits for the next source.
;
; It assumes:
;         BP  =  phase alignment mask
;         AL  =  current byte to mask
;         BH  =  old unused bits
;-----------------------------------------------------------------------;

phase_align:
        mov     ah,al                   ;Make a copy of aligned source
        and     ax,bp                   ;Masked used, unused bits
        or      al,bh                   ;Mask in old unused bits
        mov     bh,ah                   ;Save new unused bits

PHASE_ALIGN_LEN equ     $-phase_align   ;Length of procedure


;-----------------------------------------------------------------------;
;       masked_store - Template for storing first and last bytes of BLT
;
;       The following code is a template for storing the first and last
;       bytes of a BLT.  The unaltered bits are saved and the altered
;       bits set in the byte, then the byte is stored.
;
;
;       It assumes:
;
;               AL  =  The byte to be BLTed to the destination bitmap.
;                      All necessary logic operations have been performed
;                      on this byte.
;
;               AH  =  The destination byte.
;
;-----------------------------------------------------------------------;

masked_store:
        and     ax,05352h               ;Mask altered/unaltered bits
        or      al,ah                   ;Combine the bits
        stosb                           ;And store the result

MASKED_STORE_LEN        equ     $-masked_store  ;Length of the template
MASKED_STORE_MASK       equ     -5              ;Offset to where mask goes


;-----------------------------------------------------------------------;
; EGA Color Plane Setup Code
;
; The EGA Color Plane Setup Code is used when the EGA is involved
; in the BLT, and the BLT isn't from the EGA to a monochrome bitmap.
;
; The template will be copied, and any required fixups will be
; performed.  The very first instruction will be generated on
; the fly instead of being copied and fixed-up.
;
; It assumes:
;         BL = MapMask value
;-----------------------------------------------------------------------;

cps:
        mov     al,MM_ALL               ;Set Map Mask
        and     al,bl                   ;Isolate the plane
        mov     dx,EGA_BASE + SEQ_DATA
        out     dx,al
        shr     al,1                    ;Map plane into ReadMask
        cmp     al,100b                 ;Set Carry if not C3 (plane 3)
        adc     al,-1                   ;Sub 1 only if C3
        mov     ah,al
        mov     al,GRAF_READ_MAP
        mov     dl,GRAF_ADDR
        out     dx,ax

LENGTH_CPS      =       $ - cps         ;Length of the code


;-----------------------------------------------------------------------;
; Mono ==> Color Fetch Code
;
; The mono ==> color fetch code is generated when the source
; is a monochrome bitmap and the destination is color.
;
; When going from mono to color, 1 bits are considered to be
; the background color, and 0 bits are considered to be the
; foreground color.
;
; For each plane:
;
;   If the foreground=background=1, then 1 can be used in
;   place of the source.
;
;   If the foreground=background=0, then 0 can be used in
;   place of the source.
;
;   If the foreground=0 and background=1, then the source
;   can be used as is.
;
;   If the foreground=1 and background=0, then the source
;   must be complemented before using.
;
; A table will be created for processing the monochrome
; bitmap for each plane of the destination.  The table
; should look like:
;
;      BackGnd   ForeGnd    Result    AND  XOR
;         1         1         1        00   FF
;         0         0         0        00   00
;         1         0         S        FF   00
;         0         1     not S        FF   FF
;
; From this, it can be seen that the XOR mask is the same as the
; foreground color.  The AND mask is the XOR of the foreground
; and the background color.
;
; It can also be seen that if the background color is white and the
; foreground (text) color is black, then the conversion needn't be
; generated (it just gives the source).
;
; The template for rotating the AND and XOR table for the plane
; select code is also shown.  It just does a three word rotate
; on the AND and XOR masks on the stack.  It is performed at the
; end of a scan in anticipation of the next color for that scan.
;
;     lodsb                           ;Get next byte of source
;     and     al,byte ptr ss:[1234h]  ;Process against current AND
;     xor     al,byte ptr ss:[1234h]  ;  and XOR masks
;-----------------------------------------------------------------------;

rot_and_xor:
;       lea     ebp,ColorMungeTBl           ;--> AND/XOR masks
        mov     eax,dword ptr [ebp+0]       ;Rotate next color's AND and
        ror     eax,16                      ; XOR mask into place
        mov     word ptr [ebp+0],ax
        mov     ax,word ptr [ebp+4]
        mov     word ptr [ebp+2],ax
        mov     ax,word ptr [ebp+6]
        mov     dword ptr [ebp+4],eax

LEN_ROT_AND_XOR =   $-rot_and_xor
        page


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\cmacflat.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: cmacflat.inc
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------macro-----------------------------------
;
; errnz exp - generate error message if expression isn't zero
;
; The errnz will generate an error message if the expression "exp"
; does not evaluate to zero.  This macro is very useful for testing
; relationships between items, labels, and data that was coded into
; an application.
;
;       errnz   <offset $ - offset label>   ;error if not at "label"
;       errnz   <eofflag and 00000001b>     ;eofflag must be bit 0
;
; For expressions involving more than one token, the angle brackets
; must be used.
;
; The macro is only evaluated on pass 2, so forward references may be
; used in the expression.
;---------------------------------------------------------------------------

if	@Version GE 600

errnz macro x                           ;;display error if expression is <>0
  if2
    .errnz (x),<x>
  endif
endm

else	;!(@Version GE 600)

errnz macro x                           ;;display error if expression is <>0
  if2
    if x                                ;;if expression is non-zero,
      errnz1  <x>,%(x)
    endif
  endif
endm

errnz1 macro x1,x2
  = *errnz* x1 = x2
  .err
endm

endif	;!(@Version GE 600)


;-----------------------------------macro-----------------------------------
;
; errn$ label,exp - generate error message if label (exp) <> $
;
; The errnz will generate an error message if the label and "exp"
; does not evaluate to the current value of the location counter.
; This macro is very useful for testing relationships between
; labels and the location counter that was coded into an application.
;
; examples:  errn$   label        ;error if not at "label"
;            errn$   label,+3     ;error if not three bytes from "label"
;            errn$   label,-3     ;error if not three bytes past "label"
;
; If no "exp" is given, it is the same as specifying 0
;
; The macro is only evaluated on pass 2, so forward references may be
; used in the expression.
;---------------------------------------------------------------------------

errn$ macro l,x                         ;;error if <$-label1 (exp2)> <>0
  errnz   <offset $ - offset l x>
endm


;-----------------------------------macro-----------------------------------
;
; useframe - generate "loc" and arg macros for accessing locals on the frame
;
; usage:    useframe name
;
;           name: name of the frame to be used
;
; useloc generates text equates which are used for accessing locals and
; parameters on the current frame, based off of EBP.
;
; The locals and parameters are each defined as a structure with the name
; parm_<name> and loc_<name>.  What is generated is text equates of the form
;
;       parm    equ <([ebp + 8])>
;   and
;       loc     equ <([ebp + sizof(loc_name))>
;
; This implies some things of interest:
;
;   1)  The calling convention is implied to be that of C.  For PASCAL calling
;       convention, the parm_ structure must be reordered.  This can be
;       accomplished by using the create_parm macro which will define the
;       structure in the correct order for the calling convention
;
;   2)  The loc_name structure should have the most commonly accessed variables
;       listed last in the structure so that the end up with the smalled offset,
;       and possibly a single byte displacement in the instruction.
;
;   3)  A frame which looks like
;
;           ---------------------
;           |                   |
;           |   parameters      |
;           |                   |
;           ---------------------   <--- EBP + 8
;           |                   |
;           |   ret addr        |
;           |                   |
;           ---------------------
;           |                   |
;           |   old EBP         |
;           |                   |
;           ---------------------   <--- EBP
;           |                   |
;           |   locals          |
;           |                   |
;           ---------------------
;           |                   |
;           |   saved regs      |
;           |                   |
;           ---------------------
;
; Once defined, frame variables can be accessed simply by parm.strucname or
; loc.strucname.
;---------------------------------------------------------------------------


useframe macro name
  ifdef parm_&name
    parm equ <([ebp + 8])>
  else
    parm equ <>
  endif
  ifdef loc_&name
    useframe1 %(((size loc_&name) + 3) and (not 3))
  else
    loc equ <>
  endif
endm

useframe1 macro size
  loc equ <([ebp - size])>
endm



;-----------------------------------macro-----------------------------------
;
; enterframe - builds the given frame
;
; usage:    enterframe name,<save list>
;
;           name:       name of the frame to generate
;           save list:  a list of 32 bit registers to be saved upon entry and
;                       restored upon exit (when leaveframe is encountered)
;
;
; enterframe builds the given frame upon the stack at the point it is
; encountered.  What is generated is the following:
;
;       enter   sizeof(loc_&name);
;       push    <save list>
;
; Once created, frame variables can be accessed simply by parm.strucname or
; loc.strucname.
;---------------------------------------------------------------------------


enterframe macro name,savelist
  useframe name
  ?cjFrame = 0
  ifdef ?PASCALConventions
    ifdef parm_&name
          ?cjFrame = size parm_&name
    endif
  endif
  ifdef loc_&name
        enter  (((size loc_&name) + 3) and (not 3)),0
  else
        enter   0,0
  endif
  ?regpoplist equ <>
  ifnb <&savelist>
    irp reg,<&savelist>
      ifnb <&&reg>
        push    &&reg
        ?regpoplist catstr <&&reg>,<,>,?regpoplist
      endif
    endm
  endif
endm



;-----------------------------------macro-----------------------------------
;
; leaveframe - removes the frame created by enterframe.
;
; usage:    leaveframe
;
;
; leaveframe restores saved registers, removes locals from the frame, and
; restores BP, and returns to the caller, optionally popping parameters
; from the stack.
;
; No invalidation of the loc and parm equates is performed.
;---------------------------------------------------------------------------


leaveframe macro
% irp reg,<?regpoplist>
    ifnb <&reg>
        pop     reg
    endif
  endm
        leave
        ret     ?cjFrame
endm


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\dfb2dfb.asm ===
;---------------------------Module-Header------------------------------;
;
; Module Name:  dfb2dfb.asm
;
; Copyright (c) 1993 Microsoft Corporation
;
;-----------------------------------------------------------------------;
;
; VOID vDFB2DFB(DEVSURF * pdsurfDst,
;               DEVSURF * pdsurfSrc,
;               RECTL * prclDst,
;               POINTL * pptlSrc);
;
; Performs accelerated copies from one DFB to another.
;
; pdsurfDst = pointer to dest surface
; pdsurfSrc = pointer to source surface
; prclDst =   pointer to rectangle describing target area of dest. DFB
; pptlSrc =   pointer to point structure describing the upper left corner
;             of the copy in the source DFB
;
;-----------------------------------------------------------------------;
;
; Note: Assumes the destination rectangle has a positive height and width.
;       Will not work properly if this is not the case.
;
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc

        .list

;-----------------------------------------------------------------------;

        .data

extrn   dfb_jLeftMasks:dword        ; identical static table to DFB2VGA, so use it.
extrn   dfb_jRightMasks:dword       ; identical static table to DFB2VGA, so use it.
extrn   dfb_pfnScanHandlers:dword   ; identical static table to DFB2VGA, so use it.


;-----------------------------------------------------------------------;

                .code

_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;-----------------------------------------------------------------------;

cProc vDFB2DFB,16,<             \
        uses esi edi ebx,       \
        pdsurfDst: ptr DEVSURF, \
        pdsurfSrc: ptr DEVSURF, \
        prclDst: ptr RECTL,     \
        pptlSrc : ptr POINTL    >

        local   pfnDrawScans:dword       ;ptr to correct scan drawing function
        local   pSrc:dword               ;pointer to working drawing src start
                                         ; address (either DFB or temp buffer)
        local   pDst:dword               ;pointer to drawing dst start address
                                         ; copy are to be performed, as follows:
        local   sDfbInfo[size DFBBLT]:byte


TRAILING_PARTIAL        equ     01h      ;partial trailing word should be copied
LEADING_PARTIAL         equ     02h      ;partial leading word should be copied
SOME_SHIFT_NEEDED       equ     04h      ;either right or left shift needed
LEFT_SHIFT_NEEDED       equ     08h      ;required shift is to the left

;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Point to the source start address (nearest dword equal or less).
;-----------------------------------------------------------------------;

        mov     ebx,pptlSrc             ;point to coords of source upper left
        mov     esi,pdsurfSrc           ;point to surface to copy from (DFB)
        mov     edi,pdsurfDst           ;point to surface to copy to (DFB)
        mov     eax,[ebx].ptl_y
        imul    eax,[esi].dsurf_lNextScan ;offset in bitmap of top src rect scan
        mov     edx,[ebx].ptl_x
        shr     edx,3                   ;source byte X address
        and     edx,not 1b              ;round down to nearest word
        add     eax,edx                 ;offset in bitmap of first source word
        add     eax,[esi].dsurf_pvBitmapStart ;pointer to first source word
        mov     pSrc,eax
        sub     eax,eax
        mov     pDst,eax                ;Init it to zero

;-----------------------------------------------------------------------;
; Set up various variables for the copy.
;
; At this point, EBX = pptlSrc, EDI = pdsurfDst.
;-----------------------------------------------------------------------;

        mov     esi,prclDst             ;point to rectangle to which to copy
        sub     ecx,ecx                 ;accumulate copy control flags
        mov     eax,[esi].xLeft         ;first, check for partial-word edges
        and     eax,1111b               ;left edge pixel alignment
        jz      short @F                ;whole byte, don't need leading mask
        or      ecx,LEADING_PARTIAL     ;do need leading mask
@@:
        mov     edx,dfb_jLeftMasks[eax*4] ;mask to apply to source to clip
        mov     sDfbInfo.LeftMask,edx     ;remember mask

        mov     eax,[esi].xRight
        and     eax,1111b               ;right edge pixel alignment
        jz      short @F                ;whole byte, don't need trailing mask
        or      ecx,TRAILING_PARTIAL    ;do need trailing mask
@@:
        mov     edx,dfb_jRightMasks[eax*4] ;mask to apply to source to clip
        mov     sDfbInfo.RightMask,edx     ;remember mask



dfb2dfb_detect_partials::
        mov     sDfbInfo.DstWidth,0 ;overwritten if any whole words
                                        ;now, see if there are only partial
                                        ; words, or maybe even only one partial
        mov     eax,[esi].xLeft
        add     eax,1111b
        and     eax,not 1111b           ;round left up to nearest word
        mov     edx,[esi].xRight
        and     edx,not 1111b           ;round right down to nearest word
        sub     edx,eax                 ;# of pixels, rounded to nearest word
                                        ; boundaries (not counting partials)
        ja      short dfb2dfb_check_whole_words ;there's at least one whole word
                                        ;there are no whole words; there may be
                                        ; only one partial word, or there may
                                        ; be two


        jb      short dfb2dfb_one_partial_only  ;there is only one, partial word
                                        ;if the dest is left- or right-
                                        ; justified, then there's only one,
                                        ; partial word, otherwise there are two
                                        ; partial words
        cmp     dword ptr sDfbInfo.LeftMask,0ffffh ;left-justified in word?
        jz      short dfb2dfb_one_partial_only  ;yes, so only one, partial word
        cmp     dword ptr sDfbInfo.RightMask,0ffffh ;right-justified in word?
        jnz     short dfb2dfb_set_copy_control_flags ;no, so there are two partial
                                             ; words, which is exactly what
                                             ; we're already set up to do



dfb2dfb_one_partial_only::              ; only one, partial word, so construct a
                                        ; single mask and set up to do just
                                        ; one, partial word
        mov     eax,sDfbInfo.LeftMask
        and     eax,sDfbInfo.RightMask         ;intersect the masks
        mov     sDfbInfo.LeftMask,eax
        mov     ecx,LEADING_PARTIAL     ;only one partial word, which we'll
                                        ; treat as leading
        jmp     short dfb2dfb_set_copy_control_flags ;the copy control flags are set

dfb2dfb_check_whole_words::
                                        ;finally, calculate the number of whole
                                        ; words  we'll process
        mov     eax,[esi].xLeft
        add     eax,1111b
        shr     eax,4                   ;round left up to nearest word
        mov     edx,[esi].xRight
        shr     edx,4                   ;round down to nearest word
        sub     edx,eax                 ;# of whole aligned words
        
        mov     sDfbInfo.DstWidth,edx ;save count of whole words

dfb2dfb_set_copy_control_flags::

;       mov     ulCopyControlFlags,ecx

;-----------------------------------------------------------------------;
; Determine whether any shift is needed to align the source with the
; destination.
;
; At this point, EBX = pptlSrc, ECX = Copy Control Flags
;                ESI = prclDst, EDI = pdsurfDst.
;-----------------------------------------------------------------------;

        mov     edx,[ebx].ptl_x
        and     edx,1111b               ;source X modulo 16
        mov     eax,[esi].xLeft
        and     eax,1111b               ;dest X modulo 16
        sub     eax,edx                 ;(dest X modulo 16) - (src X modulo 16)

;-----------------------------------------------------------------------;
; Start optimization for byte aligned cases.  Code works without this
;-----------------------------------------------------------------------;

        cmp     eax,8
        jne     short @F
        ;
        ; Src starts in lower byte, Dst starts in upper byte
        ;
        dec     pSrc                    ;add unused first byte to src
        sub     eax,eax                 ;set alignment = 0
        jmp     dfb2dfb_done_with_byte_aligned_optimze
@@:
        cmp     eax,-8
        jne     short @F
        ;
        ; Src starts in upper byte, Dst starts in lower byte
        ;
        inc     pSrc                    ;remove unused first byte of src
        sub     eax,eax                 ;set alignment = 0
@@:
dfb2dfb_done_with_byte_aligned_optimze:

;-----------------------------------------------------------------------;
; End optimization for byte aligned cases.
;-----------------------------------------------------------------------;

        mov     sDfbInfo.AlignShift,eax ;remember the shift

;-----------------------------------------------------------------------;
; Set pfnDrawScans to appropriate function:
;
; 0 0 ... 0 0 1 1 1 1
;             | | | |______   trailing partial   
;             | | |________   leading partial   
;             |_|__________   align index     00 - no align needed
;                                             01 - right shift needed
;                                             10 - invalid
;                                             11 - left shift needed
;
;-----------------------------------------------------------------------;
                                
        cmp     sDfbInfo.AlignShift,0

        je      short no_shift          ;flags set by sub above
        jg      short @F
        or      ecx,LEFT_SHIFT_NEEDED   ;shl required
        neg     sDfbInfo.AlignShift     ;take absolute value
@@:
        or      ecx,SOME_SHIFT_NEEDED   ;shl or shr required

no_shift:
        mov     edx,dfb_pfnScanHandlers[ecx*4] ;proper drawing handler
        mov     pfnDrawScans,edx


;-----------------------------------------------------------------------;
; Set up the offsets to the next source and destination scans.
;
; At this point, EBX = pptlSrc, ESI = prclDst, EDI = pdsurfDst.
;-----------------------------------------------------------------------;

        mov     eax,[esi].xLeft
        shr     eax,4           ;index of first word (including partial)
        mov     edx,[esi].xRight
        add     edx,1111b        
        shr     edx,4           ;index following last word
        sub     edx,eax         ;# of words across dest rectangle
        add     edx,edx         ;# of bytes across dest rectangle
        mov     eax,[edi].dsurf_lNextPlane ;# of bytes across 1 scan of dest
        sub     eax,edx         ;offset from last byte dest copied to on one
        mov     ecx,pdsurfSrc
        mov     sDfbInfo.DstDelta,eax  ; scan to first dest byte copied to on next
            
        ;
        ; use # bytes across dst rect to calculate ulSrcDelta
        ; the src ptr is incremented at the same time as the
        ; dst ptr
        ;

        mov     eax,[ecx].dsurf_lNextPlane
        sub     eax,edx                ;offset from end of one src scan to 
        mov     sDfbInfo.SrcDelta,eax  ; start of next

;-----------------------------------------------------------------------;
; At this point, ESI = prclDst, EDI = pdsurfDst
;-----------------------------------------------------------------------;

        mov     eax,[esi].yTop          ;top scan of copy
        imul    eax,[edi].dsurf_lNextScan ;offset of starting scan line
        mov     edx,[esi].xLeft         ;left dest X coordinate
        shr     edx,3                   ;left dest byte offset in row
        and     edx,not 1               ;round down to word ptr
        add     eax,edx                 ;initial offset in dest bitmap
        add     eax,[edi].dsurf_pvBitmapStart ;initial dest bitmap address
        add     pDst,eax                ;remember where to start drawing
                
;-----------------------------------------------------------------------;
; At this point, EDI->pdsurfDst
;-----------------------------------------------------------------------;

; Calculate the # of scans to do

        mov     ebx,[esi].yBottom       ;bottom of destination rectangle
        sub     ebx,[esi].yTop          ;# of scans to copy

;-----------------------------------------------------------------------;
; Copy to the screen in bursts of ulPlaneScans scans.
;
; At this point, EBX = # of scans remaining.
;-----------------------------------------------------------------------;
             
dfb2dfb_proceed_with_copy::

;-----------------------------------------------------------------------;
; Copy the DFB scans
;-----------------------------------------------------------------------;

        mov     esi,pSrc
        mov     edi,pDst

        shl     ebx,2
        mov     sDfbInfo.BurstCountLeft,ebx
        mov     eax,pfnDrawScans
        push    ebp                     ;-----------------------------------
        lea     ebp,sDfbInfo            ;WARNING:
        call    eax                     ;ebp in use, pfnDrawScans is invalid
        pop     ebp                     ;-----------------------------------

        cRet    vDFB2DFB        ;done!

endProc vDFB2DFB



public dfb2dfb_detect_partials
public dfb2dfb_one_partial_only
public dfb2dfb_check_whole_words
public dfb2dfb_set_copy_control_flags
public dfb2dfb_proceed_with_copy

_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\dfb2dib.asm ===
;---------------------------Module-Header------------------------------;
;
; Module Name:  dfb2dib.asm
;
; Copyright (c) 1993 Microsoft Corporation
;
;-----------------------------------------------------------------------;
;
; VOID vDFB2DIB(DEVSURF * pdsurfDst,
;               DEVSURF * pdsurfSrc,
;               RECTL * prclDst,
;               POINTL * pptlSrc);
;
; Performs accelerated copies from a DFB to a DIB.
;
; pdsurfDst = pointer to dest surface
; pdsurfSrc = pointer to source surface
; prclDst =   pointer to rectangle describing target area of dest. DIB
; pptlSrc =   pointer to point structure describing the upper left corner
;             of the copy in the source DFB
;
;-----------------------------------------------------------------------;
;
; Note: Assumes the destination rectangle has a positive height and width.
;       Will not work properly if this is not the case.
;
;       This routine uses a 2K buffer on the stack
;
;-----------------------------------------------------------------------;

        .486

        .model  small,c

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc

        .list

;-----------------------------------------------------------------------;

        .data


;-----------------------------------------------------------------------;
; Masks to be applied to the source data for the 8 possible clip
; alignments.
;-----------------------------------------------------------------------;

dfb2dib_jLeftMasks      label   byte
        db      0ffh, 00fh

dfb2dib_jRightMasks     label   byte
        db      0ffh, 0f0h



;-----------------------------------------------------------------------;
; Translate table used to spread out a nibble to a WORD, with three
; blank spacer bits between each actual bit.
;-----------------------------------------------------------------------;

aXlate  label   dword
        dd      0000h,0800h,8000h,8800h,0008h,0808h,8008h,8808h
        dd      0080h,0880h,8080h,8880h,0088h,0888h,8088h,8888h



;-----------------------------------------------------------------------;
; Array of function pointers to handle leading and trailing bytes
;-----------------------------------------------------------------------;
pfnScanhandlers label   dword
        dd      draw_dfb2dib_scan_00
        dd      draw_dfb2dib_scan_01
        dd      draw_dfb2dib_scan_10
        dd      draw_dfb2dib_scan_11


;-----------------------------------------------------------------------;

                .code

_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT,ES:FLAT,SS:NOTHING,FS:NOTHING,GS:NOTHING

;-----------------------------------------------------------------------;

cProc vDFB2DIB,16,<             \
        uses esi edi ebx,       \
        pdsurfDst: ptr DEVSURF, \
        pdsurfSrc: ptr DEVSURF, \
        prclDst: ptr RECTL,     \
        pptlSrc : ptr POINTL    >

        local   ulSrcBytesWide:dword    ;src copy width (paritials included)
        local   ulDstBytesWide:dword    ;dst copy width (paritials included)
        local   ulSrcBytesPerPlane:dword ;# of bytes in a src scan line
        local   ulDstBytesPerScan:dword ;# of bytes in a dst scan line
        local   ulSrcDelta:dword        ;from end of src scan to start of next
        local   ulDstDelta:dword        ;from end of dst scan to start of next
        local   pSrc:dword              ;ptr to drawing src start
        local   pDst:dword              ;ptr to drawing dst start
        local   pBuf:dword              ;ptr to temp dst start (conversion buf)
        local   pfnCopy:dword           ;ptr to temp => DIB copy function
        local   ulSrcIntraByte:dword    ;src intra-byte index
        local   ulAlignShift:dword
        local   ulLeftMask:dword
        local   ulRightMask:dword
        local   ulThreePlanes:dword
        local   ulWidthInPixels:dword
        local   ulNumScans:dword
        local   ulNumScansLeft:dword
        local   ulLowWord:dword
        local   ulLastDword:dword
        local   aTempBuf[(MAX_SCAN_WIDTH/2)+16]:byte
                                        ;we need enough space to store the scan
                                        ; plus up to four dwords

;-----------------------------------------------------------------------;

        cld

;-----------------------------------------------------------------------;
; Point to the source start address (nearest dword equal or less).
;-----------------------------------------------------------------------;

begin_setup::

        mov     ebx,pptlSrc             ;point to coords of source upper left
        mov     edx,prclDst             ;point to rectangle to which to copy
        mov     esi,pdsurfSrc           ;point to surface to copy from (DFB4)
        mov     edi,pdsurfDst           ;point to surface to copy to (DIB4)

        mov     eax,[edi].dsurf_lNextScan
        mov     ulDstBytesPerScan,eax   ;set dest scan width
        mov     eax,[esi].dsurf_lNextPlane
        mov     ulSrcBytesPerPlane,eax   ;set source scan width

        lea     eax,[eax+2*eax]
        mov     ulThreePlanes,eax       ;ulThreePlanes = 3 * source scan width

        mov     eax,[ebx].ptl_y
        imul    eax,[esi].dsurf_lNextScan ;offset in bitmap of top src rect scan
        mov     ecx,[ebx].ptl_x
        shr     ecx,3                   ;source byte X address
        add     eax,ecx                 ;offset in bitmap of first source byte
        add     eax,[esi].dsurf_pvBitmapStart ;pointer to first source dword
        mov     pSrc,eax

        mov     eax,[edx].yTop
        imul    eax,ulDstBytesPerScan   ;offset in bitmap of top dst rect scan
        mov     ecx,[edx].xLeft
        shr     ecx,1                   ;dest byte X address
        add     eax,ecx                 ;offset in bitmap of first source dword
        add     eax,[edi].dsurf_pvBitmapStart ;pointer to first source dword
        mov     pDst,eax

        mov     eax,[edx].xRight
        sub     eax,[edx].xLeft
        mov     ulWidthInPixels,eax     ;save width in pixels

        mov     eax,[ebx].ptl_x         ;calculate src right
        add     eax,ulWidthInPixels     ;src right
        add     eax,111b
        shr     eax,3                   ;src right rounded up to byte
        mov     ecx,[ebx].ptl_x         ;src left edge
        shr     ecx,3                   ;src left rounded down to whole byte
        sub     eax,ecx

        inc     eax                     ;convert one extra byte in case we
                                        ; require a shift

        mov     ulSrcBytesWide,eax      ;# of bytes in src touched by copy

        mov     eax,[edx].xRight
        inc     eax
        shr     eax,1                   ;dst right rounded up to whole byte
        mov     ecx,[edx].xLeft
        shr     ecx,1                   ;dst left rounded down to whole byte
        sub     eax,ecx
        mov     ulDstBytesWide,eax      ;# of bytes in dst touched by copy

        mov     eax,ulSrcBytesPerPlane
        shl     eax,2
        sub     eax,ulSrcBytesWide
        mov     ulSrcDelta,eax

        mov     eax,ulDstBytesPerScan
        sub     eax,ulDstBytesWide
        mov     ulDstDelta,eax

        mov     eax,[edx].xLeft         ;get dst left edge
        and     eax,1b                  ;0 - byte aligned, 1 - not byte aligned
        mov     cl,dfb2dib_jLeftMasks[eax]  ;look up dst left mask
        mov     ch,cl                   ;store mask in cl
        not     ch                      ;store not mask in ch
        mov     ulLeftMask,ecx          ;save dst left mask

        mov     eax,[edx].xRight        ;get dst right edge
        and     eax,1b                  ;0 - byte aligned, 1 - not byte aligned
        mov     cl,dfb2dib_jRightMasks[eax] ;look up dst right mask
        mov     ch,cl                   ;store mask in cl
        not     ch                      ;store not mask in ch
        mov     ulRightMask,ecx         ;save dst right mask

        mov     ecx,[edx].xLeft         ;get left edge
        and     ecx,1                   ;1 - left partial, 0 - none
        sub     ulDstBytesWide,ecx      ;remove partials
        shl     ecx,1
        mov     eax,[edx].xRight        ;get right edge
        and     eax,1                   ;1 - right partial, 0 - none
        sub     ulDstBytesWide,eax      ;remove partials
        jge     @F
        mov     ulDstBytesWide,0        ;we must have had just 1 partial
@@:

        or      eax,ecx
        mov     ecx,pfnScanhandlers[eax*4]
        mov     pfnCopy,ecx             ;save ptr to appropriate copy function

        mov     eax,[edx].yBottom       ;get bottom scan
        mov     ecx,[edx].yTop          ;get top scan
        sub     eax,ecx
        mov     ulNumScans,eax          ;# of scans to copy

        mov     eax,[ebx].ptl_x
        xor     eax,[edx].xLeft
        and     eax,1                   ;eax = (0-aligned 1-nonaligned)
        mov     ulAlignShift,eax

        mov     eax,[ebx].ptl_x
        and     eax,111b                ;calculate src intra-byte index
        mov     ulSrcIntraByte,eax

;-----------------------------------------------------------------------;
; At this point, EBX = pptlSrc,         EDX = prclDst,
;                ESI = pdsurfSrc,       EDI = pdsurfDst
;-----------------------------------------------------------------------;

        mov     eax,ulNumScans
        mov     ulNumScansLeft,eax

        lea     esi,aTempBuf
        mov     pBuf,esi

do_scan_line::

        mov     ecx,ulSrcBytesWide
        mov     esi,pSrc
        mov     edi,pBuf

        cmp     ulAlignShift,0
        je      short @F
        xor     eax,eax
        mov     ulLastDword,eax
@@:

        mov     eax,ulSrcBytesPerPlane

convert_byte::

;------------------------------------------------------------------------
; process the high nibble of the bytes
;------------------------------------------------------------------------

        mov     bl,[esi]                ; move plane0 byte into ebx
        shr     ebx,2                   ; we need nibble 1 (*4)
        and     ebx,111100b
        mov     edx,aXlate[ebx]         ; put plane0 data into edx

        shr     edx,1                   ; shift edx into place
        add     esi,eax                 ; next plane
        mov     bl,[esi]                ; move plane1 byte into ebx
        shr     ebx,2                   ; we need nibble 1 (*4)
        and     ebx,111100b
        or      edx,aXlate[ebx]         ; merge plane1 data into edx

        shr     edx,1                   ; shift edx into place
        add     esi,eax                 ; next plane
        mov     bl,[esi]                ; move plane2 byte into ebx
        shr     ebx,2                   ; we need nibble 1 (*4)
        and     ebx,111100b
        or      edx,aXlate[ebx]         ; merge plane2 data into edx

        shr     edx,1                   ; shift edx into place
        add     esi,eax                 ; next plane
        mov     bl,[esi]                ; move plane3 byte into ebx
        shr     ebx,2                   ; we need nibble 1 (*4)
        and     ebx,111100b
        or      edx,aXlate[ebx]         ; merge plane3 data into edx

        sub     esi,ulThreePlanes

        mov     ulLowWord,edx

;------------------------------------------------------------------------
; process the low nibble of the bytes
;------------------------------------------------------------------------

        mov     bl,[esi]                ; move plane0 byte into ebx
        shl     ebx,2                   ; we need nibble 0 (*4)
        and     ebx,111100b
        mov     edx,aXlate[ebx]         ; put plane0 data into edx

        shr     edx,1                   ; shift edx into place
        add     esi,eax                 ; next plane
        mov     bl,[esi]                ; move plane1 byte into ebx
        shl     ebx,2                   ; we need nibble 0 (*4)
        and     ebx,111100b
        or      edx,aXlate[ebx]         ; merge plane1 data into edx

        shr     edx,1                   ; shift edx into place
        add     esi,eax                 ; next plane
        mov     bl,[esi]                ; move plane1 byte into ebx
        shl     ebx,2                   ; we need nibble 0 (*4)
        and     ebx,111100b
        or      edx,aXlate[ebx]         ; merge plane2 data into edx

        shr     edx,1                   ; shift edx into place
        add     esi,eax                 ; next plane
        mov     bl,[esi]                ; move plane1 byte into ebx
        shl     ebx,2                   ; we need nibble 0 (*4)
        and     ebx,111100b
        or      edx,aXlate[ebx]         ; merge plane3 data into edx

        sub     esi,ulThreePlanes

        shl     edx,16                  ; move result to HIGH word of edx
        or      edx,ulLowWord

        cmp     ulAlignShift,0          ; byte align if needed
        je      short @F
        mov     eax,ulLastDword
        bswap   edx
        mov     ulLastDword,edx
        shrd    edx,eax,4
        bswap   edx
@@:

        mov     eax,ulSrcBytesPerPlane

        mov     [edi],edx               ; store dword in target buff
        add     edi,4
        inc     esi
        dec     ecx                     ; we done one more src byte
        jg      convert_byte

        add     esi,ulSrcDelta          ; advance pSrc to next scan
        mov     pSrc,esi

        mov     esi,pBuf                ; copy from buf to dest DIB
        mov     eax,ulSrcIntraByte      ; skip this many pixels
        add     eax,ulAlignShift        ; round up if you aligned
        shr     eax,1                   ; skip this many bytes
        add     esi,eax
        mov     edi,pDst
        mov     ecx,ulDstBytesWide

        jmp     pfnCopy

dfb2dib_done_with_copy::

        add     edi,ulDstDelta
        mov     pDst,edi

        dec     ulNumScansLeft
        jnz     do_scan_line


        cRet    vdfb2dib                ;done!





;-----------------------------------------------------------------------;
; Copy from temp buffer to the dest.  no leading byte, no trailing byte
;-----------------------------------------------------------------------;

draw_dfb2dib_scan_00::
        rep     movsb                   ;copy whole bytes
        jmp     dfb2dib_done_with_copy


;-----------------------------------------------------------------------;
; Copy from temp buffer to the dest.  no leading byte, 1 trailing byte
;-----------------------------------------------------------------------;

draw_dfb2dib_scan_01::
        rep     movsb                   ;copy whole bytes
        mov     edx,ulRightMask         ;load mask
        mov     al,[esi]                ;read from temp buffer
        mov     bl,[edi]                ;read dest byte
        and     al,dl                   ;mask src
        and     bl,dh                   ;mask dest
        or      al,bl                   ;combine src with dest
        mov     [edi],al                ;write to dest
        inc     esi
        inc     edi
        jmp     dfb2dib_done_with_copy  ;done with buffer


;-----------------------------------------------------------------------;
; Copy from temp buffer to the dest.  1 leading byte, no trailing byte
;-----------------------------------------------------------------------;

draw_dfb2dib_scan_10::
        mov     edx,ulLeftMask          ;load mask
        mov     al,[esi]                ;read from temp buffer
        mov     bl,[edi]                ;read dest byte
        and     al,dl                   ;mask src
        and     bl,dh                   ;mask dest
        or      al,bl                   ;combine src with dest
        mov     [edi],al                ;write to dest
        inc     esi
        inc     edi
        rep     movsb                   ;copy whole bytes
        jmp     dfb2dib_done_with_copy  ;done with buffer


;-----------------------------------------------------------------------;
; Copy from temp buffer to the dest.  1 leading byte, 1 trailing byte
;-----------------------------------------------------------------------;

draw_dfb2dib_scan_11::
        mov     edx,ulLeftMask          ;load mask
        mov     al,[esi]                ;read from temp buffer
        mov     bl,[edi]                ;read dest byte
        and     al,dl                   ;mask src
        and     bl,dh                   ;mask dest
        or      al,bl                   ;combine src with dest
        mov     [edi],al                ;write to dest
        inc     esi
        inc     edi
        rep     movsb                   ;copy whole bytes
        mov     edx,ulRightMask         ;load mask
        mov     al,[esi]                ;read from temp buffer
        mov     bl,[edi]                ;read dest byte
        and     al,dl                   ;mask src
        and     bl,dh                   ;mask dest
        or      al,bl                   ;combine src with dest
        mov     [edi],al                ;write to dest
        inc     esi
        inc     edi
        jmp     dfb2dib_done_with_copy  ;done with buffer

endProc vdfb2dib



public  begin_setup
public  do_scan_line
public  convert_byte
public  dfb2dib_done_with_copy
public  draw_dfb2dib_scan_00
public  draw_dfb2dib_scan_01
public  draw_dfb2dib_scan_10
public  draw_dfb2dib_scan_11
public  dfb2dib_jLeftMasks
public  dfb2dib_jRightMasks


_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\dfbline.asm ===
;----------------------------- Module Header -----------------------------;
;
; dfbline.asm
;
; Contents:  Strip draw routines for writing lines onto device format bitmaps
;
; Notes:
;
; 1) We have 6 strip draw routines.  Horizontal, vertical, and diagonal
;    cases for each of Solid and Arbitrary styled lines.  Each routine
;    only has to draw left-to-right.
;
; 2) DFB Format:
;
;    The DFB format is a four plane bitmap.  Each bit in a 4 bit VGA colour
;    corresponds to a plane in the bitmap.  The bitmap has the format
;
;           PLANE 3	\
;           PLANE 2	 | - This is one scan line.
;           PLANE 1	 |   We are going UP in memory from PLANE 0
;           PLANE 0	/    on a scan line.
;
;    Where PLANE n corrosponds to bit n (counting from the right) in a VGA
;    colour.
;
;    The line code will call the appropriate strip routine 4 times to draw
;    a line: each time we'll draw on one plane of the DFB.
;
; 4) ROP Actions:
;
; 5) Output Routines:
;
;    The scope of the output routines is wildly inconsistant between functions.
;    Some write single bytes, some write the whole strips array onto a plane.
;    The overriding consideration was ease of implementation
;
;-------------------------------------------------------------------------;

	PAGE , 132
	.386

	.model  small,c

	assume ds:FLAT,es:FLAT,ss:FLAT
	assume fs:nothing,gs:nothing

	.xlist
	include stdcall.inc	      ;calling convention cmacros
	include i386\strucs.inc
	.list
	.code

	include i386\lines.inc

;--------------------------Private-Routine------------------------------;
; vBitmapSolidDiagonal
;
;   Draw diagonal strips left-to-right (handles both x-major and
;   y-major diagonal lines).
;
;-----------------------------------------------------------------------;

cProc   vBitmapSolidDiagonal,12,<  \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        mov     ebx, plStripEnd
        mov     esi, pStrips

; Do some initialization:

        mov     [ebx], esi                      ; save pStrips
        mov     [ebx + 4], ebp
        mov     al,  [esi].ST_jBitMask
        mov     edi, [esi].ST_pjScreen
        mov     ebp, [esi].ST_lNextScan

; Set up ROP registers:

        mov     dl, al
        mov     dh, al
        and     edx, [esi].ST_ulBitmapROP
        not     dl

;                   al  = rotating bit
;                   ebx = pointer to end of strips
;                   ecx = pixel count
;                   dl  = and mask
;                   dh  = xor mask
;                   esi = current strip pointer
;                   edi = display memory pointer
;                   ebp = delta

        test    [esi].ST_flFlips, FL_FLIP_D
        lea     esi, [esi].ST_alStrips
        jnz     y_major_next_diagonal

x_major_next_diagonal:
        mov     ecx, [esi]
        add     esi, 4

x_major_diagonal_loop:
        mov     ah, [edi]
        and     ah, dl
        xor     ah, dh
        mov     [edi], ah

        ror     dl, 1
        ror     dh, 1
        ror     al, 1
        adc     edi, ebp
        dec     ecx
        jnz     short x_major_diagonal_loop

        sub     edi, ebp
        cmp     esi, ebx
        jb      short x_major_next_diagonal

        jmp     short done_diagonal

y_major_next_diagonal:
        mov     ecx, [esi]
        add     esi, 4

y_major_diagonal_loop:
        mov     ah, [edi]
        and     ah, dl
        xor     ah, dh
        mov     [edi], ah

        ror     dl, 1
        ror     dh, 1
        ror     al, 1
        adc     edi, ebp
        dec     ecx
        jnz     short y_major_diagonal_loop

        rol     dl, 1
        rol     dh, 1
        rol     al, 1
        sbb     edi, 0
        cmp     esi, ebx
        jb      short y_major_next_diagonal

done_diagonal:
        mov     esi, [ebx]                      ; esi = pStrips
        mov     ebp, [ebx + 4]                  ; restore ebp
        mov     [esi].ST_pjScreen, edi
        mov     [esi].ST_jBitmask, al
        cRet    vBitmapSolidDiagonal

endProc vBitmapSolidDiagonal

;--------------------------Private-Routine------------------------------;
; vBitmapSolidVertical
;
;   Draw vertical strips left-to-right.
;
;-----------------------------------------------------------------------;

cProc   vBitmapSolidVertical,12,<  \
        uses         esi edi ebx,   \
        pStrips:     ptr STRIPS,    \
        pls:         ptr LINESTATE, \
        plStripEnd: ptr >

        mov     ebx, plStripEnd
        mov     esi, pStrips

; Do some initialization:

        mov     [ebx], esi                      ; save pStrips
        mov     [ebx + 4], ebp
        mov     al,  [esi].ST_jBitMask
        mov     edi, [esi].ST_pjScreen
        mov     ebp, [esi].ST_lNextScan

; Set up ROP registers:

        mov     dl, al
        mov     dh, al
        and     edx, [esi].ST_ulBitmapROP
        add     esi, offset ST_alStrips
        not     dl

;                   al  = rotating bit
;                   ebx = pointer to end of strips
;                   ecx = pixel count
;                   dl  = and mask
;                   dh  = xor mask
;                   esi = current strip pointer
;                   edi = display memory pointer
;                   ebp = delta

next_vertical:
        mov     ecx, [esi]
        add     esi, 4

vertical_loop:
        mov     ah, [edi]
        and     ah, dl
        xor     ah, dh
        mov     [edi], ah

        add     edi, ebp
        dec     ecx
        jnz     short vertical_loop

; Okay, we're finished with the strip so we have to advance one pixel
; to the right:

        ror     dl, 1
        ror     dh, 1
        ror     al, 1
        adc     edi, 0

; See if there are any more strips:

        cmp     esi, ebx
        jb      short next_vertical

; We're done:

        mov     esi, [ebx]                      ; esi = pStrips
        mov     ebp, [ebx + 4]                  ; restore ebp
        mov     [esi].ST_pjScreen, edi
        mov     [esi].ST_jBitmask, al
        cRet    vBitmapSolidDiagonal

endProc vBitmapSolidVertical

;--------------------------Private-Routine------------------------------;
; vBitmapSolidHorizontal
;
;   Draw vertical strips left-to-right.
;
;-----------------------------------------------------------------------;

cProc   vBitmapSolidHorizontal,12,< \
        uses        esi edi ebx,    \
        pStrips:    ptr STRIPS,     \
        pls:        ptr LINESTATE,  \
        plStripEnd: ptr >

        mov     ebx, plStripEnd
        mov     esi, pStrips

; Do some initialization:

        push    ebp
        mov     [esi].ST_plStripEnd, ebx
        mov     al,  [esi].ST_jBitMask
        mov     edx, [esi].ST_ulBitmapROP
        mov     edi, [esi].ST_pjScreen
        lea     ebp, [esi].ST_alStrips

;                   al  = rotating bit
;                   ebx = garbage
;                   ecx = pixel count
;                   edx = ulBitmapROP
;                   esi = pStrips
;                   edi = display memory pointer
;                   ebp = current strip pointer

next_horizontal:
        mov     ecx, [ebp]
        add     ebp, 4

        lea     ebx, [2 * eax - 1]      ; bl = start mask
        ror     al, cl                  ; al = rotating bit for next scan
        shr     ecx, 3
        cmp     bl, al
        adc     ecx, 0
        jnz     short extends_out_of_first_byte

        sub     bl, al                  ; figure out rest of mask
        sub     bl, al
        inc     bl

        mov     bh, bl                  ; compute ROP values
        and     ebx, edx
        not     bl

        mov     ah, [edi]               ; actually write the byte
        and     ah, bl
        xor     ah, bh
        mov     [edi], ah

        add     edi, [esi].ST_lNextScan ; increment to next scan

        cmp     ebp, [esi].ST_plStripEnd ; see if done all strips
        jb      short next_horizontal

        pop     ebp                     ; clean up and leave
        mov     [esi].ST_pjScreen, edi
        mov     [esi].ST_jBitmask, al
        cRet    vBitmapSolidHorizontal

extends_out_of_first_byte:

; This part gets called when the current strip doesn't fit entirely
; into one byte:

        mov     bh, bl                  ; compute ROP values
        and     ebx, edx
        not     bl

        mov     ah, [edi]               ; actually write the byte
        and     ah, bl
        xor     ah, bh
        mov     [edi], ah

        inc     edi                     ; move to next byte

        dec     ecx                     ; any bytes inbetween start & end byte?
        jnz     short output_bunch

last_byte:
        lea     ebx, [2 * eax - 1]      ; compute end mask
        not     bl

        mov     bh, bl                  ; compute ROP values
        and     ebx, edx
        not     bl

        mov     ah, [edi]               ; actually write the byte
        and     ah, bl
        xor     ah, bh
        mov     [edi], ah

        add     edi, [esi].ST_lNextScan ; go to next scan

        cmp     ebp, [esi].ST_plStripEnd ; was this the last strip?
        jb      short next_horizontal

        pop     ebp                     ; clean up and leave
        mov     [esi].ST_pjScreen, edi
        mov     [esi].ST_jBitmask, al
        cRet    vBitmapSolidHorizontal

output_bunch:
        not     dl

bunch_loop:

; We have a series of bytes to lay down:

        mov     ah, [edi]
        and     ah, dl
        xor     ah, dh
        mov     [edi], ah
        inc     edi

        dec     ecx                     ; we done all the whole bytes?
        jnz     short bunch_loop

        not     dl
        jmp     short last_byte

endProc vBitmapSolidHorizontal

;--------------------------Private-Routine------------------------------;
; vBitmapStyledHorizontal
;
;   Draws arbitrarily styled horizontal strips left-to-right.
;
;-----------------------------------------------------------------------;

cProc   vBitmapStyledHorizontal,12,< \
        uses        esi edi ebx,    \
        pStrips:    ptr STRIPS,     \
        pls:        ptr LINESTATE,  \
        plStripEnd: ptr >

        mov     ebx, plStripEnd
        mov     esi, pStrips
        push    ebp
        mov     ebp, esi

; Do some initialization:

        mov     [ebp].ST_plStripEnd, ebx
        lea     esi, [ebp].ST_alStrips
        mov     al,  [ebp].ST_jBitmask
        mov     ah,  [ebp].ST_jStyleMask
        mov     edx, [ebp].ST_spRemaining
        mov     edi, [ebp].ST_pjScreen

;                   al  = rotating bit
;                   ah  = 0 if working on a dash, 0ffh if working on a gap
;                   bl  = accumulating mask
;                   ecx = pixel count
;                   edx = # of pixels to go in dash or gap (must be 32 bits)
;                   esi = current strip pointer
;                   edi = display memory pointer
;                   ebp = pStrips

        align   4

next_horizontal:
        mov     ecx, [esi]              ; get new strip count
        add     esi, 4
        xor     bl, bl                  ; clear accumulating mask

horizontal_loop:
        xor     bl, ah                  ; set bit in accumulating mask if
        or      bl, al                  ;   ah says we're working on a dash
        xor     bl, ah

        dec     edx
        jz      short next_style_entry

next_pixel:
        ror     al, 1
        jc      short output_byte
        dec     ecx                     ; another pixel done; continue with
        jnz     short horizontal_loop   ;   with strip if there's more left

; We're done a horizontal strip.  Now we do a diagonal step:

side_step:
        mov     bh, bl                  ; do ROP stuff
        and     ebx, [ebp].ST_ulBitmapROP
        not     bl

        and     [edi], bl               ; write the byte
        xor     [edi], bh

        add     edi, [ebp].ST_lNextScan

        cmp     [ebp].ST_plStripEnd, esi ; are we finished the strip array?
        ja      short next_horizontal

        mov     [ebp].ST_pjScreen, edi  ; remember where we were
        mov     [ebp].ST_jBitmask, al
        mov     [ebp].ST_jStyleMask, ah
        mov     [ebp].ST_spRemaining, edx

        pop     ebp

        cRet    vBitmapStyledHorizontal

output_byte:
        mov     bh, bl                  ; do ROP stuff
        and     ebx, [ebp].ST_ulBitmapROP
        not     bl

        and     [edi], bl               ; write the byte
        xor     [edi], bh

        xor     bl, bl                  ; clear accumulating mask

        inc     edi                     ; moved one byte to right

        dec     ecx
        jnz     short horizontal_loop   ; more pels to go in strip
        jmp     short side_step         ; need a new strip

; We're onto a new entry in the style array:

next_style_entry:
        mov     edx, [ebp].ST_psp       ; go to next style array entry
        add     edx, 4
        cmp     [ebp].ST_pspEnd, edx    ; if past end go back to start
        jae     short @F
        mov     edx, [ebp].ST_pspStart
@@:
        mov     [ebp].ST_psp, edx       ; save it for posterity
        mov     edx, [edx]              ; new count
        not     ah                      ; dash => gap or gap => dash

        jmp     short next_pixel

endProc vBitmapStyledHorizontal


;--------------------------Private-Routine------------------------------;
; vBitmapStyledVertical
;
;   Draw arbitrarily styled vertical strips left-to-right.
;
;-----------------------------------------------------------------------;

cProc   vBitmapStyledVertical,12,<  \
        uses        esi edi ebx,    \
        pStrips:    ptr STRIPS,     \
        pls:        ptr LINESTATE,  \
        plStripEnd: ptr >

        mov     ebx, plStripEnd
        mov     esi, pStrips
        push    ebp
        mov     ebp, esi

; Do some initialization:

        mov     [ebp].ST_plStripEnd, ebx
        lea     esi, [ebp].ST_alStrips
        mov     al,  [ebp].ST_jBitmask
        mov     ah,  [ebp].ST_jStyleMask
        mov     edx, [ebp].ST_spRemaining
        mov     edi, [ebp].ST_pjScreen

;                   al  = rotating bit
;                   ah  = 0 if working on a dash, 0ffh if working on a gap
;                   bl  = and mask
;                   bh  = xor mask
;                   ecx = pixel count
;                   edx = # of pixels to go in dash or gap (must be 32 bits)
;                   esi = current strip pointer
;                   edi = display memory pointer
;                   ebp = pStrips

        align   4

next_vertical:
        mov     ecx, [esi]              ; get new strip count
        add     esi, 4

        mov     bl, al                  ; load up bl and bh to handle ROP
        mov     bh, al
        and     ebx, [ebp].ST_ulBitmapROP
        not     bl

vertical_loop:
        or      ah, ah
        jnz     short @F                ; don't output pixel if in a gap
        and     [edi], bl
        xor     [edi], bh
@@:
        dec     edx
        jz      short next_style_entry

next_pixel:
        add     edi, [ebp].ST_lNextScan
        dec     ecx                     ; another pixel done; continue with
        jnz     short vertical_loop     ;   with strip if there's more left

; We're done a vertical strip.  Take a side step:

        ror     al, 1
        adc     edi, 0

        cmp     esi, [ebp].ST_plStripEnd ; we done with all the strips?
        jb      short next_vertical

        mov     [ebp].ST_pjScreen, edi  ; remember where we were
        mov     [ebp].ST_jBitmask, al
        mov     [ebp].ST_jStyleMask, ah
        mov     [ebp].ST_spRemaining, edx

        pop     ebp

        cRet    vBitmapStyledVertical

; We're onto a new entry in the style array:

next_style_entry:
        mov     edx, [ebp].ST_psp       ; go to next style array entry
        add     edx, 4
        cmp     [ebp].ST_pspEnd, edx    ; if past end go back to start
        jae     short @F
        mov     edx, [ebp].ST_pspStart
@@:
        mov     [ebp].ST_psp, edx       ; save it for posterity
        mov     edx, [edx]              ; new count
        not     ah                      ; dash => gap or gap => dash

        jmp     short next_pixel


endProc vBitmapStyledVertical

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\dfbpat.asm ===
;---------------------------Module-Header------------------------------;
;
; Module Name:  dfb2pat.asm
;
; Copyright (c) 1994 Microsoft Corporation
;
;-----------------------------------------------------------------------;
;
; VOID vClrPatDFB(PDEVSURF pdsurfDst,
;               ULONG cRect,
;               RECTL * prclDst,
;               MIX ulMix,
;               BRUSHINST *pBrush,
;               PPOINTL pBrushOrg);
;
; The parameter list must match up with vClrPatBlt
;
; Performs accelerated fills to a DFB.
;
; pdsurfDst = pointer to dest surface
; cRect =     count of rectangles to fill
; prclDst =   pointer to array of rectangles describing target area of DFB
; ulMix =     mix rop with which to fill
; pBrush =    pointer to the brush instance
; pBrushOrg = pointer to where to start in brush
;
;-----------------------------------------------------------------------;
;
; Note: Assumes the destination rectangle has a positive height and width.
;       Will not work properly if this is not the case.
;
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc
        include i386\ropdefs.inc
        include i386\display.inc        ; Display specific structures

        .list

;-----------------------------------------------------------------------;

        .data

extrn   jForceOffTable:byte             ;see vgablts.asm
extrn   jForceOnTable:byte              ;see vgablts.asm
extrn   jNotTable:byte                  ;see vgablts.asm

extrn   dfbfill_jLeftMasks:dword        ;see dfbfill.asm
extrn   dfbfill_jRightMasks:dword       ;see dfbfill.asm

dfbpat_pfnScanHandlers  label   dword
        dd      patfill_dfb_scan_00
        dd      patfill_dfb_scan_01
        dd      patfill_dfb_scan_10
        dd      patfill_dfb_scan_11

;-----------------------------------------------------------------------;

                .code

_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;-----------------------------------------------------------------------;

cProc vClrPatDFB,24,<              \
        uses esi edi ebx,          \
        pdsurfDst: ptr DEVSURF,    \
        cRect: dword,              \
        prclDst: ptr RECTL,        \
        ulMix: dword,              \
        pBrush: ptr oem_brush_def, \
        pBrushOrg: ptr POINTL      >

        local   pfnDrawScans:dword       ;ptr to correct scan drawing function
        local   pDst:dword               ;pointer to drawing dst start address
        local   ulBytesPerDstPlane:dword ;# of bytes on one mono plan scan of DFB
        local   ulColor:dword            ;color of pattern
        local   ulPatternOrgY:dword      ;Local copy of the pattern offset Y
        local   iPatY:dword              ;y index into pattern
        local   RotatedPat[32]:byte      ;Aligned pattern buffer
        
        local   sDfbInfo[size DFBBLT]:byte


TRAILING_PARTIAL        equ     01h      ;partial trailing word should be copied
LEADING_PARTIAL         equ     02h      ;partial leading word should be copied

PLANE_0_BIT             equ     01h      ;which bit of ulColor should go on plane 0
PLANE_1_BIT             equ     02h      ;which bit of ulColor should go on plane 1
PLANE_2_BIT             equ     04h      ;which bit of ulColor should go on plane 2
PLANE_3_BIT             equ     08h      ;which bit of ulColor should go on plane 3

;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Make sure there's something to draw; clip enumerations can be empty.
;-----------------------------------------------------------------------;

        cmp     cRect,0                ;any more rects to fill?
        je      dfbpat_exit            ;no, we're done

        ;
        ; Set up for the desired raster op.
        ;

        sub     ebx,ebx                 ;ignore any background mix; we're only
        mov     bl,byte ptr ulMix       ; concerned with the foreground in this
                                        ; module
        cmp     ebx,R2_NOP              ;is this NOP?
        jz      dfbpat_exit            ;yes, we're done
        
        mov     esi,pBrush              ;point to the brush







        
;-----------------------------------------------------------------------;
; Set up variables that are constant for the entire time we're in this
; module.
;-----------------------------------------------------------------------;
        mov     edx,pBrushOrg                ;point to the brush origin

        mov     ecx,[edx].ptl_y
        and     ecx,7                           ;just to be safe
        mov     ulPatternOrgY,ecx

        mov     ecx,[edx].ptl_x
        and     ecx,7                           ;eax mod 8

        ;We are now going to make a copy of our rotated copy of our pattern.
        ;The reason that we do this is because we may be called with several
        ;rectangles and we don't really want to rotate the pattern data for
        ;each rectangle. We copy this rectangle to be double high so that
        ;we can incorperate our Y offest later without having to worry
        ;about running off the end of the pattern.

        lea     edi,RotatedPat                  ;Pattern Dest
        ; mov     esi,[esi + oem_brush_pmono]     ;Pattern Src
        add     esi,oem_brush_C0                ;Pattern Src
           
        or      ecx,ecx
        jnz     rotate_pattern_ROP
        ; Since there is no rotation we just need to expand our pattern
        ; to be double tall.
INDEX=0
DSTINDEX=0
        rept    8
        mov     eax,[esi+INDEX]
        mov     [edi+DSTINDEX],eax
INDEX=INDEX+4
DSTINDEX=DSTINDEX+4
        endm    ;-----------------
        jmp     copy_masks


rotate_pattern_ROP:
        mov     ch,4                    ;Loop count

shift_pattern_loop_ROP:
INDEX=0
        rept    8                       ;patterns are 8x8 planar (4*8)
        mov     al,[esi+INDEX]          ;load bytes for shift
        ror     al,cl                   ;shift into position
        mov     [edi+INDEX],al          ;save result
INDEX=INDEX+1
        endm    ;-----------------
        add     edi,8
        add     esi,8
        dec     ch
        jnz     shift_pattern_loop_ROP


copy_masks:
        
        
        
        
        
        
        
        

dfbpat_outer_loop:

;-----------------------------------------------------------------------;
; Set up various variables for the copy.
;
; At this point, EBX = pptlSrc, EDI = pdsurfDst.
;-----------------------------------------------------------------------;
        
        mov     edi,pdsurfDst           ;point to surface to fill (DFB)
        mov     esi,prclDst             ;point to rectangle to fill
        
        mov     ecx,[esi].yTop
        add     ecx,8                   ;this and the fact that ulPatternOrgY
                                        ; is always less than 8 mean that...
        sub     ecx,ulPatternOrgY       ;... this is always positive
        and     ecx,7
        mov     iPatY,ecx
        
        sub     ecx,ecx                 ;accumulate copy control flags
        mov     eax,[esi].xLeft         ;first, check for partial-dword edges
        and     eax,11111b              ;left edge pixel alignment
        jz      short @F                ;whole byte, don't need leading mask
        or      ecx,LEADING_PARTIAL     ;do need leading mask
@@:
        mov     edx,dfbfill_jLeftMasks[eax*4] ;mask to apply to source to clip
        mov     sDfbInfo.LeftMask,edx         ;remember mask
        not     edx
        mov     sDfbInfo.NotLeftMask,edx      ;remember mask

        mov     eax,[esi].xRight
        and     eax,11111b              ;right edge pixel alignment
        jz      short @F                ;whole byte, don't need trailing mask
        or      ecx,TRAILING_PARTIAL    ;do need trailing mask
@@:
        mov     edx,dfbfill_jRightMasks[eax*4] ;mask to apply to source to clip
        mov     sDfbInfo.RightMask,edx         ;remember mask
        not     edx
        mov     sDfbInfo.NotRightMask,edx      ;remember mask



dfbpat_detect_partials::
        mov     sDfbInfo.DstWidth,0     ;overwritten if any whole dwords
                                        ;now, see if there are only partial
                                        ; dwords, or maybe even only one partial
        mov     eax,[esi].xLeft
        add     eax,11111b
        and     eax,not 11111b          ;round left up to nearest dword
        mov     edx,[esi].xRight

        cmp     eax,edx                        ;if left (rounded up) >= right
        jge     short dfbpat_one_partial_only ; only one dword

        and     edx,not 11111b          ;round right down to nearest dword
        sub     edx,eax                 ;# of pixels, rounded to nearest dword
                                        ; boundaries (not counting partials)
        ja      short dfbpat_check_whole_dwords ;there's at least one whole dword

                                        ;there are no whole dwords
                                        ; there are two partial
                                        ; dwords, which is exactly what
                                        ; we're already set up to do

        jmp     short dfbpat_set_copy_control_flags
                      
dfbpat_one_partial_only::              ;only one, partial dword, so construct a
                                        ; single mask and set up to do just
                                        ; one, partial dword
        mov     eax,sDfbInfo.LeftMask
        and     eax,sDfbInfo.RightMask         ;intersect the masks
        mov     sDfbInfo.LeftMask,eax
        not     eax
        mov     sDfbInfo.NotLeftMask,eax
        mov     ecx,LEADING_PARTIAL     ;only one partial dword, which we'll
                                        ; treat as leading
        jmp     short dfbpat_set_copy_control_flags ;the copy control flags are set

dfbpat_check_whole_dwords::
                                        ;finally, calculate the number of whole
                                        ; dwords  we'll process
        shr     edx,5                   ;num_pixels/32
        mov     sDfbInfo.DstWidth,edx   ;save count of whole dwords

dfbpat_set_copy_control_flags::

        mov     edx,dfbpat_pfnScanHandlers[ecx*4] ;proper drawing handler
        mov     pfnDrawScans,edx


;-----------------------------------------------------------------------;
; Set up the offsets to the next source and destination scans.
;
; At this point, EBX = pptlSrc, ESI = prclDst, EDI = pdsurfDst.
;-----------------------------------------------------------------------;

        mov     edx,sDfbInfo.DstWidth ;# of dwords across dest rectangle
        shl     edx,2                 ;# of bytes across dest rectangle
        mov     eax,[edi].dsurf_lNextScan ;# of bytes across 1 scan of dest
        sub     eax,edx         ;offset from end of scan 1 to start of scan 2
        mov     sDfbInfo.DstDelta,eax  
            
;-----------------------------------------------------------------------;
; At this point, ESI = prclDst, EDI = pdsurfDst
;-----------------------------------------------------------------------;

        mov     eax,[edi].dsurf_lNextPlane
        mov     ulBytesPerDstPlane,eax

        mov     eax,[esi].yTop          ;top scan of copy
        imul    eax,[edi].dsurf_lNextScan ;offset of starting scan line
        mov     edx,[esi].xLeft         ;left dest X coordinate
        add     edx,31                  ;round up to dword
        and     edx,not 31
        shr     edx,3                   ;left dest byte offset in row
        add     eax,edx                 ;initial offset in dest bitmap
        add     eax,[edi].dsurf_pvBitmapStart ;initial dest bitmap address
        mov     pDst,eax                ;remember where to start drawing
                
;-----------------------------------------------------------------------;
; At this point, EDI = pdsurfDst
;-----------------------------------------------------------------------;

; Calculate the # of scans to do

        mov     ebx,[esi].yBottom       ;bottom of destination rectangle
        sub     ebx,[esi].yTop          ;# of scans to copy
        mov     sDfbInfo.BurstCountLeft,ebx

;-----------------------------------------------------------------------;
; Copy to the screen in bursts of BurstCountLeft scans.
;-----------------------------------------------------------------------;
             
dfbpat_proceed_with_copy::

;-----------------------------------------------------------------------;
; Copy the DFB scans
;-----------------------------------------------------------------------;

dfbpat_plane_0_scan:

        lea     esi,sDfbInfo            ;points to parameters
        mov     edi,pDst
        lea     eax,RotatedPat[SIZE_PATTERN*0]
        mov     ebx,iPatY
        call    pfnDrawScans

dfbpat_plane_1_scan:

        mov     eax,ulBytesPerDstPlane
        add     pDst,eax                ;dst scan mod 4 now == 1
                  
        lea     esi,sDfbInfo            ;points to parameters
        mov     edi,pDst
        lea     eax,RotatedPat[SIZE_PATTERN*1]
        mov     ebx,iPatY
        call    pfnDrawScans

dfbpat_plane_2_scan:

        mov     eax,ulBytesPerDstPlane
        add     pDst,eax                ;dst scan mod 4 now == 2
                  
        lea     esi,sDfbInfo            ;points to parameters
        mov     edi,pDst
        lea     eax,RotatedPat[SIZE_PATTERN*2]
        mov     ebx,iPatY
        call    pfnDrawScans

dfbpat_plane_3_scan:

        mov     eax,ulBytesPerDstPlane
        add     pDst,eax                ;dst scan mod 4 now == 3
                  
        lea     esi,sDfbInfo            ;points to parameters
        mov     edi,pDst
        lea     eax,RotatedPat[SIZE_PATTERN*3]
        mov     ebx,iPatY
        call    pfnDrawScans

        add     prclDst,(size RECTL)    ;point to the next rectangle, if there is one
        dec     cRect
        jnz     dfbpat_outer_loop

dfbpat_exit:

        cRet    vClrPatDFB              ;done!

endProc vClrPatDFB


                                  
;-----------------------------------------------------------------------;
; Fill n scans, no leading partial, no trailing partial
;
; esi->BurstCountLeft:  # scans to do
; esi->DstWidth:        # whole words
; esi->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    ptr to structure of parameters
;                      *edi:    pDst
;                      *eax:    ulColor
;                       ebx:    index into pattern
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;-----------------------------------------------------------------------;

patfill_dfb_scan_00     proc    near

        local   pattern:dword
        local   temp_count:dword
    
        mov     ecx,[esi].BurstCountLeft
        mov     temp_count,ecx
        mov     pattern,eax
        
@@:     ; burst loop (do each scan)

        mov     eax,pattern
        mov     cl,[eax+ebx]            ;get pattern byte
        inc     ebx                     ;increment to next scan's pattern
        and     ebx,SIZE_PATTERN-1
        mov     al,cl                   ;copy cl to all 4 bytes of eax
        mov     ah,cl
        ror     eax,16
        mov     al,cl
        mov     ah,cl
        
        ; main loop

        mov     ecx,[esi].DstWidth      ;load DstWidth (will get trashed)
        rep     stosd                   ;copy DWORDs (destroy CX)

        ; set up for next scan

        add     edi,[esi].DstDelta      ;inc to next scan
        dec     temp_count              ;dec BurstCountLeft 
        jg      @B                      ;if any left, loop

        ret                             ;bye

patfill_dfb_scan_00     endp


;-----------------------------------------------------------------------;
; Fill n scans, 0 leading partial, 1 trailing partial
;
; esi->BurstCountLeft:  # scans to do
; esi->DstWidth:        # whole words
; esi->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    ptr to structure of parameters
;                      *edi:    pDst
;                      *eax:    ulColor
;                       ebx:    index into pattern
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

patfill_dfb_scan_01     proc    near

        local   pattern:dword
        local   temp_count:dword
    
        mov     ecx,[esi].BurstCountLeft
        mov     temp_count,ecx
        mov     pattern,eax
        
@@:     ; burst loop (do each scan)

        mov     eax,pattern
        mov     cl,[eax+ebx]            ;get pattern byte
        inc     ebx                     ;increment to next scan's pattern
        and     ebx,SIZE_PATTERN-1
        mov     al,cl                   ;copy cl to all 4 bytes of eax
        mov     ah,cl
        ror     eax,16
        mov     al,cl
        mov     ah,cl
        
        ; main loop

        mov     ecx,[esi].DstWidth      ;load DstWidth (will get trashed)
        rep     stosd                   ;copy DWORDs (destroy CX)        
                                                                         
        ; trailing partial dword

        push    eax                     ;save color for main loop
        mov     edx,[edi]               ;get leading dst dword           
        and     edx,[esi].NotRightMask  ;remove bits that will be filled 
        and     eax,[esi].RightMask     ;remove bits that won't be filled
        or      edx,eax                 ;combine dwords                  
        mov     [edi],edx               ;write leading dword             
        pop     eax                     ;restore color for main loop

        ; set up for next scan

        add     edi,[esi].DstDelta      ;inc to next scan                
        dec     temp_count              ;dec BurstCountLeft 
        jg      @B                      ;if any left, loop

        ret                             ;bye

patfill_dfb_scan_01     endp


;-----------------------------------------------------------------------;
; Fill n scans, 1 leading partial, 0 trailing partial
;
; esi->BurstCountLeft:  # scans to do
; esi->DstWidth:        # whole words
; esi->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    ptr to structure of parameters
;                      *edi:    pDst
;                      *eax:    ulColor
;                       ebx:    index into pattern
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

patfill_dfb_scan_10     proc    near

        local   pattern:dword
        local   temp_count:dword
    
        mov     ecx,[esi].BurstCountLeft
        mov     temp_count,ecx
        mov     pattern,eax
        
@@:     ; burst loop (do each scan)

        mov     eax,pattern
        mov     cl,[eax+ebx]            ;get pattern byte
        inc     ebx                     ;increment to next scan's pattern
        and     ebx,SIZE_PATTERN-1
        mov     al,cl                   ;copy cl to all 4 bytes of eax
        mov     ah,cl
        ror     eax,16
        mov     al,cl
        mov     ah,cl
        
        ; leading partial dword

        push    eax                     ;save color for main loop
        mov     edx,[edi-4]             ;get leading dst dword
        and     edx,[esi].NotLeftMask   ;remove bits that will be filled
        and     eax,[esi].LeftMask      ;remove bits that won't be filled
        or      edx,eax                 ;combine dwords
        mov     [edi-4],edx             ;write leading dword
        pop     eax                     ;restore color for main loop

        ; main loop

        mov     ecx,[esi].DstWidth      ;load DstWidth (will get trashed)
        rep     stosd                   ;copy DWORDs (destroy CX)        
                                                                         
        ; set up for next scan

        add     edi,[esi].DstDelta      ;inc to next scan                
        dec     temp_count              ;dec BurstCountLeft 
        jg      @B                      ;if any left, loop

        ret                             ;bye

patfill_dfb_scan_10     endp


;-----------------------------------------------------------------------;
; Fill n scans, 1 leading partial, 1 trailing partial
;
; esi->BurstCountLeft:  # scans to do
; esi->DstWidth:        # whole words
; esi->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    ptr to structure of parameters
;                      *edi:    pDst
;                      *eax:    ulColor
;                       ebx:    index into pattern
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

patfill_dfb_scan_11     proc    near

        local   pattern:dword
        local   temp_count:dword
    
        mov     ecx,[esi].BurstCountLeft
        mov     temp_count,ecx
        mov     pattern,eax
        
@@:     ; burst loop (do each scan)

        mov     eax,pattern
        mov     cl,[eax+ebx]            ;get pattern byte
        inc     ebx                     ;increment to next scan's pattern
        and     ebx,SIZE_PATTERN-1
        mov     al,cl                   ;copy cl to all 4 bytes of eax
        mov     ah,cl
        ror     eax,16
        mov     al,cl
        mov     ah,cl
        
        ; leading partial dword

        push    eax                     ;save color for main loop
        mov     edx,[edi-4]             ;get leading dst dword
        and     edx,[esi].NotLeftMask   ;remove bits that will be filled
        and     eax,[esi].LeftMask      ;remove bits that won't be filled
        or      edx,eax                 ;combine dwords
        mov     [edi-4],edx             ;write leading dword
        pop     eax                     ;restore color for main loop

        ; main loop

        mov     ecx,[esi].DstWidth      ;load DstWidth (will get trashed)
        rep     stosd                   ;copy DWORDs (destroy CX)        
                                                                         
        ; trailing partial dword

        push    eax                     ;save color for main loop
        mov     edx,[edi]               ;get leading dst dword           
        and     edx,[esi].NotRightMask  ;remove bits that will be filled 
        and     eax,[esi].RightMask     ;remove bits that won't be filled
        or      edx,eax                 ;combine dwords                  
        mov     [edi],edx               ;write leading dword             
        pop     eax                     ;restore color for main loop

        ; set up for next scan

        add     edi,[esi].DstDelta      ;inc to next scan                
        dec     temp_count              ;dec BurstCountLeft 
        jg      @B                      ;if any left, loop

        ret                             ;bye

patfill_dfb_scan_11     endp



public patfill_dfb_scan_00
public patfill_dfb_scan_01
public patfill_dfb_scan_10
public patfill_dfb_scan_11

public dfbpat_detect_partials
public dfbpat_one_partial_only
public dfbpat_check_whole_dwords
public dfbpat_set_copy_control_flags
public dfbpat_proceed_with_copy

_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\dfbfill.asm ===
;---------------------------Module-Header------------------------------;
;
; Module Name:  dfb2fill.asm
;
; Copyright (c) 1993 Microsoft Corporation
;
;-----------------------------------------------------------------------;
;
; VOID vDFBFILL(PDEVSURF pdsurfDst,
;               ULONG cRect,
;               RECTL * prclDst,
;               MIX ulMix,
;               ULONG ulColor);
;
; The parameter list must match up with vTrgBlt
;
; Performs accelerated fills to a DFB.
;
; pdsurfDst = pointer to dest surface
; cRect =     count of rectangles to fill
; prclDst =   pointer to array of rectangles describing target area of DFB
; ulMix =     mix rop with which to fill
; ulColor =   solid color with which to fill rectangle
;
;-----------------------------------------------------------------------;
;
; Note: Assumes the destination rectangle has a positive height and width.
;       Will not work properly if this is not the case.
;
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc
        include i386\ropdefs.inc

        .list

;-----------------------------------------------------------------------;

        .data

extrn   jForceOffTable:byte             ; see vgablts.asm
extrn   jForceOnTable:byte              ; see vgablts.asm
extrn   jNotTable:byte                  ; see vgablts.asm

dfbfill_jLeftMasks      label   dword
                db      0ffh,0ffh,0ffh,0ffh
                db      07fh,0ffh,0ffh,0ffh
                db      03fh,0ffh,0ffh,0ffh
                db      01fh,0ffh,0ffh,0ffh
                db      00fh,0ffh,0ffh,0ffh
                db      007h,0ffh,0ffh,0ffh
                db      003h,0ffh,0ffh,0ffh
                db      001h,0ffh,0ffh,0ffh
                db      000h,0ffh,0ffh,0ffh
                db      000h,07fh,0ffh,0ffh
                db      000h,03fh,0ffh,0ffh
                db      000h,01fh,0ffh,0ffh
                db      000h,00fh,0ffh,0ffh
                db      000h,007h,0ffh,0ffh
                db      000h,003h,0ffh,0ffh
                db      000h,001h,0ffh,0ffh
                db      000h,000h,0ffh,0ffh
                db      000h,000h,07fh,0ffh
                db      000h,000h,03fh,0ffh
                db      000h,000h,01fh,0ffh
                db      000h,000h,00fh,0ffh
                db      000h,000h,007h,0ffh
                db      000h,000h,003h,0ffh
                db      000h,000h,001h,0ffh
                db      000h,000h,000h,0ffh
                db      000h,000h,000h,07fh
                db      000h,000h,000h,03fh
                db      000h,000h,000h,01fh
                db      000h,000h,000h,00fh
                db      000h,000h,000h,007h
                db      000h,000h,000h,003h
                db      000h,000h,000h,001h
                                 
dfbfill_jRightMasks     label   dword
                db      0ffh,0ffh,0ffh,0ffh
                db      080h,000h,000h,000h
                db      0c0h,000h,000h,000h
                db      0e0h,000h,000h,000h
                db      0f0h,000h,000h,000h
                db      0f8h,000h,000h,000h
                db      0fch,000h,000h,000h
                db      0feh,000h,000h,000h
                db      0ffh,000h,000h,000h
                db      0ffh,080h,000h,000h
                db      0ffh,0c0h,000h,000h
                db      0ffh,0e0h,000h,000h
                db      0ffh,0f0h,000h,000h
                db      0ffh,0f8h,000h,000h
                db      0ffh,0fch,000h,000h
                db      0ffh,0feh,000h,000h
                db      0ffh,0ffh,000h,000h
                db      0ffh,0ffh,080h,000h
                db      0ffh,0ffh,0c0h,000h
                db      0ffh,0ffh,0e0h,000h
                db      0ffh,0ffh,0f0h,000h
                db      0ffh,0ffh,0f8h,000h
                db      0ffh,0ffh,0fch,000h
                db      0ffh,0ffh,0feh,000h
                db      0ffh,0ffh,0ffh,000h
                db      0ffh,0ffh,0ffh,080h
                db      0ffh,0ffh,0ffh,0c0h
                db      0ffh,0ffh,0ffh,0e0h
                db      0ffh,0ffh,0ffh,0f0h
                db      0ffh,0ffh,0ffh,0f8h
                db      0ffh,0ffh,0ffh,0fch
                db      0ffh,0ffh,0ffh,0feh

dfbfill_pfnScanHandlers label   dword
                dd      fill_dfb_scan_00
                dd      fill_dfb_scan_01
                dd      fill_dfb_scan_10
                dd      fill_dfb_scan_11

;-----------------------------------------------------------------------;

                .code

_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;-----------------------------------------------------------------------;

cProc vDFBFILL,20,<             \
        uses esi edi ebx,       \
        pdsurfDst: ptr DEVSURF, \
        cRect: dword,           \
        prclDst: ptr RECTL,     \
        ulMix: dword,           \
        ulColor: dword,         >

        local   pfnDrawScans:dword       ;ptr to correct scan drawing function
        local   pDst:dword               ;pointer to drawing dst start address
        local   ulBytesPerDstPlane       ;# of bytes on one mono plan scan of DFB
        local   sDfbInfo[size DFBBLT]:byte


TRAILING_PARTIAL        equ     01h      ;partial trailing word should be copied
LEADING_PARTIAL         equ     02h      ;partial leading word should be copied

PLANE_0_BIT             equ     01h      ;which bit of ulColor should go on plane 0
PLANE_1_BIT             equ     02h      ;which bit of ulColor should go on plane 1
PLANE_2_BIT             equ     04h      ;which bit of ulColor should go on plane 2
PLANE_3_BIT             equ     08h      ;which bit of ulColor should go on plane 3

;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Make sure there's something to draw; clip enumerations can be empty.
;-----------------------------------------------------------------------;

        cmp     cRect,0                 ;any more rects to fill?
        je      dfbfill_exit            ;no, we're done

        ;
        ; Set up for the desired raster op.
        ;

        sub     ebx,ebx                 ;ignore any background mix; we're only
        mov     bl,byte ptr ulMix       ; concerned with the foreground in this
                                        ; module
        cmp     ebx,R2_NOP              ;is this NOP?
        jz      dfbfill_exit            ;yes, we're done
        mov     ah,byte ptr ulColor     ;get the drawing color
        and     ah,jForceOffTable[ebx]  ;force color to 0 if necessary
                                        ; (R2_BLACK)
        or      ah,jForceOnTable[ebx]   ;force color to 0ffh if necessary
                                        ; (R2_WHITE)
        xor     ah,jNotTable[ebx]       ;invert color if necessary (any Pn mix)
                                        ;at this point, AH has the color we
                                        ; want to draw with; set up the VGA
                                        ; hardware to draw with that color
        mov     byte ptr ulColor,ah     ;save it!

dfbfill_outer_loop:

;-----------------------------------------------------------------------;
; Set up various variables for the copy.
;
; At this point, EBX = pptlSrc, EDI = pdsurfDst.
;-----------------------------------------------------------------------;
        
        mov     edi,pdsurfDst           ;point to surface to fill (DFB)
        mov     esi,prclDst             ;point to rectangle to fill
        sub     ecx,ecx                 ;accumulate copy control flags
        mov     eax,[esi].xLeft         ;first, check for partial-dword edges
        and     eax,11111b              ;left edge pixel alignment
        jz      short @F                ;whole byte, don't need leading mask
        or      ecx,LEADING_PARTIAL     ;do need leading mask
@@:
        mov     edx,dfbfill_jLeftMasks[eax*4] ;mask to apply to source to clip
        mov     sDfbInfo.LeftMask,edx         ;remember mask
        not     edx
        mov     sDfbInfo.NotLeftMask,edx      ;remember mask

        mov     eax,[esi].xRight
        and     eax,11111b              ;right edge pixel alignment
        jz      short @F                ;whole byte, don't need trailing mask
        or      ecx,TRAILING_PARTIAL    ;do need trailing mask
@@:
        mov     edx,dfbfill_jRightMasks[eax*4] ;mask to apply to source to clip
        mov     sDfbInfo.RightMask,edx         ;remember mask
        not     edx
        mov     sDfbInfo.NotRightMask,edx      ;remember mask



dfbfill_detect_partials::
        mov     sDfbInfo.DstWidth,0     ;overwritten if any whole dwords
                                        ;now, see if there are only partial
                                        ; dwords, or maybe even only one partial
        mov     eax,[esi].xLeft
        add     eax,11111b
        and     eax,not 11111b          ;round left up to nearest dword
        mov     edx,[esi].xRight

        cmp     eax,edx                        ;if left (rounded up) >= right
        jge     short dfbfill_one_partial_only ; only one dword

        and     edx,not 11111b          ;round right down to nearest dword
        sub     edx,eax                 ;# of pixels, rounded to nearest dword
                                        ; boundaries (not counting partials)
        ja      short dfbfill_check_whole_dwords ;there's at least one whole dword

                                        ;there are no whole dwords
                                        ; there are two partial
                                        ; dwords, which is exactly what
                                        ; we're already set up to do

        jmp     short dfbfill_set_copy_control_flags
                      
dfbfill_one_partial_only::              ;only one, partial dword, so construct a
                                        ; single mask and set up to do just
                                        ; one, partial dword
        mov     eax,sDfbInfo.LeftMask
        and     eax,sDfbInfo.RightMask         ;intersect the masks
        mov     sDfbInfo.LeftMask,eax
        not     eax
        mov     sDfbInfo.NotLeftMask,eax
        mov     ecx,LEADING_PARTIAL     ;only one partial dword, which we'll
                                        ; treat as leading
        jmp     short dfbfill_set_copy_control_flags ;the copy control flags are set

dfbfill_check_whole_dwords::
                                        ;finally, calculate the number of whole
                                        ; dwords  we'll process
        shr     edx,5                   ;num_pixels/32
        mov     sDfbInfo.DstWidth,edx   ;save count of whole dwords

dfbfill_set_copy_control_flags::

        mov     edx,dfbfill_pfnScanHandlers[ecx*4] ;proper drawing handler
        mov     pfnDrawScans,edx


;-----------------------------------------------------------------------;
; Set up the offsets to the next source and destination scans.
;
; At this point, EBX = pptlSrc, ESI = prclDst, EDI = pdsurfDst.
;-----------------------------------------------------------------------;

        mov     edx,sDfbInfo.DstWidth ;# of dwords across dest rectangle
        shl     edx,2                 ;# of bytes across dest rectangle
        mov     eax,[edi].dsurf_lNextScan ;# of bytes across 1 scan of dest
        sub     eax,edx         ;offset from end of scan 1 to start of scan 2
        mov     sDfbInfo.DstDelta,eax  
            
;-----------------------------------------------------------------------;
; At this point, ESI = prclDst, EDI = pdsurfDst
;-----------------------------------------------------------------------;

        mov     eax,[edi].dsurf_lNextPlane
        mov     ulBytesPerDstPlane,eax

        mov     eax,[esi].yTop          ;top scan of copy
        imul    eax,[edi].dsurf_lNextScan ;offset of starting scan line
        mov     edx,[esi].xLeft         ;left dest X coordinate
        add     edx,31                  ;round up to dword
        and     edx,not 31
        shr     edx,3                   ;left dest byte offset in row
        add     eax,edx                 ;initial offset in dest bitmap
        add     eax,[edi].dsurf_pvBitmapStart ;initial dest bitmap address
        mov     pDst,eax                ;remember where to start drawing
                
;-----------------------------------------------------------------------;
; At this point, EDI = pdsurfDst
;-----------------------------------------------------------------------;

; Calculate the # of scans to do

        mov     ebx,[esi].yBottom       ;bottom of destination rectangle
        sub     ebx,[esi].yTop          ;# of scans to copy
        mov     sDfbInfo.BurstCountLeft,ebx

;-----------------------------------------------------------------------;
; Copy to the screen in bursts of BurstCountLeft scans.
;-----------------------------------------------------------------------;
             
dfbfill_proceed_with_copy::

;-----------------------------------------------------------------------;
; Copy the DFB scans
;-----------------------------------------------------------------------;

dfbfill_plane_0_scan:

        lea     esi,sDfbInfo            ;points to parameters
        mov     edi,pDst

        mov     eax,ulColor
        and     eax,PLANE_0_BIT         ;if PLANE_0_BIT not set, eax=0
        cmp     eax,1                   ;if eax==0 set CF
        sbb     eax,eax                 ;if CF eax=ffffffff else eax=0
        not     eax                     ;if PLANE_0_BIT was set, eax=ffffffff
                                        ; else eax=0
        call    pfnDrawScans

dfbfill_plane_1_scan:

        mov     eax,ulBytesPerDstPlane
        add     pDst,eax                ;dst scan mod 4 now == 1
                  
        lea     esi,sDfbInfo            ;points to parameters
        mov     edi,pDst

        mov     eax,ulColor
        and     eax,PLANE_1_BIT         ;if PLANE_1_BIT not set, eax=0
        cmp     eax,1                   ;if eax==0 set CF
        sbb     eax,eax                 ;if CF eax=ffffffff else eax=0
        not     eax                     ;if PLANE_1_BIT was set, eax=ffffffff
                                        ; else eax=0
        call    pfnDrawScans

dfbfill_plane_2_scan:

        mov     eax,ulBytesPerDstPlane
        add     pDst,eax                ;dst scan mod 4 now == 2
                  
        lea     esi,sDfbInfo            ;points to parameters
        mov     edi,pDst

        mov     eax,ulColor
        and     eax,PLANE_2_BIT         ;if PLANE_2_BIT not set, eax=0
        cmp     eax,1                   ;if eax==0 set CF
        sbb     eax,eax                 ;if CF eax=ffffffff else eax=0
        not     eax                     ;if PLANE_2_BIT was set, eax=ffffffff
                                        ; else eax=0
        call    pfnDrawScans

dfbfill_plane_3_scan:

        mov     eax,ulBytesPerDstPlane
        add     pDst,eax                ;dst scan mod 4 now == 3
                  
        lea     esi,sDfbInfo            ;points to parameters
        mov     edi,pDst

        mov     eax,ulColor
        and     eax,PLANE_3_BIT         ;if PLANE_3_BIT not set, eax=0
        cmp     eax,1                   ;if eax==0 set CF
        sbb     eax,eax                 ;if CF eax=ffffffff else eax=0
        not     eax                     ;if PLANE_3_BIT was set, eax=ffffffff
                                        ; else eax=0
        call    pfnDrawScans

        add     prclDst,(size RECTL)    ;point to the next rectangle, if there is one
        dec     cRect
        jnz     dfbfill_outer_loop

dfbfill_exit:

        cRet    vDFBFILL                ;done!

endProc vDFBFILL


                                  
;-----------------------------------------------------------------------;
; Fill n scans, no leading partial, no trailing partial
;
; esi->BurstCountLeft:  # scans to do
; esi->DstWidth:        # whole words
; esi->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    ptr to structure of parameters
;                      *edi:    pDst
;                      *eax:    ulColor
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    esi->DstDelta
;-----------------------------------------------------------------------;

fill_dfb_scan_00        proc    near

        mov     ebx,[esi].BurstCountLeft
        mov     edx,[esi].DstDelta

@@:     ; burst loop (do each scan)

        ; main loop

        mov     ecx,[esi].DstWidth      ;load DstWidth (will get trashed)
        rep     stosd                   ;copy DWORDs (destroy CX)

        ; set up for next scan

        add     edi,edx                 ;inc to next scan
        dec     ebx                     ;dec BurstCountLeft 
        jg      @B                      ;if any left, loop

        ret                             ;bye

fill_dfb_scan_00        endp


;-----------------------------------------------------------------------;
; Fill n scans, 0 leading partial, 1 trailing partial
;
; esi->BurstCountLeft:  # scans to do
; esi->DstWidth:        # whole words
; esi->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    ptr to structure of parameters
;                      *edi:    pDst
;                      *eax:    ulColor
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

fill_dfb_scan_01        proc    near

        mov     ebx,[esi].BurstCountLeft

@@:     ; burst loop (do each scan)

        ; main loop

        mov     ecx,[esi].DstWidth      ;load DstWidth (will get trashed)
        rep     stosd                   ;copy DWORDs (destroy CX)        
                                                                         
        ; trailing partial dword

        push    eax                     ;save color for main loop
        mov     edx,[edi]               ;get leading dst dword           
        and     edx,[esi].NotRightMask  ;remove bits that will be filled 
        and     eax,[esi].RightMask     ;remove bits that won't be filled
        or      edx,eax                 ;combine dwords                  
        mov     [edi],edx               ;write leading dword             
        pop     eax                     ;restore color for main loop

        ; set up for next scan

        add     edi,[esi].DstDelta      ;inc to next scan                
        dec     ebx                     ;dec BurstCountLeft              
        jg      @B                      ;if any left, loop

        ret                             ;bye

fill_dfb_scan_01        endp


;-----------------------------------------------------------------------;
; Fill n scans, 1 leading partial, 0 trailing partial
;
; esi->BurstCountLeft:  # scans to do
; esi->DstWidth:        # whole words
; esi->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    ptr to structure of parameters
;                      *edi:    pDst
;                      *eax:    ulColor
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

fill_dfb_scan_10        proc    near

        mov     ebx,[esi].BurstCountLeft

@@:     ; burst loop (do each scan)

        ; leading partial dword

        push    eax                     ;save color for main loop
        mov     edx,[edi-4]             ;get leading dst dword
        and     edx,[esi].NotLeftMask   ;remove bits that will be filled
        and     eax,[esi].LeftMask      ;remove bits that won't be filled
        or      edx,eax                 ;combine dwords
        mov     [edi-4],edx             ;write leading dword
        pop     eax                     ;restore color for main loop

        ; main loop

        mov     ecx,[esi].DstWidth      ;load DstWidth (will get trashed)
        rep     stosd                   ;copy DWORDs (destroy CX)        
                                                                         
        ; set up for next scan

        add     edi,[esi].DstDelta      ;inc to next scan                
        dec     ebx                     ;dec BurstCountLeft              
        jg      @B                      ;if any left, loop

        ret                             ;bye

fill_dfb_scan_10        endp


;-----------------------------------------------------------------------;
; Fill n scans, 1 leading partial, 1 trailing partial
;
; esi->BurstCountLeft:  # scans to do
; esi->DstWidth:        # whole words
; esi->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    ptr to structure of parameters
;                      *edi:    pDst
;                      *eax:    ulColor
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

fill_dfb_scan_11        proc    near

        mov     ebx,[esi].BurstCountLeft

@@:     ; burst loop (do each scan)

        ; leading partial dword

        push    eax                     ;save color for main loop
        mov     edx,[edi-4]             ;get leading dst dword
        and     edx,[esi].NotLeftMask   ;remove bits that will be filled
        and     eax,[esi].LeftMask      ;remove bits that won't be filled
        or      edx,eax                 ;combine dwords
        mov     [edi-4],edx             ;write leading dword
        pop     eax                     ;restore color for main loop

        ; main loop

        mov     ecx,[esi].DstWidth      ;load DstWidth (will get trashed)
        rep     stosd                   ;copy DWORDs (destroy CX)        
                                                                         
        ; trailing partial dword

        push    eax                     ;save color for main loop
        mov     edx,[edi]               ;get leading dst dword           
        and     edx,[esi].NotRightMask  ;remove bits that will be filled 
        and     eax,[esi].RightMask     ;remove bits that won't be filled
        or      edx,eax                 ;combine dwords                  
        mov     [edi],edx               ;write leading dword             
        pop     eax                     ;restore color for main loop

        ; set up for next scan

        add     edi,[esi].DstDelta      ;inc to next scan                
        dec     ebx                     ;dec BurstCountLeft              
        jg      @B                      ;if any left, loop

        ret                             ;bye

fill_dfb_scan_11        endp

                
public dfbfill_jLeftMasks
public dfbfill_jRightMasks
public dfbfill_pfnScanHandlers

public fill_dfb_scan_00
public fill_dfb_scan_01
public fill_dfb_scan_10
public fill_dfb_scan_11

public dfbfill_detect_partials
public dfbfill_one_partial_only
public dfbfill_check_whole_dwords
public dfbfill_set_copy_control_flags
public dfbfill_proceed_with_copy

_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\dfb2vga.asm ===
;---------------------------Module-Header------------------------------;
;
; Module Name:  dfb2vga.asm
;
; Copyright (c) 1993 Microsoft Corporation
;
;-----------------------------------------------------------------------;
;
; VOID vDFB2VGA(DEVSURF * pdsurfDst,
;               DEVSURF * pdsurfSrc,
;               RECTL * prclDst,
;               POINTL * pptlSrc);
;
; Performs accelerated copies from a DFB to the VGA screen.
;
; pdsurfDst = pointer to dest surface
; pdsurfSrc = pointer to source surface
; prclDst =   pointer to rectangle describing target area of dest. VGA
; pptlSrc =   pointer to point structure describing the upper left corner
;             of the copy in the source DFB
;
;-----------------------------------------------------------------------;
;
; Note: Assumes the destination rectangle has a positive height and width.
;       Will not work properly if this is not the case.
;
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc

        .list

;-----------------------------------------------------------------------;

        .data

        align   4

;-----------------------------------------------------------------------;
; Masks to be applied to the source data for the 8 possible clip
; alignments.
;-----------------------------------------------------------------------;
        
dfb_jLeftMasks  label   dword
        dd      0000ffffh          ; if the mask is "byte" backwords,
        dd      0000ff7fh          ; just use db, and divide bytes
        dd      0000ff3fh          ; by "h,0"
        dd      0000ff1fh
        dd      0000ff0fh
        dd      0000ff07h
        dd      0000ff03h
        dd      0000ff01h
        dd      0000ff00h
        dd      00007f00h
        dd      00003f00h
        dd      00001f00h
        dd      00000f00h
        dd      00000700h
        dd      00000300h
        dd      00000100h
                              
                              
dfb_jRightMasks label   dword
        dd      0000ffffh
        dd      00000080h
        dd      000000c0h
        dd      000000e0h
        dd      000000f0h
        dd      000000f8h
        dd      000000fch
        dd      000000feh
        dd      000000ffh
        dd      000080ffh
        dd      0000c0ffh
        dd      0000e0ffh
        dd      0000f0ffh
        dd      0000f8ffh
        dd      0000fcffh
        dd      0000feffh

;-----------------------------------------------------------------------;
; Array of function pointers to handle leading and trailing bytes
;-----------------------------------------------------------------------;

dfb_pfnScanHandlers     label   dword
                dd      draw_dfb_scan_00        ; no alignment cases
                dd      draw_dfb_scan_01
                dd      draw_dfb_scan_10
                dd      draw_dfb_scan_11
                dd      draw_dfb_scan_shr_00    ; shr cases
                dd      draw_dfb_scan_shr_01
                dd      draw_dfb_scan_shr_10
                dd      draw_dfb_scan_shr_11
                dd      draw_dfb_scan_00        ; invalid cases (should be NOPS)
                dd      draw_dfb_scan_01
                dd      draw_dfb_scan_10
                dd      draw_dfb_scan_11
                dd      draw_dfb_scan_shl_00    ; shl cases
                dd      draw_dfb_scan_shl_01
                dd      draw_dfb_scan_shl_10
                dd      draw_dfb_scan_shl_11

;-----------------------------------------------------------------------;

                .code

_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;-----------------------------------------------------------------------;

cProc vDFB2VGA,16,<             \
        uses esi edi ebx,       \
        pdsurfDst: ptr DEVSURF, \
        pdsurfSrc: ptr DEVSURF, \
        prclDst: ptr RECTL,     \
        pptlSrc : ptr POINTL    >

        local   ulBytesPerSrcPlane:dword ;# of bytes in a whole scan line
        local   pfnDrawScans:dword       ;ptr to correct scan drawing function
        local   ulPlaneScans:dword       ;# of scans to copy in burst
        local   pSrc:dword               ;pointer to working drawing src start
                                         ; address (either DFB or temp buffer)
        local   pDst:dword               ;pointer to drawing dst start address
        local   ulCurrentTopScan:dword   ;top scan to copy to in current bank
        local   ulBottomScan:dword       ;bottom scan line of copy rectangle
        local   ulBurstMax:dword         ;max # of scans to be done in a single
                                         ; plane before switching to the next
                                         ; plane (to avoid flicker)
        local   ulCopyControlFlags:dword ;upper bits indicate which portions of
                                         ; copy are to be performed, as follows:
                    
        local   sDfbInfo[size DFBBLT]:byte

TRAILING_PARTIAL        equ     01h      ;partial trailing word should be copied
LEADING_PARTIAL         equ     02h      ;partial leading word should be copied
SOME_SHIFT_NEEDED       equ     04h      ;either right or left shift needed
LEFT_SHIFT_NEEDED       equ     08h      ;required shift is to the left

;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Point to the source start address (nearest dword equal or less).
;-----------------------------------------------------------------------;

        mov     ebx,pptlSrc             ;point to coords of source upper left
        mov     esi,pdsurfSrc           ;point to surface to copy from (DFB4)
        mov     edi,pdsurfDst           ;point to surface to copy to (VGA)
        mov     eax,[ebx].ptl_y
        imul    eax,[esi].dsurf_lNextScan ;offset in bitmap of top src rect scan
        mov     edx,[ebx].ptl_x
        shr     edx,3                   ;source byte X address
        and     edx,not 1b              ;round down to nearest word
        add     eax,edx                 ;offset in bitmap of first source word
        add     eax,[esi].dsurf_pvBitmapStart ;pointer to first source word
        mov     pSrc,eax
        sub     eax,eax
        mov     pDst,eax                ;Init it to zero

;-----------------------------------------------------------------------;
; Set up various variables for the copy.
;
; At this point, EBX = pptlSrc, EDI = pdsurfDst.
;-----------------------------------------------------------------------;

        mov     esi,prclDst             ;point to rectangle to which to copy
        sub     ecx,ecx                 ;accumulate copy control flags
        mov     eax,[esi].xLeft         ;first, check for partial-word edges
        and     eax,1111b               ;left edge pixel alignment
        jz      short @F                ;whole byte, don't need leading mask
        or      ecx,LEADING_PARTIAL     ;do need leading mask
@@:
        mov     edx,dfb_jLeftMasks[eax*4] ;mask to apply to source to clip
        mov     sDfbInfo.LeftMask,edx     ;remember mask

        mov     eax,[esi].xRight
        and     eax,1111b               ;right edge pixel alignment
        jz      short @F                ;whole byte, don't need trailing mask
        or      ecx,TRAILING_PARTIAL    ;do need trailing mask
@@:
        mov     edx,dfb_jRightMasks[eax*4] ;mask to apply to source to clip
        mov     sDfbInfo.RightMask,edx     ;remember mask


dfb_detect_partials::
        mov     sDfbInfo.DstWidth,0        ;overwritten if any whole words
                                        ;now, see if there are only partial
                                        ; words, or maybe even only one partial
        mov     eax,[esi].xLeft
        add     eax,1111b
        and     eax,not 1111b           ;round left up to nearest word
        mov     edx,[esi].xRight
        and     edx,not 1111b           ;round right down to nearest word
        sub     edx,eax                 ;# of pixels, rounded to nearest word
                                        ; boundaries (not counting partials)
        ja      short dfb_check_whole_words ;there's at least one whole word
                                        ;there are no whole words; there may be
                                        ; only one partial word, or there may
                                        ; be two


        jb      short dfb_one_partial_only  ;there is only one, partial word
                                        ;if the dest is left- or right-
                                        ; justified, then there's only one,
                                        ; partial word, otherwise there are two
                                        ; partial words
        cmp     dword ptr sDfbInfo.LeftMask,0ffffh ;left-justified in word?
        jz      short dfb_one_partial_only  ;yes, so only one, partial word
        cmp     dword ptr sDfbInfo.RightMask,0ffffh ;right-justified in word?
        jnz     short dfb_set_copy_control_flags ;no, so there are two partial
                                             ; words, which is exactly what
                                             ; we're already set up to do



dfb_one_partial_only::                  ;only one, partial word, so construct a
                                        ; single mask and set up to do just
                                        ; one, partial word
        mov     eax,sDfbInfo.LeftMask
        and     eax,sDfbInfo.RightMask         ;intersect the masks
        mov     sDfbInfo.LeftMask,eax
        mov     ecx,LEADING_PARTIAL     ;only one partial word, which we'll
                                        ; treat as leading
        jmp     short dfb_set_copy_control_flags ;the copy control flags are set

dfb_check_whole_words::
                                        ;finally, calculate the number of whole
                                        ; words  we'll process
        mov     eax,[esi].xLeft
        add     eax,1111b
        shr     eax,4                   ;round left up to nearest word
        mov     edx,[esi].xRight
        shr     edx,4                   ;round down to nearest word
        sub     edx,eax                 ;# of whole aligned words
        
        mov     sDfbInfo.DstWidth,edx      ;save count of whole words

dfb_set_copy_control_flags::

        mov     ulCopyControlFlags,ecx

;-----------------------------------------------------------------------;
; Determine whether any shift is needed to align the source with the
; destination.
;
; At this point, EBX = pptlSrc, ECX = Copy Control Flags
;                ESI = prclDst, EDI = pdsurfDst.
;-----------------------------------------------------------------------;

        mov     edx,[ebx].ptl_x
        and     edx,1111b       ;source X modulo 16
        mov     eax,[esi].xLeft
        and     eax,1111b       ;dest X modulo 16
        sub     eax,edx         ;(dest X modulo 16) - (src X modulo 16)

;-----------------------------------------------------------------------;
; Start optimization for byte aligned cases.  Code works without this
;-----------------------------------------------------------------------;

        cmp     eax,8
        jne     short @F
        ;
        ; Src starts in lower byte, Dst starts in upper byte
        ;
        dec     pSrc                    ;add unused first byte to src
        sub     eax,eax                 ;set alignment = 0
        jmp     dfb2vga_done_with_byte_aligned_optimze
@@:
        cmp     eax,-8
        jne     short @F
        ;
        ; Src starts in upper byte, Dst starts in lower byte
        ;
        inc     pSrc                    ;remove unused first byte of src
        sub     eax,eax                 ;set alignment = 0
@@:
dfb2vga_done_with_byte_aligned_optimze:

;-----------------------------------------------------------------------;
; End optimization for byte aligned cases.
;-----------------------------------------------------------------------;

        mov     sDfbInfo.AlignShift,eax ;remember the shift

;-----------------------------------------------------------------------;
; Set pfnDrawScans to appropriate function:
;
;       1 1 1 1
;       | | | |______   trailing partial   
;       | | |________   leading partial   
;       |_|__________   align index     00 - no align needed
;                                       01 - right shift needed
;                                       11 - left shift needed
;
;-----------------------------------------------------------------------;
                                
        cmp     sDfbInfo.AlignShift,0

        je      short no_shift          ;flags set by sub above
        jg      short @F
        or      ecx,LEFT_SHIFT_NEEDED   ;shl required
        neg     sDfbInfo.AlignShift     ;take absolute value
@@:
        or      ecx,SOME_SHIFT_NEEDED   ;shl or shr required

no_shift:
        mov     edx,dfb_pfnScanHandlers[ecx*4] ;proper drawing handler
        mov     pfnDrawScans,edx


;-----------------------------------------------------------------------;
; If we're going to have to read from display memory, set up the Graphics
; Controller to point to the Read Map, so we can save some OUTs later.
;
; At this point, EBX = pptlSrc, ECX = ulCopyControlFlags, ESI = prclDst,
; EDI = pdsurfDst.
;-----------------------------------------------------------------------;

        test    ecx,LEADING_PARTIAL or TRAILING_PARTIAL
        jz      short @F
        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_READ_MAP
        out     dx,al   ;leave GRAF_ADDR pointing to Read Map
@@:

;-----------------------------------------------------------------------;
; Set up the offsets to the next source and destination scans.
;
; At this point, EBX = pptlSrc, ESI = prclDst, EDI = pdsurfDst.
;-----------------------------------------------------------------------;

        mov     eax,[esi].xLeft
        shr     eax,4           ;index of first word (including partial)
        mov     edx,[esi].xRight
        add     edx,1111b        
        shr     edx,4           ;index following last word
        sub     edx,eax         ;# of words across dest rectangle
        add     edx,edx         ;# of bytes across dest rectangle
        mov     eax,[edi].dsurf_lNextScan ;# of bytes across 1 scan of vga
        sub     eax,edx         ;offset from last byte dest copied to on one
        mov     ecx,pdsurfSrc
        mov     sDfbInfo.DstDelta,eax  ; scan to first dest byte copied to on next
                      
        ;
        ; use # bytes across dst rect to calculate ulSrcDelta
        ; the src ptr is incremented at the same time as the
        ; dst ptr
        ;

        mov     eax,[ecx].dsurf_lNextPlane
        mov     ulBytesPerSrcPlane,eax ;save for later use
        mov     eax,[ecx].dsurf_lNextScan
        sub     eax,edx         ;offset from last source byte copied from on
        mov     sDfbInfo.SrcDelta,eax  ; one scan to first source byte copied to on
                                ; next

        mov     eax,[esi].xLeft
        mov     edx,[esi].xRight
        sub     edx,eax         ;width in pixels
               
;-----------------------------------------------------------------------;
; Set up the maximum burst size (# of scans to do before switching
; planes).
;
; At this point, EBX = pptlSrc, EDX = width in pixels
;                ESI = prclDst, EDI = pdsurfDst.
;-----------------------------------------------------------------------;

        mov     eax,2           ;assume we'll only do two scans per burst
                                ; (the minimum number)
        test    edx,not 0ffh    ;>511 pixels?
        jnz     short @F        ;yes, so do two scans at a time, to avoid
                                ; flicker as separate planes are done
                                ;***note: this is a tentative value, and
                                ; experience may indicate that it should be
                                ; increased or reduced to 1***
                                ;<512 pixels, so we can do more scans per
                                ; plane, thereby saving lots of OUTs. The exact
                                ; # of scans depends on how wide the copy is;
                                ; the wider it is, the fewer scans
        mov     al,4            ;assume we'll do four scans per plane
        test    dh,1            ;256 or more wide?
        jnz     short @F        ;512>width>=256, four scans will do the job
        mov     al,8            ;assume we'll do eight scans per plane
        add     dl,dl           ;128 or more wide?
        jc      short @F        ;256>width>=128, eight scans is fine
        mov     al,16           ;assume we'll do sixteen scans per plane
        js      short @F        ;128>width>=64, sixteen will do fine
        mov     al,32           ;<64 wide, so we'll do 32 scans per plane
@@:

        mov     ulBurstMax,eax  ;this is the longest burst we'll do in a single
                                ; plane


;-----------------------------------------------------------------------;
; Copy all banks in the destination rectangle, one at a time.
;
; At this point, ESI = prclDst, EDI = pdsurfDst
;-----------------------------------------------------------------------;

dfb_set_initial_banking::

;-----------------------------------------------------------------------;
; Map in the bank containing the top scan to copy to, if it's not mapped
; in already.
;-----------------------------------------------------------------------;

        mov     eax,[esi].yBottom
        mov     ulBottomScan,eax        ;bottom scan to which to copy
        mov     eax,[esi].yTop          ;top scan line of copy
        mov     ulCurrentTopScan,eax    ;this will be the copy top in 1st bank

        cmp     eax,[edi].dsurf_rcl1WindowClip.yTop ;is copy top less than
                                                    ; current bank?
        jl      short dfb_map_init_bank             ;yes, map in proper bank
        cmp     eax,[edi].dsurf_rcl1WindowClip.yBottom ;copy top greater than
                                                       ; current bank?
        jl      short dfb_init_bank_mapped          ;no, proper bank already mapped
dfb_map_init_bank::

; Map in the bank containing the top scan line of the copy dest.

        ptrCall <dword ptr [edi].dsurf_pfnBankControl>,<edi,eax,JustifyTop>

dfb_init_bank_mapped::

;-----------------------------------------------------------------------;
; Compute the starting address for the initial dest bank.
;-----------------------------------------------------------------------;

        mov     eax,ulCurrentTopScan    ;top scan line to which to copy in
                                        ; current bank
        imul    eax,[edi].dsurf_lNextScan ;offset of starting scan line
        mov     edx,[esi].xLeft         ;left dest X coordinate
        shr     edx,3                   ;left dest byte offset in row
        and     edx,not 1               ;round down to word ptr
        add     eax,edx                 ;initial offset in dest bitmap

; Note that the start of the bitmap will change each time through the
; bank loop, because the start of the bitmap is varied to map the
; desired scan line to the banking window.

        add     eax,[edi].dsurf_pvBitmapStart ;initial dest bitmap address
        add     pDst,eax                ;remember where to start drawing
                
;-----------------------------------------------------------------------;
; Main loop for processing copying to each bank.
;
; At this point, EDI->pdsurfDst
;-----------------------------------------------------------------------;

dfb_bank_loop::

; Calculate the # of scans to do in this bank.

        mov     ebx,ulBottomScan        ;bottom of destination rectangle
        cmp     ebx,[edi].dsurf_rcl1WindowClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; dest rect or the bottom of the
                                        ; current bank?
        jl      short @F                ;copy bottom comes first, so draw to
        mov     ebx,[edi].dsurf_rcl1WindowClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
@@:
        sub     ebx,ulCurrentTopScan    ;# of scans to copy in bank

;-----------------------------------------------------------------------;
; Copy to the screen in bursts of either ulBurstMax size or remaining
; number of scans in bank, whichever is less.
;
; At this point, EBX = # of scans remaining in bank.
;-----------------------------------------------------------------------;

dfb_copy_burst_loop::
        mov     eax,ulBurstMax  ;most scans we can copy per plane
        sub     ebx,eax         ;# of scans left in bank after copying that many
        jnle    short @F        ;there are enough scans left to copy max #
        add     eax,ebx         ;not enough scans left; copy all remaining scans
        sub     ebx,ebx         ;after this, no scans remain in bank
@@:
        push    ebx             ;# of scan lines remaining in bank after burst
                                ;EAX = # of scans in burst

        mov     ulPlaneScans,eax ;set the scan count the planes

dfb_proceed_with_copy::

;-----------------------------------------------------------------------;
; Copy the DFB scan to VGA plane 0.
;-----------------------------------------------------------------------;

        mov     esi,pSrc
        mov     edi,pDst

; Map in plane 0 for writes.

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_C0
        out     dx,al                   ; map in plane 0 for writes

        test    ulCopyControlFlags,LEADING_PARTIAL or TRAILING_PARTIAL
        jz      short @F
        mov     edx,VGA_BASE + GRAF_DATA
        mov     al,RM_C0
        out     dx,al                   ; map in plane 0 for reads
@@:

        mov     eax,ulPlaneScans
        mov     sDfbInfo.BurstCountLeft,eax
        mov     eax,pfnDrawScans
        push    ebp                     ;-----------------------------------
        lea     ebp,sDfbInfo            ;WARNING:                           
        call    eax                     ;ebp in use, pfnDrawScans is invalid
        pop     ebp                     ;-----------------------------------

dfb_copy_burst_plane0_done::


;-----------------------------------------------------------------------;
; Copy the DFB scan to VGA plane 1.
;-----------------------------------------------------------------------;

        mov     eax,ulBytesPerSrcPlane
        add     pSrc,eax                ;src scan mod 4 now == 1

        mov     esi,pSrc
        mov     edi,pDst

; Map in plane 1 for writes.

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_C1
        out     dx,al                   ; map in plane 1 for writes

        test    ulCopyControlFlags,LEADING_PARTIAL or TRAILING_PARTIAL
        jz      short @F
        mov     edx,VGA_BASE + GRAF_DATA
        mov     al,RM_C1
        out     dx,al                   ; map in plane 1 for reads
@@:

        mov     eax,ulPlaneScans
        mov     sDfbInfo.BurstCountLeft,eax
        mov     eax,pfnDrawScans
        push    ebp                     ;-----------------------------------
        lea     ebp,sDfbInfo            ;WARNING:                           
        call    eax                     ;ebp in use, pfnDrawScans is invalid
        pop     ebp                     ;-----------------------------------

dfb_copy_burst_plane1_done::


;-----------------------------------------------------------------------;
; Copy the DFB scan to VGA plane 2.
;-----------------------------------------------------------------------;

        mov     eax,ulBytesPerSrcPlane
        add     pSrc,eax                ;src scan mod 4 now == 2

        mov     esi,pSrc
        mov     edi,pDst

; Map in plane 2 for writes.

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_C2
        out     dx,al                   ; map in plane 2 for writes

        test    ulCopyControlFlags,LEADING_PARTIAL or TRAILING_PARTIAL
        jz      short @F
        mov     edx,VGA_BASE + GRAF_DATA
        mov     al,RM_C2
        out     dx,al                   ; map in plane 2 for reads
@@:

        mov     eax,ulPlaneScans
        mov     sDfbInfo.BurstCountLeft,eax
        mov     eax,pfnDrawScans
        push    ebp                     ;-----------------------------------
        lea     ebp,sDfbInfo            ;WARNING:                           
        call    eax                     ;ebp in use, pfnDrawScans is invalid
        pop     ebp                     ;-----------------------------------

dfb_copy_burst_plane2_done::


;-----------------------------------------------------------------------;
; Copy the DFB scan to VGA plane 3.
;-----------------------------------------------------------------------;

        mov     eax,ulBytesPerSrcPlane
        add     pSrc,eax                ;src scan mod 4 now == 3

        mov     esi,pSrc
        mov     edi,pDst

; Map in plane 3 for writes.

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_C3
        out     dx,al                   ; map in plane 3 for writes

        test    ulCopyControlFlags,LEADING_PARTIAL or TRAILING_PARTIAL
        jz      short @F
        mov     edx,VGA_BASE + GRAF_DATA
        mov     al,RM_C3
        out     dx,al                   ; map in plane 3 for reads
@@:

        mov     eax,ulPlaneScans
        mov     sDfbInfo.BurstCountLeft,eax
        mov     eax,pfnDrawScans
        push    ebp                     ;-----------------------------------
        lea     ebp,sDfbInfo            ;WARNING:                           
        call    eax                     ;ebp in use, pfnDrawScans is invalid
        pop     ebp                     ;-----------------------------------

dfb_copy_burst_plane3_done::
        ;
        ; fixup where src ptr is pointing to 
        ;

        sub     esi,ulBytesPerSrcPlane
        sub     esi,ulBytesPerSrcPlane
        sub     esi,ulBytesPerSrcPlane
        mov     pSrc,esi        ;remember where we are, for next burst
        mov     pDst,edi

        pop     ebx             ;get back remaining length in bank
        and     ebx,ebx         ;anything left in this bank?
        jnz     dfb_copy_burst_loop ;continue if so

; Done with bank; are there more banks to do?

        mov     edi,pdsurfDst
        mov     eax,[edi].dsurf_rcl1WindowClip.yBottom ;is the copy bottom in
        cmp     ulBottomScan,eax                       ; the current bank?
        jnle    short dfb_next_bank     ;no, map in the next bank and copy
                                        ; to it
                                        ;yes, we're done
;-----------------------------------------------------------------------;
; Restore default Map Mask and done.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al           ;map in all planes

        cRet    vDFB2VGA        ;done!

;-----------------------------------------------------------------------;
; Advance to the next bank and copy to it.
;-----------------------------------------------------------------------;

dfb_next_bank::
        mov     ulCurrentTopScan,eax    ;remember where the top of the bank
                                        ; we're about to map in is (same as
                                        ; bottom of bank we just did)
        mov     ecx,[edi].dsurf_pvBitmapStart
        sub     pDst,ecx                ;offset of current position in screen

        ptrCall <dword ptr [edi].dsurf_pfnBankControl>,<edi,eax,JustifyTop>
                                        ;map in the bank

        mov     ecx,[edi].dsurf_pvBitmapStart
        add     pDst,ecx                ;pointer to current position in screen

        jmp     dfb_bank_loop               ;copy the next bank

        ret

endProc vDFB2VGA







;-----------------------------------------------------------------------;
; Copy n scans, no alignment, no leading partial, no trailing partial
;
; ebp->BurstCountLeft:  # scans to do
; ebp->DstWidth:    # whole words
; ebp->SrcDelta:        distance from end of one src line to start of next
; ebp->DstDelta:        distance from end of one dst line to start of next
;
; registers used        ebp:    pointer to info struct passed in
;                       eax:    ebp->BurstCountLeft
;                       ebx:    ebp->SrcDelta
;                       ecx:    # whole words for rep
;                       edx:    ebp->DstDelta
;-----------------------------------------------------------------------;

draw_dfb_scan_00        proc    near

        mov     eax,[ebp].BurstCountLeft        
        mov     ebx,[ebp].SrcDelta
        mov     edx,[ebp].DstDelta

@@:
        mov     ecx,[ebp].DstWidth
        rep     movsw
        add     esi,ebx
        add     edi,edx
        dec     eax
        jg      @B

        ret

draw_dfb_scan_00        endp


;-----------------------------------------------------------------------;
; Copy n scans, no alignment, no leading partial, 1 trailing partial
;
; ebp->BurstCountLeft:  # scans to do
; ebp->DstWidth:    # whole words
; ebp->SrcDelta:        distance from end of one src line to start of next
; ebp->DstDelta:        distance from end of one dst line to start of next
;
; registers used        ebp:    pointer to info struct passed in
;                       eax:    ebp->BurstCountLeft
;                       ebx:    dst word of edge
;                       ecx:    # whole words for rep
;                               src word of edge
;                       edx:    not ebp->RightMask
;-----------------------------------------------------------------------;

draw_dfb_scan_01        proc    near

        mov     eax,[ebp].BurstCountLeft
        mov     edx,[ebp].RightMask
        not     edx

@@:
        mov     ecx,[ebp].DstWidth
        rep     movsw
        mov     cx,[esi]                ; src word in cx
        mov     bx,[edi]                ; dst word in bx
        and     ecx,[ebp].RightMask     ; apply left mask to cx
        and     ebx,edx                 ; apply not left mask to bx
        or      ecx,ebx                 ; combine bx into cx
        mov     [edi],cx                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr
        add     esi,[ebp].SrcDelta
        add     edi,[ebp].DstDelta
        dec     eax
        jg      @B

        ret

draw_dfb_scan_01        endp


;-----------------------------------------------------------------------;
; Copy n scans, no alignment, 1 leading partial, no trailing partial
;
; ebp->BurstCountLeft:  # scans to do
; ebp->DstWidth:    # whole words
; ebp->SrcDelta:        distance from end of one src line to start of next
; ebp->DstDelta:        distance from end of one dst line to start of next
;
; registers used        ebp:    pointer to info struct passed in
;                       eax:    ebp->BurstCountLeft
;                       ebx:    dst word of edge
;                       ecx:    # whole words for rep
;                               src word of edge
;                       edx:    not ebp->LeftMask
;-----------------------------------------------------------------------;

draw_dfb_scan_10        proc    near

        mov     eax,[ebp].BurstCountLeft
        mov     edx,[ebp].LeftMask
        not     edx

@@:
        mov     cx,[esi]                ; src word in cx
        mov     bx,[edi]                ; dst word in bx
        and     ecx,[ebp].LeftMask      ; apply left mask to cx
        and     ebx,edx                 ; apply not left mask to bx
        or      ecx,ebx                 ; combine bx into cx
        mov     [edi],cx                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr
        mov     ecx,[ebp].DstWidth
        rep     movsw
        add     esi,[ebp].SrcDelta
        add     edi,[ebp].DstDelta
        dec     eax
        jg      @B

        ret

draw_dfb_scan_10        endp


;-----------------------------------------------------------------------;
; Copy n scans, no alignment, 1 leading partial, 1 trailing partial
;
; ebp->BurstCountLeft:  # scans to do
; ebp->DstWidth:    # whole words
; ebp->SrcDelta:        distance from end of one src line to start of next
; ebp->DstDelta:        distance from end of one dst line to start of next
;
; registers used        ebp:    pointer to info struct passed in
;                       eax:    ebp->BurstCountLeft
;                       ebx:    dst word of edge
;                       ecx:    # whole words for rep
;                               src word of edge
;                       edx:    ebp->LeftMask
;                               not ebp->LeftMask
;                               ebp->RightMask
;                               not ebp->RightMask
;-----------------------------------------------------------------------;

draw_dfb_scan_11        proc    near

        mov     eax,[ebp].BurstCountLeft
        mov     edx,[ebp].RightMask
        not     edx

@@:
        mov     cx,[esi]                ; src word in cx
        mov     bx,[edi]                ; dst word in bx
        mov     edx,[ebp].LeftMask
        and     ecx,edx                 ; apply left mask to cx
        not     edx                     ; negate mask
        and     ebx,edx                 ; apply not left mask to bx
        or      ecx,ebx                 ; combine bx into cx
        mov     [edi],cx                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr
        mov     ecx,[ebp].DstWidth
        rep     movsw
        mov     cx,[esi]                ; src word in cx
        mov     bx,[edi]                ; dst word in bx
        mov     edx,[ebp].RightMask
        and     ecx,edx                 ; apply left mask to cx
        not     edx                     ; negate mask
        and     ebx,edx                 ; apply not left mask to bx
        or      ecx,ebx                 ; combine bx into cx
        mov     [edi],cx                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr
        add     esi,[ebp].SrcDelta
        add     edi,[ebp].DstDelta
        dec     eax
        jg      @B

        ret

draw_dfb_scan_11        endp



        

draw_dfb_scan_shr_00    proc    near

        xor     eax,eax

        mov     ecx,[ebp].DstWidth
        mov     [ebp].Tmp1,ecx          ; load burst counter
        mov     ecx,[ebp].AlignShift

@@:
        dec     [ebp].Tmp1              ; dec burst counter
        jl      short @F
        xor     eax,eax                 ; necessary?
        mov     ax,[esi]                ; src word in ax, undo endian effect
        ror     ax,8                    ; reverse endian
        mov     ebx,[ebp].Tmp2          ; use previous word
        shl     ebx,16
        mov     [ebp].Tmp2,eax          ; save as previous word
        or      eax,ebx
        shr     eax,cl
        ror     ax,8                    ; rotate ax into proper endian format
        mov     [edi],ax                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr
        jmp     @B

@@:
        add     esi,[ebp].SrcDelta
        add     edi,[ebp].DstDelta
        dec     [ebp].BurstCountLeft
        jg      draw_dfb_scan_shr_00

        ret

draw_dfb_scan_shr_00    endp


draw_dfb_scan_shr_01    proc    near

        xor     eax,eax

        mov     ecx,[ebp].DstWidth
        mov     [ebp].Tmp1,ecx          ; load burst counter
        mov     ecx,[ebp].AlignShift

@@:
        dec     [ebp].Tmp1              ; dec burst counter
        jl      short @F
        xor     eax,eax                 ; necessary?
        mov     ax,[esi]                ; src word in ax, undo endian effect
        ror     ax,8                    ; reverse endian
        mov     ebx,[ebp].Tmp2          ; use previous word
        shl     ebx,16
        mov     [ebp].Tmp2,eax          ; save as previous word
        or      eax,ebx
        shr     eax,cl
        ror     ax,8                    ; rotate ax into proper endian format
        mov     [edi],ax                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr
        jmp     @B

@@:
        xor     eax,eax                 ; necessary?
        mov     ax,[esi]                ; src word in ax
        ror     ax,8                    ; reverse endian
        mov     ebx,[ebp].Tmp2          ; use previous word
        shl     ebx,16
        or      eax,ebx
        mov     bx,[edi]                ; dst word in bx
        shr     eax,cl
        ror     ax,8
        mov     edx,[ebp].RightMask
        and     eax,edx                 ; apply left mask to ax
        not     edx                     ; negate mask
        and     ebx,edx                 ; apply not left mask to bx
        or      eax,ebx                 ; combine bx into ax
        mov     [edi],ax                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr

        add     esi,[ebp].SrcDelta
        add     edi,[ebp].DstDelta
        dec     [ebp].BurstCountLeft
        jg      draw_dfb_scan_shr_01

        ret

draw_dfb_scan_shr_01    endp


draw_dfb_scan_shr_10    proc    near

        xor     eax,eax

        mov     ecx,[ebp].DstWidth
        mov     [ebp].Tmp1,ecx          ; load burst counter
        mov     ecx,[ebp].AlignShift

        mov     ax,[esi]                ; src word in ax
        ror     ax,8                    ; reverse endian
        mov     bx,[edi]                ; dst word in bx
        mov     [ebp].Tmp2,eax          ; save as previous word
        shr     eax,cl
        ror     ax,8
        mov     edx,[ebp].LeftMask
        and     eax,edx                 ; apply left mask to ax
        not     edx                     ; negate mask
        and     ebx,edx                 ; apply not left mask to bx
        or      eax,ebx                 ; combine bx into ax
        mov     [edi],ax                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr

@@:
        dec     [ebp].Tmp1              ; dec burst counter
        jl      short @F
        xor     eax,eax                 ; necessary?
        mov     ax,[esi]                ; src word in ax, undo endian effect
        ror     ax,8                    ; reverse endian
        mov     ebx,[ebp].Tmp2          ; use previous word
        shl     ebx,16
        mov     [ebp].Tmp2,eax          ; save as previous word
        or      eax,ebx
        shr     eax,cl
        ror     ax,8                    ; rotate ax into proper endian format
        mov     [edi],ax                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr
        jmp     @B

@@:
        add     esi,[ebp].SrcDelta
        add     edi,[ebp].DstDelta
        dec     [ebp].BurstCountLeft
        jg      draw_dfb_scan_shr_10

        ret

draw_dfb_scan_shr_10    endp


draw_dfb_scan_shr_11    proc    near

        xor     eax,eax

        mov     ecx,[ebp].DstWidth
        mov     [ebp].Tmp1,ecx          ; load burst counter
        mov     ecx,[ebp].AlignShift

        mov     ax,[esi]                ; src word in ax
        ror     ax,8                    ; reverse endian
        mov     bx,[edi]                ; dst word in bx
        mov     [ebp].Tmp2,eax          ; save as previous word
        shr     eax,cl
        ror     ax,8
        mov     edx,[ebp].LeftMask
        and     eax,edx                 ; apply left mask to ax
        not     edx                     ; negate mask
        and     ebx,edx                 ; apply not left mask to bx
        or      eax,ebx                 ; combine bx into ax
        mov     [edi],ax                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr

@@:
        dec     [ebp].Tmp1              ; dec burst counter
        jl      short @F
        xor     eax,eax                 ; necessary?
        mov     ax,[esi]                ; src word in ax, undo endian effect
        ror     ax,8                    ; reverse endian
        mov     ebx,[ebp].Tmp2          ; use previous word
        shl     ebx,16
        mov     [ebp].Tmp2,eax          ; save as previous word
        or      eax,ebx
        shr     eax,cl
        ror     ax,8                    ; rotate ax into proper endian format
        mov     [edi],ax                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr
        jmp     @B

@@:
        xor     eax,eax                 ; necessary?
        mov     ax,[esi]                ; src word in ax
        ror     ax,8                    ; reverse endian
        mov     ebx,[ebp].Tmp2          ; use previous word
        shl     ebx,16
        or      eax,ebx
        shr     eax,cl
        mov     bx,[edi]                ; dst word in bx
        ror     ax,8
        mov     edx,[ebp].RightMask
        and     eax,edx                 ; apply left mask to ax
        not     edx                     ; negate mask
        and     ebx,edx                 ; apply not left mask to bx
        or      eax,ebx                 ; combine bx into ax
        mov     [edi],ax                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr

        add     esi,[ebp].SrcDelta
        add     edi,[ebp].DstDelta
        dec     [ebp].BurstCountLeft
        jg      draw_dfb_scan_shr_11

        ret

draw_dfb_scan_shr_11    endp



        

draw_dfb_scan_shl_00    proc    near

        xor     eax,eax

        mov     ecx,[ebp].DstWidth
        mov     [ebp].Tmp1,ecx          ; load burst counter
        mov     ecx,[ebp].AlignShift

        mov     ax,[esi]                ; src word in ax
        ror     ax,8                    ; reverse endian
        mov     [ebp].Tmp2,eax          ; save as previous word
       
@@:
        dec     [ebp].Tmp1              ; dec burst counter
        jl      short @F
        xor     eax,eax                 ; necessary?
        mov     ax,[esi+2]              ; src word in ax, undo endian effect
        ror     ax,8                    ; reverse endian
        mov     ebx,[ebp].Tmp2          ; use previous word
        mov     [ebp].Tmp2,eax          ; save as previous word
        shl     ebx,16
        or      eax,ebx
        shl     eax,cl
        shr     eax,16

        ror     ax,8                    ; rotate ax into proper endian format
        mov     [edi],ax                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr
        jmp     @B

@@:

        add     esi,[ebp].SrcDelta
        add     edi,[ebp].DstDelta
        dec     [ebp].BurstCountLeft
        jg      draw_dfb_scan_shl_00

        ret

draw_dfb_scan_shl_00    endp


draw_dfb_scan_shl_01    proc    near

        xor     eax,eax

        mov     ecx,[ebp].DstWidth
        mov     [ebp].Tmp1,ecx          ; load burst counter
        mov     ecx,[ebp].AlignShift

        mov     ax,[esi]                ; src word in ax
        ror     ax,8                    ; reverse endian
        mov     [ebp].Tmp2,eax          ; save as previous word
       
@@:
        dec     [ebp].Tmp1              ; dec burst counter
        jl      short @F
        xor     eax,eax                 ; necessary?
        mov     ax,[esi+2]              ; src word in ax, undo endian effect
        ror     ax,8                    ; reverse endian
        mov     ebx,[ebp].Tmp2          ; use previous word
        mov     [ebp].Tmp2,eax          ; save as previous word
        shl     ebx,16
        or      eax,ebx
        shl     eax,cl
        shr     eax,16

        ror     ax,8                    ; rotate ax into proper endian format
        mov     [edi],ax                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr
        jmp     @B

@@:
        xor     eax,eax                 ; necessary?
        mov     ax,[esi+2]              ; src word in ax, undo endian effect
        ror     ax,8                    ; reverse endian
        mov     ebx,[ebp].Tmp2          ; use previous word
        shl     ebx,16
        or      eax,ebx
        shl     eax,cl
        shr     eax,16

        mov     bx,[edi]                ; dst word in bx
        ror     ax,8                    ; rotate ax into proper endian format
        mov     edx,[ebp].RightMask
        and     eax,edx                 ; apply left mask to ax
        not     edx                     ; negate mask
        and     ebx,edx                 ; apply not left mask to bx
        or      eax,ebx                 ; combine bx into ax

        mov     [edi],ax                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr

        add     esi,[ebp].SrcDelta
        add     edi,[ebp].DstDelta
        dec     [ebp].BurstCountLeft
        jg      draw_dfb_scan_shl_01

        ret

draw_dfb_scan_shl_01    endp


draw_dfb_scan_shl_10    proc    near

        xor     eax,eax

        mov     ecx,[ebp].DstWidth
        mov     [ebp].Tmp1,ecx          ; load burst counter
        mov     ecx,[ebp].AlignShift

        mov     ax,[esi]                ; src word in ax
        ror     ax,8                    ; reverse endian
        mov     [ebp].Tmp2,eax          ; save as previous word
       
        mov     ax,[esi+2]              ; src word in ax
        ror     ax,8                    ; reverse endian
        mov     bx,[edi]                ; dst word in bx

        mov     edx,[ebp].Tmp2          ; use previous word
        mov     [ebp].Tmp2,eax          ; save as previous word
        shl     edx,16
        or      eax,edx
        shl     eax,cl
        shr     eax,16

        ror     ax,8
        mov     edx,[ebp].LeftMask
        and     eax,edx                 ; apply left mask to ax
        not     edx                     ; negate mask
        and     ebx,edx                 ; apply not left mask to bx
        or      eax,ebx                 ; combine bx into ax
        mov     [edi],ax                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr

@@:
        dec     [ebp].Tmp1              ; dec burst counter
        jl      short @F
        xor     eax,eax                 ; necessary?
        mov     ax,[esi+2]              ; src word in ax, undo endian effect
        ror     ax,8                    ; reverse endian
        mov     ebx,[ebp].Tmp2          ; use previous word
        mov     [ebp].Tmp2,eax          ; save as previous word
        shl     ebx,16
        or      eax,ebx
        shl     eax,cl
        shr     eax,16

        ror     ax,8                    ; rotate ax into proper endian format
        mov     [edi],ax                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr
        jmp     @B

@@:

        add     esi,[ebp].SrcDelta
        add     edi,[ebp].DstDelta
        dec     [ebp].BurstCountLeft
        jg      draw_dfb_scan_shl_10

        ret

draw_dfb_scan_shl_10    endp


draw_dfb_scan_shl_11    proc    near

        xor     eax,eax

        mov     ecx,[ebp].DstWidth
        mov     [ebp].Tmp1,ecx          ; load burst counter
        mov     ecx,[ebp].AlignShift
                    
        mov     ax,[esi]                ; src word in ax
        ror     ax,8                    ; reverse endian
        mov     [ebp].Tmp2,eax          ; save as previous word
       
        mov     ax,[esi+2]              ; src word in ax
        ror     ax,8                    ; reverse endian
        mov     bx,[edi]                ; dst word in bx

        mov     edx,[ebp].Tmp2          ; use previous word
        mov     [ebp].Tmp2,eax          ; save as previous word
        shl     edx,16
        or      eax,edx
        shl     eax,cl
        shr     eax,16

        ror     ax,8
        mov     edx,[ebp].LeftMask
        and     eax,edx                 ; apply left mask to ax
        not     edx                     ; negate mask
        and     ebx,edx                 ; apply not left mask to bx
        or      eax,ebx                 ; combine bx into ax
        mov     [edi],ax                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr

@@:
        dec     [ebp].Tmp1              ; dec burst counter
        jl      short @F
        xor     eax,eax                 ; necessary?
        mov     ax,[esi+2]              ; src word in ax, undo endian effect
        ror     ax,8                    ; reverse endian
        mov     ebx,[ebp].Tmp2          ; use previous word
        mov     [ebp].Tmp2,eax          ; save as previous word
        shl     ebx,16
        or      eax,ebx
        shl     eax,cl
        shr     eax,16

        ror     ax,8                    ; rotate ax into proper endian format
        mov     [edi],ax                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr
        jmp     @B

@@:
        xor     eax,eax                 ; necessary?
        mov     ax,[esi+2]              ; src word in ax, undo endian effect
        ror     ax,8                    ; reverse endian
        mov     ebx,[ebp].Tmp2          ; use previous word
        shl     ebx,16
        or      eax,ebx
        shl     eax,cl
        shr     eax,16

        mov     bx,[edi]                ; dst word in bx
        ror     ax,8                    ; rotate ax into proper endian format
        mov     edx,[ebp].RightMask
        and     eax,edx                 ; apply left mask to ax
        not     edx                     ; negate mask
        and     ebx,edx                 ; apply not left mask to bx
        or      eax,ebx                 ; combine bx into ax

        mov     [edi],ax                ; write leading word to dst
        add     esi,2                   ; increment src ptr
        add     edi,2                   ; increment dst ptr

        add     esi,[ebp].SrcDelta
        add     edi,[ebp].DstDelta
        dec     [ebp].BurstCountLeft
        jg      draw_dfb_scan_shl_11

        ret

draw_dfb_scan_shl_11    endp



        

public draw_dfb_scan_shr_00
public draw_dfb_scan_shr_01
public draw_dfb_scan_shr_10
public draw_dfb_scan_shr_11
public draw_dfb_scan_shl_00
public draw_dfb_scan_shl_01
public draw_dfb_scan_shl_10
public draw_dfb_scan_shl_11
public draw_dfb_scan_00
public draw_dfb_scan_01
public draw_dfb_scan_10
public draw_dfb_scan_11

public dfb_detect_partials
public dfb_jLeftMasks
public dfb_jRightMasks
public dfb_pfnScanHandlers
public dfb_one_partial_only
public dfb_check_whole_words
public dfb_set_copy_control_flags
public dfb_set_initial_banking
public dfb_map_init_bank
public dfb_init_bank_mapped
public dfb_bank_loop
public dfb_copy_burst_loop
public dfb_proceed_with_copy
public dfb_copy_burst_plane0_done
public dfb_copy_burst_plane1_done
public dfb_copy_burst_plane2_done
public dfb_copy_burst_plane3_done
public dfb_next_bank

_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\display.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: display.inc
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

NUMBER_PLANES   equ     4               ;4 plane format



;       The color structure is how this driver stores its physical
;       colors in memory.  The color consists of four bytes (dword),
;       one byte for each of three planes of color, and a fourth
;       byte which is a combination of one bit from each plane, plus
;       other special information.
;
;       C3Bit will have to be expanded as needed for the fourth plane.


phys_color      struc
pcol_C0         db      ?               ;Plane C0
pcol_C1         db      ?               ;Plane C1
pcol_C2         db      ?               ;Plane C2
pcol_C3         db      ?               ;Plane C3/Monochrome/Special information
phys_color      ends


;       Definitions for the pcol_C3 byte of the physical color
;
;       Some of these definitions have limitations as to when they
;       are valid.  They are as follows:
;
;       C0_BIT          color device, phys color, solid brushes if SOLID_COLOR
;       C1_BIT          color device, phys color, solid brushes if SOLID_COLOR
;       C2_BIT          color device, phys color, solid brushes if SOLID_COLOR
;       C3_BIT          color device, phys color, solid brushes if SOLID_COLOR
;       MONO_BIT        mono  device, phys color
;       ONES_OR_ZEROS   color device, phys color, solid brushes if SOLID_COLOR
;       GREY_SCALE      color device, dithered solid and hatched brushes
;       SOLID_BRUSH     color device, solid brush qualifier
;
;       There may be brushes where the accelerators could have been set,
;       but wasn't.  That's life.


SPECIAL         equ     pcol_C3         ;Special information is here
C0_BIT          equ     00000001b       ;  C0 color
C1_BIT          equ     00000010b       ;  C1 color
C2_BIT          equ     00000100b       ;  C2 color
C3_BIT          equ     00001000b       ;  C3 color
MONO_BIT        equ     00010000b       ;  Monochrome bit
ONES_OR_ZEROS   equ     00100000b       ;  Color is really all 1's or all 0's
GREY_SCALE      equ     01000000b       ;  Indicates a real grey scale brush
SOLID_BRUSH     equ     10000000b       ;  Indicates a solid color brush

        .errnz  (size phys_color) - 4   ;Must be a double word



;       The brush structure is OEM dependant, and can contain whatever
;       information that is needed to realize the given brush.
;
;       For this implementation, the brush will consist of an 8x8
;       pattern for each of the planes, and another 8x8 pattern
;       for monochrome devices and for monochrome to color conversion
;       (for something like a hatched brush, this would contain the
;       monochrome mask used to create the brush).
;
;       The style will also be stored in the brush and is used to
;       catch hollow brushes and exit early.
;
;       A flag specific to the EGA is also stored in the brush.  This
;       flag indicates that the brush is a solid brush and that the
;       color for each plane is a solid color (all 1's or all 0's).
;       Patterns which are solid in each plane can be handle as a
;       special case in Bitblt when the raster op is P or Pn.


SIZE_PATTERN    equ     8               ;Size of an 8 by 8 pattern in bytes


oem_brush_def   struc
oem_brush_C0     db     SIZE_PATTERN dup (?)    ;C0 plane
oem_brush_C1     db     SIZE_PATTERN dup (?)    ;C1 plane
oem_brush_C2     db     SIZE_PATTERN dup (?)    ;C2 plane
oem_brush_C3     db     SIZE_PATTERN dup (?)    ;C3 plane
oem_brush_mono   db     32       dup (?)        ;Mono portion
oem_brush_style  dw     0                       ;Style of the brush
oem_brush_accel  db     0                       ;Accellerator for solids
oem_brush_fg     db     0                       ;current foreground (text) color
oem_brush_bg     db     0                       ;current background color
oem_brush_rwidth db     0                       ;pre expanded width
oem_brush_yshft  db     0                       ;
oem_brush_spar2  db     0                       ;just a fill byte for now
oem_brush_width  dd     0                       ;Width of brush
oem_brush_height dd     0                       ;Height of brush
oem_brush_pmono  dd     0                       ;pointer to mono pattern
oem_brush_def   ends                            ;  (same as "Special" above)

;       Brush styles defined by GDI

BS_SOLID            equ     0
BS_HOLLOW           equ     1
BS_HATCHED          equ     2
BS_PATTERN          equ     3
BS_MONO_PATTERN     equ     4
BS_COLOR_PATTERN    equ     5

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\dib2vga.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: dib2vga.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
;
; VOID vDIB2VGA(DEVSURF * pdsurfDst, DEVSURF * pdsurfSrc,
;               RECTL * prclDst, POINTL * pptlSrc, UCHAR *pConv,
;               BOOL fDfbTrg );
;
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; NOTE: This routine will be entirely unhappy if the area to be copied
;       is wider than 2048 pixels.
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Performs accelerated copies of DIB pixels to the VGA screen.
;
; pdsurfDst = pointer to dest surface, which must be the VGA
;
; pdsurfSrc = pointer to source surface, which must be a 4 bpp DIB. Only the
;       lNextScan and pvBitmapStart fields need to be set
;
; prclDst = pointer to rectangle describing area of VGA to be copied to
;
; pptlSrc = pointer to point structure describing the upper left corner
;           of the copy in the source DIB
;
; pConv = pointer to set of four 256-byte tables used for conversion
;           from DIB4 to VGA, created by vSetDIB4ToVGATables
;
; fDfbTrg = flag set to 0 if target is VGA or 1 if target is DFB
;
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
;
; VOID vSetDIB4ToVGATables(UCHAR * pucConvTable);
;
; Creates the four 256-byte tables used for conversion from DIB4 to VGA.
;
; pucConvTable = pointer to 1K of storage into which the conversion
;                tables are placed
;
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
;
; Note: Assumes the destination rectangle has a positive height and width.
;       Will not work properly if this is not the case.
;
; Note: The source must be a standard DIB4 bitmap, and the destination
;       must be VGA display memory.
;
; Note: Performance would benefit if we did more scans at a time in each
; plane on processor/VGA combinations that supported higher conversion
; and display memory writing speeds.
;
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; [BUGFIX] - byte reads from plane 3 of video memory must be done twice
;            on the VLB CL5434 or they don't always work
;-----------------------------------------------------------------------;

        .486

        .model  small,c

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc

        .list

;-----------------------------------------------------------------------;



; Do not change this value unless you know exactly what you are doing.
; It is used to store up to 32 scans whose number of pixels total 2048
; (or 1024 bytes) or less.  Also, each scan needs an extra dword padding
; for an extra write that always gets done, and an extra dword of padding
; for spacers which are added when shifting right.

BUF_SIZE        equ     (1024+(32*(4+4)))


        .data


;-----------------------------------------------------------------------;
; Masks to be applied to the source data for the 8 possible clip
; alignments.
;-----------------------------------------------------------------------;

jLeftMasks      db   0ffh, 07fh, 03fh, 01fh, 00fh, 007h, 003h, 001h
jRightMasks     db  0ffh, 080h, 0c0h, 0e0h, 0f0h, 0f8h, 0fch, 0feh


                .code

_TEXT$01   SEGMENT PARA USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;-----------------------------------------------------------------------;

cProc vSetDIB4ToVGATables,4,<   \
        uses esi edi ebx,       \
        pucConvTable : dword    >

        mov     ebx,pucConvTable

; Generate the table used to multiplex bits from form accumulated from DIB4
; to VGA planar byte format for plane 0. Translation is from 64207531 source
; DIB format (where 0 is leftmost, 7 is rightmost) to 76543210 VGA
; format (where 7 is leftmost, 0 is rightmost).

        mov     ecx,256
        sub     al,al
plane0_conv_table_loop:
        sub     dl,dl
        mov     ah,al
        and     ah,10h
        shl     ah,3
        or      dl,ah
        mov     ah,al
        and     ah,01h
        shl     ah,6
        or      dl,ah
        mov     ah,al
        and     ah,20h
        or      dl,ah
        mov     ah,al
        and     ah,02h
        shl     ah,3
        or      dl,ah
        mov     ah,al
        and     ah,40h
        shr     ah,3
        or      dl,ah
        mov     ah,al
        and     ah,04h
        or      dl,ah
        mov     ah,al
        and     ah,80h
        shr     ah,6
        or      dl,ah
        mov     ah,al
        and     ah,08h
        shr     ah,3
        or      dl,ah
        mov     [ebx],dl
        inc     al
        inc     ebx
        dec     ecx
        jnz     plane0_conv_table_loop

; Generate the table used to multiplex bits from form accumulated from DIB4
; to VGA planar byte format for plane 1. Translation is from 46025713 source
; DIB format (where 0 is leftmost, 7 is rightmost) to 76543210 VGA
; format (where 7 is leftmost, 0 is rightmost).

        mov     ecx,256
        sub     al,al
plane1_conv_table_loop:
        sub     dl,dl
        mov     ah,al
        and     ah,20h
        shl     ah,2
        or      dl,ah
        mov     ah,al
        and     ah,02h
        shl     ah,5
        or      dl,ah
        mov     ah,al
        and     ah,10h
        shl     ah,1
        or      dl,ah
        mov     ah,al
        and     ah,01h
        shl     ah,4
        or      dl,ah
        mov     ah,al
        and     ah,80h
        shr     ah,4
        or      dl,ah
        mov     ah,al
        and     ah,08h
        shr     ah,1
        or      dl,ah
        mov     ah,al
        and     ah,40h
        shr     ah,5
        or      dl,ah
        mov     ah,al
        and     ah,04h
        shr     ah,2
        or      dl,ah
        mov     [ebx],dl
        inc     al
        inc     ebx
        dec     ecx
        jnz     plane1_conv_table_loop

; Generate the table used to multiplex bits from form accumulated from DIB4
; to VGA planar byte format for plane 2. Translation is from 20643175 source
; DIB format (where 0 is leftmost, 7 is rightmost) to 76543210 VGA
; format (where 7 is leftmost, 0 is rightmost).

        mov     ecx,256
        sub     al,al
plane2_conv_table_loop:
        sub     dl,dl
        mov     ah,al
        and     ah,40h
        shl     ah,1
        or      dl,ah
        mov     ah,al
        and     ah,04h
        shl     ah,4
        or      dl,ah
        mov     ah,al
        and     ah,80h
        shr     ah,2
        or      dl,ah
        mov     ah,al
        and     ah,08h
        shl     ah,1
        or      dl,ah
        mov     ah,al
        and     ah,10h
        shr     ah,1
        or      dl,ah
        mov     ah,al
        and     ah,01h
        shl     ah,2
        or      dl,ah
        mov     ah,al
        and     ah,20h
        shr     ah,4
        or      dl,ah
        mov     ah,al
        and     ah,02h
        shr     ah,1
        or      dl,ah
        mov     [ebx],dl
        inc     al
        inc     ebx
        dec     ecx
        jnz     plane2_conv_table_loop

; Generate the table used to multiplex bits from form accumulated from DIB4
; to VGA planar byte format for plane 1. Translation is from 02461357 source
; DIB format (where 0 is leftmost, 7 is rightmost) to 76543210 VGA
; format (where 7 is leftmost, 0 is rightmost).

        mov     ecx,256
        sub     al,al
plane3_conv_table_loop:
        sub     dl,dl
        mov     ah,al
        and     ah,80h
        or      dl,ah
        mov     ah,al
        and     ah,08h
        shl     ah,3
        or      dl,ah
        mov     ah,al
        and     ah,40h
        shr     ah,1
        or      dl,ah
        mov     ah,al
        and     ah,04h
        shl     ah,2
        or      dl,ah
        mov     ah,al
        and     ah,20h
        shr     ah,2
        or      dl,ah
        mov     ah,al
        and     ah,02h
        shl     ah,1
        or      dl,ah
        mov     ah,al
        and     ah,10h
        shr     ah,3
        or      dl,ah
        mov     ah,al
        and     ah,01h
        or      dl,ah
        mov     [ebx],dl
        inc     al
        inc     ebx
        dec     ecx
        jnz     plane3_conv_table_loop

        cRet    vSetDIB4ToVGATables     ;done

endProc vSetDIB4ToVGATables

;-----------------------------------------------------------------------;

cProc vDIB2VGA,24,<             \
        uses esi edi ebx,       \
        pdsurfDst: ptr DEVSURF, \
        pdsurfSrc: ptr DEVSURF, \
        prclDst: ptr RECTL,     \
        pptlSrc : ptr POINTL,   \
        pConv : dword,          \
        fDfbTrg : dword         >

        local   ulBytesPerPlane:dword    ;# of bytes in a whole scan line
        local   ulDstLeftEdge:dword     ;working copy of prclDst.xLeft
        local   ulDstRightEdge:dword    ;working copy of prclDst.xRight

        local   ulWholeDwordCount:dword ;# of whole VGA dwords to copy to
        local   ulSourceDwordWidth:dword ;# of DIB dwords from which to copy
                                         ; (rounded up to the nearest dword)
        local   ulLeftMask:dword        ;low byte = mask for new pixels at
                                        ; left edge;
                                        ;high byte = mask for dest at left
                                        ; edge;
                                        ;high word = 0ffffh
        local   ulRightMask:dword       ;low byte = mask for new pixels at
                                        ; partial left edge;
                                        ;high byte = mask for destination at
                                        ; partial right edge;
                                        ;high word = 0ffffh
        local   ulPlane0Scans:dword     ;# of scans to copy in plane 0 in burst
        local   ulPlane1Scans:dword     ;# of scans to copy in plane 1 in burst
        local   ulPlane2Scans:dword     ;# of scans to copy in plane 2 in burst
        local   ulPlane3Scans:dword     ;# of scans to copy in plane 3 in burst
        local   ulSrcDelta:dword        ;offset from end of one source scan to
                                        ; copy to start of next in working
                                        ; source (either DIB or temp buffer)
        local   ulTrueSrcDelta:dword    ;offset from end of one source scan to
                                        ; copy to start of next in DIB if temp
                                        ; buffer is being used
        local   ulDstDelta:dword        ;offset from end of one destination
                                        ; scan to copy to start of next
        local   pSrc:dword              ;pointer to working drawing src start
                                        ; address (either DIB or temp buffer)
        local   pTrueSrc:dword          ;pointer to drawing src start address
                                        ; in DIB if temp buffer is being used
        local   pDst:dword              ;pointer to drawing dst start address
        local   pTempBuffer:dword       ;pointer to buffer used for alignment
        local   ulCurrentTopScan:dword  ;top scan to copy to in current bank
        local   ulBottomScan:dword      ;bottom scan line of copy rectangle
        local   ulAlignShift:dword      ;# of bits to shift left (+) or right
                                        ; (-) to dword align source to dest
        local   ulBurstMax:dword        ;max # of scans to be done in a single
                                        ; plane before switching to the next
                                        ; plane (to avoid flicker)
        local   pAlignmentRoutine:dword ;pointer to routine to be used to
                                        ; copy & align the source with the dest
        local   DIB4_to_VGA_plane0_table:dword ;pointers to conversion tables
        local   DIB4_to_VGA_plane1_table:dword ; for the four planes
        local   DIB4_to_VGA_plane2_table:dword
        local   DIB4_to_VGA_plane3_table:dword
        local   ulCopyControlFlags:dword ;upper bits indicate which portions of
                                         ; copy are to be performed, as follows:

        local   aTempBuf[BUF_SIZE]:byte

ODD_WHOLE_WORD  equ     80000000h       ;there are an odd # of VGA words to
                                        ; copy to
        .errnz  ODD_WHOLE_WORD-80000000h ; (note that this *must* be bit 31,
                                         ; because the sign status is used to
                                         ; detect this case)
WHOLE_WORDS     equ     40000000h       ;whole words to be copied
LEADING_BYTE    equ     20000000h       ;leading byte should be copied
TRAILING_BYTE   equ     10000000h       ;trailing byte should be copied
LEADING_PARTIAL equ     08000000h       ;partial leading byte should be copied
TRAILING_PARTIAL equ    04000000h       ;partial trailing byte should be copied


;-----------------------------------------------------------------------;

        cld

        mov     esi,prclDst             ;point to rectangle to which to copy
        mov     eax,[esi].xLeft
        mov     ulDstLeftEdge,eax       ;save working copy of prclDst.xLeft
        mov     edx,[esi].xRight
        mov     ulDstRightEdge,edx      ;save working copy of prclDst.xRight

;-----------------------------------------------------------------------;
; Point to the source start address (nearest dword equal or less).
;-----------------------------------------------------------------------;

        mov     ebx,pptlSrc             ;point to coords of source upper left
        mov     esi,pdsurfSrc           ;point to surface to copy from (DIB4)
        mov     edi,pdsurfDst           ;point to surface to copy to (VGA)
        mov     eax,[ebx].ptl_y
        imul    [esi].dsurf_lNextScan   ;offset in bitmap of top src rect scan
        mov     edx,[ebx].ptl_x
        shr     edx,1                   ;source byte X address
        and     edx,not 11b             ;round down to nearest dword
        add     eax,edx                 ;offset in bitmap of first source dword
        add     eax,[esi].dsurf_pvBitmapStart ;pointer to first source dword
        mov     pSrc,eax

;-----------------------------------------------------------------------;
; Set the pointers to the DIB->VGA conversion tables for the four
; planes; those tables are created at start-up, and found via the PDEV.
;-----------------------------------------------------------------------;

        mov     eax,pConv                       ;first conversion table
        mov     DIB4_to_VGA_plane0_table,eax
        inc     ah                              ;add 256 to point to next table
        mov     DIB4_to_VGA_plane1_table,eax
        inc     ah                              ;add 256 to point to next table
        mov     DIB4_to_VGA_plane2_table,eax
        inc     ah                              ;add 256 to point to next table
        mov     DIB4_to_VGA_plane3_table,eax

;-----------------------------------------------------------------------;
; Set up various variables for the copy.
;
; At this point, EBX = pptlSrc, EDI = pdsurfDst.
;-----------------------------------------------------------------------;

        mov     esi,prclDst             ;point to rectangle to which to copy
        sub     ecx,ecx                 ;accumulate copy control flags, which
                                        ; describe the various portions of the
                                        ; copy we want to perform

                                        ;first, check for partial-byte edges
        mov     eax,ulDstLeftEdge
        and     eax,111b                ;left edge pixel alignment
        jz      short @F                ;whole byte, don't need leading mask
        or      ecx,LEADING_PARTIAL     ;do need leading mask
@@:
        mov     edx,-1                  ;set high word, so copy control bits
                                        ; aren't wiped out by AND
        mov     dl,jLeftMasks[eax]      ;mask to apply to source to clip
        mov     dh,dl
        not     dh                      ;mask to apply to dest to preserve
        mov     ulLeftMask,edx          ;remember mask

        mov     eax,ulDstRightEdge
        and     eax,111b                ;right edge pixel alignment
        jz      short @F                ;whole byte, don't need trailing mask
        or      ecx,TRAILING_PARTIAL    ;do need trailing mask
@@:
        mov     edx,-1                  ;set high word, so copy control bits
                                        ; aren't wiped out by AND
        mov     dl,jRightMasks[eax]     ;mask to apply to source to clip
        mov     dh,dl
        not     dh                      ;mask to apply to dest to preserve
        mov     ulRightMask,edx         ;remember mask

                                        ;now, see if there are only partial
                                        ; bytes, or maybe even only one byte
        mov     eax,ulDstLeftEdge
        add     eax,111b
        and     eax,not 111b            ;round left up to nearest byte
        mov     edx,ulDstRightEdge
        and     edx,not 111b            ;round right down to nearest byte
        sub     edx,eax                 ;# of pixels, rounded to nearest byte
                                        ; boundaries (not counting partials)
        ja      short check_whole_bytes ;there's at least one whole byte
                                        ;there are no whole bytes; there may be
                                        ; only one partial byte, or there may
                                        ; be two
        jb      short one_partial_only  ;there is only one, partial byte
                                        ;if the dest is left- or right-
                                        ; justified, then there's only one,
                                        ; partial byte, otherwise there are two
                                        ; partial bytes
        cmp     byte ptr ulLeftMask,0ffh ;left-justified in byte?
        jz      short one_partial_only  ;yes, so only one, partial byte
        cmp     byte ptr ulRightMask,0ffh ;right-justified in byte?
        jnz     short set_copy_control_flags ;no, so there are two partial
                                             ; bytes, which is exactly what
                                             ; we're already set up to do
one_partial_only::                      ;only one, partial byte, so construct a
                                        ; single mask and set up to do just
                                        ; one, partial byte
        mov     eax,ulLeftMask
        and     eax,ulRightMask         ;intersect the masks
        mov     ah,al
        not     ah                      ;construct the destination mask
        mov     ulLeftMask,eax
        mov     ecx,LEADING_PARTIAL     ;only one partial byte, which we'll
                                        ; treat as leading
        jmp     short set_copy_control_flags ;the copy control flags are set

        align   4
check_whole_bytes::
                                        ;check for leading and trailing odd
                                        ; (non-word-aligned) whole bytes
        mov     eax,ulDstLeftEdge         ;check for leading whole byte
        and     eax,1111b               ;intra-word address
        jz      short @F                ;whole leading word, so no whole byte
        cmp     eax,8                   ;is start at or before second byte
                                        ; start?
        ja      short @F                ;no, so no whole byte
        or      ecx,LEADING_BYTE        ;yes, there's a leading byte
@@:

        mov     eax,ulDstRightEdge        ;check for trailing whole byte
        and     eax,1111b               ;intra-word address
        jz      short @F                ;whole trailing word, so no whole byte
        cmp     eax,8                   ;is start before second byte start?
        jb      short @F                ;no, so no whole byte
        or      ecx,TRAILING_BYTE       ;yes, there's a trailing byte
@@:

                                        ;finally, calculate the number of whole
                                        ; aligned words and pairs thereof we'll
                                        ; process
        mov     eax,ulDstLeftEdge
        add     eax,1111b
        shr     eax,4                   ;round left up to nearest word
        mov     edx,ulDstRightEdge
        shr     edx,4                   ;round down to nearest word
        sub     edx,eax                 ;# of whole aligned words
        jz      short set_copy_control_flags ;no whole aligned words
        or      ecx,WHOLE_WORDS         ;mark that we have whole aligned words
        inc     edx
        shr     edx,1                   ;# of whole dwords, or fractions
        mov     ulWholeDwordCount,edx   ; thereof
        jc      short set_copy_control_flags ;no odd word
        or      ecx,ODD_WHOLE_WORD      ;mark that we have an odd word to copy

set_copy_control_flags::
        mov     ulCopyControlFlags,ecx

;-----------------------------------------------------------------------;
; If we're going to have to read from display memory, set up the Graphics
; Controller to point to the Read Map, so we can save some OUTs later.
;
; At this point, EBX = pptlSrc, ECX = ulCopyControlFlags, ESI = prclDst,
; EDI = pdsurfDst.
;-----------------------------------------------------------------------;

        cmp     fDfbTrg,0               ;if DbfTrg flag set...
        jne     @F                      ;skip VGA specific code

        test    ecx,LEADING_PARTIAL or TRAILING_PARTIAL
        jz      short @F
        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_READ_MAP
        out     dx,al   ;leave GRAF_ADDR pointing to Read Map
@@:

;-----------------------------------------------------------------------;
; Set up the offsets to the next source and destination scans.
;
; At this point, EBX = pptlSrc, ESI = prclDst, EDI = pdsurfDst.
;-----------------------------------------------------------------------;

        mov     eax,ulDstLeftEdge
        shr     eax,3           ;left edge byte
        mov     edx,ulDstRightEdge
        add     edx,111b        ;byte after right edge
        shr     edx,3
        sub     edx,eax         ;# of bytes across dest
        mov     eax,[edi].dsurf_lNextPlane
        mov     ulBytesPerPlane,eax ;save for later use
        mov     eax,[edi].dsurf_lNextScan

        sub     eax,edx         ;offset from last byte dest copied to on one
        mov     ulDstDelta,eax  ; scan to first dest byte copied to on next

        mov     ecx,pdsurfSrc
        mov     eax,ulDstLeftEdge
        mov     edx,ulDstRightEdge
        sub     edx,eax         ;width in pixels
        push    edx             ;remember width in pixels
        mov     eax,[ebx].ptl_x ;source left edge
        add     edx,eax         ;source right edge
        shr     eax,1           ;source left start byte
        and     eax,not 11b     ;source left start rounded to nearest dword
        inc     edx
        shr     edx,1           ;source right byte after last byte copied
        add     edx,11b
        and     edx,not 11b     ;round up to source right dword after last byte
                                ; copied
        sub     edx,eax         ;source width in bytes, rounded to dwords
                                ; (because we always work with source dwords)
        mov     eax,[ecx].dsurf_lNextScan
        sub     eax,edx         ;offset from last source byte copied from on
        mov     ulSrcDelta,eax  ; one scan to first source byte copied to on
                                ; next

;-----------------------------------------------------------------------;
; Set up the maximum burst size (# of scans to do before switching
; planes).
;
; At this point, EBX = pptlSrc, ESI = prclDst, EDI = pdsurfDst.
;-----------------------------------------------------------------------;

        pop     edx             ;retrieve width in pixels
        mov     eax,1           ;assume we'll only do one scan per burst
                                ; (the minimum number)
        test    edx,not 3ffh    ;>1023 pixels?
        jnz     short @F        ;yes, so do one scan at a time, to avoid
                                ; flicker as separate planes are done

                                ;<1024 pixels, so we can do more scans per
                                ; plane, thereby saving lots of OUTs. The exact
                                ; # of scans depends on how wide the copy is;
                                ; the wider it is, the fewer scans
        add     eax,eax         ;try 2 per plane
        test    edx,not 1ffh    ;>511 pixels?
        jnz     short @F        ;yes, so do two scans at a time
        mov     al,4            ;assume we'll do four scans per plane
        test    dh,1            ;256 or more wide?
        jnz     short @F        ;512>width>=256, four scans will do the job
        mov     al,8            ;assume we'll do eight scans per plane
        add     dl,dl           ;128 or more wide?
        jc      short @F        ;256>width>=128, eight scans is fine
        mov     al,16           ;assume we'll do sixteen scans per plane
        js      short @F        ;128>width>=64, sixteen will do fine
        mov     al,32           ;<64 wide, so we'll do 32 scans per plane
@@:
        mov     ulBurstMax,eax  ;this is the longest burst we'll do in a single
                                ; plane

;-----------------------------------------------------------------------;
; Determine whether any shift is needed to align the source with the
; destination.
;
; At this point, EBX = pptlSrc, ESI = prclDst, EDI = pdsurfDst.
;-----------------------------------------------------------------------;


        mov     eax,[ebx].ptl_x
        and     eax,111b        ;source X modulo 8
        mov     edx,ulDstLeftEdge
        and     edx,111b        ;dest X modulo 8
        sub     eax,edx         ;(source X modulo 8) - (dest X modulo 8)
        mov     ulAlignShift,eax ;remember the shift
        jz      set_initial_banking ;if it's 0, we have no alignment to
                                    ; do, and are ready to roll

;-----------------------------------------------------------------------;
; Alignment is needed, so set up the alignment variables.
;
; At this point, EBX = pptlSrc, ESI = prclDst, EDI = pdsurfDst,
;  EAX = shift, in range -7 to 7.
;-----------------------------------------------------------------------;

        mov     edx,ulSrcDelta     ;remember the real source width; we'll fake
        mov     ulTrueSrcDelta,edx ; ulSrcDelta for the drawing routines

                                ;set ulSrcDelta to either 0 or 4,
                                ; depending on whether the last dword
                                ; we rotate is needed (because we
                                ; always generate as many dest dwords as
                                ; there are source dwords on left shifts,
                                ; and we always generate dest dwords = # source
                                ; dwords + 1 on right shifts, whether we need
                                ; the last dword or not; we only need it when
                                ; the right edge shifts left)
        mov     ecx,ulDstRightEdge
        sub     ecx,ulDstLeftEdge
        add     ecx,[ebx].ptl_x ;CL = lsb of source right edge
        dec     ecx             ;adjust to actual right X, rather than X+1
        mov     ch,byte ptr ulDstRightEdge ;CH = lsb of dest right edge
        dec     ch              ;adjust to actual right X, rather than X+1
        and     ecx,0707h       ;right source and dest intrabyte addresses
        sub     edx,edx         ;assume we need the last byte, in which case
                                ; the source in the temp buffer (from which we
                                ; always copy after rotation) is contiguous
        cmp     ch,cl           ;right or left shift at right edge?
        jb      short @F        ;left shift at right edge, so every byte in the
                                ; temp buffer will be used
        add     edx,4           ;right shift at right edge, so the last byte in
                                ; the temp buffer won't be used, thus skip it
@@:
        mov     ulSrcDelta,edx  ;delta to next scan in temp buffer

        and     eax,eax         ;shift left or right?
        js      short @F        ;shift right
                                ;shift left

        mov     edx,offset align_burst_lshift_486 ;shifting left, assume 486
        jmp     short set_shift_vec     ;486

        align   4
@@:                             ;shifting right

        and     eax,7           ;for left shift, shift value is already
                                ; correct; for right shift, this is equivalent
                                ; to 8 - right shift, since we always shift
                                ; left (remember, EAX is currently negative for
                                ; right shifts)
        mov     edx,offset align_burst_rshift_486 ;486
set_shift_vec::
        mov     pAlignmentRoutine,edx   ;routine to be used to shift into
                                        ; alignment with destination
        shl     eax,2           ;multiply by 4 because we're dealing with
                                ; 4-bit pixels
        mov     ulAlignShift,eax ;remember the shift amount
        mov     eax,ulDstRightEdge
        sub     eax,ulDstLeftEdge ;pixel width of rectangle to copy
        mov     edx,[ebx].ptl_x ;left pixel of source
        and     edx,111b        ;distance in pixels from left pixel to pixel at
                                ; start of left dword
        add     eax,edx         ;pixel width from start of left dword to right
                                ; edge of copy in source
        add     eax,7           ;round up to nearest dword (8 pixel set)
        shr     eax,3           ;# of dwords spanned by source
        mov     ulSourceDwordWidth,eax ;always pick up this number of dwords
                                       ; when aligning

        lea     eax,aTempBuf    ;use 2K stack buffer as temp storage
        mov     pTempBuffer,eax ; temporary-use buffer

        mov     eax,pSrc        ;remember the real source pointer; we'll fake
        mov     pTrueSrc,eax    ; pSrc for the drawing routines

;-----------------------------------------------------------------------;
; Copy all banks in the destination rectangle, one at a time.
;
; At this point, ESI = prclDst, EDI = pdsurfDst
;-----------------------------------------------------------------------;

set_initial_banking::

;-----------------------------------------------------------------------;
; Map in the bank containing the top scan to copy to, if it's not mapped
; in already.
;-----------------------------------------------------------------------;

        mov     eax,[esi].yBottom
        mov     ulBottomScan,eax        ;bottom scan to which to copy
        mov     eax,[esi].yTop          ;top scan line of copy
        mov     ulCurrentTopScan,eax    ;this will be the copy top in 1st bank

        cmp     fDfbTrg,0               ;if DbfTrg flag set...
        jne     init_bank_mapped        ;skip banking code

        cmp     eax,[edi].dsurf_rcl1WindowClip.yTop ;is copy top less than
                                                    ; current bank?
        jl      short map_init_bank             ;yes, map in proper bank
        cmp     eax,[edi].dsurf_rcl1WindowClip.yBottom ;copy top greater than
                                                       ; current bank?
        jl      short init_bank_mapped          ;no, proper bank already mapped
map_init_bank::

; Map in the bank containing the top scan line of the copy dest.

        ptrCall <dword ptr [edi].dsurf_pfnBankControl>,<edi,eax,JustifyTop>

init_bank_mapped::

;-----------------------------------------------------------------------;
; Compute the starting address for the initial dest bank.
;-----------------------------------------------------------------------;

        mov     eax,ulCurrentTopScan    ;top scan line to which to copy in
                                        ; current bank
        imul    [edi].dsurf_lNextScan   ;offset of starting scan line
        mov     edx,ulDstLeftEdge         ;left dest X coordinate
        shr     edx,3                   ;left dest byte offset in row
        add     eax,edx                 ;initial offset in dest bitmap

; Note that the start of the bitmap will change each time through the
; bank loop, because the start of the bitmap is varied to map the
; desired scan line to the banking window.

        add     eax,[edi].dsurf_pvBitmapStart ;initial dest bitmap address
        mov     pDst,eax                ;remember where to start drawing

;-----------------------------------------------------------------------;
; Main loop for processing copying to each bank.
;
; At this point, EDI->pdsurfDst
;-----------------------------------------------------------------------;

bank_loop::

; Calculate the # of scans to do in this bank.

        mov     ebx,ulBottomScan        ;bottom of destination rectangle

        cmp     fDfbTrg,0               ;if DbfTrg flag set...
        jne     @F                      ;skip banking code

        cmp     ebx,[edi].dsurf_rcl1WindowClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; dest rect or the bottom of the
                                        ; current bank?
        jl      short @F                ;copy bottom comes first, so draw to
                                        ; that; this is the last bank in copy
        mov     ebx,[edi].dsurf_rcl1WindowClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
@@:
        sub     ebx,ulCurrentTopScan    ;# of scans to copy in bank

;-----------------------------------------------------------------------;
; Copy to the screen in bursts of either ulBurstMax size or remaining
; number of scans in bank, whichever is less.
;
; At this point, EBX = # of scans remaining in bank.
;-----------------------------------------------------------------------;

copy_burst_loop::
        mov     eax,ulBurstMax  ;most scans we can copy per plane
        sub     ebx,eax         ;# of scans left in bank after copying that many
        jnle    short @F        ;there are enough scans left to copy max #
        add     eax,ebx         ;not enough scans left; copy all remaining scans
        sub     ebx,ebx         ;after this, no scans remain in bank
@@:
        push    ebx             ;# of scan lines remaining in bank after burst
                                ;EAX = # of scans in burst
        mov     ulPlane0Scans,eax ;set the scan count for each of the plane
        mov     ulPlane1Scans,eax ; loops
        mov     ulPlane2Scans,eax
        mov     ulPlane3Scans,eax

;-----------------------------------------------------------------------;
; If necessary, align the dwords in this burst so that the left edge is
; on a dword boundary.
;
; At this point, AL = # of scans in burst.
;-----------------------------------------------------------------------;

        mov     ecx,ulAlignShift
        and     ecx,ecx         ;is alignment needed?
        jz      proceed_with_copy  ;no, so we're ready to copy

        mov     ch,al           ;# of scans to copy
        mov     esi,pTrueSrc    ;copy from current source location
        mov     edi,pTempBuffer ;copy to the temp buffer

        jmp     pAlignmentRoutine ;perform the copy

;-----------------------------------------------------------------------;
; Loops to align this burst's scans for left or right shift.
;
; Input: CH = # of scans to copy in this burst (max burst = 256)
;        CL = # of bits to shift left to dword align
;        ESI = first dword of first DIB scan to convert
;        EDI = first dword of buffer into which to shift
;        ulSourceDwordWidth = # of dwords across source
;        ulTrueSrcDelta = distance from end of one source scan (rounded up to
;               nearest dword) to start of next
;
; All loops alway flush (write) the last dword, so one more dword
; is written to the dest than is read from the source. This requires the
; dest buffer to have room for an extra dword.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Macro to copy and align the current burst for left shift.
;-----------------------------------------------------------------------;

ALIGN_BURST_LSHIFT macro Is486
        local   align_burst_lshift_loop,align_last_lshift,align_odd_lshift
        local   align_lshift_loop
align_burst_lshift_loop:
        mov     ebx,ulSourceDwordWidth ;# of dwords across source
        mov     edx,[esi]       ;load the initial source dword
        add     esi,4           ;point to next source dword
        bswap   edx             ;make it big endian
        dec     ebx             ;any more dwords to shift?
        jz      short align_last_lshift ;no, do just this one
        inc     ebx
        shr     ebx,1           ;double dword count
        jnc     short align_odd_lshift ;do odd dword
        align   4
align_lshift_loop:
        mov     eax,[esi]       ;get next dword to align
        add     esi,4           ;point to next source dword
        bswap   eax             ;make it big endian
        shld    edx,eax,cl      ;shift to generate a 32-bit shifted value
        bswap   edx             ;make it big endian
        mov     [edi],edx       ;store it
        add     edi,4           ;point to next dest dword
        mov     edx,eax         ;set up for the next shift
align_odd_lshift:
        mov     eax,[esi]       ;get next dword to align
        add     esi,4           ;point to next source dword
        bswap   eax             ;make it big endian
        shld    edx,eax,cl      ;shift to generate a 32-bit shifted value
        bswap   edx             ;make it big endian
        mov     [edi],edx       ;store it
        add     edi,4           ;point to next dest dword
        mov     edx,eax         ;set up for the next shift
        dec     ebx             ;count down dwords to shift
        jnz     align_lshift_loop ;do next dword, if any
align_last_lshift:              ;do the last dword, which doesn't require a
                                ; new source byte
        shl     edx,cl          ;shift it into position
        bswap   edx             ;make it big endian
        mov     [edi],edx       ;store it
        add     edi,4           ;point to next dest dword

        add     esi,ulTrueSrcDelta ;point to next source scan
        dec     ch              ;count down scans in burst
        jnz     align_burst_lshift_loop
        ENDM    ;ALIGN_BURST_LSHIFT

;-----------------------------------------------------------------------;
; Macro to copy and align the current burst for right shift.
;-----------------------------------------------------------------------;

ALIGN_BURST_RSHIFT macro Is486
        local   align_burst_rshift_loop,align_odd_rshift,align_rshift_loop
align_burst_rshift_loop:
        mov     ebx,ulSourceDwordWidth ;# of dwords across source
        inc     ebx
        shr     ebx,1           ;double dword count
        jnc     short align_odd_rshift ;do odd dword
        align   4
align_rshift_loop:
        mov     eax,[esi]       ;get next dword to align
        add     esi,4           ;point to next source dword
        bswap   eax             ;make it big endian
        shld    edx,eax,cl      ;shift to generate a 32-bit shifted value
        bswap   edx             ;make it little endian
        mov     [edi],edx       ;store it
        add     edi,4           ;point to next dest dword
        mov     edx,eax         ;set up for the next shift
align_odd_rshift:
        mov     eax,[esi]       ;get next dword to align
        add     esi,4           ;point to next source dword
        bswap   eax             ;make it big endian
        shld    edx,eax,cl      ;shift to generate a 32-bit shifted value
        bswap   edx             ;make it little endian
        mov     [edi],edx       ;store it
        add     edi,4           ;point to next dest dword
        mov     edx,eax         ;set up for the next shift
        dec     ebx             ;count down dwords to shift
        jnz     align_rshift_loop ;do next dword, if any

                                ;do the trailing destination dword
        shl     edx,cl          ;shift into position
        bswap   edx             ;make it little endian
        mov     [edi],edx       ;store it
        add     edi,4           ;point to next dest dword

        add     esi,ulTrueSrcDelta ;point to next source scan
        dec     ch              ;count down scans in burst
        jnz     align_burst_rshift_loop
        ENDM    ;ALIGN_BURST_RSHIFT
;-----------------------------------------------------------------------;

        align   4
align_burst_rshift_486::
        ALIGN_BURST_RSHIFT 1
        jmp     short set_alignment_source

        align   4
align_burst_lshift_486::
        ALIGN_BURST_LSHIFT 1

;-----------------------------------------------------------------------;
; Set up the pointers for a copy from the temp buffer, and advance the
; real pointer.
;-----------------------------------------------------------------------;
set_alignment_source::
        mov     pTrueSrc,esi    ;remember where to start next time in source
        mov     esi,pTempBuffer ;copy from the temp buffer
        mov     pSrc,esi        ;remember where the copy source is (DIB or
                                ; temp buffer)

proceed_with_copy::

; Load ECX with the copy control flags; this stays set throughout the
; copying of this burst.

        mov     ecx,ulCopyControlFlags

; Copy the DIB scan to VGA plane 0.

        mov     esi,pSrc
        mov     edi,pDst

        cmp     fDfbTrg,0               ;if DbfTrg flag set...
        jne     @F                      ;skip VGA specific code

; Map in plane 0 for writes.

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_C0
        out     dx,al   ;map in plane 0 for writes (SEQ_ADDR points to the Map
                        ; Mask by default)

; Map in plane 0 for reads if and only if we need to handle partial edge
; bytes, which require read/modify/write cycles.

        test    ecx,LEADING_PARTIAL or TRAILING_PARTIAL
        jz      short @F
        mov     edx,VGA_BASE + GRAF_DATA
        mov     al,RM_C0
        out     dx,al   ;map in plane 0 for reads (GRAF_ADDR already points to
                        ; Read Map)
@@:
        jmp     DIB4_to_VGA_plane0_copy

        align   4
copy_burst_plane0_done::

; Copy the DIB scan to VGA plane 1.

        cmp     fDfbTrg,0               ;if DbfTrg flag NOT set...
        je      @F                      ;skip DFB specific code
        mov     eax,ulBytesPerPlane
        add     pDst,eax                ;dest scan mod 4 now == 1
@@:
        mov     esi,pSrc
        mov     edi,pDst

        cmp     fDfbTrg,0               ;if DbfTrg flag set...
        jne     @F                      ;skip VGA specific code

; Map in plane 1 for writes.

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_C1
        out     dx,al   ;map in plane 1 for writes (SEQ_ADDR points to the Map
                        ; Mask by default)

; Map in plane 1 for reads if and only if we need to handle partial edge
; bytes, which require read/modify/write cycles.

        test    ecx,LEADING_PARTIAL or TRAILING_PARTIAL
        jz      short @F
        mov     edx,VGA_BASE + GRAF_DATA
        mov     al,RM_C1
        out     dx,al   ;map in plane 1 for reads (GRAF_ADDR already points to
                        ; Read Map)
@@:
        jmp     DIB4_to_VGA_plane1_copy

        align   4
copy_burst_plane1_done::

; Copy the DIB scan to VGA plane 2.

        cmp     fDfbTrg,0               ;if DbfTrg flag NOT set...
        je      @F                      ;skip DFB specific code
        mov     eax,ulBytesPerPlane
        add     pDst,eax                ;dest scan mod 4 now == 2
@@:
        mov     esi,pSrc
        mov     edi,pDst

        cmp     fDfbTrg,0               ;if DbfTrg flag set...
        jne     @F                      ;skip VGA specific code

; Map in plane 2 for writes.

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_C2
        out     dx,al   ;map in plane 2 for writes (SEQ_ADDR points to the Map
                        ; Mask by default)

; Map in plane 2 for reads if and only if we need to handle partial edge
; bytes, which require read/modify/write cycles.

        test    ecx,LEADING_PARTIAL or TRAILING_PARTIAL
        jz      short @F
        mov     edx,VGA_BASE + GRAF_DATA
        mov     al,RM_C2
        out     dx,al   ;map in plane 2 for reads (GRAF_ADDR already points to
                        ; Read Map)
@@:
        jmp     DIB4_to_VGA_plane2_copy

        align   4
copy_burst_plane2_done::

; Copy the DIB scan to VGA plane 3.

        cmp     fDfbTrg,0               ;if DbfTrg flag NOT set...
        je      @F                      ;skip DFB specific code
        mov     eax,ulBytesPerPlane
        add     pDst,eax                ;dest scan mod 4 now == 3
@@:
        mov     esi,pSrc
        mov     edi,pDst

        cmp     fDfbTrg,0               ;if DbfTrg flag set...
        jne     @F                      ;skip VGA specific code

; Map in plane 3 for writes.

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_C3
        out     dx,al   ;map in plane 3 for writes (SEQ_ADDR points to the Map
                        ; Mask by default)

; Map in plane 3 for reads if and only if we need to handle partial edge
; bytes, which require read/modify/write cycles.

        test    ecx,LEADING_PARTIAL or TRAILING_PARTIAL
        jz      short @F
        mov     edx,VGA_BASE + GRAF_DATA
        mov     al,RM_C3
        out     dx,al   ;map in plane 3 for reads (GRAF_ADDR already points to
                        ; Read Map)
@@:
        jmp     DIB4_to_VGA_plane3_copy

        align   4
copy_burst_plane3_done::

        mov     pSrc,esi        ;remember where we are, for next burst
        mov     pDst,edi

        pop     ebx             ;get back remaining length in bank
        and     ebx,ebx         ;anything left in this bank?
        jnz     copy_burst_loop ;continue if so

; Done with bank; are there more banks to do?

        cmp     fDfbTrg,0               ;if DbfTrg flag set...
        jne     @F                      ;skip banking and VGA code

        mov     edi,pdsurfDst
        mov     eax,[edi].dsurf_rcl1WindowClip.yBottom ;is the copy bottom in
        cmp     ulBottomScan,eax                       ; the current bank?
        jnle    short next_bank         ;no, map in the next bank and copy to
                                        ; it
                                        ;yes, we're done
@@:

;-----------------------------------------------------------------------;
; Restore default Map Mask and done.
;-----------------------------------------------------------------------;

        cmp     fDfbTrg,0               ;if DbfTrg flag set...
        jne     @F                      ;skip VGA specific code

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al           ;map in all planes
@@:
        cRet    vDIB2VGA        ;done!

;-----------------------------------------------------------------------;
; Advance to the next bank and copy to it.
;-----------------------------------------------------------------------;
        align   4
next_bank::
        mov     ulCurrentTopScan,eax    ;remember where the top of the bank
                                        ; we're about to map in is (same as
                                        ; bottom of bank we just did)
        mov     ecx,[edi].dsurf_pvBitmapStart
        sub     pDst,ecx                ;offset of current position in screen

        ptrCall <dword ptr [edi].dsurf_pfnBankControl>,<edi,eax,JustifyTop>
                                        ;map in the bank

        mov     ecx,[edi].dsurf_pvBitmapStart
        add     pDst,ecx                ;pointer to current position in screen

        jmp     bank_loop               ;copy the next bank

;-----------------------------------------------------------------------;
; Loops for converting 1 or more scans in each of planes 0, 1, 2, and 3.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Plane 0 DIB->VGA conversion code for a single scan line.
;-----------------------------------------------------------------------;
        align   4
DIB4_to_VGA_plane0_copy::

;-----------------------------------------------------------------------;
; Set EBX to point to multiplexed DIB byte->planar byte conversion table
; for plane 0.
;
; Input: ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels
;        EDI = VGA pointer to planar byte
;        ulPlane0Scans = # of scan lines to copy to
;        ulSrcDelta = offset from end of one source scan copied to start of next
;        ulDstDelta = offset from end of one dest scan copied to start of next
;        ulWholeDwordCount = # of whole, aligned dwords to copy
;        ulLeftMask = mask for partial left edge, if any
;        ulRightMask = mask for partial right edge, if any
;        Plane 0 must be mapped in for writes
;-----------------------------------------------------------------------;

        mov     ebx,DIB4_to_VGA_plane0_table ;stays set for all bytes/words

DIB4_to_VGA_plane0_copy_loop::

;-----------------------------------------------------------------------;
; Code to convert 1-7 DIB4 pixels to a partial VGA plane 0 byte (8
; pixels in plane 0). Assumes that a full dword of DIB4 pixels (8
; pixels) is available, starting at ESI, although some of the pixels
; will be masked off. Assumes the DIB4 pixels (including masked-off
; pixels) start in the upper nibble of [ESI], and that the first
; (possibly masked-off) DIB4 pixel maps to bit 7 of the VGA at [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels (possibly masked off)
;        EDI = VGA pointer to planar byte
;        Plane 0 must be mapped in for writes
;-----------------------------------------------------------------------;

        test    ecx,LEADING_PARTIAL     ;handle a leading partial byte?
        jz      short DIB4_to_VGA_plane0_copy_lbyte ;no, go straight to whole
                                                    ; byte
                                        ;yes, handle leading partial byte
        mov     edx,[esi]               ;get 8 pixels to convert of DIB
        and     edx,11111111h           ;keep only the plane 0 bits of DIB dword
                                        ; EDX = xxx6xxx7xxx4xxx5xxx2xxx3xxx0xxx1
        shld    eax,edx,16+2            ;put bits 7-4 of DIB dword in AX,
                                        ; shifted left 2 (x = zero bit)
                                        ; DX = xxx2xxx3xxx0xxx1
                                        ; AX = x6xxx7xxx4xxx5xx
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; x6x2x7x3x4x0x5x1
        mov     bl,al                   ;BL = x4x0x5x1 of DIB dword 0
        add     ah,ah                   ;make AH 6x2x7x3x of DIB dword 0 (shl 1)
        or      bl,ah                   ;BL = 64207531 of DIB dword 0
        add     esi,4                   ;point to next DIB dword
        inc     edi                     ;point to next VGA byte (placed here
                                        ; for 486 pipelining reasons)
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0
        mov     ch,[edi-1]              ;get the VGA destination byte
        and     ecx,ulLeftMask          ;mask off source and dest
        or      cl,ch                   ;combine masked source and dest
        mov     [edi-1],cl              ;write the new pixels to the VGA

;-----------------------------------------------------------------------;
; Code to convert 8 DIB4 pixels to a single VGA plane 0 byte (8 pixels
; in plane 0). Assumes the DIB4 pixels start in the upper nibble of
; [ESI], and that the first DIB4 pixel maps to bit 7 of the VGA at
; [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels
;        EDI = VGA pointer to planar byte
;        Plane 0 must be mapped in for writes
;-----------------------------------------------------------------------;

DIB4_to_VGA_plane0_copy_lbyte::
        test    ecx,LEADING_BYTE        ;should we handle a leading byte?
        jz      short DIB4_to_VGA_plane0_copy_words ;no, go straight to words
                                        ;yes, handle leading byte
        mov     edx,[esi]               ;get 8 pixels to convert of DIB
        and     edx,11111111h           ;keep only the plane 0 bits of DIB dword
                                        ; EDX = xxx6xxx7xxx4xxx5xxx2xxx3xxx0xxx1
        shld    eax,edx,16+2            ;put bits 7-4 of DIB dword in AX,
                                        ; shifted left 2 (x = zero bit)
                                        ; DX = xxx2xxx3xxx0xxx1
                                        ; AX = x6xxx7xxx4xxx5xx
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; x6x2x7x3x4x0x5x1
        mov     bl,al                   ;BL = x4x0x5x1 of DIB dword 0
        add     ah,ah                   ;make AH 6x2x7x3x of DIB dword 0 (shl 1)
        or      bl,ah                   ;BL = 64207531 of DIB dword 0
        add     esi,4                   ;point to next DIB dword
        inc     edi                     ;point to next VGA byte (placed here
                                        ; for 486 pipelining reasons)
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0
        mov     [edi-1],cl              ;write 8 bits from DIB dword to VGA

;-----------------------------------------------------------------------;
; Code to convert sets of 32 DIB4 pixels to 4 VGA plane 0 bytes (32
; pixels in plane 0). Assumes the VGA destination is word aligned.
; Assumes the DIB4 pixels start in the upper nibble of [ESI], and that
; the first DIB4 pixel maps to bit 7 of the VGA at [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels
;        EDI = VGA pointer to two planar bytes (must be word aligned)
;        ulWholeDwordCount = # of VGA dwords to convert
;        Plane 0 must be mapped in for writes
;
; Note: on entry at DIB4_to_VGA_plane0_word_odd, ESI must point to the
; desired source start minus 8, and EAX must be loaded as if the following
; instructions had been performed:
;        mov     edx,[esi+8]
;        and     edx,11111111h
;        shld    eax,edx,16+2
;        or      eax,edx
;
; Note: the code is so odd because of 486 pipeline optimization.
; DO NOT CHANGE THIS CODE UNLESS YOU KNOW EXACTLY WHAT YOU'RE DOING!!!
;
; Note: all 486 pipeline penalties are eliminated except for SHLD, which
; is losing 4 cycles total, and writing CX to memory (2 cycles), so far
; as I know.
;-----------------------------------------------------------------------;

DIB4_to_VGA_plane0_copy_words::
        test    ecx,ODD_WHOLE_WORD or WHOLE_WORDS ;any whole words to copy?
        jz      DIB4_to_VGA_plane0_copy_tbyte ;no, check for trailing whole
                                              ; bytes
                                ;yes, copy the whole words
        push    ebp             ;preserve stack frame pointer
        mov     ebp,ulWholeDwordCount ;# of VGA dwords to copy to
                                ;even # of DIB dwords to copy? (flags still
                                ; set from TEST)
        .errnz   ODD_WHOLE_WORD - 80000000h
        jns     short DIB4_to_VGA_plane0_word_loop ;yes, start copying
                                ;no, there's an odd word; prepare to enter loop
                                ; in middle
        mov     edx,[esi]       ;get 8 pixels to convert of first DIB dword
        and     edx,11111111h   ;keep only the plane 0 bits of DIB dword
                                ; EDX = xxx6xxx7xxx4xxx5xxx2xxx3xxx0xxx1
        shld    eax,edx,16+2    ;put bits 7-4 of DIB dword in AX,
                                ; shifted left 2
                                ; DX = xxx2xxx3xxx0xxx1
                                ; AX = x6xxx7xxx4xxx5xx
        or      eax,edx         ;put bits 7-0 of DIB dword in AX:
        sub     esi,8           ;compensate source back for entering in middle
        sub     edi,2           ;compensate dest back for entering in middle

        jmp     short DIB4_to_VGA_plane0_word_odd

;-----------------------------------------------------------------------;
; Loop to copy a word at a time to VGA plane 0 (actually, unrolled once
; so copies dwords).
;-----------------------------------------------------------------------;

        align   16
DIB4_to_VGA_plane0_word_loop::
        mov     edx,[esi]               ;get 8 pixels to convert of DIB dword 0
        and     edx,11111111h           ;keep only the plane 0 bits of DIB
                                        ; dword 0
                                        ; EDX = xxx6xxx7xxx4xxx5xxx2xxx3xxx0xxx1
        shld    eax,edx,16+2            ;put bits 7-4 of DIB dword 0 in AX,
                                        ; shifted left 2 (x = zero bit)
                                        ; DX = xxx2xxx3xxx0xxx1
                                        ; AX = x6xxx7xxx4xxx5xx
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; x6x2x7x3x4x0x5x1
        mov     edx,[esi+4]             ;get 8 pixels to convert of DIB dword 1
        mov     bl,al                   ;BL = x4x0x5x1 of DIB dword 0
        add     ah,ah                   ;make AH 6x2x7x3x of DIB dword 0 (shl 1)
        or      bl,ah                   ;BL = 64207531 of DIB dword 0
        and     edx,11111111h           ;keep only the plane 0 bits of DIB
                                        ; dword 1
                                        ; EDX = xxx6xxx7xxx4xxx5xxx2xxx3xxx0xxx1
        shld    eax,edx,16+2            ;put bits 7-4 of DIB dword 1 in AX,
                                        ; shifted left 2
                                        ; DX = xxx2xxx3xxx0xxx1
                                        ; AX = x6xxx7xxx4xxx5xx
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0
        or      eax,edx                 ;put bits 7-0 of DIB dword 1 in AX:
                                        ; x6x2x7x3x4x0x5x1
        mov     bl,al                   ;BL = x4x0x5x1 of DIB dword 1
        mov     edx,[esi+8]             ;get 8 pixels to convert of DIB dword 2
        add     ah,ah                   ;make AH 6x2x7x3x of DIB dword 1 (shl 1)
        or      bl,ah                   ;BL = 64207531 of DIB dword 1
        and     edx,11111111h           ;keep only the plane 0 bits of DIB
                                        ; dword 2
                                        ; EDX = xxx6xxx7xxx4xxx5xxx2xxx3xxx0xxx1
        shld    eax,edx,16+2            ;put bits 7-4 of DIB dword 2 in AX,
                                        ; shifted left 2
                                        ; DX = xxx2xxx3xxx0xxx1
                                        ; AX = x6xxx7xxx4xxx5xx
        mov     ch,[ebx]                ;CH = 76543210 of DIB dword 1
        or      eax,edx                 ;put bits 7-0 of DIB dword 2 in AX:
                                        ; x6x2x7x3x4x0x5x1
        mov     [edi],cx                ;write 16 bits from DIB dwords 0 and 1
                                        ; to VGA

DIB4_to_VGA_plane0_word_odd::
        mov     edx,[esi+12]            ;get 8 pixels to convert of DIB dword 3
        mov     bl,al                   ;BL = x4x0x5x1 of DIB dword 2
        add     ah,ah                   ;make AH 6x2x7x3x of DIB dword 2 (shl 1)
        or      bl,ah                   ;BL = 64207531 of DIB dword 2
        and     edx,11111111h           ;keep only the plane 0 bits of DIB
                                        ; dword 3
                                        ; EDX = xxx6xxx7xxx4xxx5xxx2xxx3xxx0xxx1
        shld    eax,edx,16+2            ;put bits 7-4 of DIB dword 3 in AX,
                                        ; shifted left 2
                                        ; DX = xxx2xxx3xxx0xxx1
                                        ; AX = x6xxx7xxx4xxx5xx
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 2
        or      eax,edx                 ;put bits 7-0 of DIB dword 3 in AX:
                                        ; x6x2x7x3x4x0x5x1
        mov     bl,al                   ;BL = x4x0x5x1 of DIB dword 3
        add     ah,ah                   ;make AH 6x2x7x3x of DIB dword 3 (shl 1)
        or      bl,ah                   ;BL = 64207531 of DIB dword 3
        add     esi,16                  ;point to next set of 4 DIB dwords
        add     edi,4                   ;point to next VGA dword
        mov     ch,[ebx]                ;CH = 76543210 of dword 0
        dec     ebp                     ;count down VGA dwords
        mov     [edi-2],cx              ;write 16 bits from DIB dwords 2 and 3
                                        ; to VGA
        jnz     DIB4_to_VGA_plane0_word_loop ;do next VGA dword, if any

        pop     ebp                     ;restore stack frame pointer


;-----------------------------------------------------------------------;
; Code to convert 8 DIB4 pixels to a single VGA plane 0 byte (8 pixels
; in plane 0). Assumes the DIB4 pixels start in the upper nibble of
; [ESI], and that the first DIB4 pixel maps to bit 7 of the VGA at
; [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels
;        EDI = VGA pointer to planar byte
;        Plane 0 must be mapped in for writes
;
;-----------------------------------------------------------------------;

DIB4_to_VGA_plane0_copy_tbyte::
        test    ecx,TRAILING_BYTE       ;should we handle a trailing byte?
        jz      short DIB4_to_VGA_plane0_copy_tpart ;no, check for trailing
                                                    ; partial
                                        ;yes, handle trailing byte
        mov     edx,[esi]               ;get 8 pixels to convert of DIB
        and     edx,11111111h           ;keep only the plane 0 bits of DIB dword
                                        ; EDX = xxx6xxx7xxx4xxx5xxx2xxx3xxx0xxx1
        shld    eax,edx,16+2            ;put bits 7-4 of DIB dword in AX,
                                        ; shifted left 2 (x = zero bit)
                                        ; DX = xxx2xxx3xxx0xxx1
                                        ; AX = x6xxx7xxx4xxx5xx
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; x6x2x7x3x4x0x5x1
        mov     bl,al                   ;BL = x4x0x5x1 of DIB dword 0
        add     ah,ah                   ;make AH 6x2x7x3x of DIB dword 0 (shl 1)
        or      bl,ah                   ;BL = 64207531 of DIB dword 0
        add     esi,4                   ;point to next DIB dword
        inc     edi                     ;point to next VGA byte (placed here
                                        ; for 486 pipelining reasons)
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0
        mov     [edi-1],cl              ;write 8 bits from DIB dword to VGA

;-----------------------------------------------------------------------;
; Code to convert 1-7 DIB4 pixels to a partial VGA plane 0 byte (8
; pixels in plane 0). Assumes that a full dword of DIB4 pixels (8
; pixels) is available, starting at ESI, although some of the pixels
; will be masked off. Assumes the DIB4 pixels (including masked-off
; pixels) start in the upper nibble of [ESI], and that the first
; (possibly masked-off) DIB4 pixel maps to bit 7 of the VGA at [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels (possibly masked off)
;        EDI = VGA pointer to planar byte
;        Plane 0 must be mapped in for writes
;-----------------------------------------------------------------------;

DIB4_to_VGA_plane0_copy_tpart::
        test    ecx,TRAILING_PARTIAL    ;handle a trailing partial byte?
        jz      short DIB4_to_VGA_plane0_copy_done ;no, done
                                        ;yes, handle trailing partial byte
        mov     edx,[esi]               ;get 8 pixels to convert of DIB
        and     edx,11111111h           ;keep only the plane 0 bits of DIB dword
                                        ; EDX = xxx6xxx7xxx4xxx5xxx2xxx3xxx0xxx1
        shld    eax,edx,16+2            ;put bits 7-4 of DIB dword in AX,
                                        ; shifted left 2 (x = zero bit)
                                        ; DX = xxx2xxx3xxx0xxx1
                                        ; AX = x6xxx7xxx4xxx5xx
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; x6x2x7x3x4x0x5x1
        mov     bl,al                   ;BL = x4x0x5x1 of DIB dword 0
        add     ah,ah                   ;make AH 6x2x7x3x of DIB dword 0 (shl 1)
        or      bl,ah                   ;BL = 64207531 of DIB dword 0
        add     esi,4                   ;point to next DIB dword
        inc     edi                     ;point to next VGA byte (placed here
                                        ; for 486 pipelining reasons)
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0
        mov     ch,[edi-1]              ;get the VGA destination byte
        and     ecx,ulRightMask         ;mask off source and dest
        or      cl,ch                   ;combine masked source and dest
        mov     [edi-1],cl              ;write the new pixels to the VGA

DIB4_to_VGA_plane0_copy_done::
        add     esi,ulSrcDelta          ;point to start of next DIB scan
        add     edi,ulDstDelta          ;point to start of next VGA scan
        dec     ulPlane0Scans           ;count down scans in this plane
        jnz     DIB4_to_VGA_plane0_copy_loop ;do next scan in this plane, if any

        jmp     copy_burst_plane0_done  ;return to the top of the plane-copy
                                        ; loop

;-----------------------------------------------------------------------;
; Plane 1 DIB->VGA conversion code for a single scan line.
;
; Input: ECX with bits sets as described for ulCopyControlFlags, above
;              bit 30 = 1 if there are whole words to be copied, = 0 if not
;              bit 29 = 1 if leading byte should be copied, = 0 if not
;              bit 28 = 1 if trailing byte should be copied, = 0 if not
;              bit 27 = 1 if partial leading byte should be copied, = 0 if not
;              bit 26 = 1 if partial trailing byte should be copied, = 0 if not
;        ESI = DIB pointer to first two pixels
;        EDI = VGA pointer to planar byte
;        ulPlane1Scans = # of scan lines to copy to
;        ulSrcDelta = offset from end of one source scan copied to start of next
;        ulDstDelta = offset from end of one dest scan copied to start of next
;        ulWholeDwordCount = # of whole, aligned dwords to copy
;        ulLeftMask = mask for partial left edge, if any
;        ulRightMask = mask for partial right edge, if any
;        Plane 1 must be mapped in for writes
;-----------------------------------------------------------------------;
        align   4
DIB4_to_VGA_plane1_copy::

;-----------------------------------------------------------------------;
; Set EBX to point to multiplexed DIB byte->planar byte conversion table
; for plane 1.
;-----------------------------------------------------------------------;

        mov     ebx,DIB4_to_VGA_plane1_table ;stays set for all bytes/words

DIB4_to_VGA_plane1_copy_loop::

;-----------------------------------------------------------------------;
; Code to convert 1-7 DIB4 pixels to a partial VGA plane 1 byte (8
; pixels in plane 1). Assumes that a full dword of DIB4 pixels (8
; pixels) is available, starting at ESI, although some of the pixels
; will be masked off. Assumes the DIB4 pixels (including masked-off
; pixels) start in the upper nibble of [ESI], and that the first
; (possibly masked-off) DIB4 pixel maps to bit 7 of the VGA at [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels (possibly masked off)
;        EDI = VGA pointer to planar byte
;        plane 1 must be mapped in for writes
;-----------------------------------------------------------------------;

        test    ecx,LEADING_PARTIAL     ;handle a leading partial byte?
        jz      short DIB4_to_VGA_plane1_copy_lbyte ;no, go straight to whole
                                                    ; byte
                                        ;yes, handle leading partial byte
        mov     edx,[esi]               ;get 8 pixels to convert of DIB
        and     edx,22222222h           ;keep only the plane 1 bits of DIB
                                        ; dword 0
                                        ; EDX = xx6xxx7xxx4xxx5xxx2xxx3xxx0xxx1x
        shld    eax,edx,16+2            ;put bits 7-4 of DIB dword 0 in AX,
                                        ; shifted left 2 (x = zero bit)
                                        ; DX = xx2xxx3xxx0xxx1x
                                        ; AX = 6xxx7xxx4xxx5xxx
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; 6x2x7x3x4x0x5x1x
        mov     bl,al                   ;BL = 4x0x5x1x of DIB dword 0
        rol     ah,7                    ;make AH x6x2x7x3 of DIB dword 0 (shr 1)
        or      bl,ah                   ;BL = 46025713 of DIB dword 0
        add     esi,4                   ;point to next DIB dword
        inc     edi                     ;point to next VGA byte (placed here
                                        ; for 486 pipelining reasons)
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0
        mov     ch,[edi-1]              ;get the VGA destination byte
        and     ecx,ulLeftMask          ;mask off source and dest
        or      cl,ch                   ;combine masked source and dest
        mov     [edi-1],cl              ;write the new pixels to the VGA

;-----------------------------------------------------------------------;
; Code to convert 8 DIB4 pixels to a single VGA plane 1 byte (8 pixels
; in plane 1). Assumes the DIB4 pixels start in the upper nibble of
; [ESI], and that the first DIB4 pixel maps to bit 7 of the VGA at
; [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels
;        EDI = VGA pointer to planar byte
;        plane 1 must be mapped in for writes
;-----------------------------------------------------------------------;

DIB4_to_VGA_plane1_copy_lbyte::
        test    ecx,LEADING_BYTE        ;should we handle a leading byte?
        jz      short DIB4_to_VGA_plane1_copy_words ;no, go straight to words
                                        ;yes, handle leading byte
        mov     edx,[esi]               ;get 8 pixels to convert of DIB
        and     edx,22222222h           ;keep only the plane 1 bits of DIB
                                        ; dword 0
                                        ; EDX = xx6xxx7xxx4xxx5xxx2xxx3xxx0xxx1x
        shld    eax,edx,16+2            ;put bits 7-4 of DIB dword 0 in AX,
                                        ; shifted left 2 (x = zero bit)
                                        ; DX = xx2xxx3xxx0xxx1x
                                        ; AX = 6xxx7xxx4xxx5xxx
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; 6x2x7x3x4x0x5x1x
        mov     bl,al                   ;BL = 4x0x5x1x of DIB dword 0
        rol     ah,7                    ;make AH x6x2x7x3 of DIB dword 0 (shr 1)
        or      bl,ah                   ;BL = 46025713 of DIB dword 0
        add     esi,4                   ;point to next DIB dword
        inc     edi                     ;point to next VGA byte (placed here
                                        ; for 486 pipelining reasons)
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0
        mov     [edi-1],cl              ;write 8 bits from DIB dword to VGA

;-----------------------------------------------------------------------;
; Code for converting sets of 32 DIB4 pixels to 4 VGA plane 1 bytes (32
; pixels in plane 1). Assumes the VGA destination is word aligned.
; Assumes the DIB4 pixels start in the upper nibble of [ESI], and that
; the first DIB4 pixel maps to bit 7 of the VGA at [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels
;        EDI = VGA pointer to two planar bytes (must be word aligned)
;        EBP = # of VGA dwords to convert
;        ulWholeDwordCount = # of VGA dwords to convert
;        Plane 1 must be mapped in for writes
;
; Note: on entry at DIB4_to_VGA_plane1_word_odd, ESI must point to the
; desired source start minus 8, and EAX must be loaded as if the following
; instructions had been performed:
;        mov     edx,[esi+8]
;        and     edx,22222222h
;        shld    eax,edx,16+2
;        or      eax,edx
;
; Note: ROL AH,7 is used instead of SHR AH,1 because the shift-by-1
; form is 1 cycle slower on a 486, and in this case the two forms are
; functionally identical.
;
; Note: the code is so odd because of 486 pipeline optimization.
; DO NOT CHANGE THIS CODE UNLESS YOU KNOW EXACTLY WHAT YOU'RE DOING!!!
;
; Note: all 486 pipeline penalties are eliminated except for SHLD, which
; is losing 4 cycles total, and writing CX to memory (2 cycles), so far
; as I know.
;-----------------------------------------------------------------------;

DIB4_to_VGA_plane1_copy_words::
        test    ecx,ODD_WHOLE_WORD or WHOLE_WORDS ;any whole words to copy?
        jz      DIB4_to_VGA_plane1_copy_tbyte ;no, check for trailing whole
                                              ; bytes
                                ;yes, copy the whole words
        push    ebp             ;preserve stack frame pointer
        mov     ebp,ulWholeDwordCount ;# of VGA dwords to copy to
                                ;even # of DIB dwords to copy? (flags still
                                ; set from TEST)
        .errnz   ODD_WHOLE_WORD - 80000000h
        jns     short DIB4_to_VGA_plane1_word_loop ;yes, start copying
                                ;no, there's an odd word; prepare to enter loop
                                ; in middle
        mov     edx,[esi]       ;get 8 pixels to convert of first DIB dword
        and     edx,22222222h   ;keep only the plane 1 bits of DIB dword
                                ; EDX = xx6xxx7xxx4xxx5xxx2xxx3xxx0xxx1x
        shld    eax,edx,16+2    ;put bits 7-4 of DIB dword in AX,
                                ; shifted left 2
                                ; DX = xx2xxx3xxx0xxx1x
                                ; AX = 6xxx7xxx4xxx5xxx
        or      eax,edx         ;put bits 7-0 of DIB dword in AX:
                                ; 6x2x7x3x4x0x5x1x
        sub     esi,8           ;compensate source back for entering in middle
        sub     edi,2           ;compensate dest back for entering in middle

        jmp     short DIB4_to_VGA_plane1_word_odd

;-----------------------------------------------------------------------;
; Loop to copy a word at a time to VGA plane 1 (actually, unrolled once
; so copies dwords).
;-----------------------------------------------------------------------;

        align   16
DIB4_to_VGA_plane1_word_loop::
        mov     edx,[esi]               ;get 8 pixels to convert of DIB dword 0
        and     edx,22222222h           ;keep only the plane 1 bits of DIB
                                        ; dword 0
                                        ; EDX = xx6xxx7xxx4xxx5xxx2xxx3xxx0xxx1x
        shld    eax,edx,16+2            ;put bits 7-4 of DIB dword 0 in AX,
                                        ; shifted left 2 (x = zero bit)
                                        ; DX = xx2xxx3xxx0xxx1x
                                        ; AX = 6xxx7xxx4xxx5xxx
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; 6x2x7x3x4x0x5x1x
        mov     edx,[esi+4]             ;get 8 pixels to convert of DIB dword 1
        mov     bl,al                   ;BL = 4x0x5x1x of DIB dword 0
        rol     ah,7                    ;make AH x6x2x7x3 of DIB dword 0 (shr 1)
        or      bl,ah                   ;BL = 46025713 of DIB dword 0
        and     edx,22222222h           ;keep only the plane 1 bits of DIB
                                        ; dword 1
                                        ; EDX = xx6xxx7xxx4xxx5xxx2xxx3xxx0xxx1x
        shld    eax,edx,16+2            ;put bits 7-4 of DIB dword 1 in AX,
                                        ; shifted left 2
                                        ; DX = xx2xxx3xxx0xxx1x
                                        ; AX = 6xxx7xxx4xxx5xxx
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0
        or      eax,edx                 ;put bits 7-0 of DIB dword 1 in AX:
                                        ; 6x2x7x3x4x0x5x1x
        mov     bl,al                   ;BL = 4x0x5x1x of DIB dword 1
        mov     edx,[esi+8]             ;get 8 pixels to convert of DIB dword 2
        rol     ah,7                    ;make AH x6x2x7x3 of DIB dword 1 (shr 1)
        or      bl,ah                   ;BL = 46025713 of DIB dword 1
        and     edx,22222222h           ;keep only the plane 1 bits of DIB
                                        ; dword 2
                                        ; EDX = xx6xxx7xxx4xxx5xxx2xxx3xxx0xxx1x
        shld    eax,edx,16+2            ;put bits 7-4 of DIB dword 2 in AX,
                                        ; shifted left 2
                                        ; DX = xx2xxx3xxx0xxx1x
                                        ; AX = 6xxx7xxx4xxx5xxx
        mov     ch,[ebx]                ;CH = 76543210 of DIB dword 1
        or      eax,edx                 ;put bits 7-0 of DIB dword 2 in AX:
                                        ; 6x2x7x3x4x0x5x1x
        mov     [edi],cx                ;write 16 bits from DIB dwords 0 and 1
                                        ; to VGA
DIB4_to_VGA_plane1_word_odd::
        mov     edx,[esi+12]            ;get 8 pixels to convert of DIB dword 3
        mov     bl,al                   ;BL = 4x0x5x1x of DIB dword 2
        rol     ah,7                    ;make AH x6x2x7x3 of DIB dword 2 (shr 1)
        or      bl,ah                   ;BL = 46025713 of DIB dword 2
        and     edx,22222222h           ;keep only the plane 1 bits of DIB
                                        ; dword 3
                                        ; EDX = xx6xxx7xxx4xxx5xxx2xxx3xxx0xxx1x
        shld    eax,edx,16+2            ;put bits 7-4 of DIB dword 3 in AX,
                                        ; shifted left 2
                                        ; DX = xx2xxx3xxx0xxx1x
                                        ; AX = 6xxx7xxx4xxx5xxx
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 2
        or      eax,edx                 ;put bits 7-0 of DIB dword 3 in AX:
                                        ; 6x2x7x3x4x0x5x1x
        mov     bl,al                   ;BL = 4x0x5x1x of DIB dword 3
        rol     ah,7                    ;make AH x6x2x7x3 of DIB dword 3 (shr 1)
        or      bl,ah                   ;BL = 46025713 of DIB dword 3
        add     esi,16                  ;point to next set of 4 DIB dwords
        add     edi,4                   ;point to next VGA dword
        mov     ch,[ebx]                ;CH = 76543210 of dword 0
        dec     ebp                     ;count down VGA dwords
        mov     [edi-2],cx              ;write 16 bits from DIB dwords 2 and 3
                                        ; to VGA
        jnz     DIB4_to_VGA_plane1_word_loop ;do next VGA dword, if any

        pop     ebp                     ;restore stack frame pointer

;-----------------------------------------------------------------------;
; Code to convert 8 DIB4 pixels to a single VGA plane 1 byte (8 pixels
; in plane 1). Assumes the DIB4 pixels start in the upper nibble of
; [ESI], and that the first DIB4 pixel maps to bit 7 of the VGA at
; [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels
;        EDI = VGA pointer to planar byte
;        Plane 1 must be mapped in for writes
;
;-----------------------------------------------------------------------;

DIB4_to_VGA_plane1_copy_tbyte::
        test    ecx,TRAILING_BYTE       ;should we handle a trailing byte?
        jz      short DIB4_to_VGA_plane1_copy_tpart ;no, check for trailing
                                                    ; partial
                                        ;yes, handle trailing byte
        mov     edx,[esi]               ;get 8 pixels to convert of DIB
        and     edx,22222222h           ;keep only the plane 1 bits of DIB
                                        ; dword 0
                                        ; EDX = xx6xxx7xxx4xxx5xxx2xxx3xxx0xxx1x
        shld    eax,edx,16+2            ;put bits 7-4 of DIB dword 0 in AX,
                                        ; shifted left 2 (x = zero bit)
                                        ; DX = xx2xxx3xxx0xxx1x
                                        ; AX = 6xxx7xxx4xxx5xxx
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; 6x2x7x3x4x0x5x1x
        mov     bl,al                   ;BL = 4x0x5x1x of DIB dword 0
        rol     ah,7                    ;make AH x6x2x7x3 of DIB dword 0 (shr 1)
        or      bl,ah                   ;BL = 46025713 of DIB dword 0
        add     esi,4                   ;point to next DIB dword
        inc     edi                     ;point to next VGA byte (placed here
                                        ; for 486 pipelining reasons)
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0
        mov     [edi-1],cl              ;write 8 bits from DIB dword to VGA

;-----------------------------------------------------------------------;
; Code to convert 1-7 DIB4 pixels to a partial VGA plane 1 byte (8
; pixels in plane 1). Assumes that a full dword of DIB4 pixels (8
; pixels) is available, starting at ESI, although some of the pixels
; will be masked off. Assumes the DIB4 pixels (including masked-off
; pixels) start in the upper nibble of [ESI], and that the first
; (possibly masked-off) DIB4 pixel maps to bit 7 of the VGA at [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels (possibly masked off)
;        EDI = VGA pointer to planar byte
;        plane 1 must be mapped in for writes
;-----------------------------------------------------------------------;

DIB4_to_VGA_plane1_copy_tpart::
        test    ecx,TRAILING_PARTIAL    ;handle a trailing partial byte?
        jz      short DIB4_to_VGA_plane1_copy_done ;no, done
                                        ;yes, handle trailing partial byte
        mov     edx,[esi]               ;get 8 pixels to convert of DIB
        and     edx,22222222h           ;keep only the plane 1 bits of DIB
                                        ; dword 0
                                        ; EDX = xx6xxx7xxx4xxx5xxx2xxx3xxx0xxx1x
        shld    eax,edx,16+2            ;put bits 7-4 of DIB dword 0 in AX,
                                        ; shifted left 2 (x = zero bit)
                                        ; DX = xx2xxx3xxx0xxx1x
                                        ; AX = 6xxx7xxx4xxx5xxx
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; 6x2x7x3x4x0x5x1x
        mov     bl,al                   ;BL = 4x0x5x1x of DIB dword 0
        rol     ah,7                    ;make AH x6x2x7x3 of DIB dword 0 (shr 1)
        or      bl,ah                   ;BL = 46025713 of DIB dword 0
        add     esi,4                   ;point to next DIB dword
        inc     edi                     ;point to next VGA byte (placed here
                                        ; for 486 pipelining reasons)
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0
        mov     ch,[edi-1]              ;get the VGA destination byte
        and     ecx,ulRightMask         ;mask off source and dest
        or      cl,ch                   ;combine masked source and dest
        mov     [edi-1],cl              ;write the new pixels to the VGA

DIB4_to_VGA_plane1_copy_done::
        add     esi,ulSrcDelta          ;point to start of next DIB scan
        add     edi,ulDstDelta          ;point to start of next VGA scan
        dec     ulPlane1Scans           ;count down scans in this plane
        jnz     DIB4_to_VGA_plane1_copy_loop ;do next scan in this plane, if any

        jmp     copy_burst_plane1_done  ;return to the top of the plane-copy
                                        ; loop

;-----------------------------------------------------------------------;
; Plane 2 DIB->VGA conversion code for a single scan line.
;
; Input: ECX with bits sets as described for ulCopyControlFlags, above
;              bit 30 = 1 if there are whole words to be copied, = 0 if not
;              bit 29 = 1 if leading byte should be copied, = 0 if not
;              bit 28 = 1 if trailing byte should be copied, = 0 if not
;              bit 27 = 1 if partial leading byte should be copied, = 0 if not
;              bit 26 = 1 if partial trailing byte should be copied, = 0 if not
;        ESI = DIB pointer to first two pixels
;        EDI = VGA pointer to planar byte
;        ulPlane2Scans = # of scan lines to copy to
;        ulSrcDelta = offset from end of one source scan copied to start of next
;        ulDstDelta = offset from end of one dest scan copied to start of next
;        ulWholeDwordCount = # of whole, aligned dwords to copy
;        ulLeftMask = mask for partial left edge, if any
;        ulRightMask = mask for partial right edge, if any
;        Plane 2 must be mapped in for writes
;-----------------------------------------------------------------------;
        align   4
DIB4_to_VGA_plane2_copy::

;-----------------------------------------------------------------------;
; Set EBX to point to multiplexed DIB byte->planar byte conversion table
; for plane 2.
;-----------------------------------------------------------------------;

        mov     ebx,DIB4_to_VGA_plane2_table ;stays set for all bytes/words

DIB4_to_VGA_plane2_copy_loop::

;-----------------------------------------------------------------------;
; Code to convert 1-7 DIB4 pixels to a partial VGA plane 2 byte (8
; pixels in plane 2). Assumes that a full dword of DIB4 pixels (8
; pixels) is available, starting at ESI, although some of the pixels
; will be masked off. Assumes the DIB4 pixels (including masked-off
; pixels) start in the upper nibble of [ESI], and that the first
; (possibly masked-off) DIB4 pixel maps to bit 7 of the VGA at [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels (possibly masked off)
;        EDI = VGA pointer to planar byte
;        plane 2 must be mapped in for writes
;-----------------------------------------------------------------------;

        test    ecx,LEADING_PARTIAL     ;handle a leading partial byte?
        jz      short DIB4_to_VGA_plane2_copy_lbyte ;no, go straight to whole
                                                    ; byte
                                        ;yes, handle leading partial byte
        mov     edx,[esi]               ;get 8 pixels to convert of DIB
        and     edx,44444444h           ;keep only the plane 2 bits of DIB
                                        ; dword 0
                                        ; EDX = x6xxx7xxx4xxx5xxx2xxx3xxx0xxx1xx
        mov     eax,edx                 ;put bits 7-4 of DIB dword 0 in AX,
        shr     eax,16+2                ; shifted right 2 (x = zero bit)
                                        ; DX = x2xxx3xxx0xxx1xx
                                        ; AX = xxx6xxx7xxx4xxx5
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; x2x6x3x7x0x4x1x5
        mov     bl,al                   ;BL = x0x4x1x5 of DIB dword 0
        add     ah,ah                   ;make AH 2x6x3x7x of DIB dword 0 (shl 1)
        or      bl,ah                   ;BL = 20643175 of DIB dword 0
        add     esi,4                   ;point to next DIB dword
        inc     edi                     ;point to next VGA byte (placed here
                                        ; for 486 pipelining reasons)
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0
        mov     ch,[edi-1]              ;get the VGA destination byte
        and     ecx,ulLeftMask          ;mask off source and dest
        or      cl,ch                   ;combine masked source and dest
        mov     [edi-1],cl              ;write the new pixels to the VGA

;-----------------------------------------------------------------------;
; Code to convert 8 DIB4 pixels to a single VGA plane 2 byte (8 pixels
; in plane 2). Assumes the DIB4 pixels start in the upper nibble of
; [ESI], and that the first DIB4 pixel maps to bit 7 of the VGA at
; [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels
;        EDI = VGA pointer to planar byte
;        plane 2 must be mapped in for writes
;-----------------------------------------------------------------------;

DIB4_to_VGA_plane2_copy_lbyte::
        test    ecx,LEADING_BYTE        ;should we handle a leading byte?
        jz      short DIB4_to_VGA_plane2_copy_words ;no, go straight to words
                                        ;yes, handle leading byte
        mov     edx,[esi]               ;get 8 pixels to convert of DIB
        and     edx,44444444h           ;keep only the plane 2 bits of DIB
                                        ; dword 0
                                        ; EDX = x6xxx7xxx4xxx5xxx2xxx3xxx0xxx1xx
        mov     eax,edx                 ;put bits 7-4 of DIB dword 0 in AX,
        shr     eax,16+2                ; shifted right 2 (x = zero bit)
                                        ; DX = x2xxx3xxx0xxx1xx
                                        ; AX = xxx6xxx7xxx4xxx5
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; x2x6x3x7x0x4x1x5
        mov     bl,al                   ;BL = x0x4x1x5 of DIB dword 0
        add     ah,ah                   ;make AH 2x6x3x7x of DIB dword 0 (shl 1)
        or      bl,ah                   ;BL = 20643175 of DIB dword 0
        add     esi,4                   ;point to next DIB dword
        inc     edi                     ;point to next VGA byte (placed here
                                        ; for 486 pipelining reasons)
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0
        mov     [edi-1],cl              ;write 8 bits from DIB dword to VGA

;-----------------------------------------------------------------------;
; Code for converting sets of 32 DIB4 pixels to 4 VGA plane 2 bytes (32
; pixels in plane 2). Assumes the VGA destination is word aligned.
; Assumes the DIB4 pixels start in the upper nibble of [ESI], and that
; the first DIB4 pixel maps to bit 7 of the VGA at [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels
;        EDI = VGA pointer to two planar bytes (must be word aligned)
;        EBP = # of VGA dwords to convert
;        ulWholeDwordCount = # of VGA dwords to convert
;        Plane 2 must be mapped in for writes
;
; Note: on entry at DIB4_to_VGA_plane2_word_odd, ESI must point to the
; desired source start minus 8, and EAX must be loaded as if the following
; instructions had been performed:
;        mov     edx,[esi+8]
;        and     edx,44444444h
;        mov     eax,edx
;        shr     eax,16+2
;        or      eax,edx
;
; Note: the code is so odd because of 486 pipeline optimization.
; DO NOT CHANGE THIS CODE UNLESS YOU KNOW EXACTLY WHAT YOU'RE DOING!!!
;
; Note: all 486 pipeline penalties are eliminated except for writing CX
; to memory (2 cycles), so far as I know.
;-----------------------------------------------------------------------;

DIB4_to_VGA_plane2_copy_words::
        test    ecx,ODD_WHOLE_WORD or WHOLE_WORDS ;any whole words to copy?
        jz      DIB4_to_VGA_plane2_copy_tbyte ;no, check for trailing whole
                                              ; bytes
                                ;yes, copy the whole words
        push    ebp             ;preserve stack frame pointer
        mov     ebp,ulWholeDwordCount ;# of VGA dwords to copy to
                                ;even # of DIB dwords to copy? (flags still
                                ; set from TEST)
        .errnz   ODD_WHOLE_WORD - 80000000h
        jns     short DIB4_to_VGA_plane2_word_loop ;yes, start copying
                                ;no, there's an odd word; prepare to enter loop
                                ; in middle
        mov     edx,[esi]       ;get 8 pixels to convert of first DIB dword
        and     edx,44444444h   ;keep only the plane 2 bits of DIB dword
                                ; EDX = x6xxx7xxx4xxx5xxx2xxx3xxx0xxx1xx
        mov     eax,edx         ;put bits 7-4 of DIB dword in AX,
        shr     eax,16+2        ; shifted right 2 (x = zero bit)
                                ; DX = x2xxx3xxx0xxx1xx
                                ; AX = xxx6xxx7xxx4xxx5
        or      eax,edx         ;put bits 7-0 of DIB dword in AX:
                                ; 62xx73xx40xx51xx
        sub     esi,8           ;compensate source back for entering in middle
        sub     edi,2           ;compensate dest back for entering in middle

        jmp     short DIB4_to_VGA_plane2_word_odd

;-----------------------------------------------------------------------;
; Loop to copy a word at a time to VGA plane 2 (actually, unrolled once
; so copies dwords).
;-----------------------------------------------------------------------;

        align   16
DIB4_to_VGA_plane2_word_loop::
        mov     edx,[esi]               ;get 8 pixels to convert of DIB dword 0
        and     edx,44444444h           ;keep only the plane 2 bits of DIB
                                        ; dword 0
                                        ; EDX = x6xxx7xxx4xxx5xxx2xxx3xxx0xxx1xx
        mov     eax,edx                 ;put bits 7-4 of DIB dword 0 in AX,
        shr     eax,16+2                ; shifted right 2 (x = zero bit)
                                        ; DX = x2xxx3xxx0xxx1xx
                                        ; AX = xxx6xxx7xxx4xxx5
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; x2x6x3x7x0x4x1x5
        mov     edx,[esi+4]             ;get 8 pixels to convert of DIB dword 1
        mov     bl,al                   ;BL = x0x4x1x5 of DIB dword 0
        add     ah,ah                   ;make AH 2x6x3x7x of DIB dword 0 (shl 1)
        or      bl,ah                   ;BL = 20643175 of DIB dword 0
        and     edx,44444444h           ;keep only the plane 2 bits of DIB
                                        ; dword 1
                                        ; EDX = x6xxx7xxx4xxx5xxx2xxx3xxx0xxx1xx
        mov     eax,edx                 ;put bits 7-4 of DIB dword 1 in AX,
        shr     eax,16+2                ; shifted right 2 (x = zero bit)
                                        ; DX = x2xxx3xxx0xxx1xx
                                        ; AX = xxx6xxx7xxx4xxx5
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0
        or      eax,edx                 ;put bits 7-0 of DIB dword 1 in AX:
                                        ; 62xx73xx40xx51xx
        mov     bl,al                   ;BL = x0x4x1x5 of DIB dword 1
        mov     edx,[esi+8]             ;get 8 pixels to convert of DIB dword 2
        add     ah,ah                   ;make AH 2x6x3x7x of DIB dword 1 (shl 1)
        or      bl,ah                   ;BL = 20643175 of DIB dword 1
        and     edx,44444444h           ;keep only the plane 2 bits of DIB
                                        ; dword 2
                                        ; EDX = x6xxx7xxx4xxx5xxx2xxx3xxx0xxx1xx
        mov     eax,edx                 ;put bits 7-4 of DIB dword 2 in AX,
        shr     eax,16+2                ; shifted right 2 (x = zero bit)
                                        ; DX = x2xxx3xxx0xxx1xx
                                        ; AX = xxx6xxx7xxx4xxx5
        mov     ch,[ebx]                ;CH = 76543210 of DIB dword 1
        or      eax,edx                 ;put bits 7-0 of DIB dword 2 in AX:
                                        ; 62xx73xx40xx51xx
        mov     [edi],cx                ;write 16 bits from DIB dwords 0 and 1
                                        ; to VGA
DIB4_to_VGA_plane2_word_odd::
        mov     edx,[esi+12]            ;get 8 pixels to convert of DIB dword 3
        mov     bl,al                   ;BL = x0x4x1x5 of DIB dword 2
        add     ah,ah                   ;make AH 2x6x3x7x of DIB dword 2 (shl 1)
        or      bl,ah                   ;BL = 20643175 of DIB dword 2
        and     edx,44444444h           ;keep only the plane 2 bits of DIB
                                        ; dword 3
                                        ; EDX = x6xxx7xxx4xxx5xxx2xxx3xxx0xxx1xx
        mov     eax,edx                 ;put bits 7-4 of DIB dword 3 in AX,
        shr     eax,16+2                ; shifted right 2 (x = zero bit)
                                        ; DX = x2xxx3xxx0xxx1xx
                                        ; AX = xxx6xxx7xxx4xxx5
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 2
        or      eax,edx                 ;put bits 7-0 of DIB dword 3 in AX:
                                        ; 62xx73xx40xx51xx
        mov     bl,al                   ;BL = x0x4x1x5 of DIB dword 3
        add     ah,ah                   ;make AH 2x6x3x7x of DIB dword 3 (shl 1)
        or      bl,ah                   ;BL = 20643175 of DIB dword 3
        add     esi,16                  ;point to next set of 4 DIB dwords
        add     edi,4                   ;point to next VGA dword
        mov     ch,[ebx]                ;CH = 76543210 of dword 0
        dec     ebp                     ;count down VGA dwords
        mov     [edi-2],cx              ;write 16 bits from DIB dwords 2 and 3
                                        ; to VGA
        jnz     DIB4_to_VGA_plane2_word_loop ;do next VGA dword, if any

        pop     ebp                     ;restore stack frame pointer

;-----------------------------------------------------------------------;
; Code to convert 8 DIB4 pixels to a single VGA plane 2 byte (8 pixels
; in plane 2). Assumes the DIB4 pixels start in the upper nibble of
; [ESI], and that the first DIB4 pixel maps to bit 7 of the VGA at
; [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels
;        EDI = VGA pointer to planar byte
;        plane 2 must be mapped in for writes
;
;-----------------------------------------------------------------------;

DIB4_to_VGA_plane2_copy_tbyte::
        test    ecx,TRAILING_BYTE       ;should we handle a trailing byte?
        jz      short DIB4_to_VGA_plane2_copy_tpart ;no, check for trailing
                                                    ; partial
                                        ;yes, handle trailing byte
        mov     edx,[esi]               ;get 8 pixels to convert of DIB
        and     edx,44444444h           ;keep only the plane 2 bits of DIB
                                        ; dword 0
                                        ; EDX = x6xxx7xxx4xxx5xxx2xxx3xxx0xxx1xx
        mov     eax,edx                 ;put bits 7-4 of DIB dword 0 in AX,
        shr     eax,16+2                ; shifted right 2 (x = zero bit)
                                        ; DX = x2xxx3xxx0xxx1xx
                                        ; AX = xxx6xxx7xxx4xxx5
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; x2x6x3x7x0x4x1x5
        mov     bl,al                   ;BL = x0x4x1x5 of DIB dword 0
        add     ah,ah                   ;make AH 2x6x3x7x of DIB dword 0 (shl 1)
        or      bl,ah                   ;BL = 20643175 of DIB dword 0
        add     esi,4                   ;point to next DIB dword
        inc     edi                     ;point to next VGA byte (placed here
                                        ; for 486 pipelining reasons)
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0
        mov     [edi-1],cl              ;write 8 bits from DIB dword to VGA

;-----------------------------------------------------------------------;
; Code to convert 1-7 DIB4 pixels to a partial VGA plane 2 byte (8
; pixels in plane 2). Assumes that a full dword of DIB4 pixels (8
; pixels) is available, starting at ESI, although some of the pixels
; will be masked off. Assumes the DIB4 pixels (including masked-off
; pixels) start in the upper nibble of [ESI], and that the first
; (possibly masked-off) DIB4 pixel maps to bit 7 of the VGA at [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels (possibly masked off)
;        EDI = VGA pointer to planar byte
;        plane 2 must be mapped in for writes
;-----------------------------------------------------------------------;

DIB4_to_VGA_plane2_copy_tpart::
        test    ecx,TRAILING_PARTIAL    ;handle a trailing partial byte?
        jz      short DIB4_to_VGA_plane2_copy_done ;no, done
                                        ;yes, handle trailing partial byte
        mov     edx,[esi]               ;get 8 pixels to convert of DIB
        and     edx,44444444h           ;keep only the plane 2 bits of DIB
                                        ; dword 0
                                        ; EDX = x6xxx7xxx4xxx5xxx2xxx3xxx0xxx1xx
        mov     eax,edx                 ;put bits 7-4 of DIB dword 0 in AX,
        shr     eax,16+2                ; shifted right 2 (x = zero bit)
                                        ; DX = x2xxx3xxx0xxx1xx
                                        ; AX = xxx6xxx7xxx4xxx5
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; x2x6x3x7x0x4x1x5
        mov     bl,al                   ;BL = x0x4x1x5 of DIB dword 0
        add     ah,ah                   ;make AH 2x6x3x7x of DIB dword 0 (shl 1)
        or      bl,ah                   ;BL = 20643175 of DIB dword 0
        add     esi,4                   ;point to next DIB dword
        inc     edi                     ;point to next VGA byte (placed here
                                        ; for 486 pipelining reasons)
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0
        mov     ch,[edi-1]              ;get the VGA destination byte
        and     ecx,ulRightMask         ;mask off source and dest
        or      cl,ch                   ;combine masked source and dest
        mov     [edi-1],cl              ;write the new pixels to the VGA

DIB4_to_VGA_plane2_copy_done::
        add     esi,ulSrcDelta          ;point to start of next DIB scan
        add     edi,ulDstDelta          ;point to start of next VGA scan
        dec     ulPlane2Scans           ;count down scans in this plane
        jnz     DIB4_to_VGA_plane2_copy_loop ;do next scan in this plane, if any

        jmp     copy_burst_plane2_done  ;return to the top of the plane-copy
                                        ; loop

;-----------------------------------------------------------------------;
; Plane 3 DIB->VGA conversion code for a single scan line.
;
; Input: ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels
;        EDI = VGA pointer to planar byte
;        ulPlane3Scans = # of scan lines to copy to
;        ulSrcDelta = offset from end of one source scan copied to start of next
;        ulDstDelta = offset from end of one dest scan copied to start of next
;        ulWholeDwordCount = # of whole, aligned dwords to copy
;        ulLeftMask = mask for partial left edge, if any
;        ulRightMask = mask for partial right edge, if any
;        Plane 3 must be mapped in for writes
;-----------------------------------------------------------------------;
        align   4
DIB4_to_VGA_plane3_copy::

;-----------------------------------------------------------------------;
; Set EBX to point to multiplexed DIB byte->planar byte conversion table
; for plane 3.
;-----------------------------------------------------------------------;

        mov     ebx,DIB4_to_VGA_plane3_table ;stays set for all bytes/words

DIB4_to_VGA_plane3_copy_loop::

;-----------------------------------------------------------------------;
; Code to convert 1-7 DIB4 pixels to a partial VGA plane 3 byte (8
; pixels in plane 3). Assumes that a full dword of DIB4 pixels (8
; pixels) is available, starting at ESI, although some of the pixels
; will be masked off. Assumes the DIB4 pixels (including masked-off
; pixels) start in the upper nibble of [ESI], and that the first
; (possibly masked-off) DIB4 pixel maps to bit 7 of the VGA at [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels (possibly masked off)
;        EDI = VGA pointer to planar byte
;        plane 3 must be mapped in for writes
;-----------------------------------------------------------------------;

        test    ecx,LEADING_PARTIAL     ;handle a leading partial byte?
        jz      short DIB4_to_VGA_plane3_copy_lbyte ;no, go straight to whole
                                                    ; byte
                                        ;yes, handle leading partial byte
        mov     edx,[esi]               ;get 8 pixels to convert of DIB dword 0
        and     edx,88888888h           ;keep only the plane 3 bits of DIB
                                        ; dword 0
                                        ; EDX = 6xxx7xxx4xxx5xxx2xxx3xxx0xxx1xxx
        mov     eax,edx                 ;put bits 7-4 of DIB dword 0 in AX,
        shr     eax,16+2                ; shifted right 2 (x = zero bit)
                                        ; DX = 2xxx3xxx0xxx1xxx
                                        ; AX = xx6xxx7xxx4xxx5x
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; 2x6x3x7x0x4x1x5x
        mov     bl,al                   ;BL = 0x4x1x5x of DIB dword 0
        rol     ah,7                    ;make AH x2x6x3x7 of DIB dword 0 (shr 1)
        or      bl,ah                   ;BL = 02461357 of DIB dword 0
        add     esi,4                   ;point to next DIB dword
        inc     edi                     ;point to next VGA byte (placed here
                                        ; for 486 pipelining reasons)
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0
        mov     ch,[edi-1]              ;get the VGA destination byte
        and     ecx,ulLeftMask          ;mask off source and dest
        or      cl,ch                   ;combine masked source and dest
        mov     [edi-1],cl              ;write the new pixels to the VGA

;-----------------------------------------------------------------------;
; Code to convert 8 DIB4 pixels to a single VGA plane 3 byte (8 pixels
; in plane 3). Assumes the DIB4 pixels start in the upper nibble of
; [ESI], and that the first DIB4 pixel maps to bit 7 of the VGA at
; [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels
;        EDI = VGA pointer to planar byte
;        plane 3 must be mapped in for writes
;-----------------------------------------------------------------------;

DIB4_to_VGA_plane3_copy_lbyte::
        test    ecx,LEADING_BYTE        ;should we handle a leading byte?
        jz      short DIB4_to_VGA_plane3_copy_words ;no, go straight to words
                                        ;yes, handle leading byte
        mov     edx,[esi]               ;get 8 pixels to convert of DIB dword 0
        and     edx,88888888h           ;keep only the plane 3 bits of DIB
                                        ; dword 0
                                        ; EDX = 6xxx7xxx4xxx5xxx2xxx3xxx0xxx1xxx
        mov     eax,edx                 ;put bits 7-4 of DIB dword 0 in AX,
        shr     eax,16+2                ; shifted right 2 (x = zero bit)
                                        ; DX = 2xxx3xxx0xxx1xxx
                                        ; AX = xx6xxx7xxx4xxx5x
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; 2x6x3x7x0x4x1x5x
        mov     bl,al                   ;BL = 0x4x1x5x of DIB dword 0
        rol     ah,7                    ;make AH x2x6x3x7 of DIB dword 0 (shr 1)
        or      bl,ah                   ;BL = 02461357 of DIB dword 0
        add     esi,4                   ;point to next DIB dword
        inc     edi                     ;point to next VGA byte (placed here
                                        ; for 486 pipelining reasons)
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0
        mov     [edi-1],cl              ;write 8 bits from DIB dword to VGA

;-----------------------------------------------------------------------;
; Code for converting sets of 32 DIB4 pixels to 4 VGA plane 3 bytes (32
; pixels in plane 3). Assumes the VGA destination is word aligned.
; Assumes the DIB4 pixels start in the upper nibble of [ESI], and that
; the first DIB4 pixel maps to bit 7 of the VGA at [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels
;        EDI = VGA pointer to two planar bytes (must be word aligned)
;        EBP = # of VGA dwords to convert
;        ulWholeDwordCount = # of VGA dwords to convert
;        plane 3 must be mapped in for writes
;
; Note: on entry at DIB4_to_VGA_plane3_word_odd, ESI must point to the
; desired source start minus 8, and EAX must be loaded as if the following
; instructions had been performed:
;        mov     edx,[esi+8]
;        and     edx,88888888h
;        mov     eax,edx
;        shr     eax,16+2
;        or      eax,edx
;
; Note: ROL AH,7 is used instead of SHR AH,1 because the shift-by-1
; form is 1 cycle slower on a 486, and in this case the two forms are
; functionally identical.
;
; Note: the code is so odd because of 486 pipeline optimization.
; DO NOT CHANGE THIS CODE UNLESS YOU KNOW EXACTLY WHAT YOU'RE DOING!!!
;
; Note: all 486 pipeline penalties are eliminated except for writing CX
; to memory (2 cycles), so far as I know.
;-----------------------------------------------------------------------;

DIB4_to_VGA_plane3_copy_words::
        test    ecx,ODD_WHOLE_WORD or WHOLE_WORDS ;any whole words to copy?
        jz      DIB4_to_VGA_plane3_copy_tbyte ;no, check for trailing whole
                                              ; bytes
                                ;yes, copy the whole words
        push    ebp             ;preserve stack frame pointer
        mov     ebp,ulWholeDwordCount ;# of VGA dwords to copy to
                                ;even # of DIB dwords to copy? (flags still
                                ; set from TEST)
        .errnz   ODD_WHOLE_WORD - 80000000h
        jns     short DIB4_to_VGA_plane3_word_loop ;yes, start copying
                                ;no, there's an odd word; prepare to enter loop
                                ; in middle
        mov     edx,[esi]       ;get 8 pixels to convert of first DIB dword
        and     edx,88888888h   ;keep only the plane 3 bits of DIB dword
                                ; EDX = 6xxx7xxx4xxx5xxx2xxx3xxx0xxx1xxx
        mov     eax,edx         ;put bits 7-4 of DIB dword in AX,
        shr     eax,16+2        ; shifted right 2 (x = zero bit)
                                ; DX = 2xxx3xxx0xxx1xxx
                                ; AX = xx6xxx7xxx4xxx5x
        or      eax,edx         ;put bits 7-0 of DIB dword in AX:
                                ; 2x6x3x7x0x4x1x5x
        sub     esi,8           ;compensate source back for entering in middle
        sub     edi,2           ;compensate dest back for entering in middle

        jmp     short DIB4_to_VGA_plane3_word_odd

;-----------------------------------------------------------------------;
; Loop to copy a word at a time to VGA plane 3 (actually, unrolled once
; so copies dwords).
;-----------------------------------------------------------------------;

        align   16
DIB4_to_VGA_plane3_word_loop::
        mov     edx,[esi]               ;get 8 pixels to convert of DIB dword 0
        and     edx,88888888h           ;keep only the plane 3 bits of DIB
                                        ; dword 0
                                        ; EDX = 6xxx7xxx4xxx5xxx2xxx3xxx0xxx1xxx
        mov     eax,edx                 ;put bits 7-4 of DIB dword 0 in AX,
        shr     eax,16+2                ; shifted right 2 (x = zero bit)
                                        ; DX = 2xxx3xxx0xxx1xxx
                                        ; AX = xx6xxx7xxx4xxx5x
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; 2x6x3x7x0x4x1x5x
        mov     edx,[esi+4]             ;get 8 pixels to convert of DIB dword 1
        mov     bl,al                   ;BL = 0x4x1x5x of DIB dword 0
        rol     ah,7                    ;make AH x2x6x3x7 of DIB dword 0 (shr 1)
        or      bl,ah                   ;BL = 02461357 of DIB dword 0
        and     edx,88888888h           ;keep only the plane 3 bits of DIB
                                        ; dword 1
                                        ; EDX = 6xxx7xxx4xxx5xxx2xxx3xxx0xxx1xxx
        mov     eax,edx                 ;put bits 7-4 of DIB dword 1 in AX,
        shr     eax,16+2                ; shifted right 2 (x = zero bit)
                                        ; DX = 2xxx3xxx0xxx1xxx
                                        ; AX = xx6xxx7xxx4xxx5x
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0
        or      eax,edx                 ;put bits 7-0 of DIB dword 1 in AX:
                                        ; 2x6x3x7x0x4x1x5x
        mov     bl,al                   ;BL = 0x4x1x5x of DIB dword 1
        mov     edx,[esi+8]             ;get 8 pixels to convert of DIB dword 2
        rol     ah,7                    ;make AH x2x6x3x7 of DIB dword 1 (shr 1)
        or      bl,ah                   ;BL = 02461357 of DIB dword 1
        and     edx,88888888h           ;keep only the plane 3 bits of DIB
                                        ; dword 2
                                        ; EDX = 6xxx7xxx4xxx5xxx2xxx3xxx0xxx1xxx
        mov     eax,edx                 ;put bits 7-4 of DIB dword 2 in AX,
        shr     eax,16+2                ; shifted right 2 (x = zero bit)
                                        ; DX = 2xxx3xxx0xxx1xxx
                                        ; AX = xx6xxx7xxx4xxx5x
        mov     ch,[ebx]                ;CH = 76543210 of DIB dword 1
        or      eax,edx                 ;put bits 7-0 of DIB dword 2 in AX:
                                        ; 2x6x3x7x0x4x1x5x
        mov     [edi],cx                ;write 16 bits from DIB dwords 0 and 1
                                        ; to VGA
DIB4_to_VGA_plane3_word_odd::
        mov     edx,[esi+12]            ;get 8 pixels to convert of DIB dword 3
        mov     bl,al                   ;BL = 0x4x1x5x of DIB dword 2
        rol     ah,7                    ;make AH x2x6x3x7 of DIB dword 2 (shr 1)
        or      bl,ah                   ;BL = 02461357 of DIB dword 2
        and     edx,88888888h           ;keep only the plane 3 bits of DIB
                                        ; dword 3
                                        ; EDX = 6xxx7xxx4xxx5xxx2xxx3xxx0xxx1xxx
        mov     eax,edx                 ;put bits 7-4 of DIB dword 3 in AX,
        shr     eax,16+2                ; shifted right 2 (x = zero bit)
                                        ; DX = 2xxx3xxx0xxx1xxx
                                        ; AX = xx6xxx7xxx4xxx5x
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 2
        or      eax,edx                 ;put bits 7-0 of DIB dword 3 in AX:
                                        ; 2x6x3x7x0x4x1x5x
        mov     bl,al                   ;BL = 0x4x1x5x of DIB dword 3
        rol     ah,7                    ;make AH x2x6x3x7 of DIB dword 3 (shr 1)
        or      bl,ah                   ;BL = 02461357 of DIB dword 3
        add     esi,16                  ;point to next set of 4 DIB dwords
        add     edi,4                   ;point to next VGA dword
        mov     ch,[ebx]                ;CH = 76543210 of dword 0
        dec     ebp                     ;count down VGA dwords
        mov     [edi-2],cx              ;write 16 bits from DIB dwords 2 and 3
                                        ; to VGA
        jnz     DIB4_to_VGA_plane3_word_loop ;do next VGA dword, if any

        pop     ebp                     ;restore stack frame pointer

;-----------------------------------------------------------------------;
; Code to convert 8 DIB4 pixels to a single VGA plane 3 byte (8 pixels
; in plane 3). Assumes the DIB4 pixels start in the upper nibble of
; [ESI], and that the first DIB4 pixel maps to bit 7 of the VGA at
; [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels
;        EDI = VGA pointer to planar byte
;        plane 3 must be mapped in for writes
;
;-----------------------------------------------------------------------;

DIB4_to_VGA_plane3_copy_tbyte::
        test    ecx,TRAILING_BYTE       ;should we handle a trailing byte?
        jz      short DIB4_to_VGA_plane3_copy_tpart ;no, check for trailing
                                                    ; partial
                                        ;yes, handle trailing byte
        mov     edx,[esi]               ;get 8 pixels to convert of DIB dword 0
        and     edx,88888888h           ;keep only the plane 3 bits of DIB
                                        ; dword 0
                                        ; EDX = 6xxx7xxx4xxx5xxx2xxx3xxx0xxx1xxx
        mov     eax,edx                 ;put bits 7-4 of DIB dword 0 in AX,
        shr     eax,16+2                ; shifted right 2 (x = zero bit)
                                        ; DX = 2xxx3xxx0xxx1xxx
                                        ; AX = xx6xxx7xxx4xxx5x
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; 2x6x3x7x0x4x1x5x
        mov     bl,al                   ;BL = 0x4x1x5x of DIB dword 0
        rol     ah,7                    ;make AH x2x6x3x7 of DIB dword 0 (shr 1)
        or      bl,ah                   ;BL = 02461357 of DIB dword 0
        add     esi,4                   ;point to next DIB dword
        inc     edi                     ;point to next VGA byte (placed here
                                        ; for 486 pipelining reasons)
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0
        mov     [edi-1],cl              ;write 8 bits from DIB dword to VGA

;-----------------------------------------------------------------------;
; Code to convert 1-7 DIB4 pixels to a partial VGA plane 3 byte (8
; pixels in plane 3). Assumes that a full dword of DIB4 pixels (8
; pixels) is available, starting at ESI, although some of the pixels
; will be masked off. Assumes the DIB4 pixels (including masked-off
; pixels) start in the upper nibble of [ESI], and that the first
; (possibly masked-off) DIB4 pixel maps to bit 7 of the VGA at [EDI].
;
; Input: EBX = pointer to multiplexed DIB byte->planar byte conversion table
;                (must start on a 256-byte boundary)
;        ECX with bits sets as described for ulCopyControlFlags, above
;        ESI = DIB pointer to first two pixels (possibly masked off)
;        EDI = VGA pointer to planar byte
;        plane 3 must be mapped in for writes
;-----------------------------------------------------------------------;

DIB4_to_VGA_plane3_copy_tpart::
        test    ecx,TRAILING_PARTIAL    ;handle a trailing partial byte?
        jz      short DIB4_to_VGA_plane3_copy_done ;no, done
                                        ;yes, handle trailing partial byte
        mov     edx,[esi]               ;get 8 pixels to convert of DIB dword 0
        and     edx,88888888h           ;keep only the plane 3 bits of DIB
                                        ; dword 0
                                        ; EDX = 6xxx7xxx4xxx5xxx2xxx3xxx0xxx1xxx
        mov     eax,edx                 ;put bits 7-4 of DIB dword 0 in AX,
        shr     eax,16+2                ; shifted right 2 (x = zero bit)
                                        ; DX = 2xxx3xxx0xxx1xxx
                                        ; AX = xx6xxx7xxx4xxx5x
        or      eax,edx                 ;put bits 7-0 of DIB dword 0 in AX:
                                        ; 2x6x3x7x0x4x1x5x
        mov     bl,al                   ;BL = 0x4x1x5x of DIB dword 0
        rol     ah,7                    ;make AH x2x6x3x7 of DIB dword 0 (shr 1)
        or      bl,ah                   ;BL = 02461357 of DIB dword 0
        add     esi,4                   ;point to next DIB dword
        inc     edi                     ;point to next VGA byte (placed here
                                        ; for 486 pipelining reasons)
        mov     cl,[ebx]                ;CL = 76543210 of DIB dword 0

        mov     ch,[edi-1]              ;get the VGA destination byte
        mov     ch,[edi-1]              ;BUGFIX - do twice to fix very
                                        ;         weird cirrus bug

        and     ecx,ulRightMask         ;mask off source and dest
        or      cl,ch                   ;combine masked source and dest
        mov     [edi-1],cl              ;write the new pixels to the VGA

DIB4_to_VGA_plane3_copy_done::
        add     esi,ulSrcDelta          ;point to start of next DIB scan
        add     edi,ulDstDelta          ;point to start of next VGA scan
        dec     ulPlane3Scans           ;count down scans in this plane
        jnz     DIB4_to_VGA_plane3_copy_loop ;do next scan in this plane, if any

        cmp     fDfbTrg,0               ;if DbfTrg flag NOT set...
        je      @F                      ;skip DFB specific code
        sub     edi,ulBytesPerPlane      ;remove the three scans just added
        sub     edi,ulBytesPerPlane
        sub     edi,ulBytesPerPlane
@@:

        jmp     copy_burst_plane3_done  ;return to the top of the plane-copy
                                        ; loop

endProc vDIB2VGA


public jLeftMasks
public jRightMasks
public one_partial_only
public check_whole_bytes
public set_copy_control_flags
public set_shift_vec
public set_initial_banking
public map_init_bank
public init_bank_mapped
public bank_loop
public copy_burst_loop
public align_burst_rshift_486
public align_burst_lshift_486
public set_alignment_source
public proceed_with_copy
public copy_burst_plane0_done
public copy_burst_plane1_done
public copy_burst_plane2_done
public copy_burst_plane3_done
public next_bank
public DIB4_to_VGA_plane0_copy
public DIB4_to_VGA_plane0_copy_loop
public DIB4_to_VGA_plane0_copy_lbyte
public DIB4_to_VGA_plane0_copy_words
public DIB4_to_VGA_plane0_word_loop
public DIB4_to_VGA_plane0_word_odd
public DIB4_to_VGA_plane0_copy_tbyte
public DIB4_to_VGA_plane0_copy_tpart
public DIB4_to_VGA_plane0_copy_done
public DIB4_to_VGA_plane1_copy
public DIB4_to_VGA_plane1_copy_loop
public DIB4_to_VGA_plane1_copy_lbyte
public DIB4_to_VGA_plane1_copy_words
public DIB4_to_VGA_plane1_word_loop
public DIB4_to_VGA_plane1_word_odd
public DIB4_to_VGA_plane1_copy_tbyte
public DIB4_to_VGA_plane1_copy_tpart
public DIB4_to_VGA_plane1_copy_done
public DIB4_to_VGA_plane2_copy
public DIB4_to_VGA_plane2_copy_loop
public DIB4_to_VGA_plane2_copy_lbyte
public DIB4_to_VGA_plane2_copy_words
public DIB4_to_VGA_plane2_word_loop
public DIB4_to_VGA_plane2_word_odd
public DIB4_to_VGA_plane2_copy_tbyte
public DIB4_to_VGA_plane2_copy_tpart
public DIB4_to_VGA_plane2_copy_done
public DIB4_to_VGA_plane3_copy
public DIB4_to_VGA_plane3_copy_loop
public DIB4_to_VGA_plane3_copy_lbyte
public DIB4_to_VGA_plane3_copy_words
public DIB4_to_VGA_plane3_word_loop
public DIB4_to_VGA_plane3_word_odd
public DIB4_to_VGA_plane3_copy_tbyte
public DIB4_to_VGA_plane3_copy_tpart
public DIB4_to_VGA_plane3_copy_done

_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\dibs.asm ===
page    ,132
        title   Dib Conversions
;---------------------------Module-Header------------------------------;
; Module Name: dibs.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

        .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM


        .xlist
        include stdcall.inc             ;calling convention cmacros

        include i386\cmacFLAT.inc       ; FLATland cmacros
        include i386\display.inc        ; Display specific structures
        include i386\ppc.inc            ; Pack pel conversion structure
        include i386\bitblt.inc         ; General definitions
        include i386\egavga.inc
        .list

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        EXTRNP  comp_byte_interval


; General equates

CJ_PLANE    equ     (cj_max_scan+1)          ;Extra byte makes algorithm easier

        .data

; Define the buffer for packed-pel to planer conversion.  !!! when we do
; conversion to planer bitmaps, this will have to come from the extra scan
; we'll allocate in our planer color bitmaps !!!

        public  ajConvertBuffer
ajConvertBuffer db      (CJ_PLANE * 4) dup (0)

        .code

_TEXT$03   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

; Define the default pixel mapping table.  This table will be used when
; converting from 4bpp to planer with no color translation.

        align   4

        public  aulDefBitMapping
aulDefBitMapping        label   dword

        dd      00000000000000000000000000000000b   ;0000
        dd      00000000000000000000000000000001b   ;0001
        dd      00000000000000000000000100000000b   ;0010
        dd      00000000000000000000000100000001b   ;0011
        dd      00000000000000010000000000000000b   ;0100
        dd      00000000000000010000000000000001b   ;0101
        dd      00000000000000010000000100000000b   ;0110
        dd      00000000000000010000000100000001b   ;0111
        dd      00000001000000000000000000000000b   ;1000
        dd      00000001000000000000000000000001b   ;1001
        dd      00000001000000000000000100000000b   ;1010
        dd      00000001000000000000000100000001b   ;1011
        dd      00000001000000010000000000000000b   ;1100
        dd      00000001000000010000000000000001b   ;1101
        dd      00000001000000010000000100000000b   ;1110
        dd      00000001000000010000000100000001b   ;1111


;-----------------------------------------------------------------------;
; vDIB4n8ToPlaner
;
; Converts a scan of a 4bpp or 8bpp DIB into planer format for bitblt
;
; Entry:
;   EBP --> ppc structure
; Exit:
;   ESI --> plane 0 of scan data
; Registers Destroyed:
;   EAX,EBX,EDX,EBP
; Registers Preserved:
;   ECX,EDI
;-----------------------------------------------------------------------;

ppc         equ     [ebp]

vDIB4n8ToPlaner proc

        push    ecx
        push    edi

; Load up the parameters for the blt

        mov     esi,ppc.pSrc                ;Source pointer
        mov     eax,ppc.iNextScan           ;Index to next scan
        add     eax,esi
        mov     ppc.pSrc,eax                ;Save next source pointer
        xor     eax,eax                     ;Creating a four bit index in eax

; pulXlate must be zero for 4bpp conversion since we will be using
; ebx for creating an index.  No problem since we don't need the
; translation by the time we're in this code.

        mov     ebx,ppc.pulXlate            ;Color translation or zero
        lea     edi,ajConvertBuffer         ;Where to store results

; Handle a partial first byte and all full bytes

        mov     ecx,ppc.cLeftMiddle         ;Get loop count for middle and left
        jecxz   vDIB4n8DoneFirst            ;No first/inner
        push    ebp
        push    offset FLAT:VDIB4n8FinishFirst   ;Set return address
        push    ppc.pfnLeftMiddle           ;Set proc for left partial byte
        mov     ebp,ppc.pulConvert          ;Base address of conversion table
        xor     edx,edx                     ;Init accumulated bits
        ret                                 ;To ppc.pfnLeftMiddle
VDIB4n8FinishFirst:                         ;It returns here
        pop     ebp

vDIB4n8DoneFirst:
        mov     ecx,ppc.pfnRight
        jecxz   short vDIB4n8DoneRightSide  ;No left side
        and     edx,01010101h               ;Carryover from a partial 4bpp byte
        push    ebp
        push    offset FLAT:VDIB4n8FinishLast    ;Set return address
        push    ecx                         ;Set function address
        mov     ecx,1                       ;No looping
        mov     ebp,ppc.pulConvert          ;Base address of conversion table
        ret                                 ;To ppc.pfnRight
VDIB4n8FinishLast:                          ;It returns here
        pop     ebp

        mov     cl,ppc.cLeftShift           ;Must align right side pels
        shl     edx,cl
        mov     [edi][CJ_PLANE*0][-1],dl
        mov     [edi][CJ_PLANE*1][-1],dh
        shr     edx,16
        mov     [edi][CJ_PLANE*2][-1],dl
        mov     [edi][CJ_PLANE*3][-1],dh

; Load up the source pointer and exit

vDIB4n8DoneRightSide:
        pop     edi
        pop     ecx
        mov     esi,ppc.pjConverted
        ret

vDIB4n8ToPlaner endp

ppc     equ     <>


;-----------------------------------------------------------------------;
; vDIB4Convert*
;
; Converts the specified number of source 4 bpp bits into the
; buffer.  These are support routines for vDIB4Planer, where a
; source byte converts into two aligned bits
;
; Entry:
;   EAX 31:8 = 0
;   EBP --> Bit conversion table
;   ESI --> Source bitmap
;   EDI --> Planer destination
;   ECX  =  Loop count
; Exit:
;   EBP --> Bit conversion table
;   ESI --> Next source byte
;   EDI --> Next planer destination
;   EDX  =  Last planer byte accumulated
; Registers Destroyed:
;   EAX,ECX,EDX
; Registers Preserved:
;-----------------------------------------------------------------------;

vDIB4Convert8::
        lodsb
        mov     ebx,eax
        shr     eax,4
        and     ebx,00001111b
        mov     edx,[ebp][eax*4]
        shl     edx,1
        or      edx,[ebp][ebx*4]
vDIB4Convert6::
        lodsb
        shl     edx,1
        mov     ebx,eax
        shr     eax,4
        and     ebx,00001111b
        or      edx,[ebp][eax*4]
        shl     edx,1
        or      edx,[ebp][ebx*4]
vDIB4Convert4::
        lodsb
        shl     edx,1
        mov     ebx,eax
        shr     eax,4
        and     ebx,00001111b
        or      edx,[ebp][eax*4]
        shl     edx,1
        or      edx,[ebp][ebx*4]
vDIB4Convert2::
        lodsb
        shl     edx,1
        mov     ebx,eax
        shr     eax,4
        and     ebx,00001111b
        or      edx,[ebp][eax*4]
        shl     edx,1
        or      edx,[ebp][ebx*4]
        mov     [edi][CJ_PLANE*0],dl
        mov     [edi][CJ_PLANE*1],dh
        ror     edx,16
        mov     [edi][CJ_PLANE*2],dl
        mov     [edi][CJ_PLANE*3],dh
        inc     edi
        dec     ecx
        jnz     vDIB4Convert8
        rol     edx,16                  ;Incase alignment of last byte
        ret


;-----------------------------------------------------------------------;
; vDIB4NAConvert*
;
; Converts the specified number of source 4 bpp bits into the
; buffer.  These are support routines for vDIB4Planer, where a
; source byte converts into two non-aligned bytes (we have to carry
; a bit over into the next destination byte).
;
; Entry:
;   EAX 31:8 = 0
;   EBP --> Bit conversion table
;   ESI --> Source bitmap
;   EDI --> Planer destination
;   ECX  =  Loop count
; Exit:
;   EBP --> Bit conversion table
;   ESI --> Next source byte
;   EDI --> Next planer destination
;   EDX  =  first pel of next destination
; Registers Destroyed:
;   EAX,ECX,EDX
; Registers Preserved:
;-----------------------------------------------------------------------;

vDIB4NAConvert7::
        lodsb
        shl     edx,1                   ;Carry over bit from last fetch
        mov     ebx,eax
        shr     eax,4
        and     ebx,00001111b
        or      edx,[ebp][eax*4]
        shl     edx,1
        or      edx,[ebp][ebx*4]
vDIB4NAConvert5::
        lodsb
        shl     edx,1
        mov     ebx,eax
        shr     eax,4
        and     ebx,00001111b
        or      edx,[ebp][eax*4]
        shl     edx,1
        or      edx,[ebp][ebx*4]
vDIB4NAConvert3::
        lodsb
        shl     edx,1
        mov     ebx,eax
        shr     eax,4
        and     ebx,00001111b
        or      edx,[ebp][eax*4]
        shl     edx,1
        or      edx,[ebp][ebx*4]
vDIB4NAConvert1::
        lodsb
        shl     edx,1
        mov     ebx,eax
        shr     eax,4
        and     ebx,00001111b
        or      edx,[ebp][eax*4]
        mov     [edi][CJ_PLANE*0],dl
        mov     [edi][CJ_PLANE*1],dh
        shr     edx,16
        mov     [edi][CJ_PLANE*2],dl
        mov     [edi][CJ_PLANE*3],dh
        inc     edi
        mov     edx,[ebp][ebx*4]            ;Start of next destination byte
        dec     ecx
        jnz     vDIB4NAConvert7
        ret

;-----------------------------------------------------------------------;
; vDIB4NAConvert0
;
; Last byte code for the 4bpp non-aligned case where the data already
; exists in EDX, but we have to increment the destination pointer since
; vDIB4n8ToPlaner assumes we stored the data and incremented the pointer
;
; Entry:
;   EDI --> destination
; Exit:
;   EDI  =  EDI + 1
; Registers Destroyed:
;   None
; Registers Preserved:
;   All but EDI
;-----------------------------------------------------------------------;

vDIB4NAConvert0 proc

        inc     edi
vNOP::
        ret

vDIB4NAConvert0 endp



;-----------------------------------------------------------------------;
; The following table is indexed into to get the address of where to
; enter the 4bpp conversion loops
;-----------------------------------------------------------------------;

apfn4bppConvert         label   dword

        dd      offset FLAT:vDIB4Convert8
        dd      offset FLAT:vDIB4NAConvert7
        dd      offset FLAT:vDIB4Convert6
        dd      offset FLAT:vDIB4NAConvert5
        dd      offset FLAT:vDIB4Convert4
        dd      offset FLAT:vDIB4NAConvert3
        dd      offset FLAT:vDIB4Convert2
        dd      offset FLAT:vDIB4NAConvert1

;-----------------------------------------------------------------------;
; The following table is indexed into to get the address of where to
; enter the 4bpp conversion loops for a partial right hand side byte
;-----------------------------------------------------------------------;

apfn4bppConvertRHS      label   dword

        dd      offset FLAT:vNOP            ;Should never be called
        dd      offset FLAT:vDIB4Convert6   ;Convert three more source bytes
        dd      offset FLAT:vDIB4Convert6   ;Convert three      source bytes
        dd      offset FLAT:vDIB4Convert4   ;Convert two   more source bytes
        dd      offset FLAT:vDIB4Convert4   ;Convert two        source bytes
        dd      offset FLAT:vDIB4Convert2   ;Convert one   more source byte
        dd      offset FLAT:vDIB4Convert2   ;Convert one        source byte
        dd      offset FLAT:vDIB4NAConvert0 ;Non-aligned, data in EDX already

;-----------------------------------------------------------------------;
; vDIB8Convert*
;
; Converts the specified number of source 8 bpp bits into the
; buffer.  These are support routines for vDIB8Planer.
;
; Entry:
;   EAX 31:8 = 0
;   EBP --> Bit conversion table
;   EBX --> Color translation table
;   ESI --> Source bitmap
;   EDI --> Planer destination
;   ECX  =  Loop count
; Exit:
;   EBP --> Bit conversion table
;   EBX --> Color translation table
;   ESI --> Next source byte
;   EDI --> Next planer destination
; Registers Destroyed:
;   EAX,ECX,EDX
; Registers Preserved:
;   None
;-----------------------------------------------------------------------;

vDIB8Convert8::
        lodsb                           ;Get pel 1
        mov     al,[ebx][eax*4]         ;Color translation into 4 bits
        mov     edx,[ebp][eax*4]
vDIB8Convert7::
        lodsb                           ;Get pel 2
        shl     edx,1
        mov     al,[ebx][eax*4]
        or      edx,[ebp][eax*4]
vDIB8Convert6::
        lodsb                           ;Get pel 2
        shl     edx,1
        mov     al,[ebx][eax*4]
        or      edx,[ebp][eax*4]
vDIB8Convert5::
        lodsb                           ;Get pel 2
        shl     edx,1
        mov     al,[ebx][eax*4]
        or      edx,[ebp][eax*4]
vDIB8Convert4::
        lodsb                           ;Get pel 2
        shl     edx,1
        mov     al,[ebx][eax*4]
        or      edx,[ebp][eax*4]
vDIB8Convert3::
        lodsb                           ;Get pel 2
        shl     edx,1
        mov     al,[ebx][eax*4]
        or      edx,[ebp][eax*4]
vDIB8Convert2::
        lodsb                           ;Get pel 2
        shl     edx,1
        mov     al,[ebx][eax*4]
        or      edx,[ebp][eax*4]
vDIB8Convert1::
        lodsb                           ;Get pel 7
        shl     edx,1
        mov     al,[ebx][eax*4]
        or      edx,[ebp][eax*4]
        mov     [edi][CJ_PLANE*0],dl
        mov     [edi][CJ_PLANE*1],dh
        ror     edx,16
        mov     [edi][CJ_PLANE*2],dl
        mov     [edi][CJ_PLANE*3],dh
        inc     edi
        dec     ecx
        jnz     vDIB8Convert8
        rol     edx,16                  ;Incase alignment of last byte
        ret

;-----------------------------------------------------------------------;
; The following table is indexed into to get the address of where to
; enter the 8bpp conversion loop
;-----------------------------------------------------------------------;

apfn8bppConvert label   dword
        dd      offset FLAT:vDIB8Convert8
        dd      offset FLAT:vDIB8Convert7
        dd      offset FLAT:vDIB8Convert6
        dd      offset FLAT:vDIB8Convert5
        dd      offset FLAT:vDIB8Convert4
        dd      offset FLAT:vDIB8Convert3
        dd      offset FLAT:vDIB8Convert2
        dd      offset FLAT:vDIB8Convert1


;-----------------------------------------------------------------------;
; vDIB8Preprocess()
;
; Performs whatever processing is necessary to prepare for a blt from
; a 8bpp DIB to a planer format bitmap.
;
; Entry:
;   EBP --> Bitblt frame structure
; Exit:
;   None
; Registers Destroyed:
;   EAX,EBX,ECX,EDX,ESI,EDI
; Registers Preserved:
;   EBP,EBX
;-----------------------------------------------------------------------;

fr      equ     [ebp]

cProc   vDIB8Preprocess

        push    ebx
        mov     fr.ppcBlt.pulConvert,offset FLAT:aulDefBitMapping

; Align the blt so that the blt's phase will become 0.  Both origins are
; guaranteed to be positive and < 16 bits !!!

        movzx   eax,fr.DestxOrg         ;Align source and dest X origins
        mov     edx,eax
        mov     ax,fr.SrcxOrg
        mov     fr.SrcxOrg,dx           ;D31:16 is zero for both
        add     eax,fr.src.lp_bits
        mov     fr.ppcBlt.pSrc,eax      ;Save address of first source pel
        and     edx,7                   ;Always start in first byte of buffer
        push    edx                     ;Save for computing loop entry
        movzx   ebx,fr.xExt             ;Compute exclusive right hand side (rhs)
        add     ebx,edx
        push    ebx                     ;Save rhs for shift count computation

; comp_byte_interval returns:
;
;   EDI = offset to first byte to be altered in the scan
;   ESI = inner loop count (possibly 0)
;   AL  = first byte mask (possibly 0)
;   AH  = last  byte mask (possibly 0)

        cCall   comp_byte_interval
        pop     ebx                     ;Exclusive rhs
        pop     edx                     ;Inclusive lhs

; If only a partial destination byte will be altered, the mask will have
; been returned in AL with AH and ESI 0.

        or      ah,ah                   ;See if only a first byte
        jnz     short @f                ;More than one byte to alter
        or      esi,esi
        jnz     @F                      ;More than a partial byte

; There will only be a partial byte.  The normal flow-o-control falls apart
; so we have to special case it.

        mov     fr.ppcBlt.cLeftMiddle,esi   ;No first/inner loop
        mov     eax,8
        sub     eax,ebx
        mov     fr.ppcBlt.cLeftShift,al ;Set shift count to align last byte
        mov     eax,8
        sub     ebx,edx                 ;EBX = # pels needed (<8)
        sub     eax,ebx
        mov     eax,apfn8bppConvert[eax*4]
        jmp     short v8bpp_have_last

@@:

; More than a single byte will be written for the destination.  Compute entry
; into the convert loop based on the destination X origin.  If the X dest
; origin was zero, the first byte will have been combined into the inner loop
; count

        cmp     al,1                    ;If partial first byte we need to bump
        cmc                             ;  the loop count by 1
        adc     esi,0
        mov     edx,apfn8bppConvert[edx*4]
        mov     al,ah                       ;Set last byte mask
        mov     fr.ppcBlt.pfnLeftMiddle,edx
v8bpp_have_first_inner:
        mov     fr.ppcBlt.cLeftMiddle,esi   ;Save innerloop count (possibly 0)

; Compute the function and shift count for the last byte (if one exists)

        movzx   eax,al
        or      eax,eax
        jz      short v8bpp_have_last   ;No last byte, set pfn = 0
        mov     al,8                    ;D31:8 set to 0 with above movzx
        sub     eax,ebx
        and     eax,00000111b
        mov     fr.ppcBlt.cLeftShift,al ;Set shift count to align last byte
        mov     eax,apfn8bppConvert[eax*4]
v8bpp_have_last:
        mov     fr.ppcBlt.pfnRight,eax

; Set the address of routine which will be called from the compiled blt

        mov     fr.ppcBlt.pfnConvert,offset FLAT:vDIB4n8ToPlaner
        mov     fr.ppcBlt.pjConverted,offset FLAT:ajConvertBuffer
        pop     ebx
        cRet    vDIB8Preprocess

endProc vDIB8Preprocess



;-----------------------------------------------------------------------;
; vDIB4Preprocess()
;
; Performs whatever processing is necessary to prepare for a blt from
; a 4bpp DIB to a planer format bitmap.
;
; Entry:
;   EBP --> Bitblt frame structure
; Exit:
;   None
; Registers Destroyed:
;   EAX,EBX,ECX,EDX,ESI,EDI
; Registers Preserved:
;   EBP,EBX
;-----------------------------------------------------------------------;

fr      equ     [ebp]

cProc   vDIB4Preprocess

        push    ebx

; If a color translation vector was given, generate the new bit
; conversion array

        mov     eax,offset FLAT:aulDefBitMapping
        cld
        mov     esi,fr.ppcBlt.pulXlate
        or      esi,esi
        jz      vDIB4_have_mapping_array
        lea     edi,fr.aulMap
        mov     ecx,16
create_next_bit_mapping:
        lodsd
        mov     eax,aulDefBitMapping[eax*4]
        stosd
        dec     ecx
        jnz     create_next_bit_mapping
        lea     eax,[edi][-16*4]
vDIB4_have_mapping_array:
        mov     fr.ppcBlt.pulConvert,eax


; Align the blt so that the blt's phase will become 0.  Both origins are
; guaranteed to be positive and < 16 bits !!!

        movzx   eax,fr.DestxOrg         ;Align source and dest X origins
        mov     edx,eax                 ;Save for later calculations
        mov     ax,fr.SrcxOrg           ;D31:16 is zero for both
        mov     fr.SrcxOrg,dx

; We never want to process a partial source byte.  We will move the source
; left if necessary, and adjust the extent if necessary.  Note that if any
; adjustments are made, we won't fetch past the end of the source nor
; will we write beyond the end of our buffer (since we made it big enough
; in the first place).

; We don't worry about adjusting the source origin before we save it
; since we will be shifting it right later to round it to a byte address

        mov     ecx,eax
        shr     ecx,1
        add     ecx,fr.src.lp_bits
        mov     fr.ppcBlt.pSrc,ecx      ;Save address of first pel
        and     eax,1                   ;EAX = 1 if source is odd pel
        movzx   ebx,fr.xExt
        sub     edx,eax                 ;Move dest left if necessary
        add     ebx,eax                 ;Also bump extent if moved
        and     edx,7                   ;Start dest in first byte of buffer
        inc     ebx                     ;Round extent to a multiple of 2
        and     bl,11111110b
        add     ebx,edx                 ;Exclusive right hand side

; A problem:  When moving the source left a pel, we can encounter a situation
; wherein the first pel written is in bit position 0.  However, it should be
; noted that this pel is not part of the blt, so we have to skip over the
; byte containing it to get to the correct first pel (which will be bit 7
; of the next byte).

        cmp     dl,7
        je      @F
        xor     ax,ax
@@:
        add     eax,offset FLAT:ajConvertBuffer
        mov     fr.ppcBlt.pjConverted,eax

; comp_byte_interval returns:
;
;   EDI = offset to first byte to be altered in the scan
;   ESI = inner loop count (possibly 0)
;   AL  = first byte mask (possibly 0)
;   AH  = last  byte mask (possibly 0)

        push    edx                     ;Save for computing loop entry
        push    ebx                     ;Save rhs for shift count computation
        cCall   comp_byte_interval
        pop     ebx                     ;Exclusive rhs
        pop     edx                     ;Inclusive lhs

; If only a partial destination byte will be altered, the mask will have
; been returned in AL with AH and ESI 0.

        or      ah,ah                   ;See if only a first byte
        jnz     short @f                ;More than one byte to alter
        or      esi,esi
        jnz     short @f                ;More than one byte

; There will only be a partial byte.  The normal flow-o-control falls apart
; so we have to special case it.

        mov     fr.ppcBlt.cLeftMiddle,esi   ;No first/inner loop
        mov     eax,8
        sub     eax,ebx
        mov     fr.ppcBlt.cLeftShift,al ;Set shift count to align last byte
        mov     eax,8
        sub     ebx,edx                 ;EBX = # pels needed (<8)
        sub     eax,ebx
        mov     eax,apfn4bppConvertRHS[eax*4]
        jmp     short v4bpp_have_last

@@:

; More than a single byte will be written for the destination.  Compute entry
; into the convert loop based on the destination X origin.  If the X dest
; origin was zero, the first byte will have been combined into the inner loop
; count

        cmp     al,1                    ;If partial first byte we need to bump
        cmc                             ;  the loop count by 1
        adc     esi,0
        mov     ecx,apfn4bppConvert[edx*4]
        mov     al,ah                      ;Set last byte mask
        mov     fr.ppcBlt.pfnLeftMiddle,ecx
v4bpp_have_first_inner:
        mov     fr.ppcBlt.cLeftMiddle,esi   ;Save innerloop count (possibly 0)

; Compute the function and shift count for the last byte (if one exists)

        movzx   eax,al
        or      eax,eax
        jz      short v4bpp_have_last   ;No last byte, set pfn = 0
        mov     al,8                    ;D31:8 set to 0 with above movzx
        sub     eax,ebx
        and     eax,00000111b
        mov     fr.ppcBlt.cLeftShift,al ;Set shift count to align last byte
        mov     eax,apfn4bppConvertRHS[eax*4]
v4bpp_have_last:
        mov     fr.ppcBlt.pfnRight,eax

; Set the address of the routine which will be called from the compiled blt

        mov     fr.ppcBlt.pfnConvert,offset FLAT:vDIB4n8ToPlaner
        pop     ebx
        cRet    vDIB4Preprocess

endProc vDIB4Preprocess


;----------------------------Private-Routine----------------------------;
; packed_pel_comp_y
;
; Compute y-related parameters.
;
; The parameters related to the Y coordinate and BLT direction
; are computed.  The parameters include:
;
;       a) Index to next scan line
;       b) Starting Y address calculation
;       d) Index to next plane
;
; Entry:
;       EBP --> Blt frame
;       AX  =  Y coordinate
;       ECX =  BLT direction
;              0000 = Y+
;              FFFF = Y-
;       BX  =  inclusive Y extent
; Returns:
;       None
; Registers Preserved:
;       EBP,ECX,EBX,EDX
; Registers Destroyed:
;       EAX,ESI,EDI,flags
; Calls:
;       None
; History:
;-----------------------------------------------------------------------;

fr      equ     [ebp]

cProc   packed_pel_comp_y

        push    edx
        mov     fr.src.next_plane,CJ_PLANE  ;Index to next plane of data
        movsx   esi,fr.src.width_b          ;Need bmWidthBytes couple-o-times
        movzx   eax,ax
        mul     esi                         ;Compute Y address
        add     fr.ppcBlt.pSrc,eax          ;Add to base address

        xor     esi,ecx                     ;1's complement if Y-
        sub     esi,ecx                     ;2's complement if Y-
        mov     fr.ppcBlt.iNextScan,esi     ;Set index to next scan line
        pop     edx
        cRet    packed_pel_comp_y

endProc packed_pel_comp_y

_TEXT$03   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\fasttext.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: fasttext.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; VOID vFastText(GLYPHPOS * pGlyphPos, ULONG ulGlyphCount, PBYTE pTempBuffer,
;                ULONG ulBufDelta, ULONG ulCharInc, DEVSURF * pdsurf,
;                RECTL * prclText, RECTL * prclOpaque, INT iFgColor,
;                INT iBgColor, ULONG fDrawFlags, RECTL * prclClip,
;                RECTL * prclExtra, ULONG iTrgType);
; pGlyphPos -
; ulGlyphCount - # of glyphs to draw. Must never be 0.
; pTempBuffer -
; ulBufDelta -
; ulCharInc -
; pdsurf -
; prclText -
; prclOpaque -
; iFgColor -
; iBgColor -
; fDrawFlags -
; prclClip -     array of clipping rectangles
; prclExtra -    array of extra rectanlges to fill in foreground color
; iTrgType -     0 = VGA; 1 = DFB; 2 = NONE
;
; Performs accelerated proportional text drawing.
;
;-----------------------------------------------------------------------;
;
; Note: prclClip and prclExtra are null rectangle (yBottom=0) terminated
;       arrays
;
; Note: Assumes the text rectangle has a positive height and width. Will
; not work properly if this is not the case.
;
; Note: The opaquing rectangle is assumed to match the text bounding
; rectangle exactly; prclOpaque is used only to determine whether or
; not opaquing is required.
;
; Note: For maximum performance, we should not bother to draw fully-
; clipped characters to the temp buffer.
;
; Note: We do not handle clipping or bank spanning in the very fast
; byte-wide-aligned-fixed-pitch console text. This would be an
; opportunity for somewhat faster console text performance.
;
;-----------------------------------------------------------------------;

        comment $

The overall approach of this module is to draw the text into a system
memory buffer, then copy the buffer to the screen a word at a time
using write mode 3 so that no OUTs and a minimum of display memory reads
are required.

        commend $

        .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc

        .list

;-----------------------------------------------------------------------;

        .data

        align   4

extrn   dfbfill_jLeftMasks:dword        ;identical static table to DFBFILL, so use it.
extrn   dfbfill_jRightMasks:dword       ;identical static table to DFBFILL, so use it.
extrn   dfbfill_pfnScanHandlers:dword   ;identical static table to DFBFILL, so use it.


pfnCopyTextOpaq         label   dword
        dd      copy_text_opaq_00
        dd      copy_text_opaq_01
        dd      copy_text_opaq_10
        dd      copy_text_opaq_11

pfnCopyInvTextOpaq      label   dword
        dd      copy_inv_text_opaq_00
        dd      copy_inv_text_opaq_01
        dd      copy_inv_text_opaq_10
        dd      copy_inv_text_opaq_11

pfnCopyTextXpar         label   dword
        dd      copy_text_xpar_00
        dd      copy_text_xpar_01
        dd      copy_text_xpar_10
        dd      copy_text_xpar_11

pfnCopyInvTextXpar      label   dword
        dd      copy_inv_text_xpar_00
        dd      copy_inv_text_xpar_01
        dd      copy_inv_text_xpar_10
        dd      copy_inv_text_xpar_11


;-----------------------------------------------------------------------;
; Tables used to branch into glyph-drawing optimizations.
;
; Handles narrow (1-4 bytes wide) glyph drawing, for case where initial byte
; should be MOVed even if it's not aligned (intended for use in drawing the
; first glyph in a string). Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
MovInitialTableNarrow   label   dword
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      mov_first_1_wide_rotated_need_last ;nonalign, 1 wide, need last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      mov_first_1_wide_rotated_no_last   ;nonalign, 1 wide, no last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      mov_first_2_wide_rotated_need_last ;nonalign, 2 wide, need last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      mov_first_2_wide_rotated_no_last   ;nonalign, 2 wide, no last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      mov_first_3_wide_rotated_need_last ;nonalign, 3 wide, need last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      mov_first_3_wide_rotated_no_last   ;nonalign, 3 wide, no last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      mov_first_4_wide_rotated_need_last ;nonalign, 4 wide, need last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide
        dd      mov_first_4_wide_rotated_no_last   ;nonalign, 4 wide, no last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide

; Handles narrow (1-4 bytes wide) glyph drawing, for case where initial byte
; ORed if it's not aligned (intended for use in drawing all but the first glyph
; in a string). Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrInitialTableNarrow    label   dword
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      or_first_1_wide_rotated_need_last  ;nonalign, 1 wide, need last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      or_first_1_wide_rotated_no_last    ;nonalign, 1 wide, no last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      or_first_2_wide_rotated_need_last  ;nonalign, 2 wide, need last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      or_first_2_wide_rotated_no_last    ;nonalign, 2 wide, no last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      or_first_3_wide_rotated_need_last  ;nonalign, 3 wide, need last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      or_first_3_wide_rotated_no_last    ;nonalign, 3 wide, no last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      or_first_4_wide_rotated_need_last  ;nonalign, 4 wide, need last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide
        dd      or_first_4_wide_rotated_no_last    ;nonalign, 4 wide, no last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide

; Handles narrow (1-4 bytes wide) glyph drawing, for case where all bytes
; should be ORed (intended for use in drawing potentially overlapping glyphs).
; Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrAllTableNarrow        label   dword
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      or_all_1_wide_rotated_need_last    ;nonalign, 1 wide, need last
        dd      or_all_1_wide_unrotated            ;aligned, 1 wide
        dd      or_all_1_wide_rotated_no_last      ;nonalign, 1 wide, no last
        dd      or_all_1_wide_unrotated            ;aligned, 1 wide
        dd      or_all_2_wide_rotated_need_last    ;nonalign, 2 wide, need last
        dd      or_all_2_wide_unrotated            ;aligned, 2 wide
        dd      or_all_2_wide_rotated_no_last      ;nonalign, 2 wide, no last
        dd      or_all_2_wide_unrotated            ;aligned, 2 wide
        dd      or_all_3_wide_rotated_need_last    ;nonalign, 3 wide, need last
        dd      or_all_3_wide_unrotated            ;aligned, 3 wide
        dd      or_all_3_wide_rotated_no_last      ;nonalign, 3 wide, no last
        dd      or_all_3_wide_unrotated            ;aligned, 3 wide
        dd      or_all_4_wide_rotated_need_last    ;nonalign, 4 wide, need last
        dd      or_all_4_wide_unrotated            ;aligned, 4 wide
        dd      or_all_4_wide_rotated_no_last      ;nonalign, 4 wide, no last
        dd      or_all_4_wide_unrotated            ;aligned, 4 wide

; Handles arbitrarily wide glyph drawing, for case where initial byte should be
; MOVed even if it's not aligned (intended for use in drawing the first glyph
; in a string). Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
MovInitialTableWide     label   dword
        dd      mov_first_N_wide_rotated_need_last      ;nonalign, need last
        dd      mov_first_N_wide_unrotated              ;aligned
        dd      mov_first_N_wide_rotated_no_last        ;nonalign, no last
        dd      mov_first_N_wide_unrotated              ;aligned

; Handles arbitrarily wide glyph drawing, for case where initial byte should be
; ORed if it's not aligned (intended for use in drawing all but the first glyph
; in a string). Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrInitialTableWide      label   dword
        dd      or_first_N_wide_rotated_need_last       ;nonalign, need last
        dd      mov_first_N_wide_unrotated              ;aligned
        dd      or_first_N_wide_rotated_no_last         ;nonalign, no last
        dd      mov_first_N_wide_unrotated              ;aligned

; Handles arbitrarily wide glyph drawing, for case where all bytes should
; be ORed (intended for use in drawing potentially overlapping glyphs).
; Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrAllTableWide  label   dword
        dd      or_all_N_wide_rotated_need_last ;nonalign, need last
        dd      or_all_N_wide_unrotated         ;aligned
        dd      or_all_N_wide_rotated_no_last   ;nonalign, no last
        dd      or_all_N_wide_unrotated         ;aligned

; Vectors to entry points for drawing various types of text. '*' means works as
; is but could be acclerated with a custom scanning loop.
        align   4
MasterTextTypeTable     label   dword       ;tops aligned  overlap  fixed pitch
        dd      draw_nf_ntb_o_to_temp_start ;      N          N          N *
        dd      draw_f_ntb_o_to_temp_start  ;      N          N          Y *
        dd      draw_nf_ntb_o_to_temp_start ;      N          Y          N
        dd      draw_f_ntb_o_to_temp_start  ;      N          Y          Y
        dd      draw_nf_tb_no_to_temp_start ;      Y          N          N
        dd      draw_f_tb_no_to_temp_start  ;      Y          N          Y
        dd      draw_nf_ntb_o_to_temp_start ;      Y          Y          N *
        dd      draw_f_ntb_o_to_temp_start  ;      Y          Y          Y *


XparInnerLoop   label   dword
        dd      xpar_byte_loop_00
        dd      xpar_byte_loop_01
        dd      xpar_byte_loop_10
        dd      xpar_byte_loop_11

; Masks for clipping for the eight possible left and right edge alignments
jOpaqueLeftMasks        label   byte
        db      0ffh,07fh,03fh,01fh,00fh,007h,003h,001h

jOpaqueRightMasks       label   byte
        db      0ffh,080h,0c0h,0e0h,0f0h,0f8h,0fch,0feh

;-----------------------------------------------------------------------;

                .code

_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;-----------------------------------------------------------------------;

cProc vFastText,56,<\
 uses esi edi ebx,\
 pGlyphPos:ptr,\
 ulGlyphCount:dword,\
 pTempBuffer:ptr,\
 ulBufDelta:dword,\
 ulCharInc:dword,\
 pdsurf:ptr,\
 prclText:ptr,\
 prclOpaque:ptr,\
 iFgColor:dword,\
 iBgColor:dword,\
 fDrawFlags:dword,\
 prclClip:dword,\
 prclExtra:dword,\
 iTrgType:dword>

        local ulGlyDelta:dword  ;width per scan of source glyph, in bytes
        local ulWidthInBytes:dword ;width of glyph, in bytes
        local ulTmpWidthInBytes:dword ;working byte-width count
        local ulGlyphX:dword    ;for fixed-pitch text, maintains the current
                                ; glyph's left-edge X coordinate
        local pGlyphLoop:dword  ;pointer to glyph-processing loop
        local ulTempLeft:dword  ;X coordinate on screen of left edge of temp
                                ; buffer
        local ulTempTop:dword   ;Y coordinate on screen of top edge of temp
                                ; buffer
        local ulLoopCount:dword ;general loop count storage
        local ulTmpSrcDelta:dword ;distance from end of one buffer text scan to
                                  ; start of next
        local ulTmpDstDelta:dword ;distance from end of one screen text scan to
                                  ; start of next
        local ulTopScan:dword     ;top scan of dest text rect in current bank
        local ulBottomScan:dword  ;bottom scan of dest text rect
        local ulNumScans:dword    ;# of scans to draw
        local ulScreenDelta:dword ;scan-to-scan offset in screen
        local ulTextWidthInBytes:dword ;# of bytes across spanned by text
        local pScreen:dword     ;pointer to first screen byte to which to draw
        local pfnEdgeVector:dword ;pointer to routine to draw any needed edges
        local pfnFirstOpaqVector:dword ;pointer to initial drawing routine
                                       ; called for opaque (either whole
                                       ; bytes, or edge(s) if no whole bytes)
        local ulWholeWidthInWords:dword ;# of whole words to copy
        local ulWholeWidthInWordsMinus1:dword ;# of whole words to copy, -1
        local ulOddByte:dword   ;1 if odd byte in whole word copy
        local ulTextLeft:dword  ;left edge of leftmost glyph
        local ulLeftMask:dword  ;for opaque text, left edge mask for string
        local ulRightMask:dword ;for opaque text, right edge mask for string
        local ulScans:dword     ;# of scans to draw
        local ulYOrigin:dword   ;Y origin of text in string (all glyphs are at
                                ; the same Y origin)
        local rclClippedBounds[16]:byte ;clipped destination rectangle;
                                        ; defined as "byte" due to assembler
                                        ; limitations

        local sDfbInfo[size DFBBLT]:byte ;storage for info used in fill code
        local ulRectLeft:dword
        local ulRectRight:dword
        local pfnDrawScans:dword         ;ptr to correct scan drawing function
        local pTempBufferSaved:dword
        local ulEdgeFlags:dword
        local ulBytesPerDstPlane:dword
        local ulLeftOffset:dword
        local pSrc:dword
        local pDst:dword
        local ulPlaneBit:dword

TRAILING_PARTIAL        equ     01h      ;partial trailing dword should be copied
LEADING_PARTIAL         equ     02h      ;partial leading dword should be copied

;-----------------------------------------------------------------------;

        cld

;-----------------------------------------------------------------------;
; Draws either a fixed or a non-fixed-pitch string to the temporary
; buffer. Assumes this is a horizontal string, so the origins of all glyphs
; are at the same Y coordinate. Draws leftmost glyph entirely with MOVs,
; even if it's not aligned, in order to ensure that the leftmost byte
; gets cleared when we're working with butted characters. For other
; non-aligned glyphs, leftmost byte is ORed, other bytes are MOVed.
;
; Input:
;       pGlyphPos = pointer to array of GLYPHPOS structures to draw
;       ulGlyphCount = # of glyphs to draw
;       ulTempLeft = X coordinate on dest of left edge of temp buffer pointed
;               to by pTempBuffer
;       pTempBuffer = pointer to first byte (upper left corner) of
;               temp buffer into which we're drawing. This should be
;               dword-aligned with the destination
;       ulBufDelta = destination scan-to-scan offset
;       ulCharInc = offset from one glyph to next (fixed-pitch only)
;       fDrawFlags = indicate the type of text to be drawn
;       Temp buffer zeroed if text doesn't cover every single pixel
;
; Fixed-pitch means equal spacing between glyph positions, not that all
; glyphs butt together or equal spacing between upper left corners.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; If 8 wide, byte aligned, and opaque, handle with very fast special-case
; code.
;-----------------------------------------------------------------------;

        mov     ebx,prclText
        sub     eax,eax
        cmp     ulCharInc,8                     ;8 wide?
        jnz     short @F                        ;no
        cmp     fDrawFlags,5                    ;fixed pitch?
        jnz     short @F                        ;no
        cmp     prclOpaque,eax                  ;opaque?
        jz      short @F                        ;no
        cmp     iTrgType,eax                    ;is target VGA?
        jnz     short @F                        ;no
        cmp     prclClip,eax                    ;is there clipping?
        jnz     short @F                        ;yes
        cmp     prclExtra,eax                   ;are there extra rectangles?
        jnz     short @F                        ;yes
        test    [ebx].xLeft,111b                ;byte aligned?
        jz      special_8_wide_aligned_opaque   ;yes, special-case
@@:

;-----------------------------------------------------------------------;
; Handle all cases other than 8-wide byte-aligned.
;-----------------------------------------------------------------------;

general_handler:
        mov     esi,pdsurf
        mov     eax,[ebx].yTop
        mov     ulTempTop,eax   ;Y screen coordinate of top edge of temp buf
        mov     eax,[ebx].xLeft
        and     eax,not 7
        mov     ulTempLeft,eax  ;X screen coordinate of left edge of temp buf
        mov     eax,[esi].dsurf_lNextScan
        mov     ulScreenDelta,eax

        mov     eax,fDrawFlags

        jmp     MasterTextTypeTable[eax*4]

;-----------------------------------------------------------------------;
; Entry point for fixed-pitch | tops and bottoms aligned | no overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_f_tb_no_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,[ebx].gp_x          ;dest X coordinate
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer (we assume the text is
                                        ; right at the top of the text rect
                                        ; and hence the buffer)
        mov     ulGlyphX,edi            ;remember where this glyph started
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        mov     pGlyphLoop,offset draw_f_tb_no_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        jmp     short draw_to_temp_start_entry

;-----------------------------------------------------------------------;
; Entry point for non-fixed-pitch | tops and bottoms aligned | no overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_nf_tb_no_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,[ebx].gp_x          ;dest X coordinate
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        mov     pGlyphLoop,offset draw_nf_tb_no_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
draw_to_temp_start_entry::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
                                        ;??? add or sub?
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        add     edi,pTempBuffer         ;initial dest byte in temp buffer

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes per scan

        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     MovInitialTableNarrow[eax*4]
                                        ;branch to draw the first glyph; never
                                        ; need to OR first glyph, because
                                        ; there's nothing there yet

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     MovInitialTableWide[eax*4]
                                        ;branch to draw the first glyph; never
                                        ; need to OR first glyph, because
                                        ; there's nothing there yet

;-----------------------------------------------------------------------;
; Entry point for fixed-pitch | tops and bottoms not aligned | overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_f_ntb_o_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     pGlyphLoop,offset draw_f_ntb_o_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     ulGlyphX,edi            ;remember where this glyph started
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        jmp     short draw_to_temp_start_entry2

;-----------------------------------------------------------------------;
; Entry point for non-fixed-pitch | tops and bottoms not aligned | overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_nf_ntb_o_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     pGlyphLoop,offset draw_nf_ntb_o_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
                                        ;??? add or sub?
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
draw_to_temp_start_entry2::
        mov     eax,[ebx].gp_y          ;dest origin Y coordinate
        sub     eax,ulTempTop           ;coord of glyph origin in temp buffer
        mov     ulYOrigin,eax           ;remember the Y origin of all glyphs
                                        ; (necessary because glyph positions
                                        ; after first aren't set for fixed-
                                        ; pitch strings)
        add     eax,[esi].gb_y          ;adjust to position of upper left glyph
                                        ; corner in dest
        mul     ulBufDelta              ;offset in buffer of top glyph scan
        add     eax,pTempBuffer         ;initial dest byte
        add     edi,eax

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes per scan

        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableNarrow[eax*4] ;branch to draw the first glyph; OR all
                                        ; glyphs, because text may overlap

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableWide[eax*4]   ;branch to draw the first glyph; OR all
                                        ; glyphs, because text may overlap

;-----------------------------------------------------------------------;
; Loop to draw all fixed-pitch | tops and bottoms aligned | no overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_f_tb_no_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one
        mov     pGlyphPos,ebx           ; we're going to draw this time)
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,ulGlyphX            ;last glyph's dest X start in temp buf
        add     edi,ulCharInc           ;this glyph's dest X start in temp buf
        mov     ulGlyphX,edi            ;remember for next glyph
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        jmp     short draw_to_temp_loop_entry

;-----------------------------------------------------------------------;
; Loop to draw all non-fixed-pitch | tops and bottoms aligned | no overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_nf_tb_no_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        sub     edi,ulTempLeft          ;adjust relative to the left edge of
                                        ; the temp buffer

draw_to_temp_loop_entry::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi                 ;pixel X coordinate in temp buffer
        shr     edi,3                   ;byte offset of first column = dest
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        add     edi,pTempBuffer         ;initial dest byte

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes to copy to per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes to copy from per
                                        ; scan
        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrInitialTableNarrow[eax*4] ;branch to draw the first glyph;
                                            ; need to OR the 1st byte if
                                            ; non-aligned to avoid overwriting
                                            ; what's already there
@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrInitialTableWide[eax*4] ;branch to draw the next glyph;
                                          ; need to OR the 1st byte if
                                          ; non-aligned to avoid overwriting
                                          ; what's already there

;-----------------------------------------------------------------------;
; Loop to draw all fixed-pitch | tops and bottoms not aligned | overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_f_ntb_o_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)

        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,ulGlyphX            ;last glyph's dest X start in temp buf
        add     edi,ulCharInc           ;this glyph's dest X start in temp buf
        mov     ulGlyphX,edi            ;remember for next glyph
        mov     esi,[esi].gdf_pgb       ;point to glyph bits

        mov     eax,ulYOrigin           ;dest Y coordinate
        jmp     short draw_to_temp_loop_entry2

;-----------------------------------------------------------------------;
; Loop to draw all non-fixed-pitch | tops and bottoms not aligned | overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_nf_ntb_o_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)

        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        sub     edi,ulTempLeft          ;adjust relative to the left edge of
                                        ; the temp buffer
        mov     eax,[ebx].gp_y          ;dest origin Y coordinate
        sub     eax,ulTempTop           ;coord of glyph origin in temp buffer
draw_to_temp_loop_entry2::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi                 ;pixel X coordinate in temp buffer
        shr     edi,3                   ;byte offset of first column = dest
                                        ; offset of upper left of glyph in temp
                                        ; buffer

        add     eax,[esi].gb_y          ;adjust to position of upper left glyph
                                        ; corner in dest
        mul     ulBufDelta              ;offset in buffer of top glyph scan
        add     eax,pTempBuffer         ;initial dest byte
        add     edi,eax

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes to copy to per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes to copy from per
                                        ; scan
        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableNarrow[eax*4] ;branch to draw the next glyph

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableWide[eax*4]   ;branch to draw the next glyph

;-----------------------------------------------------------------------;
; Routines to draw all scans of a single glyph into the temp buffer,
; optimized for the following cases:
;
;       1 to 4 byte-wide destination rectangles for each of:
;               No rotation needed
;               Rotation needed, same # of source as dest bytes needed
;               Rotation needed, one less source than dest bytes needed
;
; Additionally, the three cases are handled for 5 and wider cases by a
; general routine for each case.
;
; If rotation is needed, there are three sorts of routines:
;
; 1) The leftmost byte is MOVed, to initialize the byte. Succeeding bytes are
;    MOVed. This is generally used for the leftmost glyph of a string.
; 2) The leftmost byte is ORed into the existing byte. Succeeding bytes are
;    MOVed. This is generally used after the leftmost glyph, because this may
;    not be the first data written to that byte.
; 3) All bytes are ORed. This is for drawing when characters might overlap.
;
; If rotation is not needed, there are two sorts of routines:
;
; 1) The leftmost byte is MOVed, to initialize the byte. Succeeding bytes are
;    MOVed. This is generally used for the leftmost glyph of a string.
; 2) All bytes are ORed. This is for drawing when characters might overlap.
;
; On entry:
;       EBX = # of scans to copy
;       CL  = right rotation
;       EDX = ulBufDelta = width per scan of destination buffer, in bytes
;       ESI = pointer to first glyph byte
;       EDI = pointer to first dest buffer byte
;       DF  = cleared
;       ulGlyDelta = width per scan of source glyph, in bytes (wide case only)
;       ulWidthInBytes = width of glyph, in bytes (required only for 5 and
;               wider cases)
;
; On exit:
;       Any or all of EAX, EBX, ECX, EDX, ESI, and EDI may be trashed.

;-----------------------------------------------------------------------;
; OR first byte, 1 byte wide dest, rotated.
;-----------------------------------------------------------------------;
or_all_1_wide_rotated_need_last::
or_all_1_wide_rotated_no_last::
or_first_1_wide_rotated_need_last::
or_first_1_wide_rotated_no_last::
or_first_1_wide_rotated_loop::
        mov     ch,[esi]
        inc     esi
        shr     ch,cl
        or      [edi],ch
        add     edi,edx
        dec     ebx
        jnz     or_first_1_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 1 byte wide dest, rotated.
;-----------------------------------------------------------------------;
mov_first_1_wide_rotated_need_last::
mov_first_1_wide_rotated_no_last::
mov_first_1_wide_rotated_loop::
        mov     ch,[esi]
        inc     esi
        shr     ch,cl
        mov     [edi],ch
        add     edi,edx
        dec     ebx
        jnz     mov_first_1_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 1 byte wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_1_wide_unrotated::
mov_first_1_wide_unrotated_loop::
        mov     al,[esi]
        inc     esi
        mov     [edi],al
        add     edi,edx
        dec     ebx
        jnz     mov_first_1_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 1 byte wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_1_wide_unrotated::
or_all_1_wide_unrotated_loop::
        mov     al,[esi]
        inc     esi
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     or_all_1_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_2_wide_rotated_need_last::
or_first_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        or      [edi],al
        mov     [edi+1],ah
        add     edi,edx
        dec     ebx
        jnz     or_first_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_2_wide_rotated_need_last::
or_all_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_2_wide_rotated_need_last::
mov_first_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_2_wide_rotated_no_last::
or_first_2_wide_rotated_loop::
        sub     eax,eax
        mov     ah,[esi]
        inc     esi
        shr     eax,cl
        or      [edi],ah
        mov     [edi+1],al
        add     edi,edx
        dec     ebx
        jnz     or_first_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_2_wide_rotated_no_last::
or_all_2_wide_rotated_loop::
        sub     eax,eax
        mov     al,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_2_wide_rotated_no_last::
mov_first_2_wide_rotated_loop::
        sub     eax,eax
        mov     al,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_2_wide_unrotated::
mov_first_2_wide_unrotated_loop::
        mov     ax,[esi]
        add     esi,2
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_2_wide_unrotated::
or_all_2_wide_unrotated_loop::
        mov     ax,[esi]
        add     esi,2
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        or      [edi],al
        mov     ax,[esi]
        ror     ax,cl
        mov     [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        mov     [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        or      [edi],al
        mov     ax,[esi]
        ror     ax,cl
        or      [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        or      [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        mov     [edi],al
        mov     ax,[esi]
        ror     ax,cl
        mov     [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        mov     [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        mov     [edi+1],ah
        mov     [edi+2],al
        shr     eax,16
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        xchg    ah,al
        or      [edi+1],ax
        shr     eax,16
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        mov     [edi+1],ah
        mov     [edi+2],al
        shr     eax,16
        mov     [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_3_wide_unrotated::
@@:
        mov     ax,[esi]
        mov     [edi],ax
        mov     al,[esi+2]
        add     esi,3
        mov     [edi+2],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 3 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_3_wide_unrotated::
@@:
        mov     ax,[esi]
        or      [edi],ax
        mov     al,[esi+2]
        add     esi,3
        or      [edi+2],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        mov     [edi+2],ax
        shr     eax,16
        mov     [edi+1],al
        or      [edi],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    al,ah
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        mov     [edi+2],ax
        shr     eax,16
        mov     [edi+1],al
        or      [edi],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_4_wide_unrotated::
@@:
        mov     eax,[esi]
        add     esi,4
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_4_wide_unrotated::
@@:
        mov     eax,[esi]
        add     esi,4
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
ofNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     ofNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
oaNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     oaNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        mov     eax,ulWidthInBytes
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
mfNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial byte separately
        shr     al,cl
        mov     [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     mfNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
ofNwr_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        mov     [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     ofNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
oaNwr_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        or      [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     oaNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
mfNwr_scan_loop:
        mov     al,[esi]        ;do the initial byte separately
        shr     al,cl
        mov     [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        mov     [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     mfNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, N bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_N_wide_unrotated::
        mov     edx,ulBufDelta
        mov     eax,ulWidthInBytes
        sub     edx,eax
        shr     eax,1           ;width in words
        jc      short odd_width ;there's at least one odd byte
        shr     eax,1           ;width in dwords
        jc      short two_odd_bytes ;there's an odd word
                                ;copy width is a dword multiple
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

odd_width::
        shr     eax,1           ;width in dwords
        jc      short three_odd_bytes ;there's an odd word and an odd byte
                                ;there's just an odd byte
        inc     edx             ;because we won't advance after last byte
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cl,[esi]
        inc     esi
        mov     [edi],cl
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

two_odd_bytes::
        add     edx,2           ;because we won't advance after last word
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cx,[esi]
        add     esi,2
        mov     [edi],cx
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

three_odd_bytes::
        add     edx,3           ;because we won't advance after last word/byte
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cx,[esi]
        mov     [edi],cx
        mov     cl,[esi+2]
        add     esi,3
        mov     [edi+2],cl
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, N bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_N_wide_unrotated::
        mov     edx,ulBufDelta
        mov     eax,ulWidthInBytes
        sub     edx,eax
        shr     eax,1           ;width in words
        jc      short or_odd_width ;there's at least one odd byte
        shr     eax,1           ;width in dwords
        jc      short or_two_odd_bytes ;there's an odd word
                                ;copy width is a dword multiple
or_no_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_no_odd_bytes_loop
        jmp     pGlyphLoop

or_odd_width::
        shr     eax,1           ;width in dwords
        jc      short or_three_odd_bytes ;there's an odd word and an odd byte
                                ;there's just an odd byte
        inc     edx             ;skip over last byte too
or_one_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cl,[esi]
        or      [edi],cl
        inc     esi
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_one_odd_bytes_loop
        jmp     pGlyphLoop

or_two_odd_bytes::
        add     edx,2           ;skip over last 2 bytes too
or_two_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cx,[esi]
        or      [edi],cx
        add     esi,2
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_two_odd_bytes_loop
        jmp     pGlyphLoop

or_three_odd_bytes::
        add     edx,3           ;skip over last 3 bytes too
or_three_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cx,[esi]
        or      [edi],cx
        mov     cl,[esi+2]
        or      [edi+2],cl
        add     esi,3
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_three_odd_bytes_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; At this point, the text is drawn to the temp buffer.
; Now, draw the extra rectangles to the temp buffer.
;
; Input:
;       pdsurf = pointer to target surface (screen)
;       prclText = pointer to text bounding rectangle
;       prclOpaque = pointer to opaquing rectangle, if there is one
;       iFgColor = text color
;       iBgColor = opaquing rectangle color, if there is one
;       ulTempLeft = X coordinate on dest of left edge of temp buffer pointed
;               to by pTempBuffer
;       pTempBuffer = pointer to first byte (upper left corner) of
;               temp buffer into which we're drawing. This should be
;               dword-aligned with the destination
;       ulBufDelta = destination scan-to-scan offset
;       Text drawn to temp buffer
;
;-----------------------------------------------------------------------;
glyphs_are_done::
        mov     esi,prclExtra
        and     esi,esi                         ;is prclExtra NULL?
        jz      extra_rects_are_done            ;yes

rect_loop::
        mov     eax,[esi].yBottom
        and     eax,eax                         ;is it a NULL rectangle?
        jz      extra_rects_are_done            ;yes
        sub     eax,[esi].yTop                  ;eax = num scans in rect
        mov     sDfbInfo.BurstCountLeft,eax     ;save for fill routine

        mov     edi,pTempBuffer                 ;edi = pTempBuffer
        mov     ecx,prclText                    ;ecx = ptr to text bounding rect
        mov     eax,[esi].yTop
        sub     eax,[ecx].yTop
        imul    eax,ulBufDelta
        add     edi,eax                         ;edi = beginning of first scan
                                                ;      in buffer that we must
                                                ;      draw a rect on

        mov     eax,[esi].xRight                ;eax = right edge of rect
        sub     eax,ulTempLeft                  ;eax = right edge of rect in buf
        mov     ulRectRight,eax

        mov     eax,[esi].xLeft                 ;eax = left edge of rect
        sub     eax,ulTempLeft                  ;eax = left edge of rect in buf
        mov     ulRectLeft,eax

        add     eax,31                          ;round up to nearest dword
        and     eax,not 31                      ; address
        shr     eax,3                           ;bit address => byte address
        add     edi,eax                         ;where rect starts in memory

;-----------------------------------------------------------------------;
; Set up various variables for the copy.
;-----------------------------------------------------------------------;

        sub     ecx,ecx                 ;accumulate copy control flags
        mov     eax,ulRectLeft          ;first, check for partial-dword edges
        and     eax,11111b              ;left edge pixel alignment
        jz      short @F                ;whole dword, don't need leading mask
        or      ecx,LEADING_PARTIAL     ;do need leading mask
@@:
        mov     edx,dfbfill_jLeftMasks[eax*4] ;mask to apply to source to clip
        mov     sDfbInfo.LeftMask,edx         ;remember mask
        not     edx
        mov     sDfbInfo.NotLeftMask,edx      ;remember mask

        mov     eax,ulRectRight
        and     eax,11111b              ;right edge pixel alignment
        jz      short @F                ;whole dword, don't need trailing mask
        or      ecx,TRAILING_PARTIAL    ;do need trailing mask
@@:
        mov     edx,dfbfill_jRightMasks[eax*4] ;mask to apply to source to clip
        mov     sDfbInfo.RightMask,edx         ;remember mask
        not     edx
        mov     sDfbInfo.NotRightMask,edx      ;remember mask

fasttext_detect_partials::
        mov     sDfbInfo.DstWidth,0     ;overwritten if any whole dwords
                                        ;now, see if there are only partial
                                        ; dwords, or maybe even only one partial
        mov     eax,ulRectLeft
        add     eax,11111b
        and     eax,not 11111b          ;round left up to nearest dword
        mov     edx,ulRectRight

        cmp     eax,edx                        ;if left (rounded up) >= right
        jge     short fasttext_one_partial_only ; only one dword

        and     edx,not 11111b          ;round right down to nearest dword
        sub     edx,eax                 ;# of pixels, rounded to nearest dword
                                        ; boundaries (not counting partials)
        ja      short fasttext_check_whole_dwords ;there's at least one whole dword

                                        ;there are no whole dwords
                                        ; there are two partial
                                        ; dwords, which is exactly what
                                        ; we're already set up to do

        jmp     short fasttext_set_copy_control_flags

fasttext_one_partial_only::              ;only one, partial dword, so construct a
                                        ; single mask and set up to do just
                                        ; one, partial dword
        mov     eax,sDfbInfo.LeftMask
        and     eax,sDfbInfo.RightMask         ;intersect the masks
        mov     sDfbInfo.LeftMask,eax
        not     eax
        mov     sDfbInfo.NotLeftMask,eax
        mov     ecx,LEADING_PARTIAL     ;only one partial dword, which we'll
                                        ; treat as leading
        jmp     short fasttext_set_copy_control_flags ;the copy control flags are set

fasttext_check_whole_dwords::
                                        ;finally, calculate the number of whole
                                        ; dwords  we'll process
        shr     edx,5                   ;num_pixels/32
        mov     sDfbInfo.DstWidth,edx   ;save count of whole dwords

fasttext_set_copy_control_flags::

        mov     edx,dfbfill_pfnScanHandlers[ecx*4] ;proper drawing handler
        mov     pfnDrawScans,edx

        mov     edx,sDfbInfo.DstWidth   ;# of dwords across dest rectangle
        shl     edx,2                   ;# of bytes across dest rectangle
        mov     eax,ulBufDelta          ;# of bytes across 1 scan of dest
        sub     eax,edx                 ;offset from end of scan 1 to start of scan 2
        mov     sDfbInfo.DstDelta,eax

        push    esi
        lea     esi,sDfbInfo            ;points to parameters
        mov     eax,-1                  ;fill all bits in rect
        call    pfnDrawScans
        pop     esi
        add     esi,size RECTL
        jmp     rect_loop

;-----------------------------------------------------------------------;
; At this point, the text is drawn to the temp buffer, and any extra
; rectangles (underline, strikeout) are drawn to the temp buffer.
; Now, draw the temp buffer to the screen.
;
; Input:
;       pdsurf = pointer to target surface (screen)
;       prclText = pointer to text bounding rectangle
;       prclOpaque = pointer to opaquing rectangle, if there is one
;       iFgColor = text color
;       iBgColor = opaquing rectangle color, if there is one
;       ulTempLeft = X coordinate on dest of left edge of temp buffer pointed
;               to by pTempBuffer
;       pTempBuffer = pointer to first byte (upper left corner) of
;               temp buffer into which we're drawing. This should be
;               dword-aligned with the destination
;       ulBufDelta = destination scan-to-scan offset
;       Text drawn to temp buffer
;
;-----------------------------------------------------------------------;
extra_rects_are_done::

;-----------------------------------------------------------------------;
; Clip to the clip rectangle, if necessary.
;-----------------------------------------------------------------------;

        mov     esi,prclText
        mov     edi,prclClip
        and     edi,edi                 ;is there clipping?
        jz      clip_set                ;no

        mov     ebx,pTempBuffer
        mov     pTempBufferSaved,ebx
        jmp     short do_opaque_clip

;-----------------------------------------------------------------------;
; Handle rectangle clipping.
;-----------------------------------------------------------------------;

get_next_clip_rect::
        mov     esi,prclText
        mov     edi,prclClip            ;make sure edi has prclClip
        and     edi,edi                 ;was this null?
        jz      exit_fast_text          ;yep
        add     edi,size RECTL          ;no, next rect
        mov     prclClip,edi            ;don't forget the increment

        mov     ebx,pTempBufferSaved
        mov     pTempBuffer,ebx

do_opaque_clip::
        mov     ebx,[edi].yBottom
        and     ebx,ebx                 ;is it a null rectangle?
        jz      exit_fast_text          ;yes

        mov     ebx,[esi].yBottom
        cmp     [edi].yBottom,ebx ;is the bottom edge of the text box clipped?
        jg      short @F          ;no
        mov     ebx,[edi].yBottom ;yes
@@:
        mov     dword ptr rclClippedBounds.yBottom,ebx ;set the (possibly
                                                       ; clipped) bottom edge
        mov     eax,[esi].yTop
        cmp     [edi].yTop,eax  ;is the top edge of the text box clipped?
        jle     short @F        ;no
                                ;yes
        sub     eax,[edi].yTop
        neg     eax             ;# of scans we just clipped off
        mul     ulBufDelta      ;# of bytes by which to advance through source
        add     pTempBuffer,eax ;advance in source to account for Y clipping
        mov     eax,[edi].yTop  ;new top edge
@@:
        mov     dword ptr rclClippedBounds.yTop,eax ;set the (possibly clipped)
                                                    ; top edge
        cmp     eax,ebx         ;is there a gap between clipped top & bottom?
        jnl     get_next_clip_rect ;no, fully clipped

        mov     edx,[esi].xRight
        cmp     [edi].xRight,edx ;is the right edge of the text box clipped?
        jg      short @F         ;no
        mov     edx,[edi].xRight ;yes
@@:
        mov     dword ptr rclClippedBounds.xRight,edx ;set the (possibly
                                                      ; clipped) right edge
        mov     eax,[esi].xLeft
        cmp     [edi].xLeft,eax ;is the left edge of the text box clipped?
        jle     short @F        ;no
                                ;yes
        mov     ebx,[edi].xLeft ;EBX = new left edge
        and     eax,not 0111b   ;floor the old left edge in its byte
        sub     ebx,eax
        shr     ebx,3           ;# of bytes to advance in source
        add     pTempBuffer,ebx ;advance in source to account for X clipping
        mov     eax,[edi].xLeft ;new left edge
@@:
        mov     dword ptr rclClippedBounds.xLeft,eax ;set the (possibly
                                                     ; clipped) left edge
        cmp     eax,edx         ;is there a gap between clipped left & right?
        jnl     get_next_clip_rect ;no, fully clipped

        lea     esi,rclClippedBounds ;this is now the destination rect

;-----------------------------------------------------------------------;
; ESI->destination text rectangle at this point
;-----------------------------------------------------------------------;
clip_set::

        cmp     iTrgType,VGA_TARGET
        je      vga_target_code

        cmp     iTrgType,DFB_TARGET
        je      short dfb_target_code

        ;
        ; if you get to here, don't copy the buffer to any dest because
        ; fasttext is being called multiple times to combine
        ; multiple glyph sets into the buffer
        ;

        cRet    vFastText


dfb_target_code::


;#############################################################################

        mov     eax,[esi].yBottom
        sub     eax,[esi].yTop                  ;eax = num scans in rect
        mov     sDfbInfo.BurstCountLeft,eax     ;save for fill routine

        mov     edi,pdsurf
        mov     eax,[edi].dsurf_lNextPlane
        mov     ulBytesPerDstPlane,eax


        mov     pDst,0
        mov     pSrc,0

;-----------------------------------------------------------------------;
; Set up various variables for the copy.
;-----------------------------------------------------------------------;

        sub     ecx,ecx                 ;accumulate copy control flags
        mov     eax,[esi].xLeft         ;first, check for partial-dword edges
        and     eax,11111b              ;left edge pixel alignment
        jz      short @F                ;whole dword, don't need leading mask
        or      ecx,LEADING_PARTIAL     ;do need leading mask
        add     pDst,4
        add     pSrc,4
@@:
        mov     edx,dfbfill_jLeftMasks[eax*4] ;mask to apply to source to clip
        mov     sDfbInfo.LeftMask,edx         ;remember mask
        not     edx
        mov     sDfbInfo.NotLeftMask,edx      ;remember mask

        mov     eax,[esi].xRight
        and     eax,11111b              ;right edge pixel alignment
        jz      short @F                ;whole dword, don't need trailing mask
        or      ecx,TRAILING_PARTIAL    ;do need trailing mask
@@:
        mov     edx,dfbfill_jRightMasks[eax*4] ;mask to apply to source to clip
        mov     sDfbInfo.RightMask,edx         ;remember mask
        not     edx
        mov     sDfbInfo.NotRightMask,edx      ;remember mask

fasttext_2_detect_partials::
        mov     sDfbInfo.DstWidth,0     ;overwritten if any whole dwords
                                        ;now, see if there are only partial
                                        ; dwords, or maybe even only one partial
        mov     eax,[esi].xLeft
        add     eax,11111b
        and     eax,not 11111b          ;round left up to nearest dword
        mov     edx,[esi].xRight

        cmp     eax,edx                        ;if left (rounded up) >= right
        jge     short fasttext_2_one_partial_only ; only one dword

        and     edx,not 11111b          ;round right down to nearest dword
        sub     edx,eax                 ;# of pixels, rounded to nearest dword
                                        ; boundaries (not counting partials)
        jg      short fasttext_2_check_whole_dwords ;there's at least one whole dword

                                        ;there are no whole dwords
                                        ; there are two partial
                                        ; dwords, which is exactly what
                                        ; we're already set up to do

        jmp     short fasttext_2_set_copy_control_flags

fasttext_2_one_partial_only::              ;only one, partial dword, so construct a
                                        ; single mask and set up to do just
                                        ; one, partial dword
        mov     eax,sDfbInfo.LeftMask
        and     eax,sDfbInfo.RightMask         ;intersect the masks
        mov     sDfbInfo.LeftMask,eax
        not     eax
        mov     sDfbInfo.NotLeftMask,eax
        mov     ecx,LEADING_PARTIAL     ;only one partial dword, which we'll
                                        ; treat as leading
        jmp     short fasttext_2_set_copy_control_flags ;the copy control flags are set

fasttext_2_check_whole_dwords::
                                        ;finally, calculate the number of whole
                                        ; dwords  we'll process
        shr     edx,5                   ;num_pixels/32
        mov     sDfbInfo.DstWidth,edx   ;save count of whole dwords

fasttext_2_set_copy_control_flags::

        mov     ulEdgeFlags,ecx

;-----------------------------------------------------------------------;
; set up dst ptr
;-----------------------------------------------------------------------;

        mov     eax,[esi].yTop                  ;top scan of copy
        imul    eax,[edi].dsurf_lNextScan       ;offset of starting scan line
        mov     edx,[esi].xLeft
        and     edx,not 31
        shr     edx,3
        add     eax,edx
        add     eax,[edi].dsurf_pvBitmapStart   ;initial dest bitmap address
        add     pDst,eax                        ;remember where to start drawing

;-----------------------------------------------------------------------;
; set up src ptr
;-----------------------------------------------------------------------;

        mov     eax,pTempBuffer
        and     eax,not 3
        add     pSrc,eax

        mov     edx,sDfbInfo.DstWidth   ;# of dwords across dest rectangle
        shl     edx,2                   ;# of bytes across dest rectangle
        mov     eax,ulBufDelta          ;# of bytes across 1 scan of dest
        sub     eax,edx                 ;offset from end of 1 to start of 2
        mov     sDfbInfo.SrcDelta,eax
        mov     eax,[edi].dsurf_lNextScan
        sub     eax,edx
        mov     sDfbInfo.DstDelta,eax

;#############################################################################

;-----------------------------------------------------------------------;
; Is this transparent or opaque text?
;-----------------------------------------------------------------------;

        cmp     prclOpaque,0
        jnz     opaque_text_dfb

;-----------------------------------------------------------------------;
; transparent text to dfb needs
; dfb |= text_buf       for all planes whose bit in iFgColor is 1
; dfb &= ~text_buf      for all planes whose bit in iFgColor is 0
;-----------------------------------------------------------------------;

        mov     ulPlaneBit,1

dfb_xpar_planes::
        mov     esi,pSrc
        mov     edi,pDst

        mov     ebx,ulPlaneBit
        test    iFgColor,ebx
        jz      short dfb_xpar_planes_fg0
dfb_xpar_planes_fg1:                            ;or buffer with dest
        mov     ecx,ulEdgeFlags
        mov     edx,pfnCopyTextXpar[ecx*4]      ;proper drawing handler
        lea     eax,sDfbInfo                    ;points to parameters
        call    edx
        jmp     short next_dfb_xpar_plane
dfb_xpar_planes_fg0:                            ;and inv buffer with dest
        mov     ecx,ulEdgeFlags
        mov     edx,pfnCopyInvTextXpar[ecx*4]   ;proper drawing handler
        lea     eax,sDfbInfo                    ;points to parameters
        call    edx

next_dfb_xpar_plane::
        cmp     ulPlaneBit,8
        je      short end_dfb_xpar_planes
        mov     edi,ulBytesPerDstPlane
        add     pDst,edi                ;save increment for next time
        shl     ulPlaneBit,1

        jmp     dfb_xpar_planes

end_dfb_xpar_planes::

        jmp     get_next_clip_rect

;-----------------------------------------------------------------------;
; bitwise "or" n scans with dest, no leading partial, no trailing partial
;
; eax->BurstCountLeft:  # scans to do
; eax->DstWidth:        # whole dwords
; eax->SrcDelta:        distance from end of one src line to start of next
; eax->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    pSrc
;                      *edi:    pDst
;                      *eax:    ptr to structure of parameters
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

copy_text_xpar_00::

        mov     ebx,[eax].BurstCountLeft

@@:     ; burst loop (do each scan)

        ; main loop

        mov     ecx,[eax].DstWidth      ;load DstWidth (will get trashed)
        and     ecx,ecx
        jz      short end_main_tx_00
main_tx_00:
        mov     edx,[esi]
        or      [edi],edx
        add     esi,4
        add     edi,4
        dec     ecx
        jg      main_tx_00
end_main_tx_00:

        ; set up for next scan

        add     edi,[eax].DstDelta      ;inc to next scan
        add     esi,[eax].SrcDelta      ;inc to next scan
        dec     ebx                     ;dec BurstCountLeft
        jg      @B                      ;if any left, loop

        retn                            ;bye

;-----------------------------------------------------------------------;
; bitwise "or" n scans with dest, no leading partial, 1 trailing partial
;
; eax->BurstCountLeft:  # scans to do
; eax->DstWidth:        # whole dwords
; eax->SrcDelta:        distance from end of one src line to start of next
; eax->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    pSrc
;                      *edi:    pDst
;                      *eax:    ptr to structure of parameters
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

copy_text_xpar_01::

        mov     ebx,[eax].BurstCountLeft

@@:     ; burst loop (do each scan)

        ; main loop

        mov     ecx,[eax].DstWidth      ;load DstWidth (will get trashed)
        and     ecx,ecx
        jz      short end_main_tx_01
main_tx_01:
        mov     edx,[esi]
        or      [edi],edx
        add     esi,4
        add     edi,4
        dec     ecx
        jg      main_tx_01
end_main_tx_01:

        ; trailing partial dword

        mov     edx,[esi]               ;get trailing src dword
        and     edx,[eax].RightMask     ;remove bits that won't be filled
        or      [edi],edx               ;or with dest

        ; set up for next scan

        add     edi,[eax].DstDelta      ;inc to next scan
        add     esi,[eax].SrcDelta      ;inc to next scan
        dec     ebx                     ;dec BurstCountLeft
        jg      @B                      ;if any left, loop

        retn                            ;bye

;-----------------------------------------------------------------------;
; bitwise "or" n scans with dest, 1 leading partial, no trailing partial
;
; eax->BurstCountLeft:  # scans to do
; eax->DstWidth:        # whole dwords
; eax->SrcDelta:        distance from end of one src line to start of next
; eax->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    pSrc
;                      *edi:    pDst
;                      *eax:    ptr to structure of parameters
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

copy_text_xpar_10::

        mov     ebx,[eax].BurstCountLeft

@@:     ; burst loop (do each scan)

        ; leading partial dword

        mov     edx,[esi-4]             ;get leading src dword
        and     edx,[eax].LeftMask      ;remove bits that won't be filled
        or      [edi-4],edx             ;or with dest

        ; main loop

        mov     ecx,[eax].DstWidth      ;load DstWidth (will get trashed)
        and     ecx,ecx
        jz      short end_main_tx_10
main_tx_10:
        mov     edx,[esi]
        or      [edi],edx
        add     esi,4
        add     edi,4
        dec     ecx
        jg      main_tx_10
end_main_tx_10:

        ; set up for next scan

        add     edi,[eax].DstDelta      ;inc to next scan
        add     esi,[eax].SrcDelta      ;inc to next scan
        dec     ebx                     ;dec BurstCountLeft
        jg      @B                      ;if any left, loop

        retn                            ;bye

;-----------------------------------------------------------------------;
; bitwise "or" n scans with dest, 1 leading partial, 1 trailing partial
;
; eax->BurstCountLeft:  # scans to do
; eax->DstWidth:        # whole dwords
; eax->SrcDelta:        distance from end of one src line to start of next
; eax->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    pSrc
;                      *edi:    pDst
;                      *eax:    ptr to structure of parameters
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

copy_text_xpar_11::

        mov     ebx,[eax].BurstCountLeft

@@:     ; burst loop (do each scan)

        ; leading partial dword

        mov     edx,[esi-4]             ;get leading src dword
        and     edx,[eax].LeftMask      ;remove bits that won't be filled
        or      [edi-4],edx             ;or with dest

        ; main loop

        mov     ecx,[eax].DstWidth      ;load DstWidth (will get trashed)
        and     ecx,ecx
        jz      short end_main_tx_11
main_tx_11:
        mov     edx,[esi]
        or      [edi],edx
        add     esi,4
        add     edi,4
        dec     ecx
        jg      main_tx_11
end_main_tx_11:

        ; trailing partial dword

        mov     edx,[esi]               ;get trailing src dword
        and     edx,[eax].RightMask     ;remove bits that won't be filled
        or      [edi],edx               ;or with dest

        ; set up for next scan

        add     edi,[eax].DstDelta      ;inc to next scan
        add     esi,[eax].SrcDelta      ;inc to next scan
        dec     ebx                     ;dec BurstCountLeft
        jg      @B                      ;if any left, loop

        retn                            ;bye

;-----------------------------------------------------------------------;
; invert and bitwise "and" n scans with dest
; no leading partial, no trailing partial
;
; eax->BurstCountLeft:  # scans to do
; eax->DstWidth:        # whole dwords
; eax->SrcDelta:        distance from end of one src line to start of next
; eax->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    pSrc
;                      *edi:    pDst
;                      *eax:    ptr to structure of parameters
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

copy_inv_text_xpar_00::

        mov     ebx,[eax].BurstCountLeft

@@:     ; burst loop (do each scan)

        ; main loop

        mov     ecx,[eax].DstWidth      ;load DstWidth (will get trashed)
        and     ecx,ecx
        jz      short end_main_itx_00
main_itx_00:
        mov     edx,[esi]
        not     edx
        and     [edi],edx
        add     esi,4
        add     edi,4
        dec     ecx
        jg      main_itx_00
end_main_itx_00:

        ; set up for next scan

        add     edi,[eax].DstDelta      ;inc to next scan
        add     esi,[eax].SrcDelta      ;inc to next scan
        dec     ebx                     ;dec BurstCountLeft
        jg      @B                      ;if any left, loop

        retn                            ;bye

;-----------------------------------------------------------------------;
; invert and bitwise "and" n scans with dest
; no leading partial, 1 trailing partial
;
; eax->BurstCountLeft:  # scans to do
; eax->DstWidth:        # whole dwords
; eax->SrcDelta:        distance from end of one src line to start of next
; eax->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    pSrc
;                      *edi:    pDst
;                      *eax:    ptr to structure of parameters
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

copy_inv_text_xpar_01::

        mov     ebx,[eax].BurstCountLeft

@@:     ; burst loop (do each scan)

        ; main loop

        mov     ecx,[eax].DstWidth      ;load DstWidth (will get trashed)
        and     ecx,ecx
        jz      short end_main_itx_01
main_itx_01:
        mov     edx,[esi]
        not     edx
        and     [edi],edx
        add     esi,4
        add     edi,4
        dec     ecx
        jg      main_itx_01
end_main_itx_01:

        ; trailing partial dword

        mov     edx,[esi]               ;get trailing src dword
        not     edx
        or      edx,[eax].NotRightMask  ;force bits to 1 that should stay
        and     [edi],edx               ;and with dest

        ; set up for next scan

        add     edi,[eax].DstDelta      ;inc to next scan
        add     esi,[eax].SrcDelta      ;inc to next scan
        dec     ebx                     ;dec BurstCountLeft
        jg      @B                      ;if any left, loop

        retn                            ;bye

;-----------------------------------------------------------------------;
; invert and bitwise "and" n scans with dest
; 1 leading partial, no trailing partial
;
; eax->BurstCountLeft:  # scans to do
; eax->DstWidth:        # whole dwords
; eax->SrcDelta:        distance from end of one src line to start of next
; eax->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    pSrc
;                      *edi:    pDst
;                      *eax:    ptr to structure of parameters
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

copy_inv_text_xpar_10::

        mov     ebx,[eax].BurstCountLeft

@@:     ; burst loop (do each scan)

        ; leading partial dword

        mov     edx,[esi-4]             ;get leading src dword
        not     edx
        or      edx,[eax].NotLeftMask   ;force bits to 1 that should stay
        and     [edi-4],edx             ;and with dest

        ; main loop

        mov     ecx,[eax].DstWidth      ;load DstWidth (will get trashed)
        and     ecx,ecx
        jz      short end_main_itx_10
main_itx_10:
        mov     edx,[esi]
        not     edx
        and     [edi],edx
        add     esi,4
        add     edi,4
        dec     ecx
        jg      main_itx_10
end_main_itx_10:

        ; set up for next scan

        add     edi,[eax].DstDelta      ;inc to next scan
        add     esi,[eax].SrcDelta      ;inc to next scan
        dec     ebx                     ;dec BurstCountLeft
        jg      @B                      ;if any left, loop

        retn                            ;bye

;-----------------------------------------------------------------------;
; invert and bitwise "and" n scans with dest
; 1 leading partial, 1 trailing partial
;
; eax->BurstCountLeft:  # scans to do
; eax->DstWidth:        # whole dwords
; eax->SrcDelta:        distance from end of one src line to start of next
; eax->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    pSrc
;                      *edi:    pDst
;                      *eax:    ptr to structure of parameters
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

copy_inv_text_xpar_11::

        mov     ebx,[eax].BurstCountLeft

@@:     ; burst loop (do each scan)

        ; leading partial dword

        mov     edx,[esi-4]             ;get leading src dword
        not     edx
        or      edx,[eax].NotLeftMask   ;force bits to 1 that should stay
        and     [edi-4],edx             ;and with dest

        ; main loop

        mov     ecx,[eax].DstWidth      ;load DstWidth (will get trashed)
        and     ecx,ecx
        jz      short end_main_itx_11
main_itx_11:
        mov     edx,[esi]
        not     edx
        and     [edi],edx
        add     esi,4
        add     edi,4
        dec     ecx
        jg      main_itx_11
end_main_itx_11:

        ; trailing partial dword

        mov     edx,[esi]               ;get trailing src dword
        not     edx
        or      edx,[eax].NotRightMask  ;force bits to 1 that should stay
        and     [edi],edx               ;and with dest

        ; set up for next scan

        add     edi,[eax].DstDelta      ;inc to next scan
        add     esi,[eax].SrcDelta      ;inc to next scan
        dec     ebx                     ;dec BurstCountLeft
        jg      @B                      ;if any left, loop

        retn                            ;bye

opaque_text_dfb::

;-----------------------------------------------------------------------;
; opaque text to dfb needs
; dfb = 1               for all planes whose bit in iFgColor and iBgColor is 1
; dfb = 0               for all planes whose bit in iFgColor and iBgColor is 0
; dfb = text_buf        for all planes whose bit in iFgColor is 1 and iBgColor is 0
; dfb = ~text_buf       for all planes whose bit in iFgColor is 0 and iBgColor is 1
;-----------------------------------------------------------------------;

        mov     ulPlaneBit,1

dfb_opaq_planes::
        mov     esi,pSrc
        mov     edi,pDst

        mov     ebx,ulPlaneBit
        test    iFgColor,ebx
        jz      short dfb_opaq_planes_fg0
dfb_opaq_planes_fg1:
        mov     ebx,ulPlaneBit
        test    iBgColor,ebx
        jz      short dfb_opaq_planes_fg1bg0
dfb_opaq_planes_fg1bg1:                         ;fill rectangle with 1s
        mov     ecx,ulEdgeFlags
        mov     edx,dfbfill_pfnScanHandlers[ecx*4] ;proper drawing handler
        lea     esi,sDfbInfo                    ;points to parameters
        mov     eax,-1                          ;fill all bits in rect
        call    edx
        jmp     short next_dfb_opaq_plane
dfb_opaq_planes_fg1bg0:                         ;copy rectangle
        mov     ecx,ulEdgeFlags
        mov     edx,pfnCopyTextOpaq[ecx*4]      ;proper drawing handler
        lea     eax,sDfbInfo                    ;points to parameters
        call    edx
        jmp     short next_dfb_opaq_plane
dfb_opaq_planes_fg0:
        mov     ebx,ulPlaneBit
        test    iBgColor,ebx
        jz      short dfb_opaq_planes_fg0bg0
dfb_opaq_planes_fg0bg1:
        mov     ecx,ulEdgeFlags
        mov     edx,pfnCopyInvTextOpaq[ecx*4]   ;proper drawing handler
        lea     eax,sDfbInfo                    ;points to parameters
        call    edx
        jmp     short next_dfb_opaq_plane
dfb_opaq_planes_fg0bg0:                         ;fill rectangle with 0s
        mov     ecx,ulEdgeFlags
        mov     edx,dfbfill_pfnScanHandlers[ecx*4] ;proper drawing handler
        lea     esi,sDfbInfo                    ;points to parameters
        mov     eax,0                           ;zero all bits in rect
        call    edx
next_dfb_opaq_plane::
        cmp     ulPlaneBit,8
        je      short end_dfb_opaq_planes
        mov     edi,ulBytesPerDstPlane
        add     pDst,edi                        ;save increment for next time
        shl     ulPlaneBit,1

        jmp     dfb_opaq_planes

end_dfb_opaq_planes::
        jmp     get_next_clip_rect

;-----------------------------------------------------------------------;
; copy n scans, no leading partial, no trailing partial
;
; eax->BurstCountLeft:  # scans to do
; eax->DstWidth:        # whole dwords
; eax->SrcDelta:        distance from end of one src line to start of next
; eax->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    pSrc
;                      *edi:    pDst
;                      *eax:    ptr to structure of parameters
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

copy_text_opaq_00::

        mov     ebx,[eax].BurstCountLeft

@@:     ; burst loop (do each scan)

        ; main loop

        mov     ecx,[eax].DstWidth      ;load DstWidth (will get trashed)
        rep     movsd                   ;copy DWORDs (destroy CX)

        ; set up for next scan

        add     edi,[eax].DstDelta      ;inc to next scan
        add     esi,[eax].SrcDelta      ;inc to next scan
        dec     ebx                     ;dec BurstCountLeft
        jg      @B                      ;if any left, loop

        retn                            ;bye

;-----------------------------------------------------------------------;
; copy n scans, no leading partial, 1 trailing partial
;
; eax->BurstCountLeft:  # scans to do
; eax->DstWidth:        # whole dwords
; eax->SrcDelta:        distance from end of one src line to start of next
; eax->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    pSrc
;                      *edi:    pDst
;                      *eax:    ptr to structure of parameters
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

copy_text_opaq_01::

        mov     ebx,[eax].BurstCountLeft

@@:     ; burst loop (do each scan)

        ; main loop

        mov     ecx,[eax].DstWidth      ;load DstWidth (will get trashed)
        rep     movsd                   ;copy DWORDs (destroy CX)

        ; trailing partial dword

        mov     ecx,[esi]               ;get trailing src dword
        mov     edx,[edi]               ;get trailing dst dword
        and     ecx,[eax].RightMask     ;remove bits that won't be filled
        and     edx,[eax].NotRightMask  ;remove bits that will be filled
        or      edx,ecx                 ;combine dwords
        mov     [edi],edx               ;write trailing dword

        ; set up for next scan

        add     edi,[eax].DstDelta      ;inc to next scan
        add     esi,[eax].SrcDelta      ;inc to next scan
        dec     ebx                     ;dec BurstCountLeft
        jg      @B                      ;if any left, loop

        retn                            ;bye

;-----------------------------------------------------------------------;
; copy n scans, 1 leading partial, no trailing partial
;
; eax->BurstCountLeft:  # scans to do
; eax->DstWidth:        # whole dwords
; eax->SrcDelta:        distance from end of one src line to start of next
; eax->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    pSrc
;                      *edi:    pDst
;                      *eax:    ptr to structure of parameters
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

copy_text_opaq_10::

        mov     ebx,[eax].BurstCountLeft

@@:     ; burst loop (do each scan)

        ; leading partial dword

        mov     ecx,[esi-4]             ;get leading src dword
        mov     edx,[edi-4]             ;get leading dst dword
        and     ecx,[eax].LeftMask      ;remove bits that won't be filled
        and     edx,[eax].NotLeftMask   ;remove bits that will be filled
        or      edx,ecx                 ;combine dwords
        mov     [edi-4],edx             ;write leading dword

        ; main loop

        mov     ecx,[eax].DstWidth      ;load DstWidth (will get trashed)
        rep     movsd                   ;copy DWORDs (destroy CX)

        ; set up for next scan

        add     edi,[eax].DstDelta      ;inc to next scan
        add     esi,[eax].SrcDelta      ;inc to next scan
        dec     ebx                     ;dec BurstCountLeft
        jg      @B                      ;if any left, loop

        retn                            ;bye

;-----------------------------------------------------------------------;
; copy n scans, 1 leading partial, 1 trailing partial
;
; eax->BurstCountLeft:  # scans to do
; eax->DstWidth:        # whole dwords
; eax->SrcDelta:        distance from end of one src line to start of next
; eax->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    pSrc
;                      *edi:    pDst
;                      *eax:    ptr to structure of parameters
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

copy_text_opaq_11::

        mov     ebx,[eax].BurstCountLeft

@@:     ; burst loop (do each scan)

        ; leading partial dword

        mov     ecx,[esi-4]             ;get leading src dword
        mov     edx,[edi-4]             ;get leading dst dword
        and     ecx,[eax].LeftMask      ;remove bits that won't be filled
        and     edx,[eax].NotLeftMask   ;remove bits that will be filled
        or      edx,ecx                 ;combine dwords
        mov     [edi-4],edx             ;write leading dword

        ; main loop

        mov     ecx,[eax].DstWidth      ;load DstWidth (will get trashed)
        rep     movsd                   ;copy DWORDs (destroy CX)

        ; trailing partial dword

        mov     ecx,[esi]               ;get trailing src dword
        mov     edx,[edi]               ;get trailing dst dword
        and     ecx,[eax].RightMask     ;remove bits that won't be filled
        and     edx,[eax].NotRightMask  ;remove bits that will be filled
        or      edx,ecx                 ;combine dwords
        mov     [edi],edx               ;write trailing dword

        ; set up for next scan

        add     edi,[eax].DstDelta      ;inc to next scan
        add     esi,[eax].SrcDelta      ;inc to next scan
        dec     ebx                     ;dec BurstCountLeft
        jg      @B                      ;if any left, loop

        retn                            ;bye

;-----------------------------------------------------------------------;
; invert and copy n scans, no leading partial, no trailing partial
;
; eax->BurstCountLeft:  # scans to do
; eax->DstWidth:        # whole dwords
; eax->SrcDelta:        distance from end of one src line to start of next
; eax->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    pSrc
;                      *edi:    pDst
;                      *eax:    ptr to structure of parameters
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

copy_inv_text_opaq_00::

        mov     ebx,[eax].BurstCountLeft

@@:     ; burst loop (do each scan)

        ; main loop

        mov     ecx,[eax].DstWidth      ;load DstWidth (will get trashed)
        and     ecx,ecx
        jz      short end_main_ito_00
main_ito_00:
        mov     edx,[esi]
        not     edx
        mov     [edi],edx
        add     esi,4
        add     edi,4
        dec     ecx
        jg      main_ito_00
end_main_ito_00:

        ; set up for next scan

        add     edi,[eax].DstDelta      ;inc to next scan
        add     esi,[eax].SrcDelta      ;inc to next scan
        dec     ebx                     ;dec BurstCountLeft
        jg      @B                      ;if any left, loop

        retn                            ;bye

;-----------------------------------------------------------------------;
; invert and copy n scans, no leading partial, 1 trailing partial
;
; eax->BurstCountLeft:  # scans to do
; eax->DstWidth:        # whole dwords
; eax->SrcDelta:        distance from end of one src line to start of next
; eax->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    pSrc
;                      *edi:    pDst
;                      *eax:    ptr to structure of parameters
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

copy_inv_text_opaq_01::

        mov     ebx,[eax].BurstCountLeft

@@:     ; burst loop (do each scan)

        ; main loop

        mov     ecx,[eax].DstWidth      ;load DstWidth (will get trashed)
        and     ecx,ecx
        jz      short end_main_ito_01
main_ito_01:
        mov     edx,[esi]
        not     edx
        mov     [edi],edx
        add     esi,4
        add     edi,4
        dec     ecx
        jg      main_ito_01
end_main_ito_01:

        ; trailing partial dword

        mov     ecx,[esi]               ;get trailing src dword
        not     ecx
        mov     edx,[edi]               ;get trailing dst dword
        and     ecx,[eax].RightMask     ;remove bits that won't be filled
        and     edx,[eax].NotRightMask  ;remove bits that will be filled
        or      edx,ecx                 ;combine dwords
        mov     [edi],edx               ;write trailing dword

        ; set up for next scan

        add     edi,[eax].DstDelta      ;inc to next scan
        add     esi,[eax].SrcDelta      ;inc to next scan
        dec     ebx                     ;dec BurstCountLeft
        jg      @B                      ;if any left, loop

        retn                            ;bye

;-----------------------------------------------------------------------;
; invert and copy n scans, 1 leading partial, no trailing partial
;
; eax->BurstCountLeft:  # scans to do
; eax->DstWidth:        # whole dwords
; eax->SrcDelta:        distance from end of one src line to start of next
; eax->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    pSrc
;                      *edi:    pDst
;                      *eax:    ptr to structure of parameters
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

copy_inv_text_opaq_10::

        mov     ebx,[eax].BurstCountLeft

@@:     ; burst loop (do each scan)

        ; leading partial dword

        mov     ecx,[esi-4]             ;get leading src dword
        not     ecx
        mov     edx,[edi-4]             ;get leading dst dword
        and     ecx,[eax].LeftMask      ;remove bits that won't be filled
        and     edx,[eax].NotLeftMask   ;remove bits that will be filled
        or      edx,ecx                 ;combine dwords
        mov     [edi-4],edx             ;write leading dword

        ; main loop

        mov     ecx,[eax].DstWidth      ;load DstWidth (will get trashed)
        and     ecx,ecx
        jz      short end_main_ito_10
main_ito_10:
        mov     edx,[esi]
        not     edx
        mov     [edi],edx
        add     esi,4
        add     edi,4
        dec     ecx
        jg      main_ito_10
end_main_ito_10:

        ; set up for next scan

        add     edi,[eax].DstDelta      ;inc to next scan
        add     esi,[eax].SrcDelta      ;inc to next scan
        dec     ebx                     ;dec BurstCountLeft
        jg      @B                      ;if any left, loop

        retn                            ;bye

;-----------------------------------------------------------------------;
; invert and copy n scans, 1 leading partial, 1 trailing partial
;
; eax->BurstCountLeft:  # scans to do
; eax->DstWidth:        # whole dwords
; eax->SrcDelta:        distance from end of one src line to start of next
; eax->DstDelta:        distance from end of one dst line to start of next
;
; registers used       *esi:    pSrc
;                      *edi:    pDst
;                      *eax:    ptr to structure of parameters
;                       ebx:    esi->BurstCountLeft
;                       ecx:    esi->DstWidth (temp "disposable" copy)
;                       edx:    saved bits for leading/trailing
;-----------------------------------------------------------------------;

copy_inv_text_opaq_11::

        mov     ebx,[eax].BurstCountLeft

@@:     ; burst loop (do each scan)

        ; leading partial dword

        mov     ecx,[esi-4]             ;get leading src dword
        not     ecx
        mov     edx,[edi-4]             ;get leading dst dword
        and     ecx,[eax].LeftMask      ;remove bits that won't be filled
        and     edx,[eax].NotLeftMask   ;remove bits that will be filled
        or      edx,ecx                 ;combine dwords
        mov     [edi-4],edx             ;write leading dword

        ; main loop

        mov     ecx,[eax].DstWidth      ;load DstWidth (will get trashed)
        and     ecx,ecx
        jz      short end_main_ito_11
main_ito_11:
        mov     edx,[esi]
        not     edx
        mov     [edi],edx
        add     esi,4
        add     edi,4
        dec     ecx
        jg      main_ito_11
end_main_ito_11:

        ; trailing partial dword

        mov     ecx,[esi]               ;get trailing src dword
        not     ecx
        mov     edx,[edi]               ;get trailing dst dword
        and     ecx,[eax].RightMask     ;remove bits that won't be filled
        and     edx,[eax].NotRightMask  ;remove bits that will be filled
        or      edx,ecx                 ;combine dwords
        mov     [edi],edx               ;write trailing dword

        ; set up for next scan

        add     edi,[eax].DstDelta      ;inc to next scan
        add     esi,[eax].SrcDelta      ;inc to next scan
        dec     ebx                     ;dec BurstCountLeft
        jg      @B                      ;if any left, loop

        retn                            ;bye

vga_target_code::

;-----------------------------------------------------------------------;
; Set up the VGA's hardware for read mode 1 and write mode 3.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,GRAF_MODE + ((M_AND_WRITE + M_COLOR_READ) SHL 8)
        out     dx,ax                   ;write mode 3 so we can do masking
                                        ; without OUTs, read mode 1 so we can
                                        ; read 0xFF from memory always, for
                                        ; ANDing (because Color Don't Care is
                                        ; all zeros)

;-----------------------------------------------------------------------;
; Is this transparent or opaque text?
;-----------------------------------------------------------------------;

        cmp     prclOpaque,0
        jnz     opaque_text

;-----------------------------------------------------------------------;
; Transparent text.
; ESI = prclText
;-----------------------------------------------------------------------;

        mov     al,GRAF_SET_RESET
        mov     ah,byte ptr iFgColor
        out     dx,ax                   ;set the drawing color

;-----------------------------------------------------------------------;
; Calculate drawing parameters.
;-----------------------------------------------------------------------;

        mov     eax,[esi].yBottom
        mov     ulBottomScan,eax ;bottom scan of text area
        mov     eax,[esi].xRight
        mov     ebx,eax
        and     ebx,111b
        mov     edx,[esi].xLeft
        mov     ch,jOpaqueRightMasks[ebx]       ;set right edge clip mask
        mov     ebx,edx
        and     ebx,111b
        mov     ulRightMask,ecx                 ;mask is expected to be in CH
        mov     ch,jOpaqueLeftMasks[ebx]        ;set left edge clip mask
        mov     ulLeftMask,ecx                  ;mask is expected to be in CH

        mov     ulTextLeft,edx
        and     edx,not 7
        add     eax,7
        sub     eax,edx
        shr     eax,3           ;width of text in bytes, rounded up

;-----------------------------------------------------------------------;
; Figure out what edges we need to handle, and calculate some info for
; doing whole bytes.
;-----------------------------------------------------------------------;

        xor     ecx,ecx                    ;clear flags

        cmp     eax,1                      ;only one byte total?
        jnz     short @F                   ;no
                                           ;yes, special case
        mov     ebx,ulLeftMask
        and     ebx,ulRightMask
        cmp     bh,0ffh                    ;solid byte?
        jz      short xpar_set_edge_vector ;yes, all set
        mov     ulLeftMask,ebx             ;no, draw as a left edge
        dec     eax                        ;there are no whole bytes
        mov     ecx,10b                    ;left edge only
        jmp     short xpar_set_edge_vector ;yes, all set

@@:
        test    [esi].xLeft,111b           ;is left edge a solid byte?
        jz      short xpar_left_edge_solid ;yes
        dec     eax                        ;no, count off from whole bytes
        or      ecx,10b                    ;left edge is needed

xpar_left_edge_solid::
        test    [esi].xRight,111b          ;is right edge a solid byte?
        jz      short xpar_set_edge_vector ;yes, all set
        dec     eax                        ;no, count off from whole bytes
        or      ecx,01b                    ;right edge is needed
        jmp     short xpar_set_edge_vector

xpar_set_edge_vector::

        mov     ecx,XparInnerLoop[ecx*4]
        mov     pfnDrawScans,ecx

xpar_edges_set::
        mov     ulLoopCount,eax

        mov     ecx,ulBufDelta
        sub     ecx,eax         ;offset to next scan in temp buffer
        mov     ulTmpSrcDelta,ecx

        mov     ebx,pdsurf
        mov     ecx,ulScreenDelta
        sub     ecx,eax         ;offset to next scan in screen
        mov     ulTmpDstDelta,ecx

        mov     eax,[esi].yTop
        imul    ulScreenDelta   ;EDX trashed
        mov     edi,[esi].xLeft
        shr     edi,3
        add     edi,eax



;-----------------------------------------------------------------------;
; Map in the bank containing the top scan of the text, if it's not
; mapped in already.
;-----------------------------------------------------------------------;

        mov     eax,[esi].yTop  ;top scan line of text
        mov     ulTopScan,eax
        cmp     eax,[ebx].dsurf_rcl1WindowClip.yTop ;is text top less than
                                                    ; current bank?
        jl      short xpar_map_init_bank            ;yes, map in proper bank
        cmp     eax,[ebx].dsurf_rcl1WindowClip.yBottom ;text top greater than
                                                       ; current bank?
        jl      short xpar_init_bank_mapped     ;no, proper bank already mapped
xpar_map_init_bank::

; Map in the bank containing the top scan line of the fill.
; Preserves EBX, ESI, and EDI.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl>,<ebx,eax,JustifyTop>

xpar_init_bank_mapped::

        mov     esi,pTempBuffer         ;initial source address

        mov     ecx,ulLeftMask
        cmp     ch,0ffh                 ;is left edge solid?
        je      short @F                ;yes
        inc     esi                     ;no, point to leftmost source and dest
        inc     edi                     ; bytes (skip over partial left edge)
@@:
        add     edi,[ebx].dsurf_pvBitmapStart   ;initial destination address

;-----------------------------------------------------------------------;
; Main loop for processing fill in each bank.
;
; At start of loop, EBX->pdsurf
;-----------------------------------------------------------------------;

xpar_bank_loop::
        mov     edx,ulBottomScan        ;bottom of destination rectangle
        cmp     edx,[ebx].dsurf_rcl1WindowClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; text rect or the bottom of the
                                        ; current bank?
        jl      short @F                ;text bottom comes first, so draw to
                                        ; that; this is the last bank in text
        mov     edx,[ebx].dsurf_rcl1WindowClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
@@:
        sub     edx,ulTopScan           ;# of scans to draw in bank
        mov     ebx,ulTmpSrcDelta

xpar_scan_loop::
        mov     ecx,ulLoopCount ;loop count

        call    pfnDrawScans

        add     esi,ebx           ;point to next buffer scan
        add     edi,ulTmpDstDelta ;point to next screen scan

        dec     edx             ;count down scans
        jnz     xpar_scan_loop

;-----------------------------------------------------------------------;
; See if there are more banks to draw.
;-----------------------------------------------------------------------;

        mov     ebx,pdsurf
        mov     eax,[ebx].dsurf_rcl1WindowClip.yBottom ;is the text bottom in
        cmp     ulBottomScan,eax                       ; the current bank?
        jnle    short do_next_xpar_bank ;no, map in the next bank and draw
                                        ;yes, so we're done

        jmp     get_next_clip_rect

do_next_xpar_bank::
        mov     ulTopScan,eax
        sub     edi,[ebx].dsurf_pvBitmapStart ;convert from address to offset
                                              ; within bitmap
        ptrCall <dword ptr [ebx].dsurf_pfnBankControl>,<ebx,eax,JustifyTop>
                                        ;map in the bank (call preserves EBX,
                                        ; ESI, and EDI)
        add     edi,[ebx].dsurf_pvBitmapStart ;convert from offset within
                                              ; bitmap to address (bitmap start
                                              ; just moved)
        jmp     xpar_bank_loop          ;we're ready to draw in the new bank


;-----------------------------------------------------------------------;
; Loops to draw transparent text
;-----------------------------------------------------------------------;


;-----------------------------------------------------------------------;
; Draw transparent text - no leading byte, no trailing byte
;-----------------------------------------------------------------------;

xpar_byte_loop_00::

        ;-----------------
        ; start main loop
        ;-----------------

        and     ecx,ecx
        jz      endloop_00

loop_00:
        mov     al,[esi]        ;get next temp buffer byte
        and     al,al           ;is it zero?
        jz      short @F        ;yes, skip it
        and     [edi],al        ;draw the byte with transparency
@@:
        inc     esi
        inc     edi
        dec     ecx
        jnz     loop_00

endloop_00:
        ;-----------------
        ; end main loop
        ;-----------------

        retn

;-----------------------------------------------------------------------;
; Draw transparent text - no leading byte, 1 trailing byte
;-----------------------------------------------------------------------;

xpar_byte_loop_01::

        ;-----------------
        ; start main loop
        ;-----------------

        and     ecx,ecx
        jz      endloop_01

loop_01:
        mov     al,[esi]        ;get next temp buffer byte
        and     al,al           ;is it zero?
        jz      short @F        ;yes, skip it
        and     [edi],al        ;draw the byte with transparency
@@:
        inc     esi
        inc     edi
        dec     ecx
        jnz     loop_01

endloop_01:
        ;-----------------
        ; end main loop
        ;-----------------

        mov     eax,ulRightMask
        mov     al,[esi]        ;get next temp buffer byte
        and     al,ah           ;is it zero?
        jz      short @F        ;yes, skip it
        and     [edi],al        ;draw the byte with transparency
@@:

        retn

;-----------------------------------------------------------------------;
; Draw transparent text - 1 leading byte, no trailing byte
;-----------------------------------------------------------------------;

xpar_byte_loop_10::
        mov     eax,ulLeftMask
        mov     al,[esi-1]      ;get next temp buffer byte
        and     al,ah           ;is it zero?
        jz      short @F        ;yes, skip it
        and     [edi-1],al      ;draw the byte with transparency
@@:

        ;-----------------
        ; start main loop
        ;-----------------

        and     ecx,ecx
        jz      endloop_10

loop_10:
        mov     al,[esi]        ;get next temp buffer byte
        and     al,al           ;is it zero?
        jz      short @F        ;yes, skip it
        and     [edi],al        ;draw the byte with transparency
@@:
        inc     esi
        inc     edi
        dec     ecx
        jnz     loop_10

endloop_10:
        ;-----------------
        ; end main loop
        ;-----------------

        retn

;-----------------------------------------------------------------------;
; Draw transparent text - 1 leading byte, 1 trailing byte
;-----------------------------------------------------------------------;

xpar_byte_loop_11::
        mov     eax,ulLeftMask
        mov     al,[esi-1]      ;get next temp buffer byte
        and     al,ah           ;is it zero?
        jz      short @F        ;yes, skip it
        and     [edi-1],al      ;draw the byte with transparency
@@:

        ;-----------------
        ; start main loop
        ;-----------------

        and     ecx,ecx
        jz      endloop_11

loop_11:
        mov     al,[esi]        ;get next temp buffer byte
        and     al,al           ;is it zero?
        jz      short @F        ;yes, skip it
        and     [edi],al        ;draw the byte with transparency
@@:
        inc     esi
        inc     edi
        dec     ecx
        jnz     loop_11

endloop_11:
        ;-----------------
        ; end main loop
        ;-----------------

        mov     eax,ulRightMask
        mov     al,[esi]        ;get next temp buffer byte
        and     al,ah           ;is it zero?
        jz      short @F        ;yes, skip it
        and     [edi],al        ;draw the byte with transparency
@@:

        retn

;-----------------------------------------------------------------------;
; Opaque text.
; ESI = prclText
;-----------------------------------------------------------------------;

opaque_text::

;-----------------------------------------------------------------------;
; Calculate the drawing parameters.
;-----------------------------------------------------------------------;

        mov     eax,[esi].yBottom
        mov     ulBottomScan,eax ;bottom scan of text area
        mov     eax,[esi].xRight
        mov     ebx,eax
        and     ebx,111b
        mov     edx,[esi].xLeft
        mov     ch,jOpaqueRightMasks[ebx]       ;set right edge clip mask
        mov     ebx,edx
        and     ebx,111b
        mov     ulRightMask,ecx                 ;mask is expected to be in CH
        mov     ch,jOpaqueLeftMasks[ebx]        ;set left edge clip mask
        mov     ulLeftMask,ecx                  ;mask is expected to be in CH

        mov     ulTextLeft,edx
        and     edx,not 7
        add     eax,7
        sub     eax,edx
        shr     eax,3           ;width of text in bytes, rounded up
        mov     ulTextWidthInBytes,eax

;-----------------------------------------------------------------------;
; Figure out what edges we need to handle, and calculate some info for
; doing whole bytes.
;-----------------------------------------------------------------------;

        cmp     eax,1                   ;only one byte total?
        jnz     short @F                ;no
                                        ;yes, special case
        mov     ecx,offset opaq_check_more_banks  ;assume it's a solid byte
        mov     ebx,ulLeftMask
        and     ebx,ulRightMask
        cmp     bh,0ffh                 ;solid byte?
        jz      short opaq_set_edge_vector ;yes, all set
        mov     ulLeftMask,ebx          ;no, draw as a left edge
        dec     eax                     ;there are no whole bytes
        mov     ecx,offset opaq_draw_left_edge_only
        jmp     short opaq_set_edge_vector ;yes, all set

@@:
        test    [esi].xLeft,111b           ;is left edge a solid byte?
        jz      short opaq_left_edge_solid ;yes
        dec     eax                        ;no, count off from whole bytes
        mov     ecx,offset opaq_draw_left_edge_only ;assume right edge is solid
        test    [esi].xRight,111b          ;is right edge a solid byte?
        jz      short opaq_set_edge_vector ;yes, all set
        dec     eax                        ;no, count off from whole bytes
        mov     ecx,offset opaq_draw_both_edges ;both edges are non-solid
        jmp     short opaq_set_edge_vector

opaq_left_edge_solid::
        mov     ecx,offset opaq_check_more_banks  ;assume right edge is solid
        test    [esi].xRight,111b          ;is right edge a solid byte?
        jz      short opaq_set_edge_vector ;yes, all set
        dec     eax                        ;no, count off from whole bytes
        mov     ecx,offset opaq_draw_right_edge_only ;no, do non-solid right
                                                     ; edge
opaq_set_edge_vector::
        mov     edi,ulBufDelta
        sub     edi,eax         ;whole bytes offset to next scan in temp buffer
        mov     ulTmpSrcDelta,edi

        mov     edi,ulScreenDelta
        sub     edi,eax         ;whole bytes offset to next scan in screen
        mov     ulTmpDstDelta,edi

        mov     pfnEdgeVector,ecx
        mov     edx,eax
        mov     pfnFirstOpaqVector,offset opaq_whole_bytes
                                        ;assume there are whole bytes, in which
                                        ; case we'll draw them first, then the
                                        ; edge bytes
        sub     edi,edi
        shr     edx,1                   ;whole words
        mov     ulWholeWidthInWords,edx
        adc     edi,edi                 ;odd byte status
        mov     ulOddByte,edi
        dec     edx                     ;whole words - 1
        mov     ulWholeWidthInWordsMinus1,edx
        cmp     eax,0                   ;are there any whole bytes at all?
        jg      short opaq_edges_set    ;yes, we're all set
                                        ;no, set up for edge(s) only
        mov     pfnFirstOpaqVector,ecx  ;the edges are first, because there are
                                        ; no whole bytes

opaq_edges_set::

;-----------------------------------------------------------------------;
; Determine the screen offset of the first destination byte.
;-----------------------------------------------------------------------;

        mov     eax,[esi].yTop
        mov     ulTopScan,eax
        mov     ecx,eax
        mul     ulScreenDelta
        mov     edi,[esi].xLeft
        shr     edi,3
        mov     ulTempLeft,edi  ;remember the offset to the first dest byte
        add     edi,eax

;-----------------------------------------------------------------------;
; Map in the bank containing the top scan of the text, if it's not
; mapped in already.
;-----------------------------------------------------------------------;

        mov     ebx,pdsurf
        cmp     ecx,[ebx].dsurf_rcl1WindowClip.yTop ;is text top less than
                                                    ; current bank?
        jl      short opaq_map_init_bank            ;yes, map in proper bank
        cmp     ecx,[ebx].dsurf_rcl1WindowClip.yBottom ;text top greater than
                                                       ; current bank?
        jl      short opaq_init_bank_mapped     ;no, proper bank already mapped
opaq_map_init_bank::

; Map in the bank containing the top scan line of the fill.
; Preserves EBX, ESI, and EDI.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl>,<ebx,ecx,JustifyTop>

opaq_init_bank_mapped::

        add     edi,[ebx].dsurf_pvBitmapStart   ;initial destination address
        mov     pScreen,edi

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_SET_RESET
        out     dx,al                   ;leave the GC Index pointing to
                                        ; set/reset

;-----------------------------------------------------------------------;
; Main loop for processing fill in each bank.
;
; At start of loop and on each loop, EBX->pdsurf and EDI->first destination
; byte.
;-----------------------------------------------------------------------;

opaq_bank_loop::
        mov     edx,ulBottomScan        ;bottom of destination rectangle
        cmp     edx,[ebx].dsurf_rcl1WindowClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; text rect or the bottom of the
                                        ; current bank?
        jl      short @F                ;text bottom comes first, so draw to
                                        ; that; this is the last bank in text
        mov     edx,[ebx].dsurf_rcl1WindowClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
@@:
        sub     edx,ulTopScan           ;# of scans to draw in bank
        mov     ulNumScans,edx
        jmp     pfnFirstOpaqVector      ;do first sort of drawing (whole
                                        ; bytes, or edge(s) if no whole
                                        ; bytes)

;-----------------------------------------------------------------------;
; Draws whole bytes, which can be handled by simply loading the latches
; with the background color and using write mode 3 to punch the
; foreground color through.
;
; On entry:
;       EDI = first destination byte
;-----------------------------------------------------------------------;
opaq_whole_bytes::
        mov     esi,pTempBuffer
        test    ulTextLeft,111b         ;is left edge solid?
        jz      short @F                ;yes
        inc     esi                     ;no, point to leftmost source and dest
        inc     edi                     ; bytes (skip over partial left edge)
@@:

;-----------------------------------------------------------------------;
; Load the latches with the background color.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_DATA
        mov     eax,iBgColor
        out     dx,al                   ;set/reset color = background

        mov     byte ptr [edi],0ffh     ;we're in write mode 3, so write the
                                        ; set/reset = background color
        mov     al,byte ptr [edi]       ;latch the background color

        mov     eax,iFgColor
        out     dx,al                   ;set/reset color = foreground now

        mov     eax,ulTmpSrcDelta
        mov     ebx,ulTmpDstDelta
        mov     edx,ulNumScans
                                        ;decide which copy loop to use
        test    edi,1                   ;is dest word-aligned?
        jnz     short @F                ;no, need leading byte
                                        ;yes, no leading byte
        cmp     ulOddByte,1             ;odd width?
        jnz     short opaq_scan_loop    ;no, no trailing byte
        jmp     short opaq_scan_loop_t  ;yes, trailing byte

@@:
        cmp     ulOddByte,1             ;odd width?
        jz      short opaq_scan_loop_l  ;yes, no trailing byte
        jmp     short opaq_scan_loop_lt ;no, trailing byte

;-----------------------------------------------------------------------;
; Loops for copying whole bytes to the screen, as much as possible a word
; at a time.
; On entry:
;       EAX = offset to next buffer scan
;       EBX = offset to next screen scan
;       EDX = # of scans to draw
;       ESI = pointer to first buffer byte from which to copy
;       EDI = pointer to first screen byte to which to copy
;       DF  = cleared
; LATER could break out and optimize short runs, such as 1, 2, 3, 4 wide.
;-----------------------------------------------------------------------;

; Loop for doing whole opaque words: no leading byte, no trailing byte.
opaq_scan_loop::
@@:
        mov     ecx,ulWholeWidthInWords
        rep     movsw
        add     esi,eax         ;point to next buffer scan
        add     edi,ebx         ;point to next screen scan
        dec     edx             ;count down scans
        jnz     @B
        jmp     pfnEdgeVector   ;do the edge(s)

; Loop for doing whole opaque words: leading byte, no trailing byte.
opaq_scan_loop_l::
@@:
        movsb
        mov     ecx,ulWholeWidthInWords
        rep     movsw
        add     esi,eax         ;point to next buffer scan
        add     edi,ebx         ;point to next screen scan
        dec     edx             ;count down scans
        jnz     @B
        jmp     pfnEdgeVector   ;do the edge(s)

; Loop for doing whole opaque words: leading byte, trailing byte.
opaq_scan_loop_lt::
@@:
        movsb
        mov     ecx,ulWholeWidthInWordsMinus1   ;one word gets done as 2 bytes
        rep     movsw
        movsb
        add     esi,eax         ;point to next buffer scan
        add     edi,ebx         ;point to next screen scan
        dec     edx             ;count down scans
        jnz     @B
        jmp     pfnEdgeVector   ;do the edge(s)

; Loop for doing whole opaque words: no leading byte, trailing byte.
opaq_scan_loop_t::
@@:
        mov     ecx,ulWholeWidthInWords
        rep     movsw
        movsb
        add     esi,eax         ;point to next buffer scan
        add     edi,ebx         ;point to next screen scan
        dec     edx             ;count down scans
        jnz     @B
        jmp     pfnEdgeVector   ;do the edge(s)

;-----------------------------------------------------------------------;
; Draw the left edge only.
;-----------------------------------------------------------------------;
opaq_draw_left_edge_only::

;-----------------------------------------------------------------------;
; First, draw the foreground pixels.
;-----------------------------------------------------------------------;

        push    offset opaq_check_more_banks ;return here when done with edge

opaq_draw_left_edge_only_entry::
        mov     edx,VGA_BASE + GRAF_DATA
        mov     eax,iFgColor
        out     dx,al                   ;set/reset color = foreground

        mov     ebx,ulBufDelta
        mov     edx,ulScreenDelta
        mov     esi,pTempBuffer
        mov     edi,pScreen
        push    esi             ;remember starting buffer and screen offsets
        push    edi             ; for when we do the background pass
        mov     eax,ulLeftMask  ;AH = clip mask
        push    eax             ;preserve clip mask for background pass
        mov     ecx,ulNumScans

opaq_fg_edge_loop::
        mov     al,[esi]
        add     esi,ebx
        and     al,ah
        and     [edi],al
        add     edi,edx

        dec     ecx
        jnz     opaq_fg_edge_loop

;-----------------------------------------------------------------------;
; Now draw the background pixels with inverted buffer contents.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_DATA
        mov     eax,iBgColor
        out     dx,al                   ;set/reset color = background

        pop     eax                     ;retrieve clip mask
        pop     edi                     ;retrieve the initial screen and
        pop     esi                     ; buffer offsets

        mov     edx,ulScreenDelta
        mov     ecx,ulNumScans

opaq_bg_edge_loop::
        mov     al,[esi]
        add     esi,ebx
        not     al
        and     al,ah
        and     [edi],al
        add     edi,edx

        dec     ecx
        jnz     opaq_bg_edge_loop

        retn

;-----------------------------------------------------------------------;
; Draw the right edge only. Once we've set up the pointers, this is done
; with exactly the same code as the left edge.
;-----------------------------------------------------------------------;
opaq_draw_right_edge_only::
        push    offset opaq_check_more_banks ;return here when done with edge

opaq_draw_right_edge_only_entry::
        mov     edx,VGA_BASE + GRAF_DATA
        mov     eax,iFgColor
        out     dx,al                   ;set/reset color = foreground

        mov     ebx,ulBufDelta
        mov     edx,ulScreenDelta
        mov     edi,ulTextWidthInBytes
        dec     edi
        mov     esi,pTempBuffer
        add     esi,edi         ;point to right edge start in buffer
        add     edi,pScreen     ;point to right edge start in screen
        push    esi             ;remember starting buffer and screen offsets
        push    edi             ; for when we do the background pass
        mov     eax,ulRightMask ;AH = clip mask
        push    eax             ;preserve clip mask for background pass
        mov     ecx,ulNumScans
        jmp     short opaq_fg_edge_loop

;-----------------------------------------------------------------------;
; Draw both the left and right edges. We do this by calling first the
; left and then the right edge drawing code.
;-----------------------------------------------------------------------;
opaq_draw_both_edges::
        call    opaq_draw_left_edge_only_entry
        call    opaq_draw_right_edge_only_entry

;-----------------------------------------------------------------------;
; See if there are more banks to draw.
;-----------------------------------------------------------------------;

opaq_check_more_banks::
        mov     ebx,pdsurf
        mov     eax,[ebx].dsurf_rcl1WindowClip.yBottom ;is the text bottom in
        cmp     ulBottomScan,eax                       ; the current bank?
        jnle    short do_next_opaq_bank ;no, map in the next bank and draw
                                        ;yes, so we're done

opaq_done::
        jmp     get_next_clip_rect

do_next_opaq_bank::
        mov     ulTopScan,eax           ;this will be the top of the next bank
        mov     ecx,eax                 ;set aside scan # for bank manager call
        mul     ulScreenDelta
        mov     edi,ulTempLeft
        add     edi,eax                 ;next screen byte to which to copy

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl>,<ebx,ecx,JustifyTop>
                                        ;map in the bank (call preserves EBX,
                                        ; ESI, and EDI)

        add     edi,[ebx].dsurf_pvBitmapStart   ;initial destination address
        mov     pScreen,edi

        mov     eax,ulBufDelta
        mul     ulNumScans
        add     pTempBuffer,eax         ;advance to next temp buffer scan to
                                        ; copy
        jmp     opaq_bank_loop          ;we're ready to draw in the new bank

;-----------------------------------------------------------------------;
; Special 8-wide aligned opaque drawing code. Loads the latches with the
; background color, sets the Set/Reset color to the foreground color,
; then uses write mode 3 to draw the glyphs. Joyously, there are no
; partial bytes to worry about, so we can really crank up the code.
;
; On entry:
;       EBX = prclText
;-----------------------------------------------------------------------;
special_8_wide_aligned_opaque::

        mov     esi,pdsurf
        mov     edi,[ebx].yBottom
        mov     eax,[ebx].yTop
        sub     edi,eax                 ;height of glyphs

;-----------------------------------------------------------------------;
; Map in the bank containing the top scan of the text, if it's not
; mapped in already.
;-----------------------------------------------------------------------;

        cmp     eax,[esi].dsurf_rcl1WindowClip.yTop ;is text top less than
                                                    ; current bank?
        jl      short s8wao_map_init_bank           ;yes, map in proper bank
        cmp     eax,[esi].dsurf_rcl1WindowClip.yBottom ;text top greater than
                                                       ; current bank?
        jl      short s8wa0_init_bank_mapped   ;no, proper bank already mapped
s8wao_map_init_bank::

; Map in the bank containing the top scan line of the text.
; Preserves EBX, ESI, and EDI.

        ptrCall <dword ptr [esi].dsurf_pfnBankControl>,<esi,eax,JustifyTop>

s8wa0_init_bank_mapped::

        mov     eax,[esi].dsurf_rcl1WindowClip.yBottom
        sub     eax,[ebx].yTop          ;maximum run in bank
        cmp     edi,eax                 ;does all the text fit in the bank?
        jg      general_handler         ;no, let general code handle it
                                        ;LATER could handle here

;-----------------------------------------------------------------------;
; Set up variables.
;-----------------------------------------------------------------------;

        mov     ulScans,edi             ;# of scans in glyphs

;-----------------------------------------------------------------------;
; Point to the first screen byte at which to draw.
;-----------------------------------------------------------------------;

        mov     eax,[ebx].yTop
        mul     [esi].dsurf_lNextScan
        mov     edi,[ebx].xLeft
        shr     edi,3
        add     edi,eax                 ;next screen byte to which to copy
        add     edi,[esi].dsurf_pvBitmapStart   ;initial destination address
        mov     pScreen,edi

;-----------------------------------------------------------------------;
; Set up the VGA's hardware for read mode 0 and write mode 3.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,GRAF_MODE + ((M_AND_WRITE + M_DATA_READ) SHL 8)
        out     dx,ax                   ;write mode 3 so we can do masking
                                        ; without OUTs

;-----------------------------------------------------------------------;
; Load the latches with the background color.
;-----------------------------------------------------------------------;

        mov     ah,byte ptr iBgColor
        mov     al,GRAF_SET_RESET
        out     dx,ax                   ;set/reset color = background

        mov     byte ptr [edi],0ffh     ;we're in write mode 3, so write the
                                        ; set/reset = background color
        mov     al,byte ptr [edi]       ;latch the background color

        inc     edx                     ;point to GC Data register
        mov     eax,iFgColor
        out     dx,al                   ;set/reset color = foreground now

;-----------------------------------------------------------------------;
; Set up the screen scan offset in EDX, and decide whether we need to do
; a leading glyph or not.
;-----------------------------------------------------------------------;

        mov     edx,[esi].dsurf_lNextScan ;offset from one scan to next

        test    edi,1                   ;is leading glyph address even or odd?
        jz      short s8wa0_word        ;even, so no leading glyph

;-----------------------------------------------------------------------;
; Do the leading glyph.
;-----------------------------------------------------------------------;

        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        add     pGlyphPos,size GLYPHPOS ;point to the next glyph
        inc     pScreen                 ;point to the next glyph's screen
                                        ; location
        dec     ulGlyphCount            ;count off this character
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     ecx,ulScans             ;# of loop reps
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        add     esi,gb_aj               ;point to the first glyph byte
        call    s8wao_byte_loop         ;branch into loop

s8wa0_word::
        mov     ecx,ulGlyphCount
        shr     ecx,1                   ;# of words we can copy, now that
                                        ; we're word-aligned
        jz      short s8wa0_trailing    ;no words to copy
        mov     ulWholeWidthInWords,ecx

s8wa0_word_loop::
        mov     ebx,pGlyphPos           ;point to the next glyph pair to draw
        add     pGlyphPos,((size GLYPHPOS)*2) ;point to the next glyph pair
        mov     edi,pScreen             ;point to current glyph pair's screen
                                        ; location
        add     pScreen,2               ;point to the next glyph pair's
                                        ; screen location
        mov     esi,[ebx].gp_pgdf       ;point to first glyph def
        mov     ebx,[ebx+(size GLYPHPOS)].gp_pgdf ;point to second glyph def
        mov     esi,[esi].gdf_pgb       ;point to first glyph
        mov     ebx,[ebx].gdf_pgb       ;point to second glyph
        add     esi,gb_aj               ;point to the first glyph's bits
        add     ebx,gb_aj               ;point to the second glyph's bits
        mov     ecx,ulScans             ;# of loop reps

s8wao_word_loop::
        mov     al,[esi]
        inc     esi
        mov     ah,[ebx]
        inc     ebx
        mov     [edi],ax
        add     edi,edx

        dec     ecx                     ;count down glyph scans
        jnz     s8wao_word_loop

        dec     ulWholeWidthInWords     ;count down glyph pairs
        jnz     s8wa0_word_loop

;-----------------------------------------------------------------------;
; Do the trailing character, if there is one.
;-----------------------------------------------------------------------;

s8wa0_trailing::
        test    ulGlyphCount,1          ;trailing byte count
                                        ;is there a trailing character?
        jz      opaq_done               ;no, we're done

        mov     ebx,pGlyphPos           ;point to the last glyph to draw
        mov     edi,pScreen             ;point to the final glyph's screen
                                        ; location
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     ecx,ulScans             ;# of loop reps
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        add     esi,gb_aj               ;point to the first glyph byte
        push    offset opaq_done        ;return here to finish up

s8wao_byte_loop::
        mov     al,[esi]
        inc     esi
        mov     [edi],al
        add     edi,edx

        dec     ecx
        jnz     s8wao_byte_loop

        retn

exit_fast_text::

        ;
        ; Only reset HW if target is VGA
        ;

        cmp     iTrgType,VGA_TARGET
        jne     end_fast_text

;-----------------------------------------------------------------------;
; Restore the VGA's hardware state and we're done.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,GRAF_MODE + ((M_PROC_WRITE + M_DATA_READ) SHL 8)
        out     dx,ax                   ;restore read mode 0 and write mode 0

end_fast_text::
        cRet    vFastText

endProc vFastText

;-----------------------------------------------------------------------;
; VOID vClearMemDword(PULONG * pulBuffer, ULONG ulDwordCount);
;
; Clears ulCount dwords starting at pjBuffer.
;-----------------------------------------------------------------------;

pulBuffer    equ [esp+8]
ulDwordCount equ [esp+12]

cProc vClearMemDword,8,<>

        push    edi
        mov     edi,pulBuffer
        mov     ecx,ulDwordCount
        sub     eax,eax
        rep     stosd
        pop     edi

        cRet  vClearMemDword

endProc vClearMemDword

public draw_f_tb_no_to_temp_start
public draw_nf_tb_no_to_temp_start
public draw_to_temp_start_entry
public draw_f_ntb_o_to_temp_start
public draw_nf_ntb_o_to_temp_start
public draw_to_temp_start_entry2
public draw_f_tb_no_to_temp_loop
public draw_nf_tb_no_to_temp_loop
public draw_to_temp_loop_entry
public draw_f_ntb_o_to_temp_loop
public draw_nf_ntb_o_to_temp_loop
public draw_to_temp_loop_entry2
public or_all_1_wide_rotated_need_last
public or_all_1_wide_rotated_no_last
public or_first_1_wide_rotated_need_last
public or_first_1_wide_rotated_no_last
public or_first_1_wide_rotated_loop
public mov_first_1_wide_rotated_need_last
public mov_first_1_wide_rotated_no_last
public mov_first_1_wide_rotated_loop
public mov_first_1_wide_unrotated
public mov_first_1_wide_unrotated_loop
public or_all_1_wide_unrotated
public or_all_1_wide_unrotated_loop
public or_first_2_wide_rotated_need_last
public or_first_2_wide_rotated_need_loop
public or_all_2_wide_rotated_need_last
public or_all_2_wide_rotated_need_loop
public mov_first_2_wide_rotated_need_last
public mov_first_2_wide_rotated_need_loop
public or_first_2_wide_rotated_no_last
public or_first_2_wide_rotated_loop
public or_all_2_wide_rotated_no_last
public or_all_2_wide_rotated_loop
public mov_first_2_wide_rotated_no_last
public mov_first_2_wide_rotated_loop
public mov_first_2_wide_unrotated
public mov_first_2_wide_unrotated_loop
public or_all_2_wide_unrotated
public or_all_2_wide_unrotated_loop
public or_first_3_wide_rotated_need_last
public or_all_3_wide_rotated_need_last
public mov_first_3_wide_rotated_need_last
public or_first_3_wide_rotated_no_last
public or_all_3_wide_rotated_no_last
public mov_first_3_wide_rotated_no_last
public mov_first_3_wide_unrotated
public or_all_3_wide_unrotated
public or_first_4_wide_rotated_need_last
public or_all_4_wide_rotated_need_last
public mov_first_4_wide_rotated_need_last
public or_first_4_wide_rotated_no_last
public or_all_4_wide_rotated_no_last
public mov_first_4_wide_rotated_no_last
public mov_first_4_wide_unrotated
public or_all_4_wide_unrotated
public or_first_N_wide_rotated_need_last
public or_all_N_wide_rotated_need_last
public mov_first_N_wide_rotated_need_last
public or_first_N_wide_rotated_no_last
public or_all_N_wide_rotated_no_last
public mov_first_N_wide_rotated_no_last
public mov_first_N_wide_unrotated
public odd_width
public two_odd_bytes
public three_odd_bytes
public or_all_N_wide_unrotated
public or_no_odd_bytes_loop
public or_odd_width
public or_one_odd_bytes_loop
public or_two_odd_bytes
public or_two_odd_bytes_loop
public or_three_odd_bytes
public or_three_odd_bytes_loop
public glyphs_are_done
public rect_loop
public fasttext_detect_partials
public fasttext_one_partial_only
public fasttext_check_whole_dwords
public fasttext_set_copy_control_flags
public extra_rects_are_done
public get_next_clip_rect
public do_opaque_clip
public clip_set
public opaque_text_dfb
public fasttext_2_detect_partials
public fasttext_2_one_partial_only
public fasttext_2_check_whole_dwords
public fasttext_2_set_copy_control_flags
public copy_text_opaq_00
public copy_text_opaq_01
public copy_text_opaq_10
public copy_text_opaq_11
public copy_inv_text_opaq_00
public copy_inv_text_opaq_01
public copy_inv_text_opaq_10
public copy_inv_text_opaq_11
public vga_target
public xpar_left_edge_solid
public xpar_set_edge_vector
public xpar_edges_set
public xpar_map_init_bank
public xpar_init_bank_mapped
public xpar_bank_loop
public xpar_scan_loop
public do_next_xpar_bank
public xpar_byte_loop_00
public xpar_byte_loop_01
public xpar_byte_loop_10
public xpar_byte_loop_11
public opaque_text
public opaq_left_edge_solid
public opaq_set_edge_vector
public opaq_edges_set
public opaq_map_init_bank
public opaq_init_bank_mapped
public opaq_bank_loop
public opaq_whole_bytes
public opaq_scan_loop
public opaq_scan_loop_l
public opaq_scan_loop_lt
public opaq_scan_loop_t
public opaq_draw_left_edge_only
public opaq_draw_left_edge_only_entry
public opaq_fg_edge_loop
public opaq_bg_edge_loop
public opaq_draw_right_edge_only
public opaq_draw_right_edge_only_entry
public opaq_draw_both_edges
public opaq_check_more_banks
public opaq_done
public do_next_opaq_bank
public special_8_wide_aligned_opaque
public s8wao_map_init_bank
public s8wa0_init_bank_mapped
public s8wa0_word
public s8wa0_word_loop
public s8wao_word_loop
public s8wa0_trailing
public s8wao_byte_loop
public exit_fast_text
public end_fast_text

_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\driver.inc ===
;******************************Module*Header*******************************\
; Module Name: driver.inc
;
; driver prototypes
;
; Copyright (c) 1992 Microsoft Corporation
;**************************************************************************/



;!!! Make this match driver.h  I want to see the same include structure
;!!! for assembler as for C

DDI_DRIVER_VERSION  EQU 010000h

MAX_SCAN_WIDTH  equ     2048   ; pixels

;/* gflDrv */

DRV_ENABLED_ONCE    EQU 1
DRV_ENABLED_PDEV    EQU 2

; Space required for working storage when working with banking on adapters
; that don't support two independent read/write windows. The largest supported
; bank is 64K; this constant provides for storing four 64K planes.
; Mirrors DRIVER.H.

BANK_BUFFER_SIZE equ    10000h*4

; Start offsets of planes within the bank buffer.
; Mirrors DRIVER.H.

BANK_BUFFER_PLANE_SIZE equ 04000h

PLANE_0_OFFSET  equ     0
PLANE_1_OFFSET  equ     BANK_BUFFER_PLANE_SIZE
PLANE_2_OFFSET  equ     BANK_BUFFER_PLANE_SIZE*2
PLANE_3_OFFSET  equ     BANK_BUFFER_PLANE_SIZE*3


; Indicates type of bank justification within banking window. Matches
; typedef enum BANK_JUST in DRIVER.H.

JustifyTop      equ     0
JustifyBottom   equ     1


; Specifies which window is to be mapped by two-window bank handler.

MapSourceBank   equ     0
MapDestBank     equ     1


; /* This device can have only one PDEV */

DRV_ONE_PDEV  EQU  1

; Miscellaneous driver flags in pdev.fl
;---mirrors driver.h---;

DRIVER_USE_OFFSCREEN equ 02h  ; if not set, don't use offscreen memory

; Maximum width and height handled by this driver (controls buffer sizes).

CX_SCREEN_MAX   equ     1280
CY_SCREEN_MAX   equ     1024
cj_max_scan     equ     (CX_SCREEN_MAX/8)

; Macro to do a simple RET, with no stack stuff, in a proc.
PLAIN_RET macro
        db      0c3h
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\egavga.inc ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:	EGAVGA.INC
;
; This file contains the external definitions of the EGA/VGA specific
; locations which driver output routines need to reference.
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
; Restrictions:
;
;	The following rules apply to the use of the EGA/VGA registers
;	for the drivers (excluding pointer code and state detection
;	code):
;
;
;	1)  Routines are allowed to alter the following registers:
;
;	    Sequencer:
;
;		SEQ_DATA		SEQ_MAP_MASK
;
;	    Graphics Controller:
;
;		GRAF_ADDR
;		GRAF_DATA		GRAF_DATA_ROT
;		GRAF_SET_RESET		GRAF_READ_MAP
;		GRAF_ENAB_SR		GRAF_MODE
;		GRAF_COL_COMP		GRAF_BIT_MASK
;
;
;	2)  The following registers will always contain the indicated
;	    value.  Routines are not allowed to alter them:
;
;	    Sequencer:
;
;		SEQ_ADDR	set to point SEQ_MAP_MASK
;
;	    Graphics Controller:
;
;		GRAF_CDC	set appropriately for color model
;
;
;	3)  Rotation counts for GRAF_DATA_ROT are not allowed.
;
;
;	4)  The following EGA/VGA registers will contain the indicated
;	    value upon entry to a routine.  Any routine which alters
;	    them must restore them to the indicated state.
;
;		Map Mask	    all planes enabled
;		Enable Set/Reset    all planes disabled
;		Data Rotate	    Set, no rotation
;		Mode		    Processor write, data read
;		Bit Mask	    all bits enabled
;
;
;	5)  The Mode Register is always shadowed in EGA/VGA memory for
;	    the state detection code.  At interrupt time, the mode
;	    will be restored from the structure "shadowed_graf_mode".
;	    Any routine altering the Mode Register must keep this location
;	    current.  This is the only EGA/VGA register which requires
;	    shadowing.
;
;
;	6)  Pointer drawing will save and restore the contents of
;	    the processor latches.
;
;
;	7)  Pointer drawing will leave GRAF_ADDR set to GRAF_BIT_MASK.
;
;-----------------------------------------------------------------------;

	include i386\driver.inc
	
;	Miscellaneous Registers used only at EGA/VGA initialization time

MISC_OUTPUT	EQU	0C2h		;Miscellaneous Output Register
CRTC_ADDR	EQU	0D4h		;CRTC Address Register for color mode
CRTC_DATA	EQU	0D5h		;CRTC Data    Register for color mode
GRAF_1_POS	EQU	0CCh		;Graphics 1 Address Register
GRAF_2_POS	EQU	0CAh		;Graphics 2 Address Register
ATTR_READ	EQU	0DAh		;Attribute Controler Read  Address
ATTR_WRITE	EQU	0C0h		;Attribute Controler Write Address
IN_STAT_0	EQU	0C2h		;Input Status Register 0
IN_STAT_1	EQU	0DAh		;Input Status Register 1



;	EGA/VGA Register Definitions.
;
;	The following definitions are the EGA/VGA registers and values
;	used by this driver.  All other registers are set up at
;	when the EGA/VGA is placed into graphics mode and never altered
;	afterwards.
;
;	All unspecified bits in the following registers must be 0.


EGA_BASE	EQU	300h		;Base address of the EGA (3xx)
VGA_BASE	EQU	300h		;Base address of the VGA (3xx)



;	EGA/VGA Register Definitions.

EGA_BASE	EQU	300h		;Base address of the EGA (3xx)
VGA_BASE	EQU	300h		;Base address of the VGA (3xx)

;	SEQUencer Registers Used

SEQ_ADDR	EQU	0C4h		;SEQUencer Address Register
SEQ_DATA	EQU	0C5h		;SEQUencer Data    Register

SEQ_MAP_MASK	EQU	02h		;Write Plane Enable Mask
MM_C0		EQU	00000001b	;  C0 plane enable
MM_C1		EQU	00000010b	;  C1 plane enable
MM_C2		EQU	00000100b	;  C2 plane enable
MM_C3		EQU	00001000b	;  C3 plane enable
MM_ALL		EQU	00001111b	;  All planes

SEQ_MODE	EQU	04h		;Memory Mode
SM_ALPHA	EQU	00000001b	;  Char map select enable
SM_EXTENDED	EQU	00000010b	;  Extended memory present
SM_ODD_PLANE	EQU	00000100b	;  Odd/even bytes to same plane


;	Graphics Controller Registers Used

GRAF_ADDR	EQU	0CEh		;Graphics Controller Address Register
GRAF_DATA	EQU	0CFh		;Graphics Controller Data    Register

GRAF_SET_RESET	EQU	00h		;  Set/Reset Plane Color
GRAF_ENAB_SR	EQU	01h		;  Set/Reset Enable
GRAF_COL_COMP	EQU	02h		;  Color Compare Register

GRAF_DATA_ROT	EQU	03h		;  Data Rotate Register
DR_ROT_CNT	EQU	00000111b	;    Data Rotate Count
DR_SET		EQU	00000000b	;    Data Unmodified
DR_AND		EQU	00001000b	;    Data ANDed with latches
DR_OR		EQU	00010000b	;    Data ORed	with latches
DR_XOR		EQU	00011000b	;    Data XORed with latches

GRAF_READ_MAP	EQU	04h		;  Read Map Select Register
RM_C0		EQU	00000000b	;    Read C0 plane
RM_C1		EQU	00000001b	;    Read C1 plane
RM_C2		EQU	00000010b	;    Read C2 plane
RM_C3		EQU	00000011b	;    Read C3 plane

GRAF_MODE	EQU	05h		;  Mode Register
M_PROC_WRITE	EQU	00000000b	;    Write processor data rotated
M_LATCH_WRITE	EQU	00000001b	;    Write latched data
M_COLOR_WRITE	EQU	00000010b	;    Write processor data as color
M_AND_WRITE	EQU	00000011b	;    Write (procdata AND bitmask)
M_DATA_READ	EQU	00000000b	;    Read selected plane
M_COLOR_READ	EQU	00001000b	;    Read color compare

GRAF_MISC	EQU	06h		;  Miscellaneous Register
MS_NON_ALPHA	EQU	00000001b	;    Char generator disabled
MS_ODD_EVEN	EQU	00000010b	;    Map odd addresses to even
MS_A0000_128K	EQU	00000000b	;    Memory present at A0000, 128kb
MS_A0000_64K	EQU	00000100b	;    Memory present at A0000, 64kb
MS_B0000_32K	EQU	00001000b	;    Memory present at B0000, 32kb
MS_B8000_32K	EQU	00001100b	;    Memory present at B8000, 32kb
MS_ADDR_MASK	EQU	00001100b

GRAF_CDC	EQU	07h		;  Color Don't Care Register
GRAF_BIT_MASK	EQU	08h		;  Bit Mask Register


;       Various sizes for EGA/VGA data structures

;-----------------------------------------------------------------------;
; On the EGA/VGA, the number of bits/pel is 4
; The number of bytes per scan is 80
;-----------------------------------------------------------------------;

BITS_PEL        EQU     4

;-----------------------------------------------------------------------;
; Helper flags for the xyCreateMasks call
;-----------------------------------------------------------------------;

PTRI_INVERT     EQU     1   ; !!! In WINGDIP.H when H2INC works
PTRI_ANIMATE    EQU     2   ; !!! In WINGDIP.H when H2INC works

;-----------------------------------------------------------------------;
; The pointer parameters are the size of the pointer as received from
; DeviceSetCursor.
;-----------------------------------------------------------------------;

PTR_HEIGHT	EQU	32
PTR_WIDTH	EQU	4			;Width in bytes of pointer
PTR_WIDTH_BITS	EQU	PTR_WIDTH*8		;Width in bits of pointer

;-----------------------------------------------------------------------;
; The work width/height is the size of a pointer as manipulated by
; the pointer drawing code.
;-----------------------------------------------------------------------;

WORK_WIDTH	EQU	PTR_WIDTH+1		;Width of mask, work area
WORK_HEIGHT	EQU	PTR_HEIGHT+0		;Height of mask, work area
MASK_LENGTH	EQU	WORK_WIDTH*WORK_HEIGHT	;#bytes in mask, work area
CLR_MASK_LENGTH	EQU	WORK_WIDTH*WORK_HEIGHT*BITS_PEL	;#bytes in color mask
	.errnz	BITS_PEL-4

;-----------------------------------------------------------------------;
; The save area parameters control the size of the buffer used for
; saveing the bits underneath the pointer image.  It should be a
; power of two to allow for easy wrap calculations.
;-----------------------------------------------------------------------;

SAVE_BUFFER_WIDTH  EQU	  8			  ;Width  of the save area
SAVE_BUFFER_HEIGHT EQU	  32			  ;Height of the save area
		   .errnz  PTR_WIDTH  GT SAVE_BUFFER_WIDTH
		   .errnz  PTR_HEIGHT GT SAVE_BUFFER_HEIGHT



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\nalgnblt.asm ===
;******************************Module*Header*******************************\
; Module Name: nalgnblt.asm
;
; driver prototypes
;
; Copyright (c) 1992 Microsoft Corporation
;**************************************************************************/

;-----------------------------------------------------------------------;
; VOID vNonAlignedSrcCopy(PDEVSURF pdsurf, RECTL * prcldst, PPOINTL * pptlsrc,
;                      INT icopydir);
; Input:
;  pdsurf - surface on which to copy
;  prcldest - pointer to destination rectangle
;  pptlsrc - pointer to source upper left corner
;  icopydir - direction in which copy must proceed to avoid overlap problems
;             and synchronize with the clip enumeration visually, according to
;             constants CD_RIGHTDOWN, CD_LEFTDOWN, CD_RIGHTUP, and CD_LEFTUP in
;             WINDDI.H
;
; Performs accelarated non-aligned SRCCOPY VGA-to-VGA blts.
;
;-----------------------------------------------------------------------;
;
; Note: The source and dest *must* be non-aligned (not have the same
; left-edge intrabyte pixel alignment. Will not work properly if they are
; in fact aligned.
;
; Note: Assumes all rectangles have positive heights and widths. Will not
; work properly if this is not the case.
;
;-----------------------------------------------------------------------;

        comment $

The overall approach of this module for each rectangle to copy is:

1) Precalculate the masks and whole byte widths, and determine which of
partial left edge, partial right edge, and whole middle bytes are required
for this copy.

2) Set up the starting pointers for each of the areas (left, whole middle,
right), the start and stop scan lines, the copying direction (left-to-right
or right-to-left, and top-to-bottom or bottom-to-top), the threading
(sequence of calls required to do the left/whole/right components in the
proper sequence), based on the passed-in copy direction, which in turn is
dictated by the nature of the overlap between the source and destination.

3) Execute a loop, based on adapter type (2 R/W windows, 1R/1W window,
1 R/W window, unbanked), that sequences through the intersection of each
bank with the source and destination rectangles in the proper direction
(top-to-bottom or bottom-to-top, based on the passed-in copy direction),
and performs the copy in each such rectangle. The threading vector is used
to call the required routines (copy left/whole/right bytes). For 1 R/W and
1R/1W adapters, there is a second threading vector that is called when the
source and the destination are both adequately (for the copy purposes)
addressable simultaneously (because they're in the same bank), so there's
no need to copy through a temp buffer. We want to avoid the temp
buffer whenever we can, because it's slower.

Note: 1 R/W and 1R/1W edges are copied through a temporary buffer. However,
each plane's bytes are not stored in the corresponding plane's temp buffer, but
rather consecutively in the plane 0 temp buffer. This is to reduce page
faulting, and also so that 1R/1W adapters only need a temp buffer large enough
to hold 4*tallest bank words (4K will do). 1 R/W adapters still copy whole
bytes through the full temp buffer, using all four planes' temp buffers, so
they require a temp buffer big enough to hold a full bank (256K will do).

Note: The VGA's rotator is used to perform all rotation in this module. The
two source bytes relevant to this operation are masked to preserve the desired
bits, then combined and fed to the VGA's rotator, which performs the rotation.
This is better than letting the 386/486 do the rotation because even with the
barrel shifter, those processors take 3 cycles per rotate, where the masking
and combining take only 2 cycles (or no cycles, for edges with 1-wide
sources). We also get to avoid 16-bit instructions like ROL AX,CL; the 16-bit
size prefix costs a cycle on a 486.

        commend $

;-----------------------------------------------------------------------;
; This is no longer used, but is needed by unroll.inc.

LOOP_UNROLL_SHIFT equ 1

;-----------------------------------------------------------------------;
; Maximum # of edge bytes to process before switching to next plane. Larger
; means faster, but there's more potential for flicker, since the raster scan
; has a better chance of catching bytes that have changed in some planes but
; not all planes. Larger also means bigger.

EDGE_CHUNK_SIZE equ     4

;-----------------------------------------------------------------------;
; Macro to push the current threading sequence (string of routine calls) on the
; stack, then jump to the first threading entry. The threading pointer can be
; specified, or defaults to pCurrentThread. The return address can be
; immediately after the JMP, or can be specified.

THREAD_AND_START macro THREADING,RETURN_ADDR
        local   push_base, return_address

ifb <&RETURN_ADDR&>
        push    offset return_address   ;after all the threaded routines, we
                                        ; return here
else
        push    offset &RETURN_ADDR&    ;return here
endif

ifb <&THREADING&>
        mov     eax,pCurrentThread
else
        mov     eax,&THREADING&
endif

        mov     ecx,[eax]               ;# of routines to thread (at least 1)
        lea     ecx,[ecx*2+ecx]         ;pushes below are 3 bytes each
        mov     edx,offset push_base+3
        sub     edx,ecx
        jmp     edx                     ;branch to push or jmp below

; Push the threading addresses on to the stack, so routines perform the
; threading as they return.

        push    dword ptr [eax+12]       ;3 byte instruction
        push    dword ptr [eax+8]
push_base:
        jmp     dword ptr [eax+4]        ;jump to the first threaded routine

return_address:
        endm

;-----------------------------------------------------------------------;

                .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc
        include i386\unroll.inc
        include i386\ropdefs.inc

        .list

;-----------------------------------------------------------------------;

        .data

; Threads for stringing together left, whole byte, and right operations
; in various orders, both using a temp buffer and not. Data format is:
;
; DWORD +0 = # of calls in thread (1, 2, or 3)
;       +4 = first call (required)
;       +8 = second call (optional)
;      +12 = third call (optional)

        align   4

; Copies not involving the temp buffer.

Thread_L        dd      1
                dd      copy_left_edge

Thread_W        dd      1
                dd      copy_whole_bytes

Thread_R        dd      1
                dd      copy_right_edge

Thread_LR       dd      2
                dd      copy_left_edge
                dd      copy_right_edge

Thread_RL       dd      2
                dd      copy_right_edge
                dd      copy_left_edge

Thread_LW       dd      2
                dd      copy_left_edge
                dd      copy_whole_bytes

Thread_WL       dd      2
                dd      copy_whole_bytes
                dd      copy_left_edge

Thread_WR       dd      2
                dd      copy_whole_bytes
                dd      copy_right_edge

Thread_RW       dd      2
                dd      copy_right_edge
                dd      copy_whole_bytes

Thread_LWR      dd      3
                dd      copy_left_edge
                dd      copy_whole_bytes
                dd      copy_right_edge

Thread_RWL      dd      3
                dd      copy_right_edge
                dd      copy_whole_bytes
                dd      copy_left_edge

; Copies involving the temp buffer.

Thread_Lb       dd      1
                dd      copy_left_edge_via_buffer

Thread_Wb       dd      1
                dd      copy_whole_bytes_via_buffer

Thread_Rb       dd      1
                dd      copy_right_edge_via_buffer

Thread_LbRb     dd      2
                dd      copy_left_edge_via_buffer
                dd      copy_right_edge_via_buffer

Thread_RbLb     dd      2
                dd      copy_right_edge_via_buffer
                dd      copy_left_edge_via_buffer

Thread_LbW      dd      2
                dd      copy_left_edge_via_buffer
                dd      copy_whole_bytes

Thread_LbWb     dd      2
                dd      copy_left_edge_via_buffer
                dd      copy_whole_bytes_via_buffer

Thread_WLb      dd      2
                dd      copy_whole_bytes
                dd      copy_left_edge_via_buffer

Thread_WbLb     dd      2
                dd      copy_whole_bytes_via_buffer
                dd      copy_left_edge_via_buffer

Thread_WRb      dd      2
                dd      copy_whole_bytes
                dd      copy_right_edge_via_buffer

Thread_WbRb     dd      2
                dd      copy_whole_bytes_via_buffer
                dd      copy_right_edge_via_buffer

Thread_RbW      dd      2
                dd      copy_right_edge_via_buffer
                dd      copy_whole_bytes

Thread_RbWb     dd      2
                dd      copy_right_edge_via_buffer
                dd      copy_whole_bytes_via_buffer

Thread_LbWRb    dd      3
                dd      copy_left_edge_via_buffer
                dd      copy_whole_bytes
                dd      copy_right_edge_via_buffer

Thread_LbWbRb   dd      3
                dd      copy_left_edge_via_buffer
                dd      copy_whole_bytes_via_buffer
                dd      copy_right_edge_via_buffer

Thread_RbWLb    dd      3
                dd      copy_right_edge_via_buffer
                dd      copy_whole_bytes
                dd      copy_left_edge_via_buffer

Thread_RbWbLb   dd      3
                dd      copy_right_edge_via_buffer
                dd      copy_whole_bytes_via_buffer
                dd      copy_left_edge_via_buffer

;-----------------------------------------------------------------------;
; Table of thread selection for various horizontal copy directions, with
; the look-up index a 4-bit field as follows:
;
; Bit 3 = 1 if left-to-right copy, 0 if right-to-left
; Bit 2 = 1 if left edge must be copied
; Bit 1 = 1 if whole bytes must be copied
; Bit 0 = 1 if right edge must be copied
;
; This is used for all cases where both the source and destination are
; simultaneously addressable for our purposes, so there's no need to go
; through the temp buffer (unbanked, 2 R/W, and sometimes for 1 R/W and 1R/1W).

MasterThreadTable label dword
                                ;right-to-left
        dd      0               ;<not used>
        dd      Thread_R        ;R->L, R
        dd      Thread_W        ;R->L, W
        dd      Thread_RW       ;R->L, RW
        dd      Thread_L        ;R->L, L
        dd      Thread_RL       ;R->L, RL
        dd      Thread_WL       ;R->L, WL
        dd      Thread_RWL      ;R->L, RWL
                                ;left-to-right
        dd      0               ;<not used>
        dd      Thread_R        ;L->R, R
        dd      Thread_W        ;L->R, W
        dd      Thread_WR       ;L->R, WR
        dd      Thread_L        ;L->R, L
        dd      Thread_LR       ;L->R, LR
        dd      Thread_LW       ;L->R, LW
        dd      Thread_LWR      ;L->R, LWR


; Table of thread selection for various adapter types and horizontal
; copy directions, with the look-up index a 6-bit field as follows:
;
; Bit 5 = adapter type high bit
; Bit 4 = adapter type low bit
; Bit 3 = 1 if left-to-right copy, 0 if right-to-left
; Bit 2 = 1 if left edge must be copied
; Bit 1 = 1 if whole bytes must be copied
; Bit 0 = 1 if right edge must be copied
;
; This is used for all cases where the source and destination are not both
; simultaneously addressable for our purposes, so we need to go through the
; temp buffer (only for 1 R/W and 1R/1W, and only sometimes).

MasterThreadTableViaBuffer label dword
                                ;unbanked (no need for buffer)
                                ;right-to-left
        dd      0               ;<not used>
        dd      Thread_R        ;R->L, R
        dd      Thread_W        ;R->L, W
        dd      Thread_RW       ;R->L, RW
        dd      Thread_L        ;R->L, L
        dd      Thread_RL       ;R->L, RL
        dd      Thread_WL       ;R->L, WL
        dd      Thread_RWL      ;R->L, RWL
                                ;left-to-right
        dd      0               ;<not used>
        dd      Thread_R        ;L->R, R
        dd      Thread_W        ;L->R, W
        dd      Thread_WR       ;L->R, WR
        dd      Thread_L        ;L->R, L
        dd      Thread_LR       ;L->R, LR
        dd      Thread_LW       ;L->R, LW
        dd      Thread_LWR      ;L->R, LWR

                                ;1 R/W banking window (everything goes through
                                ;                       buffer)
                                ;right-to-left
        dd      0               ;<not used>
        dd      Thread_Rb       ;R->L, R
        dd      Thread_Wb       ;R->L, W
        dd      Thread_RbWb     ;R->L, RW
        dd      Thread_Lb       ;R->L, L
        dd      Thread_RbLb     ;R->L, RL
        dd      Thread_WbLb     ;R->L, WL
        dd      Thread_RbWbLb   ;R->L, RWL
                                ;left-to-right
        dd      0               ;<not used>
        dd      Thread_Rb       ;L->R, R
        dd      Thread_Wb       ;L->R, W
        dd      Thread_WbRb     ;L->R, WR
        dd      Thread_Lb       ;L->R, L
        dd      Thread_LbRb     ;L->R, LR
        dd      Thread_LbWb     ;L->R, LW
        dd      Thread_LbWbRb   ;L->R, LWR

                                ;1R/1W banking window (edge go through buffer)
                                ;right-to-left
        dd      0               ;<not used>
        dd      Thread_Rb       ;R->L, R
        dd      Thread_W        ;R->L, W
        dd      Thread_RbW      ;R->L, RW
        dd      Thread_Lb       ;R->L, L
        dd      Thread_RbLb     ;R->L, RL
        dd      Thread_WLb      ;R->L, WL
        dd      Thread_RbWLb    ;R->L, RWL
                                ;left-to-right
        dd      0               ;<not used>
        dd      Thread_Rb       ;L->R, R
        dd      Thread_W        ;L->R, W
        dd      Thread_WRb      ;L->R, WR
        dd      Thread_Lb       ;L->R, L
        dd      Thread_LbRb     ;L->R, LR
        dd      Thread_LbW      ;L->R, LW
        dd      Thread_LbWRb    ;L->R, LWR

                                ;2 R/W banking window (no need for buffer)
                                ;right-to-left
        dd      0               ;<not used>
        dd      Thread_R        ;R->L, R
        dd      Thread_W        ;R->L, W
        dd      Thread_RW       ;R->L, RW
        dd      Thread_L        ;R->L, L
        dd      Thread_RL       ;R->L, RL
        dd      Thread_WL       ;R->L, WL
        dd      Thread_RWL      ;R->L, RWL
                                ;left-to-right
        dd      0               ;<not used>
        dd      Thread_R        ;L->R, R
        dd      Thread_W        ;L->R, W
        dd      Thread_WR       ;L->R, WR
        dd      Thread_L        ;L->R, L
        dd      Thread_LR       ;L->R, LR
        dd      Thread_LW       ;L->R, LW
        dd      Thread_LWR      ;L->R, LWR


; Amount to shift adapter type field left for use in MasterThreadTableViaBuffer.

ADAPTER_FIELD_SHIFT     equ     4

; Mask for setting left-to-right bit to "left-to-right true" for use in both
; MasterThread tables.

LEFT_TO_RIGHT_FIELD_SET equ     1000b


; Table of top-to-bottom loops for adapter types.

        align   4
TopToBottomLoopTable label dword
        dd      top_to_bottom_2RW       ;unbanked is same as 2RW
        dd      top_to_bottom_1RW
        dd      top_to_bottom_1R1W
        dd      top_to_bottom_2RW


; Table of bottom-to-top loops for adapter types.

        align   4
BottomToTopLoopTable label dword
        dd      bottom_to_top_2RW       ;unbanked is same as 2RW
        dd      bottom_to_top_1RW
        dd      bottom_to_top_1R1W
        dd      bottom_to_top_2RW


; Table of routines for setting up to copy in various directions.

        align   4
SetUpForCopyDirection   label   dword
        dd      left_to_right_top_to_bottom     ;CD_RIGHTDOWN
        dd      right_to_left_top_to_bottom     ;CD_LEFTDOWN
        dd      left_to_right_bottom_to_top     ;CD_RIGHTUP
        dd      right_to_left_bottom_to_top     ;CD_LEFTUP

;-----------------------------------------------------------------------;
; Left edge clip masks for intrabyte start addresses 0 through 7.
; Whole byte cases are flagged as 0ffh.

jLeftMaskTable  label   byte
        db      0ffh,07fh,03fh,01fh,00fh,007h,003h,001h

;-----------------------------------------------------------------------;
; Right edge clip masks for intrabyte end addresses (non-inclusive)
; 0 through 7. Whole byte cases are flagged as 0ffh.

jRightMaskTable label   byte
        db      0ffh,080h,0c0h,0e0h,0f0h,0f8h,0fch,0feh

;-----------------------------------------------------------------------;
; Table of width-based source-edge-to-buffer copy routines.

        align   4
copy_edge_from_screen_to_buffer label   dword
        dd      copy_screen_to_buffered_edge_1ws
        dd      copy_screen_to_buffered_edge_2ws

;-----------------------------------------------------------------------;
; Table of width-based buffer-to-dest-edge copy routines.

        align   4
copy_edge_from_buffer_to_screen label   dword
        dd      copy_buffered_edge_to_screen_1ws
        dd      copy_buffered_edge_to_screen_2ws

;-----------------------------------------------------------------------;
; Table of width-based edge copy routines (no intermediate buffer).

        align   4
copy_edge_table label   dword
        dd      copy_edge_1ws
        dd      copy_edge_2ws

;-----------------------------------------------------------------------;

        .code

_TEXT$04   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;-----------------------------------------------------------------------;

cProc   vNonAlignedSrcCopy,16,<        \
        uses    esi edi ebx,    \
        pdsurf: ptr DEVSURF,    \
        prcldest : ptr RECTL,   \
        pptlsrc : ptr POINTL,   \
        icopydir : dword

        local   culWholeBytesWidth : dword ;# of bytes to copy across each scan
        local   ulBlockHeight : dword   ;# of scans to copy per bank block
        local   ulWholeScanDelta : dword;offset from end of one whole bytes
                                        ; scan to start of next
        local   ulWholeBytesSrc : dword ;offset in bitmap of first source whole
                                        ; byte to copy from
        local   ulWholeBytesDest : dword;offset in bitmap of first source whole
                                        ; byte to copy to
        local   ulLeftEdgeSrc : dword   ;offset in bitmap of first source left
                                        ; edge byte to copy from
        local   ulLeftEdgeDest : dword  ;offset in bitmap of first dest left
                                        ; edge byte to copy to
        local   ulRightEdgeSrc : dword  ;offset in bitmap of first source right
                                        ; edge byte to copy from
        local   ulRightEdgeDest : dword ;offset in bitmap of first dest right
                                        ; edge byte to copy to
        local   ulNextScan : dword      ;width of scan, in bytes
        local   jLeftMask : dword       ;left edge clip mask
        local   jRightMask : dword      ;right edge clip mask
        local   culTempCount : dword    ;handy temporary counter
        local   pTempEntry : dword      ;temporary storage for vector into
                                        ; unrolled loop
        local   pTempPlane : dword      ;pointer to storage in temp buffer for
                                        ; edge bytes (which are stored
                                        ; consecutively, not in each plane's
                                        ; temp buffer, to reduce possible page
                                        ; faulting
        local   ppTempPlane0 : dword    ;pointer to pointer to storage in temp
                                        ; buffer for plane 0, immediately
                                        ; preceded by storage for planes 1, 2,
                                        ; and 3
        local   ppTempPlane3 : dword    ;like above, but for plane 3
        local   ulOffsetInBank : dword  ;offset relative to bank start
        local   pSrcAddr : dword        ;working pointer to first source
                                        ; byte to copy from
        local   pDestAddr : dword       ;working pointer to first dest
                                        ; byte to copy to
        local   ulCurrentJustification:dword ;justification used to map in
                                             ; banks; top for top to bottom
                                             ; copies, bottom for bottom to top
        local   ulCurrentSrcScan :dword ;scan line used to map in current
                                        ; source bank
        local   ulCurrentDestScan:dword ;scan line used to map in current dest
                                        ; bank
        local   ulLastDestScan :dword   ;scan in target rect at which we stop
                                        ; advancing through banks
        local   pCurrentThread : dword  ;pointer to data describing the
                                        ; threaded calls to be performed to
                                        ; perform the current copy
        local   pCurrentThreadViaBuffer:dword
                                        ;pointer to data describing the
                                        ; threaded calls to be performed to
                                        ; perform the current copy in the case
                                        ; where the source and destination are
                                        ; not simultaneously adequately
                                        ; accessible, so the copy has to go
                                        ; through a temp buffer (used only for
                                        ; 1 R/W and 1R/1W banking)
        local   ulAdapterType : dword   ;adapter type code, per VIDEO_BANK_TYPE
        local   ulLWRType : dword       ;whether left edge, whole bytes, and
                                        ; right edge are involved in the
                                        ; current operation;
                                        ; bit 2 = 1 if left edge involved
                                        ; bit 1 = 1 if whole bytes involved
                                        ; bit 0 = 1 if right edge involved
        local   ulLeftEdgeAdjust :dword ;used to bump the whole bytes start
                                        ; address past the left edge when the
                                        ; left edge is partial
        local   ulCombineMask : dword   ;mask for combining desired portions
                                        ; of AL and AH before ORing to make a
                                        ; single byte; used to combine before
                                        ; letting VGA rotate byte as it's
                                        ; written. Used for all cases except
                                        ; whole bytes copied left-to-right
        local   ulCombineMaskWhole : dword
                                        ;mask for combining desired portions of
                                        ; AL and AH when copying whole bytes
                                        ; (different from ulCombineMask in the
                                        ; case of whole bytes left-to-right
                                        ; copies, because then AH is the lsb
                                        ; and AL is the MSB; then, this is
                                        ; ulCombineMask with the bytes swapped.
                                        ; For right-to-left whole byte copies,
                                        ; this is the same as ulCombineMask)
        local   ulTempScanCount : dword ;temp scan line countdown variable
        local   ulWholeScanSrcDelta : dword
                                        ;offset from end of one source whole
                                        ; bytes scan line to start of next.
                                        ; Differs from ulWholeScanDelta because
                                        ; of source rotation pipeline priming
        local   ulLeftSrcWidthMinus1 : dword ;# of bytes in left src edge minus
                                             ; one (0 or 1)
        local   ulRightSrcWidthMinus1 : dword ;# of bytes in right src edge
                                             ; minus one (0 or 1)

;-----------------------------------------------------------------------;

; Set pointers to temp buffer plane pointers (used only by 1 R/W and 1R/1W
; adapters), and other rectangle-independent variables.

        mov     esi,pdsurf
        mov     eax,[esi].dsurf_pvBankBufferPlane0
        mov     pTempPlane,eax
        lea     eax,[esi].dsurf_pvBankBufferPlane0
        mov     ppTempPlane0,eax
        lea     eax,[esi].dsurf_pvBankBufferPlane3
        mov     ppTempPlane3,eax

        mov     eax,[esi].dsurf_vbtBankingType
        mov     ulAdapterType,eax

; Copy the rectangle.

        call    copy_rect

;-----------------------------------------------------------------------;
; Set the VGA registers back to their default state.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax           ;enable bit mask for all bits

        mov     eax,(DR_SET shl 8) + GRAF_DATA_ROT
        out     dx,ax           ;restore default of no rotation

        mov     dl,SEQ_DATA
        mov     al,MM_ALL
        out     dx,al           ;enable writes to all planes

        cld                     ;restore default direction flag

        cRet    vNonAlignedSrcCopy ;done


;***********************************************************************;
;
; Copies the specified rectangle.
;
;***********************************************************************;

copy_rect:

; Calculate the rotation, set up the VGA's rotator, and set the byte-combining
; masks.

        mov     edi,prcldest            ;left edge of destination
        mov     esi,pptlsrc
        mov     ah,byte ptr [edi].xLeft ;left edge of source
        sub     ah,byte ptr [esi].ptl_x
        and     ah,07h                  ;rotation = (dest - source) % 8
        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_DATA_ROT
        out     dx,ax                   ;set the VGA's rotator for the rotation

; Set up byte-combining mask, in preparation for ORing and letting the VGA's
; rotator rotate, assuming the left-hand source byte is in AL and the
; right-hand source byte is in AH (true for all cases except left-to-right
; whole bytes).

        mov     cl,ah
        mov     eax,0000ff00h
        rol     ax,cl
        mov     ulCombineMask,eax

; Calculate source edge widths (1 or 2 bytes).

        sub     edx,edx         ;assume right source width is 1
        mov     ebx,[edi].xLeft
        mov     ecx,[edi].xRight ;dest right edge (non-inclusive)
        dec     ecx             ;make it inclusive
        sub     ecx,ebx         ;dest width = dest right - dest left
        mov     eax,[esi].ptl_x
        add     ecx,eax         ;ECX = right edge of source
        xor     eax,ecx
        and     eax,not 07h     ;do the src start and end differ in byte
                                ; address bits? (as opposed to intrabyte)
        jz      short @F        ;no, force 1-wide source

        mov     al,byte ptr [edi].xLeft
        mov     ah,byte ptr [esi].ptl_x
        and     eax,00000707h
        cmp     ah,al
        jb      short @F
        inc     edx             ;left source width is 2
@@:
        mov     ulLeftSrcWidthMinus1,edx

        sub     edx,edx         ;assume right source width is 1
        mov     eax,[edi].xRight ;dest right edge (non-inclusive)
        dec     eax             ;make it inclusive
        and     cl,07h          ;intrabyte source address
        and     al,07h          ;intrabyte dest address
        cmp     cl,al
        ja      short @F
        inc     edx             ;right source width is 2
@@:
        mov     ulRightSrcWidthMinus1,edx

; Set up masks and whole bytes count, and build left/whole/right index
; indicating which of those parts are involved in the copy.

        mov     ebx,[edi].xRight        ;right edge of fill (non-inclusive)
        mov     ecx,ebx
        and     ecx,0111b               ;intrabyte address of right edge
        mov     ah,jRightMaskTable[ecx] ;right edge mask

        mov     esi,[edi].xLeft         ;left edge of fill (inclusive)
        mov     ecx,esi
        shr     ecx,3                   ;/8 for start offset from left edge
                                        ; of scan line
        sub     ebx,esi                 ;width in pixels of fill

        and     esi,0111b               ;intrabyte address of left edge
        mov     al,jLeftMaskTable[esi]  ;left edge mask

        dec     ebx                     ;make inclusive on right
        add     ebx,esi                 ;inclusive width, starting counting at
                                        ; the beginning of the left edge byte
        shr     ebx,3                   ;width of fill in bytes touched - 1
        jnz     short more_than_1_byte  ;more than 1 byte is involved

; Only one byte will be affected. Combine first/last masks.

        and     al,ah                   ;we'll use first byte mask only
        xor     ah,ah                   ;want last byte mask to be 0 to
                                        ; indicate right edge not involved
        inc     ebx                     ;so there's one count to subtract below
                                        ; if this isn't a whole edge byte
more_than_1_byte:

; If all pixels in the left edge are altered, combine the first byte into the
; whole byte count, because we can handle solid edge bytes faster as part of
; the whole bytes. Ditto for the right edge.

        sub     ecx,ecx                 ;edge whole-status accumulator
        cmp     al,-1                   ;is left edge a whole byte or partial?
        adc     ecx,ecx                 ;ECX=1 if left edge partial, 0 if whole
        sub     ebx,ecx                 ;if left edge partial, deduct it from
                                        ; the whole bytes count
        mov     ulLeftEdgeAdjust,ecx    ;for skipping over the left edge if
                                        ; it's partial when pointing to the
                                        ; whole bytes
        and     ah,ah                   ;is right edge mask 0, meaning this
                                        ; fill is only 1 byte wide?
        jz      short save_masks        ;yes, no need to do anything
        or      ecx,40h                 ;assume there's a partial right edge
        cmp     ah,-1                   ;is right edge a whole byte or partial?
        jnz     short save_masks        ;partial
                                        ;bit 1=0 if left edge partial, 1 whole
        inc     ebx                     ;if right edge whole, include it in the
                                        ; whole bytes count
        and     ecx,not 40h             ;there's no partial right edge
save_masks:
        cmp     ebx,1                   ;do we have any whole bytes?
        cmc                             ;CF set if whole byte count > 0
        adc     ecx,ecx                 ;if any whole bytes, set whole bytes
                                        ; bit in left/whole/right accumulator
        rol     cl,1                    ;align the left/whole/right bits
        mov     ulLWRType,ecx           ;save left/whole/right status

        mov     byte ptr jLeftMask,al   ;save left and right clip masks
        mov     byte ptr jRightMask,ah
        mov     culWholeBytesWidth,ebx  ;save # of whole bytes

; Copy the rectangle in the specified direction.

        mov     eax,icopydir
        jmp     SetUpForCopyDirection[eax*4]


;***********************************************************************;
;
; The following routines set up to handle the four possible copy
; directions.
;
;***********************************************************************;


;-----------------------------------------------------------------------;
; Set-up code for left-to-right, top-to-bottom copies.
;-----------------------------------------------------------------------;

left_to_right_top_to_bottom::

        cld                             ;we'll copy left to right

; Byte-combining mask, in preparation for ORing and letting the VGA's rotator
; rotate, assuming the left-hand source byte is in AH and the right-hand source
; byte is in AL (true only for left-to-right whole bytes).

        mov     eax,ulCombineMask
        not     eax
        mov     ulCombineMaskWhole,eax

        mov     esi,pdsurf
        mov     eax,[esi].dsurf_lNextScan
        mov     ulNextScan,eax          ;copy top to bottom
        sub     eax,culWholeBytesWidth  ;offset from end of one dest whole byte
        mov     ulWholeScanDelta,eax    ; scan to start of next
        dec     eax                     ;offset from end of one src whole byte
        mov     ulWholeScanSrcDelta,eax ; scan to start of next, accounting for
                                        ; leading byte used to prime the
                                        ; rotation pipeline

        mov     esi,ulLWRType           ;3-bit flag field for left, whole, and
                                        ; right involvement in operation
        or      esi,LEFT_TO_RIGHT_FIELD_SET   ;add left-to-right into the index
        mov     eax,MasterThreadTable[esi*4]
        mov     pCurrentThread,eax      ;threading when no buffering is needed
        mov     edx,ulAdapterType
        shl     edx,ADAPTER_FIELD_SHIFT
        or      esi,edx                 ;factor adapter type into the index
        mov     eax,MasterThreadTableViaBuffer[esi*4]
        mov     pCurrentThreadViaBuffer,eax ;threading when buffering is needed

        mov     ulCurrentJustification,JustifyTop ;copy top to bottom

        mov     esi,prcldest
        mov     eax,[esi].yBottom
        mov     ulLastDestScan,eax      ;end at bottom of dest copy rect
        mov     eax,[esi].yTop
        mov     ulCurrentDestScan,eax   ;start at top of dest copy rect
        mul     ulNextScan              ;offset in bitmap of top dest rect scan
        mov     edx,[esi].xLeft
        shr     edx,3                   ;byte X address
        add     eax,edx                 ;offset in bitmap of first dest byte
        mov     ulLeftEdgeDest,eax      ;that's where the left dest edge is
        add     eax,ulLeftEdgeAdjust    ;the whole bytes start at the next
                                        ; byte, unless the left edge is a whole
                                        ; byte and is thus part of the whole
                                        ; bytes already
        mov     ulWholeBytesDest,eax    ;where the whole dest bytes start
        add     eax,culWholeBytesWidth  ;point to the right edge
        mov     ulRightEdgeDest,eax     ;where the right dest edge starts

        mov     esi,pptlsrc
        mov     eax,[esi].ptl_y
        mov     ulCurrentSrcScan,eax    ;start at top of source copy rect
        mul     ulNextScan              ;offset in bitmap of top dest rect scan
        mov     edx,[esi].ptl_x
        shr     edx,3                   ;byte X address
        add     eax,edx                 ;offset in bitmap of first source byte
        mov     ulLeftEdgeSrc,eax       ;that's where the left src edge is
        add     eax,ulLeftSrcWidthMinus1 ;the first whole byte includes the
        dec     eax                      ; last (leftmost) left edge byte, so
        add     eax,ulLeftEdgeAdjust     ; add a byte if the left edge is 2
                                         ; wide, except when the left dest byte
                                         ; is solid so the left edge is part of
                                         ; the whole bytes
        mov     ulWholeBytesSrc,eax     ;where the src whole bytes start
        add     eax,culWholeBytesWidth  ;point to the right edge
        mov     ulRightEdgeSrc,eax      ;where the right src edge starts,
                                        ; because the whole bytes and the right
                                        ; source edge share a byte, and we
                                        ; always point to the leftmost byte in
                                        ; the right source edge

; Branch to the appropriate top-to-bottom bank enumeration loop.

        mov     eax,ulAdapterType
        jmp     TopToBottomLoopTable[eax*4]


;-----------------------------------------------------------------------;
; Set-up code for right-to-left, top-to-bottom copies.
;-----------------------------------------------------------------------;

right_to_left_top_to_bottom::

        std                             ;we'll copy right to left

; Byte-combining mask, in preparation for ORing and letting the VGA's rotator
; rotate, assuming the left-hand source byte is in AL and the right-hand source
; byte is in AH (always true except for left-to-right whole bytes).

        mov     eax,ulCombineMask
        mov     ulCombineMaskWhole,eax

        mov     esi,pdsurf
        mov     eax,[esi].dsurf_lNextScan
        mov     ulNextScan,eax          ;copy top to bottom
        add     eax,culWholeBytesWidth  ;offset from end of one whole byte scan
        mov     ulWholeScanDelta,eax    ; to start of next, given that we're
                                        ; copying one way and going scan-to-
                                        ; scan the other way
        inc     eax                     ;offset from end of one src whole byte
        mov     ulWholeScanSrcDelta,eax ; scan to start of next, accounting for
                                        ; leading byte used to prime the
                                        ; rotation pipeline

        mov     esi,ulLWRType           ;3-bit flag field for left, whole, and
                                        ; right involvement in operation
                                        ;leave left-to-right field cleared, so
                                        ; we look up right-to-left entries
        mov     eax,MasterThreadTable[esi*4]
        mov     pCurrentThread,eax      ;threading when no buffering is needed
        mov     edx,ulAdapterType
        shl     edx,ADAPTER_FIELD_SHIFT
        or      esi,edx                 ;factor adapter type into the index
        mov     eax,MasterThreadTableViaBuffer[esi*4]
        mov     pCurrentThreadViaBuffer,eax ;threading when buffering is needed

        mov     ulCurrentJustification,JustifyTop ;copy top to bottom

        mov     esi,prcldest
        mov     eax,[esi].yBottom
        mov     ulLastDestScan,eax      ;end at bottom of dest copy rect
        mov     eax,[esi].yTop
        mov     ulCurrentDestScan,eax   ;start at top of dest copy rect
        mul     ulNextScan              ;offset in bitmap of top dest rect scan
        mov     edx,[esi].xLeft
        shr     edx,3                   ;byte X address
        add     eax,edx                 ;offset in bitmap of first dest byte
        mov     ulLeftEdgeDest,eax      ;that's where the left dest edge is
        add     eax,ulLeftEdgeAdjust    ;the whole bytes start at the next
                                        ; byte, unless the left edge is a whole
                                        ; byte and is thus part of the whole
                                        ; bytes already
        add     eax,culWholeBytesWidth  ;point to the right edge
        mov     ulRightEdgeDest,eax     ;where the right dest edge starts
        dec     eax                     ;back up to the last whole byte
        mov     ulWholeBytesDest,eax    ;where the whole dest bytes start

        mov     esi,pptlsrc
        mov     eax,[esi].ptl_y
        mov     ulCurrentSrcScan,eax    ;start at top of source copy rect
        mul     ulNextScan              ;offset in bitmap of top dest rect scan
        mov     edx,[esi].ptl_x
        shr     edx,3                   ;byte X address
        add     eax,edx                 ;offset in bitmap of first source byte
        mov     ulLeftEdgeSrc,eax       ;that's where the left src edge is
        add     eax,ulLeftSrcWidthMinus1 ;the first whole byte includes the
        dec     eax                      ; last (leftmost) left edge byte, so
        add     eax,ulLeftEdgeAdjust     ; add a byte if the left edge is 2
                                         ; wide, except when the left dest byte
                                         ; is solid so the left edge is part of
                                         ; the whole bytes
        add     eax,culWholeBytesWidth  ;point to the right edge of the whole
                                        ; src bytes, accounting for the extra
                                        ; source byte needed to prime the
                                        ; rotation pipeline
        mov     ulWholeBytesSrc,eax     ;where the src whole bytes start
        mov     ulRightEdgeSrc,eax      ;that's also where the right src edge
                                        ; starts, because the whole bytes and
                                        ; the right source edge share a byte,
                                        ; and we always point to the leftmost
                                        ; byte in the right source edge

; Branch to the appropriate top-to-bottom bank enumeration loop.

        mov     eax,ulAdapterType
        jmp     TopToBottomLoopTable[eax*4]


;-----------------------------------------------------------------------;
; Set-up code for left-to-right, bottom-to-top copies.
;-----------------------------------------------------------------------;

left_to_right_bottom_to_top::

        cld                             ;we'll copy left to right

; Byte-combining mask, in preparation for ORing and letting the VGA's rotator
; rotate, assuming the left-hand source byte is in AH and the right-hand source
; byte is in AL (true only for left-to-right whole bytes).

        mov     eax,ulCombineMask
        not     eax
        mov     ulCombineMaskWhole,eax

        mov     edi,pdsurf
        mov     eax,[edi].dsurf_lNextScan
        neg     eax
        mov     ulNextScan,eax          ;copy bottom to top
        sub     eax,culWholeBytesWidth  ;offset from end of one whole byte scan
        mov     ulWholeScanDelta,eax    ; to start of next, given that we're
                                        ; copying one way and going scan-to-
                                        ; scan the other way
        dec     eax                     ;offset from end of one src whole byte
        mov     ulWholeScanSrcDelta,eax ; scan to start of next, accounting for
                                        ; leading byte used to prime the
                                        ; rotation pipeline

        mov     esi,ulLWRType           ;3-bit flag field for left, whole, and
                                        ; right involvement in operation
        or      esi,LEFT_TO_RIGHT_FIELD_SET   ;add left-to-right into the index
        mov     eax,MasterThreadTable[esi*4]
        mov     pCurrentThread,eax      ;threading when no buffering is needed
        mov     edx,ulAdapterType
        shl     edx,ADAPTER_FIELD_SHIFT
        or      esi,edx                 ;factor adapter type into the index
        mov     eax,MasterThreadTableViaBuffer[esi*4]
        mov     pCurrentThreadViaBuffer,eax ;threading when buffering is needed

        mov     ulCurrentJustification,JustifyBottom ;copy bottom to top

        mov     esi,prcldest
        mov     edx,[esi].yTop
        mov     ulLastDestScan,edx      ;end at top of dest copy rect
        mov   