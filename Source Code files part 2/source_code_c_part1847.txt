T CBaseSAPI::GetRecoContext()
{
    if( g_cpEngine == NULL )
        return E_FAIL;

    HRESULT hr=S_OK;

    if( m_cpRecoCtxt )
        return S_OK;
        // return m_cpRecoCtxt;

#if 0
    // get the FORM node - we add information here.
    IBaseXMLNode * pForm;
    DetachParent(&pForm);
    BOOL bFound=FALSE;
    do
    {
        if( SUCCEEDED( hr=pForm->DetachParent( &pForm )))
        {
            bFound=SUCCEEDED(pForm->IsType( TEXT("FORM" )));
        }
    } while( (bFound== FALSE) && pForm );

    if(pForm == NULL )
        return E_FAIL;

    LPWSTR pszType;
    pForm->get_StringType(&pszType);
    //
    // BUGBUG - this is VERY bad.
    // add a VT_VARIANT property mechanism for containers.
    //
#endif
    BOOL bGot=FALSE;

#ifdef _ONE_CONTEXT
    // We do this ONLY ONCE per dialog.
    LPWSTR pszContext;
    if( SUCCEEDED( pForm->get_Attr( TEXT("SAPI:CONTEXT"), &pszContext )))
    {
        ISpRecoContext *pContext=(ISpRecoContext *)StringToIntDef( pszContext, 0 );
        if( pContext )
        {
            m_cpRecoCtxt=pContext;
            bGot=TRUE;
        }
    }
#endif

    if( bGot == FALSE )
    {
        if( SUCCEEDED( hr=g_cpEngine->CreateRecoContext( &m_cpRecoCtxt.p ) ))
        {
            // REVIEW - BIG BIG HACK!
            TCHAR szNumString[128];
            wsprintf( szNumString, TEXT("%d"), m_cpRecoCtxt );
            // pForm->put_Attr( TEXT("SAPI:CONTEXT"), szNumString);
            // end hack.
            if( SUCCEEDED(hr = m_cpRecoCtxt->SetNotifySink( this )))   // This add ref's US.
            {
	            // Tell SR what types of events interest us.  Here we only care about command
                // recognition.
                const ULONGLONG ullInterest = 
                               // SPFEI(SPEI_SOUND_START) | SPFEI(SPEI_SOUND_END) |
                               // SPFEI(SPEI_PHRASE_START) | 
                               SPFEI(SPEI_RECOGNITION) |
                               SPFEI(SPEI_FALSE_RECOGNITION) |
                               SPFEI(SPEI_HYPOTHESIS) |
                              // SPFEI(SPEI_INTERFERENCE) |
                              // SPFEI(SPEI_REQUEST_UI) | SPFEI(SPEI_RECO_STATE_CHANGE) |
                              // SPFEI(SPEI_PROPERTY_NUM_CHANGE) | SPFEI(SPEI_PROPERTY_STRING_CHANGE)
                              0;
                hr = m_cpRecoCtxt->SetInterest(ullInterest, ullInterest);
            }
        }
    }
    return hr;
}

//
// Called for ALL RULES (as we only have one context)
//
HRESULT STDMETHODCALLTYPE CBaseSAPI::Notify( void)
{ 
#ifndef _ONE_CONTEXT
    // work out which rule caused this thing to fire.
    CSpEvent event;

    if (m_cpRecoCtxt)
    {
        while (event.GetFrom(m_cpRecoCtxt) == S_OK)
        {
            switch (event.eEventId)
            {
            case SPEI_HYPOTHESIS:
            break;

				case SPEI_RECOGNITION:
                    {
                        ISpRecoResult * pResult = event.RecoResult();
                        {
                            CBaseSAPI * pBase;
                            if( SUCCEEDED( pResult->GetGrammarId((ULONG*)&pBase)))
                            {
                                ISpPhrase * pPhrase = event.RecoResult();
                                pBase->ExecuteCommand(pPhrase);
                            }
                        }
                    }
					break;
                case SPEI_INTERFERENCE:
                    {
                        // g_Notifications.SetText(L"I can't quite hear you");
                    }
                    break;
                case SPEI_FALSE_RECOGNITION:
                    {
                        // g_Notifications.SetText(L"I mis-understood you");
                    }
                    break;
			}
		}
	}
#else
    Callback(); 
#endif
    return S_OK; 
}

BOOL CBaseSAPI::NeedsTip()
{
    LPWSTR pszTip;
    if( SUCCEEDED( get_Attr(L"TOOLTIP", &pszTip )))
        return FALSE;
    return TRUE;
}

void CBaseSAPI::LoadDictation()
{
    HRESULT hr;
    if( SUCCEEDED( hr = GetRecoContext() ))
    {
        // we use the 'shared' context here.
        // if( SUCCEEDED( hr = m_cpRecoCtxt->CreateGrammar( (DWORD)this, &m_cpDictationGrammar) ))
        m_cpDictationGrammar = m_cpCmdGrammar;
        {
            hr = m_cpDictationGrammar->LoadDictation(NULL, SPLO_STATIC);
            if ( SUCCEEDED( hr ) )
            {
                m_cpDictationGrammar->SetDictationState(SPRS_INACTIVE); // SPRS_INACTIVE);
            }
        }
    }
    // return hr;
}

void CBaseSAPI::LoadNumberGrammar(LPCWSTR pszFile)
{
    // load a specific grammar.
    if( pszFile == NULL )
        pszFile = L"c:\\cicerorcml\\numbers.xml";

    HRESULT hr;
    if( SUCCEEDED( hr = GetRecoContext() ))
    {
        // we use the 'shared' context here.
        if( SUCCEEDED( hr = m_cpRecoCtxt->CreateGrammar( (DWORD)this, &m_cpNumberGrammar) ))
        {
            if( SUCCEEDED( hr = m_cpNumberGrammar->LoadCmdFromFile( pszFile, SPLO_STATIC ) ))  // is TRUE needed?
            {
                m_cpNumberGrammar->SetRuleState(
                NULL, 
                NULL, 
                SPRS_ACTIVE);
            }
        }
    }

}

BOOL CBaseSAPI::GetVoice()
{
    if( g_cpVoice )
        return TRUE;

  	if( SUCCEEDED( g_cpVoice.CoCreateInstance( CLSID_SpVoice ) ))
	{
        return TRUE;
	}
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\applaunch\basesapi.h ===
// BaseSAPI.h: interface for the CBaseSAPI class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BASESAPI_H__24A1B8CC_6860_4311_92E6_CE5397D11661__INCLUDED_)
#define AFX_BASESAPI_H__24A1B8CC_6860_4311_92E6_CE5397D11661__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "appservices.h"
#include <sphelper.h>

#include "list.h"

// #define _WITH_DICTATION
// #define _ONE_CONTEXT

class CBaseSAPI  : public CAppServices, public ISpNotifySink
{
public:
	void LoadNumberGrammar( LPCWSTR pszFile=NULL );
    void LoadDictation();

	CBaseSAPI();
	virtual ~CBaseSAPI();
    typedef CAppServices BASECLASS;

    HRESULT InitSAPI( void );
    void ResetGrammar( void );
    void ProcessRecoEvent( void );

	// IBaseXMLNode methods Children.
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
            IBaseXMLNode __RPC_FAR *pChild);

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExitNode( 
        IBaseXMLNode __RPC_FAR *parent, LONG lDialogResult);

    //
    // Sit on the set to check for us being disabled
    //
    virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Attr( 
        LPCWSTR index,
        /* [in] */ LPCWSTR newVal)
    {
        if( lstrcmpi( index, L"ENABLED")==0)
        {
            if( lstrcmpi( newVal, L"NO") == 0 )
                SetRuleState(FALSE);
            else if( lstrcmpi( newVal, L"YES") == 0 )
                SetRuleState(TRUE);
        }
        return BASECLASS::put_Attr(index, newVal);
    }

    //
    // ISpNotifySink method
    //
    virtual HRESULT STDMETHODCALLTYPE Notify( void) ;
    virtual HRESULT ExecuteCommand( ISpPhrase *pPhrase )=0;

    //
    // I unknown goo
    //
    virtual ULONG STDMETHODCALLTYPE AddRef( void)
    { return BASECLASS::AddRef(); }

    virtual ULONG STDMETHODCALLTYPE Release( void)
    { return BASECLASS::Release(); }

    // 2 interfaces only, ISpNotifySink and IBaseXMLNode 
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppvObject) 
    {   if (riid == IID_IUnknown) 
            *ppvObject = static_cast<IUnknown*>((ISpNotifySink*)this);  
        else if (riid == __uuidof(IBaseXMLNode))           
            *ppvObject = static_cast<IBaseXMLNode*>(this); 
        else if (riid == __uuidof(ISpNotifySink))           
            *ppvObject = static_cast<ISpNotifySink*>(this); 
        else 
        {
            *ppvObject = NULL; return E_NOINTERFACE; 
        }
        reinterpret_cast<IUnknown*>(*ppvObject)->AddRef(); 
        return S_OK; 
    }

	void SayFailure();
	void SaySuccess();

	HRESULT LoadCFG( LPCTSTR pszFileName  );
    HRESULT SetRuleState(BOOL bOnOff);

protected:
	BOOL NeedsTip();
	HRESULT GetRecoContext();
	BOOL IsEnabled(HWND hWnd);
	LPWSTR GetRecognizedRule( ISpPhrase * pPhrase );

    BOOL    GetVoice();
    static CComPtr<ISpVoice>               g_cpVoice;

	LPWSTR GetRecognizedText(ISpPhrase *pPhrase);
	LPWSTR FindNiceText(LPCWSTR text);
	CComPtr<IBaseXMLNode>		m_cpFailure;
	CComPtr<IBaseXMLNode>		m_cpSuccess;

	// just one Engine.
	static CComPtr<ISpRecognizer>		g_cpEngine;				// Pointer to reco engine interface

    // REVIEW - try to get only one Context per dialog
    CComPtr<ISpRecoContext>         m_cpRecoCtxt;			// Pointer to reco context interface

    // Currently we have one grammar per context, which is expensive.
    CComPtr<ISpRecoGrammar>         m_cpCmdGrammar;			// Pointer to grammar interface
    CComPtr<ISpRecoGrammar>         m_cpNumberGrammar;
    CComPtr<ISpRecoGrammar>         m_cpDictationGrammar;

	BOOL	m_bActive;
	static	LONG	m_bInited;

    virtual void Callback() {}; // calls ExecuteCommand on derived classes

	virtual BOOL SetControlText( LPCWSTR dstrText );

    HRESULT LoadCFGFromString( LPCTSTR pszCFG, LPCTSTR prefix=NULL );

};

#endif // !defined(AFX_BASESAPI_H__24A1B8CC_6860_4311_92E6_CE5397D11661__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\applaunch\applaunch.cpp ===
// AppLaunch.cpp : Defines the entry point for the application.
//

//
// First pass creates RULE nodes for every
// REQUIRED and OPTIONAL element
// for the top level (first child) nodes, they will 
// also contain their children, and use RULEREF to get to their insides
//


#include "stdafx.h"
#include "cmdline.h"
#include "filestream.h"

#include "dumptocfg.h"
#include "sapilaunch.h"
#include "resource.h"

HINSTANCE g_hInstance;

typedef struct _TAGCMDLINE
{
    LPTSTR  pszOutputdir;
    LPTSTR  pszInFilename;
    LPTSTR  pszOutFilename;
    BOOL    bAutoExit;
    BOOL    bHelpOnly;
    BOOL    bCreate;        // are we generating a file, or using a file
} CMDLINE, * PCMDLINE;

void        ProcessAppLaunch(PCMDLINE cmd);
HRESULT     CreateCFG(PCMDLINE cmd, IBaseXMLNode * pHead);

int APIENTRY wWinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPTSTR     lpCmdLine,
                     int       nCmdShow)
{
 	// TODO: Place code here.

    //
    // Parse command line.
    //
    g_hInstance=hInstance;
    LPTSTR pszNothing=NULL;
    CMDLINE cmd={NULL};
    cmd.bAutoExit=FALSE;
	BOOL	bHelpOnly=FALSE;
    cmd.pszOutFilename = new TCHAR[MAX_PATH];
    lstrcpy(cmd.pszOutFilename, TEXT("sample.xml") );
    if(*lpCmdLine)
    {
        CMDLINE_BEGIN( lpCmdLine, &cmd.pszInFilename, &pszNothing, TRUE )

            CMDLINE_TEXTARG( "-output", &cmd.pszOutputdir )
            CMDLINE_TEXTARG( "-o", &cmd.pszOutputdir )

            CMDLINE_TEXTARG( "-filename", &cmd.pszInFilename )
            CMDLINE_TEXTARG( "-f", &cmd.pszInFilename )

            CMDLINE_TEXTARG( "-outfilename", &cmd.pszOutFilename )
            CMDLINE_TEXTARG( "-of", &cmd.pszOutFilename )

            CMDLINE_SWITCH( "-autoexit", &cmd.bAutoExit )
            CMDLINE_SWITCH( "-x", &cmd.bAutoExit )

            CMDLINE_SWITCH( "-help", &bHelpOnly )
            CMDLINE_SWITCH( "-?", &bHelpOnly )
        CMDLINE_END()
    }
    else
    {
        // no command line, defaults go here.
    }

    if( cmd.bHelpOnly )
    {
        return 0;
    }

    if( cmd.pszInFilename )
    {
        ProcessAppLaunch(&cmd);
    }

    // cleanup the cmdline
    delete cmd.pszInFilename;
    delete cmd.pszOutFilename;
    delete cmd.pszOutputdir;

	return 0;
}


BOOL CALLBACK ListeningDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    if(uMessage==WM_COMMAND)
    {
        int iControl=LOWORD(wParam);
        if( HIWORD(wParam)==0 )
        {
            switch( iControl )
            {
            case IDOK:
            case IDCANCEL:
                EndDialog( hDlg, iControl);
                break;
            }
        }
    }

    if( uMessage==WM_SETTEXT )
    {
        SHELLEXECUTEINFOW sei = {0};

        sei.cbSize = sizeof(sei);
        sei.lpFile = (LPTSTR)lParam;
        sei.nShow  = SW_SHOWNORMAL;

        ShellExecuteEx(&sei);
        return TRUE;
    }

    if(uMessage==WM_INITDIALOG)
    {
        return TRUE;
    }
    return FALSE;
}


//
// Creates the file
// then listens on it.
//
void ProcessAppLaunch( PCMDLINE pArgs)
{
    //
    // This loads and builds the tree
    //
    CSimpleXMLLoader loader;
	FileStream * stream=new FileStream();
    HRESULT hr=E_FAIL;
	if( stream->open(pArgs->pszInFilename) )
	{
        XMLParser xmlParser;
        xmlParser.SetFactory(&loader);
        xmlParser.SetInput(stream);
        hr=xmlParser.Run(-1);
    }
    stream->Release();

    if( SUCCEEDED( hr ))
    {
        IBaseXMLNode * pHead = loader.GetHeadElement();
        if( pHead )
        {
            if( SUCCEEDED(CreateCFG(pArgs, pHead)) )
            {
                //
                //
                //
                CSapiLaunch Listen( pHead );
                Listen.AddRef();
                if( SUCCEEDED( Listen.LoadCFG( pArgs->pszOutFilename ) ))
                {
                    HWND hDlg = CreateDialogParam( g_hInstance, MAKEINTRESOURCE(IDD_LISTENING), GetDesktopWindow(), ListeningDlgProc, (LPARAM)NULL );
                    ShowWindow(hDlg, SW_NORMAL );

                    Listen.LoadDictation();

                    Listen.SetRuleState(TRUE);
                    Listen.SetWindow( hDlg );

	                MSG msg;
	                while (GetMessage(&msg, NULL, 0, 0) )
	                {
                        if( IsDialogMessage( hDlg, &msg ) == FALSE )
			                DispatchMessage(&msg);

                        if(msg.hwnd == hDlg)
                        {
                            if( msg.message == WM_NULL)
                                break;
                        }
	                }
                }
            }
        }
    }
}

HRESULT CreateCFG(PCMDLINE pArgs, IBaseXMLNode * pHead)
{
    HRESULT hr=S_OK;

    //
    // This walks the tree.
    //
    if( SUCCEEDED( pHead->IsType( L"Launch" )))
    {
        CXMLLaunch * pLaunch = (CXMLLaunch*)pHead;

        CNodeList * pNodeList = pLaunch->GetNodeList();

        CDumpToCfg dump;

        dump.AppendText(TEXT("<GRAMMAR>\r\n"));
        dump.DumpNodes(pNodeList);

        dump.AppendText( dump.m_Rules->pszString );
        dump.AppendText( TEXT("</GRAMMAR>"));

        HANDLE hf;
        if( (hf = CreateFile( 
            pArgs->pszOutFilename,
			GENERIC_WRITE,
			FILE_SHARE_READ,
			NULL,
			CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			NULL) )
            != INVALID_HANDLE_VALUE )
        {
            DWORD dwWrote;
            PSTRINGBUFFER pBuffer = dump.m_RuleBuffer;
            WriteFile( hf , pBuffer->pszString, pBuffer->used*2, &dwWrote, NULL );

            CloseHandle( hf );
        }
    }
    return hr;
}


PSTRINGBUFFER AppendText(PSTRINGBUFFER buffer, LPTSTR pszText)
{
    PSTRINGBUFFER pResult=buffer;
    if(buffer==NULL)
    {
        pResult=new STRINGBUFFER;
        pResult->size=512;
        pResult->pszString = new TCHAR[pResult->size];
        pResult->pszStringEnd = pResult->pszString;
        pResult->used = 0;
    }

    if(pszText)
    {
        UINT cbNewText=lstrlen(pszText);
        // Make sure we the space
        if( pResult->size < pResult->used + cbNewText + 4 )
        {
            LPTSTR pszNewBuffer=new TCHAR[pResult->size * 2];
            CopyMemory( pszNewBuffer, pResult->pszString, pResult->size * sizeof(TCHAR) );
            delete pResult->pszString;
            pResult->pszString = pszNewBuffer;
            pResult->size*=2;
            pResult->pszStringEnd = (pResult->pszString)+pResult->used;
        }
        // append the string.
        CopyMemory( pResult->pszStringEnd, pszText, cbNewText*sizeof(TCHAR));
        pResult->used +=cbNewText;
        pResult->pszStringEnd = (pResult->pszString)+pResult->used;
        *(pResult->pszStringEnd)=NULL;
    }
    else
    {
        delete pResult->pszString;
        delete pResult;
        pResult=NULL;
    }
    return pResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\applaunch\debug.cpp ===
//
//
//

#include "stdafx.h"
#include "debug.h"

#ifdef _DEBUG
void FAR _cdecl 
TRACE(
	LPTSTR lpszFormat, 
	...) 
{
	TCHAR szBuf[1024];
	int	cchAdd;

	cchAdd = wvsprintf((LPTSTR)szBuf, lpszFormat, (LPSTR)(&lpszFormat + 1));
	OutputDebugString((LPCTSTR)szBuf);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\applaunch\debug.h ===
//
//
//

#ifdef _DEBUG
void FAR _cdecl 
TRACE(
	LPTSTR lpszFormat, 
	...);

#else
#define TRACE 0?0:
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\applaunch\appservices.h ===
#ifndef __APPSERVICES_H
#define __APPSERVICES_H

#include "xmlloader.h"      // The helper classes for XMLLoader

#include "basenode.h"        // interface for the nodes themselves

typedef _RefcountList<IBaseXMLNode>        CXMLNodeList;       // calls release on the elements.

#define NEWNODE(name) static IBaseXMLNode * newXML##name() { return new CXML##name; }
#define XMLNODE(name, function) { name, CXML##function::newXML##function }

class CAppServices : public _simpleunknown<IBaseXMLNode>, public CStringPropertySection
{
public:
    CAppServices() { m_StringType=L"Uninitialized"; }
    virtual ~CAppServices() {};

    STDMETHOD(DetachParent)(IBaseXMLNode **pVal)
    { 
        *pVal = m_pParent;
        if( m_pParent==NULL )
            return E_FAIL;
        return S_OK;
    }

    virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE AttachParent( 
        /* [in] */ IBaseXMLNode __RPC_FAR *newVal)
    {
        m_pParent=newVal;
        return S_OK;
    }

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IBaseXMLNode __RPC_FAR *pChild)
    {
        LPWSTR pType;
        LPWSTR pChildType;
        get_StringType( &pType );
        pChild->get_StringType( &pChildType );

        //
        // you should actually implement this
        // for now we'll just add these children to the Unknown list of children.
        //
        m_UnknownChildren.Append( pChild );
        return S_OK;
    }
        
    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoEndChild( 
        IBaseXMLNode __RPC_FAR *child)
    {
        return S_OK;
    }
    
    virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
        /* [retval][out] */ UINT __RPC_FAR *pVal)
    {
        *pVal = NODETYPE;
        return S_OK;
    }
    
    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitNode( 
        IBaseXMLNode __RPC_FAR *parent)
    {
        return S_OK;
    }
    
    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DisplayNode( 
        IBaseXMLNode __RPC_FAR *parent)
    {
        return S_OK;
    }
    
    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExitNode( 
        IBaseXMLNode __RPC_FAR *parent, LONG lDialogResult)
    {
        return S_OK;
    }
    
    virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Attr( 
        LPCWSTR index,
        /* [retval][out] */ LPWSTR __RPC_FAR *pVal)
    {
        *pVal = (LPWSTR)CStringPropertySection::Get(index);
        if( *pVal )
            return S_OK;
        return E_INVALIDARG;    // HMM, we don't have this attribute, but is it failure?
    }
    
    virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Attr( 
        LPCWSTR index,
        /* [in] */ LPCWSTR newVal)
    {
        CStringPropertySection::Set(index, newVal);
        return S_OK;
    }
    
    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsType( 
        LPCWSTR nodeName)
    {
        if( lstrcmpi(nodeName, m_StringType) == 0 )
            return S_OK;
        return E_FAIL;  // OK, so it's not really a failure REVIEW!
    }
    
    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE YesDefault( 
        /* [in] */ LPCWSTR propID,
        /* [in] */ DWORD dwNotPresent,
        /* [in] */ DWORD dwYes,
        /* [retval][out] */ DWORD __RPC_FAR *pdwValue)
    {
        *pdwValue = CStringPropertySection::YesNo(propID, dwNotPresent, dwYes);
        return S_OK;
    }
    
    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE YesNoDefault( 
        /* [in] */ LPCWSTR propID,
        /* [in] */ DWORD dwNotPresent,
        /* [in] */ DWORD dwNo,
        /* [in] */ DWORD dwYes,
        /* [retval][out] */ DWORD __RPC_FAR *pdwValue)
    {
        *pdwValue = CStringPropertySection::YesNo(propID, dwNotPresent, dwNo, dwYes);
        return S_OK;
    }
    
    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ValueOf( 
        /* [in] */ LPCWSTR propID,
        /* [in] */ DWORD dwNotPresent,
        /* [retval][out] */ DWORD __RPC_FAR *pdwValue)
    {
        *pdwValue = CStringPropertySection::ValueOf(propID, dwNotPresent);
        return S_OK;
    }

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SignedValueOf( 
        /* [in] */ LPCWSTR propID,
        /* [in] */ int dwNotPresent,
        /* [retval][out] */ int __RPC_FAR *pdwValue)
    {
        *pdwValue = CStringPropertySection::ValueOf(propID, dwNotPresent);
        return S_OK;
    }

    virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StringType( 
        /* [retval][out] */ LPWSTR __RPC_FAR *pStringType)
    {
        *pStringType = (LPWSTR)m_StringType;
        return S_OK;
    }

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChildEnum( 
        IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum) { return E_NOTIMPL; }

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUnknownEnum( 
        IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum)
    {
        if( pEnum )
        {
            *pEnum = new CEnumControls<CXMLNodeList>(m_UnknownChildren);
            (*pEnum)->AddRef();
            return S_OK;
        }
        return E_FAIL;
    }

protected:
    int NODETYPE;
    LPWSTR  m_StringType;

private:
    IBaseXMLNode * m_pParent;
    CStringPropertySection m_PS;

   	CXMLNodeList	  m_UnknownChildren;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\applaunch\basetsd.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    basetsd.h

Abstract:

    Type definitions for the basic sized types.

Author:

    Jeff Havens (jhavens)   23-Oct-1997

Revision History:

--*/

#ifndef _BASETSD_H_
#define _BASETSD_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// The following types are guaranteed to be signed and 32 bits wide.
//

typedef int LONG32, *PLONG32;
typedef int INT32, *PINT32;

//
// The following types are guaranteed to be unsigned and 32 bits wide.
//

typedef unsigned int ULONG32, *PULONG32;
typedef unsigned int DWORD32, *PDWORD32;
typedef unsigned int UINT32, *PUINT32;

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

//
// The INT_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. UINT_PTR is
// the unsigned variation.
//
// __int3264 is intrinsic to 64b MIDL but not to old MIDL or to C compiler.
//
#if ( 501 < __midl )

    typedef [public] __int3264 INT_PTR, *PINT_PTR;
    typedef [public] unsigned __int3264 UINT_PTR, *PUINT_PTR;

    typedef [public] __int3264 LONG_PTR, *PLONG_PTR;
    typedef [public] unsigned __int3264 ULONG_PTR, *PULONG_PTR;

#else  // midl64
// old midl and C++ compiler

#if defined(_WIN64)
    typedef __int64 INT_PTR, *PINT_PTR;
    typedef unsigned __int64 UINT_PTR, *PUINT_PTR;

    typedef __int64 LONG_PTR, *PLONG_PTR;
    typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;

    #define __int3264   __int64

#else
    typedef _W64 int INT_PTR, *PINT_PTR;
    typedef _W64 unsigned int UINT_PTR, *PUINT_PTR;

    typedef _W64 long LONG_PTR, *PLONG_PTR;
    typedef _W64 unsigned long ULONG_PTR, *PULONG_PTR;

    #define __int3264   __int32

#endif
#endif // midl64

//
// HALF_PTR is half the size of a pointer it intended for use with
// within strcuture which contain a pointer and two small fields.
// UHALF_PTR is the unsigned variation.
//

#ifdef _WIN64

#define ADDRESS_TAG_BIT 0x40000000000UI64

typedef unsigned __int64 HANDLE_PTR;
typedef unsigned int UHALF_PTR, *PUHALF_PTR;
typedef int HALF_PTR, *PHALF_PTR;

#pragma warning(disable:4311)   // type cast truncation
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4305)   // type cast truncation

#if !defined(__midl)
__inline
unsigned long
HandleToUlong(
    const void *h
    )
{
    return((unsigned long) h );
}

__inline
long
HandleToLong(
    const void *h
    )
{
    return((long) h );
}

__inline
void *
LongToHandle(
    const long h
    )
{
    return((void *) (INT_PTR) h );
}


__inline
unsigned long
PtrToUlong(
    const void  *p
    )
{
    return((unsigned long) p );
}

__inline
unsigned int
PtrToUint(
    const void  *p
    )
{
    return((unsigned int) p );
}

__inline
unsigned short
PtrToUshort(
    const void  *p
    )
{
    return((unsigned short) p );
}

__inline
long
PtrToLong(
    const void  *p
    )
{
    return((long) p );
}

__inline
int
PtrToInt(
    const void  *p
    )
{
    return((int) p );
}

__inline
short
PtrToShort(
    const void  *p
    )
{
    return((short) p );
}

__inline
void *
IntToPtr(
    const int i
	)
// Caution: IntToPtr() sign-extends the int value.
{
    return( (void *)(INT_PTR)i );
}

__inline
void *
UIntToPtr(
    const unsigned int ui
    )
// Caution: UIntToPtr() zero-extends the unsigned int value.
{
    return( (void *)(UINT_PTR)ui );
}

__inline
void *
LongToPtr(
    const long l
    )
// Caution: LongToPtr() sign-extends the long value.
{
    return( (void *)(LONG_PTR)l );
}

__inline
void *
ULongToPtr(
    const unsigned long ul
    )
// Caution: ULongToPtr() zero-extends the unsigned long value.
{
    return( (void *)(ULONG_PTR)ul );
}

#endif // !_midl
#if _MSC_VER >= 1200
#pragma warning(pop)      // restore 4305
#endif
#pragma warning(3:4311)   // bump 4311 to a level 3

#else  // !_WIN64

#define ADDRESS_TAG_BIT 0x80000000UL

typedef unsigned short UHALF_PTR, *PUHALF_PTR;
typedef short HALF_PTR, *PHALF_PTR;
typedef _W64 unsigned long HANDLE_PTR;

#define HandleToUlong( h ) ((ULONG)(ULONG_PTR)(h) )
#define HandleToLong( h ) ((LONG)(LONG_PTR) (h) )
#define LongToHandle( h) ((HANDLE)(LONG_PTR) (h))
#define PtrToUlong( p ) ((ULONG)(ULONG_PTR) (p) )
#define PtrToLong( p ) ((LONG)(LONG_PTR) (p) )
#define PtrToUint( p ) ((UINT)(UINT_PTR) (p) )
#define PtrToInt( p ) ((INT)(INT_PTR) (p) )
#define PtrToUshort( p ) ((unsigned short)(ULONG_PTR)(p) )
#define PtrToShort( p ) ((short)(LONG_PTR)(p) )
#define IntToPtr( i )    ((VOID *)(INT_PTR)((int)i))
#define UIntToPtr( ui )  ((VOID *)(UINT_PTR)((unsigned int)ui))
#define LongToPtr( l )   ((VOID *)(LONG_PTR)((long)l))
#define ULongToPtr( ul )  ((VOID *)(ULONG_PTR)((unsigned long)ul))

#endif // !_WIN64

#define UlongToPtr(ul) ULongToPtr(ul)
#define UintToPtr(ui) UIntToPtr(ui)

#define MAXUINT_PTR  (~((UINT_PTR)0))
#define MAXINT_PTR   ((INT_PTR)(MAXUINT_PTR >> 1))
#define MININT_PTR   (~MAXINT_PTR)

#define MAXULONG_PTR (~((ULONG_PTR)0))
#define MAXLONG_PTR  ((LONG_PTR)(MAXULONG_PTR >> 1))
#define MINLONG_PTR  (~MAXLONG_PTR)

#define MAXUHALF_PTR ((UHALF_PTR)~0)
#define MAXHALF_PTR  ((HALF_PTR)(MAXUHALF_PTR >> 1))
#define MINHALF_PTR  (~MAXHALF_PTR)

//
// SIZE_T used for counts or ranges which need to span the range of
// of a pointer.  SSIZE_T is the signed variation.
//

typedef ULONG_PTR SIZE_T, *PSIZE_T;
typedef LONG_PTR SSIZE_T, *PSSIZE_T;

//
// Add Windows flavor DWORD_PTR types
//

typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

//
// The following types are guaranteed to be signed and 64 bits wide.
//

typedef __int64 LONG64, *PLONG64;
typedef __int64 INT64,  *PINT64;


//
// The following types are guaranteed to be unsigned and 64 bits wide.
//

typedef unsigned __int64 ULONG64, *PULONG64;
typedef unsigned __int64 DWORD64, *PDWORD64;
typedef unsigned __int64 UINT64,  *PUINT64;

#ifdef __cplusplus
}
#endif

#endif // _BASETSD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\applaunch\cmdline.h ===
//
// Command line processing header file
//

//
//
//
#define CMDLINE_BEGIN(cmdLine, firstarg, rubbish, wantQuotes) \
    {                                                           \
    LPTSTR pszArgs=new TCHAR[lstrlen(cmdLine)*sizeof(TCHAR)+4]; \
    lstrcpy(pszArgs,lpCmdLine);                                 \
    lstrcat(pszArgs,TEXT(" "));                                 \
    LPTSTR pszSwitch=pszArgs;                                   \
    LPTSTR lastArg=pszArgs;                                     \
    LPTSTR * ppszRubbish=rubbish;                   \
    LPTSTR * ppszDest=firstarg;                     \
    BOOL    bInQuotes=FALSE;                        \
    BOOL    bStripQuotes=wantQuotes;                \
    while(*pszSwitch!=0)                            \
    {                                               \
        if( *pszSwitch==TEXT('"') )                 \
        {                                           \
            if( bStripQuotes )                      \
            {                                       \
                if(bInQuotes)                       \
                    *pszSwitch=TEXT(' ');           \
                else                                \
                    lastArg=pszSwitch+1;            \
            }                                       \
            bInQuotes=!bInQuotes;                   \
        }                                           \
                                                    \
        if( (bInQuotes==FALSE) && (*pszSwitch==TEXT(' ')) ) \
        {                                           \
            *pszSwitch=NULL;                        \
            if( *lastArg==TEXT('/') )               \
                *lastArg=TEXT('-');                 \
            if(FALSE)                               \
            {}                                      \


//
// Each argument
//
#define CMDLINE_TEXTARG(Switch, Destination)        \
    else if(lstrcmpi(lastArg,TEXT(Switch))==0)      \
    {    ppszDest=Destination;   }                  \


#define CMDLINE_SWITCH(Switch, Destination)         \
    else if(lstrcmpi(lastArg,TEXT(Switch))==0)      \
    {   ppszDest=ppszRubbish;                       \
        *Destination=TRUE;   }                      \


//
// 
//
#define CMDLINE_END()                               \
            else                                    \
            {                                       \
                if( *lastArg =='-' )                \
                { /* Some Error */                  \
                }                                   \
                else                                \
                {                                   \
                   *ppszDest=new TCHAR[lstrlen(lastArg)+1]; lstrcpy(*ppszDest,lastArg); \
                }                                   \
                ppszDest=ppszRubbish;               \
            }                                       \
            lastArg=pszSwitch+1;                    \
        }                                           \
        pszSwitch++;                                \
    }                                               \
    delete pszArgs;                                 \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\applaunch\dumptocfg.h ===
// DumpToCfg.h: interface for the CDumpToCfg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DUMPTOCFG_H__A227A315_8DCD_454C_8AF2_302006CB338C__INCLUDED_)
#define AFX_DUMPTOCFG_H__A227A315_8DCD_454C_8AF2_302006CB338C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "simpleloader.h"

typedef struct _tagStringBuffer
{
    UINT    size;           // in chars
    UINT    used;           // in chars
    LPTSTR  pszString;      // start of the string
    LPTSTR  pszStringEnd;   // points to the NULL in the string, so cat'ing is fast
} STRINGBUFFER, * PSTRINGBUFFER;


PSTRINGBUFFER AppendText(PSTRINGBUFFER buffer, LPTSTR pszText);


class CDumpToCfg  
{
public:
	CDumpToCfg();
	virtual ~CDumpToCfg();

    void DumpRuleNodes( CNodeList * pNodeList );
    void DumpNodes( CNodeList * pNodeList );

    void AddStrings(LPTSTR pszText);
    void DumpLitteral(CXMLLitteral * pLitteral);
    void DumpLitteralEnd( CXMLLitteral * pLitteral);
    void DumpToken(CXMLToken * pToken);

    void AppendText( LPTSTR pszText );
    void SetBuffer(BOOL bRule ) { m_pCurrentBuffer=bRule?&m_RuleBuffer:&m_Rules; }
    PSTRINGBUFFER m_RuleBuffer; // <RULE>
    PSTRINGBUFFER m_Rules;      // stuff with <RULEREF >
    PSTRINGBUFFER * m_pCurrentBuffer;
private:
    int m_Depth;
};

#endif // !defined(AFX_DUMPTOCFG_H__A227A315_8DCD_454C_8AF2_302006CB338C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\applaunch\dumptocfg.cpp ===
// DumpToCfg.cpp: implementation of the CDumpToCfg class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DumpToCfg.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDumpToCfg::CDumpToCfg()
{
    m_RuleBuffer=NULL;
    m_Rules=NULL;

    TCHAR szBuffer[2];
    szBuffer[0]=0xfeff;
    szBuffer[1]=NULL;
    m_RuleBuffer = ::AppendText( m_RuleBuffer, szBuffer);

    m_Depth=0;

    SetBuffer(TRUE);
}

CDumpToCfg::~CDumpToCfg()
{
    ::AppendText(m_RuleBuffer, NULL);
    ::AppendText(m_Rules, NULL);
}

//
// DumpNodes assumes that a bunch of "RULES" will be created,
// mainly as placeholders for list of strings.
//
void CDumpToCfg::DumpRuleNodes(CNodeList * pNodeList )
{
}

void CDumpToCfg::DumpNodes(CNodeList * pNodeList )
{
    CXMLNode * pNode;
    int i=0;
    m_Depth++;

    while( pNode = pNodeList->GetPointer(i++) )
    {
        LPTSTR pszName;
        pNode->get_Attr(L"TEXT", &pszName );
        // BOOL bRequired = pLitteral->IsRequired();

        if( m_Depth == 1 )
        {
            TCHAR szTemp[MAX_PATH];
            wsprintf(szTemp, TEXT("<RULE NAME=\"%s\" TOPLEVEL=\"ACTIVE\">\r\n"), pszName);
            AppendText(szTemp);
        }

        CNodeList  * pnewNodes = pNode->GetNodeList();


        // List of actual words
        if( SUCCEEDED( pNode->IsType( TEXT("LITTERAL") ) ))
        {
            DumpLitteral( (CXMLLitteral*)pNode);
            DumpNodes(pnewNodes);
            DumpLitteralEnd( (CXMLLitteral*)pNode);
        }

        // Things we're listening for from the user, 
        // dictation, numbers, dates etc.
        if( SUCCEEDED( pNode->IsType( TEXT("Token") ) ))
        {
            DumpToken( (CXMLToken*)pNode);
            DumpNodes( pnewNodes);
        }

        if( m_Depth == 1 )
        {
            AppendText(TEXT("</RULE>\r\n" ));
        }
    }

    m_Depth --;
}

//
// THis is the REQUIRED TEXT="Stuff"
//
void CDumpToCfg::DumpLitteral( CXMLLitteral * pLitteral)
{
    TCHAR szBuffer[1024];
    BOOL bRequired = pLitteral->IsRequired();
    LPTSTR pszName;
    pLitteral->get_Attr(L"TEXT", &pszName );

    if( m_Depth<=1 )
    {
        wsprintf(szBuffer, TEXT("%s"), bRequired?TEXT("<L>\r\n"):TEXT("<O>\r\n") );
        AppendText( szBuffer );
        // Now what are the strings?
        AddStrings( pszName );

        if( bRequired )
            AppendText( TEXT("</L>\r\n"));
    }
    else
    {
        LPTSTR pszTemp=new TCHAR[lstrlen(pszName)+50];
        if( !bRequired )
            AppendText( TEXT("<O>\r\n"));
        wsprintf(pszTemp,TEXT("<RULEREF NAME=\"%s\" />"),pszName);
        AppendText( pszTemp );
        // if( !bRequired )
        //    AppendText( TEXT("</O>\r\n"));

        //
        // Now create the RULEREF ?
        //
        SetBuffer(FALSE);
        wsprintf(pszTemp,TEXT("<RULE NAME=\"%s\" >"),pszName);
        AppendText( pszTemp );
        AppendText( TEXT("<L>") );
        AddStrings( pszName );
        AppendText( TEXT("</L>") );
        wsprintf(pszTemp,TEXT("</RULE>\r\n"),pszName);
        AppendText( pszTemp );
        SetBuffer(TRUE);

        delete pszTemp;
    }
}

//
// A list cannot contain any optional things.
//
void CDumpToCfg::DumpLitteralEnd( CXMLLitteral * pLitteral)
{
    // if( m_Depth < 1 )
    {
        BOOL bRequired = pLitteral->IsRequired();

        if( !bRequired )
            AppendText( TEXT("</O>\r\n") );
        else
        {
            // AppendText( TEXT("</L>\r\n") );
        }

    }    
}

//
// This is kinda sneaky, and not sure if this should go here or somewher else??
//
//
void CDumpToCfg::AddStrings(LPTSTR pszText)
{
    LPTSTR pszWord= new TCHAR[lstrlen(pszText)+15];
    LPTSTR pszTemp=new TCHAR[lstrlen(pszText)+15];
    LPTSTR pszCopy=pszWord;
    while( *pszText )
    {
        if( *pszText ==TEXT('/') )
        {
            *pszCopy=0;
            wsprintf(pszTemp, TEXT("<P>%s</P>\r\n") , pszWord );
            AppendText(pszTemp );
            pszCopy=pszWord;
        }
        else
            *pszCopy++=*pszText;
        pszText++;
    }

    *pszCopy=0;
    wsprintf(pszTemp, TEXT("<P>%s</P>\r\n") , pszWord );
    AppendText(pszTemp );
    delete pszTemp;
    delete pszWord;
}


// This is a SLOT type="dictation" etc.
// 
//
void CDumpToCfg::DumpToken( CXMLToken * pToken)
{
    TCHAR szBuffer[1024];

    LPTSTR pszName;
    pToken->get_Attr(L"NAME", &pszName );
    LPTSTR pszType;
    pToken->get_Attr(L"TYPE", &pszType );

    if( lstrcmpi( pszType, TEXT("dictation") ) == 0 )
    {
        
        wsprintf( szBuffer, TEXT("<RULEREF NAME=\"dictation_%s\" VALSTR=\"%s\" />"), pszName, pszName );
        AppendText( szBuffer );

        //
        // Now create the RULEREF ?
        //
        SetBuffer(FALSE);
        wsprintf(szBuffer,TEXT("<RULE NAME=\"dictation_%s\" >"),pszName, pszName);
        AppendText( szBuffer );
        AppendText( TEXT("<DICTATION MIN=\"1\" MAX=\"3\"/>\r\n"));
        AppendText( TEXT("</RULE>\r\n") );
        SetBuffer(TRUE);

        wsprintf(szBuffer,TEXT("dictation_%s"),pszName);
        pToken->put_Attr(TEXT("TEXT"), szBuffer );
    }
    else
    if( lstrcmpi( pszType, TEXT("number") ) == 0 )
    {
    }
    if( lstrcmpi( pszType, TEXT("date") ) == 0 )
    {
    }
}

void CDumpToCfg::AppendText( LPTSTR pszText )
{
    // m_RuleBuffer=::AppendText(m_RuleBuffer, pszText);
    *m_pCurrentBuffer = ::AppendText( *m_pCurrentBuffer, pszText );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\applaunch\sapilaunch.h ===
// SapiLaunch.h: interface for the CSapiLaunch class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SAPILAUNCH_H__E09EE8AF_6562_403C_BE16_A247B63573B9__INCLUDED_)
#define AFX_SAPILAUNCH_H__E09EE8AF_6562_403C_BE16_A247B63573B9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "BaseSAPI.h"
#include "simpleloader.h"

class CSapiLaunch : public CBaseSAPI  
{
public:
	CSapiLaunch(IBaseXMLNode * pHead);
	virtual ~CSapiLaunch();
    virtual HRESULT ExecuteCommand( ISpPhrase *pPhrase );
    void    SetWindow( HWND h) { m_hwnd=h; };
protected:
    IBaseXMLNode * m_pHead;
    CXMLNode * FindElementCalled( CNodeList ** ppNodeList, CXMLNode * pCurrentNode, LPCTSTR pszText );
    HWND m_hwnd;
};

#endif // !defined(AFX_SAPILAUNCH_H__E09EE8AF_6562_403C_BE16_A247B63573B9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\applaunch\sapilaunch.cpp ===
// SapiLaunch.cpp: implementation of the CSapiLaunch class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "SapiLaunch.h"
// #include "debug.h"
#include "resource.h"
#include "dumptocfg.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSapiLaunch::CSapiLaunch(IBaseXMLNode * pHead)
: m_pHead(pHead)
{
}

CSapiLaunch::~CSapiLaunch()
{

}

HRESULT CSapiLaunch::ExecuteCommand( ISpPhrase *pPhrase )
{
  	HRESULT hr=S_OK;

    LPWSTR pszSaid = GetRecognizedText( pPhrase );

    TRACE(TEXT("The user said %s\n"), pszSaid );

    SetWindowText( GetDlgItem( m_hwnd, IDC_TEXT ), pszSaid );

    SPPHRASE *pElements;
    // Get the phrase elements, one of which is the rule id we specified in
    // the grammar.  Switch on it to figure out which command was recognized.
    if (FAILED(hr = pPhrase->GetPhrase(&pElements)))
        return hr;

    // find this now ... hmm ...
    if( FAILED( m_pHead->IsType( L"Launch" )))
        return hr;

    CXMLLaunch * pLaunch = (CXMLLaunch*)m_pHead;

    CNodeList * pNodeList = pLaunch->GetNodeList();

    CXMLNode * pNode=NULL;

    const SPPHRASERULE * pRule = &pElements->Rule;
    LPCWSTR pszRuleName = pRule->pszName;

    BOOL bEnd=FALSE;

    CXMLNode * pLitteral=NULL;
    CStringPropertySection substitutions;

    do{

        pNode = FindElementCalled( &pNodeList, pNode, pszRuleName );
        //
        // Keep a track of last required/ optional
        //
        if( pNode )
        {
            if( SUCCEEDED( pNode->IsType( L"Litteral" ) ))
                pLitteral=pNode;
            else if( SUCCEEDED( pNode->IsType( L"Token" ) ))
                pLitteral=pNode;

            //
            // Get the result from the SLOT
            //
            if( SUCCEEDED( pNode->IsType( L"Token" )))
            {
                LPTSTR pszName;
                if( SUCCEEDED( pNode->get_Attr(L"NAME",&pszName )))
                {
					ULONG FirstElement=pRule->ulFirstElement;
                    PSTRINGBUFFER pSub=NULL;
                    for(UINT i=0; i<pRule->ulCountOfElements; i++ )
                    {
                        pSub=AppendText(pSub,(LPTSTR)pElements->pElements[FirstElement+i].pszDisplayText);
                        AppendText(pSub, TEXT(" ") );
                    }
                    substitutions.Set( pszName, pSub->pszString);
                    AppendText(pSub, NULL);
                }
            }

            if( pRule->pFirstChild != NULL )
            {
                pRule = pRule->pFirstChild;
                pszRuleName = pRule->pszName;
                continue;
            }

            //
            // Could be a child or us, or not
            //
            if( pRule->pNextSibling != NULL )
            {
                pRule = pRule->pNextSibling;
                pszRuleName = pRule->pszName;
                continue;
            }

            bEnd=TRUE;

        }
        else
        {
            TRACE(TEXT("Failed to find that node\n"));
        }
    } while( pNode && !bEnd);

    // Now find out where the Invoke is - its a brother of the last slot, unless that's
    // an optional slot! Yuck! Find the invoke child of the last litteral??
    if( pLitteral )
    {
        // Found it! - now find the Invoke stuff.
        TRACE(TEXT("Think I've found a match in the XML\n"));
        CNodeList * pnewNodes = pLitteral->GetNodeList();
        int k=0;
        CXMLNode * pInvoke;
        while(pInvoke = pnewNodes->GetPointer(k++) )
        {
            if( SUCCEEDED ( pInvoke -> IsType (L"INVOKE") ))
            {
                TRACE(TEXT("We have an invoke node \n"));
                LPTSTR pszCommand;
                pInvoke->get_Attr(L"COMMAND", &pszCommand);
                BOOL bURL=FALSE;

                if( pszCommand == NULL )
                {
                    pInvoke->get_Attr(L"URL", &pszCommand);
                    if(pszCommand!=NULL)
                        bURL=TRUE;
                }

                TCHAR cmdLine[1024];
                LPTSTR pszCmdLine=cmdLine;

                while( *pszCommand)
                {
                    if( *pszCommand==TEXT('&') )
                    {
                        // substitute argument.
                        TCHAR szRuleName[128];
                        LPTSTR pszAppend=szRuleName;
                        // pszAppend += wsprintf( szRuleName, TEXT("dictation_") );
                        while( *++pszCommand )
                        {
                            *pszAppend=*pszCommand;
                            if(*pszCommand==TEXT(';'))
                            {
                                *pszAppend=0;
                                LPCTSTR pszReplace=substitutions.Get( szRuleName );
                                TRACE(TEXT("Replace %s with %s\n"),szRuleName, pszReplace );
                                while(*pszReplace)
                                    *pszCmdLine++=*pszReplace++;
                                pszCommand++;
                                break;
                            }
                            pszAppend++;
                        }
                    }
                    else
                        *pszCmdLine++=*pszCommand++;
                }
                *pszCmdLine=0;

                // substitute %20 for spaces?
                if( bURL )
                {
                    TCHAR withSpaces[1024];
                    lstrcpyn( withSpaces, cmdLine, 1023);
                    LPTSTR pszSrc = withSpaces;
                    LPTSTR pszDest = cmdLine;
                    while(*pszSrc)
                    {
                        if( *pszSrc==TEXT(' ') )
                        {
                            *pszDest++=TEXT('%');
                            *pszDest++=TEXT('2');
                            *pszDest++=TEXT('0');
                        }
                        else
                            *pszDest++=*pszSrc;
                        pszSrc++;
                    }
                    *pszDest=0;
                }
                TRACE(TEXT("We ahve the command %s\n"),cmdLine);
                SetWindowText( GetDlgItem( m_hwnd, IDC_CMDLINE ), cmdLine );
                SetWindowText(m_hwnd, cmdLine );
            }
        }
    }

    return hr;
}

//
// Can be one of our children, or our brothers.
//
CXMLNode * CSapiLaunch::FindElementCalled( CNodeList ** ppNodeList, CXMLNode * pCurrentNode, LPCTSTR pszText )
{
    CXMLNode * pNode;
    int i=0;
    CNodeList * pNodeList = *ppNodeList;

    // check our brothers first.
    while( pNode = pNodeList->GetPointer(i++) )
    {
        LPTSTR pszName;
        pNode->get_Attr(L"TEXT", &pszName );

        if( pszName == NULL )
            continue;

        TRACE(TEXT("SAPI rule is %s - comparing with %s\n"), pszText, pszName );

        if( lstrcmpi( pszName, pszText) == 0 )
        {
            TRACE(TEXT("Match!\n"));
            return pNode;
        }
    }

    //
    // Now could it be one of our chilrend??
    //
    if( pCurrentNode )
    {
        pNodeList = pCurrentNode->GetNodeList();
        i=0;
        // check our brothers first.
        while( pNode = pNodeList->GetPointer(i++) )
        {
            LPTSTR pszName;
            pNode->get_Attr(L"TEXT", &pszName );

            if( pszName == NULL )
                continue;

            TRACE(TEXT("SAPI rule is %s - comparing with %s\n"), pszText, pszName );

            if( lstrcmpi( pszName, pszText) == 0 )
            {
                TRACE(TEXT("Match!\n"));
                CNodeList * pChildList = pNode->GetNodeList();
                if( pChildList->GetPointer(0) )
                    *ppNodeList = pNodeList;
                return pNode;
            }
        }
    }
    return NULL;
}
#if 0
        }
    }

    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\applaunch\simpleloader.cpp ===
//
// Understands 2 namespaces, the default and a Dummy one.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "SimpleLoader.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


//
// This is a lookup which matches element names in the schema to
// C++ objects to deal with them.
//
#define XMLNODE(name, function) { name, CXML##function::newXML##function }
#define XMLNODEALIAS(name, object, function) { name, CXML##object::newXML##function }

CSimpleXMLLoader::XMLELEMENT_CONSTRUCTOR g_APPLAUNCH[]=
{
	XMLNODE( TEXT("LAUNCH"), Launch ),  
	XMLNODEALIAS( TEXT("REQUIRED"), Litteral, LitteralRequired),  
	XMLNODEALIAS( TEXT("OPTIONAL"), Litteral, LitteralOptional),  
	XMLNODE( TEXT("SLOT"), Token ),  
	XMLNODE( TEXT("INVOKE"), Invoke ),  
	{ NULL, NULL}   // end
};

CSimpleXMLLoader::XMLELEMENT_CONSTRUCTOR g_DEMONS[]=
{
    XMLNODE( TEXT("DEMO"), Demo ),

	{ NULL, NULL}   // end
};


CSimpleXMLLoader::CSimpleXMLLoader()
: BASECLASS()
{
    m_pEntitySet=NULL;
    //
    // Register the namespaces we want to deal with by default.
    //
    RegisterNameSpace( TEXT("urn:schemas-microsoft-com:CICERO:APPLAUNCH"), CSimpleXMLLoader::CreateRootElement );
}

IBaseXMLNode * CSimpleXMLLoader::CreateRootElement( LPCTSTR pszElement )
{ return CreateElement( g_APPLAUNCH, pszElement ); }

IBaseXMLNode * CSimpleXMLLoader::CreateDummyElement( LPCTSTR pszElement )
{ return CreateElement( g_DEMONS, pszElement ); }


IBaseXMLNode * CSimpleXMLLoader::CreateElement( PXMLELEMENT_CONSTRUCTOR dictionary, LPCTSTR pszElement )
{
	if(dictionary)
	{
		PXMLELEMENT_CONSTRUCTOR pEC=dictionary;
		while( pEC->pwszElement )
		{
			if( lstrcmpi( pszElement , pEC->pwszElement) == 0 )
			{
				CLSPFN pFunc=pEC->pFunc;
                return pFunc();
			}
			pEC++;
		}
    }
    return NULL;
}



CSimpleXMLLoader::~CSimpleXMLLoader()
{
}


//
//
//
LPCTSTR CSimpleXMLLoader::DoEntityRef( LPCTSTR pszEntity )
{
    LPTSTR pszPadded=new TCHAR[lstrlen(pszEntity)+3];
    if(m_pEntitySet==NULL)
    {
        wsprintf( pszPadded, TEXT("&%s;"), pszEntity);
        return pszPadded;
    }

    if( lstrcmpi(pszEntity, TEXT("DemoEntity")) ==0 )
        return TEXT("Email FelixA");

    return pszEntity;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\applaunch\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AppLaunch.rc
//
#define IDD_LISTENING                   102
#define IDC_TEXT                        1002
#define IDC_CMDLINE                     1003

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40004
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\applaunch\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	AppLaunch.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\applaunch\simpleloader.h ===
// RCMLLoader.h: interface for the CSimpleXMLLoader class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RCMLLOADER_H__229F8181_D92F_4313_A9C7_334E7BEE3B3B__INCLUDED_)
#define AFX_RCMLLOADER_H__229F8181_D92F_4313_A9C7_334E7BEE3B3B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "appservices.h"    // 

class CSimpleXMLLoader : public _XMLDispatcher<IBaseXMLNode>
{
public:
	typedef _XMLDispatcher<IBaseXMLNode> BASECLASS;
	CSimpleXMLLoader();
	virtual ~CSimpleXMLLoader();

    //
    // Dispatcher cannot do this for us.
    //
    virtual LPCTSTR DoEntityRef(LPCTSTR pszEntity);
    void SetEntities(LPCTSTR * pszEntities) { m_pEntitySet=pszEntities; }

    //
    // We create nodes of type IBaseXMLNode
    //
    typedef IBaseXMLNode * (*CLSPFN)();

    typedef struct _XMLELEMENT_CONSTRUCTOR
    {
	    LPCTSTR	pwszElement;		// the element
	    CLSPFN	pFunc;				// the function to call.
    }XMLELEMENT_CONSTRUCTOR, * PXMLELEMENT_CONSTRUCTOR;


    //
    // Here are the name spaces that we support.
    //
    static IBaseXMLNode * WINAPI CreateElement( PXMLELEMENT_CONSTRUCTOR dictionary, LPCTSTR pszElement );
    static IBaseXMLNode * WINAPI CreateRootElement( LPCTSTR pszElement ); 
    static IBaseXMLNode * WINAPI CreateDummyElement( LPCTSTR pszElement );

private:
    LPCTSTR  *  m_pEntitySet;

protected:

};

//
// the app launch schema
//
class CXMLLitteral;
class CXMLToken;
class CXMLInvoke;
class CXMLNode;

typedef _RefcountList<CXMLLitteral> CLitteralList;
typedef _RefcountList<CXMLToken> CTokenList;

typedef _RefcountList<CXMLNode> CNodeList;

class CXMLNode : public CAppServices
{
public:
    CXMLNode() {};
    virtual ~CXMLNode() {};
	typedef CAppServices BASECLASS;

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IBaseXMLNode __RPC_FAR *child) 
    { 
        if( SUCCEEDED( child->IsType( L"Litteral" )))
        {
            m_NodeList.Append((CXMLNode*)child);
            return S_OK;
        }
        if( SUCCEEDED( child->IsType( L"Token" )))
        {
            m_NodeList.Append((CXMLNode*)child);
            return S_OK;
        }
        if( SUCCEEDED( child->IsType( L"Invoke" )))
        {
            m_NodeList.Append((CXMLNode*)child);
            return S_OK;
        }
        return BASECLASS::AcceptChild(child); 
    }

    CNodeList *     GetNodeList() { return &m_NodeList; }

protected:
    void Init() {};
    CNodeList       m_NodeList;
};

class CXMLLaunch  : public CXMLNode
{
public:
    CXMLLaunch() {m_StringType=L"Launch";}
    virtual ~CXMLLaunch() {};

	typedef CXMLNode BASECLASS;
   	NEWNODE( Launch);

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IBaseXMLNode __RPC_FAR *child) 
    { 
        return BASECLASS::AcceptChild(child); 
    }

protected:
    void Init() {};
};

class CXMLToken  : public CXMLNode
{
public:
    CXMLToken() {m_StringType=L"Token";}
    virtual ~CXMLToken() {};

	typedef CXMLNode BASECLASS;
   	NEWNODE( Token);

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IBaseXMLNode __RPC_FAR *child) 
    { 
        /*
        if( SUCCEEDED( child->IsType( L"Litteral" )))
        {
            m_LitteralList.Append((CXMLLitteral*)child);
            return S_OK;
        }
        */
        return BASECLASS::AcceptChild(child);
    }

protected:
    void Init() {};
    CLitteralList   m_LitteralList;
};

class CXMLLitteral  : public CXMLNode
{
public:
    CXMLLitteral(BOOL bRequired) : m_bRequired(bRequired) {m_StringType=L"Litteral";}
    virtual ~CXMLLitteral() {};

	typedef CXMLNode BASECLASS;
   	// NEWNODE( Litteral);
    static IBaseXMLNode * newXMLLitteralOptional() { return new CXMLLitteral(FALSE); }
    static IBaseXMLNode * newXMLLitteralRequired() { return new CXMLLitteral(TRUE); }

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IBaseXMLNode __RPC_FAR *child) 
    { 
        /*
        if( SUCCEEDED( child->IsType( L"Token" )))
        {
            m_TokenList.Append((CXMLToken*)child);
            return S_OK;
        }
        */
        return BASECLASS::AcceptChild(child); 
    }

    BOOL    IsRequired() { return m_bRequired; }

protected:
    void Init() {};
    CTokenList   m_TokenList;
    BOOL    m_bRequired;
};


class CXMLInvoke  : public CAppServices
{
public:
    CXMLInvoke() {m_StringType=L"Invoke";}
    virtual ~CXMLInvoke() {};

	typedef CAppServices BASECLASS;
   	NEWNODE( Invoke);

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IBaseXMLNode __RPC_FAR *child) { return BASECLASS::AcceptChild(child); }

protected:
    void Init() {};
};

//////////////////

class CXMLDemo  : public CAppServices
{
public:
    CXMLDemo() {m_StringType=L"DEMO";}

    virtual ~CXMLDemo() {};

	typedef CAppServices BASECLASS;
   	NEWNODE( Demo );

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IBaseXMLNode __RPC_FAR *child) { return BASECLASS::AcceptChild(child); }

protected:
    void Init() {};
};

#endif // !defined(AFX_RCMLLOADER_H__229F8181_D92F_4313_A9C7_334E7BEE3B3B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\speechhook\spchhk\debug.cpp ===
//
//
//

#include "stdafx.h"
#include "debug.h"

#ifdef _DEBUG
void FAR _cdecl 
TRACE(
	LPTSTR lpszFormat, 
	...) 
{
	TCHAR szBuf[1024];
	int	cchAdd;

	cchAdd = wvsprintf((LPTSTR)szBuf, lpszFormat, (LPSTR)(&lpszFormat + 1));
	OutputDebugString((LPCTSTR)szBuf);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\speechhook\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\speechhook\spchhk\debug.h ===
//
//
//

#ifdef _DEBUG
void FAR _cdecl 
TRACE(
	LPTSTR lpszFormat, 
	...);

#else
#define TRACE 0?0:
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\applaunch\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include "basetsd.h"
#include <windows.h>
#include <atlbase.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\speechhook\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	SpeechHook.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\speechhook\spchhk\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	SPCHHK.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\speechhook\spchhk\rcmllistens.h ===
// RCMLListens.h: interface for the CRCMLListens class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RCMLLISTENS_H__7DF0DDCF_A1E4_413F_823A_7A27839D42D5__INCLUDED_)
#define AFX_RCMLLISTENS_H__7DF0DDCF_A1E4_413F_823A_7A27839D42D5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "thread.h"
#define _RCML_LOADFILE
#include "rcml.h"

class CTunaClient;

class CRCMLListens : public CLightThread  
{
public:
    typedef CLightThread BASECLASS;

	HRESULT TurnOffRules();
    HRESULT SetElementRuleState( IRCMLControl * pNode , LPCWSTR pszState, IRCMLNode ** ppCicero);
    HRESULT ShowTooltip( IRCMLNode * pNode);
	HRESULT MapToHwnd( HWND hWnd );
	CRCMLListens(LPCTSTR pszFileName, HWND hWnd );
	virtual ~CRCMLListens();

  	virtual void Process(void);
	virtual EThreadError Stop(void);
    HWND    GetWindow() { return m_hwnd; } 
protected:
	HRESULT UnBind();
    IRCMLNode    * m_pRootNode;
    BOOL            m_bInitedRCML;
    TCHAR       m_szFile[MAX_PATH];
    HWND        m_hwnd;
    UINT        m_uiLastTip;
    HWND        m_hwndTT;
    void        ShowBalloonTip(LPWSTR pszText);
    static CTunaClient  g_TunaClient;
    static BOOL         g_TunaInit;
};

#endif // !defined(AFX_RCMLLISTENS_H__7DF0DDCF_A1E4_413F_823A_7A27839D42D5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\speechhook\speechhook.cpp ===
// SpeechHook.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
#define USING_DLL 1
#include "commdlg.h"
#include "resource.h"
#include "shellapi.h"

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Startup information for the listener.
//
typedef struct _tagAppInit
{
    HMODULE hMod;       // the DLL that we are using to listen.
} APPINIT, * PAPPINIT;

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This is the default dialog proc used when displaying RCML dialogs
//
#ifndef WS_EX_LAYERED
#define WS_EX_LAYERED           0x00080000
WINUSERAPI
BOOL
WINAPI
SetLayeredWindowAttributes (
    HWND hwnd,
    COLORREF crKey,
    BYTE bAlpha,
    DWORD dwFlags);

#define LWA_COLORKEY            0x00000001
#define LWA_ALPHA               0x00000002

typedef WINUSERAPI
BOOL
( WINAPI * PSLWA ) (
    HWND hwnd,
    COLORREF crKey,
    BYTE bAlpha,
    DWORD dwFlags);

#endif

BOOL CALLBACK ListeningDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    if(uMessage==WM_COMMAND)
    {
        int iControl=LOWORD(wParam);
        if( HIWORD(wParam)==0 )
        {
            switch( iControl )
            {
            case IDOK:
            case IDCANCEL:
                EndDialog( hDlg, iControl);
                break;
            case IDC_TUNA:
                ShellExecute( hDlg, "open", "http://toolbox/search/tbdetail.asp?ToolID=1056", NULL,
                    NULL, SW_NORMAL );
                break;
            }
        }
    }


    if(uMessage==WM_INITDIALOG)
    {
        PAPPINIT pAppInit = (PAPPINIT)lParam;

#ifndef _DEBUG
        // SetWindowPos( hDlg, HWND_TOPMOST, 0, 0,0,0, SWP_NOSIZE | SWP_NOMOVE );
        HMODULE hm=LoadLibrary("USER32.DLL");
        if(hm)
        {
            PSLWA pSetLayeredWindowAttributes = (PSLWA)GetProcAddress(hm, "SetLayeredWindowAttributes");
            if( pSetLayeredWindowAttributes )
            {
                SetWindowLong(hDlg , GWL_EXSTYLE, GetWindowLong(hDlg , GWL_EXSTYLE) | WS_EX_LAYERED);
                pSetLayeredWindowAttributes( hDlg, 0, 0xF0, LWA_ALPHA);
            }
            FreeLibrary(hm);
        }
#endif
        return TRUE;
    }
    return FALSE;
}


typedef _declspec(dllimport) void ( * PTURNON) (HWND hStatusWindow);

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    // IsChild( (HWND)0x3709f4, (HWND)0x1f09b0);

	HMODULE hMod = LoadLibrary( lpCmdLine );
	if(hMod)
	{
        APPINIT appInit;
        appInit.hMod = hMod;

        HWND hDlg = CreateDialogParam( hInstance, MAKEINTRESOURCE(IDD_LISTENING), GetDesktopWindow(), ListeningDlgProc, (LPARAM)&appInit );
        PTURNON pTurnOn = (PTURNON)GetProcAddress(hMod, "TurnOnHooks");
        if( pTurnOn )
        {
            ShowWindow(hDlg, SW_NORMAL );
            pTurnOn(hDlg);

	         // Main message loop:
	        MSG msg;
	        while (GetMessage(&msg, NULL, 0, 0) )
	        {
                if( IsDialogMessage( hDlg, &msg ) == FALSE )
			        DispatchMessage(&msg);

                if(msg.hwnd == hDlg)
                {
                    if( msg.message == WM_NULL)
                        break;
                }
	        }

		    GetProcAddress( hMod, "TurnOffHooks" )();
        }

		FreeLibrary( hMod );
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\speechhook\spchhk\spchhk.cpp ===
// SPCHHK.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#define _RCML_LOADFILE
#include "rcml.h"
#include <Psapi.h>
#include "rcmllistens.h"
#include "debug.h"
#include <commctrl.h>
#include <shellapi.h>   // ShellExecute
//
// Turn this on if you want to log information
//
#define _LOG_INFO


#include "winable.h"


typedef struct _tagRCMLWHND
{
    BOOL            bActive;        // are we listening on this one
    BOOL            bFocusChange;   // the tree remains active, but rebound to a new hwnd.
    HWND            hwnd;           // this is where the RCML is bound to (may not be listening)
    LPWSTR          pszRCMLFileName;// this is the file we're using to bind.
    CRCMLListens *  pRCMLListener;  // this is the tree.
} RCMLHWND, * PRCMLHWND;

#pragma data_seg(".shdata")

//
// A array of HWNDs that are speech enabled.
// should be a thread safe array.
//
#define MAX_MAPPING 12
RCMLHWND g_hwndRCML[MAX_MAPPING];
HHOOK g_hhookShell=NULL;
HINSTANCE g_hDllInst    = 0;
HWINEVENTHOOK g_WinEventHook=0;
CRITICAL_SECTION g_CritSec={0};
LONG    g_Lock=0;
HWND    g_hStatus;  // the status hwnd.
HWND    g_hList;    // the ListView.
#pragma data_seg()

void BindRCMLToWindows( LPCWSTR szFileName, LPCWSTR pszDlgTitle, HWND hwnd );
void SeeIfWeHaveRCML( LPCWSTR pszModuleName, LPCWSTR pszId, LPCWSTR pszDlgTitle, HWND hwndToBindTo );
void GetModule( LPWSTR pszOutModuleName, UINT cbOutModuleName, HWND hwnd );
void GetWindowTitle( LPWSTR * ppszTitle , HWND hWnd);
void LogInfo(LPCWSTR szModuleName, LPCWSTR szTitle, LPCWSTR pszName);
void UnHook( PRCMLHWND pNode );
void CheckItem( PRCMLHWND pNode , BOOL bCheckState);


////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Just for a message pump.
//
void MakeHiddenWindow()
{
}

void DestroyHiddenWindow()
{
}




////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Hooks us up to listen to an hwnd.
//
void Hookup(HWND hWnd)
{
    if( (hWnd == g_hList ) || (hWnd==g_hStatus) )
        return;

    if(IsWindow( hWnd ) )
    {
		TCHAR szModuleName[MAX_PATH];
        LPTSTR szTitle=NULL;
        UINT ui=sizeof(szModuleName);
        GetModule( szModuleName, sizeof(szModuleName), hWnd );
        GetWindowTitle( &szTitle, hWnd );
        //
        // For dialogs we use their title to be unique (kinda).
        // for window classes (e.g. top level applications) we use their class name.
        //
        LPTSTR pszWindowIdentifier = szTitle;
        TCHAR szClassName[MAX_PATH];
        if ( GetClassName( hWnd, szClassName, MAX_PATH ) )
        {
            // TRACE(TEXT("*** We have focus on '%s' of class '%s'\n"), szTitle, szClassName );
            if( szClassName[0]!=TEXT('#') )
            {
                pszWindowIdentifier = szClassName;
                SeeIfWeHaveRCML( szModuleName, pszWindowIdentifier, szTitle, hWnd );
            }
            else
            {
                // LogInfo( szModuleName, szTitle, szClassName );
                RECT rect;
                GetClientRect( hWnd, &rect );
                TCHAR szID[MAX_PATH];
                wsprintf(szID, TEXT("%s (%dx%d)"), pszWindowIdentifier, rect.right, rect.bottom );
                SeeIfWeHaveRCML( szModuleName, szID, szTitle, hWnd );
            }
        }
		delete szTitle;
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// GetMessageHook gets everything!
// You get the "Property Sheet itself" on the SYSTEM_DIALOGSTART and SYSTEM_FOREGROUND
// for the PAGES, you hook...EVENT_OBJECT_SELECTION 
//
VOID CALLBACK WinEventHookProc(
  HWINEVENTHOOK hWinEventHook,
  DWORD event,
  HWND hWnd,
  LONG idObject,
  LONG idChild,
  DWORD dwEventThread,
  DWORD dwmsEventTime
)
{
    //
    // Focus or creation, pretty much the same, bind RCML to a set of HWNDs.
    //
    if( event == EVENT_OBJECT_FOCUS )
    {
        if( IsWindow(hWnd) )
        {
            GUITHREADINFO guiInfo;
            guiInfo.cbSize = sizeof(guiInfo);
            if( GetGUIThreadInfo( NULL, &guiInfo ) )
            {
                if( (guiInfo.flags & GUI_INMENUMODE ) == FALSE )
                {
                    if( guiInfo.hwndActive != NULL )
                    {
                        // TRACE(TEXT("++++ HWND 0x%08x and 0x%08x\n"), guiInfo.hwndActive, guiInfo.hwndFocus );
                        Hookup(guiInfo.hwndActive); // should be the dialog itself.

                        HWND hPotentialPage = guiInfo.hwndFocus;
                        while( (hPotentialPage!=NULL) && (hPotentialPage  != guiInfo.hwndActive ) )
                        {
                            DWORD dwStyleEx =  GetWindowLong(hPotentialPage, GWL_EXSTYLE);
                            if( dwStyleEx & WS_EX_CONTROLPARENT )
                                break;  // this COULD be a sheet??
                            hPotentialPage=GetParent( hPotentialPage );
                        }

                        if( (hPotentialPage != NULL) && (hPotentialPage  != guiInfo.hwndActive ) )
                            Hookup(hPotentialPage);
                    }
                }
            }
        }
	}

    if( event == EVENT_SYSTEM_FOREGROUND )
    {
        // TRACE(TEXT("We should cleanup\n"));
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// when we load, we register the hook
// we watch how many times we load (once for every process?)
// and how many times we unload, and then terminate ourselves
//
BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
	g_hDllInst = (HINSTANCE)hModule;
    return TRUE;
}


//
// These are called by the 'launching' exe, to turn on and then off the hook
//
extern"C"
{
_declspec(dllexport) void TurnOnHooks(HWND hStatusWindow)
{
	if( g_hhookShell == NULL )
	{
        // This only sees top level windows - application schema.
		// g_hhookShell = SetWindowsHookEx(  WH_SHELL, ShellHookProc, (HMODULE)g_hDllInst, 0 );

        // This sees the dialogs BEFORE they have children.
		// g_hhookShell = SetWindowsHookEx(  WH_CBT, CBTHookProc, (HMODULE)g_hDllInst, 0 );

        // This sees only the PostMessgaes!
		// g_hhookShell = SetWindowsHookEx(  WH_GETMESSAGE, GetMessageHookProc, (HMODULE)g_hDllInst, 0 );

        // This sees All the messgaes - and is the closest to working.
		// g_hhookShell = SetWindowsHookEx(  WH_CALLWNDPROCRET, CallWndProcHookProc, (HMODULE)g_hDllInst, 0 );

        g_WinEventHook = SetWinEventHook( 
            EVENT_SYSTEM_FOREGROUND , 
            EVENT_OBJECT_FOCUS , 
            g_hDllInst,
            WinEventHookProc,
            0,
            0,
            WINEVENT_OUTOFCONTEXT | WINEVENT_SKIPOWNPROCESS); // WINEVENT_OUTOFCONTEXT ); // WINEVENT_INCONTEXT ); //  | WINEVENT_SKIPOWNPROCESS );

        g_hStatus = hStatusWindow;
        g_hList = GetDlgItem( g_hStatus, 1002);     // NOTE HARD CODED.

        // Init the list.
        ListView_SetExtendedListViewStyleEx( g_hList, 0, LVS_EX_CHECKBOXES);

        LV_COLUMN col={0};
        col.mask = LVCF_FMT | LVCF_ORDER | LVCF_TEXT | LVCF_WIDTH;
        col.fmt |= LVCFMT_LEFT;
        col.pszText = TEXT("Listening");
        col.cx = LVSCW_AUTOSIZE_USEHEADER;
        col.iOrder = 0;
        int iCol = ListView_InsertColumn( g_hList, 0, &col );

        if( col.cx < 0 )
            ListView_SetColumnWidth( g_hList, iCol, col.cx );

        col.mask = LVCF_FMT | LVCF_ORDER | LVCF_TEXT | LVCF_WIDTH;
        col.fmt |= LVCFMT_LEFT;
        col.pszText = TEXT("HWND");
        col.cx = LVSCW_AUTOSIZE;
        col.iOrder = 1;
        iCol = ListView_InsertColumn( g_hList, 1, &col );

        if( col.cx < 0 )
            ListView_SetColumnWidth( g_hList, iCol, col.cx );

	}

    //
    // Throw up a Window for a message pump!
    //
    MakeHiddenWindow();
    InitializeCriticalSection( & g_CritSec );
}

_declspec(dllexport) TurnOffHooks()
{
    DestroyHiddenWindow();
    if( g_hhookShell)
	    UnhookWindowsHookEx( g_hhookShell );

    if( g_WinEventHook )
        UnhookWinEvent( g_WinEventHook );

    //
    // UnHook all the RCML.
    //
    for(int i=0;i< MAX_MAPPING ; i++)
    {
        if( g_hwndRCML[i].pRCMLListener )
            UnHook( &g_hwndRCML[i] );
    }

	g_hhookShell=NULL;
    DeleteCriticalSection( &g_CritSec );
}

}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Tears down the RCML nodes, uninitializes, and turns off the speech recognition stuff.
//
void UnHook( PRCMLHWND pNode )
{
    CheckItem(pNode, FALSE );

    LVFINDINFO fi={0};
    fi.flags = LVFI_PARAM;
    fi.lParam = (LPARAM)pNode;
    int iFound;
    if( (iFound=ListView_FindItem( g_hList, -1, &fi )) != -1)
    {
        ListView_DeleteItem( g_hList, iFound );
    }
    else
    {
        // Not present in the list??
    }

    pNode->hwnd = NULL;
    if( pNode->pRCMLListener )
    {
        TRACE(TEXT("Unbinding '%s'\n"), pNode->pszRCMLFileName );
        pNode->pRCMLListener->Stop();
        delete pNode->pRCMLListener;
        pNode->pRCMLListener=NULL;
    }
    delete pNode->pszRCMLFileName;
    pNode->pszRCMLFileName=NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Kinda annoying
// set the UI status, but performs the nitty gritty of binding to an HWND
// or turning rules off.
// Checks the old state, so doesn't end up rebinding all the time.
//
void CheckItem( PRCMLHWND pNode , BOOL bCheckState)
{
    LVFINDINFO fi={0};
    fi.flags = LVFI_PARAM;
    fi.lParam = (LPARAM)pNode;
    int iFound=ListView_FindItem( g_hList, -1, &fi );
    BOOL bOldState = pNode->bActive;
    pNode->bActive=bCheckState;
    if( iFound != -1)
    {
        ListView_SetCheckState( g_hList, iFound, bCheckState );
        TCHAR szB[20];
        wsprintf(szB,TEXT("%08x"),pNode->hwnd);
        ListView_SetItemText( g_hList, iFound, 1, szB);
    }
    else
    {
        // Not present in the list??
    }

    if( (bCheckState != bOldState ) || pNode->bFocusChange )
    {
        if(bCheckState)
        {
            if( pNode->pRCMLListener )
            {
                if( SUCCEEDED(pNode->pRCMLListener->MapToHwnd( pNode->hwnd )))
                {
                }
                else
                {
                    // pNode->pRCMLListener->TurnOffRules();
                    // ListView_SetCheckState( g_hList, iFound, FALSE );
                    // pNode->bActive=FALSE;
                }
            }
        }
        else
        {
            if( pNode->pRCMLListener )
                pNode->pRCMLListener->TurnOffRules();
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// See if there is an RCML dialog that maps to this runtime dialog.
// this is just a registry lookup, if we find something, we then call off to bind it
//
// ID is the classname or the dialog title
// DlgTitle is always the title, we use that to display to the user.
//
void SeeIfWeHaveRCML( LPCWSTR pszModuleName, LPCWSTR pszID, LPCWSTR pszDlgTitle, HWND hwndToBindTo )
{
	HKEY hK;
    if(*pszModuleName==0)
        return;
    if(*pszDlgTitle==0)
        return;

    BOOL bFoundFileMapping=FALSE;
	if( RegOpenKey( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RCML\\SideBand"), &hK ) == ERROR_SUCCESS )
	{
		HKEY hkFile;
		if( RegOpenKey( hK, pszModuleName, &hkFile ) == ERROR_SUCCESS )
		{

			// there is a look aside RCML file for this dialog
			DWORD dwType=REG_SZ;
			TCHAR szFileName[MAX_PATH];
			DWORD cbFileName=sizeof(szFileName);
			if( RegQueryValueEx( hkFile, pszID, NULL, &dwType, (LPBYTE)szFileName, &cbFileName) == ERROR_SUCCESS )
            {
                BindRCMLToWindows( szFileName , pszDlgTitle, hwndToBindTo );
                bFoundFileMapping=TRUE;
#ifdef _LOG_INFO
	            HKEY d_hK;
	            if( RegOpenKey( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RCML\\SideBand"), &d_hK ) == ERROR_SUCCESS )
                {
		            RegSetValueEx( d_hK, TEXT("RCML"),NULL, REG_SZ, (LPBYTE)szFileName, (lstrlen(szFileName)+1)*sizeof(TCHAR) );
		            RegCloseKey(d_hK);
	            }
#endif
            }
			RegCloseKey( hkFile );
		}

        if( bFoundFileMapping == FALSE )
        {
            //
            // Runtime generate the RCML files for the customer!
            //
            // -o is a directory
            // -f is the filename
            //
            TCHAR directory[MAX_PATH];
            wsprintf(directory,TEXT("c:\\cicerorcml\\CFG\\%s"), pszModuleName);

            TCHAR shortFile[MAX_PATH];
            wsprintf(shortFile,TEXT("%s"),pszID); // pszDlgTitle);

            TCHAR args[1024];
            wsprintf(args,TEXT("c:\\cicerorcml\\RCMLGen.exe  -x -e -v -w %d -o \"%s\" -f \"%s\""),
                hwndToBindTo, directory, shortFile );

            TRACE(TEXT("++--++ Executing %s\n"), args);

            //
            // May / or may not actually help in getting the file BEFORE we try to bind to it
            //
			STARTUPINFO startup;
			PROCESS_INFORMATION pi;
			startup.cb = sizeof(startup);
			startup.lpReserved = NULL;
			startup.lpDesktop = NULL;
			startup.lpTitle = NULL;
			startup.dwFlags = 0L;
			startup.cbReserved2 = 0;
			startup.lpReserved2 = NULL;
            if (CreateProcess(NULL,  args, NULL, NULL, FALSE, CREATE_NEW_PROCESS_GROUP,
                              NULL, TEXT("c:\\cicerorcml"), &startup, &pi))
            {
				WaitForInputIdle( pi.hProcess, INFINITE ); 

                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
            }

            //
            // We should have the file now, bind to it.
            //
            HKEY hkModule;
            if( RegCreateKey( hK, pszModuleName, &hkModule ) == ERROR_SUCCESS )
            {
                TCHAR file[MAX_PATH];
                wsprintf(file,TEXT("%s\\%s.RCML"),directory,shortFile);
                RegSetValueEx( hkModule, pszID, NULL, REG_SZ, (LPBYTE)file, (lstrlen(file)+1) * sizeof(TCHAR) );
                RegCloseKey(hkModule);
                BindRCMLToWindows( file , pszDlgTitle, hwndToBindTo );   // not sure if ShellExecute is blocking.
            }
        }

	    RegCloseKey(hK);
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Actually does the work of binding the RCML tree to the Win32 goo
// we may re-use a existing tree, and simply re-parent it.
// need to put a critsection around this.
// unfortunately being a win event thing, user manages to get our thread to re-enter this code!
//
//
void BindRCMLToWindows( LPCWSTR szFileName, LPCWSTR pszWindowText, HWND hwnd )
{
    //
    // Walk the list of RCML files to find a running tree.
    //
    TRACE(TEXT("**** We have an RCML file association : %s to \"%s\", 0x%08x\n"), 
        szFileName , pszWindowText, hwnd );

    PRCMLHWND pUsedSlot=NULL;
    CRCMLListens * pRootNode=NULL;
    for(int i=0;i< MAX_MAPPING ; i++)
    {
        if( lstrcmpi( szFileName, g_hwndRCML[i].pszRCMLFileName) == 0 )
        {
            pRootNode = g_hwndRCML[i].pRCMLListener ;   // we already have this file mapped.

            if( g_hwndRCML[i].hwnd != hwnd )
                g_hwndRCML[i].bFocusChange = TRUE;
            else
                g_hwndRCML[i].bFocusChange = FALSE;
            g_hwndRCML[i].hwnd = hwnd;
            pUsedSlot = &g_hwndRCML[i];

            TRACE(TEXT("**** we have a tree for this already\n"));
            break;
        }
    }

    //
    // We haven't found this RCML file loaded yet - load it.
    //
    if( pRootNode == NULL )
    {
        TRACE(TEXT("--- NO TREE mapping it\n"));
        int i;
        int iFreeSlot=-1;

        //
        // Find a free listener slot - not HWND related.
        //
        BOOL bFreeSlot=FALSE;
        for(i=0;i< MAX_MAPPING ; i++)
        {
            if( g_hwndRCML[i].pRCMLListener == NULL )
            {
                bFreeSlot=TRUE;
                iFreeSlot=i;
                break;
            }
        }

        //
        // We have run out of active slots, and punt any active RCML tree
        // whose window is no longer present.
        //
        if( bFreeSlot == FALSE )
        {
            TRACE(TEXT("Punting RCML bound to non-visible windows\n"));
            for(i=0;i< MAX_MAPPING ; i++)
            {
                if( IsWindow(g_hwndRCML[i].hwnd) == FALSE )
                {
                    UnHook(&g_hwndRCML[i]);
                    if(iFreeSlot==-1)
                        iFreeSlot=i;
                }
            }
        }

        //
        // Now find the first free slot.
        //
        if( iFreeSlot!=-1)
        {
            i = iFreeSlot;
            if( g_hwndRCML[i].hwnd == NULL )
            {
                g_hwndRCML[i].hwnd = hwnd;
                pUsedSlot = &g_hwndRCML[i];

                if( g_hwndRCML[i].pRCMLListener )
                    delete g_hwndRCML[i].pRCMLListener;

                g_hwndRCML[i].pszRCMLFileName = new TCHAR[lstrlen(szFileName)+1];
                lstrcpy( g_hwndRCML[i].pszRCMLFileName, szFileName );   // remember the filename

                pRootNode = g_hwndRCML[i].pRCMLListener = new CRCMLListens( szFileName, hwnd);

                g_hwndRCML[i].pRCMLListener->Start();

                //
                // Add the item to the list if it's not already there
                //
                LVFINDINFO fi={0};
                fi.flags = LVFI_STRING;
                fi.psz=pszWindowText;
                int iFound;
                if( (iFound=ListView_FindItem( g_hList, -1, &fi )) != -1)
                {
                }
                else
                {
                    LVITEM lvi={0};
                    lvi.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
                    lvi.iItem = 0;
                    lvi.pszText = (LPTSTR)pszWindowText;
                    lvi.lParam = (LPARAM) pUsedSlot;
                    int iFound=ListView_InsertItem( g_hList, & lvi );
                }
                CheckItem(pUsedSlot, TRUE);
            }
        }
    }

    //
    // remember which window we THINK has voice focus.
    // go through the list of active things, and see if we should turn any off.
    //
    GUITHREADINFO guiInfo;
    guiInfo.cbSize = sizeof(guiInfo);
    if( GetGUIThreadInfo( NULL, &guiInfo )==FALSE )
    {
        guiInfo.hwndActive = NULL;
        guiInfo.hwndFocus = NULL;
    }

    // TRACE(TEXT("Active Window 0x%08x and Focus is 0x%08x\n"), guiInfo.hwndActive, guiInfo.hwndFocus );

    for(i=0;i< MAX_MAPPING ; i++)
    {
        // if it's no longer a window, or doesn't have focus or selection,
        if( g_hwndRCML[i].hwnd == NULL )
            continue;

        // TRACE(TEXT(" Window %03d = 0x%08x"),i,g_hwndRCML[i].hwnd);
        if( IsWindow( g_hwndRCML[i].hwnd ) == FALSE )
        {
            // We have an RCML tree, but the window isn't around to respond to input.
            CheckItem(&g_hwndRCML[i], FALSE);
        }
        else
        {
            if( IsWindow( guiInfo.hwndFocus  ) )
            {
                // The window has voice focus if.
                // 1) It is the active window.
                // 2) The control with focus is a child of the active window &&
                //    a child of us.
                //
                // The tree is present, but the window doesn't have 'voice focus'
                // if it's the active window, of course it has speech focus.
                BOOL bWithSpeechFocus = (g_hwndRCML[i].hwnd == guiInfo.hwndActive);
                if( !bWithSpeechFocus )
                {
                    // All pages on a sheet are children of the active window (the sheet).
                    if( IsChild( g_hwndRCML[i].hwnd , guiInfo.hwndFocus ) )
                        bWithSpeechFocus = IsChild( guiInfo.hwndActive, g_hwndRCML[i].hwnd );
                }

#ifdef DEBUG_2
                TRACE(TEXT("Active Window 0x%08x and Focus is 0x%08x, checking 0x%08x = %s\n"),
                    guiInfo.hwndActive, guiInfo.hwndFocus , g_hwndRCML[i].hwnd,
                    bWithSpeechFocus?TEXT("Focus"):TEXT("No Focus"));
#endif

                CheckItem(&g_hwndRCML[i], bWithSpeechFocus);
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Finds the short version of the module name
//
void GetModule( LPWSTR pszOutModuleName, UINT cbOutModuleName, HWND hwnd )
{
    *pszOutModuleName=0;
    if( IsWindow(hwnd)==FALSE)
        return;

    TCHAR szPath[MAX_PATH];
   	HMODULE hModule = (HMODULE)GetWindowLong(hwnd, GWL_HINSTANCE);
	if( GetModuleFileName( hModule, szPath, sizeof(szPath) ) )
    {
	    LPTSTR pszModuleName=szPath;
	    LPTSTR pszTemp=pszModuleName;
	    while( *pszTemp != 0 )
        {
		    if( *pszTemp++=='\\')
			    pszModuleName = pszTemp;
	    }
        if( *pszModuleName )
            lstrcpyn( pszOutModuleName, pszModuleName, cbOutModuleName );
        else
            *pszOutModuleName=0;
    }
    else
    {
        DWORD dwProcessID;
        DWORD dwThreadID = GetWindowThreadProcessId( hwnd, &dwProcessID );
        HANDLE hProcess = OpenProcess( PROCESS_QUERY_INFORMATION |
                                    PROCESS_VM_READ, FALSE, dwProcessID);
        DWORD dwModuleSize=128;
        HMODULE hm[128];
        if( EnumProcessModules( hProcess, hm, sizeof(hm), &dwModuleSize ) )
        {
            // HMODULE * pModules=new HMODULE[dwModuleSize/sizeof(HMODULE)];
            // if( EnumProcessModules( hProcess, pModules, dwModuleSize, &dwModuleSize ) )
            {
                UINT mSize=sizeof(hm);
                if( dwModuleSize < mSize )
                    mSize=dwModuleSize;

                for(UINT i=0;i<dwModuleSize/sizeof(HMODULE);i++)
                {
                    if( hm[i] == hModule )
                    {
    	                if( GetModuleFileNameEx( hProcess, hm[i], szPath, sizeof(szPath) ) )
                        {
	                        LPTSTR pszModuleName=szPath;
	                        LPTSTR pszTemp=pszModuleName;
	                        while( *pszTemp != 0 )
	                        {
		                        if( *pszTemp++=='\\')
			                        pszModuleName = pszTemp;
	                        }
                            if( *pszModuleName )
                                lstrcpyn( pszOutModuleName, pszModuleName, cbOutModuleName );
                            else
                                *pszOutModuleName=0;
                            break;
                        }
                    }
                }
            }
            // delete pModules;
        }
        else
        {
            DWORD dwGLE= GetLastError();
            TRACE(TEXT("Can't get process info on 0x%08x (or 0x%08x), gle=%d"),dwProcessID,hProcess,dwGLE);
        }
        CloseHandle(hProcess);
    }
    // TRACE(TEXT("Module for HWND=0x%04x is %s\n"),hwnd,pszOutModuleName);
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Gets the WindowTitle, assumes buffer is NULL to begin with.
//
void GetWindowTitle( LPWSTR * ppszTitle , HWND hWnd)
{
   	int dwTitleSize=GetWindowTextLength( hWnd )+2;
    if( dwTitleSize > 2 )
    {
	    *ppszTitle=new TCHAR[dwTitleSize];
        if ( GetWindowText( hWnd, *ppszTitle, dwTitleSize ) )
        {
            LPWSTR pszChars=*ppszTitle;
            while( *pszChars ) 
            {
                if( *pszChars < 32 )
                    *pszChars=0;
                else
                    pszChars++;
            }
        }
        else
            **ppszTitle=0;
    }
    else
    {
        TRACE(TEXT("Cannot get the title from hwnd 0x%08x\n"), hWnd );
	    *ppszTitle=new TCHAR[2];
        **ppszTitle=0;
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Simple Logging
//
void LogInfo(LPCWSTR szModuleName, LPCWSTR szTitle, LPCWSTR pszName)
{
    //
	// For debugging we log this in the registry.
	//
#ifdef _LOG_INFO
    if( lstrcmpi( szTitle, TEXT("Registry Editor") ))
    {
	    HKEY d_hK;
	    if( RegOpenKey( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RCML\\SideBand"), &d_hK ) == ERROR_SUCCESS )
	    {
		    RegSetValueEx( d_hK, TEXT("ModuleName"),NULL, REG_SZ, (LPBYTE)szModuleName, (lstrlen(szModuleName)+1)*sizeof(TCHAR) );
		    RegSetValueEx( d_hK, TEXT("DialogTitle"), NULL, REG_SZ, (LPBYTE)szTitle, (lstrlen(szTitle)+1)*sizeof(TCHAR) );
		    RegSetValueEx( d_hK, TEXT("DialogName"), NULL, REG_SZ, (LPBYTE)pszName, (lstrlen(pszName)+1)*sizeof(TCHAR) );
		    RegCloseKey(d_hK);
	    }
    }
#endif
}



// -----------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// this is the Shell hook itself.
// gets called for TOPLEVEL window creation, not dialogs of apps.
//
LRESULT CALLBACK ShellHookProc(int code, WPARAM wparam, LPARAM lparam)	// HOOKPROC
{
    if (code == HSHELL_WINDOWCREATED)
	{
		HWND hwnd = (HWND)wparam;
	    TCHAR szCaption[128];
	    TCHAR szAppname[128];
        
        GetWindowText(hwnd, szCaption, 128);

        GetModuleFileName((HMODULE)GetWindowLong(hwnd, GWL_HINSTANCE), szAppname, 128);
        
		int i=5;
	}
	else
	if( code == HSHELL_WINDOWDESTROYED )
	{
	}

    return CallNextHookEx(g_hhookShell, code, wparam, lparam);
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This is a CBTHook, pretty much the same
// Gets called for every create window, EVERY, create window.
// we I check and check it to be a DIALOG class, 0x8002, I guess I could check
// owned, but not WS_CHILD??
//
LRESULT CALLBACK CBTHookProc(int code, WPARAM wparam, LPARAM lparam)	// HOOKPROC
{
	if( code < 0 )
	    return CallNextHookEx(g_hhookShell, code, wparam, lparam);

    if (code == HCBT_CREATEWND )
	{
    }
	else
	if( code == HCBT_DESTROYWND )
	{
		HWND hWnd = (HWND)wparam;
	}

    return CallNextHookEx(g_hhookShell, code, wparam, lparam);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// GetMessageHook gets everything posted.
//
//
LRESULT CALLBACK GetMessageHookProc(int code, WPARAM wparam, LPARAM lparam)
{
    MSG * pMessage=(MSG*)lparam;

	if( (code != HC_ACTION) || (code < 0 ) )
	    return CallNextHookEx(g_hhookShell, code, wparam, lparam);

    return CallNextHookEx(g_hhookShell, code, wparam, lparam);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// GetMessageHook gets everything!
//
LRESULT CALLBACK CallWndProcHookProc(int code, WPARAM wparam, LPARAM lparam)
{
    PCWPRETSTRUCT pInfo=(PCWPRETSTRUCT)lparam;

	if( (code != HC_ACTION) || (code < 0 ) )
	    return CallNextHookEx(g_hhookShell, code, wparam, lparam);

    return CallNextHookEx(g_hhookShell, code, wparam, lparam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\speechhook\spchhk\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__9226302C_D3C2_441D_BAA4_4273D798B2F0__INCLUDED_)
#define AFX_STDAFX_H__9226302C_D3C2_441D_BAA4_4273D798B2F0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9226302C_D3C2_441D_BAA4_4273D798B2F0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlgen\cmdline.h ===
//
// Command line processing header file
//

//
//
//
#define CMDLINE_BEGIN(cmdLine, firstarg, rubbish, wantQuotes) \
    {                                                           \
    LPTSTR pszArgs=new TCHAR[lstrlen(cmdLine)*sizeof(TCHAR)+4]; \
    lstrcpy(pszArgs,lpCmdLine);                                 \
    lstrcat(pszArgs,TEXT(" "));                                 \
    LPTSTR pszSwitch=pszArgs;                                   \
    LPTSTR lastArg=pszArgs;                                     \
    LPTSTR * ppszRubbish=rubbish;                   \
    LPTSTR * ppszDest=firstarg;                     \
    BOOL    bInQuotes=FALSE;                        \
    BOOL    bStripQuotes=wantQuotes;                \
    while(*pszSwitch!=0)                            \
    {                                               \
        if( *pszSwitch==TEXT('"') )                 \
        {                                           \
            if( bStripQuotes )                      \
            {                                       \
                if(bInQuotes)                       \
                    *pszSwitch=TEXT(' ');           \
                else                                \
                    lastArg=pszSwitch+1;            \
            }                                       \
            bInQuotes=!bInQuotes;                   \
        }                                           \
                                                    \
        if( (bInQuotes==FALSE) && (*pszSwitch==TEXT(' ')) ) \
        {                                           \
            *pszSwitch=NULL;                        \
            if( *lastArg==TEXT('/') )               \
                *lastArg=TEXT('-');                 \
            if(FALSE)                               \
            {}                                      \


//
// Each argument
//
#define CMDLINE_TEXTARG(Switch, Destination)        \
    else if(lstrcmpi(lastArg,TEXT(Switch))==0)      \
    {    ppszDest=Destination;   }                  \


#define CMDLINE_SWITCH(Switch, Destination)         \
    else if(lstrcmpi(lastArg,TEXT(Switch))==0)      \
    {   ppszDest=ppszRubbish;                       \
        *Destination=TRUE;   }                      \


//
// 
//
#define CMDLINE_END()                               \
            else                                    \
            {                                       \
                if( *lastArg =='-' )                \
                { /* Some Error */                  \
                }                                   \
                else                                \
                {                                   \
                   *ppszDest=new TCHAR[lstrlen(lastArg)+1]; lstrcpy(*ppszDest,lastArg); \
                }                                   \
                ppszDest=ppszRubbish;               \
            }                                       \
            lastArg=pszSwitch+1;                    \
        }                                           \
        pszSwitch++;                                \
    }                                               \
    delete pszArgs;                                 \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlgen\debug.h ===
//
//
//

#ifdef _DEBUG
void FAR _cdecl 
TRACE(
	LPTSTR lpszFormat, 
	...);

#else
#define TRACE 0?0:
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\speechhook\spchhk\rcmllistens.cpp ===
// RCMLListens.cpp: implementation of the CRCMLListens class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "RCMLListens.h"
#include "rcml.h"
#include "debug.h"
// #include "commctrl.h"

#include "tunaclient.h"

CTunaClient  CRCMLListens::g_TunaClient;
BOOL         CRCMLListens::g_TunaInit;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRCMLListens::CRCMLListens(LPCTSTR szFileName, HWND hwnd)
{
    lstrcpyn( m_szFile, szFileName, MAX_PATH);
    m_hwnd=hwnd;
    m_bInitedRCML=FALSE;
    m_pRootNode=NULL;
    m_uiLastTip=0;
    m_hwndTT=NULL;
}

CRCMLListens::~CRCMLListens()
{
    UnBind();     // we need to pro-actively stop the speech recognition.
}


//
// Starts the thread
// we build the RCML node stuff, init the nodes, walk again, get the events they
// are waiting for - how do we communicate this, to use events not a callback?
// the cicero.dll can't really do that for us I don't think, as each node is independent.
// hmm.
//
void CRCMLListens::Process(void)
{
    HRESULT hr;
    m_pRootNode=NULL;
    if( SUCCEEDED( hr=RCMLLoadFile( m_szFile, 0, &m_pRootNode )))
    {
        //
        // what do we do now? Init the tree?
        //
#ifdef _LOG_INFO
        TCHAR szBuffer[1024];
        wsprintf(szBuffer, TEXT(" ++++++ File %s bound to HWND 0x%08x\n"), m_szFile, hwnd );
        OutputDebugString( szBuffer );
	    HKEY d_hK;
	    if( RegOpenKey( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RCML\\SideBand"), &d_hK ) == ERROR_SUCCESS )
	    {
		    RegSetValueEx( d_hK, TEXT("Bind RCML"),NULL, REG_SZ, (LPBYTE)szBuffer, (lstrlen(szBuffer)+1)*sizeof(TCHAR) );
		    RegCloseKey(d_hK);
	    }
#endif
        HWND hwnd=m_hwnd;   // YUCK, forces the mapping!
        m_hwnd=NULL;
        MapToHwnd(hwnd);

        m_pRootNode->AddRef();

        WaitForSingleObject( GetEvent(), INFINITE);

        m_pRootNode->Release();
    }
}

//
// Stops the RCML from listening.
//
EThreadError CRCMLListens::Stop(void)
{
    return BASECLASS::Stop();
}

//
// HWND is the parent window - OR NULL.
//
HRESULT CRCMLListens::MapToHwnd(HWND hwnd)
{
    //
    // If we were using the cache, or a new tree, do a binding.
    //
    if( m_pRootNode==NULL)
        return E_INVALIDARG;    // hmm.

    if( IsWindow( hwnd ) == FALSE )
    {
        TRACE(TEXT("The window 0x%08x isn't valid\n"),hwnd);
        return E_INVALIDARG;
    }

    if( m_hwnd == hwnd )
    {
        TRACE(TEXT("--- Already bound %s to window 0x%08x\n"), m_szFile, hwnd );
        return S_OK;
    }

    TRACE(TEXT("--- Binding %s to window 0x%08x\n"), m_szFile, hwnd );
    m_hwnd = hwnd;
    HRESULT hr;

    //
    // This turns on or off the rules on the dialog itself (the menu).
    //
    IRCMLControl * pControl;
    if( SUCCEEDED( m_pRootNode->QueryInterface( __uuidof( IRCMLControl), (LPVOID*)&pControl )))
    {
        // if( m_bInitedRCML == FALSE )
        //    pControl->OnInit(NULL);     // so we don't screw with fonts.
        pControl->put_Window(hwnd);
        TRACE(TEXT("Mapping to 0x%08x \n"), hwnd );
        if(hwnd!=NULL)
            SetElementRuleState( pControl, L"YES", NULL );
        else
            SetElementRuleState( pControl, L"NO", NULL );
        pControl->Release();
    }

    //
    // Turns on all the controls on/off the page
    //
    IEnumUnknown * pEnum;
    IRCMLNode *pTipControl=NULL;
    UINT    uiControlIndex=0;
    if( SUCCEEDED( hr=m_pRootNode->GetChildEnum( & pEnum )))    // enumerate the children of the dialog
    {
        IUnknown * pUnk;
        ULONG got;
        while( pEnum->Next( 1, &pUnk, &got ) == S_OK )
        {
            if( got )
            {
                IRCMLControl * pControl;
                if( SUCCEEDED( pUnk->QueryInterface( __uuidof( IRCMLControl ), (LPVOID*) & pControl )))
                {
                    LPWSTR pszID;
                    if( SUCCEEDED( pControl->get_ID( & pszID )))
                    {
                        if( HIWORD(pszID) == 0 )
                        {
                            if( hwnd!= NULL)
                            {
                                HWND hwndCtrl = GetDlgItem( hwnd, LOWORD(pszID ) );
                            
                                if( hwndCtrl )
                                {
                                    // we only init the node the FIRST time it's loaded.
                                    if( m_bInitedRCML == FALSE )
                   	                    pControl->OnInit(NULL);     // so we don't mess with fonts.
                                    pControl->put_Window(hwndCtrl);
                                    IRCMLNode * pCiceroNode=NULL;
                                    SetElementRuleState( pControl, L"YES", &pCiceroNode );

                                    //
                                    // try to find uiControlIndex is the current control.
                                    // m_uiLastTip was the last control we showed.
                                    //
                                    if( pCiceroNode )
                                    {
                                        if( uiControlIndex >= m_uiLastTip )
                                        {
                                            if( pTipControl == NULL )
                                            {
                                                if( SUCCEEDED( pCiceroNode->QueryInterface( __uuidof( IRCMLNode ),
                                                    (LPVOID*)&pTipControl ) ))
                                                {
                                                    m_uiLastTip=uiControlIndex;
                                                }
                                            }
                                        }
                                        pCiceroNode->Release();
                                    }
                                }
                            }
                            else
                            {
                                pControl->put_Window(NULL);
                                SetElementRuleState( pControl, L"NO", NULL );
                            }
                        }
                    }
                    pControl->Release();
                }
                uiControlIndex++;
            }
        }
        m_bInitedRCML=TRUE;
        pEnum->Release();

        m_uiLastTip++;
        if(m_uiLastTip > uiControlIndex )
            m_uiLastTip=0;
    }

    //
    // If we managed to turn the rules on/off, beep and show a tooltip
    //
    if( SUCCEEDED(hr) )
    {
       MessageBeep(MB_ICONHAND);
       if(pTipControl)
       {
           // See if we have a CICERO node as a child with some tooltip text.
           ShowTooltip( pTipControl );
           pTipControl->Release();
       }
    }
    return hr;
}

HRESULT CRCMLListens::UnBind()
{
    IEnumUnknown * pEnum;
    if(m_pRootNode==NULL)
        return S_OK;

    //
    // Turn off the rules on the dialog itself (menu)
    //
    IRCMLControl * pControl;
    if( SUCCEEDED( m_pRootNode->QueryInterface( __uuidof( IRCMLControl), (LPVOID*)&pControl )))
    {
        SetElementRuleState( pControl, L"NO", NULL );
        pControl->Release();
    }


    // enumerate the children of the dialog
    if( SUCCEEDED( m_pRootNode->GetChildEnum( & pEnum )))
    {
        IUnknown * pUnk;
        ULONG got;
        while( pEnum->Next( 1, &pUnk, &got ) == S_OK )
        {
            if( got )
            {
                IRCMLControl * pControl;
                if( SUCCEEDED( pUnk->QueryInterface( __uuidof( IRCMLControl ), (LPVOID*) & pControl )))
                {
                    pControl->OnDestroy( NULL, 0 ); // we don't know what info to provide.
                    pControl->Release();
                }
            }
        }
        pEnum->Release();
    }

    //
    // Tell the parent dialog it's going away, in RCML this walks the unknown children
    // and kills their nodes.
    //
    if( SUCCEEDED( m_pRootNode->QueryInterface( __uuidof( IRCMLControl), (LPVOID*)&pControl )))
    {
        pControl->OnDestroy( NULL, 0 ); // we don't know what info to provide.
        pControl->Release();
    }

    m_pRootNode-> Release();   // should take down the Cicero stuff too.
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Called when the focus moves away from this tree, we hvae to find the Cicero nodes
// and turn them off - note the HACKY way we do this through properties!
// saved me doing a custom interface!!!!!
//
HRESULT CRCMLListens::TurnOffRules()
{
    TRACE(TEXT("Trying to turn off rules on %s\n"),m_szFile);
                                               
    if(m_pRootNode==NULL)
        return S_OK;
    IEnumUnknown * pEnum;
    HRESULT hr;

    //
    // Turn off the rules on the dialog itself (menu)
    //
    IRCMLControl * pControl;
    if( SUCCEEDED( m_pRootNode->QueryInterface( __uuidof( IRCMLControl), (LPVOID*)&pControl )))
    {
        SetElementRuleState( pControl, L"NO", NULL );
        pControl->Release();
    }

    if( SUCCEEDED( hr=m_pRootNode->GetChildEnum( & pEnum ))) // enumerate the children of the dialog
    {
        IUnknown * pUnk;
        ULONG got;
        while( pEnum->Next( 1, &pUnk, &got ) == S_OK )
        {
            if( got )
            {
                IRCMLControl * pControl;
                if( SUCCEEDED( pUnk->QueryInterface( __uuidof( IRCMLControl ), (LPVOID*) & pControl )))
                {
                    SetElementRuleState( pControl, L"NO", NULL );
                    pControl->Release();
                }
            }
        }
        pEnum->Release();
    }
    m_hwnd=NULL;    // not live.
    return hr;
}


HRESULT CRCMLListens::SetElementRuleState( IRCMLControl * pControl, LPCWSTR pszState, IRCMLNode ** ppCiceroNode)
{
    // We have a control, walk it's namespace children.
    HRESULT hr;
    IEnumUnknown * pEnumNS;
    if( SUCCEEDED( hr=pControl->GetUnknownEnum( & pEnumNS ))) // walk the unknown children of this control
    {
        ULONG nsGot;
        IUnknown * pUnkNode;
        while( pEnumNS->Next( 1, &pUnkNode, &nsGot ) == S_OK )
        {
            if( nsGot )
            {
                IRCMLNode * pNode;
                if( SUCCEEDED( pUnkNode->QueryInterface( __uuidof( IRCMLNode ), (LPVOID*) & pNode )))
                {
                    WCHAR szPrefixWeNeed[]=L"CICERO:";

                    LPWSTR pszType;
                    if( SUCCEEDED(pNode->get_StringType( &pszType )))
                    {
                        lstrcpyn( szPrefixWeNeed, pszType, sizeof(szPrefixWeNeed)/sizeof(szPrefixWeNeed[0]) );
                        if(lstrcmpi( szPrefixWeNeed, L"CICERO:" )==0)
                        {
                            pNode->put_Attr( L"ENABLED", pszState );
                            if( ppCiceroNode )
                            {
                                *ppCiceroNode=pNode;
                                pNode->AddRef();
                            }
                        }
                    }
                    pNode->Release();
                }
            }
        }
        pEnumNS->Release();
    }
    return hr;
}


HRESULT CRCMLListens::ShowTooltip( IRCMLNode * pNode)
{
    HRESULT hr=S_OK;

    WCHAR szPrefixWeNeed[]=L"CICERO:";

    LPWSTR pszType;
    if( SUCCEEDED(pNode->get_StringType( &pszType )))
    {
        lstrcpyn( szPrefixWeNeed, pszType, sizeof(szPrefixWeNeed)/sizeof(szPrefixWeNeed[0]) );
        if(lstrcmpi( szPrefixWeNeed, L"CICERO:" )==0)
        {
            LPWSTR pszTip;
            if( SUCCEEDED( pNode->get_Attr(L"TOOLTIP", &pszTip )))
            {
                if( g_TunaInit==FALSE )
                {
                    g_TunaInit=TRUE;
                    g_TunaClient.SetPropertyName("Command Prompts");
                }
                g_TunaClient.SetText(pszTip);
            }
        }
    }
    return hr;
}

void CRCMLListens::ShowBalloonTip(LPWSTR pszText)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlgen\debug.cpp ===
//
//
//

#include "stdafx.h"
#include "debug.h"

#ifdef _DEBUG
void FAR _cdecl 
TRACE(
	LPTSTR lpszFormat, 
	...) 
{
	TCHAR	szBuf[1024];
	int	cchAdd;

	cchAdd = wvsprintf((LPTSTR)szBuf, lpszFormat, (LPSTR)(&lpszFormat + 1));
	OutputDebugString((LPCTSTR)szBuf);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\speechhook\spchhk\thread.h ===
//
// FelixA 1996
//
// A simple ThreadClass
//


#ifndef _THREAD_H
#define _THREAD_H

enum EThreadError
{
	successful,
	error,
	threadError,
	threadRunning,			// thread is already running.
	noEvent,				// we couldn't create and event, thread can't start
};

class CLightThread
{
public:
	HANDLE GetEvent();
	BOOL StopRunning();
	BOOL IsRunning();
	EThreadError GetStatus();
	CLightThread();
	virtual ~CLightThread();

	virtual void Process(void);
	virtual EThreadError Start(int iPriority=THREAD_PRIORITY_NORMAL);
	virtual EThreadError Stop(void);

	static LPTHREAD_START_ROUTINE ThreadStub(CLightThread *object);

private:
	EThreadError	m_status; 
	HANDLE			m_hThread;
	DWORD			m_dwThreadID;
	BOOL			m_bKillThread;
	HANDLE			m_hEndEvent;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlgen\dumpcache.h ===
// DumpCache.h: interface for the CDumpCache class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DUMPCACHE_H__4C38000D_34A8_46FF_A57E_31C2BDB83632__INCLUDED_)
#define AFX_DUMPCACHE_H__4C38000D_34A8_46FF_A57E_31C2BDB83632__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "fileencoder.h"

class CDumpCache  
{
	typedef struct _tagListElement
	{
		LPTSTR pString;
		BOOL	bDeleteString;
		struct _tagListElement* pNext;
	} LISTELEMENT, *PLISTELEMENT;

public:
    CDumpCache(CFileEncoder & fe);
	virtual ~CDumpCache();

	void AddChild(LPTSTR pszChild, BOOL bDeleteString);
	void AddAttribute(LPTSTR pszAttribute, BOOL bDeleteString);
	void AllocAddChild(LPTSTR pszChild, DWORD dwStrlen = 0);
	void AllocAddAttribute(LPCTSTR pszAttribute, DWORD dwStrlen = 0);

    //
    // Annoying - we know that WIN32:STYLE LOCATION and STYLE are children
    // what are other children. Shouldn't this be an array or something?
    //
	BOOL WriteElement(LPCTSTR pszElementName, 
        CDumpCache * pWin32=NULL,
        CDumpCache * pStyle=NULL, 
        CDumpCache * pLocation=NULL, 
        CDumpCache * pControl=NULL,
        CDumpCache * pCicero=NULL
        );
    void Write(LPTSTR pszString, BOOL bNewLine=TRUE) {     m_Encoder.Write(pszString,bNewLine); }

private:
	PLISTELEMENT m_Attributes;
	PLISTELEMENT m_Children;
	CFileEncoder & m_Encoder;
};

#endif // !defined(AFX_DUMPCACHE_H__4C38000D_34A8_46FF_A57E_31C2BDB83632__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlgen\dumpcache.cpp ===
// DumpCache.cpp: implementation of the CDumpCache class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DumpCache.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDumpCache::CDumpCache(CFileEncoder & fe)
 : m_Encoder(fe)
{
	m_Attributes = m_Children = NULL;
}

CDumpCache::~CDumpCache()
{
	PLISTELEMENT pErase, pNext = m_Attributes;
	while (pNext)
	{ 
		pErase = pNext;
		pNext = pNext->pNext;
		if( pErase->bDeleteString)
			delete pErase->pString;
		delete pErase;
	}
	pNext = m_Children;
	while (pNext)
	{ 
		pErase = pNext;
		pNext = pNext->pNext;
		if( pErase->bDeleteString)
			delete pErase->pString;
		delete pErase;
	}
}

void CDumpCache::AddAttribute(LPTSTR pszAttribute, BOOL bDeleteString)
{
	PLISTELEMENT pNewGuy = new LISTELEMENT;
	pNewGuy->pNext = m_Attributes;
	m_Attributes = pNewGuy;
	m_Attributes->pString = pszAttribute;
	m_Attributes->bDeleteString = bDeleteString;
}

void CDumpCache::AddChild(LPTSTR pszChild, BOOL bDeleteString)
{
	PLISTELEMENT pNewGuy = new LISTELEMENT;
#if 0
	pNewGuy->pNext = m_Children;
	m_Children = pNewGuy;
	m_Children->pString = pszChild;
	m_Children->bDeleteString = bDeleteString;
#else
    PLISTELEMENT * ppLastNode=&m_Children;
    while( *ppLastNode )
        ppLastNode=&( (*ppLastNode)->pNext);
    *ppLastNode=pNewGuy;
    pNewGuy->pString=pszChild;
    pNewGuy->pNext=NULL;
    pNewGuy->bDeleteString=bDeleteString;
#endif
}

void CDumpCache::AllocAddAttribute(LPCTSTR pszAttribute, DWORD dwStrlen)
{
	if(dwStrlen == 0)
		dwStrlen = lstrlen(pszAttribute);
	LPTSTR buff = new TCHAR[dwStrlen+1];
	wcscpy(buff, pszAttribute);
	AddAttribute(buff ,true);
}

void CDumpCache::AllocAddChild(LPTSTR pszChild, DWORD dwStrlen)
{
	if(dwStrlen == 0)
		dwStrlen = lstrlen(pszChild);
	LPTSTR buff = new TCHAR[dwStrlen+1];
	wcscpy(buff, pszChild);
	AddChild(buff ,true);
}

//
// Understands the nature of the XML we're writing. 8-(
//
//
// This is relatively confusing.
// you get passed the name of the element to dump, e.g. BUTTON
// as well as the WIN32: STYLE child LOCATION child CICERO child
// and the WIN32 specific control information.
//
TCHAR g_szTabs[]=TEXT("\t\t\t\t\t\t\t\t");
int g_bIndent=3;        // RCML FORM PAGE
BOOL CDumpCache::WriteElement(LPCTSTR pszElementName, 
        CDumpCache * pWin32, CDumpCache * pStyle, 
        CDumpCache * pLocation, CDumpCache * pControl,
        CDumpCache * pCicero )
{
	LPTSTR buff;
	DWORD dwLen = lstrlen(pszElementName);

	buff = new TCHAR[dwLen+100];
    g_bIndent++;

    //
    // Don't write anything out if this is an empty element.
    //
    BOOL bHasNoChildren = (
        (m_Children == NULL) && 
        (pWin32==NULL) && 
        (pStyle==NULL) && 
        (pLocation==NULL) && 
        (pControl == NULL) &&
        (pCicero == NULL)
        );
    // Rare occasion, there are no attributes on the control, just <LOCATION> and <WIN32:IMAGE>
    if (m_Attributes || !bHasNoChildren )
    {
        // Indent the element.
        int tabIndent=(sizeof(g_szTabs)/sizeof(g_szTabs[0]))-g_bIndent;
        if(tabIndent<0)
            tabIndent=0;
        LPTSTR pszTabs=&g_szTabs[tabIndent];
	    Write( pszTabs, FALSE);

        // NOTE NOTE NOTE - no space after attribute name.
	    wsprintf(buff, TEXT("<%s"), pszElementName);
	    Write( buff, FALSE );

	    PLISTELEMENT pNext = m_Attributes;
        BOOL firstAttributeCouldBeElement=TRUE;
	    while (pNext)
	    {
            if( firstAttributeCouldBeElement )
            {
                // if it's not a namespace element, we need to instert a space.
                if( *pNext->pString != TEXT(':') )
        		    Write( TEXT(" "), FALSE);
            }
            firstAttributeCouldBeElement=FALSE;
		    Write( pNext->pString, FALSE);
		    pNext = pNext->pNext;
	    }


	    if(bHasNoChildren)
	    {
		    Write( TEXT("/>") );
            delete buff;
            g_bIndent--;
		    return true;
	    } else
		    Write( TEXT(">"));

	    pNext = m_Children;
	    while (pNext)
	    { 	    
            Write( &g_szTabs[tabIndent>0?tabIndent-1:0], FALSE); // tab it out.
		    Write( pNext->pString);
		    pNext = pNext->pNext;
	    }

        if(pStyle)
            pStyle->WriteElement( TEXT("STYLE") );

        if(pLocation)
            pLocation->WriteElement( TEXT("RELATIVE") );

        // Win32 SPECIFIC child
        if(pControl)
        {
            // Form a WIN32:CHECKBOX, WIN32:<ELEMENT>   
            TCHAR element[256];
            wsprintf(element, TEXT("WIN32:%s"), pszElementName);
            pControl->WriteElement( element );
        }

        // WIN32:STYLE
        if(pWin32)
            pWin32->WriteElement( TEXT("WIN32:STYLE") );

        //
        // CICERO: - hard thing is we don't actually know what the element name suffix is!
        //
        if(pCicero)
            pCicero->WriteElement( TEXT("CICERO") );

        // Close the attribute name if one was used (for CICERO:CMD etc)
        // Now close the elment.
	    Write( pszTabs, FALSE );

   	    pNext = m_Attributes;
        if(pNext)
        {
            // if it's not a namespace element, we need to instert a space.
            if( *pNext->pString == TEXT(':') )
            {
        	    LPTSTR pszElementEnd = buff+wsprintf(buff, TEXT("</%s"), pszElementName);
                LPTSTR pszElement=pNext->pString;
                while( *pszElement!=TEXT(' ') && *pszElement )
                    *pszElementEnd++=*pszElement++;
                wsprintf(pszElementEnd,TEXT(">"));
            }
            else
        	    wsprintf(buff, TEXT("</%s>"), pszElementName);
        }
        else
        {
    	    wsprintf(buff, TEXT("</%s>"), pszElementName);
	    }
	    Write( buff );
    }

    delete buff;
    g_bIndent--;
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlgen\fileencoder.h ===
// FileEncoder.h: interface for the CFileEncoder class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILEENCODER_H__FE94624A_8FDC_4BDA_A80D_9C306CF89F40__INCLUDED_)
#define AFX_FILEENCODER_H__FE94624A_8FDC_4BDA_A80D_9C306CF89F40__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define PROPERTY(type, name) type Get##name() const { return m_##name; } void Set##name(type i) { m_##name=i; }

class CFileEncoder  
{
public:
	void CloseFile();
    enum RF_ENCODING
    {
        RF_ANSI,
        RF_UNICODE,
        RF_UTF8
    } ;

	void Write( LPCTSTR pszString, BOOL bNewLine=FALSE);
	CFileEncoder();
	virtual ~CFileEncoder();
    PROPERTY( LPTSTR, Filename );
  	BOOL CreateFile(LPCTSTR pszFile);
    PROPERTY ( RF_ENCODING, Encoding );

private:
    LPTSTR  m_Filename;
    HANDLE  m_hFile;
    RF_ENCODING m_Encoding;
};

#endif // !defined(AFX_FILEENCODER_H__FE94624A_8FDC_4BDA_A80D_9C306CF89F40__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\speechhook\spchhk\thread.cpp ===
//
// FelixA 1996
//
// A simple ThreadClass
//

#include "stdafx.h"
#include "thread.h"
#include "debug.h"

/*++
*******************************************************************************
Routine:
   LPTHREAD_START_ROUTINE ThreadStub	

Description:
	Because we must have a specific type of function to start the thread in 
	CLightThread, and since that function can not start with a this pointer, we
	can't have it be a member function.  So this is a little stub that calls
	the starts with the CreateThread and immediately calls the 
	InputWatcherThread.  

Arguments:
	CLightThread *object	The this pointer for the CLightThread Object.  

Return Value:
	0	 (this is usually ignored).

*******************************************************************************
--*/
LPTHREAD_START_ROUTINE CLightThread::ThreadStub(CLightThread *object)
{
	TRACE(TEXT("Thread stub called, calling the process\n"));
	object->Process();
	TRACE(TEXT("Process has stopped\n"));
	return(0);	
}


/*++
*******************************************************************************
Routine:
	CLightThread::CLightThread
	CLightThread::~CLightThread

Description:
	Constructor and Destructor for the CLightThread Class.

Arguments:

Return Value:

*******************************************************************************
--*/

CLightThread::CLightThread()
		:m_hThread(NULL),
		 m_bKillThread(FALSE),
		 m_status(successful)
{
	TRACE(TEXT("CLightThread being created - event created\n"));
	m_hEndEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (m_hEndEvent == NULL)
	{
		TRACE(TEXT("!!! Failed to create an event\n"));
		m_status = error;
	}
}

CLightThread::~CLightThread()
{
	TRACE(TEXT("Cleaning up CLightThread\n"));
	Stop();
	if(m_hEndEvent)
		CloseHandle(m_hEndEvent);
}

/*++
*******************************************************************************
Routine:
	CLightThread::Start

Description:
	Start up the InputWatcher Thread.
	Use ExitApp to clean all this up before ending.

Arguments:
	None.

Return Value:
	successful	if it worked.
	threadError	if the thread did not initialize properly (which might mean
		the input device did not initialize).

*******************************************************************************
--*/
EThreadError CLightThread::Start(int iPriority)
{
	if(IsRunning())
	{
		TRACE(TEXT("!!! Can't start thread, already running\n"));
		return threadRunning;
	}

	if(!m_hEndEvent)
	{
		TRACE(TEXT("!!! No event, can't start thread\n"));
		return noEvent;
	}

	m_bKillThread = FALSE;

	// Create a thread to watch for Input events.
	m_hThread = CreateThread((LPSECURITY_ATTRIBUTES)NULL,
								0,
								(LPTHREAD_START_ROUTINE)ThreadStub,
								this,
								CREATE_SUSPENDED, 
								&m_dwThreadID);
	if (m_hThread == NULL) 
	{
		TRACE(TEXT("!!! Couldn't create the thread\n"));
		return threadError;
	}

	SetThreadPriority(m_hThread, iPriority); // THREAD_PRIORITY_ABOVE_NORMAL);
	ResumeThread(m_hThread);

	TRACE(TEXT("Thread created OK\n"));
	return(successful);
}


/*++
*******************************************************************************
Routine:
	CLightThread::Stop

Description:
	Cleanup stuff that must be done before exiting the app.  Specifically, 
	this tells the Input Watcher Thread to stop.

Arguments:
	None.

Return Value:
	None.

*******************************************************************************
--*/
EThreadError CLightThread::Stop() 
{
	if(IsRunning())	
	{
		TRACE(TEXT("Trying to stop the thread\n"));
		//
		// Set flag to tell thread to kill itself, and wake it up
		//
		m_bKillThread = TRUE;
		SetEvent(m_hEndEvent);

		//
		// wait until thread has self-terminated, and clear the event.
		//
		TRACE(TEXT("WaitingForSingleObject\n"));
		WaitForSingleObject(m_hThread, INFINITE);
		ResetEvent(m_hEndEvent);

		TRACE(TEXT("Thread stopped\n"));
        CloseHandle(m_hThread);
		m_hThread = NULL;
	}
	return(successful);
}


/*++
*******************************************************************************
Routine:
	CLightThread::InputWatcherThread

Description:
	This is a thread devoted solely to reading comm input.

Arguments:
	None.

Return Value:
	None.

*******************************************************************************
--*/
void 
CLightThread::Process() 
{
#if 0
	while (!m_bKillThread) 
	{
	}
#endif
	return;  //Return Value ignored.
}

EThreadError CLightThread::GetStatus()
{
	return m_status;
}

BOOL CLightThread::IsRunning()
{
	return m_hThread!=NULL;
}

BOOL CLightThread::StopRunning()
{
	return m_bKillThread;
}

HANDLE CLightThread::GetEvent()
{
	return m_hEndEvent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlgen\controldumpers.cpp ===
// ResControl.cpp: implementation of the CResControl class.
//
// http://msdn.microsoft.com/workshop/author/css/reference/attributes.asp
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ResControl.h"
#include "resfile.h"
#include "debug.h"

//
// Control Style. 
// CS( ES_WANTRETURN, TEXT("WANTRETURN"), m_WantReturn, FALSE ) 
// -> WIN32:ELEMENT WANTRETURN="YES"
//
#define CONTROLSTYLE(p,id, member, def) if( ((dwRemainingStyles & p)==p) != def ) { wsprintf(m_szDumpBuffer, TEXT("%s=\"%s\" "), id, (dwRemainingStyles & p)?TEXT("YES"):TEXT("NO") ); AddControl(); } m_dumpedStyle |= p;
#define STYLEEX(p,id, member, def) if( ((dwRemainingStyles & p)==p) != def ) { wsprintf(m_szDumpBuffer, TEXT("%s=\"%s\" "), id, (dwRemainingStyles & p)?TEXT("YES"):TEXT("NO") ); AddWin32Style(); } m_dumpedStyleEx|=p;
#define STYLE(p,id, member, def) if( ((dwRemainingStyles & p)==p) != def ) { wsprintf(m_szDumpBuffer, TEXT("%s=\"%s\" "), id, (dwRemainingStyles & p)?TEXT("YES"):TEXT("NO") ); AddWin32Style(); } m_dumpedStyle |= p;
#define CONTROL(p,id, member, def) if( ((dwRemainingStyles & p)==p) != def ) { wsprintf(m_szDumpBuffer, TEXT("%s=\"%s\" "), id, (dwRemainingStyles & p)?TEXT("YES"):TEXT("NO") ); Add(); } m_dumpedStyle |= p;

CResControl::SHORTHAND CResControl::pShorthand[]=
{
    // BUTTONS, low 4 bits are an enumeration:

    // BS_PUSHBUTTON       0x00000000L
    // BS_DEFPUSHBUTTON    0x00000001L
    // BS_CHECKBOX         0x00000002L
    // BS_AUTOCHECKBOX     0x00000003L
    // BS_RADIOBUTTON      0x00000004L
    // BS_3STATE           0x00000005L
    // BS_AUTO3STATE       0x00000006L
    // BS_GROUPBOX         0x00000007L
    // BS_USERBUTTON       0x00000008L
    // BS_AUTORADIOBUTTON  0x00000009L
    // BS_OWNERDRAW        0x0000000BL

	{ TEXT("BUTTON"), 0xf, BS_PUSHBUTTON,		0,0, CResControl::DumpPushButton	, 50, 14 },	// Button
	{ TEXT("BUTTON"), 0xf, BS_DEFPUSHBUTTON,	0,0, CResControl::DumpPushButton	, 50, 14 },	// Defpushbutton
	{ TEXT("BUTTON"), 0xf, BS_CHECKBOX,			0,0, CResControl::DumpCheckBox		, 0,0 },	// GroupBox
	{ TEXT("BUTTON"), 0xf, BS_AUTOCHECKBOX,		0,0, CResControl::DumpCheckBox		, 0, 10 },	// AutoCheckBox
	{ TEXT("BUTTON"), 0xf, BS_RADIOBUTTON,	    0,0, CResControl::DumpRadioButton	, 0, 10  },	// Radiobutton
	{ TEXT("BUTTON"), 0xf, BS_3STATE,	        0,0, CResControl::DumpCheckBox  	, 0, 10  },	// Radiobutton
	{ TEXT("BUTTON"), 0xf, BS_AUTO3STATE,	    0,0, CResControl::DumpCheckBox  	, 0, 10  },	// Radiobutton
	{ TEXT("BUTTON"), 0xf, BS_GROUPBOX,			0,0, CResControl::DumpGroupBox	    , 0,0 },	// GroupBox
	{ TEXT("BUTTON"), 0xf, BS_USERBUTTON,	    0,0, CResControl::DumpPushButton	, 0, 10  },	// Radiobutton
	{ TEXT("BUTTON"), 0xf, BS_AUTORADIOBUTTON,	0,0, CResControl::DumpRadioButton	, 0, 10  },	// Radiobutton
	{ TEXT("BUTTON"), 0xf, BS_OWNERDRAW,	    0,0, CResControl::DumpPushButton	, 0, 10  },	// Radiobutton
	{ TEXT("BUTTON"), 0x0, 0,					0,0, CResControl::DumpButton		, 0,0 },	// Any other button.

	// WS_BORDER  = 0x?? 8? 
	// ES_LEFT - all edit controls seem to be the same.
	{ TEXT("EDIT"),   0, 0, 0,0, CResControl::DumpDefEdit	,0,14},	// Edit

	// SS_LEFT
/*
	{ TEXT("STATIC"), SS_TYPEMASK, SS_LEFT,			0,0, CResControl::DumpDefStatic ,0,8 },	// Static
	{ TEXT("STATIC"), SS_TYPEMASK, SS_CENTER,		0,0, CResControl::DumpDefStatic ,0,8 },	// Static
	{ TEXT("STATIC"), SS_TYPEMASK, SS_RIGHT,			0,0, CResControl::DumpDefStatic ,0,8 },	// Static
*/
// Images
	{ TEXT("STATIC"), SS_TYPEMASK, SS_ICON,			0,0, CResControl::DumpImage ,0,0 },	// Static
	{ TEXT("STATIC"), SS_TYPEMASK, SS_BITMAP,		0,0, CResControl::DumpImage ,0,0  },	// Static
	{ TEXT("STATIC"), SS_TYPEMASK, SS_ENHMETAFILE,	0,0, CResControl::DumpImage ,0,0  },	// Static

// Rects
	{ TEXT("STATIC"), SS_TYPEMASK, SS_BLACKRECT,		0,0, CResControl::DumpRect ,0,0  },	// Static
	{ TEXT("STATIC"), SS_TYPEMASK, SS_GRAYRECT,		0,0, CResControl::DumpRect ,0,0  },	// Static
	{ TEXT("STATIC"), SS_TYPEMASK, SS_WHITERECT,		0,0, CResControl::DumpRect ,0,0  },	// Static
	{ TEXT("STATIC"), SS_TYPEMASK, SS_BLACKFRAME,	0,0, CResControl::DumpRect ,0,0  },	// Static
	{ TEXT("STATIC"), SS_TYPEMASK, SS_GRAYFRAME,		0,0, CResControl::DumpRect ,0,0  },	// Static
	{ TEXT("STATIC"), SS_TYPEMASK, SS_WHITEFRAME,	0,0, CResControl::DumpRect ,0,0  },	// Static

	{ TEXT("STATIC"), SS_TYPEMASK, SS_ETCHEDHORZ,	0,0, CResControl::DumpRect ,0,0  },	// Static
	{ TEXT("STATIC"), SS_TYPEMASK, SS_ETCHEDVERT,	0,0, CResControl::DumpRect ,0,0  },	// Static
	{ TEXT("STATIC"), SS_TYPEMASK, SS_ETCHEDFRAME,	0,0, CResControl::DumpRect ,0,0 },	// Static

/*
	{ TEXT("STATIC"), SS_TYPEMASK, SS_USERITEM,		0,0, CResControl::DumpDefStatic ,0,0  },	// Static
	{ TEXT("STATIC"), SS_TYPEMASK, SS_SIMPLE,		0,0, CResControl::DumpDefStatic ,0,0  },	// Static
	{ TEXT("STATIC"), SS_TYPEMASK, SS_LEFTNOWORDWRAP, 0,0, CResControl::DumpDefStatic ,0,0  },	// Static
	{ TEXT("STATIC"), SS_TYPEMASK, SS_OWNERDRAW,		0,0, CResControl::DumpDefStatic ,0,0  },	// Static


	{ TEXT("STATIC"), SS_TYPEMASK, SS_ETCHEDHORZ,	0,0, CResControl::DumpImage ,0,0  },	// Static
	{ TEXT("STATIC"), SS_TYPEMASK, SS_ETCHEDVERT,	0,0, CResControl::DumpImage ,0,0  },	// Static
	{ TEXT("STATIC"), SS_TYPEMASK, SS_ETCHEDFRAME,	0,0, CResControl::DumpImage ,0,0 },	// Static
*/
// All others.
	{ TEXT("STATIC"), 0x0,		0,					0,0, CResControl::DumpDefStatic , 0,8 },

	{ TEXT("SCROLLBAR"), 0x0,	0,					0,0, CResControl::DumpScrollBar , 11,10 },

	//
	// COMBOBOX
	// CBS_SIMPLE CBS_DROPDOWN CBS_DROPDOWNLIST
	//
	{ TEXT("COMBOBOX"), 0xf, CBS_SIMPLE ,	0,0, CResControl::DumpComboBox ,0,0 },
	{ TEXT("COMBOBOX"), 0xf, CBS_DROPDOWN ,	0,0, CResControl::DumpComboBox ,0,0 },
	{ TEXT("COMBOBOX"), 0xf, CBS_DROPDOWNLIST ,	0,0, CResControl::DumpComboBox ,0,0 },

	//
	// LISTBOX
	// LBS_
	//
	{ TEXT("LISTBOX"), 0, 0,	0,0, CResControl::DumpListBox ,0,0 },


    /////////////// C O M M O N   C O N T R O L S /////////////
    /////////////// C O M M O N   C O N T R O L S /////////////
    /////////////// C O M M O N   C O N T R O L S /////////////

	//
	// Slider
	//
	{ TRACKBAR_CLASS, 0, 0,	0,0, CResControl::DumpSlider ,0,0 },

	//
	// Spinner
	//
	{ UPDOWN_CLASS, 0, 0,	0,0, CResControl::DumpSpinner ,11,14 },

	//
	// Progress
	//
	{ PROGRESS_CLASS, 0, 0,	0,0, CResControl::DumpProgress ,0,0 },

	//
	// ListView
	//
	{ WC_LISTVIEW, 0, 0,	0,0, CResControl::DumpListView ,0,0 },

	//
	// TreeView
	//
	{ WC_TREEVIEW, 0, 0,	0,0, CResControl::DumpTreeView ,0,0 },

	//
	// Pager
	//
	{ WC_PAGESCROLLER, 0, 0,	0,0, CResControl::DumpPager ,0,0 },

	//
	// HEADER
	//
	{ WC_HEADER, 0, 0,	0,0, CResControl::DumpHeader ,0,0 },

	//
	// TAB
	//
	{ WC_TABCONTROL, 0, 0,	0,0, CResControl::DumpTab ,0,0 },

	//
	//
    { ANIMATE_CLASS, 0,0, 0,0, CResControl::DumpAnimation, 0,0 },

	//
	{ NULL, 0,0,0,0}
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////// B U T T O N //////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

//
// Catchall - shouldn't really ever be called.
//
void CResControl::DumpButton(LPTSTR szBuffer, LPCTSTR pszTitle)
{
    // We don't know this button type.
	wsprintf(szBuffer,TEXT("STYLE=\"0x%02x\"  "), GetControlStyle() & 0xf );
    AddWin32Style();

	DumpDefButtonRules();
	DumpWindowStyle();
    DumpStyleEX();
	DumpLocation();
    DumpText();
	DumpIDDefMinusOne();
    Emit(TEXT("BUTTON"));
}

//
// Deals with :
// BS_PUSHBUTTON BS_DEFPUSHBUTTON BS_USERBUTTON BS_OWNERDRAW
//
void CResControl::DumpPushButton(LPTSTR szBuffer, LPCTSTR pszTitle)
{
	// Push Button.
    switch( GetControlStyle() & 0xf )
    {
        case BS_PUSHBUTTON     : 
        case BS_CHECKBOX       :
        case BS_AUTOCHECKBOX   :
        case BS_RADIOBUTTON    :
        case BS_3STATE         :
        case BS_AUTO3STATE     :
        case BS_GROUPBOX       :
        case BS_USERBUTTON     :   
        case BS_AUTORADIOBUTTON:
        case BS_OWNERDRAW      :
            // BUGBUG - shouldn't hit these
            break;
    }


    switch( GetControlStyle() & 0xf )
    {
        case BS_PUSHBUTTON : 
            break;

        case BS_DEFPUSHBUTTON : 
            AddControl(TEXT("DEFPUSH=\"YES\" "));
            break;

        case BS_USERBUTTON : 
            AddControl(TEXT("USERBUTTON=\"YES\" "));
            break;

        case BS_OWNERDRAW : 
            AddControl(TEXT("OWNERDRAW=\"YES\" "));
            break;
    }

    m_dumpedStyle |= 0xf; // BS_PUSHBUTTON | BS_DEFPUSHBUTTON | BS_USERBUTTON | BS_OWNERDRAW;

	DumpDefButtonRules();
	DumpWindowStyle();
	DumpStyleEX();
	DumpLocation();
    DumpText();

    if( GetCicero() )
    {
        LPWSTR pszShortButtonText=FindNiceText( GetRawTitle() );
        TCHAR szTip[1024];
        wsprintf(szTip,TEXT("Try saying '%s'"), pszShortButtonText );
        BOOL bAccuracy=FALSE;
        BOOL bTip=TRUE;
        if((lstrcmpi(pszShortButtonText, TEXT("OK")) == 0 )||
           (lstrcmpi(pszShortButtonText, TEXT("Cancel")) == 0 ) ||
           (lstrcmpi(pszShortButtonText, TEXT("Apply")) == 0 ) )
           bAccuracy=TRUE;

        if((lstrcmpi(pszShortButtonText, TEXT("OK")) == 0 )||
           (lstrcmpi(pszShortButtonText, TEXT("Cancel")) == 0 ) )
           bTip=FALSE;

        if(bTip)
            wsprintf(szBuffer,TEXT(":CMD TEXT=\"%s%s\" TOOLTIP=\"%s\" "), bAccuracy?TEXT("+"):TEXT(""),
            pszShortButtonText,
            szTip);
        else
            wsprintf(szBuffer,TEXT(":CMD TEXT=\"%s%s\" "), bAccuracy?TEXT("+"):TEXT(""),
            pszShortButtonText);

        AddCicero(szBuffer);
        delete pszShortButtonText;
    }

	DumpIDDefMinusOne();
	Emit(TEXT("BUTTON"));
}

//
// BS_RADIOBUTTON BS_AUTORADIOBUTTON
// AUTO is WIN32:RADIOBUTTON\@AUTO
//
void CResControl::DumpRadioButton(LPTSTR szBuffer, LPCTSTR pszTitle)
{
	// RADIOBUTTON
    switch( GetControlStyle() & 0xf )
    {
        case BS_RADIOBUTTON : 
            AddControl(TEXT("AUTO=\"NO\" "));
            break;

        case BS_AUTORADIOBUTTON : 
            // Add(TEXT("AUTO=\"YES\" ")); Default
            break;
    }

    m_dumpedStyle |= 0xf; // BS_PUSHBUTTON | BS_DEFPUSHBUTTON | BS_USERBUTTON | BS_OWNERDRAW;

	// Defaults
	DumpDefButtonRules();
	DumpWindowStyle();
	DumpStyleEX();
    DumpLocation();

    DumpID();
    DumpText();

    if( GetCicero() )
    {
        LPWSTR pszShortButtonText=FindNiceText( GetRawTitle() );
    	wsprintf(szBuffer,TEXT(":CMD TEXT=\"%s\" "), pszShortButtonText );
        AddCicero(szBuffer);
        delete pszShortButtonText;
    }

	Emit(TEXT("RADIOBUTTON"));
}

//
// BS_CHECKBOX BS_AUTOCHECKBOX BS_3STATE BS_AUTO3STATE
//
// AUTO nature is WIN32:CHECKBOX\@AUTO
// TRISTATE is CHECKBOX\@TRISTATE
//
void CResControl::DumpCheckBox(LPTSTR szBuffer, LPCTSTR pszTitle)
{
    // CHECKBOX

	// Defaults
    switch( GetControlStyle() & 0xf )
    {
        case BS_CHECKBOX : 
            AddControl(TEXT("AUTO=\"NO\" "));
            break;

        case BS_AUTOCHECKBOX : 
            // Add(TEXT("AUTO=\"YES\" ")); Default
            break;

        case BS_3STATE : 
            Add(TEXT("TRISTATE=\"YES\" "));
            break;

        case BS_AUTO3STATE :
            AddControl(TEXT("AUTO=\"YES\" "));
            Add(TEXT("TRISTATE=\"YES\" " ));
            break;
    }
    m_dumpedStyle |= 0xf; // BS_PUSHBUTTON | BS_DEFPUSHBUTTON | BS_USERBUTTON | BS_OWNERDRAW;

	DumpDefButtonRules();
	DumpWindowStyle();
	DumpStyleEX();
	DumpLocation();

    DumpID();
    DumpText();

    if( GetCicero() )
    {
        LPWSTR pszShortButtonText=FindNiceText( GetRawTitle() );
        TCHAR szTip[1024];
        wsprintf(szTip,TEXT("Try saying 'Do %s' or 'Toggle %s'"), pszShortButtonText, pszShortButtonText );

    	wsprintf(szBuffer,TEXT(":CMD TEXT=\"%s\" TOOLTIP=\"%s\" "), pszShortButtonText, szTip );
        AddCicero(szBuffer);
    	wsprintf(szBuffer,TEXT("<CICERO:FAILURE TEXT=\"Cannot check %s\" />"), pszShortButtonText );
        m_pCicero->AllocAddChild( szBuffer);
        delete pszShortButtonText;
    }

	Emit(TEXT("CHECKBOX"));
}

void CResControl::DumpGroupBox(LPTSTR szBuffer, LPCTSTR pszTitle)
{
	// GROUPBOX
    m_dumpedStyle |= 0xf; // BS_PUSHBUTTON | BS_DEFPUSHBUTTON | BS_USERBUTTON | BS_OWNERDRAW;

	DumpDefButtonRules();
	DumpWindowStyle();
	DumpStyleEX();
	DumpLocation();
    DumpText();

	DumpIDDefMinusOne();
	Emit(TEXT("GROUPBOX"));
}

//
// HEIGHT : defaults to 14
// PASSWORD
// CLASSIFICATION : UPPERCASE, LOWERCASE, NUMBER, DATE, TIME, FILENAME, URL, EMAILADDRESS
// ES_PASSWORD
//
//  ES_LEFT             0x0000L  *  // STYLE\@TEXT-ALIGN
//  ES_CENTER           0x0001L  *  // STYLE\@TEXT-ALIGN
//  ES_RIGHT            0x0002L  *  // STYLE\@TEXT-ALIGN
//  ES_MULTILINE        0x0004L  *  // WIN32:EDIT MULTILINE="YES"
//  ES_UPPERCASE        0x0008L  *  // STYLE\@text-transform=uppercase
//  ES_LOWERCASE        0x0010L  *  // STYLE\@text-transform=lowercase
//  ES_PASSWORD         0x0020L  *  // CONTENT="PASSWORD"
//  ES_AUTOVSCROLL      0x0040L  *  // STYLE\overflow-x="auto"
//  ES_AUTOHSCROLL      0x0080L  *  // STYLE\overflow-y="auto"
//  ES_NOHIDESEL        0x0100L  *  // WIN32:EDIT\NOHIDESEL
//  ES_OEMCONVERT       0x0400L  *  // WIN32:EDIT\OEMCONVERT
//  ES_READONLY         0x0800L  *  // READONLY="YES"
//  ES_WANTRETURN       0x1000L  *  // WIN32:EDIT\WANTRETURN
//  ES_NUMBER           0x2000L  *  // CONTENT="NUMBER"
//  SETLENGTH                       // MAXLENGTH

void CResControl::DumpDefEdit(LPTSTR szBuffer, LPCTSTR pszTitle)
{
    DWORD dwRemainingStyles = GetControlStyle();

    switch ( dwRemainingStyles & (ES_CENTER | ES_RIGHT | ES_LEFT ) )
    {
    case ES_CENTER:
        AddStyle( TEXT("TEXT-ALIGN=\"CENTER\" ") );
        break;
    case ES_RIGHT:
        AddStyle( TEXT("TEXT-ALIGN=\"RIGHT\" ") );
        break;
    default:
        // AddStyle( TEXT("TEXT-ALIGN=\"LEFT\" "); Default
        break;
    }
    m_dumpedStyle |= (ES_CENTER | ES_RIGHT | ES_LEFT );

    CONTROLSTYLE( ES_MULTILINE, TEXT("MULTILINE"), m_MultiLine, FALSE );

    switch( dwRemainingStyles & (ES_UPPERCASE | ES_LOWERCASE ) )
    {
    case ES_UPPERCASE:
        AddStyle( TEXT("TEXT-TRANSFORM=\"UPPERCASE\" "));
        break;
    case ES_LOWERCASE:
        AddStyle( TEXT("TEXT-TRANSFORM=\"LOWERCASE\" "));
        break;
    default:
        //
        break;
    }
    m_dumpedStyle |= (ES_UPPERCASE | ES_LOWERCASE );

    if( dwRemainingStyles & ES_PASSWORD )
		Add( TEXT("CONTENT=\"PASSWORD\" "));
    m_dumpedStyle |=ES_PASSWORD;


    if( !( dwRemainingStyles & ES_AUTOHSCROLL ) )
		AddStyle( TEXT("OVERFLOW-X=\"VISIBLE\" ")); // can only type as big as the control
    m_dumpedStyle |=ES_AUTOHSCROLL;

    if( ( dwRemainingStyles & ES_AUTOVSCROLL ) )
		AddStyle( TEXT("OVERFLOW-Y=\"AUTO\" "));
    m_dumpedStyle |=ES_AUTOVSCROLL;

    CONTROLSTYLE( ES_NOHIDESEL, TEXT("NOHIDESEL"), m_NoHideSel, FALSE );
    CONTROLSTYLE( ES_OEMCONVERT, TEXT("OEMCONVERT"), m_OemConvert, FALSE );

    CONTROL( ES_READONLY, TEXT("READONLY"), m_ReadOnly, FALSE );

    CONTROLSTYLE( ES_WANTRETURN, TEXT("WANTRETURN"), m_WantReturn, FALSE );

	if(dwRemainingStyles & ES_NUMBER)
		Add( TEXT("CONTENT=\"NUMBER\" "));
    m_dumpedStyle |= ES_NUMBER;

    DumpTabStop(TRUE);

	DumpWindowStyle();
    DumpStyleEX();
    DumpID();
    DumpText();
	DumpLocation();

    if( GetCicero() )
    {
        LPWSTR pszShortButtonText=FindNiceText( GetRawTitle() );
        TCHAR szTip[1024];
        wsprintf(szTip,TEXT("Try saying '%s'"), pszShortButtonText );
        BOOL bAccuracy=FALSE;
        BOOL bTip=TRUE;

        wsprintf(szBuffer,TEXT(":CMD "), bAccuracy?TEXT("+"):TEXT(""),
            pszShortButtonText,
            szTip);

        AddCicero(szBuffer);
        delete pszShortButtonText;
    }


	Emit(TEXT("EDIT"));
}

//////////////////////////////////////////////////////////////////////////////////////////
//
    // http://msdn.microsoft.com/workshop/author/dhtml/reference/objects/LABEL.asp
    // Enumeration
    // SS_LEFT             0x0000L  S       // STYLE\@TEXT-ALIGN 
    // SS_CENTER           0x0001L  S       // STYLE\@TEXT-ALIGN 
    // SS_RIGHT            0x0002L  S       // STYLE\@TEXT-ALIGN
    // SS_ICON             0x0003L          // IMAGE
    // SS_BLACKRECT        0x0004L  C       // RECT\WIN32:STATIC\@TYPE="BLACKRECT"
    // SS_GRAYRECT         0x0005L  C       // RECT\WIN32:STATIC\@TYPE="GRAYRECT"
    // SS_WHITERECT        0x0006L  C       // RECT\WIN32:STATIC\@TYPE="WHITERECT"
    // SS_BLACKFRAME       0x0007L  C       // RECT\WIN32:STATIC\@TYPE="BLACKFRAME"
    // SS_GRAYFRAME        0x0008L  C       // RECT\WIN32:STATIC\@TYPE="GRAYFRAME"
    // SS_WHITEFRAME       0x0009L  C       // RECT\WIN32:STATIC\@TYPE="WHITEFRAME"
    // SS_USERITEM         0x000AL          // ??
    // SS_SIMPLE           0x000BL	C       // WIN32:STATIC\SIMPLE
    // SS_LEFTNOWORDWRAP   0x000CL  C		// WIN32:STATIC\@LEFTNOWORDWRAP
    // SS_OWNERDRAW        0x000DL          // WIN32:STATIC\OWNERDRAW
    // SS_BITMAP           0x000EL          // IMAGE
    // SS_ENHMETAFILE      0x000FL          // IMAGE
    // SS_ETCHEDHORZ       0x0010L          // RECT\WIN32:STATIC\@TYPE="ETCHEDHORZ"
    // SS_ETCHEDVERT       0x0011L          // RECT\WIN32:STATIC\@TYPE="ETCHEDVERT"
    // SS_ETCHEDFRAME      0x0012L		    // RECT\WIN32:STATIC\@TYPE="ETCHEDFRAME"
    // SS_TYPEMASK         0x0000001FL
    // End enumeration.

// http://msdn.microsoft.com/workshop/author/dhtml/reference/objects/IMG.asp

    //  FLAGS - can't find much overlap with HTML.
    //  SS_NOPREFIX         0x00000080L     // WIN32:STATIC\@NOPREFIX=NO /* Don't do "&" character translation */
    //  SS_NOTIFY           0x00000100L     // WIN32:STATIC\NOTIFY
    //  SS_CENTERIMAGE      0x00000200L     // WIN32:STATIC\CENTERIMAGE
    //  SS_RIGHTJUST        0x00000400L     // WIN32:STATIC\@RIGHTJUST
    //  SS_REALSIZEIMAGE    0x00000800L     // WIN32:STATIC\@REALSIZEIMAGE 
    //  SS_SUNKEN           0x00001000L     // WIN32:STATIC\@SUNKEN
    //  Enumeration
    //  SS_ENDELLIPSIS      0x00004000L     // ELIPSIS="END" 
    //  SS_PATHELLIPSIS     0x00008000L     // ELIPSIS="PATH" 
    //  SS_WORDELLIPSIS     0x0000C000L     // ELIPSIS="WORD" 
    //  SS_ELLIPSISMASK     0x0000C000L
//
//
//////////////////////////////////////////////////////////////////////////////////////////
void CResControl::DumpDefStatic(LPTSTR szBuffer, LPCTSTR pszTitle)
{
    DWORD dwRemainingStyles = GetControlStyle();

    switch ( dwRemainingStyles & SS_TYPEMASK )
    {
    case SS_LEFT:
    default:
        // AddStyle( TEXT("TEXT-ALIGN=\"LEFT\" ") );
        break;

    case SS_CENTER:
        AddStyle( TEXT("TEXT-ALIGN=\"CENTER\" ") );
        break;

    case SS_RIGHT:
        AddStyle( TEXT("TEXT-ALIGN=\"RIGHT\" ") );
        break;

    case SS_USERITEM:
        AddStyle( TEXT("TEXT-ALIGN=\"CENTER\" ") );
        break;

    case SS_SIMPLE:
        AddControl( TEXT("SIMPLE=\"YES\" "));
        break;

    case SS_LEFTNOWORDWRAP:
        AddControl( TEXT("LEFTNOWORDWRAP=\"YES\" "));
        break;
    case SS_OWNERDRAW:
        AddControl( TEXT("OWNERDRAW=\"YES\" "));
        break;
    }
    m_dumpedStyle |= SS_TYPEMASK;

    DumpDefStaticRules();

	DumpWindowStyle();
	DumpStyleEX();
	DumpLocation();
    DumpText();
	DumpIDDefMinusOne();

	Emit(TEXT("LABEL"));
}

//
// Rectangle (the background for an image?)
//
void CResControl::DumpRect(LPTSTR szBuffer, LPCTSTR pszTitle)
{
    DWORD dwRemainingStyles = GetControlStyle();
    switch ( dwRemainingStyles & SS_TYPEMASK )
    {
    default:
    case SS_BLACKRECT:
        AddControl( TEXT("TYPE=\"BLACKRECT\" "));
        break;

    case SS_GRAYRECT:
        AddControl( TEXT("TYPE=\"GRAYRECT\" "));
        break;

    case SS_WHITERECT:
        AddControl( TEXT("TYPE=\"WHITERECT\" "));
        break;

    case SS_BLACKFRAME:
        AddControl( TEXT("TYPE=\"BLACKFRAME\" "));
        break;

    case SS_GRAYFRAME:
        AddControl( TEXT("TYPE=\"GRAYFRAME\" "));
        break;

    case SS_WHITEFRAME:
        AddControl( TEXT("TYPE=\"WHITEFRAME\" "));
        break;

    case SS_ETCHEDHORZ:
        AddControl( TEXT("TYPE=\"ETCHEDHORZ\" "));
        break;

    case SS_ETCHEDVERT:
        AddControl( TEXT("TYPE=\"ETCHEDVERT\" "));
        break;

    case SS_ETCHEDFRAME:
        AddControl( TEXT("TYPE=\"ETCHEDFRAME\" "));
        break;
    }

    m_dumpedStyle |= SS_TYPEMASK;

    DumpDefStaticRules();

	DumpWindowStyle();
	DumpStyleEX();
	DumpLocation();
    // DumpText(); Rects don't have TEXT.
	DumpIDDefMinusOne();

	Emit(TEXT("RECT"));
}

//
// Image
//
void CResControl::DumpImage(LPTSTR szBuffer, LPCTSTR pszTitle)
{
    // Do we allow them to force the image type
    // ICON, BITMAP, ENHMETAFILE ???
    //
    DWORD dwRemainingStyles = GetControlStyle();
    switch ( dwRemainingStyles & SS_TYPEMASK )
    {
    default:
    case SS_ICON:
        Add( TEXT("CONTENT=\"ICON\" "));
        break;

    case SS_BITMAP:
        Add( TEXT("CONTENT=\"BITMAP\" "));
        break;

    case SS_ENHMETAFILE:
        Add( TEXT("CONTENT=\"VECTOR\" "));
        break;
    }
    m_dumpedStyle |= SS_TYPEMASK;

	// Label
    DumpDefStaticRules();

	DumpWindowStyle();
	DumpStyleEX();
	DumpLocation();
	DumpIDDefMinusOne();

	wsprintf(szBuffer,TEXT("IMAGEID=\"%d\" "), m_TitleID);
	Add(szBuffer);

	Emit(TEXT("IMAGE"));
}
//
// Static defines:
//
BOOL CResControl::DumpDefStaticRules( )
{
    DWORD dwRemainingStyles=GetControlStyle();
    dwRemainingStyles &= ~ m_dumpedStyle;  

    if( GetDumpWin32()== FALSE )
    {
        if( dwRemainingStyles & SS_SUNKEN )
            m_StyleEx |= WS_EX_STATICEDGE;
    }

    CONTROLSTYLE( SS_NOPREFIX,      TEXT("NOPREFIX"),       m_NoPrefix, FALSE );
    CONTROLSTYLE( SS_NOTIFY,        TEXT("NOTIFY"),         m_Notify, FALSE );
    CONTROLSTYLE( SS_CENTERIMAGE,   TEXT("CENTERIMAGE"),    m_CenterImage, FALSE );
    CONTROLSTYLE( SS_RIGHTJUST,     TEXT("RIGHTJUST"),      m_RightJust, FALSE );
    CONTROLSTYLE( SS_REALSIZEIMAGE, TEXT("REALSIZEIMAGE"),  m_RealSizeImage, FALSE );
    CONTROLSTYLE( SS_SUNKEN,        TEXT("SUNKEN"),         m_Sunken, FALSE );

	switch(dwRemainingStyles & SS_ELLIPSISMASK )
	{
    case SS_ENDELLIPSIS:
        AddControl(TEXT("ELIPSIS=\"END\" "));
        break;
    case SS_PATHELLIPSIS:
        AddControl(TEXT("ELIPSIS=\"PATH\" "));
        break;
    case SS_WORDELLIPSIS:
        AddControl(TEXT("ELIPSIS=\"WORD\" "));
        break;
    default:
        break;
	}
    m_dumpedStyle |= SS_ELLIPSISMASK;

    DumpTabStop(FALSE);

	return true;
}

//
// SCROLLBAR
//
//////////////////////////////////////////////////////////////////////////////////////////
//
// SBS_HORZ                    0x0000L  A @VERTICAL="NO"
// SBS_VERT                    0x0001L  A @VERTICAL="YES"
// SBS_TOPALIGN                0x0002L  A @ALIGN="TOP"
// SBS_LEFTALIGN               0x0002L  A @ALIGN="LEFT"
// SBS_BOTTOMALIGN             0x0004L  A @ALIGN="BOTOM"
// SBS_RIGHTALIGN              0x0004L  A @ALIGN="RIGHT"
// SBS_SIZEBOXTOPLEFTALIGN     0x0002L    WIN32:SCROLLBAR\@SIZEBOX="YES" the @ALIGN="TOP" or @ALIGN="LEFT"
// SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L    WIN32:SCROLLBAR\@SIZEBOX="YES" the @ALIGN="BOTTOM" or @ALIGN="RIGHT"
// SBS_SIZEBOX                 0x0008L    WIN32:SCROLLBAR\@SIZEBOX="YES"
// SBS_SIZEGRIP                0x0010L    WIN32:SCROLLBAR\@SIZEGRIP="YES"
//

void CResControl::DumpScrollBar(LPTSTR szBuffer, LPCTSTR pszTitle)
{

    DWORD dwRemainingStyles = GetControlStyle();

    if( dwRemainingStyles & SBS_VERT )
    {
        Add( TEXT("ORIENTATION=\"VERTICAL\" ") );
        if( dwRemainingStyles & SBS_LEFTALIGN )
            Add( TEXT("ALIGN=\"LEFT\" ") );
        if( dwRemainingStyles & SBS_RIGHTALIGN )
            Add( TEXT("ALIGN=\"RIGHT\" ") );
    }
    else
    {
        // Add( TEXT("ORIENTATION=\"HORIZONTAL\" ") );
        if( dwRemainingStyles & SBS_TOPALIGN )
            Add( TEXT("ALIGN=\"TOP\" ") );
        if( dwRemainingStyles & SBS_BOTTOMALIGN )
            Add( TEXT("ALIGN=\"BOTTOM\" ") );
    }
    if( dwRemainingStyles & SBS_SIZEBOX )
        AddControl( TEXT("SIZEBOX=\"YES\" ") );

    if( dwRemainingStyles & SBS_SIZEGRIP )
        AddControl( TEXT("SIZEGRIP=\"YES\" ") );

    m_dumpedStyle |= SBS_VERT | SBS_TOPALIGN | SBS_BOTTOMALIGN | SBS_SIZEBOX  | SBS_SIZEGRIP ;
       
	DumpWindowStyle();
    DumpStyleEX();
	DumpLocation();
    // DumpText();  - I don't think that they need text
	DumpIDDefMinusOne();
	Emit(TEXT("SCROLLBAR"));
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Slider
//
//  TBS_AUTOTICKS           0x0001      AUTOTICKS
//  TBS_VERT                0x0002      VERTICAL
//  TBS_HORZ                0x0000      
//  TBS_TOP                 0x0004      TICKS="TOP LEFT BOTTOM RIGHT BOTH"
//  TBS_BOTTOM              0x0000
//  TBS_LEFT                0x0004      
//  TBS_RIGHT               0x0000      
//  TBS_BOTH                0x0008      
//  TBS_NOTICKS             0x0010      NOTICKS
//  TBS_ENABLESELRANGE      0x0020      SELECTION
//  TBS_FIXEDLENGTH         0x0040      FIXEDLENGTH
//  TBS_NOTHUMB             0x0080      NOTHUMB
//  TBS_TOOLTIPS            0x0100      TOOLTIPS

void CResControl::DumpSlider(LPTSTR szBuffer, LPCTSTR pszTitle)
{
    DWORD dwRemainingStyles = GetControlStyle();

 
    CONTROL( TBS_AUTOTICKS,    TEXT("AUTOTICKS"),      m_AutoTicks, FALSE );

    if( dwRemainingStyles & TBS_VERT )
    {
        Add(TEXT("ORIENTATION=\"VERTICAL\" "));
        if( (dwRemainingStyles & (TBS_NOTICKS | TBS_BOTH )) == 0 )
        {
            if( dwRemainingStyles & TBS_LEFT )
                Add(TEXT("TICKS=\"LEFT\" "));
            else
                Add(TEXT("TICKS=\"RIGHT\" "));
        }
        else
        {
            if( dwRemainingStyles & TBS_NOTICKS )
                Add(TEXT("TICKS=\"NONE\" "));
            else
                Add(TEXT("TICKS=\"BOTH\" "));
        }
    }
    else
    {
        // Add(TEXT("ORIENTATION=\"HORIZONTAL\" ")); - Default
        if( (dwRemainingStyles & (TBS_NOTICKS | TBS_BOTH )) == 0 )
        {
            if( dwRemainingStyles & TBS_TOP )
                Add(TEXT("TICKS=\"TOP\" "));
            else
                Add(TEXT("TICKS=\"BOTTOM\" "));
        }
        else
        {
            if( dwRemainingStyles & TBS_NOTICKS )
                Add(TEXT("TICKS=\"NONE\" "));
            else
                Add(TEXT("TICKS=\"BOTH\" "));
        }
    }

    CONTROL( TBS_ENABLESELRANGE,TEXT("SELECTION"),     m_Selection, FALSE );
    CONTROL( TBS_FIXEDLENGTH,  TEXT("FIXEDLENFTH"),    m_FixedLength, FALSE );
    CONTROL( TBS_NOTHUMB,      TEXT("NOTHUMB"),        m_NoThumb, FALSE );
    CONTROL( TBS_TOOLTIPS,     TEXT("TOOLTIPS"),       m_Tooltips, FALSE );

    m_dumpedStyle |= 0x1ff;
    DumpTabStop(TRUE);

	DumpWindowStyle();
    DumpStyleEX();
	DumpLocation();
    // DumpText();  - I don't think that they need text
	DumpIDDefMinusOne();

    if( GetCicero() )
        AddCicero( TEXT(":CMD ") );

	Emit(TEXT("SLIDER"));
}

////////////////////////////////////////////////////////////////////////////////////////
// UDS_WRAP                0x0001       @WRAP
// UDS_SETBUDDYINT         0x0002       @CONTENT="NUMBER"   
// UDS_ALIGNRIGHT          0x0004       @ALIGN="RIGHT"
// UDS_ALIGNLEFT           0x0008       @ALIGH="LEFT"
// UDS_AUTOBUDDY           0x0010       @BUDDY="AUTO"
// UDS_ARROWKEYS           0x0020       @ARROWKEYS="YES"    default
// UDS_HORZ                0x0040       @HORIZONTAL
// UDS_NOTHOUSANDS         0x0080       @NOTHOUSANDS
// UDS_HOTTRACK            0x0100       @HOTTRACK
void CResControl::DumpSpinner(LPTSTR szBuffer, LPCTSTR pszTitle)
{
    DWORD dwRemainingStyles = GetControlStyle();

    CONTROL( UDS_WRAP,         TEXT("WRAP"),      m_Wrap, FALSE );

    if( dwRemainingStyles & UDS_SETBUDDYINT )
        Add(TEXT("CONTENT=\"NUMBER\" "));

    if( dwRemainingStyles & UDS_ALIGNRIGHT )
        Add(TEXT("ALIGN=\"RIGHT\" "));

    if( dwRemainingStyles & UDS_ALIGNLEFT )
        Add(TEXT("ALIGN=\"LEFT\" "));

    if( dwRemainingStyles & UDS_AUTOBUDDY )
        Add(TEXT("BUDDY=\"AUTO\" "));

    CONTROL( UDS_ARROWKEYS,    TEXT("ARROWKEYS"),      m_ArrowKeys, TRUE );
    // CONTROL( UDS_HORZ,         TEXT("HORIZONATAL"),    m_Horz, FALSE );
    if( dwRemainingStyles & UDS_HORZ )
        Add(TEXT("ORIENTATION=\"HORIZONTAL\" "));

    CONTROL( UDS_NOTHOUSANDS,  TEXT("NOTHOUSANDS"),    m_NoThousands, FALSE );
    CONTROL( UDS_HOTTRACK,     TEXT("HOTTRACK"),       m_HotTrack, FALSE );

    m_dumpedStyle |= 0x1ff;
    DumpTabStop(FALSE);

	DumpWindowStyle();
    DumpStyleEX();
	DumpLocation();
    // DumpText();  - I don't think that they need text
	DumpIDDefMinusOne();

    if( GetCicero() )
        AddCicero( TEXT(":CMD ") );

	Emit(TEXT("SPINNER"));
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Progress
//
//
// PBS_SMOOTH              0x01
// PBS_VERTICAL            0x04
//
void CResControl::DumpProgress(LPTSTR szBuffer, LPCTSTR pszTitle)
{
    DWORD dwRemainingStyles = GetControlStyle();

    CONTROL( PBS_SMOOTH,         TEXT("SMOOTH"),      m_Smooth, FALSE );
    // CONTROL( PBS_VERTICAL,       TEXT("VERTICAL"),    m_Vertical, FALSE );
    if( dwRemainingStyles & PBS_VERTICAL )
        Add(TEXT("ORIENTATION=\"VERTICAL\" "));
    m_dumpedStyle |= PBS_VERTICAL;

    DumpTabStop(FALSE);

	DumpWindowStyle();
    DumpStyleEX();
	DumpLocation();
    // DumpText();  - I don't think that they need text
	DumpIDDefMinusOne();

	Emit(TEXT("PROGRESS"));
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//
// PAGER
//
//
// PGS_VERT                0x00000000
// PGS_HORZ                0x00000001
// PGS_AUTOSCROLL          0x00000002
// PGS_DRAGNDROP           0x00000004
//
void CResControl::DumpPager(LPTSTR szBuffer, LPCTSTR pszTitle)
{
    DWORD dwRemainingStyles = GetControlStyle();

    CONTROL( PGS_AUTOSCROLL,         TEXT("AUTOSCROLL"),      m_AutoScroll, FALSE );

    if( dwRemainingStyles & PGS_HORZ )
        Add(TEXT("ORIENTATION=\"HORIZONTAL\" "));
    m_dumpedStyle |= PGS_HORZ;

    DumpTabStop(FALSE);

	DumpWindowStyle();
    DumpStyleEX();
	DumpLocation();
    // DumpText();  - I don't think that they need text
	DumpIDDefMinusOne();

	Emit(TEXT("PAGER"));
}



//////////////////////////////////////////////////////////////////////////////////////////////////
//
// HEADER
//
//
//  HDS_HORZ                0x0000
//  HDS_BUTTONS             0x0002
//  HDS_HOTTRACK            0x0004
//  HDS_HIDDEN              0x0008
//  HDS_DRAGDROP            0x0040
//  HDS_FULLDRAG            0x0080
//
void CResControl::DumpHeader(LPTSTR szBuffer, LPCTSTR pszTitle)
{
    DWORD dwRemainingStyles = GetControlStyle();

    CONTROL( HDS_BUTTONS,         TEXT("BUTTONS"),      m_AutoScroll, FALSE );
    CONTROL( HDS_HOTTRACK,         TEXT("HOTTRACK"),      m_AutoScroll, FALSE );
    CONTROL( HDS_FULLDRAG,         TEXT("HDS_FULLDRAG"),      m_AutoScroll, FALSE );

    DumpTabStop(FALSE);

	DumpWindowStyle();
    DumpStyleEX();
	DumpLocation();
    // DumpText();  - I don't think that they need text
	DumpIDDefMinusOne();

	Emit(TEXT("HEADER"));
}


//////////////////////////////////////////////////////////////////////////////////////////////////
//
// ListView
//
// LVS_ICON                0x0000
// LVS_REPORT              0x0001  *@DISPLAY="REPORT"
// LVS_SMALLICON           0x0002  *@DISPLAY="SMALLICON"
// LVS_LIST                0x0003  *@DISPLAY="LIST"
// LVS_TYPEMASK            0x0003

// LVS_SINGLESEL           0x0004  *@SELECTION="SINGLE"
// LVS_SHOWSELALWAYS       0x0008  *WIN32:TREEVIEW @SHOWSELALWAYS="YES"

// LVS_SORTASCENDING       0x0010  *@SORT="ASCENDING"
// LVS_SORTDESCENDING      0x0020  *@SORT="DESCENDING"
// LVS_SHAREIMAGELISTS     0x0040  *WIN32:TREEVIEW @SHAREIMAGELIST="YES"
// LVS_NOLABELWRAP         0x0080  *@NOLABELWRAP="YES"

// LVS_AUTOARRANGE         0x0100  *@AUTOARRANGE="YES"
// LVS_EDITLABELS          0x0200  *@EDITLABELS="YES"

// LVS_OWNERDATA           0x1000  *WIN32:TREEVIEW @OWNERDATA="YES"
// LVS_NOSCROLL            0x2000  *@NOSCROLL="YES"

// LVS_TYPESTYLEMASK       0xfc00

// LVS_ALIGNTOP            0x0000  *@ALIGN="TOP"
// LVS_ALIGNLEFT           0x0800  *@ALIGN="LEFT"
// LVS_ALIGNMASK           0x0c00

// LVS_OWNERDRAWFIXED      0x0400  *WIN32:TREEVIEW @OWNERDRAWFIXED="YES"
// LVS_NOCOLUMNHEADER      0x4000  *@NOCOLUMNHEADER="YES"
// LVS_NOSORTHEADER        0x8000  *@NOSORTHEADER="YES"
void CResControl::DumpListView(LPTSTR szBuffer, LPCTSTR pszTitle)
{
    DWORD dwRemainingStyles = GetControlStyle();

    if( dwRemainingStyles & LVS_SINGLESEL)
        Add(TEXT("SELECTION=\"SINGLE\" "));
    m_dumpedStyle |= LVS_SINGLESEL;

    switch( dwRemainingStyles & LVS_TYPEMASK )
    {
    case LVS_ICON:
    default:
        break;
    case LVS_REPORT:
        Add(TEXT("DISPLAY=\"REPORT\" "));
        break;
    case LVS_SMALLICON:
        Add(TEXT("DISPLAY=\"SMALLICON\" "));
        break;
    case LVS_LIST:
        Add(TEXT("DISPLAY=\"LIST\" "));
        break;
    }
    m_dumpedStyle |= LVS_TYPEMASK;

    if( dwRemainingStyles & LVS_SORTASCENDING )
        Add(TEXT("SORT=\"ASCENDING\" "));
    if( dwRemainingStyles & LVS_SORTDESCENDING )
        Add(TEXT("SORT=\"DESCENDING\" "));
    m_dumpedStyle |= LVS_SORTASCENDING | LVS_SORTDESCENDING;
    
    switch( dwRemainingStyles & LVS_ALIGNMASK )
    {
    case LVS_ALIGNTOP:
        Add(TEXT("ALIGN=\"TOP\" "));
            break;
    case LVS_ALIGNLEFT:
        Add(TEXT("ALIGN=\"LEFT\" "));
            break;
    }
    m_dumpedStyle |= LVS_ALIGNMASK;

    CONTROL( LVS_NOLABELWRAP,        TEXT("NOLABELWRAP"),         m_NoLabelWrap, FALSE );
    CONTROL( LVS_AUTOARRANGE,        TEXT("AUTOARRANGE"),         m_AutoArrange, FALSE );
    CONTROL( LVS_EDITLABELS,         TEXT("EDITLABELS"),          m_EditLabels, FALSE );
    CONTROL( LVS_NOSCROLL,           TEXT("NOSCROLL"),            m_NoScroll, FALSE );
    CONTROL( LVS_NOCOLUMNHEADER,     TEXT("NOCOLUMNHEADER"),      m_NoColHeader, FALSE );
    CONTROL( LVS_NOSORTHEADER,       TEXT("NOSORTHEADER"),        m_NoSortHeader, FALSE );

    CONTROLSTYLE( LVS_OWNERDRAWFIXED,TEXT("OWNERDRAWFIXED"),    m_OwnerDrawFixed, FALSE );
    CONTROLSTYLE( LVS_OWNERDATA,     TEXT("OWNERDATA"),         m_OwnerData,      FALSE );
    CONTROLSTYLE( LVS_SHAREIMAGELISTS,TEXT("SHAREIMAGELISTS"),  m_ShareImageList, FALSE );
    CONTROLSTYLE( LVS_SHOWSELALWAYS, TEXT("SHOWSELALWAYS"),     m_ShowSelAlways,  FALSE );

    DumpTabStop(TRUE);

	DumpWindowStyle();
    DumpStyleEX();
	DumpLocation();
    // DumpText();  - I don't think that they need text
	DumpIDDefMinusOne();

	Emit(TEXT("LISTVIEW"));
}

////////////////////////////////////////////////////////////////////////////////////
// TreeView
//
// TVS_HASBUTTONS          0x0001   @EXPANDBOXES="YES" (or @HASBUTTONS?)
// TVS_HASLINES            0x0002   @LINES="YES"
// TVS_LINESATROOT         0x0004   @LINES="ROOT" (turns on TVS_HASLINES)
// TVS_EDITLABELS          0x0008   @EDITLABELS="YES"

// TVS_DISABLEDRAGDROP     0x0010   @DISABLEDRAGDROP="YES"
// TVS_SHOWSELALWAYS       0x0020   WIN32:TREEVIEW @SHOWSELALWAYS="YES"
// TVS_RTLREADING          0x0040   WIN32:TREEVIEW @RTLREADING="YES"
// TVS_NOTOOLTIPS          0x0080   @NOTOOLTIPS="YES"

// TVS_CHECKBOXES          0x0100   @CHECBOXES="YES"
// TVS_TRACKSELECT         0x0200   WIN32:TREEVIEW @TRACKSELECT="YES"
// TVS_SINGLEEXPAND        0x0400   @AUTOEXPAND="YES"
// TVS_INFOTIP             0x0800   WIN32:TREEVIEW @INFOTIP="YES"

// TVS_FULLROWSELECT       0x1000   @ROWSELECT="YES"
// TVS_NOSCROLL            0x2000   @NOSCROLL="YES"
// TVS_NONEVENHEIGHT       0x4000   WIN32:TREEVIEW @NOEVENHEIGHT="YES"

void CResControl::DumpTreeView(LPTSTR szBuffer, LPCTSTR pszTitle)
{
    DWORD dwRemainingStyles = GetControlStyle();

    CONTROL( TVS_HASBUTTONS,         TEXT("EXPANDBOXES"),      m_ExpandBoxes, FALSE );
    if( dwRemainingStyles & TVS_LINESATROOT )
    {
        Add(TEXT("LINES=\"ROOT\" "));
    }
    else
    {
        if( dwRemainingStyles & TVS_HASLINES )
            Add(TEXT("LINES=\"YES\" "));
    }
    m_dumpedStyle |= TVS_HASLINES | TVS_LINESATROOT;

    CONTROL( TVS_EDITLABELS,        TEXT("EDITLABELS"),         m_EditLables, FALSE );
    CONTROL( TVS_DISABLEDRAGDROP,   TEXT("DISABLEDRAGDROP"),    m_DisableDragDrop, FALSE );
    CONTROL( TVS_NOTOOLTIPS,        TEXT("NOTOOLTIPS"),         m_NoTooltips, FALSE );
    CONTROL( TVS_CHECKBOXES,        TEXT("CHECKBOXES"),         m_CheckBoxes, FALSE );
    CONTROL( TVS_SINGLEEXPAND,      TEXT("AUTOEXPAND"),         m_AutoExpand, FALSE );
    CONTROL( TVS_FULLROWSELECT,     TEXT("ROWSELECT"),          m_FullRowSelect, FALSE );
    CONTROL( TVS_NOSCROLL,          TEXT("NOSCROLL"),           m_NoScroll, FALSE );

    CONTROLSTYLE( TVS_SHOWSELALWAYS,   TEXT("SHOWSELALWAYS"), m_ShowSelAlways, FALSE );
    CONTROLSTYLE( TVS_RTLREADING,      TEXT("RTLREADING"),    m_RTLReading,    FALSE );
    CONTROLSTYLE( TVS_TRACKSELECT,     TEXT("TRACKSELECT"),   m_TrackSelect,   FALSE );
    CONTROLSTYLE( TVS_INFOTIP,         TEXT("INFOTIP"),       m_InfoTip,       FALSE );
    CONTROLSTYLE( TVS_NONEVENHEIGHT,   TEXT("NONEVENHEIGHT"), m_NoEvenHeight,  FALSE );

    DumpTabStop(TRUE);

	DumpWindowStyle();
    DumpStyleEX();
	DumpLocation();
    // DumpText();  - I don't think that they need text
	DumpIDDefMinusOne();

	Emit(TEXT("TREEVIEW"));
}

// http://msdn.microsoft.com/workshop/author/dhtml/reference/objects/SELECT.asp
// LBS_NOTIFY            0x0001L     C  // WIN32:LISTBOX\@NOTIFY
// LBS_SORT              0x0002L     A  // SORT="YES"
// LBS_NOREDRAW          0x0004L     C  // WIN32:LISTBOX\@NOREDRAW
// LBS_MULTIPLESEL       0x0008L     A  // MULTIPLE="YES"
// LBS_OWNERDRAWFIXED    0x0010L     C  // WIN32:COMBOBOX\@OWNERDRAWFIXED
// LBS_OWNERDRAWVARIABLE 0x0020L     C  // WIN32:COMBOBOX\@OWNERDRAWVARIABLE
// LBS_HASSTRINGS        0x0040L     C  // WIN32:COMBOBOX\HASSTRINGS
// LBS_USETABSTOPS       0x0080L     C  // WIN32:COMBOBOX\@TABSTOPS
// LBS_NOINTEGRALHEIGHT  0x0100L     C  // WIN32:COMBOBOX\@NOINTEGRALHEIGHT
// LBS_MULTICOLUMN       0x0200L     C  // MULTICOLUMN="YES"
// LBS_WANTKEYBOARDINPUT 0x0400L     C  // WIN32:COMBOBOX\@WANTKEYBOARDINPUT
// LBS_EXTENDEDSEL       0x0800L     A  // SELECTION="EXTENDED"
// LBS_DISABLENOSCROLL   0x1000L     C  // WIN32:COMBOBOX\DISALBENOSCROLL
// LBS_NODATA            0x2000L     C  // WIN32:COMBOBOX\@NODATA
// LBS_NOSEL             0x4000L     A  // SELECTION="NO"
void CResControl::DumpListBox(LPTSTR szBuffer, LPCTSTR pszTitle)
{
    DWORD dwRemainingStyles = GetControlStyle();

    CONTROLSTYLE( LBS_NOTIFY, TEXT("NOTIFY"),       m_Notify, TRUE );

    if( (dwRemainingStyles & LBS_SORT ) == FALSE )
    {
        Add(TEXT("SORT=\"NO\" "));      // default is ON.
    }
    m_dumpedStyle |= LBS_SORT;

    CONTROLSTYLE( LBS_NOREDRAW, TEXT("NNOREDRAW"), m_NoRedraw, FALSE );

    if( dwRemainingStyles & LBS_MULTIPLESEL )
    {
        Add(TEXT("MULTIPLE=\"YES\" "));
    }
    m_dumpedStyle  |= LBS_MULTIPLESEL;


    CONTROLSTYLE( LBS_OWNERDRAWFIXED, TEXT("OWNERDRAWFIXED"),       m_OwnerDrawFixed, FALSE );
    CONTROLSTYLE( LBS_OWNERDRAWVARIABLE, TEXT("OWNERDRAWVARIABLE"), m_OwnerDrawVariable, FALSE );

    CONTROLSTYLE( LBS_HASSTRINGS, TEXT("HASSTRINGS"), m_HasStrings, FALSE );
    CONTROLSTYLE( LBS_USETABSTOPS, TEXT("TABSTOPS"), m_UseTabstops, FALSE );

    CONTROLSTYLE( LBS_NOINTEGRALHEIGHT, TEXT("NOINTEGRALHEIGHT"), m_NoIntegralHeight, TRUE );
    CONTROLSTYLE( LBS_WANTKEYBOARDINPUT, TEXT("WANTKEYBOARDINPUT"), m_WantKeyboardInput, FALSE );

    if( dwRemainingStyles & LBS_MULTICOLUMN )
    {
        Add(TEXT("MULTICOLUMN=\"YES\" "));
    }
    m_dumpedStyle  |= LBS_MULTICOLUMN;


    // TRICKY!
    if( dwRemainingStyles & ( LBS_EXTENDEDSEL | LBS_NOSEL ) )
    {
        if(  dwRemainingStyles & LBS_EXTENDEDSEL )
            Add(TEXT("SELECTION=\"EXTENDED\" "));
        else
            Add(TEXT("SELECTION=\"NO\" "));
    }
    m_dumpedStyle  |= ( LBS_EXTENDEDSEL | LBS_NOSEL );

    CONTROLSTYLE( LBS_DISABLENOSCROLL, TEXT("DISABLENOSCROLL"), m_DisableNoScroll, FALSE );
    CONTROLSTYLE( LBS_NODATA, TEXT("NODATA"), m_NoData, FALSE );

    DumpTabStop(TRUE);

	DumpWindowStyle();
    DumpStyleEX();
    DumpID();
    DumpText();
	DumpLocation();

    if( GetCicero() )
        AddCicero( TEXT(":CMD ") );

    //
    // See if there are any items in the listbox.
    //
    if(m_hwnd && m_Parent.GetEnhanced() )
    {
        int iCount=SendMessage( m_hwnd, LB_GETCOUNT, NULL, NULL);
        if( iCount!=LB_ERR)
        {
            WORD wLen=0;
            LPTSTR szText=NULL;
            LPTSTR szItem=NULL;
            int iCurSel = SendMessage(m_hwnd, LB_GETCURSEL , 0, 0); 
            for(int i=0;i<iCount;i++)
            {
                int iLen=SendMessage(m_hwnd, LB_GETTEXTLEN , i, 0);
                if( iLen > wLen )
                {
                    delete szText;
                    wLen=iLen+20;
                    szText=new TCHAR[wLen];
                    delete szItem;
                    szItem=new TCHAR[wLen+100]; // this is the XML wrapped up version.
                }
                SendMessage(m_hwnd, LB_GETTEXT , i, (LPARAM)szText );
                int id=SendMessage(m_hwnd, LB_GETITEMDATA , i, NULL );
                LPWSTR szFixedString=m_Parent.FixEntity( szText );

                LPWSTR szNextText=szItem;
                szNextText += wsprintf(szNextText, TEXT("<ITEM "));

                if( id )
                    szNextText += wsprintf(szNextText, TEXT("ID=\"%u\" "), id);

                if( i==iCurSel )
                    szNextText += wsprintf(szNextText, TEXT("SELECTED=\"YES\" ") );

                szNextText += wsprintf(szNextText, TEXT("TEXT=\"%s\" />"), szFixedString);

                m_pDumpCache->AllocAddChild(szItem);
                delete szFixedString;
            }
            delete szText;
            delete szItem;
        }
    }

	Emit(TEXT("LISTBOX"));
    // REVIEW in Enhanced mode we should add the <ITEM> stuff to show off.
}

//
// ComboBox
//
// CBS_SIMPLE            0x0001L     A  // SIZE!="1" READONLY (doesn't matter)
// CBS_DROPDOWN          0x0002L     A  // SIZE="1" READONLY="NO
// CBS_DROPDOWNLIST      0x0003L     A  // SIZE="1" READONLY="YES"
// CBS_OWNERDRAWFIXED    0x0010L     C  // WIN32:COMBOBOX\@OWNERDRAWFIXED
// CBS_OWNERDRAWVARIABLE 0x0020L     C  // WIN32:COMBOBOX\@OWNERDRAWVARIABLE
// CBS_AUTOHSCROLL       0x0040L     S  // STYLE\overflow-y="auto"
// CBS_OEMCONVERT        0x0080L     C  // WIN32:COMBOBOX\OEMCONVERT
// CBS_SORT              0x0100L     A  // SORT="YES"
// CBS_HASSTRINGS        0x0200L     C  // WIN32:COMBOBOX\HASSTRINGS
// CBS_NOINTEGRALHEIGHT  0x0400L     C  // WIN32:COMBOBOX\NOINTEGRALHEIGHT
// CBS_DISABLENOSCROLL   0x0800L     C  // WIN32:COMBOBOX\DISALBENOSCROLL
// CBS_UPPERCASE           0x2000L   S  // STYLE\@text-transform=uppercase
// CBS_LOWERCASE           0x4000L   S  // STYLE\@text-transform=lowercase
//
// http://msdn.microsoft.com/workshop/author/dhtml/reference/objects/SELECT.asp
//
// CICERO:COMBO
// Readonly combo, means we can generate the list of options
// 
void CResControl::DumpComboBox(LPTSTR szBuffer, LPCTSTR pszTitle)
{
    DWORD dwRemainingStyles = GetControlStyle();

    //
    // This is a bit strange, although it's an ENUM, we're mapping
    // to two attributes, SIZE (from HTML) and READONLY (as in, non editable text).
    // this isn't a rendering style, just you can't add any more items to the list, just
    // pick one.
    // DEFAULTS : SIZE="1" and READONLY="NO"    
    //
    BOOL bReadOnly=FALSE;
    switch ( dwRemainingStyles & 0xf )
    {
    case CBS_SIMPLE:
        Add(TEXT("SIZE=\"-1\" "));
        break;
    default:
    case CBS_DROPDOWN:
        // Add(TEXT("READONLY=\"NO\" ));
        break;
    case CBS_DROPDOWNLIST:
        Add(TEXT("READONLY=\"YES\" "));
        bReadOnly=TRUE;
        break;
    }
    m_dumpedStyle |= 0xf;

    CONTROLSTYLE( CBS_OWNERDRAWFIXED, TEXT("OWNERDRAWFIXED"),       m_OwnerDrawFixed, FALSE );
    CONTROLSTYLE( CBS_OWNERDRAWVARIABLE, TEXT("OWNERDRAWVARIABLE"), m_OwnerDrawVariable, FALSE );

    if( !( dwRemainingStyles & CBS_AUTOHSCROLL ) )
		AddStyle( TEXT("OVERFLOW-X=\"VISIBLE\" ")); // can only type as big as the control
    m_dumpedStyle |=CBS_AUTOHSCROLL;

    CONTROLSTYLE( CBS_OEMCONVERT, TEXT("OEMCONVERT"), m_OemConvert, FALSE );

    CONTROL( CBS_SORT, TEXT("SORT"), m_Sort, TRUE );    // default is to sort.

    CONTROLSTYLE( CBS_HASSTRINGS, TEXT("HASSTRINGS"), m_HasStrings, FALSE );


    CONTROLSTYLE( CBS_NOINTEGRALHEIGHT, TEXT("NOINTEGRALHEIGHT"), m_NoIntegralHeight, FALSE );
    CONTROLSTYLE( CBS_DISABLENOSCROLL, TEXT("DISABLENOSCROLL"), m_DisableNoScroll, FALSE );

    switch( dwRemainingStyles & (CBS_UPPERCASE | CBS_LOWERCASE ) )
    {
    case CBS_UPPERCASE:
        AddStyle( TEXT("TEXT-TRANSFORM=\"UPPERCASE\" "));
        break;
    case CBS_LOWERCASE:
        AddStyle( TEXT("TEXT-TRANSFORM=\"LOWERCASE\" "));
        break;
    default:
        //
        break;
    }
    m_dumpedStyle |= (CBS_UPPERCASE | CBS_LOWERCASE );

    DumpTabStop(TRUE);

	DumpWindowStyle();
    DumpStyleEX();
    DumpID();
    DumpText();

    //
    // need to fix up the height of the combo.
    // combo's height is always fixed, so we need to find the drop height.
    //
    RECT dropped;
    if(m_hwnd)
    {
        SendMessage(m_hwnd, CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)&dropped);
        SIZE size;
        size.cx = dropped.right - dropped.left ;
        size.cy = dropped.bottom - dropped.top;
        size = m_Parent.m_Font.GetDlgUnitsFromPixels( size );
        SetHeight(size.cy);
    }
	DumpLocation();

#if 0
    if( GetCicero() )
    {
        if( bReadOnly==FALSE )
            // AddCicero( TEXT(":CFG FILENAME=\"somecfg.xml\" ") );    // it's free form data entry
            AddCicero( TEXT(":CMD ") );    // it's free form data entry
        else
            AddCicero( TEXT(":CMD ") );                             // we can runtime command this.
    }
#else
    if( GetCicero() )
    {
        LPWSTR pszShortButtonText=FindNiceText( GetRawTitle() );
    	wsprintf(szBuffer,TEXT(":CMD "));
        AddCicero(szBuffer);
    	wsprintf(szBuffer,TEXT("<CICERO:FAILURE TEXT=\"Unable to make that selection\" />") );
        m_pCicero->AllocAddChild( szBuffer);
        delete pszShortButtonText;
    }

#endif
    //
    // See if there are any items in the combobox.
    //
    if(m_hwnd && m_Parent.GetEnhanced() )
    {
        int iCount=SendMessage( m_hwnd, CB_GETCOUNT, NULL, NULL);
        if( iCount!=CB_ERR)
        {
            WORD wLen=0;
            LPTSTR szText=NULL;
            LPTSTR szItem=NULL;
            int iCurSel = SendMessage(m_hwnd, CB_GETCURSEL , 0, 0); 
            for(int i=0;i<iCount;i++)
            {
                int iLen=SendMessage(m_hwnd, CB_GETLBTEXTLEN , i, 0);
                if( iLen > wLen )
                {
                    delete szText;
                    wLen=iLen+20;
                    szText=new TCHAR[wLen];
                    delete szItem;
                    szItem=new TCHAR[wLen+100]; // this is the XML wrapped up version.
                }
                SendMessage(m_hwnd, CB_GETLBTEXT , i, (LPARAM)szText );
                int id=SendMessage(m_hwnd, CB_GETITEMDATA , i, NULL );
                LPWSTR szFixedString=m_Parent.FixEntity( szText );

                LPWSTR szNextText=szItem;
                szNextText += wsprintf(szNextText, TEXT("<ITEM "));

                if( id )
                    szNextText += wsprintf(szNextText, TEXT("ID=\"%u\" "), id);

                if( i==iCurSel )
                    szNextText += wsprintf(szNextText, TEXT("SELECTED=\"YES\" ") );

                szNextText += wsprintf(szNextText, TEXT("TEXT=\"%s\" />"), szFixedString);

                m_pDumpCache->AllocAddChild(szItem);
                delete szFixedString;
            }
            delete szText;
            delete szItem;
        }
    }

	Emit(TEXT("COMBOBOX"));
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Control specific rules.
//
////////////////////////////////////////////////////////////////////////////////////////
// BS_PUSHBUTTON       0x00000000L
// BS_DEFPUSHBUTTON    0x00000001L
// BS_CHECKBOX         0x00000002L
// BS_AUTOCHECKBOX     0x00000003L
// BS_RADIOBUTTON      0x00000004L
// BS_3STATE           0x00000005L
// BS_AUTO3STATE       0x00000006L
// BS_GROUPBOX         0x00000007L
// BS_USERBUTTON       0x00000008L
// BS_AUTORADIOBUTTON  0x00000009L
// BS_OWNERDRAW        0x0000000BL
// BS_LEFTTEXT         0x00000020L
// BS_TEXT             0x00000000L
// BS_ICON             0x00000040L
// BS_BITMAP           0x00000080L
// BS_LEFT             0x00000100L
// BS_RIGHT            0x00000200L
// BS_CENTER           0x00000300L
// BS_TOP              0x00000400L
// BS_BOTTOM           0x00000800L
// BS_VCENTER          0x00000C00L
// BS_PUSHLIKE         0x00001000L
// BS_MULTILINE        0x00002000L
// BS_NOTIFY           0x00004000L
// BS_FLAT             0x00008000L
// BS_RIGHTBUTTON      BS_LEFTTEXT

BOOL CResControl::DumpDefButtonRules()
{
    DWORD dwRemainingStyles=GetControlStyle();

    //
    // we don't dump everything here - some style bits don't make sense for all buttons
    // e.g. TRI_STATE for groupboxes.
    //
    dwRemainingStyles &= ~ m_dumpedStyle;  

    // The low 4 bits are an enum
    dwRemainingStyles &= ~ 0xf;

    //
    // These are all the style bits that this method emits.
    //
    m_dumpedStyle |= 
        (BS_FLAT | BS_NOTIFY | BS_MULTILINE | BS_RIGHT | BS_LEFT | BS_BOTTOM | BS_TOP );

    //
    // REVIEW BS_ICON BS_BITMAP ??
    //
    CONTROLSTYLE( BS_LEFTTEXT,    TEXT("LEFTTEXT"),   m_LeftText, FALSE );    // only for check / radio
    CONTROLSTYLE( BS_FLAT,        TEXT("FLAT"),       m_Flat,     FALSE );
    CONTROLSTYLE( BS_NOTIFY,      TEXT("NOTIFY"),     m_Notify,   FALSE );
    CONTROLSTYLE( BS_MULTILINE,   TEXT("MULTILINE"),  m_MultiLine,FALSE );
    CONTROLSTYLE( BS_ICON,        TEXT("ICON"),       m_Icon,     FALSE );
    CONTROLSTYLE( BS_BITMAP,      TEXT("BITMAP"),     m_Bitmap,   FALSE );
    CONTROLSTYLE( BS_PUSHLIKE,    TEXT("PUSHLIKE"),   m_Pushlike, FALSE );

    //
    // BOTH RIGHT and LEFT is CENTER -CSS-
    //
    if(dwRemainingStyles & BS_CENTER )
    {
        if( (dwRemainingStyles & BS_CENTER) == BS_CENTER )
        {
            AddStyle(TEXT("TEXT-ALIGN=\"CENTER\" "));
        }
        else
        {
            if( dwRemainingStyles & BS_RIGHT )
                AddStyle(TEXT("TEXT-ALIGN=\"RIGHT\" "));
            else
                AddStyle(TEXT("TEXT-ALIGN=\"LEFT\" "));
        }
    }

    //
    // BS_TOP & BS_BOTTOM == BS_CENTER
    //
	if(dwRemainingStyles & BS_VCENTER )
	{
        if( (dwRemainingStyles & BS_VCENTER) == BS_VCENTER )
        {
            AddStyle(TEXT("VERTICAL-ALIGN=\"MIDDLE\" "));
        }
        else
        {
            if( dwRemainingStyles & BS_TOP )
                AddStyle(TEXT("VERTICAL-ALIGN=\"TOP\" "));
            else
                AddStyle(TEXT("VERTICAL-ALIGN=\"BOTTOM\" "));
        }
	}

    DumpTabStop(TRUE);

	return true;
}

//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
// Tab
//
// TCS_SCROLLOPPOSITE      0x0001   @SHUFFLE="YES" // assumes multiline tab
// TCS_BOTTOM              0x0002   @ALIGN="BOTTOM"
// TCS_RIGHT               0x0002   @ALIGN="RIGHT"
// TCS_MULTISELECT         0x0004   @MULTISELECT="YES" // allow multi-select in button mode
// TCS_FLATBUTTONS         0x0008   WIN32:TAB\@FLATBUTTONS="YES"
// TCS_FORCEICONLEFT       0x0010   WIN32:TAB\@FORCEICONLEFT="YES"
// TCS_FORCELABELLEFT      0x0020   WIN32:TAB\@FORCELABELLEFT="YES"
// TCS_HOTTRACK            0x0040   @HOTTRACK
// TCS_VERTICAL            0x0080   @ORIENTATION="VERTICAL"
// TCS_TABS                0x0000   @STYLE="TABS"
// TCS_BUTTONS             0x0100   @STYLE="BUTTONS"
// TCS_SINGLELINE          0x0000   @MULTILINE="NO"
// TCS_MULTILINE           0x0200   @MULTILINE="YES"
// TCS_RIGHTJUSTIFY        0x0000   @JUSTIFY="RIGHT"
// TCS_FIXEDWIDTH          0x0400   @FIXEDWIDTH="YES"
// TCS_RAGGEDRIGHT         0x0800   @JUSTIFY="LEFT"
// TCS_FOCUSONBUTTONDOWN   0x1000   WIN32:TAB\@FOCUSONBUTTONDOWN="YES"
// TCS_OWNERDRAWFIXED      0x2000   WIN32:TAB\@OWNERDRAWFIXED="YES"
// TCS_TOOLTIPS            0x4000   // implied from HELP\TOOLTIP\TEXT="..."
// TCS_FOCUSNEVER          0x8000   WIN32:TAB\@FOCUSNEVER="YES"
// EX styles for use with TCM_SETEXTENDEDSTYLE
// TCS_EX_FLATSEPARATORS   0x00000001   WIN32:TAB\FLATSEPARATORS="YES"
// TCS_EX_REGISTERDROP     0x00000002   WIN32:TAB\REGISTERDROP="YES"
//
void CResControl::DumpTab(LPTSTR szBuffer, LPCTSTR pszTitle)
{
    DWORD dwRemainingStyles = GetControlStyle();

    CONTROL( TCS_SCROLLOPPOSITE, TEXT("SHUFFLE"), 0, FALSE );
    if( dwRemainingStyles & TCS_BOTTOM )
        Add(TEXT("ALIGN=\"BOTTOM\" "));

    CONTROL( TCS_MULTISELECT, TEXT("MULTISELECT"), 0, FALSE );

    CONTROLSTYLE( TCS_FLATBUTTONS, TEXT("FLATBUTTONS"), m_FlatButtons, FALSE );
    CONTROLSTYLE( TCS_FORCEICONLEFT, TEXT("FORCEICONLEFT"), m_ForceIconLeft, FALSE );
    CONTROLSTYLE( TCS_FORCELABELLEFT, TEXT("FORCELABELLEFT"), m_ForceLabelLeft, FALSE );

    CONTROL( TCS_HOTTRACK, TEXT("HOTTRACK"), 0, FALSE );

    if( dwRemainingStyles & TCS_VERTICAL )
        Add(TEXT("ORIENTATION=\"VERTICAL\" "));

    if( dwRemainingStyles & TCS_BUTTONS )
        Add(TEXT("STYLE=\"BUTTONS\" "));

    CONTROL( TCS_MULTILINE, TEXT("MULTILINE"), 0, FALSE );

    if( dwRemainingStyles & TCS_RAGGEDRIGHT )
        Add(TEXT("JUSTIFY=\"LEFT\" "));

    CONTROL( TCS_FIXEDWIDTH, TEXT("FIXEDWIDTH"), m_FixedWidth, FALSE );

    CONTROLSTYLE( TCS_FOCUSONBUTTONDOWN, TEXT("FOCUSONBUTTONDOWN"), m_FocusButtonDown, FALSE );
    CONTROLSTYLE( TCS_OWNERDRAWFIXED, TEXT("OWNERDRAWFIXED"), m_OwnerDrawFixed, FALSE );
    CONTROLSTYLE( TCS_FOCUSNEVER, TEXT("FOCUSNEVER"), m_FocusNever, FALSE );

    // This is a hack
    if( dwRemainingStyles & TCS_TOOLTIPS )
        m_pDumpCache->AddChild(TEXT(" <HELP><TOOLTIP/></HELP> "), FALSE);

    m_dumpedStyle |= (TCS_BOTTOM | TCS_VERTICAL | TCS_BUTTONS | 
                        TCS_RAGGEDRIGHT | TCS_FIXEDWIDTH | TCS_TOOLTIPS);

    DumpTabStop(TRUE);

	DumpWindowStyle();
    DumpStyleEX();
    DumpID();
    DumpText();
	DumpLocation();

    if( GetCicero() )
        AddCicero( TEXT(":CMD ") );

    // we dumb the tab headers regardless of cicero.
    if(m_hwnd && m_Parent.GetEnhanced() )
    {
#if 0
        int tabCount = TabCtrl_GetItemCount( m_hwnd );
        TCHAR   tabText[MAX_PATH];
        TCHAR   tabHeaderText[MAX_PATH];
        tabText[0]=0;
        for( int i=0;i<tabCount;i++)
        {

            TCITEMHEADER header={0};
            header.pszText=tabHeaderText;
            header.cchTextMax=129;
            header.mask |= TCIF_TEXT;

            TCITEM item={0};
            item.pszText = tabText;
            item.cchTextMax = 127;
            item.mask = TCIF_TEXT; // | TCIF_PARAM;
            item.lParam = NULL; // (LPARAM)&header;
            // TabCtrl_GetItem( m_hwnd, i, &item);
            SendMessage( m_hwnd, TCM_GETITEMW, i, (LPARAM)&item);
            TRACE(TEXT("The text for the tab is '%s'\n"),item.pszText);
        }
#endif

#if 0
        IAccessible * pA;
        HRESULT hr;
        CoInitialize(NULL);
        if( SUCCEEDED(hr=AccessibleObjectFromWindow( m_hwnd, 
            OBJID_WINDOW,   // works for office, information about the window itself, how many children it has.
            // OBJID_MENU , // the menu for the window, doesn't work for office.
            IID_IAccessible, (LPVOID*)&pA ) ))
        {
            CResFile::FindMenuItem(pA, ROLE_SYSTEM_PAGETAB );
            pA->Release();
        }
        CoUninitialize();
#endif
    }

	Emit(TEXT("TAB"));

    // REVIEW in Enhanced mode we should add the <ITEM> stuff to show off.
}

//
// Animation
//
// ACS_CENTER              0x0001
// ACS_TRANSPARENT         0x0002
// ACS_AUTOPLAY            0x0004
// ACS_TIMER               0x0008  // don't use threads... use timers
//
void CResControl::DumpAnimation(LPTSTR szBuffer, LPCTSTR pszTitle)
{
    DWORD dwRemainingStyles = GetControlStyle();
    Add( TEXT("CONTENT=\"ANIMATION\" "));

    if( dwRemainingStyles & ACS_CENTER )
        Add( TEXT("ALIGN=\"CENTER\" ") );

    CONTROL( ACS_TRANSPARENT, TEXT("TRANSPARENT"), 0, FALSE );
    CONTROL( ACS_AUTOPLAY, TEXT("AUTOPLAY"), 0, FALSE );
    CONTROLSTYLE( ACS_TIMER, TEXT("TIMER"), m_Timer, FALSE );

    m_dumpedStyle |= ACS_CENTER;

    DumpTabStop(FALSE);

	DumpWindowStyle();
	DumpStyleEX();
	DumpLocation();
	DumpIDDefMinusOne();

	Add( TEXT("FILE=\"filename goes here\" ") );

	Emit(TEXT("IMAGE"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlgen\fileencoder.cpp ===
// FileEncoder.cpp: implementation of the CFileEncoder class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "FileEncoder.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CFileEncoder::CFileEncoder()
{
    m_hFile = INVALID_HANDLE_VALUE;
}

CFileEncoder::~CFileEncoder()
{
    CloseFile();
}

BOOL CFileEncoder::CreateFile(LPCTSTR pszFile)
{
    CloseFile();

    m_hFile = ::CreateFile(
	pszFile,
	GENERIC_WRITE,
	FILE_SHARE_READ,
	NULL,
	CREATE_ALWAYS,
	FILE_ATTRIBUTE_NORMAL,
	NULL);

    SetFilename( (LPTSTR)pszFile );

    if( m_hFile != INVALID_HANDLE_VALUE )
    {
	    DWORD dwWritten;
        WORD  unicodePrefix = 0xFEFF;
        BYTE utf8Prefix[] = { 0xEF, 0xBB, 0xBF };

        switch ( GetEncoding() )
        {
        case RF_UNICODE:
	        WriteFile(m_hFile, &unicodePrefix, sizeof(unicodePrefix),&dwWritten,NULL);
            break;
        case RF_ANSI:
	        // WriteFile(m_hFile, &unicodePrefix, sizeof(unicodePrefix),&dwWritten,NULL);
            break;
        case RF_UTF8:
	        WriteFile(m_hFile, utf8Prefix, sizeof(utf8Prefix),&dwWritten,NULL);
            break;
        }
        return TRUE;
    }

    return FALSE;
}

void CFileEncoder::Write(LPCTSTR pszString, BOOL bNewLine)
{
	DWORD dwWritten;
    switch ( GetEncoding() )
    {
    case RF_UNICODE:
	    WriteFile( m_hFile, pszString, lstrlen(pszString)*sizeof(TCHAR),&dwWritten,NULL);
	    if(bNewLine)
		    WriteFile( m_hFile, TEXT("\r\n"), 2*sizeof(TCHAR), &dwWritten, NULL );
    break;

    case RF_ANSI:
        {
	    WriteFile( m_hFile, pszString, lstrlen(pszString)*sizeof(TCHAR),&dwWritten,NULL);
	    if(bNewLine)
		    WriteFile( m_hFile, TEXT("\r\n"), 2*sizeof(TCHAR), &dwWritten, NULL );
        }
    break;

    case RF_UTF8:
        {
            // Get size of buffer needed.
            DWORD dwOutLen = WideCharToMultiByte( CP_UTF8, 0, pszString, -1, NULL, 0, NULL, NULL); 

	        CHAR * pBuffer = new CHAR[dwOutLen];
            dwOutLen = WideCharToMultiByte( CP_UTF8, 0, pszString, -1, pBuffer, dwOutLen, NULL, NULL ); 

   	        WriteFile( m_hFile, pBuffer, dwOutLen-1,&dwWritten,NULL);

	        if(bNewLine)
            {
                CHAR newLine[]= { 0x0d, 0x0a}; // , 00 };
       	        WriteFile( m_hFile, newLine, sizeof(newLine),&dwWritten,NULL);
            }

            delete pBuffer;
        }
    break;
    }
}

void CFileEncoder::CloseFile()
{
    if(m_hFile != INVALID_HANDLE_VALUE )
        CloseHandle( m_hFile );
    m_hFile = INVALID_HANDLE_VALUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlgen\fonts.cpp ===
//
// Simple font classes with helper functions.
//
// (C) Microsoft Corp.
// Felix Andrew 1999
//

#include "stdafx.h"
#include "fonts.h"

void CQuickFont::Init(HFONT hf)
{
	if(GetFont())
	{
		DeleteObject(GetFont());
		m_font=NULL;
		m_baseUnit=0;
	}

	//
	// Select the font into the DC
	//
	m_font=hf; // CreateFontIndirect(&lf);
	SelectObject(GetDC(), m_font );
	m_baseUnit=0;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////
CQuickFont::CQuickFont(LPTSTR name, DWORD dwSize)
: m_font(NULL), m_dc(NULL)
{
	Init(name, dwSize);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////
CQuickFont::~CQuickFont()
{
	if(m_font)
		DeleteObject(m_font);
	if(m_dc)
		ReleaseDC(NULL, m_dc);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Creates the font we require
//
//////////////////////////////////////////////////////////////////////////////////////////
void CQuickFont::Init(LPCTSTR name, DWORD dwSize )
{
	Init( name, dwSize, 0, FW_NORMAL );
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Creates the font we require
//
//////////////////////////////////////////////////////////////////////////////////////////
void CQuickFont::Init(LPCTSTR name, DWORD dwSize , DWORD dwStyle, DWORD dwWeight, LOGFONT * pBaseLF )
{
	if(GetFont())
	{
		DeleteObject(GetFont());
		m_font=NULL;
		m_baseUnit=0;
	}

    LOGFONT lf;

	if( ( (name==NULL) || (lstrcmpi(name,TEXT(""))==0) ) && (pBaseLF==NULL) )
		return;

	if(pBaseLF==NULL)
		ZeroMemory( &lf, sizeof(LOGFONT));
	else
		CopyMemory( &lf, pBaseLF, sizeof( LOGFONT ) );

	if( dwWeight )
		lf.lfWeight=dwWeight;

	if( dwStyle & FS_ITALIC )
		lf.lfItalic=TRUE;

	if( name )
		lstrcpy(lf.lfFaceName, name );

	if( dwSize )
	{
		lf.lfHeight = -MulDiv(dwSize, GetDeviceCaps(GetDC(), LOGPIXELSY), 72);
		m_dwSize=dwSize;
	}
	else
	{
		// BUGBUG - size is inherited from the logfont?
	}

	//
	// Select the font into the DC
	//
	m_font=CreateFontIndirect(&lf);

	SelectObject(GetDC(), m_font );
	m_baseUnit=0;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Gets a screen DC so we can calculate the size of text rendered in this font
//
//////////////////////////////////////////////////////////////////////////////////////////
HDC CQuickFont::GetDC()
{
	if(m_dc==NULL)
		m_dc=::GetDC(NULL);		// VadimG says this is OK
	return m_dc;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Calculates the height of a piece of text, given the width of the text
// loword is the height
// hi-word is the width
//
//////////////////////////////////////////////////////////////////////////////////////////
SIZE CQuickFont::HowHigh(LPCTSTR text, DWORD dwWidth)
{
	RECT rect={0};
	rect.right=dwWidth;
	rect.bottom=-1;
	DrawText( GetDC(), text, -1, &rect, DT_CALCRECT | DT_WORDBREAK);
	SIZE s;
	s.cx=rect.right;
	s.cy=rect.bottom;
	return s;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Returns the length of the text, so caller can determin if multi line / single line>
// returns HEIGHT WIDTH
//
//////////////////////////////////////////////////////////////////////////////////////////
SIZE CQuickFont::HowLong( LPCTSTR text )
{
	SIZE size;
	GetTextExtentPoint32( GetDC(), text, lstrlen(text), &size);
	// int width=0;
	// int height=0;
	// GetTextExtentExPoint( GetDC(), text, lstrlen(text), 0, &width, &height, &size );
	return size;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Taken from NT5 user.
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD CQuickFont::GetDialogBaseUnits()
{
	if(m_baseUnit)
		return m_baseUnit;
    m_baseUnit = GetDialogBaseUnits( GetDC(), m_font );
    return m_baseUnit;
}

DWORD CQuickFont::GetDialogBaseUnits( HDC hdc, HFONT font )
{
    DWORD baseUnit;
	TEXTMETRIC textMetric;
	SelectObject(hdc, font );
	GetTextMetrics( hdc, &textMetric);

	if( textMetric.tmPitchAndFamily & TMPF_FIXED_PITCH )
	{
        SIZE size;
        static CONST TCHAR wszAvgChars[] = TEXT("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
		int len=(sizeof(wszAvgChars) / sizeof(TCHAR)) - 1;
        /*
         * Change from tmAveCharWidth.  We will calculate a true average
         * as opposed to the one returned by tmAveCharWidth.  This works
         * better when dealing with proportional spaced fonts.
         */
        if (GetTextExtentPoint32(hdc, wszAvgChars,len , &size)) 
		{
            // UserAssert((((size.cx / 26) + 1) / 2) > 0);
			int p1=size.cx/26;
			baseUnit = MAKELONG( ((size.cx / 26) + 1) / 2, size.cy);    // round up
        }
	}
	else
		baseUnit = ::GetDialogBaseUnits();
	return baseUnit;
}

SIZE CQuickFont::GetPixelsFromDlgUnits(SIZE s)
{
	return GetPixelsFromDlgUnits( s, GetDialogBaseUnits() );
}

// Static, takes the base.
SIZE CQuickFont::GetPixelsFromDlgUnits(SIZE s, DWORD nBase)
{
	SIZE r;
	// r.cx= (s.cx * LOWORD(nBase)) / 4;
	// r.cy= (s.cy * HIWORD(nBase)) / 8;
    // USER does below, MSDN does above.
    r.cx = MulDiv( s.cx, LOWORD(nBase), 4);
    r.cy = MulDiv( s.cy, HIWORD(nBase), 8);
	return r;
}

SIZE CQuickFont::GetDlgUnitsFromPixels(SIZE s)
{
    return GetDlgUnitsFromPixels( s, GetDialogBaseUnits() );
}

SIZE CQuickFont::GetDlgUnitsFromPixels(SIZE s, DWORD nBase)
{
    SIZE r;
	// r.cx= s.cx * 4 / LOWORD(nBase) ;
	// r.cy= s.cy * 8 / HIWORD(nBase) ;
    // USER does below, MSDN does above.
    r.cx = MulDiv( s.cx, 4, LOWORD(nBase) );
    r.cy = MulDiv( s.cy, 8, HIWORD(nBase) );
	return r;
}


void CQuickFont::GetLogFont( int cbSize, LOGFONT * pLF )
{
    GetObject( m_font, cbSize, pLF );
}

#ifdef OLD_FONT_CODE
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
CFonts::CFonts()
: m_uiNum(0),
  m_pFonts(NULL)
{
}

CFonts::~CFonts()
{
	Init(0,0);		// deletes and cleans up the fonts.
}

void	CFonts::Init(UINT uiNumFonts, UINT uiType)
{
	//
	// Clean up old fonts.
	//
	if(m_pFonts)
	{
		UINT uiIndex;
		for(uiIndex=0;uiIndex<m_uiNum;uiIndex++)
			if(m_pFonts[uiIndex])
				DeleteObject(m_pFonts[uiIndex]);
		delete [] m_pFonts;
	}

	//
	// Create new fonts.
	//
	if(uiNumFonts)
		m_pFonts=new HFONT[uiNumFonts];
	m_uiNum=uiNumFonts;

	//
	// Zero init them.
	//
	UINT uiIndex;
	for(uiIndex=0;uiIndex<m_uiNum;uiIndex++)
		m_pFonts[uiIndex]=NULL;

	m_uiType=uiType;

}

//
//
//
void	CFonts::CreateFont(UINT uiIndex, LONG lfWeight, BYTE lfItalic, BYTE lfStrike )
{

	switch( m_uiType)
	{
		case ODT_MENU:
		{
			NONCLIENTMETRICS ncm;
			if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0))
			{
				LOGFONT	lf;
				CopyMemory(&lf, &(ncm.lfMenuFont), sizeof(ncm.lfMenuFont));
				lf.lfWeight=lfWeight;
				lf.lfItalic=lfItalic;
				lf.lfStrikeOut=lfStrike;
				SetFont( uiIndex, CreateFontIndirect(&lf) );
				return;
			}
		}

		//
		// Not perhaps the above fails - do default.
		//
		default:
		{
			LOGFONT	lf;

			if (SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, 0))
			{
				lf.lfWeight=lfWeight;
				lf.lfItalic=lfItalic;
				lf.lfStrikeOut=lfStrike;
				SetFont( uiIndex, CreateFontIndirect(&lf) );
			}
		}
	}
}

HFONT	CFonts::GetFont(UINT iIndex)
{
	if(iIndex>m_uiNum || !m_pFonts)
		return NULL;
	return m_pFonts[iIndex];
}

void	CFonts::SetFont(UINT uiIndex, HFONT hf)
{
	if(uiIndex>m_uiNum || !m_pFonts)
		return;

	if(m_pFonts[uiIndex])
		DeleteObject(m_pFonts[uiIndex]);

	m_pFonts[uiIndex]=hf;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlgen\fonts.h ===
//
//
//

#ifndef _FONTS_H
#define _FONTS_H

class CQuickFont
{
public:
	CQuickFont(): m_font(NULL), m_dc(NULL) { Init(NULL,0); }
	CQuickFont( LPTSTR name, DWORD dwSize);
	virtual ~CQuickFont();

	enum QFS_STYLE
	{
		FS_ITALIC=1,
	};

	//
	//
	//
	HFONT	GetFont() { return m_font; }
	void    Init( HFONT hf );
	void	Init(LPCTSTR name, DWORD dwSize );
	void	Init(LPCTSTR name, DWORD dwSize, DWORD dwStyle, DWORD dwWeight, LOGFONT * pBaseLF=NULL);

	//
	// Now we have the font, we can get information about how text is rendered using it.
	//

	//
	// MULTILINE - USER
	//
	SIZE	HowHigh( LPCTSTR name, DWORD dwWidth);

	//
	// SINGLE LINE - GDI
	//
	SIZE	HowLong( LPCTSTR text );

	//
	// Returns a dialog mapping from Pixels to DLG units.
	//
	DWORD	        GetDialogBaseUnits();       // calls this static with GetDC and GetFont
	static DWORD	GetDialogBaseUnits(HDC hdc, HFONT hf);

	//
	// Information about the font itself - name, size etc.
	//
	DWORD	GetSize() { return m_dwSize; }

	SIZE	GetDlgUnitsFromPixels( SIZE s );
	SIZE	GetPixelsFromDlgUnits( SIZE s );
	static SIZE	GetDlgUnitsFromPixels( SIZE s, DWORD nBase );   // nBase is GetDialogBaseUnits.
	static SIZE	GetPixelsFromDlgUnits( SIZE s, DWORD nBase );

    void    GetLogFont(int cbSize, LOGFONT * pLF);

private:
	DWORD	m_baseUnit;
	DWORD	m_dwSize;
	HDC		GetDC();
	HFONT	m_font;
	HDC		m_dc;
	// LOGFONT	m_lf;   // this is large and costly.
	CQuickFont( CQuickFont & font ) : m_font(NULL), m_dc(NULL) {};
};

#if 0

class CFonts
{
public:
	CFonts();
	~CFonts();
	void	Init(UINT uiNumFonts, UINT uiType);
	void	CreateFont(UINT uiIndex, LONG lfWeight, BYTE lfItalic=FALSE, BYTE bStrike=FALSE);
	HFONT	GetFont(UINT iIndex);

private:
	UINT	m_uiNum;
	HFONT	* m_pFonts;
	void	SetFont(UINT uiIndex, HFONT hf);
	UINT	m_uiType;	// owner draw types. ODT_MENU WM_MEASUREITEM
};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlgen\rcmlgen.cpp ===
// RC2XML.cpp : Defines the entry point for the application.
//

//
// To test the COMMAND LINE stuff
// rcmlgen.exe -d 102 -p "c:\dump now" /e
// "c:\dump now\rcmlgen-102.xml"
// rcmlgen.exe -d IMAGES 


#include "stdafx.h"
#include "resfile.h"
#include "rcml.h"
#include "resource.h"
#include "cmdline.h"
#include "shlwapi.h"
#include <shlobj.h>
#include "debug.h"

#ifdef _NEWUSER
// #define 2RCMLDialogBox DialogBox
#define DLGBOX DialogBox
#define DLGBOXP DialogBoxParam
#pragma message("Retail will only run on new version of User32.dll")
#else
#define DLGBOX RCMLDialogBox
#define DLGBOXP RCMLDialogBoxParam
#endif

HINSTANCE g_hInstance;
TCHAR g_InitialWorkingDirectory[MAX_PATH];

extern "C" {

	typedef struct _tagDUMPDLG
	{
		LPTSTR	pszPrefix;      // the 'abbreviated' app name, e.g. rcmlgen (no .exe)
        LPTSTR  pszModule;      // fully qualified pointer to the executable we're dumping.
        LPTSTR  pszOutputdir;   // where the files are to be saved (command line).
        LPTSTR  pszDialog;      // the dialog we're interested in dumping (command line)
        LPTSTR  szHwnd;         // the dialog we're interested in dumping (command line)
		HWND	hWndParent;
        WORD    wEncoding;      // UTF8, UNICODE, ANSI
        // struct - can't be struct as using &
        BOOL	bEndhanced;
        BOOL    bAutoExit;
        BOOL    bWin32;
        BOOL    bRelativeLayout;
        BOOL    bPrompt;        // get user input,e.g. no command line.
        BOOL    bCicero;        // do they want cicer annotations?
	} DUMPDLG, * PDUMPDLG;

void GetCheckBoxes( HWND hDlg, DUMPDLG * pDlg)
{
	pDlg->bEndhanced=SendDlgItemMessage( hDlg, IDC_ENHANCED, BM_GETCHECK, 0,0 );
	pDlg->bWin32=SendDlgItemMessage( hDlg, IDC_WIN32, BM_GETCHECK, 0,0 );
	pDlg->bRelativeLayout=SendDlgItemMessage( hDlg, IDC_RELATIVE, BM_GETCHECK, 0,0 );
	pDlg->bCicero=SendDlgItemMessage( hDlg, IDC_VOICEENABLE, BM_GETCHECK, 0,0 );
}

void SetCheckBoxes( HWND hDlg, DUMPDLG * pDlg)
{
    SendDlgItemMessage( hDlg, IDC_ENHANCED, BM_SETCHECK, pDlg->bEndhanced?BST_CHECKED:0,0);
    SendDlgItemMessage( hDlg, IDC_WIN32, BM_SETCHECK, pDlg->bWin32?BST_CHECKED:0,0);
    SendDlgItemMessage( hDlg, IDC_RELATIVE, BM_SETCHECK, pDlg->bRelativeLayout?BST_CHECKED:0,0);
    SendDlgItemMessage( hDlg, IDC_VOICEENABLE, BM_SETCHECK, pDlg->bCicero?BST_CHECKED:0,0);
}

//
// Creates a directory, one part at a time
//
void MyCreateDirectory( LPCWSTR pszDir )
{
    LPTSTR pszPath=new TCHAR[lstrlen(pszDir)+1];
    lstrcpy(pszPath,pszDir);
    LPTSTR pszEnd=pszPath;
    while(*pszEnd)
    {
        if(*pszEnd==TEXT('\\'))
        {
            *pszEnd=0;
            CreateDirectory( pszPath, NULL );
            *pszEnd=TEXT('\\');
        }
        pszEnd++;
    }
    CreateDirectory( pszDir, NULL );
    delete pszPath;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// When the user uses the 'cursor' to pick a dialog to dump out.
//
void RuntimeDumpRCML( HWND hwnd, LPCTSTR lpName, DUMPDLG * pDlg  )
{
    //
    // Get a CResFile to prepare to decode the dialog.
    //
	CResFile res( pDlg->bEndhanced, pDlg->bRelativeLayout, pDlg->bWin32, pDlg->bCicero );
    res.GetFile().SetEncoding( CFileEncoder::RF_UNICODE );
    switch( pDlg->wEncoding )
    {
    case IDS_ANSI:
        res.GetFile().SetEncoding( CFileEncoder::RF_ANSI );
        break;
    case IDS_UNICODE:
        res.GetFile().SetEncoding( CFileEncoder::RF_UNICODE );
        break;
    case IDS_UTF8:
        res.GetFile().SetEncoding( CFileEncoder::RF_UTF8 );
        break;
    }

    if( res.LoadWindow(hwnd) )
    {
        BOOL bDeleteFile=FALSE;
		LPTSTR pszFile=(LPTSTR)lpName;        // ??

        // pszFile is the filename we should be exporting to.
        
        //
        // Add on the output directory if in pDlg - and always the modulename.
        //
        LPTSTR pszOutputDir=pDlg->pszOutputdir?pDlg->pszOutputdir:TEXT(".");
        // -x -v -w 1050022 -o "c:\cicerorcml\CFG\SHELL32.dll" -f "Run"
        MyCreateDirectory( pszOutputDir );
        LPTSTR pszFully=new TCHAR[lstrlen(pszFile)+lstrlen(pszOutputDir)+lstrlen(pDlg->pszPrefix)+16];
        wsprintf(pszFully,TEXT("%s\\%s.RCML"),
            pszOutputDir, 
            pszFile );

        if(bDeleteFile)
            delete []pszFile;

        bDeleteFile=TRUE;
        pszFile=pszFully;

        //
        // Fully qualified - or not.
        //
	    res.DumpDialog(pszFile);

        SetWindowText( GetDlgItem( pDlg->hWndParent, IDC_FILE ), pszFile );

        if(bDeleteFile)
            delete []pszFile;
    }
}
	    
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This dumps a SPECIFIC dialog.
// this is the callback from User.
// lpType is the type of the resource RT_DIALOG in our case
// lpName is the identifier (either an WORD or an LPTSTR)
// lParam is the callback context.
// 
BOOL CALLBACK dialogDump(HMODULE hModule, LPCTSTR lpType,        LPTSTR lpName, LONG lParam)
{
	PDUMPDLG pDlg=(PDUMPDLG)lParam;

    //
    // User can have specified an individual
    // dialog to dump (from the command line).
    // Check is this the dialog we wanted??
    //
    if( pDlg->pszDialog )
    {
        if(HIWORD(lpName))
        {
            if(lstrcmpi(pDlg->pszDialog, lpName)!=0)
                return TRUE;
        }
        else
        {
            TCHAR number[16];
            wsprintf(number,TEXT("%d"),LOWORD(lpName));
            if(lstrcmpi(pDlg->pszDialog, number)!=0)
                return TRUE;
        }
    }

    //
    // Get a CResFile to prepare to decode the dialog.
    //
	CResFile res( pDlg->bEndhanced, pDlg->bRelativeLayout, pDlg->bWin32, pDlg->bCicero );
    res.GetFile().SetEncoding( CFileEncoder::RF_UNICODE );
    switch( pDlg->wEncoding )
    {
    case IDS_ANSI:
        res.GetFile().SetEncoding( CFileEncoder::RF_ANSI );
        break;
    case IDS_UNICODE:
        res.GetFile().SetEncoding( CFileEncoder::RF_UNICODE );
        break;
    case IDS_UTF8:
        res.GetFile().SetEncoding( CFileEncoder::RF_UTF8 );
        break;
    }

	if( res.LoadDialog( lpName, hModule ) )
	{
        BOOL bDeleteFile=FALSE;
		LPTSTR pszFile=lpName;
		TCHAR szString[128];

        //
        // Form the filename here.
        //
		if(HIWORD(lpName)==0)
		{
			LPTSTR pszPrefix=pDlg->pszPrefix;
			wsprintf(szString,TEXT("%d.RCML"), LOWORD(lpName)); // no prefix, they are in a folder.
			pszFile=szString;
		}
        else
        {
            int ilen=lstrlen(pszFile);
            LPTSTR pszNewFile=new TCHAR[ilen+8];
            wsprintf(pszNewFile,TEXT("%s.RCML"), pszFile );
            bDeleteFile=TRUE;
            pszFile=pszNewFile;
        }
        // pszFile is the filename we should be exporting to.
        
        //
        // Add on the output directory if in pDlg - and always the modulename.
        //
        LPTSTR pszOutputDir=pDlg->pszOutputdir?pDlg->pszOutputdir:TEXT(".");
        LPTSTR pszFully=new TCHAR[lstrlen(pszFile)+lstrlen(pszOutputDir)+lstrlen(pDlg->pszPrefix)+16];
        wsprintf(pszFully,TEXT("%s\\%s.RCML\\%s"),
            pszOutputDir, 
            pDlg->pszPrefix,
            pszFile );

        if(bDeleteFile)
            delete []pszFile;

        bDeleteFile=TRUE;
        pszFile=pszFully;

        //
        // Fully qualified - or not.
        //
	    res.DumpDialog(pszFile);
        if(bDeleteFile)
            delete []pszFile;
	}

	return TRUE;
}

}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This is the default dialog proc used when displaying RCML dialogs
//
BOOL CALLBACK NothingDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    if(uMessage==WM_COMMAND)
    {
        int iControl=LOWORD(wParam);
        if( (HIWORD(wParam)==0) && (iControl==IDOK || iControl==IDCANCEL ) )
        {
            TRACE(TEXT("Ending the dialog 0x%08x with %d\n"), hDlg, iControl );
            EndDialog( hDlg, iControl);
            LONG lRes = GetWindowLong( hDlg, DWL_MSGRESULT );   // why the dialog is going away.
            SetWindowLong(hDlg, DWL_MSGRESULT, 0xffee);
        }
    }
    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
// CreateLink - uses the shell's IShellLink and IPersistFile interfaces 
//   to create and store a shortcut to the specified object. 
// Returns the result of calling the member functions of the interfaces. 
// lpszPathObj - address of a buffer containing the path of the object. 
// lpszPathLink - address of a buffer containing the path where the 
//   shell link is to be stored. 
// lpszDesc - address of a buffer containing the description of the 
//   shell link. 
 
HRESULT CreateLink(LPCWSTR lpszPathObj, LPWSTR lpszPathLink, LPWSTR lpszDesc) 
{ 
    HRESULT hres; 
    IShellLink* psl=NULL; 

    hres=CoInitialize( NULL );

    // Get a pointer to the IShellLink interface. 
    hres = CoCreateInstance(CLSID_ShellLink, NULL, 
        CLSCTX_INPROC_SERVER, IID_IShellLink, (LPVOID *) &psl); 
    if (SUCCEEDED(hres)) { 
        IPersistFile* ppf; 
 
        // Set the path to the shortcut target and add the 
        // description. 
        psl->SetPath(lpszPathObj); 
        psl->SetDescription(lpszDesc); 
 
       // Query IShellLink for the IPersistFile interface for saving the 
       // shortcut in persistent storage. 
        hres = psl->QueryInterface(IID_IPersistFile, 
            (LPVOID*)&ppf); 
 
        if (SUCCEEDED(hres)) {
            // Save the link by calling IPersistFile::Save. 
            hres = ppf->Save(lpszPathLink, TRUE); 
            ppf->Release(); 
        } 
        psl->Release(); 
    } 
    CoUninitialize();
    return hres; 
} 

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
BOOL GetShortcutInformation( LPWSTR pszPathLink, LPWSTR * ppszDestination )
{
    HRESULT hres; 
    IShellLink* psl=NULL; 

    hres=CoInitialize( NULL );

    // Get a pointer to the IShellLink interface. 
    hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (LPVOID *) &psl); 
    if (SUCCEEDED(hres))
    { 
        // Query IShellLink for the IPersistFile interface for saving the 
        // shortcut in persistent storage. 
        IPersistFile* ppf; 
        hres = psl->QueryInterface(IID_IPersistFile, (LPVOID*)&ppf); 
 
        if (SUCCEEDED(hres)) 
        {
            // Save the link by calling IPersistFile::Save. 
            hres = ppf->Load(pszPathLink, 0); 
            if( SUCCEEDED(hres) )
            {
#if 0
                WIN32_FIND_DATA fd;

                // Set the path to the shortcut target and add the 
                // description.
                hres = psl->GetPath(NULL, 0, &fd, 0 );
                if( SUCCEEDED(hres) )
                {
                    *ppszDestination = new TCHAR[lstrlen(fd.cFileName)+1];
                    lstrcpy(*ppszDestination, fd.cFileName );
                }
#else
                *ppszDestination = new TCHAR[MAX_PATH];
                hres = psl->GetPath(*ppszDestination , MAX_PATH, NULL, 0 );
#endif
            }
            ppf->Release(); 
        }
        psl->Release(); 
    } 
    CoUninitialize();
    return hres; 
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
static LPTSTR g_szShortcutFileName=TEXT("Application.lnk");

void CreateShortcutAndFolder( PDUMPDLG pDlg )
{
    LPTSTR pszFully=new TCHAR[lstrlen(pDlg->pszOutputdir)+lstrlen(pDlg->pszPrefix)+26+lstrlen(g_szShortcutFileName)];

    wsprintf(pszFully,TEXT("%s\\%s.RCML"),
        pDlg->pszOutputdir, 
        pDlg->pszPrefix
        );

    MyCreateDirectory( pszFully);
    SetWindowText( GetDlgItem( pDlg->hWndParent, IDC_FILE ), pszFully );

    wsprintf(pszFully,TEXT("%s\\%s.RCML\\%s"),
        pDlg->pszOutputdir, 
        pDlg->pszPrefix,
        g_szShortcutFileName
        );

    //
    // CreateLink is Unicode Only.
    //
#ifndef UNICODE
    WCHAR wszModule[MAX_PATH]; 
    WCHAR wszPath[MAX_PATH]; 
    MultiByteToWideChar(CP_ACP, 0, pDlg->pszModule, -1, wszModule, MAX_PATH); 
    MultiByteToWideChar(CP_ACP, 0, pszFully, -1, wszPath, MAX_PATH); 
    CreateLink( wszModule, wszPath, L"Shortcut to the executable to RCML enabled" );
#else
    CreateLink( pDlg->pszModule, pszFully, TEXT("Shortcut to the executable to RCML enabled") );
#endif
    delete pszFully;
}


BOOL CALLBACK EnumResLangProc(
  HMODULE hModule,    // module handle
  LPCTSTR lpszType,  // resource type
  LPCTSTR lpszName,  // resource name
  WORD wIDLanguage,  // language identifier
  LONG lParam    // application-defined parameter
)
{
    *((LPWORD)lParam)=wIDLanguage;
    return FALSE;   // we only enumerate the first thing.
}

WORD GetFirstLang( HMODULE hm, LPCTSTR id )
{
    WORD Lang;
    EnumResourceLanguages( hm, RT_DIALOG, id, EnumResLangProc, (LPARAM)&Lang );
    return Lang;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// The folder contains all the new RCML files.
// it also contains a 'link' perhaps to the executable to fix up.
// 
//
void ReplaceResources( LPTSTR pszFolder )
{
    //
    // Find the Application.lnk file, find the path from that.
    //
    TRACE( TEXT("Folder drop : %s\n"), pszFolder );
    LPWSTR pszFile=NULL;
#ifndef UNICODE
    WCHAR wszLink[MAX_PATH]; 
    CHAR szLink[MAX_PATH]
    wsprintf(szLink, "%s\\%s", pszFolder, g_szShortcutFileName);
    MultiByteToWideChar(CP_ACP, 0, szLink, -1, wszLink, MAX_PATH); 
    GetShortcutInformation( wszLink, &pszFile);
#else
    TCHAR szLink[MAX_PATH];
    wsprintf(szLink, TEXT("%s\\%s"), pszFolder, g_szShortcutFileName);
    GetShortcutInformation( szLink, &pszFile);
#endif

    // Use hm for the language.
    TRACE( TEXT("Application.lnk points to : %s\n"), pszFile );
    HANDLE h = BeginUpdateResource( pszFile, FALSE );
    HMODULE hm=LoadLibraryEx( pszFile, NULL, DONT_RESOLVE_DLL_REFERENCES );
    int bFirstOneSkipped=10;
    if( h)
    {
        // Walk all of the *.rcml files in this directory.
        WIN32_FIND_DATA FindFileData;
        TCHAR szFileToLookFor[MAX_PATH];
        wsprintf(szFileToLookFor, TEXT("%s\\%s"), pszFolder, TEXT("*.rcml") );
        HANDLE hFFF=FindFirstFile( szFileToLookFor, &FindFileData );
        if( hFFF != INVALID_HANDLE_VALUE )
        {
            do
            {
                // Is this a numeric or string substitution - based on filename.
                LPTSTR psz=FindFileData.cFileName;
                TRACE( TEXT("Found the file '%s'\n"),psz);
                int iResourceID=0;
                int c;
	            if(psz != NULL)
	            {
		            while(c = (int)(TCHAR)*psz++)
		            {
			            c -= TEXT('0');
			            if( c < 0 || c > 9)
				            break;
			            iResourceID = iResourceID*10 + c;
		            }
                }

                // Read in the whole file.
                DWORD cbSize = FindFileData.nFileSizeLow;
                LPBYTE pRCML = new BYTE[cbSize];
                TCHAR szFullyQualified[MAX_PATH];
                wsprintf(szFullyQualified, TEXT("%s\\%s"), pszFolder, FindFileData.cFileName);
                HANDLE hFile=::CreateFile(
	                szFullyQualified,
	                GENERIC_READ,
	                FILE_SHARE_READ,
	                NULL,
	                OPEN_EXISTING,
	                FILE_ATTRIBUTE_NORMAL,
	                NULL);

                DWORD cbRead=0;
                if( hFile != INVALID_HANDLE_VALUE )
                {
                    SetFilePointer( hFile, 0, NULL, FILE_BEGIN );
                    ReadFile(hFile, pRCML, cbSize, &cbRead, NULL );
                    CloseHandle(hFile);
                }

                // Is this a string resource or an ID.
                LPCTSTR id;
                if(iResourceID)
                {
                    id=MAKEINTRESOURCE(iResourceID);
                    TRACE(TEXT("Integer resource ID : %d\n"), id);
                }
                else
                {
                    id= FindFileData.cFileName ;
                    PathRemoveExtension( (LPTSTR)id );
                    TRACE(TEXT("Text    resource ID : %s\n"), id);
                }

                // Find the language, and substitue the RCML dialog for theirs.
                WORD langID = GetFirstLang( hm, id );

                if( langID == 0 )
                {
                    TRACE( TEXT("The resouce doesn't exist\n"));
                }

                if( HIWORD(id) )
                {
                    if( UpdateResource( h, RT_DIALOG,    id, langID, NULL, 0 ) ==0 )// delete
                    {
                        DWORD dwErr=GetLastError();
                        TRACE(TEXT("Couldn't delete that resource : 0x%08x\n"), dwErr );
                    }
                }

                UpdateResource( h, TEXT("RCML"), id, langID, pRCML, cbSize ); // Replace

                // Cleanup.
                delete [] pRCML;

            } while ( FindNextFile( hFFF, &FindFileData ));
            FindClose( hFFF );
        }
        FreeLibrary(hm);    // MUST free first, otherwise EndUpdate thrown away.
        BOOL bYes=EndUpdateResource( h, FALSE );
        if( !bYes )
        {
            DWORD dw=GetLastError();
            dw;
        }
    }
    delete pszFile;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This is called to dump out all of the information from a given resource (dll or exe)
//
void ProcessFile( LPTSTR pszFile, PDUMPDLG pDlg )
{
    //
    // See if the file is a folder.
    //
    DWORD dwType = GetFileAttributes( pszFile );
    if( (dwType!=-1) && (dwType & FILE_ATTRIBUTE_DIRECTORY ) )
    {
        ReplaceResources( pszFile );
    }
    else
    {
	    HMODULE hInst=LoadLibraryEx( pszFile, NULL, LOAD_LIBRARY_AS_DATAFILE | DONT_RESOLVE_DLL_REFERENCES);    // LoadResources??
	    if(hInst)
	    {
            //
            // we need fully qualified path now.
            //
            LPTSTR szFullyQualified=new TCHAR[MAX_PATH];
            DWORD dwSize = GetModuleFileName( hInst, szFullyQualified, MAX_PATH );
			if(dwSize==0)
			{
				lstrcpy(szFullyQualified, pszFile );
				dwSize=lstrlen(szFullyQualified);
			}

            if(dwSize)
            {
                delete pDlg->pszModule;
                pDlg->pszModule = new TCHAR[dwSize+1];
                lstrcpy(pDlg->pszModule , szFullyQualified );

                //
                // No specified output directory, place it in the same place as the exe.
                //
                if(pDlg->pszOutputdir==NULL)
                {
                    pDlg->pszOutputdir = new TCHAR[MAX_PATH];
                    lstrcpy(pDlg->pszOutputdir, pDlg->pszModule );
                    if( PathGetDriveNumber( pDlg->pszOutputdir ) == -1 )
                    {
                        lstrcpy( pDlg->pszOutputdir , g_InitialWorkingDirectory );
                        PathAppend( pDlg->pszOutputdir, pDlg->pszModule );
                    }
		            PathRemoveFileSpec( pDlg->pszOutputdir );
                }
            }

            //
            // Try to work out what the execuatble name is (e.g. RCMLGen) no .EXE
            //
		    LPTSTR pszFileName = PathFindFileName( szFullyQualified );
		    LPTSTR pszPrefix=new TCHAR[lstrlen(pszFileName)+1];
		    lstrcpy( pszPrefix, pszFileName );
		    PathRemoveExtension( pszPrefix );

		    pDlg->pszPrefix=pszPrefix;
            CreateShortcutAndFolder( pDlg );
		    EnumResourceNames( hInst, RT_DIALOG, dialogDump, (LPARAM)pDlg );
		    FreeLibrary(hInst);
            delete pszPrefix;
	    }
	    else
	    {
			DWORD dwLastError = GetLastError();
		    // could be a .XML file, see if we can render it
		    // Let's set the working directory there as it might reference relative paths
		    LPTSTR pszFileName  = PathFindFileName( pszFile );
		    // if there is something prefixing the file name, eat a '\', NULL terminate, and use
		    // that for the current directory.
		    // MCostea, #364429
		    if(pszFileName > pszFile)
		    {
			    pszFileName -= 1;
			    TCHAR save = *pszFileName;
			    *pszFileName = 0;
			    SetCurrentDirectory(pszFile);
			    *pszFileName = save;
			    pszFileName++;
 			    DLGBOX( g_hInstance, pszFileName, pDlg->hWndParent, NothingDlgProc);
		    }
	    }
    }
}

BOOL CALLBACK PropSheetBaseDialog(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
/*
	switch(uMessage)
	{
	default:
		return FALSE;
	}
*/
	return FALSE;
}

void GetFile(int i, HDROP hdrop, LPTSTR * ppszString, UINT * pcbSize)
{
	UINT uiSize=DragQueryFile( hdrop, i, NULL, 0 );
	if(uiSize > *pcbSize)
	{
		delete * ppszString;
		*pcbSize=uiSize+20;
		*ppszString=new TCHAR[*pcbSize+1];
	}
	DragQueryFile( hdrop, i, *ppszString, *pcbSize);
}


void FillListbox( HWND hctl, int * pInts, PDUMPDLG pdd )
{
    if( hctl && pInts )
    {
        LPTSTR pszBuffer;
        DWORD dwSize=4;
        pszBuffer=new TCHAR[dwSize];
        DWORD dwGot;
        while(*pInts)
        {
            BOOL bLoaded=FALSE;
            while( bLoaded==FALSE)
            {
                dwGot = LoadString(g_hInstance, *pInts, pszBuffer, dwSize );
                if( (dwGot == dwSize-1) )
                {
                    delete pszBuffer;
                    dwSize*=2;
                    pszBuffer=new TCHAR[dwSize];
                }
                else
                    bLoaded=TRUE;
            }
            int iIndex= SendMessage(hctl, CB_ADDSTRING, 0, (LPARAM)pszBuffer );
            if( iIndex != CB_ERR )
            {
                SendMessage(hctl, CB_SETITEMDATA, iIndex, *pInts );
                if(pdd)
                {
                    if(*pInts == pdd->wEncoding )
                        SendMessage(hctl, CB_SETCURSEL, iIndex, 0 );
                }
            }
            pInts++;
        }
        delete pszBuffer;
    }
}


HCURSOR hcursor;

int encodingStrings[] = { IDS_ANSI, IDS_UNICODE, IDS_UTF8, 0 };

BOOL CALLBACK FilePickerDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
	switch(uMessage)
	{

	case WM_INITDIALOG:
        {
            PDUMPDLG pDD=(PDUMPDLG)lParam;
            DUMPDLG dd={NULL};
            if(pDD==NULL)
            {
                pDD=&dd;
                dd.bEndhanced=TRUE;
                dd.bWin32=TRUE;
                dd.bRelativeLayout=TRUE;
                dd.wEncoding=IDS_UNICODE;
                // dd.pszModule=TEXT("RCMLGen.exe");
                dd.bPrompt=TRUE;
            }

            //
            // we got passed a dump dialog.
            //
            if(pDD->pszModule)
                SetWindowText( GetDlgItem( hDlg, IDC_FILE), pDD->pszModule );
            SetCheckBoxes(hDlg, pDD);
            FillListbox( GetDlgItem( hDlg, IDC_ENCODING), encodingStrings, pDD);
            pDD->hWndParent=hDlg;

            int cbSize=10;
            LPTSTR pszSomeString=new TCHAR[cbSize];
            int iRet=RCMLLoadString( hDlg, 0, pszSomeString, cbSize );
            TRACE(TEXT("The load String returned %d\n"),iRet);
            delete pszSomeString;

            if( pDD->bPrompt==FALSE )
            {
			    ProcessFile( pDD->pszModule, pDD );
                if(pDD->bAutoExit)
                    EndDialog(hDlg,1);
            }

        }
		break;

	case WM_COMMAND:
		{
			WORD wCmdID=LOWORD(wParam);
			switch( wCmdID )
			{
				case IDOK:
				{
        	        HWND hEdit=GetDlgItem( hDlg, IDC_FILE );
					if(hEdit)
					{
						UINT cbSize=SendMessage(hEdit, WM_GETTEXTLENGTH, 0,0);
						if(cbSize)
						{
                            HCURSOR old=SetCursor(LoadCursor( NULL, MAKEINTRESOURCE(IDC_APPSTARTING) ));
                            EnableWindow( GetDlgItem( hDlg, IDOK), FALSE );
                            EnableWindow( GetDlgItem( hDlg, IDCANCEL), FALSE );

							cbSize++;
							LPTSTR pszString=new TCHAR[cbSize+10];
							SendMessage(hEdit, WM_GETTEXT, cbSize, (LPARAM)pszString);
                            DUMPDLG dlg={NULL};
							dlg.pszPrefix=NULL;
                            dlg.pszModule=pszString;
                            GetCheckBoxes( hDlg, &dlg);
                            int iSelindex = SendDlgItemMessage( hDlg, IDC_ENCODING, CB_GETCURSEL, 0, 0);
                            dlg.wEncoding = (WORD)SendDlgItemMessage( hDlg, IDC_ENCODING, CB_GETITEMDATA, iSelindex, 0 );
							dlg.hWndParent=hDlg;
							ProcessFile( pszString, &dlg );
							delete dlg.pszModule;

                            EnableWindow( GetDlgItem( hDlg, IDOK), TRUE );
                            EnableWindow( GetDlgItem( hDlg, IDCANCEL), TRUE );
                            SetCursor(old);
						}
					}
				}
				break;
				case IDCANCEL:
					EndDialog(hDlg,wCmdID);
				break;
			}
		}
		break;

	case WM_DROPFILES:
		{
			HDROP hdrop=(HDROP)wParam;
			int iCount=DragQueryFile( hdrop, (UINT)-1, NULL, 0 );
			LPTSTR	pszString=NULL;
			UINT	cbString=0;
			if( iCount == 1 )
			{
				GetFile( 0, hdrop, &pszString, &cbString);
				DUMPDLG dlg={0};
				dlg.pszPrefix=NULL;
                GetCheckBoxes( hDlg, &dlg );
				SendDlgItemMessage( hDlg, IDC_FILE, WM_SETTEXT, 0, (LPARAM)pszString);
				ProcessFile( pszString, &dlg );
			}
			else
			{
				if( MessageBox(NULL,TEXT("Display in Multiple dialogs?"),TEXT("PropertySheet or Dialogs"), MB_YESNO) == IDYES )
				{
					for ( int i = 0; i < iCount; i++ )
					{
						GetFile(i, hdrop, &pszString, &cbString);
						DUMPDLG dlg;
						dlg.pszPrefix=NULL;
                        GetCheckBoxes( hDlg, &dlg );
						SendDlgItemMessage( hDlg, IDC_FILE, WM_SETTEXT, 0, (LPARAM)pszString);
						ProcessFile( pszString, &dlg );
					}
				}
				else
				{
					//
					// Property sheet testing code. DestroyPropertySheet
					//
					PROPSHEETHEADER psh={0};
					psh.dwSize=sizeof(psh);
					psh.dwFlags = PSH_DEFAULT | PSH_PROPSHEETPAGE; 
					if( MessageBox(NULL,TEXT("Would you like a Wizard?"),TEXT("Wizard"), MB_YESNO) == IDYES )
						psh.dwFlags |= PSH_WIZARD ;
					else
						psh.dwFlags;
					psh.hInstance=NULL;
					psh.pszCaption=TEXT("Test pages");
					psh.nPages=iCount;
					psh.nStartPage=0;
					PROPSHEETPAGE * pages=new PROPSHEETPAGE[psh.nPages];
					psh.ppsp = pages;

					//
					// Now fill the pages.
					//
					for(WORD i=0;i<iCount;i++)
					{
						ZeroMemory( &pages[i], sizeof(PROPSHEETPAGE) );
						pages[i].dwSize=sizeof(PROPSHEETPAGE);
						pages[i].dwFlags=PSP_DEFAULT;
						pages[i].hInstance=NULL;
						cbString=0;
						GetFile( i, hdrop, (LPTSTR*)&(pages[i].pszTemplate), &cbString);
						pages[i].pszTitle=TEXT("Some title");
						pages[i].pfnDlgProc=PropSheetBaseDialog;
					}
					RCMLPropertySheet(&psh);

					for(i=0;i<iCount;i++)
					{
						delete (LPTSTR)(pages[i].pszTemplate);
					}
				}
			}
			delete pszString;
			DragFinish( hdrop );
		}
        break;

        case WM_LBUTTONDOWN:
            {
                POINT pt;
                pt.x = LOWORD(lParam);
                pt.y = HIWORD(lParam); 
                HWND h=ChildWindowFromPoint( hDlg, pt );
                int id=GetDlgCtrlID( h );
                if( id == IDC_SPY )
                {
                    SetCapture(hDlg);
                    hcursor = SetCursor(LoadCursor(g_hInstance, MAKEINTRESOURCE(IDC_SPY)));
                }
                else
                    hcursor=NULL;
            }
            break;
        
        case WM_LBUTTONUP:
            if( hcursor )
            {
                SetCursor(hcursor);
                ReleaseCapture();
                POINT pt;
                GetCursorPos(&pt);
                HWND hwndCaptured = WindowFromPoint(pt);

                HCURSOR old=SetCursor(LoadCursor( NULL, MAKEINTRESOURCE(IDC_APPSTARTING) ));
                EnableWindow( GetDlgItem( hDlg, IDOK), FALSE );
                EnableWindow( GetDlgItem( hDlg, IDCANCEL), FALSE );

				int cbSize=GetWindowTextLength( hwndCaptured );
				LPTSTR pszString=new TCHAR[cbSize+10];
                GetWindowText( hwndCaptured, pszString, cbSize+4 );

                DUMPDLG dlg={NULL};
				dlg.pszPrefix=NULL;
                dlg.pszModule=pszString;
                GetCheckBoxes( hDlg, &dlg);
                int iSelindex = SendDlgItemMessage( hDlg, IDC_ENCODING, CB_GETCURSEL, 0, 0);
                dlg.wEncoding = (WORD)SendDlgItemMessage( hDlg, IDC_ENCODING, CB_GETITEMDATA, iSelindex, 0 );
				dlg.hWndParent=hDlg;
                dlg.pszOutputdir = new TCHAR[MAX_PATH];
                GetModuleFileName(NULL, dlg.pszOutputdir, MAX_PATH);
		        PathRemoveFileSpec( dlg.pszOutputdir );
                RuntimeDumpRCML( hwndCaptured, pszString, &dlg );
				delete dlg.pszModule;
                delete dlg.pszOutputdir;
                EnableWindow( GetDlgItem( hDlg, IDOK), TRUE );
                EnableWindow( GetDlgItem( hDlg, IDCANCEL), TRUE );
                SetCursor(old);
            }
            break;
        
        case WM_MOUSEMOVE:
            if (GetCapture() == hDlg) 
            {
                POINT pt;
                GetCursorPos(&pt);
                HWND hwndCaptured = WindowFromPoint(pt);
                //
                // Is there a help ID of any kind that we can use??
                //
                LONG lID = GetWindowLong( hwndCaptured, GWL_ID );
                TRACE(TEXT("Window ID is %d\n"),lID);
            }
            return TRUE;

	}
	return FALSE;
}

void DoSimpleWin32PropSheet(BOOL bUseRCML, HINSTANCE hInstance)
{
	//
	// Property sheet testing code. DestroyPropertySheet
	//
	PROPSHEETHEADER psh={0};
	psh.dwSize=sizeof(psh);
	psh.dwFlags = PSH_DEFAULT | PSH_PROPSHEETPAGE;
	psh.hInstance=hInstance;
	psh.pszCaption=TEXT("Test pages");
	psh.nPages=3;	// 3 pages.
	psh.nStartPage=0; // psh.nPages;
	PROPSHEETPAGE * pages=new PROPSHEETPAGE[psh.nPages];
	psh.ppsp = pages;

	//
	// Now fill the pages.
	//
	for(WORD i=0;i<psh.nPages;i++)
	{
		ZeroMemory( &pages[i], sizeof(PROPSHEETPAGE) );
		pages[i].dwSize=sizeof(PROPSHEETPAGE);
		pages[i].dwFlags=PSP_DEFAULT;
		pages[i].hInstance=hInstance;
		pages[i].pszTemplate=TEXT("test.RCML"); // MAKEINTRESOURCE(IDD_DIALOG1);
		pages[i].pszTitle=TEXT("Some title");
		pages[i].pfnDlgProc=PropSheetBaseDialog;
	}

	if(bUseRCML)
		RCMLPropertySheet(&psh);
	else
		PropertySheet(&psh);

	delete pages;
}



BOOL CALLBACK HelpDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
	switch(uMessage)
	{
	case WM_COMMAND:
		{
			WORD wCmdID=LOWORD(wParam);
			switch( wCmdID )
			{
				case IDOK:
					EndDialog(hDlg,wCmdID);
				break;
			}
		}
		break;
	}
	return FALSE;
}

int APIENTRY wWinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPWSTR     lpCmdLine,
                     int       nCmdShow)
{
#ifdef _DEBUG2
	DoSimpleWin32PropSheet(TRUE, hInstance);
	// DoSimpleWin32PropSheet(FALSE, hInstance);
#else
#endif

    GetCurrentDirectory( MAX_PATH, g_InitialWorkingDirectory );
    GetModuleFileName( hInstance, g_InitialWorkingDirectory, MAX_PATH);
    PathRemoveFileSpec( g_InitialWorkingDirectory );


    //
    // Setup the HKEY for the RCMLGen UI
    //
    HKEY hRCMLGen;
    if( RegCreateKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RCML"), &hRCMLGen ) == ERROR_SUCCESS )
        RCMLSetKey(hRCMLGen);

    //
    // Crack the command line;
    // use /P if you want to know what those macros do!
    //
    g_hInstance=hInstance;
    LPTSTR pszNothing=NULL;
    LPTSTR encoding=NULL;
    DUMPDLG dd={NULL};
    dd.bPrompt=TRUE;
	BOOL	bHelpOnly=FALSE;

    dd.wEncoding=IDS_UNICODE;

    if(*lpCmdLine)
    {
        CMDLINE_BEGIN( lpCmdLine, &dd.pszModule, &pszNothing, TRUE )
            CMDLINE_TEXTARG( "-dialog", &dd.pszDialog )
            CMDLINE_TEXTARG( "-d", &dd.pszDialog )

            CMDLINE_TEXTARG( "-output", &dd.pszOutputdir )
            CMDLINE_TEXTARG( "-o", &dd.pszOutputdir )

            CMDLINE_TEXTARG( "-filename", &dd.pszModule )
            CMDLINE_TEXTARG( "-f", &dd.pszModule )

            CMDLINE_SWITCH( "-autoexit", &dd.bAutoExit )
            CMDLINE_SWITCH( "-x", &dd.bAutoExit )

            CMDLINE_SWITCH( "-enhanced", &dd.bEndhanced )
            CMDLINE_SWITCH( "-e", &dd.bEndhanced )

            CMDLINE_SWITCH( "-Win32", &dd.bWin32 )

            CMDLINE_SWITCH( "-relative", &dd.bRelativeLayout)
            CMDLINE_SWITCH( "-r", &dd.bRelativeLayout)

            // -x -w 13 -o c:\cicerorcml -f foo -v

            CMDLINE_SWITCH( "-voice", &dd.bCicero)
            CMDLINE_SWITCH( "-v", &dd.bCicero)

            CMDLINE_SWITCH( "-help", &bHelpOnly )
            CMDLINE_SWITCH( "-?", &bHelpOnly )

            CMDLINE_TEXTARG( "-window", &dd.szHwnd )
            CMDLINE_TEXTARG( "-w", &dd.szHwnd )

            CMDLINE_TEXTARG( "-encoding", &encoding )

        CMDLINE_END()
    }
    else
    {
        dd.bEndhanced = TRUE;
        dd.bWin32 = TRUE;
        dd.bRelativeLayout = TRUE;
    }

    if(encoding)
    {
        if(lstrcmpi(encoding,TEXT("UNICODE"))==0)
            dd.wEncoding=IDS_UNICODE;
        else if(lstrcmpi(encoding,TEXT("UTF8"))==0)
            dd.wEncoding=IDS_UTF8;
        else if(lstrcmpi(encoding,TEXT("ANSI"))==0)
            dd.wEncoding=IDS_ANSI;
    }
	if(bHelpOnly)
	{
	    DLGBOX( hInstance, MAKEINTRESOURCE( IDD_HELP ) , NULL, HelpDlgProc );
	}
    else
    {
        // Dumping an hwnd!
        if( dd.szHwnd )
        {
            HWND hw=(HWND)wcstol(dd.szHwnd, NULL,10);
            RuntimeDumpRCML( hw, dd.pszModule, &dd);
        }
        else
        {
            LPCTSTR pStrings[]={TEXT("Done"),TEXT("Two"),TEXT("Three"), NULL};
	        if( dd.pszModule==0 )
	        {
		        DLGBOXP( hInstance, MAKEINTRESOURCE( IDD_FILEPICKER ) , NULL, FilePickerDlgProc, (LPARAM)&dd); // ,  pStrings );
	        }
	        else
	        {
                //
                // See if we can loadLibrary it, if we can, generate it.
                //
                HMODULE h=LoadLibraryEx( dd.pszModule , NULL, LOAD_LIBRARY_AS_DATAFILE);
                if( h )
                {
                    FreeLibrary(h);
                    dd.bPrompt=FALSE;
    		        DLGBOXP( hInstance, MAKEINTRESOURCE( IDD_FILEPICKER ) , NULL, FilePickerDlgProc, (LPARAM)&dd); // ,  pStrings );
                }
                else
 		            DLGBOX( NULL, dd.pszModule, NULL, FilePickerDlgProc );
	        }
        }
    }

    //
    // Done processing, cleaning up.
    //
    RegCloseKey( hRCMLGen );

    delete dd.pszDialog;
    delete dd.pszModule;
    delete dd.pszOutputdir;
    delete encoding;

	return 0;
}

void	GetRCMLVersionNumber( HINSTANCE h,  LPTSTR * ppszVersion)
{
	DWORD	dwSize=MAX_PATH * 2;
	LPTSTR	pszString=new TCHAR[dwSize];
	if( GetModuleFileName( h, 
	  pszString,  // buffer that receives the base name
	  dwSize         // size of the buffer
		) > 0 )
	{
		DWORD	dwHandle;
		DWORD	dwInfoSize = GetFileVersionInfoSize( pszString, &dwHandle );
		LPBYTE	pVerInfo=new BYTE[dwInfoSize];

		if( GetFileVersionInfo( pszString, dwHandle, dwInfoSize, pVerInfo ) )
		{
			UINT	cbFileDescription;
			LPVOID	pData;
			if( VerQueryValue( pVerInfo, 
				TEXT("\\StringFileInfo\\040904b0\\FileVersion"), // FileDescription"),
				  &pData, 
				  &cbFileDescription) )
			{
				*ppszVersion=new TCHAR[cbFileDescription+1];
				lstrcpy(*ppszVersion, (LPTSTR)pData);
			}
		}
        delete pVerInfo;
	}
    delete pszString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlgen\rescontrol.h ===
// ResControl.h: interface for the CResControl class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RESCONTROL_H__DCE6FBE8_DD78_11D2_8BCE_00C04FB177B1__INCLUDED_)
#define AFX_RESCONTROL_H__DCE6FBE8_DD78_11D2_8BCE_00C04FB177B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
typedef void (*MYCB)(void);

#include "DumpCache.h"
class CResFile;

#undef PROPERTY
#define PROPERTY(name, type) type Get##name() const { return m_##name; } void Set##name(type i) { m_##name=i; }

typedef struct { 
    DWORD  helpID; 
    DWORD  exStyle; 
    DWORD  style; 
    short  x; 
    short  y; 
    short  cx; 
    short  cy; 
    short  id; 
    // sz_Or_Ord windowClass; // name or ordinal of a window class
    // sz_Or_Ord title;       // title string or ordinal of a resource
    // WORD   extraCount;     // bytes of following creation data
} DLGITEMTEMPLATEEX, * PDLGITEMTEMPLATEEX; 
 
typedef struct _ENTITY
{
    TCHAR   szChar;
    LPCTSTR szEntity;
} ENTITY, * PENTITY;

extern ENTITY g_Entity[];

class CResControl  
{
public:
	DLGITEMTEMPLATE * GetNextControl();
	CResControl(DLGITEMTEMPLATE * pData, BOOL bIsExtended, BOOL bWin32, CResFile & parent);
	CResControl(HWND hWnd, BOOL bIsExtended, BOOL bWin32, CResFile & parent);
	virtual ~CResControl();

	PROPERTY ( Width, DWORD );
	PROPERTY ( Height, DWORD );
	PROPERTY ( Style, DWORD );
	PROPERTY ( StyleEx, DWORD );
    PROPERTY ( DumpWin32, BOOL );
    PROPERTY ( Cicero, BOOL );

	WORD	GetWindowStyle() { return (WORD)(GetStyle()>>16) & 0xffff; }
	WORD	GetControlStyle() { return (WORD)GetStyle()&0xffff; }

	PROPERTY ( X, DWORD );
	PROPERTY ( Y, DWORD );
	PROPERTY ( ID, WORD );

	LPWSTR SetClass	( LPCTSTR pszClass );
	LPWSTR SetTitle	( LPCTSTR pszTitle );
	VOID   SetTitleID( DWORD titleID ) {	m_TitleID = titleID; }

	void	Dump(CResControl * pRelative=NULL );
	CResControl * GetRelative() { return m_pRelative; }
	LPWSTR GetTitle() { return m_pszTitle; }
	LPWSTR GetRawTitle() { return m_pszRawTitle; }
	LPWSTR GetClass() { return m_pszClass; }
    static LPWSTR  FindNiceText(LPCWSTR text);

private:
    CResFile    &   m_Parent;
	DLGITEMTEMPLATE * m_pData;
	CResControl	* m_pRelative;
	CDumpCache  * m_pDumpCache;

	DWORD	m_Width;
	DWORD	m_Height;
	DWORD	m_Style;
	DWORD	m_StyleEx;
	DWORD	m_X;
	DWORD	m_Y;
	WORD	m_ID;
	DWORD	m_TitleID;		// this one is for the ID of an icon


	LPWSTR	m_pszClass;
	LPWSTR	m_pszTitle;
    LPWSTR  m_pszRawTitle;

    //
    // Rendering styles
    //
    BOOL    m_DumpWin32;
    BOOL    m_Cicero;


protected:
    void    AddWin32Style( LPCTSTR pszAttrib=NULL);
    void    AddStyle( LPCTSTR pszAttrib=NULL);
    void    AddLocation( LPCTSTR pszAttrib=NULL);
    void    Add( LPCTSTR pszAttrib=NULL);
    void    AddControl( LPCTSTR pszAttrib=NULL);
    void    AddCicero(LPCTSTR pszAttrib=NULL);

    void    Emit( LPCTSTR pszElementName);
    void DumpTabStop( BOOL defaultsTo );
	void DumpWin32();

    DWORD   m_dumpedStyleEx;  // the bits that have been written out by the control
    DWORD   m_dumpedStyle;    // the bits that have been written out by the control.

    //
    // The WIN32 element goes here.
    //
    CDumpCache  *   m_pWin32;
    CDumpCache  *   m_pStyle;
    CDumpCache  *   m_pLocation;
    CDumpCache  *   m_pControl;
    CDumpCache  *   m_pCicero;

	LPWSTR	SetString( LPWSTR * ppszString, LPCTSTR pszSource  );
	DLGITEMTEMPLATE* m_pEndData;
	LPBYTE	m_pCreationData;

	HANDLE	m_hFile;
    HWND    m_hwnd; // hey, if we have an HWND lets use it!

	// static	LPCWSTR szClassNames[];

	typedef void (CResControl::*CLSPFN)(LPTSTR pszBuffer, LPCTSTR pszTitle);
#define DUMP(name) void Dump##name(LPTSTR pszBuffer, LPCTSTR pszTitle);

    // BUTTON
	DUMP(Button)
	DUMP(PushButton)
        // GROUPBOX
	    DUMP(GroupBox)
        // CHECKBOX
	    DUMP(CheckBox)
        // RADIOBUTTON
	    DUMP(RadioButton)

    // LABEL
	DUMP(DefStatic)

    // EDIT
	DUMP(DefEdit)

    // RECT
	DUMP(Rect)

    // IMAGE
	DUMP(Image)

    // LISTVIEW
	DUMP(ListView)

    // TREEVIEW
	DUMP(TreeView)

    // SLIDER
	DUMP(Slider)

    // SCROLLBAR
	DUMP(ScrollBar)

    // PROGRESS
	DUMP(Progress)

    // SPINNER
	DUMP(Spinner)

    // LISTBOX
	DUMP(ListBox)

    // COMBOBOX
	DUMP(ComboBox)

	DUMP(Pager)
	DUMP(Header)
	DUMP(Tab)
	DUMP(Animation)

	BOOL DumpDefButtonRules();
	BOOL DumpDefStaticRules();

	//
	// Property Dump Helpers.
	//
	void	DumpClassName();
	void	DumpWindowStyle();
	void	DumpControlStyle();
	void	DumpStyleEX();
    void    DumpWin32Styles();
    void	DumpHeight();
	void	DumpWidth();
	BOOL	DumpLocation();
	void	DumpIDDefMinusOne();
	void	DumpText();
	void	DumpID();

	TCHAR	m_szDumpBuffer[1024];

	typedef struct _SHORTHAND
	{
		LPCWSTR	pszClassName;
		DWORD	dwAndStyles;	// we and this with the style ...
		DWORD	dwStyles;		// if it matches this, it's a hit
		DWORD	dwAndStyleEx;	// same here.
		DWORD	dwStyleEx;
		CLSPFN		pfn;
		DWORD	dwWidth;
		DWORD	dwHeight;
	} SHORTHAND, * PSHORTHAND;

	static SHORTHAND pShorthand[];
	void		SetShorthand( PSHORTHAND pSH) {m_pCurrentSH=pSH; }
	PSHORTHAND	GetShorthand() { return m_pCurrentSH; }
	PSHORTHAND	m_pCurrentSH;

};

#undef PROPERTY

#endif // !defined(AFX_RESCONTROL_H__DCE6FBE8_DD78_11D2_8BCE_00C04FB177B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlgen\rcmlgen.h ===
#ifndef __RCMLGEN_H
#define __RCMLGEN_H

#include "..\xml2rcdll\RCMLNS.H"
#include "..\xml2rcdll\rcmlpublic.h"

#include "stringproperty.h"

class CDWin32NameSpaceLoader : public RCMLNameSpace
{
public:
    CDWin32NameSpaceLoader();

    typedef RCMLNode * (*CLSPFN)();

    typedef struct _XMLELEMENT_CONSTRUCTOR
    {
	    LPCTSTR	pwszElement;		// the element
	    CLSPFN	pFunc;				// the function to call.
    }XMLELEMENT_CONSTRUCTOR, * PXMLELEMENT_CONSTRUCTOR;

    static RCMLNode * WINAPI CreateElement( LPCTSTR pszText );
private:
};

extern "C" {
    __declspec(dllexport) RCMLNode * WINAPI CreateElement( LPCTSTR pszText )
    {
        return CDWin32NameSpaceLoader::CreateElement( pszText );
    }
};


class CXMLEnable : public RCMLNode, public _RCMLUnknownImp
{
public:
    CXMLEnable() {};
    virtual ~CXMLEnable() {};
    static RCMLNode * newXMLEnable() { return new CXMLEnable; }

    // Node
    virtual LPCTSTR GetStringType() { return TEXT("DWIN32:ENABLE"); }
    virtual	void SetParent( RCMLNode * p ) { m_pParent=p; }
    virtual	RCMLNode * GetParent() { return m_pParent; }

    virtual BOOL    AcceptChild( RCMLNode * pChild ) { return FALSE; }
    virtual void    DoEndChild(  RCMLNode * pChild) {};
    virtual UINT    GetType() { return 1; }
    virtual void    InitNode(RCMLNode * pParent );
    virtual void    ExitNode(RCMLNode * pParent, LONG lDialogResult ) {};

    // Attributes
    virtual    	BOOL	Set( LPCTSTR szPropID, LPCTSTR pValue ) { return m_PS.Set( szPropID, pValue); }
    virtual 	LPCTSTR	Get( LPCTSTR szPropID ) { return m_PS.Get( szPropID ); }
    virtual     DWORD   YesNo( LPCTSTR szPropID, DWORD dwNotPresent, DWORD dwYes=TRUE) { return m_PS.YesNo(  szPropID, dwNotPresent, dwYes ); }
    virtual     DWORD   YesNo( LPCTSTR szPropID, DWORD defNotPresent, DWORD dwNo, DWORD dwYes) { return m_PS.YesNo(  szPropID, defNotPresent, dwNo, dwYes); }
    virtual     DWORD   ValueOf( LPCTSTR szPropID, DWORD dwDefault) { return m_PS.ValueOf( szPropID, dwDefault ); }

    //
    // Unknown
    //
    ULONG STDMETHODCALLTYPE AddRef() { return _RCMLUnknownImp::AddRef(); }
    ULONG STDMETHODCALLTYPE Release() { return _RCMLUnknownImp::Release(); }

private:
    RCMLNode * m_pParent;
    CStringPropertySection m_PS;
};

class CXMLPersist : public CXMLEnable
{
public:
    CXMLPersist() {};
    virtual ~ CXMLPersist() {};
    static RCMLNode * newXMLPersist() { return new CXMLPersist; }
    virtual void    InitNode(RCMLNode * pParent );
    virtual void    ExitNode(RCMLNode * pParent, LONG lDialogResult  );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlgen\rescontrol.cpp ===
// ResControl.cpp: implementation of the CResControl class.
//
// http://msdn.microsoft.com/workshop/author/css/reference/attributes.asp
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ResControl.h"
#include "resfile.h"

//
// Control Style. 
// CS( ES_WANTRETURN, TEXT("WANTRETURN"), m_WantReturn, FALSE ) 
// -> WIN32:ELEMENT WANTRETURN="YES"
//
#define CONTROLSTYLE(p,id, member, def) if( ((dwRemainingStyles & p)==p) != def ) { wsprintf(m_szDumpBuffer, TEXT("%s=\"%s\" "), id, (dwRemainingStyles & p)?TEXT("YES"):TEXT("NO") ); AddControl(); } m_dumpedStyle |= p;
#define STYLEEX(p,id, member, def) if( ((dwRemainingStyles & p)==p) != def ) { wsprintf(m_szDumpBuffer, TEXT("%s=\"%s\" "), id, (dwRemainingStyles & p)?TEXT("YES"):TEXT("NO") ); AddWin32Style(); } m_dumpedStyleEx|=p;
#define STYLE(p,id, member, def) if( ((dwRemainingStyles & p)==p) != def ) { wsprintf(m_szDumpBuffer, TEXT("%s=\"%s\" "), id, (dwRemainingStyles & p)?TEXT("YES"):TEXT("NO") ); AddWin32Style(); } m_dumpedStyle |= p;
#define CONTROL(p,id, member, def) if( ((dwRemainingStyles & p)==p) != def ) { wsprintf(m_szDumpBuffer, TEXT("%s=\"%s\" "), id, (dwRemainingStyles & p)?TEXT("YES"):TEXT("NO") ); Add(); } m_dumpedStyle |= p;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CResControl::CResControl(DLGITEMTEMPLATE * pData, BOOL bIsExtended, BOOL bWin32, CResFile & parent)
:m_Parent(parent)
{
    SetDumpWin32(bWin32);
    SetCicero( parent.GetCicero() );
    m_hwnd=NULL;
	m_pData=pData;
	m_pszClass=NULL;
	m_pszTitle=NULL;
	m_pszRawTitle=NULL;

    m_dumpedStyleEx=0;
    m_dumpedStyle=0;

    m_pWin32=NULL;      // Win32 styles.
    m_pLocation=NULL;
    m_pStyle=NULL;
    m_pControl=NULL;
    m_pCicero=NULL;

	LPWORD pWord=NULL;
	if( bIsExtended )
	{
		PDLGITEMTEMPLATEEX pDataEx=(PDLGITEMTEMPLATEEX)pData;
		SetStyle(pDataEx->style);
		SetStyleEx(pDataEx->exStyle);
		SetID(pDataEx->id);
		SetY(pDataEx->y);
		SetX(pDataEx->x);
		SetY(pDataEx->y);
		SetWidth(pDataEx->cx);
		SetHeight(pDataEx->cy);
		pWord=(LPWORD)(pDataEx+1);
	}
	else
	{
		SetStyle(pData->style);
		SetStyleEx(pData->dwExtendedStyle);
		SetID(pData->id);
		SetY(pData->y);
		SetX(pData->x);
		SetY(pData->y);
		SetWidth(pData->cx);
		SetHeight(pData->cy);
		pWord=(LPWORD)(pData+1);
	}


	//
	// Now look at the class, title and creation data (?)
	//
	if( *pWord==0xffff)
	{
		pWord++;
		switch( *pWord )
		{
			case  0x0080: // Button
				SetClass(TEXT("BUTTON"));
			break;
			case  0x0081: // Edit
				SetClass(TEXT("EDIT"));
			break;
			case  0x0082: // Static
				SetClass(TEXT("STATIC"));
			break;
			case  0x0083: // List box
				SetClass(TEXT("LISTBOX"));
			break;
			case  0x0084: // Scroll bar
				SetClass(TEXT("SCROLLBAR"));
			break;
			case  0x0085: // Combo box
				SetClass(TEXT("COMBOBOX"));
			break;
		}
		pWord++;
	}
	else
	{
		pWord=SetClass(pWord);
	}

	if( *pWord == 0xffff )
	{
		//
		// Resource identifier - icon in a static for example (why not strings in a string table)
		//
		pWord++;
		SetTitleID(*pWord++);
	}
	else
	{
		pWord=SetTitle(pWord);
	}

	//
	// pWord now points at creation data.
	//
	WORD wCreationData=*pWord++;
	if(wCreationData)
	{
		m_pCreationData=new BYTE[wCreationData];
		CopyMemory(m_pCreationData, pWord, wCreationData);
	}
	else
		m_pCreationData=NULL;

	m_pEndData=(DLGITEMTEMPLATE *)((((((ULONG)(pWord))+3)>>2)<<2));
}

CResControl::CResControl(HWND hwnd, BOOL bIsExtended, BOOL bWin32, CResFile & parent)
:m_Parent(parent)
{
    SetDumpWin32(bWin32);
    SetCicero( parent.GetCicero() );
    m_hwnd=hwnd;
	m_pData=NULL;

	m_pszClass=NULL;
	m_pszTitle=NULL;
	m_pszRawTitle=NULL;

    m_dumpedStyleEx=0;
    m_dumpedStyle=0;

    m_pWin32=NULL;      // Win32 styles.
    m_pLocation=NULL;
    m_pStyle=NULL;
    m_pControl=NULL;
    m_pCicero=NULL;

	LPWORD pWord=NULL;

    // pretty much a copy from  CResFile::ExtractDlgHeaderInformation

    WINDOWPLACEMENT wp;
    wp.length = sizeof(wp);
    GetWindowPlacement( hwnd, &wp );

    RECT rp;
    GetWindowRect( GetParent(hwnd), &rp );

    RECT r;
    GetWindowRect( hwnd, &r);

    r.left = r.left-rp.left;
    r.right = r.right-rp.left;
    r.top = r.top - rp.top;
    r.bottom = r.bottom - rp.top;

    SIZE size;
    size.cx = wp.rcNormalPosition.right - wp.rcNormalPosition.left;
    size.cy = wp.rcNormalPosition.bottom - wp.rcNormalPosition.top;
    size = parent.m_Font.GetDlgUnitsFromPixels( size );
	SetWidth( size.cx );
	SetHeight( size.cy );

    size.cx = wp.rcNormalPosition.left;
    size.cy = wp.rcNormalPosition.top;
    size = parent.m_Font.GetDlgUnitsFromPixels( size );
	SetX( size.cx);
	SetY( size.cy  );


	SetID( (WORD)GetWindowLong( hwnd, GWL_ID) );
	SetTitleID( (WORD)GetWindowLong( hwnd, GWL_ID)  );
	SetStyle( GetWindowLong( hwnd, GWL_STYLE) );
	SetStyleEx( GetWindowLong( hwnd, GWL_EXSTYLE) );

    // SetClass(NULL);     // can't get that I don't think, hidden?
    int cbText = GetWindowTextLength( hwnd )+1;
    LPTSTR pszTitle=new TCHAR[cbText+1];
    GetWindowText( hwnd, pszTitle, cbText );
    SetTitle(pszTitle);     // how does this work for images??
    delete pszTitle;

    TCHAR szClass[MAX_PATH];
    GetClassName( hwnd, szClass, sizeof(szClass));
    SetClass(szClass);

	m_pEndData=NULL;
}

CResControl::~CResControl()
{
	delete m_pszClass;
	delete m_pszTitle;
	delete m_pszRawTitle;
    delete m_pWin32;
    delete m_pLocation;
    delete m_pStyle;
    delete m_pControl;
    delete m_pCicero;
}

DLGITEMTEMPLATE * CResControl::GetNextControl()
{
	return m_pEndData;	//
}

LPWSTR CResControl::SetClass	( LPCTSTR pszClass )
{
	return SetString( &m_pszClass, pszClass );
}

//
// The return is the start of the next character.
//

ENTITY g_Entity[] =
{ 
    {TEXT('<'), TEXT("&lt;") },
    {TEXT('>'), TEXT("&gt;") },
    {TEXT('&'), TEXT("&amp;") },
    {TEXT('\"'), TEXT("&quot;") },
    {TEXT('\''), TEXT("&apos;") },
    { NULL, NULL }
};

//
// Should we be converting the & here?
//
LPWSTR CResControl::SetTitle(LPCTSTR pszTitle )
{
    m_pszRawTitle=new TCHAR[lstrlen(pszTitle)+1];
    lstrcpy(m_pszRawTitle,pszTitle);

	//
	// Replace & with something else.
	//
	UINT	cbLen=lstrlenW(pszTitle)+1;
	LPWSTR newString=new WCHAR[cbLen*4];
	LPCWSTR pSource=pszTitle;
	LPWSTR pDest=newString;
	while( *pSource!=0)
	{
    /*    
    &lt; - (<) 
    &gt; - (>) 
    &amp; - (&) 
    &quot; - (") 
    &apos; - (') 
    */
        int i=0;
        BOOL bFound=FALSE;
        while( g_Entity[i].szEntity )
        {
            if( *pSource == g_Entity[i].szChar )
            {
                lstrcpy(pDest, g_Entity[i].szEntity );
                pDest += lstrlen( g_Entity[i].szEntity );
                bFound=TRUE;
                break;
            }
            i++;
        }

        if( !bFound )
			*pDest++=*pSource;
	    pSource++;
	}
	*pDest=0;

	LPWSTR pRes=SetString( &m_pszTitle, newString);
	delete newString;
	return (LPWSTR)pszTitle+cbLen;
}

LPWSTR CResControl::SetString( LPWSTR * ppszString , LPCTSTR pszSource )
{
	if( *ppszString != NULL )
	{
		delete *ppszString;
		*ppszString=NULL;
	}
	int len=lstrlenW( pszSource )+1;
	*ppszString=new WCHAR[len];
	lstrcpyW( *ppszString, pszSource );
	return (LPWSTR)pszSource+len;
}



//
// A switch based off the control name
//
void CResControl::Dump(CResControl * pRelative)
{
	m_pRelative=pRelative;

	TCHAR szBuffer[4096];

	LPCWSTR pszClass=(LPCWSTR)GetClass();
	if( (pszClass==NULL) || (lstrlenW(pszClass)==0) )
		pszClass=TEXT("STATIC");

	LPCTSTR pszTitle = (LPCWSTR)GetTitle();

	m_pDumpCache = new CDumpCache( m_Parent.GetFile() );

	//
	// Do a quick lookup to see if we know this class, and prefer to special case
	// it's dumping.
	//
	int i=0;
	BOOL bGenericControl=TRUE;
	SetShorthand(NULL);
	while( pShorthand[i].pszClassName )
	{
		if( lstrcmpiW( pShorthand[i].pszClassName, pszClass ) == 0 )
		{
			if( (GetStyle() & pShorthand[i].dwAndStyles) == pShorthand[i].dwStyles )
			{
				CLSPFN pFunc=pShorthand[i].pfn;
				SetShorthand(&pShorthand[i]);
				(this->*pFunc)(szBuffer, pszTitle);
#ifdef _DEBUG
                //
                // remove the styles which are shorthand.
                //
                // DumpWin32Styles();      ---- this is too late, the contol has 'emitted'
                DWORD dwRemainingStyle  = GetControlStyle() & ~m_dumpedStyle;
                if( dwRemainingStyle )
                {
	                wsprintf(m_szDumpBuffer,TEXT("%s - STYLE=\"0x%x\" "), 
                        pszClass,
                        dwRemainingStyle );
                    MessageBox( NULL, m_szDumpBuffer, TEXT("Missed control styles"), MB_OK );
    				(this->*pFunc)(szBuffer, pszTitle);
                }
#endif
				bGenericControl=FALSE;
				break;
			}
		}
		i++;
	}


	//
	// Do we emit this as a generic goober?
	//
	if(	bGenericControl==TRUE )
	{
        DumpLocation();

   	    DumpControlStyle();
	    DumpWindowStyle();
  	    DumpStyleEX();

		wsprintf(szBuffer,TEXT("CLASS=\"%s\" ID=\"%u\"  TEXT=\"%s\" "),
			pszClass, GetID(), pszTitle );
        Add(szBuffer);

		Emit(TEXT("CONTROL"));
	}

	delete m_pDumpCache;
}



////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////// H E L P E R S ///////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
void	CResControl::DumpIDDefMinusOne()
{
	if(GetID() != -1)
	{
		wsprintf(m_szDumpBuffer,TEXT("ID=\"%u\" "), GetID());
        Add();
	}
}

void	CResControl::DumpClassName()
{
	wsprintf(m_szDumpBuffer,TEXT("CLASS =\"%s\" "), GetClass);
    AddWin32Style();
}

//
// Adds a WIN32:STYLE attribute - these are WS_ and WS_EX styles
// NOT WIN32:BUTTON kinds of things.
// NOT to be called by individual control dumpers, ONLY by the WS_ and WS_EX guys.
//
void CResControl::AddWin32Style(LPCTSTR pszAttrib)
{
    if(m_pWin32==NULL)
        m_pWin32=new CDumpCache(m_Parent.GetFile());

    m_pWin32->AllocAddAttribute(pszAttrib?pszAttrib:m_szDumpBuffer);
}

//
// Adds a STYLE\@ attribute
//
void CResControl::AddStyle(LPCTSTR pszAttrib)
{
    if(m_pStyle==NULL)
        m_pStyle=new CDumpCache(m_Parent.GetFile());

    m_pStyle->AllocAddAttribute(pszAttrib?pszAttrib:m_szDumpBuffer);
}

void CResControl::AddCicero(LPCTSTR pszAttrib)
{
    if(m_pCicero==NULL)
        m_pCicero=new CDumpCache(m_Parent.GetFile());

    m_pCicero->AllocAddAttribute(pszAttrib?pszAttrib:m_szDumpBuffer);
}

//
// Adds a \LOCATION\@ attribute
//
void CResControl::AddLocation(LPCTSTR pszAttrib)
{
    if(m_pLocation==NULL)
        m_pLocation=new CDumpCache(m_Parent.GetFile());

    m_pLocation->AllocAddAttribute(pszAttrib?pszAttrib:m_szDumpBuffer);
}

//
// Adds an .\@ attribute
//
void CResControl::Add(LPCTSTR pszAttrib)
{
    m_pDumpCache->AllocAddAttribute(pszAttrib?pszAttrib:m_szDumpBuffer);
}

//
// Adds a control specific attribute - e.g. WIN32:BUTTON\@
//
void CResControl::AddControl(LPCTSTR pszAttrib)
{
    if(m_pControl==NULL)
        m_pControl=new CDumpCache(m_Parent.GetFile());
    m_pControl->AllocAddAttribute(pszAttrib?pszAttrib:m_szDumpBuffer);
}

void CResControl::Emit(LPCTSTR pszElement)
{
    m_pDumpCache->WriteElement( pszElement , 
        GetDumpWin32()?m_pWin32:NULL, 
        m_pStyle, 
        m_pLocation, 
        GetDumpWin32()?m_pControl:NULL ,
        GetCicero()?m_pCicero:NULL
        );
}

void CResControl::DumpText( )
{
	wsprintf(m_szDumpBuffer,TEXT("TEXT=\"%s\" "), GetTitle() );
    Add();
}

void CResControl::DumpID( )
{
	wsprintf(m_szDumpBuffer,TEXT("ID=\"%u\" "), GetID() );
    Add();
}

//
// This is for unknown controls?
//
void	CResControl::DumpControlStyle()
{
    DWORD dwRemainingStyle=GetControlStyle() & ~m_dumpedStyle;
    if( dwRemainingStyle )
    {   // doing a bitwise bump of the control style bits.
        for(int i=0;i<16;i++)
        {
            if( dwRemainingStyle & 1 )
            {
	            wsprintf(m_szDumpBuffer,TEXT("CS_BIT%02d=\"YES\" "), i );
                AddWin32Style();
            }
            dwRemainingStyle >>= 1;
        }
    }
}


    // dump this style bit
    // under this name
    // if it's NOT the default.

//
// Dumps all the window styles.
//

// make a copy of this so that dialog can call it and dump it's own version (different defaults)
// or make this static.

void	CResControl::DumpWindowStyle()
{
    DWORD dwRemainingStyles = GetStyle() & ~m_dumpedStyle;

    if(dwRemainingStyles==0)
        return;

#ifdef _DEBUG
    if( dwRemainingStyles & WS_TABSTOP )
        MessageBox( NULL, TEXT("You missed dumping the TABINDEX, add DumpTabStop(FALSE/FALSE);"), GetClass(), MB_OK);
#endif
    STYLE( WS_POPUP           , TEXT("POPUP") ,             m_Popup,        FALSE );
    STYLE( WS_CHILD           , TEXT("CHILD") ,             m_Child,        TRUE );
    STYLE( WS_MINIMIZE        , TEXT("MINIMIZE") ,          m_Maximize,         FALSE );
    // STYLE( WS_VISIBLE         , TEXT("VISIBLE") ,           m_Visible,      TRUE );
    if( !(dwRemainingStyles & WS_VISIBLE) )
        AddStyle( TEXT("VISIBILITY=\"HIDDEN\" "));

    STYLE( WS_DISABLED        , TEXT("DISABLED") ,          m_Disabled,     FALSE );
    STYLE( WS_CLIPSIBLINGS    , TEXT("CLIPSIBLINGS") ,      m_ClipSiblings, FALSE ); // CARE?
    STYLE( WS_CLIPCHILDREN    , TEXT("CLIPCHILDREN") ,      m_ClipChildren, FALSE ); // CARE?
    STYLE( WS_MAXIMIZE        , TEXT("MAXIMIZE") ,          m_Minimize,         FALSE );

    STYLE( WS_BORDER          , TEXT("BORDER") ,            m_Border,       FALSE );
    STYLE( WS_DLGFRAME        , TEXT("DLGFRAME") ,          m_DlgFrame,     FALSE ); // CARE?
    STYLE( WS_VSCROLL         , TEXT("VSCROLL") ,           m_VScroll,      FALSE );
    STYLE( WS_HSCROLL         , TEXT("HSCROLL") ,           m_HScroll,      FALSE );

    STYLE( WS_SYSMENU         , TEXT("SYSMENU"),            m_SysMenu,      FALSE ); // CARE?
    STYLE( WS_THICKFRAME      , TEXT("THICKFRAME") ,        m_ThickFrame,   FALSE ); // CARE?
    // STYLE( WS_MINIMIZEBOX     , TEXT("MINIMIZEBOX") ,       m_Group,   FALSE );
    // STYLE( WS_MAXIMIZEBOX     , TEXT("MAXIMIZEBOX") ,       m_TabStop,   FALSE );
    STYLE( WS_GROUP           , TEXT("GROUP") ,             m_Group,        FALSE );

    // This is an attribute on the CONTROL itself TABINDEX="0" means WS_TABSTOP
    // we shouldn't get this far - but it's a catchall??
    STYLE( WS_TABSTOP         , TEXT("TABSTOP") ,           m_TabStop,      FALSE );
}

//
// Pass in TRUE, if you expect it to be on, e.g. edit controls, buttons.
// false ifyou expect it to be off,e.g. statics.
//
void CResControl::DumpTabStop( BOOL defaultsTo )
{
    DWORD dwRemainingStyles = GetStyle() & ~m_dumpedStyle;
    if( defaultsTo == TRUE )
    {
        // Should be set, so if it's not, we make it -1
        if( ((dwRemainingStyles & WS_TABSTOP)!=WS_TABSTOP) )
            Add(TEXT("TABINDEX=\"-1\" "));
    }
    else
    {
        // Should NOT be set, so if it is, we make it 0.
        if( ((dwRemainingStyles & WS_TABSTOP)==WS_TABSTOP) )
            Add(TEXT("TABINDEX=\"0\" "));
    }
    m_dumpedStyle |= WS_TABSTOP;
}

//
// Dumps all the style bits that have not been addressed but the
// dumping of the element itself (perhaps by shorthand).
//
void	CResControl::DumpStyleEX()
{
    DWORD dwRemainingStyles = GetStyleEx() & ~m_dumpedStyleEx;

    if(dwRemainingStyles==0)
        return;

    if( GetDumpWin32()== FALSE )
    {
        // we map the following 3 style bits to CSS
        // WS_EX_DLGMODALFRAME WS_EX_CLIENTEDGE WS_EX_STATICEDGE WS_EX_WINDOWEDGE
        switch( dwRemainingStyles & (WS_EX_DLGMODALFRAME | WS_EX_CLIENTEDGE | WS_EX_STATICEDGE | WS_EX_WINDOWEDGE) )
        {
        case WS_EX_CLIENTEDGE | WS_EX_STATICEDGE :
            AddStyle(TEXT("BORDER-STYLE=\"INSET\" BORDER-WIDTH=\"3\" "));
            break;

        case WS_EX_CLIENTEDGE:
            AddStyle(TEXT("BORDER-STYLE=\"INSET\" BORDER-WIDTH=\"2\" "));
            break;

        case WS_EX_STATICEDGE :
            AddStyle(TEXT("BORDER-STYLE=\"INSET\" BORDER-WIDTH=\"1\" "));
            break;

        case WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE:
        case WS_EX_DLGMODALFRAME:
            AddStyle(TEXT("BORDER-STYLE=\"OUTSET\" BORDER-WIDTH=\"2\" "));
            break;

        case WS_EX_DLGMODALFRAME | WS_EX_CLIENTEDGE | WS_EX_WINDOWEDGE :
        case WS_EX_DLGMODALFRAME | WS_EX_CLIENTEDGE :
            AddStyle(TEXT("BORDER-STYLE=\"RIDGE\" BORDER-WIDTH=\"3\" "));
            break;
        }
        return;
    }

    STYLEEX( WS_EX_DLGMODALFRAME     , TEXT("MODALFRAME"),    m_ModalFrame,     FALSE );
    STYLEEX( 0x2                     , TEXT("EXBIT1"),          m_Bit1, FALSE );
    STYLEEX( WS_EX_NOPARENTNOTIFY    , TEXT("NOPARENTNOTIFY"),m_NoParentNotify, FALSE );
    STYLEEX( WS_EX_TOPMOST           , TEXT("TOPMOST"),       m_TopMost,        FALSE );

    STYLEEX( WS_EX_ACCEPTFILES       , TEXT("DROPTARGET"),    m_DropTarget,     FALSE );
    STYLEEX( WS_EX_TRANSPARENT       , TEXT("TRANSPARENT"),   m_Transparent,    FALSE );
    STYLEEX( WS_EX_MDICHILD          , TEXT("MDI"),           m_MDI,            FALSE );
    STYLEEX( WS_EX_TOOLWINDOW        , TEXT("TOOLWINDOW"),    m_ToolWindow,     FALSE );

    STYLEEX( WS_EX_WINDOWEDGE        , TEXT("WINDOWEDGE"),    m_WindowEdge,     FALSE );
    STYLEEX( WS_EX_CLIENTEDGE        , TEXT("CLIENTEDGE"),    m_ClientEdge,     FALSE );
    STYLEEX( WS_EX_CONTEXTHELP       , TEXT("CONTEXTHELP"),   m_ContextHelp,    FALSE );
    STYLEEX( 0x00000800L             , TEXT("EXBIT11"),         m_Bit11,          FALSE );

    STYLEEX( WS_EX_RIGHT             , TEXT("RIGHT"),         m_Right,          FALSE );
    STYLEEX( WS_EX_RTLREADING        , TEXT("RTLREADING"),    m_RTLReading,     FALSE );
    STYLEEX( WS_EX_LEFTSCROLLBAR     , TEXT("LEFTSCROLLBAR"), m_LeftScrollbar,  FALSE );
    STYLEEX( 0x00008000L             , TEXT("EXBIT15"),       m_Bit15,          FALSE );

    STYLEEX( WS_EX_CONTROLPARENT     , TEXT("CONTROLPARENT"), m_ControlParent,  FALSE );
    STYLEEX( WS_EX_STATICEDGE        , TEXT("STATICEDGE"),    m_StaticEdge,     FALSE );
    STYLEEX( WS_EX_APPWINDOW         , TEXT("APPWINDOW"),     m_AppWindow,      FALSE );
    STYLEEX( 0x00080000L             , TEXT("EXBIT19"),       m_Bit19,          FALSE );

    STYLEEX( 0x00100000L             , TEXT("EXBIT20"),       m_Bit20,          FALSE );
    STYLEEX( 0x00200000L             , TEXT("EXBIT21"),       m_Bit21,          FALSE );
    STYLEEX( 0x00400000L             , TEXT("EXBIT22"),       m_Bit22,          FALSE );
    STYLEEX( 0x00800000L             , TEXT("EXBIT23"),       m_Bit23,          FALSE );

    STYLEEX( 0x01000000L             , TEXT("EXBIT24"),       m_Bit24,          FALSE );
    STYLEEX( 0x02000000L             , TEXT("EXBIT25"),       m_Bit25,          FALSE );
    STYLEEX( 0x04000000L             , TEXT("EXBIT26"),       m_Bit26,          FALSE );
    STYLEEX( 0x08000000L             , TEXT("EXBIT27"),       m_Bit27,          FALSE );

    STYLEEX( 0x10000000L             , TEXT("EXBIT28"),       m_Bit28,          FALSE );
    STYLEEX( 0x20000000L             , TEXT("EXBIT29"),       m_Bit29,          FALSE );
    STYLEEX( 0x40000000L             , TEXT("EXBIT30"),       m_Bit30,          FALSE );
    STYLEEX( 0x80000000L             , TEXT("EXBIT31"),       m_Bit31,          FALSE );

}

//
// This is a control attribute.
//
void	CResControl::DumpHeight()
{
	PSHORTHAND pSH=GetShorthand();
	if( (pSH==NULL) || (pSH->dwHeight != GetHeight() ) )
	{
		wsprintf(m_szDumpBuffer,TEXT("HEIGHT=\"%d\" "), GetHeight() );
		Add();
	}
}

//
// This is a control attribute.
//
void	CResControl::DumpWidth()
{
	PSHORTHAND pSH=GetShorthand();
	if( (pSH==NULL) || (pSH->dwWidth != GetWidth() ) )
	{
		wsprintf(m_szDumpBuffer,TEXT("WIDTH=\"%d\" "), GetWidth() );
		Add();
	}
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Dumps width, height, X and Y
// RELATIVE
// TO = ID of thing relative to
// ALIGN shorthand - not suppored.
// CORNER RELATIVECORNER, relate to TOPLEFT
//
////////////////////////////////////////////////////////////////////////////////////////
BOOL CResControl::DumpLocation()
{
	if( GetRelative() == NULL )
	{
        wsprintf(m_szDumpBuffer ,TEXT("X=\"%d\" Y=\"%d\" "), GetX(), GetY() );
        Add();  // if it's not relative we use X and Y, should these be AddLocation?
		DumpWidth();
		DumpHeight();
		return FALSE;
	}

    //
    // Get the RECTs of us and them.
    //
    RECT us;
    us.left = GetX();
    us.top = GetY();
    us.right = GetX() + GetWidth();
    us.bottom = GetY() + GetHeight();

    CResControl * pRelative=GetRelative();
    RECT their;
    their.left = pRelative->GetX();
    their.top = pRelative->GetY();
    their.right = pRelative->GetX() + pRelative->GetWidth();
    their.bottom = pRelative->GetY() + pRelative->GetHeight();

    //
    // Work out our alignment.
    //
    if( us.left > their.right )
    {
        // we're to the RIGHT
        if( us.top == their.top )
        {
            AddLocation(TEXT("ALIGN=\"RIGHT\" "));
        }
        else
        {
            AddLocation(TEXT("CORNER=\"TOPLEFT\" RELATIVECORNER=\"TOPRIGHT\" "));
		    wsprintf(m_szDumpBuffer,TEXT(" Y=\"%d\" "), us.top - their.top );
            AddLocation();
        }
		wsprintf(m_szDumpBuffer,TEXT(" X=\"%d\" "), us.left - their.right );
        AddLocation();
    }
    else if ( us.right < their.left )
    {
        // we're to the LEFT
        if( us.top == their.top )
        {
            AddLocation(TEXT("ALIGN=\"LEFT\" "));
        }
        else
        {
            AddLocation(TEXT("CORNER=\"TOPRIGHT\" RELATIVECORNER=\"TOPLEFT\" "));
		    wsprintf(m_szDumpBuffer,TEXT(" Y=\"%d\" "), us.top - their.top );
            AddLocation();
        }
		wsprintf(m_szDumpBuffer,TEXT(" X=\"%d\" "), us.right - their.left );
        AddLocation();
    }
    else if ( us.top > their.bottom )
    {
        // we're below their
        if( us.left == their.left )
        {
            AddLocation(TEXT("ALIGN=\"BELOW\" "));
        }
        else
        {
            AddLocation(TEXT("CORNER=\"TOPLEFT\" RELATIVECORNER=\"BOTTOMLEFT\" "));
		    wsprintf(m_szDumpBuffer,TEXT(" X=\"%d\" "), us.right - their.right);
            AddLocation();
        }
		wsprintf(m_szDumpBuffer,TEXT(" Y=\"%d\" "), us.top - their.bottom );
        AddLocation();
    }
    else if ( us.bottom < their.top )
    {
        // we're ABOVE their
        if( us.left == their.left )
        {
            AddLocation(TEXT("ALIGN=\"ABOVE\" "));
        }
        else
        {
            AddLocation(TEXT("CORNER=\"BOTTOMLEFT\" RELATIVECORNER=\"TOPLEFT\" "));
		    wsprintf(m_szDumpBuffer,TEXT(" X=\"%d\" "), us.right - their.right);
            AddLocation();
        }
		wsprintf(m_szDumpBuffer,TEXT(" Y=\"%d\" "), us.bottom - their.top );
        AddLocation();
    }
    else
    {
        // HMM, no relationship?
        // they are overlapping perhaps??
        wsprintf(m_szDumpBuffer ,TEXT("X=\"%d\" Y=\"%d\" "), GetX(), GetY() );
        Add();  // if it's not relative we use X and Y, should these be AddLocation?
		DumpWidth();
		DumpHeight();
		return FALSE;
    }

    // Now don't forget the width and height on the parent!
	DumpWidth();
	DumpHeight();


	return TRUE;
}


//
// Emits all the un-emitted bits from the WS_* and WS_EX* stuff.
//
void CResControl::DumpWin32()
{

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This will take a string like "&About ..." and return "About"
// or "Try to R&einvest" and return "Reinvest"
//
LPWSTR CResControl::FindNiceText(LPCWSTR text)
{
    if( text==NULL )
        return NULL;

    LPCWSTR pszLastSpace=text;
    BOOL bFoundAccelorator=FALSE;
    LPCWSTR pszCurrentChar=text;
    while(*pszCurrentChar)
    {
        if( *pszCurrentChar == L'&' )
        {
            bFoundAccelorator=TRUE;
            break;
        }
        if( *pszCurrentChar == L' ' )
            pszLastSpace=pszCurrentChar+1;

        pszCurrentChar++;
    }

    //
    // If we found an &, then we know which word it is on.
    // isolate the word.
    //
    pszCurrentChar = pszLastSpace;
    BOOL bFindingEnd=TRUE;
    UINT iStrLen=0;
    while( bFindingEnd )
    {
        switch (*pszCurrentChar )
        {
            case L' ':
            case L'.':
            case L':':
            case L'-':  // isn't this IsAlpha
            case 0:
            case 9:
                bFindingEnd=FALSE;  // we're left pointing at the terminating char.
                break;
            default:
                pszCurrentChar++;
                iStrLen++;
                break;
        }
    };

    LPWSTR pszNewString = new TCHAR[iStrLen+1];

    if( bFoundAccelorator==FALSE )
    {
        ZeroMemory( pszNewString, (iStrLen+1)*sizeof(WCHAR) );
        CopyMemory( pszNewString, pszLastSpace, iStrLen*sizeof(WCHAR));
    }
    else
    {
        // copy, skipping over the & and the ... if present (though they shouldn't be).
        LPWSTR pszDest=pszNewString;
        LPCWSTR pszLastChar=pszCurrentChar;
        pszCurrentChar = pszLastSpace;
        while( pszCurrentChar != pszLastChar )
        {
            if( *pszCurrentChar==L'&' || *pszCurrentChar==L'.' )
            {
            }
            else
                *pszDest++=*pszCurrentChar;
            pszCurrentChar++;
        };
        *pszDest=0;
    }
    return pszNewString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlgen\resfile.h ===
// ResFile.h: interface for the CResFile class.
//
// Understands / parses resource file
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RESFILE_H__1E466580_DD5E_11D2_8BCE_00C04FB177B1__INCLUDED_)
#define AFX_RESFILE_H__1E466580_DD5E_11D2_8BCE_00C04FB177B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "rescontrol.h"
#include "fileencoder.h"
#include "fonts.h"
#include "winable.h"
#include "unknwn.h"
#include "oleacc.h"

#undef PROPERTY
#define PROPERTY(name, type) type Get##name() const { return m_##name; } void Set##name(type i) { m_##name=i; }

typedef struct {  
    WORD   dlgVer; 
    WORD   signature; 
    DWORD  helpID; 
    DWORD  exStyle; 
    DWORD  style; 
    WORD   cDlgItems; 
    short  x; 
    short  y; 
    short  cx; 
    short  cy; 
    WORD  menu;         // name or ordinal of a menu resource MAKEINTRESOURCE
    WORD  windowClass;  // name or ordinal of a window class
    // WCHAR  title[0]; // title string of the dialog box
    // short  pointsize;       // if DS_SETFONT or DS_SHELLFONT is set
    // short  weight;          // if DS_SETFONT or DS_SHELLFONT is set
    // short  bItalic;         // if DS_SETFONT or DS_SHELLFONT is set
    // WCHAR  font[fontLen];   // if DS_SETFONT or DS_SHELLFONT is set
} DLGTEMPLATEEX, * PDLGTEMPLATEEX; 

class CResFile  
{
public:
    LPWSTR FixEntity( LPWSTR pszTitle );
	void DumpDialog(LPTSTR pszOutputFile);  // dumps the whole thing, calles the methods below.
	void DumpEpilog();
    void DumpPage();
	void DumpFormAndCaption();
	void DumpTestInfo(LPTSTR pszFileName);
	void DumpProlog();
	void DumpDialogStyles();
	void DumpMenu();
	BOOL IsExtended(DLGTEMPLATE *pDlgTemplate);

	CResFile(BOOL bEnhanced, BOOL bRelative, BOOL bWin32, BOOL bCicero);
	virtual ~CResFile();
	BOOL	LoadDialog(LPTSTR ID, HMODULE hMod=NULL);
	BOOL	LoadWindow(HWND hWnd);
	PROPERTY ( Width, DWORD );
	PROPERTY ( Height, DWORD );
	PROPERTY ( Style, DWORD );
	PROPERTY ( ItemCount, DWORD );
	PROPERTY ( StyleEx, DWORD );
	PROPERTY ( FontSize, WORD );
	PROPERTY ( FontWeight, WORD );
	PROPERTY ( FontItalic, WORD );
    PROPERTY ( Enhanced, BOOL );
    PROPERTY ( Win32, BOOL );
    PROPERTY ( Relative, BOOL );
    PROPERTY ( Cicero, BOOL );

	LPWSTR SetMenu	( LPWSTR pszMenu );
	LPWSTR SetClass	( LPWSTR pszClass );
	LPWSTR SetTitle	( LPWSTR pszTitle );
	LPWSTR SetFont	( LPWSTR pszString );

	LPWSTR GetTitle() { return m_pszTitle; }
	LPWSTR GetClass() { return m_pszClass; }
	LPWSTR GetFont() { return m_pszFont; }
	LPWSTR GetMenu() { return m_pszMenu; }

    void DumpLayoutElement();
    CFileEncoder &  GetFile() { return m_hFile; }

    //
    // When we're dumping a dialog, we use this font mapping??
    // public because I'm lazy.
    //
    CQuickFont      m_Font;
	void FindMenuItem( IAccessible * pAcc, LONG role_code);
    void DumpAccessibleItem( IAccessible * pAcc, VARIANT * pvChild, LONG role_code );

private:
	DWORD	m_Width;
	DWORD	m_Height;
	DWORD	m_Style;
	DWORD	m_StyleEx;
	DWORD	m_ItemCount;

	LPWSTR	m_pszMenu;
	LPWSTR	m_pszClass;
	LPWSTR	m_pszTitle;

	WORD	m_FontSize;
	WORD	m_FontWeight;	// DlgEX
	WORD	m_FontItalic;	// DlgEX
	LPWSTR	m_pszFont;

    HWND    m_hwnd;         // if we're dumping something live.
    HWND    GetWindow() { return m_hwnd; }


protected:
	void FindMenuItem( HMENU hMenu, LONG nothing );
    void Write( LPTSTR pszString, BOOL newLine=TRUE ) { m_hFile.Write( pszString, newLine); }
	DLGITEMTEMPLATE *	ExtractDlgHeaderInformation( DLGTEMPLATE * pDlgTemplate );
	void                ExtractDlgHeaderInformation( HWND hWnd );

	LPWSTR	SetString( LPWSTR * ppszString, LPWSTR pszSource  );

	CResControl **	m_pControls;
    struct {
        BOOL        m_Enhanced:1;
        BOOL        m_Win32:1;
        BOOL        m_Relative:1;
        BOOL        m_Cicero:1;
    };

	// HANDLE		m_hFile;
    CFileEncoder    m_hFile;

    //
    // The WIN32 element goes here.
    //
    CDumpCache  *   m_pWin32;

};

#endif // !defined(AFX_RESFILE_H__1E466580_DD5E_11D2_8BCE_00C04FB177B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlgen\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	RC2XML.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlgen\resfile.cpp ===
// ResFile.cpp: implementation of the CResFile class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ResFile.h"
#include "debug.h"
extern void	GetRCMLVersionNumber( HINSTANCE h,  LPTSTR * ppszVersion);

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CResFile::CResFile(BOOL bEnhanced, BOOL bRelative, BOOL bWin32, BOOL bCicero)
{
	m_pszMenu=NULL;
	m_pszClass=NULL;
	m_pszTitle=NULL;
	m_pszFont=NULL;
	m_pControls=NULL;
	SetItemCount(0);

    SetEnhanced( bEnhanced );
    SetRelative( bRelative );
    SetWin32( bWin32 );
    SetCicero( bCicero );

    m_pWin32=NULL;
    m_hwnd=NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
CResFile::~CResFile()
{
    if( HIWORD(m_pszMenu) )
	    delete m_pszMenu;

    if( HIWORD(m_pszClass) )
	    delete m_pszClass;

	delete m_pszTitle;
	delete m_pszFont;
    delete m_pWin32;

	int k=GetItemCount();
	for(int i=0;i<k;i++)
		delete m_pControls[i];
	delete m_pControls;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
BOOL CResFile::LoadDialog(LPTSTR ID, HMODULE hMod)
{
	HRSRC hDialog = FindResource( hMod, ID , RT_DIALOG );
	if( hDialog!=NULL )
	{
		HGLOBAL hMemDialog = LoadResource( hMod, hDialog );
		if( hMemDialog != NULL )
		{
			LPVOID pMemDialog = LockResource( hMemDialog );
			//
			//
			//
			DLGTEMPLATE * pDlgTemplate=(DLGTEMPLATE*)pMemDialog;
			DLGITEMTEMPLATE * pControls = ExtractDlgHeaderInformation( pDlgTemplate );
			if(pControls==NULL)
				return FALSE;

			BOOL	bIsExtended=IsExtended( pDlgTemplate );
			int k=GetItemCount();
			m_pControls=new CResControl*[k];
			for(int i=0;i<k;i++)
			{
				m_pControls[i]=new CResControl( pControls, bIsExtended, GetWin32(), *this );
				pControls=m_pControls[i]->GetNextControl();		// this is odd.
			}
			UnlockResource( hMemDialog );
			return TRUE;
		}
	}
	return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////
//
// Temporary hack - but seems to be working quite well
//
//////////////////////////////////////////////////////////////////////
BOOL CResFile::LoadWindow(HWND hWnd)
{
    m_hwnd= hWnd;
    ExtractDlgHeaderInformation(hWnd);

    HWND hFirstChild=::GetWindow(hWnd, GW_CHILD);
    // count the number of children.
    int i=0;
    while( hFirstChild )
    {
        hFirstChild=::GetWindow( hFirstChild, GW_HWNDNEXT );
        i++;
    }

    // 
    SetItemCount(i);
    m_pControls=new CResControl*[i];
    hFirstChild=::GetWindow(hWnd, GW_CHILD);
    i=0;
    while( hFirstChild )
    {
    	m_pControls[i]=new CResControl( hFirstChild, TRUE, GetWin32(), *this );
        hFirstChild=::GetWindow( hFirstChild, GW_HWNDNEXT );
        i++;
    }
	return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
void CResFile::ExtractDlgHeaderInformation(HWND hwnd)
{
    HFONT hFont = (HFONT)SendMessage( hwnd , WM_GETFONT, NULL, NULL);
    if(hFont==NULL)
        hFont = (HFONT)GetStockObject(SYSTEM_FONT);
    LOGFONT lf;
    ::GetObject( hFont, sizeof(lf), &lf );
    m_Font.Init(NULL,0,0,0,&lf);

    WORD wSize= (WORD)(lf.lfHeight<0?-MulDiv(lf.lfHeight, 72, GetDeviceCaps(GetDC(hwnd), LOGPIXELSY) ):lf.lfHeight);

    SetFontSize( wSize );     // probably need to back map?
    SetFontWeight( (WORD)lf.lfWeight );
    SetFontItalic( lf.lfItalic );
    SetFont( lf.lfFaceName );

    //
    // Now we have the font, we can size the dialog correctly.
    //
    WINDOWPLACEMENT wp;
    wp.length = sizeof(wp);
    GetWindowPlacement( hwnd, &wp );

    RECT r;
    GetClientRect( hwnd, &r);

    SIZE size;
    size.cx = wp.rcNormalPosition.right - wp.rcNormalPosition.left;
    size.cy = wp.rcNormalPosition.bottom - wp.rcNormalPosition.top;
    size.cx = r.right - r.left;
    size.cy = r.bottom - r.top;
    size = m_Font.GetDlgUnitsFromPixels( size );

	SetWidth( size.cx );
	SetHeight( size.cy );

	SetStyle( GetWindowLong( hwnd, GWL_STYLE) );
	SetStyleEx( GetWindowLong( hwnd, GWL_EXSTYLE) );

    SetMenu(NULL);      // review
    SetClass(NULL);     // can't get that I don't think, hidden?
    int cbText = GetWindowTextLength( hwnd )+1;
    LPTSTR pszTitle=new TCHAR[cbText+1];
    GetWindowText( hwnd, pszTitle, cbText );
    SetTitle(pszTitle);
    delete pszTitle;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
DLGITEMTEMPLATE * CResFile::ExtractDlgHeaderInformation(DLGTEMPLATE *pDlgTemplate)
{
	DLGTEMPLATEEX * pDlgEx=(DLGTEMPLATEEX*)pDlgTemplate;

	//
	// New or old style dialog template.
	//
	if ( pDlgEx->signature == (WORD)-1 )
	{
		//
		// New dialog format used here.
		//
		SetWidth( pDlgEx->cx );
		SetHeight( pDlgEx->cy );
		SetItemCount( pDlgEx->cDlgItems );
		SetStyle( pDlgEx->style );
		SetStyleEx( pDlgEx->exStyle );

		LPWSTR pszString=(LPWSTR)(&pDlgEx->menu);

		//
		// Menu goo.
		//
		WORD * pW=(WORD*)pszString;
		if( *pW == 0 )
		{
			// No menu.
			pszString++;
		}
		else if (*pW==(WORD)-1)
		{
			// Menu is a resource - yuck.
			SetMenu( (LPTSTR)*(pW+1) );
			pszString+=2;
		}
		else
		{
			pszString = SetMenu( pszString );
		}

		//
		// Class goo.
		//
		pW=(WORD*)pszString;
		if( *pW == 0 )
		{
			// No class.
			pszString++;
		}
		else if (*pW==(WORD)-1)
		{
			// Menu is a resource - what does that mean!
			pszString+=2;
		}
		else
		{
			pszString = SetClass( pszString );
		}

		//
		//
		pszString = SetTitle( pszString );

		//
		// pszString now points at 
		//
	    // short  pointsize;       // if DS_SETFONT or DS_SHELLFONT is set
		// short  weight;          // if DS_SETFONT or DS_SHELLFONT is set
		// short  bItalic;         // if DS_SETFONT or DS_SHELLFONT is set
		// WCHAR  font[fontLen];   // if DS_SETFONT or DS_SHELLFONT is set

		DWORD dwStyle = GetStyle();
		if( dwStyle & DS_SETFONT )
		{
			short * pShort=(short *)pszString;
			// Font Size
			SetFontSize( *pShort++ );
			SetFontWeight( *pShort++ );
			SetFontItalic( *pShort++ );
			pszString=SetFont( (LPWSTR)pShort );
		}
		DWORD pData=(DWORD)pszString;
		pData+=3;
		pData &= ~3;
		return (DLGITEMTEMPLATE * )pData;

	}
	else
	{
		SetWidth( pDlgTemplate->cx );
		SetHeight( pDlgTemplate->cy );
		SetItemCount( pDlgTemplate->cdit );
		SetStyle( pDlgTemplate->style );
		SetStyleEx( pDlgTemplate->dwExtendedStyle );

		LPWSTR pszString=(LPWSTR)(&pDlgTemplate->cy+1);
		// pszString++;		// for some reason, we do this>?

		//
		// Followed by 3 variable length arrays (strings)
		// menu, class, title and then a font name if DS_SETFONT is used.
		//
		pszString = SetMenu( pszString );
		pszString = SetClass( pszString );
		pszString = SetTitle( pszString );

		//
		// Now we go for the FONT.
		// 
		DWORD dwStyle = GetStyle();
		if( dwStyle & DS_SETFONT )
		{
			// Font Size
			SetFontSize( *((LPWORD)pszString) );
			pszString++;
			pszString=SetFont( pszString );
		}
		DWORD pData=(DWORD)pszString;
		pData+=3;
		pData &= ~3;
		return (DLGITEMTEMPLATE * )pData;
	}
	return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
LPWSTR CResFile::SetMenu	( LPWSTR pszMenu )
{
	return SetString( &m_pszMenu, pszMenu );
}

LPWSTR CResFile::SetClass	( LPWSTR pszClass )
{
	return SetString( &m_pszClass, pszClass );
}

LPWSTR CResFile::SetTitle	( LPWSTR pszTitle )
{
	UINT   cbLen=lstrlenW(pszTitle)+1;
    LPWSTR newString = FixEntity( pszTitle );
	LPWSTR pRes=SetString( &m_pszTitle, newString);
	delete newString;
	return pszTitle+cbLen;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Takes an input string, and returns a string fixed up with entities.
//
LPWSTR CResFile::FixEntity( LPWSTR pszTitle )
{
	UINT	cbLen=lstrlenW(pszTitle)+1;
	LPWSTR newString=new WCHAR[cbLen*4];
	LPWSTR pSource=pszTitle;
	LPWSTR pDest=newString;
	while( *pSource!=0)
	{
    /*    
    &lt; - (<) 
    &gt; - (>) 
    &amp; - (&) 
    &quot; - (") 
    &apos; - (') 
    */
        int i=0;
        BOOL bFound=FALSE;
        while( g_Entity[i].szEntity )
        {
            if( *pSource == g_Entity[i].szChar )
            {
                lstrcpy(pDest, g_Entity[i].szEntity );
                pDest += lstrlen( g_Entity[i].szEntity );
                bFound=TRUE;
                break;
            }
            i++;
        }

        if( !bFound )
			*pDest++=*pSource;
	    pSource++;
	}
	*pDest=0;

	return newString;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
LPWSTR CResFile::SetFont	( LPWSTR pszFont )
{
	return SetString( &m_pszFont, pszFont );
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
LPWSTR CResFile::SetString( LPWSTR * ppszString , LPWSTR pszSource )
{
	if( HIWORD(*ppszString) != NULL )
	{
		delete *ppszString;
		*ppszString=NULL;
	}
    if(HIWORD(pszSource))
    {
	    int len=lstrlenW( pszSource )+1;
	    *ppszString=new WCHAR[len];
	    lstrcpyW( *ppszString, pszSource );
	    return pszSource+len;
    }
    else
    {
        *ppszString=pszSource;
        return NULL;
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
void CResFile::DumpDialog(LPTSTR pszFilename)
{
    if( m_hFile.CreateFile(pszFilename) )
    {
        DumpProlog();

        DumpFormAndCaption();

        DumpPage();
        //<PAGE>
        DumpDialogStyles();
        DumpTestInfo(pszFilename);
        DumpLayoutElement();
        DumpMenu();
	    int k=GetItemCount();
	    CResControl * pLast=NULL;
	    CResControl * pCurrent=NULL;
	    for(int i=0;i<k;i++)
	    {
		    pCurrent=m_pControls[i];
		    
		    BOOL bRelative=FALSE;
		    if( GetRelative() )
		    {
			    //
			    // Work out if we can do a relative position.
			    // same X or same Y, with same height is OK.
			    //
			    if( pLast )
			    {
				    if( pCurrent->GetY() == pLast->GetY() )
				    {
					    if( pCurrent->GetHeight() == pCurrent->GetHeight() )
					    {
						    bRelative=TRUE;
					    }
				    }

				    if( pCurrent->GetX() == pLast->GetX( ) )
				    {
					    if( pCurrent->GetHeight() == pCurrent->GetHeight() )
					    {
						    bRelative=TRUE;
					    }
				    }
			    }
		    }
            pCurrent->Dump(bRelative?pLast:NULL);
		    pLast=pCurrent;
            Write( TEXT("\r\n"), FALSE );
	    }
        //</PAGE>
        DumpEpilog();
        m_hFile.CloseFile();
    }	
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
BOOL CResFile::IsExtended(DLGTEMPLATE *pDlgTemplate)
{
	DLGTEMPLATEEX * pDlgEx=(DLGTEMPLATEEX*)pDlgTemplate;

	//
	// New or old style dialog template.
	//
	return pDlgEx->signature == (WORD)-1 ;
}

void CResFile::DumpLayoutElement()
{
	TCHAR szBuffer[1024];
	Write(TEXT("\t\t\t<LAYOUT>"));
	Write(TEXT("\t\t\t\t<XYLAYOUT ANNOTATE=\"NO\">"));
	    //
	    // Now we dump the style object too.
	    //
	    wsprintf(szBuffer,TEXT("\t\t\t\t<STYLE FONT-FAMILY=\"%s\" FONT-SIZE=\"%d\" /> \r\n"),
		    GetFont(), GetFontSize() );
	    Write(szBuffer);
	Write(TEXT("\t\t\t\t</XYLAYOUT>\r\n"));

	Write(TEXT("\t\t\t</LAYOUT>\r\n"));
}

#undef PROPERTY
#define PROPERTY(p,id, def) if( ((dwRemainingStyles & p)==p) != def ) { wsprintf(szBuffer, TEXT("%s=\"%s\" "), id, (dwRemainingStyles & p)?TEXT("YES"):TEXT("NO") ); m_pWin32->AllocAddAttribute(szBuffer, 0); }
#define DLGSTYLE(p,id, member, def) if( ((dwRemainingStyles & p)==p) != def ) { wsprintf(szBuffer, TEXT("%s=\"%s\" "), id, (dwRemainingStyles & p)?TEXT("YES"):TEXT("NO") ); m_pWin32->AllocAddAttribute(szBuffer, 0); }

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// These are very WIN32 specific styles.
//
void CResFile::DumpDialogStyles()
{
    if( GetWin32() == FALSE )
        return;

    if(m_pWin32==NULL)
        m_pWin32=new CDumpCache(m_hFile);

	TCHAR szBuffer[1024];
	DWORD dwRemainingStyles;

    dwRemainingStyles = GetStyle();

    PROPERTY( WS_POPUP           , TEXT("POPUP") ,             TRUE );     // POPUP
    PROPERTY( WS_CHILD           , TEXT("CHILD") ,             FALSE );
    PROPERTY( WS_MINIMIZE        , TEXT("MAXIMIZEBUTTON") ,    FALSE );
//    PROPERTY( WS_VISIBLE         , TEXT("VISIBLE") ,           TRUE );     // VISIBLE - CARE?

//    PROPERTY( WS_DISABLED        , TEXT("DISABLED") ,          FALSE );
    PROPERTY( WS_CLIPSIBLINGS    , TEXT("CLIPSIBLINGS") ,      FALSE );
    PROPERTY( WS_CLIPCHILDREN    , TEXT("CLIPCHILDREN") ,      FALSE );

    // WS_CAPTION is annoying, and in FormAndCaption stuff.
    // PROPERTY( WS_BORDER          , TEXT("BORDER") ,            TRUE );     // BORDER
    // PROPERTY( WS_DLGFRAME        , TEXT("DLGFRAME") ,          TRUE );     // DLGFRAME - close button.
    PROPERTY( WS_VSCROLL         , TEXT("VSCROLL") ,           FALSE );
    PROPERTY( WS_HSCROLL         , TEXT("HSCROLL") ,           FALSE );

    PROPERTY( WS_SYSMENU         , TEXT("SYSMENU"),            TRUE );     // most dialogs have this.
    PROPERTY( WS_THICKFRAME      , TEXT("THICKFRAME") ,        FALSE );
    // PROPERTY( WS_GROUP           , TEXT("GROUP") ,             FALSE );
    // PROPERTY( WS_TABSTOP         , TEXT("TABSTOP") ,           FALSE );

    // Dumped in FormAndCaption
    // PROPERTY( WS_MINIMIZEBOX     , TEXT("MINIMIZEBOX") ,       FALSE );
    // PROPERTY( WS_MAXIMIZEBOX     , TEXT("MAXIMIZEBOX") ,       FALSE );


    //
    // Extended styles
    //
    dwRemainingStyles = GetStyleEx();

    PROPERTY( WS_EX_DLGMODALFRAME     , TEXT("MODALFRAME"),    FALSE );      // Default.
    PROPERTY( WS_EX_NOPARENTNOTIFY    , TEXT("NOPARENTNOTIFY"),FALSE );
    PROPERTY( WS_EX_TOPMOST           , TEXT("TOPMOST"),       FALSE );

    PROPERTY( WS_EX_ACCEPTFILES       , TEXT("DROPTARGET"),    FALSE );
    PROPERTY( WS_EX_TRANSPARENT       , TEXT("TRANSPARENT"),   FALSE );
    PROPERTY( WS_EX_MDICHILD          , TEXT("MDI"),           FALSE );
    PROPERTY( WS_EX_TOOLWINDOW        , TEXT("TOOLWINDOW"),    FALSE );

    PROPERTY( WS_EX_WINDOWEDGE        , TEXT("WINDOWEDGE"),    FALSE );
    PROPERTY( WS_EX_CLIENTEDGE        , TEXT("CLIENTEDGE"),    FALSE );
    PROPERTY( WS_EX_CONTEXTHELP       , TEXT("CONTEXTHELP"),   FALSE );
    PROPERTY( WS_EX_RIGHT             , TEXT("RIGHT"),         FALSE );
    PROPERTY( WS_EX_RTLREADING        , TEXT("RTLREADING"),    FALSE );
    PROPERTY( WS_EX_LEFTSCROLLBAR     , TEXT("LEFTSCROLLBAR"), FALSE );

    PROPERTY( WS_EX_CONTROLPARENT     , TEXT("CONTROLPARENT"), FALSE );
    PROPERTY( WS_EX_STATICEDGE        , TEXT("STATICEDGE"),    FALSE );
    PROPERTY( WS_EX_APPWINDOW         , TEXT("APPWINDOW"),     FALSE );

    m_pWin32->WriteElement(TEXT("WIN32:STYLE") );

    delete m_pWin32;
    m_pWin32= new CDumpCache(m_hFile);

    //
    // Specific Dialog styles.
    //
    dwRemainingStyles = GetStyle();
    DLGSTYLE(  DS_ABSALIGN         , TEXT("ABSALIGN"),      m_AbsAlign,         FALSE );
    DLGSTYLE(  DS_SYSMODAL         , TEXT("SYSMODAL"),      m_SysModal,         FALSE );
    DLGSTYLE(  DS_LOCALEDIT        , TEXT("LOCALEDIT"),     m_LocalEdit,        FALSE );  // Local storage.

    DLGSTYLE(  DS_SETFONT          , TEXT("SETFONT"),       m_SetFont,          TRUE );  // User specified font for Dlg controls */
    DLGSTYLE(  DS_MODALFRAME       , TEXT("MODALFRAME"),    m_ModalFrame,       TRUE );  // Can be combined with WS_CAPTION  */
    DLGSTYLE(  DS_NOIDLEMSG        , TEXT("NOIDLEMSG"),     m_NoIdleMessgae,    FALSE );  // IDLE message will not be sent */
    DLGSTYLE(  DS_SETFOREGROUND    , TEXT("SETFOREGROUND"), m_SetForeground,    FALSE );  // not in win3.1 */

    DLGSTYLE(  DS_3DLOOK           , TEXT("DDDLOOK"),       m_3DLook,           FALSE );
    DLGSTYLE(  DS_FIXEDSYS         , TEXT("FIXEDSYS"),      m_FixedSys,         FALSE );
    DLGSTYLE(  DS_NOFAILCREATE     , TEXT("NOFAILCREATE"),  m_NoFailCreate,     FALSE );
    DLGSTYLE(  DS_CONTROL          , TEXT("CONTROL"),       m_Control,          FALSE );
    DLGSTYLE(  DS_CENTER           , TEXT("CENTER"),        m_Center,           FALSE );
    DLGSTYLE(  DS_CENTERMOUSE      , TEXT("CENTERMOUSE"),   m_CenterMouse,      FALSE );
    DLGSTYLE(  DS_CONTEXTHELP      , TEXT("CONTEXTHELP"),   m_ContextHelp,      FALSE );

    if( GetClass() )
    {
        if( HIWORD(GetClass()) )
        {
            if( lstrlen(GetClass()) )
            {
                wsprintf( szBuffer, TEXT("CLASS=\"%s\" "), GetClass() );
                m_pWin32->AllocAddAttribute(szBuffer);
            }
        }
        else
        {
            wsprintf( szBuffer, TEXT("CLASS=\"%d\" "), GetClass() );
            m_pWin32->AllocAddAttribute(szBuffer);
        }

    }

    if( GetMenu() )
    {
        if( HIWORD(GetMenu())  )
        {
            if( lstrlen(GetMenu()) )
            {
                wsprintf( szBuffer, TEXT("MENUID=\"%s\" "), GetMenu() );
                m_pWin32->AllocAddAttribute(szBuffer);
            }
        }
        else
        {
            wsprintf( szBuffer, TEXT("MENUID=\"%d\" "), GetMenu() );
            m_pWin32->AllocAddAttribute(szBuffer);
        }
    }

    m_pWin32->WriteElement(TEXT("WIN32:DIALOGSTYLE"));
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// The header for the XML files.
//
void CResFile::DumpProlog()
{
    switch( m_hFile.GetEncoding() )
    {
    case CFileEncoder::RF_UNICODE:
   	    Write(TEXT("<?xml version='1.0' encoding=\"UTF-16\" ?>") );
        break;

    case CFileEncoder::RF_UTF8:
   	    Write(TEXT("<?xml version='1.0' encoding=\"UTF-8\" ?>") );
        break;

    default:
   	    Write(TEXT("<?xml version='1.0' ?>") );
        break;
    }

   	Write(TEXT("<!-- XML Generated by RCMLGen (C) Microsoft Corp. 1999, 2000 -->") );
   	Write(TEXT("<RCML\txmlns=\"urn:schemas-microsoft-com:rcml\" "));
    if( GetEnhanced() )
       Write(TEXT("\txmlns:WIN32=\"urn:schemas-microsoft-com:rcml:win32\""));
    if( GetCicero() )
       Write(TEXT("\txmlns:CICERO=\"urn:schemas-microsoft-com:rcml:CICERO\""));
    Write(TEXT(">") );
   	Write(TEXT("\t<PLATFORM OS=\"WINDOWS\" />") );
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CResFile::DumpFormAndCaption()
{
	TCHAR szBuffer[1024];
   	Write(TEXT("\t<FORM "), FALSE );
	if( GetEnhanced() )
		Write(TEXT("RESIZE=\"Automatic\" "),FALSE);
   	Write(TEXT(">") );

	wsprintf(szBuffer,TEXT("\t\t<CAPTION TEXT=\"%s\" "), GetTitle() );
	Write(szBuffer, FALSE);
 	DWORD dwRemainingStyles;

    dwRemainingStyles = GetStyle();

    if( dwRemainingStyles & WS_MINIMIZEBOX )        // default FALSE
        Write( TEXT("MINIMIZEBOX=\"YES\" "), FALSE );

    if( dwRemainingStyles & WS_MAXIMIZEBOX )        // default FALSE
        Write( TEXT("MAXIMIZEBOX=\"YES\" "), FALSE );

    if( (dwRemainingStyles & WS_SYSMENU) == FALSE)  // default TRUE
        Write( TEXT("CLOSE=\"NO\" "), FALSE );

  	Write(TEXT("/>") );
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CResFile::DumpEpilog()
{
    if( GetEnhanced() )
   	    Write(TEXT("\t\t\t<STRINGTABLE />"));

	Write(TEXT("\t\t</PAGE>"));
	Write(TEXT("\t</FORM>"));
	Write(TEXT("</RCML>"));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CResFile::DumpTestInfo(LPTSTR pszFileName)
{
	//
	// Write out useful testing information.
	//
	TCHAR szBuffer[1024];
	LPTSTR pVersion;
	GetRCMLVersionNumber( GetModuleHandle( TEXT("RCML.dll")), &pVersion );
	wsprintf(szBuffer,TEXT("\t\t\t<TESTINFO FILE=\"%s\" GENERATORDATE=\"%s\" ENHANCED=\"%s\" RCMLVER=\"%s\" />"),
		pszFileName?pszFileName:TEXT("No File"), TEXT(__DATE__), GetEnhanced()?TEXT("YES"):TEXT("NO"), pVersion); 
	Write(szBuffer);
    delete pVersion;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CResFile::DumpPage()
{
	TCHAR szBuffer[1024];
  	Write(TEXT("\t\t<PAGE "), FALSE);
	wsprintf(szBuffer,TEXT(" WIDTH=\"%d\" HEIGHT=\"%d\" "), GetWidth(), GetHeight());
	Write(szBuffer, FALSE);

	Write(TEXT(">"));

}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
void CResFile::DumpMenu()
{
    if( GetWindow() == NULL )
        return;

    if( GetCicero() == FALSE )
        return;

   	Write(TEXT("\t\t<CICERO:COMMANDING xmlns=\"urn:schemas-microsoft-com:rcml:CICERO\">") );

    //
    // The accessible guys supposedly do this for HMENUs to, HOWEVER
    // they cannot provide me with the command ID that I should use to fake up the command
    //
    HMENU hMenu = ::GetMenu(GetWindow());
    if( hMenu != NULL )
        FindMenuItem(hMenu, NULL);

    //
    // This was for MSAA support. MSAA cannot enumerate the 
    // menus on an Explorer window - so PM's will just have to do those by hand?
    // This should work on the office applications though.
    //
    IAccessible * pA;
    HRESULT hr;
    CoInitialize(NULL);
    if( SUCCEEDED(hr=AccessibleObjectFromWindow( GetWindow(), 
        OBJID_WINDOW,   // works for office, information about the window itself, how many children it has.
        // OBJID_MENU , // the menu for the window, doesn't work for office.
        IID_IAccessible, (LPVOID*)&pA ) ))
    {
        FindMenuItem(pA, ROLE_SYSTEM_MENUITEM);
        // FindMenuItem(pA, ROLE_SYSTEM_PUSHBUTTON);   // for Coolbar menu items ... hmm...
        pA->Release();
    }
    CoUninitialize();

   	Write(TEXT("\t\t</CICERO:COMMANDING>") );
}

//
// 
//
void CResFile::FindMenuItem(IAccessible *pA, LONG role_code)
{
    long childCount;
    HRESULT hr;
    if( SUCCEEDED( hr= pA->get_accChildCount( &childCount )))
    {
        if( childCount>0 )
        {
            int i;
            VARIANT * childArray=new VARIANT[childCount];
            for(i=0;i<childCount;i++)
                VariantInit( &childArray[i]);

            //
            // Get the children
            //
            LONG obtained;
            hr=AccessibleChildren( pA, 0, childCount, childArray, &obtained );
            TRACE(TEXT("Got %d children our of %d from this control\n"),obtained, childCount);

            // Dump them out
            for(i=0;i<obtained;i++)
            {
                //
                // Get an Idispatch interface.
                //
                if( childArray[i].vt == VT_I4 )
                {
                    // hr=pA->get_accChild( childArray[i], &pDisp );
                    DumpAccessibleItem( pA, &childArray[i], role_code);
                }
                else
                if( childArray[i].vt == VT_DISPATCH )
                {
                    IDispatch * pDisp = childArray[i].pdispVal;
                    IAccessible * pDumpThis = NULL;
                    if( SUCCEEDED( pDisp->QueryInterface( IID_IAccessible, (LPVOID*)&pDumpThis) ))
                    {
                        if( pDumpThis )
                        {
                            VARIANT varDumpThis;
                            VariantInit(&varDumpThis);
                            varDumpThis.vt=VT_I4;
                            varDumpThis.lVal = CHILDID_SELF;

                            DumpAccessibleItem( pDumpThis, &varDumpThis, role_code );

                            VariantClear( &varDumpThis );

                            FindMenuItem(pDumpThis, role_code);      // recurse.

                            pDumpThis->Release();
                        }
                    }
                    // pDisp->Release();    // done in the VariantClear (I suspect).
                }
            }

            //
            // Cleanup - lets not bother. we released from the variant already.
            //
            for(int iDel=0;iDel<childCount;iDel++)
                hr = VariantClear( &childArray[iDel]);
            delete [] childArray;
        }
    }
}

void CResFile::FindMenuItem(HMENU hMenu, LONG nothing)
{
    int iMenuCount = GetMenuItemCount( hMenu );
    for(int i=0; i<iMenuCount;i++)
    {
        MENUITEMINFO mInfo;
        mInfo.cbSize = sizeof(MENUITEMINFO);
        mInfo.fMask = MIIM_SUBMENU | MIIM_ID;
        if( GetMenuItemInfo( hMenu, i, TRUE, &mInfo ) )
        {
            if( mInfo.hSubMenu )
            {
                TRACE(TEXT("Menu has a child menu of 0x%08x\n"), mInfo.hSubMenu);
                FindMenuItem(mInfo.hSubMenu, nothing);
            }
            else
            {
                // Parent menus can't be actioned upon, so don't dump them out.
                TCHAR menuText[MAX_PATH];
                if( GetMenuString( hMenu, i, menuText, sizeof(menuText), MF_BYPOSITION ) )
                {
                    if( GetCicero() )
                    {
                        LPWSTR text=CResControl::FindNiceText( menuText );
                        TRACE(TEXT("Menu item %s (was '%s') command %d\n"), 
                            text, menuText, mInfo.wID);
                        TCHAR szBuffer[1024];
                        wsprintf(szBuffer,
                            TEXT("\t\t\t<COMMAND TEXT=\"+%s\" ID=\"%u\"/>"), 
                            text, mInfo.wID );
                       	Write(szBuffer);
                        delete text;
                    }
                }
            }
        }
    }
}

//
//
//
void CResFile::DumpAccessibleItem( IAccessible * pDumpThis, VARIANT * pvarDumpThis, LONG role_code )
{

    VARIANT varRole;
    VariantInit(&varRole);

    HRESULT hr; 
    if( SUCCEEDED( hr = pDumpThis->get_accRole( *pvarDumpThis , &varRole ) ))
    {
        VARIANT varState;
        VariantInit(&varState);
        if( SUCCEEDED( hr = pDumpThis->get_accState( *pvarDumpThis , &varState ) ))
        {
#ifdef _DEBUG
            {
            BSTR bstrDesc=NULL;
            if( SUCCEEDED( hr=pDumpThis->get_accDescription( *pvarDumpThis, &bstrDesc)))
            {
                TRACE(TEXT("Debug : it's a '%s' "),bstrDesc);
            }
            BSTR bstrName;
            if( SUCCEEDED( hr=pDumpThis->get_accName( *pvarDumpThis, &bstrName)))
            {
                TRACE(TEXT("Debug called : %s "),bstrName);
            }
            TRACE(TEXT("its state is 0x%08x\n"), varState.lVal );
            SysFreeString( bstrDesc );
            SysFreeString( bstrName );
            }
#endif
            if( ( varState.lVal && ((varState.lVal & STATE_SYSTEM_INVISIBLE) == 0 )))
            {
                // TRACE(TEXT("varRole code 0x%08x, "), varRole.lVal);
                if( varRole.lVal == role_code  )
                {
                    BSTR bstrDesc=NULL;
                    if( SUCCEEDED( hr=pDumpThis->get_accDescription( *pvarDumpThis, &bstrDesc)))
                    {
                        TRACE(TEXT("it's a '%s' \n"),bstrDesc);
                    }
                    SysFreeString( bstrDesc );

                    BSTR bstrName=NULL;
        #if 0
                    if( SUCCEEDED( hr=pDumpThis->get_accName( *pvarDumpThis, &bstrName)))
                    {
                        TRACE(TEXT("*-*-* We have a menu item %s\n"),bstrName);
                        SysFreeString( bstrName );
                    }
        #endif
                    if( bstrDesc )
                    {
                        LPWSTR text=CResControl::FindNiceText( bstrDesc );
                        TRACE(TEXT("Accessible item %s (was '%s') command\n"), 
                            text, bstrName);
                        TCHAR szBuffer[1024];
                        wsprintf(szBuffer,
                            TEXT("\t\t\t<COMMAND TEXT=\"%s\"/>"), 
                            text);
                        Write(szBuffer);
                        delete text;
                    }
                }
            }
        }
    }
    VariantClear( &varRole );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlgen\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <shellapi.h>
#include <prsht.h>
#include <commctrl.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlgen\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resources.rc
//
#define IDS_ANSI                        1
#define IDS_UNICODE                     2
#define IDS_UTF8                        3
#define IDD_DIALOG1                     101
#define IDD_DIALOG2                     102
#define IDD_MIX                         102
#define IDD_FILEPICKER                  103
#define IDD_FILEPICKER_OLD              103
#define IDD_FILEPICKER2                 103
#define IDD_EDITS                       104
#define IDD_STATIC                      105
#define IDD_FILENDATE                   105
#define IDD_PIXELDIALOG                 106
#define IDD_PIXELDIALOG1                107
#define IDR_RCML1                       107
#define IDD_BUTTONS                     108
#define IDD_STATICS                     109
#define IDB_BITMAP1                     112
#define IDI_APPICON                     114
#define IDI_ICON1                       115
#define IDI_SPY                         116
#define IDC_SPY                         117
#define IDD_HELP                        120
#define IDC_RADIO1                      1000
#define IDC_RADIO2                      1001
#define IDC_RADIO3                      1002
#define IDC_CHECK1                      1003
#define IDC_EDIT1                       1004
#define IDC_RADIO4                      1004
#define IDC_FILE                        1005
#define IDC_CHECK2                      1005
#define IDC_EDIT6                       1005
#define IDC_COMBO1                      1006
#define IDC_RADIO5                      1006
#define IDC_LIST1                       1007
#define IDC_RADIO6                      1007
#define IDC_COMBO5                      1007
#define IDC_SPIN1                       1008
#define IDC_CHECK4                      1008
#define IDC_COMBO6                      1008
#define IDC_LIST7                       1008
#define IDC_PROGRESS1                   1009
#define IDC_CHECK5                      1009
#define IDC_COMBO7                      1009
#define IDC_SPIN2                       1009
#define IDC_LIST8                       1009
#define IDC_SLIDER1                     1010
#define IDC_CHECK6                      1010
#define IDC_SPIN3                       1010
#define IDC_PROGRESS2                   1010
#define IDC_LIST9                       1010
#define IDC_LIST2                       1011
#define IDC_CHECK7                      1011
#define IDC_COMBO8                      1011
#define IDC_SPIN4                       1011
#define IDC_PROGRESS3                   1011
#define IDC_CHECK3                      1012
#define IDC_ENHANCED                    1012
#define IDC_CHECK8                      1012
#define IDC_COMBO10                     1012
#define IDC_LIST3                       1012
#define IDC_SPIN5                       1012
#define IDC_EDIT2                       1013
#define IDC_LIST4                       1013
#define IDC_WIN32                       1013
#define IDC_EDIT3                       1014
#define IDC_BUTTON1                     1014
#define IDC_LIST5                       1014
#define IDC_RELATIVE                    1014
#define IDC_EDIT4                       1015
#define IDC_BUTTON2                     1015
#define IDC_LIST6                       1015
#define IDC_VOICEENABLE                 1015
#define IDC_EDIT5                       1016
#define IDC_BUTTON3                     1016
#define IDC_BUTTON4                     1017
#define IDC_EDIT7                       1017
#define IDC_COMBO2                      1017
#define IDC_BUTTON5                     1018
#define IDC_EDIT8                       1018
#define IDC_COMBO3                      1018
#define IDC_SPIN6                       1018
#define IDC_EDIT9                       1019
#define IDC_COMBO4                      1019
#define IDC_EDIT10                      1020
#define IDC_COMBO9                      1020
#define IDC_SPIN7                       1020
#define IDC_EDIT11                      1021
#define IDC_EDIT13                      1022
#define IDC_ENCODING                    1022
#define IDC_SPIN8                       1022
#define IDC_EDIT12                      1023
#define IDC_TREE1                       1023
#define IDC_EDIT14                      1024
#define IDC_SLIDER2                     1024
#define IDC_SLIDER3                     1025
#define IDC_SLIDER4                     1026
#define IDC_SLIDER5                     1027
#define IDC_SCROLLBAR1                  1028
#define IDC_SCROLLBAR2                  1029
#define IDC_SCROLLBAR3                  1030
#define IDC_PROGRESS4                   1031
#define IDC_TAB1                        1032
#define IDC_TREE2                       1033
#define IDC_TAB2                        1033
#define IDC_TREE3                       1034
#define IDC_TAB3                        1034
#define IDC_ANIMATE1                    1034
#define IDC_TREE4                       1035
#define IDC_TAB4                        1035
#define IDC_BUTTON6                     1035
#define IDC_TREE5                       1036
#define IDC_TAB5                        1036
#define IDC_TREE6                       1037
#define IDC_TREE7                       1038
#define IDC_TAB7                        1038

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        121
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1036
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\xmllib\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	xmllib.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\xmllib\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__F201A301_5B4C_4D8C_A1D4_BDA74FFE53E0__INCLUDED_)
#define AFX_STDAFX_H__F201A301_5B4C_4D8C_A1D4_BDA74FFE53E0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
// #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <tchar.h>
#include <malloc.h>

// #include <crtdbg.h>
#pragma intrinsic( memcpy, memset, memcmp)

// #include <afxole.h>

// TODO: reference additional headers your program requires here

#include "commctrl.h"
// #include "debug.h"

#pragma warning( disable : 4273 )
#include "core/base/_reference.hxx"
#include "xml/tokenizer/parser/unknown.hxx"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F201A301_5B4C_4D8C_A1D4_BDA74FFE53E0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\xmllib\core\base\_reference.cxx ===
/*
 * @(#)_reference.cxx 1.0 6/3/97
 * 
* Copyright (c) 1997 - 1999 Microsoft Corporation. All rights reserved. * 
 */

#include "stdafx.h"
// #include "core.hxx"
#pragma hdrstop

void _assign(IUnknown ** ppref, IUnknown * pref)
{
    IUnknown *punkRef = *ppref;
    if (pref) ((IUnknown *)pref)->AddRef();
    (*ppref) = (IUnknown *)pref; 
    if (punkRef) punkRef->Release();
}    

void _release(IUnknown ** ppref)
{
    if (*ppref) 
    {
        (*ppref)->Release();
        *ppref = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\xmllib\core\util\chartype.cxx ===
/*
 * @(#)CharType.cxx 1.0 6/15/98
 * 
 * Character type constants and functions
 *
*  Copyright (C) 1998,1999 Microsoft Corporation. All rights reserved. * 
 */

int g_anCharType[TABLE_SIZE] = { 
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0 | FWHITESPACE | FCHARDATA,
    0 | FWHITESPACE | FCHARDATA,
    0,
    0,
    0 | FWHITESPACE | FCHARDATA,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0 | FWHITESPACE | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FMISCNAME | FCHARDATA,
    0 | FMISCNAME | FCHARDATA,
    0 | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FSTARTNAME | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FMISCNAME | FSTARTNAME | FCHARDATA,
    0 | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
};

const WCHAR * ParseName(const WCHAR *pwc, ULONG * pul)
{
    WCHAR ch;
    Assert(pwc);
    // we don't allow a colon at the beginning

    if ((ch = *pwc) && isStartNameChar(ch))
    {
        pwc = ParseNameToken(pwc, pul);
    }
    else
    {
        *pul = 0;
    }

    return pwc;
}

const WCHAR * ParseNameToken(const WCHAR *pwc, ULONG * pul)
{
    WCHAR ch;
    Assert(pwc);
    const WCHAR * pwcStart = pwc;
    const WCHAR * pwcColon = null;

    *pul = 0;

    if (*pwc == ':')
    {
        return pwc;
    }

    while((ch = *pwc) != 0 && isNameChar(ch))
    {
        if (ch == ':')
        {
            if (pwcColon)
                break;

            pwcColon = pwc;
        }

        pwc++;
    }

    // don't allow 0 length names

    if (pwcColon)
    {
        if (pwc - pwcColon == 1)
        {
            pwc = pwcColon;
        }
        else
        {
            *pul = (ULONG)(pwcColon - pwcStart);
        }
    }

    return pwc;
}


bool isValidName(const WCHAR *pwc, ULONG * pnColonPos)
{
    const WCHAR * pwchNext = ParseName(pwc, pnColonPos);

    if (*pwchNext || pwchNext == pwc)
    {
        return false;
    }

    return true;
}


//
// LanguageID ::= (IANACode || UserCode || ISO639) ('-' SubCode)*
// ISO639 ::= ([a-z] | [A-Z])([a-z] | [A-Z])
// IANACode ::= ('i' | 'I') '-' ([a-z] | [A-Z])+
// UserCode ::= ('x' | 'X') '-' ([a-z] | [A-Z])+
// SubCode :;= ([a-z] | [A-Z])+
//
bool
isValidLanguageID(const WCHAR * pwcText, ULONG ulLen)
{
    WCHAR ch;
    bool fSeenLetter = false;

    if (ulLen < 2)
        goto Error;

    ch = *pwcText;
    if (isLetter(ch))
    {
        if (isLetter(*(++pwcText))) // ISO639 Code: a two-letter language code as defined by ISO 639
        {
            if (2 == ulLen)
                return true;
            ulLen--;
            pwcText++;
        }
        else if ('I' != ch && 'i' != ch && //IANA Code
                 'X' != ch && 'x' != ch)    // User Code
        {
            goto Error;
        }

        if ('-' != *pwcText)
            goto Error;
        ulLen -= 2;

        while (ulLen-- > 0)
        {
            ch = *(++pwcText);
            if (isLetter(ch))
            {
                fSeenLetter = true;
            }
            else if ('-' == ch && fSeenLetter)
            {
                fSeenLetter = false;
            }
            else
            {
                goto Error;
            }
        }

        if (fSeenLetter)
            return true;
    }

Error:
    return false;
}


bool 
isValidPublicID(const WCHAR * pwcText, ULONG ulLen)
{
    // length of 0 is OK
    while (ulLen-- > 0)
    {
        if (!isPubidChar(*pwcText++))
            return false;
    }
    return true;
}

//==============================================================================
WCHAR BuiltinEntity(const WCHAR* text, ULONG len)
{
    ULONG ulength =  len * sizeof(WCHAR); // Length in chars
    switch (len)
    {
    case 4:
        if (::memcmp(L"quot", text, ulength) == 0)
        {
            return 34;
        }
        else if (::memcmp(L"apos", text, ulength) == 0)
        {
            return 39;
        }
        break;
    case 3:
        if (::memcmp(L"amp", text, ulength) == 0)
        {
            return 38;
        }
        break;
    case 2:
        if (::memcmp(L"lt", text, ulength) == 0)
        {
            return 60;
        }
        else if (::memcmp(L"gt", text, ulength) == 0)
        {
            return 62;
        }
        break;
    }
    return 0;
}

// BUGBUG -- need a better ifdef than this.
#ifdef UNIX
const ULONG MAXWCHAR = 0xFFFFFFFF;
#else
const ULONG MAXWCHAR = 0xFFFF;
#endif

//==============================================================================
HRESULT HexToUnicode(const WCHAR* text, ULONG len, WCHAR& ch)
{
    ULONG result = 0;
    for (ULONG i = 0; i < len; i++)
    {
        ULONG digit = 0;
        if (text[i] >= L'a' && text[i] <= L'f')
        {
            digit = 10 + (text[i] - L'a');
        }
        else if (text[i] >= L'A' && text[i] <= L'F')
        {
            digit = 10 + (text[i] - L'A');
        }
        else if (text[i] >= L'0' && text[i] <= L'9')
        {
            digit = (text[i] - L'0');
        }
        else
            return XML_E_INVALID_HEXIDECIMAL;

        // Last unicode value (MAXWCHAR) is reserved as "invalid value"
        if (result >= (MAXWCHAR - digit)/16)       // result is about to overflow
            return XML_E_INVALID_UNICODE;  // the maximum 4 byte value.

        result = (result*16) + digit;
    }
    if (result == 0)    // zero is also invalid.
        return XML_E_INVALID_UNICODE;
    ch = (WCHAR)result;
    return S_OK;
}

//==============================================================================
HRESULT DecimalToUnicode(const WCHAR* text, ULONG len, WCHAR& ch)
{
    ULONG result = 0;
    for (ULONG i = 0; i < len; i++)
    {
        ULONG digit = 0;
        if (text[i] >= L'0' && text[i] <= L'9')
        {
            digit = (text[i] - L'0');
        }
        else
            return XML_E_INVALID_DECIMAL;

        // Last unicode value (MAXWCHAR) is reserved as "invalid value"
        if (result >= (MAXWCHAR - digit) /10)       // result is about to overflow
            return XML_E_INVALID_UNICODE;          // the maximum 4 byte value.

        result = (result*10) + digit;
    }
    if (result == 0)    // zero is also invalid.
        return XML_E_INVALID_UNICODE;

    ch = (WCHAR)result;
    return S_OK;
}


#ifdef UNIX
    const unsigned char s_ByteOrderMarkTrident[sizeof(WCHAR)] = { 0xFF, 0xFE, 0xFF, 0xFE };
    const unsigned char s_ByteOrderMark[sizeof(WCHAR)] = { 0xFE, 0xFF, 0xFE, 0xFF };
    const unsigned char s_ByteOrderMarkUCS2[2] = { 0xFF, 0xFE };
#else
    const unsigned char s_ByteOrderMark[2] = { 0xFF, 0xFE };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\xmllib\core\util\_rawstack.cxx ===
/*
 * @(#)_rawstack.cxx 1.0 3/30/98
 * 
*  Copyright (C) 1998,1999 Microsoft Corporation. All rights reserved. * 
 */
#include "stdafx.h"
#define     checkhr
#define new_ne new

#pragma hdrstop

#include "_rawstack.hxx"

//===========================================================================
RawStack::RawStack(long entrySize, long growth)
{
    _lEntrySize = entrySize;
    _pStack = NULL;
    _ncUsed = _ncSize = 0;
    _lGrowth = growth;
}
 
RawStack::~RawStack()
{
    delete _pStack;
}

char* 
RawStack::__push()
{
    // No magic object construction -- user has to do this.
    char* newStack = new_ne char[_lEntrySize * ( _ncSize + _lGrowth) ];
    if (newStack == NULL)
    {
        return NULL;
    }
    ::memset(newStack, 0, _lEntrySize * (_ncSize + _lGrowth));
    if (_ncUsed > 0)
    {
        ::memcpy(newStack, _pStack, _lEntrySize * _ncUsed);
    }
    _ncSize += _lGrowth;
    delete _pStack;
    _pStack = newStack;

    return &_pStack[_lEntrySize * _ncUsed++];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\xmllib\xml\tokenizer\encoder\codepage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
// Copyright (c) 1994 - 1999 Microsoft Corporation. All rights reserved.*///
//  File:       intl.hxx
//
//  Contents:   Codepage definitions
//
//----------------------------------------------------------------------------

#ifndef _CODEPAGE_H_
#define _CODEPAGE_H_

typedef UINT CODEPAGE;              // Codepage corresponds to Mlang ID

#define CP_UNDEFINED    CODEPAGE(-1)
#define CP_UCS_2        1200
#define CP_1250         1250
#define CP_1251         1251
#define CP_1252         1252
#define CP_1253         1253
#define CP_1254         1254
#define CP_1255         1255
#define CP_1256         1256
#define CP_1257         1257
#define CP_1258         1258

#define CP_UTF_8        65001
#define CP_UCS_4        12000

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\xmllib\xml\tokenizer\parser\xmlparser.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0205 */
/* at Thu Oct 22 17:08:10 1998
 */
/* Compiler settings for xmlparser.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __xmlparser_h__
#define __xmlparser_h__

/* Forward Declarations */ 

#ifndef __IXMLNodeSource_FWD_DEFINED__
#define __IXMLNodeSource_FWD_DEFINED__
typedef interface IXMLNodeSource IXMLNodeSource;
#endif 	/* __IXMLNodeSource_FWD_DEFINED__ */


#ifndef __IXMLParser_FWD_DEFINED__
#define __IXMLParser_FWD_DEFINED__
typedef interface IXMLParser IXMLParser;
#endif 	/* __IXMLParser_FWD_DEFINED__ */


#ifndef __IXMLNodeFactory_FWD_DEFINED__
#define __IXMLNodeFactory_FWD_DEFINED__
typedef interface IXMLNodeFactory IXMLNodeFactory;
#endif 	/* __IXMLNodeFactory_FWD_DEFINED__ */


#ifndef __XMLParser_FWD_DEFINED__
#define __XMLParser_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLParser XMLParser;
#else
typedef struct XMLParser XMLParser;
#endif /* __cplusplus */

#endif 	/* __XMLParser_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_xmlparser_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//--------------------------------------------------------------------------




typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0001
    {	XML_ELEMENT	= 1,
	XML_ATTRIBUTE	= XML_ELEMENT + 1,
	XML_PI	= XML_ATTRIBUTE + 1,
	XML_XMLDECL	= XML_PI + 1,
	XML_DOCTYPE	= XML_XMLDECL + 1,
	XML_DTDATTRIBUTE	= XML_DOCTYPE + 1,
	XML_ENTITYDECL	= XML_DTDATTRIBUTE + 1,
	XML_ELEMENTDECL	= XML_ENTITYDECL + 1,
	XML_ATTLISTDECL	= XML_ELEMENTDECL + 1,
	XML_NOTATION	= XML_ATTLISTDECL + 1,
	XML_GROUP	= XML_NOTATION + 1,
	XML_INCLUDESECT	= XML_GROUP + 1,
	XML_PCDATA	= XML_INCLUDESECT + 1,
	XML_CDATA	= XML_PCDATA + 1,
	XML_IGNORESECT	= XML_CDATA + 1,
	XML_COMMENT	= XML_IGNORESECT + 1,
	XML_ENTITYREF	= XML_COMMENT + 1,
	XML_WHITESPACE	= XML_ENTITYREF + 1,
	XML_NAME	= XML_WHITESPACE + 1,
	XML_NMTOKEN	= XML_NAME + 1,
	XML_STRING	= XML_NMTOKEN + 1,
	XML_PEREF	= XML_STRING + 1,
	XML_MODEL	= XML_PEREF + 1,
	XML_ATTDEF	= XML_MODEL + 1,
	XML_ATTTYPE	= XML_ATTDEF + 1,
	XML_ATTPRESENCE	= XML_ATTTYPE + 1,
	XML_DTDSUBSET	= XML_ATTPRESENCE + 1,
	XML_LASTNODETYPE	= XML_DTDSUBSET + 1
    }	XML_NODE_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0002
    {	XML_VERSION	= XML_LASTNODETYPE,
	XML_ENCODING	= XML_VERSION + 1,
	XML_STANDALONE	= XML_ENCODING + 1,
	XML_NS	= XML_STANDALONE + 1,
	XML_XMLSPACE	= XML_NS + 1,
	XML_XMLLANG	= XML_XMLSPACE + 1,
	XML_SYSTEM	= XML_XMLLANG + 1,
	XML_PUBLIC	= XML_SYSTEM + 1,
	XML_NDATA	= XML_PUBLIC + 1,
	XML_AT_CDATA	= XML_NDATA + 1,
	XML_AT_ID	= XML_AT_CDATA + 1,
	XML_AT_IDREF	= XML_AT_ID + 1,
	XML_AT_IDREFS	= XML_AT_IDREF + 1,
	XML_AT_ENTITY	= XML_AT_IDREFS + 1,
	XML_AT_ENTITIES	= XML_AT_ENTITY + 1,
	XML_AT_NMTOKEN	= XML_AT_ENTITIES + 1,
	XML_AT_NMTOKENS	= XML_AT_NMTOKEN + 1,
	XML_AT_NOTATION	= XML_AT_NMTOKENS + 1,
	XML_AT_REQUIRED	= XML_AT_NOTATION + 1,
	XML_AT_IMPLIED	= XML_AT_REQUIRED + 1,
	XML_AT_FIXED	= XML_AT_IMPLIED + 1,
	XML_PENTITYDECL	= XML_AT_FIXED + 1,
	XML_EMPTY	= XML_PENTITYDECL + 1,
	XML_ANY	= XML_EMPTY + 1,
	XML_MIXED	= XML_ANY + 1,
	XML_SEQUENCE	= XML_MIXED + 1,
	XML_CHOICE	= XML_SEQUENCE + 1,
	XML_STAR	= XML_CHOICE + 1,
	XML_PLUS	= XML_STAR + 1,
	XML_QUESTIONMARK	= XML_PLUS + 1,
	XML_LASTSUBNODETYPE	= XML_QUESTIONMARK + 1
    }	XML_NODE_SUBTYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0003
    {	XML_E_PARSEERRORBASE	= 0xc00ce500L,
	XML_E_ENDOFINPUT	= XML_E_PARSEERRORBASE,
	XML_E_MISSINGEQUALS	= XML_E_ENDOFINPUT + 1,
	XML_E_MISSINGQUOTE	= XML_E_MISSINGEQUALS + 1,
	XML_E_COMMENTSYNTAX	= XML_E_MISSINGQUOTE + 1,
	XML_E_BADSTARTNAMECHAR	= XML_E_COMMENTSYNTAX + 1,
	XML_E_BADNAMECHAR	= XML_E_BADSTARTNAMECHAR + 1,
	XML_E_BADCHARINSTRING	= XML_E_BADNAMECHAR + 1,
	XML_E_XMLDECLSYNTAX	= XML_E_BADCHARINSTRING + 1,
	XML_E_BADCHARDATA	= XML_E_XMLDECLSYNTAX + 1,
	XML_E_MISSINGWHITESPACE	= XML_E_BADCHARDATA + 1,
	XML_E_EXPECTINGTAGEND	= XML_E_MISSINGWHITESPACE + 1,
	XML_E_BADCHARINDTD	= XML_E_EXPECTINGTAGEND + 1,
	XML_E_BADCHARINDECL	= XML_E_BADCHARINDTD + 1,
	XML_E_MISSINGSEMICOLON	= XML_E_BADCHARINDECL + 1,
	XML_E_BADCHARINENTREF	= XML_E_MISSINGSEMICOLON + 1,
	XML_E_UNBALANCEDPAREN	= XML_E_BADCHARINENTREF + 1,
	XML_E_EXPECTINGOPENBRACKET	= XML_E_UNBALANCEDPAREN + 1,
	XML_E_BADENDCONDSECT	= XML_E_EXPECTINGOPENBRACKET + 1,
	XML_E_INTERNALERROR	= XML_E_BADENDCONDSECT + 1,
	XML_E_UNEXPECTED_WHITESPACE	= XML_E_INTERNALERROR + 1,
	XML_E_INCOMPLETE_ENCODING	= XML_E_UNEXPECTED_WHITESPACE + 1,
	XML_E_BADCHARINMIXEDMODEL	= XML_E_INCOMPLETE_ENCODING + 1,
	XML_E_MISSING_STAR	= XML_E_BADCHARINMIXEDMODEL + 1,
	XML_E_BADCHARINMODEL	= XML_E_MISSING_STAR + 1,
	XML_E_MISSING_PAREN	= XML_E_BADCHARINMODEL + 1,
	XML_E_BADCHARINENUMERATION	= XML_E_MISSING_PAREN + 1,
	XML_E_PIDECLSYNTAX	= XML_E_BADCHARINENUMERATION + 1,
	XML_E_EXPECTINGCLOSEQUOTE	= XML_E_PIDECLSYNTAX + 1,
	XML_E_MULTIPLE_COLONS	= XML_E_EXPECTINGCLOSEQUOTE + 1,
	XML_E_INVALID_DECIMAL	= XML_E_MULTIPLE_COLONS + 1,
	XML_E_INVALID_HEXIDECIMAL	= XML_E_INVALID_DECIMAL + 1,
	XML_E_INVALID_UNICODE	= XML_E_INVALID_HEXIDECIMAL + 1,
	XML_E_TOKEN_ERROR	= XML_E_PARSEERRORBASE + 0x50,
	XML_E_SUSPENDED	= XML_E_TOKEN_ERROR,
	XML_E_STOPPED	= XML_E_SUSPENDED + 1,
	XML_E_UNEXPECTEDENDTAG	= XML_E_STOPPED + 1,
	XML_E_UNCLOSEDTAG	= XML_E_UNEXPECTEDENDTAG + 1,
	XML_E_DUPLICATEATTRIBUTE	= XML_E_UNCLOSEDTAG + 1,
	XML_E_MULTIPLEROOTS	= XML_E_DUPLICATEATTRIBUTE + 1,
	XML_E_INVALIDATROOTLEVEL	= XML_E_MULTIPLEROOTS + 1,
	XML_E_BADXMLDECL	= XML_E_INVALIDATROOTLEVEL + 1,
	XML_E_MISSINGROOT	= XML_E_BADXMLDECL + 1,
	XML_E_UNEXPECTEDEOF	= XML_E_MISSINGROOT + 1,
	XML_E_BADPEREFINSUBSET	= XML_E_UNEXPECTEDEOF + 1,
	XML_E_PE_NESTING	= XML_E_BADPEREFINSUBSET + 1,
	XML_E_INVALID_CDATACLOSINGTAG	= XML_E_PE_NESTING + 1,
	XML_E_UNCLOSEDPI	= XML_E_INVALID_CDATACLOSINGTAG + 1,
	XML_E_UNCLOSEDSTARTTAG	= XML_E_UNCLOSEDPI + 1,
	XML_E_UNCLOSEDENDTAG	= XML_E_UNCLOSEDSTARTTAG + 1,
	XML_E_UNCLOSEDSTRING	= XML_E_UNCLOSEDENDTAG + 1,
	XML_E_UNCLOSEDCOMMENT	= XML_E_UNCLOSEDSTRING + 1,
	XML_E_UNCLOSEDDECL	= XML_E_UNCLOSEDCOMMENT + 1,
	XML_E_UNCLOSEDMARKUPDECL	= XML_E_UNCLOSEDDECL + 1,
	XML_E_UNCLOSEDCDATA	= XML_E_UNCLOSEDMARKUPDECL + 1,
	XML_E_BADDECLNAME	= XML_E_UNCLOSEDCDATA + 1,
	XML_E_BADEXTERNALID	= XML_E_BADDECLNAME + 1,
	XML_E_BADELEMENTINDTD	= XML_E_BADEXTERNALID + 1,
	XML_E_RESERVEDNAMESPACE	= XML_E_BADELEMENTINDTD + 1,
	XML_E_EXPECTING_VERSION	= XML_E_RESERVEDNAMESPACE + 1,
	XML_E_EXPECTING_ENCODING	= XML_E_EXPECTING_VERSION + 1,
	XML_E_EXPECTING_NAME	= XML_E_EXPECTING_ENCODING + 1,
	XML_E_UNEXPECTED_ATTRIBUTE	= XML_E_EXPECTING_NAME + 1,
	XML_E_ENDTAGMISMATCH	= XML_E_UNEXPECTED_ATTRIBUTE + 1,
	XML_E_INVALIDENCODING	= XML_E_ENDTAGMISMATCH + 1,
	XML_E_INVALIDSWITCH	= XML_E_INVALIDENCODING + 1,
	XML_E_EXPECTING_NDATA	= XML_E_INVALIDSWITCH + 1,
	XML_E_INVALID_MODEL	= XML_E_EXPECTING_NDATA + 1,
	XML_E_INVALID_TYPE	= XML_E_INVALID_MODEL + 1,
	XML_E_INVALIDXMLSPACE	= XML_E_INVALID_TYPE + 1,
	XML_E_MULTI_ATTR_VALUE	= XML_E_INVALIDXMLSPACE + 1,
	XML_E_INVALID_PRESENCE	= XML_E_MULTI_ATTR_VALUE + 1,
	XML_E_BADXMLCASE	= XML_E_INVALID_PRESENCE + 1,
	XML_E_CONDSECTINSUBSET	= XML_E_BADXMLCASE + 1,
	XML_E_CDATAINVALID	= XML_E_CONDSECTINSUBSET + 1,
	XML_E_INVALID_STANDALONE	= XML_E_CDATAINVALID + 1,
	XML_E_UNEXPECTED_STANDALONE	= XML_E_INVALID_STANDALONE + 1,
	XML_E_DOCTYPE_IN_DTD	= XML_E_UNEXPECTED_STANDALONE + 1,
	XML_E_MISSING_ENTITY	= XML_E_DOCTYPE_IN_DTD + 1,
	XML_E_ENTITYREF_INNAME	= XML_E_MISSING_ENTITY + 1,
	XML_E_DOCTYPE_OUTSIDE_PROLOG	= XML_E_ENTITYREF_INNAME + 1,
	XML_E_INVALID_VERSION	= XML_E_DOCTYPE_OUTSIDE_PROLOG + 1,
	XML_E_DTDELEMENT_OUTSIDE_DTD	= XML_E_INVALID_VERSION + 1,
	XML_E_DUPLICATEDOCTYPE	= XML_E_DTDELEMENT_OUTSIDE_DTD + 1,
	XML_E_RESOURCE	= XML_E_DUPLICATEDOCTYPE + 1,
	XML_E_LASTERROR	= XML_E_RESOURCE + 1
    }	XML_ERROR_CODE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0004
    {	XMLPARSER_IDLE	= 0,
	XMLPARSER_WAITING	= XMLPARSER_IDLE + 1,
	XMLPARSER_BUSY	= XMLPARSER_WAITING + 1,
	XMLPARSER_ERROR	= XMLPARSER_BUSY + 1,
	XMLPARSER_STOPPED	= XMLPARSER_ERROR + 1,
	XMLPARSER_SUSPENDED	= XMLPARSER_STOPPED + 1
    }	XML_PARSER_STATE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0005
    {	XMLFLAG_FLOATINGAMP	= 1,
	XMLFLAG_SHORTENDTAGS	= 2,
	XMLFLAG_CASEINSENSITIVE	= 4,
	XMLFLAG_NONAMESPACES	= 8,
	XMLFLAG_NOWHITESPACE	= 16,
	XMLFLAG_IE4QUIRKS	= 32,
	XMLFLAG_NODTDNODES	= 64,
	XMLFLAG_IE4COMPATIBILITY	= 255
    }	XML_PARSER_FLAGS;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0006
    {	XMLNF_STARTDOCUMENT	= 0,
	XMLNF_STARTDTD	= XMLNF_STARTDOCUMENT + 1,
	XMLNF_ENDDTD	= XMLNF_STARTDTD + 1,
	XMLNF_STARTDTDSUBSET	= XMLNF_ENDDTD + 1,
	XMLNF_ENDDTDSUBSET	= XMLNF_STARTDTDSUBSET + 1,
	XMLNF_ENDPROLOG	= XMLNF_ENDDTDSUBSET + 1,
	XMLNF_STARTENTITY	= XMLNF_ENDPROLOG + 1,
	XMLNF_ENDENTITY	= XMLNF_STARTENTITY + 1,
	XMLNF_ENDDOCUMENT	= XMLNF_ENDENTITY + 1,
	XMLNF_DATAAVAILABLE	= XMLNF_ENDDOCUMENT + 1
    }	XML_NODEFACTORY_EVENT;

typedef struct  _XML_NODE_INFO
    {
    DWORD dwSize;
    DWORD dwType;
    DWORD dwSubType;
    BOOL fTerminal;
    const WCHAR __RPC_FAR *pwcText;
    ULONG ulLen;
    ULONG ulNsPrefixLen;
    PVOID pNode;
    PVOID pReserved;
    }	XML_NODE_INFO;



extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_v0_0_s_ifspec;


#ifndef __XMLPSR_LIBRARY_DEFINED__
#define __XMLPSR_LIBRARY_DEFINED__

/* library XMLPSR */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_XMLPSR;

#ifndef __IXMLNodeSource_INTERFACE_DEFINED__
#define __IXMLNodeSource_INTERFACE_DEFINED__

/* interface IXMLNodeSource */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361d-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFactory( 
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFactory( 
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ BSTR bstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLineNumber( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLinePosition( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetAbsolutePosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLineBuffer( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastError( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetFlags( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetURL( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFactory )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFactory )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLineNumber )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLinePosition )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetAbsolutePosition )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineBuffer )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastError )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetURL )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        END_INTERFACE
    } IXMLNodeSourceVtbl;

    interface IXMLNodeSource
    {
        CONST_VTBL struct IXMLNodeSourceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLNodeSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLNodeSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLNodeSource_SetFactory(This,pNodeFactory)	\
    (This)->lpVtbl -> SetFactory(This,pNodeFactory)

#define IXMLNodeSource_GetFactory(This,ppNodeFactory)	\
    (This)->lpVtbl -> GetFactory(This,ppNodeFactory)

#define IXMLNodeSource_Abort(This,bstrErrorInfo)	\
    (This)->lpVtbl -> Abort(This,bstrErrorInfo)

#define IXMLNodeSource_GetLineNumber(This)	\
    (This)->lpVtbl -> GetLineNumber(This)

#define IXMLNodeSource_GetLinePosition(This)	\
    (This)->lpVtbl -> GetLinePosition(This)

#define IXMLNodeSource_GetAbsolutePosition(This)	\
    (This)->lpVtbl -> GetAbsolutePosition(This)

#define IXMLNodeSource_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)

#define IXMLNodeSource_GetLastError(This)	\
    (This)->lpVtbl -> GetLastError(This)

#define IXMLNodeSource_GetErrorInfo(This,pbstrErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo)

#define IXMLNodeSource_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IXMLNodeSource_GetURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetURL(This,ppwcBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLNodeSource_SetFactory_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);


void __RPC_STUB IXMLNodeSource_SetFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetFactory_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);


void __RPC_STUB IXMLNodeSource_GetFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_Abort_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [in] */ BSTR bstrErrorInfo);


void __RPC_STUB IXMLNodeSource_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetLineNumber_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetLinePosition_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLinePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetAbsolutePosition_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetAbsolutePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetLineBuffer_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
    /* [out] */ ULONG __RPC_FAR *pulLen,
    /* [out] */ ULONG __RPC_FAR *pulStartPos);


void __RPC_STUB IXMLNodeSource_GetLineBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetLastError_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLastError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetErrorInfo_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);


void __RPC_STUB IXMLNodeSource_GetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetFlags_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetURL_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);


void __RPC_STUB IXMLNodeSource_GetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLNodeSource_INTERFACE_DEFINED__ */


#ifndef __IXMLParser_INTERFACE_DEFINED__
#define __IXMLParser_INTERFACE_DEFINED__

/* interface IXMLParser */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361e-51a0-11d2-9caf-0060b0ec3d39")
    IXMLParser : public IXMLNodeSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetURL( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInput( 
            /* [in] */ IUnknown __RPC_FAR *pStm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PushData( 
            /* [in] */ const char __RPC_FAR *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadDTD( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExpandEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRoot( 
            /* [in] */ PVOID pRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRoot( 
            /* [in] */ PVOID __RPC_FAR *ppRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( 
            /* [in] */ long lChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParserState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG iFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSecureBaseURL( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecureBaseURL( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFactory )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFactory )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLineNumber )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLinePosition )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetAbsolutePosition )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineBuffer )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastError )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetURL )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetURL )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInput )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pStm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PushData )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const char __RPC_FAR *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadDTD )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExpandEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRoot )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ PVOID pRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRoot )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ PVOID __RPC_FAR *ppRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Run )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ long lChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParserState )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Suspend )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFlags )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ ULONG iFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSecureBaseURL )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSecureBaseURL )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        END_INTERFACE
    } IXMLParserVtbl;

    interface IXMLParser
    {
        CONST_VTBL struct IXMLParserVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLParser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLParser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLParser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLParser_SetFactory(This,pNodeFactory)	\
    (This)->lpVtbl -> SetFactory(This,pNodeFactory)

#define IXMLParser_GetFactory(This,ppNodeFactory)	\
    (This)->lpVtbl -> GetFactory(This,ppNodeFactory)

#define IXMLParser_Abort(This,bstrErrorInfo)	\
    (This)->lpVtbl -> Abort(This,bstrErrorInfo)

#define IXMLParser_GetLineNumber(This)	\
    (This)->lpVtbl -> GetLineNumber(This)

#define IXMLParser_GetLinePosition(This)	\
    (This)->lpVtbl -> GetLinePosition(This)

#define IXMLParser_GetAbsolutePosition(This)	\
    (This)->lpVtbl -> GetAbsolutePosition(This)

#define IXMLParser_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)

#define IXMLParser_GetLastError(This)	\
    (This)->lpVtbl -> GetLastError(This)

#define IXMLParser_GetErrorInfo(This,pbstrErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo)

#define IXMLParser_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IXMLParser_GetURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetURL(This,ppwcBuf)


#define IXMLParser_SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)	\
    (This)->lpVtbl -> SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)

#define IXMLParser_Load(This,fFullyAvailable,pimkName,pibc,grfMode)	\
    (This)->lpVtbl -> Load(This,fFullyAvailable,pimkName,pibc,grfMode)

#define IXMLParser_SetInput(This,pStm)	\
    (This)->lpVtbl -> SetInput(This,pStm)

#define IXMLParser_PushData(This,pData,ulChars,fLastBuffer)	\
    (This)->lpVtbl -> PushData(This,pData,ulChars,fLastBuffer)

#define IXMLParser_LoadDTD(This,pszBaseUrl,pszRelativeUrl)	\
    (This)->lpVtbl -> LoadDTD(This,pszBaseUrl,pszRelativeUrl)

#define IXMLParser_LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)	\
    (This)->lpVtbl -> LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)

#define IXMLParser_ParseEntity(This,pwcText,ulLen,fpe)	\
    (This)->lpVtbl -> ParseEntity(This,pwcText,ulLen,fpe)

#define IXMLParser_ExpandEntity(This,pwcText,ulLen)	\
    (This)->lpVtbl -> ExpandEntity(This,pwcText,ulLen)

#define IXMLParser_SetRoot(This,pRoot)	\
    (This)->lpVtbl -> SetRoot(This,pRoot)

#define IXMLParser_GetRoot(This,ppRoot)	\
    (This)->lpVtbl -> GetRoot(This,ppRoot)

#define IXMLParser_Run(This,lChars)	\
    (This)->lpVtbl -> Run(This,lChars)

#define IXMLParser_GetParserState(This)	\
    (This)->lpVtbl -> GetParserState(This)

#define IXMLParser_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IXMLParser_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IXMLParser_SetFlags(This,iFlags)	\
    (This)->lpVtbl -> SetFlags(This,iFlags)

#define IXMLParser_SetSecureBaseURL(This,pszBaseUrl)	\
    (This)->lpVtbl -> SetSecureBaseURL(This,pszBaseUrl)

#define IXMLParser_GetSecureBaseURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetSecureBaseURL(This,ppwcBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLParser_SetURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
    /* [in] */ BOOL fAsync);


void __RPC_STUB IXMLParser_SetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Load_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ BOOL fFullyAvailable,
    /* [in] */ IMoniker __RPC_FAR *pimkName,
    /* [in] */ LPBC pibc,
    /* [in] */ DWORD grfMode);


void __RPC_STUB IXMLParser_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetInput_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pStm);


void __RPC_STUB IXMLParser_SetInput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_PushData_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const char __RPC_FAR *pData,
    /* [in] */ ULONG ulChars,
    /* [in] */ BOOL fLastBuffer);


void __RPC_STUB IXMLParser_PushData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_LoadDTD_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl);


void __RPC_STUB IXMLParser_LoadDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_LoadEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
    /* [in] */ BOOL fpe);


void __RPC_STUB IXMLParser_LoadEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_ParseEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwcText,
    /* [in] */ ULONG ulLen,
    /* [in] */ BOOL fpe);


void __RPC_STUB IXMLParser_ParseEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_ExpandEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwcText,
    /* [in] */ ULONG ulLen);


void __RPC_STUB IXMLParser_ExpandEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetRoot_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ PVOID pRoot);


void __RPC_STUB IXMLParser_SetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetRoot_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ PVOID __RPC_FAR *ppRoot);


void __RPC_STUB IXMLParser_GetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Run_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ long lChars);


void __RPC_STUB IXMLParser_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetParserState_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_GetParserState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Suspend_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Reset_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetFlags_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ ULONG iFlags);


void __RPC_STUB IXMLParser_SetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetSecureBaseURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl);


void __RPC_STUB IXMLParser_SetSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetSecureBaseURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);


void __RPC_STUB IXMLParser_GetSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLParser_INTERFACE_DEFINED__ */


#ifndef __IXMLNodeFactory_INTERFACE_DEFINED__
#define __IXMLNodeFactory_INTERFACE_DEFINED__

/* interface IXMLNodeFactory */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361f-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyEvent( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginChildren( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndChildren( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Error( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNode( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLNodeFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLNodeFactory __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyEvent )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginChildren )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndChildren )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Error )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNode )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);
        
        END_INTERFACE
    } IXMLNodeFactoryVtbl;

    interface IXMLNodeFactory
    {
        CONST_VTBL struct IXMLNodeFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLNodeFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLNodeFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLNodeFactory_NotifyEvent(This,pSource,iEvt)	\
    (This)->lpVtbl -> NotifyEvent(This,pSource,iEvt)

#define IXMLNodeFactory_BeginChildren(This,pSource,pNodeInfo)	\
    (This)->lpVtbl -> BeginChildren(This,pSource,pNodeInfo)

#define IXMLNodeFactory_EndChildren(This,pSource,fEmpty,pNodeInfo)	\
    (This)->lpVtbl -> EndChildren(This,pSource,fEmpty,pNodeInfo)

#define IXMLNodeFactory_Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo)	\
    (This)->lpVtbl -> Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo)

#define IXMLNodeFactory_CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo)	\
    (This)->lpVtbl -> CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLNodeFactory_NotifyEvent_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ XML_NODEFACTORY_EVENT iEvt);


void __RPC_STUB IXMLNodeFactory_NotifyEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_BeginChildren_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);


void __RPC_STUB IXMLNodeFactory_BeginChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_EndChildren_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ BOOL fEmpty,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);


void __RPC_STUB IXMLNodeFactory_EndChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_Error_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ HRESULT hrErrorCode,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);


void __RPC_STUB IXMLNodeFactory_Error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_CreateNode_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ PVOID pNodeParent,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);


void __RPC_STUB IXMLNodeFactory_CreateNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLNodeFactory_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_XMLParser;

#ifdef __cplusplus

class DECLSPEC_UUID("d2423620-51a0-11d2-9caf-0060b0ec3d39")
XMLParser;
#endif
#endif /* __XMLPSR_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\xmllib\xml\tokenizer\encoder\charencoder.cxx ===
/*
 * @(#)CharEncoder.cxx 1.0 6/10/97
 * 
* Copyright (c) 1997 - 1999 Microsoft Corporation. All rights reserved. * 
 */
#include "stdafx.h"
#include <shlwapi.h>
#pragma hdrstop

#define     checkhr
#define new_ne new
#define LENGTH(x) (sizeof(x)/sizeof(x[0]))

#include "charencoder.hxx"

// #include <shlwapip.h>   // IsCharSpace

#ifdef UNIX
#include <lendian.hpp>
#endif

#ifdef UNIX
// Not needed under UNIX
#else
#ifndef _WIN64
// #include <w95wraps.h>
#endif // _WIN64
#endif /* UNIX */

//
// Delegate other charsets to mlang
//
const EncodingEntry CharEncoder::charsetInfo [] = 
{
    { CP_1250, _T("WINDOWS-1250"), 1, wideCharFromMultiByteWin32, wideCharToMultiByteWin32 }, 
    { CP_1251, _T("WINDOWS-1251"), 1, wideCharFromMultiByteWin32, wideCharToMultiByteWin32 }, 
    { CP_1252, _T("WINDOWS-1252"), 1, wideCharFromMultiByteWin32, wideCharToMultiByteWin32 },
    { CP_1253, _T("WINDOWS-1253"), 1, wideCharFromMultiByteWin32, wideCharToMultiByteWin32 }, 
    { CP_1254, _T("WINDOWS-1254"), 1, wideCharFromMultiByteWin32, wideCharToMultiByteWin32 },
    { CP_1257, _T("WINDOWS-1257"), 1, wideCharFromMultiByteWin32, wideCharToMultiByteWin32 },
    { CP_UCS_4, _T("UCS-4"), 4, wideCharFromUcs4Bigendian, wideCharToUcs4Bigendian },
    { CP_UCS_2, _T("ISO-10646-UCS-2"), 2, wideCharFromUcs2Bigendian, wideCharToUcs2Bigendian },
    { CP_UCS_2, _T("UCS-2"), 2, wideCharFromUcs2Bigendian, wideCharToUcs2Bigendian },
    { CP_UCS_2, _T("UNICODE-2-0-UTF-16"), 2, wideCharFromUcs2Bigendian, wideCharToUcs2Bigendian },
    { CP_UCS_2, _T("UTF-16"), 2, wideCharFromUcs2Bigendian, wideCharToUcs2Bigendian },
    { CP_UTF_8, _T("UNICODE-1-1-UTF-8"), 3, wideCharFromUtf8, wideCharToUtf8 },
    { CP_UTF_8, _T("UNICODE-2-0-UTF-8"), 3, wideCharFromUtf8, wideCharToUtf8 },
    { CP_UTF_8, _T("UTF-8"), 3, wideCharFromUtf8, wideCharToUtf8 }
};

IMultiLanguage * CharEncoder::pMultiLanguage = NULL;

Encoding * Encoding::newEncoding(const TCHAR * s, ULONG len, bool endian, bool mark)
{
    Encoding * e = new_ne Encoding();
    if (e == NULL)
        return NULL;
    e->charset = new_ne TCHAR[len + 1];
    if (e->charset == NULL)
    {
        delete e;
        return NULL;
    }
    ::memcpy(e->charset, s, sizeof(TCHAR) * len);
    e->charset[len] = 0; // guarentee NULL termination.
    e->littleendian = endian;
    e->byteOrderMark = mark;
    return e;
}

Encoding::~Encoding()
{
    if (charset != NULL)
    {
        delete [] charset;
    }
}

int CharEncoder::getCharsetInfo(const TCHAR * charset, CODEPAGE * pcodepage, UINT * mCharSize)
{
    CPINFO cpinfo;

    for (int i = LENGTH(charsetInfo) - 1; i >= 0; i--)
    {
        if (StrCmpI(charset, charsetInfo[i].charset) == 0)
        {             
            //
            // test whether we can handle it locally or not
            // BUGBUG(HACK) the index number may change if we change charsetInfo
            //
            if (i > 5 || GetCPInfo(charsetInfo[i].codepage, &cpinfo))
            {
                *pcodepage = charsetInfo[i].codepage;
                *mCharSize = charsetInfo[i].maxCharSize;
                return i;
            }
            else
            {
                break;
            }
        }
    }

    //
    // delegate to MLANG then
    //
    MIMECSETINFO mimeCharsetInfo;
    HRESULT hr;

    hr = _EnsureMultiLanguage();
    if (hr == S_OK)
    {
        hr = pMultiLanguage->GetCharsetInfo((TCHAR*)charset, &mimeCharsetInfo);
        if (hr == S_OK)
        {
            *pcodepage = mimeCharsetInfo.uiInternetEncoding;
            if (GetCPInfo(*pcodepage, &cpinfo))
                *mCharSize = cpinfo.MaxCharSize;
            else // if we don't know the max size, assume a large size
                *mCharSize = 4;
            return -1;
        }
    }

    return -2;
}

extern HRESULT CreateMultiLanguage(IMultiLanguage ** ppUnk);

HRESULT CharEncoder::_EnsureMultiLanguage()
{
    // return CreateMultiLanguage(&pMultiLanguage);
    return E_NOTIMPL; // FA
}

/**
 * get information about a code page identified by <code> encoding </code>
 */
HRESULT CharEncoder::getWideCharFromMultiByteInfo(Encoding * encoding, CODEPAGE * pcodepage, WideCharFromMultiByteFunc ** pfnWideCharFromMultiByte, UINT * mCharSize)
{
    HRESULT hr = S_OK;

    int i = getCharsetInfo(encoding->charset, pcodepage, mCharSize);
    if (i >= 0) // in our short list
    {
        switch (*pcodepage)
        {
        case CP_UCS_2:
            if (encoding->littleendian)
                *pfnWideCharFromMultiByte = wideCharFromUcs2Littleendian;
            else
                *pfnWideCharFromMultiByte = wideCharFromUcs2Bigendian;
            break;
        case CP_UCS_4:
            if (encoding->littleendian)
                *pfnWideCharFromMultiByte = wideCharFromUcs4Littleendian;
            else
                *pfnWideCharFromMultiByte = wideCharFromUcs4Bigendian;
            break;
        default:
            *pfnWideCharFromMultiByte = charsetInfo[i].pfnWideCharFromMultiByte;
            break;
        }
    }
    else if (i == -1) // delegate to MLANG
    {
        hr = pMultiLanguage->IsConvertible(*pcodepage, CP_UCS_2);
        if (S_OK == hr) 
            *pfnWideCharFromMultiByte = wideCharFromMultiByteMlang;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

/**
 * get information about a code page identified by <code> encoding </code>
 */
HRESULT CharEncoder::getWideCharToMultiByteInfo(Encoding * encoding, CODEPAGE * pcodepage, WideCharToMultiByteFunc ** pfnWideCharToMultiByte, UINT * mCharSize)
{
    HRESULT hr = S_OK;

    int i = getCharsetInfo(encoding->charset, pcodepage, mCharSize);
    if (i >= 0) // in our short list
    {
        switch (*pcodepage)
        {
        case CP_UCS_2:
            if (encoding->littleendian)
                *pfnWideCharToMultiByte = wideCharToUcs2Littleendian;
            else
                *pfnWideCharToMultiByte = wideCharToUcs2Bigendian;
            break;
        case CP_UCS_4:
            if (encoding->littleendian)
                *pfnWideCharToMultiByte = wideCharToUcs4Littleendian;
            else
                *pfnWideCharToMultiByte = wideCharToUcs4Bigendian;
            break;
        default:
            *pfnWideCharToMultiByte = charsetInfo[i].pfnWideCharToMultiByte;
            break;
        }
    }
    else if (i == -1) // delegate to MLANG
    {
        hr = pMultiLanguage->IsConvertible(CP_UCS_2, *pcodepage);
        if (hr == S_OK)
            *pfnWideCharToMultiByte = wideCharToMultiByteMlang;
        else
            hr = E_FAIL;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

/**
 * Scans rawbuffer and translates UTF8 characters into UNICODE characters 
 */
HRESULT CharEncoder::wideCharFromUtf8(DWORD* pdwMode, CODEPAGE codepage, BYTE* bytebuffer,
                                            UINT * cb, TCHAR * buffer, UINT * cch)
{

#if 0
    // Just for the record - I tried this and measured it and it's twice as
    // slow as our hand-crafted code.

    // Back up if end of buffer is the second or third byte of a multi-byte 
    // encoding since MultiByteToWideChar cannot handle this case.  These second
    // and third bytes are easy to identify - they always start with the bit
    // pattern 0x10xxxxxx.

    UINT remaining = 0;
    UINT count;
    int endpos = (int)*cb;

    while (endpos > 0 && (bytebuffer[endpos-1] & 0xc0) == 0x80)
    {
        endpos--;
        remaining++;
    }
    if (endpos > 0)
    {
        count = MultiByteToWideChar(CP_UTF8, 0, bytebuffer, endpos, buffer, *cch);
        if (count == 0)
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
#else
    UINT remaining = *cb;
    UINT count = 0;
    UINT max = *cch;
    ULONG ucs4;

    // UTF-8 multi-byte encoding.  See Appendix A.2 of the Unicode book for more info.
    //
    // Unicode value    1st byte    2nd byte    3rd byte    4th byte
    // 000000000xxxxxxx 0xxxxxxx
    // 00000yyyyyxxxxxx 110yyyyy    10xxxxxx
    // zzzzyyyyyyxxxxxx 1110zzzz    10yyyyyy    10xxxxxx
    // 110110wwwwzzzzyy+ 11110uuu   10uuzzzz    10yyyyyy    10xxxxxx
    // 110111yyyyxxxxxx, where uuuuu = wwww + 1
    WCHAR c;
    bool valid = true;

    while (remaining > 0 && count < max)
    {
        // This is an optimization for straight runs of 7-bit ascii 
        // inside the UTF-8 data.
        c = *bytebuffer;
        if (c & 0x80)   // check 8th-bit and get out of here
            break;      // so we can do proper UTF-8 decoding.
        *buffer++ = c;
        bytebuffer++;
        count++;
        remaining--;
    }

    while (remaining > 0 && count < max)
    {
        UINT bytes = 0;
        for (c = *bytebuffer; c & 0x80; c <<= 1)
            bytes++;

        if (bytes == 0) 
            bytes = 1;

        if (remaining < bytes)
        {
            break;
        }
         
        c = 0;
        switch ( bytes )
        {
            case 6: bytebuffer++;    // We do not handle ucs4 chars
            case 5: bytebuffer++;    // except those on plane 1
                    valid = false;
                    // fall through
            case 4: 
                    // Do we have enough buffer?
                    if (count >= max - 1)
                        goto Cleanup;

                    // surrogate pairs
                    ucs4 = ULONG(*bytebuffer++ & 0x07) << 18;
                    if ((*bytebuffer & 0xc0) != 0x80)
                        valid = false;
                    ucs4 |= ULONG(*bytebuffer++ & 0x3f) << 12;
                    if ((*bytebuffer & 0xc0) != 0x80)
                        valid = false;
                    ucs4 |= ULONG(*bytebuffer++ & 0x3f) << 6;
                    if ((*bytebuffer & 0xc0) != 0x80)
                        valid = false;                    
                    ucs4 |= ULONG(*bytebuffer++ & 0x3f);

                    // For non-BMP code values of ISO/IEC 10646, 
                    // only those in plane 1 are valid xml characters
                    if (ucs4 > 0x10ffff)
                        valid = false;

                    if (valid)
                    {
                        // first ucs2 char
                        *buffer++ = (USHORT)((ucs4 - 0x10000) / 0x400 + 0xd800);
                        count++;
                        // second ucs2 char
                        c = (USHORT)((ucs4 - 0x10000) % 0x400 + 0xdc00);
                    }
                    break;

            case 3: c  = WCHAR(*bytebuffer++ & 0x0f) << 12;    // 0x0800 - 0xffff
                    if ((*bytebuffer & 0xc0) != 0x80)
                        valid = false;
                    // fall through
            case 2: c |= WCHAR(*bytebuffer++ & 0x3f) << 6;     // 0x0080 - 0x07ff
                    if ((*bytebuffer & 0xc0) != 0x80)
                        valid = false;
                    c |= WCHAR(*bytebuffer++ & 0x3f);
                    break;
                    
            case 1:
                c = TCHAR(*bytebuffer++);                      // 0x0000 - 0x007f
                break;

            default:
                valid = false; // not a valid UTF-8 character.
                break;
        }

        // If the multibyte sequence was illegal, store a FFFF character code.
        // The Unicode spec says this value may be used as a signal like this.
        // This will be detected later by the parser and an error generated.
        // We don't throw an exception here because the parser would not yet know
        // the line and character where the error occurred and couldn't produce a
        // detailed error message.

        if (! valid)
        {
            c = 0xffff;
            valid = true;
        }

        *buffer++ = c;
        count++;
        remaining -= bytes;
    }
#endif

Cleanup:
    // tell caller that there are bytes remaining in the buffer to
    // be processed next time around when we have more data.
    *cb -= remaining;
    *cch = count;
    return S_OK;
}


/**
 * Scans bytebuffer and translates UCS2 big endian characters into UNICODE characters 
 */
HRESULT CharEncoder::wideCharFromUcs2Bigendian(DWORD* pdwMode, CODEPAGE codepage, BYTE* bytebuffer,
                                            UINT * cb, TCHAR * buffer, UINT * cch)
{
    UINT num = *cb >> 1; 
    if (num > *cch)
        num = *cch;
    for (UINT i = num; i > 0; i--)
    {
        *buffer++ = ((*bytebuffer) << 8) | (*(bytebuffer + 1));
        bytebuffer += 2;
    }
    *cch = num;
    *cb = num << 1;
    return S_OK;
}


/**
 * Scans bytebuffer and translates UCS2 little endian characters into UNICODE characters 
 */
HRESULT CharEncoder::wideCharFromUcs2Littleendian(DWORD* pdwMode, CODEPAGE codepage, BYTE* bytebuffer,
                                            UINT * cb, TCHAR * buffer, UINT * cch)
{
    UINT num = *cb / 2; // Ucs2 is two byte unicode.
    if (num > *cch)
        num = *cch;


#ifndef UNIX
    // Optimization for windows platform where little endian maps directly to WCHAR.
    // (This increases overall parser performance by 5% for large unicode files !!)
    ::memcpy(buffer, bytebuffer, num * sizeof(TCHAR));
#else
    for (UINT i = num; i > 0 ; i--)
    {
        // we want the letter 'a' to be 0x0000006a.
        *buffer++ = (*(bytebuffer+1)<<8) | (*bytebuffer); 
        bytebuffer += 2;
    }
#endif
    *cch = num;
    *cb = num * 2;
    return S_OK;
}


/**
 * Scans bytebuffer and translates UCS4 big endian characters into UNICODE characters 
 */
HRESULT CharEncoder::wideCharFromUcs4Bigendian(DWORD* pdwMode, CODEPAGE codepage, BYTE* bytebuffer,
                                            UINT * cb, TCHAR * buffer, UINT * cch)
{
    UINT num = *cb >> 2;
    if (num > *cch)
        num = *cch;
    for (UINT i = num; i > 0; i--)
    {
#ifndef UNIX
        if (*bytebuffer != 0 || *(bytebuffer + 1) != 0)
        {
            // return XML_E_INVALID_UNICODE;
            return E_FAIL;// FA
        }
        *buffer++ = (*(bytebuffer + 2) << 8) | (*(bytebuffer + 3));
#else
        *buffer++ = ((*bytebuffer)<<24) | (*(bytebuffer+1)<<16) | (*(bytebuffer+2)<<8) | (*(bytebuffer+3));
#endif
        bytebuffer += 4;
    }
    *cch = num;
    *cb = num << 2;
    return S_OK;
}


/**
 * Scans bytebuffer and translates UCS4 little endian characters into UNICODE characters 
 */
HRESULT CharEncoder::wideCharFromUcs4Littleendian(DWORD* pdwMode, CODEPAGE codepage, BYTE* bytebuffer,
                                            UINT * cb, TCHAR * buffer, UINT * cch)
{
    UINT num = *cb >> 2; // Ucs4 is two byte unicode.
    if (num > *cch)
        num = *cch;
    for (UINT i = num; i > 0 ; i--)
    {
#ifndef UNIX
        *buffer++ = (*(bytebuffer+1)<<8) | (*bytebuffer);
        if (*(bytebuffer + 2) != 0 || *(bytebuffer + 3) != 0)
        {
            // return XML_E_INVALID_UNICODE;
            return E_FAIL; // FA
        }
#else
        *buffer++ = (*(bytebuffer+3)<<24) | (*(bytebuffer+2)<<16) | (*(bytebuffer+1)<<8) | (*bytebuffer);
#endif
        bytebuffer += 4;
    }
    *cch = num;
    *cb = num << 2;
    return S_OK;
}


/**
 * Scans bytebuffer and translates characters of charSet identified by 
 * <code> codepage </code> into UNICODE characters, 
 * using Win32 function MultiByteToWideChar() for encoding
 */
HRESULT CharEncoder::wideCharFromMultiByteWin32(DWORD* pdwMode, CODEPAGE codepage, BYTE* bytebuffer,
                                            UINT * cb, TCHAR * buffer, UINT * cch)
{
    HRESULT hr = S_OK;
    *cch = ::MultiByteToWideChar(codepage, MB_PRECOMPOSED,
                                 (char*)bytebuffer, *cb,
                                 buffer, *cch);
    if (*cch == 0)
        hr = GetLastError();
    return hr;
}


/**
 * Scans bytebuffer and translates multibyte characters into UNICODE characters,
 * using Mlang for encoding
 */
HRESULT CharEncoder::wideCharFromMultiByteMlang(DWORD* pdwMode, CODEPAGE codepage, BYTE* bytebuffer,
                                            UINT * cb, TCHAR * buffer, UINT * cch)
{
    HRESULT hr;
    checkhr2(_EnsureMultiLanguage());
    checkhr2(pMultiLanguage->ConvertStringToUnicode(pdwMode, codepage, 
                                 (char*)bytebuffer, cb, 
                                 buffer, cch ));
    return S_OK;
}


/**
 * Scans buffer and translates Unicode characters into Ucs2 big endian characters 
 */
HRESULT CharEncoder::wideCharToUcs2Bigendian(DWORD* pdwMode, CODEPAGE codepage, TCHAR * buffer, 
                                           UINT *cch, BYTE* bytebuffer, UINT * cb)
{
    UINT num = (*cb) >> 1; 
    if (num > *cch)
        num = *cch;
    // BUGBUG - what do we do about Unix where WCHAR is 4 bytes ?
    // Currently we just throw away the high WORD - but I don't know how else
    // to do it, since UCS2 is 2-byte unicode by definition.
    for (UINT i = num; i > 0; i--)
    {
        *bytebuffer++ = (*buffer) >> 8;
        *bytebuffer++ = (*buffer++) & 0xFF;
    }
    *cch = num;
    *cb = num << 1;
    return S_OK;
}


/**
 * Scans buffer and translates Unicode characters into Ucs2 little endian characters
 */
HRESULT CharEncoder::wideCharToUcs2Littleendian(DWORD* pdwMode, CODEPAGE codepage, TCHAR * buffer, 
                                              UINT *cch, BYTE* bytebuffer, UINT * cb)
{
    UINT num = (*cb) >> 1;
    if (num > *cch)
        num = *cch;

    // BUGBUG - what do we do about Unix where WCHAR is 4 bytes ?
    // Currently we just throw away the high WORD - but I don't know how else
    // to do it, since UCS2 is 2-byte unicode by definition.
#ifndef UNIX
    // Optimization for windows platform where little endian maps directly to WCHAR.
    // (This increases overall parser performance by 5% for large unicode files !!)
    ::memcpy(bytebuffer, buffer, num * sizeof(TCHAR));
#else
    for (UINT i = num; i > 0; i--)
    {
        *bytebuffer++ = (*buffer) & 0xFF;
        *bytebuffer++ = (*buffer++) >> 8;
    }
#endif
    *cch = num;
    *cb = num << 1;
    return S_OK;
}


/**
 * Scans buffer and translates Unicode characters into Ucs4 big endian characters 
 */
HRESULT CharEncoder::wideCharToUcs4Bigendian(DWORD* pdwMode, CODEPAGE codepage, TCHAR * buffer, 
                                           UINT *cch, BYTE* bytebuffer, UINT * cb)
{
    UINT num = (*cb) >> 2; 
    if (num > *cch)
        num = *cch;

    for (UINT i = num; i > 0; i--)
    {
#ifndef UNIX
        *bytebuffer++ = 0;
        *bytebuffer++ = 0;
        *bytebuffer++ = (*buffer) >> 8;
        *bytebuffer++ = (*buffer) & 0xFF;
#else
        *bytebuffer++ = (*buffer) >> 24;
        *bytebuffer++ = ((*buffer) >> 16) & 0xFF;
        *bytebuffer++ = ((*buffer) >> 8) & 0xFF;
        *bytebuffer++ = (*buffer) & 0xFF;
#endif
        buffer++;
    }
    *cch = num;
    *cb = num << 2;
    return S_OK;
}


/**
 * Scans buffer and translates Unicode characters into Ucs4 little endian characters
 */
HRESULT CharEncoder::wideCharToUcs4Littleendian(DWORD* pdwMode, CODEPAGE codepage, TCHAR * buffer, 
                                              UINT *cch, BYTE* bytebuffer, UINT * cb)
{
    UINT num = (*cb) >> 2;
    if (num > *cch)
        num = *cch;

    for (UINT i = num; i > 0; i--)
    {
#ifndef UNIX
        *bytebuffer++ = (*buffer) & 0xFF;
        *bytebuffer++ = (*buffer) >> 8;
        *bytebuffer++ = 0;
        *bytebuffer++ = 0;
#else
        *bytebuffer++ = (*buffer) & 0xFF;
        *bytebuffer++ = ((*buffer) >> 8) & 0xFF;
        *bytebuffer++ = ((*buffer) >> 16) & 0xFF;
        *bytebuffer++ = (*buffer) >> 24;
#endif
        buffer++;
    }
    *cch = num;
    *cb = num << 2;
    return S_OK;
}


/**
 * Scans buffer and translates Unicode characters into UTF8 characters
 */
HRESULT CharEncoder::wideCharToUtf8(DWORD* pdwMode, CODEPAGE codepage, TCHAR * buffer, 
                                       UINT *cch, BYTE* bytebuffer, UINT * cb)
{
    UINT count = 0, num = *cch, m1 = *cb, m2 = m1 - 1, m3 = m2 - 1, m4 = m3 - 1;
    DWORD dw1;
    bool surrogate = false;

    for (UINT i = num; i > 0; i--)
    {
#ifdef UNIX
          // Solaris a WCHAR is 4 bytes (DWORD)
        DWORD dw = 0;
        DWORD dwTemp[4];
        BYTE* pByte = (BYTE*)buffer;
        dwTemp[3] = (DWORD)pByte[0];
        dwTemp[2] = (DWORD)pByte[1];
        dwTemp[1] = (DWORD)pByte[2];
        dwTemp[0] = (DWORD)pByte[3];
        dw = dwTemp[0]+(dwTemp[1]<<8)+(dwTemp[2]<<16)+(dwTemp[3]<<24);
#else
        DWORD dw = *buffer;
#endif

        if (surrogate) //  is it the second char of a surrogate pair?
        {
            if (dw >= 0xdc00 && dw <= 0xdfff)
            {
                // four bytes 0x11110xxx 0x10xxxxxx 0x10xxxxxx 0x10xxxxxx
                if (count < m4)
                    count += 4;
                else
                    break;
                ULONG ucs4 = (dw1 - 0xd800) * 0x400 + (dw - 0xdc00) + 0x10000;
                *bytebuffer++ = (byte)(( ucs4 >> 18) | 0xF0);
                *bytebuffer++ = (byte)((( ucs4 >> 12) & 0x3F) | 0x80);
                *bytebuffer++ = (byte)((( ucs4 >> 6) & 0x3F) | 0x80);
                *bytebuffer++ = (byte)(( ucs4 & 0x3F) | 0x80);
                surrogate = false;
                buffer++;
                continue;
            }
            else // Then dw1 must be a three byte character
            {
                if (count < m3)
                    count += 3;
                else
                    break;
                *bytebuffer++ = (byte)(( dw1 >> 12) | 0xE0);
                *bytebuffer++ = (byte)((( dw1 >> 6) & 0x3F) | 0x80);
                *bytebuffer++ = (byte)(( dw1 & 0x3F) | 0x80);
            }
            surrogate = false;
        }

        if (dw  < 0x80) // one byte, 0xxxxxxx
        {
            if (count < m1)
                count++;
            else
                break;
            *bytebuffer++ = (byte)dw;
        }
        else if ( dw < 0x800) // two WORDS, 110xxxxx 10xxxxxx
        {
            if (count < m2)
                count += 2;
            else
                break;
            *bytebuffer++ = (byte)((dw >> 6) | 0xC0);
            *bytebuffer++ = (byte)((dw & 0x3F) | 0x80);
        }
        else if (dw >= 0xd800 && dw <= 0xdbff) // Assume that it is the first char of surrogate pair
        {
            if (i == 1) // last wchar in buffer
                break;
            dw1 = dw;
            surrogate = true;
        }
        else // three bytes, 1110xxxx 10xxxxxx 10xxxxxx
        {
            if (count < m3)
                count += 3;
            else
                break;
            *bytebuffer++ = (byte)(( dw >> 12) | 0xE0);
            *bytebuffer++ = (byte)((( dw >> 6) & 0x3F) | 0x80);
            *bytebuffer++ = (byte)(( dw & 0x3F) | 0x80);
        }
        buffer++;
    }

    *cch = surrogate ? num - i - 1 : num - i;
    *cb = count;

    return S_OK;
}

/**
 * Scans buffer and translates Unicode characters into characters identified
 * by <code> codepage </>, using Win32 function WideCharToMultiByte for encoding 
 */
HRESULT CharEncoder::wideCharToMultiByteWin32(DWORD* pdwMode, CODEPAGE codepage, TCHAR * buffer, 
                                              UINT *cch, BYTE* bytebuffer, UINT * cb)
{
    HRESULT hr = S_OK;
    BOOL fBadChar = false;
    *cb = ::WideCharToMultiByte(codepage, NULL, buffer, *cch, (char*)bytebuffer, *cb, NULL, &fBadChar);
    if (*cb == 0)
        hr = ::GetLastError();
    else if (fBadChar)
        // BUGBUG: how do we inform the caller which character failed?
        hr = S_FALSE;
    return hr;
}


/**
 * Scans buffer and translates Unicode characters into characters of charSet 
 * identified by <code> codepage </code>, using Mlang for encoding 
 */
HRESULT CharEncoder::wideCharToMultiByteMlang(DWORD* pdwMode, CODEPAGE codepage, TCHAR * buffer, 
                                              UINT *cch, BYTE* bytebuffer, UINT * cb)
{
    HRESULT hr;
    checkhr2(_EnsureMultiLanguage());
    checkhr2(pMultiLanguage->ConvertStringFromUnicode(pdwMode, codepage,
                                       buffer, cch, (char*)bytebuffer, cb ));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\xmllib\xml\tokenizer\encoder\encodingstream.cxx ===
/*
 * @(#)EncodingStream.cxx 1.0 6/10/97
 * 
* Copyright (c) 1997 - 1999 Microsoft Corporation. All rights reserved. * 
 */

#include "stdafx.h"
#pragma hdrstop
#include <shlwapi.h>
// #define StrLen lstrlen
#define     checkhr
#define     checkerr
#define new_ne new
// #define isWhiteSpace iswspace
#define Assert(x)

#include "encodingstream.hxx"

// NOTE: We are using the error codes defined in xmlerr.h
// which are in the precompiled header.

const int EncodingStream::BUFFERSIZE = 4096*sizeof(WCHAR);

EncodingStream::EncodingStream(IStream * stream): stream(stream), encoding(NULL), buf(NULL)
{
    // These objects are sometimes handed out to external clients.
//    ::IncrementComponents();
    AddRef();

    pfnWideCharFromMultiByte = NULL;
    pfnWideCharToMultiByte = NULL;
    btotal = bnext = startAt = 0;
    lastBuffer = false;
    bufsize = 0;
    _fEOF = false;
    _fReadStream = true;
    _fUTF8BOM = false;
    _fTextXML = false;
    _fSetCharset = false;
    _dwMode = 0;
    codepage = CP_UNDEFINED;
}

/**
 * Builds the EncodingStream for input.
 * Reads the first two bytes of the InputStream * in order to make a guess
 * as to the character encoding of the file.
 */
IStream * EncodingStream::newEncodingStream(IStream * stream)
{
    EncodingStream * es = new_ne EncodingStream(stream);
    if (es == NULL)
        return NULL;
    es->isInput = true;
    es->buf = NULL;
    return es;
}


/**
 * Builds the EncodingStream for output. The default encoding is UTF-8
 */
IStream * EncodingStream::newEncodingStream(IStream * stream, Encoding * encoding)
{
    HRESULT hr;

    if (!stream)
        return NULL;
    EncodingStream * es = new_ne EncodingStream(stream);
    if (es == NULL)
        return NULL;
    // set the default encoding to UTF-8
    if (encoding == NULL)
    {
        es->encoding = Encoding::newEncoding();
        if (es->encoding == NULL)
            goto error;
    }
    else
        es->encoding = encoding;
    es->isInput = false;
    es->maxCharSize = 3; // set a default value
    checkerr(CharEncoder::getWideCharToMultiByteInfo(es->encoding, &es->codepage, &es->pfnWideCharToMultiByte, &es->maxCharSize));

    // allocates bytebuffer according to maxCharSize, allowing enough space 
    // to hold bytes converted from wide characters in buffer
    es->bufsize = BUFFERSIZE * ((es->maxCharSize + 1) / sizeof(WCHAR));
    es->buf = new_ne BYTE[es->bufsize];
    if (es->buf == NULL)
        goto error;

    //
    // Notice: byteOrderMark was set to true only when the encoding is UCS-2, UTF-16 or UCS-4 
    //
    if (es->encoding->byteOrderMark)
    {
        BYTE szTemp[2];
        ULONG ulError;

        if (es->encoding->littleendian)
        {
            szTemp[0]= 0xff;
            szTemp[1]= 0xfe;
        }
        else
        {
            szTemp[0]= 0xfe;
            szTemp[1]= 0xff;
        }
        checkerr(stream->Write(szTemp, 2, &ulError));
        if (es->codepage == CP_UCS_4)
        {
            checkerr(stream->Write(szTemp, 2, &ulError));
        }
    }

    return es;

error:
    delete es;
    return NULL;
}

EncodingStream::~EncodingStream()
{
    // These objects are sometimes handed out to external clients.
//    ::DecrementComponents();
    Release();
    if (buf != NULL)
        delete [] buf;
    if (encoding != NULL)
        delete encoding;
    stream = NULL;
}

/**
 * Reads characters from stream and encode it to Unicode
 */
HRESULT STDMETHODCALLTYPE EncodingStream::Read(void * pv, ULONG cb, ULONG * pcbRead)
{
    HRESULT hr;

    ULONG num = 0;

    if (pcbRead != NULL)
        *pcbRead = 0;

    if (btotal == 0 && _fEOF)          // we already hit EOF - so return right away.
        return S_OK;

    // Calculate how many UNICODE chars we are allowed to return.
    cb /= sizeof(WCHAR);
    checkhr2( prepareForInput(cb));

    if (stream && _fReadStream)
    {
        // btotal = number of bytes already in start of buffer.
        if (cb > btotal)
        {
            hr = stream->Read(buf + btotal, cb - btotal, &num);
            if (hr == E_PENDING && num > 0)
            {
                // in which case we ignore the error, and continue on !!.
                // BUGBUG - this may be a problem.since we are changing the
                // return code returned from the stream.  This may mean we
                // should not ever hand out this stream outside of MSXML.
                hr = 0;
            }
            if (FAILED(hr))
            {
                return hr;
            }
            if (btotal == 0 && num == 0)
            {
                _fEOF = true;
                return hr;
            }
        }
        else
        {
            hr = S_OK;
        }
    }
    else if (btotal == 0)
    {
        return (lastBuffer) ? S_FALSE : E_PENDING;
    }

    btotal += num;
    UINT b = btotal, utotal = cb;
    if (b > cb)
    {
        // If we have more bytes in our buffer than the caller has
        // room for, then only return the number of bytes the caller
        // asked for -- otherwise pfnWideCharFromMultiByte will write
        // off the end of the caller's buffer.
        b = cb;
    }
    if (pfnWideCharFromMultiByte == NULL) // first read() call
    {
        checkhr2(autoDetect());
        if (pfnWideCharFromMultiByte == NULL) // failed to fully determine encoding
            return (lastBuffer) ? S_FALSE : E_PENDING;
        b -= bnext;
        startAt -= bnext;
    }
    hr = (this->pfnWideCharFromMultiByte)(&_dwMode, codepage, buf + bnext, &b, (TCHAR *)pv, &utotal);
    if (hr != S_OK)
        return hr;
    if (b == 0 && num == 0 && (stream || lastBuffer))
    {
        // stream says we're at the end, but pfnWideCharFromMultiByte
        // disagrees !!
        // return XML_E_INCOMPLETE_ENCODING;
        return E_FAIL; // FA
    }
    bnext += b;
    if (pcbRead != NULL)
        *pcbRead = utotal*sizeof(WCHAR);
    return (utotal == 0) ? E_PENDING : S_OK;
} 


// BUGBUG: According to RFC 2376 (XML Media type),
// when media type is "text/xml" and charset is missing
// the charset should be always "US-ASCII" no matter what encoding information is in
// the xml document. 
// However, because urlmon always sets MimeType to text/xml when it sniffs xml document,
// we cannot strictly following RFC 2376 (we want the mime type be set to application/xml by
// urlmon so we can detect the encoding according to what's in the XML language spec) 
// See bug 74716 for more info.

// When charset is set, we use it as the encoding scheme;
// otherwise, do auto-detect and ignore mime type information

/**
 * Checks the first two/four bytes of the input Stream in order to 
 * detect UTF-16/UCS-4 or UTF-8 encoding;
 * otherwise assume it is UTF-8
 */
HRESULT EncodingStream::autoDetect()
{
    // wait until we have enough to be sure.
    if (btotal < 2)
        return S_OK;

    unsigned int guess = (((unsigned char)buf[0]) << 8) + ((unsigned char)buf[1]);
    HRESULT hr;

    if (guess == 0xFEFF || guess == 0xFFFE) // BOM found
    {
        // wait until we have enough to be sure.
        if (btotal < 4)
            return S_OK;

        unsigned int guess1 = (((unsigned char)buf[2]) << 8) + ((unsigned char)buf[3]);
        if (guess == guess1)
        {
            if (!encoding)
            {
                static const TCHAR* wchUCS4 = _T("UCS-4");
                encoding = Encoding::newEncoding(wchUCS4, 5, (0xFFFE == guess), true);
            }
            bnext = 4;
        }
        else
        {
            if (!encoding)
            {
                static const TCHAR* wchUCS2 = _T("UCS-2");
                encoding = Encoding::newEncoding(wchUCS2, 5, (0xFFFE == guess), true);
            }
            bnext = 2;
        }

        if (NULL == encoding)
            return E_OUTOFMEMORY;       
        encoding->littleendian =  (0xFFFE == guess);
    }
    else
    {
        if (!encoding)
        {
            encoding = Encoding::newEncoding();
            if (NULL == encoding)
                return E_OUTOFMEMORY;
        }

        // In some system, such as win2k, there is BOM 0xEF BB BF for UTF8
        if (guess == 0xEFBB)
        {
            if (btotal < 3)
                return S_OK;
            if (buf[2] == 0xBF)
                _fUTF8BOM = true; 
            bnext = 3; 
        }
        else
        {
            encoding->byteOrderMark = false;
        }
    }

    checkhr2(CharEncoder::getWideCharFromMultiByteInfo(encoding, &codepage, &pfnWideCharFromMultiByte, &maxCharSize));
    return S_OK;
}


/**
 * Encodes Unicode characters and writes to output stream
 */
HRESULT STDMETHODCALLTYPE EncodingStream::Write(void const* pv, ULONG cb, ULONG * pcbWritten)
{
    HRESULT hr;
    UINT bytetotal;
    UINT cb1 = BUFFERSIZE / maxCharSize;
    ULONG position = 0;
    ULONG utotal;
    cb /= sizeof(WCHAR);

    if (pfnWideCharToMultiByte == NULL)
        return E_FAIL;

    do {
        if (cb1 + position > cb)
            cb1 = cb - position;
	    bytetotal = cb1 * maxCharSize;
        checkhr2((this->pfnWideCharToMultiByte)(&_dwMode, codepage, (WCHAR *)pv + position, &cb1, buf, &bytetotal));
        if (S_FALSE == hr) // unable to convert a character
            return E_UNEXPECTED;
        checkhr2(stream->Write((void *)buf, bytetotal, &utotal));
        position += cb1;
    } while (position < cb);

    if (pcbWritten)
        *pcbWritten = cb; 
    return S_OK;
}


/**
 * Switchs the character encoding of the input stream
 * Returns:
 *         S_OK: succeeded, and do not need re-read
 *         S_FALSE: succeeded, needs to re-read from <code> newPosition </code>
 *         Otherwise: error code
 * Notice: 
 *         This method only works for input stream, newPosition starts with 1
 */
HRESULT EncodingStream::switchEncodingAt(Encoding * newEncoding, int newPosition)
{
    // Ignore encoding information in the document when charset information is set from outside
    if (_fSetCharset)
        return S_OK;

    int l = newPosition - startAt;
    if (l < 0 || l > (int)bnext) 
    {
        // out of range
        delete newEncoding;
        return E_INVALIDARG;
    }

    UINT newcodepage;
    UINT newCharSize;
    //
    // get and check charset information
    //
    WideCharFromMultiByteFunc * pfn;
    HRESULT hr = CharEncoder::getWideCharFromMultiByteInfo(newEncoding, &newcodepage, &pfn, &newCharSize);
    if (hr != S_OK)
    {
        delete newEncoding;
        return E_INVALIDARG;
    }
    if (codepage == newcodepage)
    {
        delete newEncoding;
        return S_OK;
    }

    // Now if we are in UCS-2/UCS-4 we cannot switch out of UCS-2/UCS-4 and if we are
    // not in UCS-2/UCS-4 we cannot switch into UCS-2/UCS-4.
    // Also if UTF-8 BOM is presented, we cannot switch away
    if ((codepage != CP_UCS_2 && newcodepage == CP_UCS_2) ||
        (codepage == CP_UCS_2 && newcodepage != CP_UCS_2) ||
        (codepage != CP_UCS_4 && newcodepage == CP_UCS_4) ||
        (codepage == CP_UCS_4 && newcodepage != CP_UCS_4) ||
        (codepage == CP_UTF_8 && newcodepage != CP_UTF_8 && _fUTF8BOM))
    {
        delete newEncoding;
        return E_FAIL;
    }

    // Ok, then, let's make the switch.
    delete encoding;
    encoding = newEncoding;
    maxCharSize = newCharSize;
    codepage = newcodepage;
    pfnWideCharFromMultiByte = pfn;

    // Because the XML declaration is encoded in UTF-8, 
    // Mapping input characters to wide characters is one-to-one mapping
    if ((int)bnext != l)
    {
        bnext = l;
        return S_FALSE;
    }
    return S_OK;
}

HRESULT EncodingStream::prepareForInput(ULONG minlen)
{
    Assert(btotal >= bnext);
    btotal -= bnext;

    if (bufsize < minlen)
    {
        BYTE* newbuf = new_ne BYTE[minlen];
        if (newbuf == NULL)
            return E_OUTOFMEMORY;
        if (buf != NULL)
        {
            ::memcpy(newbuf, buf+bnext, btotal);
            delete[] buf;
        }
        buf = newbuf;
        bufsize = minlen;
    }
    else if (bnext > 0 && btotal > 0)
    {
        // Shift remaining bytes down to beginning of buffer.
        ::memmove(buf, buf + bnext, btotal);          
    }
    startAt += bnext;
    bnext = 0;
    return S_OK;
}


HRESULT EncodingStream::AppendData( const BYTE* buffer, ULONG length, BOOL lastBuffer)
{
    Assert(btotal >= bnext);
    this->lastBuffer = (lastBuffer != FALSE);
    HRESULT hr;
    ULONG minlen = length + (btotal - bnext); // make sure we don't loose any data
    if (minlen < BUFFERSIZE)
        minlen = BUFFERSIZE;
    checkhr2( prepareForInput(minlen));
    
    if (length > 0 && buffer != NULL)
    {
        // Copy raw data into new buffer.
        ::memcpy(buf + btotal, buffer, length);
        btotal += length;
    }
    if (pfnWideCharFromMultiByte == NULL) // first AppendData call
    {
        checkhr2(autoDetect());
    }
    return hr;
}

HRESULT EncodingStream::BufferData()
{
    HRESULT hr = S_OK;
    checkhr2( prepareForInput(0)); // shift down (so bnext=0).

    if (_fEOF)          // already hit the end of the stream.
        return S_FALSE;

    const DWORD BUFSIZE = 4096;

    DWORD dwRead = 1;

    while (S_OK == hr && dwRead > 0)
    {
        // if we cannot fit another buffer full, then re-allocate.
        DWORD minsize = (btotal+BUFSIZE > bufsize) ? bufsize + BUFSIZE : bufsize;
        checkhr2( prepareForInput(minsize)); // make space available.

        dwRead = 0;
        hr = stream->Read(buf + btotal, BUFSIZE, &dwRead);
        btotal += dwRead;
    }

    if (SUCCEEDED(hr) && dwRead == 0)
    {
        _fEOF = true;
        hr = S_FALSE; // return S_FALSE when at eof.
    }
    return hr;
}

Encoding *  
EncodingStream::getEncoding()
{
    return encoding;
}


void 
EncodingStream::SetMimeType(const WCHAR * pwszMimeType, int length)
{
    static const TCHAR * pszTEXT = _T("text/xml");

    if (8 == length)
        _fTextXML = StrCmpNI(pwszMimeType, pszTEXT, 8) == 0; // text/xml
    else
        _fTextXML = false;   // application/xml
}
    

void 
EncodingStream::SetCharset(const WCHAR * pwszCharset, int length)
{
    if (encoding)
        delete encoding;
    // assume BOM and little endian
    encoding = Encoding::newEncoding(pwszCharset, length, true, true);
    _fSetCharset = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\xmllib\xml\tokenizer\xmlparser.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0205 */
/* at Thu Oct 22 17:08:10 1998
 */
/* Compiler settings for xmlparser.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __xmlparser_h__
#define __xmlparser_h__

/* Forward Declarations */ 

#ifndef __IXMLNodeSource_FWD_DEFINED__
#define __IXMLNodeSource_FWD_DEFINED__
typedef interface IXMLNodeSource IXMLNodeSource;
#endif 	/* __IXMLNodeSource_FWD_DEFINED__ */


#ifndef __IXMLParser_FWD_DEFINED__
#define __IXMLParser_FWD_DEFINED__
typedef interface IXMLParser IXMLParser;
#endif 	/* __IXMLParser_FWD_DEFINED__ */


#ifndef __IXMLNodeFactory_FWD_DEFINED__
#define __IXMLNodeFactory_FWD_DEFINED__
typedef interface IXMLNodeFactory IXMLNodeFactory;
#endif 	/* __IXMLNodeFactory_FWD_DEFINED__ */


#ifndef __XMLParser_FWD_DEFINED__
#define __XMLParser_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLParser XMLParser;
#else
typedef struct XMLParser XMLParser;
#endif /* __cplusplus */

#endif 	/* __XMLParser_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_xmlparser_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//--------------------------------------------------------------------------




typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0001
    {	XML_ELEMENT	= 1,
	XML_ATTRIBUTE	= XML_ELEMENT + 1,
	XML_PI	= XML_ATTRIBUTE + 1,
	XML_XMLDECL	= XML_PI + 1,
	XML_DOCTYPE	= XML_XMLDECL + 1,
	XML_DTDATTRIBUTE	= XML_DOCTYPE + 1,
	XML_ENTITYDECL	= XML_DTDATTRIBUTE + 1,
	XML_ELEMENTDECL	= XML_ENTITYDECL + 1,
	XML_ATTLISTDECL	= XML_ELEMENTDECL + 1,
	XML_NOTATION	= XML_ATTLISTDECL + 1,
	XML_GROUP	= XML_NOTATION + 1,
	XML_INCLUDESECT	= XML_GROUP + 1,
	XML_PCDATA	= XML_INCLUDESECT + 1,
	XML_CDATA	= XML_PCDATA + 1,
	XML_IGNORESECT	= XML_CDATA + 1,
	XML_COMMENT	= XML_IGNORESECT + 1,
	XML_ENTITYREF	= XML_COMMENT + 1,
	XML_WHITESPACE	= XML_ENTITYREF + 1,
	XML_NAME	= XML_WHITESPACE + 1,
	XML_NMTOKEN	= XML_NAME + 1,
	XML_STRING	= XML_NMTOKEN + 1,
	XML_PEREF	= XML_STRING + 1,
	XML_MODEL	= XML_PEREF + 1,
	XML_ATTDEF	= XML_MODEL + 1,
	XML_ATTTYPE	= XML_ATTDEF + 1,
	XML_ATTPRESENCE	= XML_ATTTYPE + 1,
	XML_DTDSUBSET	= XML_ATTPRESENCE + 1,
	XML_LASTNODETYPE	= XML_DTDSUBSET + 1
    }	XML_NODE_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0002
    {	XML_VERSION	= XML_LASTNODETYPE,
	XML_ENCODING	= XML_VERSION + 1,
	XML_STANDALONE	= XML_ENCODING + 1,
	XML_NS	= XML_STANDALONE + 1,
	XML_XMLSPACE	= XML_NS + 1,
	XML_XMLLANG	= XML_XMLSPACE + 1,
	XML_SYSTEM	= XML_XMLLANG + 1,
	XML_PUBLIC	= XML_SYSTEM + 1,
	XML_NDATA	= XML_PUBLIC + 1,
	XML_AT_CDATA	= XML_NDATA + 1,
	XML_AT_ID	= XML_AT_CDATA + 1,
	XML_AT_IDREF	= XML_AT_ID + 1,
	XML_AT_IDREFS	= XML_AT_IDREF + 1,
	XML_AT_ENTITY	= XML_AT_IDREFS + 1,
	XML_AT_ENTITIES	= XML_AT_ENTITY + 1,
	XML_AT_NMTOKEN	= XML_AT_ENTITIES + 1,
	XML_AT_NMTOKENS	= XML_AT_NMTOKEN + 1,
	XML_AT_NOTATION	= XML_AT_NMTOKENS + 1,
	XML_AT_REQUIRED	= XML_AT_NOTATION + 1,
	XML_AT_IMPLIED	= XML_AT_REQUIRED + 1,
	XML_AT_FIXED	= XML_AT_IMPLIED + 1,
	XML_PENTITYDECL	= XML_AT_FIXED + 1,
	XML_EMPTY	= XML_PENTITYDECL + 1,
	XML_ANY	= XML_EMPTY + 1,
	XML_MIXED	= XML_ANY + 1,
	XML_SEQUENCE	= XML_MIXED + 1,
	XML_CHOICE	= XML_SEQUENCE + 1,
	XML_STAR	= XML_CHOICE + 1,
	XML_PLUS	= XML_STAR + 1,
	XML_QUESTIONMARK	= XML_PLUS + 1,
	XML_LASTSUBNODETYPE	= XML_QUESTIONMARK + 1
    }	XML_NODE_SUBTYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0003
    {	XML_E_PARSEERRORBASE	= 0xc00ce500L,
	XML_E_ENDOFINPUT	= XML_E_PARSEERRORBASE,
	XML_E_MISSINGEQUALS	= XML_E_ENDOFINPUT + 1,
	XML_E_MISSINGQUOTE	= XML_E_MISSINGEQUALS + 1,
	XML_E_COMMENTSYNTAX	= XML_E_MISSINGQUOTE + 1,
	XML_E_BADSTARTNAMECHAR	= XML_E_COMMENTSYNTAX + 1,
	XML_E_BADNAMECHAR	= XML_E_BADSTARTNAMECHAR + 1,
	XML_E_BADCHARINSTRING	= XML_E_BADNAMECHAR + 1,
	XML_E_XMLDECLSYNTAX	= XML_E_BADCHARINSTRING + 1,
	XML_E_BADCHARDATA	= XML_E_XMLDECLSYNTAX + 1,
	XML_E_MISSINGWHITESPACE	= XML_E_BADCHARDATA + 1,
	XML_E_EXPECTINGTAGEND	= XML_E_MISSINGWHITESPACE + 1,
	XML_E_BADCHARINDTD	= XML_E_EXPECTINGTAGEND + 1,
	XML_E_BADCHARINDECL	= XML_E_BADCHARINDTD + 1,
	XML_E_MISSINGSEMICOLON	= XML_E_BADCHARINDECL + 1,
	XML_E_BADCHARINENTREF	= XML_E_MISSINGSEMICOLON + 1,
	XML_E_UNBALANCEDPAREN	= XML_E_BADCHARINENTREF + 1,
	XML_E_EXPECTINGOPENBRACKET	= XML_E_UNBALANCEDPAREN + 1,
	XML_E_BADENDCONDSECT	= XML_E_EXPECTINGOPENBRACKET + 1,
	XML_E_INTERNALERROR	= XML_E_BADENDCONDSECT + 1,
	XML_E_UNEXPECTED_WHITESPACE	= XML_E_INTERNALERROR + 1,
	XML_E_INCOMPLETE_ENCODING	= XML_E_UNEXPECTED_WHITESPACE + 1,
	XML_E_BADCHARINMIXEDMODEL	= XML_E_INCOMPLETE_ENCODING + 1,
	XML_E_MISSING_STAR	= XML_E_BADCHARINMIXEDMODEL + 1,
	XML_E_BADCHARINMODEL	= XML_E_MISSING_STAR + 1,
	XML_E_MISSING_PAREN	= XML_E_BADCHARINMODEL + 1,
	XML_E_BADCHARINENUMERATION	= XML_E_MISSING_PAREN + 1,
	XML_E_PIDECLSYNTAX	= XML_E_BADCHARINENUMERATION + 1,
	XML_E_EXPECTINGCLOSEQUOTE	= XML_E_PIDECLSYNTAX + 1,
	XML_E_MULTIPLE_COLONS	= XML_E_EXPECTINGCLOSEQUOTE + 1,
	XML_E_INVALID_DECIMAL	= XML_E_MULTIPLE_COLONS + 1,
	XML_E_INVALID_HEXIDECIMAL	= XML_E_INVALID_DECIMAL + 1,
	XML_E_INVALID_UNICODE	= XML_E_INVALID_HEXIDECIMAL + 1,
	XML_E_TOKEN_ERROR	= XML_E_PARSEERRORBASE + 0x50,
	XML_E_SUSPENDED	= XML_E_TOKEN_ERROR,
	XML_E_STOPPED	= XML_E_SUSPENDED + 1,
	XML_E_UNEXPECTEDENDTAG	= XML_E_STOPPED + 1,
	XML_E_UNCLOSEDTAG	= XML_E_UNEXPECTEDENDTAG + 1,
	XML_E_DUPLICATEATTRIBUTE	= XML_E_UNCLOSEDTAG + 1,
	XML_E_MULTIPLEROOTS	= XML_E_DUPLICATEATTRIBUTE + 1,
	XML_E_INVALIDATROOTLEVEL	= XML_E_MULTIPLEROOTS + 1,
	XML_E_BADXMLDECL	= XML_E_INVALIDATROOTLEVEL + 1,
	XML_E_MISSINGROOT	= XML_E_BADXMLDECL + 1,
	XML_E_UNEXPECTEDEOF	= XML_E_MISSINGROOT + 1,
	XML_E_BADPEREFINSUBSET	= XML_E_UNEXPECTEDEOF + 1,
	XML_E_PE_NESTING	= XML_E_BADPEREFINSUBSET + 1,
	XML_E_INVALID_CDATACLOSINGTAG	= XML_E_PE_NESTING + 1,
	XML_E_UNCLOSEDPI	= XML_E_INVALID_CDATACLOSINGTAG + 1,
	XML_E_UNCLOSEDSTARTTAG	= XML_E_UNCLOSEDPI + 1,
	XML_E_UNCLOSEDENDTAG	= XML_E_UNCLOSEDSTARTTAG + 1,
	XML_E_UNCLOSEDSTRING	= XML_E_UNCLOSEDENDTAG + 1,
	XML_E_UNCLOSEDCOMMENT	= XML_E_UNCLOSEDSTRING + 1,
	XML_E_UNCLOSEDDECL	= XML_E_UNCLOSEDCOMMENT + 1,
	XML_E_UNCLOSEDMARKUPDECL	= XML_E_UNCLOSEDDECL + 1,
	XML_E_UNCLOSEDCDATA	= XML_E_UNCLOSEDMARKUPDECL + 1,
	XML_E_BADDECLNAME	= XML_E_UNCLOSEDCDATA + 1,
	XML_E_BADEXTERNALID	= XML_E_BADDECLNAME + 1,
	XML_E_BADELEMENTINDTD	= XML_E_BADEXTERNALID + 1,
	XML_E_RESERVEDNAMESPACE	= XML_E_BADELEMENTINDTD + 1,
	XML_E_EXPECTING_VERSION	= XML_E_RESERVEDNAMESPACE + 1,
	XML_E_EXPECTING_ENCODING	= XML_E_EXPECTING_VERSION + 1,
	XML_E_EXPECTING_NAME	= XML_E_EXPECTING_ENCODING + 1,
	XML_E_UNEXPECTED_ATTRIBUTE	= XML_E_EXPECTING_NAME + 1,
	XML_E_ENDTAGMISMATCH	= XML_E_UNEXPECTED_ATTRIBUTE + 1,
	XML_E_INVALIDENCODING	= XML_E_ENDTAGMISMATCH + 1,
	XML_E_INVALIDSWITCH	= XML_E_INVALIDENCODING + 1,
	XML_E_EXPECTING_NDATA	= XML_E_INVALIDSWITCH + 1,
	XML_E_INVALID_MODEL	= XML_E_EXPECTING_NDATA + 1,
	XML_E_INVALID_TYPE	= XML_E_INVALID_MODEL + 1,
	XML_E_INVALIDXMLSPACE	= XML_E_INVALID_TYPE + 1,
	XML_E_MULTI_ATTR_VALUE	= XML_E_INVALIDXMLSPACE + 1,
	XML_E_INVALID_PRESENCE	= XML_E_MULTI_ATTR_VALUE + 1,
	XML_E_BADXMLCASE	= XML_E_INVALID_PRESENCE + 1,
	XML_E_CONDSECTINSUBSET	= XML_E_BADXMLCASE + 1,
	XML_E_CDATAINVALID	= XML_E_CONDSECTINSUBSET + 1,
	XML_E_INVALID_STANDALONE	= XML_E_CDATAINVALID + 1,
	XML_E_UNEXPECTED_STANDALONE	= XML_E_INVALID_STANDALONE + 1,
	XML_E_DOCTYPE_IN_DTD	= XML_E_UNEXPECTED_STANDALONE + 1,
	XML_E_MISSING_ENTITY	= XML_E_DOCTYPE_IN_DTD + 1,
	XML_E_ENTITYREF_INNAME	= XML_E_MISSING_ENTITY + 1,
	XML_E_DOCTYPE_OUTSIDE_PROLOG	= XML_E_ENTITYREF_INNAME + 1,
	XML_E_INVALID_VERSION	= XML_E_DOCTYPE_OUTSIDE_PROLOG + 1,
	XML_E_DTDELEMENT_OUTSIDE_DTD	= XML_E_INVALID_VERSION + 1,
	XML_E_DUPLICATEDOCTYPE	= XML_E_DTDELEMENT_OUTSIDE_DTD + 1,
	XML_E_RESOURCE	= XML_E_DUPLICATEDOCTYPE + 1,
	XML_E_LASTERROR	= XML_E_RESOURCE + 1
    }	XML_ERROR_CODE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0004
    {	XMLPARSER_IDLE	= 0,
	XMLPARSER_WAITING	= XMLPARSER_IDLE + 1,
	XMLPARSER_BUSY	= XMLPARSER_WAITING + 1,
	XMLPARSER_ERROR	= XMLPARSER_BUSY + 1,
	XMLPARSER_STOPPED	= XMLPARSER_ERROR + 1,
	XMLPARSER_SUSPENDED	= XMLPARSER_STOPPED + 1
    }	XML_PARSER_STATE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0005
    {	XMLFLAG_FLOATINGAMP	= 1,
	XMLFLAG_SHORTENDTAGS	= 2,
	XMLFLAG_CASEINSENSITIVE	= 4,
	XMLFLAG_NONAMESPACES	= 8,
	XMLFLAG_NOWHITESPACE	= 16,
	XMLFLAG_IE4QUIRKS	= 32,
	XMLFLAG_NODTDNODES	= 64,
	XMLFLAG_IE4COMPATIBILITY	= 255
    }	XML_PARSER_FLAGS;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0006
    {	XMLNF_STARTDOCUMENT	= 0,
	XMLNF_STARTDTD	= XMLNF_STARTDOCUMENT + 1,
	XMLNF_ENDDTD	= XMLNF_STARTDTD + 1,
	XMLNF_STARTDTDSUBSET	= XMLNF_ENDDTD + 1,
	XMLNF_ENDDTDSUBSET	= XMLNF_STARTDTDSUBSET + 1,
	XMLNF_ENDPROLOG	= XMLNF_ENDDTDSUBSET + 1,
	XMLNF_STARTENTITY	= XMLNF_ENDPROLOG + 1,
	XMLNF_ENDENTITY	= XMLNF_STARTENTITY + 1,
	XMLNF_ENDDOCUMENT	= XMLNF_ENDENTITY + 1,
	XMLNF_DATAAVAILABLE	= XMLNF_ENDDOCUMENT + 1
    }	XML_NODEFACTORY_EVENT;

typedef struct  _XML_NODE_INFO
    {
    DWORD dwSize;
    DWORD dwType;
    DWORD dwSubType;
    BOOL fTerminal;
    const WCHAR __RPC_FAR *pwcText;
    ULONG ulLen;
    ULONG ulNsPrefixLen;
    PVOID pNode;
    PVOID pReserved;
    }	XML_NODE_INFO;



extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_v0_0_s_ifspec;


#ifndef __XMLPSR_LIBRARY_DEFINED__
#define __XMLPSR_LIBRARY_DEFINED__

/* library XMLPSR */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_XMLPSR;

#ifndef __IXMLNodeSource_INTERFACE_DEFINED__
#define __IXMLNodeSource_INTERFACE_DEFINED__

/* interface IXMLNodeSource */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361d-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFactory( 
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFactory( 
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ BSTR bstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLineNumber( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLinePosition( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetAbsolutePosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLineBuffer( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastError( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetFlags( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetURL( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFactory )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFactory )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLineNumber )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLinePosition )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetAbsolutePosition )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineBuffer )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastError )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetURL )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        END_INTERFACE
    } IXMLNodeSourceVtbl;

    interface IXMLNodeSource
    {
        CONST_VTBL struct IXMLNodeSourceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLNodeSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLNodeSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLNodeSource_SetFactory(This,pNodeFactory)	\
    (This)->lpVtbl -> SetFactory(This,pNodeFactory)

#define IXMLNodeSource_GetFactory(This,ppNodeFactory)	\
    (This)->lpVtbl -> GetFactory(This,ppNodeFactory)

#define IXMLNodeSource_Abort(This,bstrErrorInfo)	\
    (This)->lpVtbl -> Abort(This,bstrErrorInfo)

#define IXMLNodeSource_GetLineNumber(This)	\
    (This)->lpVtbl -> GetLineNumber(This)

#define IXMLNodeSource_GetLinePosition(This)	\
    (This)->lpVtbl -> GetLinePosition(This)

#define IXMLNodeSource_GetAbsolutePosition(This)	\
    (This)->lpVtbl -> GetAbsolutePosition(This)

#define IXMLNodeSource_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)

#define IXMLNodeSource_GetLastError(This)	\
    (This)->lpVtbl -> GetLastError(This)

#define IXMLNodeSource_GetErrorInfo(This,pbstrErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo)

#define IXMLNodeSource_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IXMLNodeSource_GetURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetURL(This,ppwcBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLNodeSource_SetFactory_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);


void __RPC_STUB IXMLNodeSource_SetFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetFactory_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);


void __RPC_STUB IXMLNodeSource_GetFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_Abort_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [in] */ BSTR bstrErrorInfo);


void __RPC_STUB IXMLNodeSource_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetLineNumber_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetLinePosition_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLinePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetAbsolutePosition_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetAbsolutePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetLineBuffer_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
    /* [out] */ ULONG __RPC_FAR *pulLen,
    /* [out] */ ULONG __RPC_FAR *pulStartPos);


void __RPC_STUB IXMLNodeSource_GetLineBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetLastError_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLastError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetErrorInfo_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);


void __RPC_STUB IXMLNodeSource_GetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetFlags_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetURL_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);


void __RPC_STUB IXMLNodeSource_GetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLNodeSource_INTERFACE_DEFINED__ */


#ifndef __IXMLParser_INTERFACE_DEFINED__
#define __IXMLParser_INTERFACE_DEFINED__

/* interface IXMLParser */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361e-51a0-11d2-9caf-0060b0ec3d39")
    IXMLParser : public IXMLNodeSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetURL( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInput( 
            /* [in] */ IUnknown __RPC_FAR *pStm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PushData( 
            /* [in] */ const char __RPC_FAR *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadDTD( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExpandEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRoot( 
            /* [in] */ PVOID pRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRoot( 
            /* [in] */ PVOID __RPC_FAR *ppRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( 
            /* [in] */ long lChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParserState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG iFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSecureBaseURL( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecureBaseURL( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFactory )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFactory )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLineNumber )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLinePosition )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetAbsolutePosition )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineBuffer )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastError )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetURL )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetURL )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInput )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pStm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PushData )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const char __RPC_FAR *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadDTD )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExpandEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRoot )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ PVOID pRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRoot )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ PVOID __RPC_FAR *ppRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Run )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ long lChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParserState )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Suspend )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFlags )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ ULONG iFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSecureBaseURL )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSecureBaseURL )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        END_INTERFACE
    } IXMLParserVtbl;

    interface IXMLParser
    {
        CONST_VTBL struct IXMLParserVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLParser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLParser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLParser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLParser_SetFactory(This,pNodeFactory)	\
    (This)->lpVtbl -> SetFactory(This,pNodeFactory)

#define IXMLParser_GetFactory(This,ppNodeFactory)	\
    (This)->lpVtbl -> GetFactory(This,ppNodeFactory)

#define IXMLParser_Abort(This,bstrErrorInfo)	\
    (This)->lpVtbl -> Abort(This,bstrErrorInfo)

#define IXMLParser_GetLineNumber(This)	\
    (This)->lpVtbl -> GetLineNumber(This)

#define IXMLParser_GetLinePosition(This)	\
    (This)->lpVtbl -> GetLinePosition(This)

#define IXMLParser_GetAbsolutePosition(This)	\
    (This)->lpVtbl -> GetAbsolutePosition(This)

#define IXMLParser_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)

#define IXMLParser_GetLastError(This)	\
    (This)->lpVtbl -> GetLastError(This)

#define IXMLParser_GetErrorInfo(This,pbstrErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo)

#define IXMLParser_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IXMLParser_GetURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetURL(This,ppwcBuf)


#define IXMLParser_SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)	\
    (This)->lpVtbl -> SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)

#define IXMLParser_Load(This,fFullyAvailable,pimkName,pibc,grfMode)	\
    (This)->lpVtbl -> Load(This,fFullyAvailable,pimkName,pibc,grfMode)

#define IXMLParser_SetInput(This,pStm)	\
    (This)->lpVtbl -> SetInput(This,pStm)

#define IXMLParser_PushData(This,pData,ulChars,fLastBuffer)	\
    (This)->lpVtbl -> PushData(This,pData,ulChars,fLastBuffer)

#define IXMLParser_LoadDTD(This,pszBaseUrl,pszRelativeUrl)	\
    (This)->lpVtbl -> LoadDTD(This,pszBaseUrl,pszRelativeUrl)

#define IXMLParser_LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)	\
    (This)->lpVtbl -> LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)

#define IXMLParser_ParseEntity(This,pwcText,ulLen,fpe)	\
    (This)->lpVtbl -> ParseEntity(This,pwcText,ulLen,fpe)

#define IXMLParser_ExpandEntity(This,pwcText,ulLen)	\
    (This)->lpVtbl -> ExpandEntity(This,pwcText,ulLen)

#define IXMLParser_SetRoot(This,pRoot)	\
    (This)->lpVtbl -> SetRoot(This,pRoot)

#define IXMLParser_GetRoot(This,ppRoot)	\
    (This)->lpVtbl -> GetRoot(This,ppRoot)

#define IXMLParser_Run(This,lChars)	\
    (This)->lpVtbl -> Run(This,lChars)

#define IXMLParser_GetParserState(This)	\
    (This)->lpVtbl -> GetParserState(This)

#define IXMLParser_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IXMLParser_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IXMLParser_SetFlags(This,iFlags)	\
    (This)->lpVtbl -> SetFlags(This,iFlags)

#define IXMLParser_SetSecureBaseURL(This,pszBaseUrl)	\
    (This)->lpVtbl -> SetSecureBaseURL(This,pszBaseUrl)

#define IXMLParser_GetSecureBaseURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetSecureBaseURL(This,ppwcBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLParser_SetURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
    /* [in] */ BOOL fAsync);


void __RPC_STUB IXMLParser_SetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Load_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ BOOL fFullyAvailable,
    /* [in] */ IMoniker __RPC_FAR *pimkName,
    /* [in] */ LPBC pibc,
    /* [in] */ DWORD grfMode);


void __RPC_STUB IXMLParser_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetInput_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pStm);


void __RPC_STUB IXMLParser_SetInput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_PushData_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const char __RPC_FAR *pData,
    /* [in] */ ULONG ulChars,
    /* [in] */ BOOL fLastBuffer);


void __RPC_STUB IXMLParser_PushData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_LoadDTD_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl);


void __RPC_STUB IXMLParser_LoadDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_LoadEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
    /* [in] */ BOOL fpe);


void __RPC_STUB IXMLParser_LoadEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_ParseEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwcText,
    /* [in] */ ULONG ulLen,
    /* [in] */ BOOL fpe);


void __RPC_STUB IXMLParser_ParseEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_ExpandEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwcText,
    /* [in] */ ULONG ulLen);


void __RPC_STUB IXMLParser_ExpandEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetRoot_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ PVOID pRoot);


void __RPC_STUB IXMLParser_SetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetRoot_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ PVOID __RPC_FAR *ppRoot);


void __RPC_STUB IXMLParser_GetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Run_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ long lChars);


void __RPC_STUB IXMLParser_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetParserState_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_GetParserState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Suspend_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Reset_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetFlags_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ ULONG iFlags);


void __RPC_STUB IXMLParser_SetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetSecureBaseURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl);


void __RPC_STUB IXMLParser_SetSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetSecureBaseURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);


void __RPC_STUB IXMLParser_GetSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLParser_INTERFACE_DEFINED__ */


#ifndef __IXMLNodeFactory_INTERFACE_DEFINED__
#define __IXMLNodeFactory_INTERFACE_DEFINED__

/* interface IXMLNodeFactory */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361f-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyEvent( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginChildren( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndChildren( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Error( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNode( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLNodeFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLNodeFactory __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyEvent )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginChildren )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndChildren )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Error )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNode )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);
        
        END_INTERFACE
    } IXMLNodeFactoryVtbl;

    interface IXMLNodeFactory
    {
        CONST_VTBL struct IXMLNodeFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLNodeFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLNodeFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLNodeFactory_NotifyEvent(This,pSource,iEvt)	\
    (This)->lpVtbl -> NotifyEvent(This,pSource,iEvt)

#define IXMLNodeFactory_BeginChildren(This,pSource,pNodeInfo)	\
    (This)->lpVtbl -> BeginChildren(This,pSource,pNodeInfo)

#define IXMLNodeFactory_EndChildren(This,pSource,fEmpty,pNodeInfo)	\
    (This)->lpVtbl -> EndChildren(This,pSource,fEmpty,pNodeInfo)

#define IXMLNodeFactory_Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo)	\
    (This)->lpVtbl -> Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo)

#define IXMLNodeFactory_CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo)	\
    (This)->lpVtbl -> CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLNodeFactory_NotifyEvent_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ XML_NODEFACTORY_EVENT iEvt);


void __RPC_STUB IXMLNodeFactory_NotifyEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_BeginChildren_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);


void __RPC_STUB IXMLNodeFactory_BeginChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_EndChildren_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ BOOL fEmpty,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);


void __RPC_STUB IXMLNodeFactory_EndChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_Error_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ HRESULT hrErrorCode,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);


void __RPC_STUB IXMLNodeFactory_Error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_CreateNode_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ PVOID pNodeParent,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);


void __RPC_STUB IXMLNodeFactory_CreateNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLNodeFactory_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_XMLParser;

#ifdef __cplusplus

class DECLSPEC_UUID("d2423620-51a0-11d2-9caf-0060b0ec3d39")
XMLParser;
#endif
#endif /* __XMLPSR_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\xmllib\xml\xmlstream\bufferedstream.cxx ===
/*
* 
* Copyright (c) 1998,1999 Microsoft Corporation. All rights reserved.
* EXEMPT: copyright change only, no build required
* 
*/
#include "stdafx.h"

#pragma hdrstop
// FA
#define new_ne new

#include <memory.h> // memmove.

// #include <shlwapip.h>   // IsCharSpace
#ifdef UNIX
// Not needed under UNIX
#else
#ifndef _WIN64
// #include <w95wraps.h>
#endif // _WIN64
#endif /* UNIX */

#include "..\..\core\util\chartype.hxx" // isWhiteSpace

#include "../tokenizer/encoder/encodingstream.hxx"
#include "bufferedstream.hxx"
#include "xmlstream.hxx"
#include "../tokenizer/xmlparser.h"

const long BLOCK_SIZE = 4096;

// no point remembering a line buffer longer than this because client
// probably can't deal with that anyway.
const long MAX_LINE_BUFFER = 512;

// #define checkhr2(a) hr = a; if (hr != S_OK) return hr;

BufferedStream::BufferedStream(XMLStream *pXMLStream)
{
    _pchBuffer = NULL;
    _lSize = 0;
    _pXMLStream = pXMLStream;
    init();
}

void BufferedStream::init()
{
    _lCurrent = _lUsed = _lMark = 0;
    _lLine = 1; // lines start at 1.
    _lMarkedline = 1;
    _lLinepos = 0;
    _lMarkedlinepos = 0;
    _chLast = 0;
    _lStartAt = 0;
    _fEof = false;
    _lLockedPos = -1;
    _lLastWhiteSpace = -1;
    _lLockCount = 0;
    _fNotified = false;
    _fFrozen = false;
//    _pPendingEncoding = NULL;
}

BufferedStream::~BufferedStream()
{
    delete [] _pchBuffer;
    _pStmInput = NULL;
//    delete _pPendingEncoding;
//    _pPendingEncoding = NULL;
}

HRESULT BufferedStream::Reset()
{
    init();
    delete[] _pchBuffer;
    _pchBuffer = NULL;
    _lSize = 0;
    _pStmInput = NULL;
    _lLockedPos = -1;
    _lLockCount = 0;
    _fFrozen = false;
//    delete _pPendingEncoding;
//    _pPendingEncoding = NULL;
    return S_OK;
}

HRESULT  
BufferedStream::Load( 
        /* [unique][in] */ EncodingStream __RPC_FAR *pStm)
{
    if (pStm != NULL)
    {
        init();
        _pStmInput = pStm;
        return S_OK;
    }
    else
    {
        _pStmInput = NULL;
    }
    return S_OK;
}

WCHAR*  
BufferedStream::getEncoding()
{   
    if (!_pStmInput)
        return NULL;
    else
    {
        Encoding* e = _pStmInput->getEncoding();
        if (e == NULL)
        {
            fillBuffer();
        }
        e = _pStmInput->getEncoding();
        return (e == NULL) ? NULL : e->charset;
    }
}


HRESULT 
BufferedStream::AppendData( const BYTE* in, ULONG length, BOOL lastBuffer)
{
    HRESULT hr;

    if (_fEof)
    {
        init();
    }

#if 0 // FA
    if (!_pStmInput)
    {
        EncodingStream* stream = (EncodingStream*)EncodingStream::newEncodingStream(NULL); 
        if (stream == NULL)
            return E_OUTOFMEMORY;
        _pStmInput = stream;
        stream->Release(); // Smart pointer is holding a ref
    }
    checkhr2(_pStmInput->AppendData(in, length, lastBuffer));
#endif // FA

    return S_OK;

}

HRESULT  
BufferedStream::nextChar( 
        /* [out] */ WCHAR* ch,
        /* [out] */ bool* fEOF)
{
    HRESULT hr;

    if (_lCurrent >= _lUsed)
    {
        if (_fEof)
        {
            *fEOF = true;
            return S_OK;
        }
        if (! _fNotified && _lUsed > 0)
        {
            _fNotified = true;          // notify data available BEFORE blowing

            // NOTE: this code approximates what prepareForInput does
            // in order to accurately predict when the buffer is about to
            // be re-allocated.

            long shift = _fFrozen ? 0 : getNewStart(); // is data about to shift?
            long used = _lUsed - shift; // this is how much is really used after shift
            if (_lSize - used < BLOCK_SIZE + 1) // +1 for null termination.
            {
                // we will reallocate !!  So return a special
                // return code
                hr = E_DATA_REALLOCATE;
            }
            else
                hr = E_DATA_AVAILABLE;    // away the old data so parser can save it if need be.
            checkhr2( _pXMLStream->ErrorCallback(hr) );
        }                   

        checkhr2( fillBuffer() );
        if (_fEof)
        {
            *fEOF = true;
            return S_OK;
        }
        _fNotified = false;
    }

    WCHAR result = _pchBuffer[_lCurrent++];

    switch (result)
    {
    case 0xa:
    case 0xd:
        if (result == 0xd || _chLast != 0xd)
            _lLine++; 
        _lLinepos = _lCurrent;
        _chLast = result;
        _lLastWhiteSpace = _lCurrent;
        break;
    case 0x20:
    case 0x9:
        _lLastWhiteSpace = _lCurrent;
        break;
    case 0xfffe:
    case 0xffff:
        return XML_E_BADCHARDATA;
    }

    *ch = result;
    return S_OK;
}

HRESULT BufferedStream::scanPCData( 
    /* [out] */ WCHAR* ch,
    /* [out] */ bool* fWhitespace)
{
    WCHAR result;
    bool foundNonWhiteSpace = false;

    if (! isWhiteSpace(*ch))
        foundNonWhiteSpace = true;

    // Then skip the data until we find '<', '>' or '&'
    while (_lCurrent < _lUsed)
    {
        result = _pchBuffer[_lCurrent++];

        switch (result)
        {
        case ']':
        case '>':
        case '<':
        case '&':
        case '\'':  // so this can be used to scan attribute values also.
        case '"':   // so this can be used to scan attribute values also.
            *ch = result;
            if (foundNonWhiteSpace)
                *fWhitespace = false;
            return S_OK;
            break;

        case 0xa:
        case 0xd:
            if (result == 0xd || _chLast != 0xd)
                _lLine++; 
            _lLinepos = _lCurrent;
            _chLast = result;
            _lLastWhiteSpace = _lCurrent;
            break;
        case 0x20:
        case 0x9:
            _lLastWhiteSpace = _lCurrent;
            break;
        case 0xfffe:
        case 0xffff:
            return XML_E_BADCHARDATA;
        default:
            foundNonWhiteSpace = true;
            break;
        }
    }

    // And just return E_PENDING if we run out of buffer.
    if (foundNonWhiteSpace)
        *fWhitespace = false;
    return E_PENDING;
}

long BufferedStream::getLine() 
{ 
    return _lMarkedline; 
}

long BufferedStream::getLinePos() 
{
    // _lMarkedlinepos is the position of the beginning of the marked line
    // relative to the beginning of the buffer, and _lMark is the 
    // position of the marked token relative to the beginning of the
    // buffer, So the position of the marked token relative to the 
    // current line is the difference between the two.
    // We also return a 1-based position so that the start of the
    // line = column 1.  This is consistent with the line numbers
    // which are also 1-based.
    return (_lMarkedlinepos > _lMark+1) ? 0 : _lMark+1-_lMarkedlinepos; 
}

long BufferedStream::getInputPos()
{
    return _lStartAt+_lMark;
}

WCHAR* BufferedStream::getLineBuf(ULONG* len, ULONG* startpos)
{
    *len = 0;
    if (_pchBuffer == NULL)
        return NULL;

    WCHAR* result = &_pchBuffer[_lMarkedlinepos];

    ULONG i = 0;
    // internal _pchBuffer is guarenteed to be null terminated.
    WCHAR ch = result[i];
    while (ch != 0 && ch != L'\n' && ch != L'\r')
    {
        i++;
        ch = result[i];
    }
    *len = i;
    // also return the line position relative to start of
    // returned buffer.
    *startpos = (_lMarkedlinepos > _lMark+1) ? 0 : _lMark+1-_lMarkedlinepos; 
    return result;
}

#if 0
HRESULT BufferedStream::switchEncoding(const TCHAR * charset, ULONG len)
{
    HRESULT hr = S_OK;

    if (!_pStmInput)
    {
        hr = E_FAIL;
        goto CleanUp;
    }
    else
    {
        _pPendingEncoding = Encoding::newEncoding(charset, len);
        if (_pPendingEncoding == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto CleanUp;
        }

        if (! _fFrozen)
        {
             hr = doSwitchEncoding();
        }
    }
CleanUp:
    return hr;
}

HRESULT BufferedStream::doSwitchEncoding()
{
    Encoding* encoding = _pPendingEncoding;
    _pPendingEncoding = NULL;

    HRESULT hr = _pStmInput->switchEncodingAt(encoding, _lStartAt + _lCurrent);
    if (hr == S_FALSE)
    {
        // need to re-read to force re-decode into new encoding.
        // In other words we have to forget that we read past this
        // position already so that the next call to nextChar
        // will call FillBuffer again.
        // (+1 so that nextChar works correctly).
        _lUsed = _lStartAt + _lCurrent;
        hr = S_OK;
    }
    else if (FAILED(hr))
    {
        hr = (hr == E_INVALIDARG) ? XML_E_INVALIDENCODING : XML_E_INVALIDSWITCH;
    }
    return hr;
}
#endif

// Returns a pointer to a contiguous block of text accumulated 
// from the last time Mark() was called up to but not including
// the last character read. (This allows a parser to have a
// lookahead character that is not included in the token).
HRESULT  
BufferedStream::getToken(const WCHAR**p, long* len)
{
    if (_pchBuffer == NULL)
        return E_FAIL;

    if (_lCurrent != _lCurrent2)
    {
        // need to fix up buffer since it is no
        // out of sync since we've been compressing
        // whitespace.

    }
    *p = &_pchBuffer[_lMark];
    *len = getTokenLength();
    return S_OK;
}


void 
BufferedStream::Lock()
{
    // We allow nested locking - where the outer lock wins - unlock only 
    // really unlocks when the outer lock is unlocked.
    if (++_lLockCount == 1)
    {
        _lLockedPos = _lMark;
        _lLockedLine = _lMarkedline;
        _lLockedLinePos = _lMarkedlinepos;
    }
}

void 
BufferedStream::UnLock()
{
    if (--_lLockCount == 0)
    {
        _lMark = _lLockedPos;
        _lMarkedline = _lLockedLine;
        _lMarkedlinepos = _lLockedLinePos;
        _lLockedPos = -1;
    }
}

HRESULT 
BufferedStream::Freeze()
{
    HRESULT hr;
    if (_lCurrent > _lMidPoint)
    {
        // Since we freeze the buffer a lot now (any time we're inside
        // a tag) we need to shift the bytes down in the buffer more
        // frequently in order to guarentee we have space in the buffer
        // when we need it.  Otherwize the buffer would tend to just
        // keep growing and growing.  So we shift the buffer when we
        // go past the midpoint.
        checkhr2( prepareForInput() ); 
        
    }
    _fFrozen = true;
    return S_OK;
}

HRESULT 
BufferedStream::UnFreeze()
{
    _fFrozen = false;
#if 0
    if (_pPendingEncoding)
    {
        return doSwitchEncoding();
    }
#endif
    return S_OK;
}


HRESULT 
BufferedStream::fillBuffer()
{
    HRESULT hr;
    
    checkhr2( prepareForInput() ); 

    if (_pStmInput)
    {
        long space = _lSize - _lUsed - 1; // reserve 1 for NULL termination

        // get more bytes.
        ULONG read = 0;
        HRESULT rc = _pStmInput->Read(&_pchBuffer[_lUsed], space*sizeof(WCHAR), &read);

        _lUsed += read/sizeof(WCHAR); // stream must return unicode characters.
       _pchBuffer[_lUsed] = 0; // NULL terminate the _pchBuffer.

        if (FAILED(rc))
            return rc;

        if (read == 0)
        {
            _fEof = true;
            // increment _lCurrent, so that getToken returns
            // last character in file.
            _lCurrent++; _lCurrent2++;
        }
    }
    else
    {
        // SetInput or AppendData hasn't been called yet.
        return E_PENDING;
    }

    return S_OK;
}

HRESULT 
BufferedStream::prepareForInput()
{
    // move the currently used section of the _pchBuffer 
    // (buf[mark] to buf[used]) down to the beginning of
    // the _pchBuffer.

    long newstart = 0;

    // BUGBUG - if this code is changed BufferedStream::nextChar has to
    // be updated also so that they stay in sync, otherwise we might
    // re-allocated the buffer without generating an E_DATA_REALLOCATE
    // notification - which would be very bad (causes GPF's in the parser).

    if (! _fFrozen)  // can't shift bits if the buffer is frozen.
    {
        newstart = getNewStart();

        if (newstart > 0)
        {
            WCHAR* src = &_pchBuffer[newstart];
            _lUsed -= newstart;
            _lStartAt += newstart;
            ::memmove(_pchBuffer,src,_lUsed*sizeof(WCHAR));
            _lCurrent -= newstart;
            _lCurrent2 -= newstart;
            _lLastWhiteSpace -= newstart;
            _lLinepos = (_lLinepos > newstart) ? _lLinepos-newstart : 0;
            _lMarkedlinepos = (_lLinepos > newstart) ? _lMarkedlinepos-newstart : 0;
            _lMark -= newstart;
            _lLockedLinePos = (_lLockedLinePos > newstart) ? _lLockedLinePos-newstart : 0;
            _lLockedPos -= newstart;
        }
    }

    // make sure we have a reasonable amount of space
    // left in the _pchBuffer.
    long space = _lSize - _lUsed; 
    if (space > 0) space--; // reserve 1 for NULL termination
    if (_pchBuffer == NULL || space < BLOCK_SIZE)
    {
        // double the size of the buffer.
		long newsize = (_lSize == 0) ? BLOCK_SIZE : (_lSize*2);

        WCHAR* newbuf = new_ne WCHAR[newsize];
        if (newbuf == NULL)
        {
            // try more conservative allocation.
            newsize = _lSize + BLOCK_SIZE;
            newbuf = new_ne WCHAR[newsize];
        }
        if (newbuf == NULL && space == 0)
            return E_OUTOFMEMORY;

        if (newbuf != NULL)
        {
            if (_pchBuffer != NULL)
            {
                // copy old bytes to new _pchBuffer.
                ::memcpy(newbuf,_pchBuffer,_lUsed*sizeof(WCHAR));
                delete [] _pchBuffer;
            }
            newbuf[_lUsed] = 0; // make sure it's null terminated.
            _pchBuffer = newbuf;
            _lSize = newsize;
            _lMidPoint = newsize / 2;

        }
    }

    return S_OK;
}

long
BufferedStream::getNewStart()
{
    long newstart = 0;

    // Unless the buffer is frozen, in which case we just reallocate and
    // do no shifting of data.
    if (_lLockedPos > 0)
    {
        // and try and preserve the beginning of the marked line if we can
        if (_lLockedLinePos < _lLockedPos && 
            _lLockedPos - _lLockedLinePos < MAX_LINE_BUFFER)
        {
            newstart = _lLockedLinePos;
        }
    }
    else if (_lMark > 0)
    {
        // and try and preserve the beginning of the marked line if we can
        newstart = _lMark;
        if (_lMarkedlinepos < _lMark && 
            _lMark - _lMarkedlinepos < MAX_LINE_BUFFER) // watch out for long lines
        {
            newstart = _lMarkedlinepos;
        }
    }
    return newstart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\xmllib\xml\tokenizer\parser\xmlparser.cxx ===
/*
* 
* Copyright (c) 1998,1999 Microsoft Corporation. All rights reserved.
* EXEMPT: copyright change only, no build required
* 
*/
#include "stdafx.h"
#include <shlwapi.h>    // StrCmpNI

#if 0
#include "core.hxx"
#pragma hdrstop
#endif

#include "xmlparser.hxx"
#include "../../xmlstream/xmlstream.hxx"
#include "../../../core/util/chartype.hxx"

#if 0

    #include "../net/urlstream.hxx"
    #include "datatype.hxx"
    #include "chartype.hxx"

    // For message formatting...
    #include "core/lang/string.hxx"
    #include "core/util/resources.hxx"

    #include <objbase.h>

#endif

#if _FA
DeclareTag(tagParserCallback, "XML Parser", "callbacks");
DeclareTag(tagParserError, "XML Parser", "errors");
#endif

#define CRITICALSECTIONLOCK CSLock lock(&_cs);
// FA
#define STACK_ENTRY_MODEL(f)
#undef CRITICALSECTIONLOCK
#define CRITICALSECTIONLOCK
#define STACK_ENTRY
#define TraceTag(z) 0?0:0
#define Assert(x)
#define new_ne new

extern HRESULT UrlOpenAllowed(LPCWSTR pwszUrl, LPCWSTR pwszBaseUrl, BOOL fDTD);

#ifdef UNIX
#ifndef POSSIBLY_FOSSIL_CODE
// This was a hack to fix this calling the wrong delete
// REVIEW BUGBUG
void XMLParser::operator delete( void * p )
{
    MemFree( p );
}
#endif // FOSSIL_CODE
#endif // UNIX

//extern char* WideToAscii(const WCHAR* string);

// --------------------------------------------------------------------
// A little helper class for setting a boolean flag and clearing it
// on destruction.
class BoolLock
{
    bool* _pFlag;
public:
    BoolLock(bool* pFlag)
    {
        _pFlag = pFlag;
        *pFlag = true;
    }
    ~BoolLock()
    {
        *_pFlag = false;
    }
};

#define breakhr(a) hr = (a); if (hr != S_OK) break;
extern HINSTANCE g_hInstance;

extern "C"{

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

};

// Since we cannot use the SHLWAPI wnsprintfA function...
int DecimalToBuffer(long value, char* buffer, int j, long maxdigits)
{
    long max = 1;
    for (int k = 0; k < maxdigits; k++)
        max = max * 10;
    if (value > (max*10)-1)
        value = (max*10)-1;
    max = max/10;
    for (int i = 0; i < maxdigits; i++)
    {
        long digit = (value / max);
        value -= (digit * max);
        max /= 10;
        buffer[i+j] = '0' + (char)digit;
    }
    buffer[i+j]=0;

    return i+j;
}

int StrToBuffer(const WCHAR* str, WCHAR* buffer, int j)
{
    while (*str != NULL)
    {
        buffer[j++] = *str++;
    }
    return j;
}

/*********
WCHAR* StringAdd(WCHAR* a, WCHAR* b)
{
    long len1 = _tcslen(a);
    long len2 = _tcslen(b);
    WCHAR* result = new_ne WCHAR[len1+len2+1];
    if (result != NULL)
    {
        ::memcpy(result, a, len1 * sizeof(WCHAR*));
        ::memcpy(&result[len1], b, len2 * sizeof(WCHAR*));
        result[len1+len2] = 0;
    }
    return result;
}
************/

#define PUSHNODEINFO(pNodeInfo)\
    if (_cNodeInfoAllocated == _cNodeInfoCurrent)\
    {\
        checkhr2(GrowNodeInfo());\
    }\
    _paNodeInfo[_cNodeInfoCurrent++] = _pCurrent;

#if 0
/************************  code bloat unacceptable ******************************
// ============ BEGIN HACK
// These are copied from messages.mc.  I have to do this because including messages.h
// would clash with <xmlparser.h>
//#define XML_I_LINENUMBER                 0x400CE590L
//#define XML_I_LINEPOSITION               0x400CE591L
// ============ END HACK

//==============================================================================
// This function calls FormatMessageA and converts the result to unicode.
// This is so that it works on Win95 !!
// For convenience the va_list of arguments are WCHAR arguments and this function
// converts them to ascii for you.
typedef char* PCHAR;

WCHAR* FormatMessageInternal(
    LPCVOID lpSource,  // pointer to message source
    DWORD dwMessageId,  // requested message identifier
    WCHAR* arg1, ...)  // variable list of args.
{
    // Caller assumes the arguments are wide chars, so now we have to convert
    // them to ascii.
    char* temp = NULL;
    DWORD rc = 0;
    WCHAR* result = NULL;
    PCHAR* args = NULL;
    int argcount = 0;
    int argsize = 0;
    va_list arglist;

    DWORD dwFlags = (lpSource == NULL) ? FORMAT_MESSAGE_FROM_SYSTEM : FORMAT_MESSAGE_FROM_HMODULE;
    dwFlags |= FORMAT_MESSAGE_ALLOCATE_BUFFER;

    // First we count number of args
    va_start(arglist, arg1);
    for (WCHAR* s = arg1; s; s = va_arg(arglist, WCHAR *))
    {
        argcount++;
    }
    va_end(arglist);
    va_start(arglist, arg1);

    // Then we pack the args into an array and convert them to ascii.
    if (argcount > 0)
    {
        dwFlags |= FORMAT_MESSAGE_ARGUMENT_ARRAY;
        args = new_ne PCHAR[argcount+1];
        if (args == NULL)
            goto CleanUp;

        argcount=0;
        for (WCHAR* s = arg1; s; s = va_arg(arglist, WCHAR *))
        {
            args[argcount] = WideToAscii(s);
            if (args[argcount] == NULL)
                goto CleanUp; // out of memory.
            argcount++;
        }
        args[argcount] = NULL; // NULL terminate the array of args.
    }

    rc = ::FormatMessageA(dwFlags, lpSource, dwMessageId,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPSTR)&temp, 0, args);

    if (rc > 0)
    {
        int length = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, temp, rc, NULL, 0);

        result = new_ne WCHAR[length+1];
        if (result == NULL)
            goto CleanUp;

        rc = ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, temp, rc, result, length);
        result[rc] = 0; // NULL terminate
    }

CleanUp:
    va_end(arglist);
    if (temp) ::LocalFree(temp);

    // Now delete the array of arguments that we converted to ascii.
    while (argcount > 0)
    {
        delete[] args[--argcount];
    }
    delete [] args;
    return result;
}
**********************/
#endif

const USHORT STACK_INCREMENT=10;

//------------------------------------------------------------------------
XMLParser::XMLParser()
:   _pDownloads(1), _pStack(STACK_INCREMENT)
//    ,_reThreadModel(MultiThread) // make sure this is thead safe (as it always has been in the past).
{
    ctorInit();
}

#ifdef RENTAL_MODEL
XMLParser::XMLParser(RentalEnum re)
: _pDownloads(1), _pStack(STACK_INCREMENT), _reThreadModel(re)
{
    ctorInit();
}
#endif

void
XMLParser::ctorInit()
{
    InitializeCriticalSection(&_cs);

    _pTokenizer = NULL;
    _pCurrent = NULL;
    _lCurrentElement = 0;
    _paNodeInfo = NULL;
    _cNodeInfoAllocated = _cNodeInfoCurrent = 0;
    _pdc = NULL;
    _usFlags = 0;
    _fCaseInsensitive = false;
    _bstrError = NULL;
//    _fTokenizerChanged = false;
    _fRunEntryCount = 0;
    _pszSecureBaseURL = NULL;
    _pszCurrentURL = NULL;
    _pszBaseURL = NULL;
    _fInLoading = false;
    _fInsideRun = false;
    _fFoundDTDAttribute = false;
    _cAttributes = 0;
    _pRoot = NULL;
    _fAttemptedURL = NULL;
    _fLastError = 0;
    _fStopped = false;
    _fSuspended = false;
    _fStarted = false;
    _fWaiting = false;
    _fIgnoreEncodingAttr = false;
    _dwSafetyOptions = 0;

//    ::IncrementComponents();

    // rest of initialization done in the init() method.

    //EnableTag(tagParserCallback, TRUE);
    //EnableTag(tagParserError, TRUE);
}

XMLParser::~XMLParser()
{
    {
//        CRITICALSECTIONLOCK;
        Reset();

        // Cleanup tagname buffers in context for good this time...
        for (long i = _pStack.size()-1; i>=0; i--)
        {
            MY_XML_NODE_INFO* pNodeInfo = _pStack[i];
            if (pNodeInfo->_pwcTagName != NULL)
            {
                delete [] pNodeInfo->_pwcTagName;
                pNodeInfo->_pwcTagName = NULL;
                pNodeInfo->_ulBufLen = 0;
            }
            // NULL out the node pointer in case it point's to a GC'd object :-)
            pNodeInfo->pNode = NULL;
        }
        delete _pszSecureBaseURL;
        delete _pszCurrentURL;

        delete[] _paNodeInfo;
//        ::DecrementComponents();
    }
    DeleteCriticalSection(&_cs);
}

HRESULT STDMETHODCALLTYPE
XMLParser::QueryInterface(REFIID riid, void ** ppvObject)
{
#if 0
//    STACK_ENTRY;
    // Since this one class implements both IXMLNodeSource and
    // IXMLParser, we must override QueryInterface since the
    // IUnknown template doesn't know about the IXMLNodeSource
    // interface.

    HRESULT hr = S_OK;
    if (riid == IID_IXMLNodeSource || riid == IID_Parser)
    {
        *ppvObject = static_cast<IXMLNodeSource*>(this);        
        AddRef();
    }
    else
    {
        hr = _unknown<IXMLParser, &IID_IXMLParser>::QueryInterface(riid, ppvObject);
    }
    return hr;
#endif
    return S_OK;
}

ULONG STDMETHODCALLTYPE
XMLParser::AddRef( void)
{
#if 0
    STACK_ENTRY;
    return _unknown<IXMLParser, &IID_IXMLParser>::AddRef();
#endif
    return S_OK;
}

ULONG STDMETHODCALLTYPE
XMLParser::Release( void)
{
#if 0
    STACK_ENTRY;
    return _unknown<IXMLParser, &IID_IXMLParser>::Release();
#endif
    return S_OK;
}

#define checknull(a) if (!(a)) { hr = E_OUTOFMEMORY; goto error; }

HRESULT STDMETHODCALLTYPE
XMLParser::SetURL(
            /* [in] */ const WCHAR* pszBaseUrl,
            /* [in] */ const WCHAR* pszRelativeUrl,
            /* [in] */ BOOL async)
{
//    CRITICALSECTIONLOCK;
    STACK_ENTRY_MODEL(_reThreadModel);

    return PushURL(pszBaseUrl, pszRelativeUrl,
                (async == TRUE),// async
                true,           // new tokenizer
                false,          // is dtd
                false,          // is entity
                false           // is parameter entity
             );
}

HRESULT
XMLParser::PushURL(
    /* [in] */ const WCHAR* pszBaseUrl,
    /* [in] */ const WCHAR* pszRelativeUrl,
    /* [in] */ bool async,
    /* [in] */ bool tokenizer,
    /* [in] */ bool dtd,
    /* [in] */ bool fentity,
    /* [in] */ bool fpe)
{
#if 0 // FA
    HRESULT hr = S_OK;
    URL url;
    URLStream* stream = NULL;
    const WCHAR* pszSecureBaseURL = NULL;

    if (NULL == pszRelativeUrl)
    {
        hr = E_INVALIDARG;
        goto cleanup;
    }

    if (_pDownloads.used() == 0)
        init();

    if (pszBaseUrl == NULL)
    {
        pszBaseUrl = _pszBaseURL;
    }

    stream = new_ne URLStream(this, dtd);
    if (stream == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    if (tokenizer)
    {
        checkerr(PushTokenizer(stream));
        if (dtd)
        {
            _pTokenizer->SetDTD(true);
        }
    }
    else
    {
        checkerr(PushDownload(stream, NULL));
    }
    _pdc->_fAsync = async;
    _pdc->_fDTD = dtd;
    _pdc->_fEntity = fentity;
    _pdc->_fPEReference = fpe;

    checknull(_pdc->_pURLStream);

    checkerr(url.set(pszRelativeUrl, _pszCurrentURL, pszBaseUrl));

    pszSecureBaseURL = getSecureBaseURL();
    if (! pszSecureBaseURL && _dwSafetyOptions) 
        pszSecureBaseURL = pszBaseUrl;
    checkerr(url.setSecureBase( pszSecureBaseURL )); // can be different from pszBaseUrl.

    checkerr(SetCurrentURL(url.getResolved()));

    _fInLoading = true;
    // WARNING: this must be done last because sometimes the callback bounces
    // right back immediately and calls Run() on the parser !!
    hr = _pdc->_pURLStream->Open(&url, async ? URLStream::ASYNCREAD : URLStream::SYNCREAD);
    _fInLoading = false;
    if (FAILED(hr))
    {
        _fAttemptedURL = ::SysAllocString(url.getRelative()); // save this for error info.
        goto error;
    }

    hr = S_OK;
    goto cleanup;
error:
    PopDownload();
cleanup:
    if (stream) stream->Release();
    _fLastError = hr;
    return hr;
#endif // FA
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
XMLParser::Load(
        /* [in] */ BOOL fFullyAvailable,
        /* [in] */ IMoniker __RPC_FAR *pimkName,
        /* [in] */ LPBC pibc,
        /* [in] */ DWORD grfMode)
{
#if 0 //FA
    STACK_ENTRY_MODEL(_reThreadModel);
    CRITICALSECTIONLOCK;

    HRESULT hr = S_OK;
    URL url;
    URLStream* stream = NULL;

    if (NULL == pimkName)
    {
        hr = E_INVALIDARG;
        goto cleanup;
    }

    if (_pDownloads.used()== 0)
        init();


    // In this case we register a special call back to pump
    // the parser during download.  Typically in this case the
    // caller also has a registered callback in order to monitor
    // the download progress.
    stream = new_ne URLStream(this);
    if (stream == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }
    checkerr(PushTokenizer(stream));

    checknull(_pdc->_pURLStream);

    checkerr(ExtractURL(pimkName, pibc, &url));

    _fInLoading = true;
    _pdc->_fAsync = true;

    // WARNING: this must be done last because sometimes the callback bounces
    // right back immediately and calls Run() on the parser !!
    hr = _pdc->_pURLStream->Open(pimkName, pibc, &url, URLStream::ASYNCREAD);

    _fInLoading = false;
    if (FAILED(hr))
    {
        _fAttemptedURL = ::SysAllocString(url.getRelative()); // save this for error info.
        goto error;
    }
    goto cleanup;
error:
    PopDownload();
cleanup:
    if (stream) stream->Release();
    return hr;
#endif // FA
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
XMLParser::LoadDTD(
            /* [in] */ const WCHAR* pszBaseUrl,
            /* [in] */ const WCHAR* pszRelativeUrl)
{
    HRESULT hr;
    STACK_ENTRY_MODEL(_reThreadModel);
    CRITICALSECTIONLOCK;
    BOOL async = FALSE;
    // If previous download is async, then make this one async too.
    if (_pdc && _pdc->_fAsync)
        async = TRUE;
    //
    // Have to do this first because PushURL may invoke another downloading and calls back to the parser immediately
    //
    _cDTD++;
    hr = _pFactory->NotifyEvent( this, XMLNF_STARTDTD);
    if (SUCCEEDED(hr))
    {
        hr = PushURL(pszBaseUrl, pszRelativeUrl,
                (async == TRUE),// async
                true,           // new tokenizer
                true,           // is dtd
                false,          // is entity
                false           // is parameter entity
             );
        _fTokenizerChanged = false;
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE
XMLParser::SetInput(
            /* [in] */ IUnknown __RPC_FAR *pStm)
{
    if (pStm == NULL)
        return E_INVALIDARG;

    STACK_ENTRY_MODEL(_reThreadModel);
    CRITICALSECTIONLOCK;
    if (_pDownloads.used() == 0)
        init();
    HRESULT hr = S_OK;

    checkhr2(PushTokenizer(NULL));

    // Get the url path
    // Continue even if we cannot get it
    STATSTG stat;
    IStream * pStream = NULL;
    memset(&stat, 0, sizeof(stat));
    hr = pStm->QueryInterface(IID_IStream, (void**)&pStream);
    if (SUCCEEDED(hr))
    {
        hr = pStream->Stat(&stat, 0);
        if (SUCCEEDED(hr) && stat.pwcsName != NULL)
        {
            SetCurrentURL(stat.pwcsName);
#if 0 // FA URL
            WCHAR* pszSecureBaseURL = getSecureBaseURL();
            if (*stat.pwcsName != 0 && pszSecureBaseURL != NULL && *pszSecureBaseURL != 0)
            {
                // Then we can apply security to IStream also - but first we have
                // to turn the pwcsName into a valid URL.
                // BUGBUG - If we can't make a valid URL then we can't verify security.
                URL url;
                url.set(stat.pwcsName,NULL,NULL);
                hr = UrlOpenAllowed(url.getResolved(), pszSecureBaseURL, FALSE);
            }
            CoTaskMemFree(stat.pwcsName);
#endif // FA URL
        }
        else
        {
            hr = S_OK; // we don't care if stat fails.
        }
        if (SUCCEEDED(hr))
        {
            hr = PushStream(pStream, false);
        }
        pStream->Release();
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE
XMLParser::PushData(
#ifdef UNIX
            //
            // The IDL compiler under Unix is outputting a
            // /* [in] */ const unsigned char *pData,
            // instead of
            // /* [in] */ const char *pData,
            // See also xmlparser.hxx
            //
            /* [in] */ const unsigned char *pData,
#else
            /* [in] */ const char __RPC_FAR *pData,
#endif
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer)
{
    STACK_ENTRY_MODEL(_reThreadModel);
    CRITICALSECTIONLOCK;
    HRESULT hr=S_OK;

    if (NULL == pData && (ulChars != 0))
    {
        return E_INVALIDARG;
    }

    if (_pTokenizer == NULL)
    {
        init();
        checkhr2(PushTokenizer(NULL));
    }
    return _pTokenizer->AppendData((const BYTE*)pData, ulChars, fLastBuffer);
}

HRESULT STDMETHODCALLTYPE
XMLParser::LoadEntity(
    /* [in] */ const WCHAR* pszBaseUrl,
    /* [in] */ const WCHAR* pszRelativeUrl,
    /* [in] */ BOOL fpe)
{
    STACK_ENTRY_MODEL(_reThreadModel);
    CRITICALSECTIONLOCK;
    HRESULT hr;
    BOOL async = FALSE;
    // If previous download is async, then make this one async too.
    if (_pdc && _pdc->_fAsync)
        async = TRUE;
    // then text is just a string that needs to be parsed.
    hr = PushURL(pszBaseUrl, pszRelativeUrl,
                (async == TRUE),// async
                (fpe != TRUE),  // new tokenizer
                (fpe == TRUE),  // is dtd
                true,           // is entity
                (fpe == TRUE)   // is parameter entity
             );
    if (hr == S_OK)
    {
        hr = _pFactory->NotifyEvent(this, XMLNF_STARTENTITY);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE
XMLParser::ParseEntity(
    /* [in] */ const WCHAR* pwcText,
    /* [in] */ ULONG ulLen,
    /* [in] */ BOOL fpe)
{
    STACK_ENTRY_MODEL(_reThreadModel);
    CRITICALSECTIONLOCK;
    HRESULT hr;

    if (!fpe)
    {
        // Then we need a new tokenizer to parse it.
        checkhr2(PushTokenizer(NULL));
        _pdc->_fEntity = true;
        _pdc->_fPEReference = (fpe == TRUE);

        checkhr2(_pTokenizer->AppendData((const BYTE*)s_ByteOrderMark, sizeof(s_ByteOrderMark), FALSE));
        hr = _pTokenizer->AppendData((const BYTE*)pwcText, ulLen * sizeof(WCHAR), TRUE);
    }
    else
    {
        hr = _pTokenizer->InsertData((const WCHAR *)pwcText, ulLen, true);
    }
    if (hr == S_OK)
    {
        hr = _pFactory->NotifyEvent(this, XMLNF_STARTENTITY);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE
XMLParser::ExpandEntity(
    /* [in] */ const WCHAR* pwcText,
    /* [in] */ ULONG ulLen)
{
    STACK_ENTRY_MODEL(_reThreadModel);
    CRITICALSECTIONLOCK;

    return _pTokenizer->InsertData((const WCHAR *)pwcText, ulLen, false);
}

HRESULT STDMETHODCALLTYPE
XMLParser::SetRoot(
            /* [in] */ PVOID pRoot)
{
    STACK_ENTRY;
    CRITICALSECTIONLOCK;
    _pRoot = pRoot;
    _pNode = pRoot;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
XMLParser::GetRoot(
    /* [in] */ PVOID __RPC_FAR * ppRoot)
{
    STACK_ENTRY;
    CRITICALSECTIONLOCK;
    if (ppRoot == NULL) return E_INVALIDARG;
    *ppRoot = _pRoot;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
XMLParser::SetFactory(
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory)
{
    STACK_ENTRY;
    CRITICALSECTIONLOCK;
    _pFactory = pNodeFactory;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
XMLParser::GetFactory(
            /* [out] */ IXMLNodeFactory** ppNodeFactory)
{
    if (ppNodeFactory == NULL) return E_INVALIDARG;
    if (_pFactory)
    {
        *ppNodeFactory = _pFactory;
        (*ppNodeFactory)->AddRef();
    }
    else
    {
        *ppNodeFactory = NULL;
    }
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
XMLParser::Run(
            /* [in] */ long lChars)
{
    STACK_ENTRY_MODEL(_reThreadModel);
    CRITICALSECTIONLOCK;

    XML_NODE_INFO   info;
    XML_NODE_INFO*  aNodeInfo[1];

    HRESULT         hr = 0;
    USHORT          numRecs;

    bool            fIsAttribute = false;
    WCHAR           wc;
    bool            stop;

    if (_fSuspended)
        _fSuspended = FALSE; // caller must want to resume.

    if (_pFactory == NULL)
    {
        return E_FAIL;
    }

    if (_fStopped)
    {
        return XML_E_STOPPED;
    }

    if (_pTokenizer == NULL)
    {
        if (_fLastError != S_OK)
            return _fLastError;
        else
            // must be _fStarted == false
            return XMLPARSER_IDLE;
    }

    // Check for recurrsive entry and whether caller actually
    // wants anything parsed.
    if (_fInsideRun || lChars == 0)
        return E_PENDING;

    BoolLock flock(&_fInsideRun);

    if (_fLastError != 0)
    {
        // one more chance to cleanup the parser stack.
        hr = _fLastError;
        goto cleanup_stack;
    }

    if (! _fStarted)
    {
        _fStarted = true;
        hr = _pFactory->NotifyEvent(this, XMLNF_STARTDOCUMENT);
        if (_fStopped)      // watch for onReadyStateChange handlers 
            return S_OK;    // fussing with the parser state.
    }

    _fWaiting = false;
    if (_fPendingBeginChildren)
    {
        _fPendingBeginChildren = false;
        hr = _pFactory->BeginChildren(this, (XML_NODE_INFO*)_pCurrent);
    }
    if (_fPendingEndChildren)
    {
        _fPendingEndChildren = false;
        hr = _pFactory->EndChildren(this, TRUE, (XML_NODE_INFO*)_pCurrent);
        if (!hr)
            hr = pop(); // no match needed
    }

    info.dwSize = sizeof(XML_NODE_INFO);
    info.dwType = XMLStream::XML_PENDING;
    info.dwSubType = 0;
    info.pwcText = NULL;
    info.ulLen = 0;
    info.ulNsPrefixLen = 0;
    info.pNode = NULL;
    info.pReserved = NULL;
    aNodeInfo[0] = &info;

more:
    _fRunEntryCount++; // count of callers inside this loop...

    while (hr == 0 && ! _fSuspended)
    {
        info.dwSubType = 0;

        // The XMLStream error codes have been aligned with the
        // XMLParser error code so no mapping is necessary.
        hr = _pTokenizer->GetNextToken(&info.dwType, (const WCHAR  **)&info.pwcText, (long*)&info.ulLen, (long*)&info.ulNsPrefixLen);
        if (hr == E_PENDING)
        {
            _fWaiting = true;
            break;
        }

        if (! _fFoundNonWS &&
                info.dwType != XMLStream::XML_PENDING &&
                info.dwType != XML_WHITESPACE &&
                info.dwType != XML_XMLDECL)
        {
            _fFoundNonWS = true;
        }

        // Now the NodeType is the same as the XMLToken value.  We set
        // this up by aligning the two enums.
        switch (info.dwType)
        {
        case 0:
            if (hr == XML_E_INVALIDSWITCH  && _fIgnoreEncodingAttr)
            {
                hr = 0; // ignore it and continue on.
            }
            break;
            // --------- Container Nodes -------------------
        case XML_XMLDECL:
            if (_fFoundNonWS && ! _fIE4Mode)  // IE4 allowed this...
            {
                hr = XML_E_BADXMLDECL;
                break;
            }
//            _fFoundNonWS = true;
            goto containers;

        case XML_XMLSPACE:
        case XML_XMLLANG:
            info.dwSubType = info.dwType;        // pass this as a subtype.
            info.dwType = XML_ATTRIBUTE;
            // fall through
        case XML_ATTRIBUTE:
            fIsAttribute = true;
            goto containers;

        case XML_VERSION:
            info.dwSubType = info.dwType;
            info.dwType = XML_ATTRIBUTE;
            _fGotVersion = true;
            fIsAttribute = true;
            goto containers;

        case XML_STANDALONE:
        case XML_ENCODING:
            if (! _fGotVersion && _pDownloads.used() == 1)
            {
                hr = XML_E_EXPECTING_VERSION;
                break;
            }
            if (info.dwType == XML_STANDALONE)
            {
                if (_pDownloads.used() > 1)
                {
                    hr = XML_E_UNEXPECTED_STANDALONE;
                    break;
                }
            }
            info.dwSubType = info.dwType;
            info.dwType = XML_ATTRIBUTE;
            fIsAttribute = true;
            goto containers;

        case XML_NS:
            info.dwSubType = info.dwType;
            info.dwType = XML_ATTRIBUTE;
            fIsAttribute = true;
            {
                MY_XML_NODE_INFO* ptr = _pStack[_lCurrentElement];// tell namespacenodefactory
                ptr->pReserved = (void*)0x1;               // that we found an XML_NS attribute.
            }
            goto containers;

        case XML_ELEMENT:
        case XML_PI:
containers:
            if (_fRootLevel)
            {
                // Special rules apply for root level tags.
                if (info.dwType == XML_ELEMENT)
                {
                     // This is a root level element.
                     if (! _fFoundRoot)
                     {
                         _fFoundRoot = true;
                     }
                     else
                     {
                         hr = XML_E_MULTIPLEROOTS;
                         break;
                     }
                }
                else if (info.dwType != XML_PI &&
                         info.dwType != XML_XMLDECL &&
                         info.dwType != XML_DOCTYPE)
                {
                    hr = XML_E_INVALIDATROOTLEVEL;
                    break;
                }
            }

            info.fTerminal = FALSE;

            if (fIsAttribute)
            {
                breakhr( pushAttribute(info));
                fIsAttribute = false;
            }
            else
            {
                breakhr( push(info));
            }
            break;

            // --------- DTD Container Nodes -------------------
        case XML_DOCTYPE:
            if (_fSeenDocType)
            {
                hr = (HRESULT)XML_E_DUPLICATEDOCTYPE;
                break;
            }
            _fSeenDocType = true;
            if (_cDTD)
            {
                hr = XML_E_DOCTYPE_IN_DTD;
                break;
            }
            else if (_fFoundRoot)
            {
                hr = XML_E_DOCTYPE_OUTSIDE_PROLOG;
                break;
            }
            goto dtdcontainers;

        case XML_SYSTEM:
        case XML_PUBLIC:
        case XML_NDATA:
            info.dwSubType = info.dwType;
            info.dwType = XML_DTDATTRIBUTE;
            fIsAttribute = true;
            goto dtdcontainers;

            // Put all DTD related container nodes here...
        case XML_PENTITYDECL:
            info.dwSubType = info.dwType;        // make this a subtype of
            info.dwType = XML_ENTITYDECL; // XML_ENTITYDECL
                // fall through
        case XML_ENTITYDECL:
        case XML_ELEMENTDECL:
        case XML_ATTLISTDECL:
        case XML_NOTATION:
        case XML_GROUP:
        case XML_INCLUDESECT:
            if (_cDTD == 0)
            {
                hr = (HRESULT)XML_E_DTDELEMENT_OUTSIDE_DTD;
                break;
            }

dtdcontainers:
            // Cannot buffer attributes for DTD declarations because of PARAMETER
            // ENTITIES
            if (_fFoundDTDAttribute)
            {
                breakhr(popDTDAttribute());
            }
            info.fTerminal = FALSE;
            if (fIsAttribute)
            {
                fIsAttribute = false;
                // NOTE - this code is setup in a way to make it possible for the
                // node factory to return E_PENDING to force the Run to return
                // but then be able to call Run() later on and pick up where it
                // left off.  This means all the state info needed to re-enter Run
                // must be saved away.
                hr =  _pFactory->CreateNode(this, _pNode, 1, aNodeInfo);
                HRESULT hr2 = pushDTDAttribute(info);
                if (FAILED(hr2)) hr = hr2; // this is more serious that E_PENDING.
                _pNode = info.pNode;
                info.pNode = NULL;
            }
            else
            {
                hr =  _pFactory->CreateNode(this, _pNode, 1, aNodeInfo);
                HRESULT hr2 = push(info);
                if (FAILED(hr2)) hr = hr2; // this is more serious than E_PENDING.
                _pNode = info.pNode;
                info.pNode = NULL;
            }
            break;

            // --------- Terminal Nodes -------------------
        case XML_AT_CDATA:
        case XML_AT_ID:
        case XML_AT_IDREF:
        case XML_AT_IDREFS:
        case XML_AT_ENTITY:
        case XML_AT_ENTITIES:
        case XML_AT_NMTOKEN:
        case XML_AT_NMTOKENS:
        case XML_AT_NOTATION:
            // Make these subtypes of XML_ATTTYPE.
            info.dwSubType = info.dwType;
            info.dwType = XML_ATTTYPE;
            goto dtdterminals;

        case XML_AT_REQUIRED:
        case XML_AT_IMPLIED:
        case XML_AT_FIXED:
            // Make these subtypes of XML_ATTPRESENCE.
            info.dwSubType = info.dwType;
            info.dwType = XML_ATTPRESENCE;
            goto dtdterminals;

        case XML_EMPTY:
        case XML_ANY:
        case XML_MIXED:
        case XML_SEQUENCE:
        case XML_CHOICE:
        case XML_STAR:
        case XML_PLUS:
        case XML_QUESTIONMARK:
            info.dwSubType = info.dwType;  // make these subtypes of XML_MODEL
            info.dwType = XML_MODEL;
            goto dtdterminals;

            // Put all DTD terminal nodes here...
        case XML_IGNORESECT:
        case XML_PEREF:
        case XML_ATTDEF:
dtdterminals:
            if (_cDTD == 0)
            {
                hr = (HRESULT)XML_E_DTDELEMENT_OUTSIDE_DTD;
                break;
            }
            // goto terminals;
            // fall through

        case XML_PCDATA:
        case XML_CDATA:
terminals:
            // Special rules apply for root level tags.
            if (_fRootLevel)
            {
                hr = XML_E_INVALIDATROOTLEVEL;
                break;
            }
            // fall through
        case XML_COMMENT:
        case XML_WHITESPACE:
tcreatenode:
            info.fTerminal = TRUE;
            if (_cAttributes != 0)
            {
                // We are inside the attribute list, so we need to push this.
                hr = pushAttributeValue(info);
                break;
            }
            hr = _pFactory->CreateNode(this, _pNode, 1, aNodeInfo);
            info.pNode = NULL;
            break;

        case XML_NAME:
        case XML_NMTOKEN:
        case XML_STRING:
        case XML_DTDSUBSET:
            info.fTerminal = TRUE;
            hr = _pFactory->CreateNode(this, _pNode, 1, aNodeInfo);
            info.pNode = NULL;
            if (info.dwType == XML_DTDSUBSET)
            {
                _cDTD--;
                breakhr(_pFactory->NotifyEvent(this, XMLNF_ENDDTDSUBSET));
            }
            break;

        case XML_ENTITYREF:
            if (_fRootLevel)
            {
                hr = XML_E_INVALIDATROOTLEVEL;
                break;
            }

            // We handle builtin entities and char entities in xmlstream
            // so these must be user defined entity, so treat it like a regular terminal node.
            goto terminals;
            break;

        case XMLStream::XML_BUILTINENTITYREF:
        case XMLStream::XML_HEXENTITYREF:
        case XMLStream::XML_NUMENTITYREF:
            // pass real entityref type as subtype so we can publish these
            // subtypes eventually.
            info.dwSubType = info.dwType; // XML_ENTITYREF;
            info.dwType = XML_PCDATA;

            if (_cAttributes == 0)
            {
                goto tcreatenode;
            }

            // We are inside the attribute list, so we need to push this.
            info.fTerminal = TRUE;
            hr = pushAttributeValue(info);
            if (SUCCEEDED(hr))
            {
                hr = CopyText(_pCurrent);
            }
            break;

        case XMLStream::XML_TAGEND:
            numRecs = 1+_cAttributes;
            if (_cAttributes != 0)  // this is safe because _rawstack does NOT reclaim
            {                       // the popped stack entries.
                popAttributes();
            }
            hr = _pFactory->CreateNode(this, _pNode, numRecs, (XML_NODE_INFO **)&_paNodeInfo[_lCurrentElement]);
            _pNode = _pCurrent->pNode;
            if (FAILED(hr))
            {
                _fPendingBeginChildren = true;
                break;
            }
            breakhr( _pFactory->BeginChildren(this, (XML_NODE_INFO*)_pCurrent));
            break;

            // The ENDXMLDECL is like EMPTYENDTAGs since we've been
            // buffering up their attributes, and we have still got to call CreateNode.
        case XMLStream::XML_ENDXMLDECL:
            _fGotVersion = false; // reset back to initial state.
            // fall through.
        case XMLStream::XML_EMPTYTAGEND:
            numRecs = 1+_cAttributes;
            if (_cAttributes != 0)
            {
                popAttributes();
            }
            hr = _pFactory->CreateNode(this, _pNode, numRecs, (XML_NODE_INFO **)&_paNodeInfo[_lCurrentElement]);
            if (FAILED(hr))
            {
                _fPendingEndChildren = true;
                break;
            }
            breakhr(_pFactory->EndChildren(this, TRUE, (XML_NODE_INFO*)_pCurrent));
            breakhr(pop()); // no match needed
            break;

        case XMLStream::XML_ENDDECL:
            if (_fFoundDTDAttribute)
            {
                breakhr(popDTDAttribute());
            }
            breakhr(_pFactory->EndChildren(this, TRUE, (XML_NODE_INFO*)_pCurrent));
            breakhr(pop()); // no match needed
            break;

        // ---------------- end of a container -----------------
        case XMLStream::XML_ENDPI:
            info.dwType = XML_CDATA;
            info.dwSubType = XML_PI;
            info.fTerminal = TRUE;
            breakhr(pushAttribute(info));
            hr = _pFactory->CreateNode(this, _pNode, 2, (XML_NODE_INFO **)&_paNodeInfo[_cNodeInfoCurrent-2]);
            popAttribute(); // pop the PCDATA node.
            if (FAILED(hr))
            {
                _fPendingEndChildren = true;
                break;
            }
            breakhr(_pFactory->EndChildren(this, FALSE, (XML_NODE_INFO*)_pCurrent));
            breakhr(pop()); // pop the XML_PI node.
            break;

        case XMLStream::XML_CLOSEPAREN:
        case XMLStream::XML_ENDCONDSECT:
            breakhr(_pFactory->EndChildren(this, FALSE, (XML_NODE_INFO*)_pCurrent));
            hr = pop(); // no tagname to match.
            break;

        case XMLStream::XML_ENDTAG:
            if (_pStack.used() == 0)
            {
                hr = XML_E_UNEXPECTEDENDTAG;
            }
            else
            {
                XML_NODE_INFO* pCurrent = (XML_NODE_INFO*)_pCurrent; // save current record
                breakhr(pop(info.pwcText, info.ulLen)); // check tag/match
                breakhr(_pFactory->EndChildren(this, FALSE, (XML_NODE_INFO*)pCurrent));
            }
            break;
        case XMLStream::XML_STARTDTDSUBSET:
            _cDTD++;
            if (_fFoundDTDAttribute)
            {
                popDTDAttribute();
            }
            breakhr( _pFactory->NotifyEvent(this, XMLNF_STARTDTDSUBSET));
            break;
        case XMLStream::XML_ENDPROLOG:
            // For top level document only, (not for DTD's or
            // entities), call EndProlog on the node factory.
            if (_fRootLevel &&
                    ! _pdc->_fEntity && ! _pdc->_fDTD)
                breakhr( _pFactory->NotifyEvent(this, XMLNF_ENDPROLOG));
            break;

        default:
            hr = E_FAIL;
            break;
        }
    }
    _fRunEntryCount--;

    stop = false;
    if (hr == XML_E_ENDOFINPUT)
    {
        hr = S_OK;
        bool inDTD = _pdc->_fDTD;
        bool inEntity = _pdc->_fEntity;
        bool inPEReference = _pdc->_fPEReference;

        if (inEntity && _pdc->_fDepth != _pStack.used())
        {
            // Entity itself was unbalanced.
            hr = ReportUnclosedTags(_pdc->_fDepth);
        }
        else if (PopDownload() == S_OK)
        {
            // then we must have just finished a DTD and we still have more to do
            // BUGBUG -- need to check that entity is well formed, i.e. no tags
            // left open.

            if (!inPEReference)
            {
                if (inEntity)
                {
                    hr = _pFactory->NotifyEvent(this, XMLNF_ENDENTITY);
                }
                else if (inDTD)
                {
                    hr = _pFactory->NotifyEvent(this, XMLNF_ENDDTD);
                    _cDTD--;
                }
            }
            if (FAILED(hr))
            {
                goto cleanup_stack;
            }

            // In a synchronous DTD download, there is another parser
            // parser Run() call on the stack above us, so let's return
            // back to that Run method so we don't complete the parsing
            // out from under it.
            if (_fRunEntryCount > 0)
                return S_OK;

            if (_fStopped)
                return S_OK;

            goto more;
        }
        else
        {
            if (_pStack.used() > 0)
            {
                hr = ReportUnclosedTags(0);
            }
            else if (! _fFoundRoot)
            {
                hr = XML_E_MISSINGROOT;
            }
            stop = true;
        }
    }

cleanup_stack:

    if (hr != S_OK && hr != E_PENDING)
    {
        stop = true;
        _fLastError = hr;

        // Pass all the XML_NODE_INFO structs to the Error function so the client
        // gets a chance to cleanup the PVOID pNode fields.
        HRESULT edr = _pFactory->Error(this, hr,
            (USHORT)(_paNodeInfo ? _lCurrentElement+1 : 0), (XML_NODE_INFO**)_paNodeInfo);
        if (edr != 0)
            _fLastError = hr;
    }

    if (stop && ! _fStopped)
    {
        TraceTag((tagParserError, "Parser stopping with hr %x", hr));
        _fLastError = hr;
        _fStopped = true;
        _fStarted = false;
        HRESULT edr;
        edr = _pFactory->NotifyEvent(this, XMLNF_ENDDOCUMENT);
        if (edr != 0)
        {
            hr = edr; // allow factory to change error code (except to S_OK)
            if (S_OK == _fLastError)
            {
                // Make sure the node factory always finds out about errors.
                edr = _pFactory->Error(this, hr, 0, NULL);
                if (edr != 0)
                    hr = edr;
            }
            _fLastError = hr;
        }
    }
    return hr;
}

HRESULT
XMLParser::popAttributes()
{
    // Now I pop all the attributes that were pushed for this tag.
    // I know we have at least one attribute.
    HRESULT hr;
    while (_cAttributes > 0)
    {
        popAttribute(); // no match needed
    }
    Assert(_pStack.used() == _lCurrentElement+1);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
XMLParser::GetParserState( void)
{
    CRITICALSECTIONLOCK;

    if (_fLastError != 0)
        return XMLPARSER_ERROR;

    if (_fStopped)
        return XMLPARSER_STOPPED;

    if (_fSuspended)
        return XMLPARSER_SUSPENDED;

    if (! _fStarted)
        return XMLPARSER_IDLE;

    if (_fWaiting)
        return XMLPARSER_WAITING;

    return XMLPARSER_BUSY;
}

HRESULT STDMETHODCALLTYPE
XMLParser::Abort(
            /* [in] */ BSTR bstrErrorInfo)
{
#if 0 // FA URL
    int i;
    STACK_ENTRY_MODEL(_reThreadModel);

    // Have to set these before Critical Section to notify Run()
    _fStopped = true;
    _fSuspended = true; // force Run to terminate...

    CRITICALSECTIONLOCK;
    TraceTag((tagParserError, "Parser aborted - %ls", bstrErrorInfo));

    //BUGBUG: may need to check bstrErrorInfo is NULL or not 
    //        and the returned result so that we can report 
    //        E_OUTOFMEMORY error
    if (_bstrError) ::SysFreeString(_bstrError);
    _bstrError = ::SysAllocString(bstrErrorInfo);

    // abort all downloads
    for (i=_pDownloads.used()-1;  i>=0;  --i)
    {
        URLStream* stm = _pDownloads[i]->_pURLStream;
        if (stm)
            stm->Abort();
    }
#endif // FA URL
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
XMLParser::Suspend( void)
{
    _fSuspended = true; // force Run to suspend
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
XMLParser::Reset( void)
{
    STACK_ENTRY;
    CRITICALSECTIONLOCK;

    init();

    delete _pszCurrentURL;
    _pszCurrentURL = NULL;
    delete _pszBaseURL;
    _pszBaseURL = NULL;
    _pRoot = NULL;
    _pFactory = NULL;
    _pNode = NULL;
#if 0
    if (_bstrError != NULL) ::SysFreeString(_bstrError);
    _bstrError = NULL;
    if (_fAttemptedURL != NULL) ::SysFreeString(_fAttemptedURL);
    _fAttemptedURL = NULL;
#endif
    return S_OK;
}

ULONG STDMETHODCALLTYPE
XMLParser::GetLineNumber( void)
{
    CRITICALSECTIONLOCK;
    if (_pTokenizer) return _pTokenizer->GetLine();
    else return 0;
}

ULONG STDMETHODCALLTYPE
XMLParser::GetLinePosition( void)
{
    CRITICALSECTIONLOCK;
    if (_pTokenizer) return _pTokenizer->GetLinePosition();
    else return 0;
}

ULONG STDMETHODCALLTYPE
XMLParser::GetAbsolutePosition( void)
{
    CRITICALSECTIONLOCK;
    if (_pTokenizer) return _pTokenizer->GetInputPosition();
    else return 0;
}


HRESULT STDMETHODCALLTYPE
XMLParser::GetLineBuffer(
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos)
{
    if (pulLen == NULL || pulStartPos == NULL) return E_INVALIDARG;

    STACK_ENTRY;
    CRITICALSECTIONLOCK;
    if (_pTokenizer)
    {
        return _pTokenizer->GetLineBuffer(ppwcBuf, pulLen, pulStartPos);
    }
    *ppwcBuf = NULL;
    *pulLen = 0;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
XMLParser::GetLastError( void)
{
    return _fLastError;
}

HRESULT STDMETHODCALLTYPE
XMLParser::GetErrorInfo(
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo)
{
#if 0 // FA error 
    HRESULT hr = S_OK;
    WCHAR* buffer = NULL;

    STACK_ENTRY_MODEL(_reThreadModel);
    CRITICALSECTIONLOCK;

    *pbstrErrorInfo = NULL;

    HRESULT errorid = GetLastError();
    if (_bstrError)
    {
        *pbstrErrorInfo = ::SysAllocString(_bstrError);
        if(*pbstrErrorInfo == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        goto DONE;
    }
    else if ((ULONG)errorid <= 0xC00CEFFF && (ULONG)errorid >= 0xC00CE000)
    {
        // MSXML error msg.
        TRY
        {
            String* s = Resources::FormatMessage(errorid, NULL);
            *pbstrErrorInfo = s->getBSTR();
            if(*pbstrErrorInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            goto DONE;
            // buffer = ::FormatMessageInternal(g_hInstance, errorid, NULL);
        }
        CATCH
        {
            hr = ERESULT;
            goto DONE;
        }
        ENDTRY
    }
    else
    {
        // MSXML error msg.
        // System error
#if 0
/**************
        buffer = ::FormatMessageInternal(NULL, errorid, NULL);

        if (buffer == NULL && HRESULT_FACILITY(errorid) == FACILITY_INTERNET)
        {
            // maybe it's URLMON...
            HINSTANCE h = ::GetModuleHandleA("URLMON.DLL");
            buffer = ::FormatMessageInternal(h, errorid, NULL);

            if (_fAttemptedURL)
            {
                WCHAR* buf2 = ::FormatMessageInternal(g_hInstance, XML_E_RESOURCE,
                    _fAttemptedURL, NULL);

                if (buffer == NULL)
                {
                    buffer = buf2;
                }
                else
                {
                    WCHAR* buf3 = StringAdd(buffer, buf2);
                    delete[] buf2;
                    if (buf3 != NULL)
                    {
                        delete [] buffer;
                        buffer = buf3;
                    }
                }
            }
        }
**************/
#endif
        TRY
        {
            String* s = Resources::FormatSystemMessage(errorid);
            if (_fAttemptedURL)
            {
                String* rs = Resources::FormatMessage(XML_E_RESOURCE,
                    String::newString(_fAttemptedURL), NULL);
                s = String::add(s,rs,null);
            }
            *pbstrErrorInfo = s->getBSTR();
            if(*pbstrErrorInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            goto DONE;
        }
        CATCH
        {
            hr = ERESULT;
            goto DONE;
        }
        ENDTRY
    }
    if (buffer == NULL)
    {
        *pbstrErrorInfo = NULL;
        hr = S_FALSE;
        goto DONE;
    }
    *pbstrErrorInfo = ::SysAllocString(buffer);
    delete[] buffer;
    if(*pbstrErrorInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
DONE:
    return hr;
#endif // FA error
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
XMLParser::SetFlags(
            /* [in] */ ULONG lFlags)
{
    _usFlags = (unsigned short)lFlags;
    _fCaseInsensitive = (lFlags & XMLFLAG_CASEINSENSITIVE) != 0;
    _fIE4Mode = (_usFlags & XMLFLAG_IE4QUIRKS) != 0;

    if (_pTokenizer != NULL)
        _pTokenizer->SetFlags(_usFlags);
    return S_OK;
}

ULONG STDMETHODCALLTYPE
XMLParser::GetFlags( )
{
    return _usFlags;
}

HRESULT STDMETHODCALLTYPE
XMLParser::GetURL(
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf)
{
#if 0 // FA URL
    if (ppwcBuf == NULL)
        return E_INVALIDARG;

    URL* url;

    //BUGBUG: should CoTaskAlloc ??
    if (_pszCurrentURL != NULL)
    {
        *ppwcBuf = _pszCurrentURL;
    }
    else if (_pdc != NULL && _pdc->_pURLStream && ((url = _pdc->_pURLStream->GetURL()) != NULL))
    {
        *ppwcBuf = url->getResolved();
    }
    else
    {
        *ppwcBuf = NULL;
    }
#endif
    return S_OK;
}


HRESULT STDMETHODCALLTYPE
XMLParser::SetSecureBaseURL(
    /* [in] */ const WCHAR* pszBaseUrl)
{
#if 0
    WCHAR* newBaseUrl = NULL;
    if (pszBaseUrl != NULL)
    {
        newBaseUrl = ::StringDup(pszBaseUrl);
        if (newBaseUrl == NULL)
            return E_OUTOFMEMORY;
    }
    delete _pszSecureBaseURL;
    _pszSecureBaseURL = newBaseUrl;
#endif    
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
XMLParser::GetSecureBaseURL(
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf)
{
    *ppwcBuf = _pszSecureBaseURL;
    return S_OK;
}


HRESULT 
XMLParser::SetCurrentURL(
    /* [in] */ const WCHAR* pszCurrentUrl)
{
#if 0 // FA
    WCHAR* newCurrentUrl = NULL;
    if (pszCurrentUrl != NULL)
    {
        newCurrentUrl = ::StringDup(pszCurrentUrl);
        if (newCurrentUrl == NULL)
            return E_OUTOFMEMORY;
    }
    delete _pszCurrentURL;
    _pszCurrentURL = newCurrentUrl;
#endif    
    return S_OK;
}

HRESULT 
XMLParser::SetBaseURL(
    /* [in] */ const WCHAR* pszBaseUrl)
{
#if 0 // FA URL
    WCHAR* newBaseUrl = NULL;
    if (pszBaseUrl != NULL)
    {
        newBaseUrl = ::StringDup(pszBaseUrl);
        if (newBaseUrl == NULL)
            return E_OUTOFMEMORY;
    }
    delete _pszBaseURL;
    _pszBaseURL = newBaseUrl;
#endif    
    return S_OK;
}

#if 0 // FA URL
HRESULT
XMLParser::HandleData(URLStream* pStm, bool last)
{
    HRESULT hr = S_OK;

    // According to email with danpoz on 1/19/99 There is a limit of 2 keep-alive 
    // connections per process and you cannot tell URLMON to NOT use keep-alive. 
    // You can find the current keep-alive limit using :
    //      InternetQueryOption(INTERNET_OPTION_MAX_CONNS_PER_SERVER).

    // So we have to continue pumping downloads - even if the parser is suspended.  
    // For example, if we download an XML document that in turn loads a DTD and the 
    // DTD loads an external entity - WININET will hang waiting for an available 
    // connection if the main XML document download or DTD download never completes.  
    // Even worse, is in the synchronous case we have to download ALL the data before 
    // parsing otherwise we attempt multiple downloads on the same thread which will 
    // always hang because there's no way to pump the prior downloads - since we're 
    // doing all this on the one thread.

    // Also if this bounces back synchronously then this is a local file !
    // in which case we do NOT need to do this expensive buffering.
    if (! _fInLoading || 0 != (_usFlags & XMLFLAG_RUNBUFFERONLY))
    {
        Download* download = FindDownload(pStm);
        if (download && download->_pEncodingStream)
        {
            hr = download->_pEncodingStream->BufferData();
            if (FAILED(hr) && E_PENDING != hr)
            {
                // must tell the encoding stream to pass the error onto the bufferedstream then.
                download->_pEncodingStream->setReadStream(true);
            }
        }

        // If this download failed, then we need to call Run() in order to notify
        // the Document that it failed.
        if ((S_OK != hr || last || _pdc->_fAsync) &&    // can parse if this is the last buffer or it's async 
            ! _fSuspended &&                // and not if this parser is actually suspended
            download &&           // and only if the download has officially been Pushed.
            _pdc == download)     // and only if the "current" download matches the one for this HandleData
        {
            AddRef();   // stabilize

            hr = Run(-1);
            TraceTag((tagParserCallback, "HandleData got hr %x from Run", hr));

            if (hr != S_OK && hr != E_PENDING && hr != XML_E_STOPPED && hr != XML_E_SUSPENDED)
            {
                _fLastError = hr;
                hr = E_ABORT;
            }
            Release();
        }
    }
Cleanup:
    return hr;
}

XMLParser::Download* 
XMLParser::FindDownload(URLStream* pStream)
{
    // Find the EncodingStream that wraps this URLStream and tell it
    // to buffer up the data so that we do not BLOCK the sockets.  If we
    // do not do this then we will eventually hang in WININET while waiting
    // for a socket to free up.  WININET enforces a limit to the number of
    // concurrent downloads allowed to ensure we are a good internet citizen.
    for (long i = _pDownloads.used()-1; i >= 0; i--)
    {
        Download* download = _pDownloads[i];
        if (download->_pURLStream == pStream)
        {
            return download;
        }
    }
    return null;
}
#endif // FA URL

//------------ PRIVATE METHODS --------------------------------------------------
HRESULT
XMLParser::PushTokenizer(
                URLStream* stream)
{
    _pTokenizer = new_ne XMLStream(this);
    if (_pTokenizer == NULL)
        return E_OUTOFMEMORY;

    _pTokenizer->SetFlags(_usFlags);
//    _fTokenizerChanged = true;

    HRESULT hr= PushDownload(stream, _pTokenizer);
    if (FAILED(hr))
    {
        delete _pTokenizer;
        _pTokenizer = NULL;
        return hr;
    }
    return S_OK;
}

HRESULT
XMLParser::PushDownload(URLStream* stream, XMLStream* tokenizer)
{
    // NOTE: tokenizer can be null, in the case of a parameter entity download.

    _pdc = _pDownloads.push();
    if (_pdc == NULL)
    {
        return E_OUTOFMEMORY;
    }
    if (_pDownloads.used() > 1)
        _fRootLevel = false;

    _pdc->_pTokenizer = tokenizer;
    _pdc->_fDTD = false;
    _pdc->_fEntity = false;
    _pdc->_fAsync = false;
    _pdc->_fFoundNonWS = _fFoundNonWS;
    _pdc->_fFoundRoot = _fFoundRoot;
    _pdc->_fSeenDocType = _fSeenDocType;
    _pdc->_fRootLevel = _fRootLevel;
    _pdc->_fDepth = _pStack.used();

    _fFoundNonWS = false;
    _fFoundRoot = false;

    _fRootLevel = (_pStack.used() == 0 && _pDownloads.used() == 1);

    HRESULT hr = S_OK;
    if (stream != NULL)
    {
        _pdc->_pURLStream = stream;
        hr = PushStream(stream,
            tokenizer == NULL); // this is a parameter entity stream if "tokenizer" is NULL.
    }
    return hr;
}

HRESULT 
XMLParser::PushStream(IStream* pStm, bool fpe)
{
    EncodingStream* stream = (EncodingStream*)EncodingStream::newEncodingStream(pStm); // refcount = 1
    if (stream == NULL)
        return E_OUTOFMEMORY;

// FA
//    if (_usFlags & XMLFLAG_RUNBUFFERONLY)
//        stream->setReadStream(false);

    _pdc->_pEncodingStream = stream;
    stream->Release(); // Smart pointer is holding a ref

    HRESULT hr = _pTokenizer->PushStream(stream, fpe);
    if (hr == E_PENDING)
    {
        _fWaiting = true;
    }
    return hr;
}

HRESULT
XMLParser::PopDownload()
{
    // NOTE: tokenizer can be null, in the case of a parameter entity download.
    HRESULT hr = S_OK;

    if (_pdc != NULL)
    {
        if (_pdc->_pTokenizer)
        {
            _pdc->_pTokenizer->Reset();
            delete _pdc->_pTokenizer;
            _pdc->_pTokenizer = NULL;
        }
        _pdc->_pEncodingStream = NULL;
#if 0 // FA URL
        if (_pdc->_pURLStream)
            _pdc->_pURLStream->Reset();
#endif
        _pdc->_pURLStream = NULL;
        // restore saved value of foundnonws.
        _fFoundNonWS = _pdc->_fFoundNonWS;
        _pdc = _pDownloads.pop();
    }
    if (_pdc != NULL)
    {
        if (_pdc->_pTokenizer != NULL)
        {
            _pTokenizer = _pdc->_pTokenizer;
        }
#if 0 // FA URL
        if (_pdc->_pURLStream != NULL)
        {
            hr = SetCurrentURL(_pdc->_pURLStream->GetURL()->getResolved());
        }
#endif
    }
    else
    {
        _pTokenizer = NULL;
        hr = S_FALSE;
    }

    if (_pStack.used() == 0 && _pDownloads.used() == 1)
        _fRootLevel = true;

    return hr;
}

HRESULT
XMLParser::GrowNodeInfo()
{
    USHORT newsize = _cNodeInfoAllocated + STACK_INCREMENT;
    MY_XML_NODE_INFO** pNewArray = new_ne PMY_XML_NODE_INFO[newsize];
    if (pNewArray == NULL)
        return E_OUTOFMEMORY;
    // Now since STACK_INCREMENT is the same for _pStack then _pStack
    // has also re-allocated.  Therefore we need to re-initialize all
    // the pointers in this array - since they point into the _pStack's memory.
    for (int i = _pStack.used() - 1; i >= 0; i--)
    {
        pNewArray[i] = _pStack[i];
    }
    delete[] _paNodeInfo;
    _paNodeInfo = pNewArray;
    _cNodeInfoAllocated = newsize;
    return S_OK;
}

HRESULT
XMLParser::GrowBuffer(PMY_XML_NODE_INFO pNodeInfo, long newlen)
{
    delete [] pNodeInfo->_pwcTagName;
    pNodeInfo->_pwcTagName = NULL;
    // add 50 characters to avoid too many reallocations.
    pNodeInfo->_pwcTagName = new_ne WCHAR[ newlen ];
    if (pNodeInfo->_pwcTagName == NULL)
        return E_OUTOFMEMORY;
    pNodeInfo->_ulBufLen = newlen;
    return S_OK;
}

HRESULT
XMLParser::push(XML_NODE_INFO& info)
{
    HRESULT hr;
    _lCurrentElement = _pStack.used();

    _pCurrent = _pStack.push();
    if (_pCurrent == NULL)
        return E_OUTOFMEMORY;

    *((XML_NODE_INFO*)_pCurrent) = info;
    PUSHNODEINFO(_pCurrent);

    _fRootLevel = false;

    // Save the tag name into the private buffer so it sticks around until the
    // close tag </foo> which could be anywhere down the road after the
    // BufferedStream been overwritten

    // THIS CODE IS OPTIMIZED FOR PERFORMANCE WHICH IS WHY IT IS NOT
    // CALLING THE CopyText METHOD.
    if (_pCurrent->_ulBufLen < info.ulLen+1)
    {
        checkhr2(GrowBuffer(_pCurrent, info.ulLen + 50));
    }
    Assert(info.ulLen >= 0);
    ::memcpy(_pCurrent->_pwcTagName, info.pwcText, info.ulLen*sizeof(WCHAR));
    _pCurrent->_pwcTagName[info.ulLen] = L'\0';

    // And make the XML_NODE_INFO point to private buffer.
    _pCurrent->pwcText = _pCurrent->_pwcTagName;

    return S_OK;
}

HRESULT
XMLParser::pushAttribute(XML_NODE_INFO& info)
{
    HRESULT hr;
    if (_cAttributes != 0)
    {
        // Attributes are special in that they are supposed to be unique.
        // So here we actually check this.
        for (long i = _pStack.used()-1; i > _lCurrentElement; i--)
        {
            XML_NODE_INFO* ptr = _pStack[i];

            if (ptr->dwType != XML_ATTRIBUTE)
                continue; // ignore attribute values.

            if (ptr->ulLen != info.ulLen)
            {
                continue; // we're ok with this one
            }

            // Optimized for the normal case where there is no match
            if (::memcmp(ptr->pwcText, info.pwcText, info.ulLen*sizeof(TCHAR)) == 0)
            {
                if (! _fCaseInsensitive)
                {
                    return XML_E_DUPLICATEATTRIBUTE;
                }
                else if (StrCmpNI(ptr->pwcText, info.pwcText, info.ulLen) == 0)
                {
                    // Duplicate attributes are allowed in IE4 mode!!
                    // But only the latest one shows up
                    // So we have to delete the previous duplication
                    if (_fIE4Mode)
                    {
// This is some code, so we comment it out for now
#ifdef NEVER
                        long j = i + 1;
                        int k;
                        // Find the next attribute
                        while (j < _pStack.used())
                        {
                            XML_NODE_INFO * pInfo = _pStack[j];
                            if (pInfo->dwType == XML_ATTRIBUTE)
                                break;
                            else
                                j++;
                        }
                        // move the stack content
                        for (k = 0; k < _pStack.used() - j; k++)
                        {
                            *((XML_NODE_INFO*)_pStack[k + i]) = *((XML_NODE_INFO*)_pStack[k + j]);
                        }
                        // pop
                        for (k = j - i; k > 0; k --)
                            _pCurrent = _pStack.pop();
                        _cNodeInfoCurrent -= j - i;
                        _cAttributes -= j - i;
#endif
                        break;
                    }
                    else
                    {
                        return XML_E_DUPLICATEATTRIBUTE;
                    }
                }
            }
        }
    }

    _cAttributes++;

    _pCurrent = _pStack.push();
    if (_pCurrent == NULL)
        return E_OUTOFMEMORY;

    *((XML_NODE_INFO*)_pCurrent) = info;
    PUSHNODEINFO(_pCurrent);

    return S_OK;
}

HRESULT
XMLParser::pushAttributeValue(XML_NODE_INFO& info)
{
    HRESULT hr;
    // Attributes are saved in the BufferedStream so we can point to the
    // real text in the buffered stream instead of copying it !!

    _pCurrent = _pStack.push();
    if (_pCurrent == NULL)
        return E_OUTOFMEMORY;

    // store attribute value quote character in the pReserved field.
    info.pReserved = (PVOID)_pTokenizer->getAttrValueQuoteChar();

    *((XML_NODE_INFO*)_pCurrent) = info;
    PUSHNODEINFO(_pCurrent);

    // this is really the count of nodes on the stack, not just attributes.
    _cAttributes++;
    return S_OK;
}

HRESULT
XMLParser::pushDTDAttribute(XML_NODE_INFO& info)
{
    HRESULT hr;
    _pCurrent = _pStack.push();
    if (_pCurrent == NULL)
        return E_OUTOFMEMORY;

    *((XML_NODE_INFO*)_pCurrent) = info;
    PUSHNODEINFO(_pCurrent);

    _fFoundDTDAttribute = true;

    return S_OK;
}

HRESULT
XMLParser::pop(const WCHAR* tag, ULONG len)
{
    HRESULT hr = S_OK;

    if (_pCurrent == NULL || _pStack.used() == 0)
    {
        hr = XML_E_UNEXPECTEDENDTAG;
        goto Cleanup;
    }
    if (len != 0)
    {
        if (_pCurrent->ulLen != len)
        {
            hr = XML_E_ENDTAGMISMATCH;
        }
        // Optimized for the normal case where there is no match
        else if (::memcmp(_pCurrent->pwcText, tag, len*sizeof(TCHAR)) != 0)
        {
            if (! _fCaseInsensitive)
            {
                hr = XML_E_ENDTAGMISMATCH;
            }
            else if (::StrCmpNI(_pCurrent->pwcText, tag, len) != 0)
            {
                hr = XML_E_ENDTAGMISMATCH;
            }
        }
        if (hr)
        {
#if 0   // FA String
            TRY
            {
                String* s = Resources::FormatMessage(hr, String::newString(_pCurrent->pwcText, 0, _pCurrent->ulLen),
                                                         String::newString(tag, 0, len), NULL);
                _bstrError = s->getBSTR();
            }
            CATCH
            {
                hr = ERESULT;
            }
            ENDTRY
#endif // FA String
            goto Cleanup;
        }
    }

    // We don't delete the fTagName because we're going to reuse this field
    // later to avoid lots of memory allocations.

    _pCurrent = _pStack.pop();
    _cNodeInfoCurrent--;

    if (_pCurrent == 0)
    {
        _pNode = _pRoot;
        if (_pDownloads.used() == 1)
            _fRootLevel = true;
    }
    else
    {
        _pNode = _pCurrent->pNode;
    }

Cleanup:
    return hr;
}

HRESULT XMLParser::pop()
{
    // We don't delete the fTagName because we're going to reuse this field
    // later to avoid lots of memory allocations.

    _pCurrent = _pStack.pop();
    _cNodeInfoCurrent--;

    if (_pCurrent == 0)
    {
        _pNode = _pRoot;
        if (_pDownloads.used() == 1)
            _fRootLevel = true;
    }
    else
    {
        _pNode = _pCurrent->pNode;
    }
    return S_OK;
}

void XMLParser::popAttribute()
{
    Assert(_pStack.used() > 0);

    _pCurrent = _pStack.pop();
    _cNodeInfoCurrent--;

    Assert(_pCurrent != 0);

    _cAttributes--;

}

HRESULT
XMLParser::popDTDAttribute()
{
    HRESULT hr;
    Assert(_pStack.used() > 0);

    hr = _pFactory->EndChildren(this, TRUE, (XML_NODE_INFO*)_pCurrent);

    _fFoundDTDAttribute = false;

    _pCurrent = _pStack.pop();
    _cNodeInfoCurrent--;

    Assert(_pCurrent != 0);

    _pNode = _pCurrent->pNode;

    return hr;
}


HRESULT
XMLParser::CopyText(PMY_XML_NODE_INFO pNodeInfo)
{
    HRESULT hr = S_OK;
    if (pNodeInfo->_pwcTagName != pNodeInfo->pwcText)
    {
        ULONG len = pNodeInfo->ulLen;

        // Copy the current text into the buffer.
        if (pNodeInfo->_ulBufLen < len+1)
        {
            checkhr2(GrowBuffer(pNodeInfo, len + 50));
        }
        if (len > 0)
        {
            ::memcpy(pNodeInfo->_pwcTagName, pNodeInfo->pwcText, len*sizeof(WCHAR));
        }
        pNodeInfo->_pwcTagName[len] = L'\0';

        // And make the XML_NODE_INFO point to private buffer.
        pNodeInfo->pwcText = pNodeInfo->_pwcTagName;
    }
    return S_OK;
}

HRESULT
XMLParser::CopyContext()
{
    // For performance reasons we try not to copy the data for attributes
    // and their values when we push them on the stack.  We can do this
    // because the tokenizer tries to freeze the internal buffers while
    // parsing attributes and thereby guarentee that the pointers stay
    // good.  But occasionally the BufferedStream has to reallocate when
    // the attributes are right at the end of the buffer.

    long last = _pStack.used();
    for (long i = _cAttributes; i > 0 ; i--)
    {
        long index = last - i;
        MY_XML_NODE_INFO* ptr = _pStack[index];
        CopyText(ptr);
    }
    return S_OK;
}

HRESULT XMLParser::ReportUnclosedTags(int start)
{
    HRESULT hr = XML_E_UNCLOSEDTAG;
    // Build a string containing the list of unclosed tags and format an error
    // message containing this text.
    int tags = _pStack.used();

    WCHAR* buffer = NULL;
    WCHAR* msgbuf = NULL;
    unsigned long size = 0;
    unsigned long used = 0;

    for (long i = start; i < tags; i++)
    {
        XML_NODE_INFO* ptr = _pStack[i];
        if (ptr->dwType == XML_ATTRIBUTE)
            break;

        if (used + ptr->ulLen + 3 > size) // +3 for '<','>' and '\0'
        {
            long newsize = used + ptr->ulLen + 500;
            WCHAR* newbuf = new_ne WCHAR[newsize];
            if (newbuf == NULL)
            {
                goto nomem;
            }
            if (buffer != NULL)
            {
                ::memcpy(newbuf, buffer, used);
                delete[] buffer;
            }

            size = newsize;
            buffer = newbuf;
        }
        if (i > start)
        {
            buffer[used++] = ',';
            buffer[used++] = ' ';
        }
        ::memcpy(&buffer[used], ptr->pwcText, sizeof(WCHAR) * ptr->ulLen);
        used += ptr->ulLen;
        buffer[used] = '\0';
    }

//    msgbuf = ::FormatMessageInternal(g_hInstance, XML_E_UNCLOSEDTAG, buffer, NULL);
#if 0 // FA String
    TRY
    {
        String* s = Resources::FormatMessage(XML_E_UNCLOSEDTAG,
            String::newString(buffer), NULL);
        _bstrError = s->getBSTR();
        goto cleanup;
    }
    CATCH
    {
        hr = ERESULT;
        goto done;
    }
    ENDTRY
#endif // FA String

    if (msgbuf == NULL)
        goto nomem;

#if 0 // FA BSTR sllocs
    if (_bstrError) ::SysFreeString(_bstrError);
    _bstrError = ::SysAllocString(msgbuf);
    if (_bstrError == NULL)
        goto nomem;
#endif

    goto cleanup;

nomem:
    hr = E_OUTOFMEMORY;
cleanup:
    delete [] buffer;
    delete [] msgbuf;
done:
    return hr;
}

HRESULT XMLParser::init()
{
    CRITICALSECTIONLOCK;

    _fLastError = 0;
    _fStopped = false;
    _fSuspended = false;
    _pNode = _pRoot;
    _fStarted = false;
    _fStopped = false;
    _fWaiting = false;
    _fFoundRoot = false;
    _fFoundNonWS = false;
    _pTokenizer = NULL;
    _fGotVersion = false;
    _cDTD = 0;
    _fSeenDocType = false;
    _fRootLevel = true;
    _cAttributes = 0;
    _fFoundDTDAttribute = false;
    _fPendingBeginChildren = false;
    _fPendingEndChildren = false;

    while (_pCurrent != NULL)
    {
        _pCurrent = _pStack.pop();
    }

    _cNodeInfoCurrent = 0;
    _lCurrentElement = 0;

    // cleanup downloads
    while (_pdc != NULL)
    {
        PopDownload();
    }

    _pCurrent = NULL;
    return S_OK;
}

#if 0 // FA URL
/**
 *Gets the URL from the specified IMoniker and binding context
 */
HRESULT XMLParser::ExtractURL(IMoniker* pmk, LPBC pbc, URL* pURL)
{
    LPOLESTR pOleStr = NULL;
    HRESULT hr = S_OK;
    long len = 0;

    checkerr(pmk->GetDisplayName(pbc, pmk, &pOleStr));
    len = ::StrLen(pOleStr);
    // Fix bugs in what GetDisplayName returns...
    if (len > 4 && ::StrNCmpI(pOleStr, _T("file"), 4) == 0)
    {
        TCHAR* buf = new_ne TCHAR[ len + 10 ];
        ::StrCpy(buf, _T("file:///"));
        LPOLESTR ptr = &pOleStr[4];
        if (*ptr == L':') ptr++;
        while (*ptr != NULL && *ptr == L'/') ptr++;
        TCHAR* temp = &buf[7];
        while (*ptr != NULL)
        {
            if (*ptr == L'\\')
                *temp = L'/';
            else
                *temp = *ptr;
            ptr++;
            temp++;
        }
        *temp = '\0'; // NULL terminate it !!
        hr = pURL->set(buf, NULL);
        delete[] buf;
    }
    else
        hr = pURL->set(pOleStr, NULL);

error:
    if (pOleStr)
        CoTaskMemFree(pOleStr);
    return hr;
}

void 
XMLParser::SetMimeType(URLStream* pStm, const WCHAR * pwszMimeType, int length) 
{
    Download* download = FindDownload(pStm);
    if (download && download->_pEncodingStream)
    {
        download->_pEncodingStream->SetMimeType(pwszMimeType, length);
    }
}


void 
XMLParser::SetCharset(URLStream* pStm, const WCHAR * pwszCharset, int length) 
{
    Download* download = FindDownload(pStm);
    if (download && download->_pEncodingStream)
    {
        download->_pEncodingStream->SetCharset(pwszCharset, length);
    }
}
#endif


HRESULT 
XMLParser::ErrorCallback(HRESULT hr)
{
    Assert(hr == XMLStream::XML_DATAAVAILABLE ||
           hr == XMLStream::XML_DATAREALLOCATE);

    if (hr == XMLStream::XML_DATAREALLOCATE)
    {
        // This is more serious.  We have to actually save away the
        // context because the buffers are about to be reallocated.
        checkhr2(CopyContext());
    }
    checkhr2(_pFactory->NotifyEvent(this, XMLNF_DATAAVAILABLE));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\xmllib\xml\xmlstream\htmlent.cxx ===
#include "core.hxx"
#pragma hdrstop

#include "htmlent.hxx"

struct _EntityInfo
{
    const TCHAR* _pszName;
    WCHAR        _nCode;
};

#define ENTITY(name, code) { _T(#name), code },

int MyStrCmpN(const WCHAR* pszStr, const WCHAR* pwc, ULONG len)
{
    // For some reason SHLWAPI StrCmpN DOESN'T WORK.
    // It returns a negative number for StrCmpN("image","AAA",3)
    // and a positive number for StrCmpN("aagrave", "AAA", 3) !!!

    // This also has the added advantage of not also having to call
    // StrLen to make sure the lengths are the same.

/********** modelled after strncmp.

The return value indicates the relation of the substrings of string1 and string2 as follows.

Return Value    Description
-----------------------------------------------------------------
< 0             string1 substring less than string2 substring
0               string1 substring identical to string2 substring
> 0             string1 substring greater than string2 substring
 
******/

    for (ULONG i = 0; i < len && *pszStr != NULL; i++)
    {
        if (*pszStr < *pwc)
        {
            return -1;
        }
        else if (*pszStr > *pwc)
        {
            return 1;
        }
        pszStr++;
        pwc++;
    }

    if (i < len)
    {
        return -1;
    }
    else if (*pszStr > 0)
    {
        return 1;// must be greater then
    }

    return 0;
}

/************
// These are the various built in entities that are supported when in HTML compatibility mode.
// I took these lists, combined them then pumped them through sort so that I can build a sorted
// static list and then use a binary search lookup.  This saves having to build a static
// Hashtable, and since it's for IE 4 compatibility mode, a binary search is good enough.

static _EntityInfo BuiltIn[] = {
    ENTITY(quot, 34)          // 
    ENTITY(amp, 38)           // & - ampersand
    ENTITY(apos, 39)          // ' - apostrophe //// not part of HTML!
    ENTITY(lt, 60)            // < less than
    ENTITY(gt, 62)            // > greater than
    { null, 0 }
};

static _EntityInfo BuiltInExt[] = {

    ENTITY(nbsp, 160)         // Non breaking space
    ENTITY(iexcl, 161)        //
    ENTITY(cent, 162)         // cent
    ENTITY(pound, 163)        // pound
    ENTITY(curren, 164)       // currency
    ENTITY(yen, 165)          // yen
    ENTITY(brvbar, 166)       // vertical bar
    ENTITY(sect, 167)         // section
    ENTITY(uml, 168)          //
    ENTITY(copy, 169)         // Copyright
    ENTITY(ordf, 170)         //
    ENTITY(laquo, 171)        //
    ENTITY(not, 172)          //
    ENTITY(shy, 173)          //
    ENTITY(reg, 174)          // Registered TradeMark
    ENTITY(macr, 175)         //
    ENTITY(deg, 176)          //
    ENTITY(plusmn, 177)       //
    ENTITY(sup2, 178)         //
    ENTITY(sup3, 179)         //
    ENTITY(acute, 180)        //
    ENTITY(micro, 181)        //
    ENTITY(para, 182)         //
    ENTITY(middot, 183)       //
    ENTITY(cedil, 184)        //
    ENTITY(sup1, 185)         //
    ENTITY(ordm, 186)         //
    ENTITY(raquo, 187)        //
    ENTITY(frac14, 188)       // 1/4
    ENTITY(frac12, 189)       // 1/2
    ENTITY(frac34, 190)       // 3/4
    ENTITY(iquest, 191)       // Inverse question mark
    ENTITY(Agrave, 192)       // Capital A grave accent
    ENTITY(Aacute, 193)       // Capital A acute accent
    ENTITY(Acirc, 194)        // Capital A circumflex accent
    ENTITY(Atilde, 195)       // Capital A tilde
    ENTITY(Auml, 196)         // Capital A dieresis or umlaut mark
    ENTITY(Aring, 197)        // Capital A ring
    ENTITY(AElig, 198)        // Capital AE dipthong (ligature)
    ENTITY(Ccedil, 199)       // Capital C cedilla
    ENTITY(Egrave, 200)       // Capital E grave accent
    ENTITY(Eacute, 201)       // Capital E acute accent
    ENTITY(Ecirc, 202)        // Capital E circumflex accent
    ENTITY(Euml, 203)         // Capital E dieresis or umlaut mark
    ENTITY(Igrave, 204)       // Capital I grave accent
    ENTITY(Iacute, 205)       // Capital I acute accent
    ENTITY(Icirc, 206)        // Capital I circumflex accent
    ENTITY(Iuml, 207)         // Capital I dieresis or umlaut mark
    ENTITY(ETH, 208)          // Capital Eth Icelandic
    ENTITY(Ntilde, 209)       // Capital N tilde
    ENTITY(Ograve, 210)       // Capital O grave accent
    ENTITY(Oacute, 211)       // Capital O acute accent
    ENTITY(Ocirc, 212)        // Capital O circumflex accent
    ENTITY(Otilde, 213)       // Capital O tilde
    ENTITY(Ouml, 214)         // Capital O dieresis or umlaut mark
    ENTITY(times, 215)        // multiply or times
    ENTITY(Oslash, 216)       // Capital O slash
    ENTITY(Ugrave, 217)       // Capital U grave accent
    ENTITY(Uacute, 218)       // Capital U acute accent
    ENTITY(Ucirc, 219)        // Capital U circumflex accent
    ENTITY(Uuml, 220)         // Capital U dieresis or umlaut mark;
    ENTITY(Yacute, 221)       // Capital Y acute accent
    ENTITY(THORN, 222)        // Capital THORN Icelandic
    ENTITY(szlig, 223)        // Small sharp s German (sz ligature)
    ENTITY(agrave, 224)       // Small a grave accent
    ENTITY(aacute, 225)       // Small a acute accent
    ENTITY(acirc, 226)        // Small a circumflex accent
    ENTITY(atilde, 227)       // Small a tilde
    ENTITY(auml, 228)         // Small a dieresis or umlaut mark
    ENTITY(aring, 229)        // Small a ring
    ENTITY(aelig, 230)        // Small ae dipthong (ligature)
    ENTITY(ccedil, 231)       // Small c cedilla
    ENTITY(egrave, 232)       // Small e grave accent
    ENTITY(eacute, 233)       // Small e acute accent
    ENTITY(ecirc, 234)        // Small e circumflex accent
    ENTITY(euml, 235)         // Small e dieresis or umlaut mark
    ENTITY(igrave, 236)       // Small i grave accent
    ENTITY(iacute, 237)       // Small i acute accent
    ENTITY(icirc, 238)        // Small i circumflex accent
    ENTITY(iuml, 239)         // Small i dieresis or umlaut mark
    ENTITY(eth, 240)          // Small eth Icelandic
    ENTITY(ntilde, 241)       // Small n tilde
    ENTITY(ograve, 242)       // Small o grave accent
    ENTITY(oacute, 243)       // Small o acute accent
    ENTITY(ocirc, 244)        // Small o circumflex accent
    ENTITY(otilde, 245)       // Small o tilde
    ENTITY(ouml, 246)         // Small o dieresis or umlaut mark
    ENTITY(divide, 247)       // divide
    ENTITY(oslash, 248)       // Small o slash
    ENTITY(ugrave, 249)       // Small u grave accent
    ENTITY(uacute, 250)       // Small u acute accent
    ENTITY(ucirc, 251)        // Small u circumflex accent
    ENTITY(uuml, 252)         // Small u dieresis or umlaut mark
    ENTITY(yacute, 253)       // Small y acute accent
    ENTITY(thorn, 254)        // Small thorn Icelandic
    ENTITY(yuml, 255)         // Small y dieresis or umlaut mark
    ENTITY(OElig, 338)        // latin capital ligature oe, U0152 ISOlat2
    ENTITY(oelig, 339)        // latin small ligature oe, U0153 ISOlat2
    ENTITY(Scaron, 352)       // latin capital letter s with caron, U0160 ISOlat2
    ENTITY(scaron, 353)       // latin small letter s with caron, U0161 ISOlat2
    ENTITY(Yuml, 376)         // latin capital letter y with diaeresis, U0178 ISOlat2
    ENTITY(fnof, 402)         // latin small f with hook, =function, =florin, U0192 ISOtech
    ENTITY(circ, 710)         // modifier letter circumflex accent, U02C6 ISOpub
    ENTITY(tilde, 732)        // small tilde, U02DC ISOdia
    ENTITY(Alpha, 913)        // greek capital letter alpha
    ENTITY(Beta, 914)         // greek capital letter beta
    ENTITY(Gamma, 915)        // greek capital letter gamma
    ENTITY(Delta, 916)        // greek capital letter delta
    ENTITY(Epsilon, 917)      // greek capital letter epsilon
    ENTITY(Zeta, 918)         // greek capital letter zeta
    ENTITY(Eta, 919)          // greek capital letter eta
    ENTITY(Theta, 920)        // greek capital letter theta
    ENTITY(Iota, 921)         // greek capital letter iota 
    ENTITY(Kappa, 922)        // greek capital letter kappa
    ENTITY(Lambda, 923)       // greek capital letter lambda
    ENTITY(Mu, 924)           // greek capital letter mu
    ENTITY(Nu, 925)           // greek capital letter nu
    ENTITY(Xi, 926)           // greek capital letter xi
    ENTITY(Omicron, 927)      // greek capital letter omicron
    ENTITY(Pi, 928)           // greek capital letter pi
    ENTITY(Rho, 929)          // greek capital letter rho
    ENTITY(Sigma, 931)        // greek capital letter sigma
    ENTITY(Tau, 932)          // greek capital letter tau
    ENTITY(Upsilon, 933)      // greek capital letter upsilon
    ENTITY(Phi, 934)          // greek capital letter phi
    ENTITY(Chi, 935)          // greek capital letter chi
    ENTITY(Psi, 936)          // greek capital letter psi   
    ENTITY(Omega, 937)        // greek capital letter omega
    ENTITY(alpha, 945)        // greek small letter alpha
    ENTITY(beta, 946)         // greek small letter beta
    ENTITY(gamma, 947)        // greek small letter gamma
    ENTITY(delta, 948)        // greek small letter delta
    ENTITY(epsilon, 949)      // greek small letter epsilon
    ENTITY(zeta, 950)         // greek small letter zeta
    ENTITY(eta, 951)          // greek small letter eta
    ENTITY(theta, 952)        // greek small letter theta
    ENTITY(iota, 953)         // greek small letter iota 
    ENTITY(kappa, 954)        // greek small letter kappa
    ENTITY(lambda, 955)       // greek small letter lambda
    ENTITY(mu, 956)           // greek small letter mu
    ENTITY(nu, 957)           // greek small letter nu
    ENTITY(xi, 958)           // greek small letter xi
    ENTITY(omicron, 959)      // greek small letter omicron
    ENTITY(pi, 960)           // greek small letter pi
    ENTITY(rho, 961)          // greek small letter rho
    ENTITY(sigmaf, 962)       // greek small final sigma
    ENTITY(sigma, 963)        // greek small letter sigma
    ENTITY(tau, 964)          // greek small letter tau
    ENTITY(upsilon, 965)      // greek small letter upsilon
    ENTITY(phi, 966)          // greek small letter phi
    ENTITY(chi, 967)          // greek small letter chi
    ENTITY(psi, 968)          // greek small letter psi   
    ENTITY(omega, 969)        // greek small letter omega
    ENTITY(thetasym, 977)     // greek small letter theta symbol, U03D1 NEW
    ENTITY(upsih, 978)        // greek upsilon with hook symbol
    ENTITY(piv, 982)          // greek pi symbol
    ENTITY(ensp, 8194)        // en space, U2002 ISOpub
    ENTITY(emsp, 8195)        // em space, U2003 ISOpub
    ENTITY(thinsp, 8201)      // thin space, U2009 ISOpub
    ENTITY(zwnj, 8204)        // zero width non-joiner, U200C NEW RFC 2070
    ENTITY(zwj, 8205)         // zero width joiner, U200D NEW RFC 2070
    ENTITY(lrm, 8206)         // left-to-right mark, U200E NEW RFC 2070
    ENTITY(rlm, 8207)         // right-to-left mark, U200F NEW RFC 2070
    ENTITY(ndash, 8211)       // en dash, U2013 ISOpub
    ENTITY(mdash, 8212)       // em dash, U2014 ISOpub
    ENTITY(lsquo, 8216)       // left single quotation mark, U2018 ISOnum
    ENTITY(rsquo, 8217)       // right single quotation mark, U2019 ISOnum
    ENTITY(sbquo, 8218)       // single low-9 quotation mark, U201A NEW
    ENTITY(ldquo, 8220)       // left double quotation mark, U201C ISOnum
    ENTITY(rdquo, 8221)       // right double quotation mark, U201D ISOnum
    ENTITY(bdquo, 8222)       // double low-9 quotation mark, U201E NEW
    ENTITY(dagger, 8224)      // dagger, U2020 ISOpub
    ENTITY(Dagger, 8225)      // double dagger, U2021 ISOpub
    ENTITY(bull, 8226)        // bullet, =black small circle, U2022 ISOpub
    ENTITY(hellip, 8230)      // horizontal ellipsis, =three dot leader, U2026 ISOpub
    ENTITY(permil, 8240)      // per mille sign, U2030 ISOtech
    ENTITY(prime, 8242)       // prime, =minutes, =feet, U2032 ISOtech
    ENTITY(Prime, 8243)       // double prime, =seconds, =inches, U2033 ISOtech
    ENTITY(lsaquo, 8249)      // single left-pointing angle quotation mark, U2039 ISO proposed
    ENTITY(rsaquo, 8250)      // single right-pointing angle quotation mark, U203A ISO proposed
    ENTITY(oline, 8254)       // overline, spacing overscore
    ENTITY(frasl, 8260)       // fraction slash
    ENTITY(image, 8465)       // blackletter capital I, =imaginary part, U2111 ISOamso 
    ENTITY(weierp, 8472)      // script capital P, =power set, =Weierstrass p, U2118 ISOamso 
    ENTITY(real, 8476)        // blackletter capital R, =real part symbol, U211C ISOamso 
    ENTITY(trade, 8482)       // trade mark sign, U2122 ISOnum 
    ENTITY(alefsym, 8501)     // alef symbol, =first transfinite cardinal, U2135 NEW 
    ENTITY(larr, 8592)        // leftwards arrow, U2190 ISOnum 
    ENTITY(uarr, 8593)        // upwards arrow, U2191 ISOnum
    ENTITY(rarr, 8594)        // rightwards arrow, U2192 ISOnum 
    ENTITY(darr, 8595)        // downwards arrow, U2193 ISOnum 
    ENTITY(harr, 8596)        // left right arrow, U2194 ISOamsa 
    ENTITY(crarr, 8629)       // downwards arrow with corner leftwards, =carriage return, U21B5 NEW 
    ENTITY(lArr, 8656)        // leftwards double arrow, U21D0 ISOtech 
    ENTITY(uArr, 8657)        // upwards double arrow, U21D1 ISOamsa 
    ENTITY(rArr, 8658)        // rightwards double arrow, U21D2 ISOtech 
    ENTITY(dArr, 8659)        // downwards double arrow, U21D3 ISOamsa 
    ENTITY(hArr, 8660)        // left right double arrow, U21D4 ISOamsa 
    ENTITY(forall, 8704)      // for all, U2200 ISOtech 
    ENTITY(part, 8706)        // partial differential, U2202 ISOtech  
    ENTITY(exist, 8707)       // there exists, U2203 ISOtech 
    ENTITY(empty, 8709)       // empty set, =null set, =diameter, U2205 ISOamso 
    ENTITY(nabla, 8711)       // nabla, =backward difference, U2207 ISOtech 
    ENTITY(isin, 8712)        // element of, U2208 ISOtech 
    ENTITY(notin, 8713)       // not an element of, U2209 ISOtech 
    ENTITY(ni, 8715)          // contains as member, U220B ISOtech 
    ENTITY(prod, 8719)        // n-ary product, =product sign, U220F ISOamsb 
    ENTITY(sum, 8721)         // n-ary sumation, U2211 ISOamsb 
    ENTITY(minus, 8722)       // minus sign, U2212 ISOtech 
    ENTITY(lowast, 8727)      // asterisk operator, U2217 ISOtech 
    ENTITY(radic, 8730)       // square root, =radical sign, U221A ISOtech 
    ENTITY(prop, 8733)        // proportional to, U221D ISOtech 
    ENTITY(infin, 8734)       // infinity, U221E ISOtech 
    ENTITY(ang, 8736)         // angle, U2220 ISOamso 
    ENTITY(and, 8743)         // logical and, =wedge, U2227 ISOtech 
    ENTITY(or, 8744)          // logical or, =vee, U2228 ISOtech 
    ENTITY(cap, 8745)         // intersection, =cap, U2229 ISOtech 
    ENTITY(cup, 8746)         // union, =cup, U222A ISOtech 
    ENTITY(int, 8747)         // integral, U222B ISOtech 
    ENTITY(there4, 8756)      // therefore, U2234 ISOtech 
    ENTITY(sim, 8764)         // tilde operator, =varies with, =similar to, U223C ISOtech 
    ENTITY(cong, 8773)        // approximately equal to, U2245 ISOtech 
    ENTITY(asymp, 8776)       // almost equal to, =asymptotic to, U2248 ISOamsr 
    ENTITY(ne, 8800)          // not equal to, U2260 ISOtech 
    ENTITY(equiv, 8801)       // identical to, U2261 ISOtech 
    ENTITY(le, 8804)          // less-than or equal to, U2264 ISOtech 
    ENTITY(ge, 8805)          // greater-than or equal to, U2265 ISOtech 
    ENTITY(sub, 8834)         // subset of, U2282 ISOtech 
    ENTITY(sup, 8835)         // superset of, U2283 ISOtech 
    ENTITY(nsub, 8836)        // not a subset of, U2284 ISOamsn 
    ENTITY(sube, 8838)        // subset of or equal to, U2286 ISOtech 
    ENTITY(supe, 8839)        // superset of or equal to, U2287 ISOtech 
    ENTITY(oplus, 8853)       // circled plus, =direct sum, U2295 ISOamsb 
    ENTITY(otimes, 8855)      // circled times, =vector product, U2297 ISOamsb 
    ENTITY(perp, 8869)        // up tack, =orthogonal to, =perpendicular, U22A5 ISOtech 
    ENTITY(sdot, 8901)        // dot operator, U22C5 ISOamsb 
    ENTITY(lceil, 8968)       // left ceiling, =apl upstile, U2308, ISOamsc  
    ENTITY(rceil, 8969)       // right ceiling, U2309, ISOamsc  
    ENTITY(lfloor, 8970)      // left floor, =apl downstile, U230A, ISOamsc  
    ENTITY(rfloor, 8971)      // right floor, U230B, ISOamsc  
    ENTITY(lang, 9001)        // left-pointing angle bracket, =bra, U2329 ISOtech 
    ENTITY(rang, 9002)        // right-pointing angle bracket, =ket, U232A ISOtech 
    ENTITY(loz, 9674)         // lozenge, U25CA ISOpub 
    ENTITY(spades, 9824)      // black spade suit, U2660 ISOpub 
    ENTITY(clubs, 9827)       // black club suit, =shamrock, U2663 ISOpub 
    ENTITY(hearts, 9829)      // black heart suit, =valentine, U2665 ISOpub 
    ENTITY(diams, 9830)       // black diamond suit, U2666 ISOpub 

    // These are Netscape-compatible synonyms for some above entities.

    ENTITY(QUOT, 34)          // For Netscape compatibility
    ENTITY(AMP, 38)           // For Netscape compatibility
    ENTITY(LT, 60)            // For Netscape compatibility
    ENTITY(GT, 62)            // For Netscape compatibility
    ENTITY(COPY, 169)         // For Netscape compatibility
    ENTITY(REG, 174)          // For Netscape compatibility
    ENTITY(TRADE, 8482)       // For IE3 compatibility

    // These are IE5 entities

    ENTITY(zwsp, 0203)    // zero width space             U200B NEW RFC 2070
    ENTITY(lre, 8234)    // Left-to-right embedding      U200F NEW RFC 2070
    ENTITY(rle, 8235)    // Right-to-left embedding      U200F NEW RFC 2070
    ENTITY(pdf, 8236)    // Pop direction format         U200F NEW RFC 2070
    ENTITY(lro, 8237)    // Left-to-right override       U200F NEW RFC 2070
    ENTITY(rlo, 8238)    // Right-to-left override       U200F NEW RFC 2070
    ENTITY(iss, 8298)    // Inhibit symmetric            U200F NEW RFC 2070 swapping
    ENTITY(ass, 8299)    // Activate symmetric           U200F NEW RFC 2070 swapping
    ENTITY(iafs, 8300)    // Inhibit Arabic form          U200F NEW RFC 2070 shaping
    ENTITY(aafs, 8301)    // Activate Arabic form         U200F NEW RFC 2070 shaping
    ENTITY(nads, 8302)    // National digit shapes        U200F NEW RFC 2070
    ENTITY(nods, 8303)    // Nominal digit shapes         U200F NEW RFC 2070

    {null, 0}
};

*************/

static const _EntityInfo s_BuiltInEntites[] = 
{
    ENTITY(AElig, 198)        // Capital AE dipthong (ligature)
    ENTITY(AMP, 38)           // For Netscape compatibility
    ENTITY(Aacute, 193)       // Capital A acute accent
    ENTITY(Acirc, 194)        // Capital A circumflex accent
    ENTITY(Agrave, 192)       // Capital A grave accent
    ENTITY(Alpha, 913)        // greek capital letter alpha
    ENTITY(Aring, 197)        // Capital A ring
    ENTITY(Atilde, 195)       // Capital A tilde
    ENTITY(Auml, 196)         // Capital A dieresis or umlaut mark
    ENTITY(Beta, 914)         // greek capital letter beta
    ENTITY(COPY, 169)         // For Netscape compatibility
    ENTITY(Ccedil, 199)       // Capital C cedilla
    ENTITY(Chi, 935)          // greek capital letter chi
    ENTITY(Dagger, 8225)      // double dagger, U2021 ISOpub
    ENTITY(Delta, 916)        // greek capital letter delta
    ENTITY(ETH, 208)          // Capital Eth Icelandic
    ENTITY(Eacute, 201)       // Capital E acute accent
    ENTITY(Ecirc, 202)        // Capital E circumflex accent
    ENTITY(Egrave, 200)       // Capital E grave accent
    ENTITY(Epsilon, 917)      // greek capital letter epsilon
    ENTITY(Eta, 919)          // greek capital letter eta
    ENTITY(Euml, 203)         // Capital E dieresis or umlaut mark
    ENTITY(GT, 62)            // For Netscape compatibility
    ENTITY(Gamma, 915)        // greek capital letter gamma
    ENTITY(Iacute, 205)       // Capital I acute accent
    ENTITY(Icirc, 206)        // Capital I circumflex accent
    ENTITY(Igrave, 204)       // Capital I grave accent
    ENTITY(Iota, 921)         // greek capital letter iota 
    ENTITY(Iuml, 207)         // Capital I dieresis or umlaut mark
    ENTITY(Kappa, 922)        // greek capital letter kappa
    ENTITY(LT, 60)            // For Netscape compatibility
    ENTITY(Lambda, 923)       // greek capital letter lambda
    ENTITY(Mu, 924)           // greek capital letter mu
    ENTITY(Ntilde, 209)       // Capital N tilde
    ENTITY(Nu, 925)           // greek capital letter nu
    ENTITY(OElig, 338)        // latin capital ligature oe, U0152 ISOlat2
    ENTITY(Oacute, 211)       // Capital O acute accent
    ENTITY(Ocirc, 212)        // Capital O circumflex accent
    ENTITY(Ograve, 210)       // Capital O grave accent
    ENTITY(Omega, 937)        // greek capital letter omega
    ENTITY(Omicron, 927)      // greek capital letter omicron
    ENTITY(Oslash, 216)       // Capital O slash
    ENTITY(Otilde, 213)       // Capital O tilde
    ENTITY(Ouml, 214)         // Capital O dieresis or umlaut mark
    ENTITY(Phi, 934)          // greek capital letter phi
    ENTITY(Pi, 928)           // greek capital letter pi
    ENTITY(Prime, 8243)       // double prime, =seconds, =inches, U2033 ISOtech
    ENTITY(Psi, 936)          // greek capital letter psi   
    ENTITY(QUOT, 34)          // For Netscape compatibility
    ENTITY(REG, 174)          // For Netscape compatibility
    ENTITY(Rho, 929)          // greek capital letter rho
    ENTITY(Scaron, 352)       // latin capital letter s with caron, U0160 ISOlat2
    ENTITY(Sigma, 931)        // greek capital letter sigma
    ENTITY(THORN, 222)        // Capital THORN Icelandic
    ENTITY(TRADE, 8482)       // For IE3 compatibility
    ENTITY(Tau, 932)          // greek capital letter tau
    ENTITY(Theta, 920)        // greek capital letter theta
    ENTITY(Uacute, 218)       // Capital U acute accent
    ENTITY(Ucirc, 219)        // Capital U circumflex accent
    ENTITY(Ugrave, 217)       // Capital U grave accent
    ENTITY(Upsilon, 933)      // greek capital letter upsilon
    ENTITY(Uuml, 220)         // Capital U dieresis or umlaut mark;
    ENTITY(Xi, 926)           // greek capital letter xi
    ENTITY(Yacute, 221)       // Capital Y acute accent
    ENTITY(Yuml, 376)         // latin capital letter y with diaeresis, U0178 ISOlat2
    ENTITY(Zeta, 918)         // greek capital letter zeta
    ENTITY(aacute, 225)       // Small a acute accent
    ENTITY(aafs, 8301)    // Activate Arabic form         U200F NEW RFC 2070 shaping
    ENTITY(acirc, 226)        // Small a circumflex accent
    ENTITY(acute, 180)        //
    ENTITY(aelig, 230)        // Small ae dipthong (ligature)
    ENTITY(agrave, 224)       // Small a grave accent
    ENTITY(alefsym, 8501)     // alef symbol, =first transfinite cardinal, U2135 NEW 
    ENTITY(alpha, 945)        // greek small letter alpha
    ENTITY(amp, 38)           // & - ampersand
    ENTITY(and, 8743)         // logical and, =wedge, U2227 ISOtech 
    ENTITY(ang, 8736)         // angle, U2220 ISOamso 
    ENTITY(apos, 39)          // ' - apostrophe //// not part of HTML!
    ENTITY(aring, 229)        // Small a ring
    ENTITY(ass, 8299)    // Activate symmetric           U200F NEW RFC 2070 swapping
    ENTITY(asymp, 8776)       // almost equal to, =asymptotic to, U2248 ISOamsr 
    ENTITY(atilde, 227)       // Small a tilde
    ENTITY(auml, 228)         // Small a dieresis or umlaut mark
    ENTITY(bdquo, 8222)       // double low-9 quotation mark, U201E NEW
    ENTITY(beta, 946)         // greek small letter beta
    ENTITY(brvbar, 166)       // vertical bar
    ENTITY(bull, 8226)        // bullet, =black small circle, U2022 ISOpub
    ENTITY(cap, 8745)         // intersection, =cap, U2229 ISOtech 
    ENTITY(ccedil, 231)       // Small c cedilla
    ENTITY(cedil, 184)        //
    ENTITY(cent, 162)         // cent
    ENTITY(chi, 967)          // greek small letter chi
    ENTITY(circ, 710)         // modifier letter circumflex accent, U02C6 ISOpub
    ENTITY(clubs, 9827)       // black club suit, =shamrock, U2663 ISOpub 
    ENTITY(cong, 8773)        // approximately equal to, U2245 ISOtech 
    ENTITY(copy, 169)         // Copyright
    ENTITY(crarr, 8629)       // downwards arrow with corner leftwards, =carriage return, U21B5 NEW 
    ENTITY(cup, 8746)         // union, =cup, U222A ISOtech 
    ENTITY(curren, 164)       // currency
    ENTITY(dArr, 8659)        // downwards double arrow, U21D3 ISOamsa 
    ENTITY(dagger, 8224)      // dagger, U2020 ISOpub
    ENTITY(darr, 8595)        // downwards arrow, U2193 ISOnum 
    ENTITY(deg, 176)          //
    ENTITY(delta, 948)        // greek small letter delta
    ENTITY(diams, 9830)       // black diamond suit, U2666 ISOpub 
    ENTITY(divide, 247)       // divide
    ENTITY(eacute, 233)       // Small e acute accent
    ENTITY(ecirc, 234)        // Small e circumflex accent
    ENTITY(egrave, 232)       // Small e grave accent
    ENTITY(empty, 8709)       // empty set, =null set, =diameter, U2205 ISOamso 
    ENTITY(emsp, 8195)        // em space, U2003 ISOpub
    ENTITY(ensp, 8194)        // en space, U2002 ISOpub
    ENTITY(epsilon, 949)      // greek small letter epsilon
    ENTITY(equiv, 8801)       // identical to, U2261 ISOtech 
    ENTITY(eta, 951)          // greek small letter eta
    ENTITY(eth, 240)          // Small eth Icelandic
    ENTITY(euml, 235)         // Small e dieresis or umlaut mark
    ENTITY(exist, 8707)       // there exists, U2203 ISOtech 
    ENTITY(fnof, 402)         // latin small f with hook, =function, =florin, U0192 ISOtech
    ENTITY(forall, 8704)      // for all, U2200 ISOtech 
    ENTITY(frac12, 189)       // 1/2
    ENTITY(frac14, 188)       // 1/4
    ENTITY(frac34, 190)       // 3/4
    ENTITY(frasl, 8260)       // fraction slash
    ENTITY(gamma, 947)        // greek small letter gamma
    ENTITY(ge, 8805)          // greater-than or equal to, U2265 ISOtech 
    ENTITY(gt, 62)            // > greater than
    ENTITY(hArr, 8660)        // left right double arrow, U21D4 ISOamsa 
    ENTITY(harr, 8596)        // left right arrow, U2194 ISOamsa 
    ENTITY(hearts, 9829)      // black heart suit, =valentine, U2665 ISOpub 
    ENTITY(hellip, 8230)      // horizontal ellipsis, =three dot leader, U2026 ISOpub
    ENTITY(iacute, 237)       // Small i acute accent
    ENTITY(iafs, 8300)    // Inhibit Arabic form          U200F NEW RFC 2070 shaping
    ENTITY(icirc, 238)        // Small i circumflex accent
    ENTITY(iexcl, 161)        //
    ENTITY(igrave, 236)       // Small i grave accent
    ENTITY(image, 8465)       // blackletter capital I, =imaginary part, U2111 ISOamso 
    ENTITY(infin, 8734)       // infinity, U221E ISOtech 
    ENTITY(int, 8747)         // integral, U222B ISOtech 
    ENTITY(iota, 953)         // greek small letter iota 
    ENTITY(iquest, 191)       // Inverse question mark
    ENTITY(isin, 8712)        // element of, U2208 ISOtech 
    ENTITY(iss, 8298)    // Inhibit symmetric            U200F NEW RFC 2070 swapping
    ENTITY(iuml, 239)         // Small i dieresis or umlaut mark
    ENTITY(kappa, 954)        // greek small letter kappa
    ENTITY(lArr, 8656)        // leftwards double arrow, U21D0 ISOtech 
    ENTITY(lambda, 955)       // greek small letter lambda
    ENTITY(lang, 9001)        // left-pointing angle bracket, =bra, U2329 ISOtech 
    ENTITY(laquo, 171)        //
    ENTITY(larr, 8592)        // leftwards arrow, U2190 ISOnum 
    ENTITY(lceil, 8968)       // left ceiling, =apl upstile, U2308, ISOamsc  
    ENTITY(ldquo, 8220)       // left double quotation mark, U201C ISOnum
    ENTITY(le, 8804)          // less-than or equal to, U2264 ISOtech 
    ENTITY(lfloor, 8970)      // left floor, =apl downstile, U230A, ISOamsc  
    ENTITY(lowast, 8727)      // asterisk operator, U2217 ISOtech 
    ENTITY(loz, 9674)         // lozenge, U25CA ISOpub 
    ENTITY(lre, 8234)    // Left-to-right embedding      U200F NEW RFC 2070
    ENTITY(lrm, 8206)         // left-to-right mark, U200E NEW RFC 2070
    ENTITY(lro, 8237)    // Left-to-right override       U200F NEW RFC 2070
    ENTITY(lsaquo, 8249)      // single left-pointing angle quotation mark, U2039 ISO proposed
    ENTITY(lsquo, 8216)       // left single quotation mark, U2018 ISOnum
    ENTITY(lt, 60)            // < less than
    ENTITY(macr, 175)         //
    ENTITY(mdash, 8212)       // em dash, U2014 ISOpub
    ENTITY(micro, 181)        //
    ENTITY(middot, 183)       //
    ENTITY(minus, 8722)       // minus sign, U2212 ISOtech 
    ENTITY(mu, 956)           // greek small letter mu
    ENTITY(nabla, 8711)       // nabla, =backward difference, U2207 ISOtech 
    ENTITY(nads, 8302)    // National digit shapes        U200F NEW RFC 2070
    ENTITY(nbsp, 160)         // Non breaking space
    ENTITY(ndash, 8211)       // en dash, U2013 ISOpub
    ENTITY(ne, 8800)          // not equal to, U2260 ISOtech 
    ENTITY(ni, 8715)          // contains as member, U220B ISOtech 
    ENTITY(nods, 8303)    // Nominal digit shapes         U200F NEW RFC 2070
    ENTITY(not, 172)          //
    ENTITY(notin, 8713)       // not an element of, U2209 ISOtech 
    ENTITY(nsub, 8836)        // not a subset of, U2284 ISOamsn 
    ENTITY(ntilde, 241)       // Small n tilde
    ENTITY(nu, 957)           // greek small letter nu
    ENTITY(oacute, 243)       // Small o acute accent
    ENTITY(ocirc, 244)        // Small o circumflex accent
    ENTITY(oelig, 339)        // latin small ligature oe, U0153 ISOlat2
    ENTITY(ograve, 242)       // Small o grave accent
    ENTITY(oline, 8254)       // overline, spacing overscore
    ENTITY(omega, 969)        // greek small letter omega
    ENTITY(omicron, 959)      // greek small letter omicron
    ENTITY(oplus, 8853)       // circled plus, =direct sum, U2295 ISOamsb 
    ENTITY(or, 8744)          // logical or, =vee, U2228 ISOtech 
    ENTITY(ordf, 170)         //
    ENTITY(ordm, 186)         //
    ENTITY(oslash, 248)       // Small o slash
    ENTITY(otilde, 245)       // Small o tilde
    ENTITY(otimes, 8855)      // circled times, =vector product, U2297 ISOamsb 
    ENTITY(ouml, 246)         // Small o dieresis or umlaut mark
    ENTITY(para, 182)         //
    ENTITY(part, 8706)        // partial differential, U2202 ISOtech  
    ENTITY(pdf, 8236)    // Pop direction format         U200F NEW RFC 2070
    ENTITY(permil, 8240)      // per mille sign, U2030 ISOtech
    ENTITY(perp, 8869)        // up tack, =orthogonal to, =perpendicular, U22A5 ISOtech 
    ENTITY(phi, 966)          // greek small letter phi
    ENTITY(pi, 960)           // greek small letter pi
    ENTITY(piv, 982)          // greek pi symbol
    ENTITY(plusmn, 177)       //
    ENTITY(pound, 163)        // pound
    ENTITY(prime, 8242)       // prime, =minutes, =feet, U2032 ISOtech
    ENTITY(prod, 8719)        // n-ary product, =product sign, U220F ISOamsb 
    ENTITY(prop, 8733)        // proportional to, U221D ISOtech 
    ENTITY(psi, 968)          // greek small letter psi   
    ENTITY(quot, 34)            // built in
    ENTITY(rArr, 8658)        // rightwards double arrow, U21D2 ISOtech 
    ENTITY(radic, 8730)       // square root, =radical sign, U221A ISOtech 
    ENTITY(rang, 9002)        // right-pointing angle bracket, =ket, U232A ISOtech 
    ENTITY(raquo, 187)        //
    ENTITY(rarr, 8594)        // rightwards arrow, U2192 ISOnum 
    ENTITY(rceil, 8969)       // right ceiling, U2309, ISOamsc  
    ENTITY(rdquo, 8221)       // right double quotation mark, U201D ISOnum
    ENTITY(real, 8476)        // blackletter capital R, =real part symbol, U211C ISOamso 
    ENTITY(reg, 174)          // Registered TradeMark
    ENTITY(rfloor, 8971)      // right floor, U230B, ISOamsc  
    ENTITY(rho, 961)          // greek small letter rho
    ENTITY(rle, 8235)    // Right-to-left embedding      U200F NEW RFC 2070
    ENTITY(rlm, 8207)         // right-to-left mark, U200F NEW RFC 2070
    ENTITY(rlo, 8238)    // Right-to-left override       U200F NEW RFC 2070
    ENTITY(rsaquo, 8250)      // single right-pointing angle quotation mark, U203A ISO proposed
    ENTITY(rsquo, 8217)       // right single quotation mark, U2019 ISOnum
    ENTITY(sbquo, 8218)       // single low-9 quotation mark, U201A NEW
    ENTITY(scaron, 353)       // latin small letter s with caron, U0161 ISOlat2
    ENTITY(sdot, 8901)        // dot operator, U22C5 ISOamsb 
    ENTITY(sect, 167)         // section
    ENTITY(shy, 173)          //
    ENTITY(sigma, 963)        // greek small letter sigma
    ENTITY(sigmaf, 962)       // greek small final sigma
    ENTITY(sim, 8764)         // tilde operator, =varies with, =similar to, U223C ISOtech 
    ENTITY(spades, 9824)      // black spade suit, U2660 ISOpub 
    ENTITY(sub, 8834)         // subset of, U2282 ISOtech 
    ENTITY(sube, 8838)        // subset of or equal to, U2286 ISOtech 
    ENTITY(sum, 8721)         // n-ary sumation, U2211 ISOamsb 
    ENTITY(sup, 8835)         // superset of, U2283 ISOtech 
    ENTITY(sup1, 185)         //
    ENTITY(sup2, 178)         //
    ENTITY(sup3, 179)         //
    ENTITY(supe, 8839)        // superset of or equal to, U2287 ISOtech 
    ENTITY(szlig, 223)        // Small sharp s German (sz ligature)
    ENTITY(tau, 964)          // greek small letter tau
    ENTITY(there4, 8756)      // therefore, U2234 ISOtech 
    ENTITY(theta, 952)        // greek small letter theta
    ENTITY(thetasym, 977)     // greek small letter theta symbol, U03D1 NEW
    ENTITY(thinsp, 8201)      // thin space, U2009 ISOpub
    ENTITY(thorn, 254)        // Small thorn Icelandic
    ENTITY(tilde, 732)        // small tilde, U02DC ISOdia
    ENTITY(times, 215)        // multiply or times
    ENTITY(trade, 8482)       // trade mark sign, U2122 ISOnum 
    ENTITY(uArr, 8657)        // upwards double arrow, U21D1 ISOamsa 
    ENTITY(uacute, 250)       // Small u acute accent
    ENTITY(uarr, 8593)        // upwards arrow, U2191 ISOnum
    ENTITY(ucirc, 251)        // Small u circumflex accent
    ENTITY(ugrave, 249)       // Small u grave accent
    ENTITY(uml, 168)          //
    ENTITY(upsih, 978)        // greek upsilon with hook symbol
    ENTITY(upsilon, 965)      // greek small letter upsilon
    ENTITY(uuml, 252)         // Small u dieresis or umlaut mark
    ENTITY(weierp, 8472)      // script capital P, =power set, =Weierstrass p, U2118 ISOamso 
    ENTITY(xi, 958)           // greek small letter xi
    ENTITY(yacute, 253)       // Small y acute accent
    ENTITY(yen, 165)          // yen
    ENTITY(yuml, 255)         // Small y dieresis or umlaut mark
    ENTITY(zeta, 950)         // greek small letter zeta
    ENTITY(zwj, 8205)         // zero width joiner, U200D NEW RFC 2070
    ENTITY(zwnj, 8204)        // zero width non-joiner, U200C NEW RFC 2070
    ENTITY(zwsp, 0203)    // zero width space             U200B NEW RFC 2070
};

// This implements a binary search lookup on the sorted entity table.
WCHAR LookupBuiltinEntity(const WCHAR* name, ULONG len)
{
    const _EntityInfo* table = s_BuiltInEntites;
    ULONG size = sizeof(s_BuiltInEntites) / sizeof(_EntityInfo);

    // initial range is the entire table - which we have to narrow down.
    ULONG top = 0;
    ULONG bottom = size;

    while (top < bottom)
    {
        ULONG i = top + (bottom - top) / 2;

        const _EntityInfo* pent = &table[i];
        const WCHAR* entname = pent->_pszName;

        // found a matnching character, so see if we're done.
        int rc = MyStrCmpN(entname, name, len);
        if (rc < 0)
        {
            if (top == i)
                top++;
            else
                top = i;
        }
        else if (rc > 0)
        {
            if (bottom == i)
                bottom--;
            else
                bottom = i;
        }
        else
        {
            return pent->_nCode;
        }
    }
    return 0xFFFF;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\xmllib\xml\xmlstream\xmlstream.cxx ===
/*
* 
* Copyright (c) 1998,1999 Microsoft Corporation. All rights reserved.
* EXEMPT: copyright change only, no build required
* 
*/
#include "stdafx.h"
#include <shlwapi.h>
#include "../tokenizer/parser/xmlparser.hxx"    //
#define StrLen lstrlen
#define checkhr(a) hr = a; if (hr != S_OK) return hr;
#define new_ne new
// #define isWhiteSpace iswspace
#define Assert(x)
#define null NULL

// #include "core.hxx"
#pragma hdrstop

// #include <shlwapip.h>   // IsCharSpace FA
#ifdef UNIX
// Not needed under UNIX
#else
#ifndef _WIN64
// #include <w95wraps.h> FA
#endif // _WIN64
#endif /* UNIX */


#ifdef _DEBUGXML
#include "msxmldbg.h"
DeclareTag(tagTokenizer, "XMLStream", "XML Tokenizer");
#endif


#include "xmlstream.hxx"
#include "bufferedstream.hxx"
#include "../../core/util/chartype.hxx"
#include "../../core/util/chartype.cxx"
#include "htmlent.hxx"
#if 0
#include "datatype.hxx"
#include "xmlparser.hxx"
#endif

const long BLOCK_SIZE = 512;
const long STACK_INCREMENT = 10;

#define INTERNALERROR return XML_E_INTERNALERROR;

// a is NULL terminated, and b is not.
bool StringEquals(const WCHAR* a, const WCHAR* b, long size, bool caseInsensitive)
{
    if (! caseInsensitive)
    {
        return (::StrCmpNW(a, b, size) == 0) && ((ULONG)size == ::StrLen(a));
    }
    else
    {
        // BUGBUG -- is this smart about real unicode case insensitivity
        // for all locales ??
        return (::StrCmpNIW(a, b, size) == 0) && ((ULONG)size == ::StrLen(a));
    }    
    return false;
}

#define checkeof(a,b) if (_fEOF) return b;

#define ADVANCE hr = (!_fDTD) ? _pInput->nextChar(&_chLookahead, &_fEOF) : DTDAdvance(); if (hr != S_OK) return hr;

#define ADVANCETO(a) hr = AdvanceTo(a);  if (hr != S_OK) return hr;

// isWhiteSpace is now implemented in the BufferedStream, since we have to
// count new lines anyway - it is more efficient to do it there.
#define ISWHITESPACE(ch) _pInput->isWhiteSpace(ch) 

#define STATE(state) { _sSubState = state; return S_OK; }
#define GOTOSTART(state) { _sSubState = state; goto Start; }


// The tokenizer has special handling for the following attribute types.
// These values are derived from the XML_AT_XXXX types provided in SetType
// and are also calculated during parsing of an ATTLIST for parsing of
// default values.
typedef enum 
{
    XMLTYPE_CDATA,       // the default.
    XMLTYPE_NAME,
    XMLTYPE_NAMES,
    XMLTYPE_NMTOKEN,
    XMLTYPE_NMTOKENS,
} XML_ATTRIBUTE_TYPE;

//==============================================================================
// The DTD stuff uses parsing tables to avoid code bloat.
// Eventually we could even compress these tables and store them in the
// resource section.  There's also plenty of opportunity to make the tables
// smaller by making the opcodes smarter.

// Parse an entity declaration.
const StateEntry g_EntityDeclTable[] =
{
// 0    '<!ENTITY'^ S ('%' S)? Name S ...
    { OP_PETEST, NULL, 1, 0,  },

// 1    '<!ENTITY' S Name ^ S ...
    { OP_WS, NULL, 2, 0,   },
// 2    '<!ENTITY' ... ^ (ExternalID | EntityValue ) ...
    { OP_PEEK, L"\"", 4, 3, 0  },
// 3
    { OP_PEEK, L"'", 4, 9, 0  },
// 4    '<!ENTITY' ... "^EntityValue" ) ...
    { OP_STRING, NULL, 5, 0,   },
// 5   '<!ENTITY' ... "EntityValue" ^ S? '>'
    { OP_TOKEN, NULL, 6, XML_STRING, -1  },
// 6   '<!ENTITY' ... "EntityValue" ^ S? '>'
    { OP_OWS, NULL, 7, 0, 0  },
// 7   '<!ENTITY' ... "EntityValue" S? ^ '>'    
    { OP_CHAR, L">", 8, XML_E_EXPECTINGTAGEND,  0 },
// 8
    { OP_POP, NULL, 0, XMLStream::XML_ENDDECL, 0  },
// 9   '<!ENTITY' ... ^ ExternalID ...
    { OP_EXTID, NULL, 10, 0,   },
// 10   '<!ENTITY' ... ExternalID ^ (S 'NDATA' Name)? '>'
    { OP_NWS, NULL, 7, 11, },
// 11
    { OP_OWS, NULL, 12, 0,   },
// 12   '<!ENTITY' ... ExternalID S ^ ('NDATA' Name | '>')
    { OP_CHAR, L">", 8, 13,  0 },
// 13   '<!ENTITY' ... ExternalID S ^ 'NDATA' Name '>'
    { OP_NAME,  NULL, 14, 0,   },
// 14   '<!ENTITY' ... ExternalID S  'NDATA' ^ Name '>'
    { OP_STRCMP, L"NDATA", 15, XML_E_EXPECTING_NDATA, XML_NDATA },
// 15   '<!ENTITY' ... ExternalID S  'NDATA' ^ S Name '>'
    { OP_WS, NULL, 16, 0,   },
// 16   '<!ENTITY' ... ExternalID S  'NDATA' S ^ Name '>'
    { OP_NAME, NULL, 17, 0, },
// 17   '<!ENTITY' ... ExternalID S  'NDATA' S Name ^ '>'
    { OP_TOKEN, NULL, 6, XML_NAME, 0 },
};


//==============================================================================
// Parse an NOTATION declaration.
const StateEntry g_NotationDeclTable[] =
{
// 0    '<!NOTATION' ^ S Name S (ExternalID | PublicID) S? >
    { OP_WS, NULL, 1, 0,  },                    
// 1    '<!NOTATION' S ^ Name S (ExternalID | PublicID) S? >
    { OP_NAME,  NULL, 2,   },                 
// 2    '<!NOTATION' S Name ^ S ...
    { OP_TOKEN,  NULL, 3, XML_NOTATION, 0  },

// 3    '<!NOTATION' S Name ^ S (ExternalID | PublicID) S? >
    { OP_WS, NULL, 4, 0,   },
// 4    '<!NOTATION' S Name S ^ (ExternalID | PublicID) S? >
    { OP_EXTID, NULL, 5, 1,   }, // _fShortPubIdOption=true
// 5    '<!NOTATION' S Name S (ExternalID | PublicID) ^ S? >
    { OP_OWS, NULL, 6, 0, },
// 6    '<!NOTATION' S Name S (ExternalID | PublicID) S? ^ >
    { OP_CHAR, L">", 7, XML_E_EXPECTINGTAGEND, 0  },
// 7    '<!NOTATION' S Name S (ExternalID | PublicID) S? > ^
    { OP_POP, NULL, 0, XMLStream::XML_ENDDECL, 0  },
};

//==============================================================================
// Parse an the DOCTYPE declaration.
const StateEntry g_DocTypeTable[] =
{
// 0    '<!DOCTYPE^ S Name (S ExternalID)? S? ...
    { OP_WS, NULL, 1, 0  },
// 1    '<!DOCTYPE S ^ Name (S ExternalID)? S? ...
    { OP_NAME, NULL, 2, 0  }, 
// 2    '<!DOCTYPE S Name ^ (S ExternalID)? S? ...
    { OP_TOKEN, NULL, 3, XML_DOCTYPE, 0 }, 
// 3    '<!DOCTYPE S Name ^ (S ExternalID)? S? ('['...']' S?)? '>'
    { OP_NWS, NULL, 9, 4 },
// 4    '<!DOCTYPE S Name ^ S
    { OP_OWS, NULL, 5, 0 },
// 5    '<!DOCTYPE S Name S ^ (ExternalID|'['|'>')
    { OP_CHAR, L"[", 10, 6, 0 },
// 6    '<!DOCTYPE S Name S ^ (ExternalID|'>')
    { OP_CHAR, L">", 13, 7, 0 },
// 7    '<!DOCTYPE S Name S ^ ExternalID
    { OP_EXTID, NULL, 8, 0 },
// 8    '<!DOCTYPE S Name S ExternalID ^ S?
    { OP_OWS, NULL, 9, 0 },
// 9    '<!DOCTYPE ... ^ ('[' | '>') 
    { OP_CHAR, L"[", 10, 11, 0 },
// 10    '<!DOCTYPE ...  '[' ^ 
    { OP_SUBSET, NULL, 11, 0 }, // scan the internal subset
// 11   <!DOCTYPE ...  [...] ^ '>'
    { OP_OWS, NULL, 12, 0 },
// 12
    { OP_CHAR, L">", 13, XML_E_EXPECTINGTAGEND, 0 },
// 13
    { OP_POP, NULL, 0, XMLStream::XML_ENDDECL, 0  },
};


//==============================================================================
// Parse an an external id.
const StateEntry g_ExternalIDTable[] =
{
// 0    ^ ( 'PUBLIC' publid [syslit] | 'SYSTEM' syslit)
    { OP_NAME, NULL, 1, 0,  },                    
// 1    ( 'PUBLIC' | 'SYSTEM' ) ^ ...
    { OP_STRCMP, L"PUBLIC", 3, 2, XML_PUBLIC },
// 2    ( 'PUBLIC' | 'SYSTEM' ) ^ ...
    { OP_STRCMP, L"SYSTEM", 13, XML_E_BADEXTERNALID, XML_SYSTEM },
// 3   'PUBLIC' ^ S publid S [syslit]
    { OP_WS, NULL, 4, 0,   },
// 4   'PUBLIC' S ^ publid S [syslit]
    { OP_ATTRVAL, NULL, 5, 0, },
// 5   'PUBLIC' S publid ^ S [syslit]
    { OP_TOKEN, NULL, 6, XML_PCDATA, -1 },
// 6   'PUBLIC' publid ^ [syslit]       (conditional upon _fShortPubIdOption)
    { OP_PUBIDOPTION, NULL, 7, 11, 0 },
// 7   then system literal is optional
    { OP_NWS, NULL, 16, 8 }, // if no whitespace then we're done !
// 8   soak up the white space.
    { OP_WS, NULL, 9,  },
// 9  if we have a quote character, we must have a system literal
    { OP_PEEK, L"\"", 12, 10, 0  },
// 10
    { OP_PEEK, L"'", 12, 16, 0  },  // otherwise we're done.
// 11   'SYSTEM' ^ S syslit
    { OP_WS, NULL, 12, 0,   },
// 12
    { OP_FAKESYSTEM, NULL, 14 },    // and fake a SYSTEM attribute
// 13   'SYSTEM' ^ S syslit
    { OP_WS, NULL, 14, 0,   },
// 14   'SYSTEM' S ^ syslit
    { OP_ATTRVAL, NULL, 15, 0,   },
// 15   'SYSTEM' S syslit ^ 
    { OP_TOKEN, NULL, 16, XML_PCDATA, -1 },
// 16   must be time to return then.
    { OP_POP, NULL, 0, 0, 1 },
};


//==============================================================================
// --- This is not very good because the OP_CODES are not a real programming
// language.  This would be a lot simpler if I had a STORE and RETRIEVE opcode
// so that I could remember which content model (sequence or choice) I was
// handling.  For now it is just a cut&paste solution for each model type.

const StateEntry g_ContentModelTable[] =
{
// 0    '(' ^ S? Name | choice | seq ')' ('?'|'*'|'+')?
    { OP_OWS, NULL, 1, 0, },
// 1    '(' S? ^ Name | choice | seq ')' ('?'|'*'|'+')?
    { OP_CHAR, L"(", 2, 3, 0 },
// 2    nested model - have to push states.
    { OP_TABLE, (const WCHAR*)g_ContentModelTable, 5, XML_GROUP },
// 3    '(' S? ^ Name 
    { OP_NAME, NULL, 4, },
// 4    '(' S? Name ^
    { OP_TOKEN, NULL, 5, XML_NAME, },
// 5    '(' S? Name ^ ('?'|'*'|'+')? S? ')'
    { OP_CHAR, L"?", 8, 6, XML_QUESTIONMARK },
//  6
    { OP_CHAR, L"*", 8, 7, XML_STAR },
//  7
    { OP_CHAR, L"+", 8, 8, XML_PLUS },
//  8
    { OP_OWS, NULL, 9, 0, },
//  9
    { OP_CHAR, L"|", 13, 10, XML_CHOICE }, // Ah ha, it's a CHOICE model
//  10
    { OP_CHAR, L",", 24, 11, XML_SEQUENCE }, // Ah ha, it's a SEQUENCE model 
//  11
    { OP_CHAR, L")", 35, XML_E_BADCHARINMODEL, XMLStream::XML_CLOSEPAREN }, 
//  12
    { OP_POP, NULL, 0, 0  },     // CAN REMOVE THIS STATE.

//  13  ----- Handle a CHOICE model
    { OP_OWS, NULL, 14, 0, },
//  14    '(' S? ^ Name | choice | seq ')' ('?'|'*'|'+')?
    { OP_CHAR, L"(", 15, 16, 0 },
//  15    nested model - have to push states.
    { OP_TABLE, (const WCHAR*)g_ContentModelTable, 18, XML_GROUP  },
//  16    '(' Name S? '|' S? ^ Name (S? '|' S? Name)* ')'
    { OP_NAME, NULL, 17, },
//  17    '(' Name S? '|' S? Name ^ (S? '|' S? Name)* ')'
    { OP_TOKEN, NULL, 18, XML_NAME, 0},
//  18    '(' S? Name ^ ('?'|'*'|'+')? S? ')'
    { OP_CHAR, L"?", 21, 19, XML_QUESTIONMARK },
//  19
    { OP_CHAR, L"*", 21, 20, XML_STAR },
//  20
    { OP_CHAR, L"+", 21, 21, XML_PLUS },
//  21
    { OP_OWS, NULL, 22, 0, },
//  22
    { OP_CHAR, L"|", 13, 23, XML_CHOICE }, // We know this is a CHOICE model
//  23
    { OP_CHAR, L")", 35, XML_E_BADCHARINMODEL, XMLStream::XML_CLOSEPAREN }, 

//  24  ----- Handle a SEQUENCE model
    { OP_OWS, NULL, 25, 0, },
//  25    '(' S? ^ Name | choice | seq ')' ('?'|'*'|'+')?
    { OP_CHAR, L"(", 26, 27, 0 },
//  26    nested model - have to push states.
    { OP_TABLE, (const WCHAR*)g_ContentModelTable, 29, XML_GROUP  },
//  27    '(' Name S? '|' S? ^ Name (S? '|' S? Name)* ')'
    { OP_NAME, NULL, 28, },
//  28    '(' Name S? '|' S? Name ^ (S? '|' S? Name)* ')'
    { OP_TOKEN, NULL, 29, XML_NAME, 0},
//  29    '(' S? Name ^ ('?'|'*'|'+')? S? ')'
    { OP_CHAR, L"?", 32, 30, XML_QUESTIONMARK },
//  30
    { OP_CHAR, L"*", 32, 31, XML_STAR },
//  31
    { OP_CHAR, L"+", 32, 32, XML_PLUS },
//  32
    { OP_OWS, NULL, 33, 0, },
//  33
    { OP_CHAR, L",", 24, 34, XML_SEQUENCE }, // We know this is a SEQUENCE model
//  34
    { OP_CHAR, L")", 35, XML_E_BADCHARINMODEL, XMLStream::XML_CLOSEPAREN }, 

//  --- trailing '?' | '+' | '*' characters after closing ')'
//  35    '(' model ')' ^ ('?'|'*'|'+')? 
    { OP_CHAR, L"?", 38, 36, XML_QUESTIONMARK },
//  36
    { OP_CHAR, L"*", 38, 37, XML_STAR },
//  37
    { OP_CHAR, L"+", 38, 38, XML_PLUS },
//  38
    { OP_POP, NULL, 0, 0, 0  },
};

//==============================================================================
// Parse an a mixed content model (#PCDATA|A|B) or switch to full content model
// if no #PCDATA

const StateEntry g_MixedModelTable[] =
{
// 0   '<!ELEMENT' S Name '(' ^ S? ( '#MIXED' | '(' | Name )
    { OP_OWS, NULL, 1 },
// 1   '<!ELEMENT' S Name '(' S? ^ ( '#MIXED' | '(' | Name )
    { OP_CHAR, L"#", 2, 16, 0 }, 

// ---Ok, it's a mixed model
// 2   '<!ELEMENT' S Name '(' S? '#^PCDATA' 
    { OP_NMTOKEN, NULL, 3, 0, 0 }, 
// 3   '<!ELEMENT' S Name '(' S? '#PCDATA^' 
    { OP_STRCMP, L"#PCDATA", 4, XML_E_INVALID_MODEL, XML_MIXED},
// 4   '(' S? '#MIXED' ^ (( S? '|' S? Name)* S? ')*') | (S? ')')
    { OP_OWS, NULL, 5 },
// 5   '(' S? '#MIXED' (( S? ^ '|' S? Name)* S? ')*') | (S? ^ ')')
    { OP_CHAR, L")", 17, 6, XMLStream::XML_CLOSEPAREN },
// 6   '(' S? '#MIXED' (( S? ^ '|' S? Name)* S? ')*') | (S? ^ ')')
    { OP_CHAR, L"|", 7, XML_E_BADCHARINMIXEDMODEL, XML_CHOICE },

// ---Ok, it has some names too.    (#PCDATA|a|b|c...)
// 7   '(' S? '#MIXED' '|' ^ S? Name
    { OP_OWS, NULL, 8, 0, },
// 8   '(' S? '#MIXED' '|'  S? ^ Name
    { OP_NAME, NULL, 9, 0, },
// 9   '(' S? '#MIXED' '|'  S?  Name ^ 
    { OP_TOKEN, NULL, 10, XML_NAME, 0}, 
// ---(cannot use state 14 because of different terminator ')*'.
// 10   '(' S? '#MIXED' ^ (( S? '|' S? Name)* S? ')*') | (S? ')*')
    { OP_OWS, NULL, 11},
// 11   '(' S? '#MIXED' (( S? ^ '|' S? Name)* S? ')*') | (S? ^ ')*')
    { OP_CHAR, L")", 13, 12, XMLStream::XML_CLOSEPAREN },
// 12   '(' S? '#MIXED' (( S? ^ '|' S? Name)* S? ')*') | (S? ^ ')*')
    { OP_CHAR, L"|", 7, XML_E_BADCHARINMIXEDMODEL, XML_CHOICE },
// 13   '(' S? '#MIXED' ')' ^ '*'
    { OP_CHAR, L"*", 14, XML_E_MISSING_STAR, 0},  
// 14   '(' S? '#MIXED' ')*' ^
    { OP_TOKEN, NULL, 15, XML_STAR, 0}, 
// 15   Ok, we're done !
    { OP_POP, NULL, 0, 0 },

// 16 ---  switch to full blown content model (not #PCDATA)
    { OP_STABLE, (const WCHAR*)g_ContentModelTable, 0 },

// 17   '(' S? '#MIXED' ')' ^ '*'
    { OP_CHAR, L"*", 14, 15, 0},  
};

//==============================================================================
// Parse an <!ELEMENT declaration.
const StateEntry g_ElementDeclTable[] =
{
// 0    '<!ELEMENT' ^ S Name 
    { OP_WS, NULL, 1, 0,  },                    
// 1    '<!ELEMENT' S ^ Name 
    { OP_NAME,  NULL, 2,   },                 
// 2    '<!ELEMENT' S Name ^ 
    { OP_TOKEN,  NULL, 3, XML_ELEMENTDECL, 0  },

// 3    '<!ELEMENT' S Name ^ S contentSpec
    { OP_WS, NULL, 4, 0,   },
// 4    ^ 'EMPTY' | 'ANY' | '(' ... ')'
    { OP_CHAR, L"(", 8, 5, 0 },
// 5    ^ 'EMPTY' | 'ANY'
    { OP_NAME,  NULL, 6,   },                 
// 6    ^ 'EMPTY' | 'ANY'
    { OP_STRCMP,  L"EMPTY", 9, 7, XML_EMPTY },
// 7    ^ 'EMPTY' | 'ANY'
    { OP_STRCMP,  L"ANY", 9, XML_E_INVALID_MODEL, XML_ANY },                 

// 8 return XML_GROUP token and find out if it is a mixed content model or a regular full blown model.
    { OP_TABLE, (const WCHAR*)g_MixedModelTable, 9, XML_GROUP },

// 9   '<!ELEMENT' S Name contentSpec ^ S? >
    { OP_OWS, NULL, 10, 0, },
// 10   '<!ELEMENT' S Name contentSpec  S? ^ >
    { OP_CHAR, L">", 11, XML_E_EXPECTINGTAGEND, 0},
// 11   '<!ELEMENT' S Name contentSpec  S? > ^
    { OP_POP, NULL, 0, XMLStream::XML_ENDDECL, 0  },
  
};

//==============================================================================
// Parse an <!ATTLIST declaration.
const StateEntry g_AttListTable[] =
{
// 0    '<!ATTLIST' ^ S Name 
    { OP_WS, NULL, 1, 0,  },                    
// 1    '<!ATTLIST' S ^ Name 
    { OP_NAME,  NULL, 2,   },                 
// 2    '<!ATTLIST' S Name ^ AttDef* '>'
    { OP_TOKEN,  NULL, 3, XML_ATTLISTDECL, 0  },

// 3    ^ (S Name S AttType S Default) | S? '>'
    { OP_OWS, NULL, 4 },
// 4    ^ (S Name S AttType S Default) | '>'
    { OP_CHAR,  L">", 5, 7, 0  },
// 5    '>' ^
    { OP_POP, NULL, 0, XMLStream::XML_ENDDECL, 0  },

// 6    ^ S Name S AttType S Default
    { OP_WS, NULL, 7, },            // <------- can delete this state...
// 7    S ^ Name S AttType S Default
    { OP_NAME, NULL, 8, },
// 8    S Name ^ S AttType S Default
    { OP_TOKEN,  NULL, 9, XML_ATTDEF, 0  },
// 9    S Name ^ S AttType S Default
    { OP_WS, NULL, 10, },
// 10    S Name S ^ 'CDATA' | 'ID' | ... | '(' enumeration
    { OP_CHAR, L"(", 32, 11, XML_GROUP }, 
// 11   must be a type name.
    { OP_NAME, NULL, 12, },
// 12   must be a type name.
    { OP_STRCMP, L"CDATA", 23, 13, XML_AT_CDATA},
// 13
    { OP_STRCMP, L"ID", 23, 14, XML_AT_ID},
// 14
    { OP_STRCMP, L"IDREF", 23, 15, XML_AT_IDREF},
// 15
    { OP_STRCMP, L"IDREFS", 23, 16, XML_AT_IDREFS},
// 16
    { OP_STRCMP, L"ENTITY", 23, 17, XML_AT_ENTITY},
// 17
    { OP_STRCMP, L"ENTITIES", 23, 18, XML_AT_ENTITIES},
// 18
    { OP_STRCMP, L"NMTOKEN", 23, 19, XML_AT_NMTOKEN},
// 19
    { OP_STRCMP, L"NMTOKENS", 23, 20, XML_AT_NMTOKENS},
// 20
    { OP_STRCMP, L"NOTATION", 21, XML_E_INVALID_TYPE, XML_AT_NOTATION},
// 21    NOTATION ^ S '('
    { OP_WS, NULL, 22, },
// 22    NOTATION S ^ '('
    { OP_CHAR, L"(", 38, XML_E_MISSING_PAREN, XML_GROUP }, 

// 23    AttType ^ S Default
    { OP_WS, NULL, 24, },
// 24    AttType S ^ Default
    { OP_CHAR, L"#", 25, 30, 0 },
// 25    AttType S ^ Default
    { OP_NMTOKEN, NULL, 26, 0, 0},  
// 26
    { OP_STRCMP, L"#REQUIRED", 3, 27, XML_AT_REQUIRED},
// 27
    { OP_STRCMP, L"#IMPLIED", 3, 28, XML_AT_IMPLIED},
// 28
    { OP_STRCMP, L"#FIXED", 29, XML_E_INVALID_PRESENCE, XML_AT_FIXED},
// 29    AttType S ^ S Default
    { OP_WS, NULL, 30, },
// 30    AttType S ^ Default
    { OP_ATTRVAL, NULL, 3, 1, 0},
// 31    ZOMBIE STATE -- CAN BE REMOVED.
    { OP_OWS, NULL, 0, 0, 0},

// 32 -- enumerated type. '(' ^ S? NmToken S '|' S NmToken ... ')'
    { OP_OWS, NULL, 33 },
// 33
    { OP_NMTOKEN, NULL, 34, 1, 0 }, // 1 means do input->Mark
// 34   '(' S? NmToken ^ S '|' S NmToken ... ')'
    { OP_TOKEN, NULL, 35, XML_NMTOKEN },
// 35   '(' S? NmToken ^ ( S '|' S NmToken)? S? ')'
    { OP_OWS, NULL, 36 },
// 36
    { OP_CHAR, L"|", 32, 37, 0 },
// 37
    { OP_CHAR, L")", 23, XML_E_BADCHARINENUMERATION, XMLStream::XML_CLOSEPAREN },

// 38 -- notation type. '(' ^ S? name S '|' S name ... ')'
    { OP_OWS, NULL, 39 },
// 39
    { OP_NAME, NULL, 40,  }, 
// 40   '(' S? name ^ S '|' S name ... ')'
    { OP_TOKEN, NULL, 41, XML_NAME },
// 41   '(' S? name ^ ( S '|' S name)? S? ')'
    { OP_OWS, NULL, 42 },
// 42
    { OP_CHAR, L"|", 38, 43, 0 },
// 43
    { OP_CHAR, L")", 23, XML_E_BADCHARINENUMERATION, XMLStream::XML_CLOSEPAREN },

};

//==============================================================================
// Parse an <!^xxxxxxxx Declaration.
const StateEntry g_DeclarationTable[] =
{
// 0    '<' ^ '!' 
    { OP_CHAR, L"!", 1, XML_E_INTERNALERROR,  },                    
// 1    '<!' ^ '-'
    { OP_PEEK, L"-", 2, 4, 0 },                    
// 2    '<!-'
    { OP_COMMENT,  NULL, 3,   },                 
// 3    done !!
    { OP_POP,  NULL, 0, 0 },

// 4    '<!' ^ '['
    { OP_PEEK, L"[", 5, 6, 0 },                    
// 5    '<![...'
    { OP_CONDSECT,  NULL, 3,   },                 

// 6    '<!' ^ Name
    { OP_NAME, NULL, 7 },

// 7    '<!' Name ^ S
    { OP_STRCMP,  L"DOCTYPE", 8, 9, 0 },
// 8    '<!' DOCTYPE ^ S
    { OP_STABLE, (const WCHAR*)g_DocTypeTable, 0 },

// 9    '<!' Name ^ S
    { OP_STRCMP,  L"ELEMENT", 10, 11, 0 },
// 10    '<!' ELEMENT ^ S
    { OP_STABLE, (const WCHAR*)g_ElementDeclTable, 0 },

// 11    '<!' Name ^ S
    { OP_STRCMP,  L"ENTITY", 12, 13, 0 },
// 12    '<!' ELEMENT ^ S
    { OP_STABLE, (const WCHAR*)g_EntityDeclTable, 0 },

// 13    '<!' Name ^ S
    { OP_STRCMP,  L"ATTLIST", 14, 15, 0 },
// 14    '<!' ELEMENT ^ S
    { OP_STABLE, (const WCHAR*)g_AttListTable, 0 },

// 15    '<!' Name ^ S
    { OP_STRCMP,  L"NOTATION", 16, XML_E_BADDECLNAME, 0 },
// 16    '<!' ELEMENT ^ S
    { OP_STABLE, (const WCHAR*)g_NotationDeclTable, 0 },

};


//==============================================================================
// Parse an <?xml or <?xml:namespace declaration.
const StateEntry g_XMLDeclarationTable[] =
{
// 0    must be xml declaration - and not xml namespace declaration        
    { OP_TOKEN, NULL, 1, XML_XMLDECL, 0 },
// 1    '<?xml' ^ S version="1.0" ...
    { OP_OWS, NULL, 2 },
// 2    '<?xml' S ^ version="1.0" ...
    { OP_SNCHAR, NULL, 3, XML_E_XMLDECLSYNTAX },
// 3    '<?xml' S ^ version="1.0" ...
    { OP_NAME, NULL, 4, },
// 4    '<?xml' S version^="1.0" ...
    { OP_STRCMP, L"version", 5, 12, XML_VERSION },
// 5
    { OP_EQUALS, NULL, 6 },
// 6    '<?xml' S version = ^ "1.0" ...
    { OP_ATTRVAL, NULL, 32, 0},
// 7    '<?xml' S version '=' value ^ 
    { OP_TOKEN, NULL, 8, XML_PCDATA, -1 },
// 8    ^ are we done ?
    { OP_CHARWS, L"?", 28, 9 },    // must be '?' or whitespace.
// 9    ^ S? [encoding|standalone] '?>'
    { OP_OWS, NULL, 10 },
// 10
    { OP_CHAR, L"?", 28, 33 },    // may have '?' after skipping whitespace.
// 11    ^ [encoding|standalone] '?>'
    { OP_NAME, NULL, 12, },
// 12
    { OP_STRCMP, L"standalone", 23, 13, XML_STANDALONE },
// 13
    { OP_STRCMP, L"encoding", 14, XML_E_UNEXPECTED_ATTRIBUTE, XML_ENCODING },
// 14
    { OP_EQUALS, NULL, 15 },
// 15   
    { OP_ATTRVAL, NULL, 16, 0 },
// 16
    { OP_ENCODING, NULL, 17, 0, -1 },
// 17
    { OP_TOKEN, NULL, 18, XML_PCDATA, -1 },

// 18    ^ are we done ?
    { OP_CHARWS, L"?", 28, 19 },    // must be '?' or whitespace.
// 19    ^ S? standalone '?>'
    { OP_OWS, NULL, 20 },
// 20
    { OP_CHAR, L"?", 28, 34 },    // may have '?' after skipping whitespace.
// 21    ^ standalone '?>'
    { OP_NAME, NULL, 22, },
// 22 
    { OP_STRCMP, L"standalone", 23, XML_E_UNEXPECTED_ATTRIBUTE, XML_STANDALONE },
// 23
    { OP_EQUALS, NULL, 24 },
// 24
    { OP_ATTRVAL, NULL, 25, 0 },
// 25   
    { OP_STRCMP, L"yes", 31, 30, -1  },

// 26    <?xml ....... ^ '?>'   -- now expecting just the closing '?>' chars
    { OP_OWS, NULL, 27 },
// 27    
    { OP_CHAR, L"?", 28, XML_E_XMLDECLSYNTAX, 0 },
// 28   
    { OP_CHAR, L">", 29, XML_E_XMLDECLSYNTAX, 0 },
// 29    done !!
    { OP_POP,  NULL, 0, XMLStream::XML_ENDXMLDECL },

//----------------------- check standalone values  "yes" or "no"
// 30
    { OP_STRCMP, L"no", 31, XML_E_INVALID_STANDALONE, -1  },
// 31
    { OP_TOKEN, NULL, 26, XML_PCDATA, -1 },
    
//----------------------- check version = "1.0"
// 32
    { OP_STRCMP, L"1.0", 7, XML_E_INVALID_VERSION, -1 },
// 33 
    { OP_SNCHAR, NULL, 11, XML_E_XMLDECLSYNTAX },   
// 34 
    { OP_SNCHAR, NULL, 21, XML_E_XMLDECLSYNTAX },  
};

#define DELAYMARK(hr) (hr == S_OK || (hr >= XML_E_TOKEN_ERROR && hr < XML_E_LASTERROR))

#define XML_E_FOUNDPEREF 0x8000e5ff

//==============================================================================
static const WCHAR* g_pstrCDATA = L"CDATA";

XMLStream::XMLStream(XMLParser * pXMLParser)
:   _pStack(1), _pStreams(1)
{   
    // precondition: 'func' is never NULL
    _fnState = &XMLStream::init;
    _pInput = NULL;
    _pchBuffer = NULL;
    _fDTD = false;
    _fInternalSubset = false;
    _cStreamDepth = 0;
    _pXMLParser = pXMLParser;

    _init();
    SetFlags(0);
}

HRESULT 
XMLStream::init()
{
    HRESULT hr = S_OK;

    if (_pInput == NULL) 
    {
        // haven't called put_stream yet.
        return XML_E_ENDOFINPUT;
    }

    _init();

    if (_fDTD)
    {
        _fnState = &XMLStream::parseDTDContent;
    }
    else
    {
        _fnState =  &XMLStream::parseContent;
    }
    checkhr2(push(&XMLStream::firstAdvance,0));

    return hr;
}

void
XMLStream::_init()
{
    _fEOF = false;
    _fEOPE = false;
    _chLookahead = 0;
    _nToken = XML_PENDING;
    _chTerminator = 0;
    _lLengthDelta = 0;
    _lNslen = _lNssep = 0;
    _sSubState = 0;
    _lMarkDelta = 0;
    _nAttrType = XMLTYPE_CDATA;
    _fUsingBuffer = false;
    _lBufLen = 0;
    delete[] _pchBuffer;
    _pchBuffer = NULL;
    _lBufSize = 0;
    _fDelayMark = false;
    _fFoundWhitespace = false;
    _fFoundNonWhitespace = false;
    _fFoundPEREf = false;
    _fWasUsingBuffer = false;
    _chNextLookahead = 0;
    _lParseStringLevel = 0;
    _cConditionalSection = 0;
    _cIgnoreSectLevel = 0;
    _fWasDTD = false;
    _fParsingAttDef = false;
    _fFoundFirstElement = false;
    _fReturnAttributeValue = true;
    _fHandlePE = true;

    _pTable = NULL;
    _lEOFError = 0;
}

XMLStream::~XMLStream()
{
    delete _pInput;
    delete[] _pchBuffer;

    InputInfo* pi = _pStreams.peek();
    while (pi != NULL)
    {
        // Previous stream is finished also, so
        // pop it and continue on.
        delete pi->_pInput;
        pi = _pStreams.pop();
    }
}

HRESULT  
XMLStream::AppendData( 
    /* [in] */ const BYTE  *buffer,
    /* [in] */ long  length,
    /* [in] */ BOOL  last)
{
    if (_pInput == NULL)
    {
        _pInput = new_ne BufferedStream(this);
        if (_pInput == NULL)
            return E_OUTOFMEMORY;
        init();
    }

    HRESULT hr = _pInput->AppendData(buffer, length, last);

    return hr;
}

HRESULT  
XMLStream::Reset( void)
{
    init();
    delete _pInput;
    _pInput = NULL;
    return S_OK;
}

HRESULT  
XMLStream::PushStream( 
        /* [unique][in] */ EncodingStream  *p,
        /* [in] */ bool fExternalPE)
{
    HRESULT hr;
    if (_pStreams.used() == 0 && _pInput == NULL)
        init();

    _cStreamDepth++;

    _fEOPE = false;

    if (_fDelayMark && _pInput != NULL)
    {
        mark(_lMarkDelta);
        _lMarkDelta = 0;
        _fDelayMark = false;
    }

    // Save current input stream.
    if (_pInput != NULL)
    {
        InputInfo* pi = _pStreams.push();
        if (pi == NULL)
            return E_OUTOFMEMORY;
 
        pi->_pInput = _pInput;
        pi->_chLookahead = _chLookahead;
        pi->_fPE = true; // assume this is a parameter entity.
        pi->_fExternalPE = fExternalPE;
        pi->_fInternalSubset = _fInternalSubset;
        if (&XMLStream::skipWhiteSpace == _fnState  && _pStack.used() > 0)
        {
            StateInfo* pSI = _pStack.peek();
            pi->_fnState = pSI->_fnState;
        }
        else
        {
            pi->_fnState = _fnState;
        }

        if (fExternalPE)
        {
            // now we are not in the internal subset any more because we're
            // processing an external external Parameter Entity.
            _fInternalSubset = false; 
        }
        // and prepend pe text with space as per xml spec.
        _chLookahead = L' ';
        _chNextLookahead = _chLookahead;
        _pInput = NULL;
    }

    _pInput = new_ne BufferedStream(this);
    if (_pInput == NULL)
        return E_OUTOFMEMORY;

    if (p != NULL)
    {
        _pInput->Load(p);
    }
    if (_chLookahead == L' ')
        _pInput->setWhiteSpace(); // _pInput didn't see this space char.
    return S_OK;
}

HRESULT
XMLStream::InsertData(
    /* [in] */ const WCHAR *buffer,
    /* [in] */ long length,
    /* [in] */ bool pedata)
{
    HRESULT hr = S_OK;
#if 0 // EncodingStream
    checkhr2(PushStream(NULL, false));
    InputInfo* pi = _pStreams.peek();
    pi->_fPE = pedata; // record whether this is a parameter entity or not !

    checkhr2(_pInput->AppendData((const BYTE*)s_ByteOrderMark, sizeof(s_ByteOrderMark), FALSE));
    checkhr2(_pInput->AppendData((const BYTE*)buffer, length*sizeof(WCHAR), TRUE));

    if (! pedata && _fDTD)
    {
        // soak up initial whitespace that PushStream put there - 
        // since this is not a parameter entity.
        hr = DTDAdvance();
    }
#endif // FA EncodingStream
    return hr;
}

HRESULT 
XMLStream::PopStream()
{
    // This method has to pop all streams until it finds a stream that
    // can deliver the next _chLookahead character.

    HRESULT hr = S_OK;

    InputInfo* pi = NULL;

    pi = _pStreams.peek();
    if (pi == NULL) return S_FALSE;

    if (pi->_fPE)
    {
        // Check the proper Declaration/PE Nesting constraint
        // See XML spec section 2.8, [29]
        StateInfo* pSI = _pStack.peek();
        if ((pi->_fnState == &XMLStream::parseDTDContent || 
             pSI->_fnState == &XMLStream::parseDTDContent)
            && (pSI->_fnState != pi->_fnState))
        {
            hr = XML_E_PE_NESTING;
        }

        // get next char from previous stream.
        _chNextLookahead = pi->_chLookahead;
    
        _chLookahead = L' '; // append parameter entity text with space as per XML spec.
    }
    else
    {
        _chLookahead = pi->_chLookahead;
    }

    // Found previous stream, so we can continue.
    _fEOF = false;

    // Ok, so we actually got the next character, so
    // we can now safely throw away the previous 
    // lookahead character and return the next
    // non-whitespace character from the previous stream.
    delete _pInput;

    _pInput = pi->_pInput;
    if (_chLookahead == L' ')
        _pInput->setWhiteSpace();

    // BUGBUG: we need to clear this so that the parser does not
    // try and pop a download in the internalPE case (when handling XML_E_ENDOFINPUT in run())
    // but this means that internal PEs never get XMLNF_ENDENTITY notifications generated.
    // The DTDNodeFactory requires this behaviour currently (incorrectly)
    _fEOPE = pi->_fExternalPE;
    if (pi->_fExternalPE)
    {
        // Restore _fInternalSubset to the saved value since we've finished
        // with the external parameter entity now.
        _fInternalSubset = pi->_fInternalSubset;
    }

    _pStreams.pop();

    _cStreamDepth--;

    return hr;
}

HRESULT
XMLStream::ContinueDTDAdvance()
{
    HRESULT hr = S_OK;
    checkhr2(pop());
    return DTDAdvance();
}

HRESULT 
XMLStream::DTDAdvance()
{
    // The DTD Advance is a little tricker because we have to take
    // parameter entities into account.
    HRESULT hr = S_OK;

    if (_fEOPE)
    {
        hr = PopStream();
        if (FAILED(hr))
            return hr;

        if (_fEOPE)
        {
            _fEOPE = false;
            // Must return end of input to tell the XMLParser to pop the
            // download, and then pick up in the current state and continue on.
            checkhr2(push(&XMLStream::ContinueDTDAdvance, _sSubState));
            return XML_E_ENDOFINPUT;
        }
    }

    if (_chNextLookahead != 0)
    {
        _chLookahead = _chNextLookahead;
        _pInput->setWhiteSpace(::isWhiteSpace(_chLookahead) != 0); // tell it we are on a whitespace.
        _chNextLookahead = 0;
    }
    else
    {
        hr = _pInput->nextChar(&_chLookahead, &_fEOF);
        if (_fEOF && _pStreams.used() > 0) 
        {
            InputInfo* pi = _pStreams.peek();
            if (pi->_fPE)
            {
                // So we reached the end of a parameter entity, but instead of popping
                // the stream immediately, we return the trailing space that we're 
                // required to return, and then the next advance will pop the stream.
                _chLookahead = L' ';
                _pInput->setWhiteSpace(); // tell it we are on a whitespace.                _fEOPE = true;
                _fEOPE = true;
            }
            else
            {
                // Pop it immediately then, since this is not a parameter entity,
                // and PopStream will set the _chLookahead character accordingly.
                PopStream();
            }
            _fEOF = false;
        }
    }

    if (_chLookahead == L'%' && _fHandlePE && _fnState != &XMLStream::parsePERef)
    {
        if (_fInternalSubset)
        {
            // Parameter entities are not allowed INSIDE a 
            // declaration when we are parsing the internal subset.
            if (_fnState != &XMLStream::parseDTDContent)
            {
                if (_fnState == &XMLStream::skipWhiteSpace && _pStack.used() > 0)
                {
                    StateInfo* pSI = _pStack.peek();
                    if (pSI->_fnState != &XMLStream::parseDTDContent)
                    {
                        hr = XML_E_BADPEREFINSUBSET;
                    }
                }
                else
                {
                    hr = XML_E_BADPEREFINSUBSET;
                }
            }
        }
        if (S_OK == hr)
        {
            _fFoundPEREf = true;
            _chLookahead = L' '; // return space to end previous token.
            _pInput->setWhiteSpace(); // tell it we are on a whitespace.                
            if (_fUsingBuffer)
            {    
                return XML_E_FOUNDPEREF; // must break out of while loops !!
            }
        }
    }

    return hr;
}


HRESULT  
XMLStream::GetNextToken( 
        /* [out] */ DWORD  *t,
        /* [out] */ const WCHAR  **text,
        /* [out] */ long  *length,
        /* [out] */ long  *nslen)
{
    HRESULT hr;

    if (_fDTD)
        return GetNextTokenInDTD(t,text,length,nslen);

    if (_fDelayMark)
    {
        mark(_lMarkDelta);
        _lMarkDelta = 0;
        _fDelayMark = false;
    }

    hr = (this->*_fnState)();
    while (hr == S_OK && _nToken == XML_PENDING)
    {
        hr = (this->*_fnState)();
    }

    if (hr == S_OK)
    {
        *t = _nToken;
    }
    else if (hr == E_PENDING)
    {
        *t = XML_PENDING;
        *length = *nslen = 0;
        *text = NULL;
        goto CleanUp;
    }
    else
    {
        *t = XML_PENDING;
    }

    // At this point hr == S_OK or it is some error.  So we
    // want to return the text of the current token, since this
    // is useful in both cases.

    if (! _fUsingBuffer)
    {
        getToken(text,length);
        if (_lLengthDelta != 0)
        {
            *length += _lLengthDelta;
            _lLengthDelta = 0;
        }
// This can only happen in the context of a DTD.
//        if (_fWasUsingBuffer)
//        {
//            _fUsingBuffer = _fWasUsingBuffer;
//            _fWasUsingBuffer = false;
//        }
    }
    else
    {
        *text = _pchBuffer;
        *length = _lBufLen;
        _fUsingBuffer = false;
        _fFoundWhitespace = false;
        _lBufLen = 0;
        _lLengthDelta = 0;
    }
    
    if (DELAYMARK(hr))
    {
        // Mark next time around so that error information points to the
        // beginning of this token.
        _fDelayMark = true;
    }
    else 
    {
        // otherwise mark this spot right away so we point to the exact
        // source of the error.
        mark(_lMarkDelta);
        _lMarkDelta = 0;
    }

    _nToken = XML_PENDING;
    *nslen = _lNslen;
    _lNslen = _lNssep = 0;

CleanUp:
    return hr;
}

HRESULT  
XMLStream::GetNextTokenInDTD( 
        /* [out] */ DWORD  *t,
        /* [out] */ const WCHAR  **text,
        /* [out] */ long  *length,
        /* [out] */ long  *nslen)
{
    HRESULT hr;

prepare:

    if (_fDelayMark)
    {
        mark(_lMarkDelta);
        _lMarkDelta = 0;
        _fDelayMark = false;
    }
    if (_fFoundPEREf)
    {
        goto peref;
    }

start:

    hr = (this->*_fnState)();
    while (hr == S_OK && _nToken == XML_PENDING && ! _fFoundPEREf)
    {
        hr = (this->*_fnState)();
    }

    if (hr == S_OK)
    {
        if (_nToken == XML_PENDING)
        {
            if (_fFoundPEREf)
            {
peref:
                // This was just a trick to pop us back up to this level and
                // break out of parseString or parseComment loops.  Now
                // we can continue on and parse the peref.
                ADVANCE; // past the '%' character.
                checkhr2(push(&XMLStream::parsePERef,_sSubState));
                // being careful not to mess up the current buffer if one
                // is being used.
                _fWasUsingBuffer = _fUsingBuffer;
                _fUsingBuffer = false;
                _fFoundPEREf = false;
                goto start;
            }
        }
        *t = _nToken;
    }
    else if (hr == E_PENDING || 
            hr == XML_E_ENDOFINPUT)  // for parameter entities, etc.
    {
        *t = XML_PENDING;
        *length = *nslen = 0;
        *text = NULL;
        goto CleanUp;
    }
    else if (hr == XML_E_FOUNDPEREF)
    {
        goto peref;
    }
    else
    {
        *t = XML_PENDING;
    }

    if (! _fUsingBuffer)
    {
        getToken(text,length);
        *length += _lLengthDelta;
        if (_fWasUsingBuffer)
        {
            _fUsingBuffer = _fWasUsingBuffer;
            _fWasUsingBuffer = false;
        }
        _lLengthDelta = 0;
    }
    else
    {
        *text = _pchBuffer;
        *length = _lBufLen;
        _fUsingBuffer = false;
        _fFoundWhitespace = false;
        _lBufLen = 0;
        _lLengthDelta = 0;
    }

    if (hr != 0 && hr != E_PENDING && _fInternalSubset && _chLookahead == L'%')
    {
        hr = XML_E_BADPEREFINSUBSET;
    }

    if (DELAYMARK(hr))
    {
        // Mark next time around so that error information points to the
        // beginning of this token.
        _fDelayMark = true;
    }
    else 
    {
        // otherwise mark this spot right away so we point to the exact
        // source of the error.
        mark(_lMarkDelta);
        _lMarkDelta = 0;
    }
    _nToken = XML_PENDING;
    *nslen = _lNslen;
    _lNslen = _lNssep = 0;

    // In IE4 mode we do not return DTD tokens at all except for the
    // one big XML_DTDSUBSET token for the entire subset.
    if (_fNoDTDNodes && _fDTD && hr == S_OK)
    {
        goto prepare;
    }

CleanUp:
    return hr;
}

ULONG  
XMLStream::GetLine()    
{
    BufferedStream* input = getCurrentStream();
    if (input != NULL)
        return input->getLine();
    return 0;
}

ULONG  
XMLStream::GetLinePosition( )
{
    BufferedStream* input = getCurrentStream();
    if (input != NULL)
        return input->getLinePos();
    return 0;
}

ULONG  
XMLStream::GetInputPosition( )
{
    BufferedStream* input = getCurrentStream();
    if (input != NULL)
        return input->getInputPos();
    return 0;
}

HRESULT  
XMLStream::GetLineBuffer( 
    /* [out] */ const WCHAR  * *buf, ULONG* len, ULONG* startpos)
{
    if (buf == NULL || len == NULL)
        return E_INVALIDARG;

    *buf = NULL;
    BufferedStream* input = getCurrentStream();
    if (input)
        *buf = input->getLineBuf(len, startpos);
    return S_OK;
}

BufferedStream* 
XMLStream::getCurrentStream()
{
    // Return the most recent stream that
    // actually has somthing to return.
    BufferedStream* input = _pInput;
    if (!_pInput)
    {
        return NULL;
    }
    int i = _pStreams.used()-1;    
    do 
    {
        ULONG len = 0, pos = 0;
        const WCHAR* buf = input->getLineBuf(&len, &pos);
        if (len > 0)
            return input;

        if (i >= 0)
            input = _pStreams[i--]->_pInput;
        else
            break;
    }
    while (input != NULL);
    return NULL;
}

void 
XMLStream::SetFlags( unsigned short usFlags)
{
    _usFlags = usFlags;
    // And break out the flags for performance reasons.
    _fFloatingAmp = (usFlags & XMLFLAG_FLOATINGAMP) != 0;
    _fShortEndTags = (usFlags & XMLFLAG_SHORTENDTAGS) != 0;
    _fCaseInsensitive = (usFlags & XMLFLAG_CASEINSENSITIVE) != 0;
    _fNoNamespaces = (usFlags & XMLFLAG_NONAMESPACES) != 0;
    _fNoWhitespaceNodes = false; // this is now bogus.  (usFlags & XMLFLAG_NOWHITESPACE) != 0;
    _fIE4Quirks = (_usFlags & XMLFLAG_IE4QUIRKS) != 0;
    _fNoDTDNodes = (_usFlags & XMLFLAG_NODTDNODES) != 0;
}

unsigned short 
XMLStream::GetFlags()
{
    return _usFlags;
}

void XMLStream::SetType(DWORD type)
{
    static short s_TypeMap[11] = { 
            XMLTYPE_CDATA,      // XML_AT_CDATA
            XMLTYPE_NAME,       // XML_AT_ID
            XMLTYPE_NAME,       // XML_AT_IDREF
            XMLTYPE_NAMES,      // XML_AT_IDREFS
            XMLTYPE_NAME,       // XML_AT_ENTITY
            XMLTYPE_NAMES,      // XML_AT_ENTITIES
            XMLTYPE_NMTOKEN,    // XML_AT_NMTOKEN
            XMLTYPE_NMTOKENS,   // XML_AT_NMTOKENS
            XMLTYPE_NMTOKEN,    // XML_AT_NOTATION
    };
    _nAttrType = s_TypeMap[type - XML_AT_CDATA];
}

WCHAR*  
XMLStream::GetEncoding()
{
#if 0
    if (_pInput == NULL)
        return NULL;
    else
        return _pInput->getEncoding();
#endif
    return NULL;
}


//======================================================================
// Real Implementation
HRESULT 
XMLStream::firstAdvance()
{
    HRESULT hr;
    ADVANCE;
    checkhr2(pop(false));
    return S_OK;
}


HRESULT 
XMLStream::parseContent()
{
    HRESULT hr = S_OK;

    if (_fEOF)
        return XML_E_ENDOFINPUT;

    switch (_chLookahead)
    {
    case L'<':
        ADVANCE;
        checkeof(_chLookahead, XML_E_UNCLOSEDDECL);
        switch (_chLookahead)
        {
        case L'!':
            checkhr2(_pInput->Freeze()); // stop shifting data until '>'
            return pushTable( 0, g_DeclarationTable, XML_E_UNCLOSEDDECL);
        case L'?':
            checkhr2(push( &XMLStream::parsePI ));
            return parsePI();
        case L'/':
            checkhr2(push(&XMLStream::parseEndTag));
            return parseEndTag();
        default:
            checkhr2(push( &XMLStream::parseElement ));
            if (_fFoundFirstElement)
            {
                return parseElement();
            }
            else
            {
                // Return special end prolog token and then continue with 
                // with parseElement.
                _fFoundFirstElement = true;
                _nToken = XML_ENDPROLOG;
            }
        }
        break;

    default:
        checkhr2(push(&XMLStream::parsePCData));
        return parsePCData();
        break;
    }
    return S_OK;
}

HRESULT 
XMLStream::skipWhiteSpace()
{
    HRESULT hr = S_OK;

    while (ISWHITESPACE(_chLookahead) && ! _fEOF)
    {
        ADVANCE;
        if (_fFoundPEREf) return S_OK;
    }
    checkhr2(pop(false));
    return hr;
}

HRESULT 
XMLStream::parseElement()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        checkhr2(_pInput->Freeze()); // stop shifting data until '>'
        checkhr2(push( &XMLStream::parseName, 1));
        checkhr2(parseName());
        _sSubState = 1;
        // fall through
    case 1:
        checkeof(_chLookahead, XML_E_UNCLOSEDSTARTTAG);
        _nToken = XML_ELEMENT;
        // and then try and parse the attributes, and return
        // to state 2 to finish up.  With an optimization
        // for the case where there are no attributes.
        if (_chLookahead == L'/' || _chLookahead == L'>')
        {
            _sSubState = 2;
        }
        else if (_fIE4Quirks && _chLookahead == L'=')
        {
            _sSubState = 4; // weird compatibility case.
        }
        else 
        {
            if (!ISWHITESPACE(_chLookahead))
            {
                return XML_E_BADNAMECHAR;
            }
            _chEndChar = L'/'; // for empty tags.
            checkhr2(push(&XMLStream::parseAttributes,2));
        }
        return S_OK;
        break;

    case 2: // finish up with start tag.
        mark(); // only return '>' or '/>' in _nToken text
        if (_chLookahead == L'/')
        {
            // must be empty tag sequence '/>'.
            ADVANCE;
            _nToken = XML_EMPTYTAGEND;
        } 
        else if (_chLookahead == L'>')
        {
            _nToken = XML_TAGEND;
        }
        else if (ISWHITESPACE(_chLookahead))
        {
            return XML_E_UNEXPECTED_WHITESPACE;
        }
        else
            return XML_E_EXPECTINGTAGEND;

        _sSubState = 3;
        // fall through
    case 3:
        checkeof(_chLookahead, XML_E_UNCLOSEDSTARTTAG);
        if (_chLookahead != L'>')
        {
            if (ISWHITESPACE(_chLookahead))
                return XML_E_UNEXPECTED_WHITESPACE;
            else 
                return XML_E_EXPECTINGTAGEND;
        }
        ADVANCE; 
        mark();
        checkhr2(pop());// return to parseContent.
        return _pInput->UnFreeze(); 
        break;

    case 4: // swollow up bad tag
        // Allow the weird CDF madness <PRECACHE="YES"/>
        // For total compatibility we fake out the parser by returning
        // XML_EMPTYTAGEND, this way the rest of the tag becomes PCDATA.
        // YUK -- but it works.
        _nToken = XML_EMPTYTAGEND;
        mark();
        checkhr2(pop());// return to parseContent.
        return _pInput->UnFreeze(); 
        break;

    default:
        INTERNALERROR;
    }
    return S_OK;
}

HRESULT 
XMLStream::parseEndTag()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        ADVANCE; // soak up the '/'
        mark(); 
        // SHORT END TAG SUPPORT, IE4 Compatibility Mode only.
        if (! _fShortEndTags || _chLookahead != L'>') 
        {
            checkhr2(push( &XMLStream::parseName, 1));
            checkhr2(parseName());
        }
        _sSubState = 1;
        // fall through
        
    case 1: // finish parsing end tag
        checkeof(_chLookahead, XML_E_UNCLOSEDENDTAG);
        _nToken = XML_ENDTAG;
        checkhr2(push(&XMLStream::skipWhiteSpace, 2));
        return S_OK;

    case 2:
        checkeof(_chLookahead, XML_E_UNCLOSEDENDTAG);
        if (_chLookahead != L'>')
        {
            return XML_E_BADNAMECHAR;
        }
        ADVANCE;
        mark();
        checkhr2(pop());// return to parseContent.
        break;

    default:
        INTERNALERROR;
    }
    return S_OK;
}

HRESULT 
XMLStream::parsePI()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        _fWasDTD = _fDTD; // as far as Advance is concerned, the contents
        _fHandlePE = false;    // of a PI are not special.
        ADVANCE;
        checkhr2(_pInput->Freeze()); // stop shifting data until '?>'
        mark(); // don't include '?' in tag name.
        if (_chLookahead == L'x' || _chLookahead == L'X')
        {
            // perhaps this is the magic <?xml version="1.0"?> declaration.
            STATE(7);  // jump to state 7.
        }
        // fall through
        _sSubState = 1;
    case 1:
        checkhr2(push( &XMLStream::parseName, 2));
        checkhr2(parseName()); 
        _sSubState = 2;
        // fall through
    case 2:
        checkeof(_chLookahead, XML_E_UNCLOSEDPI);
        if (_chLookahead != L'?' && ! ISWHITESPACE(_chLookahead))
        { 
            return XML_E_BADNAMECHAR;
        }
        _nToken = XML_PI;
        STATE(3);   // found startpi _nToken and return to _sSubState 3
        break;

    case 3: // finish with rest of PI
        if (_chLookahead == L'?')
        {
            ADVANCE;
            if (_chLookahead == L'>')
            {
                STATE(6);
            }
            else
            {
                return XML_E_EXPECTINGTAGEND;
            }
        }

        checkhr2(push(&XMLStream::skipWhiteSpace, 4));
        checkhr2( skipWhiteSpace() );
        _sSubState = 4;
        // fall through

    case 4: // support for normalized whitespace
        mark(); // strip whitespace from beginning of PI data, since this is
                // just the separator between the PI target name and the PI data.
        _sSubState = 5;
        // fallthrough

    case 5:
        while (! _fEOF )
        {
            if (_chLookahead == L'?')
            {
                ADVANCE;
                break;
            }
            if (! isCharData(_chLookahead))
                return XML_E_PIDECLSYNTAX;
            ADVANCE;
        }
        _sSubState = 6; // go to next state
        // fall through.
    case 6:
        checkeof(_chLookahead, XML_E_UNCLOSEDPI);
        if (_chLookahead == L'>')
        {
            ADVANCE;
            _lLengthDelta = -2; // don't include '?>' in PI CDATA.
        }
        else
        {
            // Hmmm.  Must be  a lone '?' so go back to state 5.
            STATE(5);
        }
        _nToken = XML_ENDPI;
        _fHandlePE = true;
        checkhr2(pop());
        return _pInput->UnFreeze();
        break;      

    case 7: // recognize 'm' in '<?xml' declaration
        ADVANCE;
        if (_chLookahead != L'm' && _chLookahead != L'M')
        {
            STATE(11); // not 'xml' so jump to state 11 to parse name
        }
        _sSubState = 8;
        // fall through                

    case 8: // recognize L'l' in '<?xml' declaration
        ADVANCE;
        if (_chLookahead != L'l' && _chLookahead != L'L')
        {
            STATE(11); // not 'xml' so jump to state 11 to parse name
        }
        _sSubState = 9;
        // fall through                

    case 9: // now need whitespace or ':' or '?' to terminate name.
        ADVANCE;
        if (ISWHITESPACE(_chLookahead))
        {
            if (! _fCaseInsensitive)
            {
                const WCHAR* t;
                long len;
                getToken(&t,&len);
                if (! StringEquals(L"xml",t,3,false)) // case sensitive
                    return XML_E_BADXMLCASE;
            }
            return pushTable(10, g_XMLDeclarationTable, XML_E_UNCLOSEDPI);
        }
        if (isNameChar(_chLookahead) || _chLookahead == ':')  
        {
            STATE(11); // Hmmm.  Must be something else then so continue parsing name
        }
        else
        {
            return XML_E_XMLDECLSYNTAX;
        }
        break;

    case 10:
        _fHandlePE = true;
        checkhr2(pop());
        return _pInput->UnFreeze();
        break;

    case 11:
        if (_chLookahead == ':')
            ADVANCE;
        _sSubState = 12;
        // fall through
    case 12:
        if (isNameChar(_chLookahead))
        {
            checkhr2(push( &XMLStream::parseName, 2));
            _sSubState = 1; // but skip IsStartNameChar test
            checkhr2(parseName());
            return S_OK;
        } 
        else
        {
            STATE(2);
        }
        break;

    default:
        INTERNALERROR;
    }

    return S_OK;
}

HRESULT 
XMLStream::parseComment()
{
    // ok, so '<!-' has been parsed so far
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        _fWasDTD = _fDTD; // as far as the DTD is concerned, the contents
        _fHandlePE = false;    // of a COMMENT are not special.
        ADVANCE; // soak up first '-'
        checkeof(_chLookahead, XML_E_UNCLOSEDCOMMENT);
        if (_chLookahead != L'-')
        {
            return XML_E_COMMENTSYNTAX;
        }
        _sSubState = 1;
        // fall through
    case 1:
        ADVANCE; // soak up second '-'
        mark(); // don't include '<!--' in comment text
        _sSubState = 2;
        // fall through;
    case 2:
        while (! _fEOF)
        {
            if (_chLookahead == L'-')
            {
                ADVANCE; // soak up first closing L'-'                
                break;
            }
            if (! isCharData(_chLookahead))
                return XML_E_BADCHARDATA;
            ADVANCE;
        }
        checkeof(_chLookahead, XML_E_UNCLOSEDCOMMENT);
        _sSubState = 3; // advance to next state        
        // fall through.
    case 3:
        if (_chLookahead != L'-')
        {
            // Hmmm, must have been a floating L'-' so go back to state 2
            STATE(2);
        }
        ADVANCE; // soak up second closing L'-'
        _sSubState = 4; 
        // fall through
    case 4:
        checkeof(_chLookahead, XML_E_UNCLOSEDCOMMENT);
        if (_chLookahead != L'>' && ! _fIE4Quirks)
        {
            // cannot have floating L'--' unless we are in compatibility mode.
            return XML_E_COMMENTSYNTAX;
        }
        ADVANCE; // soak up closing L'>'
        _lLengthDelta = -3; // don't include L'-->' in PI CDATA.
        _nToken = XML_COMMENT;
        checkhr2(pop());
        _fHandlePE = true;
        break;

    default:
        INTERNALERROR;
    }    
    return S_OK;
}


HRESULT 
XMLStream::parseName()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        if (! isStartNameChar(_chLookahead))
        {
            if (ISWHITESPACE(_chLookahead))
                hr = XML_E_UNEXPECTED_WHITESPACE;
            else
                hr = XML_E_BADSTARTNAMECHAR;
            goto CleanUp;
        }
        mark(); 
        _sSubState = 1;
        // fall through

    case 1:
        _lNslen = _lNssep = 0;
        if (_fNoNamespaces)
        {
            goto simple;            
        }
        // When handling namespaces, L':' is not allowed as a start name character
        if (_chLookahead == L':')
        {
            hr = XML_E_BADSTARTNAMECHAR;
            goto CleanUp;
        }
        ADVANCE;
        _sSubState = 2;
        // fall through

    case 2:
loop:
        while (_chLookahead != L':' && isNameChar(_chLookahead) && !_fEOF)
        {
            ADVANCE;
        }
        if (_chLookahead == L':')
        {
            if (_lNssep == 0)
            {
                _lNslen = _pInput->getTokenLength();
                _lNssep++;
            }
            else
            {
                hr = XML_E_MULTIPLE_COLONS;
                goto CleanUp;
            }
            // Must not re-enter this state since _lNssep has already been incremented.
            ADVANCETO(2);
            goto loop;
        }
        else
        {
            hr = pop(false);
            break;
        }

    case 3:  // this is the case when we are not supporting namespaces.
simple:
        while (isNameChar(_chLookahead) && !_fEOF)
        {
            ADVANCE;
        }
        hr = pop(false);
        break;

    default:
        INTERNALERROR;
    }

CleanUp:
    return hr;
}

HRESULT 
XMLStream::parseNmToken()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        if (! isNameChar(_chLookahead))
        {
            if (ISWHITESPACE(_chLookahead))
                return XML_E_UNEXPECTED_WHITESPACE;

            return XML_E_BADNAMECHAR;
        }
        _sSubState = 1;
        // fall through
    case 1:
        while (_chLookahead != L'>' && isNameChar(_chLookahead) && ! _fEOF)
        {
            ADVANCE;
        }
        checkhr2(pop(false));
        break;

    default:
        INTERNALERROR;
    }
    return hr;
}

HRESULT 
XMLStream::parseAttributes()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        _nAttrType = XMLTYPE_CDATA;
        _fCheckAttribute = false;
        checkhr2(push(&XMLStream::skipWhiteSpace, 1));
        checkhr2( skipWhiteSpace() );
        _sSubState = 1;
        // fall through
    case 1:
        if (_chLookahead == _chEndChar || _chLookahead == L'>' )
        {
            checkhr2(pop()); // no attributes.
            return S_OK;
        }
        if (_chLookahead == L'x')
        {
            _fCheckAttribute = true;
        }
        checkhr2( push( &XMLStream::parseName, 2 ) );
        checkhr2( parseName() );

        if (!ISWHITESPACE(_chLookahead) && _chLookahead != L'=')
        {
            return XML_E_BADNAMECHAR;
        }
        _sSubState = 2;
        // fall through
    case 2:
        if (ISWHITESPACE(_chLookahead))
        {
            // Eq ::= S? '=' S?
            STATE(7);
        }

        checkeof(_chLookahead, XML_E_UNCLOSEDSTARTTAG);
        if (_fCheckAttribute)
        {
            const WCHAR* t; long len;
            getToken(&t, &len);
            if (StringEquals(L"xml:space",t,len+_lLengthDelta,_fCaseInsensitive))
            {
                _nToken = XML_XMLSPACE;
            }
            else if (StringEquals(L"xml:lang",t,len+_lLengthDelta,_fCaseInsensitive))
            {
                _nToken = XML_XMLLANG;
            }
            else if ((_lNslen == 5 && 
                StringEquals(L"xmlns",t,_lNslen,_fCaseInsensitive)) ||
                StringEquals(L"xmlns",t,len+_lLengthDelta,_fCaseInsensitive))
            {
                if (len+_lLengthDelta >= 9 &&
                    StringEquals(L"xml", &t[6], 3, TRUE))
                {
                    return XML_E_RESERVEDNAMESPACE;
                }
                _nToken = XML_NS;
            }
            else if (_fIE4Quirks && 
                StringEquals(L"xml-space",t,len+_lLengthDelta,_fCaseInsensitive))
            {
                _nToken = XML_XMLSPACE;
            }
            else
            {
                _nToken = XML_ATTRIBUTE;
            }
        }
        else
        {
            _nToken = XML_ATTRIBUTE;
        }
        _sSubState = 3;
        return S_OK;
        break;

    case 3:
        if (ISWHITESPACE(_chLookahead))
            return XML_E_UNEXPECTED_WHITESPACE;
        _fWhitespace = false;
        _sSubState = 4;
        // fall through

    case 4:
        if (_chLookahead != L'=')
        {
            return XML_E_MISSINGEQUALS;
        }
        ADVANCE;
        if (ISWHITESPACE(_chLookahead))
        {
            // allow whitespace between '=' and attribute value.
            checkhr2(push(&XMLStream::skipWhiteSpace, 5));
            checkhr2( skipWhiteSpace() );            
        }
        _sSubState = 5;
        // fall through

    case 5:
        if (ISWHITESPACE(_chLookahead))
            return XML_E_UNEXPECTED_WHITESPACE;
        if (_chLookahead != L'"' && _chLookahead != L'\'')
        {
            return XML_E_MISSINGQUOTE;
        }
        _chTerminator = _chLookahead;
        ADVANCE;
        mark(); 
        return push(&XMLStream::parseAttrValue, 6);
        _sSubState = 6;
    // fall through;

    case 6:
        checkeof(_chLookahead, XML_E_UNCLOSEDSTARTTAG);
        if (_chLookahead == _chEndChar || _chLookahead == L'>')
        {
            checkhr2(pop());
            return S_OK;
        }
        if (! ISWHITESPACE(_chLookahead) && !_fIE4Quirks)
        {
            return XML_E_MISSINGWHITESPACE;
        }
        STATE(0); // go back to state 0
        break;

    case 7:
        // allow whitespace between attribute and '='
        _lLengthDelta = _pInput->getTokenLength();
        checkhr2(push(&XMLStream::skipWhiteSpace, 8));
        checkhr2( skipWhiteSpace() );       
        _sSubState = 8;
        // fall through

    case 8:
        checkeof(_chLookahead, XML_E_UNCLOSEDSTARTTAG);
        _lLengthDelta -= _pInput->getTokenLength();
        STATE(2);
        break;

    default:
        INTERNALERROR;
    }
    return hr;
}

HRESULT XMLStream::parseAttrValue()
{
    HRESULT hr = S_OK;

    switch (_sSubState)
    {
    case 0: 
        _fParsingAttDef = true;        
        // mark beginning of attribute data           
        _sSubState =  2;
        // fall through;

    case 2:
        while ( _chLookahead != _chTerminator && 
                _chLookahead != L'<' &&
                ! _fEOF  ) 
        {
            if (_chLookahead == L'&')
            {
                // then parse entity ref and then return
                // to state 2 to continue with PCDATA.
                return push(&XMLStream::parseEntityRef,2);
            }
            hr = _pInput->scanPCData(&_chLookahead, &_fWhitespace);
            if (FAILED(hr))
            {
                if (hr == E_PENDING)
                {
                    hr = S_OK;
                    ADVANCE;
                }
                return hr;
            }
        }
        _sSubState = 3;
        // fall through
    case 3:
        checkeof(_chLookahead, XML_E_UNCLOSEDSTRING);
        if (_chLookahead == _chTerminator)
        {
            ADVANCE;
            if (_fReturnAttributeValue)
            {
                // return what we have so far - if anything.
                if ((_fUsingBuffer && _lBufLen > 0) ||
                    _pInput->getTokenLength() > 1)
                {
                    _lLengthDelta = -1; // don't include string _chTerminator.
                    _nToken = XML_PCDATA;
                }
            }
            else
            {
                _fReturnAttributeValue = true; // reset to default value.
            }
            _fParsingAttDef = false;
            checkhr2(pop());
            return S_OK;
        } 
        else if (_chLookahead == L'<' && _fIE4Quirks)
        {
            // This was allowed in IE4
            ADVANCE;
            STATE(2);
        }
        else
        {
            return XML_E_BADCHARINSTRING;
        }        
        break;

    default:
        INTERNALERROR;
    }
    return hr;
}

// Also, in order to support validation of entity references in this situation, we also
// expand entities.  In order to do this we have to use the local buffer for accumulating
// the names in case they cross entity ref boundaries.  For example: value="A&b;C" will
// expand to a single name "ABC" if the entitiy is defined to be <!ENTITY b "B">.

HRESULT 
XMLStream::expandEntity()
{
    HRESULT hr = S_OK;

    switch (_sSubState)
    {
    case 0:
        // Switch out of DTD mode and buffer mode temporarily.
        _fDTD = _fWasDTD; // but first reset the _fDTD flag.
        _fWasUsingBuffer = _fUsingBuffer;
        _fUsingBuffer = false;
        _fResolved = false;
        _cStreams = _pStreams.used(); // save current # of streams.
        // (NodeFactory will call XMLParser::ExpandEntity).
        return push(&XMLStream::parseEntityRef,1);

    case 1:
        if (! _fResolved)
        {
            if (_cStreams != _pStreams.used()) // was pushstream called ?
            {
                // If so then eat up the space character that pushStream inserts
                // because in this case we don't want inserted whitespace.
                _fDTD = true;
                ADVANCE; 
                _fDTD = _fWasDTD;
            }
        }
        else
        {
            _fUsingBuffer = _fWasUsingBuffer;
            _fWasUsingBuffer = false;
        }
        pop();
        _fWasDTD = _fDTD;
        _fDTD = true;
        break;

    }
    return S_OK;
}

HRESULT 
XMLStream::parseNMString()
{
    HRESULT hr = S_OK;

    switch (_sSubState)
    {
    case 0:
        if (_chLookahead != L'"' && _chLookahead != L'\'')
        {
            hr = XML_E_MISSINGQUOTE;
            goto CleanUp;
        }
        _chTerminator = _chLookahead;
        _sSubState = 1;
        // fall through

    case 1:
        ADVANCE; // skip the string _chTerminator.
        if (! isStartNameChar(_chLookahead) || _chLookahead == L':')
        {
            goto Error;
        }
        mark(); 
        _sSubState = 2;

    case 2:
        while (_chLookahead != L':' && isNameChar(_chLookahead) && !_fEOF)
        {
            ADVANCE;
        }
        checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
        if (_chLookahead != _chTerminator)
        {
            goto Error;
        }
        _sSubState = 3;
        // fall through

    case 3:
        ADVANCE;
        _lLengthDelta = -1; // don't include string _chTerminator.
        hr = pop();
        break;

    default:
        INTERNALERROR;
    }

CleanUp:
    return hr;

Error:
    if (ISWHITESPACE(_chLookahead))
        hr = XML_E_UNEXPECTED_WHITESPACE;
    else
        hr = XML_E_BADSTARTNAMECHAR;
    goto CleanUp;
}

HRESULT 
XMLStream::ScanHexDigits()
{
    HRESULT hr = S_OK;
    while (! _fEOF && _chLookahead != L';')
    {
        if (! isHexDigit(_chLookahead))
        {
            return ISWHITESPACE(_chLookahead) ? XML_E_UNEXPECTED_WHITESPACE : XML_E_BADCHARINENTREF;
        }
        ADVANCE;
    }
    checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
    return hr;
}

HRESULT 
XMLStream::ScanDecimalDigits()
{
    HRESULT hr = S_OK;
    while (! _fEOF && _chLookahead != L';')
    {
        if (! isDigit(_chLookahead))
        {
            return ISWHITESPACE(_chLookahead) ? XML_E_UNEXPECTED_WHITESPACE : XML_E_BADCHARINENTREF;
        }
        ADVANCE;
    }
    checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
    return hr;
}

HRESULT 
XMLStream::parseString()
{
    // This method is used to parse the entity declaration value where we resolve numeric entities
    // but NOT named entities.
    HRESULT hr = S_OK;

    switch (_sSubState)
    {
    case 0:
        if (_chLookahead != L'"' && _chLookahead != L'\'')
        {
            return XML_E_MISSINGQUOTE;
        }
        _lParseStringLevel = _pStreams.used();
        _fUsingBuffer = true;
        _chTerminator = _chLookahead;
        _sSubState = 1;
        // fall through
    case 1:
        ADVANCE;
        mark(); // don't include ' or " in string.
        _sSubState = 2; // and don't do this again.
        // fall through;
    case 2:
        while ( ((_chLookahead != _chTerminator && 
                _chLookahead != _chBreakChar) ||  _lParseStringLevel < _pStreams.used()) &&
                ! _fEOF ) 
        {
            if (_chLookahead == L'&')
            {
                // then parse entity ref resolving numeric entities and 
                // leaving named entities alone.
                ADVANCE; // soak up the ampersand.
                STATE(3);
            }
            PushChar(_chLookahead);
            // 6/24/98 - we must use ADVANCETO because PushChar has
            // already saved the _chLookahead character, and so we 
            // don't want to re-enter this state without the next char.
            ADVANCETO(2); 
        }
        checkeof(_chLookahead, XML_E_UNCLOSEDSTRING);
        if (_chLookahead == _chTerminator)
        {
            ADVANCE;
            _lLengthDelta = -1; // don't include string _chTerminator.
            checkhr2(pop()); 
        }
        else
        {
            return XML_E_BADCHARINSTRING;
        }
        break;

    case 3:
        checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
        if (_chLookahead == L'#')
        {
            ADVANCE;
        }
        else if (! isStartNameChar(_chLookahead))
        {
            hr = XML_E_BADCHARINENTREF;
            break;
        }
        else
        {
            // we are parsing an entity so don't resolve named entities yet.
            PushChar(L'&');
            STATE(7);
        }
        _sSubState = 4;
        // fall through

        // ------------- Numeric entity references --------------------
    case 4:
        checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
        if (_chLookahead == L'x')
        {
            // hex character reference.
            ADVANCE;
            mark();
            STATE(6); // go to state 6
        }
        _sSubState = 5;
        mark();
        // fall through

    case 5: // '&#' ^ [0-9]+ ';'
        checkhr2(ScanDecimalDigits());
        if (_chLookahead != L';')
        {
            return XML_E_MISSINGSEMICOLON;
        }
        else
        {
            // Just resolve the numeric reference into the buffer.
            const WCHAR* t; long len; WCHAR ch;
            getToken(&t, &len);
            checkhr2(DecimalToUnicode(t,len,ch));
            PushChar(ch);
        }
        // 6/24/98 - we must use ADVANCETO because PushChar has
        // already saved the _chLookahead character, and so we 
        // don't want to re-enter this state without the next char.
        ADVANCETO(2); // soak up the L';'
        STATE(2);
        break;

    case 6: // '&#X' ^ [0-9a-fA-F]+
        checkhr2(ScanHexDigits());
        if (_chLookahead != L';')
        {
            return XML_E_MISSINGSEMICOLON;
        }
        else
        {
            // Just resolve the numeric reference into the buffer.
            const WCHAR* t; long len; WCHAR ch;
            getToken(&t, &len);
            checkhr2(HexToUnicode(t,len,ch));
            PushChar(ch);
        }
        // 6/24/98 - we must use ADVANCETO because PushChar has
        // already saved the _chLookahead character, and so we 
        // don't want to re-enter this state without the next char.
        ADVANCETO(2); // soak up the L';'
        STATE(2);
        break;

    case 7:
        // ------------- Named Entity References --------------------
        // Just make sure it is valid - we don't actually return it.
        while (isNameChar(_chLookahead) && !_fEOF)
        {
            PushChar(_chLookahead);
            // 6/24/98 - we must use ADVANCETO because PushChar has
            // already saved the _chLookahead character, and so we 
            // don't want to re-enter this state without the next char.
            ADVANCETO(7); 
        }
        checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
        if (_chLookahead != L';')
        {
            return XML_E_BADCHARINENTREF;
        }
        STATE(2);
        break;

    default:
        INTERNALERROR;
    }
    return hr;
}

HRESULT 
XMLStream::parsePCData()
{
    HRESULT hr = S_OK;

Start:
    switch (_sSubState)
    {
    case 0:
        _fWhitespace = true;
        _sSubState = 1;
        // fall through;

    case 1:
        // This state is used when we are not normalizing white space.  This
        // is a separate state for performance reasons.  
        // Normalizing whitespace is about 11% slower.
        while (_chLookahead != L'<' && ! _fEOF )
        {
            if (_chLookahead == L'&')
            {
                // then parse entity ref and then return
                // to state 1 to continue with PCDATA.
                return push(&XMLStream::parseEntityRef,1);
            }
 
            if (_chLookahead == L'>' && ! _fIE4Quirks)
            {
                WCHAR* pText;
                long len;
                _pInput->getToken((const WCHAR**)&pText, &len);
                if (len >= 2 && StrCmpN(L"]]", pText + len - 2, 2) == 0)
                     return XML_E_INVALID_CDATACLOSINGTAG;               
            }
// This slows us down too much.
//            else if (! isCharData(_chLookahead))
//            {
//                return XML_E_BADCHARDATA;
//            }

            hr = _pInput->scanPCData(&_chLookahead, &_fWhitespace);
            if (FAILED(hr))
            {
                if (hr == E_PENDING)
                {
                    hr = S_OK;
                    ADVANCE;
                }
                return hr;
            }
            checkhr(hr);
        }
        _sSubState = 2;
        // fall through

    case 2:
        if (_pInput->getTokenLength() > 0 || _fUsingBuffer)
        {
            _nToken = _fWhitespace ? XML_WHITESPACE : XML_PCDATA;
        }
        checkhr2(pop());
        break;

    default:
        INTERNALERROR;
    }   
    return S_OK;
}

HRESULT 
XMLStream::parseEntityRef()
{
    HRESULT hr = S_OK;
    long entityLen = 0, i, lLen = 1;
    const WCHAR* t; 
    long len;

Start:
    switch (_sSubState)
    {
    case 0: // ^ ( '&#' [0-9]+ ) | ('&#X' [0-9a-fA-F]+) | ('&' Name) ';'
        _nPreToken = XML_PENDING;
        _lEntityPos = _pInput->getTokenLength(); // record entity position.
        _fPCDataPending = (_lEntityPos > 0);

        if (PreEntityText())
        {
            // remember the pending text before parsing the entity.
            _nPreToken = _nToken;
            _nToken = XML_PENDING;
        }
        _sSubState = 1;
        // fall through
    case 1:
        ADVANCE; // soak up the '&'
        _sSubState = 2;
        // fall through
    case 2:
        checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
        if (_chLookahead == L'#')
        {
            ADVANCE;
            _sSubState = 3;
            // fall through
        }
        else
        {
            // Loose entity parsing allows "...&6..."
            if (! isStartNameChar(_chLookahead))
            {
                if (_fFloatingAmp)
                {
                    // then it isn't an entity reference, so go back to PCDATA
                    if (_fUsingBuffer)
                    {
                        // this in case we are normalizing white space.
                        PushChar(L'&');
                    }
                    _fWhitespace = false;
                    checkhr2(pop());
                    return S_OK;
                }
                else if (ISWHITESPACE(_chLookahead))
                    return XML_E_UNEXPECTED_WHITESPACE;
                else
                    return XML_E_BADSTARTNAMECHAR;
            }
            checkhr2(push(&XMLStream::parseName, 6));
            _sSubState = 1; // avoid doing a mark() so we can return PCDATA if necessary.
            return parseName();
        }
        break;

        // ------------- Numeric entity references --------------------
    case 3:
        checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
        if (_chLookahead == L'x')
        {
            // hex character reference.
            ADVANCE;
            STATE(5); // go to state 5
        }
        _sSubState = 4;
        // fall through

    case 4: // '&#' ^ [0-9]+ ';'
        checkhr2(ScanDecimalDigits());
        if (_chLookahead != L';')
        {
            STATE(9);
        }

        entityLen = _pInput->getTokenLength() - _lEntityPos;
        getToken(&t, &len);
        checkhr2(DecimalToUnicode(t + _lEntityPos + 2, entityLen - 2, _wcEntityValue));
        lLen = 2;
        _nToken = XML_NUMENTITYREF;
        GOTOSTART(10); // have to use GOTOSTART() because we want to use the values of t and len
        break;

    case 5: // '&#X' ^ [0-9a-fA-F]+
        checkhr2(ScanHexDigits());
        if (_chLookahead != L';')
        {
            STATE(9);
        }

        entityLen = _pInput->getTokenLength() - _lEntityPos;
        getToken(&t, &len);
        checkhr2(HexToUnicode(t + _lEntityPos + 3, entityLen - 3, _wcEntityValue));
        lLen = 3;
        _nToken = XML_HEXENTITYREF;
        GOTOSTART(10);  // have to use GOTOSTART() because we want to use the values of t and len
        break;
        
        // ------------- Named Entity References --------------------
    case 6: // '&' Name ^ ';'
        checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
        if (_chLookahead != L';')
        {
            STATE(9);
        }

        // If parseName found a namespace then we need to calculate the
        // real nslen taking the pending PC data and '&' into account
        // and remember this in case we have to return the PCDATA.
        _nEntityNSLen = (_lNslen > 0) ? _lNslen - _lEntityPos - 1 : 0;
        _fUsingBuffer = false;

        entityLen = _pInput->getTokenLength() - _lEntityPos;
        getToken(&t, &len);

        if (0 != (_wcEntityValue = BuiltinEntity(t + _lEntityPos + 1, entityLen - 1)) ||
            (_fIE4Quirks && 0xFFFF != (_wcEntityValue = LookupBuiltinEntity(t + _lEntityPos + 1, entityLen - 1))))
        {
            lLen = 1;
            _nToken = XML_BUILTINENTITYREF;
            GOTOSTART(10);  // have to use GOTOSTART() because we want to use the values of t and len
        }
        else if (_nPreToken != XML_PENDING)
        {
            // Return previous token (XML_PCDATA or XML_WHITESPACE)
            _lLengthDelta = -entityLen;
            _lMarkDelta = entityLen - 1; // don't include '&' in _nToken.
            _nToken = _nPreToken;
            STATE(7);
        }

        mark(entityLen-1); // don't include '&' in _nToken.
        _sSubState = 7;
        // fall through

    case 7:
        ADVANCE; // soak up the ';'
        _nToken = XML_ENTITYREF;
        _lNslen = _nEntityNSLen;
        _lLengthDelta = -1; // don't include the ';'
        STATE(8); // return token and resume in state 8.
        break;

    case 8:
        mark();
        checkhr2(pop());
        return S_OK;

    case 9:
        // Soft entity handling - we just continue with PCDATA in 
        // this case.
        if (_fFloatingAmp)
        {
            if (_fUsingBuffer)
            {
                // this in case we are normalizing white space.  In this case
                // we have to copy what we have so far to the normalized buffer.
                long endpos = _pInput->getTokenLength();
                const WCHAR* t; long len;
                getToken(&t, &len);
                for (long i = _lEntityPos; i < endpos; i++)
                    PushChar(t[i]);
            }
            _fWhitespace = false;
            checkhr2(pop());
            return S_OK;
        }
        else
            return XML_E_MISSINGSEMICOLON;
        break;

    case 10:
        // Return the text before builtin or char entityref as XML_PCDATA
        if (_nPreToken)
        {
            _nPreToken = _nToken;
            _nToken = XML_PCDATA;
            _lLengthDelta = -entityLen;
            _lMarkDelta = entityLen - lLen; // don't include '&' in _nToken.
            STATE(11);  // return token and resume in state 12.
        }
        else
        {
            _nPreToken = _nToken;
            mark(entityLen - lLen);
            GOTOSTART(11);
        }
        break;

    case 11:
        // push the builtin entity
        _fUsingBuffer = true;
        PushChar(_wcEntityValue);
        _nToken = _nPreToken;
        STATE(12); // return token and resume in state 12.
        break;

    case 12:
        ADVANCE; // soak up the ';'
        STATE(8); // resume in state 8.
        break;

    default:
        INTERNALERROR;
    }   
    return S_OK;      
}

HRESULT 
XMLStream::parsePEDecl()
{
    // This method is used to distinguish between the following cases:
    //  <!ENTITY ^ S % name ... > <!-- a parameter entity declaration -->
    //  <!ENTITY ^ S %foo; ... >  <!-- a parameter entity reference -->

    HRESULT hr = S_OK;
    long entityLen = 0;

    switch (_sSubState)
    {
    case 0: // ^ S 
        if (! ISWHITESPACE(_chLookahead))
            return XML_E_MISSINGWHITESPACE;
        _sSubState = 1;
        // fall through
    case 1:
        _fHandlePE = false; // so we don't try and parse peref from inside skipWhiteSpace.
        checkhr2(push(&XMLStream::skipWhiteSpace, 2));
        checkhr2(skipWhiteSpace());
        _sSubState = 2;
        // fall through
    case 2:
        _fHandlePE = true;
        checkeof(_chLookahead, _lEOFError);
        if (_chLookahead == L'%')
        {
            ADVANCE;    // soak up the '%'
            STATE(4);
        }
        checkhr2(push(&XMLStream::parseName, 3));
        checkhr2( parseName() );
        _sSubState = 3;
        // fall through
    case 3:
        checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
        _nToken = XML_ENTITYDECL;
        checkhr2(pop(false));
        return S_OK;

    case 4:
        if (ISWHITESPACE(_chLookahead))
        {
            checkhr2(push(&XMLStream::skipWhiteSpace, 5));
            return skipWhiteSpace();
        }
        // parsePEREf, then try again in state 1.
        return push(&XMLStream::parsePERef, 1); 

    case 5:
        checkhr2(push(&XMLStream::parseName, 6));
        checkhr2(parseName());
        _sSubState = 6;
        // fall through.

    case 6:
        _nToken = XML_PENTITYDECL;
        checkhr2(pop(false));
        return S_OK;

    default:
        INTERNALERROR;
    }   
    return S_OK;      

}

HRESULT
XMLStream::parsePERef()
{
    HRESULT hr;
    switch (_sSubState)
    {
    case 0:
        _sSubState = 1;
        // fall through

    case 1:
        checkhr2(push(&XMLStream::parseName, 2));
        checkhr2( parseName() );
        _sSubState = 2;
        // fall through

    case 2:
        checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
        if (_chLookahead != L';') return XML_E_MISSINGSEMICOLON;
        ADVANCE;    // soak up the ';'
        _sSubState = 3;
        // fall through

    case 3:
        checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
        _nToken = XML_PEREF;
        _lLengthDelta = -1; // don't include the ';'
        checkhr2(pop());
        break;

    default:
        INTERNALERROR;
    }   
    return S_OK;      

}

HRESULT 
XMLStream::pushTable(short substate, const StateEntry* table, DWORD le)
{
    HRESULT hr = S_OK;

    checkhr2(push(&XMLStream::parseTable, substate));
    _pTable = table;
    _lEOFError = le;
    return hr;
}


HRESULT 
XMLStream::push(StateFunc f, short s)
{
    StateInfo* pSI = _pStack.push();
    if (pSI == NULL)
        return E_OUTOFMEMORY;
    pSI->_sSubState = s;
    pSI->_fnState = _fnState;
    pSI->_pTable = _pTable;
    pSI->_lEOFError = _lEOFError;
    pSI->_cStreamDepth = _cStreamDepth;

    _sSubState = 0;
    _fnState = f;

    return S_OK;
}

HRESULT
XMLStream::pop(bool boundary)
{
    StateInfo* pSI = _pStack.peek();

    if (_fDTD && 
        ! (_fParsingAttDef) && boundary && _cStreamDepth != pSI->_cStreamDepth) // _fParsingNames || 
    {
        // If we are in a PE and we are popping out to a state that is NOT in a PE
        // and this is a pop where we need to check this condition, then return an error.
        // For example, the following is not well formed because the parameter entity
        // pops us out of the ContentModel state in which the PE was found:
        // <!DOCTYPE foo [
        //      <!ENTITY % foo "a)">
        //      <!ELEMENT bar ( %foo; >
        //  ]>...
        return XML_E_PE_NESTING;
    }
    _fnState = pSI->_fnState;
    _sSubState = pSI->_sSubState;
    _pTable = pSI->_pTable;
    _lEOFError = pSI->_lEOFError;
    _pStack.pop();
    return S_OK;
}

HRESULT 
XMLStream::switchTo(StateFunc f)
{
    HRESULT hr;

    // Make sure we keep the old stream depth.
    StateInfo* pSI = _pStack.peek();
    int currentDepth = _cStreamDepth;
    _cStreamDepth = pSI->_cStreamDepth;

    checkhr2(pop(false));
    checkhr2(push(f,_sSubState)); // keep return to _sSubState the same

    _cStreamDepth = currentDepth;

    return (this->*f)();
}

HRESULT 
XMLStream::switchToTable(const StateEntry* table, DWORD le)
{
    HRESULT hr;

    // Make sure we keep the old stream depth.
    StateInfo* pSI = _pStack.peek();
    int currentDepth = _cStreamDepth;
    _cStreamDepth = pSI->_cStreamDepth;

    checkhr2(pop(false));
    checkhr2(pushTable(_sSubState,table,le)); // keep return to _sSubState the same

    _cStreamDepth = currentDepth;

    return parseTable();
}

//========================================================================
HRESULT 
XMLStream::parseCondSect()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        ADVANCE; // soak up the '[' character
        if (_fFoundPEREf) return S_OK;
        _sSubState = 1;
        // fall through
    case 1: // now match magic '[CDATA[' sequence.     
        checkeof(_chLookahead, XML_E_UNCLOSEDMARKUPDECL);
        if (_chLookahead == L'C')
        {
            _pchCDataState = g_pstrCDATA;
            STATE(5); // goto state 5
        }
        _sSubState = 2;   // must be IGNORE, INCLUDE or %pe;
        // fall through

    case 2: // must be DTD markup declaration
        // '<![' ^ S? ('INCLUDE' | 'IGNORE' | %pe;) S? [...]]> or 
        // skip optional whitespace
        if (_fInternalSubset)
            return XML_E_CONDSECTINSUBSET;
        checkeof(_chLookahead, XML_E_EXPECTINGOPENBRACKET);
        checkhr2(push(&XMLStream::skipWhiteSpace, 3));
        return skipWhiteSpace(); // must return because of %pe;

    case 3:
        checkeof(_chLookahead, XML_E_UNCLOSEDMARKUPDECL);
        checkhr2(push(&XMLStream::parseName,4));
        return parseName();

    case 4: // scanned 'INCLUDE' or 'IGNORE'
        {
            const WCHAR* t;
            long len;
            getToken(&t,&len);
            if (StringEquals(L"IGNORE",t,len,false))
            {
                return switchTo(&XMLStream::parseIgnoreSect);
            }
            else if (StringEquals(L"INCLUDE",t,len,false))
            {
                return switchTo(&XMLStream::parseIncludeSect);
            }
            else
                return XML_E_BADENDCONDSECT;
        }
        break;

    case 5: // parse CDATA name
        while (*_pchCDataState != 0 && _chLookahead == *_pchCDataState && ! _fEOF)
        {
            ADVANCE;            // advance first, before incrementing _pchCDataState
            _pchCDataState++;   // so that this state is re-entrant in the E_PENDING case.
            checkeof(_chLookahead, XML_E_UNCLOSEDMARKUPDECL);
        }
        if (*_pchCDataState != 0)
        {
            // must be INCLUDE or IGNORE section so go to state 2.
            _sSubState = 2;
        } 
        else if (_chLookahead != L'[')
        {
            return XML_E_EXPECTINGOPENBRACKET;
        }
        else if (_fDTD)
            return XML_E_CDATAINVALID;
        else
            return switchTo(&XMLStream::parseCData);

        return S_OK;
        break;        

    default:
        INTERNALERROR;
    }
    return S_OK;
}


HRESULT 
XMLStream::parseCData()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        ADVANCE; // soak up the '[' character.
        mark(); // don't include 'CDATA[' in CDATA text
        _sSubState = 1;
        // fall through
    case 1:
        while (_chLookahead != L']' && ! _fEOF)
        {
            // scanPCData will stop when it sees a ']' character.
            hr = _pInput->scanPCData(&_chLookahead, &_fWhitespace);
            if (FAILED(hr))
            {
                if (hr == E_PENDING)
                {
                    hr = S_OK;
                    ADVANCE;
                }
                return hr;
            }
        }
        checkeof(_chLookahead, XML_E_UNCLOSEDCDATA);
        _sSubState = 2;
        // fall through
    case 2:
        ADVANCE; // soak up first L']' character.
        checkeof(_chLookahead, XML_E_UNCLOSEDCDATA);
        if (_chLookahead != L']')
        {
            // must have been floating ']' character, so
            // return to state 1.
            STATE(1); 
        }
        _sSubState = 3;
        // fall through
    case 3:
        ADVANCE; // soak up second ']' character.
        checkeof(_chLookahead, XML_E_UNCLOSEDCDATA);
        if (_chLookahead == L']')
        {
            // Ah, an extra ']' character, tricky !!  
            // In this case we stay in state 3 until we find a non ']' character
            // so you can terminate a CDATA section with ']]]]]]]]]]]]]]]]>'
            // and everying except the final ']]>' is treated as CDATA.
            STATE(3);
        }
        else if (_chLookahead != L'>')
        {
            // must have been floating "]]" pair, so
            // return to state 1.
            STATE(1);
        }
        _sSubState = 4;
        // fall through
    case 4:
        ADVANCE; // soak up the '>'
        _nToken = XML_CDATA;
        _lLengthDelta = -3; // don't include terminating ']]>' in text.
        checkhr2(pop()); // return to parseContent.
        return S_OK;
        break;

    default:
        INTERNALERROR;
    }
    return S_OK;
}

HRESULT 
XMLStream::parseIncludeSect()
{
    // now parse conditional section contents.
    // which is like parseDTDContent except it
    // terminates with ']]>' instead of ']' and it
    // does not allow another '<!['.
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0: // '<![' INCLUDE ^ S? '[' (decl | PI | comment | pe | S)* ']]>'
        _nToken = XML_INCLUDESECT;
        checkhr2(push(&XMLStream::skipWhiteSpace, 1));
        return skipWhiteSpace();

    case 1:
        checkeof(_chLookahead, XML_E_UNCLOSEDDECL);
        if (_chLookahead != L'[')
        {
            return XML_E_EXPECTINGOPENBRACKET;
        }
        ADVANCE;
        mark();
        if (_fFoundPEREf) return S_OK;
        _sSubState = 2;
        // fall through

    case 2: // '<![' name '[' ^ (decl | PI | comment | pe | S)* ']]>'
        checkeof(_chLookahead, XML_E_UNCLOSEDDECL);
        _cConditionalSection++;
        checkhr2(push(&XMLStream::parseDTDContent,3));
        return parseDTDContent();

    case 3: // ']' ^ ']>'
        checkeof(_chLookahead, XML_E_UNCLOSEDDECL);
        if (ISWHITESPACE(_chLookahead))
            return XML_E_UNEXPECTED_WHITESPACE;
        else if (_chLookahead != L']')
        {
            return XML_E_BADENDCONDSECT;
        }
        ADVANCE;
        _sSubState = 4;
        // fall through
    case 4: // ']]' ^ '>'
        checkeof(_chLookahead, XML_E_UNCLOSEDDECL);
        if (ISWHITESPACE(_chLookahead))
            return XML_E_UNEXPECTED_WHITESPACE;
        else if (_chLookahead != L'>')
        {
            return XML_E_BADENDCONDSECT;
        }
        ADVANCE;
        _nToken = XML_ENDCONDSECT;
        checkhr2(pop());
        return S_OK;
        
    default:
        INTERNALERROR;

    }
    return S_OK;
}

HRESULT 
XMLStream::parseIgnoreSect()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0: // <![IGNORE ^ S? '[' ...
        _cIgnoreSectLevel++; // allow nested ignore sections.
        checkhr2(push(&XMLStream::skipWhiteSpace, 1));
        return skipWhiteSpace();

    case 1: // <![IGNORE S? ^ '[' ...
        checkeof(_chLookahead, XML_E_UNCLOSEDDECL);
        if (_chLookahead != L'[')
        {
            return XML_E_EXPECTINGOPENBRACKET;
        }
        ADVANCE;
        if (_cIgnoreSectLevel == 1) mark();
        checkhr2(push(&XMLStream::skipWhiteSpace, 2));
        return skipWhiteSpace();

    case 2:
        _fHandlePE = false; // turn of parameter entity handling.
        while (_chLookahead != L']' && _chLookahead != L'<' && ! _fEOF)
        {
            ADVANCE;
        }
        checkeof(_chLookahead, XML_E_UNCLOSEDDECL);
        if (_chLookahead == L'<')    // watch out for nested conditional sections.
            STATE(6);
        _sSubState = 3;
        // fall through
    case 3:
        ADVANCE; // soak up first ']' character.
        checkeof(_chLookahead, XML_E_UNCLOSEDDECL);
        if (_chLookahead != L']')
        {
            // must have been floating ']' character, so\
            // return to state 2.
            STATE(2); 
        }
        _sSubState = 4;
        // fall through
    case 4:
        ADVANCE; // soak up second ']' character.
        checkeof(_chLookahead, XML_E_UNCLOSEDDECL);
        if (_chLookahead == L']')
        {
            // Ah, an extra ']' character, tricky !!  
            // In this case we stay in state 3 until we find a non ']' character
            // so you can terminate a CDATA section with ']]]]]]]]]]]]]]]]>'
            // and everying except the final ']]>' is treated as CDATA.
            STATE(4);
        }
        else if (_chLookahead != L'>')
        {
            // must have been floating "]]" pair, so
            // return to state 2.
            STATE(2);
        }
        _sSubState = 5;
        // fall through
    case 5:
        ADVANCE; // soak up the L'>'
        _cIgnoreSectLevel--;
        if (_cIgnoreSectLevel > 0)
        {
            // continue on in state 2.
            STATE(2);
        }
        else
        {
            _nToken = XML_IGNORESECT;   // return contents as one big string !
            _lLengthDelta = -3; // don't include terminating ']]>' in text.
            checkhr2(pop()); // return to parseContent.
            _fHandlePE = true; // turn parameter entities back on.
            return S_OK;
        }
        break;

    case 6: // <![IGNORE[ .... ^ '<'
        ADVANCE;    // soak up the '<' character
        checkeof(_chLookahead, XML_E_UNCLOSEDDECL);
        if (_chLookahead != L'!')
        {
            // must be something other than '<!'
            STATE(2); 
        }
        _sSubState = 7;
        // fall through

    case 7: // <![IGNORE[ .... '<' ^ '!'
        ADVANCE;    // soak up the '<' character
        checkeof(_chLookahead, XML_E_UNCLOSEDDECL);
        if (_chLookahead != L'[')
        {
            // must be something other than '<!['
            STATE(2); 
        }
        // Ok, this is the start of a nested conditional section, 
        // so start again in state 0 which will increment the nesting count.
        STATE(0);

    default:
        INTERNALERROR;
    }
    return S_OK;
}

HRESULT 
XMLStream::skipInternalSubset()
{
    HRESULT hr = S_OK;

    switch (_sSubState)
    {
    case 0:
        // Ok, now we skip to the end of the internal subset
        // and return it as one big string.  The client can then
        // create a new parser, put it in DTD mode and 
        // parse the DTD stuff.
        _nToken = XML_STARTDTDSUBSET;
        mark();
        _pInput->Lock();
        _fInternalSubset = true;
        _fDTD = true;
        checkhr2(push(&XMLStream::parseDTDContent, 1));
        return S_OK;
        break;

    case 1:
        _lLengthDelta = -1; // don't return closing ']' in token.
        _pInput->UnLock();
        _nToken = XML_DTDSUBSET;
        checkhr2(pop());
        break;
    }
    return hr;
}

HRESULT 
XMLStream::parseDTDContent()
{
    // This is similar to parseContent except it doesn't allow
    // PCData and normal XML elements.
    HRESULT hr = S_OK;
    if (_fEOF) 
    {
        if (_pStack.used() == 0)
            return XML_E_ENDOFINPUT;
        else if (_cConditionalSection)
            return XML_E_UNCLOSEDDECL;
        else
            return XML_E_UNEXPECTEDEOF;
    }

    switch (_sSubState)
    {
    case 0: // '[' ^ (decl | PI | comment | pe | S)* ']'
        switch (_chLookahead)
        {
        case L'<':
            ADVANCE;
            if (_chLookahead == L'!')
            {            
                checkhr2(_pInput->Freeze()); // stop shifting data until '>'
                return pushTable(  0, g_DeclarationTable, XML_E_UNCLOSEDDECL);
            }
            else if (_chLookahead == L'?')
            {
                checkhr2(push( &XMLStream::parsePI, 0));
                return parsePI();
            }
            else if (ISWHITESPACE(_chLookahead))
                return XML_E_UNEXPECTED_WHITESPACE;
            else 
                return XML_E_BADELEMENTINDTD;
            break;
        case L'%':
            ADVANCE;
            checkhr2(push(&XMLStream::parsePERef,0));
            return parsePERef();
        case L']':
            if (_fInternalSubset || _cConditionalSection)
            {
                // Internal Subset or conditional section is finished
                mark();
                ADVANCE; // soak up L']'
                if (_fInternalSubset)
                {
                    _fDTD = false;
                    _fInternalSubset = false;
                }
                _cConditionalSection--;
                checkhr2(pop()); // we're done, and now we should have '>'
                return S_OK;
            }
            else
            {
                return XML_E_BADCHARINDTD;
            }
            break;
        default:
            break;
        }
        if (! ISWHITESPACE(_chLookahead))
        {
            return XML_E_BADCHARINDTD;
        }
        // then soak up the whitespace - but return because
        // we may find parameter entity reference.
        checkhr2(push(XMLStream::skipWhiteSpace,1));
        return skipWhiteSpace();

    case 1:
        // return whitespace _nToken and continue in state 1.
        _sSubState = 0;
        if (_pInput->getTokenLength() > 0) // && ! _fNoWhitespaceNodes)
        {
            _nToken = XML_WHITESPACE;
        }
        return S_OK;

    default:
        INTERNALERROR;

    }
    return S_OK;
}

HRESULT
XMLStream::parseEquals()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0: // Eq ::= S? '=' S? 
        if (ISWHITESPACE(_chLookahead))
        {
            // allow whitespace between attribute and '='
            checkhr2(push(&XMLStream::skipWhiteSpace, 1));
            checkhr2( skipWhiteSpace() );            
        }
        _sSubState = 1;
        // fall through

    case 1:
        if (_chLookahead != L'=')
        {
            return XML_E_MISSINGEQUALS;
        }
        ADVANCE;
        if (ISWHITESPACE(_chLookahead))
        {
            // allow whitespace between '=' and attribute value.
            checkhr2(push(&XMLStream::skipWhiteSpace, 2));
            checkhr2( skipWhiteSpace() );            
        }
        _sSubState = 2;
        // fall through

    case 2:
        checkhr2(pop(false));
        break;

    default:
        INTERNALERROR;

    }
    return S_OK;
}

//===============================================================================
// Parse from a StateEntry parse table...

HRESULT 
XMLStream::parseTable()
{
    HRESULT hr = S_OK;


#ifdef _DEBUGXML
    if (_pTable == g_EntityDeclTable)
        TaggedTrace(tagTokenizer,"g_EntityDeclTable");
    else if (_pTable == g_NotationDeclTable)
        TaggedTrace(tagTokenizer,"g_NotationDeclTable");
    else if (_pTable == g_DocTypeTable)
        TaggedTrace(tagTokenizer,"g_DocTypeTable");
    else if (_pTable == g_ExternalIDTable)
        TaggedTrace(tagTokenizer,"g_ExternalIDTable");
    else if (_pTable == g_ContentModelTable)
        TaggedTrace(tagTokenizer,"g_ContentModelTable");
    else if (_pTable == g_ElementDeclTable)
        TaggedTrace(tagTokenizer,"g_ElementDeclTable");
    else if (_pTable == g_AttListTable)
        TaggedTrace(tagTokenizer,"g_AttListTable");
    else if (_pTable == g_DeclarationTable)
        TaggedTrace(tagTokenizer,"g_DeclarationTable");
    else if (_pTable == g_XMLDeclarationTable)
        TaggedTrace(tagTokenizer,"g_XMLDeclarationTable");
#endif

    while (hr == S_OK && _nToken == XML_PENDING)
    {
        const StateEntry* pSE = &_pTable[_sSubState];

        DWORD newState = pSE->_sGoto;

#ifdef _DEBUGXML
        TaggedTrace(tagTokenizer,"state=%d", _sSubState);
#endif
        switch (pSE->_sOp)
        {
        case OP_WS:
            if (_fFoundPEREf) return S_OK;
            checkeof(_chLookahead, _lEOFError);
            if (! ISWHITESPACE(_chLookahead))
                return XML_E_MISSINGWHITESPACE;
            // fall through
        case OP_OWS:
            if (_fFoundPEREf) return S_OK;
            checkeof(_chLookahead, _lEOFError);
            checkhr2(push(&XMLStream::skipWhiteSpace, (short)newState));
            checkhr2(skipWhiteSpace());
            if (_fFoundPEREf) return XML_E_FOUNDPEREF;
            break;
        case OP_NWS:
            if (_fFoundPEREf) return S_OK;
            checkeof(_chLookahead, _lEOFError);
            if (! ISWHITESPACE(_chLookahead))
                newState = pSE->_sGoto;
            else
                newState = pSE->_sArg1;
            break;
        case OP_CHARWS:
            if (_fFoundPEREf) return S_OK;
            mark();
            checkeof(_chLookahead, _lEOFError);
            if (_chLookahead == pSE->_pch[0])
            {
                ADVANCE;
                newState = pSE->_sGoto;
                _nToken = pSE->_lDelta;
            }
            else if (! ISWHITESPACE(_chLookahead))
            {
                return E_FAIL; // XML_E_WHITESPACEORQUESTIONMARK;
            }
            else
                newState = pSE->_sArg1;
            break;
        case OP_CHAR:
            if (_fFoundPEREf) return S_OK;
            mark();
        case OP_CHAR2:
            if (_fFoundPEREf) return S_OK;
            checkeof(_chLookahead, _lEOFError);
            if (_chLookahead == pSE->_pch[0])
            {
                ADVANCE;
                newState = pSE->_sGoto;
                _nToken = pSE->_lDelta;
                if (_nToken == XML_GROUP)
                    _nAttrType = XMLTYPE_NMTOKEN;
            }
            else
            {
                newState = pSE->_sArg1;
                if (newState >= XML_E_PARSEERRORBASE &&
                    ISWHITESPACE(_chLookahead))
                    return XML_E_UNEXPECTED_WHITESPACE;
            }
            break;
        case OP_PEEK:
            if (_fFoundPEREf) return S_OK;
            checkeof(_chLookahead, _lEOFError);
            if (_chLookahead == pSE->_pch[0])
            {
                newState = pSE->_sGoto;
            }
            else
                newState = pSE->_sArg1;
            break;
        case OP_NAME:
            if (_fFoundPEREf) return S_OK;
            checkeof(_chLookahead, _lEOFError);
            checkhr2(push(&XMLStream::parseName, (short)newState));
            checkhr2(parseName());
            break;
        case OP_NMTOKEN:
            if (_fFoundPEREf) return S_OK;
            if (pSE->_sArg1 != 0)
                mark();

            checkeof(_chLookahead, _lEOFError);
            checkhr2(push(&XMLStream::parseNmToken, (short)newState));
            checkhr2(parseNmToken());
            break;
        case OP_TOKEN:
            _nToken = pSE->_sArg1;
            _lLengthDelta = pSE->_lDelta;  
            break;
        case OP_STRING:
            if (_fFoundPEREf) return S_OK;
            checkeof(_chLookahead, _lEOFError);
            _chBreakChar = 0;
            checkhr2(push(&XMLStream::parseString, (short)newState));
            checkhr2(parseString());
            break;
        case OP_EXTID:
            if (_fFoundPEREf) return S_OK;
            // must be ExternalID (section 4.2.2)
            checkeof(_chLookahead, _lEOFError);
            _fShortPubIdOption = (pSE->_sArg1 != 0);
            // push the g_ExternalIDTable parse table !!
            return pushTable((short)newState, g_ExternalIDTable, XML_E_UNCLOSEDDECL);
            break;
        case OP_POP:
            _lLengthDelta = pSE->_lDelta;
            if (_lLengthDelta == 0) mark();
            // The _lDelta field contains a boolean flag to tell us whether this
            // pop needs to check for parameter entity boundary or not.
            checkhr2(pop(pSE->_lDelta == 0)); // we're done !
            _nToken = pSE->_sArg1;
            _nAttrType = XMLTYPE_CDATA;
            return S_OK;
        case OP_STRCMP:
            {
                const WCHAR* t;
                long len;
                getToken(&t,&len);
                long delta = (pSE->_lDelta < 0) ? pSE->_lDelta : 0;
                if (StringEquals(pSE->_pch,t,len+delta,_fCaseInsensitive))
                {
                    if (pSE->_lDelta > 0) 
                    {
                        _nToken = pSE->_lDelta;
                        _lLengthDelta = 0;
                    }


                    if (_pTable == g_AttListTable)
                    {
                        // special case for <!ATTLIST parsing...
                        switch (_nToken)
                        {
                        case XML_AT_CDATA:
                            _nAttrType = XMLTYPE_CDATA;
                            break;
                        case XML_AT_ID:
                        case XML_AT_IDREF:
                        case XML_AT_ENTITY:
                            _nAttrType = XMLTYPE_NAME;
                            break;
                        case XML_AT_IDREFS:
                        case XML_AT_ENTITIES:
                            _nAttrType = XMLTYPE_NAMES;
                            break;
                        case XML_AT_NMTOKEN:
                        case XML_AT_NOTATION:
                            _nAttrType = XMLTYPE_NMTOKEN;
                            break;
                        case XML_AT_NMTOKENS:
                            _nAttrType = XMLTYPE_NMTOKENS;
                            break;
                        }
                    }

                    newState = pSE->_sGoto;
                }
                else
                    newState = pSE->_sArg1;
             }
             break;
        case OP_SUBSET:
            if (_fFoundPEREf) return S_OK;
            checkhr2(push(&XMLStream::skipInternalSubset, (short)newState));
            return skipInternalSubset();

        case OP_PUBIDOPTION:
            if (_fShortPubIdOption)
                newState = pSE->_sGoto;
            else
                newState = pSE->_sArg1;
            break;

        case OP_FAKESYSTEM:
            // Now we have to also fake a "SYSTEM" token.
            _nToken = XML_SYSTEM;
            _fUsingBuffer = true;
            PushChar(L'S');
            PushChar(L'Y');
            PushChar(L'S');
            PushChar(L'T');
            PushChar(L'E');
            PushChar(L'M');
            break;

        case OP_TABLE:
            checkeof(_chLookahead, _lEOFError);
            _nToken = pSE->_sArg1;
            return pushTable((short)newState, 
                (const StateEntry*)(pSE->_pch), XML_E_UNCLOSEDDECL);

        case OP_STABLE:
            checkeof(_chLookahead, _lEOFError);
            return switchToTable((const StateEntry*)(pSE->_pch), XML_E_UNCLOSEDDECL);

        case OP_COMMENT:
            return push(&XMLStream::parseComment, (short)newState);
            break;

        case OP_CONDSECT:
            if (_fFoundPEREf) return S_OK;
            // parse <![CDATA[...]]> or <![IGNORE[...]]>
            return push(&XMLStream::parseCondSect, (short)newState);

        case OP_SNCHAR:
            checkeof(_chLookahead, _lEOFError);
            if (isStartNameChar(_chLookahead))
            {
                newState = pSE->_sGoto;
            }
            else
                newState = pSE->_sArg1;
            break;
        case OP_EQUALS:
            if (_fFoundPEREf) return S_OK;
            checkeof(_chLookahead, _lEOFError);
            checkhr2(push(&XMLStream::parseEquals, (short)newState));
            checkhr2(parseEquals());
            break;
        case OP_ENCODING:
            {
                const WCHAR* t;
                long len;
                _pInput->getToken(&t,&len);
                // hr =  _pInput->switchEncoding(t, len+pSE->_lDelta);
                hr=E_FAIL; // FA
            }
            break;

        case OP_ATTRVAL:
            if (_fFoundPEREf) return S_OK;
            if (_chLookahead != L'"' && _chLookahead != L'\'')
            {
                return XML_E_MISSINGQUOTE;
            }
            _chTerminator = _chLookahead;
            ADVANCE; 
            mark();
            _fReturnAttributeValue = (pSE->_sArg1 == 1);
            checkeof(_chLookahead, _lEOFError);
            return push(&XMLStream::parseAttrValue, (short)newState);
            break;

        case OP_PETEST:
            if (_fFoundPEREf) return S_OK;
            checkeof(_chLookahead, _lEOFError);
            checkhr2(push(&XMLStream::parsePEDecl, (short)newState));
            return parsePEDecl();
            break;

        case OP_NMSTRING:
            checkhr2(push(&XMLStream::parseNMString, (short)newState));
            checkhr2(parseNMString());
            break;
        }
        if (_fnState != &XMLStream::parseTable)
            return S_OK;

        if (newState >= XML_E_PARSEERRORBASE)
            return (HRESULT)newState;
        else
            _sSubState = (short)newState;
    }

    if (_nToken == XMLStream::XML_ENDDECL)
    {
        return _pInput->UnFreeze();
    }
    return S_OK;
}


HRESULT    
XMLStream::_PushChar(WCHAR ch) 
{
    // buffer needs to grow.
    long newsize =  (_lBufSize+512)*2 ;
    WCHAR* newbuf = new_ne WCHAR[newsize];
    if (newbuf == NULL)
        return E_OUTOFMEMORY;
    if (_pchBuffer != NULL)
    {
        ::memcpy(newbuf, _pchBuffer, sizeof(WCHAR)*_lBufLen);
        delete[] _pchBuffer;
    }
    _lBufSize = newsize;
    _pchBuffer = newbuf;   
    _pchBuffer[_lBufLen++] = ch;
    return S_OK;
}

HRESULT 
XMLStream::AdvanceTo(short substate)
{
    // This method combines and advance with a state switch in one
    // atomic operation that handles the E_PENDING case properly.

    _sSubState = substate;

    HRESULT hr = (!_fDTD) ? _pInput->nextChar(&_chLookahead, &_fEOF) : DTDAdvance(); 
    if (hr != S_OK && (hr == E_PENDING || hr == E_DATA_AVAILABLE || hr == E_DATA_REALLOCATE || hr == XML_E_FOUNDPEREF))
    {
        // Then we must do an advance next time around before continuing
        // with previous state.  Push will save the _sSubState and return
        // to it.
        push(&XMLStream::firstAdvance,substate);
    }    
    return hr;
}

bool
XMLStream::PreEntityText()
{
    // This is a helper function that calculates whether or not to
    // return some PCDATA or WHITEPACE before an entity reference.
    if (_fPCDataPending)
    {
        // return what we have so far.
        if (_fWhitespace && ! _fIE4Quirks) // in IE4 mode we do not have WHITESPACE nodes
                                           // and entities are always resolved, so return
                                           // the leading whitespace as PCDATA.
            _nToken = XML_WHITESPACE;                                
        else                               
            _nToken = XML_PCDATA;

        long entityLen = _pInput->getTokenLength() - _lEntityPos;
        _lLengthDelta = -entityLen;
        _lMarkDelta = entityLen;
        _fPCDataPending = false;
        _fWhitespace = true;
        return true;
    }

    return false;
}

HRESULT 
XMLStream::ErrorCallback(HRESULT hr)
{
    if (hr == E_DATA_AVAILABLE)
        hr = XML_DATAAVAILABLE;
    else if (hr == E_DATA_REALLOCATE)
        hr = XML_DATAREALLOCATE;
    return _pXMLParser->ErrorCallback(hr);
}

unsigned short __cdecl LookupBuiltinEntity(unsigned short const *,unsigned long)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\ahui\ids.h ===
#ifndef __APPHELP_IDS
#define __APPHELP_IDS

#define IDS_APPCOMPATWIN95H         1000
#define IDS_APPCOMPATWIN95          1001
#define IDS_APPCOMPATWIN95L         1002
#define IDS_APPCOMPATWIN95R         1003
#define IDS_APPCOMPAT_CANCEL        1004
#define IDS_APPCOMPAT_RUNCANCEL     1005

#define IDC_WORKED                  1100
#define IDC_NOTWORKING              1101


#define DLG_APPCOMPAT               2000
#define DLG_FEEDBACK                2100

#define IDD_STATE                   2001
#define IDD_RICHTEXT                2002
#define IDD_LINE_1                  2003
#define IDD_DETAILS                 2004
#define IDD_ICON                    2005
#define IDD_ICON_TRASH              2006
#define IDD_APPNAME                 2007
#define IDD_CONTACT                 2008
#define IDD_LINE_2                  2009
#define IDD_APPHELP_DETAILS         2010

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\apphelp\check.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        check.c

    Abstract:

        This module implements the main API that CreateProcess
        calls to check if an EXE is shimmed or apphelpped.

    Author:

        vadimb     created     sometime in 2000

    Revision History:

        clupu      cleanup                                12/27/2000
        andyseti   added ApphelpCheckExe                  03/29/2001
        andyseti   added ApphelpCheckInstallShieldPackage 06/28/2001
--*/

#include "apphelp.h"


extern HINSTANCE ghInstance;

//
// Prototypes of internal functions
//
void
GetExeNTVDMData(
    IN  HSDB hSDB,                  // the SDB context
    IN  PSDBQUERYRESULT psdbQuery,  // the EXEs and LAYERs that are active
    OUT WCHAR* pszCompatLayer,      // The new compat layer variable. with format:
                                    // "Alpha Bravo Charlie"
    OUT PNTVDM_FLAGS pFlags         // The flags
    );


//
// Appcompat Infrastructure disable-via-policy-flag
//
DWORD gdwInfrastructureFlags; // initialized to 0

#define APPCOMPAT_INFRA_DISABLED   0x00000001
#define APPCOMPAT_INFRA_VALID_FLAG 0x80000000

#define IsAppcompatInfrastructureDisabled() \
    (!!( (gdwInfrastructureFlags & APPCOMPAT_INFRA_VALID_FLAG) ? \
        (gdwInfrastructureFlags & APPCOMPAT_INFRA_DISABLED) : \
        (CheckAppcompatInfrastructureFlags() & APPCOMPAT_INFRA_DISABLED)) )


DWORD
CheckAppcompatInfrastructureFlags(
    VOID
    );


#if DBG

BOOL
bDebugChum(
    void
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Checks an env var. If the var is present return TRUE.
--*/
{
    UNICODE_STRING ustrDebugChum;
    UNICODE_STRING ustrDebugChumVal = { 0 };
    NTSTATUS       Status;

    RtlInitUnicodeString(&ustrDebugChum, L"DEBUG_OFFLINE_CONTENT");

    Status = RtlQueryEnvironmentVariable_U(NULL,
                                           &ustrDebugChum,
                                           &ustrDebugChumVal);

    if (Status == STATUS_BUFFER_TOO_SMALL) {
        return TRUE;
    }

    return FALSE;
}

#else // DBG
    #define bDebugChum() TRUE
#endif // DBG

BOOL
GetExeID(
    IN  PDB   pdb,              // the pointer to the database
    IN  TAGID tiExe,            // the TAGID of the EXE for which we need the ID
    OUT GUID* pGuid             // will receive the EXE's ID
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Reads the EXE's ID from the database using the EXE's tag id.
--*/
{
    TAGID tiExeID;

    tiExeID = SdbFindFirstTag(pdb, tiExe, TAG_EXE_ID);

    if (tiExeID == TAGID_NULL) {
        DBGPRINT((sdlError, "GetExeID", "EXE tag 0x%x without an ID !\n", tiExe));
        return FALSE;
    }

    if (!SdbReadBinaryTag(pdb, tiExeID, (PBYTE)pGuid, sizeof(*pGuid))) {
        DBGPRINT((sdlError, "GetExeID", "Cannot read the ID for EXE tag 0x%x.\n", tiExe));
        return FALSE;
    }

    return TRUE;
}


BOOL
GetExeIDByTagRef(
    IN  HSDB   hSDB,            // handle to the database object
    IN  TAGREF trExe,           // EXE tag ref
    OUT GUID*  pGuid            // will receive the EXE's ID
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Reads the EXE's ID from the database using the EXE's tag ref.
--*/
{
    PDB   pdb;
    TAGID tiExe;
    TAGID tiExeID;

    if (!SdbTagRefToTagID(hSDB, trExe, &pdb, &tiExe)) {
        DBGPRINT((sdlError,
                  "GetExeIDByTagRef",
                  "Failed to get the tag id from EXE tag ref 0x%x.\n",
                  tiExe));
        return FALSE;
    }

    return GetExeID(pdb, tiExe, pGuid);
}



#define APPHELP_CLSID_REG_PATH  L"\\Registry\\Machine\\Software\\Classes\\CLSID\\"
#define APPHELP_INPROCSERVER32  L"\\InProcServer32"

DWORD
ResolveCOMServer(
    IN  REFCLSID    CLSID,
    OUT LPWSTR      lpPath,
    OUT DWORD       dwBufSize)
{
    DWORD                           dwReqBufSize = 0;
    UNICODE_STRING                  ustrKey = { 0 };
    UNICODE_STRING                  ustrValueName = { 0 };
    UNICODE_STRING                  ustrGuid = { 0 };
    UNICODE_STRING                  ustrUnexpandedValue = { 0 };
    UNICODE_STRING                  ustrValue = { 0 };
    NTSTATUS                        Status;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    HANDLE                          KeyHandle = NULL;
    PKEY_VALUE_FULL_INFORMATION     pKeyValueInfo = NULL;
    DWORD                           dwKeyValueInfoSize = 0;
    DWORD                           dwKeyValueInfoReqSize = 0;
    LPWSTR                          wszCLSIDRegFullPath = NULL;
    WCHAR                           wszCLSID[41] = { 0 };

    wszCLSIDRegFullPath = RtlAllocateHeap(
                            RtlProcessHeap(),
                            HEAP_ZERO_MEMORY,
                            (wcslen(APPHELP_CLSID_REG_PATH) +
                             wcslen(APPHELP_INPROCSERVER32) + 64)
                                * sizeof(WCHAR));
                                // Enough for path + CLSID in string form

    if (wszCLSIDRegFullPath == NULL) {
        DBGPRINT((sdlInfo,
                  "SdbResolveCOMServer",
                  "Memory allocation failure\n"));
        goto Done;
    }

    wcscpy(wszCLSIDRegFullPath, APPHELP_CLSID_REG_PATH);

    Status = RtlStringFromGUID(CLSID, &ustrGuid);
    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlInfo,
                  "SdbResolveCOMServer",
                  "Malformed CLSID\n"));
        goto Done;
    }

    if (ustrGuid.Length/sizeof(WCHAR) > 40) {
        DBGPRINT((sdlInfo,
                  "SdbResolveCOMServer",
                  "CLSID more than 40 characters\n"));
        goto Done;
    }

    RtlMoveMemory(wszCLSID,
                  ustrGuid.Buffer,
                  ustrGuid.Length);

    wszCLSID[ustrGuid.Length/sizeof(WCHAR)] = L'\0';

    wcscat(wszCLSIDRegFullPath, wszCLSID);
    wcscat(wszCLSIDRegFullPath, APPHELP_INPROCSERVER32);

    RtlInitUnicodeString(&ustrKey, wszCLSIDRegFullPath);
    RtlInitUnicodeString(&ustrValueName, L"");

    InitializeObjectAttributes(&ObjectAttributes,
                               &ustrKey,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&KeyHandle,
                       GENERIC_READ,
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlInfo,
                  "SdbResolveCOMServer",
                  "Failed to open Key \"%s\" Status 0x%x\n",
                  wszCLSIDRegFullPath,
                  Status));
        goto Done;
    }

    if (lpPath == NULL &&
        dwBufSize != 0) {
        DBGPRINT((sdlInfo,
                  "SdbResolveCOMServer",
                  "Bad parameters\n"));
        goto Done;
    }

    pKeyValueInfo = RtlAllocateHeap(RtlProcessHeap(),
                                    HEAP_ZERO_MEMORY,
                                    dwBufSize * 2);

    if (pKeyValueInfo == NULL) {
        DBGPRINT((sdlInfo,
                  "SdbResolveCOMServer",
                  "Memory allocation failure\n"));
        goto Done;
    }

    dwKeyValueInfoSize = dwBufSize * 2;

    Status = NtQueryValueKey(KeyHandle,
                             &ustrValueName,
                             KeyValueFullInformation,
                             pKeyValueInfo,
                             dwKeyValueInfoSize,
                             &dwKeyValueInfoReqSize);

    if (!NT_SUCCESS(Status)) {

        if (Status == STATUS_BUFFER_TOO_SMALL) {

            RtlFreeHeap(RtlProcessHeap(), 0, pKeyValueInfo);

            pKeyValueInfo = RtlAllocateHeap(RtlProcessHeap(),
                                            HEAP_ZERO_MEMORY,
                                            dwKeyValueInfoReqSize);

            if (pKeyValueInfo == NULL) {
                DBGPRINT((sdlInfo,
                          "SdbResolveCOMServer",
                          "Memory allocation failure\n"));
                goto Done;
            }

            dwKeyValueInfoSize = dwKeyValueInfoReqSize;

            Status = NtQueryValueKey(KeyHandle,
                                     &ustrValueName,
                                     KeyValueFullInformation,
                                     pKeyValueInfo,
                                     dwKeyValueInfoSize,
                                     &dwKeyValueInfoReqSize);

            if (!NT_SUCCESS(Status)) {
                DBGPRINT((sdlInfo,
                          "SdbResolveCOMServer",
                          "Failed to retrieve default key value for \"%s\" Status 0x%x\n",
                          wszCLSIDRegFullPath,
                          Status));
                goto Done;
            }

        } else {
            DBGPRINT((sdlInfo,
                      "SdbResolveCOMServer",
                      "Failed to retrieve default key value for \"%s\" Status 0x%x\n",
                      wszCLSIDRegFullPath,
                      Status));
            goto Done;
        }
    }

    if (pKeyValueInfo->Type == REG_SZ) {
        dwReqBufSize = pKeyValueInfo->DataLength + (1 * sizeof(WCHAR));

        if (dwBufSize >= dwReqBufSize) {
            RtlMoveMemory(lpPath, ((PBYTE) pKeyValueInfo) + pKeyValueInfo->DataOffset, pKeyValueInfo->DataLength);
            lpPath[pKeyValueInfo->DataLength / sizeof(WCHAR)] = '\0';
        }

    } else if (pKeyValueInfo->Type == REG_EXPAND_SZ) {
        ustrUnexpandedValue.Buffer = (PWSTR) (((PBYTE) pKeyValueInfo) + pKeyValueInfo->DataOffset);
        ustrUnexpandedValue.Length = (USHORT) pKeyValueInfo->DataLength;
        ustrUnexpandedValue.MaximumLength = (USHORT) pKeyValueInfo->DataLength;
        ustrValue.Buffer = lpPath;
        ustrValue.Length = 0;
        ustrValue.MaximumLength = (USHORT) dwBufSize;
        Status = RtlExpandEnvironmentStrings_U(NULL,
                                               &ustrUnexpandedValue,
                                               &ustrValue,
                                               &dwReqBufSize);

        if (Status == STATUS_BUFFER_TOO_SMALL) {
            goto Done;
        } else if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlInfo,
                      "SdbResolveCOMServer",
                      "Failed to expand key value for \"%s\" Status 0x%x\n",
                      wszCLSIDRegFullPath,
                      Status));
            goto Done;
        }
    }

    DBGPRINT((sdlInfo,
              "SdbResolveCOMServer",
              "CLSID %s resolved to \"%s\"\n",
              wszCLSID, lpPath));

Done:

    if (KeyHandle != NULL) {
        NtClose(KeyHandle);
    }

    if (wszCLSIDRegFullPath != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, wszCLSIDRegFullPath);
    }

    if (pKeyValueInfo != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, pKeyValueInfo);
    }

    if (ustrGuid.Buffer != NULL) {
        RtlFreeUnicodeString(&ustrGuid);
    }

    return dwReqBufSize;
}

VOID
ParseSdbQueryResult(
    IN HSDB            hSDB,
    IN PSDBQUERYRESULT pQuery,
    OUT TAGREF*        ptrAppHelp,      // apphelp tagref, optional
    OUT PAPPHELP_DATA  pApphelpData,    // apphelp data, optional
    OUT TAGREF*        ptrSxsData       // fusion tagref, optional
    )
{
    DWORD dwIndex;
    BOOL  bAppHelp   = FALSE;
    BOOL  bFusionFix = FALSE;
    TAGREF trExe;
    TAGREF trAppHelp = TAGREF_NULL;
    TAGREF trSxsData = TAGREF_NULL;

    //
    // scan matching exes; we extract fusion fix (the first one we find) and apphelp data,
    // also the first one we find
    //

    for (dwIndex = 0; dwIndex < pQuery->dwExeCount; ++dwIndex) {
        trExe = pQuery->atrExes[dwIndex];
        if (ptrAppHelp != NULL && !bAppHelp) {
            bAppHelp = SdbReadApphelpData(hSDB, trExe, pApphelpData);
            if (bAppHelp) {
                trAppHelp = trExe;
                if (ptrSxsData == NULL || bFusionFix) {
                    break;
                }
            }
        }

        // see if we have sxs fix as well
        if (ptrSxsData != NULL && !bFusionFix) {
            bFusionFix = GetExeSxsData(hSDB, trExe, NULL, NULL);
            if (bFusionFix) {
                trSxsData = trExe;
            }
            if (bFusionFix && (ptrAppHelp == NULL || bAppHelp)) {
                break;
            }
        }
    }

    if (ptrAppHelp != NULL) {
        *ptrAppHelp = trAppHelp;
    }

    if (ptrSxsData != NULL) {
        *ptrSxsData = trSxsData;
    }
}




BOOL
InternalCheckRunApp(
    IN  HANDLE  hFile,          // [Optional] Handle to an open file to check
    IN  LPCWSTR pwszPath,       // path to the app in NT format
    IN  LPCWSTR pEnvironment,   // pointer to the environment of the process that is
                                // being created or NULL.
    IN  DWORD   dwReason,       // collection of flags hinting at why we were called
    OUT PVOID*  ppData,         // this will contain the pointer to the allocated buffer
                                // containing the appcompat data.
    OUT PDWORD  pcbData,        // if appcompat data is found, the size of the buffer
                                // is returned here.
    OUT PVOID*  ppSxsData,      // out: Sxs data block from the compatibility database
    OUT PDWORD  pcbSxsData,     // out: sxs data block size
    IN  BOOL    bNTVDMMode,     // Are we doing the special NTVDM stuff?

    IN  LPCWSTR szModuleName,   // the module name (for NTVDM only)

    OUT LPWSTR  pszCompatLayer, // The new compat layer variable. with format:
                                // "__COMPAT_LAYER=Alpha Bravo Charlie"
    OUT PNTVDM_FLAGS  pFlags,   // The flags
    OUT PAPPHELP_INFO pAHInfo   // If there is apphelp to display, this will be filled
                                // in with non-null values
    )
/*++
    Return: FALSE if the app should be blocked from running, TRUE otherwise.

    Desc:   This is the main API of apphelp.dll. It is called from CreateProcess
            to retrieve application compatibility information for the current process.

            This function does not check whether the appcompat infrastructure has been
            disabled, (kernel32 checks that)

--*/
{

    APPHELP_DATA    ApphelpData;
    BOOL            bSuccess;
    BOOL            bRunApp             = TRUE; // run by default
    BOOL            bAppHelp            = FALSE;
    WCHAR*          pwszDosPath         = NULL;
    BOOL            bBypassCache        = FALSE;    // this is set if cache bypass occured (as opposed to entry not being found
    BOOL            bGetSxsData         = TRUE;     // indicates whether we should look for Fusion fixes
    BOOL            bFusionFix          = FALSE;    // will be set to TRUE if we have obtained fusion fix
    HSDB            hSDB                = NULL;
    SDBQUERYRESULT  sdbQuery;
    NTSTATUS        Status;

    TAGREF          trAppHelp           = TAGREF_NULL;
    TAGREF          trFusionFix         = TAGREF_NULL;

    UNICODE_STRING  ExePath;
    RTL_UNICODE_STRING_BUFFER DosPathBuffer;
    UCHAR BufferPath[MAX_PATH*2];

    RtlZeroMemory(&sdbQuery, sizeof(sdbQuery));
    RtlInitUnicodeStringBuffer(&DosPathBuffer, BufferPath, sizeof(BufferPath));

    RtlInitUnicodeString(&ExePath, pwszPath);

    Status = RtlAssignUnicodeStringBuffer(&DosPathBuffer, &ExePath);
    if (NT_SUCCESS(Status)) {
        Status = RtlNtPathNameToDosPathName(0, &DosPathBuffer, NULL, NULL);
    }

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError, "InternalCheckRunApp", "Failed to convert path \"%S\" to DOS.\n", pwszPath));
        goto Done;
    }

    //
    // we have been successful, this is 0-terminated dos path
    //
    pwszDosPath = DosPathBuffer.String.Buffer;

    //
    // Cache lookup was bypassed by one reason or the other.
    // We do not update cache after it had been bypassed.
    //
    bBypassCache = !!(dwReason & SHIM_CACHE_BYPASS);

    hSDB = SdbInitDatabase(0, NULL);

    if (hSDB == NULL) {
        DBGPRINT((sdlError,
                  "InternalCheckRunApp",
                  "Failed to initialize the database.\n"));
        goto Done;
    }

    //
    // We didn't find this EXE in the cache. Query the database
    // to get all the info about this EXE.
    //
    SdbGetMatchingExe(hSDB, pwszDosPath, szModuleName, pEnvironment, 0, &sdbQuery);

    if (sdbQuery.dwFlags & SHIMREG_DISABLE_SXS) {
        bGetSxsData = FALSE;
    }

    //
    // The last EXE in the list is always the more specific one, and
    // the one we want to use for checking IDs and flags and whatnot.
    //

    //
    // find apphelp/and/or Fusion fix
    //
    ParseSdbQueryResult(hSDB,
                        &sdbQuery,
                        &trAppHelp,
                        &ApphelpData,
                        bGetSxsData ? &trFusionFix : NULL);

    bAppHelp = (trAppHelp != TAGREF_NULL);

    if (bAppHelp) {

        //
        // Check whether the disable bit is set (the dwFlags has been retrieved from the
        // registry via the SdbReadApphelpData call)
        //
        if (!(sdbQuery.dwFlags & SHIMREG_DISABLE_APPHELP)) {

            BOOL bNoUI;

            //
            // See whether the user has checked "Don't show this anymore" box before.
            //
            bNoUI = ((sdbQuery.dwFlags & SHIMREG_APPHELP_NOUI) != 0);

            if (bNoUI) {
                DBGPRINT((sdlInfo,
                          "InternalCheckRunApp",
                          "NoUI flag is set, apphelp UI disabled for this app.\n"));
            }

            //
            // Depending on severity of the problem...
            //
            switch (ApphelpData.dwSeverity) {
            case APPHELP_MINORPROBLEM:
            case APPHELP_HARDBLOCK:
            case APPHELP_NOBLOCK:
            case APPHELP_REINSTALL:
                if (bNoUI) {
                    bRunApp = (ApphelpData.dwSeverity != APPHELP_HARDBLOCK);
                } else {
                    DWORD dwRet;


                    //
                    // We need to show apphelp -- pack up the info
                    // so we can hand it off to shimeng or ntvdm.
                    //
                    sdbQuery.trAppHelp = trAppHelp;

                    if (pAHInfo) {
                        PDB   pdb;
                        TAGID tiWhich;

                        if (SdbTagRefToTagID(hSDB, trAppHelp, &pdb, &tiWhich)) {
                            if (SdbGetDatabaseGUID(hSDB, pdb, &(pAHInfo->guidDB))) {
                                pAHInfo->tiExe = tiWhich;
                            }
                        }
                    }

                    bRunApp = TRUE;
                }
                break;

            default:
                //
                // Some other case was found (e.g. VERSIONSUB which should be replaced
                // by shims in most cases).
                //
                DBGPRINT((sdlWarning,
                          "InternalCheckRunApp",
                          "Unhandled severity flag 0x%x.\n",
                          ApphelpData.dwSeverity));
                break;
            }
        }
    }

    //
    // Apphelp verification is done. Check for shims if we should still run the app.
    //
    if (bRunApp) {

        if (ppData &&
            (sdbQuery.atrExes[0] != TAGREF_NULL ||
             sdbQuery.atrLayers[0] != TAGREF_NULL ||
             sdbQuery.trAppHelp)) {
            //
            // There are shims for this EXE. Pack the appcompat data
            // so it can be sent to ntdll in the context of the starting EXE.
            //
            SdbPackAppCompatData(hSDB, &sdbQuery, ppData, pcbData);
        }

        if (ppSxsData && bGetSxsData && trFusionFix != TAGREF_NULL) {
            //
            // See if we have Fusion data to report.
            //
            GetExeSxsData(hSDB, trFusionFix, ppSxsData, pcbSxsData);
            bFusionFix = (ppSxsData != NULL && *ppSxsData != NULL);
        }

        if (bNTVDMMode) {
            GetExeNTVDMData(hSDB, &sdbQuery, pszCompatLayer, pFlags);
        }
    }

    //
    // Update the cache now.
    //
    if (!bBypassCache) {
        //
        // Do not update the cache if we got the EXE entry from a local database.
        //
        bBypassCache = (sdbQuery.atrExes[0] != TAGREF_NULL &&
                        !SdbIsTagrefFromMainDB(sdbQuery.atrExes[0]));
    }

    if (!bBypassCache) {

        //
        // We remove from cache only if we have some appcompat data
        //
        BOOL
        bCleanApp = sdbQuery.atrExes[0] == TAGREF_NULL &&
                    sdbQuery.atrLayers[0] == TAGREF_NULL &&
                    !bAppHelp &&
                    sdbQuery.dwFlags == 0 &&
                    !bFusionFix;

        if (hFile != INVALID_HANDLE_VALUE) {
            ApphelpUpdateCacheEntry (pwszDosPath, hFile, !bCleanApp, FALSE);
        }
    }

Done:

    RtlFreeUnicodeStringBuffer(&DosPathBuffer);

    if (hSDB != NULL) {
        SdbReleaseDatabase(hSDB);
    }

    return bRunApp;
}


BOOL
ApphelpQueryExe(
    IN  HSDB            hSDB,
    IN  LPCWSTR         pwszPath,            // Unicode path to the executable (DOS_PATH)
    IN  BOOL            bAppHelpIfNecessary, // Produce AppHelp dialog if necessary
    IN  DWORD           dwGetMatchingExeFlags,
    OUT SDBQUERYRESULT* pQueryResult         // Shim Database Query Result
    )
/*++
    Return: FALSE if the app should be blocked from running, TRUE otherwise.

    Desc:   This function is similar with ApphelpCheckRunApp but without validating
            cache and Layer flags and doesn't return application compatibility
            information for given app name. It is intended to be called from
            a shim / user mode to verify whether an executable is allowed to run or not.

--*/
{
    BOOL   bRunApp   = TRUE; // run by default
    DWORD  dwDatabaseType = 0;
    DWORD  dwSeverity     = 0;
    TAGREF trAppHelp = TAGREF_NULL;

    HAPPHELPINFOCONTEXT hApphelpInfoContext = NULL;

    //
    // Query the database to get all the info about this EXE.
    // Note:
    //   This function is intended to be called from user mode.
    //   It doesn't require a call to ConvertToDosPath to string \??\ from the filepath.
    //
    DBGPRINT((sdlInfo,
              "ApphelpCheckExe",
              "Calling SdbGetMatchingExe for \"%s\"\n",
              pwszPath));

    SdbGetMatchingExe(hSDB, pwszPath, NULL, NULL, dwGetMatchingExeFlags, pQueryResult);

    //
    // get info out of the query
    //
    ParseSdbQueryResult(hSDB,
                        pQueryResult,
                        &trAppHelp,
                        NULL,       // Apphelp Information api is used here
                        NULL);      // no sxs fixes are needed

    //
    // The last EXE in the list is always the more specific one, and the one we want to
    // use for checking IDs and flags and whatnot.
    //

    if (trAppHelp != TAGREF_NULL) {
        //
        // Read the apphelp data if available for this EXE.
        //
        if (SdbIsTagrefFromMainDB(trAppHelp)) {
            dwDatabaseType |= SDB_DATABASE_MAIN;
        }

        hApphelpInfoContext = SdbOpenApphelpInformationByID(hSDB,
                                                            trAppHelp,
                                                            dwDatabaseType);
    }

    //
    // Check whether the disable bit is set (the dwFlags has been retrieved from the
    // registry via the SdbReadApphelpData call)
    //
    if (hApphelpInfoContext != NULL) {
        if (!(pQueryResult->dwFlags & SHIMREG_DISABLE_APPHELP)) {
            BOOL bNoUI;

            //
            // See whether the user has checked "Don't show this anymore" box before.
            //
            bNoUI = ((pQueryResult->dwFlags & SHIMREG_APPHELP_NOUI) != 0);

            if (bNoUI) {
                DBGPRINT((sdlInfo,
                          "ApphelpCheckExe",
                          "NoUI flag is set, apphelp UI disabled for this app.\n"));
            }


            SdbQueryApphelpInformation(hApphelpInfoContext,
                                       ApphelpProblemSeverity,
                                       &dwSeverity,
                                       sizeof(dwSeverity));

            if (!bAppHelpIfNecessary) {
                bNoUI = TRUE;
            }

            //
            // depending on severity of the problem...
            //
            switch (dwSeverity) {
            case APPHELP_MINORPROBLEM:
            case APPHELP_HARDBLOCK:
            case APPHELP_NOBLOCK:
            case APPHELP_REINSTALL:
                bRunApp = (dwSeverity != APPHELP_HARDBLOCK);

                if (!bNoUI) {
                    DWORD dwRet;
                    APPHELP_INFO AHInfo = { 0 };

                    SdbQueryApphelpInformation(hApphelpInfoContext,
                                               ApphelpDatabaseGUID,
                                               &AHInfo.guidDB,
                                               sizeof(AHInfo.guidDB));

                    SdbQueryApphelpInformation(hApphelpInfoContext,
                                               ApphelpExeTagID,
                                               &AHInfo.tiExe,
                                               sizeof(AHInfo.tiExe));
                    AHInfo.bOfflineContent = bDebugChum();
                    SdbShowApphelpDialog(&AHInfo,
                                         NULL,
                                         &bRunApp); // either we succeeded or bInstall package is treated
                                                    // the same way as No UI
                }
                break;
            default:
                //
                // Some other case was found (e.g. VERSIONSUB which should be replaced
                // by shims in most cases).
                //
                DBGPRINT((sdlWarning,
                          "ApphelpCheckExe",
                          "Unhandled severity flag 0x%x.\n",
                          dwSeverity));
                break;
            }
        }
    }

    //
    // Apphelp verification is done.
    //

    if (hApphelpInfoContext != NULL) {
        SdbCloseApphelpInformation(hApphelpInfoContext);
    }

    return bRunApp;
}


/*++
// This code was used to check for include/exclude list in the database
// to eliminate confusion entries should ALWAYS provide the list
//
// CheckIncludeExcludeList
// returns: TRUE  - database provides the list
//          FALSE - no list is provided in the database
//

BOOL
CheckIncludeExcludeList(
    IN HSDB hSDB,
    IN SDBQUERYRESULT* pQueryResult
    )
{
    INT i;
    TAGREF trExe;
    TAGREF trFix;
    TAGREF trInexclude;

    for (i = 0; i < SDB_MAX_EXES && pQueryResult->atrExes[i] != TAGREF_NULL; ++i) {
        trExe  = pQueryResult->atrExes[i];
        trFix = SdbFindFirstTagRef(hSDB, trExe, TAG_SHIM_REF);
        while (trFix != TAGREF_NULL) {
            trInexclude = SdbFindFirstTagRef(hSDB, trFix, TAG_INEXCLUDE);
            if (trInexclude != TAGREF_NULL) {
                return TRUE;
            }

            trFix = SdbFindNextTagRef(hSDB, trExe, trFix);
        }
    }

    //
    // layers have their own inclusion/exclusion scheme
    //
    return FALSE;

}

--*/

BOOL
ApphelpFixExe(
    IN  HSDB            hSDB,
    IN  LPCWSTR         pwszPath,       // Unicode path to the executable (DOS_PATH)
    IN  SDBQUERYRESULT* pQueryResult,   // QueryResult
    IN  BOOL            bUseModuleName  // if false, module name is not used for dynamic shimming
    )
{
    typedef BOOL    (WINAPI *_pfn_SE_DynamicShim)(LPCWSTR , HSDB , SDBQUERYRESULT*, LPCSTR);

    static  const WCHAR             ShimEngine_ModuleName[]         = L"Shimeng.dll";
    static  const CHAR              DynamicShimProcedureName[]      = "SE_DynamicShim";
    static  _pfn_SE_DynamicShim     pfnDynamicShim = NULL;

    HMODULE         hmodShimEngine = 0;
    BOOL            bResult = FALSE;
    ANSI_STRING     AnsiModuleName = { 0 };
    UNICODE_STRING  UnicodeModuleName;
    NTSTATUS        Status;
    LPCSTR          pszModuleName = NULL;
    LPCWSTR         pwszModuleName;

    //
    // Do we need to do anything?
    //
    if (pQueryResult->atrExes[0] == TAGREF_NULL &&
        pQueryResult->atrLayers[0] == TAGREF_NULL) {
        //
        // Nothing for the shim engine to do.
        //
        bResult = TRUE;
        goto Done;
    }

    //
    // Load additional shims for this exe.
    //
    DBGPRINT((sdlInfo,"ApphelpFixExe", "Loading ShimEngine for \"%s\"\n", pwszPath));

    hmodShimEngine = LoadLibraryW(ShimEngine_ModuleName);

    if (hmodShimEngine == NULL) {
        DBGPRINT((sdlError,"ApphelpFixExe", "Failed to get ShimEngine module handle.\n"));
        goto Done;
    }

    pfnDynamicShim = (_pfn_SE_DynamicShim) GetProcAddress(hmodShimEngine, DynamicShimProcedureName);

    if (NULL == pfnDynamicShim) {
        DBGPRINT((sdlError,
                  "ApphelpFixExe",
                  "Failed to get Dynamic Shim procedure address from ShimEngine module.\n"));
        goto Done;
    }

    //
    // check inclusion/exclusion list
    //
    if (pwszPath != NULL && bUseModuleName) {
        //
        // no inclusion/exclusion in the xml -- determine module name
        //
        pwszModuleName = wcsrchr(pwszPath, L'\\'); // last backslash please

        if (pwszModuleName == NULL) {
            pwszModuleName = pwszPath;
        } else {
            ++pwszModuleName;
        }

        //
        // convert to ansi
        //
        RtlInitUnicodeString(&UnicodeModuleName, pwszModuleName);
        Status = RtlUnicodeStringToAnsiString(&AnsiModuleName,
                                              &UnicodeModuleName,
                                              TRUE);
        if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlError, "ApphelpFixExe",
                       "Failed to convert unicode string \"%s\" to ansi, Status 0x%lx.\n",
                       pwszModuleName, Status));

            goto Done;
        }

        pszModuleName = AnsiModuleName.Buffer; // this will be allocated by RtlUnicodeStringToAnsiString

    }

    if (FALSE == (*pfnDynamicShim)(pwszPath,
                                   hSDB,
                                   pQueryResult,
                                   pszModuleName)) {
        // BUGBUG: This never happens since DynamicShim never return FALSE
        DBGPRINT((sdlError, "ApphelpFixExe", "Failed to call Dynamic Shim.\n"));
        goto Done;
    }

    bResult = TRUE;

Done:

    RtlFreeAnsiString(&AnsiModuleName); // this will do nothing if string is empty
    return bResult;
}

BOOL
ApphelpCheckExe(
    IN  LPCWSTR     pwszPath,            // Unicode path to the executable (DOS_PATH)
    IN  BOOL        bAppHelpIfNecessary, // Only present AppHelp this executable if TRUE
    IN  BOOL        bShimIfNecessary,    // Only load shim for this executable if TRUE
    IN  BOOL        bUseModuleName       // use module name when inclusion/exclusion list is not provided
    )
{
    BOOL            bRunApp = TRUE;
    SDBQUERYRESULT  QueryResult;
    HSDB            hSDB;

    if (IsAppcompatInfrastructureDisabled()) {
        goto Done;
    }

    RtlZeroMemory(&QueryResult, sizeof(QueryResult));

    hSDB = SdbInitDatabase(0, NULL);
    if (hSDB == NULL) {
        DBGPRINT((sdlError, "ApphelpCheckExe", "Failed to initialize database.\n"));
        goto Done;
    }

    bRunApp = ApphelpQueryExe(hSDB,
                              pwszPath,
                              bAppHelpIfNecessary,
                              SDBGMEF_IGNORE_ENVIRONMENT,
                              &QueryResult);

    if (TRUE == bRunApp && TRUE == bShimIfNecessary) {
        ApphelpFixExe(hSDB, pwszPath, &QueryResult, bUseModuleName);
    }

    SdbReleaseDatabase(hSDB);

Done:

    return bRunApp;
}

BOOL
ApphelpCheckIME(
    IN LPCWSTR pwszPath            // Unicode path to the exe
    )
{
    BOOL            bRunApp = TRUE;
    SDBQUERYRESULT  QueryResult;
    HSDB            hSDB;
    BOOL            bCleanApp;

    if (IsAppcompatInfrastructureDisabled()) {
        return TRUE;
    }

    RtlZeroMemory(&QueryResult, sizeof(QueryResult));

    hSDB = SdbInitDatabase(0, NULL);
    if (hSDB == NULL) {
        DBGPRINT((sdlError, "ApphelpCheckIME", "Failed to initialize database.\n"));
        goto Done;
    }

    bRunApp = ApphelpQueryExe(hSDB,
                              pwszPath,
                              TRUE,
                              SDBGMEF_IGNORE_ENVIRONMENT,
                              &QueryResult);

    if (TRUE == bRunApp) {
        ApphelpFixExe(hSDB, pwszPath, &QueryResult, FALSE);
    }

    SdbReleaseDatabase(hSDB);

    //
    // see that it's in the cache if no fixes
    //
    bCleanApp = QueryResult.atrExes[0]   == TAGREF_NULL &&
                QueryResult.atrLayers[0] == TAGREF_NULL &&
                QueryResult.trAppHelp    == TAGREF_NULL &&
                QueryResult.dwFlags      == 0;

#ifndef WIN2K_NOCACHE

    BaseUpdateAppcompatCache(pwszPath, INVALID_HANDLE_VALUE, !bCleanApp);

#endif

Done:

    return bRunApp;
}

BOOL
ApphelpCheckShellObject(
    IN  REFCLSID    ObjectCLSID,
    IN  BOOL        bShimIfNecessary,
    OUT ULONGLONG*  pullFlags
    )
/*++
    Return: FALSE if the object should be blocked from instantiating, TRUE otherwise.

    Desc:   This is a helper function for Explorer and Internet Explorer that will
            allow those applications to detect bad extension objects and either
            block them from running or fix them.

            pullFlags is filled with a 64-bit flag mask that can be used to turn
            on 'hack' flags in Explorer/IE. These are pulled out of the App Compat
            database.

            If the database indicates that a shim should be used to fix the extension
            and bShimIfNecessary is TRUE, this function will load SHIMENG.DLL and
            apply the fix.

--*/
{
    BOOL            bGoodObject = TRUE;
    LPWSTR          szComServer = NULL;
    LPWSTR          szDLLName = NULL;
    DWORD           dwBufSize = 0;
    DWORD           dwReqBufSize = 0;
    SDBQUERYRESULT  QueryResult;
    HSDB            hSDB = NULL;
    PVOID           pModuleHandle = NULL;
    UNICODE_STRING  ustrDLLName = { 0 };
    UNICODE_STRING  ustrNtPath = { 0 };
    NTSTATUS        status;
    HANDLE          hDLL = INVALID_HANDLE_VALUE;
    DWORD           dwReason;

    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;

    if (IsAppcompatInfrastructureDisabled()) {
        return TRUE;
    }

    if (pullFlags != NULL) {
        *pullFlags = 0;
    }

    szComServer = RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH);

    if (szComServer == NULL) {
        DBGPRINT((sdlInfo,"ApphelpCheckShellObject", "Memory allocation error\n"));
        goto Done;
    }

    dwBufSize = MAX_PATH;

    //
    // Turn the CLSID into a filename (ie, the DLL that serves the object)
    //
    dwReqBufSize = ResolveCOMServer(ObjectCLSID, szComServer, dwBufSize);

    if (dwReqBufSize == 0) {
        //
        // CLSID could not be resolved to a DLL.
        //
        goto Done;
    }

    if (dwReqBufSize > dwBufSize) {

        RtlFreeHeap(RtlProcessHeap(), 0, szComServer);
        szComServer = RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, dwReqBufSize);

        if (szComServer == NULL) {
            DBGPRINT((sdlInfo,"ApphelpCheckShellObject", "Memory allocation error\n"));
            goto Done;
        }

        dwBufSize = dwReqBufSize;

        dwReqBufSize = ResolveCOMServer(ObjectCLSID, szComServer, dwBufSize);

        if (dwReqBufSize > dwBufSize || dwReqBufSize == 0) {
            //
            // What? Buffer size changed. This could happen if registration of an
            // object took place between the time we first queried and the next time.
            // Just being paranoid...
            //
            DBGPRINT((sdlInfo,"ApphelpCheckShellObject", "Memory allocation error\n"));
            goto Done;
        }
    }

    //
    // Determine DLL name (w/o path). Walk back to first backslash.
    //
    szDLLName = szComServer + dwReqBufSize/sizeof(WCHAR);

    while (szDLLName >= szComServer) {
        if (*szDLLName == L'\\') {
            break;
        }

        szDLLName--;
    }

    szDLLName++;

    //
    // Check if this DLL is already loaded. If so, no need to try and do anything
    // since it's really too late anyway.
    //
    RtlInitUnicodeString(&ustrDLLName, szDLLName);

    status = LdrGetDllHandle(NULL,
                             NULL,
                             &ustrDLLName,
                             &pModuleHandle);

    if (NT_SUCCESS(status)) {
        //
        // Already loaded.
        //
        goto Done;
    }

    if (!RtlDosPathNameToNtPathName_U(szComServer,
                                      &ustrNtPath,
                                      NULL,
                                      NULL)) {
        DBGPRINT((sdlError,
                    "ApphelpCheckShellObject",
                    "RtlDosPathNameToNtPathName_U failed, path \"%s\"\n",
                    szComServer));
        goto Done;
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               &ustrNtPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hDLL,
                          GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          0,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ,
                          FILE_OPEN,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    if (!NT_SUCCESS(status)) {
        DBGPRINT((sdlError,
                    "ApphelpCheckShellObject",
                    "SdbpOpenFile failed, path \"%s\"\n",
                    szComServer));
        goto Done;
    }

    if (BaseCheckAppcompatCache(ustrNtPath.Buffer, hDLL, NULL, &dwReason)) {
        //
        // We have this in cache
        //
        goto Done;
    }

    RtlZeroMemory(&QueryResult, sizeof(QueryResult));

    hSDB = SdbInitDatabase(0, NULL);
    if (hSDB == NULL) {
        DBGPRINT((sdlError, "ApphelpCheckShellObject", "Failed to initialize database.\n"));
        goto Done;
    }

    bGoodObject = ApphelpQueryExe(hSDB,
                                  szComServer,
                                  FALSE,
                                  SDBGMEF_IGNORE_ENVIRONMENT,
                                  &QueryResult);

    if (TRUE == bGoodObject && TRUE == bShimIfNecessary) {
        ApphelpFixExe(hSDB, szComServer, &QueryResult, FALSE);
    }

    SdbQueryFlagMask(hSDB, &QueryResult, TAG_FLAG_MASK_SHELL, pullFlags, NULL);

    //
    // we might want to use Apphelp api for this -- but shell does pass the right
    // thing to us (most likely)
    //
    BaseUpdateAppcompatCache(ustrNtPath.Buffer,
                             hDLL,
                             !(QueryResult.atrExes[0] == TAGREF_NULL &&
                               QueryResult.atrLayers[0] == TAGREF_NULL));

Done:

    RtlFreeUnicodeString(&ustrNtPath);

    if (hSDB != NULL) {
        SdbReleaseDatabase(hSDB);
    }

    if (hDLL != INVALID_HANDLE_VALUE) {
        NtClose(hDLL);
    }

    if (szComServer != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, szComServer);
    }

    return bGoodObject;
}

BOOL
ApphelpGetNTVDMInfo(
    IN  LPCWSTR pwszPath,       // path to the app in NT format
    IN  LPCWSTR pwszModule,     // module name
    IN  LPCWSTR pEnvironment,   // pointer to the environment of the task that is
                                // being created or NULL if we are to use the main NTVDM
                                // environment block.
    OUT LPWSTR pszCompatLayer,  // The new compat layer variable. with format:
                                // "Alpha Bravo Charlie" -- allow 256 chars for this.
    OUT PNTVDM_FLAGS pFlags,    // The flags
    OUT PAPPHELP_INFO pAHInfo   // If there is apphelp to display, this will be filled
                                // in with non-null values
    )
/*++
    Return: FALSE if the app should be blocked from running, TRUE otherwise.

    Desc:   This is essentially the equivalent of ApphelpCheckRunApp, but specific
            to NTVDM.
--*/
{
    if (IsAppcompatInfrastructureDisabled()) {
        return TRUE;
    }

    return InternalCheckRunApp(INVALID_HANDLE_VALUE, pwszPath, pEnvironment, 0,
                               NULL, NULL, NULL, NULL, TRUE,
                               pwszModule, pszCompatLayer, pFlags, pAHInfo);
}


void
GetExeNTVDMData(
    IN  HSDB hSDB,                  // the SDB context
    IN  PSDBQUERYRESULT psdbQuery,  // the EXEs and LAYERs that are active
    OUT WCHAR* pszCompatLayer,      // The new compat layer variable. with format:
                                    // "Alpha Bravo Charlie"
    OUT PNTVDM_FLAGS pFlags         // The flags
    )
{
    DWORD i;
    ULARGE_INTEGER uliFlags;
    LPVOID pFlagContext = NULL;


    ZeroMemory(pFlags, sizeof(NTVDM_FLAGS));

    //
    // Build the layer variable, and look for the two "special" layers
    //
    if (pszCompatLayer) {
        pszCompatLayer[0] = 0;

        for (i = 0; i < SDB_MAX_LAYERS && psdbQuery->atrLayers[i] != TAGREF_NULL; ++i) {
            WCHAR* pszEnvVar;

            //
            // Get the environment var and tack it onto the full string
            //
            pszEnvVar = SdbGetLayerName(hSDB, psdbQuery->atrLayers[i]);

            //
            // check for one of the two "special" layers
            //
            if (_wcsicmp(pszEnvVar, L"640X480") == 0) {
                //
                // set the 640x480 flag -- found in base\mvdm\inc\wowcmpat.h
                //
                // NOTE: we don't have this flag yet -- waiting on WOW guys
            }
            if (_wcsicmp(pszEnvVar, L"256COLOR") == 0) {
                //
                // set the 256 color flag -- found in base\mvdm\inc\wowcmpat.h
                //
                pFlags->dwWOWCompatFlagsEx |= 0x00000002;
            }

            if (pszEnvVar) {
                wcscat(pszCompatLayer, pszEnvVar);
                wcscat(pszCompatLayer, L" ");
            }
        }
    }

    //
    // Look for compat flags
    //
    SdbQueryFlagMask(hSDB, psdbQuery, TAG_FLAGS_NTVDM1, &uliFlags.QuadPart, &pFlagContext);
    pFlags->dwWOWCompatFlags |= uliFlags.LowPart;
    pFlags->dwWOWCompatFlagsEx |= uliFlags.HighPart;

    SdbQueryFlagMask(hSDB, psdbQuery, TAG_FLAGS_NTVDM2, &uliFlags.QuadPart, &pFlagContext);
    pFlags->dwUserWOWCompatFlags |= uliFlags.LowPart;
    pFlags->dwWOWCompatFlags2 |= uliFlags.HighPart;

    SdbQueryFlagMask(hSDB, psdbQuery, TAG_FLAGS_NTVDM3, &uliFlags.QuadPart, &pFlagContext);
    pFlags->dwWOWCompatFlagsFE |= uliFlags.LowPart;
    // High Part is unused for now.

    // now pack command line parameters

    SdbpPackCmdLineInfo(pFlagContext, &pFlags->pFlagsInfo);
    SdbpFreeFlagInfoList(pFlagContext);
}


BOOL
ApphelpCheckRunApp(
    IN  HANDLE hFile,           // [Optional] Handle to an open file to check
    IN  WCHAR* pwszPath,        // path to the app in NT format
    IN  WCHAR* pEnvironment,    // pointer to the environment of the process that is
                                // being created or NULL.
    IN  DWORD  dwReason,        // collection of flags hinting at why we were called
    OUT PVOID* ppData,          // this will contain the pointer to the allocated buffer
                                // containing the appcompat data.
    OUT PDWORD pcbData,         // if appcompat data is found, the size of the buffer
                                // is returned here.
    OUT PVOID* ppSxsData,       // BUGBUG: describe
    OUT PDWORD pcbSxsData       // BUGBUG: describe
    )
/*++
    Return: FALSE if the app should be blocked from running, TRUE otherwise.

    Desc:   This is the main API of apphelp.dll. It is called from CreateProcess
            to retrieve application compatibility information for the current process.
--*/
{
    return InternalCheckRunApp(hFile, pwszPath, pEnvironment, dwReason,
                               ppData, pcbData, ppSxsData, pcbSxsData,
                               FALSE, NULL, NULL, NULL, NULL);
}



//
// =============================================================================================
//                              InstallShield 7 Support
// =============================================================================================
//
BOOL
ApphelpCheckInstallShieldPackage(
    IN  REFCLSID    PackageID,
    IN  LPCWSTR     lpszPackageFullPath
    )
{
    BOOL            bPackageGood = TRUE; // This return value MUST TRUE otherwise InstallShield7 will cancel its processes.

    TAGREF          trExe = TAGREF_NULL;

    DWORD           dwNumExes = 0;
    DWORD           dwDataType = 0;
    DWORD           dwSize = 0;
    DWORD           dwReturn = 0;

    BOOL            bMatchFound = FALSE;
    NTSTATUS        Status;

    BOOL            bAppHelpIfNecessary = FALSE;
    BOOL            bResult = TRUE;

    WCHAR           wszCLSID[41];
    WCHAR           wszPackageCode[41];

    GUID            guidPackageID;
    GUID            guidPackageCode;

    HSDB            hSDB = NULL;
    SDBQUERYRESULT  QueryResult;

    if (IsAppcompatInfrastructureDisabled()) {
        goto Done;
    }

    if (NULL == lpszPackageFullPath) {
        DBGPRINT((sdlInfo,
                  "ApphelpCheckInstallShieldPackage",
                  "lpszPackageFullPath is NULL\n"));
        goto Done;
    }

    SdbGUIDToString((GUID *)&PackageID, wszCLSID);

    DBGPRINT((sdlWarning,
              "ApphelpCheckInstallShieldPackage",
              "InstallShield package detected. CLSID: %s FullPath: %s\n",
              wszCLSID, lpszPackageFullPath));

    RtlZeroMemory(&QueryResult, sizeof(QueryResult));

    hSDB = SdbInitDatabase(0, NULL);
    if (hSDB == NULL) {
        DBGPRINT((sdlError, "ApphelpCheckExe", "Failed to initialize database.\n"));
        goto Done;
    }

    bMatchFound = ApphelpQueryExe(hSDB,
                                  lpszPackageFullPath,
                                  bAppHelpIfNecessary,
                                  SDBGMEF_IGNORE_ENVIRONMENT,
                                  &QueryResult);

    if (!bMatchFound)
    {
        DBGPRINT((sdlError, "ApphelpCheckInstallShieldPackage", "No match found.\n"));
        goto Done;
    }

    for (dwNumExes = 0; dwNumExes < SDB_MAX_EXES; ++dwNumExes)
    {
        if (TAGREF_NULL == QueryResult.atrExes[dwNumExes]) {
            break;
        }
        trExe = QueryResult.atrExes[dwNumExes];

        DBGPRINT((sdlInfo, "ApphelpCheckInstallShieldPackage", "Processing TAGREF atrExes[%d] = 0x%8x.\n", dwNumExes, trExe));

        dwSize = sizeof(wszPackageCode);
        *wszPackageCode = L'\0';

        dwReturn = SdbQueryData(hSDB,
                                trExe,
                                L"PackageCode",
                                &dwDataType,
                                wszPackageCode,
                                &dwSize);

        if (dwReturn == ERROR_SUCCESS)
        {
            DBGPRINT((sdlInfo, "ApphelpCheckInstallShieldPackage", "SdbQueryData returns dwSize = %d and dwDataType = %d.\n", dwSize, dwDataType));

            if ((dwSize > 0) && (dwSize < sizeof(wszPackageCode)))
            {
                // we have some data
                // check the type (should be string)
                if (REG_SZ != dwDataType)
                {
                    DBGPRINT((sdlError, "ApphelpCheckInstallShieldPackage", "SdbQueryData returns non STRING PackageCode data. Exiting.\n"));
                    goto Done;
                }

                DBGPRINT((sdlInfo, "ApphelpCheckInstallShieldPackage", "Comparing PackageId = %s and PackageCode = %s.\n", wszCLSID, wszPackageCode));

                // convert to guid
                if (FALSE == SdbGUIDFromString(wszPackageCode, &guidPackageCode))
                {
                   DBGPRINT((sdlError, "ApphelpCheckInstallShieldPackage", "Can not convert PackageCode to GUID. Exiting.\n"));
                   goto Done;
                }

                if (RtlEqualMemory(PackageID, &guidPackageCode, sizeof(guidPackageCode) ))
                {
                    DBGPRINT((sdlWarning, "ApphelpCheckInstallShieldPackage",
                        "Found InstallShield package matched with PackageCode: %s.\n",
                        wszPackageCode));

                    if (TRUE != ApphelpFixExe(hSDB, lpszPackageFullPath, &QueryResult, FALSE))
                    {
                        DBGPRINT((sdlError, "ApphelpCheckInstallShieldPackage", "Can not load additional shim dynamically for this executable.\n"));
                    }
                    goto Done;
                }
            }
        }
    } // for

    DBGPRINT((sdlError, "ApphelpCheckInstallShieldPackage", "No match found.\n"));

Done:
    if (hSDB != NULL) {
        SdbReleaseDatabase(hSDB);
    }

    return bPackageGood;
}


//
// =============================================================================================
//                                  MSI Support
// =============================================================================================
//

BOOL
SDBAPI
ApphelpCheckMsiPackage(
    IN GUID* pguidDB,  // database id
    IN GUID* pguidID,  // match id
    IN DWORD dwFlags,  // not used now, set to 0
    IN BOOL  bNoUI
    )
{
    WCHAR        szDatabasePath[MAX_PATH];
    DWORD        dwDatabaseType = 0;
    DWORD        dwPackageFlags = 0;
    DWORD        dwLength;
    BOOL         bInstallPackage = TRUE;
    HSDB         hSDB = NULL;
    TAGREF       trPackage = TAGREF_NULL;

    HAPPHELPINFOCONTEXT hApphelpInfoContext = NULL;
    DWORD               dwSeverity = 0;

    if (IsAppcompatInfrastructureDisabled()) {
        goto out;
    }

    hSDB = SdbInitDatabase(HID_NO_DATABASE, NULL);
    if (hSDB == NULL) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                   "Failed to initialize database\n"));
        goto out;
    }

    //
    // First, we need to resolve a db
    //
    dwLength = SdbResolveDatabase(pguidDB, &dwDatabaseType, szDatabasePath, CHARCOUNT(szDatabasePath));
    if (dwLength == 0 || dwLength > CHARCOUNT(szDatabasePath)) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                  "Failed to resolve database path\n"));
        goto out;
    }

    //
    // open database
    //

    if (!SdbOpenLocalDatabase(hSDB, szDatabasePath)) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                  "Failed to open database \"%s\"\n", szDatabasePath));
        goto out;
    }

    //
    // find the entry
    //
    trPackage = SdbFindMsiPackageByID(hSDB, pguidID);
    if (trPackage == TAGREF_NULL) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                  "Failed to find msi package by guid id\n"));
        goto out;
    }

    hApphelpInfoContext = SdbOpenApphelpInformationByID(hSDB,
                                                        trPackage,
                                                        dwDatabaseType);
    if (hApphelpInfoContext == NULL) {
        DBGPRINT((sdlInfo, "ApphelpCheckMsiPackage",
                  "Apphelp information has not been found\n"));
        goto out;
    }

    //
    // we have apphelp data, check to see if we have flags for this exe
    //

    if (!SdbGetEntryFlags(pguidID, &dwPackageFlags)) {
        DBGPRINT((sdlWarning, "ApphelpCheckMsiPackage",
                  "No flags for trPackage 0x%x\n", trPackage));
        dwPackageFlags = 0;
    }

    //
    // Check whether the disable bit is set (the dwFlags has been retrieved from the
    // registry via the SdbReadApphelpData call)
    //
    if (dwPackageFlags & SHIMREG_DISABLE_APPHELP) {
        goto out;
    }


    bNoUI |= !!(dwPackageFlags & SHIMREG_APPHELP_NOUI);
    if (bNoUI) {
        DBGPRINT((sdlInfo, "ApphelpCheckMsiPackage",
                  "NoUI flag is set, apphelp UI disabled for this app.\n"));
    }

    SdbQueryApphelpInformation(hApphelpInfoContext,
                               ApphelpProblemSeverity,
                               &dwSeverity,
                               sizeof(dwSeverity));

    //
    // depending on severity of the problem...
    //
    switch (dwSeverity) {
    case APPHELP_MINORPROBLEM:
    case APPHELP_HARDBLOCK:
    case APPHELP_NOBLOCK:
    case APPHELP_REINSTALL:

        //
        //
        //
        bInstallPackage = (APPHELP_HARDBLOCK != dwSeverity);
        if (!bNoUI) {
            DWORD dwRet;
            APPHELP_INFO AHInfo = { 0 };

            AHInfo.guidDB = *pguidDB;
            SdbQueryApphelpInformation(hApphelpInfoContext,
                                       ApphelpExeTagID,
                                       &AHInfo.tiExe,
                                       sizeof(AHInfo.tiExe));
            if (AHInfo.tiExe != TAGID_NULL) {

                AHInfo.bOfflineContent = bDebugChum();

                SdbShowApphelpDialog(&AHInfo, NULL, &bInstallPackage);
                   // either we succeeded or bInstall package is treated
                   // the same way as No UI
            }
        }
        break;

    default:
        //
        // Some other case was found (e.g. VERSIONSUB which should be replaced
        // by shims in most cases).
        //
        DBGPRINT((sdlInfo, "ApphelpCheckMsiPackage",
                  "Unhandled severity flag 0x%x.\n", dwSeverity));
        break;
    }

    //
    // at this point we know whether we want to install the package or not
    //


out:

    if (hApphelpInfoContext != NULL) {
        SdbCloseApphelpInformation(hApphelpInfoContext);
    }

    if (hSDB != NULL) {
        SdbReleaseDatabase(hSDB);
    }


    return bInstallPackage;
}

BOOL
SDBAPI
ApphelpFixMsiPackage(
    IN GUID*   pguidDB,
    IN GUID*   pguidID,
    IN LPCWSTR pszFileName,
    IN LPCWSTR pszActionName,
    IN DWORD   dwFlags
    )
{
    WCHAR          szDatabasePath[MAX_PATH];
    DWORD          dwDatabaseType = 0;
    HSDB           hSDB = NULL;
    TAGREF         trPackage = TAGREF_NULL;
    TAGREF         trAction  = TAGREF_NULL;
    SDBQUERYRESULT QueryResult;
    BOOL           bSuccess = FALSE;
    DWORD          dwLength;
    TAGREF         trLayer, trLayerRef;
    DWORD          dwLayers  = 0;

    if (IsAppcompatInfrastructureDisabled()) {
        bSuccess = TRUE;
        goto out;
    }

    hSDB = SdbInitDatabase(0, NULL);
    if (hSDB == NULL) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                   "Failed to initialize database\n"));
        goto out;
    }

    //
    // First, we need to resolve a db
    //
    dwLength = SdbResolveDatabase(pguidDB, &dwDatabaseType, szDatabasePath, CHARCOUNT(szDatabasePath));
    if (dwLength == 0 || dwLength > CHARCOUNT(szDatabasePath)) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                  "Failed to resolve database path\n"));
        goto out;
    }

    //
    // open database
    //

    if (!SdbOpenLocalDatabase(hSDB, szDatabasePath)) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                  "Failed to open database \"%s\"\n", szDatabasePath));
        goto out;
    }

    //
    // find the entry
    //
    trPackage = SdbFindMsiPackageByID(hSDB, pguidID);
    if (trPackage == TAGREF_NULL) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                  "Failed to find msi package by guid id\n"));
        goto out;
    }

    if (SdbGetEntryFlags(pguidID, &dwFlags) && (dwFlags & SHIMREG_DISABLE_SHIM)) {
        DBGPRINT((sdlInfo, "ApphelpCheckMsiPackage",
                  "Shims for this package are disabled\n"));

        goto out;
    }

    trAction = SdbFindCustomActionForPackage(hSDB, trPackage, pszActionName);
    if (trAction == TAGREF_NULL) {
        DBGPRINT((sdlInfo, "ApphelpCheckMsiPackage",
                  "Failed to find custom action \"%s\"\n", pszActionName));
        goto out;
    }

    //
    // we have custom action on our hands which appears to have fixes
    // attached to it, shim it!
    //
    RtlZeroMemory(&QueryResult, sizeof(QueryResult));

    QueryResult.guidID = *pguidID;
    QueryResult.atrExes[0] = trAction;

    //
    // get all the layers for this entry
    //
    trLayerRef = SdbFindFirstTagRef(hSDB, trAction, TAG_LAYER);
    while (trLayerRef != TAGREF_NULL && dwLayers < SDB_MAX_LAYERS) {
        trLayer = SdbGetNamedLayer(hSDB, trLayerRef);
        if (trLayer != TAGREF_NULL) {
            QueryResult.atrLayers[dwLayers++] = trLayer;
        }
        trLayerRef = SdbFindNextTagRef(hSDB, trAction, trLayerRef);
    }


    //
    // ready to shim
    //
    bSuccess = ApphelpFixExe(hSDB, pszFileName, &QueryResult, TRUE);
    if (bSuccess) {
        DBGPRINT((sdlInfo, "ApphelpFixMsiPackage",
                   "Custom action \"%s\" successfully shimmed file \"%s\"\n",
                   pszActionName, pszFileName));
    }

out:
    if (hSDB != NULL) {
        SdbReleaseDatabase(hSDB);
    }


    return(bSuccess);
}

BOOL
SDBAPI
ApphelpFixMsiPackageExe(
    IN GUID* pguidDB,
    IN GUID* pguidID,
    IN LPCWSTR pszActionName,
    IN OUT LPWSTR pwszEnv,
    IN OUT LPDWORD pdwBufferSize
    )
{

    WCHAR          szDatabasePath[MAX_PATH];
    DWORD          dwDatabaseType = 0;
    HSDB           hSDB = NULL;
    TAGREF         trPackage = TAGREF_NULL;
    TAGREF         trAction  = TAGREF_NULL;
    SDBQUERYRESULT QueryResult;
    DWORD          dwLength;
    DWORD          dwBufferSize;
    BOOL           bSuccess = FALSE;
    DWORD          dwFlags;
    int            i;
    TAGREF         trLayer;

    if (pwszEnv != NULL) {
        *pwszEnv = TEXT('\0');
    }

    if (IsAppcompatInfrastructureDisabled()) {
        goto out;
    }

    hSDB = SdbInitDatabase(HID_NO_DATABASE, NULL);
    if (hSDB == NULL) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                   "Failed to initialize database\n"));
        goto out;
    }

    //
    // First, we need to resolve a db
    //
    dwLength = SdbResolveDatabase(pguidDB, &dwDatabaseType, szDatabasePath, CHARCOUNT(szDatabasePath));
    if (dwLength == 0 || dwLength > CHARCOUNT(szDatabasePath)) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                  "Failed to resolve database path\n"));
        goto out;
    }

    //
    // open database
    //

    if (!SdbOpenLocalDatabase(hSDB, szDatabasePath)) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                  "Failed to open database \"%s\"\n", szDatabasePath));
        goto out;
    }

    //
    // find the entry
    //
    trPackage = SdbFindMsiPackageByID(hSDB, pguidID);
    if (trPackage == TAGREF_NULL) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                  "Failed to find msi package by guid id\n"));
        goto out;
    }

    if (SdbGetEntryFlags(pguidID, &dwFlags) && (dwFlags & SHIMREG_DISABLE_SHIM)) {
        DBGPRINT((sdlInfo, "ApphelpCheckMsiPackage",
                  "Shims for this package are disabled\n"));

        goto out;
    }

    trAction = SdbFindCustomActionForPackage(hSDB, trPackage, pszActionName);
    if (trAction == TAGREF_NULL) {
        DBGPRINT((sdlInfo, "ApphelpCheckMsiPackage",
                  "Failed to find custom action \"%s\"\n", pszActionName));
        goto out;
    }

    //
    // now -- this action is an exe, do it right for him
    //
    RtlZeroMemory(&QueryResult, sizeof(QueryResult));

    QueryResult.guidID = *pguidID;

    for (i = 0; i < SDB_MAX_LAYERS; ++i) {
        //
        // check to see if we are doing the first layer, if so - call
        // find first to obtain the layer, else find the next applicable layer
        //

        if (i == 0) {
            trLayer = SdbFindFirstTagRef(hSDB, trAction, TAG_LAYER);
        } else {
            trLayer = SdbFindNextTagRef (hSDB, trAction, trLayer);
        }

        if (trLayer == TAGREF_NULL) {
            break;
        }

        QueryResult.atrLayers[i] = trLayer;
    }

    dwLength = 0;
    if (pdwBufferSize != NULL) {
        dwLength = *pdwBufferSize;
    }

    //
    // build compat layer
    //
    dwBufferSize = SdbBuildCompatEnvVariables(hSDB,
                                              &QueryResult,
                                              0,
                                              NULL,
                                              pwszEnv,
                                              dwLength,
                                              NULL);

    if (pdwBufferSize != NULL) {
        *pdwBufferSize = dwBufferSize;
    }

    bSuccess = TRUE;

out:

    if (hSDB != NULL) {
        SdbReleaseDatabase(hSDB);
    }

    return bSuccess;
}



/*++
    Function:

        CheckAppcompatInfrastructureFlags

    Description:

        Checks various registry places for infrastructure global flags (just the disabled bit for now)
        The flags are set into the global variable gdwInfrastructureFlags. Function is used via the macro
        for perf reasons

    Return:
        global infrastructure flags

--*/

DWORD
CheckAppcompatInfrastructureFlags(
    VOID
    )
{
    static const UNICODE_STRING KeyNameAppCompat =
        RTL_CONSTANT_STRING(L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility");
    static const UNICODE_STRING ValueNameDisableShims =
        RTL_CONSTANT_STRING(L"DisableAppCompat");
    static const OBJECT_ATTRIBUTES objaAppCompat =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&KeyNameAppCompat, OBJ_CASE_INSENSITIVE);

    HANDLE hKey;
    BYTE   ValueBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInformation =
            (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
    DWORD     ValueLength;
    NTSTATUS  Status;

    gdwInfrastructureFlags = 0; // initialize just in case

    // for now we are just checking the disabled bit

    //
    // Now see if the shim infrastructure is disabled for this machine
    //
    Status = NtOpenKey(&hKey, KEY_QUERY_VALUE, (POBJECT_ATTRIBUTES) &objaAppCompat);

    if (NT_SUCCESS(Status)) {
        Status = NtQueryValueKey(hKey,
                                 (PUNICODE_STRING) &ValueNameDisableShims,
                                 KeyValuePartialInformation,
                                 pKeyValueInformation,
                                 sizeof(ValueBuffer),
                                 &ValueLength);

        NtClose(hKey);

        if (NT_SUCCESS(Status) &&
            pKeyValueInformation->Type == REG_DWORD &&
            pKeyValueInformation->DataLength == sizeof(DWORD)) {
            if (*((PDWORD) pKeyValueInformation->Data) > 0) {
                gdwInfrastructureFlags |= APPCOMPAT_INFRA_DISABLED;
            }
        }
    }

    //
    // make the bits valid
    //
    gdwInfrastructureFlags |= APPCOMPAT_INFRA_VALID_FLAG;

    return gdwInfrastructureFlags;
}

/*++
    Function:

        SdbInitDatabaseExport

    Description:

        This is "exported" version of the function SdbInitDatabase
        that checks for the "diabled" flag -- otherwise calls into SdbInitDatabase

    Return:

         see SdbInitDatabase

--*/

HSDB
SDBAPI
SdbInitDatabaseExport(
    IN  DWORD dwFlags,          // flags that tell how the database should be
                                // initialized.
    IN  LPCWSTR pszDatabasePath // the OPTIONAL full path to the database to
                                // be used.
    )
{
    if (IsAppcompatInfrastructureDisabled()) {
        return NULL;
    }

    return SdbInitDatabase(dwFlags, pszDatabasePath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\apphelp\debug.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        debug.c

    Abstract:

        This module implements debug only routines.

    Author:

        vadimb     created     sometime in 2000

    Revision History:

        clupu      cleanup     12/27/2000
--*/

#include "apphelp.h"


#if defined(APPHELP_TOOLS)


//
// this functionality will not be available (temporary)
//


DWORD
ApphelpShowUI(
    TAGREF  trExe,                  // tagref for the exe (should be a "LOCAL" tagref)
    LPCWSTR pwszDatabase,           // database path (we will make a local db out of it
    LPCWSTR pwszDetailsDatabase,
    LPCWSTR pwszApphelpPath,
    BOOL    bLocalChum,
    BOOL    bUseHtmlHelp
    )
/*++
    Return: The same as what ShowApphelp returns.

    Desc:   Given the database and the (local) tagref it procures the dialog
            with all the information in it for a given htmlhelpid.
            This api is for internal use only and it is available on
            checked builds only
--*/
{

/*
    HSDB         hSDB = NULL;
    APPHELP_DATA ApphelpData;
    DWORD        dwRet = (DWORD)-1;
    PAPPHELPCONTEXT pContext;

    pContext = InitializeApphelpContext();
    if (pContext == NULL) {
        DBGPRINT((sdlError,
                  "iShowApphelpDebug",
                  "Failed to initialize Apphelp context for thread id 0x%x\n",
                  GetCurrentThreadId()));
        goto ExitShowApphelpDebug;
    }

    hSDB = SdbInitDatabase(HID_NO_DATABASE, NULL);

    if (hSDB == NULL) {
        DBGPRINT((sdlError, "iShowApphelpDebug", "Failed to initialize database\n"));
        goto Done;
    }

    //
    // Open local database
    //
    if (!SdbOpenLocalDatabase(hSDB, pwszDatabase)) {
        DBGPRINT((sdlError,
                  "iShowApphelpDebug",
                  "Failed to open database \"%ls\"\n",
                  pwszDatabase));
        goto Done;
    }

    if (SdbIsTagrefFromMainDB(trExe)) {
        DBGPRINT((sdlError, "iShowApphelpDebug", "Can only operate on local tagrefs\n"));
        goto Done;
    }

    //
    // Now we venture out and read apphelp data
    //
    if (!SdbReadApphelpData(hSDB, trExe, &ApphelpData)) {
        DBGPRINT((sdlError,
                  "iShowApphelpDebug",
                  "Error while trying to read Apphelp data for 0x%x in \"%S\"\n",
                  trExe,
                  pwszDatabase));
        goto Done;
    }

    //
    // We have the data and everything else we need to throw a dialog,
    // set debug chum ...
    //
    pContext->bShowOfflineContent = bLocalChum;

    //
    // Should we use html help instead ?
    //
    pContext->bUseHtmlHelp = bUseHtmlHelp;

    //
    // Pointer to the local chum.
    //
    pContext->pwszApphelpPath = pwszApphelpPath;

    //
    // And now throw a dialog...
    //
    dwRet = ShowApphelp(&ApphelpData, pwszDetailsDatabase, NULL);

Done:
    if (hSDB != NULL) {
        SdbReleaseDatabase(hSDB);
    }

    //
    // Release the context for this thread/instance
    //
    ReleaseApphelpContext();

ExitShowApphelpDebug:

    return dwRet;
*/
    return TRUE;
}

BOOL
ApphelpShowDialog(
    IN  PAPPHELP_INFO   pAHInfo,    // the info necessary to find the apphelp data
    IN  PHANDLE         phProcess   // [optional] returns the process handle of
                                    // the process displaying the apphelp.
                                    // When the process completes, the return value
                                    // (from GetExitCodeProcess()) will be zero
                                    // if the app should not run, or non-zero
                                    // if it should run.

    )
{ 
    BOOL bRunApp = TRUE;

    SdbShowApphelpDialog(pAHInfo, 
                         phProcess,
                         &bRunApp);

    return bRunApp;
    
}

//
// Get all the file's attributes
//
//


BOOL
ApphelpGetFileAttributes(
    IN  LPCWSTR    lpwszFileName,
    OUT PATTRINFO* ppAttrInfo,
    OUT LPDWORD    lpdwAttrCount
    )
/*++
    Return: The same as what SdbGetFileAttributes returns.

    Desc:   Stub to call SdbGetFileAttributes.
--*/
{
    return SdbGetFileAttributes(lpwszFileName, ppAttrInfo, lpdwAttrCount);
}

BOOL
ApphelpFreeFileAttributes(
    IN PATTRINFO pAttrInfo
    )
/*++
    Return: The same as what SdbFreeFileAttributes returns.

    Desc:   Stub to call SdbFreeFileAttributes.
--*/
{
    return SdbFreeFileAttributes(pAttrInfo);
}

#endif // APPHELP_TOOLS


void CALLBACK
ShimFlushCache(
    HWND      hwnd,
    HINSTANCE hInstance,
    LPSTR     lpszCmdLine,
    int       nCmdShow
    )
/*++
    Return: void.

    Desc:   Entry point for rundll32.exe. This is used to flush cache
            after installing a brand new shim database. Use:

                "rundll32 apphelp.dll,ShimFlushCache"
--*/
{
#ifndef WIN2K_NOCACHE
    BaseFlushAppcompatCache();
#endif
}

void CALLBACK
ShimDumpCache(
    HWND      hwnd,
    HINSTANCE hInstance,
    LPSTR     lpszCmdLine,
    int       nCmdShow
    )
{
#ifndef WIN2K_NOCACHE
    BaseDumpAppcompatCache();
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\ahui\ahui.cpp ===
/*--

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ahui.cpp

Abstract:

    Shows an apphelp message, and returns 0 if the program shouldn't run, and non-
    zero if the program should run

    Accepts a command line with a GUID and a TAGID, in the following format:

    {243B08D7-8CF7-4072-AF64-FD5DF4085E26} 0x0000009E

Author:

    dmunsil 04/03/2001

Revision History:

Notes:



--*/

#define _UNICODE

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <memory.h>
#include <malloc.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <htmlhelp.h>

extern "C" {
#include "shimdb.h"
}

#include "ids.h"

#include "shlobj.h"
#include "shlobjp.h"
#include "shellapi.h"
#include "shlwapi.h"


//
// same is in shell/published and also the same as used in shimdbc
//
#define APPTYPE_TYPE_MASK     0x000000FF

#define APPTYPE_INC_NOBLOCK   0x00000001
#define APPTYPE_INC_HARDBLOCK 0x00000002
#define APPTYPE_MINORPROBLEM  0x00000003
#define APPTYPE_REINSTALL     0x00000004
#define APPTYPE_VERSIONSUB    0x00000005
#define APPTYPE_SHIM          0x00000006
#define APPTYPE_NONE          0x00000000

extern "C" VOID AllowForegroundActivation(VOID);


enum ShimAppHelpSeverityType
{
   APPHELP_MINORPROBLEM = APPTYPE_MINORPROBLEM,
   APPHELP_HARDBLOCK    = APPTYPE_INC_HARDBLOCK,
   APPHELP_NOBLOCK      = APPTYPE_INC_NOBLOCK,
   APPHELP_VERSIONSUB   = APPTYPE_VERSIONSUB,
   APPHELP_SHIM         = APPTYPE_SHIM,
   APPHELP_REINSTALL    = APPTYPE_REINSTALL,
   APPHELP_NONE         = APPTYPE_NONE
};

#define APPHELP_DIALOG_FAILED ((DWORD)-1)

//
// TODO: add parameters to apphelp.exe's command line to work with these
//       variables.
//
BOOL    g_bShowOnlyOfflineContent = FALSE;
BOOL    g_bUseHtmlHelp = FALSE;
WCHAR   g_wszApphelpPath[MAX_PATH];

HFONT   g_hFontBold = NULL;

HINSTANCE g_hInstance;

//
// Global variables used while parsing args
//

DWORD g_dwHtmlHelpID;
DWORD g_dwTagID;
DWORD g_dwSeverity;
LPCWSTR g_pAppName;
LPCWSTR g_pszGuid;
BOOL  g_bPreserveChoice;
WCHAR wszHtmlHelpID[]     = L"HtmlHelpID";
WCHAR wszAppName[]        = L"AppName";
WCHAR wszSeverity[]       = L"Severity";
WCHAR wszGUID[]           = L"GUID";
WCHAR wszTagID[]          = L"TagID";
WCHAR wszOfflineContent[] = L"OfflineContent";
WCHAR wszPreserveChoice[] = L"PreserveChoice";

//
// FORWARD DECLARATIONS OF FUNCTIONS

DWORD
ShowApphelpDialog(
    IN  PAPPHELP_DATA pApphelpData
    );


DWORD
ShowApphelp(
    IN  PAPPHELP_DATA pApphelpData,
    IN  LPCWSTR       pwszDetailsDatabasePath,
    IN  PDB           pdbDetails
    )
/*++
    Return: The return value can be one of the following based on what the user has
            selected:

                -1            - failed to show the info
                IDOK | 0x8000 - "no ui" checked, run the app
                IDCANCEL      - do not run the app
                IDOK          - run the app

    Desc:   Open the details database, collect the details info and then show it.
--*/
{
    DWORD dwRet = APPHELP_DIALOG_FAILED;
    BOOL  bCloseDetails = FALSE;

    if (pdbDetails == NULL) {

        //
        // Open the database containing the details info, if one wasn't passed in.
        //
        if (pApphelpData->bSPEntry) {
            pdbDetails = SdbOpenApphelpDetailsDatabaseSP();
        } else {
            pdbDetails = SdbOpenApphelpDetailsDatabase(pwszDetailsDatabasePath);
        }

        bCloseDetails = TRUE;
        if (pdbDetails == NULL) {
            DBGPRINT((sdlError, "ShowApphelp", "Failed to open the details database.\n"));
            goto Done;
        }
    }

    //
    // Read apphelp details data.
    //
    if (!SdbReadApphelpDetailsData(pdbDetails, pApphelpData)) {
        DBGPRINT((sdlError, "ShowApphelp", "Failed to read apphelp details.\n"));
        goto Done;
    }

    //
    // Show the dialog box. The return values can be:
    //      -1            - error
    //      IDOK | 0x8000 - "no ui" checked, run the app
    //      IDCANCEL      - do not run the app
    //      IDOK          - run the app
    //
    dwRet = ShowApphelpDialog(pApphelpData);

    if (dwRet == APPHELP_DIALOG_FAILED) {
        DBGPRINT((sdlError, "ShowApphelp", "Failed to show the apphelp info.\n"));
    }

Done:
    if (pdbDetails != NULL && bCloseDetails) {
        SdbCloseDatabase(pdbDetails);
    }

    return dwRet;
}

void
FixEditControlScrollBar(
    IN  HWND hDlg,
    IN  int  nCtrlId
    )
/*++
    Return: void.

    Desc:   This function tricks the edit control to not show the vertical scrollbar
            unless absolutely necessary.
--*/
{
    HFONT       hFont = NULL;
    HFONT       hFontOld = NULL;
    HDC         hDC = NULL;
    TEXTMETRICW tm;
    RECT        rc;
    int         nVisibleLines = 0;
    int         nLines;
    DWORD       dwStyle;
    HWND        hCtl;

    //
    // Get the edit control's rectangle.
    //
    SendDlgItemMessageW(hDlg, nCtrlId, EM_GETRECT, 0, (LPARAM)&rc);

    //
    // Retrieve the number of lines.
    //
    nLines = (int)SendDlgItemMessageW(hDlg, nCtrlId, EM_GETLINECOUNT, 0, 0);

    //
    // Calculate how many lines will fit.
    //
    hFont = (HFONT)SendDlgItemMessageW(hDlg, nCtrlId, WM_GETFONT, 0, 0);

    if (hFont != NULL) {

        hDC = CreateCompatibleDC(NULL);

        if (hDC != NULL) {
            hFontOld = (HFONT)SelectObject(hDC, hFont);

            //
            // Now get the metrics
            //
            if (GetTextMetricsW(hDC, &tm)) {
                nVisibleLines = (rc.bottom - rc.top) / tm.tmHeight;
            }

            SelectObject(hDC, hFontOld);
            DeleteDC(hDC);
        }
    }

    if (nVisibleLines && nVisibleLines >= nLines) {
        hCtl = GetDlgItem(hDlg, nCtrlId);
        dwStyle = (DWORD)GetWindowLongPtrW(hCtl, GWL_STYLE);

        SetWindowLongPtrW(hCtl, GWL_STYLE, (LONG)(dwStyle & ~WS_VSCROLL));
        SetWindowPos(hCtl,
                     NULL,
                     0,
                     0,
                     0,
                     0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
    }
}




BOOL
ShowApphelpHtmlHelp(
    HWND            hDlg,
    PAPPHELP_DATA   pApphelpData
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Shows html help using hhctrl.ocx
--*/
{
    WCHAR       szAppHelpURL[2048];
    WCHAR       szWindowsDir[MAX_PATH];
    WCHAR       szChmURL[1024];
    WCHAR       szChmFile[MAX_PATH];
    HINSTANCE   hInst = NULL;
    UINT        nChars;
    int         nChURL, nch;
    HRESULT     hr;
    DWORD       cch;
    LPWSTR      lpwszUnescaped = NULL;
    BOOL        bSuccess = FALSE;
    BOOL        bCustom = FALSE;
    LCID        lcid;
    size_t      nLen;
    BOOL        bFound = FALSE;

    bCustom = !(pApphelpData->dwData & SDB_DATABASE_MAIN);

    // apphelp is not in the main database, then it's custom apphelp

    nChars = GetSystemWindowsDirectoryW(szWindowsDir,
                                        CHARCOUNT(szWindowsDir));

    if (!nChars || nChars > CHARCOUNT(szWindowsDir)) {
        DBGPRINT((sdlError, "ShowApphelpHtmlHelp",
                  "Error trying to retrieve Windows Directory %d.\n", GetLastError()));
        goto errHandle;
    }

    if (bCustom) {
        //
        // this is a custom DB, and therefore the URL in it should be taken
        // as-is, without using the MS redirector
        //

        wcscpy(szAppHelpURL, pApphelpData->szURL);

    } else {

        WCHAR szLcid[16] = L"";

        lcid = GetUserDefaultUILanguage();

        if (pApphelpData->bSPEntry) {
            _snwprintf(szChmFile, CHARCOUNT(szChmFile), L"%s\\Help\\apps_sp.chm", szWindowsDir);
            _snwprintf(szLcid, CHARCOUNT(szLcid), L"_%x.htm", lcid);
        } else {

            wcscpy(szLcid, L".htm");

            if (lcid != MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)) {

                nLen = _snwprintf(szChmFile,
                                  CHARCOUNT(szChmFile),
                                  L"%s\\Help\\MUI\\%04x\\apps.chm",
                                  szWindowsDir,
                                  lcid);

                if (nLen > 0) {
                    bFound = RtlDoesFileExists_U(szChmFile);
                }
            }

            if (!bFound) {
                _snwprintf(szChmFile, CHARCOUNT(szChmFile), L"%s\\Help\\apps.chm", szWindowsDir);
            }
        }


        nChURL = _snwprintf(szAppHelpURL,
                            CHARCOUNT(szAppHelpURL),
                            L"hcp://services/redirect?online=");

        //
        // When we are compiling retail we check for the offline content as well.
        //
        if (!g_bShowOnlyOfflineContent) {

            //
            // First thing, unescape url
            //
            if (pApphelpData->szURL != NULL) {

                //
                // Unescape the url first, using shell.
                //
                cch = wcslen(pApphelpData->szURL) + 1;

                lpwszUnescaped = (LPWSTR)malloc(cch * sizeof(WCHAR));

                if (lpwszUnescaped == NULL) {
                    DBGPRINT((sdlError,
                              "ShowApphelpHtmlHelp",
                              "Error trying to allocate memory for \"%S\"\n",
                              pApphelpData->szURL));
                    goto errHandle;
                }

                //
                // Unescape round 1 - use the shell function (same as used to encode
                // it for xml/database).
                //
                hr = UrlUnescapeW(pApphelpData->szURL, lpwszUnescaped, &cch, 0);
                if (!SUCCEEDED(hr)) {
                    DBGPRINT((sdlError,
                              "ShowApphelpHtmlHelp",
                              "UrlUnescapeW failed on \"%S\"\n",
                              pApphelpData->szURL));
                    goto errHandle;
                }

                //
                // Unescape round 2 - use our function borrowed from help center
                //
                cch = (DWORD)(CHARCOUNT(szAppHelpURL) - nChURL);

                if (!SdbEscapeApphelpURL(szAppHelpURL + nChURL, &cch, lpwszUnescaped)) {
                    DBGPRINT((sdlError,
                              "ShowApphelpHtmlHelp",
                              "Error escaping URL \"%S\"\n",
                              lpwszUnescaped));
                    goto errHandle;
                }

                nChURL += (int)cch;
            }
        }

        //
        // At this point szAppHelpURL contains redirected URL for online usage
        // for custom db szAppHelpURL contains full URL
        //
        // If Apphelp file is provided -- use it
        //
        if (*g_wszApphelpPath) {
            _snwprintf(szChmURL,
                       CHARCOUNT(szChmURL),
                       L"mk:@msitstore:%ls::/idh_w2_%d%s",
                       g_wszApphelpPath,
                       pApphelpData->dwHTMLHelpID,
                       szLcid);
        } else {

            _snwprintf(szChmURL,
                       CHARCOUNT(szChmURL),
                       L"mk:@msitstore:%ls::/idh_w2_%d%s",
                       szChmFile,
                       pApphelpData->dwHTMLHelpID,
                       szLcid);

        }

        //
        // at this point szChmURL contains a URL pointing to the offline help file
        // we put it into the szAppHelpURL for both online and offline case
        //

        if (g_bShowOnlyOfflineContent) {
            cch = (DWORD)(CHARCOUNT(szAppHelpURL) - nChURL);

            if (g_bUseHtmlHelp) {
                hr = UrlEscapeW(szChmURL, szAppHelpURL + nChURL, &cch, 0);
                if (SUCCEEDED(hr)) {
                    nChURL += (INT)cch;
                }
            } else {

                if (!SdbEscapeApphelpURL(szAppHelpURL+nChURL, &cch, szChmURL)) {
                    DBGPRINT((sdlError,  "ShowApphelpHtmlHelp", "Error escaping URL \"%S\"\n", szChmURL));
                    goto errHandle;
                }

                nChURL += (int)cch;
            }
        }

        //
        // now offline sequence
        //
        cch = (DWORD)(CHARCOUNT(szAppHelpURL) - nChURL);
        nch = _snwprintf(szAppHelpURL + nChURL, cch, L"&offline=");
        nChURL += nch;

        cch = (DWORD)(CHARCOUNT(szAppHelpURL) - nChURL);

        if (!SdbEscapeApphelpURL(szAppHelpURL+nChURL, &cch, szChmURL)) {
            DBGPRINT((sdlError,  "ShowApphelpHtmlHelp", "Error escaping URL \"%S\"\n", szChmURL));
            goto errHandle;
        }

        nChURL += (int)cch;

        *(szAppHelpURL + nChURL) = L'\0';

    }

    //
    // WARNING: On Whistler execution of the following line will cause
    //          an AV (it works properly on Win2k) when it's executed twice
    //          from the same process. We should be able to just call
    //          shell with szAppHelpURL but we can't.
    //          So for now, use hh.exe as the stub.
    //
    // right before we do ShellExecute -- set current directory to windows dir
    //

    SetCurrentDirectoryW(szWindowsDir);
    if (g_bUseHtmlHelp && !bCustom) {
        DBGPRINT((sdlInfo,  "ShowApphelpHtmlHelp", "Opening Apphelp URL \"%S\"\n", szChmURL));
        hInst = ShellExecuteW(hDlg, L"open", L"hh.exe", szChmURL, NULL, SW_SHOWNORMAL);
    } else if (!bCustom) {

        WCHAR szHSCPath[MAX_PATH];
        WCHAR* pszParameters;
        size_t  cchUrl = ARRAYSIZE(szAppHelpURL);
        static WCHAR szUrlPrefix[] = L"-url ";

        nch = _snwprintf(szHSCPath, CHARCOUNT(szHSCPath),
                         L"%s\\pchealth\\helpctr\\binaries\\helpctr.exe",
                         szWindowsDir);

        if (nch < 0) {
            DBGPRINT((sdlError, "ShowApphelpHtmlHelp", "Windows path to helpctr too long %S\n", szWindowsDir));
            goto errHandle;
        }

        cchUrl = CHARCOUNT(szUrlPrefix) + wcslen(szAppHelpURL) + 1;
        pszParameters = new WCHAR[cchUrl];
        if (pszParameters == NULL) {
            bSuccess = FALSE;
            goto errHandle;
        }

        wcscpy(pszParameters, szUrlPrefix);
        wcscat(pszParameters, szAppHelpURL);

        DBGPRINT((sdlInfo,
                  "ShowApphelpHtmlHelp",
                  "Opening APPHELP URL \"%S\"\n",
                  szAppHelpURL));


        hInst = ShellExecuteW(hDlg, L"open", szHSCPath, pszParameters, NULL, SW_SHOWNORMAL);

        delete[] pszParameters;

    } else {

        DBGPRINT((sdlInfo,
                  "ShowApphelpHtmlHelp",
                  "Opening Custom APPHELP URL \"%S\"\n",
                  szAppHelpURL));

        hInst = ShellExecuteW(hDlg, L"open", szAppHelpURL, NULL, NULL, SW_SHOWNORMAL);
    }

    if (HandleToUlong(hInst) <= 32) {
        DBGPRINT((sdlError,
                  "ShowApphelpHtmlHelp",
                  "Error 0x%p trying to show help topic \"%ls\"\n",
                  hInst,
                  szAppHelpURL));
    }

    //
    // If we unload html help now we'll get weird and unpredictable behavior!
    // So don't do it :-(
    //
    bSuccess = (HandleToUlong(hInst) > 32);

errHandle:
    if (lpwszUnescaped != NULL) {
        free(lpwszUnescaped);
    }

    return bSuccess;

}


INT_PTR
AppCompatDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
/*++
    Return: void.

    Desc:   This is the dialog proc for the apphelp dialog.
--*/
{
    BOOL            bReturn = TRUE;
    PAPPHELP_DATA   pApphelpData;

    pApphelpData = (PAPPHELP_DATA)GetWindowLongPtrW(hDlg, DWLP_USER);

    switch (uMsg) {
    case WM_INITDIALOG:
        {
            WCHAR    wszMessage[2048];
            DWORD    dwResActionString;
            HFONT    hFont;
            LOGFONTW LogFont;
            WCHAR*   pwszAppTitle;
            INT      nChars;
            DWORD    dwDefID = IDD_DETAILS;
            DWORD    dwDefBtn; // old default button id
            HICON    hIcon;
            LPWSTR   IconID = MAKEINTRESOURCEW(IDI_WARNING);

            pApphelpData = (PAPPHELP_DATA)lParam;
            SetWindowLongPtrW(hDlg, DWLP_USER, (LONG_PTR)pApphelpData);

            //
            // Show the app icon.
            //
            hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDD_ICON_TRASH));

            SetClassLongPtr(hDlg, GCLP_HICON, (LONG_PTR)hIcon);

            mouse_event(MOUSEEVENTF_WHEEL, 0, 0, 0, 0);
            SetForegroundWindow(hDlg);

            pwszAppTitle = pApphelpData->szAppTitle;

            if (pwszAppTitle == NULL) {
                pwszAppTitle = pApphelpData->szAppName;
            }

            if (pwszAppTitle != NULL) {

                SetDlgItemTextW(hDlg, IDD_APPNAME, pwszAppTitle);
                //
                // Make sure that we only utilize the first line of that text
                // for the window title.
                //
                SetWindowTextW(hDlg, pwszAppTitle);
            }

            hFont = (HFONT)SendDlgItemMessageW(hDlg,
                                               IDD_APPNAME,
                                               WM_GETFONT,
                                               0, 0);

            if (hFont && GetObjectW(hFont, sizeof(LogFont), (LPVOID)&LogFont)) {

                LogFont.lfWeight = FW_BOLD;

                hFont = CreateFontIndirectW(&LogFont);

                if (hFont != NULL) {
                    g_hFontBold = hFont;
                    SendDlgItemMessageW(hDlg,
                                        IDD_APPNAME,
                                        WM_SETFONT,
                                        (WPARAM)hFont, TRUE);
                }
            }

            //
            // By default, we have both RUN AND CANCEL
            //
            dwResActionString = IDS_APPCOMPAT_RUNCANCEL;

            switch (pApphelpData->dwSeverity) {

            case APPHELP_HARDBLOCK:
                //
                // Disable run button and "don't show this again" box
                // Reset the "defpushbutton" style from this one...
                //
                EnableWindow(GetDlgItem(hDlg, IDD_STATE), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
                dwResActionString = IDS_APPCOMPAT_CANCEL;
                dwDefID = IDD_DETAILS;  // set for hardblock case since RUN is not avail
                IconID = MAKEINTRESOURCEW(IDI_ERROR);
                break;

            case APPHELP_MINORPROBLEM:
                break;

            case APPHELP_NOBLOCK:
                break;

            case APPHELP_REINSTALL:
                break;
            }

            //
            // if we have no URL, or the URL begins with "null" gray out the "details" button
            //
            if (!pApphelpData->szURL || !pApphelpData->szURL[0] ||
                _wcsnicmp(pApphelpData->szURL, L"null", 4) == 0) {

                EnableWindow(GetDlgItem(hDlg, IDD_DETAILS), FALSE);
            }


            hIcon = LoadIconW(NULL, IconID);

            if (hIcon != NULL) {
                SendDlgItemMessageW(hDlg, IDD_ICON, STM_SETICON, (WPARAM)hIcon, 0);
            }

            //
            // Set the default push button
            // Reset the current default push button to a regular button.
            //
            // Update the default push button's control ID.
            //
            dwDefBtn = (DWORD)SendMessageW(hDlg, DM_GETDEFID, 0, 0);

            if (HIWORD(dwDefBtn) == DC_HASDEFID) {
                dwDefBtn = LOWORD(dwDefBtn);
                SendDlgItemMessageW(hDlg, dwDefBtn,  BM_SETSTYLE, BS_PUSHBUTTON, TRUE);
            }

            SendDlgItemMessageW(hDlg, dwDefID, BM_SETSTYLE, BS_DEFPUSHBUTTON, TRUE);
            SendMessageW(hDlg, DM_SETDEFID, (WPARAM)dwDefID, 0);

            //
            // now set the focus
            // be careful and do not mess with other focus-related messages, else use PostMessage here
            //
            SendMessageW(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, dwDefID), TRUE);

            //
            // If dwHTMLHelpID is not present disable "Details" button
            //
            if (!pApphelpData->dwHTMLHelpID) {
                EnableWindow(GetDlgItem(hDlg, IDD_DETAILS), FALSE);
            }

            wszMessage[0] = L'\0';

            LoadStringW(g_hInstance,
                        dwResActionString,
                        wszMessage,
                        sizeof(wszMessage) / sizeof(WCHAR));

            SetDlgItemTextW(hDlg, IDD_LINE_2, wszMessage);

            SetDlgItemTextW(hDlg,
                            IDD_APPHELP_DETAILS,
                            pApphelpData->szDetails ? pApphelpData->szDetails : L"");

            FixEditControlScrollBar(hDlg, IDD_APPHELP_DETAILS);

            //
            // Return false so that the default focus-setting would not apply.
            //
            bReturn = FALSE;
            break;
        }

    case WM_DESTROY:
        //
        // perform cleanup - remove the font we've had created
        //
        if (g_hFontBold != NULL) {
            DeleteObject(g_hFontBold);
            g_hFontBold = NULL;
        }

        AllowForegroundActivation();

        PostQuitMessage(0); // we just bailed out
        break;



    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDOK:
            //
            // Check the NO UI checkbox
            //
            EndDialog(hDlg, (INT_PTR)(IsDlgButtonChecked(hDlg, IDD_STATE) ? (IDOK | 0x8000) : IDOK));
            break;

        case IDCANCEL:
            EndDialog(hDlg, (INT_PTR)(IsDlgButtonChecked(hDlg, IDD_STATE) && g_bPreserveChoice ? (IDCANCEL | 0x8000) : IDCANCEL));
            break;

        case IDD_DETAILS:
            //
            // Launch details.
            //
            ShowApphelpHtmlHelp(hDlg, pApphelpData);
            break;

        default:
            bReturn = FALSE;
            break;
        }
        break;

    default:
        bReturn = FALSE;
        break;
    }

    return bReturn;
}


typedef NTSTATUS (NTAPI *PFNUSERTESTTOKENFORINTERACTIVE)(HANDLE Token, PLUID pluidCaller);
PFNUSERTESTTOKENFORINTERACTIVE UserTestTokenForInteractive = NULL;

BOOL
CheckUserToken(
    )
/*++
    returns TRUE if the apphelp should be shown
            FALSE if we should not present apphelp UI
--*/
{
    NTSTATUS Status;
    HANDLE   hToken  = NULL;
    LUID     LuidUser;
    HMODULE  hWinsrv = NULL;
    BOOL     bShowUI = FALSE;
    UINT     nChars;
    static
    WCHAR    szWinsrvDllName[] = L"winsrv.dll";
    WCHAR    szSystemDir[MAX_PATH];
    WCHAR    szWinsrvDll[MAX_PATH];
    BOOL     bWow64 = FALSE;

    if (IsWow64Process(GetCurrentProcess(), &bWow64)) {
        if (bWow64) {
            return TRUE;
        }
    }

    nChars = GetSystemDirectoryW(szSystemDir,
                                 CHARCOUNT(szSystemDir));
    if (nChars == 0 || nChars > CHARCOUNT(szSystemDir) - 1 - CHARCOUNT(szWinsrvDllName)) {
        DBGPRINT((sdlError, "CheckUserToken",
                  "Error trying to retrieve windows system dir %d\n", GetLastError()));
        *szSystemDir = L'\0';
        nChars = 0;
    } else {
        //
        // safe, we have counted the winsrv.dll (which includes 0-terminator),
        // 1 = '\\' character
        // and szSystemDir
        //
        szSystemDir[nChars++] = L'\\';
        szSystemDir[nChars]   = L'\0';
    }

    //
    // extra check just to be safe, nChars includes now '\\'
    //
    if (nChars + CHARCOUNT(szWinsrvDllName) > CHARCOUNT(szWinsrvDll)) {
        goto ErrHandle;
    }

    wcscpy(szWinsrvDll, szSystemDir);
    wcscat(szWinsrvDll, szWinsrvDllName);

    hWinsrv = LoadLibraryW(szWinsrvDll);
    if (hWinsrv == NULL) {
        goto ErrHandle;
    }

    UserTestTokenForInteractive = (PFNUSERTESTTOKENFORINTERACTIVE)GetProcAddress(hWinsrv,
                                                                                 "_UserTestTokenForInteractive");
    if (UserTestTokenForInteractive == NULL) {
        goto ErrHandle;
    }


    Status = NtOpenProcessToken(NtCurrentProcess(),
                                TOKEN_QUERY,
                                &hToken);
    if (NT_SUCCESS(Status)) {

        Status = UserTestTokenForInteractive(hToken, &LuidUser);

        NtClose(hToken);

        if (NT_SUCCESS(Status)) {
            bShowUI = TRUE;
            goto ErrHandle;
        }

    }

    Status = NtOpenThreadToken(NtCurrentThread(),
                               TOKEN_QUERY,
                               TRUE,
                               &hToken);

    if (NT_SUCCESS(Status)) {

        Status = UserTestTokenForInteractive(hToken, &LuidUser);

        NtClose(hToken);

        if (NT_SUCCESS(Status)) {
            bShowUI = TRUE;
            goto ErrHandle;
        }
    }

ErrHandle:

    if (hWinsrv) {
        FreeLibrary(hWinsrv);
    }

    return bShowUI;

}

BOOL
CheckWindowStation(
    )
/*++
    returns TRUE if the apphelp should be shown
            FALSE if we should not bother with apphelp UI


--*/

{
    HWINSTA hWindowStation;
    BOOL  bShowUI      = FALSE;
    DWORD dwLength     = 0;
    DWORD dwBufferSize = 0;
    DWORD dwError;
    BOOL  bSuccess;
    LPWSTR pwszWindowStation = NULL;

    hWindowStation = GetProcessWindowStation();
    if (hWindowStation == NULL) {
        DBGPRINT((sdlError,
                  "ApphelpCheckWindowStation",
                  "GetProcessWindowStation failed error 0x%lx\n", GetLastError()));
        goto ErrHandle;  // the app is not a Windows NT/Windows 2000 app??? try to show UI
    }

    // get the information please
    bSuccess = GetUserObjectInformationW(hWindowStation, UOI_NAME, NULL, 0, &dwBufferSize);
    if (!bSuccess) {
        dwError = GetLastError();
        if (dwError != ERROR_INSUFFICIENT_BUFFER) {
            DBGPRINT((sdlError,
                      "ApphelpCheckWindowStation",
                      "GetUserObjectInformation failed error 0x%lx\n", dwError));
            goto ErrHandle;
        }

        pwszWindowStation = (LPWSTR)malloc(dwBufferSize);
        if (pwszWindowStation == NULL) {
            DBGPRINT((sdlError,
                      "ApphelpCheckWindowStation",
                      "Failed to allocate 0x%lx bytes for Window Station name\n", dwBufferSize));
            goto ErrHandle;
        }

        // ok, call again
        bSuccess = GetUserObjectInformationW(hWindowStation,
                                             UOI_NAME,
                                             pwszWindowStation,
                                             dwBufferSize,
                                             &dwLength);
        if (!bSuccess) {
            DBGPRINT((sdlError,
                      "ApphelpCheckWindowStation",
                      "GetUserObjectInformation failed error 0x%lx, buffer size 0x%lx returned 0x%lx\n",
                      GetLastError(), dwBufferSize, dwLength));
            goto ErrHandle;
        }

        // now we have window station name, compare it to winsta0
        //
        bShowUI = (_wcsicmp(pwszWindowStation, L"Winsta0") == 0);

        if (!bShowUI) {
            DBGPRINT((sdlInfo,
                      "ApphelpCheckWindowStation",
                      "Apphelp UI will not be shown, running this process on window station \"%s\"\n",
                      pwszWindowStation));
        }
    }

ErrHandle:

    // should we do a close handle ???
    //
    if (hWindowStation != NULL) {
        CloseWindowStation(hWindowStation);
    }

    if (pwszWindowStation != NULL) {
        free(pwszWindowStation);
    }

    return bShowUI;

}

DWORD
ShowApphelpDialog(
    IN  PAPPHELP_DATA pApphelpData
    )
/*++
    Return: (IDOK | IDCANCEL) | [0x8000]
                IDOK | 0x8000 - the user has chosen to run the app and
                                checked "don't show me this anymore"
                IDOK          - the user has chosen to run the app, dialog will be shown again
                IDCANCEL      - the user has chosen not to run the app
                -1            - we have failed to import APIs necessary to show dlg box

    Desc:   Shows the dialog box with apphelp info.
--*/
{
    BOOL    bSuccess;
    INT_PTR retVal = 0;

    retVal = DialogBoxParamW(g_hInstance,
                             MAKEINTRESOURCEW(DLG_APPCOMPAT),
                             NULL,
                             (DLGPROC)AppCompatDlgProc,
                             (LPARAM)pApphelpData); // parameter happens to be a pointer of type PAPPHELP_DATA

    return (DWORD)retVal;
}


VOID
ParseCommandLineArgs(
    int argc,
    WCHAR* argv[]
    )
{
    WCHAR ch;
    WCHAR* pArg;
    WCHAR* pEnd;

    while (--argc) {
        pArg = argv[argc];
        if (*pArg == L'/' || *pArg == '-') {
            ch = *++pArg;
            switch(towupper(ch)) {
            case L'H':
                if (!_wcsnicmp(pArg, wszHtmlHelpID, CHARCOUNT(wszHtmlHelpID)-1)) {
                    pArg = wcschr(pArg, L':');
                    if (pArg) {
                        ++pArg; // skip over :
                        g_dwHtmlHelpID = (DWORD)wcstoul(pArg, &pEnd, 0);
                    }
                }
                break;
            case L'A':
                if (!_wcsnicmp(pArg, wszAppName, CHARCOUNT(wszAppName)-1)) {
                    pArg = wcschr(pArg, L':');
                    if (pArg) {
                        ++pArg;
                        g_pAppName = pArg; // this is app name, remove the quotes

                    }
                }
                break;
            case L'S':
                if (!_wcsnicmp(pArg, wszSeverity, CHARCOUNT(wszSeverity)-1)) {
                    pArg = wcschr(pArg, L':');
                    if (pArg) {
                        ++pArg;
                        g_dwSeverity = (DWORD)wcstoul(pArg, &pEnd, 0);
                    }
                }
                break;
            case L'T':
                if (!_wcsnicmp(pArg, wszTagID, CHARCOUNT(wszTagID)-1)) {
                    pArg = wcschr(pArg, L':');
                    if (pArg) {
                        ++pArg;
                        g_dwTagID = (DWORD)wcstoul(pArg, &pEnd, 0);
                    }
                }
                break;
            case L'G':
                if (!_wcsnicmp(pArg, wszGUID, CHARCOUNT(wszGUID)-1)) {
                    if ((pArg = wcschr(pArg, L':')) != NULL) {
                        ++pArg;
                        g_pszGuid = pArg;
                    }
                }
                break;
            case L'O':
                if (!_wcsnicmp(pArg, wszOfflineContent, CHARCOUNT(wszOfflineContent)-1)) {
                    g_bShowOnlyOfflineContent = TRUE;
                }
                break;
            case L'P':
                if (!_wcsnicmp(pArg, wszPreserveChoice, CHARCOUNT(wszPreserveChoice)-1)) {
                    g_bPreserveChoice = TRUE;
                }
                break;

            default:

                // unrecognized switch
                DBGPRINT((sdlError, "ParseCommandLineArgs",
                          "Unrecognized parameter %s\n", pArg));
                break;
            }
        } else {
            // not a switch
            if (*pArg == L'{') {
                g_pszGuid = pArg;
            } else {

                g_dwTagID = (DWORD)wcstoul(pArg, &pEnd, 0);

            }

        }
    }
}

INT_PTR
FeedbackDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
/*++
    Return: void.

    Desc:   This is the dialog proc for the apphelp dialog.
--*/
{
    BOOL   bReturn = TRUE;
    LPWSTR lpszExeName;

    lpszExeName = (LPWSTR)GetWindowLongPtrW(hDlg, DWLP_USER);

    switch (uMsg) {
    case WM_INITDIALOG:
        {
            HICON hIcon;

            lpszExeName = (LPWSTR)lParam;
            SetWindowLongPtrW(hDlg, DWLP_USER, (LONG_PTR)lpszExeName);

            //
            // Show the app icon.
            //
            hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDD_ICON_TRASH));

            SetClassLongPtr(hDlg, GCLP_HICON, (LONG_PTR)hIcon);

            SendDlgItemMessage(hDlg, IDC_WORKED, BM_SETCHECK, BST_CHECKED, 0);

        }
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDOK:
            EndDialog(hDlg, IDOK);
            break;

        case IDCANCEL:
            EndDialog(hDlg, IDCANCEL);
            break;

        default:
            bReturn = FALSE;
            break;
        }
        break;

    default:
        bReturn = FALSE;
        break;
    }

    return bReturn;
}

void
ShowFeedbackDialog(
    LPWSTR lpszAppName
    )
{
    DialogBoxParamW(g_hInstance,
                    MAKEINTRESOURCEW(DLG_FEEDBACK),
                    NULL,
                    (DLGPROC)FeedbackDlgProc,
                    (LPARAM)lpszAppName);
}

extern "C" int APIENTRY
wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR    lpCmdLine,
    int       nCmdShow
    )
/*++
    Return: 1 if the app for which the apphelp is shown should run, 0 otherwise.

    Desc:   The command line looks like this:

            apphelp.exe GUID tagID [USELOCALCHM USEHTMLHELP APPHELPPATH]

            Ex:
                apphelp.exe {243B08D7-8CF7-4072-AF64-FD5DF4085E26} 0x0000009E

                apphelp.exe {243B08D7-8CF7-4072-AF64-FD5DF4085E26} 0x0000009E 1 1 c:\temp
--*/
{
    int             nReturn = 1;  // we always default to running, if something goes wrong
    LPWSTR          szCommandLine;
    LPWSTR*         argv;
    int             argc;
    UNICODE_STRING  ustrGuid;
    GUID            guidDB    = { 0 };
    GUID            guidExeID = { 0 };
    TAGID           tiExe = TAGID_NULL;
    TAGID           tiExeID = TAGID_NULL;
    TAGREF          trExe = TAGREF_NULL;
    WCHAR           wszDBPath[MAX_PATH];
    DWORD           dwType = 0;
    APPHELP_DATA    ApphelpData;
    WCHAR           szDBPath[MAX_PATH];
    HSDB            hSDB = NULL;
    PDB             pdb = NULL;
    DWORD           dwFlags = 0;
    BOOL            bAppHelp = FALSE;
    BOOL            bRunApp = FALSE;

    g_hInstance = hInstance;

    InitCommonControls();
    ZeroMemory(&ApphelpData, sizeof(ApphelpData));

    //
    // Note that this memory isn't freed because it will automatically
    // be freed on exit anyway, and there are a lot of exit cases from
    // this application.
    //
    szCommandLine = GetCommandLineW();
    argv = CommandLineToArgvW(szCommandLine, &argc);

    ParseCommandLineArgs(argc, argv);

    if (argc > 1) {
        if (_wcsicmp(L"feedback", argv[1]) == 0) {
            ShowFeedbackDialog(argc > 2 ? argv[2] : NULL);
        }
    }

    if (g_pszGuid == NULL) {
        DBGPRINT((sdlError, "AHUI!wWinMain",
                  "GUID not provided\n"));
        goto out;
    }

    if (!(g_dwTagID ^ g_dwHtmlHelpID)) {
        DBGPRINT((sdlError, "AHUI!wWinMain",
                   "Only TagID or HtmlHelpID should be provided\n"));
        goto out;
    }

    RtlInitUnicodeString(&ustrGuid, g_pszGuid);

    if (g_dwHtmlHelpID) {
        //
        // provided here: guid, severity and html help id along with app name
        //

        if (!NT_SUCCESS(RtlGUIDFromString(&ustrGuid, &guidExeID))) {
            DBGPRINT((sdlError,
                       "Ahui!wWinMain",
                       "Error getting GUID from string %s\n", g_pszGuid));
            goto out;
        }
        ApphelpData.dwSeverity   = g_dwSeverity;
        ApphelpData.dwHTMLHelpID = g_dwHtmlHelpID;
        ApphelpData.szAppName    = (LPWSTR)g_pAppName;
        bAppHelp = TRUE;
        dwType   = SDB_DATABASE_MAIN_SHIM;
        goto ProceedWithApphelp;
    }

    // non-htmlid case, guid is a database guid
    // also dwTagID is specified

    if (RtlGUIDFromString(&ustrGuid, &guidDB) != STATUS_SUCCESS) {
        DBGPRINT((sdlError,
                  "AppHelp.exe!wWinMain",
                  "Error trying to convert GUID string %S.\n",
                  g_pszGuid));
        goto out;
    }

    tiExe = (TAGID)g_dwTagID;

    if (tiExe == TAGID_NULL) {
        DBGPRINT((sdlError,
                  "AppHelp.exe!wWinMain",
                  "Error getting TAGID from param %S\n",
                  argv[2]));
        goto out;
    }

    hSDB = SdbInitDatabase(0, NULL);

    if (!hSDB) {
        DBGPRINT((sdlError,
                  "AppHelp.exe!wWinMain",
                  "Error initing database context.\n"));
        goto out;
    }

    pdb = SdbGetPDBFromGUID(hSDB, &guidDB);

    if (!pdb) {
        DWORD dwLen;

        //
        // It's not one of the main DBs, try it as a local.
        //
        dwLen = SdbResolveDatabase(&guidDB, &dwType, szDBPath, MAX_PATH);

        if (!dwLen || dwLen > MAX_PATH) {
            DBGPRINT((sdlError,
                      "AppHelp.exe!wWinMain",
                      "Error resolving database from GUID\n"));
            goto out;
        }

        //
        // We have many "main" databases -- we should limit the check
        //

        if (dwType != SDB_DATABASE_MAIN_SHIM && dwType != SDB_DATABASE_MAIN_TEST) {
            SdbOpenLocalDatabase(hSDB, szDBPath);
        }

        pdb = SdbGetPDBFromGUID(hSDB, &guidDB);
        if (!pdb) {
            DBGPRINT((sdlError,
                      "AppHelp.exe!wWinMain",
                      "Error getting pdb from GUID.\n"));
            goto out;
        }
    } else {

        dwType |= SDB_DATABASE_MAIN; // we will use details from the main db

    }

    if (!SdbTagIDToTagRef(hSDB, pdb, tiExe, &trExe)) {
        DBGPRINT((sdlError,
                  "AppHelp.exe!wWinMain",
                  "Error converting TAGID to TAGREF.\n"));
        goto out;
    }

    tiExeID = SdbFindFirstTag(pdb, tiExe, TAG_EXE_ID);

    if (tiExeID == TAGID_NULL) {
        DBGPRINT((sdlError,
                  "AppHelp.exe!wWinMain",
                  "Error trying to find TAG_EXE_ID.\n"));
        goto out;
    }

    if (!SdbReadBinaryTag(pdb,
                          tiExeID,
                          (PBYTE)&guidExeID,
                          sizeof(GUID))) {
        DBGPRINT((sdlError,
                  "AppHelp.exe!wWinMain",
                  "Error trying to read TAG_EXE_ID.\n"));
        goto out;
    }


    bAppHelp = SdbReadApphelpData(hSDB, trExe, &ApphelpData);

ProceedWithApphelp:
    if (SdbIsNullGUID(&guidExeID) || !SdbGetEntryFlags(&guidExeID, &dwFlags)) {
        dwFlags = 0;
    }

    if (bAppHelp) {

        //
        // Check whether the disable bit is set.
        //
        if (!(dwFlags & SHIMREG_DISABLE_APPHELP)) {

            BOOL bNoUI;

            //
            // See whether the user has checked "Don't show this anymore" box before.
            //
            bNoUI = ((dwFlags & SHIMREG_APPHELP_NOUI) != 0);

            if (!bNoUI) {
                //
                // checkwindowstation returns true when UI should be shown
                //
                bNoUI = !CheckWindowStation();
            }
            if (!bNoUI) {
                bNoUI = !CheckUserToken();
            }


            if (bNoUI) {
                DBGPRINT((sdlInfo,
                          "bCheckRunBadapp",
                          "NoUI flag is set, apphelp UI disabled for this app.\n"));
            }

            //
            // depending on severity of the problem...
            //
            switch (ApphelpData.dwSeverity) {
            case APPHELP_MINORPROBLEM:
            case APPHELP_HARDBLOCK:
            case APPHELP_NOBLOCK:
            case APPHELP_REINSTALL:
                if (bNoUI) {

                    bRunApp = (ApphelpData.dwSeverity != APPHELP_HARDBLOCK) && !(dwFlags & SHIMREG_APPHELP_CANCEL);

                } else {
                    DWORD dwRet;

                    //
                    // Show the UI. This function returns -1 in case of error or one
                    // of the following values on success:
                    //    IDOK | 0x8000 - "no ui" checked, run app
                    //    IDCANCEL      - do not run app
                    //    IDOK          - run app

                    ApphelpData.dwData = dwType;  // we use custom data for database type

                    dwRet = ShowApphelp(&ApphelpData,
                                        NULL,
                                        (dwType & SDB_DATABASE_MAIN) ? NULL : SdbGetLocalPDB(hSDB));

                    if (dwRet != APPHELP_DIALOG_FAILED) {
                        //
                        // The UI was shown. See whether the user has
                        // checked the "no ui" box.
                        //

                        if (dwRet & 0x8000) {
                            //
                            // "no ui" box was checked. Save the appropriate bits
                            // in the registry.
                            //
                            dwFlags |= SHIMREG_APPHELP_NOUI;

                            if ((dwRet & 0x0FFF) != IDOK) {
                                dwFlags |= SHIMREG_APPHELP_CANCEL; // we will not be hitting this path unless g_bPreserveChoice is enabled
                            }

                            if (!SdbIsNullGUID(&guidExeID)) {
                                SdbSetEntryFlags(&guidExeID, dwFlags);
                            }
                        }
                        //
                        // Check whether the user has chosen to run the app.
                        //
                        bRunApp = ((dwRet & 0x0FFF) == IDOK);
                    } else {
                        //
                        // The UI was not shown (some error prevented that).
                        // If the app is not "Hardblock" run it anyway.
                        //
                        bRunApp = (APPHELP_HARDBLOCK != ApphelpData.dwSeverity);
                    }
                }
                break;
            }

        }
    }

    if (!bRunApp) {
        nReturn = 0;
    }

out:

    return nReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\apphelp\apphelp.h ===
#ifndef __APPHELP_LIB_H
#define __APPHELP_LIB_H

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <memory.h>
#include <malloc.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "shimdb.h"



#if DBG // make sure that apphelp_tools is defined when compiling checked
    #ifndef APPHELP_TOOLS
    #define APPHELP_TOOLS
    #endif
#endif


//
// Routines in ahcache.c
//

BOOL
BaseUpdateAppcompatCache(
    LPCWSTR pwszPath,
    HANDLE  hFile,
    BOOL    bRemove
    );

BOOL
BaseFlushAppcompatCache(
    VOID
    );

BOOL
BaseCheckAppcompatCache(
    LPCWSTR pwszPath,
    HANDLE  hFile,
    PVOID   pEnvironment,
    DWORD*  dwReason
    );
VOID
BaseDumpAppcompatCache(
    VOID
    );

//
// Apphelp api to update the cache
//
//

BOOL
WINAPI
ApphelpUpdateCacheEntry(
    LPCWSTR pwszPath,           // nt path or dos path (see bNTPath)
    HANDLE  hFile,              // file handle (or INVALID_HANDLE_VALUE if not needed)
    BOOL    bDeleteEntry,       // TRUE if we are to delete the entry
    BOOL    bNTPath             // if TRUE -- NT path, FALSE - dos path
    );

//
// Reasons:
//

#define SHIM_CACHE_NOT_FOUND 0x00000001
#define SHIM_CACHE_BYPASS    0x00000002 // bypass cache (either removable media or temp dir)
#define SHIM_CACHE_LAYER_ENV 0x00000004 // layer env variable set
#define SHIM_CACHE_MEDIA     0x00000008
#define SHIM_CACHE_TEMP      0x00000010
#define SHIM_CACHE_NOTAVAIL  0x00000020


//
// Routines in check.c
//

INT_PTR CALLBACK
AppCompatDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    );

DWORD
ShowApphelpDialog(
    PAPPHELP_DATA pApphelpData
    );


// in apphelppath.c

BOOL
ConvertToDosPath(
    OUT LPWSTR*  ppDosPath,
    IN  LPCWSTR  pwszPath
    );

BOOL
CheckStringPrefixUnicode(
   PUNICODE_STRING pStrPrefix,
   PUNICODE_STRING pString,
   BOOL CaseInSensitive);

// this function is used to free the dos path
// it checks whether the path was allocated or
// the static buffer was used
VOID
FreeDosPath(WCHAR* pDosPath);

//
// in matchApphelp.c
//


BOOL
GetExeSxsData(
    HSDB   hSDB,
    TAGREF trExe,
    PVOID* ppSxsData,
    DWORD* pcbSxsData
    );


//
// in apphelpcache.c
//

VOID ShimUpdateCache(LPCWSTR pwszPath, PSDBQUERYRESULT psdbQuery);
VOID ShimCacheProcessCleanup(VOID);
VOID ShimCacheThreadCleanup(VOID);
BOOL ShimCacheProcessInit(VOID);
VOID ShimInitCache(PVOID pCache);
VOID ShimRemoveExeFromCache(LPCWSTR pwszPath);

BOOL
LookupCache(
    LPCWSTR         pwszPath,
    PSDBQUERYRESULT psdbQuery
    );

BOOL
BypassCache(
    LPCWSTR pwszPath,
    WCHAR*  pEnvironment,
    BOOL*   pbLayer
    );

//
// in apphelpcheck.c
//
//

DWORD
ShowApphelp(
    IN OUT PAPPHELP_DATA pApphelpData,
    IN     LPCWSTR       pwszDetailsDatabasePath,
    IN     PDB           pdbDetails
    );

//
// same is in shell/published and also the same as used in shimdbc
//
#define APPTYPE_TYPE_MASK     0x000000FF

#define APPTYPE_INC_NOBLOCK   0x00000001
#define APPTYPE_INC_HARDBLOCK 0x00000002
#define APPTYPE_MINORPROBLEM  0x00000003
#define APPTYPE_REINSTALL     0x00000004
#define APPTYPE_VERSIONSUB    0x00000005
#define APPTYPE_SHIM          0x00000006
#define APPTYPE_NONE          0x00000000

enum ShimAppHelpSeverityType
{
   APPHELP_MINORPROBLEM = APPTYPE_MINORPROBLEM,
   APPHELP_HARDBLOCK    = APPTYPE_INC_HARDBLOCK,
   APPHELP_NOBLOCK      = APPTYPE_INC_NOBLOCK,
   APPHELP_VERSIONSUB   = APPTYPE_VERSIONSUB,
   APPHELP_SHIM         = APPTYPE_SHIM,
   APPHELP_REINSTALL    = APPTYPE_REINSTALL,
   APPHELP_NONE         = APPTYPE_NONE
};

//
// SDBAPI internal functions that we use to obtain flags for ntvdm
//

BOOL
SDBAPI
SdbpPackCmdLineInfo(
    IN  PVOID   pvFlagInfoList,
    OUT PVOID*  ppFlagInfo
    );

BOOL
SDBAPI
SdbpFreeFlagInfoList(
    IN PVOID pvFlagInfoList
    );

//
// Alloc/free routines from dblib
//
extern void* SdbAlloc(size_t);
extern void  SdbFree(void*);

//
// Stack allocation routine
//
#ifndef STACK_ALLOC

//
//
// Exact same definition for stack-related routines is found in sdbp.h
//

VOID
SdbResetStackOverflow(
    VOID
    );

#if DBG | defined(_WIN64)

#define STACK_ALLOC(ptrVar, nSize) \
    {                                     \
        PVOID* ppVar = (PVOID*)&(ptrVar); \
        *ppVar = SdbAlloc(nSize);         \
    }

#define STACK_FREE(pMemory)  \
    SdbFree(pMemory)

#else // !DBG

//
// HACK ALERT
//
//  The code below works because when we hit a stack overflow - we catch the exception
//  and subsequently fix the stack up using a crt routine
//

//
// this routine lives in sdbapi, semi-private api
//


#define STACK_ALLOC(ptrVar, nSize) \
    __try {                                                                 \
        PVOID* ppVar = (PVOID*)&(ptrVar);                                   \
        *ppVar = _alloca(nSize);                                            \
    } __except (GetExceptionCode() == EXCEPTION_STACK_OVERFLOW ?            \
                EXCEPTION_EXECUTE_HANDLER:EXCEPTION_CONTINUE_SEARCH) {      \
        (ptrVar) = NULL;                                                    \
    }                                                                       \
                                                                            \
    if (ptrVar == NULL) {                                                   \
        SdbResetStackOverflow();                                            \
    }


#define STACK_FREE(pMemory)

#endif // DBG


#endif // !defined(STACK_ALLOC)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\apphelp\match.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        match.c

    Abstract:

        This module implements ...

    Author:

        vadimb     created     sometime in 2000

    Revision History:

        clupu      cleanup     12/27/2000
--*/

#include "apphelp.h"

// global Hinst
HINSTANCE ghInstance;


BOOL
DllMain(
    HANDLE hModule,
    DWORD  ul_reason,
    LPVOID lpReserved
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   apphelp.dll entry point.
--*/
{
    switch (ul_reason) {
    case DLL_PROCESS_ATTACH:
        ghInstance = hModule;
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}


BOOL
GetExeSxsData(
    IN  HSDB   hSDB,            // handle to the database channel
    IN  TAGREF trExe,           // tagref of an exe entry
    OUT PVOID* ppSxsData,       // pointer to the SXS data
    OUT DWORD* pcbSxsData       // pointer to the SXS data size
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Gets SXS (Fusion) data for the specified EXE from the database.
--*/
{
    TAGID  tiExe;
    TAGID  tiSxsManifest;
    PDB    pdb;
    WCHAR* pszManifest;
    DWORD  dwManifestLength; // in chars
    PVOID  pSxsData = NULL;

    if (!SdbTagRefToTagID(hSDB, trExe, &pdb, &tiExe)) {
        DBGPRINT((sdlError,
                  "GetExeSxsData",
                  "Failed to get the database the TAGREF 0x%x belongs to.\n",
                  trExe));
        return FALSE;
    }

    tiSxsManifest = SdbFindFirstTag(pdb, tiExe, TAG_SXS_MANIFEST);

    if (!tiSxsManifest) {
        DBGPRINT((sdlInfo,
                  "GetExeSxsData",
                  "No SXS data for TAGREF 0x%x.\n",
                  trExe));
        return FALSE;
    }

    pszManifest = SdbGetStringTagPtr(pdb, tiSxsManifest);
    if (pszManifest == NULL) {
        DBGPRINT((sdlError,
                  "GetExeSxsData",
                  "Failed to get manifest string tagid 0x%lx\n",
                  tiSxsManifest));
        return FALSE;
    }

    dwManifestLength = wcslen(pszManifest);

    //
    // check if this is just a query for existance of the data tag
    //
    if (ppSxsData == NULL) {
        if (pcbSxsData != NULL) {
            *pcbSxsData = dwManifestLength * sizeof(WCHAR);
        }
        return TRUE;
    }

    //
    // Allocate the string and return it. NOTE: SXS.DLL cannot handle
    // a NULL terminator at the end of the string. We must provide the
    // string without the NULL terminator.
    //
    pSxsData = (PVOID)RtlAllocateHeap(RtlProcessHeap(),
                                      HEAP_ZERO_MEMORY,
                                      dwManifestLength * sizeof(WCHAR));
    if (pSxsData == NULL) {
        DBGPRINT((sdlError,
                  "GetExeSxsData",
                  "Failed to allocate %d bytes\n",
                  dwManifestLength * sizeof(WCHAR)));
        return FALSE;
    }

    RtlMoveMemory(pSxsData, pszManifest, dwManifestLength * sizeof(WCHAR));

    if (ppSxsData != NULL) {
        *ppSxsData = pSxsData;
    }

    if (pcbSxsData != NULL) {
        *pcbSxsData = dwManifestLength * sizeof(WCHAR);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\apphelp\persistlayers.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        persistLayers.c

    Abstract:

        This module implements routines to persist layer
        information for shortcuts.

    Author:

        dmunsil     created     sometime in 2000

    Revision History:


--*/

#include "apphelp.h"


BOOL
AllowPermLayer(
    IN  LPCWSTR  pwszPath       // path to the file to check whether you
                                // can set a permanent layer on
    )
/*++
    Return: TRUE if a permanent setting of a layer is allowed for the
            specified file, FALSE otherwise.

    Desc:   Returns wether a permanent layer setting can be persisted
            for the specified file.
--*/
{
    WCHAR wszDrive[5];
    UINT  unType;

    if (pwszPath == NULL) {
        DBGPRINT((sdlError, "AllowPermLayer", "Invalid argument\n"));
        return FALSE;
    }

    if (pwszPath[1] != L':' && pwszPath[1] != L'\\') {
        //
        // Not a path we recognize.
        //
        DBGPRINT((sdlInfo,
                  "AllowPermLayer",
                  "\"%S\" not a full path we can operate on.\n",
                  pwszPath));
        return FALSE;
    }

    if (pwszPath[1] == L'\\') {
        //
        // Network path. Not allowed.
        //
        DBGPRINT((sdlInfo,
                  "AllowPermLayer",
                  "\"%S\" is a network path.\n",
                  pwszPath));
        return FALSE;
    }

    wcscpy(wszDrive, L"c:\\");
    wszDrive[0] = pwszPath[0];

    unType = GetDriveTypeW(wszDrive);

    if (unType == DRIVE_REMOTE) {
        DBGPRINT((sdlInfo,
                  "AllowPermLayer",
                  "\"%S\" is on CDROM or other removable media.\n",
                  pwszPath));
        return FALSE;
    }

    return TRUE;
}

//
// Semi-exported api from SDBAPI (ntbase.c)
//
BOOL
SDBAPI
SdbpGetLongPathName(
    IN LPCWSTR pwszPath,
    OUT PRTL_UNICODE_STRING_BUFFER pBuffer
    );

BOOL 
SDBAPI
ApphelpUpdateCacheEntry(
    LPCWSTR pwszPath,           // nt path
    HANDLE  hFile,              // file handle 
    BOOL    bDeleteEntry,       // TRUE if we are to delete the entry
    BOOL    bNTPath             // if TRUE -- NT path, FALSE - dos path
    )
{
    RTL_UNICODE_STRING_BUFFER Path;
    UCHAR                     PathBuffer[MAX_PATH*2];
    BOOL                      TranslationStatus;
    BOOL                      bSuccess = FALSE;
    UNICODE_STRING            NtPath = { 0 };
    UNICODE_STRING            DosPath = { 0 };
    BOOL                      bFreeNtPath = FALSE;
    NTSTATUS                  Status;

    RtlInitUnicodeStringBuffer(&Path, PathBuffer, sizeof(PathBuffer));

    if (bNTPath) { // if this is NT Path name, convert to dos

        RtlInitUnicodeString(&NtPath, pwszPath);
        
        Status = RtlAssignUnicodeStringBuffer(&Path, &NtPath); // NT path
        if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlError, "ApphelpUpdateCacheEntry", "Failed to allocate temp buffer for %s\n", pwszPath));    
            goto Cleanup;
        }
        
        Status = RtlNtPathNameToDosPathName(0, &Path, NULL, NULL);
        if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlError, "ApphelpUpdateCacheEntry", 
                      "Failed to convert Path \"%s\" to dos path status 0x%lx\n", pwszPath, Status));    
            goto Cleanup;
        }

        Status = RtlDuplicateUnicodeString(RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE, &Path.String, &DosPath);
        if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlError, "ApphelpUpdateCacheEntry", 
                      "Failed to Duplicate Path \"%s\" status 0x%lx\n", Path.String.Buffer, Status));    
            goto Cleanup;
        }
            
        pwszPath = DosPath.Buffer;
    } 

    // 
    // at this point we have both NT and DOS path - buffer is available to us now
    // 
    
    if (!SdbpGetLongPathName(pwszPath, &Path)) { // in - DosPath // out -- Long DOS Path
        goto Cleanup;
    }

    //
    // convert long path name to NT Path name
    //
    TranslationStatus = RtlDosPathNameToNtPathName_U(Path.String.Buffer,
                                                     &NtPath,
                                                     NULL,
                                                     NULL);
    if (!TranslationStatus) {
         DBGPRINT((sdlError, "ApphelpUpdateCacheEntry", 
                   "Failed to Convert Path \"%s\" to NT path\n", Path.String.Buffer));    
         goto Cleanup;
    }
    //
    // update the cache (use NT Path here)
    //
    bSuccess = BaseUpdateAppcompatCache(NtPath.Buffer, hFile, bDeleteEntry);
    
    //
    // we only free this string when we successfully navigated through RtlDosPathNameToNtPathName_U
    //
    RtlFreeUnicodeString(&NtPath); 
    
    
Cleanup:

    if (bNTPath) { 
        //
        // Free DosPath if we had to convert from NT Path to DosPath first
        //
        RtlFreeUnicodeString(&DosPath);        
    }
    
    RtlFreeUnicodeStringBuffer(&Path);

    return bSuccess;

}

BOOL
SetPermLayers(
    IN  LPCWSTR pwszPath,       // path to the file to set a permanent layer on (dos path)
    IN  LPCWSTR pwszLayers,     // layers to apply to the file, separated by spaces
    IN  BOOL    bMachine        // TRUE if the layers should be persisted per machine
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Sets a permanent layer setting for the specified file.
--*/
{
    BOOL bSuccess = FALSE;
    
    if (pwszPath == NULL || pwszLayers == NULL) {
        DBGPRINT((sdlError, "SetPermLayers", "Invalid argument\n"));
        return FALSE;
    }

    bSuccess = SdbSetPermLayerKeys(pwszPath, pwszLayers, bMachine);

    // we do not care whether we were successful in the call above, clean the 
    // cache always (just in case)

    ApphelpUpdateCacheEntry(pwszPath, INVALID_HANDLE_VALUE, TRUE, FALSE);

    return bSuccess;
}

BOOL
GetPermLayers(
    IN  LPCWSTR pwszPath,       // path to the file to set a permanent layer on
    OUT LPWSTR  pwszLayers,     // layers to apply to the file, separated by spaces
    OUT DWORD*  pdwBytes,       // input: number of bytes available; output is number
                                // of bytes needed.
    IN  DWORD   dwFlags
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Returns the permanent layer setting for the specified file.
--*/
{
    if (pwszPath == NULL || pwszLayers == NULL || pdwBytes == NULL) {
        DBGPRINT((sdlError, "GetPermLayers", "Invalid argument\n"));
        return FALSE;
    }

    return SdbGetPermLayerKeys(pwszPath, pwszLayers, pdwBytes, dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\apphelp\path.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        path.c

    Abstract:

        This module implements string utilities for dealing with NT device names.

    Author:

        vadimb     created     sometime in 2000

    Revision History:

        clupu      cleanup     12/27/2000
--*/

#include "apphelp.h"


UNICODE_STRING DosDevicePrefix    = RTL_CONSTANT_STRING(L"\\??\\");
UNICODE_STRING DosDeviceUNCPrefix = RTL_CONSTANT_STRING(L"\\??\\UNC\\");


BOOL
CheckStringPrefixUnicode(
    IN  PUNICODE_STRING pStrPrefix,     // the prefix to check for
    IN  PUNICODE_STRING pString,        // the string
    IN  BOOL            CaseInSensitive
    )
/*++
    Return: TRUE if the specified string contains pStrPrefix at it's start.

    Desc:   Verifies if a string is a prefix in another unicode counted string.
            It is equivalent to RtlStringPrefix.
--*/
{
    PWSTR ps1, ps2;
    UINT  n;
    WCHAR c1, c2;

    n = pStrPrefix->Length;
    if (pString->Length < n) {
        return FALSE;
    }

    n /= sizeof(WCHAR); // convert to char count

    ps1 = pStrPrefix->Buffer;
    ps2 = pString->Buffer;

    if (CaseInSensitive) {
        while (n--) {
            c1 = *ps1++;
            c2 = *ps2++;

            if (c1 != c2) {
                c1 = RtlUpcaseUnicodeChar(c1);
                c2 = RtlUpcaseUnicodeChar(c2);
                if (c1 != c2) {
                    return FALSE;
                }
            }
        }
    } else {
        while (n--) {
            if (*ps1++ != *ps2++) {
                return FALSE;
            }
        }
    }

    return TRUE;
}


BOOL
DeleteCharsUnicodeString(
    OUT PUNICODE_STRING pStringDest,    // UNICODE string to operate on
    IN  USHORT          nIndexStart,    // starting byte for deletion
    IN  USHORT          nLength         // number of bytes to be removed
    )
/*++
    Return: TRUE if the characters were removed, FALSE on failure.

    Desc:   Removes the specified number of characters from a unicode string
            starting at the specified position (including starting character).
--*/
{
    if (nIndexStart > pStringDest->Length) { // start past length
        return FALSE;
    }

    if (nLength >= (pStringDest->Length - nIndexStart)) {
        pStringDest->Length = nIndexStart;
        *(PWCHAR)((PUCHAR)pStringDest->Buffer + nIndexStart) = UNICODE_NULL;
    } else {
        USHORT nNewLength;

        nNewLength = pStringDest->Length - nLength;

        RtlMoveMemory((PUCHAR)pStringDest->Buffer + nIndexStart,
                      (PUCHAR)pStringDest->Buffer + nIndexStart + nLength,
                      nNewLength - nIndexStart);

        pStringDest->Length = nNewLength;
        *(PWCHAR)((PUCHAR)pStringDest->Buffer + nNewLength) = UNICODE_NULL;
    }

    return TRUE;
}


void
InitZeroUnicodeString(
    OUT PUNICODE_STRING pStr,
    IN  PWSTR           pwsz,
    IN  USHORT          nMaximumLength
    )
/*++
    Return: void.

    Desc:   Initializes an empty UNICODE string given the pointer
            starting at the specified position (including starting character).
--*/
{
    pStr->Length = 0;
    pStr->MaximumLength = nMaximumLength;
    pStr->Buffer = pwsz;
    
    if (pwsz != NULL) {
        pwsz[0] = UNICODE_NULL;
    }
}

static WCHAR szStaticDosPathBuffer[MAX_PATH];

void
FreeDosPath(
    WCHAR* pDosPath
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    //
    // Check whether this memory points to our internal buffer.
    // If not then this was allocated. We need to free it.
    //
    if (pDosPath &&
        ((ULONG_PTR)pDosPath < (ULONG_PTR)szStaticDosPathBuffer ||
        (ULONG_PTR)pDosPath >= ((ULONG_PTR)szStaticDosPathBuffer) + sizeof(szStaticDosPathBuffer))) {
        SdbFree(pDosPath);
    }
}


BOOL
ConvertToDosPath(
    OUT LPWSTR*  ppDosPath,
    IN  LPCWSTR  pwszPath
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   This function can determine what sort of path has been given to it.
            If it's NT Path it returns DosPath.
            The function returns path name in a static buffer which is global 
            or allocates memory as necessary if the static buffer is not
            large enough.
--*/
{
    UNICODE_STRING ustrPath;
    UNICODE_STRING ustrDosPath;
    WCHAR*         pDosPath;

    RtlInitUnicodeString(&ustrPath, pwszPath);

    //
    // If the length is sufficient use the static buffer. If not allocate memory.
    //
    if (ustrPath.Length < sizeof(szStaticDosPathBuffer)) {
        pDosPath = szStaticDosPathBuffer;
    } else {
        //
        // Allocate an output buffer that is large enough
        //
        pDosPath = SdbAlloc(ustrPath.Length + sizeof(UNICODE_NULL));
        
        if (pDosPath == NULL) {
            DBGPRINT((sdlError,
                      "ConvertToDosPath",
                      "Failed to allocate %d bytes\n",
                      ustrPath.Length + sizeof(UNICODE_NULL)));
            return FALSE;
        }
    }
    
    InitZeroUnicodeString(&ustrDosPath, pDosPath, ustrPath.Length + sizeof(UNICODE_NULL));

    //
    // Now it's unicode string. Copy the source string into it.
    //
    RtlCopyUnicodeString(&ustrDosPath, &ustrPath);

    if (CheckStringPrefixUnicode(&DosDeviceUNCPrefix, &ustrDosPath, TRUE)) {
        //
        // UNC path name. We convert it to DosPathName.
        //
        DeleteCharsUnicodeString(&ustrDosPath,
                                 (USHORT)0,
                                 (USHORT)(DosDeviceUNCPrefix.Length - 2 * sizeof(WCHAR)));

        ustrDosPath.Buffer[0] = L'\\';

         
    } else {
        //
        // The string is not prefixed by <UNC\>
        //
        if (CheckStringPrefixUnicode(&DosDevicePrefix, &ustrDosPath, TRUE)) {

            DeleteCharsUnicodeString(&ustrDosPath,
                                     0,
                                     DosDevicePrefix.Length);
        }
    }

    *ppDosPath = pDosPath;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\appverifier\appverifier.cpp ===
#include "precomp.h"

#include "dbsupport.h"
#include "viewlog.h"


#define AV_OPTIONS_KEY  L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\AppVerifier"

#define AV_OPTION_CLEAR_LOG     L"ClearLogsBeforeRun"
#define AV_OPTION_BREAK_ON_LOG  L"BreakOnLog"
#define AV_OPTION_FULL_PAGEHEAP L"FullPageHeap"
#define AV_OPTION_AV_DEBUGGER   L"UseAVDebugger"


//
// Forward declarations
//
void RefreshSettingsList(HWND hDlg);

CWinApp theApp;


HINSTANCE g_hInstance = NULL;

BOOL    g_bSettingsDirty = FALSE;

BOOL    g_bRefreshingSettings = FALSE;

BOOL    g_bConsoleMode = FALSE;

//
// AppVerifier options
//
BOOL    g_bClearSessionLogBeforeRun;
BOOL    g_bBreakOnLog;
BOOL    g_bFullPageHeap;
BOOL    g_bUseAVDebugger;

// forward function declarations
LRESULT CALLBACK DlgMain(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

BOOL
GetAppTitleString(
    wstring &strTitle
    )
{
    wstring strVersion;

    if (!AVLoadString(IDS_APP_NAME, strTitle)) {
        return FALSE;
    }

    if (!AVLoadString(IDS_VERSION_STRING, strVersion)) {
        return FALSE;
    }

    strTitle += L" ";
    strTitle += strVersion;

    return TRUE;
}

BOOL 
SearchGroupForSID(
    DWORD dwGroup, 
    BOOL* pfIsMember
    )
{
    PSID                     pSID;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL                     fRes = TRUE;
    
    if (!AllocateAndInitializeSid(&SIDAuth,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  dwGroup,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  &pSID)) {
        fRes = FALSE;
    }

    if (!CheckTokenMembership(NULL, pSID, pfIsMember)) {
        fRes = FALSE;
    }

    FreeSid(pSID);

    return fRes;
}

BOOL 
CanRun(
    void
    )
{
    BOOL fIsAdmin;

    if (!SearchGroupForSID(DOMAIN_ALIAS_RID_ADMINS, &fIsAdmin))
    {
        return FALSE;
    }

    return fIsAdmin;
}

void
DumpCurrentSettingsToConsole(void)
{
    CAVAppInfo *pApp;

    printf("\n");
    printf("Current Verifier Settings:\n\n");

    for (pApp = g_aAppInfo.begin(); pApp != g_aAppInfo.end(); pApp++) {
        printf("%ls:\n", pApp->wstrExeName.c_str());

        CTestInfo *pTest;

        for (pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
            if (pApp->IsTestActive(*pTest)) {
                printf("    %ls\n", pTest->strTestCommandLine.c_str());
            }
        }

        printf("\n");
    }

    printf("Done.\n");
    printf("\n");
}

void
DumpHelpToConsole(void)
{
    printf("\n");
    printf("Usage: appverif.exe [flags] [tests] [APP [APP...]]\n");
    printf("\n");
    printf("No command-line: run appverif.exe in GUI mode.\n");
    printf("\n");
    printf("Flags:\n");
    printf("    /?                  - print this help text.\n");
    printf("    /querysettings (/q) - dump current settings to console.\n");
    printf("    /reset (/r)         - reset (clear) all settings for all apps.\n");
    printf("    /all (/a)           - enable all tests for specified apps.\n");
    printf("    /default (/d)       - enable default tests for specified apps.\n");
    printf("    /none (/n)          - disable all tests for specified apps.\n");
    printf("\n");
    printf("Tests (prefix with '+' to add and '-' to remove):\n");
    printf("\n");
    printf("  Kernel Tests:\n");
    
    CTestInfo *pTest;

    for (pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
        if (pTest->eTestType == TEST_KERNEL) {
            printf("    %ls\n", pTest->strTestCommandLine.c_str());
        }
    }
    printf("\n");
    printf("  Shim Tests:\n");
    
    for (pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
        if (pTest->eTestType == TEST_SHIM) {
            printf("    %ls\n", pTest->strTestCommandLine.c_str());
        }
    }

    printf("\n");
    printf("(For descriptions of tests, run appverif.exe in GUI mode.)\n");
    printf("\n");
    printf("Examples:\n");
    printf("\n");
    printf("    appverif /d -pageheap foo.exe\n");
    printf("        (turn on default tests except pageheap for foo.exe)\n");
    printf("\n");
    printf("    appverif /a -locks foo.exe\n");
    printf("        (turn on all tests except locks for foo.exe)\n");
    printf("\n");
    printf("    appverif +pageheap foo.exe bar.exe\n");
    printf("        (turn on just pageheap for foo.exe & bar.exe)\n");
    printf("\n");
    printf("    appverif /n foo.exe\n");
    printf("        (clear all tests for foo.exe)\n");
    printf("\n");
    printf("    appverif /r\n");
    printf("        (clear all tests for all apps)\n");
    printf("\n");

}

void
HandleCommandLine(int argc, LPWSTR *argv)
{
    WCHAR szApp[MAX_PATH];
    wstring strTemp;
    CWStringArray astrApps;

    szApp[0] = 0;

    g_bConsoleMode = TRUE;

    //
    // print the title
    //
    if (GetAppTitleString(strTemp)) {
        printf("\n%ls\n", strTemp.c_str());
    }
    if (AVLoadString(IDS_COPYRIGHT, strTemp)) {
        printf("%ls\n\n", strTemp.c_str());
    }

    //
    // check for global operations
    //
    if (_wcsnicmp(argv[0], L"/q", 2) == 0) { // querysettings
        DumpCurrentSettingsToConsole();
        return;
    }
    if (_wcsicmp(argv[0], L"/?") == 0) {  // help
        DumpHelpToConsole();
        return;
    }
    if (_wcsnicmp(argv[0], L"/r", 2) == 0) { // reset
        g_aAppInfo.clear();
        goto out;
    }

    //
    // first get a list of the app names
    //
    for (int nArg = 0 ; nArg != argc; nArg++) {
        WCHAR wc = argv[nArg][0];

        if (wc != L'/' && wc != L'-' && wc != L'+') {
            astrApps.push_back(argv[nArg]);
        }
    }

    if (astrApps.size() == 0) {
        AVErrorResourceFormat(IDS_NO_APP);
        DumpHelpToConsole();
        return;
    }

    //
    // now for each app name, parse the list and adjust its settings
    //
    for (wstring *pStr = astrApps.begin(); pStr != astrApps.end(); pStr++) {
        CAVAppInfo *pApp;
        BOOL bFound = FALSE;

        //
        // check to see if they submitted a full path
        //
        const WCHAR * pExe = NULL;
        const WCHAR * pPath = NULL;

        pExe = wcsrchr(pStr->c_str(), L'\\');
        if (!pExe) {
            if ((*pStr)[1] == L':') {
                pExe = pStr->c_str() + 2;
            }
        } else {
            pExe++;
        }

        if (pExe) {
            pPath = pStr->c_str();
        } else {
            pExe = pStr->c_str();
        }

        //
        // first, find or add the app to the list, and get a pointer to it
        //
        for (pApp = g_aAppInfo.begin(); pApp != g_aAppInfo.end(); pApp++) {
            if (_wcsicmp(pApp->wstrExeName.c_str(), pExe) == 0) {
                bFound = TRUE;
                break;
            }
        }
        if (!bFound) {
            CAVAppInfo App;

            App.wstrExeName = pExe;
            g_aAppInfo.push_back(App);
            pApp = g_aAppInfo.end() - 1;
        }

        //
        // if they submitted a full path, update the records
        //
        if (pPath) {
            pApp->wstrExePath = pPath;
        }

        //
        // now walk the command line again and make the adjustments
        //
        for (int nArg = 0 ; nArg != argc; nArg++) {
            if (argv[nArg][0] == L'/') {
                if (_wcsnicmp(argv[nArg], L"/a", 2) == 0) {  // all
                    
                    for (CTestInfo *pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
                        pApp->AddTest(*pTest);
                    }
                } else if (_wcsnicmp(argv[nArg], L"/n", 2) == 0) {  // none
                    
                    for (CTestInfo *pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
                        pApp->RemoveTest(*pTest);
                    }
                } else if (_wcsnicmp(argv[nArg], L"/d", 2) == 0) {  // default
                    
                    for (CTestInfo *pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
                        if (pTest->bDefault) {
                            pApp->AddTest(*pTest);
                        } else {
                            pApp->RemoveTest(*pTest);
                        }
                    }
                } else {
                    
                    //
                    // unknown parameter
                    //
                    AVErrorResourceFormat(IDS_INVALID_PARAMETER, argv[nArg]);
                    DumpHelpToConsole();
                    return;
                }

            } else if (argv[nArg][0] == L'+' || argv[nArg][0] == L'-') {
                
                BOOL bAdd = (argv[nArg][0] == L'+');
                LPWSTR szParam = argv[nArg] + 1;

                //
                // see if it's a shim name
                //
                CTestInfo *pTest;
                BOOL bFound = FALSE;

                for (pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
                    if (_wcsicmp(szParam, pTest->strTestCommandLine.c_str()) == 0) {
                        if (bAdd) {
                            pApp->AddTest(*pTest);
                        } else {
                            pApp->RemoveTest(*pTest);
                        }
                        bFound = TRUE;
                        break;
                    }
                }

                if (!bFound) {
                    //
                    // unknown test
                    //

                    AVErrorResourceFormat(IDS_INVALID_TEST, szParam);
                    DumpHelpToConsole();
                    return;
                }
            } 
            //
            // anything that doesn't begin with a slash, plus, or minus
            // is an app name, so we'll ignore it
            //

        }
    }

out:
    //
    // save them to disk/registry
    //
    SetCurrentAppSettings();
    
    //
    // show them the current settings, for verification
    //
    DumpCurrentSettingsToConsole();
}


extern "C" int APIENTRY
wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR    lpCmdLine,
    int       nCmdShow
    )
{
    LPWSTR* argv = NULL;
    int     argc = 0;
    
    g_hInstance = hInstance;

    InitTestInfo();

    GetCurrentAppSettings();

    if (lpCmdLine && lpCmdLine[0]) {
        argv = CommandLineToArgvW(lpCmdLine, &argc);
    }

    //
    // See if it's used as a debugger.
    //
    if (argc == 2 && _wcsicmp(argv[0], L"/debug") == 0) {
        FreeConsole();
        DebugApp(argv[1]);
        return 1;
    }

    if (!CanRun()) {
        AVErrorResourceFormat(IDS_ACCESS_IS_DENIED);
        return 0;
    }
    
    if (argc > 0) {
        //
        // we're in console mode, so handle everything as a console
        //
        HandleCommandLine(argc, argv);
        return 1;
    }

    FreeConsole();
    
    InitCommonControls();

    HWND hMainDlg = CreateDialog(g_hInstance, (LPCTSTR)IDD_DLG_MAIN, NULL, (DLGPROC)DlgMain);

    MSG msg;

    //
    // Main message loop:
    //
    while (GetMessage(&msg, NULL, 0, 0)) {
        if (!IsDialogMessage(hMainDlg, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return 0;
}

void
RefreshAppList(
    HWND hDlg
    )
{
    CAVAppInfoArray::iterator it;

    HWND hList = GetDlgItem(hDlg, IDC_LIST_APPS);

    ListView_DeleteAllItems(hList);

    for (it = g_aAppInfo.begin(); it != g_aAppInfo.end(); it++) {
        LVITEM lvi;

        lvi.mask      = LVIF_TEXT | LVIF_PARAM;
        lvi.pszText   = (LPWSTR)it->wstrExeName.c_str();
        lvi.lParam    = (LPARAM)it;
        lvi.iItem     = 9999;
        lvi.iSubItem  = 0;

        ListView_InsertItem(hList, &lvi);
    }

    RefreshSettingsList(hDlg);
}

void
DirtySettings(
    HWND hDlg,
    BOOL bDirty
    )
{
    g_bSettingsDirty = bDirty;

    if (hDlg) {
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_SAVE_SETTINGS), bDirty);
    }
}

void
SaveSettings(
    HWND hDlg
    )
{
    DirtySettings(hDlg, FALSE);

    SetCurrentAppSettings();
}

void
SaveSettingsIfDirty(HWND hDlg)
{
    if (g_bSettingsDirty) {
        SaveSettings(hDlg);
    }
}

void
DisplayLog(
    HWND hDlg
    )
{
    g_szSingleLogFile[0] = 0;

    DialogBox(g_hInstance, (LPCTSTR)IDD_VIEWLOG_PAGE, hDlg, (DLGPROC)DlgViewLog);
}

void
DisplaySingleLog(HWND hDlg)
{
    WCHAR           wszFilter[] = L"Log files (*.log)\0*.log\0";
    OPENFILENAME    ofn;
    WCHAR           wszAppFullPath[MAX_PATH];
    WCHAR           wszAppShortName[MAX_PATH];

    wstring         wstrLogTitle;

    if (!AVLoadString(IDS_VIEW_EXPORTED_LOG_TITLE, wstrLogTitle)) {
        wstrLogTitle = _T("View Exported Log");
    }

    wszAppFullPath[0] = 0;

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hDlg;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = wszFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = wszAppFullPath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = wszAppShortName;
    ofn.nMaxFileTitle     = MAX_PATH;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = wstrLogTitle.c_str();
    ofn.Flags             = OFN_PATHMUSTEXIST       |
                            OFN_HIDEREADONLY        |           // hide the "open read-only" checkbox                
                            OFN_NONETWORKBUTTON     |           // no network button                                 
                            OFN_NOTESTFILECREATE    |           // don't test for write protection, a full disk, etc.
                            OFN_SHAREAWARE;                     // don't check the existance of file with OpenFile   
    ofn.lpstrDefExt       = _T("log");

    if ( !GetOpenFileName(&ofn) )
    {
        return;
    }

    wcscpy(g_szSingleLogFile, wszAppFullPath);

    DialogBox(g_hInstance, (LPCTSTR)IDD_VIEWLOG_PAGE, hDlg, (DLGPROC)DlgViewLog);

    g_szSingleLogFile[0] = 0;
}

void
SelectApp(
    HWND hDlg,
    int  nWhich
    )
{
    HWND hList = GetDlgItem(hDlg, IDC_LIST_APPS);

    int nItems = ListView_GetItemCount(hList);

    if (nItems == 0) {
        return;
    }

    if (nWhich > nItems - 1) {
        nWhich = nItems - 1;
    }

    ListView_SetItemState(hList, nWhich, LVIS_SELECTED, LVIS_SELECTED);
}

void
RunSelectedApp(
    HWND hDlg
    )
{
    WCHAR wszCommandLine[256];

    SaveSettings(hDlg);

    HWND hAppList = GetDlgItem(hDlg, IDC_LIST_APPS);

    int nApp = ListView_GetNextItem(hAppList, -1, LVNI_SELECTED);

    if (nApp == -1) {
        return;
    }

    LVITEM lvi;

    lvi.mask      = LVIF_PARAM;
    lvi.iItem     = nApp;
    lvi.iSubItem  = 0;

    ListView_GetItem(hAppList, &lvi);

    CAVAppInfo *pApp = (CAVAppInfo*)lvi.lParam;

    if (pApp->wstrExePath.size()) {
        
        LPWSTR pwsz;
        
        wcscpy(wszCommandLine, pApp->wstrExePath.c_str());

        pwsz = wcsrchr(wszCommandLine, L'\\');

        if (pwsz) {
            *pwsz = 0;
            SetCurrentDirectory(wszCommandLine);
            *pwsz = L'\\';
        }

    } else {
        wcscpy(wszCommandLine, pApp->wstrExeName.c_str());
    }

    PROCESS_INFORMATION ProcessInfo;
    BOOL        bRet;
    STARTUPINFO StartupInfo;

    ZeroMemory(&StartupInfo, sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);

    ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));

    bRet = CreateProcess(NULL,
                         wszCommandLine,
                         NULL,
                         NULL,
                         FALSE,
                         0,
                         NULL,
                         NULL,
                         &StartupInfo,
                         &ProcessInfo);

    if (!bRet) {
        WCHAR           wszFilter[] = L"Executable files (*.exe)\0*.exe\0";
        OPENFILENAME    ofn;
        WCHAR           wszAppFullPath[MAX_PATH];
        WCHAR           wszAppShortName[MAX_PATH];

        wcscpy(wszAppFullPath, wszCommandLine);

        ofn.lStructSize       = sizeof(OPENFILENAME);
        ofn.hwndOwner         = hDlg;
        ofn.hInstance         = NULL;
        ofn.lpstrFilter       = wszFilter;
        ofn.lpstrCustomFilter = NULL;
        ofn.nMaxCustFilter    = 0;
        ofn.nFilterIndex      = 0;
        ofn.lpstrFile         = wszAppFullPath;
        ofn.nMaxFile          = MAX_PATH;
        ofn.lpstrFileTitle    = wszAppShortName;
        ofn.nMaxFileTitle     = MAX_PATH;
        ofn.lpstrInitialDir   = NULL;
        ofn.lpstrTitle        = _T("Please locate application");
        ofn.Flags             = OFN_PATHMUSTEXIST       |
                                OFN_HIDEREADONLY        |           // hide the "open read-only" checkbox                
                                OFN_NONETWORKBUTTON     |           // no network button                                 
                                OFN_NOTESTFILECREATE    |           // don't test for write protection, a full disk, etc.
                                OFN_SHAREAWARE;                     // don't check the existance of file with OpenFile   
        ofn.lpstrDefExt       = NULL;

        if (!GetOpenFileName(&ofn)) {
            return;
        }

        pApp->wstrExePath = wszAppFullPath;
        pApp->wstrExeName = wszAppShortName;
        wcscpy(wszCommandLine, pApp->wstrExePath.c_str());

        RefreshAppList(hDlg);

        ZeroMemory(&StartupInfo, sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);

        ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));

        bRet = CreateProcess(NULL,
                             wszCommandLine,
                             NULL,
                             NULL,
                             FALSE,
                             0,
                             NULL,
                             NULL,
                             &StartupInfo,
                             &ProcessInfo);
        if (!bRet) {
            AVErrorResourceFormat(IDS_CANT_LAUNCH_EXE);
        }
    }
}

void
AddAppToList(
    HWND hDlg
    )
{

    WCHAR           wszFilter[] = L"Executable files (*.exe)\0*.exe\0";
    OPENFILENAME    ofn;
    WCHAR           wszAppFullPath[MAX_PATH];
    WCHAR           wszAppShortName[MAX_PATH];

    wstring         wstrTitle;

    if (!AVLoadString(IDS_ADD_APPLICATION_TITLE, wstrTitle)) {
        wstrTitle = _T("Add Application");
    }

    wszAppFullPath[0] = 0;

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hDlg;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = wszFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = wszAppFullPath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = wszAppShortName;
    ofn.nMaxFileTitle     = MAX_PATH;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = wstrTitle.c_str();
    ofn.Flags             = OFN_HIDEREADONLY        |           // hide the "open read-only" checkbox                
                            OFN_NONETWORKBUTTON     |           // no network button                                 
                            OFN_NOTESTFILECREATE    |           // don't test for write protection, a full disk, etc.
                            OFN_SHAREAWARE;                     // don't check the existance of file with OpenFile   
    ofn.lpstrDefExt       = _T("EXE");

    if (!GetOpenFileName(&ofn)) {
        return;
    }

    //
    // check to see if the app is already in the list
    //
    CAVAppInfo *pApp;
    BOOL bFound = FALSE;

    for (pApp = g_aAppInfo.begin(); pApp != g_aAppInfo.end(); pApp++) {
        if (_wcsicmp(pApp->wstrExeName.c_str(), wszAppShortName) == 0) {
            //
            // the app is already in the list, so just update the full
            // path, if it's good
            //
            if (GetFileAttributes(wszAppFullPath) != -1) {
                pApp->wstrExePath = wszAppFullPath;
            }
            bFound = TRUE;
        }
    }

    //
    // if the app wasn't already in the list, add it to the list
    //
    if (!bFound) {
        CAVAppInfo AppInfo;

        AppInfo.wstrExeName = wszAppShortName;

        //
        // check to see if the file actually exists
        //
        if (GetFileAttributes(wszAppFullPath) != -1) {
            AppInfo.wstrExePath = wszAppFullPath;
        }

        //
        // init the default tests
        //
        CTestInfo *pTest;
        for (pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
            if (pTest->bDefault) {
                AppInfo.AddTest(*pTest);
            }
        }

        g_aAppInfo.push_back(AppInfo);

        RefreshAppList(hDlg);

        SelectApp(hDlg, 9999);

        DirtySettings(hDlg, TRUE);
    }
}

void
RemoveSelectedApp(
    HWND hDlg
    )
{
    HWND hAppList = GetDlgItem(hDlg, IDC_LIST_APPS);

    int nApp = ListView_GetNextItem(hAppList, -1, LVNI_SELECTED);

    if (nApp == -1) {
        return;
    }

    LVITEM lvi;

    lvi.mask      = LVIF_PARAM;
    lvi.iItem     = nApp;
    lvi.iSubItem  = 0;

    ListView_GetItem(hAppList, &lvi);

    CAVAppInfo *pApp = (CAVAppInfo*)lvi.lParam;

    g_aAppInfo.erase(pApp);

    RefreshAppList(hDlg);

    SelectApp(hDlg, nApp);

    DirtySettings(hDlg, TRUE);
}

void
ScanSettingsList(
    HWND hDlg,
    int  nItem
    )
{

    HWND hSettingList = GetDlgItem(hDlg, IDC_LIST_SETTINGS);
    HWND hAppList = GetDlgItem(hDlg, IDC_LIST_APPS);
    int nBegin, nEnd;

    int nApp = ListView_GetNextItem(hAppList, -1, LVNI_SELECTED);

    if (nApp == -1) {
        return;
    }

    LVITEM lvi;

    lvi.mask      = LVIF_PARAM;
    lvi.iItem     = nApp;
    lvi.iSubItem  = 0;

    ListView_GetItem(hAppList, &lvi);

    CAVAppInfo *pApp = (CAVAppInfo*)lvi.lParam;

    if (!pApp) {
        return;
    }

    int nItems = ListView_GetItemCount(hSettingList);

    if (!nItems) {
        //
        // nothing in list
        //
        return;
    }

    if (nItem == -1 || nItem >= nItems) {
        nBegin = 0;
        nEnd = nItems;
    } else {
        nBegin = nItem;
        nEnd = nItem + 1;
    }

    for (int i = nBegin; i < nEnd; ++i) {
        BOOL bTestEnabled = FALSE;
        BOOL bChecked = FALSE;

        lvi.iItem = i;

        ListView_GetItem(hSettingList, &lvi);

        CTestInfo *pTest = (CTestInfo*)lvi.lParam;

        bChecked = ListView_GetCheckState(hSettingList, i);

        bTestEnabled = pApp->IsTestActive(*pTest);

        if (bTestEnabled != bChecked) {
            DirtySettings(hDlg, TRUE);
            
            if (bChecked) {
                pApp->AddTest(*pTest);
            } else {
                pApp->RemoveTest(*pTest);
            }
        }
    }
}

void
DisplaySettingsDescription(
    HWND hDlg
    )
{
    HWND hList = GetDlgItem(hDlg, IDC_LIST_SETTINGS);

    int nItem = ListView_GetNextItem(hList, -1, LVNI_SELECTED);

    if (nItem == -1) {
        WCHAR szTestDesc[256];

        LoadString(g_hInstance, IDS_VIEW_TEST_DESC, szTestDesc, 256);
        SetWindowText(GetDlgItem(hDlg, IDC_STATIC_DESC), szTestDesc);
    } else {
        LVITEM lvi;

        lvi.mask      = LVIF_PARAM;
        lvi.iItem     = nItem;
        lvi.iSubItem  = 0;

        ListView_GetItem(hList, &lvi);

        CTestInfo *pTest = (CTestInfo*)lvi.lParam;

        SetWindowText(GetDlgItem(hDlg, IDC_STATIC_DESC), pTest->strTestDescription.c_str());
    }

}

void
RefreshSettingsList(
    HWND hDlg
    )
{
    HWND hSettingList = GetDlgItem(hDlg, IDC_LIST_SETTINGS);
    HWND hAppList = GetDlgItem(hDlg, IDC_LIST_APPS);

    static nLastItem = -1;

    int nItem = ListView_GetNextItem(hAppList, -1, LVNI_SELECTED);

    if (nItem == -1) {

        EnableWindow(GetDlgItem(hDlg, IDC_BTN_RUN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_REMOVE), FALSE);

    } else {

        EnableWindow(GetDlgItem(hDlg, IDC_BTN_RUN), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_REMOVE), TRUE);
    }

    if (nItem == nLastItem) {
        return;

    }

    ListView_DeleteAllItems(hSettingList);

    DisplaySettingsDescription(hDlg);

    nLastItem = nItem;

    if (nItem != -1) {
        LVITEM lvi;

        lvi.mask      = LVIF_PARAM;
        lvi.iItem     = nItem;
        lvi.iSubItem  = 0;

        ListView_GetItem(hAppList, &lvi);

        CAVAppInfo *pApp = (CAVAppInfo*)lvi.lParam;

        if (!pApp) {
            return;
        }

        CTestInfo* pTest;

        for (pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
            lvi.mask      = LVIF_TEXT | LVIF_PARAM;
            lvi.pszText   = (LPWSTR)pTest->strTestName.c_str();
            lvi.lParam    = (LPARAM)pTest;
            lvi.iItem     = 9999;
            lvi.iSubItem  = 0;

            int nItem = ListView_InsertItem(hSettingList, &lvi);

            BOOL bCheck = pApp->IsTestActive(*pTest);

            ListView_SetCheckState(hSettingList, nItem, bCheck);
        }
    }
}

void
ReadOptions(
    void
    )
{
    LONG  lRet;
    HKEY  hKey;
    DWORD cbData;
    
    lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                          AV_OPTIONS_KEY,
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hKey,
                          NULL);

    if (lRet != ERROR_SUCCESS) {
        return;
    }

    cbData = sizeof(DWORD);
    
    RegQueryValueEx(hKey,
                    AV_OPTION_CLEAR_LOG,
                    NULL,
                    NULL,
                    (BYTE*)&g_bClearSessionLogBeforeRun,
                    &cbData);

    RegQueryValueEx(hKey,
                    AV_OPTION_BREAK_ON_LOG,
                    NULL,
                    NULL,
                    (BYTE*)&g_bBreakOnLog,
                    &cbData);

    RegQueryValueEx(hKey,
                    AV_OPTION_FULL_PAGEHEAP,
                    NULL,
                    NULL,
                    (BYTE*)&g_bFullPageHeap,
                    &cbData);

    RegQueryValueEx(hKey,
                    AV_OPTION_AV_DEBUGGER,
                    NULL,
                    NULL,
                    (BYTE*)&g_bUseAVDebugger,
                    &cbData);

    RegCloseKey(hKey);
}

void
SaveOptions(
    void
    )
{
    LONG  lRet;
    HKEY  hKey;
    
    lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                          AV_OPTIONS_KEY,
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hKey,
                          NULL);

    if (lRet != ERROR_SUCCESS) {
        return;
    }

    RegSetValueEx(hKey,
                  AV_OPTION_CLEAR_LOG,
                  NULL,
                  REG_DWORD,
                  (BYTE*)&g_bClearSessionLogBeforeRun,
                  sizeof(DWORD));

    RegSetValueEx(hKey,
                  AV_OPTION_BREAK_ON_LOG,
                  NULL,
                  REG_DWORD,
                  (BYTE*)&g_bBreakOnLog,
                  sizeof(DWORD));

    RegSetValueEx(hKey,
                  AV_OPTION_FULL_PAGEHEAP,
                  NULL,
                  REG_DWORD,
                  (BYTE*)&g_bFullPageHeap,
                  sizeof(DWORD));

    RegSetValueEx(hKey,
                  AV_OPTION_AV_DEBUGGER,
                  NULL,
                  REG_DWORD,
                  (BYTE*)&g_bUseAVDebugger,
                  sizeof(DWORD));

    RegCloseKey(hKey);
    SetCurrentAppSettings();
}


LRESULT CALLBACK
DlgViewOptions(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (message) {
    case WM_INITDIALOG:
        ReadOptions();
        SendDlgItemMessage(hDlg,
                           IDC_CLEAR_LOG_ON_CHANGES,
                           BM_SETCHECK,
                           (g_bClearSessionLogBeforeRun ? BST_CHECKED : BST_UNCHECKED),
                           0);

        SendDlgItemMessage(hDlg,
                           IDC_BREAK_ON_LOG,
                           BM_SETCHECK,
                           (g_bBreakOnLog ? BST_CHECKED : BST_UNCHECKED),
                           0);

        SendDlgItemMessage(hDlg,
                           IDC_FULL_PAGEHEAP,
                           BM_SETCHECK,
                           (g_bFullPageHeap ? BST_CHECKED : BST_UNCHECKED),
                           0);

        SendDlgItemMessage(hDlg,
                           IDC_USE_AV_DEBUGGER,
                           BM_SETCHECK,
                           (g_bUseAVDebugger ? BST_CHECKED : BST_UNCHECKED),
                           0);

        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            g_bClearSessionLogBeforeRun = (SendDlgItemMessage(hDlg,
                                                              IDC_CLEAR_LOG_ON_CHANGES,
                                                              BM_GETCHECK,
                                                              0,
                                                              0) == BST_CHECKED);

            g_bBreakOnLog = (SendDlgItemMessage(hDlg,
                                                IDC_BREAK_ON_LOG,
                                                BM_GETCHECK,
                                                0,
                                                0) == BST_CHECKED);

            g_bFullPageHeap = (SendDlgItemMessage(hDlg,
                                                  IDC_FULL_PAGEHEAP,
                                                  BM_GETCHECK,
                                                  0,
                                                  0) == BST_CHECKED);

            g_bUseAVDebugger = (SendDlgItemMessage(hDlg,
                                                   IDC_USE_AV_DEBUGGER,
                                                   BM_GETCHECK,
                                                   0,
                                                   0) == BST_CHECKED);

            SaveOptions();

            EndDialog(hDlg, LOWORD(wParam));
            return TRUE;

        case IDCANCEL:
            EndDialog(hDlg, LOWORD(wParam));
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        break;
    }
    return FALSE;
}

void
ViewOptions(
    HWND hDlg
    )
{
    DialogBox(g_hInstance, (LPCTSTR)IDD_OPTIONS, hDlg, (DLGPROC)DlgViewOptions);
}

// Message handler for main dialog.
LRESULT CALLBACK
DlgMain(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (message) {
    case WM_INITDIALOG:
        {
            wstring strTemp;

            //
            // set the caption to the appropriate version, etc.
            //
            if (GetAppTitleString(strTemp)) {
                SetWindowText(hDlg, strTemp.c_str());
            }
            EnableWindow(GetDlgItem(hDlg, IDC_BTN_RUN), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_BTN_REMOVE), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_BTN_SAVE_SETTINGS), FALSE);

            HWND hList = GetDlgItem(hDlg, IDC_LIST_SETTINGS);

            if (hList) {
                LVCOLUMN  lvc;

                lvc.mask     = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
                lvc.fmt      = LVCFMT_LEFT;
                lvc.cx       = 300;
                lvc.iSubItem = 0;
                lvc.pszText  = L"xxx";

                ListView_InsertColumn(hList, 0, &lvc);
                ListView_SetExtendedListViewStyleEx(hList, LVS_EX_CHECKBOXES, LVS_EX_CHECKBOXES);

            }

            hList = GetDlgItem(hDlg, IDC_LIST_APPS);
            if (hList) {
                LVITEM lvi;
                LVCOLUMN  lvc;

                lvc.mask     = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
                lvc.fmt      = LVCFMT_LEFT;
                lvc.cx       = 250;
                lvc.iSubItem = 0;
                lvc.pszText  = L"xxx";

                ListView_InsertColumn(hList, 0, &lvc);

                RefreshAppList(hDlg);

                SelectApp(hDlg, 0);
            }

            WCHAR szTestDesc[256];

            LoadString(g_hInstance, IDS_VIEW_TEST_DESC, szTestDesc, 256);
            SetWindowText(GetDlgItem(hDlg, IDC_STATIC_DESC), szTestDesc);

            //
            // Show the app icon.
            //
            HICON hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ICON));

            SetClassLongPtr(hDlg, GCLP_HICON, (LONG_PTR)hIcon);

            return TRUE;
        }
        break;

    case WM_ACTIVATE:
        if (LOWORD(wParam) == WA_INACTIVE) {
            SaveSettingsIfDirty(hDlg);
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_BTN_ADD:
            AddAppToList(hDlg);
            break;

        case IDC_BTN_REMOVE:
            RemoveSelectedApp(hDlg);
            break;

        case IDC_BTN_VIEW_LOG:
            DisplayLog(hDlg);
            break;

        case IDC_BTN_VIEW_EXTERNAL_LOG:
            DisplaySingleLog(hDlg);
            break;

        case IDC_BTN_OPTIONS:
            ViewOptions(hDlg);
            break;

        case IDC_BTN_RUN:
            RunSelectedApp(hDlg);
            break;

        case IDOK:
        case IDCANCEL:
            SaveSettings(hDlg);
            EndDialog(hDlg, LOWORD(wParam));
            PostQuitMessage(0);
            return TRUE;
            break;
        }
        break;

    case WM_NOTIFY:
        LPNMHDR pnmh = (LPNMHDR)lParam;

        HWND hItem = pnmh->hwndFrom;

        if (hItem == GetDlgItem(hDlg, IDC_LIST_APPS)) {
            switch (pnmh->code) {
            case LVN_KEYDOWN:
                {
                    LPNMLVKEYDOWN pnmkd = (LPNMLVKEYDOWN)lParam;

                    if (pnmkd->wVKey == VK_DELETE) {
                        if (IsWindowEnabled(GetDlgItem(hDlg, IDC_BTN_RUN))) {
                            RemoveSelectedApp(hDlg);
                        }
                    }
                }
                break;

            case LVN_ITEMCHANGED:
                LPNMLISTVIEW pnmv = (LPNMLISTVIEW)lParam;

                if (!g_bRefreshingSettings && (pnmv->uChanged & LVIF_STATE) && ((pnmv->uNewState ^ pnmv->uOldState) & LVIS_SELECTED)) {
                    g_bRefreshingSettings = TRUE;

                    RefreshSettingsList(hDlg);

                    g_bRefreshingSettings = FALSE;
                }

            }
        } else if (hItem == GetDlgItem(hDlg, IDC_LIST_SETTINGS)) {
            switch (pnmh->code) {
            case LVN_ITEMCHANGED:
                LPNMLISTVIEW pnmv = (LPNMLISTVIEW)lParam;

                if (!g_bRefreshingSettings) {
                    if ((pnmv->uChanged & LVIF_STATE) && ((pnmv->uNewState ^ pnmv->uOldState) & LVIS_SELECTED)) {
                        DisplaySettingsDescription(hDlg);
                    }
                    if ((pnmv->uChanged & LVIF_STATE) && ((pnmv->uNewState ^ pnmv->uOldState) >> 12) != 0) {
                        ScanSettingsList(hDlg, pnmv->iItem);
                    }
                }
                break;
            }
        }
        break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\appverifier\debugger.h ===
#ifndef __APPVERIFIER_DEBUGGER_H_
#define __APPVERIFIER_DEBUGGER_H_

#define MAX_BREAKPOINTS     32
#ifdef _X86_
#define BP_INSTR            0xcc
#define BP_SIZE             1
#else
#pragma message("Debugger Breakpoint support needed for this architecture")
#endif

typedef struct tagBP_INFO      *PBP_INFO;
typedef struct tagTHREAD_INFO  *PTHREAD_INFO;
typedef struct tagPROCESS_INFO *PPROCESS_INFO;

typedef DWORD (*PBP_HANDLER)(PPROCESS_INFO,
                             PTHREAD_INFO,
                             PEXCEPTION_RECORD,
                             PBP_INFO);

typedef struct tagBP_INFO {
    LPVOID        Address;
    ULONG         OriginalInstr;
    PBP_HANDLER   Handler;
} BP_INFO, *PBP_INFO;

typedef struct tagTHREAD_INFO {
    PTHREAD_INFO  pNext;
    HANDLE        hProcess;
    HANDLE        hThread;
    ULONG         dwThreadId;
    CONTEXT       Context;
} THREAD_INFO, *PTHREAD_INFO;

typedef struct tagPROCESS_INFO {
    PPROCESS_INFO pNext;
    HANDLE        hProcess;
    DWORD         dwProcessId;
    BOOL          bSeenLdrBp;
    LPVOID        EntryPoint;
    DEBUG_EVENT   DebugEvent;
    PTHREAD_INFO  pFirstThreadInfo;
    BP_INFO       bp[MAX_BREAKPOINTS];
} PROCESS_INFO, *PPROCESS_INFO;


SIZE_T
ReadMemoryDbg(
    HANDLE  hProcess,
    LPVOID  Address,
    LPVOID  Buffer,
    SIZE_T  Length
    );

BOOL
WriteMemoryDbg(
    HANDLE  hProcess,
    PVOID   Address,
    PVOID   Buffer,
    SIZE_T  Length
    );

DWORD WINAPI
DebugApp(
    LPTSTR pszAppName
    );

#endif // __APPVERIFIER_DEBUGGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\appverifier\dbsupport.h ===
#ifndef __APPVERIFIER_DBSUPPORT_H_
#define __APPVERIFIER_DBSUPPORT_H_

typedef enum {
    TEST_SHIM,
    TEST_KERNEL
} TestType;

typedef vector<wstring> CWStringArray;
          
class CTestInfo {
public:
    //
    // valid for all tests
    //
    TestType            eTestType;   
    wstring             strTestName;
    wstring             strTestDescription;
    wstring             strTestCommandLine;
    BOOL                bDefault;       // is this test turned on by default?

    //
    // if type is TEST_SHIM, the following are valid
    //
    wstring             strDllName;
    CWStringArray       astrIncludes;
    CWStringArray       astrExcludes;

    //
    // if type is TEST_KERNEL, the following are valid
    //
    DWORD               dwKernelFlag;

    CTestInfo(void) : 
        eTestType(TEST_SHIM), 
        dwKernelFlag(0),
        bDefault(TRUE) {}

};

typedef vector<CTestInfo> CTestInfoArray;

class CAVAppInfo {
public:
    wstring         wstrExeName;
    wstring         wstrExePath; // optional
    DWORD           dwRegFlags;
    CWStringArray   awstrShims;

    CAVAppInfo() : dwRegFlags(0) {}

    void
    AddTest(CTestInfo &Test) {
        if (Test.eTestType == TEST_KERNEL) {
            dwRegFlags |= Test.dwKernelFlag;
        } else {
            for (wstring *pStr = awstrShims.begin(); pStr != awstrShims.end(); ++pStr) {
                if (*pStr == Test.strTestName) {
                    return;
                }
            }
            // not found, so add
            awstrShims.push_back(Test.strTestName);
        }
    }

    void
    RemoveTest(CTestInfo &Test) {
        if (Test.eTestType == TEST_KERNEL) {
            dwRegFlags &= ~(Test.dwKernelFlag);
        } else {
            for (wstring *pStr = awstrShims.begin(); pStr != awstrShims.end(); ++pStr) {
                if (*pStr == Test.strTestName) {
                    awstrShims.erase(pStr);
                    return;
                }
            }
        }
    }

    BOOL
    IsTestActive(CTestInfo &Test) {
        if (Test.eTestType == TEST_KERNEL) {
            return (dwRegFlags & Test.dwKernelFlag) == Test.dwKernelFlag;
        } else {
            for (wstring *pStr = awstrShims.begin(); pStr != awstrShims.end(); ++pStr) {
                if (*pStr == Test.strTestName) {
                    return TRUE;
                }
            }
            return FALSE;
        }
    }

};

typedef vector<CAVAppInfo> CAVAppInfoArray;

typedef struct _KERNEL_TEST_INFO
{
    ULONG   m_uNameStringId;
    ULONG   m_uDescriptionStringId;
    DWORD   m_dwBit;
    BOOL    m_bDefault;
    LPWSTR  m_szCommandLine;   
} KERNEL_TEST_INFO, *PKERNEL_TEST_INFO;


extern CAVAppInfoArray g_aAppInfo;

extern CTestInfoArray g_aTestInfo;

void 
ResetVerifierLog(void);

BOOL 
InitTestInfo(void);

void
GetCurrentAppSettings(void);

void
SetCurrentAppSettings(void);

BOOL 
AppCompatWriteShimSettings(
    CAVAppInfoArray&    arrAppInfo
    );

BOOL
AppCompatDeleteSettings(
    void
    );

#endif // __APPVERIFIER_DBSUPPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\appverifier\avutil.h ===
#ifndef __APP_VERIFIER_UTIL_H__
#define __APP_VERIFIER_UTIL_H__


///////////////////////////////////////////////////////////////////////////
//
// Report an error using a dialog box.
// The message format string is loaded from the resources.
//

void __cdecl
AVErrorResourceFormat(
    UINT uIdResourceFormat,
    ...
    );


///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//
// N.B. CString::LoadString doesn't work in cmd line mode
//

BOOL
AVLoadString(
    ULONG  uIdResource,
    WCHAR* szBuffer,
    ULONG  uBufferLength
    );

///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//
// N.B. CString::LoadString doesn't work in cmd line mode
//

BOOL
AVLoadString(
    ULONG    uIdResource,
    wstring& strText
    );


/////////////////////////////////////////////////////////////////////////////
BOOL
AVRtlCharToInteger(
    IN  LPCTSTR String,
    IN  ULONG   Base OPTIONAL,
    OUT PULONG  Value
    );

/////////////////////////////////////////////////////////////////////////////
BOOL
AVWriteStringHexValueToRegistry(
    HKEY    hKey,
    LPCTSTR szValueName,
    DWORD   dwValue
    );


#endif //#ifndef __APP_VERIFIER_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\appverifier\ids.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AppVerifier.rc
//
#define IDD_DLG_MAIN                    101
#define IDD_DIALOG1                     102
#define IDD_OPTIONS                     102
#define IDC_LIST_APPS                   1000
#define IDC_LIST_SETTINGS               1001
#define IDC_BTN_SAVE_SETTINGS           1002
#define IDC_BTN_OPTIONS                 1003
#define IDC_BTN_VIEW_LOG                1004
#define IDC_BTN_ADD                     1005
#define IDC_BTN_REMOVE                  1006
#define IDC_BTN_RUN                     1007
#define IDC_STATIC_DESC                 1008
#define IDC_BTN_DELETE_ALL              1009
#define IDC_CLEAR_LOG_ON_CHANGES        1009
#define IDC_BTN_DELETE_LOG              1010
#define IDC_BREAK_ON_LOG                1010
#define IDC_LIGHT_PAGEHEAP              1011
#define IDC_FULL_PAGEHEAP               1011
#define IDC_BTN_VIEW_EXTERNAL_LOG       1012
#define IDC_PRE_GUARD                   1012
#define IDC_BTN_EXPORT_LOG              1013
#define IDC_USE_AV_DEBUGGER             1015
#define IDC_ISSUE_DESCRIPTION           1016
#define IDC_ISSUES                      1017
#define IDC_SOLUTIONS_STATIC            1018
#define IDS_APPTITLE                    1202
#define IDS_CANNOT_LOAD_APP_TITLE       1203
#define IDS_NOT_ENOUGH_MEMORY           1204
#define IDS_ACCESS_IS_DENIED            1220
#define IDS_REGOPENKEYEX_FAILED         1221
#define IDS_REGENUMKEYEX_FAILED         1222
#define IDS_REGQUERYVALUEEX_FAILED      1224
#define IDS_INVALID_PARAMETER           1225
#define IDS_INVALID_TEST                1226
#define IDS_NO_APP                      1227
#define IDR_MAINFRAME                   1228
#define IDS_VERIFY_LOCKS_CHECKS         1231
#define IDS_VERIFY_HANDLE_CHECKS        1232
#define IDS_PAGE_HEAP                   1233
#define IDS_VERIFY_STACK_CHECKS         1234
#define IDS_VERIFY_LOCKS_CHECKS_DESC    1305
#define IDS_VERIFY_HANDLE_CHECKS_DESC   1306
#define IDS_PAGE_HEAP_DESC              1307
#define IDS_VERIFY_STACK_CHECKS_DESC    1308
#define IDS_CANT_LAUNCH_EXE             1309
#define IDS_VIEW_TEST_DESC              1310
#define IDS_CANT_COPY                   1311
#define IDS_LOG_TITLE_SINGLE            1500
#define IDS_LOG_TITLE_LOCAL             1501
#define IDS_APP_NAME                    1600
#define IDS_VERSION_STRING              1601
#define IDS_COPYRIGHT                   1602
#define IDS_VIEW_EXPORTED_LOG_TITLE     1603
#define IDS_ADD_APPLICATION_TITLE       1604
#define IDS_EXPORT_LOG_TITLE            1605
#define IDD_VIEWLOG_PAGE                2007
#define IDI_ICON                        3001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1020
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\appverifier\crash.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    crash.h

Abstract:

    This module implements support for handling crash dump files.

    *** Use this file when linking against crashxxx.lib

Author:

    Lou Perazzoli (Loup) 10-Nov-1993
    Wesley Witt   (wesw) 1-Dec-1993   (additional work)

Environment:

    NT 3.5

Revision History:

--*/

#ifndef _CRASHLIB_
#define _CRASHLIB_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4200)
extern "C" {
#endif

#if 0
typedef struct _MEMORY_BASIC_INFORMATION32 {
    DWORD BaseAddress;
    DWORD AllocationBase;
    DWORD AllocationProtect;
    DWORD RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION32, *PMEMORY_BASIC_INFORMATION32;

typedef struct _MEMORY_BASIC_INFORMATION64 {
    DWORDLONG BaseAddress;
    DWORDLONG AllocationBase;
    DWORD     AllocationProtect;
    DWORD     __alignment1;
    DWORDLONG RegionSize;
    DWORD     State;
    DWORD     Protect;
    DWORD     Type;
    DWORD     __alignment2;
} MEMORY_BASIC_INFORMATION64, *PMEMORY_BASIC_INFORMATION64;
#endif

#define USERMODE_CRASHDUMP_SIGNATURE    'RESU'
#define USERMODE_CRASHDUMP_VALID_DUMP32 'PMUD'
#define USERMODE_CRASHDUMP_VALID_DUMP64 '46UD'

typedef struct _USERMODE_CRASHDUMP_HEADER {
    DWORD       Signature;
    DWORD       ValidDump;
    DWORD       MajorVersion;
    DWORD       MinorVersion;
    DWORD       MachineImageType;
    DWORD       ThreadCount;
    DWORD       ModuleCount;
    DWORD       MemoryRegionCount;
    DWORD_PTR   ThreadOffset;
    DWORD_PTR   ModuleOffset;
    DWORD_PTR   DataOffset;
    DWORD_PTR   MemoryRegionOffset;
    DWORD_PTR   DebugEventOffset;
    DWORD_PTR   ThreadStateOffset;
    DWORD_PTR   VersionInfoOffset;
    DWORD_PTR   Spare1;
} USERMODE_CRASHDUMP_HEADER, *PUSERMODE_CRASHDUMP_HEADER;

typedef struct _USERMODE_CRASHDUMP_HEADER32 {
    DWORD       Signature;
    DWORD       ValidDump;
    DWORD       MajorVersion;
    DWORD       MinorVersion;
    DWORD       MachineImageType;
    DWORD       ThreadCount;
    DWORD       ModuleCount;
    DWORD       MemoryRegionCount;
    DWORD       ThreadOffset;
    DWORD       ModuleOffset;
    DWORD       DataOffset;
    DWORD       MemoryRegionOffset;
    DWORD       DebugEventOffset;
    DWORD       ThreadStateOffset;
    DWORD       VersionInfoOffset;
    DWORD       Spare1;
} USERMODE_CRASHDUMP_HEADER32, *PUSERMODE_CRASHDUMP_HEADER32;

typedef struct _USERMODE_CRASHDUMP_HEADER64 {
    DWORD       Signature;
    DWORD       ValidDump;
    DWORD       MajorVersion;
    DWORD       MinorVersion;
    DWORD       MachineImageType;
    DWORD       ThreadCount;
    DWORD       ModuleCount;
    DWORD       MemoryRegionCount;
    DWORDLONG   ThreadOffset;
    DWORDLONG   ModuleOffset;
    DWORDLONG   DataOffset;
    DWORDLONG   MemoryRegionOffset;
    DWORDLONG   DebugEventOffset;
    DWORDLONG   ThreadStateOffset;
    DWORDLONG   VersionInfoOffset;
    DWORDLONG   Spare1;
} USERMODE_CRASHDUMP_HEADER64, *PUSERMODE_CRASHDUMP_HEADER64;

typedef struct _CRASH_MODULE {
    DWORD_PTR   BaseOfImage;
    DWORD       SizeOfImage;
    DWORD       ImageNameLength;
    CHAR        ImageName[0];
} CRASH_MODULE, *PCRASH_MODULE;

typedef struct _CRASH_MODULE32 {
    DWORD       BaseOfImage;
    DWORD       SizeOfImage;
    DWORD       ImageNameLength;
    CHAR        ImageName[0];
} CRASH_MODULE32, *PCRASH_MODULE32;

typedef struct _CRASH_MODULE64 {
    DWORDLONG   BaseOfImage;
    DWORD       SizeOfImage;
    DWORD       ImageNameLength;
    CHAR        ImageName[0];
} CRASH_MODULE64, *PCRASH_MODULE64;

typedef struct _CRASH_THREAD {
    DWORD       ThreadId;
    DWORD       SuspendCount;
    DWORD       PriorityClass;
    DWORD       Priority;
    DWORD_PTR   Teb;
    DWORD_PTR   Spare0;
    DWORD_PTR   Spare1;
    DWORD_PTR   Spare2;
    DWORD_PTR   Spare3;
    DWORD_PTR   Spare4;
    DWORD_PTR   Spare5;
    DWORD_PTR   Spare6;
} CRASH_THREAD, *PCRASH_THREAD;

typedef struct _CRASH_THREAD32 {
    DWORD       ThreadId;
    DWORD       SuspendCount;
    DWORD       PriorityClass;
    DWORD       Priority;
    DWORD       Teb;
    DWORD       Spare0;
    DWORD       Spare1;
    DWORD       Spare2;
    DWORD       Spare3;
    DWORD       Spare4;
    DWORD       Spare5;
    DWORD       Spare6;
} CRASH_THREAD32, *PCRASH_THREAD32;

typedef struct _CRASH_THREAD64 {
    DWORD       ThreadId;
    DWORD       SuspendCount;
    DWORD       PriorityClass;
    DWORD       Priority;
    DWORDLONG   Teb;
    DWORDLONG   Spare0;
    DWORDLONG   Spare1;
    DWORDLONG   Spare2;
    DWORDLONG   Spare3;
    DWORDLONG   Spare4;
    DWORDLONG   Spare5;
    DWORDLONG   Spare6;
} CRASH_THREAD64, *PCRASH_THREAD64;


typedef struct _CRASHDUMP_VERSION_INFO {
    BOOL    IgnoreGuardPages;       // Whether we should ignore GuardPages or not
    DWORD   PointerSize;            // 32, 64 bit pointers
} CRASHDUMP_VERSION_INFO, *PCRASHDUMP_VERSION_INFO;

//
// usermode crash dump data types
//
#define DMP_EXCEPTION                 1 // obsolete
#define DMP_MEMORY_BASIC_INFORMATION  2
#define DMP_THREAD_CONTEXT            3
#define DMP_MODULE                    4
#define DMP_MEMORY_DATA               5
#define DMP_DEBUG_EVENT               6
#define DMP_THREAD_STATE              7
#define DMP_DUMP_FILE_HANDLE          8

//
// If a user mode API fails, GetLastError may return one of these error values
//
#define ERROR_DMP_INITIALIZENOTCALLED       _HRESULT_TYPEDEF_(0xEFFF0001)
#define ERROR_DMP_NOTUSERMODE               _HRESULT_TYPEDEF_(0xEFFF0002)
#define ERROR_DMP_HDR_THREADCOUNT           _HRESULT_TYPEDEF_(0xEFFF0003)
#define ERROR_DMP_HDR_MODULECOUNT           _HRESULT_TYPEDEF_(0xEFFF0004)
#define ERROR_DMP_HDR_MEMORYREGIONCOUNT     _HRESULT_TYPEDEF_(0xEFFF0005)
#define ERROR_DMP_HDR_THREADOFFSET          _HRESULT_TYPEDEF_(0xEFFF0006)
#define ERROR_DMP_HDR_MODULEOFFSET          _HRESULT_TYPEDEF_(0xEFFF0007)
#define ERROR_DMP_HDR_DATAOFFSET            _HRESULT_TYPEDEF_(0xEFFF0008)
#define ERROR_DMP_HDR_MEMORYREGIONOFFSET    _HRESULT_TYPEDEF_(0xEFFF0009)
#define ERROR_DMP_HDR_DEBUGEVENTOFFSET      _HRESULT_TYPEDEF_(0xEFFF000A)
#define ERROR_DMP_HDR_THREADSTATEOFFSET     _HRESULT_TYPEDEF_(0xEFFF000B)
#define ERROR_DMP_HDR_VERSIONINFOOFFSET     _HRESULT_TYPEDEF_(0xEFFF000C)
#define ERROR_DMP_HDR_SPARE1                _HRESULT_TYPEDEF_(0xEFFF000D)
#define ERROR_DMP_OLD_VERSION               _HRESULT_TYPEDEF_(0xEFFF000E)

//
// usermode crashdump error values
//
#define ERROR_DMP_DEBUG_EVENT               _HRESULT_TYPEDEF_(0xEFFF000F)
#define ERROR_DMP_MEMORY_MAP                _HRESULT_TYPEDEF_(0xEFFF0010)
#define ERROR_DMP_THREAD_CONTEXT            _HRESULT_TYPEDEF_(0xEFFF0011)
#define ERROR_DMP_THREAD_STATE              _HRESULT_TYPEDEF_(0xEFFF0012)
#define ERROR_DMP_MODULE_TABLE              _HRESULT_TYPEDEF_(0xEFFF0013)

//
// usermode crashdump callback function
//
typedef BOOL  (WINAPI *PDMP_CREATE_DUMP_CALLBACK)(
    DWORD       DataType,
    PVOID*      DumpData,
    LPDWORD     DumpDataLength,
    PVOID       UserData
    );

BOOL
WINAPI
DmpCreateUserDump(
    IN LPSTR                       CrashDumpName,
    IN PDMP_CREATE_DUMP_CALLBACK   DmpCallback,
    IN PVOID                       lpv
    );

BOOL
WINAPI
DmpCreateUserDumpW(
    IN LPWSTR                      CrashDumpName,
    IN PDMP_CREATE_DUMP_CALLBACK   DmpCallback,
    IN PVOID                       lpv
    );

BOOL
WINAPI
DmpInitialize (
    IN  LPSTR               FileName,
    OUT PCONTEXT            *Context,
    OUT PEXCEPTION_RECORD   *Exception,
    OUT PVOID               *DmpHeader
    );

VOID
WINAPI
DmpUnInitialize (
    VOID
    );

DWORD
WINAPI
DmpReadMemory (
    IN ULONG64 BaseAddress,
    IN PVOID Buffer,
    IN ULONG Size
    );

DWORD
WINAPI
DmpWriteMemory (
    IN ULONG64 BaseAddress,
    IN PVOID Buffer,
    IN ULONG Size
    );

DWORD
WINAPI
DmpReadPhysicalMemory (
    IN ULONG64 BaseAddress,
    IN PVOID Buffer,
    IN ULONG Size
    );

DWORD
WINAPI
DmpWritePhysicalMemory (
    IN ULONG64 BaseAddress,
    IN PVOID Buffer,
    IN ULONG Size
    );

DWORD
WINAPI
DmpReadFileByteOffset (
    IN ULONG FileByteOffset,
    IN PVOID Buffer,
    IN ULONG Size
    );


BOOL
WINAPI
DmpReadControlSpace(
    IN USHORT   Processor,
    IN ULONG64  TargetBaseAddress,
    OUT PVOID   UserInterfaceBuffer,
    OUT ULONG   TransferCount,
    OUT PULONG  ActualBytesRead
    );

BOOL
WINAPI
DmpGetContext(
    IN  ULONG     Processor,
    OUT PVOID     Context
    );

INT
WINAPI
DmpGetCurrentProcessor(
    VOID
    );

BOOL
WINAPI
DmpGetThread(
    IN  ULONG           ThreadIndex,
    OUT PCRASH_THREAD   Thread
    );

BOOL
WINAPI
DmpDetectVersionParameters(
    CRASHDUMP_VERSION_INFO* VersionInfo
    );

BOOL
WINAPI
DmpSetVersionParameters(
    PCRASHDUMP_VERSION_INFO VersionInfo
    );

BOOL
WINAPI
DmpValidateDumpFile(
    BOOL ThoroughCheck
    );

#ifdef __cplusplus
}
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4200)
#endif
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\appverifier\avutil.cpp ===
#include "precomp.h"

#include "AVUtil.h"

VOID
DebugPrintf(
    LPCSTR pszFmt, 
    ...
    )
{
    char szT[1024];

    va_list vaArgList;
    va_start(vaArgList, pszFmt);

    _vsnprintf(szT, 1023, pszFmt, vaArgList);

    // make sure we have a '\n' at the end of the string

    int len = strlen(szT);

    if (szT[len - 1] != '\n') {
        strcpy(szT + len, "\n");
    }


    OutputDebugStringA(szT);

    va_end(vaArgList);
}

///////////////////////////////////////////////////////////////////////////
//
// Report an error using a dialog box or a console message.
// The message format string is loaded from the resources.
//

void __cdecl
AVErrorResourceFormat(
    UINT uIdResourceFormat,
    ...
    )
{
    WCHAR   szMessage[2048];
    WCHAR   strFormat[2048];
    BOOL    bResult;
    va_list prms;

    //
    // Load the format string from the resources
    //

    bResult = AVLoadString(uIdResourceFormat,
                           strFormat,
                           ARRAY_LENGTH(strFormat));

    ASSERT(bResult);

    if (bResult) {
        va_start (prms, uIdResourceFormat);

        //
        // Format the message in our local buffer
        //

        _vsnwprintf(szMessage,
                    ARRAY_LENGTH(szMessage),
                    strFormat,
                    prms);

        if (g_bConsoleMode) {
            printf("Error: %ls\n", szMessage); 

        } else {
            //
            // GUI mode
            //
            MessageBox(NULL, szMessage, L"Application Verifier", 
                       MB_OK | MB_ICONSTOP );
        }

        va_end(prms);
    }
}

///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//

BOOL
AVLoadString(
    ULONG  uIdResource,
    WCHAR* szBuffer,
    ULONG  uBufferLength
    )
{
    ULONG uLoadStringResult;

    if (uBufferLength < 1) {
        ASSERT(FALSE);
        return FALSE;
    }

    uLoadStringResult = LoadStringW(g_hInstance,
                                    uIdResource,
                                    szBuffer,
                                    uBufferLength);

    return (uLoadStringResult > 0);
}

///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//

BOOL
AVLoadString(
    ULONG    uIdResource,
    wstring& strText
    )
{
    WCHAR szText[4096];
    BOOL  bSuccess;

    bSuccess = AVLoadString(uIdResource,
                            szText,
                            ARRAY_LENGTH(szText));

    if (bSuccess) {
        strText = szText;
    } else {
        strText = L"";
    }

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
BOOL
AVRtlCharToInteger(
    IN  LPCWSTR String,
    IN  ULONG   Base OPTIONAL,
    OUT PULONG  Value
    )
{
    WCHAR c, Sign;
    ULONG Result, Digit, Shift;

    while ((Sign = *String++) <= L' ') {
        if (!*String) {
            String--;
            break;
        }
    }

    c = Sign;
    if (c == L'-' || c == L'+') {
        c = *String++;
    }

    if ( Base == 0 ) {
        Base = 10;
        Shift = 0;
        if (c == L'0' ) {
            c = *String++;
            if (c == L'x') {
                Base = 16;
                Shift = 4;
            } else
                if (c == L'o') {
                Base = 8;
                Shift = 3;
            } else
                if (c == L'b') {
                Base = 2;
                Shift = 1;
            } else {
                String--;
            }

            c = *String++;
        }
    } else {
        switch ( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;
        case 10:    Shift = 0;  break;
        default:    return FALSE;
        }
    }

    Result = 0;
    while (c) {
        if (c >= _T( '0' ) && c <= _T( '9' ) ) {
            Digit = c - '0';
        } else
            if (c >= _T( 'A' ) && c <= _T( 'F' ) ) {
            Digit = c - 'A' + 10;
        } else
            if (c >= _T( 'a' ) && c <= _T( 'f' ) ) {
            Digit = c - _T( 'a' ) + 10;
        } else {
            break;
        }

        if (Digit >= Base) {
            break;
        }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
        } else {
            Result = (Result << Shift) | Digit;
        }

        c = *String++;
    }

    if (Sign == _T('-')) {
        Result = (ULONG)(-(LONG)Result);
    }

    *Value = Result;

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL
AVWriteStringHexValueToRegistry(
    HKEY    hKey,
    LPCWSTR szValueName,
    DWORD   dwValue
    )
{
    LONG lResult;
    WCHAR szValue[ 32 ];

    swprintf(szValue,
             L"0x%08X",
             dwValue);

    lResult = RegSetValueEx(hKey,
                            szValueName,
                            0,
                            REG_SZ,
                            (BYTE *)szValue,
                            wcslen(szValue) * sizeof(WCHAR) + sizeof(WCHAR));

    return (lResult == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\appverifier\userdumpp.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    drwatson.h

Abstract:

    Common header file for drwatson data structures.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include <tchar.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <dbghelp.h>

// Implemented in crashlib
PWSTR AsiToUnicode(PSTR);
PSTR UnicodeToAnsi(PWSTR);

typedef enum _CrashDumpType {
    FullDump  = 0,
    MiniDump  = 1,
    FullMiniDump = 2,
} CrashDumpType;

typedef struct _tagOPTIONS {
    _TCHAR                      szLogPath[MAX_PATH];
    _TCHAR                      szWaveFile[MAX_PATH];
    _TCHAR                      szCrashDump[MAX_PATH];
    BOOL                        fDumpSymbols;
    BOOL                        fDumpAllThreads;
    BOOL                        fAppendToLogFile;
    BOOL                        fVisual;
    BOOL                        fSound;
    BOOL                        fCrash;
    // true: Generate user dump name in the range from fname000.dmp to fname999.dmp
    // false: standard behavior, always overwrite fname.dmp when generating a new
    //      dump file.
    BOOL                        fUseSequentialNaming;
    // If TRUE use long file names when sequentially naming the dumps
    // If FALSE use 8.3 file names when sequentially naming the dumps
    //      causes the 'n' of characters to be removed from the end of the
    //      file name to make it fit in the 8.3 format. ie longuser.dmp -> longus00.dmp
    BOOL                        fUseLongFileNames;
    int                         nNextDumpSequence;
    DWORD                       dwInstructions;
    DWORD                       dwMaxCrashes;
    CrashDumpType               dwType;
} OPTIONS, *POPTIONS;

typedef struct _tagCRASHES {
    _TCHAR                      szAppName[256];
    _TCHAR                      szFunction[256];
    SYSTEMTIME                  time;
    DWORD                       dwExceptionCode;
    DWORD_PTR                   dwAddress;
} CRASHES, *PCRASHES;

typedef struct _tagCRASHINFO {
    HWND       hList;
    CRASHES    crash;
    HDC        hdc;
    DWORD      cxExtent;
    DWORD      dwIndex;
    DWORD      dwIndexDesired;
    BYTE      *pCrashData;
    DWORD      dwCrashDataSize;
} CRASHINFO, *PCRASHINFO;

typedef struct _tagTHREADCONTEXT {
    LIST_ENTRY                   ThreadList;
    HANDLE                       hThread;
    DWORD                        dwThreadId;
    DWORD_PTR                    pc;
    DWORD_PTR                    frame;
    DWORD_PTR                    stack;
    CONTEXT                      context;
    DWORD_PTR                    stackBase;
    DWORD_PTR                    stackRA;
    BOOL                         fFaultingContext;
} THREADCONTEXT, *PTHREADCONTEXT;


typedef BOOL (CALLBACK* CRASHESENUMPROC)(PCRASHINFO);

//
// process list structure returned from GetSystemProcessList()
//
typedef struct _PROCESS_LIST {
    DWORD       dwProcessId;
    _TCHAR      ProcessName[MAX_PATH];
} PROCESS_LIST, *PPROCESS_LIST;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\appverifier\dbsupport.cpp ===
#include "precomp.h"

#include "ntexapi.h"

extern BOOL g_bClearSessionLogBeforeRun;
extern BOOL g_bUseAVDebugger;

TCHAR  g_szXML[32768];

TCHAR  g_szCmd[1024];

/////////////////////////////////////////////////////////////////////////////
//
// Registry keys/values names
//

const TCHAR g_szImageOptionsKeyName[] = _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options");
const TCHAR g_szGlobalFlagValueName[] = _T("GlobalFlag");
const TCHAR g_szVerifierFlagsValueName[] = _T("VerifierFlags");
const TCHAR g_szVerifierPathValueName[] = _T("VerifierPath");
const TCHAR g_szDebugger[] = _T("Debugger");

CAVAppInfoArray g_aAppInfo;

CTestInfoArray  g_aTestInfo;

BOOL
SetAppVerifierFlagsForKey(
    HKEY  hKey,
    DWORD dwDesiredFlags
    )
{
    BOOL  bRet = FALSE;
    DWORD dwValueType = 0;
    DWORD dwDataSize = 0;
    TCHAR szOldGlobalFlagValue[32];
    BOOL  bSuccesfullyConverted;
    BOOL  bDesireEnabled = (dwDesiredFlags != 0);
    LONG  lResult;
    DWORD dwFlags = 0;

    //
    // Read the GlobalFlag value
    //
    dwDataSize = sizeof(szOldGlobalFlagValue);

    lResult = RegQueryValueEx(hKey,
                              g_szGlobalFlagValueName,
                              NULL,
                              &dwValueType,
                              (LPBYTE) &szOldGlobalFlagValue[0],
                              &dwDataSize);

    if (ERROR_SUCCESS == lResult) {
        bSuccesfullyConverted = AVRtlCharToInteger(szOldGlobalFlagValue,
                                                   0,
                                                   &dwFlags);
        if (!bSuccesfullyConverted) {
            dwFlags = 0;
        }
    }

    BOOL bEnabled = (dwFlags & FLG_APPLICATION_VERIFIER) != 0;

    //
    // write the new global flags, if necessary
    //
    if (bDesireEnabled != bEnabled) {
        if (bDesireEnabled) {
            dwFlags |= FLG_APPLICATION_VERIFIER;
        } else {
            dwFlags &= ~FLG_APPLICATION_VERIFIER;
        }

        BOOL bSuccess = AVWriteStringHexValueToRegistry(hKey,
                                                        g_szGlobalFlagValueName,
                                                        dwFlags);
        if (!bSuccess) {
            goto out;
        }
    }

    //
    // now write the app verifier settings
    //
    if (bDesireEnabled) {
        lResult = RegSetValueEx(hKey,
                                g_szVerifierFlagsValueName,
                                0,
                                REG_DWORD,
                                (PBYTE) &dwDesiredFlags,
                                sizeof(dwDesiredFlags));
        if (lResult != ERROR_SUCCESS) {
            goto out;
        }
    } else {
        lResult = RegDeleteValue(hKey, g_szVerifierFlagsValueName);
        if (lResult != ERROR_SUCCESS) {
            goto out;
        }
    }

    bRet = TRUE;

out:
    return bRet;
}

DWORD
GetAppVerifierFlagsFromKey(
    HKEY hKey
    )
{
    DWORD   dwRet = 0;
    DWORD   dwValueType = 0;
    DWORD   dwDataSize = 0;
    TCHAR   szOldGlobalFlagValue[32];
    BOOL    bSuccesfullyConverted;
    LONG    lResult;
    DWORD   dwFlags = 0;

    //
    // Read the GlobalFlag value
    //
    dwDataSize = sizeof(szOldGlobalFlagValue);

    lResult = RegQueryValueEx(hKey,
                              g_szGlobalFlagValueName,
                              NULL,
                              &dwValueType,
                              (LPBYTE)&szOldGlobalFlagValue[0],
                              &dwDataSize);

    if (ERROR_SUCCESS == lResult) {
        bSuccesfullyConverted = AVRtlCharToInteger(szOldGlobalFlagValue,
                                                   0,
                                                   &dwFlags);

        if ((FALSE != bSuccesfullyConverted) && 
             ((dwFlags & FLG_APPLICATION_VERIFIER) != 0)) {
            //
            // App verifier is enabled for this app - read the verifier flags
            //

            dwDataSize = sizeof(dwRet);

            lResult = RegQueryValueEx(hKey,
                                      g_szVerifierFlagsValueName,
                                      NULL,
                                      &dwValueType,
                                      (LPBYTE)&dwRet,
                                      &dwDataSize);

            if (ERROR_SUCCESS != lResult || REG_DWORD != dwValueType) {
                //
                // couldn't get them, for one reason or another
                //
                dwRet = 0;
            }
        }
    }

    return dwRet;
}

void
SetAppVerifierFullPathForKey(
    HKEY     hKey,
    wstring& strPath
    )
{
    if (strPath.size() == 0) {
        RegDeleteValue(hKey, g_szVerifierPathValueName);
    } else {
        RegSetValueEx(hKey,
                        g_szVerifierPathValueName,
                        0,
                        REG_SZ,
                        (PBYTE) strPath.c_str(),
                        strPath.size() * sizeof(WCHAR));
    }
}

void
SetDebuggerOptionsForKey(
    HKEY     hKey,
    BOOL     bUseAVDebugger
    )
{
    WCHAR szName[MAX_PATH];
    
    szName[0] = 0;

    GetModuleFileName(NULL, szName, MAX_PATH);

    wcscat(szName, L" /debug");
    
    if (bUseAVDebugger) {
        RegSetValueEx(hKey,
                        g_szDebugger,
                        0,
                        REG_SZ,
                        (PBYTE)szName,
                        wcslen(szName) * sizeof(WCHAR));
    } else {
        
        WCHAR szDbgName[MAX_PATH];
        DWORD cbSize;
        
        cbSize = MAX_PATH * sizeof(WCHAR);

        szDbgName[0] = 0;

        RegQueryValueEx(hKey,
                        g_szDebugger,
                        0,
                        NULL,
                        (PBYTE)szDbgName,
                        &cbSize);

        if (_wcsicmp(szName, szDbgName) == 0) {
            RegDeleteValue(hKey, g_szDebugger);
        }
    }
}


void
GetAppVerifierFullPathFromKey(
    HKEY     hKey,
    wstring& strPath
    )
{
    DWORD   dwValueType = 0;
    DWORD   dwDataSize = 0;
    TCHAR   szVerifierPath[MAX_PATH];
    LONG    lResult;

    //
    // Read the GlobalFlag value
    //
    dwDataSize = sizeof(szVerifierPath);

    szVerifierPath[0] = 0;

    lResult = RegQueryValueEx(hKey,
                              g_szVerifierPathValueName,
                              NULL,
                              &dwValueType,
                              (LPBYTE)szVerifierPath,
                              &dwDataSize);

    if (ERROR_SUCCESS == lResult && dwValueType == REG_SZ) {
        strPath = szVerifierPath;
    }
}

void
GetCurrentAppSettingsFromRegistry(
    void
    )
{
    HKEY        hImageOptionsKey;
    HKEY        hSubKey;
    DWORD       dwSubkeyIndex;
    DWORD       dwDataSize;
    DWORD       dwValueType;
    DWORD       dwFlags;
    LONG        lResult;
    FILETIME    LastWriteTime;
    TCHAR       szOldGlobalFlagValue[32];
    TCHAR       szKeyNameBuffer[256];

    //
    // Open the Image File Execution Options regkey
    //
    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           g_szImageOptionsKeyName,
                           0,
                           KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS,
                           &hImageOptionsKey);

    if (lResult != ERROR_SUCCESS) {
        if (lResult == ERROR_ACCESS_DENIED) {
            AVErrorResourceFormat(IDS_ACCESS_IS_DENIED);
        } else {
            AVErrorResourceFormat(IDS_REGOPENKEYEX_FAILED,
                                  g_szImageOptionsKeyName,
                                  (DWORD)lResult);
        }

        return;
    }

    //
    // Enumerate all the existing subkeys for app execution options
    //
    for (dwSubkeyIndex = 0; TRUE; dwSubkeyIndex += 1) {
        wstring wstrPath;

        dwDataSize = ARRAY_LENGTH(szKeyNameBuffer);

        lResult = RegEnumKeyEx(hImageOptionsKey,
                               dwSubkeyIndex,
                               szKeyNameBuffer,
                               &dwDataSize,
                               NULL,
                               NULL,
                               NULL,
                               &LastWriteTime);

        if (lResult != ERROR_SUCCESS) {
            if (lResult == ERROR_NO_MORE_ITEMS) {
                //
                // We finished looking at all the existing subkeys
                //
                break;
            } else {
                if (lResult == ERROR_ACCESS_DENIED) {
                    AVErrorResourceFormat(IDS_ACCESS_IS_DENIED);
                } else {
                    AVErrorResourceFormat(IDS_REGENUMKEYEX_FAILED,
                                          g_szImageOptionsKeyName,
                                          (DWORD)lResult);
                }

                goto CleanUpAndDone;
            }
        }

        //
        // Open the subkey
        //
        lResult = RegOpenKeyEx(hImageOptionsKey,
                               szKeyNameBuffer,
                               0,
                               KEY_QUERY_VALUE | KEY_SET_VALUE,
                               &hSubKey);

        if (lResult != ERROR_SUCCESS) {
            if (lResult == ERROR_ACCESS_DENIED) {
                AVErrorResourceFormat(IDS_ACCESS_IS_DENIED);
            } else {
                AVErrorResourceFormat(IDS_REGOPENKEYEX_FAILED,
                                      szKeyNameBuffer,
                                      (DWORD)lResult);
            }

            goto CleanUpAndDone;
        }

        dwFlags = GetAppVerifierFlagsFromKey(hSubKey);
        GetAppVerifierFullPathFromKey(hSubKey, wstrPath);
        
        if (dwFlags || wstrPath.size()) {
            //
            // Update the info in the array, or add it if necessary
            //
            CAVAppInfo* pApp;
            BOOL        bFound = FALSE;

            for (pApp = g_aAppInfo.begin(); pApp != g_aAppInfo.end(); pApp++) {
                if (_wcsicmp(pApp->wstrExeName.c_str(), szKeyNameBuffer) == 0) {
                    bFound = TRUE;
                    pApp->dwRegFlags = dwFlags;
                    pApp->wstrExePath = wstrPath;
                    break;
                }
            }

            if (!bFound) {
                CAVAppInfo  AppInfo;
                AppInfo.wstrExeName = szKeyNameBuffer;
                AppInfo.dwRegFlags = dwFlags;
                AppInfo.wstrExePath = wstrPath;

                g_aAppInfo.push_back(AppInfo);
            }
        }

        VERIFY(ERROR_SUCCESS == RegCloseKey(hSubKey));
    }

CleanUpAndDone:

    VERIFY(ERROR_SUCCESS == RegCloseKey(hImageOptionsKey));
}

void
GetCurrentAppSettingsFromSDB(
    void
    )
{
    CAVAppInfo  AppInfo;
    TCHAR       szPath[MAX_PATH];
    PDB         pdb = NULL;
    TAGID       tiDB = TAGID_NULL;
    TAGID       tiExe = TAGID_NULL;

    //
    // go find the SDB
    //
    szPath[0] = 0;
    GetSystemWindowsDirectory(szPath, MAX_PATH);
    _tcscat(szPath, _T("\\AppPatch\\Custom\\{448850f4-a5ea-4dd1-bf1b-d5fa285dc64b}.sdb"));

    pdb = SdbOpenDatabase(szPath, DOS_PATH);
    if (!pdb) {
        //
        // no current DB
        //
        goto out;
    }

    //
    // enumerate all the apps and the shims applied to them
    //
    tiDB = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);
    if (!tiDB) {
        goto out;
    }

    tiExe = SdbFindFirstTag(pdb, tiDB, TAG_EXE);
    
    while (tiExe) {
        WCHAR* wszName = NULL;
        TAGID  tiShim = TAGID_NULL;
        TAGID  tiName = SdbFindFirstTag(pdb, tiExe, TAG_NAME);

        if (!tiName) {
            goto nextExe;
        }
        wszName = SdbGetStringTagPtr(pdb, tiName);

        CAVAppInfoArray::iterator it;
        BOOL bFound = FALSE;

        for (it = g_aAppInfo.begin(); it != g_aAppInfo.end(); it++) {
            if (_wcsicmp(it->wstrExeName.c_str(), wszName) == 0) {
                bFound = TRUE;
                break;
            }
        }

        if (!bFound) {
            AppInfo.wstrExeName = wszName;
            g_aAppInfo.push_back(AppInfo);
            it = g_aAppInfo.end() - 1;
        }

        tiShim = SdbFindFirstTag(pdb, tiExe, TAG_SHIM_REF);
        
        while (tiShim) {
            WCHAR* wszShimName = NULL;
            TAGID  tiShimName = SdbFindFirstTag(pdb, tiShim, TAG_NAME);
            
            if (!tiShimName) {
                goto nextShim;
            }
            
            wszShimName = SdbGetStringTagPtr(pdb, tiShimName);

            it->awstrShims.push_back(wstring(wszShimName));

            nextShim:
            tiShim = SdbFindNextTag(pdb, tiExe, tiShim);
        }

nextExe:

        tiExe = SdbFindNextTag(pdb, tiDB, tiExe);
    }

out:

    if (pdb) {
        SdbCloseDatabase(pdb);
        pdb = NULL;
    }

    return;
}

void
GetCurrentAppSettings(
    void
    )
{
    g_aAppInfo.clear();

    GetCurrentAppSettingsFromRegistry();
    GetCurrentAppSettingsFromSDB();
}

void
SetCurrentRegistrySettings(
    void
    )
{
    HKEY        hImageOptionsKey;
    HKEY        hSubKey = NULL;
    DWORD       dwSubkeyIndex;
    DWORD       dwDataSize;
    DWORD       dwValueType;
    DWORD       dwFlags;
    LONG        lResult;
    FILETIME    LastWriteTime;
    TCHAR       szKeyNameBuffer[ 256 ];
    CAVAppInfo* pApp;
    wstring     wstrEmpty = L"";

    //
    // Open the Image File Execution Options regkey
    //
    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           g_szImageOptionsKeyName,
                           0,
                           KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS,
                           &hImageOptionsKey);

    if (lResult != ERROR_SUCCESS) {
        if (lResult == ERROR_ACCESS_DENIED) {
            AVErrorResourceFormat(IDS_ACCESS_IS_DENIED);
        } else {
            AVErrorResourceFormat(IDS_REGOPENKEYEX_FAILED,
                                  g_szImageOptionsKeyName,
                                  (DWORD)lResult);
        }

        return;
    }

    //
    // Enumerate all the existing subkeys for app execution options
    //

    for (dwSubkeyIndex = 0; TRUE; dwSubkeyIndex += 1) {
        dwDataSize = ARRAY_LENGTH(szKeyNameBuffer);

        lResult = RegEnumKeyEx(hImageOptionsKey,
                               dwSubkeyIndex,
                               szKeyNameBuffer,
                               &dwDataSize,
                               NULL,
                               NULL,
                               NULL,
                               &LastWriteTime);

        if (lResult != ERROR_SUCCESS) {
            if (lResult == ERROR_NO_MORE_ITEMS) {
                //
                // We finished looking at all the existing subkeys
                //
                break;
            } else {
                if (lResult == ERROR_ACCESS_DENIED) {
                    AVErrorResourceFormat(IDS_ACCESS_IS_DENIED);
                } else {
                    AVErrorResourceFormat(IDS_REGENUMKEYEX_FAILED,
                                          g_szImageOptionsKeyName,
                                          (DWORD)lResult);
                }

                goto CleanUpAndDone;
            }
        }

        //
        // Open the subkey
        //
        lResult = RegOpenKeyEx(hImageOptionsKey,
                               szKeyNameBuffer,
                               0,
                               KEY_QUERY_VALUE | KEY_SET_VALUE,
                               &hSubKey);

        if (lResult != ERROR_SUCCESS) {
            if (lResult == ERROR_ACCESS_DENIED) {
                AVErrorResourceFormat(IDS_ACCESS_IS_DENIED);
            } else {
                AVErrorResourceFormat(IDS_REGOPENKEYEX_FAILED,
                                      szKeyNameBuffer,
                                      (DWORD)lResult);
            }

            goto CleanUpAndDone;
        }

        dwFlags = GetAppVerifierFlagsFromKey(hSubKey);
        
        DWORD dwDesiredFlags = 0;
        BOOL bFound = FALSE;

        for (pApp = g_aAppInfo.begin(); pApp != g_aAppInfo.end(); pApp++) {
            if (_wcsicmp(pApp->wstrExeName.c_str(), szKeyNameBuffer) == 0) {
                dwDesiredFlags = pApp->dwRegFlags;
                bFound = TRUE;

                //
                // we found it, so update the full path
                //
                SetAppVerifierFullPathForKey(hSubKey, pApp->wstrExePath);

                //
                // and add the debugger as well
                //
                SetDebuggerOptionsForKey(hSubKey, g_bUseAVDebugger);

                break;
            }
        }

        if (!bFound) {
            //
            // if this one isn't in our list, make sure it doesn't
            // have a full path or our debugger set
            //
            SetAppVerifierFullPathForKey(hSubKey, wstrEmpty);
            SetDebuggerOptionsForKey(hSubKey, FALSE);
        }

        if (dwFlags != dwDesiredFlags) {
            SetAppVerifierFlagsForKey(hSubKey, dwDesiredFlags);
        }



        VERIFY(ERROR_SUCCESS == RegCloseKey(hSubKey));
        hSubKey = NULL;
    }

    //
    // and now go through the list the other way, looking for new ones to add
    //
    for (pApp = g_aAppInfo.begin(); pApp != g_aAppInfo.end(); pApp++) {
        lResult = RegOpenKeyEx(hImageOptionsKey,
                               pApp->wstrExeName.c_str(),
                               0,
                               KEY_QUERY_VALUE | KEY_SET_VALUE,
                               &hSubKey);

        //
        // if it exists, we've already dealt with it above
        //
        if (lResult != ERROR_SUCCESS) {
            //
            // it doesn't exist. Try to create it.
            //
            lResult = RegCreateKeyEx(hImageOptionsKey,
                                     pApp->wstrExeName.c_str(),
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_QUERY_VALUE | KEY_SET_VALUE,
                                     NULL,
                                     &hSubKey,
                                     NULL);

            if (lResult == ERROR_SUCCESS) {
                SetAppVerifierFlagsForKey(hSubKey, pApp->dwRegFlags);
                SetAppVerifierFullPathForKey(hSubKey, pApp->wstrExePath);
                SetDebuggerOptionsForKey(hSubKey, g_bUseAVDebugger);
            }
        }
        
        if (hSubKey) {
            RegCloseKey(hSubKey);
            hSubKey = NULL;
        }
    }

CleanUpAndDone:

    VERIFY(ERROR_SUCCESS == RegCloseKey(hImageOptionsKey));
}

void
SetCurrentAppSettings(
    void
    )
{
    SetCurrentRegistrySettings();
    AppCompatWriteShimSettings(g_aAppInfo);
}

KERNEL_TEST_INFO g_KernelTests[] = 
{
    {
        IDS_PAGE_HEAP,
        IDS_PAGE_HEAP_DESC,
        RTL_VRF_FLG_FULL_PAGE_HEAP,
        TRUE,
        L"PageHeap"
    },
    {
        IDS_VERIFY_LOCKS_CHECKS,
        IDS_VERIFY_LOCKS_CHECKS_DESC,
        RTL_VRF_FLG_LOCK_CHECKS,
        TRUE,
        L"Locks"
    },
    {
        IDS_VERIFY_HANDLE_CHECKS,
        IDS_VERIFY_HANDLE_CHECKS_DESC,
        RTL_VRF_FLG_HANDLE_CHECKS,
        TRUE,
        L"Handles"
    },
    {
        IDS_VERIFY_STACK_CHECKS,
        IDS_VERIFY_STACK_CHECKS_DESC,
        RTL_VRF_FLG_STACK_CHECKS,
        FALSE,
        L"Stacks"
    }
};

BOOL
GetKernelTestInfo(
    CTestInfoArray& TestArray
    )
{
    CTestInfo ti;
    TCHAR     szTemp[256];
    int       i;

    ti.eTestType = TEST_KERNEL;

    for (int i = 0; i < ARRAY_LENGTH(g_KernelTests); ++i) {
        if (!AVLoadString(g_KernelTests[i].m_uNameStringId, szTemp, ARRAY_LENGTH(szTemp))) {
            continue;
        }
        ti.strTestName = szTemp;

        if (AVLoadString(g_KernelTests[i].m_uDescriptionStringId, szTemp, ARRAY_LENGTH(szTemp))) {
            ti.strTestDescription = szTemp;
        } else {
            ti.strTestDescription = L"";
        }

        ti.dwKernelFlag = g_KernelTests[i].m_dwBit;
        ti.bDefault =  g_KernelTests[i].m_bDefault;
        ti.strTestCommandLine = g_KernelTests[i].m_szCommandLine;

        TestArray.push_back(ti);
    }

    return TRUE;
}


void
ParseIncludeList(
    WCHAR*         szList,
    CWStringArray& astrArray
    )
{
    if (!szList) {
        return;
    }

    WCHAR *szComma = NULL;
    WCHAR *szBegin = szList;
    WCHAR szTemp[128];
    int nLen = wcslen(szList);
    WCHAR *szEnd = szList + nLen;


    do {
        szComma = wcschr(szBegin, L',');
        if (!szComma) {
            szComma = szEnd;
        }
        while (*szComma && iswspace(*szComma)) {
            szComma++;
        }

        nLen = (int)(szComma - szBegin);

        if (nLen > 0) {
            memcpy(szTemp, szBegin, nLen * sizeof(WCHAR));
            szTemp[nLen] = 0;

            astrArray.push_back(szTemp);
        }

        if (!*szComma) {
            break;
        }
        szBegin = szComma + 1;

    } while (TRUE);

}

BOOL
GetShimInfo(
    CTestInfoArray& TestInfoArray
    )
{
    HKEY hKey = NULL;
    BOOL bRet = FALSE;
    int nWhich = 0;
    TCHAR szAppPatch[MAX_PATH];
    TCHAR szShimFullPath[MAX_PATH];
    HMODULE hMod;
    _pfnEnumShims pEnumShims = NULL;
    _pfnIsVerifierDLL pIsVerifer = NULL;
    PSHIM_DESCRIPTION pShims = NULL;
    DWORD dwShims = 0;

    WIN32_FIND_DATA FindData;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    TCHAR szDllSearch[MAX_PATH];

    GetSystemWindowsDirectory(szAppPatch, MAX_PATH);
    _tcscat(szAppPatch, _T("\\AppPatch\\"));
    _tcscpy(szDllSearch, szAppPatch);
    _tcscat(szDllSearch, _T("*.dll"));

    //
    // enumerate all the DLLs and look for ones that have Verification
    // shims in them
    //
    hFind = FindFirstFile(szDllSearch, &FindData);
    while (hFind != INVALID_HANDLE_VALUE) {

        _tcscpy(szShimFullPath, szAppPatch);
        _tcscat(szShimFullPath, FindData.cFileName);

        hMod = LoadLibrary(szShimFullPath);
        if (!hMod) {
            goto nextKey;
        }

        pIsVerifer = (_pfnIsVerifierDLL)GetProcAddress(hMod, "IsVerifierDLL");
        if (!pIsVerifer) {
            //
            // not a real verifier shim
            //
            goto nextKey;
        }

        if (!pIsVerifer()) {
            //
            // not a real verifier shim
            //
            goto nextKey;
        }

        pEnumShims = (_pfnEnumShims)GetProcAddress(hMod, "EnumShims");
        if (!pEnumShims) {
            //
            // not a real verifier shim
            //
            goto nextKey;
        }

        dwShims = pEnumShims(NULL, ENUM_SHIMS_MAGIC);
        if (!dwShims) {
            goto nextKey;
        }

        pShims = new SHIM_DESCRIPTION[dwShims];
        if (!pShims) {
            goto out;
        }

        pEnumShims(pShims, ENUM_SHIMS_MAGIC);

        for (DWORD i = 0; i < dwShims; ++i) {
            CTestInfo ti;

            ti.eTestType = TEST_SHIM;
            ti.strDllName = FindData.cFileName;
            ti.strTestName = pShims[i].szName;
            ti.strTestCommandLine = pShims[i].szName;
            ti.strTestDescription = pShims[i].szDescription;
            ti.bDefault = TRUE;

            ParseIncludeList(pShims[i].szIncludes, ti.astrIncludes);
            ParseIncludeList(pShims[i].szExcludes, ti.astrExcludes);

            //
            // add it to the end
            //
            TestInfoArray.push_back(ti);
        }

        delete [] pShims;
        pShims = NULL;


        nextKey:
        if (hMod) {
            FreeLibrary(hMod);
            hMod = NULL;
        }
        if (!FindNextFile(hFind, &FindData)) {
            FindClose(hFind);
            hFind = INVALID_HANDLE_VALUE;
        }
    }


    bRet = TRUE;

    out:

    if (hMod) {
        FreeLibrary(hMod);
        hMod = NULL;
    }
    if (hFind != INVALID_HANDLE_VALUE) {
        FindClose(hFind);
        hFind = INVALID_HANDLE_VALUE;
    }
    return bRet;
}

BOOL 
InitTestInfo(
    void
    )
{
    g_aTestInfo.clear();

    if (!GetKernelTestInfo(g_aTestInfo)) {
        return FALSE;
    }
    if (!GetShimInfo(g_aTestInfo)) {
        return FALSE;
    }

    return TRUE;
}

void
ResetVerifierLog(
    void
    )
{
    WIN32_FIND_DATA FindData;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    BOOL bFound;
    TCHAR szVLogPath[MAX_PATH];
    TCHAR szVLogSearch[MAX_PATH];
    TCHAR szPath[MAX_PATH];
    HANDLE hFile;

    GetSystemWindowsDirectory(szVLogPath, MAX_PATH);
    _tcscat(szVLogPath, _T("\\AppPatch\\VLog\\"));
    _tcscpy(szVLogSearch, szVLogPath);
    _tcscat(szVLogSearch, _T("*.log"));

    //
    // kill all the .log files
    //
    hFind = FindFirstFile(szVLogSearch, &FindData);
    while (hFind != INVALID_HANDLE_VALUE) {

        _tcscpy(szPath, szVLogPath);
        _tcscat(szPath, FindData.cFileName);

        DeleteFile(szPath);

        if (!FindNextFile(hFind, &FindData)) {
            FindClose(hFind);
            hFind = INVALID_HANDLE_VALUE;
        }
    }

    //
    // recreate session.log
    //
    CreateDirectory(szVLogPath, NULL);

    _tcscpy(szPath, szVLogPath);
    _tcscat(szPath, _T("session.log"));

    hFile = CreateFile(szPath, 
                       GENERIC_WRITE, 
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    return;
}

void EnableVerifierLog(void)
{
    HANDLE hFile;
    TCHAR szPath[MAX_PATH];
    TCHAR szVLogPath[MAX_PATH];

    GetSystemWindowsDirectory(szVLogPath, MAX_PATH);
    _tcscat(szVLogPath, _T("\\AppPatch\\VLog\\"));
    
    //
    // make sure VLog dir and session.log exists
    //
    CreateDirectory(szVLogPath, NULL);

    _tcscpy(szPath, szVLogPath);
    _tcscat(szPath, _T("session.log"));

    hFile = CreateFile(szPath, 
                       GENERIC_WRITE, 
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }
}

CTestInfo*
FindShim(
    wstring& wstrName
    )
{
    CTestInfoArray::iterator it;

    for (it = g_aTestInfo.begin(); it != g_aTestInfo.end(); it++) {
        if (it->strTestName == wstrName) {
            return &(*it);
        }
    }

    return NULL;
}

extern "C" BOOL
ShimdbcExecute(
    LPCWSTR lpszCmdLine
    );

TCHAR g_szBuff[2048] = _T("");


BOOL 
AppCompatWriteShimSettings(
    CAVAppInfoArray& arrAppInfo
    )
{
    TCHAR               szTempPath[MAX_PATH] = _T("");
    TCHAR               szXmlFile[MAX_PATH]  = _T("");
    TCHAR               szSdbFile[MAX_PATH]  = _T("");
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    DWORD               bytesWritten;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    BOOL                bReturn = FALSE;
    TCHAR               szUnicodeHdr[2] = { 0xFEFF, 0};

    if (0 == arrAppInfo.size()) {
        return AppCompatDeleteSettings();
    }

    //
    // Construct the XML...
    //
    wsprintf(g_szXML,
             _T("%s<?xml version=\"1.0\"?>\r\n")
             _T("<DATABASE NAME=\"Application Verifier Database\" ID=\"{448850f4-a5ea-4dd1-bf1b-d5fa285dc64b}\">\r\n")
             _T("    <LIBRARY>\r\n"),
             szUnicodeHdr);

    CTestInfoArray::iterator it;

    for (it = g_aTestInfo.begin(); it != g_aTestInfo.end(); it++) {
        if (it->eTestType != TEST_SHIM) {
            continue;
        }
        wsprintf(g_szBuff,
                 _T("        <SHIM NAME=\"%s\" FILE=\"%s\">\r\n")
                 _T("            <DESCRIPTION>\r\n")
                 _T("                %s\r\n")
                 _T("            </DESCRIPTION>\r\n"),
                 it->strTestName.c_str(),
                 it->strDllName.c_str(),
                 it->strTestDescription.c_str());

        lstrcat(g_szXML, g_szBuff);

        CWStringArray::iterator wsit;

        for (wsit = it->astrIncludes.begin(); wsit != it->astrIncludes.end(); ++wsit) {
            wsprintf(g_szBuff,
                     _T("            <INCLUDE MODULE=\"%s\"/>\r\n"),
                     wsit->c_str());

            lstrcat(g_szXML, g_szBuff);
        }
        for (wsit = it->astrExcludes.begin(); wsit != it->astrExcludes.end(); ++wsit) {
            wsprintf(g_szBuff,
                     _T("            <EXCLUDE MODULE=\"%s\"/>\r\n"),
                     wsit->c_str());

            lstrcat(g_szXML, g_szBuff);
        }

        lstrcat(g_szXML, _T("        </SHIM>\r\n"));

    }

    lstrcat(g_szXML, _T("    </LIBRARY>\r\n\r\n"));
    lstrcat(g_szXML, _T("    <APP NAME=\"All EXEs to be verified\" VENDOR=\"Various\">\r\n"));

    CAVAppInfo* aiit;

    for (aiit = arrAppInfo.begin(); aiit != arrAppInfo.end(); aiit++) {

        //
        // if there're no shims, we're done
        //
        if (aiit->awstrShims.size() == 0) {
            continue;
        }

        wsprintf(g_szBuff, _T("        <EXE NAME=\"%s\">\r\n"), 
                 aiit->wstrExeName.c_str());
        lstrcat(g_szXML, g_szBuff);

        CWStringArray::iterator wsit;

        for (wsit = aiit->awstrShims.begin();
            wsit != aiit->awstrShims.end();
            wsit++) {

            CTestInfo* pTestInfo = FindShim(*wsit);

            if (pTestInfo) {
                wsprintf(g_szBuff,
                         _T("            <SHIM NAME=\"%s\"/>\r\n"),
                         pTestInfo->strTestName.c_str());

                lstrcat(g_szXML, g_szBuff);
            }
        }

        lstrcat(g_szXML, _T("        </EXE>\r\n"));
    }

    lstrcat(g_szXML,
            _T("    </APP>\r\n")
            _T("</DATABASE>"));

    if (GetTempPath(MAX_PATH, szTempPath) == 0) {
        DPF("[AppCompatSaveSettings] GetTempPath failed.");
        goto cleanup;
    }

    //
    // Obtain a temp name for the XML file
    //
    if (GetTempFileName(szTempPath, _T("XML"), NULL, szXmlFile) == 0) {
        DPF("[AppCompatSaveSettings] GetTempFilePath for XML failed.");
        goto cleanup;
    }

    hFile = CreateFile(szXmlFile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        DPF("[AppCompatSaveSettings] CreateFile '%s' failed 0x%X.",
            szXmlFile, GetLastError());
        goto cleanup;
    }

    if (WriteFile(hFile, g_szXML, lstrlen(g_szXML) * sizeof(TCHAR), &bytesWritten, NULL) == 0) {
        DPF("[AppCompatSaveSettings] WriteFile \"%s\" failed 0x%X.",
            szXmlFile, GetLastError());
        goto cleanup;
    }

    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

    //
    // Obtain a temp name for the SDB file
    //
    wsprintf(szSdbFile, _T("%stempdb.sdb"), szTempPath);

    DeleteFile(szSdbFile);

    //
    // Invoke the compiler to generate the SDB file
    //

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    wsprintf(g_szCmd, _T("shimdbc.exe fix -q \"%s\" \"%s\""), szXmlFile, szSdbFile);

    if (!ShimdbcExecute(g_szCmd)) {
        DPF("[AppCompatSaveSettings] CreateProcess \"%s\" failed 0x%X.",
            g_szCmd, GetLastError());
        goto cleanup;
    }

    //
    // The SDB file is generated. Install the database now.
    //
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    wsprintf(g_szCmd, _T("sdbinst.exe -q \"%s\""), szSdbFile);

    if (!CreateProcess(NULL,
                        g_szCmd,
                        NULL,
                        NULL,
                        FALSE,
                        NORMAL_PRIORITY_CLASS | CREATE_NO_WINDOW,
                        NULL,
                        NULL,
                        &si,
                        &pi)) {

        DPF("[AppCompatSaveSettings] CreateProcess \"%s\" failed 0x%X.",
            g_szCmd, GetLastError());
        goto cleanup;
    }

    CloseHandle(pi.hThread);

    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(pi.hProcess);

    //
    // ensure we've got a fresh log session started
    //
    EnableVerifierLog();

    if (g_bClearSessionLogBeforeRun) {
        ResetVerifierLog();
    }

    bReturn = TRUE;

    cleanup:

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    DeleteFile(szXmlFile);
    DeleteFile(szSdbFile);

    return bReturn;
}

BOOL
AppCompatDeleteSettings(
    void
    )
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    TCHAR               szCmd[MAX_PATH];

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    lstrcpy(szCmd, _T("sdbinst.exe -q -u -g {448850f4-a5ea-4dd1-bf1b-d5fa285dc64b}"));

    if (!CreateProcess(NULL,
                         szCmd,
                         NULL,
                         NULL,
                         FALSE,
                         NORMAL_PRIORITY_CLASS | CREATE_NO_WINDOW,
                         NULL,
                         NULL,
                         &si,
                         &pi)) {

        DPF("[AppCompatDeleteSettings] CreateProcess \"%s\" failed 0x%X.",
            szCmd, GetLastError());
        return FALSE;
    }

    CloseHandle(pi.hThread);

    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(pi.hProcess);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\appverifier\debugger.cpp ===
#include "precomp.h"


#include <memory.h>
#include <stdlib.h>
#include "wdbgexts.h"

#include "Debugger.h"
#include "UserDump.h"
#include "DbgHelp.h"

#ifdef BP_SIZE
ULONG     g_BpSize  = BP_SIZE;
#endif
#ifdef BP_INSTR
ULONG     g_BpInstr = BP_INSTR;
#endif

typedef void (*PFNDBGEXT)(HANDLE                    hCurrentProcess,
                          HANDLE                    hCurrentThread,
                          DWORD                     dwUnused,
                          PWINDBG_EXTENSION_APIS    lpExtensionApis,
                          LPSTR                     lpArgumentString);


TCHAR                   g_szCrashDumpFile[MAX_PATH];

PFNDBGEXT               g_pfnPhextsInit;

BOOL                    g_bInitialBreakpoint = TRUE;

PROCESS_INFORMATION     g_ProcessInformation;

WINDBG_EXTENSION_APIS   ExtensionAPIs;


typedef struct tagLOADEDDLL {
    struct tagLOADEDDLL* pNext;
    LPTSTR               pszName;
    LPVOID               lpBaseOfDll;
} LOADEDDLL, *PLOADEDDLL;

PLOADEDDLL g_pFirstDll;


PPROCESS_INFO   g_pProcessHead  = NULL;
PPROCESS_INFO   g_pFirstProcess = NULL;


//
// BUGBUG: what's this for ?
//
TCHAR g_szDbgString[1024];


//
// Local function prototypes
//

void DebuggerLoop(void);



DWORD WINAPI
DebugApp(
    LPTSTR pszAppName
    )
/*++
    Return: TRUE if successful, FALSE otherwise.

    Desc:   Launch the debuggee.
--*/
{
    BOOL        bRet;
    STARTUPINFO StartupInfo;

    wcscpy(g_szCrashDumpFile, L"d:\\temp\\crash.dmp");
    
    ZeroMemory(&StartupInfo, sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);

    bRet = CreateProcess(NULL,
                         pszAppName,
                         NULL,
                         NULL,
                         FALSE,
                         CREATE_SEPARATE_WOW_VDM | DEBUG_ONLY_THIS_PROCESS,
                         NULL,
                         NULL,
                         &StartupInfo,
                         &g_ProcessInformation);

    if (!bRet) {
        return 0;
    }

    if (g_ProcessInformation.hProcess != NULL) {

        InitVerifierLogSupport(pszAppName, g_ProcessInformation.dwProcessId);

        //
        // Start the debugger loop.
        //
        DebuggerLoop();

        //
        // Free the memory.
        //
        PPROCESS_INFO pProcess = g_pProcessHead;
        PPROCESS_INFO pProcessNext;

        while (pProcess != NULL) {
            pProcessNext = pProcess->pNext;

            PTHREAD_INFO pThread = pProcess->pFirstThreadInfo;
            PTHREAD_INFO pThreadNext;

            while (pThread != NULL) {
                pThreadNext = pThread->pNext;

                HeapFree(GetProcessHeap(), 0, pThread);

                pThread = pThreadNext;
            }

            HeapFree(GetProcessHeap(), 0, pProcess);

            pProcess = pProcessNext;
        }

        g_pProcessHead = NULL;

        PLOADEDDLL pDll = g_pFirstDll;
        PLOADEDDLL pDllNext;

        while (pDll != NULL) {
            pDllNext = pDll->pNext;

            HeapFree(GetProcessHeap(), 0, pDll->pszName);
            HeapFree(GetProcessHeap(), 0, pDll);

            pDll = pDllNext;
        }

        g_pFirstDll = NULL;

        CloseHandle(g_ProcessInformation.hProcess);
        CloseHandle(g_ProcessInformation.hThread);

        ZeroMemory(&g_ProcessInformation, sizeof(PROCESS_INFORMATION));
    }

    return 1;
}


PPROCESS_INFO
GetProcessInfo(
    HANDLE hProcess
    )
{
    PPROCESS_INFO pProcess = g_pProcessHead;

    while (pProcess != NULL) {
        if (pProcess->hProcess == hProcess) {
            return pProcess;
        }
    }

    return NULL;
}

SIZE_T
ReadMemoryDbg(
    HANDLE  hProcess,
    LPVOID  Address,
    LPVOID  Buffer,
    SIZE_T  Length
    )
{
    SIZE_T        cbRead;
    LPVOID        AddressBp;
    PPROCESS_INFO pProcess;

    if (!ReadProcessMemory(hProcess,
                           Address,
                           Buffer,
                           Length,
                           &cbRead)) {
        return 0;
    }

    pProcess = GetProcessInfo(hProcess);

    if (pProcess == NULL) {
        return 0;
    }

#if defined(BP_INSTR) && defined(BP_SIZE)
    for (int i = 0; i < MAX_BREAKPOINTS; i++) {

        AddressBp = pProcess->bp[i].Address;

        if ((ULONG_PTR)AddressBp >= (ULONG_PTR)Address &&
             (ULONG_PTR)AddressBp <  (ULONG_PTR)Address + Length) {

            CopyMemory((LPVOID)((ULONG_PTR)Buffer + (ULONG_PTR)AddressBp - (ULONG_PTR)Address),
                       &pProcess->bp[i].OriginalInstr,
                       g_BpSize);
        }
    }
#endif

    return cbRead;
}

BOOL
WriteMemoryDbg(
    HANDLE  hProcess,
    PVOID   Address,
    PVOID   Buffer,
    SIZE_T   Length
    )
{
    SIZE_T cb = 0;
    BOOL  bSuccess;

    bSuccess = WriteProcessMemory(hProcess, Address, Buffer, Length, &cb);

    if (!bSuccess || cb != Length) {
        return FALSE;
    }

    return TRUE;
}

BOOL
GetImageName(
    HANDLE    hProcess,
    ULONG_PTR ImageBase,
    PVOID     ImageNamePtr,
    LPTSTR    ImageName,
    DWORD     ImageNameLength
    )
/*++
    Return: TRUE if successful, FALSE otherwise.

    Desc:   BUGBUG: give details here
--*/
{
    DWORD_PTR              i;
    BYTE                   UnicodeBuf[256 * 2];
    IMAGE_DOS_HEADER       dh;
    IMAGE_NT_HEADERS       nh;
    IMAGE_EXPORT_DIRECTORY expdir;

    if (!ReadMemoryDbg(hProcess,
                        (ULONG*)ImageNamePtr,
                        &i,
                        sizeof(i))) {

        goto GetFromExports;
    }

    if (!ReadMemoryDbg(hProcess,
                        (ULONG*)i,
                        (ULONG*)UnicodeBuf,
                        sizeof(UnicodeBuf))) {

        goto GetFromExports;
    }

    ZeroMemory(ImageName, ImageNameLength);

#ifdef UNICODE
    lstrcpyW(ImageName, (LPCWSTR)UnicodeBuf);
#else    
    WideCharToMultiByte(CP_ACP,
                        0,
                        (LPWSTR)UnicodeBuf,
                        wcslen((LPWSTR)UnicodeBuf),
                        ImageName,
                        ImageNameLength,
                        NULL,
                        NULL);
#endif // UNICODE

    if (lstrlen(ImageName) == 0) {
        goto GetFromExports;
    }

    return TRUE;

GetFromExports:

    if (!ReadMemoryDbg(hProcess,
                        (ULONG*)ImageBase,
                        (ULONG*)&dh,
                        sizeof(IMAGE_DOS_HEADER))) {
        return FALSE;
    }

    if (dh.e_magic != IMAGE_DOS_SIGNATURE) {
        return FALSE;
    }

    if (!ReadMemoryDbg(hProcess,
                        (ULONG*)(ImageBase + dh.e_lfanew),
                        (ULONG*)&nh,
                        sizeof(IMAGE_NT_HEADERS))) {
        return FALSE;
    }

    if (nh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress == 0) {
        return FALSE;
    }

    if (!ReadMemoryDbg(hProcess,
                        (ULONG*)(ImageBase +
                                 nh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress),
                        (ULONG*)&expdir,
                        sizeof(IMAGE_EXPORT_DIRECTORY))) {
        return FALSE;
    }

    if (!ReadMemoryDbg(hProcess,
                        (ULONG*)(ImageBase + expdir.Name),
#ifdef UNICODE
                        (ULONG*)UnicodeBuf,
#else
                        (ULONG*)ImageName,
#endif // UNICODE
                        ImageNameLength)) {
        return FALSE;
    }

#ifdef UNICODE
    MultiByteToWideChar(CP_ACP,
                        0,
                        (LPCSTR)UnicodeBuf,
                        -1,
                        ImageName,
                        ImageNameLength);
#endif // UNICODE

    return TRUE;
}

void
AddDll(
    LPVOID  lpBaseOfDll,
    LPCTSTR pszDllName
    )
/*++
    Return: void.

    Desc:   BUGBUG: give details here
--*/
{
    PLOADEDDLL pDll;

    pDll = (PLOADEDDLL)HeapAlloc(GetProcessHeap(), 0, sizeof(LOADEDDLL));

    if (pDll == NULL) {
        return;
    }

    pDll->pszName = (LPTSTR)HeapAlloc(GetProcessHeap(), 0, (lstrlen(pszDllName) + 1) * sizeof(TCHAR));

    if (pDll->pszName == NULL) {
        HeapFree(GetProcessHeap(), 0, pDll);
        return;
    }

    lstrcpy(pDll->pszName, pszDllName);

    pDll->lpBaseOfDll = lpBaseOfDll;

    pDll->pNext = g_pFirstDll;
    g_pFirstDll = pDll;
}

LPTSTR
GetDll(
    LPVOID lpBaseOfDll
    )
/*++
    Return: The name of the DLL with the specified base address.

    Desc:   BUGBUG
--*/
{
    PLOADEDDLL pDll = g_pFirstDll;

    while (pDll != NULL) {
        if (pDll->lpBaseOfDll == lpBaseOfDll) {
            return pDll->pszName;
        }
        pDll = pDll->pNext;
    }

    return NULL;
}

void
RemoveDll(
    LPVOID lpBaseOfDll
    )
/*++
    Return: void.

    Desc:   BUGBUG: give details here
--*/
{
    PLOADEDDLL* ppDll = &g_pFirstDll;
    PLOADEDDLL  pDllFree;

    while (*ppDll != NULL) {

        if ((*ppDll)->lpBaseOfDll == lpBaseOfDll) {

            HeapFree(GetProcessHeap(), 0, (*ppDll)->pszName);
            pDllFree = *ppDll;

            *ppDll = (*ppDll)->pNext;

            HeapFree(GetProcessHeap(), 0, pDllFree);
            break;
        }
        ppDll = &((*ppDll)->pNext);
    }
}


BOOL
ProcessModuleLoad(
    PPROCESS_INFO pProcess,
    DEBUG_EVENT*  pde
    )

/*++
    Return: TRUE on success, FALSE otherwise

    Desc:   Process all module load debug events, create process & dll load.
            The purpose is to allocate a MODULEINFO structure, fill in the
            necessary values, and load the symbol table.
--*/

{
    HANDLE      hFile=NULL;
    DWORD_PTR   dwBaseOfImage;

    if (pde->dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT) {

        hFile         = pde->u.CreateProcessInfo.hFile;
        dwBaseOfImage = (DWORD_PTR)pde->u.CreateProcessInfo.lpBaseOfImage;

        SymInitialize(pProcess->hProcess, NULL, FALSE);

    } else if (pde->dwDebugEventCode == LOAD_DLL_DEBUG_EVENT) {
        hFile         = pde->u.LoadDll.hFile;
        dwBaseOfImage = (DWORD_PTR)pde->u.LoadDll.lpBaseOfDll;
    }

    if (hFile == NULL || hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (dwBaseOfImage==(DWORD_PTR)NULL) {
        return FALSE;
    }

    if (!SymLoadModule(pProcess->hProcess, hFile, NULL, NULL, dwBaseOfImage, 0)) {
        return FALSE;
    }

    return TRUE;
}

void
DebuggerLoop(
    void
    )
/*++
    Return: void.

    Desc:   BUGBUG: give details here
--*/
{
    DEBUG_EVENT   DebugEv;                            // debugging event information 
    DWORD         dwContinueStatus = DBG_CONTINUE;    // exception continuation 
    PPROCESS_INFO pProcess = NULL;
    PTHREAD_INFO  pThread  = NULL;

    while (TRUE) {

        //
        // Wait for a debugging event to occur. The second parameter indicates
        // that the function does not return until a debugging event occurs.
        //
        WaitForDebugEvent(&DebugEv, INFINITE);

        //
        // Update the processes and threads lists.
        //
        pProcess = g_pProcessHead;
        while (pProcess != NULL) {
            if (pProcess->dwProcessId == DebugEv.dwProcessId) {
                break;
            }
            pProcess = pProcess->pNext;
        }

        if (pProcess == NULL) {
            //
            // New process.
            //
            pProcess = (PPROCESS_INFO)HeapAlloc(GetProcessHeap(),
                                                HEAP_ZERO_MEMORY,
                                                sizeof(PROCESS_INFO));
            if (pProcess == NULL) {
                break;
            }

            pProcess->dwProcessId = DebugEv.dwProcessId;
            pProcess->pNext = g_pProcessHead;
            g_pProcessHead = pProcess;
        }

        pThread = pProcess->pFirstThreadInfo;

        while (pThread != NULL) {
            if (pThread->dwThreadId == DebugEv.dwThreadId) {
                break;
            }
            pThread = pThread->pNext;
        }

        if (pThread == NULL) {
            //
            // New thread.
            //
            pThread = (PTHREAD_INFO)HeapAlloc(GetProcessHeap(),
                                              HEAP_ZERO_MEMORY,
                                              sizeof(THREAD_INFO));
            if (pThread == NULL) {
                break;
            }

            pThread->dwThreadId = DebugEv.dwThreadId;
            pThread->pNext = pProcess->pFirstThreadInfo;
            pProcess->pFirstThreadInfo = pThread;
        }

        dwContinueStatus = DBG_CONTINUE;

        if (DebugEv.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT) {
            goto EndProcess;
        }

        switch (DebugEv.dwDebugEventCode) {
        
        case EXCEPTION_DEBUG_EVENT: 

            switch (DebugEv.u.Exception.ExceptionRecord.ExceptionCode) {
            case EXCEPTION_BREAKPOINT:

                //
                // Hit a breakpoint.
                //
                if (!pProcess->bSeenLdrBp) {

                    pProcess->bSeenLdrBp = TRUE;

                    //
                    // When the initial breakpoint is hit all the
                    // staticly linked DLLs are already loaded so
                    // we can go ahead and set breakpoints.
                    //
                    DPF("[DebuggerLoop] Hit initial breakpoint.");

                    //
                    // Now it would be a good time to initialize the debugger extensions.
                    //
                    break;
                }

                DPF("[DebuggerLoop] Hit breakpoint.");

                VLog("Hard coded Breakpoint");

                if (MessageBox(NULL,
                                _T("An Access Violation occured. Do you want to create")
                                _T(" a crash dump file so you can later debug this problem ?"),
                                _T("Error"),
                                MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON1) == IDYES) {

                    pProcess->DebugEvent = DebugEv;
                    GenerateUserModeDump(g_szCrashDumpFile,
                                         pProcess,
                                         &DebugEv.u.Exception);
                }

                if (MessageBox(NULL,
                                _T("Do you want to continue running the program ?"),
                                _T("Error"),
                                MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON1) != IDYES) {
                    goto EndProcess;
                }

                dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
                break;

            case STATUS_SINGLE_STEP:
                DPF("[DebuggerLoop] Hit single step breakpoint.");
                break;

            case EXCEPTION_ACCESS_VIOLATION:
                DPF("[DebuggerLoop] AV. Addr: 0x%08X, firstChance %d",
                    DebugEv.u.Exception.ExceptionRecord.ExceptionAddress,
                    DebugEv.u.Exception.dwFirstChance);

                if (DebugEv.u.Exception.dwFirstChance == 0) {
                    VLog("Access Violation");

                    if (MessageBox(NULL,
                                    _T("An Access Violation occured. Do you want to create")
                                    _T(" a crash dump file so you can later debug this problem ?"),
                                    _T("Error"),
                                    MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON1) == IDYES) {

                        pProcess->DebugEvent = DebugEv;
                        GenerateUserModeDump(g_szCrashDumpFile,
                                             pProcess,
                                             &DebugEv.u.Exception);
                    }

                    if (MessageBox(NULL,
                                    _T("Do you want to continue running the program ?"),
                                    _T("Error"),
                                    MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON1) != IDYES) {
                        goto EndProcess;
                    }

                }
                
                dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;

                break;

            default:
                DPF("[DebuggerLoop] Unknown debugger exception.");

                dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
                break;
            }
            break;

        case CREATE_THREAD_DEBUG_EVENT:
            pThread->hProcess = pProcess->hProcess;
            pThread->hThread  = DebugEv.u.CreateThread.hThread;

            DPF("[DebuggerLoop] new thread. StartAddress: 0x%x",
                DebugEv.u.CreateThread.lpStartAddress);
            break;

        case EXIT_THREAD_DEBUG_EVENT:
            DPF("[DebuggerLoop] exiting thread with code: 0x%x",
                DebugEv.u.ExitThread.dwExitCode);
            break;

        case CREATE_PROCESS_DEBUG_EVENT:

            pProcess->hProcess = DebugEv.u.CreateProcessInfo.hProcess;
            pThread->hProcess  = pProcess->hProcess;
            pThread->hThread   = DebugEv.u.CreateProcessInfo.hThread;

            if (g_pFirstProcess == NULL) {
                g_pFirstProcess = pProcess;
            }

            pProcess->EntryPoint = DebugEv.u.CreateProcessInfo.lpStartAddress;

            ProcessModuleLoad(pProcess, &DebugEv);

            DPF("[DebuggerLoop] new process. BaseImage: 0x%x StartAddress: 0x%x",
                DebugEv.u.CreateProcessInfo.lpBaseOfImage,
                DebugEv.u.CreateProcessInfo.lpStartAddress);
            break;

        case LOAD_DLL_DEBUG_EVENT:
            {
                TCHAR szAsciiBuf[256];
                TCHAR szDllName[128];
                TCHAR szExt[16];
                BOOL  bRet;

                bRet = GetImageName(pProcess->hProcess,
                                    (ULONG_PTR)DebugEv.u.LoadDll.lpBaseOfDll,
                                    DebugEv.u.LoadDll.lpImageName,
                                    szAsciiBuf,
                                    sizeof(szAsciiBuf));
                if (!bRet) {
                    DPF("[DebuggerLoop] DLL LOADED. BaseDll: 0x%X cannot get the name.",
                        DebugEv.u.LoadDll.lpBaseOfDll);

                    AddDll(DebugEv.u.LoadDll.lpBaseOfDll, NULL);
                } else {
                    _tsplitpath(szAsciiBuf, NULL, NULL, szDllName, szExt);
                    lstrcat(szDllName, szExt);

                    AddDll(DebugEv.u.LoadDll.lpBaseOfDll, szDllName);

                    DPF("[DebuggerLoop] DLL LOADED. BaseDll: 0x%X \"%S\".",
                        DebugEv.u.LoadDll.lpBaseOfDll,
                        szDllName);
                }

                ProcessModuleLoad(pProcess, &DebugEv);

                CloseHandle(DebugEv.u.LoadDll.hFile);

                break;
            }

        case UNLOAD_DLL_DEBUG_EVENT:
            {
                LPTSTR pszName = GetDll(DebugEv.u.UnloadDll.lpBaseOfDll);

                if (pszName == NULL) {
                    DPF("[DebuggerLoop] DLL UNLOADED. BaseDll: 0x%X unknown.",
                        DebugEv.u.UnloadDll.lpBaseOfDll);
                } else {
                    DPF("[DebuggerLoop] DLL UNLOADED. BaseDll: 0x%X \"%S\".",
                        DebugEv.u.UnloadDll.lpBaseOfDll, pszName);
                }

                RemoveDll(DebugEv.u.UnloadDll.lpBaseOfDll);

                break;
            }

        case OUTPUT_DEBUG_STRING_EVENT:
            ReadMemoryDbg(pThread->hProcess,
                          DebugEv.u.DebugString.lpDebugStringData,
                          g_szDbgString,
                          DebugEv.u.DebugString.nDebugStringLength);

#ifdef UNICODE
            DPF("DPF - %s", g_szDbgString);
#else
            DPF("DPF - %S", g_szDbgString);
#endif // UNICODE
            break;

        default:
            DPF("[DebuggerLoop] Unknown event 0x%X",
                DebugEv.dwDebugEventCode);
            break;
        }

        //
        // Resume executing the thread that reported the debugging event.
        //
        ContinueDebugEvent(DebugEv.dwProcessId,
                           DebugEv.dwThreadId,
                           dwContinueStatus); 
    }

    EndProcess:
    DPF("[DebuggerLoop] The debugged process has exited.");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\appverifier\precomp.h ===
#ifndef __APPVERIFIER_PRECOMP_H__
#define __APPVERIFIER_PRECOMP_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#undef ASSERT

#include "afxwin.h"
#include <shellapi.h>
#include <commdlg.h>
#include <commctrl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#pragma warning(disable:4786)
#include <string>
#include <xstring>
#include <algorithm>
#include <vector>

using namespace std;


#include "ids.h"

extern "C" {
#include "shimdb.h"
}

#include "avutil.h"
#include "dbsupport.h"
#include "debugger.h"

VOID
DebugPrintf(
    LPCSTR pszFmt, 
    ...
    );

#if DBG
#define DPF DebugPrintf
#else
#define DPF if (0) DebugPrintf
#endif



///////////////////////////////////////////////////////////////////////////
//
// ARRAY_LENGTH macro
//

#ifndef ARRAY_LENGTH
#define ARRAY_LENGTH( array )   ( sizeof( array ) / sizeof( array[ 0 ] ) )
#endif //#ifndef ARRAY_LENGTH


//
// Application name ("Application Verifier Manager")
//

extern wstring g_strAppName;

extern HINSTANCE g_hInstance;

extern BOOL     g_bConsoleMode;


BOOL
InitVerifierLogSupport(
    LPWSTR szAppName,
    DWORD  dwID
    );

void
VLog(
    LPCSTR pszFmt, 
    ...
    );


#endif // __APPVERIFIER_PRECOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\appverifier\userdump.h ===
#ifndef __APPVERIFIER_USERDUMP_H_
#define __APPVERIFIER_USERDUMP_H_

BOOL
GenerateUserModeDump(
    LPTSTR                  lpszFileName,
    PPROCESS_INFO           pProcess,
    LPEXCEPTION_DEBUG_INFO  ed
    );


#endif // __APPVERIFIER_USERDUMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\appverifier\userdump.cpp ===
#include "precomp.h"

#include <crash.h>

#include "Debugger.h"
#include "UserDumpp.h"

#define MEM_SIZE (64*1024)


//
// Private data structure used for communcating
// crash dump data to the callback function.
//
typedef struct _CRASH_DUMP_INFO
{
    PPROCESS_INFO               pProcess;
    EXCEPTION_DEBUG_INFO*       ExceptionInfo;
    DWORD                       MemoryCount;
    DWORD_PTR                   Address;
    PUCHAR                      MemoryData;
    MEMORY_BASIC_INFORMATION    mbi;
    SIZE_T                      MbiOffset;
    SIZE_T                      MbiRemaining;
    PTHREAD_INFO                pCurrentThread;
    IMAGEHLP_MODULE             mi;
    PCRASH_MODULE               CrashModule;
} CRASH_DUMP_INFO, *PCRASH_DUMP_INFO;

//
// Local function prototypes
//

DWORD_PTR GetTeb( HANDLE hThread )
{
    NTSTATUS                   Status;
    THREAD_BASIC_INFORMATION   ThreadBasicInfo;
    DWORD_PTR                  Address = 0;

    Status = NtQueryInformationThread( hThread,
                                       ThreadBasicInformation,
                                       &ThreadBasicInfo,
                                       sizeof( ThreadBasicInfo ),
                                       NULL );
    if ( NT_SUCCESS(Status) )
    {
        Address = (DWORD_PTR)ThreadBasicInfo.TebBaseAddress;
    }

    return Address;
}



BOOL
CrashDumpCallback(
    IN     DWORD   DataType,        // requested data type
    OUT    PVOID*  DumpData,        // pointer to a pointer to the data
    OUT    LPDWORD DumpDataLength,  // pointer to the data length
    IN OUT PVOID   cdi              // private data
    )
/*++
    Return: TRUE on success, FALSE otherwise.
    
    Desc:   This function is the callback used by crashlib.
            Its purpose is to provide data to CreateUserDump()
            for writting to the crashdump file.
--*/

{
    PCRASH_DUMP_INFO CrashdumpInfo = (PCRASH_DUMP_INFO)cdi;

    switch ( DataType )
    {
    case DMP_DEBUG_EVENT:
        *DumpData = &CrashdumpInfo->pProcess->DebugEvent;
        *DumpDataLength = sizeof(DEBUG_EVENT);
        break;

    case DMP_THREAD_STATE:
        {
            static CRASH_THREAD CrashThread;
            PTHREAD_INFO        pCurrentThread;

            *DumpData = &CrashThread;

            if ( CrashdumpInfo->pCurrentThread == NULL )
            {
                pCurrentThread = CrashdumpInfo->pProcess->pFirstThreadInfo;
            }
            else
            {
                pCurrentThread = CrashdumpInfo->pCurrentThread->pNext;
            }

            CrashdumpInfo->pCurrentThread = pCurrentThread;

            if ( pCurrentThread == NULL )
            {
                return FALSE;
            }

            ZeroMemory(&CrashThread, sizeof(CrashThread));

            CrashThread.ThreadId = pCurrentThread->dwThreadId;
            CrashThread.SuspendCount = SuspendThread(pCurrentThread->hThread);

            if ( CrashThread.SuspendCount != (DWORD)-1 )
            {
                ResumeThread(pCurrentThread->hThread);
            }

            CrashThread.PriorityClass = GetPriorityClass(CrashdumpInfo->pProcess->hProcess);
            CrashThread.Priority = GetThreadPriority(pCurrentThread->hThread);
            CrashThread.Teb = GetTeb(pCurrentThread->hThread);

            *DumpDataLength = sizeof(CRASH_THREAD);
            break;
        }

    case DMP_MEMORY_BASIC_INFORMATION:
        while ( TRUE )
        {
            CrashdumpInfo->Address += CrashdumpInfo->mbi.RegionSize;

            if ( !VirtualQueryEx(CrashdumpInfo->pProcess->hProcess,
                                 (LPVOID)CrashdumpInfo->Address,
                                 &CrashdumpInfo->mbi,
                                 sizeof(MEMORY_BASIC_INFORMATION)) )
            {
                return FALSE;
            }

            if ( (CrashdumpInfo->mbi.Protect & PAGE_GUARD) ||
                 (CrashdumpInfo->mbi.Protect & PAGE_NOACCESS) )
            {
                continue;
            }

            if ( (CrashdumpInfo->mbi.State & MEM_FREE) ||
                 (CrashdumpInfo->mbi.State & MEM_RESERVE) )
            {
                continue;
            }

            break;
        }

        *DumpData = &CrashdumpInfo->mbi;
        *DumpDataLength = sizeof(MEMORY_BASIC_INFORMATION);
        break;

    case DMP_THREAD_CONTEXT:
        {
            PTHREAD_INFO pCurrentThread;

            if ( CrashdumpInfo->pCurrentThread == NULL )
            {
                pCurrentThread = CrashdumpInfo->pProcess->pFirstThreadInfo;
            }
            else
            {
                pCurrentThread = CrashdumpInfo->pCurrentThread->pNext;
            }

            CrashdumpInfo->pCurrentThread = pCurrentThread;

            if ( pCurrentThread == NULL )
            {
                return FALSE;
            }

            *DumpData = &CrashdumpInfo->pCurrentThread->Context;
            *DumpDataLength = sizeof(CONTEXT);
            break;
        }

    case DMP_MODULE:
        if ( CrashdumpInfo->mi.BaseOfImage == 0 )
        {
            return FALSE;
        }

        CrashdumpInfo->CrashModule->BaseOfImage = CrashdumpInfo->mi.BaseOfImage;
        CrashdumpInfo->CrashModule->SizeOfImage = CrashdumpInfo->mi.ImageSize;
        CrashdumpInfo->CrashModule->ImageNameLength = strlen(CrashdumpInfo->mi.ImageName) + 1;
        strcpy( CrashdumpInfo->CrashModule->ImageName, CrashdumpInfo->mi.ImageName );

        *DumpData = CrashdumpInfo->CrashModule;
        *DumpDataLength = sizeof(CRASH_MODULE) + CrashdumpInfo->CrashModule->ImageNameLength;

        if ( !SymGetModuleInfo(CrashdumpInfo->pProcess->hProcess,
                               (DWORD_PTR)-1,
                               &CrashdumpInfo->mi) )
        {
            CrashdumpInfo->mi.BaseOfImage = 0;
        }
        break;

    case DMP_MEMORY_DATA:
        if ( !CrashdumpInfo->MemoryCount )
        {

            CrashdumpInfo->Address = 0;
            CrashdumpInfo->MbiOffset = 0;
            CrashdumpInfo->MbiRemaining = 0;

            ZeroMemory( &CrashdumpInfo->mbi, sizeof(MEMORY_BASIC_INFORMATION) );

            CrashdumpInfo->MemoryData = (PUCHAR)VirtualAlloc(NULL,
                                                             MEM_SIZE,
                                                             MEM_COMMIT,
                                                             PAGE_READWRITE);
        }

        if ( !CrashdumpInfo->MbiRemaining )
        {
            while ( TRUE )
            {
                CrashdumpInfo->Address += CrashdumpInfo->mbi.RegionSize;

                if ( !VirtualQueryEx(CrashdumpInfo->pProcess->hProcess,
                                     (LPVOID)CrashdumpInfo->Address,
                                     &CrashdumpInfo->mbi,
                                     sizeof(MEMORY_BASIC_INFORMATION)) )
                {

                    if ( CrashdumpInfo->MemoryData )
                    {
                        VirtualFree(CrashdumpInfo->MemoryData, MEM_SIZE, MEM_RELEASE);
                    }

                    return FALSE;
                }

                if ( (CrashdumpInfo->mbi.Protect & PAGE_GUARD) ||
                     (CrashdumpInfo->mbi.Protect & PAGE_NOACCESS) )
                {
                    continue;
                }

                if ( (CrashdumpInfo->mbi.State & MEM_FREE) ||
                     (CrashdumpInfo->mbi.State & MEM_RESERVE) )
                {
                    continue;
                }

                CrashdumpInfo->MbiOffset = 0;
                CrashdumpInfo->MbiRemaining = CrashdumpInfo->mbi.RegionSize;
                CrashdumpInfo->MemoryCount += 1;
                break;
            }
        }

        *DumpDataLength = (DWORD)__min( CrashdumpInfo->MbiRemaining, MEM_SIZE );
        CrashdumpInfo->MbiRemaining -= *DumpDataLength;

        ReadProcessMemory(CrashdumpInfo->pProcess->hProcess,
                          (PUCHAR)((DWORD_PTR)CrashdumpInfo->mbi.BaseAddress + CrashdumpInfo->MbiOffset),
                          CrashdumpInfo->MemoryData,
                          *DumpDataLength,
                          NULL);

        *DumpData = CrashdumpInfo->MemoryData;
        CrashdumpInfo->MbiOffset += *DumpDataLength;
        break;
    }

    return TRUE;
}

BOOL
CreateUserDump(
    IN  LPTSTR                             pszFileName,
    IN  PDBGHELP_CREATE_USER_DUMP_CALLBACK DmpCallback,
    IN  PVOID                              lpv
    )

/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Creates the dump file.
--*/
{
    OSVERSIONINFOW              OsVersion = {0};
    USERMODE_CRASHDUMP_HEADER   DumpHeader = {0};
    DWORD                       cb;
    HANDLE                      hFile = INVALID_HANDLE_VALUE;
    BOOL                        rval;
    PVOID                       DumpData;
    DWORD                       DumpDataLength;
    SECURITY_ATTRIBUTES         SecAttrib;
    SECURITY_DESCRIPTOR         SecDescript;

    //
    // Create a DACL that allows all access to the directory.
    //
    SecAttrib.nLength               = sizeof(SECURITY_ATTRIBUTES);
    SecAttrib.lpSecurityDescriptor  = &SecDescript;
    SecAttrib.bInheritHandle        = FALSE;

    InitializeSecurityDescriptor(&SecDescript, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorDacl(&SecDescript, TRUE, NULL, FALSE);

    hFile = CreateFile(pszFileName,
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       &SecAttrib,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if ( hFile == NULL || hFile == INVALID_HANDLE_VALUE )
    {
        return FALSE;
    }

    //
    // Write out an empty header.
    //
    if ( !WriteFile(hFile, &DumpHeader, sizeof(DumpHeader), &cb, NULL) )
    {
        goto bad_file;
    }

    //
    // Write the debug event.
    //
    DumpHeader.DebugEventOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    DmpCallback(DMP_DEBUG_EVENT, &DumpData, &DumpDataLength, lpv);

    if ( !WriteFile(hFile, DumpData, sizeof(DEBUG_EVENT), &cb, NULL) )
    {
        goto bad_file;
    }

    //
    // Write the memory map.
    //
    DumpHeader.MemoryRegionOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    do
    {
        __try {
            rval = DmpCallback(DMP_MEMORY_BASIC_INFORMATION,
                               &DumpData,
                               &DumpDataLength,
                               lpv);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }

        if ( rval )
        {
            DumpHeader.MemoryRegionCount += 1;

            if ( !WriteFile(hFile, DumpData, sizeof(MEMORY_BASIC_INFORMATION), &cb, NULL) )
            {
                goto bad_file;
            }
        }
    } while ( rval );

    //
    // Write the thread contexts.
    //
    DumpHeader.ThreadOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    do
    {
        __try {
            rval = DmpCallback(DMP_THREAD_CONTEXT,
                               &DumpData,
                               &DumpDataLength,
                               lpv);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }

        if ( rval )
        {
            if ( !WriteFile(hFile, DumpData, DumpDataLength, &cb, NULL) )
            {
                goto bad_file;
            }

            DumpHeader.ThreadCount += 1;
        }

    } while ( rval );

    //
    // Write the thread states.
    //
    DumpHeader.ThreadStateOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    do
    {
        __try {
            rval = DmpCallback(DMP_THREAD_STATE,
                               &DumpData,
                               &DumpDataLength,
                               lpv);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }

        if ( rval )
        {
            if ( !WriteFile(hFile, DumpData, sizeof(CRASH_THREAD), &cb, NULL) )
            {
                goto bad_file;
            }
        }

    } while ( rval );

    //
    // Write the module table.
    //
    DumpHeader.ModuleOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    do
    {
        __try {
            rval = DmpCallback(DMP_MODULE,
                               &DumpData,
                               &DumpDataLength,
                               lpv);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }

        if ( rval )
        {
            if ( !WriteFile(hFile,
                            DumpData,
                            sizeof(CRASH_MODULE) + ((PCRASH_MODULE)DumpData)->ImageNameLength,
                            &cb,
                            NULL) )
            {
                goto bad_file;
            }

            DumpHeader.ModuleCount += 1;
        }
    } while ( rval );

    //
    // Write the virtual memory
    //
    DumpHeader.DataOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    do
    {
        __try {
            rval = DmpCallback(DMP_MEMORY_DATA,
                               &DumpData,
                               &DumpDataLength,
                               lpv);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }

        if ( rval )
        {
            if ( !WriteFile(hFile, DumpData, DumpDataLength, &cb, NULL) )
            {
                goto bad_file;
            }
        }
    } while ( rval );

    //
    // The VersionInfo is optional.
    //
    DumpHeader.VersionInfoOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    //
    // re-write the dump header with some valid data.
    //
    GetVersionEx(&OsVersion);

    DumpHeader.Signature        = USERMODE_CRASHDUMP_SIGNATURE;
    DumpHeader.MajorVersion     = OsVersion.dwMajorVersion;
    DumpHeader.MinorVersion     = OsVersion.dwMinorVersion;
#ifdef _X86_
    DumpHeader.MachineImageType = IMAGE_FILE_MACHINE_I386;
    DumpHeader.ValidDump        = USERMODE_CRASHDUMP_VALID_DUMP32;
#else
    DumpHeader.MachineImageType = IMAGE_FILE_MACHINE_IA64;
    DumpHeader.ValidDump        = USERMODE_CRASHDUMP_VALID_DUMP64;
#endif

    SetFilePointer(hFile, 0, 0, FILE_BEGIN);

    if ( !WriteFile(hFile, &DumpHeader, sizeof(DumpHeader), &cb, NULL) )
    {
        goto bad_file;
    }

    CloseHandle(hFile);

    return TRUE;

    bad_file:

    CloseHandle(hFile);

    DeleteFile(pszFileName);

    return FALSE;
}



BOOL
GenerateUserModeDump(
    LPTSTR                  pszFileName,
    PPROCESS_INFO           pProcess,
    LPEXCEPTION_DEBUG_INFO  ed
    )
{
    CRASH_DUMP_INFO CrashdumpInfo = {0};
    BOOL            bRet;
    PTHREAD_INFO    pThread;

    CrashdumpInfo.mi.SizeOfStruct = sizeof(CrashdumpInfo.mi);
    CrashdumpInfo.pProcess        = pProcess;
    CrashdumpInfo.ExceptionInfo   = ed;

    //
    // Get the thread context for all the threads.
    //
    pThread = pProcess->pFirstThreadInfo;

    while ( pThread != NULL )
    {
        pThread->Context.ContextFlags = CONTEXT_FULL;
        GetThreadContext(pThread->hThread, &pThread->Context);
        pThread = pThread->pNext;
    }

    //
    // Get first entry in the module list.
    //
    if ( !SymInitialize(pProcess->hProcess, NULL, FALSE) )
    {
        return FALSE;
    }

    if ( !SymGetModuleInfo(pProcess->hProcess, 0, &CrashdumpInfo.mi) )
    {
        return FALSE;
    }

    CrashdumpInfo.CrashModule = (PCRASH_MODULE)LocalAlloc(LPTR, 4096);

    bRet = CreateUserDump(pszFileName, CrashDumpCallback, &CrashdumpInfo);

    LocalFree(CrashdumpInfo.CrashModule);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\appverifier\log.cpp ===
#include "precomp.h"

typedef struct _VLOG_GLOBAL_DATA {
    BOOL    bLoggingDisabled;
    WCHAR   szSessionLog[MAX_PATH];
    WCHAR   szProcessLog[MAX_PATH];
} VLOG_GLOBAL_DATA, *PVLOG_GLOBAL_DATA;


PVLOG_GLOBAL_DATA g_pData = NULL;

HANDLE  g_hMap = NULL;                      // mapping handle for global data
BOOL    g_bVerifierLogInited = FALSE;   // have we been through the init sequence?
BOOL    g_bLoggingDisabled = TRUE;   // have we been through the init sequence?


WCHAR g_szSessionLog[MAX_PATH];
WCHAR g_szProcessLog[MAX_PATH];

#define DEBUGGER_LOG    L"DEBUGGER"
#define DEBUGGER_ENTRY_CRASH    L"Crash"
#define DEBUGGER_ENTRY_CRASH_DESCRIPTION    L"An AV occured. The application exited."

void
WriteToProcessLog(
    LPCSTR szLine
    );

void
WriteToSessionLog(
    LPCSTR szLine
    );

void
GetExeName(
    LPWSTR szProcessPath,
    LPWSTR szProcessName
    )
{
    LPWSTR pszLast = NULL;
    LPWSTR psz;
    LPWSTR pszFound = NULL;
    
    psz = szProcessPath;
    
    while (psz) {
        pszFound = wcschr(psz, L'\\');

        if (pszFound != NULL) {
            pszLast = pszFound;
            psz = pszFound + 1;
        } else {
            psz = pszFound;
        }
    }

    if (pszLast != NULL) {
        psz = pszLast + 1;
    } else {
        psz = szProcessPath;
    }

    pszFound = wcschr(psz, L'.');

    if (pszFound != NULL) {
        wcsncpy(szProcessName, psz, pszFound - psz);
    } else {
        wcscpy(szProcessName, psz);
    }
}

/*++

 Function Description:
    
    Initializes the support for file logging. 

 Return Value: 
    
    TRUE if successful, FALSE if failed

 History:

    04/26/2001 dmunsil  Created

--*/
BOOL
InitVerifierLogSupport(
    LPWSTR szProcessPath,
    DWORD  dwID
    )
{
    WCHAR       szShared[128];
    WCHAR       szVLogPath[MAX_PATH];
    WCHAR       szProcessName[MAX_PATH];
    WCHAR       szTime[128];
    char        szTemp[400];
    HANDLE      hFile;
    SYSTEMTIME  LocalTime;
    int         nTemp;
    BOOL        bAlreadyInited;
    DWORD       dwErr;

    //
    // if we've already been inited, get out
    //
    if (g_bVerifierLogInited) {
        return FALSE;
    }
    g_bVerifierLogInited = TRUE;

    swprintf(szShared, L"VeriferLog_%08X", dwID);
    
    g_hMap = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, szShared);
    if (g_hMap) {
        bAlreadyInited = TRUE;
    } else {
        bAlreadyInited = FALSE;
        g_hMap = CreateFileMapping(INVALID_HANDLE_VALUE,
                                   NULL,
                                   PAGE_READWRITE,
                                   0,
                                   sizeof(VLOG_GLOBAL_DATA),
                                   szShared);
    }

    if (!g_hMap) {
        DPF("Cannot get shared global data.");
        g_bLoggingDisabled = TRUE;
        return FALSE;
    }

    g_pData = (PVLOG_GLOBAL_DATA)MapViewOfFile(g_hMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);
    if (!g_pData) {
        DPF("Cannot map shared global data.");
        g_bLoggingDisabled = TRUE;
        return FALSE;
    }

    if (bAlreadyInited) {
        if (g_pData->szProcessLog[0] == 0 || g_pData->szSessionLog[0] == 0) {
            g_bLoggingDisabled = TRUE;
            g_pData->bLoggingDisabled = TRUE;
            return FALSE;
        }
        g_bLoggingDisabled = g_pData->bLoggingDisabled;
        
        wcscpy(g_szSessionLog, g_pData->szSessionLog);
        wcscpy(g_szProcessLog, g_pData->szProcessLog);
        return TRUE;
    } else {
        //
        // just in case -- make sure these are NULL
        //
        ZeroMemory(g_pData, sizeof(VLOG_GLOBAL_DATA));
    }

    //
    // we need to init the file mapping, so temporarily disable logging, just in case.
    //
    g_pData->bLoggingDisabled = TRUE;

    //
    // init the CString objects
    //

    //
    // the verifier log will be located in %windir%\AppPatch\VLog
    //

    //
    // First, check that VLog exists; if not, we're not logging
    //
    GetSystemWindowsDirectoryW(szVLogPath, MAX_PATH);

    wcscat(szVLogPath, L"\\AppPatch\\VLog");

    if (GetFileAttributesW(szVLogPath) == -1) {
        
        if (!CreateDirectory(szVLogPath, NULL)) {
            DPF("No log directory %ls. Logging disabled.", szVLogPath);
            g_bLoggingDisabled = TRUE;
            return FALSE;
        }
    }

    //
    // Next, check for the existence of session.log. If it's not there,
    // we're not logging
    //
    wcscpy(g_szSessionLog, szVLogPath);
    wcscat(g_szSessionLog, L"\\session.log");
    
    if (GetFileAttributesW(g_szSessionLog) == -1) {
        
        hFile = CreateFile(g_szSessionLog, 
                           GENERIC_WRITE, 
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
        if (hFile != INVALID_HANDLE_VALUE) {
            CloseHandle(hFile);
        } else {
            DPF("No session log file '%ls'. Logging disabled.", g_szSessionLog);
            g_bLoggingDisabled = TRUE;
            return FALSE;
        }
    }

    //
    // get the process log file name
    //
    GetExeName(szProcessPath, szProcessName);
    
    //
    // combine into log name, find first available
    //
    nTemp = 0;
    do {
        swprintf(g_szProcessLog, L"%ls\\%ls%d.%ls", szVLogPath, szProcessName, nTemp, L"log");

        nTemp++;
    } while (GetFileAttributesW(g_szProcessLog) != -1);
    
    //
    // open the file. create it if it doesn't exist, and truncate
    //
    hFile = CreateFileW(g_szProcessLog,
                        GENERIC_ALL,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        dwErr = GetLastError();

        DPF("Cannot create verifier process log file '%ls'. Error 0x%08X.", 
            g_szProcessLog, dwErr);

        g_bLoggingDisabled = TRUE;
        return FALSE;
    }
    
    CloseHandle(hFile);

    //
    // put the info in the session log and the process log
    //
    g_pData->bLoggingDisabled = FALSE;
    g_bLoggingDisabled = FALSE;


    //
    // I realize these pointers point to process-specific memory, but since
    // this mapping is only shared by this process, it seems safe.
    //
    wcscpy(g_pData->szProcessLog, g_szProcessLog);
    wcscpy(g_pData->szSessionLog, g_szSessionLog);
    
    GetLocalTime(&LocalTime);
    
    swprintf(szTime,
             L"%d/%d/%d %d:%02d:%02d",
             LocalTime.wMonth,
             LocalTime.wDay,
             LocalTime.wYear,
             LocalTime.wHour,
             LocalTime.wMinute,
             LocalTime.wSecond);
    
    sprintf(szTemp,
            "# LOG_BEGIN %ls '%ls' '%ls'",
            szTime,
            szProcessPath,
            g_szProcessLog);
    
    WriteToProcessLog(szTemp);
    WriteToSessionLog(szTemp);
    
    //
    // Dump the log provider info
    //
    sprintf(szTemp, "# SHIM_BEGIN %ls 1", DEBUGGER_LOG);
    WriteToProcessLog(szTemp);
    
    sprintf(szTemp, "# LOGENTRY %ls 0 '%ls", DEBUGGER_LOG, DEBUGGER_ENTRY_CRASH);
    WriteToProcessLog(szTemp);
    
    WriteToProcessLog("# DESCRIPTION BEGIN");
    sprintf(szTemp, "%ls", DEBUGGER_ENTRY_CRASH_DESCRIPTION);
    WriteToProcessLog(szTemp);
    WriteToProcessLog("# DESCRIPTION END");
    
    return TRUE;
}

/*++

 Function Description:
    
    clean up all our shared file resources 

 History:

    04/26/2001 dmunsil  Created

--*/
void
ReleaseLogSupport(
    void
    )
{
    g_bLoggingDisabled = TRUE;
    if (g_pData) {
        UnmapViewOfFile(g_pData);
        g_pData = NULL;
        if (g_hMap) {
            CloseHandle(g_hMap);
            g_hMap = NULL;
        }
    }
}

/*++

 Function Description:
    
    Logs a problem that the verifier has found 

 History:

    04/26/2001 dmunsil  Created

--*/
void
VLog(
    LPCSTR pszFmt, 
    ...
    )
{
    char    szT[1024];
    char*   szTemp;
    int     nLen;
    int     nRemain;
    va_list arglist;

    if (g_bLoggingDisabled) {
        return;
    }

    _snprintf(szT, 1023, "| %ls 0 '", DEBUGGER_LOG);

    nLen = lstrlenA(szT);
    szTemp = szT + nLen;
    nRemain = 1023 - nLen;

    if (nRemain > 0) {
        va_start(arglist, pszFmt);
        _vsnprintf(szTemp, nRemain, pszFmt, arglist);
        va_end(arglist);
    }

    szT[1023] = 0;
    WriteToProcessLog(szT);
}


/*++

 Function Description:
    
    Writes a line of text to the process log file 

 Return Value: 
    
 History:

    04/26/2001 dmunsil  Created

--*/
void
WriteToProcessLog(
    LPCSTR szLine
    )
{
    HANDLE hFile;
    DWORD  bytesWritten;

    if (g_bLoggingDisabled) {
        return;
    }

    // open the log file

    hFile = CreateFileW(g_szProcessLog,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        DPF("Cannot open verifier log file '%s'", g_szProcessLog);
        return;
    }

    // go to the end of the file

    SetFilePointer(hFile, 0, NULL, FILE_END);

    // make sure we have no '\n' or '\r' at the end of the string.

    int len = lstrlenA(szLine);

    while (len && (szLine[len - 1] == '\n' || szLine[len - 1] == '\r')) {
        len--;
    }

    // write the actual log

    WriteFile(hFile, szLine, len, &bytesWritten, NULL);

    // new line

    WriteFile(hFile, "\r\n", 2, &bytesWritten, NULL);

    CloseHandle(hFile);

    // dump it in the debugger as well on checked builds
#if DBG
    DPF((LPSTR)szLine);
#endif // DBG
    
}


/*++

 Function Description:
    
    Writes a line of text to the session log file 

 Return Value: 
    
 History:

    04/26/2001 dmunsil  Created

--*/
void
WriteToSessionLog(
    LPCSTR szLine
    )
{
    HANDLE hFile;
    DWORD  bytesWritten;

    if (g_bLoggingDisabled) {
        return;
    }

    // open the log file

    hFile = CreateFileW(g_szSessionLog,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        DPF("Cannot open verifier log file '%s'", g_szSessionLog);
        return;
    }

    // go to the end of the file

    SetFilePointer(hFile, 0, NULL, FILE_END);

    // make sure we have no '\n' or '\r' at the end of the string.

    int len = lstrlenA(szLine);

    while (len && (szLine[len - 1] == '\n' || szLine[len - 1] == '\r')) {
        len--;
    }

    // write the actual log

    WriteFile(hFile, szLine, len, &bytesWritten, NULL);

    // new line

    WriteFile(hFile, "\r\n", 2, &bytesWritten, NULL);

    CloseHandle(hFile);

    // dump it in the debugger as well on checked builds
#if DBG
    DPF((LPSTR)szLine);
#endif // DBG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\appverifier\viewlog.cpp ===
#include "precomp.h"

#include "viewlog.h"

CSessionLogEntry* g_pSessionLogHead = NULL;

TCHAR   g_szSingleLogFile[MAX_PATH] = _T("");

HWND g_hwndIssues;
int  g_cWidth;
int  g_cHeight;

TCHAR*
fGetLine(
    TCHAR* szLine,
    int    nChars,
    FILE*  file
    )
{
    if (_fgetts(szLine, nChars, file)) {
        int nLen = _tcslen(szLine);
        while (szLine[nLen - 1] == _T('\n') || szLine[nLen - 1] == _T('\r')) {
            szLine[nLen - 1] = 0;
            nLen--;
        }
        return szLine;
    } else {
        return NULL;
    }
}

CSessionLogEntry*
GetSessionLogEntry(
    HWND    hDlg,
    LPCTSTR szLogFullPath
    )
{
    TCHAR szLine[4096];
    FILE * file = NULL;
    SYSTEMTIME stime;
    CSessionLogEntry *pEntryTemp = NULL;
    TCHAR *szBegin = NULL;
    TCHAR *szEnd = NULL;

    HWND hTree = GetDlgItem(hDlg, IDC_ISSUES);

    file = _tfopen(szLogFullPath, _T("rt"));

    if (!file) {
        goto out;
    }

    if (fGetLine(szLine, 4096, file)) {

        ZeroMemory(&stime, sizeof(SYSTEMTIME));

        int nFields = _stscanf(szLine, _T("# LOG_BEGIN %hd/%hd/%hd %hd:%hd:%hd"), 
                               &stime.wMonth,
                               &stime.wDay,
                               &stime.wYear,
                               &stime.wHour,
                               &stime.wMinute,
                               &stime.wSecond);

        //
        // if we parsed that line properly, then we've got a valid line.
        // Parse it.
        //
        if (nFields == 6) {
            pEntryTemp = new CSessionLogEntry;
            if (!pEntryTemp) {
                goto out;
            }
            pEntryTemp->RunTime = stime;
            pEntryTemp->strLogPath = szLogFullPath;

            //
            // get the log file and exe path
            //
            szBegin = _tcschr(szLine, _T('\''));
            if (szBegin) {
                szBegin++;
                szEnd = _tcschr(szBegin, _T('\''));
                if (szEnd) {
                    TCHAR szName[MAX_PATH];
                    TCHAR szExt[_MAX_EXT];
                    *szEnd = 0;

                    pEntryTemp->strExePath = szBegin;

                    *szEnd = 0;

                    //
                    // split the path and get the name and extension
                    //
                    _tsplitpath(pEntryTemp->strExePath, NULL, NULL, szName, szExt);

                    pEntryTemp->strExeName = szName;
                    pEntryTemp->strExeName += szExt;
                }
            }

            //
            // Add it to the tree.
            //
            TVINSERTSTRUCT is;

            WCHAR szItem[256];

            wsprintf(szItem, L"%s - %d/%d/%d %d:%02d",
                     pEntryTemp->strExeName,
                     pEntryTemp->RunTime.wMonth,
                     pEntryTemp->RunTime.wDay,
                     pEntryTemp->RunTime.wYear,
                     pEntryTemp->RunTime.wHour,
                     pEntryTemp->RunTime.wMinute);

            is.hParent      = TVI_ROOT;
            is.hInsertAfter = TVI_LAST;
            is.item.lParam  = 0;
            is.item.mask    = TVIF_TEXT;
            is.item.pszText = szItem;

            pEntryTemp->hTreeItem = TreeView_InsertItem(hTree, &is);
        }
    }

out:

    if (file) {
        fclose(file);
        file = NULL;
    }

    return pEntryTemp;
}


DWORD
ReadSessionLog(HWND hDlg, CSessionLogEntry **ppSessionLog)
{
    TCHAR szLine[4096];
    FILE * file = NULL;
    SYSTEMTIME stime;
    CSessionLogEntry *pEntryTemp = NULL;
    DWORD dwEntries = 0;
    TCHAR *szBegin = NULL;
    TCHAR *szEnd = NULL;
    CSessionLogEntry **ppEnd = ppSessionLog;

    HWND hTree = GetDlgItem(hDlg, IDC_ISSUES);

    TCHAR szVLog[MAX_PATH];
    TCHAR szLogFullPath[MAX_PATH];

    WIN32_FIND_DATA FindData;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    TCHAR szLogSearch[MAX_PATH];

    //
    // BUGBUG -- this is cheesy, but it's the fastest way to make the change
    // to remove session.log. Going forward, we should combine these two functions
    // into one, and switch to vectors instead of linked lists
    //
    GetSystemWindowsDirectory(szVLog, MAX_PATH);
    _tcscat(szVLog, _T("\\AppPatch\\VLog\\"));
    _tcscpy(szLogSearch, szVLog);
    _tcscat(szLogSearch, _T("*.log"));

    //
    // enumerate all the logs and make entries for them
    //
    hFind = FindFirstFile(szLogSearch, &FindData);
    while (hFind != INVALID_HANDLE_VALUE) {

        //
        // make sure to exclude session.log, in case we're using older shims
        //
        if (_tcsicmp(FindData.cFileName, _T("session.log")) == 0) {
            goto nextFile;
        }

        _tcscpy(szLogFullPath, szVLog);
        _tcscat(szLogFullPath, FindData.cFileName);

        pEntryTemp = GetSessionLogEntry(hDlg, szLogFullPath);
        if (pEntryTemp) {
            //
            // we want these in the order they appear in the log,
            // so we add to the end rather than the beginning.
            //
            *ppEnd = pEntryTemp;
            ppEnd = &(pEntryTemp->pNext);

            dwEntries++;
        }

nextFile:

        if (!FindNextFile(hFind, &FindData)) {
            FindClose(hFind);
            hFind = INVALID_HANDLE_VALUE;
        }
    }

    return dwEntries;
}

DWORD
ReadProcessLog(HWND hDlg, CSessionLogEntry* pSLogEntry)
{
    TCHAR szLine[4096];
    FILE * file = NULL;
    CProcessLogEntry *pProcessEntry = NULL;
    TCHAR szShimName[256];
    DWORD dwEntries = 0;
    TCHAR * szTemp = NULL;
    DWORD dwEntry = 0;
    TCHAR *szBegin = NULL;
    CProcessLogEntry **ppProcessTail = &(pSLogEntry->pProcessLog);


    HWND hTree = GetDlgItem(hDlg, IDC_ISSUES);

    if (!pSLogEntry) {
        return 0;
    }

    file = _tfopen(pSLogEntry->strLogPath, _T("rt"));

    if (!file) {
        return 0;
    }

    //
    // first get the headers
    //
    szTemp = fGetLine(szLine, 4096, file);
    while (szTemp) {

        if (szLine[0] == _T('|')) {
            break;
        }
        if (szLine[0] != _T('#')) {
            goto nextLine;
        }


        if (_stscanf(szLine, _T("# LOGENTRY %s %d '"), szShimName, &dwEntry) == 2) {
            if (pProcessEntry) {
                *ppProcessTail = pProcessEntry;
                ppProcessTail = &(pProcessEntry->pNext);
                pProcessEntry = NULL;
                dwEntries++;
            }

            pProcessEntry = new CProcessLogEntry;
            if (!pProcessEntry) {
                goto out;
            }
            pProcessEntry->strShimName = szShimName;
            pProcessEntry->dwLogNum = dwEntry;

            szBegin = _tcschr(szLine, _T('\''));
            if (szBegin) {
                szBegin++;
                pProcessEntry->strLogTitle = szBegin;
            }
        } else if (_tcsncmp(szLine, _T("# DESCRIPTION BEGIN"), 19) == 0) {
            szTemp = fGetLine(szLine, 4096, file);
            while (szTemp) {
                if (_tcsncmp(szLine, _T("# DESCRIPTION END"), 17) == 0) {
                    break;
                }
                if (pProcessEntry) {

                    //
                    // throw in a carriage return if necessary
                    //
                    if (pProcessEntry->strLogDescription.GetLength()) {
                        pProcessEntry->strLogDescription += _T("\n");
                    }
                    pProcessEntry->strLogDescription += szLine;
                }
                szTemp = fGetLine(szLine, 4096, file);
            }
        } else if (_tcsncmp(szLine, _T("# URL '"), 7) == 0) {
            szBegin = _tcschr(szLine, _T('\''));
            if (szBegin) {
                szBegin++;
                pProcessEntry->strLogURL = szBegin;
            }
        }

        nextLine:
        szTemp = fGetLine(szLine, 4096, file);

    }

    //
    // if we've still got an entry in process, save it
    //
    if (pProcessEntry) {
        *ppProcessTail = pProcessEntry;
        ppProcessTail = &(pProcessEntry->pNext);

        pProcessEntry = NULL;
        dwEntries++;
    }

    //
    // now read all the log lines
    //
    while (szTemp) {
        CProcessLogEntry *pEntry;
        TCHAR szName[256];

        int nFields = _stscanf(szLine, _T("| %s %d '"), szName, &dwEntry);
        if (nFields == 2) {
            BOOL bFound = FALSE;
            pEntry = pSLogEntry->pProcessLog;
            while (pEntry) {
                if (pEntry->strShimName == szName && pEntry->dwLogNum == dwEntry) {
                    pEntry->dwOccurences++;
                    bFound = TRUE;

                    //
                    // here's where we would save the occurrence info
                    //
                    szBegin = _tcschr(szLine, _T('\''));
                    if (szBegin) {
                        szBegin++;

                        pEntry->arrProblems.Add(szBegin);
                    }

                    break;
                }

                pEntry = pEntry->pNext;
            }

            if (!bFound) {
                //
                // need to dump a debug string -- no matching log entry found
                //
                ;
            }
        }

        szTemp = fGetLine(szLine, 4096, file);

    }

    out:
    //
    // Add it to the tree
    //
    pProcessEntry = pSLogEntry->pProcessLog;

    while (pProcessEntry != NULL) {
        if (pProcessEntry->dwOccurences > 0) {
            TVINSERTSTRUCT is;

            is.hParent      = pSLogEntry->hTreeItem;
            is.hInsertAfter = TVI_LAST;
            is.item.lParam  = (LPARAM)pProcessEntry;
            is.item.mask    = TVIF_TEXT | TVIF_PARAM;
            is.item.pszText = pProcessEntry->strLogTitle.GetBuffer(0);

            pProcessEntry->hTreeItem = TreeView_InsertItem(hTree, &is);

            for (int i = 0; i < pProcessEntry->arrProblems.GetSize(); i++) {
                is.hParent      = pProcessEntry->hTreeItem;
                is.hInsertAfter = TVI_LAST;
                is.item.lParam  = 0;
                is.item.mask    = TVIF_TEXT;
                is.item.pszText = pProcessEntry->arrProblems.GetAt(i).GetBuffer(0);

                TreeView_InsertItem(hTree, &is);
            }
        }

        pProcessEntry = pProcessEntry->pNext;
    }

    if (file) {
        fclose(file);
        file = NULL;
    }

    return dwEntries;

}

void
SetLogDialogCaption(HWND hDlg, ULONG ulCaptionID, LPCWSTR szAdditional)
{
    wstring wstrCaption;

    if (AVLoadString(ulCaptionID, wstrCaption)) {
        if (szAdditional) {
            wstrCaption += szAdditional;
        }

        SetWindowText(hDlg, wstrCaption.c_str());
    }
}

void
RefreshLog(HWND hDlg)
{
    TreeView_DeleteAllItems(g_hwndIssues);

    if (g_pSessionLogHead) {
        delete g_pSessionLogHead;
        g_pSessionLogHead = NULL;
    }

    if (g_szSingleLogFile[0]) {
        g_pSessionLogHead = GetSessionLogEntry(hDlg, g_szSingleLogFile);
        SetLogDialogCaption(hDlg, IDS_LOG_TITLE_SINGLE, g_szSingleLogFile);
    } else {
        ReadSessionLog(hDlg, &g_pSessionLogHead);
        SetLogDialogCaption(hDlg, IDS_LOG_TITLE_LOCAL, NULL);
    }

    CSessionLogEntry* pEntry = g_pSessionLogHead;

    while (pEntry) {
        ReadProcessLog(hDlg, pEntry);
        pEntry = pEntry->pNext;
    }

    EnableWindow(GetDlgItem(hDlg, IDC_BTN_DELETE_LOG), FALSE);

}


void
HandleSizing(
    HWND hDlg
    )
{
    int  nWidth;
    int  nHeight;
    RECT rDlg;

    HDWP hdwp = BeginDeferWindowPos(0);
    
    GetWindowRect(hDlg, &rDlg);

    nWidth = rDlg.right - rDlg.left;
    nHeight = rDlg.bottom - rDlg.top;

    int deltaW = nWidth - g_cWidth;
    int deltaH = nHeight - g_cHeight;

    HWND hwnd;
    RECT r;

    hwnd = GetDlgItem(hDlg, IDC_ISSUES);

    GetWindowRect(hwnd, &r);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   0,
                   0,
                   r.right - r.left + deltaW,
                   r.bottom - r.top + deltaH,
                   SWP_NOMOVE | SWP_NOZORDER);

    hwnd = GetDlgItem(hDlg, IDC_SOLUTIONS_STATIC);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left,
                   r.top + deltaH,
                   0,
                   0,
                   SWP_NOSIZE | SWP_NOZORDER);

    hwnd = GetDlgItem(hDlg, IDC_ISSUE_DESCRIPTION);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left,
                   r.top + deltaH,
                   r.right - r.left + deltaW,
                   r.bottom - r.top,
                   SWP_NOZORDER);

    EndDeferWindowPos(hdwp);
    
    g_cWidth = nWidth;
    g_cHeight = nHeight;
}

CSessionLogEntry*
GetSessionLogEntryFromHItem(
    HTREEITEM hItem
    )
{
    CSessionLogEntry* pEntry = g_pSessionLogHead;

    while (pEntry) {
        if (pEntry->hTreeItem == hItem) {
            return pEntry;
        }
        pEntry = pEntry->pNext;
    }

    return NULL;
}

void
DeleteAllLogs(
    HWND hDlg
    )
{
    ResetVerifierLog();

    RefreshLog(hDlg);
}

void
ExportSelectedLog(
    HWND hDlg
    )
{
    HTREEITEM hItem = TreeView_GetSelection(g_hwndIssues);
    WCHAR szName[MAX_PATH];
    WCHAR szExt[MAX_PATH];
    wstring wstrName;

    if (hItem == NULL) {
        return;
    }

    CSessionLogEntry* pSession;
    TVITEM            ti;

    //
    // first check if this is a top-level item
    //
    pSession = GetSessionLogEntryFromHItem(hItem);
    if (!pSession) {
        return;
    }

    _wsplitpath(pSession->strLogPath, NULL, NULL, szName, szExt);

    wstrName = szName;
    wstrName += szExt;

    WCHAR           wszFilter[] = L"Log files (*.log)\0*.log\0";
    OPENFILENAME    ofn;
    WCHAR           wszAppFullPath[MAX_PATH];
    WCHAR           wszAppShortName[MAX_PATH];
    wstring         wstrTitle;

    if (!AVLoadString(IDS_EXPORT_LOG_TITLE, wstrTitle)) {
        wstrTitle = _T("Export Log");
    }

    wcscpy(wszAppFullPath, wstrName.c_str());

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hDlg;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = wszFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = wszAppFullPath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = wszAppShortName;
    ofn.nMaxFileTitle     = MAX_PATH;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = wstrTitle.c_str();
    ofn.Flags             = OFN_HIDEREADONLY;     // hide the "open read-only" checkbox                
    ofn.lpstrDefExt       = _T("log");

    if ( !GetSaveFileName(&ofn) )
    {
        return;
    }


    if (CopyFile(pSession->strLogPath, wszAppFullPath, FALSE) == 0) {
        DWORD dwErr = GetLastError();

        AVErrorResourceFormat(IDS_CANT_COPY, dwErr);
    }
}

void
DeleteSelectedLog(
    HWND hDlg
    )
{
    HTREEITEM hItem = TreeView_GetSelection(g_hwndIssues);

    if (hItem == NULL) {
        return;
    }

    CSessionLogEntry* pSession;
    TVITEM            ti;

    //
    // first check if this is a top-level item
    //
    pSession = GetSessionLogEntryFromHItem(hItem);
    if (!pSession) {
        return;
    }

    DeleteFile(pSession->strLogPath);

    RefreshLog(hDlg);

    
}

void
HandleSelectionChanged(
    HWND      hDlg,
    HTREEITEM hItem
    )
{
    CProcessLogEntry* pEntry;
    CSessionLogEntry* pSession;
    TVITEM            ti;

    //
    // first check if this is a top-level item
    //
    pSession = GetSessionLogEntryFromHItem(hItem);
    if (pSession && !g_szSingleLogFile[0]) {
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_EXPORT_LOG), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_DELETE_LOG), TRUE);
    } else {
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_EXPORT_LOG), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_DELETE_LOG), FALSE);
    }
    

    ti.mask  = TVIF_HANDLE | TVIF_PARAM;
    ti.hItem = hItem;

    TreeView_GetItem(g_hwndIssues, &ti);

    if (ti.lParam == 0) {

        hItem = TreeView_GetParent(g_hwndIssues, hItem);

        ti.mask  = TVIF_HANDLE | TVIF_PARAM;
        ti.hItem = hItem;

        TreeView_GetItem(g_hwndIssues, &ti);

        if (ti.lParam == 0) {
            return;
        }
    }

    pEntry = (CProcessLogEntry*)ti.lParam;

    SetDlgItemText(hDlg, IDC_ISSUE_DESCRIPTION, pEntry->strLogDescription);
}

// Message handler for log view dialog.
LRESULT CALLBACK
DlgViewLog(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HDC hDC;

    switch (message) {
    case WM_INITDIALOG:
        {
            EnableWindow(GetDlgItem(hDlg, IDC_BTN_DELETE_LOG), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_BTN_EXPORT_LOG), FALSE);

            if (g_szSingleLogFile[0]) {
                EnableWindow(GetDlgItem(hDlg, IDC_BTN_DELETE_ALL), FALSE);
            }

            g_hwndIssues = GetDlgItem(hDlg, IDC_ISSUES);

            RECT r;

            GetWindowRect(hDlg, &r);

            g_cWidth = r.right - r.left;
            g_cHeight = r.bottom - r.top;

            RefreshLog(hDlg);

            return TRUE;
        }
        break;

    case WM_SIZE:
        HandleSizing(hDlg);
        break;

    case WM_GETMINMAXINFO:
        {
            MINMAXINFO* pmmi = (MINMAXINFO*)lParam;

            pmmi->ptMinTrackSize.y = 300;

            return 0;
            break;
        }

    case WM_NOTIFY:
        if (wParam == IDC_ISSUES) {

            LPNMHDR pnm = (LPNMHDR)lParam;

            if (g_hwndIssues == NULL) {
                break;
            }

            switch (pnm->code) {
            case NM_CLICK:
                {
                    TVHITTESTINFO ht;
                    HTREEITEM     hItem;

                    GetCursorPos(&ht.pt);

                    ScreenToClient(g_hwndIssues, &ht.pt);

                    TreeView_HitTest(g_hwndIssues, &ht);

                    if (ht.hItem == NULL) {
                        break;
                    }

                    HandleSelectionChanged(hDlg, ht.hItem);
                    break;
                }
            case TVN_SELCHANGED:
                {
                    NM_TREEVIEW* pnmtv = (NM_TREEVIEW*)pnm;

                    HandleSelectionChanged(hDlg, pnmtv->itemNew.hItem);
                    break;
                }
            }
        } else if (wParam == IDC_ISSUE_DESCRIPTION) {
            LPNMHDR pnm = (LPNMHDR)lParam;

            if (g_hwndIssues == NULL) {
                break;
            }

            switch (pnm->code) {
            case NM_CLICK:
                {
                    SHELLEXECUTEINFO sei = { 0};

                    HTREEITEM hItem = TreeView_GetSelection(g_hwndIssues);

                    if (hItem == NULL) {
                        break;
                    }

                    CProcessLogEntry* pEntry;
                    TVITEM            ti;

                    ti.mask  = TVIF_HANDLE | TVIF_PARAM;
                    ti.hItem = hItem;

                    TreeView_GetItem(g_hwndIssues, &ti);

                    if (ti.lParam == 0) {
                        hItem = TreeView_GetParent(g_hwndIssues, hItem);

                        ti.mask  = TVIF_HANDLE | TVIF_PARAM;
                        ti.hItem = hItem;

                        TreeView_GetItem(g_hwndIssues, &ti);

                        if (ti.lParam == 0) {
                            break;
                        }
                    }

                    pEntry = (CProcessLogEntry*)ti.lParam;

                    SetDlgItemText(hDlg, IDC_ISSUE_DESCRIPTION, pEntry->strLogDescription);

                    sei.cbSize = sizeof(SHELLEXECUTEINFO);
                    sei.fMask  = SEE_MASK_DOENVSUBST;
                    sei.hwnd   = hDlg;
                    sei.nShow  = SW_SHOWNORMAL;
                    sei.lpFile = pEntry->strLogURL;

                    ShellExecuteEx(&sei);
                }
            }
        }
        break;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {
        case IDC_BTN_DELETE_LOG:
            DeleteSelectedLog(hDlg);
            break;

        case IDC_BTN_DELETE_ALL:
            DeleteAllLogs(hDlg);
            break;

        case IDC_BTN_EXPORT_LOG:
            ExportSelectedLog(hDlg);
            break;
        
        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, LOWORD(wParam));
            return TRUE;
            break;
        }
        break;

    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\checkacversion\buildno.h ===
// This will end up being OSMaj,OSMin,0,AC_BUILD
// So if AC_BUILD is 1 and the OS is 5.1 (XP), the final version will 5,1,0,1

#pragma once
#define AC_BUILD 1
#define AC_GUID "{2eac6a2d-57a8-44d4-96f7-e32bab40ca5f}"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\checkacversion\resource.h ===
#pragma once


#define STATUS_SP_VERSION_GREATER_1        0xf06a
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\appverifier\viewlog.h ===
#ifndef __APPVERIFIER_VIEWLOG_H_
#define __APPVERIFIER_VIEWLOG_H_

extern TCHAR   g_szSingleLogFile[MAX_PATH];

class CProcessLogEntry {
public:
    CString     strShimName;
    DWORD       dwLogNum;

    CString     strLogTitle;
    CString     strLogDescription;
    CString     strLogURL;
    DWORD       dwOccurences;

    CStringArray    arrProblems;

    HTREEITEM   hTreeItem;
    
    CProcessLogEntry *  pNext;

    CProcessLogEntry(void) : 
        pNext(NULL), 
        dwLogNum(0),
        dwOccurences(0) {}

    ~CProcessLogEntry() {
        if (pNext) {
            delete pNext;
            pNext = NULL;
        }
    }
};

class CSessionLogEntry {
public:
    CString     strExeName;  // just name and ext
    CString     strExePath;  // full path to exe
    SYSTEMTIME  RunTime;
    CString     strLogPath;  // full path to log

    HTREEITEM   hTreeItem;

    CProcessLogEntry *  pProcessLog;
    CSessionLogEntry *  pNext;

    CSessionLogEntry(void) :
        pNext(NULL),
        pProcessLog(NULL) {
        ZeroMemory(&RunTime, sizeof(SYSTEMTIME));
    }

    ~CSessionLogEntry() {
        if (pProcessLog) {
            delete pProcessLog;
            pProcessLog = NULL;
        }
        if (pNext) {
            delete pNext;
            pNext = NULL;
        }
    }
};

LRESULT CALLBACK DlgViewLog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif // #ifndef __APPVERIFIER_VIEWLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\checkacversion\main.cpp ===
/*++

    Copyright (c) 2001  Microsoft Corporation

    Module Name:

        main.cpp

    Abstract:

        This is the customization DLL for update.exe.  When the AppCompat package
        is installed, the first thing that happens is update.exe calls BeginInstallation().
        
        That function checks the registry for the version of the already-installed package.
        The user may continue to install THIS package under the following conditions:
        
        - There is no package already installed
        - There is any corruption in these registry values
        - The package that's already installed is an older version than this one.

        The user will not be able to install this package under only the condition that he/she
        has a package already installed that's a newer version.

    Notes:
        
        * This is written in ANSI because Update.exe is ANSI and a Unicode implementation would add
          no value.
        
        * Any messages in the string table of AcVersion.rc will override messages in Update.exe.
          For instance, if BeginInstallation() returns STATUS_SP_VERSION_GREATER_1, normally the
          message in Update.exe's resources that corresponds to this would be displayed to the user.
          If there is, however, a STATUS_SP_VERSION_GREATER_1 string in AcVersion.rc, it will be used
          instead.  This way we can use either Update.exe's strings OR our own custom strings.
          
          This works for all areas of the installer, by the way, not just BeginInstallation() return value.
          For instance, adding a STR_WELCOME_LINE string in AcVersion.rc would replace the corresponding
          string in Update.exe.
        
    Author:

        carlco     created     07/30/2001

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include "buildno.h"
#include "resource.h"


#define THIS_MAJOR         5
#define THIS_MINOR         1
#define THIS_BUILD         0
#define THIS_REVISION      AC_BUILD

// This is from %WIN2k_SE_ROOT%\private\windows\setup\srvpack5\update4\resource.h
//#define STATUS_SP_VERSION_GREATER_1        0xf06a
#define STR_WELCOME_LINE                   0xf039
#define STATUS_BUILD_VERSION_MISMATCH      0xf020

/*
    This is the code that will be passed back to update.exe to notify the mechanism that
    a package has already been installed that is a greater version than this one.
*/
#define QFE_FAIL_CODE      STATUS_SP_VERSION_GREATER_1
//#define QFE_FAIL_CODE      IDS_TEST


/*

Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{2eac6a2d-57a8-44d4-96f7-e32bab40ca5f}]
@="Windows Update"
"ComponentID"="Windows XP Application Compatibility Update"
"IsInstalled"=dword:00000001
"Locale"="*"
"Version"="1,0,2205,0"

*/

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, PVOID lpvReserved)
{
    return TRUE;
}


#define GRABNEXTTOKEN(a)                              \
    sz = strchr(szTok, ',');                          \
    if(sz == NULL)                                    \
    {                                                 \
        return S_OK;                                  \
    }                                                 \
    *sz = 0;                                          \
    (a) = atoi(szTok);                                \
    szTok = sz + 1;


DWORD BeginInstallation(PVOID pCustomInfo)
{
    HKEY hKey = NULL;
    CHAR szVersion[25];
    DWORD dwSize = 25;
//CHAR szBuf[500];

    DWORD dwMajor = 0;
    DWORD dwMinor = 0;
    DWORD dwBuild = 0;
    DWORD dwRevision = 0;
    PSTR sz = NULL;
    PSTR szTok = NULL;
    
//sprintf(szBuf, "BeginInstallation\n");
//OutputDebugString(szBuf);

    if(ERROR_SUCCESS != RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        "SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\" AC_GUID,
        NULL,
        KEY_QUERY_VALUE,
        &hKey))
    {
        // Error opening the key - the package may not be installed, so it's OK to install it.
        return S_OK;
    }

    // Get the version
    if(ERROR_SUCCESS != RegQueryValueEx(
        hKey, "Version", NULL, NULL, (PBYTE)szVersion, &dwSize
        ))
    {
        // Error getting this value; let's install the package.
        RegCloseKey(hKey);
        return S_OK;
    }

    RegCloseKey(hKey);

    // Examine the version.  Find the major version number.
    // Find the first comma and replace it with a NULL
    
    szTok = szVersion;
    GRABNEXTTOKEN(dwMajor)
    GRABNEXTTOKEN(dwMinor)
    GRABNEXTTOKEN(dwBuild)
    
    // Now there shouldn't be any more commas left.
    // szTok is the last token.
    dwRevision = atoi(szTok);

//sprintf(szBuf, "%d,%d,%d,%d\n", dwMajor, dwMinor, dwBuild, dwRevision);
//OutputDebugString(szBuf);

    /*
        If we've made it this far, we can now compare the version.
    */
    if(dwMajor > THIS_MAJOR)
    {
        return QFE_FAIL_CODE;
    }

    if(dwMajor == THIS_MAJOR)
    {
        if(dwMinor > THIS_MINOR)
        {
            return QFE_FAIL_CODE;
        }
        
        if(dwMinor == THIS_MINOR)
        {
            if(dwBuild > THIS_BUILD)
            {
                return QFE_FAIL_CODE;
            }
            
            if(dwBuild == THIS_BUILD)
            {
                if(dwRevision > THIS_REVISION) return QFE_FAIL_CODE;
            }
        }
    }

    
    return S_OK;
}


DWORD EndInstallation(PVOID pCustomInfo)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\compatui\accelcontainer.cpp ===
// AccelContainer.cpp: implementation of the CAccelContainer class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "AccelContainer.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

typedef struct _VKEYS { 
    LPCTSTR pKeyName; 
    WORD    virtKey;
} VKEYS; 
 
VKEYS vkeys[] = { 
    TEXT("BkSp"), VK_BACK,
    TEXT("PgUp"), VK_PRIOR,    
    TEXT("PgDn"), VK_NEXT,
    TEXT("End"),  VK_END,
    TEXT("Home"), VK_HOME, 
    TEXT("Left"), VK_LEFT, 
    TEXT("Up"),   VK_UP, 
    TEXT("Right"),VK_RIGHT, 
    TEXT("Down"), VK_DOWN, 
    TEXT("Ins"),  VK_INSERT, 
    TEXT("Del"),  VK_DELETE, 
    TEXT("Mult"), VK_MULTIPLY, 
    TEXT("Add"),  VK_ADD, 
    TEXT("Sub"),  VK_SUBTRACT, 
    TEXT("DecPt"),VK_DECIMAL, 
    TEXT("Div"),  VK_DIVIDE, 
    TEXT("F2"),   VK_F2, 
    TEXT("F3"),   VK_F3, 
    TEXT("F5"),   VK_F5, 
    TEXT("F6"),   VK_F6, 
    TEXT("F7"),   VK_F7, 
    TEXT("F8"),   VK_F8, 
    TEXT("F9"),   VK_F9, 
    TEXT("F10"),  VK_F10,
    TEXT("F11"),  VK_F11, 
    TEXT("F12"),  VK_F12 
}; 

wstring CAccelContainer::GetKeyFromAccel(const ACCEL& accel)
{
    int i;
    wstring strAccel((LPCTSTR)&accel.key, 1);
    
    
    for (i = 0; i < sizeof(vkeys)/sizeof(vkeys[0]); ++i) {
        if (vkeys[i].virtKey == accel.key) {
            strAccel = vkeys[i].pKeyName;
            break;
        }
    }

    return strAccel;
}


BOOL CAccelContainer::IsAccelKey(LPMSG pMsg, WORD* pCmd) 
{
    ACCELVECTOR::iterator iter;
    WORD fVirtKey = 0;
    //
    //
    if (NULL == pMsg) {
        fVirtKey |= (GetKeyState(VK_MENU)    & 0x8000) ? FALT : 0;
        fVirtKey |= (GetKeyState(VK_CONTROL) & 0x8000) ? FCONTROL : 0;
        fVirtKey |= (GetKeyState(VK_SHIFT)   & 0x8000) ? FSHIFT : 0;
        fVirtKey |= FVIRTKEY;
        
        for (iter = m_Accel.begin(); iter != m_Accel.end(); ++iter) {
            const ACCEL& accl = *iter;            
            
            if (GetKeyState(accl.key) & 0x8000) {
                //
                // pressed! see if we have a match
                //
                if (fVirtKey == accl.fVirt) {
                    // 
                    // we do have a match 
                    //
                    if (pCmd) {
                        *pCmd = accl.cmd;
                    }
                    return TRUE;

                }    
            }
        }
    } else {

        // one of the nasty messages ?
        if (pMsg->message == WM_SYSKEYDOWN || pMsg->message == WM_SYSKEYUP) {
            fVirtKey = (pMsg->lParam & 0x20000000) ? FALT : 0;
            fVirtKey |= FVIRTKEY; // always a virtkey code
                        
            for (iter = m_Accel.begin(); iter != m_Accel.end(); ++iter) {
                const ACCEL& accl = *iter;            
            
                if (pMsg->wParam == accl.key) {
                    //
                    // pressed! see if we have a match
                    //
                    if (fVirtKey == accl.fVirt) {
                        // 
                        // we do have a match 
                        //
                        if (pCmd) {
                            *pCmd = accl.cmd;
                        }
                        return TRUE;

                    }    
                }
            }            
        }

    }

    return FALSE;

}



VOID CAccelContainer::ParseAccelString(LPCTSTR lpszStr, WORD wCmd) 
{
    LPCTSTR pch = lpszStr;
    LPCTSTR pchEnd, pchb;
    ACCEL   accl;

    //
    // nuke all
    // 
    
    

    while (*pch) {

        //
        // skip whitespace 
        //
        pch += _tcsspn(pch, TEXT(" \t"));

        //
        // see what kind of key this is
        //
        if (*pch == TEXT('{')) {
            // some special key
            ++pch;
            pch += _tcsspn(pch, TEXT(" \t"));

            int i;
            for (i = 0; i < sizeof(vkeys)/sizeof(vkeys[0]); ++i) {
                int nLen = _tcslen(vkeys[i].pKeyName);
                if (!_tcsnicmp(pch, vkeys[i].pKeyName, nLen)) {
                    // aha -- we have a match
                    //
                    accl.cmd   = wCmd;
                    accl.fVirt = FALT|FVIRTKEY;
                    accl.key   = vkeys[i].virtKey;
                    m_Accel.push_back(accl);

                    pch += nLen;
                    pch += _tcsspn(pch, TEXT(" \t"));
                    break;
                }
            }

            pchEnd = _tcschr(pch, '}');
            pchb   = _tcschr(pch, '{');
            if (pchEnd != NULL && (pchb == NULL || pchEnd < pchb)) {
                pch = pchEnd + 1; // one past the bracket
            }

            // what if we have not succeeded - and no closing bracket ? 
            // we skip the bracket and go ahead as character


        } else if (_istalnum(*pch)) { // normal key

            TCHAR ch = _totupper(*pch);
            accl.cmd   = wCmd;
            accl.fVirt = FALT|FVIRTKEY;
            accl.key   = ch; 
            
            m_Accel.push_back(accl);
            ++pch;
        } else {
            ++pch; // skip the char, we can't recognize it
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\compatui\accelcontainer.h ===
// AccelContainer.h: interface for the CAccelContainer class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ACCELCONTAINER_H__DEBE6100_DEDC_41E0_995A_67D2922897D0__INCLUDED_)
#define AFX_ACCELCONTAINER_H__DEBE6100_DEDC_41E0_995A_67D2922897D0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

///////////////////////////////// STL 

#pragma warning(disable:4786)
#include <string>
#include <xstring>
#include <map>
#include <algorithm>
#include <vector>
#include <set>

using namespace std;

/////////////////////////////////////

class CAccelContainer  
{
public:
    CAccelContainer() {}
    virtual ~CAccelContainer() {}


    typedef vector<ACCEL > ACCELVECTOR;

    ACCELVECTOR m_Accel;        // accelerators
    
    CAccelContainer& operator=(LPCTSTR lpszStr) {
        SetAccel(lpszStr);
        return *this;
    }

    void SetAccel(LPCTSTR lpszStr, WORD wCmd = 0) {
        ParseAccelString(lpszStr, wCmd);
    }

    void ClearAccel() {
        m_Accel.erase(m_Accel.begin(), m_Accel.end());
    }

    VOID ParseAccelString(LPCTSTR lpszStr, WORD wCmd);
    BOOL IsAccelKey(LPMSG pMsg, WORD* pCmd = NULL);

    int GetCount() {
        return m_Accel.size();
    }
    const ACCEL& GetAccel(int nPos) {
        return m_Accel[nPos];
    }

    wstring GetKeyFromAccel(const ACCEL& accel);

    wstring GetAccelString(WORD wCmd = 0) {
        ACCELVECTOR::iterator iter;
        wstring strAccel;

        for (iter = m_Accel.begin(); iter != m_Accel.end(); ++iter) {
            const ACCEL& accel = *iter;
            if (accel.cmd == wCmd) {
                strAccel += GetKeyFromAccel(accel);
            }
        }
        return strAccel;
    }

};

#endif // !defined(AFX_ACCELCONTAINER_H__DEBE6100_DEDC_41E0_995A_67D2922897D0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\compatui\ntutil.c ===
#define WIN
#define FLAT_32
#define TRUE_IF_WIN32   1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define _WINDOWS
#include <windows.h>
#include "shimdb.h"


//
// Routine in ahcache.c
//

BOOL 
SDBAPI
ApphelpUpdateCacheEntry(
    LPCWSTR pwszPath,           // nt path
    HANDLE  hFile,              // file handle 
    BOOL    bDeleteEntry,       // TRUE if we are to delete the entry
    BOOL    bNTPath             // if TRUE -- NT path, FALSE - dos path
    );

//
//
// Global stuff used elsewhere
//

VOID
InvalidateAppcompatCacheEntry(
    LPCWSTR pwszDosPath
    )
{
    ApphelpUpdateCacheEntry(pwszDosPath, INVALID_HANDLE_VALUE, TRUE, FALSE);
}

//
// Determine if a file is in the root or if the file is in the leaf
//

BOOL
WINAPI
CheckFileLocation(
    LPCWSTR pwszDosPath,
    BOOL* pbRoot,
    BOOL* pbLeaf
    )
{
    BOOL            TranslationStatus;
    UNICODE_STRING  PathName;
    PWSTR           FileName = NULL;
    RTL_PATH_TYPE   PathType;
    WIN32_FIND_DATA FindData;
    BOOL            bLeaf;
    BOOL            bSuccess = FALSE;
    WCHAR           wszFileName[MAX_PATH];  
    PWSTR           FreeBuffer = NULL;
    NTSTATUS        Status;
    ULONG           Length;
    HANDLE          hFind = INVALID_HANDLE_VALUE;
    static LPCWSTR  pwszPrefixWin32 = TEXT("\\??\\"); // std win32 path prefix
    static LPCWSTR  pwszPrefixUNC   = TEXT("\\UNC\\");
    UCHAR           DosPathBuffer[MAX_PATH*2];
    RTL_UNICODE_STRING_BUFFER DosPath;

    RtlInitUnicodeStringBuffer(&DosPath, DosPathBuffer, sizeof(DosPathBuffer));
    
    TranslationStatus = RtlDosPathNameToNtPathName_U(pwszDosPath,
                                                     &PathName,
                                                     &FileName,
                                                     NULL);
    if (!TranslationStatus) {
        goto cleanup;
    }

    FreeBuffer = PathName.Buffer;

    if (FileName == NULL) {
        goto cleanup;
    }

    PathName.Length = (USHORT)((ULONG_PTR)FileName - (ULONG_PTR)PathName.Buffer);
    wcscpy(wszFileName, FileName);

    //
    // path name is ready for open -- sanitize the '\\'
    //
    if (PathName.Length > 2 * sizeof(WCHAR)) {
        if (RTL_STRING_GET_LAST_CHAR(&PathName) == L'\\' &&
            RTL_STRING_GET_AT(&PathName, RTL_STRING_GET_LENGTH_CHARS(&PathName) - 2) != L':') {
            PathName.Length -= sizeof(UNICODE_NULL);
        }
    }

   
    Status = RtlGetLengthWithoutLastFullDosOrNtPathElement(0, &PathName, &Length);
    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }

    if (Length == wcslen(pwszPrefixWin32)) { // this is root path of whatever kind you think it is
        *pbRoot = TRUE;
    }

    //
    // check if this is a leaf node in fact
    // the way we know is this:
    // - if it's the only file in that node
    // - there are no other files / subdirectories in this directory
    //

    // append * to the path name

    if (PathName.MaximumLength < PathName.Length + 2 * sizeof(WCHAR)) {
        goto cleanup;
    }

    RtlAppendUnicodeToString(&PathName, 
                             RTL_STRING_GET_LAST_CHAR(&PathName) == TEXT('\\') ? TEXT("*") : TEXT("\\*"));

    // convert the string to dos path
    Status = RtlAssignUnicodeStringBuffer(&DosPath, &PathName);
    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }
    
    Status = RtlNtPathNameToDosPathName(0, &DosPath, NULL, NULL);
    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }

    hFind = FindFirstFileW(DosPath.String.Buffer, &FindData);
    if (hFind == INVALID_HANDLE_VALUE) {
        // we should at least have found a file we came here with
        goto cleanup;
    }

    bLeaf = TRUE;
    do {
        // check for . and ..
        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            if (wcscmp(FindData.cFileName, TEXT(".")) == 0 || wcscmp(FindData.cFileName, TEXT(".."))) {
                continue;
            }
            bLeaf = FALSE;
            break;
        }

        // ok, we are the file, make sure we're not the same file
        //
        if (_wcsicmp(FindData.cFileName, FileName) != 0) {
            bLeaf = FALSE;
            break;
        }

    } while (FindNextFileW(hFind, &FindData));

    *pbLeaf = bLeaf;
    bSuccess = TRUE;

cleanup:


    if (hFind != INVALID_HANDLE_VALUE) {
        FindClose(hFind);
    }

    if (FreeBuffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    }

    RtlFreeUnicodeStringBuffer(&DosPath);
    
    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\compatui\progview.cpp ===
// ProgView.cpp : Implementation of CProgView

#include "stdafx.h"
#include <commctrl.h>
#include "CompatUI.h"
#include "ProgView.h"

/////////////////////////////////////////////////////////////////////////////
// CProgView

HRESULT
CProgView::InPlaceActivate(
    LONG iVerb, 
    const RECT* prcPosRect
    )
{
    HRESULT hr = CComCompositeControl<CProgView>::InPlaceActivate(iVerb, prcPosRect);

    
/*
    //
    // this code below might be useful in order to deal with accelerators
    // but ie host does not appear to be paying any attention
    //

    CComPtr<IOleControlSite> spCtlSite;
    HRESULT hRet = InternalGetSite(IID_IOleControlSite, (void**)&spCtlSite);
    if (SUCCEEDED(hRet)) {
        spCtlSite->OnControlInfoChanged();
    }
*/


    return hr;
}

LRESULT 
CProgView::OnNotifyListView(
    int     idCtrl, 
    LPNMHDR pnmh, 
    BOOL&   bHandled
    )
{

    if (idCtrl != IDC_LISTPROGRAMS) {
        bHandled = FALSE;
        return 0;
    }

    // see that we get the notification to fill-in the details
    return NotifyProgramList(m_pProgramList, pnmh, bHandled);
}

LRESULT 
CProgView::OnDblclkListprograms(
    int      idCtrl, 
    LPNMHDR  pnmh, 
    BOOL&    bHandled)
{
    LPNMITEMACTIVATE lpnmh;

    if (idCtrl != IDC_LISTPROGRAMS) {
        bHandled = FALSE;
        return 0;
    }

    // we have a double-click !

    lpnmh = (LPNMITEMACTIVATE)pnmh;
    
    Fire_DblClk((LONG)lpnmh->uKeyFlags);
    bHandled = TRUE;
    return 0;
}



STDMETHODIMP CProgView::GetSelectedItem()
{

    GetProgramListSelection(m_pProgramList);
    return S_OK;
}

STDMETHODIMP CProgView::get_SelectionName(VARIANT*pVal)
{
    
    GetProgramListSelectionDetails(m_pProgramList, 0, pVal);
    
    return S_OK;
}


STDMETHODIMP CProgView::GetSelectionInformation(LONG lInformationClass, VARIANT *pVal)
{
    GetProgramListSelectionDetails(m_pProgramList, lInformationClass, pVal);
    return S_OK;
}

VOID
CProgView::ShowProgressWindows(BOOL bProgress)
{
    HDWP hDefer = ::BeginDeferWindowPos(4);
    DWORD dwProgressFlag = bProgress ? SWP_SHOWWINDOW : SWP_HIDEWINDOW;
    DWORD dwListFlag     = bProgress ? SWP_HIDEWINDOW : SWP_SHOWWINDOW;

    hDefer = ::DeferWindowPos(hDefer, GetDlgItem(IDC_ANIMATEFIND), NULL, 
                            0, 0, 0, 0,
                            SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|dwProgressFlag);

    hDefer = ::DeferWindowPos(hDefer, GetDlgItem(IDC_STATUSLINE1), NULL,
                            0, 0, 0, 0,
                            SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|dwProgressFlag);

    hDefer = ::DeferWindowPos(hDefer, GetDlgItem(IDC_STATUSLINE2), NULL,
                            0, 0, 0, 0,
                            SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|dwProgressFlag);

    hDefer = ::DeferWindowPos(hDefer, GetDlgItem(IDC_LISTPROGRAMS), NULL,
                            0, 0, 0, 0,
                            SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|dwListFlag);


    EndDeferWindowPos(hDefer);

}

STDMETHODIMP CProgView::PopulateList()
{   
    HANDLE hThread; 

    ResetEvent(m_hEventCancel);
    ResetEvent(m_hEventCmd);

    if (!m_bInPlaceActive) {
        InPlaceActivate(OLEIVERB_INPLACEACTIVATE);
    }
    if (m_hThreadPopulate == NULL) {
        m_hThreadPopulate = CreateThread(NULL, 0, _PopulateThreadProc, (LPVOID)this, 0, NULL); 
    }

    if (m_hThreadPopulate != NULL && !IsScanInProgress()) {
        m_nCmdPopulate = CMD_SCAN;
        SetEvent(m_hEventCmd);
    }

    return S_OK;
}

BOOL CProgView::PopulateListInternal()
{
    
    if (InterlockedCompareExchange(&m_PopulateInProgress, TRUE, FALSE) == TRUE) {
        //
        // populate in progress -- quit
        //
        return FALSE;
    }

    if (m_pProgramList != NULL) {
        CleanupProgramList(m_pProgramList);
        m_pProgramList = NULL;

    }
   
    ShowProgressWindows(TRUE);
    Animate_OpenEx(GetDlgItem(IDC_ANIMATEFIND), _Module.GetModuleInstance(), MAKEINTRESOURCE(IDA_FINDANIM));
    Animate_Play(GetDlgItem(IDC_ANIMATEFIND), 0, -1, -1);
   
    PostMessage(WM_VIEW_CHANGED);
    
    // FireViewChange();

//    if (m_bInPlaceActive) {
/*    HCURSOR hcWait = (HCURSOR)::LoadImage(NULL,
                                          MAKEINTRESOURCE(IDC_WAIT),
                                          IMAGE_CURSOR,
                                          0, 0, 
                                          LR_DEFAULTSIZE|LR_SHARED);

//    HCURSOR hcWait = ::LoadCursor(_Module.GetResourceInstance(),
//                                 MAKEINTRESOURCE(IDC_WAIT));
  
    
    HCURSOR hcSave = SetCursor(hcWait);
*/

    //
    // malloc used on this thread should NOT be used on UI thread
    // 

    InitializeProgramList(&m_pProgramList, GetDlgItem(IDC_LISTPROGRAMS));
    PopulateProgramList(m_pProgramList, this, m_hEventCancel);

//    SetCursor(hcSave);

    Animate_Stop(GetDlgItem(IDC_ANIMATEFIND));
    Animate_Close(GetDlgItem(IDC_ANIMATEFIND));
    ShowProgressWindows();

    InterlockedCompareExchange(&m_PopulateInProgress, FALSE, TRUE);

    PostMessage(WM_VIEW_CHANGED);
    PostMessage(WM_LIST_POPULATED); // we are done, signal to the main thread


//    FireViewChange();

//    } else {
//        m_bPendingPopulate = TRUE;
//    }


    return TRUE;
}

DWORD WINAPI
CProgView::_PopulateThreadProc(
    LPVOID lpvParam
    )
{
    CProgView* pProgView = (CProgView*)lpvParam;    
    DWORD      dwWait;
    BOOL       bExit = FALSE;
    HRESULT hr = CoInitialize(NULL);
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    //
    // keep this thread alive, block it on a command event
    //
    while(!bExit) {
        dwWait = WaitForSingleObject(pProgView->m_hEventCmd, INFINITE);
        if (dwWait != WAIT_OBJECT_0) {
            break; // get out, we are being killed
        }
        //
        // get the command
        //
        switch(pProgView->m_nCmdPopulate) {
        case CMD_NONE:
            break;

        case CMD_EXIT:
            bExit = TRUE;
            //
            // intentional fall-through
            //

        case CMD_CLEANUP:
            if (pProgView->m_pProgramList) {
                CleanupProgramList(pProgView->m_pProgramList);
                pProgView->m_pProgramList = NULL;
            }
            break;

        case CMD_SCAN:
            pProgView->PopulateListInternal();
            break;
        }

        pProgView->m_nCmdPopulate = CMD_NONE;
    }
    CoUninitialize();
    return TRUE;
}

STDMETHODIMP 
CProgView::UpdateListItem(
    BSTR pTarget, 
    VARIANT *pKeys, 
    BOOL *pResult
    )
{
    VARIANT vKeys;
    VariantInit(&vKeys);
    CComBSTR bstrKeys;
    HRESULT  hr;
    
    if (!m_pProgramList) {
        return S_OK;
    }

    if (pKeys->vt == VT_NULL || pKeys->vt == VT_EMPTY) {
        *pResult = UpdateProgramListItem(m_pProgramList, pTarget, NULL);
        return S_OK;
    }

    hr = VariantChangeType(&vKeys, pKeys, 0, VT_BSTR);
    if (SUCCEEDED(hr)) {
        bstrKeys = vKeys.bstrVal;
    
        if (bstrKeys.Length()) {
            *pResult = UpdateProgramListItem(m_pProgramList, pTarget, bstrKeys);
        } else {
            *pResult = FALSE;
        }
    }

    VariantClear(&vKeys);    
    return S_OK;
}

BOOL
CProgView::PreTranslateAccelerator(
    LPMSG pMsg, 
    HRESULT& hRet
    ) 
{
    HWND hWndCtl;
    HWND hwndList = GetDlgItem(IDC_LISTPROGRAMS);

    hRet = S_OK;
    hWndCtl = ::GetFocus();
    if (IsChild(hWndCtl) && ::GetParent(hWndCtl) != m_hWnd)    {
        do {
            hWndCtl = ::GetParent(hWndCtl);
        } while (::GetParent(hWndCtl) != m_hWnd);
    }

    if (hWndCtl == hwndList && 
        pMsg->message == WM_KEYDOWN &&
            (LOWORD(pMsg->wParam) == VK_RETURN ||
            LOWORD(pMsg->wParam) == VK_EXECUTE)) {

        if (ListView_GetNextItem(hwndList, -1, LVNI_SELECTED) >= 0) {
            Fire_DblClk(0);
            return TRUE;
        }

    }


    //
    // check for external accelerators because the next call is going to eat the message
    //
    if (m_ExternAccel.IsAccelKey(pMsg)) { // we do not touch external accel messages
        return FALSE; 
    }

    return CComCompositeControl<CProgView>::PreTranslateAccelerator(pMsg, hRet);
}        


STDMETHODIMP CProgView::CancelPopulateList()
{
    if (m_hEventCancel && InterlockedCompareExchange(&m_PopulateInProgress, TRUE, TRUE) == TRUE) {
        SetEvent(m_hEventCancel);
    }
    return S_OK;
}

STDMETHODIMP CProgView::get_AccelCmd(LONG lCmd, BSTR *pVal)
{
    CComBSTR bstrAccel = m_Accel.GetAccelString((WORD)lCmd).c_str();
    *pVal = bstrAccel.Copy();
    return S_OK;
}

STDMETHODIMP CProgView::put_AccelCmd(LONG lCmd, BSTR newVal)
{
    m_Accel.SetAccel(newVal);
    return S_OK;
}

STDMETHODIMP CProgView::ClearAccel()
{
    m_Accel.ClearAccel();
    return S_OK;
}


STDMETHODIMP CProgView::get_ExternAccel(BSTR *pVal)
{
    CComBSTR bstrAccel = m_ExternAccel.GetAccelString().c_str();
    *pVal = bstrAccel.Copy();
    return S_OK;
}

STDMETHODIMP CProgView::put_ExternAccel(BSTR newVal)
    { 
    m_ExternAccel.SetAccel(newVal);
    return S_OK;
}

STDMETHODIMP CProgView::ClearExternAccel()
{
    m_ExternAccel.ClearAccel();
    return S_OK;
}

//
// in upload.c
//
wstring StrUpCase(wstring& wstr);

//
// expand env -- lives in util.cpp 
// we have a bit differing implementation here
//

wstring 
ExpandEnvironmentVars(
    LPCTSTR lpszCmd
    )
{
    DWORD   dwLength;
    LPTSTR  lpBuffer = NULL;
    BOOL    bExpanded = FALSE;
    wstring strCmd;
    TCHAR   szBuffer[MAX_PATH];

    if (_tcschr(lpszCmd, TEXT('%')) == NULL) {
        goto out;
    }

    dwLength = ExpandEnvironmentStrings(lpszCmd, NULL, 0);
    if (!dwLength) {
        goto out;
    }

    if (dwLength < CHARCOUNT(szBuffer)) {
        lpBuffer = szBuffer;
    } else {
        lpBuffer = new TCHAR[dwLength];
        if (NULL == lpBuffer) {
            goto out;
        }
    }

    dwLength = ExpandEnvironmentStrings(lpszCmd, lpBuffer, dwLength);
    if (!dwLength) {
        goto out;
    }

    strCmd = lpBuffer;
    bExpanded = TRUE;

 out:
    if (!bExpanded) {
        strCmd = lpszCmd;
    }
    if (lpBuffer && lpBuffer != szBuffer) {
        delete[] lpBuffer;
    }
    return strCmd;
}

STDMETHODIMP CProgView::put_ExcludeFiles(BSTR newVal)
{
    // parse exclude files, put them into our blacklist
    wstring strFile;
    LPCWSTR pch = newVal;
    LPCWSTR pend;
    
    m_ExcludedFiles.clear(); 

    while (pch != NULL && *pch != TEXT('\0')) {

        pch += _tcsspn(pch, TEXT(" \t"));
        // begining 
        // find the ;
        pend = _tcschr(pch, TEXT(';'));
        if (pend == NULL) {
            // from pch to the end
            strFile = pch;
            pch = NULL; // will bail out
        } else {
            strFile = wstring(pch, (wstring::size_type)(pend - pch));
            pch = pend + 1; // one past ; 
        }
    
        // add 
        if (strFile.length()) {
            strFile = ExpandEnvironmentVars(strFile.c_str());
            m_ExcludedFiles.insert(StrUpCase(strFile));
        }
    }

    return S_OK;
}

STDMETHODIMP CProgView::get_ExcludeFiles(BSTR* pVal)
{
    // parse exclude files, put them into our blacklist
    STRSET::iterator iter;
    CComBSTR bstrFiles;

    for (iter = m_ExcludedFiles.begin(); iter != m_ExcludedFiles.end(); ++iter) {
        if (bstrFiles.Length()) {
            bstrFiles += TEXT(';');
        }
        bstrFiles += (*iter).c_str();
    }

    *pVal = bstrFiles.Copy();

    return S_OK;
}

BOOL CProgView::IsFileExcluded(LPCTSTR pszFile)
{
    wstring strFile = pszFile;
    STRSET::iterator iter;

    iter = m_ExcludedFiles.find(StrUpCase(strFile));
    return iter != m_ExcludedFiles.end();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\compatui\compatui.cpp ===
// CompatUI.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f CompatUIps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <commctrl.h>
#include "CompatUI.h"
#include "CompatUI_i.c"
#include "ProgView.h"
#include "util.h"
#include "SelectFile.h"
#include "shfusion.h"
#include "Upload.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ProgView, CProgView)
OBJECT_ENTRY(CLSID_Util, CUtil)
OBJECT_ENTRY(CLSID_SelectFile, CSelectFile)
OBJECT_ENTRY(CLSID_Upload, CUpload)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {

#ifndef NO_FUSION
        BOOL bFusionInit;

        bFusionInit = SHFusionInitializeFromModuleID(hInstance,124);
        ATLTRACE(TEXT("Fusion init 0x%lx\n"), bFusionInit);           
#endif
        _Module.Init(ObjectMap, hInstance, &LIBID_COMPATUILib);
        
        DisableThreadLibraryCalls(hInstance);


    }
    else if (dwReason == DLL_PROCESS_DETACH) {

        _Module.Term();

#ifndef NO_FUSION
        SHFusionUninitialize();
#endif

    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\compatui\progview.h ===
// ProgView.h : Declaration of the CProgView

#ifndef __PROGVIEW_H_
#define __PROGVIEW_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include <shlobj.h>
#include "CompatUICP.h"

/////////////////// SHIMDB

extern "C" {
    #include "shimdb.h"
}

/////////////////// STL 

#include "AccelContainer.h"

class CProgramList;
class CProgView;


#define IDC_REFRESH 0x1234
//
// Program list stuff
//

BOOL
GetProgramListSelection(
    CProgramList* pProgramList
    );


BOOL 
InitializeProgramList(
    CProgramList** ppProgramList,
    HWND hwndListView
    );

BOOL
CleanupProgramList(
    CProgramList* pProgramList
    );

BOOL
PopulateProgramList(
    CProgramList* pProgramList,
    CProgView*    pProgView,
    HANDLE        hEventCancel
    );

BOOL
GetProgramListSelectionDetails(
    CProgramList* pProgramList,
    INT iInformationClass,
    VARIANT* pVal
    );

LRESULT
NotifyProgramList(
    CProgramList* pProgramList,
    LPNMHDR       pnmhdr,
    BOOL&         bHandled
    );

BOOL
GetProgramListEnabled(
    CProgramList* pProgramList
    );

VOID
EnableProgramList(
    CProgramList* pProgramList,
    BOOL bEnable
    );

BOOL
UpdateProgramListItem(
    CProgramList* pProgramList,
    LPCWSTR pwszPath,
    LPCWSTR pwszKeys
    );


#define WM_VIEW_CHANGED   (WM_USER+500)
#define WM_LIST_POPULATED (WM_USER+501)

//
// wait for the thread to cleanup
//

#define POPULATE_THREAD_TIMEOUT 1000

/////////////////////////////////////////////////////////////////////////////
// CProgView
class ATL_NO_VTABLE CProgView : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CStockPropImpl<CProgView, IProgView, &IID_IProgView, &LIBID_COMPATUILib>,
    public CComCompositeControl<CProgView>,
    public IPersistStreamInitImpl<CProgView>,
    public IOleControlImpl<CProgView>,
    public IOleObjectImpl<CProgView>,
    public IOleInPlaceActiveObjectImpl<CProgView>,
    public IViewObjectExImpl<CProgView>,
    public IOleInPlaceObjectWindowlessImpl<CProgView>,
    public CComCoClass<CProgView, &CLSID_ProgView>,
    public ISupportErrorInfo,
    public IPersistPropertyBagImpl<CProgView>,
    public IConnectionPointContainerImpl<CProgView>,
    public CProxy_IProgViewEvents< CProgView >,
    public IPropertyNotifySinkCP< CProgView >,
    public IProvideClassInfo2Impl<&CLSID_ProgView, &DIID__IProgViewEvents, &LIBID_COMPATUILib>, 
    public CProxy_ISelectFileEvents< CProgView >
{
public:
    typedef enum {
        CMD_EXIT,
        CMD_CLEANUP,
        CMD_SCAN,
        CMD_NONE
    } PopulateCmdType;


    CProgView()
    {
        m_bWindowOnly = TRUE;
        m_pProgramList = NULL;
        m_bPendingPopulate = FALSE;
        m_bRecomposeOnResize = TRUE;
        m_PopulateInProgress = FALSE;
        m_nCmdPopulate = CMD_NONE;
        CalcExtent(m_sizeExtent);

        m_hEventCancel = CreateEvent(NULL, TRUE, FALSE, NULL);
        // 
        // handle error -- we are big time in trouble if this fails
        //
        m_hEventCmd    = CreateEvent(NULL, FALSE, FALSE, NULL);
        //
        // same
        //

        m_hThreadPopulate = NULL;

        m_pMallocUI = NULL;

        //
        // create accelerator
        //

        ACCEL rgAccel[] = { { FVIRTKEY, VK_F5, IDC_REFRESH } };
        m_hAccel = CreateAcceleratorTable(rgAccel, ARRAYSIZE(rgAccel));
    
    }

    ~CProgView() {
        if (m_hAccel) {
            DestroyAcceleratorTable(m_hAccel);
        }
        if (m_hEventCancel) {
            SetEvent(m_hEventCancel);
            CloseHandle(m_hEventCancel);
        }
        if (m_hEventCmd) {
            m_nCmdPopulate = CMD_EXIT;
            SetEvent(m_hEventCmd);
            CloseHandle(m_hEventCmd);
        }
        if (m_hThreadPopulate) {
            WaitForSingleObject(m_hThreadPopulate, POPULATE_THREAD_TIMEOUT);
            CloseHandle(m_hThreadPopulate);
        }
        if (m_pMallocUI) {
            m_pMallocUI->Release();
        }
    }

DECLARE_REGISTRY_RESOURCEID(IDR_PROGVIEW)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CProgView)
    COM_INTERFACE_ENTRY(IProgView)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2) 
    COM_INTERFACE_ENTRY(IPersistPropertyBag)
END_COM_MAP()

BEGIN_PROP_MAP(CProgView)
    PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
    PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)

    PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_StockColorPage)
//    PROP_ENTRY("BorderStyle", DISPID_BORDERSTYLE, CLSID_NULL)
    PROP_ENTRY("Enabled", DISPID_ENABLED, CLSID_NULL)
//    PROP_ENTRY("ForeColor", DISPID_FORECOLOR, CLSID_StockColorPage)
//    PROP_ENTRY("Text", DISPID_TEXT, CLSID_NULL)
//    PROP_ENTRY("Tabstop", DISPID_TABSTOP, CLSID_NULL)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)

    PROP_ENTRY("Accel",        7,       CLSID_NULL) // the numbers should match .idl file!
    PROP_ENTRY("ExternAccel",  8,       CLSID_NULL)
    PROP_ENTRY("ExcludeFiles", 9,       CLSID_NULL)

END_PROP_MAP()

BEGIN_MSG_MAP(CProgView)
    NOTIFY_ID_HANDLER(IDC_LISTPROGRAMS,  OnNotifyListView)
    NOTIFY_HANDLER(IDC_LISTPROGRAMS, NM_DBLCLK, OnDblclkListprograms)
    MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_VIEW_CHANGED, OnViewChanged)
    MESSAGE_HANDLER(WM_LIST_POPULATED, OnListPopulated)
    MESSAGE_HANDLER(WM_GETDLGCODE, OnGetDlgCode)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    
    //    COMMAND_ID_HANDLER(IDC_REFRESH, OnRefreshListCmd)

    CHAIN_MSG_MAP(CComCompositeControl<CProgView>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

BEGIN_SINK_MAP(CProgView)
    //Make sure the Event Handlers have __stdcall calling convention
END_SINK_MAP()

BEGIN_CONNECTION_POINT_MAP(CProgView)
CONNECTION_POINT_ENTRY(DIID__IProgViewEvents)
CONNECTION_POINT_ENTRY(DIID__ISelectFileEvents)
END_CONNECTION_POINT_MAP()

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
    {
        static const IID* arr[] = 
        {
            &IID_IProgView,
        };
        for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
        {
            if (InlineIsEqualGUID(*arr[i], riid))
                return S_OK;
        }
        return S_FALSE;
    }

    STDMETHOD(OnAmbientPropertyChange)(DISPID dispid)
    {
        if (dispid == DISPID_AMBIENT_BACKCOLOR)
        {
            SetBackgroundColorFromAmbient();
            FireViewChange();
        }

        return IOleControlImpl<CProgView>::OnAmbientPropertyChange(dispid);
    }

    HRESULT FireOnChanged(DISPID dispID) {
        if (dispID == DISPID_ENABLED) {
            HWND hwndList = GetDlgItem(IDC_LISTPROGRAMS);
            if (::IsWindow(hwndList)) {
                ::EnableWindow(hwndList, m_bEnabled);
            }
        }
        return S_OK;
    }

    STDMETHOD(GetControlInfo)(CONTROLINFO* pCI) {
        if (NULL == pCI) {
            return E_POINTER;
        }
        pCI->cb      = sizeof(*pCI);
        pCI->hAccel  = m_hAccel;
        pCI->cAccel  = 1;
        pCI->dwFlags = 0;
        return S_OK;
    }

    STDMETHOD(OnMnemonic)(LPMSG pMsg) {
        if (pMsg->message == WM_COMMAND || pMsg->message == WM_SYSCOMMAND) {
            if (LOWORD(pMsg->wParam) == IDC_REFRESH) {
                PopulateList();
            }
        }
        return S_OK;
    }

    HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect = NULL);

    LRESULT OnNotifyListView(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnDblclkListprograms(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnMouseActivate(UINT, WPARAM, LPARAM, BOOL&) {
        // Manually activate the control
        InPlaceActivate(OLEIVERB_UIACTIVATE);
        return 0;
    } 
    

    STDMETHOD(InPlaceDeactivate)(VOID) {
        HRESULT hr = IOleInPlaceObjectWindowlessImpl<CProgView>::InPlaceDeactivate();
        //
        // make sure we cancel first if we are scanning
        //
        return hr;
    }

#if 0
    STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL* psizel) {


        if (IsWindow()) {
            HWND hlvPrograms = GetDlgItem(IDC_LISTPROGRAMS);
            SIZEL sizePix;
            AtlHiMetricToPixel(psizel, &sizePix);
            ::SetWindowPos(hlvPrograms, NULL, 0, 0, 
                           sizePix.cx, sizePix.cy,
                           SWP_NOZORDER|SWP_NOACTIVATE);
            /*
            ::SetWindowPos(hlvPrograms, NULL, 0, 0, 
                           m_rcPos.right - m_rcPos.left,
                           m_rcPos.bottom - m_rcPos.top,
                           SWP_NOZORDER|SWP_NOACTIVATE);
            */

        }
        HRESULT hr = IOleObjectImpl<CProgView>::SetExtent(dwDrawAspect, psizel);

        return hr;
    }

#endif

    LRESULT OnGetDlgCode(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        // TODO : Add Code for message handler. Call DefWindowProc if necessary.
        if (lParam) {
            LPMSG pMsg = (LPMSG)lParam;
            if (pMsg->message == WM_SYSKEYDOWN || pMsg->message == WM_SYSCHAR) { // eat accel ?
                bHandled = TRUE;
                return DLGC_WANTMESSAGE;
            }
        }

        bHandled = TRUE;
        return DLGC_WANTTAB|DLGC_WANTARROWS|DLGC_WANTALLKEYS;
    }
    

    STDMETHOD(SetObjectRects)(LPCRECT prcPos, LPCRECT prcClip) {
        HWND hlvPrograms = GetDlgItem(IDC_LISTPROGRAMS);
        IOleInPlaceObjectWindowlessImpl<CProgView>::SetObjectRects(prcPos, prcClip);
        ::SetWindowPos(hlvPrograms, NULL, 0, 0,
                       prcPos->right - prcPos->left,
                       prcPos->bottom - prcPos->top,
                       SWP_NOZORDER|SWP_NOACTIVATE);
        
        HWND hwnd;
        RECT rc;

        hwnd = GetDlgItem(IDC_STATUSLINE1);
        ::GetWindowRect(hwnd, &rc);

        //
        // we are happy with location, just set the width
        //
        ScreenToClient((LPPOINT)&rc);
        ScreenToClient(((LPPOINT)&rc) + 1);
 
        ::SetWindowPos(hwnd, NULL, 
                       rc.left, rc.top,
                       prcPos->right - prcPos->left - rc.left,
                       rc.bottom - rc.top,
                       SWP_NOZORDER|SWP_NOACTIVATE);

        hwnd = GetDlgItem(IDC_STATUSLINE2);
        ::GetWindowRect(hwnd, &rc);

        //
        // we are happy with location, just set the width
        //
        ScreenToClient((LPPOINT)&rc);
        ScreenToClient(((LPPOINT)&rc) + 1);
 
        ::SetWindowPos(hwnd, NULL,  
                       rc.left, rc.top,
                       prcPos->right - prcPos->left - rc.left,
                       rc.bottom - rc.top,
                       SWP_NOZORDER|SWP_NOACTIVATE);

        return S_OK;
   
    }

    BOOL PreTranslateAccelerator(LPMSG pMsg, HRESULT& hrRet);

#if 0

    static CWndClassInfo& GetWndClassInfo() {
        DebugBreak();
        static CWndClassInfo wc = CWindowImpl<CProgView>::GetWndClassInfo();
        wc.m_wc.style &= ~(CS_HREDRAW|CS_VREDRAW);
        return wc;
    }


    BOOL PreTranslateAccelerator(LPMSG pMsg, HRESULT& hrRet) {

        HWND hwndList  = GetDlgItem(IDC_LISTPROGRAMS);
        HWND hwndFocus = GetFocus();

        if (hwndList != hwndFocus || !::IsWindowEnabled(hwndList)) {
            goto PropagateAccel;
        }

        if (pMsg->message == WM_KEYDOWN) {
            
            if (pMsg->wParam == VK_LEFT || 
                pMsg->wParam == VK_RIGHT ||
                pMsg->wParam == VK_UP ||
                pMsg->wParam == VK_DOWN) {
            
                SendDlgItemMessage(IDC_LISTPROGRAMS, pMsg->message, pMsg->wParam, pMsg->lParam);
                hrRet = S_OK;
                return TRUE;
            }

            if (LOWORD(pMsg->wParam) == VK_RETURN || LOWORD(pMsg->wParam) == VK_EXECUTE) {
        
                if (ListView_GetNextItem(hwndList, -1, LVNI_SELECTED) >= 0) {
                    Fire_DblClk(0);
                    hrRet = S_OK;
                    return TRUE;
                }
            }

            if (LOWORD(pMsg->wParam) == VK_TAB) {
                goto PropagateAccel;
            }
        }
                
        if (IsDialogMessage(pMsg)) {
            hrRet = S_OK;
            return TRUE;
        }

        if (::TranslateAccelerator(m_hWnd, NULL, pMsg)) {
            hrRet = S_OK;
            return TRUE;
        }

        PropagateAccel:
        return FALSE;
    }
#endif




// IViewObjectEx
    DECLARE_VIEW_STATUS(0)

// IProgView
public:
    STDMETHOD(get_ExcludeFiles)(/*[out, retval]*/ BSTR* pVal);
    STDMETHOD(put_ExcludeFiles)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_ExternAccel)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_ExternAccel)(/*[in]*/ BSTR newVal);
#if 0
    STDMETHOD(get_Accel)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_Accel)(/*[in]*/ BSTR newVal);
#endif
    STDMETHOD(CancelPopulateList)();
    STDMETHOD(UpdateListItem)(/*[in]*/BSTR pTarget, /*[in]*/VARIANT* pKeys, /*[out, retval]*/ BOOL* pResult);
    STDMETHOD(PopulateList)();
    STDMETHOD(GetSelectionInformation)(LONG, VARIANT* pVal);
    STDMETHOD(get_SelectionName)(/*[out, retval]*/ VARIANT *pVal);
    STDMETHOD(GetSelectedItem)(); 

    STDMETHOD(ClearAccel)();
    STDMETHOD(ClearExternAccel)();
    STDMETHOD(get_AccelCmd)(/*[in]*/ LONG lCmd, /*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_AccelCmd)(/*[in]*/ LONG lCmd, /*[in]*/ BSTR newVal);



    BOOL m_bEnabled;

    BOOL m_bPendingPopulate;
    CProgramList* m_pProgramList;


    enum { IDD = IDD_PROGVIEW };

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
        // TODO : Add Code for message handler. Call DefWindowProc if necessary.
/*
        DWORD dwStyle = (DWORD)GetClassLong(m_hWnd, GCL_STYLE);
        dwStyle &= ~(CS_HREDRAW | CS_VREDRAW);
        SetClassLong(m_hWnd, GCL_STYLE, dwStyle);
*/

        //
        // before we start messing around with this... obtain malloc for the UI thread
        //
        HRESULT hr = SHGetMalloc(&m_pMallocUI);
        if (!SUCCEEDED(hr)) {
            //
            // aww -- ui malloc will not be available -- we're pretty much hosed
            //
            m_pMallocUI = NULL;
        }

        PopulateList();

        return 0;

    }

    static DWORD WINAPI _PopulateThreadProc(LPVOID lpvParam);

    VOID UpdatePopulateStatus(LPCTSTR lpszName, LPCTSTR lpszPath) {
        SetDlgItemText(IDC_STATUSLINE1, lpszName);
        ::PathSetDlgItemPath(m_hWnd, IDC_STATUSLINE2, lpszPath);
    }

    VOID ShowProgressWindows(BOOL bProgress = FALSE);

    LRESULT OnViewChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
        FireViewChange();
        bHandled = TRUE;
        return 0;
    }

    LRESULT OnListPopulated(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
        Fire_ProgramListReady();
        bHandled = TRUE;
        return 0;
    }

    BOOL PopulateListInternal();

    HANDLE m_hEventCancel;
    LONG   m_PopulateInProgress; 
    HANDLE m_hEventCmd;
    PopulateCmdType m_nCmdPopulate;
    HANDLE m_hThreadPopulate;

    IMalloc* m_pMallocUI;

    HACCEL m_hAccel;

    BOOL IsScanInProgress(VOID) {
        return InterlockedCompareExchange(&m_PopulateInProgress, TRUE, TRUE) == TRUE;
    }

    /*
    LRESULT OnRefreshListCmd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled) {
        PopulateList();
        bHandled = TRUE;
        return 0;
    }
    */

    //
    // accelerators
    //
    CAccelContainer m_Accel;       // my own accelerator
    CAccelContainer m_ExternAccel; // external accels


    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        InPlaceActivate(OLEIVERB_UIACTIVATE);    
        //
        // if we are scanning then we don't need to do anything, else - set the focus to listview 
        //
        if (!IsScanInProgress()) {
            ::SetFocus(GetDlgItem(IDC_LISTPROGRAMS));
        }

        return CComCompositeControl<CProgView>::OnSetFocus(uMsg, wParam, lParam, bHandled);
    }

    //
    // blacklisted files
    //
    typedef set<wstring> STRSET;
        
    STRSET m_ExcludedFiles;

    //
    // check whether a file is excluded
    //
    BOOL IsFileExcluded(LPCTSTR pszFile);

};



#endif //__PROGVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\compatui\compatuicp.h ===
#ifndef _COMPATUICP_H_
#define _COMPATUICP_H_












template <class T>
class CProxy_IProgViewEvents : public IConnectionPointImpl<T, &DIID__IProgViewEvents, CComDynamicUnkArray>
{
    //Warning this class may be recreated by the wizard.
public:
    HRESULT Fire_DblClk(LONG lFlags)
    {
        CComVariant varResult;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        CComVariant* pvars = new CComVariant[1];
        int nConnections = m_vec.GetSize();
        
        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                VariantClear(&varResult);
                pvars[0] = lFlags;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
        }
        delete[] pvars;
        return varResult.scode;
    
    }
    HRESULT Fire_ProgramListReady()
    {
        CComVariant varResult;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();
        
        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                VariantClear(&varResult);
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
        }
        return varResult.scode;
    
    }
};

template <class T>
class CProxy_ISelectFileEvents : public IConnectionPointImpl<T, &DIID__ISelectFileEvents, CComDynamicUnkArray>
{
    //Warning this class may be recreated by the wizard.
public:
    HRESULT Fire_SelectionComplete()
    {
        CComVariant varResult;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();
        
        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                VariantClear(&varResult);
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
        }
        return varResult.scode;
    
    }
    HRESULT Fire_StateChanged(LONG lState)
    {
        CComVariant varResult;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        CComVariant* pvars = new CComVariant[1];
        int nConnections = m_vec.GetSize();
        
        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                VariantClear(&varResult);
                pvars[0] = lState;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
        }
        delete[] pvars;
        return varResult.scode;
    
    }
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\compatui\proglist.cpp ===
/*++

      Implements population of a listview control with the content from
      the start menu


--*/


#include "stdafx.h"
#include "resource.h"

#include <stdio.h>
#include <stdlib.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <commctrl.h>
#include <msi.h>
#include <sfc.h>
#include "CompatUI.h"
#include "progview.h"
extern "C" {
#include "shimdb.h"
}

#pragma warning(disable:4786)
#include <string>
#include <xstring>
#include <map>
#include <algorithm>

using namespace std;

#ifdef _UNICODE
typedef wstring tstring;
#else
typedef string tstring;
#endif

    typedef
    INSTALLSTATE (WINAPI*PMsiGetComponentPath)(
      LPCTSTR szProduct,   // product code for client product
      LPCTSTR szComponent, // component ID
      LPTSTR lpPathBuf,    // returned path
      DWORD *pcchBuf       // buffer character count
    );

    typedef
    UINT (WINAPI* PMsiGetShortcutTarget)(
      LPCTSTR szShortcutTarget,     // path to shortcut link file
      LPTSTR szProductCode,        // fixed length buffer for product code
      LPTSTR szFeatureId,          // fixed length buffer for feature id
      LPTSTR szComponentCode       // fixed length buffer for component code
    );


typedef enum tagPROGRAMINFOCLASS {
    PROGLIST_DISPLAYNAME,
    PROGLIST_LOCATION,     //
    PROGLIST_EXENAME,      // cracked exe name
    PROGLIST_CMDLINE,      // complete exe name + parameters
    PROGLIST_EXECUTABLE,   // what we should execute (link or exe, not cracked)
    PROGLIST_ARGUMENTS     // just the args
};




class CException {
public:
    CException(LPCSTR lpszFile = NULL, DWORD nLocation = 0) {
        SetLocation(lpszFile, nLocation);
    }
    virtual ~CException() {}

    virtual VOID Delete() {
        delete this;
    }

    int __cdecl FormatV(LPCTSTR lpszFormat, va_list arg) {
        int nch = 0;

        if (lpszFormat) {
            nch = _vsntprintf(szDescription, CHARCOUNT(szDescription), lpszFormat, arg);
        } else {
            *szDescription = TEXT('\0');
        }
        return nch;
    }

    int __cdecl Format(LPCTSTR lpszFormat, ...) {
        va_list arg;
        int nch = 0;

        if (lpszFormat) {
            va_start(arg, lpszFormat);
            nch = _vsntprintf(szDescription, CHARCOUNT(szDescription), lpszFormat, arg);
            va_end(arg);
        } else {
            *szDescription = TEXT('\0');
        }
    }

    VOID SetLocation(LPCSTR lpszFile, DWORD nLocation) {
        if (lpszFile) {
            strcpy(szLocation, lpszFile);
        } else {
            *szLocation = TEXT('\0');
        }
        m_dwLocation = nLocation;
    }

    TCHAR   szDescription[MAX_PATH];
    CHAR    szLocation[MAX_PATH];
    DWORD   m_dwLocation;
};

class CMemoryException : public CException {
public:
    CMemoryException(LPCSTR lpszFile = NULL, DWORD nLocation = 0) :
      CException(lpszFile, nLocation) {}
    VOID Delete() {}
};

class CCancelException : public CException {
public:
    CCancelException(LPCSTR lpszFile = NULL, DWORD nLocation = 0) :
      CException(lpszFile, nLocation){}
};

static CMemoryException _MemoryExceptionStatic;

VOID __cdecl ThrowMemoryException(LPCSTR lpszFile, DWORD nLocation, LPCTSTR lpszFormat = NULL, ...) {
    va_list arg;
    CMemoryException* pMemoryException = &_MemoryExceptionStatic;

    va_start(arg, lpszFormat);
    pMemoryException->FormatV(lpszFormat, arg);
    va_end(arg);

    throw pMemoryException;
}

class CProgramList {
public:
    CProgramList(LPMALLOC pMalloc, HWND hwndListView, LPCTSTR szSystemDirectory) :
      m_pMalloc(pMalloc),
      m_hwndListView(hwndListView),
      m_hMSI(NULL),
      m_pSelectionInfo(NULL),
      m_hbmSort(NULL),
      m_pProgView(NULL),
      m_hEventCancel(NULL) {
        //
        // we are always initializing on populate thread
        //
        m_dwOwnerThreadID    = GetCurrentThreadId();
        m_strSystemDirectory = szSystemDirectory;
      }

      ~CProgramList();

    BOOL PopulateControl(CProgView* pProgView = NULL, HANDLE hEventCancel = NULL);

    LPMALLOC GetMalloc(VOID) {
        return GetCurrentThreadId() == m_dwOwnerThreadID ? m_pMalloc : m_pMallocUI;
    }

    BOOL CaptureSelection();

    BOOL GetSelectionDetails(INT iInformationClass, VARIANT* pVal);

    LRESULT LVNotifyDispInfo   (LPNMHDR pnmhdr, BOOL& bHandled);
    LRESULT LVNotifyColumnClick(LPNMHDR pnmhdr, BOOL& bHandled);
    LRESULT LVNotifyGetInfoTip (LPNMHDR pnmhdr, BOOL& bHandled);
    LRESULT LVNotifyRClick     (LPNMHDR pnmhdr, BOOL& bHandled);
    BOOL IsEnabled(VOID);

    VOID Enable(BOOL);

    BOOL UpdateListItem(LPCWSTR pwszPath, LPCWSTR pwszKey);

protected:
    BOOL ListFolder(LPCTSTR pszLocationParent, IShellFolder* pFolder, LPCITEMIDLIST pidlFull, LPCITEMIDLIST pidlFolder);
    BOOL ListLink(LPCTSTR pszLocationParent, LPCTSTR pszDisplayName, IShellFolder* pFolder, LPCITEMIDLIST pidlFull, LPCITEMIDLIST pidlLink);
    BOOL ListMsiLink(LPCTSTR pszLocationParent, LPCTSTR pszDisplayName, LPCTSTR pszMsiPath, IShellFolder* pFolder, LPCITEMIDLIST pidlFull);

    LPITEMIDLIST GetNextItemIDL(LPCITEMIDLIST pidl);
       UINT         GetSizeIDL    (LPCITEMIDLIST pidl);
      LPITEMIDLIST AppendIDL     (LPCITEMIDLIST pidlBase,
                                LPCITEMIDLIST pidlAdd);
    LPITEMIDLIST GetLastItemIDL(LPCITEMIDLIST pidl);

    BOOL GetDisplayName(IShellFolder* pFolder, LPCITEMIDLIST pidl, tstring& strDisplay);
    BOOL GetPathFromLink(IShellLink* pLink, WIN32_FIND_DATA* pfd, tstring& strPath);
    BOOL GetArgumentsFromLink(IShellLink* pLink, tstring& strArgs);

    BOOL AddItem(LPCTSTR pszLocation,
                 LPCTSTR pszDisplayName,
                 LPCTSTR pszPath,
                 LPCTSTR pszArguments,
                 IShellFolder* pFolder,
                 LPCITEMIDLIST pidlFull,
                 BOOL    bUsePath = FALSE); // true if we should use path for executable


    int GetIconFromLink(LPCITEMIDLIST pidlLinkFull, LPCTSTR lpszExePath);

    BOOL IsSFCItem(LPCTSTR lpszItem);
    BOOL IsItemInSystemDirectory(LPCTSTR pszPath);

private:
    LPMALLOC m_pMalloc;
    LPMALLOC m_pMallocUI;
    HWND     m_hwndListView; // list view control
    HBITMAP  m_hbmSort;
    typedef struct tagSHITEMINFO {

        tstring strDisplayName;     // descriptive name
        tstring strFolder;          // containing folder
        tstring strPath;            // actual exe, cracked
        tstring strPathExecute;     // link path (this is what we will execute)
        tstring strCmdLine;         // command line (cracked link)
        tstring strArgs;
        tstring strKeys;
        LPITEMIDLIST pidl;          // full pidl
    } SHITEMINFO, *PSHITEMINFO;
    static CALLBACK SHItemInfoCompareFunc(LPARAM lp1, LPARAM lp2, LPARAM lParamSort);

    typedef map< tstring, PSHITEMINFO, less<tstring> > MAPSTR2ITEM;
    typedef multimap< tstring, PSHITEMINFO > MULTIMAPSTR2ITEM;

    //
    // store key->item sequence, the keys are cmdlines (with args)
    //
    MAPSTR2ITEM m_mapItems;

    //
    // store key->item sequence, where the key is exe name (path)
    //
    MULTIMAPSTR2ITEM m_mmapExeItems;

    //
    // selected item
    //

    PSHITEMINFO m_pSelectionInfo;

    //
    // cached msi.dll handle
    //
    HMODULE     m_hMSI;


    PMsiGetComponentPath  m_pfnGetComponentPath;
    PMsiGetShortcutTarget m_pfnGetShortcutTarget;

    //
    // cached system directory
    //

    tstring m_strSystemDirectory;

    //
    // image list used to show icons
    //

    HIMAGELIST  m_hImageList;

    //
    // optional pointer to the parent view
    //
    CProgView* m_pProgView;


    //
    // event that we use to signal the end of scan
    //
    HANDLE m_hEventCancel;


    //
    // owner thread
    //
    DWORD m_dwOwnerThreadID;

    VOID CheckForCancel() {
        if (m_hEventCancel) {
            if (::WaitForSingleObject(m_hEventCancel, 0) != WAIT_TIMEOUT) {
                // cancelled!!!
                throw new CCancelException();
            }
        }
    }

};

//
// in upload.cpp
//

wstring StrUpCase(wstring& wstr);

//
// load the string from resources
//
wstring LoadResourceString(UINT nID)
{
    LPTSTR lpszBuffer = NULL;
    int cch;
    wstring str;

    cch = ::LoadString(_Module.GetModuleInstance(), nID, (LPTSTR)&lpszBuffer, 0);
    //
    // hack! this must work (I know it does)
    //
    if (cch && NULL != lpszBuffer) {
        str = wstring(lpszBuffer, cch);
    }

    return str;
}



/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Utility functions
//


BOOL
InitializeProgramList(
    CProgramList** ppProgramList,
    HWND hwndListView
    )
{
    HRESULT hr;
    BOOL bSuccess = FALSE;
    LPMALLOC pMalloc = NULL;
    TCHAR szSystemWindowsDirectory[MAX_PATH];
    CProgramList* pProgramList = NULL;
    UINT uSize;

    hr = SHGetMalloc(&pMalloc);
    if (!SUCCEEDED(hr)) {
        goto ErrHandle;
    }


    uSize = ::GetSystemWindowsDirectory(szSystemWindowsDirectory,
                                        CHARCOUNT(szSystemWindowsDirectory));
    if (uSize == 0 || uSize > CHARCOUNT(szSystemWindowsDirectory)) {
        goto ErrHandle;
    }

    pProgramList = new CProgramList(pMalloc, hwndListView, szSystemWindowsDirectory);
    if (NULL == pProgramList) {
        goto ErrHandle;
    }


    *ppProgramList = pProgramList;
    bSuccess = TRUE;

ErrHandle:

    if (!bSuccess) {

        if (NULL != pMalloc) {
            pMalloc->Release();
        }

        if (NULL != pProgramList) {
            delete pProgramList;
        }

    }

    return bSuccess;
}


BOOL
CleanupProgramList(
    CProgramList* pProgramList
    )
{
    LPMALLOC pMalloc;

    if (NULL == pProgramList) {
        return FALSE;
    }

    pMalloc = pProgramList->GetMalloc();

    delete pProgramList;

    if (NULL != pMalloc) {
        pMalloc->Release();
    }


    return TRUE;
}

BOOL
PopulateProgramList(
    CProgramList* pProgramList,
    CProgView*    pProgView,
    HANDLE        hEventCancel
    )
{
    return pProgramList->PopulateControl(pProgView, hEventCancel);
}


CProgramList::~CProgramList()
{
    //
    //
    //
    MAPSTR2ITEM::iterator iter;

    iter = m_mapItems.begin();
    while (iter != m_mapItems.end()) {
        PSHITEMINFO pInfo = (*iter).second;

        GetMalloc()->Free(pInfo->pidl); // nuke this please
        delete pInfo;

        ++iter;
    }

    if (NULL != m_hbmSort) {
        DeleteObject(m_hbmSort);
    }


//  Image list is destroyed automatically when the control is destroyed
//
//    if (NULL != m_hImageList) {
//        ImageList_Destroy(m_hImageList);
//    }

    if (NULL != m_hMSI) {
        FreeLibrary(m_hMSI);
    }
}

BOOL
CProgramList::GetDisplayName(
    IShellFolder* pFolder,
    LPCITEMIDLIST pidl,
    tstring&      strDisplayName
    )
{
    STRRET strName;
    HRESULT hr;
    LPTSTR pszName = NULL;


    hr = pFolder->GetDisplayNameOf(pidl, SHGDN_NORMAL, &strName);
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    hr = StrRetToStr(&strName, pidl, &pszName);
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    // if we have been successful, assign return result
    if (pszName != NULL) {
        strDisplayName = pszName;
        CoTaskMemFree(pszName);
    } else {
        strDisplayName.erase();
    }
    return TRUE;
}

BOOL
CProgramList::GetPathFromLink(
    IShellLink* pLink,
    WIN32_FIND_DATA* pfd,
    tstring& strPath
    )
{
    TCHAR  szPath[MAX_PATH];
    HRESULT hr;

    hr = pLink->GetPath(szPath, sizeof(szPath)/sizeof(szPath[0]), pfd, 0);
    if (hr == S_OK) {
        strPath = szPath;
    }

    return hr == S_OK;
}

BOOL
CProgramList::GetArgumentsFromLink(
    IShellLink* pLink,
    tstring& strArgs
    )
{
    TCHAR szArgs[INFOTIPSIZE];

    HRESULT hr = pLink->GetArguments(szArgs, sizeof(szArgs)/sizeof(szArgs[0]));
    if (SUCCEEDED(hr)) {
        strArgs = szArgs;
    }

    return SUCCEEDED(hr);

}



LPITEMIDLIST
CProgramList::GetNextItemIDL(
    LPCITEMIDLIST pidl
    )
{
   // Check for valid pidl.
    if (pidl == NULL) {
        return NULL;
    }

    // Get the size of the specified item identifier.
    int cb = pidl->mkid.cb;

    // If the size is zero, it is the end of the list.
    if (cb == 0) {
        return NULL;
    }

    // Add cb to pidl (casting to increment by bytes).
    pidl = (LPITEMIDLIST) (((LPBYTE) pidl) + cb);

    // Return NULL if it is null-terminating, or a pidl otherwise.
    return (pidl->mkid.cb == 0) ? NULL : (LPITEMIDLIST) pidl;
}

LPITEMIDLIST
CProgramList::GetLastItemIDL(
    LPCITEMIDLIST pidl
    )
{
    LPITEMIDLIST pidlLast = (LPITEMIDLIST)pidl;

    if (pidl == NULL) {
        return NULL;
    }

    int cb = pidl->mkid.cb;
    if (cb == 0) {
        return NULL;
    }

    do {
        pidl = GetNextItemIDL(pidlLast);
        if (pidl != NULL) {
            pidlLast = (LPITEMIDLIST)pidl;
        }
    } while (pidl != NULL);

    return pidlLast;
}


UINT
CProgramList::GetSizeIDL(
    LPCITEMIDLIST pidl
    )
{
    UINT cbTotal = 0;
    if (pidl)
    {
        cbTotal += sizeof(pidl->mkid.cb);    // Null terminator
        while (NULL != pidl)
        {
            cbTotal += pidl->mkid.cb;
            pidl = GetNextItemIDL(pidl);
        }
    }
    return cbTotal;
}

LPITEMIDLIST
CProgramList::AppendIDL(
    LPCITEMIDLIST pidlBase,
    LPCITEMIDLIST pidlAdd
    )
{
    if (NULL == pidlBase && NULL == pidlAdd) {
        return NULL;
    }

    LPITEMIDLIST pidlNew, pidlAlloc;

    UINT cb1 = pidlBase ? GetSizeIDL(pidlBase)  : 0;
    UINT cb2 = pidlAdd  ? GetSizeIDL(pidlAdd) : 0;

    UINT size = cb1 + cb2;
    pidlAlloc =
    pidlNew = (LPITEMIDLIST)GetMalloc()->Alloc(size);
    if (pidlNew)
    {
        if (NULL != pidlBase) {
            cb1 = pidlAdd ? cb1 - sizeof(pidlBase->mkid.cb) : cb1;
            RtlMoveMemory(pidlNew, pidlBase, cb1);
            pidlNew = (LPITEMIDLIST)((PBYTE)pidlNew + cb1);
        }

        if (NULL != pidlAdd) {
            RtlMoveMemory(pidlNew, pidlAdd, cb2);
        }
    }

    return pidlAlloc;
}


BOOL
CProgramList::ListMsiLink(
    LPCTSTR pszLocationParent,
    LPCTSTR pszDisplayName,
    LPCTSTR pszMsiPath,
    IShellFolder* pFolder,
    LPCITEMIDLIST pidlFull
    )
{
    //
    // make sure we have msi module handle
    //

    if (NULL == m_hMSI) {
        m_hMSI = LoadLibrary(TEXT("msi.dll"));
        if (NULL == m_hMSI) {
            return FALSE;
        }

#ifdef _UNICODE
        m_pfnGetComponentPath  = (PMsiGetComponentPath )GetProcAddress(m_hMSI, "MsiGetComponentPathW");
        m_pfnGetShortcutTarget = (PMsiGetShortcutTarget)GetProcAddress(m_hMSI, "MsiGetShortcutTargetW");

#else
        m_pfnGetComponentPath  = (PMsiGetComponentPath )GetProcAddress(m_hMSI, "MsiGetComponentPathA");
        m_pfnGetShortcutTarget = (PMsiGetShortcutTarget)GetProcAddress(m_hMSI, "MsiGetShortcutTargetA");
#endif

    }

    UINT  ErrCode;
    TCHAR szProduct[MAX_PATH];
    TCHAR szFeatureId[MAX_PATH];
    TCHAR szComponentCode[MAX_PATH];

    ErrCode = m_pfnGetShortcutTarget(pszMsiPath, szProduct, szFeatureId, szComponentCode);
    if (ERROR_SUCCESS != ErrCode) {
        return FALSE;
    }

    INSTALLSTATE is;
    TCHAR  szPath[MAX_PATH];
    DWORD  cchPath = sizeof(szPath)/sizeof(szPath[0]);
    *szPath = 0;

    is = m_pfnGetComponentPath(szProduct, szComponentCode, szPath, &cchPath);
    if (INSTALLSTATE_LOCAL == is) {
        //
        // add this item
        //
        return AddItem(pszLocationParent,
                       pszDisplayName,
                       szPath,
                       NULL,
                       pFolder,
                       pidlFull,
                       TRUE);
    }

    return FALSE;
}

int
CProgramList::GetIconFromLink(
    LPCITEMIDLIST pidlLinkFull,
    LPCTSTR       lpszExePath
    )
{

    HRESULT hr;
    IShellFolder* pFolder = NULL;
    IExtractIcon* pExtractIcon = NULL;
    INT iIconIndex = 0;
    UINT uFlags    = 0;
    LPCITEMIDLIST pidlLink = 0;
    HICON hIconLarge = NULL;
    HICON hIconSmall = NULL;
    UINT  nIconSize;
    int ImageIndex = -1;
    UINT uiErrorMode;
    DWORD dwAttributes;

    TCHAR szIconFile[MAX_PATH];
    *szIconFile = TEXT('\0');

    uiErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    hr = SHBindToParent(pidlLinkFull, IID_IShellFolder, (PVOID*)&pFolder, &pidlLink);
    if (!SUCCEEDED(hr)) {
        goto trySysImage;
    }

    // get the ui please
    hr = pFolder->GetUIObjectOf(m_hwndListView, 1, (LPCITEMIDLIST*)&pidlLink, IID_IExtractIcon, NULL, (PVOID*)&pExtractIcon);

    if (!SUCCEEDED(hr)) {
        goto trySysImage;
    }


    hr = pExtractIcon->GetIconLocation(0,
                                       szIconFile,
                                       sizeof(szIconFile) / sizeof(szIconFile[0]),
                                       &iIconIndex,
                                       &uFlags);

    if (!SUCCEEDED(hr)) {
        goto trySysImage;
    }

    if (*szIconFile == TEXT('*')) { // this is batch or some such, don't bother
        goto trySysImage;
    }

    //
    // before doing an extract, check whether it's available
    //

    dwAttributes = GetFileAttributes(szIconFile);


    if (dwAttributes == (DWORD)-1) {
        goto trySysImage;
    }


    nIconSize = MAKELONG(0, ::GetSystemMetrics(SM_CXSMICON));

    //
    // this call is likely to produce a popup, beware of that
    //
    hr = pExtractIcon->Extract(szIconFile,
                               iIconIndex,
                               &hIconLarge,
                               &hIconSmall,
                               nIconSize);

    //
    // if hIconSmall was retrieved - we were successful
    //

trySysImage:

    if (hIconSmall == NULL) {
        //
        // woops -- we could not extract an icon -- what a bummer
        // use shell api then
        SHFILEINFO FileInfo;
        HIMAGELIST hImageSys;

        hImageSys = (HIMAGELIST)SHGetFileInfo(lpszExePath,
                                              0,
                                              &FileInfo, sizeof(FileInfo),
                                              SHGFI_ICON|SHGFI_SMALLICON|SHGFI_SYSICONINDEX);
        if (hImageSys) {
            hIconSmall = ImageList_GetIcon(hImageSys, FileInfo.iIcon, ILD_TRANSPARENT);
        }
    }

    //
    // now that we have an icon, we can add it to our image list ?
    //
    if (hIconSmall != NULL) {
        ImageIndex = ImageList_AddIcon(m_hImageList, hIconSmall);
    }

///////////////////////// cleanup ///////////////////////////////////////////
    SetErrorMode(uiErrorMode);

    if (hIconSmall) {
        DestroyIcon(hIconSmall);
    }

    if (hIconLarge) {
        DestroyIcon(hIconLarge);
    }

    if (pExtractIcon != NULL) {
        pExtractIcon->Release();
    }
    if (pFolder != NULL) {
        pFolder->Release();
    }


    return ImageIndex;
}



BOOL
CProgramList::ListLink(
    LPCTSTR pszLocationParent,
    LPCTSTR pszDisplayName,
    IShellFolder* pFolder,
    LPCITEMIDLIST pidlFull,
    LPCITEMIDLIST pidlLink
    )
{
    IShellLink* psl = NULL;
    WIN32_FIND_DATA wfd;
    HRESULT  hr;
    BOOL     bSuccess = FALSE;
    tstring  strPath;
    tstring  strArgs;
    CComBSTR bstr;
    LPCTSTR  pszArgs = NULL;

    IPersistFile* ipf = NULL;
    IShellLinkDataList* pdl;
    DWORD dwFlags;
    BOOL  bMsiLink = FALSE;

    //
    // check whether we need to cancel
    //

    CheckForCancel();

    hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                            IID_IShellLink, (LPVOID*)&psl);
    if (!SUCCEEDED(hr)) {
        return FALSE; // we can't create link object
    }

    hr = psl->SetIDList(pidlFull); // set the id list
    if (!SUCCEEDED(hr)) {
        goto out;
    }

    //
    // now the shell link is ready to rumble
    //
    if (!GetPathFromLink(psl, &wfd, strPath)) {
        goto out;
    }


    // now let's see what is inside of this link -- shall we?


    hr = psl->QueryInterface(IID_IPersistFile, (LPVOID*)&ipf);
    if (!SUCCEEDED(hr)) {
        goto out;
    }

    bstr = strPath.c_str();

    hr = ipf->Load(bstr, STGM_READ);

    if (SUCCEEDED(hr)) {

        //
        // resolve the link for now
        //
        // hr = psl->Resolve(NULL, SLR_NO_UI|SLR_NOUPDATE);


        hr = psl->QueryInterface(IID_IShellLinkDataList, (LPVOID*)&pdl);
        if (SUCCEEDED(hr)) {
            hr = pdl->GetFlags(&dwFlags);

            bMsiLink = SUCCEEDED(hr) && (dwFlags & SLDF_HAS_DARWINID);

            pdl->Release();
        }

        if (bMsiLink) {

            bSuccess = ListMsiLink(pszLocationParent, pszDisplayName, strPath.c_str(), pFolder, pidlFull);

        } else {

            //
            // we now get the path from the link -- and that's that
            //
            if (GetPathFromLink(psl, &wfd, strPath)) {

                if (GetArgumentsFromLink(psl, strArgs)) {
                    pszArgs = strArgs.c_str();
                }

                //
                // add this to our list view
                //

                bSuccess = AddItem(pszLocationParent,
                                   pszDisplayName,
                                   strPath.c_str(),
                                   pszArgs,
                                   pFolder,
                                   pidlFull);

            }
        }

    }

    if (NULL != ipf) {
        ipf->Release();
    }


out:
    if (NULL != psl) {
        psl->Release();
    }

    return bSuccess;

}



BOOL
CProgramList::ListFolder(
    LPCTSTR       pszLocation, // ui string - where is this folder located?
    IShellFolder* pParent,     // parent folder
    LPCITEMIDLIST pidlFull,     // idl of the full path to the folder
    LPCITEMIDLIST pidlFolder    // idl of this folder relative to the pidlFull
    )
{
    LPENUMIDLIST penum = NULL;
    LPITEMIDLIST pidl  = NULL;
    HRESULT      hr;

    ULONG        celtFetched;
    ULONG        uAttr;
    tstring      strDisplayNameLocation;
    tstring      strDisplayName;

    IShellFolder* pFolder = NULL;
    BOOL bDesktop = FALSE;

    BOOL bCancel = FALSE;
    CCancelException* pCancelException = NULL;

    CheckForCancel();

    if (pParent == NULL) {
        hr = SHGetDesktopFolder(&pParent);
        bDesktop = TRUE;
    }

    hr = pParent->BindToObject(pidlFolder,
                                 NULL,
                               IID_IShellFolder,
                               (LPVOID *) &pFolder);

    if (NULL == pszLocation) {
        GetDisplayName(pParent, pidlFolder, strDisplayNameLocation);
    } else {
        strDisplayNameLocation = pszLocation;
    }

    if (bDesktop) {
        pParent->Release();
    }

    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    hr = pFolder->EnumObjects(NULL,SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, &penum);
    if (!SUCCEEDED(hr)) {
        pFolder->Release(); // free the folder- - and go away
        return FALSE;
    }


    while( (hr = penum->Next(1,&pidl, &celtFetched)) == S_OK && celtFetched == 1 && !bCancel) {
        LPITEMIDLIST pidlCur;

        if (pidlFull == NULL) {
            pidlFull = pidlFolder;
        }

        pidlCur = AppendIDL(pidlFull, pidl);

        // get the display name of this item
        GetDisplayName(pFolder, pidl, strDisplayName);


        uAttr = SFGAO_FOLDER | SFGAO_LINK;
        hr = pFolder->GetAttributesOf(1, (LPCITEMIDLIST *) &pidl, &uAttr);
        if (SUCCEEDED(hr)) {

            try {

                if (uAttr & SFGAO_FOLDER) {
                    //
                    // dump folder recursively
                    //
                    ListFolder(strDisplayName.c_str(), pFolder, pidlCur, pidl);

                } else if (uAttr & SFGAO_LINK) {

                    ListLink(strDisplayNameLocation.c_str(), strDisplayName.c_str(), pFolder, pidlCur, pidl);

                } else if (uAttr & SFGAO_FILESYSTEM) {
                    //
                    // this item is a file
                    //
                    AddItem(strDisplayNameLocation.c_str(),
                            strDisplayName.c_str(),
                            NULL,
                            NULL,
                            pFolder,
                            pidlCur,
                            TRUE);

                }

            } catch(CCancelException* pex) {
                //
                // we need to cancel -- we shall cleanup and do what we need, then re-throw
                //
                bCancel = TRUE;
                pCancelException = pex;
            }

        }
        GetMalloc()->Free(pidlCur);
        GetMalloc()->Free(pidl);

    }

    if (NULL != penum) {
        penum->Release();
    }

    if (NULL != pFolder) {
        pFolder->Release();
    }

    if (bCancel && pCancelException) {
        throw pCancelException;
    }

    return TRUE;
}


BOOL
CProgramList::IsSFCItem(
    LPCTSTR pszPath
    )
{

#ifndef _UNICODE
    WCHAR wszBuffer[1024];

    mbstowcs(wszBuffer, pszPath, sizeof(wszBuffer)/sizeof(wszBuffer[0]));
    return SfcIsFileProtected(NULL, wszBuffer);
#else

    return SfcIsFileProtected(NULL, pszPath);

#endif

}

BOOL
CProgramList::IsItemInSystemDirectory(
    LPCTSTR pszPath
    )
{
    TCHAR szCommonPath[MAX_PATH];
    int nch;
    string s;

    nch = PathCommonPrefix(m_strSystemDirectory.c_str(), pszPath, szCommonPath);
    return nch == m_strSystemDirectory.length();
}

BOOL
ValidateExecutableFile(
    LPCTSTR pszPath,
    BOOL    bValidateFileExists
    )
{
    LPTSTR rgExt[] = {
            TEXT("EXE"),
            TEXT("BAT"),
            TEXT("CMD"),
            TEXT("PIF"),
            TEXT("COM"),
            TEXT("LNK")
            };
    LPTSTR pExt;
    int i;
    BOOL bValidatedExt = FALSE;

    pExt = PathFindExtension(pszPath);
    if (pExt == NULL || *pExt == TEXT('\0')) {
        return FALSE;
    }
    ++pExt;

    for (i = 0; i < sizeof(rgExt)/sizeof(rgExt[0]) && !bValidatedExt; ++i) {
            bValidatedExt = !_tcsicmp(pExt, rgExt[i]);
    }

    if (!bValidatedExt) {
        return FALSE;
    }


    return bValidateFileExists ? PathFileExists(pszPath) : TRUE;
}


BOOL
CProgramList::AddItem(
    LPCTSTR pszLocation,
    LPCTSTR pszDisplayName,
    LPCTSTR pszPath,
    LPCTSTR pszArguments,
    IShellFolder* pFolder,
    LPCITEMIDLIST pidlFull,
    BOOL    bUsePath
    )
{
    //
    // first test -- is this one of the types we like?
    //
    LPTSTR pchSlash;
    LPTSTR pchDot;
    LPTSTR rgExt[] = { TEXT("EXE"), TEXT("BAT"), TEXT("CMD"), TEXT("PIF"), TEXT("COM"), TEXT("LNK") };
    BOOL   bValidatedExt = FALSE;
    BOOL   bSuccess = FALSE;
    PSHITEMINFO pInfo = NULL;
    MAPSTR2ITEM::iterator Iter;
    TCHAR  szPathExecute[MAX_PATH];
    tstring strKey;
    tstring strKeyExe;

    LVITEM lvi;
    int    ix;


    //
    // check for cancelling the search
    //
    CheckForCancel();

    if (NULL == pszPath) {
        pszPath = szPathExecute;

        if (!SHGetPathFromIDList(pidlFull, szPathExecute)) {
            goto out;
        }
    }

    if (pszDisplayName && m_pProgView) {
        m_pProgView->UpdatePopulateStatus(pszDisplayName, pszPath);
    }

    pchSlash = _tcsrchr(pszPath, TEXT('\\'));
    pchDot   = _tcsrchr(pszPath, TEXT('.'));

    if (NULL != pchSlash) {
        if ((ULONG_PTR)pchDot < (ULONG_PTR)pchSlash) {
            pchDot = NULL;
        }
    }

    if (NULL != pchDot) {
        ++pchDot;

        for (int i = 0; i < sizeof(rgExt)/sizeof(rgExt[0]) && !bValidatedExt; ++i) {
            bValidatedExt = !_tcsicmp(pchDot, rgExt[i]);
        }
    }

    if (!bValidatedExt) {
        goto out;
    }

    //
    // Checks whether the item is in system directory or SFC-protected
    //
#if 0
    if (IsItemInSystemDirectory(pszPath) || IsSFCItem(pszPath)) {
        goto out;
    }
#endif

    //
    // GetBinaryTypeW excludes wow exes
    //
#if 0
    if (GetBinaryType(pszPath, &dwBinaryType) &&
        dwBinaryType == SCS_WOW_BINARY) {
        goto out;
    }
#endif

    if (IsSFCItem(pszPath)) {
        goto out;
    }

    //
    // this is multimap key
    //
    strKeyExe = StrUpCase(wstring(pszPath));

    //
    // check whether this has been excluded
    //
    if (m_pProgView->IsFileExcluded(strKeyExe.c_str())) {
        goto out;
    }

    //
    // now compose the key string
    //
    strKey = strKeyExe;
    if (NULL != pszArguments) {
        strKey.append(TEXT(" "));
        strKey.append(pszArguments);
    }

    //
    // now check whether this item has already been listed
    //

    Iter = m_mapItems.find(strKey);
    if (Iter != m_mapItems.end()) { // found a duplicate
        goto out;
    }

    //
    // now please add this item to the list view
    //
    pInfo = new CProgramList::SHITEMINFO;
    if (pInfo == NULL) {
        ThrowMemoryException(__FILE__, __LINE__, TEXT("%s\n"), TEXT("Failed to allocate Item Information structure"));
    }

    pInfo->strDisplayName = pszDisplayName;
    pInfo->strFolder      = pszLocation;
    pInfo->strPath        = pszPath;
    pInfo->strCmdLine     = strKey;
    if (NULL != pszArguments) {
        pInfo->strArgs = pszArguments;
    }
    pInfo->pidl           = AppendIDL(NULL, pidlFull);

    if (bUsePath) {
        pInfo->strPathExecute = pszPath;
    } else {

        // finally, what are we going to launch ?
        if (SHGetPathFromIDList(pidlFull, szPathExecute)) {
            pInfo->strPathExecute = szPathExecute;
        }
    }


    m_mapItems[strKey] = pInfo;

    m_mmapExeItems.insert(MULTIMAPSTR2ITEM::value_type(strKeyExe, pInfo));

    ATLTRACE(TEXT("Adding item %s %s %s\n"), pszDisplayName, pszLocation, pszPath);

    lvi.mask = LVIF_TEXT|LVIF_PARAM|LVIF_IMAGE;
    lvi.iItem = ListView_GetItemCount(m_hwndListView); // append at the end please
    lvi.iSubItem = 0;
    lvi.pszText = LPSTR_TEXTCALLBACK;
    lvi.iImage  = I_IMAGECALLBACK;
    lvi.lParam  = (LPARAM)pInfo;
    ix = ListView_InsertItem(m_hwndListView, &lvi);

    lvi.mask = LVIF_TEXT;
    lvi.iItem = ix;
    lvi.iSubItem = 1;
    lvi.pszText = LPSTR_TEXTCALLBACK;
    ListView_SetItem(m_hwndListView, &lvi);

    bSuccess = TRUE;

out:

    return bSuccess;
}

BOOL
CProgramList::PopulateControl(
    CProgView* pProgView,
    HANDLE     hevtCancel
    )
{
    int i;
    HRESULT hr;
    LPITEMIDLIST pidl;
    BOOL bCancel = FALSE;
    struct {
        INT csidl;
        UINT nIDDescription;
    } rgFolders[] = {
        { CSIDL_DESKTOPDIRECTORY, IDS_DESKTOP             },
        { CSIDL_COMMON_STARTMENU, IDS_COMMON_STARTMENU    },
        { CSIDL_STARTMENU,        IDS_STARTMENU           },
        { CSIDL_COMMON_PROGRAMS,  IDS_COMMON_PROGRAMS     },
        { CSIDL_PROGRAMS,         IDS_PROGRAMS            }
    };


    //
    // set the progview object pointer so we could update the status
    //
    m_pProgView = pProgView;

    m_pMallocUI = pProgView->m_pMallocUI;

    //
    // set the event so that we could cancel the scan
    //
    m_hEventCancel = hevtCancel;


    //
    // set extended style
    //

    ListView_SetExtendedListViewStyleEx(m_hwndListView,
                                        LVS_EX_INFOTIP|LVS_EX_LABELTIP,
                                        LVS_EX_INFOTIP|LVS_EX_LABELTIP);

    //
    //  fix columns
    //


    LVCOLUMN lvc;
    RECT     rc;
    SIZE_T   cxProgName;
    SIZE_T   cx;
    wstring  strCaption;

    lvc.mask = LVCF_WIDTH;
    if (!ListView_GetColumn(m_hwndListView, 2, &lvc)) {

        ::GetClientRect(m_hwndListView, &rc);
        cx = rc.right - rc.left -
                ::GetSystemMetrics(SM_CXVSCROLL) -
                ::GetSystemMetrics(SM_CXEDGE) -
                ::GetSystemMetrics(SM_CXSIZEFRAME);


        cxProgName = cx * 3 / 5;
        strCaption = LoadResourceString(IDS_PROGRAMNAME);

        lvc.mask    = LVCF_FMT|LVCF_WIDTH|LVCF_TEXT;
        lvc.pszText = (LPTSTR)strCaption.c_str();
        lvc.fmt     = LVCFMT_LEFT;
        lvc.cx      = cxProgName;
        lvc.iSubItem= 0;
        ListView_InsertColumn(m_hwndListView, 0, &lvc);

        cx -= cxProgName;

        cxProgName = cx / 2;
        strCaption = LoadResourceString(IDS_FOLDER);

        lvc.mask    = LVCF_FMT|LVCF_WIDTH|LVCF_TEXT|LVCF_SUBITEM;
        lvc.pszText = (LPTSTR)strCaption.c_str();
        lvc.fmt     = LVCFMT_LEFT;
        lvc.cx      = cxProgName;
        lvc.iSubItem= 1;
        ListView_InsertColumn(m_hwndListView, 1, &lvc);

        strCaption = LoadResourceString(IDS_SETTINGS);

        lvc.mask    = LVCF_FMT|LVCF_WIDTH|LVCF_TEXT|LVCF_SUBITEM;
        lvc.pszText = (LPTSTR)strCaption.c_str();
        lvc.fmt     = LVCFMT_LEFT;
        lvc.cx      = cx - cxProgName;
        lvc.iSubItem= 2;
        ListView_InsertColumn(m_hwndListView, 2, &lvc);

    }

    HDC hDC = GetDC(m_hwndListView);
    int nBitsPixel = ::GetDeviceCaps(hDC, BITSPIXEL);
    int nPlanes    = ::GetDeviceCaps(hDC, PLANES);
    UINT flags;

    nBitsPixel *= nPlanes;
    if (nBitsPixel < 4) {
        flags = ILC_COLOR;
    } else if (nBitsPixel < 8) {
        flags = ILC_COLOR4;
    } else if (nBitsPixel < 16) {
        flags = ILC_COLOR8;
    } else if (nBitsPixel < 24) {
        flags = ILC_COLOR16;
    } else if (nBitsPixel < 32) {
        flags = ILC_COLOR24;
    } else if (nBitsPixel == 32) {
        flags = ILC_COLOR32;
    } else {
        flags = ILC_COLORDDB;
    }

    flags |= ILC_MASK;

    ReleaseDC(m_hwndListView, hDC);

    m_hImageList = ImageList_Create(::GetSystemMetrics(SM_CXSMICON),
                                    ::GetSystemMetrics(SM_CYSMICON),
                                    flags,
                                    10,
                                    25);
    if (m_hImageList == NULL) {
        ATLTRACE(TEXT("Image List creation failure, error 0x%lx\n"), GetLastError());
    }

    ImageList_SetBkColor(m_hImageList, CLR_NONE);

    ListView_SetImageList(m_hwndListView, m_hImageList, LVSIL_SMALL);

    ::SendMessage(m_hwndListView, WM_SETREDRAW, FALSE, 0);

    ListView_DeleteAllItems(m_hwndListView);

    //
    // AtlTrace(TEXT("Callback Mask: 0x%lx\n"), ListView_GetCallbackMask(m_hwndListView));
    //

    for (i = 0; i < sizeof(rgFolders)/sizeof(rgFolders[0]) && !bCancel; ++i) {
        wstring strDescription = LoadResourceString(rgFolders[i].nIDDescription);

        hr = SHGetFolderLocation(NULL, rgFolders[i].csidl, NULL, 0, &pidl);
        if (SUCCEEDED(hr)) {
            try {
                ListFolder(strDescription.c_str(), NULL, NULL, pidl);
            } catch(CCancelException* pex) {
                bCancel = TRUE;
                pex->Delete();
            } catch(CException* pex) {
                bCancel = TRUE;
                pex->Delete();
            }
            GetMalloc()->Free(pidl);
        }
    }

    ::SendMessage(m_hwndListView, WM_SETREDRAW, TRUE, 0);

    return TRUE;

}

BOOL
CProgramList::CaptureSelection(
    VOID
    )
{
    INT iSelected;
    LVITEM lvi;

    m_pSelectionInfo = NULL;

    iSelected = ListView_GetNextItem(m_hwndListView, -1, LVNI_SELECTED);

    if (iSelected == -1) {
        return FALSE;
    }

    lvi.iItem = iSelected;
    lvi.iSubItem = 0;
    lvi.mask = LVIF_PARAM;
    if (ListView_GetItem(m_hwndListView, &lvi)) {
        m_pSelectionInfo = (PSHITEMINFO)lvi.lParam;
    }

    return m_pSelectionInfo != NULL;

}

BOOL
CProgramList::GetSelectionDetails(
    INT iInformationClass,
    VARIANT* pVal
    )
{
    CComBSTR bstr;

    if (m_pSelectionInfo == NULL) {
        pVal->vt = VT_NULL;
        return TRUE;
    }

    switch(iInformationClass) {
    case PROGLIST_DISPLAYNAME:
        bstr = m_pSelectionInfo->strDisplayName.c_str();
        break;

    case PROGLIST_LOCATION:     //
        bstr = m_pSelectionInfo->strFolder.c_str();
        break;

    case PROGLIST_EXENAME:      // cracked exe name
        bstr = m_pSelectionInfo->strPath.c_str(); //
        break;

    case PROGLIST_CMDLINE:      // complete exe name + parameters
        bstr = m_pSelectionInfo->strCmdLine.c_str();
        break;

    case PROGLIST_EXECUTABLE:    // what we should execute (link or exe, not cracked)
        bstr = m_pSelectionInfo->strPathExecute.c_str();
        break;

    case PROGLIST_ARGUMENTS:
        bstr = m_pSelectionInfo->strArgs.c_str();
        break;

    default:
        pVal->vt = VT_NULL;
        return TRUE;
        break;
    }


    pVal->vt = VT_BSTR;
    pVal->bstrVal = bstr.Copy();

    return TRUE;
}

#define PROGLIST_SORT_NONE 0
#define PROGLIST_SORT_ASC  1
#define PROGLIST_SORT_DSC  2


int CALLBACK
CProgramList::SHItemInfoCompareFunc(
    LPARAM lp1,
    LPARAM lp2,
    LPARAM lParamSort
    )
{
    PSHITEMINFO pInfo1 = (PSHITEMINFO)lp1;
    PSHITEMINFO pInfo2 = (PSHITEMINFO)lp2;
    BOOL bEmpty1, bEmpty2;
    int nColSort   = (int)LOWORD(lParamSort);
    int nSortOrder = (int)HIWORD(lParamSort);
    int iRet = 0;

    switch(nColSort) {
    case 0: // SORT_APPNAME:
        iRet = _tcsicmp(pInfo1->strDisplayName.c_str(),
                        pInfo2->strDisplayName.c_str());
        break;

    case 1: // SORT_APPLOCATION:
        iRet = _tcsicmp(pInfo1->strFolder.c_str(),
                        pInfo2->strFolder.c_str());
        break;

    case 2: // SORT_LAYERS:
        bEmpty1 = pInfo1->strKeys.empty();
        bEmpty2 = pInfo2->strKeys.empty();
        if (bEmpty1 || bEmpty2) {
            if (bEmpty1) {
                iRet = bEmpty2 ? 0 : 1;
            } else {
                iRet = bEmpty1 ? 0 : -1;
            }
        } else {

            iRet = _tcsicmp(pInfo1->strKeys.c_str(),
                            pInfo2->strKeys.c_str());
        }

        break;
    }

    if (nSortOrder == PROGLIST_SORT_DSC) {
        iRet = -iRet;
    }

    return iRet;
}



LRESULT
CProgramList::LVNotifyColumnClick(
    LPNMHDR pnmhdr,
    BOOL&   bHandled
    )
{
    LPNMLISTVIEW lpnmlv = (LPNMLISTVIEW)pnmhdr;

    // lpnmlv->iSubItem - this is what we have to sort on
    // check whether we already have something there

    HWND hwndHeader = ListView_GetHeader(m_hwndListView);
    INT  nCols;
    INT  i;
    INT  nColSort = lpnmlv->iSubItem;
    LPARAM lSortParam; // leave high word blank for now
    LPARAM lSortOrder = PROGLIST_SORT_ASC;
    HDITEM hdi;
    //
    // reset current image - wherever that is
    //
    nCols = Header_GetItemCount(hwndHeader);

    for (i = 0; i < nCols; ++i) {
        hdi.mask = HDI_BITMAP|HDI_LPARAM|HDI_FORMAT;
        if (!Header_GetItem(hwndHeader, i, &hdi)) {
            continue;
        }

        if (i == nColSort && (hdi.mask & HDI_LPARAM)) {
            switch(hdi.lParam) {
            case PROGLIST_SORT_NONE:
            case PROGLIST_SORT_DSC:
                lSortOrder = PROGLIST_SORT_ASC;
                break;
            case PROGLIST_SORT_ASC:
                lSortOrder = PROGLIST_SORT_DSC;
                break;
            }
        }

        if (hdi.mask & HDI_BITMAP) {
            DeleteObject((HGDIOBJ)hdi.hbm);
        }

        hdi.lParam = PROGLIST_SORT_NONE;
        hdi.fmt &= ~(HDF_BITMAP|HDF_BITMAP_ON_RIGHT);
        hdi.mask |= HDI_BITMAP|HDI_LPARAM|HDI_FORMAT;
        hdi.hbm = NULL;
        Header_SetItem(hwndHeader, i, &hdi);
    }

    lSortParam = MAKELONG(nColSort, lSortOrder);
    ListView_SortItems(m_hwndListView, (PFNLVCOMPARE)SHItemInfoCompareFunc, lSortParam);

    // now, load the image please
    m_hbmSort = (HBITMAP)::LoadImage(_Module.GetResourceInstance(),
                                     MAKEINTRESOURCE(lSortOrder == PROGLIST_SORT_ASC? IDB_SORTUP : IDB_SORTDN),
                                     IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
    hdi.mask = HDI_BITMAP|HDI_LPARAM|HDI_FORMAT;
    Header_GetItem(hwndHeader, nColSort,  &hdi);
    hdi.mask   |= HDI_BITMAP|HDI_FORMAT|HDI_LPARAM;
    hdi.hbm    = m_hbmSort;
    hdi.fmt    |= HDF_BITMAP|HDF_BITMAP_ON_RIGHT;
    hdi.lParam = lSortOrder;
    Header_SetItem(hwndHeader, nColSort, &hdi);


    bHandled = TRUE;
    return 0;
}

LRESULT
CProgramList::LVNotifyDispInfo(
    LPNMHDR pnmhdr,
    BOOL& bHandled
    )
{

    WCHAR wszPermKeys[MAX_PATH];
    DWORD cbSize;

    LV_ITEM &lvItem = reinterpret_cast<LV_DISPINFO*>(pnmhdr)->item;

    LV_ITEM lvi;
    PSHITEMINFO pInfo;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = lvItem.iItem;
    lvi.iSubItem = 0;

    if (!ListView_GetItem(m_hwndListView, &lvi)) {
        // bummer, we can't retrieve an item -- if we let it go, things will be worse
        lvItem.mask &= ~(LVIF_TEXT|LVIF_IMAGE);
        lvItem.mask |= LVIF_DI_SETITEM;
        bHandled = TRUE;
        return 0;
    }

    pInfo = reinterpret_cast<PSHITEMINFO> (lvi.lParam);

    if (lvItem.mask & LVIF_TEXT) {
        switch (lvItem.iSubItem) {
        case 0:
            lvItem.pszText = (LPTSTR)pInfo->strDisplayName.c_str();
            break;
        case 1:
            lvItem.pszText = (LPTSTR)pInfo->strFolder.c_str();
            break;
        case 2:
            // check with SDB
            cbSize = sizeof(wszPermKeys);
            if (pInfo->strKeys.empty()) {

                if (SdbGetPermLayerKeys(pInfo->strPath.c_str(), wszPermKeys, &cbSize, GPLK_ALL)) {
                    pInfo->strKeys = wszPermKeys;
                }

            }

            if (!pInfo->strKeys.empty()) {
                lvItem.pszText = (LPTSTR)pInfo->strKeys.c_str();
            }

            break;

        default:
            break;
        }
    }


    if (lvItem.mask & LVIF_IMAGE) {
        lvItem.iImage = GetIconFromLink(pInfo->pidl, pInfo->strPathExecute.c_str());
    }

    lvItem.mask |= LVIF_DI_SETITEM;
    bHandled = TRUE;
    return 0;

}

LRESULT
CProgramList::LVNotifyGetInfoTip(
    LPNMHDR pnmhdr,
    BOOL& bHandled
    )
{
    DWORD cbSize;
    LPNMLVGETINFOTIP pGetInfoTip = (LPNMLVGETINFOTIP)pnmhdr;
    LV_ITEM lvi;
    PSHITEMINFO pInfo;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = pGetInfoTip->iItem;
    lvi.iSubItem = 0;

    if (!ListView_GetItem(m_hwndListView, &lvi)) {
        // bupkas
        bHandled = FALSE;
        return 0;
    }

    pInfo = reinterpret_cast<PSHITEMINFO> (lvi.lParam);

    //
    // now we can fiddle
    //

    _tcsncpy(pGetInfoTip->pszText, pInfo->strCmdLine.c_str(), pGetInfoTip->cchTextMax);
    *(pGetInfoTip->pszText + pGetInfoTip->cchTextMax - 1) = TEXT('\0');

    bHandled = TRUE;
    return 0;

}

LRESULT
CProgramList::LVNotifyRClick(
    LPNMHDR pnmhdr,
    BOOL& bHandled
    )
{

    DWORD dwPos = ::GetMessagePos();
    LVHITTESTINFO hti;
    LV_ITEM lvi;
    PSHITEMINFO pInfo;
    HRESULT hr;
    LPITEMIDLIST  pidlItem = NULL;
    IShellFolder* pFolder  = NULL;
    IContextMenu* pContextMenu = NULL;
    CMINVOKECOMMANDINFO ici;
    int nCmd;
    HMENU hMenu = NULL;
    UINT  idMin, idMax, idCmd;
    WCHAR szCmdVerb[MAX_PATH];
    int nLastSep, i, nLastItem;

    hti.pt.x = (int) LOWORD (dwPos);
    hti.pt.y = (int) HIWORD (dwPos);
    ScreenToClient (m_hwndListView, &hti.pt);

    ListView_HitTest (m_hwndListView, &hti);

    if (!(hti.flags & LVHT_ONITEM)) {
        bHandled = FALSE;
        return 0;
    }

    lvi.mask  = LVIF_PARAM;
    lvi.iItem = hti.iItem;
    lvi.iSubItem = 0;

    if (!ListView_GetItem(m_hwndListView, &lvi)) {
        // bupkas
        bHandled = FALSE;
        return 0;
    }

    pInfo = reinterpret_cast<PSHITEMINFO> (lvi.lParam);

    //
    // we have an item, show it's context menu then
    //

    hr = SHBindToParent(pInfo-> pidl, IID_IShellFolder, (PVOID*)&pFolder, (LPCITEMIDLIST*)&pidlItem);
    if (!SUCCEEDED(hr)) {
        goto cleanup;
    }

    // get the ui please
    hr = pFolder->GetUIObjectOf(m_hwndListView, 1, (LPCITEMIDLIST*)&pidlItem, IID_IContextMenu, NULL, (PVOID*)&pContextMenu);
    if (!SUCCEEDED(hr)) {
        goto cleanup;
    }

    hMenu = CreatePopupMenu();
    if (hMenu == NULL) {
        goto cleanup;
    }

    hr = pContextMenu->QueryContextMenu(hMenu,
                                        0,
                                        1,
                                        0x7FFF,
                                        CMF_EXPLORE);
    if (!SUCCEEDED(hr)) {
        goto cleanup;
    }



    //
    // sanitize
    //
    idMin = 1;
    idMax = HRESULT_CODE(hr);

    for (idCmd = 0; idCmd < idMax; ++idCmd) {
        hr = pContextMenu->GetCommandString(idCmd, GCS_VERBW, NULL, (LPSTR)szCmdVerb, CHARCOUNT(szCmdVerb));
        if (SUCCEEDED(hr)) {
            if (!_wcsicmp(szCmdVerb, TEXT("cut"))    ||
                !_wcsicmp(szCmdVerb, TEXT("delete")) ||
                !_wcsicmp(szCmdVerb, TEXT("rename")) ||
                !_wcsicmp(szCmdVerb, TEXT("link"))) {
                //
                // not allowed
                //
                DeleteMenu(hMenu, idCmd + idMin, MF_BYCOMMAND);
            }
        }
    }

    //
    // after doing some basic sanitization against the destructive tendencies --
    // nuke double-separators
    //

    nLastItem = ::GetMenuItemCount(hMenu) - 1;
    nLastSep = nLastItem + 1;
    for (i = nLastItem; i >= 0; --i) {
        MENUITEMINFO mii;

        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_FTYPE;
        if (GetMenuItemInfo(hMenu, i, TRUE, &mii)) {
            if (mii.fType & MFT_SEPARATOR) {
                if (nLastSep == i + 1 || i == 0) {
                    // this sep is dead
                    DeleteMenu(hMenu, i, MF_BYPOSITION);
                }
                nLastSep = i;
            }
        }
    }



    ClientToScreen(m_hwndListView, &hti.pt);
    nCmd = TrackPopupMenu(hMenu,
                          TPM_LEFTALIGN |
                            TPM_LEFTBUTTON |
                            TPM_RIGHTBUTTON |
                            TPM_RETURNCMD,
                          hti.pt.x, hti.pt.y,
                          0,
                          m_hwndListView,
                          NULL);

    //
    // execute command
    //
    if (nCmd) {
        ici.cbSize          = sizeof (CMINVOKECOMMANDINFO);
        ici.fMask           = 0;
        ici.hwnd            = m_hwndListView;
        ici.lpVerb          = MAKEINTRESOURCEA(nCmd - 1);
        ici.lpParameters    = NULL;
        ici.lpDirectory     = NULL;
        ici.nShow           = SW_SHOWNORMAL;
        ici.dwHotKey        = 0;
        ici.hIcon           = NULL;
        hr = pContextMenu->InvokeCommand(&ici);

        //
        // requery perm layer keys -- useless here btw
        //
        /* // this code will not work since the call above is always asynchronous
           //
        if (SUCCEEDED(hr)) {
            DWORD cbSize;
            WCHAR wszPermKeys[MAX_PATH];

            cbSize = sizeof(wszPermKeys);
            if (SdbGetPermLayerKeys(pInfo->strPath.c_str(), wszPermKeys, &cbSize)) {
                pInfo->strKeys = wszPermKeys;
            } else {
                pInfo->strKeys.erase();
            }

            //
            // set the info into the list box
            //
            ListView_SetItemText(m_hwndListView, lvi.iItem, 2, (LPWSTR)pInfo->strKeys.c_str());

        }
        */


    }

cleanup:

    if (hMenu) {
        DestroyMenu(hMenu);
    }
    if (pContextMenu) {
        pContextMenu->Release();
    }
    if (pFolder) {
        pFolder->Release();
    }

    bHandled = TRUE;
    return 0;
}



BOOL
CProgramList::UpdateListItem(
    LPCWSTR pwszPath,
    LPCWSTR pwszKey
    )
{

    // find the item first

    MAPSTR2ITEM::iterator iter;
    MULTIMAPSTR2ITEM::iterator iterExe;
    MULTIMAPSTR2ITEM::iterator iterFirstExe, iterLastExe;

    tstring     strKey = pwszPath;
    tstring     strExeKey;
    PSHITEMINFO pInfo = NULL;
    PSHITEMINFO pInfoExe = NULL;

    //
    // we need to iterate through all the persisted items
    //
    StrUpCase(strKey);

    iter = m_mapItems.find(strKey);
    if (iter != m_mapItems.end()) {
        pInfo = (*iter).second;
    }

    if (pInfo == NULL) {
        return FALSE;
    }

    //
    // once we have found this single item, get the command and
    // show info for all the other affected items
    //
    strExeKey = pInfo->strPath;
    StrUpCase(strExeKey);

    iterFirstExe = m_mmapExeItems.lower_bound(strExeKey);
    iterLastExe  = m_mmapExeItems.upper_bound(strExeKey);

    for (iterExe = iterFirstExe; iterExe != m_mmapExeItems.end() && iterExe != iterLastExe; ++iterExe) {
        pInfoExe = (*iterExe).second;


        // find this item in a listview

        LVFINDINFO lvf;
        INT index;

        lvf.flags = LVFI_PARAM;
        lvf.lParam = (LPARAM)pInfoExe;

        index = ListView_FindItem(m_hwndListView, -1, &lvf);
        if (index < 0) {
            return FALSE; // inconsistent
        }

        // else we have both the item and the keys
        if (pwszKey == NULL) {
            pInfoExe->strKeys.erase();
        } else {
            pInfoExe->strKeys = pwszKey;
        }

        ListView_SetItemText(m_hwndListView, index, 2, (LPWSTR)pInfoExe->strKeys.c_str());
    }

    return TRUE;
}



BOOL
CProgramList::IsEnabled(
    VOID
    )
{

    if (::IsWindow(m_hwndListView)) {
        return ::IsWindowEnabled(m_hwndListView);
    }

    return FALSE;
}


VOID
CProgramList::Enable(
    BOOL bEnable
    )
{
    if (::IsWindow(m_hwndListView)) {

        ::EnableWindow(m_hwndListView, bEnable);
    }

}

BOOL
GetProgramListSelection(
    CProgramList* pProgramList
    )
{
    return pProgramList->CaptureSelection();
}


BOOL
GetProgramListSelectionDetails(
    CProgramList* pProgramList,
    INT iInformationClass,
    VARIANT* pVal
    )
{
    return pProgramList->GetSelectionDetails(iInformationClass, pVal);
}

LRESULT
NotifyProgramList(
    CProgramList* pProgramList,
    LPNMHDR       pnmhdr,
    BOOL&         bHandled
    )
{
    LRESULT lRet = 0;

    switch (pnmhdr->code) {
    case LVN_GETDISPINFO:
        lRet = pProgramList->LVNotifyDispInfo(pnmhdr, bHandled);
        break;

    case LVN_COLUMNCLICK:
        lRet = pProgramList->LVNotifyColumnClick(pnmhdr, bHandled);
        break;

    case LVN_GETINFOTIP:
        lRet = pProgramList->LVNotifyGetInfoTip(pnmhdr, bHandled);
        break;

    case NM_RCLICK:
        lRet = pProgramList->LVNotifyRClick(pnmhdr, bHandled);
        break;

    default:
        bHandled = FALSE;
        break;
    }

    return lRet;
}

BOOL
GetProgramListEnabled(
    CProgramList* pProgramList
    )
{
    return pProgramList->IsEnabled();
}

VOID
EnableProgramList(
    CProgramList* pProgramList,
    BOOL bEnable
    )
{
    pProgramList->Enable(bEnable);
}

BOOL
UpdateProgramListItem(
    CProgramList* pProgramList,
    LPCWSTR pwszPath,
    LPCWSTR pwszKeys
    )
{
    return pProgramList->UpdateListItem(pwszPath, pwszKeys);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\compatui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CompatUI.rc
//
#define IDS_PROJNAME                    100
#define IDB_PROGVIEW                    101
#define IDS_DESKTOP                     101
#define IDR_PROGVIEW                    102
#define IDS_COMMON_STARTMENU            102
#define IDD_PROGVIEW                    103
#define IDS_STARTMENU                   103
#define IDR_UTIL                        104
#define IDS_COMMON_PROGRAMS             104
#define IDB_SELECTFILE                  105
#define IDS_PROGRAMS                    105
#define IDR_SELECTFILE                  106
#define IDS_PROGRAMNAME                 106
#define IDD_SELECTFILE                  107
#define IDS_FOLDER                      107
#define IDS_SETTINGS                    108
#define IDR_UPLOAD                      109
#define IDS_SENDINGINFO                 109
#define IDD_UPLOADFILES                 110
#define IDS_CLEANINGUP                  110
#define IDS_SENDINGCAPTION              111
#define IDS_WAITCLEANUP                 112
#define IDS_LAUNCHINGDR                 113
#define IDS_COLLECTINGDATACAPTION       114
#define IDS_COMPATWIZARD                115
#define IDS_GRABMISTATUS_COLLECTING     116
#define IDS_WIZARD_INFOTIP              117
#define IDC_LISTPROGRAMS                201
#define IDB_SORTDN                      203
#define IDB_SORTUP                      204
#define IDC_EDITFILENAME                207
#define IDA_WATSONANIM                  207
#define IDC_BROWSE                      208
#define IDA_FINDANIM                    209
#define IDI_COMPATWIZARD                210
//
// to items below should be identical with one difference - one
// should have quotes (the string we use in .cpp file) and the
// other should not (resource compiler adds quotes)
//
#define IDR_SHOWTEMPFILESDLGRC          TempFileListTemplate.html
#define IDR_SHOWTEMPFILESDLG            TEXT("TempFileListTemplate.html")

#define IDC_UPLOADFILES                 212
#define IDC_STATUSLINE1                 213
#define IDC_STATUSLINE2                 214
#define IDC_ANIMATEFIND                 215
#define IDS_CHECKING_FILES              216

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        212
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         217
#define _APS_NEXT_SYMED_VALUE           111
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\compatui\selectfile.cpp ===
// SelectFile.cpp : Implementation of CSelectFile

#include "stdafx.h"
#include "CompatUI.h"
#include "SelectFile.h"

#include "commdlg.h"
#include "cderr.h"
/////////////////////////////////////////////////////////////////////////////
// CSelectFile

//
// in upload.c
//

wstring StrUpCase(wstring& wstr);



STDMETHODIMP CSelectFile::get_BrowseTitle(BSTR *pVal)
{
    *pVal = m_bstrTitle.Copy();
    return S_OK;
}

STDMETHODIMP CSelectFile::put_BrowseTitle(BSTR newVal)
{
    m_bstrTitle = newVal;
    return S_OK;
}

STDMETHODIMP CSelectFile::get_BrowseFilter(BSTR *pVal)
{
    *pVal = m_bstrFilter.Copy();
    return S_OK;
}

STDMETHODIMP CSelectFile::put_BrowseFilter(BSTR newVal)
{
    m_bstrFilter = newVal;
    return S_OK;
}

STDMETHODIMP CSelectFile::get_BrowseInitialDirectory(BSTR *pVal)
{
    *pVal = m_bstrInitialDirectory;
    return S_OK;
}

STDMETHODIMP CSelectFile::put_BrowseInitialDirectory(BSTR newVal)
{
    m_bstrInitialDirectory = newVal;
    return S_OK;
}

STDMETHODIMP CSelectFile::get_BrowseFlags(long *pVal)
{
    *pVal = (LONG)m_dwBrowseFlags;
    return S_OK;
}

STDMETHODIMP CSelectFile::put_BrowseFlags(long newVal)
{
    m_dwBrowseFlags = (DWORD)newVal;
    return S_OK;
}

STDMETHODIMP CSelectFile::get_FileName(BSTR *pVal)
{
    wstring sFileName;

    GetFileNameFromUI(sFileName);
    m_bstrFileName = sFileName.c_str();

    *pVal = m_bstrFileName.Copy();
    return S_OK;
}

STDMETHODIMP CSelectFile::put_FileName(BSTR newVal)
{
    m_bstrFileName = newVal;
    SetDlgItemText(IDC_EDITFILENAME, m_bstrFileName);

    return S_OK;
}

STDMETHODIMP CSelectFile::get_ErrorCode(long *pVal)
{
    *pVal = (LONG)m_dwErrorCode;
    return S_OK;
}


#define MAX_BUFFER 2048

LRESULT CSelectFile::OnClickedBrowse(
    WORD wNotifyCode, 
    WORD wID, 
    HWND hWndCtl, 
    BOOL& bHandled) 
{
    LRESULT lRes = 0;        
    
    // TODO: Add your implementation code here
    OPENFILENAME ofn;
    LPTSTR pszFileName = NULL;
    DWORD  dwFileNameLength = 0;
    DWORD  dwLen;
    LPTSTR pszFilter = NULL, pch;

    m_dwErrorCode = 0;

    ZeroMemory(&ofn, sizeof(ofn)); 
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hWnd;

    //
    // part one (straight) - title 
    //
    ofn.lpstrTitle = (LPCTSTR)m_bstrTitle; // assumes we're unicode (and we are)

    //
    // recover the filename from the edit box
    //
    wstring sFileName;

    if (GetFileNameFromUI(sFileName)) {
        m_bstrFileName = sFileName.c_str();
    }

    //
    // part two - init filename
    //
    dwFileNameLength = __max(MAX_BUFFER, m_bstrFileName.Length() * 2); // in characters

    pszFileName = new TCHAR[dwFileNameLength * sizeof(*pszFileName)];
    if (pszFileName == NULL) {
        m_dwErrorCode = ERROR_OUTOFMEMORY;
        goto HandleError;
    }
    
    // so we have the buffer now
    //
    if (m_bstrFileName.Length () > 0) {
        // sanitize the filename with regard to quotes
        _tcscpy(pszFileName, (LPCTSTR)m_bstrFileName); // hypocritical copy, we are unicode
    } else {
        // start with the contents of the text box then
        *pszFileName = TEXT('\0'); 
    }

    // 
    // sanity check, if pszFileName ends with \ then we will get an error
    //
    PathRemoveBackslash(pszFileName);

    ofn.lpstrFile  = pszFileName;
    ofn.nMaxFile   = dwFileNameLength;

    //
    // see if we also need to process filter
    //

    if (m_bstrFilter.Length() > 0) {
        dwLen = m_bstrFilter.Length(); 

        pszFilter = new TCHAR[(dwLen + 2) * sizeof(*pszFilter)];
        if (pszFilter == NULL) {
            m_dwErrorCode = ERROR_OUTOFMEMORY;
            goto HandleError;
        }

        RtlZeroMemory(pszFilter, (dwLen + 2) * sizeof(*pszFilter));
        _tcscpy(pszFilter, m_bstrFilter);

        pch = pszFilter;
        while (pch) {
            pch = _tcschr(pch, TEXT('|'));
            if (pch) {
                *pch++ = TEXT('\0');
            }
        }

        // now that the replacement is done -- assign the filter string
        ofn.lpstrFilter = pszFilter;
    }

    //
    // now check whether we have some in the initial directory
    //
    if (m_bstrInitialDirectory.Length() > 0) {
        ofn.lpstrInitialDir = (LPCTSTR)m_bstrInitialDirectory;
    }

    //
    // flags 
    // 

    if (m_dwBrowseFlags) {
        ofn.Flags = m_dwBrowseFlags;
    } else {
        ofn.Flags = OFN_FILEMUSTEXIST|OFN_EXPLORER;
    }

    BOOL bRetry;
    BOOL bSuccess;

    do {
        bRetry = FALSE;
            
        bSuccess = GetOpenFileName(&ofn);
        if (!bSuccess) {
            m_dwErrorCode = CommDlgExtendedError();
            if (m_dwErrorCode == FNERR_INVALIDFILENAME) {
                *pszFileName = TEXT('\0');
                bRetry = TRUE;
            } 
        }
    } while (bRetry);
        
    if (!bSuccess) {
        goto HandleError;
    }

    SetDlgItemText(IDC_EDITFILENAME, pszFileName);

    m_bstrFileName = (LPCTSTR)pszFileName;
    m_dwErrorCode = 0;

HandleError:

    if (pszFileName != NULL) {
        delete[] pszFileName;
    }

    if (pszFilter != NULL) {
        delete[] pszFilter;
    }

    
    bHandled = TRUE;
    return lRes;
}


BOOL
CSelectFile::PreTranslateAccelerator(
    LPMSG pMsg, 
    HRESULT& hRet
    )
{
    HWND hWndCtl;
    HWND hwndEdit   = GetDlgItem(IDC_EDITFILENAME);
    HWND hwndBrowse = GetDlgItem(IDC_BROWSE);
    BSTR bstrFileName = NULL;
    WORD wCmd = 0;
    BOOL bBrowseHandled;

    hRet = S_OK;
    hWndCtl = ::GetFocus();
    if (IsChild(hWndCtl) && ::GetParent(hWndCtl) != m_hWnd)    {
        do {
            hWndCtl = ::GetParent(hWndCtl);
        } while (::GetParent(hWndCtl) != m_hWnd);
    }

    if (pMsg->message == WM_KEYDOWN &&
            (LOWORD(pMsg->wParam) == VK_RETURN ||
            LOWORD(pMsg->wParam) == VK_EXECUTE)) {
        if (hWndCtl == hwndEdit) {
            BOOL bReturn;
            wstring sFileName;
                    
            bReturn = GetFileNameFromUI(sFileName) && 
                      ValidateExecutableFile(sFileName.c_str(), TRUE);
            if (bReturn) {
                Fire_SelectionComplete();
                return TRUE;
            }
        }
        // this either was hwndBrowse or filename was not there -- open
        // browse dialog then
            
        OnClickedBrowse(BN_CLICKED, IDC_BROWSE, hwndBrowse, bBrowseHandled);
        ::SetFocus(hwndEdit);
    }

    //
    // fixup external accelerators for internal controls (in this case -- edit)
    //
    if (m_Accel.IsAccelKey(pMsg, &wCmd) && wCmd == IDC_EDITFILENAME) {
        ::SetFocus(hwndEdit);
        return TRUE;
    }
        

    //
    // check for external accelerators because the next call is going to eat the message
    //
    if (m_ExternAccel.IsAccelKey(pMsg)) { // we do not touch external accel messages
        return FALSE; 
    }

    //
    // check whether we are tabbing out of control
    //
    if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_TAB) {
        // check whether we're tabbing out
        // (perhaps the control wants to eat tab?
        DWORD_PTR dwDlgCode = ::SendMessage(pMsg->hwnd, WM_GETDLGCODE, 0, 0);
        if (!(dwDlgCode & DLGC_WANTTAB)) {
            // control does not want a tab
            // see whether it's the last control and we're tabbing out
            HWND hwndFirst = GetNextDlgTabItem(NULL, FALSE); // first 
            HWND hwndLast  = GetNextDlgTabItem(hwndFirst, TRUE); 
            BOOL bFirstOrLast;
            if (::GetKeyState(VK_SHIFT) & 0x8000) {
                // shift ? 
                bFirstOrLast = (hWndCtl == hwndFirst);
            } else {
                bFirstOrLast = (hWndCtl == hwndLast);
            }

            if (bFirstOrLast) {
                IsDialogMessage(pMsg);
                return FALSE;
            }
        }
    }
                


    return CComCompositeControl<CSelectFile>::PreTranslateAccelerator(pMsg, hRet);
}
/*

STDMETHODIMP CSelectFile::get_Accel(BSTR *pVal)
{
    CComBSTR bstr = (LPCWSTR)m_Accel;
    *pVal = bstr.Copy();
    return S_OK;
}

STDMETHODIMP CSelectFile::put_Accel(BSTR newVal)
{
    m_Accel = (LPCWSTR)newVal;
    return S_OK;
}
*/
STDMETHODIMP CSelectFile::get_ExternAccel(BSTR *pVal)
{
    CComBSTR bstr = m_ExternAccel.GetAccelString(0).c_str();
    *pVal = bstr.Copy();
    return S_OK;
}

STDMETHODIMP CSelectFile::put_ExternAccel(BSTR newVal)
{
    m_ExternAccel = (LPCWSTR)newVal;
    return S_OK;
}

static TCHAR szU[]  = TEXT("<U>");
static TCHAR szUC[] = TEXT("</U>");

#define szU_Len  (CHARCOUNT(szU) - 1)
#define szUC_Len (CHARCOUNT(szUC) - 1)

STDMETHODIMP CSelectFile::get_BrowseBtnCaption(BSTR *pVal)
{
    // TODO: Add your implementation code here
    CComBSTR bstrCaption;
    wstring  strCaption = m_BrowseBtnCaption;
    wstring::size_type nPos;

    nPos = m_BrowseBtnCaption.find(TEXT('&'));
    if (nPos == wstring::npos || nPos > m_BrowseBtnCaption.length() - 1) {
        bstrCaption = m_BrowseBtnCaption.c_str();
    } else {
        bstrCaption = m_BrowseBtnCaption.substr(0, nPos).c_str();
        bstrCaption += szU;
        bstrCaption += m_BrowseBtnCaption[nPos+1];
        bstrCaption += szUC;
        if (nPos < m_BrowseBtnCaption.length() - 1) {
            bstrCaption += m_BrowseBtnCaption.substr(nPos+2).c_str();
        }
    }
    *pVal = bstrCaption.Copy();
    return S_OK;
}

STDMETHODIMP CSelectFile::put_BrowseBtnCaption(BSTR newVal)
{

    // 
    // form a caption from the string
    // 
    wstring strCaption  = newVal; 
    wstring strCaptionU = strCaption;
    wstring::size_type nPosU, nPosUC;
    wstring strAccel;
    
    StrUpCase(strCaptionU);

    //
    // find <u> </u> pair
    //
    nPosU = strCaptionU.find(szU);
    nPosUC = strCaptionU.find(szUC, nPosU);
    if (nPosUC == wstring::npos || nPosU == wstring::npos || nPosUC < nPosU || nPosUC <= (nPosU + szU_Len)) {
        goto cleanup;
    }
    
    // extract the char at the & 
    // 
    // 
    strAccel = strCaption.substr(nPosU + szU_Len, nPosUC - (nPosU + szU_Len));
    
    //
    // add accel please -- with command id IDC_BROWSE
    //
    m_Accel.SetAccel(strAccel.c_str(), IDC_BROWSE);

    //
    // now we (presumably) found <u>accelchar</u>
    //
    m_BrowseBtnCaption = strCaption.substr(0, nPosU); // up to the <U>
    m_BrowseBtnCaption += TEXT('&');
    m_BrowseBtnCaption += strAccel.c_str();
    m_BrowseBtnCaption += strCaption.substr(nPosUC + szUC_Len); // all the rest please

    if (IsWindow()) {
        SetDlgItemText(IDC_BROWSE, m_BrowseBtnCaption.c_str());
    }

cleanup:

    return S_OK;
}

STDMETHODIMP CSelectFile::get_AccelCmd(LONG lCmd, BSTR *pVal)
{
    CComBSTR bstrVal = m_Accel.GetAccelString((WORD)lCmd).c_str();
    *pVal = bstrVal.Copy();
    return S_OK;
}

STDMETHODIMP CSelectFile::put_AccelCmd(LONG lCmd, BSTR newVal)
{
    m_Accel.SetAccel(newVal, (WORD)lCmd);
    return S_OK;
}

STDMETHODIMP CSelectFile::ClearAccel()
{
    m_Accel.ClearAccel();
    return S_OK;
}

STDMETHODIMP CSelectFile::ClearExternAccel()
{
    m_ExternAccel.ClearAccel();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\compatui\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__6A70480E_DE84_4628_B473_C28872E61333__INCLUDED_)
#define AFX_STDAFX_H__6A70480E_DE84_4628_B473_C28872E61333__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlhost.h>
#include <atlctl.h>
#include <atlwin.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__6A70480E_DE84_4628_B473_C28872E61333__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\compatui\selectfile.h ===
// SelectFile.h : Declaration of the CSelectFile

#ifndef __SELECTFILE_H_
#define __SELECTFILE_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include "compatuiCP.h"
extern "C" {
    #include "shimdb.h"
}

#pragma warning(disable:4786)
#include <string>
#include <xstring>
#include <map>
#include <locale>
#include <algorithm>
#include <vector>
using namespace std;

//
// Accel containment code
//
#include "AccelContainer.h"

//
// in ProgList.cpp
//

BOOL
ValidateExecutableFile(
    LPCTSTR pszPath,
    BOOL    bValidateFileExists 
    );

//
// in util.cpp
//
wstring
ShimUnquotePath(
    LPCTSTR pwszFileName
    );



/////////////////////////////////////////////////////////////////////////////
// CSelectFile
class ATL_NO_VTABLE CSelectFile : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CStockPropImpl<CSelectFile, ISelectFile, &IID_ISelectFile, &LIBID_COMPATUILib>,
    public CComCompositeControl<CSelectFile>,
    public IPersistStreamInitImpl<CSelectFile>,
    public IOleControlImpl<CSelectFile>,
    public IOleObjectImpl<CSelectFile>,
    public IOleInPlaceActiveObjectImpl<CSelectFile>,
    public IViewObjectExImpl<CSelectFile>,
    public IOleInPlaceObjectWindowlessImpl<CSelectFile>,
    public CComCoClass<CSelectFile, &CLSID_SelectFile>,
    public ISupportErrorInfo,
    public IPersistPropertyBagImpl<CSelectFile>,
    public IConnectionPointContainerImpl<CSelectFile>,
    public CProxy_ISelectFileEvents< CSelectFile >,
    public IPropertyNotifySinkCP< CSelectFile >,
    public IProvideClassInfo2Impl<&CLSID_SelectFile, &DIID__ISelectFileEvents, &LIBID_COMPATUILib>,
    public CProxy_IProgViewEvents< CSelectFile >
{
public:
    CSelectFile() :
      m_dwBrowseFlags(0)
    {
        m_bWindowOnly    = TRUE;
        m_bTabStop       = TRUE;
        m_bMouseActivate = FALSE;
        CalcExtent(m_sizeExtent);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SELECTFILE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSelectFile)
    COM_INTERFACE_ENTRY(ISelectFile)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
//    COM_INTERFACE_ENTRY(ISupportErrorInfo)
//    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)

    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IPersistPropertyBag)
     
END_COM_MAP()

BEGIN_PROP_MAP(CSelectFile)
    PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
    PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_StockColorPage)
    PROP_ENTRY("BackStyle", DISPID_BACKSTYLE, CLSID_NULL)
//    PROP_ENTRY("BorderColor", DISPID_BORDERCOLOR, CLSID_StockColorPage)
//    PROP_ENTRY("BorderVisible", DISPID_BORDERVISIBLE, CLSID_NULL)
    PROP_ENTRY("Enabled", DISPID_ENABLED, CLSID_NULL)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
    PROP_ENTRY("Accel",            7, CLSID_NULL)
    PROP_ENTRY("ExternAccel",      8, CLSID_NULL)
    PROP_ENTRY("BrowseBtnCaption", 9, CLSID_NULL)
END_PROP_MAP()

BEGIN_CONNECTION_POINT_MAP(CSelectFile)
CONNECTION_POINT_ENTRY(DIID__ISelectFileEvents)
// CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
CONNECTION_POINT_ENTRY(DIID__IProgViewEvents)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CSelectFile)
    COMMAND_HANDLER(IDC_BROWSE, BN_CLICKED, OnClickedBrowse)
    
//    MESSAGE_HANDLER(WM_CTLCOLORDLG, OnColorDlg)
//    MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorDlg)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)    
    MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

    CHAIN_MSG_MAP(CComCompositeControl<CSelectFile>)

// ALT_MSG_MAP(1)

END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

BEGIN_SINK_MAP(CSelectFile)
    //Make sure the Event Handlers have __stdcall calling convention
END_SINK_MAP()

    STDMETHOD(OnAmbientPropertyChange)(DISPID dispid)
    {
        if (dispid == DISPID_AMBIENT_BACKCOLOR)
        {
            SetBackgroundColorFromAmbient();
            FireViewChange();
        } 
        return IOleControlImpl<CSelectFile>::OnAmbientPropertyChange(dispid);
    }

    HRESULT FireOnChanged(DISPID dispID) {
        if (dispID == DISPID_ENABLED) {

            ::EnableWindow(GetDlgItem(IDC_EDITFILENAME), m_bEnabled);
            ::EnableWindow(GetDlgItem(IDC_BROWSE),       m_bEnabled);
                    
        }
        return S_OK;
    }


    STDMETHOD(GetControlInfo)(CONTROLINFO* pCI) {
        if (NULL == pCI) {
            return E_POINTER;
        }

        pCI->hAccel = NULL;
        pCI->cAccel = 0;
        pCI->dwFlags = 0;
        return S_OK;
    }
        


// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
    {
        static const IID* arr[] = 
        {
            &IID_ISelectFile,
        };
        for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
        {
            if (InlineIsEqualGUID(*arr[i], riid))
                return S_OK;
        }
        return S_FALSE;
    }

    STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL* psizel) {
        HRESULT hr = IOleObjectImpl<CSelectFile>::SetExtent(dwDrawAspect, psizel);

        PositionControls();

        return hr;
    }

    STDMETHOD(SetObjectRects)(LPCRECT prcPos, LPCRECT prcClip) {
        IOleInPlaceObjectWindowlessImpl<CSelectFile>::SetObjectRects(prcPos, prcClip);

        PositionControls(prcPos);
        
        return S_OK;
    }

    HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect = NULL) {
        HRESULT hr = CComCompositeControl<CSelectFile>::InPlaceActivate(iVerb, prcPosRect);

        Fire_StateChanged(iVerb);
      
        return hr;
    }

    STDMETHOD(UIDeactivate)() {
        HRESULT hr = IOleInPlaceObjectWindowlessImpl<CSelectFile>::UIDeactivate();

        //
        // We are being deactivated
        // when we loose focus, nuke default button out of here
        //

        DWORD dwDefBtn = (DWORD)SendMessage(DM_GETDEFID, 0);

        if (HIWORD(dwDefBtn) == DC_HASDEFID) {
            // SendMessage(DM_SETDEFID, IDC_EDITFILENAME); // basically forget the default button
            dwDefBtn = LOWORD(dwDefBtn);
            DWORD dwStyle = ::GetWindowLong(GetDlgItem(dwDefBtn), GWL_STYLE);
            if (dwStyle & BS_DEFPUSHBUTTON) { 
                dwStyle &= ~BS_DEFPUSHBUTTON;
                dwStyle |= BS_PUSHBUTTON;
                SendDlgItemMessage(dwDefBtn,  BM_SETSTYLE, dwStyle, TRUE);
            }
        }
        
        // send killfocus
        SendMessage(WM_KILLFOCUS);


        return hr;
    }


    LRESULT OnMouseActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        // Manually activate the control
        LRESULT lRes = CComCompositeControl<CSelectFile>::OnMouseActivate(uMsg, wParam, lParam, bHandled);
        m_bMouseActivate = TRUE;        
            
        return 0;
    } 
    
    BOOL PreTranslateAccelerator(LPMSG pMsg, HRESULT& hrRet);

       
    // IViewObjectEx
    DECLARE_VIEW_STATUS(0)

// ISelectFile
public:
    STDMETHOD(ClearAccel)();
    STDMETHOD(ClearExternAccel)();
    STDMETHOD(get_AccelCmd)(/*[in]*/ LONG lCmd, /*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_AccelCmd)(/*[in]*/ LONG lCmd, /*[in]*/ BSTR newVal);
    STDMETHOD(get_BrowseBtnCaption)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_BrowseBtnCaption)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_ExternAccel)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_ExternAccel)(/*[in]*/ BSTR newVal);
#if 0
    STDMETHOD(get_Accel)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_Accel)(/*[in]*/ BSTR newVal);
#endif
    STDMETHOD(get_ErrorCode)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_FileName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_FileName)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_BrowseFlags)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_BrowseFlags)(/*[in]*/ long newVal);
    STDMETHOD(get_BrowseInitialDirectory)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_BrowseInitialDirectory)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_BrowseFilter)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_BrowseFilter)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_BrowseTitle)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_BrowseTitle)(/*[in]*/ BSTR newVal);
    OLE_COLOR m_clrBackColor;
    LONG m_nBackStyle;
    OLE_COLOR m_clrBorderColor;
    BOOL m_bBorderVisible;
    BOOL m_bEnabled;


    // browse dialog props
    CComBSTR m_bstrTitle;
    CComBSTR m_bstrFilter;
    CComBSTR m_bstrInitialDirectory;
    CComBSTR m_bstrFileName;
    DWORD    m_dwBrowseFlags;
    DWORD    m_dwErrorCode;

    wstring  m_BrowseBtnCaption;
    BOOL     m_bMouseActivate;

    enum { IDD = IDD_SELECTFILE };
    LRESULT OnClickedBrowse(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

protected:
    VOID PositionControls(LPCRECT lprc = NULL) {

        if (NULL == lprc) {
            lprc = &m_rcPos;
        }

        if (IsWindow()) {
            // position the edit ctl first
            HDWP hdwp = BeginDeferWindowPos(2);
            HWND hedit = GetDlgItem(IDC_EDITFILENAME);
            HWND hbtn  = GetDlgItem(IDC_BROWSE);
            LONG lWidthEdit;
            LONG lWidthBtn;
            RECT rcBtn;
            RECT rcEdit;
            LONG lSpace = ::GetSystemMetrics(SM_CXFRAME);

            ::GetWindowRect(hbtn,  &rcBtn); // get the rectangle for the button
            ::GetWindowRect(hedit, &rcEdit);
            lWidthBtn  = rcBtn.right - rcBtn.left; // width of the button - 1
            lWidthEdit = lprc->right - lprc->left - lSpace - lWidthBtn;

            hdwp = ::DeferWindowPos(hdwp, hedit, NULL, 0, 0, lWidthEdit, rcEdit.bottom - rcEdit.top, SWP_NOZORDER);
            hdwp = ::DeferWindowPos(hdwp, hbtn,  NULL, lWidthEdit + lSpace, 0, lWidthBtn, rcBtn.bottom - rcBtn.top, SWP_NOZORDER);
            ::EndDeferWindowPos(hdwp);
        }
    }



    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
        WORD wCmd = 0;
        
        // 
        // determine whether we came here with accel
        //
        CComCompositeControl<CSelectFile>::OnSetFocus(uMsg, wParam, lParam, bHandled);

        if (!m_bMouseActivate) {
            DoVerbUIActivate(&m_rcPos, NULL);

            if (m_Accel.IsAccelKey(NULL, &wCmd)) {
                //
                // we are to be accelerated 
                // we look into the accel cmd to see what is there
                //
                switch(wCmd) {
                case IDC_BROWSE:
                    ::SetFocus(GetDlgItem(IDC_BROWSE));
                    OnClickedBrowse(BN_CLICKED, IDC_BROWSE, GetDlgItem(IDC_BROWSE), bHandled);
                    break;

                case IDC_EDITFILENAME:
                    ::SetFocus(GetDlgItem(IDC_EDITFILENAME));
                    break;
                }
            }
            
            //
            // did we arrive here with the tab? 
            //
            if (!IsChild(GetFocus())) {
                if (GetKeyState(VK_TAB) & 0x8000) { // was that the tab key ? 
                    HWND hwndFirst = GetNextDlgTabItem(NULL, FALSE); // first 
                    HWND hwndLast  = GetNextDlgTabItem(hwndFirst, TRUE); 

                    if ((GetKeyState(VK_SHIFT)   & 0x8000)) {
                        // aha, came here with a shift-tab! -- what is the last control ? 
                        ::SetFocus(hwndLast);
                    } else {
                        ::SetFocus(hwndFirst);
                    }
                } else {

                    ::SetFocus(GetDlgItem(IDC_EDITFILENAME));
                }
            }
        }
        
        //
        // set the default pushbutton 
        //
        SendMessage(DM_SETDEFID, IDC_BROWSE); 
        SendDlgItemMessage(IDC_BROWSE, BM_SETSTYLE, BS_DEFPUSHBUTTON);

        m_bMouseActivate = FALSE;
        bHandled = TRUE;
        return 0;
    }


    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
/* // this code sets the same font as the container is using 
   // we do not care for now, we're using MS Shell Dlg instead

        CComVariant varFont;
        HFONT       hFont;
        HWND        hwnd;

        HRESULT hr = GetAmbientProperty(DISPID_AMBIENT_FONT, varFont);

        if (SUCCEEDED(hr)) {

            CComQIPtr<IFont, &IID_IFont> pFont (varFont.pdispVal);
            if (SUCCEEDED(pFont->get_hFont(&hFont))) {
                for (hwnd = GetTopWindow(); hwnd != NULL; 
                hwnd = ::GetNextWindow(hwnd, GW_HWNDNEXT)) {
                         ::SendMessage(hwnd, WM_SETFONT, (WPARAM)hFont, TRUE);
                }

            }

        }
*/

        SHAutoComplete(GetDlgItem(IDC_EDITFILENAME), SHACF_FILESYSTEM);
        if (m_BrowseBtnCaption.length()) {
            SetDlgItemText(IDC_BROWSE, m_BrowseBtnCaption.c_str());
        }

        // 
        // show ui hints
        //

        SendMessage(WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, UISF_HIDEACCEL | UISF_HIDEFOCUS));
    
        return 0;
    }

    //
    // Accelerators
    //
    CAccelContainer m_Accel;
    CAccelContainer m_ExternAccel;

    BOOL GetFileNameFromUI(wstring& sFileName) {
        BSTR bstrFileName = NULL;
        BOOL bReturn = FALSE;
        bReturn = GetDlgItemText(IDC_EDITFILENAME, bstrFileName);
        if (bReturn) {
            sFileName = ShimUnquotePath(bstrFileName);
        } else {
            sFileName.erase();
        }
        if (bstrFileName) {
            ::SysFreeString(bstrFileName);
        }
        return bReturn;
    }


};

#endif //__SELECTFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\compatui\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\compatui\upload.cpp ===
// Upload.cpp : Implementation of CUpload
#include "stdafx.h"
#include "resource.h"
#include "CompatUI.h"
#include "shlobj.h"
extern "C" {
    #include "shimdb.h"
}

#include "Upload.h"

TCHAR szKeyDataFiles[] = TEXT("DataFiles");


//
// lives in util.cpp
//
BOOL
GetExePathFromObject(
    LPCTSTR lpszPath,  // path to an arbitrary object
    CComBSTR& bstrExePath
    );


//
// lives in proglist.cpp
//

wstring
    LoadResourceString(UINT nID);

//
// lives in ntutil.c
//
extern "C"
BOOL
WINAPI
CheckFileLocation(
    LPCWSTR pwszDosPath,
    BOOL* pbRoot,
    BOOL* pbLeaf
    );


//
// conversion
//
BOOL VariantToBOOL(CComVariant& v)
{
    if (SUCCEEDED(v.ChangeType(VT_BOOL))) {
        return v.boolVal;
    }

    return FALSE;
}

wstring VariantToStr(CComVariant& v)
{
    wstring str;

    if (v.vt != VT_EMPTY && v.vt != VT_NULL) {
        if (SUCCEEDED(v.ChangeType(VT_BSTR))) {
            str = v.bstrVal;
        }
    }

    return str;
}

HRESULT StringToVariant(VARIANT* pv, const wstring& str)
{
    HRESULT hr = E_FAIL;

    pv->vt = VT_NULL;
    pv->bstrVal = ::SysAllocString(str.c_str());
    if (pv->bstrVal == NULL) {
        hr = E_OUTOFMEMORY;
    } else {
        pv->vt = VT_BSTR;
        hr = S_OK;
    }

    return hr;
}


BOOL
GetTempFile(
    LPCTSTR lpszPrefix,
    CComBSTR& bstrFile
    )
{
    DWORD dwLength;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szTempFile[MAX_PATH];

    dwLength = GetTempPath(CHARCOUNT(szBuffer), szBuffer);
    if (!dwLength || dwLength > CHARCOUNT(szBuffer)) {
        return FALSE;
    }

    //
    // we got directory, generate the file now
    //

    dwLength = GetTempFileName(szBuffer, lpszPrefix, 0, szTempFile);
    if (!dwLength) {
        return FALSE;
    }

    bstrFile = szTempFile;
    return TRUE;

}

wstring StrUpCase(wstring& wstr)
{
    ctype<wchar_t> _ct;
    wstring::iterator iter;

    for (iter = wstr.begin(); iter != wstr.end(); ++iter) {
        (*iter) = _ct.toupper(*iter);
    }

    return wstr;
}

/////////////////////////////////////////////////////////////////////////////
// CUpload


BOOL CUpload::GetDataFilesKey(CComBSTR& bstrVal)
{
    // STRVEC::iterator iter;
    MAPSTR2MFI::iterator iter;

    bstrVal.Empty();

    for (iter = m_DataFiles.begin(); iter != m_DataFiles.end(); ++iter) {
        if (bstrVal.Length()) {
            bstrVal.Append(TEXT("|"));
        }
        bstrVal.Append((*iter).second.strFileName.c_str());
    }
    return bstrVal.Length() != 0;

}

STDMETHODIMP CUpload::SetKey(BSTR pszKey, VARIANT* pvValue)
{
    wstring strKey = pszKey;
    VARIANT vStr;
    HRESULT hr;
    HRESULT hrRet = S_OK;


    //
    // dwwin is case-sensitive
    //
    // StrUpCase(strKey);

    if (strKey == szKeyDataFiles) { // data files cannot be set directly
        return E_INVALIDARG;
    }

    VariantInit(&vStr);

    hr = VariantChangeType(&vStr, pvValue, 0, VT_BSTR);
    if (SUCCEEDED(hr)) {
        wstring strVal = vStr.bstrVal;

        m_mapManifest[strKey] = strVal;
    } else if (pvValue->vt == VT_NULL || pvValue->vt == VT_EMPTY) {
        m_mapManifest.erase(strKey);
    } else {
        hrRet = E_INVALIDARG;
    }
    VariantClear(&vStr);

    return hrRet;
}

STDMETHODIMP CUpload::GetKey(BSTR pszKey, VARIANT *pValue)
{
    CComBSTR bstrVal;
    wstring  strKey = pszKey;

    // StrUpCase(strKey);

    if (strKey == szKeyDataFiles) {
        //
        // data files -- handled separately
        //
        if (GetDataFilesKey(bstrVal)) {
            pValue->vt = VT_BSTR;
            pValue->bstrVal = bstrVal.Copy();
        } else {
            pValue->vt = VT_NULL;
        }

    } else {

        MAPSTR2STR::iterator iter = m_mapManifest.find(strKey);
        if (iter != m_mapManifest.end()) {
            bstrVal = (*iter).second.c_str();
            pValue->vt = VT_BSTR;
            pValue->bstrVal = bstrVal.Copy();
        } else {
            pValue->vt = VT_NULL;
        }
    }
    return S_OK;
}

#define DWWIN_HEADLESS_MODE 0x00000080

BOOL CUpload::IsHeadlessMode(void)
{
    CComVariant varFlags;
    HRESULT     hr;
    BOOL        bHeadless = FALSE;

    GetKey(TEXT("Flags"), &varFlags);

    hr = varFlags.ChangeType(VT_I4);
    if (SUCCEEDED(hr)) {
        bHeadless = !!(varFlags.lVal & DWWIN_HEADLESS_MODE);
    }

    return bHeadless;
}


/*
DWORD CUpload::CountFiles(DWORD nLevel, LPCWSTR pszPath)
{
    WIN32_FIND_DATA wfd;
    wstring strPath = pszPath;
    wstring::size_type nPos;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    DWORD dwCount = 0;

    nPos = strPath.length();
    if (strPath[nPos-1] != TEXT('\\')) {
        strPath += TEXT('\\');
        ++nPos;
    }

    FindFirstFileExW(

    strPath += TEXT('*');

    hFind = FindFirstFile(strPath.c_str(), &wfd);
    if (hFind != INVALID_HANDLE_VALUE) {
        do {
            if (nLevel < 3 && wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                if (wcscmp(wfd.cFileName, TEXT(".")) && wcscmp(wfd.cFileName, TEXT(".."))) {
                    strPath.replace(nPos, wstring::nPos, wfd.cFileName);
                    dwCount += CountFiles(nLevel + 1, strPath.c_str());
                }
            } else { // file
                ++dwCount;
            }
        } while (FindNextFile(hFind, &wfd));

        FindClose(hFind);
    }

    return dwCount;
}
*/

BOOL CALLBACK CUpload::_GrabmiCallback(
    LPVOID    lpvCallbackParam, // application-defined parameter
    LPCTSTR   lpszRoot,         // root directory path
    LPCTSTR   lpszRelative,     // relative path
    PATTRINFO pAttrInfo,        // attributes
    LPCWSTR   pwszXML           // resulting xml
    )
{
    GMEPARAMS* pParams = (GMEPARAMS*)lpvCallbackParam;

    CUpload* pT = pParams->first;
    IProgressDialog* ppd = pParams->second;

    if (ppd == NULL) {
        return TRUE;
    }

    ppd->SetLine(2, lpszRoot,     TRUE, NULL);

    // ppd->SetLine(2, lpszRelative, TRUE, NULL);

    return !ppd->HasUserCancelled();
}


STDMETHODIMP CUpload::AddMatchingInfo(
    BSTR pszCommand,
    VARIANT vFilter,
    VARIANT vKey,
    VARIANT vDescription,
    VARIANT vProgress,
    BOOL *pbSuccess)
{

/*  HANDLE hThread = NULL;
    DWORD  dwExitCode = 0;
    DWORD  dwWait;
*/

    CComVariant varFilter(vFilter);
    DWORD  dwFilter = GRABMI_FILTER_NORMAL;
    wstring strKey;
    wstring strDescription;

    if (SUCCEEDED(varFilter.ChangeType(VT_I4))) {
        dwFilter   = (DWORD)varFilter.lVal;
    }

    strKey         = VariantToStr(CComVariant(vKey));
    strDescription = VariantToStr(CComVariant(vDescription));


    *pbSuccess = AddMatchingInfoInternal(::GetActiveWindow(),
                                         pszCommand,
                                         dwFilter,
                                         VariantToBOOL(CComVariant(vProgress)),
                                         strKey.empty()         ? NULL : strKey.c_str(),
                                         strDescription.empty() ? NULL : strDescription.c_str());

/*

    MITHREADPARAMBLK* pParam = new MITHREADPARAMBLK;
    CComVariant varFilter(vFilter);

    if (!pParam) {
        goto cleanup;
    }

    pParam->pThis          = this;
    pParam->strCommand     = pszCommand;
    pParam->hwndParent     = ::GetActiveWindow();
    pParam->dwFilter       = GRABMI_FILTER_NORMAL;

    if (SUCCEEDED(varFilter.ChangeType(VT_I4))) {
        pParam->dwFilter   = (DWORD)varFilter.lVal;
    }

    pParam->bNoProgress    = VariantToBOOL(CComVariant(vProgress));
    pParam->strKey         = VariantToStr(CComVariant(vKey));
    pParam->strDescription = VariantToStr(CComVariant(vDescription));

    hThread = CreateThread(NULL,
                           0,
                           (LPTHREAD_START_ROUTINE)_AddMatchingInfoThreadProc,
                           (LPVOID)pParam,
                           0,
                           NULL);
    if (!hThread) {
        goto cleanup;
    }

    dwWait = WaitForSingleObject(hThread, INFINITE);
    if (dwWait != WAIT_OBJECT_0) {
        goto cleanup;
    }

    GetExitCodeThread(hThread, &dwExitCode);

cleanup:
    if (hThread) {
        CloseHandle(hThread);
    }

    *pbSuccess = !!dwExitCode;
*/

    return S_OK;
}


DWORD WINAPI
CUpload::_AddMatchingInfoThreadProc(LPVOID lpvThis)
{
    BOOL bSuccess;
    HRESULT hr;

    MITHREADPARAMBLK* pParam = (MITHREADPARAMBLK*)lpvThis;
    if (!pParam->bNoProgress) {
        hr = CoInitialize(NULL);
        if (!SUCCEEDED(hr)) {
            pParam->bNoProgress = TRUE;
        }
    }

    bSuccess = pParam->pThis->AddMatchingInfoInternal(::GetActiveWindow(),
                                                      pParam->strCommand.c_str(),
                                                      pParam->dwFilter,
                                                      pParam->bNoProgress,
                                                      pParam->strKey.empty()         ? NULL : pParam->strKey.c_str(),
                                                      pParam->strDescription.empty() ? NULL : pParam->strDescription.c_str());
    if (!pParam->bNoProgress) {
        CoUninitialize();
    }
    delete pParam;
    return bSuccess;
}


BOOL CUpload::AddMatchingInfoInternal(
    HWND hwndParent,
    LPCWSTR pszCommand,
    DWORD   dwFilter,
    BOOL    bNoProgress,
    LPCTSTR pszKey,
    LPCTSTR pszDescription)
{
    CComBSTR bstrPath;
    CComBSTR bstrGrabmiFile;
    BOOL bSuccess = FALSE;

    IProgressDialog * ppd = NULL;
    HRESULT hr;
    GMEPARAMS GrabmiParams;
    MFI     MatchingFileInfo;
    wstring strKey;

    UINT   DriveType;
    BOOL   bLeaf = NULL;
    BOOL   bRoot = NULL;
    DWORD   dwFilters[3];
    wstring Paths[3];
    int    nDrive;
    DWORD  nPasses = 1;
    wstring DriveRoot(TEXT("X:\\"));

    //
    // this is kinda dangerous, the way it works. We collect the info while yielding to the
    // creating process (due to the start dialog
    // so the calling window needs to be disabled -- or we need to trap doing something else
    // while we're collecting data
    //


    if (!::GetExePathFromObject(pszCommand, bstrPath)) {
        return FALSE;
    }

    //
    // bstrPath is exe path, create and grab matching info
    //

    if (!GetTempFile(TEXT("ACG"), bstrGrabmiFile)) {
        goto cleanup;
    }

    //
    // we are going to run grabmi!!!
    //

    //
    // prepare callback
    //

    if (!bNoProgress) {
        hr = CoCreateInstance(CLSID_ProgressDialog,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IProgressDialog,
                              (void **)&ppd);
        if (!SUCCEEDED(hr)) {
            ppd = NULL;
        }
    }


    //
    // check to see what happened to hr
    //
    if (ppd) {
        wstring strCaption;

        strCaption = LoadResourceString(IDS_COLLECTINGDATACAPTION);
        ppd->SetTitle(strCaption.c_str());                        // Set the title of the dialog.

        ppd->SetAnimation (_Module.GetModuleInstance(), IDA_FINDANIM); // Set the animation to play.

        strCaption = LoadResourceString(IDS_WAITCLEANUP);
        ppd->SetCancelMsg (strCaption.c_str(), NULL);   // Will only be displayed if Cancel

        strCaption = LoadResourceString(IDS_GRABMISTATUS_COLLECTING);
        ppd->SetLine(1, strCaption.c_str(), FALSE, NULL);

        ppd->StartProgressDialog(hwndParent,
                                 NULL,
                                 PROGDLG_NOPROGRESSBAR|
                                    PROGDLG_MODAL|
                                    PROGDLG_NOMINIMIZE|
                                    PROGDLG_NORMAL|
                                    PROGDLG_NOTIME,
                                 NULL); // Display and enable automatic estimated time remain
    }

    //
    // this is where we have to determine whether grabmi is a going to be running wild
    // Check the drive first to see whether it's removable media
    // cases : leaf node / root node
    //       : system directory
    //       : cd-rom
    //       : temp directory
    // there could be many combinations
    //

    if (ppd) {
        wstring strCaption = LoadResourceString(IDS_CHECKING_FILES);
        ppd->SetLine(2, strCaption.c_str(), FALSE, NULL);
    }

    //
    // this is the default filter we shall use
    //
    dwFilters[0] = GRABMI_FILTER_PRIVACY;
    Paths    [0] = bstrPath;
    nPasses      = 1;

    //
    // determine if it's root/leaf node (could be both)
    //
    if (!CheckFileLocation(bstrPath, &bRoot, &bLeaf)) {
        // we cannot check the file's location
        goto GrabInformation;
    }

    DriveType = GetDriveTypeW(bstrPath); // this will give us *some* clue

    // rules:
    // cdrom and not root -- three passes
    // root - add current file
    //

    if (bRoot || DRIVE_REMOTE == DriveType) {

        dwFilters[0] |= GRABMI_FILTER_LIMITFILES;

    } else if (DRIVE_CDROM == DriveType) {

        nDrive = PathGetDriveNumber(bstrPath);
        if (nDrive >= 0) {
            dwFilters[0] |= GRABMI_FILTER_NOCLOSE|GRABMI_FILTER_APPEND;

            dwFilters[1] = GRABMI_FILTER_NORECURSE|GRABMI_FILTER_APPEND;
            Paths    [1] = DriveRoot;
            Paths    [1].at(0) = (WCHAR)(TEXT('A') + nDrive);
            nPasses = 2;
        }

    }

    if (bLeaf) {
        // we may want to do more here -- future dev
        ;
    }


GrabInformation:


    //
    // set callback context
    //
    GrabmiParams.first  = this;
    GrabmiParams.second = ppd;

    while (nPasses-- > 0) {

        if (SdbGrabMatchingInfoEx(Paths[nPasses].c_str(),
                                  dwFilters[nPasses],
                                  bstrGrabmiFile,
                                  _GrabmiCallback,
                                  (LPVOID)&GrabmiParams) == GMI_FAILED) {
            goto cleanup;
        }
    }


    //
    // figure out the key/description
    //

    if (pszDescription) {
        MatchingFileInfo.strDescription = pszDescription;
    }

    MatchingFileInfo.strFileName    = bstrGrabmiFile;
    MatchingFileInfo.bOwn           = TRUE; // we have generated this file
    //
    // key
    //

    if (pszKey == NULL) {
        strKey = MatchingFileInfo.strFileName;
    } else {
        strKey = pszKey;
    }
    StrUpCase(strKey);

    m_DataFiles[strKey] = MatchingFileInfo;

    // m_DataFiles.push_back(StrUpCase(wstring(bstrGrabmiFile)));

    //
    //
    //
    bSuccess = TRUE;

cleanup:
    if (ppd) {
        ppd->StopProgressDialog();
        ppd->Release();
    }

    return bSuccess;
}

STDMETHODIMP CUpload::AddDataFile(
    BSTR pszDataFile,
    VARIANT vKey,
    VARIANT vDescription,
    VARIANT vOwn)
{
    MFI     MatchingFileInfo;
    wstring strKey = VariantToStr(CComVariant(vKey));
    BOOL    bKeyFromName = FALSE;

    if (strKey.empty()) {
        strKey = pszDataFile;
        bKeyFromName = TRUE;
    }
    StrUpCase(strKey);

    if (m_DataFiles.find(strKey) != m_DataFiles.end() && !bKeyFromName) {
        CComBSTR bstrKey = strKey.c_str();
        RemoveDataFile(bstrKey);
    }

    MatchingFileInfo.strDescription = VariantToStr(CComVariant(vDescription));
    MatchingFileInfo.strFileName    = pszDataFile;
    MatchingFileInfo.bOwn           = VariantToBOOL(CComVariant(vOwn));

    m_DataFiles[strKey] = MatchingFileInfo;

    // m_DataFiles.push_back(StrUpCase(wstring(pszDataFile)));
    return S_OK;
}


STDMETHODIMP CUpload::RemoveDataFile(BSTR pszDataFile)
{
    // STRVEC::iterator iter;
    MAPSTR2MFI::iterator iter;
    wstring strFileName;

    wstring strDataFile = pszDataFile;

    StrUpCase(strDataFile);

    iter = m_DataFiles.find(strDataFile);
    if (iter != m_DataFiles.end()) {
        if ((*iter).second.bOwn) {
            ::DeleteFile((*iter).second.strFileName.c_str());
        }

        m_DataFiles.erase(iter);
    }

/*
    for (iter = m_DataFiles.begin(); iter != m_DataFiles.end(); ++iter) {
        if (*iter == strDataFile) {
            //
            // found it
            //
            m_DataFiles.erase(iter);
            break;
        }
    }
*/
    return S_OK;
}

STDMETHODIMP CUpload::CreateManifestFile(BOOL *pbSuccess)
{
    //
    // manifest file creation code
    //
    HANDLE hFile = INVALID_HANDLE_VALUE;
    WCHAR  UNICODE_MARKER[] = { (WCHAR)0xFEFF, L'\r', L'\n' };
    MAPSTR2STR::iterator iter;
    DWORD  dwWritten;
    wstring strLine;
    CComBSTR bstrDataFiles;
    BOOL bResult;
    BOOL bSuccess = FALSE;

    if (!GetTempFile(TEXT("ACM"), m_bstrManifest)) {
        goto cleanup;
    }

    //
    // m_bstrManifest is our file
    //


    hFile = CreateFileW(m_bstrManifest,
                        GENERIC_READ|GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        goto cleanup;
    }

    bResult = WriteFile(hFile, UNICODE_MARKER, sizeof(UNICODE_MARKER), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }

    //
    // done with the marker, now do the manifest strings
    //
    //
    for (iter = m_mapManifest.begin(); iter != m_mapManifest.end(); ++iter) {
        strLine = (*iter).first + TEXT('=') + (*iter).second + TEXT("\r\n");
        bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
        if (!bResult) {
            goto cleanup;
        }
    }

    //
    // done with the general stuff, do the data files
    //

    if (GetDataFilesKey(bstrDataFiles)) {
        strLine = wstring(szKeyDataFiles) + TEXT('=') + wstring(bstrDataFiles) + TEXT("\r\n");
        bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
        if (!bResult) {
            goto cleanup;
        }
    }
    bSuccess = TRUE;

cleanup:

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    if (!bSuccess && m_bstrManifest.Length()) {
        DeleteFile(m_bstrManifest);
        m_bstrManifest.Empty();
    }
    *pbSuccess = bSuccess;

    return S_OK;
}

STDMETHODIMP CUpload::SendReport(BOOL *pbSuccess)
{
    UINT uSize;
    TCHAR szSystemWindowsDirectory[MAX_PATH];
    wstring strDWCmd;
    wstring strDWPath;
    STARTUPINFO         StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    DWORD dwWait;
    BOOL  bSuccess = FALSE;
    BOOL  bResult;
    DWORD dwExitCode;
    BOOL  bTerminated = FALSE;
    DWORD dwTimeout = 10; // 10ms per ping

    //
    // Create Progress dialog
    //
    IProgressDialog * ppd = NULL;
    HRESULT hr;

    if (IsHeadlessMode()) {

        hr = CoCreateInstance(CLSID_ProgressDialog,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IProgressDialog,
                              (void **)&ppd);
        if (!SUCCEEDED(hr)) {
            ppd = NULL;
        }
    }

    //
    // check to see what happened to hr
    //
    if (ppd) {
        wstring strCaption;

        strCaption = LoadResourceString(IDS_SENDINGCAPTION);
        ppd->SetTitle(strCaption.c_str());                        // Set the title of the dialog.

        ppd->SetAnimation (_Module.GetModuleInstance(), IDA_WATSONANIM); // Set the animation to play.

        strCaption = LoadResourceString(IDS_WAITCLEANUP);
        ppd->SetCancelMsg (strCaption.c_str(), NULL);   // Will only be displayed if Cancel

        strCaption = LoadResourceString(IDS_LAUNCHINGDR);
        ppd->SetLine (1, strCaption.c_str(), FALSE, NULL);

        ppd->StartProgressDialog(::GetActiveWindow(),
                                 NULL,
                                 PROGDLG_NOPROGRESSBAR|
                                    PROGDLG_MODAL|
                                    PROGDLG_NOMINIMIZE|
                                    PROGDLG_NORMAL|
                                    PROGDLG_NOTIME,
                                 NULL); // Display and enable automatic estimated time remain
    }

    uSize = ::GetSystemWindowsDirectory(szSystemWindowsDirectory,
                                        CHARCOUNT(szSystemWindowsDirectory));
    if (uSize == 0 || uSize > CHARCOUNT(szSystemWindowsDirectory)) {
        goto cleanup;
    }

    strDWPath = szSystemWindowsDirectory;
    if (strDWPath.at(strDWPath.length() - 1) != TCHAR('\\')) {
        strDWPath.append(TEXT("\\"));
    }

    strDWPath += TEXT("system32\\dwwin.exe");
    strDWCmd = strDWPath + TEXT(" -d ") + (LPCWSTR)m_bstrManifest;

    ZeroMemory(&StartupInfo, sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));

    bResult = CreateProcess(strDWPath.c_str(),
                            (LPWSTR)strDWCmd.c_str(),
                            NULL,
                            NULL,
                            FALSE,
                            0,
                            NULL,
                            NULL,
                            &StartupInfo,
                            &ProcessInfo);
    if (bResult) {
        //
        // recover an exit code please
        //
        if (ppd) {
            wstring strSending = LoadResourceString(IDS_SENDINGINFO);
            ppd->SetLine(1, strSending.c_str(), FALSE, NULL);
        }
        while(TRUE) {
            dwWait = WaitForSingleObject(ProcessInfo.hProcess, dwTimeout);
            if (dwWait == WAIT_OBJECT_0) {
                if (GetExitCodeProcess(ProcessInfo.hProcess, &dwExitCode)) {
                    bSuccess = (dwExitCode == 0);
                } else {
                    bSuccess = FALSE;
                }
                break;

            } else if (dwWait == WAIT_TIMEOUT) {

                //
                // check the cancel button
                //

                if (ppd && !bTerminated && ppd->HasUserCancelled()) {
                    TerminateProcess(ProcessInfo.hProcess, (UINT)-1);
                    bTerminated = TRUE;
                    bSuccess = FALSE;
                    dwTimeout = 1000; // wait a bit longer
                }

            } else { // object somehow became abandoned
                bSuccess = FALSE;
                break;
            }
        }

    }

    if (ppd) {
        wstring strCleaningUp = LoadResourceString(IDS_CLEANINGUP);
        ppd->SetLine(1, strCleaningUp.c_str(), FALSE, NULL);
    }


cleanup:


    if (ProcessInfo.hThread) {
        CloseHandle(ProcessInfo.hThread);
    }
    if (ProcessInfo.hProcess) {
        CloseHandle(ProcessInfo.hProcess);
    }

    if (ppd) {
        ppd->StopProgressDialog();
        ppd->Release();
    }

    *pbSuccess = bSuccess;

    return S_OK;
}

wstring MakeXMLAttr(LPCTSTR lpszName, LPCTSTR lpszValue)
{
    wstring str;
    wstring strVal;
    LPCTSTR pch;
    wstring::size_type nPos = 0;
    int     nlen;

    if (NULL != lpszValue) {
        strVal = lpszValue;
    }

    // find and replace: all the instances of &quot; &amp; &lt; &gt;
    //
    while (nPos != wstring::npos && nPos < strVal.length()) {

        nPos = strVal.find_first_of(TEXT("&\"<>"), nPos);
        if (nPos == wstring::npos) {
            break;
        }

        switch(strVal.at(nPos)) {
        case TEXT('&'):
            pch = TEXT("&amp;");
            break;

        case TEXT('>'):
            pch = TEXT("&gt;");
            break;

        case TEXT('<'):
            pch = TEXT("&lt;");
            break;

        case TEXT('\"'):
            pch = TEXT("&quot;");
            break;
        default:
            // lunacy, we saw it -- and now it's gone
            pch = NULL;
            break;
        }

        if (pch) {
            strVal.replace(nPos, 1, pch); // one character
            nPos += _tcslen(pch);
        }
    }

    // once we got the string, assign
    str = lpszName;
    str += TEXT("=\"");
    str += strVal;
    str += TEXT("\"");

    return str;
}

wstring MakeXMLAttr(LPCTSTR lpszName, LONG lValue)
{
    WCHAR szBuf[32];
    wstring str;

    swprintf(szBuf, TEXT("\"0x%lx\""), lValue);

    str = lpszName;
    str += TEXT("=");
    str += szBuf;
    return str;
}

wstring MakeXMLLayers(LPCTSTR lpszLayers)
{
    wstring str;
    wstring strLayer;
    LPCTSTR pch, pbrk;

    //
    // partition the string
    //
    pch = lpszLayers;

    while (pch && *pch != TEXT('\0')) {

        pch += _tcsspn(pch, TEXT(" \t"));

        // check if we're not at the end
        if (*pch == TEXT('\0')) {
            break;
        }

        pbrk = _tcspbrk(pch, TEXT(" \t"));
        if (pbrk == NULL) {
            // from pch to the end of the string
            strLayer.assign(pch);
        } else {
            strLayer.assign(pch, (int)(pbrk-pch));
        }

        if (!str.empty()) {
            str += TEXT("\r\n");
        }
        str += TEXT("    "); // lead-in
        str += TEXT("<LAYER NAME=\"");
        str += strLayer;
        str += TEXT("\"/>");

        pch = pbrk;
    }

    return str;
}



STDMETHODIMP CUpload::AddDescriptionFile(
    BSTR     pszApplicationName,
    BSTR     pszApplicationPath,
    LONG     lMediaType,
    BOOL     bCompatSuccess,
    VARIANT* pvFixesApplied,
    VARIANT  vKey,
    BOOL     *pbSuccess
    )
{

    //
    // manifest file creation code
    //
    HANDLE   hFile = INVALID_HANDLE_VALUE;
    WCHAR    UNICODE_MARKER[] = { (WCHAR)0xFEFF, L'\r', L'\n' };
    DWORD    dwWritten;
    wstring  strLine;
    CComBSTR bstrDescriptionFile;
    BOOL     bResult;
    BOOL     bSuccess = FALSE;
    WCHAR    szBuf[32];
    VARIANT  vFixes;
    MFI      MatchingFileInfo;
    wstring  strKey = VariantToStr(CComVariant(vKey));
    wstring  strLayers;
    static   TCHAR szTab[] = TEXT("    ");
    static   TCHAR szCRTab[] = TEXT("\r\n    ");
    VariantInit(&vFixes);

    if (!GetTempFile(TEXT("ACI"), bstrDescriptionFile)) {
        goto cleanup;
    }

    //
    // m_bstrManifest is our file
    //


    hFile = CreateFileW(bstrDescriptionFile,
                        GENERIC_READ|GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        goto cleanup;
    }

    bResult = WriteFile(hFile, UNICODE_MARKER, sizeof(UNICODE_MARKER), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }


    // xml marker
    strLine = TEXT("<?xml version=\"1.0\" encoding=\"UTF-16\"?>\r\n");
    bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }

    // compose compat wizard...
    strLine = TEXT("<CompatWizardResults");
    strLine += TEXT(' ');
    strLine += MakeXMLAttr(TEXT("ApplicationName"), pszApplicationName);
    strLine += szCRTab;
    strLine += MakeXMLAttr(TEXT("ApplicationPath"), pszApplicationPath);
    strLine += szCRTab;
    strLine += MakeXMLAttr(TEXT("MediaType"), lMediaType);
    strLine += szCRTab;
    strLine += MakeXMLAttr(TEXT("CompatibilityResult"), bCompatSuccess ? TEXT("Success") : TEXT("Failure"));
    strLine += TEXT(">\r\n");

    if (SUCCEEDED(VariantChangeType(&vFixes, pvFixesApplied, 0, VT_BSTR))) {
        strLayers = vFixes.bstrVal;
    }

    if (!strLayers.empty()) {
        //
        // parse the layers string and get all of them listed
        //
        strLine += MakeXMLLayers(strLayers.c_str());
        strLine += TEXT("\r\n");
    }

    strLine += TEXT("</CompatWizardResults>\r\n");

    // we are done generating data, write it all out
    bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }


/*

    //
    // after we get through the descriptions
    // write out data
    strLine = TEXT("[CompatWizardResults]\r\n");
    bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }

    //
    // write out all the info
    //
    strLine =  TEXT("ApplicationName=");
    strLine += pszApplicationName;
    strLine += TEXT("\r\n");
    bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }

    strLine =  TEXT("ApplicationPath=");
    strLine += pszApplicationPath;
    strLine += TEXT("\r\n");
    bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }

    strLine =  TEXT("MediaType=");
    _sntprintf(szBuf, CHARCOUNT(szBuf), TEXT("0x%lx"), lMediaType);
    strLine += szBuf;
    strLine += TEXT("\r\n");
    bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }

    //
    // success
    //
    strLine = TEXT("CompatibilityResult=");
    strLine += bCompatSuccess ? TEXT("Success") : TEXT("Failure");
    strLine += TEXT("\r\n");
    bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }

    //
    // fixes applied
    //
    strLine = TEXT("Layers=");
    if (!SUCCEEDED(VariantChangeType(&vFixes, pvFixesApplied, 0, VT_BSTR))) {
        strLine += TEXT("none");
    } else {
        strLine += vFixes.bstrVal;
    }
    strLine += TEXT("\r\n");
    bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }
*/



    // standard file -- manifesto
    MatchingFileInfo.strDescription = TEXT("Application Compatibility Description File");
    MatchingFileInfo.strFileName    = bstrDescriptionFile;
    MatchingFileInfo.bOwn           = TRUE;

    //
    // key is the filename prefixed by ACI_c:\foo\bar.exe
    //
    if (strKey.empty()) {
        strKey = TEXT("ACI_");
        strKey += pszApplicationPath;
    }
    StrUpCase(strKey);

    m_DataFiles[strKey] = MatchingFileInfo;

    // m_DataFiles.push_back(StrUpCase(wstring(bstrDescriptionFile)));
    bSuccess = TRUE;

cleanup:

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    if (!bSuccess && bstrDescriptionFile.Length()) {
        DeleteFile(bstrDescriptionFile);
    }
    *pbSuccess = bSuccess;

    VariantClear(&vFixes);

    return S_OK;
}

STDMETHODIMP CUpload::DeleteTempFiles()
{
    // kill all the supplemental files

    // STRVEC::iterator iter;
    MAPSTR2MFI::iterator iter;

    for (iter = m_DataFiles.begin(); iter != m_DataFiles.end(); ++iter) {
        if ((*iter).second.bOwn) {
            ::DeleteFile((*iter).second.strFileName.c_str());
        }
    }

    m_DataFiles.clear();

    //
    // kill the manifest
    //
    if (m_bstrManifest.Length() > 0) {
        ::DeleteFile((LPCTSTR)m_bstrManifest);
    }
    m_bstrManifest.Empty();

    return S_OK;
}

VOID CUpload::ListTempFiles(wstring& str)
{
//    STRVEC::iterator iter;
    MAPSTR2MFI::iterator iter;

    str = TEXT("");

    for (iter = m_DataFiles.begin(); iter != m_DataFiles.end(); ++iter) {
        if (!str.empty()) {
            str += TEXT(";");
        }
        str += (*iter).second.strFileName.c_str();
    }

/*  // this will show the manifest file as well -- but I don't think we need to
    // do this as the manifest is irrelevant
    if (!str.empty()) {
        str += TEXT("\r\n");
    }
    str += (LPCTSTR)m_bstrManifest;
*/
}

STDMETHODIMP CUpload::ShowTempFiles()
{
    TCHAR szMshtml[] = TEXT("mshtml.dll");
    TCHAR szModuleFileName[MAX_PATH];
    LPMONIKER pmk = NULL;
    HRESULT hr;
    CComVariant vargIn;
    CComVariant vargOut;
    DWORD dwLength;
    TCHAR szUrl2[MAX_PATH];
    wstring strURL = TEXT("res://");
    wstring strArg;
    SHOWHTMLDIALOGFN* pfnShowDlg = NULL;

    HMODULE hMshtml = ::GetModuleHandle(szMshtml);
    if (NULL == hMshtml) {
        hMshtml = ::LoadLibrary(szMshtml);
        if (NULL == hMshtml) {
            goto cleanup;
        }
    }

    pfnShowDlg = (SHOWHTMLDIALOGFN*)GetProcAddress(hMshtml,
                                                   "ShowHTMLDialog");

    if (NULL == pfnShowDlg) {
        goto cleanup;
    }

    dwLength = ::GetModuleFileName(_Module.GetModuleInstance(),
                                   szModuleFileName,
                                   CHARCOUNT(szModuleFileName));

    if (dwLength == 0 || dwLength >= CHARCOUNT(szModuleFileName)) {
        goto cleanup;
    }


    _sntprintf(szUrl2, CHARCOUNT(szUrl2),
               TEXT("/#%d/%s"),
               (int)PtrToInt(RT_HTML),
               IDR_SHOWTEMPFILESDLG);

    strURL += szModuleFileName;
    strURL += szUrl2;

    hr = CreateURLMoniker(NULL, strURL.c_str(), &pmk);

    if (!SUCCEEDED(hr)) {
        goto cleanup;
    }

    ListTempFiles(strArg);
    // create argument In
    vargIn = strArg.c_str();

    pfnShowDlg(::GetActiveWindow(),
               pmk,
               &vargIn,
               TEXT("center:yes"),
               &vargOut);

cleanup:

    if (NULL != pmk) {
        pmk->Release();
    }

    return S_OK;
}

STDMETHODIMP CUpload::GetDataFile(VARIANT vKey, LONG InformationClass, VARIANT* pVal)
{
    CComVariant varKey(vKey);
    LONG lIndex;
    MAPSTR2MFI::iterator iter;
    wstring str;
    HRESULT hr = S_OK;

    pVal->vt = VT_NULL;

    switch(InformationClass) {
    case InfoClassCount:
        // requested: counter
        pVal->vt = VT_I4;
        pVal->lVal = m_DataFiles.size();
        break;

    case InfoClassKey:

        if (!SUCCEEDED(varKey.ChangeType(VT_I4))) {
            break;
        }
        lIndex = varKey.lVal;
        iter = m_DataFiles.begin();
        while (iter != m_DataFiles.end() && lIndex > 0) {
            ++iter;
            --lIndex;
        }

        if (iter != m_DataFiles.end()) {
            hr = StringToVariant(pVal, (*iter).first);
        }
        break;

    case InfoClassFileName:
    case InfoClassDescription:

        if (SUCCEEDED(varKey.ChangeType(VT_I4))) {
            lIndex = varKey.lVal;
            iter = m_DataFiles.begin();
            while (iter != m_DataFiles.end() && lIndex > 0) {
                ++iter;
                --lIndex;
            }

        } else if (SUCCEEDED(varKey.ChangeType(VT_BSTR))) {
            str = varKey.bstrVal;
            iter = m_DataFiles.find(str);
        }

        if (iter != m_DataFiles.end()) {
            switch(InformationClass) {
            case InfoClassFileName:
                str = (*iter).second.strFileName;
                break;

            case InfoClassDescription:
                str = (*iter).second.strDescription;
                break;
            }

            hr = StringToVariant(pVal, str);

        }
        break;
    default:
        break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\compatui\uploadfiles.h ===
// CUploadFiles.h : Declaration of the CCUploadFiles

#ifndef __CUPLOADFILES_H_
#define __CUPLOADFILES_H_

#include "resource.h"       // main symbols
#include <atlhost.h>
#include "CompatUI.h"
#include "upload.h"

/////////////////////////////////////////////////////////////////////////////
// CCUploadFiles
class CUploadFiles : 
    public CAxDialogImpl<CUploadFiles>
{
public:
    CUploadFiles() : m_pUpload(NULL)
    {
    }

    ~CUploadFiles()
    {
    }

    VOID SetUploadContext(CUpload* pUpload) {
        m_pUpload = pUpload;
    }


    enum { IDD = IDD_UPLOADFILES };

BEGIN_MSG_MAP(CUploadFiles)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    COMMAND_ID_HANDLER(IDOK, OnOK)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        //
        // init text control please
        //
        
        wstring strList;
        
        m_pUpload->ListTempFiles(strList);
        SetDlgItemText(IDC_UPLOADFILES, strList.c_str());
    
        return 1;  // Let the system set the focus
    }

    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        EndDialog(wID);
        return 0;
    }

    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        EndDialog(wID);
        return 0;
    }

private:
    CUpload* m_pUpload;
};

#endif //__CUPLOADFILES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\compatui\upload.h ===
// Upload.h : Declaration of the CUpload

#ifndef __UPLOAD_H_
#define __UPLOAD_H_

#include "resource.h"       // main symbols

#pragma warning(disable:4786)
#include <string>
#include <xstring>
#include <map>
#include <locale>
#include <algorithm>
#include <vector>
using namespace std;


/////////////////////////////////////////////////////////////////////////////
// CUpload
class ATL_NO_VTABLE CUpload : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CUpload, &CLSID_Upload>,
    public IDispatchImpl<IUpload, &IID_IUpload, &LIBID_COMPATUILib>
{
public:
    CUpload() 
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_UPLOAD)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CUpload)
    COM_INTERFACE_ENTRY(IUpload)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IUpload
public:
    STDMETHOD(ShowTempFiles)();
    STDMETHOD(DeleteTempFiles)();
    STDMETHOD(AddDescriptionFile)(
            /*[in]*/BSTR pszApplicationName, 
            /*[in]*/BSTR pszApplicationPath, 
            /*[in]*/LONG lMediaType, 
            /*[in]*/BOOL bCompatSuccess, 
            /*[in]*/VARIANT* pvFixesApplied, 
            /*[in]*/VARIANT pszKey, 
            /*[out, retval]*/BOOL* pbSuccess);
    STDMETHOD(SendReport)(/*[out, retval]*/BOOL* pbSuccess);
    STDMETHOD(CreateManifestFile)(/*[out, retval]*/BOOL *pbSuccess);
    STDMETHOD(RemoveDataFile)(/*[in]*/BSTR pszDataFile);
    STDMETHOD(AddDataFile)(
            /*[in]*/BSTR pszDataFile, 
            /*[in]*/VARIANT vKey, 
            /*[in]*/VARIANT vDescription,
            /*[in]*/VARIANT vOwn);
    STDMETHOD(AddMatchingInfo)(
            /*[in]*/BSTR pszCommand, 
            /*[in]*/VARIANT vFilter,
            /*[in]*/VARIANT vKey, 
            /*[in]*/VARIANT vDescription, 
            /*[in]*/VARIANT vProgress,
            /*[out, retval]*/BOOL* pbSuccess);
    STDMETHOD(GetKey)(/*[in]*/BSTR pszKey, /*[out, retval]*/VARIANT* pszValue);
    STDMETHOD(SetKey)(/*[in]*/BSTR pszKey, /*[in]*/VARIANT* pvValue);
    STDMETHOD(GetDataFile)(/*[in]*/VARIANT vKey, /*[in]*/LONG InformationClass, /*[out, retval]*/VARIANT* pVal);


protected:
    //
    // map for the items, unique
    //

    VOID ListTempFiles(wstring& str);

    typedef map<wstring, wstring, less<wstring> > MAPSTR2STR;
    MAPSTR2STR m_mapManifest;


    //
    // data files collection in an embedded object
    //
    typedef struct tagMatchingFileInfo {
        wstring strDescription; // description of a matching file
        wstring strFileName;    // filename
        BOOL    bOwn;           // do we own the file?
    } MFI, *PMFI;


    typedef map<wstring, MFI > MAPSTR2MFI;
    MAPSTR2MFI m_DataFiles;
       
    
    
/*
    typedef vector<wstring> STRVEC;
    
    STRVEC m_DataFiles;
*/

    CComBSTR m_bstrManifest;

    BOOL GetDataFilesKey(CComBSTR& bstrVal);

    IProgressDialog* m_ppd; 
    static BOOL CALLBACK _GrabmiCallback(
        LPVOID    lpvCallbackParam, // application-defined parameter
        LPCTSTR   lpszRoot,         // root directory path
        LPCTSTR   lpszRelative,     // relative path
        PATTRINFO pAttrInfo,        // attributes
        LPCWSTR   pwszXML           // resulting xml
        );         
    
    BOOL IsHeadlessMode(void); 

    typedef struct tagMIThreadParamBlock {
        CUpload* pThis;
        wstring  strCommand;
        HWND     hwndParent;
        DWORD    dwFilter;
        BOOL     bNoProgress;
        wstring  strKey;
        wstring  strDescription;
    } MITHREADPARAMBLK;

    typedef enum tagDATAFILESINFOCLASS {
        InfoClassCount = 0,
        InfoClassKey = 1,
        InfoClassFileName = 2,
        InfoClassDescription = 3
    } DATAFILESINFOCLASS;

    typedef pair<CUpload*, IProgressDialog*> GMEPARAMS;

    static DWORD WINAPI _AddMatchingInfoThreadProc(LPVOID lpvThis);
    BOOL AddMatchingInfoInternal(HWND hwndParent, 
                                 LPCWSTR pszCommand,
                                 DWORD   dwFilter,
                                 BOOL    bNoProgress,
                                 LPCWSTR pszKey,
                                 LPCWSTR pszDescription);

    
};



#endif //__UPLOAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\compatui\uploadfiles.cpp ===
// CUploadFiles.cpp : Implementation of CCUploadFiles
#include "stdafx.h"
#include "CompatUI.h"
#include "shlobj.h"
extern "C" {
    #include "shimdb.h"
}

#include "Upload.h"
#include "Uploadfiles.h"

/////////////////////////////////////////////////////////////////////////////
// CCUploadFiles
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\compatui\util.cpp ===
// Util.cpp : Implementation of CUtil
#include "stdafx.h"
#include "CompatUI.h"
#include "Util.h"
#include <shlobj.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <msi.h>
#include <sfc.h>
#include "Aclapi.h"

extern "C" {
#include "shimdb.h"
}

#pragma warning(disable:4786)
#include <string>
#include <xstring>
#include <map>
#include <locale>
#include <algorithm>
#include <vector>
using namespace std;

/////////////////////////////////////////////////////////////////////////////
// CUtil
extern "C"
VOID
InvalidateAppcompatCacheEntry(
    LPCWSTR pwszDosPath
    );

BOOL
GetExePathFromObject(
    LPCTSTR lpszPath,  // path to an arbitrary object
    CComBSTR& bstrExePath
    );


    typedef
    INSTALLSTATE (WINAPI*PMsiGetComponentPath)(
      LPCTSTR szProduct,   // product code for client product
      LPCTSTR szComponent, // component ID
      LPTSTR lpPathBuf,    // returned path
      DWORD *pcchBuf       // buffer character count
    );

    typedef
    UINT (WINAPI* PMsiGetShortcutTarget)(
      LPCTSTR szShortcutTarget,     // path to shortcut link file
      LPTSTR szProductCode,        // fixed length buffer for product code
      LPTSTR szFeatureId,          // fixed length buffer for feature id
      LPTSTR szComponentCode       // fixed length buffer for component code
    );

BOOL
IsUserAdmin(
    void
    );

BOOL
GiveUsersWriteAccess(
    void
    );

BOOL
IsLUAEnabled(
    LPCWSTR pszLayers
    );

wstring
StrUpCase(
    wstring& wstr
    );

BOOL
ShimExpandEnvironmentVars(
    LPCTSTR lpszCmd,
    CComBSTR& bstr
    )
{
    DWORD dwLength;
    LPTSTR lpBuffer = NULL;
    BOOL   bExpanded = FALSE;
    if (_tcschr(lpszCmd, TEXT('%')) == NULL) {
        goto out;
    }

    dwLength = ExpandEnvironmentStrings(lpszCmd, NULL, 0);
    if (!dwLength) {
        goto out;
    }

    lpBuffer = new TCHAR[dwLength];
    if (NULL == lpBuffer) {
        goto out;
    }

    dwLength = ExpandEnvironmentStrings(lpszCmd, lpBuffer, dwLength);
    if (!dwLength) {
        goto out;
    }
    bstr = lpBuffer;
    bExpanded = TRUE;

 out:
    if (!bExpanded) {
        bstr = lpszCmd;
    }
    if (lpBuffer) {
        delete[] lpBuffer;
    }
    return bExpanded;
}

wstring
ShimUnquotePath(
    LPCTSTR pwszFileName
    )
{
    wstring sFileName;
    LPCTSTR pScan = pwszFileName;
    LPCTSTR pQuote;
    LPCTSTR pLastQuote = NULL;

    // skip over the leading spaces
    pScan += _tcsspn(pScan, TEXT(" \t"));
    while (*pScan) {
        pQuote = _tcschr(pScan, TEXT('\"'));
        if (NULL == pQuote) {
            sFileName += pScan;
            break;
        }
        //
        // we found a quote
        // is this the first quote we've found?
        if (pLastQuote == NULL) {
            pLastQuote = pQuote;
            // add the current string
            sFileName += wstring(pScan, (int)(pQuote-pScan));
        } else {
            // we have a closing quote
            ++pLastQuote;
            sFileName += wstring(pLastQuote, (int)(pQuote-pLastQuote));
            pLastQuote = NULL;
        }

        pScan = pQuote + 1;

    }

    return sFileName;
}

//
// ShimGetPathFromCmdLine
//

BOOL
ShimGetPathFromCmdLine(
    LPCTSTR pwszCmdLine,
    CComBSTR& StrPath
    )
{
    TCHAR chSave;
    LPTSTR pScan = (LPTSTR)pwszCmdLine;
    LPTSTR pAppName;
    TCHAR  szBuffer[MAX_PATH];
    DWORD  dwLength;
    DWORD  dwAttributes;
    BOOL   bScan = FALSE;
    CComBSTR bstrPathName;

    if (*pScan == TEXT('\"')) {
        // seek till we find matching "
        pAppName = ++pScan;
        while (*pScan) {
            if (*pScan == TEXT('\"')) {
                break;
            }
            ++pScan;
        }
    } else {
        pAppName = pScan;
        while (*pScan) {
            if (_istspace(*pScan)) {
                bScan = TRUE;
                break;
            }
            ++pScan;
        }
    }

    while (TRUE) {

        chSave = *pScan;
        *pScan = TEXT('\0');

        ShimExpandEnvironmentVars(pAppName, bstrPathName);

        //
        // Check this path
        //
        dwLength = SearchPathW(NULL,
                               bstrPathName,
                               TEXT(".exe"),
                               CHARCOUNT(szBuffer),
                               szBuffer,
                               NULL);
        //
        // restore the character
        //
        *pScan = chSave;

        if (dwLength && dwLength < CHARCOUNT(szBuffer)) {
            //
            // check attributes
            //
            dwAttributes = GetFileAttributesW(szBuffer);
            if ((dwAttributes != (DWORD)-1) &&
                !(dwAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                //
                // we are mighty done
                //
                StrPath = (LPCWSTR)szBuffer;
                return TRUE;
            }
        }

        if (!bScan || *pScan == TEXT('\0')) {
            break;
        }

        ++pScan;
        while (*pScan) {
           if (_istspace(*pScan)) {
               break;
           }
           ++pScan;
        }

    }


    return FALSE;
}

//
// This class allows us to change error mode on selected apis
//
//

class CSaveErrorMode {
public:
    CSaveErrorMode() {
        m_uiErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    }
    ~CSaveErrorMode() {
        SetErrorMode(m_uiErrorMode);
    }
protected:
    UINT m_uiErrorMode;
};


STDMETHODIMP CUtil::IsCompatWizardDisabled(BOOL* pbDisabled)
{
    *pbDisabled = FALSE;

    return S_OK;
}

STDMETHODIMP CUtil::RemoveArgs(BSTR pVar, VARIANT* pRet)
{
    // TODO: Add your implementation code here
    CComBSTR bstr;
    CSaveErrorMode ErrMode;

    if (!ShimGetPathFromCmdLine(pVar, bstr)) {
        bstr = pVar;
    }

    pRet->vt = VT_BSTR;
    pRet->bstrVal = bstr.Copy();

    return S_OK;
}

STDMETHODIMP CUtil::GetItemKeys(BSTR pVar, VARIANT *pRet)
{
    CComBSTR bstr = pVar;
    CComBSTR bstrOut;
    LPWSTR   pwszPermKeys;
    DWORD    cbSize;
    BOOL     bLayers;


    bLayers = SdbGetPermLayerKeys(bstr, NULL, &cbSize, GPLK_USER);
    if (bLayers) {
        pwszPermKeys = new WCHAR[cbSize / sizeof(WCHAR)];
        bLayers = SdbGetPermLayerKeys(bstr, pwszPermKeys, &cbSize, GPLK_USER);
        if (bLayers) {
            bstrOut = pwszPermKeys;
        }
        delete [] pwszPermKeys;
    }

    if (!bstrOut) {
        pRet->vt = VT_NULL;
    } else {
        pRet->vt = VT_BSTR;
        pRet->bstrVal = bstrOut.Copy();
    }

    return S_OK;
}


STDMETHODIMP CUtil::SetItemKeys(BSTR pszPath, VARIANT* pKeys, BOOL *pVal)
{
    // TODO: Add your implementation code here
    CComBSTR bstrKeys;
    CComBSTR bstrKeysMachine;
    BOOL     bSuccess = TRUE;
    VARIANT  varKeys;
    VARIANT  varKeysMachine;

    InvalidateAppcompatCacheEntry(pszPath);

    if (pKeys->vt == VT_NULL || pKeys->vt == VT_EMPTY) {
        bSuccess &= SdbDeletePermLayerKeys(pszPath, FALSE);
    } else {
        VariantInit(&varKeys);
        if (SUCCEEDED(VariantChangeType(&varKeys, pKeys, 0, VT_BSTR))) {
            bstrKeys = varKeys.bstrVal;
            VariantClear(&varKeys);
        }

        if (bstrKeys) {
            bSuccess &= SdbSetPermLayerKeys(pszPath, bstrKeys, FALSE);
        }
    }

    *pVal = bSuccess;

    return S_OK;
}

BOOL
SearchGroupForSID(
    DWORD dwGroup,
    BOOL* pfIsMember
    )
{
    PSID                     pSID = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL                     fRes = TRUE;

    if (!AllocateAndInitializeSid(&SIDAuth,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  dwGroup,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  &pSID)) {
        ATLTRACE(_T("[SearchGroupForSID] AllocateAndInitializeSid failed 0x%lx\n"),
                 GetLastError());

        return FALSE;
    }

    if (!CheckTokenMembership(NULL, pSID, pfIsMember)) {
        ATLTRACE(_T("[SearchGroupForSID] CheckTokenMembership failed 0x%x\n"),
                 GetLastError());
        fRes = FALSE;
    }

    FreeSid(pSID);

    return fRes;
}

BOOL
IsUserAdmin(
    void
    )
{
    BOOL fIsUser, fIsAdmin, fIsPowerUser;

    if (!SearchGroupForSID(DOMAIN_ALIAS_RID_USERS, &fIsUser) ||
        !SearchGroupForSID(DOMAIN_ALIAS_RID_ADMINS, &fIsAdmin)) {
        return FALSE;
    }

    return (fIsUser && fIsAdmin);
}

#if 0

BOOL
GiveUsersWriteAccess(
    void
    )
{
    DWORD                    dwRes;
    PACL                     pOldDACL;
    PACL                     pNewDACL = NULL;
    SECURITY_DESCRIPTOR      sd;
    PSECURITY_DESCRIPTOR     pSD = &sd;
    GUID                     guidChildObjectType;   // GUID of object to control creation of
    PSID                     pTrusteeSID;           // trustee for new ACE
    EXPLICIT_ACCESS          ea;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    PSID                     pUsersSID = NULL;
    TCHAR                    szDir[MAX_PATH];

    ExpandEnvironmentStrings(LUA_REDIR_W, szDir, MAX_PATH);

    if (!CreateDirectory(szDir, NULL)) {
        DWORD err = GetLastError();

        if (GetLastError() != ERROR_ALREADY_EXISTS) {
            return FALSE;
        }
    }

    dwRes = GetNamedSecurityInfo(szDir,
                                 SE_FILE_OBJECT,
                                 DACL_SECURITY_INFORMATION,
                                 NULL,
                                 NULL,
                                 &pOldDACL,
                                 NULL,
                                 &pSD);

    if (ERROR_SUCCESS != dwRes) {
        goto Cleanup;
    }

    if (!AllocateAndInitializeSid(&SIDAuth,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_USERS,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  &pUsersSID) ) {
        goto Cleanup;
    }

    //
    // Initialize an EXPLICIT_ACCESS structure for the new ACE.
    //
    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
    ea.grfAccessPermissions = FILE_ALL_ACCESS;
    ea.grfAccessMode        = GRANT_ACCESS;
    ea.grfInheritance       = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea.Trustee.TrusteeForm  = TRUSTEE_IS_SID;
    ea.Trustee.TrusteeType  = TRUSTEE_IS_GROUP;
    ea.Trustee.ptstrName    = (LPTSTR)pUsersSID;

    //
    // Create a new ACL that merges the new ACE
    // into the existing DACL.
    //
    dwRes = SetEntriesInAcl(1, &ea, pOldDACL, &pNewDACL);

    if (ERROR_SUCCESS != dwRes)  {
        goto Cleanup;
    }

    dwRes = SetNamedSecurityInfo(szDir,
                                 SE_FILE_OBJECT,
                                 DACL_SECURITY_INFORMATION,
                                 NULL,
                                 NULL,
                                 pNewDACL,
                                 NULL);

    if (ERROR_SUCCESS != dwRes)  {
        goto Cleanup;
    }

Cleanup:

    if (pUsersSID) {
        FreeSid(pUsersSID);
    }

    return (dwRes == ERROR_SUCCESS);
}

BOOL
IsLUAEnabled(
    LPCWSTR pszLayers
    )
{
    LPCWSTR pchStart = pszLayers;
    LPCWSTR pch;
    wstring strTok;
    BOOL    bLUAEnabled = FALSE;

    pchStart += wcsspn(pchStart, L"#!");

    while (pchStart != NULL && *pchStart != L'\0' && !bLUAEnabled) {
        pchStart += wcsspn(pchStart, L" \t");
        if (*pchStart == L'\0') {
            break;
        }

        pch = wcspbrk(pchStart, L" \t");
        if (pch == NULL) {
            strTok = pchStart;
            pchStart = NULL;
        } else {
            strTok = wstring(pchStart, (size_t)(pch - pchStart));
            StrUpCase(strTok);
            pchStart = pch;
        }
        bLUAEnabled = (strTok == L"LUA");
    }

    return bLUAEnabled;

}

#endif


// this method returns true when we should present the LUA checkbox and
// false when we should not

STDMETHODIMP CUtil::CheckAdminPrivileges(BOOL *pVal)
{
    *pVal = IsUserAdmin();
    return S_OK;
}

STDMETHODIMP CUtil::RunApplication(BSTR pLayers, BSTR pszCmdLine, BOOL bEnableLog, DWORD* pResult)
{

    LPCWSTR  pszExt;
    BOOL     bShellExecute = FALSE;
    BOOL     bSuccess = FALSE;
    DWORD    dwError  = 0;
    DWORD    dwBinaryType = 0;
    DWORD    dwCreateProcessFlags = 0;
    CSaveErrorMode ErrMode;

    CComBSTR bstrAppName = pszCmdLine;
    ShimGetPathFromCmdLine(pszCmdLine, bstrAppName);

    CComBSTR bstrExePath;

    // check if we are using .lnk file

    pszExt = PathFindExtension(bstrAppName);
    if (pszExt != NULL) {
        bShellExecute = !_tcsicmp(pszExt, TEXT(".lnk"));
    }

    if (!bShellExecute) { // not shell exec? check the binary
        if (!pszExt || (_tcsicmp(pszExt, TEXT(".cmd")) && _tcsicmp(pszExt, TEXT(".bat")))) {
            bShellExecute = !GetBinaryTypeW(bstrAppName, &dwBinaryType);
            if (!bShellExecute && (dwBinaryType == SCS_WOW_BINARY || dwBinaryType == SCS_PIF_BINARY)) {
                dwCreateProcessFlags |= CREATE_SEPARATE_WOW_VDM;
            }
        }
    }
    //
    // invalidate cache
    //
    if (::GetExePathFromObject(bstrAppName, bstrExePath)) {
        InvalidateAppcompatCacheEntry(bstrExePath);
    }


    SetEnvironmentVariable(TEXT("__COMPAT_LAYER"), pLayers);
    SetEnvironmentVariable(TEXT("SHIM_FILE_LOG"),  bEnableLog ? TEXT("shim.log") : NULL);

    //
    // now we shall either ShellExecute or do a CreateProcess
    //
    if (bShellExecute) {
        int    nLength = bstrAppName.Length() + 3;
        LPTSTR pszCmdLineShellExec  = new TCHAR[nLength];
        SHELLEXECUTEINFO ShExecInfo = { 0 };

        if (pszCmdLineShellExec == NULL) {
            //
            // out of memory, just do a create process
            //
            goto HandleCreateProcess;
        }
        nLength = _sntprintf(pszCmdLineShellExec,
                             nLength,
                             TEXT("\"%s\""),
                             (LPCTSTR)bstrAppName);
        if (nLength < 0) {
            delete[] pszCmdLineShellExec;
            goto HandleCreateProcess;
        }

        ShExecInfo.cbSize = sizeof(ShExecInfo);
        ShExecInfo.fMask  = 0; //SEE_MASK_FLAG_NO_UI;
        ShExecInfo.lpVerb = L"open";
        ShExecInfo.lpFile = pszCmdLineShellExec;
        ShExecInfo.nShow  = SW_SHOW;

        bSuccess = ShellExecuteEx(&ShExecInfo);
        if (!bSuccess || (int)((INT_PTR)ShExecInfo.hInstApp) < 32) {
            dwError = GetLastError();
        }
        delete[] pszCmdLineShellExec;


    } else {
HandleCreateProcess:

        // get working directory
        TCHAR szWorkingDir[MAX_PATH];
        LPTSTR pAppName = (LPTSTR)bstrAppName.m_str;
        int nLength;
        LPTSTR pszWorkingDir = NULL;
        STARTUPINFO         StartupInfo;
        PROCESS_INFORMATION ProcessInfo;

        LPTSTR pBackslash = _tcsrchr(pAppName, TEXT('\\'));
        if (pBackslash != NULL) {
            //
            // check for root
            //
            nLength = (int)(pBackslash - pAppName);
            if (nLength == 2 && pAppName[1] == TEXT(':')) {
                ++nLength;
            }
            _tcsncpy(szWorkingDir, pAppName, nLength);
            szWorkingDir[nLength] = TEXT('\0');
            pszWorkingDir = szWorkingDir;
        }

        ZeroMemory(&StartupInfo, sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);
        ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));

        bSuccess = CreateProcess(NULL,
                                 pszCmdLine,
                                 NULL,
                                 NULL,
                                 FALSE,
                                 0,
                                 NULL,
                                 pszWorkingDir,
                                 &StartupInfo,
                                 &ProcessInfo);

        if (!bSuccess) {
            dwError = GetLastError();
        }

        if (ProcessInfo.hThread) {
            CloseHandle(ProcessInfo.hThread);
        }
        if (ProcessInfo.hProcess) {
            CloseHandle(ProcessInfo.hProcess);
        }
    }

    *pResult = dwError;

    SetEnvironmentVariable(TEXT("__COMPAT_LAYER"), NULL);
    SetEnvironmentVariable(TEXT("SHIM_FILE_LOG") , NULL);

    return S_OK;
}

BOOL
GetExePathFromLink(
    LPMALLOC      pMalloc,
    LPCITEMIDLIST pidlLinkFull,
    LPCTSTR       pszLinkFile,
    LPTSTR        pszExePath,
    DWORD         dwBufferSize
    )
{
    IShellLink* psl = NULL;
    WIN32_FIND_DATA wfd;
    HRESULT  hr;
    BOOL     bSuccess = FALSE;
    TCHAR    szPath[MAX_PATH];
    IPersistFile* ipf = NULL;
    IShellLinkDataList* pdl;
    DWORD dwFlags  = 0;
    BOOL  bMsiLink = FALSE;
    HMODULE hMSI = NULL;

    // first do the link

    hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                            IID_IShellLink, (LPVOID*)&psl);
    if (!SUCCEEDED(hr)) {
        return FALSE; // we can't create link object
    }

    hr = psl->SetIDList(pidlLinkFull); // set the id list
    if (!SUCCEEDED(hr)) {
        goto out;
    }

    hr = psl->QueryInterface(IID_IPersistFile, (LPVOID*)&ipf);
    if (!SUCCEEDED(hr)) {
        goto out;
    }

    hr = ipf->Load(pszLinkFile, STGM_READ);
    if (!SUCCEEDED(hr)) {
        goto out;
    }

    //
    // resolve the link for now
    //
    // hr = psl->Resolve(NULL, SLR_NO_UI|SLR_NOUPDATE);
    //

    hr = psl->QueryInterface(IID_IShellLinkDataList, (LPVOID*)&pdl);
    if (SUCCEEDED(hr)) {
        hr = pdl->GetFlags(&dwFlags);

        bMsiLink = SUCCEEDED(hr) && (dwFlags & SLDF_HAS_DARWINID);

        pdl->Release();
    }

    if (bMsiLink) {
        //
        // this is msi link, we need to crack it using msi
        //
        UINT  ErrCode;
        TCHAR szProduct      [MAX_PATH];
        TCHAR szFeatureId    [MAX_PATH];
        TCHAR szComponentCode[MAX_PATH];
        INSTALLSTATE is;

        hMSI = LoadLibrary(TEXT("Msi.dll"));
        if (NULL == hMSI) {
            goto out;
        }

        PMsiGetComponentPath  pfnGetComponentPath  = (PMsiGetComponentPath )GetProcAddress(hMSI, "MsiGetComponentPathW");
        PMsiGetShortcutTarget pfnGetShortcutTarget = (PMsiGetShortcutTarget)GetProcAddress(hMSI, "MsiGetShortcutTargetW");

        if (!pfnGetComponentPath || !pfnGetShortcutTarget)
        {
            goto out;
        }

        ErrCode = pfnGetShortcutTarget(pszLinkFile,
                                       szProduct,
                                       szFeatureId,
                                       szComponentCode);
        if (ERROR_SUCCESS != ErrCode) {
            goto out;
        }

        *pszExePath = TEXT('\0');

        is = pfnGetComponentPath(szProduct, szComponentCode, pszExePath, &dwBufferSize);
        bSuccess = (INSTALLSTATE_LOCAL == is);

    } else {

        hr = psl->GetPath(pszExePath, dwBufferSize, &wfd, 0);
        bSuccess = SUCCEEDED(hr);
    }


out:
    if (hMSI) {
        FreeLibrary(hMSI);
    }

    if (NULL != ipf) {
        ipf->Release();
    }

    if (NULL != psl) {
        psl->Release();
    }

    return bSuccess;

}

BOOL
GetExePathFromObject(
    LPCTSTR lpszPath,  // path to an arbitrary object
    CComBSTR& bstrExePath
    )
{
    IShellFolder* psh = NULL;
    LPMALLOC      pMalloc = NULL;
    HRESULT       hr;
    LPITEMIDLIST  pidl = NULL;
    DWORD         dwAttributes;
    CComBSTR      bstr;
    BOOL          bSuccess = FALSE;

    hr = SHGetMalloc(&pMalloc);
    if (!SUCCEEDED(hr)) {
        goto cleanup;
    }

    hr = SHGetDesktopFolder(&psh);
    if (!SUCCEEDED(hr)) {
        goto cleanup;
    }


    if (!ShimGetPathFromCmdLine(lpszPath, bstr)) {
        goto cleanup;
    }

    //
    // parse display name
    //
    dwAttributes = SFGAO_LINK | SFGAO_FILESYSTEM | SFGAO_VALIDATE;

    hr = psh->ParseDisplayName(NULL,
                               NULL,
                               bstr,     // path to the executable file
                               NULL,     // number of chars eaten
                               &pidl,
                               &dwAttributes);
    if (!SUCCEEDED(hr)) {
        goto cleanup;
    }

    //
    // display name parsed, check whether it's a link
    //
    if (dwAttributes & SFGAO_LINK) {
        TCHAR szExePath[MAX_PATH];
        //
        // it's a link, crack it
        //
        bSuccess = GetExePathFromLink(pMalloc,
                                      pidl,
                                      bstr,
                                      szExePath,
                                      CHARCOUNT(szExePath));
        // after recovering the path -- get the env vars expanded
        if (bSuccess) {
            ShimExpandEnvironmentVars(szExePath, bstrExePath);
        }

    } else if (dwAttributes & SFGAO_FILESYSTEM) {
        //
        // filesystem object (a file)
        //
        bstrExePath = bstr;
        bSuccess    = TRUE;
    }


cleanup:


    if (pidl) {
        pMalloc->Free(pidl);
    }
    if (psh) {
        psh->Release();
    }
    if (pMalloc) {
        pMalloc->Release();
    }
    return bSuccess;
}

STDMETHODIMP CUtil::GetExePathFromObject(BSTR pszPath, VARIANT* pExePath)
{
    CComBSTR bstrExePath;
    BOOL bSuccess;
    CSaveErrorMode ErrMode;

    bSuccess = ::GetExePathFromObject(pszPath, bstrExePath);
    if (bSuccess) {
        pExePath->vt = VT_BSTR;
        pExePath->bstrVal = bstrExePath.Copy();
    } else {
        pExePath->vt = VT_NULL;
    }

    return S_OK;
}

STDMETHODIMP CUtil::IsSystemTarget(BSTR bstrPath, BOOL *pbSystemTarget)
{
    CComBSTR bstrExePath;
    BOOL  bSystemTarget = FALSE;
    DWORD dwAttributes;
    CSaveErrorMode ErrMode;

/*++
    //
    // This code was used to check system directory
    //

    ULONG uSize;
    int   nch;
    TCHAR szSystemDir[MAX_PATH];
    TCHAR szCommonPath[MAX_PATH];

    uSize = ::GetSystemWindowsDirectory(szSystemDir,
                                        CHARCOUNT(szSystemDir));
    if (uSize == 0 || uSize > CHARCOUNT(szSystemDir)) {
        *pbSystemTarget = FALSE;
        return S_OK;
    }
--*/


    if (!::GetExePathFromObject(bstrPath, bstrExePath)) {
        bstrExePath = bstrPath;
    }


/*++
    // this code was used before -- it checked system directory as
    // well as sfc, we are only checking sfc now

    nch = PathCommonPrefix(szSystemDir, bstrExePath, szCommonPath);
    bSystemTarget = (nch == (int)uSize);
    if (!bSystemTarget) {
        bSystemTarget = SfcIsFileProtected(NULL, bstrExePath);
    }
--*/

    bSystemTarget = SfcIsFileProtected(NULL, bstrExePath);


    if (!bSystemTarget) {
        dwAttributes = GetFileAttributes(bstrExePath);
        bSystemTarget = (dwAttributes == (DWORD)-1 || (dwAttributes & FILE_ATTRIBUTE_DIRECTORY));
    }


    *pbSystemTarget = bSystemTarget;

    return S_OK;
}


STDMETHODIMP CUtil::IsExecutableFile(BSTR bstrPath, BOOL *pbExecutableFile)
{
    BOOL bExecutable = FALSE;
    DWORD dwExeType = 0;
    CComBSTR bstrExePath;
    LPCWSTR pszExt;
    CSaveErrorMode ErrMode;

    if (!::GetExePathFromObject(bstrPath, bstrExePath)) {
        bstrExePath = bstrPath;
    }

    bExecutable = GetBinaryTypeW(bstrExePath, &dwExeType);
    if (!bExecutable) {
        // is this a batch file? if not -- you are out!
        pszExt = PathFindExtension(bstrPath);
        if (pszExt != NULL) {
            bExecutable = !_tcsicmp(pszExt, TEXT(".bat")) ||
                          !_tcsicmp(pszExt, TEXT(".cmd"));
        }
    }
    *pbExecutableFile = bExecutable;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\compatui\util.h ===
// Util.h : Declaration of the CUtil

#ifndef __UTIL_H_
#define __UTIL_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CUtil
class ATL_NO_VTABLE CUtil :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CUtil, &CLSID_Util>,
    public IDispatchImpl<IUtil, &IID_IUtil, &LIBID_COMPATUILib>
{
public:
    CUtil()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_UTIL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CUtil)
    COM_INTERFACE_ENTRY(IUtil)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IUtil
public:
    STDMETHOD(IsExecutableFile)(/*[in]*/BSTR bstrPath, /*[out, retval]*/BOOL* pbExecutableFile);
    STDMETHOD(IsSystemTarget)(/*[in]*/BSTR bstrPath, /*[out, retval]*/BOOL* pbSystemTarget);
    STDMETHOD(GetExePathFromObject)(/*[in]*/BSTR pszPath, /*[out, retval]*/VARIANT* pExePath);
    STDMETHOD(CheckAdminPrivileges)(/*[out, retval]*/ BOOL* pVal);
    STDMETHOD(SetItemKeys)(/*[in]*/BSTR pszPath, /*[in]*/VARIANT* pKeys, /*[out, retval]*/BOOL* pVal);
    STDMETHOD(GetItemKeys)(/*[in]*/BSTR pszPath, /*[out, retval]*/VARIANT* pszKeys);
    STDMETHOD(RemoveArgs)(BSTR sVar, VARIANT* pOut);
    STDMETHOD(RunApplication)(/*[in]*/BSTR pLayers, /*[in]*/BSTR pszCmdLine,
                              /*[in]*/BOOL bEnableLog, /*[out,retval]*/DWORD* pResult);
    STDMETHOD(IsCompatWizardDisabled)(/*[out, retval]*/BOOL* pbDisabled);
};

#endif //__UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\doc\msvcsampleshim\inc\shimah.h ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:

    ShimAh.h

 Abstract:

    Definitions for use by all modules

 Notes:

    None

 History:

    12/09/1999 robkenny Created
    01/10/2000 linstev  Format to new style

--*/

#ifndef _SHIMAH_H_
#define _SHIMAH_H_


DWORD_PTR AhCall(LPSTR pszModule, LPSTR pszFunctionName, DWORD dwArgCount, ...);


#define GetLastError()                          (DWORD)     AhCall("KERNEL32.DLL", "GetLastError", 0)
#define FormatMessageA(a, b, c, d, e, f, g)     (LONG)      AhCall("KERNEL32.DLL", "FormatMessageA", 7, a, b, c, d, e, f, g)
#define FormatMessageW(a, b, c, d, e, f, g)     (LONG)      AhCall("KERNEL32.DLL", "FormatMessageW", 7, a, b, c, d, e, f, g)

// Memory routines
#define VirtualAlloc(a, b, c, d)                (LPVOID)    AhCall("KERNEL32.DLL", "VirtualAlloc", 4, a, b, c, d)
#define VirtualFree(a, b, c)                    (BOOL)      AhCall("KERNEL32.DLL", "VirtualFree", 3, a, b, c)
#define VirtualProtect(a, b, c, d)              (BOOL)      AhCall("KERNEL32.DLL", "VirtualProtect", 4, a, b, c, d)

#define malloc(a)                               (LPVOID)    VirtualAlloc(NULL, a, MEM_COMMIT, PAGE_READWRITE)
#define free(a)                                 (VOID)      VirtualFree(a, 0, MEM_RELEASE)
#define memset(a, b, c)                         (LPVOID)    AhCall("NTDLL.DLL", "RtlFillMemory", 3, a, b, c)
#define memmove(a, b, c)                        (LPVOID)    AhCall("NTDLL.DLL", "RtlMoveMemory", 3, a, b, c)
#define memcpy(a, b, c)                         (VOID *)    AhCall("NTDLL.DLL", "memcpy", 3, a, b, c)

#define RtlAllocateHeap(a, b, c)                (LPVOID)    AhCall("NTDLL.DLL", "RtlAllocateHeap", 3, a, b, c)
#define RtlFreeHeap(a, b, c)                    (LPVOID)    AhCall("NTDLL.DLL", "RtlFreeHeap", 3, a, b, c)

// Disable build warnings due to duplicate macro definitions
#ifdef ZeroMemory
#undef ZeroMemory
#endif
#define ZeroMemory(a, b)                            (int)       AhCall( "NTDLL.DLL", "RtlZeroMemory", 2, a, b)
#ifdef MoveMemory
#undef MoveMemory
#endif
#define MoveMemory(a, b, c)                         (int)       AhCall( "NTDLL.DLL", "RtlMoveMemory", 3, a, b, c)

// String manipulation routines
#define towupper(a)                                 (int)       AhCall("NTDLL.DLL", "towupper", 1, a)
#define strstr(a, b)                                (char *)    AhCall("NTDLL.DLL", "strstr", 2, a, b)
#define wcsstr(a, b)                                (wchar_t *) AhCall("NTDLL.DLL", "wcsstr", 2, a, b)
#define _strupr(a)                                  (char *)    AhCall("NTDLL.DLL", "_strupr", 1, a)
#define _wcsupr(a)                                  (wchar_t *) AhCall("NTDLL.DLL", "_wcsupr", 1, a)
#define strncmp(a, b, c)                            (char *)    AhCall("NTDLL.DLL", "strncmp", 3, a, b, c)
#define wcsncmp(a, b, c)                            (wchar_t *) AhCall("NTDLL.DLL", "wcsncmp", 3, a, b, c)
#define _stricmp(a, b)                              (int)       AhCall("NTDLL.DLL", "_stricmp", 2, a, b)
#define strcat(a, b)                                (char *)    AhCall("NTDLL.DLL", "strcat", 2, a, b)
#define wcscat(a, b)                                (wchar_t *) AhCall("NTDLL.DLL", "wcscat", 2, a, b)
#define strlen(a)                                   (size_t)    AhCall("NTDLL.DLL", "strlen", 1, a)
#define wcslen(a)                                   (size_t)    AhCall("NTDLL.DLL", "wcslen", 1, a)
#define strcpy(a, b)                                (char *)    AhCall("NTDLL.DLL", "strcpy", 2, a, b)
#define wcscpy(a, b)                                (wchar_t *) AhCall("NTDLL.DLL", "wcscpy", 2, a, b)
#define strncpy(a, b, c)                            (char *)    AhCall("NTDLL.DLL", "strncpy", 3, a, b, c)
#define wcsncpy(a, b, c)                            (wchar_t *) AhCall("NTDLL.DLL", "wcsncpy", 3, a, b, c)
#define _strlwr(a)                                  (char *)    AhCall("NTDLL.DLL", "_strlwr", 1, a)
#define _wcslwr(a)                                  (wchar_t *) AhCall("NTDLL.DLL", "_wcslwr", 1, a)
#define _strnicmp(a, b, c)                          (int)       AhCall("NTDLL.DLL", "_strnicmp", 3, a, b, c)
#define _wcsnicmp(a, b, c)                          (int)       AhCall("NTDLL.DLL", "_wcsnicmp", 3, a, b, c)

// ANSI/Unicode routines
#define MultiByteToWideChar(a, b, c, d, e, f)       (int)       AhCall("KERNEL32.DLL", "MultiByteToWideChar", 6, a, b, c, d, e, f)
#define WideCharToMultiByte(a, b, c, d, e, f, g, h) (int)       AhCall("KERNEL32.DLL", "WideCharToMultiByte", 8, a, b, c, d, e, f, g, h)

// Registry routines
#define RegOpenKeyA(a, b, c)                       (LONG)      AhCall("ADVAPI32.DLL", "RegOpenKeyA", 3, a, b, c)
#define RegOpenKeyW(a, b, c)                       (LONG)      AhCall("ADVAPI32.DLL", "RegOpenKeyW", 3, a, b, c)
#define RegCloseKey(a)                             (LONG)      AhCall("ADVAPI32.DLL", "RegCloseKey", 1, a)
#define RegOpenKeyExA(a, b, c, d, e)               (LONG)      AhCall("ADVAPI32.DLL", "RegOpenKeyExA", 5, a, b, c, d, e) 
#define RegOpenKeyExW(a, b, c, d, e)               (LONG)      AhCall("ADVAPI32.DLL", "RegOpenKeyExW", 5, a, b, c, d, e) 
#define RegQueryValueExA(a, b, c, d, e, f)         (LONG)      AhCall("ADVAPI32.DLL", "RegQueryValueExA", 6, a, b, c, d, e, f)
#define RegQueryValueExW(a, b, c, d, e, f)         (LONG)      AhCall("ADVAPI32.DLL", "RegQueryValueExW", 6, a, b, c, d, e, f)
#define RegCreateKeyExA(a, b, c, d, e, f, g, h, i) (LONG)      AhCall("ADVAPI32.DLL", "RegCreateKeyExA", 9, a, b, c, d, e, f, g, h, i)
#define RegCreateKeyExW(a, b, c, d, e, f, g, h, i) (LONG)      AhCall("ADVAPI32.DLL", "RegCreateKeyExA", 9, a, b, c, d, e, f, g, h, i)
#define RegCreateKeyA(a, b, c)                     (LONG)      AhCall("ADVAPI32.DLL", "RegCreateKeyA", 3, a, b, c)
#define RegCreateKeyW(a, b, c)                     (LONG)      AhCall("ADVAPI32.DLL", "RegCreateKeyW", 3, a, b, c)

#define GetPrivateProfileIntA(a, b, c, d)          (UINT)      AhCall("KERNEL32.DLL", "GetPrivateProfileIntA", 4, a, b, c, d)
#define GetPrivateProfileIntW(a, b, c, d)          (UINT)      AhCall("KERNEL32.DLL", "GetPrivateProfileIntW", 4, a, b, c, d)
#define GetPrivateProfileSectionA(a, b, c, d)      (DWORD)     AhCall("KERNEL32.DLL", "GetPrivateProfileSectionA", 4, a, b, c, d)
#define GetPrivateProfileSectionW(a, b, c, d)      (DWORD)     AhCall("KERNEL32.DLL", "GetPrivateProfileSectionW", 4, a, b, c, d)
#define GetPrivateProfileSectionNamesA(a, b, c)    (DWORD)     AhCall("KERNEL32.DLL", "GetPrivateProfileSectionNamesA", 3, a, b, c)
#define GetPrivateProfileSectionNamesW(a, b, c)    (DWORD)     AhCall("KERNEL32.DLL", "GetPrivateProfileSectionNamesW", 3, a, b, c)
#define GetPrivateProfileStringA(a, b, c, d, e, f) (DWORD)     AhCall("KERNEL32.DLL", "GetPrivateProfileStringA", 6, a, b, c, d, e, f)
#define GetPrivateProfileStringW(a, b, c, d, e, f) (DWORD)     AhCall("KERNEL32.DLL", "GetPrivateProfileStringW", 6, a, b, c, d, e, f)
#define GetPrivateProfileStructA(a, b, c, d, e)    (DWORD)     AhCall("KERNEL32.DLL", "GetPrivateProfileStructA", 5, a, b, c, d, e) 
#define GetPrivateProfileStructW(a, b, c, d, e)    (DWORD)     AhCall("KERNEL32.DLL", "GetPrivateProfileStructW", 5, a, b, c, d, e) 
#define WritePrivateProfileSectionA(a, b, c)       (DWORD)     AhCall("KERNEL32.DLL", "WritePrivateProfileSectionA", 3, a, b, c)
#define WritePrivateProfileSectionW(a, b, c)       (DWORD)     AhCall("KERNEL32.DLL", "WritePrivateProfileSectionW", 3, a, b, c)
#define WritePrivateProfileStringA(a, b, c, d)     (UINT)      AhCall("KERNEL32.DLL", "WritePrivateProfileStringA", 4, a, b, c, d)
#define WritePrivateProfileStringW(a, b, c, d)     (UINT)      AhCall("KERNEL32.DLL", "WritePrivateProfileStringW", 4, a, b, c, d)
#define WritePrivateProfileStructA(a, b, c, d, e)  (DWORD)     AhCall("KERNEL32.DLL", "WritePrivateProfileStructA", 5, a, b, c, d, e) 
#define WritePrivateProfileStructW(a, b, c, d, e)  (DWORD)     AhCall("KERNEL32.DLL", "WritePrivateProfileStructW", 5, a, b, c, d, e) 


#define GetEnvironmentVariableA(a, b, c)        (DWORD)     AhCall("KERNEL32.DLL", "GetEnvironmentVariableA", 3, a, b, c)
#define GetEnvironmentVariableW(a, b, c)        (DWORD)     AhCall("KERNEL32.DLL", "GetEnvironmentVariableW", 3, a, b, c)
#define ExpandEnvironmentStringsA(a, b, c)      (DWORD)     AhCall("KERNEL32.DLL", "ExpandEnvironmentStringsA", 3, a, b, c)
#define ExpandEnvironmentStringsW(a, b, c)      (DWORD)     AhCall("KERNEL32.DLL", "ExpandEnvironmentStringsW", 3, a, b, c)

#define GetWindowsDirectoryA(a, b)              (UINT)      AhCall("Kernel32.dll", "GetWindowsDirectoryA", 2, a, b)
#define GetWindowsDirectoryW(a, b)              (UINT)      AhCall("Kernel32.dll", "GetWindowsDirectoryW", 2, a, b)

#define GetSystemDirectoryA(a, b)               (UINT)      AhCall("Kernel32.dll", "GetSystemDirectoryA", 2, a, b)
#define GetSystemDirectoryW(a, b)               (UINT)      AhCall("Kernel32.dll", "GetSystemDirectoryW", 2, a, b)

#define GetFullPathNameA(a, b, c, d)            (DWORD)     AhCall("KERNEL32.DLL", "GetFullPathNameA", 4, a, b, c, d)
#define GetFullPathNameW(a, b, c, d)            (DWORD)     AhCall("KERNEL32.DLL", "GetFullPathNameW", 4, a, b, c, d)
#define GetShortPathNameA(a, b, c)              (DWORD)     AhCall("KERNEL32.DLL", "GetShortPathNameA", 3, a, b, c)
#define GetShortPathNameW(a, b, c)              (DWORD)     AhCall("KERNEL32.DLL", "GetShortPathNameW", 3, a, b, c)

#define SHGetFolderPathA(a, b, c, d, e)         (HRESULT)   AhCall("SHELL32.DLL", "SHGetFolderPathA", 5, a, b, c, d, e)
#define SHGetFolderPathW(a, b, c, d, e)         (HRESULT)   AhCall("SHELL32.DLL", "SHGetFolderPathW", 5, a, b, c, d, e)

#define SHGetSpecialFolderPathA(a, b, c, d)     (BOOL)      AhCall( "SHELL32.DLL", "SHGetSpecialFolderPathA", 4, a, b, c, d)
#define SHGetSpecialFolderPathW(a, b, c, d)     (BOOL)      AhCall( "SHELL32.DLL", "SHGetSpecialFolderPathW", 4, a, b, c, d)

#define SHGetFolderLocation(a, b, c, d, e)      (HRESULT)   AhCall("SHELL32.DLL", "SHGetFolderLocation", 5, a, b, c, d, e)

#define GetCurrentDirectoryA(a, b)              (DWORD)     AhCall( "KERNEL32.DLL", "GetCurrentDirectoryA", 2, a, b)
#define GetCurrentDirectoryW(a, b)              (DWORD)     AhCall( "KERNEL32.DLL", "GetCurrentDirectoryW", 2, a, b)

#ifndef _WIN64
    #define GetWindowLongA(a, b)                    (LONG)      AhCall("USER32.DLL", "GetWindowLongA", 2, a, b)
    #define GetWindowLongW(a, b)                    (LONG)      AhCall("USER32.DLL", "GetWindowLongW", 2, a, b)
    #define SetWindowLongA(a, b, c)                 (LONG)      AhCall("USER32.DLL", "SetWindowLongA", 3, a, b, c)
    #define SetWindowLongW(a, b, c)                 (LONG)      AhCall("USER32.DLL", "SetWindowLongW", 3, a, b, c)
#else    //use 64 bit calls
    #define GetWindowLongA(a, b)                    (LONG_PTR)  AhCall("USER32.DLL", "GetWindowLongPtrA", 2, a, b)
    #define GetWindowLongW(a, b)                    (LONG_PTR)  AhCall("USER32.DLL", "GetWindowLongPtrW", 2, a, b)
    #define SetWindowLongA(a, b, c)                 (LONG_PTR)  AhCall("USER32.DLL", "SetWindowLongPtrA", 3, a, b, c)
    #define SetWindowLongW(a, b, c)                 (LONG_PTR)  AhCall("USER32.DLL", "SetWindowLongPtrW", 3, a, b, c)
#endif

#define GetDriveTypeA( a )                      (UINT)      AhCall("KERNEL32.DLL", "GetDriveTypeA", 1, a)
#define GetDriveTypeW( a )                      (UINT)      AhCall("KERNEL32.DLL", "GetDriveTypeW", 1, a)
#define CopyFileA(a, b, c )                     (BOOL)      AhCall("KERNEL32.DLL", "CopyFileA", 3, a, b, c )
#define CopyFileW(a, b, c )                     (BOOL)      AhCall("KERNEL32.DLL", "CopyFileW", 3, a, b, c )
#define SetFileAttributesA( a, b )              (BOOL)      AhCall("KERNEL32.DLL", "SetFileAttributesA", 2, a, b )
#define SetFileAttributesW( a, b )              (BOOL)      AhCall("KERNEL32.DLL", "SetFileAttributesW", 2, a, b )

#define RemoveDirectoryA(a)                     (BOOL)      AhCall("KERNEL32.DLL", "RemoveDirectoryA", 1, a)
#define RemoveDirectoryW(a)                     (BOOL)      AhCall("KERNEL32.DLL", "RemoveDirectoryW", 1, a)
#define MoveFileA(a, b)                         (BOOL)      AhCall("KERNEL32.DLL", "MoveFileA", 2, a, b)
#define MoveFileW(a, b)                         (BOOL)      AhCall("KERNEL32.DLL", "MoveFileW", 2, a, b)

#define GetUserNameA(a, b)                      (BOOL)      AhCall("ADVAPI32.DLL", "GetUserNameA", 2, a, b);
#define GetUserNameW(a, b)                      (BOOL)      AhCall("ADVAPI32.DLL", "GetUserNameW", 2, a, b);
#define OpenProcessToken( a, b, c )             (BOOL)      AhCall("ADVAPI32.DLL", "OpenProcessToken", 3, a, b, c )
#define GetCurrentProcess()                     (HANDLE)    AhCall("KERNEL32.DLL", "GetCurrentProcess", 0 )
#define LookupPrivilegeValueA( a, b, c )        (BOOL)      AhCall("ADVAPI32.DLL", "LookupPrivilegeValueA", 3, a, b, c )
#define LookupPrivilegeValueW( a, b, c )        (BOOL)      AhCall("ADVAPI32.DLL", "LookupPrivilegeValueW", 3, a, b, c )
#define AdjustTokenPrivileges( a, b, c, d, e, f)(BOOL)      AhCall("ADVAPI32.DLL", "AdjustTokenPrivileges", 6, a, b, c, d, e, f )

#define GetDiskFreeSpaceExA( a, b, c, d )       (BOOL)      AhCall("KERNEL32.DLL", "GetDiskFreeSpaceExA", 4, a, b, c, d )
#define lstrcpyA(a, b)                          (LPTSTR)    AhCall("KERNEL32.DLL", "lstrcpy", 2, a, b) 
#define mouse_event(a, b, c, d, e)              (VOID)      AhCall("USER32.DLL", "mouse_event", 5, a, b, c, d, e )
#define SetForegroundWindow(a)                  (BOOL)      AhCall("USER32.DLL", "SetForegroundWindow", 1, a )
#define IsWindow(a)                             (BOOL)      AhCall("USER32.DLL", "IsWindow", 1, a )

#define lstrcmpA(a, b)                          (int)       AhCall("KERNEL32.DLL", "lstrcmpA", 2, a, b)
#define lstrcmpW(a, b)                          (int)       AhCall("KERNEL32.DLL", "lstrcmpW", 2, a, b)

#define CloseHandle(a)                          (BOOL)      AhCall("KERNEL32.DLL", "CloseHandle", 1, a)

#define GetModuleFileNameA(a, b, c)             (DWORD)     AhCall("KERNEL32.DLL", "GetModuleFileNameA", 3, a, b, c)
#define GetModuleFileNameW(a, b, c)             (DWORD)     AhCall("KERNEL32.DLL", "GetModuleFileNameW", 3, a, b, c)
#define GetShortPathNameA(a, b, c)              (DWORD)     AhCall("KERNEL32.DLL", "GetShortPathNameA", 3, a, b, c)
#define GetShortPathNameW(a, b, c)              (DWORD)     AhCall("KERNEL32.DLL", "GetShortPathNameW", 3, a, b, c)
#define LocalAlloc(a, b)                        (HLOCAL)    AhCall("KERNEL32.DLL", "LocalAlloc", 2, a, b)
#define LocalFree(a)                            (HLOCAL)    AhCall("KERNEL32.DLL", "LocalFree", 1, a)

#define ShellExecuteA(a, b, c, d, e, f)         (HINSTANCE) AhCall("SHELL32.DLL",  "ShellExecuteA", 6, a, b ,c ,d ,e ,f)
#define ShellExecuteW(a, b, c, d, e, f)         (HINSTANCE) AhCall("SHELL32.DLL",  "ShellExecuteW", 6, a, b ,c ,d ,e ,f)
#define IsBadStringPtrA(a, b)                   (BOOL)      AhCall("KERNEL32.DLL", "IsBadStringPtrA", 2, a ,b)
#define IsBadStringPtrW(a, b)                   (BOOL)      AhCall("KERNEL32.DLL", "IsBadStringPtrW", 2, a ,b)

#define GetLogicalDriveStringsA(a, b)           (DWORD)     AhCall("KERNEL32.DLL", "GetLogicalDriveStringsA",2, a ,b)
#define GetLogicalDriveStringsW(a, b)           (DWORD)     AhCall("KERNEL32.DLL", "GetLogicalDriveStringsW",2, a ,b)

#define EnterCriticalSection(a)                 (VOID)      AhCall("KERNEL32.DLL", "EnterCriticalSection", 1, a)
#define LeaveCriticalSection(a)                 (VOID)      AhCall("KERNEL32.DLL", "LeaveCriticalSection", 1, a)
#define InitializeCriticalSection(a)            (VOID)      AhCall("KERNEL32.DLL", "InitializeCriticalSection", 1, a)
#define DeleteCriticalSection(a)                (VOID)      AhCall("KERNEL32.DLL", "InitializeCriticalSection", 1, a)

#define EnumDisplaySettingsA(a, b, c)           (BOOL)      AhCall("USER32.DLL", "EnumDisplaySettingsA", 3, a, b, c)
#define EnumDisplaySettingsW(a, b, c)           (BOOL)      AhCall("USER32.DLL", "EnumDisplaySettingsW", 3, a, b, c)
#define ChangeDisplaySettingsA(a, b)            (LONG)      AhCall("USER32.DLL", "ChangeDisplaySettingsA", 2, a, b)
#define ChangeDisplaySettingsW(a, b)            (LONG)      AhCall("USER32.DLL", "ChangeDisplaySettingsA", 2, a, b)
#define ChangeDisplaySettingsExA(a, b, c, d, e) (LONG)      AhCall("USER32.DLL", "ChangeDisplaySettingsExA", 5, a, b, c, d, e)
#define ChangeDisplaySettingsExW(a, b, c, d, e) (LONG)      AhCall("USER32.DLL", "ChangeDisplaySettingsExW", 5, a, b, c, d, e) 

#define SelectObject(a, b)                      (HGDIOBJ)   AhCall("GDI32.DLL", "SelectObject", 2, a, b)
#define BitBlt(a, b, c, d, e, f, g, h, i)       (BOOL)      AhCall("GDI32.DLL", "BitBlt", 9, a, b, c, d, e, f, g, h, i)
#define StretchBlt(a, b, c, d, e, f, g, h, i, j, k) (BOOL)  AhCall("GDI32.DLL", "StretchBlt", 11, a, b, c, d, e, f, g, h, i, j, k)

#define CreateDIBSection(a, b, c, d, e, f)      (HBITMAP)   AhCall("GDI32.DLL", "CreateDIBSection", 6, a, b, c, d, e, f)
#define CreateCompatibleBitmap(a, b, c)         (HBITMAP)   AhCall("GDI32.DLL", "CreateCompatibleBitmap", 3, a, b, c)
#define CreateCompatibleDC(a)                   (HDC)       AhCall("GDI32.DLL", "CreateCompatibleDC", 1, a)
#define DeleteObject(a)                         (BOOL)      AhCall("GDI32.DLL", "DeleteObject", 1, a)
#define DeleteDC(a)                             (BOOL)      AhCall("GDI32.DLL", "DeleteDC", 1, a)

#define OpenMutexA(a, b, c)                     (HANDLE)    AhCall("KERNEL32.DLL", "OpenMutexA", 3, a, b, c)
#define GetCurrentThreadId()                    (DWORD)     AhCall("KERNEL32.DLL", "GetCurrentThreadId", 0)

#define CoCreateInstance(a, b, c, d, e)         (HRESULT)   AhCall("OLE32.DLL", "CoCreateInstance", 5, &(a), b, c, &(d), e) 
#define CoInitialize(a)                         (HRESULT)   AhCall("OLE32.DLL", "CoInitialize", 1, a) 
#define CoUninitialize()                        (HRESULT)   AhCall("OLE32.DLL", "CoUninitialize", 0) 
 
#endif // _SHIMAH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\doc\msvcsampleshim\inc\shimdebug.h ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:

    common.h

 Abstract:

    Definitions for use by all modules

 Notes:

    None

 History:

    12/09/1999 robkenny Created
    01/10/2000 linstev  Format to new style

--*/

#ifndef _SHIMCOMMON_H_
#define _SHIMCOMMON_H_

void APPBreakPoint(void);
#ifdef DBG
    // Debug environment variable, values = 0 -> 9
    #define szDebugEnvironmentVariable "SHIM_DEBUG_LEVEL"    
    
    // Debug error levels
    typedef enum 
    {    
        eDbgLevelBase  = 0,
        eDbgLevelError,
        eDbgLevelWarning,
        eDbgLevelUser,
        eDbgLevelInfo,
        eDbgLevelSpew = 9,
    } DEBUGLEVEL;

    VOID __cdecl DebugPrintf(DEBUGLEVEL dwDetail, LPSTR pszFmt, ...);

    VOID DebugAssert(
        LPSTR szFile,
        DWORD dwLine,
        BOOL bAssert, 
        LPSTR szHelpString);

    #define DPF          DebugPrintf
    #define DPFERROR(a)  DPF(eDbgLevelError, a)
    #define ASSERT(a, b) DebugAssert(__FILE__, __LINE__, a, b)
#else
    #pragma warning(disable : 4002)
    #define DPF()
    #define ASSERT()
#endif



#endif // _SHIMCOMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\doc\msvcsampleshim\inc\shimhook.h ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ShimHook.h

 Abstract:

    Header for ShimHook.cpp

 Notes:

    None

 History:

    11/01/1999 markder  Created
    01/10/2000 linstev  Format to new style

--*/

#ifndef _SHIMHOOK_H_
#define _SHIMHOOK_H_

#include <windows.h>
#include <winerror.h>
#include <shellapi.h>
#include <shlobj.h>
#include <ole2.h>
#include <ddraw.h>

#include <shimdb.h>
#include "ShimHookMacro.h"
#include "ShimDebug.h"
#include "ShimLib.h"
#include "ShimProto.h"

#endif //_AH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\doc\msvcsampleshim\inc\shimhookmacro.h ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ShimHookMacro.h

 Abstract:

    Shim hooking macros

 Notes:

    None

 History:

    11/01/1999 markder  Created
    01/10/2000 linstev  Format to new style

--*/

#ifndef _SHIMHOOKMACRO_H_
#define _SHIMHOOKMACRO_H_

#include <ShimDebug.h>

enum
{
    APIHOOK_DllGetClassObject = 0,
    APIHOOK_DirectDrawCreate,
    APIHOOK_DirectDrawCreateEx,
    USERAPIHOOKSTART
};

enum
{
    USERCOMHOOKSTART = 0
};

typedef struct tagSHIM_COM_HOOK
{
    CLSID*              pCLSID;
    IID*                pIID;
    DWORD               dwVtblIndex;
    PVOID               pfnNew;
    PVOID               pfnOld;
} SHIM_COM_HOOK, *PSHIM_COM_HOOK;

typedef struct tagSHIM_IFACE_FN_MAP
{
    PVOID               pVtbl;
    PVOID               pfnNew;
    PVOID               pfnOld;
    PVOID               pNext;
} SHIM_IFACE_FN_MAP, *PSHIM_IFACE_FN_MAP;

typedef struct tagSHIM_HOOKED_OBJECT
{
    PVOID               pThis;
    CLSID*              pCLSID;
    DWORD               dwRef;
    BOOL                bAddRefTrip;
    BOOL                bClassFactory;
    PVOID               pNext;
} SHIM_HOOKED_OBJECT, *PSHIM_HOOKED_OBJECT;

//  These declarations are needed to hook all known exported APIs that return a COM object.

PVOID       LookupOldCOMIntf( PVOID pVtbl, PVOID pfnNew, BOOL bThrowExceptionIfNull );
void        DumpCOMHooks();
void        InitializeHooks(DWORD fdwReason);
VOID        HookObject(IN CLSID *pCLSID, IN REFIID riid, OUT LPVOID *ppv, OUT PSHIM_HOOKED_OBJECT pOb, IN BOOL bClassFactory );

extern void InitHooks(DWORD dwCount);
extern void InitComHooks(DWORD dwCount);
extern HRESULT APIHook_DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppv);

#ifndef LIB_BUILD_FLAG
    extern BOOL     g_bAPIHooksInited;
    extern BOOL     g_bHasCOMHooks;
    extern PHOOKAPI g_pAPIHooks;   
    extern PSHIM_COM_HOOK g_pCOMHooks;   
    extern DWORD    g_dwAPIHookCount;   
    extern DWORD    g_dwCOMHookCount;   
#else
    BOOL     g_bAPIHooksInited;
    BOOL     g_bHasCOMHooks;
    PHOOKAPI g_pAPIHooks;   
    PSHIM_COM_HOOK g_pCOMHooks;   
    DWORD    g_dwAPIHookCount;   
    DWORD    g_dwCOMHookCount;   
#endif // LIB_BUILD_FLAG

// Macros for user shims

#define INIT_HOOKS InitHooks

#define INIT_COMHOOKS(module, count)                                    \
    ASSERT(g_bAPIHooksInited,"INVALID COMHOOK, INIT_HOOK MACRO MUST BE FIRST!!"); \
    DECLARE_APIHOOK(module, DllGetClassObject);                    \
    InitComHooks(count);

#define DECLARE_APIHOOK(module, fn)                        \
    g_pAPIHooks[APIHOOK_##fn].pszModule = #module;         \
    g_pAPIHooks[APIHOOK_##fn].pszFunctionName = #fn;       \
    g_pAPIHooks[APIHOOK_##fn].pfnNew = APIHook_##fn;       \
    DPF(eDbgLevelInfo, "[declare apihook] " #fn "\n");


#define DECLARE_COMHOOK(clsid, iid, intf, vtblndx)                 \
    g_pCOMHooks[COMHOOK_##intf ].pCLSID        = (CLSID*) &clsid;  \
    g_pCOMHooks[COMHOOK_##intf ].pIID          = (IID*)  &iid;     \
    g_pCOMHooks[COMHOOK_##intf ].dwVtblIndex   = vtblndx;          \
    g_pCOMHooks[COMHOOK_##intf ].pfnNew        = COMHook_##intf;   \
    DPF(eDbgLevelInfo, "[declarecomhook] " #intf "\n");

#define LOOKUP_APIHOOK(fn)                                  \
    (*(_pfn_##fn)(g_pAPIHooks[APIHOOK_##fn].pfnOld))

#define LOOKUP_COMHOOK(pThis, fn, bThrowException)              \
    (*(_pfn_##fn)(LookupOldCOMIntf(*((PVOID *) pThis), COMHook_##fn, bThrowException )))


#endif // _SHIMHOOKMACRO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\doc\msvcsampleshim\inc\shimhapi.h ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    shim.h
//
// History:    May-99   clupu       Created.
//             Aug-99   v-johnwh    Various bug fixes.
//          23-Nov-99   markder     Support for multiple shim DLLs, chaining
//                                  of hooks. General clean-up.
//          11-Feb-00   markder     Reverted to W2K shipped shim structures.
// 
// Desc:    Contains all structure and function definitions for the shim mechanism.
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef __SHIM_H__
#define __SHIM_H__

typedef struct tagHOOKAPI {
    
    char*   pszModule;          // the name of the module
    char*   pszFunctionName;    // the name of the API in the module
    PVOID   pfnNew;             // pointer to the new stub API
    PVOID   pfnOld;             // pointer to the old API
    DWORD   dwIndex;            // used internally
    char*   pszModToPatch;      // list of modules to hook. NULL means all.

} HOOKAPI, *PHOOKAPI;

/*
 * If the hook DLL ever patches LoadLibraryA/W it must call PatchNewModules
 * so that the shim knows to patch any new loaded DLLs
 */
typedef VOID (*PFNPATCHNEWMODULES)(VOID);

typedef PHOOKAPI (*PFNGETHOOKAPIS)(LPSTR pszCmdLine,
                                   PFNPATCHNEWMODULES pfnPatchNewModules,
                                   DWORD* pdwHooksCount);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\doc\msvcsampleshim\sampleshim\sampleshim.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   SampleShim.cpp

 Abstract:

   This DLL serves as a template for the creation of shim DLLs. Follow
   the commenting/coding style of this source file wherever possible.
   Never use tabs, configure your editor to insert spaces instead of
   tab characters.

 Notes:

   This is a sample DLL.

 History:

   02/02/2000 markder  Created

--*/

#include "ShimHook.h"

// Add APIs that you wish to hook to this enumeration. The first one
// must have "= USERAPIHOOKSTART", and the last one must be
// APIHOOK_Count.
enum
{
   APIHOOK_OutputDebugStringA = USERAPIHOOKSTART,
   APIHOOK_OutputDebugStringW,
   APIHOOK_Count
};

/*++

 This stub function intercepts all calls to OutputDebugStringA
 and prefixes the output string with "SampleShim says:".

 Note that all Win32 APIs use __stdcall calling conventions, so
 you must be sure to have this set in MSVC++. Go to Projects|Settings,
 C/C++ tab, select Category: "Code Generation" from dropdown, make
 sure "Calling convention" is set to __stdcall.

--*/

VOID
APIHook_OutputDebugStringA(
    LPCSTR szOutputString
    )
{
    // Declare all local variables at top of function. Always use
    // Hungarian notation as follows:
    //
    //      Type                        Scope
    //      -----------------------     ------------------
    //      Pointers            p       Global          g_
    //      DWORD               dw      Class member    m_
    //      LONG                l       Static          s_
    //      ANSI strings        sz
    //      Wide-char strings   wsz
    //      Arrays              rg
    //
    LPSTR   szNewOutputString;
    CHAR    szPrefix[] = "SampleShim says: ";

    // All string alterations must be done in new memory. Never
    // alter a passed-in string in-place.
    szNewOutputString = (LPSTR) malloc( strlen( szOutputString ) +
                                        strlen( szPrefix ) + 1 );

    // Use the DPF macro to print debug strings. See Hooks\inc\ShimDebug.h
    // for debug level values. Use eDbgLevelError if an unexpected error occurs
    // in your shim code. For informational output, use eDbgLevelUser.
    DPF(eDbgLevelUser, "APIHook_OutputDebugStringA called.\n");
    
    strcpy( szNewOutputString, szPrefix );
    strcat( szNewOutputString, szOutputString );

    // Use the LOOKUP_APIHOOK macro to call the original API. You must use
    // this so that API chaining and inclusion/exclusion information is
    // preserved.
    LOOKUP_APIHOOK(OutputDebugStringA)( szNewOutputString );

    free( szNewOutputString );

    return;
}

/*++

 This stub function intercepts all calls to OutputDebugStringW
 and prefixes the output string with "SampleShim says:".

 Note that to make your shim generally applicable, you should include
 both ANSI and wide-character versions of your stub function.

--*/

VOID
APIHook_OutputDebugStringW(
    LPCWSTR wszOutputString
    )
{
    // NEVER use TCHAR variables or tcs-prefixed string manipulation routines.
    // Prefix all wide-character string constants with L. Never use _T() or
    // TEXT() macros.
    LPWSTR   wszNewOutputString;
    WCHAR    wszPrefix[] = L"SampleShim says: ";

    // A single line of code should never be more than 80 characters long.
    wszNewOutputString = (LPWSTR) malloc( sizeof(WCHAR) *
                                          ( wcslen( wszOutputString ) +
                                            wcslen( wszPrefix ) + 1 ) );

    DPF(eDbgLevelUser, "APIHook_OutputDebugStringW called.\n");
    
    // Make sure to use wide-character versions of all string manipulation
    // routines where appropriate.
    wcscpy( wszNewOutputString, wszPrefix );
    wcscat( wszNewOutputString, wszOutputString );

    LOOKUP_APIHOOK(OutputDebugStringW)( wszNewOutputString );

    free( wszNewOutputString );

    return;
}

/*++

 Register hooked functions

--*/

VOID
InitializeHooks(DWORD fdwReason)
{
    if (fdwReason != DLL_PROCESS_ATTACH) return;

    // Don't touch this line.
    INIT_HOOKS(APIHOOK_Count);

    // Add APIs that you wish to hook here. All API prototypes
    // must be declared in Hooks\inc\ShimProto.h. Compiler errors
    // will result if you forget to add them.
    DECLARE_APIHOOK(KERNEL32.DLL, OutputDebugStringA);
    DECLARE_APIHOOK(KERNEL32.DLL, OutputDebugStringW);

    // If you have any more initialization to do, do it here.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\dbaccess.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        dbaccess.c

    Abstract:

        This module implements APIs to access the shim database.

    Author:

        dmunsil     created     sometime in 1999

    Revision History:

        several people contributed (vadimb, clupu, ...)

--*/

#include "sdbp.h"

#if defined(KERNEL_MODE) && defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, SdbReleaseDatabase)
#pragma alloc_text(PAGE, SdbGetDatabaseVersion)
#pragma alloc_text(PAGE, SdbGetDatabaseInformation)
#pragma alloc_text(PAGE, SdbGetDatabaseID)
#pragma alloc_text(PAGE, SdbFreeDatabaseInformation)
#pragma alloc_text(PAGE, SdbGetDatabaseInformationByName)
#pragma alloc_text(PAGE, SdbpGetDatabaseDescriptionPtr)
#pragma alloc_text(PAGE, SdbpReadMappedData)
#pragma alloc_text(PAGE, SdbpGetMappedData)
#pragma alloc_text(PAGE, SdbOpenDatabase)
#pragma alloc_text(PAGE, SdbpOpenDatabaseInMemory)
#pragma alloc_text(PAGE, SdbCloseDatabaseRead)
#pragma alloc_text(PAGE, SdbpOpenAndMapDB)
#pragma alloc_text(PAGE, SdbpUnmapAndCloseDB)
#pragma alloc_text(PAGE, SdbGetTagFromTagID)
#pragma alloc_text(PAGE, SdbpGetNextTagId)
#pragma alloc_text(PAGE, SdbGetFirstChild)
#pragma alloc_text(PAGE, SdbGetNextChild)
#pragma alloc_text(PAGE, SdbpCreateSearchPathPartsFromPath)
#endif // KERNEL_MODE && ALLOC_PRAGMA



void
SdbReleaseDatabase(
    IN  HSDB hSDB               // handle to the database channel
    )
/*++
    Return: void.

    Desc:   This API should be called in pair with SdbInitDatabase.
--*/
{
    PSDBCONTEXT pContext = (PSDBCONTEXT)hSDB;

    assert(pContext != NULL);

    //
    // Do everything under a try/except block so we don't screw the caller
    // if the databases are corrupt.
    //
    __try {

#ifndef KERNEL_MODE

        SdbpCleanupLocalDatabaseSupport(hSDB);

        if (pContext->rgSDB[2].dwFlags & SDBENTRY_VALID_ENTRY) {
            SdbCloseDatabaseRead(pContext->rgSDB[2].pdb);
        }

#endif // KERNEL_MODE
        
        if (pContext->pdbTest != NULL) {
            SdbCloseDatabaseRead(pContext->pdbTest);
        }

        if (pContext->pdbMain != NULL) {
            SdbCloseDatabaseRead(pContext->pdbMain);
        }

        //
        // Cleanup attributes.
        //
        SdbpCleanupAttributeMgr(pContext);

#ifndef KERNEL_MODE

        //
        // Cleanup user sdb cache
        //
        SdbpCleanupUserSDBCache(pContext);

#endif // KERNEL_MODE

#if defined(NT_MODE) || defined(WIN32U_MODE)
        if (SDBCONTEXT_IS_INSTRUMENTED(pContext)) {
            SdbpCloseDebugPipe(SDBCONTEXT_GET_PIPE(pContext));
        }
#endif

        SdbFree(pContext);

    } __except (SHIM_EXCEPT_HANDLER) {
        ;
    }
}

BOOL
SdbGetDatabaseVersion(
    IN  LPCTSTR pszFileName,    // the file name
    OUT LPDWORD lpdwMajor,      // store the major version of the database
    OUT LPDWORD lpdwMinor       // store the minor version of the database
    )
/*++
    Return: void.

    Desc:   This API should be called in pair with SdbInitDatabase.
--*/
{
    PDB             pdb;
    SDBDATABASEINFO DBInfo;
    BOOL            bSuccess;

    pdb = SdbAlloc(sizeof(DB));

    if (pdb == NULL) {
        DBGPRINT((sdlError, "SdbGetDatabaseVersion", "Can't allocate DB structure.\n"));
        return FALSE;
    }

    if (!SdbpOpenAndMapDB(pdb, pszFileName, DOS_PATH)) {
        DBGPRINT((sdlError,
                  "SdbGetDatabaseVersion",
                  "Failed to open the database \"%s\".\n",
                  pszFileName));
        goto err1;
    }

    pdb->bWrite = FALSE;
    pdb->dwSize = SdbpGetFileSize(pdb->hFile);

    if (!SdbGetDatabaseInformation(pdb, &DBInfo)) {
        DBGPRINT((sdlError, "SdbGetDatabaseVersion", "Can't read database information.\n"));
        goto err2;
    }

    *lpdwMajor = DBInfo.dwVersionMajor;
    *lpdwMinor = DBInfo.dwVersionMinor;

err2:
    SdbpUnmapAndCloseDB(pdb);

err1:
    SdbFree(pdb);

    return TRUE;
}

BOOL
SDBAPI
SdbGetDatabaseInformation(
    IN  PDB              pdb,
    OUT PSDBDATABASEINFO pSdbInfo
    )
{
    DB_HEADER DBHeader;
    BOOL      bReturn = FALSE;

    RtlZeroMemory(pSdbInfo, sizeof(*pSdbInfo));

    if (!SdbpReadMappedData(pdb, 0, &DBHeader, sizeof(DB_HEADER))) {
        DBGPRINT((sdlError, "SdbGetDatabaseInformation", "Can't read database header.\n"));
        goto errHandle;
    }

    if (DBHeader.dwMagic != SHIMDB_MAGIC) {
        DBGPRINT((sdlError,
                  "SdbGetDatabaseInformation",
                  "Magic doesn't match. Magic: 0x%08X, Expected: 0x%08X.\n",
                  DBHeader.dwMagic,
                  (DWORD)SHIMDB_MAGIC));
        goto errHandle;
    }

    pSdbInfo->dwVersionMajor = DBHeader.dwMajorVersion;
    pSdbInfo->dwVersionMinor = DBHeader.dwMinorVersion;

    //
    // Id and description are optional
    //
    if (SdbGetDatabaseID(pdb, &pSdbInfo->guidDB)) {
        pSdbInfo->dwFlags |= DBINFO_GUID_VALID;
    }

    //
    // Now try to get valid description.
    //
    pSdbInfo->pszDescription = (LPTSTR)SdbpGetDatabaseDescriptionPtr(pdb);

    bReturn = TRUE;

errHandle:

    return bReturn;
}

BOOL
SDBAPI
SdbGetDatabaseID(
    IN  PDB   pdb,
    OUT GUID* pguidDB
    )
{
    TAGID tiDatabase;
    TAGID tiGuidID;
    BOOL  bReturn = FALSE;

    if (!(pdb->dwFlags & DB_GUID_VALID)) {
        tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);
        if (!tiDatabase) {
            DBGPRINT((sdlError, "SdbGetDatabaseID", "Failed to get root tag\n"));
            goto errHandle;
        }

        tiGuidID = SdbFindFirstTag(pdb, tiDatabase, TAG_DATABASE_ID);
        if (!tiGuidID) {
            DBGPRINT((sdlWarning, "SdbGetDatabaseID", "Failed to get the database id\n"));
            goto errHandle;
        }

        if (!SdbReadBinaryTag(pdb, tiGuidID, (PBYTE)&pdb->guidDB, sizeof(GUID))) {
            DBGPRINT((sdlError,
                      "SdbGetDatabaseID",
                      "Failed to read database id 0x%lx\n",
                      tiGuidID));
            goto errHandle;
        }

        pdb->dwFlags |= DB_GUID_VALID;
    }

    //
    // If we are here, GUID retrieval was successful.
    //
    if (pdb->dwFlags & DB_GUID_VALID) {
        RtlMoveMemory(pguidDB, &pdb->guidDB, sizeof(GUID));
        bReturn = TRUE;
    }

errHandle:

    return bReturn;
}

VOID
SDBAPI
SdbFreeDatabaseInformation(
    IN PSDBDATABASEINFO pDBInfo
    )
{
    if (pDBInfo != NULL && (pDBInfo->dwFlags & DBINFO_SDBALLOC)) {
        SdbFree(pDBInfo);
    }
}


BOOL
SDBAPI
SdbGetDatabaseInformationByName(
    IN  LPCTSTR           pszDatabase,
    OUT PSDBDATABASEINFO* ppdbInfo
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   This function retrieves database information given the database name
            the pointer to the SDBDATABASEINFO should be freed by the caller using
            SdbFreeDatabaseInformation
--*/
{
    PDB              pdb = NULL;
    DWORD            dwDescriptionSize = 0;
    PSDBDATABASEINFO pDbInfo = NULL;
    BOOL             bReturn = FALSE;
    SDBDATABASEINFO  DbInfo;

    assert(ppdbInfo != NULL);

    pdb = SdbOpenDatabase(pszDatabase, DOS_PATH);
    if (pdb == NULL) {
        DBGPRINT((sdlError,
                  "SdbGetDatabaseInformationByName",
                  "Error opening database file \"%s\"\n",
                  pszDatabase));
        return FALSE;
    }

    //
    // Find the size of the database description
    //
    if (!SdbGetDatabaseInformation(pdb, &DbInfo)) {
        DBGPRINT((sdlError,
                  "SdbGetDatabaseInformationByName",
                  "Error Retrieving Database information for \"%s\"\n",
                  pszDatabase));
        goto HandleError;
    }

    if (DbInfo.pszDescription != NULL) {
        dwDescriptionSize = (_tcslen(DbInfo.pszDescription) + 1) * sizeof(TCHAR);
    }

    pDbInfo = (PSDBDATABASEINFO)SdbAlloc(sizeof(SDBDATABASEINFO) + dwDescriptionSize);
    if (pDbInfo == NULL) {
        DBGPRINT((sdlError,
                  "SdbGetDatabaseInformationByName",
                  "Error allocating 0x%lx bytes for database information \"%s\"\n",
                  sizeof(SDBDATABASEINFO) + dwDescriptionSize,
                  pszDatabase));
        goto HandleError;
    }

    RtlMoveMemory(pDbInfo, &DbInfo, sizeof(DbInfo));

    pDbInfo->dwFlags |= DBINFO_SDBALLOC;

    //
    // Make it "self-contained"
    //
    if (DbInfo.pszDescription != NULL) {
        pDbInfo->pszDescription = (LPTSTR)(pDbInfo + 1);
        RtlMoveMemory(pDbInfo->pszDescription, DbInfo.pszDescription, dwDescriptionSize);
    }

    *ppdbInfo = pDbInfo;
    bReturn = TRUE;

HandleError:
    if (pdb != NULL) {
        SdbCloseDatabaseRead(pdb);
    }

    if (!bReturn) {
        if (pDbInfo != NULL) {
            SdbFree(pDbInfo);
        }
    }

    return bReturn;
}


LPCTSTR
SdbpGetDatabaseDescriptionPtr(
    IN PDB pdb
    )
{
    TAGID   tiDatabase;
    TAGID   tiName;
    LPCTSTR lpszDescription = NULL;

    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);
    
    if (!tiDatabase) {
        DBGPRINT((sdlError,
                  "SdbpGetDatabaseDescriptionPtr",
                  "Failed to get database tag, db is corrupt\n"));
        goto errHandle;
    }

    tiName = SdbFindFirstTag(pdb, tiDatabase, TAG_NAME);
    if (tiName) {
        lpszDescription = SdbGetStringTagPtr(pdb, tiName);
    }

errHandle:
    return lpszDescription;
}


BOOL
SdbpReadMappedData(
    IN  PDB   pdb,              // database handle
    IN  DWORD dwOffset,         // offset in the database where the data is to be copied from
    OUT PVOID pBuffer,          // destination buffer
    IN  DWORD dwSize            // the region size
    )
/*++
    Return: TRUE if successful, FALSE otherwise.

    Desc:   This function reads the data (dwSize bytes) from the database
            starting at offset dwOffset into the buffer pBuffer provided
            by the caller
--*/
{

    if (pdb->dwSize < dwOffset + dwSize) {
        DBGPRINT((sdlError,
                  "SdbpReadMappedData",
                  "Attempt to read past the end of the database offset 0x%lx size 0x%lx (0x%lx)\n",
                  dwOffset,
                  dwSize,
                  pdb->dwSize));
        return FALSE;
    }

    assert(pdb->pBase != NULL);

    memcpy(pBuffer, (PBYTE)pdb->pBase + dwOffset, dwSize);
    return TRUE;
}

PVOID
SdbpGetMappedData(
    IN  PDB   pdb,              // database handle
    IN  DWORD dwOffset          // offset in the database
    )
/*++
    Return: The pointer to the data.

    Desc:   This function returns the pointer to data within the database at
            offset dwOffset. It will return FALSE if dwOffset is invalid.
--*/
{
    assert(pdb);

    assert(pdb->pBase != NULL);

    if (dwOffset >= pdb->dwSize) {
        DBGPRINT((sdlError,
                  "SdbpGetMappedData",
                  "Trying to read mapped data past the end of the database offset 0x%x size 0x%x\n",
                  dwOffset,
                  pdb->dwSize));
        assert(FALSE);
        return NULL;
    }
    
    return (PBYTE)pdb->pBase + dwOffset;
}


PDB
SdbOpenDatabase(
    IN  LPCTSTR   szPath,       // full path to the DB
    IN  PATH_TYPE eType         // DOS_PATH for standard paths,
                                // NT_PATH  for internal NT paths
    )
/*++
    Return: A pointer to the open DB, or NULL on failure.

    Desc:   Opens up a shim database file, checks version and magic numbers, and creates
            a DB record that is passed back as a PDB. eType can be NT_PATH or DOS_PATH,
            and tells whether we are using NTDLL internal paths, or the more familiar
            DOS paths.
--*/
{
    PDB         pdb;
    DB_HEADER   DBHeader;
    BOOL        bSuccess;

    pdb = SdbAlloc(sizeof(DB));

    if (pdb == NULL) {
        DBGPRINT((sdlError, "SdbOpenDatabase", "Can't allocate DB structure.\n"));
        return NULL;
    }

    if (!SdbpOpenAndMapDB(pdb, szPath, eType)) {
        DBGPRINT((sdlInfo,
                  "SdbOpenDatabase",
                  "Failed to open the database \"%s\".\n",
                  szPath));
        goto err1;
    }

    pdb->bWrite = FALSE;
    pdb->dwSize = SdbpGetFileSize(pdb->hFile);

    //
    // Check version and magic.
    //
    if (!SdbpReadMappedData(pdb, 0, &DBHeader, sizeof(DB_HEADER))) {
        DBGPRINT((sdlError, "SdbOpenDatabase", "Can't read database header.\n"));
        goto err2;
    }

    if (DBHeader.dwMagic != SHIMDB_MAGIC) {
        DBGPRINT((sdlError, "SdbOpenDatbase", "Magic does not match 0x%lx\n", DBHeader.dwMagic));
        goto err2;
    }

    if (DBHeader.dwMajorVersion == 1) {
        DBGPRINT((sdlWarning, "SdbOpenDatabase", "Reading under hack from older database\n"));
        pdb->bUnalignedRead = TRUE;
    } else if (DBHeader.dwMajorVersion != SHIMDB_MAJOR_VERSION) {

        DBGPRINT((sdlError, "SdbOpenDatabase",
                  "MajorVersion mismatch, MajorVersion 0x%lx Expected 0x%lx\n",
                  DBHeader.dwMajorVersion, (DWORD)SHIMDB_MAJOR_VERSION));
        goto err2;
    }

    if (DBHeader.dwMagic != SHIMDB_MAGIC || DBHeader.dwMajorVersion != SHIMDB_MAJOR_VERSION) {
        DBGPRINT((sdlError,
                  "SdbOpenDatabase",
                  "Magic or MajorVersion doesn't match."
                  "Magic: %08X, Expected: %08X; MajorVersion: %08X, Expected: %08X.\n",
                  DBHeader.dwMagic,
                  (DWORD)SHIMDB_MAGIC,
                  DBHeader.dwMajorVersion,
                  (DWORD)SHIMDB_MAJOR_VERSION));
        goto err2;
    }

    return pdb;

err2:
    SdbpUnmapAndCloseDB(pdb);

err1:
    SdbFree(pdb);

    return NULL;
}


PDB
SdbpOpenDatabaseInMemory(
    IN  LPVOID pImageDatabase,  // Pointer to the image of the mapped database
    IN  DWORD  dwSize           // the size of the file in bytes
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    PDB       pdb = NULL;
    DB_HEADER DBHeader;

    pdb = SdbAlloc(sizeof(DB));
    if (pdb == NULL) {
        DBGPRINT((sdlError,
                  "SdbpOpenDatabaseInMemory",
                  "Failed to allocate DB structure\n"));
        return NULL;
    }

    pdb->bWrite   = FALSE;
    pdb->hFile    = INVALID_HANDLE_VALUE;
    pdb->pBase    = pImageDatabase;
    pdb->dwSize   = dwSize;
    pdb->dwFlags |= DB_IN_MEMORY;

    if (!SdbpReadMappedData(pdb, 0, &DBHeader, sizeof(DB_HEADER))) {
        DBGPRINT((sdlError,
                  "SdbpOpenDatabaseInMemory",
                  "Can't read database header\n"));
        goto ErrHandle;
    }

    if (DBHeader.dwMagic != SHIMDB_MAGIC || DBHeader.dwMajorVersion != SHIMDB_MAJOR_VERSION) {
        DBGPRINT((sdlError,
                  "SdbpOpenDatabaseInMemory",
                  "Magic or MajorVersion doesn't match."
                  "Magic: %08X, Expected: %08X; MajorVersion: %08X, Expected: %08X.\n",
                  DBHeader.dwMagic,
                  (DWORD)SHIMDB_MAGIC,
                  DBHeader.dwMajorVersion,
                  (DWORD)SHIMDB_MAJOR_VERSION));
        goto ErrHandle;
    }

    return pdb;

ErrHandle:
    if (pdb != NULL) {
        SdbFree(pdb);
    }

    return NULL;
}


void
SdbCloseDatabaseRead(
    IN  PDB pdb                 // handle to the DB to close
    )
/*++
    Return: void.

    Desc:   Closes a database that was opened for read access as it is the case
            with the majority of our run-time code.
--*/
{
    assert(pdb);
    assert(!pdb->bWrite);

    if (pdb->pBase != NULL) {

        SdbpUnmapAndCloseDB(pdb);

        CLEANUP_STRING_CACHE_READ(pdb);

        SdbFree(pdb);
    }
}

BOOL
SdbpOpenAndMapDB(
    IN  PDB       pdb,          // pdb to fill in with mapping handles and whatnot
    IN  LPCTSTR   pszPath,      // full path of file to open
    IN  PATH_TYPE eType         // DOS_PATH for standard paths, NT_PATH for nt internal paths
    )
/*++
    Return: TRUE if successful, FALSE otherwise.

    Desc:   Opens a db file, maps it into memory, and sets up the global vars in the pdb.
--*/
{
    NTSTATUS      status;
    IMAGEFILEDATA ImageData;

    ImageData.dwFlags = 0;

    if (!SdbpOpenAndMapFile(pszPath, &ImageData, eType)) {
        DBGPRINT((sdlInfo, "SdbpOpenAndMapDB", "Failed to open file \"%s\"\n", pszPath));
        return FALSE;
    }

    pdb->hFile    = ImageData.hFile;
    pdb->hSection = ImageData.hSection;
    pdb->pBase    = ImageData.pBase;
    pdb->dwSize   = (DWORD)ImageData.ViewSize;

    return TRUE;
}

BOOL
SdbpUnmapAndCloseDB(
    IN  PDB pdb                 // pdb to close the files and mapping info
    )
/*++
    Return: TRUE if successful, FALSE otherwise.

    Desc:   Cleans up for the specified database.
--*/
{
    BOOL          bReturn;
    IMAGEFILEDATA ImageData;

    if (pdb->dwFlags & DB_IN_MEMORY) {
        //
        // database in memory
        //
        pdb->pBase  = NULL;
        pdb->dwSize = 0;
        return TRUE;
    }

    ImageData.dwFlags  = 0;
    ImageData.hFile    = pdb->hFile;
    ImageData.hSection = pdb->hSection;
    ImageData.pBase    = pdb->pBase;

    bReturn = SdbpUnmapAndCloseFile(&ImageData);

    //
    // once we nuke the file -- reset values
    //
    if (bReturn) {
        pdb->hFile    = INVALID_HANDLE_VALUE;
        pdb->hSection = NULL;
        pdb->pBase    = NULL;
    }

    return bReturn;
}

TAG
SdbGetTagFromTagID(
    IN  PDB   pdb,              // DB to use
    IN  TAGID tiWhich           // record to get the tag for
    )
/*++
    Return: Just the TAG (the word-sized header) of the record.

    Desc:   Returns just the TAG that a TAGID points to.
--*/
{
    TAG tWhich = TAG_NULL;

    assert(pdb && tiWhich);

    if (!SdbpReadMappedData(pdb, (DWORD)tiWhich, &tWhich, sizeof(TAG))) {
        DBGPRINT((sdlError, "SdbGetTagFromTagID", "Error reading data.\n"));
        return TAG_NULL;
    }

    return tWhich;
}


TAGID
SdbpGetNextTagId(
    IN  PDB   pdb,              // DB to look in
    IN  TAGID tiWhich           // tag to get the next sibling of
    )
/*++
    Return: The next tag after the one passed in, or one past end of file if no more.

    Desc:   Gets the TAGID of the next tag in the DB, or a virtual
            TAGID that is one past the end of the file, which means
            there are no more tags in the DB.

            This is an internal function, and shouldn't be called by
            external functions, as there's no clean way to tell you've
            walked off the end of the file. Use tiGetNextChildTag instead.
--*/
{
    //
    // If the tag is an unfinished list tag, point to the end of the file.
    //
    if (GETTAGTYPE(SdbGetTagFromTagID(pdb, tiWhich)) == TAG_TYPE_LIST &&
        SdbGetTagDataSize(pdb, tiWhich) == TAG_SIZE_UNFINISHED) {

        DBGPRINT((sdlError, "SdbpGetNextTagId", "Reading from unfinished list.\n"));
        return pdb->dwSize;
    } else {
        return (TAGID)(tiWhich + GETTAGDATAOFFSET(pdb, tiWhich));
    }
}

TAGID
SdbGetFirstChild(
    IN  PDB   pdb,              // DB to use
    IN  TAGID tiParent          // parent to look in
    )
/*++
    Return: The first child of tiParent, or TAGID_NULL if there are none.

    Desc:   Returns the first child of tiParent, which must point to a tag
            of basic type LIST.
--*/
{
    TAGID tiParentEnd;
    TAGID tiReturn;

    assert(pdb);

    if (tiParent != TAGID_ROOT &&
        GETTAGTYPE(SdbGetTagFromTagID(pdb, tiParent)) != TAG_TYPE_LIST) {

        DBGPRINT((sdlError,
                  "SdbGetFirstChild",
                  "Trying to operate on non-list, non-root tag.\n"));
        return TAGID_NULL;
    }

    if (tiParent == TAGID_ROOT) {
        tiParentEnd = pdb->dwSize;

        //
        // Skip past the header.
        //
        tiReturn = sizeof(DB_HEADER);

    } else {
        tiParentEnd = SdbpGetNextTagId(pdb, tiParent);

        //
        // Just skip past the tag and size params.
        //
        tiReturn = tiParent + sizeof(TAG) + sizeof(DWORD);
    }


    if (tiReturn >= tiParentEnd) {
        tiReturn = TAGID_NULL;
    }

    return tiReturn;
}


TAGID
SdbGetNextChild(
    IN  PDB   pdb,              // DB to use
    IN  TAGID tiParent,         // parent to look in
    IN  TAGID tiPrev            // previously found child
    )
/*++
    Return: The next child of tiParent, or TAGID_NULL if there are none.

    Desc:   Returns the next child of tiParent after tiPrev. tiParent must point
            to a tag of basic type LIST.
--*/
{
    TAGID tiParentEnd;
    TAGID tiReturn;

    assert(pdb && tiPrev);

    if (tiParent != TAGID_ROOT &&
        GETTAGTYPE(SdbGetTagFromTagID(pdb, tiParent)) != TAG_TYPE_LIST) {

        DBGPRINT((sdlError,
                  "SdbGetNextChild",
                  "Trying to operate on non-list, non-root tag.\n"));
        return TAGID_NULL;
    }

    if (tiParent == TAGID_ROOT) {
        tiParentEnd = pdb->dwSize;
    } else {
        tiParentEnd = SdbpGetNextTagId(pdb, tiParent);
    }

    //
    // Get the next tag.
    //
    tiReturn = SdbpGetNextTagId(pdb, tiPrev);

    if (tiReturn >= tiParentEnd) {
        tiReturn = TAGID_NULL;
    }

    return tiReturn;
}


BOOL
SdbpCreateSearchPathPartsFromPath(
    IN  LPCTSTR           pszPath,
    OUT PSEARCHPATHPARTS* ppSearchPathParts
    )
/*++
    Return: Returns TRUE on success, FALSE on failure.

    Desc:   This function breaks down a search path (PROCESS_HISTORY) into
            parts, with each part specifying a directory where the search
            for a matching binary to take place. Directories are organized
            in such a way that the last executed binary provides the first
            search path.
--*/
{

    LPCTSTR          pszDir = pszPath;
    LPCTSTR          pszDirEnd = NULL;
    ULONG            nParts = 0;
    ULONG            i      = 0;
    PSEARCHPATHPARTS pSearchPathParts = NULL;

    if (pszPath == NULL) {
        DBGPRINT((sdlError,
                  "SdbpCreateSearchPathPartsFromPath",
                  "Invalid argument.\n"));
        return FALSE;
    }

    //
    // We count search path parts by counting semicolons in the path string
    // numberOfParts = numberOfSemicolons + 1
    //
    pszDir = pszPath;

    if (*pszDir != 0) {
        //
        // At least one part there...
        //
        nParts++;
    }

    while ((pszDir = _tcschr(pszDir, _T(';'))) != NULL) {
        pszDir++;
        nParts++;
    }

    //
    // nParts now has the number of parts in a search path.
    //
    pSearchPathParts = (PSEARCHPATHPARTS)SdbAlloc(sizeof(SEARCHPATHPARTS) +
                                                  sizeof(SEARCHPATHPART) * nParts);

    if (pSearchPathParts == NULL) {
        DBGPRINT((sdlError,
                  "SdbpCreateSearchPathPartsFromPath",
                  "Failed to allocate %d bytes.\n",
                  sizeof(SEARCHPATHPARTS) + sizeof(SEARCHPATHPART) * nParts));
        return FALSE;
    }

    pSearchPathParts->PartCount = nParts;

    pszDir = pszPath + _tcslen(pszPath);

    while (pszDir >= pszPath) {
        if (*pszDir == _T('\\') && pszDirEnd == NULL) {
            //
            // Points to the backslash
            //
            pszDirEnd = pszDir;
        }

        if ((*pszDir == _T(';') || pszPath == pszDir) && pszDirEnd != NULL) {
            //
            // At this point we should have an end to the string,
            // If not that means we are stepping from a recently found path
            //
            if (*pszDir == _T(';')) {
                pszDir++;
            }

            pSearchPathParts->Parts[i].pszPart    = pszDir;
            pSearchPathParts->Parts[i].PartLength = (ULONG)(pszDirEnd - pszDir + 1);

            i++;

            pszDirEnd = NULL;

        }

        pszDir--;
    }

    *ppSearchPathParts = pSearchPathParts;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\doc\msvcsampleshim\inc\shimlib.h ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:

    AhCall.h

 Abstract:

    Definitions for use by all modules

 Notes:

    None

 History:

    12/09/1999 robkenny Created
    01/10/2000 linstev  Format to new style

--*/

#ifndef _SHIMLIB_H_
#define _SHIMLIB_H_

#include <WinDef.h>

BOOL        IsOnCDRomW( LPCWSTR wszFileName );
BOOL        IsOnCDRomA( LPCSTR szFileName );
BOOL        IsOnCDRom( HANDLE hFile );

VOID        MassagePathW( LPCWSTR pwszOldPath, LPWSTR pwszNewPath );
VOID        MassagePathA( LPCSTR pszOldPath, LPSTR pszNewPath );

char *      StringDuplicateA( const char * strToCopy );
wchar_t *   StringDuplicateW( const wchar_t * wstrToCopy );

VOID        SkipBlanksA(const char *& str);
VOID        SkipBlanksW(const WCHAR *& str);

char *      __cdecl stristr(const char* string, const char * strCharSet);
WCHAR *     __cdecl wcsistr(const WCHAR* string, const WCHAR * strCharSet);

int         SafeStringCopyA(char *  lpDest, DWORD nDestSize, const char *  lpSrc, DWORD nSrcLen);
int         SafeStringCopyW(WCHAR * lpDest, DWORD nDestSize, const WCHAR * lpSrc, DWORD nSrcLen);

BOOL        StringSubstituteA(const char * lpOrig, const char * lpMatch, const char * lpSubstitute, DWORD dwCorrectedSize, char * lpCorrected, DWORD * nCorrectedLen, DWORD * nCorrectedTotalSize);
BOOL        StringSubstituteW(const WCHAR * lpOrig, const WCHAR * lpMatch, const WCHAR * lpSubstitute, WCHAR * lpCorrected, DWORD dwCorrectedSize, DWORD * nCorrectedLen, DWORD * nCorrectedTotalSize);
BOOL        StringISubstituteA(const char * lpOrig, const char * lpMatch, const char * lpSubstitute, DWORD dwCorrectedSize, char * lpCorrected, DWORD * nCorrectedLen, DWORD * nCorrectedTotalSize);
BOOL        StringISubstituteW(const WCHAR * lpOrig, const WCHAR * lpMatch, const WCHAR * lpSubstitute, WCHAR * lpCorrected, DWORD dwCorrectedSize, DWORD * nCorrectedLen, DWORD * nCorrectedTotalSize);



#endif // _SHIMLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\doc\msvcsampleshim\inc\shimproto.h ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:

    ShimProto.h

 Abstract:

    Definitions for use by all modules

 Notes:

    None

 History:

    12/09/1999 robkenny Created
    01/10/2000 linstev  Format to new style

--*/

#ifndef _SHIMPROTO_H_
#define _SHIMPROTO_H_

typedef void      (WINAPI *_pfn_OutputDebugStringA)( LPCSTR lpString );
typedef void      (WINAPI *_pfn_OutputDebugStringW)( LPCWSTR lpString );

typedef BOOL      (WINAPI *_pfn_CloseHandle)( HANDLE hObject );
typedef BOOL      (WINAPI *_pfn_CreateProcessA)(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
typedef BOOL      (WINAPI *_pfn_CreateProcessW)(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
typedef HANDLE    (WINAPI *_pfn_CreateSemaphoreA)(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCTSTR lpName);
typedef HWND      (WINAPI *_pfn_CreateWindowExA)(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
typedef HWND      (WINAPI *_pfn_CreateWindowExW)(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
typedef ATOM      (WINAPI *_pfn_RegisterClassA)(CONST WNDCLASSA *lpWndClass);
typedef ATOM      (WINAPI *_pfn_RegisterClassW)(CONST WNDCLASSW *lpWndClass);
typedef ATOM      (WINAPI *_pfn_RegisterClassExA)(CONST WNDCLASSEXA *lpWndClass);
typedef ATOM      (WINAPI *_pfn_RegisterClassExW)(CONST WNDCLASSEXW *lpWndClass);
typedef HWND      (WINAPI *_pfn_CreateDialogParamA)(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
typedef HWND      (WINAPI *_pfn_CreateDialogParamW)(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
typedef HWND      (WINAPI *_pfn_CreateDialogIndirectParamA)(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM lInitParam);
typedef HWND      (WINAPI *_pfn_CreateDialogIndirectParamW)(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM lInitParam);
typedef HWND      (WINAPI *_pfn_CreateDialogIndirectParamAorW)(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM lInitParam);

typedef DWORD     (WINAPI *_pfn_GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
  
typedef BOOL      (WINAPI *_pfn_CopyFileA)( LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists);
typedef BOOL      (WINAPI *_pfn_CopyFileW)( LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists);
//typedef BOOL      (WINAPI *_pfn_CopyFileExA)( LPCSTR lpExistingFileName,LPCSTR lpNewFileName,LPPROGRESS_ROUTINE lpProgressRoutine,LPVOID lpData,LPBOOL pbCancel,DWORD dwCopyFlags );
//typedef BOOL      (WINAPI *_pfn_CopyFileExW)( LPCWSTR lpExistingFileName,LPCWSTR lpNewFileName,LPPROGRESS_ROUTINE lpProgressRoutine,LPVOID lpData,LPBOOL pbCancel,DWORD dwCopyFlags );
typedef BOOL      (WINAPI *_pfn_CreateDirectoryA)( LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef BOOL      (WINAPI *_pfn_CreateDirectoryW)( LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef BOOL      (WINAPI *_pfn_CreateDirectoryExA)( LPCSTR lpTemplateDirectory,LPCSTR lpNewDirectory,LPSECURITY_ATTRIBUTES lpSecurityAttributes );
typedef BOOL      (WINAPI *_pfn_CreateDirectoryExW)( LPCWSTR lpTemplateDirectory,LPCWSTR lpNewDirectory,LPSECURITY_ATTRIBUTES lpSecurityAttributes );
typedef BOOL      (WINAPI *_pfn_DeleteFileA)( LPCSTR lpFileName );
typedef BOOL      (WINAPI *_pfn_DeleteFileW)( LPCWSTR lpFileName );
typedef BOOL      (WINAPI *_pfn_GetBinaryTypeA)( LPCSTR lpApplicationName, LPDWORD lpBinaryType);
typedef BOOL      (WINAPI *_pfn_GetBinaryTypeW)( LPCWSTR lpApplicationName, LPDWORD lpBinaryType);
typedef DWORD     (WINAPI *_pfn_GetFullPathNameA)( LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart);
typedef DWORD     (WINAPI *_pfn_GetFullPathNameW)( LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
typedef DWORD     (WINAPI *_pfn_GetShortPathNameA)(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer );
typedef DWORD     (WINAPI *_pfn_GetShortPathNameW)(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer );
typedef BOOL      (WINAPI *_pfn_MoveFileA)(LPCSTR lpExistingFileName,  LPCSTR lpNewFileName);
typedef BOOL      (WINAPI *_pfn_MoveFileW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
typedef BOOL      (WINAPI *_pfn_MoveFileExA)(LPCSTR lpExistingFileName, LPCSTR lpNewNewFileName, DWORD dwFlags);
typedef BOOL      (WINAPI *_pfn_MoveFileExW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewNewFileName, DWORD dwFlags);
//typedef BOOL      (WINAPI *_pfn_MoveFileWithProgressA)(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags);
//typedef BOOL      (WINAPI *_pfn_MoveFileWithProgressW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags);

typedef BOOL      (WINAPI *_pfn_SetCurrentDirectoryA)(LPCSTR lpPathName);
typedef BOOL      (WINAPI *_pfn_SetCurrentDirectoryW)(LPCWSTR lpPathName);
typedef HFILE     (WINAPI *_pfn_OpenFile)(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle);

typedef HANDLE    (WINAPI *_pfn_CreateFileA)( LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
typedef HANDLE    (WINAPI *_pfn_CreateFileW)( LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
typedef BOOL      (WINAPI *_pfn_DeleteFileA)( LPCSTR lpFileName);
typedef BOOL      (WINAPI *_pfn_DeleteFileW)( LPCWSTR lpFileName);
typedef BOOL      (WINAPI *_pfn_DeleteObject)(HGDIOBJ hObject);

typedef BOOL      (WINAPI *_pfn_ExitWindowsEx)( UINT uFlags, DWORD dwReserved );

typedef BOOL      (WINAPI *_pfn_FreeLibrary)(HMODULE hLibModule);

typedef HANDLE    (WINAPI *_pfn_FindFirstFileA)     (LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
typedef HANDLE    (WINAPI *_pfn_FindFirstFileW)     (LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
//typedef HANDLE    (WINAPI *_pfn_FindFirstFileExA)   (LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags);
//typedef HANDLE    (WINAPI *_pfn_FindFirstFileExW)   (LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags);
typedef BOOL      (WINAPI *_pfn_FindNextFileA)      (HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
typedef BOOL      (WINAPI *_pfn_FindNextFileW)      (HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
typedef HANDLE    (WINAPI *_pfn_FindClose)          (HANDLE hFindFile);

typedef LPSTR     (WINAPI *_pfn_GetCommandLineA)(VOID);
typedef LPWSTR    (WINAPI *_pfn_GetCommandLineW)(VOID);
typedef HRESULT   (WINAPI *_pfn_DllGetClassObject)( REFCLSID rclsid, REFIID riid, PVOID * ppv );
typedef HRESULT   (WINAPI *_pfn_DirectDrawCreate)( GUID FAR *lpGUID, LPVOID *lplpDD, IUnknown* pUnkOuter ); 
typedef HRESULT   (WINAPI *_pfn_DirectDrawCreateEx)( GUID FAR *lpGUID, LPVOID *lplpDD, REFIID iid, IUnknown* pUnkOuter );

typedef BOOL      (WINAPI *_pfn_GetDiskFreeSpaceA)( LPCSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters);
typedef DWORD     (WINAPI *_pfn_GetFileAttributesA)(LPCSTR lpFileName);
typedef DWORD     (WINAPI *_pfn_GetFileAttributesW)(LPCWSTR wcsFileName);
typedef BOOL      (WINAPI *_pfn_GetFileAttributesExA)(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
typedef BOOL      (WINAPI *_pfn_GetFileAttributesExW)(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
typedef BOOL      (WINAPI *_pfn_GetFileInformationByHandle)(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION);
typedef DWORD     (WINAPI *_pfn_GetFileVersionInfoSizeA)( LPSTR lptstrFilename, LPDWORD lpdwHandle );
typedef BOOL      (WINAPI *_pfn_GetFileVersionInfoA)( LPSTR lpstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
typedef BOOL      (WINAPI *_pfn_GetFileVersionInfoW)( LPWSTR lpstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);

typedef UINT      (WINAPI *_pfn_GetPrivateProfileIntA)(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName);
typedef UINT      (WINAPI *_pfn_GetPrivateProfileIntW)(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName);
typedef DWORD     (WINAPI *_pfn_GetPrivateProfileSectionA)(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);
typedef DWORD     (WINAPI *_pfn_GetPrivateProfileSectionW)(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
typedef DWORD     (WINAPI *_pfn_GetPrivateProfileSectionNamesA)(LPSTR lpszReturnBuffer, DWORD nSize, LPCSTR lpFileName);
typedef DWORD     (WINAPI *_pfn_GetPrivateProfileSectionNamesW)(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName);
typedef DWORD     (WINAPI *_pfn_GetPrivateProfileStringA)( LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR  lpReturnedString, DWORD  nSize, LPCSTR lpFileName);
typedef DWORD     (WINAPI *_pfn_GetPrivateProfileStringW)( LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR  lpReturnedString, DWORD  nSize, LPCWSTR lpFileName);
typedef BOOL      (WINAPI *_pfn_GetPrivateProfileStructA)(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR lpFileName);
typedef BOOL      (WINAPI *_pfn_GetPrivateProfileStructW)(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR lpFileName);
typedef BOOL      (WINAPI *_pfn_WritePrivateProfileSectionA)(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName);
typedef BOOL      (WINAPI *_pfn_WritePrivateProfileSectionW)(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName);
typedef BOOL      (WINAPI *_pfn_WritePrivateProfileStringA)(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName);
typedef BOOL      (WINAPI *_pfn_WritePrivateProfileStringW)(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName);
typedef BOOL      (WINAPI *_pfn_WritePrivateProfileStructA)(LPCSTR lpAppName, LPCSTR lpKeyName, LPVOID lpStruct, UINT uSizeStruct, LPCSTR lpFileName);
typedef BOOL      (WINAPI *_pfn_WritePrivateProfileStructW)(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR lpFileName);

typedef FARPROC   (WINAPI *_pfn_GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
typedef VOID      (WINAPI *_pfn_GetProcessorSpeed)(VOID);
typedef HANDLE    (WINAPI *_pfn_GetStdHandle)( DWORD nStdHandle );
typedef UINT      (WINAPI *_pfn_GetSystemPaletteEntries)( HDC hdc, UINT iStartIndex, UINT nEntries, LPPALETTEENTRY lppe);
typedef DWORD     (WINAPI *_pfn_GetVersion)();
typedef BOOL      (WINAPI *_pfn_GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation);
typedef BOOL      (WINAPI *_pfn_GetVersionExW)(LPOSVERSIONINFOW lpVersionInformation);

typedef BOOL      (WINAPI *_pfn_InitializeSecurityDescriptor)( PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision);

typedef HINSTANCE (WINAPI *_pfn_LoadLibraryA)(LPCSTR lpLibFileName);
typedef HINSTANCE (WINAPI *_pfn_LoadLibraryW)(LPCWSTR lpLibFileName);
typedef HINSTANCE (WINAPI *_pfn_LoadLibraryExA)(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
typedef HINSTANCE (WINAPI *_pfn_LoadLibraryExW)(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
typedef BOOL      (WINAPI *_pfn_LookupPrivilegeValueA)( LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid );
typedef BOOL      (WINAPI *_pfn_LookupPrivilegeValueW)( LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid );

typedef int       (WINAPI *_pfn_MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
typedef int       (WINAPI *_pfn_MessageBoxW)(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);

typedef VOID      (WINAPI *_pfn_OutputDebugStringA)(LPCSTR lpOutputString);

typedef LONG      (WINAPI *_pfn_RegCreateKeyA)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult); 
typedef LONG      (WINAPI *_pfn_RegCreateKeyW)(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult); 
typedef LONG      (WINAPI *_pfn_RegCreateKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
typedef LONG      (WINAPI *_pfn_RegCreateKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
typedef LONG      (WINAPI *_pfn_RegOpenKeyA)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult); 
typedef LONG      (WINAPI *_pfn_RegOpenKeyW)(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult); 
typedef LONG      (WINAPI *_pfn_RegOpenKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult); 
typedef LONG      (WINAPI *_pfn_RegOpenKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult); 
typedef LONG      (WINAPI *_pfn_RegQueryValueA)(HKEY hkey, LPCSTR lpSubKey, LPBYTE lpData, LPDWORD lpcbData);
typedef LONG      (WINAPI *_pfn_RegQueryValueW)(HKEY hkey, LPCWSTR lpSubKey, LPBYTE lpData, LPDWORD lpcbData);
typedef LONG      (WINAPI *_pfn_RegQueryValueExA)(HKEY hkey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
typedef LONG      (WINAPI *_pfn_RegQueryValueExW)(HKEY hkey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
typedef LONG      (WINAPI *_pfn_RegEnumValueA)(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
typedef LONG      (WINAPI *_pfn_RegEnumValueW)(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
typedef LONG      (WINAPI *_pfn_RegEnumKeyA)(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cbName);
typedef LONG      (WINAPI *_pfn_RegEnumKeyW)(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cbName);
typedef LONG      (WINAPI *_pfn_RegEnumKeyExA)(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcbName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcbClass, PFILETIME lpftLastWriteTime);
typedef LONG      (WINAPI *_pfn_RegEnumKeyExW)(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME lpftLastWriteTime);
typedef LONG      (WINAPI *_pfn_RegQueryInfoKeyA)(HKEY hKey, LPSTR lpClass, LPDWORD lpcbClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);
typedef LONG      (WINAPI *_pfn_RegQueryInfoKeyW)(HKEY hKey, LPWSTR lpClass, LPDWORD lpcbClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime); 
typedef LONG      (WINAPI *_pfn_RegCloseKey)(HKEY hkey);
typedef LONG      (WINAPI *_pfn_RegSetValueExA)(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, DWORD dwType, LPCSTR lpData, DWORD cbData);
typedef LONG      (WINAPI *_pfn_RegSetValueExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, DWORD dwType, LPCSTR lpData, DWORD cbData);


typedef int       (WINAPI *_pfn_ReleaseDC)(HWND hWnd, HDC hdc);

typedef DWORD     (WINAPI *_pfn_GetEnvironmentVariableA)(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize);
typedef DWORD     (WINAPI *_pfn_GetEnvironmentVariableW)(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);

typedef BOOL      (WINAPI *_pfn_RemoveDirectoryA)(LPCSTR lpFileName);
typedef BOOL      (WINAPI *_pfn_RemoveDirectoryW)(LPCWSTR lpFileName);

typedef PVOID     (WINAPI *_pfn_RtlAllocateHeap)(PVOID HeapHandle, ULONG Flags, SIZE_T Size);

typedef COLORREF  (WINAPI *_pfn_SetBkColor)(HDC hdc, COLORREF crColor);
typedef COLORREF  (WINAPI *_pfn_SetTextColor)(HDC hdc, COLORREF crColor);
typedef LONG      (WINAPI *_pfn_SetWindowLongA)(HWND hWnd, int nIndex, LONG dwnewLong);
typedef LONG      (WINAPI *_pfn_SetWindowLongW)(HWND hWnd, int nIndex, LONG dwnewLong);

typedef HINSTANCE (WINAPI *_pfn_ShellExecuteA)(HWND hwnd, LPCSTR lpVerb, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
typedef HINSTANCE (WINAPI *_pfn_ShellExecuteW)(HWND hwnd, LPCWSTR lpVerb, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);
typedef BOOL      (WINAPI *_pfn_ShellExecuteExA)(LPSHELLEXECUTEINFOA lpExecInfo);
typedef BOOL      (WINAPI *_pfn_ShellExecuteExW)(LPSHELLEXECUTEINFOW lpExecInfo);
typedef HRESULT   (WINAPI *_pfn_SHGetSpecialFolderLocation)( HWND hwndOwner, int nFolder, LPITEMIDLIST *ppidl );
typedef HRESULT   (WINAPI *_pfn_SHGetFolderLocation)( HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwReserved,  LPITEMIDLIST *ppidl );
typedef HRESULT   (WINAPI *_pfn_SHGetFolderPathA)( HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlags, LPSTR pszPath );
typedef HRESULT   (WINAPI *_pfn_SHGetFolderPathW)( HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath );
typedef BOOL      (WINAPI *_pfn_SHGetSpecialFolderPathA)( HWND hwndOwner, LPSTR lpszPath, int nFolder, BOOL fCreate );
typedef BOOL      (WINAPI *_pfn_SHGetSpecialFolderPathW)( HWND hwndOwner, LPWSTR lpszPath, int nFolder, BOOL fCreate );
typedef BOOL      (WINAPI *_pfn_ShowWindow)( HWND hWnd, INT nCmdShow );

typedef BOOL      (WINAPI *_pfn_VerQueryValueA)( const LPVOID pBlock, LPSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen);
typedef BOOL      (WINAPI *_pfn_VerQueryValueW)( const LPVOID pBlock, LPWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen);

typedef int       (WINAPI *_pfn_vsnprintf)(char *buffer, size_t count, const char *format, va_list argptr);

typedef UINT      (WINAPI *_pfn_WinExec)(LPCSTR lpCmdLine, UINT uCmdShow);


typedef ULONG     (*_pfn_AddRef)( PVOID pThis );
typedef ULONG     (*_pfn_Release)( PVOID pThis );
typedef HRESULT   (*_pfn_QueryInterface)( PVOID pThis, REFIID iid, PVOID* ppvObject );
typedef HRESULT   (*_pfn_CreateInstance)( PVOID pThis, IUnknown * pUnkOuter, REFIID riid, void ** ppvObject );
typedef HRESULT   (*_pfn_IPersistFile_Save)(PVOID pThis, LPCOLESTR pszFileName,  BOOL fRemember);
typedef HRESULT   (*_pfn_IShellLink_SetPathA)( PVOID pThis, LPCSTR pszFile );
typedef HRESULT   (*_pfn_IShellLink_SetPathW)( PVOID pThis, LPCWSTR pszFile );
typedef HRESULT   (*_pfn_IDirectDraw_CreateSurface)(PVOID pThis, LPDDSURFACEDESC lpDDSurfaceDesc, LPDIRECTDRAWSURFACE* lplpDDSurface, IUnknown* pUnkOuter);
typedef HRESULT   (*_pfn_IDirectDraw_CreateSurface2)(PVOID pThis, LPDDSURFACEDESC lpDDSurfaceDesc, LPDIRECTDRAWSURFACE* lplpDDSurface, IUnknown* pUnkOuter);
typedef HRESULT   (*_pfn_IDirectDraw_SetCooperativeLevel)(PVOID pThis, HWND hWnd,DWORD dwFlags);
typedef HRESULT   (*_pfn_IDirectDrawSurface_GetDC)(LPDIRECTDRAWSURFACE lpDDSurface, HDC FAR *lphDC);
typedef HRESULT   (*_pfn_IDirectDrawSurface_ReleaseDC)(LPDIRECTDRAWSURFACE lpDDSurface, HDC hDC);
typedef HRESULT   (*_pfn_IDirectDrawSurface_Lock)(LPDIRECTDRAWSURFACE lpDDSurface, LPRECT lpDestRect, LPDDSURFACEDESC lpDDSurfaceDesc, DWORD dwFlags, HANDLE hEvent);
typedef HRESULT   (*_pfn_IDirectDrawSurface_Unlock)(LPDIRECTDRAWSURFACE lpDDSurface, LPVOID lpSurfaceData);
typedef HRESULT   (*_pfn_IDirectDrawSurface_Restore)(LPDIRECTDRAWSURFACE lpDDSurface);
typedef HRESULT   (*_pfn_IDirectDrawSurface_Blt)(LPDIRECTDRAWSURFACE lpDDDestSurface, LPRECT lpDestRect, LPDIRECTDRAWSURFACE lpDDSrcSurface, LPRECT lpSrcRect, DWORD dwFlags, LPDDBLTFX lpDDBltFX);
typedef HRESULT   (*_pfn_IDirectDrawSurface_Flip)(LPDIRECTDRAWSURFACE lpDDSurface, LPDIRECTDRAWSURFACE lpDDSurfaceDest, DWORD dwFlags);
typedef LONG      (*_pfn_ChangeDisplaySettingsA)(LPDEVMODEA lpDevMode, DWORD dwflags);
typedef LONG      (*_pfn_ChangeDisplaySettingsW)(LPDEVMODEW lpDevMode, DWORD dwflags);
typedef LONG      (*_pfn_ChangeDisplaySettingsExA)(LPCSTR lpszDeviceName, LPDEVMODEA lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam);
typedef LONG      (*_pfn_ChangeDisplaySettingsExW)(LPCWSTR lpszDeviceName, LPDEVMODEW lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam);
typedef LONG      (*_pfn_CreateDIBSection)(HDC hdc, CONST BITMAPINFO *pbmi, UINT iUsage, VOID *ppvBits, HANDLE hSection, DWORD dwOffset);

typedef VOID      (*_pfn_GetStartupInfoA)(LPSTARTUPINFOA lpStartupInfo);
typedef VOID      (*_pfn_GetStartupInfoW)(LPSTARTUPINFOW lpStartupInfo);

typedef DWORD     (*_pfn_SetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
typedef DWORD     (*_pfn_ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
typedef DWORD     (*_pfn_WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);

typedef HANDLE    (*_pfn_CreateMutexA)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
typedef HANDLE    (*_pfn_CreateMutexW)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);
typedef BOOL      (*_pfn_ReleaseMutex)(HANDLE hMutex);


#endif // _SHIMPROTO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\doc\msvcsampleshim\lib\common.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Common.cpp

 Abstract:

    Common functions for all modules

 Notes:

    None

 History:

    12/15/1999 linstev  Created
    01/10/2000 linstev  Format to new style

--*/

#include <stdio.h>
#include "ShimHook.h"

#ifdef DBG
    extern DEBUGLEVEL              GetDebugLevel();
#endif

/*++

 Function Description:
    
    Print a formatted string using DebugOutputString.

 Arguments:

    IN dwDetail -  Detail level above which no print will occur
    IN pszFmt   -  Format string

 Return Value: 
    
    None

 History:

    11/01/1999 markder  Created

--*/

#ifdef DBG
VOID
__cdecl
DebugPrintf(
    DEBUGLEVEL dwDetail, 
    LPSTR pszFmt, 
    ...
    )
{
    char szT[1024];
    va_list arglist;

    if (dwDetail <= GetDebugLevel())
    {
        switch (dwDetail) 
        {
        case eDbgLevelError:
            OutputDebugStringA ("[FAIL] ");
            break;
        case eDbgLevelWarning:
            OutputDebugStringA ("[WARN] ");
            break;
        case eDbgLevelUser:
            OutputDebugStringA ("[USER] ");
            break;
        case eDbgLevelInfo:
            OutputDebugStringA ("[INFO] ");
            break;
        }

        va_start(arglist, pszFmt);
        _vsnprintf(szT, 1023, pszFmt, arglist);
        szT[1023] = 0;
        va_end(arglist);
        OutputDebugStringA(szT);
    }
}

/*++

 Function Description:
    
    Assert that prints file and line number.

 Arguments:

    IN dwDetail -  Detail level above which no print will occur
    IN pszFmt   -  Format string

 Return Value: 
    
    None

 History:

    11/01/1999 markder  Created

--*/

VOID
DebugAssert(
    LPSTR szFile,
    DWORD dwLine,
    BOOL bAssert, 
    LPSTR szHelpString
    )
{
    if (!bAssert )
    {
        int i;
        for (i=0; i<80; i++) DPF(eDbgLevelError, "+");
        DPF(eDbgLevelError, "\n");
        DPF(eDbgLevelError, "FILE: %s\n", szFile);
        DPF(eDbgLevelError, "LINE: %d\n", dwLine);
        DPF(eDbgLevelError, "ASSERT: %s\n", szHelpString);
        for (i=0; i<80; i++) DPF(eDbgLevelError, "+");
        DPF(eDbgLevelError, "\n");

        #ifdef _X86_
            __asm int 3;
        #else
            #pragma message ("Not implented on IA64")
        #endif
    }
}
#endif

/*++

 Function Description:
    
    Determine if a file resides on a CD Rom drive

 Arguments:

    IN wszFileName - Filename including path

 Return Value: 
    
    TRUE if file is on CD drive

 History:

    01/10/2000 linstev  Updated

--*/

BOOL 
IsOnCDRomA(LPCSTR szFileName)
{
    CHAR szDrive[4];
    CHAR *szCurDir = NULL;
    DWORD dwCurDirSize = 0;
    
    if (szFileName[1] == ':')
    {
        szDrive[0] = szFileName[0];
        szDrive[1] = ':';
        szDrive[2] = '\\';
        szDrive[3] = '\0';
    }
    else if (!(szFileName[0] == '\\' && szFileName[1] == '\\'))
    {
        // Not UNC naming, must be a relative path

        dwCurDirSize = GetCurrentDirectoryA(0, szCurDir);

        if (dwCurDirSize)
        {
            szCurDir = (PCHAR)LocalAlloc( LPTR, dwCurDirSize * sizeof(CHAR));
            dwCurDirSize = GetCurrentDirectoryA( dwCurDirSize, szCurDir);

            if (dwCurDirSize && !(szCurDir[0] == '\\' && szCurDir[1] == '\\'))
            {
                szDrive[0] = szCurDir[0];
                szDrive[1] = ':';
                szDrive[2] = '\\';
                szDrive[3] = '\0';
            }

            LocalFree( szCurDir );
            szCurDir = NULL;
        }
    }

    return (GetDriveTypeA(szDrive) == DRIVE_CDROM);
}

/*++

 Function Description:
    
    Determine if a file resides on a CD Rom drive

 Arguments:

    IN wszFileName - Filename including path

 Return Value: 
    
    TRUE if file is on CD drive

 History:

    01/10/2000 linstev  Updated

--*/

BOOL 
IsOnCDRomW(IN LPCWSTR wszFileName)
{
    WCHAR wszDrive[4];
    WCHAR *wszCurDir = NULL;
    DWORD dwCurDirSize = 0;
    
    if (wszFileName[1] == L':')
    {
        wszDrive[0] = wszFileName[0];
        wszDrive[1] = L':';
        wszDrive[2] = L'\\';
        wszDrive[3] = L'\0';
    }
    else if (!(wszFileName[0] == L'\\' && wszFileName[1] == L'\\'))
    {
        // Not UNC naming, must be a relative path

        dwCurDirSize = GetCurrentDirectoryW(0, wszCurDir);

        if (dwCurDirSize)
        {
            wszCurDir = (PWCHAR)LocalAlloc( LPTR, dwCurDirSize * sizeof(WCHAR));
            dwCurDirSize = GetCurrentDirectoryW( dwCurDirSize, wszCurDir );

            if (dwCurDirSize && !(wszCurDir[0] == L'\\' && wszCurDir[1] == L'\\'))
            {
                wszDrive[0] = wszCurDir[0];
                wszDrive[1] = L':';
                wszDrive[2] = L'\\';
                wszDrive[3] = L'\0';
            }

            LocalFree(wszCurDir);
            wszCurDir = NULL;
        }
    }

    return (GetDriveTypeW(wszDrive) == DRIVE_CDROM);
}

/*++

 Function Description:
    
    Removes all "\ " and replaces with "\".

 Arguments:

    IN  pszOldPath - String to scan
    OUT pszNewPath - Resultant string

 Return Value: 
    
    None

 History:

    01/10/2000 linstev  Updated

--*/

VOID 
MassagePathA(
    LPCSTR pszOldPath, 
    LPSTR pszNewPath
    )
{
    PCHAR pszTempBuffer;
    PCHAR pszPointer;
    LONG nOldPos, nNewPos, nOldStringLen;
    BOOL bAtSeparator = TRUE;

    nOldStringLen = strlen(pszOldPath);
    pszTempBuffer = (PCHAR) LocalAlloc(LPTR, nOldStringLen + 1);
    pszPointer = pszTempBuffer;

    nNewPos = nOldStringLen;
    for (nOldPos = nOldStringLen - 1; nOldPos >= 0; nOldPos--)
    {
        if (pszOldPath[ nOldPos ] == '\\')
        {
            bAtSeparator = TRUE;
        }
        else
        {
            if (pszOldPath[nOldPos] == ' ' && bAtSeparator)
            {
                continue;
            }
            else
            {
                bAtSeparator = FALSE;
            }
        }

        pszPointer[--nNewPos] = pszOldPath[nOldPos];
    }

    pszPointer += nNewPos;
    strcpy(pszNewPath, pszPointer);
    LocalFree(pszTempBuffer);
}

/*++

 Function Description:
    
    Removes all L"\ " and replaces with L"\".

 Arguments:

    IN  pwszOldPath - String to scan
    OUT pwszNewPath - Resultant string

 Return Value: 
    
    None

 History:

    01/10/2000 linstev  Updated

--*/

VOID 
MassagePathW( 
    LPCWSTR pwszOldPath, 
    LPWSTR pwszNewPath 
    )
{
    PWCHAR pwszTempBuffer;
    PWCHAR pwszPointer;
    LONG nOldPos, nNewPos, nOldStringLen;
    BOOL bAtSeparator = TRUE;

    nOldStringLen = wcslen(pwszOldPath);
    pwszTempBuffer = (PWCHAR) LocalAlloc(LPTR, (nOldStringLen + 1) * sizeof(WCHAR));
    pwszPointer = pwszTempBuffer;

    nNewPos = nOldStringLen;
    for (nOldPos = nOldStringLen - 1; nOldPos >= 0; nOldPos--)
    {
        if (pwszOldPath[ nOldPos ] == L'\\')
        {
            bAtSeparator = TRUE;
        }
        else
        {
            if (pwszOldPath[nOldPos] == L' ' && bAtSeparator)
            {
                continue;
            }
            else
            {
                bAtSeparator = FALSE;
            }
        }

        pwszPointer[--nNewPos] = pwszOldPath[nOldPos];
    }

    pwszPointer += nNewPos;

    wcscpy(pwszNewPath, pwszPointer);

    LocalFree(pwszTempBuffer);
}

/*++

 Function Description:
    
    Duplicate a string into malloc memory.

 Arguments:

    IN  strToCopy - String to copy

 Return Value: 
    
    String in malloc memory

 History:

    01/10/2000 linstev  Updated
    02/14/2000 robkenny Converted from VirtualAlloc to malloc

--*/

char * 
StringDuplicateA(const char *strToCopy)
{
    size_t strToCopySize = (strlen(strToCopy) + 1) * sizeof(strToCopy[0]);

    char * strDuplicate = (char *) malloc(strToCopySize);

    memcpy(strDuplicate, strToCopy, strToCopySize);

    return strDuplicate;
}

/*++

 Function Description:
    
    Duplicate a string into malloc memory.

 Arguments:

    IN  wstrToCopy - String to copy

 Return Value: 
    
    String in malloc memory

 History:

    01/10/2000 linstev  Updated
    02/14/2000 robkenny Converted from VirtualAlloc to malloc

--*/

wchar_t *
StringDuplicateW(const wchar_t *wstrToCopy)
{
    size_t wstrToCopySize = (wcslen(wstrToCopy) + 1) * sizeof(wstrToCopy[0]);

    wchar_t * wstrDuplicate = (wchar_t *) malloc(wstrToCopySize);

    memcpy(wstrDuplicate, wstrToCopy, wstrToCopySize);

    return wstrDuplicate;
}

/*++

 Function Description:
    
    Skip leading whitespace

 Arguments:

    IN  str - String to scan

 Return Value: 
    
    None

 History:

    01/10/2000 linstev  Updated

--*/

VOID 
SkipBlanksA(const char *& str)
{
    // Skip leading whitespace

    static const char * WhiteSpaceString = " \t";

    str += strspn(str, WhiteSpaceString);
}

/*++

 Function Description:
    
    Skip leading whitespace

 Arguments:

    IN  str - String to scan

 Return Value: 
    
    None

 History:

    01/10/2000 linstev  Updated

--*/

VOID 
SkipBlanksW(const WCHAR *& str)
{
    // Skip leading whitespace

    static const WCHAR * WhiteSpaceString = L" \t";

    str += wcsspn(str, WhiteSpaceString);
}

/*++

 Function Description:
    
    Find the first occurance of strCharSet in string 
    Case insensitive

 Arguments:

    IN string            - String to search
    IN strCharSet        - String to search for

 Return Value: 
    
    First occurance or NULL

 History:

    12/01/1999 robkenny Created
    12/15/1999 linstev  Reformatted

--*/

char*
__cdecl
stristr(
    IN const char* string, 
    IN const char* strCharSet
    )
{
    char * pszRet = NULL;

    long  nstringLen = strlen(string) + 1;
    long  nstrCharSetLen = strlen(strCharSet) + 1;

    char * szTemp_string = (char *) malloc(nstringLen);
    char * szTemp_strCharSet = (char *) malloc(nstrCharSetLen);

    if ((!szTemp_string) || (!szTemp_strCharSet))
    {
        goto Fail;
    }

    strcpy(szTemp_string, string);
    strcpy(szTemp_strCharSet, strCharSet);
    _strlwr(szTemp_string);
    _strlwr(szTemp_strCharSet);
    
    pszRet = strstr(szTemp_string, szTemp_strCharSet);

    if (pszRet)
    {
        pszRet = ((char *) string) + (pszRet - szTemp_string);
    }

Fail:
    if (szTemp_string)
    {
        free(szTemp_string);
    }

    if (szTemp_strCharSet)
    {
        free(szTemp_strCharSet);
    }

    return pszRet;
}

/*++

 Function Description:
    
    Find the first occurance of strCharSet in string 
    Case insensitive

 Arguments:

    IN string            - String to search
    IN strCharSet        - String to search for

 Return Value: 
    
    First occurance or NULL

 History:

    12/01/1999 robkenny Created
    12/15/1999 linstev  Reformatted

--*/

WCHAR* 
__cdecl
wcsistr(
    IN const WCHAR* string, 
    IN const WCHAR* strCharSet
    )
{
    WCHAR * pszRet = NULL;

    long nstringLen = wcslen(string) + 1;
    long nstrCharSetLen = wcslen(strCharSet) + 1;

    WCHAR * szTemp_string = (WCHAR *) malloc(nstringLen * sizeof(WCHAR));
    WCHAR * szTemp_strCharSet = (WCHAR *) malloc(nstrCharSetLen  * sizeof(WCHAR));

    if ((!szTemp_string) || (!szTemp_strCharSet))
    {
        goto Fail;
    }

    wcscpy(szTemp_string, string);
    wcscpy(szTemp_strCharSet, strCharSet);
    _wcslwr(szTemp_string);
    _wcslwr(szTemp_strCharSet);
    
    pszRet = wcsstr(szTemp_string, szTemp_strCharSet);

    if (pszRet)
    {
        pszRet = ((WCHAR *) string) + (pszRet - szTemp_string);
    }

Fail:
    if (szTemp_string)
    {
        free(szTemp_string);
    }

    if( szTemp_strCharSet )
    {
        free(szTemp_strCharSet);
    }

    return pszRet;
}

/*++

  Func:   SafeStringCopyA

  Params: lpDest            Destination string
          nDestSize         size in chars of lpDest
          lpSrc             Original string
          nSrcLen           Number of chars to copy

  Return: int               Number of chars copied into lpDest

  Desc:   Copy lpSrc into lpDest without overflowing the buffer
--*/

int SafeStringCopyA(char * lpDest, DWORD nDestSize, const char * lpSrc, DWORD nSrcLen)
{
    size_t nCharsToCopy = __min(nSrcLen, nDestSize);
    if (nCharsToCopy > 0)
    {
        strncpy(lpDest, lpSrc, nCharsToCopy);
    }

    return nCharsToCopy;
}

/*++

  Func:   SafeStringCopyW

  Params: lpDest            Destination string
          nDestSize         size in chars of lpDest
          lpSrc             Original string
          nSrcLen           Number of chars to copy

  Return: int               Number of chars copied into lpDest

  Desc:   Copy lpSrc into lpDest without overflowing the buffer
--*/

int SafeStringCopyW(WCHAR * lpDest, DWORD nDestSize, const WCHAR * lpSrc, DWORD nSrcLen)
{
    size_t nCharsToCopy = __min(nSrcLen, nDestSize);
    if (nCharsToCopy > 0)
    {
        wcsncpy(lpDest, lpSrc, nCharsToCopy);
    }

    return nCharsToCopy;
}

typedef WCHAR * (__cdecl * _pfn_StrStrW)( const WCHAR * string, const WCHAR * strCharSet );
typedef char  * (__cdecl * _pfn_StrStrA)( const char  * string, const char  * strCharSet );


/*++

  Func:   StringSubstituteRoutineA

  Params: lpOrig              Original string
          lpMatch             Sub-string to look for
          lpSubstitute        string to replace lpMatch
          lpCorrected         the corrected string, may be NULL if (dwCorrectedSize == 0)
          dwCorrectedSize     maximum size of lpCorrected.
                              If 0, then routine returns number of chars necessasry for substitution
          nCorrectedLen       Number of chars placed into lpCorrected.  If the buffer
                              was large enough, this == (wcslen(lpCorrected) + 1)
          nCorrectedTotalSize Number of total chars that should have been copied.
                              This == dwCorrectedSize if lpCorrected was large enough.
          StringSubStringRoutine String comparison routine

  Return: BOOL                Return TRUE if this routine replaced 1 or more matches

  Desc:   Replace the all occurances of lpMatch with lpSubstitute in lpOrig, placing output into lpCorrected

          This routine is CASE SENSITIVE!

--*/
BOOL StringSubstituteRoutineA(
                       const char * lpOrig,
                       const char * lpMatch,
                       const char * lpSubstitute,
                       DWORD dwCorrectedSize,
                       char * lpCorrected,
                       DWORD * nCorrectedLen,
                       DWORD * nCorrectedTotalSize,
                       _pfn_StrStrA     StringSubStringRoutine)
{
    BOOL    bStringChanged = FALSE;
    DWORD   nCharsShouldHaveCopied = 0;                    // Size of resulting string (might exceed  )
    size_t  nCharsCopied = 0;

    char * lpMatchInString = StringSubStringRoutine( lpOrig, lpMatch );

    if (lpMatchInString != NULL)
    {
        // Replace lpMatch with lpSubstitute.
        // Make sure we do not overrun the output buffer.
        size_t nCharsToCopy;                            // How many chars we can safely copy (always <= nCopyLen)

        // Copy the unmodified chars at the beginning of the string
        nCharsToCopy                = lpMatchInString - lpOrig;
        nCharsCopied               += SafeStringCopyA(lpCorrected + nCharsShouldHaveCopied, dwCorrectedSize - nCharsCopied, lpOrig, nCharsToCopy);
        nCharsShouldHaveCopied     += nCharsToCopy;

        // The substitution string
        nCharsToCopy                = strlen(lpSubstitute);
        nCharsCopied               += SafeStringCopyA(lpCorrected + nCharsShouldHaveCopied, dwCorrectedSize - nCharsCopied, lpSubstitute, nCharsToCopy);
        nCharsShouldHaveCopied     += nCharsToCopy;

        char * lpOrigAfterMatch  = lpMatchInString + strlen(lpMatch);

        // Recursively replace the remainder of the string
        DWORD nSmallerSize;
        DWORD nSmallerTotal;
        StringSubstituteA(lpOrigAfterMatch, lpMatch, lpSubstitute, dwCorrectedSize - nCharsCopied, lpCorrected + nCharsShouldHaveCopied, &nSmallerSize, &nSmallerTotal);

        nCharsCopied               += nSmallerSize;
        nCharsShouldHaveCopied     += nSmallerTotal;
        bStringChanged              = TRUE;

        // Recusion is cool: the remainder of the string is copied "automatically" for us in the else statement
    }
    else
    {
        nCharsShouldHaveCopied      = strlen(lpOrig) + 1;
        nCharsCopied                = SafeStringCopyA(lpCorrected, dwCorrectedSize, lpOrig, nCharsShouldHaveCopied);
    }

    // Make sure we have placed the 0 char at the end of the string
    if (nCharsCopied != nCharsShouldHaveCopied && nCharsCopied > 0)
    {
        lpCorrected[nCharsCopied-1] = 0;
    }

    if (nCorrectedLen != NULL)
        *nCorrectedLen = nCharsCopied;

    if (nCorrectedTotalSize != NULL)
        *nCorrectedTotalSize = nCharsShouldHaveCopied;

    return bStringChanged;
}


/*++

  Func:   StringSubstituteW

  Params: lpOrig              Original string
          lpMatch             Sub-string to look for
          lpSubstitute        string to replace lpMatch
          lpCorrected         the corrected string, may be NULL if (dwCorrectedSize == 0)
          dwCorrectedSize     maximum size of lpCorrected.
                              If 0, then routine returns number of chars necessasry for substitution
          nCorrectedLen       Number of chars placed into lpCorrected.  If the buffer
                              was large enough, this == (wcslen(lpCorrected) + 1)
          nCorrectedTotalSize Number of total chars that should have been copied.
                              This == dwCorrectedSize if lpCorrected was large enough.
          StringSubStringRoutine String comparison routine

  Return: BOOL                Return TRUE if this routine replaced 1 or more matches

  Desc:   Replace the all occurances of lpMatch with lpSubstitute in lpOrig, placing output into lpCorrected.

          This routine is CASE SENSITIVE!

--*/
BOOL StringSubstituteRoutineW(
                       const WCHAR * lpOrig,
                       const WCHAR * lpMatch,
                       const WCHAR * lpSubstitute,
                       WCHAR * lpCorrected,
                       DWORD dwCorrectedSize,
                       DWORD * nCorrectedLen,
                       DWORD * nCorrectedTotalSize,
                       _pfn_StrStrW     StringSubStringRoutine)
{
    BOOL    bStringChanged = FALSE;
    DWORD   nCharsShouldHaveCopied = 0;                    // Size of resulting string (might exceed  )
    size_t  nCharsCopied = 0;

    WCHAR * lpMatchInString = StringSubStringRoutine( lpOrig, lpMatch );

    if (lpMatchInString != NULL)
    {
        // Replace lpMatch with lpSubstitute.
        // Make sure we do not overrun the output buffer.
        size_t nCharsToCopy;                            // How many chars we can safely copy (always <= nCopyLen)

        // Copy the unmodified chars at the beginning of the string
        nCharsToCopy                = lpMatchInString - lpOrig;
        nCharsCopied               += SafeStringCopyW(lpCorrected + nCharsShouldHaveCopied, dwCorrectedSize - nCharsCopied, lpOrig, nCharsToCopy);
        nCharsShouldHaveCopied     += nCharsToCopy;

        // The substitution string
        nCharsToCopy                = wcslen(lpSubstitute);
        nCharsCopied               += SafeStringCopyW(lpCorrected + nCharsShouldHaveCopied, dwCorrectedSize - nCharsCopied, lpSubstitute, nCharsToCopy);
        nCharsShouldHaveCopied     += nCharsToCopy;

        WCHAR * lpOrigAfterMatch  = lpMatchInString + wcslen(lpMatch);

        // Recursively replace the remainder of the string
        DWORD nSmallerSize;
        DWORD nSmallerTotal;
        StringSubstituteW(lpOrigAfterMatch, lpMatch, lpSubstitute, lpCorrected + nCharsShouldHaveCopied, dwCorrectedSize - nCharsCopied, &nSmallerSize, &nSmallerTotal);

        nCharsCopied               += nSmallerSize;
        nCharsShouldHaveCopied     += nSmallerTotal;
        bStringChanged              = TRUE;

        // Recursion is cool: the remainder of the string is copied "automatically" for us in the else statement
    }
    else
    {
        nCharsShouldHaveCopied      = wcslen(lpOrig) + 1;
        nCharsCopied                = SafeStringCopyW(lpCorrected, dwCorrectedSize, lpOrig, nCharsShouldHaveCopied);
    }

    // Make sure we have placed the 0 char at the end of the string
    if (nCharsCopied != nCharsShouldHaveCopied && nCharsCopied > 0)
    {
        lpCorrected[nCharsCopied-1] = 0;
    }

    if (nCorrectedLen != NULL)
        *nCorrectedLen = nCharsCopied;

    if (nCorrectedTotalSize != NULL)
        *nCorrectedTotalSize = nCharsShouldHaveCopied;

    return bStringChanged;
}

/*++

  Func:   StringISubstituteA

  Params: lpOrig              Original string
          lpMatch             Sub-string to look for
          lpSubstitute        string to replace lpMatch
          lpCorrected         the corrected string, may be NULL if (dwCorrectedSize == 0)
          dwCorrectedSize     maximum size of lpCorrected.
                              If 0, then routine returns number of chars necessasry for substitution
          nCorrectedLen       Number of chars placed into lpCorrected.  If the buffer
                              was large enough, this == (wcslen(lpCorrected) + 1)
          nCorrectedTotalSize Number of total chars that should have been copied.
                              This == dwCorrectedSize if lpCorrected was large enough.

  Return: BOOL                Return TRUE if this routine replaced 1 or more matches

  Desc:   Replace the all occurances of lpMatch with lpSubstitute in lpOrig, placing output into lpCorrected

          This routine is CASE SENSITIVE!

--*/
BOOL StringSubstituteA(
                       const char * lpOrig,
                       const char * lpMatch,
                       const char * lpSubstitute,
                       DWORD dwCorrectedSize,
                       char * lpCorrected,
                       DWORD * nCorrectedLen,
                       DWORD * nCorrectedTotalSize)
{
    return StringSubstituteRoutineA(
            lpOrig,
            lpMatch,
            lpSubstitute,
            dwCorrectedSize,
            lpCorrected,
            nCorrectedLen,
            nCorrectedTotalSize,
            strstr);
}

/*++

  Func:   StringISubstituteA

  Params: lpOrig              Original string
          lpMatch             Sub-string to look for
          lpSubstitute        string to replace lpMatch
          lpCorrected         the corrected string, may be NULL if (dwCorrectedSize == 0)
          dwCorrectedSize     maximum size of lpCorrected.
                              If 0, then routine returns number of chars necessasry for substitution
          nCorrectedLen       Number of chars placed into lpCorrected.  If the buffer
                              was large enough, this == (wcslen(lpCorrected) + 1)
          nCorrectedTotalSize Number of total chars that should have been copied.
                              This == dwCorrectedSize if lpCorrected was large enough.

  Return: BOOL                Return TRUE if this routine replaced 1 or more matches

  Desc:   Replace the all occurances of lpMatch with lpSubstitute in lpOrig, placing output into lpCorrected

          This routine is CASE SENSITIVE!

--*/
BOOL StringISubstituteA(
                       const char * lpOrig,
                       const char * lpMatch,
                       const char * lpSubstitute,
                       DWORD dwCorrectedSize,
                       char * lpCorrected,
                       DWORD * nCorrectedLen,
                       DWORD * nCorrectedTotalSize)
{
    return StringSubstituteRoutineA(
            lpOrig,
            lpMatch,
            lpSubstitute,
            dwCorrectedSize,
            lpCorrected,
            nCorrectedLen,
            nCorrectedTotalSize,
            stristr);
}

/*++

  Func:   StringSubstituteW

  Params: lpOrig              Original string
          lpMatch             Sub-string to look for
          lpSubstitute        string to replace lpMatch
          lpCorrected         the corrected string, may be NULL if (dwCorrectedSize == 0)
          dwCorrectedSize     maximum size of lpCorrected.
                              If 0, then routine returns number of chars necessasry for substitution
          nCorrectedLen       Number of chars placed into lpCorrected.  If the buffer
                              was large enough, this == (wcslen(lpCorrected) + 1)
          nCorrectedTotalSize Number of total chars that should have been copied.
                              This == dwCorrectedSize if lpCorrected was large enough.

  Return: BOOL                Return TRUE if this routine replaced 1 or more matches

  Desc:   Replace the all occurances of lpMatch with lpSubstitute in lpOrig, placing output into lpCorrected.

          This routine is CASE IN-SENSITIVE!

--*/
BOOL StringSubstituteW(
                       const WCHAR * lpOrig,
                       const WCHAR * lpMatch,
                       const WCHAR * lpSubstitute,
                       WCHAR * lpCorrected,
                       DWORD dwCorrectedSize,
                       DWORD * nCorrectedLen,
                       DWORD * nCorrectedTotalSize)
{
    return StringSubstituteRoutineW(
        lpOrig,
        lpMatch,
        lpSubstitute,
        lpCorrected,
        dwCorrectedSize,
        nCorrectedLen,
        nCorrectedTotalSize,
        wcsstr);
}

/*++

  Func:   StringISubstituteW

  Params: lpOrig              Original string
          lpMatch             Sub-string to look for
          lpSubstitute        string to replace lpMatch
          lpCorrected         the corrected string, may be NULL if (dwCorrectedSize == 0)
          dwCorrectedSize     maximum size of lpCorrected.
                              If 0, then routine returns number of chars necessasry for substitution
          nCorrectedLen       Number of chars placed into lpCorrected.  If the buffer
                              was large enough, this == (wcslen(lpCorrected) + 1)
          nCorrectedTotalSize Number of total chars that should have been copied.
                              This == dwCorrectedSize if lpCorrected was large enough.

  Return: BOOL                Return TRUE if this routine replaced 1 or more matches

  Desc:   Replace the all occurances of lpMatch with lpSubstitute in lpOrig, placing output into lpCorrected.

          This routine is CASE IN-SENSITIVE!

--*/
BOOL StringISubstituteW(
                       const WCHAR * lpOrig,
                       const WCHAR * lpMatch,
                       const WCHAR * lpSubstitute,
                       WCHAR * lpCorrected,
                       DWORD dwCorrectedSize,
                       DWORD * nCorrectedLen,
                       DWORD * nCorrectedTotalSize)
{
    return StringSubstituteRoutineW(
        lpOrig,
        lpMatch,
        lpSubstitute,
        lpCorrected,
        dwCorrectedSize,
        nCorrectedLen,
        nCorrectedTotalSize,
        wcsistr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\doc\msvcsampleshim\lib\shimhook.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ShimHook.cpp

 Abstract:

    Utils for all modules and COM hooking mechanism

 Notes:

    None

 History:

    11/01/1999 markder  Created
    11/11/1999 markder  Added comments
    01/10/2000 linstev  Format to new style

--*/

// Have to do this to keep shims simpler
#define LIB_BUILD_FLAG
#include "ShimHook.h"
#undef  LIB_BUILD_FLAG

#define APPBreakPoint() ;

// Global variables for api hook support

PHOOKAPI    GetHookAPIs(
    IN LPSTR pszCmdLine,
    IN PFNPATCHNEWMODULES pfnPatchNewModules,
    IN OUT DWORD *pdwHooksCount
    );

void        PatchFunction( PVOID* pVtbl, DWORD dwVtblIndex, PVOID pfnNew );
ULONG       COMHook_AddRef( PVOID pThis );
ULONG       COMHook_Release( PVOID pThis );
HRESULT     COMHook_QueryInterface( PVOID pThis, REFIID iid, PVOID* ppvObject );
HRESULT     COMHook_IClassFactory_CreateInstance( PVOID pThis, IUnknown * pUnkOuter, REFIID riid, void ** ppvObject );
VOID        HookObject(IN CLSID *pCLSID, IN REFIID riid, OUT LPVOID *ppv, OUT PSHIM_HOOKED_OBJECT pOb, IN BOOL bClassFactory);

/*++

 Global variables for COM hook support

 The following variables are pointers to the first entry in linked lists that
 are maintained by the mechanism in order to properly manage the hooking
 process.

 There will be one SHIM_IFACE_FN_MAP for every COM interface function pointer
 that was overwritten with one of our hooks.

 There will be one SHIM_HOOKED_OBJECT entry every COM interface that is handed
 out. This is required to differentiate between different classes that expose
 the same interface, but one is hooked and one isn't.

--*/

PSHIM_IFACE_FN_MAP  g_pIFaceFnMaps;
PSHIM_HOOKED_OBJECT g_pObjectCache;

#ifdef DBG
    DEBUGLEVEL GetDebugLevel()
    {
        CHAR cEnv[MAX_PATH];
        DEBUGLEVEL dlRet = eDbgLevelError;

        if (GetEnvironmentVariableA(
                szDebugEnvironmentVariable, 
                cEnv, 
                MAX_PATH))
        {
            CHAR c = cEnv[0];
            if ((c >= '0') || (c <= '9'))
            {
                dlRet = (DEBUGLEVEL)((int)(c - '0'));
            }
        }
        
        return dlRet;
    }
#endif

/*++

 Function Description:

    Called by the shim mechanism. Initializes the global APIHook array and
    returns necessary information to the shim mechanism.

 Arguments:

    IN dwGetProcAddress  -  Function pointer to GetProcAddress
    IN dwLoadLibraryA    -  Function pointer to LoadLibraryA
    IN dwFreeLibrary     -  Function pointer to FreeLibrary
    IN OUT pdwHooksCount -  Receive the number of APIHooks in the returned array

 Return Value:

    Pointer to global HOOKAPI array.

 History:

    11/01/1999 markder  Created

--*/

PHOOKAPI
GetHookAPIs(
    IN LPSTR /*pszCmdLine*/,
    IN PFNPATCHNEWMODULES /*pfnPatchNewModules */,
    IN OUT DWORD * pdwHooksCount
    )
{
    // Initialize Global variables here.
    // At present (1/11/00) we do not have static initialization
    g_bAPIHooksInited   = FALSE;
    g_pAPIHooks         = NULL;
    g_dwAPIHookCount    = 0;
    g_bHasCOMHooks      = FALSE;
    g_dwCOMHookCount    = 0;
    g_pCOMHooks         = NULL;
    g_pIFaceFnMaps      = NULL;
    g_pObjectCache      = NULL;

    // exists in user shims
    InitializeHooks(DLL_PROCESS_ATTACH);

    PHOOKAPI p_ReportedShimBlockAddress = g_pAPIHooks;

    if (!g_bHasCOMHooks)
    {
       p_ReportedShimBlockAddress = g_pAPIHooks + USERAPIHOOKSTART;

       g_dwAPIHookCount -= USERAPIHOOKSTART;
    }

    *pdwHooksCount = g_dwAPIHookCount;

    DPF(eDbgLevelBase, 
        "Hooks = %d, DebugLevel = %d\n\n", 
        g_dwAPIHookCount, 
        GetDebugLevel());

    return p_ReportedShimBlockAddress;
}

/*++

 Function Description:

    Adds an entry to the g_IFaceFnMaps linked list.

 Arguments:

    IN  pVtbl  - Pointer to an interface vtable to file under
    IN  pfnNew - Pointer to the new (stub) function
    IN  pfnOld - Pointer to the old (original) function

 Return Value:

    None

 History:

    11/01/1999 markder  Created

--*/

VOID
AddIFaceFnMap(
    IN PVOID pVtbl,
    IN PVOID pfnNew,
    IN PVOID pfnOld
    )
{
    PSHIM_IFACE_FN_MAP pNewMap = (PSHIM_IFACE_FN_MAP)
        VirtualAlloc(
            NULL,
            sizeof(SHIM_IFACE_FN_MAP),
            MEM_COMMIT,
            PAGE_READWRITE);

    DPF(eDbgLevelInfo, "[AddMap]  pVtbl: 0x%p pfnNew: 0x%p pfnOld: 0x%p\n",
        pVtbl,
        pfnNew,
        pfnOld);

    pNewMap->pVtbl  = pVtbl;
    pNewMap->pfnNew = pfnNew;
    pNewMap->pfnOld = pfnOld;

    pNewMap->pNext = g_pIFaceFnMaps;
    g_pIFaceFnMaps = pNewMap;
}

/*++

 Function Description:

  Searches the g_pIFaceFnMaps linked list for a match on pVtbl and pfnNew, and
  returns the corresponding pfnOld. This is typically called from inside a
  stubbed function to determine what original function pointer to call for the
  particular vtable that was used by the caller.

  It is also used by PatchFunction to determine if a vtable's function pointer
  has already been stubbed.

 Arguments:

    IN  pVtbl  - Pointer to an interface vtable to file under
    IN  pfnNew - Pointer to the new (stub) function
    IN  bThrowExceptionIfNull - Flag that specifies whether it should be
                 possible to not find the original function in our function
                 map

 Return Value:

    Returns the original function pointer

 History:

    11/01/1999 markder  Created

--*/

PVOID
LookupOldCOMIntf(
    IN PVOID pVtbl,
    IN PVOID pfnNew,
    IN BOOL bThrowExceptionIfNull
    )
{
    PSHIM_IFACE_FN_MAP pMap = g_pIFaceFnMaps;
    PVOID pReturn = NULL;

    DPF(eDbgLevelInfo, "[LookUpOldCOMIntf] pVtbl: 0x%p pfnNew: 0x%p ",
        pVtbl,
        pfnNew);

    // Scan the linked list for a match and return if found.
    while (pMap)
    {
        if (pMap->pVtbl == pVtbl && pMap->pfnNew == pfnNew)
        {
            pReturn = pMap->pfnOld;
            break;
        }

        pMap = (PSHIM_IFACE_FN_MAP) pMap->pNext;
    }

    DPF(eDbgLevelInfo, " --> Returned: 0x%p\n", pReturn);

    if (!pReturn && bThrowExceptionIfNull)
    {
        // If we have hit this point, there is something seriously wrong.
        // Either there is a bug in the AddRef/Release stubs or the app
        // obtained an interface pointer in some way that we don't catch.
        DPF(eDbgLevelError,"ERROR: Shim COM APIHooking mechanism failed.\n");
        APPBreakPoint();
    }

    return pReturn;
}

/*++

 Function Description:

  Stores the original function pointer in the function map and overwrites it in
  the vtable with the new one.

 Arguments:

    IN  pVtbl       - Pointer to an interface vtable to file under
    IN  dwVtblIndex - The index of the target function within the vtable.
    IN  pfnNew      - Pointer to the new (stub) function

 Return Value:

    None

 History:

    11/01/1999 markder  Created

--*/

VOID
PatchFunction(
    IN PVOID* pVtbl,
    IN DWORD dwVtblIndex,
    IN PVOID pfnNew
    )
{
    DWORD dwOldProtect = 0;
    DWORD dwOldProtect2 = 0;

    DPF(eDbgLevelInfo, "[PatchFunction] pVtbl: 0x%p, dwVtblIndex: %d, pfnOld: 0x%p, pfnNew: 0x%p\n",
        pVtbl,
        dwVtblIndex,
        pVtbl[dwVtblIndex],
        pfnNew);

    // if not patched yet
    if (!LookupOldCOMIntf( pVtbl, pfnNew, FALSE))
    {
        AddIFaceFnMap( pVtbl, pfnNew, pVtbl[dwVtblIndex]);

        // Make the code page writable and overwrite function pointers in vtable
        if (VirtualProtect(pVtbl + dwVtblIndex,
                sizeof(DWORD),
                PAGE_READWRITE,
                &dwOldProtect))
        {
            pVtbl[dwVtblIndex] = pfnNew;

            // Return the code page to its original state
            VirtualProtect(pVtbl + dwVtblIndex,
                sizeof(DWORD),
                dwOldProtect,
                &dwOldProtect2);
        }
    }

}

/*++

 Function Description:

    This stub exists to keep track of an interface's reference count changes.
    Note that the bAddRefTrip flag is cleared, which allows
    APIHook_QueryInterface to determine whether an AddRef was performed inside
    the original QueryInterface function call.

 Arguments:

    IN  pThis - The object's 'this' pointer

 Return Value:

    Return value is obtained from original function

 History:

    11/01/1999 markder  Created

--*/

ULONG
APIHook_AddRef(
    IN PVOID pThis
    )
{
    PSHIM_HOOKED_OBJECT pHookedOb = g_pObjectCache;
    _pfn_AddRef pfnOld;
    ULONG ulReturn;

    pfnOld = (_pfn_AddRef) LookupOldCOMIntf( *((PVOID*)(pThis)),
        APIHook_AddRef,
        TRUE);

    ulReturn = (*pfnOld)(pThis);

    while (pHookedOb)
    {
        if (pHookedOb->pThis == pThis)
        {
            pHookedOb->dwRef++;
            pHookedOb->bAddRefTrip = FALSE;
            DPF(eDbgLevelInfo, "[AddRef] pThis: 0x%p dwRef: %d ulReturn: %d\n",
                pThis,
                pHookedOb->dwRef,
                ulReturn);
            break;
        }

        pHookedOb = (PSHIM_HOOKED_OBJECT) pHookedOb->pNext;
    }

    return ulReturn;
}

/*++

 Function Description:

    This stub exists to keep track of an interface's reference count changes.

 Arguments:

    IN  pThis - The object's 'this' pointer

 Return Value:

    Return value is obtained from original function

 History:

    11/01/1999 markder  Created

--*/

ULONG
APIHook_Release(
    IN PVOID pThis
    )
{
    PSHIM_HOOKED_OBJECT *ppHookedOb = &g_pObjectCache;
    PSHIM_HOOKED_OBJECT pTemp;
    _pfn_Release pfnOld;
    ULONG ulReturn;

    pfnOld = (_pfn_Release) LookupOldCOMIntf(*((PVOID*)(pThis)),
        APIHook_Release,
        TRUE);

    ulReturn = (*pfnOld)( pThis );

    while ((*ppHookedOb))
    {
        if ((*ppHookedOb)->pThis == pThis)
        {
            (*ppHookedOb)->dwRef--;

            DPF(eDbgLevelInfo, "[Release] pThis: 0x%p dwRef: %d ulReturn: %d %s\n",
                pThis,
                (*ppHookedOb)->dwRef,
                ulReturn,
                ((*ppHookedOb)->dwRef?"":" --> Deleted"));

            if (!((*ppHookedOb)->dwRef))
            {
                pTemp = (*ppHookedOb);
                *ppHookedOb = (PSHIM_HOOKED_OBJECT) (*ppHookedOb)->pNext;
                VirtualFree(pTemp, 0, MEM_RELEASE);
            }

            break;
        }

        ppHookedOb = (PSHIM_HOOKED_OBJECT*) &((*ppHookedOb)->pNext);
    }

    return ulReturn;
}

/*++

 Function Description:

    This stub catches the application attempting to obtain a new interface
    pointer to the same object. The function searches the object cache
    to obtain a CLSID for the object and, if found, APIHooks all required
    functions in the new vtable (via the HookObject call).

 Arguments:

    IN  pThis     - The object's 'this' pointer
    IN  iid       - Reference to the identifier of the requested interface
    IN  ppvObject - Address of output variable that receives the interface
                    pointer requested in riid.

 Return Value:

    Return value is obtained from original function

 History:

    11/01/1999 markder  Created

--*/

HRESULT
APIHook_QueryInterface(
    PVOID pThis,
    REFIID iid,
    PVOID* ppvObject
    )
{
    HRESULT hrReturn = E_FAIL;
    _pfn_QueryInterface pfnOld = NULL;
    PSHIM_HOOKED_OBJECT pOb = g_pObjectCache;

    pfnOld = (_pfn_QueryInterface) LookupOldCOMIntf(
        *((PVOID*)pThis),
        APIHook_QueryInterface,
        TRUE);

    while (pOb)
    {
        if (pOb->pThis == pThis)
        {
            pOb->bAddRefTrip = TRUE;
            break;
        }
        pOb = (PSHIM_HOOKED_OBJECT) pOb->pNext;
    }

    if (S_OK == (hrReturn = (*pfnOld) (pThis, iid, ppvObject)))
    {
        if (pOb)
        {
            if (pOb->pThis == *((PVOID*)ppvObject))
            {
                // Same object. Detect whether QueryInterface used IUnknown::AddRef
                // or an internal function.
                DPF( eDbgLevelInfo,"[HookObject] Existing object%s. pThis: 0x%p\n",
                    (pOb->bAddRefTrip?" (AddRef'd) ":""),
                    pOb->pThis);

                if (pOb->bAddRefTrip)
                {
                    (pOb->dwRef)++;      // AddRef the object
                    pOb->bAddRefTrip = FALSE;
                }

                // We are assured that the CLSID for the object will be the same.
                HookObject(pOb->pCLSID, iid, ppvObject, pOb, pOb->bClassFactory);
            }
            else
            {
                HookObject(pOb->pCLSID, iid, ppvObject, NULL, pOb->bClassFactory);
            }
        }
    }

    return hrReturn;
}

/*++

 Function Description:

    This stub catches the most interesting part of the object creation process:
    The actual call to IClassFactory::CreateInstance. Since no CLSID is passed
    in to this function, the stub must decide whether to APIHook the object by
    looking up the instance of the class factory in the object cache. IF IT
    EXISTS IN THE CACHE, that indicates that it creates an object that we wish
    to APIHook.

 Arguments:

    IN  pThis     - The object's 'this' pointer
    IN  pUnkOuter - Pointer to whether object is or isn't part of an aggregate
    IN  riid      - Reference to the identifier of the interface
    OUT ppvObject - Address of output variable that receives the interface
                    pointer requested in riid

 Return Value:

    Return value is obtained from original function

 History:

    11/01/1999 markder  Created

--*/

HRESULT
APIHook_IClassFactory_CreateInstance(
    PVOID pThis,
    IUnknown *pUnkOuter,
    REFIID riid,
    VOID **ppvObject
    )
{
    HRESULT hrReturn = E_FAIL;
    _pfn_CreateInstance pfnOldCreateInst = NULL;
    PSHIM_HOOKED_OBJECT pOb = g_pObjectCache;

    pfnOldCreateInst = (_pfn_CreateInstance) LookupOldCOMIntf(
        *((PVOID*)pThis),
        APIHook_IClassFactory_CreateInstance,
        FALSE);

    if (S_OK == (hrReturn = (*pfnOldCreateInst)(pThis, pUnkOuter, riid, ppvObject)))
    {
        while (pOb)
        {
            if (pOb->pThis == pThis)
            {
                // This class factory instance creates an object that we APIHook.
                DPF(eDbgLevelInfo, "[CreateInstance] Hooking object! pThis: 0x%p\n", pThis);
                HookObject(pOb->pCLSID, riid, ppvObject, NULL, FALSE);
                break;
            }

            pOb = (PSHIM_HOOKED_OBJECT) pOb->pNext;
        }
    }

    return hrReturn;
}

/*++

 Function Description:

    This stub intercepts the one and only exported function in a DLL server that
    OLE/COM uses. It is at this point that we start APIHooking, first by
    APIHooking the class factory (which this function returns) and then later
    the actual object(s) we are interested in.

 Arguments:

    IN  rclsid      CLSID for the class object
    IN  riid      - Reference to the identifier of the interface that
                    communicateswith the class object
    IN  riid      - Reference to the identifier of the interface
    OUT ppvObject - Address of output variable that receives the interface
                    pointer requested in riid

 Return Value:

    Return value is obtained from original function

 History:

    11/01/1999 markder  Created

--*/

HRESULT
APIHook_DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    HRESULT hrReturn = E_FAIL;
    DWORD i = 0;

    hrReturn = LOOKUP_APIHOOK(DllGetClassObject)( rclsid, riid,  ppv);

    if (S_OK ==  hrReturn)
    {
        // Determine if we need to APIHook this object
        for (i = 0; i < g_dwCOMHookCount; i++)
        {
            if (g_pCOMHooks[i].pCLSID &&
                IsEqualGUID( (REFCLSID) *(g_pCOMHooks[i].pCLSID), rclsid))
            {
                // Yes, we are APIHooking an interface on this object. Hook
                // IClassFactory::CreateInstance.
                HookObject((CLSID*) &rclsid, riid, ppv, NULL, TRUE);
                break;
            }
        }
    }

    return hrReturn;
}

/*++

 Function Description:

    This stub intercepts the DirectDrawCreate.

 Arguments:

    See DirectDrawCreate on MSDN

 Return Value:

    See DirectDrawCreate on MSDN

 History:

    11/01/1999 markder  Created

--*/

HRESULT
APIHook_DirectDrawCreate(
    IN GUID FAR *lpGUID,
    OUT LPVOID *lplpDD,
    OUT IUnknown* pUnkOuter
    )
{
    HRESULT hrReturn = E_FAIL;
    DWORD i = 0;

    hrReturn = LOOKUP_APIHOOK(DirectDrawCreate)(lpGUID, lplpDD, pUnkOuter);

    if (S_OK == hrReturn)
    {
        // Determine if we need to APIHook this object
        for (i = 0; i < g_dwCOMHookCount; i++)
        {
            if (g_pCOMHooks[i].pCLSID &&
                IsEqualGUID( (REFCLSID) *(g_pCOMHooks[i].pCLSID), CLSID_DirectDraw))
            {
                // Yes, we are APIHooking an interface on this object.
                HookObject((CLSID*) &CLSID_DirectDraw, IID_IDirectDraw, lplpDD, NULL, FALSE);
                break;
            }
        }
    }

    return hrReturn;
}

/*++

 Function Description:

    This stub intercepts DirectDrawCreateEx.

 Arguments:

    See DirectDrawCreateEx on MSDN

 Return Value:

    See DirectDrawCreateEx on MSDN

 History:

    11/01/1999 markder  Created

--*/

HRESULT
APIHook_DirectDrawCreateEx(
    GUID FAR *lpGUID,
    LPVOID *lplpDD,
    REFIID iid,
    IUnknown* pUnkOuter
    )
{
    HRESULT hrReturn = E_FAIL;
    DWORD i = 0;

    hrReturn = LOOKUP_APIHOOK(DirectDrawCreateEx)(
        lpGUID,
        lplpDD,
        iid,
        pUnkOuter);

    if (S_OK ==  hrReturn)
    {
        // Determine if we need to APIHook this object
        for (i = 0; i < g_dwCOMHookCount; i++)
        {
            if (g_pCOMHooks[i].pCLSID &&
                IsEqualGUID( (REFCLSID) *(g_pCOMHooks[i].pCLSID), CLSID_DirectDraw))
            {
                // Yes, we are APIHooking an interface on this object.
                HookObject((CLSID*) &CLSID_DirectDraw, iid, lplpDD, NULL, FALSE);
                break;
            }
        }
    }

    return hrReturn;
}

/*++

 Function Description:

    Free memory associated with Hooks and dump info

 Arguments:

    None

 Return Value:

    None

 History:

    11/01/1999 markder  Created

--*/

VOID
DumpCOMHooks()
{
    PSHIM_IFACE_FN_MAP pMap = g_pIFaceFnMaps;
    PSHIM_HOOKED_OBJECT pHookedOb = g_pObjectCache;

    // Dump function map
    DPF(eDbgLevelInfo, "\n--- Shim COM Hook Function Map ---\n\n");

    while (pMap)
    {
        DPF(eDbgLevelInfo, "pVtbl: 0x%p pfnNew: 0x%p pfnOld: 0x%p\n",
            pMap->pVtbl,
            pMap->pfnNew,
            pMap->pfnOld);

        pMap = (PSHIM_IFACE_FN_MAP) pMap->pNext;
    }

    // Dump class factory cache
    DPF(eDbgLevelInfo, "\n--- Shim Object Cache (SHOULD BE EMPTY!!) ---\n\n");

    while (pHookedOb)
    {
        DPF(eDbgLevelInfo, "pThis: 0x%p dwRef: %d\n",
            pHookedOb->pThis,
            pHookedOb->dwRef);

        pHookedOb = (PSHIM_HOOKED_OBJECT) pHookedOb->pNext;
    }
}

/*++

 Function Description:

    This function adds the object's important info to the object cache and then
    patches all required functions. IUnknown is APIHooked for all objects
    regardless.

 Arguments:

    IN  rclsid - CLSID for the class object
    IN  riid   - Reference to the identifier of the interface that communicates
                 with the class object
    OUT ppv    - Address of the pThis pointer that uniquely identifies an
                 instance of the COM interface
    OUT pOb    - New obj pointer
    IN  bClassFactory - Is this a class factory call

 Return Value:

    None

 History:

    11/01/1999 markder  Created

--*/

VOID
HookObject(
    IN CLSID *pCLSID,
    IN REFIID riid,
    OUT LPVOID *ppv,
    OUT PSHIM_HOOKED_OBJECT pOb,
    IN BOOL bClassFactory
    )
{
    PVOID *pVtbl = ((PVOID*)(*((PVOID*)(*ppv))));
    DWORD i = 0;

    if (!pOb)
    {
        DPF(eDbgLevelInfo, "[HookObject] New %s! pThis: 0x%p\n",
            (bClassFactory?"class factory":"object"),
            *ppv);

        pOb = (PSHIM_HOOKED_OBJECT) VirtualAlloc(
            NULL,
            sizeof(PSHIM_HOOKED_OBJECT),
            MEM_COMMIT,
            PAGE_READWRITE);

        pOb->pCLSID = pCLSID;
        pOb->pThis = *ppv;
        pOb->dwRef = 1;
        pOb->bAddRefTrip = FALSE;
        pOb->pNext = g_pObjectCache;
        pOb->bClassFactory = bClassFactory;

        g_pObjectCache = pOb;
    }

    // IUnknown must always be APIHooked since it is possible to get
    // a new interface pointer using it, and we need to process each interface
    // handed out. We must also keep track of the reference count so that
    // we can clean up our interface function map.

    PatchFunction(pVtbl, 0, APIHook_QueryInterface);
    PatchFunction(pVtbl, 1, APIHook_AddRef);
    PatchFunction(pVtbl, 2, APIHook_Release);

    if (bClassFactory && IsEqualGUID(IID_IClassFactory, riid))
    {
        PatchFunction(pVtbl, 3, APIHook_IClassFactory_CreateInstance);
    }
    else
    {
        for (i = 0; i < g_dwCOMHookCount; i++)
        {
            if (!(g_pCOMHooks[i].pCLSID) || !pCLSID)
            {
                if (IsEqualGUID( (REFIID) *(g_pCOMHooks[i].pIID), riid))
                {
                    PatchFunction(
                        pVtbl,
                        g_pCOMHooks[i].dwVtblIndex,
                        g_pCOMHooks[i].pfnNew);
                }
            }
            else
            {
                if (IsEqualGUID((REFCLSID) *(g_pCOMHooks[i].pCLSID), *pCLSID) &&
                    IsEqualGUID((REFIID) *(g_pCOMHooks[i].pIID), riid))
                {
                    PatchFunction(
                        pVtbl,
                        g_pCOMHooks[i].dwVtblIndex,
                        g_pCOMHooks[i].pfnNew);
                }
            }
        }
    }
}


void InitHooks(DWORD dwCount)
{
    g_bAPIHooksInited   = TRUE;
    g_dwAPIHookCount    = dwCount;
    g_pAPIHooks = (PHOOKAPI) VirtualAlloc(
                    NULL,
                    g_dwAPIHookCount * sizeof(HOOKAPI),
                    MEM_COMMIT,
                    PAGE_READWRITE);
}

void InitComHooks(DWORD dwCount)
{
    DECLARE_APIHOOK(DDraw.dll, DirectDrawCreate);
    DECLARE_APIHOOK(DDraw.dll, DirectDrawCreateEx);

    g_bHasCOMHooks = TRUE;
    g_dwCOMHookCount = dwCount;
    g_pCOMHooks = (PSHIM_COM_HOOK) VirtualAlloc(
                    NULL,
                    g_dwCOMHookCount * sizeof(SHIM_COM_HOOK),
                    MEM_COMMIT,
                    PAGE_READWRITE);
}

/*++

 Function Description:

    Called on process detach with old shim mechanism.

 Arguments:

    See MSDN

 Return Value:

    See MSDN

 History:

    11/01/1999 markder  Created

--*/

BOOL
__stdcall DllMain(
    HINSTANCE /*hinstDLL*/,
    DWORD fdwReason,
    LPVOID /*lpvReserved*/
    )
{
    if (DLL_PROCESS_DETACH == fdwReason)
    {
        if (g_bHasCOMHooks)
        {
            DumpCOMHooks();
        }
        InitializeHooks(DLL_PROCESS_DETACH);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\attributes.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        attributes.c

    Abstract:

        This file contains complete implementation of attribute retrieval and
        caching.

    Author:

        vadimb     created     sometime in 2000

    Revision History:

        several people contributed (clupu, dmunsil...)

--*/

//
// Obtain tag information
//
#define _WANT_TAG_INFO

#include "sdbp.h"
#include <stddef.h>
#include <time.h>



#if defined(KERNEL_MODE) && defined(ALLOC_DATA_PRAGMA)
#pragma  data_seg()
#endif // KERNEL_MODE && ALLOC_DATA_PRAGMA


//
// Attribute tags
// The attributes are checked in the order they are listed below.
//
TAG g_rgAttributeTags[] = {
    TAG_SIZE,
    TAG_CHECKSUM,
    TAG_BIN_FILE_VERSION,
    TAG_BIN_PRODUCT_VERSION,
    TAG_PRODUCT_VERSION,
    TAG_FILE_DESCRIPTION,
    TAG_COMPANY_NAME,
    TAG_PRODUCT_NAME,
    TAG_FILE_VERSION,
    TAG_ORIGINAL_FILENAME,
    TAG_INTERNAL_NAME,
    TAG_LEGAL_COPYRIGHT,
    TAG_VERDATEHI,
    TAG_VERDATELO,
    TAG_VERFILEOS,
    TAG_VERFILETYPE,
    TAG_MODULE_TYPE,
    TAG_PE_CHECKSUM,
    TAG_LINKER_VERSION,
#ifndef KERNEL_MODE
    TAG_16BIT_DESCRIPTION,
    TAG_16BIT_MODULE_NAME,
#endif
    TAG_UPTO_BIN_FILE_VERSION,
    TAG_UPTO_BIN_PRODUCT_VERSION,
    TAG_LINK_DATE,
    TAG_UPTO_LINK_DATE,
    TAG_VER_LANGUAGE
};

#define ATTRIBUTE_COUNT ARRAYSIZE(g_rgAttributeTags)

static TAG_INFO gaTagInfo[] = {
    {TAG_DATABASE           ,TEXT("DATABASE")},
    {TAG_LIBRARY            ,TEXT("LIBRARY")},
    {TAG_INEXCLUDE          ,TEXT("INEXCLUDE")},
    {TAG_SHIM               ,TEXT("SHIM")},
    {TAG_PATCH              ,TEXT("PATCH")},
    {TAG_FLAG               ,TEXT("FLAG")},
    {TAG_APP                ,TEXT("APP")},
    {TAG_EXE                ,TEXT("EXE")},
    {TAG_MATCHING_FILE      ,TEXT("MATCHING_FILE")},
    {TAG_SHIM_REF           ,TEXT("SHIM_REF")},
    {TAG_PATCH_REF          ,TEXT("PATCH_REF")},
    {TAG_FLAG_REF           ,TEXT("FLAG_REF")},
    {TAG_LAYER              ,TEXT("LAYER")},
    {TAG_FILE               ,TEXT("FILE")},
    {TAG_APPHELP            ,TEXT("APPHELP")},
    {TAG_LINK               ,TEXT("LINK")},
    {TAG_DATA               ,TEXT("DATA")},
    {TAG_ACTION             ,TEXT("ACTION")},
    {TAG_MSI_TRANSFORM      ,TEXT("MSI TRANSFORM")},
    {TAG_MSI_TRANSFORM_REF  ,TEXT("MSI TRANSFORM REF")},
    {TAG_MSI_PACKAGE        ,TEXT("MSI PACKAGE")},
    {TAG_MSI_CUSTOM_ACTION  ,TEXT("MSI CUSTOM ACTION")},

    {TAG_NAME               ,TEXT("NAME")},
    {TAG_DESCRIPTION        ,TEXT("DESCRIPTION")},
    {TAG_MODULE             ,TEXT("MODULE")},
    {TAG_API                ,TEXT("API")},
    {TAG_VENDOR             ,TEXT("VENDOR")},
    {TAG_APP_NAME           ,TEXT("APP_NAME")},
    {TAG_DLLFILE            ,TEXT("DLLFILE")},
    {TAG_COMMAND_LINE       ,TEXT("COMMAND_LINE")},
    {TAG_ACTION_TYPE        ,TEXT("ACTION_TYPE")},
    {TAG_COMPANY_NAME       ,TEXT("COMPANY_NAME")},
    {TAG_WILDCARD_NAME      ,TEXT("WILDCARD_NAME")},
    {TAG_PRODUCT_NAME       ,TEXT("PRODUCT_NAME")},
    {TAG_PRODUCT_VERSION    ,TEXT("PRODUCT_VERSION")},
    {TAG_FILE_DESCRIPTION   ,TEXT("FILE_DESCRIPTION")},
    {TAG_FILE_VERSION       ,TEXT("FILE_VERSION")},
    {TAG_ORIGINAL_FILENAME  ,TEXT("ORIGINAL_FILENAME")},
    {TAG_INTERNAL_NAME      ,TEXT("INTERNAL_NAME")},
    {TAG_LEGAL_COPYRIGHT    ,TEXT("LEGAL_COPYRIGHT")},
    {TAG_16BIT_DESCRIPTION  ,TEXT("S16BIT_DESCRIPTION")},
    {TAG_APPHELP_DETAILS    ,TEXT("PROBLEM_DETAILS")},
    {TAG_LINK_URL           ,TEXT("LINK_URL")},
    {TAG_LINK_TEXT          ,TEXT("LINK_TEXT")},
    {TAG_APPHELP_TITLE      ,TEXT("APPHELP_TITLE")},
    {TAG_APPHELP_CONTACT    ,TEXT("APPHELP_CONTACT")},
    {TAG_SXS_MANIFEST       ,TEXT("SXS_MANIFEST")},
    {TAG_DATA_STRING        ,TEXT("DATA_STRING")},
    {TAG_MSI_TRANSFORM_FILE ,TEXT("MSI_TRANSFORM_FILE")},
    {TAG_16BIT_MODULE_NAME  ,TEXT("S16BIT_MODULE_NAME")},
    {TAG_LAYER_DISPLAYNAME  ,TEXT("LAYER_DISPLAYNAME")},
    {TAG_COMPILER_VERSION   ,TEXT("COMPILER_VERSION")},
    {TAG_SIZE               ,TEXT("SIZE")},
    {TAG_OFFSET             ,TEXT("OFFSET")},
    {TAG_CHECKSUM           ,TEXT("CHECKSUM")},
    {TAG_SHIM_TAGID         ,TEXT("SHIM_TAGID")},
    {TAG_PATCH_TAGID        ,TEXT("PATCH_TAGID")},
    {TAG_LAYER_TAGID        ,TEXT("LAYER_TAGID")},
    {TAG_FLAG_TAGID         ,TEXT("FLAG_TAGID")},
    {TAG_MODULE_TYPE        ,TEXT("MODULE_TYPE")},
    {TAG_VERDATEHI          ,TEXT("VERFILEDATEHI")},
    {TAG_VERDATELO          ,TEXT("VERFILEDATELO")},
    {TAG_VERFILEOS          ,TEXT("VERFILEOS")},
    {TAG_VERFILETYPE        ,TEXT("VERFILETYPE")},
    {TAG_PE_CHECKSUM        ,TEXT("PE_CHECKSUM")},
    {TAG_LINKER_VERSION     ,TEXT("LINKER_VERSION")},
    {TAG_LINK_DATE          ,TEXT("LINK_DATE")},
    {TAG_UPTO_LINK_DATE     ,TEXT("UPTO_LINK_DATE")},
    {TAG_OS_SERVICE_PACK    ,TEXT("OS_SERVICE_PACK")},
    {TAG_VER_LANGUAGE       ,TEXT("VER_LANGUAGE")},

    {TAG_PREVOSMAJORVER     ,TEXT("PREVOSMAJORVERSION")},
    {TAG_PREVOSMINORVER     ,TEXT("PREVOSMINORVERSION")},
    {TAG_PREVOSPLATFORMID   ,TEXT("PREVOSPLATFORMID")},
    {TAG_PREVOSBUILDNO      ,TEXT("PREVOSBUILDNO")},
    {TAG_PROBLEMSEVERITY    ,TEXT("PROBLEM_SEVERITY")},
    {TAG_HTMLHELPID         ,TEXT("HTMLHELPID")},
    {TAG_INDEX_FLAGS        ,TEXT("INDEXFLAGS")},
    {TAG_LANGID             ,TEXT("APPHELP_LANGID")},
    {TAG_ENGINE             ,TEXT("ENGINE")},
    {TAG_FLAGS              ,TEXT("FLAGS") },
    {TAG_DATA_VALUETYPE     ,TEXT("VALUETYPE")},
    {TAG_DATA_DWORD         ,TEXT("DATA_DWORD")},
    {TAG_MSI_TRANSFORM_TAGID,TEXT("MSI_TRANSFORM_TAGID")},
    {TAG_RUNTIME_PLATFORM,   TEXT("RUNTIME_PLATFORM")},
    {TAG_OS_SKU,             TEXT("OS_SKU")},

    {TAG_INCLUDE            ,TEXT("INCLUDE")},
    {TAG_GENERAL            ,TEXT("GENERAL")},
    {TAG_MATCH_LOGIC_NOT    ,TEXT("MATCH_LOGIC_NOT")},
    {TAG_APPLY_ALL_SHIMS    ,TEXT("APPLY_ALL_SHIMS")},
    {TAG_USE_SERVICE_PACK_FILES
                            ,TEXT("USE_SERVICE_PACK_FILES")},

    {TAG_TIME               ,TEXT("TIME")},
    {TAG_BIN_FILE_VERSION   ,TEXT("BIN_FILE_VERSION")},
    {TAG_BIN_PRODUCT_VERSION,TEXT("BIN_PRODUCT_VERSION")},
    {TAG_MODTIME            ,TEXT("MODTIME")},
    {TAG_FLAG_MASK_KERNEL   ,TEXT("FLAG_MASK_KERNEL")},
    {TAG_FLAG_MASK_USER     ,TEXT("FLAG_MASK_USER")},
    {TAG_FLAG_MASK_SHELL    ,TEXT("FLAG_MASK_SHELL")},
    {TAG_UPTO_BIN_PRODUCT_VERSION, TEXT("UPTO_BIN_PRODUCT_VERSION")},
    {TAG_UPTO_BIN_FILE_VERSION, TEXT("UPTO_BIN_FILE_VERSION")},
    {TAG_DATA_QWORD         ,TEXT("DATA_QWORD")},
    {TAG_FLAGS_NTVDM1       ,TEXT("FLAGS_NTVDM1")},
    {TAG_FLAGS_NTVDM2       ,TEXT("FLAGS_NTVDM2")},
    {TAG_FLAGS_NTVDM3       ,TEXT("FLAGS_NTVDM3")},

    {TAG_PATCH_BITS         ,TEXT("PATCH_BITS")},
    {TAG_FILE_BITS          ,TEXT("FILE_BITS")},
    {TAG_EXE_ID             ,TEXT("EXE_ID(GUID)")},
    {TAG_DATA_BITS          ,TEXT("DATA_BITS")},
    {TAG_MSI_PACKAGE_ID     ,TEXT("MSI_PACKAGE_ID(GUID)")},
    {TAG_DATABASE_ID        ,TEXT("DATABASE_ID(GUID)")},
    {TAG_MATCH_MODE         ,TEXT("MATCH_MODE")},

    //
    // Internal types defined in shimdb.h
    //
    {TAG_STRINGTABLE        ,TEXT("STRINGTABLE")},
    {TAG_INDEXES            ,TEXT("INDEXES")},
    {TAG_INDEX              ,TEXT("INDEX")},
    {TAG_INDEX_TAG          ,TEXT("INDEX_TAG")},
    {TAG_INDEX_KEY          ,TEXT("INDEX_KEY")},
    {TAG_INDEX_BITS         ,TEXT("INDEX_BITS")},
    {TAG_STRINGTABLE_ITEM   ,TEXT("STRTAB_ITEM")},
    {TAG_TAG                ,TEXT("TAG")},
    {TAG_TAGID              ,TEXT("TAGID")},

    {TAG_NULL               ,TEXT("")} // always needs to be last item
};

static MOD_TYPE_STRINGS g_rgModTypeStrings[] = {
    {MT_UNKNOWN_MODULE, TEXT("NONE")},
    {MT_W16_MODULE,     TEXT("WIN16")},
    {MT_W32_MODULE,     TEXT("WIN32")},
    {MT_DOS_MODULE,     TEXT("DOS")}
};

//
// Version Strings for stringref attributes
//
typedef struct _VER_STRINGS {
    TAG         tTag;
    LPTSTR      szName;
} VER_STRINGS;

static VER_STRINGS g_rgVerStrings[] = {
    {TAG_PRODUCT_VERSION,       TEXT("ProductVersion")   },
    {TAG_FILE_DESCRIPTION,      TEXT("FileDescription")  },
    {TAG_COMPANY_NAME,          TEXT("CompanyName")      },
    {TAG_PRODUCT_NAME,          TEXT("ProductName")      },
    {TAG_FILE_VERSION,          TEXT("FileVersion")      },
    {TAG_ORIGINAL_FILENAME,     TEXT("OriginalFilename") },
    {TAG_INTERNAL_NAME,         TEXT("InternalName")     },
    {TAG_LEGAL_COPYRIGHT,       TEXT("LegalCopyright")   }
};

//
// Binary version tags (DWORDs and QWORDs)
//
//
static TAG g_rgBinVerTags[] = {
    TAG_VERDATEHI,
    TAG_VERDATELO,
    TAG_VERFILEOS,
    TAG_VERFILETYPE,
    TAG_BIN_PRODUCT_VERSION,
    TAG_BIN_FILE_VERSION,
    TAG_UPTO_BIN_PRODUCT_VERSION,
    TAG_UPTO_BIN_FILE_VERSION
};

//
// Binary header tags (retrieval requires opening a file).
//
static TAG g_rgHeaderTags[] = {
    TAG_MODULE_TYPE,
    TAG_PE_CHECKSUM,
    TAG_LINKER_VERSION,
    TAG_CHECKSUM,
    TAG_16BIT_DESCRIPTION,
    TAG_16BIT_MODULE_NAME,
    TAG_LINK_DATE,
    TAG_UPTO_LINK_DATE
};

//
// Basic information tags (size).
//
TAG g_rgDirectoryTags[] = {
    TAG_SIZE,
    0
};


//
// Invalid tag token
//
static TCHAR s_szInvalidTag[] = _T("InvalidTag");

#if defined(KERNEL_MODE) && defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, TagToIndex)
#pragma alloc_text(PAGE, SdbTagToString)
#pragma alloc_text(PAGE, SdbpModuleTypeToString)
#pragma alloc_text(PAGE, SdbpSetAttribute)
#pragma alloc_text(PAGE, SdbpQueryStringVersionInformation)
#pragma alloc_text(PAGE, SdbpQueryBinVersionInformation)
#pragma alloc_text(PAGE, SdbpGetVersionAttributesNT)
#pragma alloc_text(PAGE, SdbpGetHeaderAttributes)
#pragma alloc_text(PAGE, SdbpGetAttribute)
#pragma alloc_text(PAGE, SdbpCheckAttribute)
#pragma alloc_text(PAGE, FindFileInfo)
#pragma alloc_text(PAGE, CreateFileInfo)
#pragma alloc_text(PAGE, SdbFreeFileInfo)
#pragma alloc_text(PAGE, SdbpCleanupAttributeMgr)
#pragma alloc_text(PAGE, SdbpCheckAllAttributes)
#pragma alloc_text(PAGE, SdbpQueryVersionString)
#pragma alloc_text(PAGE, SdbpGetModuleType)
#pragma alloc_text(PAGE, SdbpGetModulePECheckSum)
#pragma alloc_text(PAGE, SdbpGetImageNTHeader)
#pragma alloc_text(PAGE, SdbpGetFileChecksum)
#pragma alloc_text(PAGE, SdbpCheckVersion)
#pragma alloc_text(PAGE, SdbpCheckUptoVersion)

#endif // KERNEL_MODE && ALLOC_PRAGMA


int
TagToIndex(
    IN  TAG tag                 // the tag
    )
/*++
    Return: The index in the attribute info array (g_rgAttributeTags).

    Desc:   Self explanatory.
--*/
{
    int i;

    for (i = 0; i < ATTRIBUTE_COUNT; i++) {
        if (tag == g_rgAttributeTags[i]) {
            return i;
        }
    }

    DBGPRINT((sdlError, "TagToIndex", "Invalid attribute 0x%x.\n", tag));

    return -1;
}


LPCTSTR
SdbTagToString(
    TAG tag
    )
/*++
    Return: The pointer to the string name for the specified tag.

    Desc:   Self explanatory.
--*/
{
    int i;

    for (i = 0; i < ARRAYSIZE(gaTagInfo); ++i) {
        if (gaTagInfo[i].tWhich == tag) {
            return gaTagInfo[i].szName;
        }
    }

    return s_szInvalidTag;
}

LPCTSTR
SdbpModuleTypeToString(
    DWORD dwModuleType
    )
{
    int i;

    for (i = 0; i < ARRAYSIZE(g_rgModTypeStrings); ++i) {
        if (g_rgModTypeStrings[i].dwModuleType == dwModuleType) {
            return g_rgModTypeStrings[i].szModuleType;
        }
    }

    //
    // The first element is the "UNKNOWN" type -- NONE
    //
    return g_rgModTypeStrings[0].szModuleType;
}

BOOL
SdbpSetAttribute(
    OUT PFILEINFO pFileInfo,    // pointer to the FILEINFO structure.
    IN  TAG       AttrID,       // Attribute ID (tag, as in TAG_SIZE
    IN  PVOID     pValue        // value
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   This function sets the value for the specified attribute.
            If pValue is NULL it means that the specified attribute is not
            available for the file.
--*/
{
    int       nAttrInd;
    PATTRINFO pAttrInfo;

    nAttrInd = TagToIndex(AttrID);

    if (nAttrInd < 0) {
        DBGPRINT((sdlError, "SdbpSetAttribute", "Invalid attribute %d.\n", nAttrInd));
        return FALSE;
    }

    pAttrInfo = &pFileInfo->Attributes[nAttrInd];

    if (pValue == NULL) {
        //
        // No value. Mark and exit.
        //
        pAttrInfo->dwFlags = (pAttrInfo->dwFlags & ~ATTRIBUTE_AVAILABLE) |
                             ATTRIBUTE_FAILED;
        return TRUE;
    }

    switch (GETTAGTYPE(AttrID)) {
    case TAG_TYPE_DWORD:
        pAttrInfo->dwAttr = *(DWORD*)pValue;
        break;

    case TAG_TYPE_QWORD:
        pAttrInfo->ullAttr = *(ULONGLONG*)pValue;
        break;

    case TAG_TYPE_STRINGREF:
        pAttrInfo->lpAttr = (LPTSTR)pValue;
        break;
    }

    pAttrInfo->tAttrID = AttrID;
    pAttrInfo->dwFlags |= ATTRIBUTE_AVAILABLE;

    return TRUE;
}


//
// This is a guard against bad code in version.dll that stomps over the
// buffer size for Unicode apis on 16-bit exes.
//
#define VERSIONINFO_BUFFER_PAD 16


void
SdbpQueryStringVersionInformation(
    IN  PSDBCONTEXT pContext,
    IN  PFILEINFO   pFileInfo,
    OUT LPVOID      pVersionInfo
    )
/*++
    Return: void.

    Desc:   Sets all the version string info available for the specified file.
--*/
{
    int              i;
    LPTSTR           szVerString;
    PLANGANDCODEPAGE pLangCodePage = NULL;
    DWORD            cbLangCP      = 0;
    int              nTranslations = 0;

    if (!pContext->pfnVerQueryValue(pVersionInfo,
                                    TEXT("\\VarFileInfo\\Translation"),
                                    (LPVOID)&pLangCodePage,
                                    &cbLangCP)) {
        DBGPRINT((sdlError,
                  "SdbpQueryStringVersionInformation",
                  "VerQueryValue failed for translation\n"));
        pLangCodePage = NULL;
    }

    nTranslations = cbLangCP / sizeof(*pLangCodePage);

    for (i = 0; i < ARRAYSIZE(g_rgVerStrings); ++i) {
        szVerString = SdbpQueryVersionString(pContext,
                                             pVersionInfo,
                                             pLangCodePage,
                                             nTranslations,
                                             g_rgVerStrings[i].szName);
        SdbpSetAttribute(pFileInfo, g_rgVerStrings[i].tTag, szVerString);
    }

#ifndef KERNEL_MODE
    //
    // Set the attribute for Language
    //
    if (pLangCodePage != NULL && nTranslations == 1) {
        
        DWORD dwLanguage = (DWORD)pLangCodePage->wLanguage;
        
        SdbpSetAttribute(pFileInfo, TAG_VER_LANGUAGE, &dwLanguage);
    } else {
        SdbpSetAttribute(pFileInfo, TAG_VER_LANGUAGE, NULL);
    }

#endif // KERNEL_MODE
}

VOID
SdbpQueryBinVersionInformation(
    IN  PSDBCONTEXT       pContext,
    IN  PFILEINFO         pFileInfo,
    OUT VS_FIXEDFILEINFO* pFixedInfo
    )
/*++
    Return: void.

    Desc:   Sets all the version string info available for the specified file
            from the fixed size resources.
--*/
{
    LARGE_INTEGER liVerData;

    SdbpSetAttribute(pFileInfo, TAG_VERDATEHI,   &pFixedInfo->dwFileDateMS);
    SdbpSetAttribute(pFileInfo, TAG_VERDATELO,   &pFixedInfo->dwFileDateLS);
    SdbpSetAttribute(pFileInfo, TAG_VERFILEOS,   &pFixedInfo->dwFileOS);
    SdbpSetAttribute(pFileInfo, TAG_VERFILETYPE, &pFixedInfo->dwFileType);

    liVerData.LowPart  = pFixedInfo->dwProductVersionLS;
    liVerData.HighPart = pFixedInfo->dwProductVersionMS;
    SdbpSetAttribute(pFileInfo, TAG_BIN_PRODUCT_VERSION,      &liVerData.QuadPart);
    SdbpSetAttribute(pFileInfo, TAG_UPTO_BIN_PRODUCT_VERSION, &liVerData.QuadPart);

    liVerData.LowPart  = pFixedInfo->dwFileVersionLS;
    liVerData.HighPart = pFixedInfo->dwFileVersionMS;
    SdbpSetAttribute(pFileInfo, TAG_BIN_FILE_VERSION, &liVerData.QuadPart);
    SdbpSetAttribute(pFileInfo, TAG_UPTO_BIN_FILE_VERSION, &liVerData.QuadPart);
}


#if defined(NT_MODE) || defined(KERNEL_MODE)

BOOL
SdbpGetVersionAttributesNT(
    IN  PSDBCONTEXT    pContext,
    OUT PFILEINFO      pFileInfo,
    IN  PIMAGEFILEDATA pImageData
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   This function retrieves all of the Version-related attributes
            Imports apis from version.dll if called for the first time
--*/
{
    BOOL              bSuccess;
    LPVOID            pVersionInfo = NULL;
    VS_FIXEDFILEINFO* pFixedInfo   = NULL;
    int               i;

    //
    // First retrieve the version info.
    //
    bSuccess = SdbpGetFileVersionInformation(pImageData, &pVersionInfo, &pFixedInfo);

    if (!bSuccess) {
        DBGPRINT((sdlInfo, "SdbpGetVersionAttributesNT", "No version info.\n"));
        goto ErrHandle;
    }

    //
    // Version information available.
    //

    //
    // Set the pointer to our internal function.
    //
    pContext->pfnVerQueryValue = SdbpVerQueryValue;

    for (i = 0; i < ARRAYSIZE(g_rgVerStrings); ++i) {
        SdbpSetAttribute(pFileInfo, g_rgVerStrings[i].tTag, NULL);
    }

    SdbpSetAttribute(pFileInfo, TAG_VER_LANGUAGE, NULL);

    //
    // Query binary stuff
    //
    SdbpQueryBinVersionInformation(pContext, pFileInfo, pFixedInfo);

    pFileInfo->pVersionInfo = pVersionInfo;

    return TRUE;

ErrHandle:
    //
    // Reset all the string info.
    //
    for (i = 0; i < ARRAYSIZE(g_rgBinVerTags); ++i) {
        SdbpSetAttribute(pFileInfo, g_rgBinVerTags[i], NULL);
    }

    for (i = 0; i < ARRAYSIZE(g_rgVerStrings); ++i) {
        SdbpSetAttribute(pFileInfo, g_rgVerStrings[i].tTag, NULL);
    }

    return FALSE;
}

#endif // NT_MODE || KERNEL_MODE


BOOL
SdbpGetHeaderAttributes(
    IN  PSDBCONTEXT pContext,
    OUT PFILEINFO   pFileInfo
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   This function retrieves the header attributes for the
            specified file.
--*/
{
    IMAGEFILEDATA   ImageData;
    HANDLE          hFile;
    ULONG           ulPEChecksum = 0;
    ULONG           ulChecksum   = 0;
    DWORD           dwModuleType = 0;
    UNICODE_STRING  ModuleDescription;
    DWORD           dwLinkerVer;
    DWORD           dwLinkDate;
    BOOL            bReturn = FALSE;
    BOOL            bSuccess;
    int             i;

    ImageData.dwFlags = 0;

    if (pFileInfo->hFile != INVALID_HANDLE_VALUE) {
        ImageData.hFile   = pFileInfo->hFile;
        ImageData.dwFlags |= IMAGEFILEDATA_HANDLEVALID;
    }

    if (pFileInfo->pImageBase != NULL) {
        ImageData.pBase    = pFileInfo->pImageBase;
        ImageData.ViewSize = (SIZE_T)   pFileInfo->dwImageSize;
        ImageData.FileSize = (ULONGLONG)pFileInfo->dwImageSize;
        ImageData.dwFlags |= IMAGEFILEDATA_PBASEVALID;
    }

    //
    // SdbpOpenAndMapFile uses DOS_PATH type as an argument
    // In kernel mode this parameter is ignored.
    //
    if (SdbpOpenAndMapFile(pFileInfo->FilePath, &ImageData, DOS_PATH)) {

        bSuccess = SdbpGetModuleType(&dwModuleType, &ImageData);
        SdbpSetAttribute(pFileInfo, TAG_MODULE_TYPE, bSuccess ? (PVOID)&dwModuleType : NULL);

        bSuccess = SdbpGetModulePECheckSum(&ulPEChecksum, &dwLinkerVer, &dwLinkDate, &ImageData);
        SdbpSetAttribute(pFileInfo, TAG_PE_CHECKSUM, bSuccess ? (PVOID)&ulPEChecksum : NULL);
        SdbpSetAttribute(pFileInfo, TAG_LINKER_VERSION, bSuccess ? (PVOID)&dwLinkerVer : NULL);
        SdbpSetAttribute(pFileInfo, TAG_LINK_DATE, bSuccess ? (PVOID)&dwLinkDate : NULL);
        SdbpSetAttribute(pFileInfo, TAG_UPTO_LINK_DATE, bSuccess ? (PVOID)&dwLinkDate : NULL);

        bSuccess = SdbpGetFileChecksum(&ulChecksum, &ImageData);
        SdbpSetAttribute(pFileInfo, TAG_CHECKSUM,   bSuccess ? (PVOID)&ulChecksum   : NULL);

#ifndef KERNEL_MODE

        //
        // Now retrieve 16-bit description string, it's max size is 256 bytes.
        //
        // This attribute is not available in kernel mode.
        //
        bSuccess = SdbpGet16BitDescription(&pFileInfo->pDescription16, &ImageData);
        SdbpSetAttribute(pFileInfo, TAG_16BIT_DESCRIPTION, pFileInfo->pDescription16);
        bSuccess = SdbpGet16BitModuleName(&pFileInfo->pModuleName16, &ImageData);
        SdbpSetAttribute(pFileInfo, TAG_16BIT_MODULE_NAME,  pFileInfo->pModuleName16);

#if defined(NT_MODE)

        //
        // Hit this case only on current platform
        //
        if (pFileInfo->hFile != INVALID_HANDLE_VALUE || pFileInfo->pImageBase != NULL) {

            SdbpGetVersionAttributesNT(pContext, pFileInfo, &ImageData);
        }
#endif  // NT_MODE

#else // KERNEL_MODE

        //
        // When we are running in kernel mode retrieve version-related
        // data now as well.
        //
        SdbpGetVersionAttributesNT(pContext, pFileInfo, &ImageData);

        //
        // Retrieve file directory attributes.
        //
        SdbpGetFileDirectoryAttributesNT(pFileInfo, &ImageData);

#endif // KERNEL_MODE

        SdbpUnmapAndCloseFile(&ImageData);

        return TRUE;
    }

    for (i = 0; i < ARRAYSIZE(g_rgHeaderTags); ++i) {
        SdbpSetAttribute(pFileInfo, g_rgHeaderTags[i], NULL);
    }

#ifdef KERNEL_MODE

    //
    // Reset all the version attributes here as well.
    //
    for (i = 0; i < ARRAYSIZE(g_rgBinVerTags); ++i) {
        SdbpSetAttribute(pFileInfo, g_rgBinVerTags[i], NULL);
    }

    for (i = 0; i < ARRAYSIZE(g_rgVerStrings); ++i) {
        SdbpSetAttribute(pFileInfo, g_rgVerStrings[i].tTag, NULL);
    }
#endif // KERNEL_MODE

    return FALSE;
}


BOOL
SdbpGetAttribute(
    IN  PSDBCONTEXT pContext,
    OUT PFILEINFO   pFileInfo,
    IN  TAG         AttrID
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Retrieve an attribute for a given file. We retrieve all the
            attributes of the same class.
--*/
{
    BOOL bReturn = FALSE;

    switch (AttrID) {
    //
    // The tags below require checking the file and making a directory query.
    //
    case TAG_SIZE:

#ifndef KERNEL_MODE  // in kernel mode we fall through to header attributes

        bReturn = SdbpGetFileDirectoryAttributes(pFileInfo);
        break;

#endif // KERNEL_MODE

    //
    // The tags below require retrieving version resources.
    //
    case TAG_VERDATEHI:
    case TAG_VERDATELO:
    case TAG_VERFILEOS:
    case TAG_VERFILETYPE:
    case TAG_UPTO_BIN_PRODUCT_VERSION:
    case TAG_UPTO_BIN_FILE_VERSION:
    case TAG_BIN_FILE_VERSION:
    case TAG_BIN_PRODUCT_VERSION:
    case TAG_PRODUCT_VERSION:
    case TAG_FILE_DESCRIPTION:
    case TAG_COMPANY_NAME:
    case TAG_PRODUCT_NAME:
    case TAG_FILE_VERSION:
    case TAG_ORIGINAL_FILENAME:
    case TAG_INTERNAL_NAME:
    case TAG_LEGAL_COPYRIGHT:
    case TAG_VER_LANGUAGE:

        //
        // In KERNEL_MODE we fall through and do the attributes using the
        // header attributes.
        //

#ifndef KERNEL_MODE

        //
        // Version attributes are retrieved through the header attributes if
        // caller provided a handle/image base
        //
        if (pFileInfo->hFile == INVALID_HANDLE_VALUE && pFileInfo->pImageBase == NULL) {
            bReturn = SdbpGetVersionAttributes(pContext, pFileInfo);
            break;
        }

#endif // KERNEL_MODE

    //
    // The tags below require opening a file and mapping it into memory.
    //
    case TAG_CHECKSUM:
    case TAG_PE_CHECKSUM:
    case TAG_LINKER_VERSION:
    case TAG_16BIT_DESCRIPTION:
    case TAG_16BIT_MODULE_NAME:
    case TAG_MODULE_TYPE:
    case TAG_UPTO_LINK_DATE:
    case TAG_LINK_DATE:
        bReturn = SdbpGetHeaderAttributes(pContext, pFileInfo);
        break;
    }

    return bReturn;
}

BOOL
SdbpCheckAttribute(
    IN  PSDBCONTEXT pContext,   // Database Context pointer
    IN  PVOID       pFileData,  // pointer returned from CheckFile
    IN  TAG         AttrID,     // Attribute ID
    IN  PVOID       pAttribute  // attribute value ptr (see above for description)
    )
/*++
    Return: TRUE if the value for given attribute matches
            the file's attribute, FALSE otherwise.

    Desc:   Check an attribute against a given value. This function
            retrieves attributes as necessary.
--*/
{
    int       nAttrIndex;
    PATTRINFO pAttrInfo;
    BOOL      bReturn = FALSE;
    PFILEINFO pFileInfo = (PFILEINFO)pFileData;

    if (pAttribute == NULL) {
        DBGPRINT((sdlError, "SdbpCheckAttribute", "Invalid parameter.\n"));
        return FALSE;
    }

    nAttrIndex = TagToIndex(AttrID);

    if (nAttrIndex < 0) {
        DBGPRINT((sdlError, "SdbpCheckAttribute", "Bad Attribute ID 0x%x\n", AttrID));
        return FALSE;
    }

    //
    // Now see if this attribute is any good.
    //
    pAttrInfo = &pFileInfo->Attributes[nAttrIndex];

    if (!(pAttrInfo->dwFlags & ATTRIBUTE_AVAILABLE)) {
        //
        // See if we have tried already
        //
        if (pAttrInfo->dwFlags & ATTRIBUTE_FAILED) {
            DBGPRINT((sdlInfo,
                      "SdbpCheckAttribute",
                      "Already tried to get attr ID 0x%x.\n",
                      AttrID));
            return FALSE;
        }

        //
        // The attribute has not been retrieved yet, do it now then.
        //
        // Try to obtain this attribute from the file.
        //
        if (!SdbpGetAttribute(pContext, pFileInfo, AttrID)) {
            DBGPRINT((sdlWarning,
                      "SdbpCheckAttribute",
                      "Failed to get attribute \"%s\" for \"%s\"\n",
                      SdbTagToString(AttrID),
                      pFileInfo->FilePath));
            //
            // ATTRIBUTE_FAILED is set by the SdbpGetAttribute
            //

            return FALSE;
        }
    }

    //
    // Check again here in case we had to retrieve the attribute.
    //
    if (!(pAttrInfo->dwFlags & ATTRIBUTE_AVAILABLE)) {
        return FALSE;
    }

    switch (AttrID) {

    case TAG_BIN_PRODUCT_VERSION:
    case TAG_BIN_FILE_VERSION:

        bReturn = SdbpCheckVersion(*(ULONGLONG*)pAttribute, pAttrInfo->ullAttr);

        if (!bReturn) {
            ULONGLONG qwDBFileVer  = *(ULONGLONG*)pAttribute;
            ULONGLONG qwBinFileVer = pAttrInfo->ullAttr;

            DBGPRINT((sdlInfo,
                      "SdbpCheckAttribute",
                      "\"%s\" mismatch file: \"%s\". Expected %d.%d.%d.%d, Found %d.%d.%d.%d\n",
                      SdbTagToString(AttrID),
                      pFileInfo->FilePath,
                      (WORD)(qwDBFileVer >> 48),
                      (WORD)(qwDBFileVer >> 32),
                      (WORD)(qwDBFileVer >> 16),
                      (WORD)(qwDBFileVer),
                      (WORD)(qwBinFileVer >> 48),
                      (WORD)(qwBinFileVer >> 32),
                      (WORD)(qwBinFileVer >> 16),
                      (WORD)(qwBinFileVer)));

        }
        break;

    case TAG_UPTO_BIN_PRODUCT_VERSION:
    case TAG_UPTO_BIN_FILE_VERSION:

        bReturn = SdbpCheckUptoVersion(*(ULONGLONG*)pAttribute, pAttrInfo->ullAttr);

        if (!bReturn) {
            ULONGLONG qwDBFileVer  = *(ULONGLONG*)pAttribute;
            ULONGLONG qwBinFileVer = pAttrInfo->ullAttr;

            DBGPRINT((sdlInfo,
                      "SdbpCheckAttribute",
                      "\"%s\" mismatch file: \"%s\". Expected %d.%d.%d.%d, Found %d.%d.%d.%d\n",
                      SdbTagToString(AttrID),
                      pFileInfo->FilePath,
                      (WORD)(qwDBFileVer >> 48),
                      (WORD)(qwDBFileVer >> 32),
                      (WORD)(qwDBFileVer >> 16),
                      (WORD)(qwDBFileVer),
                      (WORD)(qwBinFileVer >> 48),
                      (WORD)(qwBinFileVer >> 32),
                      (WORD)(qwBinFileVer >> 16),
                      (WORD)(qwBinFileVer)));
        }
        break;

    case TAG_UPTO_LINK_DATE:
        bReturn = (*(DWORD*)pAttribute >= pAttrInfo->dwAttr);

        if (!bReturn) {
            DBGPRINT((sdlInfo,
                      "SdbpCheckAttribute",
                      "\"%s\" mismatch file \"%s\". Expected less than 0x%x Found 0x%x\n",
                      SdbTagToString(AttrID),
                      pFileInfo->FilePath,
                      *(DWORD*)pAttribute,
                      pAttrInfo->dwAttr));
        }
        break;

    default:

        switch (GETTAGTYPE(AttrID)) {
        case TAG_TYPE_DWORD:
            //
            // This is likely to be hit first.
            //
            bReturn = (*(DWORD*)pAttribute == pAttrInfo->dwAttr);

            if (!bReturn) {
                DBGPRINT((sdlInfo,
                          "SdbpCheckAttribute",
                          "\"%s\" mismatch file \"%s\". Expected 0x%x Found 0x%x\n",
                          SdbTagToString(AttrID),
                          pFileInfo->FilePath,
                          *(DWORD*)pAttribute,
                          pAttrInfo->dwAttr));
            }
            break;

        case TAG_TYPE_STRINGREF:
            bReturn = SdbpPatternMatch((LPCTSTR)pAttribute, (LPCTSTR)pAttrInfo->lpAttr);

            if (!bReturn) {
                DBGPRINT((sdlInfo,
                          "SdbpCheckAttribute",
                          "\"%s\" mismatch file \"%s\". Expected \"%s\" Found \"%s\"\n",
                          SdbTagToString(AttrID),
                          pFileInfo->FilePath,
                          pAttribute,
                          pAttrInfo->lpAttr));

            }
            break;

        case TAG_TYPE_QWORD:
            bReturn = (*(ULONGLONG*)pAttribute == pAttrInfo->ullAttr);

            if (!bReturn) {
                DBGPRINT((sdlInfo,
                          "SdbpCheckAttribute",
                          "\"%s\" mismatch file \"%s\". Expected 0x%I64x Found 0x%I64x\n",
                          SdbTagToString(AttrID),
                          pFileInfo->FilePath,
                          *(ULONGLONG*)pAttribute,
                          pAttrInfo->ullAttr));
            }

            break;
        }
        break;
    }

    return bReturn;
}


PFILEINFO
FindFileInfo(
    IN  PSDBCONTEXT pContext,
    IN  LPCTSTR     FilePath
    )
/*++
    Return: A pointer to the cached FILEINFO structure if one is found
            or NULL otherwise.

    Desc:   This function performs a search in the file cache to determine whether
            a given file has already been touched.
--*/
{
    PFILEINFO pFileInfo = (PFILEINFO)pContext->pFileAttributeCache; // global cache

    while (pFileInfo != NULL) {
        if (ISEQUALSTRING(pFileInfo->FilePath, FilePath)) {
            DBGPRINT((sdlInfo,
                      "FindFileInfo",
                      "FILEINFO for \"%s\" found in the cache.\n",
                      FilePath));
            return pFileInfo;
        }

        pFileInfo = pFileInfo->pNext;
    }

    return NULL;
}

PFILEINFO
CreateFileInfo(
    IN  PSDBCONTEXT pContext,
    IN  LPCTSTR     FullPath,
    IN  DWORD       dwLength OPTIONAL,  // length (in characters) of FullPath string
    IN  HANDLE      hFile OPTIONAL,   // file handle
    IN  LPVOID      pImageBase OPTIONAL,
    IN  DWORD       dwImageSize OPTIONAL,
    IN  BOOL        bNoCache
    )
/*++
    Return: A pointer to the allocated FILEINFO structure.

    Desc:   Allocates the FILEINFO structure for the specified file.
--*/
{
    PFILEINFO pFileInfo;
    SIZE_T    sizeBase;
    SIZE_T    size;
    DWORD     nPathLen;

    nPathLen  = dwLength ? dwLength : (DWORD)_tcslen(FullPath);

    sizeBase  = sizeof(*pFileInfo) + ATTRIBUTE_COUNT * sizeof(ATTRINFO);
    size      = sizeBase + (nPathLen + 1) * sizeof(*FullPath);

    pFileInfo = (PFILEINFO)SdbAlloc(size);

    if (pFileInfo == NULL) {
        DBGPRINT((sdlError,
                  "CreateFileInfo",
                  "Failed to allocate %d bytes for FILEINFO structure.\n",
                  size));
        return NULL;
    }

    RtlZeroMemory(pFileInfo, size);

    pFileInfo->FilePath = (LPTSTR)((PBYTE)pFileInfo + sizeBase);

    RtlCopyMemory(pFileInfo->FilePath, FullPath, nPathLen * sizeof(*FullPath));

    pFileInfo->FilePath[nPathLen] = TEXT('\0');

    pFileInfo->hFile       = hFile;
    pFileInfo->pImageBase  = pImageBase;
    pFileInfo->dwImageSize = dwImageSize;

    //
    // Now link it in if we use the cache.
    //
    if (!bNoCache) {
        pFileInfo->pNext = (PFILEINFO)pContext->pFileAttributeCache;
        pContext->pFileAttributeCache = (PVOID)pFileInfo;
    }

    return pFileInfo;
}


void
SdbFreeFileInfo(
    IN  PVOID pFileData         // pointer returned from SdbpGetFileAttributes
    )
/*++
    Return: void.

    Desc:   Self explanatory. Use this only after calling GetFileInfo
            with bNoCache set to TRUE.
--*/
{
    PFILEINFO pFileInfo = (PFILEINFO)pFileData;

    if (pFileInfo == NULL) {
        DBGPRINT((sdlError, "SdbFreeFileInfo", "Invalid parameter.\n"));
        return;
    }

    if (pFileInfo->pVersionInfo != NULL) {
        SdbFree(pFileInfo->pVersionInfo);
    }

    if (pFileInfo->pDescription16 != NULL) {
        SdbFree(pFileInfo->pDescription16);
    }

    if (pFileInfo->pModuleName16 != NULL) {
        SdbFree(pFileInfo->pModuleName16);
    }

    SdbFree(pFileInfo);
}

void
SdbpCleanupAttributeMgr(
    IN  PSDBCONTEXT pContext    // database context
    )
/*++
    Return: void.

    Desc:   This function should be called afer we are done checking a given exe
            it performs cleanup tasks, such as:
            . unload dynamically linked dll (version.dll)
            . cleanup file cache
--*/
{
    PFILEINFO pFileInfo = (PFILEINFO)pContext->pFileAttributeCache;
    PFILEINFO pNext;

    while (pFileInfo != NULL) {
        pNext = pFileInfo->pNext;
        SdbFreeFileInfo(pFileInfo);
        pFileInfo = pNext;
    }

    //
    // Reset the cache pointer.
    //
    pContext->pFileAttributeCache = NULL;
}


BOOL
SdbpCheckAllAttributes(
    IN  PSDBCONTEXT pContext,   // pointer to the database channel
    IN  PDB         pdb,        // pointer to the Shim Database that we're checking against
    IN  TAGID       tiMatch,    // TAGID for a given file(exe) to be checked
    IN  PVOID       pFileData   // pointer returned from CheckFile
    )
/*++
    Return: TRUE if all the file's attributes match the ones described in the
            database for this file, FALSE otherwise.

    Desc:   TBD
--*/
{
    int         i;
    TAG         tAttrID;
    PVOID       pAttribute;
    TAGID       tiTemp;
    DWORD       dwAttribute;
    ULONGLONG   ullAttribute;
    BOOL        bReturn = TRUE;  // match by default

    assert(tiMatch != TAGID_NULL);

    if (pFileData == NULL) {
        //
        // No file was passed in. This can happen if LOGIC="NOT" is used.
        //
        return FALSE;
    }

    for (i = 0; i < ATTRIBUTE_COUNT && bReturn; ++i) {

        tAttrID = g_rgAttributeTags[i];
        tiTemp = SdbFindFirstTag(pdb, tiMatch, tAttrID);

        if (tiTemp != TAGID_NULL) {
            pAttribute = NULL;

            switch (GETTAGTYPE(tAttrID)) {
            
            case TAG_TYPE_DWORD:
                dwAttribute = SdbReadDWORDTag(pdb, tiTemp, 0);
                pAttribute = &dwAttribute;
                break;

            case TAG_TYPE_QWORD:
                ullAttribute = SdbReadQWORDTag(pdb, tiTemp, 0);
                pAttribute = &ullAttribute;
                break;

            case TAG_TYPE_STRINGREF:
                pAttribute = SdbGetStringTagPtr(pdb, tiTemp);
                break;
            }

            //
            // Now check the attribute.
            //
            bReturn = SdbpCheckAttribute(pContext, pFileData, tAttrID, pAttribute);

            //
            // we bail out if !bReturn via the condition in FOR loop above
            //
        }
    }

    return bReturn;
}


//
// VERSION DATA
//


/*--

  Search order is:

  - Language neutral, Unicode (0x000004B0)
  - Language neutral, Windows-multilingual (0x000004e4)
  - US English, Unicode (0x040904B0)
  - US English, Windows-multilingual (0x040904E4)

  If none of those exist, it's not likely we're going to get good
  matching info from what does exist.

--*/

LPTSTR
SdbpQueryVersionString(
    IN  PSDBCONTEXT      pContext,       // the database channel
    IN  PVOID            pVersionData,   // Version data buffer
    IN  PLANGANDCODEPAGE pTranslations,
    IN  DWORD            TranslationCount,
    IN  LPCTSTR          szString        // String to search for; see VerQueryValue in MSDN
    )
/*++
    Return: The pointer to the string if found, NULL if not.

    Desc:   Gets a pointer to a particular string in the StringFileInfo section
            of a version resource.
            Lookup is performed for known english-language resources followed up
            by a lookup in the available translations section (if such was found)
--*/
{
    TCHAR  szTemp[128];
    LPTSTR szReturn = NULL;
    int    i;

    static DWORD adwLangs[] = {0x000004B0, 0x000004E4, 0x040904B0, 0x040904E4};

    assert(pVersionData && szString);

    for (i = 0; i < ARRAYSIZE(adwLangs); ++i) {
        UINT unLen;

        _stprintf(szTemp, _T("\\StringFileInfo\\%08X\\%s"), adwLangs[i], szString);
        if (pContext->pfnVerQueryValue(pVersionData, szTemp, (PVOID*)&szReturn, &unLen)) {
            return szReturn;
        }
    }

    if (pTranslations != NULL) {
        for (i = 0; i < (int)TranslationCount; ++i, ++pTranslations) {
            UINT unLen;

            _stprintf(szTemp, _T("\\StringFileInfo\\%04X%04X\\%s"),
                      (DWORD)pTranslations->wLanguage,
                      (DWORD)pTranslations->wCodePage,
                      szString);

            if (pContext->pfnVerQueryValue(pVersionData, szTemp, (PVOID*)&szReturn, &unLen)) {
                return szReturn;
            }
        }
    }

    return NULL; // none found
}

BOOL
SdbpGetModuleType(
    OUT LPDWORD lpdwModuleType,
    IN  PIMAGEFILEDATA pImageData
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Gets a pointer to a particular string in the StringFileInfo section
            of a version resource.
--*/
{
    PIMAGE_DOS_HEADER pDosHeader;
    DWORD             dwModuleType = MT_UNKNOWN_MODULE;
    LPBYTE            lpSignature;
    DWORD             OffsetNew;

    pDosHeader = (PIMAGE_DOS_HEADER)pImageData->pBase;
    if (pDosHeader == NULL || pDosHeader == (PIMAGE_DOS_HEADER)-1) {
        return FALSE;
    }

    //
    // Check size and read signature.
    //
    if (pImageData->ViewSize < sizeof(*pDosHeader) || pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        return FALSE;
    }

    //
    // Assume DOS module.
    //
    dwModuleType = MT_DOS_MODULE;
    OffsetNew = (DWORD)pDosHeader->e_lfanew;

    //
    // New header signature. Check offset.
    //
    if (pImageData->ViewSize < OffsetNew + sizeof(DWORD)) {
        return FALSE;
    }

    lpSignature = ((LPBYTE)pImageData->pBase + OffsetNew);

    if (IMAGE_NT_SIGNATURE == *(LPDWORD)lpSignature) {
        dwModuleType = MT_W32_MODULE;
    } else if (IMAGE_OS2_SIGNATURE == *(PWORD)lpSignature) {
        dwModuleType = MT_W16_MODULE;
    }

    if (lpdwModuleType != NULL) {
        *lpdwModuleType = dwModuleType;
    }

    return TRUE;
}

BOOL
SdbpGetImageNTHeader(
    OUT PIMAGE_NT_HEADERS* ppHeader,
    IN  PIMAGEFILEDATA     pImageData
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Gets a pointer to the IMAGE_NT_HEADERS.
--*/
{
    PIMAGE_DOS_HEADER pDosHeader;
    PIMAGE_NT_HEADERS pNtHeaders = NULL;
    DWORD             ModuleType;

    if (!SdbpGetModuleType(&ModuleType, pImageData)) {
        return FALSE;
    }

    if (ModuleType != MT_W32_MODULE) {
        return FALSE;
    }

    //
    // Header is valid.
    //
    pDosHeader = (PIMAGE_DOS_HEADER)pImageData->pBase;
    pNtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)pImageData->pBase + pDosHeader->e_lfanew);

    if (pImageData->ViewSize >= pDosHeader->e_lfanew + sizeof(*pNtHeaders)) { // not too short?
        *ppHeader = pNtHeaders;
        return TRUE;
    }

    return FALSE;
}


BOOL
SdbpGetModulePECheckSum(
    OUT PULONG         pChecksum,
    OUT LPDWORD        pdwLinkerVersion,
    OUT LPDWORD        pdwLinkDate,
    IN  PIMAGEFILEDATA pImageData
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Gets the checksum from the PE headers.
--*/
{
    PIMAGE_NT_HEADERS pNtHeader;
    PIMAGE_DOS_HEADER pDosHeader;
    ULONG             ulChecksum = 0;

    if (!SdbpGetImageNTHeader(&pNtHeader, pImageData)) {
        DBGPRINT((sdlError, "SdbpGetModulePECheckSum", "Failed to get Image NT header.\n"));
        return FALSE;
    }

    pDosHeader = (PIMAGE_DOS_HEADER)pImageData->pBase;

    //
    // Fill in the linker version (as it used to calculated in ntuser).
    //
    *pdwLinkerVersion = (pNtHeader->OptionalHeader.MinorImageVersion & 0xFF) +
                        ((pNtHeader->OptionalHeader.MajorImageVersion & 0xFF) << 16);

    *pdwLinkDate = pNtHeader->FileHeader.TimeDateStamp;

    switch (pNtHeader->OptionalHeader.Magic) {
    case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
        if (pImageData->ViewSize >= pDosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS32)) {
            ulChecksum = ((PIMAGE_NT_HEADERS32)pNtHeader)->OptionalHeader.CheckSum;
            *pChecksum = ulChecksum;
            return TRUE;
        }
        break;


    case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
        //
        // Do an additional check.
        //
        if (pImageData->ViewSize >= pDosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS64)) {
            ulChecksum = ((PIMAGE_NT_HEADERS64)pNtHeader)->OptionalHeader.CheckSum;
            *pChecksum = ulChecksum;
            return TRUE;
        }
        break;

    default:
        //
        // Unknown image type ?
        //
        DBGPRINT((sdlError,
                  "SdbpGetModulePECheckSum",
                  "Bad image type 0x%x\n",
                  pNtHeader->OptionalHeader.Magic));
        *pChecksum = 0;
        break;
    }

    return FALSE;
}

#define CHECKSUM_SIZE  4096
#define CHECKSUM_START 512


BOOL
SdbpGetFileChecksum(
    OUT PULONG         pChecksum,
    IN  PIMAGEFILEDATA pImageData
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Calculates a checksum for the file.
--*/
{
    ULONG   size = CHECKSUM_SIZE;
    ULONG   StartAddress = CHECKSUM_START;
    ULONG   ulChecksum = 0;
    LPDWORD lpdw;
    int     i;

    if ((SIZE_T)pImageData->FileSize < (SIZE_T)size) {
        StartAddress = 0;
        size = (ULONG)pImageData->FileSize; // this is safe (size is rather small)
    } else if ((SIZE_T)(size + StartAddress) > (SIZE_T)pImageData->FileSize) {
        //
        // The cast here is safe (FileSize is small)
        //
        StartAddress = (ULONG)(pImageData->FileSize - size);
    }

    if (size >= sizeof(DWORD)) {

        ULONG ulCarry;

        lpdw = (LPDWORD)((LPBYTE)pImageData->pBase + StartAddress);

        for (i = 0; i < (INT)(size/sizeof(DWORD)); ++i) {
            
            if (PtrToUlong(lpdw) & 0x3) { // alignment fault fixup
                ulChecksum += *((DWORD UNALIGNED*)lpdw);
                lpdw++;
            } else {
                ulChecksum += *lpdw++;
            }

            ulCarry = ulChecksum & 1;
            ulChecksum >>= 1;
            
            if (ulCarry) {
                ulChecksum |= 0x80000000;
            }
        }
    }

    *pChecksum = ulChecksum;
    return TRUE;
}


BOOL
SdbpCheckVersion(
    IN  ULONGLONG qwDBFileVer,
    IN  ULONGLONG qwBinFileVer
    )
/*++
    Return: TRUE if the versions match, FALSE if they don't.

    Desc:   Checks a binary version from the db against the version from
            the file, including allowing for wildcards, which are represented
            in the DB by using FFFF for that word-sized portion of the version.
--*/
{
    WORD wDBSegment, wFileSegment;
    int  i;

    for (i = 3; i >= 0; --i) {
        //
        // Get the appropriate word out of the QWORD
        //
        wDBSegment = (WORD)(qwDBFileVer >> (16 * i));
        wFileSegment = (WORD)(qwBinFileVer >> (16 * i));

        //
        // The DB segment may be 0xFFFF, in which case it matches on
        // everything.
        //
        if (wDBSegment != wFileSegment && wDBSegment != 0xFFFF) {
            return FALSE;
        }
    }

    return TRUE;
}



BOOL
SdbpCheckUptoVersion(
    IN  ULONGLONG qwDBFileVer,
    IN  ULONGLONG qwBinFileVer
    )
/*++
    Return: TRUE if the versions match, FALSE if they don't.

    Desc:   Checks a binary version from the db against the version from
            the file, including allowing for wildcards, which are represented
            in the DB by using FFFF for that word-sized portion of the version.
--*/
{
    WORD wDBSegment, wFileSegment;
    BOOL bReturn = TRUE;
    int  i;

    for (i = 3; i >= 0; --i) {
        //
        // Get the appropriate word out of the QWORD
        //
        wDBSegment = (WORD)(qwDBFileVer >> (16 * i));
        wFileSegment = (WORD)(qwBinFileVer >> (16 * i));

        if (wDBSegment == wFileSegment || wDBSegment == 0xFFFF) {
            continue;
        }

        //
        // At this point we know that the two values don't match
        // the wFileSegment has to be less than wDBSegment to satisfy this
        // test - so set bReturn and exit
        //

        bReturn = (wDBSegment > wFileSegment);
        break;

    }

    return bReturn;
}


#ifndef KERNEL_MODE

BOOL
SdbFormatAttribute(
    IN  PATTRINFO pAttrInfo,    // pointer to the attribute information
    OUT LPTSTR    pchBuffer,    // receives XML corresponding to the given attribute
    IN  DWORD     dwBufferSize  // size in wide characters of the buffer pchBuffer
    )
/*++
    Return: FALSE if the buffer is too small or attribute not available.

    Desc:   TBD.
--*/
{
    int nchBuffer = (int)dwBufferSize;
    int nch;
    TCHAR lpszAttr[MAX_PATH];

#if defined(WIN32A_MODE) || defined(WIN32U_MODE)
    struct tm* ptm;
    time_t tt;
#else
    LARGE_INTEGER liTime;
    TIME_FIELDS   TimeFields;
#endif

    if (!(pAttrInfo->dwFlags & ATTRIBUTE_AVAILABLE)) {
        return FALSE;
    }

    nch = _sntprintf(pchBuffer, nchBuffer, TEXT("%s="), SdbTagToString(pAttrInfo->tAttrID));

    if (nch < 0) {
        DBGPRINT((sdlError,
                  "SdbFormatAttribute",
                  "Buffer is too small to accomodate \"%s\"\n",
                  SdbTagToString(pAttrInfo->tAttrID)));
        return FALSE;
    }

    nchBuffer -= nch; // we advance the pointer past the "name="
    pchBuffer += nch;
    nch = -1;

    switch (pAttrInfo->tAttrID) {
    case TAG_BIN_PRODUCT_VERSION:
    case TAG_BIN_FILE_VERSION:
    case TAG_UPTO_BIN_PRODUCT_VERSION:
    case TAG_UPTO_BIN_FILE_VERSION:
        nch = _sntprintf(pchBuffer, nchBuffer, TEXT("\"%d.%d.%d.%d\""),
                         (WORD)(pAttrInfo->ullAttr >> 48),
                         (WORD)(pAttrInfo->ullAttr >> 32),
                         (WORD)(pAttrInfo->ullAttr >> 16),
                         (WORD)(pAttrInfo->ullAttr));

        break;

    case TAG_MODULE_TYPE:
        nch = _sntprintf(pchBuffer, nchBuffer, TEXT("\"%s\""),
                         SdbpModuleTypeToString(pAttrInfo->dwAttr));
        break;


    case TAG_VER_LANGUAGE:
        //
        // language is a dword attribute that we shall make a string out of
        //
        {
            TCHAR szLanguageName[MAX_PATH];
            DWORD dwLength;

            szLanguageName[0] = TEXT('\0');
            
            dwLength = VerLanguageName((LANGID)pAttrInfo->dwAttr,
                                       szLanguageName,
                                       CHARCOUNT(szLanguageName));
            
            if (dwLength) {
                nch = _sntprintf(pchBuffer, nchBuffer, TEXT("\"%s [0x%x]\""),
                                 szLanguageName, pAttrInfo->dwAttr);
            } else {
                nch = _sntprintf(pchBuffer, nchBuffer, TEXT("\"0x%x\""),
                                 pAttrInfo->dwAttr);
            }

        }
        break;

    case TAG_LINK_DATE:
    case TAG_UPTO_LINK_DATE:

#if defined(WIN32A_MODE) || defined(WIN32U_MODE)

        tt = (time_t) pAttrInfo->dwAttr;
        ptm = gmtime(&tt);
        if (ptm) {
            nch = _sntprintf(pchBuffer, nchBuffer, TEXT("\"%02d/%02d/%02d %02d:%02d:%02d\""),
                             ptm->tm_mon+1,
                             ptm->tm_mday,
                             ptm->tm_year+1900,
                             ptm->tm_hour,
                             ptm->tm_min,
                             ptm->tm_sec);
        }
#else
        RtlSecondsSince1970ToTime((ULONG)pAttrInfo->dwAttr, &liTime);
        RtlTimeToTimeFields(&liTime, &TimeFields);
        nch = _sntprintf(pchBuffer, nchBuffer, TEXT("\"%02d/%02d/%02d %02d:%02d:%02d\""),
                         TimeFields.Month,
                         TimeFields.Day,
                         TimeFields.Year,
                         TimeFields.Hour,
                         TimeFields.Minute,
                         TimeFields.Second);

#endif
        break;

    case TAG_SIZE:
        nch = _sntprintf(pchBuffer, nchBuffer, TEXT("\"%ld\""), pAttrInfo->dwAttr);
        break;
    
    default:

        switch (GETTAGTYPE(pAttrInfo->tAttrID)) {
        case TAG_TYPE_DWORD:
            nch = _sntprintf(pchBuffer, nchBuffer, TEXT("\"0x%lX\""),
                             pAttrInfo->dwAttr);
            break;

        case TAG_TYPE_QWORD:
            //
            // This is an unidentified QWORD attribute
            //
            DBGPRINT((sdlError, "SdbFormatAttribute", "Unexpected qword attribute found\n"));
            nch = _sntprintf(pchBuffer, nchBuffer, TEXT("\"0x%I64X\""), pAttrInfo->ullAttr);
            break;

        case TAG_TYPE_STRINGREF:
            if (nchBuffer < 3) {
                return FALSE; // not enough room even for " ?
            }

            *pchBuffer++ = TEXT('\"');
            nchBuffer--;

            if (!SdbpSanitizeXML(pchBuffer, nchBuffer, pAttrInfo->lpAttr)) {
                // handle error please
                return FALSE;
            }
            
            //
            // Once done with this, sanitize further
            //
            if (!SafeNCat(pchBuffer, nchBuffer, TEXT("\""), -1)) {
                return FALSE;
            }
            
            nch = 0;
            break;
        }
    }

    return (nch >= 0); // evaluates to TRUE when we successfully printed the value into the buffer
}

BOOL
SdbpGetVersionAttributes(
    IN  PSDBCONTEXT pContext,
    OUT PFILEINFO   pFileInfo
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   This function retrieves all of the Version-related attributes
            Imports apis from version.dll if called for the first time
--*/
{
    BOOL                bSuccess;
    DWORD               dwNull = 0;
    VS_FIXEDFILEINFO*   pFixedInfo    = NULL; // fixed info ptr
    UINT                FixedInfoSize = 0;
    PVOID               pBuffer       = NULL; // version data buffer
    DWORD               dwBufferSize;         // version data buffer size
    int                 i;

#ifdef NT_MODE
    //
    // check to see whether we need to run NT routine
    //
    if (pFileInfo->hFile != INVALID_HANDLE_VALUE || pFileInfo->pImageBase != NULL) {

        //
        // not an error -- this case is handled in header attributes
        //

        goto err;
    }

#endif // NT_MODE

    if (pContext == NULL) {
        //
        // Special case when it's called with null context.
        // In this case we use an internal structure allocated from the stack.
        //
        STACK_ALLOC(pContext, sizeof(SDBCONTEXT));

        if (pContext == NULL) {
            DBGPRINT((sdlError,
                      "SdbpGetVersionAttributes",
                      "Failed to allocate %d bytes from stack\n",
                      sizeof(SDBCONTEXT)));
            goto err;
        }

        RtlZeroMemory(pContext, sizeof(SDBCONTEXT));
    }

#ifdef WIN32A_MODE

    pContext->pfnGetFileVersionInfoSize = GetFileVersionInfoSizeA;
    pContext->pfnGetFileVersionInfo     = GetFileVersionInfoA;
    pContext->pfnVerQueryValue          = VerQueryValueA;

#else

    pContext->pfnGetFileVersionInfoSize = GetFileVersionInfoSizeW;
    pContext->pfnGetFileVersionInfo     = GetFileVersionInfoW;
    pContext->pfnVerQueryValue          = VerQueryValueW;

#endif

    dwBufferSize = pContext->pfnGetFileVersionInfoSize(pFileInfo->FilePath, &dwNull);

    if (dwBufferSize == 0) {
        DBGPRINT((sdlInfo, "SdbpGetVersionAttributes", "No version info.\n"));
        //
        // We have failed to obtain version attributes
        //
        goto err;
    }

    pBuffer = SdbAlloc(dwBufferSize + VERSIONINFO_BUFFER_PAD);

    if (pBuffer == NULL) {
        DBGPRINT((sdlError,
                  "SdbpGetVersionAttributes",
                  "Failed to allocate %d bytes for version info buffer.\n",
                  dwBufferSize + VERSIONINFO_BUFFER_PAD));
        goto err;
    }

    if (!pContext->pfnGetFileVersionInfo(pFileInfo->FilePath, 0, dwBufferSize, pBuffer)) {
        DBGPRINT((sdlError,
                  "SdbpGetVersionAttributes",
                  "Failed to retrieve version info for file \"%s\"",
                  pFileInfo->FilePath));
        goto err;
    }

    if (!pContext->pfnVerQueryValue(pBuffer,
                                    TEXT("\\"),
                                    (PVOID*)&pFixedInfo,
                                    &FixedInfoSize)) {
        DBGPRINT((sdlError,
                  "SdbpGetVersionAttributes",
                  "Failed to query for fixed version info size for \"%s\"\n",
                  pFileInfo->FilePath));
        goto err;
    }

    //
    // Retrieve string attributes.
    //
    SdbpQueryStringVersionInformation(pContext, pFileInfo, pBuffer);

    //
    // Now retrieve other attributes.
    //
    if (FixedInfoSize >= sizeof(VS_FIXEDFILEINFO)) {

        SdbpQueryBinVersionInformation(pContext, pFileInfo, pFixedInfo);

    } else {
        //
        // No other version attributes are available. Set the rest of the
        // attributes as being not available.
        //
        for (i = 0; i < ARRAYSIZE(g_rgBinVerTags); ++i) {
            SdbpSetAttribute(pFileInfo, g_rgBinVerTags[i], NULL);
        }
    }

    //
    // Store the pointer to the version info buffer.
    //
    pFileInfo->pVersionInfo = pBuffer;
    return TRUE;

err:
    //
    // We are here ONLY when we failed to obtain version info
    // through apis -- regardless of the state of other value we might have
    // obtained

    if (pBuffer != NULL) {
        SdbFree(pBuffer);
    }

    for (i = 0; i < ARRAYSIZE(g_rgBinVerTags); ++i) {
        SdbpSetAttribute(pFileInfo, g_rgBinVerTags[i], NULL);
    }

    for (i = 0; i < ARRAYSIZE(g_rgVerStrings); ++i) {
        SdbpSetAttribute(pFileInfo, g_rgVerStrings[i].tTag, NULL);
    }

    return FALSE;
}

BOOL
SdbpGetFileDirectoryAttributes(
    OUT PFILEINFO pFileInfo
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   This function retrieves the file directory attributes for the
            specified file.
--*/
{
    BOOL                    bSuccess = FALSE;
    FILEDIRECTORYATTRIBUTES fda;
    int                     i;

    bSuccess = SdbpQueryFileDirectoryAttributes(pFileInfo->FilePath, &fda);

    if (!bSuccess) {
        DBGPRINT((sdlInfo,
                  "SdbpGetFileDirectoryAttributes",
                  "No file directory attributes available.\n"));
        goto Done;
    }

    if (fda.dwFlags & FDA_FILESIZE) {
        assert(fda.dwFileSizeHigh == 0);
        SdbpSetAttribute(pFileInfo, TAG_SIZE, &fda.dwFileSizeLow);
    }

Done:

    if (!bSuccess) {
        for (i = 0; g_rgDirectoryTags[i] != 0; ++i) {
            SdbpSetAttribute(pFileInfo, g_rgDirectoryTags[i], NULL);
        }
    }

    return bSuccess;
}

BOOL
SdbGetFileAttributes(
    IN  LPCTSTR    lpwszFileName,   // the file for which attributes are requested
    OUT PATTRINFO* ppAttrInfo,      // receives allocated pointer to the attribute array
    OUT LPDWORD    lpdwAttrCount    // receives the number of entries in an attributes table
    )
/*++
    Return: FALSE if the file does not exist or some other severe error had occured.
            Note that each attribute has it's own flag ATTRIBUTE_AVAILABLE that allows
            for checking whether an attribute has been retrieved successfully
            Not all attributes might be present for all files.

    Desc:   TBD
--*/
{
    PFILEINFO pFileInfo;
    BOOL      bReturn;

    //
    // The call below allocates the structure, context is not used
    //
    pFileInfo = SdbGetFileInfo(NULL, lpwszFileName, INVALID_HANDLE_VALUE, NULL, 0, TRUE);

    if (pFileInfo == NULL) {
        DBGPRINT((sdlError, "SdbGetFileAttributes", "Error retrieving FILEINFO structure\n"));
        return FALSE;
    }

    //
    // The three calls below, even when fail do not produce a fatal condition
    // as the exe may not have all the attributes available.
    //
    bReturn = SdbpGetFileDirectoryAttributes(pFileInfo);
    if (!bReturn) {
        DBGPRINT((sdlInfo, "SdbGetFileAttributes", "Error retrieving directory attributes\n"));
    }

    bReturn = SdbpGetVersionAttributes(NULL, pFileInfo);
    if (!bReturn) {
        DBGPRINT((sdlInfo, "SdbGetFileAttributes", "Error retrieving version attributes\n"));
    }

    bReturn = SdbpGetHeaderAttributes(NULL, pFileInfo);
    if (!bReturn) {
        DBGPRINT((sdlInfo, "SdbGetFileAttributes", "Error retrieving header attributes\n"));
    }

    pFileInfo->dwMagic = FILEINFO_MAGIC;

    //
    // Now that we are done, put the return pointer.
    //
    if (lpdwAttrCount != NULL) {
        *lpdwAttrCount = ATTRIBUTE_COUNT;
    }

    if (ppAttrInfo != NULL) {

        //
        // Return the pointer to the attribute info itself.
        // It is the same pointer we expect to get in a complimentary
        // call to SdbFreeFileInfo.
        //
        *ppAttrInfo = &pFileInfo->Attributes[0];

    } else {

        //
        // Pointer is not needed. Release the memory.
        //
        SdbFreeFileInfo(pFileInfo);
    }

    return TRUE;
}

BOOL
SdbFreeFileAttributes(
    IN  PATTRINFO pFileAttributes   // pointer returned by SdbGetFileAttributes
    )
/*++
    Return: FALSE if a wrong pointer was passed in (not the one
            from SdbGetFileAttributes).

    Desc:   Self explanatory.
--*/
{
    PFILEINFO pFileInfo;

    //
    // We are assuming the pointer that was passed in points inside of a
    // larger structure FILEINFO. To verify that we step back a pre-determined number
    // of bytes (calculated below as an offset) and check the "magic" signature.
    //
    pFileInfo = (PFILEINFO)((PBYTE)pFileAttributes - OFFSETOF(FILEINFO, Attributes));

    if (pFileInfo->dwMagic != FILEINFO_MAGIC) {
        DBGPRINT((sdlError, "SdbFreeFileAttributes", "Bad pointer to attributes.\n"));
        return FALSE;
    }

    SdbFreeFileInfo(pFileInfo);

    return TRUE;
}

BOOL
SdbpQuery16BitDescription(
    OUT LPSTR szBuffer,             // min length 256 chars !
    IN  PIMAGEFILEDATA pImageData
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Gets the 16 bit description for a DOS executable.
--*/
{
    PIMAGE_DOS_HEADER pDosHeader;
    PIMAGE_OS2_HEADER pNEHeader;
    PBYTE             pSize;
    DWORD             ModuleType;

    if (!SdbpGetModuleType(&ModuleType, pImageData)) {
        return FALSE;
    }

    if (ModuleType != MT_W16_MODULE) {
        return FALSE;
    }

    pDosHeader = (PIMAGE_DOS_HEADER)pImageData->pBase;
    pNEHeader  = (PIMAGE_OS2_HEADER)((PBYTE)pImageData->pBase + pDosHeader->e_lfanew);

    //
    // Now we know that pNEHeader is valid, just have to make sure that
    // the next offset is valid as well, make a check against file size.
    //
    if (pImageData->ViewSize < pDosHeader->e_lfanew + sizeof(*pNEHeader)) {
        return FALSE;
    }

    if (pImageData->ViewSize < pNEHeader->ne_nrestab + sizeof(*pSize)) {
        return FALSE;
    }

    pSize = (PBYTE)((PBYTE)pImageData->pBase + pNEHeader->ne_nrestab);

    if (*pSize == 0) {
        return FALSE;
    }

    //
    // Now check for the string size.
    //
    if (pImageData->ViewSize < pNEHeader->ne_nrestab + sizeof(*pSize) + *pSize) {
        return FALSE;
    }

    RtlCopyMemory(szBuffer, pSize + 1, *pSize);
    szBuffer[*pSize] = '\0';

    return TRUE;
}

BOOL
SdbpQuery16BitModuleName(
    OUT LPSTR          szBuffer,
    IN  PIMAGEFILEDATA pImageData
    )
{
    PIMAGE_DOS_HEADER pDosHeader;
    PIMAGE_OS2_HEADER pNEHeader;
    PBYTE             pSize;
    DWORD             ModuleType;

    if (!SdbpGetModuleType(&ModuleType, pImageData)) {
        return FALSE;
    }

    if (ModuleType != MT_W16_MODULE) {
        return FALSE;
    }

    pDosHeader = (PIMAGE_DOS_HEADER)pImageData->pBase;
    pNEHeader  = (PIMAGE_OS2_HEADER)((PBYTE)pImageData->pBase + pDosHeader->e_lfanew);

    //
    // Now we know that pNEHeader is valid, just have to make sure that
    // the next offset is valid as well, make a check against file size.
    //
    if (pImageData->ViewSize < pDosHeader->e_lfanew + sizeof(*pNEHeader)) {
        return FALSE;
    }

    if (pImageData->ViewSize < pNEHeader->ne_restab + sizeof(*pSize)) {
        return FALSE;
    }

    pSize = (PBYTE)((PBYTE)pImageData->pBase + pDosHeader->e_lfanew + pNEHeader->ne_restab);

    if (*pSize == 0) {
        return FALSE;
    }

    //
    // Now check for the string size.
    //
    if (pImageData->ViewSize <
        pDosHeader->e_lfanew + pNEHeader->ne_restab + sizeof(*pSize) + *pSize) {
        
        return FALSE;
    }

    RtlCopyMemory(szBuffer, pSize + 1, *pSize);
    szBuffer[*pSize] = '\0';

    return TRUE;
}

#endif // KERNEL_MODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\dllmain.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        dllmain.c

    Abstract:

        BUGBUG: This module implements ...

    Author:

        clupu     created     sometime in 2000

    Revision History:

--*/

#include "sdbp.h"

BOOL APIENTRY
DllMain(
    HANDLE hModule, 
    DWORD  ul_reason, 
    LPVOID lpReserved
    )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\hash.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        hash.c

    Abstract:

        BUGBUG: comment.

    Author:

        vadimb     created     sometime in 2000

    Revision History:
--*/

#include "sdbp.h"

#define DEFAULT_STR_HASH_SIZE 8147

#if defined(KERNEL_MODE) && defined(ALLOC_DATA_PRAGMA)
#pragma  data_seg()
#endif // KERNEL_MODE && ALLOC_DATA_PRAGMA


//
// Table used to calculate CRC32. This is used to generate
// the hash index for strings.
//

static DWORD rgdwCrc[] =
{
  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL,
  0x076dc419L, 0x706af48fL, 0xe963a535L, 0x9e6495a3L,
  0x0edb8832L, 0x79dcb8a4L, 0xe0d5e91eL, 0x97d2d988L,
  0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L, 0x90bf1d91L,

  0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L,
  0x136c9856L, 0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL,
  0x14015c4fL, 0x63066cd9L, 0xfa0f3d63L, 0x8d080df5L,

  0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L, 0xa2677172L,
  0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L,
  0x32d86ce3L, 0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L,

  0x26d930acL, 0x51de003aL, 0xc8d75180L, 0xbfd06116L,
  0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L, 0xb8bda50fL,
  0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL,

  0x76dc4190L, 0x01db7106L, 0x98d220bcL, 0xefd5102aL,
  0x71b18589L, 0x06b6b51fL, 0x9fbfe4a5L, 0xe8b8d433L,
  0x7807c9a2L, 0x0f00f934L, 0x9609a88eL, 0xe10e9818L,
  0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,

  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL,
  0x6c0695edL, 0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L,
  0x65b0d9c6L, 0x12b7e950L, 0x8bbeb8eaL, 0xfcb9887cL,
  0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L, 0xfbd44c65L,

  0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL,
  0x4369e96aL, 0x346ed9fcL, 0xad678846L, 0xda60b8d0L,
  0x44042d73L, 0x33031de5L, 0xaa0a4c5fL, 0xdd0d7cc9L,

  0x5005713cL, 0x270241aaL, 0xbe0b1010L, 0xc90c2086L,
  0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L,
  0x59b33d17L, 0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL,

  0xedb88320L, 0x9abfb3b6L, 0x03b6e20cL, 0x74b1d29aL,
  0xead54739L, 0x9dd277afL, 0x04db2615L, 0x73dc1683L,
  0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L,

  0xf00f9344L, 0x8708a3d2L, 0x1e01f268L, 0x6906c2feL,
  0xf762575dL, 0x806567cbL, 0x196c3671L, 0x6e6b06e7L,
  0xfed41b76L, 0x89d32be0L, 0x10da7a5aL, 0x67dd4accL,
  0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,

  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L,
  0xd1bb67f1L, 0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL,
  0xd80d2bdaL, 0xaf0a1b4cL, 0x36034af6L, 0x41047a60L,
  0xdf60efc3L, 0xa867df55L, 0x316e8eefL, 0x4669be79L,

  0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL,
  0xc5ba3bbeL, 0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L,
  0xc2d7ffa7L, 0xb5d0cf31L, 0x2cd99e8bL, 0x5bdeae1dL,

  0x9b64c2b0L, 0xec63f226L, 0x756aa39cL, 0x026d930aL,
  0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L,
  0x92d28e9bL, 0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L,

  0x86d3d2d4L, 0xf1d4e242L, 0x68ddb3f8L, 0x1fda836eL,
  0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L, 0x18b74777L,
  0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L,

  0xa00ae278L, 0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L,
  0xa7672661L, 0xd06016f7L, 0x4969474dL, 0x3e6e77dbL,
  0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L, 0x37d83bf0L,
  0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,

  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L,
  0xbad03605L, 0xcdd70693L, 0x54de5729L, 0x23d967bfL,
  0xb3667a2eL, 0xc4614ab8L, 0x5d681b02L, 0x2a6f2b94L,
  0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL, 0x2d02ef8dL

};

#if defined(KERNEL_MODE) && defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, HashCreate)
#pragma alloc_text(PAGE, HashFree)
#pragma alloc_text(PAGE, HashStringRef)
#pragma alloc_text(PAGE, HashString)
#pragma alloc_text(PAGE, HashFindString)
#pragma alloc_text(PAGE, HashFindStringByRef)
#pragma alloc_text(PAGE, HashAddString)
#pragma alloc_text(PAGE, HashAddStringByRef)
#endif // KERNEL_MODE && ALLOC_PRAGMA


PVOID
HashCreate(
    void
    )
/*++
    Return: The hash.

    Desc:   Creates and initializes the hash.
--*/
{
    PSTRHASH pHash;

    pHash = (PSTRHASH)SdbAlloc(sizeof(STRHASH));

    if (pHash == NULL) {
        DBGPRINT((sdlError,
                  "HashCreate",
                  "Failed to allocate %d bytes.\n",
                  sizeof(STRHASH)));
        return NULL;
    }

    pHash->dwHashSize = DEFAULT_STR_HASH_SIZE;

    pHash->pTable = (PSTRHASHELEMENT*)SdbAlloc(sizeof(PSTRHASHELEMENT) * DEFAULT_STR_HASH_SIZE);

    if (pHash->pTable == NULL) {
        DBGPRINT((sdlError,
                  "HashCreate",
                  "Failed to allocate %d bytes for the table.\n",
                  sizeof(PSTRHASHELEMENT) * DEFAULT_STR_HASH_SIZE));
        
        SdbFree(pHash);
        return NULL;
    }
    
    return pHash;
}

void
HashFree(
    IN  PVOID pStringHash       // the hash to be freed.
    )
/*++
    Return: void

    Desc:   BUGBUG: comments ?
--*/
{
    PSTRHASHELEMENT phe, pheNext;
    PSTRHASH        pHash = (PSTRHASH)pStringHash;
    int             i;

    if (pHash == NULL) {
        DBGPRINT((sdlError, "HashFree", "Invalid argument.\n"));
        return;
    }

    if (pHash->pTable != NULL) {

        for (i = 0; i < (int)pHash->dwHashSize; i++) {

            for (phe = pHash->pTable[i]; phe != NULL; ) {
                pheNext = phe->pNext;
                SdbFree(phe);
                phe = pheNext;
            }
        }

        SdbFree(pHash->pTable);
    }

    SdbFree(pHash);
}


DWORD
HashStringRef(
    IN  PSTRHASH  pHash,        // pointer to the string hash structure.
    IN  STRINGREF srString      // string-reference (a dword) that is used to
                                // identify the string in an sdb file.
    )
/*++
    Return: Hash index for the string

    Desc:   BUGBUG: comments ?
--*/
{
    //
    // really simple for now
    //

    return (srString % pHash->dwHashSize);
}


DWORD
HashString(
    IN  PSTRHASH pHash,         // pointer to the string hash structure.
    IN  LPCTSTR  szString       // the string to be hashed
    )
/*++
    Return: The string reference in the hash.

    Desc:   BUGBUG: comments ?
--*/
{
    DWORD dwHash = 0;

    while (*szString) {
        dwHash += (dwHash << 5) + dwHash + *szString++;
    }
    
    dwHash %= pHash->dwHashSize;

    return dwHash;
}

STRINGREF
HashFindString(
    IN  PSTRHASH pHash,         // pointer to the string hash structure.
    IN  LPCTSTR  szString       // string to search for.
    )
/*++
    Return: The string ref if the string is found in the hash, 0 otherwise.

    Desc:   Searches for the specified string in the hash table.
--*/
{
    DWORD           dwHash;
    PSTRHASHELEMENT phe;
    int             iCmp;
    STRINGREF       srReturn = STRINGREF_NULL;

    dwHash = HashString(pHash, szString);

    phe = pHash->pTable[dwHash];

    for (; phe != NULL; phe = phe->pNext) {

        iCmp = _tcsicmp(szString, phe->szStr);

        //
        // The list of items related to the entry dwHash in the table
        // is sorted in ascending order by the "add" routine
        // therefore we compare until we find an item that is greater or equal
        // to the search string.
        //

        if (iCmp <= 0) {
            //
            // Found or failure, stop the search.
            //
            srReturn = (iCmp == 0 ? phe->srStr : STRINGREF_NULL);
            break;
        }
    }

    return srReturn;
}

LPTSTR
HashFindStringByRef(
    IN  PSTRHASH  pHash,        // pointer to the string hash structure.
    IN  STRINGREF srString      // stringref of the string to search for.
    )
/*++
    Return: The pointer to the found string or NULL.

    Desc:   Searches for the specified string in the hash table.
--*/
{
    DWORD           dwHash;
    PSTRHASHELEMENT phe;
    LPTSTR          pStr = NULL;

    dwHash = HashStringRef(pHash, srString);

    phe = pHash->pTable[dwHash];

    for (; phe != NULL; phe = phe->pNext) {
        if (phe->srStr >= srString) {
            pStr = ((phe->srStr == srString) ? phe->szStr : NULL);
            break;
        }
    }

    return pStr;
}


BOOL
HashAddString(
    IN  PSTRHASH  pHash,        // pointer to the string hash structure.
    IN  LPCTSTR   szString,     // the string to be added
    IN  STRINGREF srString      // the string ref for the string to be added
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   BUGBUG: comments ?
--*/
{
    DWORD           dwHash;
    PSTRHASHELEMENT phe;
    PSTRHASHELEMENT pheLast;
    PSTRHASHELEMENT pheNew;
    DWORD           dwStrSize;
    BOOL            bSuccess = FALSE;

    dwHash = HashString(pHash, szString);

    phe = pHash->pTable[dwHash];

    dwStrSize = (_tcslen(szString) + 1) * sizeof(TCHAR);

    //
    // Now check where to insert the string.
    //
    for (pheLast = NULL;
         phe != NULL && _tcsicmp(szString, phe->szStr) > 0;
         pheLast = phe, phe = phe->pNext) {
        ;
    }

    //
    // Insert it.
    //
    pheNew = (PSTRHASHELEMENT)SdbAlloc(sizeof(STRHASHELEMENT) + dwStrSize);

    if (pheNew == NULL) {
        DBGPRINT((sdlError,
                  "HashAddString",
                  "Failed to allocate %d bytes.\n",
                  sizeof(STRHASHELEMENT) + dwStrSize));
        return FALSE;
    }

    pheNew->szStr = (LPTSTR)(pheNew + 1);
    pheNew->srStr = srString;

    RtlMoveMemory(pheNew->szStr, szString, dwStrSize);

    pheNew->pNext = phe;

    if (pheLast == NULL) {
        pHash->pTable[dwHash] = pheNew;
    } else {
        pheLast->pNext = pheNew;
    }

    return TRUE;
}

LPTSTR
HashAddStringByRef(
    IN  PSTRHASH  pHash,
    IN  LPCTSTR   szString,
    IN  STRINGREF srString
    )
/*++
    Return: The pointer to the string added in the hash table.

    Desc:   BUGBUG: comments ?
--*/
{
    DWORD           dwHash;
    PSTRHASHELEMENT phe;
    PSTRHASHELEMENT pheLast;
    PSTRHASHELEMENT pheNew;
    DWORD           dwStrSize;
    LPTSTR          lpszCachedString = NULL;

    dwHash = HashStringRef(pHash, srString);

    phe = pHash->pTable[dwHash];

    dwStrSize = (_tcslen(szString) + 1) * sizeof(TCHAR);

    //
    // Check where to insert the string.
    //
    for (pheLast = NULL;
         phe != NULL && srString > phe->srStr;
         pheLast = phe, phe = phe->pNext);

    //
    // Insert it.
    //
    pheNew = (PSTRHASHELEMENT)SdbAlloc(sizeof(STRHASHELEMENT) + dwStrSize);

    if (pheNew == NULL) {
        DBGPRINT((sdlError,
                  "HashAddStringByRef",
                  "Failed to allocate %d bytes.\n",
                  sizeof(STRHASHELEMENT) + dwStrSize));

        return NULL;
    }

    pheNew->szStr = (LPTSTR)(pheNew + 1);
    pheNew->srStr = srString;

    RtlMoveMemory(pheNew->szStr, szString, dwStrSize);

    pheNew->pNext = phe;

    if (pheLast == NULL) {
        pHash->pTable[dwHash] = pheNew;
    } else {
        pheLast->pNext = pheNew;
    }

    lpszCachedString = pheNew->szStr;

    return lpszCachedString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\grabmiapi.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        grabmiapi.c

    Abstract:

        Code for generating matching information for files in a given
        directory and its subdirectories.

    Author:

        jdoherty     created     sometime in 2000

    Revision History:

        several people contributed (vadimb, clupu, ...)

--*/

#include "sdbp.h"
#include <time.h>
#include <shlwapi.h>

#define MAX_MISC_FILES_PER_LEVEL    10
#define MAX_LEVELS_OF_DIRECTORIES   3

static UCHAR UNICODE_MARKER[2] = { 0xFF, 0xFE }; // will hold special characters to specify
                                                 // a UNICODE File


TCHAR* g_szFilterDesc[] = {
    TEXT("GRABMI_FILTER_NORMAL"),
    TEXT("GRABMI_FILTER_PRIVACY"),
    TEXT("GRABMI_FILTER_DRIVERS"),
    TEXT("GRABMI_FILTER_VERBOSE"),
    TEXT("GRABMI_FILTER_SYSTEM"),
    TEXT("GRABMI_FILTER_THISFILEONLY"),
};

TCHAR* g_szGrabmiFilterNormal[] = {
    TEXT(".exe"),
    TEXT(".icd"),
    TEXT("._mp"),
    TEXT(".msi"),
    TEXT(".dll")
};

TCHAR* g_szGrabmiFilterSystem[] = {
    TEXT("ntdll.dll"),
    TEXT("user32.dll"),
    TEXT("kernel32.dll"),
    TEXT("gdi32.dll"),
    TEXT("wininet.dll"),
    TEXT("winsock.dll"),
    TEXT("advapi32.dll"),
    TEXT("shell32.dll"),
    TEXT("ole32.dll"),
    TEXT("advapi32.dll"),
    TEXT("oleaut32.dll"),
    TEXT("repcrt32.dll"),
};

typedef struct tagRECINFO {

    LPVOID                 lpvCallbackParameter;
    PFNGMIProgressCallback pfnCallback;

    ULONG                  MaxFiles; // limit the number of files
    ULONG                  FileCount; // count the files
    BOOL                   bNewStorageFile;

} RECINFO, *PRECINFO;

#define GRABMI_FLAGS_MASK 0xFFFF0000

GMI_RESULT
SdbpGrabMatchingInfoDir(
    HANDLE        hStorageFile,     // handle to a file we are writing
    PRECINFO      pinfo,            // pointer to extra info
    DWORD         dwFilterAndFlags, // specifies the types of files to be added for matching
    LPCTSTR       lpszRoot,         // root directory for our search (pointer to the buffer)
    LPTSTR        lpszOriginalExe,  // never null -- pointer to the relative portion,
    LPTSTR        lpszRelative,     // never null -- pointer to the relative portion,
    int           nLevel            // current directory level for matching information
    )
/*++

 Function Name:
    SdbpGrabMatchingInfoDir

 Function Description:

    This function traverses a directory and its subdirectories gathering matching
    information and writes it to the specified file.

 Return Value:

    BOOL:  TRUE if Successful

 History:

    04/26/2001   jdoherty        Created

    SdbpGrabMatchingInfoDir pointer definition:
    c:\foo\bar\soap\relativepath\
    ^- lpszRoot     ^- lpszRelative

--*/
{
    HANDLE          hSearch = INVALID_HANDLE_VALUE;  // handle for FindFileFirst and FindFileNext
    WIN32_FIND_DATA FindFileData;               // structure containing file information
    LPTSTR          lpchFilePart;               // points to a file part in szSearchPath
    LPTSTR          pchExt;                     // extension of current file
    LPTSTR          lpReplaceChar;              // pointer to character to be replaced

    BOOL            bMiscFile;
    INT             nch, nchBuffer, i;
    INT             nLen;
    INT             cbFileCounter = 0;          // running count of misc files added to matching.
    int             cbMultiByte = 0;            // The amount of MultiByte chars converting.
    int             cchWideChar = 0;            // The amount of WideChars converted.
    DWORD           dwBufferSize = 4096;        // initialize me with the alloc size for lpData
    LPTSTR          lpData = NULL;              // INITIALIZE ME WITH MALLOC!!!
    LPTSTR          lpBuffer = NULL;            // points within lpData
    LPWSTR          lpUnicodeBuffer = NULL;     // INITIALIZE ME WITH MALLOC!!!
    BOOL            bThisFileOnlyDone = FALSE;
    DWORD           dwFilter      = (dwFilterAndFlags & ~GRABMI_FLAGS_MASK);
    DWORD           dwFilterFlags = (dwFilterAndFlags & GRABMI_FLAGS_MASK);
    PATTRINFO       pAttrInfo;                  // attribute information structure
    DWORD           dwBytesWritten = 0;
    DWORD           dwAttributes;
    DWORD           dwAttrCount;
    GMI_RESULT      Result = GMI_FAILED;        // these two variables control return Result
                                                // is set as a return from callback or nested call
    //
    // Only want to grab information for the file(s) specified which
    // should reside in the root directory specified.
    //
    if (nLevel != 0 &&
        (dwFilter == GRABMI_FILTER_THISFILEONLY  ||
         dwFilter == GRABMI_FILTER_SYSTEM)) {
        goto eh;
    }

    lpData = (LPTSTR)SdbAlloc(dwBufferSize * sizeof(TCHAR));

    if (lpData == NULL) {
        DBGPRINT((sdlError,
                  "SdbpGrabMatchingInfoDir",
                  "Unable to allocate %d bytes.\n",
                  dwBufferSize * sizeof(TCHAR)));
        goto eh;
    }

#ifdef WIN32A_MODE
    lpUnicodeBuffer = (LPWSTR)SdbAlloc(dwBufferSize * sizeof(WCHAR));

    if (lpUnicodeBuffer == NULL) {
        DBGPRINT((sdlError,
                  "SdbpGrabMatchingInfoDir",
                  "Unable to allocate %d bytes.\n",
                  dwBufferSize * sizeof(WCHAR)));
        goto eh;
    }
#endif // WIN32A_MODE

    lpchFilePart = lpszRelative + _tcslen(lpszRelative);

    assert(lpchFilePart == lpszRoot || *(lpchFilePart-1) == TEXT('\\'));

    if (dwFilter == GRABMI_FILTER_THISFILEONLY) {
        _tcscpy(lpchFilePart, lpszOriginalExe);
    } else {
        _tcscpy(lpchFilePart, TEXT("*"));
    }

    //
    // Pass one. Grab all the file matching info we can.
    //
    hSearch = FindFirstFile(lpszRoot, &FindFileData);

    if (hSearch == INVALID_HANDLE_VALUE) {
        DBGPRINT((sdlError,
                  "SdbpGrabMatchingInfoDir",
                  "FindFirstFile Failed on [%s].\n",
                  lpszRoot));
        goto eh;
    }

    //
    // Comment in hStorage file where the root of the matching information is
    //
    if (nLevel == 0 && pinfo->bNewStorageFile) {
        *lpchFilePart = TEXT('\0');
        nch = _sntprintf(lpData,
                         dwBufferSize,
                         TEXT("<?xml version=\"1.0\" encoding=\"UTF-16\"?>\r\n<DATABASE>\r\n"));
        if (nch < 0) {
            //
            // lpData is too small to store information
            //
            DBGPRINT((sdlError, "SdbpGrabMatchingInforDir", "lpData is too small\n"));
            goto eh;
        }

#ifndef WIN32A_MODE
        lpUnicodeBuffer = lpData;
#else
        cchWideChar = MultiByteToWideChar(CP_ACP,
                                          0,
                                          lpData,
                                          -1,
                                          lpUnicodeBuffer,
                                          dwBufferSize);

        if (cchWideChar == 0) {
            DBGPRINT((sdlError,
                      "SdbpGrabMatchingInforDir",
                      "lpUnicodeBuffer is too small for conversion\n"));

            goto eh;
        }

#endif

        WriteFile(hStorageFile, UNICODE_MARKER, 2, &dwBytesWritten, NULL);

        WriteFile(hStorageFile,
                  lpUnicodeBuffer,
                  wcslen(lpUnicodeBuffer) * sizeof(WCHAR),
                  &dwBytesWritten,
                  NULL);
    }

    if (nLevel == 0) {
        if (dwFilter == GRABMI_FILTER_SYSTEM) {
            _tcscpy (lpszOriginalExe, TEXT("SYSTEM INFO"));
        }

        nch = _sntprintf(lpData, dwBufferSize, TEXT("<EXE NAME=\""));

        if (nch < 0) {
            DBGPRINT((sdlError, "SdbpGrabMatchingInforDir", "lpData is to small\n"));
            goto eh;
        }

        if (!SdbpSanitizeXML(lpData + nch, dwBufferSize - nch, lpszOriginalExe)) {
            goto eh;
        }

        // if we are here, we need to attach a few more things
        nLen = _tcslen(lpData);
        nch = _sntprintf(lpData + nLen, dwBufferSize - nLen, TEXT("\" FILTER=\"%s\">\r\n"),
                         g_szFilterDesc[dwFilter]);
        if (nch < 0) {
            goto eh;
        }
        nch += nLen;

#ifndef WIN32A_MODE
        lpUnicodeBuffer = lpData;
#else
        cchWideChar = MultiByteToWideChar(CP_ACP,
                                          0,
                                          lpData,
                                          -1,
                                          lpUnicodeBuffer,
                                          dwBufferSize);
        if (cchWideChar == 0) {
            DBGPRINT((sdlError,
                      "SdbpGrabMatchingInforDir",
                      "lpUnicodeBuffer is too small for conversion\n"));

            goto eh;
        }

#endif // WIN32A_MODE

        WriteFile(hStorageFile,
                  lpUnicodeBuffer,
                  wcslen(lpUnicodeBuffer) * sizeof(WCHAR),
                  &dwBytesWritten,
                  NULL);
    }

    switch (dwFilter) {

    case GRABMI_FILTER_PRIVACY:
    case GRABMI_FILTER_THISFILEONLY:
    case GRABMI_FILTER_SYSTEM:
        cbFileCounter = MAX_MISC_FILES_PER_LEVEL;
        break;
    }

    do {
        //
        // Check for directories including . and ..
        //
        if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            continue;
        }

        //
        // Make a relative path with our buffer
        //
        _tcscpy(lpchFilePart, FindFileData.cFileName);

        //
        // lpszRelative points to the relative path
        // lpszRoot points to the full path
        bMiscFile = FALSE;

        //
        // Check to see if there is version information for the specified file and whether
        // it is a .exe, .icd, ._MP, .msi, or .dll.  If so print the information to the file.
        // Otherwise, add the information if cbFileCounter is less than MAX_MISC_FILES_PER_LEVEL.
        //
        pchExt = PathFindExtension(lpszRoot);

        switch (dwFilter) {

        case GRABMI_FILTER_NORMAL:
        case GRABMI_FILTER_PRIVACY:
            for (i = 0; i < ARRAYSIZE(g_szGrabmiFilterNormal); i++) {
                if (_tcsicmp(pchExt, g_szGrabmiFilterNormal[i]) == 0) {
                    break;
                }
            }
            bMiscFile = (i >= ARRAYSIZE(g_szGrabmiFilterNormal));
            break;

        case GRABMI_FILTER_SYSTEM:
            for (i = 0; i < ARRAYSIZE(g_szGrabmiFilterSystem); i++) {
                if (_tcsicmp(FindFileData.cFileName, g_szGrabmiFilterSystem[i]) == 0) {
                    break;
                }
            }
            bMiscFile = (i >= ARRAYSIZE(g_szGrabmiFilterSystem));
            break;

        case GRABMI_FILTER_THISFILEONLY:
            bMiscFile = _tcsicmp(FindFileData.cFileName, lpszOriginalExe);
            break;

        case GRABMI_FILTER_DRIVERS:
            bMiscFile = _tcsicmp(pchExt, TEXT(".sys"));
            break;

        default:
            break;
        }

        if (bMiscFile) {
            if (cbFileCounter < MAX_MISC_FILES_PER_LEVEL) {
                ++cbFileCounter;
            } else {
                continue;
            }
        }

        //
        // List relative data here
        //
        lpBuffer = lpData;

        if (dwFilter == GRABMI_FILTER_DRIVERS) {
            nch = _sntprintf(lpBuffer, dwBufferSize, TEXT("    <SYS NAME=\""));
        } else {
            nch = _sntprintf(lpBuffer, dwBufferSize, TEXT("    <MATCHING_FILE NAME=\""));
        }

        if (nch < 0) {
            goto eh;
        }

        if (!SdbpSanitizeXML(lpBuffer + nch, dwBufferSize - nch, lpszRelative)) {
            goto eh;
        }

        nLen = _tcslen(lpBuffer);
        nch = _sntprintf(lpBuffer + nLen, dwBufferSize - nLen, TEXT("\" "));

        if (nch < 0) {
            goto eh;
        }

        //
        // Now we add the length -- and we're ready
        //
        nch      += nLen;

        lpBuffer += nch;
        nchBuffer = nch;    // amount of characters in lpBuffer already

        //
        // Call the attribute manager to get all the attributes for this file.
        //
        pAttrInfo = NULL;

        if (SdbGetFileAttributes(lpszRoot, &pAttrInfo, &dwAttrCount)) {

            //
            // Loop through all the attributes and add the ones that are available.
            //
            TCHAR lpszAttr[MAX_PATH*2];

            for (i = 0; (DWORD)i < dwAttrCount; ++i) {

                if (SdbFormatAttribute(&pAttrInfo[i], lpBuffer, dwBufferSize - nchBuffer)) {
                    //
                    // lpBuffer has XML for this attribute
                    //

                    // insert space
                    nch = _tcslen(lpBuffer) + 1; // for space

                    if (dwFilter == GRABMI_FILTER_DRIVERS) {
                        switch (pAttrInfo[i].tAttrID) {

                        case TAG_BIN_PRODUCT_VERSION:
                        case TAG_UPTO_BIN_PRODUCT_VERSION:
                        case TAG_LINK_DATE:
                        case TAG_UPTO_LINK_DATE:
                            break;

                        default:
                            continue;
                        }
                    }

                    if (nchBuffer + nch >= (int)dwBufferSize) {
                        //
                        // lpBuffer is not large enough to hold the information
                        //
                        DBGPRINT((sdlError,
                                  "SdbGetMatchingInfoDir",
                                  "lpBuffer is too small to handle attributes for %s.\n",
                                  lpszRelative));
                    }

                    _tcscat(lpBuffer, TEXT(" "));

                    lpBuffer  += nch;

                    nchBuffer += nch;
                }
            }
        }

        nch = _sntprintf(lpBuffer, dwBufferSize, TEXT("/>\r\n"));

        if (nch < 0) {
            //
            // Buffer is too small.
            //
            DBGPRINT((sdlError,
                      "SdbGrabMatchingInfoDir",
                      "lpBuffer is too small to handle attributes for %s.\n",
                      lpszRelative));
            continue;
        }
        //
        // Check to see if using unicode or not.  If not, convert
        // to unicode.
        //
#ifndef WIN32A_MODE
        lpUnicodeBuffer = lpData;
#else
        cchWideChar = MultiByteToWideChar(CP_ACP,
                                          0,
                                          lpData,
                                          -1,
                                          lpUnicodeBuffer,
                                          dwBufferSize);
        if (cchWideChar == 0) {
            //
            // buffer is not large enough for conversion
            //
            DBGPRINT((sdlError,
                      "SdbpGrabMatchingInforDir",
                      "lpUnicodeBuffer is not large enough for conversion\n"));

            goto eh;
        }

#endif // WIN32A_MODE

        if (pinfo->pfnCallback) {
            if (!pinfo->pfnCallback(pinfo->lpvCallbackParameter,
                                    lpszRoot,           // give straight name
                                    lpszRelative,       // relative name
                                    pAttrInfo,          // pointer to the attributes
                                    lpUnicodeBuffer)) { // xml output
                Result = GMI_CANCELLED;
            }
        }

        WriteFile(hStorageFile,
                  lpUnicodeBuffer,
                  wcslen(lpUnicodeBuffer) * sizeof(WCHAR),
                  &dwBytesWritten,
                  NULL);

        if (pAttrInfo) {
            SdbFreeFileAttributes(pAttrInfo);
            pAttrInfo = NULL; // make sure we do not free it twice
        }

        //
        // Check to see whether we have reached the file limit
        //
        if (pinfo->MaxFiles && ++pinfo->FileCount >= pinfo->MaxFiles && Result != GMI_CANCELLED) {
            Result = GMI_SUCCESS; // limit reached, grabmi cancelled
            nLevel = MAX_LEVELS_OF_DIRECTORIES; // this is so that we bail out
            break;
        }

    } while (FindNextFile(hSearch, &FindFileData) && (Result != GMI_CANCELLED));

    FindClose(hSearch);
    hSearch = INVALID_HANDLE_VALUE;

    if (Result == GMI_CANCELLED) {
        goto CloseTags;
    }

    if (dwFilter != GRABMI_FILTER_SYSTEM && dwFilter != GRABMI_FILTER_THISFILEONLY) {
        if (nLevel >= MAX_LEVELS_OF_DIRECTORIES || (dwFilterFlags & GRABMI_FILTER_NORECURSE)) {
            Result = GMI_SUCCESS; // not a failure, just a limiting case
            goto eh; // done
        }

        //
        // Replace the filename in szSearchFile with "*" -- hack!
        //
        _tcscpy(lpchFilePart, TEXT("*"));

        hSearch = FindFirstFile(lpszRoot, &FindFileData);

        if (INVALID_HANDLE_VALUE == hSearch) {
            //
            // lpszRoot does not contain any matching files
            //
            DBGPRINT((sdlError,
                      "SdbGrabMatchingInfoDir",
                      "%s contains no matching files!\n",
                      lpszRoot));
            goto eh;
        }

        //
        // Now go through the subdirectories and grab that information.
        //
        do {
            if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                continue;
            }

            if ((_tcscmp(FindFileData.cFileName, TEXT(".")) == 0) ||
                (_tcscmp( FindFileData.cFileName, TEXT("..")) == 0)) {
                continue;
            }

            //
            // Form relative path here by copying lpszRelative and appending cFileName and '\\'
            //
            _tcscpy(lpchFilePart, FindFileData.cFileName);
            _tcscat(lpchFilePart, TEXT("\\"));

            //
            // Recusive call. Check return result for having been cancelled !!!
            //
            Result = SdbpGrabMatchingInfoDir(hStorageFile,
                                             pinfo,
                                             dwFilterAndFlags,
                                             lpszRoot,
                                             NULL,
                                             lpszRelative,
                                             nLevel + 1);

            if (Result == GMI_CANCELLED) {
                //
                // We are cancelled. Write out a valid database code to close
                // this if we have the option set.
                //

                break;
            }

        } while (FindNextFile(hSearch, &FindFileData));

    }

CloseTags:
    //
    // This is where we close the tags if instructed to do so
    //
    if (nLevel == 0) {
        wcscpy (lpUnicodeBuffer, L"</EXE>\r\n");

        if (!(dwFilterFlags & GRABMI_FILTER_NOCLOSE)) {
            wcscat(lpUnicodeBuffer, L"</DATABASE>\r\n");
        }

        WriteFile(hStorageFile,
                  lpUnicodeBuffer,
                  wcslen(lpUnicodeBuffer) * sizeof(WCHAR),
                  &dwBytesWritten,
                  NULL);
    }

    //
    // Check how we got here -- was it via the cancel route ?
    //
    if (Result == GMI_CANCELLED) {
        goto eh;
    }

    //
    // Information gathered successfully.
    //
    Result = GMI_SUCCESS;

eh:

    if (INVALID_HANDLE_VALUE != hSearch) {
        FindClose(hSearch);
    }
    if (lpData != NULL) {
        SdbFree(lpData);
    }

#ifdef WIN32A_MODE
    if (lpUnicodeBuffer != NULL) {
        SdbFree(lpUnicodeBuffer);
    }
#endif // WIN32A_MODE

    return Result;
}


BOOL
SDBAPI
SdbGrabMatchingInfo(
    LPCTSTR szMatchingPath,
    DWORD   dwFilter,
    LPCTSTR szFile
    )
{
    return SdbGrabMatchingInfoEx(szMatchingPath, dwFilter, szFile, NULL, NULL) == GMI_SUCCESS;
}


GMI_RESULT
SDBAPI
SdbGrabMatchingInfoEx(
    LPCTSTR szMatchingPath,     // path to begin gathering information
    DWORD   dwFilterAndFlags,             // specifies the types of files to be added to matching
    LPCTSTR szFile,             // full path to file where information will be stored
    PFNGMIProgressCallback pfnCallback,
    LPVOID                 lpvCallbackParameter
    )
{
    HANDLE      hStorageFile = INVALID_HANDLE_VALUE;
    LPTSTR      lpRootDirectory = NULL;
    LPTSTR      pchBackslash;
    LPTSTR      lpRelative;
    TCHAR       szOriginalExe[MAX_PATH] = {TEXT("Exe Not Specified")};
    int         nDirLen, nLevel = 0;
    DWORD       dwAttributes;
    GMI_RESULT  Result = GMI_FAILED;
    DWORD       dwFilter      = (dwFilterAndFlags & ~GRABMI_FLAGS_MASK);
    DWORD       dwFilterFlags = (dwFilterAndFlags & GRABMI_FLAGS_MASK);
    RECINFO     info;

    //
    // Check to see if dwFilter is a know value
    //
    if (dwFilter != GRABMI_FILTER_NORMAL &&
        dwFilter != GRABMI_FILTER_PRIVACY &&
        dwFilter != GRABMI_FILTER_DRIVERS &&
        dwFilter != GRABMI_FILTER_VERBOSE &&
        dwFilter != GRABMI_FILTER_SYSTEM &&
        dwFilter != GRABMI_FILTER_THISFILEONLY) {

        //
        // Unknown filter specified.
        //
        DBGPRINT((sdlError,
                  "SdbGrabMatchingInfo",
                  "dwFilter is not a recognized filter.\n"));
        goto eh;
    }

    RtlZeroMemory(&info, sizeof(info));

    info.pfnCallback          = pfnCallback;
    info.lpvCallbackParameter = lpvCallbackParameter;
    info.MaxFiles             = (dwFilterFlags & GRABMI_FILTER_LIMITFILES) ? GRABMI_IMPOSED_FILE_LIMIT : 0;
    info.FileCount            = 0;
    info.bNewStorageFile      = TRUE;

    lpRootDirectory = (LPTSTR)SdbAlloc(4096 * sizeof(TCHAR));

    if (lpRootDirectory == NULL) {
        DBGPRINT((sdlError,
                  "SdbGrabMatchingInfo",
                  "Unable to allocate memory for lpRootDirectory."));
        goto eh;
    }

    if (dwFilter == GRABMI_FILTER_SYSTEM) {
        GetSystemDirectory (lpRootDirectory, MAX_PATH);
        _tcscat (lpRootDirectory, TEXT("\\"));

    } else {
        dwAttributes = GetFileAttributes(szMatchingPath);

        if (dwAttributes == (DWORD)-1) {
            DBGPRINT((sdlError,
                      "SdbGrabMatchingInfo",
                      "GetFileAttributes failed or %s is not a valid path",
                      szMatchingPath));
            goto eh;
        }

        _tcscpy (lpRootDirectory, szMatchingPath);
        nDirLen = _tcslen(lpRootDirectory);

        //
        // See if location specified exists and if so determine
        // whether its a file or directory
        //
        if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            //
            // Is this a directory ?
            //
            if (nDirLen > 0 && lpRootDirectory[nDirLen-1] != TEXT('\\')) {
                _tcscat(lpRootDirectory, TEXT("\\"));
            }
        } else {
            //
            // A path containing a file name was passed as szMatchingPath.
            // Determine what the containing dir is.
            //
            pchBackslash = _tcsrchr(lpRootDirectory, TEXT('\\'));

            if (NULL == pchBackslash) {
                _tcscpy (szOriginalExe, lpRootDirectory);
                GetCurrentDirectory (MAX_PATH*16, lpRootDirectory);
                _tcscat (lpRootDirectory, TEXT("\\"));

            } else {
                pchBackslash = CharNext(pchBackslash);
                _tcscpy (szOriginalExe, pchBackslash);
                *pchBackslash = TEXT('\0');
            }
        }
    }

    lpRelative = lpRootDirectory + _tcslen(lpRootDirectory);

    //
    // Check to see if szOriginalExe is not NULL if
    // GRABMI_FILTER_THISFILEONLY was selected.
    //
    if (dwFilter == GRABMI_FILTER_THISFILEONLY && szOriginalExe == '\0' ) {
        DBGPRINT((sdlError,
                  "SdbGrabMatchingInfo",
                  "GRABMI_FILTER_THISFILEONLY specified but passed in a directory: %s.",
                  lpRootDirectory));
        goto eh;

    } else if (dwFilterFlags & GRABMI_FILTER_APPEND) {
        //
        // Open the file where the information will be stored.
        //
        hStorageFile = CreateFile(szFile,
                                  GENERIC_WRITE,
                                  0,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);

        if (ERROR_ALREADY_EXISTS == GetLastError()) {
            SetFilePointer (hStorageFile, 0, NULL, FILE_END);
            info.bNewStorageFile = FALSE;
        }
    } else {
        //
        // Open the file where the information will be stored.
        //
        hStorageFile = CreateFile(szFile,
                                  GENERIC_WRITE,
                                  0,
                                  NULL,
                                  CREATE_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);
    }

    if (hStorageFile == INVALID_HANDLE_VALUE) {
        DBGPRINT((sdlError, "SdbGrabMatchingInfo", "Unable to open the storage file."));
        goto eh;
    }

    //
    // Call the API which does the bulk of the work
    //
    Result = SdbpGrabMatchingInfoDir(hStorageFile,
                                     &info,
                                     dwFilterAndFlags,
                                     lpRootDirectory,
                                     szOriginalExe,
                                     lpRelative,
                                     nLevel);

eh:

    if (hStorageFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hStorageFile);
    }

    if (lpRootDirectory) {
        SdbFree(lpRootDirectory);
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\findtag.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        findtag.c

    Abstract:

        BUGBUG: This module implements ...

    Author:

        dmunsil     created     sometime in 1999

    Revision History:

        several people contributed (vadimb, clupu, ...)

--*/

#include "sdbp.h"

#if defined(KERNEL_MODE) && defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, SdbFindFirstTag)
#pragma alloc_text(PAGE, SdbFindNextTag)
#pragma alloc_text(PAGE, SdbFindFirstNamedTag)
#pragma alloc_text(PAGE, SdbpFindNextNamedTag)
#pragma alloc_text(PAGE, SdbpFindMatchingName)
#pragma alloc_text(PAGE, SdbpFindMatchingDWORD)
#pragma alloc_text(PAGE, SdbpFindMatchingGUID)
#pragma alloc_text(PAGE, SdbFindFirstTagRef)
#pragma alloc_text(PAGE, SdbFindNextTagRef)
#endif // KERNEL_MODE && ALLOC_PRAGMA


TAGID
SdbFindFirstTag(
    IN  PDB   pdb,              // pdb to use
    IN  TAGID tiParent,         // parent (must be LIST tag)
    IN  TAG   tTag              // tag to match
    )
/*++
    Return: The tag id found or TAGID_NULL on failure.

    Desc:   Finds the first child of tiParent that is a tag of type tTag.
--*/
{
    TAGID tiTemp;
    TAGID tiReturn = TAGID_NULL;

    assert(pdb);

    tiTemp = SdbGetFirstChild(pdb, tiParent);

    while (tiTemp != TAGID_NULL) {
        if (SdbGetTagFromTagID(pdb, tiTemp) == tTag) {
            tiReturn = tiTemp;
            break;
        }

        tiTemp = SdbGetNextChild(pdb, tiParent, tiTemp);
    }

    return tiReturn;
}

TAGID
SdbFindNextTag(
    IN  PDB   pdb,              // DB to use
    IN  TAGID tiParent,         // parent tag to search (must be LIST)
    IN  TAGID tiPrev            // previously found child of required type
    )
/*++
    Return: The next matching child of tiParent, or TAGID_NULL if no more.

    Desc:   Finds the next child of tiParent, starting with the one after tiPrev,
            that is a tag of the same type as tiPrev.
--*/
{
    TAGID tiTemp;
    TAGID tiReturn = TAGID_NULL;
    TAG   tTag;

    assert(pdb);

    tTag = SdbGetTagFromTagID(pdb, tiPrev);

    if (tTag == TAG_NULL) {
        DBGPRINT((sdlError, "SdbFindNextTag", "Invalid tagid 0x%lx\n", tiPrev));
        return TAGID_NULL;
    }

    tiTemp = SdbGetNextChild(pdb, tiParent, tiPrev);

    while (tiTemp != TAGID_NULL) {
        if (SdbGetTagFromTagID(pdb, tiTemp) == tTag) {
            tiReturn = tiTemp;
            break;
        }

        tiTemp = SdbGetNextChild(pdb, tiParent, tiTemp);
    }

    return tiReturn;
}

TAGID
SdbFindFirstNamedTag(
    IN  PDB     pdb,            // DB to use
    IN  TAGID   tiParent,       // parent to search in
    IN  TAG     tToFind,        // tag type to find
    IN  TAG     tName,          // child of found tag that will be some kind
                                //      of STRING or STRINGREF
    IN  LPCTSTR pszName         // string to search for
    )
/*++
    Return: The tag id found or TAGID_NULL if no tags match the criteria.

    Desc:   Scans sequentially through the children of tiParent, looking for
            tags of type tToFind. When it finds one, it looks for a child of
            that tag of type tName, and if found, compares that string to the
            passed-in string. If they match, it returns the TAGID of the tag
            of type tToFind.
--*/
{
    TAGID tiTemp;
    TAGID tiReturn = TAGID_NULL;

    assert(pdb);

    tiTemp = SdbGetFirstChild(pdb, tiParent);

    while (tiTemp != TAGID_NULL) {

        if (SdbGetTagFromTagID(pdb, tiTemp) == tToFind) {
            TAGID tiName;

            tiName = SdbFindFirstTag(pdb, tiTemp, tName);

            if (tiName != TAGID_NULL) {
                LPTSTR pszTemp;

                pszTemp = SdbGetStringTagPtr(pdb, tiName);
                if (pszTemp == NULL) {
                    DBGPRINT((sdlError,
                              "SdbFindFirstNamedTag",
                              "Can't get the name string.\n"));
                    break;
                }

                if (_tcsicmp(pszName, pszTemp) == 0) {
                    tiReturn = tiTemp;
                    break;
                }
            }
        }

        tiTemp = SdbGetNextChild(pdb, tiParent, tiTemp);
    }

    return tiReturn;
}

TAGID
SdbpFindNextNamedTag(
    IN  PDB          pdb,       // DB to use
    IN  TAGID        tiParent,  // parent to search in
    IN  TAGID        tiPrev,    // previously found record
    IN  TAG          tName,     // tag type that should be a STRING or STRINGREF
    IN  LPCTSTR      pszName    // string to search for
    )
/*++
    Return: The tag id found or TAGID_NULL if no tags match the criteria.

    Desc:   Scans sequentially through the children of tiParent, starting with tiPrev,
            looking for tags of the same type as tiPrev.
            When it finds one, it looks for a child of that tag of type tName,
            and if found, compares that string to the passed-in string. If they
            match, it returns the TAGID of the tag of the same type as tiPrev.
--*/
{
    TAGID tiTemp;
    TAGID tiReturn = TAGID_NULL;
    TAG   tToFind;

    assert(pdb);

    tToFind = SdbGetTagFromTagID(pdb, tiPrev);

    if (tToFind == TAG_NULL) {
        DBGPRINT((sdlError, "SdbpFindNextNamedTag", "Invalid tagid 0x%lx\n", tiPrev));
        return TAGID_NULL;
    }

    tiTemp = SdbGetNextChild(pdb, tiParent, tiPrev);

    while (tiTemp != TAGID_NULL) {

        if (SdbGetTagFromTagID(pdb, tiTemp) == tToFind) {
            TAGID tiName;

            tiName = SdbFindFirstTag(pdb, tiTemp, tName);
            if (tiName != TAGID_NULL) {
                LPTSTR pszTemp;

                pszTemp = SdbGetStringTagPtr(pdb, tiName);
                if (pszTemp == NULL) {
                    DBGPRINT((sdlError,
                              "SdbpFindNextNamedTag",
                              "Can't get the name string tagid 0x%lx\n",
                              tiName));
                    break;
                }
                if (_tcsicmp(pszName, pszTemp) == 0) {
                    tiReturn = tiTemp;
                    break;
                }
            }
        }

        tiTemp = SdbGetNextChild(pdb, tiParent, tiTemp);
    }

    return tiReturn;
}

TAGID
SdbpFindMatchingName(
    IN  PDB        pdb,         // DB to use
    IN  TAGID      tiStart,     // the tag where to start from
    IN  FIND_INFO* pFindInfo    // pointer to the search context structure
    )
/*++
    Return: The tag id found or TAGID_NULL if no tags match the criteria.

    Desc:   Given a database handle and a starting point in the database
            the function scans the database to find the name matching the one
            provided while calling one of the search functions.
--*/
{
    TAGID  tiName;
    LPTSTR pszTemp;
    TAGID  tiReturn = tiStart;

    while (tiReturn != TAGID_NULL) {

        tiName = SdbFindFirstTag(pdb, tiReturn, pFindInfo->tName);

        if (tiName == TAGID_NULL) {
            DBGPRINT((sdlError,
                      "SdbpFindMatchingName",
                      "The tag 0x%x was not found under tag 0x%x.\n",
                      tiReturn,
                      pFindInfo->tName));

            return TAGID_NULL;
        }

        //
        // Get the pointer to the string.
        //
        pszTemp = SdbGetStringTagPtr(pdb, tiName);

        if (pszTemp == NULL) {
            DBGPRINT((sdlError,
                      "SdbpFindMatchingName",
                      "Can't get the name string for tagid 0x%x.\n",
                      tiName));
            return TAGID_NULL; // corrupt database
        }

        //
        // We have two different index styles. One index is a "unique" kind
        // of index when each key in the index table occurs only once.
        // The second kind stores all the occurences of keys. We check for the
        // kind of index we're searching to determine what the proper
        // comparison routine should be. Unique-style index has all the
        // child items (having the same index value) sorted in ascending order
        // by shimdbc. As a result we take advantage of that while performing
        // matching on the name.
        //
        if (pFindInfo->dwFlags & SHIMDB_INDEX_UNIQUE_KEY) {
            int iCmp;

            iCmp = _tcsicmp(pFindInfo->szName, pszTemp);

            //
            // szName (string we search for) < szTemp (string from the db)
            // we have not found our target, since all the strings in the database
            // are sorted in ascending order
            //
            if (iCmp < 0) {
                //
                // No dpf here, what we were looking for was not found
                //

                return TAGID_NULL;
            }

            //
            // Break if there is a match.
            //
            if (iCmp == 0) {
                break;
            }

        } else {

            //
            // When using non-unique index the only kind of comparison
            // that needs to be done is a direct comparison for equality.
            //
            if (_tcsicmp(pszTemp, pFindInfo->szName) == 0) {
                //
                // It's a match, so return it.
                //
                break;
            }
        }

        tiReturn = SdbpGetNextIndexedRecord(pdb, pFindInfo->tiIndex, pFindInfo);
    }

    return tiReturn;
}


TAGID
SdbpFindMatchingDWORD(
    IN  PDB        pdb,         // DB to use
    IN  TAGID      tiStart,     // the tag where to start from
    IN  FIND_INFO* pFindInfo    // pointer to the search context structure
    )
/*++
    Return: The tag id found or TAGID_NULL if no tags match the criteria.

    Desc:   BUGBUG: comments ?
--*/
{
    TAGID tiName;
    TAGID tiReturn = tiStart;
    DWORD dwTemp;

    while (tiReturn != TAGID_NULL) {

        tiName = SdbFindFirstTag(pdb, tiReturn, pFindInfo->tName);

        if (tiName == TAGID_NULL) {
            DBGPRINT((sdlError,
                      "SdbpFindMatchingDWORD",
                      "The tag 0x%lx was not found under tag 0x%lx\n",
                      tiReturn,
                      pFindInfo->tName));

            return TAGID_NULL;
        }

        dwTemp = SdbReadDWORDTag(pdb, tiName, (DWORD)-1);

        if (dwTemp == (DWORD)-1) {
            //
            // This is not an error condition, merely an indication that the
            // dword we were looking for was not found in the database.
            //
            return TAGID_NULL;
        }

        if (dwTemp == pFindInfo->dwName) {
            break;
        }

        tiReturn = SdbpGetNextIndexedRecord(pdb, pFindInfo->tiIndex, pFindInfo);
    }

    return tiReturn;
}

TAGID
SdbpFindMatchingGUID(
    IN  PDB        pdb,         // DB to use
    IN  TAGID      tiStart,     // the tag where to start from
    IN  FIND_INFO* pFindInfo    // pointer to the search context structure
    )
/*++
    Return: The tag id found or TAGID_NULL if no tags match the criteria.

    Desc:   BUGBUG: comments ?
--*/
{
    GUID  guidID   = { 0 };
    TAGID tiReturn = tiStart;
    TAGID tiName;
    DWORD dwTemp;

    while (tiReturn != TAGID_NULL) {

        tiName = SdbFindFirstTag(pdb, tiReturn, pFindInfo->tName);

        if (tiName == TAGID_NULL) {
            DBGPRINT((sdlError,
                      "SdbpFindMatchingGUID",
                      "The tag 0x%lx was not found under tag 0x%lx\n",
                      tiReturn,
                      pFindInfo->tName));

            return TAGID_NULL;
        }

        if (!SdbReadBinaryTag(pdb, tiName, (PBYTE)&guidID, sizeof(guidID))) {
            DBGPRINT((sdlError, "SdbpFindMatchingGUID", 
                      "Cannot read binary tag 0x%lx\n", tiName));
            return TAGID_NULL;
        }

        //
        // verify whether the key for this entry is still the same as it is 
        // for original guid, if not -- that's it, guid key was not found
        // 
        if (IS_MEMORY_EQUAL(&guidID, pFindInfo->pguidName, sizeof(guidID))) {
            break;
        }

        tiReturn = SdbpGetNextIndexedRecord(pdb, pFindInfo->tiIndex, pFindInfo);
    }

    return tiReturn;
}


TAGREF
SdbFindFirstTagRef(
    IN  HSDB   hSDB,            // handle to the database channel
    IN  TAGREF trParent,        // parent to search
    IN  TAG    tTag             // tag we're looking for
    )
/*++
    Return: The tagref of the first child that matches tTag.

    Desc:   Scans sequentially through all children of trParent, looking
            for the first tag that matches tTag. Returns the first found,
            or TAGREF_NULL if there are no children with that type.

            trParent can be 0 (or TAGREF_ROOT) to look through the root tags,
            which at this point are only DATABASE and possibly STRINGTABLE.
--*/
{
    PDB    pdb;
    TAGID  tiParent;
    TAGID  tiReturn;
    TAGREF trReturn = TAGREF_NULL;

    if (!SdbTagRefToTagID(hSDB, trParent, &pdb, &tiParent)) {
        DBGPRINT((sdlError, "SdbFindFirstTagRef", "Can't convert tag ref.\n"));
        goto err1;
    }

    tiReturn = SdbFindFirstTag(pdb, tiParent, tTag);
    if (tiReturn == TAGID_NULL) {
        //
        // No error here. We just didn't find the tag.
        //
        goto err1;
    }

    if (!SdbTagIDToTagRef(hSDB, pdb, tiReturn, &trReturn)) {
        DBGPRINT((sdlError, "SdbFindFirstTagRef", "Can't convert TAGID.\n"));
        trReturn = TAGREF_NULL;
        goto err1;
    }

err1:
    return trReturn;
}

TAGREF
SdbFindNextTagRef(
    IN  HSDB   hSDB,            // handle to the database channel
    IN  TAGREF trParent,        // parent to search
    IN  TAGREF trPrev           // previous child found
    )
/*++
    Return: The tagref of the next child of parent that matches trPrev.

    Desc:   Scans sequentially through all children of trParent, starting with
            the first tag after trPrev, looking for the first tag that
            matches tTag. Returns the next found, or TAGREF_NULL if there are
            no more children with that type.

            trParent can be 0 (or TAGREF_ROOT) to look through the root tags,
            which at this point are only DATABASE and possibly STRINGTABLE.
--*/
{
    PDB    pdb;
    TAGID  tiParent;
    TAGID  tiPrev;
    TAGID  tiReturn;
    TAGREF trReturn;

    if (!SdbTagRefToTagID(hSDB, trParent, &pdb, &tiParent)) {
        DBGPRINT((sdlError, "SdbFindNextTagRef", "Can't convert tag ref trParent.\n"));
        return TAGREF_NULL;
    }

    if (!SdbTagRefToTagID(hSDB, trPrev, &pdb, &tiPrev)) {
        DBGPRINT((sdlError, "SdbFindNextTagRef", "Can't convert tag ref trPrev.\n"));
        return TAGREF_NULL;
    }

    tiReturn = SdbFindNextTag(pdb, tiParent, tiPrev);
    if (tiReturn == TAGID_NULL) {
        //
        // No error here.
        //
        return TAGREF_NULL;
    }

    if (!SdbTagIDToTagRef(hSDB, pdb, tiReturn, &trReturn)) {
        DBGPRINT((sdlError, "SdbFindNextTagRef", "Can't convert TAGID.\n"));
        return TAGREF_NULL;
    }

    return trReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\index.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        index.c

    Abstract:

        This module implements the APIs and internal functions used to access and build
        indexes in the database.

    Author:

        dmunsil     created     sometime in 1999

    Revision History:

        several people contributed (vadimb, clupu, ...)

--*/

#include "sdbp.h"

#if defined(KERNEL_MODE) && defined(ALLOC_DATA_PRAGMA)
#pragma  data_seg()
#endif // KERNEL_MODE && ALLOC_DATA_PRAGMA


#if defined(KERNEL_MODE) && defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, SdbFindFirstGUIDIndexedTag)
#pragma alloc_text(PAGE, SdbFindNextGUIDIndexedTag)
#pragma alloc_text(PAGE, SdbFindFirstDWORDIndexedTag)
#pragma alloc_text(PAGE, SdbFindNextDWORDIndexedTag)
#pragma alloc_text(PAGE, SdbFindFirstStringIndexedTag)
#pragma alloc_text(PAGE, SdbFindNextStringIndexedTag)
#pragma alloc_text(PAGE, SdbpBinarySearchUnique)
#pragma alloc_text(PAGE, SdbpBinarySearchFirst)
#pragma alloc_text(PAGE, SdbpGetFirstIndexedRecord)
#pragma alloc_text(PAGE, SdbpGetNextIndexedRecord)
#pragma alloc_text(PAGE, SdbpPatternMatch)
#pragma alloc_text(PAGE, SdbpPatternMatchAnsi)
#pragma alloc_text(PAGE, SdbpKeyToAnsiString)
#pragma alloc_text(PAGE, SdbpFindFirstIndexedWildCardTag)
#pragma alloc_text(PAGE, SdbpFindNextIndexedWildCardTag)
#pragma alloc_text(PAGE, SdbGetIndex)
#pragma alloc_text(PAGE, SdbpScanIndexes)
#pragma alloc_text(PAGE, SdbpGetIndex)
#pragma alloc_text(PAGE, SdbMakeIndexKeyFromString)
#pragma alloc_text(PAGE, SdbpTagToKey)
#endif // KERNEL_MODE && ALLOC_PRAGMA

TAGID
SdbFindFirstGUIDIndexedTag(
    IN  PDB         pdb,
    IN  TAG         tWhich,
    IN  TAG         tKey,
    IN  GUID*       pguidName,
    OUT FIND_INFO*  pFindInfo
    )
/*++
    Return: void

    Desc:   This function locates the first matching entry indexed by GUID id
--*/
{
    TAGID tiReturn;
    DWORD dwFlags = 0;

    pFindInfo->tiIndex = SdbGetIndex(pdb, tWhich, tKey, &dwFlags);

    if (pFindInfo->tiIndex == TAGID_NULL) {
        DBGPRINT((sdlError,
                  "SdbFindFirstGUIDIndexedTag",
                  "Failed to find index 0x%lx key 0x%lx\n",
                  tWhich, tKey));

        return TAGID_NULL;
    }

    pFindInfo->tName     = tKey;
    pFindInfo->pguidName = pguidName;
    pFindInfo->dwFlags   = dwFlags;
    pFindInfo->ullKey    = MAKEKEYFROMGUID(pguidName);

    tiReturn = SdbpGetFirstIndexedRecord(pdb, pFindInfo->tiIndex, pFindInfo->ullKey, pFindInfo);

    if (tiReturn == TAGID_NULL) {
        //
        // While this is handled properly in FindMatchingGUID we return here since
        // the record was not found in the index. It is not an abnormal condition.
        // We have just failed to find the match. Likewise, DBGPRINT is not warranted
        //
        return tiReturn;
    }

    return SdbpFindMatchingGUID(pdb, tiReturn, pFindInfo);
}

TAGID
SdbFindNextGUIDIndexedTag(
    IN  PDB        pdb,
    OUT FIND_INFO* pFindInfo
    )
/*++
    Return: The TAGID of the next GUID-indexed tag.

    Desc:   This function finds the next entry matching a guid provided in a
            previous call to SdbFindNextGUIDIndexedTag
--*/
{
    TAGID tiReturn;

    //
    // Get a preliminary match from the index.
    //
    tiReturn = SdbpGetNextIndexedRecord(pdb, pFindInfo->tiIndex, pFindInfo);

    if (tiReturn == TAGID_NULL) {
        //
        // This case is handled properly in SdbpFindMatchingGUID
        // we return here however for simplicity.
        // DBGPRINT is not needed since it's not an abnormal condition
        //
        return tiReturn;
    }

    return SdbpFindMatchingGUID(pdb, tiReturn, pFindInfo);
}

TAGID
SdbFindFirstDWORDIndexedTag(
    IN  PDB         pdb,
    IN  TAG         tWhich,
    IN  TAG         tKey,
    IN  DWORD       dwName,
    OUT FIND_INFO*  pFindInfo
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: what does this do ?
--*/
{

    TAGID tiReturn;
    DWORD dwFlags = 0;

    pFindInfo->tiIndex = SdbGetIndex(pdb, tWhich, tKey, &dwFlags);

    if (pFindInfo->tiIndex == TAGID_NULL) {
        DBGPRINT((sdlError,
                  "SdbFindFirstDWORDIndexedTag",
                  "Failed to find index 0x%lx key 0x%lx\n",
                  tWhich, tKey));

        return TAGID_NULL;
    }

    pFindInfo->tName   = tKey;
    pFindInfo->dwName  = dwName;
    pFindInfo->dwFlags = dwFlags;
    pFindInfo->ullKey  = MAKEKEYFROMDWORD(dwName);

    tiReturn = SdbpGetFirstIndexedRecord(pdb, pFindInfo->tiIndex, pFindInfo->ullKey, pFindInfo);

    if (tiReturn == TAGID_NULL) {
        //
        // While this is handled properly in FindMatchingGUID we return here since
        // the record was not found in the index. It is not an abnormal condition.
        // We have just failed to find the match. Likewise, DBGPRINT is not warranted
        //
        return tiReturn;
    }

    return SdbpFindMatchingDWORD(pdb, tiReturn, pFindInfo);
}

TAGID
SdbFindNextDWORDIndexedTag(
    IN  PDB        pdb,
    OUT FIND_INFO* pFindInfo
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    TAGID tiReturn;

    //
    // Get a preliminary match from the index.
    //
    tiReturn = SdbpGetNextIndexedRecord(pdb, pFindInfo->tiIndex, pFindInfo);

    if (tiReturn == TAGID_NULL) {
        //
        // This case is handled properly in SdbpFindMatchingDWORD
        // we return here however for simplicity.
        // DBGPRINT is not needed since it's not an abnormal condition
        //
        return tiReturn;
    }

    return SdbpFindMatchingDWORD(pdb, tiReturn, pFindInfo);

}

TAGID
SdbFindFirstStringIndexedTag(
    IN  PDB        pdb,
    IN  TAG        tWhich,
    IN  TAG        tKey,
    IN  LPCTSTR    pszName,
    OUT FIND_INFO* pFindInfo
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    TAGID tiReturn;
    DWORD dwFlags = 0;

    pFindInfo->tiIndex = SdbGetIndex(pdb, tWhich, tKey, &dwFlags);

    if (pFindInfo->tiIndex == TAGID_NULL) {

        DBGPRINT((sdlError,
                  "SdbFindFirstStringIndexedTag",
                  "Index not found 0x%lx Key 0x%lx\n",
                  tWhich,
                  tKey));

        return TAGID_NULL;
    }

    pFindInfo->tName   = tKey;
    pFindInfo->szName  = (LPTSTR)pszName;
    pFindInfo->dwFlags = dwFlags;
    pFindInfo->ullKey  = SdbMakeIndexKeyFromString(pszName);

    //
    // Get a preliminary match from the index.
    //
    tiReturn = SdbpGetFirstIndexedRecord(pdb, pFindInfo->tiIndex, pFindInfo->ullKey, pFindInfo);

    if (tiReturn == TAGID_NULL) {
        //
        // This is not a bug, tag was not found
        //
        return tiReturn;
    }

    DBGPRINT((sdlInfo, "SdbFindFirstStringIndexedTag", "Found tagid 0x%x\n", tiReturn));

    return SdbpFindMatchingName(pdb, tiReturn, pFindInfo);
}


TAGID
SdbFindNextStringIndexedTag(
    IN  PDB        pdb,
    OUT FIND_INFO* pFindInfo
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    TAGID tiReturn;

    //
    // Get a preliminary match from the index.
    //
    tiReturn = SdbpGetNextIndexedRecord(pdb, pFindInfo->tiIndex, pFindInfo);

    if (tiReturn == TAGID_NULL) {
        //
        // This is not a bug, this item was not found
        //
        return tiReturn;
    }

    return SdbpFindMatchingName(pdb, tiReturn, pFindInfo);

}

BOOL
SdbpBinarySearchUnique(
    IN  PINDEX_RECORD pRecords, // index record ptr
    IN  DWORD         nRecords, // number of records
    IN  ULONGLONG     ullKey,   // key to search for
    OUT DWORD*        pdwIndex  // index to the item
    )
/*++
    Return: TRUE if the index to the item is found.

    Desc:   BUGBUG: comment ?
--*/
{
    int       iLeft   = 0;
    int       iRight  = (int)nRecords - 1;
    int       i = -1;
    ULONGLONG ullKeyIndex;
    BOOL      bFound = FALSE;

    if (iRight >= 0) {
        do {
            i = (iLeft + iRight) / 2; // middle

            READ_INDEX_KEY(pRecords, i, &ullKeyIndex);

            if (ullKey <= ullKeyIndex) {
                iRight = i - 1;
            }

            if (ullKey >= ullKeyIndex) {
                iLeft = i + 1;
            }
        } while (iRight >= iLeft);
    }

    bFound = (iLeft - iRight > 1);

    if (bFound) {
        *pdwIndex = (DWORD)i;
    }
    return bFound;
}

BOOL
SdbpBinarySearchFirst(
    IN PINDEX_RECORD pRecords,
    IN DWORD         nRecords,
    IN ULONGLONG     ullKey,
    OUT DWORD*       pdwIndex
    )
{
    int iLeft = 0;
    int iRight = (int)nRecords - 1;
    int i = -1;

    ULONGLONG ullKeyIndex     = 0;
    ULONGLONG ullKeyIndexPrev = 0;
    BOOL bFound = FALSE;

    if (iRight < 0) {
        return FALSE;
    }

    do {

        i= (iLeft + iRight) / 2; // middle
        READ_INDEX_KEY(pRecords, i, &ullKeyIndex);

        if (ullKey == ullKeyIndex) {
            if (i == 0 || READ_INDEX_KEY_VAL(pRecords, i - 1, &ullKeyIndexPrev) != ullKey) {
                //
                // we are done, thank you
                //
                bFound = TRUE;
                break;
            } else {
                //
                // look in the previous record
                //
                iRight = i - 1;
            }

        } else {

            if (ullKey < ullKeyIndex) {
                iRight = i - 1;
            } else {
                iLeft = i + 1;
            }
        }

    } while (iRight >= iLeft);

    if (bFound) {
        *pdwIndex = (DWORD)i;
    }
    return bFound;

}

TAGID
SdbpGetFirstIndexedRecord(
    IN  PDB        pdb,         // the DB to use
    IN  TAGID      tiIndex,     // the index to use
    IN  ULONGLONG  ullKey,      // the key to search for
    OUT FIND_INFO* pFindInfo    // search context
    )
/*++
    Return: the record found, or TAGID_NULL.

    Desc:   Looks through an index for the first record that matches the key. It
            returns the index record position for subsequent calls to SdbpGetNextIndexedRecord.
--*/
{
    PINDEX_RECORD pIndexRecords;
    DWORD         dwRecords;
    BOOL          bFound;

    if (SdbGetTagFromTagID(pdb, tiIndex) != TAG_INDEX_BITS) {

        DBGPRINT((sdlError,
                  "SdbpGetFirstIndexedRecord",
                  "The tag 0x%lx is not an index tag\n",
                  tiIndex));

        return TAGID_NULL;
    }

    dwRecords = SdbGetTagDataSize(pdb, tiIndex) / sizeof(INDEX_RECORD);

    pIndexRecords = (INDEX_RECORD*)SdbpGetMappedTagData(pdb, tiIndex);

    if (pIndexRecords == NULL) {

        DBGPRINT((sdlError,
                  "SdbpGetFirstIndexedRecord",
                  "Failed to get the pointer to index data, index tagid 0x%lx\n",
                  tiIndex));

        return TAGID_NULL;
    }

    //
    // Check to see whether our index is "unique", if so use our search proc.
    //
    if (pFindInfo->dwFlags & SHIMDB_INDEX_UNIQUE_KEY) {
        bFound = SdbpBinarySearchUnique(pIndexRecords,
                                        dwRecords,
                                        ullKey,
                                        &pFindInfo->dwIndexRec);

        if (bFound && pFindInfo->dwIndexRec < (dwRecords - 1)) {
            //
            // We have the next rec -- retrieve the next tagid.
            //
            pFindInfo->tiEndIndex = pIndexRecords[pFindInfo->dwIndexRec + 1].tiRef;
        } else {
            //
            // We will have to search until eof.
            //
            pFindInfo->tiEndIndex = TAGID_NULL;
        }
        pFindInfo->tiCurrent = TAGID_NULL;

    } else {
        bFound = SdbpBinarySearchFirst(pIndexRecords,
                                       dwRecords,
                                       ullKey,
                                       &pFindInfo->dwIndexRec);
    }

    return bFound ? pIndexRecords[pFindInfo->dwIndexRec].tiRef : TAGID_NULL;
}

TAGID
SdbpGetNextIndexedRecord(
    IN  PDB        pdb,         // the DB to use
    IN  TAGID      tiIndex,     // the index to use
    OUT FIND_INFO* pFindInfo    // the find context
    )
/*++
    Return: the record found, or TAGID_NULL.

    Desc:   Gets the next record that matches the one found by a previous call to
            SdbpGetFirstIndexedRecord.
--*/
{
    ULONGLONG     ullKey;
    ULONGLONG     ullKeyNext;
    PINDEX_RECORD pIndexRecords;
    DWORD         dwRecords;
    TAGID         tiRef = TAGID_NULL;
    TAGID         tiThis;
    TAG           tag, tagThis;

    if (SdbGetTagFromTagID(pdb, tiIndex) != TAG_INDEX_BITS) {
        DBGPRINT((sdlError,
                  "SdbpGetNextIndexedRecord",
                  "The tag 0x%lx is not an index tag\n",
                  tiIndex));

        return TAGID_NULL;
    }

    pIndexRecords = (PINDEX_RECORD)SdbpGetMappedTagData(pdb, tiIndex);

    if (pIndexRecords == NULL) {

        DBGPRINT((sdlError,
                  "SdbpGetNextIndexedRecord",
                  "Failed to get pointer to the index data tagid x%lx\n",
                  tiIndex));

        return TAGID_NULL;
    }

    if (pFindInfo->dwFlags & SHIMDB_INDEX_UNIQUE_KEY) {
        //
        // There are 2 cases:
        // - this is the very first call to SdbpGetNextIndexedrecord
        // - this is one of the subsequent calls
        //
        // In the first case, we will have tiCurrent member of the FIND_INFO
        // structure set to TAGID_NULL. We use then the reference to the
        // index table contained in pFindInfo->dwIndexRec to obtain the reference
        // to the next eligible entry in the database.
        // In the second case we use the stored tiCurrent to obtain the current tag
        //
        if (pFindInfo->tiCurrent == TAGID_NULL) {
            tiThis = pIndexRecords[pFindInfo->dwIndexRec].tiRef;
        } else {
            tiThis = pFindInfo->tiCurrent;
        }

        //
        // The tag tiThis which we just obtained was the one we previously looked at
        // we need to step to the next tag, the call below does that. Entries are sorted
        // since we're using "unique" index
        //
        tiRef = SdbpGetNextTagId(pdb, tiThis);

        //
        // Now check the tag for corruption, eof and other calamities.
        //
        tagThis = SdbGetTagFromTagID(pdb, tiThis);
        tag     = SdbGetTagFromTagID(pdb, tiRef);

        if (tag == TAG_NULL || GETTAGTYPE(tag) != TAG_TYPE_LIST || tag != tagThis) {

            //
            // This is NOT a bug, but a special condition when the tag happened to be
            // the very last tag in the index, thus we have to walk until we hit either
            // the end of the file - or a tag of a different type

            return TAGID_NULL;
        }

        //
        // Also check for the endtag. It will be a check for TAGID_NULL if we're
        // looking for eof but this condition has already been caught by the code above.
        //
        if (tiRef == pFindInfo->tiEndIndex) {

            //
            // This is not an error condition. We have walked all the matching entries until
            // we hit the very last entry, as denoted by tiEndIndex
            //

            return TAGID_NULL;
        }

        //
        // Also here check whether the key still has the same
        // value for this entry as it did for the previous entry.
        // This would have been easy but keys are not immediately available
        // for this entry therefore we just return the tiRef. The caller will
        // verify whether the entry is valid and whether the search should continue.
        //
        pFindInfo->tiCurrent = tiRef;

    } else {

        dwRecords = SdbGetTagDataSize(pdb, tiIndex) / sizeof(INDEX_RECORD);

        //
        // Get out if this is the last record.
        //
        if (pFindInfo->dwIndexRec == dwRecords - 1) {
            //
            // This is not a bug, record not found
            //
            return TAGID_NULL;
        }

        //
        // we check the next index record to see if it has the same key
        //
        READ_INDEX_KEY(pIndexRecords, pFindInfo->dwIndexRec, &ullKey);
        READ_INDEX_KEY(pIndexRecords, pFindInfo->dwIndexRec + 1, &ullKeyNext);

        if (ullKey != ullKeyNext) {

            //
            // This is not a bug, record not found
            //
            return TAGID_NULL;
        }

        ++pFindInfo->dwIndexRec;
        tiRef = pIndexRecords[pFindInfo->dwIndexRec].tiRef;
    }

    return tiRef;
}

BOOL
SdbpPatternMatch(
    IN  LPCTSTR pszPattern,
    IN  LPCTSTR pszTestString)
/*++
    Return: TRUE if pszTestString matches pszPattern
            FALSE if not

    Desc:   This function does a case-insensitive comparison of
            pszTestString against pszPattern. pszPattern can
            include asterisks to do wildcard matches.

            Any complaints about this function should be directed
            toward MarkDer.
--*/
{
    //
    // March through pszTestString. Each time through the loop,
    // pszTestString is advanced one character.
    //
    while (TRUE) {

        //
        // If pszPattern and pszTestString are both sitting on a NULL,
        // then they reached the end at the same time and the strings
        // must be equal.
        //
        if (*pszPattern == TEXT('\0') && *pszTestString == TEXT('\0')) {
            return TRUE;
        }

        if (*pszPattern != TEXT('*')) {

            //
            // Non-asterisk mode. Look for a match on this character.
            // If equal, continue traversing. Otherwise, the strings
            // cannot be equal so return FALSE.
            //
            if (UPCASE_CHAR(*pszPattern) == UPCASE_CHAR(*pszTestString)) {
                pszPattern++;
            } else {
                return FALSE;
            }

        } else {

            //
            // Asterisk mode. Look for a match on the character directly
            // after the asterisk.
            //
            if (*(pszPattern + 1) == TEXT('*')) {
                //
                // Asterisks exist side by side. Advance the pattern pointer
                // and go through loop again.
                //
                pszPattern++;
                continue;
            }

            if (*(pszPattern + 1) == TEXT('\0')) {
                //
                // Asterisk exists at the end of the pattern string. Any
                // remaining part of pszTestString matches so we can
                // immediately return TRUE.
                //
                return TRUE;
            }

            if (UPCASE_CHAR(*(pszPattern + 1)) == UPCASE_CHAR(*pszTestString)) {
                //
                // Characters match. If the remaining parts of
                // pszPattern and pszTestString match, then the entire
                // string matches. Otherwise, keep advancing the
                // pszTestString pointer.
                //
                if (SdbpPatternMatch(pszPattern + 1, pszTestString)) {
                    return TRUE;
                }
            }
        }

        //
        // No more pszTestString left. Must not be a match.
        //
        if (!*pszTestString) {
            return FALSE;
        }

        pszTestString++;
    }
}

BOOL
SdbpPatternMatchAnsi(
    IN  LPCSTR pszPattern,
    IN  LPCSTR pszTestString)
{
    //
    // March through pszTestString. Each time through the loop,
    // pszTestString is advanced one character.
    //
    while (TRUE) {

        //
        // If pszPattern and pszTestString are both sitting on a NULL,
        // then they reached the end at the same time and the strings
        // must be equal.
        //
        if (*pszPattern == '\0' && *pszTestString == '\0') {
            return TRUE;
        }

        if (*pszPattern != '*') {

            //
            // Non-asterisk mode. Look for a match on this character.
            // If equal, continue traversing. Otherwise, the strings
            // cannot be equal so return FALSE.
            //
            if (toupper(*pszPattern) == toupper(*pszTestString)) {
                pszPattern++;
            } else {
                return FALSE;
            }

        } else {

            //
            // Asterisk mode. Look for a match on the character directly
            // after the asterisk.
            //

            if (*(pszPattern + 1) == '*') {
                //
                // Asterisks exist side by side. Advance the pattern pointer
                // and go through loop again.
                //
                pszPattern++;
                continue;
            }

            if (*(pszPattern + 1) == '\0') {
                //
                // Asterisk exists at the end of the pattern string. Any
                // remaining part of pszTestString matches so we can
                // immediately return TRUE.
                //
                return TRUE;
            }

            if (toupper(*(pszPattern + 1)) == toupper(*pszTestString)) {
                //
                // Characters match. If the remaining parts of
                // pszPattern and pszTestString match, then the entire
                // string matches. Otherwise, keep advancing the
                // pszTestString pointer.
                //
                if (SdbpPatternMatchAnsi(pszPattern + 1, pszTestString)) {
                    return TRUE;
                }
            }
        }

        //
        // No more pszTestString left. Must not be a match.
        //
        if (!*pszTestString) {
            return FALSE;
        }

        pszTestString++;
    }
}

char*
SdbpKeyToAnsiString(
    ULONGLONG ullKey,
    char*     szString
    )
/*++
    Return: ?

    Desc:   ?
--*/
{
    char* szRevString = (char*)&ullKey;
    int   i;

    for (i = 0; i < 8; ++i) {
        szString[i] = szRevString[7 - i];
    }
    szString[8] = 0;

    return szString;
}

TAGID
SdbpFindFirstIndexedWildCardTag(
    PDB          pdb,
    TAG          tWhich,
    TAG          tKey,
    LPCTSTR      szName,
    FIND_INFO*   pFindInfo
    )
/*++
    Return: ?

    Desc:   ?
--*/
{
    char          szAnsiName[MAX_PATH];
    char          szAnsiKey[10];
    PINDEX_RECORD pIndex = NULL;
    DWORD         dwRecs;
    NTSTATUS      status;
    DWORD         dwFlags = 0;
    DWORD         i, j;

    pFindInfo->tiIndex = SdbGetIndex(pdb, tWhich, tKey, &dwFlags);

    if (pFindInfo->tiIndex == TAGID_NULL) {
        DBGPRINT((sdlError,
                  "SdbpFindFirstIndexedWilCardTag",
                  "Failed to get an index for tag 0x%lx key 0x%lx\n",
                  (DWORD)tWhich,
                  (DWORD)tKey));

        return TAGID_NULL;
    }

    pFindInfo->tName   = tKey;
    pFindInfo->szName  = szName;
    pFindInfo->dwFlags = dwFlags;

    RtlZeroMemory(szAnsiName, MAX_PATH);
    RtlZeroMemory(szAnsiKey, 10);

    //
    // Get the uppercase ANSI version of this search string so
    // it will match the keys in the index.
    //
    status = UPCASE_UNICODETOMULTIBYTEN(szAnsiName,
                                        CHARCOUNT(szAnsiName),    // this is size in characters
                                        pFindInfo->szName);
    if (!NT_SUCCESS(status)) {

        DBGPRINT((sdlError,
                  "SdbpFindFirstIndexedWildCardTag",
                  "Failed to convert name to multi-byte\n"));
        return TAGID_NULL;
    }

    //
    // Get the index.
    //
    pIndex = SdbpGetIndex(pdb, pFindInfo->tiIndex, &dwRecs);

    if (pIndex == NULL) {
        DBGPRINT((sdlError,
                  "SdbpFindFirstIndexedWildCardTag",
                  "Failed to get index by tag id 0x%lx\n",
                  pFindInfo->tiIndex));
        return TAGID_NULL;
    }

    //
    // Walk through the whole index sequentially, doing a first pass check of the key
    // so we can avoid getting the whole record if the name clearly isn't a match.
    //
    for (i = 0; i < dwRecs; ++i) {

        TAGID  tiMatch;
        TAGID  tiKey;
        LPTSTR szDBName;
        ULONGLONG ullKey;

        READ_INDEX_KEY(pIndex, i, &ullKey);

        //
        // the call below never fails, so we don't check return value
        //
        SdbpKeyToAnsiString(pIndex[i].ullKey, szAnsiKey);

        //
        // If the original pattern match is more than eight characters, we have
        // to plant an asterisk at the eighth character so that proper wildcard
        // matching occurs.
        //
        szAnsiKey[8] = '*';

        //
        // Quick check of the string that's in the key.
        //
        if (!SdbpPatternMatchAnsi(szAnsiKey, szAnsiName)) {
            continue;
        }

        //
        // We found a tentative match, now pull the full record and
        // see if it's real.
        //
        tiMatch = pIndex[i].tiRef;

        //
        // Get the key field.
        //
        tiKey = SdbFindFirstTag(pdb, tiMatch, pFindInfo->tName);

        if (tiKey == TAGID_NULL) {
            //
            // This is not a bug, but rather continue searching
            //
            continue;
        }

        szDBName = SdbGetStringTagPtr(pdb, tiKey);

        if (szDBName == NULL) {
            // BUGBUG: what if this fails ?
            continue;
        }

        //
        // Is this really a match?
        //
        if (SdbpPatternMatch(szDBName, pFindInfo->szName)) {
            pFindInfo->dwIndexRec = i;
            return tiMatch;
        }
    }

    // BUGBUG: DPF
    return TAGID_NULL;
}

TAGID
SdbpFindNextIndexedWildCardTag(
    PDB        pdb,
    FIND_INFO* pFindInfo
    )
/*++
    Return: ?

    Desc:   ?
--*/
{
    char          szAnsiName[MAX_PATH];
    char          szAnsiKey[10];
    PINDEX_RECORD pIndex = NULL;
    DWORD         dwRecs;
    NTSTATUS      status;
    DWORD         i, j;

    RtlZeroMemory(szAnsiName, MAX_PATH);
    RtlZeroMemory(szAnsiKey, 10);

    //
    // Get the uppercase ANSI version of this search string so
    // it will match the keys in the index.
    //
    status = UPCASE_UNICODETOMULTIBYTEN(szAnsiName,
                                        CHARCOUNT(szAnsiName),
                                        pFindInfo->szName);

    if (!NT_SUCCESS(status)) {
        // BUGBUG: DPF
        return TAGID_NULL;
    }

    //
    // Get the index.
    //
    pIndex = SdbpGetIndex(pdb, pFindInfo->tiIndex, &dwRecs);

    if (pIndex == NULL) {
        // BUGBUG: DPF
        return TAGID_NULL;
    }

    //
    // Walk through the rest of the index sequentially, doing a first pass
    // check of the key so we can avoid getting the whole record if the
    // name clearly isn't a match.
    //
    for (i = pFindInfo->dwIndexRec + 1; i < dwRecs; ++i) {
        
        TAGID     tiMatch;
        TAGID     tiKey;
        LPTSTR    pszDBName;
        ULONGLONG ullKey;

        READ_INDEX_KEY(pIndex, i, &ullKey);

        SdbpKeyToAnsiString(ullKey, szAnsiKey);

        //
        // If the original pattern match is more than eight characters, we have
        // to plant an asterisk at the eighth character so that proper wildcard
        // matching occurs.
        //
        szAnsiKey[8] = '*';

        //
        // Quick check of the string that's in the key.
        //
        if (!SdbpPatternMatchAnsi(szAnsiKey, szAnsiName)) {
            // BUGBUG: DPF
            continue;
        }

        //
        // We found a tentative match, now pull the full record and
        // see if it's real.
        //
        tiMatch = pIndex[i].tiRef;

        //
        // Get the key field.
        //
        tiKey = SdbFindFirstTag(pdb, tiMatch, pFindInfo->tName);

        if (tiKey == TAGID_NULL) {
            // BUGBUG: DPF
            continue;
        }

        pszDBName = SdbGetStringTagPtr(pdb, tiKey);

        if (pszDBName == NULL) {
            // BUGBUG: DPF
            continue;
        }

        //
        // Is this really a match?
        //
        if (SdbpPatternMatch(pszDBName, pFindInfo->szName)) {
            pFindInfo->dwIndexRec = i;
            return tiMatch;
        }
    }

    // BUGBUG: DPF
    return TAGID_NULL;
}

//
// Index access functions (for reading) -- better to use tiFindFirstIndexedTag, above
//

TAGID
SdbGetIndex(
    IN  PDB     pdb,            // db to use
    IN  TAG     tWhich,         // tag we'd like an index for
    IN  TAG     tKey,           // the kind of tag used as a key for this index
    OUT LPDWORD lpdwFlags       // index record flags (e.g. indicator whether the index
                                // is "unique" style
    )
/*++
    Return: TAGID of index, or TAGID_NULL.

    Desc:   Retrieves a TAGID ptr to the index bits for a specific
            tag, if one exists.
--*/
{
    TAGID tiReturn = TAGID_NULL;
    int   i;

    //
    // Scan the indexes if not done already.
    //
    if (!pdb->bIndexesScanned) {
        SdbpScanIndexes(pdb);
    }

    for (i = 0; i < MAX_INDEXES; ++i) {
        
        if (!pdb->aIndexes[i].tWhich) {
            
            DBGPRINT((sdlInfo,
                      "SdbGetIndex",
                      "index 0x%x(0x%x) was not found in the index table\n",
                      tWhich,
                      tKey));
            
            return TAGID_NULL;
        }

        if (pdb->aIndexes[i].tWhich == tWhich && pdb->aIndexes[i].tKey == tKey) {
            
            tiReturn = pdb->aIndexes[i].tiIndex;

            if (lpdwFlags != NULL) {
                *lpdwFlags = pdb->aIndexes[i].dwFlags;
            }
            
            break;
        }
    }

    return tiReturn;
}

void
SdbpScanIndexes(
    IN  PDB pdb                 // db to use
    )
/*++

    Params: described above.

    Return: void. No failure case.

    Desc:   Scans the initial tags in the DB and gets the index pointer info.
--*/
{
    TAGID tiFirst;
    TAGID tiIndex;

    if (pdb->bIndexesScanned && !pdb->bWrite) {
        //
        // This is not an error condition
        //
        return;
    }

    RtlZeroMemory(pdb->aIndexes, sizeof(pdb->aIndexes));

    pdb->bIndexesScanned = TRUE;

    //
    // The indexes must be the first tag.
    //
    tiFirst = SdbGetFirstChild(pdb, TAGID_ROOT);

    if (tiFirst == TAGID_NULL) {
        DBGPRINT((sdlError,
                  "SdbpScanIndexes",
                  "Failed to get the child index from root\n"));
        return;
    }

    if (SdbGetTagFromTagID(pdb, tiFirst) != TAG_INDEXES) {
        DBGPRINT((sdlError,
                  "SdbpScanIndexes",
                  "Root child tag is not index tagid 0x%lx\n",
                  tiFirst));
        return;
    }

    pdb->dwIndexes = 0;
    tiIndex = SdbFindFirstTag(pdb, tiFirst, TAG_INDEX);

    while (tiIndex != TAGID_NULL) {

        TAGID tiIndexTag;
        TAGID tiIndexKey;
        TAGID tiIndexBits;
        TAGID tiIndexFlags;

        if (pdb->dwIndexes == MAX_INDEXES) {
            DBGPRINT((sdlError,
                      "SdbpScanIndexes",
                      "Too many indexes in file. Recompile and increase MAX_INDEXES.\n"));
            return;
        }

        tiIndexTag = SdbFindFirstTag(pdb, tiIndex, TAG_INDEX_TAG);

        if (tiIndexTag == TAGID_NULL) {
            DBGPRINT((sdlError,
                      "SdbpScanIndexes",
                      "Index missing TAG_INDEX_TAG.\n"));
            return;
        }
        
        pdb->aIndexes[pdb->dwIndexes].tWhich = SdbReadWORDTag(pdb, tiIndexTag, TAG_NULL);

        tiIndexKey = SdbFindFirstTag(pdb, tiIndex, TAG_INDEX_KEY);

        if (tiIndexKey == TAGID_NULL) {
            DBGPRINT((sdlError, "SdbpScanIndexes", "Index missing TAG_INDEX_KEY.\n"));
            return;
        }
        pdb->aIndexes[pdb->dwIndexes].tKey = SdbReadWORDTag(pdb, tiIndexKey, TAG_NULL);

        tiIndexFlags = SdbFindFirstTag(pdb, tiIndex, TAG_INDEX_FLAGS);

        if (tiIndexFlags != TAGID_NULL) {
            pdb->aIndexes[pdb->dwIndexes].dwFlags = SdbReadDWORDTag(pdb, tiIndexFlags, 0);
        } else {
            pdb->aIndexes[pdb->dwIndexes].dwFlags = 0;
        }

        tiIndexBits = SdbFindFirstTag(pdb, tiIndex, TAG_INDEX_BITS);

        if (tiIndexBits == TAGID_NULL) {
            pdb->aIndexes[pdb->dwIndexes].tWhich = TAG_NULL;
            DBGPRINT((sdlError, "SdbpScanIndexes", "Index missing TAG_INDEX_BITS.\n"));
            return;
        }
        pdb->aIndexes[pdb->dwIndexes].tiIndex = tiIndexBits;

        pdb->dwIndexes++;

        tiIndex = SdbFindNextTag(pdb, tiFirst, tiIndex);
    }

    return;
}

PINDEX_RECORD
SdbpGetIndex(
    IN  PDB    pdb,
    IN  TAGID  tiIndex,
    OUT DWORD* pdwNumRecs
    )
/*++
    Return: ?

    Desc:   ?
--*/
{
    if (SdbGetTagFromTagID(pdb, tiIndex) != TAG_INDEX_BITS) {
        DBGPRINT((sdlError,
                  "SdbpGetIndex",
                  "Index tagid 0x%lx is not referring to the index bits\n",
                  tiIndex));
        return NULL;
    }

    *pdwNumRecs = SdbGetTagDataSize(pdb, tiIndex) / sizeof(INDEX_RECORD);

    return (PINDEX_RECORD)SdbpGetMappedTagData(pdb, tiIndex);
}

#if defined(_WIN64)

ULONGLONG
SdbMakeIndexKeyFromGUID(
    IN GUID* pGuid
    )
/*
    Return: a 64-bit key to use for searching

    Desc:   The standard index key is created for a Guid
            using the xor operation on a first and second half
            of guid
*/
{
    ULONGLONG ullPart1 = 0,
              ullPart2 = 0;

    RtlMoveMemory(&ullPart1, pGuid, sizeof(ULONGLONG));
    RtlMoveMemory(&ullPart2, (PBYTE)pGuid + sizeof(ULONGLONG), sizeof(ULONGLONG));

    return (ullPart1 ^ ullPart2);
}

#endif // _WIN64


#define SDB_KEY_LENGTH_BYTES 8
#define SDB_KEY_LENGTH 8

ULONGLONG
SdbMakeIndexKeyFromString(
    IN  LPCTSTR szKey
    )
/*++
    Return: a 64-bit key to use for searching.

    Desc:   The standard index key for a Unicode string is the
            first 8 characters of the string, converted to uppercase ansi,
            then cast to a ULONGLONG (64 bit unsigned int).
--*/
{
    char     szFlippedKey[SDB_KEY_LENGTH_BYTES]; // flipped to deal with little-endian issues
    char*    pszKey = &szFlippedKey[SDB_KEY_LENGTH_BYTES-1]; // points to the last char
    NTSTATUS status;
    int      i;
    WCHAR    ch;
    int      nLength;

#ifndef WIN32A_MODE

    UNICODE_STRING  ustrKey;
    UNICODE_STRING  ustrKeySrc; // truncated string
    UNICODE_STRING  ustrKeySrcUpcased;
    WCHAR           Buffer[SDB_KEY_LENGTH];
    WCHAR           BufferUpcased[SDB_KEY_LENGTH];
    LPCWSTR         pKeyBuffer = BufferUpcased;
    NTSTATUS        Status;
    
    RtlInitUnicodeString(&ustrKey, szKey);

    //
    // Call below copies upto maximum length of the destination string
    //
    ustrKeySrc.Buffer        = Buffer;
    ustrKeySrc.MaximumLength = sizeof(Buffer);
    RtlCopyUnicodeString(&ustrKeySrc, &ustrKey);

    //
    // Upcase what we have created
    //
    ustrKeySrcUpcased.Buffer        = BufferUpcased;
    ustrKeySrcUpcased.MaximumLength = sizeof(BufferUpcased);
    
    Status = RtlUpcaseUnicodeString(&ustrKeySrcUpcased, &ustrKeySrc, FALSE);
    
    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbMakeIndexKeyFromString",
                  "Failed to upcase unicode string \"%s\"\n",
                  szKey));
        return 0;
    }

    //
    // Now we have an upper-case unicode string which is of max. 8 characters length
    //
    nLength = ustrKeySrcUpcased.Length / sizeof(WCHAR);

#else // WIN32A_MODE

    WCHAR   Buffer[SDB_KEY_LENGTH + 1];
    LPCWSTR pKeyBuffer = Buffer;

    nLength = mbstowcs(Buffer, szKey, CHARCOUNT(Buffer));
    
    if (nLength < 0) {
        DBGPRINT((sdlError,
                  "SdbMakeIndexKeyFromString",
                  "Failed to convert string \"%s\" to unicode\n",
                  szKey));
        return 0;
    }

    Buffer[nLength] = TEXT('\0'); // zero-terminate

    //
    // Upcase now. Buffer is always 0-terminated.
    //
    _wcsupr(Buffer);

#endif // WIN32A_MODE

    assert(nLength <= SDB_KEY_LENGTH);

    RtlZeroMemory(szFlippedKey , sizeof(szFlippedKey));

    //
    // To be compatible with the old (ANSI) scheme of making keys, we
    // construct the key using all non-null bytes in the string, up to 8
    //
    for (i = 0; i < nLength; ++i) {

        ch = *pKeyBuffer++;
        *pszKey-- = (unsigned char)ch;

        //
        // ch is a unicode char, whatever it is, see if it has 2 bytes or just one
        //
        if (HIBYTE(ch) && i < (SDB_KEY_LENGTH - 1)) {
            //
            // Two bytes, store both
            //
            *pszKey-- = (unsigned char)HIBYTE(ch);
            ++i;
        }
    }

    return *((ULONGLONG*)szFlippedKey);
}


ULONGLONG
SdbpTagToKey(
    IN  PDB   pdb,
    IN  TAGID tiTag
    )
/*++
    Return: ?

    Desc:   ?
--*/
{
    TAG_TYPE  ttType;
    ULONGLONG ullReturn = 0;
    DWORD     dwSize;
    PVOID     pData;
    LPTSTR    szTemp = NULL;

    ttType = GETTAGTYPE(SdbGetTagFromTagID(pdb, tiTag));

    switch (ttType) {
    
    case TAG_TYPE_STRING:
    case TAG_TYPE_STRINGREF:
        
        szTemp = SdbGetStringTagPtr(pdb, tiTag);
        
        if (!szTemp) {
            ullReturn = 0;
        } else {
            ullReturn = SdbMakeIndexKeyFromString(szTemp);
        }
        
        break;

    case TAG_TYPE_NULL:
        ullReturn = 1;
        break;

    case TAG_TYPE_BINARY: // indexing binary data
                          // check that the size of the data is sizeof(GUID)
        if (sizeof(GUID) == SdbGetTagDataSize(pdb, tiTag)) {
            //
            // Special case.
            //
            pData = SdbpGetMappedTagData(pdb, tiTag);
            
            if (pData == NULL) {
                return 0;
            }

            ullReturn = MAKEKEYFROMGUID((GUID*)pData);
            break;
        }
        //
        // Fall through to the general binary data case.
        //

    default:
        
        dwSize = SdbGetTagDataSize(pdb, tiTag);
        
        if (dwSize > sizeof(ULONGLONG)) {
            dwSize = sizeof(ULONGLONG);
        }
        
        pData = SdbpGetMappedTagData(pdb, tiTag);
        
        if (pData == NULL) {
            return 0;
        }

        memcpy(&ullReturn, pData, dwSize);
        break;
    }

    return ullReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\guid.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        guid.c

    Abstract:

        GUID-related utilities that run on win9x and nt4 as
        well as win2k and whistler
        
    Author:

        vadimb     created     sometime in 2001

    Revision History:


--*/

#include "sdbp.h"
#include "initguid.h"

#if defined(KERNEL_MODE) && defined(ALLOC_DATA_PRAGMA)
#pragma  data_seg()
#endif // KERNEL_MODE && ALLOC_DATA_PRAGMA

const TCHAR g_szGuidFormat[] = TEXT("{%08lx-%04hx-%04hx-%02hx%02hx-%02hx%02hx%02hx%02hx%02hx%02hx}");

#if defined(KERNEL_MODE) && defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, SdbpGUIDToUnicodeString)
#pragma alloc_text(PAGE, SdbpFreeUnicodeString)
#pragma alloc_text(PAGE, SdbGUIDToString)
#endif // KERNEL_MODE && ALLOC_PRAGMA

//
// GUID string buffer size (in chars) not including the term null char
//
#define GUID_STRING_SIZE 38 

DEFINE_GUID(STATIC_NULL_GUID, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, \
            0x0, 0x0, 0x0, 0x0);


BOOL
SDBAPI 
SdbIsNullGUID(
    IN GUID* pGuid
    )
{
    return pGuid == NULL || 
           RtlEqualMemory(pGuid, &STATIC_NULL_GUID, sizeof(*pGuid));
}


#if defined(NT_MODE) || defined(KERNEL_MODE)

BOOL
SDBAPI
SdbGUIDFromString(
    IN  LPCWSTR lpszGuid,
    OUT GUID*   pGuid
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Converts a string to a GUID.
--*/
{
    UNICODE_STRING ustrGuid;
    NTSTATUS       status;

    RtlInitUnicodeString(&ustrGuid, lpszGuid);

    status = RtlGUIDFromString(&ustrGuid, pGuid);

    return NT_SUCCESS(status);
}

#else // we do the same thing for both WIN32A and WIN32U

BOOL
SdbGUIDFromString(
    LPCTSTR lpszGuid,
    GUID* pGuid)
{
    int   nFields;
    DWORD rgData4[8];
    DWORD dwData2;
    DWORD dwData3;
    INT   i;

    nFields = _stscanf(lpszGuid, g_szGuidFormat,
                       &pGuid->Data1,   // type : long
                       &dwData2,   // type : short
                       &dwData3,   // type : short
                       &rgData4[0],// type : short all the way to the bottom
                       &rgData4[1],
                       &rgData4[2],
                       &rgData4[3],
                       &rgData4[4],
                       &rgData4[5],
                       &rgData4[6],
                       &rgData4[7]);

    if (nFields == 11) {
        pGuid->Data2 = (USHORT)dwData2;
        pGuid->Data3 = (USHORT)dwData3;
        for (i = 0; i < 8; ++i) {
            pGuid->Data4[i] = (BYTE)rgData4[i];
        }
    }

    return (nFields == 11);
}

#endif

#ifndef WIN32A_MODE
//
// Private Functions used internally
//

NTSTATUS
SdbpGUIDToUnicodeString(
    IN  GUID* pGuid,
    OUT PUNICODE_STRING pUnicodeString
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    pUnicodeString->Length        = GUID_STRING_SIZE * sizeof(WCHAR);
    pUnicodeString->MaximumLength = pUnicodeString->Length + sizeof(UNICODE_NULL);
    pUnicodeString->Buffer        = SdbAlloc(pUnicodeString->MaximumLength);

    if (pUnicodeString->Buffer == NULL) {
        DBGPRINT((sdlError,
                  "SdbpGUIDToUnicodeString",
                  "Failed to allocate %ld bytes for GUID\n",
                  (DWORD)pUnicodeString->MaximumLength));
        return STATUS_NO_MEMORY;
    }

    swprintf(pUnicodeString->Buffer, g_szGuidFormat,
             pGuid->Data1,
             pGuid->Data2,
             pGuid->Data3,
             pGuid->Data4[0],
             pGuid->Data4[1],
             pGuid->Data4[2],
             pGuid->Data4[3],
             pGuid->Data4[4],
             pGuid->Data4[5],
             pGuid->Data4[6],
             pGuid->Data4[7]);

    return STATUS_SUCCESS;
}

VOID
SdbpFreeUnicodeString(
    PUNICODE_STRING pUnicodeString
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    if (pUnicodeString->Buffer != NULL) {
        SdbFree(pUnicodeString->Buffer);
        RtlZeroMemory(pUnicodeString, sizeof(*pUnicodeString));
    }
}

#endif // WIN32A_MODE

BOOL 
SDBAPI
SdbGUIDToString(
    IN  GUID*  pGuid,
    OUT LPTSTR pszGuid
    )
{
    _stprintf(pszGuid, g_szGuidFormat,
              pGuid->Data1,
              pGuid->Data2,
              pGuid->Data3,
              pGuid->Data4[0],
              pGuid->Data4[1],
              pGuid->Data4[2],
              pGuid->Data4[3],
              pGuid->Data4[4],
              pGuid->Data4[5],
              pGuid->Data4[6],
              pGuid->Data4[7]);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\msitransform.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        apphelp.c

    Abstract:

        This module implements high-level functions to access msi installer information

    Author:

        vadimb     created     sometime in 2000

    Revision History:

--*/

#include "sdbp.h"

/*++
// Local function prototype
//
//
--*/
PDB
SdbpGetNextMsiDatabase(
    IN HSDB            hSDB,
    IN LPCTSTR         lpszLocalDB,
    IN OUT PSDBMSIFINDINFO pFindInfo
    );

TAGID
SdbpFindPlatformMatch(
    IN HSDB hSDB,
    IN PDB  pdb,
    IN TAGID tiMatch,  // current match using the GUID index
    IN PSDBMSIFINDINFO pFindInfo
    )
{
    TAGID           tiRuntimePlatform;
    DWORD           dwRuntimePlatform;
    LPCTSTR         pszGuid = NULL;
#ifndef WIN32A_MODE
    UNICODE_STRING  ustrGUID = { 0 };
    NTSTATUS        Status;
#else
    TCHAR           szGUID[64]; // guid is about 38 chars + 0
#endif // WIN32A_MODE
    TAGID           tiOSSKU;
    DWORD           dwOSSKU;


    if (tiMatch != TAGID_NULL) {
#ifndef WIN32A_MODE
        GUID_TO_UNICODE_STRING(&pFindInfo->guidID, &ustrGUID);
        pszGuid = ustrGUID.Buffer;
#else // WIN32A_MODE
        GUID_TO_STRING(&pFindInfo->guidID, szGUID);
        pszGuid = szGUID;
#endif // WIN32A_MODE
    }

    while (tiMatch != TAGID_NULL) {

        tiRuntimePlatform = SdbFindFirstTag(pdb, tiMatch, TAG_RUNTIME_PLATFORM);
        if (tiRuntimePlatform != TAGID_NULL) {

            dwRuntimePlatform = SdbReadDWORDTag(pdb, tiRuntimePlatform, RUNTIME_PLATFORM_ANY);

            //
            // Check for the platform match
            //
            if (!SdbpCheckRuntimePlatform(hSDB, pszGuid, dwRuntimePlatform)) {
                goto CheckNextMatch;
            }
        }

        // check for SKU match

        tiOSSKU = SdbFindFirstTag(pdb, tiMatch, TAG_OS_SKU);
        if (tiOSSKU != TAGID_NULL) {

            dwOSSKU = SdbReadDWORDTag(pdb, tiOSSKU, OS_SKU_ALL);

            if (dwOSSKU != OS_SKU_ALL) {

                PSDBCONTEXT pDBContext = (PSDBCONTEXT)hSDB;

                //
                // Check for the OS SKU match
                //
                if (!(dwOSSKU & pDBContext->dwOSSKU)) {
                    DBGPRINT((sdlInfo,
                              "SdbpCheckExe",
                              "MSI OS SKU Mismatch %s Database(0x%lx) vs 0x%lx\n",
                              (pszGuid ? pszGuid : TEXT("Unknown")),
                              dwOSSKU,
                              pDBContext->dwOSSKU));
                    goto CheckNextMatch;
                }
            }
        }

        break; // if we are here -- both sku and platform match


    CheckNextMatch:


        tiMatch = SdbFindNextGUIDIndexedTag(pdb, &pFindInfo->sdbFindInfo);
    }

#ifndef WIN32A_MODE

    FREE_GUID_STRING(&ustrGUID);

#endif // WIN32A_MODE

    return tiMatch;
}


TAGREF
SDBAPI
SdbpFindFirstMsiMatch(
    IN  HSDB            hSDB,
    IN LPCTSTR          lpszLocalDB,
    OUT PSDBMSIFINDINFO pFindInfo
    )
/*++
    Return: TAGREF of a matching MSI transform in whatever database we have found to be valid
            the state of the search is updated (pFindInfo->sdbLookupState) or TAGREF_NULL if
            there were no matches in any of the remaining databases

    Desc:   When this function is called first, the state is set to LOOKUP_NONE - the local
            db is up for lookup first, followed by arbitrary number of other lookup states.
--*/
{
    TAGREF trMatch = TAGREF_NULL;
    TAGID  tiMatch = TAGID_NULL;
    PDB    pdb;

    do {
        //
        // If we have a database to look into first, use it, otherwise grab the
        // next database from the list of things we use.
        //
        pdb = SdbpGetNextMsiDatabase(hSDB, lpszLocalDB, pFindInfo);

        //
        // There is no database for us to look at - get out
        //
        if (pdb == NULL) {
            //
            // All options are out -- get out now
            //
            break;
        }

        tiMatch = SdbFindFirstGUIDIndexedTag(pdb,
                                             TAG_MSI_PACKAGE,
                                             TAG_MSI_PACKAGE_ID,
                                             &pFindInfo->guidID,
                                             &pFindInfo->sdbFindInfo);
        //
        // Skip entries that do not match our runtime platform
        //
        tiMatch = SdbpFindPlatformMatch(hSDB, pdb, tiMatch, pFindInfo);

    } while (tiMatch == TAGID_NULL);

    if (tiMatch != TAGID_NULL) {
        //
        // We have a match if we are here, state information is stored in pFindInfo with
        // sdbLookupState containing the NEXT search state for us to feast on.
        //
        if (!SdbTagIDToTagRef(hSDB, pdb, tiMatch, &trMatch)) {
            DBGPRINT((sdlError,
                      "SdbpFindFirstMsiMatch",
                      "Failed to convert tagid 0x%x to tagref\n",
                      tiMatch));
            return TAGREF_NULL;
        }
    }

    return trMatch;
}

TAGREF
SDBAPI
SdbpFindNextMsiMatch(
    IN  HSDB            hSDB,
    IN  PDB             pdb,
    OUT PSDBMSIFINDINFO pFindInfo
    )
{
    TAGREF trMatch = TAGREF_NULL;
    TAGID  tiMatch = TAGID_NULL;

    tiMatch = SdbFindNextGUIDIndexedTag(pdb, &pFindInfo->sdbFindInfo);

    if (tiMatch == TAGID_NULL) {
        return TAGREF_NULL;
    }

    tiMatch = SdbpFindPlatformMatch(hSDB, pdb, tiMatch, pFindInfo);

    if (tiMatch == TAGID_NULL) {
        return TAGREF_NULL;
    }

    if (!SdbTagIDToTagRef(hSDB, pdb, tiMatch, &trMatch)) {
        DBGPRINT((sdlError,
                  "SdbpFindFirstMsiMatch",
                  "Failed to convert tagid 0x%x to tagref\n",
                  tiMatch));
        return TAGREF_NULL;
    }

    return trMatch;
}


TAGREF
SDBAPI
SdbFindFirstMsiPackage_Str(
    IN  HSDB            hSDB,
    IN  LPCTSTR         lpszGuid,
    IN  LPCTSTR         lpszLocalDB,
    OUT PSDBMSIFINDINFO pFindInfo
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    GUID guidID;

    if (!SdbGUIDFromString(lpszGuid, &guidID)) {
        DBGPRINT((sdlError,
                  "SdbFindFirstMsiPackage_Str",
                  "Failed to convert guid from string %s\n",
                  lpszGuid));

        return TAGREF_NULL;
    }

    return SdbFindFirstMsiPackage(hSDB, &guidID, lpszLocalDB, pFindInfo);
}

//
// The workings of MSI database search:
//
// 1. Function SdbpGetNextMsiDatabase returns the database corresponding to the
//    state stored in sdbLookupState
// 2. Only non-null values are returned and the state is advanced to the next
//    valid value. For instance, if we were not able to open a local (supplied) database
//    we try main database - if that was a no-show, we try test db, if that is not available,
//    we try custom dbs
// 3. When function returns NULL - it means that no more dbs are available for lookup


PDB
SdbpGetNextMsiDatabase(
    IN HSDB                hSDB,
    IN LPCTSTR             lpszLocalDB,
    IN OUT PSDBMSIFINDINFO pFindInfo
    )
/*++

    Func: SdbpGetNextMsiDatabase
          Returns the next database to be looked at
          or NULL if no more databases are availalble
          Uses pFindInfo->sdbLookupState and updates it upon exit
--*/
{
    PSDBCONTEXT         pContext = (PSDBCONTEXT)hSDB;
    PDB                 pdbRet;
    LPTSTR              pszGuid;
    SDBMSILOOKUPSTATE   LookupState = LOOKUP_DONE;
#ifndef WIN32A_MODE
    UNICODE_STRING      ustrGUID = { 0 };
    NTSTATUS            Status;
#else
    TCHAR               szGUID[64]; // guid is about 38 chars + 0
#endif

    do {
        pdbRet = NULL;

        switch (pFindInfo->sdbLookupState) {

        case LOOKUP_DONE: // no next state
            break;

        case LOOKUP_NONE: // initial state, start with local db
            LookupState = LOOKUP_LOCAL;
            break;

        case LOOKUP_LOCAL:
            SdbCloseLocalDatabase(hSDB);

            if (lpszLocalDB != NULL) {

                if (!SdbOpenLocalDatabase(hSDB, lpszLocalDB)) {
                    DBGPRINT((sdlWarning,
                              "SdbpGetNextMsiDatabase",
                              "Cannot open database \"%s\"\n",
                              lpszLocalDB));
                } else {
                    pdbRet = pContext->pdbLocal;
                }
            }

            LookupState = LOOKUP_CUSTOM;
            break;

        case LOOKUP_CUSTOM:

#ifndef WIN32A_MODE
            Status = GUID_TO_UNICODE_STRING(&pFindInfo->guidID, &ustrGUID);

            if (!NT_SUCCESS(Status)) {
                DBGPRINT((sdlError,
                          "SdbGetNextMsiDatabase",
                          "Failed to convert guid to string, status 0x%lx\n",
                          Status));
                break;
            }

            pszGuid = ustrGUID.Buffer;
#else
            GUID_TO_STRING(&pFindInfo->guidID, szGUID);
            pszGuid = szGUID;
#endif
            SdbCloseLocalDatabase(hSDB);

            if (SdbOpenNthLocalDatabase(hSDB, pszGuid, &pFindInfo->dwCustomIndex, FALSE)) {

                pdbRet = pContext->pdbLocal;

                //
                // The state does not change when we have a match
                //
                assert(pdbRet != NULL);

            } else {
                LookupState = LOOKUP_TEST;
            }

            break;

        case LOOKUP_TEST:
            pdbRet = pContext->pdbTest;

            //
            // Next one is custom
            //
            LookupState = LOOKUP_MAIN;
            break;

        case LOOKUP_MAIN:
            pdbRet = pContext->pdbMain;
            LookupState = LOOKUP_DONE;
            break;

        default:
            DBGPRINT((sdlError,
                      "SdbGetNextMsiDatabase",
                      "Unknown MSI Lookup State 0x%lx\n",
                      pFindInfo->sdbLookupState));
            LookupState = LOOKUP_DONE;
            break;
        }

        pFindInfo->sdbLookupState = LookupState;

    } while (pdbRet == NULL && pFindInfo->sdbLookupState != LOOKUP_DONE);

#ifndef WIN32A_MODE
    FREE_GUID_STRING(&ustrGUID);
#endif

    return pdbRet;
}


TAGREF
SDBAPI
SdbFindFirstMsiPackage(
    IN  HSDB            hSDB,           // HSDB context
    IN  GUID*           pGuidID,        // GUID that we're looking for
    IN  LPCTSTR         lpszLocalDB,    // optional path to local db, dos path style
    OUT PSDBMSIFINDINFO pFindInfo       // pointer to our search context
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    PSDBCONTEXT pContext = (PSDBCONTEXT)hSDB;
    LPTSTR      pszGuid;

    //
    // Initialize MSI search structure
    //
    RtlZeroMemory(pFindInfo, sizeof(*pFindInfo));

    pFindInfo->guidID = *pGuidID; // store the guid ptr in the context
    pFindInfo->sdbLookupState = LOOKUP_NONE;

    pFindInfo->trMatch = SdbpFindFirstMsiMatch(hSDB, lpszLocalDB, pFindInfo);

    return pFindInfo->trMatch;
}


TAGREF
SDBAPI
SdbFindNextMsiPackage(
    IN     HSDB            hSDB,
    IN OUT PSDBMSIFINDINFO pFindInfo
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{

    PDB    pdb = NULL;
    TAGID  tiMatch;
    TAGREF trMatch = TAGREF_NULL;

    assert(hSDB != NULL && pFindInfo != NULL);

    if (pFindInfo->trMatch == TAGREF_NULL) {
        DBGPRINT((sdlError, "SdbFindNextMsiPackage", "No more matches\n"));
        return trMatch;
    }

    //
    // Take the last match and look in the same database
    //
    if (!SdbTagRefToTagID(hSDB, pFindInfo->trMatch, &pdb, &tiMatch)) {
        DBGPRINT((sdlError,
                  "SdbFindNextMsiPackage",
                  "Failed to convert tagref 0x%x to tagid\n",
                  pFindInfo->trMatch));
        return trMatch;
    }

    //
    // Call to find the next match in this (current) database
    //
    trMatch = SdbpFindNextMsiMatch(hSDB, pdb, pFindInfo);

    if (trMatch != TAGREF_NULL) {
        pFindInfo->trMatch = trMatch;
        return trMatch;
    }

    //
    // So in this (current) database we have no further matches, look for the first match
    // in the next db
    //
    trMatch = SdbpFindFirstMsiMatch(hSDB, NULL, pFindInfo);

    //
    // We have found a match -- or not, store supplemental information and return.
    //
    pFindInfo->trMatch = trMatch;

    return trMatch;
}


DWORD
SDBAPI
SdbEnumMsiTransforms(
    IN     HSDB    hSDB,
    IN     TAGREF  trMatch,
    OUT    TAGREF* ptrBuffer,
    IN OUT DWORD*  pdwBufferSize
    )
/*++
    Return: BUGBUG: ?

    Desc:   Enumerate fixes for a given MSI package.
--*/
{
    TAGID tiMatch = TAGID_NULL;
    TAGID tiTransform;
    DWORD nTransforms = 0;
    DWORD dwError = ERROR_SUCCESS;
    PDB   pdb;

    //
    // Get a list of transforms available for this entry
    //
    if (!SdbTagRefToTagID(hSDB, trMatch, &pdb, &tiMatch)) {
        DBGPRINT((sdlError,
                  "SdbEnumerateMsiTransforms",
                  "Failed to convert tagref 0x%x to tagid\n",
                  trMatch));
        return ERROR_INTERNAL_DB_CORRUPTION;
    }

    if (ptrBuffer == NULL) {
        //
        // We should have the pdwBufferSize not NULL in this case.
        //
        if (pdwBufferSize == NULL) {
            DBGPRINT((sdlError,
                      "SdbEnumerateMsiTransforms",
                      "when ptrBuffer is not specified, pdwBufferSize should not be NULL\n"));
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // Now start enumerating transforms. Count them first.
    //
    if (pdwBufferSize != NULL) {
        tiTransform = SdbFindFirstTag(pdb, tiMatch, TAG_MSI_TRANSFORM_REF);

        while (tiTransform != TAGID_NULL) {
            nTransforms++;

            tiTransform = SdbFindNextTag(pdb, tiMatch, tiTransform);
        }

        //
        // Both buffer size and buffer specified, see if we fit in.
        //
        if (ptrBuffer == NULL || *pdwBufferSize < nTransforms * sizeof(TAGREF)) {
            *pdwBufferSize = nTransforms * sizeof(TAGREF);
            DBGPRINT((sdlInfo,
                      "SdbEnumerateMsiTransforms",
                      "Buffer specified is too small\n"));
            return ERROR_INSUFFICIENT_BUFFER;
        }
    }

    //
    // Now we have counted them all and either the buffer size is not supplied
    // or it has enough room, do it again now
    // The only case when we are here is ptrBuffer != NULL
    //

    assert(ptrBuffer != NULL);

    __try {

        tiTransform = SdbFindFirstTag(pdb, tiMatch, TAG_MSI_TRANSFORM_REF);

        while (tiTransform != TAGID_NULL) {

            if (!SdbTagIDToTagRef(hSDB, pdb, tiTransform, ptrBuffer)) {

                DBGPRINT((sdlError,
                          "SdbEnumerateMsiTransforms",
                          "Failed to convert tagid 0x%x to tagref\n",
                          tiTransform));

                return ERROR_INTERNAL_DB_CORRUPTION;
            }

            //
            // Advance the pointer
            //
            ++ptrBuffer;

            //
            // Lookup next transform
            //

            tiTransform = SdbFindNextTag(pdb, tiMatch, tiTransform);
        }

        if (pdwBufferSize != NULL) {
            *pdwBufferSize = nTransforms * sizeof(TAGREF);
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = ERROR_INVALID_DATA;
    }

    return dwError;
}


BOOL
SDBAPI
SdbReadMsiTransformInfo(
    IN  HSDB                 hSDB,
    IN  TAGREF               trTransformRef,
    OUT PSDBMSITRANSFORMINFO pTransformInfo
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    TAGID  tiTransformRef = TAGID_NULL;
    TAGID  tiName         = TAGID_NULL;
    TAGID  tiFile         = TAGID_NULL;
    PDB    pdb            = NULL;
    TAGREF trTransform    = TAGREF_NULL;
    TAGREF trFileTag      = TAGREF_NULL;
    TAGREF trFile         = TAGREF_NULL;
    TAGREF trFileName     = TAGREF_NULL;
    DWORD  dwLength;
    LPTSTR pszFileName    = NULL;

    RtlZeroMemory(pTransformInfo, sizeof(*pTransformInfo));

    if (!SdbTagRefToTagID(hSDB, trTransformRef, &pdb, &tiTransformRef)) {
        DBGPRINT((sdlError,
                  "SdbReadMsiTransformInfo",
                  "Failed to convert tagref 0x%lx to tagid\n",
                  trTransformRef));
        return FALSE;
    }

    if (SdbGetTagFromTagID(pdb, tiTransformRef) != TAG_MSI_TRANSFORM_REF) {
        DBGPRINT((sdlError,
                  "SdbReadMsiTransformInfo",
                  "Bad Transform reference 0x%lx\n",
                  trTransformRef));
        return FALSE;
    }

    //
    // First find the name.
    //
    tiName = SdbFindFirstTag(pdb, tiTransformRef, TAG_NAME);
    if (tiName) {
        pTransformInfo->lpszTransformName = SdbGetStringTagPtr(pdb, tiName);
    }

    //
    // Then locate the transform itself.
    //
    trTransform = SdbGetItemFromItemRef(hSDB,
                                        trTransformRef,
                                        TAG_NAME,
                                        TAG_MSI_TRANSFORM_TAGID,
                                        TAG_MSI_TRANSFORM);

    if (trTransform == TAGREF_NULL) {
        //
        // We can't do it, return TRUE however.
        // Reason: Caller will have the name of the transform
        //         and should know what to do.
        //
        return TRUE;
    }

    pTransformInfo->trTransform = trTransform;

    //
    // Now that we have the transform entry get the description and the bits.
    //
    trFileTag = SdbFindFirstTagRef(hSDB, trTransform, TAG_MSI_TRANSFORM_TAGID);

    if (trFileTag != TAGREF_NULL) {

        //
        // Read the reference to an actual file within this db
        //
        tiFile = SdbReadDWORDTagRef(hSDB, trFileTag, (DWORD)TAGID_NULL);

        //
        // If we attained the tiFile - note that it is an id within
        // the current database, so make a trFile out of it.
        //
        if (tiFile) {
            if (!SdbTagIDToTagRef(hSDB, pdb, tiFile, &trFile)) {
                DBGPRINT((sdlError,
                          "SdbReadMsiTransformInfo",
                          "Failed to convert File tag to tagref 0x%lx\n",
                          tiFile));
                trFile = TAGREF_NULL;
            }
        }
    }

    if (trFile == TAGREF_NULL) {
        //
        // We wil have to look by (file) name.
        //
        trFileName = SdbFindFirstTagRef(hSDB, trTransform, TAG_MSI_TRANSFORM_FILE);

        if (trFileName == TAGREF_NULL) {
            DBGPRINT((sdlError,
                      "SdbReadMsiTransformInfo",
                      "Failed to get MSI Transform for tag 0x%x\n",
                      trTransform));
            return FALSE;
        }

        dwLength = SdbpGetStringRefLength(hSDB, trFileName);

        STACK_ALLOC(pszFileName, (dwLength + 1) * sizeof(TCHAR));

        if (pszFileName == NULL) {
            DBGPRINT((sdlError,
                      "SdbReadMsiTransformInfo",
                      "Failed to allocate buffer for %ld characters tag 0x%lx\n",
                      dwLength,
                      trFileName));
            return FALSE;
        }

        //
        // Now read the filename.
        //
        if (!SdbReadStringTagRef(hSDB, trFileName, pszFileName, dwLength + 1)) {
            DBGPRINT((sdlError,
                      "SdbReadMsiTransformInfo",
                      "Failed to read filename string tag, length %d characters, tag 0x%x\n",
                      dwLength,
                      trFileName));
            STACK_FREE(pszFileName);
            return FALSE;
        }

        //
        // Locate the transform in the library (of the current file first, if
        // not found -- in the main db then).
        //
        trFile = SdbpGetLibraryFile(pdb, pszFileName);

        if (trFile == TAGREF_NULL) {
            trFile = SdbpGetMainLibraryFile(hSDB, pszFileName);
        }

        STACK_FREE(pszFileName);
    }

    pTransformInfo->trFile = trFile;

    return TRUE;
}

BOOL
SDBAPI
SdbCreateMsiTransformFile(
    IN  HSDB                 hSDB,
    IN  LPCTSTR              lpszFileName,
    OUT PSDBMSITRANSFORMINFO pTransformInfo
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    TAGREF trBits;
    DWORD  dwSize;
    PBYTE  pBuffer  = NULL;
    BOOL   bSuccess = FALSE;

    if (pTransformInfo->trFile == TAGREF_NULL) {

        DBGPRINT((sdlError,
                  "SdbCreateMsiTransformFile",
                  "File for transform \"%s\" was not found\n",
                  pTransformInfo->lpszTransformName));
        goto out;
    }

    trBits = SdbFindFirstTagRef(hSDB, pTransformInfo->trFile, TAG_FILE_BITS);

    if (trBits == TAGREF_NULL) {

        DBGPRINT((sdlError,
                  "SdbCreateMsiTransformFile",
                  "File bits not found tag 0x%x\n",
                  trBits));
        goto out;
    }

    dwSize = SdbpGetTagRefDataSize(hSDB, trBits);

    pBuffer = (PBYTE)SdbAlloc(dwSize);

    if (pBuffer == NULL) {
        DBGPRINT((sdlError,
                  "SdbCreateMsiTransformFile",
                  "Failed to allocate %d bytes.\n",
                  dwSize));
        goto out;
    }

    //
    // Now read the DLL's bits.
    //
    if (!SdbpReadBinaryTagRef(hSDB, trBits, pBuffer, dwSize)) {
        DBGPRINT((sdlError,
                  "SdbCreateMsiTransformFile",
                  "Can't read transform bits.\n"));
        goto out;
    }

    if (!SdbpWriteBitsToFile(lpszFileName, pBuffer, dwSize)) {
        DBGPRINT((sdlError,
                  "SdbCreateMsiTransformFile",
                  "Can't write transform bits to disk.\n"));
        goto out;
    }

    bSuccess = TRUE;

out:
    if (pBuffer != NULL) {
        SdbFree(pBuffer);
    }

    return bSuccess;
}

BOOL
SDBAPI
SdbGetMsiPackageInformation(
    IN  HSDB            hSDB,
    IN  TAGREF          trMatch,
    OUT PMSIPACKAGEINFO pPackageInfo
    )
{
    PDB   pdb = NULL;
    TAGID tiMatch;
    TAGID tiPackageID;
    TAGID tiExeID;
    TAGID tiApphelp;
    TAGID tiCustomAction;
    BOOL  bSuccess;

    RtlZeroMemory(pPackageInfo, sizeof(*pPackageInfo));

    if (!SdbTagRefToTagID(hSDB, trMatch, &pdb, &tiMatch)) {

        DBGPRINT((sdlError,
                  "SdbGetMsiPackageInformation",
                  "Failed to convert tagref 0x%lx to tagid\n",
                  trMatch));

        return FALSE;
    }

    //
    // Fill in important id's
    //
    if (!SdbGetDatabaseID(pdb, &pPackageInfo->guidDatabaseID)) {

        DBGPRINT((sdlError,
                  "SdbGetMsiPackageInformation",
                  "Failed to get database id, tagref 0x%lx\n",
                  trMatch));

        return FALSE;
    }


    //
    // Retrieve match id (unique one)
    //
    tiPackageID = SdbFindFirstTag(pdb, tiMatch, TAG_MSI_PACKAGE_ID);

    if (tiPackageID == TAGID_NULL) {

        DBGPRINT((sdlError,
                  "SdbGetMsiPackageInformation",
                  "Failed to get msi package id, tagref = 0x%lx\n",
                  trMatch));

        return FALSE;
    }

    bSuccess = SdbReadBinaryTag(pdb,
                                tiPackageID,
                                (PBYTE)&pPackageInfo->guidMsiPackageID,
                                sizeof(pPackageInfo->guidMsiPackageID));
    if (!bSuccess) {
        DBGPRINT((sdlError,
                  "SdbGetMsiPackageInformation",
                  "Failed to read MSI Package ID referenced by 0x%x\n",
                  trMatch));
        return FALSE;
    }

    tiExeID = SdbFindFirstTag(pdb, tiMatch, TAG_EXE_ID);

    if (tiExeID == TAGID_NULL) {

        DBGPRINT((sdlError,
                  "SdbGetMsiPackageInformation",
                  "Failed to read TAG_EXE_ID for tagref 0x%x\n",
                  trMatch));

        return FALSE;
    }

    bSuccess = SdbReadBinaryTag(pdb,
                                tiExeID,
                                (PBYTE)&pPackageInfo->guidID,
                                sizeof(pPackageInfo->guidID));
    if (!bSuccess) {

        DBGPRINT((sdlError,
                  "SdbGetMsiPackageInformation",
                  "Failed to read EXE ID referenced by tagref 0x%x\n",
                  trMatch));

        return FALSE;
    }

    //
    // Set the flags to indicate whether apphelp or shims are available for
    // this package
    // note that shims/layers might be set for the subordinate actions and not
    // for the package itself. If custom_action tag exists however -- we need to check
    // with the full api later.
    //
    tiApphelp = SdbFindFirstTag(pdb, tiMatch, TAG_APPHELP);

    if (tiApphelp != TAGID_NULL) {
        pPackageInfo->dwPackageFlags |= MSI_PACKAGE_HAS_APPHELP;
    }

    //
    // Check to see whether we have any shims/layers
    //
    tiCustomAction = SdbFindFirstTag(pdb, tiMatch, TAG_MSI_CUSTOM_ACTION);

    if (tiCustomAction != TAGID_NULL) {
        pPackageInfo->dwPackageFlags |= MSI_PACKAGE_HAS_SHIMS;
    }

    return TRUE;

}

TAGREF
SDBAPI
SdbFindMsiPackageByID(
    IN HSDB  hSDB,
    IN GUID* pguidID
    )
{
    TAGID       tiMatch;
    PSDBCONTEXT pContext = (PSDBCONTEXT)hSDB;
    FIND_INFO   FindInfo;
    TAGREF      trMatch = TAGREF_NULL;

    //
    // We search only the LOCAL database in this case
    //
    tiMatch = SdbFindFirstGUIDIndexedTag(pContext->pdbLocal,
                                         TAG_MSI_PACKAGE,
                                         TAG_EXE_ID,
                                         pguidID,
                                         &FindInfo);
    if (tiMatch == TAGID_NULL) {
        return trMatch;
    }

    if (!SdbTagIDToTagRef(hSDB, pContext->pdbLocal, tiMatch, &trMatch)) {
        DBGPRINT((sdlError,
                  "SdbFindMsiPackageByID",
                  "Failed to convert tagid 0x%lx to tagref\n",
                  tiMatch));
    }

    return trMatch;
}

TAGREF
SDBAPI
SdbFindCustomActionForPackage(
    IN HSDB     hSDB,
    IN TAGREF   trPackage,
    IN LPCTSTR  lpszCustomAction
    )
{
    PDB    pdb = NULL;
    TAGID  tiMatch  = TAGID_NULL;
    TAGREF trReturn = TAGREF_NULL;
    TAGID  tiCustomAction;

    if (!SdbTagRefToTagID(hSDB, trPackage, &pdb, &tiMatch)) {

         DBGPRINT((sdlError,
                  "SdbFindCustomActionForPackage",
                  "Failed to convert tagref 0x%lx to tagid\n",
                  trPackage));

         return TAGREF_NULL;
    }

    //
    // Now, for this tiMatch look for a custom action
    //
    tiCustomAction = SdbFindFirstNamedTag(pdb,
                                          tiMatch,
                                          TAG_MSI_CUSTOM_ACTION,
                                          TAG_NAME,
                                          lpszCustomAction);

    if (tiCustomAction != TAGID_NULL) {
        if (!SdbTagIDToTagRef(hSDB, pdb, tiCustomAction, &trReturn)) {

            DBGPRINT((sdlError,
                      "SdbFindCustomActionForPackage",
                      "Failed to convert tagid 0x%lx to tagref\n",
                      tiCustomAction));

            trReturn = TAGREF_NULL;
        }
    }

    return trReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\dbaccessplus.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        dbaccessplus.c

    Abstract:

        This module implements APIs to access the shim database.

    Author:

        clupu     created     sometime in 2001

    Revision History:

        several people contributed (vadimb, dmunsil, ...)

--*/

#include "sdbp.h"

//
// This file is not included for KERNEL_MODE
//

//
// SdbInitDatabase is not used in Kernel mode. SdbInitDatabaseInMemory is used instead
//

HSDB
SdbInitDatabase(
    IN  DWORD   dwFlags,        // flags that tell how the database should be
                                // initialized.
    IN  LPCTSTR pszDatabasePath // the OPTIONAL full path to the database to be used.
    )
/*++
    Return: A handle to the database.

    Desc:   This is the first API someone needs to call to initiate comunication
            with the database. Should be paired with a call to SdbReleaseDatabase
            when finished.

            HID_DATABASE_FULLPATH indicates that pszDatabasePath points to the full path of the
                                  main database, when this flag is not present and pszDatabasePath
                                  is not NULL we treat it as the directory where sysmain.sdb and
                                  systest.sdb are to be found

            HID_DOS_PATHS         indicates the format of the pszDatabasePath: when this flag is
                                  present, we treat it as being in dos c:\blah\blah format, when
                                  it's not present - we treat pszDatabasePath as being in nt format
                                  e.g. "\SystemRoot\Apppatch"

            HID_NO_DATABASE       indicates that no database will be open at this time
                                  (pszDatabasePath is simply ignored, along with all
                                  the other flags)

            In addition to the flags above you can specify the type of the database that needs to be
            opened via the SDB_DATABASE_MAIN_* flags such as:
            SDB_DATABASE_MAIN_SHIM    - sysmain.sdb
            SDB_DATABASE_MAIN_MSI     - msimain.sdb
            SDB_DATABASE_MAIN_DRIVERS - drvmain.sdb
            This feature is not present on downlevel platforms.
            When any of the database type flags are provided, pszDatabasePath should be set to NULL

--*/
{
    TCHAR       wszWinDir[MAX_PATH] = TEXT("");
    TCHAR       wszShimDB[MAX_PATH] = TEXT("");
    BOOL        bReturn = FALSE;
    PSDBCONTEXT pContext;
    DWORD       dwFlagOpen = 0;

    //
    // Allocate the HSDB handle.
    //
    pContext = (PSDBCONTEXT)SdbAlloc(sizeof(SDBCONTEXT));

    if (pContext == NULL) {
        DBGPRINT((sdlError, "SdbInitDatabase", "Failed to allocate %d bytes for HSDB\n",
                 sizeof(SDBCONTEXT)));
        return NULL;
    }

    //
    // See if we need to open db...
    //
    if (dwFlags & HID_NO_DATABASE) {
        DBGPRINT((sdlInfo, "SdbInitDatabase", "No database is open\n"));
        goto InitDone;
    }

    //
    // Determine which flag to use with the OPEN call
    //
    dwFlagOpen = (dwFlags & HID_DOS_PATHS) ? DOS_PATH : NT_PATH;

    //
    // Open the main database and do this under a try/except so we don't screw
    // our caller if the database is corrupt.
    //
    __try {

        if (dwFlags & HID_DATABASE_FULLPATH) {
            // we better have the ptr
            if (pszDatabasePath == NULL) {
                DBGPRINT((sdlError, "SdbInitDatabase",
                          "Database not specified with the database path flag\n"));
                goto errHandle;
            }

            _tcscpy(wszShimDB, pszDatabasePath);

        } else {
            //
            // we do not have a database path
            // see if we have a database type to open as a "main" db
            //

#ifndef WIN32A_MODE
            //
            // This code works only on UNICODE
            //
            if (dwFlags & HID_DATABASE_TYPE_MASK) {

                DWORD dwDatabaseType = dwFlags;
                DWORD dwLen;

                dwLen = SdbpGetStandardDatabasePath(dwDatabaseType,
                                                    dwFlags,
                                                    wszShimDB,
                                                    CHARCOUNT(wszShimDB));
                if (dwLen > CHARCOUNT(wszShimDB)) {
                    DBGPRINT((sdlError,
                              "SdbInitDatabase",
                              "Cannot get standard database path\n"));
                    goto errHandle;
                }

            } else

#endif // WIN32A_MODE
            {
                if (pszDatabasePath != NULL) {
                    int nLen;

                    _tcscpy(wszShimDB, pszDatabasePath);
                    nLen = _tcslen(wszShimDB);
                    if (nLen > 0 && TEXT('\\') == wszShimDB[nLen-1]) {
                        wszShimDB[nLen-1] = TEXT('\0');
                    }
                } else {  // standard database path

                    if (dwFlags & HID_DOS_PATHS) {
                        SdbpGetAppPatchDir(wszShimDB);
                    } else {
                        _tcscpy(wszShimDB, TEXT("\\SystemRoot\\AppPatch"));
                    }
                }

                _tcscat(wszShimDB, TEXT("\\sysmain.sdb"));
            }
        }

        pContext->pdbMain = SdbOpenDatabase(wszShimDB, dwFlagOpen);

    } __except(SHIM_EXCEPT_HANDLER) {
        pContext->pdbMain = NULL;
    }

    if (pContext->pdbMain == NULL) {
        DBGPRINT((sdlError, "SdbInitDatabase", "Unable to open main database sysmain.sdb.\n"));
        goto errHandle;
    }

    if (dwFlags & HID_DATABASE_FULLPATH) {
        // we are done, no test db
        goto InitDone;
    }

    //
    // Now try to open the systest.sdb if it exists.
    //
    __try {

        if (NULL != pszDatabasePath) {

            int nLen;

            _tcscpy(wszShimDB, pszDatabasePath);

            nLen = _tcslen(wszShimDB);

            if (nLen > 0 && TEXT('\\') == wszShimDB[nLen-1]) {
                wszShimDB[nLen-1] = TEXT('\0');
            }

        } else {  // standard database path

            if (dwFlags & HID_DOS_PATHS) {
                SdbpGetAppPatchDir(wszShimDB);
            } else {
                _tcscpy(wszShimDB, TEXT("\\SystemRoot\\AppPatch"));
            }
        }

        _tcscat(wszShimDB, TEXT("\\systest.sdb"));

        pContext->pdbTest = SdbOpenDatabase(wszShimDB, dwFlagOpen);

    } __except(SHIM_EXCEPT_HANDLER) {
        pContext->pdbTest = NULL;
    }

    if (pContext->pdbTest == NULL) {
        DBGPRINT((sdlInfo, "SdbInitDatabase", "No systest.sdb found.\n"));
    }

InitDone:

    //
    // Initialize new members (local db support)
    //
    if (pContext->pdbMain) {

        pContext->rgSDB[0].pdb     = pContext->pdbMain;
        pContext->rgSDB[0].dwFlags = SDBENTRY_VALID_ENTRY|SDBENTRY_VALID_GUID;

        RtlCopyMemory(&pContext->rgSDB[0].guidDB, &GUID_SYSMAIN_SDB, sizeof(GUID));

        SDBCUSTOM_SET_MASK(pContext, SDB_MASK_TO_INDEX(PDB_MAIN));
    }

    if (pContext->pdbTest) {

        pContext->rgSDB[1].pdb     = pContext->pdbTest;
        pContext->rgSDB[1].dwFlags = SDBENTRY_VALID_ENTRY|SDBENTRY_VALID_GUID;

        RtlCopyMemory(&pContext->rgSDB[1].guidDB, &GUID_SYSTEST_SDB, sizeof(GUID));

        SDBCUSTOM_SET_MASK(pContext, SDB_MASK_TO_INDEX(PDB_TEST));
    }

    //
    // Initialize architecture
    //
    pContext->dwRuntimePlatform = SdbpGetProcessorArchitecture();

    //
    // Initialize OS SKU and SP
    //
    SdbpGetOSSKU(&pContext->dwOSSKU, &pContext->dwSPMask);

#ifndef WIN32A_MODE

    //
    // Finally, initialize the pipe
    //
    pContext->hPipe = SdbpOpenDebugPipe();

#endif // WIN32A_MODE

    return (HSDB)pContext;

errHandle:

    //
    // Cleanup on failure.
    //
    if (pContext != NULL) {
        if (pContext->pdbMain != NULL) {
            SdbCloseDatabaseRead(pContext->pdbMain);
        }

        if (pContext->pdbTest != NULL) {
            SdbCloseDatabaseRead(pContext->pdbTest);
        }

        SdbFree(pContext);
    }

    return NULL;
}

BOOL
SdbpOpenAndMapFile(
    IN  LPCTSTR        szPath,          // Filename
    OUT PIMAGEFILEDATA pImageData,      // pointer to the structure to be filled
    IN  PATH_TYPE      ePathType        // path type, only DOS_PATH is supported on win32
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Opens a file and maps it into memory.
--*/
{
    HANDLE hFile;
    DWORD  dwFlags = 0;

    if (pImageData->dwFlags & IMAGEFILEDATA_PBASEVALID) {
        //
        // special case, only headers are valid in our assumption
        //
        return TRUE;
    }

    if (pImageData->dwFlags & IMAGEFILEDATA_HANDLEVALID) {
        hFile = pImageData->hFile;
        dwFlags |= IMAGEFILEDATA_NOFILECLOSE;
    } else {
        hFile = SdbpOpenFile(szPath, ePathType);
    }

    if (hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (!SdbpMapFile(hFile, pImageData)) {
        if (!(dwFlags & IMAGEFILEDATA_NOFILECLOSE)) {
            SdbpCloseFile(hFile);
        }
        return FALSE;
    }

    pImageData->dwFlags = dwFlags;

    return TRUE;
}

BOOL
SdbpUnmapAndCloseFile(
    IN  PIMAGEFILEDATA pImageData
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    HANDLE hFile;
    BOOL   bSuccess;

    if (pImageData->dwFlags & IMAGEFILEDATA_PBASEVALID) { // externally supplied pointer
        RtlZeroMemory(pImageData, sizeof(*pImageData));
        return TRUE;
    }

    hFile = pImageData->hFile;

    bSuccess = SdbpUnmapFile(pImageData);

    if (hFile != INVALID_HANDLE_VALUE) {
        if (pImageData->dwFlags & IMAGEFILEDATA_NOFILECLOSE)  {
            pImageData->hFile = INVALID_HANDLE_VALUE;
        } else {
            SdbpCloseFile(hFile);
        }
    }

    return bSuccess;
}


BOOL
SdbpCleanupLocalDatabaseSupport(
    IN HSDB hSDB
    )
{
    PSDBCONTEXT pSdbContext = (PSDBCONTEXT)hSDB;
    DWORD       dwIndex;
    DWORD       dwMask;

    //
    // Ee start with entry 2 -- to include local sdbs
    //
    if (pSdbContext->dwDatabaseMask & SDB_CUSTOM_MASK) {

        for (dwIndex = 3; dwIndex < ARRAYSIZE(pSdbContext->rgSDB); ++dwIndex) {
            dwMask = 1 << dwIndex;
            if (pSdbContext->dwDatabaseMask & dwMask) {
                SdbCloseLocalDatabaseEx(hSDB, NULL, dwIndex);
            }
        }
    }

    //
    // Always check for entry 2 (local sdb)
    //
    if (pSdbContext->pdbLocal != NULL) {
        SdbCloseLocalDatabaseEx(hSDB, NULL, SDB_MASK_TO_INDEX(PDB_LOCAL));
    }

    return TRUE;
}


BOOL
SdbpIsLocalTempPDB(
    IN HSDB hSDB,
    IN PDB  pdb
    )
{
    PSDBENTRY pEntry = SDBGETLOCALENTRY(hSDB);

    if (pEntry->dwFlags & SDBENTRY_VALID_ENTRY) {
        return pdb == pEntry->pdb;
    }

    return FALSE;
}

BOOL
SdbpIsMainPDB(
    IN HSDB hSDB,
    IN PDB  pdb
    )
{
    DWORD dwIndex;

    if (!SdbpFindLocalDatabaseByPDB(hSDB, pdb, FALSE, &dwIndex)) {
        return FALSE;
    }

    return (dwIndex == SDB_MASK_TO_INDEX(PDB_MAIN) || dwIndex == SDB_MASK_TO_INDEX(PDB_TEST));
}

BOOL
SdbpFindLocalDatabaseByPDB(
    IN  HSDB    hSDB,
    IN  PDB     pdb,
    IN  BOOL    bExcludeLocalDB, // exclude local db entry?
    OUT LPDWORD pdwIndex
    )
{
    PSDBCONTEXT pSdbContext = (PSDBCONTEXT)hSDB;
    DWORD       dwIndex;
    PSDBENTRY   pEntry;
    BOOL        bSuccess = FALSE;

    for (dwIndex = 0; dwIndex < ARRAYSIZE(pSdbContext->rgSDB); ++dwIndex) {

        if (bExcludeLocalDB && dwIndex == SDB_MASK_TO_INDEX(PDB_LOCAL)) {
            continue;
        }

        if (!SDBCUSTOM_CHECK_INDEX(hSDB, dwIndex)) {
            continue;
        }

        pEntry = &pSdbContext->rgSDB[dwIndex];

        if ((pEntry->dwFlags & SDBENTRY_VALID_ENTRY) && (pdb == pEntry->pdb)) {
            bSuccess = TRUE;
            break;
        }
    }

    if (bSuccess && pdwIndex != NULL) {
        *pdwIndex = dwIndex;
    }

    return bSuccess;
}

BOOL
SdbpFindLocalDatabaseByGUID(
    IN  HSDB    hSDB,
    IN  GUID*   pGuidDB,
    IN  BOOL    bExcludeLocalDB,
    OUT LPDWORD pdwIndex // this index (if valid) will work as an initial point for comparison
    )
{
    PSDBCONTEXT pSdbContext = (PSDBCONTEXT)hSDB;
    PSDBENTRY   pEntry;
    DWORD       dwIndex;

    for (dwIndex = 0; dwIndex < ARRAYSIZE(pSdbContext->rgSDB); ++dwIndex) {

        if (bExcludeLocalDB && dwIndex == SDB_MASK_TO_INDEX(PDB_LOCAL)) {
            continue;
        }

        if (!SDBCUSTOM_CHECK_INDEX(hSDB, dwIndex)) {
            continue;
        }

        pEntry = SDBGETENTRY(hSDB, dwIndex);

        if (!(pEntry->dwFlags & SDBENTRY_VALID_GUID)) {

            //
            // if this happens to be a valid database -- get it's guid
            //
            if ((pEntry->dwFlags & SDBENTRY_VALID_ENTRY) && (pEntry->pdb != NULL)) {

                //
                // retrieve guid
                //
                GUID guidDB;

                if (SdbGetDatabaseGUID(hSDB, pEntry->pdb, &guidDB)) {
                    pEntry->guidDB = guidDB;
                    pEntry->dwFlags |= SDBENTRY_VALID_GUID;
                    goto checkEntry;
                }
            }
            continue;
        }

    checkEntry:

        if (RtlEqualMemory(&pEntry->guidDB, pGuidDB, sizeof(GUID))) {

            if (pdwIndex) {
                *pdwIndex = dwIndex;
            }

            return TRUE;
        }
    }

    return FALSE;
}

DWORD
SdbpFindFreeLocalEntry(
    IN HSDB hSDB
    )
{
    PSDBCONTEXT pSdbContext = (PSDBCONTEXT)hSDB;
    DWORD       dwIndex;

    for (dwIndex = 3; dwIndex < ARRAYSIZE(pSdbContext->rgSDB); ++dwIndex) {

        if (SDBCUSTOM_CHECK_INDEX(hSDB, dwIndex)) {
            continue;
        }

        if (!(pSdbContext->rgSDB[dwIndex].dwFlags & (SDBENTRY_VALID_ENTRY | SDBENTRY_VALID_GUID))) {
            return dwIndex;
        }
    }

    //
    // We have no entry
    //
    return SDBENTRY_INVALID_INDEX;
}

/*++
    returns SDBENTRY_INVALID_INDEX if none could be found

    if success, returns an index where the local db entry was found
--*/

DWORD
SdbpRetainLocalDBEntry(
    IN  HSDB hSDB,
    OUT PDB* ppPDB OPTIONAL // optional pointer to the pdb
    )
{
    DWORD       dwIndex     = SDBENTRY_INVALID_INDEX;
    PSDBCONTEXT pSdbContext = (PSDBCONTEXT)hSDB;
    PSDBENTRY   pEntry;
    PSDBENTRY   pEntryLocal = SDBGETLOCALENTRY(hSDB);
    GUID        guidDB;

    if (pEntryLocal->pdb == NULL || !(pEntryLocal->dwFlags & SDBENTRY_VALID_ENTRY)) {
        return SDBENTRY_INVALID_INDEX;
    }

    //
    // Recycling could be done here so that we reuse custom db entries which
    // may have been opened already (for instance set by __COMPAT_LAYER)
    //
    if (SdbGetDatabaseGUID(hSDB, pEntryLocal->pdb, &guidDB) &&
        SdbpFindLocalDatabaseByGUID(hSDB, &guidDB, TRUE, &dwIndex) &&
        dwIndex != SDBENTRY_INVALID_INDEX) {

        //
        // Close the local db
        //
        SdbCloseLocalDatabase(hSDB);

        pEntry = SDBGETENTRY(hSDB, dwIndex);

        pSdbContext->pdbLocal = pEntry->pdb;

        if (ppPDB != NULL) {
            *ppPDB = pEntry->pdb;
        }

        return dwIndex;
    }

    //
    // An attempt to recycle has failed -- allocate new entry
    //
    dwIndex = SdbpFindFreeLocalEntry(hSDB);
    if (dwIndex != SDBENTRY_INVALID_INDEX) {
        //
        // We have found an empty slot, relocate
        //
        pEntry = SDBGETENTRY(hSDB, dwIndex);

        RtlCopyMemory(pEntry, pEntryLocal, sizeof(SDBENTRY));
        RtlZeroMemory(pEntryLocal, sizeof(SDBENTRY));

        SDBCUSTOM_SET_MASK(hSDB, dwIndex);

        if (ppPDB != NULL) {
            *ppPDB = pEntry->pdb;
        }

        //
        // Note that pdbLocal is still valid, we never close this handle manually though
        //
    }

    return dwIndex;
}


BOOL
SdbCloseLocalDatabaseEx(
    IN HSDB  hSDB,
    IN PDB   pdb,
    IN DWORD dwIndex
    )
{
    PSDBCONTEXT pSdbContext = (PSDBCONTEXT)hSDB;
    PSDBENTRY   pEntry;
    DWORD       dwMask;

    if (pdb != NULL) {
        if (!SdbpFindLocalDatabaseByPDB(hSDB, pdb, FALSE, &dwIndex)) {
            return FALSE;
        }
    }

    dwMask = 1 << dwIndex;

    if (dwIndex >= ARRAYSIZE(pSdbContext->rgSDB) || !(pSdbContext->dwDatabaseMask & dwMask)) {
        return FALSE;
    }

    pEntry = &pSdbContext->rgSDB[dwIndex];
    if (pEntry->dwFlags & SDBENTRY_VALID_ENTRY) {
        if (pEntry->pdb) {
            SdbCloseDatabaseRead(pEntry->pdb);
        }
    }

    RtlZeroMemory(pEntry, sizeof(*pEntry));

    SDBCUSTOM_CLEAR_MASK(hSDB, dwIndex);

    if (dwIndex == SDB_MASK_TO_INDEX(PDB_LOCAL)) {
        pSdbContext->pdbLocal = NULL;
    }

    return TRUE;
}


BOOL
SdbOpenLocalDatabaseEx(
    IN     HSDB    hSDB,
    IN     LPCVOID pDatabaseID,
    IN     DWORD   dwFlags,
    OUT    PDB*    pPDB OPTIONAL,
    IN OUT LPDWORD pdwLocalDBMask OPTIONAL // local db mask for tagref
    )
{
    PSDBCONTEXT pSdbContext = (PSDBCONTEXT)hSDB;
    PDB         pdb;
    DWORD       dwOpenFlags = DOS_PATH;
    TCHAR       szDatabasePath[MAX_PATH];
    LPTSTR      pszDatabasePath;
    GUID        guidDB;
    GUID*       pGuidDB;
    DWORD       dwDatabaseType = 0;
    DWORD       dwCount;
    BOOL        bSuccess = FALSE;
    DWORD       dwIndex;

    PSDBENTRY   pEntry;

    if (!(SDBCUSTOM_FLAGS(dwFlags) & SDBCUSTOM_USE_INDEX)) {
        //
        // Find free local sdb entry
        //
        dwIndex = SdbpFindFreeLocalEntry(hSDB);

        if (dwIndex == SDBENTRY_INVALID_INDEX) {
            DBGPRINT((sdlError,
                      "SdbOpenLocalDatabaseEx",
                      "No more free entries in local db table\n"));
            goto cleanup;
        }

        pEntry = &pSdbContext->rgSDB[dwIndex];

    } else {
        dwIndex = *pdwLocalDBMask;

        if (dwIndex & TAGREF_STRIP_PDB) {
            dwIndex = SDB_MASK_TO_INDEX(dwIndex);
        }

        if (dwIndex >= ARRAYSIZE(pSdbContext->rgSDB)) {
            DBGPRINT((sdlError,
                      "SdbOpenLocalDatabaseEx",
                      "Bad index 0x%lx\n",
                      dwIndex));
            goto cleanup;
        }

        if (dwIndex < 2) {
            DBGPRINT((sdlWarning,
                      "SdbOpenLocalDatabaseEx",
                      "Unusual use of SdbOpenLocalDatabaseEx index 0x%lx\n",
                      dwIndex));
        }

        pEntry = &pSdbContext->rgSDB[dwIndex];

        SdbCloseLocalDatabaseEx(hSDB, NULL, dwIndex);
    }

    switch (SDBCUSTOM_TYPE(dwFlags)) {
    case SDBCUSTOM_PATH:
        if (SDBCUSTOM_PATH_NT & SDBCUSTOM_FLAGS(dwFlags)) {
            dwOpenFlags = NT_PATH;
        }
        pszDatabasePath = (LPTSTR)pDatabaseID;
        pGuidDB = NULL;
        break;

    case SDBCUSTOM_GUID:
        if (SDBCUSTOM_GUID_STRING & SDBCUSTOM_FLAGS(dwFlags)) {
            if (!SdbGUIDFromString((LPCTSTR)pDatabaseID, &guidDB)) {

                DBGPRINT((sdlError,
                          "SdbOpenLocalDatabaseEx",
                          "Cannot convert \"%s\" to guid\n",
                          (LPCTSTR)pDatabaseID));
                goto cleanup;
            }
            pGuidDB = &guidDB;
        } else {
            pGuidDB = (GUID*)pDatabaseID;
        }

        dwCount = SdbResolveDatabase(pGuidDB,
                                     &dwDatabaseType,
                                     szDatabasePath,
                                     CHARCOUNT(szDatabasePath));
        if (dwCount == 0 || dwCount >= CHARCOUNT(szDatabasePath)) {
            DBGPRINT((sdlError,
                      "SdbOpenLocalDatabaseEx",
                      "Cannot resolve database, the path length is 0x%lx\n",
                      dwCount));
            goto cleanup;
        }
        pszDatabasePath = szDatabasePath;
        break;

    default:
        DBGPRINT((sdlError, "SdbOpenLocalDatabaseEx", "Bad flags 0x%lx\n", dwFlags));
        goto cleanup;
        break;
    }


    pdb = SdbOpenDatabase(pszDatabasePath, dwOpenFlags);
    if (pdb == NULL) {
        //
        // dbgprint not needed here
        //
        goto cleanup;
    }

    pSdbContext->rgSDB[dwIndex].pdb = pdb;
    pSdbContext->rgSDB[dwIndex].dwFlags = SDBENTRY_VALID_ENTRY;

    SDBCUSTOM_SET_MASK(pSdbContext, dwIndex);

    if (pGuidDB != NULL) {
        RtlCopyMemory(&pSdbContext->rgSDB[dwIndex].guidDB, pGuidDB, sizeof(GUID));
        pSdbContext->rgSDB[dwIndex].dwFlags |= SDBENTRY_VALID_GUID;
    } else {
        RtlZeroMemory(&pSdbContext->rgSDB[dwIndex].guidDB, sizeof(GUID));
    }

    bSuccess = TRUE;

cleanup:

    if (bSuccess) {
        if (dwIndex == SDB_MASK_TO_INDEX(PDB_LOCAL)) {
            pSdbContext->pdbLocal = pdb;
        }

        if (pdwLocalDBMask != NULL) {
            *pdwLocalDBMask = SDB_INDEX_TO_MASK(dwIndex);
        }

        if (pPDB != NULL) {
            *pPDB = pdb;
        }
    }

    return bSuccess;
}


BOOL
SdbOpenLocalDatabase(
    IN  HSDB    hSDB,               // handle to the database channel
    IN  LPCTSTR pszLocalDatabase    // full DOS path to the local database to open.
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Opens a local database.
--*/
{

    DWORD dwIndex = PDB_LOCAL;
    BOOL  bSuccess;

    bSuccess = SdbOpenLocalDatabaseEx(hSDB,
                                      pszLocalDatabase,
                                      (SDBCUSTOM_PATH_DOS | SDBCUSTOM_USE_INDEX),
                                      NULL,
                                      &dwIndex);
    return bSuccess;
}

BOOL
SdbCloseLocalDatabase(
    IN  HSDB hSDB               // handle to the database channel
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Closes the local database.
--*/
{
    return SdbCloseLocalDatabaseEx(hSDB, NULL, SDB_MASK_TO_INDEX(PDB_LOCAL));
}


TAGREF
SdbGetItemFromItemRef(
    IN  HSDB   hSDB,            // handle to the database channel
    IN  TAGREF trItemRef,       // TAGREF of a DLL_REF record
    IN  TAG    tagItemKey,      // key that has the name of the item (TAG_NAME)
    IN  TAG    tagItemTAGID,    // tag that points to the location of the desired item by it's tagid
    IN  TAG    tagItem          // what to look for under Library
    )
/*++
    Return: TAGREF of a DLL record that matches the DLL_REF.

    Desc:   Given a TAGREF that points to a *tag*_REF type tag, searches through
            the various databases for the matching tag (generally located
            under the LIBRARY tag in gpdbMain).

            if bAllowNonMain is specified then the library section is looked up
            in the same database where trItemRef was found. This is used with
            MSI transforms - to locate and extract them from custom databases.
            This flag IS NOT used for other components - such as patches and
            shim dlls. This is ensured through the macros -
            SdbGetShimFromShimRef(hSDB, trShimRef)
            and
            SdbGetPatchFromPatchRef(hSDB, trPatchRef)
            Both of these macros call this function with bAllowNonMain set to FALSE
--*/
{
    PSDBCONTEXT pDbContext   = (PSDBCONTEXT)hSDB;
    TAGID       tiItemRef    = TAGID_NULL;
    PDB         pdbItemRef   = NULL;
    TAGREF      trReturn     = TAGREF_NULL;
    TAGID       tiReturn     = TAGID_NULL;
    TAGID       tiDatabase   = TAGID_NULL;
    TAGID       tiLibrary    = TAGID_NULL;
    TAGID       tiItemTagID  = TAGID_NULL;
    TAGID       tiItemName;
    LPTSTR      szItemName   = NULL;

    try {
        //
        // Find first which database contains the reference TAGREF.
        //
        if (!SdbTagRefToTagID(pDbContext, trItemRef, &pdbItemRef, &tiItemRef)){
            DBGPRINT((sdlError, "SdbGetItemFromItemRef", "Can't convert tag ref.\n"));
            goto out;
        }

        //
        // First check if there's a TAG_item_TAGID that tells us exactly
        // where the item is within the current database.
        //
        tiItemTagID = SdbFindFirstTag(pdbItemRef, tiItemRef, tagItemTAGID);

        if (tiItemTagID != TAGID_NULL) {

            tiReturn = (TAGID)SdbReadDWORDTag(pdbItemRef, tiItemTagID, 0);

            if (tiReturn != TAGID_NULL) {
                goto out;
            }
        }

        if (pdbItemRef == pDbContext->pdbMain) {
            goto checkMainDatabase;
        }

        //
        // Then check for the item in the LIBRARY section of the
        // current database.
        //
        tiDatabase = SdbFindFirstTag(pdbItemRef, TAGID_ROOT, TAG_DATABASE);
        if (!tiDatabase) {
            DBGPRINT((sdlError,
                      "SdbGetItemFromItemRef",
                      "Can't find DATABASE tag in db.\n"));
            goto checkMainDatabase;
        }

        tiLibrary = SdbFindFirstTag(pdbItemRef, tiDatabase, TAG_LIBRARY);
        if (!tiLibrary) {
            //
            // This library doesn't have a LIBRARY section. That's ok, go check
            // sysmain.sdb.
            //
            goto checkMainDatabase;
        }

        //
        // We need to search by name.
        //
        tiItemName = SdbFindFirstTag(pdbItemRef, tiItemRef, tagItemKey);
        if (!tiItemName) {
            goto out;
        }

        szItemName = SdbGetStringTagPtr(pdbItemRef, tiItemName);
        if (!szItemName) {
            goto out;
        }

        tiReturn = SdbFindFirstNamedTag(pdbItemRef,
                                        tiLibrary,
                                        tagItem,
                                        tagItemKey,
                                        szItemName);

        if (tiReturn != TAGID_NULL) {
            goto out;
        }

checkMainDatabase:

        tiDatabase = SdbFindFirstTag(pDbContext->pdbMain, TAGID_ROOT, TAG_DATABASE);
        if (!tiDatabase) {
            DBGPRINT((sdlError,
                      "SdbGetItemFromItemRef",
                      "Can't find DATABASE tag in main db.\n"));
            goto out;
        }

        tiLibrary = SdbFindFirstTag(pDbContext->pdbMain, tiDatabase, TAG_LIBRARY);
        if (!tiLibrary) {
            DBGPRINT((sdlError,
                      "SdbGetItemFromItemRef",
                      "Can't find LIBRARY tag in main db.\n"));
            goto out;
        }

        //
        // We need to search by name.
        //
        if (szItemName == NULL) {
            tiItemName = SdbFindFirstTag(pdbItemRef, tiItemRef, tagItemKey);
            if (!tiItemName) {
                goto out;
            }

            szItemName = SdbGetStringTagPtr(pdbItemRef, tiItemName);
            if (!szItemName) {
                goto out;
            }
        }

        tiReturn = SdbFindFirstNamedTag(pDbContext->pdbMain,
                                        tiLibrary,
                                        tagItem,
                                        tagItemKey,
                                        szItemName);

        pdbItemRef = pDbContext->pdbMain;

    } except (SHIM_EXCEPT_HANDLER) {
        tiReturn = TAGID_NULL;
        trReturn = TAGREF_NULL;
    }

out:

    if (tiReturn) {
        assert(pdbItemRef != NULL);
        if (!SdbTagIDToTagRef(pDbContext, pdbItemRef, tiReturn, &trReturn)) {
            trReturn = TAGREF_NULL;
        }
    }

    if (trReturn == TAGREF_NULL) {
        DBGPRINT((sdlError,
                  "SdbGetItemFromItemRef",
                  "Can't find tag for tag ref 0x%x.\n", trItemRef));
    }

    return trReturn;
}


TAGID
SdbpGetLibraryFile(
    IN  PDB     pdb,           // handle to the database channel
    IN  LPCTSTR szDllName       // the name of the DLL
    )
/*++
    Return: The TAGID of the DLL used by the specified shim.

    Desc:   This function gets the TAGID of the DLL with the specified name.
--*/
{
    TAGID       tiDatabase;
    TAGID       tiLibrary;
    TAGID       tiDll = TAG_NULL;

    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);

    if (!tiDatabase) {
        DBGPRINT((sdlError, "SdbpGetLibraryFile", "Can't find DATABASE tag in main db.\n"));
        goto out;
    }

    tiLibrary = SdbFindFirstTag(pdb, tiDatabase, TAG_LIBRARY);

    if (!tiLibrary) {
        DBGPRINT((sdlError, "SdbpGetLibraryFile", "Can't find LIBRARY tag in main db.\n"));
        goto out;
    }

    tiDll = SdbFindFirstNamedTag(pdb, tiLibrary, TAG_FILE, TAG_NAME, szDllName);

    if (!tiDll) {
        DBGPRINT((sdlError,
                  "SdbpGetLibraryFile", "Can't find FILE \"%s\" in main db library.\n",
                  szDllName));
        goto out;
    }

out:

    return tiDll;
}

BOOL
SdbGetDllPath(
    IN  HSDB   hSDB,            // handle to the database channel
    IN  TAGREF trShimRef,       // SHIM_REF to use to search for the DLL
    OUT LPTSTR pwszBuffer       // Buffer to fill with the path to the DLL containing
                                // the specified shim.
    )
/*++
    Return: TRUE if the DLL was found, FALSE otherwise.

    Desc:   Hunts for the DLL file on disk, first in the same
            directory as the EXE (if there was a local database opened), then
            in the %windir%\AppPatch directory.
            Always fills in a DOS_PATH type path (UNC or 'x:').
--*/
{
    BOOL     bReturn = FALSE;
    HANDLE   hFile   = INVALID_HANDLE_VALUE;
    PBYTE    pBuffer = NULL;
    DWORD    dwSize;
    TAGREF   trShim;
    TAGREF   trDll;
    TAGREF   trDllBits;
    TAGREF   trName;
    TCHAR    szFile[2 * MAX_PATH];
    TCHAR    szName[MAX_PATH];

    assert(pwszBuffer);

    try {

        //
        // Initialize the return buffer.
        //
        pwszBuffer[0] = _T('\0');

        SdbpGetAppPatchDir(szFile);

        _tcscat(szFile, _T("\\"));

        //
        // Look for the SHIM record in the LIBRARY section.
        //
        trShim = SdbGetShimFromShimRef(hSDB, trShimRef);

        if (trShim == TAGREF_NULL) {

            //
            // No SHIM in LIBRARY. Error out.
            //
            DBGPRINT((sdlError, "SdbGetDllPath", "No SHIM in LIBRARY.\n"));
            goto out;
        }

        //
        // Get the name of the file that contains this shim.
        //
        trName = SdbFindFirstTagRef(hSDB, trShim, TAG_DLLFILE);
        if (trName == TAGREF_NULL) {
            //
            // Nope, and we need one. Error out.
            //
            DBGPRINT((sdlError, "SdbGetDllPath", "No DLLFILE for the SHIM in LIBRARY.\n"));
            goto out;
        }

        if (!SdbReadStringTagRef(hSDB, trName, szName, MAX_PATH)) {
            DBGPRINT((sdlError, "SdbGetDllPath", "Can't read DLL name.\n"));
            goto out;
        }

        //
        // Check if the file is already on the disk.
        // Look in %windir%\AppPatch directory for the DLL.
        //
        _tcscat(szFile, szName);
        _tcscpy(pwszBuffer, szFile);

        DBGPRINT((sdlInfo, "SdbGetDllPath", "Opening file \"%s\".\n", szFile));

        hFile = SdbpOpenFile(szFile, DOS_PATH);

        if (hFile != INVALID_HANDLE_VALUE) {
            bReturn = TRUE;
            goto out;
        }

out:
        ;

    } except (SHIM_EXCEPT_HANDLER) {
        bReturn = FALSE;
    }

    if (hFile != INVALID_HANDLE_VALUE) {
        SdbpCloseFile(hFile);
    }

    if (pBuffer != NULL) {
        SdbFree(pBuffer);
    }

    if (bReturn) {
        DBGPRINT((sdlInfo, "SdbGetDllPath", "Using DLL \"%s\".\n", szFile));
    }

    return bReturn;
}

BOOL
SdbReadPatchBits(
    IN  HSDB    hSDB,           // handle to the database channel
    IN  TAGREF  trPatchRef,     // PATCH_REF to use to find the PATCH
    OUT PVOID   pBuffer,        // buffer to fill with bits
    OUT LPDWORD lpdwBufferSize  // size of passed-in buffer
    )
/*++
    Return: Returns TRUE on success, FALSE on failure.

    Desc:   Looks for the patch, first on disk, then in the DB, and fills
            pBuffer with the bits. If the size specified in lpdwBufferSize is
            less than the size of the patch this function will return in
            lpdwBufferSize the size required. In that case pBuffer is ignored
            and can be NULL.
--*/
{
    BOOL   bReturn      = FALSE;
    TAGID  tiPatchRef   = TAGID_NULL;
    PDB    pdb          = NULL;
    LPTSTR szName       = NULL;
    TAGREF trPatch      = TAGREF_NULL;
    TAGREF trPatchBits  = TAGREF_NULL;
    TAGID  tiName       = TAGID_NULL;
    DWORD  dwSize;

    try {
        if (!SdbTagRefToTagID(hSDB, trPatchRef, &pdb, &tiPatchRef)) {
            DBGPRINT((sdlError, "SdbReadPatchBits", "Can't convert tag ref.\n"));
            goto out;
        }

        tiName = SdbFindFirstTag(pdb, tiPatchRef, TAG_NAME);
        if (!tiName) {
            DBGPRINT((sdlError, "SdbReadPatchBits", "Can't find the name tag.\n"));
            goto out;
        }

        szName = SdbGetStringTagPtr(pdb, tiName);
        if (!szName) {
            DBGPRINT((sdlError, "SdbReadPatchBits", "Can't read the name of the patch.\n"));
            goto out;
        }

        //
        // Look in the main database for the patch bits.
        //
        trPatch = SdbGetPatchFromPatchRef(hSDB, trPatchRef);
        if (!trPatch) {
            DBGPRINT((sdlError, "SdbReadPatchBits", "Can't get the patch tag.\n"));
            goto out;
        }

        trPatchBits = SdbFindFirstTagRef(hSDB, trPatch, TAG_PATCH_BITS);
        if (!trPatchBits) {
            DBGPRINT((sdlError, "SdbReadPatchBits", "Can't get the patch bits tag.\n"));
            goto out;
        }

        dwSize = SdbpGetTagRefDataSize(hSDB, trPatchBits);

        if (dwSize == 0) {
            DBGPRINT((sdlError, "SdbReadPatchBits", "Corrupt database. Zero sized patch.\n"));
            goto out;
        }

        //
        // Check for buffer size.
        //
        if (dwSize > *lpdwBufferSize) {
            *lpdwBufferSize = dwSize;
            goto out;
        }

        //
        // Read the bits if the buffer is big enough.
        //
        *lpdwBufferSize = dwSize;

        if (!SdbpReadBinaryTagRef(hSDB, trPatchBits, pBuffer, dwSize)) {
            DBGPRINT((sdlError, "SdbReadPatchBits", "Cannot get the patch bits.\n"));
            goto out;
        }

        bReturn = TRUE;

    } except (SHIM_EXCEPT_HANDLER) {
        bReturn = FALSE;
    }

out:
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\ntbase.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        ntbase.c

    Abstract:

        This module implements low level primitives. They should never be
        called by anything other than this module.

    Author:

        dmunsil     created     sometime in 1999

    Revision History:

        several people contributed (vadimb, clupu, ...)

--*/

#include "sdbp.h"

#define SDB_MEMORY_POOL_TAG 'abdS'

#if defined(KERNEL_MODE) && defined(ALLOC_DATA_PRAGMA)
#pragma  data_seg()
#endif // KERNEL_MODE && ALLOC_DATA_PRAGMA


#if defined(KERNEL_MODE) && defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, SdbAlloc)
#pragma alloc_text(PAGE, SdbFree)
#pragma alloc_text(PAGE, SdbpOpenFile)
#pragma alloc_text(PAGE, SdbpQueryAppCompatFlagsByExeID)
#pragma alloc_text(PAGE, SdbGetEntryFlags)
#pragma alloc_text(PAGE, SdbpGetFileSize)
#endif // KERNEL_MODE && ALLOC_PRAGMA


//
// Memory functions
//

void*
SdbAlloc(
    IN  size_t size             // size in bytes to allocate
    )
/*++
    Return: The pointer allocated.

    Desc:   Just a wrapper for allocation -- perhaps useful if we move this
            code to a non-NTDLL location and need to call differently.
--*/
{
#ifdef BOUNDS_CHECKER_DETECTION
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
#else

    #ifdef KERNEL_MODE

        LPVOID lpv; // return zero-initialized memory pool.

        lpv = ExAllocatePoolWithTag(PagedPool, size, SDB_MEMORY_POOL_TAG);
        
        if (lpv != NULL) {
            RtlZeroMemory(lpv, size);
        }

        return lpv;

    #else
        return RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, size);
    #endif // KERNEL_MODE

#endif // BOUNDS_CHECKER_DETECTION
}

void
SdbFree(
    IN  void* pWhat             // ptr allocated with SdbAlloc that should be freed.
    )
/*++
    Return: The pointer allocated.

    Desc:   Just a wrapper for deallocation -- perhaps useful if we move this
            code to a non-NTDLL location and need to call differently.
--*/
{
#ifdef BOUNDS_CHECKER_DETECTION
    HeapFree(GetProcessHeap(), 0, pWhat);
#else

    #ifdef KERNEL_MODE
        ExFreePoolWithTag(pWhat, SDB_MEMORY_POOL_TAG);
    #else
        RtlFreeHeap(RtlProcessHeap(), 0, pWhat);
    #endif // KERNEL_MODE

#endif // BOUNDS_CHECKER_DETECTION
}


HANDLE
SdbpOpenFile(
    IN  LPCWSTR   szPath,       // full path of file to open
    IN  PATH_TYPE eType         // DOS_PATH for standard paths, NT_PATH for nt
                                // internal paths
    )
/*++
    Return: A handle to the opened file or INVALID_HANDLE_VALUE on failure.

    Desc:   Just a wrapper for opening an existing file for READ -- perhaps
            useful if we move this code to a non-NTDLL location and need to
            call differently. Also makes the code more readable by wrapping
            all the strange NTDLL goo in one place.

            Takes as parameters the path to open, and the kind of path.
            NT_PATH is the type used internally in NTDLL, and DOS_PATH is
            the type most users know, that begins with a drive letter.
--*/
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING    UnicodeString;
    NTSTATUS          status;
    HANDLE            hFile = INVALID_HANDLE_VALUE;

#ifndef KERNEL_MODE
    RTL_RELATIVE_NAME RelativeName;
#endif // KERNEL_MODE

    RtlInitUnicodeString(&UnicodeString, szPath);

#ifndef KERNEL_MODE
    if (eType == DOS_PATH) {
        if (!RtlDosPathNameToNtPathName_U(szPath,
                                          &UnicodeString,
                                          NULL,
                                          &RelativeName)) {
            DBGPRINT((sdlError,
                      "SdbpOpenFile",
                      "RtlDosPathNameToNtPathName_U failed, path \"%s\"\n",
                      szPath));
            return INVALID_HANDLE_VALUE;
        }
    }
#endif // KERNEL_MODE

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          0,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ,
                          FILE_OPEN,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

#ifndef KERNEL_MODE
    if (eType == DOS_PATH) {
        RtlFreeUnicodeString(&UnicodeString);
    }
#endif // KERNEL_MODE

    if (!NT_SUCCESS(status)) {
        DBGPRINT((sdlInfo, "SdbpOpenFile", "NtCreateFile failed status 0x%x\n", status));
        return INVALID_HANDLE_VALUE;
    }

    return hFile;
}


void
SdbpQueryAppCompatFlagsByExeID(
    IN  LPCWSTR         pwszKeyPath,    // NT registry key path.
    IN  PUNICODE_STRING pustrExeID,     // a GUID in string format that identifies the
                                        // EXE entry in the database.
    OUT LPDWORD         lpdwFlags       // this will contain the flags for the EXE
                                        // entry checked.
    )
/*++
    Return: STATUS_SUCCESS or a failure NTSTATUS code.

    Desc:   Given an EXE id it returns flags from the registry associated with
            that exe..
--*/
{
    UNICODE_STRING                  ustrKey;
    NTSTATUS                        Status;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    HANDLE                          KeyHandle;
    PKEY_VALUE_PARTIAL_INFORMATION  KeyValueInformation;
    ULONG                           KeyValueBuffer[256];
    ULONG                           KeyValueLength;

    *lpdwFlags = 0;

    RtlInitUnicodeString(&ustrKey, pwszKeyPath);

    InitializeObjectAttributes(&ObjectAttributes,
                               &ustrKey,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&KeyHandle,
                       GENERIC_READ|SdbpGetWow64Flag(),
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlInfo,
                  "SdbpQueryAppCompatFlagsByExeID",
                  "Failed to open Key \"%s\" Status 0x%x\n",
                  pwszKeyPath,
                  Status));
        return;
    }

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;

    Status = NtQueryValueKey(KeyHandle,
                             pustrExeID,
                             KeyValuePartialInformation,
                             KeyValueInformation,
                             sizeof(KeyValueBuffer),
                             &KeyValueLength);

    NtClose(KeyHandle);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlInfo,
                  "SdbpQueryAppCompatFlagsByExeID",
                  "Failed to read value info from Key \"%s\" Status 0x%x\n",
                  pwszKeyPath,
                  Status));
        return;
    }

    //
    // Check for the value type.
    //
    if (KeyValueInformation->Type != REG_DWORD) {
        DBGPRINT((sdlError,
                  "SdbpQueryAppCompatFlagsByExeID",
                  "Unexpected value type 0x%x for Key \"%s\".\n",
                  KeyValueInformation->Type,
                  pwszKeyPath));
        return;
    }

    *lpdwFlags = *(DWORD*)(&KeyValueInformation->Data[0]);
}


BOOL
SdbGetEntryFlags(
    IN  GUID*   pGuid,          // pointer to the GUID that identifies an EXE entry in
                                // the database
    OUT LPDWORD lpdwFlags       // this will contain the "disable" flags for that entry
    )
/*++
    Return: TRUE on success, FALSE on failure.

    Desc:   Given an EXE id it returns flags from the registry associated with
            that exe..
--*/
{
    BOOL            bSuccess       = FALSE;
    NTSTATUS        Status;
    UNICODE_STRING  ustrExeID;
    DWORD           dwFlagsUser    = 0;     // flags from HKEY_CURRENT_USER
    DWORD           dwFlagsMachine = 0;     // flags from HKEY_LOCAL_MACHINE
    UNICODE_STRING  userKeyPath = { 0 };

    *lpdwFlags = 0;

    //
    // Convert the GUID to string.
    //
    Status = GUID_TO_UNICODE_STRING(pGuid, &ustrExeID);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbGetEntryFlags",
                  "Failed to convert EXE id to string. status 0x%x.\n",
                  Status));
        return TRUE;
    }

    //
    // Query the flags in the LOCAL_MACHINE subtree.
    //
    SdbpQueryAppCompatFlagsByExeID(APPCOMPAT_KEY_PATH_MACHINE, &ustrExeID, &dwFlagsMachine);

    //
    // Set the flags here so that if any call from now on fails we at least have
    // the per machine settings.
    //
    *lpdwFlags = dwFlagsMachine;

    //
    // We do not query CURRENT_USER subtree in kernel-mode
    //

#ifndef KERNEL_MODE

    if (!SdbpBuildUserKeyPath(APPCOMPAT_KEY_PATH_NT, &userKeyPath)) {
        DBGPRINT((sdlError,
                  "SdbGetEntryFlags",
                  "Failed to format current user key path for \"%s\"\n",
                  APPCOMPAT_KEY_PATH_NT));

        FREE_GUID_STRING(&ustrExeID);
        return TRUE;
    }

    SdbpQueryAppCompatFlagsByExeID(userKeyPath.Buffer, &ustrExeID, &dwFlagsUser);
    *lpdwFlags |= dwFlagsUser;

    SdbFree(userKeyPath.Buffer);

#endif // KERNEL_MODE

    //
    // Free the buffer allocated by RtlStringFromGUID
    //
    FREE_GUID_STRING(&ustrExeID);

    return TRUE;
}

DWORD
SdbpGetFileSize(
    IN  HANDLE hFile            // file to check the size of
    )
/*++
    Return: The size of the file or 0 on failure.

    Desc:   Gets the lower DWORD of the size of a file -- only
            works accurately with files smaller than 2GB.
            In general, since we're only interested in matching, we're
            fine just matching the least significant DWORD of the file size.
--*/
{
    FILE_STANDARD_INFORMATION   FileStandardInformationBlock;
    IO_STATUS_BLOCK             IoStatusBlock;
    HRESULT                     status;

    status = NtQueryInformationFile(hFile,
                                    &IoStatusBlock,
                                    &FileStandardInformationBlock,
                                    sizeof(FileStandardInformationBlock),
                                    FileStandardInformation);

    if (!NT_SUCCESS(status)) {
        DBGPRINT((sdlError, "SdbpGetFileSize", "Unsuccessful. Status: 0x%x.\n", status));
        return 0;
    }

    return FileStandardInformationBlock.EndOfFile.LowPart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\read.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        read.c

    Abstract:

        This module implements primitives used for reading the database.

    Author:

        dmunsil     created     sometime in 1999

    Revision History:

        several people contributed (vadimb, clupu, ...)

--*/

#include "sdbp.h"

#if defined(KERNEL_MODE) && defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, SdbpGetTagHeadSize)
#pragma alloc_text(PAGE, SdbReadBYTETag)
#pragma alloc_text(PAGE, SdbReadWORDTag)
#pragma alloc_text(PAGE, SdbReadDWORDTag)
#pragma alloc_text(PAGE, SdbReadQWORDTag)
#pragma alloc_text(PAGE, SdbReadBYTETagRef)
#pragma alloc_text(PAGE, SdbReadWORDTagRef)
#pragma alloc_text(PAGE, SdbReadDWORDTagRef)
#pragma alloc_text(PAGE, SdbReadQWORDTagRef)
#pragma alloc_text(PAGE, SdbGetTagDataSize)
#pragma alloc_text(PAGE, SdbpGetTagRefDataSize)
#pragma alloc_text(PAGE, SdbpReadTagData)
#pragma alloc_text(PAGE, SdbReadStringTagRef)
#pragma alloc_text(PAGE, SdbpReadBinaryTagRef)
#pragma alloc_text(PAGE, SdbpGetMappedTagData)
#pragma alloc_text(PAGE, SdbpGetStringRefLength)
#pragma alloc_text(PAGE, SdbpReadStringRef)
#pragma alloc_text(PAGE, SdbReadStringTag)
#pragma alloc_text(PAGE, SdbGetStringTagPtr)
#pragma alloc_text(PAGE, SdbpReadStringFromTable)
#pragma alloc_text(PAGE, SdbpGetMappedStringFromTable)
#pragma alloc_text(PAGE, SdbReadBinaryTag)
#pragma alloc_text(PAGE, SdbGetBinaryTagData)
#endif // KERNEL_MODE && ALLOC_PRAGMA

DWORD
SdbpGetTagHeadSize(
    PDB   pdb,      // IN - pdb to use
    TAGID tiWhich   // IN - record to get info on
    )
/*++
    Return: The size of the non-data (TAG & SIZE) portion of the record.

    Desc:   Returns the size of the non-data part of a tag in the DB, which is
            to say the tag itself (a WORD), and possibly the size (a DWORD).
            So this function will return 2 if the tag has an implied size,
            6 if the tag has a size after it, and 0 if there was an error.
--*/
{
    TAG   tWhich;
    DWORD dwRetOffset;
    DWORD dwOffset = (DWORD)tiWhich;

    if (!SdbpReadMappedData(pdb, (DWORD)tiWhich, &tWhich, sizeof(TAG))) {
        DBGPRINT((sdlError, "SdbpGetTagHeadSize", "Error reading tag.\n"));
        return 0;
    }

    dwRetOffset = sizeof(TAG);

    if (GETTAGTYPE(tWhich) >= TAG_TYPE_LIST) {
        dwRetOffset += sizeof(DWORD);
    }

    return dwRetOffset;
}

//
// This macro is used by the *ReadTypeTag primitives.
//

#define READDATATAG(dataType, tagType, dtDefault)                                   \
{                                                                                   \
    dataType dtReturn = dtDefault;                                                  \
                                                                                    \
    assert(pdb);                                                                    \
                                                                                    \
    if (GETTAGTYPE(SdbGetTagFromTagID(pdb, tiWhich)) != tagType) {                  \
        DBGPRINT((sdlError,                                                         \
                  "READDATATAG",                                                    \
                  "TagID 0x%X, Tag 0x%X not of the expected type.\n",               \
                  tiWhich,                                                          \
                  (DWORD)SdbGetTagFromTagID(pdb, tiWhich)));                        \
        return dtDefault;                                                           \
    }                                                                               \
                                                                                    \
    if (!SdbpReadTagData(pdb, tiWhich, &dtReturn, sizeof(dataType))) {              \
        return dtDefault;                                                           \
    }                                                                               \
                                                                                    \
    return dtReturn;                                                                \
}

BYTE
SdbReadBYTETag(PDB pdb, TAGID tiWhich, BYTE jDefault)
{
    READDATATAG(BYTE, TAG_TYPE_BYTE, jDefault);
}

WORD SdbReadWORDTag(PDB pdb, TAGID tiWhich, WORD wDefault)
{
    READDATATAG(WORD, TAG_TYPE_WORD, wDefault);
}

DWORD SdbReadDWORDTag(PDB pdb, TAGID tiWhich, DWORD dwDefault)
{
    READDATATAG(DWORD, TAG_TYPE_DWORD, dwDefault);
}

ULONGLONG SdbReadQWORDTag(PDB pdb, TAGID tiWhich, ULONGLONG qwDefault)
{
    READDATATAG(ULONGLONG, TAG_TYPE_QWORD, qwDefault);
}

//
// This macro is used by the *ReadTypeTag primitives.
//

#define READTYPETAGREF(fnReadTypeTag, dtDefault)                                    \
{                                                                                   \
    PDB   pdb;                                                                      \
    TAGID tiWhich;                                                                  \
                                                                                    \
    if (!SdbTagRefToTagID(hSDB, trWhich, &pdb, &tiWhich)) {                         \
        DBGPRINT((sdlError, "READTYPETAGREF", "Can't convert tag ref.\n"));         \
        return dtDefault;                                                           \
    }                                                                               \
                                                                                    \
    return fnReadTypeTag(pdb, tiWhich, dtDefault);                                  \
}


BYTE SdbReadBYTETagRef(HSDB hSDB, TAGREF trWhich, BYTE jDefault)
{
    READTYPETAGREF(SdbReadBYTETag, jDefault);
}

WORD SdbReadWORDTagRef(HSDB hSDB, TAGREF trWhich, WORD wDefault)
{
    READTYPETAGREF(SdbReadWORDTag, wDefault);
}

DWORD SdbReadDWORDTagRef(HSDB hSDB, TAGREF trWhich, DWORD dwDefault)
{
    READTYPETAGREF(SdbReadDWORDTag, dwDefault);
}

ULONGLONG SdbReadQWORDTagRef(HSDB hSDB, TAGREF trWhich, ULONGLONG qwDefault)
{
    READTYPETAGREF(SdbReadQWORDTag, qwDefault);
}

DWORD
SdbGetTagDataSize(
    IN  PDB   pdb,              // DB to use
    IN  TAGID tiWhich           // record to get size of
    )
/*++
    Return: The size of the data portion of the record.

    Desc:   Returns the size of the data portion of the given tag, i.e. the
            part after the tag WORD and the (possible) size DWORD.
--*/
{
    TAG   tWhich;
    DWORD dwSize;
    DWORD dwOffset = (DWORD)tiWhich;

    assert(pdb);

    tWhich = SdbGetTagFromTagID(pdb, tiWhich);

    switch (GETTAGTYPE(tWhich)) {
    case TAG_TYPE_NULL:
        dwSize = 0;
        break;

    case TAG_TYPE_BYTE:
        dwSize = 1;
        break;

    case TAG_TYPE_WORD:
        dwSize = 2;
        break;

    case TAG_TYPE_DWORD:
        dwSize = 4;
        break;

    case TAG_TYPE_QWORD:
        dwSize = 8;
        break;

    case TAG_TYPE_STRINGREF:
        dwSize = 4;
        break;

    default:
        dwSize = 0;
        if (!SdbpReadMappedData(pdb, dwOffset + sizeof(TAG), &dwSize, sizeof(DWORD))) {
            DBGPRINT((sdlError, "SdbGetTagDataSize", "Error reading size data\n"));
        }
        break;
    }

    return dwSize;
}


DWORD
SdbpGetTagRefDataSize(
    IN  HSDB   hSDB,
    IN  TAGREF trWhich
    )
/*++
    Return: The size of the data portion of the record.

    Desc:   Returns the data size of the tag pointed to by TAGREF.
            Useful for finding out how much to allocate before
            calling SdbpReadBinaryTagRef.
--*/
{
    PDB   pdb;
    TAGID tiWhich;

    try {
        if (!SdbTagRefToTagID(hSDB, trWhich, &pdb, &tiWhich)) {
            DBGPRINT((sdlError, "SdbpGetTagRefDataSize", "Can't convert tag ref.\n"));
            return 0;
        }

        return SdbGetTagDataSize(pdb, tiWhich);
    } except (SHIM_EXCEPT_HANDLER) {
        ;
    }

    return 0;
}


BOOL
SdbpReadTagData(
    IN  PDB   pdb,              // DB to use
    IN  TAGID tiWhich,          // record to read
    OUT PVOID pBuffer,          // buffer to fill
    IN  DWORD dwBufferSize      // size of buffer
    )
/*++
    Return: TRUE if the data was read, FALSE if not.

    Desc:   An internal function used to read the data from a tag into a buffer.
            It does not check the type of the TAG, and should only be used internally.
--*/
{
    DWORD dwOffset;
    DWORD dwSize;

    assert(pdb && pBuffer);

    dwSize = SdbGetTagDataSize(pdb, tiWhich);

    if (dwSize > dwBufferSize) {
        DBGPRINT((sdlError,
                  "SdbpReadTagData",
                  "Buffer too small. Avail: %d, Need: %d.\n",
                  dwBufferSize,
                  dwSize));
        return FALSE;
    }

    dwOffset = tiWhich + SdbpGetTagHeadSize(pdb, tiWhich);

    if (!SdbpReadMappedData(pdb, dwOffset, pBuffer, dwSize)) {
        DBGPRINT((sdlError,
                  "SdbpReadTagData",
                  "Error reading tag data.\n"));
        return FALSE;
    }

    return TRUE;
}


BOOL
SdbReadStringTagRef(
    IN  HSDB   hSDB,            // handle to the database channel
    IN  TAGREF trWhich,         // string or stringref tag to read
    OUT LPTSTR pwszBuffer,      // buffer to fill
    IN  DWORD  dwBufferSize     // size of passed-in buffer
    )
/*++
    Return: TRUE if the string was read, FALSE if not.

    Desc:   Reads a tag of type STRING or STRINGREF into a buffer. If the
            type is STRING, the data is read directly from the tag.
            If the type is STRINGREF, the string is read from the string
            table at the end of the file. Which one it is should be
            transparent to the caller.
--*/
{
    PDB   pdb;
    TAGID tiWhich;

    try {
        if (!SdbTagRefToTagID(hSDB, trWhich, &pdb, &tiWhich)) {
            DBGPRINT((sdlError, "SdbReadStringTagRef", "Can't convert tag ref.\n"));
            return FALSE;
        }

        return SdbReadStringTag(pdb, tiWhich, pwszBuffer, dwBufferSize);
    } except (SHIM_EXCEPT_HANDLER) {
        ;
    }

    return FALSE;
}

BOOL
SdbpReadBinaryTagRef(
    IN  HSDB   hSDB,            // handle to the database channel
    IN  TAGREF trWhich,         // BINARY tag to read
    OUT PBYTE  pBuffer,         // buffer to fill
    IN  DWORD  dwBufferSize     // size of passed-in buffer
    )
/*++
    Return: TRUE if the buffer was read, FALSE if not.

    Desc:   Reads a tag of type BINARY into pBuffer. Use SdbpGetTagRefDataSize
            to get the size of the buffer before calling this routine.
--*/
{
    PDB   pdb;
    TAGID tiWhich;

    try {
        if (!SdbTagRefToTagID(hSDB, trWhich, &pdb, &tiWhich)) {
            DBGPRINT((sdlError,  "SdbpReadBinaryTagRef", "Can't convert tag ref.\n"));
            return FALSE;
        }

        return SdbReadBinaryTag(pdb, tiWhich, pBuffer, dwBufferSize);
    } except (SHIM_EXCEPT_HANDLER) {
    }

    return FALSE;
}

PVOID
SdbpGetMappedTagData(
    IN  PDB   pdb,              // DB to use
    IN  TAGID tiWhich           // record to read
    )
/*++
    Return: The data pointer or NULL on failure.

    Desc:   An internal function used to get a pointer to the tag data.
            It works only if the DB is mapped.
--*/
{
    PVOID pReturn;
    DWORD dwOffset;

    assert(pdb);

    dwOffset = tiWhich + SdbpGetTagHeadSize(pdb, tiWhich);

    pReturn = SdbpGetMappedData(pdb, dwOffset);

    if (pReturn == NULL) {
        DBGPRINT((sdlError, "SdbpGetMappedTagData", "Error getting ptr to tag data.\n"));
    }

    return pReturn;
}

DWORD
SdbpGetStringRefLength(
    IN  HSDB   hSDB,
    IN  TAGREF trString
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    PDB     pdb        = NULL;
    TAGID   tiString   = TAGID_NULL;
    DWORD   dwLength   = 0;
    LPCTSTR lpszString;

    if (!SdbTagRefToTagID(hSDB, trString, &pdb, &tiString)) {
        DBGPRINT((sdlError,
                  "SdbGetStringRefLength",
                  "Failed to convert tag 0x%x to tagid\n",
                  trString));
        return dwLength;
    }

    lpszString = SdbGetStringTagPtr(pdb, tiString);
    
    if (lpszString != NULL) {
        dwLength = _tcslen(lpszString);
    }
    
    return dwLength;
}    

LPCTSTR 
SdbpGetStringRefPtr(
    IN HSDB hSDB,
    IN TAGREF trString
    )
{

    PDB     pdb        = NULL;
    TAGID   tiString   = TAGID_NULL;

    if (!SdbTagRefToTagID(hSDB, trString, &pdb, &tiString)) {
        DBGPRINT((sdlError, "SdbGetStringRefPtr", 
                  "Failed to convert tag 0x%x to tagid\n", trString));
        return NULL;
    }

    return SdbGetStringTagPtr(pdb, tiString);
}

    
STRINGREF
SdbpReadStringRef(
    IN  PDB   pdb,              // PDB to use
    IN  TAGID tiWhich           // record of type STRINGREF
    )
/*++
    Return: Returns the stringref, or STRINGREF_NULL on failure.

    Desc:   Used to read a stringref tag directly; normally one would just read
            it like a string, and let the DB fix up string refs. But a low-level
            tool may need to know exactly what it's reading.
--*/
{
    STRINGREF srReturn = STRINGREF_NULL;

    assert(pdb);

    if (GETTAGTYPE(SdbGetTagFromTagID(pdb, tiWhich)) != TAG_TYPE_STRINGREF) {
        DBGPRINT((sdlError,
                  "SdbpReadStringRef",
                  "TagID 0x%08X, Tag %04X not STRINGREF type.\n",
                  tiWhich,
                  (DWORD)SdbGetTagFromTagID(pdb, tiWhich)));
        return STRINGREF_NULL;
    }

    if (!SdbpReadTagData(pdb, tiWhich, &srReturn, sizeof(STRINGREF))) {
        DBGPRINT((sdlError, "SdbpReadStringRef", "Error reading data.\n"));
        return STRINGREF_NULL;
    }

    return srReturn;
}

BOOL
SdbReadStringTag(
    IN  PDB    pdb,             // DB to use
    IN  TAGID  tiWhich,         // record of type STRING or STRINGREF
    OUT LPTSTR pwszBuffer,      // buffer to fill
    IN  DWORD  dwBufferSize     // size in characters of buffer (leave room for zero!)
    )
/*++
    Return: TRUE if successful, or FALSE if the string can't be found or the
            buffer is too small.

    Desc:   Reads a string from the DB into szBuffer. If the tag is of
            type STRING, the string is just read from the data portion of
            the tag. If the tag is of type STRINGREF, the db reads the STRINGREF,
            then uses it to read the string from the string table at the end of
            the file. Either way, it's transparent to the caller.
--*/
{
    TAG tWhich;
    BOOL bSuccess;

    assert(pdb && pwszBuffer);

    tWhich = SdbGetTagFromTagID(pdb, tiWhich);

    if (GETTAGTYPE(tWhich) == TAG_TYPE_STRING) {
        //
        // Read an actual string.
        //

        return(READ_STRING(pdb, tiWhich, pwszBuffer, dwBufferSize));

    } else if (GETTAGTYPE(tWhich) == TAG_TYPE_STRINGREF) {
        //
        // Read a string reference, then get the string out of the table
        //
        STRINGREF srWhich = SdbpReadStringRef(pdb, tiWhich);

        if (srWhich == 0) {
            DBGPRINT((sdlError, "SdbReadStringTag", "Error getting StringRef.\n"));
            return FALSE;
        }

        return SdbpReadStringFromTable(pdb, srWhich, pwszBuffer, dwBufferSize);
    }

    //
    // This ain't no kind of string at all
    //
    return FALSE;
}

LPTSTR
SdbGetStringTagPtr(
    IN  PDB   pdb,              // DB to use
    IN  TAGID tiWhich           // record of type STRING or STRINGREF
    )
/*++
    Return: Returns a pointer if successful, or NULL if the string can't be found.

    Desc:   Gets a pointer to the string. If the tag is of type STRING,
            the string is just obtained from the data portion of the tag.
            If the tag is of type STRINGREF, the db reads the STRINGREF,
            then uses it to get the string from the string table at the end
            of the file. Either way, it's transparent to the caller.
--*/
{
    TAG    tWhich;
    LPTSTR pszReturn = NULL;

    assert(pdb);

    tWhich = SdbGetTagFromTagID(pdb, tiWhich);

    if (GETTAGTYPE(tWhich) == TAG_TYPE_STRING) {
        //
        // Read an actual string.
        //
        pszReturn = CONVERT_STRINGPTR(pdb,
                                      SdbpGetMappedTagData(pdb, tiWhich),
                                      TAG_TYPE_STRING,
                                      tiWhich);


    } else if (GETTAGTYPE(tWhich) == TAG_TYPE_STRINGREF) {
        //
        // Read a string reference, then get the string out of the table.
        //
        STRINGREF srWhich = SdbpReadStringRef(pdb, tiWhich);

        if (srWhich == 0) {
            DBGPRINT((sdlError, "SdbReadStringTag", "Error getting StringRef.\n"));
            return NULL;
        }

        pszReturn = CONVERT_STRINGPTR(pdb,
                                      SdbpGetMappedStringFromTable(pdb, srWhich),
                                      TAG_TYPE_STRINGREF,
                                      srWhich);

    }

    //
    // This ain't no kind of string at all.
    //
    return pszReturn;
}

BOOL
SdbpReadStringFromTable(
    IN  PDB       pdb,          // DB to use
    IN  STRINGREF srData,       // STRINGREF to get
    OUT LPTSTR    szBuffer,     // buffer to fill
    IN  DWORD     dwBufferSize  // size of buffer
    )
/*++
    Return: TRUE if the string was read, FALSE if not.

    Desc:   Reads a string out of the string table, given a STRINGREF.
            The STRINGREF is a direct offset from the beginning of the
            STRINGTABLE tag that should exist at the end of the db.
--*/
{
    TAGID tiWhich;
    TAG   tWhich;
    PDB   pdbString = NULL;

    assert(pdb && srData && szBuffer);

    if (pdb->bWrite) {
        //
        // When we're writing, the string table is in a separate DB.
        //
        if (!pdb->pdbStringTable) {
            DBGPRINT((sdlError, "SdbpReadStringFromTable", "No stringtable in DB.\n"));
            return FALSE;
        }

        //
        // Adjust for the slightly different offsets in the other DB.
        //
        tiWhich = srData - sizeof(TAG) - sizeof(DWORD) + sizeof(DB_HEADER);
        pdbString = pdb->pdbStringTable;
    } else {

        //
        // The STRINGREF is an offset from the beginning of the string table.
        //
        if (pdb->tiStringTable == TAGID_NULL) {
            pdb->tiStringTable = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_STRINGTABLE);

            if (pdb->tiStringTable == TAGID_NULL) {
                DBGPRINT((sdlError, "SdbpReadStringFromTable", "No stringtable in DB.\n"));
                return FALSE;
            }
        }

        tiWhich = pdb->tiStringTable + srData;
        pdbString = pdb;
    }

    tWhich = SdbGetTagFromTagID(pdbString, tiWhich);

    if (tWhich != TAG_STRINGTABLE_ITEM) {
        DBGPRINT((sdlError, "SdbpReadStringFromTable", "Pulled out a non-stringtable item.\n"));
        return FALSE;
    }

    return READ_STRING(pdbString, tiWhich, szBuffer, dwBufferSize);
}

WCHAR*
SdbpGetMappedStringFromTable(
    IN  PDB       pdb,          // DB to use
    IN  STRINGREF srData        // STRINGREF to get
    )
/*++
    Return: A pointer to a string or NULL.

    Desc:   Gets a pointer to a  string in the string table, given a STRINGREF.
            The STRINGREF is a direct offset from the beginning of the STRINGTABLE
            tag that should exist at the end of the db.
--*/
{
    TAGID tiWhich;
    TAG   tWhich;
    PDB   pdbString = NULL;

    assert(pdb && srData);

    if (pdb->bWrite) {
        //
        // When we're writing, the string table is in a separate DB.
        //
        if (pdb->pdbStringTable == NULL) {
            DBGPRINT((sdlError, "SdbpGetMappedStringFromTable", "No stringtable in DB.\n"));
            return NULL;
        }

        //
        // Adjust for the slightly different offsets in the other DB
        //
        tiWhich = srData - sizeof(TAG) - sizeof(DWORD) + sizeof(DB_HEADER);
        pdbString = pdb->pdbStringTable;
    } else {

        if (pdb->tiStringTable == TAGID_NULL) {
            pdb->tiStringTable = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_STRINGTABLE);

            if (pdb->tiStringTable == TAGID_NULL) {
                DBGPRINT((sdlError, "SdbpGetMappedStringFromTable", "No stringtable in DB.\n"));
                return NULL;
            }
        }

        //
        // The STRINGREF is an offset from the beginning of the string table.
        //
        tiWhich = pdb->tiStringTable + srData;
        pdbString = pdb;
    }

    tWhich = SdbGetTagFromTagID(pdbString, tiWhich);

    if (tWhich != TAG_STRINGTABLE_ITEM) {
        DBGPRINT((sdlError,
                  "SdbpGetMappedStringFromTable",
                  "Pulled out a non-stringtable item.\n"));
        return NULL;
    }

    return (WCHAR*)SdbpGetMappedTagData(pdbString, tiWhich);
}


BOOL
SdbReadBinaryTag(
    IN  PDB   pdb,              // DB to use
    IN  TAGID tiWhich,          // record of BASIC TYPE BINARY
    OUT PBYTE pBuffer,          // buffer to fill
    IN  DWORD dwBufferSize      // buffer size
    )
/*++
    Return: TRUE if the data was read, FALSE if not.

    Desc:   Reads data from a tag of type BINARY into pBuffer.
            Returns FALSE if the tag is not type BINARY, or the buffer is too small.
--*/
{
    assert(pdb);

    if (GETTAGTYPE(SdbGetTagFromTagID(pdb, tiWhich)) != TAG_TYPE_BINARY) {
        DBGPRINT((sdlError,
                  "SdbReadBinaryTag",
                  "TagID 0x%08X, Tag %04X not BINARY type.\n",
                  tiWhich,
                  (DWORD)SdbGetTagFromTagID(pdb, tiWhich)));
        return FALSE;
    }

    if (!SdbpReadTagData(pdb, tiWhich, pBuffer, dwBufferSize)) {
        DBGPRINT((sdlError, "SdbReadBinaryTag", "Error reading buffer.\n"));
        return FALSE;
    }

    return TRUE;
}

PVOID
SdbGetBinaryTagData(
    IN  PDB   pdb,              // pointer to the database to use
    IN  TAGID tiWhich           // tagid of the binary tag
    )
/*++
    Return: pointer to the binary data referenced by tiWhich or NULL if
            tiWhich does not refer to the binary tag or if tiWhich is invalid.

    Desc:   Function returns pointer to the [mapped] binary data referred to by
            tiWhich parameter in the database pdb.
--*/
{
    assert(pdb);

    if (GETTAGTYPE(SdbGetTagFromTagID(pdb, tiWhich)) != TAG_TYPE_BINARY) {
        DBGPRINT((sdlError,
                  "SdbGetBinaryTagData",
                  "TagID 0x%08X, Tag %04X not BINARY type.\n",
                  tiWhich,
                  (DWORD)SdbGetTagFromTagID(pdb, tiWhich)));
        return NULL;
    }

    return SdbpGetMappedTagData(pdb, tiWhich);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\ntbaseplus.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        ntbaseplus.c

    Abstract:

        This module implements low level primitives. They should never be
        called by anything other than this module.

    Author:

        dmunsil     created     sometime in 1999

    Revision History:

        several people contributed (vadimb, clupu, ...)

        kinshu  -   01/10/2002  -   Fixed a bug in the circular linked list
                                    insertion and deletion routines(InsertLookup,
                                    RemoveLookup)

--*/

#include "sdbp.h"

UNICODE_STRING g_ustrDatabasePath          = RTL_CONSTANT_STRING(L"DatabasePath");
UNICODE_STRING g_ustrDatabaseType          = RTL_CONSTANT_STRING(L"DatabaseType");
UNICODE_STRING g_ustrDatabaseDescription   = RTL_CONSTANT_STRING(L"DatabaseDescription");
UNICODE_STRING g_ustrInstallTimeStamp      = RTL_CONSTANT_STRING(L"DatabaseInstallTimeStamp");

UNICODE_STRING g_ustrDebugPipeName         = RTL_CONSTANT_STRING(L"\\Device\\NamedPipe\\ShimViewer");

extern TCHAR g_szCompatLayer[];

//
// Global flag for wow64. On Win2k we zero this flag out
//
DWORD volatile g_dwWow64Key = (DWORD)-1;


typedef NTSTATUS
(SDBAPI* PFNEnsureBufferSize)(
    IN ULONG           Flags,
    IN OUT PRTL_BUFFER Buffer,
    IN SIZE_T          Size);

PFNEnsureBufferSize volatile g_pfnEnsureBufferSize = NULL;

NTSTATUS
SDBAPI
SdbEnsureBufferSizeFunction(
    IN ULONG           Flags,
    IN OUT PRTL_BUFFER Buffer,
    IN SIZE_T          Size);

//
// to work on win2k, we have to modify default buffer-manipulation macro
//
#undef RtlEnsureBufferSize
#define RtlEnsureBufferSize(Flags, Buff, NewSizeBytes) \
    (   ((Buff) != NULL && (NewSizeBytes) <= (Buff)->Size) \
        ? STATUS_SUCCESS \
        : SdbEnsureBufferSizeFunction((Flags), (Buff), (NewSizeBytes)) \
    )




//
// This routine was stolen from buffer.c in ntdll so that we can support downlevel platforms
//
NTSTATUS
SDBAPI
SdbpEnsureBufferSize(
    IN ULONG           Flags,
    IN OUT PRTL_BUFFER Buffer,
    IN SIZE_T          Size
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR   Temp = NULL;

    if ((Flags & ~(RTL_ENSURE_BUFFER_SIZE_NO_COPY)) != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (Buffer == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (Size <= Buffer->Size) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    //
    // Size <= Buffer->StaticSize does not imply static allocation, it
    // could be heap allocation that the client poked smaller.
    //
    if (Buffer->Buffer == Buffer->StaticBuffer && Size <= Buffer->StaticSize) {
        Buffer->Size = Size;
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    //
    // The realloc case was messed up in Whistler, and got removed.
    // Put it back in Blackcomb.
    //
    Temp = (PUCHAR)RtlAllocateHeap(RtlProcessHeap(), 0, (Size));
    if (Temp == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    if ((Flags & RTL_ENSURE_BUFFER_SIZE_NO_COPY) == 0) {
        RtlCopyMemory(Temp, Buffer->Buffer, Buffer->Size);
    }

    if (RTLP_BUFFER_IS_HEAP_ALLOCATED(Buffer)) {
        RtlFreeHeap(RtlProcessHeap(), 0, Buffer->Buffer);
        Buffer->Buffer = NULL;
    }

    ASSERT(Temp != NULL);
    Buffer->Buffer = Temp;
    Buffer->Size = Size;
    Status = STATUS_SUCCESS;

Exit:
    return Status;
}


#define KEY_MACHINE TEXT("\\Registry\\Machine")


BOOL
SdbpBuildMachineKeyPath(
    IN  LPCWSTR         pwszPath,
    OUT PUNICODE_STRING pmachineKeyPath
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Given a path to the key it builds it up for HKEY_LOCAL_MACHINE
            registry. The buffer used by pmachineKeyPath will have to be freed
            using SdbFree!
--*/
{
    BOOL           bReturn = FALSE;
    NTSTATUS       Status;
    UNICODE_STRING machineKey = {0};

    RtlInitUnicodeString(&machineKey, KEY_MACHINE);

    pmachineKeyPath->Length = 0;
    pmachineKeyPath->MaximumLength = wcslen(pwszPath) * sizeof(*pwszPath) +
                                        machineKey.Length +
                                        sizeof(UNICODE_NULL);

    pmachineKeyPath->Buffer = SdbAlloc(pmachineKeyPath->MaximumLength);

    if (pmachineKeyPath->Buffer == NULL) {
        DBGPRINT((sdlError,
                  "SdbpBuildUserKeyPath",
                  "Failed to allocate %d bytes for user key buffer.\n",
                  pmachineKeyPath->MaximumLength));
        goto out;
    }

    RtlAppendUnicodeStringToString(pmachineKeyPath, &machineKey);
    RtlAppendUnicodeToString(pmachineKeyPath, pwszPath);
    bReturn = TRUE;

out:
    return bReturn;
}


BOOL
SdbpBuildUserKeyPath(
    IN  LPCWSTR         pwszPath,
    OUT PUNICODE_STRING puserKeyPath
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Given a path to the key it builds it up for HKEY_CURRENT_USER
            registry. The buffer used by puserKeyPath will have to be freed
            using SdbFree!
--*/
{
    BOOL           bReturn = FALSE;
    NTSTATUS       Status;
    UNICODE_STRING userKey = {0};

    Status = RtlFormatCurrentUserKeyPath(&userKey);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbpBuildUserKeyPath",
                  "Failed to format current user key path 0x%x\n",
                  Status));
        goto out;
    }

    puserKeyPath->Length = 0;
    puserKeyPath->MaximumLength = wcslen(pwszPath) * sizeof(*pwszPath) +
                                    userKey.Length +
                                    sizeof(UNICODE_NULL);

    puserKeyPath->Buffer = SdbAlloc(puserKeyPath->MaximumLength);

    if (puserKeyPath->Buffer == NULL) {
        DBGPRINT((sdlError,
                  "SdbpBuildUserKeyPath",
                  "Failed to allocate %d bytes for user key buffer.\n",
                  puserKeyPath->MaximumLength));
        goto out;
    }

    RtlAppendUnicodeStringToString(puserKeyPath, &userKey);
    RtlAppendUnicodeToString(puserKeyPath, pwszPath);
    bReturn = TRUE;

out:
    RtlFreeUnicodeString(&userKey);
    return bReturn;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// Custom SDB cache code
//

PUSERSDBLOOKUP
SdbpFindSDBLookupEntry(
    IN PSDBCONTEXT pSdbContext,          // sdb context for searches
    IN LPCWSTR     pwszItemName,         // item name foo.exe for instance
    IN BOOL        bLayer                // true if Layer
    )
{
    PUSERSDBLOOKUP pLookup = pSdbContext->pLookupHead;

    if (pLookup == NULL) {
        return NULL;
    }

    do {
        if (!_wcsicmp(pLookup->pwszItemName, pwszItemName) && pLookup->bLayer == bLayer) {
            return pLookup;
        }

        pLookup = pLookup->pNext;

    } while (pLookup != pSdbContext->pLookupHead);

    return NULL;
}


void
RemoveLookup(
    PSDBCONTEXT    pSdbContext,
    PUSERSDBLOOKUP pLookup
    )
{
    assert(pLookup);

    if (pLookup->pPrev == pLookup) {
        //
        // There is only one element
        //
        pSdbContext->pLookupHead = NULL;
        SdbFree(pLookup);
        return;
    }

    if (pSdbContext->pLookupHead == pLookup) {
        //
        // We are deleting the first element
        //
        pSdbContext->pLookupHead = pLookup->pNext;
    }

    pLookup->pPrev->pNext = pLookup->pNext;
    pLookup->pNext->pPrev = pLookup->pPrev;

    SdbFree(pLookup);
}

void
InsertLookup(
    PSDBCONTEXT    pSdbContext,
    PUSERSDBLOOKUP pLookup
    )
{
    assert(pLookup);

    if (pSdbContext->pLookupHead == NULL) {
        pSdbContext->pLookupHead = pLookup;
        pLookup->pPrev = pLookup;
        pLookup->pNext = pLookup;
        return;
    }

    pLookup->pNext = pSdbContext->pLookupHead;
    pLookup->pPrev = pSdbContext->pLookupHead->pPrev;

    //
    // The pNext of the last element (pSdbContext->pLookupHead->pPrev) should point to the
    // new element
    //
    pSdbContext->pLookupHead->pPrev->pNext = pLookup;
    pSdbContext->pLookupHead->pPrev        = pLookup;

    pSdbContext->pLookupHead = pLookup;
}

PUSERSDBLOOKUP
SdbpCreateSDBLookupEntry(
    IN PSDBCONTEXT pSdbContext,
    IN DWORD       dwCount,
    IN LPCWSTR     pwszItemName,
    IN BOOL        bLayer
    )
{
    DWORD          dwSize;
    PUSERSDBLOOKUP pLookup;

    pLookup = SdbpFindSDBLookupEntry(pSdbContext, pwszItemName, bLayer);
    if (pLookup != NULL) {

        //
        // cornel: If we already have it shouldn't we just return here ?
        //
        assert(pLookup->dwCount == dwCount);
        RemoveLookup(pSdbContext, pLookup);
    }

    //
    // One entry is already included. See the structure definition.
    //
    // The memory layout is:
    //
    //    USERSDBLOOKUP
    //    (dwCount - 1) USERSDBLOOKUPENTRY structures
    //    the string that pLookup->pwszItemName points to
    //
    dwSize = sizeof(USERSDBLOOKUP) +
             (wcslen(pwszItemName) + 1) * sizeof(WCHAR) +
             (dwCount - 1) * sizeof(USERSDBLOOKUPENTRY);  // one is already included

    pLookup = (PUSERSDBLOOKUP)SdbAlloc(dwSize);

    if (pLookup == NULL) {
        DBGPRINT((sdlError,
                  "SdbpCreateSDBLookupEntry",
                  "Failed to allocate 0x%lx bytes for sdb lookup buffer\n",
                  dwSize));
        return NULL;
    }

    pLookup->pwszItemName = (LPWSTR)((PBYTE)(pLookup + 1) +
                                     (dwCount - 1) * sizeof(USERSDBLOOKUPENTRY));

    pLookup->bLayer  = bLayer;
    pLookup->dwCount = dwCount;

    wcscpy(pLookup->pwszItemName, pwszItemName);

    InsertLookup(pSdbContext, pLookup);

    return pLookup;
}


void
SdbpCleanupUserSDBCache(
    IN PSDBCONTEXT pSdbContext
    )
{
    while (pSdbContext->pLookupHead) {
        RemoveLookup(pSdbContext, pSdbContext->pLookupHead);
    }
}

//
// We built the array of these in accordance with ValueName's corresponding to a
// list of custom databases we have -- and query existing values for this particular entry
// ValueBuffer shall be allocated to be of a maximum length considering the number
// of the entries that we have
//
typedef int (__cdecl* PFNQSORTCOMPARE)(const void* pElem1, const void* pElem2);

int __cdecl
SdbpUserSDBLookupCompareEntries(
    LPCVOID pEntry1,
    LPCVOID pEntry2
    )
{
    //
    // last-installed goes first
    //
    PUSERSDBLOOKUPENTRY pLookupEntry1 = (PUSERSDBLOOKUPENTRY)pEntry1;
    PUSERSDBLOOKUPENTRY pLookupEntry2 = (PUSERSDBLOOKUPENTRY)pEntry2;


    if (pLookupEntry1->liTimeStamp.QuadPart < pLookupEntry2->liTimeStamp.QuadPart) {
        return 1;
    }

    if (pLookupEntry1->liTimeStamp.QuadPart == pLookupEntry2->liTimeStamp.QuadPart) {
        return 0;
    }

    return -1;

}

NTSTATUS
SDBAPI
SdbpFindCharInUnicodeString(
    ULONG            Flags,
    PCUNICODE_STRING StringToSearch,
    PCUNICODE_STRING CharSet,
    USHORT*          NonInclusivePrefixLength
    )
{
    LPCWSTR pch;

    //
    // Implement only the case when we move backwards
    //
    if (Flags != RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END) {
        return STATUS_NOT_IMPLEMENTED;
    }

    pch = StringToSearch->Buffer + StringToSearch->Length / sizeof(WCHAR);

    while (pch >= StringToSearch->Buffer) {

        if (_tcschr(CharSet->Buffer, *pch)) {
            //
            // Got the char
            //
            if (NonInclusivePrefixLength) {
                *NonInclusivePrefixLength = (USHORT)(pch - StringToSearch->Buffer) * sizeof(WCHAR);
            }

            return STATUS_SUCCESS;
        }

        pch--;
    }

    //
    // We haven't found it. Return failure.
    //
    return STATUS_NOT_FOUND;
}


BOOL
SdbpEnumUserSdb(
    IN  PSDBCONTEXT     pSdbContext,
    IN  LPCWSTR         wszItemName, // file name of an exe or the layer name
    IN  BOOL            bLayer,
    OUT PUSERSDBLOOKUP* ppSdbLookup
    )
{
    //
    // This is how we figure:
    // path + \\layers\\ + MAX_PATH (for name)
    //
    WCHAR FullKeyBuffer[sizeof(APPCOMPAT_KEY_PATH_MACHINE_CUSTOM)/sizeof(WCHAR) + 8 + MAX_PATH];

    OBJECT_ATTRIBUTES ObjectAttributes;

    struct {
        KEY_FULL_INFORMATION KeyFullInformation;
        WCHAR  Buffer[MAX_PATH];
    } KeyInformationBuffer;

    PKEY_FULL_INFORMATION pFullInfo = &KeyInformationBuffer.KeyFullInformation;

    struct {
        KEY_VALUE_FULL_INFORMATION KeyValueFullInformation;
        BYTE Buffer[MAX_PATH * 2 * sizeof(WCHAR)];
    } KeyValueInformationBuffer;

    PKEY_VALUE_FULL_INFORMATION pValue = &KeyValueInformationBuffer.KeyValueFullInformation;

    PBYTE               pData;
    PUSERSDBLOOKUPENTRY pEntry;
    ULONG               ResultLength;
    ULONG               KeyValueLength;
    DWORD               dwIndexValue   = 0;
    DWORD               dwIndexEntries = 0;
    ULONG               nIndex;
    NTSTATUS            Status;
    HANDLE              KeyHandle = NULL;
    UNICODE_STRING      ustrDbGuid;
    USHORT              uPrefix = 0;
    UNICODE_STRING      ustrFullKey;
    UNICODE_STRING      ustrValue;
    UNICODE_STRING      ustrCharDot = RTL_CONSTANT_STRING(L".");
    GUID                guidDB;
    PUSERSDBLOOKUP      pLookup  = NULL;
    BOOL                bSuccess = FALSE;
    ULARGE_INTEGER      liTimeStamp;

    ustrFullKey.Length = 0;
    ustrFullKey.Buffer = FullKeyBuffer;
    ustrFullKey.MaximumLength = sizeof(FullKeyBuffer);

    RtlAppendUnicodeToString(&ustrFullKey, APPCOMPAT_KEY_PATH_MACHINE_CUSTOM);

    if (bLayer) {
        RtlAppendUnicodeToString(&ustrFullKey, L"\\Layers\\");
    } else {
        RtlAppendUnicodeToString(&ustrFullKey, L"\\");
    }

    RtlAppendUnicodeToString(&ustrFullKey, wszItemName);

    InitializeObjectAttributes(&ObjectAttributes,
                               &ustrFullKey,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&KeyHandle, GENERIC_READ|SdbpGetWow64Flag(), &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlWarning,
                  "SdbpEnumUserSdb",
                  "Failed to open key \"%s\" Status 0x%lx\n",
                  ustrFullKey.Buffer,
                  Status));
        goto cleanup;
    }

    Status = NtQueryKey(KeyHandle,
                        KeyFullInformation,
                        &KeyInformationBuffer,
                        sizeof(KeyInformationBuffer),
                        &ResultLength);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlWarning,
                  "SdbpEnumUserSdb",
                  "Failed to query key \"%s\" Status 0x%lx\n",
                  ustrFullKey.Buffer,
                  Status));
        goto cleanup;
    }

    if (pFullInfo->Values == 0) {
        goto cleanup; // nothing to look at
    }

    //
    // Create new lookup item
    //
    pLookup = SdbpCreateSDBLookupEntry(pSdbContext, pFullInfo->Values, wszItemName, bLayer);
    if (pLookup == NULL) {
        //
        // Oops, can't have an entry -- can't do lookups
        //
        goto cleanup;
    }

    //
    // Load all the values
    //
    for (dwIndexValue = 0; dwIndexValue < pFullInfo->Values; dwIndexValue++) {

        Status = NtEnumerateValueKey(KeyHandle,
                                     dwIndexValue,
                                     KeyValueFullInformation,
                                     &KeyValueInformationBuffer,
                                     sizeof(KeyValueInformationBuffer),
                                     &KeyValueLength);

        if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlWarning,
                      "SdbpEnumUserSdb",
                      "Failed to enum value index 0x%lx Status 0x%lx\n",
                      dwIndexValue,
                      Status));
            continue;
        }

        //
        // Extract database guid
        //
        ustrDbGuid.Buffer        = &pValue->Name[0];
        ustrDbGuid.MaximumLength =
        ustrDbGuid.Length        = (USHORT)pValue->NameLength;

        Status = SdbpFindCharInUnicodeString(RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END,
                                             &ustrDbGuid,
                                             &ustrCharDot,
                                             &uPrefix);
        if (NT_SUCCESS(Status)) {
            ustrDbGuid.Length = uPrefix;
        }

        //
        // Convert to guid
        //
        Status = RtlGUIDFromString(&ustrDbGuid, &guidDB);
        if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlWarning, "SdbpEnumUserSdb",
                       "Failed to convert db name \"%s\" to guid Status 0x%lx\n",
                       ustrDbGuid.Buffer, Status));

            continue; // We have failed to convert, skip and do the next
        }

        //
        // Data may not be aligned, we store here timestamp
        //
        pData = (PBYTE)pValue + pValue->DataOffset;

        //
        // Check out value type
        //
        switch (pValue->Type) {

        case REG_BINARY:
            //
            // The value is likely a timestamp
            //
            if (pValue->DataLength < sizeof(liTimeStamp.QuadPart)) {
                DBGPRINT((sdlError,
                          "SdbpEnumUserSdb",
                          "Data length (0x%lx) does not match timestamp length for index 0x%lx\n",
                          pValue->DataLength,
                          dwIndexValue));
                liTimeStamp.QuadPart = 0;
            } else {
                RtlCopyMemory(&liTimeStamp.QuadPart, (LPCVOID)pData, sizeof(liTimeStamp.QuadPart));
            }
            break;

        case REG_QWORD:
            //
            // Naturally supported type, not aligned though
            //
            liTimeStamp.QuadPart = *(PULONGLONG UNALIGNED)pData;
            break;

        case REG_SZ:

            //
            // Hack: in case we need to enforce a particular order on some odd entry -- we
            // use this hack
            //
            liTimeStamp.QuadPart = 0;

            if (pValue->DataLength > 0) {
                ustrValue.Buffer        = (WCHAR*)pData;
                ustrValue.Length        = (USHORT)pValue->DataLength - sizeof(UNICODE_NULL);
                ustrValue.MaximumLength = (USHORT)pValue->DataLength;

                Status = RtlUnicodeStringToInteger(&ustrValue, 0, &liTimeStamp.LowPart);

                if (!NT_SUCCESS(Status)) {
                    DBGPRINT((sdlWarning,
                              "SdbpEnumUserSdb",
                              "Bad value for \"%s\" -> \"%s\" for index 0x%lx\n",
                              pValue->Name,
                              (LPCWSTR)pData,
                              dwIndexValue));
                }
            }
            break;

        default:
            //
            // Error case
            //
            DBGPRINT((sdlError,
                      "SdbpEnumUserSdb",
                      "Bad value type 0x%lx for index 0x%lx\n",
                      pValue->Type,
                      dwIndexValue));
            Status = STATUS_INVALID_PARAMETER; // bugbug
            break;
        }

        //
        // Check the status
        //
        if (!NT_SUCCESS(Status)) {
            continue;
        }

        //
        // Fill-in this entry
        //
        pEntry = &pLookup->rgEntries[dwIndexEntries];
        ++dwIndexEntries;

        RtlCopyMemory(&pEntry->guidDB, &guidDB, sizeof(GUID));
        pEntry->liTimeStamp.QuadPart = liTimeStamp.QuadPart;
    }

    //
    // After this, we are basically ready to lookup entries in sdbs
    //
    pLookup->dwCount = dwIndexEntries; // adjust count based on actually filled-in entries

    if (dwIndexEntries > 1) {
        //
        // Optimization: only sort if more than one entry.
        //
        qsort((void*)&pLookup->rgEntries[0],
              (size_t)pLookup->dwCount,
              (size_t)sizeof(USERSDBLOOKUPENTRY),
              (PFNQSORTCOMPARE)SdbpUserSDBLookupCompareEntries);
    }

    if (ppSdbLookup) {
        *ppSdbLookup = pLookup;
    }

    bSuccess = TRUE;

cleanup:

    if (KeyHandle) {
        NtClose(KeyHandle);
    }

    if (!bSuccess && pLookup != NULL) {
        RemoveLookup(pSdbContext, pLookup);
    }

    return bSuccess;
}

BOOL
SdbGetNthUserSdb(
    IN HSDB        hSDB,
    IN LPCWSTR     wszItemName, // item name (foo.exe or layer name)
    IN BOOL        bLayer,
    IN OUT LPDWORD pdwIndex,    // (0-based)
    OUT GUID*      pGuidDB
    )
{
    PSDBCONTEXT    pSdbContext = (PSDBCONTEXT)hSDB;
    PUSERSDBLOOKUP pLookup     = NULL;
    BOOL           bSuccess    = FALSE;
    DWORD          nIndex      = *pdwIndex;

    //
    // Context already may have a user sdb cache -- do not touch it
    //
    if (nIndex == 0) {

        //
        // The first call, we have to init our system
        //
        if (!SdbpEnumUserSdb(pSdbContext, wszItemName, bLayer, &pLookup)) {
            goto cleanup; // no custom sdb will be accessible
        }

    } else {
        pLookup = SdbpFindSDBLookupEntry(pSdbContext, wszItemName, bLayer);
    }

    if (pLookup == NULL || nIndex >= pLookup->dwCount) {
        return FALSE;
    }

    RtlCopyMemory(pGuidDB, &pLookup->rgEntries[nIndex].guidDB, sizeof(*pGuidDB));
    ++nIndex;
    bSuccess = TRUE;

    *pdwIndex = nIndex;

cleanup:

   return bSuccess;
}


#ifndef WIN32U_MODE

BOOL
SDBAPI
SdbpGetLongPathName(
    IN  LPCWSTR                    pwszPath,
    OUT PRTL_UNICODE_STRING_BUFFER pBuffer
    )
{
    DWORD    dwBufferSize;
    NTSTATUS Status;

    RtlSyncStringToBuffer(pBuffer);

    dwBufferSize = GetLongPathNameW(pwszPath,
                                    pBuffer->String.Buffer,
                                    RTL_STRING_GET_MAX_LENGTH_CHARS(&pBuffer->String));
    if (!dwBufferSize) {
        DBGPRINT((sdlError,
                  "SdbpGetLongPathName",
                  "Failed to convert short path to long path error 0x%lx\n",
                  GetLastError()));
        return FALSE;
    }

    if (dwBufferSize < RTL_STRING_GET_MAX_LENGTH_CHARS(&pBuffer->String)) {
        goto Done;
    }

    Status = RtlEnsureUnicodeStringBufferSizeChars(pBuffer, dwBufferSize);
    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbpGetLongPathName",
                  "Failed to obtain sufficient buffer for long path (0x%lx chars) status 0x%lx\n",
                  dwBufferSize,
                  Status));
        return FALSE;
    }

    dwBufferSize = GetLongPathNameW(pwszPath,
                                    pBuffer->String.Buffer,
                                    RTL_STRING_GET_MAX_LENGTH_CHARS(&pBuffer->String));

    if (!dwBufferSize || dwBufferSize > RTL_STRING_GET_MAX_LENGTH_CHARS(&pBuffer->String)) {
        DBGPRINT((sdlError,
                  "SdbpGetLongPathName",
                  "Failed to convert short path to long path (0x%lx chars) error 0x%lx\n",
                  dwBufferSize,
                  GetLastError()));
        return FALSE;
    }

Done:

    pBuffer->String.Length = (USHORT)dwBufferSize;
    return TRUE;
}

void
SdbpGetPermLayersInternal(
    IN     PUNICODE_STRING pstrExePath,
    OUT    LPWSTR          wszLayers, // output receives layers string if success
    IN OUT LPDWORD         pdwBytes,  // pointer to the size of wszLayers buffer
    IN     BOOL            bMachine
    )
{
    UNICODE_STRING      strKeyPath = { 0 };
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE              KeyHandle;
    ULONG               KeyValueBuffer[256];
    ULONG               KeyValueLength;
    NTSTATUS            Status;
    DWORD               dwBytes = *pdwBytes;

    PKEY_VALUE_PARTIAL_INFORMATION  KeyValueInformation;

    *pdwBytes = 0;

    if (bMachine) {
        //
        // Build the machine path
        //
        if (!SdbpBuildMachineKeyPath(APPCOMPAT_PERM_LAYER_PATH, &strKeyPath)) {
            DBGPRINT((sdlError,
                      "SdbpGetPermLayersInternal",
                      "Failed to format machine key path for \"%S\"\n",
                      APPCOMPAT_PERM_LAYER_PATH));
            goto out;
        }

    } else {
        if (!SdbpBuildUserKeyPath(APPCOMPAT_PERM_LAYER_PATH, &strKeyPath)) {
            DBGPRINT((sdlError,
                      "SdbpGetPermLayersInternal",
                      "Failed to format user key path for \"%S\"\n",
                      APPCOMPAT_PERM_LAYER_PATH));
            goto out;
        }
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               &strKeyPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&KeyHandle, GENERIC_READ|SdbpGetWow64Flag(), &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlInfo,
                  "SdbpGetPermLayersInternal",
                  "Failed to open Key \"%S\" Status 0x%x\n",
                  strKeyPath.Buffer,
                  Status));
        goto out;
    }

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;

    Status = NtQueryValueKey(KeyHandle,
                             pstrExePath,
                             KeyValuePartialInformation,
                             KeyValueInformation,
                             sizeof(KeyValueBuffer),
                             &KeyValueLength);

    NtClose(KeyHandle);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlInfo,
                  "SdbpGetPermLayersInternal",
                  "Failed to read value info from Key \"%S\" Status 0x%x\n",
                  strKeyPath.Buffer,
                  Status));
        goto out;
    }

    //
    // Check for the value type.
    //
    if (KeyValueInformation->Type != REG_SZ) {
        DBGPRINT((sdlError,
                  "SdbpGetPermLayersInternal",
                  "Unexpected value type 0x%x for Key \"%S\".\n",
                  KeyValueInformation->Type,
                  strKeyPath.Buffer));
        goto out;
    }

    if (wszLayers == NULL || KeyValueInformation->DataLength > dwBytes) {
        DBGPRINT((sdlError,
                  "SdbpGetPermLayersInternal",
                  "Value length %d too long for key \"%S\".\n",
                  KeyValueInformation->DataLength,
                  strKeyPath.Buffer));

        *pdwBytes = KeyValueInformation->DataLength;
        goto out;
    }

    RtlMoveMemory(wszLayers, KeyValueInformation->Data, KeyValueInformation->DataLength);
    *pdwBytes = KeyValueInformation->DataLength;

out:
    if (strKeyPath.Buffer != NULL) {
        SdbFree(strKeyPath.Buffer);
    }
}

BOOL
SdbGetPermLayerKeys(
    IN  LPCWSTR  pwszPath,      // exe path
    OUT LPWSTR   pwszLayers,    // output receives layers string if success
    IN  LPDWORD  pdwBytes,      // pointer to the size of wszLayers buffer
    IN  DWORD    dwFlags        // per machine, per user flags
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Retrieves layers string associated with a given exe.
            wszLayers may be NULL. In that case pdwBytes will receive necessary
            size if the size provided in pdwBytes is not sufficient. The function
            will return TRUE and pdwBytes will contain the necessary size.
--*/
{
    UNICODE_STRING      ustrPath;
    BOOL                bRet = FALSE;
    WCHAR               wszSignPath[MAX_PATH];
    LPCWSTR             pwszNewPath;
    UCHAR               PathBuffer[MAX_PATH * 2];
    DWORD               dwBytesMachine, dwBytesUser;
    RTL_UNICODE_STRING_BUFFER LongPath;

    RtlInitUnicodeStringBuffer(&LongPath, PathBuffer, sizeof(PathBuffer));

    if (!pwszPath || !pdwBytes) {
        DBGPRINT((sdlError,
                  "SdbGetPermLayerKeys",
                  "NULL parameter passed for wszPath or pdwBytes.\n"));
        goto out;
    }

    if (!SdbpGetLongPathName(pwszPath, &LongPath)) {
        goto out;
    }

    pwszPath = LongPath.String.Buffer;

    if (SdbpIsPathOnCdRom(pwszPath)) {

        SdbpBuildSignature(pwszPath, wszSignPath);

        pwszNewPath = wszSignPath;
    } else {
        pwszNewPath = pwszPath;
    }

    RtlInitUnicodeString(&ustrPath, pwszNewPath);

    dwBytesMachine = 0;
    dwBytesUser = 0;

    if (dwFlags & GPLK_MACHINE) {

        dwBytesMachine = *pdwBytes;

        SdbpGetPermLayersInternal(&ustrPath, pwszLayers, &dwBytesMachine, TRUE);
    }

    if (dwFlags & GPLK_USER) {

        if (dwBytesMachine != 0) {
            if (pwszLayers != NULL) {
                pwszLayers += (dwBytesMachine / sizeof(TCHAR) - 1);
                *pwszLayers++ = TEXT(' ');
            }

            dwBytesMachine += sizeof(TCHAR);
        }

        if (pwszLayers != NULL) {
            dwBytesUser = *pdwBytes - dwBytesMachine;
        }

        SdbpGetPermLayersInternal(&ustrPath, pwszLayers, &dwBytesUser, FALSE);

        if (dwBytesUser == 0 && dwBytesMachine != 0) {
            dwBytesMachine -= sizeof(TCHAR);

            if (pwszLayers != NULL) {
                *(--pwszLayers) = 0;
            }
        }
    }

    if (pwszLayers != NULL) {
        if (*pdwBytes >= dwBytesMachine + dwBytesUser) {
            bRet = TRUE;
        }
    } else {
        bRet = TRUE;
    }

    *pdwBytes = dwBytesMachine + dwBytesUser;

    if (*pdwBytes == 0) {
        bRet = FALSE;
    }

out:

    RtlFreeUnicodeStringBuffer(&LongPath);

    return bRet;
}

#else // WIN32U_MODE case, stub the perm layer api

BOOL
SdbGetPermLayerKeys(
    IN  LPCTSTR  szPath,
    OUT LPTSTR   szLayers,
    IN  LPDWORD  pdwBytes,
    IN  DWORD    dwFlags
    )
{
    return FALSE;
}

#endif // WIN32U_MODE

HANDLE
SdbpCreateKeyPath(
    LPCWSTR pwszPath,
    BOOL    bMachine
    )
/*++
    Return: The handle to the registry key created.

    Desc:   Given a path to the key relative to HKEY_CURRENT_USER open/create
            the key returns the handle to the key or NULL on failure.
--*/
{
    UNICODE_STRING    strKeyPath = { 0 };
    HANDLE            KeyHandle = NULL;
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG             CreateDisposition;

    if (bMachine) {
        if (!SdbpBuildMachineKeyPath(pwszPath, &strKeyPath)) {
            DBGPRINT((sdlError,
                      "SdbCreateKeyPath",
                      "Failed to format machine key path for \"%s\"\n",
                      pwszPath));
            goto out;
        }
    } else {
        if (!SdbpBuildUserKeyPath(pwszPath, &strKeyPath)) {
            DBGPRINT((sdlError,
                      "SdbCreateKeyPath",
                      "Failed to format user key path for \"%s\"\n",
                      pwszPath));
            goto out;
        }
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               &strKeyPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtCreateKey(&KeyHandle,
                         STANDARD_RIGHTS_WRITE |
                            KEY_QUERY_VALUE |
                            KEY_ENUMERATE_SUB_KEYS |
                            KEY_SET_VALUE |
                            KEY_CREATE_SUB_KEY|
                            SdbpGetWow64Flag(),
                         &ObjectAttributes,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         &CreateDisposition);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbCreateKeyPath",
                  "NtCreateKey failed for \"%s\" Status 0x%x\n",
                  pwszPath,
                  Status));
        KeyHandle = NULL;
        goto out;
    }

out:
    if (strKeyPath.Buffer != NULL) {
        SdbFree(strKeyPath.Buffer);
    }

    return KeyHandle;
}

#ifndef WIN32U_MODE

BOOL
SdbSetPermLayerKeys(
    IN  LPCWSTR wszPath,        // application path
    IN  LPCWSTR wszLayers,      // layers to associate with this application
    IN  BOOL    bMachine        // TRUE if the layers should be set per machine
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Associates wszLayers string with application wszPath.
--*/
{
    UNICODE_STRING ustrPath;
    NTSTATUS       Status;
    HANDLE         KeyHandle;
    BOOL           bRet = FALSE;
    WCHAR          wszSignPath[MAX_PATH];
    LPCWSTR        pwszPath;
    RTL_UNICODE_STRING_BUFFER LongPath;
    UCHAR          PathBuffer[MAX_PATH * 2];

    if (!wszLayers || !wszLayers[0]) {
        //
        // They passed in an empty string -- delete the layer keys
        //
        return SdbDeletePermLayerKeys(wszPath, bMachine);
    }

    RtlInitUnicodeStringBuffer(&LongPath, PathBuffer, sizeof(PathBuffer));

    if (!SdbpGetLongPathName(wszPath, &LongPath)) {
        goto out;
    }

    wszPath = LongPath.String.Buffer;

    if (SdbpIsPathOnCdRom(wszPath)) {

        SdbpBuildSignature(wszPath, wszSignPath);

        pwszPath = wszSignPath;
    } else {
        pwszPath = wszPath;
    }

    RtlInitUnicodeString(&ustrPath, pwszPath);

    KeyHandle = SdbpCreateKeyPath(APPCOMPAT_KEY_PATH_NT, bMachine);

    if (KeyHandle == NULL) {
        DBGPRINT((sdlError,
                  "SdbSetPermLayerKeys",
                  "Failed to create user key path for \"%s\"\n",
                  APPCOMPAT_KEY_PATH_NT));
        goto out;
    }

    NtClose(KeyHandle);

    KeyHandle = SdbpCreateKeyPath(APPCOMPAT_PERM_LAYER_PATH, bMachine);

    if (KeyHandle == NULL) {
        DBGPRINT((sdlError,
                  "SdbSetPermLayerKeys",
                  "Failed to create user key path \"%s\"\n",
                  APPCOMPAT_PERM_LAYER_PATH));
        goto out;
    }

    Status = NtSetValueKey(KeyHandle,
                           &ustrPath,
                           0,
                           REG_SZ,
                           (PVOID)wszLayers,
                           (wcslen(wszLayers) + 1) * sizeof(WCHAR));
    NtClose(KeyHandle);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbSetPermLayerKeys",
                  "Failed NtSetValueKey status 0x%x\n",
                  Status));
        goto out;
    }

    bRet = TRUE;

out:

    RtlFreeUnicodeStringBuffer(&LongPath);
    return bRet;
}

BOOL
SdbDeletePermLayerKeys(
    IN LPCWSTR wszPath,
    IN BOOL    bMachine
    )
/*++
    Return: TRUE if success

    Desc:   This function is used to disable permanent layer storage entry
            for the application.
--*/
{
    UNICODE_STRING      strKeyPath = { 0 };
    UNICODE_STRING      ustrPath;
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE              KeyHandle;
    BOOL                bRet = FALSE;
    WCHAR               wszSignPath[MAX_PATH];
    LPCWSTR             pwszPath;

    PKEY_VALUE_PARTIAL_INFORMATION  KeyValueInformation;
    RTL_UNICODE_STRING_BUFFER       LongPath;
    UCHAR                           PathBuffer[MAX_PATH * 2];

    RtlInitUnicodeStringBuffer(&LongPath, PathBuffer, sizeof(PathBuffer));

    if (!SdbpGetLongPathName(wszPath, &LongPath)) {
        goto out;
    }

    wszPath = LongPath.String.Buffer;

    if (SdbpIsPathOnCdRom(wszPath)) {

        SdbpBuildSignature(wszPath, wszSignPath);

        pwszPath = wszSignPath;
    } else {
        pwszPath = wszPath;
    }

    RtlInitUnicodeString(&ustrPath, pwszPath);

    if (bMachine) {
        if (!SdbpBuildMachineKeyPath(APPCOMPAT_PERM_LAYER_PATH, &strKeyPath)) {
            DBGPRINT((sdlError,
                      "SdbDeletePermLayerKeys",
                      "Failed to format machine key path for \"%S\"\n",
                      APPCOMPAT_PERM_LAYER_PATH));
            goto out;
        }
    } else {
        if (!SdbpBuildUserKeyPath(APPCOMPAT_PERM_LAYER_PATH, &strKeyPath)) {
            DBGPRINT((sdlError,
                      "SdbDeletePermLayerKeys",
                      "Failed to format user key path for \"%S\"\n",
                      APPCOMPAT_PERM_LAYER_PATH));
            goto out;
        }
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               &strKeyPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&KeyHandle,
                       KEY_WRITE|SdbpGetWow64Flag(),
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlInfo,
                  "SdbDeletePermLayerKeys",
                  "Failed to open Key for \"%S\" Status 0x%x\n",
                  strKeyPath.Buffer,
                  Status));
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            bRet = TRUE;
        }
        goto out;
    }

    Status = NtDeleteValueKey(KeyHandle,
                              &ustrPath);

    NtClose(KeyHandle);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlInfo,
                  "SdbDeletePermLayerKeys",
                  "Failed to delete value from Key \"%S\" Status 0x%x\n",
                  strKeyPath.Buffer,
                  Status));
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            bRet = TRUE;
        }
        goto out;
    }

    bRet = TRUE;

out:

    if (strKeyPath.Buffer != NULL) {
        SdbFree(strKeyPath.Buffer);
    }

    RtlFreeUnicodeStringBuffer(&LongPath);
    return bRet;

}

#endif // WIN32U_MODE

BOOL
SdbSetEntryFlags(
    IN  GUID* pGuidID,
    IN  DWORD dwFlags
    )
/*++
    Return: TRUE if success

    Desc:   This function is used to disable apphelp or shim entries.
--*/
{

    UNICODE_STRING ustrExeID = { 0 };
    NTSTATUS       Status;
    HANDLE         KeyHandle;
    BOOL           bReturn = FALSE;

    Status = GUID_TO_UNICODE_STRING(pGuidID, &ustrExeID);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbSetEntryFlags",
                  "Failed to convert GUID to string 0x%x\n",
                  Status));
        goto out;
    }

    KeyHandle = SdbpCreateKeyPath(APPCOMPAT_KEY_PATH_NT, FALSE);

    if (KeyHandle == NULL) {
        DBGPRINT((sdlError,
                  "SdbSetEntryFlags",
                  "Failed to create user key path for \"%s\"\n",
                  APPCOMPAT_KEY_PATH_NT));
        goto out;
    }

    Status = NtSetValueKey(KeyHandle,
                           &ustrExeID,
                           0,
                           REG_DWORD,
                           &dwFlags,
                           sizeof(DWORD));
    NtClose(KeyHandle);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbSetEntryFlags",
                  "Failed NtSetValueKey status 0x%x\n",
                  Status));
        goto out;
    }

    bReturn = TRUE;

out:
    FREE_GUID_STRING(&ustrExeID);

    return bReturn;
}


BOOL
SdbpGetLongFileName(
    IN  LPCWSTR szFullPath,     // a full UNC or DOS path & filename, "c:\foo\mylong~1.ext"
    OUT LPWSTR  szLongFileName  // the long filename portion "mylongfilename.ext"
    )
/*++
    Return: TRUE if successful, FALSE otherwise.

    Desc:   Retrieves the long filename (without the path) of a potentially
            short full-path filename.
--*/
{
    NTSTATUS                  status;
    BOOL                      bSuccess = FALSE;
    UNICODE_STRING            FileName;
    UNICODE_STRING            PathName;
    OBJECT_ATTRIBUTES         ObjPathName;
    IO_STATUS_BLOCK           IoStatusBlock;
    HANDLE                    hDirectoryHandle = NULL;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;

    struct SEARCH_BUFFER {
        FILE_BOTH_DIR_INFORMATION DirInfo;
        WCHAR                     Names[MAX_PATH-1];
        } Buffer;

    PathName.Buffer = NULL;

    if (!RtlDosPathNameToNtPathName_U(szFullPath,
                                      &PathName,
                                      &FileName.Buffer,
                                      NULL)) {
        PathName.Buffer = NULL;

        DBGPRINT((sdlError,
                  "SdbpGetLongFileName",
                  "Failed to get NT path name for \"%s\"\n",
                  szFullPath));
        goto out;
    }

    if (FileName.Buffer == NULL) {
        DBGPRINT((sdlError,
                  "SdbpGetLongFileName",
                  "Filename buffer is NULL for \"%s\"\n",
                  szFullPath));
        goto out;
    }

    FileName.Length = PathName.Length -
                        (USHORT)((ULONG_PTR)FileName.Buffer - (ULONG_PTR)PathName.Buffer);

    FileName.MaximumLength = FileName.Length;

    PathName.Length = (USHORT)((ULONG_PTR)FileName.Buffer - (ULONG_PTR)PathName.Buffer);
    PathName.MaximumLength = PathName.Length;

    InitializeObjectAttributes(&ObjPathName,
                               &PathName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtOpenFile(&hDirectoryHandle,
                        FILE_LIST_DIRECTORY | SYNCHRONIZE,
                        &ObjPathName,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_DIRECTORY_FILE |
                            FILE_SYNCHRONOUS_IO_NONALERT |
                            FILE_OPEN_FOR_BACKUP_INTENT);

    if (STATUS_SUCCESS != status) {
        DBGPRINT((sdlError,
                  "SdbpGetLongFileName",
                  "Failed to open directory file. Status 0x%x\n",
                  status));
        goto out;
    }

    DirectoryInfo = &(Buffer.DirInfo);

    status = NtQueryDirectoryFile(hDirectoryHandle,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  DirectoryInfo,
                                  sizeof(Buffer),
                                  FileBothDirectoryInformation,
                                  TRUE,
                                  &FileName,
                                  FALSE);

    if (STATUS_SUCCESS != status) {
        DBGPRINT((sdlError,
                  "SdbpGetLongFileName",
                  "NtQueryDirectoryFile Failed 0x%x\n",
                  status));
        goto out;
    }

    if (DirectoryInfo->FileNameLength > MAX_PATH - 2) {
        DBGPRINT((sdlError,
                  "SdbpGetLongFileName",
                  "File name longer than MAX_PATH - 2\n"));
        goto out;
    }

    wcsncpy(szLongFileName, DirectoryInfo->FileName,
            DirectoryInfo->FileNameLength/sizeof(WCHAR));

    szLongFileName[DirectoryInfo->FileNameLength / sizeof(WCHAR)] = L'\0';

    bSuccess = TRUE;

out:
    if (PathName.Buffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, PathName.Buffer);
    }

    if (hDirectoryHandle) {
        NtClose(hDirectoryHandle);
    }

    return bSuccess;
}

void
SdbpGetWinDir(
    OUT LPWSTR pwszDir
    )
/*++
    Return: void.

    Desc:   Retrieves the system windows directory.
--*/
{
    wcscpy(pwszDir, USER_SHARED_DATA->NtSystemRoot);
}


void
SdbpGetAppPatchDir(
    OUT LPWSTR szAppPatchPath
    )
/*++
    Return: void.

    Desc:   Retrieves the %windir%\AppPatch directory.
--*/
{
    int nLen;

    wcscpy(szAppPatchPath, USER_SHARED_DATA->NtSystemRoot);

    nLen = wcslen(szAppPatchPath);

    if (nLen > 0 && L'\\' == szAppPatchPath[nLen-1]) {
        szAppPatchPath[nLen-1] = L'\0';
    }

    wcscat(szAppPatchPath, L"\\AppPatch");
}


void
SdbpGetCurrentTime(
    OUT LPSYSTEMTIME lpTime
    )
/*++
    Return: void.

    Desc:   Retrieves the current local time.
--*/
{
    LARGE_INTEGER LocalTime;
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER Bias;
    TIME_FIELDS   TimeFields;

    volatile KSYSTEM_TIME* pRealBias = &(USER_SHARED_DATA->TimeZoneBias);

    //
    // Read system time from shared region.
    //
    do {
        SystemTime.HighPart = USER_SHARED_DATA->SystemTime.High1Time;
        SystemTime.LowPart = USER_SHARED_DATA->SystemTime.LowPart;
    } while (SystemTime.HighPart != USER_SHARED_DATA->SystemTime.High2Time);

    //
    // Read time zone bias from shared region.
    // If it's terminal server session use client bias.
    //
    do {
        Bias.HighPart = pRealBias->High1Time;
        Bias.LowPart = pRealBias->LowPart;
    } while (Bias.HighPart != pRealBias->High2Time);

    LocalTime.QuadPart = SystemTime.QuadPart - Bias.QuadPart;

    RtlTimeToTimeFields(&LocalTime, &TimeFields);

    lpTime->wYear         = TimeFields.Year;
    lpTime->wMonth        = TimeFields.Month;
    lpTime->wDayOfWeek    = TimeFields.Weekday;
    lpTime->wDay          = TimeFields.Day;
    lpTime->wHour         = TimeFields.Hour;
    lpTime->wMinute       = TimeFields.Minute;
    lpTime->wSecond       = TimeFields.Second;
    lpTime->wMilliseconds = TimeFields.Milliseconds;
}


NTSTATUS
SdbpGetEnvVar(
    IN  LPCWSTR pEnvironment,
    IN  LPCWSTR pszVariableName,
    OUT LPWSTR  pszVariableValue,
    OUT LPDWORD pdwBufferSize
    )
/*++
    Return:

    Desc:   Retrieves the value of the specified environment variable.
--*/
{
    NTSTATUS       Status = STATUS_VARIABLE_NOT_FOUND;
    UNICODE_STRING ustrVariableName;
    UNICODE_STRING ustrVariableValue;
    DWORD          dwBufferSize = 0;

    if (pdwBufferSize && pszVariableValue) {
        dwBufferSize = *pdwBufferSize;
    }

    RtlInitUnicodeString(&ustrVariableName, pszVariableName);

    ustrVariableValue.Length        = 0;
    ustrVariableValue.MaximumLength = (USHORT)dwBufferSize * sizeof(WCHAR);
    ustrVariableValue.Buffer        = (WCHAR*)pszVariableValue;

    Status = RtlQueryEnvironmentVariable_U((LPVOID)pEnvironment,
                                           &ustrVariableName,
                                           &ustrVariableValue);

    if (pdwBufferSize) {
        *pdwBufferSize = (DWORD)ustrVariableValue.Length / sizeof(WCHAR);
    }

    return Status;
}


BOOL
SdbpMapFile(
    IN  HANDLE         hFile,   // handle to the open file (this is done previously)
    OUT PIMAGEFILEDATA pImageData
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Maps a file into memory.
--*/
{
    NTSTATUS Status;
    HANDLE   hSection = NULL;
    SIZE_T   ViewSize = 0;
    PVOID    pBase = NULL;

    IO_STATUS_BLOCK           IoStatusBlock;
    FILE_STANDARD_INFORMATION StandardInfo;

    if (hFile == INVALID_HANDLE_VALUE) {
        DBGPRINT((sdlError, "SdbpMapFile", "Invalid argument\n"));
        return FALSE;
    }

    //
    // Query the file's size.
    //
    Status = NtQueryInformationFile(hFile,
                                    &IoStatusBlock,
                                    &StandardInfo,
                                    sizeof(StandardInfo),
                                    FileStandardInformation);
    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbpMapFile",
                  "NtQueryInformationFile (EOF) failed Status = 0x%x\n",
                  Status));
        return FALSE;
    }

    //
    // Create a view of the file.
    //
    Status = NtCreateSection(&hSection,
                             SECTION_MAP_READ,
                             NULL,
                             0,
                             PAGE_READONLY,
                             SEC_COMMIT,
                             hFile);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbpMapFile",
                  "NtCreateSection failed Status 0x%x\n",
                  Status));
        //
        // Can't create section, thus no way to map the file.
        //
        return FALSE;
    }

    Status = NtMapViewOfSection(hSection,
                                NtCurrentProcess(),
                                &pBase,
                                0,
                                0,
                                NULL,
                                &ViewSize,
                                ViewUnmap,
                                0,
                                PAGE_READONLY);

    if (!NT_SUCCESS(Status)) {
         NtClose(hSection);
         DBGPRINT((sdlError,
                   "SdbpMapFile",
                   "NtMapViewOfSection failed Status 0x%x\n",
                   Status));
         return FALSE;
    }

    //
    // We have made it. The file is mapped.
    //
    pImageData->hFile    = hFile;
    pImageData->hSection = hSection;
    pImageData->pBase    = pBase;
    pImageData->ViewSize = ViewSize;
    pImageData->FileSize = StandardInfo.EndOfFile.QuadPart;

    return TRUE;
}

BOOL
SdbpUnmapFile(
    IN  PIMAGEFILEDATA pImageData
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Unmaps a file from memory.
--*/
{
    NTSTATUS Status;
    BOOL     bReturn = TRUE;

    if (pImageData->pBase != NULL) {
        Status = NtUnmapViewOfSection(NtCurrentProcess(), pImageData->pBase);

        if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlError,
                      "SdbpUnmapFile",
                      "NtUnmapViewOfSection failed Status 0x%x\n",
                      Status));
            bReturn = FALSE;
        }
        pImageData->pBase = NULL;
    }

    if (pImageData->hSection) {
        NtClose(pImageData->hSection);
        pImageData->hSection = NULL;
    }

    pImageData->hFile = INVALID_HANDLE_VALUE; // hFile is not owned by us

    return bReturn;
}

#ifndef _WIN64

void
SdbResetStackOverflow(
    void
    )
/*++
    Return: void.

    Desc:   This function sets the guard page to its position before the
            stack overflow.

            This is a copy of the following CRT routine:
                void _resetstkoflw(void) - Recovers from Stack Overflow
--*/
{
    LPBYTE                   pStack, pGuard, pStackBase, pCommitBase;
    MEMORY_BASIC_INFORMATION mbi;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_INFO              si;
    DWORD                    PageSize;
    NTSTATUS                 Status;
    SIZE_T                   ReturnLength;
    DWORD                    OldProtect;
    SIZE_T                   RegionSize;

    //
    // Use alloca() to get the current stack pointer
    // the call below DOES NOT fail
    //
    __try {
        pStack = _alloca(1);
    } __except(GetExceptionCode() == EXCEPTION_STACK_OVERFLOW ?
               EXCEPTION_EXECUTE_HANDLER:EXCEPTION_CONTINUE_SEARCH) {
        pStack = (LPBYTE)&pStack;  // hack: we just grab the address of our internal variable
    }

    //
    // Find the base of the stack.
    //
    Status = NtQueryVirtualMemory(NtCurrentProcess(),
                                  pStack,
                                  MemoryBasicInformation,
                                  &mbi,
                                  sizeof(mbi),
                                  &ReturnLength);
    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbpResetStackOverflow",
                  "NtQueryVirtualMemory failed on stack 0x%x Status 0x%x\n",
                  pStack,
                  Status));
        return;
    }

    pStackBase = mbi.AllocationBase;

    Status = NtQueryVirtualMemory(NtCurrentProcess(),
                                  pStackBase,
                                  MemoryBasicInformation,
                                  &mbi,
                                  sizeof(mbi),
                                  &ReturnLength);
    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbpResetStackOverflow",
                  "NtQueryVirtualMemory failed on stack base 0x%x Status 0x%x\n",
                  pStackBase,
                  Status));
        return;
    }

    if (mbi.State & MEM_RESERVE) {
        pCommitBase = (LPBYTE)mbi.AllocationBase + mbi.RegionSize;

        Status = NtQueryVirtualMemory(NtCurrentProcess(),
                                      pCommitBase,
                                      MemoryBasicInformation,
                                      &mbi,
                                      sizeof(mbi),
                                      &ReturnLength);
        if (!NT_SUCCESS(Status)) {
             DBGPRINT((sdlError,
                       "SdbpResetStackOverflow",
                       "NtQueryVirtualMemory failed on stack commit base 0x%x Status 0x%x\n",
                       pCommitBase,
                       Status));
             return;
        }

    } else {
        pCommitBase = pStackBase;
    }

    //
    // Find the page size.
    //
    Status = NtQuerySystemInformation(SystemBasicInformation,
                                      &BasicInfo,
                                      sizeof(BasicInfo),
                                      NULL);
    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbpResetStackOverflow",
                  "NtQuerySystemInformation failed Status 0x%x\n",
                  Status));
        return;
    }

    PageSize = BasicInfo.PageSize;

    //
    // Find the page just below where stack pointer currently points.
    //
    pGuard = (LPBYTE)(((DWORD_PTR)pStack & ~(DWORD_PTR)(PageSize -1)) - PageSize);

    if (pGuard < pStackBase) {
        //
        // We can't save this.
        //
        DBGPRINT((sdlError,
                  "SdbpResetStackOverflow",
                  "Bad guard page 0x%x base 0x%x\n",
                  pGuard,
                  pStackBase));
        return;
    }

    if (pGuard > pStackBase) {

        RegionSize = pGuard - pStackBase;

        Status = NtFreeVirtualMemory(NtCurrentProcess(),
                                     &pStackBase,
                                     &RegionSize,
                                     MEM_DECOMMIT);
        if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlError,
                      "SdbpResetStackOverflow",
                      "NtFreeVirtualMemory on 0x%x failed Status 0x%x\n",
                      pStackBase,
                      Status));
        }
    }

    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                     &pGuard,
                                     0,
                                     &PageSize,
                                     MEM_COMMIT,
                                     PAGE_READWRITE);
    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbpResetStackOverflow",
                  "NtAllocateVirtualMemory on 0x%x failed Status 0x%x\n",
                  pGuard,
                  Status));
        return;
    }

    Status = NtProtectVirtualMemory(NtCurrentProcess(),
                                    &pGuard,
                                    &PageSize,
                                    PAGE_READWRITE|PAGE_GUARD,
                                    &OldProtect);
    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbpResetStackOverflow",
                  "NtProtectVirtualMemory on 0x%x failed Status 0x%x\n",
                  pGuard,
                  Status));
    }
}

#endif // _WIN64


BOOL
SdbpQueryFileDirectoryAttributes(
    LPCWSTR                  FilePath,
    PFILEDIRECTORYATTRIBUTES pFileDirectoryAttributes
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    OBJECT_ATTRIBUTES DirObjectAttributes;
    UNICODE_STRING    FileName;        // filename part
    IO_STATUS_BLOCK   IoStatusBlock;
    HANDLE            FileHandle = INVALID_HANDLE_VALUE;
    UNICODE_STRING    Path       = { 0 };            // nt path name

    struct tagDirectoryInformationBuffer { // directory information (see ntioapi)
       FILE_DIRECTORY_INFORMATION DirInfo;
       WCHAR name[MAX_PATH];
    } DirectoryInformationBuf;

    PFILE_DIRECTORY_INFORMATION pDirInfo = &DirectoryInformationBuf.DirInfo;

    USHORT            nPathLength;
    int               i;
    NTSTATUS          Status = STATUS_INVALID_PARAMETER;
    BOOL              bTranslationStatus;

    RtlZeroMemory(pFileDirectoryAttributes, sizeof(*pFileDirectoryAttributes));

    bTranslationStatus = RtlDosPathNameToNtPathName_U(FilePath,
                                                      &Path,
                                                      &FileName.Buffer,
                                                      NULL);
    if (!bTranslationStatus) {
        DBGPRINT((sdlError,
                  "SdbpGetFileDirectoryAttributes",
                  "RtlDosPathNameToNtPathName_U failed for \"%s\"\n",
                  FilePath));
        assert(FALSE);
        goto Fail;
    }

    if (FileName.Buffer == NULL) {
        DBGPRINT((sdlError,
                  "SdbpGetFileDirectoryAttributes",
                  "RtlDosPathNameToNtPathName_U returned no filename for \"%s\"",
                  FilePath));
        Status = STATUS_INVALID_PARAMETER;
        goto Fail;
    }

    nPathLength = (USHORT)((ULONG_PTR)FileName.Buffer - (ULONG_PTR)Path.Buffer);

    FileName.Length        = Path.Length - nPathLength;
    FileName.MaximumLength = FileName.Length;

    //
    // path length, adjust please -- chopping off trailing backslash
    //
    // BUGBUG: what am I suppose to understand from the above comment ?
    //
    Path.Length = nPathLength;

    if (nPathLength > 2 * sizeof(WCHAR)) {
        if (*(Path.Buffer + (nPathLength/sizeof(WCHAR)) - 2) != L':' &&
            *(Path.Buffer + (nPathLength/sizeof(WCHAR)) - 1) == L'\\') {
            Path.Length -= sizeof(WCHAR);
        }
    }

    Path.MaximumLength = Path.Length;

    InitializeObjectAttributes(&DirObjectAttributes,
                               &Path,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenFile(&FileHandle,
                        FILE_LIST_DIRECTORY | SYNCHRONIZE,
                        &DirObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        FILE_DIRECTORY_FILE|
                            FILE_SYNCHRONOUS_IO_NONALERT |
                            FILE_OPEN_FOR_BACKUP_INTENT);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbpGetFileDirectoryAttributes",
                  "NtOpenFile Failed to open \"%s\", status 0x%x\n",
                  (int)Path.Length,
                  Path.Buffer,
                  Status));
        goto Fail;
    }

    Status = NtQueryDirectoryFile(FileHandle,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  pDirInfo,
                                  sizeof(DirectoryInformationBuf),
                                  FileDirectoryInformation,
                                  TRUE,
                                  &FileName,
                                  FALSE);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbpGetFileDirectoryAttributes",
                  "NtQueryDirectoryFile Failed to query \"%s\" for \"%s\" status 0x%x\n",
                  (int)Path.Length,
                  Path.Buffer,
                  (int)FileName.Length,
                  FileName.Buffer,
                  Status));
        goto Fail;
    }

    pFileDirectoryAttributes->dwFlags |= FDA_FILESIZE;
    pFileDirectoryAttributes->dwFileSizeHigh = pDirInfo->EndOfFile.HighPart;
    pFileDirectoryAttributes->dwFileSizeLow  = pDirInfo->EndOfFile.LowPart;

Fail:

    if (Path.Buffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, Path.Buffer);
    }

    if (FileHandle != INVALID_HANDLE_VALUE) {
        NtClose(FileHandle);
    }

    return NT_SUCCESS(Status);
}

LPWSTR
StringToUnicodeString(
    IN  LPCSTR pszSrc           // pointer to the ANSI string to be converted
    )
/*++
    Return: A pointer to an allocated UNICODE string.

    Desc:   Converts an ANSI string to UNICODE.
--*/
{
    NTSTATUS       Status;
    ANSI_STRING    AnsiSrc;
    UNICODE_STRING UnicodeDest = { 0 };
    LPWSTR         pwszUnicodeDest = NULL;
    ULONG          Length;

    RtlInitString(&AnsiSrc, pszSrc);

    Length = RtlAnsiStringToUnicodeSize(&AnsiSrc);

    pwszUnicodeDest = (LPWSTR)SdbAlloc(Length);

    if (pwszUnicodeDest == NULL) {
        DBGPRINT((sdlWarning, "StringToUnicodeString", "Failed to allocate %d bytes.\n", Length));
        return pwszUnicodeDest;
    }

    UnicodeDest.MaximumLength = (USHORT)Length;
    UnicodeDest.Buffer        = pwszUnicodeDest;

    Status = RtlAnsiStringToUnicodeString(&UnicodeDest, &AnsiSrc, FALSE);

    if (!NT_SUCCESS(Status)) {
        SdbFree(pwszUnicodeDest);
        pwszUnicodeDest = NULL;

        DBGPRINT((sdlWarning,
                  "StringToUnicodeString",
                  "Failed to convert \"%s\" to UNICODE. Status 0x%x\n",
                  pszSrc,
                  Status));
    }

    return pwszUnicodeDest;
}

BOOL
SdbpGet16BitDescription(
    OUT LPWSTR*        ppszDescription,
    IN  PIMAGEFILEDATA pImageData
    )
/*++
    Return: TRUE on success, FALSE otherwise

    Desc:   This function retrieves 16-bit description from the
            module identified by pImageData
--*/
{
    BOOL   bSuccess;
    char   szBuffer[256];
    LPWSTR pwszDescription = NULL;

    bSuccess = SdbpQuery16BitDescription(szBuffer, pImageData);

    if (bSuccess) {
        pwszDescription = StringToUnicodeString(szBuffer);

        *ppszDescription = pwszDescription;
    }

    return (pwszDescription != NULL);
}


BOOL
SdbpGet16BitModuleName(
    OUT LPWSTR*        ppszModuleName,
    IN  PIMAGEFILEDATA pImageData
    )
/*++
    Return: TRUE on success, FALSE otherwise

    Desc:   Retrieves 16-bit module name from the image
            identified by pImageData, then converts it to UNICODE
--*/
{
    BOOL   bSuccess;
    char   szBuffer[256]; // max possible length of a string is 256 (1-byte worth of length)
    LPWSTR pwszModuleName = NULL;

    bSuccess = SdbpQuery16BitModuleName(szBuffer, pImageData);

    if (bSuccess) {
        pwszModuleName = StringToUnicodeString(szBuffer);

        *ppszModuleName = pwszModuleName;
    }

    return (pwszModuleName != NULL);
}

PVOID
SdbGetFileInfo(
    IN  HSDB    hSDB,
    IN  LPCWSTR pwszFilePath,
    IN  HANDLE  hFile,          // OPTIONAL HANDLE to the file, not used here
    IN  LPVOID  pImageBase,
    IN  DWORD   dwImageSize, // ignored
    IN  BOOL    bNoCache
    )
/*++
    Return: BUGBUG: ?

    Desc:   Create and link a new entry in a file attribute cache.
--*/
{
    PSDBCONTEXT        pContext = (PSDBCONTEXT)hSDB;
    WCHAR*             FullPath  = NULL;
    NTSTATUS           Status;
    PFILEINFO          pFileInfo = NULL;
    ULONG              nBufferLength;
    ULONG              cch;
    UNICODE_STRING     FullPathU;
    BOOL               bFreeFullPath;

    //
    // Check hFile and/or pImageBase -- if these are supplied --
    // we presume that the file exists and we do not touch it
    //
    if (hFile != INVALID_HANDLE_VALUE || pImageBase != NULL) {

        FullPath      = (LPWSTR)pwszFilePath; // we do not have to free it
        cch           = wcslen(FullPath) * sizeof(WCHAR);
        nBufferLength = cch + sizeof(UNICODE_NULL);
        bFreeFullPath = FALSE;
        goto CreateFileInfo;
    }

    //
    // See if we have info on this file. First we get the full path.
    //
    cch = RtlGetFullPathName_U(pwszFilePath,
                               0,
                               NULL,
                               NULL);
    if (cch == 0) {
        DBGPRINT((sdlError,
                  "SdbGetFileInfo",
                  "RtlGetFullPathName_U failed for \"%s\"\n",
                  pwszFilePath));
        return pFileInfo;
    }

    //
    // Now allocate that much.
    //
    nBufferLength = cch + sizeof(UNICODE_NULL);

    STACK_ALLOC(FullPath, nBufferLength);

    if (FullPath == NULL) {
        DBGPRINT((sdlError,
                  "SdbGetFileInfo",
                  "Failed to allocate %d bytes for full path\n",
                  nBufferLength));
        return pFileInfo;
    }
    bFreeFullPath = TRUE;

    cch = RtlGetFullPathName_U(pwszFilePath,
                               nBufferLength,
                               FullPath,
                               NULL);

    assert(cch <= nBufferLength);

    if (cch > nBufferLength || cch == 0) {
        DBGPRINT((sdlError,
                  "SdbGetFileInfo",
                  "RtlGetFullPathName_U failed for \"%s\"\n",
                  pwszFilePath));
        goto Done;
    }

CreateFileInfo:

    if (!bNoCache) {
        pFileInfo = FindFileInfo(pContext, FullPath);
    }

    if (pFileInfo == NULL) {
        if (hFile != INVALID_HANDLE_VALUE || pImageBase != NULL ||
            RtlDoesFileExists_U(FullPath)) {
            //
            // The path does exist. Create a record of this file path.
            //
            FullPathU.Buffer        = FullPath;
            FullPathU.Length        = (USHORT)cch;
            FullPathU.MaximumLength = (USHORT)nBufferLength;

            pFileInfo = CreateFileInfo(pContext,
                                       FullPathU.Buffer,
                                       FullPathU.Length / sizeof(WCHAR),
                                       hFile,
                                       pImageBase,
                                       dwImageSize,
                                       bNoCache);
        }
    }

Done:
    if (FullPath != NULL && bFreeFullPath) {
        STACK_FREE(FullPath);
    }

    return (PVOID)pFileInfo;
}


static UNICODE_STRING g_ustrShimDbgLevelVar = RTL_CONSTANT_STRING(L"SHIM_DEBUG_LEVEL");

int
GetShimDbgLevel(
    void
    )
/*++
    Return: The current debug level.

    Desc:   Checks the environment variable that controls the amount of
            debug output.
--*/
{
    UNICODE_STRING ShimDbgLevel;
    INT            iShimDebugLevel = 0;
    NTSTATUS       Status;
    WCHAR          Buffer[MAX_PATH];
    ULONG          ulValue;

    ShimDbgLevel.Buffer = (PWCHAR)Buffer;
    ShimDbgLevel.Length = 0;
    ShimDbgLevel.MaximumLength = sizeof(Buffer);

    Status = RtlQueryEnvironmentVariable_U(NULL,
                                           &g_ustrShimDbgLevelVar,
                                           &ShimDbgLevel);
    if (NT_SUCCESS(Status)) {
        //
        // We have the debug level variable present. Parse it to see what
        // is the value of this variable.
        //
        Status = RtlUnicodeStringToInteger(&ShimDbgLevel, 0, (PULONG)&ulValue);

        if (NT_SUCCESS(Status)) {
            iShimDebugLevel = (int)ulValue;
        }
    }

    return iShimDebugLevel;
}

//
// Functions that deal with APPCOMPAT_EXE_DATA
//

//
// These two functions should be used when passing APPCOMPAT_EXE_DATA structure
// across the boundaries of CreateProcess. Before passing the struct it should
// be "denormalized"; after -- normalized.
//

#define APPCOMPAT_EXE_DATA_MAGIC 0xAC0DEDAB


BOOL
SdbPackAppCompatData(
    IN  HSDB            hSDB,
    IN  PSDBQUERYRESULT pSdbQuery,
    OUT PVOID*          ppData,         // app compat data package
    OUT LPDWORD         pdwSize         // data size
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Packs the APPCOMPAT_EXE_DATA to be sent to the kernel in the context
            of the process about to be started (and shimmed).
--*/
{
    PSDBCONTEXT         pSdbContext = (PSDBCONTEXT)hSDB;
    DWORD               cbData;
    PAPPCOMPAT_EXE_DATA pData = NULL;
    BOOL                bReturn = FALSE;
    BOOL                bLocal;

    assert(ppData != NULL);
    assert(pdwSize != NULL);

    if (pSdbQuery->atrExes[0] == TAGREF_NULL && pSdbQuery->atrLayers[0] == TAGREF_NULL) {
        DBGPRINT((sdlError, "SdbPackAppCompatData", "Invalid arguments.\n"));
        return FALSE;
    }

    cbData = sizeof(APPCOMPAT_EXE_DATA);

    //
    // Allocate memory. Use this form of allocation so we know that
    // we can free it from CreateProcess.
    //
    pData = (PAPPCOMPAT_EXE_DATA)RtlAllocateHeap(RtlProcessHeap(),
                                                 HEAP_ZERO_MEMORY,
                                                 cbData);
    if (pData == NULL) {
        DBGPRINT((sdlError,
                  "SdbPackAppCompatData",
                  "Failed to allocate %d bytes.\n",
                  cbData));
        return FALSE;
    }

    pData->cbSize    = cbData;
    pData->dwMagic   = APPCOMPAT_EXE_DATA_MAGIC;
    pData->dwFlags   = pSdbQuery->dwFlags;
    pData->trAppHelp = pSdbQuery->trAppHelp;

    RtlCopyMemory(&pData->atrExes[0],
                  &pSdbQuery->atrExes[0],
                  sizeof(pSdbQuery->atrExes));

    RtlCopyMemory(&pData->atrLayers[0],
                  &pSdbQuery->atrLayers[0],
                  sizeof(pSdbQuery->atrLayers));

    wcscpy(pData->szShimEngine, L"ShimEng.dll");

    //
    // Store custom sdbs
    //
    pData->dwDatabaseMap = pSdbQuery->dwCustomSDBMap;

    if (pData->dwDatabaseMap) {
        RtlCopyMemory(&pData->rgGuidDB[0],
                      &pSdbQuery->rgGuidDB[0],
                      sizeof(pData->rgGuidDB));
    }

    DBGPRINT((sdlInfo|sdlLogPipe,
              "SdbPackAppCompatData",
              "\n\tdwFlags    0x%X\n"
              "\tdwMagic    0x%X\n"
              "\ttrExe      0x%X\n"
              "\ttrLayer    0x%X\n",
              hSDB,
              pData->dwFlags,
              pData->dwMagic,
              pData->atrExes[0],
              pData->atrLayers[0]));

    //
    // Dump all the relevant entries
    //
    if (SDBCONTEXT_IS_INSTRUMENTED(hSDB)) {
        DWORD dwMask;
        DWORD dwIndex;
        WCHAR szGuid[64];
        PDB   pdb;
        LPCWSTR pszDescription;
        SDBDATABASEINFO DbInfo;

        if (pSdbQuery->dwCustomSDBMap) {

            DBGPRINT((sdlInfo|sdlLogPipe, "SdbPackAppcompatData", "Database List\n", hSDB));

            for (dwIndex = 0; dwIndex < ARRAYSIZE(pSdbQuery->rgGuidDB); ++dwIndex) {

                dwMask = (1UL << dwIndex);

                if (!(pSdbQuery->dwCustomSDBMap & dwMask)) {
                    continue;
                }

                //
                // Dump the guid
                //
                pszDescription = NULL;

                pdb = SdbGetPDBFromGUID(hSDB, &pSdbQuery->rgGuidDB[dwIndex]);
                if (pdb != NULL && SdbGetDatabaseInformation(pdb, &DbInfo)) {
                    pszDescription = DbInfo.pszDescription;
                }

                SdbGUIDToString(&pSdbQuery->rgGuidDB[dwIndex], szGuid);

                DBGPRINT((sdlInfo|sdlLogPipe,
                          "SdbPackAppcompatData",
                          "0x%lx %s %s\n",
                          hSDB,
                          SDB_INDEX_TO_MASK(dwIndex),
                          szGuid,
                          (pszDescription ? pszDescription : L"")));
            }
        }

        //
        // Now dump all the matches
        //
        for (dwIndex = 0; dwIndex < ARRAYSIZE(pSdbQuery->atrExes); ++dwIndex) {

            if (pSdbQuery->atrExes[dwIndex] == TAGREF_NULL) {
                continue;
            }

            DBGPRINT((sdlInfo|sdlLogPipe,
                      "SdbPackAppcompatData",
                      "Exe   0x%.8lx\n",
                      hSDB,
                      pSdbQuery->atrExes[dwIndex]));
        }

        for (dwIndex = 0; dwIndex < ARRAYSIZE(pSdbQuery->atrLayers); ++dwIndex) {

            if (pSdbQuery->atrLayers[dwIndex] == TAGREF_NULL) {
                continue;
            }

            DBGPRINT((sdlInfo|sdlLogPipe,
                      "SdbPackAppcompatData",
                      "Layer 0x%.8lx\n",
                      hSDB,
                      pSdbQuery->atrLayers[dwIndex]));
        }
    }

    *ppData  = (PVOID)pData;
    *pdwSize = cbData;

    return TRUE;
}


BOOL
SdbUnpackAppCompatData(
    IN  HSDB            hSDB,
    IN  LPCWSTR         pwszExeName,
    IN  PVOID           pAppCompatData,
    OUT PSDBQUERYRESULT pSdbQuery
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Unpacks the APPCOMPAT_EXE_DATA to extract the TAGREFs to be used
            for the EXE that just started. This function is called from
            LdrpInitializeProcess (in ntdll).
--*/
{
    PAPPCOMPAT_EXE_DATA pData = (PAPPCOMPAT_EXE_DATA)pAppCompatData;
    PSDBCONTEXT         pSdbContext = (PSDBCONTEXT)hSDB;
    BOOL                bLocal;

    if (pData == NULL) {
        DBGPRINT((sdlError, "SdbUnpackAppCompatData", "Invalid parameter\n"));
        return FALSE;
    }

    if (pData->dwMagic != APPCOMPAT_EXE_DATA_MAGIC) {
        DbgPrint("[SdbUnpackAppCompatData] Invalid magic 0x%x. Expected 0x%x\n",
                  pData->dwMagic,
                  APPCOMPAT_EXE_DATA_MAGIC);
        return FALSE;
    }

    DBGPRINT((sdlInfo,
              "SdbUnpackAppCompatData",
              "Appcompat Data for \"%s\":\n"
              "\tdwFlags    0x%X\n"
              "\tdwMagic    0x%X\n"
              "\ttrExe      0x%X\n"
              "\ttrLayer    0x%X\n",
              pwszExeName,
              pData->dwFlags,
              pData->dwMagic,
              pData->atrExes[0],
              pData->atrLayers[0]));

    //
    // We have no use for dwFlags so far.
    //

    //
    // We should get rid of all the local sdbs in this context
    //
    if (pSdbContext->pdbLocal != NULL) {
        SdbCloseLocalDatabase(hSDB);
    }

    RtlCopyMemory(&pSdbQuery->atrExes[0],
                  &pData->atrExes[0],
                  sizeof(pData->atrExes));

    RtlCopyMemory(&pSdbQuery->atrLayers[0],
                  &pData->atrLayers[0],
                  sizeof(pData->atrLayers));

    pSdbQuery->dwFlags = pData->dwFlags;
    pSdbQuery->trAppHelp = pData->trAppHelp;

    //
    // See if we need to open local db
    //
    // We might need to be able to use local dbs --
    // actual open on a local db will be performed by a tagref translation layer
    //
    if (pData->dwDatabaseMap) {

        DWORD     dwMask;
        DWORD     dwIndex;
        PSDBENTRY pEntry;
        DWORD     dwCount = 2;

        SdbpCleanupLocalDatabaseSupport(hSDB);

        //
        // Now introduce entries, one by one
        //
        for (dwIndex = 2; dwIndex < ARRAYSIZE(pSdbContext->rgSDB); ++dwIndex) {

            dwMask = (1UL << dwIndex);

            if (pData->dwDatabaseMap & dwMask) {
                pEntry = SDBGETENTRY(hSDB, dwIndex);
                pEntry->dwFlags = SDBENTRY_VALID_GUID;
                pEntry->guidDB  = pData->rgGuidDB[dwIndex];
                dwCount = dwIndex;
            }
        }

        pSdbContext->dwDatabaseMask |= (pData->dwDatabaseMap & SDB_CUSTOM_MASK);
    }

    return TRUE;
}

DWORD
SdbGetAppCompatDataSize(
    IN  PVOID pAppCompatData
    )
/*++
    Return: The size of the appcompat data.

    Desc:   Self explanatory.
--*/
{
    PAPPCOMPAT_EXE_DATA pData = (PAPPCOMPAT_EXE_DATA)pAppCompatData;

    if (pData == NULL) {
        DBGPRINT((sdlError, "SdbGetAppCompatDataSize", "Invalid parameter\n"));
        return 0;
    }

    if (pData->dwMagic != APPCOMPAT_EXE_DATA_MAGIC) {
        DBGPRINT((sdlError,
                  "SdbGetAppCompatDataSize",
                  "Invalid magic 0x%x. Expected 0x%x\n",
                  pData->dwMagic,
                  APPCOMPAT_EXE_DATA_MAGIC));
        return 0;
    }

    return pData->cbSize;
}


BOOL
SdbpWriteBitsToFile(
    IN  LPCTSTR pszFile,
    IN  PBYTE   pBuffer,
    IN  DWORD   dwSize
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Self explanatory.
--*/
{
    LPCWSTR           pszFileU = (LPCWSTR)pszFile;
    UNICODE_STRING    strFilePath;
    RTL_RELATIVE_NAME RelativeName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS          status = STATUS_UNSUCCESSFUL;
    HANDLE            hFile  = NULL;
    IO_STATUS_BLOCK   IoStatusBlock;
    LARGE_INTEGER     liOffset;

    //
    // Create the file.
    //
    RtlInitUnicodeString(&strFilePath, pszFileU);

    if (!RtlDosPathNameToNtPathName_U(strFilePath.Buffer,
                                      &strFilePath,
                                      NULL,
                                      &RelativeName)) {
        DBGPRINT((sdlError,
                  "SdbpWriteBitsToFile",
                  "Failed to convert file name \"%s\" to NT path.\n",
                  pszFileU));
        goto cleanup;
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               &strFilePath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          0,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_OVERWRITE_IF,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    //
    // RtlDosPathNameToNtPathName_U allocates memory for the
    // unicode string. This is where we dump it.
    //
    RtlFreeUnicodeString(&strFilePath);

    if (!NT_SUCCESS(status)) {
        DBGPRINT((sdlError,
                  "SdbpWriteBitsToFile",
                  "Failed to create file \"%s\".\n",
                  pszFileU));
        goto cleanup;
    }

    //
    // ...and write the bits to disk
    //
    liOffset.LowPart  = 0;
    liOffset.HighPart = 0;

    status = NtWriteFile(hFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         (PVOID)pBuffer,
                         dwSize,
                         &liOffset,
                         NULL);

    if (!NT_SUCCESS(status)) {
        DBGPRINT((sdlError,
                  "SdbpWriteBitsToFile",
                  "Failed 0x%x to write file \"%s\" to disk.\n",
                  status,
                  pszFileU));
        goto cleanup;
    }

    status = STATUS_SUCCESS;

cleanup:

    if (hFile != NULL) {
        NtClose(hFile);
    }

    return (status == STATUS_SUCCESS);
}

DWORD
SdbExpandEnvironmentStrings(
    IN  LPCWSTR lpSrc,
    OUT LPWSTR  lpDst,
    IN  DWORD   nSize
    )
{
    NTSTATUS       Status;
    UNICODE_STRING Source;
    UNICODE_STRING Destination;
    ULONG          Length;
    DWORD          iSize;

    if (nSize > (MAXUSHORT >> 1) - 2) {
        iSize = (MAXUSHORT >> 1) - 2;
    } else {
        iSize = nSize;
    }

    RtlInitUnicodeString(&Source, lpSrc);

    Destination.Buffer = lpDst;
    Destination.Length = 0;
    Destination.MaximumLength = (USHORT)(iSize * sizeof( WCHAR ));

    Length = 0;

    Status = RtlExpandEnvironmentStrings_U(NULL,
                                           &Source,
                                           &Destination,
                                           &Length);

    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_TOO_SMALL) {
        return (Length / sizeof(WCHAR));
    }

    return 0;
}

BOOL
SDBAPI
SdbRegisterDatabaseEx(
    IN LPCWSTR    pszDatabasePath,
    IN DWORD      dwDatabaseType,
    IN PULONGLONG pTimeStamp OPTIONAL
    )
/*++
    Registers any given database so that it is "known" to our database lookup apis

--*/
{
    PSDBDATABASEINFO  pDbInfo = NULL;
    BOOL              bReturn = FALSE;
    UNICODE_STRING    ustrPath;
    UNICODE_STRING    ustrFullPath = { 0 };
    BOOL              bFreeFullPath = FALSE;
    BOOL              bExpandSZ = FALSE;
    UNICODE_STRING    ustrKey;
    UNICODE_STRING    ustrFullKey;
    UNICODE_STRING    ustrDatabaseID = { 0 };
    WCHAR             wszFullKey[1024];
    NTSTATUS          Status;
    HANDLE            KeyHandleAppcompat = NULL;
    HANDLE            KeyHandle = NULL;
    ULONG             CreateDisposition;
    ULONG             PathLength = 0;
    OBJECT_ATTRIBUTES ObjectAttributes;
    FILETIME          TimeStamp;
    LARGE_INTEGER     liTimeStamp;
    KEY_WRITE_TIME_INFORMATION KeyWriteTimeInfo;

    //
    // See if we need to expand some strings...
    //
    if (_tcschr(pszDatabasePath, TEXT('%')) != NULL) {

        bExpandSZ = TRUE;

        RtlInitUnicodeString(&ustrPath, pszDatabasePath);

        Status = RtlExpandEnvironmentStrings_U(NULL,
                                               &ustrPath,
                                               &ustrFullPath,
                                               &PathLength);

        if (Status != STATUS_BUFFER_TOO_SMALL) {
            DBGPRINT((sdlError,
                      "SdbRegisterDatabase",
                      "Failed to expand environment strings for \"%s\" Status 0x%lx\n",
                      pszDatabasePath,
                      Status));
            return FALSE;
        }

        //
        // Allocate the length we need
        //
        ustrFullPath.Buffer = (WCHAR*)SdbAlloc(PathLength);

        if (ustrFullPath.Buffer == NULL) {
            DBGPRINT((sdlError,
                      "SdbRegisterDatabase",
                      "Failed to allocate 0x%lx bytes for the path buffer \"%s\"\n",
                      PathLength,
                      pszDatabasePath));
            return FALSE;
        }

        ustrFullPath.MaximumLength = (USHORT)PathLength;
        ustrFullPath.Length = 0;
        bFreeFullPath = TRUE;

        Status = RtlExpandEnvironmentStrings_U(NULL,
                                               &ustrPath,
                                               &ustrFullPath,
                                               &PathLength);
        if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlError,
                      "SdbRegisterDatabase",
                      "Failed to expand environment strings for \"%s\" Status 0x%lx\n",
                      pszDatabasePath,
                      Status));
            goto HandleError;
        }

    } else {
        RtlInitUnicodeString(&ustrFullPath, pszDatabasePath);
    }

    if (!SdbGetDatabaseInformationByName(ustrFullPath.Buffer, &pDbInfo)) {
        DBGPRINT((sdlError,
                  "SdbRegisterDatabase",
                  "Cannot obtain database information for \"%s\"\n",
                  pszDatabasePath));
        goto HandleError;
    }

    if (!(pDbInfo->dwFlags & DBINFO_GUID_VALID)) {
        DBGPRINT((sdlError,
                  "SdbRegisterDatabase",
                  "Cannot register database with no id \"%s\"\n",
                  pszDatabasePath));
        goto HandleError;
    }

    Status = GUID_TO_UNICODE_STRING(&pDbInfo->guidDB, &ustrDatabaseID);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbRegisterDatabase",
                  "Cannot convert guid to unicode string status 0x%lx\n",
                  Status));
        goto HandleError;
    }

    //
    // Now that we have database information - create entry
    //
    ustrFullKey.Length = 0;
    ustrFullKey.MaximumLength = sizeof(wszFullKey);
    ustrFullKey.Buffer = wszFullKey;

    RtlAppendUnicodeToString(&ustrFullKey, APPCOMPAT_KEY_PATH_MACHINE_INSTALLEDSDB);
    RtlAppendUnicodeToString(&ustrFullKey, L"\\");
    RtlAppendUnicodeStringToString(&ustrFullKey, &ustrDatabaseID);

    FREE_GUID_STRING(&ustrDatabaseID);

    //
    // All done, now create key - first make sure that appcompat key path machine exists...
    //
    RtlInitUnicodeString(&ustrKey, APPCOMPAT_KEY_PATH_MACHINE_INSTALLEDSDB);
    InitializeObjectAttributes(&ObjectAttributes,
                               &ustrKey,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtCreateKey(&KeyHandleAppcompat,
                         STANDARD_RIGHTS_WRITE |
                            KEY_QUERY_VALUE |
                            KEY_ENUMERATE_SUB_KEYS |
                            KEY_SET_VALUE |
                            KEY_CREATE_SUB_KEY|
                            SdbpGetWow64Flag(),
                         &ObjectAttributes,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         &CreateDisposition);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbRegisterDatabase",
                  "Failed to create key \"%s\" status = 0x%lx\n",
                  ustrKey.Buffer,
                  Status));
        goto HandleError;
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               &ustrFullKey,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtCreateKey(&KeyHandle,
                         STANDARD_RIGHTS_WRITE |
                            KEY_QUERY_VALUE |
                            KEY_ENUMERATE_SUB_KEYS |
                            KEY_SET_VALUE |
                            KEY_CREATE_SUB_KEY|
                            SdbpGetWow64Flag(),
                         &ObjectAttributes,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         &CreateDisposition);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbRegisterDatabase",
                  "Failed to create key \"%s\" Status 0x%x\n",
                  ustrFullKey.Buffer,
                  Status));
        goto HandleError;
    }

    //
    // We have an open key, we shall set these values:
    //
    Status = NtSetValueKey(KeyHandle,
                           &g_ustrDatabasePath,
                           0,
                           bExpandSZ ? REG_EXPAND_SZ : REG_SZ,
                           (PVOID)pszDatabasePath,
                           (_tcslen(pszDatabasePath) + 1) * sizeof(*pszDatabasePath));

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbRegisterDatabase",
                  "Failed to set value \"%s\" to \"%s\" Status 0x%lx\n",
                  g_ustrDatabasePath.Buffer,
                  pszDatabasePath,
                  Status));
        goto HandleError;
    }

    Status = NtSetValueKey(KeyHandle,
                           &g_ustrDatabaseType,
                           0,
                           REG_DWORD,
                           (PVOID)&dwDatabaseType,
                           sizeof(dwDatabaseType));

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbRegisterDatabase",
                  "Failed to set value \"%s\" to 0x%lx Status 0x%lx\n",
                  g_ustrDatabaseType.Buffer,
                  dwDatabaseType, Status));
        goto HandleError;
    }

    if (pDbInfo->pszDescription != NULL) {
        Status = NtSetValueKey(KeyHandle,
                               &g_ustrDatabaseDescription,
                               0,
                               REG_SZ,
                               (PVOID)pDbInfo->pszDescription,
                               (_tcslen(pDbInfo->pszDescription) + 1) * sizeof(WCHAR));

        if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlError,
                      "SdbRegisterDatabase",
                      "Failed to set value \"%s\" to 0x%lx Status 0x%lx\n",
                      g_ustrDatabaseDescription.Buffer,
                      pDbInfo->pszDescription,
                      Status));
            goto HandleError;
        }
    }

    //
    // Finally, set the date/time stamp explicitly as a value
    //
    if (pTimeStamp == NULL) {
        GetSystemTimeAsFileTime(&TimeStamp);
        liTimeStamp.LowPart  = TimeStamp.dwLowDateTime;
        liTimeStamp.HighPart = TimeStamp.dwHighDateTime;
    } else {
        liTimeStamp.QuadPart = *pTimeStamp;
    }

    Status = NtSetValueKey(KeyHandle,
                           &g_ustrInstallTimeStamp,
                           0,
                           REG_QWORD,
                           (PVOID)&liTimeStamp.QuadPart,
                           sizeof(liTimeStamp.QuadPart));

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbRegisterDatabase",
                  "Failed to set value \"%s\" Status 0x%lx\n",
                  g_ustrInstallTimeStamp.Buffer,
                  Status));
        goto HandleError;
    }

    //
    // Make the value we set into the timestamp MATCH the last write date/time stamp
    // on the key itself (just to be consistent)
    //
    KeyWriteTimeInfo.LastWriteTime.QuadPart = liTimeStamp.QuadPart;

    Status = NtSetInformationKey(KeyHandle,
                                 KeyWriteTimeInformation,
                                 &KeyWriteTimeInfo,
                                 sizeof(KeyWriteTimeInfo));
    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbRegisterDatabase",
                  "Failed to set last write time on key Status 0x%lx\n",
                  Status));
        goto HandleError;
    }

    bReturn = TRUE;

HandleError:

    if (pDbInfo != NULL) {
        SdbFreeDatabaseInformation(pDbInfo);
    }

    if (bFreeFullPath && ustrFullPath.Buffer != NULL) {
        SdbFree(ustrFullPath.Buffer);
    }

    if (KeyHandle != NULL) {
        NtClose(KeyHandle);
    }

    if (KeyHandleAppcompat != NULL) {
        NtClose(KeyHandleAppcompat);
    }

    return bReturn;
}

BOOL
SDBAPI
SdbRegisterDatabase(
    IN LPCWSTR pszDatabasePath,
    IN DWORD   dwDatabaseType
    )
{
    return SdbRegisterDatabaseEx(pszDatabasePath, dwDatabaseType, NULL);
}


BOOL
SDBAPI
SdbUnregisterDatabase(
    IN GUID* pguidDB
    )
/*++
    Unregisters a database so it's no longer available.


--*/
{
    BOOL              bReturn = FALSE;
    UNICODE_STRING    ustrFullPath = { 0 };
    UNICODE_STRING    ustrFullKey;
    UNICODE_STRING    ustrDatabaseID = { 0 };
    WCHAR             wszFullKey[1024];
    NTSTATUS          Status;
    HANDLE            KeyHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;

    Status = GUID_TO_UNICODE_STRING(pguidDB, &ustrDatabaseID);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbUnregisterDatabase",
                  "Cannot convert guid to unicode string status 0x%lx\n",
                  Status));
        goto HandleError;
    }

    //
    // Now that we have database information - remove entry
    //
    ustrFullKey.Length = 0;
    ustrFullKey.MaximumLength = sizeof(wszFullKey);
    ustrFullKey.Buffer = wszFullKey;

    RtlAppendUnicodeToString(&ustrFullKey, APPCOMPAT_KEY_PATH_MACHINE_INSTALLEDSDB);
    RtlAppendUnicodeToString(&ustrFullKey, L"\\");
    RtlAppendUnicodeStringToString(&ustrFullKey, &ustrDatabaseID);

    FREE_GUID_STRING(&ustrDatabaseID);

    //
    // All done, now delete key
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               &ustrFullKey,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&KeyHandle, DELETE|SdbpGetWow64Flag(), &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbUnregisterDatabase",
                  "Failed to open key \"%s\" Status 0x%x\n",
                  ustrFullKey.Buffer,
                  Status));
        goto HandleError;
    }

    //
    // We have an open key, now delete it
    //
    Status = NtDeleteKey(KeyHandle);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbUnregisterDatabase",
                  "Failed to delete key \"%s\" Status 0x%x\n",
                  ustrFullKey.Buffer,
                  Status));
        goto HandleError;
    }

    bReturn = TRUE;

HandleError:

    if (KeyHandle != NULL) {
        NtClose(KeyHandle);
    }

    return bReturn;
}

BOOL
SdbpDoesFileExistNTPath(
    LPCWSTR lpwszFileName
    )
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING    NtFileName;
    NTSTATUS          Status;
    BOOL              ReturnValue = FALSE;
    FILE_BASIC_INFORMATION BasicInfo;

    RtlInitUnicodeString(&NtFileName, lpwszFileName);

    InitializeObjectAttributes(&Obja,
                               &NtFileName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    // Query the file's attributes.  Note that the file cannot simply be opened
    // to determine whether or not it exists, as the NT LanMan redirector lies
    // on NtOpenFile to a Lan Manager server because it does not actually open
    // the file until an operation is performed on it. We don't care since net is not
    // even involved -- we always check for LOCAL files
    //
    Status = NtQueryAttributesFile(&Obja, &BasicInfo);

    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_SHARING_VIOLATION || Status == STATUS_ACCESS_DENIED) {
            ReturnValue = TRUE;
        } else {
            ReturnValue = FALSE;
        }
    } else {
        ReturnValue = TRUE;
    }

    return ReturnValue;
}

BOOL
SDBAPI
SdbGetStandardDatabaseGUID(
    IN  DWORD  dwDatabaseType,
    OUT GUID*  pGuidDB
    )
{
    GUID const * pguid = NULL;

    if (!(dwDatabaseType & SDB_DATABASE_MAIN)) {
        DBGPRINT((sdlError,
                  "SdbGetStandardDatabaseGUID",
                  "Cannot obtain database guid for databases other than main\n"));
        return FALSE;
    }

    switch (dwDatabaseType & SDB_DATABASE_TYPE_MASK) {

    case SDB_DATABASE_MAIN_DRIVERS:
        pguid = &GUID_DRVMAIN_SDB;
        break;

    case SDB_DATABASE_MAIN_DETAILS:
        pguid = &GUID_APPHELP_SDB;
        break;

    case SDB_DATABASE_MAIN_SP_DETAILS:
        pguid = &GUID_APPHELP_SP_SDB;
        break;

    case SDB_DATABASE_MAIN_MSI:
        pguid = &GUID_MSIMAIN_SDB;
        break;

    case SDB_DATABASE_MAIN_SHIM:
        pguid = &GUID_SYSMAIN_SDB;
        break;
    }

    if (pguid != NULL) {
        if (pGuidDB != NULL) {
            RtlCopyMemory(pGuidDB, pguid, sizeof(*pGuidDB));
        }
        return TRUE;
    }

    return FALSE;
}

DWORD
SdbpGetStandardDatabasePath(
    IN  DWORD  dwDatabaseType,
    IN  DWORD  dwFlags,                      // specify HID_DOS_PATHS for dos paths
    OUT LPTSTR pszDatabasePath,
    IN  DWORD  dwBufferSize    // in tchars
    )
{
    TCHAR   szAppPatch[MAX_PATH];
    TCHAR   szTemp[MAX_PATH];
    LPCTSTR pszDatabase = NULL;
    LPCTSTR pszDir      = NULL;
    LCID    lcid;
    int     nLen;

    if (dwFlags & HID_DOS_PATHS) {
         SdbpGetAppPatchDir(szAppPatch);
    } else {
        _tcscpy(szAppPatch, TEXT("\\SystemRoot\\AppPatch"));
    }

    if (!(dwDatabaseType & SDB_DATABASE_MAIN)) { // cannot get it for non-main d
        return 0;
    }

    pszDir = szAppPatch;

    switch (dwDatabaseType & SDB_DATABASE_TYPE_MASK) {

    case SDB_DATABASE_MAIN_DRIVERS:
        pszDatabase = TEXT("drvmain.sdb");
        break;

    case SDB_DATABASE_MAIN_MSI:
        pszDatabase = TEXT("msimain.sdb");
        break;

    case SDB_DATABASE_MAIN_SHIM:
        pszDatabase = TEXT("sysmain.sdb");
        break;

    case SDB_DATABASE_MAIN_TEST:
        pszDatabase = TEXT("systest.sdb");
        break;

    case SDB_DATABASE_MAIN_SP_DETAILS:
        pszDatabase = TEXT("apph_sp.sdb");
        break;

    case SDB_DATABASE_MAIN_DETAILS:
        //
        // The code below is not operational on nt4 yet. It would prevent sdbapiu from
        // working properly as GetUserDefaultUILanguage does not exist.
        //
#ifndef WIN32U_MODE

        lcid = GetUserDefaultUILanguage();

        if (lcid != MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)) {

            BOOL  bFoundDB = FALSE;
            TCHAR szTemp[MAX_PATH];

            //
            // When doing this, always remember which apppatch we are putting up here
            // we need to form our own private apppatch
            //
            nLen = _sntprintf(szTemp,
                              CHARCOUNT(szTemp),
                              TEXT("%s\\MUI\\%04x\\apphelp.sdb"),
                              szAppPatch,
                              lcid);
            if (nLen > 0) {
                if (dwFlags & HID_DOS_PATHS) {
                    bFoundDB = RtlDoesFileExists_U(szTemp);
                } else {
                    bFoundDB = SdbpDoesFileExistNTPath(szTemp);
                }
            }

            if (bFoundDB) {
                _sntprintf(szTemp, CHARCOUNT(szTemp), TEXT("MUI\\%04x\\apphelp.sdb"), lcid);

                pszDatabase = szTemp;
            }
        }
#else
        UNREFERENCED_PARAMETER(lcid);
#endif
        if (pszDatabase == NULL) {

            //
            // Standard case
            //
            pszDatabase = TEXT("apphelp.sdb");
        }

        break;
    }

    if (pszDatabase == NULL) {
        DBGPRINT((sdlError,
                  "SdbpGetStandardDatabasePath",
                  "Cannot get the path for database type 0x%lx\n",
                  dwDatabaseType));
        return 0;
    }

    if (pszDatabasePath != NULL) {
        nLen = _sntprintf(pszDatabasePath,
                          (int)dwBufferSize,
                          TEXT("%s\\%s"),
                          pszDir,
                          pszDatabase);
    } else {
        nLen = -1;
    }

    if (nLen < 0) {
        if (pszDatabasePath != NULL) {
            DBGPRINT((sdlError, "SdbpGetStandardDatabasePath", "Path is too long\n"));
        }

        //
        // Calc expected length. One for term null char and one for "\\" ...
        //
        nLen = (pszDir == NULL ? 0 : _tclen(pszDir)) + _tcslen(pszDatabase) + 1 + 1;
    }

    return (DWORD)nLen;
}


DWORD
SDBAPI
SdbResolveDatabase(
    IN  GUID*   pguidDB,            // pointer to the database guid to resolve
    OUT LPDWORD lpdwDatabaseType,   // optional pointer to the database type
    OUT LPTSTR  pszDatabasePath,    // optional pointer to the database path
    IN  DWORD   dwBufferSize        // size of the buffer pszDatabasePath
    )
{
    WCHAR               wszFullKey[1024];
    UNICODE_STRING      ustrFullKey;
    UNICODE_STRING      ustrKey;
    UNICODE_STRING      ustrPath;
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE              KeyHandle = NULL;
    ULONG               KeyValueBuffer[256];
    ULONG               KeyValueLength = 0;
    BOOL                bRet = FALSE;
    ULONG               PathValueLength = 0; // this is return result
    DWORD               dwDatabaseType  = 0;
    int                 i;

    PKEY_VALUE_PARTIAL_INFORMATION  KeyValueInformation;

    static struct tagSTDGUIDSDB {
        const GUID* pGuid;
        DWORD dwDatabaseType;
    } guidStd[] = {
            { &GUID_SYSMAIN_SDB,    SDB_DATABASE_MAIN_SHIM    },
            { &GUID_MSIMAIN_SDB,    SDB_DATABASE_MAIN_MSI     },
            { &GUID_DRVMAIN_SDB,    SDB_DATABASE_MAIN_DRIVERS },
            { &GUID_APPHELP_SDB,    SDB_DATABASE_MAIN_DETAILS },
            { &GUID_APPHELP_SP_SDB, SDB_DATABASE_MAIN_SP_DETAILS},
            { &GUID_SYSTEST_SDB,    SDB_DATABASE_MAIN_TEST    }
    };

    for (i = 0; i < ARRAYSIZE(guidStd); ++i) {
        if (!memcmp(guidStd[i].pGuid, pguidDB, sizeof(GUID))) {
            dwDatabaseType = guidStd[i].dwDatabaseType;
            break;
        }
    }

    if (i < ARRAYSIZE(guidStd)) {
        DWORD dwLen;

        dwLen = SdbpGetStandardDatabasePath(dwDatabaseType,
                                            HID_DOS_PATHS,
                                            pszDatabasePath,
                                            dwBufferSize);
        if (lpdwDatabaseType != NULL) {
            *lpdwDatabaseType = dwDatabaseType;
        }
        return dwLen;
    }

    ustrFullKey.Buffer        = wszFullKey;
    ustrFullKey.MaximumLength = sizeof(wszFullKey);
    ustrFullKey.Length        = 0;

    RtlAppendUnicodeToString(&ustrFullKey, APPCOMPAT_KEY_PATH_MACHINE_INSTALLEDSDB);
    RtlAppendUnicodeToString(&ustrFullKey, L"\\");

    Status = GUID_TO_UNICODE_STRING(pguidDB, &ustrKey);
    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbResolveDatabase",
                  "Failed to convert guid to string status 0x%lx\n",
                  Status));
        goto HandleError; // 0 means error
    }

    RtlAppendUnicodeStringToString(&ustrFullKey, &ustrKey);

    FREE_GUID_STRING(&ustrKey);

    InitializeObjectAttributes(&ObjectAttributes,
                               &ustrFullKey,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&KeyHandle, GENERIC_READ|SdbpGetWow64Flag(), &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbResolveDatabase",
                  "Failed to open Key \"%s\" Status 0x%lx\n",
                  ustrFullKey.Buffer,
                  Status));
        goto HandleError;
    }

    //
    // Now since we were able to open the key -- database was found, recover path and type
    //
    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;

    Status = NtQueryValueKey(KeyHandle,
                             &g_ustrDatabasePath,
                             KeyValuePartialInformation,
                             KeyValueInformation,
                             sizeof(KeyValueBuffer),
                             &KeyValueLength);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbResolveDatabase",
                  "Failed trying to query value \"%s\" Status 0x%lx\n",
                  g_ustrDatabasePath.Buffer,
                  Status));
        goto HandleError;
    }


    switch (KeyValueInformation->Type) {

    case REG_SZ:

        PathValueLength = KeyValueInformation->DataLength;

        if (pszDatabasePath == NULL || dwBufferSize * sizeof(WCHAR) < PathValueLength) {
            DBGPRINT((sdlWarning,
                      "SdbResolveDatabase",
                      "Insufficient buffer for the database path\n"));
            goto HandleError;
        }

        RtlMoveMemory(pszDatabasePath, KeyValueInformation->Data, PathValueLength);
        break;

    case REG_EXPAND_SZ:

        ustrKey.Buffer          = (PWSTR)&KeyValueInformation->Data;
        ustrKey.Length          = (USHORT)(KeyValueInformation->DataLength - sizeof(UNICODE_NULL));
        ustrKey.MaximumLength   = (USHORT)KeyValueInformation->DataLength;

        ustrPath.Buffer         = pszDatabasePath;
        ustrPath.Length         = 0;
        ustrPath.MaximumLength  = (USHORT)(dwBufferSize * sizeof(WCHAR));

        Status = RtlExpandEnvironmentStrings_U(NULL, &ustrKey, &ustrPath, &PathValueLength);

        if (Status == STATUS_BUFFER_TOO_SMALL) {
            DBGPRINT((sdlWarning, "SdbResolveDatabase", "Insufficient buffer to expand path\n"));
            goto HandleError;
        }

        if (!NT_SUCCESS(Status)) {
            PathValueLength = 0;
        }

        break;

    default:
        DBGPRINT((sdlError,
                  "SdbResolveDatabase",
                  "Wrong key type 0x%lx\n",
                  KeyValueInformation->Type));

        PathValueLength = 0;
        goto HandleError;
        break;
    }

    if (lpdwDatabaseType != NULL) {

        //
        // Query for the database type
        //
        Status = NtQueryValueKey(KeyHandle,
                                 &g_ustrDatabaseType,
                                 KeyValuePartialInformation,
                                 KeyValueInformation,
                                 sizeof(KeyValueBuffer),
                                 &KeyValueLength);

        if (NT_SUCCESS(Status)) {

            if (KeyValueInformation->Type != REG_DWORD) {
                //
                // bummer, get out -- wrong type
                //
                DBGPRINT((sdlError,
                          "SdbResolveDatabase",
                          "Wrong database type - value type 0x%lx\n",
                          KeyValueInformation->Type));
                PathValueLength = 0;
                goto HandleError;
            }

            //
            // Else, we get the value
            //
            RtlMoveMemory(lpdwDatabaseType, &KeyValueInformation->Data, sizeof(*lpdwDatabaseType));

        } else {
            *lpdwDatabaseType = 0; // we do not have any value then
        }
    }

HandleError:

    if (KeyHandle != NULL) {
        NtClose(KeyHandle);
    }

    return PathValueLength / sizeof(WCHAR);
}

LPTSTR
SDBAPI
SdbGetLayerName(
    IN  HSDB   hSDB,
    IN  TAGREF trLayer
    )
/*++
    Return: BUGBUG

    Desc:   BUGBUG
--*/
{
    PDB    pdb;
    TAGID  tiLayer, tiName;
    LPTSTR pwszName;

    if (!SdbTagRefToTagID(hSDB, trLayer, &pdb, &tiLayer)) {
        DBGPRINT((sdlError,
                  "SdbGetLayerName",
                  "Failed to get tag id from tag ref 0x%lx\n",
                  trLayer));
        return NULL;
    }

    tiName = SdbFindFirstTag(pdb, tiLayer, TAG_NAME);

    if (tiName == TAGID_NULL) {
        DBGPRINT((sdlError,
                  "SdbGetLayerName",
                  "Failed to get the name tag id for 0x%lx\n",
                  tiName));
        return NULL;
    }

    pwszName = SdbGetStringTagPtr(pdb, tiName);

    if (pwszName == NULL) {
        DBGPRINT((sdlError,
                  "SdbGetLayerName",
                  "Cannot read the name of the layer tag id 0x%lx\n",
                  tiName));
    }

    return pwszName;
}


/*++
    SdbBuildComapatEnvVar

    This function builds the environment variable necessary for
    Compat Layer propagation

--*/

DWORD
SDBAPI
SdbBuildCompatEnvVariables(
    IN  HSDB            hSDB,
    IN  SDBQUERYRESULT* psdbQuery,
    IN  DWORD           dwFlags,
    IN  LPCWSTR         pwszParentEnv OPTIONAL, // environment which contains vars
                                                // that we shall inherit from
    OUT LPWSTR          pBuffer,
    IN  DWORD           cbSize,   // size of the buffer in tchars
    OUT LPDWORD         lpdwShimsCount OPTIONAL
    )
{
    int    i;
    TCHAR  szFullEnvVar[MAX_PATH];
    TAGREF trShimRef;
    INT    nCountLayers = 0;
    DWORD  dwSizeRequired;

    //
    // Count the DLLs that trLayer uses, and put together the environment variable
    //
    szFullEnvVar[0] = TEXT('\0');

    //
    // Make sure to propagate the flags.
    //
    if (!(dwFlags & SBCE_ADDITIVE)) {
        _tcscat(szFullEnvVar, TEXT("!"));
    }

    if (dwFlags & SBCE_INCLUDESYSTEMEXES) {
        _tcscat(szFullEnvVar, TEXT("#"));
    }

    for (i = 0; i < SDB_MAX_LAYERS && psdbQuery->atrLayers[i] != TAGREF_NULL; ++i) {
        WCHAR* pszEnvVar;

        //
        // Get the environment var and tack it onto the full string
        //
        pszEnvVar = SdbGetLayerName(hSDB, psdbQuery->atrLayers[i]);

        if (pszEnvVar) {
            if (nCountLayers) {
                _tcscat(szFullEnvVar, TEXT(" "));
            }
            ++nCountLayers;
            _tcscat(szFullEnvVar, pszEnvVar);
        }

        if (lpdwShimsCount != NULL) {

            //
            // Keep counting the dlls.
            //
            trShimRef = SdbFindFirstTagRef(hSDB, psdbQuery->atrLayers[i], TAG_SHIM_REF);

            while (trShimRef != TAGREF_NULL) {
                (*lpdwShimsCount)++;
                trShimRef = SdbFindNextTagRef(hSDB, psdbQuery->atrLayers[i], trShimRef);
            }
        }
    }

    dwSizeRequired = _tcslen(szFullEnvVar) + _tcslen(g_szCompatLayer) + 3;

    if (cbSize < dwSizeRequired || pBuffer == NULL) {
        //
        // need g_szCompatLayer + '=' + \0 + szFullEnvVar space in the buffer
        //
        return dwSizeRequired;
    }

    return (DWORD)_stprintf(pBuffer, TEXT("%s=%s%c"), g_szCompatLayer, szFullEnvVar, TEXT('\0'));

    UNREFERENCED_PARAMETER(pwszParentEnv);
}

DWORD
SdbpGetProcessorArchitecture(
    VOID
    )
{
    static DWORD dwProcessorArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;

    SYSTEM_PROCESSOR_INFORMATION ProcessorInfo;
    NTSTATUS                     Status;
    PVOID                        Wow64Info = NULL;

    if (dwProcessorArchitecture != PROCESSOR_ARCHITECTURE_UNKNOWN) {
        goto Cleanup;
    }

    Status = NtQuerySystemInformation(SystemProcessorInformation,
                                      &ProcessorInfo,
                                      sizeof(ProcessorInfo),
                                      NULL);
    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbpGetProcessorArchitecture",
                  "Failed to obtain system processor information 0x%lx\n",
                  Status));
        goto Cleanup;
    }

    dwProcessorArchitecture = ProcessorInfo.ProcessorArchitecture;

#ifndef _WIN64
    if (dwProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {
        //
        // If we are not 64 bit native -- then we need to make sure this is not
        // an emulation layer that we are running on
        //
        Status = NtQueryInformationProcess(NtCurrentProcess(),
                                           ProcessWow64Information,
                                           &Wow64Info,
                                           sizeof(Wow64Info),
                                           NULL);

        if (NT_SUCCESS(Status) && Wow64Info != NULL) {
            dwProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA32_ON_WIN64;
        }
    }
#endif // _WIN64

Cleanup:

    return dwProcessorArchitecture;
}

#define FULL_TABLETPC_KEY_PATH  KEY_MACHINE TEXT("\\") TABLETPC_KEY_PATH
#define FULL_EHOME_KEY_PATH     KEY_MACHINE TEXT("\\") EHOME_KEY_PATH

BOOL
SdbpIsOs(
    DWORD dwOSSKU
    )
{
    BOOL                            bRet = FALSE;
    UNICODE_STRING                  ustrKeyPath = {0};
    UNICODE_STRING                  ustrValue;
    NTSTATUS                        status;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    HANDLE                          KeyHandle;
    PKEY_VALUE_PARTIAL_INFORMATION  KeyValueInformation;
    ULONG                           KeyValueBuffer[64];
    ULONG                           KeyValueLength;

    if (dwOSSKU == OS_SKU_TAB) {
        RtlInitUnicodeString(&ustrKeyPath, FULL_TABLETPC_KEY_PATH);
    } else if (dwOSSKU == OS_SKU_MED) {
        RtlInitUnicodeString(&ustrKeyPath, FULL_EHOME_KEY_PATH);
    } else {
        DBGPRINT((sdlWarning,
                  "SdbpIsOs",
                  "Specified unknown OS type 0x%lx",
                  dwOSSKU));
        return FALSE;
    }

    InitializeObjectAttributes(
        &ObjectAttributes,
        &ustrKeyPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    status = NtOpenKey(
        &KeyHandle,
        KEY_QUERY_VALUE | SdbpGetWow64Flag(),
        &ObjectAttributes);

    if (!NT_SUCCESS(status)) {
        DBGPRINT((sdlWarning,
                  "SdbpIsOs",
                  "Failed to open Key %s Status 0x%lx",
                  ustrKeyPath.Buffer,
                  status));
        goto out;
    }

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)&KeyValueBuffer;
    RtlInitUnicodeString(&ustrValue, IS_OS_INSTALL_VALUE);

    status = NtQueryValueKey(
        KeyHandle,
        &ustrValue,
        KeyValuePartialInformation,
        KeyValueInformation,
        sizeof(KeyValueBuffer),
        &KeyValueLength);

    NtClose(KeyHandle);

    if (!NT_SUCCESS(status)) {
        DBGPRINT((sdlWarning,
                  "SdbpIsOs",
                  "Failed to read value info for value %s for key %s Status 0x%lx",
                  IS_OS_INSTALL_VALUE,
                  ustrKeyPath.Buffer,
                  status));
        goto out;
    }

    if (KeyValueInformation->Type != REG_DWORD) {
        DBGPRINT((sdlWarning,
                  "SdbpIsOs",
                  "Unexpected value type 0x%x for value %s under key %s",
                  KeyValueInformation->Type,
                  IS_OS_INSTALL_VALUE,
                  ustrKeyPath.Buffer));
        goto out;
    }

    if (*(DWORD*)(&KeyValueInformation->Data[0]) != 0) {
        bRet = TRUE;
    }

    DBGPRINT((sdlInfo|sdlLogPipe,
              "SdbpIsOs",
              "%s %s installed",
              0,
              (dwOSSKU == OS_SKU_TAB ? TEXT("TabletPC") : TEXT("eHome")),
              (bRet ? TEXT("is") : TEXT("is not"))));

out:

    return bRet;
}

void
SdbpGetOSSKU(
    LPDWORD lpdwSKU,
    LPDWORD lpdwSP
    )
{
    WORD wServicePackMajor;
    WORD wSuiteMask;
    WORD wProductType;
    PPEB Peb = NtCurrentPeb();

    wServicePackMajor = (Peb->OSCSDVersion >> 8) & 0xFF;

    wSuiteMask = (USHORT)(USER_SHARED_DATA->SuiteMask & 0xffff);

    *lpdwSP = 1 << wServicePackMajor;

    wSuiteMask = wSuiteMask;

    wProductType = USER_SHARED_DATA->NtProductType;

    if (wProductType == VER_NT_WORKSTATION) {
        if (wSuiteMask & VER_SUITE_PERSONAL) {
            *lpdwSKU = OS_SKU_PER;
        } else {

#if (_WIN32_WINNT >= 0x0501)

            if (SdbpIsOs(OS_SKU_TAB)) {
                *lpdwSKU = OS_SKU_TAB;
            } else if (SdbpIsOs(OS_SKU_MED)) {
                *lpdwSKU = OS_SKU_MED;
            } else {
                *lpdwSKU = OS_SKU_PRO;
            }
#else
            *lpdwSKU = OS_SKU_PRO;
#endif
        }
        return;
    }

    if (wSuiteMask & VER_SUITE_DATACENTER) {
        *lpdwSKU = OS_SKU_DTC;
        return;
    }

    if (wSuiteMask & VER_SUITE_ENTERPRISE) {
        *lpdwSKU = OS_SKU_ADS;
        return;
    }

    if (wSuiteMask & VER_SUITE_BLADE) {
        *lpdwSKU = OS_SKU_BLA;
        return;
    }

    *lpdwSKU = OS_SKU_SRV;
}

DWORD
SdbpGetWow64Flag(
    VOID
    )
{
    if (g_dwWow64Key == (DWORD)-1) {

        OSVERSIONINFOEXW osvi;
        BOOL             bSuccess;

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);

#ifdef WIN32U_MODE
        bSuccess = GetVersionExW((POSVERSIONINFOW)&osvi);
#else
        bSuccess = NT_SUCCESS(RtlGetVersion((PRTL_OSVERSIONINFOW)&osvi));
#endif
        if (bSuccess) {

            //
            // Straight win2k
            //
            if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0) {

                g_dwWow64Key = 0; // no flag since there is no wow64 on win2k

            } else {

                g_dwWow64Key = KEY_WOW64_64KEY;
            }


        } else {

            DBGPRINT((sdlError, "SdbGetWow64Flag", "RtlGetVersion failed\n"));

            //
            // XP or higher.
            //
            g_dwWow64Key = KEY_WOW64_64KEY;
        }
    }

    return g_dwWow64Key;
}

NTSTATUS
SDBAPI
SdbEnsureBufferSizeFunction(
    IN ULONG           Flags,
    IN OUT PRTL_BUFFER Buffer,
    IN SIZE_T          Size
    )
{
    HMODULE hModNtdll;

    if (g_pfnEnsureBufferSize == NULL) {

        hModNtdll = GetModuleHandleW(L"ntdll.dll");

        if (hModNtdll == NULL) {
            DBGPRINT((sdlError,
                      "SdbEnsureBufferSizeFunction",
                      "Failed to retrieve ntdll.dll module handle, Error 0x%lx\n",
                      GetLastError()));
            return STATUS_UNSUCCESSFUL;
        }

        g_pfnEnsureBufferSize = (PFNEnsureBufferSize)GetProcAddress(hModNtdll,
                                                                    "RtlpEnsureBufferSize");

        if (g_pfnEnsureBufferSize == NULL) {

            DBGPRINT((sdlError,
                      "SdbEnsureBufferSizeFunction",
                      "RtlpEnsureBufferSize is not available, reverting to sdbapi\n"));

            g_pfnEnsureBufferSize = SdbpEnsureBufferSize;
        }
    }

    return g_pfnEnsureBufferSize(Flags, Buffer, Size);
}

HANDLE
SdbpOpenDebugPipe(
    void
    )
{
    OBJECT_ATTRIBUTES       ObjectAttributes;
    NTSTATUS                Status;
    HANDLE                  hPipe = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK         IoStatusBlock;
    FILE_PIPE_INFORMATION   FilePipeInfo;

    InitializeObjectAttributes(&ObjectAttributes,
                               &g_ustrDebugPipeName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    IoStatusBlock.Status = 0;
    IoStatusBlock.Information = 0;

    //
    // Open the named pipe
    //
    Status = NtCreateFile(&hPipe,
                          FILE_GENERIC_WRITE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_OPEN,
                          0,
                          NULL,
                          0);

    if ((!NT_SUCCESS(Status) || INVALID_HANDLE_VALUE == hPipe)) {

        if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
            DBGPRINT((sdlWarning,
                      "SdbpOpenDebugPipe",
                      "Failed to create debug pipe, status 0x%lx\n",
                      Status));
        }

        return INVALID_HANDLE_VALUE;
    }

    //
    // Change the mode of the named pipe to message mode
    //
    FilePipeInfo.ReadMode       = FILE_PIPE_MESSAGE_MODE;
    FilePipeInfo.CompletionMode = FILE_PIPE_QUEUE_OPERATION;

    Status = NtSetInformationFile(hPipe,
                                  &IoStatusBlock,
                                  &FilePipeInfo,
                                  sizeof(FilePipeInfo),
                                  FilePipeInformation);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlWarning,
                  "SdbpOpenDebugPipe",
                  "Failed to set pipe mode, status 0x%lx\n",
                  Status));

        NtClose(hPipe);
        hPipe = INVALID_HANDLE_VALUE;
    }

    return hPipe;
}

BOOL
SdbpCloseDebugPipe(
    IN HANDLE hPipe
    )
{
    if (hPipe != INVALID_HANDLE_VALUE) {
        NtClose(hPipe);
    }
    return TRUE;
}

BOOL
SdbpWriteDebugPipe(
    HSDB    hSDB,
    LPCSTR  pszBuffer
    )
{
    DWORD           dwBufferSize;
    ANSI_STRING     strMessage;
    UNICODE_STRING  ustrMessage;
    NTSTATUS        Status = STATUS_UNSUCCESSFUL;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER   liOffset = { 0 };
    PSDBCONTEXT     pSdbContext = (PSDBCONTEXT)hSDB;
    HANDLE          hPipe = INVALID_HANDLE_VALUE;
    BOOL            bClosePipe = FALSE;
    PCHAR           pchStart;
    PCHAR           pch;
    PWCHAR          pwch;

    if (pSdbContext == NULL) {
        hPipe = SdbpOpenDebugPipe();
        bClosePipe = TRUE;
    } else {
        hPipe = pSdbContext->hPipe;
    }

    if (hPipe == INVALID_HANDLE_VALUE ||
        pszBuffer == NULL) {
        return FALSE;
    }

    //
    // Preprocess the string to eliminate any \t \r \n
    //
    pchStart = (PCHAR)pszBuffer;

    while (pchStart != NULL && *pchStart) {

        //
        // Skip over white space and any empty lines
        //
        pchStart += strspn(pchStart, " \t\r\n");

        pch = strpbrk(pchStart, "\r\n");

        if (pch == NULL) {
            RtlInitAnsiString(&strMessage, pchStart);
            pchStart = NULL;
        } else {

            //
            // if it's a tab, nuke it by replacing it with ' '
            //

            strMessage.Buffer = pchStart;
            strMessage.MaximumLength =
            strMessage.Length        = (USHORT)((DWORD_PTR)pch - (DWORD_PTR)pchStart); // size in bytes

            //
            // now adjust the pointer past \r\n
            //
            pchStart = pch + strspn(pch, "\r\n");
        }

        if (strMessage.Length == 0) {
            continue;
        }


        Status = RtlAnsiStringToUnicodeString(&ustrMessage, &strMessage, TRUE);

        if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlWarning,
                      "SdbpWriteDebugPipe",
                      "Failed to convert string to unicode status 0x%lx\n",
                      Status));
            goto cleanup;
        }

        //
        // Second line of defense against rogue chars in shimviewer.
        // Search and replace all instances of '\t' with ' '
        //
        pwch = ustrMessage.Buffer;

        while (pwch != NULL && *pwch) {

            pwch = wcschr(pwch, L'\t');

            if (pwch != NULL) {
                *pwch++ = L' ';
            }
        }

        IoStatusBlock.Status = 0;
        IoStatusBlock.Information = 0;

        Status = NtWriteFile(pSdbContext->hPipe,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             (PVOID)ustrMessage.Buffer,
                             ustrMessage.Length,
                             &liOffset,
                             NULL);

        RtlFreeUnicodeString(&ustrMessage);

        if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlWarning,
                      "SdbpWriteDebugPipe",
                      "Failed to write data to debug pipe, Status 0x%lx\n",
                      Status));
            if (Status == STATUS_PIPE_BROKEN) {
                bClosePipe = TRUE;
                goto cleanup;
            }
        }
    }

cleanup:

    if (bClosePipe) {
        SdbpCloseDebugPipe(hPipe);
        hPipe = INVALID_HANDLE_VALUE;
    }

    //
    // We do cleanup depending on the context
    //
    if (pSdbContext != NULL) {
        pSdbContext->hPipe = hPipe; // so that we don't do it again in case of an error
    }

    return NT_SUCCESS(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\sources.inc ===
!IF 0

Copyright (c) 1991  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

MAJORCOMP=AppCompat

SYNCHRONIZE_BLOCK=1

TARGETPATH=$(_OBJ_DIR)

SOURCES=\
        ..\sdbapi.c     \
        ..\read.c       \
        ..\findtag.c    \
        ..\hash.c       \
        ..\dbaccess.c   \
        ..\attributes.c \
        ..\index.c      \
        ..\guid.c

PRECOMPILED_INCLUDE=..\sdbp.h

MSC_WARNING_LEVEL=/WX /W3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\sdbapiplus.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        sdbapiplus.c

    Abstract:

        BUGBUG: This module implements ...

    Author:

        dmunsil    created     sometime in 1999

    Revision History:

        several people contributed (vadimb, clupu, ...)

--*/

#include "sdbp.h"

TCHAR g_szProcessHistory[] = TEXT("__PROCESS_HISTORY");
TCHAR g_szCompatLayer[]    = TEXT("__COMPAT_LAYER");

#ifdef _DEBUG_SPEW
extern DBGLEVELINFO g_rgDbgLevelInfo[];
extern PCH          g_szDbgLevelUser;
#endif // _DEBUG_SPEW


BOOL
SdbpCheckRuntimePlatform(
    IN PSDBCONTEXT pContext,   // pointer to the database channel
    IN LPCTSTR     pszMatchingFile,
    IN DWORD       dwPlatformDB
    )
{
    DWORD dwPlatform = pContext->dwRuntimePlatform;
    BOOL  bMatch = FALSE;
    BOOL  bMatchElement;
    DWORD dwElement;
    INT   i;

    if (dwPlatformDB == RUNTIME_PLATFORM_ANY) {
        return TRUE;
    }

    //
    // Check for all 3 supported platforms.
    //
    for (i = 0; i < 3; ++i) {
        dwElement = (dwPlatformDB >> (i * 8)) & RUNTIME_PLATFORM_MASK_ELEMENT;
        if (!(dwElement & RUNTIME_PLATFORM_FLAG_VALID)) { // this is not a valid element - move on
            continue;
        }

        bMatchElement = (dwPlatform == (dwElement & RUNTIME_PLATFORM_MASK_VALUE));
        if (dwElement & RUNTIME_PLATFORM_FLAG_NOT_ELEMENT) {
            bMatchElement = !bMatchElement;
        }

        bMatch |= bMatchElement;
    }

    if (dwPlatformDB & RUNTIME_PLATFORM_FLAG_NOT) {
        bMatch = !bMatch;
    }

    if (!bMatch) {
        DBGPRINT((sdlInfo,
                  "SdbpCheckRuntimePlatform",
                  "Platform Mismatch for \"%s\" Database(0x%lx) vs 0x%lx\n",
                  (pszMatchingFile ? pszMatchingFile : TEXT("Unknown")),
                  dwPlatformDB,
                  dwPlatform));
    }

    return bMatch;
}

BOOL
SafeNCat(
    LPTSTR  lpszDest,
    int     nSize,
    LPCTSTR lpszSrc,
    int     nSizeAppend
    )
{
    int nLen = _tcslen(lpszDest);
    int nLenAppend = _tcslen(lpszSrc);

    if (nSizeAppend >= 0 && nLenAppend > nSizeAppend) {
        nLenAppend = nSizeAppend;
    }

    if (nSize < nLen + nLenAppend + 1) {
        return FALSE;
    }

    RtlCopyMemory(lpszDest + nLen, lpszSrc, nLenAppend * sizeof(*lpszSrc));
    *(lpszDest + nLen + nLenAppend) = TEXT('\0');

    return TRUE;
}

BOOL
SdbpSanitizeXML(
    LPTSTR  pchOut,
    int     nSize,
    LPCTSTR lpszXML
    )
{
    LPCTSTR pch;
    LPCTSTR pchCur = lpszXML;
    LPCTSTR rgSC[] = { TEXT("&amp;"), TEXT("&quot;"), TEXT("&lt;"), TEXT("&gt;") };
    LPCTSTR rgSpecialChars = TEXT("&\"<>"); // should be the same as above
    LPCTSTR pchSpecial;
    int     iReplace; // & should be first in both lists above
    int     nLen;
    int     i;

    if (nSize < 1) {
        return FALSE;
    }

    *pchOut = TEXT('\0');

    while (*pchCur) {

        pch = _tcspbrk(pchCur, rgSpecialChars);
        if (NULL == pch) {
            // no more chars -- copy the rest
            if (!SafeNCat(pchOut, nSize, pchCur, -1)) {
                return FALSE;
            }
            break;
        }

        // copy up to pch
        if (!SafeNCat(pchOut, nSize, pchCur, (int)(pch - pchCur))) {
            return FALSE;
        }

        if (*pch == TEXT('&')) {
            for (i = 0; i < ARRAYSIZE(rgSC); ++i) {
                nLen = _tcslen(rgSC[i]);
                if (_tcsnicmp(rgSC[i], pch, nLen) == 0) {
                    // ok, move along, we are not touching this
                    break;
                }
            }

            if (i < ARRAYSIZE(rgSC)) {
                // do not touch the string
                // nLen is the length we need to skip
                if (!SafeNCat(pchOut, nSize, pch, nLen)) {
                    return FALSE;
                }
                pchCur = pch + nLen;
                continue;
            }

            iReplace = 0;
        } else {

            pchSpecial = _tcschr(rgSpecialChars, *pch);
            if (pchSpecial == NULL) {
                // internal error -- what is this ?
                return FALSE;
            }

            iReplace = (int)(pchSpecial - rgSpecialChars);
        }

        // so instead of pch we will have rgSC[i]
        if (!SafeNCat(pchOut, nSize, rgSC[iReplace], -1)) {
            return FALSE;
        }
        pchCur = pch + 1; // move on to the next char
    }

    return TRUE;
}

BOOL
SdbTagIDToTagRef(
    IN  HSDB    hSDB,
    IN  PDB     pdb,        // PDB the TAGID is from
    IN  TAGID   tiWhich,    // TAGID to convert
    OUT TAGREF* ptrWhich    // converted TAGREF
    )
/*++
    Return: TRUE if a TAGREF was found, FALSE otherwise.

    Desc:   Converts a PDB and TAGID into a TAGREF, by packing the high bits of the
            TAGREF with a constant that tells us which PDB, and the low bits with
            the TAGID.
--*/
{
    PSDBCONTEXT pSdbContext = (PSDBCONTEXT)hSDB;
    BOOL        bReturn = FALSE;
    PSDBENTRY   pEntry;
    DWORD       dwIndex = SDBENTRY_INVALID_INDEX;

    if (SdbpFindLocalDatabaseByPDB(hSDB, pdb, FALSE, &dwIndex)) {
        *ptrWhich = tiWhich | SDB_INDEX_TO_MASK(dwIndex);
        bReturn = TRUE;
    }

    if (!bReturn) {
        DBGPRINT((sdlError, "SdbTagIDToTagRef", "Bad PDB.\n"));
        *ptrWhich = TAGREF_NULL;
    }

    return bReturn;
}

BOOL
SdbTagRefToTagID(
    IN  HSDB   hSDB,
    IN  TAGREF trWhich,     // TAGREF to convert
    OUT PDB*   ppdb,        // PDB the TAGREF is from
    OUT TAGID* ptiWhich     // TAGID within that PDB
    )
/*++
    Return: TRUE if the TAGREF is valid and was converted, FALSE otherwise.

    Desc:   Converts a TAGREF type to a TAGID and a PDB. This manages the interface
            between NTDLL, which knows nothing of PDBs, and the shimdb, which manages
            three separate PDBs. The TAGREF incorporates the TAGID and a constant
            that tells us which PDB the TAGID is from. In this way, the NTDLL client
            doesn't need to know which DB the info is coming from.
--*/
{
    PSDBCONTEXT pSdbContext = (PSDBCONTEXT)hSDB;
    BOOL        bReturn = TRUE;
    TAGID       tiWhich = TAGID_NULL;
    PDB         pdb     = NULL;
    DWORD       dwMask;
    DWORD       dwIndex;
    DWORD       dwCount;
    PSDBENTRY   pEntry;

    assert(ppdb && ptiWhich);

    tiWhich = trWhich & TAGREF_STRIP_TAGID;
    dwIndex = SDB_MASK_TO_INDEX(trWhich & TAGREF_STRIP_PDB);

    //
    // Dynamically open a custom sdb.
    //
    pEntry = SDBGETENTRY(pSdbContext, dwIndex);

    if (pEntry->dwFlags & SDBENTRY_VALID_ENTRY) {
        pdb = pEntry->pdb;
    } else {
        if (pEntry->dwFlags & SDBENTRY_VALID_GUID) {

            //
            // We have a "half-baked" entry, make sure we 
            // fill this entry in.
            //
            GUID guidDB = pEntry->guidDB;
            
            pEntry->dwFlags = 0; // invalidate an entry so that we know it's empty
            
            bReturn = SdbOpenLocalDatabaseEx(hSDB,
                                             &guidDB,
                                             SDBCUSTOM_GUID | SDBCUSTOM_USE_INDEX,
                                             &pdb,
                                             &dwIndex);
            if (!bReturn) {
                goto cleanup;
            }
        }
    }

    if (pdb == NULL && tiWhich != TAGID_NULL) {
        DBGPRINT((sdlError, "SdbTagRefToTagID", "PDB dereferenced by this TAGREF is NULL\n"));
        bReturn = FALSE;
    }

cleanup:

    if (ppdb != NULL) {
        *ppdb = pdb;
    }

    if (ptiWhich != NULL) {
        *ptiWhich = tiWhich;
    }

    return bReturn;
}

PDB
SdbGetLocalPDB(
    IN HSDB hSDB
    )
{
    PSDBCONTEXT pSdbContext = (PSDBCONTEXT)hSDB;
    
    if (pSdbContext) {
        return pSdbContext->pdbLocal;
    }
    
    return NULL;
}

BOOL
SdbIsTagrefFromMainDB(
    IN  TAGREF trWhich          // TAGREF to test if it's from the main DB
    )
/*++
    Return: TRUE if the TAGREF is from sysmain.sdb, FALSE otherwise.

    Desc:   Checks if the provided TAGREF belongs to sysmain.sdb.
--*/
{
    return ((trWhich & TAGREF_STRIP_PDB) == PDB_MAIN);
}

BOOL
SdbIsTagrefFromLocalDB(
    IN  TAGREF trWhich          // TAGREF to test if it's from the local DB
    )
/*++
    Return: TRUE if the TAGREF is from a local SDB, FALSE otherwise.

    Desc:   Checks if the provided TAGREF belongs to a local SDB.
--*/
{
    return ((trWhich & TAGREF_STRIP_PDB) == PDB_LOCAL);
}

BOOL
SdbGetDatabaseGUID(
    IN  HSDB    hSDB,               // HSDB of the sdbContext (optional)
    IN  PDB     pdb,                // PDB of the database in question
    OUT GUID*   pguidDB             // the guid of the DB
    )
/*++
    Return: TRUE if the GUID could be retrieved from the pdb, FALSE otherwise.

    Desc:   Gets the GUID from an SDB file. If the hSDB is passed in, it will
            also check if the GUID is from systest or sysmain and return
            one of the hard-coded GUIDs for those files.
--*/
{
    if (!pdb) {
        DBGPRINT((sdlError, "SdbGetDatabaseGUID", "NULL pdb passed in.\n"));
        return FALSE;
    }
    
    if (!pguidDB) {
        DBGPRINT((sdlError, "SdbGetDatabaseGUID", "NULL pguidDB passed in.\n"));
        return FALSE;
    }

    if (hSDB) {
        PSDBCONTEXT pSdbContext = (PSDBCONTEXT)hSDB;
        DWORD       dwIndex;
        
        if (SdbpFindLocalDatabaseByPDB(hSDB, pdb, FALSE, &dwIndex)) {
            
            //
            // Found the db, copy guid, we're done
            //
            if (pSdbContext->rgSDB[dwIndex].dwFlags & SDBENTRY_VALID_GUID) {
                RtlCopyMemory(pguidDB, &pSdbContext->rgSDB[dwIndex].guidDB, sizeof(*pguidDB));
                return TRUE;
            }
        }
    }

    return SdbGetDatabaseID(pdb, pguidDB);
}

PDB
SdbGetPDBFromGUID(
    IN  HSDB    hSDB,               // HSDB
    IN  GUID*   pguidDB             // the guid of the DB
    )
{
    PSDBCONTEXT     pSdbContext = (PSDBCONTEXT)hSDB;
    PSDBENTRY       pEntry;
    GUID            guidTemp;
    DWORD           dwIndex;
    PDB             pdb = NULL;

    if (!pSdbContext) {
        return NULL;
    }

    if (!SdbpFindLocalDatabaseByGUID(hSDB, pguidDB, FALSE, &dwIndex)) {
        return NULL;
    }

    pEntry = &pSdbContext->rgSDB[dwIndex];
    
    if (pEntry->dwFlags & SDBENTRY_VALID_ENTRY) {
        pdb = pEntry->pdb;
    } else {
        //
        // Open local db
        //
        if (!SdbOpenLocalDatabaseEx(hSDB, 
                                    pguidDB, 
                                    SDBCUSTOM_GUID|SDBCUSTOM_USE_INDEX, 
                                    &pdb, 
                                    &dwIndex)) {
            DBGPRINT((sdlWarning, "SdbGetPDBFromGUID", "Failed to open dormant pdb\n"));
        }
    }

    return pdb;
}

typedef struct tagFlagInfoEntry {
    
    ULONGLONG ullFlagMask; // mask of the flag
    DWORD     dwSize;  // size of the structure
    TAG       tFlagType;
    TCHAR     szCommandLine[0];

} FLAGINFOENTRY, *PFLAGINFOENTRY;

typedef struct tagFlagInfo {
    DWORD     dwSize; // total size
    DWORD     dwCount; // number of entries
    //
    // This member below is not allowed due to 0-size szCommandLine array, so it's implied
    //
    // FLAGINFOENTRY FlagInfoEntry[0]; // not a real array
    //
} FLAGINFO, *PFLAGINFO;

typedef struct tagFlagInfoListEntry* PFLAGINFOLISTENTRY;

typedef struct tagFlagInfoListEntry {
    
    ULONGLONG           ullFlagMask;
    TAG                 tFlagType;
    LPCTSTR             pszCommandLine; // points to the currently open db
    DWORD               dwEntrySize;
    PFLAGINFOLISTENTRY  pNext;

} FLAGINFOLISTENTRY;

typedef FLAGINFOLISTENTRY* PFLAGINFOCONTEXT;

#define ALIGN_ULONGLONG(p) \
    ((((ULONG_PTR)(p)) + (sizeof(ULONGLONG) - 1)) & ~(sizeof(ULONGLONG) - 1))

BOOL
SDBAPI
SdbpPackCmdLineInfo(
    IN  PVOID   pvFlagInfoList,
    OUT PVOID*  ppFlagInfo
    )
{
    PFLAGINFOLISTENTRY pFlagInfoList = (PFLAGINFOLISTENTRY)pvFlagInfoList;
    PFLAGINFOLISTENTRY pEntry;
    DWORD              dwSize = 0;
    DWORD              dwFlagCount = 0;
    DWORD              dwEntrySize;
    PFLAGINFO          pFlagInfo;
    PFLAGINFOENTRY     pFlagInfoEntry;

    pEntry = pFlagInfoList;
    
    while (pEntry != NULL) {
        pEntry->dwEntrySize = ALIGN_ULONGLONG(sizeof(FLAGINFOENTRY) +
                                              (_tcslen(pEntry->pszCommandLine) +
                                               1) * sizeof(TCHAR));
        dwSize += pEntry->dwEntrySize;
        pEntry = pEntry->pNext;
        ++dwFlagCount;
    }

    dwSize += sizeof(FLAGINFO);

    //
    // Allocate memory
    //
    pFlagInfo = (PFLAGINFO)SdbAlloc(dwSize);
    
    if (pFlagInfo == NULL) {
        DBGPRINT((sdlError,
                  "SdbpPackCmdLineInfo",
                  "Failed to allocate 0x%lx bytes for FlagInfo\n",
                  dwSize));

        return FALSE;
    }

    pFlagInfo->dwSize  = dwSize;
    pFlagInfo->dwCount = dwFlagCount;
    pFlagInfoEntry = (PFLAGINFOENTRY)(pFlagInfo + 1);

    pEntry = pFlagInfoList;
    
    while (pEntry != NULL) {
        //
        // Create an entry
        //
        pFlagInfoEntry->ullFlagMask = pEntry->ullFlagMask;
        pFlagInfoEntry->dwSize      = pEntry->dwEntrySize;
        pFlagInfoEntry->tFlagType   = pEntry->tFlagType;
        
        //
        // Copy the string
        //
        _tcscpy(&pFlagInfoEntry->szCommandLine[0], pEntry->pszCommandLine);

        //
        // Advance to the next entry
        //
        pFlagInfoEntry = (PFLAGINFOENTRY)((PBYTE)pFlagInfoEntry + pFlagInfoEntry->dwSize);

        pEntry = pEntry->pNext;
    }

    *ppFlagInfo = (PVOID)pFlagInfo;

    return TRUE;


}

BOOL
SDBAPI
SdbpFreeFlagInfoList(
    IN PVOID pvFlagInfoList
    )
{
    PFLAGINFOLISTENTRY pFlagInfoList = (PFLAGINFOLISTENTRY)pvFlagInfoList;
    PFLAGINFOLISTENTRY pNext;

    while (pFlagInfoList != NULL) {
        pNext = pFlagInfoList->pNext;
        SdbFree(pFlagInfoList);
        pFlagInfoList = pNext;
    }

    return TRUE;
}


BOOL
SDBAPI
SdbQueryFlagInfo(
    IN PVOID     pvFlagInfo,
    IN TAG       tFlagType,
    IN ULONGLONG ullFlagMask,
    OUT LPCTSTR* ppCmdLine
    )
{
    PFLAGINFO      pFlagInfo      = (PFLAGINFO)pvFlagInfo;
    PFLAGINFOENTRY pFlagInfoEntry = (PFLAGINFOENTRY)(pFlagInfo+1);
    int i;

    for (i = 0; i < (int)pFlagInfo->dwCount; ++i) {

        if (pFlagInfoEntry->tFlagType   == tFlagType &&
            pFlagInfoEntry->ullFlagMask == ullFlagMask) {
            
            if (ppCmdLine != NULL) {
                *ppCmdLine = &pFlagInfoEntry->szCommandLine[0];
            }
            
            return TRUE;
        }

        pFlagInfoEntry = (PFLAGINFOENTRY)((PBYTE)pFlagInfoEntry + pFlagInfoEntry->dwSize);
    }

    return FALSE;
}

BOOL
SDBAPI
SdbFreeFlagInfo(
    IN PVOID pvFlagInfo
    )
{
    PFLAGINFO pFlagInfo = (PFLAGINFO)pvFlagInfo;

    if (pFlagInfo != NULL) {
        SdbFree(pFlagInfo);
    }

    return TRUE;
}

BOOL
SDBAPI
SdbpGetFlagCmdLine(
    IN PFLAGINFOCONTEXT* ppFlagInfo,
    IN HSDB              hSDB,
    IN TAGREF            trFlagRef,
    IN TAG               tFlagType,
    IN ULONGLONG         ullFlagMask,
    IN BOOL              bOverwrite
    )
{
    TAGREF             trFlagCmdLine;
    BOOL               bReturn = FALSE;
    LPCTSTR            lpszCmdLine;
    PFLAGINFOLISTENTRY pFlagInfoListEntry;
    PFLAGINFOLISTENTRY pFlagPrev;

    //
    // We start by getting the cmd line
    //
    trFlagCmdLine = SdbFindFirstTagRef(hSDB, trFlagRef, TAG_COMMAND_LINE);

    if (trFlagCmdLine == TAGREF_NULL) { // no cmd line for this flag
        bReturn = TRUE;
        goto Cleanup;
    }

    //
    // Now we get the rest of the info
    //
    lpszCmdLine = SdbpGetStringRefPtr(hSDB, trFlagCmdLine);
    
    if (lpszCmdLine == NULL) {
        DBGPRINT((sdlError,
                  "SdbpGetFlagCmdLine",
                  "Failed to read TAG_COMMAND_LINE string\n"));
        goto Cleanup;
    }

    //
    // Check whether we have already command line for this flag
    //
    pFlagInfoListEntry = *ppFlagInfo;
    pFlagPrev = NULL;
    
    while (pFlagInfoListEntry != NULL) {

        if (pFlagInfoListEntry->tFlagType   == tFlagType &&
            pFlagInfoListEntry->ullFlagMask == ullFlagMask) {
            break;
        }

        pFlagPrev = pFlagInfoListEntry;
        pFlagInfoListEntry = pFlagInfoListEntry->pNext;
    }

    if (pFlagInfoListEntry != NULL) {
        
        if (bOverwrite) { // found the same flag, overwrite

            if (pFlagPrev == NULL) {
                *ppFlagInfo = pFlagInfoListEntry->pNext;
            } else {
                pFlagPrev->pNext = pFlagInfoListEntry->pNext;
            }
            
            SdbFree(pFlagInfoListEntry);

        } else { // same entry, no overwriting
            bReturn = TRUE;
            goto Cleanup;
        }
    }

    //
    // We have everything we need - make a context entry
    //
    pFlagInfoListEntry = (PFLAGINFOLISTENTRY)SdbAlloc(sizeof(FLAGINFOLISTENTRY));
    
    if (pFlagInfoListEntry == NULL) {
        DBGPRINT((sdlError,
                  "SdbpGetFlagCmdLine",
                  "Failed to allocate FLAGINFOLISTENTRY\n"));
        goto Cleanup;
    }

    pFlagInfoListEntry->ullFlagMask    = ullFlagMask;
    pFlagInfoListEntry->tFlagType      = tFlagType;
    pFlagInfoListEntry->pszCommandLine = lpszCmdLine;
    pFlagInfoListEntry->pNext          = *ppFlagInfo;
    *ppFlagInfo = pFlagInfoListEntry;

    bReturn = TRUE;

Cleanup:

    return bReturn;
}


BOOL
SDBAPI
SdbQueryFlagMask(
    IN  HSDB            hSDB,
    IN  SDBQUERYRESULT* psdbQuery,
    IN  TAG             tFlagType,
    OUT ULONGLONG*      pullFlags,
    IN OUT PVOID*       ppFlagInfo OPTIONAL
    )
{
    DWORD            dwInd;
    TAGREF           trFlagRef;
    TAGREF           trFlag;
    TAGREF           trFlagMask;
    TAGREF           trFlagCmdLine;
    ULONGLONG        ullFlagMask;
    PFLAGINFOCONTEXT pFlagInfoContext = NULL;

    if (pullFlags == NULL) {
        DBGPRINT((sdlError, "SdbQueryFlagMask", "Invalid parameter.\n"));
        return FALSE;
    }

    *pullFlags = 0;
    
    if (ppFlagInfo != NULL) {
        pFlagInfoContext = *(PFLAGINFOCONTEXT*)ppFlagInfo;
    }

    for (dwInd = 0; psdbQuery->atrExes[dwInd] != TAGREF_NULL && dwInd < SDB_MAX_EXES; dwInd++) {

        trFlagRef = SdbFindFirstTagRef(hSDB, psdbQuery->atrExes[dwInd], TAG_FLAG_REF);

        while (trFlagRef != TAGREF_NULL) {
            
            trFlag = SdbGetFlagFromFlagRef(hSDB, trFlagRef);
            
            if (trFlag == TAGREF_NULL) {
                DBGPRINT((sdlError,
                          "SdbQueryFlagMask",
                          "Failed to get TAG from TAGREF 0x%x.\n",
                          trFlagRef));
                break;
            }

            ullFlagMask = 0;

            trFlagMask = SdbFindFirstTagRef(hSDB, trFlag, tFlagType);
            
            if (trFlagMask != TAGREF_NULL) {
                ullFlagMask = SdbReadQWORDTagRef(hSDB, trFlagMask, 0);
            }

            *pullFlags |= ullFlagMask;

            //
            // Now we get command line - if we have retrieved the flag mask
            //
            if (ppFlagInfo != NULL && ullFlagMask) {
                if (!SdbpGetFlagCmdLine(&pFlagInfoContext,
                                        hSDB,
                                        trFlagRef,
                                        tFlagType,
                                        ullFlagMask,
                                        TRUE)) {
                    //
                    // BUGBUG: this has to be handled as an error
                    // Currently we do not do this b/c it is not
                    // as important -- pFlagInfoContext will not be
                    // touched if this function had failed
                    //
                    break;
                }
            }

            trFlagRef = SdbFindNextTagRef(hSDB, psdbQuery->atrExes[dwInd], trFlagRef);
        }
    }

    for (dwInd = 0;
         psdbQuery->atrLayers[dwInd] != TAGREF_NULL && dwInd < SDB_MAX_LAYERS;
         dwInd++) {

        trFlagRef = SdbFindFirstTagRef(hSDB, psdbQuery->atrLayers[dwInd], TAG_FLAG_REF);

        while (trFlagRef != TAGREF_NULL) {
            trFlag = SdbGetFlagFromFlagRef(hSDB, trFlagRef);

            if (trFlag == TAGREF_NULL) {
                DBGPRINT((sdlError,
                          "SdbQueryFlagMask",
                          "Failed to get TAG from TAGREF 0x%x.\n",
                          trFlagRef));
                break;
            }

            ullFlagMask = 0;

            trFlagMask = SdbFindFirstTagRef(hSDB, trFlag, tFlagType);
            
            if (trFlagMask != TAGREF_NULL) {
                ullFlagMask = SdbReadQWORDTagRef(hSDB, trFlagMask, 0);
            }

            *pullFlags |= ullFlagMask;

            if (ppFlagInfo != NULL && ullFlagMask) {
                SdbpGetFlagCmdLine(&pFlagInfoContext,
                                   hSDB,
                                   trFlagRef,
                                   tFlagType,
                                   ullFlagMask,
                                   FALSE);
            }

            trFlagRef = SdbFindNextTagRef(hSDB, psdbQuery->atrLayers[dwInd], trFlagRef);
        }
    }

    if (ppFlagInfo != NULL) {
        *ppFlagInfo = (PVOID)pFlagInfoContext;
    }

    return TRUE;
}


BOOL
SdbpIsPathOnCdRom(
    LPCTSTR pszPath
    )
{
    TCHAR szDrive[5];
    UINT  unType;

    if (pszPath == NULL) {
        DBGPRINT((sdlError,
                  "SdbpIsPathOnCdRom",
                  "NULL parameter passed for szPath.\n"));
        return FALSE;
    }

    if (pszPath[1] != _T(':') && pszPath[1] != _T('\\')) {
        //
        // Not a path we recognize.
        //
        DBGPRINT((sdlInfo,
                  "SdbpIsPathOnCdRom",
                  "\"%s\" not a full path we can operate on.\n",
                  pszPath));
        return FALSE;
    }

    if (pszPath[1] == _T('\\')) {
        //
        // Network path.
        //
        return FALSE;
    }

    memcpy(szDrive, _T("c:\\"), 4 * sizeof(TCHAR));
    szDrive[0] = pszPath[0];

    unType = GetDriveType(szDrive);

    if (unType == DRIVE_CDROM) {
        return TRUE;
    }

    return FALSE;
}

BOOL
SdbpBuildSignature(
    LPCTSTR pszPath,
    LPTSTR  pszPathSigned
    )
{
    TCHAR           szDir[MAX_PATH];
    TCHAR*          pszEnd;
    DWORD           dwSignature = 0;
    HANDLE          hFind;
    WIN32_FIND_DATA ffd;
    int             nCount = 9;

    _tcsncpy(szDir, pszPath, MAX_PATH);
    szDir[MAX_PATH - 1] = 0;

    pszEnd = _tcsrchr(szDir, _T('\\'));
    if (pszEnd != NULL) {
        ++pszEnd;
    } else {
        pszEnd = szDir;
    }

    *pszEnd++ = _T('*');
    *pszEnd   = _T('\0');

    hFind = FindFirstFile(szDir, &ffd);

    if (hFind == INVALID_HANDLE_VALUE) {
        DBGPRINT((sdlInfo,
                  "SdbPathRequiresSignature",
                  "\"%s\" not a full path we can operate on.\n",
                  pszPath));
        return FALSE;
    }

    do {
        if (!(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            ffd.nFileSizeLow != 0) {

            dwSignature = ((dwSignature << 1) | (dwSignature >> 31)) ^ ffd.nFileSizeLow;

            nCount--;
        }

        if (!FindNextFile(hFind, &ffd)) {
            break;
        }

    } while (nCount > 0);

    FindClose(hFind);

    //
    // pszPath always starts with x:\\
    //
    _stprintf(pszPathSigned, _T("SIGN=%X %s"), dwSignature, pszPath + 3);

    return TRUE;
}


LPTSTR
GetProcessHistory(
    IN  LPCTSTR pEnvironment,
    IN  LPTSTR  szDir,
    IN  LPTSTR  szName
    )
/*++
    Return: The __PROCESS_HISTORY content from the environment.

    Desc:   The function retrieves Process History given the environment, an exe name and
            it's directory. Process History is constructed from the __PROCESS_HISTORY environment
            variable with an addition of the current exe path. The memory buffer returned from this
            function should be freed using SdbFree
--*/
{
    UNICODE_STRING  ProcessHistoryEnvVarName;
    UNICODE_STRING  ProcessHistory;
    NTSTATUS        Status;
    ULONG           ProcessHistorySize = 0;
    ULONG           DirLen  = 0, NameLen = 0;
    DWORD           dwBufferLength   = 0;
    LPTSTR          szProcessHistory = NULL;
    LPTSTR          pszHistory       = NULL;

    assert(szDir != NULL && szName != NULL);

    DirLen  = _tcslen(szDir);
    NameLen = _tcslen(szName);

    Status = SdbpGetEnvVar(pEnvironment,
                           g_szProcessHistory,
                           NULL,
                           &dwBufferLength);

    if (STATUS_BUFFER_TOO_SMALL == Status) {
        ProcessHistorySize = (DirLen + NameLen + 2 + dwBufferLength) * sizeof(TCHAR);
    } else {
        //
        // We assume that the environment variable is not available.
        //
        assert(Status == STATUS_VARIABLE_NOT_FOUND);

        ProcessHistorySize = (DirLen + NameLen + 1) * sizeof(TCHAR);
    }

    //
    // Allocate the buffer, regardless of whether there is
    // an environment variable or not. Later, we will check Status again
    // to see whether we need to try to query for an environment variable
    // with a valid buffer.
    //
    pszHistory = szProcessHistory = SdbAlloc(ProcessHistorySize);

    if (szProcessHistory == NULL) {
        DBGPRINT((sdlError,
                  "GetProcessHistory",
                  "Unable to allocate %d bytes for process history.\n",
                  ProcessHistorySize));

        return NULL;
    }

    *pszHistory = 0;

    if (Status == STATUS_BUFFER_TOO_SMALL) {

        //
        // In this case we have tried to obtain the __PROCESS_HISTORY and
        // the variable was present as indicated by the status
        //
        Status = SdbpGetEnvVar(pEnvironment,
                               g_szProcessHistory,
                               szProcessHistory,
                               &dwBufferLength);

        if (NT_SUCCESS(Status)) {
            //
            // See if we have ';' at the end of this.
            //
            pszHistory = szProcessHistory + dwBufferLength - 1;
            
            if (*pszHistory != TEXT(';')) {
                *++pszHistory = TEXT(';');
            }

            ++pszHistory;
        }
    }

    //
    // The __PROCESS_HISTORY environment variable has the following format:
    //
    //     __PROCESS_HISTORY=C:\ProcessN-2.exe;D:\ProcessN-1.exe
    //
    // and then the following lines tack on the current process like so:
    //
    //     __PROCESS_HISTORY=C:\ProcessN-2.exe;D:\ProcessN-1.exe;D:\Child\ProcessN.exe
    //

    RtlMoveMemory(pszHistory, szDir, DirLen * sizeof(TCHAR));
    pszHistory += DirLen;

    RtlMoveMemory(pszHistory, szName, NameLen * sizeof(TCHAR));
    pszHistory += NameLen;
    *pszHistory = TEXT('\0');

    return szProcessHistory;
}


TAGREF
SdbpGetNamedLayerFromExe(
    IN  HSDB  hSDB,
    IN  PDB   pdb,
    IN  TAGID tiLayer
    )
/*++
    Return: A TAGREF for the layer under the EXE tag or TAGREF_NULL if there is no layer.

    Desc:   BUGBUG: ?
--*/
{
    PSDBCONTEXT pSdbContext = (PSDBCONTEXT)hSDB;
    TAGREF      trLayer;
    TAGID       tiDatabase, tiName;
    TCHAR*      pszName;
    BOOL        bSuccess;

    //
    // Read the layer's name.
    //
    tiName = SdbFindFirstTag(pdb, tiLayer, TAG_NAME);

    if (tiName == TAGID_NULL) {
        DBGPRINT((sdlError, "SdbpGetNamedLayerFromExe", "Layer tag w/o a name.\n"));
        return TAGREF_NULL;
    }

    pszName = SdbGetStringTagPtr(pdb, tiName);

    if (pszName == NULL) {
        DBGPRINT((sdlError,
                  "SdbpGetNamedLayerFromExe",
                  "Cannot read the name of the layer tag.\n"));
        return TAGREF_NULL;
    }

    //
    // First, try to find the layer in the same db as the EXE
    //
    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);

    assert(tiDatabase != TAGID_NULL);

    trLayer = TAGREF_NULL;

    tiLayer = SdbFindFirstNamedTag(pdb,
                                   tiDatabase,
                                   TAG_LAYER,
                                   TAG_NAME,
                                   pszName);

    if (tiLayer != TAGID_NULL) {
        bSuccess = SdbTagIDToTagRef(pSdbContext, pdb, tiLayer, &trLayer);

        if (!bSuccess) {
            DBGPRINT((sdlError, "SdbpGetNamedLayerFromExe", "Cannot get tag ref from tag id.\n"));
        }

        return trLayer;
    }

    if (pdb != pSdbContext->pdbMain) {
        //
        // Try it now in the main db
        //
        tiDatabase = SdbFindFirstTag(pSdbContext->pdbMain, TAGID_ROOT, TAG_DATABASE);

        tiLayer = SdbFindFirstNamedTag(pSdbContext->pdbMain,
                                       tiDatabase,
                                       TAG_LAYER,
                                       TAG_NAME,
                                       pszName);

        if (tiLayer != TAGID_NULL) {
            bSuccess = SdbTagIDToTagRef(pSdbContext, pSdbContext->pdbMain, tiLayer, &trLayer);

            if (!bSuccess) {
                DBGPRINT((sdlError,
                          "SdbpGetNamedLayerFromExe",
                          "Cannot get tag ref from tag id.\n"));
            }
        }
    }

    return trLayer;
}


TAGREF
SDBAPI
SdbGetNamedLayer(
    IN HSDB hSDB,               // database context
    IN TAGREF trLayerRef        // tagref of a record referencing a layer
    )
{
    PDB    pdb        = NULL;
    TAGID  tiLayerRef = TAGID_NULL;
    TAGREF trLayer    = TAGREF_NULL;

    if (!SdbTagRefToTagID(hSDB, trLayerRef, &pdb, &tiLayerRef)) {
        DBGPRINT((sdlError, "SdbGetNamedLayer",
                   "Error converting tagref 0x%lx to tagid\n", trLayerRef));
        return TAGREF_NULL;
    }

    return SdbpGetNamedLayerFromExe(hSDB, pdb, tiLayerRef);
}

//
// This code is only needed when not running in Kernel Mode
//

TAGREF
SdbGetLayerTagReg(
    IN  HSDB    hSDB,
    IN  LPCTSTR szLayer
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    TAGID       tiDatabase;
    TAGID       tiLayer;
    TAGREF      trLayer;
    PSDBCONTEXT pSdbContext = (PSDBCONTEXT)hSDB;

    if (pSdbContext == NULL || pSdbContext->pdbMain == NULL) {
        DBGPRINT((sdlError, "SdbGetLayerTagReg", "Invalid parameters.\n"));
        return TAGREF_NULL;
    }

    tiDatabase = SdbFindFirstTag(pSdbContext->pdbMain, TAGID_ROOT, TAG_DATABASE);

    tiLayer = SdbFindFirstNamedTag(pSdbContext->pdbMain,
                                   tiDatabase,
                                   TAG_LAYER,
                                   TAG_NAME,
                                   szLayer);

    if (tiLayer == TAGID_NULL) {
        DBGPRINT((sdlError, "SdbGetLayerTagReg", "No layer \"%s\" exists.\n", szLayer));
        return TAGREF_NULL;
    }

    if (!SdbTagIDToTagRef(hSDB, pSdbContext->pdbMain, tiLayer, &trLayer)) {
        DBGPRINT((sdlError,
                  "SdbGetLayerTagReg",
                  "Cannot get tagref for tagid 0x%x.\n",
                  tiLayer));
        return TAGREF_NULL;
    }

    return trLayer;
}


TCHAR g_szWhiteSpaceDelimiters[] = TEXT(" \t");

BOOL
SdbParseLayerString(
    IN  PSDBCONTEXT     pSdbContext,
    IN  LPTSTR          pszLayerString,
    IN  PSDBQUERYRESULT pQueryResult,
    IN  PDWORD          pdwLayers,
    OUT PBOOL           pbAppendLayer // an equivalent of "exclusive" flag
    )
{
    TCHAR* pszLayerStringStart = NULL;
    TCHAR  szLayer[MAX_PATH];
    TAGID  tiDatabase = TAGID_NULL;
    TAGID  tiLayer  = TAGID_NULL;
    PDB    pdbLayer = NULL;             // pdb that contains the match for the layer
    BOOL   fSuccess = FALSE;

    //
    // Skip over and handle special flag characters
    //    '!' means don't use any EXE entries
    //    '#' means go ahead and apply layers to system EXEs (we don't handle this)
    //

    //
    // Skip over the white spaces...
    //
    pszLayerString += _tcsspn(pszLayerString, g_szWhiteSpaceDelimiters);

    //
    // Next up is the ! or # or both
    //
    while (*pszLayerString != _T('\0') &&
           _tcschr(TEXT("!# \t"), *pszLayerString) != NULL) {

        //
        // ! is processed here
        //
        if (*pszLayerString == _T('!') && pbAppendLayer) {
            *pbAppendLayer = FALSE;
        }

        pszLayerString++;
    }

    //
    // Now we should be at the beginning of the layer string.
    //
    while (pszLayerString != NULL && *pszLayerString != _T('\0')) {
        //
        // Beginning of the string, remember the ptr
        //
        pszLayerStringStart = pszLayerString;

        //
        // Move the end to the first space.
        //
        pszLayerString = _tcspbrk(pszLayerStringStart, g_szWhiteSpaceDelimiters);

        //
        // Check whether it's all the way to the end
        //
        if (pszLayerString != NULL) {
            //
            // Terminate the string...
            //
            *pszLayerString++ = _T('\0');

            //
            // Skip white space.
            //
            pszLayerString += _tcsspn(pszLayerString, g_szWhiteSpaceDelimiters);
        }

        //
        // Now pszLayerStringStart points to the layer string that needs
        // to be examined.
        //
        _tcscpy(szLayer, pszLayerStringStart);

        //
        // Search the layer in the test database first.
        //
        if (pSdbContext->pdbTest != NULL) {
            tiDatabase = SdbFindFirstTag(pSdbContext->pdbTest, TAGID_ROOT, TAG_DATABASE);
            pdbLayer = pSdbContext->pdbTest;

            tiLayer = SdbFindFirstNamedTag(pSdbContext->pdbTest,
                                           tiDatabase,
                                           TAG_LAYER,
                                           TAG_NAME,
                                           szLayer);
        }

        if (tiLayer == TAGID_NULL) {
            //
            // Now search the layer in the main database.
            //
            tiDatabase = SdbFindFirstTag(pSdbContext->pdbMain, TAGID_ROOT, TAG_DATABASE);
            pdbLayer = pSdbContext->pdbMain;

            tiLayer = SdbFindFirstNamedTag(pSdbContext->pdbMain,
                                           tiDatabase,
                                           TAG_LAYER,
                                           TAG_NAME,
                                           szLayer);
        }

        if (tiLayer != TAGID_NULL) {
            goto foundDB;
        }

        //
        // Check if the layer is defined in a custom database
        //
        {
            DWORD dwLocalIndex = 0;

            while (SdbOpenNthLocalDatabase((HSDB)pSdbContext, szLayer, &dwLocalIndex, TRUE)) {

                tiDatabase = SdbFindFirstTag(pSdbContext->pdbLocal, TAGID_ROOT, TAG_DATABASE);

                if (tiDatabase != TAGID_NULL) {
                    tiLayer = SdbFindFirstNamedTag(pSdbContext->pdbLocal,
                                                   tiDatabase,
                                                   TAG_LAYER,
                                                   TAG_NAME,
                                                   szLayer);

                    if (tiLayer != TAGID_NULL) {
                        pdbLayer = pSdbContext->pdbLocal;
                        goto foundDB;
                    }
                } else {
                    DBGPRINT((sdlError, "SdbParseLayerString", "Local database is corrupted!\n"));
                }

                SdbCloseLocalDatabase((HSDB)pSdbContext);
            }
        } 

foundDB:
        if (tiLayer != TAGID_NULL) {

            if (!SdbpAddMatch(pQueryResult,
                              pSdbContext,
                              pdbLayer,
                              NULL,
                              0,
                              &tiLayer,
                              1,
                              NULL,
                              0,
                              NULL)) {
                //
                // Error would have already been logged
                //
                break;
            }

            DBGPRINT((sdlWarning|sdlLogPipe,
                      "SdbParseLayerString",
                      "Invoking compatibility layer \"%s\".\n",
                      pSdbContext,
                      szLayer));

        }

        tiLayer = TAGID_NULL;
        pdbLayer = NULL;
    }

    return TRUE;
}

BOOL
SdbOpenNthLocalDatabase(
    IN  HSDB    hSDB,           // handle to the database channel
    IN  LPCTSTR pszItemName,    // the name of the exectutable, without the path or the layer name
    IN  LPDWORD pdwIndex,       // zero based index of the local DB to open
    IN  BOOL    bLayer
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Opens the Nth local database.
--*/
{
    TCHAR   szSDBPath[MAX_PATH];
    TCHAR   szSDBName[MAX_PATH];
    DWORD   dwLength = sizeof(szSDBName);
    BOOL    bRet = FALSE;
    GUID    guidDB;
    DWORD   dwDatabaseType;
    DWORD   dwIndex;

    //
    // Keep trying until there aren't any more user SDB files, or
    // we find one we can open. This is to guard against a missing file
    // causing us to ignore all further SDB files.
    //
    while (!bRet) {
        if (!SdbGetNthUserSdb(hSDB, pszItemName, bLayer, pdwIndex, &guidDB)) {
            break; // we have no more dbs
        }

        //
        // Resolve the database we got through the local database interface
        //
        DBGPRINT((sdlInfo,
                  "SdbOpenNthLocalDatabase",
                  "Attempting to open local database %d\n",
                  *pdwIndex,
                  szSDBPath));

        //
        // See if we already have the database open
        //
        if (SdbpFindLocalDatabaseByGUID(hSDB, &guidDB, FALSE, &dwIndex)) {
            
            PSDBENTRY pEntry = SDBGETENTRY(hSDB, dwIndex);
            
            //
            // This database is already open, remember, we treat pdbLocal as a junk
            // pointer, which ALWAYS stores the result of this operation
            // 
            assert(pEntry->dwFlags & SDBENTRY_VALID_ENTRY);
            assert(pEntry->pdb != NULL);
            
            ((PSDBCONTEXT)hSDB)->pdbLocal = pEntry->pdb;
            bRet = TRUE;
            break;
        }
            
        dwIndex = PDB_LOCAL;
        bRet = SdbOpenLocalDatabaseEx(hSDB,
                                      &guidDB,
                                      SDBCUSTOM_GUID_BINARY|SDBCUSTOM_USE_INDEX,
                                      NULL,
                                      &dwIndex);
        //
        // In reality the function above will not do extra work to map the db
        // if it already is mapped and opened (retained)
        //
    }

    return bRet;
}

/*++

    SdbGetMatchingExe

    This is where the bulk of the work gets done. A full path of an EXE gets passed in,
    and the function searches the database for potential matches. If a match is found,
    the TAGREF of the EXE record in the database is passed back to be used for future
    queries. If no match is found, the return is TAGREF_NULL.

    The TAGREF returned by this function must be released by calling SdbReleaseMatchingExe
    when finished with it. This only pertains to this TAGREF, not to TAGREFs in general.

    ppContext is an optional parameter
        if NULL, it has no effect
        if not-null then it contains a pointer to the retained search context which
        is useful when performing multiple search passes

    using ppContext:

        PVOID pContext = NULL;

        SdbGetMatchingExe(TAG_EXE, L"foo\foo.exe", pEnv, &pContext, &trExe, &trLayer);

        then you can use the context like this:

        SdbGetMatchingExe(TAG_APPHELP_EXE, L"foo\foo.exe", pEnv, &pContext, &trExe, &trLayer);

        to free the search context use
        vFreeSearchDBContext(&pContext); <<< pContext is released and set to NULL

        this is done to cache path-related information for a given exe file

--*/
BOOL
SdbpCleanupForExclusiveMatch(
    IN PSDBCONTEXT pSdbContext,
    IN PDB         pdb
    )
{
    DWORD     dwIndex;
    PSDBENTRY pEntry;

    //
    // In doing a cleanup we do not touch the temp db since it's the one 
    // that is currently open (hence pdb parameter)
    // 
    for (dwIndex = 2; dwIndex < ARRAYSIZE(pSdbContext->rgSDB); ++dwIndex) {
        
        if (!SDBCUSTOM_CHECK_INDEX(pSdbContext, dwIndex)) {
            continue;
        }

        pEntry = SDBGETENTRY(pSdbContext, dwIndex);
        
        if (pEntry->pdb == pdb) {
            continue;
        }
        
        //
        // Nuke this entry
        //
        if (!SdbCloseLocalDatabaseEx((HSDB)pSdbContext, NULL, dwIndex)) {
            DBGPRINT((sdlError,
                      "SdbpCleanupForExclusiveMatch",
                      "Failed to close local database\n"));
        }
    }        
        
    return TRUE;    

}


BOOL
SdbpAddMatch(
    IN OUT PSDBQUERYRESULT pQueryResult,
    IN PSDBCONTEXT         pSdbContext,
    IN PDB                 pdb,
    IN TAGID*              ptiExes,
    IN DWORD               dwNumExes,
    IN TAGID*              ptiLayers,
    IN DWORD               dwNumLayers,
    IN GUID*               pguidExeID,
    IN DWORD               dwExeFlags,
    IN OUT PMATCHMODE      pMatchMode
    )
{
    DWORD  dwIndex;
    TAGID  tiLayer;
    TAGREF trLayer;
    BOOL   bSuccess = FALSE;

    if (pMatchMode != NULL) {

        switch (pMatchMode-> Type) {
            
        case MATCH_ADDITIVE:
            //
            // We're ok, add the match 
            //
            break;
            
        case MATCH_NORMAL: 
            //
            // Go ahead, store the result
            //
            break;

        case MATCH_EXCLUSIVE:
            //
            // Purge what we have so far
            //
            RtlZeroMemory(pQueryResult, sizeof(*pQueryResult));

            //
            // Cleanup all the custom sdbs, we will not need to apply any.
            // We need to cleanse all the custom sdbs EXCEPT pdb.
            // This is a tricky operation since pdb may be hosted in any of the custom sdb
            // cells
            //
            SdbpCleanupForExclusiveMatch(pSdbContext, pdb);
            break;

        default:

            //
            // We don't know what this mode is -- error
            //
            DBGPRINT((sdlError,
                      "SdbpAddMatch",
                      "Unknown match mode 0x%lx\n",
                      (DWORD)pMatchMode->Type));
            break;
        }
    }        

    //
    // Check whether this sdb is a custom sdb or local sdb
    //
    if (SdbpIsLocalTempPDB(pSdbContext, pdb)) {

        //
        // Permanentize this sdb -- note that pdb may change while we are here!
        //
        if (SdbpRetainLocalDBEntry(pSdbContext, &pdb) == SDBENTRY_INVALID_INDEX) {

            //
            // Can't permanentize, forget it then
            //
            goto cleanup;
        }
    }

    //
    // Now pdb is either test, main or a permanentized local entry
    //
    if (ptiExes != NULL) {
        for (dwIndex = 0; dwIndex < dwNumExes; ++dwIndex) {

            if (pQueryResult->dwExeCount >= ARRAYSIZE(pQueryResult->atrExes)) {

                DBGPRINT((sdlError,
                          "SdbpAddMatch",
                          "Failed to add the exe: exe count exceeded, tiExe was 0x%lx\n",
                          ptiExes[dwIndex]));
                break;
            }

            bSuccess = SdbTagIDToTagRef(pSdbContext,
                                        pdb,
                                        ptiExes[dwIndex],
                                        &pQueryResult->atrExes[pQueryResult->dwExeCount]);
            
            if (!bSuccess) {
                DBGPRINT((sdlError,
                          "SdbpAddMatch",
                          "Failed to convert tiExe 0x%x to trExe.\n",
                          ptiExes[dwIndex]));
                continue;
            }
            
            ++pQueryResult->dwExeCount;

            tiLayer = SdbFindFirstTag(pdb, ptiExes[dwIndex], TAG_LAYER);
            
            while (tiLayer != TAGID_NULL) {
                
                trLayer = SdbpGetNamedLayerFromExe(pSdbContext, pdb, tiLayer);
                
                if (trLayer == TAGREF_NULL) {
                    DBGPRINT((sdlError,
                              "SdbpAddMatch",
                              "Failed to convert 0x%lx to layer ref\n",
                              tiLayer));
                    continue;
                }

                if (pQueryResult->dwLayerCount >= ARRAYSIZE(pQueryResult->atrLayers)) {
                    
                    DBGPRINT((sdlError,
                              "SdbpAddMatch",
                              "Failed to add the layer: layer count exceeded, tiExe was 0x%lx\n",
                              ptiExes[dwIndex]));
                    break;
                }

                pQueryResult->atrLayers[pQueryResult->dwLayerCount] = trLayer;
                ++pQueryResult->dwLayerCount;

                tiLayer = SdbFindNextTag(pdb, ptiExes[dwIndex], tiLayer);
            }
        }
    }

    if (ptiLayers != NULL) {

        for (dwIndex = 0; dwIndex < dwNumLayers; ++dwIndex) {

            trLayer = SdbpGetNamedLayerFromExe(pSdbContext, pdb, ptiLayers[dwIndex]);
            
            if (trLayer == TAGREF_NULL) {
                DBGPRINT((sdlError,
                          "SdbpAddMatch",
                          "Failed to get layer from 0x%lx\n",
                          ptiLayers[dwIndex]));
                continue;
            }

            if (pQueryResult->dwLayerCount >= ARRAYSIZE(pQueryResult->atrLayers)) {
                DBGPRINT((sdlError,
                          "SdbpAddMatch",
                          "Failed to add the match: layer count exceeded, trLayer was 0x%lx\n",
                          trLayer));
                break; // note that we simply truncate our match
            }

            pQueryResult->atrLayers[pQueryResult->dwLayerCount] = trLayer;
            ++pQueryResult->dwLayerCount;
        }
    }

    bSuccess = TRUE;

cleanup:

    return bSuccess;
}


BOOL
SdbpCaptureCustomSDBInformation(
    IN OUT PSDBQUERYRESULT pQueryResult,
    IN     PSDBCONTEXT     pSdbContext
    )
{
    DWORD     dwIndex;
    TAGREF    trExe;
    TAGREF    trLayer;
    DWORD     dwDatabaseIndex;
    PSDBENTRY pEntry;
    DWORD     dwMap = 0;
    DWORD     dwMask;
    
    //
    // Go through results, pick those sdbs that we need...
    //
    for (dwIndex = 0; dwIndex < pQueryResult->dwExeCount; ++dwIndex) {

        //
        // Get custom sdb for each tagref
        //
        trExe = pQueryResult->atrExes[dwIndex];

        dwDatabaseIndex = SDB_MASK_TO_INDEX(trExe);
        
        dwMask = (1UL << dwDatabaseIndex);

        if (!(dwMap & dwMask)) {
            //
            // Copy the guid
            //
            pEntry = SDBGETENTRY(pSdbContext, dwDatabaseIndex);
            RtlCopyMemory(&pQueryResult->rgGuidDB[dwDatabaseIndex], &pEntry->guidDB, sizeof(GUID));
            dwMap |= dwMask;
        }
    }

    for (dwIndex = 0; dwIndex < pQueryResult->dwLayerCount; ++dwIndex) {

        trLayer = pQueryResult->atrLayers[dwIndex];
        
        dwDatabaseIndex = SDB_MASK_TO_INDEX(trLayer);
        
        dwMask = (1UL << dwDatabaseIndex);

        if (!(dwMap & dwMask)) {
            pEntry = SDBGETENTRY(pSdbContext, dwDatabaseIndex);
            RtlCopyMemory(&pQueryResult->rgGuidDB[dwDatabaseIndex], &pEntry->guidDB, sizeof(GUID));
            dwMap |= dwMask;
        }
    }

    //
    // Map to all the entries we have.
    // Technically we do not need it, but just in case...
    //
    pQueryResult->dwCustomSDBMap = dwMap;

    return TRUE;
}
    

BOOL
SdbGetMatchingExe(
    IN  HSDB            hSDB  OPTIONAL,
    IN  LPCTSTR         szPath,
    IN  LPCTSTR         szModuleName,  // Optional -- only useful for 16-bit apps
    IN  LPCTSTR         pszEnvironment,
    IN  DWORD           dwFlags,
    OUT PSDBQUERYRESULT pQueryResult
    )
/*++
    Return: TRUE if the specified EXE has a match in the database, FALSE otherwise.

    Desc:   This is where the bulk of the work gets done. A full path of an EXE gets
            passed in, and the function searches the database for potential matches.
            If a match is found, the TAGREF of the EXE record in the database is
            passed back to be used for future queries. If no match is found, the
            return is TAGREF_NULL.
            The TAGREF returned by this function must be released by calling
            SdbReleaseMatchingExe when finished with it. This only pertains to
            this TAGREF, not to TAGREFs in general.
--*/
{
    PDB       pdb      = NULL;             // pdb that contains the match for the EXE
    TAG       tSection = TAG_EXE;
    TAGID     atiExes[SDB_MAX_EXES];
    TAGID     tiLayer  = TAGID_NULL;
    DWORD     dwLayers = 0;
    BOOL      bCompatLayer     = FALSE;
    BOOL      bAppendLayer     = TRUE;     // default behavior is to append to existing fixes
    BOOL      bReleaseDatabase = FALSE;
    BOOL      fSuccess = FALSE;
    DWORD     dwBufferSize;
    DWORD     dwLocalIndex = 0;
    DWORD     dwNumExes = 0;
    MATCHMODE MatchMode  = { 0 };
    GUID      guidExeID  = { 0 };
    DWORD     dwExeFlags = 0;

    PSDBCONTEXT     pSdbContext;
    SEARCHDBCONTEXT Context;
    BOOL            bInstrumented = FALSE;
    BOOL            bMatchComplete = FALSE;

    RtlZeroMemory(pQueryResult, sizeof(SDBQUERYRESULT));
    RtlZeroMemory(atiExes, sizeof(atiExes));

    if (hSDB == NULL) {
        hSDB = SdbInitDatabase(HID_DOS_PATHS, NULL);

        if (hSDB == NULL) {
            DBGPRINT((sdlError, "SdbGetMatchingExe", "Failed to open the database.\n"));
            return FALSE;
        }

        bReleaseDatabase = TRUE;
    }

    pSdbContext = (PSDBCONTEXT)hSDB;

    //
    // Initialize matching mode - we set the InterType to none (meaning the first match will 
    // be used to start the process) and IntraType is set to normal (does not really matter)
    //
    
    MatchMode.Type = MATCH_NORMAL;

    //
    // Check whether we have an instrumented run 
    //
    bInstrumented = SDBCONTEXT_IS_INSTRUMENTED(hSDB);

    assert(pSdbContext->pdbMain && szPath);

    RtlZeroMemory(&Context, sizeof(Context)); // do this so that we don't trip later
    
    //
    // We shall use it later to optimize file attribute retrieval
    //
    Context.hMainFile = INVALID_HANDLE_VALUE;

    __try {

        NTSTATUS Status;
        TCHAR    szCompatLayer[MAX_PATH + 1];

        //
        // Check for system exes that WE KNOW we don't want to patch
        //
        DBGPRINT((sdlInfo, "SdbGetMatchingExe", "Looking for \"%s\".\n", szPath));

        if (_tcsnicmp(szPath, TEXT("\\??\\"), 4) == 0 ||
            _tcsnicmp(szPath, TEXT("\\SystemRoot\\"), 12) == 0) {
            goto out;
        }

        //
        // If the search context had been supplied use it, otherwise create one
        //
        if (!SdbpCreateSearchDBContext(&Context, szPath, szModuleName, pszEnvironment)) {
            DBGPRINT((sdlError, "SdbGetMatchingExe", "Failed to create search DB context.\n"));
            goto out;
        }

        //
        // Make sure no local database is opened.
        //
        SdbCloseLocalDatabase(hSDB);

        if (!(dwFlags & SDBGMEF_IGNORE_ENVIRONMENT)) {
            //
            // See if there's an environment variable set called "__COMPAT_LAYER".
            // If so, grab the layers from that variable.
            //
            dwBufferSize = sizeof(szCompatLayer) / sizeof(szCompatLayer[0]);

            Status = SdbpGetEnvVar(pszEnvironment,
                                   g_szCompatLayer,
                                   szCompatLayer,
                                   &dwBufferSize);

            if (Status == STATUS_BUFFER_TOO_SMALL) {
                DBGPRINT((sdlWarning,
                          "SdbGetMatchingExe",
                          "__COMPAT_LAYER name cannot exceed 256 characters.\n"));
            }

            if (NT_SUCCESS(Status)) {
                
                SdbParseLayerString(pSdbContext,
                                    szCompatLayer,
                                    pQueryResult,
                                    &dwLayers,
                                    &bAppendLayer);
                
                if (!bAppendLayer) {
                    //
                    // This is an exclusive matching case, once we determined
                    // that the layers cannot be appended to we get out.
                    //
                    goto out;
                }
            }
        }

        //
        // At this point we might have all the info from the env variable.
        // See if we do, and if so -- check bAppendLayer
        //
        dwBufferSize = sizeof(szCompatLayer);
        
        if (SdbGetPermLayerKeys(szPath, szCompatLayer, &dwBufferSize, GPLK_ALL)) {
            
            SdbParseLayerString(pSdbContext,
                                szCompatLayer,
                                pQueryResult,
                                &dwLayers,
                                &bAppendLayer);
            
            if (!bAppendLayer) {
                goto out;
            }
        } else {
            if (dwBufferSize > sizeof(szCompatLayer)) {
                DBGPRINT((sdlWarning,
                          "SdbGetMatchingExe",
                          "Layers in registry cannot exceed %d characters\n",
                          sizeof(szCompatLayer)/sizeof(szCompatLayer[0])));
            }
        }

        //
        // This block deals with searching local sdbs
        //
        dwLocalIndex = 0;
        
        while (SdbOpenNthLocalDatabase(hSDB, Context.szName, &dwLocalIndex, FALSE)) {
            
            dwNumExes = SdbpSearchDB(pSdbContext,
                                     pSdbContext->pdbLocal,
                                     tSection,
                                     &Context,
                                     atiExes,
                                     &guidExeID,
                                     &dwExeFlags,
                                     &MatchMode);

            if (dwNumExes) {
                pdb = pSdbContext->pdbLocal;
                
                //
                // Report matches in local sdb with mode
                //
                DBGPRINT((sdlInfo,
                          "SdbGetMatchingExe",
                          "Found in local database.\n"));

                if (!bMatchComplete) {

                    //
                    // Add the match in
                    //
                    if (!SdbpAddMatch(pQueryResult,
                                      pSdbContext,
                                      pdb,
                                      atiExes,
                                      dwNumExes,
                                      NULL, 0,      // no layers
                                      &guidExeID,
                                      dwExeFlags,
                                      &MatchMode)) {
                        //
                        // Failed to secure a match, stop matching
                        //
                        goto out;
                    }                                                              
                }

                //
                // We have "current running state" flags in dwMatchingMode 
                //
                if (MatchMode.Type != MATCH_ADDITIVE) {
                    
                    if (bInstrumented) {
                        //
                        // We are running instrumented, prevent further storing of results
                        //
                        bMatchComplete = TRUE;
                        
                        //
                        // Modify match mode so that we keep matching to see if
                        // we get any more matches.
                        //
                        MatchMode.Type  = MATCH_ADDITIVE;
                        
                    } else {
                        goto out;
                    }
                }

                //
                // Note that we do not leak local sdb here since the match was made
                // in a local sdb. Since we added the match, local sdb is "permanentized" 
                //
            }

            //
            // If the match was added, there is no local db to close.
            // However the call below will just (quietly) exit, no harm done.
            //
            SdbCloseLocalDatabase(hSDB);
        }

        //
        // Search systest.sdb database
        //
        if (pSdbContext->pdbTest != NULL) {
            dwNumExes = SdbpSearchDB(pSdbContext,
                                     pSdbContext->pdbTest,
                                     tSection,
                                     &Context,
                                     atiExes,
                                     &guidExeID,
                                     &dwExeFlags,
                                     &MatchMode);
                                     
            if (dwNumExes) {
                pdb = pSdbContext->pdbTest;

                if (!bMatchComplete) {

                    if (!SdbpAddMatch(pQueryResult,
                                      pSdbContext,
                                      pdb,
                                      atiExes,
                                      dwNumExes,
                                      NULL,
                                      0,      // no layers
                                      &guidExeID,
                                      dwExeFlags,
                                      &MatchMode)) {
                        goto out;
                    }
                }
                
                if (MatchMode.Type != MATCH_ADDITIVE) {
                    if (bInstrumented) {
                        //
                        // We are running instrumented, prevent further storing of results
                        //
                        bMatchComplete = TRUE;
                        
                        //
                        // Modify match mode so that we keep matching to see if we
                        // get any more matches.
                        //
                        MatchMode.Type  = MATCH_ADDITIVE;
                        
                    } else {
                        goto out;
                    }
                }

                DBGPRINT((sdlInfo, "SdbGetMatchingExe", "Using SysTest.sdb\n"));
                goto out;
            }
        }

        //
        // Search the main db
        //
        dwNumExes = SdbpSearchDB(pSdbContext,
                                 pSdbContext->pdbMain,
                                 tSection,
                                 &Context,
                                 atiExes,
                                 &guidExeID,
                                 &dwExeFlags,
                                 &MatchMode);
        if (dwNumExes) {
            pdb = pSdbContext->pdbMain;

            if (!bMatchComplete) {

                if (!SdbpAddMatch(pQueryResult,
                                  pSdbContext,
                                  pdb,
                                  atiExes,
                                  dwNumExes,
                                  NULL,
                                  0,      // no layers
                                  &guidExeID,
                                  dwExeFlags,
                                  &MatchMode)) { // also match mode!!!
                    goto out;
                }
            }

            DBGPRINT((sdlInfo, "SdbGetMatchingExe", "Using Sysmain.sdb\n"));
            goto out;
        }

out:
        //
        // We are done matching. Before we return, we need to capture all the
        // custom sdb entries that we used while producing the result of this query.
        //
        SdbpCaptureCustomSDBInformation(pQueryResult, pSdbContext);

    } __except (SHIM_EXCEPT_HANDLER) {
        RtlZeroMemory(pQueryResult, sizeof(SDBQUERYRESULT));
    }

    if (dwLayers >= SDB_MAX_LAYERS) {
        DBGPRINT((sdlWarning,
                  "SdbGetMatchingExe",
                  "Hit max layer limit at %d. Perhaps we need to bump it.\n",
                  dwLayers));
    }

    //
    // Free search context stuff
    //
    SdbpReleaseSearchDBContext(&Context);

    if (bReleaseDatabase) {
        SdbReleaseDatabase(hSDB);
    }

    return (pQueryResult->atrExes[0] != TAGREF_NULL ||
            pQueryResult->atrLayers[0] != TAGREF_NULL);
}


void
SdbReleaseMatchingExe(
    IN  HSDB   hSDB,
    IN  TAGREF trExe
    )
/*++
    Return: void.

    Desc:   Releases globally allocated data and closes a local database, if it exists.
            The TAGREF of the exe is passed in purely for possible future use.
--*/
{
    SdbpCleanupLocalDatabaseSupport(hSDB);
}


int __cdecl
ShimDbgPrint(
    int iLevelAndFlags,
    PCH pszFunctionName,
    PCH Format,
    ...
    )
{
    int     nch       = 0;

#ifdef _DEBUG_SPEW

    CHAR    Buffer[2048];
    INT     i;
    PCH     pchLevel  = NULL;
    PCH     pchBuffer = Buffer;
    PCH     pszFormat = NULL;
    PCH     pszMessage= Buffer;
    INT     cch       = CHARCOUNT(Buffer);
    va_list arglist;
    HANDLE  hPipe = INVALID_HANDLE_VALUE;
    int     iLevel = FILTER_DBG_LEVEL(iLevelAndFlags);
    HSDB    hSDB = NULL;
    BOOL    bPipe;
    
    //
    // Check to see whether the debug output is initialized
    //
    if (g_iShimDebugLevel == SHIM_DEBUG_UNINITIALIZED) {
        g_iShimDebugLevel = GetShimDbgLevel();
    }

    //
    // Check to see whether we need to print anything.
    // The criteria is such that we won't print a thing if iLevel does not fit, 
    // but we will use the pipe when it is provided.
    //
    bPipe = !!(iLevelAndFlags & sdlLogPipe);

    if (!bPipe && iLevel > g_iShimDebugLevel) {
        return 0;
    }

    PREPARE_FORMAT(pszFormat, Format);

    if (pszFormat == NULL) {

        //
        // Can't convert format for debug output
        //
        return 0;
    }

    va_start(arglist, Format);

    //
    // Now on to the contents
    //
    if (bPipe) {
        //
        // The first arg then is hSDB
        //
        hSDB = va_arg(arglist, HSDB);

        //
        // For pipe out we prepend output with [pid:0x%.8lx] 
        //
        nch = sprintf(pchBuffer, "[pid: 0x%.8lx]", GetCurrentProcessId());
        pchBuffer += nch;
        pszMessage = pchBuffer;
        cch -= nch;
    }

    //
    // Do we have a comment for this debug level? if so, print it
    //
    for (i = 0; i < DEBUG_LEVELS; ++i) {
        if (g_rgDbgLevelInfo[i].iLevel == iLevel) {
            pchLevel = (PCH)g_rgDbgLevelInfo[i].szStrTag;
            break;
        }
    }

    if (pchLevel == NULL) {
        pchLevel = g_szDbgLevelUser;
    }

    nch = sprintf(pchBuffer, "[%-4hs]", pchLevel);
    pchBuffer += nch;
    cch -= nch;

    if (pszFunctionName) {

        //
        // Single-byte char going into UNICODE buffer
        //
        nch = sprintf(pchBuffer, "[%-20hs] ", pszFunctionName);
        pchBuffer += nch;
        cch -= nch;
    }

    //
    // _vsntprintf this will not work for UNICODE Win2000
    //
    nch = _vsnprintf(pchBuffer, cch, pszFormat, arglist); // resolves either to ansi or UNICODE
    pchBuffer += nch;
    va_end(arglist);

    if (nch < 0) { // can't fit into the buffer
        return 0;
    }

#ifndef WIN32A_MODE

    if (bPipe)  {
        SdbpWriteDebugPipe(hSDB, Buffer);
    }

    nch = DbgPrint("%s", pszMessage);

    STACK_FREE(pszFormat);

#else // WIN32A_MODE

    OutputDebugString(pszMessage);

    nch = (int)(pchBuffer - pszMessage);

#endif // WIN32A_MODE

#endif // _DEBUG_SPEW

    return nch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\ntver.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        sdbapi.c

    Abstract:

        ANTI-BUGBUG: This module implements ...
        NT-only version information retrieval

    Author:

        VadimB    created     sometime toward the end of November 2000

    Revision History:

        several people contributed (vadimb, clupu, ...)

--*/

#include "sdbp.h"

BOOL
SdbpGetFileVersionInformation(
    IN  PIMAGEFILEDATA     pImageData,        // we assume that the file has been mapped
                                              // in for other purposes
    OUT LPVOID*            ppVersionInfo,     // receives pointer to the (allocated) version
                                              // resource
    OUT VS_FIXEDFILEINFO** ppFixedVersionInfo // receives pointer to fixed version info
    );


BOOL
SdbpVerQueryValue(
    const LPVOID    pb,
    LPVOID          lpSubBlockX,    // can be only unicode
    LPVOID*         lplpBuffer,
    PUINT           puLen
    );


#if defined(KERNEL_MODE) && defined(ALLOC_DATA_PRAGMA)
#pragma  data_seg()
#endif // KERNEL_MODE && ALLOC_DATA_PRAGMA


#if defined(KERNEL_MODE) && defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, SdbpGetFileVersionInformation)
#pragma alloc_text(PAGE, SdbpVerQueryValue)
#endif // KERNEL_MODE && ALLOC_PRAGMA

typedef struct _RESOURCE_DATAW {
    USHORT TotalSize;
    USHORT DataSize;
    USHORT Type;
    WCHAR  szName[16];                     // L"VS_VERSION_INFO" + unicode nul
    VS_FIXEDFILEINFO FixedFileInfo;
} VERSIONINFOW, *PVERSIONINFOW;


BOOL
SdbpGetFileVersionInformation(
    IN  PIMAGEFILEDATA     pImageData,        // we assume that the file has been mapped
                                              // in for other purposes
    OUT LPVOID*            ppVersionInfo,     // receives pointer to the (allocated) version
                                              // resource
    OUT VS_FIXEDFILEINFO** ppFixedVersionInfo // receives pointer to fixed version info
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    NTSTATUS      Status;
    ULONG_PTR     ulPath[3];
    ULONG         ulSize; // size of the resource
    LPVOID        pImageBase;
    PVERSIONINFOW pVersionInfo = NULL;
    ULONG         ulVersionSize = 0;
    LPVOID        pVersionBuffer;
    DWORD         dwModuleType = MT_UNKNOWN_MODULE;
    
    PIMAGE_RESOURCE_DATA_ENTRY pImageResourceData;

    //
    // Check module type first. We only recognize win32 modules.
    //
    if (!SdbpGetModuleType(&dwModuleType, pImageData) || dwModuleType != MT_W32_MODULE) {
        DBGPRINT((sdlError,
                  "SdbpGetFileVersionInformation",
                  "Bad module type 0x%x\n",
                  dwModuleType));
        return FALSE;
    }

    pImageBase = (LPVOID)pImageData->pBase;

    //
    // Setup the path to the resource
    //
    ulPath[0] = PtrToUlong(RT_VERSION);
    ulPath[1] = PtrToUlong(MAKEINTRESOURCE(VS_VERSION_INFO));
    ulPath[2] = 0;

    //
    // See if the resource has come through.
    //
    __try {

        Status = LdrFindResource_U(pImageBase, ulPath, 3, &pImageResourceData);
        
        if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlError,
                      "SdbpGetFileVersionInformation",
                      "LdrFindResource_U failed status 0x%x\n",
                      Status));
            return FALSE;
        }

        Status = LdrAccessResource(pImageBase, pImageResourceData, &pVersionInfo, &ulVersionSize);
        
        if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlError,
                      "SdbpGetFileVersionInformation",
                      "LdrAccessResource failed Status 0x%x\n",
                      Status));
            return FALSE;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        DBGPRINT((sdlError,
                  "SdbpGetFileVersionInformation",
                  "Exception while trying to retrieve version-related information\n"));
        
        Status = STATUS_UNSUCCESSFUL;
    }

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    //
    // Check to make sure that what we have got is good.
    //
    if (sizeof(*pVersionInfo) > ulVersionSize ||
        _wcsicmp(pVersionInfo->szName, L"VS_VERSION_INFO") != 0) {
        
        DBGPRINT((sdlError,
                  "SdbpGetFileVersionInformation",
                  "Bad version resource\n"));
        return FALSE;
    }

    //
    // Now we have a pointer to the resource data. Allocate version information.
    //
    pVersionBuffer = (LPVOID)SdbAlloc(ulVersionSize);
    
    if (pVersionBuffer == NULL) {
        DBGPRINT((sdlError,
                  "SdbpGetFileVersionInformation",
                  "Failed to allocate %d bytes for version information\n",
                  ulVersionSize));
        return FALSE;
    }

    //
    // Copy all the version-related information
    //
    RtlMoveMemory(pVersionBuffer, pVersionInfo, ulVersionSize);

    if (ppFixedVersionInfo != NULL) {
        *ppFixedVersionInfo = &(((PVERSIONINFOW)pVersionBuffer)->FixedFileInfo);
    }

    assert(ppVersionInfo != NULL);

    *ppVersionInfo = pVersionBuffer;

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
// This code was taken from Cornel's win2k tree
//


#define DWORDUP(x) (((x) + 3) & ~3)

typedef struct tagVERBLOCK {
    WORD  wTotLen;
    WORD  wValLen;
    WORD  wType;
    WCHAR szKey[1];
} VERBLOCK ;

typedef struct tagVERHEAD {
    WORD  wTotLen;
    WORD  wValLen;
    WORD  wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO") + 3) & ~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;


BOOL
SdbpVerQueryValue(
    const LPVOID    pb,
    LPVOID          lpSubBlockX,    // can be only unicode
    LPVOID*         lplpBuffer,
    PUINT           puLen
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    ANSI_STRING     AnsiString;
    UNICODE_STRING  UnicodeString;
    LPWSTR          lpSubBlockOrg;
    LPWSTR          lpSubBlock;
    NTSTATUS        Status;
    VERBLOCK*       pBlock = (PVOID)pb;
    LPWSTR          lpStart, lpEndBlock, lpEndSubBlock;
    WCHAR           cTemp, cEndBlock;
    DWORD           dwHeadLen, dwTotBlockLen;
    BOOL            bLastSpec;
    int             nCmp;
    BOOL            bString;
    int             nIndex = -1;

    *puLen = 0;

    //
    // wType is 0 for win32 versions, but holds 56 ('V') for win16.
    //
    if (((VERHEAD*)pb)->wType) {
        return 0;
    }

    //
    // If doesn't need unicode, then we must thunk the input parameter
    // to unicode.
    //

    STACK_ALLOC(lpSubBlockOrg, (wcslen(lpSubBlockX) + 1) * sizeof(WCHAR));
    
    if (lpSubBlockOrg == NULL) {
        DBGPRINT((sdlError,
                  "SdbpVerQueryValue",
                  "Failed to allocate %d bytes\n",
                  (wcslen(lpSubBlockX) + 1) * sizeof(WCHAR)));
        return FALSE;
    }

    wcscpy(lpSubBlockOrg, lpSubBlockX);

    lpSubBlock = lpSubBlockOrg;

    //
    // Ensure that the total length is less than 32K but greater than the
    // size of a block header; we will assume that the size of pBlock is at
    // least the value of this first int.
    // Put a '\0' at the end of the block so that none of the wcslen's will
    // go past then end of the block.  We will replace it before returning.
    //
    if ((int)pBlock->wTotLen < sizeof(VERBLOCK)) {
        goto Fail;
    }

    lpEndBlock  = (LPWSTR)((LPSTR)pBlock + pBlock->wTotLen - sizeof(WCHAR));
    cEndBlock   = *lpEndBlock;
    *lpEndBlock = 0;
    bString     = FALSE;
    bLastSpec   = FALSE;

    while ((*lpSubBlock || nIndex != -1)) {
        //
        // Ignore leading '\\'s
        //
        while (*lpSubBlock == TEXT('\\')) {
            ++lpSubBlock;
        }

        if ((*lpSubBlock || nIndex != -1)) {
            //
            // Make sure we still have some of the block left to play with.
            //
            dwTotBlockLen = (DWORD)((LPSTR)lpEndBlock - (LPSTR)pBlock + sizeof(WCHAR));
            
            if ((int)dwTotBlockLen < sizeof(VERBLOCK) || pBlock->wTotLen > (WORD)dwTotBlockLen) {
                goto NotFound;
            }

            //
            // Calculate the length of the "header" (the two length WORDs plus
            // the data type flag plus the identifying string) and skip
            // past the value.
            //
            dwHeadLen = (DWORD)(DWORDUP(sizeof(VERBLOCK) - sizeof(WCHAR) +
                                (wcslen(pBlock->szKey) + 1) * sizeof(WCHAR)) +
                                DWORDUP(pBlock->wValLen));
            
            if (dwHeadLen > pBlock->wTotLen) {
                goto NotFound;
            }
            
            lpEndSubBlock = (LPWSTR)((LPSTR)pBlock + pBlock->wTotLen);
            pBlock = (VERBLOCK*)((LPSTR)pBlock+dwHeadLen);

            //
            // Look for the first sub-block name and terminate it
            //
            for (lpStart = lpSubBlock;
                 *lpSubBlock && *lpSubBlock != TEXT('\\');
                 lpSubBlock++) {
                
                /* find next '\\' */ ;
            }
            
            cTemp = *lpSubBlock;
            *lpSubBlock = 0;

            //
            // Continue while there are sub-blocks left
            // pBlock->wTotLen should always be a valid pointer here because
            // we have validated dwHeadLen above, and we validated the previous
            // value of pBlock->wTotLen before using it
            //
            nCmp = 1;
            
            while ((int)pBlock->wTotLen > sizeof(VERBLOCK) &&
                   (int)pBlock->wTotLen <= (LPSTR)lpEndSubBlock-(LPSTR)pBlock) {

                //
                // Index functionality: if we are at the end of the path
                // (cTemp == 0 set below) and nIndex is NOT -1 (index search)
                // then break on nIndex zero.  Else do normal wscicmp.
                //
                if (bLastSpec && nIndex != -1) {

                    if (!nIndex) {

                        nCmp=0;

                        //
                        // Index found, set nInde to -1
                        // so that we exit this loop
                        //
                        nIndex = -1;
                        break;
                    }

                    nIndex--;

                } else {

                    //
                    // Check if the sub-block name is what we are looking for
                    //

                    if (!(nCmp = _wcsicmp(lpStart, pBlock->szKey))) {
                        break;
                    }
                }

                //
                // Skip to the next sub-block
                //
                pBlock=(VERBLOCK*)((LPSTR)pBlock+DWORDUP(pBlock->wTotLen));
            }

            //
            // Restore the char NULLed above and return failure if the sub-block
            // was not found
            //
            *lpSubBlock = cTemp;
            
            if (nCmp) {
                goto NotFound;
            }
        }
        
        bLastSpec = !cTemp;
    }

    //
    // Fill in the appropriate buffers and return success
    ///

    *puLen = pBlock->wValLen;

    //
    // Add code to handle the case of a null value.
    //
    // If zero-len, then return the pointer to the null terminator
    // of the key.  Remember that this is thunked in the ansi case.
    //
    // We can't just look at pBlock->wValLen.  Check if it really is
    // zero-len by seeing if the end of the key string is the end of the
    // block (i.e., the val string is outside of the current block).
    //

    lpStart = (LPWSTR)((LPSTR)pBlock + DWORDUP((sizeof(VERBLOCK) - sizeof(WCHAR)) +
                                               (wcslen(pBlock->szKey)+1)*sizeof(WCHAR)));

    *lplpBuffer = lpStart < (LPWSTR)((LPBYTE)pBlock + pBlock->wTotLen) ?
                  lpStart :
                  (LPWSTR)(pBlock->szKey + wcslen(pBlock->szKey));

    bString = pBlock->wType;

    *lpEndBlock = cEndBlock;

    //
    // Must free string we allocated above.
    //

    STACK_FREE(lpSubBlockOrg);

    return TRUE;


NotFound:
    //
    // Restore the char we NULLed above
    //
    *lpEndBlock = cEndBlock;

    Fail:

    STACK_FREE(lpSubBlockOrg);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\sdbapi.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        sdbapi.c

    Abstract:

        BUGBUG: This module implements ...

    Author:

        dmunsil     created     sometime in 1999

    Revision History:

        several people contributed (vadimb, clupu, ...)

--*/

#include "sdbp.h"
#include "initguid.h"

DEFINE_GUID(GUID_SYSMAIN_SDB, 0x11111111, 0x1111, 0x1111, 0x11, 0x11, 0x11, 0x11, \
            0x11, 0x11, 0x11, 0x11);
DEFINE_GUID(GUID_APPHELP_SDB, 0x22222222, 0x2222, 0x2222, 0x22, 0x22, 0x22, 0x22, \
            0x22, 0x22, 0x22, 0x22);
DEFINE_GUID(GUID_SYSTEST_SDB, 0x33333333, 0x3333, 0x3333, 0x33, 0x33, 0x33, 0x33, \
            0x33, 0x33, 0x33, 0x33);
DEFINE_GUID(GUID_DRVMAIN_SDB, 0xF9AB2228, 0x3312, 0x4A73, 0xB6, 0xF9, 0x93, 0x6D, \
            0x70, 0xE1, 0x12, 0xEF);
DEFINE_GUID(GUID_MSIMAIN_SDB, 0xD8FF6D16, 0x6A3A, 0x468A, 0x8B, 0x44, 0x01, 0x71, \
            0x4D, 0xDC, 0x49, 0xEA);
DEFINE_GUID(GUID_APPHELP_SP_SDB, 0x44444444, 0x4444, 0x4444, 0x44, 0x44, 0x44, 0x44, \
            0x44, 0x44, 0x44, 0x44);

#ifdef _DEBUG_SPEW

//
// Shim Debug output support
//
int g_iShimDebugLevel = SHIM_DEBUG_UNINITIALIZED;

DBGLEVELINFO g_rgDbgLevelInfo[DEBUG_LEVELS] = {
    { "Err",   sdlError    },
    { "Warn",  sdlWarning  },
    { "Fail",  sdlFail     },
    { "Info",  sdlInfo     }
};

PCH g_szDbgLevelUser = "User";

#endif // _DEBUG_SPEW



BOOL
SdbpInitializeSearchDBContext(
    PSEARCHDBCONTEXT pContext
    );


#if defined(KERNEL_MODE) && defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, ShimExceptionHandler)
#pragma alloc_text(PAGE, SdbpCreateSearchDBContext)
#pragma alloc_text(PAGE, SdbpInitializeSearchDBContext)
#pragma alloc_text(PAGE, SdbpReleaseSearchDBContext)
#pragma alloc_text(PAGE, SdbpCheckForMatch)
#pragma alloc_text(PAGE, SdbpSearchDB)
#pragma alloc_text(PAGE, SdbpCreateSearchDBContext)
#pragma alloc_text(PAGE, SdbGetDatabaseMatch)
#pragma alloc_text(PAGE, SdbQueryData)
#pragma alloc_text(PAGE, SdbQueryDataEx)
#pragma alloc_text(PAGE, SdbReadEntryInformation)
#pragma alloc_text(PAGE, PrepareFormatForUnicode)
#pragma alloc_text(PAGE, ShimDbgPrint)
#endif

#if DBG
const BOOL g_bDBG = TRUE;
#else
const BOOL g_bDBG = FALSE;
#endif

//
// Exception handler
//

ULONG
ShimExceptionHandler(
    PEXCEPTION_POINTERS pexi,
    char*               szFile,
    DWORD               dwLine
    )
{
#ifndef KERNEL_MODE // in kmode exceptions won't work anyway

    DBGPRINT((sdlError,
              "ShimExceptionHandler",
              "Shim Exception %#x in module \"%hs\", line %d, at address %#p. flags:%#x. !exr %#p !cxr %#p",
              pexi->ExceptionRecord->ExceptionCode,
              szFile,
              dwLine,
              CONTEXT_TO_PROGRAM_COUNTER(pexi->ContextRecord),
              pexi->ExceptionRecord->ExceptionFlags,
              pexi->ExceptionRecord,
              pexi->ContextRecord));

    //
    // Special-case stack overflow exception which is likely to occur due to
    // low memory conditions during stress. The process is dead anyway so we
    // will not handle this exception.
    //
    if (pexi->ExceptionRecord->ExceptionCode == EXCEPTION_STACK_OVERFLOW) {
        return EXCEPTION_CONTINUE_SEARCH;
    }

#if DBG
    SDB_BREAK_POINT();
#endif // DBG

#endif // KERNEL_MODE

    return EXCEPTION_EXECUTE_HANDLER;
}

BOOL
SdbpResolveAndSplitPath(
    IN  DWORD   dwFlags,        // context flags (SEARCHDBF_NO_LFN in particular)
    IN  LPCTSTR szFullPath,     // a full UNC or DOS path & filename, "c:\foo\myfile.ext"
    OUT LPTSTR  szDir,          // the drive and dir portion of the filename "c:\foo\"
    OUT LPTSTR  szName,         // the filename portion "myfile"
    OUT LPTSTR  szExt           // the extension portion ".ext"
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   This function takes a full path and splits it into pieces ala splitpath,
            but also converts short file names to long names.
            NOTE: The caller is responsible for allocating enough space
                  for the passed-in strings to take any portion of the path.
                  For safety, allocate at least MAX_PATH WCHARS for each piece.
--*/
{
    TCHAR* szCursor;
    TCHAR  szLongFileName[MAX_PATH + 1];
    BOOL   bFound;
    DWORD  i;

    assert(szFullPath && szDir && szName && szExt);

    //
    // Parse the directory.
    //
    szDir[0] = _T('\0');

    szCursor = _tcsrchr(szFullPath, _T('\\')); // last backslash please
    if (szCursor == NULL) {
        szCursor = (LPTSTR)szFullPath;
    } else {
        _tcsncpy(szDir, szFullPath, szCursor - szFullPath + 1);
        szDir[szCursor - szFullPath + 1] = _T('\0');
    }

#ifndef KERNEL_MODE

    //
    // Make sure we're using the long filename
    //
    if (dwFlags & SEARCHDBF_NO_LFN) {
        assert(_tcslen(szCursor) < CHARCOUNT(szLongFileName));
        _tcscpy(szLongFileName, szCursor);
    } else {
        if (!SdbpGetLongFileName(szFullPath, szLongFileName)) {
            return FALSE;
        }
    }

#else // KERNEL_MODE

    //
    // When we are in kernel mode, our file name is always considered to be "long".
    // At this point szCursor points to the last '\\' or to the beginning of the name.
    //
    if (*szCursor == _T('\\')) {
        ++szCursor;
    }

    //
    // Make sure that we have enough room for the name.
    //
    assert(wcslen(szCursor) < CHARCOUNT(szLongFileName));
    wcscpy(szLongFileName, szCursor);

#endif // KERNEL_MODE

    //
    // Parse name & extension
    //
    szExt[0]  = _T('\0');
    szName[0] = _T('\0');

    //
    // Within the long file name find the last dot
    //
    szCursor = _tcsrchr(szLongFileName, _T('.'));
    
    if (szCursor != NULL) {
        _tcsncpy(szName, szLongFileName, szCursor - szLongFileName);
        szName [szCursor-szLongFileName] = _T('\0');
        _tcscpy(szExt, szCursor);
    } else {
        _tcscpy(szName, szLongFileName);
    }

    return TRUE;
}


BOOL
SdbpCreateSearchDBContext(
    PSEARCHDBCONTEXT pContext,
    LPCTSTR          szPath,
    LPCTSTR          szModuleName,
    LPCTSTR          pEnvironment
    )
/*++
    Return: TRUE - search db context was successfully created

    Desc:   This function creates context for searching the database, in particular, the
            context is initalized with the path of probable local database location,
            executable path is broken down into containing directory and the filename part.
--*/
{
    DWORD  dwPathLen;
    BOOL   bReturn     = FALSE;
    TCHAR* szDirectory = NULL;
    TCHAR* szExt       = NULL;
    TCHAR* szFullName  = NULL;
    TCHAR* szFileName  = NULL;
    TCHAR* szModule    = NULL;
    
    assert(NULL != szPath);
    assert(NULL != pContext);

    dwPathLen = _tcslen(szPath);

    //
    // Allocate enough to guarantee our strings will not overflow
    //
    szDirectory = SdbAlloc((dwPathLen + 1) * sizeof(TCHAR));
    szFullName  = SdbAlloc((_MAX_PATH + 1) * sizeof(TCHAR));

    if (szModuleName) {
        szModule = SdbAlloc((_tcslen(szModuleName) + 1) * sizeof(TCHAR));
        if (!szModule) {
            DBGPRINT((sdlError,
                      "SdbpCreateSearchDBContext",
                      "Unable to allocate memory for szModule.\n"));
            goto out;
        }
        _tcscpy(szModule, szModuleName);
    }

    STACK_ALLOC(szExt,      (_MAX_PATH + 1) * sizeof(TCHAR));
    STACK_ALLOC(szFileName, (_MAX_PATH + 1) * sizeof(TCHAR));

    if (!szDirectory || !szExt || !szFullName || !szFileName || !pContext) {
        DBGPRINT((sdlError,
                  "SdbpCreateSearchDBContext",
                  "Unable to allocate memory for strings.\n"));
        goto out;
    }

    if (!SdbpResolveAndSplitPath(pContext->dwFlags, szPath, szDirectory, szFileName, szExt)) {
        DBGPRINT((sdlError,
                  "SdbpCreateSearchDBContext",
                  "Unable to parse executable path for \"%s\".\n",
                  szPath));
        goto out;
    }

    _tcscpy(szFullName, szFileName);
    _tcscat(szFullName, szExt);

    pContext->pEnvironment = pEnvironment;
    pContext->szDir        = szDirectory;
    pContext->szName       = szFullName; // fullname (filename + ext)
    pContext->szModuleName = szModule;

    //
    // We do not retain szExt (don't need it)
    //
    // Calculate this later -- implied by RtlZeroMemory statement above
    //
    pContext->pSearchParts     = NULL;
    pContext->szProcessHistory = NULL;

    bReturn = TRUE;

out:
    if (szExt != NULL) {
        STACK_FREE(szExt);
    }

    if (szFileName != NULL) {
        STACK_FREE(szFileName);
    }

    if (!bReturn) {

        if (szDirectory != NULL) {
            SdbFree(szDirectory);
        }
        if (szFullName != NULL) {
            SdbFree(szFullName);
        }

        if (szModule != NULL) {
            SdbFree(szModule);
        }
    }

    return bReturn;
}


BOOL
SdbpInitializeSearchDBContext(
    PSEARCHDBCONTEXT pContext
    )
/*++
    Return: TRUE - the context was successfully initialized with the process history
                   which was broken down into the separate search paths

    Desc:   This function prepares search context for use, obtaining and parsing process
            history into separate paths. The array of these search paths is used then
            by the caller to inquire about matching files that might be present in one
            of the these places.
            In Kernel mode use SEARCHDBF_NO_PROCESS_HISTORY flag within context
            it will include only the current exe path into the process history
--*/
{
    BOOL   bSuccess = TRUE;
    LPTSTR pszProcessHistory = NULL;

    if (pContext->pSearchParts != NULL) {
        return TRUE;
    }

    if (pContext->dwFlags & SEARCHDBF_NO_PROCESS_HISTORY) {

        pszProcessHistory = pContext->szProcessHistory;
        
        if (pszProcessHistory == NULL) {
            
            DWORD DirLen  = _tcslen(pContext->szDir);
            DWORD NameLen = _tcslen(pContext->szName);

            //
            // We create a temporary process history
            //
            pContext->szProcessHistory = SdbAlloc((DirLen + NameLen + 1) * sizeof(TCHAR));
            
            if (pContext->szProcessHistory == NULL) {
                DBGPRINT((sdlError,
                          "SdbpInitializeSearchDBContext",
                          "Failed to allocate buffer %d bytes\n",
                          (DirLen + NameLen + 1) * sizeof(TCHAR)));
                return FALSE;
            }

            pszProcessHistory = pContext->szProcessHistory;

            RtlMoveMemory(pszProcessHistory, pContext->szDir, DirLen * sizeof(TCHAR));
            RtlMoveMemory(pszProcessHistory + DirLen, pContext->szName, NameLen * sizeof(TCHAR));

            *(pszProcessHistory + DirLen + NameLen) = TEXT('\0');
        }

        //
        // When we are here -- we either have a process history or we just
        // created it consisting of a single search item
        //

    } else {

#ifndef KERNEL_MODE
        if (pContext->szProcessHistory == NULL) {

            pContext->szProcessHistory = GetProcessHistory(pContext->pEnvironment,
                                                           pContext->szDir,
                                                           pContext->szName);
            if (pContext->szProcessHistory == NULL) {
                DBGPRINT((sdlError,
                          "SdbpInitializeSearchDBContext",
                          "Failed to retrieve process history\n"));
                return FALSE;
            }
        }

        pszProcessHistory = pContext->szProcessHistory;
#else
        //
        // This is the case with KERNEL_MODE. YOU HAVE TO SET SEARCHDBF_NO_PROCESS_HISTORY
        //
        assert(FALSE);
        pszProcessHistory = NULL;
#endif
    }

    //
    // At this point pszProcessHistory is NOT NULL
    //
    assert(pszProcessHistory != NULL);

    DBGPRINT((sdlInfo,
              "SdbpInitializeSearchDBContext",
              "Using Process History: \"%s\"\n",
              pszProcessHistory));

    bSuccess = SdbpCreateSearchPathPartsFromPath(pszProcessHistory, &pContext->pSearchParts);

    if (bSuccess) {
        pContext->dwFlags |= SEARCHDBF_INITIALIZED;
    }

    return bSuccess;
}

void
SdbpReleaseSearchDBContext(
    PSEARCHDBCONTEXT pContext
    )
/*++
    Return: void

    Desc:   Resets search DB context, frees memory allocated for each of the
            temporary buffers.
--*/
{
    if (pContext == NULL) {
        return;
    }
    
    if (pContext->szProcessHistory != NULL) {
        SdbFree(pContext->szProcessHistory);
        pContext->szProcessHistory = NULL;
    }

    if (pContext->pSearchParts != NULL) {
        SdbFree(pContext->pSearchParts);
        pContext->pSearchParts = NULL;
    }

    if (pContext->szDir != NULL) {
        SdbFree(pContext->szDir);
        pContext->szDir = NULL;
    }

    if (pContext->szName != NULL) {
        SdbFree(pContext->szName);
        pContext->szName = NULL;
    }

    if (pContext->szModuleName != NULL) {
        SdbFree(pContext->szModuleName);
        pContext->szModuleName = NULL;
    }
}

BOOL
SdbpIsExeEntryEnabled(
    IN  PDB    pdb,
    IN  TAGID  tiExe,
    OUT GUID*  pGUID,
    OUT DWORD* pdwFlags
    )
{
    TAGID tiExeID;
    DWORD i;
    BOOL  fSuccess = FALSE;

    //
    // Get the EXE's GUID
    //
    tiExeID = SdbFindFirstTag(pdb, tiExe, TAG_EXE_ID);

    if (tiExeID == TAGID_NULL) {
        DBGPRINT((sdlError,
                  "SdbpIsExeEntryEnabled",
                  "Failed to read TAG_EXE_ID for tiExe 0x%x !\n",
                  tiExe));
        goto error;
    }

    if (!SdbReadBinaryTag(pdb, tiExeID, (PBYTE)pGUID, sizeof(GUID))) {
        DBGPRINT((sdlError,
                  "SdbpIsExeEntryEnabled",
                  "Failed to read the GUID for tiExe 0x%x !\n",
                  tiExe));
        goto error;
    }

    if (!SdbGetEntryFlags(pGUID, pdwFlags)) {
        DBGPRINT((sdlWarning,
                  "SdbpIsExeEntryEnabled",
                  "No flags for tiExe 0x%lx\n",
                  tiExe));

        *pdwFlags = 0;
    } else {
        DBGPRINT((sdlInfo,
                  "SdbpIsExeEntryEnabled",
                  "Retrieved flags for this app 0x%x.\n",
                  *pdwFlags));
    }

    if (!(*pdwFlags & SHIMREG_DISABLE_SHIM)) {
        fSuccess = TRUE;
    }

error:

    return fSuccess;
}

#define EXTRA_BUF_SPACE (16 * sizeof(TCHAR))

//
// Matching an entry:
//
// 1. We check whether each file exists by calling SdbGetFileInfo
// 2. Each file's info is stored in FILEINFOCHAINITEM (allocated on the stack) - such as pointer
//    to the actual FILEINFO structure (stored in file attribute cache) and tiMatch denoting
//    the entry in the database for a given MATCHING_FILE
// 3. After we have verified that all the matching files do exist -- we proceed to walk the
//    chain of FILEINFOCHAINITEM structures and call SdbCheckAllAttributes to check on all the
//    other attributes of the file
// 4. Cleanup: File attribute cache is destroyed when the database is closed via call to
//    SdbCleanupAttributeMgr
// 5. No cleanup is needed for FILEINFOCHAINITEM structures (they are allocated on the stack and
//    just "go away")
//
//

typedef struct tagFILEINFOCHAINITEM {
    PVOID pFileInfo;                        // pointer to the actual FILEINFO
                                            // structure (from attribute cache)
    TAGID tiMatch;                          // matching entry in the database
    
    struct tagFILEINFOCHAINITEM* pNextItem; // pointer to the next matching file

} FILEINFOCHAINITEM, *PFILEINFOCHAINITEM;


BOOL
SdbpCheckForMatch(
    IN  HSDB                hSDB,        // context ptr
    IN  PDB                 pdb,         // pdb to get match criteria from
    IN  TAGID               tiExe,       // TAGID of exe record to get match criteria from
    IN  PSEARCHDBCONTEXT    pContext,    // search db context (includes name/path)
    OUT PMATCHMODE          pMatchMode,   // the match mode of this EXE
    OUT GUID*               pGUID,
    OUT DWORD*              pdwFlags
    )
/*++
    Return: TRUE if match is good, FALSE if this EXE doesn't match.

    Desc:   Given an EXE tag and a name and dir, checks  the DB for MATCHING_FILE
            tags, and checks all the matching info available for each the
            files listed. If all the files check out, returns TRUE. If any of
            the files don't exist, or don't match on one of the given
            criteria, returns FALSE.
--*/
{
    BOOL                bReturn = FALSE;
    BOOL                bMatchLogicNot = FALSE;
    BOOL                bAllAttributesMatch = FALSE;
    TAGID               tiMatch;
    TCHAR*              szTemp = NULL;
    LONG                nFullPathBufSize = 0;
    LONG                nFullPathReqBufSize = 0;
    LPTSTR              szFullPath = NULL;
    LONG                i;
    LONG                NameLen = _tcslen(pContext->szName);
    LONG                MatchFileLen;
    PSEARCHPATHPARTS    pSearchPath;
    PSEARCHPATHPART     pSearchPathPart;
    NTSTATUS            Status;
    PFILEINFOCHAINITEM  pFileInfoItem          = NULL;
    PFILEINFOCHAINITEM  pFileInfoItemList      = NULL;  // holds the list of matching files
                                                        // which were found
    PFILEINFOCHAINITEM  pFileInfoItemNext;              // holds the next item in the list
    PVOID               pFileInfo              = NULL;  // points to the current file's
                                                        // information structure
    BOOL                bDisableAttributeCache = FALSE; // will be set according to search

    TAGID               tiName, tiTemp, tiMatchLogicNot;
    TCHAR*              szMatchFile = NULL;
    HANDLE              hFileHandle; // handle for the file we're checking, optimization
    LPVOID              pImageBase;  // pointer to the image
    DWORD               dwImageSize = 0;
    WORD                wDefaultMatchMode;
    
    //
    // Check context's flags
    //
    if (pContext->dwFlags & SEARCHDBF_NO_ATTRIBUTE_CACHE) {
        bDisableAttributeCache = TRUE;
    }

    //
    // Loop through matching criteria.
    //
    tiMatch = SdbFindFirstTag(pdb, tiExe, TAG_MATCHING_FILE);

    while (tiMatch != TAGID_NULL) {

        tiMatchLogicNot = SdbFindFirstTag(pdb, tiMatch, TAG_MATCH_LOGIC_NOT);
        bMatchLogicNot = (tiMatchLogicNot != TAGID_NULL);

        tiName = SdbFindFirstTag(pdb, tiMatch, TAG_NAME);

        if (!tiName) {
            goto out;
        }

        szTemp = SdbGetStringTagPtr(pdb, tiName);

        if (szTemp == NULL) {
            DBGPRINT((sdlError,
                      "SdbpCheckForMatch",
                      "Failed to get the string from the database.\n"));
            goto out;
        }

        if (szTemp[0] == TEXT('*')) {
            //
            // This is a signal that we should use the exe name.
            //
            szMatchFile  = pContext->szName;
            MatchFileLen = NameLen;
            hFileHandle  = pContext->hMainFile;
            pImageBase   = pContext->pImageBase;
            dwImageSize  = pContext->dwImageSize;

        } else {

            szMatchFile  =  szTemp;
            MatchFileLen = _tcslen(szMatchFile);
            hFileHandle  = INVALID_HANDLE_VALUE;
            pImageBase   = NULL;
        }

        //
        // When searching for files, we look in all process' exe directories,
        // starting with the current process and working backwards through the process
        // tree.
        //

        //
        // See that the context is good...
        //
        if (!(pContext->dwFlags & SEARCHDBF_INITIALIZED)) {

            if (!SdbpInitializeSearchDBContext(pContext)) {
                DBGPRINT((sdlError,
                          "SdbpCheckForMatch",
                          "Failed to initialize SEARCHDBCONTEXT.\n"));
                goto out;
            }
        }

        pSearchPath = pContext->pSearchParts;

        assert(pSearchPath != NULL);

        for (i = 0; i < (LONG)pSearchPath->PartCount && NULL == pFileInfo; ++i) {

            pSearchPathPart = &pSearchPath->Parts[i];

            //
            // There are two ways to specify a matching file: A relative path
            // from the EXE, or an absolute path. To specify an absolute path,
            // an environment variable (like "%systemroot%") must be used
            // as the base of the path. Therefore, we check for the first character
            // of the matching file to be % and if so, we assume that it is an
            // absolute path.
            //
#ifndef KERNEL_MODE
            if (szMatchFile[0] == TEXT('%')) {
                //
                // Absolute path. Contains environment variables, get expanded size.
                //
                nFullPathReqBufSize = SdbExpandEnvironmentStrings(szMatchFile, NULL, 0);

            } else
#endif // KERNEL_MODE
            {
                //
                // Relative path. Determine size of full path.
                //
                nFullPathReqBufSize = (pSearchPathPart->PartLength + MatchFileLen + 1) * sizeof(TCHAR);
            }

            if (nFullPathBufSize < nFullPathReqBufSize) {
                //
                // Need to realloc the buffer.
                //
                if (szFullPath == NULL) {
                    nFullPathBufSize = _MAX_PATH * sizeof(TCHAR);

                    if (nFullPathReqBufSize >= nFullPathBufSize) {
                        nFullPathBufSize = nFullPathReqBufSize + EXTRA_BUF_SPACE;
                    }
                } else {
                    STACK_FREE(szFullPath);
                    nFullPathBufSize = nFullPathReqBufSize + EXTRA_BUF_SPACE;
                }

                STACK_ALLOC(szFullPath, nFullPathBufSize);
            }

            if (szFullPath == NULL) {
                DBGPRINT((sdlError,
                          "SdbpCheckForMatch",
                          "Failed to allocate %d bytes for FullPath.\n",
                          nFullPathBufSize));
                goto out;
            }

#ifndef KERNEL_MODE
            if (szMatchFile[0] == TEXT('%')) {
                //
                // Absolute Path. Path contains environment variables, expand it.
                //
                if (!SdbExpandEnvironmentStrings(szMatchFile, szFullPath, nFullPathBufSize)) {
                    DBGPRINT((sdlError,
                              "SdbpCheckForMatch",
                              "SdbExpandEnvironmentStrings failed to expand strings for %s.\n",
                              szMatchFile));
                    goto out;
                }

            } else
#endif  // KERNEL_MODE
            {
                //
                // Relative path. Concatenate EXE directory with specified relative path.
                //
                RtlMoveMemory(szFullPath,
                              pSearchPathPart->pszPart,
                              pSearchPathPart->PartLength * sizeof(TCHAR));

                RtlMoveMemory(szFullPath + pSearchPathPart->PartLength,
                              szMatchFile,
                              (MatchFileLen + 1) * sizeof(TCHAR));
            }

            pFileInfo = SdbGetFileInfo(hSDB,
                                       szFullPath,
                                       hFileHandle,
                                       pImageBase,
                                       dwImageSize, // this will be set ONLY if pImageBase != NULL
                                       bDisableAttributeCache);

            //
            // This is not a bug, attributes are cleaned up when the database
            // context is released.
            //
        }

        if (pFileInfo == NULL && !bMatchLogicNot) {
            DBGPRINT((sdlInfo,
                      "SdbpCheckForMatch",
                      "Matching file \"%s\" not found.\n",
                      szMatchFile));
            goto out;
        }

        //
        // Create and store a new FILEINFOITEM on the stack
        //
        STACK_ALLOC(pFileInfoItem, sizeof(*pFileInfoItem));

        if (pFileInfoItem == NULL) {
            DBGPRINT((sdlError,
                      "SdbpCheckForMatch",
                      "Failed to allocate %d bytes for FILEINFOITEM\n",
                      sizeof(*pFileInfoItem)));
            goto out;
        }

        pFileInfoItem->pFileInfo = pFileInfo;
        pFileInfoItem->tiMatch   = tiMatch;
        pFileInfoItem->pNextItem = pFileInfoItemList;
        pFileInfoItemList        = pFileInfoItem;

        //
        // We have the matching file.
        // Remember where it is for the second pass when we check all the file attributes.
        //
        tiMatch = SdbFindNextTag(pdb, tiExe, tiMatch);

        //
        // Reset the file matching. we don't touch this file again for now, it's info
        // is safely linked in pFileInfoItemList
        //
        pFileInfo = NULL;
    }

    //
    // We are still here. That means all the matching files have been found.
    // Check all the other attributes using fileinfoitemlist information.
    //

    pFileInfoItem = pFileInfoItemList;

    while (pFileInfoItem != NULL) {
        
        tiMatchLogicNot = SdbFindFirstTag(pdb, pFileInfoItem->tiMatch, TAG_MATCH_LOGIC_NOT);
        bMatchLogicNot = (tiMatchLogicNot != TAGID_NULL);

        if (pFileInfoItem->pFileInfo != NULL) {
            bAllAttributesMatch = SdbpCheckAllAttributes(hSDB,
                                                         pdb,
                                                         pFileInfoItem->tiMatch,
                                                         pFileInfoItem->pFileInfo);
        } else {
            bAllAttributesMatch = FALSE;
        }

        if (bAllAttributesMatch && bMatchLogicNot) {
            DBGPRINT((sdlInfo,
                      "SdbpCheckForMatch",
                      "All attributes match, but LOGIC=\"NOT\" was used which negates the match.\n"));
            goto out;
        }

        if (!bAllAttributesMatch && !bMatchLogicNot) {
            //
            // Debug output happened inside SdbpCheckAllAttributes, no
            // need for further spew here.
            //
            goto out;
        }

        //
        // Advance to the next item.
        //
        pFileInfoItem = pFileInfoItem->pNextItem;
    }

    //
    // It's a match! get the match mode
    //
    if (pMatchMode) {

        //
        //  Important: depending on a particular database, we may use a different mode if 
        //  there is match mode tag
        //
        //  For Custom DB: default is the all-additive mode
        //  For Main   DB: default is normal mode 
        //

#ifndef KERNEL_MODE        
        wDefaultMatchMode = SdbpIsMainPDB(hSDB, pdb) ? MATCHMODE_DEFAULT_MAIN : 
                                                       MATCHMODE_DEFAULT_CUSTOM;
#else  // KERNEL_MODE
        wDefaultMatchMode = MATCHMODE_DEFAULT_MAIN;
#endif // KERNEL_MODE
        
        tiTemp = SdbFindFirstTag(pdb, tiExe, TAG_MATCH_MODE);
        
        if (tiTemp) {
            pMatchMode->dwMatchMode = SdbReadWORDTag(pdb, tiTemp, wDefaultMatchMode);
        } else {
            pMatchMode->dwMatchMode = wDefaultMatchMode;
        }
    }

    bReturn = TRUE;

out:

    pFileInfoItem = pFileInfoItemList;

    while (pFileInfoItem != NULL) {

        pFileInfoItemNext = pFileInfoItem->pNextItem;

        if (pFileInfoItem->pFileInfo != NULL && bDisableAttributeCache) {
            SdbFreeFileInfo(pFileInfoItem->pFileInfo);
        }

        STACK_FREE(pFileInfoItem);
        pFileInfoItem = pFileInfoItemNext;
    }

    if (szFullPath != NULL) {
        STACK_FREE(szFullPath);
    }

    if (bReturn) {
        //
        // One last matching criteria: verify the entry is not disabled.
        //
        bReturn = SdbpIsExeEntryEnabled(pdb, tiExe, pGUID, pdwFlags);
    }

    return bReturn;
}

typedef enum _ADDITIVE_MODE {
    AM_NORMAL,
    AM_ADDITIVE_ONLY,
    AM_NO_ADDITIVE
} ADDITIVE_MODE, *PADDITIVE_MODE;

LPCTSTR 
SdbpFormatMatchModeType(
    DWORD dwMatchMode
    )
{
    LPCTSTR pszMatchMode;
    
    switch (dwMatchMode) {
    
    case MATCH_ADDITIVE:
        pszMatchMode = _T("Additive");
        break;
        
    case MATCH_EXCLUSIVE:
        pszMatchMode = _T("Exclusive");
        break;
        
    case MATCH_NORMAL:
        pszMatchMode = _T("Normal");
        break;
        
    default:
        pszMatchMode = _T("Unknown");
        break;
    }                

    return pszMatchMode;
}

LPCTSTR 
SdbpFormatMatchMode(
    PMATCHMODE pMatchMode
    )
{
static TCHAR szMatchMode[MAX_PATH];

    LPTSTR pszMatchMode = szMatchMode;
    int    nChars = CHARCOUNT(szMatchMode);
    int    nLen;

    nLen = _sntprintf(pszMatchMode,
                      nChars,
                      _T("0x%.2x%.2x [Mode: %s"), 
                      pMatchMode->Flags,
                      pMatchMode->Type,
                      SdbpFormatMatchModeType(pMatchMode->Type));
    if (nLen < 0) {
        goto eh;
    }
    
    nChars -= nLen;
    pszMatchMode += nLen;

eh:    

    //
    // Just in case, truncate
    //
    if (nLen < 0) {
        szMatchMode[CHARCOUNT(szMatchMode) - 1] = _T('\0');
    }

    return szMatchMode;
}

/*++
    SdbpCheckExe

    Checks a particular instance of an application in an SDB against for a match
    Information on the file is passed through pContext parameter

    result is returned in ptiExes

--*/

BOOL
SdbpCheckExe(
    IN  HSDB                hSDB,               //
    IN  PDB                 pdb,                //
    IN  TAGID               tiExe,              // tag for an exe in the database
    IN OUT PDWORD           pdwNumExes,         // returns (and passes in) the number of accumulated exe matches
    IN OUT PSEARCHDBCONTEXT pContext,           // information about the file which we match against
    IN  ADDITIVE_MODE       eMode,              // target Match mode, we filter entries based on this parameter
    IN  BOOL                bDebug,             // debug flag
    OUT PMATCHMODE          pMatchMode,         // returns match mode used if success
    OUT TAGID*              ptiExes,            // returns another entry in array of matched exes
    OUT GUID*               pGUID,              // matched exe id
    OUT DWORD*              pdwFlags            // matched exe flags
    )
{
    BOOL      bSuccess = FALSE;
    TAGID     tiAppName = TAGID_NULL;
    LPTSTR    szAppName = NULL;
    LPCTSTR   pszMatchMode = NULL;
    TAGID     tiRuntimePlatform;
    DWORD     dwRuntimePlatform;
    TAGID     tiOSSKU;
    DWORD     dwOSSKU;
    TAGID     tiSP;
    DWORD     dwSPMask;
    MATCHMODE MatchMode;

    //
    // For debug purposes we'd like to know the name of the app, which
    // is more useful when the exe name is, say, AUTORUN.EXE or SETUP.EXE
    //
    tiAppName = SdbFindFirstTag(pdb, tiExe, TAG_APP_NAME);

    if (tiAppName != TAGID_NULL) {
        szAppName = SdbGetStringTagPtr(pdb, tiAppName);
    }

    DBGPRINT((sdlInfo, "SdbpCheckExe", "---------\n"));
    DBGPRINT((sdlInfo,
              "SdbpCheckExe",
              "Index entry found for App: \"%s\" Exe: \"%s\"\n",
              szAppName,
              pContext->szName));

#ifndef KERNEL_MODE

    //
    // Check whether this exe is good for this platform first.
    //
    tiRuntimePlatform = SdbFindFirstTag(pdb, tiExe, TAG_RUNTIME_PLATFORM);
    
    if (tiRuntimePlatform) {
        dwRuntimePlatform = SdbReadDWORDTag(pdb, tiRuntimePlatform, RUNTIME_PLATFORM_ANY);
        
        //
        // Check for the platform match
        //
        if (!SdbpCheckRuntimePlatform(hSDB, szAppName, dwRuntimePlatform)) {
            //
            // Not the right platform. Debug spew would have occured in SdbpCheckRuntimePlatform
            //
            goto out;
        }
    }

    tiOSSKU = SdbFindFirstTag(pdb, tiExe, TAG_OS_SKU);
    
    if (tiOSSKU) {
        
        dwOSSKU = SdbReadDWORDTag(pdb, tiOSSKU, OS_SKU_ALL);

        if (dwOSSKU != OS_SKU_ALL) {

            PSDBCONTEXT pDBContext = (PSDBCONTEXT)hSDB;

            //
            // Check for the OS SKU match
            //
            if (!(dwOSSKU & pDBContext->dwOSSKU)) {
                DBGPRINT((sdlInfo,
                          "SdbpCheckExe",
                          "OS SKU Mismatch for \"%s\" Database(0x%lx) vs 0x%lx\n",
                          (szAppName ? szAppName : TEXT("Unknown")),
                          dwOSSKU,
                          pDBContext->dwOSSKU));
                goto out;
            }
        }
    }

    tiSP = SdbFindFirstTag(pdb, tiExe, TAG_OS_SERVICE_PACK);
    
    if (tiSP) {
        dwSPMask = SdbReadDWORDTag(pdb, tiSP, 0xFFFFFFFF);

        if (dwSPMask != 0xFFFFFFFF) {

            PSDBCONTEXT pDBContext = (PSDBCONTEXT)hSDB;

            //
            // Check for the OS SKU match
            //
            if (!(dwSPMask & pDBContext->dwSPMask)) {
                DBGPRINT((sdlInfo,
                          "SdbpCheckExe",
                          "OS SP Mismatch for \"%s\" Database(0x%lx) vs 0x%lx\n",
                          (szAppName ? szAppName : TEXT("Unknown")),
                          dwSPMask,
                          pDBContext->dwSPMask));
                goto out;
            }
        }
    }
#endif // KERNEL_MODE

    if (!SdbpCheckForMatch(hSDB, pdb, tiExe, pContext, &MatchMode, pGUID, pdwFlags)) {
        goto out;
    }
    
    if (eMode == AM_ADDITIVE_ONLY && MatchMode.Type != MATCH_ADDITIVE) {
        goto out;
    }
    
    if (eMode == AM_NO_ADDITIVE && MatchMode.Type == MATCH_ADDITIVE) {
        goto out;
    }

    pszMatchMode = SdbpFormatMatchMode(&MatchMode);

    //
    // If we're in debug mode, don't actually put the ones we find on the
    // list, just put up an error.
    //
    if (bDebug) {

        //
        // We are in debug mode, do not add the match
        //
        DBGPRINT((sdlError,
                  "SdbpCheckExe",
                  "-----------------------------------------------------\n"));

        DBGPRINT((sdlError|sdlLogPipe,
                  "SdbpCheckExe",
                  "!!!! Multiple matches! App: '%s', Exe: '%s',  Mode: %s\n",
                  hSDB,  // so that the pipe would use hPipe if needed
                  szAppName,
                  pContext->szName,
                  pszMatchMode));

        DBGPRINT((sdlError,
                  "SdbpCheckExe",
                  "-----------------------------------------------------\n"));

    } else {

        DBGPRINT((sdlWarning|sdlLogPipe,
                  "SdbpCheckExe",
                  "++++ Successful match for App: '%s', Exe: '%s', Mode: %s\n",
                  hSDB,
                  szAppName,
                  pContext->szName,
                  pszMatchMode));

        //
        // If this is an exclusive match, kill anything we've found up to now
        //
        if (MatchMode.Type == MATCH_EXCLUSIVE) {
            RtlZeroMemory(ptiExes, sizeof(TAGID) * SDB_MAX_EXES);
            *pdwNumExes = 0;
        }

        //
        // Save this match on the list
        //
        ptiExes[*pdwNumExes] = tiExe;
        (*pdwNumExes)++;

        bSuccess = TRUE;
    }

out:
    //
    // In case of success, return match mode information
    //

    if (bSuccess && pMatchMode != NULL) {
        pMatchMode->dwMatchMode = MatchMode.dwMatchMode;
    }

    return bSuccess;
}


DWORD
SdbpSearchDB(
    IN  HSDB             hSDB,
    IN  PDB              pdb,           // pdb to search in
    IN  TAG              tiSearchTag,   // OPTIONAL - target tag (TAG_EXE or TAG_APPHELP_EXE)
    IN  PSEARCHDBCONTEXT pContext,
    OUT TAGID*           ptiExes,       // caller needs to provide array of size SDB_MAX_EXES
    OUT GUID*            pLastExeGUID,
    OUT DWORD*           pLastExeFlags,
    OUT PMATCHMODE       pMatchMode     // reason why we stopped scanning
    )
/*++
    Return: TAGID of found EXE record, TAGID_NULL if not found.

    Desc:   This function searches a given shimDB for any EXEs with the given filename.
            If it finds one, it checks all the MATCHING_FILE records by
            calling SdbpCheckForMatch.
            If any EXEs are found, the number of EXEs found is returned in ptiExes.
            If not, it returns 0.

            when we get the matching mode out of the particular exe -- it is checked 
            to see whether we need to continue and then this matching mode is returned

            It will never return more than SDB_MAX_EXES EXE entries.

            Debug Output is controlled by three factors 
                -- a global one (controlled via the ifdef DBG), TRUE on checked builds
                -- a pipe handle in hSDB which is activated when we init the context
                -- a local variable that is set when we are in one of the conditions above
                   when the variable bDebug is set -- we do not actually store the matches
            
--*/
{
    TAGID       tiDatabase, tiExe;
    FIND_INFO   FindInfo;
    TAGID       tiAppName = TAGID_NULL;
    TCHAR*      szAppName = _T("(unknown)");
    BOOL        bUsingIndex = FALSE;
    DWORD       dwNumExes = 0;
    DWORD       dwMatchMode = MATCH_NORMAL;
    DWORD       i;
    DWORD       dwAdditiveMode = MATCH_NORMAL;
    BOOL        bDebug = FALSE;
    BOOL        bMultiple = FALSE;
    BOOL        bSuccess = FALSE;
    MATCHMODE   MatchMode; // internal match mode
    MATCHMODE   MatchModeExe;

#ifndef KERNEL_MODE

    if (pMatchMode) {
        MatchMode.dwMatchMode = pMatchMode->dwMatchMode;
    } else {
        MatchMode.dwMatchMode = SdbpIsMainPDB(hSDB, pdb) ? MATCHMODE_DEFAULT_MAIN : 
                                                           MATCHMODE_DEFAULT_CUSTOM;
    }
#else // KERNEL_MODE

    MatchMode.dwMatchMode = MATCHMODE_DEFAULT_MAIN;

#endif

    if (!tiSearchTag) {
        tiSearchTag = TAG_EXE;
    }

    //
    // ADDITIVE MATCHES -- wildcards 
    //
    if (tiSearchTag == TAG_EXE && SdbIsIndexAvailable(pdb, TAG_EXE, TAG_WILDCARD_NAME)) {

        tiExe = SdbpFindFirstIndexedWildCardTag(pdb,
                                                TAG_EXE,
                                                TAG_WILDCARD_NAME,
                                                pContext->szName,
                                                &FindInfo);

        while (tiExe != TAGID_NULL) {

            bSuccess = SdbpCheckExe(hSDB,
                                    pdb,
                                    tiExe,
                                    &dwNumExes,
                                    pContext,
                                    AM_ADDITIVE_ONLY, // match mode we request for this db
                                    bDebug,
                                    &MatchModeExe,    // this is the matched tag from the db
                                    ptiExes,
                                    pLastExeGUID,
                                    pLastExeFlags);

            if (bSuccess) {

                if (bDebug) {
                    bMultiple = TRUE;  // if bDebug is set -- we already seen a match 
                } else {
                
                    //
                    // We got a match, update the state and make decision on whether to continue
                    //
                    MatchMode = MatchModeExe;
                    
                    if (MatchModeExe.Type != MATCH_ADDITIVE) {
                        bDebug = (g_bDBG || SDBCONTEXT_IS_INSTRUMENTED(hSDB));
                        if (!bDebug) {
                            goto out;
                        }
                    } 
                }
            }

            tiExe = SdbpFindNextIndexedWildCardTag(pdb, &FindInfo);
        }
    }

    //
    // Normal EXEs
    // 
    bUsingIndex = SdbIsIndexAvailable(pdb, tiSearchTag, TAG_NAME);

    if (bUsingIndex) {

        //
        // Look in the index.
        //
        tiExe = SdbFindFirstStringIndexedTag(pdb,
                                             tiSearchTag,
                                             TAG_NAME,
                                             pContext->szName,
                                             &FindInfo);

        if (tiExe == TAGID_NULL) {
            DBGPRINT((sdlInfo,
                      "SdbpSearchDB",
                      "SdbFindFirstStringIndexedTag failed to locate exe: \"%s\".\n",
                      pContext->szName));
        }

    } else {

        //
        // Searching without an index...
        //
        DBGPRINT((sdlInfo, "SdbpSearchDB", "Searching database with no index.\n"));

        //
        // First get the DATABASE
        //
        tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);

        if (tiDatabase != TAGID_NULL) {
            DBGPRINT((sdlError, "SdbpSearchDB", "No DATABASE tag found.\n"));
            goto out;
        }

        //
        // Then get the first EXE.
        //
        tiExe = SdbFindFirstNamedTag(pdb, tiDatabase, tiSearchTag, TAG_NAME, pContext->szName);
    }

    while (tiExe != TAGID_NULL) {

        bSuccess = SdbpCheckExe(hSDB,
                                pdb,
                                tiExe,
                                &dwNumExes,
                                pContext,
                                AM_NORMAL,
                                bDebug,
                                &MatchModeExe,
                                ptiExes,
                                pLastExeGUID,
                                pLastExeFlags);

        if (bSuccess) {

            if (bDebug) {

                bMultiple = TRUE;  // if bDebug is set -- we already seen a match 
                
            } else {
            
                //
                // We got a match, update the state and make decision on whether to continue
                // if we're not additive, we may go into debug mode
                //
                MatchMode = MatchModeExe;
                
                if (MatchModeExe.Type != MATCH_ADDITIVE) { 
                    bDebug = (g_bDBG || SDBCONTEXT_IS_INSTRUMENTED(hSDB));
                    if (!bDebug) {
                        goto out;
                    }
                } 
            }
        }

        if (bUsingIndex) {
            tiExe = SdbFindNextStringIndexedTag(pdb, &FindInfo);
        } else {
            tiExe = SdbpFindNextNamedTag(pdb, tiDatabase, tiExe, TAG_NAME, pContext->szName);
        }
    }

#ifndef KERNEL_MODE
    //
    // Now we search by module name, if one is available
    // this case falls into 16-bit flags category 
    //
    if (tiSearchTag == TAG_EXE && pContext->szModuleName) {
        
        bUsingIndex = SdbIsIndexAvailable(pdb, tiSearchTag, TAG_16BIT_MODULE_NAME);

        if (bUsingIndex) {

            //
            // Look in the index.
            //
            tiExe = SdbFindFirstStringIndexedTag(pdb,
                                                 tiSearchTag,
                                                 TAG_16BIT_MODULE_NAME,
                                                 pContext->szModuleName,
                                                 &FindInfo);

            if (tiExe == TAGID_NULL) {
                DBGPRINT((sdlInfo,
                          "SdbpSearchDB",
                          "SdbFindFirstStringIndexedTag failed to locate exe (MODNAME): \"%s\".\n",
                          pContext->szModuleName));
            }

        } else {

            //
            // Searching without an index...
            //
            DBGPRINT((sdlInfo, "SdbpSearchDB", "Searching database with no index.\n"));

            //
            // First get the DATABASE
            //
            tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);

            if (tiDatabase != TAGID_NULL) {
                DBGPRINT((sdlError, "SdbpSearchDB", "No DATABASE tag found.\n"));
                goto out;
            }

            //
            // Then get the first EXE.
            //
            tiExe = SdbFindFirstNamedTag(pdb,
                                         tiDatabase,
                                         tiSearchTag,
                                         TAG_16BIT_MODULE_NAME,
                                         pContext->szModuleName);
        }

        while (tiExe != TAGID_NULL) {

            bSuccess = SdbpCheckExe(hSDB,
                                    pdb,
                                    tiExe,
                                    &dwNumExes,
                                    pContext,
                                    AM_NORMAL,
                                    bDebug,
                                    &MatchModeExe,
                                    ptiExes,
                                    pLastExeGUID,
                                    pLastExeFlags);

            if (bSuccess) {
                if (bDebug) {
                    bMultiple = TRUE;  // if bDebug is set -- we already seen a match 
                } else {
                
                    //
                    // We got a match, update the state and make decision on whether to continue
                    //
                    MatchMode = MatchModeExe;
                    
                    if (MatchModeExe.Type != MATCH_ADDITIVE) {
                        bDebug = (g_bDBG || SDBCONTEXT_IS_INSTRUMENTED(hSDB));
                        if (!bDebug) {
                            goto out;
                        }
                    } 
                }
            }

            if (bUsingIndex) {
                tiExe = SdbFindNextStringIndexedTag(pdb, &FindInfo);
            } else {
                tiExe = SdbpFindNextNamedTag(pdb,
                                             tiDatabase,
                                             tiExe,
                                             TAG_16BIT_MODULE_NAME,
                                             pContext->szModuleName);
            }
        }
    }
#endif // KERNEL_MODE

    //
    // Now check for wild-card non-additive exes.
    //
    if (tiSearchTag == TAG_EXE && SdbIsIndexAvailable(pdb, TAG_EXE, TAG_WILDCARD_NAME)) {

        tiExe = SdbpFindFirstIndexedWildCardTag(pdb,
                                                TAG_EXE,
                                                TAG_WILDCARD_NAME,
                                                pContext->szName,
                                                &FindInfo);

        while (tiExe != TAGID_NULL) {

            bSuccess = SdbpCheckExe(hSDB,
                                    pdb,
                                    tiExe,
                                    &dwNumExes,
                                    pContext,
                                    AM_NO_ADDITIVE,
                                    bDebug,
                                    &MatchModeExe,
                                    ptiExes,
                                    pLastExeGUID,
                                    pLastExeFlags);

            if (bSuccess) {

                if (bDebug) {
                    bMultiple = TRUE;  // if bDebug is set -- we already seen a match 
                } else {
                
                    //
                    // we got a match, update the state and make decision on whether to continue
                    //
                    MatchMode = MatchModeExe;
                    
                    if (MatchModeExe.Type != MATCH_ADDITIVE) {
                        bDebug = (g_bDBG || SDBCONTEXT_IS_INSTRUMENTED(hSDB));
                        if (!bDebug) {
                            goto out;
                        }
                    } 
                }
            }


            tiExe = SdbpFindNextIndexedWildCardTag(pdb, &FindInfo);
        }
    }

out:
    //
    // Now report the final resolution of the match.
    //
    for (i = 0; i < dwNumExes; ++i) {

        tiAppName = SdbFindFirstTag(pdb, ptiExes[i], TAG_APP_NAME);

        if (tiAppName != TAGID_NULL) {
            szAppName = SdbGetStringTagPtr(pdb, tiAppName);
        } else {
            szAppName = _T("(Unknown)");
        }

        DBGPRINT((sdlWarning,
                  "SdbpSearchDB",
                  "--------------------------------------------------------\n"));

        DBGPRINT((sdlWarning|sdlLogPipe,
                  "SdbpSearchDB",
                  "+ Final match is App: \"%s\", exe: \"%s\".\n",
                  hSDB,
                  szAppName,
                  pContext->szName));

        DBGPRINT((sdlWarning,
                  "SdbpSearchDB",
                  "--------------------------------------------------------\n"));
    }

    if (bMultiple) {
        DBGPRINT((sdlError,
                  "SdbpSearchDB",
                  "--------------------------------------------------------\n"));

        DBGPRINT((sdlError|sdlLogPipe,
                  "SdbpSearchDB",
                  "!!!!!!!  Multiple non-additive matches.          !!!!!\n",
                  hSDB));

        DBGPRINT((sdlError,
                  "SdbpSearchDB",
                  "--------------------------------------------------------\n"));
    }

    if (pMatchMode != NULL) {
        pMatchMode->dwMatchMode = MatchMode.dwMatchMode;
    }

    return dwNumExes;
}

TAGREF
SdbGetDatabaseMatch(
    IN HSDB    hSDB,
    IN LPCTSTR szPath,
    IN HANDLE  FileHandle  OPTIONAL,
    IN LPVOID  pImageBase  OPTIONAL,
    IN DWORD   dwImageSize OPTIONAL
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    SEARCHDBCONTEXT Context;
    PSDBCONTEXT     pSdbContext = (PSDBCONTEXT)hSDB;
    TAGID           tiExe = TAGID_NULL;
    TAGID           atiExes[SDB_MAX_EXES];
    TAGREF          trExe = TAGREF_NULL;
    DWORD           dwNumExes = 0;
    GUID            guid;
    DWORD           dwFlags = 0;

    assert(pSdbContext->pdbMain && szPath);

    RtlZeroMemory(&Context, sizeof(Context)); // do this so that we don't trip later
    RtlZeroMemory(atiExes, sizeof(atiExes));

    Context.dwFlags |= (SEARCHDBF_NO_PROCESS_HISTORY | SEARCHDBF_NO_ATTRIBUTE_CACHE);

    if (FileHandle != INVALID_HANDLE_VALUE || pImageBase != NULL) {
        Context.dwFlags |= SEARCHDBF_NO_LFN;
    }

    Context.hMainFile   = FileHandle; // used to optimize attribute retrieval
    Context.pImageBase  = pImageBase; // this will be used and not a file handle
    Context.dwImageSize = dwImageSize; // size of the image

    DBGPRINT((sdlInfo, "SdbGetDatabaseMatch", "Looking for \"%s\"\n", szPath));

    //
    // Create search db context, no process history needed.
    //
    if (!SdbpCreateSearchDBContext(&Context, szPath, NULL, NULL)) {
        DBGPRINT((sdlError,
                  "SdbGetDatabaseMatch",
                  "Failed to create search DB context.\n"));
        goto out;
    }

    //
    // We will be searching the main db
    //
    dwNumExes = SdbpSearchDB(pSdbContext,
                             pSdbContext->pdbMain,
                             TAG_EXE,
                             &Context,
                             atiExes,
                             &guid,
                             &dwFlags,
                             NULL);
    //
    // Convert to TAGREF
    //
    if (dwNumExes) {

        //
        // Always use the last exe in the list, as it will be the most specific
        //
        tiExe = atiExes[dwNumExes - 1];

        if (!SdbTagIDToTagRef(hSDB, pSdbContext->pdbMain, tiExe, &trExe)) {
            DBGPRINT((sdlError,
                      "SdbGetDatabaseMatch",
                      "Failed to convert tagid to tagref\n"));
            goto out;
        }
    }

out:

    SdbpReleaseSearchDBContext(&Context);

    return trExe;
}


DWORD
SdbQueryData(
    IN     HSDB    hSDB,              // database handle
    IN     TAGREF  trExe,             // tagref of the matching exe
    IN     LPCTSTR lpszDataName,      // if this is null, will try to return all the policy names
    OUT    LPDWORD lpdwDataType,      // pointer to data type (REG_SZ, REG_BINARY, etc)
    OUT    LPVOID  lpBuffer,          // buffer to fill with information
    IN OUT LPDWORD lpdwBufferSize     // pointer to buffer size
    )
{
    return SdbQueryDataEx(hSDB, trExe, lpszDataName, lpdwDataType, lpBuffer, lpdwBufferSize, NULL);
}


DWORD
SdbQueryDataExTagID(
    IN     PDB     pdb,               // database handle
    IN     TAGID   tiExe,             // tagref of the matching exe
    IN     LPCTSTR lpszDataName,      // if this is null, will try to return all the policy names
    OUT    LPDWORD lpdwDataType,      // pointer to data type (REG_SZ, REG_BINARY, etc)
    OUT    LPVOID  lpBuffer,          // buffer to fill with information
    IN OUT LPDWORD lpdwBufferSize,    // pointer to buffer size
    OUT    TAGID*  ptiData            // optional pointer to the retrieved data tag
    )
/*++
    Return: Error code or ERROR_SUCCESS if successful

    Desc:   See complete description with sample code
            in doc subdirectory
--*/
{
    TAGID     tiData;
    BOOL      bSuccess;
    TAGID     tiParent;
    TAGID     tiName;
    TAGID     tiValue;
    TAGID     tiValueType;
    DWORD     cbSize;
    DWORD     dwValueType;
    LPCTSTR   pszName;
    LPTSTR    pszNameBuffer = NULL;
    LPTSTR    pSlash;
    LPTSTR    pchBuffer;
    DWORD     dwData;
    TAG       tData;
    ULONGLONG ullData;
    LPVOID    lpValue;
    DWORD     Status = ERROR_NOT_SUPPORTED; // have it initialized

    if (lpszDataName == NULL) {

        if (lpdwBufferSize == NULL) {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrHandle;
        }

        cbSize = 0;

        tiData = SdbFindFirstTag(pdb, tiExe, TAG_DATA);
        if (!tiData) {
            //
            // Bad entry.
            //
            DBGPRINT((sdlError,
                      "SdbQueryDataExTagID",
                      "The entry 0x%x does not appear to have data\n",
                      tiExe));

            Status = ERROR_INTERNAL_DB_CORRUPTION;
            goto ErrHandle;
        }

        while (tiData) {

            //
            // Pass one: Calculate the size needed.
            //
            tiName = SdbFindFirstTag(pdb, tiData, TAG_NAME);
            
            if (!tiName) {
                DBGPRINT((sdlError,
                          "SdbQueryDataExTagID",
                          "The entry 0x%x does not contain a name tag\n",
                          tiData));
                Status = ERROR_INTERNAL_DB_CORRUPTION;
                goto ErrHandle;
            }

            pszName = SdbGetStringTagPtr(pdb, tiName);
            
            if (!pszName) {
                DBGPRINT((sdlError,
                          "SdbQueryDataExTagID",
                          "The entry 0x%x contains NULL name\n",
                          tiName));
                Status = ERROR_INTERNAL_DB_CORRUPTION;
                goto ErrHandle;
            }

            cbSize += (_tcslen(pszName) + 1) * sizeof(*pszName);

            tiData = SdbFindNextTag(pdb, tiExe, tiData);
        }

        cbSize += sizeof(*pszName); // for the final 0

        //
        // We are done, compare the size.
        //
        if (lpBuffer == NULL || *lpdwBufferSize < cbSize) {
            *lpdwBufferSize = cbSize;
            Status = ERROR_INSUFFICIENT_BUFFER;
            goto ErrHandle;
        }

        //
        // lpBuffer != NULL here and there is enough room
        //
        pchBuffer = (LPTSTR)lpBuffer;

        tiData = SdbFindFirstTag(pdb, tiExe, TAG_DATA);

        while (tiData) {

            tiName = SdbFindFirstTag(pdb, tiData, TAG_NAME);
            
            if (tiName) {
                pszName = SdbGetStringTagPtr(pdb, tiName);

                if (pszName) {
                    _tcscpy(pchBuffer, pszName);
                    pchBuffer += _tcslen(pchBuffer) + 1;
                }
            }

            tiData = SdbFindNextTag(pdb, tiExe, tiData);
        }

        //
        // The buffer has been filled, terminate.
        //
        *pchBuffer++ = TEXT('\0');

        //
        // Save the size written to the buffer
        //
        *lpdwBufferSize = (DWORD)((ULONG_PTR)pchBuffer - (ULONG_PTR)lpBuffer);

        //
        // Save data type
        //
        if (lpdwDataType != NULL) {
            *lpdwDataType = REG_MULTI_SZ;
        }

        return ERROR_SUCCESS;
    }

    //
    // In this case we allow the query to proceed if
    // the buffer is null and lpdwBufferSize is not null or lpBufferSize is not null
    //
    if (lpBuffer == NULL && lpdwBufferSize == NULL) {
        DBGPRINT((sdlError,
                  "SdbQueryDataExTagID",
                  "One of lpBuffer or lpdwBufferSize should not be null\n"));
        Status = ERROR_INVALID_PARAMETER;
        goto ErrHandle;
    }

    //
    // Expect the name to be in format "name1\name2..."
    //
    STACK_ALLOC(pszNameBuffer, (_tcslen(lpszDataName) + 1) * sizeof(*pszNameBuffer));
    
    if (pszNameBuffer == NULL) {
        DBGPRINT((sdlError,
                  "SdbQueryDataExTagID",
                  "Cannot allocate temporary buffer for parsing the name \"%s\"\n",
                  lpszDataName));
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrHandle;
    }

    tiParent = tiExe;
    tiData   = TAGID_NULL;
    
    do {
        pSlash = _tcschr(lpszDataName, TEXT('\\'));
        
        if (pSlash == NULL) {
            _tcscpy(pszNameBuffer, lpszDataName);
            lpszDataName = NULL;
        } else {
            _tcsncpy(pszNameBuffer, lpszDataName, pSlash - lpszDataName);
            pszNameBuffer[pSlash - lpszDataName] = TEXT('\0');
            lpszDataName = pSlash + 1; // go to the next char
        }
        
        tiData = SdbFindFirstNamedTag(pdb, tiParent, TAG_DATA, TAG_NAME, pszNameBuffer);
        tiParent = tiData;
    
    } while (lpszDataName != NULL && *lpszDataName != TEXT('\0') && tiData != TAGID_NULL);

    if (!tiData) {
        DBGPRINT((sdlError,
                  "SdbQueryDataExTagID",
                  "The entry \"%s\" not found\n",
                  pszNameBuffer));
        Status = ERROR_NOT_FOUND;
        goto ErrHandle;
    }

    //
    // Looks like we found the entry, query value type
    //
    dwValueType = REG_NONE;

    tiValueType = SdbFindFirstTag(pdb, tiData, TAG_DATA_VALUETYPE);
    
    if (!tiValueType) {
        DBGPRINT((sdlWarning,
                  "SdbQueryDataExTagID",
                  "The entry 0x%x does not have valuetype information\n",
                  tiData));
    } else {
        dwValueType = SdbReadDWORDTag(pdb, tiValueType, REG_NONE);
    }

    cbSize  = 0;
    lpValue = NULL;

    if (dwValueType != REG_NONE) {

        //
        // Find data tag
        //
        cbSize = 0;

        switch (dwValueType) {
        
        case REG_SZ:
            //
            // string data
            //
            tData = TAG_DATA_STRING;
            break;

        case REG_DWORD:
            tData = TAG_DATA_DWORD;
            break;

        case REG_QWORD:
            tData = TAG_DATA_QWORD;
            break;

        case REG_BINARY:
            tData = TAG_DATA_BITS;
            break;

        default:
            DBGPRINT((sdlError,
                      "SdbQueryDataExTagID",
                      "The entry 0x%x contains bad valuetype information 0x%x\n",
                      tiData,
                      dwValueType));
            Status = ERROR_INTERNAL_DB_CORRUPTION;
            goto ErrHandle;
            break;
        }

        tiValue = SdbFindFirstTag(pdb, tiData, tData);
        
        //
        // Find what the data size is if needed
        //
        if (!tiValue) {

            DBGPRINT((sdlWarning,
                      "SdbQueryDataExTagID",
                      "The entry 0x%x contains no value\n",
                      tiData));
            Status = ERROR_NOT_FOUND;
            goto ErrHandle;

        }

        //
        // For those who have no size quite yet...
        // (binary and a string)
        //
        switch (dwValueType) {
        
        case REG_SZ:
            pchBuffer = SdbGetStringTagPtr(pdb, tiValue);
            
            if (pchBuffer == NULL) {
                DBGPRINT((sdlWarning,
                          "SdbQueryDataExTagID",
                          "The entry 0x%x contains bad string value 0x%x\n",
                          tiData,
                          tiValue));
                Status = ERROR_NOT_FOUND;
                goto ErrHandle;
            }

            cbSize = (_tcslen(pchBuffer) + 1) * sizeof(*pchBuffer);
            lpValue = (LPVOID)pchBuffer;
            break;

        case REG_BINARY:
            cbSize = SdbGetTagDataSize(pdb, tiValue); // binary tag
            lpValue = SdbpGetMappedTagData(pdb, tiValue);

            if (lpValue == NULL) {
                DBGPRINT((sdlWarning,
                          "SdbQueryDataExTagID",
                          "The entry 0x%x contains bad binary value 0x%x\n",
                          tiData,
                          tiValue));
                Status = ERROR_NOT_FOUND;
                goto ErrHandle;
            }
            break;

        case REG_DWORD:
            dwData = SdbReadDWORDTag(pdb, tiValue, 0);
            cbSize = sizeof(dwData);
            lpValue = (LPVOID)&dwData;
            break;

        case REG_QWORD:
            ullData = SdbReadQWORDTag(pdb, tiValue, 0);
            cbSize = sizeof(ullData);
            lpValue = (LPVOID)&ullData;
            break;
        }

        //
        // At this point we have everything we need to get the pointer to data.
        //
    }

    //
    // Fix the output params and exit.
    //
    Status = ERROR_SUCCESS;

    if (cbSize == 0) {
        goto SkipCopy;
    }

    if (lpBuffer == NULL || (lpdwBufferSize != NULL && *lpdwBufferSize < cbSize)) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto SkipCopy;
    }

    //
    // Buffer size checked out, now if buffer exists -- copy
    //
    if (lpBuffer != NULL) {
        RtlMoveMemory(lpBuffer, lpValue, cbSize);
    }

SkipCopy:

    if (lpdwBufferSize) {
        *lpdwBufferSize = cbSize;
    }

    if (lpdwDataType) {
        *lpdwDataType = dwValueType;
    }

    if (ptiData) {
        *ptiData = tiData;
    }

ErrHandle:

    if (pszNameBuffer != NULL) {
        STACK_FREE(pszNameBuffer);
    }

    return Status;
}

DWORD
SdbQueryDataEx(
    IN     HSDB    hSDB,              // database handle
    IN     TAGREF  trExe,             // tagref of the matching exe
    IN     LPCTSTR lpszDataName,      // if this is null, will try to return all the policy names
    OUT    LPDWORD lpdwDataType,      // pointer to data type (REG_SZ, REG_BINARY, etc)
    OUT    LPVOID  lpBuffer,          // buffer to fill with information
    IN OUT LPDWORD lpdwBufferSize,    // pointer to buffer size
    OUT    TAGREF* ptrData            // optional pointer to the retrieved data tag
    )
{
    BOOL     bSuccess;
    PDB      pdb   = NULL;
    TAGID    tiExe = TAGID_NULL;
    TAGID    tiData;
    NTSTATUS Status;

    bSuccess = SdbTagRefToTagID(hSDB, trExe, &pdb, &tiExe);

    if (!bSuccess) {
        DBGPRINT((sdlError,
                  "SdbQueryDataEx",
                  "Failed to convert tagref 0x%x to tagid\n",
                  trExe));
        Status = ERROR_INVALID_PARAMETER;
        goto ErrHandle;
    }

    Status = SdbQueryDataExTagID(pdb,
                                 tiExe,
                                 lpszDataName,
                                 lpdwDataType,
                                 lpBuffer,
                                 lpdwBufferSize,
                                 &tiData);
    //
    // See that we convert the output param
    //
    if (ptrData != NULL && NT_SUCCESS(Status)) {
        if (!SdbTagIDToTagRef(hSDB, pdb, tiData, ptrData)) {
            Status = ERROR_INVALID_DATA;
        }
    }

ErrHandle:

    return Status;
}

BOOL
SdbReadEntryInformation(
    IN  HSDB           hSDB,
    IN  TAGREF         trExe,
    OUT PSDBENTRYINFO  pEntryInfo
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    BOOL         bSuccess = FALSE;
    TAGID        tiExe;
    TAGID        tiData;
    TAGID        tiExeID;
    TAGID        tiPolicy;
    TAGID        tiRegPath;
    PDB          pdb;
    SDBENTRYINFO EntryInfo;

    RtlZeroMemory(&EntryInfo, sizeof(EntryInfo));

    bSuccess = SdbTagRefToTagID(hSDB, trExe, &pdb, &tiExe);
    
    if (!bSuccess) {
        DBGPRINT((sdlError,
                  "SdbReadEntryInformation",
                  "Failed to convert tagref 0x%x to tagid\n",
                  trExe));
        goto ErrHandle;
    }

    //
    // Get the EXE's ID
    //
    tiExeID = SdbFindFirstTag(pdb, tiExe, TAG_EXE_ID);

    if (tiExeID == TAGID_NULL) {
        DBGPRINT((sdlError,
                  "SdbReadEntryInformation",
                  "Failed to read TAG_EXE_ID for tiExe 0x%x !\n",
                  tiExe));
        goto ErrHandle;
    }

    bSuccess = SdbReadBinaryTag(pdb,
                                tiExeID,
                                (PBYTE)&EntryInfo.guidID,
                                sizeof(EntryInfo.guidID));
    if (!bSuccess) {
        DBGPRINT((sdlError,
                  "SdbReadEntryInformation",
                  "Failed to read GUID referenced by 0x%x\n",
                  tiExeID));
        goto ErrHandle;
    }

    //
    // Get the database id
    //
    if (!SdbGetDatabaseID(pdb, &EntryInfo.guidDB)) {
        DBGPRINT((sdlError,
                  "SdbReadEntryInformation",
                  "Failed to read GUID of the database\n"));
        goto ErrHandle;
    }

    //
    // Retrieve entry flags as referenced by the registry
    //
    if (!SdbGetEntryFlags(&EntryInfo.guidID, &EntryInfo.dwFlags)) {
        DBGPRINT((sdlWarning,
                  "SdbReadEntryInformation",
                  "No flags for tiExe 0x%x\n",
                  tiExe));

        EntryInfo.dwFlags = 0;
    } else {
        DBGPRINT((sdlInfo,
                  "SdbReadEntryInformation",
                  "Retrieved flags for this app 0x%x.\n",
                  EntryInfo.dwFlags));
    }

    //
    // Read the data tags
    //
    tiData = SdbFindFirstTag(pdb, tiExe, TAG_DATA);
    
    EntryInfo.tiData = tiData;
    
    if (tiData == TAGID_NULL) {
        //
        // This is not a data entry
        //
        DBGPRINT((sdlWarning,
                  "SdbReadEntryInformation",
                  "Entry tiExe 0x%x does not contain TAG_DATA.\n",
                  tiExe));
    }

    if (pEntryInfo != NULL) {
        RtlMoveMemory(pEntryInfo, &EntryInfo, sizeof(*pEntryInfo));
    }

    bSuccess = TRUE;

ErrHandle:

    return bSuccess;
}


//
// We may be compiled UNICODE or ANSI
// If we are compiled UNICODE we need to use UNICODE sprintf and convert
// the result back to ANSI for output with DbgPrint. This is accomplished
// by %ls format in DbgPrint. Format and Function name are always passed
// in as ANSI though. TCHAR strings are formatted just with %s
//

void
PrepareFormatForUnicode(
    PCH fmtUnicode,
    PCH format
    )
{
    PCH    pfmt;
    CHAR   ch;
    size_t nch;
    long   width;
    PCH    pend;

    strcpy(fmtUnicode, format);
    pfmt = fmtUnicode;

    while('\0' != (ch = *pfmt++)) {
        if (ch == '%') {

            if (*pfmt == '%') {
                continue;
            }

            //
            // Skip the characters that relate to  - + 0 ' ' #
            //
            nch = strspn(pfmt, "-+0 #");
            pfmt += nch;

            //
            // Parse the width.
            //
            if (*pfmt == '*') {
                //
                // Parameter defines the width
                //
                ++pfmt;
            } else {
                //
                // See whether we have width
                //
                if (isdigit(*pfmt)) {
                    pend = NULL;
                    width = atol(pfmt);

                    while (isdigit(*pfmt)) {
                        ++pfmt;
                    }
                }
            }

            //
            // Now we can have: .precision
            //
            if (*pfmt == '.') {
                ++pfmt;
                width = atol(pfmt);

                while (isdigit(*pfmt)) {
                    ++pfmt;
                }
            }

            //
            // Now is the format (one of: h, l, L, I64)
            //
            ch = *pfmt;
            pend = strchr("hlLNFw", ch);
            if (pend != NULL) {
                ++pfmt; // move past the modifier char
            } else {
                if (ch == 'I' && !strncpy(pfmt, "I64", 3)) {
                    pfmt += 3;
                }
            }

            //
            // We should have a type character here.
            //
            if (*pfmt == 's') {
                //
                // Convert to UPPER, making it UNICODE string with ansi vsnprintf
                //
                *pfmt = 'S';
            }

            //
            // Move past the format char if we are not at the end
            //
            if (*pfmt != '\0') {
                ++pfmt;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\sdbp.h ===
#ifndef __SDBP_H__
#define __SDBP_H__

#ifndef SDB_ANSI_LIB
    #define UNICODE
    #define _UNICODE
#endif

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <malloc.h>
#include <stddef.h>

#ifndef KERNEL_MODE

    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>

    #include <windows.h>

#else // KERNEL_MODE

    #include <ntosp.h>
    #include <zwapi.h>

    #include <ntimage.h>
    #include <windef.h>
    #include <winver.h>
    #include <winerror.h>
    #include <stdarg.h>
    #include <ntldr.h>

    #define NtCreateFile           ZwCreateFile
    #define NtClose                ZwClose
    #define NtReadFile             ZwReadFile
    #define NtOpenKey              ZwOpenKey
    #define NtQueryValueKey        ZwQueryValueKey
    #define NtMapViewOfSection     ZwMapViewOfSection
    #define NtUnmapViewOfSection   ZwUnmapViewOfSection
    #define NtOpenFile             ZwOpenFile
    #define NtQueryInformationFile ZwQueryInformationFile

    #ifndef MAKEINTRESOURCE
        #define MAKEINTRESOURCEW(i) (LPWSTR)((ULONG_PTR)((WORD)(i)))
        #define MAKEINTRESOURCE MAKEINTRESOURCEW
    #endif // not defined MAKEINTRESOURCE

    #ifndef RT_VERSION
        #define RT_VERSION  MAKEINTRESOURCE(16)
    #endif // not defined RT_VERSION

    #ifndef INVALID_HANDLE_VALUE
        #define INVALID_HANDLE_VALUE ((HANDLE)(LONG_PTR)-1)
    #endif // not defined INVALID_HANDLE_VALUE

    #ifndef SEC_COMMIT
        #define SEC_COMMIT  0x8000000
    #endif

#endif // KERNEL_MODE


#include <tchar.h>

#include "shimdb.h"

#define MAX_INDEXES             10

#define TABLETPC_KEY_PATH   TEXT("System\\WPA\\TabletPC")
#define EHOME_KEY_PATH      TEXT("SYSTEM\\WPA\\MediaCenter")
#define IS_OS_INSTALL_VALUE TEXT("Installed")

//
// This is a flag stored for each index.
// Currently it is only used to flag "unique key" types.
//
#define SHIMDB_INDEX_UNIQUE_KEY 0x00000001



// index could be of 2 types:
// containing simply all record and containing only
// "unique" keys with the records linked (the records have to be sorted for this
// type of index to work)
typedef struct _INDEX_INFO {
    TAGID       tiIndex;            // points at the INDEX_BITS tag
    TAG         tWhich;             // what tag is being indexed
    TAG         tKey;               // what subtag is the key?
    BOOL        bActive;            // are we actually indexing now?
    BOOL        bUniqueKey;         // are the keys unique?
    ULONGLONG   ullLastKey;
    DWORD       dwIndexEntry;       // offset to the next available index entry
    DWORD       dwIndexEnd;         // one byte past the end of the index block
    DWORD       dwFlags;
} INDEX_INFO, *PINDEX_INFO;

//
// Flags for use in DB structure DB.dwFlags
//

#define DB_IN_MEMORY           0x00000001
#define DB_GUID_VALID          0x00000002


typedef struct _DB {
    // used for both read and write

    HANDLE      hFile;
    PVOID       pBase;              // for  both memory-mapping & buffered writes
    BOOL        bWrite;             // was it opened with create?
    DWORD       dwSize;             // the size of the whole db, in bytes

    DWORD       dwFlags;            // flags (such as IN-memory flag)

    GUID        guidDB;             // optional id for the database

    DWORD       dwIndexes;          // the number of indexes
    INDEX_INFO  aIndexes[MAX_INDEXES];  // data for the indexes

    // stuff that's used for read
    HANDLE      hSection;           // for memory-mapping
    TAGID       tiStringTable;      // pointer to the stringtable for string handling
    BOOL        bIndexesScanned;    // have the indexes been looked at?

    // stuff that's used for write
    struct _DB* pdbStringTable;    // stringtable is a subdatabase that's created on the side
    PVOID       pStringHash;        // stringtable hash (same info as in stringtable)
    DWORD       dwAllocatedSize;    // the size allocated for buffered writes
    BOOL        bWritingIndexes;    // are we in the process of allocating index space?
    TAGID       tiIndexes;          // used during index allocation

    //
    // BUGBUG Hack alert read from unaligned (v1.0) database is enabled here
    //
    BOOL        bUnalignedRead;


#ifdef WIN32A_MODE
    PVOID       pHashStringBody;    // hash of the strings located within the body
    PVOID       pHashStringTable;   // hash for the strings in the stringtable
#endif

#ifndef WIN32A_MODE
    UNICODE_STRING ustrTempStringtable; // string table temp filename
#else
    LPCTSTR        pszTempStringtable;
#endif


} DB, *PDB;


//
// We're using the high 4 bits of the TAGID to
// say what PDB the TAGID is from. Kludge? Perhaps.
//
#define PDB_MAIN            0x00000000
#define PDB_TEST            0x10000000

// all other entries are local (custom) pdbs

#define PDB_LOCAL           0x20000000

#define TAGREF_STRIP_TAGID  0x0FFFFFFF
#define TAGREF_STRIP_PDB    0xF0000000

typedef WCHAR* PWSZ;



ULONG
ShimExceptionHandler(
    PEXCEPTION_POINTERS pexi,
    char*               pszFile,
    DWORD               dwLine
    );

#if DBG
#define SHIM_EXCEPT_HANDLER ShimExceptionHandler(GetExceptionInformation(), __FILE__, __LINE__)
#else
#define SHIM_EXCEPT_HANDLER ShimExceptionHandler(GetExceptionInformation(), "", 0)
#endif


//
// Function prototypes for use in attributes.c (from version.dll)
//
//

typedef DWORD (WINAPI* PFNGetFileVersionInfoSize) (LPTSTR  lptstrFilename,
                                                   LPDWORD lpdwHandle);

typedef BOOL (WINAPI* PFNGetFileVersionInfo)(LPTSTR lpstrFilename,
                                             DWORD  dwHandle,
                                             DWORD  dwLen,
                                             LPVOID lpData);

typedef BOOL  (WINAPI* PFNVerQueryValue)(const LPVOID pBlock,
                                         LPTSTR       lpSubBlock,
                                         LPVOID*      lplpBuffer,
                                         PUINT        puLen);

#ifdef WIN32A_MODE

#define VERQUERYVALUEAPINAME          "VerQueryValueA"
#define GETFILEVERSIONINFOAPINAME     "GetFileVersionInfoA"
#define GETFILEVERSIONINFOSIZEAPINAME "GetFileVersionInfoSizeA"

#else

#define VERQUERYVALUEAPINAME          "VerQueryValueW"
#define GETFILEVERSIONINFOAPINAME     "GetFileVersionInfoW"
#define GETFILEVERSIONINFOSIZEAPINAME "GetFileVersionInfoSizeW"

#endif


//
// custom db cache entry and header
//
typedef struct tagUSERSDBLOOKUPENTRY {
    ULARGE_INTEGER liTimeStamp; // we don't need this item, but just for debugging ...
    GUID           guidDB;
} USERSDBLOOKUPENTRY, *PUSERSDBLOOKUPENTRY;

//
// Lookup vectors
//
//
typedef struct tagUSERSDBLOOKUP {

    struct tagUSERSDBLOOKUP* pNext;

    struct tagUSERSDBLOOKUP* pPrev;
    LPWSTR              pwszItemName;   // item name
    BOOL                bLayer;         // true if layer

    DWORD               dwCount;        // item count

    USERSDBLOOKUPENTRY  rgEntries[1];   // actual names

} USERSDBLOOKUP, *PUSERSDBLOOKUP;


//
// HSDB flags
//
#define HSDBF_USE_ATTRIBUTES    0x00000001

#define MAX_SDBS 16

/*++
    Flags for use with SdbOpenLocalDatabaseEx

--*/

#define SDBCUSTOM_GUID        0x00000001   // this is a "type" -- when specified, database guid is used to find/open the database
#define SDBCUSTOM_GUID_BINARY 0x00000001   // guid is provided in binary form
#define SDBCUSTOM_GUID_STRING 0x00010001   // guid is provided as a string "{....}"

#define SDBCUSTOM_PATH        0x00000002   // when specified, database path is used to find/open the database
#define SDBCUSTOM_PATH_DOS    0x00000002   // path is provided in dos form
#define SDBCUSTOM_PATH_NT     0x00010002   // path is provided in nt form

#define SDBCUSTOM_USE_INDEX   0x10000000   // when specified, an index is provided to use a particular entry within the sdb table

#define SDBCUSTOM_FLAGS(dwFlags)  ((dwFlags) & 0xFFFF0000) 
#define SDBCUSTOM_TYPE(dwFlags)   ((dwFlags) & 0x0FFFF)

#define SDBCUSTOM_SET_MASK(hSDB, dwIndex) \
    (((PSDBCONTEXT)hSDB)->dwDatabaseMask |= (1 << (dwIndex)))

#define SDBCUSTOM_CLEAR_MASK(hSDB, dwIndex) \
    (((PSDBCONTEXT)hSDB)->dwDatabaseMask &= ~(1 << (dwIndex)))
    
#define SDBCUSTOM_CHECK_INDEX(hSDB, dwIndex) \
    (((PSDBCONTEXT)hSDB)->dwDatabaseMask & (1 << (dwIndex)))

#define SDB_CUSTOM_MASK       0x0FFF8       // except 0, 1 and 2 -- bits for main, test and local

/*++
    These macros convert from the mask form (as found in TAGREF's high 4 bits) to
    index form and back
    
--*/

#define SDB_MASK_TO_INDEX(dwMask)  ((((DWORD)(dwMask)) >> 28) & 0x0F)
#define SDB_INDEX_TO_MASK(dwIndex) (((DWORD)(dwIndex)) << 28)


typedef struct tagSDBENTRY {
    GUID    guidDB;   // guid of a custom db 
    PDB     pdb;      // pdb for the db
    DWORD   dwFlags;  // see SDBENTRY_ flags
} SDBENTRY, *PSDBENTRY;


/*++
    Given a context and index (or mask) for an sdb - retrieve a pointer to 
    the appropriate entry (PSDBENTRY)

--*/
#define SDBGETENTRY(hSDB, dwIndex) \
        (&((PSDBCONTEXT)hSDB)->rgSDB[dwIndex])
#define SDBGETENTRYBYMASK(hSDB, dwMask) \
        SDBGETENTRY(hSDB, SDB_MASK_TO_INDEX(dwMask))

/*++
    Retrieve main, test and temporary entries respectively
--*/
#define SDBGETMAINENTRY(hSDB)  SDBGETENTRY(hSDB, SDB_MASK_TO_INDEX(PDB_MAIN))
#define SDBGETTESTENTRY(hSDB)  SDBGETENTRY(hSDB, SDB_MASK_TO_INDEX(PDB_TEST))
#define SDBGETLOCALENTRY(hSDB) SDBGETENTRY(hSDB, SDB_MASK_TO_INDEX(PDB_LOCAL))

#define SDB_LOCALDB_INDEX      SDB_MASK_TO_INDEX(PDB_LOCAL)
#define SDB_FIRST_ENTRY_INDEX  3   // since 0 is main, 1 is test and 2 is local


/*++
    Flags that are valid in SDBENTRY.dwFlags

--*/
#define SDBENTRY_VALID_GUID   0x00000001 // indicated that an entry has valid guid for lookup
#define SDBENTRY_VALID_ENTRY  0x00000002 // indicates whether an entry is free

#define SDBENTRY_INVALID_INDEX ((DWORD)-1)

/*++
    Macros that allow us access to some of the members of hSDB w/o derefencing the type
    Makes it a bit easier of the typecasts in code

--*/
#ifdef WIN32A_MODE

#define SDBCONTEXT_IS_INSTRUMENTED(hSDB) FALSE
#define SDBCONTEXT_GET_PIPE(hSDB)        INVALID_HANDLE_VALUE

#else 

#define SDBCONTEXT_GET_PIPE(hSDB) \
        (((PSDBCONTEXT)(hSDB))->hPipe)

#define SDBCONTEXT_IS_INSTRUMENTED(hSDB) \
        (((PSDBCONTEXT)(hSDB))->hPipe != INVALID_HANDLE_VALUE)

#endif


typedef struct tagSDBCONTEXT {

    DWORD dwFlags;

    //
    // Database handles
    //

    PDB pdbMain;  // main database (sysmain)
    PDB pdbTest;  // test database (systest)
    PDB pdbLocal; // local database

    // 
    // database table
    // 
    DWORD dwDatabaseCount; // number of entries in the table below
    DWORD dwDatabaseMask;  // bit-field mask for databases
    SDBENTRY rgSDB[MAX_SDBS]; 

    //
    // Pointer to the file attribute cache (see attributes.c for details)
    //

    PVOID pFileAttributeCache;

    //
    // function pointers for use with version.dll
    // (see attributes.c)
    //
    PFNVerQueryValue            pfnVerQueryValue;
    PFNGetFileVersionInfo       pfnGetFileVersionInfo;
    PFNGetFileVersionInfoSize   pfnGetFileVersionInfoSize;

    //
    // processor architecture, cached to perform checks of RUNTIME_PLATFORM
    //
    DWORD dwRuntimePlatform;

    //
    // OS SKU
    //
    DWORD dwOSSKU;

    //
    // OS SP mask
    //
    DWORD dwSPMask;

    //
    // User SDB cache
    //
    PUSERSDBLOOKUP pLookupHead;

#ifndef WIN32A_MODE 
    //
    // debug pipe
    //
    HANDLE hPipe;

#endif // WIN32A_MODE

} SDBCONTEXT, *PSDBCONTEXT;


//
// These flags are used to direct
// SearchDB routine not to use process_history or
// to prepare for lookup in local DB
//

#define SEARCHDBF_INITIALIZED          0x00000001
#define SEARCHDBF_NO_PROCESS_HISTORY   0x00000002
//
// note the gap here -- there was a flag related to local dbs - it's 
// defunct and has been removed
//
#define SEARCHDBF_NO_ATTRIBUTE_CACHE   0x00000008
#define SEARCHDBF_NO_LFN               0x00000010

typedef struct tagSEARCHPATHPART {
    LPCTSTR  pszPart;
    ULONG    PartLength;
} SEARCHPATHPART, *PSEARCHPATHPART;

typedef struct tagSEARCHPATH {
    ULONG PartCount; // count parts
    SEARCHPATHPART Parts[];
} SEARCHPATHPARTS, *PSEARCHPATHPARTS;


typedef struct tagSEARCHDBCONTEXT {

    DWORD   dwFlags;      // flags directing how the context is used
                          // we may, for instance, not want to use ProcessHistory
                          // at all SEARCHDBF* flags apply

    HANDLE  hMainFile;    // handle of the main file we are checking
    LPVOID  pImageBase;   // pointer to image base for the main file. We will use the image pointer
    DWORD   dwImageSize;  // image size as provided by k-mode code

    LPTSTR  szDir;        // directory, we allocate it, we free it
    LPTSTR  szName;       // filename for the file we're looking up, we allocate and free it
    LPTSTR  szModuleName; // for 16-bit apps only; we allocate and free

    LPCTSTR pEnvironment; // we DON'T touch this at all
    LPTSTR  szProcessHistory; // buffer for the search path string (unparsed), allocated by us, we free it

    PSEARCHPATHPARTS pSearchParts; // search path undone, we allocate and free it

} SEARCHDBCONTEXT, *PSEARCHDBCONTEXT;

// HASH structures

typedef struct tagStringHashElement {
    TCHAR*                          szStr;  // the string itself (points past buffer)
    STRINGREF                       srStr;  // stringref (where the string is)
    struct tagStringHashElement*    pNext;

} STRHASHELEMENT, *PSTRHASHELEMENT;


typedef struct tagStringHash {
    DWORD            dwHashSize; // hash size
    PSTRHASHELEMENT* pTable;

} STRHASH, *PSTRHASH;


#ifndef WIN32A_MODE

//
// apphelp info stuff (see apphelp.c)
//

//
// dwContextFlags can have these values:
//
#define AHC_DBDETAILS_NOCLOSE 0x00000001
#define AHC_HSDB_NOCLOSE      0x00000002

typedef struct tagAPPHELPINFOCONTEXT {
    HSDB    hSDB; // handle to the database

    PDB     pdb;           // pdb where we have exe or null (we work through hsdb then
    PDB     pdbDetails;    // pdb where we have details
    DWORD   dwDatabaseType; // this is the database type (of the db that contains the match)
    DWORD   dwContextFlags; // flags specific to the context

    GUID    guidDB;        // database guid
    GUID    guidID;        // guid of the matching entry

    DWORD   dwMask;       // mask which tells us whether members are valid

    TAGID   tiExe;        // tagid of an exe entry
    TAGID   tiApphelpExe; // apphelp in the main db
    DWORD   dwHtmlHelpID; // html help id
    DWORD   dwSeverity;
    DWORD   dwFlags;


    TAGID   tiApphelpDetails;    // apphelp stuff in the details db
    TAGID   tiLink;
    LPCWSTR pwszAppName;
    LPCWSTR pwszApphelpURL;
    LPCWSTR pwszVendorName;
    LPCWSTR pwszExeName;
    LPCWSTR pwszLinkURL;
    LPCWSTR pwszLinkText;
    LPCWSTR pwszTitle;
    LPCWSTR pwszDetails;
    LPCWSTR pwszContact;

    LPWSTR  pwszHelpCtrURL;     // help center URL

    BOOL    bOfflineContent;    // pass FALSE
    BOOL    bUseHtmlHelp;       // pass FALSE
    UNICODE_STRING ustrChmFile;
    UNICODE_STRING ustrDetailsDatabase;

} APPHELPINFOCONTEXT, *PAPPHELPINFOCONTEXT;

#endif // WIN32A_MODE

void* SdbAlloc(size_t size);
void  SdbFree(void* pWhat);


// Base primitives.

HANDLE
SdbpOpenFile(
    LPCTSTR   szPath,
    PATH_TYPE eType
    );

#if defined(WIN32A_MODE) || defined(WIN32U_MODE)
    #define SdbpCloseFile(hFile) CloseHandle(hFile)
#else
    #define SdbpCloseFile(hFile) NtClose(hFile)
#endif

BOOL
SdbpCreateSearchPathPartsFromPath(
    IN  LPCTSTR           pszPath,
    OUT PSEARCHPATHPARTS* ppSearchPathParts
    );

BOOL
SdbpGetLongFileName(
    IN  LPCTSTR szFullPath,
    OUT LPTSTR  szLongFileName
    );

void
SdbpGetWinDir(
    LPTSTR pwszDir
    );

void
SdbpGetAppPatchDir(
    LPTSTR szAppPatchPath
    );

DWORD
SdbExpandEnvironmentStrings(
    IN  LPCTSTR lpSrc,
    OUT LPTSTR  lpDst,
    IN  DWORD   nSize);

BOOL
SdbpGUIDFromString(
    LPCTSTR lpszGuid,
    GUID* pGuid
    );


DWORD
SdbpGetStringRefLength(
    HSDB   hSDB,
    TAGREF trString
    );

LPCTSTR
SdbpGetStringRefPtr(
    IN HSDB hSDB,
    IN TAGREF trString
    );

BOOL
SdbpWriteBitsToFile(
    LPCTSTR szFile,
    PBYTE   pBuffer,
    DWORD   dwSize
    );

// DB access primitives

void
SdbCloseDatabaseRead(
    PDB pdb
    );

BOOL
SdbpOpenAndMapDB(
    PDB       pdb,
    LPCTSTR   pszPath,
    PATH_TYPE eType
    );

PDB
SdbpOpenDatabaseInMemory(
    LPVOID pImageDatabase,
    DWORD  dwSize
    );

BOOL
SdbpUnmapAndCloseDB(
    PDB pdb
    );

DWORD
SdbpGetFileSize(
    HANDLE hFile
    );

BOOL
SdbpReadMappedData(
    PDB   pdb,
    DWORD dwOffset,
    PVOID pBuffer,
    DWORD dwSize
    );

PVOID
SdbpGetMappedData(
    PDB   pdb,
    DWORD dwOffset
    );

TAGID
SdbpGetNextTagId(
    PDB   pdb,
    TAGID tiWhich
    );

DWORD
SdbpGetStandardDatabasePath(
    IN  DWORD  dwDatabaseType,
    IN  DWORD  dwFlags,                      // specify HID_DOS_PATHS for dos paths
    OUT LPTSTR pszDatabasePath,
    IN  DWORD  dwBufferSize    // in tchars
    );

LPTSTR
GetProcessHistory(
    IN  LPCTSTR pEnvironment,
    IN  LPTSTR  szDir,
    IN  LPTSTR  szName
    );


void
PrepareFormatForUnicode(
    PCH fmtUnicode,
    PCH format
    );

#ifndef WIN32A_MODE

#define PREPARE_FORMAT(pszFormat, Format) \
    {                                                                           \
        STACK_ALLOC(pszFormat, (strlen(Format) + 1) * sizeof(*Format));         \
        if (pszFormat != NULL) {                                                \
            PrepareFormatForUnicode(pszFormat, Format);                         \
        }                                                                       \
    }


#define CONVERT_FORMAT(pwsz, psz) \
    {                                                                           \
        ANSI_STRING    str;                                                     \
        UNICODE_STRING ustr;                                                    \
        ULONG          Length;                                                  \
        NTSTATUS       Status;                                                  \
                                                                                \
        RtlInitAnsiString(&str, (psz));                                         \
        Length = RtlAnsiStringToUnicodeSize(&str);                              \
        pwsz = (LPWSTR)_alloca(Length);                                         \
                                                                                \
        if (pwsz != NULL) {                                                     \
            ustr.MaximumLength = (USHORT)Length;                                \
            ustr.Buffer        = pwsz;                                          \
            Status = RtlAnsiStringToUnicodeString(&ustr, &str, FALSE);          \
            if (!NT_SUCCESS(Status)) {                                          \
                pwsz = NULL;                                                    \
            }                                                                   \
        }                                                                       \
    }

#else // WIN32A_MODE

#define PREPARE_FORMAT(pszFormat, Format) (pszFormat = (Format))

#define CONVERT_FORMAT(pwsz, psz) (pwsz = (psz))

#endif // WIN32A_MODE

#ifdef KERNEL_MODE

    #define SdbpGetWow64Flag() KEY_WOW64_64KEY

#else // !KERNEL_MODE

    DWORD SdbpGetWow64Flag(VOID);

#endif // KERNEL_MODE

// READ

DWORD
SdbpGetTagHeadSize(
    PDB   pdb,
    TAGID tiWhich
    );

TAGID
SdbpGetLibraryFile(
    IN  PDB     pdb,           // handle to the database channel
    IN  LPCTSTR szDllName       // the name of the FILE to find in LIBRARY (main db only)
    );

#define SdbpGetMainLibraryFile(hSDB, szFileName) \
    SdbpGetLibraryFile(((PSDBCONTEXT)(hSDB))->pdbMain, (szFileName))

STRINGREF SdbpReadStringRef(PDB pdb, TAGID tiWhich);

BOOL SdbpReadStringFromTable(PDB pdb, STRINGREF srData, LPTSTR szBuffer, DWORD dwBufferSize);

//
// Custom db stuff
//

VOID
SdbpCleanupUserSDBCache(
    IN PSDBCONTEXT pSdbContext
    );

HANDLE
SdbpCreateKeyPath(
    LPCWSTR pwszPath,
    BOOL    bMachine
    );


BOOL
SdbOpenNthLocalDatabase(
    IN  HSDB    hSDB,           // handle to the database channel
    IN  LPCTSTR pszItemName,    // the name of the exectutable, without the path or the layer name
    IN  LPDWORD pdwIndex,       // zero based index of the local DB to open
    IN  BOOL    bLayer
    );


BOOL
SdbpAddMatch(                   // internal function see sdbapi for more info
    IN OUT PSDBQUERYRESULT pQueryResult,
    IN PSDBCONTEXT         pSdbContext,
    IN PDB                 pdb,
    IN TAGID*              ptiExes,
    IN DWORD               dwNumExes,
    IN TAGID*              ptiLayers,
    IN DWORD               dwNumLayers,
    IN GUID*               pguidExeID,
    IN DWORD               dwExeFlags,
    IN OUT PMATCHMODE      pMode
);


BOOL
SdbOpenLocalDatabaseEx(
    IN  HSDB       hSDB,
    IN  LPCVOID    pDatabaseID,
    IN  DWORD      dwFLags,
    OUT PDB*  pPDB OPTIONAL,
    IN OUT LPDWORD pdwLocalDBMask OPTIONAL // local db mask for tagref
    );


BOOL
SdbCloseLocalDatabaseEx(
    IN HSDB hSDB,
    IN PDB  pdb,
    IN DWORD dwIndex
    );



BOOL 
SdbpIsMainPDB(
    IN HSDB hSDB,
    IN PDB  pdb
    );

BOOL
SdbpIsLocalTempPDB(
    IN HSDB hSDB,
    IN PDB  pdb
    );

DWORD
SdbpRetainLocalDBEntry(
    IN  HSDB hSDB,
    OUT PDB* ppPDB OPTIONAL // optional pointer to the pdb
    );

BOOL
SdbpCleanupLocalDatabaseSupport(
    IN HSDB hSDB
    );

BOOL
SdbpFindLocalDatabaseByGUID(
    IN HSDB     hSDB,
    IN GUID*    pGuidDB,
    IN BOOL     bExcludeLocalDB,
    OUT LPDWORD pdwIndex 
    );

BOOL
SdbpFindLocalDatabaseByPDB(
    IN  HSDB    hSDB,
    IN  PDB     pdb,
    IN  BOOL    bExcludeLocalDB, // exclude local temp db entry?
    OUT LPDWORD pdwIndex
    );

LPCTSTR
SdbpGetDatabaseDescriptionPtr(
    IN PDB pdb
    );

// HASH

PVOID
HashCreate(
    void
    );


void
HashFree(
    PVOID pStringHash
    );

DWORD
HashString(
    PSTRHASH pHash,
    LPCTSTR  szString
    );


DWORD
HashStringRef(
    PSTRHASH pHash,
    STRINGREF srString);

// BULK

BOOL
SdbpReadMappedData(
    PDB   pdb,
    DWORD dwOffset,
    PVOID pBuffer,
    DWORD dwSize
    );

BOOL
SdbpCheckForMatch(
    HSDB             pDBContext,
    PDB              pdb,
    TAGID            tiExe,
    PSEARCHDBCONTEXT pContext,
    PMATCHMODE       pMMode,
    GUID*            pGUID,
    DWORD*           pdwFlags
    );

BOOL
bGetExeID(
    PDB   pdb,
    TAGID tiExe,
    GUID* pGuid
    );

BOOL
SdbpBinarySearchUnique(
    PINDEX_RECORD pRecords,
    DWORD         nRecords,
    ULONGLONG     ullKey,
    DWORD*        pdwIndex
    );

BOOL
SdbpBinarySearchFirst(
    PINDEX_RECORD pRecords,
    DWORD         nRecords,
    ULONGLONG     ullKey,
    DWORD*        pdwIndex
    );

char*
SdbpKeyToAnsiString(
    ULONGLONG ullKey,
    char*     szString
    );

// ATTRIBUTES

BOOL
SafeNCat(
    LPTSTR  lpszDest,
    int     nSize,
    LPCTSTR lpszSrc,
    int     nSizeAppend
    );

BOOL
SdbpSanitizeXML(
    LPTSTR  pchOut,
    int     nSize,
    LPCTSTR lpszXML
    );


////////////////////////////////////////////////////////////////////////////
//
//  Image File Data
//  Helpful structure that is used in functions dealing with
//  image properties retrieval
//

typedef struct tagIMAGEFILEDATA {
    HANDLE    hFile;        // we do not manage this

    DWORD     dwFlags;      // flags that tell us not to mess with the file's handle

    HANDLE    hSection;     // section of the fileview
    PVOID     pBase;        // base ptr
    SIZE_T    ViewSize;     // size of the view
    ULONGLONG FileSize;     // size of the file

} IMAGEFILEDATA, *PIMAGEFILEDATA;

#define IMAGEFILEDATA_HANDLEVALID 0x00000001
#define IMAGEFILEDATA_NOFILECLOSE 0x00000002
#define IMAGEFILEDATA_PBASEVALID  0x00000004
#define IMAGEFILEDATA_NOFILEMAP   0x00000008

//
// FILEINFORMATION structure used in file attribute cache, see attributes.c
//
//

typedef struct tagFILEINFORMATION {

    //
    // "Signature" to insure that it's legitimate memory when
    // operating of file attributes
    //
    DWORD  dwMagic;

    HANDLE hFile;  // we store this handle
    LPVOID pImageBase;
    DWORD  dwImageSize;

    //
    // pointer to the next item in cache
    //

    struct tagFILEINFORMATION* pNext; // pointer to the next item in cache

    LPTSTR  FilePath;        // file name with path (allocated by us with this struct)
    DWORD   dwFlags;         // flags

    PVOID   pVersionInfo;    // version info ptr, retained (allocated by us)
    LPTSTR  pDescription16;  // string, points to the buffer for 16-bit description
    LPTSTR  pModuleName16;   // string, points to the buffer for 16-bit module name

    ATTRINFO Attributes[];

} FILEINFO, *PFILEINFO;


//
// This structure is used to recover directory-related attributes of a file
// we used to have time here as well... but not anymore
// only low part of the file size is of any significance
//

typedef struct tagFILEDIRECTORYATTRIBUTES {

    DWORD  dwFlags; // flags that show which attributes are valid

    DWORD  dwFileSizeHigh;
    DWORD  dwFileSizeLow;

} FILEDIRECTORYATTRIBUTES, *PFILEDIRECTORYATTRIBUTES;


//
// Attribute names. Use SdbTagToString if you want to get the name of
// a tag ID.
//
typedef struct _TAG_INFO {
    TAG         tWhich;
    TCHAR*      szName;
} TAG_INFO, *PTAG_INFO;

typedef struct _MOD_TYPE_STRINGS {
    DWORD      dwModuleType;
    LPTSTR     szModuleType;
}   MOD_TYPE_STRINGS;

typedef struct tagLANGANDCODEPAGE {
    WORD wLanguage;
    WORD wCodePage;
} LANGANDCODEPAGE, *PLANGANDCODEPAGE;


BOOL
SdbpGetHeaderAttributes(
    IN  PSDBCONTEXT pContext,
    OUT PFILEINFO   pFileInfo
    );

LPTSTR
SdbpQueryVersionString(
    HSDB             hSDB,
    PVOID            pVersionData,
    PLANGANDCODEPAGE pTranslations,
    DWORD            dwCount,
    LPCTSTR          szString
    );

BOOL
SdbpGetFileChecksum(
    PULONG         pChecksum,
    PIMAGEFILEDATA pImageData
    );

BOOL
SdbpGetModulePECheckSum(
    PULONG         pChecksum,
    LPDWORD        pdwLinkerVersion,
    LPDWORD        pdwLinkDate,
    PIMAGEFILEDATA pImageData
    );

BOOL
SdbpCheckVersion(
    ULONGLONG qwDBFileVer,
    ULONGLONG qwBinFileVer
    );

BOOL
SdbpCheckUptoVersion(
    ULONGLONG qwDBFileVer,
    ULONGLONG qwBinFileVer
    );


#ifdef KERNEL_MODE

//
// Special versions of functions for kernel-mode implementation (in ntkmode.c).
//
BOOL
SdbpGetFileDirectoryAttributesNT(
    PFILEINFO      pFileInfo,
    PIMAGEFILEDATA pImageData
    );

BOOL
SdbpQueryFileDirectoryAttributesNT(
    PIMAGEFILEDATA           pImageData,
    PFILEDIRECTORYATTRIBUTES pFileDirectoryAttributes
    );

#else

BOOL
SdbpGetFileDirectoryAttributes(
    OUT PFILEINFO pFileInfo
    );

BOOL
SdbpGetVersionAttributes(
    IN  PSDBCONTEXT pContext,
    OUT PFILEINFO   pFileInfo
    );

#endif // KERNEL_MODE


int
TagToIndex(
    IN  TAG tag                 // the tag
    );

BOOL
SdbpSetAttribute(
    OUT PFILEINFO pFileInfo,    // pointer to the FILEINFO structure.
    IN  TAG       AttrID,       // Attribute ID (tag, as in TAG_SIZE
    IN  PVOID     pValue        // value
    );

void
SdbpQueryStringVersionInformation(
    IN  PSDBCONTEXT pContext,
    IN  PFILEINFO   pFileInfo,
    OUT LPVOID      pVersionInfo
    );

VOID
SdbpQueryBinVersionInformation(
    IN  PSDBCONTEXT       pContext,
    IN  PFILEINFO         pFileInfo,
    OUT VS_FIXEDFILEINFO* pFixedInfo
    );

BOOL
SdbpGetAttribute(
    IN  PSDBCONTEXT pContext,
    OUT PFILEINFO   pFileInfo,
    IN  TAG         AttrID
    );

BOOL
SdbpGetImageNTHeader(
    OUT PIMAGE_NT_HEADERS* ppHeader,
    IN  PIMAGEFILEDATA     pImageData
    );

BOOL
SdbpGetVersionAttributesNT(
    PSDBCONTEXT    pContext,
    PFILEINFO      pFileInfo,
    PIMAGEFILEDATA pImageData
    );

VOID
SdbpCleanupAttributeMgr(
    PSDBCONTEXT pContext
    );

BOOL
SdbpCheckAttribute(
    HSDB  hSDB,
    PVOID pFileData,
    TAG   tAttrID,
    PVOID pAttribute
    );

BOOL
SdbpCheckAllAttributes(
    HSDB hSDB,
    PDB pdb,
    TAGID tiMatch,
    PVOID pFileData);



// READ FUNCTIONS

BOOL SdbpReadTagData(PDB pdb, TAGID tiWhich, PVOID pBuffer, DWORD dwBufferSize);

// WRITE

BOOL
SdbpWriteTagData(
    PDB         pdb,
    TAG         tTag,
    const PVOID pBuffer,
    DWORD       dwSize
    );


// STRING FUNCTIONS

WCHAR* SdbpGetMappedStringFromTable(PDB pdb, STRINGREF srData);

STRINGREF SdbpAddStringToTable(PDB pdb, LPCTSTR szData);

// INDEX FUNCTIONS

PINDEX_RECORD
SdbpGetIndex(
    PDB    pdb,
    TAGID  tiIndex,
    DWORD* pdwNumRecs
    );

void
SdbpScanIndexes(
    PDB pdb
    );

TAGID
SdbpGetFirstIndexedRecord(
    PDB        pdb,
    TAGID      tiIndex,
    ULONGLONG  ullKey,
    FIND_INFO* pFindInfo
    );

TAGID
SdbpGetNextIndexedRecord(
    PDB        pdb,
    TAGID      tiIndex,
    FIND_INFO* pFindInfo
    );

TAGID
SdbpFindFirstIndexedWildCardTag(
    PDB          pdb,
    TAG          tWhich,
    TAG          tKey,
    LPCTSTR      szName,
    FIND_INFO*   pFindInfo
    );

TAGID
SdbpFindNextIndexedWildCardTag(
    PDB        pdb,
    FIND_INFO* pFindInfo
    );

BOOL
SdbpSortIndex(
    PDB   pdb,
    TAGID tiIndexBits
    );

ULONGLONG
SdbpTagToKey(
    PDB   pdb,
    TAGID tiTag
    );


// FINDTAG

TAGID
tiFindFirstNamedTag(
    PDB          pdb,
    TAGID        tiParent,
    TAG          tToFind,
    TAG          tName,
    LPCTSTR      pszName
    );

TAGID
SdbpFindNextNamedTag(
    PDB          pdb,
    TAGID        tiParent,
    TAGID        tiPrev,
    TAG          tName,
    LPCTSTR      pszName
    );

TAGID
SdbpFindMatchingName(
    PDB        pdb,
    TAGID      tiStart,
    FIND_INFO* pFindInfo
    );

TAGID
SdbpFindMatchingDWORD(
    PDB        pdb,
    TAGID      tiStart,
    FIND_INFO* pFindInfo
    );

TAGID
SdbpFindMatchingGUID(
    IN  PDB        pdb,         // DB to use
    IN  TAGID      tiStart,     // the tag where to start from
    IN  FIND_INFO* pFindInfo    // pointer to the search context structure
    );

BOOL bTagRefToTagID(HSDB, TAGREF trWhich, PDB* ppdb, TAGID* ptiWhich);

DWORD SdbpGetTagRefDataSize(HSDB, TAGREF trWhich);

BOOL SdbpReadBinaryTagRef(HSDB, TAGREF trWhich, PBYTE pBuffer, DWORD dwBufferSize);


//
// Debug functions (pipe-related)
//
HANDLE
SdbpOpenDebugPipe(
    VOID
    );

BOOL
SdbpCloseDebugPipe(
    IN HANDLE hPipe
    );

BOOL
SdbpWriteDebugPipe(
    HSDB    hSDB,
    LPCSTR  pszBuffer
    );


//
// APPCOMPAT_EXE_DATA
//
//

#define MAX_SHIM_ENGINE_NAME    32

typedef struct tagAPPCOMPAT_EXE_DATA {
    //
    // WARNING: never ever change the position of 'szShimEngine'.
    //
    // It MUST be the first element of this structure
    //
    // this structure is referenced during installation of
    // an appcompat backend (base\ntdll)

    WCHAR       szShimEngine[MAX_SHIM_ENGINE_NAME];

    DWORD       dwFlags;        // flags (if any)
    DWORD       cbSize;         // struct size(allocation size)
    DWORD       dwMagic;        // magic (signature)

    TAGREF      atrExes[SDB_MAX_EXES];
    TAGREF      atrLayers[SDB_MAX_LAYERS];
    TAGREF      trAppHelp;      // if there's an apphelp to display

    DWORD       dwDatabaseMap;    // count local dbs
    GUID        rgGuidDB[MAX_SDBS]; // local dbs

} APPCOMPAT_EXE_DATA, *PAPPCOMPAT_EXE_DATA;



PVOID SdbpGetMappedTagData(PDB pdb, TAGID tiWhich);
BOOL  bWStrEqual(const WCHAR* szOne, const WCHAR* szTwo);
BOOL bFlushBufferedData(PDB pdb);
void vReleaseBufferedData(PDB pdb);



BOOL SdbpPatternMatchAnsi(LPCSTR pszPattern, LPCSTR pszTestString);
BOOL SdbpPatternMatch(LPCTSTR pszPattern, LPCTSTR pszTestString);

//
// Registry access functions
//
//

typedef WCHAR* PWSZ;

void
SdbpQueryAppCompatFlagsByExeID(
    LPCWSTR         pwszKeyPath,
    PUNICODE_STRING pustrExeID,
    LPDWORD         lpdwFlags
    );

#ifdef _DEBUG_SPEW

typedef struct tagDBGLEVELINFO {
    
    LPCSTR  szStrTag;
    INT     iLevel;

} DBGLEVELINFO;

#define DEBUG_LEVELS    4

//
// Shim Debug Level variable
// In it's initial state -- we have -1 here,
// further, upon the very first call to ShimDbgPrint, we examine the
// environment variable -- and then we set it up appropriately
//
#define SHIM_DEBUG_UNINITIALIZED 0x0C0FFEE


#endif // _DEBUG_SPEW


/*++

    bWStrEqual

    Currently a wrapper for _wcsicmp. Potentially will use a faster
    routine that just checks equality, rather than also trying to get
    less than/greater than.

--*/
#define bWStrEqual(s1, s2) (0 == _wcsicmp((s1), (s2)))

#define ISEQUALSTRING(s1, s2) (0 == _tcsicmp((s1), (s2)))


/*++

    dwGetTagDataOffset

    Returns the total size of the tag: the tag header plus the tag data.
    Used for skipping past a tag and going to the next tag in the file.

--*/


//
// HACK ALERT BUGBUG
// remove this when the code to write aligned db has propagated
// throught
//

#define GETTAGDATASIZEALIGNED(pdb, tiWhich) \
    ((pdb)->bUnalignedRead ? (SdbGetTagDataSize(pdb, tiWhich)) : \
                             ((SdbGetTagDataSize(pdb, tiWhich) + 1) & (~1)))

#if 0 // this is good code that we should but back at some point

#define GETTAGDATASIZEALIGNED(pdb, tiWhich) \
    ((SdbGetTagDataSize(pdb, tiWhich) + 1) & (~1))

#endif // End good code

#define GETTAGDATAOFFSET(pdb, tiWhich) \
    (GETTAGDATASIZEALIGNED(pdb, tiWhich) + SdbpGetTagHeadSize(pdb, tiWhich))



#ifndef WIN32A_MODE

///////////////////////////////////////////////////////////////////////////////////
//
//  UNICODE - specific macros and definitions
//

#define IS_MEMORY_EQUAL(p1, p2, Size) RtlEqualMemory(p1, p2, Size)

#define CONVERT_STRINGPTR(pdb, pwszSrc, tagType, srWhich) ((WCHAR*)pwszSrc)

#define READ_STRING(pdb, tiWhich, pwszBuffer, dwBufferSize) \
    (SdbpReadTagData((pdb), (tiWhich), (pwszBuffer), (dwBufferSize) * sizeof(WCHAR)))

//
// The macro below is a substitution for a function that exists in non-unicode code
//
#define SdbpDoesFileExists(FilePath) RtlDoesFileExists_U(FullPath)

NTSTATUS
SdbpGUIDToUnicodeString(
    IN  GUID* pGuid,
    OUT PUNICODE_STRING pUnicodeString
    );

VOID
SdbpFreeUnicodeString(
    PUNICODE_STRING pUnicodeString
    );

#define GUID_TO_UNICODE_STRING(pGuid, pUnicodeString) \
    SdbpGUIDToUnicodeString(pGuid, pUnicodeString)

#define FREE_GUID_STRING(pUnicodeString) \
    SdbpFreeUnicodeString(pUnicodeString)

#ifdef KERNEL_MODE

NTSTATUS
SdbpUpcaseUnicodeStringToMultiByteN(
    OUT LPSTR   lpszDest,  // dest buffer
    IN  DWORD   dwSize,    // size in characters
    IN  LPCWSTR lpszSrc    // source
    );

BOOL SdbpCreateUnicodeString(
    PUNICODE_STRING pStr,
    LPCWSTR         lpwsz
    );


BOOL
SdbpDoesFileExists_U(
    LPCWSTR pwszPath
    );


#define DOES_FILE_EXISTS_U(pwszPath) \
    SdbpDoesFileExists_U(pwszPath)

#define UPCASE_UNICODETOMULTIBYTEN(szDest, dwDestSize, szSrc) \
    SdbpUpcaseUnicodeStringToMultiByteN(szDest, dwDestSize, szSrc)




#else // not KERNEL_MODE code below

#define DOES_FILE_EXISTS_U(pwszPath) \
    RtlDoesFileExists_U(pwszPath)

#define UPCASE_UNICODETOMULTIBYTEN(szDest, dwDestSize, szSrc)       \
    RtlUpcaseUnicodeToMultiByteN((szDest),                          \
                                 (dwDestSize) * sizeof(*(szDest)),  \
                                 NULL,                              \
                                 (WCHAR*)(szSrc),                   \
                                 (wcslen((szSrc)) + 1) * sizeof(WCHAR))


#define FREE_TEMP_STRINGTABLE(pdb) \
    RtlFreeUnicodeString(&pdb->ustrTempStringtable)

#define COPY_TEMP_STRINGTABLE(pdb, pszTempStringtable) \
    RtlCreateUnicodeString(&pdb->ustrTempStringtable, pszTempStringtable)


void
SdbpGetCurrentTime(
    LPSYSTEMTIME lpTime
    );

BOOL
SdbpBuildUserKeyPath(
    IN  LPCWSTR         pwszPath,
    OUT PUNICODE_STRING puserKeyPath
    );


#endif // KERNEL_MODE

//
// Convert unicode char to upper case
//
#define UPCASE_CHAR(ch) RtlUpcaseUnicodeChar((ch))

//
// String cache which does not exist in unicode
//

#define CLEANUP_STRING_CACHE_READ(pdb)

#define SDB_BREAK_POINT() DbgBreakPoint()


#else // WIN32A_MODE

#define IS_MEMORY_EQUAL(p1, p2, Size) (memcmp((p1), (p2), (Size)) == 0)


//
// From Win32Base.c
//

LPSTR
SdbpFastUnicodeToAnsi(
    IN  PDB      pdb,
    IN  LPCWSTR  pwszSrc,
    IN  TAG_TYPE ttTag,
    IN  DWORD    dwRef
    );

BOOL
SdbpReadStringToAnsi(
    PDB    pdb,
    TAGID  tiWhich,
    LPSTR  pszBuffer,
    DWORD  dwBufferSize);

#define CONVERT_STRINGPTR(pdb, pwszSrc, tagType, srWhich) \
    SdbpFastUnicodeToAnsi(pdb, (WCHAR*)pwszSrc, tagType, (DWORD)srWhich)

#define READ_STRING(pdb, tiWhich, pwszBuffer, dwBufferSize) \
    (SdbpReadStringToAnsi((pdb), (tiWhich), (pwszBuffer), (dwBufferSize)))

BOOL
SdbpDoesFileExists(
    LPCTSTR pszFilePath
    );

#define UPCASE_CHAR(ch) _totupper((ch))

#define UPCASE_UNICODETOMULTIBYTEN(szDest, dwDestSize, szSrc) \
    (_tcsncpy((szDest), (szSrc), (dwDestSize)), \
     (szDest)[(dwDestSize) - 1] = 0,            \
     _tcsupr((szDest)),                         \
     STATUS_SUCCESS)

#define FREE_LOCALDB_NAME(pSDBContext) \
    {                                               \
        if (NULL != pSDBContext->pszPDBLocal) {     \
            SdbFree(pSDBContext->pszPDBLocal);      \
            pSDBContext->pszPDBLocal = NULL;        \
        }                                           \
    }

#define COPY_LOCALDB_NAME(pSDBContext, pszLocalDatabase) \
    ((pSDBContext->pszPDBLocal = SdbpDuplicateString(pszLocalDatabase)),   \
     (NULL != pSDBContext->pszPDBLocal))

#define CLEANUP_STRING_CACHE_READ(pdb) \
    {                                           \
        if (pdb->pHashStringTable != NULL) {    \
            HashFree(pdb->pHashStringTable);    \
            pdb->pHashStringTable = NULL;       \
        }                                       \
                                                \
        if (pdb->pHashStringBody != NULL) {     \
            HashFree(pdb->pHashStringBody);     \
            pdb->pHashStringBody = NULL;        \
        }                                       \
    }

#define FREE_TEMP_STRINGTABLE(pdb) \
    if (pdb->pszTempStringtable) { \
        SdbFree(pdb->pszTempStringtable); \
        pdb->pszTempStringtable = NULL;   \
    }

#define COPY_TEMP_STRINGTABLE(pdb, pszTempStringtable) \
    ((pdb->pszTempStringtable = SdbpDuplicateString(pszTempStringtable)), \
     (NULL != pdb->pszTempStringtable))

#define SDB_BREAK_POINT() DebugBreak()

#define GUID_TO_STRING SdbGUIDToString

#endif // WIN32A_MODE




BOOL
SdbpMapFile(
    HANDLE hFile,   // handle to the open file (this is done previously)
    PIMAGEFILEDATA pImageData
);

BOOL
SdbpUnmapFile(
    PIMAGEFILEDATA pImageData
);

BOOL
SdbpOpenAndMapFile(
    IN  LPCTSTR szPath,
    OUT PIMAGEFILEDATA pImageData,
    IN  PATH_TYPE ePathType
    );

BOOL
SdbpUnmapAndCloseFile(
    PIMAGEFILEDATA pImageData
    );

NTSTATUS
SdbpGetEnvVar(
    IN  LPCTSTR pEnvironment,
    IN  LPCTSTR pszVariableName,
    OUT LPTSTR  pszVariableValue,
    OUT LPDWORD pdwBufferSize);


LPTSTR HashAddStringByRef(PSTRHASH pHash, LPCTSTR szString, STRINGREF srString);
LPTSTR HashFindStringByRef(PSTRHASH pHash, STRINGREF srString);

/////////////////////////////////////////////////////////////////////////////////
//
// Private versions of functions to check for resources...
// found in ntver.c
//

BOOL
SdbpVerQueryValue(
    const LPVOID    pb,
    LPVOID          lpSubBlockX,    // can be only unicode
    LPVOID*         lplpBuffer,
    PUINT           puLen
    );

BOOL
SdbpGetFileVersionInformation(
    IN  PIMAGEFILEDATA     pImageData,        // we assume that the file has been mapped in for other purposes
    OUT LPVOID*            ppVersionInfo,     // receives pointer to the (allocated) version resource
    OUT VS_FIXEDFILEINFO** ppFixedVersionInfo // receives pointer to fixed version info
    );

BOOL
SdbpGetModuleType(                      // retrieve module type
    OUT LPDWORD lpdwModuleType,         // OUT - module type
    IN  PIMAGEFILEDATA pImageData       // IN  - image data
    );


BOOL
SdbpCreateSearchDBContext(
    PSEARCHDBCONTEXT pContext,
    LPCTSTR          szPath,
    LPCTSTR          szModuleName,
    LPCTSTR          pEnvironment
    );

DWORD
SdbpSearchDB(
    IN  HSDB             hSDB,
    IN  PDB              pdb,           // pdb to search in
    IN  TAG              tiSearchTag,   // OPTIONAL - target tag (TAG_EXE or TAG_APPHELP_EXE)
    IN  PSEARCHDBCONTEXT pContext,
    OUT TAGID*           ptiExes,       // caller needs to provide array of size SDB_MAX_EXES
    OUT GUID*            pLastExeGUID,
    OUT DWORD*           pLastExeFlags,
    IN OUT PMATCHMODE    pMatchMode     // reason why we stopped scanning
    );

void
SdbpReleaseSearchDBContext(
    PSEARCHDBCONTEXT pContext
    );



//
// this macro is used to retrieve ulonglong from the index
//
//

#if defined(_WIN64)

#define READ_INDEX_KEY(pIndexRecord, iIndex, pullKey) \
    RtlMoveMemory((pullKey), &pIndexRecord[iIndex].ullKey, sizeof(*(pullKey)))
#else

#define READ_INDEX_KEY(pIndexRecord, iIndex, pullKey) \
    *pullKey = pIndexRecord[iIndex].ullKey

#endif

#define READ_INDEX_KEY_VAL(pIndexRecord, iIndex, pullKey) \
    ( READ_INDEX_KEY(pIndexRecord, iIndex, pullKey), *(pullKey) )

//
// this macro is used to allocate cheap pointer on the stack
//

#if DBG | defined(KERNEL_MODE) | defined(_WIN64)

#define STACK_ALLOC(ptrVar, nSize) \
    {                                     \
        PVOID* ppVar = (PVOID*)&(ptrVar); \
        *ppVar = SdbAlloc(nSize);         \
    }

#define STACK_FREE(pMemory)  \
    SdbFree(pMemory)

#else // hack-routine to reset the stack after an overflow

//
// this routine is a replica of a _resetstkoflw which lives in the crt
// crtw32\heap\resetstk.c
//

VOID
SdbResetStackOverflow(
    VOID
    );


//
// HACK ALERT
//
//  The code below works because when we hit a stack overflow - we catch the exception
//  and subsequently fix the stack up using a crt routine
//

#define STACK_ALLOC(ptrVar, nSize) \
    __try {                                                                 \
        PVOID* ppVar = (PVOID*)&(ptrVar);                                   \
        *ppVar = _alloca(nSize);                                            \
    } __except (GetExceptionCode() == EXCEPTION_STACK_OVERFLOW ?            \
                EXCEPTION_EXECUTE_HANDLER:EXCEPTION_CONTINUE_SEARCH) {      \
        (ptrVar) = NULL;                                                    \
    }                                                                       \
                                                                            \
    if (ptrVar == NULL) {                                                   \
        SdbResetStackOverflow();                                                    \
    }


#define STACK_FREE(pMemory)

#endif

LPTSTR
SdbpDuplicateString(
    LPCTSTR pszSrc);



#define FDA_FILESIZE 0x00000001


BOOL
SdbpQueryFileDirectoryAttributes(
    LPCTSTR                  FilePath,
    PFILEDIRECTORYATTRIBUTES pFileDirectoryAttributes
    );

//
// Magic fileinfo signature
//
#define FILEINFO_MAGIC 0xA4C0FFEE


WCHAR*
DuplicateUnicodeString(
    IN PUNICODE_STRING pStr,
    IN PUSHORT         pLength  OPTIONAL
    );  // pLength is an allocated length

LPWSTR
StringToUnicodeString(
    IN  LPCSTR pszSrc
    );


//
// defined for uni/non-uni separately
//

BOOL
SdbpGet16BitDescription(
    LPTSTR* ppszDescription,
    PIMAGEFILEDATA pImageData
    );

BOOL
SdbpGet16BitModuleName(
    LPTSTR* ppszModuleName,
    PIMAGEFILEDATA pImageData
    );

//
// in attributes.c
//

BOOL
SdbpQuery16BitDescription(
    LPSTR szBuffer,      // min length -- 256 chars !
    PIMAGEFILEDATA pImageData
    );


BOOL
SdbpQuery16BitModuleName(
    LPSTR szBuffer,      // min length -- 256 chars !
    PIMAGEFILEDATA pImageData
    );

LPCTSTR
SdbpModuleTypeToString(
    DWORD dwModuleType
);

//
// in index.c
//

BOOL
SdbpPatternMatch(
    IN  LPCTSTR pszPattern,
    IN  LPCTSTR pszTestString);

BOOL
SdbpPatternMatchAnsi(
    IN  LPCSTR pszPattern,
    IN  LPCSTR pszTestString);

//
// defined for uni/non-uni separately
//

//////////////////////////////////////////////////////////////////////////////////
//
//  GetFileInfo
//  1. performs check on a file to determine if it exists
//  2. if it does exist -- it leaves a cache entry (creates a fileinfo struct)
//     if it does NOT exist -- we leave no mention of it on record
//  if bNoCache == TRUE the file is not entered into the cache
//  caller must free the stucture using FreeFileData
//
//  Parameters:
//      tiMatch        - IN - match id from the database, used temporary
//      FilePath    -    IN - file path that we are to check
//      bNoCache    -    IN - whether we should enter the file into cache
//
//  returns:
//      Pointer to internal data structure that should be used in
//      subsequent calls to SdbpCheckAttribute or NULL if file was not available
//

PVOID
SdbGetFileInfo(
    IN  HSDB    hSDB,
    IN  LPCTSTR pszFilePath,
    IN  HANDLE  hFile OPTIONAL,
    IN  LPVOID  pImageBase OPTIONAL,
    IN  DWORD   dwImageSize OPTIONAL,
    IN  BOOL    bNoCache
    );


//
// in attributes.c
//

PFILEINFO
CreateFileInfo(
    IN  PSDBCONTEXT pContext,
    IN  LPCTSTR     FullPath,
    IN  DWORD       dwLength OPTIONAL,  // length (in characters) of FullPath string
    IN  HANDLE      hFile OPTIONAL,   // file handle
    IN  LPVOID      pImageBase OPTIONAL,
    IN  DWORD       dwImageSize OPTIONAL,
    IN  BOOL        bNoCache
    );

PFILEINFO
FindFileInfo(
    PSDBCONTEXT pContext,
    LPCTSTR     FilePath
    );


// defined unicode and non-unicode

INT GetShimDbgLevel(VOID);


//
// from index.c
//

STRINGREF HashFindString(PSTRHASH pHash, LPCTSTR szString);

BOOL HashAddString(PSTRHASH pHash, LPCTSTR szString, STRINGREF srString);

BOOL
SdbpIsPathOnCdRom(
    LPCTSTR pszPath
    );

BOOL
SdbpBuildSignature(
    LPCTSTR pszPath,
    LPTSTR  pszPathSigned
    );

//
// in ntbase/win32base
//

DWORD
SdbpGetProcessorArchitecture(
    VOID
    );

VOID
SdbpGetOSSKU(
    LPDWORD lpdwSKU,
    LPDWORD lpdwSP
    );

//
// in Attributes.c
//

BOOL
SdbpCheckRuntimePlatform(
    IN PSDBCONTEXT pContext,   // pointer to the database channel
    IN LPCTSTR     pszMatchingFile,
    IN DWORD       dwPlatformDB
    );

//
// convenient define
//

#ifndef OFFSETOF
#define OFFSETOF offsetof
#endif


/* // Use this pragma below in conjunction with the commented block
   // in the beginning of the file to compile with warning level 4

#pragma warning(pop)

*/
#endif // __SDBP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\win32base.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        win32base.c

    Abstract:

        This module implements low level primitives that are win32 compatible.

    Author:

        clupu     created     10/25/2000

    Revision History:

--*/

#include "sdbp.h"
#include <time.h>
#include <shlwapi.h>

// Define this for bounds-checked detection of leaks.

// #define BOUNDS_CHECKER_DETECTION

//
// Memory functions
//

void*
SdbAlloc(
    IN  size_t size             // size in bytes to allocate
    )
/*++
    Return: The pointer allocated.

    Desc:   Just a wrapper for allocation -- perhaps useful if we move this
            code to a non-NTDLL location and need to call differently.
--*/
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
}

void
SdbFree(
    IN  void* pWhat             // ptr allocated with SdbAlloc that should be freed.
    )
/*++
    Return: The pointer allocated.

    Desc:   Just a wrapper for deallocation -- perhaps useful if we move this
            code to a non-NTDLL location and need to call differently.
--*/
{
    HeapFree(GetProcessHeap(), 0, pWhat);
}

HANDLE
SdbpOpenFile(
    IN  LPCTSTR   szPath,       // full path of file to open
    IN  PATH_TYPE eType         // must be always DOS_PATH
    )
/*++
    Return: A handle to the opened file or INVALID_HANDLE_VALUE on failure.

    Desc:   Just a wrapper for opening an existing file for READ.
--*/
{
    HANDLE hFile;

    assert(eType == DOS_PATH);

    hFile = CreateFile(szPath,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);


    if (hFile == INVALID_HANDLE_VALUE) {
        DBGPRINT((sdlInfo, "SdbpOpenFile", "CreateFileW failed 0x%x.\n", GetLastError()));
    }

    return hFile;
}


void
SdbpQueryAppCompatFlagsForExeID(
    IN  HKEY    hkeyRoot,       // the root key (HKLM or HKCU)
    IN  LPCTSTR pwszExeID,      // the exe ID in string format
    OUT LPDWORD lpdwFlags       // this will contain the flags from the registry.
    )
/*++
    Return: void.

    Desc:  BUGBUG
           Query registry for compatibility flags. Exe ID is a GUID in string format.

--*/
{
    HKEY  hkey;
    DWORD type, cbSize, dwFlags = 0;
    LONG  lRes;

    *lpdwFlags = 0;

    lRes = RegOpenKey(hkeyRoot, APPCOMPAT_KEY_PATH, &hkey);

    if (lRes != ERROR_SUCCESS) {
        //
        // No key for this ExeID. No big deal.
        //
        return;
    }

    cbSize = sizeof(DWORD);

    lRes = RegQueryValueEx(hkey, pwszExeID, NULL, &type, (LPBYTE)&dwFlags, &cbSize);

    if (lRes != ERROR_SUCCESS || type != REG_DWORD) {
        goto cleanup;
    }

    *lpdwFlags = dwFlags;

cleanup:

    RegCloseKey(hkey);
}

BOOL
SdbGetEntryFlags(
    IN  GUID*   pGuid,          // the EXE's ID
    OUT LPDWORD lpdwFlags       // will receive the flags for this EXE
    )
/*++
    Return: void.

    Desc:   BUGBUG: comment.
--*/
{
    TCHAR szExeID[128];
    DWORD dwFlagsMachine = 0, dwFlagsUser = 0;


    if (!SdbGUIDToString(pGuid, szExeID)) {
        DBGPRINT((sdlError, "SdbGetEntryFlags",
                  "Failed to convert guid to string\n"));
        return FALSE;
    }

    //
    // Look in both the local machine and per user keys. Then combine the
    // flags.
    //
    SdbpQueryAppCompatFlagsForExeID(HKEY_LOCAL_MACHINE, szExeID, &dwFlagsMachine);

    SdbpQueryAppCompatFlagsForExeID(HKEY_CURRENT_USER,  szExeID, &dwFlagsUser);

    *lpdwFlags = (dwFlagsMachine | dwFlagsUser);

    return TRUE;
}

BOOL
SdbSetEntryFlags(
    IN  GUID* pGuid,            // the EXE's ID
    IN  DWORD dwFlags           // the registry flags for this EXE
    )
/*++
    Return: void.

    Desc:   BUGBUG: comment.
--*/
{
    TCHAR szExeID[128];
    DWORD dwExeFlags;
    HKEY  hkey;
    LONG  lRes;

    lRes = RegCreateKey(HKEY_CURRENT_USER, APPCOMPAT_KEY_PATH, &hkey);

    if (lRes != ERROR_SUCCESS) {
        DBGPRINT((sdlError,
                  "SdbSetEntryFlags",
                  "Failed 0x%x to open/create key in HKCU\n",
                  GetLastError()));
        return FALSE;
    }


    if (!SdbGUIDToString(pGuid, szExeID)) {
        DBGPRINT((sdlError, "SdbSetEntryFlags",
                  "Failed to convert GUID to string\n"));
        RegCloseKey(hkey);
        return FALSE;
    }


    dwExeFlags = dwFlags;

    lRes = RegSetValueEx(hkey,
                         szExeID,
                         0,
                         REG_DWORD,
                         (const BYTE*)&dwExeFlags,
                         sizeof(DWORD));

    if (lRes != ERROR_SUCCESS) {
        DBGPRINT((sdlError,
                  "SdbSetEntryFlags",
                  "Failed 0x%x to set the flags for exe ID.\n",
                  GetLastError()));
        return FALSE;
    }

    return TRUE;
}


VOID
SdbpCleanupUserSDBCache(
    IN PSDBCONTEXT pSdbContext
    )
{
    ;
}

BOOL
SDBAPI
SdbGetNthUserSdb(
    IN  HSDB    hSDB,
    IN  LPCTSTR szItemName,     // file name (foo.exe) or layer name
    IN  BOOL    bLayer,         // true if layer
    IN OUT LPDWORD pdwIndex,    // 0-based index
    OUT GUID*   pGuidDB         // guid of a database to search
    )
{
    TCHAR szFullKey[512];
    LONG  lResult;
    HKEY  hKey = NULL;
    DWORD dwNameSize = 0;
    DWORD dwDataType;
    BOOL  bRet = FALSE;
    TCHAR szSdbName[MAX_PATH];
    DWORD dwIndex = *pdwIndex;
    LPTSTR pDot;

    if (szItemName == NULL || pGuidDB == NULL || pdwIndex == NULL) {
        DBGPRINT((sdlError, "SdbGetNthUserSdb",
                  "NULL parameter passed for szExeName or pGuidDB or pdwIndex.\n"));
        goto out;
    }

    if (bLayer) {
        _stprintf(szFullKey, TEXT("%s\\Layers\\%s"), APPCOMPAT_KEY_PATH_CUSTOM, szItemName);
    } else {
        _stprintf(szFullKey, TEXT("%s\\%s"), APPCOMPAT_KEY_PATH_CUSTOM, szItemName);
    }

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           szFullKey,
                           0,
                           KEY_READ,
                           &hKey);
    if (lResult != ERROR_SUCCESS) {
        DBGPRINT((sdlInfo, "SdbGetNthUserSdb",
                  "Failed to open Key \"%s\" Error 0x%x\n", szFullKey, lResult));
        goto out;
    }

    //
    // enum all the values please
    //

    while (TRUE) {

        dwNameSize = CHARCOUNT(szSdbName);

        lResult = RegEnumValue(hKey,
                               dwIndex,
                               szSdbName,
                               &dwNameSize,
                               NULL,
                               &dwDataType,
                               NULL,
                               NULL);

        dwIndex++;

        if (lResult != ERROR_SUCCESS) {
            goto out;
        }

        //
        // we have sdb name, convert it to guid
        //
        pDot = _tcsrchr(szSdbName, TEXT('.'));
        if (pDot != NULL) {
            *pDot = TEXT('\0'); // old style entry
        }

        if (SdbGUIDFromString(szSdbName, pGuidDB)) {
            //
            // we are done
            //
            break;
        }
    }

    //
    // advance the counter if success
    //
    *pdwIndex = dwIndex;

    bRet = TRUE;

out:
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return bRet;

}

//
// These three functions are not needed for Win9x, and are stubbed out here
//

BOOL
SdbGetPermLayerKeys(
    IN  LPCTSTR  szPath,
    OUT LPTSTR   szLayers,
    IN  LPDWORD  pdwBytes,
    IN  DWORD    dwFlags
    )
{
    return FALSE;
}

BOOL
SdbSetPermLayerKeys(
    IN  LPCTSTR  szPath,
    IN  LPCTSTR  szLayers,
    IN  BOOL     bMachine
    )
{
    return FALSE;
}

BOOL
SdbDeletePermLayerKeys(
    IN  LPCTSTR szPath,
    IN  BOOL    bMachine
    )
{
    return FALSE;
}


BOOL
SdbpGetLongFileName(
    IN  LPCTSTR szFullPath,     // a full UNC or DOS path & filename, "c:\foo\mylong~1.ext"
    OUT LPTSTR  szLongFileName  // the long filename portion "mylongfilename.ext"
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   BUGBUG: comment.
--*/
{
    HANDLE          hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    BOOL            bReturn = FALSE;

    hFind = FindFirstFile(szFullPath, &FindData);

    if (hFind == INVALID_HANDLE_VALUE) {
        DBGPRINT((sdlError,
                  "SdbpGetLongFileName",
                  "FindFirstFile failed, error 0x%x.\n",
                  GetLastError()));
        goto Done;
    }

    //
    // BUGBUG: Hopefuly there is enough space in 'szLongFileName' to not AV :-(
    //
    _tcscpy(szLongFileName, FindData.cFileName);
    bReturn = TRUE;

Done:

    if (hFind != INVALID_HANDLE_VALUE) {
        FindClose(hFind);
    }

    return bReturn;
}

void
SdbpGetWinDir(
    OUT LPTSTR pszDir           // will contain the %windir% path.
    )
/*++
    Return: void.

    Desc:   This is a wrapper function to get the windows directory.
--*/
{
    UINT cch;

    //
    // BUGBUG: This will only work properly on non-TS system.
    //         On TS we need to use GetSystemWindowsDirectory instead.
    //
    cch = GetWindowsDirectory(pszDir, MAX_PATH);

    if (cch == 0) {
        *pszDir = 0;
    }
}

void
SdbpGetAppPatchDir(
    OUT LPTSTR szAppPatchPath   // will contain %windir%\AppPatch path
    )
/*++
    Return: void.

    Desc:   This is a wrapper function to get the %windir%\AppPatch directory.
--*/
{
    UINT cch;

    //
    // BUGBUG: This will only work properly on non-TS system.
    //         On TS we need to use GetSystemWindowsDirectory instead.
    //
    cch = GetWindowsDirectory(szAppPatchPath, MAX_PATH);

    //
    // Make sure the path doesn't end with '\\'
    //
    if (cch > 0 && _T('\\') == szAppPatchPath[cch - 1]) {
        szAppPatchPath[cch - 1] = _T('\0');
    }

    _tcscat(szAppPatchPath, _T("\\AppPatch"));
}

void
SdbpGetCurrentTime(
    OUT LPSYSTEMTIME lpTime     // will contain the local time
    )
/*++
    Return: void.

    Desc:   This is a wrapper function to get the local time.
--*/
{
    GetLocalTime(lpTime);
}


NTSTATUS
SdbpGetEnvVar(
    IN  LPCTSTR pEnvironment,
    IN  LPCTSTR pszVariableName,
    OUT LPTSTR  pszVariableValue,
    OUT LPDWORD pdwBufferSize
    )
/*++
    Return: BUGBUG: ?

    Desc:   Retrieves the value of the specified environment variable.
--*/
{
    DWORD    dwLength;
    DWORD    dwBufferSize = 0;
    NTSTATUS Status;
    LPTSTR   pszBuffer = NULL;

    assert(pEnvironment == NULL);

    if (pdwBufferSize && pszVariableValue) {
        dwBufferSize = *pdwBufferSize;
    }

    dwLength = GetEnvironmentVariable(pszVariableName, (LPTSTR)pszVariableValue, dwBufferSize);

    if (dwLength == 0) {
        //
        // The variable was not found. Just return.
        //
        return STATUS_VARIABLE_NOT_FOUND;
    }

    if (dwLength >= dwBufferSize) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        Status = STATUS_SUCCESS;
    }

    if (pdwBufferSize != NULL) {
        *pdwBufferSize = dwLength;
    }

    return Status;
}

LPSTR
SdbpFastUnicodeToAnsi(
    IN  PDB      pdb,           // pointer to the database
    IN  LPCWSTR  pwszSrc,       // String to convert
    IN  TAG_TYPE ttTag,         // tag type from which pwszSrc was obtained,
                                // either STRINGREF or STRING
    IN  DWORD    dwRef          // tagid or string's stringref
    )
/*++
    Return: The pointer to the ANSI string in the hash table.

    Desc:   This function converts a UNICODE string to ANSI and stores it in a hash
            table. It then returns the pointer to the ANSI string in the hash table.
            Subsequent calls trying to convert a string that has been previously
            converted will be very fast.
--*/
{
    LPSTR    pszDest = NULL;
    PSTRHASH pHash = NULL;
    INT      nSize;
    LPSTR    pszBuffer = NULL;

    //
    // See if this string comes from the stringtable or it is in-place.
    //
    switch (ttTag) {
    case TAG_TYPE_STRING:
        if (pdb->pHashStringBody == NULL) {
            pdb->pHashStringBody = HashCreate();
        }

        pHash = pdb->pHashStringBody;
        break;

    case TAG_TYPE_STRINGREF:
        if (pdb->pHashStringTable == NULL) {
            pdb->pHashStringTable = HashCreate();
        }

        pHash = pdb->pHashStringTable;
        break;

    default:
        DBGPRINT((sdlError,
                  "SdbpFastUnicodeToAnsi",
                  "ttTag 0x%x should be STRING or STRINGREF\n",
                  ttTag));
        assert(FALSE);
        break;
    }

    if (pHash == NULL) {
        DBGPRINT((sdlError,
                  "SdbpFastUnicodeToAnsi",
                  "Pointer to hash is invalid, tag type 0x%x\n",
                  ttTag));
        return NULL;
    }

    pszDest = HashFindStringByRef(pHash, dwRef);

    if (pszDest == NULL) {
        //
        // Convert the string to ANSI. Do it in 2 steps to find
        // the required size first.
        //
        nSize = WideCharToMultiByte(CP_OEMCP,
                                    0,
                                    pwszSrc,
                                    -1,
                                    NULL,
                                    0,
                                    NULL,
                                    NULL);

        if (nSize == 0) {
            DBGPRINT((sdlError,
                      "SdbpFastUnicodeToAnsi",
                      "WideCharToMultiByte failed 0x%x.\n",
                      GetLastError()));
            goto Done;
        }

        STACK_ALLOC(pszBuffer, nSize); // size is in BYTES
        if (pszBuffer == NULL) {
            DBGPRINT((sdlError,
                      "SdbpFastUnicodeToAnsi",
                      "Failed to allocate 0x%x bytes on the stack.\n",
                      nSize));
            goto Done;
        }

        nSize = WideCharToMultiByte(CP_OEMCP,
                                    0,
                                    pwszSrc,
                                    -1,
                                    pszBuffer,
                                    nSize,
                                    NULL,
                                    NULL);
        if (nSize == 0) {
            DBGPRINT((sdlError,
                      "UnicodeStringToString",
                      "WideCharToMultiByte failed with buffer Error = 0x%lx\n",
                      GetLastError()));
            goto Done;
        }

        //
        // Now we are ready to store the string in the hash table.
        //
        pszDest = HashAddStringByRef(pHash, pszBuffer, dwRef);
    }

Done:

    if (pszBuffer != NULL) {
        STACK_FREE(pszBuffer);
    }

    return pszDest;
}

BOOL
SdbpMapFile(
    IN  HANDLE         hFile,       // handle to the open file (this is done previously)
    OUT PIMAGEFILEDATA pImageData   // stores the mapping info
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   This function maps the view of a file in memory so that access operations
            on that file are faster.
--*/
{
    NTSTATUS Status;
    HANDLE   hSection = NULL;
    SIZE_T   ViewSize = 0;
    PVOID    pBase = NULL;
    LARGE_INTEGER liFileSize;
    BOOL     bSuccess = FALSE;

    MEMORY_BASIC_INFORMATION MemoryInfo;

    if (hFile == INVALID_HANDLE_VALUE) {
        DBGPRINT((sdlError,
                  "SdbpMapFile",
                  "Invalid parameter.\n"));
        return FALSE;
    }

    liFileSize.LowPart = GetFileSize(hFile, &liFileSize.HighPart);
    if (liFileSize.LowPart == (DWORD)-1) {

        DWORD dwError = GetLastError();

        if (dwError != NO_ERROR) {
            DBGPRINT((sdlError, "SdbpMapFile", "GetFileSize failed with 0x%x.\n", dwError));
            return FALSE;
        }
    }

    hSection = CreateFileMapping(hFile,
                                 NULL, // no inheritance
                                 PAGE_READONLY | SEC_COMMIT,
                                 0,
                                 0,
                                 NULL);
    if (hSection == NULL) {
        DBGPRINT((sdlError,
                  "SdbpMapFile",
                  "CreateFileMapping failed with 0x%x.\n",
                  GetLastError()));
        return FALSE;
    }

    //
    // Now map the view.
    //
    pBase = MapViewOfFile(hSection,
                          FILE_MAP_READ,
                          0,
                          0,
                          0);

    if (pBase == NULL) {
         CloseHandle(hSection);
         DBGPRINT((sdlError,
                   "SdbpMapFile",
                   "MapViewOfFile failed with 0x%x.\n",
                   GetLastError()));
         return FALSE;
    }

    //
    // Why do you need both FileSize and ViewSize ?
    // Both FileSize and ViewSize are used in various places
    // need to re-examine why and how they're used - BUGBUG
    //
    VirtualQuery(pBase, &MemoryInfo, sizeof(MemoryInfo));

    pImageData->hFile    = hFile;
    pImageData->hSection = hSection;
    pImageData->pBase    = pBase;
    pImageData->ViewSize = MemoryInfo.RegionSize;
    pImageData->FileSize = liFileSize.QuadPart;

    return TRUE;
}

BOOL
SdbpUnmapFile(
    IN  PIMAGEFILEDATA pImageData   // mapping info
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   This function unmaps the view of a file.
--*/
{
    if (pImageData->pBase) {
        UnmapViewOfFile(pImageData->pBase);
        pImageData->pBase = NULL;
    }

    if (pImageData->hSection) {
        CloseHandle(pImageData->hSection);
        pImageData->hSection = NULL;
    }

    pImageData->hFile = INVALID_HANDLE_VALUE;

    return TRUE;
}


LPTSTR
SdbpDuplicateString(
    IN  LPCTSTR pszSrc          // pointer to the string to be duplicated
    )
/*++
    Return: A pointer to the allocated duplicated string.

    Desc:   Duplicates a string by allocating a copy from the heap.
--*/
{
    LPTSTR pszDest = NULL;
    int    nSize;

    assert(pszSrc != NULL);

    nSize = (_tcslen(pszSrc) + 1) * sizeof(TCHAR);

    pszDest = (LPTSTR)SdbAlloc(nSize);

    if (pszDest == NULL) {
        DBGPRINT((sdlError,
                  "SdbpDuplicateString",
                  "Failed to allocate %d bytes.\n",
                  nSize));
        return NULL;
    }

    RtlMoveMemory(pszDest, pszSrc, nSize);

    return pszDest;
}

BOOL
SdbpReadStringToAnsi(
    IN  PDB    pdb,
    IN  TAGID  tiWhich,
    OUT LPSTR  pszBuffer,
    IN  DWORD  dwBufferSize
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Reads a string from the database and converts it to ANSI.
--*/
{
    WCHAR* pData;
    INT    nch;

    pData = (WCHAR*)SdbpGetMappedTagData(pdb, tiWhich);

    if (pData == NULL) {
        DBGPRINT((sdlError,
                  "SdbpReadStringToAnsi",
                  "SdbpGetMappedTagData failed for TAGID 0x%x.\n",
                  tiWhich));
        return FALSE;
    }


    nch = WideCharToMultiByte(CP_OEMCP,
                              0,
                              pData,
                              -1,
                              pszBuffer,
                              dwBufferSize * sizeof(TCHAR),
                              NULL,
                              NULL);

    if (nch == 0) {
        DBGPRINT((sdlError,
                  "SdbpReadStringToAnsi",
                  "WideCharToMultiByte failed with 0x%x.\n",
                  GetLastError()));
        return FALSE;
    }

    return TRUE;
}

DWORD
SdbpGetFileSize(
    IN  HANDLE hFile            // handle to the file to check the size of
    )
/*++
    Return: The size of the file or 0 on failure.

    Desc:   Gets the lower DWORD of the size of a file -- only
            works accurately with files smaller than 2GB.
            In general, since we're only interested in matching, we're
            fine just matching the least significant DWORD of the file size.
--*/
{
    return GetFileSize(hFile, NULL);
}


BOOL
SdbpQueryFileDirectoryAttributes(
    IN  LPCTSTR                  FilePath,
    OUT PFILEDIRECTORYATTRIBUTES pFileDirectoryAttributes
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   BUGBUG: ?
--*/
{
    WIN32_FIND_DATA FindData;
    HANDLE          hFind;
    int             i;

    ZeroMemory(pFileDirectoryAttributes, sizeof(*pFileDirectoryAttributes));

    hFind = FindFirstFile(FilePath, &FindData);

    if (hFind == INVALID_HANDLE_VALUE) {
        DBGPRINT((sdlError,
                  "SdbpQueryFileDirectoryAttributes",
                  "FindFirstFile failed with 0x%x.\n",
                  GetLastError()));
        return FALSE;
    }

    //
    // Make sure we are not checking vlfs.
    //
    if (FindData.nFileSizeHigh != 0) {
        DBGPRINT((sdlError,
                  "SdbpQueryFileDirectoryAttributes",
                  "Checking vlf files (0x%x 0x%x) is not supported\n",
                  FindData.nFileSizeHigh,
                  FindData.nFileSizeLow));
        return FALSE;
    }

    pFileDirectoryAttributes->dwFlags       |= FDA_FILESIZE;
    pFileDirectoryAttributes->dwFileSizeHigh = FindData.nFileSizeHigh;
    pFileDirectoryAttributes->dwFileSizeLow  = FindData.nFileSizeLow;

    FindClose(hFind);

    return TRUE;
}

BOOL
SdbpDoesFileExists(
    IN  LPCTSTR pszFilePath     // the full path of the file
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Checks if the specified file exists.
--*/
{
    DWORD dwAttributes;

    dwAttributes = GetFileAttributes(pszFilePath);

    return (dwAttributes != (DWORD)-1);
}

BOOL
SdbpGet16BitDescription(
    OUT LPTSTR*        ppszDescription,
    IN  PIMAGEFILEDATA pImageData
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   BUGBUG: ?
--*/
{
    BOOL   bSuccess;
    CHAR   szBuffer[256];
    LPTSTR pszDescription = NULL;

    bSuccess = SdbpQuery16BitDescription(szBuffer, pImageData);

    if (bSuccess) {
        pszDescription = SdbpDuplicateString(szBuffer);
        *ppszDescription = pszDescription;
    }

    return (pszDescription != NULL);
}

BOOL
SdbpGet16BitModuleName(
    OUT LPTSTR*        ppszModuleName,
    IN  PIMAGEFILEDATA pImageData
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   BUGBUG: ?
--*/
{
    BOOL   bSuccess;
    CHAR   szBuffer[256];
    LPTSTR pszModuleName = NULL;

    bSuccess = SdbpQuery16BitModuleName(szBuffer, pImageData);

    if (bSuccess) {
        pszModuleName = SdbpDuplicateString(szBuffer);
        *ppszModuleName = pszModuleName;
    }

    return (pszModuleName != NULL);
}


PVOID
SdbGetFileInfo(
    IN  HSDB    hSDB,
    IN  LPCTSTR pszFilePath,
    IN  HANDLE  hFile OPTIONAL,
    IN  LPVOID  pImageBase OPTIONAL,
    IN  DWORD   dwImageSize OPTIONAL,
    IN  BOOL    bNoCache
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    PSDBCONTEXT    pContext = (PSDBCONTEXT)hSDB;
    LPTSTR         FullPath;
    NTSTATUS       Status;
    PFILEINFO      pFileInfo = NULL;
    DWORD          nBufferLength;
    DWORD          cch;
    UNICODE_STRING FullPathU;

    //
    // See if we have info on this file. Get the full path first.
    //
    cch = GetFullPathName(pszFilePath, 0, NULL, NULL);

    if (cch == 0) {
        DBGPRINT((sdlError,
                  "GetFileInfo",
                  "GetFullPathName failed for \"%s\" with 0x%x.\n",
                  pszFilePath,
                  GetLastError()));
        return NULL;
    }

    nBufferLength = (cch + 1) * sizeof(TCHAR);

    STACK_ALLOC(FullPath, nBufferLength);
    if (FullPath == NULL) {
        DBGPRINT((sdlError,
                  "GetFileInfo",
                  "Failed to allocate %d bytes on the stack for full path.\n",
                  nBufferLength));
        return NULL;
    }

    cch = GetFullPathName(pszFilePath,
                          nBufferLength,
                          FullPath,
                          NULL);

    assert(cch <= nBufferLength);

    if (cch > nBufferLength || cch == 0) {
        DBGPRINT((sdlError,
                  "GetFileInfo",
                  "GetFullPathName failed for \"%s\" with 0x%x.\n",
                  pszFilePath,
                  GetLastError()));

        STACK_FREE(FullPath);

        return NULL;
    }

    if (!bNoCache) {
        pFileInfo = FindFileInfo(pContext, FullPath);
    }

    if (pFileInfo == NULL) {

        if (SdbpDoesFileExists(FullPath)) {
            pFileInfo = CreateFileInfo(pContext,
                                       FullPath,
                                       cch,
                                       hFile,
                                       pImageBase,
                                       dwImageSize,
                                       bNoCache);
        }
    }

    STACK_FREE(FullPath);

    return (PVOID)pFileInfo;

}

int
GetShimDbgLevel(
    void
    )
{
    TCHAR  szDebugLevel[128];
    DWORD  cch;
    INT    iShimDebugLevel = 0;

    cch = GetEnvironmentVariable(TEXT("SHIM_DEBUG_LEVEL"),
                                 szDebugLevel,
                                 CHARCOUNT(szDebugLevel));
    if (cch != 0) {
        iShimDebugLevel = (int)_tcstol(szDebugLevel, NULL, 0);
    }

    return iShimDebugLevel;
}


BOOL
SdbpWriteBitsToFile(
    LPCTSTR pszFile,
    PBYTE   pBuffer,
    DWORD   dwSize
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Self explanatory.
--*/

{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    BOOL   bReturn = FALSE;
    DWORD  dwBytesWritten;

    hFile = CreateFile(pszFile,
                       GENERIC_READ | GENERIC_WRITE,
                       0, // no sharing
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        DBGPRINT((sdlError, "SdbpWriteBitsToFile",
                  "Failed to create file \"%s\" Error 0x%lx.\n", pszFile, GetLastError()));
        goto cleanup;
    }

    if (!WriteFile(hFile, pBuffer, dwSize, &dwBytesWritten, NULL)) {
        DBGPRINT((sdlError, "SdbpWriteBitsToFile",
                   "Failed to write bits to file \"%s\" Error 0x%lx\n", pszFile, GetLastError()));
        goto cleanup;
    }

    bReturn = TRUE;

 cleanup:

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    return bReturn;
}

/***
* void _resetstkoflw(void) - Recovers from Stack Overflow
*
* Purpose:
*       Sets the guard page to its position before the stack overflow.
*
*******************************************************************************/

VOID
SdbResetStackOverflow(
    VOID
    )
{
    LPBYTE pStack, pGuard, pStackBase, pCommitBase;
    MEMORY_BASIC_INFORMATION mbi;
    SYSTEM_INFO si;
    DWORD PageSize;

    // Use alloca() to get the current stack pointer
    pStack = _alloca(1);

    // Find the base of the stack.
    VirtualQuery(pStack, &mbi, sizeof mbi);
    pStackBase = mbi.AllocationBase;

    VirtualQuery(pStackBase, &mbi, sizeof mbi);

    if (mbi.State & MEM_RESERVE) {
        pCommitBase = (LPBYTE)mbi.AllocationBase + mbi.RegionSize;
        VirtualQuery(pCommitBase, &mbi, sizeof mbi);
    } else {
        pCommitBase = pStackBase;
    }

    //
    // Find the page just below where stack pointer currently points.
    //
    GetSystemInfo(&si);
    PageSize = si.dwPageSize;

    pGuard = (LPBYTE) (((DWORD_PTR)pStack & ~(DWORD_PTR)(PageSize -1)) - PageSize);

    if ( pGuard < pStackBase) {
        //
        // We can't save this
        //
        return;
    }

    if (pGuard > pStackBase) {
        VirtualFree(pStackBase, pGuard -pStackBase, MEM_DECOMMIT);
    }

    VirtualAlloc(pGuard, PageSize, MEM_COMMIT, PAGE_READWRITE);
    VirtualProtect(pGuard, PageSize, PAGE_READWRITE | PAGE_GUARD, &PageSize);
}

DWORD
SdbExpandEnvironmentStrings(
    IN  LPCTSTR lpSrc,
    OUT LPTSTR  lpDst,
    IN  DWORD   nSize)
{
    return ExpandEnvironmentStrings(lpSrc, lpDst, nSize);
}

TCHAR g_szDatabasePath[]        = TEXT("DatabasePath");
TCHAR g_szDatabaseType[]        = TEXT("DatabaseType");
TCHAR g_szDatabaseDescription[] = TEXT("DatabaseDescription");


BOOL
SDBAPI
SdbGetDatabaseRegPath(
    IN  GUID*  pguidDB,
    OUT LPTSTR pszDatabasePath,
    IN  DWORD  dwBufferSize      // size (in tchars) of the buffer
    )
{
    TCHAR szDatabaseID[64];
    INT   nch;

    SdbGUIDToString(pguidDB, szDatabaseID);

    nch = _sntprintf(pszDatabasePath,
                     (size_t)dwBufferSize,
                     TEXT("%s\\%s"),
                     APPCOMPAT_KEY_PATH_INSTALLEDSDB,
                     szDatabaseID);
    return (nch > 0);
}

BOOL
SDBAPI
SdbUnregisterDatabase(
    IN GUID* pguidDB
    )
/*++
    Unregisters a database so it's no longer available.


--*/
{
    TCHAR szFullKey[512];

    //
    // Form the key
    //
    if (!SdbGetDatabaseRegPath(pguidDB, szFullKey, CHARCOUNT(szFullKey))) {
        DBGPRINT((sdlError, "SdbUnregisterDatabase", "Failed to get database key path\n"));
        return FALSE;
    }

    return (SHDeleteKey(HKEY_LOCAL_MACHINE, szFullKey) == ERROR_SUCCESS);
}


BOOL
SDBAPI
SdbRegisterDatabase(
    IN LPCTSTR pszDatabasePath,
    IN DWORD   dwDatabaseType
    )
/*++
    Registers any given database so that it is "known" to our database lookup apis

    Caller must ensure that appcompatflags registry entry exists
    If the function fails -- the caller should try to cleanup the mess using SdbUnregisterDatabase

--*/
{
    // first we write the database path
    PSDBDATABASEINFO  pDbInfo = NULL;
    BOOL              bReturn = FALSE;
    DWORD             dwPathLength;
    DWORD             dwLength;
    LPTSTR            pszFullPath = NULL;
    TCHAR             szDatabaseID[64]; // sufficient for guid
    LONG              lResult;
    TCHAR             szFullKey[512];
    HKEY              hKeyInstalledSDB = NULL;
    HKEY              hKey = NULL;
    BOOL              bExpandSZ = FALSE;
    BOOL              bFreeFullPath = FALSE;

    //
    // see if we need to expand some strings...
    //
    if (_tcschr(pszDatabasePath, TEXT('%')) != NULL) {

        bExpandSZ = TRUE;

        dwPathLength = ExpandEnvironmentStrings(pszDatabasePath, NULL, 0);
        if (dwPathLength == 0) {
            DBGPRINT((sdlError, "SdbRegisterDatabase",
                       "Failed to expand environment strings for \"%s\" Error 0x%lx\n",
                      pszDatabasePath, GetLastError()));
            return FALSE;
        }

        pszFullPath = SdbAlloc(dwPathLength * sizeof(WCHAR));
        if (pszFullPath == NULL) {
            DBGPRINT((sdlError, "SdbRegisterDatabase",
                      "Failed to allocate 0x%lx bytes for the path buffer \"%s\"\n",
                      dwPathLength, pszDatabasePath));
            return FALSE;
        }

        bFreeFullPath = TRUE;

        dwLength = ExpandEnvironmentStrings(pszDatabasePath, pszFullPath, dwPathLength);
        if (dwLength == 0 || dwLength > dwPathLength) {
            DBGPRINT((sdlError, "SdbRegisterDatabase",
                      "Failed to expand environment strings for \"%s\" Length 0x%lx Return value 0x%lx Error 0x%lx\n",
                      pszDatabasePath, dwPathLength, dwLength, GetLastError()));
            goto HandleError;
        }

    } else { // this path does not need expansion
        pszFullPath = (LPTSTR)pszDatabasePath;
    }

    if (!SdbGetDatabaseInformationByName(pszFullPath, &pDbInfo)) {
        DBGPRINT((sdlError, "SdbRegisterDatabase",
                  "Cannot obtain database information for \"%s\"\n", pszFullPath));
        goto HandleError;
    }

    if (!(pDbInfo->dwFlags & DBINFO_GUID_VALID)) {
        DBGPRINT((sdlError, "SdbRegisterDatabase",
                  "Cannot register database with no id \"%s\"\n", pszDatabasePath));
        goto HandleError;
    }

    //
    // convert the guid into the string, returns true always
    //

    SdbGUIDToString(&pDbInfo->guidDB, szDatabaseID);

    //
    // now that we have database information - create entry
    //

    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                             APPCOMPAT_KEY_PATH_INSTALLEDSDB,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE|KEY_READ,
                             NULL,
                             &hKeyInstalledSDB,
                             NULL);

    if (lResult != ERROR_SUCCESS) {
        DBGPRINT((sdlError, "SdbRegisterDatabase",
                  "Failed to create key \"%s\" error 0x%lx\n", APPCOMPAT_KEY_PATH_INSTALLEDSDB, lResult));
        goto HandleError;
    }

    assert(hKeyInstalledSDB != NULL);

    //
    // now create the key for the existing database
    //

    lResult = RegCreateKeyEx(hKeyInstalledSDB, // subkey
                             szDatabaseID,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE|KEY_READ,
                             NULL,
                             &hKey,
                             NULL);
    if (lResult != ERROR_SUCCESS) {
        DBGPRINT((sdlError, "SdbRegisterDatabase",
                  "Failed to create key \"%s\" error 0x%lx\n", szDatabaseID, lResult));
        goto HandleError;
    }

    assert(hKey != NULL);

    //
    // set values for this database
    //
    lResult = RegSetValueEx(hKey,
                            g_szDatabasePath,
                            0,
                            bExpandSZ ? REG_EXPAND_SZ : REG_SZ,
                            (PBYTE)pszFullPath,
                            (_tcslen(pszFullPath) + 1) * sizeof(*pszFullPath));
    if (lResult != ERROR_SUCCESS) {
        DBGPRINT((sdlError, "SdbRegisterDatabase",
                   "Failed to set value \"%s\" to \"%s\" Error 0x%lx\n",
                   g_szDatabasePath, pszFullPath, lResult));
        goto HandleError;
    }

    lResult = RegSetValueEx(hKey,
                            g_szDatabaseType,
                            0,
                            REG_DWORD,
                            (PBYTE)&dwDatabaseType,
                            sizeof(dwDatabaseType));
    if (lResult != ERROR_SUCCESS) {
        DBGPRINT((sdlError, "SdbRegisterDatabase",
                   "Failed to set value \"%s\" to 0x%lx Error 0x%lx\n",
                   g_szDatabaseType, dwDatabaseType, lResult));
        goto HandleError;
    }

    if (pDbInfo->pszDescription != NULL) {
        lResult = RegSetValueEx(hKey,
                                g_szDatabaseDescription,
                                0,
                                REG_SZ,
                                (PBYTE)pDbInfo->pszDescription,
                                (_tcslen(pDbInfo->pszDescription) + 1) * sizeof(*pDbInfo->pszDescription));
        if (lResult != ERROR_SUCCESS) {
            DBGPRINT((sdlError, "SdbRegisterDatabase",
                       "Failed to set value \"%s\" to 0x%lx Error 0x%lx\n",
                       g_szDatabaseDescription, pDbInfo->pszDescription, lResult));
            goto HandleError;
        }
    }

    bReturn = TRUE;


HandleError:

    if (hKeyInstalledSDB != NULL) {
        RegCloseKey(hKeyInstalledSDB);
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    if (pDbInfo != NULL) {
        SdbFreeDatabaseInformation(pDbInfo);
    }

    if (bFreeFullPath && pszFullPath != NULL) {
        SdbFree(pszFullPath);
    }

    return bReturn;
}

DWORD
SDBAPI
SdbResolveDatabase(
    IN  GUID*   pguidDB,            // pointer to the database guid to resolve
    OUT LPDWORD lpdwDatabaseType,   // optional pointer to the database type
    OUT LPTSTR  pszDatabasePath,    // optional pointer to the database path
    IN  DWORD   dwBufferSize        // size of the buffer pszDatabasePath in tchars
    )
{
    TCHAR  szDatabaseID[64];
    TCHAR  szDatabasePath[MAX_PATH];
    TCHAR  szFullKey[512];
    LONG   lResult;
    HKEY   hKey = NULL;
    DWORD  dwDataType;
    DWORD  dwDataSize;
    DWORD  dwLength = 0;
    //
    // convert guid to string
    //

    if (!SdbGetDatabaseRegPath(pguidDB, szFullKey, CHARCOUNT(szFullKey))) {
        DBGPRINT((sdlError, "SdbResolveDatabase", "Failed to retrieve database key path\n"));
        goto HandleError;
    }

    //
    // open the key
    //
    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           szFullKey,
                           0,
                           KEY_READ,
                           &hKey);
    if (lResult != ERROR_SUCCESS) {
        DBGPRINT((sdlError, "SdbResolveDatabase",
                  "Failed to open key \"%s\" Error 0x%lx\n", szFullKey, lResult));
        goto HandleError; // 0 means error
    }

    dwDataSize = sizeof(szDatabasePath);

    lResult = RegQueryValueEx(hKey,
                              g_szDatabasePath,
                              NULL,
                              &dwDataType,
                              (LPBYTE)szDatabasePath,
                              &dwDataSize);
    if (lResult != ERROR_SUCCESS) {
        DBGPRINT((sdlError, "SdbResolveDatabase",
                  "Failed to query value \"%s\" Error 0x%lx\n", g_szDatabasePath, lResult));
        goto HandleError; // 0 means error
    }

    switch(dwDataType) {
    case REG_SZ:
        // see if we have enough room to copy the string
        //
        if (dwBufferSize * sizeof(TCHAR) < dwDataSize) {
            DBGPRINT((sdlWarning, "SdbResolveDatabase",
                      "Insufficient buffer for the database path Required 0x%lx Have 0x%lx\n",
                      dwDataSize, dwBufferSize * sizeof(TCHAR)));
            goto HandleError;
        }

        RtlMoveMemory(pszDatabasePath, szDatabasePath, dwDataSize);
        dwLength = dwDataSize / sizeof(TCHAR);
        break;

    case REG_EXPAND_SZ:
        // we have to expand the strings
        dwLength = ExpandEnvironmentStrings(szDatabasePath, pszDatabasePath, dwBufferSize);
        if (dwLength == 0 || dwLength > dwBufferSize) {
            DBGPRINT((sdlWarning, "SdbResolveDatabase",
                      "Failed to expand output path\n"));
            dwLength = 0;
            goto HandleError;
        }
        break;

    default:
        // can't do it -- fail
        DBGPRINT((sdlError, "SdbResolveDatabase", "Wrong key type 0x%lx\n", dwDataType));
        goto HandleError;
        break;
    }

    if (lpdwDatabaseType != NULL) {
        dwDataSize = sizeof(*lpdwDatabaseType);
        lResult = RegQueryValueEx(hKey,
                                  g_szDatabaseType,
                                  NULL,
                                  &dwDataType,
                                  (LPBYTE)lpdwDatabaseType,
                                  &dwDataSize);

        if (lResult == ERROR_SUCCESS) {

            if (dwDataType != REG_DWORD) {
                // bummer, get out -- wrong type
                DBGPRINT((sdlError, "SdbResolveDatabase",
                          "Wrong database type - value type 0x%lx\n", dwDataType));
                dwLength = 0;
                goto HandleError;
            }

        } else {
            *lpdwDatabaseType = 0;
        }

    }


HandleError:

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return dwLength;
}

DWORD
SdbpGetProcessorArchitecture(
    VOID
    )
{
    SYSTEM_INFO SysInfo;

    SysInfo.wProcessorArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
    GetSystemInfo(&SysInfo);
    return (DWORD)SysInfo.wProcessorArchitecture;
}

BOOL
SdbpIsOs(
    DWORD dwOSSKU
    )
{
    HKEY    hkey;
    DWORD   type, cbSize, dwInstalled = 0;
    LONG    lRes;
    LPTSTR  pszKeyPath;
    BOOL    bRet = FALSE;

    if (dwOSSKU == OS_SKU_TAB) {
        pszKeyPath = TABLETPC_KEY_PATH;
    } else if (dwOSSKU == OS_SKU_MED) {
        pszKeyPath = EHOME_KEY_PATH;
    } else {
        DBGPRINT((sdlWarning,
                  "SdbpIsOs",
                  "Specified unknown OS type 0x%lx",
                  dwOSSKU));
        return FALSE;
    }

    lRes = RegOpenKey(HKEY_LOCAL_MACHINE, pszKeyPath, &hkey);

    if (lRes != ERROR_SUCCESS) {
        goto cleanup;
    }

    cbSize = sizeof(DWORD);

    lRes = RegQueryValueEx(hkey, IS_OS_INSTALL_VALUE, NULL, &type, (LPBYTE)&dwInstalled, &cbSize);

    if (lRes != ERROR_SUCCESS || type != REG_DWORD) {
        goto cleanup;
    }

    if (dwInstalled) {
        bRet = TRUE;
    }

    DBGPRINT((sdlInfo|sdlLogPipe,
              "SdbpIsOs",
              "%s %s installed",
              0,
              (dwOSSKU == OS_SKU_TAB ? TEXT("TabletPC") : TEXT("eHome")),
              (bRet ? TEXT("is") : TEXT("is not"))));

cleanup:

    RegCloseKey(hkey);

    return bRet;
}

VOID
SdbpGetOSSKU(
    LPDWORD lpdwSKU,
    LPDWORD lpdwSP
    )
{
    OSVERSIONINFOEXA osv;
    WORD             wSuiteMask;

    ZeroMemory(&osv, sizeof(OSVERSIONINFOEXA));

    osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);

    GetVersionExA((LPOSVERSIONINFOA)&osv);

    *lpdwSP = 1 << osv.wServicePackMajor;

    wSuiteMask = osv.wSuiteMask;

    if (osv.wProductType == VER_NT_WORKSTATION) {
        if (wSuiteMask & VER_SUITE_PERSONAL) {
            *lpdwSKU = OS_SKU_PER;
        } else {

#if (_WIN32_WINNT >= 0x0501)

            if (SdbpIsOs(OS_SKU_TAB)) {
                *lpdwSKU = OS_SKU_TAB;
            } else if (SdbpIsOs(OS_SKU_MED)) {
                *lpdwSKU = OS_SKU_MED;
            } else {
                *lpdwSKU = OS_SKU_PRO;
            }
#else
            *lpdwSKU = OS_SKU_PRO;
#endif
        }
        return;
    }

    if (wSuiteMask & VER_SUITE_DATACENTER) {
        *lpdwSKU = OS_SKU_DTC;
        return;
    }

    if (wSuiteMask & VER_SUITE_ENTERPRISE) {
        *lpdwSKU = OS_SKU_ADS;
        return;
    }

    if (wSuiteMask & VER_SUITE_BLADE) {
        *lpdwSKU = OS_SKU_BLA;
        return;
    }

    *lpdwSKU = OS_SKU_SRV;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\doc\testkmode.c ===
//
// Using simplified database matching api
//
// Sample Pseudo-Code  :-)
//
//

/*
    ANNOTATED XML:
    =============

    <APP NAME="Evil Notepad Application" VENDOR="Impostors International LTD.">

        <HISTORY ALIAS="VadimB" DATE="11/29/00">
        <DESCRIPTION>
            Created this nifty sample database to demonstrate functionality
            of sdbapint.dll
        </DESCRIPTION>
        </HISTORY>

        <BUG NUMBER="300000" DATABASE="WHISTLER"/>

        <EXE NAME="Notepad.exe" SIZE="50960" PECHECKSUM="0xE8B4" CHECKSUM="0x02C54A1C" ID="{6E98D683-8A03-4F5B-9B33-FB7429F2C978}">

        <!-- VadimB: This is where the entry is,
             the following attributes could be used (on the left is the XML spelling)

             All of the attributes below are supported (including the version-related attributes)

                SIZE                - file size
                PECHECKSUM          - Checksum from the PE Header
                CHECKSUM            - checksum as calculated by our tools (see xmlwiz)
                BIN_FILE_VERSION    - Binary file version from Fixed Version Information resource
                BIN_PRODUCT_VERSION - binary product version from Fixed Version Information resource
                PRODUCT_VERSION     - "ProductVersion" resource
                FILE_DESCRIPTION    - "FileDescription" resource
                COMPANY_NAME        - "CompanyName" resource
                PRODUCT_NAME        - "ProductName" resource
                FILEVERSION         - "FileVersion" resource
                ORIGINALFILENAME    - "OriginalFilename" resource
                INTERNALNAME        - "InternalName" resource
                LEGALCOPYRIGHT      - "LegalCopyright" resource

                UPTO_BIN_PRODUCT_VERSION - up to the specified binary product version

                VERFILEDATEHI       - maps to the Fixed Version Into dwFileDateMS
                VERFILEDATELO       - maps to the Fixed Version Info dwFileDateLS
                VERFILETYPE         - maps to the Fixed Version Info dwFileType

                MODULETYPE          - specify module type - as one of WIN32, WIN16, DOS, etc -- ONLY WIN32 is supported

                S16BITDESCRIPTION   - 16-bit Module's description - SHOULD NOT be used

             Initially when composing XML, the ID attribute could be omitted - it is generated automatically
             by shimdbc.exe and your xml file will be updated with the (generated) id

        -->

        <!-- VadimB: This is what you can do with DRIVER_POLICY tags:
             - more than one tag allowed
             - NAME attribute should be unique within the scope of each EXE tag above
             - VALUETYPE must be present, the following value types are supported:
                STRING - maps to REG_SZ
                DWORD  - maps to REG_DWORD
                QWORD  - maps to REG_QWORD
                BINARY - maps to REG_BINARY
             - Values can be located within the scope of the tag -- or denoted as an attribute
               VALUE
        -->



        <!-- in the entry below - Policy1 defines a DWORD value 0x12345 -->

            <DRIVER_POLICY NAME="Policy1" VALUETYPE="DWORD" VALUE="0x12345"/>

        <!-- entry below is a string which will be picked up from the body of the tag "This is my string" -->

            <DRIVER_POLICY NAME="Policy2" VALUETYPE="STRING">
                This is my string
            </DRIVER_POLICY>

        <!-- entry below provides for 5 bytes of binary data -->

            <DRIVER_POLICY NAME="Policy3" VALUETYPE="BINARY" VALUE="1 2 3 4 5"/>

        <!-- entry below does not have any value associated with it -->

            <DRIVER_POLICY NAME="Policy4"/>

        <!-- entry below is a ULONGLONG -->

            <DRIVER_POLICY NAME="Policy5" VALUETYPE="QWORD" VALUE="0x1234567812345678"/>


            <DRIVER_POLICY NAME="Policy6" VALUETYPE ="STRING" VALUE="Testing in-line string">
            <!--
                 this is a comment, so please ignore me
            -->
            </DRIVER_POLICY>


        </EXE>

    </APP>


    Using SdbQueryDriverInformation :

    Note the change

DWORD
SdbQueryDriverInformation(
    IN     HSDB    hSDB,              // Database handle
    IN     TAGREF  trExe,             // matching entry
    IN     LPCWSTR lpszPolicyName,    // Policy name which is to be retrieved
    OUT    LPDWORD lpdwDataType,      // Optional, receives information on the target data type
    OUT    LPVOID  lpBuffer,          // buffer to fill with data
    IN OUT LPDWORD lpdwBufferSize     // buffer size
    );

    Notes:
        1. If lpszPolicyName == NULL then the function will attempt to copy all the available policy names
           into buffer pointed to by lpBuffer. If lpBuffer is NULL, lpdwBufferSize will receive the required size.
           Possible return values:
           ERROR_INSUFFICIENT_BUFFER    - when lpBuffer == NULL or the size of the buffer is insufficient to hold the
                                               list of policy names
           ERROR_INVALID_PARAMETER      - one of the parameters was invalid

           ERROR_INTERNAL_DB_CORRUPTION - the database is unusable

           ERROR_SUCCESS

        2. If lpszPolicyName != NULL then the function will attempt to find the data for this policy. If lpBuffer is
           specified, lpdwBufferSize should point to the buffer size. lpdwBUfferSize could be NULL -- an attempt to
           copy data into lpBuffer will be made (under try/except).


           Possible return values:
           ERROR_NOT_FOUND              - policy could not be found
           ERROR_INTERNAL_DB_CORRUPTION - the database is unusable
           ERROR_INSUFFICIENT_BUFFER    - lpdwBufferSize will be updated with the correct size of the buffer
           ERROR_INVALID_DATA           - lpBuffer parameter is invalid

           ERROR_SUCCESS


*/



#include "shimdb.h"


// ....
//
// it is assumed that the database has been mapped into memory
// pDatabase      is the pointer to the beginning of the database image
// dwDatabaseSize is the size of the database image
//
// Also assumed:
//      lpszDriverPath - fully qualified name of the driver file that we're checking
//

{
    HSDB                 hSDB;
    TAGREF               trDriver;
    SDBDRIVERINFORMATION DriverInfo;
    BOOL                 bSuccess;
    DWORD                Status;
    DWORD                dwDataSize;
    DWORD                dwDataType;
    LPVOID               pBuffer;
    DWORD                dwData;

    //
    //

    hSDB = SdbInitDatabaseInMemory(pDatabase, dwDatabaseSize);
    if (NULL == hSDB) {
        //
        // something is terribly wrong -- database has failed to initialize
        //
    }

    //
    // Match exe
    //

    trDriver = SdbGetDatabaseMatch(hSDB, lpszDriverPath);
    if (TAGREF_NULL == trDriver) {

        //
        // there is no match in the database for this file
        //
    }
    else {

        //
        // we have a match, trExe is the "token" that references the match
        // now we shall read the relevant info

        bSuccess = SdbReadDriverInformation(hSDB, trDriver, &DriverInfo);
        if (!bSuccess) {

            //
            // for one reason or the other, this entry is corrupted
            //

        }

        //
        // DriverInfo contains the following:
        //
        // GUID     guidID;                   // guid ID for this entry - ID attribute in XML
        // DWORD    dwFlags;                  // registry flags for this exe - see below
        //
        // Each EXE can have flags in AppCompatibility section of the registry associated with it,
        // we should check whether this entry is disabled via a registry flag
        //

        if (DriverInfo.dwFlags & SHIMREG_DISABLE_DRIVER) {

            //
            // don't apply this entry, it has been de-activated through the registry
            //

        }


        //
        // Query for information - step 1 -- obtain all the available policies for this driver
        //

        Status = SdbQueryDriverInformation(hSDB,
                                           trDriver,
                                           NULL,        // policy name
                                           &dwDataType, // pointer to the data type
                                           NULL,        // pointer to the buffer
                                           &dwDataSize);

        // expected return value:
        // ERROR_INSUFFICIENT_BUFFER
        // dwDataSize will contain the required buffer size in bytes

        //
        // assuming that we allocated dwDataSize bytes, pBuffer is the buffer pointer
        //

        Status = SdbQueryDriverInformation(hSDB,
                                           trDriver,
                                           NULL,
                                           &dwDataType,
                                           pBuffer,
                                           &dwDataSize);
        //
        // expected return value:
        // ERROR_SUCCESS
        // dwDataSize will contain the number of bytes written into the buffer
        // dwDataType will contain REG_MULTI_SZ
        // pBuffer will receive the following data (unicode strings, assuming xml above was used)
        // Policy1\0Policy2\0Policy3.... \0\0
        //

        Status = SdbQueryDriverInformation(hSDB,
                                           trDriver,
                                           L"Policy1",
                                           &dwDataType,
                                           NULL,
                                           &dwDataSize);
        //
        // Expected return value:
        // ERROR_INSUFFICIENT_BUFFER
        // dwDataSize will contain 4
        // dwDataType will contain REG_DWORD
        //

        dwDataSize = sizeof(dwData);

        Status = SdbQueryDriverInformation(hSDB,
                                           trDriver,
                                           L"Policy1",
                                           &dwDataType,
                                           &dwData,
                                           &dwDataSize);
        // expected return value:
        // ERROR_SUCCESS
        // dwData will have a value of 0x12345
        //

    }

    //
    // After all the work is done - release the database
    //
    //

    SdbReleaseDatabase(hSDB);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\doc\testmsi.c ===
/*
 *
 *
 * This is the file you need to include to pull all the relevant
 * functionality for Sdb* functions
 * Note that despite api parameters appearing as TCHAR in definitions, they are always
 * WCHARs on NT and always CHARs on Win9x
 *
 */

#include "shimdb.h"


/*++

    XML how-to

    1. db.xml in xml directory is a snapshot of our actual xml file
       (you should enlist into lab6 windows\published and windows\appcompat!!!)
    2. Transforms(remedies) are specified under <LIBRARY> :

        <!--   MSI Transforms -->

        <!-- this is the file containing the transform -- it should be accessible to the compiler
             when appcompat database is being built -->
        <FILE NAME="notepad.exe"/>

        <!-- this is description stub, transform is referenced by name ExperimentalTransform
             refers to the filename notepad.exe -->
        <MSI_TRANSFORM NAME="ExperimentalTransform" FILE="notepad.exe">
            <DESCRIPTION>
                This is a sample transform for MSI implementation
            </DESCRIPTION>
        </MSI_TRANSFORM>


    3. Packages are specified like this:

    <APP NAME="Some random app" VENDOR="ArtsCraftsAndCalamitiesInc">
        <DESCRIPTION>
            This is description
        </DESCRIPTION>
        ...



        <MSI_PACKAGE NAME="Test install 1" ID="{740fa5d8-6472-4c36-9129-364b773fa64e}">
            <DATA NAME="Data1"  VALUETYPE="DWORD"  VALUE="0x12345678"/>
            <DATA NAME="Moo2"   VALUETYPE="STRING" VALUE="This is my test string"/>
            <DATA NAME="Kozu44" VALUETYPE="BINARY">
                01 23 45 67 89 10 11 12 13 14 15 16 17 18 19 20 21
            </DATA>

            <MSI_TRANSFORM NAME="ExperimentalTransform"/>

        </MSI_PACKAGE>

        <MSI_PACKAGE NAME="Test Install 2 same guid" ID="{740fa5d8-6472-4c36-9129-364b773fa64e}">

            <DATA NAME="Data1"  VALUETYPE="DWORD"  VALUE="0x45678"/>
            <DATA NAME="Moo2"   VALUETYPE="STRING" VALUE="This is another string"/>
            <DATA NAME="Kozu44" VALUETYPE="BINARY">
                01 23 45 67 89 10 11 12 13 14 15 16 17 18 19 20 21
            </DATA>

            <MSI_TRANSFORM NAME="ExperimentalTransform2"/>

        </MSI_PACKAGE>

    </APP>

    4. Compiling database - the best way to do it -- is to build sysmain.sdb using
       %sdxroot%\windows\appcompat\package

       to do it:
        a. Enlist into lab6 windows\appcompat and windows\published,
           build in windows\published then in windows\appcompat
        b. modify windows\appcompat\db\db.xml
        c. Copy all the msi transform files into %_NTTREE%\shimdll
        c. build in windows\appcompat\package
        d. appfix.exe package is ready for deployment in obj\i386



======================================================================================================
New Features:

    1. Nested DATA tags:

        <MSI_PACKAGE NAME="Test install 1" ID="{740fa5d8-6472-4c36-9129-364b773fa64e}">
            <DATA NAME="Data1" VALUETYPE="DWORD" VALUE="0x12345678"/>
            <DATA NAME="Moo2" VALUETYPE="STRING" VALUE="This is my test string"/>
            <DATA NAME="Kozu44" VALUETYPE="BINARY">
                01 23 45 67 89 10 11 12 13 14 15 16 17 18 19 20 21
            </DATA>
            <DATA NAME="Root" VALUETYPE="STRING" VALUE="ROOT">
                <DATA NAME="Node1" VALUETYPE="DWORD" VALUE="0x1"/>
                <DATA NAME="Node2" VALUETYPE="DWORD" VALUE="0x2">
                    <DATA NAME="SubNode1" VALUETYPE="DWORD" VALUE="0x3"/>
                    <DATA NAME="SubNode2" VALUETYPE="DWORD" VALUE="0x4"/>
                </DATA>
            </DATA>

            <MSI_TRANSFORM NAME="ExperimentalTransform"/>

        </MSI_PACKAGE>

    2. New API and enhanced old api to query nested data tags:

        - direct addressing:

            Status = SdbQueryData(hSDB,
                                  trMatch,
                                  L"Root\Node2\Subnode2", // <<<<< direct path to the value
                                  &dwDataType,
                                  NULL,
                                  &dwDataSize);

        - via enumeration

            Status = SdbQueryDataEx(hSDB,
                                    trMatch,
                                    L"Root",
                                    &dwDataType,
                                    NULL,
                                    &dwDataSize,
                                    &trDataRoot);

        the call above retrieves trDataRoot which allows for further calls to SdbQueryData/SdbQueryDataEx:

            Status = SdbQueryDataEx(hSDB,
                                    trDataRoot,
                                    L"Node2",
                                    &dwDataType,
                                    NULL,
                                    &dwDataSize,
                                    NULL);  // <<< passing NULL is allowed

    3. Fully functional custom databases.

            - compile db.xml that comprises your private database

                shimdbc fix -f .\MyMsiTransforms MyMsiPackages.xml MsiPrivate.sdb

                (above -f parameter points shimdbc to the directory which has all the transform files)

            - install the database using sdbInst (in tools directory)

                sdbinst MsiPrivate.sdb

            - Run query as usual -- the normal enumeration process will now include all the custom dbs in
              addition to any data located in the main database

            - You can unistall the db using sdbinst as well


    4. New flag in SdbInitDatabase

            hSDB = SdbInitDatabase(HID_DATABASE_FULLPATH|HID_DOS_PATH, L"c:\\temp\\mydb.sdb")

       the flag HID_DATABASE_FULLPATH directs us to open the database specified as a second parameter and treat it as
       "main" database. You can also avoid opening ANY database at all -- and rely upon local database and/or custom database:

            hSDB = SdbInitDatabase(HID_NO_DB, NULL)


    5. Note that NONE is a valid data type -
        <DATA NAME="Foo" VALUETYPE="NONE">
        </DATA>

       this entry is perfectly valid


--*/


DetectMsiPackage()
{

    HSDB hSDB;
    SDBMSIFINDINFO MsiFindInfo;

    /*++

        General note:

        * While debugging your code it is useful to set SHIM_DEBUG_LEVEL environment variable
        * in order to see debug spew from Sdb* functions. To see all the debug output:
        * Set SHIM_DEBUG_LEVEL=9


        1. Initialize Database

        Function:

        HSDB
        SdbInitDatabase(
         IN  DWORD dwFlags,          // flags that tell how the database should be
                                     // initialized.
         IN  LPCTSTR pszDatabasePath // the OPTIONAL full path to the database to
                                     // be used.
        )

        dwFlags could have HID_DOS_PATH if you provide pszDatabasePath
        Function will try to open sysmain.sdb and systest.sdb (if available) in \SystemRoot\AppPatch if none of the
        parameters are supplied. To specify alternative location for sysmain.sdb and systest.sdb :

        SdbInitDatabase(HID_DOS_PATH, L"c:\foo") will look for sysmain.sdb in c:\foo


    --*/

    hSDB = SdbInitDatabase(0, NULL);

    if (NULL == hSDB) {
        //
        // failed to initialize database
        //
    }

    /*++

        2. Detect this particular package -- there could be more than one match, caller should
           try and distinguish between the packages by reading supplemental data

           Detection is done by calling SdbFindFirstMsiPackage/SdbFindFirsMsiPackage_Str and
           SdbFindNextMsiPacakage

        Functions:

        TAGREF
        SdbFindFirstMsiPackage_Str(
        IN  HSDB            hSDB,        // handle obtained in a call to SdbInitDatabase
        IN  LPCTSTR         lpszGuid,    // guid in the form {xxxxx.... }
        IN  LPCTSTR         lpszLocalDB, // Optional full path to the local DB file
        OUT PSDBMSIFINDINFO pFindInfo    // find context
        );


        TAGREF
        SdbFindNextMsiPackage(
        IN     HSDB            hSDB,     // handle, see above
        IN OUT PSDBMSIFINDINFO pFindInfo // find context, previously obtained from SdbFindFirstMsiPackage* functions
        );



    --*/

    trMatch = SdbFindFirstMsiPackage_Str(hSDB,
                                         L"{740fa5d8-6472-4c36-9129-364b773fa64e}",
                                         NULL,
                                         &MsiFindInfo);
    while (TAGREF_NULL != trMatch) {


        /*++

            3a.Examine name of this package. Use these functions:

               WCHAR wszBuffer[MAX_PATH];

               trName = SdbFindFirstTagRef(hSDB, trMatch, TAG_NAME);
               if (TAGREF_NULL != trName) {
                   bSuccess = SdbReadStringTagRef(hSDB, trName, wszBuffer, sizeof(wszBuffer)/sizeof(wszBuffer[0]));
               }

               the code above reads "Special Install package" given the xml below:

               <!-- MSI transform -->
               <MSI_PACKAGE NAME="Special install package" ID="{740fa5d8-6472-4c36-9129-364b773fa64e}">
                    <DATA NAME="Data1"  VALUETYPE="DWORD"  VALUE="0x12345678"/>
                    <DATA NAME="Moo2"   VALUETYPE="STRING" VALUE="This is my test string"/>
                    <DATA NAME="Kozu44" VALUETYPE="BINARY">
                       01 23 45 67 89 10 11 12 13 14 15 16 17 18 19 20 21
                    </DATA>

                    <MSI_TRANSFORM NAME="ExperimentalTransform2"/>
                    <MSI_TRANSFORM NAME="ExperimentalTransform3"/>

               </MSI_PACKAGE>

            3b.Examine supplemental data for this package:

            DWORD
            SdbQueryData(
            IN     HSDB    hSDB,              // database handle
            IN     TAGREF  trExe,             // tagref of the matching exe
            IN     LPCTSTR lpszDataName,      // if this is null, will try to return all the policy names
            OUT    LPDWORD lpdwDataType,      // pointer to data type (REG_SZ, REG_BINARY, etc)
            OUT    LPVOID  lpBuffer,          // buffer to fill with information
            IN OUT LPDWORD lpdwBufferSize     // pointer to buffer size
            );

            //
            // Query for information - step 1 -- obtain all the available data for this package
            //

            Status = SdbQueryData(hSDB,
                                  trMatch,
                                  NULL,        // data value name
                                  &dwDataType, // pointer to the data type
                                  NULL,        // pointer to the buffer
                                  &dwDataSize);

            // expected return value:
            // ERROR_INSUFFICIENT_BUFFER
            // dwDataSize will contain the required buffer size in bytes


            //
            // assuming that we allocated dwDataSize bytes, pBuffer is the buffer pointer
            //

            Status = SdbQueryData(hSDB,
                                  trMatch,
                                  NULL,
                                  &dwDataType,
                                  pBuffer,
                                  &dwDataSize);
            //
            // expected return value:
            // ERROR_SUCCESS
            // dwDataSize will contain the number of bytes written into the buffer
            // dwDataType will contain REG_MULTI_SZ
            // pBuffer will receive the following data (unicode strings, assuming xml above was used)
            // Data1\0Moo2\0Kozu44\0\0
            //

            Status = SdbQueryData(hSDB,
                                  trMatch,
                                  L"Data1",
                                  &dwDataType,
                                  NULL,
                                  &dwDataSize);
            //
            // Expected return value:
            // ERROR_INSUFFICIENT_BUFFER
            // dwDataSize will contain 4
            // dwDataType will contain REG_DWORD
            //

            dwDataSize = sizeof(dwData);

            Status = SdbQueryData(hSDB,
                                  trMatch,
                                  L"Data1",
                                  &dwDataType,
                                  &dwData,
                                  &dwDataSize);
            // expected return value:
            // ERROR_SUCCESS
            // dwData will have a value of 0x12345678
            //

            .... etc ...

        --*/


        //
        //  We presume that using the code above we determined that this package is a match, we break out of the loop
        //  trMatch is the matching package
        //
        if (bMatch) {
            break;
        }


        trMatch = SdbFindNextMsiPackage(hSDB, &MsiFindInfo);
    }


    if (TAGREF_NULL == trMatch) {
        return; // no match
    }


    /*++
        4. Seek the remedies. To do so there are two ways:
            - Enumerate all the transforms available for this package using

                DWORD                           // returns the error code, ERROR_SUCCESS if successful
                SdbEnumMsiTransforms(
                IN     HSDB    hSDB,            // db handle
                IN     TAGREF  trMatch,         // matching tagref for the package
                OUT    TAGREF* ptrBuffer,       // pointer to the buffer that will be filled with transform tagrefs
                IN OUT DWORD*  pdwBufferSize    // size of the buffer in bytes, upon return will be set to the number
                );                              // of bytes written to the buffer

                dwError = SdbEnumMsiTransforms(hsdb, trMatch, NULL, &dwSize);
                //
                // expeceted ERROR_INSUFFICIENT_BUFFER,
                // allocate dwSize bytes
                //

                TAGREF* ptrBuffer = new TAGREF[dwSize/sizeof(TAGREF)];

                dwError = SdbEnumMsiTransforms(hsdb, trMatch, ptrBuffer, &dwSize);
                //
                // expected return: ERROR_SUCCESS
                //
                // ptrBuffer will have dwSize/sizeof(TAGREF) values filled with transform tagrefs

                for (i = 0; i < dwSize / sizeof(TAGREF); ++i) {

                    trTransform = ptrBuffer[i];

                    // see below what we do with trTransform

                }


            - Enumerate transforms one by one using macros:

                SdbGetFirstMsiTransformForPackage(hSDB, trMatch)
                SdbGetNextMsiTransformForPackage(hSDB, trMatch, trPrevTransform)

                trTransform = SdbGetFirstMsiTransformForPackage(hSDB, trMatch);
                while (trTransform != TAGREF_NULL) {

                    //
                    // see below what we do with trTansform
                    //


                    trTransform = SdbGetNextMsiTransformForPackage(hSDB, trMatch, trTransform);
                }


        5. Read the transforms and extract transform files if available

           a. Read information:

           BOOL
           SdbReadMsiTransformInfo(
           IN  HSDB   hSDB,                         // db handle
           IN  TAGREF trTransformRef,               // trTransform obtained above
           OUT PSDBMSITRANSFORMINFO pTransformInfo  // pointer to SDBMSITRANSFORMINFO structure
           );

           SDBMSITRANSFORMINFO MsiTransformInfo;
           //
           // Members of the structure:
           //
           // LPCWSTR   lpszTransformName;     // name of the transform
           // TAGREF    trTransform;           // tagref of this transform
           // TAGREF    trFile;                // tagref of file for this transform (bits)

           bSuccess = SdbReadMsiTransformInfo(hSDB, trTransform, &MsiTransformInfo);

           if (bSuccess) {
               //
               // MsiTransformInfo.lpszTransformName is the name of the transform (e.g. "ExperimentalTransform2"
               // from xml above. The bits are available for extraction if MsiTransformInfo.trFile != TAGREF_NULL
               //


           }

           b. Extract Transform bits:

           The structure pointed to by pTransformInfo should be obtained by calling SdbReadMsiTransformInfo

           BOOL
           SdbCreateMsiTransformFile(
           IN  HSDB hSDB,                              // db handle
           IN  LPCTSTR lpszFileName,                   // filename to write data to
           IN  PSDBMSITRANSFORMINFO pTransformInfo     // pointer to the transform structure
           );

           bSuccess = SdbCreateMsiTransformFile(hSDB, L"c:\foo\mytransform.msi", &MsiTransformInfo);


    --*/

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\lib\write.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        write.c

    Abstract:

        This module implements low level primitives that are win32 compatible.

    Author:

        dmunsil     created     sometime in 1999

    Revision History:

--*/

#include "sdbp.h"

#define ALLOCATION_INCREMENT 65536 // 64K bytes

BOOL
SdbpWriteBufferedData(
    PDB         pdb,
    DWORD       dwOffset,
    const PVOID pBuffer,
    DWORD       dwSize)
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Appends the specified buffer to the mapped view of the db.
--*/
{
    if (!pdb->bWrite) {
        DBGPRINT((sdlError, "SdbpWriteBufferedData", "Invalid parameter.\n"));
        return FALSE;
    }

    //
    // Reallocate the buffer if necessary
    //
    if (dwOffset + dwSize > pdb->dwAllocatedSize) {

        DWORD  dwNewAllocation;
        PVOID* pNewBase;

        dwNewAllocation = dwOffset + dwSize + ALLOCATION_INCREMENT;
        pNewBase = SdbAlloc(dwNewAllocation);
        
        if (pNewBase == NULL) {
            DBGPRINT((sdlError,
                      "SdbpWriteBufferedData",
                      "Failed to allocate %d bytes.\n",
                      dwNewAllocation));
            return FALSE;
        }

        if (pdb->pBase) {
            memcpy(pNewBase, pdb->pBase, pdb->dwAllocatedSize);
            SdbFree(pdb->pBase);
        }
        pdb->pBase = pNewBase;
        pdb->dwAllocatedSize = dwNewAllocation;
    }

    //
    // Copy in the new bytes.
    //
    memcpy((PBYTE)pdb->pBase + dwOffset, pBuffer, dwSize);

    //
    // Adjust the size.
    //
    if (dwOffset + dwSize > pdb->dwSize) {
        pdb->dwSize = dwOffset + dwSize;
    }

    return TRUE;
}


HANDLE
SdbpCreateFile(
    IN  LPCWSTR   szPath,       // the full path to the database file to be created
    IN  PATH_TYPE eType         // DOS_PATH for the popular DOS paths or NT_PATH for
                                // nt internal paths.
    )
/*++
    Return: The handle to the created file or INVALID_HANDLE_VALUE if it fails.

    Desc:   Creates a file with the path specified.
--*/
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING    UnicodeString;
    HANDLE            hFile = INVALID_HANDLE_VALUE;
    HRESULT           status;
    RTL_RELATIVE_NAME RelativeName;

    RtlInitUnicodeString(&UnicodeString, szPath);

    if (eType == DOS_PATH) {
        if (!RtlDosPathNameToNtPathName_U(UnicodeString.Buffer,
                                          &UnicodeString,
                                          NULL,
                                          &RelativeName)) {
            DBGPRINT((sdlError,
                      "SdbpCreateFile",
                      "Failed to convert DOS path \"%s\"\n",
                      szPath));
            return INVALID_HANDLE_VALUE;
        }
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          0,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_OVERWRITE_IF,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    if (eType == DOS_PATH) {
        RtlFreeUnicodeString(&UnicodeString);
    }

    if (!NT_SUCCESS(status)) {
        DBGPRINT((sdlError,
                  "SdbpCreateFile",
                  "Failed to create the file \"%s\". Status 0x%x\n",
                  szPath,
                  status));
        return INVALID_HANDLE_VALUE;
    }

    return hFile;
}


void
SdbpDeleteFile(
    IN  LPCWSTR   szPath,       // the full path to the database file to be deleted.
    IN  PATH_TYPE eType         // DOS_PATH for the popular DOS paths or NT_PATH for
                                // nt internal paths.
    )
/*++
    Return: ?

    Desc:   ?.
--*/
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    UnicodeString;
    RTL_RELATIVE_NAME RelativeName;
    NTSTATUS          status;

    RtlInitUnicodeString(&UnicodeString, szPath);

    if (eType == DOS_PATH) {
        if (!RtlDosPathNameToNtPathName_U(UnicodeString.Buffer,
                                          &UnicodeString,
                                          NULL,
                                          &RelativeName)) {
            DBGPRINT((sdlError,
                      "SdbpDeleteFile",
                      "Failed to convert DOS path \"%s\"\n",
                      szPath));
            return;
        }
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtDeleteFile(&ObjectAttributes);

    if (DOS_PATH == eType) {
        RtlFreeUnicodeString(&UnicodeString);
    }

    if (!NT_SUCCESS(status)) {
        DBGPRINT((sdlError,
                  "SdbpDeleteFile",
                  "Failed to delete the file \"%s\". Status 0x%x\n",
                  szPath,
                  status));
    }
}


PDB
SdbCreateDatabase(
    IN  LPCWSTR   szPath,
    IN  PATH_TYPE eType
    )
/*++
    Return: A pointer to the created database.

    Desc:   Self explanatory.
--*/
{
    HANDLE      hFile;
    DB_HEADER   DBHeader;
    PDB         pdb;
    SYSTEMTIME  time;

    hFile = SdbpCreateFile(szPath, eType);

    if (hFile == INVALID_HANDLE_VALUE) {
        DBGPRINT((sdlError, "SdbCreateDatabase", "Failed to create the database.\n"));
        return NULL;
    }

    pdb = SdbAlloc(sizeof(DB));

    if (pdb == NULL) {
        DBGPRINT((sdlError,
                  "SdbCreateDatabase",
                  "Failed to allocate %d bytes.\n",
                  sizeof(DB)));
        goto err1;
    }

    ZeroMemory(pdb, sizeof(DB));

    pdb->hFile = hFile;
    pdb->bWrite = TRUE;

    //
    // Create the initial header
    //
    DBHeader.dwMagic = SHIMDB_MAGIC;
    DBHeader.dwMajorVersion = SHIMDB_MAJOR_VERSION;

    SdbpGetCurrentTime(&time);

    DBHeader.dwMinorVersion = time.wDay + time.wMonth * 100 + (time.wYear - 2000) * 10000;

    if (!SdbpWriteBufferedData(pdb, 0, &DBHeader, sizeof(DB_HEADER))) {
        DBGPRINT((sdlError,
                  "SdbCreateDatabase",
                  "Failed to write the header to disk.\n"));
        goto err2;
    }

    return pdb;

err2:
    SdbFree(pdb);

err1:
    SdbpCloseFile(hFile);

    return NULL;
}

//
// WRITE functions
//

TAGID
SdbBeginWriteListTag(
    IN  PDB pdb,
    IN  TAG tTag
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    TAGID tiReturn;

    assert(pdb);

    //
    // The tagid is just the file offset to the tag
    //
    tiReturn = pdb->dwSize;

    if (GETTAGTYPE(tTag) != TAG_TYPE_LIST) {
        DBGPRINT((sdlError, "SdbBeginWriteListTag", "This is not a list tag.\n"));
        return TAGID_NULL;
    }

    if (!SdbpWriteTagData(pdb, tTag, NULL, TAG_SIZE_UNFINISHED)) {
        DBGPRINT((sdlError, "SdbBeginWriteListTag", "Failed to write the data.\n"));
        return TAGID_NULL;
    }

    return tiReturn;
}


BOOL
SdbEndWriteListTag(
    IN  PDB   pdb,
    IN  TAGID tiList
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    DWORD dwSize;
    DWORD i;

    assert(pdb);

    if (GETTAGTYPE(SdbGetTagFromTagID(pdb, tiList)) != TAG_TYPE_LIST) {
        DBGPRINT((sdlError, "SdbEndWriteListTag", "This is not a list tag.\n"));
        return FALSE;
    }

    //
    // The size of this tag is the offset from the beginning to the end of the
    // file, minus the tag and size itself.
    //
    dwSize = pdb->dwSize - tiList - sizeof(TAG) - sizeof(DWORD);

    if (!SdbpWriteBufferedData(pdb, tiList + sizeof(TAG), &dwSize, sizeof(DWORD))) {
        DBGPRINT((sdlError, "SdbEndWriteListTag", "Failed to write the data.\n"));
        return FALSE;
    }

    //
    // Check if we need to add index entries
    //
    for (i = 0; i < pdb->dwIndexes; i++) {

        //
        // Is there an index of this type, that is currently active?
        //
        if (pdb->aIndexes[i].tWhich == SdbGetTagFromTagID(pdb, tiList) &&
            pdb->aIndexes[i].bActive) {

            //
            // We have an index on this tag, check for a key.
            //
            TAGID        tiKey;
            INDEX_RECORD IndexRecord;
            BOOL         bWrite = TRUE;     // this is the variable that determines
                                            // whether we actually write an index entry,
                                            // used for "uniqueKey" indexes
            
            PINDEX_INFO  pIndex = &pdb->aIndexes[i];

            //
            // Find the key value and fill out INDEX_RECORD structure.
            //
            tiKey = SdbFindFirstTag(pdb, tiList, pIndex->tKey);

            //
            // If we don't have a key, that's OK. This tag will get indexed with key 0
            //
            if (tiKey) {
                IndexRecord.ullKey = SdbpTagToKey(pdb, tiKey);
            } else {
                IndexRecord.ullKey = (ULONGLONG)0;
            }

            IndexRecord.tiRef = tiList;

            //
            // If the index is of "UniqueKey" type we don't write anything at
            // this time, we just collect the info and write it all out at the end.
            //
            if (pIndex->bUniqueKey) {
                //
                // Use the buffer
                //
                // has the last written key been the same as this one?
                //
                if (pIndex->ullLastKey == IndexRecord.ullKey) {
                    bWrite = FALSE;
                } else {
                    //
                    // Actually write the key, store the buffer
                    //
                    pIndex->ullLastKey = IndexRecord.ullKey;
                }
            }

            if (bWrite) {
                //
                // Check for walking off the end of the index
                //
                if (pIndex->dwIndexEntry == pIndex->dwIndexEnd) {
                    DBGPRINT((sdlError,
                              "SdbEndWriteListTag",
                              "Too many index entries for tag %04x, key %04x.\n",
                              pdb->aIndexes[i].tWhich,
                              pdb->aIndexes[i].tKey));
                    return FALSE;
                }

                //
                // Stick in the new entry, and increment
                //
                SdbpWriteBufferedData(pdb,
                                      pIndex->dwIndexEntry,
                                      &IndexRecord,
                                      sizeof(INDEX_RECORD));
                
                pIndex->dwIndexEntry += sizeof(INDEX_RECORD);
            }
        }
    }

    return TRUE;
}


BOOL
SdbWriteNULLTag(
    IN  PDB pdb,
    IN  TAG tTag
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    assert(pdb);

    if (GETTAGTYPE(tTag) != TAG_TYPE_NULL) {
        return FALSE;
    }

    if (!SdbpWriteTagData(pdb, tTag, NULL, 0)) {
        return FALSE;
    }

    return TRUE;
}

#define WRITETYPEDTAG(ttype, type)                                          \
{                                                                           \
    assert(pdb);                                                            \
                                                                            \
    if (GETTAGTYPE(tTag) != ttype) {                                        \
        return FALSE;                                                       \
    }                                                                       \
                                                                            \
    if (!SdbpWriteTagData(pdb, tTag, &xData, sizeof(type))) {               \
        return FALSE;                                                       \
    }                                                                       \
                                                                            \
    return TRUE;                                                            \
}


BOOL SdbWriteBYTETag(PDB pdb, TAG tTag, BYTE xData)
{
    WRITETYPEDTAG(TAG_TYPE_BYTE, BYTE);
}


BOOL SdbWriteWORDTag(PDB pdb, TAG tTag, WORD xData)
{
    WRITETYPEDTAG(TAG_TYPE_WORD, WORD);
}

BOOL SdbWriteDWORDTag(PDB pdb, TAG tTag, DWORD xData)
{
    WRITETYPEDTAG(TAG_TYPE_DWORD, DWORD);
}

BOOL SdbWriteQWORDTag(PDB pdb, TAG tTag, ULONGLONG xData)
{
    WRITETYPEDTAG(TAG_TYPE_QWORD, ULONGLONG);
}


BOOL
SdbWriteStringTag(
    IN  PDB     pdb,
    IN  TAG     tTag,
    IN  LPCWSTR pwszData
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    TAG_TYPE ttThis;

    assert(pdb);

    ttThis = GETTAGTYPE(tTag);

    //
    // It must be either a STRING type, in which case we
    // write it directly, or a STRINGREF, in which case we
    // put it in the string table and add a string table reference
    // in place here.
    //
    if (ttThis == TAG_TYPE_STRINGREF) {
        STRINGREF srThis;

        srThis = SdbpAddStringToTable(pdb, pwszData);

        if (srThis == STRINGREF_NULL) {
            return FALSE;
        }

        return SdbWriteStringRefTag(pdb, tTag, srThis);
    } else if (ttThis == TAG_TYPE_STRING) {

        return SdbWriteStringTagDirect(pdb, tTag, pwszData);
    }

    return FALSE;
}


BOOL
SdbWriteBinaryTag(
    IN  PDB   pdb,
    IN  TAG   tTag,
    IN  PBYTE pBuffer,
    IN  DWORD dwSize
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    assert(pdb);

    if (GETTAGTYPE(tTag) != TAG_TYPE_BINARY) {
        return FALSE;
    }

    if (!SdbpWriteTagData(pdb, tTag, pBuffer, dwSize)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
SdbWriteBinaryTagFromFile(
    IN  PDB     pdb,
    IN  TAG     tTag,
    IN  LPCWSTR pwszPath
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    HANDLE          hTempFile;
    DWORD           dwSize;
    BOOL            bSuccess = FALSE;
    PBYTE           pBuffer;
    LARGE_INTEGER   liOffset;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS        status;

    assert(pdb && pwszPath);

    hTempFile = SdbpOpenFile(pwszPath, DOS_PATH);

    if (hTempFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    dwSize = SdbpGetFileSize(hTempFile);

    pBuffer = SdbAlloc(dwSize);
    if (pBuffer == NULL) {
        bSuccess = FALSE;
        goto err1;
    }

    liOffset.LowPart = 0;
    liOffset.HighPart = 0;

    status = NtReadFile(hTempFile,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        pBuffer,
                        dwSize,
                        &liOffset,
                        NULL);

    if (!NT_SUCCESS(status)) {
        DBGPRINT((sdlError,
                  "SdbWriteBinaryTagFromFile",
                  "Failed to read data. Status: 0x%x.\n",
                  status));
        goto err2;
    }

    bSuccess = SdbWriteBinaryTag(pdb, tTag, pBuffer, dwSize);

err2:
    SdbFree(pBuffer);

err1:
    SdbpCloseFile(hTempFile);

    return bSuccess;
}


BOOL
SdbpWriteTagData(
    PDB         pdb,
    TAG         tTag,
    const PVOID pBuffer,
    DWORD       dwSize
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    BYTE bPadding = 0xDB;

    assert(pdb);

    //
    // Write the tag.
    //
    if (!SdbpWriteBufferedData(pdb, pdb->dwSize, &tTag, sizeof(TAG))) {
        return FALSE;
    }

    //
    // Write the size.
    //
    if (GETTAGTYPE(tTag) >= TAG_TYPE_LIST) {
        if (!SdbpWriteBufferedData(pdb, pdb->dwSize, &dwSize, sizeof(DWORD))) {
            return FALSE;
        }
    }

    //
    // Write the data.
    //
    if (pBuffer) {

        if (!SdbpWriteBufferedData(pdb, pdb->dwSize, pBuffer, dwSize)) {
            return FALSE;
        }
        
        //
        // Align the tag.
        //
        if (dwSize & 1) {
            if (!SdbpWriteBufferedData(pdb, pdb->dwSize, &bPadding, 1)) {
                DBGPRINT((sdlError, "SdbpWriteTagData", "Failed to write padding data 1 byte\n"));
                return FALSE;
            }
        }
    }

    return TRUE;
}


BOOL
SdbWriteStringRefTag(
    IN  PDB       pdb,
    IN  TAG       tTag,
    IN  STRINGREF srData
    )
{
    assert(pdb);

    if (GETTAGTYPE(tTag) != TAG_TYPE_STRINGREF) {
        return FALSE;
    }

    if (!SdbpWriteTagData(pdb, tTag, &srData, sizeof(srData))) {
        return FALSE;
    }

    return TRUE;
}


BOOL
SdbWriteStringTagDirect(
    IN  PDB     pdb,
    IN  TAG     tTag,
    IN  LPCWSTR pwszData
    )
{
    DWORD dwSize;

    assert(pdb && pwszData);

    dwSize = (wcslen(pwszData) + 1) * sizeof(WCHAR);

    if (GETTAGTYPE(tTag) != TAG_TYPE_STRING) {
        return FALSE;
    }

    if (!SdbpWriteTagData(pdb, tTag, (const PVOID)pwszData, dwSize)) {
        return FALSE;
    }

    return TRUE;
}

void
SdbCloseDatabase(
    IN  PDB pdb         // IN - DB to close
    )
/*++

    Params: described above.

    Return: void.

    Desc:   Closes a database and frees all memory and file handles associated with it.
--*/
{
    assert(pdb != NULL);

    // copy the string table and indexes onto the end of the file
    if (pdb->bWrite && pdb->pdbStringTable != NULL) {

        TAGID tiString;

        tiString = SdbFindFirstTag(pdb->pdbStringTable, TAGID_ROOT, TAG_STRINGTABLE_ITEM);

        if (tiString != TAGID_NULL) {
            TAGID tiTable;

            tiTable = SdbBeginWriteListTag(pdb, TAG_STRINGTABLE);

            while (tiString != TAGID_NULL) {

                TCHAR* pszTemp;

                pszTemp = SdbGetStringTagPtr(pdb->pdbStringTable, tiString);

                if (pszTemp == NULL) {
                    DBGPRINT((sdlWarning,
                              "SdbCloseDatabase",
                              "Failed to read a string.\n"));
                    break;
                }

                if (!SdbWriteStringTagDirect(pdb, TAG_STRINGTABLE_ITEM, pszTemp)) {
                    DBGPRINT((sdlError,
                              "SdbCloseDatabase",
                              "Failed to write stringtable item\n"));
                    break;
                }

                tiString = SdbFindNextTag(pdb->pdbStringTable, TAGID_ROOT, tiString);
            }

            if (!SdbEndWriteListTag(pdb, tiTable)) {
                DBGPRINT((sdlError,
                          "SdbCloseDatabase",
                          "Failed to write end list tag for the string table\n"));
                goto err1;
            }
        }
    }

    //
    // Now sort all the indexes if necessary.
    //
    if (pdb->bWrite) {
        DWORD i;

        for (i = 0; i < pdb->dwIndexes; ++i) {
            if (!SdbpSortIndex(pdb, pdb->aIndexes[i].tiIndex)) {
                DBGPRINT((sdlError,
                          "SdbCloseDatabase",
                          "Failed to sort index.\n"));
                goto err1;
            }
        }
    }

err1:
    if (pdb->pdbStringTable != NULL) {
        SdbCloseDatabase(pdb->pdbStringTable);
        pdb->pdbStringTable = NULL;
        
        //
        // Delete the file
        //
        if (pdb->ustrTempStringtable.Buffer) {
            SdbpDeleteFile(pdb->ustrTempStringtable.Buffer, DOS_PATH);
        }

        FREE_TEMP_STRINGTABLE(pdb);
    }

    //
    // The string hash is used when writing to the database for the purpose of
    // caching the string table.
    //
    if (pdb->pStringHash != NULL) {
        HashFree(pdb->pStringHash);
        pdb->pStringHash = NULL;
    }

    if (pdb->pBase != NULL) {
        if (pdb->bWrite) {
            
            LARGE_INTEGER   liOffset;
            IO_STATUS_BLOCK IoStatusBlock;
            HRESULT         status;

            liOffset.LowPart = 0;
            liOffset.HighPart = 0;

            //
            // Flush the buffer to disk.
            //
            status = NtWriteFile(pdb->hFile,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &IoStatusBlock,
                                 pdb->pBase,
                                 pdb->dwSize,
                                 &liOffset,
                                 NULL);

            if (!NT_SUCCESS(status)) {
                DBGPRINT((sdlError, "SdbCloseDatabase", "Failed to write the sdb.\n"));
            }
            
            SdbFree(pdb->pBase);
            pdb->pBase = NULL;
            
            // BUGBUG: should we call SdbpUnmapAndCloseDB in this case ?
        } else {
            SdbpUnmapAndCloseDB(pdb);
        }
    }

    if (pdb->hFile != INVALID_HANDLE_VALUE) {
        SdbpCloseFile(pdb->hFile);
        pdb->hFile = INVALID_HANDLE_VALUE;
    }

    SdbFree(pdb);
}


//
// INDEX functions (used during write)
//
BOOL
SdbDeclareIndex(
    IN  PDB      pdb,
    IN  TAG      tWhich,
    IN  TAG      tKey,
    IN  DWORD    dwEntries,
    IN  BOOL     bUniqueKey,
    OUT INDEXID* piiIndex
    )
{
    BOOL  bReturn = FALSE;
    DWORD dwSize = 0;
    TAGID tiIndex = TAGID_NULL;
    PVOID pFiller = NULL;
    TAGID tiIndexBits = TAGID_NULL;
    DWORD dwFlags = 0;

    if (bUniqueKey) {
        // this is a special unique-key index which we will write out
        dwFlags |= SHIMDB_INDEX_UNIQUE_KEY;
    }

    if (GETTAGTYPE(tWhich) != TAG_TYPE_LIST) {
        DBGPRINT((sdlError, "SdbDeclareIndex", "Illegal to index non-LIST tag.\n"));
        goto err1;
    }

    if (GETTAGTYPE(tKey) == TAG_TYPE_LIST) {
        DBGPRINT((sdlError, "SdbDeclareIndex", "Illegal to use LIST type as a key.\n"));
        goto err1;
    }

    if (!pdb->bWritingIndexes) {
        if (pdb->dwSize != sizeof(DB_HEADER)) {
            DBGPRINT((sdlError,
                      "SdbDeclareIndex",
                      "Began declaring indexes after writing other data.\n"));
            goto err1;
        }
        pdb->bWritingIndexes = TRUE;
        pdb->tiIndexes = SdbBeginWriteListTag(pdb, TAG_INDEXES);
        if (!pdb->tiIndexes) {
            DBGPRINT((sdlError, "SdbDeclareIndex", "Error beginning TAG_INDEXES.\n"));
            goto err1;
        }
    }

    if (pdb->dwIndexes == MAX_INDEXES) {
        DBGPRINT((sdlError,
                  "SdbDeclareIndex",
                  "Hit limit of %d indexes. Increase MAX_INDEXES and recompile.\n",
                  MAX_INDEXES));
        goto err1;
    }

    tiIndex = SdbBeginWriteListTag(pdb, TAG_INDEX);
    if (!tiIndex) {
        DBGPRINT((sdlError, "SdbDeclareIndex", "Error beginning TAG_INDEX.\n"));
        goto err1;
    }

    if (!SdbWriteWORDTag(pdb, TAG_INDEX_TAG, tWhich)) {
        DBGPRINT((sdlError, "SdbDeclareIndex", "Error writing TAG_INDEX_TAG.\n"));
        goto err1;
    }

    if (!SdbWriteWORDTag(pdb, TAG_INDEX_KEY, tKey)) {
        DBGPRINT((sdlError, "SdbDeclareIndex", "Error writing TAG_INDEX_KEY.\n"));
        goto err1;
    }

    if (dwFlags && !SdbWriteDWORDTag(pdb, TAG_INDEX_FLAGS, dwFlags)) {
        DBGPRINT((sdlError, "SdbDeclareIndex", "Error writing TAG_INDEX_FLAGS.\n"));
        goto err1;
    }

    //
    // allocate and write out space-filler garbage, which
    // will be filled in with the real index later.
    //
    dwSize = dwEntries * sizeof(INDEX_RECORD);
    pFiller = SdbAlloc(dwSize);
    if (!pFiller) {
        goto err1;
    }

    tiIndexBits = pdb->dwSize;

    if (!SdbWriteBinaryTag(pdb, TAG_INDEX_BITS, pFiller, dwSize)) {
        DBGPRINT((sdlError, "SdbDeclareIndex", "Error writing TAG_INDEX_BITS.\n"));
        goto err1;
    }

    SdbFree(pFiller);
    pFiller = NULL;

    if (!SdbEndWriteListTag(pdb, tiIndex)) {
        DBGPRINT((sdlError, "SdbDeclareIndex", "Error ending TAG_INDEX.\n"));
        goto err1;
    }

    pdb->aIndexes[pdb->dwIndexes].tWhich = tWhich;
    pdb->aIndexes[pdb->dwIndexes].tKey = tKey;
    pdb->aIndexes[pdb->dwIndexes].tiIndex = tiIndexBits;
    pdb->aIndexes[pdb->dwIndexes].dwIndexEntry = tiIndexBits + sizeof(TAG) + sizeof(DWORD);
    pdb->aIndexes[pdb->dwIndexes].dwIndexEnd = pdb->aIndexes[pdb->dwIndexes].dwIndexEntry + dwSize;
    pdb->aIndexes[pdb->dwIndexes].ullLastKey = 0;
    pdb->aIndexes[pdb->dwIndexes].bUniqueKey = bUniqueKey;

    *piiIndex = pdb->dwIndexes;

    pdb->dwIndexes++;

    bReturn = TRUE;

err1:

    if (pFiller) {
        SdbFree(pFiller);
        pFiller = NULL;
    }

    return bReturn;
}

BOOL
SdbCommitIndexes(
    IN  PDB pdb
    )
{
    pdb->bWritingIndexes = FALSE;
    if (!SdbEndWriteListTag(pdb, pdb->tiIndexes)) {
        DBGPRINT((sdlError, "SdbDeclareIndex", "Error ending TAG_INDEXES.\n"));
        return FALSE;
    }
    return TRUE;
}

BOOL
SdbStartIndexing(
    IN  PDB     pdb,
    IN  INDEXID iiWhich
    )
{
    if (iiWhich >= pdb->dwIndexes) {
        return FALSE;
    }
    pdb->aIndexes[iiWhich].bActive = TRUE;
    return TRUE;
}

BOOL
SdbStopIndexing(
    IN  PDB     pdb,
    IN  INDEXID iiWhich
    )
{
    if (iiWhich >= pdb->dwIndexes) {
        return FALSE;
    }
    pdb->aIndexes[iiWhich].bActive = FALSE;
    return TRUE;
}

int __cdecl
CompareIndexRecords(
    const void* p1,
    const void* p2
    )
/*++

    Params: BUGBUG: comments ?

    Return: TRUE if successful, FALSE otherwise.

    Desc:   Callback used by qsort.
--*/
{
    ULONGLONG ullKey1;
    ULONGLONG ullKey2;

    ullKey1 = ((INDEX_RECORD UNALIGNED*)p1)->ullKey;
    ullKey2 = ((INDEX_RECORD UNALIGNED*)p2)->ullKey;

    if (ullKey1 == ullKey2) {
        TAGID ti1, ti2;

        //
        // Secondary sort on TAGID, so we'll always walk
        // the exe records from the beginning to the end, and
        // take advantage of cache read-ahead
        //
        ti1 = ((INDEX_RECORD UNALIGNED*)p1)->tiRef;
        ti2 = ((INDEX_RECORD UNALIGNED*)p2)->tiRef;

        if (ti1 == ti2) {
            return 0;
        } else if (ti1 < ti2) {
            return -1;
        } else {
            return 1;
        }
    } else if (ullKey1 < ullKey2) {
        return -1;
    } else {
        return 1;
    }
}

BOOL
SdbpSortIndex(
    PDB   pdb,
    TAGID tiIndexBits
    )
/*++

    Params: BUGBUG: comments ?

    Return: TRUE if successful, FALSE otherwise.

    Desc:   Sorts an index.
--*/
{
    INDEX_RECORD* pIndexRecords = NULL;
    DWORD         dwRecords = 0;

    if (SdbGetTagFromTagID(pdb, tiIndexBits) != TAG_INDEX_BITS) {
        DBGPRINT((sdlError, "SdbpSortIndex", "Not an index.\n"));
        return FALSE;
    }

    pIndexRecords = SdbpGetMappedTagData(pdb, tiIndexBits);

    if (pIndexRecords == NULL) {
        DBGPRINT((sdlError,
                  "SdbpSortIndex",
                  "Index referenced by 0x%x is not valid\n",
                  tiIndexBits));
        return FALSE;
    }

    dwRecords = SdbGetTagDataSize(pdb, tiIndexBits) / sizeof(INDEX_RECORD);

    qsort(pIndexRecords, dwRecords, sizeof(INDEX_RECORD), CompareIndexRecords);

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////
//
// String writing routine
//

STRINGREF
SdbpAddStringToTable(
    PDB          pdb,
    LPCTSTR      szData)
{
    STRINGREF srReturn = STRINGREF_NULL;
    BOOL      bSuccess;
    TAGID     tiTemp;

    assert(pdb);
    
    //
    // Add a string table if one doesn't exist
    //
    if (!pdb->pdbStringTable) {
        DWORD dwLength;
        TCHAR szBuffer[MAX_PATH];
        TCHAR szTempFile[MAX_PATH];

        //
        // Create temp string table db
        //
        dwLength = GetTempPath(CHARCOUNT(szBuffer), szBuffer);
        if (!dwLength || dwLength > CHARCOUNT(szBuffer)) {
            DBGPRINT((sdlError,
                      "SdbpAddStringToTable",
                      "Error Gettting temp path 0x%lx\n",
                      GetLastError()));
            goto err1;
        }

        // 
        // We got the directory, generate the file now
        // 
        dwLength = GetTempFileName(szBuffer, TEXT("SDB"), 0, szTempFile);
        if (!dwLength) {
            DBGPRINT((sdlError,
                      "SdbpAddStringToTable",
                      "Error Gettting temp filename 0x%lx\n",
                      GetLastError()));
            goto err1;
        }

        //
        // If we are successful, we'd have a string table file now.
        //
        pdb->pdbStringTable = SdbCreateDatabase(szTempFile, DOS_PATH);
        if (!pdb->pdbStringTable) {
            goto err1;
        }

        //
        // success !!! set the name of the file into the pdb so we could remove it later
        //
        if (!COPY_TEMP_STRINGTABLE(pdb, szTempFile)) {
            DBGPRINT((sdlError,
                      "SdbpAddStringToTable",
                      "Error copying string table temp filename\n"));
            goto err1;
        }
    }

    if (!pdb->pStringHash) {
        pdb->pStringHash = HashCreate();
        if (pdb->pStringHash == NULL) {
            DBGPRINT((sdlError,
                      "SdbpAddStringToTable",
                      "Error creating hash table\n"));
            goto err1;
        }
    }

    srReturn = HashFindString((PSTRHASH)pdb->pStringHash, szData);
    if (!srReturn) {
        //
        // A stringref is the offset from the beginning of the string table to
        // the string tag itself. We have to adjust for the header of the temporary
        // DB, and the tag and size that will be written later.
        //
        srReturn = pdb->pdbStringTable->dwSize - sizeof (DB_HEADER) + sizeof(TAG) + sizeof(DWORD);

        bSuccess = SdbWriteStringTagDirect(pdb->pdbStringTable, TAG_STRINGTABLE_ITEM, szData);

        if (!bSuccess) {
            DBGPRINT((sdlError,
                      "SdbpAddStringToTable",
                      "Failed to write stringtableitem into the string table\n"));
            srReturn = STRINGREF_NULL;
        }

        HashAddString((PSTRHASH)pdb->pStringHash, szData, srReturn);
    }

err1:

    return srReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\sdbapi\kmode\ntkmode.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        ntKMode.c

    Abstract:

        This module implements low level primitives for kernel mode implementation.

    Author:

        VadimB      created     sometime in 2000

    Revision History:


--*/

#include "sdbp.h"


#ifdef KERNEL_MODE

extern TAG g_rgDirectoryTags[];


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SdbTagIDToTagRef)
#pragma alloc_text(PAGE, SdbTagRefToTagID)
#pragma alloc_text(PAGE, SdbInitDatabaseInMemory)
#pragma alloc_text(PAGE, SdbpOpenAndMapFile)
#pragma alloc_text(PAGE, SdbpUnmapAndCloseFile)
#pragma alloc_text(PAGE, SdbpUpcaseUnicodeStringToMultiByteN)
#pragma alloc_text(PAGE, SdbpQueryFileDirectoryAttributesNT)
#pragma alloc_text(PAGE, SdbpDoesFileExists_U)
#pragma alloc_text(PAGE, SdbGetFileInfo)
#pragma alloc_text(PAGE, DuplicateUnicodeString)
#pragma alloc_text(PAGE, SdbpCreateUnicodeString)
#pragma alloc_text(PAGE, SdbpGetFileDirectoryAttributesNT)
#endif

BOOL
SdbTagIDToTagRef(
    IN  HSDB    hSDB,
    IN  PDB     pdb,        // PDB the TAGID is from
    IN  TAGID   tiWhich,    // TAGID to convert
    OUT TAGREF* ptrWhich    // converted TAGREF
    )
/*++
    Return: TRUE if a TAGREF was found, FALSE otherwise.

    Desc:   Converts a PDB and TAGID into a TAGREF, by packing the high bits of the
            TAGREF with a constant that tells us which PDB, and the low bits with
            the TAGID.
--*/
{
    PSDBCONTEXT pSdbContext = (PSDBCONTEXT)hSDB;
    BOOL        bReturn = FALSE;

    //
    // In kernel mode we only support sysmain db
    //
    *ptrWhich = tiWhich | PDB_MAIN;
    bReturn = TRUE;

    if (!bReturn) {
        DBGPRINT((sdlError, "SdbTagIDToTagRef", "Bad PDB.\n"));
        *ptrWhich = TAGREF_NULL;
    }

    return bReturn;
}


BOOL
SdbTagRefToTagID(
    IN  HSDB   hSDB,
    IN  TAGREF trWhich,     // TAGREF to convert
    OUT PDB*   ppdb,        // PDB the TAGREF is from
    OUT TAGID* ptiWhich     // TAGID within that PDB
    )
/*++
    Return: TRUE if the TAGREF is valid and was converted, FALSE otherwise.

    Desc:   Converts a TAGREF type to a TAGID and a PDB. This manages the interface
            between NTDLL, which knows nothing of PDBs, and the shimdb, which manages
            three separate PDBs. The TAGREF incorporates the TAGID and a constant
            that tells us which PDB the TAGID is from. In this way, the NTDLL client
            doesn't need to know which DB the info is coming from.
--*/
{
    PSDBCONTEXT pSdbContext = (PSDBCONTEXT)hSDB;
    BOOL        bReturn = TRUE;
    TAGID       tiWhich = TAGID_NULL;
    PDB         pdb     = NULL;
    DWORD       dwMask;

    dwMask = trWhich & TAGREF_STRIP_PDB;
    if (dwMask != PDB_MAIN) {
        goto cleanup;
    }

    tiWhich = trWhich & TAGREF_STRIP_TAGID;
    pdb     = pSdbContext->pdbMain;
    
    //
    // See that we double-check here
    //
    if (pdb == NULL && tiWhich != TAGID_NULL) {
        DBGPRINT((sdlError, "SdbTagRefToTagID", "PDB dereferenced by this TAGREF is NULL\n"));
        bReturn = FALSE;
    }

cleanup:

    if (ppdb != NULL) {
        *ppdb = pdb;
    }

    if (ptiWhich != NULL) {
        *ptiWhich = tiWhich;
    }

    return bReturn;
}

HSDB
SdbInitDatabaseInMemory(
    IN  LPVOID  pDatabaseImage,
    IN  DWORD   dwImageSize
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    PSDBCONTEXT pContext;

    //
    // Initialize the context.
    //
    pContext = (PSDBCONTEXT)SdbAlloc(sizeof(SDBCONTEXT));
    if (pContext == NULL) {
        DBGPRINT((sdlError,
                  "SdbInitDatabaseInMemory",
                  "Failed to allocate %d bytes for HSDB\n",
                  sizeof(SDBCONTEXT)));
        return NULL;
    }

    //
    // Now open the database.
    //
    pContext->pdbMain = SdbpOpenDatabaseInMemory(pDatabaseImage, dwImageSize);
    if (pContext->pdbMain == NULL) {
        DBGPRINT((sdlError,
                  "SdbInitDatabaseInMemory",
                  "Unable to open main database at 0x%x size 0x%x\n",
                  pDatabaseImage,
                  dwImageSize));
        goto ErrHandle;
    }

    return (HSDB)pContext;

ErrHandle:

    if (pContext != NULL) {

        if (pContext->pdbMain != NULL) {
            SdbCloseDatabaseRead(pContext->pdbMain);
        }

        SdbFree(pContext);
    }

    return NULL;
}

//
// Open and map File
//

BOOL
SdbpOpenAndMapFile(
    IN  LPCWSTR        szPath,      // pointer to the fully-qualified filename
    OUT PIMAGEFILEDATA pImageData,  // pointer to IMAGEFILEDATA that receives
                                    // image-related information
    IN  PATH_TYPE      ePathType    // ignored
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Opens a file and maps it into memory.
--*/
{

    NTSTATUS          Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    ustrFileName;
    HANDLE            hSection = NULL;
    HANDLE            hFile    = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK   IoStatusBlock;
    SIZE_T            ViewSize = 0;
    PVOID             pBase = NULL;
    DWORD             dwFlags = 0;

    FILE_STANDARD_INFORMATION StandardInfo;

    if (pImageData->dwFlags & IMAGEFILEDATA_PBASEVALID) {
        //
        // special case, only headers are valid in our assumption
        //
        return TRUE;
    }

    //
    // Initialize return data
    //
    if (pImageData->dwFlags & IMAGEFILEDATA_HANDLEVALID) {
        hFile = pImageData->hFile;
        if (hFile != INVALID_HANDLE_VALUE) {
            dwFlags |= IMAGEFILEDATA_NOFILECLOSE;
        }
    }
    
    RtlZeroMemory(pImageData, sizeof(*pImageData));
    pImageData->hFile = INVALID_HANDLE_VALUE;

    if (hFile == INVALID_HANDLE_VALUE) {

        //
        // Open the file
        //
        RtlInitUnicodeString(&ustrFileName, szPath);

        InitializeObjectAttributes(&ObjectAttributes,
                                   &ustrFileName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        Status = ZwCreateFile(&hFile,
                              GENERIC_READ,
                              &ObjectAttributes,
                              &IoStatusBlock,
                              NULL,
                              FILE_ATTRIBUTE_NORMAL,
                              FILE_SHARE_READ,
                              FILE_OPEN,
                              FILE_SYNCHRONOUS_IO_NONALERT|FILE_NON_DIRECTORY_FILE,
                              NULL,
                              0);

        if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlError,
                      "SdbpOpenAndMapFile",
                      "ZwCreateFile failed status 0x%x\n",
                      Status));
            return FALSE;
        }

    }

    //
    // Query file size
    //
    Status = ZwQueryInformationFile(hFile,
                                    &IoStatusBlock,
                                    &StandardInfo,
                                    sizeof(StandardInfo),
                                    FileStandardInformation);
    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbpOpenAndMapFile",
                  "ZwQueryInformationFile (EOF) failed Status 0x%x\n",
                  Status));
        if (!(dwFlags & IMAGEFILEDATA_NOFILECLOSE)) {
            ZwClose(hFile);
        }
        return FALSE;
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwCreateSection(&hSection,
                             STANDARD_RIGHTS_REQUIRED |
                                SECTION_QUERY |
                                SECTION_MAP_READ,
                             &ObjectAttributes,
                             NULL,
                             PAGE_READONLY,
                             SEC_COMMIT,
                             hFile);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbpOpenAndMapFile",
                  "ZwOpenSectionFailed status 0x%x\n",
                  Status));
        if (!(dwFlags & IMAGEFILEDATA_NOFILECLOSE)) {
            ZwClose(hFile);
        }
        return FALSE;
    }

    Status = ZwMapViewOfSection(hSection,
                                NtCurrentProcess(),
                                &pBase,
                                0L,
                                0L,
                                NULL,
                                &ViewSize,
                                ViewUnmap,
                                0L,
                                PAGE_READONLY);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError,
                  "SdbpMapFile",
                  "NtMapViewOfSection failed Status 0x%x\n",
                  Status));

        ZwClose(hSection);
        if (!(dwFlags & IMAGEFILEDATA_NOFILECLOSE)) {
            ZwClose(hFile);
        }
        return FALSE;
    }

    pImageData->hFile    = hFile;
    pImageData->dwFlags  = dwFlags;
    pImageData->hSection = hSection;
    pImageData->pBase    = pBase;
    pImageData->ViewSize = ViewSize;
    pImageData->FileSize = StandardInfo.EndOfFile.QuadPart;

    return TRUE;
}


BOOL
SdbpUnmapAndCloseFile(
    IN  PIMAGEFILEDATA pImageData   // pointer to IMAGEFILEDATE - image-related information
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Closes and unmaps an opened file.
--*/
{
    BOOL     bSuccess = TRUE;
    NTSTATUS Status;

    if (pImageData->dwFlags & IMAGEFILEDATA_PBASEVALID) { // externally supplied pointer 
        RtlZeroMemory(pImageData, sizeof(*pImageData));
        return TRUE;
    }

    if (pImageData->pBase != NULL) {
        Status = ZwUnmapViewOfSection(NtCurrentProcess(), pImageData->pBase);
        if (!NT_SUCCESS(Status)) {
            bSuccess = FALSE;
            DBGPRINT((sdlError,
                      "SdbpCloseAndUnmapFile",
                      "ZwUnmapViewOfSection failed Status 0x%x\n",
                      Status));
        }
        pImageData->pBase = NULL;
    }

    if (pImageData->hSection != NULL) {
        Status = ZwClose(pImageData->hSection);
        if (!NT_SUCCESS(Status)) {
            bSuccess = FALSE;
            DBGPRINT((sdlError,
                      "SdbpCloseAndUnmapFile",
                      "ZwClose on section failed Status 0x%x\n",
                      Status));
        }

        pImageData->hSection = NULL;
    }

    if (pImageData->dwFlags & IMAGEFILEDATA_NOFILECLOSE) {

        pImageData->hFile = INVALID_HANDLE_VALUE;

    } else {

        if (pImageData->hFile != INVALID_HANDLE_VALUE) {
            Status = ZwClose(pImageData->hFile);
            if (!NT_SUCCESS(Status)) {
                bSuccess = FALSE;
            