  SetLastError(LastError);
        }
        else
        {
            bRetValue = TRUE;
        }
    }

    return bRetValue;
}

BOOL
InternalAddPrinterDriverEx(
    LPWSTR      pName,
    DWORD       Level,
    LPBYTE      pDriverInfo,
    DWORD       dwFileCopyFlags,
    PINISPOOLER pIniSpooler,
    BOOL        bUseScratchDir,
    BOOL        bImpersonateOnCreate
    )
/*++
Function Description: This function adds/upgrades printer drivers. The new files may not be
                      used until the old drivers are unloaded. Thus the new functionality
                      associated with the new files may take a while to show up; either until
                      the DC count in the system goes to 0 or when the machine is rebooted.

Parameters: pName                -- driver name
            Level                -- level of driver_info struct
            pDriverInfo          -- driver_info buffer
            dwFileCopyFlags      -- file copy options
            pIniSpooler          -- pointer to INISPOOLER struct
            bUseScratchDir       -- flag indicating location of the driver files
            bImpersonateOnCreate -- flag for impersonating the client on creating and
                                     moving files

Return Value: TRUE on success; FALSE otherwise
--*/
{
    DWORD           LastError               = ERROR_SUCCESS;
    BOOL            bReturnValue            = FALSE;
    BOOL            bDriverMoved = FALSE, bNewIniDriverCreated = FALSE;
    LPWSTR          pEnvironment            = szEnvironment;
    PINTERNAL_DRV_FILE pInternalDriverFiles = NULL;
    DWORD           dwMajorVersion;

    PINIDRIVER      pIniDriver              = NULL;
    PINIENVIRONMENT pIniEnvironment;
    PINIVERSION     pIniVersion;
    LPWSTR          pszDriverPath;
    LPWSTR          pszDriverName;
    DWORD           dwBlockingStatus = BSP_PRINTER_DRIVER_OK;
    BOOL            bCopyFilesToClusterDisk;
    BOOL            bBadDriver = FALSE;    
    HANDLE          hRestorePoint            = NULL;
    BOOL            bSetSystemRestorePoint   = FALSE;
    BOOL            bIsSystemRestorePointSet = FALSE;
    DWORD           FileCount                = 0;
    
    //
    // If the pIniSpooler where we add the driver is a cluster type spooler,
    // then besides its normal tasks, it also needs to propagte the driver
    // files to the cluster disk. Thus the driver files will be available
    // on each node where the cluster spooler fails over. SplAddPrinterDriverEx
    // is the function that calls this one. SplAddPrinterDriverEx can be called
    // in 2 types of context:
    // 1) The caller is cluster unaware and wants to add a driver. Then InternalAdd
    // PrinterDriverEX will propagate driver files to the cluster disk, if the
    // pIniSpooler happens to be of cluster type
    // 2) The caller of this function is SplCreateSpooler when pIniSpooler is a
    // cluster spooler. In this case that caller uses the files on the cluster
    // disk and calls the function to add the driver from the cluster disk to the
    // local node. The driver files will be installed on the local machine. They will
    // not be shared with the pLocalIniSpooler. We need the driver files locally.
    // We can't load them off the driver disk. Otherwise, on a fail over, apps
    // who loaded a driver file will get an in page error.
    // The following flag is used to distinguish the case 2). When SplCreateSpooler
    // is the caller of SplAddPrinterDriverEx, then we do not need to copy the files
    // to the disk. It would be redundant.
    //
    bCopyFilesToClusterDisk = pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER  &&
                              pIniSpooler->SpoolerFlags & SPL_PRINT         &&
                              !(dwFileCopyFlags & APD_DONT_COPY_FILES_TO_CLUSTER);

    //
    // We want to set a system restore point unless the installer has already told
    // us that the driver is signed. To really get this working properly, we would
    // have to redesign AddPrinterDriver to be signing aware. For now it is the 
    // honor system (it is not obvious why an OEM installer would not want us to 
    // check point here though).
    // 
    bSetSystemRestorePoint = !bCopyFilesToClusterDisk && !(dwFileCopyFlags & APD_DONT_SET_CHECKPOINT);

    //
    // We mask APD_DONT_COPY_FILES_TO_CLUSTER. The subsequent uses of dwFilecopyFlags exptect it
    // to have a single bit set. They don't use it bitwise. They compare
    // dwords agains it. The same goes for APD_DRIVER_SIGNATURE_VALID.
    //
    dwFileCopyFlags = dwFileCopyFlags & ~(APD_DONT_COPY_FILES_TO_CLUSTER);

    DBGMSG(DBG_TRACE, ("InternalAddPrinterDriverEx( %x, %d, %x, %x)\n",
                       pName, Level, pDriverInfo, pIniSpooler));

    try {

        EnterSplSem();

        if (!MyName(pName, pIniSpooler) ||
            !ValidateDriverInfo(pDriverInfo,
                               Level,
                               dwFileCopyFlags,
                               bCopyFilesToClusterDisk,
                               pIniSpooler))
        {
            leave;
        }

        if (Level == 7)
        {
            //
            //  We can't be inside the semaphore to make this call.
            //
            LeaveSplSem();
            bReturnValue = InternalINFInstallDriver( (DRIVER_INFO_7*)pDriverInfo );
            EnterSplSem();
            leave;
        }

        pszDriverName = ((DRIVER_INFO_2*)pDriverInfo)->pName;

        pEnvironment = ((DRIVER_INFO_2*)pDriverInfo)->pEnvironment;

        //
        // If the driver hasn't gone through our class installer, then we want to
        // create a sysem restore point here. Since Level 7 drivers are by 
        // definition signed, we can do this after the InternalINFInstallDriver.
        // Since check-pointing takes from 25-30 seconds, this must take place 
        // outside the CS.
        // 
        if (bSetSystemRestorePoint)
        {
            LeaveSplSem();
            bIsSystemRestorePointSet = LocalStartSystemRestorePoint(pszDriverName, &hRestorePoint); 
            EnterSplSem();

            //
            // This only fails if something completely unexpected happens in 
            // setting the checkpoint. Some skus don't support check points 
            // in which case hRestorePoint will be NULL even though the function
            // succeeds.
            // 
            if (!bIsSystemRestorePointSet)
            {
                leave;
            }
        }

        pIniEnvironment = FindEnvironment(pEnvironment, pIniSpooler );

        if (!CreateInternalDriverFileArray(Level,
                                           pDriverInfo,
                                           &pInternalDriverFiles,
                                           &FileCount,
                                           bUseScratchDir,
                                           pIniEnvironment,
                                           FALSE))
        {
            leave;
        }

        //
        //  For the driver and config files in the scratch directory do a version
        //  check else use the version passed in rather than calling
        //  GetPrintDriverVersion which will cause a LoadLibrary - possibly
        //  over the network.
        //  Same for CheckFilePlatform. We shouldn't hit the network for files
        //  in Scratch or temporary directory.
        //
        //
        if (bUseScratchDir || dwFileCopyFlags & APD_COPY_FROM_DIRECTORY)
        {
            if (!GetPrintDriverVersion(pInternalDriverFiles[0].pFileName,
                                       &dwMajorVersion,
                                       NULL))
            {
                leave;
            }
            else
            {
                //
                // ntprint.dll doesn't fill in cVersion. We need to set it correctly
                // just in case we need to call Save/RestoreParametersForUpgrade.
                // For this case we need to have a corect version since no more validation are done.
                //
                ((DRIVER_INFO_2*)pDriverInfo)->cVersion = dwMajorVersion;
            }


            if (!CheckFilePlatform(pInternalDriverFiles[0].pFileName, pEnvironment) ||
                !CheckFilePlatform(pInternalDriverFiles[1].pFileName, pEnvironment))
            {

                LastError = ERROR_EXE_MACHINE_TYPE_MISMATCH;
                leave;
            }

        }
        else
        {
            dwMajorVersion = ((DRIVER_INFO_2*)pDriverInfo)->cVersion;
        }

        LeaveSplSem();

        LastError = IsCompatibleDriver(pszDriverName,
                                       pInternalDriverFiles[0].pFileName,
                                       ((DRIVER_INFO_2*)pDriverInfo)->pEnvironment,
                                       dwMajorVersion,
                                       &dwBlockingStatus);

        EnterSplSem();

        if (LastError != ERROR_SUCCESS)
        {
            leave;
        }

              
        //
        // If the printer driver is blocked, we consider it a bad driver. 
        //
        bBadDriver = (dwBlockingStatus & BSP_BLOCKING_LEVEL_MASK) == BSP_PRINTER_DRIVER_BLOCKED;
        if (bBadDriver) 
        {
            LastError = ERROR_PRINTER_DRIVER_BLOCKED;
        }
        
        //
        // if the driver is not blocked and we are not instructed to install 
        // warned driver, check for warned driver.
        //
        if(!bBadDriver && !(dwFileCopyFlags & APD_INSTALL_WARNED_DRIVER)) 
        {
            bBadDriver =  (dwBlockingStatus & BSP_BLOCKING_LEVEL_MASK) == BSP_PRINTER_DRIVER_WARNED;
            if (bBadDriver)
            {
                LastError = ERROR_PRINTER_DRIVER_WARNED;
            }
        }

        if (bBadDriver)
        {
            //
            // Win2k server does not recognize the new error code so we should
            // returns ERROR_UNKNOWN_PRINTER_DRIVER to get the right error 
            // message on win2k and nt4.
            // 
            // Client from Whistler or later will set 
            // APD_RETURN_BLOCKING_STATUS_CODE before call AddPrinterDrver
            //
            if (!(dwFileCopyFlags & APD_RETURN_BLOCKING_STATUS_CODE))
            {
                LastError = ERROR_UNKNOWN_PRINTER_DRIVER;
            }
            
            SplLogEvent(pIniSpooler,
                        LOG_ERROR,
                        MSG_BAD_OEM_DRIVER,
                        TRUE,
                        pszDriverName,
                        NULL);
            leave;
        }

#ifdef _WIN64

        //
        // Disallow installation of WIN64 KMPD.
        //
        if (pEnvironment                                &&
            !_wcsicmp(LOCAL_ENVIRONMENT, pEnvironment)  &&
            IsKMPD(pInternalDriverFiles[0].pFileName))
        {
            LastError = ERROR_KM_DRIVER_BLOCKED;
            leave;
        }
#endif
        
        pIniVersion = FindVersionEntry( pIniEnvironment, dwMajorVersion );

        if (pIniVersion == NULL)
        {
            pIniVersion = CreateVersionEntry(pIniEnvironment,
                                             dwMajorVersion,
                                             pIniSpooler);

            if (pIniVersion == NULL)
            {
                leave;
            }

        }
        else
        {
            //
            // Version exists, try and create directory even if it
            // exists.  This is a slight performance hit, but since you
            // install drivers rarely, this is ok.  This fixes the problem
            // where the version directory is accidentally deleted.
            //
            if (!CreateVersionDirectory(pIniVersion,
                                        pIniEnvironment,
                                        FALSE,
                                        pIniSpooler))
            {
                leave;
            }
        }

        //
        // Check for existing driver
        //
        pIniDriver = FindDriverEntry(pIniVersion, pszDriverName);

        //
        // Clear this flag since subsequent calls doesn't check bitwise.
        //
        dwFileCopyFlags &= ~(APD_COPY_FROM_DIRECTORY | APD_INSTALL_WARNED_DRIVER | APD_RETURN_BLOCKING_STATUS_CODE | APD_DONT_SET_CHECKPOINT);

        if (!CheckFileCopyOptions(pIniEnvironment,
                                  pIniVersion,
                                  pIniDriver,
                                  pInternalDriverFiles,
                                  FileCount,
                                  dwFileCopyFlags,
                                  &bReturnValue))
        {
            //
            // We don't need to do anything because either the operation
            // failed (strict upgrade with older src files), or because
            // it's an upgrade and the dest is newer.  bReturnValue indicates
            // if the AddPrinterDriver call succeeds.
            //
            leave;
        }

        //
        // Copy files to the correct directories
        //
        if (!CopyFilesToFinalDirectory(pIniSpooler,
                                       pIniEnvironment,
                                       pIniVersion,
                                       pInternalDriverFiles,
                                       FileCount,
                                       dwFileCopyFlags,
                                       bImpersonateOnCreate,
                                       &bDriverMoved))
        {
            leave;
        }

        //
        // If pIniSpooler is a cluster spooler, then copy driver files to cluster disk
        // if the driver is not being installed from the cluster disk (as part of the
        // SplCreatespooler)
        //
        if (bCopyFilesToClusterDisk)
        {
            LastError = CopyFileToClusterDirectory(pIniSpooler,
                                                   pIniEnvironment,
                                                   pIniVersion,
                                                   pInternalDriverFiles,
                                                   FileCount);

            if (LastError == ERROR_SUCCESS)
            {
                //
                // Here we propagate the ICM profiles to the cluster disk
                //
                CopyICMFromLocalDiskToClusterDisk(pIniSpooler);
            }
            else
            {
                leave;
            }
        }

        //
        // Check if the drivers need to be unloaded
        // WaitRequiredForDriverUnload returns TRUE if the driver is loaded by Spooler process.
        // If not loaded by Spooler itself, the config file could be loaded by any client app.
        // In this case we move the loaded files in "Old" directory. When reload the confing file,
        // the client apps(WINSPOOL.DRV) will figure that the driver was upgraded and reload the dll.
        // See RefCntLoad and RefCntUnload in Winspool.drv. GDI32.DLL uses the same mechanism for
        // Driver file.
        //
        if (WaitRequiredForDriverUnload(pIniSpooler,
                                        pIniEnvironment,
                                        pIniVersion,
                                        pIniDriver,
                                        Level,
                                        pDriverInfo,
                                        dwFileCopyFlags,
                                        pInternalDriverFiles,
                                        FileCount,
                                        dwMajorVersion,
                                        bDriverMoved,
                                        &bReturnValue) &&
            bReturnValue)
        {
            if (pIniDriver)
            {
                //
                // Store information in the registry to complete the call later
                //
                bReturnValue = SaveParametersForUpgrade(pIniSpooler->pMachineName, bDriverMoved,
                                                        Level, pDriverInfo, dwMajorVersion);
                leave;

            }
            else
            {
                //
                // Add driver in a temp directory
                //
                bReturnValue = AddTempDriver(pIniSpooler,
                                             pIniEnvironment,
                                             pIniVersion,
                                             Level,
                                             pDriverInfo,
                                             dwFileCopyFlags,
                                             pInternalDriverFiles,
                                             FileCount,
                                             dwMajorVersion,
                                             bDriverMoved
                                             );

                leave;
            }
        }

    } finally {

        //
        // This code is only for clusters
        //
        if (bReturnValue && pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER)
        {
            SYSTEMTIME SysTime = {0};

            if (bCopyFilesToClusterDisk)
            {
                //
                // We are in the case where the add printer driver call comes from outside
                // the spooler. We need to get the local time and write the time stamp in the
                // locl regsitry and in the cluster database
                //
                GetLocalTime(&SysTime);

                //
                // Write timestamp to registry. Doesn't matter if any of them fails
                // The time stamp is for faster cluster spooler initialization
                //
                WriteTimeStamp(pIniSpooler->hckRoot,
                               SysTime,
                               pIniSpooler->pszRegistryEnvironments,
                               pIniEnvironment->pName,
                               szDriversKey,
                               pIniVersion->pName,
                               pszDriverName,
                               pIniSpooler);
            }
            else
            {
                //
                // We are in the case where the add printer driver call came from inside
                // the spooler (SplCreateSpooler). This is the case when our local node
                // doesn't already have the driver installed. We do not need to get a new
                // time stamp. (this would case the time stamp in the cluster db to be updated,
                // and then whenever we fail over the time stamps will be always different)
                // We just get the time stamp from the cluster db and update the local registry
                //
                ReadTimeStamp(pIniSpooler->hckRoot,
                              &SysTime,
                              pIniSpooler->pszRegistryEnvironments,
                              pIniEnvironment->pName,
                              szDriversKey,
                              pIniVersion->pName,
                              pszDriverName,
                              pIniSpooler);
            }

            WriteTimeStamp(HKEY_LOCAL_MACHINE,
                           SysTime,
                           ipszRegistryClusRepository,
                           pIniSpooler->pszClusResID,
                           pIniEnvironment->pName,
                           pIniVersion->pName,
                           pszDriverName,
                           NULL);
        }

        if (!bReturnValue && LastError == ERROR_SUCCESS)
        {
            LastError = GetLastError();

            //
            // We failed the call because bDriverMoved was FALSE and the driver was loaded
            //
            if(LastError == ERROR_SUCCESS && !bDriverMoved)
            {
                 LastError = ERROR_NO_SYSTEM_RESOURCES;
            }

            SPLASSERT(LastError != ERROR_SUCCESS);
        }

        if (bUseScratchDir && FileCount)
        {
            SetOldDateOnDriverFilesInScratchDirectory(pInternalDriverFiles,
                                                      FileCount,
                                                      pIniSpooler);
        }

        LeaveSplSem();

        if (FileCount)
        {
            CleanupInternalDriverInfo(pInternalDriverFiles, FileCount);
        }

        CleanUpgradeDirectories();

        //
        // End the system restore point once everything is done. Cancel it if the
        // function fails.
        // 
        if (hRestorePoint)
        {
            (VOID)EndSystemRestorePoint(hRestorePoint, !bReturnValue);
        }

        if (!bReturnValue)
        {
            DBGMSG( DBG_WARNING, ("InternalAddPrinterDriver Failed %d\n", LastError ));
            SetLastError(LastError);
        }
    }

    return bReturnValue;
}

BOOL 
AddTempDriver(
    IN      PINISPOOLER         pIniSpooler,
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      DWORD               dwLevel,
    IN      LPBYTE              pDriverInfo,
    IN      DWORD               dwFileCopyFlags,
    IN  OUT PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN      DWORD               dwFileCount,
    IN      DWORD               dwVersion,
    IN      BOOL                bDriverMoved
    )

/*++
Function Description: For new drivers which require driver files to be unloaded,
                      add the driver into a temp directory and mark it for upgrade on
                      reboot OR when the files are unloaded

Parameters:   pIniSpooler          -- pointer to INISPOOLER
              pIniEnvironment      -- pointer to INIENVIRONMENT
              pIniVersion          -- pointer to INVERSION
              dwLevel              -- driver_info level
              pDriverInfo          -- pointer to driver_info
              dwFileCopyFlags      -- File copy flags that make it to the spooler
              pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
              dwFileCount          -- number of files in file set
              dwVersion            -- driver version
              bDriverMoved         -- Were any files moved to the Old directory ?

Return Values: TRUE if the driver was added;
               FALSE otherwise
--*/

{
    BOOL     bReturn = FALSE;
    WCHAR    szVersionDir[MAX_PATH], szNewDir[MAX_PATH+5];
    WCHAR    szDriverFile[MAX_PATH], szOldFile[MAX_PATH], szNewFile[MAX_PATH];
    WCHAR    *pTempDir = NULL;
    DWORD    dwIndex, dwTempDir;
    HANDLE   hToken = NULL, hFile;
    LPWSTR   pFileName;

    hToken = RevertToPrinterSelf();

    // get the version directory

    // szVersionDir shouldn't be bigger than MAX_PATH - 5 since is used later
    // to build another file paths.
    if((StrNCatBuff(szVersionDir,
                    MAX_PATH - 5,
                    pIniSpooler->pDir,
                    L"\\drivers\\",
                    pIniEnvironment->pDirectory,
                    L"\\",
                    pIniVersion->szDirectory,
                    NULL) != ERROR_SUCCESS))
    {
        goto CleanUp;
    }

    dwIndex = CreateNumberedTempDirectory((LPWSTR)szVersionDir, &pTempDir);

    if (dwIndex == -1) {
        goto CleanUp;
    }

    dwTempDir = dwIndex;

    wsprintf(szNewDir, L"%ws\\New", szVersionDir);

    // copy the files into the temp directory and mark them for deletion on
    // reboot
    for (dwIndex = 0; dwIndex < dwFileCount; dwIndex++) {

        pFileName = (LPWSTR) FindFileName(pInternalDriverFiles[dwIndex].pFileName);

        if((StrNCatBuff(szNewFile,MAX_PATH,szNewDir ,L"\\", pFileName, NULL) != ERROR_SUCCESS)        ||
           (StrNCatBuff(szOldFile,MAX_PATH,szVersionDir, L"\\", pFileName, NULL) != ERROR_SUCCESS)    ||
           (StrNCatBuff(szDriverFile,MAX_PATH,pTempDir, L"\\", pFileName, NULL) != ERROR_SUCCESS))
        {
             goto CleanUp;
        }

        hFile = CreateFile(szNewFile, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile == INVALID_HANDLE_VALUE) {

            CopyFile(szOldFile, szDriverFile, FALSE);

        } else {

            CloseHandle(hFile);
            hFile = INVALID_HANDLE_VALUE;

            CopyFile(szNewFile, szDriverFile, FALSE);
        }

        SplMoveFileEx(szDriverFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
    }

    // Delete the directory on reboot
    SplMoveFileEx(szNewDir, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);

    // Update driver structures and make event call backs and
    // store information in the registry to complete the call later
    bReturn = CompleteDriverUpgrade(pIniSpooler,
                                    pIniEnvironment,
                                    pIniVersion,
                                    NULL,
                                    dwLevel,
                                    pDriverInfo,
                                    dwFileCopyFlags,
                                    pInternalDriverFiles,
                                    dwFileCount,
                                    dwVersion,
                                    dwTempDir,
                                    bDriverMoved,
                                    TRUE,
                                    TRUE) &&

              SaveParametersForUpgrade(pIniSpooler->pMachineName,
                                       bDriverMoved,
                                       dwLevel,
                                       pDriverInfo,
                                       dwVersion);

CleanUp:

    if (hToken) {
        ImpersonatePrinterClient(hToken);
    }

    FreeSplMem(pTempDir);

    return bReturn;
}

BOOL 
WaitRequiredForDriverUnload(
    IN      PINISPOOLER         pIniSpooler,
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      PINIDRIVER          pIniDriver,
    IN      DWORD               dwLevel,
    IN      LPBYTE              pDriverInfo,
    IN      DWORD               dwFileCopyFlags,
    IN  OUT PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN      DWORD               dwFileCount,
    IN      DWORD               dwVersion,
    IN      BOOL                bDriverMoved,
        OUT LPBOOL              pbSuccess
    )
/*++
Function Description: Determine if the driver upgrade has to be defered till the
                      dlls can be unloaded. GDI and the client side of the spooler are
                      notified to continue the pending upgrade when the dll is unloaded.

Parameters:   pIniSpooler          -- pointer to INISPOOLER
              pIniEnvironment      -- pointer to INIENVIRONMENT
              pIniVersion          -- pointer to INVERSION
              pIniDriver           -- pointer to INIDRIVER
              dwLevel              -- driver_info level
              pDriverInfo          -- pointer to driver_info
              dwFileCopyFlags      -- copy flags for the driver.
              pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
              dwFileCount          -- number of files in file set
              dwVersion            -- driver version
              bDriverMoved         -- Were any files moved to the Old directory ?
              pbSuccess            -- pointer to Success flag

Return Values: TRUE if the driver was unloaded and upgraded;
               FALSE if the driver cant be unloaded
--*/

{
    BOOL           bUnloaded,bDriverFileMoved, bConfigFileMoved;
    LPWSTR         pDriverFile, pConfigFile;
    WCHAR          szDriverFile[MAX_PATH], szOldDir[MAX_PATH], szNewDir[MAX_PATH];
    WCHAR          szTempFile[MAX_PATH], szCurrDir[MAX_PATH], szConfigFile[MAX_PATH];
    HANDLE         hFile, hToken = NULL;
    DWORD          dwDriverAttributes = 0;

    hToken = RevertToPrinterSelf();

    *pbSuccess = FALSE;

    // Set up Driver, Old and New directories
    if((StrNCatBuff(szCurrDir,
                    MAX_PATH,
                    pIniSpooler->pDir,
                    L"\\drivers\\",
                    pIniEnvironment->pDirectory,
                    L"\\",
                    pIniVersion->szDirectory,
                    NULL) != ERROR_SUCCESS)         ||
       (StrNCatBuff(szOldDir,
                    MAX_PATH,
                    szCurrDir,
                    L"\\Old",
                    NULL) != ERROR_SUCCESS)         ||
       (StrNCatBuff(szNewDir,
                    MAX_PATH,
                    szCurrDir,
                    L"\\New",
                    NULL) != ERROR_SUCCESS)         ||
       (StrNCatBuff(szDriverFile,
                    MAX_PATH,
                    szCurrDir,
                    L"\\",
                    FindFileName(pInternalDriverFiles[0].pFileName),
                    NULL) != ERROR_SUCCESS)         ||
       (StrNCatBuff(szConfigFile,
                    MAX_PATH,
                    szCurrDir,
                    L"\\",
                    FindFileName(pInternalDriverFiles[1].pFileName),
                    NULL) != ERROR_SUCCESS)         ||
       (StrNCatBuff(szTempFile,
                    MAX_PATH,szNewDir,
                    L"\\",
                    FindFileName(pInternalDriverFiles[0].pFileName),
                    NULL) != ERROR_SUCCESS))
    {
         bUnloaded  = TRUE;
         goto CleanUp;
    }

    // Check if the new driver file needs to be copied
    hFile = CreateFile(szTempFile, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
        pDriverFile = szDriverFile;

        if (pIniDriver) {
            dwDriverAttributes = pIniDriver->dwDriverAttributes;
        } else {
            dwDriverAttributes = IsKMPD(szDriverFile) ? DRIVER_KERNELMODE
                                                      : DRIVER_USERMODE;
        }
    } else {
        pDriverFile = NULL;
    }

    if((StrNCatBuff(szTempFile,
                    MAX_PATH,
                    szNewDir,
                    L"\\",
                    FindFileName(pInternalDriverFiles[1].pFileName), NULL)
                    != ERROR_SUCCESS))
    {
        bUnloaded  = TRUE;
        goto CleanUp;
    }

    // Check if the new config file needs to be copied
    hFile = CreateFile(szTempFile, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
        pConfigFile = szConfigFile;
    } else {
        pConfigFile = NULL;
    }

    bUnloaded = FilesUnloaded(pIniEnvironment, pDriverFile, pConfigFile,
                              dwDriverAttributes);

    if (bUnloaded) {

        // Move the driver files
        if (MoveNewDriverRelatedFiles(szNewDir,
                                      szCurrDir,
                                      szOldDir,
                                      pInternalDriverFiles,
                                      dwFileCount,
                                      &bDriverFileMoved,
                                      &bConfigFileMoved)) {

            // Update driver structures and make event call backs
            *pbSuccess = CompleteDriverUpgrade(pIniSpooler,
                                               pIniEnvironment,
                                               pIniVersion,
                                               pIniDriver,
                                               dwLevel,
                                               pDriverInfo,
                                               dwFileCopyFlags,
                                               pInternalDriverFiles,
                                               dwFileCount,
                                               dwVersion,
                                               0,
                                               bDriverMoved,
                                               bDriverFileMoved,
                                               bConfigFileMoved
                                               );
        }
    }
    else {

        //
        // We care if the files are marked to be moved from New to Version directory only if the drivers are loaded
        // and we left the updated files in New directory. Then it is imperative MoveFileEx to have succeeded.
        // Fail the api call if bDriverMoved is FALSE;
        //
        *pbSuccess = bDriverMoved;
    }

CleanUp:

    if (hToken) {
        ImpersonatePrinterClient(hToken);
    }


    return (!bUnloaded);
}

BOOL FilesUnloaded(
    PINIENVIRONMENT pIniEnvironment,
    LPWSTR  pDriverFile,
    LPWSTR  pConfigFile,
    DWORD   dwDriverAttributes)
{
    BOOL bReturn = TRUE;
    fnWinSpoolDrv fnList;

    // Drivers belonging to other environments are not loaded
    if (!pIniEnvironment ||
        lstrcmpi(pIniEnvironment->pName, szEnvironment)) {

        return bReturn;
    }

    if (pDriverFile) {

        bReturn = GdiArtificialDecrementDriver(pDriverFile,
                                               dwDriverAttributes);
    }

    if (bReturn && pConfigFile && SplInitializeWinSpoolDrv(&fnList)) {

        bReturn = (* (fnList.pfnForceUnloadDriver))(pConfigFile);
    }

    return bReturn;
}

DWORD StringSizeInBytes(
    LPWSTR pString,
    BOOL   bMultiSz)

/*++
Function Description: Computes the number of bytes in the string

Parameters: pString   -- string pointer
            bMultiSz  -- flag for multi_sz strings

Return Values: number of bytes
--*/

{
    DWORD  dwReturn = 0, dwLength;

    if (!pString) {
        return dwReturn;
    }

    if (!bMultiSz) {

        dwReturn = (wcslen(pString) + 1) * sizeof(WCHAR);

    } else {

        while (dwLength = wcslen(pString)) {

             pString += (dwLength + 1);
             dwReturn += (dwLength + 1) * sizeof(WCHAR);
        }

        dwReturn += sizeof(WCHAR);
    }

    return dwReturn;
}

DWORD LocalRegSetValue(
    HKEY    hKey,
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pValueData)

/*++
Function Description:  This function is a wrapper around RegSetValueEx which puts in
                       NULL strings for NULL pointers.

Parameters:  hKey        -  handle to registry key
             pValueName  -  value name
             dwType      -  type of value data (REG_DWORD , REG_SZ ...)
             pValueData  -  data buffer

Return Values: Last error returned by RegSetValueEx
--*/

{
    DWORD   dwSize;
    WCHAR   pNull[2];
    LPBYTE  pData = pValueData;

    if (!pValueName) {
        return ERROR_SUCCESS;
    }

    pNull[0] = pNull[1] = L'\0';

    switch (dwType) {

    case REG_DWORD:
         dwSize = sizeof(DWORD);
         break;

    case REG_SZ:
         if (!pData) {
             pData = (LPBYTE) pNull;
             dwSize = sizeof(WCHAR);
         } else {
             dwSize = StringSizeInBytes((LPWSTR) pData, FALSE);
         }
         break;

    case REG_MULTI_SZ:
         if (!pData || !*pData) {
             pData = (LPBYTE) pNull;
             dwSize = 2 * sizeof(WCHAR);
         } else {
             dwSize = StringSizeInBytes((LPWSTR) pData, TRUE);
         }
         break;

    default:
         // only dword, sz and msz are written to the registry
         return ERROR_INVALID_PARAMETER;
    }

    return RegSetValueEx(hKey, pValueName, 0, dwType, pData, dwSize);
}

BOOL SaveParametersForUpgrade(
    LPWSTR pName,
    BOOL   bDriverMoved,
    DWORD  dwLevel,
    LPBYTE pDriverInfo,
    DWORD  dwVersion)

/*++
Function Description: Saves data for the driver upgrade which has to be
                      deferred till the new driver can be loaded

Parameters: pName         -- pIniSpooler->pName
            bDriverMoved  -- Were any of the old driver files moved?
            dwLevel       -- Driver_Info level
            pDriverInfo   -- Driver_Info pointer
            dwVersion     -- Driver version number

Return Values: TRUE if successful; FALSE otherwise
--*/

{
    HANDLE         hToken = NULL;
    HKEY           hRootKey = NULL, hUpgradeKey = NULL, hVersionKey = NULL;
    HKEY           hDriverKey = NULL;
    DWORD          dwDriverMoved = (DWORD) bDriverMoved;
    BOOL           bReturn = FALSE;
    WCHAR          pBuffer[MAX_PATH];
    PDRIVER_INFO_2 pDriver2;
    PDRIVER_INFO_3 pDriver3;
    PDRIVER_INFO_4 pDriver4;
    PDRIVER_INFO_6 pDriver6;

    pDriver2 = (PDRIVER_INFO_2) pDriverInfo;

    // Stop impersonation for modifying the registry
    hToken = RevertToPrinterSelf();

    wsprintf(pBuffer, L"Version-%d", dwVersion);

    // Create the registry keys
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegistryRoot, 0,
                       NULL, 0, KEY_WRITE, NULL, &hRootKey, NULL) ||

        RegCreateKeyEx(hRootKey, szPendingUpgrades, 0,
                       NULL, 0, KEY_WRITE, NULL, &hUpgradeKey, NULL) ||

        RegCreateKeyEx(hUpgradeKey, pBuffer, 0,
                       NULL, 0, KEY_WRITE, NULL, &hVersionKey, NULL) ||

        RegCreateKeyEx(hVersionKey, pDriver2->pName, 0,
                       NULL, 0, KEY_WRITE, NULL, &hDriverKey, NULL)) {

         goto CleanUp;
    }

    if (dwLevel == DRIVER_INFO_VERSION_LEVEL) {

        bReturn = SaveDriverVersionForUpgrade(hDriverKey, (PDRIVER_INFO_VERSION)pDriverInfo,
                                              pName, bDriverMoved, dwVersion);

        goto CleanUp;
    }

    // Add the spooler name and driver info level

    if (LocalRegSetValue(hDriverKey, L"SplName", REG_SZ, (LPBYTE) pName) ||

        LocalRegSetValue(hDriverKey, L"Level",  REG_DWORD, (LPBYTE) &dwLevel) ||

        LocalRegSetValue(hDriverKey, L"DriverMoved", REG_DWORD, (LPBYTE) &dwDriverMoved)) {

         goto CleanUp;
    }

    // Add Driver_Info_2 data
    if (LocalRegSetValue(hDriverKey, L"cVersion", REG_DWORD, (LPBYTE) &dwVersion) ||

        LocalRegSetValue(hDriverKey, L"pName", REG_SZ, (LPBYTE) pDriver2->pName) ||

        LocalRegSetValue(hDriverKey, L"pEnvironment", REG_SZ, (LPBYTE) pDriver2->pEnvironment) ||

        LocalRegSetValue(hDriverKey, L"pDriverPath", REG_SZ, (LPBYTE) pDriver2->pDriverPath) ||

        LocalRegSetValue(hDriverKey, L"pDataFile", REG_SZ, (LPBYTE) pDriver2->pDataFile) ||

        LocalRegSetValue(hDriverKey, L"pConfigFile", REG_SZ, (LPBYTE) pDriver2->pConfigFile)) {

         goto CleanUp;
    }

    if (dwLevel != 2) {

        pDriver3 = (PDRIVER_INFO_3) pDriverInfo;

        // Add Driver_Info_3 data
        if (LocalRegSetValue(hDriverKey, L"pHelpFile", REG_SZ, (LPBYTE) pDriver3->pHelpFile) ||

            LocalRegSetValue(hDriverKey, L"pDependentFiles", REG_MULTI_SZ,
                             (LPBYTE) pDriver3->pDependentFiles) ||

            LocalRegSetValue(hDriverKey, L"pMonitorName", REG_SZ,
                             (LPBYTE) pDriver3->pMonitorName) ||

            LocalRegSetValue(hDriverKey, L"pDefaultDataType", REG_SZ,
                             (LPBYTE) pDriver3->pDefaultDataType)) {

             goto CleanUp;
        }

        if (dwLevel == 4 || dwLevel == 6) {

           pDriver4 = (PDRIVER_INFO_4) pDriverInfo;

            // Add Driver_Info_4 data
           if (LocalRegSetValue(hDriverKey, L"pszzPreviousNames", REG_MULTI_SZ, (LPBYTE) pDriver4->pszzPreviousNames))
           {
               goto CleanUp;
           }
        }

        if (dwLevel == 6) {

           pDriver6 = (PDRIVER_INFO_6) pDriverInfo;

            // Add Driver_Info6 data
           if (RegSetValueEx(hDriverKey, L"ftDriverDate", 0, REG_BINARY, (LPBYTE)&pDriver6->ftDriverDate, sizeof(FILETIME)) ||

               RegSetValueEx(hDriverKey, L"dwlDriverVersion", 0, REG_BINARY, (LPBYTE)&pDriver6->dwlDriverVersion, sizeof(DWORDLONG)) ||

               LocalRegSetValue(hDriverKey, L"pszMfgName", REG_SZ, (LPBYTE)pDriver6->pszMfgName)                        ||

               LocalRegSetValue(hDriverKey, L"pszOEMUrl", REG_SZ, (LPBYTE)pDriver6->pszOEMUrl)                          ||

               LocalRegSetValue(hDriverKey, L"pszHardwareID", REG_SZ, (LPBYTE)pDriver6->pszHardwareID)                  ||

               LocalRegSetValue(hDriverKey, L"pszProvider", REG_SZ, (LPBYTE)pDriver6->pszProvider)
              )
           {
               goto CleanUp;
           }
        }
    }

    bReturn = TRUE;

CleanUp:

    if (hDriverKey) {
        RegCloseKey(hDriverKey);
    }

    if (hVersionKey) {
        RegCloseKey(hVersionKey);
    }

    if (hUpgradeKey) {
        RegCloseKey(hUpgradeKey);
    }

    if (hRootKey) {
        RegCloseKey(hRootKey);
    }

    if (hToken) {
        ImpersonatePrinterClient(hToken);
    }

    return bReturn;
}


BOOL SaveDriverVersionForUpgrade(
    IN  HKEY                    hDriverKey,
    IN  PDRIVER_INFO_VERSION    pDriverVersion,
    IN  LPWSTR                  pName,
    IN  DWORD                   dwDriverMoved,
    IN  DWORD                   dwVersion
    )
/*++

Routine Name:

    SaveDriverVersionForUpgrade

Routine Description:

    Save a DRIVER_INFO_VERSION into registry for pending driver upgrade purposes.
    It is called by SaveParametersForUpgrade.
    For simplicity, it will save it in the same format DRIVER_INFO_6
    is saved in the registry.

Arguments:

    hDriverKey      - the registry key where to save data
    pDriverVersion  - pointer to DRIVER_INFO_VERSION structure
    pName           - driver name
    dwDriverMoved   - information about the way files where move between directories
    dwVersion       - driver version

Return Value:

    TRUE if success.

--*/
{

    BOOL    bRetValue = FALSE;
    DWORD   dwLevel = 6;
    PWSTR   pDllFiles = NULL;
    PWSTR   pszDriverPath, pszDataFile, pszConfigFile, pszHelpFile, pDependentFiles ;

    pszDriverPath = pszDataFile = pszConfigFile = pszHelpFile = NULL;


    if (!GetFileNamesFromDriverVersionInfo(pDriverVersion,
                                           &pszDriverPath,
                                           &pszConfigFile,
                                           &pszDataFile,
                                           &pszHelpFile))
    {
        goto CleanUp;
    }

    if (!BuildDependentFilesFromDriverInfo(pDriverVersion,
                                           &pDllFiles))
    {
        goto CleanUp;
    }


    if (LocalRegSetValue(hDriverKey, L"SplName", REG_SZ, (LPBYTE) pName)                            ||
        LocalRegSetValue(hDriverKey, L"Level", REG_DWORD, (LPBYTE) &dwLevel)                        ||
        LocalRegSetValue(hDriverKey, L"DriverMoved", REG_DWORD, (LPBYTE) &dwDriverMoved)            ||
        LocalRegSetValue(hDriverKey, L"Level",  REG_DWORD, (LPBYTE) &dwLevel)                       ||
        LocalRegSetValue(hDriverKey, L"cVersion", REG_DWORD, (LPBYTE) &dwVersion)                   ||
        LocalRegSetValue(hDriverKey, L"pName", REG_SZ, (LPBYTE) pDriverVersion->pName)              ||
        LocalRegSetValue(hDriverKey, L"pEnvironment", REG_SZ, (LPBYTE) pDriverVersion->pEnvironment)||
        LocalRegSetValue(hDriverKey, L"pDriverPath", REG_SZ, (LPBYTE) pszDriverPath)                ||
        LocalRegSetValue(hDriverKey, L"pDataFile", REG_SZ, (LPBYTE) pszDataFile)                    ||
        LocalRegSetValue(hDriverKey, L"pConfigFile", REG_SZ, (LPBYTE) pszConfigFile)                ||
        LocalRegSetValue(hDriverKey, L"pHelpFile", REG_SZ, (LPBYTE) pszHelpFile)                    ||
        LocalRegSetValue(hDriverKey, L"pDependentFiles", REG_MULTI_SZ, (LPBYTE) pDllFiles)          ||
        LocalRegSetValue(hDriverKey, L"pMonitorName", REG_SZ,
                        (LPBYTE) pDriverVersion->pMonitorName)                                      ||

        LocalRegSetValue(hDriverKey, L"pDefaultDataType", REG_SZ,
                        (LPBYTE) pDriverVersion->pDefaultDataType)                                  ||

        LocalRegSetValue(hDriverKey, L"pszzPreviousNames", REG_MULTI_SZ,
                        (LPBYTE) pDriverVersion->pszzPreviousNames)                                 ||

        RegSetValueEx(hDriverKey, L"ftDriverDate", 0, REG_BINARY,
                      (LPBYTE)&pDriverVersion->ftDriverDate, sizeof(FILETIME))                      ||

        RegSetValueEx(hDriverKey, L"dwlDriverVersion", 0, REG_BINARY,
                     (LPBYTE)&pDriverVersion->dwlDriverVersion, sizeof(DWORDLONG))                  ||

        LocalRegSetValue(hDriverKey, L"pszMfgName", REG_SZ,
                        (LPBYTE)pDriverVersion->pszMfgName)                                         ||

        LocalRegSetValue(hDriverKey, L"pszOEMUrl", REG_SZ,
                        (LPBYTE)pDriverVersion->pszOEMUrl)                                          ||

        LocalRegSetValue(hDriverKey, L"pszHardwareID", REG_SZ,
                        (LPBYTE)pDriverVersion->pszHardwareID)                                      ||

        LocalRegSetValue(hDriverKey, L"pszProvider", REG_SZ,
                        (LPBYTE)pDriverVersion->pszProvider))

    {
        goto CleanUp;
    }

    bRetValue = TRUE;

CleanUp:

    FreeSplMem(pDllFiles);

    return bRetValue;
}

BOOL
MoveNewDriverRelatedFiles(
    LPWSTR              pNewDir,
    LPWSTR              pCurrDir,
    LPWSTR              pOldDir,
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount,
    LPBOOL              pbDriverFileMoved,
    LPBOOL              pbConfigFileMoved)

/*++
Function Description:  Moves driver files in the New directory to the correct directory.

Parameters:  pNewDir         -- name of the New (source) directory
             pCurrDir        -- name of the destination directory
             pOldDir         -- name of the Old (temp) directory
             pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
             dwFileCount          -- number of files in file set
             pbDriverFileMoved -- flag to return if new driver file has been moved;
                                  We assume entry 0 for driver file in pInternalDriverFiles array
                                  pbDriverFileMoved should be NULL when this assumption is FALSE
                                  ( see SplCopyNumberOfFiles )
             pbConfigFileMoved -- flag to return if new config file has been moved;
                                  We assume entry 0 for config file in pInternalDriverFiles array
                                  pbConfigFileMoved should be NULL when this assumption is FALSE
                                  ( see SplCopyNumberOfFiles )

Return Values: NONE
--*/

{
    HANDLE  hFile;
    DWORD   dwIndex, dwBackupIndex;
    WCHAR   szDriverFile[MAX_PATH], szNewFile[MAX_PATH], szOldFile[MAX_PATH];
    WCHAR   *pszTempOldDirectory = NULL;
    LPWSTR  pFileName;
    BOOL    bRetValue = FALSE;
    BOOL    bFailedToMove = FALSE;

    if (pbDriverFileMoved)
    {
        *pbDriverFileMoved = FALSE;
    }

    if (pbConfigFileMoved)
    {
        *pbConfigFileMoved = FALSE;
    }

    if (CreateNumberedTempDirectory(pOldDir, &pszTempOldDirectory) != -1) {

        for (dwIndex = 0; dwIndex < dwFileCount; dwIndex++) {

            BOOL FileCopied = FALSE;

            pFileName = (LPWSTR) FindFileName(pInternalDriverFiles[dwIndex].pFileName);

            if((StrNCatBuff(szNewFile,MAX_PATH,pNewDir, L"\\", pFileName, NULL) == ERROR_SUCCESS) &&
               (StrNCatBuff(szDriverFile,MAX_PATH,pCurrDir, L"\\", pFileName, NULL) == ERROR_SUCCESS) &&
               (StrNCatBuff(szOldFile,MAX_PATH,pszTempOldDirectory, L"\\", pFileName, NULL) == ERROR_SUCCESS))
            {
                hFile = CreateFile(szNewFile, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL, NULL);

                if (hFile != INVALID_HANDLE_VALUE)
                {
                    CloseHandle(hFile);

                    if (!SplMoveFileEx(szDriverFile, szOldFile, MOVEFILE_REPLACE_EXISTING)) {

                        bFailedToMove = TRUE;
                        dwBackupIndex = dwIndex;
                        break;
                    }

                    if (!SplMoveFileEx(szNewFile, szDriverFile, MOVEFILE_REPLACE_EXISTING)) {

                        bFailedToMove = TRUE;
                        dwBackupIndex = dwIndex + 1;
                        break;
                    }

                    FileCopied = TRUE;
                    //
                    // We could come in here from a pending upgrade
                    //
                    pInternalDriverFiles[dwIndex].bUpdated = TRUE;
                }
            }

            switch (dwIndex)
            {
            case 0:
                if (pbDriverFileMoved)
                {
                    *pbDriverFileMoved = FileCopied;
                }
                break;
            case 1:
                if (pbConfigFileMoved)
                {
                    *pbConfigFileMoved = FileCopied;
                }
                break;
            }
        }

        if ( bFailedToMove ) {

            //
            // Restore the initial file set in version directory.
            // Old\N has the replaced files. Move them back to Version directory.
            //
            for (dwIndex = 0; dwIndex < dwBackupIndex; dwIndex++) {

                pFileName = (LPWSTR) FindFileName(pInternalDriverFiles[dwIndex].pFileName);

                if( (StrNCatBuff(szDriverFile,MAX_PATH,pCurrDir, L"\\", pFileName, NULL) == ERROR_SUCCESS) &&
                    (StrNCatBuff(szOldFile,MAX_PATH,pszTempOldDirectory, L"\\", pFileName, NULL) == ERROR_SUCCESS)) {

                    SplMoveFileEx(szOldFile, szDriverFile, MOVEFILE_REPLACE_EXISTING);
                }

                pInternalDriverFiles[dwIndex].bUpdated = FALSE;
            }

        } else {

            bRetValue = TRUE;
        }
    }

    FreeSplMem(pszTempOldDirectory);

    return bRetValue;
}

BOOL LocalDriverUnloadComplete(
    LPWSTR   pDriverFile)

/*++
Function Description: This function is called in response to some driver file
                      being unloaded. The spooler tries to complete driver upgrades
                      that were waiting for this file to unload.

Parameters: pDriverFile   -- Driver file which was unloaded

Return Values: TRUE
--*/
{
    HANDLE  hToken = NULL;

    hToken = RevertToPrinterSelf();

    PendingDriverUpgrades(pDriverFile);

    if (hToken) {
        ImpersonatePrinterClient(hToken);
    }

    return TRUE;
}

BOOL RestoreVersionKey(
    HKEY     hUpgradeKey,
    DWORD    dwIndex,
    HKEY     *phVersionKey)

/*++
Function Description: Gets the version key from the pending upgrade key

Parameters: hUpgradeKey    -- upgrade key
            dwIndex        -- version index
            phVersionKey   -- pointer to buffer for version key

Return Values: TRUE if version key is found
               FALSE otherwise
--*/

{
    WCHAR   pBuffer[MAX_PATH];
    DWORD   dwSize = MAX_PATH;

    *phVersionKey = NULL;

    if (RegEnumKeyEx(hUpgradeKey, dwIndex, pBuffer, &dwSize,
                     NULL, NULL, NULL, NULL)) {

        return FALSE;
    }

    if (RegCreateKeyEx(hUpgradeKey, pBuffer, 0,
                       NULL, 0, KEY_ALL_ACCESS, NULL, phVersionKey, NULL)) {

        return FALSE;
    }

    return TRUE;
}

VOID PendingDriverUpgrades(
    LPWSTR   pDriverFile)

/*++
Function Description: Loops thru the list of pending upgrades and completes them if
                      driver files have been unloaded. This function will try all the
                      drivers on spooler startup.

Parameters: pDriverFile  -- name of the file which was unloaded

Return Values: NONE
--*/

{
    DWORD    dwIndex, dwLevel, dwDriverMoved, dwFileCount, dwVersion, dwVersionIndex;
    LPWSTR   pKeyName, pSplName,pEnvironment;
    PINTERNAL_DRV_FILE pInternalDriverFiles = NULL;
    HKEY     hRootKey = NULL, hVersionKey = NULL, hUpgradeKey = NULL;
    WCHAR    szDir[MAX_PATH], szDriverFile[MAX_PATH], szConfigFile[MAX_PATH];
    BOOL     bSuccess;

    PDRIVER_INFO_6   pDriverInfo;
    PINISPOOLER      pIniSpooler;
    PINIENVIRONMENT  pIniEnvironment;
    PINIVERSION      pIniVersion;
    PINIDRIVER       pIniDriver;

    // struct for maintaining keynames to be deleted at the end
    struct StringList {
       struct StringList *pNext;
       LPWSTR  pKeyName;
       DWORD   dwVersionIndex;
    } *pStart, *pTemp;

    pStart = pTemp = NULL;

    EnterSplSem();

    // Open the registry key
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegistryRoot, 0,
                       NULL, 0, KEY_ALL_ACCESS, NULL, &hRootKey, NULL) ||

        RegCreateKeyEx(hRootKey, szPendingUpgrades, 0,
                       NULL, 0, KEY_ALL_ACCESS, NULL, &hUpgradeKey, NULL)) {

         goto CleanUp;
    }

    // Loop thru each version entry
    for (dwVersionIndex = 0, hVersionKey = NULL;

         RestoreVersionKey(hUpgradeKey, dwVersionIndex, &hVersionKey);

         RegCloseKey(hVersionKey), hVersionKey = NULL, ++dwVersionIndex) {

        // Loop thru each driver upgrade
        for (dwIndex = 0, dwFileCount = 0, pInternalDriverFiles = NULL;

             RestoreParametersForUpgrade(hVersionKey,
                                         dwIndex,
                                         &pKeyName,
                                         &pSplName,
                                         &dwLevel,
                                         &dwDriverMoved,
                                         &pDriverInfo);

             CleanUpResources(pKeyName, pSplName, pDriverInfo,
                              &pInternalDriverFiles, dwFileCount),
             ++dwIndex, dwFileCount = 0, pInternalDriverFiles = NULL) {

            // The driver_info struct validity has been checked while updating
            // the registry.

            // Set pIniSpooler to LocalIniSpooler
            if (!(pIniSpooler = pLocalIniSpooler)) {
                continue;
            }

            // Set pIniEnvironment
            pEnvironment = szEnvironment;
            if (pDriverInfo->pEnvironment && *(pDriverInfo->pEnvironment)) {
                pEnvironment = pDriverInfo->pEnvironment;
            }
            pIniEnvironment = FindEnvironment(pEnvironment, pIniSpooler);
            if (!pIniEnvironment) {
                continue;
            }

            // Set pIniVersion
            dwVersion = pDriverInfo->cVersion;
            pIniVersion = FindVersionEntry(pIniEnvironment, dwVersion);
            if (!pIniVersion) {
                continue;
            }

            // Set pIniDriver
            pIniDriver = FindDriverEntry(pIniVersion, pDriverInfo->pName);
            if (!pIniDriver) {
                continue;
            }

            // Check for the file name which was unloaded
            if (pDriverFile) {

               if((StrNCatBuff(szDir,
                               MAX_PATH,
                               pIniSpooler->pDir,
                               L"\\drivers\\",
                               pIniEnvironment->pDirectory,
                               L"\\",
                               pIniVersion->szDirectory,
                               NULL) != ERROR_SUCCESS)                  ||
                  (StrNCatBuff(szDriverFile,
                               MAX_PATH,
                               szDir,
                               L"\\",
                               FindFileName(pIniDriver->pDriverFile),
                               NULL) != ERROR_SUCCESS)                  ||
                  (StrNCatBuff(szConfigFile,
                               MAX_PATH,szDir,
                               L"\\",
                               FindFileName(pIniDriver->pConfigFile),
                               NULL) != ERROR_SUCCESS))
                   continue;

               if (_wcsicmp(pDriverFile, szDriverFile) &&
                   _wcsicmp(pDriverFile, szConfigFile))  {

                   continue;
               }
            }

            if (!CreateInternalDriverFileArray(dwLevel,
                                               (LPBYTE)pDriverInfo,
                                               &pInternalDriverFiles,
                                               &dwFileCount,
                                               FALSE,
                                               pIniEnvironment,
                                               TRUE))
            {
                continue;
            }

            if (!WaitRequiredForDriverUnload(pIniSpooler,
                                             pIniEnvironment,
                                             pIniVersion,
                                             pIniDriver,
                                             dwLevel,
                                             (LPBYTE) pDriverInfo,
                                             APD_STRICT_UPGRADE,
                                             pInternalDriverFiles,
                                             dwFileCount,
                                             dwVersion,
                                             (BOOL) dwDriverMoved,
                                             &bSuccess) &&
                bSuccess) {

                // Upgrade has been completed, delete the registry key
                if (pKeyName && (pTemp = AllocSplMem(sizeof(struct StringList)))) {
                    pTemp->pKeyName = pKeyName;
                    pTemp->dwVersionIndex = dwVersionIndex;
                    pTemp->pNext = pStart;
                    pStart = pTemp;
                } else {
                    FreeSplMem(pKeyName);
                }

                pKeyName = NULL;
            }
        }
    }

    // Delete the keys for driver that have completed the upgrade
    while (pTemp = pStart) {
        pStart = pTemp->pNext;

        hVersionKey = NULL;
        if (RestoreVersionKey(hUpgradeKey,
                              pTemp->dwVersionIndex,
                              &hVersionKey)) {

            RegDeleteKey(hVersionKey, pTemp->pKeyName);
            RegCloseKey(hVersionKey);
        }

        FreeSplMem(pTemp->pKeyName);
        FreeSplMem(pTemp);
    }

CleanUp:

    LeaveSplSem();

    if (hUpgradeKey) {
        RegCloseKey(hUpgradeKey);
    }
    if (hRootKey) {
        RegCloseKey(hRootKey);
    }

    CleanUpgradeDirectories();

    return;
}

VOID CleanUpResources(
    LPWSTR              pKeyName,
    LPWSTR              pSplName,
    PDRIVER_INFO_6      pDriverInfo,
    PINTERNAL_DRV_FILE *ppInternalDriverFiles,
    DWORD               dwFileCount)

/*++
Function Description: Frees resources allocated for driver upgrades

Parameters: pKeyName     -  registry key name
            pSplName     -  IniSpooler name
            pDriverInfo  -  driver info 4 pointer
            pInternalDriverFiles - array of INTERNAL_DRV_FILE structures
            dwFileCount          -- number of files in file set

Return Values: NONE
--*/

{
    if (pKeyName) {
        FreeSplStr(pKeyName);
    }
    if (pSplName) {
        FreeSplStr(pSplName);
    }

    FreeDriverInfo6(pDriverInfo);

    CleanupInternalDriverInfo(*ppInternalDriverFiles, dwFileCount);
    *ppInternalDriverFiles = NULL;

    return;
}

BOOL RestoreParametersForUpgrade(
    HKEY     hUpgradeKey,
    DWORD    dwIndex,
    LPWSTR   *pKeyName,
    LPWSTR   *pSplName,
    LPDWORD  pdwLevel,
    LPDWORD  pdwDriverMoved,
    PDRIVER_INFO_6   *ppDriverInfo)

/*++
Function Description: Retrieves the parameters for pending driver upgrades

Parameters: hUpgradeKey     -- Registry key containing the upgrade information
            dwIndex         -- Index to enumerate
            pKeyName        -- pointer to a string containing the key name
            pSplName        -- pIniSpooler->pName
            pdwLevel        -- pointer to the driver_info level
            pdwDriverMoved  -- pointer to the flag indicating if any of the old driver files
                               were moved.
            pDriverInfo     -- pointer to driver_info struct

Return Values: TRUE if some driver has to be upgraded and the
                       parameters can be retrieved;
               FALSE otherwise
--*/

{
    BOOL             bReturn = FALSE;
    LPWSTR           pDriverName = NULL;
    PDRIVER_INFO_6   pDriver6 = NULL;
    DWORD            dwError, dwSize, *pVersion;
    HKEY             hDriverKey = NULL;

    // Initialize pSplName & pKeyName
    *pSplName = NULL;
    *pKeyName = NULL;
    *ppDriverInfo = NULL;

    dwSize = MAX_PATH+1;
    if (!(pDriver6 = AllocSplMem(sizeof(DRIVER_INFO_6))) ||
        !(pDriverName = AllocSplMem(dwSize*sizeof (WCHAR)))) {

        // Allocation failed
        goto CleanUp;
    }

    dwError = RegEnumKeyEx(hUpgradeKey, dwIndex, pDriverName, &dwSize,
                           NULL, NULL, NULL, NULL);

    if (dwError == ERROR_MORE_DATA) {

        // Need a bigger buffer
        FreeSplMem(pDriverName);

        dwSize++;   // count null terminator
        if (!(pDriverName = AllocSplMem(dwSize*sizeof (WCHAR)))) {

            // Allocation failed
            goto CleanUp;
        }

        dwError = RegEnumKeyEx(hUpgradeKey, dwIndex, pDriverName, &dwSize,
                               NULL, NULL, NULL, NULL);
    }

    if (dwError) {
        goto CleanUp;
    }

    if (RegCreateKeyEx(hUpgradeKey, pDriverName,  0,
                       NULL, 0, KEY_READ, NULL, &hDriverKey, NULL) ||

        !RegGetValue(hDriverKey, L"Level", (LPBYTE *)&pdwLevel) ||

        !RegGetValue(hDriverKey, L"DriverMoved", (LPBYTE *)&pdwDriverMoved) ||

        !RegGetValue(hDriverKey, L"SplName", (LPBYTE *)&pSplName)) {

         goto CleanUp;
    }

    switch (*pdwLevel) {
    case 6:

       dwSize = sizeof(FILETIME);

       if (RegQueryValueEx( hDriverKey,
                            L"ftDriverDate",
                            NULL,
                            NULL,
                            (LPBYTE)&pDriver6->ftDriverDate,
                            &dwSize
                            )!=ERROR_SUCCESS) {
           goto CleanUp;
       }

       dwSize = sizeof(DWORDLONG);

       if (RegQueryValueEx( hDriverKey,
                            L"dwlDriverVersion",
                            NULL,
                            NULL,
                            (LPBYTE)&pDriver6->dwlDriverVersion,
                            &dwSize
                            )!=ERROR_SUCCESS){
           goto CleanUp;
       }

       if (!RegGetValue(hDriverKey, L"pszMfgName", (LPBYTE *)&pDriver6->pszMfgName)              ||

           !RegGetValue(hDriverKey, L"pszOEMUrl", (LPBYTE *)&pDriver6->pszOEMUrl)                ||

           !RegGetValue(hDriverKey, L"pszHardwareID", (LPBYTE *)&pDriver6->pszHardwareID)        ||

           !RegGetValue(hDriverKey, L"pszProvider", (LPBYTE *)&pDriver6->pszProvider)
          )
       {
           goto CleanUp;
       }

    case 4:

       if (!RegGetValue(hDriverKey, L"pszzPreviousNames",
                        (LPBYTE *)&pDriver6->pszzPreviousNames)) {
           goto CleanUp;
       }

    case 3:

       if (!RegGetValue(hDriverKey, L"pDefaultDataType",
                        (LPBYTE *)&pDriver6->pDefaultDataType) ||

           !RegGetValue(hDriverKey, L"pMonitorName",
                        (LPBYTE *)&pDriver6->pMonitorName)     ||

           !RegGetValue(hDriverKey, L"pDependentFiles",
                        (LPBYTE *)&pDriver6->pDependentFiles)  ||

           !RegGetValue(hDriverKey, L"pHelpFile",
                        (LPBYTE *)&pDriver6->pHelpFile)) {

           goto CleanUp;
       }

    case 2:

       pVersion = &pDriver6->cVersion;

       if (!RegGetValue(hDriverKey, L"pConfigFile",
                        (LPBYTE *)&pDriver6->pConfigFile)   ||

           !RegGetValue(hDriverKey, L"pDataFile",
                        (LPBYTE *)&pDriver6->pDataFile)     ||

           !RegGetValue(hDriverKey, L"pDriverPath",
                        (LPBYTE *)&pDriver6->pDriverPath)   ||

           !RegGetValue(hDriverKey, L"pName",
                        (LPBYTE *)&pDriver6->pName)         ||

           !RegGetValue(hDriverKey, L"pEnvironment",
                        (LPBYTE *)&pDriver6->pEnvironment)  ||

           !RegGetValue(hDriverKey, L"cVersion",
                        (LPBYTE *)&pVersion)) {

           goto CleanUp;
       }

       break;

    default:
       // Invalid level
       goto CleanUp;
    }

    *ppDriverInfo = pDriver6;
    *pKeyName = pDriverName;

    pDriver6    = NULL;
    pDriverName = NULL;

    bReturn = TRUE;

CleanUp:

    if (!bReturn) {
        FreeDriverInfo6(pDriver6);

        FreeSplMem(*pSplName);
        *pSplName = NULL;

        FreeSplMem(pDriverName);
    }

    if (hDriverKey) {
        RegCloseKey(hDriverKey);
    }

    return bReturn;
}

VOID FreeDriverInfo6(
    PDRIVER_INFO_6   pDriver6)

/*++
Function Description: Frees a driver_info_6 struct and the strings inside it.

Parameters: pDriver6  -- pointer to the driver_info_6 struct

Return Values: NONE
--*/

{
    if (!pDriver6) {
        return;
    }

    if (pDriver6->pName) {
        FreeSplMem(pDriver6->pName);
    }
    if (pDriver6->pEnvironment) {
        FreeSplMem(pDriver6->pEnvironment);
    }
    if (pDriver6->pDriverPath) {
        FreeSplMem(pDriver6->pDriverPath);
    }
    if (pDriver6->pConfigFile) {
        FreeSplMem(pDriver6->pConfigFile);
    }
    if (pDriver6->pHelpFile) {
        FreeSplMem(pDriver6->pHelpFile);
    }
    if (pDriver6->pDataFile) {
        FreeSplMem(pDriver6->pDataFile);
    }
    if (pDriver6->pDependentFiles) {
        FreeSplMem(pDriver6->pDependentFiles);
    }
    if (pDriver6->pMonitorName) {
        FreeSplMem(pDriver6->pMonitorName);
    }
    if (pDriver6->pDefaultDataType) {
        FreeSplMem(pDriver6->pDefaultDataType);
    }
    if (pDriver6->pszzPreviousNames) {
        FreeSplMem(pDriver6->pszzPreviousNames);
    }
    if (pDriver6->pszMfgName) {
        FreeSplMem(pDriver6->pszMfgName);
    }
    if (pDriver6->pszOEMUrl) {
        FreeSplMem(pDriver6->pszOEMUrl);
    }
    if (pDriver6->pszHardwareID) {
        FreeSplMem(pDriver6->pszHardwareID);
    }
    if (pDriver6->pszProvider) {
        FreeSplMem(pDriver6->pszProvider);
    }

    FreeSplMem(pDriver6);

    return;
}

BOOL RegGetValue(
    HKEY    hDriverKey,
    LPWSTR  pValueName,
    LPBYTE  *pValue)

/*++
Function Description: This function retrieves values from the registry. It allocates the
                      necessary buffers which should be freed later. The value types are
                      DWORD, SZ or MULTI_SZ.

Parameters: hDriverKey      -- handle to the registry key
            pValueName      -- name of the value to be queried
            pValue          -- pointer to pointer to store the result

Return Values: TRUE if successful; FALSE otherwise
--*/

{
    BOOL   bReturn = FALSE;
    DWORD  dwError, dwSize = 0, dwType;
    LPBYTE pBuffer = NULL;

    dwError = RegQueryValueEx(hDriverKey, pValueName, NULL, NULL, NULL, &dwSize);

    if ((dwError == ERROR_SUCCESS) && (pBuffer = AllocSplMem(dwSize))) {

        if (dwError = RegQueryValueEx(hDriverKey, pValueName,
                                      NULL, &dwType, pBuffer, &dwSize)) {

            goto CleanUp;
        }

    } else {

        goto CleanUp;
    }

    if (dwType == REG_DWORD) {
        // Store DWORD values directly in the location.
        *((LPDWORD)*pValue) = *((LPDWORD)pBuffer);
        FreeSplMem(pBuffer);
        pBuffer = NULL;
    } else {
        // Return pointers for strings and MultiSz strings.
        *((LPBYTE *)pValue) = pBuffer;
    }

    bReturn = TRUE;

CleanUp:

    if (!bReturn && pBuffer) {
        FreeSplMem(pBuffer);
    }

    return bReturn;
}

DWORD GetDriverFileVersion(
     PINIVERSION      pIniVersion,
     LPWSTR           pFileName)

/*++
Function Description: Retrieves the version number of the file

Parameters:   pIniVersion  -- pointer to PINIVERSION
              pFileName    -- file name

Return Values: file version number
--*/

{
    PDRVREFCNT pdrc;
    DWORD      dwReturn = 0;

    SplInSem();

    if (!pIniVersion || !pFileName || !(*pFileName)) {
        return dwReturn;
    }

    for (pdrc = pIniVersion->pDrvRefCnt;
         pdrc;
         pdrc = pdrc->pNext) {

         if (lstrcmpi(pFileName,pdrc->szDrvFileName) == 0) {
             dwReturn = pdrc->dwVersion;
             break;
         }
    }

    return dwReturn;
}

BOOL GetDriverFileCachedVersion(
     IN     PINIVERSION      pIniVersion,
     IN     LPCWSTR          pFileName,
     OUT    DWORD            *pFileVersion
)
/*++

Routine Name:

    GetDriverFileCachedVersion

Routine Description:

    This routine returns a file's minor version.
    The file must be an executable( file name ended in .DLL or .EXE )
    pIniVersion keeps a linked list with information about all driver files.
    To avoid service start up delays, the entries in this list aren't initialized
    when Spooler starts. GetPrintDriverVersion loads the executable's data segment
    and this will increase Spooler initialization time.
    If the cache entry isn't initialized, call GetPrintDriverVersion and initialize it.
    Else, return cached information.
    When pIniVersion is NULL, just call GetPrintDriverVersion.

Arguments:

    pIniVersion - pointer to PINIVERSION structure. Can be NULL.
    pFileName   - file name
    pFileVersion - retrieve cached file version
    VersionType - specifies which version to return

Return Value:

    TRUE file version was successfully returned.

--*/
{
    PDRVREFCNT pdrc;
    BOOL       bRetValue = FALSE;
    BOOL       bFound = FALSE;

    SplInSem();

    if (pFileVersion && pFileName && *pFileName)
    {
        *pFileVersion = 0;
        //
        // Don't do anything for non-executable files
        //
        if (!IsEXEFile(pFileName))
        {
            bRetValue = TRUE;
        }
        else
        {
            //
            // If pIniVersion is NULL, then we cannot access cached information.
            // This code path was written for calls from SplCopyNumberOfFiles(files.c)
            //
            if (!pIniVersion)
            {
                bRetValue = GetPrintDriverVersion(pFileName,
                                                  NULL,
                                                  pFileVersion);
            }
            else
            {
                //
                // Search the entry in pIniVersion's list of files
                //
                for (pdrc = pIniVersion->pDrvRefCnt;
                     pdrc;
                     pdrc = pdrc->pNext)
                {
                     LPCWSTR     pFile = FindFileName(pFileName);

                     if (pFile && lstrcmpi(pFile, pdrc->szDrvFileName) == 0)
                     {
                         //
                         // Return cached information.
                         //
                         if(pdrc->bInitialized)
                         {
                             *pFileVersion  = pdrc->dwFileMinorVersion;
                             bRetValue      = TRUE;
                         }
                         else if (GetPrintDriverVersion(pFileName,
                                                        &pdrc->dwFileMajorVersion,
                                                        &pdrc->dwFileMinorVersion))
                         {
                            //
                            // Mark the entry as initialized so next time we don't have
                            // to do the work of calling GetPrintDriverVersion.
                            //
                            pdrc->bInitialized  = TRUE;
                            *pFileVersion       = pdrc->dwFileMinorVersion;
                            bRetValue           = TRUE;
                         }

                         //
                         // Break the loop when file found.
                         //
                         bFound = TRUE;
                         break;
                     }
                }
            }
        }
    }

    if (!bFound)
    {
        bRetValue = TRUE;
    }

    return bRetValue;
}

VOID IncrementFileVersion(
    PINIVERSION      pIniVersion,
    LPCWSTR           pFileName)

/*++
Function Description: Increments the version number of the file.

Parameters:   pIniVersion  -- pointer to PINIVERSION
              pFileName    -- file name

Return Values: NONE
--*/

{
    PDRVREFCNT pdrc;

    SplInSem();

    if (!pIniVersion || !pFileName || !(*pFileName)) {
        return;
    }

    for (pdrc = pIniVersion->pDrvRefCnt;
         pdrc;
         pdrc = pdrc->pNext) {

         if (lstrcmpi(pFileName,pdrc->szDrvFileName) == 0) {
             pdrc->dwVersion++;
             break;
         }
    }

    return;
}

BOOL
CompleteDriverUpgrade(
    IN      PINISPOOLER         pIniSpooler,
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      PINIDRIVER          pIniDriver,
    IN      DWORD               dwLevel,
    IN      LPBYTE              pDriverInfo,
    IN      DWORD               dwFileCopyFlags,
    IN      PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN      DWORD               dwFileCount,
    IN      DWORD               dwVersion,
    IN      DWORD               dwTempDir,
    IN      BOOL                bDriverMoved,
    IN      BOOL                bDriverFileMoved,
    IN      BOOL                bConfigFileMoved
    )
/*++
Function Description: This functions updates the INIDRIVER struct and calls DrvUpgradePrinter
                      and DrvDriverEvent. An event for adding printer drivers is logged.

Parameters:   pIniSpooler          -- pointer to INISPOOLER
              pIniEnvironment      -- pointer to INIENVIRONMENT
              pIniVersion          -- pointer to INIVERSION
              pIniDriver           -- pointer to INIDRIVER
              dwLevel              -- driver_info level
              pDriverInfo          -- pointer to driver_info
              dwFileCopyFlags      -- AddPrinterDriver file copy flags.
              pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
              dwFileCount          -- number of files in file set
              dwVersion            -- driver version
              dwTempDir            -- temp directory number for loaded drivers
              bDriverMoved         -- Were any files moved to the Old directory ?
              bDriverFileMoved     -- driver file moved ?
              bConfigFileMoved     -- config file moved ?

Return Values: TRUE if successful; FALSE otherwise
--*/

{
    WCHAR    szDirectory[MAX_PATH];
    LPWSTR   pOldDir, pTemp, pEnvironment = szEnvironment;
    LPBYTE   pDriver4 = NULL, pUpgradeInfo2 = NULL;
    DWORD    cbBuf;

    PINIMONITOR  pIniLangMonitor = NULL;
    PINISPOOLER  pTempIniSpooler, pIniNextSpooler;
    PINIDRIVER   pTempIniDriver = NULL;
    PINIPRINTER  pFixUpIniPrinter;
    PINIVERSION  pTempIniVersion;
    LPDRIVER_INFO_4  pDrvInfo4 = NULL;
    BOOL         bUpdatePrinters = FALSE;

    // Save the driver_info_4 struct for the old driver. This is passed to the
    // DrvUpgradePrinter call.
    if (pIniDriver && bDriverMoved) {

        cbBuf = GetDriverInfoSize(pIniDriver, 4, pIniVersion, pIniEnvironment,
                                  NULL, pIniSpooler);

        if (pDriver4 = (LPBYTE) AllocSplMem(cbBuf)) {

            pUpgradeInfo2 = CopyIniDriverToDriverInfo(pIniEnvironment, pIniVersion,
                                                      pIniDriver, 4, pDriver4,
                                                      pDriver4 + cbBuf, NULL, pIniSpooler);
        }
    }

    // Update the driver struct
    pIniDriver = CreateDriverEntry(pIniEnvironment,
                                   pIniVersion,
                                   dwLevel,
                                   pDriverInfo,
                                   dwFileCopyFlags,
                                   pIniSpooler,
                                   pInternalDriverFiles,
                                   dwFileCount,
                                   dwTempDir,
                                   pIniDriver);

    // Fail the call if pIniDriver failed
    if (pIniDriver == NULL) {
        return FALSE;
    }

    // Increment version numbers
    if (bDriverFileMoved) {
        IncrementFileVersion(pIniVersion, FindFileName(pInternalDriverFiles[0].pFileName));
    }
    if (bConfigFileMoved) {
        IncrementFileVersion(pIniVersion, FindFileName(pInternalDriverFiles[1].pFileName));
    }

    pDrvInfo4 = (LPDRIVER_INFO_4) pDriverInfo;

    if (pDrvInfo4->pEnvironment &&
        *pDrvInfo4->pEnvironment) {

        pEnvironment = pDrvInfo4->pEnvironment;
    }

    if ((dwLevel == 3 || dwLevel == 4 || dwLevel ==6) &&
        pDrvInfo4->pMonitorName &&
        *pDrvInfo4->pMonitorName &&
        _wcsicmp(pEnvironment, szWin95Environment)) {

        pIniLangMonitor = FindMonitor(pDrvInfo4->pMonitorName,
                                      pLocalIniSpooler);
    }

    if (pIniLangMonitor &&
        pIniDriver->pIniLangMonitor != pIniLangMonitor) {

        if (pIniDriver->pIniLangMonitor)
            pIniDriver->pIniLangMonitor->cRef--;

        if (pIniLangMonitor)
            pIniLangMonitor->cRef++;

        pIniDriver->pIniLangMonitor = pIniLangMonitor;
    }

    // Increment cRefs for leaving SplSem
    INCSPOOLERREF( pIniSpooler );
    INCDRIVERREF( pIniDriver );
    pIniEnvironment->cRef++;

    // Call DrvDriverEvent in the Driver. Environment and version checks are
    // done inside NotifyDriver.
    NotifyDriver(pIniSpooler,
                 pIniEnvironment,
                 pIniVersion,
                 pIniDriver,
                 DRIVER_EVENT_INITIALIZE,
                 0);

    bUpdatePrinters = DriverAddedOrUpgraded(pInternalDriverFiles, dwFileCount);

    //
    // Call DrvUprgadePrinter if the driver added belongs to this version
    // and environment. And the pIniSpooler is not a cluster spooler
    //
    if (!(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER) &&
        pThisEnvironment == pIniEnvironment) {

        // Walk through all pIniSpoolers that print.
        INCSPOOLERREF( pLocalIniSpooler );

        for( pTempIniSpooler = pLocalIniSpooler;
             pTempIniSpooler;
             pTempIniSpooler = pIniNextSpooler ){

            //
            // Do not touch the driver belonging to cluster spoolers. Cluster spoolers
            // handle thier drivers themselves
            //
             if (pTempIniSpooler->SpoolerFlags & SPL_PRINT && !(pTempIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER)){

                // Walk all the printers and see if anyone is using this driver.
                for ( pFixUpIniPrinter = pTempIniSpooler->pIniPrinter;
                      pFixUpIniPrinter != NULL;
                      pFixUpIniPrinter = pFixUpIniPrinter->pNext ) {

                    //  Does this Printer Have this driver ?
                    if ( lstrcmpi( pFixUpIniPrinter->pIniDriver->pName,
                                   pIniDriver->pName ) == STRINGS_ARE_EQUAL ) {

                        pTempIniDriver = FindCompatibleDriver( pIniEnvironment,
                                                               &pTempIniVersion,
                                                               pIniDriver->pName,
                                                               dwVersion,
                                                               FIND_COMPATIBLE_VERSION | DRIVER_UPGRADE);

                        SPLASSERT( pTempIniDriver != NULL );

                        //
                        // Does this Printer Has a Newer Driver it should be using ?
                        // Note: within the same version, pIniPrinter->pIniDriver
                        // does not change (the fields are updated in an upgrade,
                        // but the same pIniDriver is used).
                        //
                        // Version 2 is not compatible with anything else,
                        // so the pIniDrivers won't change in SUR.
                        //

                        if ( pTempIniDriver != pFixUpIniPrinter->pIniDriver ) {

                            DECDRIVERREF( pFixUpIniPrinter->pIniDriver );

                            pFixUpIniPrinter->pIniDriver = pTempIniDriver;

                            INCDRIVERREF( pFixUpIniPrinter->pIniDriver );
                        }
                    }
                }

                pOldDir = NULL;

                if ( !bDriverMoved ) {

                    // Use older version of the driver
                    pTempIniDriver = FindCompatibleDriver( pIniEnvironment,
                                                           &pTempIniVersion,
                                                           pIniDriver->pName,
                                                           (dwVersion>2)?(dwVersion - 1):dwVersion,
                                                           FIND_ANY_VERSION | DRIVER_UPGRADE);

                    if ( pTempIniDriver != NULL ) {

                        SPLASSERT( pTempIniVersion != NULL );


                        GetDriverVersionDirectory( szDirectory,
                                                   COUNTOF(szDirectory),
                                                   pIniSpooler,
                                                   pThisEnvironment,
                                                   pTempIniVersion,
                                                   pTempIniDriver,
                                                   NULL );

                        if ( DirectoryExists( szDirectory )) {

                            pOldDir = (LPWSTR) szDirectory;
                        }

                        cbBuf = GetDriverInfoSize(pTempIniDriver, 4, pTempIniVersion,
                                                  pIniEnvironment, NULL, pIniSpooler);

                        if (pDriver4 = (LPBYTE) AllocSplMem(cbBuf)) {

                            pUpgradeInfo2 = CopyIniDriverToDriverInfo(pIniEnvironment,
                                                                      pTempIniVersion,
                                                                      pTempIniDriver,
                                                                      4,
                                                                      pDriver4,
                                                                      pDriver4 + cbBuf,
                                                                      NULL,
                                                                      pIniSpooler);
                        }
                    }

                } else {

                    if((StrNCatBuff(szDirectory,
                                    MAX_PATH,
                                    pIniSpooler->pDir,
                                    L"\\drivers\\",
                                    pIniEnvironment->pDirectory,
                                    L"\\",
                                    pIniVersion->szDirectory,
                                    L"\\Old",
                                    NULL) == ERROR_SUCCESS))
                    {
                        pOldDir = (LPWSTR) szDirectory;
                    }
                    else
                    {
                       // ?????
                    }

                }

                INCDRIVERREF(pIniDriver);
                if( bUpdatePrinters) {
                    ForEachPrinterCallDriverDrvUpgrade(pTempIniSpooler,
                                                       pIniDriver,
                                                       pOldDir,
                                                       pInternalDriverFiles,
                                                       dwFileCount,
                                                       pUpgradeInfo2 ? pDriver4
                                                                     : NULL);
                }
                DECDRIVERREF(pIniDriver);
            }
            pIniNextSpooler = pTempIniSpooler->pIniNextSpooler;

            if ( pIniNextSpooler ) {
                INCSPOOLERREF( pIniNextSpooler );
            }
            DECSPOOLERREF( pTempIniSpooler );
        }
    }

    //
    // Perform driver upgrade if the pIniSpooler is a cluster spooler
    //
    if (pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER &&
        !lstrcmpi(pIniEnvironment->pName, szEnvironment)) {

        DBGMSG(DBG_CLUSTER, ("CompleteDriverUpgrade searching for cluster spooler printers\n"));

        //
        // Walk all the printers and see if anyone is using this driver.
        //
        for ( pFixUpIniPrinter = pIniSpooler->pIniPrinter;
              pFixUpIniPrinter != NULL;
              pFixUpIniPrinter = pFixUpIniPrinter->pNext )
        {
            //
            //  Does this Printer Have this driver ?
            //
            if (lstrcmpi(pFixUpIniPrinter->pIniDriver->pName, pIniDriver->pName) == STRINGS_ARE_EQUAL)
            {
                pTempIniDriver = FindCompatibleDriver(pIniEnvironment,
                                                      &pTempIniVersion,
                                                      pIniDriver->pName,
                                                      dwVersion,
                                                      FIND_COMPATIBLE_VERSION | DRIVER_UPGRADE);

                SPLASSERT( pTempIniDriver != NULL );

                //
                // Does this Printer Has a Newer Driver it should be using ?
                // Note: within the same version, pIniPrinter->pIniDriver
                // does not change (the fields are updated in an upgrade,
                // but the same pIniDriver is used).
                //
                // Version 2 is not compatible with anything else,
                // so the pIniDrivers won't change in SUR.
                //

                if ( pTempIniDriver != pFixUpIniPrinter->pIniDriver )
                {
                    DECDRIVERREF( pFixUpIniPrinter->pIniDriver );

                    pFixUpIniPrinter->pIniDriver = pTempIniDriver;

                    INCDRIVERREF( pFixUpIniPrinter->pIniDriver );
                }
            }
        }

        pOldDir = NULL;

        if ( !bDriverMoved )
        {
            // Use older version of the driver
            pTempIniDriver = FindCompatibleDriver( pIniEnvironment,
                                                   &pTempIniVersion,
                                                   pIniDriver->pName,
                                                   (dwVersion>2)?(dwVersion - 1):dwVersion,
                                                   FIND_ANY_VERSION | DRIVER_UPGRADE);

            if ( pTempIniDriver != NULL )
            {
                SPLASSERT( pTempIniVersion != NULL );

                GetDriverVersionDirectory( szDirectory,
                                           COUNTOF(szDirectory),
                                           pIniSpooler,
                                           pIniEnvironment,
                                           pTempIniVersion,
                                           pTempIniDriver,
                                           NULL );

                if ( DirectoryExists( szDirectory ))
                {
                    pOldDir = (LPWSTR) szDirectory;
                }

                cbBuf = GetDriverInfoSize(pTempIniDriver, 4, pTempIniVersion, pIniEnvironment, NULL, pIniSpooler);

                if (pDriver4 = (LPBYTE) AllocSplMem(cbBuf))
                {
                    pUpgradeInfo2 = CopyIniDriverToDriverInfo(pIniEnvironment,
                                                              pTempIniVersion,
                                                              pTempIniDriver,
                                                              4,
                                                              pDriver4,
                                                              pDriver4 + cbBuf,
                                                              NULL,
                                                              pIniSpooler);
                }
            }
            else
            {
                if((StrNCatBuff(szDirectory,
                                MAX_PATH,
                                pIniSpooler->pDir,
                                L"\\drivers\\",
                                pIniEnvironment->pDirectory,
                                L"\\",
                                pIniVersion->szDirectory,
                                L"\\Old",
                                NULL) == ERROR_SUCCESS))
                {
                    pOldDir = (LPWSTR) szDirectory;
                }
            }

            INCDRIVERREF(pIniDriver);
            if( bUpdatePrinters)
            {
                ForEachPrinterCallDriverDrvUpgrade(pIniSpooler,
                                                   pIniDriver,
                                                   pOldDir,
                                                   pInternalDriverFiles,
                                                   dwFileCount,
                                                   pUpgradeInfo2 ? pDriver4 : NULL);
            }

            DECDRIVERREF(pIniDriver);
        }
    }



    if (pDriver4) {
        FreeSplMem(pDriver4);
        pDriver4 = NULL;
    }

    //  Log Event - Successfully adding the printer driver.
    //
    //  Note we use pLocalIniSpooler here because drivers are currently
    //  global accross all spoolers and we always want it logged

    pTemp = BuildFilesCopiedAsAString(pInternalDriverFiles, dwFileCount);

    SplLogEvent(pLocalIniSpooler,
                LOG_WARNING,
                MSG_DRIVER_ADDED,
                TRUE,
                pIniDriver->pName,
                pIniEnvironment->pName,
                pIniVersion->pName,
                pTemp,
                NULL);

    FreeSplMem(pTemp);

    // Decrement cRefs after reentering SplSem
    DECSPOOLERREF( pIniSpooler );
    DECDRIVERREF( pIniDriver );
    pIniEnvironment->cRef--;

    SetPrinterChange(NULL,
                     NULL,
                     NULL,
                     PRINTER_CHANGE_ADD_PRINTER_DRIVER,
                     pLocalIniSpooler );

    return TRUE;
}

VOID CleanUpgradeDirectories()

/*++
Function Description:  Deletes the Old and New directories if there are
                       no pending driver upgrades.

Parameters: NONE

Return Values: NONE
--*/

{
    DWORD            dwError, dwSize, dwVersionIndex;
    BOOL             bPendingUpgrade = FALSE;
    HKEY             hRootKey = NULL, hUpgradeKey = NULL, hVersionKey = NULL;
    WCHAR            pDriverDir[MAX_PATH], pCleanupDir[MAX_PATH];
    PINIENVIRONMENT  pIniEnvironment;
    PINIVERSION      pIniVersion;

    // Open the registry key
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegistryRoot, 0,
                       NULL, 0, KEY_ALL_ACCESS, NULL, &hRootKey, NULL) ||

        RegCreateKeyEx(hRootKey, szPendingUpgrades, 0,
                       NULL, 0, KEY_ALL_ACCESS, NULL, &hUpgradeKey, NULL)) {

         goto CleanUp;
    }

    // loop thru the version entries
    for (dwVersionIndex = 0, hVersionKey = NULL;

         RestoreVersionKey(hUpgradeKey, dwVersionIndex, &hVersionKey);

         RegCloseKey(hVersionKey), hVersionKey = NULL, ++dwVersionIndex) {

        // Search for pending upgrade keys
        dwSize = MAX_PATH;
        dwError = RegEnumKeyEx(hVersionKey, 0, pDriverDir, &dwSize,
                               NULL, NULL, NULL, NULL);

        if (dwError != ERROR_NO_MORE_ITEMS) {
            bPendingUpgrade = TRUE;
            break;
        }
    }

    // If there aren't any pending driver upgrades, delete the Old and
    // new directories and the files within.
    if ( pLocalIniSpooler) {

        PINISPOOLER pIniSpooler;

        for (pIniSpooler = pLocalIniSpooler;
             pIniSpooler;
             pIniSpooler = pIniSpooler->pIniNextSpooler) {

            if (pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL ||
                pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER) {

                for (pIniEnvironment = pIniSpooler->pIniEnvironment;
                     pIniEnvironment;
                     pIniEnvironment = pIniEnvironment->pNext) {

                    for (pIniVersion = pIniEnvironment->pIniVersion;
                         pIniVersion;
                         pIniVersion = pIniVersion->pNext) {

                        if( StrNCatBuff( pDriverDir,
                                        COUNTOF(pDriverDir),
                                        pIniSpooler->pDir,
                                        L"\\drivers\\",
                                        pIniEnvironment->pDirectory,
                                        L"\\",
                                        pIniVersion->szDirectory,
                                        NULL) != ERROR_SUCCESS )

                            continue;

                        if( StrNCatBuff( pCleanupDir,
                                        COUNTOF(pCleanupDir),
                                        pDriverDir,
                                        L"\\Old",
                                        NULL) != ERROR_SUCCESS )
                            continue;


                        DeleteDirectoryRecursively(pCleanupDir, FALSE);

                        if( StrNCatBuff( pCleanupDir,
                                        COUNTOF(pCleanupDir),
                                        pDriverDir,
                                        L"\\New",
                                        NULL) != ERROR_SUCCESS )
                            continue;

                        if (!bPendingUpgrade) {

                            DeleteAllFilesAndDirectory(pCleanupDir, FALSE);
                        }
                    }
                }
            }
        }
    }

CleanUp:

    if (hVersionKey) {
        RegCloseKey(hVersionKey);
    }

    if (hUpgradeKey) {
        RegCloseKey(hUpgradeKey);
    }

    if (hRootKey) {
        RegCloseKey(hRootKey);
    }

    return;
}

BOOL
CheckFileCopyOptions(
    PINIENVIRONMENT     pIniEnvironment,
    PINIVERSION         pIniVersion,
    PINIDRIVER          pIniDriver,
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount,
    DWORD               dwFileCopyFlags,
    LPBOOL              pbSucceeded
    )

/*++

Function Description:

    CheckFileCopyOptions examines the timestamps of the source and
    target files and determines if strict upgrade/downgrade can fail.

Parameters:

    pIniEnvironment      - pointer to a PINIENVIRONMENT structure
    pIniVersion          - pointer to a PINIVERSION structure
    pIniDriver           - pointer to the old INIDRIVER structure
    pInternalDriverFiles - array of INTERNAL_DRV_FILE structures
    dwFileCount          - number of files in file set
    dwFileCopyFlags      - file copying options.
    pbSucceeded          - flag to indicate the AddPrinterDriver call succeeded.

Return Values:

    TRUE - We need to copy any files.  *pbSucceeded is unchanged.

    FALSE - We don't need to copy, either because the entire call failed
        (e.g., strict upgrade but older source files), or because we don't
        need to do anything.  *pbSucceeded indicates if the API call should
        succeed (the latter case).

--*/

{
    BOOL            bReturn = FALSE, bInSem = TRUE, bSameMainDriverName = FALSE;
    LPWSTR          pDrvDestDir = NULL, pICMDestDir = NULL, pNewDestDir = NULL;
    LPWSTR          pTargetFileName = NULL, pFileName;
    DWORD           dwCount;
    WIN32_FIND_DATA DestFileData, SourceFileData;
    HANDLE          hFileExists;
    DWORD           TimeStampComparison;
    enum { Equal, Newer, Older } DriverComparison;
    DWORD           dwDriverVersion;


    if (!pbSucceeded) {
        goto CleanUp;
    }

    *pbSucceeded = FALSE;

    SplInSem();

    switch (dwFileCopyFlags) {

    case APD_COPY_ALL_FILES:

        // Nothing to check
        bReturn = TRUE;
        break;

    case APD_COPY_NEW_FILES:

        // Check if the driver file sets are different
        if (pIniDriver)
        {
            pFileName = wcsrchr(pInternalDriverFiles[0].pFileName, L'\\');
            if (pFileName && pIniDriver->pDriverFile &&
                !_wcsicmp(pFileName+1, pIniDriver->pDriverFile))
            {
                bSameMainDriverName = TRUE;
            }
        }

    case APD_STRICT_UPGRADE:
    case APD_STRICT_DOWNGRADE:

        // Set up the destination directories
        if (!(pDrvDestDir = AllocSplMem( INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1 )) ||
            !(pNewDestDir = AllocSplMem( INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1 )) ||
            !(pTargetFileName = AllocSplMem( INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1 ))) {

             goto CleanUp;
        }

        // Regular driver directory
        if( !GetEnvironmentScratchDirectory( pDrvDestDir, MAX_PATH, pIniEnvironment, FALSE ) ) {

            goto CleanUp;
        }

        wcscat(pDrvDestDir, L"\\" );
        wcscat(pDrvDestDir, pIniVersion->szDirectory );

        // New driver files directory where files may be stored temporarily
        wcscpy(pNewDestDir, pDrvDestDir);
        wcscat(pNewDestDir, L"\\New");

        if (!wcscmp(pIniEnvironment->pName, szWin95Environment)) {

           if (!(pICMDestDir = AllocSplMem( INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1 ))) {
               goto CleanUp;
           }

           // ICM directory for win95
           wcscpy(pICMDestDir, pDrvDestDir);
           wcscat(pICMDestDir, L"\\Color");
        }

        if (pIniDriver) {
            INCDRIVERREF(pIniDriver);
        }
        LeaveSplSem();
        bInSem = FALSE;

        // Examine the timestamps for the source and the target files.
        for (dwCount = 0; dwCount < dwFileCount; ++dwCount) {

            // Get Source File Date & Time Stamp
            hFileExists = FindFirstFile(pInternalDriverFiles[dwCount].pFileName, &SourceFileData );

            if (hFileExists == INVALID_HANDLE_VALUE) {
                goto CleanUp;
            } else {
                FindClose(hFileExists);
            }

            if (!(pFileName = wcsrchr(pInternalDriverFiles[dwCount].pFileName, L'\\'))) {
                goto CleanUp;
            }

            //
            // Skip past the backslash.
            //
            ++pFileName;

            if (pICMDestDir && IsAnICMFile(pInternalDriverFiles[dwCount].pFileName)) {

                // Check in the Color Directory
                wsprintf(pTargetFileName, L"%ws\\%ws", pICMDestDir, pFileName);
                hFileExists = FindFirstFile(pTargetFileName, &DestFileData);

            } else {

                LPWSTR pszTestFileName;

                if ((dwCount == 0) && !bSameMainDriverName && pIniDriver) {

                    //
                    // We're processing the main driver file.  The server's
                    // file doesn't exist on the client, but the client does
                    // have a version of this driver.
                    //
                    // Instead of checking the server's file name on the
                    // client, we want to check the client's IniDriver->pDriver
                    // to see which is newer.
                    //
                    // For example, server has rasdd, while client has unidrv.
                    // Client does not have rasdd, so we would normally copy
                    // rasdd down to the client and change the DRIVER_INFO.
                    //
                    // Instead, we want to see if the server's unidrv is
                    // newer than the client's rasdd.  If so, then we
                    // need to upgrade.
                    //
                    // Even if the client did have a new unidrv (even a
                    // really new one), we still want to upgrade the
                    // client's DRIVER_INFO.
                    //
                    pszTestFileName = pIniDriver->pDriverFile;

                } else {

                    pszTestFileName = pFileName;
                }

                // Check in the new directory first
                wsprintf(pTargetFileName, L"%ws\\%ws", pNewDestDir, pszTestFileName);
                hFileExists = FindFirstFile(pTargetFileName, &DestFileData);

                if (hFileExists == INVALID_HANDLE_VALUE) {

                    // Check in the regular driver directory
                    wsprintf(pTargetFileName, L"%ws\\%ws", pDrvDestDir, pszTestFileName);
                    hFileExists = FindFirstFile(pTargetFileName, &DestFileData);
                }
            }

            if (hFileExists != INVALID_HANDLE_VALUE) {

               FindClose(hFileExists);

               EnterSplSem();
               if (pIniDriver) {
                   DECDRIVERREF(pIniDriver);
               }
               bInSem = TRUE;

               if (!GetDriverFileCachedVersion(pIniVersion, pTargetFileName, &dwDriverVersion)) {
                   SetLastError(ERROR_CAN_NOT_COMPLETE);
                   goto CleanUp;
               }

               if (pIniDriver) {
                   INCDRIVERREF(pIniDriver);
               }
               LeaveSplSem();
               bInSem = FALSE;

               DriverComparison = pInternalDriverFiles[dwCount].dwVersion == dwDriverVersion ?
                                      Equal :
                                      pInternalDriverFiles[dwCount].dwVersion > dwDriverVersion ?
                                          Newer :
                                          Older;

               if (DriverComparison == Equal) {

                   TimeStampComparison = CompareFileTime( &SourceFileData.ftLastWriteTime,
                                                          &DestFileData.ftLastWriteTime );

                   DriverComparison = TimeStampComparison == 1 ?
                                          Newer :
                                          TimeStampComparison == -1 ?
                                              Older :
                                              Equal;
               }

               switch (DriverComparison) {

               case Newer:
                  // Source file newer than the target. Strict downgrade will fail.
                  if (dwFileCopyFlags == APD_STRICT_DOWNGRADE) {
                      SetLastError(ERROR_CAN_NOT_COMPLETE);
                      goto CleanUp;
                  }
                  break;

               case Older:
                  // Target file newer than the source. Strict upgrade will fail.
                  if (dwFileCopyFlags == APD_STRICT_UPGRADE) {
                      SetLastError(ERROR_CAN_NOT_COMPLETE);
                      goto CleanUp;
                  } else {

                      //
                      // If we are doing a copy new files (non-strict upgrade),
                      // and the main driver files are different, and
                      // the driver is already installed, then we want to use
                      // the existing driver.
                      //
                      if ((dwFileCopyFlags == APD_COPY_NEW_FILES) &&
                          (dwCount == 0) && !bSameMainDriverName &&
                          pIniDriver)
                      {
                          *pbSucceeded = TRUE;
                          goto CleanUp;
                      }
                  }
                  break;

               default:
                  // file times are the same
                  break;
               }
            }
        }

        bReturn = TRUE;
        break;

    default:

        // Unknown flag
        SetLastError(ERROR_INVALID_PARAMETER);
        break;
    }

CleanUp:

    if (!bInSem) {
        EnterSplSem();
        if (pIniDriver) {
            DECDRIVERREF(pIniDriver);
        }
    }
    if (pDrvDestDir) {
        FreeSplMem(pDrvDestDir);
    }
    if (pTargetFileName) {
        FreeSplMem(pTargetFileName);
    }
    if (pICMDestDir) {
        FreeSplMem(pICMDestDir);
    }
    if (pNewDestDir) {
        FreeSplMem(pNewDestDir);
    }

    return bReturn;
}

BOOL
LocalDeletePrinterDriver(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pDriverName
    )
{

    BOOL bReturn;
    bReturn = LocalDeletePrinterDriverEx( pName,
                                          pEnvironment,
                                          pDriverName,
                                          0,
                                          0);

    return bReturn;
}

BOOL
LocalDeletePrinterDriverEx(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pDriverName,
    DWORD    dwDeleteFlag,
    DWORD    dwVersionNum
    )
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplDeletePrinterDriverEx( pName,
                                        pEnvironment,
                                        pDriverName,
                                        pIniSpooler,
                                        dwDeleteFlag,
                                        dwVersionNum);

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}

BOOL
SplDeletePrinterDriverEx(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pDriverName,
    PINISPOOLER pIniSpooler,
    DWORD    dwDeleteFlag,
    DWORD    dwVersionNum
    )
/*++

Function Description: Deletes specific or all versions of a printer driver. Removes unused
                      or all files associated with the driver.

Parameters: pName - name of the server. NULL implies local machine.
            pEnvironment - string containing the environment of the driver to be deleted.
                           NULL implies use local environment.
            pDriverName - string containing the name of the driver.
            pIniSpooler - Pointer to INISPOOLER struct.
            dwDeleteFlag - combination of DPD_DELETE_SPECIFIC_VERSION and
                            DPD_DELETE_UNUSED_FILES or DPD_DELETE_ALL_FILES. The defaults
                            are delete all versions and dont delete the files.
            dwVersionNum - version number (0-3) of the driver. Used only if dwDeleteFlag
                           contains DPD_DELETE_SPECIFIC_VERSION.

Return Values: TRUE if deleted.
               FALSE otherwise.

--*/
{
    PINIENVIRONMENT pIniEnvironment;
    PINIVERSION pIniVersion;
    PINIDRIVER  pIniDriver;
    BOOL        bRefCount = FALSE,bEnteredSplSem = FALSE,bReturn = TRUE;
    BOOL        bFileRefCount = FALSE;
    BOOL        bThisVersion,bSetPrinterChange = FALSE;
    BOOL        bFoundDriver = FALSE, bSpecificVersionDeleted = FALSE;
    LPWSTR      pIndex;
    WCHAR       szDirectory[MAX_PATH];
    HANDLE      hImpersonationToken;
    DWORD       dwRet;


    DBGMSG(DBG_TRACE, ("DeletePrinterDriverEx\n"));

    // Check if the call is for the local machine.
    if ( pName && *pName ) {
        if ( !MyName( pName, pIniSpooler )) {
            bReturn = FALSE;
            goto CleanUp;
        }
    }

    // Invalid Input and Access Checks
    if ( !pDriverName || !*pDriverName ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        bReturn = FALSE;
        goto CleanUp;
    }

    if (dwDeleteFlag & ~(DPD_DELETE_SPECIFIC_VERSION
                         | DPD_DELETE_ALL_FILES
                         | DPD_DELETE_UNUSED_FILES)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        bReturn = FALSE;
        goto CleanUp;
    }

    if ( !ValidateObjectAccess( SPOOLER_OBJECT_SERVER,
                                SERVER_ACCESS_ADMINISTER,
                                NULL, NULL, pIniSpooler )) {
       bReturn = FALSE;
       goto CleanUp;
    }

   EnterSplSem();
   bEnteredSplSem = TRUE;

    pIniEnvironment = FindEnvironment(pEnvironment, pIniSpooler);

    if ( !pIniEnvironment ) {
        SetLastError(ERROR_INVALID_ENVIRONMENT);
        bReturn = FALSE;
        goto CleanUp;
    }
    pIniVersion = pIniEnvironment->pIniVersion;

    while ( pIniVersion ) {

        if ((pIniDriver = FindDriverEntry(pIniVersion, pDriverName))) {

            bFoundDriver = TRUE;

            // bThisVersion indicates if this version is to be deleted.
            bThisVersion = !(dwDeleteFlag & DPD_DELETE_SPECIFIC_VERSION) ||
                           (pIniVersion->cMajorVersion == dwVersionNum);

            if ((pIniDriver->cRef) && bThisVersion) {
               bRefCount = TRUE;
               break;
            }

            if (bThisVersion &&
                (dwDeleteFlag & DPD_DELETE_ALL_FILES) &&
                FilesInUse(pIniVersion,pIniDriver)) {

               bFileRefCount = TRUE;
               break;
            }
        }

        pIniVersion = pIniVersion->pNext;
    }

    if ( !bFoundDriver ) {
        SetLastError(ERROR_UNKNOWN_PRINTER_DRIVER);
        bReturn = FALSE;
        goto CleanUp;
    }

    if ( bRefCount ) {
        SetLastError( ERROR_PRINTER_DRIVER_IN_USE );
        bReturn = FALSE;
        goto CleanUp;
    }

    if ( bFileRefCount ) {
        // New error code has to added.
        SetLastError( ERROR_PRINTER_DRIVER_IN_USE );
        bReturn = FALSE;
        goto CleanUp;
    }

    pIniVersion = pIniEnvironment->pIniVersion;

    while ( pIniVersion && (!bSpecificVersionDeleted) ) {

       if ( !(dwDeleteFlag & DPD_DELETE_SPECIFIC_VERSION) ||
            (bSpecificVersionDeleted = (pIniVersion->cMajorVersion == dwVersionNum))) {

        if (( pIniDriver = FindDriverEntry( pIniVersion, pDriverName ))) {

            //
            // Remove pending driver upgrades for local environment
            //
            if (!lstrcmpi(pIniEnvironment->pName, szEnvironment)) {

                RemovePendingUpgradeForDeletedDriver(pDriverName,
                                                     pIniVersion->cMajorVersion,
                                                     pIniSpooler);

                RemoveDriverTempFiles(pIniSpooler, pIniEnvironment,
                                      pIniVersion, pIniDriver);
            }

            if ( !DeleteDriverIni( pIniDriver,
                                   pIniVersion,
                                   pIniEnvironment,
                                   pIniSpooler )) {

                DBGMSG( DBG_CLUSTER, ("Error - driverini not deleted %d\n", GetLastError()));
                bReturn = FALSE;
                goto CleanUp;
            }

            bSetPrinterChange = TRUE;
            hImpersonationToken = RevertToPrinterSelf();

            SPLASSERT(pIniSpooler->pDir!=NULL);

            dwRet = StrNCatBuff(szDirectory,
                                COUNTOF(szDirectory),
                                pIniSpooler->pDir,
                                L"\\drivers\\",
                                pIniEnvironment->pDirectory,
                                L"\\",
                                pIniVersion->szDirectory,
                                L"\\",
                                NULL);

            if (dwRet != ERROR_SUCCESS)
            {
                 if (hImpersonationToken)
                 {
                    ImpersonatePrinterClient(hImpersonationToken);
                 }
                bReturn = FALSE;
                SetLastError(dwRet);
                goto CleanUp;
            }

            //
            // Before we leave for the driver event. Mark this printer driver as
            // pending deletion. This prevents other calls from mistakenly using
            // this driver, even though it is about to be deleted. Drivers should
            // not expect to find any other information about the driver during this
            // call other than what they were presented with.
            //
            pIniDriver->dwDriverFlags |= PRINTER_DRIVER_PENDING_DELETION;

            //
            // Increment cRefs for leaving SplSem, this prevent SplDeletePrinterDriver
            // from being called twice.
            //
            INCSPOOLERREF( pIniSpooler );
            INCDRIVERREF( pIniDriver );
            pIniEnvironment->cRef++;

            // Call DrvDriverEvent in the Driver.
            NotifyDriver(pIniSpooler,
                         pIniEnvironment,
                         pIniVersion,
                         pIniDriver,
                         DRIVER_EVENT_DELETE,
                         dwDeleteFlag);

            // Decrement cRefs after reentering SplSem
            DECDRIVERREF( pIniDriver );
            DECSPOOLERREF( pIniSpooler );
            pIniEnvironment->cRef--;

            // Update the file reference counts for the version of the driver that
            // has been deleted.
            UpdateDriverFileRefCnt(pIniEnvironment,pIniVersion,pIniDriver,szDirectory,dwDeleteFlag,FALSE);

            if (hImpersonationToken) {
               ImpersonatePrinterClient(hImpersonationToken);
            }

            DeleteDriverEntry( pIniVersion, pIniDriver );
        }

       }

       pIniVersion = pIniVersion->pNext;
    }

    if (bSetPrinterChange) {
        SetPrinterChange( NULL,
                          NULL,
                          NULL,
                          PRINTER_CHANGE_DELETE_PRINTER_DRIVER,
                          pIniSpooler );
    }

CleanUp:

   if (bEnteredSplSem) {
      LeaveSplSem();
   }

   return bReturn;

}

VOID
RemoveDriverTempFiles(
    PINISPOOLER  pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER pIniDriver
    )

/*++
Function Description: Removes temp directory associated with the driver

Parameters: pIniSpooler       - pointer to INISPOOLER
            pIniEnvironment   - pointer to INIENVIRONMENT
            pIniVersion       - pointer to INIVERSION
            pIniDriver        - pointer to INIDRIVER

Return Values: NONE
--*/

{
    WCHAR   szDriverDir[MAX_PATH], szDriverFile[MAX_PATH];
    LPCWSTR  pszDriverFile, pszConfigFile;
    DWORD   DriverFileSize, ConfigFileSize, MaxFileSize;
    fnWinSpoolDrv fnList;

    pszDriverFile = FindFileName(pIniDriver->pDriverFile);
    pszConfigFile = FindFileName(pIniDriver->pConfigFile);

    DriverFileSize = pszDriverFile ? wcslen(pszDriverFile) : 0 ;

    ConfigFileSize = pszConfigFile ? wcslen(pszConfigFile) : 0 ;

    MaxFileSize = ConfigFileSize > DriverFileSize ?
                  ConfigFileSize :
                  DriverFileSize;


    if (pIniDriver->dwTempDir &&
        GetDriverVersionDirectory(szDriverDir,
                                  COUNTOF(szDriverDir) - MaxFileSize -1,
                                  pIniSpooler,
                                  pIniEnvironment,
                                  pIniVersion,
                                  pIniDriver,
                                  NULL))
    {
        // Unload the driver files if neccessary

        if( pszDriverFile &&
            StrNCatBuff (szDriverFile,
                        COUNTOF(szDriverFile),
                        szDriverDir,
                        L"\\",
                        pszDriverFile,
                        NULL) == ERROR_SUCCESS ) {

            GdiArtificialDecrementDriver(szDriverFile, pIniDriver->dwDriverAttributes);
        }



        if( pszConfigFile &&
            StrNCatBuff (szDriverFile,
                        COUNTOF(szDriverFile),
                        szDriverDir,
                        L"\\",
                        pszConfigFile,
                        NULL) == ERROR_SUCCESS ) {
            if (SplInitializeWinSpoolDrv(&fnList)) {
                (* (fnList.pfnForceUnloadDriver))(szDriverFile);
            }
        }
        // Delete the files and the directory
        DeleteAllFilesAndDirectory(szDriverDir, FALSE);

    }

    return;
}


VOID RemovePendingUpgradeForDeletedDriver(
    LPWSTR      pDriverName,
    DWORD       dwVersion,
    PINISPOOLER pIniSpooler
    )

/*++
Function Description: Removes pending upgrade keys for deleted drivers.

Parameters: pDriverName  - driver name (eg. HP LaserJet 5)
            dwVersion    - version number being deleted

Return Values: NONE
--*/

{
    HKEY    hRootKey = NULL, hUpgradeKey = NULL, hVersionKey = NULL;
    HANDLE  hToken = NULL;
    WCHAR   pDriver[MAX_PATH];
    BOOL    bAllocMem = FALSE;
    DWORD   dwSize;

    // Parameter check
    if (!pDriverName || !*pDriverName) {
        // Invalid strings
        return;
    }

    hToken = RevertToPrinterSelf();

    DBGMSG(DBG_CLUSTER, ("RemovePendingUpgradeForDeletedDriver Driver "TSTR"\n", pDriverName));

    wsprintf(pDriver, L"Version-%d", dwVersion);

    //
    // The local spooler and cluster spooler have different sets of drivers.
    // The root registry is different.
    //
    if (pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG)
    {
        hRootKey = pIniSpooler->hckRoot;
    }
    else
    {
        SplRegCreateKey(HKEY_LOCAL_MACHINE,
                        szRegistryRoot,
                        0,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hRootKey,
                        NULL,
                        NULL);
    }

    // Open the registry key
    if (hRootKey &&
        SplRegCreateKey(hRootKey,
                        szPendingUpgrades,
                        0,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hUpgradeKey,
                        NULL,
                        pIniSpooler) == ERROR_SUCCESS &&
        SplRegCreateKey(hUpgradeKey,
                        pDriver,
                        0,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hVersionKey,
                        NULL,
                        pIniSpooler) == ERROR_SUCCESS)
    {
        // Delete driver subkey, if any (since reg apis are not case sensitive)
        SplRegDeleteKey(hVersionKey, pDriverName, pIniSpooler);
    }

    if (hVersionKey) {
        SplRegCloseKey(hVersionKey, pIniSpooler);
    }

    if (hUpgradeKey) {
        SplRegCloseKey(hUpgradeKey, pIniSpooler);
    }

    //
    // Do not close the root key if the spooler is a cluster spooler
    //
    if (hRootKey && !(pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG)) {
        SplRegCloseKey(hRootKey, pIniSpooler);
    }

    if (hToken) {
        ImpersonatePrinterClient(hToken);
    }

    return;
}


BOOL
NotifyDriver(
    PINISPOOLER     pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION     pIniVersion,
    PINIDRIVER      pIniDriver,
    DWORD           dwDriverEvent,
    DWORD           dwParameter
    )
/*++
Function description: Calls DrvDriverEvent, to allow the driver to cleanup some of it's
                      private files. The function is called inside SplSem.

Parameters: pIniSpooler - pointer to INISPOOLER struct.
            pIniEnvironment - pointer to INIENVIRONMENT struct.
            pIniVersion - pointer to INIVERSION struct.
            pIniDriver - pointer to the INIDRIVER struct of the driver to be notified.
            dwDriverEvent - the type of Driver Event (delete | initialize)
            dwParameter - LPARAM to pass to DrvDriverEvent. Contains dwDeleteFlag for
                            DRIVER_EVENT_DELETE

Return Values: TRUE if DrvDriverEvent returns TRUE or if it need not be called.
               FALSE if DrvDriverEvent could not be called or if it returns FALSE.

--*/
{
    WCHAR       szDriverLib[MAX_PATH];
    FARPROC     pfnDrvDriverEvent;
    HINSTANCE   hDrvLib = NULL;
    LPBYTE      pDriverInfo = NULL;
    DWORD       cbBuf;
    BOOL        bReturn = FALSE;

    SplInSem();

    // Check if the driver could have been used by the system. Version number should be
    // 2 or 3, Environment should match with the global szEnvironment.

    if (((pIniVersion->cMajorVersion != SPOOLER_VERSION) &&
         (pIniVersion->cMajorVersion != COMPATIBLE_SPOOLER_VERSION)) ||
        lstrcmpi(pIniEnvironment->pName,szEnvironment)) {

        return TRUE;
    }

    // Get the directory where the driver files are stored.

    if( pIniDriver->pConfigFile &&
        GetDriverVersionDirectory(szDriverLib,
                                  (DWORD)(COUNTOF(szDriverLib) - wcslen(pIniDriver->pConfigFile) - 2),
                                  pIniSpooler, pIniEnvironment,
                                  pIniVersion, pIniDriver, NULL)) {


        if((StrNCatBuff(szDriverLib,
                       COUNTOF(szDriverLib),
                       szDriverLib,
                       L"\\",
                       pIniDriver->pConfigFile,
                       NULL) == ERROR_SUCCESS))
        {

             // Load the driver dll for the version being deleted.

             if (hDrvLib = LoadDriver(szDriverLib))
             {
                 if (pfnDrvDriverEvent = GetProcAddress(hDrvLib, "DrvDriverEvent")) {

                    // If the DrvDriverEvent is supported Copy pIniDriver Info into a
                    // DRIVER_INFO_3 struct and call the DrvDriverEvent Function.

                    cbBuf = GetDriverInfoSize( pIniDriver, 3, pIniVersion, pIniEnvironment,
                                                       NULL, pIniSpooler );

                    if (pDriverInfo = (LPBYTE) AllocSplMem(cbBuf)) {

                       if (CopyIniDriverToDriverInfo( pIniEnvironment,
                                                      pIniVersion,
                                                      pIniDriver,
                                                      3,
                                                      pDriverInfo,
                                                      pDriverInfo + cbBuf,
                                                      NULL,
                                                      pIniSpooler )) {

                           // Leave the semaphore before calling into the spooler
                           LeaveSplSem();
                           SplOutSem();


                           try {

                             bReturn = (BOOL) pfnDrvDriverEvent(dwDriverEvent,
                                                                3,
                                                                pDriverInfo,
                                                                (LPARAM) dwParameter);

                           } except(EXCEPTION_EXECUTE_HANDLER) {

                                 SetLastError( GetExceptionCode() );
                                 DBGMSG(DBG_ERROR,
                                        ("NotifyDriver ExceptionCode %x Driver %ws Error %d\n",
                                        GetLastError(), szDriverLib, GetLastError() ));
                                 bReturn = FALSE;
                           }
                           // Reenter the semaphore
                           EnterSplSem();
                       }
                    }
                 }
             }
        }
    }

    if (pDriverInfo) {
       FreeSplMem(pDriverInfo);
    }

    if (hDrvLib) {
        UnloadDriver(hDrvLib);
    }

    return bReturn;
}

VOID
DeleteScratchDriverFile(
    LPCWSTR  pszDirectory,
    LPCWSTR  pszFileName,
    DWORD    dwSize)
/*++
Function Description : Deletes the driver file from the spooler scratch directory. Applications
                       and print UI place the driver files here before calling AddPrinterDriver.

Parameters : pszDirectory -  Directory where the driver file is placed (scratch\version\)
             pszFileName  -  Name of the file to be removed
             dwSize       -  Memory required to store the entire file name

Return Values : NONE
--*/
{
    WCHAR    szDelFile[MAX_PATH];
    LPWSTR   pszDelFile = NULL, pSwitch;
    BOOL     bAllocMem = FALSE;

    if (!pszDirectory || !*pszDirectory ||
        !pszFileName || !*pszFileName) {

         // Nothing to delete
         return;
    }

    // Allocate memory for the file name (if necessary)
    if (dwSize > MAX_PATH) {
       if (pszDelFile =  (LPWSTR) AllocSplMem(dwSize)) {
           bAllocMem = TRUE;
       } else {
           return;
       }
    } else {
       pszDelFile = (LPWSTR) szDelFile;
    }

    // Remove the version entry in the directory name
    wcscpy(pszDelFile, pszDirectory);

    if (pSwitch = wcsrchr(pszDelFile, L'\\')) {
        *pSwitch = L'\0';
    }

    if (pSwitch = wcsrchr(pszDelFile, L'\\')) {
        *(pSwitch + 1) = L'\0';
    }
    wcscat(pszDelFile, pszFileName);

    // No need to try to delete the files on reboot, since these dll's are
    // never loaded
    SplDeleteFile(pszDelFile);

    // Free Allocated memory (if any)
    if (bAllocMem) {
       FreeSplMem(pszDelFile);
    }

    return;
}

PDRVREFCNT
DecrementFileRefCnt(
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER pIniDriver,
    LPCWSTR pszFileName,
    LPCWSTR pszDirectory,
    DWORD dwDeleteFlag
    )
/*++

Function description: Decrements the driver file usage reference counts and deletes unused
                      files depending on dwDeleteFlag.

Paramaters:  pIniEnvironment - pointer to INIENVIRONMENT
             pIniVersion - pointer to INIVERSION struct. This struct contains the ref counts.
             pIniDriver - pointer to INIDRIVER
             szFileName - driver file name whose ref count is to be decremented.
             szDirectory - Directory where the files are located.
             dwDeleteFlag - unused files are deleted if this flag contains
                            DPD_DELETE_UNUSED_FILES or DPD_DELETE_ALL_FILES

Return Value: pointer to the DRVREFCNT which was decremented
              NULL if memory allocation fails.

--*/
{

    PDRVREFCNT pdrc,*pprev;
    LPWSTR     pszDelFile=NULL;
    WCHAR      szTempDir[MAX_PATH+5],szTempFile[MAX_PATH];
    DWORD      dwSize;
    PDRVREFCNT pReturn = NULL;

    SplInSem();

    pdrc = pIniVersion->pDrvRefCnt;
    pprev = &(pIniVersion->pDrvRefCnt);

    // Go thru the list of ref count nodes in the Iniversion struct and find the node
    // corresponding to szFileName.

    while (pdrc != NULL) {
       if (lstrcmpi(pszFileName,pdrc->szDrvFileName) == 0) {

         if (pdrc->refcount == 1 &&
             ((dwDeleteFlag & DPD_DELETE_UNUSED_FILES) ||
             (dwDeleteFlag & DPD_DELETE_ALL_FILES)) ) {

              // Delete the file.
              dwSize = sizeof(pszDirectory[0])*(wcslen(pszDirectory)+1);
              dwSize += sizeof(pszFileName[0])*(wcslen(pszFileName)+1);

              pszDelFile = (LPWSTR) AllocSplMem(dwSize);
              if (!pszDelFile) {
                pReturn = NULL;
                goto CleanUp;
              }
              wcscpy(pszDelFile, pszDirectory);
              wcscat(pszDelFile, pszFileName);

              if (pIniDriver) {

                 if (!lstrcmpi(pszFileName, pIniDriver->pDriverFile)) {

                     FilesUnloaded(pIniEnvironment, pszDelFile,
                                   NULL, pIniDriver->dwDriverAttributes);
                 }
                 else if (!lstrcmpi(pszFileName, pIniDriver->pConfigFile)) {

                     FilesUnloaded(pIniEnvironment, NULL,
                                   pszDelFile, pIniDriver->dwDriverAttributes);
                 }
              }

              //
              // We are about to delete a driver file. Delete the same file from
              // the cluster disk too (if applicable)
              //
              if (pIniEnvironment->pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER)
              {
                  WCHAR szFilePath[MAX_PATH] = {0};

                  //
                  // If DeleteFile fails, there isn't much we can do about it.
                  // The file will remain on the cluster disk.
                  //
                  if (StrNCatBuff(szFilePath,
                                  MAX_PATH,
                                  pIniEnvironment->pIniSpooler->pszClusResDriveLetter,
                                  L"\\",
                                  szClusterDriverRoot,
                                  L"\\",
                                  pIniEnvironment->pDirectory,
                                  L"\\",
                                  pIniVersion->szDirectory,
                                  L"\\",
                                  pszFileName,
                                  NULL) == ERROR_SUCCESS &&
                      SplDeleteFile(szFilePath))
                  {
                      DBGMSG(DBG_CLUSTER, ("DecrementFilesRefCnt Deleted szFilePath "TSTR" from cluster\n", szFilePath));
                  }
              }

              if (!SplDeleteFile(pszDelFile)) {
                 // Move the file to a temp directory and delete on REBOOT.
                 // Create the temp directory and new tempfile.

                 wcscpy(szTempDir, pszDirectory);
                 wcscat(szTempDir, L"temp");

                 //
                 // Fix for 420824. CreateDirectory will fail, if szTempDir already
                 // exists. Since we don't check for any errors, subsequent functions
                 // may fail.
                 //
                 CreateDirectory(szTempDir,NULL);

                 GetTempFileName(szTempDir,pszFileName,0,szTempFile);
                 SplMoveFileEx(pszDelFile,szTempFile,MOVEFILE_REPLACE_EXISTING);
                 SplMoveFileEx(szTempFile,NULL,MOVEFILE_DELAY_UNTIL_REBOOT);
              }

                 // Delete the corresponding file from the scratch directory
              DeleteScratchDriverFile(pszDirectory, pszFileName, dwSize);

              *pprev = pdrc->pNext;
         }

         // Decrement the ref cnt for the file.

         if (pdrc->refcount > 0) pdrc->refcount--;
         pReturn = pdrc;
         break;

       }
       pprev = &(pdrc->pNext);
       pdrc = pdrc->pNext;
    }

CleanUp:

    if (pszDelFile) {
       FreeSplMem(pszDelFile);
    }
    return pReturn;
}


BOOL
SplGetPrinterDriver(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    DWORD   dwDontCare;

    return SplGetPrinterDriverEx(hPrinter,
                                 pEnvironment,
                                 Level,
                                 pDriverInfo,
                                 cbBuf,
                                 pcbNeeded,
                                 0,
                                 0,
                                 &dwDontCare,
                                 &dwDontCare
                                 );
}

BOOL
LocalGetPrinterDriverDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplGetPrinterDriverDirectory( pName,
                                            pEnvironment,
                                            Level,
                                            pDriverInfo,
                                            cbBuf,
                                            pcbNeeded,
                                            pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}

BOOL
SplGetPrinterDriverDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    PINISPOOLER pIniSpooler
)
{
    DWORD       cb;
    WCHAR       string[MAX_PATH];
    BOOL        bRemote=FALSE;
    PINIENVIRONMENT pIniEnvironment;
    HANDLE      hImpersonationToken;
    DWORD       ParmError;
    SHARE_INFO_1501 ShareInfo1501;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    PSHARE_INFO_2 pShareInfo = (PSHARE_INFO_2)pIniSpooler->pDriversShareInfo;

    DBGMSG( DBG_TRACE, ("GetPrinterDriverDirectory\n"));

    if ( pName && *pName ) {

        if ( !MyName( pName, pIniSpooler )) {

            return FALSE;

        } else {
            bRemote = TRUE;
        }
    }

    if ( !ValidateObjectAccess( SPOOLER_OBJECT_SERVER,
                                SERVER_ACCESS_ENUMERATE,
                                NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

   EnterSplSem();

    pIniEnvironment = FindEnvironment( pEnvironment, pIniSpooler );

    if ( !pIniEnvironment ) {

       LeaveSplSem();
        SetLastError( ERROR_INVALID_ENVIRONMENT );
        return FALSE;
    }


    // Ensure that the directory exists

    GetDriverDirectory( string, COUNTOF(string), pIniEnvironment, NULL, pIniSpooler );

    hImpersonationToken = RevertToPrinterSelf();

    CreateCompleteDirectory( string );

    ImpersonatePrinterClient( hImpersonationToken );



    cb = GetDriverDirectory( string, COUNTOF(string), pIniEnvironment, bRemote ? pName : NULL, pIniSpooler )
         * sizeof(WCHAR) + sizeof(WCHAR);

    *pcbNeeded = cb;

   LeaveSplSem();

    if (cb > cbBuf) {

       SetLastError( ERROR_INSUFFICIENT_BUFFER );
       return FALSE;
    }

    wcscpy( (LPWSTR)pDriverInfo, string );

    memset( &ShareInfo1501, 0, sizeof ShareInfo1501 );


    // Also ensure the drivers share exists

    if ( bRemote ) {

        NET_API_STATUS rc;

        if ( rc = (*pfnNetShareAdd)(NULL, 2, (LPBYTE)pIniSpooler->pDriversShareInfo, &ParmError )) {

            DBGMSG( DBG_WARNING, ("NetShareAdd failed: Error %d, Parm %d\n", rc, ParmError));
        }

        else if (pSecurityDescriptor = CreateDriversShareSecurityDescriptor( )) {

            ShareInfo1501.shi1501_security_descriptor = pSecurityDescriptor;

            if (rc = (*pfnNetShareSetInfo)(NULL, pShareInfo->shi2_netname, 1501,
                                           &ShareInfo1501, &ParmError)) {

                DBGMSG( DBG_WARNING, ("NetShareSetInfo failed: Error %d, Parm %d\n", rc, ParmError));

            }

            LocalFree(pSecurityDescriptor);
        }
    }

    return TRUE;
}

BOOL
LocalEnumPrinterDrivers(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplEnumPrinterDrivers( pName, pEnvironment, Level, pDriverInfo,
                                     cbBuf, pcbNeeded, pcReturned,
                                     pIniSpooler);

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}

/*++

Routine Name

    FindDriverInList

Routine Description:

    Finds a certain driver in a list of drivers. None of the arguments
    can or will be null.

Arguments:
    pDriverList - array of DRIVER INFO 6 strucutres
    cDrivers    - number of drivers in the list
    pszName     - name of the driver we are looking for
    pszEnv      - environment of the driver we are looking for
    dwVersion   - version of the driver we are looking for

Return Value:

    valid pointer to driver info 6 structure if the driver is found
    NULL if the driver was not found

--*/
DRIVER_INFO_6*
FindDriverInList(
    DRIVER_INFO_6 *pDriverList,
    DWORD          cDrivers,
    LPCWSTR        pszName,
    LPCWSTR        pszEnv,
    DWORD          dwVersion
    )
{
    DWORD          uIndex;
    DRIVER_INFO_6 *pDrv6   = NULL;

    for (pDrv6 = pDriverList, uIndex = 0;
         pDrv6 && uIndex < cDrivers;
         pDrv6++, uIndex++)
    {
        if (!_wcsicmp(pDrv6->pName, pszName)       &&
            !_wcsicmp(pDrv6->pEnvironment, pszEnv) &&
            pDrv6->cVersion == dwVersion)
        {
            break;
        }
    }

    //
    // Check if driver was found
    //
    return uIndex == cDrivers ? NULL : pDrv6;
}

/*++

Routine Name

    GetBufferSizeForPrinterDrivers

Routine Description:

    Helper function for SplEnumAllClusterPrinterDrivers. Calculates the
    bytes needed to hold all printer driver strucutres on all the spoolers
    hosted by the spooler process. Note that we may ask for more bytes
    than we really need. This is beacuse we enumerate the drivers on the
    local  spooler and on cluster spoolers and we count duplicates again.
    In order to count the exact number of bytes needed, we would need to
    loop through the drivers and search each of them in all spoolers. This
    would be too slow.

Arguments:

    pszRemote   - NULL if the caller is local on the machine, a string otherwise

Return Value:

    Count of bytes needed to store all the drivers

--*/
DWORD
GetBufferSizeForPrinterDrivers(
    LPWSTR pszRemote
    )
{
    PINISPOOLER     pIniSpooler;
    PINIENVIRONMENT pIniEnvironment;
    PINIVERSION     pIniVersion;
    PINIDRIVER      pIniDriver;
    DWORD           cbNeeded = 0;

    SplInSem();

    for (pIniSpooler = pLocalIniSpooler;
         pIniSpooler;
         pIniSpooler = pIniSpooler->pIniNextSpooler)
    {
        //
        // We want either a pIniSpooler that is not a clusrer, or
        // a pIniSpooler that is a cluster spooler that is not
        // in pending deletion or offline
        //
        if (!(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER) ||
            pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER &&
            !(pIniSpooler->SpoolerFlags & SPL_PENDING_DELETION ||
              pIniSpooler->SpoolerFlags & SPL_OFFLINE))
        {
            for (pIniEnvironment = pIniSpooler->pIniEnvironment;
                 pIniEnvironment;
                 pIniEnvironment = pIniEnvironment->pNext)
            {
                for (pIniVersion = pIniEnvironment->pIniVersion;
                     pIniVersion;
                     pIniVersion = pIniVersion->pNext)
                {
                    for (pIniDriver = pIniVersion->pIniDriver;
                         pIniDriver;
                         pIniDriver = pIniDriver->pNext)
                    {
                        //
                        // Omit drivers that are currently in a pending deletion
                        // state.
                        //
                        if (!(pIniDriver->dwDriverFlags & PRINTER_DRIVER_PENDING_DELETION))
                        {
                            cbNeeded += GetDriverInfoSize(pIniDriver,
                                                          6,
                                                          pIniVersion,
                                                          pIniEnvironment,
                                                          pszRemote,
                                                          pIniSpooler);
                        }
                    }
                }
            }
        }
    }

    return cbNeeded;
}

/*++

Routine Name

    PackClusterPrinterDrivers

Routine Description:

    Helper function for SplEnumAllClusterPrinterDrivers. This function relies on
    its caller to validate the arguments. This function loops through all the
    drivers on all pIniSpooler and stores driver information in a buffer. There
    won't be duplicate drivers in the list. If 2 pIniSpooler have the same driver,
    then the oldest is enumerated.

Arguments:

    pszRemote   - NULL if the caller is local on the machine, a string otherwise
    pDriverBuf  - buffer to hold the strcutures
    cbBuf       - buffer size in bytes
    pcReturned  - number of structures returned

Return Value:

    Win32 error code

--*/
DWORD
PackClusterPrinterDrivers(
    LPWSTR          pszRemote,
    LPBYTE          pDriverBuf,
    DWORD           cbBuf,
    LPDWORD         pcReturned
    )
{
    PINIDRIVER      pIniDriver;
    PINIENVIRONMENT pIniEnvironment;
    PINIVERSION     pIniVersion;
    PINISPOOLER     pIniSpooler;
    DRIVER_INFO_6  *pListHead   = (DRIVER_INFO_6 *)pDriverBuf;
    LPBYTE          pEnd        = pDriverBuf + cbBuf;
    DWORD           dwError     = ERROR_SUCCESS;

    SplInSem();

    for (pIniSpooler = pLocalIniSpooler;
         pIniSpooler;
         pIniSpooler = pIniSpooler->pIniNextSpooler)
    {
        //
        // Either pIniSpooler is not a cluster, or it is a cluster and
        // it is not pending deletion or offline
        //
        if (!(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER) ||
              pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER &&
              !(pIniSpooler->SpoolerFlags & SPL_PENDING_DELETION ||
              pIniSpooler->SpoolerFlags & SPL_OFFLINE))
        {
            for (pIniEnvironment = pIniSpooler->pIniEnvironment;
                 pIniEnvironment;
                 pIniEnvironment = pIniEnvironment->pNext)
            {
                for (pIniVersion = pIniEnvironment->pIniVersion;
                     pIniVersion;
                     pIniVersion = pIniVersion->pNext)
                {
                    for (pIniDriver = pIniVersion->pIniDriver;
                         pIniDriver;
                         pIniDriver = pIniDriver->pNext)
                    {
                        //
                        // Make sure that we don't enumerate drivers that are pending deletion.
                        //
                        if (!(pIniDriver->dwDriverFlags & PRINTER_DRIVER_PENDING_DELETION))
                        {
                            DRIVER_INFO_6 *pDrv6 = NULL;

                            if (pDrv6 = FindDriverInList(pListHead,
                                                         *pcReturned,
                                                         pIniDriver->pName,
                                                         pIniEnvironment->pName,
                                                         pIniDriver->cVersion))

                            {
                                //
                                // The driver that we are currently enumerating is older than the
                                // driver that we have in the list. We need to update the driver
                                // time in the list. The list always has the oldest driver.
                                //
                                if (CompareFileTime(&pDrv6->ftDriverDate, &pIniDriver->ftDriverDate) > 0)
                                {
                                    pDrv6->ftDriverDate = pIniDriver->ftDriverDate;
                                }
                            }
                            else
                            {
                                //
                                // Add the driver to the driver list
                                //
                                if (pEnd = CopyIniDriverToDriverInfo(pIniEnvironment,
                                                                     pIniVersion,
                                                                     pIniDriver,
                                                                     6,
                                                                     pDriverBuf,
                                                                     pEnd,
                                                                     pszRemote,
                                                                     pIniSpooler))
                                {
                                    pDriverBuf += sizeof(DRIVER_INFO_6);

                                    (*pcReturned)++;
                                }
                                else
                                {
                                    //
                                    // Severe error occured
                                    //
                                    dwError = ERROR_INSUFFICIENT_BUFFER;

                                    goto CleanUp;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

CleanUp:

    return dwError;
}

/*++

Routine Name

    SplEnumAllClusterPrinterDrivers

Routine Description:

    Enumerates the driver on all the spoolers hosted by the spooler process.
    It does not enumerate duplicates. This function is a helper function
    for EnumPrinterDrivers, when the latter is called with "allcluster"
    environment. The only consumer for this is Windows Update. Windows
    update needs to update all the drivers on all the spoolers on a machine,
    and uses EnumPrinterDrivers with "allcluster" environment.

Arguments:

    pszRemote   - NULL if the caller is local on the machine, a string otherwise
    Level       - must be 6
    pDriverInfo - buffer to hold the strcutures
    cbBuf       - buffer size in bytes
    pcbNeeded   - pointer to receive the count of bytes needed
    pcReturned  - number of structures returned. Must be a valid pointer

Return Value:

    TRUE,  if getting the drivers was successful
    FALSE, otherwise. Use GetLastError for error code

--*/
BOOL
SplEnumAllClusterPrinterDrivers(
    LPWSTR  pszRemote,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned)
{
    DWORD  dwError = ERROR_INVALID_PARAMETER;

    if (pcbNeeded && pcReturned)
    {
        *pcReturned = 0;

        if (dwLevel == 6)
        {
            EnterSplSem();

            //
            // Calculate the bytes needed for our driver structures
            //
            *pcbNeeded = GetBufferSizeForPrinterDrivers(pszRemote);

            dwError = cbBuf < *pcbNeeded ? ERROR_INSUFFICIENT_BUFFER :
                                           PackClusterPrinterDrivers(pszRemote,
                                                                     pDriverInfo,
                                                                     cbBuf,
                                                                     pcReturned);

            LeaveSplSem();
        }
        else
        {
            dwError = ERROR_INVALID_LEVEL;
        }
    }

    SetLastError(dwError);

    return dwError == ERROR_SUCCESS;
}

BOOL
SplEnumPrinterDrivers(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    PINISPOOLER pIniSpooler
)
{
    PINIDRIVER  pIniDriver;
    PINIVERSION pIniVersion;
    BOOL        bAllDrivers;
    DWORD       cb, cbStruct;
    LPBYTE      pEnd;
    LPWSTR      lpRemote = NULL;
    PINIENVIRONMENT pIniEnvironment;

    DBGMSG( DBG_TRACE, ("EnumPrinterDrivers\n"));

    if ( pName && *pName ) {

        if ( !MyName( pName, pIniSpooler )) {

            return FALSE;

        } else {

            lpRemote = pName;
        }
    }


    if ( !ValidateObjectAccess( SPOOLER_OBJECT_SERVER,
                                SERVER_ACCESS_ENUMERATE,
                                NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    if (!_wcsicmp(pEnvironment, EPD_ALL_LOCAL_AND_CLUSTER))
    {
        return SplEnumAllClusterPrinterDrivers(lpRemote,
                                               Level,
                                               pDriverInfo,
                                               cbBuf,
                                               pcbNeeded,
                                               pcReturned);
    }

    switch (Level) {

    case 1:
        cbStruct = sizeof(DRIVER_INFO_1);
        break;

    case 2:
        cbStruct = sizeof(DRIVER_INFO_2);
        break;

    case 3:
        cbStruct = sizeof(DRIVER_INFO_3);
        break;

    case 4:
        cbStruct = sizeof(DRIVER_INFO_4);
        break;

    case 5:
        cbStruct = sizeof(DRIVER_INFO_5);
        break;

    case 6:
        cbStruct = sizeof(DRIVER_INFO_6);
        break;
    }

    *pcReturned=0;

    cb=0;

    bAllDrivers = !_wcsicmp(pEnvironment, L"All");

   EnterSplSem();

    if ( bAllDrivers )
        pIniEnvironment = pIniSpooler->pIniEnvironment;
    else
        pIniEnvironment = FindEnvironment( pEnvironment, pIniSpooler );

    if ( !pIniEnvironment ) {

       LeaveSplSem();
        SetLastError(ERROR_INVALID_ENVIRONMENT);
        return FALSE;
    }


    do {

        pIniVersion = pIniEnvironment->pIniVersion;

        while ( pIniVersion ) {

            pIniDriver = pIniVersion->pIniDriver;

            while ( pIniDriver ) {

                //
                // Don't consider drivers that are pending deletion for enumeration.
                //
                if (!(pIniDriver->dwDriverFlags & PRINTER_DRIVER_PENDING_DELETION))
                {
                    DBGMSG( DBG_TRACE, ("Driver found - %ws\n", pIniDriver->pName));

                    cb += GetDriverInfoSize( pIniDriver, Level, pIniVersion,
                                             pIniEnvironment, lpRemote, pIniSpooler );
                }

                pIniDriver = pIniDriver->pNext;
            }

            pIniVersion = pIniVersion->pNext;
        }

        if ( bAllDrivers )
            pIniEnvironment = pIniEnvironment->pNext;
        else
            break;
    } while ( pIniEnvironment );

    *pcbNeeded=cb;

    DBGMSG( DBG_TRACE, ("Required is %d and Available is %d\n", cb, cbBuf));

    if (cbBuf < cb) {

        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        LeaveSplSem();
        return FALSE;
    }


    DBGMSG( DBG_TRACE, ("Now copying contents into DRIVER_INFO structures\n"));

    if ( bAllDrivers )
        pIniEnvironment = pIniSpooler->pIniEnvironment;

    pEnd = pDriverInfo+cbBuf;

    do {

        pIniVersion = pIniEnvironment->pIniVersion;

        while ( pIniVersion ) {

            pIniDriver = pIniVersion->pIniDriver;

            while ( pIniDriver ) {

                //
                // Don't consider printer drivers that are pending deletion for
                // enumeration.
                //
                if (!(pIniDriver->dwDriverFlags & PRINTER_DRIVER_PENDING_DELETION))
                {

                    if (( pEnd = CopyIniDriverToDriverInfo( pIniEnvironment,
                                                            pIniVersion,
                                                            pIniDriver,
                                                            Level,
                                                            pDriverInfo,
                                                            pEnd,
                                                            lpRemote,
                                                            pIniSpooler )) == NULL){
                        LeaveSplSem();
                         return FALSE;
                    }

                    pDriverInfo += cbStruct;
                    (*pcReturned)++;
                }

                pIniDriver = pIniDriver->pNext;
            }

            pIniVersion = pIniVersion->pNext;
        }

        if ( bAllDrivers )
            pIniEnvironment = pIniEnvironment->pNext;
        else
            break;
    } while ( pIniEnvironment );

   LeaveSplSem();
    return TRUE;
}

DWORD
GetDriverInfoSize(
    PINIDRIVER  pIniDriver,
    DWORD       Level,
    PINIVERSION pIniVersion,
    PINIENVIRONMENT  pIniEnvironment,
    LPWSTR      lpRemote,
    PINISPOOLER pIniSpooler
)
{
    DWORD cbDir, cb=0, cchLen;
    WCHAR  string[INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1];
    LPWSTR pStr;
    DWORD  cFiles = 0;

    switch (Level) {

    case 1:
        cb=sizeof(DRIVER_INFO_1) + wcslen(pIniDriver->pName)*sizeof(WCHAR) +
                                   sizeof(WCHAR);
        break;

    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case DRIVER_INFO_VERSION_LEVEL:

        cbDir = GetDriverVersionDirectory( string, COUNTOF(string), pIniSpooler, pIniEnvironment,
                                           pIniVersion, pIniDriver, lpRemote) + 1;

        SPLASSERT(pIniDriver->pDriverFile);
        cb+=wcslen(pIniDriver->pDriverFile) + 1 + cbDir;

        SPLASSERT(pIniDriver->pDataFile);
        cb+=wcslen(pIniDriver->pDataFile) + 1 + cbDir;

        SPLASSERT(pIniDriver->pConfigFile);
        cb+=wcslen(pIniDriver->pConfigFile) + 1 + cbDir;

        cb += wcslen( pIniDriver->pName ) + 1 + wcslen( pIniEnvironment->pName ) + 1;

        if ((Level == 2) || (Level == 5)) {

            // For the strings in the struct
            cb *= sizeof(WCHAR);
            if (Level == 2) {
                cb += sizeof( DRIVER_INFO_2 );
            } else { // Level 5
                cb += sizeof( DRIVER_INFO_5 );
            }

        } else {    // level 3 or 4 or 6

            if ( pIniDriver->pHelpFile && *pIniDriver->pHelpFile )
                cb += wcslen(pIniDriver->pHelpFile) + cbDir + 1;

            if ( pIniDriver->pMonitorName && *pIniDriver->pMonitorName )
                cb += wcslen(pIniDriver->pMonitorName) + 1;

            if ( pIniDriver->pDefaultDataType && *pIniDriver->pDefaultDataType)
                cb += wcslen(pIniDriver->pDefaultDataType) + 1;

            if ( (pStr=pIniDriver->pDependentFiles) && *pStr ) {

                //
                // There are 4 distinctive files in the file set
                // (driver, data , config, help).
                //
                cFiles = 4;
                while ( *pStr ) {
                    cchLen = wcslen(pStr) + 1;
                    cb    += cchLen + cbDir;
                    pStr  += cchLen;
                    cFiles++;
                }
                ++cb; //for final \0
            }

            if ( (Level == 4 || Level == 6 || Level == DRIVER_INFO_VERSION_LEVEL) &&
                 (pStr = pIniDriver->pszzPreviousNames) &&
                 *pStr) {

                while ( *pStr ) {

                    cchLen  = wcslen(pStr) + 1;
                    cb     += cchLen;
                    pStr   += cchLen;
                }

                ++cb; //for final \0
            }

            if (Level==6 || Level == DRIVER_INFO_VERSION_LEVEL) {

                if (pIniDriver->pszMfgName && *pIniDriver->pszMfgName)
                    cb += wcslen(pIniDriver->pszMfgName) + 1;

                if (pIniDriver->pszOEMUrl && *pIniDriver->pszOEMUrl)
                   cb += wcslen(pIniDriver->pszOEMUrl) + 1;

                if (pIniDriver->pszHardwareID && *pIniDriver->pszHardwareID)
                   cb += wcslen(pIniDriver->pszHardwareID) + 1;

                if (pIniDriver->pszProvider && *pIniDriver->pszProvider)
                   cb += wcslen(pIniDriver->pszProvider) + 1;

            }

            cb *= sizeof(WCHAR);

            switch (Level) {
            case 3:
                cb += sizeof( DRIVER_INFO_3 );
                break;
            case 4:
                cb += sizeof( DRIVER_INFO_4 );
                break;
            case 6:
                cb += sizeof( DRIVER_INFO_6 );
                break;
            case DRIVER_INFO_VERSION_LEVEL:
                cb += sizeof( DRIVER_INFO_VERSION ) +
                      cFiles * sizeof(DRIVER_FILE_INFO) +
                      sizeof(ULONG_PTR);
                break;
            }
        }

        break;
    default:
        DBGMSG(DBG_ERROR,
                ("GetDriverInfoSize: level can not be %d", Level) );
        cb = 0;
        break;
    }

    return cb;
}



LPBYTE
CopyMultiSzFieldToDriverInfo(
    LPWSTR  pszz,
    LPBYTE  pEnd,
    LPWSTR  pszPrefix,
    DWORD   cchPrefix
    )
/*++

Routine Description:
    Copies a multi sz field from IniDriver to DriverInfo structure.
    If a pszPrefix is specified that is appended before each string.

Arguments:
    pszz        : entry in pIniDriver (this could be dependent files
                     ex. PSCRIPT.DLL\0QMS810.PPD\0PSCRPTUI.DLL\0PSPCRIPTUI.HLP\0PSTEST.TXT\0\0
                    or previous names
                     ex. OldName1\0OldName2\0\0 )
    pEnd        : end of buffer to which it needs to be copied
    pszPrefix   : Prefix to copy when copying to user buffer. For dependent
                  files this will be driver directory path
    cchPrefix   : length of prefix

Return Value:
    after copying where is the buffer end to copy next field

History:
    Written by MuhuntS (Muhunthan Sivapragasam)June 95

--*/
{
    LPWSTR  pStr1, pStr2;
    DWORD   cchSize, cchLen;

    if ( !pszz || !*pszz )
        return pEnd;

    pStr1   = pszz;
    cchSize = 0;

    while ( *pStr1 ) {

        cchLen = wcslen(pStr1) + 1;
        cchSize += cchPrefix + cchLen;
        pStr1 += cchLen;
    }

    // For the last \0
    ++cchSize;

    pEnd -= cchSize * sizeof(WCHAR);

    pStr1 = pszz;
    pStr2 = (LPWSTR) pEnd;

    while ( *pStr1 ) {

        if ( pszPrefix ) {

            wcsncpy(pStr2, pszPrefix, cchPrefix);
            pStr2 += cchPrefix;
        }
        wcscpy(pStr2, pStr1);
        cchLen  = wcslen(pStr1) + 1;
        pStr2  += cchLen;
        pStr1  += cchLen;
    }

    *pStr2 = '\0';

    return pEnd;

}


LPBYTE
CopyIniDriverToDriverInfo(
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER pIniDriver,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    LPBYTE  pEnd,
    LPWSTR  lpRemote,
    PINISPOOLER pIniSpooler
)
/*++
Routine Description:
    This routine copies data from the IniDriver structure to
    an DRIVER_INFO_X structure.

Arguments:

    pIniEnvironment     pointer to the INIENVIRONMENT structure

    pIniVersion         pointer to the INIVERSION structure.

    pIniDriver          pointer to the INIDRIVER structure.

    Level               Level of the DRIVER_INFO_X structure

    pDriverInfo         Buffer of the DRIVER_INFO_X structure

    pEnd                pointer to the end of the  pDriverInfo

    lpRemote              flag which determines whether Remote or Local

    pIniSpooler         pointer to the INISPOOLER structure
Return Value:

    if the call is successful, the return value is the updated pEnd value.

    if the call is unsuccessful, the return value is NULL.


Note:

--*/
{
    LPWSTR *pSourceStrings, *SourceStrings;
    WCHAR  string[INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1];
    DWORD i, j;
    DWORD *pOffsets;
    LPWSTR pTempDriverPath=NULL;
    LPWSTR pTempConfigFile=NULL;
    LPWSTR pTempDataFile=NULL;
    LPWSTR pTempHelpFile=NULL;

    switch (Level) {

    case DRIVER_INFO_VERSION_LEVEL:

        return CopyIniDriverToDriverInfoVersion(pIniEnvironment,
                                                pIniVersion,
                                                pIniDriver,
                                                pDriverInfo,
                                                pEnd,
                                                lpRemote,
                                                pIniSpooler);
        break;

    case 1:
        pOffsets = DriverInfo1Strings;
        break;

    case 2:
    case 5:
        pOffsets = DriverInfo2Strings;
        break;

    case 3:
    case 4:
        pOffsets = DriverInfo3Strings;
        break;
    case 6:
        pOffsets = DriverInfo6Strings;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return NULL;
    }

    for (j=0; pOffsets[j] != -1; j++) {
    }

    SourceStrings = pSourceStrings = AllocSplMem(j * sizeof(LPWSTR));

    if ( pSourceStrings ) {

        switch (Level) {

        case 1:
            *pSourceStrings++=pIniDriver->pName;

            pEnd = PackStrings(SourceStrings, pDriverInfo, pOffsets, pEnd);
            break;

        case 2:
        case 3:
        case 4:
        case 5:
        case 6:

            i = GetDriverVersionDirectory(string, (DWORD)(COUNTOF(string) - wcslen(pIniDriver->pDriverFile) - 1), pIniSpooler, pIniEnvironment,
                                          pIniVersion, pIniDriver, lpRemote);
            if(!i) {
                pEnd = NULL;
                goto Fail;
            }
            string[i++] = L'\\';

            *pSourceStrings++ = pIniDriver->pName;

            *pSourceStrings++ = pIniEnvironment->pName;

            wcscpy( &string[i], pIniDriver->pDriverFile );

            if (( pTempDriverPath = AllocSplStr(string) ) == NULL){

                DBGMSG( DBG_WARNING, ("CopyIniDriverToDriverInfo: AlloSplStr failed\n"));
                pEnd = NULL;
                goto Fail;
            }

            *pSourceStrings++ = pTempDriverPath;


            wcscpy( &string[i], pIniDriver->pDataFile );

            if (( pTempDataFile = AllocSplStr(string) ) == NULL){

                DBGMSG( DBG_WARNING, ("CopyIniDriverToDriverInfo: AlloSplStr failed\n"));
                pEnd = NULL;
                goto Fail;
            }

            *pSourceStrings++ = pTempDataFile;


            if ( pIniDriver->pConfigFile && *pIniDriver->pConfigFile ) {

                wcscpy( &string[i], pIniDriver->pConfigFile );

                if (( pTempConfigFile = AllocSplStr(string) ) == NULL) {

                    DBGMSG( DBG_WARNING, ("CopyIniDriverToDriverInfo: AlloSplStr failed\n"));
                    pEnd = NULL;
                    goto Fail;
                }

                *pSourceStrings++ = pTempConfigFile;

            } else {

                *pSourceStrings++=0;
            }

            if ( Level == 3 || Level == 4 || Level == 6 ) {

                if ( pIniDriver->pHelpFile && *pIniDriver->pHelpFile ) {

                    wcscpy( &string[i], pIniDriver->pHelpFile );

                    if (( pTempHelpFile = AllocSplStr(string) ) == NULL) {
                        DBGMSG(DBG_WARNING,
                               ("CopyIniDriverToDriverInfo: AlloSplStr failed\n"));
                        pEnd = NULL;
                        goto Fail;
                    }
                    *pSourceStrings++ = pTempHelpFile;
                } else {

                    *pSourceStrings++=0;
                }

                *pSourceStrings++ = pIniDriver->pMonitorName;

                *pSourceStrings++ = pIniDriver->pDefaultDataType;

            }


            if (Level == 6) {

                ((PDRIVER_INFO_6)pDriverInfo)->ftDriverDate = pIniDriver->ftDriverDate;

                ((PDRIVER_INFO_6)pDriverInfo)->dwlDriverVersion = pIniDriver->dwlDriverVersion;

                *pSourceStrings++ = pIniDriver->pszMfgName;

                *pSourceStrings++ = pIniDriver->pszOEMUrl;

                *pSourceStrings++ = pIniDriver->pszHardwareID;

                *pSourceStrings++ = pIniDriver->pszProvider;
            }

            pEnd = PackStrings( SourceStrings, pDriverInfo, pOffsets, pEnd );

            if ( Level == 3 || Level == 4 || Level == 6 ) {

                //
                // Dependent files need to be copied till \0\0
                // so need to do it outside PackStirngs
                //
                if ( pIniDriver->cchDependentFiles ) {

                    pEnd = CopyMultiSzFieldToDriverInfo(
                                    pIniDriver->pDependentFiles,
                                    pEnd,
                                    string,
                                    i);
                   ((PDRIVER_INFO_3)pDriverInfo)->pDependentFiles = (LPWSTR) pEnd;
                }
                else {
                    ((PDRIVER_INFO_3)pDriverInfo)->pDependentFiles  = NULL;
                }

                //
                // pszzPreviousNames is multi-sz too
                //
                if ( Level == 4 || Level == 6) {

                    if ( pIniDriver->cchPreviousNames ) {

                        pEnd = CopyMultiSzFieldToDriverInfo(
                                        pIniDriver->pszzPreviousNames,
                                        pEnd,
                                        NULL,
                                        0);
                        ((PDRIVER_INFO_4)pDriverInfo)->pszzPreviousNames = (LPWSTR) pEnd;
                    } else {

                        ((PDRIVER_INFO_4)pDriverInfo)->pszzPreviousNames = NULL;
                    }

                }

                ((PDRIVER_INFO_3)pDriverInfo)->cVersion = pIniDriver->cVersion;
            } else {
                //Level == 2 or Level = 5
                if (Level == 2) {

                    ((PDRIVER_INFO_2)pDriverInfo)->cVersion = pIniDriver->cVersion;

                } else {

                    PDRIVER_INFO_5 pDriver5;

                    pDriver5 = (PDRIVER_INFO_5) pDriverInfo;
                    pDriver5->cVersion = pIniDriver->cVersion;

                    if (!pIniDriver->dwDriverAttributes) {

                        // Driver Attributes has not been initialized as yet; do it now
                        CheckDriverAttributes(pIniSpooler, pIniEnvironment,
                                              pIniVersion, pIniDriver);
                    }

                    pDriver5->dwDriverAttributes = pIniDriver->dwDriverAttributes;
                    pDriver5->dwConfigVersion = GetDriverFileVersion(pIniVersion,
                                                                     pIniDriver->pConfigFile);
                    pDriver5->dwDriverVersion = GetDriverFileVersion(pIniVersion,
                                                                     pIniDriver->pDriverFile);
                }
            }

            break;

        }

Fail:

        FreeSplStr( pTempDriverPath );
        FreeSplStr( pTempConfigFile );
        FreeSplStr( pTempDataFile );
        FreeSplStr( pTempHelpFile );
        FreeSplMem( SourceStrings );

    } else {

        DBGMSG( DBG_WARNING, ("Failed to alloc driver source strings.\n"));
        pEnd = NULL;
    }

    return pEnd;
}

LPBYTE
CopyIniDriverToDriverInfoVersion(
    IN  PINIENVIRONMENT pIniEnvironment,
    IN  PINIVERSION     pIniVersion,
    IN  PINIDRIVER      pIniDriver,
    IN  LPBYTE          pDriverInfo,
    IN  LPBYTE          pEnd,
    IN  LPWSTR          lpRemote,
    IN  PINISPOOLER     pIniSpooler
)
/*++

Routine Name:

    CopyIniDriverToDriverInfoVersion

Routine Description:

    This routine copy data from pIniDriver to the pDriverInfo as a DRIVER_INFO_VERSION

Arguments:

    pIniEnvironment     pointer to the INIENVIRONMENT structure
    pIniVersion         pointer to the INIVERSION structure.
    pIniDriver          pointer to the INIDRIVER structure.
    pDriverInfo         Buffer big enough to fit a DRIVER_INFO_VERSION and
                        the strings that needs to be packed
    pEnd                pointer to the end of the  pDriverInfo
    lpRemote            flag which determines whether Remote or Local
    pIniSpooler         pointer to the INISPOOLER structure

Return Value:

    Returns the pointer to the "end" of pDriverInfo if success.
    NULL if it failes.

--*/
{
    LPWSTR *pSourceStrings = NULL;
    LPWSTR *SourceStrings = NULL;
    DRIVER_INFO_VERSION *pDriverVersion;
    WCHAR  szDriverVersionDir[INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1];
    DWORD  cStrings;
    LPWSTR pTempDllFile = NULL;

    pDriverVersion = (DRIVER_INFO_VERSION *)pDriverInfo;

    if (!GetDriverVersionDirectory(szDriverVersionDir,
                                  COUNTOF(szDriverVersionDir),
                                  pIniSpooler,
                                  pIniEnvironment,
                                  pIniVersion,
                                  pIniDriver,
                                  lpRemote))
    {
        pEnd = NULL;
    }
    else
    {
        for (cStrings=0; DriverInfoVersionStrings[cStrings] != 0xFFFFFFFF; cStrings++);

        if (!(pSourceStrings = SourceStrings = AllocSplMem(cStrings * sizeof(LPWSTR))))
        {
            DBGMSG( DBG_WARNING, ("Failed to alloc driver source strings.\n"));
            pEnd = NULL;
        }
        else
        {
            *pSourceStrings++ = pIniDriver->pName;
            *pSourceStrings++ = pIniEnvironment->pName;
            *pSourceStrings++ = pIniDriver->pMonitorName;
            *pSourceStrings++ = pIniDriver->pDefaultDataType;
            *pSourceStrings++ = pIniDriver->pszMfgName;
            *pSourceStrings++ = pIniDriver->pszOEMUrl;
            *pSourceStrings++ = pIniDriver->pszHardwareID;
            *pSourceStrings++ = pIniDriver->pszProvider;
            //                           
            // Pack the strings at the end of pDriverInfo
            //
            pEnd = PackStrings( SourceStrings, pDriverInfo, DriverInfoVersionStrings, pEnd );

            if (pEnd)
            {
                if (pIniDriver->cchPreviousNames == 0)
                {
                    pDriverVersion->pszzPreviousNames = NULL;
                }
                else
                {
                    pEnd = CopyMultiSzFieldToDriverInfo(pIniDriver->pszzPreviousNames,
                                                        pEnd,
                                                        NULL,
                                                        0);
                    if (pEnd)
                    {
                        pDriverVersion->pszzPreviousNames = (LPWSTR) pEnd;
                    }
                }

                if (pEnd)
                {
                    pDriverVersion->cVersion            = pIniDriver->cVersion;
                    pDriverVersion->ftDriverDate        = pIniDriver->ftDriverDate;
                    pDriverVersion->dwlDriverVersion    = pIniDriver->dwlDriverVersion;
                    pDriverVersion->dwFileCount         = 3;

                    if (pIniDriver->pHelpFile && *pIniDriver->pHelpFile)
                    {
                        pDriverVersion->dwFileCount++;
                    }

                    if (pIniDriver->cchDependentFiles)
                    {
                        for (pTempDllFile = pIniDriver->pDependentFiles;
                             *pTempDllFile;
                             pTempDllFile += wcslen(pTempDllFile) + 1,
                             pDriverVersion->dwFileCount++ );
                    }

                    //
                    // Pack in the file names and versions in pDriverVersion->pFileInfo.
                    //
                    pEnd = CopyIniDriverFilesToDriverInfo(pDriverVersion,
                                                          pIniVersion,
                                                          pIniDriver,
                                                          szDriverVersionDir,
                                                          pEnd);

                    //
                    // When we are done, the end shoud not be less than the 
                    // start of the buffer plus the driver info version buffer 
                    // size. If these have overlapped, we are in serious trouble.
                    // 
                    SPLASSERT(pEnd >= pDriverInfo + sizeof(DRIVER_INFO_VERSION));
                }
            }
        }
    }

    FreeSplMem(SourceStrings);

    return pEnd;
}


LPBYTE
CopyIniDriverFilesToDriverInfo(
    IN  LPDRIVER_INFO_VERSION   pDriverVersion,
    IN  PINIVERSION             pIniVersion,
    IN  PINIDRIVER              pIniDriver,
    IN  LPCWSTR                 pszDriverVersionDir,
    IN  LPBYTE                  pEnd
)
/*++

Routine Name:

    CopyIniDriverFilesToDriverInfo

Routine Description:

    This routine copy data from pIniDriver to the pDriverInfo->pFileInfo.
    The number of files is already filled in pDriverInfo->dwFileCount

Arguments:

    pDriverVersion      pointer to a DRIVER_INFO_VERSION structure
    pIniVersion         pointer to the INIVERSION structure.
    pIniDriver          pointer to the INIDRIVER structure.
    pszDriverVersionDir string containing the driver version directory
    pEnd                pointer to the end of the  pDriverInfo

Return Value:

    Returns the pointer to the "end" of pDriverInfo if success.
    NULL if it failes.

--*/
{
    DWORD   dwIndex = 0;
    LPWSTR  pTempDllFile = NULL;
    DWORD dwFileSetCount = pDriverVersion->dwFileCount;

    //
    // Reserve space for DRIVER_FILE_INFO array
    //
    pEnd = (LPBYTE)ALIGN_DOWN(pEnd, ULONG_PTR);
    pEnd -= dwFileSetCount * sizeof(DRIVER_FILE_INFO);

    pDriverVersion->pFileInfo = (DRIVER_FILE_INFO*)pEnd;
    //
    // For each file call FillDriverInfo and fill in the entry
    // in the array of DRIVER_FILE_INFO.
    //
    if (dwIndex >= pDriverVersion->dwFileCount ||
        !(pEnd = FillDriverInfo(pDriverVersion,
                                dwIndex++,
                                pIniVersion,
                                pszDriverVersionDir,
                                pIniDriver->pDriverFile,
                                DRIVER_FILE,
                                pEnd)))
    {
        goto End;
    }

    if (dwIndex >= dwFileSetCount ||
        !(pEnd = FillDriverInfo(pDriverVersion,
                                dwIndex++,
                                pIniVersion,
                                pszDriverVersionDir,
                                pIniDriver->pConfigFile,
                                CONFIG_FILE,
                                pEnd)))
    {
        goto End;
    }

    if (dwIndex >= dwFileSetCount ||
        !(pEnd = FillDriverInfo(pDriverVersion,
                                dwIndex++,
                                pIniVersion,
                                pszDriverVersionDir,
                                pIniDriver->pDataFile,
                                DATA_FILE,
                                pEnd)))
    {
        goto End;
    }

    if (pIniDriver->pHelpFile && *pIniDriver->pHelpFile)
    {
        if (dwIndex >= dwFileSetCount ||
            !(pEnd = FillDriverInfo(pDriverVersion,
                                    dwIndex++,
                                    pIniVersion,
                                    pszDriverVersionDir,
                                    pIniDriver->pHelpFile,
                                    HELP_FILE,
                                    pEnd)))
        {
            goto End;
        }
    }

    if (pIniDriver->cchDependentFiles)
    {
        for (pTempDllFile = pIniDriver->pDependentFiles;
             *pTempDllFile;
             pTempDllFile += wcslen(pTempDllFile) + 1)
             {
                 if (dwIndex >= dwFileSetCount ||
                     !(pEnd = FillDriverInfo(pDriverVersion,
                                             dwIndex++,
                                             pIniVersion,
                                             pszDriverVersionDir,
                                             pTempDllFile,
                                             DEPENDENT_FILE,
                                             pEnd)))
                 {
                        goto End;
                 }

             }
    }

End:

    return pEnd;
}


LPBYTE
FillDriverInfo (
    LPDRIVER_INFO_VERSION   pDriverVersion,
    DWORD                   Index,
    PINIVERSION             pIniVersion,
    LPCWSTR                 pszPrefix,
    LPCWSTR                 pszFileName,
    DRIVER_FILE_TYPE        FileType,
    LPBYTE                  pEnd
    )
/*++

Routine Name:

    FillDriverInfo

Routine Description:

    This routine copy a file name and version into the pDriverInfo->pFileInfo entry

Arguments:

    pDriverVersion      pointer to a DRIVER_INFO_VERSION structure
    Index               index in the pDriverInfo->pFileInfo array of
    pIniVersion         pointer to the INIVERSION structure.
    pszPrefix           prefix string for file name.
                        This should be the driver version directory
    pszFileName         file name, no path
    FileType            file type: Driver, Config, Data, etc
    pEnd                pointer to the end of the  pDriverInfo

Return Value:

    Returns the pointer to the "end" of pDriverInfo if success.
    NULL if it failes.

--*/
{
    LPWSTR  pszTempFilePath = NULL;
    LPBYTE  pszNewEnd = NULL;
    DWORD   dwRet = ERROR_SUCCESS;

    if ((dwRet = StrCatAlloc(&pszTempFilePath,
                            pszPrefix,
                            L"\\",
                            pszFileName,
                            NULL)) != ERROR_SUCCESS)
    {
        SetLastError(dwRet);
        pszNewEnd = NULL;

    }
    else
    {
        //
        // Packs the file name into pDriverInfo
        //
        pszNewEnd = PackStringToEOB(pszTempFilePath, pEnd);
        //
        // Fills in the offset in pDriverVersion where the string was packed.
        // We cannot store pointers because we don't marshall anything else
        // but the structure at the begining of the buffer. We could marshall
        // the array of DRIVER_FILE_INFO but there is no way to update the buffer
        // size between 32 and 64 bits in Win32spl.dll ( UpdateBufferSize ) since we
        // don't know how many files are by that time.
        //
        pDriverVersion->pFileInfo[Index].FileNameOffset = MakeOffset((LPVOID)pszNewEnd, (LPVOID)pDriverVersion);

        pDriverVersion->pFileInfo[Index].FileVersion = 0;

        pDriverVersion->pFileInfo[Index].FileType = FileType;

        if (!GetDriverFileCachedVersion(pIniVersion,
                                        (LPWSTR)pszNewEnd,
                                        &pDriverVersion->pFileInfo[Index].FileVersion))
        {
            pszNewEnd = NULL;
        }


    }

    FreeSplMem(pszTempFilePath);

    return pszNewEnd;
}

BOOL
WriteDriverIni(
    PINIDRIVER      pIniDriver,
    PINIVERSION     pIniVersion,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
)
{
    HKEY    hEnvironmentsRootKey, hEnvironmentKey, hDriversKey, hDriverKey;
    HKEY    hVersionKey;
    HANDLE  hToken;
    DWORD   dwLastError=ERROR_SUCCESS;
    PINIDRIVER  pUpdateIniDriver;

    hToken = RevertToPrinterSelf();

    if ((dwLastError = SplRegCreateKey(pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ? pIniSpooler->hckRoot : HKEY_LOCAL_MACHINE,
                                       pIniSpooler->pszRegistryEnvironments,
                                       0,
                                       KEY_WRITE,
                                       NULL,
                                       &hEnvironmentsRootKey,
                                       NULL,
                                       pIniSpooler)) == ERROR_SUCCESS) {
        DBGMSG(DBG_TRACE, ("WriteDriverIni Created key %ws\n", pIniSpooler->pszRegistryEnvironments));

        if ((dwLastError = SplRegCreateKey(hEnvironmentsRootKey,
                                           pIniEnvironment->pName,
                                           0,
                                           KEY_WRITE,
                                           NULL,
                                           &hEnvironmentKey,
                                           NULL,
                                           pIniSpooler)) == ERROR_SUCCESS) {

            DBGMSG(DBG_TRACE, ("WriteDriverIni Created key %ws\n", pIniEnvironment->pName));

            if ((dwLastError = SplRegCreateKey(hEnvironmentKey,
                                               szDriversKey,
                                               0,
                                               KEY_WRITE,
                                               NULL,
                                               &hDriversKey,
                                               NULL,
                                               pIniSpooler)) == ERROR_SUCCESS) {
                DBGMSG(DBG_TRACE, ("WriteDriverIni Created key %ws\n", szDriversKey));
                DBGMSG(DBG_TRACE, ("WriteDriverIni Trying to create version key %ws\n", pIniVersion->pName));
                if ((dwLastError = SplRegCreateKey(hDriversKey,
                                                   pIniVersion->pName,
                                                   0,
                                                   KEY_WRITE,
                                                   NULL,
                                                   &hVersionKey,
                                                   NULL,
                                                   pIniSpooler)) == ERROR_SUCCESS) {

                    DBGMSG(DBG_TRACE, ("WriteDriverIni Created key %ws\n", pIniVersion->pName));
                    if ((dwLastError = SplRegCreateKey(hVersionKey,
                                                       pIniDriver->pName,
                                                       0,
                                                       KEY_WRITE,
                                                       NULL,
                                                       &hDriverKey,
                                                       NULL,
                                                       pIniSpooler)) == ERROR_SUCCESS) {
                        DBGMSG(DBG_TRACE,(" WriteDriverIni Created key %ws\n", pIniDriver->pName));

                        RegSetString(hDriverKey, szConfigurationKey, pIniDriver->pConfigFile, &dwLastError, pIniSpooler);

                        RegSetString(hDriverKey, szDataFileKey, pIniDriver->pDataFile, &dwLastError, pIniSpooler);

                        RegSetString(hDriverKey, szDriverFile,  pIniDriver->pDriverFile, &dwLastError, pIniSpooler);

                        RegSetString(hDriverKey, szHelpFile, pIniDriver->pHelpFile, &dwLastError, pIniSpooler);

                        RegSetString(hDriverKey, szMonitor, pIniDriver->pMonitorName, &dwLastError, pIniSpooler);

                        RegSetString(hDriverKey, szDatatype, pIniDriver->pDefaultDataType, &dwLastError, pIniSpooler);

                        RegSetMultiString(hDriverKey, szDependentFiles, pIniDriver->pDependentFiles, pIniDriver->cchDependentFiles, &dwLastError, pIniSpooler);

                        RegSetMultiString(hDriverKey, szPreviousNames, pIniDriver->pszzPreviousNames, pIniDriver->cchPreviousNames, &dwLastError, pIniSpooler);

                        RegSetDWord(hDriverKey, szDriverVersion, pIniDriver->cVersion, &dwLastError, pIniSpooler);

                        RegSetDWord(hDriverKey, szTempDir, pIniDriver->dwTempDir, &dwLastError, pIniSpooler);

                        RegSetDWord(hDriverKey, szAttributes, pIniDriver->dwDriverAttributes, &dwLastError, pIniSpooler);

                        RegSetString(hDriverKey, szMfgName, pIniDriver->pszMfgName, &dwLastError, pIniSpooler);

                        RegSetString(hDriverKey, szOEMUrl, pIniDriver->pszOEMUrl, &dwLastError, pIniSpooler);

                        RegSetString(hDriverKey, szHardwareID, pIniDriver->pszHardwareID, &dwLastError, pIniSpooler);

                        RegSetString(hDriverKey, szProvider, pIniDriver->pszProvider, &dwLastError, pIniSpooler);

                        RegSetBinaryData(hDriverKey,
                                         szDriverDate,
                                         (LPBYTE)&pIniDriver->ftDriverDate,
                                         sizeof(FILETIME),
                                         &dwLastError,
                                         pIniSpooler);

                        RegSetBinaryData(hDriverKey,
                                         szLongVersion,
                                         (LPBYTE)&pIniDriver->dwlDriverVersion,
                                         sizeof(DWORDLONG),
                                         &dwLastError,
                                         pIniSpooler);

                        SplRegCloseKey(hDriverKey, pIniSpooler);

                        if(dwLastError != ERROR_SUCCESS) {

                            SplRegDeleteKey(hVersionKey, pIniDriver->pName, pIniSpooler);
                        }
                    }

                    SplRegCloseKey(hVersionKey, pIniSpooler);
                }

                SplRegCloseKey(hDriversKey, pIniSpooler);
            }

            SplRegCloseKey(hEnvironmentKey, pIniSpooler);
        }

        SplRegCloseKey(hEnvironmentsRootKey, pIniSpooler);
    }

    ImpersonatePrinterClient( hToken );

    if ( dwLastError != ERROR_SUCCESS ) {

        SetLastError( dwLastError );
        return FALSE;

    } else {
        return TRUE;
    }
}


BOOL
DeleteDriverIni(
    PINIDRIVER      pIniDriver,
    PINIVERSION     pIniVersion,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
)
{
    HKEY    hEnvironmentsRootKey, hEnvironmentKey, hDriversKey;
    HANDLE  hToken;
    HKEY    hVersionKey;
    DWORD   LastError= 0;
    DWORD   dwRet = 0;

    hToken = RevertToPrinterSelf();

    if ((dwRet = SplRegCreateKey(pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ? pIniSpooler->hckRoot : HKEY_LOCAL_MACHINE,
                                 pIniSpooler->pszRegistryEnvironments,
                                 0,
                                 KEY_WRITE,
                                 NULL,
                                 &hEnvironmentsRootKey,
                                 NULL,
                                 pIniSpooler) == ERROR_SUCCESS)) {
        if ((dwRet = SplRegOpenKey(hEnvironmentsRootKey,
                                   pIniEnvironment->pName,
                                   KEY_WRITE,
                                   &hEnvironmentKey,
                                   pIniSpooler)) == ERROR_SUCCESS) {

            if ((dwRet = SplRegOpenKey(hEnvironmentKey,
                                       szDriversKey,
                                       KEY_WRITE,
                                       &hDriversKey,
                                       pIniSpooler)) == ERROR_SUCCESS) {
                if ((dwRet = SplRegOpenKey(hDriversKey,
                                           pIniVersion->pName,
                                           KEY_WRITE,
                                           &hVersionKey,
                                           pIniSpooler)) == ERROR_SUCCESS) {

                    if ((dwRet = SplRegDeleteKey(hVersionKey, pIniDriver->pName, pIniSpooler)) != ERROR_SUCCESS) {
                        LastError = dwRet;
                        DBGMSG( DBG_WARNING, ("Error:RegDeleteKey failed with %d\n", dwRet));
                    }

                    SplRegCloseKey(hVersionKey, pIniSpooler);
                } else {
                    LastError = dwRet;
                    DBGMSG( DBG_WARNING, ("Error: RegOpenKeyEx <version> failed with %d\n", dwRet));
                }
                SplRegCloseKey(hDriversKey, pIniSpooler);
            } else {
                LastError = dwRet;
                DBGMSG( DBG_WARNING, ("Error:RegOpenKeyEx <Drivers>failed with %d\n", dwRet));
            }
            SplRegCloseKey(hEnvironmentKey, pIniSpooler);
        } else {
            LastError = dwRet;
            DBGMSG( DBG_WARNING, ("Error:RegOpenKeyEx <Environment> failed with %d\n", dwRet));
        }
        SplRegCloseKey(hEnvironmentsRootKey, pIniSpooler);
    } else {
        LastError = dwRet;
        DBGMSG( DBG_WARNING, ("Error:RegCreateKeyEx <Environments> failed with %d\n", dwRet));
    }

    ImpersonatePrinterClient( hToken );

    if (LastError) {
        SetLastError(LastError);
        return FALSE;
    }

    return TRUE;
}

VOID
SetOldDateOnSingleDriverFile(
    LPWSTR  pFileName
    )
/*++
Routine Description:

    This routine changes the Date / Time of the file.

    The reason for doing this is that, when AddPrinterDriver is called we move the Driver
    file from the ScratchDiretory to a \version directory.    We then want to mark the original
    file for deletion.    However Integraphs install program ( an possibly others ) rely on the
    file still being located in the scratch directory.   By setting the files date / time
    back to an earlier date / time we will not attemp to copy this file again to the \version
    directory since it will be an older date.

    It is then marked for deletion at reboot.

Arguments:

    pFileName           Just file Name ( not fully qualified )

    pDir                Directory where file to be deleted is located

Return Value:

    None

Note:

--*/
{
    FILETIME  WriteFileTime;
    HANDLE hFile;

    if ( pFileName ) {

        DBGMSG( DBG_TRACE,("Attempting to delete file %ws\n", pFileName));

        hFile = CreateFile(pFileName, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if ( hFile != INVALID_HANDLE_VALUE ) {

            DBGMSG( DBG_TRACE, ("CreateFile %ws succeeded\n", pFileName));

            DosDateTimeToFileTime(0xc3, 0x3000, &WriteFileTime);
            SetFileTime(hFile, &WriteFileTime, &WriteFileTime, &WriteFileTime);
            CloseHandle(hFile);

        } else {
            DBGMSG( DBG_WARNING, ("CreateFile %ws failed with %d\n", pFileName, GetLastError()));
        }
    }
}


VOID
SetOldDateOnDriverFilesInScratchDirectory(
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               FileCount,
    PINISPOOLER         pIniSpooler
    )
{
    HANDLE  hToken;

    SPLASSERT(FileCount);
    //  Run as SYSTEM so we don't run into problems
    //  Changing the file time or date

    hToken = RevertToPrinterSelf();

    do {
        SetOldDateOnSingleDriverFile(pInternalDriverFiles[--FileCount].pFileName);
    } while (FileCount);

    ImpersonatePrinterClient(hToken);

}



PINIVERSION
FindVersionEntry(
    PINIENVIRONMENT pIniEnvironment,
    DWORD dwVersion
    )
{
    PINIVERSION pIniVersion;

    pIniVersion = pIniEnvironment->pIniVersion;

    while (pIniVersion) {
        if (pIniVersion->cMajorVersion == dwVersion) {
            return pIniVersion;
        } else {
            pIniVersion = pIniVersion->pNext;
        }
    }
    return NULL;
}



PINIVERSION
CreateVersionEntry(
    PINIENVIRONMENT pIniEnvironment,
    DWORD dwVersion,
    PINISPOOLER pIniSpooler
    )
{
    PINIVERSION pIniVersion = NULL;
    WCHAR szTempBuffer[MAX_PATH];
    BOOL    bSuccess = FALSE;

try {

    pIniVersion = AllocSplMem(sizeof(INIVERSION));
    if ( pIniVersion == NULL ) {
        leave;
    }

    pIniVersion->signature = IV_SIGNATURE;

    wsprintf( szTempBuffer, L"Version-%d", dwVersion );
    pIniVersion->pName = AllocSplStr( szTempBuffer );

    if ( pIniVersion->pName == NULL ) {
        leave;
    }

    wsprintf( szTempBuffer, L"%d", dwVersion );
    pIniVersion->szDirectory = AllocSplStr(szTempBuffer);

    if ( pIniVersion->szDirectory == NULL ) {
        leave;
    }

    pIniVersion->cMajorVersion = dwVersion;

    // Initialize the Driver Files Reference count list.

    pIniVersion->pDrvRefCnt = NULL;

    //
    // Create the version directory.  This will write it out to the
    // registry since it will create a new directory.
    //
    if ( !CreateVersionDirectory( pIniVersion,
                                  pIniEnvironment,
                                  TRUE,
                                  pIniSpooler )) {

        //
        // Something Went Wrong Clean Up Registry Entry
        //
        DeleteDriverVersionIni( pIniVersion, pIniEnvironment, pIniSpooler );
        leave;
    }

    //
    // insert version entry into version list
    //
    InsertVersionList( &pIniEnvironment->pIniVersion, pIniVersion );

    bSuccess = TRUE;

 } finally {

    if ( !bSuccess && pIniVersion != NULL ) {

        FreeSplStr( pIniVersion->pName );
        FreeSplStr( pIniVersion->szDirectory );
        FreeSplMem( pIniVersion );
        pIniVersion = NULL;
    }
 }

    return pIniVersion;
}


BOOL
SetDependentFiles(
    IN  OUT LPWSTR              *ppszDependentFiles,
    IN  OUT LPDWORD             pcchDependentFiles,
    IN  OUT PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN      DWORD               FileCount,
    IN      BOOL                bFixICM,
    IN      BOOL                bMergeDependentFiles
    )
/*++

Routine Description:
    Sets dependentFiles field in IniDriver

Arguments:
    pDependentFiles     : copy the field to this (copy file names only, not full path)
    cchDependentFiles   : this is the character count (inc. \0\0) of the field
    pInternalDriverFiles: array of INTERNAL_DRV_FILE structures
    FileCount           : number of entries in previous array
    bFixICM             : For Win95 drivers ICM files should be used as
                          Color\<icm-file> in the dependent file list since
                          that is how SMB point and print needs it.

Return Value:
    TRUE  success (memory will be allocated)
    FALSE else

History:
    Written by MuhuntS (Muhunthan Sivapragasam) June 95

--*/
{
    BOOL    bRet                = TRUE;
    LPCWSTR pFileName           = NULL;
    LPWSTR  pStr                = NULL;
    LPWSTR  pszDependentFiles   = NULL;
    DWORD   cchDependentFiles   = 0;
    DWORD  i;

    SPLASSERT(FileCount);

    for ( i = cchDependentFiles = 0; i < FileCount && bRet ; ++i ) {

        pFileName = FindFileName(pInternalDriverFiles[i].pFileName);

        if (pFileName)
        {
            cchDependentFiles += wcslen(pFileName)+1;

            if ( bFixICM && IsAnICMFile(pInternalDriverFiles[i].pFileName) )
                cchDependentFiles += 6;
        }
        else
        {
            bRet = FALSE;

            SetLastError(ERROR_FILE_NOT_FOUND);
        }
    }

    // For last \0
    ++(cchDependentFiles);

    if (bRet)
    {
        pszDependentFiles = AllocSplMem(cchDependentFiles*sizeof(WCHAR));

        bRet = pszDependentFiles != NULL;
    }

    if (bRet)
    {
        for ( i=0, pStr = pszDependentFiles; i < FileCount && bRet ; ++i ) {

            pFileName = FindFileName(pInternalDriverFiles[i].pFileName);

            if (pFileName)
            {
                if ( bFixICM && IsAnICMFile(pInternalDriverFiles[i].pFileName) ) {

                    wcscpy(pStr, L"Color\\");
                    wcscat(pStr, pFileName);
                } else {

                    wcscpy(pStr, pFileName);
                }

                pStr += wcslen(pStr) + 1;
            }
            else
            {
                bRet = FALSE;

                SetLastError(ERROR_FILE_NOT_FOUND);
            }
        }

        *pStr = '\0';
    }

    //
    // If everything succeeded so far, we have two multi-sz strings that 
    // represent the old and the new dependent files, what we want to do
    // is to merge the resulting set of files together
    // 
    if (bRet && bMergeDependentFiles)
    {
        PWSTR   pszNewDependentFiles = pszDependentFiles;
        DWORD   cchNewDependentFiles = cchDependentFiles;

        pszDependentFiles = NULL; cchDependentFiles = 0;

        bRet = MergeMultiSz(*ppszDependentFiles, *pcchDependentFiles, pszNewDependentFiles, cchNewDependentFiles, &pszDependentFiles, &cchDependentFiles);

        FreeSplMem(pszNewDependentFiles);
    }

    if (bRet)
    {
        *ppszDependentFiles = pszDependentFiles;

        pszDependentFiles = NULL;
        *pcchDependentFiles = cchDependentFiles;
    }
    else
    {
        *pcchDependentFiles = 0;
        *ppszDependentFiles = NULL;
    }

    FreeSplMem(pszDependentFiles);

    return bRet;
}


PINIDRIVER
CreateDriverEntry(
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      DWORD               Level,
    IN      LPBYTE              pDriverInfo,
    IN      DWORD               dwFileCopyFlags,
    IN      PINISPOOLER         pIniSpooler,
    IN  OUT PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN      DWORD               FileCount,
    IN      DWORD               dwTempDir,
    IN      PINIDRIVER          pOldIniDriver
    )

/*++
Function Description - Creates a INIDRIVER struct and adds it to the list in pIniVersion

Parameters:

Return Values:
--*/

{
    PINIDRIVER      pIniDriver;
    PDRIVER_INFO_2  pDriver = (PDRIVER_INFO_2)pDriverInfo;
    PDRIVER_INFO_3  pDriver3 = (PDRIVER_INFO_3)pDriverInfo;
    PDRIVER_INFO_4  pDriver4 = (PDRIVER_INFO_4)pDriverInfo;
    PDRIVER_INFO_6  pDriver6 = (PDRIVER_INFO_6)pDriverInfo;
    PDRIVER_INFO_VERSION pDriverVersion = (PDRIVER_INFO_VERSION)pDriverInfo;
    LPWSTR          pszzPreviousNames;
    BOOL            bFail = FALSE, bUpdate;
    BOOL            bCoreFilesSame = TRUE;
    DWORD           dwDepFileIndex, dwDepFileCount, dwLen;

    bUpdate = pOldIniDriver != NULL;

    if ( !(pIniDriver = (PINIDRIVER) AllocSplMem(sizeof(INIDRIVER))) ) {

        return NULL;
    }
    else
    {
        pIniDriver->DriverFileMinorVersion = 0;
        pIniDriver->DriverFileMajorVersion = 0;
    }

    // If it is an update pIniDriver is just a place holder for strings
    if ( !bUpdate ) {

        pIniDriver->signature       = ID_SIGNATURE;
        pIniDriver->cVersion        = pIniVersion->cMajorVersion;

    } else {

        UpdateDriverFileRefCnt(pIniEnvironment, pIniVersion, pOldIniDriver, NULL, 0, FALSE);
        CopyMemory(pIniDriver, pOldIniDriver, sizeof(INIDRIVER));
    }

    //
    // For the core driver files, we want to see if any of them have changed, if
    // they are the same and the behaviour is APD_COPY_NEW_FILES, then we merge
    // the dependent files. This is to handle plugins correctly.
    //
    AllocOrUpdateStringAndTestSame(&pIniDriver->pDriverFile,
                                   FindFileName(pInternalDriverFiles[0].pFileName),
                                   bUpdate ? pOldIniDriver->pDriverFile : NULL,
                                   FALSE,
                                   &bFail,
                                   &bCoreFilesSame);

    AllocOrUpdateStringAndTestSame(&pIniDriver->pConfigFile,
                                   FindFileName(pInternalDriverFiles[1].pFileName),
                                   bUpdate ? pOldIniDriver->pConfigFile : NULL,
                                   FALSE,
                                   &bFail,
                                   &bCoreFilesSame);

    AllocOrUpdateStringAndTestSame(&pIniDriver->pDataFile,
                                   FindFileName(pInternalDriverFiles[2].pFileName),
                                   bUpdate ? pOldIniDriver->pDataFile : NULL,
                                   FALSE,
                                   &bFail,
                                   &bCoreFilesSame);

    pIniDriver->dwTempDir = dwTempDir;

    switch (Level) {
        case 2:
            AllocOrUpdateString(&pIniDriver->pName,
                                pDriver->pName,
                                bUpdate ? pOldIniDriver->pName : NULL,
                                FALSE,
                                &bFail);

            pIniDriver->pHelpFile   = pIniDriver->pDependentFiles
                                    = pIniDriver->pMonitorName
                                    = pIniDriver->pDefaultDataType
                                    = pIniDriver->pszzPreviousNames
                                    = NULL;

            pIniDriver->cchDependentFiles   = pIniDriver->cchPreviousNames
                                            = 0;
            break;

        case 3:
        case 4:
            pIniDriver->pszMfgName    = NULL;
            pIniDriver->pszOEMUrl     = NULL;
            pIniDriver->pszHardwareID = NULL;
            pIniDriver->pszProvider   = NULL;

        case DRIVER_INFO_VERSION_LEVEL :
        case 6:
            AllocOrUpdateString(&pIniDriver->pName,
                                pDriver3->pName,
                                bUpdate ? pOldIniDriver->pName : NULL,
                                FALSE,
                                &bFail);

            dwDepFileIndex          = 3;
            dwDepFileCount          = FileCount - 3;

            //
            // Look for the help file
            //
            {
                LPWSTR pszHelpFile = NULL;

                if (Level == DRIVER_INFO_VERSION_LEVEL) 
                {
                    DWORD HelpFileIndex;

                    //
                    // Search for the help file in the array of file infos. All inbox 
                    // drivers have a help file, but IHV printer drivers may not have 
                    // one. Therefore it is not safe to assume we always have a help file
                    //
                    if (S_OK == FindIndexInDrvFileInfo(pDriverVersion->pFileInfo,
                                                       pDriverVersion->dwFileCount,
                                                       HELP_FILE,
                                                       &HelpFileIndex))
                    {
                        pszHelpFile = (LPWSTR)((LPBYTE)pDriverVersion + 
                                               pDriverVersion->pFileInfo[HelpFileIndex].FileNameOffset);
                    }
                }
                else
                {
                    //
                    // Level is 3,4 or 6
                    //
                    pszHelpFile = pDriver3->pHelpFile;
                }

                if (pszHelpFile && *pszHelpFile)                
                {
                    AllocOrUpdateString(&pIniDriver->pHelpFile,
                                        FindFileName(pInternalDriverFiles[3].pFileName),
                                        bUpdate ? pOldIniDriver->pHelpFile : NULL,
                                        FALSE,
                                        &bFail);
    
                    ++dwDepFileIndex;
                    --dwDepFileCount;
                }
                else
                {
                    pIniDriver->pHelpFile = NULL;
                }
            }
            
            if ( dwDepFileCount ) {

                //
                // We want to merge the dependent files if:
                // 1. None of the Core files have changed.
                // 2. The call was made with APD_COPY_NEW_FILES.
                // 
                BOOL    bMergeDependentFiles = bCoreFilesSame && dwFileCopyFlags & APD_COPY_NEW_FILES;

                if ( !bFail &&
                     !SetDependentFiles(&pIniDriver->pDependentFiles,
                                        &pIniDriver->cchDependentFiles,
                                        pInternalDriverFiles+dwDepFileIndex,
                                        dwDepFileCount,
                                        !wcscmp(pIniEnvironment->pName, szWin95Environment),
                                        bMergeDependentFiles) ) {
                    bFail = TRUE;
                }
            } else {

                pIniDriver->pDependentFiles = NULL;
                pIniDriver->cchDependentFiles = 0;
            }

            AllocOrUpdateString(&pIniDriver->pMonitorName,
                                (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                pDriverVersion->pMonitorName : pDriver3->pMonitorName,
                                bUpdate ? pOldIniDriver->pMonitorName : NULL,
                                FALSE,
                                &bFail);

            AllocOrUpdateString(&pIniDriver->pDefaultDataType,
                                (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                pDriverVersion->pDefaultDataType : pDriver3->pDefaultDataType,
                                bUpdate ? pOldIniDriver->pDefaultDataType : NULL,
                                FALSE,
                                &bFail);

            pIniDriver->cchPreviousNames = 0;

            if ( Level == 4 || Level == 6 || Level == DRIVER_INFO_VERSION_LEVEL) {

                pszzPreviousNames = (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                    pDriverVersion->pszzPreviousNames :
                                    pDriver4->pszzPreviousNames;

                for ( ; pszzPreviousNames && *pszzPreviousNames; pszzPreviousNames += dwLen) {

                    dwLen = wcslen(pszzPreviousNames) + 1;

                    pIniDriver->cchPreviousNames += dwLen;
                }

                if ( pIniDriver->cchPreviousNames ) {

                    pIniDriver->cchPreviousNames++;

                    if ( !(pIniDriver->pszzPreviousNames
                                = AllocSplMem(pIniDriver->cchPreviousNames
                                                            * sizeof(WCHAR))) ) {

                        bFail = TRUE;

                    } else {

                        CopyMemory(
                                (LPBYTE)(pIniDriver->pszzPreviousNames),
                                (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                pDriverVersion->pszzPreviousNames :
                                pDriver4->pszzPreviousNames,
                                pIniDriver->cchPreviousNames * sizeof(WCHAR));
                    }

                } else {

                    pIniDriver->pszzPreviousNames = NULL;
                }

            }

            if (Level == 6 || Level == DRIVER_INFO_VERSION_LEVEL) {

                 AllocOrUpdateString(&pIniDriver->pszMfgName,
                                (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                pDriverVersion->pszMfgName : pDriver6->pszMfgName,
                                bUpdate ? pOldIniDriver->pszMfgName : NULL,
                                FALSE,
                                &bFail);

                 AllocOrUpdateString(&pIniDriver->pszOEMUrl,
                                (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                pDriverVersion->pszOEMUrl : pDriver6->pszOEMUrl,
                                bUpdate ? pOldIniDriver->pszOEMUrl : NULL,
                                FALSE,
                                &bFail);

                 AllocOrUpdateString(&pIniDriver->pszHardwareID,
                                (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                pDriverVersion->pszHardwareID : pDriver6->pszHardwareID,
                                bUpdate ? pOldIniDriver->pszHardwareID : NULL,
                                FALSE,
                                &bFail);

                 AllocOrUpdateString(&pIniDriver->pszProvider,
                                (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                pDriverVersion->pszProvider : pDriver6->pszProvider,
                                bUpdate ? pOldIniDriver->pszProvider : NULL,
                                FALSE,
                                &bFail);

                 pIniDriver->dwlDriverVersion = (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                                pDriverVersion->dwlDriverVersion : pDriver6->dwlDriverVersion;
                 pIniDriver->ftDriverDate     = (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                                pDriverVersion->ftDriverDate : pDriver6->ftDriverDate;
            }

            break;

        default: //can not be
            DBGMSG(DBG_ERROR,
                   ("CreateDriverEntry: level can not be %d", Level) );
            return NULL;
    }


    // Added calls to update driver files ref counts.

    if ( !bFail && UpdateDriverFileRefCnt(pIniEnvironment,pIniVersion,pIniDriver,NULL,0,TRUE) ) {

        //
        // Update the files minor version
        //
        UpdateDriverFileVersion(pIniVersion, pInternalDriverFiles, FileCount);

        // UMPD\KMPD detection
        CheckDriverAttributes(pIniSpooler, pIniEnvironment,
                              pIniVersion, pIniDriver);

        if ( WriteDriverIni(pIniDriver, pIniVersion, pIniEnvironment, pIniSpooler)) {

            if ( bUpdate ) {
                CopyNewOffsets((LPBYTE) pOldIniDriver,
                               (LPBYTE) pIniDriver,
                               IniDriverOffsets);

                // Remove temp files and directory, if any
                if (pOldIniDriver->dwTempDir && (dwTempDir == 0)) {

                    RemoveDriverTempFiles(pIniSpooler,
                                          pIniEnvironment,
                                          pIniVersion,
                                          pOldIniDriver);
                }

                pOldIniDriver->dwDriverAttributes = pIniDriver->dwDriverAttributes;
                pOldIniDriver->cchDependentFiles = pIniDriver->cchDependentFiles;
                pOldIniDriver->dwTempDir = pIniDriver->dwTempDir;
                pOldIniDriver->cchPreviousNames = pIniDriver->cchPreviousNames;

                if(Level == 6)
                {
                    pOldIniDriver->dwlDriverVersion = pIniDriver->dwlDriverVersion;
                    pOldIniDriver->ftDriverDate     = pIniDriver->ftDriverDate;
                }

                FreeSplMem( pIniDriver );

                return pOldIniDriver;
            } else {
                pIniDriver->pNext = pIniVersion->pIniDriver;
                pIniVersion->pIniDriver = pIniDriver;

                return pIniDriver;
            }
        }
    }

    //
    // Get here only for failure cases.
    //
    FreeStructurePointers((LPBYTE) pIniDriver,
                          (LPBYTE) pOldIniDriver,
                          IniDriverOffsets);
    FreeSplMem( pIniDriver );

    return NULL;

}

BOOL
IsKMPD(
    LPWSTR  pDriverName
    )
/*++
Function Description:  Determines if the driver is kernel or user mode. If the dll
                       cant be loaded or the required export is not found, the spooler
                       assumes that the driver runs in kernel mode.

Parameters:  pDriverName  -- Driver file name

Return Values: TRUE if kernel mode;
               FALSE otherwise
--*/
{
    DWORD  dwOldErrorMode, dwUserMode, cb;
    HANDLE hInst;
    BOOL   bReturn = TRUE;
    BOOL   (*pfnDrvQuery)(DWORD, PVOID, DWORD, PDWORD);

    // Avoid popups from loadlibrary failures
    dwOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    hInst = LoadLibraryExW(pDriverName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

    if (hInst) {

        // Check if the printer driver DLL exports DrvQueryDriverInfo entrypoint
        pfnDrvQuery = (BOOL (*)(DWORD, PVOID, DWORD, PDWORD))
                              GetProcAddress(hInst, "DrvQueryDriverInfo");

        if ( pfnDrvQuery ) {

            try {

                if ( pfnDrvQuery(DRVQUERY_USERMODE, &dwUserMode,
                                 sizeof(dwUserMode), &cb) )
                    bReturn = (dwUserMode == 0);

            } except(EXCEPTION_EXECUTE_HANDLER) {

                SetLastError( GetExceptionCode() );
                DBGMSG(DBG_ERROR,
                       ("IsKMPD ExceptionCode %x Driver %ws Error %d\n",
                         GetLastError(), pDriverName, GetLastError() ));
            }
        }

        FreeLibrary(hInst);
    }

    SetErrorMode(dwOldErrorMode);

    return bReturn;
}

BOOL
IniDriverIsKMPD (
    PINISPOOLER     pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION     pIniVersion,
    PINIDRIVER      pIniDriver
    )
/*++
Function Description:
    Determines if the driver is kernel or user mode.
    For Whistler we save pIniDriver->dwDriverAttributes under registry.
    pIniDriver->dwDriverAttributes could be un-initialized at the time we do
    the check to see if a driver is KM or UM.

Parameters:   pIniSpooler          -- pointer to INISPOOLER
              pIniEnvironment      -- pointer to INIENVIRONMENT
              pIniVersion          -- pointer to INVERSION
              pIniDriver           -- pointer to INIDRIVER

Return Values: TRUE if kernel mode;
               FALSE otherwise
--*/
{
    //
    // Call IsKMPD if dwDriverAttributes is not initialized
    //
    if ( pIniDriver->dwDriverAttributes == 0 ) {

        CheckDriverAttributes(pIniSpooler, pIniEnvironment, pIniVersion, pIniDriver);
    }

    return (BOOL)(pIniDriver->dwDriverAttributes & DRIVER_KERNELMODE);
}

VOID
CheckDriverAttributes(
    PINISPOOLER     pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION     pIniVersion,
    PINIDRIVER      pIniDriver
    )
/*++
Function Description: Updates the pIniDriver->dwDriverAttributes field

Parameters:   pIniSpooler          -- pointer to INISPOOLER
              pIniEnvironment      -- pointer to INIENVIRONMENT
              pIniVersion          -- pointer to INVERSION
              pIniDriver           -- pointer to INIDRIVER

Return Values: NONE
--*/
{
    WCHAR       szDriverFile[MAX_PATH];
    PINIDRIVER  pUpdateIniDriver;

    if( GetDriverVersionDirectory(  szDriverFile,
                                    COUNTOF(szDriverFile),
                                    pIniSpooler,
                                    pIniEnvironment,
                                    pIniVersion,
                                    pIniDriver,
                                    NULL)   &&
        StrNCatBuff(szDriverFile,
                    COUNTOF(szDriverFile),
                    szDriverFile,
                    L"\\",
                    FindFileName(pIniDriver->pDriverFile),
                    NULL) == ERROR_SUCCESS )
    {
         pIniDriver->dwDriverAttributes = IsKMPD(szDriverFile) ? DRIVER_KERNELMODE
                                                               : DRIVER_USERMODE;

         // Update other pIniDriver structs with the new driver attributes.

         for (pUpdateIniDriver = pIniVersion->pIniDriver;
              pUpdateIniDriver;
              pUpdateIniDriver = pUpdateIniDriver->pNext) {

             if (pUpdateIniDriver == pIniDriver) {

                 // Already updated this driver
                 continue;
             }

             if (!_wcsicmp(FindFileName(pIniDriver->pDriverFile),
                           FindFileName(pUpdateIniDriver->pDriverFile))) {

                 pUpdateIniDriver->dwDriverAttributes = pIniDriver->dwDriverAttributes;
             }
         }
    }
    return;
}

BOOL
FileInUse(
    PINIVERSION pIniVersion,
    LPWSTR      pFileName
    )
/*++
Function Description: Finds if the file specified by pFileName is used by any driver.

Parameters: pIniVersion - pointer to INIVERSION struct where the ref counts are
                          stored
            pFileName   - Name of the driver related file

Return Value: TRUE if file is in Use
              FALSE otherwise
--*/
{
    PDRVREFCNT pdrc;

    if (!pFileName || !(*pFileName)) {
       return FALSE;
    }

    pdrc = pIniVersion->pDrvRefCnt;

    while (pdrc != NULL) {
       if (_wcsicmp(pFileName,pdrc->szDrvFileName) == 0) {
          return (pdrc->refcount > 1);
       }
       pdrc = pdrc->pNext;
    }

    return FALSE;

}

BOOL
FilesInUse(
    PINIVERSION pIniVersion,
    PINIDRIVER  pIniDriver
    )

/*++
Function Description: FilesInUse checks if any of the driver files are used by another
                      driver

Parameters: pIniVersion - pointer to INIVERSION struct where the ref counts are
                          stored
            pIniDriver  - pointer to INIDRIVER struct where the filenames are stored

Return Value: TRUE if any file is in Use
              FALSE otherwise
--*/
{
    LPWSTR pIndex;

    if (FileInUse(pIniVersion,pIniDriver->pDriverFile)) {
       return TRUE;
    }
    if (FileInUse(pIniVersion,pIniDriver->pConfigFile)) {
       return TRUE;
    }
    if (FileInUse(pIniVersion,pIniDriver->pDataFile)) {
       return TRUE;
    }
    if (FileInUse(pIniVersion,pIniDriver->pHelpFile)) {
       return TRUE;
    }

    pIndex = pIniDriver->pDependentFiles;
    while (pIndex && *pIndex) {
       if (FileInUse(pIniVersion,pIndex)) return TRUE;
       pIndex += wcslen(pIndex) + 1;
    }

    return FALSE;
}

BOOL
DuplicateFile(
    PDRVFILE    *ppfile,
    LPCWSTR      pFileName,
    BOOL        *pbDuplicate
    )
/*++
Function Description:   Detects repeated filenames in INIDRIVER struct.
                        The function adds nodes to the list of filenames.

Parameters:   ppfile      - pointer to a list of filenames seen till now
              pFileName   - name of the file
              pbDuplicate - pointer to flag to indicate duplication

Return Values: TRUE - if successful
               FALSE - otherwise
--*/
{
    PDRVFILE    pfile = *ppfile,pfiletemp;

    *pbDuplicate = FALSE;

    if (!pFileName || !(*pFileName)) {
        return TRUE;
    }

    while (pfile) {
       if (pfile->pFileName && (lstrcmpi(pFileName,pfile->pFileName) == 0)) {
           *pbDuplicate = TRUE;
           return TRUE;
       }
       pfile = pfile->pnext;
    }

    if (!(pfiletemp = AllocSplMem(sizeof(DRVFILE)))) {
       return FALSE;
    }
    pfiletemp->pnext = *ppfile;
    pfiletemp->pFileName = pFileName;
    *ppfile = pfiletemp;

    return TRUE;
}


BOOL
InternalIncrement(
    PDRVREFNODE *pNew,
    PDRVFILE    *ppfile,
    PINIVERSION pIniVersion,
    LPCWSTR     pFileName
    )
/*++
Function Description: InternalIncrement calls IncrementFileRefCnt and saves the pointer to
                      to the DRVREFCNT in a DRVREFNODE. These pointers are used to readjust
                      the ref counts if any intermediate call to IncrementFileRefCnt fails.

Parameters: pNew - pointer to a variable which contains a pointer to a DRVREFNODE.
                   The new DRVREFNODE is assigned to this variable.
            ppfile - list of filenames seen so far.
            pIniVersion - pointer to INIVERSION struct.
            pFileName - Name of the file whose ref cnt is to be incremented.

Return Value: TRUE if memory allocation and call to IncrementFileRefCnt succeeds
              FALSE otherwise.

--*/
{
    PDRVREFNODE ptemp;
    BOOL        bDuplicate;

    if (!pFileName || !pFileName[0]) {
        return TRUE;
    }

    if (!DuplicateFile(ppfile, pFileName, &bDuplicate)) {
        return FALSE;
    }

    if (bDuplicate) {
        return TRUE;
    }

    if (!(ptemp = AllocSplMem(sizeof(DRVREFNODE)))) {
        return FALSE;
    }

    ptemp->pNext = *pNew;
    *pNew = ptemp;

    if ((*pNew)->pdrc = IncrementFileRefCnt(pIniVersion,pFileName)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
InternalDecrement(
    PDRVREFNODE *pNew,
    PDRVFILE    *ppfile,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER  pIniDriver,
    LPCWSTR     pFileName,
    LPCWSTR     pDirectory,
    DWORD       dwDeleteFlag
    )
/*++
Function Description: InternalDecrement calls DecrementFileRefCnt and saves the pointer to
                      to the DRVREFCNT in a DRVREFNODE. These pointers are used to readjust
                      the ref counts if any intermediate call to DecrementFileRefCnt fails.

Parameters: pNew - pointer to a variable which contains a pointer to a DRVREFNODE.
                   The new DRVREFNODE is assigned to this variable.
            ppfile - list of filenames seen so far.
            pIniEnvironment - pointer to INIENVIRONMENT.
            pIniVersion - pointer to INIVERSION struct.
            pIniDriver - pointer to INIDRIVER.
            pFileName - Name of the file whose ref cnt is to be decremented.
            pDirectory - Directory where the files are stored.
            dwDeleteFlag - Flag to delete files.

Return Value: TRUE if memory allocation and call to DecrementFileRefCnt succeeds
              FALSE otherwise.

--*/

{
    PDRVREFNODE ptemp;
    BOOL        bDuplicate;

    if( !pFileName || !pFileName[0] ){
        return TRUE;
    }

    if (!DuplicateFile(ppfile, pFileName, &bDuplicate)) {
        return FALSE;
    }

    if (bDuplicate) {
        return TRUE;
    }

    if (!(ptemp = AllocSplMem(sizeof(DRVREFNODE)))) {
        return FALSE;
    }

    ptemp->pNext = *pNew;
    *pNew = ptemp;

    if ((*pNew)->pdrc = DecrementFileRefCnt(pIniEnvironment,pIniVersion,pIniDriver,pFileName,
                                            pDirectory,dwDeleteFlag)) {
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOL
UpdateDriverFileRefCnt(
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER  pIniDriver,
    LPCWSTR     pDirectory,
    DWORD       dwDeleteFlag,
    BOOL        bIncrementFlag
    )
/*++
Function Description: UpdateDriverRefCnt calls the functions to increment or decrement
                      the ref cnts for the driver related files. If any call fails, the
                      ref cnts are returned to their previous values.

Parameters: pIniEnvironment : pointer to INIENVIRONMENT
            pIniVersion : pointer to INIVERSION struct which contains the ref cnts.
            pIniDriver  : pointer to INIDRIVER struct which contains driver info.
            pDirectory  : Directory where the files are stored.
            dwDeleteFlag: Flag to delete the files.
            bIncrementFlag: TRUE if driver added
                            FALSE if driver deleted.

Return Values: TRUE if success
               FALSE otherwise.
--*/
{
    LPWSTR      pIndex;
    PDRVREFNODE phead=NULL,ptemp=NULL;
    BOOL        bReturn = TRUE;
    PDRVFILE    pfile = NULL,pfiletemp;
    PDRVREFCNT  pDrvRefCnt, *ppDrvRefCnt;

    pIndex = pIniDriver->pDependentFiles;

    if (bIncrementFlag) {
       // Adding driver entry. Increment fileref counts.

       if (!InternalIncrement(&phead,&pfile,pIniVersion,pIniDriver->pDriverFile)
           || !InternalIncrement(&phead,&pfile,pIniVersion,pIniDriver->pConfigFile)
           || !InternalIncrement(&phead,&pfile,pIniVersion,pIniDriver->pHelpFile)
           || !InternalIncrement(&phead,&pfile,pIniVersion,pIniDriver->pDataFile)) {

           bReturn = FALSE;
           goto CleanUp;

       }

       while (pIndex && *pIndex) {
          if (!InternalIncrement(&phead,&pfile,pIniVersion,pIndex)) {
             bReturn = FALSE;
             goto CleanUp;
          }
          pIndex += wcslen(pIndex) + 1;
       }

    } else {
       // Deleting driver entry. Decrement fileref counts.

       if (!InternalDecrement(&phead,&pfile,pIniEnvironment,pIniVersion,pIniDriver,pIniDriver->pDriverFile,
                               pDirectory,dwDeleteFlag)
           || !InternalDecrement(&phead,&pfile,pIniEnvironment,pIniVersion,pIniDriver,pIniDriver->pConfigFile,
                               pDirectory,dwDeleteFlag)
           || !InternalDecrement(&phead,&pfile,pIniEnvironment,pIniVersion,pIniDriver,pIniDriver->pHelpFile,
                               pDirectory,dwDeleteFlag)
           || !InternalDecrement(&phead,&pfile,pIniEnvironment,pIniVersion,pIniDriver,pIniDriver->pDataFile,
                               pDirectory,dwDeleteFlag)) {

           bReturn = FALSE;
           goto CleanUp;
       }

       while (pIndex && *pIndex) {
          if (!InternalDecrement(&phead,&pfile,pIniEnvironment,pIniVersion,pIniDriver,pIndex,pDirectory,dwDeleteFlag)) {
             bReturn = FALSE;
             goto CleanUp;
          }
          pIndex += wcslen(pIndex) + 1;
       }
    }

CleanUp:

    if (bReturn) {
       //
       // When delete the file, remove the RefCnt nodes with count = 0.
       // We want to keep the node when we don't delete the file because the node
       // contains info about how many times the file was updated (dwVersion).
       // Client apps (WINSPOOL.DRV) rely on this when decide to reload the driver files.
       //
       while (ptemp = phead) {
          if (ptemp->pdrc &&
              ptemp->pdrc->refcount == 0 &&
              (dwDeleteFlag & DPD_DELETE_UNUSED_FILES ||
               dwDeleteFlag & DPD_DELETE_ALL_FILES)) {
             FreeSplStr(ptemp->pdrc->szDrvFileName);
             FreeSplMem(ptemp->pdrc);
          }
          phead = phead->pNext;
          FreeSplMem(ptemp);
       }

    } else {
       // Adjust the ref counts.
       while (ptemp = phead) {
          if (ptemp->pdrc) {
             if (bIncrementFlag) {
                ptemp->pdrc->refcount--;
             } else {
                ptemp->pdrc->refcount++;
                if (ptemp->pdrc->refcount == 1) {
                   ptemp->pdrc->pNext = pIniVersion->pDrvRefCnt;
                   pIniVersion->pDrvRefCnt = ptemp->pdrc;
                }
             }
          }
          phead = phead->pNext;
          FreeSplMem(ptemp);
       }

       //
       // When delete the file, remove the RefCnt nodes with count = 0.
       // We want to keep the node when we don't delete the file because the node
       // contains info about how many times the file was updated (dwVersion).
       // Client apps (WINSPOOL.DRV) rely on this when decide to reload the driver files.
       //
       ppDrvRefCnt = &(pIniVersion->pDrvRefCnt);
       while (pDrvRefCnt = *ppDrvRefCnt) {
           if (pDrvRefCnt->refcount == 0 && dwDeleteFlag) {
               *ppDrvRefCnt = pDrvRefCnt->pNext;
               FreeSplStr(pDrvRefCnt->szDrvFileName);
               FreeSplMem(pDrvRefCnt);
           } else {
               ppDrvRefCnt = &(pDrvRefCnt->pNext);
           }
       }
    }

    while (pfiletemp = pfile) {
       pfile = pfile->pnext;
       FreeSplMem(pfiletemp);
    }

    return bReturn;

}

VOID
UpdateDriverFileVersion(
    IN  PINIVERSION         pIniVersion,
    IN  PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN  DWORD               FileCount
    )
{
    PDRVREFCNT pdrc;
    DWORD      dwIndex;

    SplInSem();

    if (pInternalDriverFiles && pIniVersion)
    {
        for (dwIndex = 0 ; dwIndex < FileCount ; dwIndex ++)
        {
            //
            // Don't do anything for non-executable files
            //
            if (!IsEXEFile(pInternalDriverFiles[dwIndex].pFileName))
            {
                continue;
            }

            //
            // Search the entry in pIniVersion's list of files
            //
            for (pdrc = pIniVersion->pDrvRefCnt;
                 pdrc &&
                 lstrcmpi(FindFileName(pInternalDriverFiles[dwIndex].pFileName),
                                       pdrc->szDrvFileName) != 0;
                 pdrc = pdrc->pNext);

            if (pdrc)
            {
                if (pInternalDriverFiles[dwIndex].hFileHandle == INVALID_HANDLE_VALUE)
                {
                    //
                    // We can come in here from a pending upgrade when we don't know the
                    // version.
                    //
                    pdrc->bInitialized = FALSE;
                }
                else if (pInternalDriverFiles[dwIndex].bUpdated)
                {
                    pdrc->dwFileMinorVersion = pInternalDriverFiles[dwIndex].dwVersion;
                    pdrc->bInitialized = TRUE;
                }
            }
        }
    }
}


PDRVREFCNT
IncrementFileRefCnt(
    PINIVERSION pIniVersion,
    LPCWSTR pFileName
    )
/*++
Function Description: IncrementFileRefCnt increments/initializes to 1 the ref count node
                      for pFileName in the IniVersion Struct.

Parameters: pIniversion - pointer to the INIVERSION struct.
            pFileName   - Name of the file whose ref cnt is to be incremented.

Return Values: Pointer to the ref cnt that was incremented
               NULL if memory allocation fails.

--*/
{
    PDRVREFCNT pdrc;

    SplInSem();

    if (!pIniVersion || !pFileName || !(*pFileName)) {
       return NULL;
    }

    pdrc = pIniVersion->pDrvRefCnt;

    while (pdrc != NULL) {

       if (lstrcmpi(pFileName,pdrc->szDrvFileName) == 0) {
          pdrc->refcount++;
          return pdrc;
       }
       pdrc = pdrc->pNext;
    }

    if (!(pdrc = (PDRVREFCNT) AllocSplMem(sizeof(DRVREFCNT)))) return NULL;
    pdrc->refcount = 1;
    pdrc->dwVersion = 0;
    pdrc->dwFileMinorVersion = 0;
    pdrc->dwFileMajorVersion = 0;
    pdrc->bInitialized = 0;
    if (!(pdrc->szDrvFileName = AllocSplStr(pFileName))) {
       FreeSplMem(pdrc);
       return NULL;
    }
    pdrc->pNext = pIniVersion->pDrvRefCnt;
    pIniVersion->pDrvRefCnt = pdrc;

    return pdrc;
}


DWORD
GetEnvironmentScratchDirectory(
    LPWSTR   pDir,
    DWORD    MaxLength,
    PINIENVIRONMENT  pIniEnvironment,
    BOOL    Remote
    )
{
   PINISPOOLER pIniSpooler = pIniEnvironment->pIniSpooler;

   if (Remote) {

       if( StrNCatBuff( pDir,
                        MaxLength,
                        pIniSpooler->pMachineName,
                        L"\\",
                        pIniSpooler->pszDriversShare,
                        L"\\",
                        pIniEnvironment->pDirectory,
                        NULL) != ERROR_SUCCESS )
        return 0;

   } else {

       if( StrNCatBuff( pDir,
                        MaxLength,
                        pIniSpooler->pDir,
                        L"\\",
                        szDriverDir,
                        L"\\",
                        pIniEnvironment->pDirectory,
                        NULL) != ERROR_SUCCESS ) {
           return 0;
       }
   }

   return wcslen(pDir);

}


BOOL
CreateVersionDirectory(
    PINIVERSION pIniVersion,
    PINIENVIRONMENT pIniEnvironment,
    BOOL bUpdate,
    PINISPOOLER pIniSpooler
    )
/*++

Routine Description:

    Creates a version directory if necessary for the environment.
    If a version number file exists instead of a directory, a tmp
    directory is created, and pIniVersion is updated appropriately.

    We will update the registry if we need to create a directory by
    re-writing the entire version entry.  This is how the version
    entry in the registry is initially created.

Arguments:

    pIniVersion - Version of drivers that the directory will hold.
                  If the directory already exists, we will modify
                  pIniVersion->szDirectory to a temp name and write
                  it to the registry.

    pIniEnvironment - Environment to use.

    bUpdate - Indicates whether we should write out the IniVersion
              registry entries.  We need to do this if we just alloced
              the pIniVersion, or if we have changed directories.

    pIniSpooler

Return Value:

    BOOL - TRUE   = Version directory and registry created/updated.
           FALSE  = Failure, call GetLastError().

--*/
{
    WCHAR   ParentDir[MAX_PATH];
    WCHAR   Directory[MAX_PATH];
    DWORD   dwParentLen=0;
    DWORD   dwAttributes = 0;
    BOOL    bCreateDirectory = FALSE;
    BOOL    bReturn = TRUE;
    HANDLE  hToken;

    if((StrNCatBuff (  ParentDir,
                       COUNTOF(ParentDir),
                       pIniSpooler->pDir,
                       L"\\drivers\\" ,
                       pIniEnvironment->pDirectory,
                       NULL) != ERROR_SUCCESS ) ||
       (StrNCatBuff (  Directory,
                       COUNTOF(Directory),
                       pIniSpooler->pDir,
                       L"\\drivers\\",
                       pIniEnvironment->pDirectory,
                       L"\\",
                       pIniVersion->szDirectory,
                       NULL) != ERROR_SUCCESS ) )
    {
        bReturn = FALSE;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto End;
    }

    DBGMSG( DBG_TRACE, ("The name of the version directory is %ws\n", Directory));
    dwAttributes = GetFileAttributes( Directory );

    hToken = RevertToPrinterSelf();

    if (dwAttributes == 0xffffffff) {

        bCreateDirectory = TRUE;

    } else if (!(dwAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

        LPWSTR pszOldDirectory = pIniVersion->szDirectory;

        DBGMSG(DBG_WARNING, ("CreateVersionDirectory: a file <not a dir> exists by the name of %ws\n", Directory));

        GetTempFileName(ParentDir, L"SPL", 0, Directory);

        //
        // GetTempFileName creates the file.  (Small window where someone
        // else could grab our file name.)
        //
        SplDeleteFile(Directory);

        //
        // We created a new dir, so modify the string.
        //
        dwParentLen = wcslen(ParentDir);
        pIniVersion->szDirectory = AllocSplStr(&Directory[dwParentLen+1]);

        if (!pIniVersion->szDirectory) {

            pIniVersion->szDirectory = pszOldDirectory;

            //
            // Memory allocation failed, just revert back to old and
            // let downwind code handle failure case.
            //
            bReturn = FALSE;

        } else {

            FreeSplStr(pszOldDirectory);
            bCreateDirectory = TRUE;
        }
    }

    if( bCreateDirectory ){

        if( CreateCompleteDirectory( Directory )){

            //
            // Be sure to update the registry entries.
            //
            bUpdate = TRUE;

        } else {

            //
            // Fail the operation since we couldn't create the directory.
            //
            bReturn = FALSE;
        }
    }

    if( bUpdate ){

        //
        // Directory exists, update registry.
        //

        bReturn = WriteDriverVersionIni( pIniVersion,
                                         pIniEnvironment,
                                         pIniSpooler);
    }

    ImpersonatePrinterClient( hToken );

End:

    return bReturn;
}


BOOL
WriteDriverVersionIni(
    PINIVERSION     pIniVersion,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
    )
/*++

Routine Description:

    Writes out the driver version registry entries.

    Note: assumes we are running in the system context; callee must
    call RevertToPrinterSelf()!

Arguments:

    pIniVersion - version to write out

    pIniEnvironment - environment the version belongs to

    pIniSpooler

Return Value:

    TRUE  =  success
    FALSE =  failure, call GetLastError()

--*/
{
    HKEY    hEnvironmentsRootKey = NULL;
    HKEY    hEnvironmentKey = NULL;
    HKEY    hDriversKey = NULL;
    HKEY    hVersionKey = NULL;
    DWORD   dwLastError = ERROR_SUCCESS;
    BOOL    bReturnValue;

 try {

     //
     // The local spooler and cluster spoolers do not share the same resgirty location
     // for environments, drivers, processors etc.
     //
    if ( !PrinterCreateKey( pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ? pIniSpooler->hckRoot : HKEY_LOCAL_MACHINE,
                            (LPWSTR)pIniSpooler->pszRegistryEnvironments,
                            &hEnvironmentsRootKey,
                            &dwLastError,
                            pIniSpooler )) {

        leave;
    }

    if ( !PrinterCreateKey( hEnvironmentsRootKey,
                            pIniEnvironment->pName,
                            &hEnvironmentKey,
                            &dwLastError,
                            pIniSpooler )) {

        leave;
    }

    if ( !PrinterCreateKey( hEnvironmentKey,
                            szDriversKey,
                            &hDriversKey,
                            &dwLastError,
                            pIniSpooler )) {


        leave;
    }

    if ( !PrinterCreateKey( hDriversKey,
                            pIniVersion->pName,
                            &hVersionKey,
                            &dwLastError,
                            pIniSpooler )) {

        leave;
    }

    RegSetString( hVersionKey, szDirectory, pIniVersion->szDirectory, &dwLastError, pIniSpooler );
    RegSetDWord(  hVersionKey, szMajorVersion, pIniVersion->cMajorVersion, &dwLastError, pIniSpooler );
    RegSetDWord(  hVersionKey, szMinorVersion, pIniVersion->cMinorVersion ,&dwLastError, pIniSpooler );

 } finally {

    if (hVersionKey)
        SplRegCloseKey(hVersionKey, pIniSpooler);

    if (hDriversKey)
        SplRegCloseKey(hDriversKey, pIniSpooler);

    if (hEnvironmentKey)
        SplRegCloseKey(hEnvironmentKey, pIniSpooler);

    if (hEnvironmentsRootKey)
        SplRegCloseKey(hEnvironmentsRootKey, pIniSpooler);

    if (dwLastError != ERROR_SUCCESS) {

        SetLastError(dwLastError);
        bReturnValue = FALSE;

    } else {

        bReturnValue = TRUE;
    }

 }
    return bReturnValue;
}

BOOL
DeleteDriverVersionIni(
    PINIVERSION pIniVersion,
    PINIENVIRONMENT  pIniEnvironment,
    PINISPOOLER pIniSpooler
    )
{
    HKEY    hEnvironmentsRootKey, hEnvironmentKey, hDriversKey;
    HANDLE  hToken;
    HKEY    hVersionKey;
    BOOL    bReturnValue = FALSE;
    DWORD   Status;

    hToken = RevertToPrinterSelf();

    if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, pIniSpooler->pszRegistryEnvironments, 0,
                         NULL, 0, KEY_WRITE, NULL, &hEnvironmentsRootKey, NULL) == ERROR_SUCCESS) {

        if ( RegOpenKeyEx( hEnvironmentsRootKey, pIniEnvironment->pName, 0,
                           KEY_WRITE, &hEnvironmentKey) == ERROR_SUCCESS) {

            if ( RegOpenKeyEx( hEnvironmentKey, szDriversKey, 0,
                               KEY_WRITE, &hDriversKey) == ERROR_SUCCESS) {

                Status = RegDeleteKey( hDriversKey, pIniVersion->pName );

                if ( Status == ERROR_SUCCESS ) {

                    bReturnValue = TRUE;

                } else {

                    DBGMSG( DBG_WARNING, ( "DeleteDriverVersionIni failed RegDeleteKey %x %ws error %d\n",
                                           hDriversKey,
                                           pIniVersion->pName,
                                           Status ));
                }

                RegCloseKey(hDriversKey);
            }

            RegCloseKey(hEnvironmentKey);
        }

        RegCloseKey(hEnvironmentsRootKey);
    }

    ImpersonatePrinterClient( hToken );

    return bReturnValue;
}



BOOL
SplGetPrinterDriverEx(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    DWORD   dwClientMajorVersion,
    DWORD   dwClientMinorVersion,
    PDWORD  pdwServerMajorVersion,
    PDWORD  pdwServerMinorVersion
    )
{
    PINIDRIVER          pIniDriver=NULL;
    PINIVERSION         pIniVersion=NULL;
    PINIENVIRONMENT     pIniEnvironment;
    DWORD               cb;
    LPBYTE              pEnd;
    PSPOOL              pSpool = (PSPOOL)hPrinter;
    PINISPOOLER         pIniSpooler;
    LPWSTR              psz;

    if ((dwClientMajorVersion == (DWORD)-1) && (dwClientMinorVersion == (DWORD)-1)) {
        dwClientMajorVersion = dwMajorVersion;
        dwClientMinorVersion = dwMinorVersion;
    }

    EnterSplSem();

    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {

        LeaveSplSem();
        return FALSE;
    }

    pIniSpooler = pSpool->pIniSpooler;

    if (!(pIniEnvironment = FindEnvironment(pEnvironment, pIniSpooler))) {
        LeaveSplSem();
        SetLastError(ERROR_INVALID_ENVIRONMENT);
        return FALSE;
    }

    //
    // if the printer handle is remote or a non-native driver is asked for,
    // then return back a compatible driver; Else return pIniPrinter->pIniDriver
    //
    if ( (pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_CALL) ||
         lstrcmpi(szEnvironment, pIniEnvironment->pName) ) {

        pIniDriver = FindCompatibleDriver(pIniEnvironment,
                                          &pIniVersion,
                                          pSpool->pIniPrinter->pIniDriver->pName,
                                          dwClientMajorVersion,
                                          FIND_COMPATIBLE_VERSION | DRIVER_SEARCH);

        //
        // For Windows 9x drivers if no driver with same name is found
        // then we look for a driver with name in the pszzPreviousNames field
        //
        if ( !pIniDriver                                                &&
             !wcscmp(pIniEnvironment->pName, szWin95Environment)        &&
             (psz = pSpool->pIniPrinter->pIniDriver->pszzPreviousNames) ) {

            for ( ; !pIniDriver && *psz ; psz += wcslen(psz) + 1 )
                pIniDriver = FindCompatibleDriver(pIniEnvironment,
                                                  &pIniVersion,
                                                  psz,
                                                  0,
                                                  FIND_COMPATIBLE_VERSION | DRIVER_SEARCH);

            if ( !pIniDriver && Level == 1 ) {

                //
                // SMB code calls GetPrinterDriver level 1 to findout which
                // driver name to send to Win9x client in GetPrinter info
                // If we do not have Win9x printer driver installed and previous
                // names field is not NULL our best guess is the first one in
                // the pszzPreviousNames. This is expected to be the popular
                // driver on Win9x. If client already has the driver they can
                // print
                //
                psz = pSpool->pIniPrinter->pIniDriver->pszzPreviousNames;
                *pcbNeeded = ( wcslen(psz) + 1 ) * sizeof(WCHAR)
                                                + sizeof(DRIVER_INFO_1);
                if ( *pcbNeeded > cbBuf ) {

                    LeaveSplSem();
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return FALSE;
                }

                ((LPDRIVER_INFO_1)pDriverInfo)->pName
                            = (LPWSTR)(pDriverInfo + sizeof(DRIVER_INFO_1));
                wcscpy(((LPDRIVER_INFO_1)pDriverInfo)->pName, psz);
                LeaveSplSem();
                return TRUE;
            }
        }

        if ( !pIniDriver ) {

            LeaveSplSem();
            return FALSE;
        }
    } else {

        pIniDriver = pSpool->pIniPrinter->pIniDriver;

        pIniVersion = FindVersionForDriver(pIniEnvironment, pIniDriver);
    }

    cb = GetDriverInfoSize( pIniDriver, Level, pIniVersion,pIniEnvironment,
                            pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_CALL ?
                                pSpool->pFullMachineName : NULL,
                            pSpool->pIniSpooler );
    *pcbNeeded=cb;

    if (cb > cbBuf) {
        LeaveSplSem();
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    pEnd = pDriverInfo+cbBuf;
    if (!CopyIniDriverToDriverInfo(pIniEnvironment, pIniVersion, pIniDriver,
                                   Level, pDriverInfo, pEnd,
                                   pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_CALL ?
                                       pSpool->pFullMachineName : NULL,
                                   pIniSpooler)) {
        LeaveSplSem();
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }
    LeaveSplSem();
    return TRUE;
}



PINIVERSION
FindCompatibleVersion(
    PINIENVIRONMENT pIniEnvironment,
    DWORD   dwMajorVersion,
    int     FindAnyVersion
    )
{
    PINIVERSION pIniVersion;

    if (!pIniEnvironment) {
        return NULL;
    }

    for ( pIniVersion = pIniEnvironment->pIniVersion;
          pIniVersion != NULL;
          pIniVersion = pIniVersion->pNext ) {

        if ( (FindAnyVersion & DRIVER_UPGRADE) ?
             (pIniVersion->cMajorVersion >= dwMajorVersion) :
             (pIniVersion->cMajorVersion <= dwMajorVersion))
            {

            //
            // Pre version 2 is not comparable with version 2 or newer
            //
            if ( dwMajorVersion >= 2                                            &&
                 pIniVersion->cMajorVersion < 2                                 &&
                 ((FindAnyVersion & FIND_ANY_VERSION)==FIND_COMPATIBLE_VERSION) &&
                 lstrcmpi(pIniEnvironment->pName, szWin95Environment) ) {

                return NULL;
            }

            return pIniVersion;
        }
    }

    return NULL;
}


PINIDRIVER
FindCompatibleDriver(
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION * ppIniVersion,
    LPWSTR pDriverName,
    DWORD dwMajorVersion,
    int FindAnyDriver
    )
{
    PINIVERSION pIniVersion;
    PINIDRIVER  pIniDriver = NULL;

    try {

        *ppIniVersion = NULL;

        if (!pIniEnvironment) {
            leave;
        }

        pIniVersion = FindCompatibleVersion( pIniEnvironment, dwMajorVersion, FindAnyDriver );

        if ( pIniVersion == NULL) {
            leave;
        }

        while (pIniVersion){

            //
            // Pre version 2 is not comparable with version 2 or newer
            //
            if ( dwMajorVersion >= 2                                              &&
                 ((FindAnyDriver & FIND_ANY_VERSION) == FIND_COMPATIBLE_VERSION)  &&
                 pIniVersion->cMajorVersion < 2 ) {

                break;
            }

            if ( pIniDriver = FindDriverEntry( pIniVersion, pDriverName ) ) {

                *ppIniVersion = pIniVersion;
                leave;  // Success
            }

            pIniVersion = pIniVersion->pNext;
        }

    } finally {

       if ( pIniDriver == NULL ) {

           SetLastError(ERROR_UNKNOWN_PRINTER_DRIVER);
       }
    }

    return pIniDriver;

}


VOID
InsertVersionList(
    PINIVERSION* ppIniVersionHead,
    PINIVERSION pIniVersion
    )

/*++

Routine Description:

    Insert a version entry into the verions linked list.

    Versions are stored in decending order (2, 1, 0) so that
    when a version is needed, we get the highest first.

Arguments:

    ppIniVersionHead - Pointer to the head of the pIniVersion head.

    pIniVersion - Version structure we want to add.

Return Value:

--*/

{
    SplInSem();

    //
    // Insert into single-linked list code.  We take the address of
    // the head pointer so that we can avoid special casing the
    // insert into empty list case.
    //
    for( ; *ppIniVersionHead; ppIniVersionHead = &(*ppIniVersionHead)->pNext ){

        //
        // If the major version of the pIniVersion we're inserting
        // is > the next pIniVersion on the list, insert it before
        // that one.
        //
        // 4 3 2 1
        //    ^
        // New '3' gets inserted here.  (Note: duplicate versions should
        // never be added.)
        //
        if( pIniVersion->cMajorVersion > (*ppIniVersionHead)->cMajorVersion ){
            break;
        }
    }

    //
    // Link up the new version.
    //
    pIniVersion->pNext = *ppIniVersionHead;
    *ppIniVersionHead = pIniVersion;
}



PINIDRIVER
FindDriverEntry(
    PINIVERSION pIniVersion,
    LPWSTR pszName
    )
{
    PINIDRIVER pIniDriver;

    if (!pIniVersion) {
        return NULL;
    }

    if (!pszName || !*pszName) {
        DBGMSG( DBG_WARNING, ("Passing a Null Printer Driver Name to FindDriverEntry\n"));
        return NULL;
    }

    pIniDriver = pIniVersion->pIniDriver;

    //
    // Only return the driver if it is not pending deletion.
    //
    while (pIniDriver) {
        if (!lstrcmpi(pIniDriver->pName, pszName) &&
            !(pIniDriver->dwDriverFlags & PRINTER_DRIVER_PENDING_DELETION)) {
            return pIniDriver;
        }
        pIniDriver = pIniDriver->pNext;
    }
    return NULL;
}


VOID
DeleteDriverEntry(
   PINIVERSION pIniVersion,
   PINIDRIVER pIniDriver
   )
{   PINIDRIVER pPrev, pCurrent;
    if (!pIniVersion) {
        return;
    }

    if (!pIniVersion->pIniDriver) {
        return;
    }
    pPrev = pCurrent = NULL;
    pCurrent = pIniVersion->pIniDriver;

    while (pCurrent) {
        if (pCurrent == pIniDriver) {
            if (pPrev == NULL) {
                pIniVersion->pIniDriver = pCurrent->pNext;
            } else{
                pPrev->pNext = pCurrent->pNext;
            }
            //
            // Free all the entries in the entry
            //
            FreeStructurePointers((LPBYTE) pIniDriver, NULL, IniDriverOffsets);
            FreeSplMem(pIniDriver);
            return;
        }
        pPrev = pCurrent;
        pCurrent = pCurrent->pNext;
    }
    return;
}

BOOL CheckFileCopy(
    PINIVERSION         pIniVersion,
    LPWSTR              pTargetFile,
    LPWSTR              pSourceFile,
    PWIN32_FIND_DATA    pSourceData,
    DWORD               dwSourceVersion,
    DWORD               dwFileCopyFlags,
    LPBOOL              pbCopyFile,
    LPBOOL              pbTargetExists)

/*++
Function Description: This functions determines if the target exists and if it should
                      be overwritten.

Parameters:

Return Values: TRUE if successful; FALSE otherwise.
--*/

{
    WIN32_FIND_DATA DestFileData, SourceFileData, *pSourceFileData;
    HANDLE          hFileExists;
    BOOL            bReturn = FALSE, bSourceFileHandleCreated = FALSE;
    DWORD           dwTargetVersion = 0;

    LeaveSplSem();

    *pbCopyFile = *pbTargetExists = FALSE;

    pSourceFileData = pSourceData ? pSourceData : &SourceFileData;

    // Get Source File Date & Time Stamp
    hFileExists = FindFirstFile( pSourceFile, pSourceFileData );

    if (hFileExists == INVALID_HANDLE_VALUE) {
        goto CleanUp;
    }

    FindClose( hFileExists );

    // Get Target File Date Time
    hFileExists = FindFirstFile( pTargetFile, &DestFileData );

    if (hFileExists == INVALID_HANDLE_VALUE) {

        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            // Copy the source since there is no target
            *pbCopyFile = TRUE;
            bReturn = TRUE;
        }

        goto CleanUp;
    }

    *pbTargetExists = TRUE;
    FindClose(hFileExists);

    //
    //  Check Source File version and LastWrite Times vs Target File if only new files
    //  are to be copied
    //
    if (dwFileCopyFlags == APD_COPY_NEW_FILES) {

        EnterSplSem();
        bReturn = GetDriverFileCachedVersion (pIniVersion, pTargetFile, &dwTargetVersion);
        LeaveSplSem();

        if(!bReturn) {
            goto CleanUp;
        }

        if (dwSourceVersion > dwTargetVersion) {
            *pbCopyFile = TRUE;

        } else {

            if (dwSourceVersion == dwTargetVersion) {

                if(CompareFileTime(&(pSourceFileData->ftLastWriteTime),
                                   &DestFileData.ftLastWriteTime)
                                   != FIRST_FILE_TIME_GREATER_THAN_SECOND) {

                    // Target File is up to date Nothing to do.
                    DBGMSG( DBG_TRACE, ("UpdateFile Target file is up to date\n"));

                } else {
                    *pbCopyFile = TRUE;
                }
            }
        }
    } else {
        *pbCopyFile = TRUE;
    }

    bReturn = TRUE;

CleanUp:

    EnterSplSem();

    return bReturn;
}

BOOL
UpdateFile(
    PINIVERSION pIniVersion,
    HANDLE      hSourceFile,
    LPWSTR      pSourceFile,
    DWORD       dwVersion,
    LPWSTR      pDestDir,
    DWORD       dwFileCopyFlags,
    BOOL        bImpersonateOnCreate,
    LPBOOL      pbFileUpdated,
    LPBOOL      pbFileMoved,
    BOOL        bSameEnvironment,
    BOOL        bWin95Environment
    )

/*++
Function Description: The file times are checked to verify if the file needs to be copied.

                      If the file already exists in the version directory, then it is copied
                      into ...\environment\version\new. The corresponding file, which is
                      present in environment\version, is copied to \version\old. The new file
                      is marked for move on REBOOT.

                      New files are copied into env\version.

Parameters: hSourceFile          --  file handle
            pSourceFile          --  file name
            pDestDir             --  driver directory (e.g system32\spool\w32x86\3)
            bImpersonateOnCreate --  flag to impersonate client on any file creation
            pbFilesUpdated       --  Have any new files been copied or moved ?
            pbFileMoved          --  Have any old files been moved ?
            bSameEnvironment     --  flag to indicate if the machine env == driver env
            bWin95Environment    --  flag to indicate if the driver env == win95

Return Values: TRUE if successful; FALSE otherwise
--*/

{
    HANDLE  hToken = INVALID_HANDLE_VALUE;
    WCHAR   szTargetFile[MAX_PATH], szNewFile[MAX_PATH];
    LPWSTR  pFileName;
    BOOL    bReturn = FALSE, bCopyFile, bTargetExists;
    DWORD   FileAttrib;

    WIN32_FIND_DATA SourceFileData;

    *pbFileMoved = FALSE;

    pFileName = wcsrchr(pSourceFile, L'\\');
    if (!pFileName || !pDestDir || !*pDestDir) {
        // Wrong file name
        SetLastError(ERROR_INVALID_PARAMETER);
        goto CleanUp;
    }

    // Set the target directory
    if(StrNCatBuff(szTargetFile,
                   COUNTOF(szTargetFile),
                   pDestDir,
                   NULL) != ERROR_SUCCESS)
    {
         goto CleanUp;
    }

    if (bWin95Environment && IsAnICMFile(pSourceFile)) {
        if((StrNCatBuff(szTargetFile,
                       COUNTOF(szTargetFile),
                       szTargetFile,
                       L"\\Color",
                       NULL)!=ERROR_SUCCESS))
        {
             goto CleanUp;
        }
    }

    if((StrNCatBuff(szTargetFile,
                   COUNTOF(szTargetFile),
                   szTargetFile,
                   pFileName,
                   NULL)!=ERROR_SUCCESS))
    {
         goto CleanUp;
    }

    // Check if the file has to be copied
    if (!CheckFileCopy(pIniVersion, szTargetFile, pSourceFile, &SourceFileData, dwVersion,
                       dwFileCopyFlags, &bCopyFile, &bTargetExists)) {
        goto CleanUp;
    }

    if (bCopyFile) {

        if (!bImpersonateOnCreate) {
            hToken = RevertToPrinterSelf();
        }

        if((StrNCatBuff(szNewFile,
                        COUNTOF(szNewFile),
                        pDestDir,
                        L"\\New",
                        pFileName,
                        NULL)!=ERROR_SUCCESS))
        {
           goto CleanUp;
        }

        // Leave semaphore for copying the files
        LeaveSplSem();

        if (!InternalCopyFile(hSourceFile, &SourceFileData,
                              szNewFile, OVERWRITE_IF_TARGET_EXISTS)) {

            // InternalCopyFile failed
            EnterSplSem();
            goto CleanUp;
        }

        EnterSplSem();

    } else {

        *pbFileMoved = TRUE;
        bReturn = TRUE;
        goto CleanUp;
    }

    if (bCopyFile) {

        if (!bSameEnvironment) {

            if (bTargetExists) {

                DWORD dwAttr;

                dwAttr = GetFileAttributes(szTargetFile);

                //
                // Check if the function succeeded and the target file is write protected.
                // Some non native drivers, notably Win 9x drivers, can be copied over to
                // the drivers directory and have the read only attribute. When we update
                // a non native driver, we want to make sure that it is not write protected.
                //
                if (dwAttr != (DWORD)-1 &&
                    dwAttr & FILE_ATTRIBUTE_READONLY) {

                    SetFileAttributes(szTargetFile, dwAttr & ~FILE_ATTRIBUTE_READONLY);
                }
            }

            if (!SplMoveFileEx(szNewFile, szTargetFile, MOVEFILE_REPLACE_EXISTING)) {
                // MoveFile failed
                goto CleanUp;
            }

        } else {

            if (bTargetExists) {

                // Move the file on REBOOT. It may get moved earlier if the driver
                // can be unloaded.
                if (SplMoveFileEx(szNewFile, szTargetFile, MOVEFILE_DELAY_UNTIL_REBOOT)) {

                    *pbFileMoved = TRUE;
                    //
                    // Don't fail the call here. MoveFileEx with MOVEFILE_DELAY_UNTIL_REBOOT will just write the registry.
                    // We'll need this only if the driver is still loaded, which we find out only later.
                    // If the driver is not loaded, we'll actually move these files later and this call won't make sense.
                    // So,don't fail the api call at this point because MoveFileEx. Hopefully, one day MoveFileEx won't
                    // be hard-coded to write only two PendingFileRenameOperations values.
                    //
                }

            } else {

                if (!SplMoveFileEx(szNewFile, szTargetFile, MOVEFILE_REPLACE_EXISTING)) {
                    // MoveFile failed
                    goto CleanUp;
                }
                *pbFileMoved = TRUE;
            }
        }

        *pbFileUpdated = TRUE;
    }

    bReturn = TRUE;

CleanUp:

    if (hToken != INVALID_HANDLE_VALUE) {
        ImpersonatePrinterClient(hToken);
    }

    return bReturn;
}


BOOL
CopyAllFilesAndDeleteOldOnes(
    PINIVERSION         pIniVersion,
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount,
    LPWSTR              pDestDir,
    DWORD               dwFileCopyFlags,
    BOOL                bImpersonateOnCreate,
    LPBOOL              pbFileMoved,
    BOOL                bSameEnvironment,
    BOOL                bWin95Environment
    )
/*++

Function Description: This function loops thru all the files in the driver_info
                      struct and calls an update routine.

Parameters: pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
            dwFileCount          -- number of files in file set
            pDestDir             --  driver directory (e.g system32\spool\w32x86\3)
            bImpersonateOnCreate --  flag to impersonate client on any file creation
            pbFileMoved          --  Have any old files been moved ?
            bSameEnvironment     --  flag to indicate if the machine env == driver env
            bWin95Environment    --  flag to indicate if the driver env == win95

Return Values: TRUE if successful; FALSE otherwise

--*/
{
    BOOL        bRet = TRUE;
    DWORD       dwCount;
    BOOL        bFilesUpdated;
    BOOL        bFilesMoved = TRUE;

    *pbFileMoved = TRUE;

    for (dwCount = 0 ; dwCount < dwFileCount ; ++dwCount) {

        bFilesUpdated = FALSE;

        if (!(bRet = UpdateFile(pIniVersion,
                                pInternalDriverFiles[dwCount].hFileHandle,
                                pInternalDriverFiles[dwCount].pFileName,
                                pInternalDriverFiles[dwCount].dwVersion,
                                pDestDir,
                                dwFileCopyFlags,
                                bImpersonateOnCreate,
                                &bFilesUpdated,
                                &bFilesMoved,
                                bSameEnvironment,
                                bWin95Environment))) {

            // Files could not be copied correctly
            break;
        }

        if (bFilesUpdated) {
            pInternalDriverFiles[dwCount].bUpdated = TRUE;
        }

        if(!bFilesMoved) {
            *pbFileMoved = FALSE;
        }
    }

    return bRet;
}


BOOL
CopyFilesToFinalDirectory(
    PINISPOOLER         pIniSpooler,
    PINIENVIRONMENT     pIniEnvironment,
    PINIVERSION         pIniVersion,
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount,
    DWORD               dwFileCopyFlags,
    BOOL                bImpersonateOnCreate,
    LPBOOL              pbFilesMoved
    )

/*++

Function Description: This function copies all the new files into the the correct
                      directory i.e ...\environment\version.

                      The files which already exist in the version directory are copied
                      in ...\environment\version\new. The corresponding files, which are
                      present in environment\version, are copied to \version\old.

                      The common files are upgraded when the old files can be unloaded
                      from either the kernel (for KMPD) or the spooler (for UMPD)

Parameters: pIniSpooler          --  pointer to the INISPOOLER struct
            pIniEnvironment      --  pointer to the driver environment struct
            pIniVersion          --  pointer to the driver version struct
            pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
            dwFileCount          -- number of files in file setes
            dwFileCount          --  number of files
            bImpersonateOnCreate --  flag to impersonate client on any file creation
            pbFileMoved          --  Have any old files been moved ?

Return Values: TRUE if successful; FALSE otherwise

--*/

{
    WCHAR   szDestDir[INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1];
    LPWSTR  pStringEnd = NULL;
    DWORD   dwIndex;
    BOOL    bRet = FALSE, bSameEnvironment, bWin95Environment;

    //
    // Initialize szDestDir to an empty string. This is to due a bogus prefix
    // bug. In practice GetEnvironment scratch directory cannot fail under
    // these conditions.
    //
    szDestDir[0] = L'\0';

    SplInSem();

    GetEnvironmentScratchDirectory( szDestDir, MAX_PATH, pIniEnvironment, FALSE );
    wcscat( szDestDir, L"\\" );
    wcscat( szDestDir, pIniVersion->szDirectory );

    // pStringEnd points to the NULL character in szDestDir
    pStringEnd = (LPWSTR) szDestDir + wcslen(szDestDir);

    bSameEnvironment = !lstrcmpi(pIniEnvironment->pName, szEnvironment);

    // Create the Old directory
    wcscat(szDestDir, L"\\Old");
    if (!DirectoryExists(szDestDir) &&
        !CreateDirectoryWithoutImpersonatingUser(szDestDir)) {

         // Failed to create Old directory
         goto CleanUp;
    }
    *pStringEnd = L'\0';

    // Create the New Directory
    wcscat(szDestDir, L"\\New");
    if (!DirectoryExists(szDestDir) &&
        !CreateDirectoryWithoutImpersonatingUser(szDestDir)) {

         // Failed to create New directory
         goto CleanUp;
    }
    *pStringEnd = L'\0';

    // Create the Color Directory if necessary
    if (!wcscmp(pIniEnvironment->pName, szWin95Environment)) {

        for (dwIndex = 0 ; dwIndex < dwFileCount ; ++dwIndex) {

            // Search for ICM files that need the Color directory
            if (IsAnICMFile(pInternalDriverFiles[dwIndex].pFileName)) {

                // Create the Color Directory
                wcscat(szDestDir, L"\\Color");
                if (!DirectoryExists(szDestDir) &&
                    !CreateDirectoryWithoutImpersonatingUser(szDestDir)) {

                     // Failed to create Color directory
                     goto CleanUp;
                }
                *pStringEnd = L'\0';

                break;
            }
        }

        bWin95Environment = TRUE;

    } else {

        bWin95Environment = FALSE;
    }

    DBGMSG(DBG_CLUSTER, ("CopyFilesToFinalDirectory szDestDir "TSTR"\n", szDestDir));

    bRet = CopyAllFilesAndDeleteOldOnes(pIniVersion,
                                        pInternalDriverFiles,
                                        dwFileCount,
                                        szDestDir,
                                        dwFileCopyFlags,
                                        bImpersonateOnCreate,
                                        pbFilesMoved,
                                        bSameEnvironment,
                                        bWin95Environment);

CleanUp:

    if (!bRet) {
        SPLASSERT( GetLastError() != ERROR_SUCCESS );
    }

    return bRet;
}


DWORD
GetDriverVersionDirectory(
    LPWSTR pDir,
    DWORD  MaxLength,
    PINISPOOLER pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER  pIniDriver,
    LPWSTR lpRemote
    )
{
    WCHAR  pTempDir[MAX_PATH];

    if (lpRemote) {

        if( StrNCatBuff(pDir,
                        MaxLength,
                        lpRemote,
                        L"\\",
                        pIniSpooler->pszDriversShare,
                        L"\\",
                        pIniEnvironment->pDirectory,
                        L"\\",
                        pIniVersion->szDirectory,
                        NULL) != ERROR_SUCCESS ) {
            return 0;
        }

    } else {

        if( StrNCatBuff(pDir,
                        MaxLength,
                        pIniSpooler->pDir,
                        L"\\",
                        szDriverDir,
                        L"\\",
                        pIniEnvironment->pDirectory,
                        L"\\",
                        pIniVersion->szDirectory,
                        NULL) != ERROR_SUCCESS ) {
            return 0;
        }

    }

    if (pIniDriver && pIniDriver->dwTempDir) {

        wsprintf(pTempDir, L"%d", pIniDriver->dwTempDir);

        if( StrNCatBuff(pDir,
                        MaxLength,
                        pDir,
                        L"\\",
                        pTempDir,
                        NULL) != ERROR_SUCCESS ) {
            return 0;
        }
    }

    return wcslen(pDir);
}



PINIVERSION
FindVersionForDriver(
    PINIENVIRONMENT pIniEnvironment,
    PINIDRIVER pIniDriver
    )
{
    PINIVERSION pIniVersion;
    PINIDRIVER pIniVerDriver;

    pIniVersion = pIniEnvironment->pIniVersion;

    while (pIniVersion) {

        pIniVerDriver = pIniVersion->pIniDriver;

        while (pIniVerDriver) {

            if ( pIniVerDriver == pIniDriver ) {

                return pIniVersion;
            }
            pIniVerDriver = pIniVerDriver->pNext;
        }
        pIniVersion = pIniVersion->pNext;
    }
    return NULL;
}



LPWSTR
GetFileNameInScratchDir(
    LPWSTR          pPathName,
    PINIENVIRONMENT pIniEnvironment
)
{
    WCHAR   szDir[INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1];
    LPCWSTR pszFileName;
    LPWSTR  pszReturn = NULL;

    //
    // Initialize the szDir to a known string value. This was a bogus prefix bug,
    // but, it is probably a good idea anyway.
    //
    szDir[0] = L'\0';

    if ((pszFileName = FindFileName(pPathName)) &&
        wcslen(pszFileName) < MAX_PATH          &&
        GetEnvironmentScratchDirectory(szDir, (DWORD)(COUNTOF(szDir) - wcslen(pszFileName) - 2), pIniEnvironment, FALSE))
    {
       wcscat(szDir, L"\\");
       wcscat(szDir, pszFileName);

       pszReturn = AllocSplStr(szDir);
    }

    return pszReturn;
}


BOOL
CreateInternalDriverFileArray(
    DWORD               Level,
    LPBYTE              pDriverInfo,
    INTERNAL_DRV_FILE **ppInternalDriverFiles,
    LPDWORD             pFileCount,
    BOOL                bUseScratchDir,
    PINIENVIRONMENT     pIniEnvironment,
    BOOL                bFileNamesOnly
    )
/*++

Routine Description:

    Creates the array of INTERNAL_DRV_FILE structures.
    For each file in file set, we build an array with information
    about the file: file name, driver minor version, file handle,
    if the file was updated.
    The field regrading updating is initialized to FALSE and modified later.

Arguments:

    Level                   : level of driver info structure
    pDriverInfo             : pointer to driver info structure
    pInternalDriverFiles    : allocate memory to this array for list of file names
    pFileCount              : will point to number of files on return
    bUseScratchDir          : Should a scratch directory be used for file names
    pIniEnvironment         : environment the version belongs to

Return Value:
    TRUE  =  success
        *ppInternalDriverFiles will (routine allocates memory) give
        the internal list of files
        *pFileCount will give number of files specified by the driver info
    FALSE =  failure, call GetLastError()

History:
    Written by MuhuntS (Muhunthan Sivapragasam) June 95

--*/
{
    LPWSTR  pStr;
    DWORD   dDepFileCount = 0, dFirstDepFileIndex, Count, Size;
    BOOL    bReturnValue = TRUE, bInSplSem = TRUE;
    PDRIVER_INFO_2 pDriverInfo2 = NULL;
    PDRIVER_INFO_3 pDriverInfo3 = NULL;
    PDRIVER_INFO_VERSION pDriverVersion = NULL;
    LPWSTR  pDependentFiles = NULL, pDependentFilestoFree = NULL;
    LPWSTR  pFileName = NULL;

    SplInSem();

    if ( !ppInternalDriverFiles || !pFileCount) {
        bReturnValue = FALSE;
        SetLastError(ERROR_INVALID_DATA);
        goto End;
    }

    *pFileCount = 0;
    *ppInternalDriverFiles = NULL;

    switch (Level) {
        case 2:
                *pFileCount = 3;
                pDriverInfo2 = (PDRIVER_INFO_2) pDriverInfo;
                break;

        case 3:
        case 4:
        case 6:
                *pFileCount = 3;
                dFirstDepFileIndex = 3;
                pDriverInfo3 = (PDRIVER_INFO_3) pDriverInfo;

                //
                // For any environment other than Win95 we build dependent files
                // without other DRIVER_INFO_3 files (i.e. ConfigFile etc)
                //
                if ( _wcsicmp(pIniEnvironment->pName, szWin95Environment) ) {

                    if ( !BuildTrueDependentFileField(pDriverInfo3->pDriverPath,
                                                      pDriverInfo3->pDataFile,
                                                      pDriverInfo3->pConfigFile,
                                                      pDriverInfo3->pHelpFile,
                                                      pDriverInfo3->pDependentFiles,
                                                      &pDependentFiles) ) {
                         bReturnValue = FALSE;
                         SetLastError(ERROR_INVALID_DATA);
                         pDependentFilestoFree = NULL;
                         goto End;
                    }
                    pDependentFilestoFree = pDependentFiles;

                } else {

                    pDependentFiles = pDriverInfo3->pDependentFiles;
                }

                if ( pDriverInfo3->pHelpFile && *pDriverInfo3->pHelpFile ) {

                    if(wcslen(pDriverInfo3->pHelpFile) >= MAX_PATH) {
                        bReturnValue = FALSE;
                        SetLastError(ERROR_INVALID_DATA);
                        *pFileCount = 0;
                        goto End;
                    }
                    ++*pFileCount;
                    ++dFirstDepFileIndex;
                }

                for ( dDepFileCount = 0, pStr = pDependentFiles ;
                      pStr && *pStr ;
                      pStr += wcslen(pStr) + 1) {

                        if(wcslen(pStr) >= MAX_PATH) {
                            bReturnValue = FALSE;
                            SetLastError(ERROR_INVALID_DATA);
                            *pFileCount = 0;
                            goto End;
                        }
                        ++dDepFileCount;
                      }

                *pFileCount += dDepFileCount;
                break;

        case DRIVER_INFO_VERSION_LEVEL:

                pDriverVersion = (LPDRIVER_INFO_VERSION)pDriverInfo;
                *pFileCount = pDriverVersion->dwFileCount;

                break;
        default:
                bReturnValue = FALSE;
                SetLastError(ERROR_INVALID_DATA);
                goto End;
                break;

    }

    try {
        *ppInternalDriverFiles = (INTERNAL_DRV_FILE *) AllocSplMem(*pFileCount * sizeof(INTERNAL_DRV_FILE));

        if ( !*ppInternalDriverFiles ) {
            bReturnValue = FALSE;
            leave;
        }

        for ( Count = 0; Count < *pFileCount; Count++ ) {
            (*ppInternalDriverFiles)[Count].pFileName = NULL;
            (*ppInternalDriverFiles)[Count].hFileHandle = INVALID_HANDLE_VALUE;
            (*ppInternalDriverFiles)[Count].dwVersion = 0;
            (*ppInternalDriverFiles)[Count].bUpdated = FALSE;
        }

        switch (Level) {
            case 2:
                if ( bUseScratchDir ) {
                   (*ppInternalDriverFiles)[0].pFileName = GetFileNameInScratchDir(
                                                                pDriverInfo2->pDriverPath,
                                                                pIniEnvironment);
                   (*ppInternalDriverFiles)[1].pFileName = GetFileNameInScratchDir(
                                                                pDriverInfo2->pConfigFile,
                                                                pIniEnvironment);
                   (*ppInternalDriverFiles)[2].pFileName = GetFileNameInScratchDir(
                                                                pDriverInfo2->pDataFile,
                                                                pIniEnvironment);
                } else {
                   (*ppInternalDriverFiles)[0].pFileName = AllocSplStr(pDriverInfo2->pDriverPath);
                   (*ppInternalDriverFiles)[1].pFileName = AllocSplStr(pDriverInfo2->pConfigFile);
                   (*ppInternalDriverFiles)[2].pFileName = AllocSplStr(pDriverInfo2->pDataFile);
                }

                break;

            case 3:
            case 4:
            case 5:
            case 6:
                if ( bUseScratchDir ) {
                   (*ppInternalDriverFiles)[0].pFileName = GetFileNameInScratchDir(
                                                                pDriverInfo3->pDriverPath,
                                                                pIniEnvironment);
                   (*ppInternalDriverFiles)[1].pFileName = GetFileNameInScratchDir(
                                                                pDriverInfo3->pConfigFile,
                                                                pIniEnvironment);
                   (*ppInternalDriverFiles)[2].pFileName = GetFileNameInScratchDir(
                                                                pDriverInfo3->pDataFile,
                                                                pIniEnvironment);

                    if ( pDriverInfo3->pHelpFile && *pDriverInfo3->pHelpFile ) {
                        (*ppInternalDriverFiles)[3].pFileName = GetFileNameInScratchDir(
                                                                    pDriverInfo3->pHelpFile,
                                                                    pIniEnvironment);
                    }
                } else {
                   (*ppInternalDriverFiles)[0].pFileName = AllocSplStr(pDriverInfo3->pDriverPath);
                   (*ppInternalDriverFiles)[1].pFileName = AllocSplStr(pDriverInfo3->pConfigFile);
                   (*ppInternalDriverFiles)[2].pFileName = AllocSplStr(pDriverInfo3->pDataFile);

                   if ( pDriverInfo3->pHelpFile && *pDriverInfo3->pHelpFile ) {
                        (*ppInternalDriverFiles)[3].pFileName = AllocSplStr(pDriverInfo3->pHelpFile);
                    }
                }

                if ( dDepFileCount ) {
                    for (pStr = pDependentFiles, Count = dFirstDepFileIndex;
                         *pStr ; pStr += wcslen(pStr) + 1) {

                        if ( bUseScratchDir ) {
                            (*ppInternalDriverFiles)[Count++].pFileName = GetFileNameInScratchDir(
                                                                           pStr,
                                                                           pIniEnvironment);
                        }
                        else {
                            (*ppInternalDriverFiles)[Count++].pFileName = AllocSplStr(pStr);
                        }
                    }
                }

                break;

            case DRIVER_INFO_VERSION_LEVEL:

                for ( Count = 0 ; Count < *pFileCount ; Count++ ) {

                    pFileName = MakePTR(pDriverVersion, pDriverVersion->pFileInfo[Count].FileNameOffset);

                    if ( bUseScratchDir ) {
                        (*ppInternalDriverFiles)[Count].pFileName = GetFileNameInScratchDir(
                                                                    pFileName,
                                                                    pIniEnvironment);
                    } else {
                        (*ppInternalDriverFiles)[Count].pFileName = AllocSplStr(pFileName);
                    }
                }

                break;
        }

        for ( Count = 0 ; Count < *pFileCount ; ) {
            if ( !(*ppInternalDriverFiles)[Count++].pFileName ) {
                DBGMSG( DBG_WARNING,
                        ("CreateInternalDriverFileArray failed to allocate memory %d\n",
                        GetLastError()) );
                bReturnValue = FALSE;
                leave;
            }
        }

        if (bFileNamesOnly) {
            leave;
        }
        //
        // CreateFile may take a long time, if we are trying to copy files
        // from a server and server crashed we want a deadlock to be
        // detected during stress.
        //

        pIniEnvironment->cRef++;
        LeaveSplSem();
        SplOutSem();
        bInSplSem = FALSE;
        for ( Count = 0 ; Count < *pFileCount ; ++Count ) {

            (*ppInternalDriverFiles)[Count].hFileHandle = CreateFile((*ppInternalDriverFiles)[Count].pFileName,
                                                                      GENERIC_READ,
                                                                      FILE_SHARE_READ,
                                                                      NULL,
                                                                      OPEN_EXISTING,
                                                                      FILE_FLAG_SEQUENTIAL_SCAN,
                                                                      NULL);

            if ( (*ppInternalDriverFiles)[Count].hFileHandle == INVALID_HANDLE_VALUE ) {
                DBGMSG( DBG_WARNING,
                        ("CreateFileNames failed to Open %ws %d\n",
                        (*ppInternalDriverFiles)[Count].pFileName, GetLastError()) );
                bReturnValue = FALSE;
                leave;
            }
        }


        //
        // Build the array of file versions.
        // Stay out of Spooler CS since we might do a LoadLibrary over the network.
        //
        if (Level == DRIVER_INFO_VERSION_LEVEL) {
            bReturnValue = GetDriverFileVersions((DRIVER_INFO_VERSION*)pDriverInfo,
                                                 *ppInternalDriverFiles,
                                                 *pFileCount);

        } else {
            bReturnValue = GetDriverFileVersionsFromNames(*ppInternalDriverFiles,
                                                          *pFileCount);
        }

    } finally {

        if (!bReturnValue) {

            CleanupInternalDriverInfo(*ppInternalDriverFiles, *pFileCount);

            *pFileCount = 0;
            *ppInternalDriverFiles  = NULL;
        }
    }

    FreeSplMem(pDependentFilestoFree);

End:

    if ( !bInSplSem ) {

        SplOutSem();
        EnterSplSem();
        SPLASSERT(pIniEnvironment->signature == IE_SIGNATURE);
        pIniEnvironment->cRef--;
    }

    return bReturnValue;
}


DWORD
CopyFileToClusterDirectory (
    IN  PINISPOOLER         pIniSpooler,
    IN  PINIENVIRONMENT     pIniEnvironment,
    IN  PINIVERSION         pIniVersion,
    IN  PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN  DWORD               FileCount
    )
/*++

Routine Name:

    CopyFileToClusterDirectory

Routine Description:

    Copy the updated driver files on the cluster disk

Arguments:

    pIniSpooler     -   Spooler
    pIniEnvironment -   Environment
    pIniVersion     -   Version
    pInternalDriverFiles - pointer to array of INTERNAL_DRV_FILE
    FileCount           - number of elemnts in array

Return Value:

    Last error

--*/
{
    DWORD uIndex;

    DWORD   LastError = ERROR_SUCCESS;

    for (uIndex = 0;
         uIndex < FileCount && LastError == ERROR_SUCCESS;
         uIndex++)
    {
        //
        // If the file was updated, it needs to go onto the cluster disk
        //
        if (pInternalDriverFiles[uIndex].bUpdated)
        {
            WCHAR szDir[MAX_PATH] = {0};

            if ((LastError = StrNCatBuff(szDir,
                                         MAX_PATH,
                                         pIniSpooler->pszClusResDriveLetter,
                                         L"\\",
                                         szClusterDriverRoot,
                                         NULL)) == ERROR_SUCCESS)
            {
                //
                // Let's assume foo is an x86 version 3 driver and k: is the
                // cluster drive letter. The file foo.dll will be copied to the
                // K:\PrinterDrivers\W32x86\3\foo.dll. If foo.icm is an ICM file
                // installed with a 9x driver, then it will be copied to
                // K:\PrinterDrivers\WIN40\0\foo.icm. This is the design. We keep
                // 9x ICM files in the Color subdirectory.
                //
                LastError = CopyFileToDirectory(pInternalDriverFiles[uIndex].pFileName,
                                                szDir,
                                                pIniEnvironment->pDirectory,
                                                pIniVersion->szDirectory,
                                                IsAnICMFile(pInternalDriverFiles[uIndex].pFileName) &&
                                                !_wcsicmp(pIniEnvironment->pName, szWin95Environment) ? L"Color" : NULL);
            }
        }
    }

    return LastError;
}

/*++

Routine Name

    LocalStartSystemRestorePoint

Routine Description:

    This starts a system restore point, if we are on the right sku (PER or PRO).
    
Arguments:

    pszDriverName   -   The name of the driver to install.
    phRestorePoint  -   The restore point handle to be used in EndSystemRestorePoint.

Return Value:

    TRUE    -   The system restore point was set, or it didn't have to be set.
    FALSE   -   An error occurred, Last Error is set.
    
--*/
BOOL
LocalStartSystemRestorePoint(
    IN      PCWSTR      pszDriverName,
        OUT HANDLE      *phRestorePoint
    )
{
#ifndef _WIN64

    BOOL            bRet                = FALSE;
    OSVERSIONINFOEX osvi                = { 0 };
    HANDLE          hRestorePoint       = NULL;
    DWORDLONG       dwlConditionMask    = 0;
    
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    osvi.wProductType = VER_NT_WORKSTATION;
    VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_LESS_EQUAL);

    //
    // We only do checkpointing on server and we don't do it for remote 
    // admin cases. We are invoked during upgrade before the SR client
    // is installed, since it doesn't make sense to put in a restore
    // point here anyway, also fail the call.
    // 
    if (!dwUpgradeFlag  &&
        VerifyVersionInfo( &osvi,
                           VER_PRODUCT_TYPE,
                           dwlConditionMask) &&
        IsLocalCall()) 
    {
                       
        hRestorePoint = StartSystemRestorePoint( NULL,
                                                 pszDriverName,
                                                    hInst,
                                                    IDS_DRIVER_CHECKPOINT);

        bRet = hRestorePoint != NULL;    
    }    
    else
    {
        //
        // On SRV skus, we don't set system restore points, but that is OK.
        // 
        bRet = TRUE;
    }

    *phRestorePoint = hRestorePoint;

    return bRet;

#else

    *phRestorePoint = NULL;
    return TRUE;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\drvupgrd.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    drvupgrd.c

Abstract:

    When the system is upgraded from one release to another printer drivers
    (e.g. RASDD ) wants to upgrade is PrinterDriverData to match the new mini driver.

    Setup from NT 4.0 on do this by calling EnumPrinterDriver and then AddPrinterDriver
    for each printer driver that we have installed.

    We call DrvUpgrade each time a printer driver is upgraded.

    For Example, pre NT 3.51 RASDD used to store its regstiry PrinterDriverData
    based on internal indexes into the mini drivers, which was not valid beween
    different updates of the mini driver, so before 3.51 it was by luck if there
    were problems in retriving the settings.   With 3.51 RASDD will convert these
    indexes back to meaningful key names ( like Memory ) so hopefully in future
    we don't have an upgrade problem.

    Note also that other than upgrade time ( which happens once ) DrvUpgrade needs to
    be called on Point and Print whenever a Driver file gets updated.  See Driver.C
    for details.   Or anyone updates a printer driver by calling AddPrinterDriver.

Author:

    Matthew A Felton ( MattFe ) March 11 1995

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

#include "clusspl.h"
#include <winddiui.h>


BOOL
UpdateUpgradeInfoStruct(
    LPBYTE pDriverUpgradeInfo, 
    DWORD  dwLevel,
    LPWSTR pPrinterNameWithToken, 
    LPWSTR pOldDriverDir,
    LPBYTE pDriverInfo
)

/*++
Function Description: This function fills in the Upgrade_Info struct with the
                      other parameters
                      
Parameters: pDriverUpgradeInfo    -- pointer Upgrade_Info_* struct
            dwLevel               -- Upgrade_Info level
            pPrinterNameWithToken -- printer name
            pOldDriverDir         -- Directory containing the old driver files
            pDriverInfo           -- pointer to driver_info_4 struct                  

Return Values: TRUE for sucesss;
               FALSE otherwise
--*/

{
    BOOL  bReturn = TRUE;

    PDRIVER_UPGRADE_INFO_1 pDrvUpgInfo1;
    PDRIVER_UPGRADE_INFO_2 pDrvUpgInfo2;
    PDRIVER_INFO_4         pDriver4;

    switch (dwLevel) {
    case 1:

        pDrvUpgInfo1 = (PDRIVER_UPGRADE_INFO_1) pDriverUpgradeInfo;
  
        pDrvUpgInfo1->pPrinterName = pPrinterNameWithToken;
        pDrvUpgInfo1->pOldDriverDirectory = pOldDriverDir;

        break;

    case 2:
    
        if (pDriver4 = (PDRIVER_INFO_4) pDriverInfo) {

            pDrvUpgInfo2 = (PDRIVER_UPGRADE_INFO_2) pDriverUpgradeInfo;
    
            pDrvUpgInfo2->pPrinterName = pPrinterNameWithToken;
            pDrvUpgInfo2->pOldDriverDirectory = pOldDriverDir;
            pDrvUpgInfo2->cVersion = pDriver4->cVersion;
            pDrvUpgInfo2->pName = pDriver4->pName;
            pDrvUpgInfo2->pEnvironment = pDriver4->pEnvironment;
            pDrvUpgInfo2->pDriverPath = pDriver4->pDriverPath;
            pDrvUpgInfo2->pDataFile = pDriver4->pDataFile;
            pDrvUpgInfo2->pConfigFile = pDriver4->pConfigFile;
            pDrvUpgInfo2->pHelpFile = pDriver4->pHelpFile;
            pDrvUpgInfo2->pDependentFiles = pDriver4->pDependentFiles;
            pDrvUpgInfo2->pMonitorName = pDriver4->pMonitorName;
            pDrvUpgInfo2->pDefaultDataType = pDriver4->pDefaultDataType;
            pDrvUpgInfo2->pszzPreviousNames = pDriver4->pszzPreviousNames;

        } else {
           
            bReturn = FALSE;
        }

        break;

    default:
        
        bReturn = FALSE;
        break;
    }

    return bReturn;
}

BOOL
bIsNewFile(
    LPWSTR              pDriverFile, 
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount
)
/*++
Function Description: This function checks to see if a driver file was updated
                      
Parameters: pDriverFile         -- driver file
            pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
            dwFileCount         -- number of files in file set

Return Values: TRUE for sucesss;
               FALSE otherwise
--*/
{
    DWORD   dwIndex;
    LPCWSTR psz;
    BOOL    bRet = FALSE;
    //
    // Must have some files.
    //
    SPLASSERT( dwFileCount );

    //
    // Search for pDriverFile in  ppFileNames array
    //
    for ( dwIndex = 0; dwIndex < dwFileCount ; ++dwIndex ) {

        if( pInternalDriverFiles[dwIndex].pFileName ) {
            
            //
            // Find the filename portion of a path
            //
            psz = FindFileName(pInternalDriverFiles[dwIndex].pFileName );

            if( psz ){

                if( !lstrcmpi(pDriverFile, psz) ){

                    //
                    // Check if the file was updated
                    //
                    bRet = pInternalDriverFiles[dwIndex].bUpdated;                    
                    break;
                }
            
            }
        }
    }

    return bRet;
    
}

BOOL 
DriversShareFiles(
    PINIDRIVER          pIniDriver1,
    PINIDRIVER          pIniDriver2,
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount
)
/*++
Function Description: Determines if the drivers have common files and
                      if the common files were updated

Parameters:  pIniDriver1         -- driver #1
             pIniDriver2         -- driver #2
             pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
             dwFileCount         -- number of files in file set
             pUpdateStatusBitMap -- map of bits that tells what files in the file set were actually updated    
             
Return Values: TRUE if files are shared;
               FALSE otherwise       
--*/
{
    LPWSTR  pStr1, pStr2;

    if (!pIniDriver1 || !pIniDriver2) {
        return FALSE;
    }
    
    if (pIniDriver1->cVersion != pIniDriver2->cVersion) {
        return FALSE;
    }

    //
    // Compare the file names and if they were updated
    //

    if (pIniDriver1->pDriverFile && pIniDriver2->pDriverFile &&
        !lstrcmpi(pIniDriver1->pDriverFile, pIniDriver2->pDriverFile) &&
        bIsNewFile(pIniDriver1->pDriverFile, pInternalDriverFiles, dwFileCount)) {

        return TRUE;
    }

    if (pIniDriver1->pConfigFile && pIniDriver2->pConfigFile &&
        !lstrcmpi(pIniDriver1->pConfigFile, pIniDriver2->pConfigFile) &&
        bIsNewFile(pIniDriver1->pConfigFile, pInternalDriverFiles, dwFileCount)) {

        return TRUE;
    }

    if (pIniDriver1->pHelpFile && pIniDriver2->pHelpFile &&
        !lstrcmpi(pIniDriver1->pHelpFile, pIniDriver2->pHelpFile) &&
        bIsNewFile(pIniDriver1->pHelpFile, pInternalDriverFiles, dwFileCount)) {

        return TRUE;
    }

    if (pIniDriver1->pDataFile && pIniDriver2->pDataFile &&
        !lstrcmpi(pIniDriver1->pDataFile, pIniDriver2->pDataFile) &&
        bIsNewFile(pIniDriver1->pDataFile, pInternalDriverFiles, dwFileCount)) {

        return TRUE;
    }

    // Compare each pair of files from the Dependent file list
    for (pStr1 = pIniDriver1->pDependentFiles;
         pStr1 && *pStr1;
         pStr1 += wcslen(pStr1) + 1) {
       
        for (pStr2 = pIniDriver2->pDependentFiles;
             pStr2 && *pStr2;
             pStr2 += wcslen(pStr2) + 1) {

            if (!lstrcmpi(pStr1, pStr2) &&
                bIsNewFile(pStr1, pInternalDriverFiles, dwFileCount)) {
                return TRUE;
            }
        }
    }

    return FALSE;
}


BOOL
ForEachPrinterCallDriverDrvUpgrade(
    PINISPOOLER         pIniSpooler,
    PINIDRIVER          pIniDriver,
    LPCWSTR             pOldDriverDir,
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount,
    LPBYTE              pDriverInfo 
)
/*++

Routine Description:

    This routine is called at Spooler Initialization time if an upgrade is detected.

    It will loop through all printers and then call the Printer Drivers DrvUpgrade
    entry point giving it a chance to upgrade any configuration data ( PrinterDriverData )
    passing them a pointer to the old Drivers Directory.

    This routine also converts devmode to current version by calling the driver.
    If driver does not support devmode conversion we will NULL the devmode so
    that we do not have devmodes of different version in the system.

    SECURITY NOTE - This routine Stops impersonation, because the printer drivers UI dll
    needs to call SetPrinterData even if the user doesn't have permission to do it.
    That is because the driver upgrading the settings.


Arguments:

    pIniSpooler - Pointer to Spooler
    pIniVersion - Pointer to the version of driver added
    pOldDriverDir - Point to Directory where old driver files are stored.
    pInternalDriverFiles - array of INTERNAL_DRV_FILE structures
    dwFileCount - number of files in array
    pUpdateStatusBitMap - map of bits that tells what files in the file set were actually updated    
    pDriverInfo - Driver Info buffer
             

Return Value:

    TRUE    - Success
    FALSE   - something major failed, like allocating memory.

--*/

{
    PINIPRINTER pIniPrinter = NULL;
    LPWSTR      pPrinterNameWithToken = NULL;
    DWORD       dwNeeded;
    DWORD       dwServerMajorVersion;
    DWORD       dwServerMinorVersion;
    BOOL        bInSem = TRUE;
    LPWSTR      pConfigFile = NULL;
    HMODULE     hModuleDriverUI = NULL;
    HANDLE      hPrinter = NULL;
    BOOL        (*pfnDrvUpgrade)() = NULL;
    BOOL        bReturnValue = FALSE;
    DRIVER_UPGRADE_INFO_1   DriverUpgradeInfo1;
    DRIVER_UPGRADE_INFO_2   DriverUpgradeInfo2;    
    WCHAR       ErrorBuffer[ 11 ];
    HANDLE      hToken = INVALID_HANDLE_VALUE;
    LPDEVMODE   pNewDevMode = NULL;


try {

    SplInSem();

    SPLASSERT( ( pIniSpooler != NULL ) &&
               ( pIniSpooler->signature == ISP_SIGNATURE ));

    if (!pOldDriverDir && !pDriverInfo) {
        leave;
    }

    //
    //  Stop Impersonating User
    //  So drivers can call SetPrinterData even if the user is not admin.
    //

    hToken = RevertToPrinterSelf();


    //
    //  Loop Through All Printers. Skip the printers that use drivers that doesn't share files with 
    //  the updated driver. Skip the printers that share files,but the files weren't updated.
    //

    for ( pIniPrinter = pIniSpooler->pIniPrinter ;
          pIniPrinter ;
          pIniPrinter = pIniPrinter->pNext ) {

        SPLASSERT( pIniPrinter->signature == IP_SIGNATURE );
        SPLASSERT( pIniPrinter->pName != NULL );
        SplInSem();

        // Verify if DrvUpgradePrinter needs to be called on this printer
        if (!DriversShareFiles( pIniPrinter->pIniDriver,
                                pIniDriver, 
                                pInternalDriverFiles, 
                                dwFileCount)) {
            continue;
        }

        //
        // Cleanup from previous iteration
        //
        FreeSplStr( pPrinterNameWithToken );
        FreeSplStr(pConfigFile);
        FreeSplMem(pNewDevMode);

        pPrinterNameWithToken   = NULL;
        pConfigFile             = NULL;
        pNewDevMode             = NULL;

        //
        // If we download a driver of newer version we need to update
        // pIniPrinter->pIniDriver
        //
        pIniPrinter->pIniDriver = FindLocalDriver(pIniPrinter->pIniSpooler, pIniPrinter->pIniDriver->pName);
        if ( pIniPrinter->pIniDriver->pIniLangMonitor == NULL )
            pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_ENABLE_BIDI;

        //  Prepare PrinterName to be passed to DrvUpgrade
        //  The name passed is "PrinterName, UpgradeToken"
        //  So that OpenPrinter can do an open without opening
        //  the port in the downlevel connection case.
        //  ( see openprn.c for details )

        pPrinterNameWithToken = pszGetPrinterName( pIniPrinter,
                                                   TRUE,
                                                   pszLocalOnlyToken );

        if ( pPrinterNameWithToken == NULL ) {

            DBGMSG( DBG_WARNING, ("FEPCDDU Failed to allocated ScratchBuffer %d\n", GetLastError() ));
            leave;
        }

        DBGMSG( DBG_TRACE, ("FEPCDDU PrinterNameWithToken %ws\n", pPrinterNameWithToken ));


        pConfigFile = GetConfigFilePath(pIniPrinter);

        if ( !pConfigFile ) {

            DBGMSG( DBG_WARNING, ("FEPCDDU failed SplGetPrinterDriverEx %d\n", GetLastError() ));
            leave;
        }

        INCPRINTERREF(pIniPrinter);

       LeaveSplSem();
       SplOutSem();
       bInSem = FALSE;

        //
        //  Load the UI DLL
        //

        hModuleDriverUI = LoadDriver(pConfigFile);

        if ( hModuleDriverUI == NULL ) {

            DBGMSG( DBG_WARNING, ("FEPCDDU failed LoadLibrary %ws error %d\n", pConfigFile, GetLastError() ));

            wsprintf( ErrorBuffer, L"%d", GetLastError() );

            SplLogEvent( pLocalIniSpooler,
                         LOG_ERROR,
                         MSG_DRIVER_FAILED_UPGRADE,
                         FALSE,
                         pPrinterNameWithToken,
                         pConfigFile,
                         ErrorBuffer,
                         NULL );

           SplOutSem();
           EnterSplSem();
           bInSem = TRUE;
           DECPRINTERREF( pIniPrinter );
            continue;
        }

        DBGMSG( DBG_TRACE, ("FEPCDDU successfully loaded %ws\n", pConfigFile ));


        //
        //  Call DrvUpgrade
        //
        pfnDrvUpgrade = (BOOL (*)())GetProcAddress( hModuleDriverUI, "DrvUpgradePrinter" );

        if ( pfnDrvUpgrade != NULL ) {

            try {

                SPLASSERT( pPrinterNameWithToken != NULL );

                SplOutSem();

                //
                //  Call Driver UI DrvUpgrade
                //              
                if (UpdateUpgradeInfoStruct((LPBYTE) &DriverUpgradeInfo2, 2,
                                            pPrinterNameWithToken, (LPWSTR) pOldDriverDir,
                                            pDriverInfo)) {

                    bReturnValue = (*pfnDrvUpgrade)(2 , &DriverUpgradeInfo2);
                }

                if ( bReturnValue == FALSE ) {

                    UpdateUpgradeInfoStruct((LPBYTE) &DriverUpgradeInfo1, 1,
                                            pPrinterNameWithToken, (LPWSTR) pOldDriverDir,
                                            NULL);

                    bReturnValue = (*pfnDrvUpgrade)(1 , &DriverUpgradeInfo1);
                }

                if ( bReturnValue == FALSE ) {

                    DBGMSG( DBG_WARNING, ("FEPCDDU Driver returned FALSE, doesn't support level %d error %d\n", 1, GetLastError() ));

                    wsprintf( ErrorBuffer, L"%d", GetLastError() );

                    SplLogEvent(  pLocalIniSpooler,
                                  LOG_ERROR,
                                  MSG_DRIVER_FAILED_UPGRADE,
                                  FALSE,
                                  pPrinterNameWithToken,
                                  pConfigFile,
                                  ErrorBuffer,
                                  NULL );
                }

            } except(1) {

                SetLastError( GetExceptionCode() );
                DBGMSG( DBG_ERROR, ("FEPCDDU ExceptionCode %x Driver %ws Error %d\n", GetLastError(), pConfigFile, GetLastError() ));

                //
                // Despite the exception in this driver we'll continue to do all printers
                //
            }

        } else {

            //  Note this is non fatal, since a driver might not have a DrvUpgrade Entry Point.

            DBGMSG( DBG_TRACE, ("FEPCDDU failed GetProcAddress DrvUpgrade error %d\n", GetLastError() ));
        }


        SplOutSem();
        EnterSplSem();
        bInSem = TRUE;

        //
        //  Call ConvertDevMode -- On upgrading we will either convert devmode,
        //  or set to driver default, or NULL it. This way we can make sure
        //  we do not have any different version devmodes
        //

        pNewDevMode = ConvertDevModeToSpecifiedVersion(pIniPrinter,
                                                       pIniPrinter->pDevMode,
                                                       pConfigFile,
                                                       pPrinterNameWithToken,
                                                       CURRENT_VERSION);

        SplInSem();

        FreeSplMem(pIniPrinter->pDevMode);

        pIniPrinter->pDevMode = (LPDEVMODE) pNewDevMode;
        if ( pNewDevMode ) {

            pIniPrinter->cbDevMode = ((LPDEVMODE)pNewDevMode)->dmSize
                                        + ((LPDEVMODE)pNewDevMode)->dmDriverExtra;

            SPLASSERT(pIniPrinter->cbDevMode);

        } else {

            wsprintf( ErrorBuffer, L"%d", GetLastError() );

            SplLogEvent(pLocalIniSpooler,
                        LOG_ERROR,
                        MSG_DRIVER_FAILED_UPGRADE,
                        TRUE,
                        pIniPrinter->pName,
                        pIniPrinter->pIniDriver->pName,
                        ErrorBuffer,
                        NULL);

            pIniPrinter->cbDevMode = 0;
        }

        pNewDevMode = NULL;

        SplInSem();
        if ( !UpdatePrinterIni(pIniPrinter, UPDATE_CHANGEID)) {

            DBGMSG(DBG_WARNING, ("FEPCDDU: UpdatePrinterIni failed with %d\n", GetLastError()));
        }

        //
        //  Clean Up - Free UI DLL
        //
 
        LeaveSplSem();
        SplOutSem();

        UnloadDriver( hModuleDriverUI );

        EnterSplSem();
        SplInSem();

        hModuleDriverUI = NULL;

        //
        //  End of Loop, Move to Next Printer
        //

        SPLASSERT( pIniPrinter->signature == IP_SIGNATURE );

        DECPRINTERREF( pIniPrinter );
    }

    //
    //  Done
    //

    bReturnValue = TRUE;

    DBGMSG( DBG_TRACE, ("FEPCDDU - Success\n" ));



 } finally {

    //
    //  Clean Up
    //

    FreeSplStr(pConfigFile);
    FreeSplMem(pNewDevMode);
    FreeSplStr(pPrinterNameWithToken);

    if ( hModuleDriverUI != NULL )
        UnloadDriver( hModuleDriverUI );

    if ( !bInSem )
        EnterSplSem();

    if ( hToken != INVALID_HANDLE_VALUE )
        ImpersonatePrinterClient(hToken);

 }
    SplInSem();
    return bReturnValue;
}


BOOL
GetFileNamesFromDriverVersionInfo (
    IN  LPDRIVER_INFO_VERSION   pDriverInfo,
    OUT LPWSTR                  *ppszDriverPath,
    OUT LPWSTR                  *ppszConfigFile,
    OUT LPWSTR                  *ppszDataFile,
    OUT LPWSTR                  *ppszHelpFile
    )
/*++

Routine Name:

    GetFileNamesFromDriverVersionInfo                
                    
Routine Description:
    
    Get the name of Driver, Config, Data, Help file from an 
    array of DRIVER_FILE_INFO structures.
    
Arguments:

    pDriverInfo - Pointer to LPDRIVER_INFO_VERSION buffer.
    ppszDriverPath - out pointer to driver file string
    ppszConfigFile - out pointer to config file string
    ppszDataFile - out pointer to data file string
    ppszHelpFile - out pointer to help file string
    
Return Value:
    
    TRUE if file pointers successfully returned.

--*/  
{
    BOOL    bRetValue = FALSE;
    DWORD   dwIndex;
    
    if (pDriverInfo && pDriverInfo->pFileInfo) 
    {
        bRetValue = TRUE;

        for (dwIndex = 0; dwIndex < pDriverInfo->dwFileCount; dwIndex++) 
        {
            switch (pDriverInfo->pFileInfo[dwIndex].FileType) 
            {
                case DRIVER_FILE:
                    if (ppszDriverPath)
                    {
                        *ppszDriverPath = MakePTR(pDriverInfo, 
                                                  pDriverInfo->pFileInfo[dwIndex].FileNameOffset);
                    }
                    break;
                case CONFIG_FILE:
                    if (ppszConfigFile)
                    {
                        *ppszConfigFile = MakePTR(pDriverInfo, 
                                                  pDriverInfo->pFileInfo[dwIndex].FileNameOffset);
                    }
                    break;
                case DATA_FILE:
                    if (ppszDataFile)
                    {
                        *ppszDataFile = MakePTR(pDriverInfo, 
                                                pDriverInfo->pFileInfo[dwIndex].FileNameOffset);
                    }
                    break;
                case HELP_FILE:
                    if (ppszHelpFile)
                    {
                        *ppszHelpFile = MakePTR(pDriverInfo, 
                                                pDriverInfo->pFileInfo[dwIndex].FileNameOffset);
                    }
                    break;
                case DEPENDENT_FILE:
                    break;
                default:
                    bRetValue = FALSE;
                    break;
            }
        }
    }
    
    return bRetValue;
}

BOOL
BuildDependentFilesFromDriverInfo (
    IN  LPDRIVER_INFO_VERSION pDriverInfo,
    OUT LPWSTR               *ppDependentFiles
)
/*++

Routine Name:

    BuildDependentFilesFromDriverInfo

Routine Description:

    Build a multisz string of driver dependent files from 
    a DRIVER_INFO_VERSION structure.

Arguments:

    pDriverInfo      - pointer to  DRIVER_INFO_VERSION structure 
    ppDependentFiles - pointer to allocated multi-sz string
    
Return Value:

    TRUE if SUCCESS    

--*/
{
    BOOL    bRetValue = TRUE;
    DWORD   dwIndex;
    DWORD   dwLength = 0;
    LPWSTR  pszDllFile = NULL;
    
    if (ppDependentFiles && pDriverInfo && pDriverInfo->pFileInfo) 
    {
        *ppDependentFiles = NULL;

        for (dwIndex = 0;
             bRetValue && dwIndex < pDriverInfo->dwFileCount; 
             dwIndex++) 
        {
            switch (pDriverInfo->pFileInfo[dwIndex].FileType) 
            {
                case DRIVER_FILE:                    
                case CONFIG_FILE:                    
                case DATA_FILE:                    
                case HELP_FILE:
                    break;
                case DEPENDENT_FILE:
                {
                    dwLength += wcslen(MakePTR(pDriverInfo, 
                                               pDriverInfo->pFileInfo[dwIndex].FileNameOffset)) + 1;
                    break;
                }                    
                default:
                {
                    bRetValue = FALSE;
                    break;
                }
            }
        }

        if (bRetValue && dwLength > 0) 
        {
            dwLength++;
            dwLength *= sizeof(WCHAR);

            pszDllFile = (LPWSTR)AllocSplMem(dwLength);

            if (pszDllFile)
            {
                *ppDependentFiles = pszDllFile;

                for (dwIndex = 0; 
                     bRetValue && dwIndex < pDriverInfo->dwFileCount; 
                     dwIndex++) 
                {
                    switch (pDriverInfo->pFileInfo[dwIndex].FileType) 
                    {
                        case DRIVER_FILE:                    
                        case CONFIG_FILE:                    
                        case DATA_FILE:                    
                        case HELP_FILE:
                            break;
                        case DEPENDENT_FILE:
                        {
                            wcscpy(pszDllFile, 
                                   MakePTR(pDriverInfo, 
                                   pDriverInfo->pFileInfo[dwIndex].FileNameOffset));
                            pszDllFile += wcslen(pszDllFile) + 1;
                            break;
                        }                            
                        default:
                        {
                            bRetValue = FALSE;
                            break;
                        }
                    }
                }                
            } 
            else
            {
                bRetValue = FALSE;
            }
        }
    }
    
    if (bRetValue == FALSE && ppDependentFiles)
    {
        FreeSplMem(*ppDependentFiles);
        *ppDependentFiles = NULL;
    }

    return bRetValue;
}


BOOL
DriverAddedOrUpgraded (
    IN  PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN  DWORD               dwFileCount
    )
/*++

Routine Name:

    DriverAddedOrUpgraded

Routine Description:
    
    Checks the Internal driver file array to see if at least 
    one driver file was updated. This is a performance optimization
    for calling DrvUpgradePrinter for ecah printer using the upgraded 
    driver or a driver sharing files in common with upgraded driver
    (see ForEachPrinterCallDriverDrvUpgrade).

Arguments:

    pInternalDriverFiles - array of INTERNAL_DRV_FILE structures
    dwFileCount - number of files in array
    
Return Value:

    TRUE if driver files where added or upgraded.

--*/
{
    BOOL    bDriverAddedOrUpgraded = FALSE;
    DWORD   dwIndex;

    for (dwIndex = 0; dwIndex < dwFileCount; dwIndex++)
    {
        if (pInternalDriverFiles[dwIndex].bUpdated)
        {
            bDriverAddedOrUpgraded = TRUE;
            break;
        }
    }

    return bDriverAddedOrUpgraded;
}

VOID
CleanupInternalDriverInfo(
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               FileCount
    )
/*++

Routine Name:
    
    CleanupInternalDriverInfo

Routine Description:
    
    Frees array of INTERNAL_DRV_FILE.
    FileCount gives the element count in the array.

Arguments:

    pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
    FileCount           -- number of files in file set
    
Return Value:

    Nothing.

--*/
{
    DWORD dwIndex;

    if (pInternalDriverFiles) 
    {
        for (dwIndex = 0; dwIndex < FileCount; dwIndex++)
        {
            FreeSplStr(pInternalDriverFiles[dwIndex].pFileName);

            if (pInternalDriverFiles[dwIndex].hFileHandle != INVALID_HANDLE_VALUE)
            {
                CloseHandle(pInternalDriverFiles[dwIndex].hFileHandle);
            }
        }
        
        FreeSplMem(pInternalDriverFiles);
    }
}

BOOL
GetDriverFileVersionsFromNames(
    IN  PINTERNAL_DRV_FILE    pInternalDriverFiles,
    IN  DWORD                 dwCount
    )
/*++

Routine Name:

    GetDriverFileVersionsFromNames

Routine Description:

    Fills the array of INTERNAL_DRV_FILE with driver minor version,
    by calling GetPrintDriverVersion for each file.
    The array already has the file names filled in.

Arguments:

    pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
    FileCount           -- number of files in file set
    
Return Value:

    TRUE if SUCCESS

--*/
{
    DWORD   Count, Size;
    BOOL    bReturnValue = TRUE;
    
    if (!pInternalDriverFiles || !dwCount) 
    {
        bReturnValue = FALSE;
        SetLastError(ERROR_INVALID_DATA);
    } 
    else
    {
        for (Count = 0 ; Count < dwCount ; ++Count) 
        {
            if (IsEXEFile(pInternalDriverFiles[Count].pFileName))
            {
                if (!GetPrintDriverVersion(pInternalDriverFiles[Count].pFileName, 
                                           NULL, 
                                           &pInternalDriverFiles[Count].dwVersion)) 
                {
                    bReturnValue = FALSE;
                    break;
                }
            }
        }
    }
    
    return bReturnValue;
}

BOOL
GetDriverFileVersions(
    IN  LPDRIVER_INFO_VERSION pDriverVersion,
    IN  PINTERNAL_DRV_FILE    pInternalDriverFiles,
    IN  DWORD                 dwCount
    )
/*++

Routine Name:

    GetDriverFileVersions

Routine Description:
    
    Fills the array of INTERNAL_DRV_FILE with driver minor version
    stored in DRIVER_INFO_VERSION structure.
    
Arguments:

    pDriverVersion      - pointer to DRIVER_INFO_VERSION
    pInternalDriverFiles - pointer to array of INTERNAL_DRV_FILE
    dwCount             - number of elemnts in array
    
Return Value:

    TRUE if succeeded.

--*/
{
    DWORD   Count, Size;
    BOOL    bReturnValue = TRUE;
    DWORD   dwMajorVersion;
    
    if (!pDriverVersion ||
        !pDriverVersion->pFileInfo || 
        pDriverVersion->dwFileCount != dwCount) 
    {
        bReturnValue = FALSE;
        SetLastError(ERROR_INVALID_DATA);
    }
    else
    {
        for (Count = 0; Count < pDriverVersion->dwFileCount; Count++) 
        {            
            pInternalDriverFiles[Count].dwVersion = pDriverVersion->pFileInfo[Count].FileVersion;
        }
    }
    
    return bReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\dsprune.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved

Abstract:

    This module provides functionality for ADs within spooler

Author:

    Steve Wilson (NT) July 1997

Revision History:

--*/


#include <precomp.h>
#pragma hdrstop

#include "ds.hxx"
#include "dsprune.hxx"


RETRYLIST   gRetry = {NULL, 0, NULL};


#define IADSPATH        0
#define IUNCNAME        1
#define ICN             2
#define IVERSION        3
#define ISERVER         4
#define IFLAGS          5
#define ADSPATH         L"ADsPath"
#define CN              L"CN"

PWSTR gpszAttributes[] = {ADSPATH, SPLDS_UNC_NAME, CN, SPLDS_VERSION_NUMBER, SPLDS_SERVER_NAME, SPLDS_FLAGS};
#define N_ATTRIBUTES    COUNTOF(gpszAttributes)

#define SZ_NO_CACHE         L",NoCache"

#define LOG_EVENT_ERROR_BUFFER_SIZE     11

DWORD
SpawnDsPrune(
    DWORD dwDelay
)
{
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   ThreadId;
    HANDLE  hDsPruneThread;
    PDWORD  pdwDelay;

    if (pdwDelay = (PDWORD) AllocSplMem(sizeof(DWORD)))
        *pdwDelay = dwDelay;

    if(!(hDsPruneThread = CreateThread(NULL,
                                        0,
                                        (LPTHREAD_START_ROUTINE) DsPrune,
                                        (PVOID) pdwDelay,
                                        0,
                                        &ThreadId))) {
        dwError = GetLastError();
        FreeSplMem(pdwDelay);
    } else {
        CloseHandle(hDsPruneThread);
        dwError = ERROR_SUCCESS;
    }


    return dwError;
}


DWORD
WINAPI
DsPrune(
    PDWORD  pdwDelay
)
{
    PWSTR   *ppszMySites = NULL;
    PWSTR   pszDomainRoot = NULL;
    ULONG   cMySites;
    DWORD   dwRet;
    HRESULT hr;

    /*
        1) Determine my site
        2) Query for all PrintQueue objects in my domain
        3) For each PrintQueue:
            a) Get array of IP addresses
            b) Pass IP addresses to DsAddressToSiteNames
            c) If no site returned by DsAddressToSiteNames matches my site, goto 3
            d) Delete PrintQueue if orphaned
    */


    // Sleep random amount on startup so DCs aren't all pruning at the same time
    if (pdwDelay) {
        Sleep(*pdwDelay*ONE_MINUTE);     // *pdwDelay is number of minutes
        FreeSplMem(pdwDelay);
    }

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr)) {
        return HRESULT_CODE(hr);
    }

    // Determine my sites
    dwRet = DsGetDcSiteCoverage(NULL, &cMySites, &ppszMySites);
    if (dwRet != NO_ERROR)
        goto error;

    dwRet = GetDomainRoot(&pszDomainRoot);
    if (dwRet != NERR_Success)
        goto error;

    while(1) {

        PRUNINGPOLICIES PruningPolicies;
        DWORD dwSleep, dwOriginalSleep;

        PruningPolicies.dwPruneDownlevel = PruneDownlevel();
        PruningPolicies.dwPruningRetries = PruningRetries();
        PruningPolicies.dwPruningRetryLog = PruningRetryLog();
        
        SetPruningPriority();

        DeleteOrphans(ppszMySites, cMySites, pszDomainRoot, &PruningPolicies);

        dwSleep = dwOriginalSleep = PruningInterval();

        while (dwSleep > HOUR_OF_MINUTES) {

            Sleep(ONE_HOUR);     // Check interval every hour

            DWORD dwNewSleep = PruningInterval();

            if (dwNewSleep != dwOriginalSleep) {
                dwSleep = dwOriginalSleep = dwNewSleep;
            }

            if (dwSleep != INFINITE && dwSleep > HOUR_OF_MINUTES)
                dwSleep -= HOUR_OF_MINUTES;
        }
        Sleep(dwSleep*ONE_MINUTE);
    }


error:

    if (ppszMySites)
        NetApiBufferFree(ppszMySites);

    FreeSplMem(pszDomainRoot);

    CoUninitialize();

    return ERROR_SUCCESS;
}



HRESULT
DeleteOrphans(
    PWSTR           *ppszMySites,
    ULONG            cMySites,
    PWSTR            pszSearchRoot,
    PRUNINGPOLICIES *pPruningPolicies
)
{
    ADS_SEARCH_HANDLE    hSearchHandle = NULL;
    IDirectorySearch    *pDSSearch = NULL;
    HRESULT              hr = S_OK;
    WCHAR                szSearchPattern[] = L"(objectCategory=printQueue)";
    SEARCHCOLUMN         Col[N_ATTRIBUTES];
    DWORD                i;
    ADS_SEARCHPREF_INFO  SearchPrefs;
    DWORD                dwError;



    // Find all PrintQueues in domain
    hr = ADsGetObject(  pszSearchRoot,
                        IID_IDirectorySearch,
                        (void **)&pDSSearch);
    BAIL_ON_FAILURE(hr);


    SearchPrefs.dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPrefs.vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs.vValue.Integer = 256;

    hr = pDSSearch->SetSearchPreference(&SearchPrefs, 1);
    if (FAILED(hr)) {
        DBGMSG(DBG_WARNING, ("DSPrune: SetSearchPref failed: %d\n", hr));
    } else if (hr != S_OK && SearchPrefs.dwStatus != ADS_STATUS_S_OK) {
        DBGMSG(DBG_WARNING, ("DSPrune: SearchPref failed: %d\n", SearchPrefs.dwStatus));
    }

    hr = pDSSearch->ExecuteSearch(
         szSearchPattern,
         gpszAttributes,
         N_ATTRIBUTES,
         &hSearchHandle);
    BAIL_ON_FAILURE(hr);

    hr = pDSSearch->GetNextRow(hSearchHandle);
    //
    // This is the new way of checking for rows in Whistler.
    // see bug 163776. I expect to be changed in the future.
    //
    if (hr == S_ADS_NOMORE_ROWS) {
        ADsGetLastError(&dwError, NULL, 0, NULL, 0);
        if (dwError == ERROR_MORE_DATA) {
            hr = pDSSearch->GetNextRow(hSearchHandle);
        }
    }
    BAIL_ON_FAILURE(hr);

    while (hr != S_ADS_NOMORE_ROWS) {

        for (i = 0 ; i < N_ATTRIBUTES ; ++i)
            Col[i].hr = pDSSearch->GetColumn(hSearchHandle, gpszAttributes[i], &Col[i].Column);

        DeleteOrphan(ppszMySites, cMySites, Col, pPruningPolicies);

        for (i = 0 ; i < N_ATTRIBUTES ; ++i)
            if (SUCCEEDED(Col[i].hr))
                pDSSearch->FreeColumn(&Col[i].Column);

        hr = pDSSearch->GetNextRow(hSearchHandle);
        //
        // This is the new way of checking for rows in Whistler.
        // see bug 163776. I expect to be changed in the future.
        //
        if (hr == S_ADS_NOMORE_ROWS) {
            ADsGetLastError(&dwError, NULL, 0, NULL, 0);
            if (dwError == ERROR_MORE_DATA) {
                hr = pDSSearch->GetNextRow(hSearchHandle);
            }
        }
        BAIL_ON_FAILURE(hr);
    }

    hr = S_OK;


error:


    if (hSearchHandle)
        pDSSearch->CloseSearchHandle(hSearchHandle);

    if (pDSSearch)
        pDSSearch->Release();

    return hr;
}


VOID
DeleteOrphan(
    PWSTR           *ppszMySites,
    ULONG            cMySites,
    SEARCHCOLUMN     Col[],
    PRUNINGPOLICIES *pPruningPolicies
)
{
    IADs                *pADs           = NULL;
    IADsContainer       *pContainer     = NULL;
    PWSTR               pszParent       = NULL;
    PWSTR               pszCommonName   = NULL;
    HANDLE              hPrinter        = NULL;
    PWSTR               pszServerName   = NULL;
    PWSTR               pszEscapedCN    = NULL;
    PWSTR               pszCN;
    PWSTR               pszADsPath;
    PWSTR               pszUNCName;
    PWSTR               pszServer;
    DWORD               dwError         = ERROR_SUCCESS;
    HRESULT             hr;
    DWORD               dwVersion;
    DWORD               dwFlags;
    DWORD               cb;
    BOOL                bDeleteIt               = FALSE;
    BOOL                bDeleteImmediately      = FALSE;
    WCHAR               ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];

    pszADsPath = SUCCEEDED(Col[IADSPATH].hr) ? Col[IADSPATH].Column.pADsValues->DNString : NULL;
    pszUNCName = SUCCEEDED(Col[IUNCNAME].hr) ? Col[IUNCNAME].Column.pADsValues->DNString : NULL;
    pszServer = SUCCEEDED(Col[ISERVER].hr) ? Col[ISERVER].Column.pADsValues->DNString : NULL;
    pszCN = SUCCEEDED(Col[ICN].hr) ? Col[ICN].Column.pADsValues->DNString : NULL;
    dwVersion = SUCCEEDED(Col[IVERSION].hr) ? Col[IVERSION].Column.pADsValues->Integer : 0;
    dwFlags = SUCCEEDED(Col[IFLAGS].hr) ? Col[IFLAGS].Column.pADsValues->Integer : 0;


    // We should always have an ADsPath & CN, but if not, don't continue because there's
    // no way to delete something if we don't know where it is.
    if (!pszADsPath || !pszCN) {
        DBGMSG(DBG_WARNING, ("DeleteOrphan: No ADs Path or CN!\n"));
        return;
    }

    if (!(dwFlags & IMMORTAL)) {
        if (!pszUNCName || !pszServer || FAILED(Col[IVERSION].hr)) {
            bDeleteIt = bDeleteImmediately = TRUE;

            SplLogEvent( pLocalIniSpooler,
                         LOG_INFO,
                         MSG_PRUNING_NOUNC_PRINTER,
                         FALSE,
                         pszADsPath,
                         NULL );

        } else if ((dwVersion >= DS_PRINTQUEUE_VERSION_WIN2000 ||
                    pPruningPolicies->dwPruneDownlevel != PRUNE_DOWNLEVEL_NEVER) &&
                    UNC2Server(pszUNCName, &pszServerName) == ERROR_SUCCESS &&
                    ServerOnSite(ppszMySites, cMySites, pszServerName)) {

            // Try to open the printer.  If it doesn't exist, delete it!

            PWSTR   pszNoCacheUNCName = NULL;

            cb = (wcslen(pszUNCName) + 1)*sizeof *pszUNCName;
            cb += sizeof(SZ_NO_CACHE);

            pszNoCacheUNCName = (PWSTR) AllocSplMem(cb);

            if (pszNoCacheUNCName) {    // If Alloc fails, just go on to the next printer

                wcscpy(pszNoCacheUNCName, pszUNCName);
                wcscat(pszNoCacheUNCName, SZ_NO_CACHE);

                DBGMSG(DBG_EXEC, ("DSPrune: Checking %ws\n", pszUNCName));

                if (!OpenPrinter(pszNoCacheUNCName, &hPrinter, NULL)) {
                    dwError = GetLastError();

                    if (dwError != ERROR_ACCESS_DENIED &&
                       (dwVersion >= DS_PRINTQUEUE_VERSION_WIN2000 ||
                        pPruningPolicies->dwPruneDownlevel == PRUNE_DOWNLEVEL_AGGRESSIVELY ||
                       (pPruningPolicies->dwPruneDownlevel == PRUNE_DOWNLEVEL_NICELY && ServerExists(pszServerName)))) {
                        bDeleteIt = TRUE;

                        //
                        // Log an info event for each retry, if the policy is configured so.
                        //
                        if (pPruningPolicies->dwPruningRetryLog) {
                            wsprintf(ErrorBuffer, L"%0x", dwError);
                            SplLogEvent( pLocalIniSpooler,
                                         LOG_INFO,
                                         MSG_PRUNING_ABSENT_PRINTER,
                                         FALSE,
                                         pszADsPath,
                                         ErrorBuffer,
                                         NULL );
                        }

                    }
                } else if (dwVersion >= DS_PRINTQUEUE_VERSION_WIN2000) {

                    BYTE    Data[256];
                    DWORD   cbNeeded  = 0;
                    BYTE    *pData = Data;
                    BYTE    bHaveData = TRUE;

                    // Verify that the printer should indeed be published and that
                    // the GUID of the published object matches the GUID on the print server.
                    // NOTE: The GUID check is needed because we may publish the same printer
                    // twice if the spooler is restarted and checks a DC before the first publish
                    // is replicated.

                    if (!GetPrinter(hPrinter, 7, Data, COUNTOF(Data), &cbNeeded)) {
                        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

                            // Forget this printer if alloc or second GetPrinter fails
                            pData = (PBYTE) AllocSplMem(cbNeeded);
                            if (pData) {
                                if (!GetPrinter(hPrinter, 7, pData, cbNeeded, &cbNeeded)) {
                                    bHaveData = FALSE;
                                }
                            } else {
                                bHaveData = FALSE;
                            }
                        } else {
                            //
                            // A Win9x machine may have the same printer UNCName
                            //
                            bDeleteIt = TRUE;
                            bHaveData = FALSE;
                        }
                    }

                    if (bHaveData) {
                        if (!(((PPRINTER_INFO_7) pData)->dwAction & DSPRINT_PUBLISH)) {
                            bDeleteIt = bDeleteImmediately = TRUE;

                            SplLogEvent( pLocalIniSpooler,
                                         LOG_INFO,
                                         MSG_PRUNING_UNPUBLISHED_PRINTER,
                                         FALSE,
                                         pszADsPath,
                                         NULL );
                        } else {

                            // Compare object GUID to printer's GUID
                            PWSTR pszObjectGUID = NULL;

                            hr = ADsGetObject(pszADsPath, IID_IADs, (void **) &pADs);
                            BAIL_ON_FAILURE(hr);

                            hr = GetGUID(pADs, &pszObjectGUID);
                            BAIL_ON_FAILURE(hr);

                            if (!((PPRINTER_INFO_7) pData)->pszObjectGUID ||
                                wcscmp(((PPRINTER_INFO_7) pData)->pszObjectGUID, pszObjectGUID)) {
                                bDeleteIt = bDeleteImmediately = TRUE;

                                SplLogEvent( pLocalIniSpooler,
                                             LOG_INFO,
                                             MSG_PRUNING_DUPLICATE_PRINTER,
                                             FALSE,
                                             pszADsPath,
                                             NULL );
                            }


                            FreeSplStr(pszObjectGUID);
                            pADs->Release();
                            pADs = NULL;
                        }
                    }

                    if (pData != Data)
                        FreeSplMem(pData);
                }
                FreeSplMem(pszNoCacheUNCName);
            }
        }
    }


    // Get PrintQueue object
    hr = ADsGetObject(pszADsPath, IID_IADs, (void **) &pADs);
    BAIL_ON_FAILURE(hr);

    if (bDeleteIt) {

        // Delete the printqueue

        // Check retry count
        if (!bDeleteImmediately && !EnoughRetries(pADs, pPruningPolicies->dwPruningRetries))
            goto error;


        // Get the Parent ADsPath
        hr = pADs->get_Parent(&pszParent);
        BAIL_ON_FAILURE(hr);

        // Get the Parent object
        hr = ADsGetObject(  pszParent,
                            IID_IADsContainer,
                            (void **) &pContainer);
        BAIL_ON_FAILURE(hr);


        // The CN string read from ExecuteSearch may have unescaped characters, so
        // be sure to fix this before trying to delete
        pszEscapedCN = CreateEscapedString(pszCN, DN_SPECIAL_CHARS);
        if (!pszEscapedCN) {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        // pszCN needs to be formatted as: "CN=Name"
        cb = (wcslen(pszEscapedCN) + 4)*sizeof(WCHAR);
        if (!(pszCommonName = (PWSTR) AllocSplMem(cb))) {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
            BAIL_ON_FAILURE(hr);
        }
        wcscpy(pszCommonName, L"CN=");
        wcscat(pszCommonName, pszEscapedCN);

        hr = pContainer->Delete(SPLDS_PRINTER_CLASS, pszCommonName);

        if (FAILED(hr)) {
            wsprintf(ErrorBuffer, L"%0x", hr);
            SplLogEvent( pLocalIniSpooler,
                         LOG_ERROR,
                         MSG_CANT_PRUNE_PRINTER,
                         FALSE,
                         pszADsPath,
                         ErrorBuffer,
                         NULL );
            DBGMSG(DBG_EXEC, ("DSPrune: Can't delete %ws.  Error: %0x\n", pszUNCName, hr));
            goto error;
        }

        SplLogEvent( pLocalIniSpooler,
                     LOG_INFO,
                     MSG_PRUNING_PRINTER,
                     FALSE,
                     pszADsPath,
                     NULL );
        DBGMSG(DBG_EXEC, ("DSPrune: DELETING %ws\n", pszUNCName));

    } else {
        // Delete the Retry Entry (if any) if we aren't deleting it
        DeleteRetryEntry(pADs);
    }


error:

    if (hPrinter)
        ClosePrinter(hPrinter);

    if (pADs)
        pADs->Release();

    if (pContainer)
        pContainer->Release();

    if (pszParent)
        SysFreeString(pszParent);

    FreeSplMem(pszCommonName);
    FreeSplMem(pszEscapedCN);
    FreeSplMem(pszServerName);
}



BOOL
EnoughRetries(
    IADs        *pADs,
    DWORD       dwPruningRetries
)
/*++
Function Description:
    This function return TRUE if we have retry count is greater than retry policy, FALSE otherwise

Parameters:
    pADs        - pointer to the PrintQueue object

Return Values:
    TRUE if retry count is greater than the policy setting for this object
    FALSE if we can't get the GUID or entry doesn't exist and it can't be created (out of memory)
--*/
{
    HRESULT     hr = S_OK;
    PWSTR       pszObjectGUID = NULL;
    PRETRYLIST  pRetry = NULL;
    BOOL        bEnoughRetries = FALSE;

    // Get the GUID
    hr = GetGUID(pADs, &pszObjectGUID);
    BAIL_ON_FAILURE(hr);

    // Get the entry
    if (!(pRetry = GetRetry(pszObjectGUID))) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    // Increment retry count if we're not done.  Delete retry if we're done.
    if (++pRetry->nRetries > dwPruningRetries) {
        DeleteRetry(pRetry);
        bEnoughRetries = TRUE;
    }

error:

    FreeSplStr(pszObjectGUID);

    return bEnoughRetries;
}


VOID
DeleteRetryEntry(
    IADs        *pADs
)
/*++
Function Description:
    This function removes a Retry entry based on the supplied ADs pointer

Parameters:
    pADs        - pointer to the PrintQueue object

Return Values:
    none
--*/
{
    HRESULT     hr = S_OK;
    PWSTR       pszObjectGUID = NULL;
    PRETRYLIST  pRetry = NULL;

    // Get the GUID
    hr = GetGUID(pADs, &pszObjectGUID);
    BAIL_ON_FAILURE(hr);

    // Get & Delete the entry
    if (pRetry = FindRetry(pszObjectGUID)) {
        DeleteRetry(pRetry);
    }

error:

    FreeSplStr(pszObjectGUID);
}


PRETRYLIST
FindRetry(
    PWSTR pszObjectGUID
)
/*++
Function Description:
    This function finds a RETRYLIST entry.

Parameters:
    pszObjectGUID - pointer to buffer containing the GUID of the RETRYLIST entry to find or create.

Return Values:
    PRETRYLIST  - pointer to the found or create RETRYLIST entry.  This may be NULL if the entry is
                  not found and a new one could not be created.

--*/
{
    PRETRYLIST  pRetry = &gRetry;

    for (; pRetry->pNext ; pRetry = pRetry->pNext) {

        // If entry exists, just return
        if (!wcscmp(pszObjectGUID, pRetry->pNext->pszObjectGUID))
            return pRetry->pNext;
    }

    return NULL;
}


PRETRYLIST
GetRetry(
    PWSTR pszObjectGUID
)
/*++
Function Description:
    This function finds or creates a RETRYLIST entry.

Parameters:
    pszObjectGUID - pointer to buffer containing the GUID of the RETRYLIST entry to find or create.

Return Values:
    PRETRYLIST  - pointer to the found or create RETRYLIST entry.  This may be NULL if the entry is
                  not found and a new one could not be created.

--*/
{
    PRETRYLIST  pRetry = &gRetry;
    int         iRet = -1;

    for (; pRetry->pNext ; pRetry = pRetry->pNext) {

        // If entry exists, just return
        if (!(iRet = wcscmp(pszObjectGUID, pRetry->pNext->pszObjectGUID)))
            return pRetry->pNext;

        // If next entry is greater than New entry, then insert New entry here
        if (iRet > 0)
            break;
    }


    // Create a new entry

    PRETRYLIST pRetryNew;

    if (!(pRetryNew = (PRETRYLIST) AllocSplMem(sizeof(RETRYLIST))))
        return NULL;

    if (!(pRetryNew->pszObjectGUID = (PWSTR) AllocSplStr(pszObjectGUID))) {
        FreeSplMem(pRetryNew);
        return NULL;
    }

    if (!pRetry->pNext) {   // End of list
        pRetryNew->pNext = NULL;
        pRetryNew->pPrev = pRetry;
        pRetry->pNext = pRetryNew;
    } else {                // Middle of list
        pRetryNew->pNext = pRetry->pNext;
        pRetryNew->pPrev = pRetry;
        pRetry->pNext->pPrev = pRetryNew;
        pRetry->pNext = pRetryNew;
    }

    pRetryNew->nRetries = 0;

    return pRetryNew;
}


VOID
DeleteRetry(
    PRETRYLIST pRetry
)
{
    SPLASSERT(pRetry != &gRetry);
    SPLASSERT(pRetry);
    SPLASSERT(pRetry->pszObjectGUID);
    SPLASSERT(pRetry->pPrev);

    pRetry->pPrev->pNext = pRetry->pNext;

    if (pRetry->pNext)
        pRetry->pNext->pPrev = pRetry->pPrev;

    FreeSplStr(pRetry->pszObjectGUID);
    FreeSplMem(pRetry);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\dsutil.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved

Abstract:

    This module provides functionality for ADs within spooler

Author:

    Steve Wilson (NT) Nov 1997

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

#define LOG_EVENT_ERROR_BUFFER_SIZE     11
#define MAX_CN  63                  // DS limits common names to 63 non-null chars
#define UNIQUE_NUMBER_SIZE  10
#define MIN_CN  (UNIQUE_NUMBER_SIZE + 3 + 1) // CN= + room for unique number if needed, plus NULL

extern BOOL gdwLogDsEvents;

extern "C" HANDLE    ghDsUpdateThread;
extern "C" DWORD     gdwDsUpdateThreadId;

// Policy values
WCHAR *szPublishPrinters        = L"PublishPrinters";
WCHAR *szPruneDownlevel         = L"PruneDownlevel";
WCHAR *szPruningInterval        = L"PruningInterval";
WCHAR *szPruningRetries         = L"PruningRetries";
WCHAR *szPruningPriority        = L"PruningPriority";
WCHAR *szVerifyPublishedState   = L"VerifyPublishedState";
WCHAR *szImmortal               = L"Immortal";
WCHAR *szServerThreadPolicy     = L"ServerThread";
WCHAR *szPruningRetryLog        = L"PruningRetryLog";

extern "C" BOOL (*pfnOpenPrinter)(LPTSTR, LPHANDLE, LPPRINTER_DEFAULTS);
extern "C" BOOL (*pfnClosePrinter)(HANDLE);
extern "C" LONG (*pfnDocumentProperties)(HWND, HANDLE, LPWSTR, PDEVMODE, PDEVMODE, DWORD);

DWORD dwLastPruningPriority = DEFAULT_PRUNING_PRIORITY;


HRESULT
GetPrintQueue(
    HANDLE          hPrinter,
    IADs            **ppADs
)
/*++
Function Description:
    This function returns the ADs PrintQueue object of the supplied printer handle.

Parameters:
    hPrinter - printer handle
    ppADs    - return pointer to the PrintQueue object.  Caller frees via ppADs->Release().

Return Values:
    HRESULT
--*/
{
    HRESULT         hr;
    PSPOOL          pSpool = (PSPOOL) hPrinter;
    PINIPRINTER     pIniPrinter = pSpool->pIniPrinter;
    IDispatch       *pDispatch = NULL;
    IADsContainer   *pADsContainer = NULL;
    WCHAR           ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];


    // Create the Print-Queue object
    // Get the container

    hr = GetPrintQueueContainer(hPrinter, &pADsContainer, ppADs);
    BAIL_ON_FAILURE(hr);

    if (!*ppADs) {  // PrintQueue object does not exist, so create it

        hr = pADsContainer->Create( SPLDS_PRINTER_CLASS,
                                    pIniPrinter->pszCN,
                                    &pDispatch);
        if (FAILED(hr)) {
            wsprintf(ErrorBuffer, L"%0x", hr);
            SplLogEvent(  ((PSPOOL) hPrinter)->pIniSpooler,
                          gdwLogDsEvents & LOG_ERROR,
                          MSG_CANT_CREATE_PRINTQUEUE,
                          FALSE,
                          pIniPrinter->pszDN,
                          ErrorBuffer,
                          NULL );

            DBGMSG(DBG_WARNING,("Can't Create PrintQueue: %ws, %ws\n", pIniPrinter->pszDN, ErrorBuffer));
            BAIL_ON_FAILURE(hr);
        }

        hr = pDispatch->QueryInterface(IID_IADs, (void **) ppADs);
        BAIL_ON_FAILURE(hr);
    }


error:

    if (pADsContainer)
        pADsContainer->Release();

    if (pDispatch)
        pDispatch->Release();

    return hr;
}




HRESULT
GetPublishPoint(
    HANDLE  hPrinter
)
/*++
Function Description:
    This function gets the publish point by setting pIniPrinter->pszDN and pIniPrinter->pszCN

Parameters:
    hPrinter - printer handle

Return Values:
    HRESULT
--*/
{
    HRESULT     hr;
    PSPOOL      pSpool = (PSPOOL) hPrinter;
    PINIPRINTER pIniPrinter = pSpool->pIniPrinter;


    // We should only be here if we couldn't use the existing DN & CN, so free old ones
    FreeSplStr(pIniPrinter->pszCN);
    pIniPrinter->pszCN = NULL;

    FreeSplStr(pIniPrinter->pszDN);
    pIniPrinter->pszDN = NULL;

    // If Published, update DN from GUID
    if (pIniPrinter->pszObjectGUID) {

        hr = GetPublishPointFromGUID(   hPrinter,
                                        pIniPrinter->pszObjectGUID,
                                        &pIniPrinter->pszDN,
                                        &pIniPrinter->pszCN,
                                        TRUE);

        //
        // If the object is actually deleted, the error is ERROR_FILE_NOT_FOUND
        // If the object is a tombstone, the error is ERROR_DS_NO_SUCH_OBJECT
        //
        if (HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND ||
            HRESULT_CODE(hr) == ERROR_DS_NO_SUCH_OBJECT) {
            if (ghDsUpdateThread && gdwDsUpdateThreadId == GetCurrentThreadId()) {
                // We are in the background thread
                pIniPrinter->DsKeyUpdate = DS_KEY_REPUBLISH;
            } else {
                pIniPrinter->DsKeyUpdateForeground = DS_KEY_REPUBLISH;
            }
        }

        BAIL_ON_FAILURE(hr);

    } else {

        // Generate default publish point & common name
        hr = GetDefaultPublishPoint(hPrinter, &pIniPrinter->pszDN);
        BAIL_ON_FAILURE(hr);


        // Printer name might change, so make a copy here
        EnterSplSem();
        PWSTR pszPrinterName = AllocSplStr(pIniPrinter->pName);
        LeaveSplSem();

        if (pszPrinterName) {
            hr = GetCommonName( hPrinter,
                                pIniPrinter->pIniSpooler->pMachineName,
                                pszPrinterName,
                                pIniPrinter->pszDN,
                                &pIniPrinter->pszCN);
            FreeSplStr(pszPrinterName);
        } else {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        }
        BAIL_ON_FAILURE(hr);
    }

error:

    return hr;
}



HRESULT
GetPublishPointFromGUID(
    HANDLE  hPrinter,
    PWSTR   pszObjectGUID,
    PWSTR   *ppszDN,
    PWSTR   *ppszCN,
    BOOL    bGetDNAndCN
)
/*++
Function Description:
    This function returns the publish point of a specified GUID

Parameters:
    hPrinter - printer handle
    ppszObjectGUID - objectGUID of object for which we want to find the publish point
    ppszDN - ADsPath of container containing object.  Caller frees via FreeSplMem().
    ppszCN - Common Name of object.  Caller frees via FreeSplMem().
    bGetDNAndCN - if TRUE, DN of Container & CN of object are returned.  If FALSE, DN is path to object

Return Values:
    HRESULT
--*/
{
    PSPOOL      pSpool = (PSPOOL) hPrinter;
    DWORD dwRet, nBytes, nChars;
    BOOL bRet;
    PWSTR pNames[2];
    DS_NAME_RESULT *pDNR = NULL;
    DOMAIN_CONTROLLER_INFO *pDCI = NULL;
    HANDLE hDS = NULL;
    PWSTR psz;
    WCHAR ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];
    HRESULT hr = S_OK;


    dwRet = Bind2DS(&hDS, &pDCI, DS_DIRECTORY_SERVICE_PREFERRED);
    if (dwRet != ERROR_SUCCESS) {
        wsprintf(ErrorBuffer, L"%0x", dwRet);
        if (pSpool) {
            SplLogEvent(  pSpool->pIniSpooler,
                          gdwLogDsEvents & LOG_ERROR,
                          MSG_CANT_GET_DNS_DOMAIN_NAME,
                          FALSE,
                          ErrorBuffer,
                          NULL );
        }
        DBGMSG(DBG_WARNING,("Can't get DNS Domain Name: %ws\n", ErrorBuffer));
        goto error;
    }


    // Get Publish Point

    if (ppszDN) {

        pNames[0] = pszObjectGUID;
        pNames[1] = NULL;

        if (!(DsCrackNames(
                        hDS,
                        DS_NAME_NO_FLAGS,
                        DS_UNKNOWN_NAME,
                        DS_FQDN_1779_NAME,
                        1,
                        &pNames[0],
                        &pDNR) == ERROR_SUCCESS)) {

            dwRet = GetLastError();
            wsprintf(ErrorBuffer, L"%0x", dwRet);
            if (pSpool) {
                SplLogEvent(  pSpool->pIniSpooler,
                              gdwLogDsEvents & LOG_WARNING,
                              MSG_CANT_CRACK_GUID,
                              FALSE,
                              pDCI->DomainName,
                              ErrorBuffer,
                              NULL );
                DBGMSG(DBG_WARNING,("Can't crack GUID: %ws, %ws\n", pDCI->DomainName, ErrorBuffer));
            }
            dwRet = ERROR_FILE_NOT_FOUND;
            goto error;
        }

        if (pDNR->rItems[0].status != DS_NAME_NO_ERROR) {
            dwRet = DsCrackNamesStatus2Win32Error(pDNR->rItems[0].status);

            wsprintf(ErrorBuffer, L"%0x", dwRet);
            if (pSpool) {
                SplLogEvent(  pSpool->pIniSpooler,
                              gdwLogDsEvents & LOG_WARNING,
                              MSG_CANT_CRACK_GUID,
                              FALSE,
                              pDCI->DomainName,
                              ErrorBuffer,
                              NULL );
            }
            DBGMSG(DBG_WARNING,("Can't crack GUID: %ws %ws\n", pDCI->DomainName, ErrorBuffer));
            dwRet = ERROR_FILE_NOT_FOUND;
            goto error;
        }


        if (bGetDNAndCN) {
            // Separate DN into CN & PublishPoint
            // pDNR has form: CN=CommonName,DN...

            hr = FQDN2CNDN(pDCI->DomainControllerName + 2, pDNR->rItems[0].pName, ppszCN, ppszDN);
            BAIL_ON_FAILURE(hr);

        } else {

            hr = BuildLDAPPath(pDCI->DomainControllerName + 2, pDNR->rItems[0].pName, ppszDN);
            BAIL_ON_FAILURE(hr);
        }
    }


error:

    if (pDNR)
        DsFreeNameResult(pDNR);

    if (hDS)
        DsUnBind(&hDS);

    if (pDCI)
        NetApiBufferFree(pDCI);

    if (dwRet != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwRet);
    }

    if (FAILED(hr)) {
        if (ppszCN) {
            FreeSplMem(*ppszCN);
            *ppszCN = NULL;
        }
        if (ppszDN) {
            FreeSplMem(*ppszDN);
            *ppszDN = NULL;
        }
    }

    return hr;
}


HRESULT
FQDN2CNDN(
    PWSTR   pszDCName,
    PWSTR   pszFQDN,
    PWSTR   *ppszCN,
    PWSTR   *ppszDN
)
{
    IADs    *pADs = NULL;
    PWSTR   pszCN = NULL;
    PWSTR   pszDN = NULL;
    PWSTR   pszLDAPPath = NULL;
    HRESULT hr;

    // Get LDAP path to object
    hr = BuildLDAPPath(pszDCName, pszFQDN, &pszLDAPPath);
    BAIL_ON_FAILURE(hr);

    // Get DN
    hr = ADsGetObject(pszLDAPPath, IID_IADs, (void **) &pADs);
    BAIL_ON_FAILURE(hr);

    hr = pADs->get_Parent(&pszDN);
    BAIL_ON_FAILURE(hr);

    if (!(*ppszDN = AllocSplStr(pszDN))) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    // Get CN
    hr = pADs->get_Name(&pszCN);
    BAIL_ON_FAILURE(hr);

    if (!(*ppszCN = AllocSplStr(pszCN))) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }


error:

    if (pADs)
        pADs->Release();

    if (pszCN)
        SysFreeString(pszCN);

    if (pszDN)
        SysFreeString(pszDN);

    FreeSplStr(pszLDAPPath);

    if (FAILED(hr)) {
        FreeSplStr(*ppszCN);
        FreeSplStr(*ppszDN);
    }

    return hr;
}


HRESULT
BuildLDAPPath(
    PWSTR   pszDC,
    PWSTR   pszFQDN,
    PWSTR   *ppszLDAPPath
)
{
    PWSTR   pszEscapedFQDN = NULL;
    DWORD   nBytes;
    HRESULT hr = S_OK;

    //
    // pszFQDN is assumed to contain escaped DN_SPECIAL_CHARS characters, but 
    // ADSI has additional special characters that need to be escaped before using
    // the LDAP path in ADSI calls.
    //
    pszEscapedFQDN = CreateEscapedString(pszFQDN, ADSI_SPECIAL_CHARS);
    if (!pszEscapedFQDN) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    // LDAP:// + pDCName + / + pName + 1
    nBytes = (wcslen(pszDC) + wcslen(pszEscapedFQDN) + 9)*sizeof(WCHAR);

    if (!(*ppszLDAPPath = (PWSTR) AllocSplMem(nBytes))) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    wsprintf(*ppszLDAPPath, L"LDAP://%ws/%ws", pszDC, pszEscapedFQDN);

error:

    FreeSplStr(pszEscapedFQDN);

    return hr;
}    


HRESULT
GetPrintQueueContainer(
    HANDLE          hPrinter,
    IADsContainer   **ppADsContainer,
    IADs            **ppADs
)
/*++
Function Description:
    This function returns the container and, if it exists, the PrintQueue object pointer
    corresponding to the supplied printer handle

Parameters:
    hPrinter - printer handle
    ppADsContainer - return Container ADsPath. Caller frees via ppADsContainer->Release().
    ppADs - return PrintQueue object ADsPath.  Caller frees via ppADs->Release().

Return Values:
    If successful, returns the printqueue container and, if found, the printqueue dispatch.
    If there is no printqueue, the dispatch is set to NULL and the default container is returned.
--*/
{
    HRESULT         hr;
    PSPOOL          pSpool = (PSPOOL) hPrinter;
    PINIPRINTER     pIniPrinter = pSpool->pIniPrinter;
    WCHAR           ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];
    DWORD           nBytes;
    PWSTR           pszObjectGUID = NULL;
    IDispatch       *pPrintQDispatch = NULL;
    LPWSTR          pszPrinterObjectGUID = pIniPrinter->pszObjectGUID;
    LPWSTR          pszPrinterDN = pIniPrinter->pszDN;
    LPWSTR          pszPrinterCN = pIniPrinter->pszCN;


    *ppADsContainer = NULL;
    *ppADs = NULL;

    //
    // Try quick search for object using known properties.
    //
    // We are outside Spooler CS and  pIniPrinter->pszObjectGUID, 
    // pIniPrinter->pszDN, pIniPrinter->pszCN might get changed by
    // the DS background thread. In the case they are set to NULL,
    // we'll take an AV. So, even if they change or are set to NULL,
    // we'll use whatever we have when we entered the function. 
    // The worst that can happen is to find a DS printQueue
    // object that doesn't last till we use it, which is fine. This 
    // is already assumed. Or, to not find a DS printQueue that will
    // be created just after we query the DS. This is also fine.
    //
    if (pszPrinterObjectGUID &&
        pszPrinterDN &&
        pszPrinterCN) {

        // Try to get the container using existing DN
        hr = ADsGetObject(  pszPrinterDN,
                            IID_IADsContainer,
                            (void **) ppADsContainer
                            );

        if (SUCCEEDED(hr)) {

            // Verify that printqueue exists in this container
            hr = (*ppADsContainer)->GetObject(  SPLDS_PRINTER_CLASS,
                                                pszPrinterCN,
                                                &pPrintQDispatch);

            // Verify that the found printQueue object has the same GUID
            if (SUCCEEDED(hr) && pPrintQDispatch) {
                hr = pPrintQDispatch->QueryInterface(IID_IADs, (void **) ppADs);
                BAIL_ON_FAILURE(hr);

                hr = GetGUID(*ppADs, &pszObjectGUID);
                BAIL_ON_FAILURE(hr);

                if (wcscmp(pszObjectGUID, pszPrinterObjectGUID))
                    hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND);
            } else {
                hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND);
            }
        }
    } else {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND);
    }

    // Couldn't find container or printQueue, so find by GUID or get default container
    if (FAILED(hr)) {

        // The following items may have been allocated above and need to be freed
        // here since we're going to reallocate them
        if (pPrintQDispatch) {
            pPrintQDispatch->Release();
            pPrintQDispatch = NULL;
        }
        if (*ppADsContainer) {
            (*ppADsContainer)->Release();
            *ppADsContainer = NULL;
        }
        if (*ppADs) {
            (*ppADs)->Release();
            *ppADs = NULL;
        }


        // find or create pszDN and pszCN
        hr = GetPublishPoint(hPrinter);
        BAIL_ON_FAILURE(hr);

        SPLASSERT(pIniPrinter->pszDN);

        hr = ADsGetObject(  pIniPrinter->pszDN,
                            IID_IADsContainer,
                            (void **) ppADsContainer
                            );

        if (FAILED(hr)) {
            wsprintf(ErrorBuffer, L"%0x", hr);
            DBGMSG(DBG_WARNING,("Can't get Container: %ws, %ws\n", pIniPrinter->pszDN, ErrorBuffer));
            SplLogEvent(  ((PSPOOL) hPrinter)->pIniSpooler,
                          gdwLogDsEvents & LOG_ERROR,
                          MSG_CANT_GET_CONTAINER,
                          FALSE,
                          pIniPrinter->pszDN,
                          ErrorBuffer,
                          NULL );

            BAIL_ON_FAILURE(hr);
        }


        // Try to get the printqueue, but don't error out if we can't
        (*ppADsContainer)->GetObject(   SPLDS_PRINTER_CLASS,
                                        pIniPrinter->pszCN,
                                        &pPrintQDispatch);
        if (pPrintQDispatch)
            pPrintQDispatch->QueryInterface(IID_IADs, (void **) ppADs);
    }


error:


    if (pPrintQDispatch)
        pPrintQDispatch->Release();

    FreeSplStr(pszObjectGUID);

    return hr;
}



HRESULT
GetCommonName(
    HANDLE hPrinter,
    PWSTR  pszServerName,
    PWSTR  pszPrinterName,
    PWSTR  pszDN,
    PWSTR  *ppszCommonName
)
/*++
Function Description:
    This function returns a standard format Common Name of the PrintQueue object
    generated from the supplied Server and Printer names

Parameters:
    hPrinter - printer handle
    pszServerName - name of a server
    pszPrinterName - name of a printer on the server
    pszDN - container DN
    ppszCommonName - return CommonName. Caller frees via FreeSplMem().

Return Values:
    HRESULT
--*/
{
    DWORD nBytes;
    PWSTR psz;
    PWSTR pszPrinterNameStart = pszPrinterName;

    // "CN=Server-Printer"
    nBytes = (wcslen(pszPrinterName) + wcslen(pszServerName) + 5)*sizeof(WCHAR);

    // We need to also make room for a unique number if there is a conflict
    if (nBytes < MIN_CN)
        nBytes = MIN_CN;

    if (!(*ppszCommonName = psz = (PWSTR) AllocSplMem(nBytes))) {
        return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
    }

    // CN=
    wcscpy(psz, L"CN=");

    // Server
    for(psz += 3, pszServerName += 2 ; *pszServerName    ; ++psz, ++pszServerName) {
        *psz = wcschr(DN_SPECIAL_CHARS, *pszServerName) ? TEXT('_') : *pszServerName;
    }
    *psz = L'-';

    // Printer
    for(++psz; *pszPrinterName ; ++psz, ++pszPrinterName) {
        *psz = wcschr(DN_SPECIAL_CHARS, *pszPrinterName) ? TEXT('_') : *pszPrinterName;
    }

    // NULL
    *psz = *pszPrinterName;

    // DS only allows 64 characters in CN attribute, so shorten this if needed
    if (wcslen(*ppszCommonName) > MAX_CN - 1) {
        (*ppszCommonName)[MAX_CN] = NULL;
    }

    // Generate a non-conflicting name in this container
    GetUniqueCN(pszDN, ppszCommonName, pszPrinterNameStart);

    return S_OK;
}


VOID
GetUniqueCN(
    PWSTR pszDN,
    PWSTR *ppszCommonName,
    PWSTR pszPrinterName
)
{
    // Check if an object with this CN already exists in this container

    // Get Container
    IADsContainer   *pADsContainer = NULL;
    UINT32          CN;     // This is a "random" number we append to the common name to make it unique

    CN = (UINT32) (ULONG_PTR) &CN;   // Initialize with some random number

    HRESULT hr = ADsGetObject(pszDN, IID_IADsContainer, (void **) &pADsContainer);

    if (SUCCEEDED(hr)) {

        BOOL bTryAgain;

        do {
            IDispatch   *pPrintQDispatch = NULL;
            bTryAgain = FALSE;

            // Get PrintQueue, if it exists
            pADsContainer->GetObject(  SPLDS_PRINTER_CLASS,
                                       *ppszCommonName,
                                       &pPrintQDispatch);
            if (pPrintQDispatch) {

                IADs *pADs = NULL;

                hr = pPrintQDispatch->QueryInterface(IID_IADs, (void **) &pADs);

                if (SUCCEEDED(hr)) {

                    // Generate a unique Common Name.
                    UINT32  cchCommonName = wcslen(*ppszCommonName);
                    PWSTR   pszDigits;

                    if (cchCommonName >= MIN_CN) {
                        pszDigits = *ppszCommonName + cchCommonName - UNIQUE_NUMBER_SIZE;
                    } else {
                        pszDigits = *ppszCommonName + 3;    // CN=
                    }
                    bTryAgain = TRUE;
                    wsprintf(pszDigits, L"%010d", ++CN);

                    pADs->Release();
                }
                pPrintQDispatch->Release();
            }
        } while(bTryAgain);

        pADsContainer->Release();
    }
}



HRESULT
GetDefaultPublishPoint(
    HANDLE hPrinter,
    PWSTR *ppszDN
)
/*++
Function Description:
    This function returns the default publish point (Container) of a PrintQueue
    based on the supplied printer handle.

Parameters:
    hPrinter - printer handle
    ppszDN - return default PrintQueue container.  Caller frees via FreeSplMem()

Return Values:
    HRESULT
--*/
{
    WCHAR szServerName[MAX_COMPUTERNAME_LENGTH + 1];
    WCHAR szName[MAX_PATH + 1];
    DWORD nSize;
    HANDLE hDS = NULL;
    DWORD dwRet = ERROR_SUCCESS;
    BOOL bRet;
    PWSTR pNames[2];
    DS_NAME_RESULT *pDNR = NULL;
    DOMAIN_CONTROLLER_INFO *pDCI = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDsRole = NULL;
    WCHAR   ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];
    HRESULT hr = S_OK;


    // Get Computer name

    nSize = MAX_COMPUTERNAME_LENGTH + 1;
    if (!(bRet = GetComputerName(szServerName, &nSize))) {
        dwRet = GetLastError();
        goto error;
    }


    // Get Domain name
    dwRet = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *) &pDsRole);
    if (dwRet) {
        wsprintf(ErrorBuffer, L"%0x", dwRet);
        DBGMSG(DBG_WARNING,("Can't get Primary Domain Info: %ws\n", ErrorBuffer));
        SplLogEvent(((PSPOOL) hPrinter)->pIniSpooler,
                   gdwLogDsEvents & LOG_ERROR,
                   MSG_CANT_GET_PRIMARY_DOMAIN_INFO,
                   FALSE,
                   ErrorBuffer,
                   NULL );
        goto error;
    }

    // Domain\Server
    wsprintf(szName, L"%ws\\%ws$", pDsRole->DomainNameFlat, szServerName);
    pNames[0] = szName;
    pNames[1] = NULL;


    dwRet = Bind2DS(&hDS, &pDCI, DS_DIRECTORY_SERVICE_PREFERRED);
    if (dwRet != ERROR_SUCCESS) {
        wsprintf(ErrorBuffer, L"%0x", dwRet);
        DBGMSG(DBG_WARNING,("Can't get DNS Domain Name: %ws\n", ErrorBuffer));
        SplLogEvent(  ((PSPOOL) hPrinter)->pIniSpooler,
                   gdwLogDsEvents & LOG_ERROR,
                   MSG_CANT_GET_DNS_DOMAIN_NAME,
                   FALSE,
                   ErrorBuffer,
                   NULL );
        goto error;
    }


    // Get Publish Point

    if (ppszDN) {
        if (!(DsCrackNames(
                        hDS,
                        DS_NAME_NO_FLAGS,
                        DS_UNKNOWN_NAME,
                        DS_FQDN_1779_NAME,
                        1,
                        &pNames[0],
                        &pDNR) == ERROR_SUCCESS)) {

            dwRet = GetLastError();

            wsprintf(ErrorBuffer, L"%0x", dwRet);
            DBGMSG(DBG_WARNING,("Can't Crack Name: %ws, %ws\n", pDCI->DomainName, ErrorBuffer));
            SplLogEvent(  ((PSPOOL) hPrinter)->pIniSpooler,
                       gdwLogDsEvents & LOG_ERROR,
                       MSG_CANT_CRACK,
                       FALSE,
                       pDCI->DomainName,
                       ErrorBuffer,
                       NULL );
            goto error;
        }

        if (pDNR->rItems[0].status != DS_NAME_NO_ERROR) {
            dwRet = DsCrackNamesStatus2Win32Error(pDNR->rItems[0].status);

            wsprintf(ErrorBuffer, L"%0x", dwRet);
            DBGMSG(DBG_WARNING,("Can't Crack Name: %ws, %ws\n", pDCI->DomainName, ErrorBuffer));
            SplLogEvent(  ((PSPOOL) hPrinter)->pIniSpooler,
                       gdwLogDsEvents & LOG_ERROR,
                       MSG_CANT_CRACK,
                       FALSE,
                       pDCI->DomainName,
                       ErrorBuffer,
                       NULL );
            goto error;
        }

        // LDAP:// + pDCName + / + pName + 1
        hr = BuildLDAPPath(pDCI->DomainControllerName + 2, pDNR->rItems[0].pName, ppszDN);
        BAIL_ON_FAILURE(hr);
    }


error:

    if (pDNR)
        DsFreeNameResult(pDNR);

    if (hDS)
        DsUnBind(&hDS);

    if (pDCI)
        NetApiBufferFree(pDCI);

    if (pDsRole)
        DsRoleFreeMemory((PVOID) pDsRole);

    // If dwRet has no facility, then make into HRESULT
    if (dwRet != ERROR_SUCCESS) {
        if (HRESULT_CODE(dwRet) == dwRet) {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwRet);
        } else {
            hr = dwRet;
        }
    }

    // Finally, make absolutely sure we are failing if *ppszDN is NULL
    if (hr == S_OK && (!ppszDN || !*ppszDN)) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND); 
    }

    return hr;
}


//  Utility routine to report if a printer is color or monochrome

BOOL
ThisIsAColorPrinter(
    LPCTSTR lpstrName
)
/*++
Function Description:
    This function determines whether or not a printer supports color printing

Parameters:
    lpstrName - Printer name

Return Values:
    If printer supports color, return is TRUE.  Otherwise, return value is FALSE
--*/
{
    HANDLE      hPrinter = NULL;
    LPTSTR      lpstrMe = const_cast <LPTSTR> (lpstrName);
    BOOL        bReturn = FALSE;
    LPDEVMODE   lpdm = NULL;
    long        lcbNeeded;

    if  (!(*pfnOpenPrinter)(lpstrMe, &hPrinter, NULL)) {
        DBGMSG(DBG_WARNING, ("Unable to open printer '%ws'- error %d\n", lpstrName,
            GetLastError()));
        goto error;
    }


    //  First, use DocumentProperties to find the correct DEVMODE size- we
    //  must use the DEVMODE to force color on, in case the user's defaults
    //  have turned it off...

    lcbNeeded = (*pfnDocumentProperties)(NULL, hPrinter, lpstrMe, NULL, NULL, 0);

    if  (lcbNeeded <= 0) {
        DBGMSG( DBG_WARNING,
                ("Document Properties (get size) for '%ws' returned %d\n",
                lpstrName,lcbNeeded));
        goto error;
    }

    lpdm = (LPDEVMODE) AllocSplMem(lcbNeeded);
    if (lpdm) {

        lpdm->dmSize = sizeof(DEVMODE);
        lpdm->dmFields = DM_COLOR;
        lpdm->dmColor = DMCOLOR_COLOR;

        if (IDOK == (*pfnDocumentProperties)(NULL, hPrinter, lpstrMe, lpdm, lpdm, DM_IN_BUFFER | DM_OUT_BUFFER)) {

            //  Finally, we can create the DC!
            HDC hdcThis = CreateDC(NULL, lpstrName, NULL, lpdm);

            if  (hdcThis) {
                bReturn =  2 < (unsigned) GetDeviceCaps(hdcThis, NUMCOLORS);
                DeleteDC(hdcThis);
            }
        }
        else
            DBGMSG(DBG_WARNING, ("DocumentProperties (retrieve) on '%s' failed- error %d\n",
                                lpstrName, GetLastError()));
    }
    else
        DBGMSG(DBG_WARNING, ("ThisIsAColorPrinter(%s) failed to get %d bytes\n",
                                lpstrName, lcbNeeded));


error:

    FreeSplMem(lpdm);

    if (hPrinter)
        (*pfnClosePrinter)(hPrinter);

    return  bReturn;
}



HRESULT
GetGUID(
    IADs    *pADs,
    PWSTR   *ppszObjectGUID
)
/*++
Function Description:
    This function returns the ObjectGUID of a given ADs object.
    ppszObjectGUID must be freed by caller using FreeSplStr().

Parameters:
    pADs - input ADs object pointer
    ppszObjectGUID - object GUID of pADs

Return Values:
    HRESULT
--*/
{
    HRESULT     hr;
    LPOLESTR    pszObjectGUID = NULL;
    IID         ObjectIID;

    hr = pADs->GetInfo();

    if (SUCCEEDED(hr)) {
        hr = get_UI1Array_Property(pADs, L"ObjectGUID", &ObjectIID);

        if (SUCCEEDED(hr)) {
            hr = StringFromIID(ObjectIID, &pszObjectGUID);

            if (SUCCEEDED(hr)) {
                if (!(*ppszObjectGUID = AllocSplStr(pszObjectGUID)))
                    hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
            }
            CoTaskMemFree(pszObjectGUID);
        }
    }

    return hr;
}



BOOL
PrinterPublishProhibited()
{
    return !GetDwPolicy(szPublishPrinters, DEFAULT_PRINT_PUBLISH_POLICY);
}


DWORD
VerifyPublishedStatePolicy()
{
    return GetDwPolicy(szVerifyPublishedState, DEFAULT_VERIFY_PUBLISHED_STATE);
}


DWORD
PruneDownlevel()
{
    return GetDwPolicy(szPruneDownlevel, DEFAULT_PRUNE_DOWNLEVEL);
}

DWORD
PruningInterval(
)
{
    return GetDwPolicy(szPruningInterval, DEFAULT_PRUNING_INTERVAL);
}

DWORD
ImmortalPolicy(
)
{
    return GetDwPolicy(szImmortal, DEFAULT_IMMORTAL);
}

VOID
ServerThreadPolicy(
    BOOL bHaveDs
)
{
    DWORD dwPolicy;

    dwPolicy = GetDwPolicy(szServerThreadPolicy, SERVER_THREAD_UNCONFIGURED);

    if (dwPolicy == SERVER_THREAD_UNCONFIGURED) {
        ServerThreadRunning = !(bHaveDs ? SERVER_THREAD_OFF : SERVER_THREAD_ON);
    } else {
        ServerThreadRunning = !dwPolicy;
    }
    CreateServerThread();
}

DWORD
PruningRetries(
)
{
    DWORD dwPruningRetries;

    dwPruningRetries = GetDwPolicy(szPruningRetries, DEFAULT_PRUNING_RETRIES);

    if (dwPruningRetries > MAX_PRUNING_RETRIES)
        dwPruningRetries = MAX_PRUNING_RETRIES;

    return dwPruningRetries;
}

DWORD
PruningRetryLog(
)
{
    DWORD dwPruningRetryLog;

    dwPruningRetryLog = GetDwPolicy(szPruningRetryLog, DEFAULT_PRUNING_RETRY_LOG);

    return dwPruningRetryLog;
}

VOID
SetPruningPriority(
)
{
    DWORD dwPriority = GetDwPolicy(szPruningPriority, DEFAULT_PRUNING_PRIORITY);

    if (dwPriority != dwLastPruningPriority) {
        if (dwPriority == THREAD_PRIORITY_LOWEST          ||
            dwPriority == THREAD_PRIORITY_BELOW_NORMAL    ||
            dwPriority == THREAD_PRIORITY_NORMAL          ||
            dwPriority == THREAD_PRIORITY_ABOVE_NORMAL    ||
            dwPriority == THREAD_PRIORITY_HIGHEST) {
            SetThreadPriority(GetCurrentThread(), DEFAULT_PRUNING_PRIORITY);
        } else {
            SetThreadPriority(GetCurrentThread(), dwPriority);
        }
        dwLastPruningPriority = dwPriority;
    }
}



BOOL
ThisMachineIsADC(
)
{
    NT_PRODUCT_TYPE  NtProductType;
    RtlGetNtProductType(&NtProductType);
    return NtProductType == NtProductLanManNt;
}



DWORD
GetDomainRoot(
    PWSTR   *ppszDomainRoot
)
/*++
Function Description:
    This function returns the ADsPath of the root of the current domain

Parameters:
    ppszDomainRoot - pointer to buffer receiving string pointer of domain root ADsPath string
                     free ppszDomainRoot with a call to FreeSplMem

Return Values:
    DWORD

--*/
{
    DWORD                                dwRet = ERROR_SUCCESS;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDsRole = NULL;
    DS_NAME_RESULT                        *pDNR = NULL;
    DOMAIN_CONTROLLER_INFO                *pDCI = NULL;
    HANDLE                                hDS = NULL;
    WCHAR                                szName[MAX_PATH + 1];
    PWSTR                                pNames[2];
    PWSTR                               pszDomainRoot;
    DWORD                               cb;


    if (!ppszDomainRoot) {
        dwRet = ERROR_INVALID_PARAMETER;
        goto error;
    }

    // Get Domain name
    dwRet = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *) &pDsRole);
    if (dwRet)
        goto error;

    wsprintf(szName, L"%ws\\", pDsRole->DomainNameFlat);

    pNames[0] = szName;
    pNames[1] = NULL;


    dwRet = Bind2DS(&hDS, &pDCI, DS_DIRECTORY_SERVICE_PREFERRED);
    if (dwRet != ERROR_SUCCESS) {
        goto error;
    }

    if (!(DsCrackNames(
                    hDS,
                    DS_NAME_NO_FLAGS,
                    DS_UNKNOWN_NAME,
                    DS_FQDN_1779_NAME,
                    1,
                    &pNames[0],
                    &pDNR) == ERROR_SUCCESS)) {

        dwRet = GetLastError();
        goto error;
    }

    if (pDNR->rItems[0].status != DS_NAME_NO_ERROR) {
        dwRet = DsCrackNamesStatus2Win32Error(pDNR->rItems[0].status);
        goto error;
    }

    // LDAP:// + pDCName + 1
    cb = (wcslen(pDNR->rItems[0].pName) + 8)*sizeof(WCHAR);

    if (!(*ppszDomainRoot = (PWSTR) AllocSplMem(cb))) {
        dwRet = GetLastError();
        goto error;
    }
    wsprintf(*ppszDomainRoot, L"LDAP://%ws", pDNR->rItems[0].pName);

error:

    if (pDNR)
        DsFreeNameResult(pDNR);

    if (hDS)
        DsUnBind(&hDS);

    if (pDCI)
        NetApiBufferFree(pDCI);

    if (pDsRole)
        DsRoleFreeMemory((PVOID) pDsRole);

    return dwRet;
}



PWSTR
CreateSearchString(
    PWSTR pszIn
)
{
    PWSTR psz, pszSS;
    PWSTR pszSearchString = NULL;
    DWORD cb;

    /* Replace \ with \5c */

    /* Count chars & pad */

    for (cb = 0, psz = pszIn ; *psz ; ++psz, ++cb) {
        if (*psz == L'\\')
            cb += 2;
    }
    cb = (cb + 1)*sizeof *psz;

    if (pszSearchString = (PWSTR) GlobalAlloc(GMEM_FIXED, cb)) {

        for(psz = pszIn, pszSS = pszSearchString ; *psz ; ++psz, ++pszSS) {
            *pszSS = *psz;

            if (*psz == L'\\') {
                *++pszSS = L'5';
                *++pszSS = L'c';
            }
        }
        *pszSS = L'\0';
    }

    return pszSearchString;
}



BOOL
ServerOnSite(
    PWSTR   *ppszMySites,
    ULONG   cMySites,
    PWSTR   pszServer
)
/*++
Function Description:
    This function returns TRUE if pszServer is on one of the ppszMySites and pszServer exists

Parameters:
    ppszMySites - input sites
    pszServer - input server name

Return Values:
    BOOL - TRUE if server exists on site, FALSE otherwise or on error

--*/
{
    PSOCKET_ADDRESS pSocketAddresses = NULL;
    PWSTR           *ppszSiteNames = NULL;
    DWORD           nAddresses;
    DWORD           dwRet, i;
    ULONG           j;
    WORD            wVersion;
    WSADATA         WSAData;
    BOOL            bServerOnSite = FALSE;

    wVersion = MAKEWORD(1, 1);

    if (WSAStartup(wVersion, &WSAData) == ERROR_SUCCESS) {

        // Find out if Server is on Site
        GetSocketAddressesFromMachineName(pszServer, &pSocketAddresses, &nAddresses);

        if (nAddresses == 0) {
            bServerOnSite = TRUE;   // Claim server is on site if we can't find it
        } else {
            dwRet = DsAddressToSiteNames(   (PCWSTR) NULL,
                                            nAddresses,
                                            pSocketAddresses,
                                            &ppszSiteNames);
            if (dwRet == NO_ERROR) {
                for(i = 0 ; i < nAddresses ; ++i) {
                    for(j = 0 ; j < cMySites ; ++j) {
                        if (ppszSiteNames[i] && ppszMySites[j] && !wcscmp(ppszSiteNames[i], ppszMySites[j])) {
                            bServerOnSite = TRUE;
                            break;
                        }
                    }
                }
            }
        }

        if (ppszSiteNames)
            NetApiBufferFree(ppszSiteNames);

        if (pSocketAddresses)
            FreeSplSockets(pSocketAddresses, nAddresses);

        WSACleanup();
    }

    return bServerOnSite;
}


VOID
FreeSplSockets(
    PSOCKET_ADDRESS  pSocketAddress,
    DWORD            nAddresses
)
{
    DWORD           i;
    PSOCKET_ADDRESS  pSocket;

    for(i = 0, pSocket = pSocketAddress ; i < nAddresses ; ++i, ++pSocket)
        FreeSplMem(pSocket->lpSockaddr);

    FreeSplMem(pSocketAddress);
}


VOID
AllocSplSockets(
    struct hostent  *pHostEnt,
    PSOCKET_ADDRESS *ppSocketAddress,
    DWORD           *nSocketAddresses
)
{
    DWORD           i;
    PSOCKET_ADDRESS pSocket;

    for ( *nSocketAddresses  = 0 ; pHostEnt->h_addr_list[*nSocketAddresses] ; ++(*nSocketAddresses))
        ;

    // Allocate SOCKET_ADDRESS array
    *ppSocketAddress = (PSOCKET_ADDRESS) AllocSplMem(*nSocketAddresses*sizeof(SOCKET_ADDRESS));
    if (!*ppSocketAddress)
        *nSocketAddresses = 0;

    // Allocate Sockaddr element for each SOCKET_ADDRESS
    // If we fail partway through, just use partial list
    for (i = 0, pSocket = *ppSocketAddress ; i < *nSocketAddresses ; ++i, ++pSocket) {
        if (!(pSocket->lpSockaddr = (struct sockaddr *) AllocSplMem(sizeof(struct sockaddr_in)))) {
            *nSocketAddresses = i;
            break;
        }
        if (pHostEnt->h_addrtype == AF_INET) {
            ((struct sockaddr_in *) pSocket->lpSockaddr)->sin_family = AF_INET;
            ((struct sockaddr_in *) pSocket->lpSockaddr)->sin_addr = *(struct in_addr *) pHostEnt->h_addr_list[i];
            pSocket->iSockaddrLength = sizeof(struct sockaddr_in);
        } else {
            DBGMSG(DBG_WARNING,("AllocSplSockets: addrtype != AF_INET: %d\n", pHostEnt->h_addrtype));
        }
    }
}


VOID
GetSocketAddressesFromMachineName(
    PWSTR           pszMachineName,     // \\Machine
    PSOCKET_ADDRESS *ppSocketAddress,
    DWORD           *nSocketAddresses
)
/*++

Routine Description:
    This routine builds list of names other than the machine name that
    can be used to call spooler APIs.

--*/
{
    struct hostent     *HostEnt;
    PSTR                pszAnsiMachineName = NULL;
    DWORD               iWsaError;

    *nSocketAddresses  = 0;
    *ppSocketAddress = 0;

    if (pszAnsiMachineName = (PSTR) AllocSplStr(pszMachineName + 2)) {
        if (UnicodeToAnsiString((PWSTR) pszAnsiMachineName, pszAnsiMachineName, NULL_TERMINATED)) {
            if (HostEnt = gethostbyname(pszAnsiMachineName)) {
                AllocSplSockets(HostEnt, ppSocketAddress, nSocketAddresses);
            } else {
                iWsaError = WSAGetLastError();
                DBGMSG(DBG_WARNING, ("gethostbyname failed in DsPrune: %d\n", iWsaError));
            }
        }
    }

    FreeSplMem(pszAnsiMachineName);
}


DWORD
UNC2Server(
    PCWSTR pszUNC,
    PWSTR *ppszServer
)
{
    PWSTR psz;
    DWORD cb;
    DWORD nChars;

    if (!pszUNC || pszUNC[0] != L'\\' || pszUNC[1] != L'\\')
        return ERROR_INVALID_PARAMETER;

    if(!(psz = wcschr(pszUNC + 2, L'\\')))
        return ERROR_INVALID_PARAMETER;

    cb = (DWORD) ((ULONG_PTR) psz - (ULONG_PTR) pszUNC + sizeof *psz);

    if (!(*ppszServer = (PWSTR) AllocSplMem(cb)))
        return GetLastError();


    nChars = (DWORD) (psz - pszUNC);
    wcsncpy(*ppszServer, pszUNC, nChars);
    (*ppszServer)[nChars] = L'\0';

    return ERROR_SUCCESS;
}




BOOL
ServerExists(
    PWSTR   pszServerName
)
{
    NET_API_STATUS  Status;
    SERVER_INFO_100 *pServer;
    BOOL            bServerExists;

    Status = NetServerGetInfo(pszServerName, 100, (PBYTE *) &pServer);
    bServerExists = !Status;
    Status = NetApiBufferFree(pServer);

    return bServerExists;
}



HRESULT
UnpublishByGUID(
    PINIPRINTER pIniPrinter
)
{
    HRESULT         hr;

    SplOutSem();

    if (!pIniPrinter->pszObjectGUID) {
        pIniPrinter->DsKeyUpdate = 0;
        pIniPrinter->DsKeyUpdateForeground = 0;
        hr = S_OK;

    } else {

        PWSTR           pszDN = NULL;
        PWSTR           pszCN = NULL;

        hr = GetPublishPointFromGUID(NULL, pIniPrinter->pszObjectGUID, &pszDN, &pszCN, TRUE);

        DBGMSG(DBG_EXEC,
               ("UnpublishByGUID: GUID %ws\n", pIniPrinter->pszObjectGUID));

        if (SUCCEEDED(hr)) {

            DBGMSG(DBG_EXEC,
                   ("UnpublishByGUID: DN %ws CN %ws\n",
                    pszDN,
                    pszCN));

            IADsContainer *pADsContainer = NULL;

            // Get the container
            hr = ADsGetObject(  pszDN,
                                IID_IADsContainer,
                                (void **) &pADsContainer
                                );

            if (SUCCEEDED(hr)) {
                hr = pADsContainer->Delete(SPLDS_PRINTER_CLASS, pszCN);
                pADsContainer->Release();
            }

            // If the container or the object is gone, succeed
            if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT) ||
                HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND ||
                HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND)
                hr = S_OK;

        }
        FreeSplStr(pszDN);
        FreeSplStr(pszCN);
    }


    // free GUID if object is deleted
    if (SUCCEEDED(hr)) {
        pIniPrinter->DsKeyUpdate = 0;
        pIniPrinter->DsKeyUpdateForeground = 0;

        FreeSplStr(pIniPrinter->pszObjectGUID);
        pIniPrinter->pszObjectGUID = NULL;

        FreeSplStr(pIniPrinter->pszCN);
        pIniPrinter->pszCN = NULL;

        FreeSplStr(pIniPrinter->pszDN);
        pIniPrinter->pszDN = NULL;

        EnterSplSem();

        if (pIniPrinter->bDsPendingDeletion) {
            pIniPrinter->bDsPendingDeletion = 0;
            DECPRINTERREF(pIniPrinter);
        }

        LeaveSplSem();


        DBGMSG(DBG_EXEC, ("UnpublishByGUID Succeeded\n"));
    } else {
        pIniPrinter->DsKeyUpdate = DS_KEY_UNPUBLISH;
        DBGMSG(DBG_EXEC, ("UnpublishByGUID Failed\n"));
    }

    SplOutSem();

    return hr;
}


HRESULT
GetDNSMachineName(
    PWSTR pszShortMachineName,
    PWSTR *ppszMachineName
)
{
    struct  hostent  *pHostEnt;
    DWORD   dwRet   = ERROR_SUCCESS;
    HRESULT hr      = S_OK;
    PSTR    pszAnsiMachineName = NULL;
    WORD    wVersion;
    WSADATA WSAData;

    wVersion = MAKEWORD(1, 1);

    dwRet = WSAStartup(wVersion, &WSAData);
    
    if (dwRet == ERROR_SUCCESS) {

        if (!pszShortMachineName || !*pszShortMachineName) {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_PARAMETER);
            BAIL_ON_FAILURE(hr);
        }

        if (!(pszAnsiMachineName = (PSTR) AllocSplStr(pszShortMachineName))) {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        if (!UnicodeToAnsiString((PWSTR) pszAnsiMachineName, pszAnsiMachineName, NULL_TERMINATED)) {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        if (!(pHostEnt = gethostbyname(pszAnsiMachineName))) {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, WSAGetLastError());
            BAIL_ON_FAILURE(hr);
        }

        if (!(*ppszMachineName = AnsiToUnicodeStringWithAlloc(pHostEnt->h_name))) {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
            BAIL_ON_FAILURE(hr);
        }        

    } else {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwRet);
    }

error:

    if (dwRet == ERROR_SUCCESS)
    {
        WSACleanup();
    }

    FreeSplMem(pszAnsiMachineName);

    return hr;
}


HRESULT
GetClusterUser(
    IADs    **ppADs
)
{
    HRESULT         hr;
    WCHAR           szUserName[MAX_PATH + 8];   // Allow for LDAP://
    PWSTR           pszUserName = szUserName;
    DWORD           cchUserName = MAX_PATH + 1;
    BOOL            bRet;


    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr))
        return hr;

    // Get cluster container's name, which must be the current user name
    wcscpy(pszUserName, L"LDAP://");
    if (!GetUserNameEx(NameFullyQualifiedDN, pszUserName + 7, &cchUserName)) {
        if (cchUserName > MAX_PATH + 1) {

            pszUserName = (PWSTR) AllocSplMem((cchUserName + 7)*sizeof(WCHAR));
            if (!pszUserName) {
                hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
                goto error;
            }

            wcscpy(pszUserName, L"LDAP://");

            if (!GetUserNameEx(NameFullyQualifiedDN, pszUserName + 7, &cchUserName)) {
                hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
                goto error;
            }

        } else {
            hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
            goto error;
        }
    }

    // Get the object
    hr = ADsGetObject(  pszUserName,
                        IID_IADs,
                        (void **) ppADs
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pszUserName != szUserName)
        FreeSplStr(pszUserName);

    CoUninitialize();

    return hr;
}


HRESULT
FQDN2Whatever(
    PWSTR pszIn,
    PWSTR *ppszOut,
    DS_NAME_FORMAT  NameFormat
)
{
    DWORD                               dwRet = ERROR_SUCCESS;
    DS_NAME_RESULT                      *pDNR = NULL;
    DOMAIN_CONTROLLER_INFO              *pDCI = NULL;
    HANDLE                              hDS = NULL;
    PWSTR                               pNames[2];
    PWSTR                               psz;
    HRESULT                             hr = S_OK;


    *ppszOut = NULL;

    // Get the DC name
    dwRet = Bind2DS(&hDS, &pDCI, DS_DIRECTORY_SERVICE_PREFERRED);
    if (dwRet != ERROR_SUCCESS)
        goto error;

    // Translate the name
    if (wcslen(pszIn) < 8) {
        dwRet = ERROR_INVALID_PARAMETER;
        goto error;
    }

    psz = wcschr(pszIn + 7, L'/');
    if (!psz) {
        dwRet = ERROR_INVALID_PARAMETER;
        goto error;
    }

    pNames[0] = ++psz;  // Input string is LDAP://ntdev.microsoft.com/CN=...  Strip off the LDAP://.../ portion
    pNames[1] = NULL;

    if (!(DsCrackNames(
                    hDS,
                    DS_NAME_NO_FLAGS,
                    DS_FQDN_1779_NAME,
                    NameFormat,
                    1,
                    &pNames[0],
                    &pDNR) == ERROR_SUCCESS)) {

        dwRet = GetLastError();
        goto error;
    }

    if (pDNR->rItems[0].status != DS_NAME_NO_ERROR) {
        dwRet = DsCrackNamesStatus2Win32Error(pDNR->rItems[0].status);
        goto error;
    }

    *ppszOut = AllocSplStr(pDNR->rItems[0].pName);


error:

    if (pDNR)
        DsFreeNameResult(pDNR);

    if (hDS)
        DsUnBind(&hDS);

    if (pDCI)
        NetApiBufferFree(pDCI);


    return dwRet == ERROR_SUCCESS ? S_OK : MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwRet);
}



DWORD
InitializeDSClusterInfo(
    PINISPOOLER     pIniSpooler,
    HANDLE          *phToken
)
{
    HRESULT hr = S_OK;
    DWORD   dwError = ERROR_SUCCESS;
    IADs    *pADs = NULL;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr)) {
        return HRESULT_CODE(hr);
    }


    // Impersonate the client
    if (!ImpersonatePrinterClient(*phToken)) {
        dwError = GetLastError();
        DBGMSG(DBG_WARNING,("InitializeDSClusterInfo FAILED: %d\n", dwError));
        CoUninitialize();
        return dwError;
    }


    // Get a copy of the client token
    dwError = NtOpenThreadToken(NtCurrentThread(), TOKEN_IMPERSONATE, TRUE, &pIniSpooler->hClusterToken);
    if (dwError != STATUS_SUCCESS) {
        DBGMSG(DBG_WARNING,("InitializeDSClusterInfo DuplicateToken FAILED: %d\n", dwError));
        pIniSpooler->hClusterToken = INVALID_HANDLE_VALUE;
        goto error;
    }

    // Get the Cluster User Object
    hr = GetClusterUser(&pADs);

    // Get the GUID to the Cluster User Object
    if (SUCCEEDED(hr))
        hr = GetGUID(pADs, &pIniSpooler->pszClusterGUID);


error:

    *phToken = RevertToPrinterSelf();

    if (FAILED(hr)) {
        dwError = HRESULT_CODE(hr);
        FreeSplStr(pIniSpooler->pszClusterGUID);
        pIniSpooler->pszClusterGUID = NULL;
    }

    if (pADs)
        pADs->Release();

    CoUninitialize();

    return dwError;
}



BOOL
CheckPublishedPrinters(
)
{
    PINIPRINTER pIniPrinter;
    BOOL        bHavePublishedPrinters = FALSE;

    SplInSem();

    if (VerifyPublishedStatePolicy() == INFINITE)
        return FALSE;

    RunForEachSpooler(&bHavePublishedPrinters, CheckPublishedSpooler);

    return bHavePublishedPrinters;
}

BOOL
CheckPublishedSpooler(
    HANDLE      h,
    PINISPOOLER pIniSpooler
)
{
    PBOOL       pbHavePublishedPrinters = (PBOOL)h;
    PINIPRINTER pIniPrinter;

    if (!(pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL))
        return TRUE;

    for (pIniPrinter = pIniSpooler->pIniPrinter ; pIniPrinter ; pIniPrinter = pIniPrinter->pNext) {
        if (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED) {

            // Refresh: verify that we're really published
            // Note that if there isn't any new info to publish and we're published,
            // we won't do any SetInfo so the overhead is minimal
            pIniPrinter->DsKeyUpdate |= DS_KEY_PUBLISH;
            *pbHavePublishedPrinters = TRUE;

        } else if (pIniPrinter->pszObjectGUID) {

            // The only way we can get here is if someone is unpublishing the printer,
            // so we don't really need to set the background DsKeyUpdate state.  Doing
            // so maintains symmetry with above statement and InitializeDS
            pIniPrinter->DsKeyUpdate |= DS_KEY_UNPUBLISH;
            *pbHavePublishedPrinters = TRUE;
        }
    }

    return TRUE;
}


PWSTR
CreateEscapedString(
    PCWSTR pszIn,
    PCWSTR pszSpecialChars
)
{
    PWSTR psz, pszO;
    PWSTR pszOut = NULL;
    DWORD cb;

    if (!pszIn || !pszSpecialChars) {
        SetLastError(ERROR_INVALID_NAME);
        return NULL;
    }    

    // Count special characters
    for (cb = 0, psz = (PWSTR) pszIn ; psz = wcspbrk(psz, pszSpecialChars) ; ++cb, ++psz)
        ;

    // Add in length of input string
    cb = (wcslen(pszIn) + cb + 1)*sizeof *pszIn;    

    // Allocate output buffer and precede special DS chars with '\'
    if (pszOut = (PWSTR) AllocSplMem(cb)) {

        for(psz = (PWSTR) pszIn, pszO = pszOut ; *psz ; ++psz, ++pszO) {
            if (wcschr(pszSpecialChars, *psz)) {
                *pszO++ = L'\\';
            }
            *pszO = *psz;
        }
        *pszO = L'\0';
    }

    return pszOut;
}


PWSTR
DevCapStrings2MultiSz(
    PWSTR   pszDevCapString,
    DWORD   nDevCapStrings,
    DWORD   dwDevCapStringLength,
    DWORD   *pcbBytes
)
{
    DWORD   i, cbBytes, cbSize;
    PWSTR   pszMultiSz = NULL;
    PWSTR   pStr;


    if (!pszDevCapString || !pcbBytes)
        return NULL;

    *pcbBytes = 0;

    //
    // Devcap buffers may not be NULL terminated
    //
    cbBytes = (nDevCapStrings*(dwDevCapStringLength + 1) + 1)*sizeof(WCHAR);


    //
    // Allocate and copy
    //
    if (pszMultiSz = (PWSTR) AllocSplMem(cbBytes)) {
        for(i = 0, pStr = pszMultiSz, cbBytes = 0 ; i < nDevCapStrings ; ++i, pStr += cbSize, cbBytes +=cbSize ) {
            wcsncpy(pStr, pszDevCapString + i*dwDevCapStringLength, dwDevCapStringLength);
            cbSize = *pStr ? wcslen(pStr) + 1 : 0;
        }
        *pStr = L'\0';
        *pcbBytes = (cbBytes + 1) * sizeof(WCHAR);
    }

    return pszMultiSz;
}

DWORD
Bind2DS(
    HANDLE                  *phDS,
    DOMAIN_CONTROLLER_INFO  **ppDCI,
    ULONG                   Flags
)
{
    DWORD dwRet;

    dwRet = DsGetDcName(NULL, NULL, NULL, NULL, Flags, ppDCI);
    if (dwRet == ERROR_SUCCESS) {

        if ((*ppDCI)->Flags & DS_DS_FLAG) {

            dwRet = DsBind (NULL, (*ppDCI)->DomainName, phDS);
            if (dwRet != ERROR_SUCCESS) {

                NetApiBufferFree(*ppDCI);
                *ppDCI = NULL;

                if (!(Flags & DS_FORCE_REDISCOVERY)) {
                    dwRet = Bind2DS(phDS, ppDCI, DS_FORCE_REDISCOVERY | Flags);
                }
            }
        } else {
            NetApiBufferFree(*ppDCI);
            *ppDCI = NULL;
            dwRet = ERROR_CANT_ACCESS_DOMAIN_INFO;
        }
    }

    return dwRet;
}


DWORD
DsCrackNamesStatus2Win32Error(
    DWORD dwStatus
)
{
    switch (dwStatus) {
        case DS_NAME_ERROR_RESOLVING:
            return ERROR_DS_NAME_ERROR_RESOLVING;

        case DS_NAME_ERROR_NOT_FOUND:
            return ERROR_DS_NAME_ERROR_NOT_FOUND;

        case DS_NAME_ERROR_NOT_UNIQUE:
            return ERROR_DS_NAME_ERROR_NOT_UNIQUE;

        case DS_NAME_ERROR_NO_MAPPING:
            return ERROR_DS_NAME_ERROR_NO_MAPPING;

        case DS_NAME_ERROR_DOMAIN_ONLY:
            return ERROR_DS_NAME_ERROR_DOMAIN_ONLY;

        case DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING:
            return ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING;
    }

    return ERROR_FILE_NOT_FOUND;
}

DWORD
GetDSSleepInterval (
    HANDLE h
)
{
    DWORD           dwVerifyPublishedStateInterval;
    PDSUPDATEDATA   pData = (PDSUPDATEDATA)h;
    DWORD           dwTimeToSleep = 30 * ONE_MINUTE;
    //
    // 30 min is the minimum interval that can be set with the policy editor.
    // If someone enables the policy while we are sleeping, then we need to wake up
    // to pick the settings. This doesn't apply if the DS doesn't respond.
    //
       

    if (pData && pData->bSleep) {

        //
        // If the updating is failing, Data.bSleep is set to TRUE. 
        // This happens when the DS is down.
        //
        dwTimeToSleep = pData->dwSleepTime;

        //
        // Sleep interval is doubled to a maximum of 2 hours.
        // We still want to attempt publishing every 2 hours. We also attempt if 
        // a "publish" action is taken(the even will be signaled).
        // 
        //
        pData->dwSleepTime = pData->dwSleepTime * 2 > 2 * ONE_HOUR ? 
                             2 * ONE_HOUR : 
                             pData->dwSleepTime * 2;

    } else {

        dwTimeToSleep = INFINITE;
    }

    return dwTimeToSleep;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\dsupdate.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Abstract:

    This module provides functionality for ADs within spooler

Author:

    Steve Wilson (NT) July 1997

Revision History:

--*/


#include <precomp.h>
#pragma hdrstop

#include "dsprune.hxx"
#include "clusspl.h"

DWORD WINAPI DsUpdate(PDWORD pdwDelay);
VOID ValidateDsProperties(PINIPRINTER pIniPrinter);
HANDLE  ghUpdateNow = NULL;

extern DWORD dwUpdateFlag;

extern "C" HANDLE    ghDsUpdateThread;
extern "C" DWORD     gdwDsUpdateThreadId;

HANDLE    ghDsUpdateThread  = NULL;
DWORD     gdwDsUpdateThreadId;

BOOL                gbInDomain;
BOOL                gdwLogDsEvents = LOG_ALL_EVENTS;


DWORD
SpawnDsUpdate(
    DWORD dwDelay
)
{
    DWORD   dwError;
    PDWORD  pdwDelay;

    SplInSem();

    if (!ghDsUpdateThread && !dwUpgradeFlag) {
        if (pdwDelay = (PDWORD) AllocSplMem(sizeof(DWORD))) {
            *pdwDelay = dwDelay;

            if(!(ghDsUpdateThread = CreateThread(NULL,
                                                0,
                                                (LPTHREAD_START_ROUTINE) DsUpdate,
                                                (PVOID) pdwDelay,
                                                0,
                                                &gdwDsUpdateThreadId))) {
                dwError = GetLastError();
                FreeSplMem(pdwDelay);
            } else {
                CloseHandle(ghDsUpdateThread);
                dwError = ERROR_SUCCESS;
            }
        } else {
            dwError = GetLastError();
        }
    } else {
        if (ghUpdateNow)
            SetEvent(ghUpdateNow);

        dwError = ERROR_BUSY;
    }

    return dwError;
}




BOOL
DsUpdatePrinter(
    HANDLE h,
    PINIPRINTER pIniPrinter
    )
{
    HANDLE hPrinter;
    PWSTR pszPrinterName = NULL;
    PDSUPDATEDATA pData = (PDSUPDATEDATA)h;
    DWORD dwAction;

    PRINTER_DEFAULTS    Defaults;

    SplInSem();

    Defaults.pDatatype = NULL;
    Defaults.pDevMode = NULL;
    Defaults.DesiredAccess = PRINTER_ACCESS_ADMINISTER;

    // dwAction and DsKeyUpdateForeground are the foreground (client) thread's requested 
    // action and state. DsKeyUpdate is the background (DsUpdate) thread's state
    // Foreground state always has priority over background, so sync up if needed.
    // When both the foreground and background actions are 0, then the publish state
    // is up to date.


    DBGMSG( DBG_EXEC, ("\nBACKGROUND UPDATE: Printer \"%ws\", dwAction = %x, DsKeyUpdate = %x, DsKeyUpdateForeground = %x, Attributes = %x\n",
            pIniPrinter->pName, pIniPrinter->dwAction, pIniPrinter->DsKeyUpdate, pIniPrinter->DsKeyUpdateForeground, pIniPrinter->Attributes ) );

    if (dwAction = pIniPrinter->dwAction) {
        pIniPrinter->dwAction = 0;          // set to 0 so we know when client thread sets it

        pIniPrinter->DsKeyUpdate |= pIniPrinter->DsKeyUpdateForeground;
        pIniPrinter->DsKeyUpdateForeground = 0;

        //
        // Mask off possible conflicts in DS_KEY_PUBLISH, REPUBLISH, and UNPUBLISH actions
        //
        pIniPrinter->DsKeyUpdate &= ~(DS_KEY_PUBLISH | DS_KEY_REPUBLISH | DS_KEY_UNPUBLISH);
 
        if (dwAction == DSPRINT_PUBLISH) {
            pIniPrinter->DsKeyUpdate |= DS_KEY_PUBLISH;
        } else if (dwAction == DSPRINT_REPUBLISH) {
            pIniPrinter->DsKeyUpdate = DS_KEY_REPUBLISH;
        } else if (dwAction == DSPRINT_UNPUBLISH) {
            pIniPrinter->DsKeyUpdate = DS_KEY_UNPUBLISH;
        }
    } else {
        //
        // If DS_KEY_UPDATE_DRIVER is set by AddForm or DeleteForm foreground threads
        // in DsUpdateDriverKeys(). We have to copy that to pIniPrinter->DsKeyUpdate
        // even if dwAction is not set. 
        //
        pIniPrinter->DsKeyUpdate |= (pIniPrinter->DsKeyUpdateForeground & DS_KEY_UPDATE_DRIVER);
        pIniPrinter->DsKeyUpdateForeground &= ~DS_KEY_UPDATE_DRIVER;
    }

    UpdatePrinterIni(pIniPrinter, UPDATE_DS_ONLY);

    if (pIniPrinter->DsKeyUpdate) {

        pData->bAllUpdated = FALSE;

        LeaveSplSem();

        // If this printer is pending deletion, delete by GUID because OpenPrinter
        // will fail.
        //
        // We check pIniPrinter->bDsPendingDeletion instead of 
        // pIniPrinter->Status ~ PRINTER_PENDING_DELETION because PRINTER_PENDING_DELETION
        // is set in InternalDeletePrinter after it leaves Spooler CS. This gives the DS thread
        // a chance to check PRINTER_PENDING_DELETION flag before it is set.
        // The reason we cannot set PRINTER_PENDING_DELETION before we leave Spooler CS is because 
        // we want OpenPrinter calls that come from PrinterDriverEvent to succeed.
        // See how InternalDeletePrinter sets the printer on PRINTER_NO_MORE_JOBS to reject incoming jobs
        // but accept OpenPrinter calls.
        //
        if (pIniPrinter->bDsPendingDeletion) {
            //
            // This will DECPRINTERREF to match DECPRINTERREF in SplDeletePrinter.
            // UnpublishByGUID won't call DeletePrinterCheck when it DECPRINTERREF.
            // RunForEachPrinter will do that.
            //
            UnpublishByGUID(pIniPrinter);

        } else {

            EnterSplSem();
            pszPrinterName = pszGetPrinterName( pIniPrinter, TRUE, NULL );
            LeaveSplSem();

            if (pszPrinterName) {
                if(LocalOpenPrinter(pszPrinterName, &hPrinter, &Defaults) == ROUTER_SUCCESS) {

                    EnterSplSem();
                    if( (pIniPrinter->DsKeyUpdate & DS_KEY_UPDATE_DRIVER) && 
                        !(pIniPrinter->DsKeyUpdate & DS_KEY_REPUBLISH)) {

                        // 
                        // We update the Registry with the Form data and then
                        // set DS_KEY_PUBLISH. Eventually SetPrinterDS() would 
                        // update the DS. 
                        UpdateDsDriverKey(hPrinter);
                        pIniPrinter->DsKeyUpdate &= ~DS_KEY_UPDATE_DRIVER;

                        if(pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED) {
                            pIniPrinter->DsKeyUpdate |= DS_KEY_PUBLISH;
                        } 
                    }
                    if (pIniPrinter->DsKeyUpdate & DS_KEY_REPUBLISH) {

                        SetPrinterDs(hPrinter, DSPRINT_UNPUBLISH, TRUE);

                        // Unpublishing & republishing printer doesn't rewrite DS keys,
                        // so on Republish, we should also rewrite DS keys so we know
                        // everything is synched up
                        SplDeletePrinterKey(hPrinter, SPLDS_DRIVER_KEY);
                        SplDeletePrinterKey(hPrinter, SPLDS_SPOOLER_KEY);
                        UpdateDsDriverKey(hPrinter);
                        UpdateDsSpoolerKey(hPrinter, 0xffffffff);

                        SetPrinterDs(hPrinter, DSPRINT_PUBLISH, TRUE);

                    } else if (pIniPrinter->DsKeyUpdate & DS_KEY_UNPUBLISH) {
                        SetPrinterDs(hPrinter, DSPRINT_UNPUBLISH, TRUE);

                    } else if (pIniPrinter->DsKeyUpdate & DS_KEY_PUBLISH) {
                        SetPrinterDs(hPrinter, DSPRINT_PUBLISH, TRUE);

                    } else {
                        // 
                        // If the printer is not published and DS_KEY_UPDATE_DRIVER
                        // is set, then we will reach here and 
                        // DsKeyUpdate will have the DS_KEY_DRIVER set by 
                        // UpdateDsDriverKey(). So we just clear it here.
                        //
                        pIniPrinter->DsKeyUpdate = 0;
                        UpdatePrinterIni(pIniPrinter, UPDATE_DS_ONLY);
                    }
                    LeaveSplSem();

                    SplClosePrinter(hPrinter);
                }
                FreeSplStr(pszPrinterName);
            }
        }
        EnterSplSem();

        if (pIniPrinter->DsKeyUpdate) {
            pData->bSleep = TRUE;      // Only sleep if the DS is down
            gdwLogDsEvents = LOG_INFO | LOG_SUCCESS; // Only report Warnings & Errors for first printer failures
        }
    }
    return TRUE;
}

BOOL
DsUpdateSpooler(
    HANDLE h,
    PINISPOOLER pIniSpooler
    )
{
    //
    // Only do this for local spoolers.
    //
    if (pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL) {
        RunForEachPrinter(pIniSpooler, h, DsUpdatePrinter);
    }
    return TRUE;
}


DWORD
WINAPI
DsUpdate(
    PDWORD  pdwDelay
)
{
    DWORD               dwSleep;
    DWORD               dwError = ERROR_SUCCESS;
    HRESULT             hr;
    DSUPDATEDATA        Data;
    DWORD               dwWaitTime = 0;
    
    SplOutSem();

    ghUpdateNow = CreateEvent((LPSECURITY_ATTRIBUTES) NULL, FALSE, FALSE, NULL);
    
    if (ghUpdateNow) {

        if (RegisterGPNotification(ghUpdateNow, TRUE)) {

            hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

            if (SUCCEEDED(hr)) {    

                DBGMSG( DBG_EXEC, ("************** ENTER DSUPDATE\n" ) );
                //
                // Force initial sleep to be within 1 sec & 5 minutes
                //
                dwSleep = (*pdwDelay >= 1 && *pdwDelay < 300) ? *pdwDelay : 1;

                FreeSplMem(pdwDelay);

                if (dwSleep > 1) {

                    Sleep(dwSleep*1000);
                }

                Data.dwSleepTime = dwSleep * 1000;

                gdwLogDsEvents = LOG_ALL_EVENTS;


                EnterSplSem();

                //
                // The logic of this loop changed from between Win2K to Whistler. 
                // On Win2k, the DS background thread used to die if there were no DS
                // actions to be made.If the "Check published state" was changed, 
                // Spooler couldn't reflect this change unless another DS action 
                // created the DS thread.
                // On Whistler we keep it alive but sleeping.
                //

                do {

                    Data.bAllUpdated = TRUE;
                    Data.bSleep = FALSE;

                    //
                    // Run through and update each printer.
                    //
                    RunForEachSpooler(&Data, DsUpdateSpooler);
        
                    //
                    // If all printers are updated or the DS is not responding,
                    // then put the DS thread to sleep.
                    //
                    if (Data.bAllUpdated || Data.bSleep) {

                        dwWaitTime = GetDSSleepInterval(&Data);

                        //
                        // If the VerifyPublishedState Policy is set, then we need to verify 
                        // we're published based on the schedule specified by the policy.
                        // However, if updating is failing, we should revert to the background
                        // updating schedule rather than the "check published state" schedule.
                        //             
                        LeaveSplSem();

                        DBGMSG( DBG_EXEC, ("BACKGROUND UPDATE SLEEP: %d\n", dwWaitTime));

                        dwError = WaitForSingleObject(ghUpdateNow, dwWaitTime);

                        if (dwError == WAIT_FAILED) {

                            //
                            // There is one case when the DS thread can still die.
                            // If this wait fails, we don't want the thread indefinitely spinning.
                            //
                            DBGMSG(DBG_WARNING, ("VerifyPublishedState Wait Failed: %d\n", GetLastError()));
                            dwError = GetLastError();
                            break;
                        }

                        EnterSplSem();
            
                        //
                        // If the "Check published state" policy is enabled,CheckPublishedPrinters will force the DS update
                        // for published printers.If the object doesn't exist in DS, the printer is republished.(see GetPublishPoint)
                        // The call returns 0 if there is the "check published state" policy 
                        // is disabled or it is enabled and there are no published printers.
                        // We could actually break the loop and kill the thread in the case when we don't have published printers,
                        // because we don't care for policy changes.
                        //
                        CheckPublishedPrinters();
                    }

                } while (TRUE);

                LeaveSplSem();
                SplOutSem();

                CoUninitialize();

            } else {

                dwError = HRESULT_CODE(hr);
            }

            UnregisterGPNotification(ghUpdateNow);

        } else {

            dwError = GetLastError();
        }

        CloseHandle(ghUpdateNow);
        ghUpdateNow = NULL;

    } else {

        dwError = GetLastError();
    }

    DBGMSG(DBG_EXEC, ("************ LEAVE DSUPDATE\n"));

    ghDsUpdateThread = NULL;

    return dwError;
}


VOID
ValidateDsProperties(
    PINIPRINTER pIniPrinter
)
{
    // Properties not generated by driver, spooler, or user should be checked here.
    // Currently, that means only the Server name.  Note that we republish the object
    // if the server name changes, so the UNCName property gets fixed as well.

    DWORD               dwError = ERROR_SUCCESS;
    BOOL                dwAction = 0;
    HRESULT             hr;

    SplInSem();

    PINISPOOLER         pIniSpooler = pIniPrinter->pIniSpooler;
    WCHAR               pData[INTERNET_MAX_HOST_NAME_LENGTH + 3];
    DWORD               cbNeeded;
    DWORD               dwType;
    struct hostent      *pHostEnt;
    HKEY                hKey = NULL;


    dwError = OpenPrinterKey(pIniPrinter, KEY_READ | KEY_WRITE, &hKey, SPLDS_SPOOLER_KEY, TRUE);
    if (dwError != ERROR_SUCCESS) {
        pIniPrinter->DsKeyUpdate = DS_KEY_REPUBLISH;
        return;
    }

    INCPRINTERREF(pIniPrinter);
    LeaveSplSem();


    // Set to publish by default.  This will verify that the printer is published, but won't
    // write anything if there's nothing to update.
    pIniPrinter->DsKeyUpdate |= DS_KEY_PUBLISH;

    // Check Server Name

    //
    // If we were unable to find a DNS name for this machine, then gethostbyname failed.
    // In this case, let's just treat this attribute as being correct.  If other attributes
    // cause us to update, we'll probably fail because the network is down or something.  But
    // then again, we also might succeed.
    //
    if (pIniSpooler->pszFullMachineName) {

        cbNeeded = (INTERNET_MAX_HOST_NAME_LENGTH + 3)*sizeof *pData;
        dwType = REG_SZ;
        dwError = SplRegQueryValue( hKey,
                                    SPLDS_SERVER_NAME,
                                    &dwType,
                                    (PBYTE) pData,
                                    &cbNeeded,
                                    pIniSpooler);

        if (dwError != ERROR_SUCCESS || wcscmp((PWSTR) pData, pIniSpooler->pszFullMachineName)) {
            pIniPrinter->DsKeyUpdate = DS_KEY_REPUBLISH;
            goto error;
        }
    }


    // Check Short Server Name
    cbNeeded = (INTERNET_MAX_HOST_NAME_LENGTH + 3)*sizeof *pData;
    dwType = REG_SZ;
    dwError = SplRegQueryValue( hKey,
                                SPLDS_SHORT_SERVER_NAME,
                                &dwType,
                                (PBYTE) pData,
                                &cbNeeded,
                                pIniSpooler);

    if (dwError != ERROR_SUCCESS || wcscmp((PWSTR) pData, pIniSpooler->pMachineName + 2)) {
        pIniPrinter->DsKeyUpdate = DS_KEY_REPUBLISH;
        goto error;
    }

    // Check Version Number
    cbNeeded = (INTERNET_MAX_HOST_NAME_LENGTH + 3)*sizeof *pData;
    dwType = REG_DWORD;
    dwError = SplRegQueryValue( hKey,
                                SPLDS_VERSION_NUMBER,
                                &dwType,
                                (PBYTE) pData,
                                &cbNeeded,
                                pIniSpooler);

    if (dwError != ERROR_SUCCESS || *((PDWORD) pData) != DS_PRINTQUEUE_VERSION_WIN2000) {
        pIniPrinter->DsKeyUpdate = DS_KEY_REPUBLISH;
        goto error;
    }

    // Check Immortal flag
    cbNeeded = (INTERNET_MAX_HOST_NAME_LENGTH + 3)*sizeof *pData;
    dwType = REG_DWORD;
    dwError = SplRegQueryValue( hKey,
                                SPLDS_FLAGS,
                                &dwType,
                                (PBYTE) pData,
                                &cbNeeded,
                                pIniSpooler);

    if (dwError != ERROR_SUCCESS) {
        pIniPrinter->DsKeyUpdate = DS_KEY_REPUBLISH;
        goto error;
    } else if (*((PDWORD) pData) != (DWORD) pIniSpooler->bImmortal) {
        dwError = SplRegSetValue(   hKey,
                                    SPLDS_FLAGS,
                                    dwType,
                                    (PBYTE) &pIniSpooler->bImmortal,
                                    sizeof pIniSpooler->bImmortal,
                                    pIniSpooler);

        if (dwError == ERROR_SUCCESS) {
            pIniPrinter->DsKeyUpdate |= DS_KEY_SPOOLER;
        }
        else {
            pIniPrinter->DsKeyUpdate = DS_KEY_REPUBLISH;
            goto error;
        }
    }


error:

    if (hKey)
        SplRegCloseKey(hKey, pIniSpooler);


    EnterSplSem();
    DECPRINTERREF(pIniPrinter);
    SplInSem();

    return;
}



extern "C" VOID
InitializeDS(
    PINISPOOLER pIniSpooler
    )
{
    PINIPRINTER                         pIniPrinter = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDsRole = NULL;
    DWORD                               dwError = ERROR_SUCCESS;
    SYSTEMTIME                          SystemTime;
    DWORD                               dwDelay = 0;

    // Verify that we're in a domain
    dwError = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *) &pDsRole);

    if (pDsRole) {
        gbInDomain = (dwError == ERROR_SUCCESS &&
                      pDsRole->MachineRole != DsRole_RoleStandaloneServer &&
                      pDsRole->MachineRole != DsRole_RoleStandaloneWorkstation);

        DsRoleFreeMemory((PVOID) pDsRole);

    } else {

        gbInDomain = FALSE;
    }


    if (gbInDomain) {

        // Check if we need to update the ds
        EnterSplSem();

        // Get spooler policies
        pIniSpooler->bImmortal = ImmortalPolicy();
        BOOL bPublishProhibited = PrinterPublishProhibited();

        // Run through all the printers and see if any need updating
        for (pIniPrinter = pIniSpooler->pIniPrinter ; pIniPrinter ; pIniPrinter = pIniPrinter->pNext) {

            // PublishProhibited not only prohibits new publishing, but also
            // removes currently published printers
            if (bPublishProhibited) {
                pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_PUBLISHED;
            }

            if (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED) {

                // Verify properties not changed by driver or spooler
                ValidateDsProperties(pIniPrinter);

            } else if (pIniPrinter->pszObjectGUID) {    // State is unpublished, but we haven't deleted
                                                        // the PrintQueue from the DS yet.
                pIniPrinter->DsKeyUpdate = DS_KEY_UNPUBLISH;
            } else {
                pIniPrinter->DsKeyUpdate = 0;
            }

            if (!dwDelay && (pIniPrinter->DsKeyUpdate || pIniPrinter->DsKeyUpdateForeground)) {
                // Initially sleep a random amount of time
                // This keeps network traffic down if there's been a power outage
                GetSystemTime(&SystemTime);

                srand((unsigned) SystemTime.wMilliseconds);

                // 100 different sleep times from 1 sec - 100 sec
                // Typical time to publish printer is 5 seconds.  Updates and deletes are just a couple seconds
                dwDelay = (rand()%100) + 1;
            }
        }

        if (dwDelay)
            SpawnDsUpdate(dwDelay);

        LeaveSplSem();

        if (ThisMachineIsADC()) {

            GetSystemTime(&SystemTime);
            srand((unsigned) SystemTime.wMilliseconds);

            DWORD dwPruningInterval = PruningInterval();

            if (dwPruningInterval == INFINITE)
                dwPruningInterval = DEFAULT_PRUNING_INTERVAL;

            if (dwPruningInterval)
                SpawnDsPrune(rand()%dwPruningInterval);
            else
                SpawnDsPrune(0);
        }
    }

    ServerThreadPolicy(gbInDomain);

    return;
}

BOOL
DsUpdateDriverKeys(
    HANDLE h,
    PINIPRINTER pIniPrinter
    )
{
    //
    // For now, we need this only when a new user defined form is added/deleted.
    // For this case, UpdateDsDriverKey is not called before call SetPrinterDS
    // We set all pIniPrinters->DsKeyUpdateForeground with DS_KEY_UPDATE_DRIVER so that 
    // on DsUpdatePrinter we know that UpdateDsDriverKey must be called before 
    // we try to publish the printer.
    //
    SplInSem();

    pIniPrinter->DsKeyUpdateForeground |= DS_KEY_UPDATE_DRIVER;    
    
    return TRUE;
}
    
BOOL
DsUpdateAllDriverKeys(
    HANDLE h,
    PINISPOOLER pIniSpooler
    )
{
    HANDLE          hToken = NULL;
    
    //
    // Only do this for local spoolers.
    //
    if (pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL) {
        RunForEachPrinter(pIniSpooler, h, DsUpdateDriverKeys);
    }

    hToken = RevertToPrinterSelf(); // All DS accesses are done by LocalSystem account
    SpawnDsUpdate(1);
    if (hToken)
        ImpersonatePrinterClient(hToken);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\eventlog.c ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation
All rights reserved.

Module Name:

    eventlog.c

Abstract:

    This module provides all functions that the Local Print Providor
    uses to write to the Event Log.

    InitializeEventLogging
    DisableEventLogging
    LogEvent
    GetUserSid

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Matthew Felton ( MattFe ) 15-Mar-1995
    Change defaults on Workstation to not log information messages
    Also add regsitry key to allow user to filter some types of call


--*/

#include <precomp.h>
#pragma hdrstop

#include "clusspl.h"

#define MAX_MERGE_STRINGS   7

HANDLE hEventSource = NULL;

#if DBG
BOOL   EventLogFull = FALSE;
#endif

BOOL
GetUserSid(
    PTOKEN_USER *ppTokenUser,
    PDWORD pcbTokenUser
);

DWORD
InitializeEventLogging(
    PINISPOOLER pIniSpooler
    )
{
    DWORD Status;
    HKEY  hkey;
    DWORD dwData;

    DWORD Flags;
    NT_PRODUCT_TYPE NtProductType;

    //
    // Initialize defaults.
    //
    pIniSpooler->dwEventLogging = LOG_DEFAULTS_WORKSTATION_EVENTS;

    //
    // Default is no NetPopup. 0 - Disable NetPopup, 1 - Enable
    //
    pIniSpooler->bEnableNetPopups = 0;

    //
    //  Caching Providers Might not require Event Logging
    //

    if ( ( pIniSpooler->SpoolerFlags & SPL_LOG_EVENTS ) == FALSE ) return TRUE;

    //
    // Turn on logging if we are a server.
    //

    if (RtlGetNtProductType(&NtProductType)) {

        if (NtProductType != NtProductWinNt) {

            pIniSpooler->dwEventLogging = LOG_ALL_EVENTS;

        }
    }

    //
    // If we aren't event logging or we are a cluster reg, then
    // don't initialize per-machine resources.
    //
    if( pIniSpooler != pLocalIniSpooler ){
        return NO_ERROR;
    }

    Status = RegCreateKey( HKEY_LOCAL_MACHINE,
                           pIniSpooler->pszRegistryEventLog,
                           &hkey );


    if( Status == NO_ERROR )
    {
        // Add the Event-ID message-file name to the subkey.

        Status = RegSetValueEx( hkey,
                                L"EventMessageFile",
                                0,
                                REG_EXPAND_SZ,
                                (LPBYTE)pIniSpooler->pszEventLogMsgFile,
                                wcslen( pIniSpooler->pszEventLogMsgFile ) * sizeof( WCHAR )
                                + sizeof( WCHAR ) );

        if( Status != NO_ERROR )
        {
            DBGMSG( DBG_ERROR, ( "Could not set event message file: Error %d\n",
                                 Status ) );
        }

        dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE
                 | EVENTLOG_INFORMATION_TYPE;

        if( Status == NO_ERROR )
        {
            Status = RegSetValueEx( hkey,
                                    L"TypesSupported",
                                    0,
                                    REG_DWORD,
                                    (LPBYTE)&dwData,
                                    sizeof dwData );

            if( Status != NO_ERROR )
            {
                DBGMSG( DBG_ERROR, ( "Could not set supported types: Error %d\n",
                                     Status ) );
            }
        }

        RegCloseKey(hkey);
    }

    else
    {
        DBGMSG( DBG_ERROR, ( "Could not create registry key for event logging: Error %d\n",
                             Status ) );
    }

    if( Status == NO_ERROR )
    {
        if( !( hEventSource = RegisterEventSource( NULL, L"Print" ) ) )
            Status = GetLastError( );
    }

    return Status;
}

VOID
SplLogEventWorker(
    IN      PINISPOOLER pIniSpooler,
    IN      WORD        EventType,
    IN      NTSTATUS    EventID,
    IN      BOOL        bInSplSem,
    IN      LPWSTR      pFirstString,
    IN      va_list     vargs
)
/*++

Function Description: 

    This provides a common entry point to support event logging. This is now 
    called by the print processor and Win32spl.

Parameters: 

    EventType   - E.g. LOG_ERROR (defined in local.h)

    EventID     - Constant as defined in messages.h.  This refers to a string
                  resource located in the event-log message DLL specified in
                  InitializeEventLogging (which currently is localspl.dll itself).

    bInSplSem   - flag to indicate if the call was made from inside SplSem

    pFirstString- The first of up to MAX_MERGE_STRINGS.  This may be NULL,
                  if no strings are to be inserted.  If strings are passed to this
                  routine, the last one must be followed by NULL.
                  Don't rely on the fact that the argument copying stops when it
                  reaches MAX_MERGE_STRINGS, because this could change if future
                  messages are found to need more replaceable parameters.
                          
    vargs       - The remaining strings to be passed in.                   

Return Values: NONE

--*/
{
    PTOKEN_USER pTokenUser = NULL;
    DWORD       cbTokenUser;
    PSID        pSid = NULL;
    LPWSTR      pMergeStrings[MAX_MERGE_STRINGS];
    WORD        cMergeStrings = 0, index;
    DWORD       LastError = GetLastError();

    if (!hEventSource)
        return;

    //
    // If the Inispooler is NULL, don't check whether to log an event, just log one,
    // This allows us to log events when failing to start up spooler.
    //
    if ( pIniSpooler )
    {
        if (( pIniSpooler->dwEventLogging & EventType ) == FALSE )
            return;

        if ( ( pIniSpooler->SpoolerFlags & SPL_LOG_EVENTS ) == FALSE )
            return;
    }

    if( GetUserSid( &pTokenUser, &cbTokenUser ) )
        pSid = pTokenUser->User.Sid;

    // Put the strings into a format accepted by ReportEvent,
    // by picking off each non-null argument, and storing it in the array
    // of merge strings.  Continue till we hit a NULL, or MAX_MERGE_STRINGS.

    if( pFirstString )
    {
        LPWSTR pszInsert;

        if (pMergeStrings[cMergeStrings] = AllocSplStr(pFirstString))
        {
            cMergeStrings++;
        }
        else
        {
            goto CleanUp;
        }
        
        while ((cMergeStrings < MAX_MERGE_STRINGS) &&
               (pszInsert = va_arg(vargs, LPWSTR))) {

            if (pMergeStrings[cMergeStrings] = AllocSplStr(pszInsert))
            {
                cMergeStrings++;
            }
            else
            {
                goto CleanUp;
            }
        }
    }

    //
    //  Leave the semaphore before calling into the event logging service
    //
    if (bInSplSem)
    {
        LeaveSplSem();
        SplOutSem();
    }

    if ( !ReportEvent( hEventSource,    // handle returned by RegisterEventSource
                       EventType,       // event type to log
                       0,               // event category
                       EventID,         // event identifier
                       pSid,            // user security identifier (optional)
                       cMergeStrings,   // number of strings to merge with message
                       0,               // size of raw data (in bytes)
                       pMergeStrings,   // array of strings to merge with message
                       NULL ) ) {       // address of raw data
#if DBG
        if( GetLastError() == ERROR_LOG_FILE_FULL ) {

            // Put out a warning message only the first time this happens:

            if( !EventLogFull ) {

                DBGMSG( DBG_WARNING, ( "The Event Log is full\n" ) );
                EventLogFull = TRUE;
            }

        } else {

            DBGMSG( DBG_WARNING, ( "ReportEvent failed: Error %d\n", GetLastError( ) ));
        }
#endif // DBG
    }

    //
    //  Reenter the semaphore after logging the event
    //
    if (bInSplSem)
    {
        EnterSplSem();
    }

CleanUp:

    // Free the strings
    for (index = 0; index < cMergeStrings ; index++) {

        FreeSplStr(pMergeStrings[index]);
    }

    if( pTokenUser ) {

        FreeSplMem( pTokenUser );
    }
    // GetUserSid() wipes out the Last Error, so restore it before returning
    SetLastError(LastError);
}

VOID
SplLogEvent(
    PINISPOOLER pIniSpooler,
    WORD        EventType,
    NTSTATUS    EventID,
    BOOL        bInSplSem,
    LPWSTR      pFirstString,
    ...
)
/*++

Function Description: Writes to the event log with up to MAX_MERGE_STRINGS parameter strings.

Parameters: EventType -   E.g. LOG_ERROR (defined in local.h)

            EventID   -   Constant as defined in messages.h.  This refers to a string
                          resource located in the event-log message DLL specified in
                          InitializeEventLogging (which currently is localspl.dll itself).

            bInSplSem -   flag to indicate if the call was made from inside SplSem

           pFirstString - The first of up to MAX_MERGE_STRINGS.  This may be NULL,
                          if no strings are to be inserted.  If strings are passed to this
                          routine, the last one must be followed by NULL.
                          Don't rely on the fact that the argument copying stops when it
                          reaches MAX_MERGE_STRINGS, because this could change if future
                          messages are found to need more replaceable parameters.

Return Values: NONE

--*/
{
    va_list vargs;
    
    va_start(vargs, pFirstString);

    SplLogEventWorker(pIniSpooler, EventType, EventID, bInSplSem, pFirstString, vargs);

    va_end(vargs);
}

VOID
PrintProcLogEvent(
    WORD     EventType,
    NTSTATUS EventID,
    LPWSTR   pLog
)

/*++
Function Description: This is an export for the print processor to log errors.

Parameters:  EventType - E.g. LOG_ERROR (defined in local.h)
             EventID   - Constant as defined in messages.h
             pLog      - string containg the log message

Return Values: NONE
--*/

{
    // Ensure that the last parameter is NULL
    if (pLog == NULL)
    {
        SplLogEvent(pLocalIniSpooler, EventType, EventID, FALSE, NULL);
    }
    else
    {
        SplLogEvent(pLocalIniSpooler, EventType, EventID, FALSE, pLog, NULL);
    }

    return;
}

VOID
SplLogEventExternal(
    IN      WORD        EventType,
    IN      DWORD       EventID,
    IN      LPWSTR      pFirstString,
    ...
)
/*++

Function Description: 

    This is an export for external components to log an event. (It is currently
    used for Win32spl). It supports variable arguments, unlike PrintProcLogEvent.

Parameters:  
    
    EventType       - E.g. LOG_ERROR (defined in local.h)
    EventID         - Constant as defined in messages.h
    pFirstString    - The first string supplied by the system in the log message.
    ...             - The remaining strings, must be NULL terminated.

Return Values: NONE

--*/
{
    va_list vargs;
    
    va_start(vargs, pFirstString);

    //
    // It might not seem logical to use the local inispooler. However, win32spl's
    // inispooler's explicitely turn off event logging. So, this is necessary. 
    // Passing in NULL seems worse since this would mean you could not tone down
    // event logging for those events.
    //
    SplLogEventWorker(pLocalIniSpooler, EventType, (NTSTATUS)EventID, FALSE, pFirstString, vargs);

    va_end(vargs);
}

 // GetUserSid
 //
 // Well, actually it gets a pointer to a newly allocated TOKEN_USER,
 // which contains a SID, somewhere.
 // Caller must remember to free it when it's been used.

BOOL
GetUserSid(
    PTOKEN_USER *ppTokenUser,
    PDWORD pcbTokenUser
)
{
    HANDLE      TokenHandle;
    HANDLE      ImpersonationToken;
    PTOKEN_USER pTokenUser = NULL;
    DWORD       cbTokenUser = 0;
    DWORD       cbNeeded;
    BOOL        bRet = FALSE;

    if ( !GetTokenHandle( &TokenHandle) ) {
        return FALSE;
    }

    ImpersonationToken = RevertToPrinterSelf();

    bRet = GetTokenInformation( TokenHandle,
                                TokenUser,
                                pTokenUser,
                                cbTokenUser,
                                &cbNeeded);

    // We've passed a NULL pointer and 0 for the amount of memory
    // allocated.  We expect to fail with bRet = FALSE and
    // GetLastError = ERROR_INSUFFICIENT_BUFFER. If we do not
    // have these conditions we will return FALSE

    if ( !bRet && (GetLastError() == ERROR_INSUFFICIENT_BUFFER) ) {

        pTokenUser = AllocSplMem( cbNeeded );

        if ( pTokenUser == NULL ) {

            goto GetUserSidDone;
        }

        cbTokenUser = cbNeeded;

        bRet = GetTokenInformation( TokenHandle,
                                    TokenUser,
                                    pTokenUser,
                                    cbTokenUser,
                                    &cbNeeded );

    } else {

        //
        // Any other case -- return FALSE
        //

        bRet = FALSE;
    }

GetUserSidDone:
    if ( bRet == TRUE ) {

        *ppTokenUser  = pTokenUser;
        *pcbTokenUser = cbTokenUser;

    } else if ( pTokenUser ) {

        FreeSplMem( pTokenUser );
    }

    ImpersonatePrinterClient( ImpersonationToken );
    CloseHandle( TokenHandle );

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\fonts.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987 - 1995        **/
/********************************************************************/

/* static char *SCCSID = "@(#)qpfont.c	13.4 90/06/11"; */
/* SCCSID = @(#)qpfont.c        13.4 90/06/11 */

#include <precomp.h>

/*
 * Font table.
 * (defines the bits in the character font)
 *
 * This is based mostly on the Windows CGAOEM font, with appropriate
 * changes for codepage 850.
 *
 * NOTE:  The characters you see in the comments mMAY NOT BE THE
 * CHARACTER REPRESENTED.  This is a representation of the codepage
 * 850 character set, and if you are not using this codepage, you may 
 * see a different set of characters in the comment fields below.
 */

unsigned char Font_Bits[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,		/* 00  */
0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,		/* 01  */
0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,		/* 02  */
0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,		/* 03  */
0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,		/* 04  */
0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,		/* 05  */
0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,		/* 06  */
0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,		/* 07  */
0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,		/* 08  */
0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,		/* 09  */
0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,		/* 0a  */
0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,		/* 0b  */
0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,		/* 0c  */
0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,		/* 0d  */
0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,		/* 0e  */
0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,		/* 0f  */
0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,		/* 10  */
0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,		/* 11  */
0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,		/* 12  */
0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,		/* 13  */
0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,		/* 14  */
0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,		/* 15  */
0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,		/* 16  */
0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,		/* 17  */
0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,		/* 18  */
0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,		/* 19  */
0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,		/* 1a  */
0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,		/* 1b  */
0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,		/* 1c  */
0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,		/* 1d  */
0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,		/* 1e  */
0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,		/* 1f  */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,		/* 20  */
0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,		/* 21 ! */
0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,		/* 22 " */
0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,		/* 23 # */
0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,		/* 24 $ */
0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,		/* 25 % */
0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,		/* 26 & */
0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,		/* 27 ' */
0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,		/* 28 ( */
0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,		/* 29 ) */
0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,		/* 2a * */
0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,		/* 2b + */
0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,		/* 2c , */
0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,		/* 2d - */
0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,		/* 2e . */
0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,		/* 2f / */
0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,		/* 30 0 */
0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,		/* 31 1 */
0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,		/* 32 2 */
0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,		/* 33 3 */
0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,		/* 34 4 */
0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,		/* 35 5 */
0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,		/* 36 6 */
0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,		/* 37 7 */
0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,		/* 38 8 */
0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,		/* 39 9 */
0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,		/* 3a : */
0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,		/* 3b ; */
0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,		/* 3c < */
0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,		/* 3d = */
0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,		/* 3e > */
0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,		/* 3f ? */
0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,		/* 40 @ */
0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,		/* 41 A */
0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,		/* 42 B */
0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,		/* 43 C */
0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,		/* 44 D */
0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,		/* 45 E */
0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,		/* 46 F */
0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,		/* 47 G */
0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,		/* 48 H */
0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,		/* 49 I */
0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,		/* 4a J */
0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,		/* 4b K */
0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,		/* 4c L */
0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,		/* 4d M */
0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,		/* 4e N */
0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,		/* 4f O */
0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,		/* 50 P */
0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,		/* 51 Q */
0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,		/* 52 R */
0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,		/* 53 S */
0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,		/* 54 T */
0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,		/* 55 U */
0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,		/* 56 V */
0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,		/* 57 W */
0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,		/* 58 X */
0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,		/* 59 Y */
0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,		/* 5a Z */
0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,		/* 5b [ */
0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,		/* 5c \ */
0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,		/* 5d ] */
0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,		/* 5e ^ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,		/* 5f _ */
0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,		/* 60 ` */
0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,		/* 61 a */
0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,		/* 62 b */
0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,		/* 63 c */
0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,		/* 64 d */
0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,		/* 65 e */
0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,		/* 66 f */
0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,		/* 67 g */
0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,		/* 68 h */
0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,		/* 69 i */
0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,		/* 6a j */
0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,		/* 6b k */
0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,		/* 6c l */
0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,		/* 6d m */
0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,		/* 6e n */
0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,		/* 6f o */
0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,		/* 70 p */
0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,		/* 71 q */
0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,		/* 72 r */
0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,		/* 73 s */
0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,		/* 74 t */
0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,		/* 75 u */
0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,		/* 76 v */
0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,		/* 77 w */
0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,		/* 78 x */
0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,		/* 79 y */
0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,		/* 7a z */
0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,		/* 7b { */
0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,		/* 7c | */
0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,		/* 7d } */
0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,		/* 7e ~ */
0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,         /* 7f   */
0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0xf0,		/* 80  */
0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,		/* 81  */
0x1c, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,		/* 82  */
0x7e, 0xc3, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,		/* 83  */
0xcc, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,		/* 84  */
0xe0, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,		/* 85  */
0x30, 0x30, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,		/* 86  */
0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0xf0,		/* 87  */
0x7e, 0xc3, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,		/* 88  */
0xcc, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,		/* 89  */
0xe0, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,		/* 8a  */
0xcc, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,		/* 8b  */
0x7e, 0xc3, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,		/* 8c  */
0xe0, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,		/* 8d  */
0xcc, 0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0x00,		/* 8e  */
0xcc, 0xcc, 0x30, 0x78, 0xcc, 0xfc, 0xcc, 0x00,		/* 8f  */
0x1c, 0x00, 0xfc, 0x60, 0x78, 0x60, 0xfc, 0x00,         /* 90  */
0x00, 0x00, 0x7f, 0x0c, 0x7f, 0xcc, 0x7f, 0x00,         /* 91  */
0x3e, 0x6c, 0xcc, 0xfe, 0xcc, 0xcc, 0xce, 0x00,         /* 92  */
0x78, 0xcc, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00,         /* 93  */
0x00, 0xcc, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00,         /* 94  */
0x00, 0xe0, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00,         /* 95  */
0x78, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00,         /* 96  */
0x00, 0xc0, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00,         /* 97  */
0x00, 0xcc, 0x00, 0xcc, 0xcc, 0xfc, 0x0c, 0xf8,         /* 98  */
0xc3, 0x18, 0x3c, 0x66, 0x66, 0x3c, 0x18, 0x00,         /* 99  */
0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x00,         /* 9a  */
0x00, 0x00, 0x34, 0x48, 0x54, 0x24, 0x58, 0x00,         /* 9b  */
0x38, 0x6c, 0x64, 0xf0, 0x60, 0xe6, 0xfc, 0x00,         /* 9c  */
0x00, 0x3a, 0x44, 0x4a, 0x62, 0x22, 0x5c, 0x00,         /* 9d  */
0x00, 0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00,         /* 9e  */
0x0c, 0x1b, 0x18, 0x7c, 0x18, 0x18, 0xd8, 0x70,         /* 9f  */
0x1c, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,		/* a0  */
0x38, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,         /* a1  */
0x00, 0x1c, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00,         /* a2  */
0x00, 0x1c, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00,         /* a3  */
0x00, 0xf8, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0x00,         /* a4  */
0xfc, 0x00, 0xcc, 0xec, 0xfc, 0xdc, 0xcc, 0x00,         /* a5  */
0x3c, 0x6c, 0x6c, 0x3e, 0x00, 0x7e, 0x00, 0x00,         /* a6  */
0x3c, 0x66, 0x66, 0x3c, 0x00, 0x7e, 0x00, 0x00,         /* a7  */
0x0c, 0x00, 0x0c, 0x18, 0x30, 0x33, 0x1e, 0x00,		/* a8  */
0x00, 0x00, 0x00, 0xfc, 0xc0, 0xc0, 0x00, 0x00,         /* a9  */
0x00, 0x00, 0x00, 0xfc, 0x0c, 0x0c, 0x00, 0x00,         /* aa  */
0xc6, 0xcc, 0xd8, 0x3e, 0x63, 0xce, 0x98, 0x1f,         /* ab  */
0xc6, 0xcc, 0xd8, 0xf3, 0x67, 0xcf, 0x9f, 0x03,         /* ac  */
0x30, 0x00, 0x30, 0x30, 0x78, 0x78, 0x30, 0x00,		/* ad  */
0x00, 0x12, 0x24, 0x48, 0x24, 0x12, 0x00, 0x00,         /* ae  */
0x00, 0x48, 0x24, 0x12, 0x24, 0x48, 0x00, 0x00,         /* af  */
0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88,         /* b0  */
0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa,         /* b1  */
0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77,         /* b2  */
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,         /* b3  */
0x08, 0x08, 0x08, 0xf8, 0x08, 0x08, 0x08, 0x00,         /* b4  */
0x1e, 0x00, 0x30, 0x78, 0xcc, 0xfc, 0xcc, 0x00,		/* b5  */
0x7c, 0x82, 0x30, 0x78, 0xcc, 0xfc, 0xcc, 0x00,		/* b6  */
0xf0, 0x00, 0x30, 0x78, 0xcc, 0xfc, 0xcc, 0x00,		/* b7  */
0x3c, 0x42, 0x99, 0xa1, 0xa1, 0x99, 0x42, 0x3c,         /* b8  */
0x36, 0x36, 0xf6, 0x00, 0xf6, 0x36, 0x36, 0x00,         /* b9  */
0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x00,         /* ba  */
0x00, 0x00, 0xfe, 0x06, 0xf6, 0x36, 0x36, 0x00,         /* bb  */
0x36, 0x36, 0xf6, 0x06, 0xfe, 0x00, 0x00, 0x00,         /* bc  */
0x18, 0x18, 0x7e, 0xd8, 0xd8, 0x7e, 0x18, 0x18,         /* bd  */
0xcc, 0xcc, 0x78, 0xfc, 0x30, 0xfc, 0x30, 0x30,         /* be  */
0x00, 0x00, 0x00, 0xf8, 0x08, 0x08, 0x08, 0x00,         /* bf  */
0x08, 0x08, 0x08, 0x0f, 0x00, 0x00, 0x00, 0x00,         /* c0  */
0x08, 0x08, 0x08, 0xff, 0x00, 0x00, 0x00, 0x00,         /* c1  */
0x00, 0x00, 0x00, 0xff, 0x08, 0x08, 0x08, 0x00,         /* c2  */
0x08, 0x08, 0x08, 0x0f, 0x08, 0x08, 0x08, 0x00,         /* c3  */
0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,         /* c4  */
0x08, 0x08, 0x08, 0xff, 0x08, 0x08, 0x08, 0x00,         /* c5  */
0x36, 0x4c, 0x00, 0x38, 0x04, 0x3c, 0x44, 0x3a,         /* c6  */
0x36, 0x4c, 0x00, 0x3c, 0x66, 0x7e, 0x66, 0x00,         /* c7  */
0x36, 0x36, 0x37, 0x30, 0x3f, 0x00, 0x00, 0x00,         /* c8  */
0x00, 0x00, 0x3f, 0x30, 0x37, 0x36, 0x36, 0x00,         /* c9  */
0x36, 0x36, 0xf7, 0x00, 0xff, 0x00, 0x00, 0x00,         /* ca  */
0x00, 0x00, 0xff, 0x00, 0xf7, 0x36, 0x36, 0x00,         /* cb  */
0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x00,         /* cc  */
0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00,         /* cd  */
0x36, 0x36, 0xf7, 0x00, 0xf7, 0x36, 0x36, 0x00,         /* ce  */
0x40, 0x3a, 0x44, 0x44, 0x44, 0xb8, 0x04, 0x00,         /* cf  */
0x36, 0x4c, 0x00, 0x38, 0x44, 0x44, 0x38, 0x00,         /* d0  */
0xf8, 0x4c, 0x44, 0xf4, 0x44, 0x4c, 0xf8, 0x00,         /* d1  */
0x7e, 0x81, 0x3c, 0x20, 0x38, 0x20, 0x3c, 0x00,         /* d2  */
0x66, 0x00, 0x3c, 0x20, 0x38, 0x20, 0x3c, 0x00,         /* d3  */
0x70, 0x00, 0x3c, 0x20, 0x38, 0x20, 0x3c, 0x00,         /* d4  */
0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,         /* d5  */
0x0e, 0x00, 0x3c, 0x18, 0x18, 0x18, 0x3c, 0x00,         /* d6  */
0x7e, 0x81, 0x3c, 0x18, 0x18, 0x18, 0x3c, 0x00,         /* d7  */
0x66, 0x00, 0x3c, 0x18, 0x18, 0x18, 0x3c, 0x00,         /* d8  */
0x08, 0x08, 0x08, 0xf8, 0x00, 0x00, 0x00, 0x00,         /* d9  */
0x00, 0x00, 0x00, 0x0f, 0x08, 0x08, 0x08, 0x00,         /* da  */
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,         /* db  */
0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,         /* dc  */
0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,         /* dd  */
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,         /* de  */
0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,         /* df  */
0x0e, 0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00,         /* e0  */
0x78, 0xcc, 0xcc, 0xf8, 0xcc, 0xcc, 0xf8, 0xc0,         /* e1  */
0x7c, 0x82, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00,         /* e2  */
0x70, 0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00,         /* e3  */
0x32, 0x4c, 0x00, 0x30, 0x48, 0x48, 0x30, 0x00,         /* e4  */
0x32, 0x4c, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00,         /* e5  */
0x00, 0x66, 0x66, 0x66, 0x7e, 0x3c, 0x26, 0x20,         /* e6  */
0x60, 0x38, 0x24, 0x24, 0x38, 0x20, 0x70, 0x00,         /* e7  */
0xf0, 0x60, 0x7c, 0x66, 0x66, 0x7c, 0x60, 0xf0,         /* e8  */
0x1c, 0x44, 0x00, 0x44, 0x44, 0x44, 0x38, 0x00,         /* e9  */
0x38, 0x44, 0x00, 0x44, 0x44, 0x44, 0x38, 0x00,         /* ea  */
0x70, 0x44, 0x00, 0x44, 0x44, 0x44, 0x38, 0x00,         /* eb  */
0x0e, 0x00, 0x22, 0x22, 0x1c, 0x04, 0x38, 0x00,         /* ec  */
0x0e, 0x00, 0x6c, 0x28, 0x38, 0x10, 0x38, 0x00,         /* ed  */
0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,         /* ee  */
0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,         /* ef  */
0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00,         /* f0  */
0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0xfc, 0x00,		/* f1  */
0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,		/* f2 = */
0xf1, 0x12, 0xf4, 0x1e, 0xf1, 0x27, 0x48, 0x8f,         /* f3  */
0x00, 0x00, 0x3c, 0x60, 0x60, 0x20, 0x00, 0x00,         /* f4  */
0x1c, 0x22, 0x18, 0x24, 0x24, 0x18, 0x44, 0x38,         /* f5  */
0x30, 0x30, 0x00, 0xfc, 0x00, 0x30, 0x30, 0x00,         /* f6  */
0x00, 0x00, 0x00, 0x00, 0x4c, 0x3c, 0x00, 0x00,         /* f7  */
0x38, 0x6c, 0x6c, 0x38, 0x00, 0x00, 0x00, 0x00,         /* f8  */
0x00, 0x00, 0x00, 0x4c, 0x4c, 0x00, 0x00, 0x00,         /* f9  */
0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,         /* fa  */
0x10, 0x30, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00,         /* fb  */
0x30, 0x48, 0x18, 0x48, 0x30, 0x00, 0x00, 0x00,         /* fc  */
0x78, 0x0c, 0x38, 0x60, 0x7c, 0x00, 0x00, 0x00,         /* fd  */
0x00, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x00,         /* fe  */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00          /* ff   */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\files.c ===
/*++

Copyright (c) 1990 - 1996 Microsoft Corporation

Module Name:

    Files.c

Abstract:

    This module provides routines required to copy files associated with a
    printer on printer connection

Author:

    Muhunthan Sivapragasam (MuhuntS) 05-Dec-96

Revision History:

--*/

#include <precomp.h>


HMODULE
SplLoadLibraryTheCopyFileModule(
    HANDLE  hPrinter,
    LPWSTR  pszModule
    )
{
    UINT        uErrorMode;
    DWORD       dwLen;
    WCHAR       szPath[MAX_PATH];
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    HMODULE     hModule;
    PINIDRIVER  pIniDriver;

    uErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    hModule = LoadLibrary(pszModule);

    //
    // If the module could not be found in $Path look for it in the
    // printer driver directory
    //
    if ( !hModule &&
         GetLastError() == ERROR_MOD_NOT_FOUND  &&
         (dwLen = GetIniDriverAndDirForThisMachine(pSpool->pIniPrinter,
                                                   szPath,
                                                   &pIniDriver)) ) {

        if ( dwLen + wcslen(pszModule) + 1 > MAX_PATH )
            goto Cleanup;

        wcscpy(szPath+dwLen, pszModule);
        hModule = LoadLibraryEx(szPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    }

Cleanup:
    (VOID)SetErrorMode(uErrorMode);

    return hModule;
}


BOOL
GenerateDirectoryNamesForCopyFilesKey(
    PSPOOL      pSpool,
    HKEY        hKey,
    LPWSTR     *ppszSourceDir,
    LPWSTR     *ppszTargetDir,
    DWORD       cbMax
    )
{
    BOOL        bRet = FALSE, bInCS = FALSE;
    DWORD       dwType, dwSize, dwSourceDirSize, dwTargetDirSize;
    LPWSTR      pszDir, ppszFiles, pszModule, pszPrinterName = NULL;
    HMODULE     hModule = NULL;
    DWORD       (*pfn)(LPWSTR       pszPrinterName,
                       LPCWSTR      pszDirectory,
                       LPBYTE       pSplClientInfo,
                       DWORD        dwLevel,
                       LPWSTR       pszSourceDir,
                       LPDWORD      pcchSourceDirSize,
                       LPWSTR       pszTargetDir,
                       LPDWORD      pcchTargetDirSize,
                       DWORD        dwFlags
                      );
    SPLCLIENT_INFO_1    SplClientInfo1;

    //
    // First find the keys we need from the registry
    // "Directory", "Files" values are mandatory. "Module" is optional
    //
    pszDir          = (LPWSTR) AllocSplMem(cbMax);
    ppszFiles       = (LPWSTR) AllocSplMem(cbMax);
    pszModule       = (LPWSTR) AllocSplMem(cbMax);

    if ( !pszDir || !ppszFiles || !pszModule )
        goto Cleanup;

    if ( (dwSize = cbMax)                                           &&
         ERROR_SUCCESS == RegQueryValueEx(hKey,
                                          L"Directory",
                                          0,
                                          &dwType,
                                          (LPBYTE)pszDir,
                                          &dwSize)                  &&
         dwType == REG_SZ                                           &&
         (dwSize = cbMax)                                           &&
         ERROR_SUCCESS == RegQueryValueEx(hKey,
                                          L"Files",
                                          0,
                                          &dwType,
                                          (LPBYTE)ppszFiles,
                                          &dwSize)                  &&
        dwType == REG_MULTI_SZ ) {

        dwSize = cbMax;
        if ( ERROR_SUCCESS == RegQueryValueEx(hKey,
                                              L"Module",
                                              0,
                                              &dwType,
                                              (LPBYTE)pszModule,
                                              &dwSize)              &&
             dwType != REG_SZ ) {

            SetLastError(ERROR_INVALID_PARAMETER);
            goto Cleanup;
        }
    }

    //
    // If a module is given we need to call into to "correct" the path
    // We will first try LoadLibrary on the module, if we can't find the module
    // we will look in the driver directory for it
    //
    if ( pszModule && *pszModule ) {

        if ( !(hModule = SplLoadLibraryTheCopyFileModule(pSpool, pszModule)) ||
             !((FARPROC)pfn = GetProcAddress(hModule, "GenerateCopyFilePaths")) )
        goto Cleanup;
    }


    dwTargetDirSize = MAX_PATH;
    dwSourceDirSize = INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH;
    *ppszSourceDir    = (LPWSTR) AllocSplMem(dwSourceDirSize * sizeof(WCHAR));
    *ppszTargetDir    = (LPWSTR) AllocSplMem(dwTargetDirSize * sizeof(WCHAR));

    if ( !*ppszSourceDir || !*ppszTargetDir )
        goto Cleanup;

    EnterSplSem();
    bInCS = TRUE;
    pszPrinterName = AllocSplStr(pSpool->pIniPrinter->pName);

    //
    // For source dir we will give full path the way the client will understand
    // (ie. have correct prefix -- server nam, dns name etc).
    // For target dir we will give a relative path off print$
    //
    if ( !pszPrinterName || wcslen(pszDir) >= dwTargetDirSize || 
         wcslen(pSpool->pFullMachineName) +
         wcslen(pSpool->pIniSpooler->pszDriversShare) +
         wcslen(pszDir) + 2 >= dwSourceDirSize ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;

    }

    wsprintf(*ppszSourceDir,
             L"%ws\\%ws\\%ws",
             pSpool->pFullMachineName,
             pSpool->pIniSpooler->pszDriversShare,
             pszDir);

    CopyMemory((LPBYTE)&SplClientInfo1,
               (LPBYTE)&pSpool->SplClientInfo1,
               sizeof(SPLCLIENT_INFO_1));

    SplClientInfo1.pUserName    = NULL;
    SplClientInfo1.pMachineName = NULL;

    LeaveSplSem();
    bInCS = FALSE;

    wcscpy(*ppszTargetDir, pszDir);

    if ( hModule ) {

        //
        // On free builds we do not want spooler to crash
        //
#if DBG
#else
        try {
#endif
            if ( ERROR_SUCCESS != pfn(pszPrinterName,
                                      pszDir,
                                      (LPBYTE)&SplClientInfo1,
                                      1,
                                      *ppszSourceDir,
                                      &dwSourceDirSize,
                                      *ppszTargetDir,
                                      &dwTargetDirSize,
                                      COPYFILE_FLAG_SERVER_SPOOLER) )
#if DBG
                goto Cleanup;
#else
                leave;
#endif
            bRet = TRUE;
#if DBG
#else
        } except(1) {
        }
#endif
    } else {

        bRet = TRUE;
    }


Cleanup:
    if ( bInCS )
        LeaveSplSem();

    SplOutSem();

    FreeSplStr(pszDir);
    FreeSplStr(ppszFiles);
    FreeSplStr(pszModule);
    FreeSplStr(pszPrinterName);

    if ( hModule )
        FreeLibrary(hModule);

    if ( !bRet ) {

        FreeSplStr(*ppszSourceDir);
        FreeSplStr(*ppszTargetDir);
        *ppszSourceDir = *ppszTargetDir = NULL;
    }

    return bRet;
}


LPWSTR
BuildFilesCopiedAsAString(
    PINTERNAL_DRV_FILE  pInternalDriverFile,
    DWORD               dwCount
    )
/*++
    For files copied we log an event. This routine allocates memory and
    generates the file list as a comma separated string
--*/
{
    DWORD   dwIndex, dwSize;
    LPWSTR  pszRet, psz2;
    LPCWSTR psz;

    //
    // Must have some files.
    //
    SPLASSERT( dwCount );

    for ( dwIndex = dwSize = 0 ; dwIndex < dwCount ; ++dwIndex ) {

        //
        // Find the file name part
        //
        psz = FindFileName( pInternalDriverFile[dwIndex].pFileName );

        if( psz ){

            //
            // Two characters for ", " separator.
            //
            dwSize  += wcslen(psz) + 2;
        }
    }

    pszRet = AllocSplMem(dwSize * sizeof(WCHAR));

    if ( !pszRet )
        return NULL;

    for ( dwIndex = 0, psz2 = pszRet ; dwIndex < dwCount ; ++dwIndex ) {

        //
        // Find the file name part
        //
        psz = FindFileName( pInternalDriverFile[dwIndex].pFileName );

        if( psz ){

            wcscpy(psz2, psz);
            psz2 = psz2 + wcslen(psz2);

            if ( dwIndex < dwCount - 1) {

                wcscpy(psz2, L", ");
                psz2 += 2;
            }
        }
    }

    return pszRet;
}

BOOL
SplCopyNumberOfFiles(
    LPWSTR      pszPrinterName,
    LPWSTR     *ppszSourceFileNames,
    DWORD       dwCount,
    LPWSTR      pszTargetDir,
    LPBOOL      pbFilesAddedOrUpdated
    )
{
    BOOL        bRet=FALSE, bFilesMoved;
    LPWSTR      pszFiles;
    DWORD       dwIndex;
    LPWSTR      pszNewDir = NULL;
    LPWSTR      pszOldDir = NULL;
    BOOL        bFilesUpdated;
    INTERNAL_DRV_FILE    *pInternalDriverFiles = NULL;
    BOOL        bWaitForReboot = FALSE;

    *pbFilesAddedOrUpdated = FALSE;

    pInternalDriverFiles  = (INTERNAL_DRV_FILE *) AllocSplMem(dwCount*sizeof(INTERNAL_DRV_FILE));

    if ( !pInternalDriverFiles )
        return FALSE;

    for ( dwIndex = 0 ; dwIndex < dwCount ; ++dwIndex ) {

        pInternalDriverFiles[dwIndex].pFileName = ppszSourceFileNames[dwIndex];
        pInternalDriverFiles[dwIndex].hFileHandle = CreateFile(ppszSourceFileNames[dwIndex],
                                                              GENERIC_READ,
                                                              FILE_SHARE_READ,
                                                              NULL,
                                                              OPEN_EXISTING,
                                                              FILE_FLAG_SEQUENTIAL_SCAN,
                                                              NULL);

        if ( pInternalDriverFiles[dwIndex].hFileHandle == INVALID_HANDLE_VALUE )
            goto Cleanup;
    }

    if ( !DirectoryExists(pszTargetDir) &&
         !CreateDirectoryWithoutImpersonatingUser(pszTargetDir) )
        goto Cleanup;

    // Create the New Directory
    pszNewDir = (LPWSTR) AllocSplMem(  ( wcslen( pszTargetDir ) + wcslen( L"\\New"  ) + 1 ) * sizeof(WCHAR) );
    if ( !pszNewDir )
       goto Cleanup;

    wcscpy(pszNewDir, pszTargetDir);
    wcscat(pszNewDir, L"\\New");
    if (!DirectoryExists(pszNewDir) &&
        !CreateDirectoryWithoutImpersonatingUser(pszNewDir)) {

         // Failed to create New directory
         goto Cleanup;
    }

    // Create the Old Directory
    pszOldDir = (LPWSTR) AllocSplMem(  ( wcslen( pszTargetDir ) + wcslen( L"\\Old"  ) + 1 ) * sizeof(WCHAR) );
    if ( !pszOldDir )
       goto Cleanup;

    wcscpy(pszOldDir, pszTargetDir);
    wcscat(pszOldDir, L"\\Old");
    if (!DirectoryExists(pszOldDir) &&
        !CreateDirectoryWithoutImpersonatingUser(pszOldDir)) {

         // Failed to create Old directory
         goto Cleanup;
    }


    EnterSplSem();

    bFilesUpdated = FALSE;

    for (dwIndex = 0 ; dwIndex < dwCount ; ++dwIndex) {

        if (!(bRet = UpdateFile(NULL,
                                pInternalDriverFiles[dwIndex].hFileHandle,
                                pInternalDriverFiles[dwIndex].pFileName,
                                0,
                                pszTargetDir,
                                APD_COPY_NEW_FILES,
                                TRUE,
                                &bFilesUpdated,
                                &bFilesMoved,
                                TRUE,
                                FALSE))) {

            //
            // Files could not be copied correctly
            //
            break;
        }

        if (bFilesUpdated) {
            *pbFilesAddedOrUpdated = TRUE;
        }
    }

    if (bRet && *pbFilesAddedOrUpdated) {

        bRet = MoveNewDriverRelatedFiles( pszNewDir, 
                                          pszTargetDir, 
                                          pszOldDir, 
                                          pInternalDriverFiles, 
                                          dwCount, 
                                          NULL, 
                                          NULL);
        //
        // Don't delete "New" directory if the files couldn't be moved in "Color" directory
        //
        bWaitForReboot = !bRet;

    }

    LeaveSplSem();

Cleanup:

    if ( pszNewDir ) {
        DeleteDirectoryRecursively(pszNewDir, bWaitForReboot);
        FreeSplMem(pszNewDir);
    }

    if ( pszOldDir ) {
        DeleteDirectoryRecursively(pszOldDir, FALSE);
        FreeSplMem(pszOldDir);
    }

    if ( *pbFilesAddedOrUpdated &&
         (pszFiles = BuildFilesCopiedAsAString(pInternalDriverFiles, dwCount)) ) {

            SplLogEvent(pLocalIniSpooler,
                        LOG_WARNING,
                        MSG_FILES_COPIED,
                        FALSE,
                        pszFiles,
                        pszPrinterName,
                        NULL);
            FreeSplMem(pszFiles);
    }

    if ( pInternalDriverFiles ) {

        while ( dwIndex-- )
            CloseHandle(pInternalDriverFiles[dwIndex].hFileHandle);
        FreeSplMem(pInternalDriverFiles);
    }

    return bRet;
}


BOOL
SplCopyFileEvent(
    HANDLE  hPrinter,
    LPWSTR  pszKey,
    DWORD   dwCopyFileEvent
    )
{
    BOOL        bRet = FALSE;
    DWORD       dwNeeded, dwType, dwLastError;
    LPWSTR      pszModule = NULL;
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    HMODULE     hModule = NULL;
    BOOL        (*pfnSpoolerCopyFileEvent)(
                                LPWSTR  pszPrinterName,
                                LPWSTR  pszKey,
                                DWORD   dwCopyFileEvent
                                );

    SPLASSERT(pSpool->pIniSpooler->signature == ISP_SIGNATURE);

    dwLastError = SplGetPrinterDataEx(hPrinter,
                                      pszKey,
                                      L"Module",
                                      &dwType,
                                      NULL,
                                      0,
                                      &dwNeeded);

    //
    // If there is no module name there is no callback needed
    //
    if ( dwLastError == ERROR_FILE_NOT_FOUND )
        return TRUE;

    if ( dwLastError != ERROR_SUCCESS                   ||
         !(pszModule = (LPWSTR) AllocSplMem(dwNeeded))  ||
         SplGetPrinterDataEx(hPrinter,
                             pszKey,
                             L"Module",
                             &dwType,
                             (LPBYTE)pszModule,
                             dwNeeded,
                             &dwNeeded)                 ||
        dwType != REG_SZ ) {

        goto Cleanup;
    }

    if ( !(hModule = SplLoadLibraryTheCopyFileModule(hPrinter,
                                                     pszModule))        ||
         !((FARPROC)pfnSpoolerCopyFileEvent = GetProcAddress(hModule,
                                                             "SpoolerCopyFileEvent")) )
        goto Cleanup;

#if DBG
#else
        try {
#endif
            bRet = pfnSpoolerCopyFileEvent(pSpool->pName,
                                           pszKey,
                                           dwCopyFileEvent);

#if DBG
#else
        } except(1) {
        }
#endif

Cleanup:
    FreeSplStr(pszModule);

    if ( hModule )
        FreeLibrary(hModule);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\getprn.c ===
/*++

Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    getprn.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    management for the Local Print Providor

    SplGetPrinter
    LocalEnumPrinters

Author:

    Dave Snipp (DaveSn) 15-Mar-1991
    Steve Wilson (SWilson) - Dec 1996 Added GetPrinter Level 7

Revision History:

--*/
#define NOMINMAX

#include <precomp.h>
#include <offsets.h>


WCHAR *szNull = L"";
WCHAR *szPrintProvidorName = L"Windows NT Local Print Providor";
WCHAR *szPrintProvidorDescription=L"Windows NT Local Printers";
WCHAR *szPrintProvidorComment=L"Locally connected Printers";

WCHAR *gszDrvConvert = L",DrvConvert";

#define Nulwcslen(psz)  ((psz) ? wcslen(psz)*sizeof(WCHAR)+sizeof(WCHAR) : 0)

#define PRINTER_STATUS_INTERNAL 0
#define PRINTER_STATUS_EXTERNAL 1

DWORD SettablePrinterStatusMappings[] = {

//  INTERNAL:                   EXTERNAL:

    PRINTER_OFFLINE,            PRINTER_STATUS_OFFLINE,
    PRINTER_PAPEROUT,           PRINTER_STATUS_PAPER_OUT,
    PRINTER_PAPER_JAM,          PRINTER_STATUS_PAPER_JAM,
    PRINTER_MANUAL_FEED,        PRINTER_STATUS_MANUAL_FEED,
    PRINTER_PAPER_PROBLEM,      PRINTER_STATUS_PAPER_PROBLEM,
    PRINTER_IO_ACTIVE,          PRINTER_STATUS_IO_ACTIVE,
    PRINTER_BUSY,               PRINTER_STATUS_BUSY,
    PRINTER_PRINTING,           PRINTER_STATUS_PRINTING,
    PRINTER_OUTPUT_BIN_FULL,    PRINTER_STATUS_OUTPUT_BIN_FULL,
    PRINTER_NOT_AVAILABLE,      PRINTER_STATUS_NOT_AVAILABLE,
    PRINTER_WAITING,            PRINTER_STATUS_WAITING,
    PRINTER_PROCESSING,         PRINTER_STATUS_PROCESSING,
    PRINTER_INITIALIZING,       PRINTER_STATUS_INITIALIZING,
    PRINTER_WARMING_UP,         PRINTER_STATUS_WARMING_UP,
    PRINTER_TONER_LOW,          PRINTER_STATUS_TONER_LOW,
    PRINTER_NO_TONER,           PRINTER_STATUS_NO_TONER,
    PRINTER_PAGE_PUNT,          PRINTER_STATUS_PAGE_PUNT,
    PRINTER_USER_INTERVENTION,  PRINTER_STATUS_USER_INTERVENTION,
    PRINTER_OUT_OF_MEMORY,      PRINTER_STATUS_OUT_OF_MEMORY,
    PRINTER_DOOR_OPEN,          PRINTER_STATUS_DOOR_OPEN,
    PRINTER_SERVER_UNKNOWN,     PRINTER_STATUS_SERVER_UNKNOWN,
    PRINTER_POWER_SAVE,         PRINTER_STATUS_POWER_SAVE,
    0,                          0
};

DWORD ReadablePrinterStatusMappings[] = {

//  INTERNAL:               EXTERNAL:

    PRINTER_PAUSED,             PRINTER_STATUS_PAUSED,
    PRINTER_PENDING_DELETION,   PRINTER_STATUS_PENDING_DELETION,

    PRINTER_OFFLINE,            PRINTER_STATUS_OFFLINE,
    PRINTER_PAPEROUT,           PRINTER_STATUS_PAPER_OUT,
    PRINTER_PAPER_JAM,          PRINTER_STATUS_PAPER_JAM,
    PRINTER_MANUAL_FEED,        PRINTER_STATUS_MANUAL_FEED,
    PRINTER_PAPER_PROBLEM,      PRINTER_STATUS_PAPER_PROBLEM,
    PRINTER_IO_ACTIVE,          PRINTER_STATUS_IO_ACTIVE,
    PRINTER_BUSY,               PRINTER_STATUS_BUSY,
    PRINTER_PRINTING,           PRINTER_STATUS_PRINTING,
    PRINTER_OUTPUT_BIN_FULL,    PRINTER_STATUS_OUTPUT_BIN_FULL,
    PRINTER_NOT_AVAILABLE,      PRINTER_STATUS_NOT_AVAILABLE,
    PRINTER_WAITING,            PRINTER_STATUS_WAITING,
    PRINTER_PROCESSING,         PRINTER_STATUS_PROCESSING,
    PRINTER_INITIALIZING,       PRINTER_STATUS_INITIALIZING,
    PRINTER_WARMING_UP,         PRINTER_STATUS_WARMING_UP,
    PRINTER_TONER_LOW,          PRINTER_STATUS_TONER_LOW,
    PRINTER_NO_TONER,           PRINTER_STATUS_NO_TONER,
    PRINTER_PAGE_PUNT,          PRINTER_STATUS_PAGE_PUNT,
    PRINTER_USER_INTERVENTION,  PRINTER_STATUS_USER_INTERVENTION,
    PRINTER_OUT_OF_MEMORY,      PRINTER_STATUS_OUT_OF_MEMORY,
    PRINTER_DOOR_OPEN,          PRINTER_STATUS_DOOR_OPEN,
    PRINTER_SERVER_UNKNOWN,     PRINTER_STATUS_SERVER_UNKNOWN,
    PRINTER_POWER_SAVE,         PRINTER_STATUS_POWER_SAVE,

    0,                          0
};

DWORD
MapPrinterStatus(
    DWORD Type,
    DWORD SourceStatus)
{
    DWORD  TargetStatus;
    PDWORD pMappings;
    INT   MapFrom;
    INT   MapTo;

    if (Type == MAP_READABLE) {

        MapFrom = PRINTER_STATUS_INTERNAL;
        MapTo   = PRINTER_STATUS_EXTERNAL;

        pMappings = ReadablePrinterStatusMappings;

    } else {

        MapFrom = PRINTER_STATUS_EXTERNAL;
        MapTo   = PRINTER_STATUS_INTERNAL;

        pMappings = SettablePrinterStatusMappings;
    }

    TargetStatus = 0;

    while(*pMappings) {

        if (SourceStatus & pMappings[MapFrom])
            TargetStatus |= pMappings[MapTo];

        pMappings += 2;
    }

    return TargetStatus;
}

DWORD
GetIniNetPrintSize(
    PININETPRINT pIniNetPrint
)
{
    return sizeof(PRINTER_INFO_1) +
           wcslen(pIniNetPrint->pName)*sizeof(WCHAR) + sizeof(WCHAR) +
           Nulwcslen(pIniNetPrint->pDescription) +
           Nulwcslen(pIniNetPrint->pComment);
}

DWORD
GetPrinterSize(
    PINIPRINTER     pIniPrinter,
    DWORD           Level,
    DWORD           Flags,
    LPWSTR          lpRemote,
    LPDEVMODE       pDevMode
)
{
    DWORD   cb;
    DWORD   cbNeeded;
    LPWSTR  pszPorts;

    switch (Level) {

    case STRESSINFOLEVEL:
        cb = sizeof(PRINTER_INFO_STRESS) +
             wcslen(pIniPrinter->pName)*sizeof(WCHAR) + sizeof(WCHAR);

        if( lpRemote ){

            //
            // Allocate space for ServerName "\\foobar" and the prefix
            // for PrinterName "\\foobar\."  The rest of PrinterName
            // is allocated above.
            //
            // ServerName + NULL + ServerName +'\'
            //
            cb += 2 * wcslen(lpRemote) * sizeof(WCHAR) +
                  sizeof(WCHAR) + sizeof(WCHAR);
        }
        break;

    case 4:
        cb = sizeof(PRINTER_INFO_4) +
            wcslen(pIniPrinter->pName)*sizeof(WCHAR) + sizeof(WCHAR);

        if( lpRemote ){
            cb += 2 * wcslen(lpRemote) * sizeof(WCHAR) +
                  sizeof(WCHAR) + sizeof(WCHAR);
        }
        break;

    case 1:

        //
        // Local:
        //
        // "pName,pDriver,pLocation"
        // "pName"
        // "pComment"
        //
        // Remote:
        //
        // "pMachine\pName,pDriver,<pLocation>"
        // "pMachine\pName"
        // "pComment"
        //

        //
        // Mandatory items, plus NULLs for _all_ strings.
        //     2 * PrinterName +
        //     DriverName +
        //     2 commas, 3 NULL terminators.
        //
        cb = 2 * wcslen( pIniPrinter->pName ) +
             wcslen( pIniPrinter->pIniDriver->pName ) +
             2 + 3;
        //
        // Add items that may be NULL.
        //

        if( pIniPrinter->pLocation ){
            cb += wcslen( pIniPrinter->pLocation );
        }

        if( pIniPrinter->pComment ){
            cb += wcslen( pIniPrinter->pComment );
        }

        //
        // Remote case adds prefix.
        //    2 * ( MachineName + BackSlash )
        //
        if( lpRemote ){
            cb += 2 * ( wcslen( lpRemote ) + 1 );
        }

        //
        // cb was a char count, convert to byte count.
        //
        cb *= sizeof( WCHAR );
        cb += sizeof( PRINTER_INFO_1 );

        break;

    case 2:

        cbNeeded = 0;
        GetPrinterPorts(pIniPrinter, 0, &cbNeeded);

        cb = sizeof(PRINTER_INFO_2) +
             wcslen(pIniPrinter->pName)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nulwcslen(pIniPrinter->pShareName) +
             cbNeeded +
             wcslen(pIniPrinter->pIniDriver->pName)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nulwcslen(pIniPrinter->pComment) +
             Nulwcslen(pIniPrinter->pLocation) +
             Nulwcslen(pIniPrinter->pSepFile) +
             wcslen(pIniPrinter->pIniPrintProc->pName)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nulwcslen(pIniPrinter->pDatatype) +
             Nulwcslen(pIniPrinter->pParameters);

        if( lpRemote ){
            cb += 2 * wcslen(lpRemote) * sizeof(WCHAR) +
                  sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pDevMode) {

            cb += pDevMode->dmSize + pDevMode->dmDriverExtra;
            cb = (cb + sizeof(ULONG_PTR)-1) & ~(sizeof(ULONG_PTR)-1);
        }

        if (pIniPrinter->pSecurityDescriptor) {

            cb += GetSecurityDescriptorLength(pIniPrinter->pSecurityDescriptor);
            cb = (cb + sizeof(ULONG_PTR)-1) & ~(sizeof(ULONG_PTR)-1);
        }

        break;

    case 3:

        cb = sizeof(PRINTER_INFO_3);
        cb += GetSecurityDescriptorLength(pIniPrinter->pSecurityDescriptor);
        cb = (cb + sizeof(ULONG_PTR)-1) & ~(sizeof(ULONG_PTR)-1);

        break;

    case 5:

        cbNeeded = 0;
        GetPrinterPorts(pIniPrinter, 0, &cbNeeded);

        cb = sizeof(PRINTER_INFO_5) +
             wcslen(pIniPrinter->pName)*sizeof(WCHAR) + sizeof(WCHAR) +
             cbNeeded;

        //
        // Allocate space for just the PrinterName prefix:
        // "\\server\."
        //
        if( lpRemote ){
            cb += wcslen(lpRemote) * sizeof(WCHAR) +
                  sizeof(WCHAR);
        }
        break;

    case 6:
        cb = sizeof(PRINTER_INFO_6);
        break;

    case 7:
        cb = sizeof(PRINTER_INFO_7);
        cb += pIniPrinter->pszObjectGUID ? (wcslen(pIniPrinter->pszObjectGUID) + 1)*sizeof(WCHAR) : 0;
        break;

    default:
        cb = 0;
        break;
    }

    return cb;
}

LPBYTE
CopyIniNetPrintToPrinter(
    PININETPRINT pIniNetPrint,
    LPBYTE  pPrinterInfo,
    LPBYTE  pEnd
)
{
    LPWSTR   SourceStrings[sizeof(PRINTER_INFO_1)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings=SourceStrings;
    PPRINTER_INFO_1 pPrinterInfo1 = (PPRINTER_INFO_1)pPrinterInfo;

    *pSourceStrings++=pIniNetPrint->pDescription;
    *pSourceStrings++=pIniNetPrint->pName;
    *pSourceStrings++=pIniNetPrint->pComment;

    pEnd = PackStrings(SourceStrings, pPrinterInfo, PrinterInfo1Strings, pEnd);

    pPrinterInfo1->Flags = PRINTER_ENUM_NAME;

    return pEnd;
}


/* CopyIniPrinterSecurityDescriptor
 *
 * Copies the security descriptor for the printer to the buffer provided
 * on a call to GetPrinter.  The portions of the security descriptor which
 * will be copied are determined by the accesses granted when the printer
 * was opened.  If it was opened with both READ_CONTROL and ACCESS_SYSTEM_SECURITY,
 * all of the security descriptor will be made available.  Otherwise a
 * partial descriptor is built containing those portions to which the caller
 * has access.
 *
 * Parameters
 *
 *     pIniPrinter - Spooler's private structure for this printer.
 *
 *     Level - Should be 2 or 3.  Any other will cause AV.
 *
 *     pPrinterInfo - Pointer to the buffer to receive the PRINTER_INFO_*
 *         structure.  The pSecurityDescriptor field will be filled in with
 *         a pointer to the security descriptor.
 *
 *     pEnd - Current position in the buffer to receive the data.
 *         This will be decremented to point to the next free bit of the
 *         buffer and will be returned.
 *
 *     GrantedAccess - An access mask used to determine how much of the
 *         security descriptor the caller has access to.
 *
 * Returns
 *
 *     Updated position in the buffer.
 *
 *     NULL if an error occurred copying the security descriptor.
 *     It is assumed that no other errors are possible.
 *
 */
LPBYTE
CopyIniPrinterSecurityDescriptor(
    PINIPRINTER pIniPrinter,
    DWORD       Level,
    LPBYTE      pPrinterInfo,
    LPBYTE      pEnd,
    ACCESS_MASK GrantedAccess
)
{
    PSECURITY_DESCRIPTOR pPartialSecurityDescriptor = NULL;
    DWORD                SecurityDescriptorLength = 0;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    PSECURITY_DESCRIPTOR *ppSecurityDescriptorCopy;
    BOOL                 ErrorOccurred = FALSE;

    if(!(AreAllAccessesGranted(GrantedAccess,
                               READ_CONTROL | ACCESS_SYSTEM_SECURITY)))
    {
        /* Caller doesn't have full access, so we'll have to build
         * a partial descriptor:
         */
        if(!BuildPartialSecurityDescriptor(GrantedAccess,
                                           pIniPrinter->pSecurityDescriptor,
                                           &pPartialSecurityDescriptor,
                                           &SecurityDescriptorLength))
        {
            ErrorOccurred = TRUE;
        }
        else
        {
            if (pPartialSecurityDescriptor)
            {
                pSecurityDescriptor = pPartialSecurityDescriptor;
            }
            else
            {
                ErrorOccurred = TRUE;
            }
        }
    }
    else
    {
        pSecurityDescriptor = pIniPrinter->pSecurityDescriptor;

        SecurityDescriptorLength = GetSecurityDescriptorLength(pSecurityDescriptor);
    }

    if (!ErrorOccurred)
    {
        pEnd -= SecurityDescriptorLength;
        pEnd = (PBYTE) ALIGN_PTR_DOWN(pEnd);

        switch( Level )
        {
        case 2:
            ppSecurityDescriptorCopy =
                &((LPPRINTER_INFO_2)pPrinterInfo)->pSecurityDescriptor;
            break;

        case 3:
            ppSecurityDescriptorCopy =
                &((LPPRINTER_INFO_3)pPrinterInfo)->pSecurityDescriptor;
            break;

        default:

            ErrorOccurred = TRUE;

            /* This should never happen */
            DBGMSG( DBG_ERROR, ("Invalid level %d in CopyIniPrinterSecurityDescriptor\n", Level ));

            break;
        }

        if (!ErrorOccurred) {

            // Copy the descriptor into the buffer that will be returned:

            *ppSecurityDescriptorCopy = (PSECURITY_DESCRIPTOR)pEnd;
            memcpy(*ppSecurityDescriptorCopy, pSecurityDescriptor,
                   SecurityDescriptorLength);
        }
    }

    if (pPartialSecurityDescriptor)
    {
        FreeSplMem(pPartialSecurityDescriptor);
    }

    if (ErrorOccurred)
    {
        pEnd = NULL;
    }

    return pEnd;
}



/* CopyIniPrinterToPrinter
 *
 * Copies the spooler's internal printer data to the caller's buffer,
 * depending on the level of information requested.
 *
 * Parameters
 *
 *     pIniPrinter - A pointer to the spooler's internal data structure
 *         for the printer concerned.
 *
 *     Level - Level of information requested (1, 2 or 3).  Any level
 *         other than those supported will cause the routine to return
 *         immediately.
 *
 *     pPrinterInfo - Pointer to the buffer to receive the PRINTER_INFO_*
 *         structure.
 *
 *     pEnd - Current position in the buffer to receive the data.
 *         This will be decremented to point to the next free bit of the
 *         buffer and will be returned.
 *
 *     pSecondPrinter - If the printer has a port which is being controlled
 *         by a monitor, this parameter points to information retrieved
 *         about a network printer.  This allows us, e.g., to return
 *         the number of jobs on the printer that the output of the
 *         printer is currently being directed to.
 *
 *     Remote - Indicates whether the caller is remote.  If so we have to
 *         include the machine name in the printer name returned.
 *
 *     CopySecurityDescriptor - Indicates whether the security descriptor
 *         should be copied.  The security descriptor should not be copied
 *         on EnumPrinters calls, because this API requires
 *         SERVER_ACCESS_ENUMERATE access, and we'd have to do an access
 *         check on every printer enumerated to determine how much of the
 *         security descriptor could be copied.  This would be costly,
 *         and the caller would probably not need the information anyway.
 *
 *     GrantedAccess - An access mask used to determine how much of the
 *         security descriptor the caller has access to.
 *
 *
 * Returns
 *
 *     A pointer to the point in the buffer reached after the requested
 *         data has been copied.
 *
 *     If there was an error, the  return value is NULL.
 *
 *
 * Assumes
 *
 *     The largest PRINTER_INFO_* structure is PRINTER_INFO_2.
 *
 */
LPBYTE
CopyIniPrinterToPrinter(
    PINIPRINTER         pIniPrinter,
    DWORD               Level,
    LPBYTE              pPrinterInfo,
    LPBYTE              pEnd,
    PPRINTER_INFO_2     pSecondPrinter2,
    LPWSTR              lpRemote,           // contains this machine name, or NULL
    BOOL                CopySecurityDescriptor,
    ACCESS_MASK         GrantedAccess,
    PDEVMODE            pDevMode
    )
{
    LPWSTR   SourceStrings[sizeof(PRINTER_INFO_2)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings=SourceStrings;
    DWORD    Attributes;

    //
    // Max string: "\\Computer\Printer,Driver,Location"
    //

    DWORD   dwRet;
    PWSTR   pszString = NULL;
    WCHAR   string[ MAX_PRINTER_BROWSE_NAME  ];
    DWORD   dwLength;
    WCHAR   printerString[ MAX_UNC_PRINTER_NAME ];
    LPWSTR  pszPorts;

    PPRINTER_INFO_3 pPrinter3 = (PPRINTER_INFO_3)pPrinterInfo;
    PPRINTER_INFO_2 pPrinter2 = (PPRINTER_INFO_2)pPrinterInfo;
    PPRINTER_INFO_1 pPrinter1 = (PPRINTER_INFO_1)pPrinterInfo;
    PPRINTER_INFO_4 pPrinter4 = (PPRINTER_INFO_4)pPrinterInfo;
    PPRINTER_INFO_5 pPrinter5 = (PPRINTER_INFO_5)pPrinterInfo;
    PPRINTER_INFO_6 pPrinter6 = (PPRINTER_INFO_6)pPrinterInfo;
    PPRINTER_INFO_7 pPrinter7 = (PPRINTER_INFO_7)pPrinterInfo;
    PPRINTER_INFO_STRESS pPrinter0 = (PPRINTER_INFO_STRESS)pPrinterInfo;
    PSECURITY_DESCRIPTOR pPartialSecurityDescriptor = NULL;
    DWORD   *pOffsets;
    SYSTEM_INFO si;
    DWORD cbNeeded;

    switch (Level) {

    case STRESSINFOLEVEL:

        pOffsets = PrinterInfoStressStrings;
        break;

    case 4:

        pOffsets = PrinterInfo4Strings;
        break;

    case 1:

        pOffsets = PrinterInfo1Strings;
        break;

    case 2:
        pOffsets = PrinterInfo2Strings;
        break;

    case 3:
        pOffsets = PrinterInfo3Strings;
        break;

    case 5:
        pOffsets = PrinterInfo5Strings;
        break;

    case 6:
        pOffsets = PrinterInfo6Strings;
        break;

    case 7:
        pOffsets = PrinterInfo7Strings;
        break;

    default:
        return pEnd;
    }

    //
    // If it's a cluster printer, it always appears remote.
    //
    Attributes = pIniPrinter->Attributes;

    Attributes |= ( pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ) ?
                     PRINTER_ATTRIBUTE_NETWORK :
                     PRINTER_ATTRIBUTE_LOCAL;

    switch (Level) {

    case STRESSINFOLEVEL:

        if (lpRemote) {

            wsprintf(string, L"%ws\\%ws", lpRemote, pIniPrinter->pName);
            *pSourceStrings++=string;
            *pSourceStrings++=lpRemote;

        } else {
            *pSourceStrings++=pIniPrinter->pName;
            *pSourceStrings++=NULL;
        }

        pEnd = PackStrings(SourceStrings, (LPBYTE)pPrinter0, pOffsets, pEnd);

        pPrinter0->cJobs                = pIniPrinter->cJobs;
        pPrinter0->cTotalJobs           = pIniPrinter->cTotalJobs;
        pPrinter0->cTotalBytes          = pIniPrinter->cTotalBytes.LowPart;
        pPrinter0->dwHighPartTotalBytes = pIniPrinter->cTotalBytes.HighPart;
        pPrinter0->stUpTime             = pIniPrinter->stUpTime;
        pPrinter0->MaxcRef              = pIniPrinter->MaxcRef;
        pPrinter0->cTotalPagesPrinted   = pIniPrinter->cTotalPagesPrinted;
        pPrinter0->dwGetVersion         = GetVersion();
#if DBG
        pPrinter0->fFreeBuild           = FALSE;
#else
        pPrinter0->fFreeBuild           = TRUE;
#endif
        GetSystemInfo(&si);
        pPrinter0->dwProcessorType      = si.dwProcessorType;
        pPrinter0->dwNumberOfProcessors   = si.dwNumberOfProcessors;
        pPrinter0->cSpooling              = pIniPrinter->cSpooling;
        pPrinter0->cMaxSpooling           = pIniPrinter->cMaxSpooling;
        pPrinter0->cRef                   = pIniPrinter->cRef;
        pPrinter0->cErrorOutOfPaper       = pIniPrinter->cErrorOutOfPaper;
        pPrinter0->cErrorNotReady         = pIniPrinter->cErrorNotReady;
        pPrinter0->cJobError              = pIniPrinter->cJobError;
        pPrinter0->cChangeID              = pIniPrinter->cChangeID;
        pPrinter0->dwLastError            = pIniPrinter->dwLastError;

        pPrinter0->Status   = MapPrinterStatus(MAP_READABLE,
                                               pIniPrinter->Status) |
                              pIniPrinter->PortStatus;

        pPrinter0->cEnumerateNetworkPrinters = pIniPrinter->pIniSpooler->cEnumerateNetworkPrinters;
        pPrinter0->cAddNetPrinters           = pIniPrinter->pIniSpooler->cAddNetPrinters;

        pPrinter0->wProcessorArchitecture    = si.wProcessorArchitecture;
        pPrinter0->wProcessorLevel           = si.wProcessorLevel;
        pPrinter0->cRefIC                    = pIniPrinter->cRefIC;

        break;

    case 4:

        if (lpRemote) {
            wsprintf(string, L"%ws\\%ws", lpRemote, pIniPrinter->pName);
            *pSourceStrings++=string;
            *pSourceStrings++= lpRemote;

        } else {
            *pSourceStrings++=pIniPrinter->pName;
            *pSourceStrings++=NULL;
        }

        pEnd = PackStrings(SourceStrings, (LPBYTE)pPrinter4, pOffsets, pEnd);

        //
        // Add additional info later
        //
        pPrinter4->Attributes = Attributes;
        break;

    case 1:

        if (lpRemote) {

            dwRet = StrCatAlloc(&pszString,
                                lpRemote,
                                L"\\",
                                pIniPrinter->pName,
                                L",",
                                pIniPrinter->pIniDriver->pName,
                                L",",
                                pIniPrinter->pLocation ?
                                pIniPrinter->pLocation :
                                szNull,
                                NULL);
            if (dwRet != ERROR_SUCCESS) {
                pEnd = NULL;
                break;
            }

            wsprintf(printerString, L"%ws\\%ws", lpRemote, pIniPrinter->pName);

        } else {

            dwRet = StrCatAlloc(&pszString,
                                pIniPrinter->pName,
                                L",",
                                pIniPrinter->pIniDriver->pName,
                                L",",
                                pIniPrinter->pLocation ?
                                pIniPrinter->pLocation :
                                szNull,
                                NULL);
            if (dwRet != ERROR_SUCCESS) {
                pEnd = NULL;
                break;
            }

            wcscpy(printerString, pIniPrinter->pName);
        }

        *pSourceStrings++=pszString;
        *pSourceStrings++=printerString;
        *pSourceStrings++=pIniPrinter->pComment;

        pEnd = PackStrings(SourceStrings, (LPBYTE)pPrinter1, pOffsets, pEnd);

        FreeSplStr(pszString);

        pPrinter1->Flags = PRINTER_ENUM_ICON8;

        break;

    case 2:

        if (lpRemote) {
            *pSourceStrings++= lpRemote;

            wsprintf(string, L"%ws\\%ws", lpRemote, pIniPrinter->pName);
            *pSourceStrings++=string;

        } else {
            *pSourceStrings++=NULL;
            *pSourceStrings++=pIniPrinter->pName;
        }

        *pSourceStrings++=pIniPrinter->pShareName;

        cbNeeded = 0;
        GetPrinterPorts(pIniPrinter, 0, &cbNeeded);

        if (pszPorts = AllocSplMem(cbNeeded)) {

            GetPrinterPorts(pIniPrinter, pszPorts, &cbNeeded);

            *pSourceStrings++=pszPorts;
            *pSourceStrings++=pIniPrinter->pIniDriver->pName;
            *pSourceStrings++=pIniPrinter->pComment;
            *pSourceStrings++=pIniPrinter->pLocation;
            *pSourceStrings++=pIniPrinter->pSepFile;
            *pSourceStrings++=pIniPrinter->pIniPrintProc->pName;
            *pSourceStrings++=pIniPrinter->pDatatype;
            *pSourceStrings++=pIniPrinter->pParameters;

            pEnd = PackStrings(SourceStrings, (LPBYTE)pPrinter2, pOffsets, pEnd);

            FreeSplMem(pszPorts);
        }
        else {
            pEnd = NULL;
            break;
        }


        if (pDevMode) {

            pEnd -= pDevMode->dmSize + pDevMode->dmDriverExtra;

            pEnd = (PBYTE)ALIGN_PTR_DOWN(pEnd);

            pPrinter2->pDevMode=(LPDEVMODE)pEnd;

            memcpy(pPrinter2->pDevMode, pDevMode, pDevMode->dmSize + pDevMode->dmDriverExtra);

            //
            // In the remote case, append the name of the server
            // in the devmode.dmDeviceName.  This allows dmDeviceName
            // to always match win.ini's [devices] section.
            //
            FixDevModeDeviceName(lpRemote ? string : pIniPrinter->pName,
                                 pPrinter2->pDevMode,
                                 pIniPrinter->cbDevMode);
        } else {

            pPrinter2->pDevMode=NULL;
        }



        pPrinter2->Attributes      = Attributes;
        pPrinter2->Priority        = pIniPrinter->Priority;
        pPrinter2->DefaultPriority = pIniPrinter->DefaultPriority;
        pPrinter2->StartTime       = pIniPrinter->StartTime;
        pPrinter2->UntilTime       = pIniPrinter->UntilTime;

        if (pSecondPrinter2) {

            pPrinter2->cJobs  = pSecondPrinter2->cJobs;
            pPrinter2->Status = pSecondPrinter2->Status;

            if( pIniPrinter->Status & PRINTER_PENDING_DELETION ){
                pPrinter2->Status |= PRINTER_STATUS_PENDING_DELETION;
            }

        } else {

            pPrinter2->cJobs=pIniPrinter->cJobs;

            pPrinter2->Status   = MapPrinterStatus(MAP_READABLE,
                                                   pIniPrinter->Status) |
                                  pIniPrinter->PortStatus;
        }

        pPrinter2->AveragePPM=pIniPrinter->AveragePPM;

        if( CopySecurityDescriptor ) {

            pEnd = CopyIniPrinterSecurityDescriptor(pIniPrinter,
                                                    Level,
                                                    pPrinterInfo,
                                                    pEnd,
                                                    GrantedAccess);
        } else {

            pPrinter2->pSecurityDescriptor = NULL;
        }

        break;

    case 3:

        pEnd = CopyIniPrinterSecurityDescriptor(pIniPrinter,
                                                Level,
                                                pPrinterInfo,
                                                pEnd,
                                                GrantedAccess);

        break;

    case 5:

        if (lpRemote) {
            wsprintf(string, L"%ws\\%ws", lpRemote, pIniPrinter->pName);
            *pSourceStrings++=string;
        } else {
            *pSourceStrings++=pIniPrinter->pName;
        }

        cbNeeded = 0;
        GetPrinterPorts(pIniPrinter, 0, &cbNeeded);

        if (pszPorts = AllocSplMem(cbNeeded)) {

            GetPrinterPorts(pIniPrinter, pszPorts, &cbNeeded);

            *pSourceStrings++ = pszPorts;

            pEnd = PackStrings(SourceStrings, (LPBYTE)pPrinter5, pOffsets, pEnd);

            pPrinter5->Attributes   = Attributes;
            pPrinter5->DeviceNotSelectedTimeout = pIniPrinter->dnsTimeout;
            pPrinter5->TransmissionRetryTimeout = pIniPrinter->txTimeout;

            FreeSplMem(pszPorts);
        }
        else
            pEnd = NULL;

        break;

    case 6:
        if (pSecondPrinter2) {
            pPrinter6->dwStatus = pSecondPrinter2->Status;

            if( pIniPrinter->Status & PRINTER_PENDING_DELETION ){
                pPrinter6->dwStatus |= PRINTER_STATUS_PENDING_DELETION;
            }
        } else {
            pPrinter6->dwStatus = MapPrinterStatus(MAP_READABLE,
                                                   pIniPrinter->Status) |
                                                   pIniPrinter->PortStatus;
        }
        break;

    case 7:

        *pSourceStrings++ = pIniPrinter->pszObjectGUID;

        pEnd = PackStrings(SourceStrings, (LPBYTE)pPrinter7, pOffsets, pEnd);

        if ( pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CACHE) {

            //
            // For connections, we rely directly on dwAction. The caching code
            // is the only one that updates dwAction in RefreshPrinterInfo7.
            //
            pPrinter7->dwAction = pIniPrinter->dwAction;

        } else {

            if (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED) {
                pPrinter7->dwAction = DSPRINT_PUBLISH;
                if (!pIniPrinter->pszObjectGUID ||
                    pIniPrinter->DsKeyUpdate    ||
                    pIniPrinter->DsKeyUpdateForeground) {
                    pPrinter7->dwAction |= DSPRINT_PENDING;
                }
            } else {
                pPrinter7->dwAction = DSPRINT_UNPUBLISH;
                if (pIniPrinter->pszObjectGUID                    ||
                    (pIniPrinter->DsKeyUpdate & DS_KEY_UNPUBLISH) ||
                    (pIniPrinter->DsKeyUpdateForeground & DS_KEY_UNPUBLISH)) {
                    pPrinter7->dwAction |= DSPRINT_PENDING;
                }
            }
        }
        break;

    default:
        return pEnd;
    }

    return pEnd;
}

BOOL
SplGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    PSPOOL              pSpool = (PSPOOL)hPrinter;
    BOOL                AccessIsGranted = FALSE;   // Must intialize
    PPRINTER_INFO_2     pSecondPrinter=NULL;
    LPBYTE              pEnd;
    LPWSTR              lpRemote;
    BOOL                bReturn = FALSE;
    PDEVMODE            pDevMode = NULL;
    PINIPRINTER         pIniPrinter;
    BOOL                bNt3xClient;
    PWSTR               pszCN = NULL, pszDN = NULL;
    DWORD               dwRet;


   EnterSplSem();

    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {

        goto Cleanup;
    }

    pIniPrinter = pSpool->pIniPrinter;
    bNt3xClient = (pSpool->TypeofHandle & PRINTER_HANDLE_3XCLIENT);

    //
    // If Nt3x client we will converted devmode. If driver can't convert we will not return devmode
    //
    if ( bNt3xClient && Level == 2 && pIniPrinter->pDevMode ) {

        //
        // Call driver to get a Nt3x DevMode (if fails no devmode is given)
        //
        if (wcsstr(pSpool->pName, gszDrvConvert))
            pDevMode = ConvertDevModeToSpecifiedVersion(pIniPrinter,
                                                        pIniPrinter->pDevMode,
                                                        NULL,
                                                        pSpool->pName,
                                                        NT3X_VERSION);
        else
            pDevMode = ConvertDevModeToSpecifiedVersion(pIniPrinter,
                                                        pIniPrinter->pDevMode,
                                                        NULL,
                                                        NULL,
                                                        NT3X_VERSION);
    }

    SplInSem();

    if (( pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_DATA ) ||
        ( pSpool->pIniSpooler != pLocalIniSpooler )) {

        lpRemote = pSpool->pFullMachineName;

    } else {

        lpRemote = NULL;

    }


    switch (Level) {

        case STRESSINFOLEVEL:
        case 1:
        case 2:
        case 4:
        case 5:
        case 6:
        case 7:

            if ( !AccessGranted(SPOOLER_OBJECT_PRINTER,
                                PRINTER_ACCESS_USE,
                                pSpool) ) {
                SetLastError(ERROR_ACCESS_DENIED);
                goto Cleanup;
            }

            break;

        case 3:

            if (!AreAnyAccessesGranted(pSpool->GrantedAccess,
                                       READ_CONTROL | ACCESS_SYSTEM_SECURITY)) {

                SetLastError(ERROR_ACCESS_DENIED);
                goto Cleanup;
            }

            break;

        default:
            break;
    }


    if (pSpool->pIniPort && !(pSpool->pIniPort->Status & PP_MONITOR)) {

        HANDLE hPort = pSpool->hPort;

        if (hPort == INVALID_PORT_HANDLE) {

            DBGMSG(DBG_WARNING, ("GetPrinter called with bad port handle.  Setting error %d\n",
                                 pSpool->OpenPortError));

            //
            // If this value is 0, then when we return GetLastError,
            // the client will think we succeeded.
            //
            SPLASSERT(pSpool->OpenPortError);

            goto PartialSuccess;
        }


        LeaveSplSem();

        if ((Level == 2 || Level == 6)) {

            if (!RetrieveMasqPrinterInfo(pSpool, &pSecondPrinter)) {
                goto CleanupFromOutsideSplSem;
            }
        }

        EnterSplSem();

        /* Re-validate the handle, since it might possibly have been closed
         * while we were outside the semaphore:
         */
        if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {

            goto Cleanup;
        }
    }

PartialSuccess:

    *pcbNeeded = GetPrinterSize(pIniPrinter, Level, 0, lpRemote,
                                bNt3xClient ? pDevMode : pIniPrinter->pDevMode);


    if (*pcbNeeded > cbBuf) {

        DBGMSG(DBG_TRACE, ("SplGetPrinter Failure with ERROR_INSUFFICIENT_BUFFER cbBuf is %d and pcbNeeded is %d\n", cbBuf, *pcbNeeded));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Cleanup;
    }

    pEnd = CopyIniPrinterToPrinter(pIniPrinter, Level, pPrinter,
                                   pPrinter+cbBuf, (PPRINTER_INFO_2) pSecondPrinter,
                                   lpRemote,
                                   TRUE, pSpool->GrantedAccess,
                                   bNt3xClient ? pDevMode : pIniPrinter->pDevMode);

    if ( pEnd != NULL)
        bReturn = TRUE;

Cleanup:

   LeaveSplSem();

CleanupFromOutsideSplSem:

    SplOutSem();
    FreeSplMem(pSecondPrinter);

    FreeSplMem(pDevMode);

    if ( bReturn == FALSE ) {

        SPLASSERT(GetLastError() != ERROR_SUCCESS);
    }

    return bReturn;
}

BOOL
EnumerateNetworkPrinters(
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    PINISPOOLER pIniSpooler
)
{
    PININETPRINT pIniNetPrint;
    DWORD        cb;
    LPBYTE       pEnd;
    BOOL         bReturnValue = FALSE;

   EnterSplSem();

    //
    // All network printers reside in pLocalIniSpooler to avoid
    // duplicates.
    //
    RemoveOldNetPrinters( NULL, pLocalIniSpooler );

    //
    //  If the Server has not been up long enough, then fail
    //  so the client will ask another Server for the Browse List.
    //

    if ( bNetInfoReady == FALSE ) {

        SetLastError( ERROR_CAN_NOT_COMPLETE );
        goto Done;
    }

    cb = 0;

    pIniNetPrint = pIniSpooler->pIniNetPrint;

    while (pIniNetPrint) {

        cb += GetIniNetPrintSize( pIniNetPrint );
        pIniNetPrint = pIniNetPrint->pNext;
    }

    *pcbNeeded = cb;

    if (cb > cbBuf) {

        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        goto    Done;
    }

    pIniNetPrint = pIniSpooler->pIniNetPrint;
    pEnd = pPrinter + cbBuf;

    while ( pIniNetPrint ) {

        pEnd = CopyIniNetPrintToPrinter( pIniNetPrint, pPrinter, pEnd );
        (*pcReturned)++;
        pPrinter += sizeof(PRINTER_INFO_1);
        pIniNetPrint = pIniNetPrint->pNext;

    }

    if ( *pcReturned == 0 ) {

        bNetInfoReady = FALSE;
        FirstAddNetPrinterTickCount = 0;
        SetLastError( ERROR_CAN_NOT_COMPLETE );

        DBGMSG( DBG_TRACE, ("EnumerateNetworkPrinters returning ERROR_CAN_NOT_COMPELTE becase there is no browse list\n"));

    } else {

        pIniSpooler->cEnumerateNetworkPrinters++;           // Stats only
        bReturnValue = TRUE;

        DBGMSG( DBG_TRACE, (" EnumerateNetworkPrnters called %d times returning %d printers\n", pIniSpooler->cEnumerateNetworkPrinters, *pcReturned ));
    }

Done:
   LeaveSplSem();
    SplOutSem();
    return bReturnValue;
}

/*++

Routine Name

    UpdateSpoolersRef

Routine Description:

    Does and AddRef or a DecRef on all pIniSpooler matching a certain criteria

Arguments:

    SpoolerType - Type of pIniSpoolers which to addref/decref
                  (Ex. SPL_TYPE_CLUSTER | SPL_TYPE_LOCAL)
    bAddRef     - TRUE means AddRef, FALSE means DecRef

Return Value:

    None

--*/
VOID
UpdateSpoolersRef(
    IN DWORD SpoolerType,
    IN BOOL  bAddRef
    )
{
    PINISPOOLER pIniSpooler;

    EnterSplSem();

    //
    // AddRef or DecRef all local and cluster spoolers
    //
    for (pIniSpooler = pLocalIniSpooler; pIniSpooler; pIniSpooler = pIniSpooler->pIniNextSpooler)
    {
        if (pIniSpooler->SpoolerFlags & SpoolerType)
        {
            if (bAddRef)
            {
                INCSPOOLERREF(pIniSpooler);
            }
            else
            {
                DECSPOOLERREF(pIniSpooler);
            }
        }
    }

    LeaveSplSem();
}

/*++

Routine Name

    SplEnumAllClusterPrinters

Routine Description:

    Enumerates all printers in the local spooler and all cluster
    spoolers hosted by localspl at the time of the call.

Arguments:

    InputFlags     - combination of ENUM_PRINTER_xxx
    pszInputName   - name of the print provider
    Level          - level of the call
    pPrinter       - buffer to hold the PRINTER_INFO_xxx structures
    cbInputBufSize - size of pPrinter buffer
    pcbNeeded      - bytes required to hold all the printer info structures
    pcReturned     - number of structures returned by this function

Return Value:

    TRUE  - cal succeeded
    FALSE - an error occurred, the function sets the last error

--*/
BOOL
SplEnumAllClusterPrinters(
    DWORD   InputFlags,
    LPWSTR  pszInputName,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbInputBufSize,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    PINISPOOLER pIniSpooler;

    DWORD cbBuf          = cbInputBufSize;
    DWORD cTotalReturned = 0;
    DWORD cbTotalNeeded  = 0;
    DWORD dwError        = ERROR_SUCCESS;
    DWORD cbStruct;

    switch (Level)
    {
        case STRESSINFOLEVEL:
            cbStruct = sizeof(PRINTER_INFO_STRESS);
            break;

        case 1:
            cbStruct = sizeof(PRINTER_INFO_1);
            break;

        case 2:
            cbStruct = sizeof(PRINTER_INFO_2);
            break;

        case 4:
            cbStruct = sizeof(PRINTER_INFO_4);
            break;

        case 5:
            cbStruct = sizeof(PRINTER_INFO_5);
            break;

        default:
            dwError = ERROR_INVALID_LEVEL;
    }

    if (dwError == ERROR_SUCCESS)
    {
        //
        // AddRef all ini spoolers
        //
        UpdateSpoolersRef(SPL_TYPE_LOCAL | SPL_TYPE_CLUSTER, TRUE);

        //
        // Enumerate all the printers
        //
        for (pIniSpooler = pLocalIniSpooler; pIniSpooler; pIniSpooler = pIniSpooler->pIniNextSpooler)
        {
            if (pIniSpooler->SpoolerFlags & (SPL_TYPE_LOCAL | SPL_TYPE_CLUSTER))
            {
                DWORD  cReturned;
                DWORD  cbNeeded;
                DWORD  Flags   = InputFlags;
                LPWSTR pszName = pszInputName;

                //
                // For clusters force the printer name to be fully qualified
                //
                if (pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER)
                {
                    Flags   |= PRINTER_ENUM_NAME;
                    pszName  = pIniSpooler->pMachineName;
                }

                if (SplEnumPrinters(Flags,
                                    pszName,
                                    Level,
                                    pPrinter,
                                    cbBuf,
                                    &cbNeeded,
                                    &cReturned,
                                    pIniSpooler))
                {
                    cTotalReturned += cReturned;
                    cbBuf          -= cbNeeded;
                    pPrinter       += cReturned * cbStruct;
                }
                else
                {
                    dwError = GetLastError();

                    if (dwError == ERROR_INSUFFICIENT_BUFFER)
                    {
                        cbBuf = 0;
                    }
                    else
                    {
                        //
                        // We cannot continue on an error different than insufficient buffer
                        //
                        break;
                    }
                }

                cbTotalNeeded += cbNeeded;
            }
        }

        //
        // DecRef all ini spoolers
        //
        UpdateSpoolersRef(SPL_TYPE_LOCAL | SPL_TYPE_CLUSTER, FALSE);

        //
        // Update out variables
        //
        if (dwError == ERROR_SUCCESS)
        {
            *pcbNeeded  = cbTotalNeeded;
            *pcReturned = cTotalReturned;
        }
        else if (dwError == ERROR_INSUFFICIENT_BUFFER)
        {
            *pcbNeeded  = cbTotalNeeded;
        }
        else
        {
            SetLastError(dwError);
        }
    }

    return dwError == ERROR_SUCCESS;
}

/*

EnumPrinters can be called with the following combinations:

Flags                   Name            Meaning

PRINTER_ENUM_LOCAL      NULL            Enumerate all Printers on this machine

PRINTER_ENUM_NAME       MachineName     Enumerate all Printers on this machine

PRINTER_ENUM_NAME |     MachineName     Enumerate all shared Printers on this
PRINTER_ENUM_SHARED     MachineName     machine

PRINTER_ENUM_NETWORK    MachineName     Enumerate all added remote printers

PRINTER_ENUM_REMOTE     ?               Return error - let win32spl handle it

PRINTER_ENUM_NAME       NULL            Give back Print Providor name

PRINTER_ENUM_NAME       "Windows NT Local Print Providor"
                                        same as PRINTER_ENUM_LOCAL

It is not an error if no known flag is specified.
In this case we just return TRUE without any data
(This is so that other print providers may define
their own flags.)

*/

BOOL
LocalEnumPrinters(
    DWORD   Flags,
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL  bReturn = ROUTER_UNKNOWN;

    if (Flags & PRINTER_ENUM_CLUSTER)
    {
        bReturn = SplEnumAllClusterPrinters(Flags,
                                            pName,
                                            Level,
                                            pPrinter,
                                            cbBuf,
                                            pcbNeeded,
                                            pcReturned);
    }
    else
    {
        PINISPOOLER pIniSpooler;

        //
        // Mask cluster flag
        //
        Flags &= ~PRINTER_ENUM_CLUSTER;

        pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

        if (pIniSpooler)
        {
            bReturn = SplEnumPrinters(Flags,
                                      pName,
                                      Level,
                                      pPrinter,
                                      cbBuf,
                                      pcbNeeded,
                                      pcReturned,
                                      pIniSpooler);

            FindSpoolerByNameDecRef(pIniSpooler);
        }
    }

    return bReturn;
}


BOOL
EnumThisPrinter(
    DWORD           Flags,
    PINIPRINTER     pIniPrinter,
    PINISPOOLER     pIniSpooler
    )
{


    //
    //  If they only want shared Printers
    //
    if ( (Flags & PRINTER_ENUM_SHARED) &&
         !(pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED) )
        return FALSE;

    //
    //  Only allow them to see printers which are being deleted if they have jobs
    //  This allows remote admin to work well.
    if ( (pIniPrinter->Status & PRINTER_PENDING_DELETION) &&
         pIniPrinter->cJobs == 0 )
        return FALSE;

    //
    //  Don't count printers which are partially created
    //
    if ( pIniPrinter->Status & PRINTER_PENDING_CREATION )
        return FALSE;

    return TRUE;
}


BOOL
SplEnumPrinters(
    DWORD   Flags,
    LPWSTR  Name,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    PINISPOOLER pIniSpooler
)
{
    PINIPRINTER pIniPrinter;
    PPRINTER_INFO_1 pPrinter1=(PPRINTER_INFO_1)pPrinter;
    DWORD       cb;
    LPBYTE      pEnd;
    LPWSTR      lpRemote;


    *pcbNeeded = 0;
    *pcReturned = 0;

    if ( Flags & PRINTER_ENUM_NAME ) {
        if ( Name && *Name ) {
            if (lstrcmpi(Name, szPrintProvidorName) && !MyName( Name, pIniSpooler)) {

                return FALSE;
            }

            // If it's PRINTER_ENUM_NAME of our name,
            // do the same as PRINTER_ENUM_LOCAL:

            Flags |= PRINTER_ENUM_LOCAL;

            // Also if it is for us then ignore the REMOTE flag.
            // Otherwise the call will get passed to Win32Spl which
            // will end up calling us back forever.

            Flags &= ~PRINTER_ENUM_REMOTE;
        }
    }

    if ( Flags & PRINTER_ENUM_REMOTE ) {
        SetLastError( ERROR_INVALID_NAME );
        return FALSE;
    }

    lpRemote = NULL;

    if ( Name && *Name ) {

        if ( MyName( Name, pIniSpooler ) ) {
            lpRemote = Name;
        }
    }

    if ((Level == 1) && (Flags & PRINTER_ENUM_NETWORK)) {

        SplOutSem();
        return EnumerateNetworkPrinters( pPrinter, cbBuf, pcbNeeded, pcReturned, pIniSpooler );
    }

   EnterSplSem();

    if ((Level == 1 ) && (Flags & PRINTER_ENUM_NAME) && !Name) {

        LPWSTR   SourceStrings[sizeof(PRINTER_INFO_1)/sizeof(LPWSTR)];
        LPWSTR   *pSourceStrings=SourceStrings;

        cb = wcslen(szPrintProvidorName)*sizeof(WCHAR) + sizeof(WCHAR) +
             wcslen(szPrintProvidorDescription)*sizeof(WCHAR) + sizeof(WCHAR) +
             wcslen(szPrintProvidorComment)*sizeof(WCHAR) + sizeof(WCHAR) +
             sizeof(PRINTER_INFO_1);

        *pcbNeeded=cb;

        if (cb > cbBuf) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
           LeaveSplSem();
            return FALSE;
        }

        *pcReturned = 1;

        pPrinter1->Flags = PRINTER_ENUM_CONTAINER | PRINTER_ENUM_ICON1;

        *pSourceStrings++=szPrintProvidorDescription;
        *pSourceStrings++=szPrintProvidorName;
        *pSourceStrings++=szPrintProvidorComment;

        PackStrings(SourceStrings, pPrinter, PrinterInfo1Strings,
                    pPrinter+cbBuf);

       LeaveSplSem();

        return TRUE;
    }

    cb=0;

    if (Flags & (PRINTER_ENUM_LOCAL | PRINTER_ENUM_NAME)) {

        //
        // For remote user's who are not admins enumerate shared printers only
        //
        if ( !IsLocalCall()                                 &&
             !(Flags & PRINTER_ENUM_SHARED)                 &&
             !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                                   SERVER_ACCESS_ADMINISTER,
                                   NULL,
                                   NULL,
                                   pIniSpooler) )
            Flags   |= PRINTER_ENUM_SHARED;

        //
        //  Calculate the size required
        //

        for ( pIniPrinter = pIniSpooler->pIniPrinter;
              pIniPrinter != NULL;
              pIniPrinter = pIniPrinter->pNext ) {

#ifdef _HYDRA_
            if ( EnumThisPrinter(Flags, pIniPrinter, pIniSpooler) && ShowThisPrinter( pIniPrinter ))
#else
            if ( EnumThisPrinter(Flags, pIniPrinter, pIniSpooler) )
#endif
                cb += GetPrinterSize(pIniPrinter, Level, Flags,
                                     lpRemote, pIniPrinter->pDevMode);

        }

    }
    *pcbNeeded=cb;

    if (cb > cbBuf) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
       LeaveSplSem();
        return FALSE;
    }

    if (Flags & (PRINTER_ENUM_LOCAL | PRINTER_ENUM_NAME)) {

        for ( pIniPrinter = pIniSpooler->pIniPrinter, pEnd = pPrinter + cbBuf;
              pIniPrinter != NULL;
              pIniPrinter = pIniPrinter->pNext ) {


            if ( !EnumThisPrinter(Flags, pIniPrinter, pIniSpooler) )
                continue;

#ifdef _HYDRA_
            // Do not list printers without access
            if( !ShowThisPrinter( pIniPrinter ) ) {
                continue;
            }
#endif

            pEnd = CopyIniPrinterToPrinter( pIniPrinter, Level, pPrinter,
                                            pEnd, NULL, lpRemote, FALSE, 0,
                                            pIniPrinter->pDevMode );

            if (!pEnd) {
               LeaveSplSem();
                return FALSE;
            }

            (*pcReturned)++;

            switch (Level) {

                case STRESSINFOLEVEL:
                    pPrinter+=sizeof(PRINTER_INFO_STRESS);
                    break;

                case 1:
                    pPrinter+=sizeof(PRINTER_INFO_1);
                    break;

                case 2:
                    pPrinter+=sizeof(PRINTER_INFO_2);
                    break;

                case 4:
                    pPrinter+=sizeof(PRINTER_INFO_4);
                    break;

                case 5:
                    pPrinter+=sizeof(PRINTER_INFO_5);
                    break;

            }
        }
    }

   LeaveSplSem();

    return TRUE;
}

#ifdef _HYDRA_
/* ShowThisPrinter
 *
 * Returns whether this printer should be visible to the current
 * user.
 *
 * We do not show printers that the caller does not
 * have access to. This is for two reasons:
 *
 * 1: A multi-user system with 200 users each with their
 *    own client printers would cause a large confusing
 *    list of printers from within applications such as word.
 *    "Client" printers are owned by the user of that station,
 *    and by default only allow print access for that user.
 *    This provides a simple way of filtering printers to show
 *    to the user for a selection.
 *
 * 2: Programs such as Windows write get confused when
 *    they see a printer they can not open. This is a bad
 *    program, since normal NT can have a printer denied to a user, but we must
 *    make it work anyway.
 *
 *
 * Must work out security modes!
 *
 * Parameters
 *
 *     pIniPrinter - A pointer to the spooler's internal data structure
 *         for the printer concerned.
 */
BOOL
ShowThisPrinter(
    PINIPRINTER pIniPrinter
    )
{
    LPWSTR            pObjectName;
    HANDLE            ClientToken;
    BOOL              AccessCheckOK;
    BOOL              OK;
    BOOL              AccessStatus = TRUE;
    ACCESS_MASK       MappedDesiredAccess;
    DWORD             GrantedAccess = 0;
    PBOOL             pGenerateOnClose;
    BYTE              PrivilegeSetBuffer[256];
    DWORD             PrivilegeSetBufferLength = 256;
    PPRIVILEGE_SET    pPrivilegeSet;
    DWORD             dwRetCode;

    PTOKEN_PRIVILEGES pPreviousTokenPrivileges;
    DWORD PreviousTokenPrivilegesLength;

    // External references to global variables in security.c
    extern GENERIC_MAPPING GenericMapping[];
    extern WCHAR           *szSpooler;


    //
    // If Hydra is not enabled, keep NT behavior unchanged
    //
    if( !(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer)) ) {
        return( TRUE );
    }

    //
    // Administrators see all printers. This allows an
    // Admin to take ownership of a printer whose ACL is
    // messed up.
    //
    if( ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                             SERVER_ACCESS_ADMINISTER,
                             NULL,
                             NULL,
                             pIniPrinter->pIniSpooler) ) {
        return( TRUE );
    }

    MapGenericToSpecificAccess(
        SPOOLER_OBJECT_PRINTER,
        PRINTER_ACCESS_USE,
        &MappedDesiredAccess
        );

    if (!(OK = GetTokenHandle(&ClientToken))) {
        return(FALSE);
    }

    pPrivilegeSet = (PPRIVILEGE_SET)PrivilegeSetBuffer;

    /* Call AccessCheck followed by ObjectOpenAuditAlarm rather than
     * AccessCheckAndAuditAlarm, because we may need to enable
     * SeSecurityPrivilege in order to check for ACCESS_SYSTEM_SECURITY
     * privilege.  We must ensure that the security access-checking
     * API has the actual token whose security privilege we have enabled.
     * AccessCheckAndAuditAlarm is no good for this, because it opens
     * the client's token again, which may not have the privilege enabled.
     */
    AccessCheckOK = AccessCheck( pIniPrinter->pSecurityDescriptor,
                                 ClientToken,
                                 MappedDesiredAccess,
                                 &GenericMapping[SPOOLER_OBJECT_PRINTER],
                                 pPrivilegeSet,
                                 &PrivilegeSetBufferLength,
                                 &GrantedAccess,
                                 &AccessStatus );

    // Close the client token handle now
    CloseHandle (ClientToken);

    if (!AccessCheckOK) {

        //
        // We do not audit and set off alarms because the caller
        // did not really try and open the printer.
        // We the server tried to check access for display purposes, not
        // for handle create.
        //
        if (GetLastError() == ERROR_NO_IMPERSONATION_TOKEN) {
            DBGMSG( DBG_ERROR, ("ShowThisPrinter: No impersonation token.  Printer will be enumerated\n"));
            return( TRUE );
        }else {
            DBGMSG( DBG_TRACE, ("ShowThisPrinter: Printer %ws Not accessable by caller Access Check failuer %d\n",pIniPrinter->pName,GetLastError()));
            return( FALSE );
        }
    }
    else if( !AccessStatus ) {
        DBGMSG( DBG_TRACE, ("ShowThisPrinter: Printer %ws Not accessable by caller AccessStatus failure %d\n",pIniPrinter->pName,GetLastError()));
        return( FALSE );
    }

    return( TRUE );
}
#endif

/*++

Routine Name:

    RetrieveMasqPrinterInfo

Description:

    This retrieves Masq information for the printer, it is either cached state
    or a direct call into the provider depending on Reg Settings.

Arguments:

    pSpool          -   The spool handle that we use for synchronisation.
    ppPrinterInfo   -   The returned printer info.

Returns:

    A Boolean, if FALSE, last error is set.

--*/
BOOL
RetrieveMasqPrinterInfo(
    IN      PSPOOL              pSpool,
        OUT PRINTER_INFO_2      **ppPrinterInfo
    )
{
    BOOL            bRet           = TRUE;
    PINIPRINTER     pIniPrinter    = NULL;

    pIniPrinter = pSpool->pIniPrinter;

    SplOutSem();

    if (!(pSpool->pIniSpooler->dwSpoolerSettings & SPOOLER_CACHEMASQPRINTERS))
    {
        //
        // Just synchronously return the data from the partial print provider.
        //
        bRet = BoolFromStatus(GetPrinterInfoFromRouter(pSpool->hPort, ppPrinterInfo));
    }
    else
    {
        //
        // Kick off the thread that goes and reads the masq status.
        //
        BOOL            bCreateThread  = FALSE;
        PRINTER_INFO_2  *pPrinterInfo2 = NULL;

        EnterSplSem();

        if (!pIniPrinter->MasqCache.bThreadRunning)
        {
            bCreateThread = TRUE;
            pIniPrinter->MasqCache.bThreadRunning = TRUE;

            INCPRINTERREF(pIniPrinter);
        }

        LeaveSplSem();

        SplOutSem();

        if (bCreateThread)
        {
            HANDLE                  hThread         = NULL;
            MasqUpdateThreadData    *pThreadData    = NULL;
            DWORD                   dwThreadId      = 0;

            pThreadData = AllocSplMem(sizeof(*pThreadData));

            bRet = pThreadData != NULL;

            if (bRet)
            {
                bRet = GetSid(&pThreadData->hUserToken);
            }

            if (bRet)
            {
                pThreadData->pIniPrinter = pIniPrinter;

                hThread = CreateThread(NULL, 0, AsyncPopulateMasqPrinterCache, (VOID *)pThreadData, 0, &dwThreadId);

                bRet = hThread != NULL;
            }

            if (bRet)
            {
                pThreadData = NULL;
            }

            //
            // If we couldn't create the thread, then drop the ref count on the
            // pIniPrinter again and set thread running to false.
            //
            if (!bRet)
            {
                EnterSplSem();

                pIniPrinter->MasqCache.bThreadRunning = FALSE;
                DECPRINTERREF(pIniPrinter);

                LeaveSplSem();
            }

            if (hThread)
            {
                CloseHandle(hThread);
            }

            if (pThreadData)
            {
                if (pThreadData->hUserToken)
                {
                    CloseHandle(pThreadData->hUserToken);
                }

                FreeSplMem(pThreadData);
            }
        }

        //
        // Check to see the cached error return for the printer.
        //
        if (bRet)
        {
            EnterSplSem();

            if (pIniPrinter->MasqCache.dwError != ERROR_SUCCESS)
            {
                SetLastError(pIniPrinter->MasqCache.dwError);

                bRet = FALSE;
            }

            //
            // Caller is only interested in the Status and cJobs members, all strings
            // are set to NULL by the allocation.
            //
            if (bRet)
            {
                pPrinterInfo2 = AllocSplMem(sizeof(PRINTER_INFO_2));

                bRet = pPrinterInfo2 != NULL;
            }

            if (bRet)
            {
                pPrinterInfo2->Status = pIniPrinter->MasqCache.Status;
                pPrinterInfo2->cJobs  = pIniPrinter->MasqCache.cJobs;

                *ppPrinterInfo = pPrinterInfo2;
                pPrinterInfo2 = NULL;
            }

            LeaveSplSem();
        }

        FreeSplMem(pPrinterInfo2);
    }

    return bRet;
}

/*++

Routine Name:

    GetPrinterInfoFromRouter

Description:

    This does a GetPrinter call against the router, it returns the error code
    as a status.

Arguments:

    hMasqPrinter    -   Handle to the masq printer.
    ppPrinterInfo   -   Returned printer info.

Returns:

    Status Code.

--*/
DWORD
GetPrinterInfoFromRouter(
    IN      HANDLE              hMasqPrinter,
        OUT PRINTER_INFO_2      **ppPrinterInfo
    )
{
    DWORD           Status = ERROR_SUCCESS;
    DWORD           cb     = 4096;
    PRINTER_INFO_2  *pPrinterInfo2 = NULL;
    DWORD           cbNeeded;

    SplOutSem();

    pPrinterInfo2 = AllocSplMem(cb);

    Status = pPrinterInfo2 != NULL ? ERROR_SUCCESS : ERROR_OUTOFMEMORY;

    if (ERROR_SUCCESS == Status)
    {
        Status = GetPrinter(hMasqPrinter, 2, (BYTE *)pPrinterInfo2, cb, &cbNeeded) ? ERROR_SUCCESS : GetLastError();
    }

    if (ERROR_INSUFFICIENT_BUFFER == Status)
    {
        FreeSplMem(pPrinterInfo2);
        pPrinterInfo2 = NULL;

        cb = cbNeeded;

        pPrinterInfo2 = AllocSplMem(cb);

        Status = pPrinterInfo2 != NULL ? ERROR_SUCCESS : ERROR_OUTOFMEMORY;

        if (ERROR_SUCCESS == Status)
        {
            Status = GetPrinter(hMasqPrinter, 2, (BYTE *)pPrinterInfo2, cb, &cbNeeded) ? ERROR_SUCCESS : GetLastError();
        }
    }

    if (ERROR_SUCCESS == Status)
    {
        *ppPrinterInfo = pPrinterInfo2;
        pPrinterInfo2 = NULL;
    }

    FreeSplMem(pPrinterInfo2);

    return Status;
}


/*++

Routine Name:

    AsyncPopulateMasqPrinterCache

Description:

    This populates the Masq printer cache for a given pIniPrinter.

Arguments:

    pvThreadData     -   Pointer to a MasqUpdateThreadData structure

Returns:

    A DWORD status, ignored.

--*/
DWORD
AsyncPopulateMasqPrinterCache(
    IN      VOID                *pvThreadData
    )
{
    DWORD                   Status          = ERROR_SUCCESS;
    PINIPRINTER             pIniPrinter     = NULL;
    PINIPORT                pIniPort        = NULL;
    PWSTR                   pszPrinterName  = NULL;
    HANDLE                  hMasqPrinter    = NULL;
    PRINTER_INFO_2          *pPrinterInfo2  = NULL;
    MasqUpdateThreadData    *pThreadData    = NULL;

    SplOutSem();

    pThreadData = (MasqUpdateThreadData *)pvThreadData;

    pIniPrinter = pThreadData->pIniPrinter;

    Status = SetCurrentSid(pThreadData->hUserToken) ? ERROR_SUCCESS : GetLastError();

    EnterSplSem();

    //
    // Find the port associated with the printer.
    //
    if (Status == ERROR_SUCCESS)
    {
        pIniPort = FindIniPortFromIniPrinter(pIniPrinter);

        Status = pIniPort && !(pIniPort->Status & PP_MONITOR) ? ERROR_SUCCESS : ERROR_INVALID_FUNCTION;
    }

    if (Status == ERROR_SUCCESS)
    {
        INCPORTREF(pIniPort);

        LeaveSplSem();

        SplOutSem();

        //
        // This relies on the fact that a masq port cannot be renamed.
        //
        if (OpenPrinterPortW(pIniPort->pName, &hMasqPrinter, NULL))
        {
            //
            // This will propogate any errors into the masq cache, which we
            // don't have to do twice, so we ignore the return code.
            //
            Status = GetPrinterInfoFromRouter(hMasqPrinter, &pPrinterInfo2);

            ClosePrinter(hMasqPrinter);
        }
        else
        {
            Status = GetLastError();

            if (Status == ERROR_SUCCESS)
            {
                Status = ERROR_UNEXP_NET_ERR;
            }
        }

        EnterSplSem();

        if (ERROR_SUCCESS == Status)
        {
            pIniPrinter->MasqCache.cJobs    = pPrinterInfo2->cJobs;
            pIniPrinter->MasqCache.Status   = pPrinterInfo2->Status;
        }
        else
        {
            pIniPrinter->MasqCache.cJobs = 0;
            pIniPrinter->MasqCache.Status = 0;
        }

        //
        // We always want to reset the status.
        //
        pIniPrinter->MasqCache.dwError = Status;


        DECPORTREF(pIniPort);
    }

    SplInSem();

    pIniPrinter->MasqCache.bThreadRunning = FALSE;
    DECPRINTERREF(pIniPrinter);

    DeletePrinterCheck(pIniPrinter);

    LeaveSplSem();

    if (pThreadData)
    {
        CloseHandle(pThreadData->hUserToken);
    }

    FreeSplMem(pThreadData);

    FreeSplMem(pPrinterInfo2);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\filepool.cxx ===
/*++

Copyright (c) 1990 - 2000  Microsoft Corporation

Module Name:

    filepool.cxx

Abstract:

    Contains the routines for handling Filepools for the Spooler. Contains the C++ objects
    and the C wrapper functions.

Author:

    Bryan Kilian (Bryankil) 5-Apr-2000

Revision History:


--*/


#include "precomp.h"
  
#pragma hdrstop
    

#include "filepool.hxx"

  
VOID FPCloseFiles(struct FileListItem * pItem, BOOL CloseShad);
  

/*--

Interface Functions:
    
    CreateFilePool
    GetFileItemHandle
    GetNameFromHandle
    GetWriterFromHandle
    GetReaderFromHandle
    ReleasePoolHandle
    DestroyFilePool
    
--*/    

/*********************
 * CreateFilePool()
 *
 * Creates the Filepool. 
 *
 * Arguments:
 *   OUT  FilePool     : Pointer to a Filepool handle.
 *   IN   BasePath     : String to use as a spool dir.
 *   IN   PreNumStr    : String to use as a filename prefix.
 *   IN   SplExt       : String to use as a spool extension.
 *   IN   ShdExt       : String to use as a shadow file extension.
 *   IN   PoolTimeout  : Dword in milliseconds before an idle pool item gets deleted.
 *   IN   MaxFiles     : Maximum number of free files in the pool.
 *
 * The path gets created as <Basepath>\<PreNumStr>XXXXX<SplExt>
 *
 */


HRESULT CreateFilePool(
    HANDLE * FilePoolHandle,
    LPCTSTR  BasePath,
    LPCTSTR  PreNumStr,
    LPCTSTR  SplExt,
    LPCTSTR  ShdExt,
    DWORD    PoolTimeout,
    DWORD    MaxFiles
    )
{
    HRESULT RetVal = E_FAIL;
    
    class FilePool * FP = NULL;
    
    if (FilePoolHandle && BasePath && PreNumStr && SplExt && ShdExt)
    {
        MaxFiles = (MaxFiles > 9999) ? 9999 : MaxFiles;
        FP = new FilePool(
                    PoolTimeout,
                    MaxFiles
                    );


        if ( FP )
        {
            RetVal = FP->AllocInit(
                            BasePath,
                            PreNumStr,
                            SplExt,
                            ShdExt
                            );
            if (SUCCEEDED(RetVal))
            {
                *FilePoolHandle = (HANDLE) FP;
            }
            else
            {
                delete FP;
                *FilePoolHandle = INVALID_HANDLE_VALUE;
            }
        }
    }
    else
    {
        RetVal = E_INVALIDARG;
    }


    return RetVal;
}

/*********************
 * GetFileItemHandle()
 *
 * Takes a FilePool Object and An empty Filehandle, and returns
 * an open File handle. Use ReleasePoolHandle Once you're finished
 * with the file. 
 *
 * Arguments:
 *   IN   FilePool     : Handle of a FilePool Object Created with CreateFilePool()
 *   OUT  FileItem     : Pointer to a FileItem Handle.
 *   IN   FromFilename : String to use as a filename.
 *
 * Returns Error if it is passed in an invalid argument, or S_OK if it succeeds. 
 *
 */

HRESULT 
GetFileItemHandle(   
    HANDLE FilePoolHandle, 
    HANDLE * FileItem,
    LPWSTR FromFilename
    )
{
   class FilePool * FP = NULL;
   HRESULT RetVal = E_FAIL;
   struct FileListItem * FLItem = NULL;

   FP = (class FilePool *)FilePoolHandle;

   RetVal = FP->GetWriteFileStruct(&FLItem, FromFilename);

   if (SUCCEEDED(RetVal))
   {
       *FileItem = (HANDLE) FLItem;
   }
   else
   {
       *FileItem = INVALID_HANDLE_VALUE;
   }

   return RetVal;
}


/*********************
 * GetNameFromHandle()
 *
 * Takes a FileItem and a string pointer, and returns
 * an allocated string containing the name of the file.
 *
 * Arguments:
 *   IN   FileItem     : Handle of a FileItem, retrieved with GetFileItemHandle()
 *   OUT  FileNameStr  : Pointer to a string variable.
 *   IN   IsSpool      : BOOL - TRUE - Returns the Spool Filename, FALSE returns the Shadow Filename
 *
 * Returns Error if it is passed in an invalid argument or if it cannot allocate the string,
 * or S_OK if it succeeds. 
 *
 */

HRESULT 
GetNameFromHandle(
    HANDLE FileItem, 
    PWSTR * FileNameStr,
    BOOL    IsSpool
    )
{
    HRESULT RetVal = S_OK;
    struct FileListItem * FPI;

    if (FileItem && (FileItem != INVALID_HANDLE_VALUE))
    {
        FPI = (struct FileListItem *)FileItem;

        if (FileNameStr && !*FileNameStr)
        {
            if (IsSpool)
            {
                *FileNameStr = AllocSplStr(FPI->SplFilename);
            }
            else
            {
                *FileNameStr = AllocSplStr(FPI->ShdFilename);
            }
            if (!*FileNameStr)
            {
                RetVal = E_OUTOFMEMORY;
            }
        }
        else
        {
            RetVal = E_INVALIDARG;
        }
    }
    else
    {
        RetVal = E_INVALIDARG;
    }

    return RetVal;
}

/*********************
 * GetCurrentWriter()
 *
 * Takes a FileItem and returns a FileHandle of the current WriteHandle if it exists.
 *
 * Arguments:
 *   IN   FileItem     : FileItem Handle.
 *   IN   IsSpool      : BOOL - TRUE: Returns the Spool file handle, FALSE returns the Shadow file handle.
 *
 * This will not create a writer if it is not yet created, and will also not update the object's flags.
 *
 * Return: Valid Handle if success or INVALID_HANDLE_VALUE.
 */

HANDLE GetCurrentWriter(
    HANDLE FileItem,
    BOOL   IsSpool)
{
    struct FileListItem * FPI;
    HANDLE RetVal = INVALID_HANDLE_VALUE;
    HANDLE Temp = INVALID_HANDLE_VALUE;
    
    if (FileItem)
    {
        FPI = (struct FileListItem *) FileItem;
        
        FPI->EnterCritSec();

        if (IsSpool)
        {
            Temp = FPI->SplWriteHandle;
        }
        else
        {
            Temp = FPI->ShdWriteHandle;
        }

        FPI->LeaveCritSec();

        if (Temp != INVALID_HANDLE_VALUE)
        {
            RetVal = Temp;
        }
    }

    return RetVal;
}

/*********************
 * GetFileCreationInfo
 *
 * Takes a FileItem and returns a bitmap.
 *
 * Arguments:
 *   IN   FileItem     : FileItem Handle.
 *   OUT  BitMap
 *
 * Returns bitmap indicating which files needed to be opened.  Bitmap reset when
 * the pool handle is released.
 *
 * Return: S_OK if success, otherwise an error value.
 */


HRESULT
GetFileCreationInfo(
    HANDLE FileItem,
    PDWORD BitMap
    )
{
    struct FileListItem * FPI;
    *BitMap = 0;

    if (FileItem && (FileItem != INVALID_HANDLE_VALUE))
    {
        FPI = (struct FileListItem *) FileItem;
        *BitMap = FPI->CreateInfo;
        return S_OK;
    }
    return E_FAIL;
}



/*********************
 * GetWriterFromHandle()
 *
 * Takes a FileItem and returns a FileHandle with an open Writer.
 *
 * Arguments:
 *   IN   FileItem     : FileItem Handle.
 *   OUT  File         : Pointer to a filehandle.
 *   IN   IsSpool      : BOOL - TRUE: Returns the Spool file handle, FALSE returns the Shadow file handle.
 *
 * This will create a writer if it is not yet created, and will also update the object's flags. It will 
 * return the current handle if there is one.
 *
 * Return: S_OK if success, otherwise an error value.
 */

HRESULT 
GetWriterFromHandle(
    HANDLE   FileItem, 
    HANDLE * File,
    BOOL     IsSpool
    )
{
    HRESULT RetVal = S_OK;
    class FilePool * FP = NULL;
    struct FileListItem * FPI;


    if (FileItem && File)
    {
        FPI = (struct FileListItem *) FileItem;
        FP = FPI->FP;

        *File = INVALID_HANDLE_VALUE;
        
        FPI->EnterCritSec();

        if (IsSpool)
        {
            if (FPI->SplWriteHandle == INVALID_HANDLE_VALUE)
            {
                RetVal = FP->CreateSplWriter(FPI);
            }
            
        }
        else
        {
            if (FPI->ShdWriteHandle == INVALID_HANDLE_VALUE)
            {
                RetVal = FP->CreateShdWriter(FPI);
            }

        }

        if (SUCCEEDED(RetVal))
        {
            if (IsSpool)
            {
                *File = FPI->SplWriteHandle;
                FPI->Status |= FP_STATUS_SPL_WRITING;
            }
            else
            {
                *File = FPI->ShdWriteHandle;
                FPI->Status |= FP_STATUS_SHD_WRITING;
            }
        }
        else
        {
            RetVal = E_FAIL;
        }

        FPI->LeaveCritSec();

    }
    else
    {
        RetVal = E_INVALIDARG;
    }


    return RetVal;
}

/*********************
 * GetReaderFromHandle()
 *
 * Takes a FileItem and returns a FileHandle with an open Reader.
 *
 * Arguments:
 *   IN   FileItem     : FileItem Handle.
 *   OUT  File         : Pointer to a filehandle.
 *
 * This will create a Reader if it is not yet created, and will also update the object's flags. It will 
 * return the current handle if there is one. It will also return the writer if the system is finished with it.
 *
 * Return: S_OK if success, otherwise an error value.
 */

HRESULT 
GetReaderFromHandle(
    HANDLE FileItem, 
    HANDLE * File
    )
{
    HRESULT RetVal = S_OK;
    class FilePool * FP = NULL;
    struct FileListItem * FPI;

    if (FileItem)
    {
        FPI = (struct FileListItem *) FileItem;
        FP = FPI->FP;
        
        // CriticalSection

        FPI->EnterCritSec();

        if (!(FPI->Status & FP_STATUS_SPL_WRITING) && 
            (FPI->SplWriteHandle != INVALID_HANDLE_VALUE) &&
            (FPI->SplReadHandle == INVALID_HANDLE_VALUE) )
        {
            //
            // We aren't writing this job anymore, we can reuse the
            // write handle for reading.
            //
            if (!(FPI->Status & FP_STATUS_SPL_READING))
            {
                if (SetFilePointer(FPI->SplWriteHandle, 0, NULL, FILE_BEGIN) !=
                    INVALID_SET_FILE_POINTER)
                {
                    *File = FPI->SplWriteHandle;
                    FPI->Status |= FP_STATUS_SPL_READING;
                }
                else
                {
                    RetVal = E_FAIL;
                }
                
            }
            else
            {
                *File = FPI->SplWriteHandle;
            }
        }
        else
        {
            //
            // We are still writing this job, so we need to use the readhandle.
            //
            if (FPI->SplReadHandle == INVALID_HANDLE_VALUE)
            {
                //
                // The Reader doesn't already exist, We need to create it.
                //
                RetVal = FP->CreateSplReader(FPI);

            }

            if (SUCCEEDED(RetVal))
            {
                //
                // We now have a valid handle
                //

                *File = FPI->SplReadHandle;
                FPI->Status |= FP_STATUS_SPL_READING;

            }
            else
            {
                RetVal = E_FAIL;
            }

        }

        FPI->LeaveCritSec();

    }
    else
    {
        RetVal = E_INVALIDARG;
    }
    return RetVal;
}

/*********************
 * FishedReading()
 *
 * Indicates to the object that we are finished with it for reading purposes.
 *
 * Arguments:
 *   IN   FileItem     : Handle of a FileItem.
 *
 * Returns Error if it is passed in an invalid argument, or S_OK if it succeeds. 
 *
 */

HRESULT 
FinishedReading(
    HANDLE FileItem
    )
{
    HRESULT RetVal = S_OK;
    struct FileListItem * FPI;

    if (FileItem)
    {
        FPI = (struct FileListItem *) FileItem;

        FPI->EnterCritSec();
        FPI->Status &= ~FP_STATUS_SPL_READING;
        FPI->LeaveCritSec();

    }
    else
    {
        RetVal = E_INVALIDARG;
    }


    return RetVal;

}
    
/*********************
 * FishedWriting()
 *
 * Indicates to the object that we are finished with it for writing purposes.
 *
 * Arguments:
 *   IN   FileItem     : Handle of a FileItem.
 *   IN   IsSpool      : BOOL - TRUE: Affects the Spl file, FALSE: Affects the Shd file.
 *
 * Returns Error if it is passed in an invalid argument, or S_OK if it succeeds. 
 *
 */

HRESULT 
FinishedWriting(
    HANDLE FileItem,
    BOOL   IsSpool
    )
{
    HRESULT RetVal = S_OK;
    struct FileListItem * FPI;

    if (FileItem)
    {
        FPI = (struct FileListItem *) FileItem;

        FPI->EnterCritSec();
        if (IsSpool)
        {
            FPI->Status &= ~FP_STATUS_SPL_WRITING;
        }
        else
        {
            FPI->Status &= ~FP_STATUS_SHD_WRITING;
        }
        FPI->LeaveCritSec();
    }
    else
    {
        RetVal = E_INVALIDARG;
    }


    return RetVal;

}

/*********************
 * ReleasePoolHandle()
 *
 * Releases the pool item back to the pool to reuse. The pool will not reuse the item if all the 
 * filehandles are closed, and also if we have reached our free files limit.
 *
 * Arguments:
 * IN OUT FileItem     : Pointer to a FileItem Handle.
 *
 * Returns Error if it fails, or S_OK if it succeeds. FileItem gets set to INVALID_HANDLE_VALUE if it succeeds.
 *
 */

HRESULT 
ReleasePoolHandle(
    HANDLE * FileItem
    )
{
    HRESULT RetVal = S_OK;
    class FilePool * FP = NULL;
    struct FileListItem * FPI;

    if (FileItem && *FileItem )
    {
        FPI = (struct FileListItem *) *FileItem;
        FP = FPI->FP;

        //
        // This should not be in the critsec, since we might delete 
        // the critical section.
        //
        RetVal = FP->ReleasePoolHandle(FPI);

        if (SUCCEEDED(RetVal))
        {
            *FileItem = INVALID_HANDLE_VALUE;
        }
    }
    else
    {
        RetVal = E_INVALIDARG;
    }
    return RetVal;
}

/*********************
 * RemoveFromFilePool()
 *
 * Removes the pool item from the pool completely and frees the associated memory.
 *
 * Arguments:
 * IN OUT FileItem     : Pointer to a FileItem Handle.
 *    IN  Delete       : BOOL, Tells us whether to delete the files or not.
 *
 * Returns Error if it fails, or S_OK if it succeeds. FileItem gets set to INVALID_HANDLE_VALUE if it succeeds.
 *
 */

HRESULT
RemoveFromFilePool(
    HANDLE* FileItem,
    BOOL    Delete
    )
{
    HRESULT RetVal = S_OK;
    class FilePool * FP = NULL;
    struct FileListItem * FPI;

    if (FileItem && *FileItem )
    {
        FPI = (struct FileListItem *) *FileItem;
        FP = FPI->FP;

        RetVal = FP->RemoveFromPool(FPI, Delete);

        if (SUCCEEDED(RetVal))
        {
            *FileItem = INVALID_HANDLE_VALUE;
        }
    }
    else
    {
        RetVal = E_INVALIDARG;
    }
    return RetVal;

}



/*********************
 * CloseFiles()
 *
 * Closes the filehandles in the Pool Item (To save memory).
 *
 * Arguments:
 *   IN  FileItem     : FileItem Handle.
 *   IN  CloseShad    : Close the shadow file handle too.
 *
 *
 */

VOID
CloseFiles(
    HANDLE FileItem,
    BOOL   CloseShad 
    )
{
    struct FileListItem * FPI;

    if (FileItem )
    {
        FPI = (struct FileListItem *) FileItem;

        FPCloseFiles(FPI, CloseShad);
    }
}

/*********************
 * DestroyFilePool()
 *
 * Takes a FilePool Object and frees it, optionally deleting the files associated with it.
 *
 * Arguments:
 * IN OUT FilePoolHandle : Pointer to existing Filepool.
 *    IN  DeleteFiles    : BOOL - TRUE: Delete the Pool files.
 *
 * Returns Error if it is passed in an invalid argument, or S_OK if it succeeds. 
 *
 */

HRESULT
DestroyFilePool(
    HANDLE* FilePoolHandle,
    BOOL    DeleteFiles
    )
{
    HRESULT RetVal = S_OK;
    class FilePool * FP = NULL;

    if (FilePoolHandle && *FilePoolHandle)
    {
        FP = (class FilePool *)FilePoolHandle;

        FP->DeleteEmptyFilesOnClose = DeleteFiles;

        delete FP;
    }
    else
    {
        RetVal = E_INVALIDARG;
    }

    return RetVal;
}


/*********************
 * TrimPool()
 *
 * Takes a FilePool Object and trim the free list, deleting old files.
 *
 * Arguments:
 *   IN   FilePool     : Handle of a FilePool Object Created with CreateFilePool()
 *
 * Returns TRUE if there are files still in the free list, or FALSE if no files left.
 */

BOOL
TrimPool(
    HANDLE FilePoolHandle
    )
{
    class FilePool * FP = NULL;
    BOOL Retval = FALSE;

    if (FilePoolHandle)
    {
        FP = (class FilePool *)FilePoolHandle;

        Retval = FP->TrimPool();
    }

    return Retval;
}


/*********************
 * ChangeFilePoolBasePath()
 *
 * Takes a FilePool Object and changes the base path in it. This will be called
 * when the spool directory is changed.
 *
 * Arguments:
 *   IN   FilePool     : Handle of a FilePool Object Created with CreateFilePool
 *   IN   BasePath     : New base path to use
 *
 * Returns an HRESULT
 */
HRESULT
ChangeFilePoolBasePath(
    IN HANDLE  *FilePoolHandle,
    IN LPCTSTR  BasePath
    )
{
    FilePool    *FP = (FilePool *)FilePoolHandle;
    HRESULT RetVal = E_INVALIDARG;
    LPTSTR  FileBase = NULL;

    if (FP)
    {
        if (FileBase = AllocSplStr(BasePath))
        {
            FP->EnterCritSec();

            FreeSplStr(FP->FileBase);
            FP->FileBase = FileBase;
            FP->LeaveCritSec();

            RetVal = S_OK;
        }
        else
        {
            RetVal = E_OUTOFMEMORY;
        }
    }

    return RetVal;
}


/*--
Generic Utility Functions

  ConvertFileExt

--*/

/*********************
 * ConvertFileExt()
 *
 * Utility function to change one extension to another.
 * Requires the extension to only be in the filename once.
 *
 * Arguments:
 * IN OUT FileName     : String of Filename to be changed.
 * IN     ExtFrom      : Extension to change.
 * IN     ExtTo        : Extension to change it to.
 *
 */

HRESULT
ConvertFileExt(
    PWSTR  Filename,
    PCWSTR ExtFrom,
    PCWSTR ExtTo
    )
{
    HRESULT RetVal = E_FAIL;
    PWSTR   Temp = NULL;

    if (Filename && ExtFrom && ExtTo && (wcslen(ExtFrom) == wcslen(ExtTo)) && ExtFrom[0])
    {
        Temp = wcsstr(Filename, ExtFrom);
        if (Temp)
        {
            //
            // This should work in all our cases.
            //
            wcscpy(Temp, ExtTo);
            RetVal = S_OK;
        }
    }
    else
    {
        RetVal = E_INVALIDARG;
    }
    return RetVal;
}

/*--
FileItem Management Functions

    TruncateFiles
  
--*/

/*********************
 * TruncateFiles()
 *
 * Takes a File Item and truncates any open files to 0 length.
 *
 * Arguments:
 *   IN   FileListItem : Item containing the files to truncate.
 *
 *
 */
VOID
TruncateFiles(
    struct FileListItem * Item
    )
{
    BOOL Trunced = FALSE;
    if (Item)
    {
        Item->EnterCritSec();
        
        //
        // Reinitialize cache data.
        //
        Item->CreateInfo = 0;

        //
        // Truncate the Shadow File
        //
        if (Item->ShdWriteHandle != INVALID_HANDLE_VALUE)
        {
            if (SetFilePointer(Item->ShdWriteHandle, 0, NULL, FILE_BEGIN) !=
                     INVALID_SET_FILE_POINTER) 
            {
                if (!SetEndOfFile(Item->ShdWriteHandle))
                {
                    DBGMSG(DBG_WARN, ("FAILED to set SPL end of file to 0 %d.\n", GetLastError()));
                }
            }
        }
        
        //
        // Truncate the Spool File. If the writehandle is closed, use the readhandle.
        //
        if (Item->SplWriteHandle != INVALID_HANDLE_VALUE)
        {
            if (SetFilePointer(Item->SplWriteHandle, 0, NULL, FILE_BEGIN) !=
                     INVALID_SET_FILE_POINTER) 
            {
                if (!SetEndOfFile(Item->SplWriteHandle))
                {
                    DBGMSG(DBG_WARN, ("FAILED to set SPL end of file to 0 %d.\n", GetLastError()));
                }
            }
        }
        else if (Item->SplReadHandle != INVALID_HANDLE_VALUE)
        {
            if (SetFilePointer(Item->SplReadHandle, 0, NULL, FILE_BEGIN) !=
                     INVALID_SET_FILE_POINTER) 
            {
                if (!SetEndOfFile(Item->SplReadHandle))
                {
                    DBGMSG(DBG_WARN, ("FAILED to set SPL end of file to 0 %d.\n", GetLastError()));
                }
            }
            // There is only one open spool handle at this point so make that
            // open handle the writer.  This is what the spooler needs when it
            // first requests a new pool item.  This also saves file I/O if the
            // next use of this item doesn't need both writer and reader at the
            // same time.
            Item->SplWriteHandle = Item->SplReadHandle;
            Item->SplReadHandle = INVALID_HANDLE_VALUE;
            
            Trunced = TRUE;
        }

        if ((Item->SplReadHandle != INVALID_HANDLE_VALUE) && !Trunced)
        {
            //CloseHandle(Item->SplReadHandle);
            SetFilePointer(Item->SplReadHandle, 0, NULL, FILE_BEGIN);
        }

        Item->LeaveCritSec();
    }
}


/*********************
 * FPCloseFiles()
 *
 * Takes a FileList item and closes the files associated with it.
 *
 * Arguments:
 *   IN   FileListItem     : FileItem with files to close.
 *   IN   CloseShad        : BOOL - TRUE: Close the Shadow File too.
 *
 *
 */
VOID
FPCloseFiles(
    struct FileListItem * pItem,
    BOOL CloseShad)
{
    if (pItem)
    {

        pItem->EnterCritSec();
        __try
        {
            if (pItem->SplWriteHandle != INVALID_HANDLE_VALUE)
            {
                CloseHandle(pItem->SplWriteHandle);
                pItem->SplWriteHandle = INVALID_HANDLE_VALUE;
            }
        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            DBGMSG(DBG_WARN, ("Hit an Exception Closing SplWriteHandle in FPCloseFiles\n"));
            pItem->SplWriteHandle = INVALID_HANDLE_VALUE;
        }
            
        __try
        {

            if (pItem->SplReadHandle != INVALID_HANDLE_VALUE)
            {
                CloseHandle(pItem->SplReadHandle);
                pItem->SplReadHandle = INVALID_HANDLE_VALUE;
            }
        
        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            DBGMSG(DBG_WARN, ("Hit an Exception Closing SplReadHandle in FPCloseFiles\n"));
            pItem->SplReadHandle = INVALID_HANDLE_VALUE;
        }

        if ( CloseShad )
        {
            __try
            {
                if (pItem->ShdWriteHandle != INVALID_HANDLE_VALUE)
                {
                    CloseHandle(pItem->ShdWriteHandle);
                    pItem->ShdWriteHandle = INVALID_HANDLE_VALUE;
                }
            }
            __except ( EXCEPTION_EXECUTE_HANDLER )
            {
                DBGMSG(DBG_WARN, ("Hit an Exception Closing ShdWriteHandle in FPCloseFiles\n"));
                pItem->ShdWriteHandle = INVALID_HANDLE_VALUE;
            }
            
        }
        pItem->LeaveCritSec();
    }
}


/*********************
 * DeletePoolFile()
 *
 * Takes a FilePool Object and trim the free list, deleting old files and freeing memory.
 *
 * Arguments:
 * IN OUT FileListItem     : FileItem to delete the files from and free up.
 *
 * Closes the files, deletes them, frees the memory, and sets the pItem to NULL
 *
 */
VOID
DeletePoolFile(struct FileListItem ** ppItem)
{
    struct FileListItem * pItem;

    if (ppItem && *ppItem)
    {
        pItem = *ppItem;
        FPCloseFiles(pItem, TRUE);
        
        DeleteCriticalSection(&pItem->CritSec);

        if (pItem->SplFilename)
        {
            DeleteFile(pItem->SplFilename);
            FreeSplMem(pItem->SplFilename);
        }

        if (pItem->ShdFilename)
        {
            DeleteFile(pItem->ShdFilename);
            FreeSplMem(pItem->ShdFilename);
        }

        FreeSplMem(pItem);
    }
    

    *ppItem = NULL;
}


/*--

List Management Functions

    RemoveFromFPList
    AddToFPListEnd
    AddToFPListHead
    
--*/    



HRESULT
RemoveFromFPList(
    struct FileListItem * Item,
    struct FileListItem ** Head,
    struct FileListItem ** Tail
    )
{
    struct FileListItem * Check = NULL;
    HRESULT RetVal = E_FAIL;

    //
    // Validate we have valid args.
    //
    if ( Item && Head && *Head && Tail && *Tail )
    {

        for ( Check = *Head; Check && (Item != Check); Check = Check->FLNext );

        if ( Check )
        {
            if ( *Head == Check )
            {
                *Head = Check->FLNext;
            }
            else
            {
                Check->FLPrev->FLNext = Check->FLNext;

            }

            if ( *Tail == Check )
            {
                *Tail = Check->FLPrev;
            }
            else
            {
                Check->FLNext->FLPrev = Check->FLPrev;
            }

            Check->FLNext = NULL;
            Check->FLPrev = NULL;

            RetVal = S_OK;
            
        }
        else
        {
            //
            // you gave me a pointer to an item not in the list.
            //
            RetVal = E_POINTER;
        }
        

    }
    else
    {
        RetVal = E_INVALIDARG;
    }

    return RetVal;
}

HRESULT
AddToFPListEnd(
    struct FileListItem * Item,
    struct FileListItem ** Head,
    struct FileListItem ** Tail
    )
{
    struct FileListItem * Check = NULL;
    HRESULT RetVal = E_FAIL;

    //
    // Validate we have valid args.
    //
    if ( Item && Head && Tail )
    {

        if ( *Tail )
        {
            //
            // There are items in the list, add something
            // onto the end.
            //
            Check = *Tail;

            Check->FLNext = Item;
            Item->FLPrev = Check;
            Item->FLNext = NULL;

            *Tail = Item;
            RetVal = S_OK;
        }
        else
        {
            if ( *Head )
            {
                //
                // If we have a head and no tail, something
                // is seriously wrong.
                //
                RetVal = E_FAIL;
            }
            else
            {
                //
                // Adding the first item into a list.
                //

                Item->FLNext = NULL;
                Item->FLPrev = NULL;

                *Head = Item;
                *Tail = Item;
                RetVal = S_OK;
            }
        }
    }
    else
    {
        RetVal = E_INVALIDARG;
    }

    return RetVal;
}


HRESULT
AddToFPListHead(
    struct FileListItem * Item,
    struct FileListItem ** Head,
    struct FileListItem ** Tail
    )
{
    HRESULT RetVal = S_OK;

    if ( Item && Head && Tail )
    {
        if ( *Head )
        {
            Item->FLNext = *Head;
            (*Head)->FLPrev = Item;
        }
        else
        {
            *Tail = Item;
        }
        *Head = Item;
        Item->FLPrev = NULL;
    }
    else
    {
        RetVal = E_INVALIDARG;
    }

    return RetVal;
}

VOID
FreeFPList(
    struct FileListItem ** Head,
    BOOL DeleteFiles
    )
{
    struct FileListItem * Item = NULL;
    struct FileListItem * Next = NULL;

    if (Head && *Head)
    {
        Item = *Head;
        while (Item)
        {
            Next = Item->FLNext;
            Item->FLNext = NULL;
            Item->FLPrev = NULL;
            
            if (Item->SplFilename && DeleteFiles)
            {
                DeletePoolFile(&Item);
                Item = Next;
            }
            else
            {
                FPCloseFiles(Item, TRUE);
                DeleteCriticalSection(&Item->CritSec);

                if (Item->SplFilename)
                {
                    FreeSplMem(Item->SplFilename);
                }
                if (Item->ShdFilename)
                {
                    FreeSplMem(Item->ShdFilename);
                }
                FreeSplMem(Item);
                Item = Next;
            }
        }
        *Head = NULL;
    }
}


/*--

FilePool Class Functions:

    InitFilePoolVars
    FilePool
    ~FilePool
    EnterCritSec
    LeaveCritSec
    GetNextFileName
    CreatePoolFile
    GetWriteFileStruct
    ReleasePoolHandle
    DeletePoolFile
    operator delete
    
--*/    





/*********************
 * Filepool::FilePool()
 *
 * See CreateFilePool() Above.
 */

FilePool::FilePool(
    DWORD   PTimeout,
    DWORD   MaxFreeFiles
    )     : FreeFiles(NULL), EndFreeFiles(NULL), FileInUse(NULL), EndUsedFiles(NULL),
            CurrentNum(0), PoolTimeout(PTimeout), MaxFiles(MaxFreeFiles), FreeSize(0), UsedSize(0),
            DeleteEmptyFilesOnClose(FALSE)
{
    SplModes.Mode      = GENERIC_READ | GENERIC_WRITE;
    SplModes.Flags     = FILE_ATTRIBUTE_NORMAL;
    SplModes.ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
    SplModes.Disp      = 0;
    
    ShdModes.Mode      = GENERIC_WRITE;
    ShdModes.Flags     = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN;
    ShdModes.ShareMode = 0;
    ShdModes.Disp      = 0;
}


/*********************
 * Filepool::AllocInit()
 *
 * See CreateFilePool() Above.
 */

HRESULT
FilePool::AllocInit(
    LPCTSTR BasePath,
    LPCTSTR PreNumStr,
    LPCTSTR SplExt,
    LPCTSTR ShdExt
    )
{
    HRESULT RetVal = S_OK;

    __try
    {
        InitializeCriticalSection(&FilePoolCritSec);
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        DBGMSG(DBG_WARN, ("FilePool: Failed to Initialise Critical Section.\n"));
        RetVal = E_FAIL;
    }

    
    if ((RetVal == S_OK) &&
        (FileBase = AllocSplStr(BasePath)) &&
        (FilePreNumStr = AllocSplStr(PreNumStr)) &&
        (SplFileExt = AllocSplStr(SplExt)) &&
        (ShdFileExt = AllocSplStr(ShdExt))
        )
    {
        //
        // We have all of our strings allocated.
        //
    }
    else
    {
        FreeSplStr(FileBase);
        FreeSplStr(FilePreNumStr);
        FreeSplStr(SplFileExt);
        FreeSplStr(ShdFileExt);
        RetVal = E_FAIL;
    }

    return RetVal;
}


/*********************
 * Filepool::FilePool()
 *
 * See CreateFilePool() Above.
 */

FilePool::~FilePool(
    )
{
    if (FileBase)
    {
        FreeSplMem(FileBase);
    }
    
    if (FilePreNumStr)
    {
        FreeSplMem(FilePreNumStr);
    }
    
    if (SplFileExt)
    {
        FreeSplMem(SplFileExt);
    }
    
    if (ShdFileExt)
    {
        FreeSplMem(ShdFileExt);
    }

    //
    // Free The lists here.
    //
    FreeFPList(&FileInUse, FALSE);
    FreeFPList(&FreeFiles, DeleteEmptyFilesOnClose);
    EndUsedFiles = NULL;
    EndFreeFiles = NULL;

    DeleteCriticalSection(&FilePoolCritSec);
}

VOID 
FilePool::EnterCritSec()
{
    EnterCriticalSection(&FilePoolCritSec);
}

VOID
FilePool::LeaveCritSec()
{
    LeaveCriticalSection(&FilePoolCritSec);
}


VOID 
FileListItem::EnterCritSec()
{
    EnterCriticalSection(&CritSec);
}

VOID
FileListItem::LeaveCritSec()
{
    LeaveCriticalSection(&CritSec);
}

/*********************
 * FilePool::GetNextFileName()
 *
 * Returns the next open Spool file name. Allocates memory.
 *
 * Arguments:
 *
 * Return:
 *   A valid spool file name, or NULL.
 *
 */

LPWSTR
FilePool::GetNextFileName(VOID)
{

    DWORD SizeToAlloc = 0;
    PWSTR FName = NULL;

    SizeToAlloc = 
        wcslen(FileBase) + 1 +
        wcslen(FilePreNumStr) + 5 +
        wcslen(SplFileExt) + 1;

    FName = (PWSTR)AllocSplMem(SizeToAlloc * sizeof(WCHAR));
    if (FName)
    {
        DWORD NextNum;
        
        EnterCritSec();
        NextNum = CurrentNum;

        CurrentNum++;

        if (CurrentNum > 99999)
        {
            CurrentNum = 0;
        }

        LeaveCritSec();
        
        wsprintf(
            FName, 
            L"%ws\\%ws%05d%ws", 
            FileBase, 
            FilePreNumStr, 
            NextNum, 
            SplFileExt);

    }
    
    return FName;
}

/*********************
 * FilePool::GetNextFileNameNoAlloc()
 *
 * Returns the next open Spool file name. Uses a buffer.
 * It is only used after a call to GetNextFileName.
 *
 * Arguments:
 * IN OUT Filename   : Buffer to copy the name into.
 *
 * Return:
 *   None.
 *
 */

VOID
FilePool::GetNextFileNameNoAlloc(
    PWSTR Filename
    )
{
    DWORD NextNum;

    EnterCritSec();
    NextNum = CurrentNum;
    
    CurrentNum++;

    if (CurrentNum > 99999)
    {
        CurrentNum = 0;
    }
    
    LeaveCritSec();
    wsprintf(
        Filename, 
        L"%ws\\%ws%05d%ws", 
        FileBase, 
        FilePreNumStr, 
        NextNum, 
        SplFileExt);

}

/*********************
 * Filepool::CreatePoolFile()
 *
 * Takes a pointer to a Filepool item and returns a new one. Can use a filename
 * passed in.
 *
 * Parameters:
 *    OUT  Item      : Pointer to a File Item.
 *    IN   Filename  : Optional Filename. Can be NULL.
 *
 * Returns S_OK if successful.
 */


HRESULT
FilePool::CreatePoolFile(
    struct FileListItem ** Item,
    PWSTR  Filename
    )
{
    HRESULT RetVal = E_FAIL;
    struct FileListItem * Temp = NULL;
    DWORD  OldNum = 0;
    BOOL CritInitialized = FALSE;

    if ( Item )
    {
        Temp = (struct FileListItem *)AllocSplMem(sizeof(struct FileListItem));

        if ( Temp )
        {
           Temp->FLNext = NULL;
           Temp->FLPrev = NULL;
           OldNum = CurrentNum;
           Temp->TimeStamp = 0;
           Temp->FP = this;
           Temp->CreateInfo = 0;
           
           __try
               {
                   InitializeCriticalSection(&Temp->CritSec);
                   CritInitialized = TRUE;
               }
           __except( EXCEPTION_EXECUTE_HANDLER )
               {
                   DBGMSG(DBG_WARN, ("FilePool: Failed to Initialise FL Critical Section.\n"));
                   RetVal = E_FAIL;
               }
           if (CritInitialized) 
           {
           
               if ( Filename )
               {
                   Temp->SplFilename = AllocSplStr(Filename);
                   Temp->ShdFilename = AllocSplStr(Filename);
                   
                   if (Temp->SplFilename && Temp->ShdFilename)
                   {
                       *Item = Temp;
                       ConvertFileExt(Temp->ShdFilename, SplFileExt, ShdFileExt);
                       Temp->SplReadHandle = INVALID_HANDLE_VALUE;
                       Temp->SplWriteHandle = INVALID_HANDLE_VALUE;
                       Temp->ShdWriteHandle = INVALID_HANDLE_VALUE;
                       RetVal = S_OK;
                   }
                   else
                   {
                       RetVal = E_OUTOFMEMORY;
                   }
               }
               else
               {
                   Temp->SplFilename = GetNextFileName();
    
                   if (Temp->SplFilename)
                   {
                       RetVal = S_OK;
                       while (FileExists(Temp->SplFilename))
                       {
                            GetNextFileNameNoAlloc(Temp->SplFilename);
                            if (OldNum == CurrentNum)
                            {
                                //
                                // We went right around.
                                //
                                RetVal = E_FAIL;
                                break;
                            }
                       }
                       if (SUCCEEDED(RetVal))
                       {
                           Temp->ShdFilename = AllocSplStr(Temp->SplFilename);
                           if (Temp->ShdFilename)
                           {
                               ConvertFileExt(Temp->ShdFilename, SplFileExt, ShdFileExt);
                               Temp->SplReadHandle = INVALID_HANDLE_VALUE;
                               Temp->SplWriteHandle = INVALID_HANDLE_VALUE;
                               Temp->ShdWriteHandle = INVALID_HANDLE_VALUE;
                               *Item = Temp;
                               RetVal = S_OK;
                           }
                       }
                   }
               }
           }
       }
    }
    else
    {
        RetVal = E_INVALIDARG;

    }
    
    if (FAILED(RetVal))
    {
        if (Temp)
        {
            DeleteCriticalSection(&Temp->CritSec);

            if (Temp->SplFilename)
            {
                FreeSplMem(Temp->SplFilename);
            }
            
            if (Temp->ShdFilename)
            {
                FreeSplMem(Temp->ShdFilename);
            }
            
            FreeSplMem(Temp);
        }
    }
    return RetVal;
}


/*********************
 * Filepool::GetWriteFileStruct()
 *
 * See GetFileItemHandle() Above.
 */

HRESULT 
FilePool::GetWriteFileStruct(
    struct FileListItem ** File,
    PWSTR  Filename
    )
{
    struct FileListItem * Temp = NULL;
    HRESULT RetVal = S_OK;
    HRESULT OurRetVal = S_OK;
    
    EnterCritSec();
    
    if ( FreeFiles && !Filename)
    {
        Temp = FreeFiles;
        
        RetVal = RemoveFromFPList( Temp, &FreeFiles, &EndFreeFiles );

        if (SUCCEEDED(RetVal))
        {
            FreeSize--;

            RetVal = AddToFPListEnd( Temp, &FileInUse, &EndUsedFiles);
            
            if (FAILED(RetVal))
            {
                //
                // Bad things
                //
                DBGMSG(DBG_WARN, ("Could not add to List End %x\n", RetVal));
                OurRetVal = E_FAIL;
            }
            else
            {
                UsedSize++;
            }
        }
        else
        {
            //
            // Find out what went wrong.
            //
            DBGMSG(DBG_WARN, ("Could not remove Item %x\n", RetVal));
            Temp = NULL;
            OurRetVal = E_FAIL;

        }
    }
    else
    {
        LeaveCritSec();

        RetVal = CreatePoolFile(&Temp, Filename);

        if ( FAILED(RetVal) )
        {
            //
            // Bad Things
            //
            DBGMSG(DBG_WARN, ("Could not create Item %x\n", RetVal));
            OurRetVal = E_FAIL;
        }
        else
        {
            EnterCritSec();
            RetVal = AddToFPListEnd(Temp, &FileInUse, &EndUsedFiles);

            if ( FAILED(RetVal) )
            {
                //
                // Bad Things
                //
                DBGMSG(DBG_WARN, ("Could not add to List End after create %x\n", RetVal));
                OurRetVal = E_FAIL;
            }
            else
            {
                UsedSize++;
            }
            LeaveCritSec();
        }
        EnterCritSec();
    }

    LeaveCritSec();

    if ( FAILED(OurRetVal) )
    {
        //
        // Clean up.
        //
                 
        if ( Temp )
        {
            //
            // We weren't able to add the file to the structure,
            // This should never happen, but if it does, clean up
            // the memory we use.
            //
            DeletePoolFile(&Temp);
            
        }

        *File = NULL;
    }
    else
    {
        *File = Temp;
    }

    return OurRetVal;
}

/*********************
 * Filepool::ReleasePoolHandle()
 *
 * See ReleasePoolHandle() Above.
 */

HRESULT
FilePool::ReleasePoolHandle(
    struct FileListItem * File
    )
{
    BOOL    bDeletePoolFile = FALSE;
    HRESULT RetVal = S_OK;
    HRESULT RemRetVal = S_OK;

    if ((File->Status & FP_STATUS_SPL_READING) || 
        (File->Status & FP_STATUS_SPL_WRITING) ||
        (File->Status & FP_STATUS_SHD_WRITING)) 
    {
        RetVal = E_FAIL;

        //
        // This is a pathological case as we will subsequently leak this handle.
        // Break.
        //         
        DBGMSG(DBG_ERROR, ("Tried to release a file with handles in use\n"));
    }
    else
    {
        EnterCritSec();
        RemRetVal = RemoveFromFPList(File, &FileInUse, &EndUsedFiles);

        if (SUCCEEDED(RemRetVal))
        {
            UsedSize--;
            //
            // If the spool directory has changed we need to delete the pool file
            //
            if ( _wcsnicmp(FileBase, File->SplFilename, wcslen(FileBase)) )
            {
                bDeletePoolFile = TRUE;
            }
        }
        LeaveCritSec();

        if (SUCCEEDED(RemRetVal))
        {
            if (bDeletePoolFile == TRUE                             ||
                FreeSize >= MaxFiles                                ||
                ((File->SplWriteHandle == INVALID_HANDLE_VALUE) &&
                 (File->SplReadHandle == INVALID_HANDLE_VALUE)))
            {
                DeletePoolFile(&File);
            }
            else
            {
                File->TimeStamp = GetTickCount();

                TruncateFiles(File);
                
                EnterCritSec();
                RetVal = AddToFPListEnd(File, &FreeFiles, &EndFreeFiles);

                if (SUCCEEDED(RetVal))
                {
                    FreeSize++;
                }
                LeaveCritSec();

            }
        }
        else
        {
            RetVal = E_INVALIDARG;
        }
    }

    return RetVal;
}

/*********************
 * Filepool::CreateSplReader()
 *
 *Used in GetReaderFromHandle.
 */

HRESULT
FilePool::CreateSplReader(
    struct FileListItem * Item
    )
{
    HRESULT RetVal = S_OK;
    HANDLE Temp = INVALID_HANDLE_VALUE;
    
    
    Temp = CreateFile( Item->SplFilename,
                       SplModes.Mode,
                       SplModes.ShareMode,
                       NULL,
                       OPEN_EXISTING | SplModes.Disp,
                       SplModes.Flags,
                       NULL);

    if (Temp && (Temp != INVALID_HANDLE_VALUE))
    {
        Item->SplReadHandle = Temp;
        Item->CreateInfo |= FP_SPL_READER_CREATED;
    }
    else
    {
        RetVal = E_FAIL;
    }

    return RetVal;
}


/*********************
 * Filepool::CreateSplWriter()
 *
 * Does the CreateFile for the Spool File. Used for GetWriterFromHandle().
 */

HRESULT
FilePool::CreateSplWriter(
    struct FileListItem * Item
    )
{
    HRESULT RetVal = S_OK;
    HANDLE Temp = INVALID_HANDLE_VALUE;
    
    
    Temp = CreateFile( Item->SplFilename,
                       SplModes.Mode,
                       SplModes.ShareMode,
                       NULL,
                       CREATE_ALWAYS | SplModes.Disp,
                       SplModes.Flags,
                       NULL);

    if (Temp && (Temp != INVALID_HANDLE_VALUE))
    {
        Item->SplWriteHandle = Temp;
        Item->CreateInfo |= FP_SPL_WRITER_CREATED;
    }
    else
    {
        RetVal = E_FAIL;
    }

    return RetVal;
}

/*********************
 * Filepool::CreateShdWriter()
 *
 * Does the CreateFile for the ShadowFile. Used for GetWriterFromHandle().
 */

HRESULT
FilePool::CreateShdWriter(
    struct FileListItem * Item
    )
{
    HRESULT RetVal = S_OK;
    HANDLE Temp = INVALID_HANDLE_VALUE;
    
    
    Temp = CreateFile( Item->ShdFilename,
                       ShdModes.Mode,
                       ShdModes.ShareMode,
                       NULL,
                       CREATE_ALWAYS | ShdModes.Disp,
                       ShdModes.Flags,
                       NULL);

    if (Temp && (Temp != INVALID_HANDLE_VALUE))
    {
        Item->ShdWriteHandle = Temp;
        Item->CreateInfo |= FP_SHD_CREATED;
    }
    else
    {
        RetVal = E_FAIL;
    }

    return RetVal;
}

/*********************
 * Filepool::RemoveFromPool()
 *
 * See RemoveFromFilePool() Above.
 */

HRESULT
FilePool::RemoveFromPool(
    struct FileListItem * File,
    BOOL Delete
    )
{
    HRESULT RemRetVal = S_OK;

    if ((File->Status & FP_STATUS_SPL_READING) || 
        (File->Status & FP_STATUS_SPL_WRITING) ||
        (File->Status & FP_STATUS_SHD_WRITING)) 
    {
        RemRetVal = E_FAIL;

        //
        // This is a pathological case as it will cause us to leak a KM handle.
        // Hard break here.
        // 
        DBGMSG(DBG_ERROR, ("Tried to release a file with handles in use\n"));
    }
    else
    {
        EnterCritSec();
        RemRetVal = RemoveFromFPList(File, &FileInUse, &EndUsedFiles);

        if (SUCCEEDED(RemRetVal))
        {
            UsedSize--;
        }
        LeaveCritSec();

        if (FAILED(RemRetVal))
        {
            EnterCritSec();
            RemRetVal = RemoveFromFPList(File, &FreeFiles, &EndFreeFiles);

            if (SUCCEEDED(RemRetVal))
            {
                FreeSize--;
            }
            LeaveCritSec();
        }
        
        
        if (SUCCEEDED(RemRetVal))
        {
            if (Delete)
            {
                DeletePoolFile(&File);
            }
            else
            {
                FPCloseFiles(File, TRUE);

                DeleteCriticalSection(&File->CritSec);

                if (File->SplFilename)
                {
                    FreeSplMem(File->SplFilename);
                }
                if (File->ShdFilename)
                {
                    FreeSplMem(File->ShdFilename);
                }
                FreeSplMem(File);
            }
        }
    }

    return RemRetVal;

}

/*********************
 * Filepool::TrimPool()
 *
 * See TrimPool() Above.
 */


BOOL
FilePool::TrimPool(
    VOID
    )
{
    DWORD  Time                         = 0;
    BOOL   GotToTrim                    = TRUE;
    struct FileListItem * Temp          = NULL;
    struct FileListItem * DeleteFiles   = NULL;
    DWORD  TrimCount                    = 0;
    BOOL   bFilesToTrim                 = FALSE;
    
    Time = GetTickCount();

    EnterCritSec();

    DeleteFiles = FreeFiles;
    
    while (FreeFiles)
    {
        if ((FreeFiles->TimeStamp > Time) ||
            (Time - FreeFiles->TimeStamp > PoolTimeout))
        {
            //
            // Walk forward until you reach a file that is not too old.
            //
            FreeFiles = FreeFiles->FLNext;

            TrimCount++;
        }
        else 
        {
            if (FreeFiles->FLPrev)
            {
                //
                // There are files to delete.
                //
                FreeFiles->FLPrev->FLNext = NULL;
                FreeFiles->FLPrev = NULL;
            }
            else
            {
                //
                // No files have timed out.
                //
                DeleteFiles = NULL;
            }
            break;
        }
    }

    if (!FreeFiles)
    {
        EndFreeFiles = NULL;
    }

    //
    // We need to decrease the FreeSize by the number of elements we are just about
    // to trim off it.
    // 
    FreeSize -= TrimCount;

    //
    // We should trim files the next time around if there is a FreeFiles list.
    // 
    bFilesToTrim = FreeFiles != NULL;
    
    LeaveCritSec();
    
    //
    // Now outside the critsec do the deletions.
    //
    while (DeleteFiles)
    {
        struct FileListItem * Temp = DeleteFiles;
        DeleteFiles = DeleteFiles->FLNext;
        DeletePoolFile(&Temp);
    }

    return bFilesToTrim;
}


void*
FilePool::operator new(
    size_t n
    )
{
    return AllocSplMem(n);
}

void
FilePool::operator delete(
    void* p,
    size_t n
    )
{
    if (p)
    {
        FreeSplMem(p);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\forms.c ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation

Module Name:

    forms.c

Abstract:

   This module provides all the public exported APIs relating to the
   Driver-based Spooler Apis for the Local Print Providor

   SplAddForm
   SplDeleteForm
   SplSetForm
   SplGetForm
   SplEnumForms

   Support Functions in forms.c - (Warning! Do Not Add to this list!!)


Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/

#include <precomp.h>
#include <offsets.h>

VOID
BroadcastChangeForms(
    PINISPOOLER pIniSpooler);

DWORD
BroadcastChangeFormsThread(
    PINISPOOLER pIniSpooler);


typedef struct _REG_FORM_INFO {

    SIZEL   Size;
    RECTL   ImageableArea;

    DWORD   cFormOrder;
    DWORD   Flags;

} REG_FORM_INFO, *PREG_FORM_INFO;


// These figures are accurate to .001 mm
// There are 25.4 mm per inch

BUILTIN_FORM BuiltInForms[] = {
    0, IDS_FORM_LETTER,                215900, 279400, 0, 0, 215900, 279400,
    0, IDS_FORM_LETTER_SMALL,          215900, 279400, 0, 0, 215900, 279400,
    0, IDS_FORM_TABLOID,               279400, 431800, 0, 0, 279400, 431800,
    0, IDS_FORM_LEDGER,                431800, 279400, 0, 0, 431800, 279400,
    0, IDS_FORM_LEGAL,                 215900, 355600, 0, 0, 215900, 355600,
    0, IDS_FORM_STATEMENT,             139700, 215900, 0, 0, 139700, 215900,
    0, IDS_FORM_EXECUTIVE,             184150, 266700, 0, 0, 184150, 266700,
    0, IDS_FORM_A3,                    297000, 420000, 0, 0, 297000, 420000,
    0, IDS_FORM_A4,                    210000, 297000, 0, 0, 210000, 297000,
    0, IDS_FORM_A4_SMALL,              210000, 297000, 0, 0, 210000, 297000,
    0, IDS_FORM_A5,                    148000, 210000, 0, 0, 148000, 210000,
    0, IDS_FORM_B4,                    257000, 364000, 0, 0, 257000, 364000,
    0, IDS_FORM_B5,                    182000, 257000, 0, 0, 182000, 257000,
    0, IDS_FORM_FOLIO,                 215900, 330200, 0, 0, 215900, 330200,
    0, IDS_FORM_QUARTO,                215000, 275000, 0, 0, 215000, 275000,
    0, IDS_FORM_10X14,                 254000, 355600, 0, 0, 254000, 355600,
    0, IDS_FORM_11X17,                 279400, 431800, 0, 0, 279400, 431800,
    0, IDS_FORM_NOTE,                  215900, 279400, 0, 0, 215900, 279400,
    0, IDS_FORM_ENVELOPE9,                   98425, 225425, 0, 0,  98425, 225425,
    0, IDS_FORM_ENVELOPE10,                 104775, 241300, 0, 0, 104775, 241300,
    0, IDS_FORM_ENVELOPE11,                 114300, 263525, 0, 0, 114300, 263525,
    0, IDS_FORM_ENVELOPE12,                 120650, 279400, 0, 0, 120650, 279400,
    0, IDS_FORM_ENVELOPE14,                 127000, 292100, 0, 0, 127000, 292100,
    0, IDS_FORM_ENVELOPE_CSIZE_SHEET,       431800, 558800, 0, 0, 431800, 558800,
    0, IDS_FORM_ENVELOPE_DSIZE_SHEET,       558800, 863600, 0, 0, 558800, 863600,
    0, IDS_FORM_ENVELOPE_ESIZE_SHEET,       863600,1117600, 0, 0, 863600,1117600,
    0, IDS_FORM_ENVELOPE_DL,                110000, 220000, 0, 0, 110000, 220000,
    0, IDS_FORM_ENVELOPE_C5,                162000, 229000, 0, 0, 162000, 229000,
    0, IDS_FORM_ENVELOPE_C3,                324000, 458000, 0, 0, 324000, 458000,
    0, IDS_FORM_ENVELOPE_C4,                229000, 324000, 0, 0, 229000, 324000,
    0, IDS_FORM_ENVELOPE_C6,                114000, 162000, 0, 0, 114000, 162000,
    0, IDS_FORM_ENVELOPE_C65,               114000, 229000, 0, 0, 114000, 229000,
    0, IDS_FORM_ENVELOPE_B4,                250000, 353000, 0, 0, 250000, 353000,
    0, IDS_FORM_ENVELOPE_B5,                176000, 250000, 0, 0, 176000, 250000,
    0, IDS_FORM_ENVELOPE_B6,                176000, 125000, 0, 0, 176000, 125000,
    0, IDS_FORM_ENVELOPE,              110000, 230000, 0, 0, 110000, 230000,
    0, IDS_FORM_ENVELOPE_MONARCH,       98425, 190500, 0, 0,  98425, 190500,
    0, IDS_FORM_SIX34_ENVELOPE,         92075, 165100, 0, 0,  92075, 165100,
    0, IDS_FORM_US_STD_FANFOLD,        377825, 279400, 0, 0, 377825, 279400,
    0, IDS_FORM_GMAN_STD_FANFOLD,      215900, 304800, 0, 0, 215900, 304800,
    0, IDS_FORM_GMAN_LEGAL_FANFOLD,    215900, 330200, 0, 0, 215900, 330200,

    // Predefined forms currently availble only in Win95.  Included here
    // for compatibility.

    0, IDS_FORM_ISO_B4,                250000, 353000, 0, 0, 250000, 353000,
    0, IDS_FORM_JAPANESE_POSTCARD,     100000, 148000, 0, 0, 100000, 148000,
    0, IDS_FORM_9X11,                  228600, 279400, 0, 0, 228600, 279400,
    0, IDS_FORM_10X11,                 254000, 279400, 0, 0, 254000, 279400,
    0, IDS_FORM_15X11,                 381000, 279400, 0, 0, 381000, 279400,
    0, IDS_FORM_ENV_INVITE,            220000, 220000, 0, 0, 220000, 220000,
    0, IDS_FORM_RESERVED_48,           1,1, 0, 0, 1, 1,
    0, IDS_FORM_RESERVED_49,           1,1, 0, 0, 1, 1,
    0, IDS_FORM_LETTER_EXTRA,          241300, 304800, 0, 0, 241300, 304800,

    0, IDS_FORM_LEGAL_EXTRA,           241300, 381000, 0, 0, 241300, 381000,
    0, IDS_FORM_TABLOID_EXTRA,         304800, 457200, 0, 0, 304800, 457200,
    0, IDS_FORM_A4_EXTRA,                   235458, 322326, 0, 0, 235458, 322326,
    0, IDS_FORM_LETTER_TRANSVERSE,          215900, 279400, 0, 0, 215900, 279400,
    0, IDS_FORM_A4_TRANSVERSE,              210000, 297000, 0, 0, 210000, 297000,
    0, IDS_FORM_LETTER_EXTRA_TRANSVERSE,    241300, 304800, 0, 0, 241300, 304800,
    0, IDS_FORM_A_PLUS,                     227000, 356000, 0, 0, 227000, 356000,
    0, IDS_FORM_B_PLUS,                     305000, 487000, 0, 0, 305000, 487000,
    0, IDS_FORM_LETTER_PLUS,                215900, 322326, 0, 0, 215900, 322326,
    0, IDS_FORM_A4_PLUS,                    210000, 330000, 0, 0, 210000, 330000,
    0, IDS_FORM_A5_TRANSVERSE,              148000, 210000, 0, 0, 148000, 210000,
    0, IDS_FORM_B5_TRANSVERSE,              182000, 257000, 0, 0, 182000, 257000,
    0, IDS_FORM_A3_EXTRA,                   322000, 445000, 0, 0, 322000, 445000,
    0, IDS_FORM_A5_EXTRA,                   174000, 235000, 0, 0, 174000, 235000,
    0, IDS_FORM_B5_EXTRA,                   201000, 276000, 0, 0, 201000, 276000,
    0, IDS_FORM_A2,                         420000, 594000, 0, 0, 420000, 594000,
    0, IDS_FORM_A3_TRANSVERSE,              297000, 420000, 0, 0, 297000, 420000,
    0, IDS_FORM_A3_EXTRA_TRANSVERSE,        322000, 445000, 0, 0, 322000, 445000,

    0, IDS_FORM_DBL_JAPANESE_POSTCARD,           200000, 148000, 0, 0, 200000, 148000,
    0, IDS_FORM_A6,                              105000, 148000, 0, 0, 105000, 148000,
    0, IDS_FORM_JENV_KAKU2,                      240000, 332000, 0, 0, 240000, 332000,
    0, IDS_FORM_JENV_KAKU3,                      216000, 277000, 0, 0, 216000, 277000,
    0, IDS_FORM_JENV_CHOU3,                      120000, 235000, 0, 0, 120000, 235000,
    0, IDS_FORM_JENV_CHOU4,                       90000, 205000, 0, 0,  90000, 205000,
    0, IDS_FORM_LETTER_ROTATED,                  279400, 215900, 0, 0, 279400, 215900,
    0, IDS_FORM_A3_ROTATED,                      420000, 297000, 0, 0, 420000, 297000,
    0, IDS_FORM_A4_ROTATED,                      297000, 210000, 0, 0, 297000, 210000,
    0, IDS_FORM_A5_ROTATED,                      210000, 148000, 0, 0, 210000, 148000,
    0, IDS_FORM_B4_JIS_ROTATED,                  364000, 257000, 0, 0, 364000, 257000,
    0, IDS_FORM_B5_JIS_ROTATED,                  257000, 182000, 0, 0, 257000, 182000,
    0, IDS_FORM_JAPANESE_POSTCARD_ROTATED,       148000, 100000, 0, 0, 148000, 100000,
    0, IDS_FORM_DBL_JAPANESE_POSTCARD_ROTATED,   148000, 200000, 0, 0, 148000, 200000,
    0, IDS_FORM_A6_ROTATED,                      148000, 105000, 0, 0, 148000, 105000,
    0, IDS_FORM_JENV_KAKU2_ROTATED,              332000, 240000, 0, 0, 332000, 240000,
    0, IDS_FORM_JENV_KAKU3_ROTATED,              277000, 216000, 0, 0, 277000, 216000,
    0, IDS_FORM_JENV_CHOU3_ROTATED,              235000, 120000, 0, 0, 235000, 120000,
    0, IDS_FORM_JENV_CHOU4_ROTATED,              205000,  90000, 0, 0, 205000,  90000,
    0, IDS_FORM_B6_JIS,                          128000, 182000, 0, 0, 128000, 182000,
    0, IDS_FORM_B6_JIS_ROTATED,                  182000, 128000, 0, 0, 182000, 128000,
    0, IDS_FORM_12X11,                           304932, 279521, 0, 0, 304932, 279521,
    0, IDS_FORM_JENV_YOU4,                       105000, 235000, 0, 0, 105000, 235000,
    0, IDS_FORM_JENV_YOU4_ROTATED,               235000, 105000, 0, 0, 235000, 105000,
    0, IDS_FORM_P16K,                            188000, 260000, 0, 0, 188000, 260000,
    0, IDS_FORM_P32K,                            130000, 184000, 0, 0, 130000, 184000,
    0, IDS_FORM_P32KBIG,                         140000, 203000, 0, 0, 140000, 203000,
    0, IDS_FORM_PENV_1,                          102000, 165000, 0, 0, 102000, 165000,
    0, IDS_FORM_PENV_2,                          102000, 176000, 0, 0, 102000, 176000,
    0, IDS_FORM_PENV_3,                          125000, 176000, 0, 0, 125000, 176000,
    0, IDS_FORM_PENV_4,                          110000, 208000, 0, 0, 110000, 208000,
    0, IDS_FORM_PENV_5,                          110000, 220000, 0, 0, 110000, 220000,
    0, IDS_FORM_PENV_6,                          120000, 230000, 0, 0, 120000, 230000,
    0, IDS_FORM_PENV_7,                          160000, 230000, 0, 0, 160000, 230000,
    0, IDS_FORM_PENV_8,                          120000, 309000, 0, 0, 120000, 309000,
    0, IDS_FORM_PENV_9,                          229000, 324000, 0, 0, 229000, 324000,
    0, IDS_FORM_PENV_10,                         324000, 458000, 0, 0, 324000, 458000,
    0, IDS_FORM_P16K_ROTATED,                    260000, 188000, 0, 0, 260000, 188000,
    0, IDS_FORM_P32K_ROTATED,                    184000, 130000, 0, 0, 184000, 130000,
    0, IDS_FORM_P32KBIG_ROTATED,                 203000, 140000, 0, 0, 203000, 140000,
    0, IDS_FORM_PENV_1_ROTATED,                  165000, 102000, 0, 0, 165000, 102000,
    0, IDS_FORM_PENV_2_ROTATED,                  176000, 102000, 0, 0, 176000, 102000,
    0, IDS_FORM_PENV_3_ROTATED,                  176000, 125000, 0, 0, 176000, 125000,
    0, IDS_FORM_PENV_4_ROTATED,                  208000, 110000, 0, 0, 208000, 110000,
    0, IDS_FORM_PENV_5_ROTATED,                  220000, 110000, 0, 0, 220000, 110000,
    0, IDS_FORM_PENV_6_ROTATED,                  230000, 120000, 0, 0, 230000, 120000,
    0, IDS_FORM_PENV_7_ROTATED,                  230000, 160000, 0, 0, 230000, 160000,
    0, IDS_FORM_PENV_8_ROTATED,                  309000, 120000, 0, 0, 309000, 120000,
    0, IDS_FORM_PENV_9_ROTATED,                  324000, 229000, 0, 0, 324000, 229000,
    0, IDS_FORM_PENV_10_ROTATED,                 458000, 324000, 0, 0, 458000, 324000,

    0, 0,                                   0,      0, 0, 0,      0,      0
};


PINIFORM
CreateFormEntry(
    LPWSTR  pFormName,
    SIZEL   Size,
    RECTL  *pImageableArea,
    DWORD   Type,
    DWORD   cFormOrder,
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Creates a Form entry, and insert it into the right place in
    pIniSpooler.

Arguments:

    pFormName - Name of Form.

    Size - Size of form.

    pImageableArea - Area of form that the printer can print to.

    Type - Type of form (usually indicates if BUILTIN form).

    cFormOrder - Where the form should be inserted for user-defined forms,
        form order increases from beginning to end.

        If this value is -1, generate a new cFormOrder for this form.
        (Put it at the end.)

Return Value:

    pIniForm - Created form, NULL = error.

Notes:

    This routine ensures that forms are put in proper order so that
    EnumForms always returns them in the same order.  We do this by
    scanning the list and inserting the new form such that all forms
    with cFormOrder =< the current on are to the left of it.

    This routine updates pIniSpooler->pIniForm (inserts or appends) and
    updates pIniSpooler->cFormOrderMax if necessary.

    i.e., 0 0 0 2 3 4 6
               ^
           New 0 inserted here.
--*/

{
    DWORD       cb;
    PINIFORM    pIniForm, pForm;

    cb = sizeof(INIFORM) + wcslen(pFormName)*sizeof(WCHAR) + sizeof(WCHAR);

    if ( pIniForm = AllocSplMem(cb) ) {

        pIniForm->pName         = wcscpy((LPWSTR)(pIniForm+1), pFormName);
        pIniForm->pNext         = NULL;
        pIniForm->signature     = IFO_SIGNATURE;
        pIniForm->Size          = Size;
        pIniForm->ImageableArea = *pImageableArea;
        pIniForm->Type          = Type;
        pIniForm->cFormOrder    = cFormOrder;

        //
        // This code will insert the item in order, but will always never
        // insert before the first item.  The built-in forms are always
        // at the front so this is not an issue.
        //

        if ( pForm = pIniSpooler->pShared->pIniForm ) {

            for( ; pForm->pNext; pForm = pForm->pNext ){

                //
                // If the next form is greater than the one we want
                // to insert, then insert it right now.
                //
                if( pForm->pNext->cFormOrder > cFormOrder ){

                    //
                    // The current from should be inserted here.
                    //
                    break;
                }
            }

            //
            // Link it up.
            //
            pIniForm->pNext = pForm->pNext;
            pForm->pNext = pIniForm;

        } else {

            pIniSpooler->pShared->pIniForm = pIniForm;
        }

        //
        // If the added form has a higher count than the current global
        // count, update the global.
        //
        if( cFormOrder > pIniSpooler->cFormOrderMax ){
            pIniSpooler->cFormOrderMax = cFormOrder;
        }
    }

    return pIniForm;
}

BOOL
InitializeForms(
    PINISPOOLER pIniSpooler
)
{
    PBUILTIN_FORM pBuiltInForm;
    HKEY          hFormsKey;
    DWORD         cUserDefinedForms;
    WCHAR         FormName[MAX_PATH];
    WCHAR         FormBuffer[FORM_NAME_LEN+1];
    DWORD         cchFormName;
    REG_FORM_INFO RegFormInfo;
    DWORD         cbRegFormInfo;

    DWORD         dwError;
    BOOL          bUpgradeTried = FALSE;
    BOOL          bStatus = TRUE;

    WORD PrimaryLangId = PRIMARYLANGID( GetSystemDefaultLangID( ));

    if (pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL)
    {
        for( pBuiltInForm = BuiltInForms; pBuiltInForm->NameId; pBuiltInForm++ ) {

            FormBuffer[0] = 0;

            LoadString( hInst,
                        pBuiltInForm->NameId,
                        FormBuffer,
                        FORM_NAME_LEN+1 );

            if ( CreateFormEntry( FormBuffer,
                             pBuiltInForm->Size,
                             &pBuiltInForm->ImageableArea,
                             FORM_BUILTIN,
                             0,
                             pIniSpooler ) == NULL)
            {
                bStatus = FALSE;
                break;
            }
        }
    }

    if ( bStatus )
    {
        //
        // Now see if there are any user-defined forms in the registry:
        //
        if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           pIniSpooler->pszRegistryForms,
                           0,
                           KEY_READ | KEY_WRITE,
                           &hFormsKey) == NO_ERROR ) {

            for( cUserDefinedForms = 0; TRUE; ++cUserDefinedForms ){

    Retry:
                cchFormName = COUNTOF( FormName );
                cbRegFormInfo = sizeof( RegFormInfo );

                dwError = RegEnumValue( hFormsKey,
                                        cUserDefinedForms,
                                        (LPWSTR)FormName,
                                        &cchFormName,
                                        NULL,
                                        NULL,
                                        (LPBYTE)&RegFormInfo,
                                        &cbRegFormInfo );

                if( dwError ){
                    break;
                }

                //
                // We will attempt the upgrade only if
                //     we are on the first item,
                //     the size is incorrect, and
                //     we haven't tried upgrading once in the function before.
                //

                if( !cUserDefinedForms                     &&
                    cbRegFormInfo != sizeof( RegFormInfo ) &&
                    !bUpgradeTried ){

                    Upgrade35Forms( hFormsKey, pIniSpooler );
                    bUpgradeTried = TRUE;

                    goto Retry;
                }

                if ( CreateFormEntry( FormName,
                                 RegFormInfo.Size,
                                 &RegFormInfo.ImageableArea,
                                 RegFormInfo.Flags,
                                 RegFormInfo.cFormOrder,
                                 pIniSpooler ) == NULL )
                {
                    bStatus = FALSE;
                    break;
                }
            }

            RegCloseKey( hFormsKey );
            hFormsKey = NULL;
        }
    }


    return bStatus;
}


DWORD
GetFormSize(
    PINIFORM    pIniForm,
    DWORD       Level
)
{
    DWORD   cb;

    switch (Level) {

    case 1:

        cb=sizeof(FORM_INFO_1) +
           wcslen(pIniForm->pName)*sizeof(WCHAR) + sizeof(WCHAR);
        break;

    default:
        cb = 0;
        break;
    }

    return cb;
}

// We are being a bit naughty here as we are not sure exactly how much
// memory to allocate for the source strings. We will just assume that
// FORM_INFO_1 is the biggest structure around for the moment.

LPBYTE
CopyIniFormToForm(
    PINIFORM pIniForm,
    DWORD   Level,
    LPBYTE  pFormInfo,
    LPBYTE  pEnd
)
{
    LPWSTR   SourceStrings[sizeof(FORM_INFO_1)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings=SourceStrings;
    LPFORM_INFO_1 pFormInfo1=(LPFORM_INFO_1)pFormInfo;
    DWORD   *pOffsets;

    switch (Level) {

    case 1:
        pOffsets = FormInfo1Strings;
        break;

    default:
        return pEnd;
    }

    switch (Level) {

    case 1:

        *pSourceStrings++=pIniForm->pName;

        pEnd = PackStrings(SourceStrings, pFormInfo, pOffsets, pEnd);

        pFormInfo1->Flags |= pIniForm->Type;
        pFormInfo1->Size = pIniForm->Size;
        pFormInfo1->ImageableArea = pIniForm->ImageableArea;

        break;

    default:
        return pEnd;
    }

    return pEnd;
}

/* Checks for logically impossible sizes.
 */
BOOL
ValidateForm(
    LPBYTE pForm
)
{
    LPFORM_INFO_1 pFormInfo = (LPFORM_INFO_1)pForm;
    DWORD    Error = NO_ERROR;

    if( !pForm ||
        (pFormInfo->Flags != FORM_USER &&
         pFormInfo->Flags != FORM_BUILTIN &&
         pFormInfo->Flags != FORM_PRINTER)) {

        Error = ERROR_INVALID_PARAMETER;

    } else

      /* Make sure name isn't longer than GDI DEVMODE specifies:
       */
    if( ( !pFormInfo->pName ) ||
        ( !pFormInfo->pName[0] ) ||
        ( wcslen( pFormInfo->pName ) > FORM_NAME_LEN )){

        Error = ERROR_INVALID_FORM_NAME;

    } else
    if( ( pFormInfo->Size.cx <= 0 )     /* Check for negative width */
        ||( pFormInfo->Size.cy <= 0 )     /* ... and height           */

      /* Check for strange imageable area:
       */
        || (pFormInfo->ImageableArea.right < 0)
        || (pFormInfo->ImageableArea.left < 0)
        || (pFormInfo->ImageableArea.bottom < 0)
        || (pFormInfo->ImageableArea.top < 0)
        ||( pFormInfo->ImageableArea.right <= pFormInfo->ImageableArea.left )
        ||( pFormInfo->ImageableArea.bottom <= pFormInfo->ImageableArea.top ) ) {

        Error = ERROR_INVALID_FORM_SIZE;
    }

    if( Error != NO_ERROR ) {

        SetLastError(Error);
        return FALSE;
    }

    return TRUE;
}


BOOL
SplAddForm(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
)
{
    LPFORM_INFO_1 pFormInfo;
    PINIFORM      pIniForm;
    HKEY          hFormsKey;
    REG_FORM_INFO RegFormInfo;
    DWORD         Status;
    PSPOOL        pSpool = (PSPOOL)hPrinter;
    PINISPOOLER   pIniSpooler;
    HANDLE        hToken = INVALID_HANDLE_VALUE;


    if (!ValidateSpoolHandle( pSpool, 0 )) {
        return(FALSE);
    }

    pIniSpooler = pSpool->pIniSpooler;

    if (Level != 1) {
        return FALSE;
    }

    if (!ValidateForm(pForm)) {

        /* ValidateForm sets the appropriate error code:
         */
        return FALSE;
    }


    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    EnterSplSem();

    pFormInfo = (LPFORM_INFO_1)pForm;

    pIniForm = FindForm(pFormInfo->pName, pIniSpooler);

    /* If there's already a form by this name, don't go on:
     */
    if (pIniForm) {

        /* Is there a better error code than this?? */
        SetLastError(ERROR_FILE_EXISTS);
        LeaveSplSem();
        return FALSE;
    }

    //
    //  Revert to LocalSystem, since a regular user cannot do this CreateKey call.
    //

    hToken = RevertToPrinterSelf();

    Status = RegCreateKeyEx(HKEY_LOCAL_MACHINE, pIniSpooler->pszRegistryForms, 0, NULL, 0,
                            KEY_WRITE, NULL, &hFormsKey, NULL);

    if (Status == NO_ERROR) {

        RegFormInfo.Size = pFormInfo->Size;
        RegFormInfo.ImageableArea = pFormInfo->ImageableArea;
        RegFormInfo.cFormOrder = pIniSpooler->cFormOrderMax + 1;
        RegFormInfo.Flags = pFormInfo->Flags;

        Status = RegSetValueEx( hFormsKey, pFormInfo->pName, 0, REG_BINARY,
                                (LPBYTE)&RegFormInfo, sizeof RegFormInfo );

        RegCloseKey( hFormsKey );

        if ( Status == NO_ERROR ) {

            CreateFormEntry( pFormInfo->pName,
                             pFormInfo->Size,
                             &pFormInfo->ImageableArea,
                             RegFormInfo.Flags,
                             RegFormInfo.cFormOrder,
                             pIniSpooler );

            SetPrinterChange( NULL,
                              NULL,
                              NULL,
                              PRINTER_CHANGE_ADD_FORM,
                              pIniSpooler );

            BroadcastChangeForms( pIniSpooler );
        }
    }

    ImpersonatePrinterClient( hToken );

    RunForEachSpooler( NULL, DsUpdateAllDriverKeys);

    LeaveSplSem();

    if ( Status != NO_ERROR )
        SetLastError( Status );

    SplLogEvent( pIniSpooler,
                 LOG_INFO,
                 MSG_FORM_ADDED,
                 FALSE,
                 pFormInfo->pName,
                 NULL );


    return ( Status == NO_ERROR );
}

BOOL
DeleteFormEntry(
    PINIFORM pIniForm,
    PINISPOOLER pIniSpooler
)
{
    PINIFORM *ppCurForm;

    ppCurForm = &pIniSpooler->pShared->pIniForm;

    while (*ppCurForm != pIniForm)
        ppCurForm = &(*ppCurForm)->pNext;

    *ppCurForm = (*ppCurForm)->pNext;

    FreeSplMem(pIniForm);

    return TRUE;

}




BOOL
SplDeleteForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName
)
{
    HKEY     hFormsKey;
    DWORD    Status;
    PINIFORM pIniForm;
    PSPOOL   pSpool = (PSPOOL) hPrinter;
    HANDLE   hToken = INVALID_HANDLE_VALUE;
    PINISPOOLER pIniSpooler;


    if (!ValidateSpoolHandle( pSpool, 0 )) {
        return(FALSE);
    }

    pIniSpooler = pSpool->pIniSpooler;

    if (!pFormName) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    EnterSplSem();


    pIniForm = FindForm(pFormName, pIniSpooler);

    if (!pIniForm || ((pIniForm->Type == FORM_BUILTIN) && 
        pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL)) {

        SetLastError( pIniForm ?
                          ERROR_INVALID_PARAMETER :
                          ERROR_INVALID_FORM_NAME );
        LeaveSplSem();
        return FALSE;
    }

    hToken = RevertToPrinterSelf();

    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pIniSpooler->pszRegistryForms, 0,
                          KEY_WRITE, &hFormsKey);

    if (Status == NO_ERROR) {

        Status = RegDeleteValue(hFormsKey, pFormName);

        RegCloseKey(hFormsKey);

        if (Status == NO_ERROR) {

            DeleteFormEntry(pIniForm , pIniSpooler );

            SetPrinterChange(NULL,
                             NULL,
                             NULL,
                             PRINTER_CHANGE_DELETE_FORM,
                             pIniSpooler);

            BroadcastChangeForms(pIniSpooler);

            RunForEachSpooler( NULL, DsUpdateAllDriverKeys);
        }
    }

    if(hToken != INVALID_HANDLE_VALUE)
    {
        ImpersonatePrinterClient( hToken );
    }

    LeaveSplSem();

    if (Status != NO_ERROR)
        SetLastError(Status);

    SplLogEvent( pIniSpooler,
                 LOG_INFO,
                 MSG_FORM_DELETED,
                 FALSE,
                 pFormName,
                 NULL );

    return (Status == NO_ERROR);
}

BOOL
SplGetForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    PINIFORM    pIniForm;
    DWORD       cb;
    LPBYTE      pEnd;
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    PINISPOOLER pIniSpooler;

    if (!ValidateSpoolHandle(pSpool, 0 )) {
        return(FALSE);
    }

    if (!pSpool->pIniPrinter ||
        !pSpool->pIniSpooler ||
        (pSpool->pIniPrinter->signature != IP_SIGNATURE)) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

   EnterSplSem();

    SPLASSERT(pSpool->pIniSpooler->signature == ISP_SIGNATURE);

    pIniSpooler = pSpool->pIniSpooler;


    cb=0;

    if (pIniForm=FindForm(pFormName, pIniSpooler)) {

        cb=GetFormSize(pIniForm, Level);

        *pcbNeeded=cb;

        if (cb > cbBuf) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
           LeaveSplSem();
            SplOutSem();
            return FALSE;
        }

        pEnd=pForm+cbBuf;

        CopyIniFormToForm(pIniForm, Level, pForm, pEnd);
    } else {
        SetLastError( ERROR_INVALID_FORM_NAME );
    }

   LeaveSplSem();
    SplOutSem();

    return !!pIniForm;
}

BOOL
SplSetForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm
)
{
    HKEY     hFormsKey;
    DWORD    Status;
    PINIFORM pIniForm;
    LPFORM_INFO_1 pFormInfo;
    REG_FORM_INFO RegFormInfo;
    PINISPOOLER pIniSpooler;
    PSPOOL   pSpool = (PSPOOL)hPrinter;


    //
    // Validate this Printer Handle
    // Disallow Mask: PRINTER_HANDLE_SERVER
    //

    if (!ValidateSpoolHandle( pSpool , 0 )) {
        return(FALSE);
    }

    pIniSpooler = pSpool->pIniSpooler;

    if (Level != 1) {
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (!ValidateForm(pForm)) {

        /* ValidateForm sets the appropriate error code:
         */
        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    EnterSplSem();


    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );

    pFormInfo = (LPFORM_INFO_1)pForm;

    pIniForm = FindForm(pFormName, pIniSpooler);

    if (!pIniForm || (pIniForm->Type == FORM_BUILTIN) || (pFormInfo->Flags & FORM_BUILTIN)) {

        SetLastError( pIniForm ?
                          ERROR_INVALID_PARAMETER :
                          ERROR_INVALID_FORM_NAME );
        LeaveSplSem();
        return FALSE;
    }

    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pIniSpooler->pszRegistryForms, 0,
                          KEY_WRITE, &hFormsKey);

    if (Status == NO_ERROR) {

        RegFormInfo.Size = pFormInfo->Size;
        RegFormInfo.ImageableArea = pFormInfo->ImageableArea;
        RegFormInfo.Flags = pFormInfo->Flags;

        Status = RegSetValueEx(hFormsKey, pFormInfo->pName, 0, REG_BINARY,
                               (LPBYTE)&RegFormInfo, sizeof RegFormInfo);

        RegCloseKey(hFormsKey);
    }

    if (Status == NO_ERROR) {

        pIniForm->Size = pFormInfo->Size;
        pIniForm->ImageableArea = pFormInfo->ImageableArea;
        pIniForm->Type = pFormInfo->Flags;

        SetPrinterChange(NULL,
                         NULL,
                         NULL,
                         PRINTER_CHANGE_SET_FORM,
                         pIniSpooler);

        BroadcastChangeForms(pIniSpooler);
    }

    LeaveSplSem();

    return (Status == NO_ERROR);
}


BOOL
SplEnumForms(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    PINIFORM    pIniForm;
    DWORD       cb;
    LPBYTE      pEnd;
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    PINISPOOLER pIniSpooler;

    if (!ValidateSpoolHandle(pSpool, 0 )) {
        return FALSE;
    }

    *pcReturned=0;

   EnterSplSem();

    pIniSpooler = pSpool->pIniSpooler;

    SPLASSERT( ( pIniSpooler != NULL ) &&
               ( pIniSpooler->signature == ISP_SIGNATURE ));


    cb=0;
    pIniForm=pIniSpooler->pShared->pIniForm;

    while (pIniForm) {
        cb+=GetFormSize(pIniForm, Level);
        pIniForm=pIniForm->pNext;
    }

    *pcbNeeded=cb;

    if (cb > cbBuf) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
       LeaveSplSem();
        SplOutSem();
        return FALSE;
    }

    pIniForm=pIniSpooler->pShared->pIniForm;
    pEnd=pForm+cbBuf;
    while (pIniForm) {
        pEnd = CopyIniFormToForm(pIniForm, Level, pForm, pEnd);
        switch (Level) {
        case 1:
            pForm+=sizeof(FORM_INFO_1);
            break;
        }
        pIniForm=pIniForm->pNext;
        (*pcReturned)++;
    }


   LeaveSplSem();
    SplOutSem();
    return TRUE;
}

DWORD dwBroadcastChangeFormsThread = 0;

VOID
BroadcastChangeForms(
    PINISPOOLER pIniSpooler)

/*++

Routine Description:

    Notify all applications that their devmode may have changed (when
    a form is changed).

Arguments:

Return Value:

--*/

{
    PINIPRINTER pIniPrinter;
    WCHAR       PrinterName[ MAX_UNC_PRINTER_NAME ];
    UINT        MachineNameLen;

    SplInSem();

    if( !( pIniSpooler->SpoolerFlags & SPL_FORMS_CHANGE )) {
        return;
    }

    INCSPOOLERREF( pIniSpooler );

    ++dwBroadcastChangeFormsThread;

    if ( pIniSpooler != pLocalIniSpooler ) {

        //
        // For Non Local Printers prepend the Machine Name
        //
        wsprintf( PrinterName, L"%ws\\", pIniSpooler->pMachineName );

    } else {

        PrinterName[0] = L'\0';
    }

    MachineNameLen = wcslen( PrinterName ) ;

    for( pIniPrinter = pIniSpooler->pIniPrinter;
         pIniPrinter;
         pIniPrinter = pIniPrinter->pNext ) {

        wcscpy ( &PrinterName[MachineNameLen], pIniPrinter->pName );

        //
        // Stress testing has shown that SendNotifyMessage can take
        // a long time to return, so leave critical section.
        //
        INCPRINTERREF( pIniPrinter );

        LeaveSplSem();
        SplOutSem();

        SendNotifyMessage(HWND_BROADCAST,
                          WM_DEVMODECHANGE,
                          0,
                          (LPARAM)PrinterName);
        EnterSplSem();

        DECPRINTERREF( pIniPrinter );
    }

    DECSPOOLERREF( pIniSpooler );
}


VOID
Upgrade35Forms(
    IN     HKEY hFormsKey,
    IN OUT PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Upgrade the forms entries in hFormsKey to include an extra DWORD
    FormOrder value.  This value is used to determine the order of
    user-defined forms (built-in forms always go in the front).  In
    the upgrade case, we assign the order based on the registry order
    (this is arbitrary).

    It is necessary to keep pIniSpooler->pIniForm in the same order
    to ensure EnumForms returns them in the same order, since drivers
    call EnumForms and assign index numbers to these forms.  If the
    order is different, the indicies will change, and dmPaperSize in
    the DEVMODE will point to a different paper size.

    If forms are added (either by the user or by the driver when it has
    new paper sizes), they will be placed at the end of the list so that
    previous indicies do not change.  If forms are deleted, then some
    indicies will change, and the printout will use the incorrect form
    (later we will add FORM_INFO_2 which returns a unique, non-changing
    index).

Arguments:

    hFormsKey - Key pointing to 3.5, 3.1 forms that need to be updated.

    pIniSpooler - Current spooler.

Return Value:

    VOID

Notes:

    pIniSpooler->cFormsOrderMax updated.

--*/

{
    DWORD         cUserDefinedForms;
    WCHAR         FormName[MAX_PATH];
    DWORD         cchFormName;
    REG_FORM_INFO RegFormInfo;
    DWORD         cbRegFormInfo;

    //
    // Read in the old FORM info, which lacks the cFormOrder and/or Flags, then
    // write it out with the new cFormOrder and/or Flags.
    //
    for( cUserDefinedForms = 0;
         TRUE;
         ++cUserDefinedForms ){

        cchFormName = COUNTOF( FormName );
        cbRegFormInfo = sizeof( RegFormInfo );

        if( RegEnumValue( hFormsKey,
                          cUserDefinedForms,
                          (LPWSTR)FormName,
                          &cchFormName,
                          NULL,
                          NULL,
                          (LPBYTE)&RegFormInfo,
                          &cbRegFormInfo ) != NO_ERROR ){

            break;
        }

        RegFormInfo.cFormOrder  = cUserDefinedForms;
        RegFormInfo.Flags       = FORM_USER;

        //
        // Write it out with the new value cFormOrderMax value.
        //
        RegSetValueEx( hFormsKey,
                       (LPWSTR)FormName,
                       0,
                       REG_BINARY,
                       (LPBYTE)&RegFormInfo,
                       sizeof( RegFormInfo ));
    }

    pIniSpooler->cFormOrderMax = cUserDefinedForms - 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\gdi.c ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation

Module Name:

    gdi.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/

#define NOMINMAX

#include <precomp.h>

#include "wingdip.h"


HANDLE
LocalCreatePrinterIC(
    HANDLE  hPrinter,
    LPDEVMODE   pDevMode
)
{
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    PSPOOLIC pSpoolIC;

    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {
        return NULL;
    }

    pSpoolIC = (PSPOOLIC)AllocSplMem( sizeof( SPOOLIC ));

    if( !pSpoolIC ){
        return NULL;
    }

    pSpoolIC->signature = IC_SIGNATURE;
    pSpoolIC->pIniPrinter = pSpool->pIniPrinter;

    ++pSpoolIC->pIniPrinter->cRefIC;

    return (HANDLE)pSpoolIC;
}

BOOL
LocalPlayGdiScriptOnPrinterIC(
    HANDLE  hPrinterIC,
    LPBYTE  pIn,
    DWORD   cIn,
    LPBYTE  pOut,
    DWORD   cOut,
    DWORD   ul
)
{
    INT nBufferSize,iRet;
    PUNIVERSAL_FONT_ID pufi;
    LARGE_INTEGER TimeStamp;

    if( cOut == sizeof(INT) )
    {
        pufi = NULL;
        nBufferSize = 0;
    }
    else
    {
        pufi = (PUNIVERSAL_FONT_ID) (pOut + sizeof(INT));
        nBufferSize = (cOut - sizeof(INT)) / sizeof(UNIVERSAL_FONT_ID);
    }

    iRet = GdiQueryFonts( pufi, nBufferSize, &TimeStamp );

    if( iRet < 0 )
    {
        if (GetLastError() == ERROR_SUCCESS) {
            // Set a generic last error for GDI
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
        return FALSE;
    }
    else
    {
        *((INT*)pOut) = iRet;
        return TRUE;
    }
}

BOOL
LocalDeletePrinterIC(
    HANDLE  hPrinterIC
)
{
    PSPOOLIC pSpoolIC = (PSPOOLIC)hPrinterIC;

    if( !pSpoolIC || pSpoolIC->signature != IC_SIGNATURE ){
        SetLastError( ERROR_INVALID_HANDLE );
        DBGMSG( DBG_WARN,
                ( "LocalDeletePrinterIC: Invalid handle value %x\n",
                  hPrinterIC ));
        return FALSE;
    }

    --pSpoolIC->pIniPrinter->cRefIC;
    FreeSplMem( pSpoolIC );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\inet.cxx ===
/*****************************************************************************\
* MODULE: inet.cxx
*
* The module contains routines for the setting up the WWW Printer Service during spooler start up.
*
* The entry point here should be called by localspl\init.c\InitializePrintProvidor() once it is done
* with its work.
*
* Copyright (C) 1996 Microsoft Corporation
*
* History:
*   Dec-1996   BabakJ     Wrote it for IIS 2.0.
*   June-1997  BabakJ     Rewrote to use IIS 4.0's new Metabase interface
*   Feb-1998   Weihaic    Modify the URL in default.htm
*   Feb 1999   BabakJ     Made metabase interface a global to avoi calling too many CoCreateInstance() for perfrmance.
\*****************************************************************************/

//
//
// Note: We cannot use precomp.h here since we requrie ATL which can only be included in C++ source files.
//
//


#define INITGUID     // babakj: (see comments in objbase.h) Needed to do it to get GUID_NULL defined.

#include "precomp.h"
#pragma hdrstop

#include <iadmw.h>      // Interface header
#include <iiscnfg.h>    // MD_ & IIS_MD_ defines

#include "..\spllib\webutil.hxx"

#define MY_META_TIMEOUT 1000

PWCHAR szW3SvcRootPath = L"/LM/W3svc/1/Root";


BOOL   fW3SvcInstalled = FALSE;  // Gobal flag telling if IIS or "Peer eb Server" is installed on the local machine.
PWCHAR szW3Root = NULL;          // The WWWRoot dir, e.g. d:\inetpub\wwwroot


static CRITICAL_SECTION ClientCS;
static CRITICAL_SECTION ServerCS;
static HANDLE hMetaBaseThdReady;
static IMSAdminBase *pIMeta = NULL;  // Metabase interface pointer


class CWebShareData {
public:
    LPWSTR m_pszShareName;
    BOOL   m_bValid;
public:
    CWebShareData (LPWSTR pszShareName);
    ~CWebShareData ();
    int Compare (CWebShareData *pSecond) {return 0;};
};

class CWebShareList :
    public CSingleList<CWebShareData*>
{
public:
    CWebShareList () {};
    ~CWebShareList () {};

    void WebSharePrinterList (void);
};

LPWSTR
mystrstrni(
    LPWSTR pSrc,
    LPWSTR pSearch
);

BOOL
CopyWebPrnFile(
    VOID
);

BOOL
SetupWebPrnSvc(
    IMSAdminBase *pIMSAdminBase,
    BOOL fWebPrnDesired,
    BOOL *pfW3SvcInstalled
);

BOOL
AddWebPrnSvc(
    IMSAdminBase *pIMSAdminBase,
    BOOL *pfW3SvcInstalled
);

BOOL
RemoveWebPrnSvc(
    IMSAdminBase *pIMSAdminBase
);

BOOL
RemoveScript(
    IMSAdminBase *pIMSAdminBase
);

BOOL
RemoveVirtualDir(
    IMSAdminBase *pIMSAdminBase
);

BOOL
InstallWebPrnSvcWorker(
    void
);

void
InstallWebPrnSvcWorkerThread(
    PINISPOOLER pIniSpooler
);

BOOL
AddScriptAtPrinterVDir(
    IMSAdminBase *pIMSAdminBase
);

BOOL
AddVirtualDir(
    IMSAdminBase *pIMSAdminBase
);

void
WebShareWorker(
    LPWSTR pShareName
);

BOOL
CreateVirtualDirForPrinterShare(
    IMSAdminBase *pIMSAdminBase,
    LPWSTR       pShareName
);

void
WebUnShareWorker(
    LPWSTR pShareName
);

BOOL
RemoveVirtualDirForPrinterShare(
    IMSAdminBase *pIMSAdminBase,
    LPWSTR       pShareName
);

void
WebShareAllPrinters(
    PINISPOOLER pIniSpooler
);


//
// This routine is called from init.c at localspl init time to kick start the whole thing.
//
// Make the COM activation on a separate thread in order not to slow down LocalSpl init process
//
void
InstallWebPrnSvc(
    PINISPOOLER pIniSpooler
)
{
    HANDLE ThreadHandle;
    DWORD ThreadId;
    HRESULT hr;                         // com error status


    // Init the sync objects needed for device arrival thread management
    InitializeCriticalSection( &ClientCS );
    InitializeCriticalSection( &ServerCS );
    hMetaBaseThdReady = CreateEvent( NULL, FALSE, FALSE, NULL);   // Auto reset, non-signaled state


    if (ThreadHandle = CreateThread( NULL,
                                     INITIAL_STACK_COMMIT,
                                     (LPTHREAD_START_ROUTINE)InstallWebPrnSvcWorkerThread,
                                     pIniSpooler, 0, &ThreadId )) {
        CloseHandle( ThreadHandle );
    }

}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// We cannot free our interface pointer becasue loading and unloading ADMWPROX.DLL is very slow.
// So we have to keep the interface pointer around. But due to COM Apt limitation, the thread that creates the interface has
// to be alive for other threads to be able to use the pointer. So here we are with this fancy thread management code:
//
// The thread stays alive for a while. Then it goes away. Then future WebShare/Unshare would invoke it again.
// So This thread could be invoked 2 ways: First by spooler init code (only once!), then by WebShare/Unshare code.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define EnterClient()  EnterCriticalSection( &ClientCS );
#define EnterServer()  EnterCriticalSection( &ServerCS );
#define LeaveClient()  LeaveCriticalSection( &ClientCS );
#define LeaveServer()  LeaveCriticalSection( &ServerCS );

static BOOL ThdAlive = FALSE;


///
///   Begin threading work
///


void
InstallWebPrnSvcWorkerThread(
    PINISPOOLER pIniSpooler
)
{
    IMSAdminBase    *pILocalMetaBase = NULL;

    SPLASSERT( (pIniSpooler == NULL) || (pIniSpooler == pLocalIniSpooler) );   // We only expect local pIniSpooler here!

    EnterServer();

    if( ThdAlive ) {
        SPLASSERT( FALSE );
        LeaveServer();
        return;
    }

    if( FAILED (CoInitializeEx( NULL, COINIT_MULTITHREADED )) ||
        FAILED (::CoCreateInstance(CLSID_MSAdminBase,
                          NULL,
                          CLSCTX_ALL,
                          IID_IMSAdminBase,
                          (void **)&pIMeta)))  {

        if( fW3SvcInstalled )
            SetEvent( hMetaBaseThdReady );  // We must have a client thread waiting in WebShare/UnShare, signal it!
        LeaveServer();
        return;
    }


    if( !fW3SvcInstalled ) {          // must be the first time we are being called.
        if (InstallWebPrnSvcWorker()) {
            WebShareAllPrinters( pIniSpooler );
            fW3SvcInstalled = TRUE;   // Once this is set, we never unset it. It is an indication that the WEb init code has succeeded.
        }
    }
    else
        SetEvent( hMetaBaseThdReady );    // event reset after a waiting thread is released.

    ThdAlive = TRUE;

    LeaveServer();

    Sleep( 15 * 60 * 1000 );    // Allow other threads to use the COM pointer for 15 minutes

    //
    // Now tear down the IISADMIN object and self terminate thread. Ensure that
    // we do not release the pointer inside the CS since this could take a long
    // time, this could potentially cause a large number of WorkerThreads queueing
    // up and doing the Release(), but that cannot be helped.
    //
    EnterServer();

    pILocalMetaBase = pIMeta;

    //
    // The client thread expects valid pointers to be non-NULL!
    //
    pIMeta = NULL;
    ThdAlive = FALSE;

    LeaveServer();

    pILocalMetaBase->Release();

    CoUninitialize();

    return;
}

void
WebShareManagement(
    LPWSTR pShareName,
    BOOL bShare          // If TRUE, will share it, else unshare it.
) {
    HANDLE ThreadHandle;
    DWORD ThreadId;

    if( !fW3SvcInstalled ) {
        return;
    }

    if(FAILED (CoInitializeEx( NULL, COINIT_MULTITHREADED )))
        return;

    EnterClient();
    EnterServer();

    if( !ThdAlive ) {
        LeaveServer();

        if (ThreadHandle = CreateThread(NULL,
                                        INITIAL_STACK_COMMIT,
                                        (LPTHREAD_START_ROUTINE)InstallWebPrnSvcWorkerThread,
                                        NULL,
                                        0,
                                        &ThreadId))   // sending NULL pIniSpooler since there is no need for it.
            CloseHandle( ThreadHandle );
        else {
            LeaveClient();
            return;
        }

        WaitForSingleObject( hMetaBaseThdReady, INFINITE );   // automatic reset event, so it is reset after a waiting thd released.
        EnterServer();
    }

    // Now do the real work
    if (pIMeta) {
        if( bShare)
            WebShareWorker( pShareName );
        else
            WebUnShareWorker( pShareName );
    }

    LeaveServer();
    LeaveClient();


    // No need to CoUninitialize();
}


///
///   End threading work
///



void
WebShareAllPrinters(
    PINISPOOLER pIniSpooler
)
{
    CWebShareList *pWebShareList = NULL;
    BOOL   bRet = TRUE;
    PINIPRINTER   pIniPrinter;


    if (pWebShareList = new CWebShareList ()) {

        // Go down the list of printers and share it out

        EnterSplSem();


        //
        // Re-share all shared printers.
        //

        for( pIniPrinter = pIniSpooler->pIniPrinter;
             pIniPrinter;
             pIniPrinter = pIniPrinter->pNext ) {

            if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED ) {

                CWebShareData *pData = new CWebShareData (pIniPrinter->pShareName);

                if (pData && pData->m_bValid &&
                    pWebShareList->Insert (pData)) {
                    continue;
                }
                else {

                    if (pData) {
                        delete pData;
                    }

                    bRet = FALSE;
                    break;
                }
            }
        }

        LeaveSplSem ();

        if (bRet) {
            pWebShareList->WebSharePrinterList ();
        }

        delete pWebShareList;

    }
}

PWSTR
GetPrinterUrl(
    PSPOOL  pSpool
)
{
    PINIPRINTER     pIniPrinter = pSpool->pIniPrinter;
    DWORD           cb;
    PWSTR           pszURL = NULL;
    PWSTR           pszServerName = NULL;
    HRESULT         hr;


    SplInSem();

    // http://machine/share
    if (!pIniPrinter->pShareName)
        goto error;

    // Get FQDN of this machine
    hr = GetDNSMachineName(pIniPrinter->pIniSpooler->pMachineName + 2, &pszServerName);
    if (FAILED(hr)) {
        SetLastError(HRESULT_CODE(hr));
        goto error;
    }

    cb = 7 + wcslen(pszServerName);  // http://machine
    cb += 1 + wcslen(pIniPrinter->pShareName) + 1;  // /share + NULL
    cb *= sizeof(WCHAR);

    if (pszURL = (PWSTR) AllocSplMem(cb)) {
        wsprintf(pszURL, L"http://%ws/%ws", pszServerName, pIniPrinter->pShareName);
    }


error:

    FreeSplStr(pszServerName);

    return pszURL;
}




//
//
// Reads the policy bit. Returns TRUE if Web Printing wanted, FASLE if not.
//
//
BOOL
IsWebPrintingDesired(
    VOID
)
{
    static PWCHAR szRegPolicyBitForDisableWebPrinting = L"Software\\Policies\\Microsoft\\Windows NT\\Printers";


    HKEY   hKey;
    DWORD  dwType;
    DWORD  cbData;
    DWORD  dwDataValue;
    BOOL   fRet = TRUE;

    if( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      szRegPolicyBitForDisableWebPrinting, 0, KEY_READ, &hKey)) {
        cbData = sizeof(dwDataValue);

        if( RegQueryValueEx(hKey, L"DisableWebPrinting" , NULL, &dwType, (LPBYTE)&dwDataValue, &cbData) == ERROR_SUCCESS )  {
            // As long as the value does not exist, it means that web printing is enabled
            // If the value is a DWORD, then if it is TRUE, Web Printing is Disabled

            if (dwType == REG_DWORD && dwDataValue) fRet = FALSE;
        }
        RegCloseKey( hKey );
    }
    return fRet;
}




BOOL
InstallWebPrnSvcWorker(
    VOID
)
{
    WCHAR  szTmpData[MAX_PATH];
    HRESULT hr;                         // com error status
    METADATA_HANDLE hMeta = NULL;       // handle to metabase
    BOOL    fW3Svc = FALSE;
    DWORD dwMDRequiredDataLen;
    METADATA_RECORD mr;


    // open key to ROOT on website #1 (default)
    hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                         L"/LM/W3svc/1",
                         METADATA_PERMISSION_READ,
                         MY_META_TIMEOUT,
                         &hMeta);
    if( SUCCEEDED( hr )) {

        // Get the physical path for the WWWROOT
        mr.dwMDIdentifier = MD_VR_PATH;
        mr.dwMDAttributes = 0;
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = STRING_METADATA;
        mr.dwMDDataLen    = sizeof( szTmpData );
        mr.pbMDData       = reinterpret_cast<unsigned char *>(szTmpData);

        hr = pIMeta->GetData( hMeta, L"/ROOT", &mr, &dwMDRequiredDataLen );
        pIMeta->CloseKey( hMeta );

        if( SUCCEEDED( hr )) {
            szW3Root = AllocSplStr( szTmpData );

            // Pass the inner dumb pointer for the callee to use
            if( SetupWebPrnSvc( pIMeta, IsWebPrintingDesired(), &fW3Svc ))
                DBGMSG(DBG_INFO, ("Setup of WWW Print Service successful.\n"));
            else
                DBGMSG(DBG_INFO, ("Setup of WWW Print Service failed.\n"));

        }
    }

    return fW3Svc;

}



//
// Given that the WWW server is installed on local machine, it installs/removes the Web Printing service.
//
// Won't reinstall if it is already installed.
//
// Installation involves:
//
//   - Add msw3prt as .printer. Just need to get the Win\sys dir.
//   - Add the virtual dis .printer
//
//  Uninstall means the removal of the above two.
//
//
BOOL
SetupWebPrnSvc(
    IMSAdminBase *pIMSAdminBase,
    BOOL fWebPrnDesired,             // whether Web Printing is desired by the caller
    BOOL *pfW3SvcInstalled           // Whether Web Printing actually got installed by this routine.
)
{
    if( fWebPrnDesired ) {

        return AddWebPrnSvc( pIMSAdminBase, pfW3SvcInstalled );
    }
    else {

        *pfW3SvcInstalled = FALSE;
        return RemoveWebPrnSvc( pIMSAdminBase );

    }
}


BOOL
AddWebPrnSvc(
    IMSAdminBase *pIMSAdminBase,
    BOOL *pfW3SvcInstalled           // Whether Web Printing actually got installed by this routine.
)
{
    HRESULT hr;          // com error status


    *pfW3SvcInstalled = FALSE;  // Assume failure

    //
    //  This is to remove the .printer script from the root
    //
    if( !RemoveScript( pIMSAdminBase ))
        return FALSE;


    if( !AddVirtualDir( pIMSAdminBase ))
        return FALSE;

    //
    // Add ".printer" as a script map to the printers virtual directory
    //
    if( !AddScriptAtPrinterVDir( pIMSAdminBase ))
        return FALSE;

    // Flush out the changes and close
    // Call SaveData() after making bulk changes, do not call it on each update
    hr = pIMSAdminBase->SaveData();
    if( FAILED( hr ))
        return FALSE;

    return( *pfW3SvcInstalled = TRUE );   // Web Printing installed.

}

BOOL
RemoveWebPrnSvc(
    IMSAdminBase *pIMSAdminBase
)
{
    HRESULT hr;          // com error status


    // Remove ".printer" as a script map from the website #1 (default)
    if( !RemoveScript( pIMSAdminBase ))
        return FALSE;


    if( !RemoveVirtualDir( pIMSAdminBase ))
        return FALSE;


    // Flush out the changes and close
    // Call SaveData() after making bulk changes, do not call it on each update
    hr = pIMSAdminBase->SaveData();
    if( FAILED( hr ))
        return FALSE;

    return( TRUE );     // Web Printing removed

}


//
//
// Finds the string pSearch in pSrc buffer and returns a ptr to the occurance of pSearch in pSrc.
//
//
LPWSTR mystrstrni( LPWSTR pSrc, LPWSTR pSearch )
{
    UINT uSearchSize = wcslen( pSearch );
    UINT uSrcSize    = wcslen( pSrc );
    LPCTSTR  pEnd;

    if( uSrcSize < uSearchSize )
        return(NULL);

    pEnd = pSrc + uSrcSize - uSearchSize;

    for( ; pSrc <= pEnd; ++pSrc ) {
        if( !_wcsnicmp( pSrc, pSearch, uSearchSize ))
            return((LPWSTR)pSrc);
    }

    return(NULL);
}

//
// Determines if the string pSearch can be found inside of a MULTI_SZ string. If it can, it retunrs a
// pointer to the beginning of the string in multi-sz that contains pSearch.
//
LPWSTR IsStrInMultiSZ( LPWSTR pMultiSzSrc, LPWSTR pSearch )
{
    LPWSTR pTmp = pMultiSzSrc;

    while( TRUE ) {
        if( mystrstrni( pTmp, pSearch ))  // See pSearch (i.e. ".printer" appears anywhere within this string. If it does, it must be ours.
            return pTmp;

        pTmp = pTmp + (wcslen(pTmp) + 1);   // Point to the beginning of the next string in the MULTI_SZ

        if( !*pTmp )
            return FALSE;             // reached the end of the MULTI_SZ string.
    }
}

#define W3SVC          L"w3svc"

/*++

Routine Name:

    AddScriptAtPrinterVDir

Description:

    Add the .printer and .asp script mapping at printers virtual directory

Arguments:

    pIMSAdminBase   - Pointer to the IIS Admin base

Returns:

    An HRESULT

--*/
BOOL
AddScriptAtPrinterVDir(
    IMSAdminBase *pIMSAdminBase
    )
{
    static WCHAR szScritMapFmt[] = L"%ws%c.printer,%ws\\msw3prt.dll,1,GET,POST%c";
    static WCHAR szPrinterVDir[] = L"w3svc/1/root/printers";

    METADATA_HANDLE hMeta           = NULL;       // handle to metabase
    PWCHAR          szFullFormat    = NULL;
    DWORD           dwMDRequiredDataLen;
    METADATA_RECORD mr;
    HRESULT         hr              = S_OK;
    DWORD           nLen;
    WCHAR           szSystemDir[MAX_PATH];
    PWCHAR          pAspMapping     = NULL;
    DWORD           dwMapingLen     = 0;
    PWCHAR          pScriptMap      = NULL;


    //
    // Read any script map set at the top, on LM\w3svc where all other default ones are (e.g. .asp, etc.)
    //
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                         L"/LM",
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         MY_META_TIMEOUT,
                         &hMeta);

    if(SUCCEEDED(hr))
    {
        mr.dwMDIdentifier = MD_SCRIPT_MAPS;
        mr.dwMDAttributes = 0;
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = MULTISZ_METADATA;
        mr.dwMDDataLen    = 0;
        mr.pbMDData       = NULL;

        hr = pIMSAdminBase->GetData( hMeta, W3SVC, &mr, &dwMDRequiredDataLen );

        hr = hr == HRESULT_FROM_WIN32 (ERROR_INSUFFICIENT_BUFFER) ? S_OK : E_FAIL;
    }

    if(SUCCEEDED(hr))
    {
        //
        // allocate for existing stuff plus our new script map.
        //
        szFullFormat = new WCHAR[dwMDRequiredDataLen];
        hr = szFullFormat? S_OK : E_OUTOFMEMORY;
    }

    if(SUCCEEDED(hr))
    {
        mr.dwMDIdentifier = MD_SCRIPT_MAPS;
        mr.dwMDAttributes = 0;
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = MULTISZ_METADATA;
        mr.dwMDDataLen    = dwMDRequiredDataLen * sizeof (WCHAR);
        mr.pbMDData       = reinterpret_cast<unsigned char *>(szFullFormat);

        hr = pIMSAdminBase->GetData( hMeta, W3SVC, &mr, &dwMDRequiredDataLen );
    }

    if(SUCCEEDED(hr))
    {
        pAspMapping = IsStrInMultiSZ( szFullFormat, L".asp" );

        hr = pAspMapping? S_OK: E_FAIL;
    }

    if(SUCCEEDED(hr))
    {
        nLen = COUNTOF (szScritMapFmt) + MAX_PATH + lstrlen (pAspMapping);

        pScriptMap = new WCHAR[nLen];

        hr = pScriptMap ? S_OK : E_OUTOFMEMORY;
    }


    if(SUCCEEDED(hr))
    {
        //
        // Return value is the length in chars w/o null char.
        //
        hr = GetSystemDirectory( szSystemDir, COUNTOF (szSystemDir)) > 0 ? S_OK : E_FAIL;
    }

    if(SUCCEEDED(hr))
    {
        dwMapingLen = wsprintf( pScriptMap, szScritMapFmt, pAspMapping, L'\0', szSystemDir, L'\0');

        hr = dwMapingLen > COUNTOF (szScritMapFmt) ? S_OK : E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        //
        // Write the new SCRIPT value
        //
        mr.dwMDIdentifier = MD_SCRIPT_MAPS;
        mr.dwMDAttributes = METADATA_INHERIT;
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = MULTISZ_METADATA;
        mr.dwMDDataLen    = sizeof (WCHAR) * (dwMapingLen + 1) ;
        mr.pbMDData       = reinterpret_cast<unsigned char *>(pScriptMap);

        hr = pIMSAdminBase->SetData( hMeta, szPrinterVDir, &mr );
    }

    if (hMeta)
    {
        pIMSAdminBase->CloseKey( hMeta );
        hMeta = NULL;
    }

    delete [] pScriptMap;
    delete [] szFullFormat;

    return SUCCEEDED (hr);
}

//
//
// Finds and removed our script map from the multi_sz, and writes it back to the metabase.
//
//
BOOL
WriteStrippedScriptValue(
    IMSAdminBase *pIMSAdminBase,
    METADATA_HANDLE hMeta,     // Handle to /LM tree
    PWCHAR szFullFormat        // MULTI_SZ string already there
)
{
    LPWSTR  pStrToKill, pNextStr;
    HRESULT hr;


    DBGMSG(DBG_INFO, ("Removing our script if already added.\n"));

    // See if our script map is already there.
    if( !(pStrToKill = IsStrInMultiSZ( szFullFormat, L".printer" )))
        return TRUE;

    // Find the next string (could be the final NULL char)
    pNextStr = pStrToKill + (wcslen(pStrToKill) + 1);

    if( !*pNextStr )
        *pStrToKill = 0;       // Our scipt map was at the end of multi_sz. Write the 2nd NULL char and we are done.
    else
        CopyMemory( pStrToKill,          // Remove our script map by copying the remainder of the multi_sz on top of the string containing the map.
                    pNextStr,
                    GetMultiSZLen(pNextStr) * sizeof(WCHAR));

    // Write the new SCRIPT value
    METADATA_RECORD mr;
    mr.dwMDIdentifier = MD_SCRIPT_MAPS;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = MULTISZ_METADATA;
    mr.dwMDDataLen    = GetMultiSZLen(szFullFormat) * sizeof(WCHAR);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(szFullFormat);

    hr = pIMSAdminBase->SetData( hMeta, W3SVC, &mr );

    return( SUCCEEDED( hr ));
}


//
//
// Removes ".printer" as a script map from the website #1 (default) if alreaedy there
//
//
BOOL
RemoveScript(
    IMSAdminBase *pIMSAdminBase
)
{
   METADATA_HANDLE hMeta = NULL;       // handle to metabase
    PWCHAR  szFullFormat;
    DWORD   dwMDRequiredDataLen;
    METADATA_RECORD mr;
    HRESULT hr;
    BOOL    fRet = FALSE;


    // Read any script map set at the top, on LM\w3svc where all other default ones are (e.g. .asp, etc.)
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                         L"/LM",
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         MY_META_TIMEOUT,
                         &hMeta);

    if( SUCCEEDED( hr )) {

        mr.dwMDIdentifier = MD_SCRIPT_MAPS;
        mr.dwMDAttributes = 0;
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = MULTISZ_METADATA;
        mr.dwMDDataLen    = 0;
        mr.pbMDData       = NULL;

        hr = pIMSAdminBase->GetData( hMeta, W3SVC, &mr, &dwMDRequiredDataLen );

        if( FAILED( hr )) {

            if( HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER ) {

                if( szFullFormat = (PWCHAR)AllocSplMem( dwMDRequiredDataLen )) {   // allocate for existing stuff plus our new script map.

                    mr.dwMDIdentifier = MD_SCRIPT_MAPS;
                    mr.dwMDAttributes = 0;
                    mr.dwMDUserType   = IIS_MD_UT_FILE;
                    mr.dwMDDataType   = MULTISZ_METADATA;
                    mr.dwMDDataLen    = dwMDRequiredDataLen;
                    mr.pbMDData       = reinterpret_cast<unsigned char *>(szFullFormat);

                    hr = pIMSAdminBase->GetData( hMeta, W3SVC, &mr, &dwMDRequiredDataLen );

                    if( SUCCEEDED( hr ))
                        fRet = WriteStrippedScriptValue( pIMSAdminBase, hMeta, szFullFormat );    // Remove the .printer map from the multi_sz if there;

                    FreeSplMem( szFullFormat );
                }
            }
        }

        pIMSAdminBase->CloseKey( hMeta );
    }

    return fRet;
}

/////////////////////////////////////////////////////////////////////////////////////////////////


static PWCHAR szPrinters = L"Printers";
#define PRINTERS   szPrinters      // Name of Printers virtual dir.


BOOL
AddVirtualDir(
    IMSAdminBase *pIMSAdminBase
)
{
    METADATA_HANDLE hMeta = NULL;       // handle to metabase
    WCHAR   szVirPath[MAX_PATH];
    WCHAR   szPath[MAX_PATH];
    DWORD   dwMDRequiredDataLen;
    DWORD   dwAccessPerm;
    METADATA_RECORD mr;
    HRESULT hr;
    BOOL    fRet;


    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                         szW3SvcRootPath,
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         MY_META_TIMEOUT,
                         &hMeta );

    // Create the key if it does not exist.
    if( FAILED( hr ))
        return FALSE;


    fRet = TRUE;

    mr.dwMDIdentifier = MD_VR_PATH;
    mr.dwMDAttributes = 0;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = sizeof( szVirPath );
    mr.pbMDData       = reinterpret_cast<unsigned char *>(szVirPath);

    // Read LM/W3Svc/1/Root/Printers see if MD_VR_PATH exists.
    hr = pIMSAdminBase->GetData( hMeta, PRINTERS, &mr, &dwMDRequiredDataLen );

    if( FAILED( hr )) {

        fRet = FALSE;
        if( hr == MD_ERROR_DATA_NOT_FOUND ||
            HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND ) {

            // Write both the key and the values if GetData() failed with any of the two errors.

            pIMSAdminBase->AddKey( hMeta, PRINTERS );

            if( GetWindowsDirectory( szPath, sizeof(szPath) / sizeof (TCHAR))) {      // Return value is the length in chars w/o null char.

                DBGMSG(DBG_INFO, ("Writing our virtual dir.\n"));

                wsprintf( szVirPath, L"%ws\\web\\printers", szPath );

                mr.dwMDIdentifier = MD_VR_PATH;
                mr.dwMDAttributes = METADATA_INHERIT;
                mr.dwMDUserType   = IIS_MD_UT_FILE;
                mr.dwMDDataType   = STRING_METADATA;
                mr.dwMDDataLen    = (wcslen(szVirPath) + 1) * sizeof(WCHAR);
                mr.pbMDData       = reinterpret_cast<unsigned char *>(szVirPath);

                // Write MD_VR_PATH value
                hr = pIMSAdminBase->SetData( hMeta, PRINTERS, &mr );
                fRet = SUCCEEDED( hr );

                // Set the default authentication method
                if( fRet ) {

                    DWORD dwAuthorization = MD_AUTH_NT;     // NTLM only.

                    mr.dwMDIdentifier = MD_AUTHORIZATION;
                    mr.dwMDAttributes = METADATA_INHERIT;   // need to inherit so that all subdirs are also protected.
                    mr.dwMDUserType   = IIS_MD_UT_FILE;
                    mr.dwMDDataType   = DWORD_METADATA;
                    mr.dwMDDataLen    = sizeof(DWORD);
                    mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwAuthorization);

                    // Write MD_AUTHORIZATION value
                    hr = pIMSAdminBase->SetData( hMeta, PRINTERS, &mr );
                    fRet = SUCCEEDED( hr );
                }
            }
        }
    }

    // In the following, do the stuff that we always want to do to the virtual dir, regardless of Admin's setting.


    if( fRet ) {

        dwAccessPerm = MD_ACCESS_READ | MD_ACCESS_SCRIPT;

        mr.dwMDIdentifier = MD_ACCESS_PERM;
        mr.dwMDAttributes = METADATA_INHERIT;    // Make it inheritable so all subdirectories will have the same rights.
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = DWORD_METADATA;
        mr.dwMDDataLen    = sizeof(DWORD);
        mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwAccessPerm);

        // Write MD_ACCESS_PERM value
        hr = pIMSAdminBase->SetData( hMeta, PRINTERS, &mr );
        fRet = SUCCEEDED( hr );
    }

    if( fRet ) {

        PWCHAR  szDefLoadFile = L"ipp_0001.asp";

        mr.dwMDIdentifier = MD_DEFAULT_LOAD_FILE;
        mr.dwMDAttributes = METADATA_INHERIT;
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = STRING_METADATA;
        mr.dwMDDataLen    = (wcslen(szDefLoadFile) + 1) * sizeof(WCHAR);
        mr.pbMDData       = reinterpret_cast<unsigned char *>(szDefLoadFile);

        // Write MD_DEFAULT_LOAD_FILE value
        hr = pIMSAdminBase->SetData( hMeta, PRINTERS, &mr );
        fRet = SUCCEEDED( hr );
    }

    if( fRet ) {

        PWCHAR  szKeyType = IIS_CLASS_WEB_VDIR_W;

        mr.dwMDIdentifier = MD_KEY_TYPE;
        mr.dwMDAttributes = METADATA_INHERIT;
        mr.dwMDUserType   = IIS_MD_UT_SERVER;
        mr.dwMDDataType   = STRING_METADATA;
        mr.dwMDDataLen    = (wcslen(szKeyType) + 1) * sizeof(WCHAR);
        mr.pbMDData       = reinterpret_cast<unsigned char *>(szKeyType);

        // Write MD_DEFAULT_LOAD_FILE value
        hr = pIMSAdminBase->SetData( hMeta, PRINTERS, &mr );
        fRet = SUCCEEDED( hr );
    }

    pIMSAdminBase->CloseKey( hMeta );

    return fRet;
}




//
//
// Removes "printers" virtual dir from IIS metabase ws3vc\1\root\printers
//
//
BOOL
RemoveVirtualDir(
    IMSAdminBase *pIMSAdminBase
)
{
    METADATA_HANDLE hMeta = NULL;       // handle to metabase
    HRESULT hr;


    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                         szW3SvcRootPath,
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         MY_META_TIMEOUT,
                         &hMeta );

    // Create the key if it does not exist.
    if( FAILED( hr ))
        return FALSE;

    pIMSAdminBase->DeleteKey( hMeta, PRINTERS );  // We don't check the retrun value since the key may already not exist and we could get an error for that reason.

    pIMSAdminBase->CloseKey( hMeta );

    return TRUE;
}





//=====================================================================================================
//=====================================================================================================
//=====================================================================================================
//
// Adding printer shares:
//
//  To support http://<server>/<share>, we create a virtual directory with a redirect property.
//
//
//=====================================================================================================
//=====================================================================================================
//=====================================================================================================

//=====================================================================================================
//
//  This function may be called during initialization time after fW3SvcInstalled is set,
//  which means, a printer maybe webshared twice (once in InstallWebPrnSvcWorkerThread,
//  and the other time when WebShare () is calleb by  ShareThisPrinter() in net.c by
//  FinalInitAfterRouterInitCompleteThread () during localspl initialization time.
//
//=====================================================================================================

void
WebShare(
    LPWSTR pShareName
)
{
    WebShareManagement( pShareName, TRUE );
}

void
WebShareWorker(
    LPWSTR pShareName
)
{
    HRESULT hr;                         // com error status

    SPLASSERT( pIMeta != NULL );

    // Pass the inner dumb pointer for the callee to use
    if( CreateVirtualDirForPrinterShare( pIMeta, pShareName ))

        // Flush out the changes and close
        // Call SaveData() after making bulk changes, do not call it on each update
        hr = pIMeta->SaveData();
}


BOOL
CreateVirtualDirForPrinterShare(
    IMSAdminBase *pIMSAdminBase,
    LPWSTR       pShareName
)
{
    METADATA_HANDLE hMeta = NULL;       // handle to metabase
    WCHAR   szOldURL[MAX_PATH];
    WCHAR   szPath[MAX_PATH];
    DWORD   dwMDRequiredDataLen;
    DWORD   dwAccessPerm;
    METADATA_RECORD mr;
    HRESULT hr;
    BOOL    fRet;


    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                         szW3SvcRootPath,
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         MY_META_TIMEOUT,
                         &hMeta );

    // Create the key if it does not exist.
    if( FAILED( hr ))
        return FALSE;


    fRet = TRUE;

    mr.dwMDIdentifier = MD_HTTP_REDIRECT;
    mr.dwMDAttributes = 0;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = sizeof( szOldURL );
    mr.pbMDData       = reinterpret_cast<unsigned char *>(szOldURL);

    // Read LM/W3Svc/1/Root/Printers to see if MD_HTTP_REDIRECT exists.
    // Note that we are only concerned with the presence of the vir dir,
    // not any properties it might have.
    //
    hr = pIMSAdminBase->GetData( hMeta, pShareName, &mr, &dwMDRequiredDataLen );

    if( FAILED( hr )) {

        fRet = FALSE;

        // Notice if the virtual dir exists, we won't touch it. One scenario is
        // if there is a name collision between a printer sharename and an existing,
        // unrelated virtual dir.
        if( HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND ) {

            // Write both the key and the values if GetData() failed with any of the two errors.

            pIMSAdminBase->AddKey( hMeta, pShareName );


            dwAccessPerm = MD_ACCESS_READ;

            mr.dwMDIdentifier = MD_ACCESS_PERM;
            mr.dwMDAttributes = 0;      // no need for inheritence
            mr.dwMDUserType   = IIS_MD_UT_FILE;
            mr.dwMDDataType   = DWORD_METADATA;
            mr.dwMDDataLen    = sizeof(DWORD);
            mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwAccessPerm);

            // Write MD_ACCESS_PERM value
            hr = pIMSAdminBase->SetData( hMeta, pShareName, &mr );
            fRet = SUCCEEDED( hr );

            if( fRet ) {

                PWCHAR  szKeyType = IIS_CLASS_WEB_VDIR_W;

                mr.dwMDIdentifier = MD_KEY_TYPE;
                mr.dwMDAttributes = 0;   // no need for inheritence
                mr.dwMDUserType   = IIS_MD_UT_FILE;
                mr.dwMDDataType   = STRING_METADATA;
                mr.dwMDDataLen    = (wcslen(szKeyType) + 1) * sizeof(WCHAR);
                mr.pbMDData       = reinterpret_cast<unsigned char *>(szKeyType);

                // Write MD_DEFAULT_LOAD_FILE value
                hr = pIMSAdminBase->SetData( hMeta, pShareName, &mr );
                fRet = SUCCEEDED( hr );
            }

            if( fRet ) {


                WCHAR szURL[MAX_PATH];

                wsprintf( szURL, L"/printers/%ws/.printer", pShareName );

                mr.dwMDIdentifier = MD_HTTP_REDIRECT;
                mr.dwMDAttributes = 0;   // no need for inheritence
                mr.dwMDUserType   = IIS_MD_UT_FILE;
                mr.dwMDDataType   = STRING_METADATA;
                mr.dwMDDataLen    = (wcslen(szURL) + 1) * sizeof(WCHAR);
                mr.pbMDData       = reinterpret_cast<unsigned char *>(szURL);

                // Write MD_DEFAULT_LOAD_FILE value
                hr = pIMSAdminBase->SetData( hMeta, pShareName, &mr );
                fRet = SUCCEEDED( hr );
            }
        }
    }

    pIMSAdminBase->CloseKey( hMeta );

    return fRet;
}


//=====================================================================================================
//=====================================================================================================
//=====================================================================================================
//
// Removing printer shares
//
//
//=====================================================================================================
//=====================================================================================================
//=====================================================================================================

void
WebUnShare(
    LPWSTR pShareName
)
{
    WebShareManagement( pShareName, FALSE );
}


void
WebUnShareWorker(
    LPWSTR pShareName
)
{
    HRESULT hr;                         // com error status

    SPLASSERT( pIMeta != NULL );

    // Pass the inner dumb pointer for the callee to use
    if( RemoveVirtualDirForPrinterShare( pIMeta, pShareName ))

        // Flush out the changes and close
        // Call SaveData() after making bulk changes, do not call it on each update
        hr = pIMeta->SaveData();
}


BOOL
RemoveVirtualDirForPrinterShare(
    IMSAdminBase *pIMSAdminBase,
    LPWSTR       pShareName
)
{
    METADATA_HANDLE hMeta = NULL;       // handle to metabase
    HRESULT hr;


    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                         szW3SvcRootPath,
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         MY_META_TIMEOUT,
                         &hMeta );

    // Create the key if it does not exist.
    if( FAILED( hr ))
        return FALSE;

    pIMSAdminBase->DeleteKey( hMeta, pShareName );  // We don't check the retrun value since the key may already not exist and we could get an error for that reason.
    pIMSAdminBase->CloseKey( hMeta );

    return TRUE;
}

CWebShareData::CWebShareData (LPWSTR pszShareName)
{
    m_bValid = FALSE;
    m_pszShareName = NULL;

    if (m_pszShareName = new WCHAR[lstrlen (pszShareName) +1]) {
        lstrcpy (m_pszShareName, pszShareName);
        m_bValid = TRUE;
    }
}

CWebShareData::~CWebShareData ()
{
    if (m_pszShareName) {
        delete [] m_pszShareName;
    }
}

void CWebShareList::WebSharePrinterList ()
{
    CSingleItem<CWebShareData*> * pItem = m_Dummy.GetNext();

    CWebShareData * pData = NULL;

    while (pItem && (pData = pItem->GetData ()) && pData->m_bValid) {

        WebShareWorker (pData->m_pszShareName);
        pItem = pItem->GetNext ();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\init.c ===
/*++

Copyright (c) 1990 - 1996  Microsoft Corporation
All rights reserved.

Module Name:

    init.c

Abstract:

    This module has all the initialization functions for the Local Print Provider

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Felix Maxa (amaxa) 18-Jun-2000
    Modified SplCreateSpooler to special case cluster pIniSpooler
    Modified LoadPrintProcessor to be able to copy the print processor
    from the cluster disk
    Added SplCreateSpoolerWorkerThread
          ClusterAddDriversFromClusterDisk
          ClusterAddVersionDrivers
          ClusterAddOrUpdateDriverFromClusterDisk, all part of the DCR
    regarding installing rpinter drivers on clusters

    Adina Trufinescu (adinatru) 07-December 1998
    Commented InitializePrintMonitor2 ;
    Changed back to the old interface - InitializePrintMonitor - which is defined in localmon.c


    Khaled Sedky (khaleds) 1-September 1998
    Modified InitializePrintProcessor amd added LoadPrintProcessor
    as a result of merging winprint and localspl

    Steve Wilson (swilson)  1-November 1996
    Added ShadowFile2 so spooler can delete crashing shadowfiles.

    Muhunthan Sivapragasam (MuhuntS) 1-June-1995
    Driver info 3 changes; Changes to use RegGetString, RegGetDword etc

    Matthew A Felton (MattFe) 27-June-1994
    pIniSpooler - allow other providers to call the spooler functions in LocalSpl

--*/

#include <precomp.h>
#pragma hdrstop

#include <lm.h>
#include <winbasep.h>
#include <faxreg.h>
#include "clusspl.h"
#include "jobid.h"
#include "filepool.hxx"

MODULE_DEBUG_INIT( DBG_ERROR , DBG_ERROR );

UINT gcClusterIniSpooler = 0;
#if DBG
HANDLE ghbtClusterRef = 0;
#endif

MONITORREG gMonitorReg = {
    sizeof( MONITORREG ),
    &SplRegCreateKey,
    &SplRegOpenKey,
    &SplRegCloseKey,
    &SplRegDeleteKey,
    &SplRegEnumKey,
    &SplRegQueryInfoKey,
    &SplRegSetValue,
    &SplRegDeleteValue,
    &SplRegEnumValue,
    &SplRegQueryValue
};

VOID
SplCreateSpoolerWorkerThread(
    PVOID pv
    );

DWORD
ClusterAddOrUpdateDriverFromClusterDisk(
    HKEY         hVersionKey,
    LPCWSTR      pszDriverName,
    LPCWSTR      pszEnvName,
    LPCWSTR      pszEnvDir,
    PINISPOOLER  pIniSpooler
    );

BOOL
Old2NewShadow(
    PSHADOWFILE   pShadowFile1,
    PSHADOWFILE_3 pShadowFile2,
    DWORD         *pnBytes
    );

VOID
FreeIniVersion(
    PINIVERSION pIniVersion
    );

BOOL
NotIniSpooler(
    BYTE *pMem
    );

PINIDRIVER
GetDriverList(
    HKEY hVersionKey,
    PINISPOOLER pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion
    );

PINIVERSION
GetVersionDrivers(
    HKEY hDriversKey,
    LPWSTR VersionName,
    PINISPOOLER pIniSpooler,
    PINIENVIRONMENT pIniEnvironment
    );

VOID
GetPrintSystemVersion(
    PINISPOOLER pIniSpooler
    );

VOID
InitializeSpoolerSettings(
    PINISPOOLER pIniSpooler
    );

VOID
WaitForSpoolerInitialization(
    VOID
    );

BOOL
ValidateProductSuite(
    PWSTR SuiteName
    );

LPWSTR
FormatRegistryKeyForPrinter(
    LPWSTR pSource,     /* The string from which backslashes are to be added. */
    LPWSTR pScratch     /* Scratch buffer for the function to write in;     */
    );                  /* must be at least as long as pSource.             */

#define MAX_LENGTH_DRIVERS_SHARE_REMARK 256

WCHAR *szSpoolDirectory   = L"\\spool";
WCHAR *szPrintShareName   = L"";            /* No share for printers in product1 */
WCHAR *szPrintDirectory   = L"\\printers";
WCHAR *szDriversDirectory = L"\\drivers";
WCHAR *gszNT4EMF = L"NT EMF 1.003";
WCHAR *gszNT5EMF = L"NT EMF 1.008";


SHARE_INFO_2 DriversShareInfo={NULL,                /* Netname - initialized below */
                               STYPE_DISKTREE,      /* Type of share */
                               NULL,                /* Remark */
                               0,                   /* Default permissions */
                               SHI_USES_UNLIMITED,  /* No users limit */
                               SHI_USES_UNLIMITED,  /* Current uses (??) */
                               NULL,                /* Path - initialized below */
                               NULL};               /* No password */


//  WARNING
//      Do not access these directly always go via pIniSpooler->pszRegistr...
//      This will then work for multiple pIniSpoolers

PWCHAR ipszRoot                   = L"Print";
PWCHAR ipszRegistryRoot           = L"System\\CurrentControlSet\\Control\\Print";
PWCHAR ipszRegistryPrinters       = L"System\\CurrentControlSet\\Control\\Print\\Printers";
PWCHAR ipszRegSwPrinters          = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Print\\Printers";
PWCHAR ipszRegistryMonitors       = L"Monitors";
PWCHAR ipszRegistryMonitorsHKLM   = L"\\System\\CurrentControlSet\\Control\\Print\\Monitors";
PWCHAR ipszRegistryEnvironments   = L"System\\CurrentControlSet\\Control\\Print\\Environments";
PWCHAR ipszClusterDatabaseEnvironments = L"Environments";
PWCHAR ipszRegistryEventLog       = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\Print";
PWCHAR ipszRegistryProviders      = L"Providers";
PWCHAR ipszEventLogMsgFile        = L"%SystemRoot%\\System32\\LocalSpl.dll";
PWCHAR ipszDriversShareName       = L"print$";
PWCHAR ipszRegistryForms          = L"System\\CurrentControlSet\\Control\\Print\\Forms";
PWCHAR ipszRegistryProductOptions = L"System\\CurrentControlSet\\Control\\ProductOptions";
PWCHAR ipszRegistryWin32Root      = L"System\\CurrentControlSet\\Control\\Print\\Providers\\LanMan Print Services\\Servers";
PWCHAR ipszRegistryClusRepository = SPLREG_CLUSTER_LOCAL_ROOT_KEY;

WCHAR *szPrinterData      = L"PrinterDriverData";
WCHAR *szConfigurationKey = L"Configuration File";
WCHAR *szDataFileKey      = L"Data File";
WCHAR *szDriverVersion    = L"Version";
WCHAR *szTempDir          = L"TempDir";
WCHAR *szDriverAttributes = L"DriverAttributes";
WCHAR *szDriversKey       = L"Drivers";
WCHAR *szPrintProcKey     = L"Print Processors";
WCHAR *szPrintersKey      = L"Printers";
WCHAR *szEnvironmentsKey  = L"Environments";
WCHAR *szDirectory        = L"Directory";
WCHAR *szDriverIni        = L"Drivers.ini";
WCHAR *szDriverFile       = L"Driver";
WCHAR *szDriverDataFile   = L"DataFile";
WCHAR *szDriverConfigFile = L"ConfigFile";
WCHAR *szDriverDir        = L"DRIVERS";
WCHAR *szPrintProcDir     = L"PRTPROCS";
WCHAR *szPrinterDir       = L"PRINTERS";
WCHAR *szClusterPrinterDir= L"Spool";
WCHAR *szPrinterIni       = L"\\printer.ini";
WCHAR *szAllSpools        = L"\\*.SPL";
WCHAR *szNullPort         = L"NULL";
WCHAR *szComma            = L",";
WCHAR *szName             = L"Name";
WCHAR *szShare            = L"Share Name";
WCHAR *szPort             = L"Port";
WCHAR *szPrintProcessor   = L"Print Processor";
WCHAR *szDatatype         = L"Datatype";
WCHAR *szDriver           = L"Printer Driver";
WCHAR *szLocation         = L"Location";
WCHAR *szDescription      = L"Description";
WCHAR *szAttributes       = L"Attributes";
WCHAR *szStatus           = L"Status";
WCHAR *szPriority         = L"Priority";
WCHAR *szDefaultPriority  = L"Default Priority";
WCHAR *szUntilTime        = L"UntilTime";
WCHAR *szStartTime        = L"StartTime";
WCHAR *szParameters       = L"Parameters";
WCHAR *szSepFile          = L"Separator File";
WCHAR *szDevMode          = L"Default DevMode";
WCHAR *szSecurity         = L"Security";
WCHAR *szSpoolDir         = L"SpoolDirectory";
WCHAR *szNetMsgDll        = L"NETMSG.DLL";
WCHAR *szMajorVersion     = L"MajorVersion";
WCHAR *szMinorVersion     = L"MinorVersion";
WCHAR *szTimeLastChange   = L"ChangeID";
WCHAR *szTotalJobs        = L"TotalJobs";
WCHAR *szTotalBytes       = L"TotalBytes";
WCHAR *szTotalPages       = L"TotalPages";
WCHAR *szHelpFile         = L"Help File";
WCHAR *szMonitor          = L"Monitor";
WCHAR *szDependentFiles   = L"Dependent Files";
WCHAR *szPreviousNames    = L"Previous Names";
WCHAR *szDNSTimeout       = L"dnsTimeout";
WCHAR *szTXTimeout        = L"txTimeout";
WCHAR *szNTFaxDriver      = FAX_DRIVER_NAME;
WCHAR *szPublishPoint     = L"PublishPoint";
WCHAR *szCommonName       = L"CommonName";
WCHAR *szObjectGUID       = L"ObjectGUID";
WCHAR *szDsKeyUpdate      = L"DsKeyUpdate";
WCHAR *szDsKeyUpdateForeground = L"DsKeyUpdateForeground";
WCHAR *szAction           = L"Action";
WCHAR *szMfgName          = L"Manufacturer";
WCHAR *szOEMUrl           = L"OEM URL";
WCHAR *szHardwareID       = L"HardwareID";
WCHAR *szProvider         = L"Provider";
WCHAR *szDriverDate       = L"DriverDate";
WCHAR *szLongVersion      = L"DriverVersion";
WCHAR *szClusDrvTimeStamp = L"TimeStamp";

WCHAR *szRegistryRoot     = L"System\\CurrentControlSet\\Control\\Print";
WCHAR *szEMFThrottle      = L"EMFThrottle";
WCHAR *szFlushShadowFileBuffers = L"FlushShadowFileBuffers";
WCHAR *szPendingUpgrades  = L"PendingUpgrades";

WCHAR *szPrintPublishPolicy = L"Software\\Policies\\Microsoft\\Windows NT\\Printers";

WCHAR *szClusterDriverRoot       = L"PrinterDrivers";
WCHAR *szClusterNonAwareMonitors = L"OtherMonitors";

#if DBG
WCHAR *szDebugFlags       = L"DebugFlags";
#endif

WCHAR *szEnvironment      = LOCAL_ENVIRONMENT;
WCHAR *szWin95Environment = L"Windows 4.0";
const WCHAR gszCacheMasqPrinters[] = L"CacheMasqPrinters";

HANDLE hInst;

//  Time before a job is assumed abandond and deleted during FastPrint
//  operation
DWORD   dwFastPrintWaitTimeout        = FASTPRINT_WAIT_TIMEOUT;
DWORD   dwSpoolerPriority             = THREAD_PRIORITY_NORMAL;
DWORD   dwPortThreadPriority          = DEFAULT_PORT_THREAD_PRIORITY;
DWORD   dwSchedulerThreadPriority     = DEFAULT_SCHEDULER_THREAD_PRIORITY;
DWORD   dwFastPrintThrottleTimeout    = FASTPRINT_THROTTLE_TIMEOUT;
DWORD   dwFastPrintSlowDownThreshold  = FASTPRINT_SLOWDOWN_THRESHOLD;
DWORD   dwServerThreadPriority        = DEFAULT_SERVER_THREAD_PRIORITY;
DWORD   dwEnableBroadcastSpoolerStatus = 0;

//  NT 3.1  No Version ( Version 0 )    User Mode
//  NT 3.5 and 3.51      Version 1      User Mode
//  NT 4.0               Version 2      Kernel Mode

DWORD   dwMajorVersion = SPOOLER_VERSION;
DWORD   dwMinorVersion = 0;

// Unique Printer ID counter which increases monotonically. Wraps at 4G.
DWORD   dwUniquePrinterSessionID = 0;

// Globals for EMF job scheduling

DWORD   dwNumberOfEMFJobsRendering = 0;
BOOL    bUseEMFScheduling = FALSE;
SIZE_T  TotalMemoryForRendering = 0;
SIZE_T  AvailMemoryForRendering = 0;
DWORD   dwLastScheduleTime = 0;

PJOBDATA pWaitingList  = NULL;
PJOBDATA pScheduleList = NULL;

DWORD   dwFlushShadowFileBuffers  = 0;     // default for uninitialized


// Time to sleep if the LocalWritePrinter WritePort doesn't write any bytes
// but still returns success.
DWORD   dwWritePrinterSleepTime  = WRITE_PRINTER_SLEEP_TIME;

BOOL    gbRemoteFax = TRUE;

BOOL      Initialized = FALSE;

PINISPOOLER     pLocalIniSpooler = NULL;
PINIENVIRONMENT pThisEnvironment = NULL;

#define POOL_TIMEOUT     120000 // 2 minutes
#define MAX_POOL_FILES   50



//
//  Global for KM Printers Blocking Policy
//  by default it is
//  1 "blocked" for Server and
//  0 "not blocked" for Workstation
//
DWORD   DefaultKMPrintersAreBlocked;

//
// Read from the registry if the HKLM\...\Print\ServerInstallTimeOut DWORD entry exists
// Otherwise default 5 mins.
//
DWORD   gdwServerInstallTimeOut;


//
//  0 - Not upgrading, 1 - performing upgrade
//

DWORD dwUpgradeFlag = 0;

LPWSTR szRemoteDoc;
LPWSTR szLocalDoc;
LPWSTR szFastPrintTimeout;
LPWSTR szRaw = L"RAW";


PRINTPROVIDOR PrintProvidor = {LocalOpenPrinter,
                               LocalSetJob,
                               LocalGetJob,
                               LocalEnumJobs,
                               LocalAddPrinter,
                               SplDeletePrinter,
                               SplSetPrinter,
                               SplGetPrinter,
                               LocalEnumPrinters,
                               LocalAddPrinterDriver,
                               LocalEnumPrinterDrivers,
                               SplGetPrinterDriver,
                               LocalGetPrinterDriverDirectory,
                               LocalDeletePrinterDriver,
                               LocalAddPrintProcessor,
                               LocalEnumPrintProcessors,
                               LocalGetPrintProcessorDirectory,
                               LocalDeletePrintProcessor,
                               LocalEnumPrintProcessorDatatypes,
                               LocalStartDocPrinter,
                               LocalStartPagePrinter,
                               LocalWritePrinter,
                               LocalEndPagePrinter,
                               LocalAbortPrinter,
                               LocalReadPrinter,
                               LocalEndDocPrinter,
                               LocalAddJob,
                               LocalScheduleJob,
                               SplGetPrinterData,
                               SplSetPrinterData,
                               LocalWaitForPrinterChange,
                               SplClosePrinter,
                               SplAddForm,
                               SplDeleteForm,
                               SplGetForm,
                               SplSetForm,
                               SplEnumForms,
                               LocalEnumMonitors,
                               LocalEnumPorts,
                               LocalAddPort,
                               LocalConfigurePort,
                               LocalDeletePort,
                               LocalCreatePrinterIC,
                               LocalPlayGdiScriptOnPrinterIC,
                               LocalDeletePrinterIC,
                               LocalAddPrinterConnection,
                               LocalDeletePrinterConnection,
                               LocalPrinterMessageBox,
                               LocalAddMonitor,
                               LocalDeleteMonitor,
                               SplResetPrinter,
                               SplGetPrinterDriverEx,
                               LocalFindFirstPrinterChangeNotification,
                               LocalFindClosePrinterChangeNotification,
                               LocalAddPortEx,
                               NULL,
                               LocalRefreshPrinterChangeNotification,
                               LocalOpenPrinterEx,
                               LocalAddPrinterEx,
                               LocalSetPort,
                               SplEnumPrinterData,
                               SplDeletePrinterData,
                               SplClusterSplOpen,
                               SplClusterSplClose,
                               SplClusterSplIsAlive,
                               SplSetPrinterDataEx,
                               SplGetPrinterDataEx,
                               SplEnumPrinterDataEx,
                               SplEnumPrinterKey,
                               SplDeletePrinterDataEx,
                               SplDeletePrinterKey,
                               LocalSeekPrinter,
                               LocalDeletePrinterDriverEx,
                               LocalAddPerMachineConnection,
                               LocalDeletePerMachineConnection,
                               LocalEnumPerMachineConnections,
                               LocalXcvData,
                               LocalAddPrinterDriverEx,
                               SplReadPrinter,
                               LocalDriverUnloadComplete,
                               LocalGetSpoolFileHandle,
                               LocalCommitSpoolData,
                               LocalCloseSpoolFileHandle,
                               LocalFlushPrinter,
                               LocalSendRecvBidiData,
                               LocalAddDriverCatalog,
                               };

DWORD
FinalInitAfterRouterInitCompleteThread(
    DWORD dwUpgrade
    );

#if DBG
VOID
InitializeDebug(
    PINISPOOLER pIniSpooler
);

PDBG_POINTERS
DbgSplGetPointers(
    VOID
    );
#endif

BOOL
DllMain(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes
)
{
    switch(dwReason) {
    case DLL_PROCESS_ATTACH:

        InitializeLocalspl();

        DisableThreadLibraryCalls(hModule);

        hInst = hModule;
        LocalMonInit(hInst);
        break;

    case DLL_PROCESS_DETACH :
        ShutdownPorts( pLocalIniSpooler );
        break;

    default:
        break;
    }
    return TRUE;

    UNREFERENCED_PARAMETER( lpRes );
}


VOID
InitializeLocalspl(
    VOID
    )
{
#if DBG
    gpDbgPointers = DbgGetPointers();

    if( gpDbgPointers ){

        hcsSpoolerSection = gpDbgPointers->pfnAllocCritSec();
        SPLASSERT( hcsSpoolerSection );

        ghbtClusterRef = gpDbgPointers->pfnAllocBackTrace();
    }

    if( !hcsSpoolerSection ){

        //
        // Must be using the free version of spoolss.dll.
        //
        InitializeCriticalSection( &SpoolerSection );
    }
#else
    InitializeCriticalSection( &SpoolerSection );
#endif

}

VOID
SplDeleteSpoolerThread(
    PVOID pv
    )
{
    PINIPORT        pIniPort;
    PINIPORT        pIniPortNext;

    PINIMONITOR     pIniMonitor;
    PINIMONITOR     pIniMonitorNext;
    PSHARE_INFO_2   pShareInfo;

    PINISPOOLER pIniSpooler = (PINISPOOLER)pv;

    EnterSplSem();

    //
    // Cleanup the port monitors.
    //
    ShutdownMonitors( pIniSpooler );

    //
    // Close Cluster Access Token
    //
    if (pIniSpooler->hClusterToken != INVALID_HANDLE_VALUE)
        NtClose(pIniSpooler->hClusterToken);


    //
    //  Delete All the Strings
    //

    FreeIniSpoolerOtherNames(pIniSpooler);
    FreeStructurePointers((LPBYTE)pIniSpooler, NULL, IniSpoolerOffsets);

    DeleteShared( pIniSpooler );

    //
    // Run all of the environments down if this isn't the local ini-spoolers
    // environment. This frees up the memory for all of the drivers and also
    // handles the driver ref-counts.
    //
    if (pIniSpooler->pIniEnvironment != pLocalIniSpooler->pIniEnvironment && pIniSpooler->pIniEnvironment) {

        PINIENVIRONMENT pIniEnvironment  = NULL;
        PINIENVIRONMENT pNextEnvironment = NULL;

        for(pIniEnvironment = pIniSpooler->pIniEnvironment; pIniEnvironment; pIniEnvironment = pNextEnvironment) {

            pNextEnvironment = pIniEnvironment->pNext;

            FreeIniEnvironment(pIniEnvironment);
        }
    }

    //
    // Delete ports and monitors.
    //
    // Note that there is no reference counting here.  By the time
    // we get here all jobs and printers should be deleted (otherwise
    // the pIniSpooler reference count would be != 0).  Therefore,
    // even though we don't refcount ports and monitors, we should
    // be ok.
    //

    //
    // Remove all ports.
    //
    for( pIniPort = pIniSpooler->pIniPort;
         pIniPort;
         pIniPort = pIniPortNext ){

        pIniPortNext = pIniPort->pNext;

        if( !DeletePortEntry( pIniPort )){
            DBGMSG( DBG_ERROR,
                    ( "Unable to delete port %ws %x %x %d",
                      pIniPort->pName,
                      pIniPort->hPort,
                      pIniPort->Status,
                      pIniPort->cJobs ));
        }
    }

    //
    // Remove all the monitors.
    //
    for( pIniMonitor = pIniSpooler->pIniMonitor;
         pIniMonitor;
         pIniMonitor = pIniMonitorNext ){

        pIniMonitorNext = pIniMonitor->pNext;

        if( !pIniMonitor->cRef ){

            FreeIniMonitor( pIniMonitor );
        }
    }

    //
    // Close cluster resource key handle.
    //
    if( pIniSpooler->hckRoot ){
        SplRegCloseKey( pIniSpooler->hckRoot, pIniSpooler );
    }

    //
    // Close cluster resource key handle.
    //
    if( pIniSpooler->hckPrinters ){
        SplRegCloseKey( pIniSpooler->hckPrinters, pIniSpooler );
    }

    //
    // Keep a counter of cluster pIniSpoolers.
    //
    if( pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){
        --gcClusterIniSpooler;
    }

    //
    // Free the shared bitmap and shared driver info.
    //
    vDeleteJobIdMap( pIniSpooler->hJobIdMap );

    pShareInfo = (PSHARE_INFO_2)pIniSpooler->pDriversShareInfo;
    FreeSplStr( pShareInfo->shi2_remark );
    FreeSplStr( pShareInfo->shi2_path );

    FreeSplMem( pIniSpooler->pDriversShareInfo );


    LeaveSplSem();

    //
    // Shut down the file pool for this ini-spooler. It should not delete any of
    // the files.
    //
    if (pIniSpooler->hFilePool != INVALID_HANDLE_VALUE) {
        (VOID)DestroyFilePool(pIniSpooler->hFilePool, FALSE);
    }

    // Free this IniSpooler

    FreeSplMem( pIniSpooler );

    DBGMSG( DBG_WARN, ( "SplDeleteSpooler: Refcount 0 %x\n", pIniSpooler ));
}

BOOL
SplDeleteSpooler(
    HANDLE  hSpooler
    )
{
    PINISPOOLER pIniSpooler = (PINISPOOLER) hSpooler;
    BOOL    bReturn = FALSE;
    PINISPOOLER pCurrentIniSpooler = pLocalIniSpooler;

    HANDLE hThread;
    DWORD ThreadId;

    SplInSem();

    //
    // Whoever calls this must have deleted all the object associated with
    // this spooler, ie all printers etc, just make certain
    //

    if( pIniSpooler != pLocalIniSpooler ){

        //
        // Mark us as pending deletion.
        //
        pIniSpooler->SpoolerFlags |= SPL_PENDING_DELETION;

        DBGMSG(DBG_CLUSTER, ("SplDeleteSpooler: Deleting %x\n cRef %u\n", pIniSpooler, pIniSpooler->cRef ));

        //
        // pIniPrinters now acquire a reference to pIniSpooler.
        //
        if( pIniSpooler->cRef == 0 ){

            SPLASSERT( pIniSpooler->pIniPrinter == NULL );

            //( pIniSpooler->pIniPort == NULL ) &&
            //( pIniSpooler->pIniForm == NULL ) &&
            //( pIniSpooler->pIniMonitor == NULL ) &&
            //( pIniSpooler->pIniNetPrint == NULL ) &&
            //( pIniSpooler->pSpool == NULL ))


            //
            // Take this Spooler Off the Linked List if it's on it.
            //

            while (( pCurrentIniSpooler->pIniNextSpooler != NULL ) &&
                   ( pCurrentIniSpooler->pIniNextSpooler != pIniSpooler )) {

                pCurrentIniSpooler = pCurrentIniSpooler->pIniNextSpooler;

            }

            //
            // May not be on the linked list if it was removed earlier by
            // clustering.
            //
            if( pCurrentIniSpooler->pIniNextSpooler ){

                SPLASSERT( pCurrentIniSpooler->pIniNextSpooler == pIniSpooler );
                pCurrentIniSpooler->pIniNextSpooler = pIniSpooler->pIniNextSpooler;
            }

            //
            // Hack for port monitors.
            //
            // Some monitors will call ClosePrinter, which deletes the very
            // last printer and allows the pIniSpooler to be destroyed.
            // Unfortunately, we call back to the monitors to close themselves
            // in the same thread, which the monitor does not support.
            //
            // Create a new thread and shut everything down.
            //
            if (hThread = CreateThread( NULL, 0,
                                        (LPTHREAD_START_ROUTINE)SplDeleteSpoolerThread,
                                        (PVOID)pIniSpooler,
                                        0,
                                        &ThreadId ))
            {
                CloseHandle(hThread);
            }
            else
            {
                //
                // Bug 54840
                //
                // What do we do if we can't create a thread to shut down?
                // Sleep and retry?
                //
                DBGMSG(DBG_ERROR, ("Unable to create SplDeleteSpoolerThread\n"));
            }

            bReturn = TRUE;
        }
    }

    return bReturn;
}

BOOL
SplCloseSpooler(
    HANDLE  hSpooler
)
{
    PINISPOOLER pIniSpooler = (PINISPOOLER) hSpooler;

    EnterSplSem();

    if ((pIniSpooler == NULL) ||
        (pIniSpooler == INVALID_HANDLE_VALUE) ||
        (pIniSpooler == pLocalIniSpooler) ||
        (pIniSpooler->signature != ISP_SIGNATURE) ||
        (pIniSpooler->cRef == 0)) {


        SetLastError( ERROR_INVALID_HANDLE );

        DBGMSG(DBG_WARNING, ("SplCloseSpooler InvalidHandle %x\n", pIniSpooler ));
        LeaveSplSem();
        return FALSE;

    }

    DBGMSG(DBG_TRACE, ("SplCloseSpooler %x %ws cRef %d\n",pIniSpooler,
                                                            pIniSpooler->pMachineName,
                                                            pIniSpooler->cRef-1));

    DECSPOOLERREF( pIniSpooler );

    LeaveSplSem();
    return TRUE;
}

BOOL SplRegCopyTree(
    HKEY hDest,
    HKEY hSrc
    )

/*++
Function Description: Recursives copies every key and value from under hSrc to hDest

Parameters: hDest - destination key
            hSrc  - source key

Return Value: TRUE if successful; FALSE otherwise
--*/

{
    BOOL    bStatus = FALSE;
    DWORD   dwError, dwIndex, cbValueName, cbData, cbKeyName, dwType;
    DWORD   cKeys, cMaxValueNameLen, cMaxValueLen, cMaxKeyNameLen, cValues;

    LPBYTE  lpValueName = NULL, lpData = NULL, lpKeyName = NULL;
    HKEY    hSrcSubKey = NULL, hDestSubKey = NULL;

    //
    // Get the max key name length and value name length and data size for
    // allocating the buffers
    //
    if (dwError = RegQueryInfoKey( hSrc, NULL, NULL, NULL,
                                   &cKeys, &cMaxKeyNameLen, NULL,
                                   &cValues, &cMaxValueNameLen,
                                   &cMaxValueLen, NULL, NULL ))
    {
        SetLastError(dwError);
        goto CleanUp;
    }

    //
    // Adjust for the NULL char
    //
    ++cMaxValueNameLen;
    ++cMaxKeyNameLen;

    //
    // Allocate the buffers
    //
    lpValueName = AllocSplMem( cMaxValueNameLen * sizeof(WCHAR) );
    lpData      = AllocSplMem( cMaxValueLen );
    lpKeyName   = AllocSplMem( cMaxKeyNameLen * sizeof(WCHAR) );

    if (!lpValueName || !lpData || !lpKeyName)
    {
        goto CleanUp;
    }

    //
    // Copy all the values in the current key
    //
    for (dwIndex = 0; dwIndex < cValues; ++dwIndex)
    {
       cbData = cMaxValueLen;
       cbValueName = cMaxValueNameLen;

       //
       // Retrieve the value name and the data
       //
       dwError = RegEnumValue( hSrc, dwIndex, (LPWSTR) lpValueName, &cbValueName,
                               NULL, &dwType, lpData, &cbData );

       if (dwError)
       {
           SetLastError( dwError );
           goto CleanUp;
       }

       //
       // Set the value in the destination
       //
       dwError = RegSetValueEx( hDest, (LPWSTR) lpValueName, 0, dwType,
                                lpData, cbData );

       if (dwError)
       {
           SetLastError( dwError );
           goto CleanUp;
       }
    }

    //
    // Recursively copies all the subkeys
    //
    for (dwIndex = 0; dwIndex < cKeys; ++dwIndex)
    {
        cbKeyName = cMaxKeyNameLen;

        //
        // Retrieve the key name
        //
        dwError = RegEnumKeyEx( hSrc, dwIndex, (LPWSTR) lpKeyName, &cbKeyName,
                                NULL, NULL, NULL, NULL );

        if (dwError)
        {
            SetLastError( dwError );
            goto CleanUp;
        }

        //
        // Open the source subkey
        //
        if (dwError = RegOpenKeyEx( hSrc, (LPWSTR) lpKeyName, 0,
                                    KEY_READ, &hSrcSubKey ))
        {
            SetLastError( dwError );
            goto CleanUp;
        }

        //
        // Create the destination subkey
        //
        if (dwError = RegCreateKeyEx( hDest, (LPWSTR) lpKeyName, 0, NULL,
                                      REG_OPTION_VOLATILE, KEY_ALL_ACCESS,
                                      NULL, &hDestSubKey, NULL ))
        {
            SetLastError( dwError );
            goto CleanUp;
        }

        //
        // Copy the subkey tree
        //
        if (!SplRegCopyTree( hDestSubKey, hSrcSubKey ))
        {
            goto CleanUp;
        }

        //
        // Close the registry handle
        //
        RegCloseKey( hDestSubKey );
        RegCloseKey( hSrcSubKey );

        hDestSubKey = NULL;
        hSrcSubKey = NULL;
    }

    bStatus = TRUE;

CleanUp:

    //
    // Free allocated resources
    //
    if (lpValueName)
    {
        FreeSplMem( lpValueName );
    }
    if (lpData)
    {
        FreeSplMem( lpData );
    }
    if (lpKeyName)
    {
        FreeSplMem( lpKeyName );
    }

    //
    // Close registry handles
    //
    if (hDestSubKey)
    {
        RegCloseKey( hDestSubKey );
    }
    if (hSrcSubKey)
    {
        RegCloseKey( hSrcSubKey );
    }

    return bStatus;
}

VOID
MigratePrinterData()

/*++
Function Description: When the spooler starts up for the first time after upgrade,
                      the printer data is moved from HKLM\Software to HKLM\System

Parameters: None

Return Values: None
--*/

{
    HKEY   hSysPrinters = NULL, hSwPrinters = NULL;

    //
    // Migrate the data only immediately following upgrade
    //
    if (!dwUpgradeFlag)
    {
        return;
    }

    //
    // Open the source and destination keys for the migration
    //
    if (( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        ipszRegSwPrinters,
                        0,
                        KEY_ALL_ACCESS,
                        &hSwPrinters )  == ERROR_SUCCESS) &&

        ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        ipszRegistryPrinters,
                        0,
                        KEY_ALL_ACCESS,
                        &hSysPrinters )  == ERROR_SUCCESS) )
    {
        //
        // Recursively copy the keys and the values from Software to System
        //
        SplRegCopyTree( hSysPrinters, hSwPrinters );
    }

    //
    // Close the registry handles
    //
    if (hSwPrinters)
    {
        RegCloseKey( hSwPrinters );
    }
    if (hSysPrinters)
    {
        RegCloseKey( hSysPrinters );
    }

    //
    // Delete the printers key from the software since it is no longer
    // accessed by the spooler
    //
    RegDeleteKey( HKEY_LOCAL_MACHINE, ipszRegSwPrinters );

    return;
}

NTSTATUS
IsCCSetLinkedtoSoftwareHive (
    PBOOL pbIsLinked
)
/*++
Function Description:
    Checks to see if it is a link between SYSTEM hive and SOFTWARE hive
    Only Nt Apis manage to do this.
Parameters:
    OUT pbIsLinked - TRUE if there is a symbolic link between SYSTEM hive and SOFTWARE hive
Return Values:

--*/
{
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      KeyName;
    HANDLE              KeyHandle;

    *pbIsLinked = FALSE;

    RtlInitUnicodeString(&KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Print\\Printers");

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE | OBJ_OPENLINK,
                                (HANDLE)NULL,
                                NULL
                              );

    //
    // Open CurrentControlSet\\Control\\Print\\Printers key
    //
    Status = NtOpenKey( (PHANDLE)(&KeyHandle),
                        MAXIMUM_ALLOWED,
                        &ObjectAttributes
                      );

    if (NT_SUCCESS(Status))
    {
        ULONG           len;
        UCHAR           ValueBuffer[MAX_PATH];
        UNICODE_STRING  ValueName;
        PKEY_VALUE_FULL_INFORMATION   keyInfo;

        RtlInitUnicodeString( &ValueName, L"SymbolicLinkValue" );

        //
        // Query CurrentControlSet\\Control\\Print\\Printers for SymbolicLinkValue
        //
        Status = NtQueryValueKey(KeyHandle,
                                 &ValueName,
                                 KeyValueFullInformation,
                                 ValueBuffer,
                                 sizeof (ValueBuffer),
                                 &len
                                 );
        if( NT_SUCCESS(Status) ) {

            //
            // It's not enough that the value exists, it should be a REG_LINK value
            //
            keyInfo = ( PKEY_VALUE_FULL_INFORMATION ) ValueBuffer;
            *pbIsLinked = ( keyInfo->Type == REG_LINK );

        }

        NtClose(KeyHandle);
    }

    return Status;
}


DWORD
LinkControlSet (
    LPCTSTR pszRegistryPrinters
)
/*++
Function Description:
    Create a symbolic volatile link from SYSTEM hive to SOFTWARE hive
Parameters:

Return Values: ERROR_SUCCESS if succeeded
--*/
{
    HKEY    hCCSKey;
    DWORD   dwRet;
    BOOL    bIsLinked = FALSE;
    PWCHAR  pszRegistryPrintersFullLink = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Print\\Printers";

    dwRet = IsCCSetLinkedtoSoftwareHive(&bIsLinked);

    //
    // IsCCSetLinkedtoSoftwareHive returns NTSTATUS
    // If the link is not there , IsCCSetLinkedtoSoftwareHive fails with STATUS_OBJECT_NAME_NOT_FOUND
    // That's not an error.
    //
    if( NT_SUCCESS(dwRet) || dwRet == STATUS_OBJECT_NAME_NOT_FOUND ) {

        if (bIsLinked) {

            dwRet = ERROR_SUCCESS;

        }else{

            dwRet = SplDeleteThisKey( HKEY_LOCAL_MACHINE,
                                      NULL,
                                      (LPWSTR)pszRegistryPrinters,
                                      FALSE,
                                      NULL
                                    );

            if( dwRet == ERROR_SUCCESS || dwRet == ERROR_FILE_NOT_FOUND) {

                dwRet = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                        pszRegistryPrinters,
                                        0,
                                        NULL,
                                        REG_OPTION_VOLATILE|REG_OPTION_CREATE_LINK,
                                        KEY_ALL_ACCESS|KEY_CREATE_LINK,
                                        NULL,
                                        &hCCSKey,
                                        NULL);

                if( dwRet == ERROR_SUCCESS )
                {
                    dwRet = RegSetValueEx( hCCSKey,
                                           _T("SymbolicLinkValue"),
                                           0,
                                           REG_LINK,
                                           (CONST BYTE *)pszRegistryPrintersFullLink,
                                           (_tcsclen(pszRegistryPrintersFullLink) * sizeof(WCHAR)));


                    RegCloseKey(hCCSKey);
                }

            }

        }
    }


    return dwRet;
}


DWORD
BackupPrintersToSystemHive(
    LPWSTR pszSwRegistryPrinters
)
/*++
Function Description:
    Because the print registry data location was moved to SOFTWARE hive, we need to create
    a symbolic registry link between the new location and the old one in SYSTEM hive.
    We are doing this for applications that read directly from registry print data and
    rely on the old location.

Parameters:
    pszSwRegistryPrinters - the new printer data location under SOFTWARE hive

Return Values:
    FALSE if the printer keys are not in SOFTWARE hive
    Since this fuction's failure might stop spooler working,
    Control set's cleanup and link failures are not considered fatal.
    Only apps that access printer data directly will fail.
--*/

{
    HKEY   hKey;
    DWORD  dwRet;
    HKEY   hSwPrinters = NULL;

    //
    // Check the existence of pszSwRegistryPrinters
    //
    dwRet = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                            pszSwRegistryPrinters,
                            0,
                            NULL,
                            0,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hSwPrinters,
                            NULL);

    if ( dwRet != ERROR_SUCCESS ) {
        goto End;
    }
    //
    // Create a volatile link between current location in SOFTWARE hive and the old one in SYSTEM hive
    // Because it is volatile, this link must be created after each reboot (every time when spooler starts)
    // A failure at this level is not fatal since spooler doesn't rely on SYSTEM hive location anymore
    //
    dwRet = LinkControlSet(ipszRegistryPrinters);

End:

    if ( hSwPrinters ){

        RegCloseKey( hSwPrinters );
    }

    return dwRet;
}


BOOL
CleanupDeletedPrinters (
    PINISPOOLER pIniSpooler
    )
/*++

Routine Description:

      Deletes the printers in pending deletion for real if they have no more jobs and
      if they are not referenced anymore

Arguments:

    pIniSpooler - not null

Return Value:

    BOOL - ignored

--*/

{
    PINIPRINTER pIniPrinter;
    BOOL    bRet = FALSE;

    if(pIniSpooler) {

        pIniPrinter = pIniSpooler->pIniPrinter;

        while (pIniPrinter) {

                if (pIniPrinter->Status & PRINTER_PENDING_DELETION &&
                    !pIniPrinter->cJobs &&
                    !pIniPrinter->cRef ) {

                    DeletePrinterForReal(pIniPrinter, INIT_TIME);

                    // The link list will have changed underneath us
                    // DeletePrinterForReal leaves the Spooler CS
                    // Lets just loop through again from the beginning

                    pIniPrinter = pIniSpooler->pIniPrinter;

                } else

                    pIniPrinter = pIniPrinter->pNext;
            }

        bRet = TRUE;
    }

    return bRet;
}


HANDLE
SplCreateSpooler(
    LPWSTR  pMachineName,
    DWORD   Level,
    PBYTE   pSpooler,
    LPBYTE  pReserved
)
{
    HANDLE          hReturn = INVALID_HANDLE_VALUE;
    PINISPOOLER     pIniSpooler = NULL;
    PSPOOLER_INFO_2 pSpoolerInfo2 = (PSPOOLER_INFO_2)pSpooler;
    DWORD           i;
    WCHAR           Buffer[MAX_PATH];
    PSHARE_INFO_2   pShareInfo = NULL;
    LONG            Status;
    HANDLE          hToken;
    DWORD           dwRet;

    hToken = RevertToPrinterSelf();

    EnterSplSem();

    //  Validate Parameters

    if ( pMachineName == NULL ) {
        SetLastError( ERROR_INVALID_NAME );
        goto SplCreateDone;
    }

    if( Level == 1 &&
        ( pSpoolerInfo2->SpoolerFlags & SPL_CLUSTER_REG ||
          !pSpoolerInfo2->pszRegistryRoot ||
          !pSpoolerInfo2->pszRegistryPrinters )){

        SetLastError( ERROR_INVALID_PARAMETER );
        goto SplCreateDone;
    }

    DBGMSG( DBG_TRACE, ("SplCreateSpooler %ws %d %x %x\n", pMachineName,
                         Level, pSpooler, pReserved ));

    if( (pSpoolerInfo2->SpoolerFlags & (SPL_TYPE_LOCAL | SPL_PRINT)) &&
        !(pSpoolerInfo2->SpoolerFlags & SPL_TYPE_CLUSTER) ){

        if ( dwRet = (BackupPrintersToSystemHive( pSpoolerInfo2->pszRegistryPrinters )) != ERROR_SUCCESS ){

            WCHAR pwszError[256];
            wsprintf(pwszError,L"%x", dwRet);
            SplLogEvent(pIniSpooler,
                        LOG_ERROR,
                        MSG_BACKUP_SPOOLER_REGISTRY,
                        TRUE,
                        pwszError,
                        NULL);
        }
    }

    if (pLocalIniSpooler != NULL) {

        pIniSpooler = FindSpooler( pMachineName, pSpoolerInfo2->SpoolerFlags );

        if (pSpoolerInfo2->SpoolerFlags & SPL_OPEN_EXISTING_ONLY && !pIniSpooler) {

            SetLastError( ERROR_FILE_NOT_FOUND );
            goto SplCreateDone;
        }
    }

    //
    // Make sure we clear out a request to only open an existing inispooler.
    // This is not a useful flag except for when we are searching for inispoolers.
    //
    pSpoolerInfo2->SpoolerFlags &= ~SPL_OPEN_EXISTING_ONLY;

    if ( pIniSpooler == NULL ) {

        pIniSpooler = AllocSplMem( sizeof(INISPOOLER) );

        if (pIniSpooler == NULL ) {
            DBGMSG( DBG_WARNING, ("Unable to allocate IniSpooler\n"));
            goto SplCreateDone;
        }

        pIniSpooler->signature = ISP_SIGNATURE;
        INCSPOOLERREF( pIniSpooler );

        pIniSpooler->hClusSplReady = NULL;
        //
        // Setup the job id map.
        //
        pIniSpooler->hJobIdMap = hCreateJobIdMap( 256 );

        pIniSpooler->pMachineName = AllocSplStr( pMachineName );

        if ( pIniSpooler->pMachineName == NULL ||
             pIniSpooler->hJobIdMap == NULL ) {

            DBGMSG( DBG_WARNING, ("Unable to allocate\n"));
            goto SplCreateDone;
        }

        //
        // A cluster spooler own its drivers, ports, pprocessors, etc. In order to manage those
        // resources, the cluster spooler needs to have information about the driver letter of
        // the cluster disk. Also the spooler needs to know its own cluster resource GUID
        //
        if( pSpoolerInfo2->SpoolerFlags & SPL_TYPE_CLUSTER )
        {
            Status = ClusterGetResourceDriveLetter(pSpoolerInfo2->pszResource, &pIniSpooler->pszClusResDriveLetter);

            if (Status != ERROR_SUCCESS)
            {
                SetLastError(Status);
                goto SplCreateDone;
            }

            Status = ClusterGetResourceID(pSpoolerInfo2->pszResource, &pIniSpooler->pszClusResID);

            if (Status != ERROR_SUCCESS)
            {
                SetLastError( Status );
                goto SplCreateDone;
            }

            //
            // When a node is upgraded, the resource dll writes a key in the registry. When the cluster spooler
            // fails over for the first time on the node that was upgraded, then it will try to read that key
            // in the registry. Then it will know if it has to do upgrade specific tasks, like upgrading its
            // printer drivers.
            //
            Status = ClusterSplReadUpgradeKey(pIniSpooler->pszClusResID, &pIniSpooler->dwClusNodeUpgraded);

            if (Status != ERROR_SUCCESS)
            {
                SetLastError( Status );
                goto SplCreateDone;
            }

            DBGMSG(DBG_CLUSTER, ("SplCreateSpooler cluster ClusterUpgradeFlag %u\n", pIniSpooler->dwClusNodeUpgraded));
        }
        else
        {
            //
            // For a non cluster type spooler, these properties are meaningless.
            //
            pIniSpooler->pszClusResDriveLetter = NULL;
            pIniSpooler->pszClusResID          = NULL;
        }

        if (pSpoolerInfo2->pDir)
        {
            pIniSpooler->pDir = AllocSplStr( pSpoolerInfo2->pDir );

            if (!pIniSpooler->pDir)
            {
                DBGMSG( DBG_WARNING, ("Unable to allocate pSpoolerInfo2-pDir\n"));
                goto SplCreateDone;
            }

            wcscpy(&Buffer[0], pIniSpooler->pDir);
        }
        else
        {
            i = GetSystemDirectory(Buffer, COUNTOF(Buffer));
            wcscpy(&Buffer[i], szSpoolDirectory);

            if (pSpoolerInfo2->SpoolerFlags & SPL_TYPE_CLUSTER)
            {
                //
                // For a cluster type spooler, the directory where it stores its driver files is of the form:
                // pDir = C:\Windows\system32\spool\Drivers\spooler-resource-GUID
                //
                StrCatAlloc(&pIniSpooler->pDir,
                            Buffer,
                            szDriversDirectory,
                            L"\\",
                            pIniSpooler->pszClusResID,
                            NULL);
            }
            else
            {
                //
                // For the local spooler, the directory where it stores its driver files is the following:
                // pDir = C:\Windows\system32\spool\Drivers
                //
                StrCatAlloc(&pIniSpooler->pDir,
                            Buffer,
                            NULL);
            }

            if (!pIniSpooler->pDir)
            {
                DBGMSG( DBG_WARNING, ("Unable to Allocate pIniSpooler->pDir\n"));
                goto SplCreateDone;
            }
        }

        //
        // DriverShareInfo
        //
        pIniSpooler->pDriversShareInfo = AllocSplMem( sizeof( SHARE_INFO_2));

        if ( pIniSpooler->pDriversShareInfo == NULL ) {
            DBGMSG(DBG_WARNING, ("Unable to Alloc pIniSpooler->pDriversShareInfo\n"));
            goto SplCreateDone;
        }

        pShareInfo = (PSHARE_INFO_2)pIniSpooler->pDriversShareInfo;

        if ( pIniSpooler->pDriversShareInfo == NULL )
            goto SplCreateDone;

        pShareInfo->shi2_netname = NULL;
        pShareInfo->shi2_type = STYPE_DISKTREE;
        pShareInfo->shi2_remark = NULL;
        pShareInfo->shi2_permissions = 0;
        pShareInfo->shi2_max_uses = SHI_USES_UNLIMITED;
        pShareInfo->shi2_current_uses = SHI_USES_UNLIMITED;
        pShareInfo->shi2_path = NULL;
        pShareInfo->shi2_passwd = NULL;

        //
        // Find end of "<winnt>\system32\spool"
        //
        i = wcslen(Buffer);

        //
        // Make <winnt>\system32\spool\drivers
        //
        wcscpy(&Buffer[i], szDriversDirectory);

        pShareInfo->shi2_path = AllocSplStr(Buffer);

        if ( pShareInfo->shi2_path == NULL ) {
            DBGMSG( DBG_WARNING, ("Unable to alloc pShareInfo->shi2_path\n"));
            goto SplCreateDone;
        }

        pShareInfo->shi2_netname = ipszDriversShareName;

        *Buffer = L'\0';
        LoadString(hInst, IDS_PRINTER_DRIVERS, Buffer, (sizeof Buffer / sizeof *Buffer));

        pShareInfo->shi2_remark  = AllocSplStr(Buffer);

        if ( pShareInfo->shi2_remark == NULL ) {
            DBGMSG(DBG_WARNING, ("SplCreateSpooler Unable to allocate\n"));
            goto SplCreateDone;
        }

        pIniSpooler->pIniPrinter = NULL;
        pIniSpooler->pIniEnvironment = NULL;
        pIniSpooler->pIniNetPrint = NULL;

        //
        // No need to initialize shared resources.
        //
        pIniSpooler->pSpool             = NULL;
        pIniSpooler->pDefaultSpoolDir   = NULL;
        pIniSpooler->bEnableRetryPopups = FALSE;
        pIniSpooler->dwRestartJobOnPoolTimeout = DEFAULT_JOB_RESTART_TIMEOUT_ON_POOL_ERROR;
        pIniSpooler->bRestartJobOnPoolEnabled  = TRUE;


        if (( pSpoolerInfo2->pszRegistryMonitors     == NULL ) &&
            ( pSpoolerInfo2->pszRegistryEnvironments == NULL ) &&
            ( pSpoolerInfo2->pszRegistryEventLog     == NULL ) &&
            ( pSpoolerInfo2->pszRegistryProviders    == NULL ) &&
            ( pSpoolerInfo2->pszEventLogMsgFile      == NULL ) &&
            ( pSpoolerInfo2->pszRegistryForms        == NULL ) &&
            ( pSpoolerInfo2->pszDriversShare         == NULL )) {

            DBGMSG( DBG_WARNING, ("SplCreateSpooler Invalid Parameters\n"));
            goto SplCreateDone;
        }

        if( !(  pSpoolerInfo2->SpoolerFlags & SPL_CLUSTER_REG ) &&
            ( pSpoolerInfo2->pszRegistryPrinters == NULL )){

            DBGMSG( DBG_WARNING, ("SplCreateSpooler Invalid RegistryPrinters\n"));
            goto SplCreateDone;
        }

        if ( pSpoolerInfo2->pDefaultSpoolDir != NULL ) {
            pIniSpooler->pDefaultSpoolDir = AllocSplStr( pSpoolerInfo2->pDefaultSpoolDir );

            if ( pIniSpooler->pDefaultSpoolDir == NULL ) {
                DBGMSG(DBG_WARNING, ("SplCreateSpooler Unable to allocate\n"));
                goto SplCreateDone;

            }
        }

        pIniSpooler->pszRegistryMonitors = AllocSplStr( pSpoolerInfo2->pszRegistryMonitors );

        //
        // The spooler stores data about environemnts, versions, drivers and print processors
        // in the regsitry (or cluster data base). This data is accessed via pIniSpooler->
        // pszRegistryEnvironemts
        //
        if (pSpoolerInfo2->SpoolerFlags & SPL_TYPE_CLUSTER)
        {
            //
            // For a cluster spooler pIniSpooler->hckRoot maps to Parameters key of the spooler
            // resource in the cluster database. pIniSpooler->pszRegistryEnvironments is a key
            // called "Environemts" under hckRoot.
            //
            pIniSpooler->pszRegistryEnvironments = AllocSplStr(ipszClusterDatabaseEnvironments);
        }
        else
        {
            //
            // For local spooler pIniSpooler->pszRegistryEnvironments is the following string:
            // System\CurrentControlSet\Control\Print\Environments. It is used relative to HKLM
            //
            pIniSpooler->pszRegistryEnvironments = AllocSplStr(!pLocalIniSpooler ? pSpoolerInfo2->pszRegistryEnvironments :
                                                                                   pLocalIniSpooler->pszRegistryEnvironments);
        }


        pIniSpooler->pszRegistryEventLog     = AllocSplStr( pSpoolerInfo2->pszRegistryEventLog );
        pIniSpooler->pszRegistryProviders    = AllocSplStr( pSpoolerInfo2->pszRegistryProviders );
        pIniSpooler->pszEventLogMsgFile      = AllocSplStr( pSpoolerInfo2->pszEventLogMsgFile );

        if (pSpoolerInfo2->SpoolerFlags & SPL_TYPE_CLUSTER)
        {
            //
            // The driver share for a cluster spooler is of the form \\server\print$\spooler-resource-GUID
            //
            StrCatAlloc(&pIniSpooler->pszDriversShare,
                        pSpoolerInfo2->pszDriversShare,
                        L"\\",
                        pIniSpooler->pszClusResID,
                        szDriversDirectory,
                        NULL);
        }
        else
        {
            //
            // The driver share for the local spooler is \\server\print$
            //
            StrCatAlloc(&pIniSpooler->pszDriversShare, pSpoolerInfo2->pszDriversShare, NULL);
        }

        pIniSpooler->pszRegistryForms        = AllocSplStr( pSpoolerInfo2->pszRegistryForms ) ;
        pIniSpooler->hClusterToken           = INVALID_HANDLE_VALUE;
        pIniSpooler->hFilePool               = INVALID_HANDLE_VALUE;

        if ( pIniSpooler->pszRegistryMonitors     == NULL ||
             pIniSpooler->pszRegistryEnvironments == NULL ||
             pIniSpooler->pszRegistryEventLog     == NULL ||
             pIniSpooler->pszRegistryProviders    == NULL ||
             pIniSpooler->pszEventLogMsgFile      == NULL ||
             pIniSpooler->pszDriversShare         == NULL ||
             pIniSpooler->pszRegistryForms        == NULL ) {

           DBGMSG(DBG_WARNING, ("SplCreateSpooler Unable to allocate\n"));
           goto SplCreateDone;

        }

        pIniSpooler->SpoolerFlags = pSpoolerInfo2->SpoolerFlags;

        //
        // Initialize the shared resources (pShared).
        //
        if( !InitializeShared( pIniSpooler )){
            DBGMSG( DBG_WARN,
                    ( "SplCreateSpooler: InitializeShared Failed %d\n",
                      GetLastError() ));
            goto SplCreateDone;
        }

        //
        // Create the print share if necessary.  This is always needed
        // since the cluster printers are shared, while the local ones
        // on this node aren't.
        //
        if(pIniSpooler->SpoolerFlags & SPL_ALWAYS_CREATE_DRIVER_SHARE ){

            if( !AddPrintShare( pIniSpooler )){
                goto SplCreateDone;
            }
        }

        //
        // Open and store the printer and root key from
        // the resource registry.
        //

        if( pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

            SPLASSERT( Level == 2 );

            // Set up the DS Cluster info.  If we fail here, we can't publish printers, but let's
            // not abort the cluster.
            Status = InitializeDSClusterInfo(pIniSpooler, &hToken);
            if (Status != ERROR_SUCCESS) {
                DBGMSG(DBG_WARNING, ("InitializeDSClusterInfo FAILED: %d\n", Status));
            }

            pIniSpooler->hckRoot = OpenClusterParameterKey(
                                       pSpoolerInfo2->pszResource );

            if( !pIniSpooler->hckRoot ) {
                goto SplCreateDone;
            }

            Status = SplRegCreateKey( pIniSpooler->hckRoot,
                                      szPrintersKey,
                                      0,
                                      KEY_ALL_ACCESS,
                                      NULL,
                                      &pIniSpooler->hckPrinters,
                                      NULL,
                                      pIniSpooler );

            if( Status != ERROR_SUCCESS ){
                SetLastError( Status );
                goto SplCreateDone;
            }

        } else {

            DWORD dwDisposition;

            Status = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                     pSpoolerInfo2->pszRegistryRoot,
                                     0,
                                     NULL,
                                     0,
                                     KEY_ALL_ACCESS,
                                     NULL,
                                     &pIniSpooler->hckRoot,
                                     &dwDisposition );

            if( Status != ERROR_SUCCESS ){
                SetLastError( Status );
                goto SplCreateDone;
            }

            Status = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                     pSpoolerInfo2->pszRegistryPrinters,
                                     0,
                                     NULL,
                                     0,
                                     KEY_ALL_ACCESS,
                                     NULL,
                                     &pIniSpooler->hckPrinters,
                                     &dwDisposition );

            if( Status != ERROR_SUCCESS ){
                SetLastError( Status );
                goto SplCreateDone;
            }

        }


        pIniSpooler->pfnReadRegistryExtra = pSpoolerInfo2->pfnReadRegistryExtra;
        pIniSpooler->pfnWriteRegistryExtra = pSpoolerInfo2->pfnWriteRegistryExtra;
        pIniSpooler->pfnFreePrinterExtra = pSpoolerInfo2->pfnFreePrinterExtra;

        // Success add to Linked List

        if ( pLocalIniSpooler != NULL ) {

            pIniSpooler->pIniNextSpooler = pLocalIniSpooler->pIniNextSpooler;
            pLocalIniSpooler->pIniNextSpooler = pIniSpooler;


        } else {

            // First One is Always LocalSpl

            pLocalIniSpooler = pIniSpooler;
            pIniSpooler->pIniNextSpooler = NULL;


        }

        //
        // This function will update the global varaiable dwUpgradeFlag
        //
        QueryUpgradeFlag( pIniSpooler );

        InitializeEventLogging( pIniSpooler );

        //
        // Only initialize forms if this is not a clustered spooler.
        //
        if( !( pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER )){
            InitializeForms( pIniSpooler );
        }

        //
        // Originally ports were a per-machine (manual) resource.  However,
        // this has changed for clustering in 5.0, so that ports can be
        // stored in the cluster registry.  Note that monitors are still
        // manual resources, since there isn't an easy way to install them
        // on a remote machine.
        //

        BuildAllPorts( pIniSpooler );

        InitializeSpoolerSettings( pIniSpooler );

        if ( pIniSpooler == pLocalIniSpooler ) {

            GetPrintSystemVersion( pIniSpooler );

            BuildEnvironmentInfo( pIniSpooler );

            BuildOtherNamesFromMachineName(&pIniSpooler->ppszOtherNames, &pIniSpooler->cOtherNames);

            if ( dwUpgradeFlag ) {

                //
                // The problem is that we have built-in forms, and
                // custom forms (duplicates disallowed).On NT4, we
                // may have a custom "A6" form.  When we upgrade to NT5,
                // and we have a new built-in from "A6."  We need to
                // rename the custom form to "A6 Custom," otherwise we'll
                // have duplicates.
                //

                UpgradeForms(pIniSpooler);

                //
                //  If we are upgrading from NT 3.1 the drivers need to be
                //  moved to the correct target directory and the registry needs to
                //  be fixed.   Because NT 3.1 didn't have different driver
                //

                Upgrade31DriversRegistryForAllEnvironments( pIniSpooler );
            }


        } else if (pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER) {

            HANDLE hThread;
            DWORD  dwThreadId;
            DWORD  dwError;

            //
            // The setup creates the registry strucutre for the local spooler:
            // Environments {Windows NT x86, Windows IA64, etc}
            // For a cluster spooler we need to create it ourselves in the
            // cluster database
            //
            if ((dwError = CreateClusterSpoolerEnvironmentsStructure(pIniSpooler)) == ERROR_SUCCESS)
            {
                //
                // Create all the environments, versions, drivers, processors strurctres
                // This function always returns FALSE. We cannot take its return value
                // into account.
                //
                BuildEnvironmentInfo(pIniSpooler);

                //
                // Now we launch a thread to do time consuming tasks that can
                // be performed with the spooler on line. These inlude ungrading
                // printer drivers, copying ICM profiles from the cluster disk etc.
                //
                // We need to bump the ref count so that the worker thread has
                // a valid pIniSpooler. The worker thread will decref the pinispooler
                // when it is done
                //
                INCSPOOLERREF(pIniSpooler);

                //
                // The event has manual reset and is not signaled.
                //
                pIniSpooler->hClusSplReady = CreateEvent(NULL, TRUE, FALSE, NULL);

                //
                // If the thread is created, then SplCreateSpoolerWorkerThread will
                // close the hClusSplReady event handle.
                //
                if (pIniSpooler->hClusSplReady &&
                    (hThread = CreateThread(NULL,
                                            0,
                                            (LPTHREAD_START_ROUTINE)SplCreateSpoolerWorkerThread,
                                            (PVOID)pIniSpooler,
                                            0,
                                            &dwThreadId)))
                {
                    CloseHandle(hThread);

                    //
                    // If Level 2 then check for other names.
                    //
                    if (Level == 2)
                    {
                        BuildOtherNamesFromSpoolerInfo2(pSpoolerInfo2, pIniSpooler);
                    }
                }
                else
                {
                    //
                    // Either CreateEvent or CreatreThread failed.
                    //
                    dwError = GetLastError();

                    if (pIniSpooler->hClusSplReady)
                    {
                        CloseHandle(pIniSpooler->hClusSplReady);

                        pIniSpooler->hClusSplReady = NULL;
                    }

                    DECSPOOLERREF(pIniSpooler);

                    DBGMSG(DBG_ERROR, ("Unable to create SplCreateSpoolerWorkerThread\n"));
                }
            }

            //
            //  An error occured
            //
            if (dwError != ERROR_SUCCESS)
            {
                SetLastError(dwError);
                goto SplCreateDone;
            }
        }
        else
        {
            //
            // This is the case of a network spooler. You get one of those when
            // you make a true printer connection
            //
            pIniSpooler->pIniEnvironment = pLocalIniSpooler->pIniEnvironment;

            //
            // If Level 2 then check for other names.
            //
            if( Level == 2 )
                BuildOtherNamesFromSpoolerInfo2( pSpoolerInfo2, pIniSpooler );
        }

        //
        // Read Printer Info from Registry (cluster databse for cluster spooler)
        // There's no cleanup in any of this code--it doesn't free any allocated memory!
        //
        if( !BuildPrinterInfo( pIniSpooler, (BOOL) dwUpgradeFlag )){
            goto SplCreateDone;
        }

        if( pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){

            //
            // Keep a counter of pIniSpoolers.
            //
            ++gcClusterIniSpooler;
        }

        //
        // We need to perform some costly initialization, so we increase the refcount
        // on the pIniSpooler and will do the lengthy operations outside the global
        // critical section
        //
        INCSPOOLERREF(pIniSpooler);
        LeaveSplSem();

        //
        // GetDNSMachineName may fail, but that's okay.  Just don't be surprised
        // if pszFullMachineName is NULL.
        //
        GetDNSMachineName(pIniSpooler->pMachineName + 2, &pIniSpooler->pszFullMachineName);

        EnterSplSem();
        DECSPOOLERREF(pIniSpooler);

    } else {

        INCSPOOLERREF( pIniSpooler );

    }

    //
    // Initialize the DS.
    //
    if (pIniSpooler->SpoolerFlags & SPL_PRINT) {
        InitializeDS(pIniSpooler);
    }

    hReturn = (HANDLE)pIniSpooler;

SplCreateDone:

    //
    // Check if an error occurred while creating the spooler.
    //
    if (hReturn == INVALID_HANDLE_VALUE && pIniSpooler)
    {
        //
        // This will prevent leaking allocated fields
        //
        DECSPOOLERREF(pIniSpooler);
    }

    LeaveSplSem();

    if ( !pIniSpooler )
    {
        if (!(pSpoolerInfo2->SpoolerFlags & SPL_OPEN_EXISTING_ONLY))
        {
            SplLogEvent(
                NULL,
                LOG_ERROR,
                MSG_INIT_FAILED,
                FALSE,
                L"Spooler",
                L"SplCreateSpooler",
                L"Unknown Error",
                NULL
                );
        }
    }

    ImpersonatePrinterClient(hToken);

    //
    // Set the event that the cluster spooler is initialized
    //
    if (pIniSpooler &&
        pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER &&
        pIniSpooler->hClusSplReady)
    {
        SetEvent(pIniSpooler->hClusSplReady);
    }

    return hReturn;
}



BOOL
InitializePrintProvidor(
   LPPRINTPROVIDOR pPrintProvidor,
   DWORD    cbPrintProvidor,
   LPWSTR   pFullRegistryPath
)
{
   HANDLE hSchedulerThread;
   HANDLE hFinalInitAfterRouterInitCompleteThread;
   DWORD  ThreadId;
   BOOL  bSucceeded = TRUE;
   WCHAR Buffer[MAX_PATH];
   DWORD i;
   PINISPOOLER pIniSpooler = NULL;
   LPWSTR   pMachineName = NULL;
   SPOOLER_INFO_1 SpoolerInfo1;
   BOOL     bInSem = FALSE;

 try {

    if (!InitializeWinSpoolDrv())
        leave;

    //
    //  Make sure sizes of structres are good
    //

    SPLASSERT( sizeof( PRINTER_INFO_STRESSW ) == sizeof ( PRINTER_INFO_STRESSA ) );


    // !! LATER !!
    // We could change this to succeed even on failure
    // if we point all the routines to a function which returns failure
    //

    if (!InitializeNet())
        leave;

    //
    // JobIdMap initialized when spooler created.
    //

    //
    // Allocate LocalSpl Global IniSpooler
    //

    Buffer[0] = Buffer[1] = L'\\';
    i = MAX_PATH-2;
    OsVersionInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if ( !GetComputerName(Buffer+2, &i) ||
         !GetVersionEx((POSVERSIONINFO)&OsVersionInfoEx) ||
         !GetVersionEx(&OsVersionInfo)) {

        DBGMSG(DBG_WARNING, ("GetComputerName/OSVersionInfo failed.\n"));
        leave;
    }

    pMachineName = AllocSplStr(Buffer);
    if ( pMachineName == NULL )
        leave;

    SpoolerInfo1.pszDriversShare = AllocSplStr(ipszDriversShareName);    /* print$ */
    if ( SpoolerInfo1.pszDriversShare == NULL )
        leave;

    // Use Defaults

    SpoolerInfo1.pDir                    = NULL;
    SpoolerInfo1.pDefaultSpoolDir        = NULL;

    SpoolerInfo1.pszRegistryRoot         = ipszRegistryRoot;
    SpoolerInfo1.pszRegistryPrinters     = ipszRegSwPrinters;
    SpoolerInfo1.pszRegistryMonitors     = ipszRegistryMonitorsHKLM;
    SpoolerInfo1.pszRegistryEnvironments = ipszRegistryEnvironments;
    SpoolerInfo1.pszRegistryEventLog     = ipszRegistryEventLog;
    SpoolerInfo1.pszRegistryProviders    = ipszRegistryProviders;
    SpoolerInfo1.pszEventLogMsgFile      = ipszEventLogMsgFile;
    SpoolerInfo1.pszRegistryForms        = ipszRegistryForms;

    SpoolerInfo1.SpoolerFlags = SPL_UPDATE_WININI_DEVICES                 |
                                SPL_PRINTER_CHANGES                       |
                                SPL_LOG_EVENTS                            |
                                SPL_FORMS_CHANGE                          |
                                SPL_BROADCAST_CHANGE                      |
                                SPL_SECURITY_CHECK                        |
                                SPL_OPEN_CREATE_PORTS                     |
                                SPL_FAIL_OPEN_PRINTERS_PENDING_DELETION   |
                                SPL_REMOTE_HANDLE_CHECK                   |
                                SPL_PRINTER_DRIVER_EVENT                  |
                                SPL_SERVER_THREAD                         |
                                SPL_PRINT                                 |
                                SPL_TYPE_LOCAL;

    SpoolerInfo1.pfnReadRegistryExtra    = NULL;
    SpoolerInfo1.pfnWriteRegistryExtra   = NULL;
    SpoolerInfo1.pfnFreePrinterExtra     = NULL;

    pLocalIniSpooler = SplCreateSpooler( pMachineName,
                                         1,
                                         (PBYTE)&SpoolerInfo1,
                                         NULL );


    if ( pLocalIniSpooler == INVALID_HANDLE_VALUE ) {
        DBGMSG( DBG_WARNING, ("InitializePrintProvidor  Unable to allocate pLocalIniSpooler\n"));
        leave;
    }

    pIniSpooler = pLocalIniSpooler;

#if DBG
    InitializeDebug( pIniSpooler );
#endif

    // !! LATER !!
    // Why is this done inside critical section ?


   EnterSplSem();
    bInSem = TRUE;

    if (!LoadString(hInst, IDS_REMOTE_DOC, Buffer, MAX_PATH))
        leave;

    szRemoteDoc = AllocSplStr( Buffer );
    if ( szRemoteDoc == NULL )
        leave;

    if (!LoadString(hInst, IDS_LOCAL_DOC, Buffer, MAX_PATH))
        leave;

    szLocalDoc = AllocSplStr( Buffer );
    if ( szLocalDoc == NULL )
        leave;

    if (!LoadString(hInst, IDS_FASTPRINT_TIMEOUT, Buffer, MAX_PATH))
        leave;

    szFastPrintTimeout = AllocSplStr( Buffer );
    if ( szFastPrintTimeout == NULL )
        leave;

    if (!InitializeSecurityStructures())
        leave;

    SchedulerSignal  = CreateEvent( NULL,
                                    EVENT_RESET_AUTOMATIC,
                                    EVENT_INITIAL_STATE_NOT_SIGNALED,
                                    NULL );

    PowerManagementSignal = CreateEvent(NULL,
                                        EVENT_RESET_MANUAL,
                                        EVENT_INITIAL_STATE_SIGNALED,
                                        NULL);

    hSchedulerThread = CreateThread( NULL,
                                     INITIAL_STACK_COMMIT,
                                     (LPTHREAD_START_ROUTINE)SchedulerThread,
                                     pIniSpooler, 0, &ThreadId );

    hFinalInitAfterRouterInitCompleteThread = CreateThread( NULL, INITIAL_STACK_COMMIT,
                                      (LPTHREAD_START_ROUTINE)FinalInitAfterRouterInitCompleteThread,
                                      (LPVOID)ULongToPtr(dwUpgradeFlag), 0, &ThreadId );


    if (!SchedulerSignal || !PowerManagementSignal || !hSchedulerThread || !hFinalInitAfterRouterInitCompleteThread) {

       DBGMSG( DBG_WARNING, ("Scheduler/FinalInitAfterRouterInitCompleteThread not initialised properly: Error %d\n", GetLastError()));
       leave;
    }

    if ( !SetThreadPriority( hSchedulerThread, dwSchedulerThreadPriority ) ) {

        DBGMSG( DBG_WARNING, ("Setting Scheduler thread priority failed %d\n", GetLastError()));
    }


    CloseHandle( hSchedulerThread );
    CloseHandle( hFinalInitAfterRouterInitCompleteThread );

    //
    // Read online/offline status for local printers from current config
    //
    SplConfigChange();

    CHECK_SCHEDULER();

    CopyMemory( pPrintProvidor, &PrintProvidor, min(sizeof(PRINTPROVIDOR), cbPrintProvidor));

   LeaveSplSem();
    bInSem = FALSE;

    CloseProfileUserMapping(); // !!! We should be able to get rid of this

    if (!dwUpgradeFlag) {
        // Setup Internet Printing if WWW service is available on this machine.
        InstallWebPrnSvc (pIniSpooler);
    }

    //
    // Get the default value for DefaultKMPrintersAreBlocked. It depends
    // what type of OS is running. If we cannot identify the type of OS,
    // the default is set to "blocked"
    //
    DefaultKMPrintersAreBlocked = GetDefaultForKMPrintersBlockedPolicy();

    gdwServerInstallTimeOut = GetServerInstallTimeOut();

    Initialized = TRUE;


 } finally {

    if ( bInSem ) {
       LeaveSplSem();
    }

 }

    SplOutSem();

    return Initialized;
}


PINIPORT
CreatePortEntry(
    LPWSTR      pPortName,
    PINIMONITOR pIniMonitor,
    PINISPOOLER pIniSpooler
)
{
    DWORD       cb;
    PINIPORT    pIniPort            =   NULL;
    HANDLE      hPort               =   NULL;
    HANDLE      hWaitToOpenOrClose  =   NULL;
    BOOL        bPlaceHolder        =   FALSE;

    //
    // This is a placeholder if there is no monitor and later if there is no
    // partial print provider.
    //
    bPlaceHolder = pIniMonitor == NULL;

    SplInSem();

    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );

    if (!pPortName || !*pPortName || wcslen(pPortName) >= MAX_PATH) {

        SetLastError(ERROR_UNKNOWN_PORT);
        return NULL;
    }

    if (!pIniMonitor) {

        /* Don't bother validating the port if we aren't initialised.
         * It must be valid, since we wrote it in the registry.
         * This fixes the problem of attempting to open a network
         * printer before the redirector has initialised,
         * and the problem of access denied because we're currently
         * in the system's context.
         */
        if (Initialized) {

            //
            // !! Warning !!
            //
            // Watch for deadlock:
            //
            // spoolss!OpenPrinterPortW  -> RPC to self printer port
            // localspl!CreatePortEntry
            // localspl!ValidatePortTokenList
            // localspl!SetPrinterPorts
            // localspl!LocalSetPrinter
            // spoolss!SetPrinterW
            // spoolss!RpcSetPrinter
            // spoolss!winspool_RpcSetPrinter
            //

            //
            // If we can't open the port then fail the call since this
            // spooler did not know this name before.
            //

            LeaveSplSem();
            if ( !OpenPrinterPortW(pPortName, &hPort, NULL) ){
                EnterSplSem();
                goto Cleanup;
            }
            else {

                bPlaceHolder = FALSE;
                ClosePrinter(hPort);
            }

            EnterSplSem();
        }
    }

    cb = sizeof(INIPORT) + wcslen(pPortName)*sizeof(WCHAR) + sizeof(WCHAR);

    hWaitToOpenOrClose = CreateEvent(NULL, FALSE, TRUE, NULL);
    if ( !hWaitToOpenOrClose )
        goto Cleanup;

    if (pIniPort=AllocSplMem(cb)) {

        pIniPort->pName = wcscpy((LPWSTR)(pIniPort+1), pPortName);
        pIniPort->signature = IPO_SIGNATURE;
        pIniPort->pIniMonitor = pIniMonitor;
        pIniPort->IdleTime = GetTickCount() - 1;
        pIniPort->bIdleTimeValid = FALSE;
        pIniPort->ErrorTime = 0;
        pIniPort->hErrorEvent = NULL;
        pIniPort->InCriticalSection = 0;

        if (pIniMonitor) {
            pIniPort->Status |= PP_MONITOR;
        }

        if (bPlaceHolder) {
            pIniPort->Status |= PP_PLACEHOLDER;
        }

        pIniPort->hWaitToOpenOrClose = hWaitToOpenOrClose;

        LinkPortToSpooler( pIniPort, pIniSpooler );
    }

Cleanup:

    if ( !pIniPort && hWaitToOpenOrClose )
        CloseHandle(hWaitToOpenOrClose);

    return pIniPort;
}

BOOL
DeletePortEntry(
    PINIPORT    pIniPort
    )

/*++

Routine Description:

    Free pIniPort resources then delete it.  If the pIniPort is on
    a pIniSpooler's linked list, remove it too.

Arguments:

    pIniPort - Port to delete.  May or may not be on a pIniSpooler.

Return Value:

    TRUE - deleted
    FALSE - not deleted (may be in use).

--*/

{
    PINISPOOLER pIniSpooler;

    SplInSem();

    SPLASSERT ( ( pIniPort != NULL) || ( pIniPort->signature == IPO_SIGNATURE) );

    //
    // We had better already closed the port monitor.
    //
    SPLASSERT( !pIniPort->hPort &&
               !(pIniPort->Status & PP_THREADRUNNING) &&
               !pIniPort->cJobs);

    if (pIniPort->cRef) {
        pIniPort->Status |= PP_DELETING;
        return FALSE;
    }

    pIniSpooler = pIniPort->pIniSpooler;

    //
    // If currently linked to a pIniSpooler, delink it.
    //
    if( pIniSpooler ){

        SPLASSERT( pIniSpooler->signature ==  ISP_SIGNATURE );

        DelinkPortFromSpooler( pIniPort, pIniSpooler );
    }

    if (pIniPort->ppIniPrinter)
        FreeSplMem(pIniPort->ppIniPrinter);

    CloseHandle(pIniPort->hWaitToOpenOrClose);

    FreeSplMem(pIniPort);

    return TRUE;
}

VOID
FreeIniMonitor(
    PINIMONITOR pIniMonitor
    )
{
    if( pIniMonitor ){

        FreeSplStr( pIniMonitor->pMonitorDll );

        if( pIniMonitor->hModule ){
            FreeLibrary( pIniMonitor->hModule );
        }

        if( pIniMonitor->pMonitorInit ){

            FreeSplStr( (LPWSTR)pIniMonitor->pMonitorInit->pszServerName );

            if( pIniMonitor->pMonitorInit->hckRegistryRoot ){
                SplRegCloseKey( pIniMonitor->pMonitorInit->hckRegistryRoot,
                                pIniMonitor->pIniSpooler );
            }

            FreeSplMem( pIniMonitor->pMonitorInit );
        }

        FreeSplMem( pIniMonitor );
    }
}

#ifdef _SPL_CLUST
LPMONITOR2
InitializePrintMonitor2(
    PMONITORINIT pMonitorInit,
    PHANDLE phMonitor
    )
{
    return(LocalMonInitializePrintMonitor2(pMonitorInit,phMonitor));
}
#endif

PINIMONITOR
CreateMonitorEntry(
    LPWSTR   pMonitorDll,
    LPWSTR   pMonitorName,
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

Arguments:

Return Value:

    Valid pIniMonitor - This means everything worked out fine.

    NULL - This means the monitor DLL was found, but the initialisation routine
           returned FALSE.  This is non-fatal, as the monitor may need the
           system to reboot before it can run properly.

    -1 - This means the monitor DLL or the initialization routine was not found.

--*/

{
    WCHAR       szRegistryRoot[MAX_PATH];
    DWORD       cb, cbNeeded, cReturned, dwRetVal;
    PPORT_INFO_1 pPorts, pPort;
    PINIMONITOR pIniMonitor;
    UINT        uOldErrMode;
    PMONITOR2 (*pfnInitializePrintMonitor2)(PMONITORINIT, PHANDLE) = NULL;
    PINIMONITOR pReturnValue = (PINIMONITOR)-1;

    HANDLE hKeyOut;
    LPWSTR pszPathOut;

    SPLASSERT( (pIniSpooler != NULL) || (pIniSpooler->signature == ISP_SIGNATURE));
    SplInSem();

    cb = sizeof(INIMONITOR) + wcslen(pMonitorName)*sizeof(WCHAR) + sizeof(WCHAR);
    pIniMonitor = AllocSplMem(cb);

    if( !pIniMonitor ){
        goto Fail;
    }

    pIniMonitor->pName = wcscpy((LPWSTR)(pIniMonitor+1), pMonitorName);
    pIniMonitor->signature = IMO_SIGNATURE;
    pIniMonitor->pMonitorDll = AllocSplStr(pMonitorDll);

    pIniMonitor->pIniSpooler = pIniSpooler;

    if( !pIniMonitor->pMonitorDll ){
        goto Fail;
    }

    //
    // Load the library, but don't show any hard error popups if it's an
    // invalid binary.
    //
    INCSPOOLERREF( pIniSpooler );
    LeaveSplSem();
    uOldErrMode = SetErrorMode( SEM_FAILCRITICALERRORS );
    pIniMonitor->hModule = LoadLibrary(pMonitorDll);
    SetErrorMode( uOldErrMode );
    EnterSplSem();
    DECSPOOLERREF( pIniSpooler );

    if (!pIniMonitor->hModule) {

        DBGMSG(DBG_WARNING, ("CreateMonitorEntry( %ws, %ws ) LoadLibrary failed %d\n",
                             pMonitorDll ? pMonitorDll : L"(NULL)",
                             pMonitorName ? pMonitorName : L"(NULL)",
                             GetLastError()));
        goto Fail;
    }

    GetRegistryLocation( pIniSpooler->hckRoot,
                         pIniSpooler->pszRegistryMonitors,
                         &hKeyOut,
                         &pszPathOut );


    dwRetVal = StrNCatBuff( szRegistryRoot,
                            COUNTOF(szRegistryRoot),
                            pszPathOut,
                            L"\\",
                            pMonitorName,
                            NULL );

    if (dwRetVal != ERROR_SUCCESS)
    {
        SetLastError(ERROR_INVALID_PRINT_MONITOR);
        goto Fail;
    }
    //
    // Try calling the entry points in the following order:
    //     InitializePrintMonitor2 (used for clustering),
    //     InitializePrintMonitor,
    //     InitializeMonitorEx,
    //     InitializeMonitor
    //

    (FARPROC)pfnInitializePrintMonitor2 = GetProcAddress(
                                              pIniMonitor->hModule,
                                              "InitializePrintMonitor2" );

    if( !pfnInitializePrintMonitor2 ){

        //
        // If this is clustered spooler, then only InitializePrintMonitor2
        // monitors are supported.
        //
        if( pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){
            goto Fail;
        }

        //
        // Add the parth to the Monitor name here.
        //

        pReturnValue = InitializeDMonitor( pIniMonitor,
                                           szRegistryRoot );

        if( pReturnValue == NULL ||
            pReturnValue == (PINIMONITOR)-1 ){

            goto Fail;
        }

    } else {

        PMONITORINIT pMonitorInit;
        DWORD Status;
        PMONITOR2 pMonitor2 = NULL;

        INCSPOOLERREF( pIniSpooler );
        LeaveSplSem();

        //
        // kKeyOut must either be not HKLM, or it must not be a cluster.
        // If it is both a cluster and also uses HKLM, then we have an error.
        // This should never happen because only win32spl uses an absolute
        // path.
        //
        SPLASSERT( (hKeyOut != HKEY_LOCAL_MACHINE) ||
                   !(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ));

        pMonitorInit = (PMONITORINIT)AllocSplMem( sizeof( MONITORINIT ));

        if( !pMonitorInit ){
            goto FailOutsideSem;
        }

        pMonitorInit->pszServerName = AllocSplStr( pIniSpooler->pMachineName );

        if( !pMonitorInit->pszServerName ){
            goto FailOutsideSem;
        }

        pMonitorInit->cbSize = sizeof( MONITORINIT );
        pMonitorInit->hSpooler = (HANDLE)pIniSpooler;
        pMonitorInit->pMonitorReg = &gMonitorReg;
        pMonitorInit->bLocal = ( pIniSpooler == pLocalIniSpooler );

        pIniMonitor->pMonitorInit = pMonitorInit;

        Status = SplRegCreateKey( hKeyOut,
                                  szRegistryRoot,
                                  0,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &pMonitorInit->hckRegistryRoot,
                                  NULL,
                                  pIniSpooler );
        //
        // If we can't create the hck root key, then fail
        // the call.  We should log an event here too.
        //
        if( Status == ERROR_SUCCESS ){

            pMonitor2 = (*pfnInitializePrintMonitor2)(
                            pMonitorInit,
                            &pIniMonitor->hMonitor );

            if( pMonitor2 ){

                DBGMSG( DBG_TRACE,
                        ( "CreateMonitorEntry: opened %x %x on %x\n",
                          pIniMonitor, pIniMonitor->hMonitor, pIniSpooler ));

                //
                // Succeeded, copy over the pMonitor2 structure into
                // pIniMonitor->Monitor2.
                //
                CopyMemory((LPBYTE)&pIniMonitor->Monitor2,
                           (LPBYTE)pMonitor2,
                           min(pMonitor2->cbSize, sizeof(MONITOR2)));

                //
                // Check if the monitor2 supports Shutdown.
                //
                // Raid#: 193150 - Accept any size Monitor2 as long as it supports Shutdown
                //
                if( !pIniMonitor->Monitor2.pfnShutdown ){

                    DBGMSG( DBG_ERROR,
                            ( "Invalid print monitor %ws (no shutdown)\n",
                              pMonitorName ));
                    SetLastError(ERROR_INVALID_PRINT_MONITOR);
                    DECSPOOLERREF( pIniSpooler );
                    goto FailOutsideSem;
                }

                //
                // Initialize an uplevel monitor for downlevel support.
                //
                InitializeUMonitor( pIniMonitor );

            } else {

                DBGMSG( DBG_WARN,
                        ( "CreateMonitorEntry: InitializePrintMonitor2 failed %d\n",
                          GetLastError() ));
            }

        } else {

            DBGMSG( DBG_WARN,
                    ( "CreateMonitorEntry: Unable to create hckRoot "TSTR"\n",
                      pMonitorName ));
        }

        EnterSplSem();
        DECSPOOLERREF( pIniSpooler );

        if( !pMonitor2 ){
            goto Fail;
        }

        pIniMonitor->bUplevel = TRUE;
    }

    //
    // Check if the monitor supports essential functions
    //
    if ( (!pIniMonitor->Monitor2.pfnOpenPort &&
          !pIniMonitor->Monitor2.pfnOpenPortEx)   ||
         !pIniMonitor->Monitor2.pfnClosePort      ||
         !pIniMonitor->Monitor2.pfnStartDocPort   ||
         !pIniMonitor->Monitor2.pfnWritePort      ||
         !pIniMonitor->Monitor2.pfnReadPort       ||
         !pIniMonitor->Monitor2.pfnEndDocPort ) {

        DBGMSG(DBG_ERROR, ("Invalid print monitor %ws\n", pMonitorName));
        SetLastError(ERROR_INVALID_PRINT_MONITOR);

        goto Fail;
    }

    if (FindMonitor(pMonitorName, pIniSpooler)) {

        SetLastError(ERROR_PRINT_MONITOR_ALREADY_INSTALLED);
        goto Fail;
    }


    if ((pIniMonitor->Monitor2.pfnEnumPorts) &&
        !(*pIniMonitor->Monitor2.pfnEnumPorts)(
              pIniMonitor->hMonitor,
              NULL,
              1,
              NULL,
              0,
              &cbNeeded,
              &cReturned)) {

        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            if (pPorts = AllocSplMem(cbNeeded)) {
                pPort = pPorts;
                if ((*pIniMonitor->Monitor2.pfnEnumPorts)(
                         pIniMonitor->hMonitor,
                         NULL,
                         1,
                         (LPBYTE)pPorts,
                         cbNeeded,
                         &cbNeeded,
                         &cReturned)) {

                    while (cReturned--) {
                        CreatePortEntry(pPort->pName,
                                        pIniMonitor,
                                        pIniSpooler);
                        pPort++;
                    }
                }
                FreeSplMem(pPorts);
            }
        }
    }

    DBGMSG(DBG_TRACE, ("CreateMonitorEntry( %ws, %ws, %ws ) returning %x\n",
                       pMonitorDll ? pMonitorDll : L"(NULL)",
                       pMonitorName ? pMonitorName : L"(NULL)",
                       szRegistryRoot, pIniMonitor));

    SplInSem();

    //
    // Success, link it up.
    //

    pIniMonitor->pNext = pIniSpooler->pIniMonitor;
    pIniSpooler->pIniMonitor = pIniMonitor;

    return pIniMonitor;

FailOutsideSem:

    EnterSplSem();

Fail:

    FreeIniMonitor( pIniMonitor );

    return pReturnValue;
}

BOOL
BuildAllPorts(
    PINISPOOLER     pIniSpooler
)
{
    DWORD   cchData, cbDll, cMonitors;
    WCHAR   Dll[MAX_PATH];
    WCHAR   MonitorName[MAX_PATH];
    WCHAR   RegistryPath[MAX_PATH];
    HKEY    hKey, hKey1, hKeyOut;
    LPWSTR  pszPathOut;
    LONG    Status;
    PINIMONITOR pReturnValue = (PINIMONITOR)-1;

    PINISPOOLER pIniSpoolerMonitor;

    //
    // For pLocalIniSpooler or clustered spooler, read the monitors out
    // of HKLM (the same monitors used in pLocalIniMonitor).  This is because
    // you install a monitor for each node, then that monitor is initialized
    // for the local spooler and all clustered spoolers.
    //
    // You install monitors on the node, not on specific cluster groups.
    //
    if( pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL ){
        pIniSpoolerMonitor = pLocalIniSpooler;
    } else {
        pIniSpoolerMonitor = pIniSpooler;
    }

    GetRegistryLocation( pIniSpoolerMonitor->hckRoot,
                         pIniSpooler->pszRegistryMonitors,
                         &hKeyOut,
                         &pszPathOut );

    Status = RegOpenKeyEx( hKeyOut,
                           pszPathOut,
                           0,
                           KEY_READ,
                           &hKey);

    if (Status != ERROR_SUCCESS)
        return FALSE;

    cMonitors=0;
    cchData = COUNTOF( MonitorName );

    while (RegEnumKeyEx(hKey, cMonitors, MonitorName, &cchData, NULL, NULL,
                        NULL, NULL) == ERROR_SUCCESS) {

        DBGMSG(DBG_TRACE, ("Found monitor %ws\n", MonitorName));

        if (RegOpenKeyEx(hKey, MonitorName, 0, KEY_READ, &hKey1)
                                                        == ERROR_SUCCESS) {

            cbDll = sizeof(Dll);

            if (RegQueryValueEx(hKey1, L"Driver", NULL, NULL,
                                (LPBYTE)Dll, &cbDll)
                                                        == ERROR_SUCCESS) {

                CreateMonitorEntry(Dll, MonitorName, pIniSpooler);
            }

            RegCloseKey(hKey1);
        }

        cMonitors++;
        cchData = COUNTOF( MonitorName );
    }

    RegCloseKey(hKey);

    return TRUE;
}

/*
   Current Directory == <NT directory>\system32\spool\printers
   pFindFileData->cFileName == 0
*/

BOOL
BuildPrinterInfo(
    PINISPOOLER pIniSpooler,
    BOOL        UpdateChangeID
)
{
    WCHAR   PrinterName[MAX_PRINTER_NAME];
    WCHAR   szData[MAX_PATH];
    WCHAR   szDefaultPrinterDirectory[MAX_PATH];
    DWORD   cbData, i;
    DWORD   cbSecurity, dwLastError;
    DWORD   cPrinters, Type;
    HKEY    hPrinterKey;
    PINIPRINTER pIniPrinter;
    PINIPORT    pIniPort;
    LONG        Status;
    SECURITY_ATTRIBUTES SecurityAttributes;
    PKEYDATA    pKeyData                    = NULL;
    BOOL    bUpdateRegistryForThisPrinter   = UpdateChangeID;
    BOOL    bWriteDirectory                 = FALSE;
    BOOL    bAllocMem                       = FALSE;
    BOOL    bNoPorts                        = FALSE;
    LPWSTR  szPortData;


    //
    // Has user specified Default Spool Directory ?
    //

    cbData = sizeof( szData );
    *szData = (WCHAR)0;

    Status = SplRegQueryValue( pIniSpooler->hckPrinters,
                               SPLREG_DEFAULT_SPOOL_DIRECTORY,
                               NULL,
                               (LPBYTE)szData,
                               &cbData,
                               pIniSpooler );

    if (Status == ERROR_SUCCESS) {  // found a value, so verify the directory
        if (!(pIniSpooler->pDefaultSpoolDir = AllocSplStr( szData )))   // Copies szData to pDefaultSpoolDir
            return FALSE;
    } else {
        bWriteDirectory = TRUE;     // No registry directory, so create one
    }

    // Copy pDefaultSpoolDir to szDefaultPrinterDirectory
    GetPrinterDirectory(NULL, FALSE, szDefaultPrinterDirectory, COUNTOF(szDefaultPrinterDirectory), pIniSpooler);

    if (!pIniSpooler->pDefaultSpoolDir)
        return FALSE;


    // Create the directory with the proper security, or fail trying

    SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    SecurityAttributes.lpSecurityDescriptor = CreateEverybodySecurityDescriptor();
    SecurityAttributes.bInheritHandle = FALSE;

    //
    // CreateDirectory limits the length of a directory to 248 (MAX_PATH-12)
    // characters. By calculating the length, we ensure that an escape sequence
    // will not lead to the creation of a directory with a name longer than 248
    //
    if (wcslen(szDefaultPrinterDirectory) > MAX_PATH - 12 ||
        !CreateDirectory(szDefaultPrinterDirectory, &SecurityAttributes)) {

        // Failed to create the directory? Back to factory default

        bWriteDirectory = TRUE;

        if (GetLastError() != ERROR_ALREADY_EXISTS) {

            //
            // In the clustered case, just fail.
            //
            if( pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){
                return FALSE;
            }

            DBGMSG(DBG_WARNING, ("Failed to create DefaultSpoolDirectory %ws\n", szDefaultPrinterDirectory));
            FreeSplStr(pIniSpooler->pDefaultSpoolDir);

            pIniSpooler->pDefaultSpoolDir = NULL;     // This tells GetPrinterDirectory to alloc pDefaultSpoolDir
            GetPrinterDirectory(NULL, FALSE, szDefaultPrinterDirectory, COUNTOF(szDefaultPrinterDirectory), pIniSpooler);

            if (!pIniSpooler->pDefaultSpoolDir)
                return FALSE;

            Status = CreateDirectory(szDefaultPrinterDirectory, &SecurityAttributes);

            if (Status != ERROR_SUCCESS && Status != ERROR_ALREADY_EXISTS) {
                DBGMSG(DBG_WARNING, ("Failed to create DefaultSpoolDirectory %ws\n", szDefaultPrinterDirectory));
                FreeSplStr(pIniSpooler->pDefaultSpoolDir);
                pIniSpooler->pDefaultSpoolDir = NULL;
                return FALSE;
            }
        }
    }

    LocalFree(SecurityAttributes.lpSecurityDescriptor);

    if (bWriteDirectory) {
        Status = SetPrinterDataServer(  pIniSpooler,
                                        SPLREG_DEFAULT_SPOOL_DIRECTORY,
                                        REG_SZ,
                                        (LPBYTE) pIniSpooler->pDefaultSpoolDir,
                                        wcslen(pIniSpooler->pDefaultSpoolDir)*sizeof(WCHAR) + sizeof(WCHAR));
    }

    cPrinters=0;
    cbData = COUNTOF(PrinterName);

    while( SplRegEnumKey( pIniSpooler->hckPrinters,
                          cPrinters,
                          PrinterName,
                          &cbData,
                          NULL,
                          pIniSpooler ) == ERROR_SUCCESS) {

        DBGMSG(DBG_TRACE, ("Found printer %ws\n", PrinterName));

        if( SplRegCreateKey( pIniSpooler->hckPrinters,
                             PrinterName,
                             0,
                             KEY_READ,
                             NULL,
                             &hPrinterKey,
                             NULL,
                             pIniSpooler ) == ERROR_SUCCESS ){

            if ( pIniPrinter = AllocSplMem(sizeof(INIPRINTER) )) {

                //
                // Reference count the pIniSpooler.
                //
                INCSPOOLERREF( pIniSpooler );
                DbgPrinterInit( pIniPrinter );

                pIniPrinter->signature = IP_SIGNATURE;
                GetSystemTime( &pIniPrinter->stUpTime );

                // Give the printer a unique session ID to pass around in notifications
                pIniPrinter->dwUniqueSessionID = dwUniquePrinterSessionID++;

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue(hPrinterKey,
                                     szName,
                                     NULL,
                                     (LPBYTE)szData,
                                     &cbData,
                                     pIniSpooler) == ERROR_SUCCESS)

                    pIniPrinter->pName = AllocSplStr(szData);

                //
                // Get Spool Directory for this printer
                //

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue( hPrinterKey,
                                      szSpoolDir,
                                      &Type,
                                      (LPBYTE)szData,
                                      &cbData,
                                      pIniSpooler) == ERROR_SUCCESS) {

                    if ( *szData != (WCHAR)0 ) {

                        pIniPrinter->pSpoolDir = AllocSplStr(szData);
                    }

                }


                //
                // Get ObjectGUID for this printer
                //

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue(   hPrinterKey,
                                        szObjectGUID,
                                        &Type,
                                        (LPBYTE)szData,
                                        &cbData,
                                        pIniSpooler) == ERROR_SUCCESS) {

                    if ( *szData != (WCHAR)0 ) {
                        pIniPrinter->pszObjectGUID = AllocSplStr(szData);
                    }
                }


                //
                // Get DsKeyUpdate and DsKeyUpdateForeground for this printer
                //

                cbData = sizeof(pIniPrinter->DsKeyUpdate );
                SplRegQueryValue(   hPrinterKey,
                                    szDsKeyUpdate,
                                    &Type,
                                    (LPBYTE) &pIniPrinter->DsKeyUpdate,
                                    &cbData,
                                    pIniSpooler);

                cbData = sizeof(pIniPrinter->DsKeyUpdateForeground );
                SplRegQueryValue(   hPrinterKey,
                                    szDsKeyUpdateForeground,
                                    &Type,
                                    (LPBYTE) &pIniPrinter->DsKeyUpdateForeground,
                                    &cbData,
                                    pIniSpooler);

                if ( !(pIniSpooler->SpoolerFlags & SPL_TYPE_CACHE) ) {

                    // We make sure that DsKeyUpdateForeground is consistent
                    // when the spooler startsup. Otherwise DsKeyUpdateForeground might be
                    // set without dwAction being set and the printer will always be in the
                    // IO_PENDING state.
                    if (pIniPrinter->DsKeyUpdateForeground & (DS_KEY_PUBLISH | DS_KEY_REPUBLISH | DS_KEY_UNPUBLISH)) {
                        if (pIniPrinter->DsKeyUpdateForeground & DS_KEY_PUBLISH) {
                            pIniPrinter->dwAction |= DSPRINT_PUBLISH;
                        } else if (pIniPrinter->DsKeyUpdateForeground & DS_KEY_REPUBLISH) {
                            pIniPrinter->dwAction |= DSPRINT_REPUBLISH;
                        } else if (pIniPrinter->DsKeyUpdateForeground & DS_KEY_UNPUBLISH) {
                            pIniPrinter->dwAction |= DSPRINT_UNPUBLISH;
                        }

                        pIniPrinter->DsKeyUpdateForeground &= ~(DS_KEY_PUBLISH | DS_KEY_REPUBLISH | DS_KEY_UNPUBLISH);

                    } else {
                        pIniPrinter->DsKeyUpdateForeground = 0;
                    }

                } else {

                    //
                    // For connections, dwAction is read from registry. It is updated by
                    // caching code with the value on the server.
                    //
                    cbData = sizeof(pIniPrinter->dwAction);
                    SplRegQueryValue(   hPrinterKey,
                                        szAction,
                                        &Type,
                                        (LPBYTE) &pIniPrinter->dwAction,
                                        &cbData,
                                        pIniSpooler);
                }

                // Make Certain this Printers Printer directory exists
                // with correct security

                if ((pIniPrinter->pSpoolDir) &&
                    (wcscmp(pIniPrinter->pSpoolDir, szDefaultPrinterDirectory) != 0)) {

                    SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
                    SecurityAttributes.lpSecurityDescriptor = CreateEverybodySecurityDescriptor();

                    SecurityAttributes.bInheritHandle = FALSE;


                    if (!CreateDirectory(pIniPrinter->pSpoolDir, &SecurityAttributes)) {

                        // Failed to Create the Directory, revert back
                        // to the default

                        if (GetLastError() != ERROR_ALREADY_EXISTS) {
                            DBGMSG(DBG_WARNING, ("Could not create printer spool directory %ws %d\n",
                                                  pIniPrinter->pSpoolDir, GetLastError() ));
                            pIniPrinter->pSpoolDir = NULL;
                        }

                    }

                    LocalFree(SecurityAttributes.lpSecurityDescriptor);
                }


                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue( hPrinterKey,
                                      szShare,
                                      &Type,
                                      (LPBYTE)szData,
                                      &cbData,
                                      pIniSpooler) == ERROR_SUCCESS)

                    pIniPrinter->pShareName = AllocSplStr(szData);

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                dwLastError = SplRegQueryValue( hPrinterKey,
                                                szPort,
                                                &Type,
                                                (LPBYTE)szData,
                                                &cbData,
                                                pIniSpooler );

                if ((dwLastError == ERROR_MORE_DATA) &&
                    (szPortData = AllocSplMem(cbData)))
                {
                    bAllocMem = TRUE;
                    dwLastError = SplRegQueryValue( hPrinterKey,
                                                    szPort,
                                                    &Type,
                                                    (LPBYTE)szPortData,
                                                    &cbData,
                                                    pIniSpooler );
                }
                else
                {
                    bAllocMem = FALSE;
                    szPortData = szData;
                }

                if (dwLastError == ERROR_SUCCESS)
                {
                    if (pKeyData = CreateTokenList(szPortData)) {

                        if (!ValidatePortTokenList( pKeyData, pIniSpooler, TRUE, &bNoPorts)) {

                            LogFatalPortError(pIniSpooler, pIniPrinter->pName);

                            FreePortTokenList(pKeyData);
                            pKeyData = NULL;

                        } else {

                            //
                            // If there are no ports on the printer, just log
                            // a warning message, but only for pooled printers.
                            //
                            if (bNoPorts && pKeyData->cTokens > 1) {

                                SplLogEvent( pIniSpooler,
                                             LOG_WARNING,
                                             MSG_NO_PORT_FOUND_FOR_PRINTER,
                                             TRUE,
                                             pIniPrinter->pName,
                                             szPortData,
                                             NULL );
                            }

                            pIniPrinter->ppIniPorts = AllocSplMem(pKeyData->cTokens * sizeof(PINIPORT));
                        }
                    }
                }

                if (bAllocMem)
                {
                    FreeSplMem(szPortData);
                    szPortData = NULL;
                }

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue( hPrinterKey,
                                      szPrintProcessor,
                                      &Type,
                                      (LPBYTE)szData,
                                      &cbData,
                                      pIniSpooler ) == ERROR_SUCCESS)
                {
                    //
                    // We are trying to find the environment relative to the pIniSpooler.
                    // The local spooler and cluster spoolers do not share the same
                    // environment strucutres anymore
                    //
                    PINIENVIRONMENT pIniEnv;

                    if (pIniEnv = FindEnvironment(szEnvironment, pIniSpooler))
                    {
                        pIniPrinter->pIniPrintProc = FindPrintProc(szData, pIniEnv);
                    }
                }

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue( hPrinterKey,
                                      szDatatype,
                                      &Type,
                                      (LPBYTE)szData,
                                      &cbData,
                                      pIniSpooler ) == ERROR_SUCCESS)

                    pIniPrinter->pDatatype = AllocSplStr(szData);

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue( hPrinterKey,
                                      szDriver,
                                      &Type,
                                      (LPBYTE)szData,
                                      &cbData,
                                      pIniSpooler ) == ERROR_SUCCESS) {

                    pIniPrinter->pIniDriver = (PINIDRIVER)FindLocalDriver(pIniSpooler, szData);

                    if (!pIniPrinter->pIniDriver)
                    {
                        //
                        // The hosting node of the cluster spooler was upgraded to Whistler.
                        //
                        if (pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER &&
                            pIniSpooler->dwClusNodeUpgraded &&

                            //
                            // The driver was not found in the cluster spooler, not on the cluster disk.
                            // We attempt to install the driver from the local spooler to our cluster
                            // spooler. This will get the driver files on the cluster disk.
                            //
                            AddLocalDriverToClusterSpooler(szData, pIniSpooler) == ERROR_SUCCESS)
                        {
                                //
                                // Search again for the driver that must have been added
                                //
                            pIniPrinter->pIniDriver = (PINIDRIVER)FindLocalDriver(pIniSpooler, szData);
                        }
                    }

                    if (!pIniPrinter->pIniDriver)
                    {
                        SplLogEvent(pLocalIniSpooler,
                                    LOG_ERROR,
                                    MSG_NO_DRIVER_FOUND_FOR_PRINTER,
                                    TRUE,
                                    pIniPrinter->pName,
                                    szData,
                                    NULL);
                    }
                }

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue( hPrinterKey,
                                      szLocation,
                                      &Type,
                                      (LPBYTE)szData,
                                      &cbData,
                                      pIniSpooler ) == ERROR_SUCCESS)

                    pIniPrinter->pLocation = AllocSplStr(szData);

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue( hPrinterKey,
                                      szDescription,
                                      &Type,
                                      (LPBYTE)szData,
                                      &cbData, pIniSpooler ) == ERROR_SUCCESS)

                    pIniPrinter->pComment = AllocSplStr(szData);

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue( hPrinterKey,
                                      szParameters,
                                      &Type,
                                      (LPBYTE)szData,
                                      &cbData, pIniSpooler ) == ERROR_SUCCESS)

                    pIniPrinter->pParameters = AllocSplStr(szData);

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue( hPrinterKey,
                                      szSepFile,
                                      &Type,
                                      (LPBYTE)szData,
                                      &cbData, pIniSpooler ) == ERROR_SUCCESS)

                    pIniPrinter->pSepFile = AllocSplStr(szData);

                cbData = sizeof(pIniPrinter->Attributes);

                SplRegQueryValue( hPrinterKey,
                                  szAttributes,
                                  NULL,
                                  (LPBYTE)&pIniPrinter->Attributes,
                                  &cbData,
                                  pIniSpooler );

                cbData = sizeof(pIniPrinter->Status);

                Status = SplRegQueryValue( hPrinterKey,
                                           szStatus,
                                           &Type,
                                           (LPBYTE)&pIniPrinter->Status,
                                           &cbData,
                                           pIniSpooler );

                pIniPrinter->Status |= PRINTER_FROM_REG;

                if ( Status == ERROR_SUCCESS ) {

                    pIniPrinter->Status &= ( PRINTER_PAUSED           |
                                             PRINTER_PENDING_DELETION |
                                             PRINTER_ZOMBIE_OBJECT    |
                                             PRINTER_FROM_REG         |
                                             PRINTER_OK               |
                                             PRINTER_PENDING_CREATION );

                } else {

                    pIniPrinter->Status |= PRINTER_PENDING_CREATION ;

                }

                // Half formed printers should be deleted
                // before they cause us trouble

                if ( pIniPrinter->Status & PRINTER_PENDING_CREATION ) {

                    pIniPrinter->Status |= PRINTER_PENDING_DELETION ;

                }



                cbData = sizeof(pIniPrinter->Priority);

                SplRegQueryValue( hPrinterKey,
                                  szPriority,
                                  &Type,
                                  (LPBYTE)&pIniPrinter->Priority,
                                  &cbData,
                                  pIniSpooler );

                cbData = sizeof(pIniPrinter->DefaultPriority);

                SplRegQueryValue( hPrinterKey,
                                  szDefaultPriority,
                                  &Type,
                                  (LPBYTE)&pIniPrinter->DefaultPriority,
                                  &cbData,
                                  pIniSpooler );

                cbData = sizeof(pIniPrinter->UntilTime);

                SplRegQueryValue( hPrinterKey,
                                  szUntilTime,
                                  &Type,
                                  (LPBYTE)&pIniPrinter->UntilTime,
                                  &cbData,
                                  pIniSpooler );

                cbData = sizeof(pIniPrinter->StartTime);

                SplRegQueryValue( hPrinterKey,
                                  szStartTime,
                                  &Type,
                                  (LPBYTE)&pIniPrinter->StartTime,
                                  &cbData,
                                  pIniSpooler );

                cbData = sizeof(pIniPrinter->dnsTimeout);

                if ( SplRegQueryValue( hPrinterKey,
                                       szDNSTimeout,
                                       &Type,
                                       (LPBYTE)&pIniPrinter->dnsTimeout,
                                       &cbData,
                                       pIniSpooler ) != ERROR_SUCCESS ) {

                    pIniPrinter->dnsTimeout = DEFAULT_DNS_TIMEOUT;
                }

                cbData = sizeof(pIniPrinter->txTimeout);

                if ( SplRegQueryValue( hPrinterKey,
                                       szTXTimeout,
                                       &Type,
                                       (LPBYTE)&pIniPrinter->txTimeout,
                                       &cbData,
                                       pIniSpooler ) != ERROR_SUCCESS ) {

                    pIniPrinter->txTimeout = DEFAULT_TX_TIMEOUT;
                }

                cbData = sizeof( pIniPrinter->cChangeID ) ;

                if ( SplRegQueryValue( hPrinterKey,
                                       szTimeLastChange,
                                       &Type,
                                       (LPBYTE)&pIniPrinter->cChangeID,
                                       &cbData,
                                       pIniSpooler ) != ERROR_SUCCESS ) {

                    // Current Registry Doesn't have a UniqueID
                    // Make sure one gets written

                    bUpdateRegistryForThisPrinter = TRUE;

                }

                pIniPrinter->dwPrivateFlag = 0;
                pIniPrinter->cbDevMode = 0;
                pIniPrinter->pDevMode = NULL;

                if (SplRegQueryValue( hPrinterKey,
                                      szDevMode,
                                      &Type,
                                      NULL,
                                      &pIniPrinter->cbDevMode,
                                      pIniSpooler ) == ERROR_SUCCESS) {

                    if (pIniPrinter->cbDevMode) {

                        pIniPrinter->pDevMode = AllocSplMem(pIniPrinter->cbDevMode);

                        SplRegQueryValue( hPrinterKey,
                                          szDevMode,
                                          &Type,
                                          (LPBYTE)pIniPrinter->pDevMode,
                                          &pIniPrinter->cbDevMode,
                                          pIniSpooler );
                    }
                }

                //
                //  A Provider might want to Read Extra Data from Registry
                //


                if ( pIniSpooler->pfnReadRegistryExtra != NULL ) {

                    pIniPrinter->pExtraData = (LPBYTE)(*pIniSpooler->pfnReadRegistryExtra)(hPrinterKey);

                }

                /* SECURITY */

                Status = SplRegQueryValue( hPrinterKey,
                                           szSecurity,
                                           NULL,
                                           NULL,
                                           &cbSecurity,
                                           pIniSpooler );

                if ((Status == ERROR_MORE_DATA) || (Status == ERROR_SUCCESS)) {

                    /* Use the process' heap to allocate security descriptors,
                     * so that they can be passed to the security API, which
                     * may need to reallocate them.
                     */
                    if (pIniPrinter->pSecurityDescriptor =
                                                   LocalAlloc(0, cbSecurity)) {

                        if (Status = SplRegQueryValue( hPrinterKey,
                                                       szSecurity,
                                                       NULL,
                                                       pIniPrinter->pSecurityDescriptor,
                                                       &cbSecurity,
                                                       pIniSpooler ) != ERROR_SUCCESS) {

                            LocalFree(pIniPrinter->pSecurityDescriptor);

                            pIniPrinter->pSecurityDescriptor = NULL;

                            DBGMSG( DBG_WARNING,
                                    ( "RegQueryValue returned %d on Permissions for %ws (%ws)\n",
                                      Status,
                                      pIniPrinter->pName ?
                                          pIniPrinter->pName :
                                          szNull,
                                      PrinterName) );
                        }
                    }

                } else {

                    pIniPrinter->pSecurityDescriptor = NULL;

                    DBGMSG( DBG_WARNING,
                            ( "RegQueryValue (2) returned %d on Permissions for %ws (%ws)\n",
                              Status,
                              pIniPrinter->pName ?
                                  pIniPrinter->pName :
                                  szNull,
                              PrinterName) );
                }

                pIniPrinter->MasqCache.bThreadRunning = FALSE;
                pIniPrinter->MasqCache.cJobs = 0;
                pIniPrinter->MasqCache.Status = 0;
                pIniPrinter->MasqCache.dwError = ERROR_SUCCESS;

                /* END SECURITY */

                if ( pIniPrinter->pName         &&
                     pIniPrinter->pShareName    &&
                     pKeyData                   &&
                     pIniPrinter->ppIniPorts    &&
                     pIniPrinter->pIniPrintProc &&
                     pIniPrinter->pIniDriver    &&
                     pIniPrinter->pLocation     &&
                     pIniPrinter->pComment      &&
                     pIniPrinter->pSecurityDescriptor
#if DBG
                     && ( IsValidSecurityDescriptor (pIniPrinter->pSecurityDescriptor)
                    ? TRUE
                    : (DBGMSG( DBG_SECURITY,
                               ( "The security descriptor for %ws (%ws) is invalid\n",
                                 pIniPrinter->pName ?
                                     pIniPrinter->pName :
                                     szNull,
                                     PrinterName)),  /* (sequential evaluation) */
                       FALSE) )
#endif /* DBG */
                    ) {


                    pIniPrinter->pIniFirstJob = pIniPrinter->pIniLastJob = NULL;

                    pIniPrinter->pIniPrintProc->cRef++;

                    INCDRIVERREF( pIniPrinter->pIniDriver );

                    for (i=0; i<pKeyData->cTokens; i++) {

                        pIniPort = (PINIPORT)pKeyData->pTokens[i];
                        pIniPrinter->ppIniPorts[i] = pIniPort;

                        pIniPort->ppIniPrinter =

                            ReallocSplMem(pIniPort->ppIniPrinter,
                                          pIniPort->cPrinters *
                                              sizeof(pIniPort->ppIniPrinter),
                                          (pIniPort->cPrinters+1) *
                                              sizeof(pIniPort->ppIniPrinter));

                        if (!pIniPort->ppIniPrinter) {
                            DBGMSG(DBG_WARNING, ("Failed to allocate memory for printer info\n." ));
                        }

                        pIniPort->ppIniPrinter[pIniPort->cPrinters] =
                                                                pIniPrinter;

                        //
                        // With the new monitors localspl does the
                        // redirection for LPT, COM ports
                        //
                        if ( !pIniPort->cPrinters++ )
                            CreateRedirectionThread(pIniPort);

                    }


                    pIniPrinter->cPorts = pKeyData->cTokens;
                    pIniPrinter->Priority =
                                  pIniPrinter->Priority ? pIniPrinter->Priority
                                                        : DEF_PRIORITY;

                    if ((pIniPrinter->Attributes &
                        (PRINTER_ATTRIBUTE_QUEUED | PRINTER_ATTRIBUTE_DIRECT)) ==
                        (PRINTER_ATTRIBUTE_QUEUED | PRINTER_ATTRIBUTE_DIRECT))

                        pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_DIRECT;

                    //
                    // I f we're upgrading, fix the NT4 bug that broke Masc printers.
                    // UpdateChangeID is passed into us as dwUpgradeFlag, so it determines
                    // if we're in an upgrade state.
                    //
                    // The rules: Printer name starts with \\
                    //            Port Name starts with \\
                    //            It's on a local IniSpooler.
                    //            The NETWORK and LOCAL bits are not set.
                    //
                    // If all the rules are met, set the NETWORK and LOCAL bits so the printer
                    // will behave properly.
                    //
                    if ( UpdateChangeID && (wcslen(pIniPrinter->pName) > 2) && pIniPrinter->cPorts &&
                         (*pIniPrinter->ppIniPorts)->pName && (wcslen((*pIniPrinter->ppIniPorts)->pName) > 2) &&
                         pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL)
                    {
                        WCHAR * pNameStr = pIniPrinter->pName;
                        WCHAR * pPortStr = (*pIniPrinter->ppIniPorts)->pName;
                        DWORD MascAttr   = (PRINTER_ATTRIBUTE_NETWORK | PRINTER_ATTRIBUTE_LOCAL);

                        if ((pNameStr[0] == L'\\') && (pNameStr[1] == L'\\') &&
                            (pPortStr[0] == L'\\') && (pPortStr[1] == L'\\') &&
                            ((pIniPrinter->Attributes & MascAttr) == 0))
                        {
                            pIniPrinter->Attributes |= MascAttr;
                        }

                    }

                    //
                    // If there were no ports for the printer, we set the state to
                    // work offline, but not if this was a masque printer. (In
                    // which case PRINTER_ATTRIBUTE_NETWORK is also set).
                    //
                    if (bNoPorts && !(pIniPrinter->Attributes & PRINTER_ATTRIBUTE_NETWORK)) {
                        pIniPrinter->Attributes |= PRINTER_ATTRIBUTE_WORK_OFFLINE;
                    }

                    pIniPrinter->pNext = pIniSpooler->pIniPrinter;

                    pIniPrinter->pIniSpooler = pIniSpooler;

                    pIniSpooler->pIniPrinter = pIniPrinter;

                    if ( bUpdateRegistryForThisPrinter ) {

                        UpdatePrinterIni( pIniPrinter , UPDATE_CHANGEID );
                        bUpdateRegistryForThisPrinter = UpdateChangeID;
                    }

                } else {

                    DBGMSG( DBG_WARNING,
                            ( "Initialization of printer failed:\
                               \n\tpPrinterName:\t%ws\
                               \n\tKeyName:\t%ws\
                               \n\tpShareName:\t%ws\
                               \n\tpKeyData:\t%08x\
                               \n\tpIniPrintProc:\t%08x",
                              pIniPrinter->pName ? pIniPrinter->pName : szNull,
                              PrinterName,
                              pIniPrinter->pShareName ? pIniPrinter->pShareName : szNull ,
                              pKeyData,
                              pIniPrinter->pIniPrintProc ) );

                    /* Do this in two lumps, because otherwise NTSD might crash.
                     * (Raid bug #10650)
                     */
                    DBGMSG( DBG_WARNING,
                            ( " \n\tpIniDriver:\t%08x\
                               \n\tpLocation:\t%ws\
                               \n\tpComment:\t%ws\
                               \n\tpSecurity:\t%08x\
                               \n\tStatus:\t\t%08x %s\n\n",
                              pIniPrinter->pIniDriver,
                              pIniPrinter->pLocation ? pIniPrinter->pLocation : szNull,
                              pIniPrinter->pComment ? pIniPrinter->pComment : szNull,
                              pIniPrinter->pSecurityDescriptor,
                              pIniPrinter->Status,
                              ( pIniPrinter->Status & PRINTER_PENDING_DELETION
                              ? "Pending deletion" : "" ) ) );

                    FreeStructurePointers((LPBYTE)pIniPrinter,
                                          NULL,
                                          IniPrinterOffsets);

                    if (pIniPrinter->pSecurityDescriptor) {
                        LocalFree(pIniPrinter->pSecurityDescriptor);
                        pIniPrinter->pSecurityDescriptor = NULL;
                    }

                    if (( pIniSpooler->pfnFreePrinterExtra != NULL ) &&
                        ( pIniPrinter->pExtraData != NULL )) {

                        (*pIniSpooler->pfnFreePrinterExtra)( pIniPrinter->pExtraData );

                    }

                    //
                    // Reference count the pIniSpooler.
                    //
                    DECSPOOLERREF( pIniSpooler );
                    DbgPrinterFree( pIniPrinter );

                    FreeSplMem(pIniPrinter);
                }

                FreePortTokenList(pKeyData);
                pKeyData = NULL;
            }
            SplRegCloseKey( hPrinterKey, pIniSpooler );
        }

        cPrinters++;

        cbData = COUNTOF(PrinterName);
    }

    if ( pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL) {

        WCHAR szFilename[MAX_PATH];
        HRESULT RetVal;

        szFilename[0] = L'\0';

        //
        // FP Change
        // Initialize the File pool.
        //
        if (pIniSpooler->hFilePool == INVALID_HANDLE_VALUE)
        {
            if (GetPrinterDirectory(NULL, FALSE, szFilename, MAX_PATH, pIniSpooler))
            {
                RetVal = CreateFilePool(
                    &pIniSpooler->hFilePool,
                    szFilename,
                    L"FP",
                    L".SPL",
                    L".SHD",
                    POOL_TIMEOUT,
                    MAX_POOL_FILES
                    );
                if (FAILED(RetVal))
                {
                    DBGMSG( DBG_WARN,
                            ( "SplCreateSpooler: Initialization of FilePool Failed %x\n",
                              RetVal ));
                }
            }
            else
            {
                DBGMSG( DBG_WARN, ("CreateFilePool: GetPrinterDirectory Failed\n"));
            }
        }

        // Read .SHD/.SPL files from common printer directory
        ProcessShadowJobs( NULL, pIniSpooler );

        // If any printer has a separate Printer directory process them
        // also

        if( GetPrinterDirectory(NULL, FALSE, szData, COUNTOF(szData), pIniSpooler) ) {

            for ( pIniPrinter = pIniSpooler->pIniPrinter;
                  pIniPrinter;
                  pIniPrinter = pIniPrinter->pNext ) {

                if ((pIniPrinter->pSpoolDir != NULL) &&
                    (_wcsicmp(szData, pIniPrinter->pSpoolDir) != 0)) {

                        ProcessShadowJobs(pIniPrinter, pIniSpooler);

                }
            }
        }
    }


    UpdateReferencesToChainedJobs( pIniSpooler );

    // Finally, go through all Printers looking for PENDING_DELETION
    // if there are no jobs for that Printer, then we can delete it now

    CleanupDeletedPrinters(pIniSpooler);

    DBGMSG( DBG_TRACE, ("BuildPrinterInfo returned\n"));

    return TRUE;
}


/* InitializePrintProcessor
 *
 * Allocates and initialises an INIPRINTPROC structure for the specified
 * print processor and environment.
 *
 * Arguments:
 *
 *     hLibrary - Handle to a previously loaded library ,
 *
 *     pIniEnvironment - Data structure for the requested environment
 *         The pIniPrintProc field is initialised with the chain of print
 *         processor structures
 *
 *     pPrintProcessorName - The Print Processor name e.g. WinPrint
 *
 *     pDLLName - The DLL name, e.g. WINPRINT
 *
 * Returns:
 *
 *     The allocated PiniPrintProc if no error was detected, otherwise FALSE.
 *
 *
 */
PINIPRINTPROC
InitializePrintProcessor(
    HINSTANCE       hLibrary,
    PINIENVIRONMENT pIniEnvironment,
    LPWSTR          pPrintProcessorName,
    LPWSTR          pDLLName
)
{
    DWORD cb, cbNeeded, cReturned;
    PINIPRINTPROC pIniPrintProc;
    BOOL    rc;
    DWORD   Error;

    DBGMSG(DBG_TRACE, ("InitializePrintProcessor( %08x, %08x ,%ws, %ws)\n",
                        hLibrary, pPrintProcessorName, pPrintProcessorName, pDLLName));


    cb = sizeof(INIPRINTPROC) +
         wcslen(pPrintProcessorName)*sizeof(WCHAR) +
         sizeof(WCHAR) +
         wcslen(pDLLName)*sizeof(WCHAR) +
         sizeof(WCHAR);

    if (!(pIniPrintProc = (PINIPRINTPROC)AllocSplMem(cb))) {

        DBGMSG(DBG_WARNING, ("Failed to allocate %d bytes for print processor\n.", cb));
        return NULL;
    }

    __try {

        InitializeCriticalSection(&pIniPrintProc->CriticalSection);

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        FreeSplMem(pIniPrintProc);
        SetLastError(GetExceptionCode());
        return NULL;
    }


    /* Typical strings used to build the full path of the DLL:
     *
     * pPathName    = C:\NT\SYSTEM32\SPOOL\PRTPROCS
     * pEnvironment = W32X86
     * pDLLName     = WINPRINT.DLL
     */

    pIniPrintProc->hLibrary = hLibrary;

    if (!pIniPrintProc->hLibrary) {

        DeleteCriticalSection(&pIniPrintProc->CriticalSection);
        FreeSplMem(pIniPrintProc);
        DBGMSG(DBG_WARNING, ("Failed to LoadLibrary(%ws)\n", pDLLName));
        return NULL;
    }

    pIniPrintProc->EnumDatatypes = (pfnEnumDatatypes) GetProcAddress(pIniPrintProc->hLibrary,
                                             "EnumPrintProcessorDatatypesW");

    if (!pIniPrintProc->EnumDatatypes) {

        DBGMSG(DBG_WARNING, ("Failed to GetProcAddress(EnumDatatypes)\n"));
        DeleteCriticalSection(&pIniPrintProc->CriticalSection);
        FreeLibrary(pIniPrintProc->hLibrary);
        FreeSplMem(pIniPrintProc);
        return NULL;
    }

    rc = (*pIniPrintProc->EnumDatatypes)(NULL, pPrintProcessorName, 1, NULL, 0, &cbNeeded, &cReturned);

    if (!rc && ((Error = GetLastError()) == ERROR_INSUFFICIENT_BUFFER)) {

        pIniPrintProc->cbDatatypes = cbNeeded;

        if (!(pIniPrintProc->pDatatypes = AllocSplMem(cbNeeded))) {

            DBGMSG(DBG_WARNING, ("Failed to allocate %d bytes for print proc datatypes\n.", cbNeeded));
            DeleteCriticalSection(&pIniPrintProc->CriticalSection);
            FreeLibrary(pIniPrintProc->hLibrary);
            FreeSplMem(pIniPrintProc);
            return NULL;
        }

        if (!(*pIniPrintProc->EnumDatatypes)(NULL, pPrintProcessorName, 1,
                                             (LPBYTE)pIniPrintProc->pDatatypes,
                                             cbNeeded, &cbNeeded,
                                             &pIniPrintProc->cDatatypes)) {

            Error = GetLastError();
            DBGMSG(DBG_WARNING, ("EnumPrintProcessorDatatypes(%ws) failed: Error %d\n",
                                 pPrintProcessorName, Error));
        }

    } else if(rc) {

        DBGMSG(DBG_WARNING, ("EnumPrintProcessorDatatypes(%ws) returned no data\n",
                             pPrintProcessorName));

    } else {

        DBGMSG(DBG_WARNING, ("EnumPrintProcessorDatatypes(%ws) failed: Error %d\n",
                             pPrintProcessorName, Error));
    }

    pIniPrintProc->Install = (pfnInstallPrintProcessor) GetProcAddress(pIniPrintProc->hLibrary,
                                            "InstallPrintProcessor");

    pIniPrintProc->Open = (pfnOpenPrintProcessor) GetProcAddress(pIniPrintProc->hLibrary,
                                                                "OpenPrintProcessor");

    pIniPrintProc->Print = (pfnPrintDocOnPrintProcessor) GetProcAddress(pIniPrintProc->hLibrary,
                                                                        "PrintDocumentOnPrintProcessor");

    pIniPrintProc->Close = (pfnClosePrintProcessor) GetProcAddress(pIniPrintProc->hLibrary,
                                                    "ClosePrintProcessor");

    pIniPrintProc->Control = (pfnControlPrintProcessor) GetProcAddress(pIniPrintProc->hLibrary,
                                                                       "ControlPrintProcessor");

    pIniPrintProc->GetPrintProcCaps = (pfnGetPrintProcCaps) GetProcAddress(pIniPrintProc->hLibrary,
                                                     "GetPrintProcessorCapabilities");

    /* pName and pDLLName are contiguous with the INIPRINTPROC structure:
     */
    pIniPrintProc->pName = (LPWSTR)(pIniPrintProc+1);
    wcscpy(pIniPrintProc->pName, pPrintProcessorName);

    pIniPrintProc->pDLLName = (LPWSTR)(pIniPrintProc->pName +
                                       wcslen(pIniPrintProc->pName) + 1);
    wcscpy(pIniPrintProc->pDLLName, pDLLName);


    pIniPrintProc->signature = IPP_SIGNATURE;

    pIniPrintProc->pNext = pIniEnvironment->pIniPrintProc;

    pIniEnvironment->pIniPrintProc = pIniPrintProc;

    return pIniPrintProc;
}

/*++

Routine Name:

    InitializeLocalPrintProcessor

Routine Description:

    We start up the local print processor, we need to bump the reference count
    on it library instance so that the cleanup code does not accidentally
    unload localspl.dll while it is running.

Arguments:

    pIniEnvironment     -   The environment to add the print processor to.

Return Value:

    An HRESULT.

--*/
HRESULT
InitializeLocalPrintProcessor(
    IN      PINIENVIRONMENT     pIniEnvironment
    )
{
    HRESULT     hRetval     = E_FAIL;
    HINSTANCE   hLocalSpl   = NULL;
    WCHAR       szFilename[MAX_PATH];

    hRetval = pIniEnvironment ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    if (SUCCEEDED(hRetval))
    {
        hRetval = GetModuleFileName(hInst, szFilename, COUNTOF(szFilename)) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hLocalSpl = LoadLibrary(szFilename);

        hRetval = hLocalSpl ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = InitializePrintProcessor(hLocalSpl, pIniEnvironment, L"WinPrint", L"localspl.dll") ? S_OK : GetLastErrorAsHResult();

        if (SUCCEEDED(hRetval))
        {
            hLocalSpl = NULL;
        }
    }

    FreeLibrary(hLocalSpl);

    return hRetval;
}


/* LoadPrintProcessor
 *
 * Loads the DLL for the required Print Processor and then calls
 * InitializePrintProcessor for the necesary allocation and
 * initialization of an INIPRINTPROC structure for the specified
 * print processor and environment.
 *
 * Arguments:
 *
 *     pIniEnvironment - Data structure for the requested environment
 *         The pIniPrintProc field is initialised with the chain of print
 *         processor structures
 *
 *     pPrintProcessorName - The Print Processor name e.g. WinPrint
 *
 *     pDLLName - The DLL name, e.g. WINPRINT
 *
 *     pInitSpooler
 *
 * Returns:
 *
 *     PINIPRINTPROC if no error was detected, otherwise NULL.
 *
 *
 */
PINIPRINTPROC
LoadPrintProcessor(
    PINIENVIRONMENT pIniEnvironment,
    LPWSTR          pPrintProcessorName,
    LPWSTR          pDLLName,
    PINISPOOLER     pIniSpooler
)
{
    WCHAR         string[MAX_PATH];
    DWORD         dwOldErrMode = 0;
    HINSTANCE     hLibrary;
    DWORD         MinorVersion = 0;
    DWORD         MajorVersion = 0; 
    PINIPRINTPROC pIniProc;

    DBGMSG(DBG_TRACE, ("LoadPrintProcessor( %08x, %ws, %ws )\n", pIniEnvironment, pPrintProcessorName, pDLLName));


    /* Originally:
     * Typical strings used to build the full path of the DLL:
     *
     * pPathName    = C:\NT\SYSTEM32\SPOOL\PRTPROCS
     * pEnvironment = W32X86
     * pDLLName     = WINPRINT.DLL
     * But after merging winprint and localspl , e.g. of setting
     * pPathName    = C:\NT\SYSTEM32
     * pDllName     = LOCALSPL.DLL
     */

    if( StrNCatBuff ( string,
                     COUNTOF(string),
                     pIniSpooler->pDir,
                     L"\\PRTPROCS\\",
                     pIniEnvironment->pDirectory,
                     L"\\",
                     pDLLName,
                     NULL) != ERROR_SUCCESS) {

        SetLastError(ERROR_BAD_PATHNAME);

        return NULL;
    }

    dwOldErrMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    hLibrary = LoadLibrary(string);

    //
    // We are a cluster spooler and we cannot find the library for a print
    // processor. We will try to copy the print processor from the cluster.
    // disk.
    //
    if (pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER &&
        !hLibrary                                    &&
        GetLastError() == ERROR_MOD_NOT_FOUND)
    {
        WCHAR szSourceFile[MAX_PATH];
        WCHAR szDestDir[MAX_PATH];
        DWORD dwError;

        DBGMSG(DBG_CLUSTER, ("LoadPrintProcessor File not found "TSTR"\n", string));

        if ((dwError = StrNCatBuff(szDestDir,
                                   COUNTOF(szDestDir),
                                   pIniSpooler->pDir,
                                   L"\\PRTPROCS\\",
                                   pIniEnvironment->pDirectory,
                                   NULL)) == ERROR_SUCCESS &&
            (dwError = StrNCatBuff(szSourceFile,
                                   COUNTOF(szSourceFile),
                                   pIniSpooler->pszClusResDriveLetter,
                                   L"\\",
                                   szClusterDriverRoot,
                                   L"\\",
                                   pIniEnvironment->pDirectory,
                                   L"\\",
                                   pDLLName,
                                   NULL)) == ERROR_SUCCESS)
        {
            //
            // Make sure the destination directory exists
            //
            CreateCompleteDirectory(szDestDir);

            //
            // Try to copy the print proc file from the cluster disk
            //
            if (CopyFile(szSourceFile, string, FALSE) &&
                (hLibrary = LoadLibrary(string)))
            {
                DBGMSG(DBG_CLUSTER, ("LoadPrintProc copied "TSTR" to "TSTR"\n", szSourceFile, string));
            }
            else
            {
                dwError = GetLastError();
            }
        }
    }

    if (hLibrary)
    {
        if (!GetBinaryVersion(string, &MajorVersion, &MinorVersion))
        {
            DBGMSG(DBG_ERROR, ("GetBinaryVersion failed. Error %u\n", GetLastError()));
        }
    }

    SetErrorMode( dwOldErrMode );       /* Restore error mode */

    pIniProc = InitializePrintProcessor(hLibrary,
                                        pIniEnvironment,
                                        pPrintProcessorName,
                                        pDLLName);

    if (pIniProc)
    {
        pIniProc->FileMajorVersion = MajorVersion;
        pIniProc->FileMinorVersion = MinorVersion;
    }

    return pIniProc;
}


/*
   Current Directory == c:\winspool\drivers
   pFindFileData->cFileName == win32.x86
*/


/* BuildEnvironmentInfo
 *
 *
 * The registry tree for Environments is as follows:
 *
 *     Print
 *      
 *       Environments
 *         
 *          Windows NT x86
 *            
 *             Drivers
 *               
 *                Agfa Compugraphic Genics (e.g.)
 *            
 *                  :
 *                  :
 *            
 *             Print Processors
 *                
 *                 WINPRINT : WINPRINT.DLL (e.g.)
 *         
 *                   :
 *                   :
 *         
 *          Windows NT R4000
 *      
 *       Printers
 *
 *
 *
 */
BOOL
BuildEnvironmentInfo(
    PINISPOOLER pIniSpooler
    )
{
    WCHAR   Environment[MAX_PATH];
    WCHAR   szData[MAX_PATH];
    DWORD   cbData, cb;
    DWORD   cchBuffer = COUNTOF(Environment);
    DWORD   cEnvironments=0, Type;
    HKEY    hEnvironmentsKey, hEnvironmentKey;
    LPWSTR  pDirectory;
    PINIENVIRONMENT pIniEnvironment;
    LONG    Status;

    //
    // The local spooler and cluster spooler have each different places
    // where they store information about environments
    //
    if (pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG)
    {
        Status = SplRegOpenKey(pIniSpooler->hckRoot,
                               pIniSpooler->pszRegistryEnvironments,
                               KEY_READ,
                               &hEnvironmentsKey,
                               pIniSpooler);
    }
    else
    {
        Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pIniSpooler->pszRegistryEnvironments, 0, KEY_READ, &hEnvironmentsKey);
    }

    if (Status != ERROR_SUCCESS)
    {
        DBGMSG(DBG_CLUSTER, ("RegOpenKey of %ws Failed: Error = %d\n", szEnvironmentsKey, Status));

        return FALSE;
    }

    //
    // Enumerate the subkeys of "Environment".
    // This will give us "Windows NT x86", "Windows NT R4000", * and maybe others:
    //
    while (SplRegEnumKey(hEnvironmentsKey, cEnvironments, Environment, &cchBuffer, NULL, pIniSpooler) == ERROR_SUCCESS) {

        DBGMSG(DBG_CLUSTER, ("Found environment "TSTR"\n", Environment));

        //
        // For each environment found, create or open the key:
        //
        if (SplRegCreateKey(hEnvironmentsKey, Environment, 0, KEY_READ, NULL, &hEnvironmentKey, NULL, pIniSpooler) == ERROR_SUCCESS) {

            cbData = sizeof(szData);

            pDirectory = NULL;

            //
            // Find the name of the directory associated with this environment,
            // e.g. "Windows NT x86"   -> "W32X86"
            //      "Windows NT R4000" -> "W32MIPS"
            //
            if (RegGetString(hEnvironmentKey, szDirectory, &pDirectory, &cbData, &Status, TRUE, pIniSpooler)) {

                DBGMSG(DBG_CLUSTER, ("BuildEnvInfo pDirectory "TSTR"\n", pDirectory));
            }

            cb = sizeof(INIENVIRONMENT) + wcslen(Environment)*sizeof(WCHAR) + sizeof(WCHAR);

            if (pDirectory && (pIniEnvironment=AllocSplMem(cb))) {

                pIniEnvironment->pName         = wcscpy((LPWSTR)(pIniEnvironment+1), Environment);
                pIniEnvironment->signature     = IE_SIGNATURE;
                pIniEnvironment->pDirectory    = pDirectory;
                pIniEnvironment->pNext         = pIniSpooler->pIniEnvironment;
                pIniSpooler->pIniEnvironment   = pIniEnvironment;
                pIniEnvironment->pIniVersion   = NULL;
                pIniEnvironment->pIniPrintProc = NULL;
                pIniEnvironment->pIniSpooler   = pIniSpooler;
                if(!_wcsicmp(Environment,LOCAL_ENVIRONMENT)) {

                    (VOID)InitializeLocalPrintProcessor(pIniEnvironment);
                }

                BuildDriverInfo(hEnvironmentKey, pIniEnvironment, pIniSpooler);
                BuildPrintProcInfo (hEnvironmentKey, pIniEnvironment, pIniSpooler);

                DBGMSG(DBG_TRACE, ("Data for environment %ws created:\
                                    \n\tpDirectory: %ws\n",
                                   Environment,
                                   pDirectory));
            }

            SplRegCloseKey(hEnvironmentKey, pIniSpooler);
        }

        cEnvironments++;

        cchBuffer = COUNTOF(Environment);
    }

    SplRegCloseKey(hEnvironmentsKey, pIniSpooler);

    if (!(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER))
    {
        pThisEnvironment = FindEnvironment(szEnvironment, pIniSpooler);
    }

    return FALSE;
}



BOOL
BuildDriverInfo(
    HKEY            hKeyEnvironment,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
    )

/*++

Routine Description:

    Creates driver and version ini structures based on environment.

Arguments:

    hKeyEnvironment - Registry key specifying environment.

    pIniEnvironment - Structure for environemnt.  Will be initialized
        to hold pIniVersions and pIniDrivers.

Return Value:

    TRUE - Success,
    False - Failure.

--*/

{
    WCHAR   szVersionName[MAX_PATH];
    DWORD   cchBuffer;
    DWORD   cVersion;
    HKEY    hDriversKey;
    DWORD   Status;
    PINIVERSION pIniVersionList, pIniVersion;

    Status = SplRegCreateKey(hKeyEnvironment,szDriversKey, 0, KEY_READ, NULL, &hDriversKey, NULL, pIniSpooler);

    if (Status != ERROR_SUCCESS) {
        DBGMSG(DBG_ERROR, ("RegOpenKeyEx of %ws failed: Error = %d\n", szDriversKey, Status));
        return FALSE;
    }

    DBGMSG(DBG_TRACE,("RegCreateKeyEx succeeded in BuildDriverInfo\n"));

    for( pIniVersionList = NULL, cVersion = 0;

         cchBuffer = COUNTOF( szVersionName ),
         SplRegEnumKey(hDriversKey, cVersion, szVersionName, &cchBuffer, NULL, pIniSpooler) == ERROR_SUCCESS;

         cVersion++ ){

        DBGMSG(DBG_TRACE,("Version found %ws\n", szVersionName));

        //
        // If it isn't a version -- remember we look for current
        // drivers before we upgrade, just move on.
        //
        if (_wcsnicmp(szVersionName, L"Version-", 8)) {
            continue;
        }

        pIniVersion = GetVersionDrivers( hDriversKey,
                                         szVersionName,
                                         pIniSpooler,
                                         pIniEnvironment );

        if( pIniVersion ){
            InsertVersionList( &pIniVersionList, pIniVersion );
        }
    }
    SplRegCloseKey(hDriversKey, pIniSpooler);
    pIniEnvironment->pIniVersion = pIniVersionList;

    return TRUE;
}


/* BuildPrintProcInfo
 *
 * Opens the printproc subkey for the specified environment and enumerates
 * the print processors listed.
 *
 * For each print processor found, calls InitializePrintProcessor to allocate
 * and inintialize a data structure.
 *
 * This function was adapted to use SplReg functions. Those functions are
 * cluster aware.
 *
 * Arguments:
 *
 *     hKeyEnvironment - The key for the specified environment,
 *         used for Registry API calls.
 *
 *     pIniEnvironment - Data structure for the environment.
 *         The pIniPrintProc field will be initialised to contain a chain
 *         of one or more print processors enumerated from the registry.
 *
 * Return:
 *
 *     TRUE if operation was successful, otherwise FALSE
 *
 *
 * 8 Sept 1992 by andrewbe, based on an original idea by davesn
 */
BOOL
BuildPrintProcInfo(
    HKEY            hKeyEnvironment,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
)
{
    WCHAR   PrintProcName[MAX_PATH];
    WCHAR   DLLName[MAX_PATH];
    DWORD   cchBuffer, cbDLLName;
    DWORD   cPrintProcs = 0;
    HKEY    hPrintProcKey, hPrintProc;
    DWORD   Status;
    PINIPRINTPROC pIniPrintProc;

    if ((Status = SplRegOpenKey(hKeyEnvironment,
                                szPrintProcKey,
                                KEY_READ,
                                &hPrintProcKey,
                                pIniSpooler)) == ERROR_SUCCESS)
    {
        cchBuffer = COUNTOF(PrintProcName);

        while (SplRegEnumKey(hPrintProcKey,
                             cPrintProcs,
                             (LPTSTR)PrintProcName,
                             &cchBuffer,
                             NULL,
                             pIniSpooler) == ERROR_SUCCESS)
       {
            DBGMSG(DBG_TRACE, ("BuildPrintProcInfo Print processor found: %ws\n", PrintProcName));

            if (SplRegOpenKey(hPrintProcKey,
                              PrintProcName,
                              KEY_READ,
                              &hPrintProc,
                              pIniSpooler) == ERROR_SUCCESS)
            {
                cbDLLName = sizeof(DLLName);

                if (SplRegQueryValue(hPrintProc,
                                     szDriverFile,
                                     NULL,
                                     (LPBYTE)DLLName,
                                     &cbDLLName,
                                     pIniSpooler) == ERROR_SUCCESS)
                {
                    pIniPrintProc = LoadPrintProcessor(pIniEnvironment,
                                                       PrintProcName,
                                                       DLLName,
                                                       pIniSpooler);
                }

                SplRegCloseKey(hPrintProc, pIniSpooler);
            }

            //
            // Don't delete the key !! If winprint.dll was corrupt,
            // then we nuke it and we are hosed since there is no UI
            // to add print procs.
            // We can afford to be a little slow on init, since we only
            // do it once.
            //
            cchBuffer = COUNTOF(PrintProcName);
            cPrintProcs++;
        }

        SplRegCloseKey(hPrintProcKey, pIniSpooler);

        DBGMSG(DBG_TRACE, ("End of print processor initialization.\n"));

    } else {

        DBGMSG (DBG_WARNING, ("SplRegOpenKey failed: Error = %d\n", Status));

        return FALSE;
    }

    return TRUE;
}


#define SetOffset(Dest, Source, End)                                      \
              if (Source) {                                               \
                 Dest=End;                                                \
                 End+=wcslen(Source)+1;                                   \
              }

#define SetPointer(struc, off)                                            \
              if (struc->off) {                                           \
                 struc->off += (ULONG_PTR)struc/sizeof(*struc->off);           \
              }

#define WriteString(hFile, pStr)  \
              if (pStr) {\
                  rc = WriteFile(hFile, pStr, wcslen(pStr)*sizeof(WCHAR) + \
                            sizeof(WCHAR), &BytesWritten, NULL);    \
                  if (!rc) { \
                      DBGMSG(DBG_WARNING, ("WriteShadowJob: WriteFile failed %d\n", \
                                            GetLastError())); \
                  } \
              }

#define AddSize(pStr, dwSize)                                         \
              if (pStr) {                                             \
                  dwSize = dwSize + (wcslen(pStr) + 1)*sizeof(WCHAR); \
              }

#define CopyString(pBuffer, dwOffset, pStr)                           \
              if (pStr) {                                             \
                  wcscpy((LPWSTR)(pBuffer + dwOffset), pStr);         \
                  dwOffset += (wcslen(pStr) + 1)*sizeof(WCHAR);       \
              }

BOOL
WriteShadowJob(
    IN      PINIJOB      pIniJob,
    IN      BOOL         bLeaveCS
    )
{
   BOOL         bAllocBuffer        = FALSE;
   BOOL         bRet                = FALSE;
   BOOL         bFileCreated        = FALSE;
   HANDLE       hFile               = INVALID_HANDLE_VALUE;
   HANDLE       hImpersonationToken = INVALID_HANDLE_VALUE;
   DWORD        BytesWritten, dwSize, dwType, dwData, dwcbData;
   ULONG_PTR    dwOffset, cb;
   SHADOWFILE_3 ShadowFile;
   LPWSTR       pEnd;
   WCHAR        szFileName[MAX_PATH];
   BYTE         ShdFileBuffer[MAX_STATIC_ALLOC];
   LPBYTE       pBuffer;
   HKEY         hPrintRegKey = NULL;
   BOOL         UsePools = TRUE;

   SplInSem();

   //
   // Only update if this is not a direct job and the spooler requests it.
   // Also don't update if the shadow file has been deleted at some other point.
   // This check must be performed in the CS else the FilePool starts leaking
   // jobs.
   //
   if ( (pIniJob->Status & JOB_DIRECT) ||
        (pIniJob->pIniPrinter->pIniSpooler->SpoolerFlags
                        & SPL_NO_UPDATE_JOBSHD) ||
        (pIniJob->Status & JOB_SHADOW_DELETED) ) {

        bRet = TRUE;

        //
        // Setting this to FALSE prevents us reentering the CS accidentally.
        //
        bLeaveCS = FALSE;
        goto CleanUp;
   }

   if (bLeaveCS)  {

       LeaveSplSem();
       SplOutSem();
   }

   //
   // FP Change
   // if we don't have a handle to a filepool item, we
   // revert to the old methods.
   //
   if (pIniJob->hFileItem == INVALID_HANDLE_VALUE)
   {
       UsePools = FALSE;
   }


   if (!UsePools)
   {
       GetFullNameFromId(pIniJob->pIniPrinter, pIniJob->JobId, FALSE, szFileName, FALSE);
   }

   hImpersonationToken = RevertToPrinterSelf();

   if (UsePools)
   {
       HRESULT      RetVal              = S_OK;
       //
       // FP Change
       // We Get a write handle from the pool for the shadow files and
       // truncate it for use.
       //
       RetVal = GetWriterFromHandle(pIniJob->hFileItem, &hFile, FALSE);

       if (SUCCEEDED(RetVal))
       {
           //
           // Even if we can't set the file pointer, we have signalled to the
           // file pool that a writer is busy with this file pool object.
           //
           bFileCreated = TRUE;

           if (INVALID_SET_FILE_POINTER == SetFilePointer(hFile, 0, NULL, FILE_BEGIN))
           {
               DBGMSG( DBG_WARNING,
                   ( "WriteShadowJob Failed to set File pointer. Error %d\n", GetLastError() ));
               hFile = INVALID_HANDLE_VALUE;
           }
       }
       else
       {
           DBGMSG( DBG_WARNING,
               ( "WriteShadowJob Failed to get File Handle from Pool Item. Error %x\n", RetVal ));
           hFile = INVALID_HANDLE_VALUE;
       }
    }
   else
   {
       //
       // Open file in Cached IO. Big performance gain.
       //
       hFile=CreateFile(szFileName, GENERIC_WRITE, FILE_SHARE_READ,
                        NULL, CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);

       if (hFile != INVALID_HANDLE_VALUE) {

            bFileCreated = TRUE;
       }
   }

   ImpersonatePrinterClient(hImpersonationToken);

   if ( hFile == INVALID_HANDLE_VALUE ) {

      DBGMSG( DBG_WARNING,
              ( "WriteShadowJob failed to open shadow file "TSTR"\n Error %d\n",
                szFileName, GetLastError() ));

      bRet = FALSE;

      goto CleanUp;

   }

   memset(&ShadowFile, 0, sizeof(ShadowFile));
   ShadowFile.signature = SF_SIGNATURE_3;
   ShadowFile.cbSize    = sizeof( SHADOWFILE_3 );
   ShadowFile.Version   = SF_VERSION_3;
   ShadowFile.Status    = pIniJob->Status;
   ShadowFile.JobId     = pIniJob->JobId;
   ShadowFile.Priority  = pIniJob->Priority;
   ShadowFile.Submitted = pIniJob->Submitted;
   ShadowFile.StartTime = pIniJob->StartTime;
   ShadowFile.UntilTime = pIniJob->UntilTime;
   ShadowFile.Size      = pIniJob->Size;
   ShadowFile.dwValidSize = pIniJob->dwValidSize;
   ShadowFile.cPages    = pIniJob->cPages;
   ShadowFile.dwReboots  = pIniJob->dwReboots;
   if(pIniJob->pSecurityDescriptor)
       ShadowFile.cbSecurityDescriptor=GetSecurityDescriptorLength(
                                           pIniJob->pSecurityDescriptor);

   pEnd=(LPWSTR)sizeof(ShadowFile);

   if (pIniJob->pDevMode) {
      ShadowFile.pDevMode=(LPDEVMODE)pEnd;
      cb = pIniJob->pDevMode->dmSize + pIniJob->pDevMode->dmDriverExtra;
      cb = ALIGN_UP(cb,ULONG_PTR);
      cb /= sizeof(WCHAR);
      pEnd += cb;
   }

   if (pIniJob->pSecurityDescriptor) {
      ShadowFile.pSecurityDescriptor=(PSECURITY_DESCRIPTOR)pEnd;
      cb = ShadowFile.cbSecurityDescriptor;
      cb = ALIGN_UP(cb,ULONG_PTR);
      cb /= sizeof(WCHAR);
      pEnd += cb;
   }

   ShadowFile.NextJobId = pIniJob->NextJobId;

   SetOffset( ShadowFile.pNotify, pIniJob->pNotify, pEnd );
   SetOffset( ShadowFile.pUser, pIniJob->pUser, pEnd );
   SetOffset( ShadowFile.pDocument, pIniJob->pDocument, pEnd );
   SetOffset( ShadowFile.pOutputFile, pIniJob->pOutputFile, pEnd );
   SetOffset( ShadowFile.pPrinterName, pIniJob->pIniPrinter->pName, pEnd );
   SetOffset( ShadowFile.pDriverName, pIniJob->pIniDriver->pName, pEnd );
   SetOffset( ShadowFile.pPrintProcName, pIniJob->pIniPrintProc->pName, pEnd );
   SetOffset( ShadowFile.pDatatype, pIniJob->pDatatype, pEnd );
   SetOffset( ShadowFile.pParameters, pIniJob->pParameters, pEnd );
   SetOffset( ShadowFile.pMachineName, pIniJob->pMachineName, pEnd );

   dwSize = (DWORD)ALIGN_UP(pEnd,ULONG_PTR);

   if (dwSize > MAX_STATIC_ALLOC) {

       if (!(pBuffer = (LPBYTE) AllocSplMem(dwSize))) {

           DBGMSG( DBG_WARNING, ("WriteShadowJob: Memory Allocation failed %d\n", GetLastError()));

           bRet = FALSE;

           goto CleanUp;
       }
       bAllocBuffer = TRUE;

   } else {

       pBuffer = (LPBYTE) ShdFileBuffer;
   }

   //
   // Copy SHADOWFILE_3 and data pointed thru it, into the buffer
   //

   dwOffset = 0;

   CopyMemory(pBuffer + dwOffset, &ShadowFile, sizeof(SHADOWFILE_3));
   dwOffset += sizeof(SHADOWFILE_3);

   if (pIniJob->pDevMode) {

       CopyMemory(pBuffer + dwOffset, pIniJob->pDevMode, pIniJob->pDevMode->dmSize +
                                                          pIniJob->pDevMode->dmDriverExtra);
       dwOffset += (pIniJob->pDevMode->dmSize + pIniJob->pDevMode->dmDriverExtra);
       dwOffset = ALIGN_UP(dwOffset,ULONG_PTR);
   }

   if (pIniJob->pSecurityDescriptor) {

       CopyMemory(pBuffer + dwOffset, pIniJob->pSecurityDescriptor,
                                       ShadowFile.cbSecurityDescriptor);
       dwOffset += ShadowFile.cbSecurityDescriptor;
       dwOffset = ALIGN_UP(dwOffset,ULONG_PTR);
   }

   //
   // CopyString is defined at the start of the function
   //
   CopyString(pBuffer, dwOffset, pIniJob->pNotify);
   CopyString(pBuffer, dwOffset, pIniJob->pUser);
   CopyString(pBuffer, dwOffset, pIniJob->pDocument);
   CopyString(pBuffer, dwOffset, pIniJob->pOutputFile);
   CopyString(pBuffer, dwOffset, pIniJob->pIniPrinter->pName);
   CopyString(pBuffer, dwOffset, pIniJob->pIniDriver->pName);
   CopyString(pBuffer, dwOffset, pIniJob->pIniPrintProc->pName);
   CopyString(pBuffer, dwOffset, pIniJob->pDatatype);
   CopyString(pBuffer, dwOffset, pIniJob->pParameters);
   CopyString(pBuffer, dwOffset, pIniJob->pMachineName);

   //
   // Copy the structure into the Shadow file. Buffers need not be buffered since the
   // file is opened in WRITE_THROUGH mode.
   //
   bRet = WriteFile( hFile, pBuffer, dwSize, &BytesWritten, NULL);

   //
   // Flush the file buffers if the corresponding flag is set in the registry
   //
   if (dwFlushShadowFileBuffers == 0) {

       // Avoid repeated initializations
       dwFlushShadowFileBuffers = 2;

       // flag has to be initialized from the registry
       dwcbData = sizeof(DWORD);
       if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        szRegistryRoot,
                        0,
                        KEY_READ,
                        &hPrintRegKey) == ERROR_SUCCESS) {

           if (RegQueryValueEx(hPrintRegKey,
                               szFlushShadowFileBuffers,
                               NULL,
                               &dwType,
                               (LPBYTE) &dwData,
                               &dwcbData) == ERROR_SUCCESS) {

                if (dwData == 1) {
                    // Flush the shadow file buffers
                    dwFlushShadowFileBuffers = 1;
                }
           }

           RegCloseKey(hPrintRegKey);
       }
   }

   if (dwFlushShadowFileBuffers == 1) {
       bRet = FlushFileBuffers(hFile);
   }

   if (!bRet) {

       DBGMSG( DBG_WARNING, ("WriteShadowJob: WriteFile failed %d\n", GetLastError()));
   }

CleanUp:

   if (bAllocBuffer) {
       FreeSplMem(pBuffer);
   }

   if (!UsePools && hFile != INVALID_HANDLE_VALUE)
   {
       //
       // FP Change
       // Only close the file if it's a non-pooled file.
       //
       if (!CloseHandle(hFile)) {
           DBGMSG(DBG_WARNING, ("WriteShadowJob CloseHandle failed %d %d\n",
                                 hFile, GetLastError()));
       }
   }

   //
   // Reenter the CS if we were asked to leave it.
   //
   if (bLeaveCS) {

       EnterSplSem();
   }

   //
   // We can be called just before the shadow file was deleted (or sent back to
   // the file pool) and then either recreate the shadow file on the disk or
   // potentially leak a file pool handle. The final DeleteJob when the reference
   // count is zero will see that the shadow file has already been deleted and will
   // not attempt to clean it up. So, we remove the JOB_SHADOW_DELETED bit here to
   // ensure that this will not happen.
   //
   if (bFileCreated) {

        pIniJob->Status &= ~JOB_SHADOW_DELETED;
   }

   return bRet;
}

#undef CopyString

#undef AddSize


VOID
ProcessShadowJobs(
    PINIPRINTER pIniPrinter,
    PINISPOOLER pIniSpooler
    )
{
    WCHAR   wczPrintDirAllSpools[MAX_PATH];
    WCHAR   wczPrinterDirectory[MAX_PATH];
    HANDLE  fFile;
    BOOL    b;
    PWIN32_FIND_DATA pFindFileData;
    PINIJOB pIniJob;
    UINT ErrorMode;

    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );

    //
    //  Don't Process Shadow Jobs during Upgrade
    //

    if ( dwUpgradeFlag != 0 || !( pIniSpooler->SpoolerFlags & SPL_PRINT )) {

        return;
    }

    ErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    if( GetPrinterDirectory(pIniPrinter,
                            FALSE,
                            wczPrintDirAllSpools,
                            (COUNTOF(wczPrintDirAllSpools) - COUNTOF(szAllSpools)),
                            pIniSpooler) &&

        GetPrinterDirectory(pIniPrinter,
                            FALSE,
                            wczPrinterDirectory,
                            COUNTOF(wczPrinterDirectory),
                            pIniSpooler) ) {

        wcscat(wczPrintDirAllSpools, szAllSpools);

        if ( pFindFileData = AllocSplMem(sizeof(WIN32_FIND_DATA) )) {

            fFile =  FindFirstFile( wczPrintDirAllSpools, pFindFileData );

            if ( fFile != (HANDLE)-1 ) {

                b=TRUE;

                while( b ) {

                    if ( !(pFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                        ReadShadowJob(wczPrinterDirectory, pFindFileData, pIniSpooler);
                    }

                    b = FindNextFile(fFile, pFindFileData);
                }

                FindClose( fFile );

            }

            FreeSplMem( pFindFileData );
        }
    }

    SetErrorMode(ErrorMode);
}



#define CheckPointer( strptr )                                        \
    if( strptr ) {                                                    \
        if( (ULONG_PTR)(strptr + wcslen(strptr) + 1) > (ULONG_PTR)pEnd ) {    \
            bRet = FALSE;                                             \
            goto BailOut;                                             \
        }                                                             \
    }

//
// make sure all pointers contain embedded data bounded within the pShadowFile (not passed the end).
//
BOOL
CheckAllPointers(
    PSHADOWFILE_3 pShadowFile,
    DWORD dwSize
    )
{
    LPBYTE pEnd = (LPBYTE)pShadowFile + dwSize;
    DWORD  cb;
    BOOL bRet = TRUE;

    try {

        CheckPointer(pShadowFile->pDatatype);
        CheckPointer(pShadowFile->pNotify);
        CheckPointer(pShadowFile->pUser);
        CheckPointer(pShadowFile->pDocument);
        CheckPointer(pShadowFile->pOutputFile);
        CheckPointer(pShadowFile->pPrinterName);
        CheckPointer(pShadowFile->pDriverName);
        CheckPointer(pShadowFile->pPrintProcName);
        CheckPointer(pShadowFile->pParameters);
        CheckPointer(pShadowFile->pMachineName);

        // Now check the rest of the two data structures
        if( (ULONG_PTR)pShadowFile->pSecurityDescriptor + pShadowFile->cbSecurityDescriptor > (ULONG_PTR)pEnd ) {
            bRet = FALSE;
            goto BailOut;
        }

        if( pShadowFile->pDevMode ) {
            cb = pShadowFile->pDevMode->dmSize + pShadowFile->pDevMode->dmDriverExtra;
            if( (ULONG_PTR)pShadowFile->pDevMode + cb > (ULONG_PTR)pEnd )
                bRet = FALSE;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        bRet = FALSE;
    }

BailOut:
    return bRet;
}

#undef CheckPointer


PINIJOB
ReadShadowJob(
    LPWSTR  szDir,
    PWIN32_FIND_DATA pFindFileData,
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Reads a *.spl/*.shd file and partially validates the file.

Arguments:

    szDir -- pointer to spool directory string

    pFindFileData -- found file data (spl file)

    pIniSpooler -- spooler the *.spl belongs to

Return Value:

    Allocated pIniJob.

Notes:

    Warning: Changing the format of SHADOWFILE requires modifying the
    data integrity checks performed here!

    If the shadow file structure size is grown, then when reading,
    you must check the old sizes before touching memory.  Current layout is:

    | DWORD | ... | String | DWORD | DWORD | StringData | StringData |
    *--------------------------------------*
                      ^ This is the SHADOWFILE_3 structure.

    If you grow it, then the next field will point to StringData, and
    won't be valid--you can't touch it since you'll corrupt the string.

--*/

{
    HANDLE   hFile = INVALID_HANDLE_VALUE;
    HANDLE   hFileSpl = INVALID_HANDLE_VALUE;
    DWORD    BytesRead;
    PSHADOWFILE_3 pShadowFile3 = NULL;
    PSHADOWFILE_3 pShadowFile = NULL;
    PINIJOB  pIniJob;
    DWORD    cb,i;
    WCHAR    szFileName[MAX_PATH];
    LPWSTR    pExt;
    BOOL     rc;
    LPWSTR   pFileSpec;
    DWORD    nFileSizeLow;

    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );

    wcscpy(&szFileName[0], szDir);
    pFileSpec = szFileName + wcslen(szFileName);

    *pFileSpec++ = L'\\';
    wcscpy(pFileSpec, pFindFileData->cFileName);

    hFileSpl=CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ,
                        NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hFileSpl == INVALID_HANDLE_VALUE) {
        DBGMSG(DBG_WARNING, ("ReadShadowJob CreateFile( %ws ) failed: LastError = %d\n",
                             szFileName, GetLastError()));

        goto Fail;
    }

    CharUpper(szFileName);
    pExt = wcsstr(szFileName, L".SPL");

    if (!pExt)
        goto Fail;

    pExt[2] = L'H';
    pExt[3] = L'D';

    hFile=CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ,
                     NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        DBGMSG(DBG_WARNING, ("ReadShadowJob CreateFile( %ws ) failed: LastError = %d\n",
                             szFileName, GetLastError()));

        goto Fail;
    }

    nFileSizeLow = GetFileSize(hFile, NULL);

    if (nFileSizeLow == 0xffffffff)
    {
        DBGMSG(DBG_WARNING, ("ReadShadowJob GetFileSize( %ws ) failed: LastError = %d\n",
                             szFileName, GetLastError()));

        goto Fail;
    }


    if ( nFileSizeLow < sizeof( SHADOWFILE ) ||
         !(pShadowFile=AllocSplMem(nFileSizeLow))) {

        goto Fail;
    }

    rc = ReadFile(hFile, pShadowFile, nFileSizeLow, &BytesRead, NULL);

    // If Shadow file is old style, then convert it to new
    if (rc && (BytesRead == nFileSizeLow) &&
        ( pShadowFile->signature == SF_SIGNATURE ||
          pShadowFile->signature == SF_SIGNATURE_2 )) {

        BOOL bStatus;

        if (!(pShadowFile3 = AllocSplMem(nFileSizeLow +
            sizeof(SHADOWFILE_3) - sizeof(SHADOWFILE))) ) {

            goto Fail;
        }

        bStatus = Old2NewShadow((PSHADOWFILE)pShadowFile, pShadowFile3, &BytesRead);
        nFileSizeLow = BytesRead;        // This is used in CheckAllPointers, below
        FreeSplMem(pShadowFile);
        pShadowFile = pShadowFile3;

        if( !bStatus ){
            goto Fail;
        }
    }

    //
    // Initial size of SF_3 must include pMachineName.
    //
    if (!rc ||
        (pShadowFile->signature != SF_SIGNATURE_3 ) ||
        (BytesRead != nFileSizeLow) ||
        (BytesRead < pShadowFile->cbSize ) ||
        (BytesRead < sizeof( SHADOWFILE_3 )) ||
        (pShadowFile->Status & (JOB_SPOOLING | JOB_PENDING_DELETION))) {

        DBGMSG(DBG_WARNING, ( "Error reading shadow job:\
                               \n\tReadFile returned %d: Error %d\
                               \n\tsignature = %08x\
                               \n\tBytes read = %d; expected %d\
                               \n\tFile size = %d; expected %d\
                               \n\tStatus = %08x %s\n",
                              rc, ( rc ? 0 : GetLastError() ),
                              pShadowFile->signature,
                              BytesRead, nFileSizeLow,
                              sizeof(*pShadowFile), pShadowFile->Size,
                              pShadowFile->Status,
                              ( (pShadowFile->Status & JOB_SPOOLING) ?
                                "Job is spooling!" : "" ) ) );

        goto Fail;
    }

    if (!CloseHandle(hFile)) {
        DBGMSG(DBG_WARNING, ("CloseHandle failed %d %d\n", hFileSpl, GetLastError()));
    }
    hFile = INVALID_HANDLE_VALUE;

    if (!CloseHandle(hFileSpl)) {
        DBGMSG(DBG_WARNING, ("CloseHandle failed %d %d\n", hFileSpl, GetLastError()));
    }
    hFileSpl = INVALID_HANDLE_VALUE;

    // Check number of reboots on this file & delete if too many
    if (pShadowFile->dwReboots > 1) {
        DBGMSG(DBG_WARNING, ("Corrupt shadow file %ws\n", szFileName));

        if ( pShadowFile->pDocument && pShadowFile->pDriverName ) {
            SplLogEvent(pIniSpooler,
                        LOG_ERROR,
                        MSG_BAD_JOB,
                        FALSE,
                        pShadowFile->pDocument + (ULONG_PTR)pShadowFile/sizeof(*pShadowFile->pDocument),
                        pShadowFile->pDriverName + (ULONG_PTR)pShadowFile/sizeof(*pShadowFile->pDriverName),
                        NULL);
        }
        goto Fail;
    }


    if (pIniJob = AllocSplMem(sizeof(INIJOB))) {

        INITJOBREFZERO(pIniJob);

        pIniJob->signature = IJ_SIGNATURE;
        pIniJob->Status    = pShadowFile->Status & (JOB_PAUSED | JOB_REMOTE | JOB_PRINTED | JOB_COMPLETE );
        pIniJob->JobId     = pShadowFile->JobId;
        pIniJob->Priority  = pShadowFile->Priority;
        pIniJob->Submitted = pShadowFile->Submitted;
        pIniJob->StartTime = pShadowFile->StartTime;
        pIniJob->UntilTime = pShadowFile->UntilTime;
        pIniJob->Size      = pShadowFile->Size;
        pIniJob->dwValidSize = pShadowFile->dwValidSize;
        pIniJob->cPages    = pShadowFile->cPages;
        pIniJob->cbPrinted = 0;
        pIniJob->NextJobId = pShadowFile->NextJobId;
        pIniJob->dwReboots = pShadowFile->dwReboots;

        pIniJob->dwJobNumberOfPagesPerSide = 0;
        pIniJob->dwDrvNumberOfPagesPerSide = 0;
        pIniJob->cLogicalPages             = 0;
        pIniJob->cLogicalPagesPrinted      = 0;

        pIniJob->WaitForWrite = NULL;
        pIniJob->WaitForRead  = NULL;
        pIniJob->hWriteFile   = INVALID_HANDLE_VALUE;

        // Additional fields for SeekPrinter.
        pIniJob->WaitForSeek  = NULL;
        pIniJob->bWaitForEnd  = FALSE;
        pIniJob->bWaitForSeek = FALSE;
        pIniJob->liFileSeekPosn.u.HighPart = 0;
        pIniJob->liFileSeekPosn.u.LowPart  = 0;

        SetPointer(pShadowFile, pDatatype);
        SetPointer(pShadowFile, pNotify);
        SetPointer(pShadowFile, pUser);
        SetPointer(pShadowFile, pDocument);
        SetPointer(pShadowFile, pOutputFile);
        SetPointer(pShadowFile, pPrinterName);
        SetPointer(pShadowFile, pDriverName);
        SetPointer(pShadowFile, pPrintProcName);
        SetPointer(pShadowFile, pParameters);
        SetPointer(pShadowFile, pMachineName);

        if( (pShadowFile->cbSecurityDescriptor > 0) && pShadowFile->pSecurityDescriptor )
            pShadowFile->pSecurityDescriptor = (PSECURITY_DESCRIPTOR)((LPBYTE)pShadowFile +
                                                 (ULONG_PTR)pShadowFile->pSecurityDescriptor);

        if (pShadowFile->pDevMode)
            pShadowFile->pDevMode = (LPDEVMODEW)((LPBYTE)pShadowFile +
                                                 (ULONG_PTR)pShadowFile->pDevMode);


        // check the length of the embedded strings as well as DevMode and Security structs.
        if( !CheckAllPointers( pShadowFile, nFileSizeLow )) {
            DBGMSG( DBG_WARNING, ("CheckAllPointers() failed; bad shadow file %ws\n", pFindFileData->cFileName ));

            DELETEJOBREF(pIniJob);
            FreeSplMem(pIniJob);

            goto Fail;
        }

        //
        //  Discard any jobs which were NT JNL 1.000 since the fonts might not
        //                   be correct

        if ( pShadowFile->pDatatype != NULL ) {
            if (!lstrcmpi( pShadowFile->pDatatype, L"NT JNL 1.000" )) {

                DBGMSG(DBG_WARNING, ("Deleteing job Datatype %ws %ws %ws\n",
                                      pShadowFile->pDatatype,
                                      pFindFileData->cFileName, szFileName));
                DELETEJOBREF(pIniJob);
                FreeSplMem(pIniJob);
                goto Fail;
            }
        }

        pIniJob->pIniDriver = (PINIDRIVER)FindLocalDriver(pIniSpooler, pShadowFile->pDriverName);

        if ((pIniJob->pIniPrinter = FindPrinter(pShadowFile->pPrinterName,pIniSpooler)) &&
             pIniJob->pIniDriver &&
            (pIniJob->pIniPrintProc = FindPrintProc(pShadowFile->pPrintProcName, FindEnvironment(szEnvironment, pIniSpooler)))) {


            // Notice that MaxJobId is really the number of job slots in the pJobIdMap, so
            // the maximum job id we can allow is (MaxJobId - 1).
            if (pIniJob->JobId >= MaxJobId( pIniSpooler->hJobIdMap )) {
                // If the job id is too huge (i.e. from a corrupt file) then we might allocate
                // too much unnecessary memory for the JobIdMap!
                // Notice we need to ask for (JobId+1) number of slots in the map!.
                if( !ReallocJobIdMap( pIniSpooler->hJobIdMap,
                                      pIniJob->JobId + 1 )) {

                    // probably a bad job id, dump the job!
                    DBGMSG( DBG_WARNING, ("Failed to alloc JobIdMap in ShadowFile %ws for JobId %d\n", pFindFileData->cFileName, pIniJob->JobId ));

                    DELETEJOBREF(pIniJob);
                    FreeSplMem(pIniJob);

                    goto Fail;
                }
            }
            else {

                if( bBitOn( pIniSpooler->hJobIdMap, pIniJob->JobId )) {

                    // A bad job id from a corrupt shadowfile; dump the job!
                    DBGMSG( DBG_WARNING, ("Duplicate Job Id in ShadowFile %ws for JobId %d\n", pFindFileData->cFileName, pIniJob->JobId ));

                    DELETEJOBREF(pIniJob);
                    FreeSplMem(pIniJob);

                    goto Fail;
                }
            }

            SPLASSERT( pIniSpooler->hJobIdMap != NULL );
            vMarkOn( pIniSpooler->hJobIdMap, pIniJob->JobId);

            pIniJob->pIniPrinter->cJobs++;
            pIniJob->pIniPrinter->cTotalJobs++;

            INCDRIVERREF( pIniJob->pIniDriver );

            pIniJob->pIniPrintProc->cRef++;
            pIniJob->pIniPort = NULL;


            if (pShadowFile->pSecurityDescriptor) {

                if (pIniJob->pSecurityDescriptor=LocalAlloc(LPTR,
                                           pShadowFile->cbSecurityDescriptor))
                    memcpy(pIniJob->pSecurityDescriptor,
                           pShadowFile->pSecurityDescriptor,
                           pShadowFile->cbSecurityDescriptor);
                else
                    DBGMSG(DBG_WARNING, ("Failed to alloc ini job security descriptor.\n"));
            }

            if (pShadowFile->pDevMode) {

                cb=pShadowFile->pDevMode->dmSize +
                                pShadowFile->pDevMode->dmDriverExtra;
                if (pIniJob->pDevMode=AllocSplMem(cb))
                    memcpy(pIniJob->pDevMode, pShadowFile->pDevMode, cb);
                else
                    DBGMSG(DBG_WARNING, ("Failed to alloc ini job devmode.\n"));
            }

            pIniJob->pNotify      = AllocSplStr( pShadowFile->pNotify);
            pIniJob->pUser        = AllocSplStr( pShadowFile->pUser);
            pIniJob->pDocument    = AllocSplStr( pShadowFile->pDocument);
            pIniJob->pOutputFile  = AllocSplStr( pShadowFile->pOutputFile);
            pIniJob->pDatatype    = AllocSplStr( pShadowFile->pDatatype);
            pIniJob->pParameters  = AllocSplStr( pShadowFile->pParameters);

            if( pShadowFile->pMachineName ){
                pIniJob->pMachineName = AllocSplStr( pShadowFile->pMachineName );
            } else {
                pIniJob->pMachineName = AllocSplStr( pIniSpooler->pMachineName );
            }

            //
            // FP Change
            // Add the files to the File pool if it's not KeepPrintedJobs, and
            // if the printer does not have its own spool directory.
            //
            if (!(pIniJob->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS) &&
                  pIniJob->pIniPrinter->pSpoolDir == NULL)
            {
                pIniJob->pszSplFileName = AllocSplStr( szFileName );

                if ((pIniJob->pIniPrinter->pIniSpooler->hFilePool != INVALID_HANDLE_VALUE)
                    && pIniJob->pszSplFileName && SUCCEEDED(ConvertFileExt(pIniJob->pszSplFileName, L".SHD", L".SPL")))
                {
                    if (FAILED(GetFileItemHandle(
                                     pIniJob->pIniPrinter->pIniSpooler->hFilePool,
                                     &pIniJob->hFileItem,
                                     pIniJob->pszSplFileName )))
                    {
                        pIniJob->hFileItem = INVALID_HANDLE_VALUE;
                        FreeSplStr(pIniJob->pszSplFileName);
                        pIniJob->pszSplFileName = NULL;
                    }
                }
                else
                {
                    FreeSplStr(pIniJob->pszSplFileName);
                    pIniJob->pszSplFileName = NULL;
                }
            }
            else
            {
                pIniJob->pszSplFileName = NULL;
                pIniJob->hFileItem = INVALID_HANDLE_VALUE;
            }


            pIniJob->pIniNextJob = NULL;
            pIniJob->pStatus = NULL;

            if (pIniJob->pIniPrevJob = pIniJob->pIniPrinter->pIniLastJob)
                pIniJob->pIniPrevJob->pIniNextJob=pIniJob;

            if (!pIniJob->pIniPrinter->pIniFirstJob)
                pIniJob->pIniPrinter->pIniFirstJob = pIniJob;

            pIniJob->pIniPrinter->pIniLastJob=pIniJob;

        } else {

            DBGMSG( DBG_WARNING, ("Failed to find printer %ws\n",pShadowFile->pPrinterName));

            DELETEJOBREF(pIniJob);
            FreeSplMem(pIniJob);

            goto Fail;
        }

    } else {

        DBGMSG(DBG_WARNING, ("Failed to allocate ini job.\n"));
    }

    FreeSplMem( pShadowFile );

    return pIniJob;

Fail:

    if (pShadowFile) {
        FreeSplMem(pShadowFile);
    }

    if (hFile != INVALID_HANDLE_VALUE && !CloseHandle(hFile)) {
        DBGMSG(DBG_WARNING, ("CloseHandle failed %d %d\n", hFile, GetLastError()));
    }
    if (hFileSpl != INVALID_HANDLE_VALUE && !CloseHandle(hFileSpl)) {
        DBGMSG(DBG_WARNING, ("CloseHandle failed %d %d\n", hFileSpl, GetLastError()));
    }

    DeleteFile(szFileName);

    wcscpy(pFileSpec, pFindFileData->cFileName);
    DeleteFile(szFileName);

    return FALSE;
}


BOOL
Old2NewShadow(
    PSHADOWFILE   pShadowFile1,
    PSHADOWFILE_3 pShadowFile3,
    DWORD         *pnBytes
    )

/*++

Routine Description:

    Converts an original format *.shd file to a new format (version 2).

Arguments:

    pShadowFile1 -- pointer to version 1 shadow file

    pShadowFile2 -- pointer to version 2 shadow file

    *pnBytes      -- pointer to number of bytes read from version 1 shadow file.  On
                    return, pnBytes contains the number of bytes in the version 2 shadow file.

Return Value:

    None


Author: Steve Wilson (NT)

--*/

{
    DWORD cbOld;
    DWORD cbDiff;

    switch( pShadowFile1->signature ){
    case SF_SIGNATURE:
        cbOld = sizeof( SHADOWFILE );
        cbDiff = sizeof( SHADOWFILE_3 ) - sizeof( SHADOWFILE );
        break;
    case SF_SIGNATURE_2:
        cbOld = sizeof ( SHADOWFILE_2 );
        cbDiff = sizeof( SHADOWFILE_3 ) - sizeof( SHADOWFILE_2 );
        break;
    default:
        return FALSE;
    }

    if( *pnBytes < cbOld ){
        return FALSE;
    }

    //
    // Copy everything except signature.
    //
    MoveMemory((PVOID)(&pShadowFile3->Status),
               (PVOID)(&pShadowFile1->Status),
               cbOld - sizeof( pShadowFile1->signature ));

    //
    // Now update signature and size.
    //
    pShadowFile3->signature = SF_SIGNATURE_3;
    pShadowFile3->cbSize = *pnBytes + cbDiff;

    //
    // Move strings.
    //
    MoveMemory( (PVOID)(pShadowFile3 + 1),
                ((PBYTE)pShadowFile1) + cbOld,
                *pnBytes - cbOld );

    pShadowFile3->pNotify += pShadowFile1->pNotify ? cbDiff/sizeof *pShadowFile1->pNotify : 0;
    pShadowFile3->pUser += pShadowFile1->pUser ? cbDiff/sizeof *pShadowFile1->pUser  : 0;
    pShadowFile3->pDocument += pShadowFile1->pDocument ? cbDiff/sizeof *pShadowFile3->pDocument : 0;
    pShadowFile3->pOutputFile += pShadowFile1->pOutputFile ? cbDiff/sizeof *pShadowFile3->pOutputFile : 0;
    pShadowFile3->pPrinterName += pShadowFile1->pPrinterName ? cbDiff/sizeof *pShadowFile3->pPrinterName : 0;
    pShadowFile3->pDriverName += pShadowFile1->pDriverName ? cbDiff/sizeof *pShadowFile3->pDriverName : 0;
    pShadowFile3->pPrintProcName += pShadowFile1->pPrintProcName ? cbDiff/sizeof *pShadowFile3->pPrintProcName : 0;
    pShadowFile3->pDatatype += pShadowFile1->pDatatype ? cbDiff/sizeof *pShadowFile3->pDatatype : 0;
    pShadowFile3->pParameters += pShadowFile1->pParameters ? cbDiff/sizeof *pShadowFile3->pParameters : 0;

    pShadowFile3->pDevMode = (PDEVMODE) (pShadowFile1->pDevMode ?
                             (ULONG_PTR) pShadowFile1->pDevMode + cbDiff : 0);

    pShadowFile3->pSecurityDescriptor = (PSECURITY_DESCRIPTOR) (pShadowFile1->pSecurityDescriptor ?
                                        (ULONG_PTR) pShadowFile1->pSecurityDescriptor + cbDiff : 0);

    pShadowFile3->Version = SF_VERSION_3;

    //
    // The first shadow file didn't have dwReboots.
    //
    if( pShadowFile1->signature == SF_SIGNATURE ){
        pShadowFile3->dwReboots = 0;
    }

    pShadowFile3->pMachineName = NULL;

    *pnBytes += cbDiff;

    return TRUE;
}


PINIVERSION
GetVersionDrivers(
    HKEY hDriversKey,
    LPWSTR szVersionName,
    PINISPOOLER pIniSpooler,
    PINIENVIRONMENT pIniEnvironment
    )
{
    HKEY hVersionKey;
    WCHAR szDirectoryValue[MAX_PATH];
    PINIDRIVER pIniDriver;
    DWORD cMajorVersion, cMinorVersion;
    DWORD cbData;
    DWORD Type;
    PINIVERSION pIniVersion = NULL;

    if (SplRegOpenKey(hDriversKey, szVersionName, KEY_READ, &hVersionKey, pIniSpooler) != ERROR_SUCCESS)
    {
        DBGMSG(DBG_TRACE, ("GetVersionDrivers SplRegOpenKey on "TSTR" failed\n", szVersionName));
        return NULL;
    }

    cbData = sizeof(szDirectoryValue);

    if (SplRegQueryValue(hVersionKey, szDirectory, &Type, (LPBYTE)szDirectoryValue, &cbData, pIniSpooler)!=ERROR_SUCCESS)
    {
        DBGMSG(DBG_TRACE, ("Couldn't query for directory in version structure\n"));
        goto Done;
    }

    cbData = sizeof(DWORD);

    if (SplRegQueryValue(hVersionKey, szMajorVersion, &Type, (LPBYTE)&cMajorVersion, &cbData, pIniSpooler)!=ERROR_SUCCESS)
    {
        DBGMSG(DBG_TRACE, ("Couldn't query for major version in version structure\n"));
        goto Done;
    }

    cbData = sizeof(DWORD);

    if (SplRegQueryValue(hVersionKey, szMinorVersion, &Type, (LPBYTE)&cMinorVersion, &cbData, pIniSpooler)!=ERROR_SUCCESS)
    {
        DBGMSG(DBG_TRACE, ("Couldn't query for minor version in version structure\n"));
        goto Done;
    }

    DBGMSG(DBG_TRACE, ("Got all information to build the version entry\n"));

    //
    // Now build the version node structure.
    //
    pIniVersion = AllocSplMem(sizeof(INIVERSION));

    if( pIniVersion ){

        pIniVersion->signature     = IV_SIGNATURE;
        pIniVersion->pName         = AllocSplStr(szVersionName);
        pIniVersion->szDirectory   = AllocSplStr(szDirectoryValue);
        pIniVersion->cMajorVersion = cMajorVersion;
        pIniVersion->cMinorVersion = cMinorVersion;
        pIniVersion->pDrvRefCnt    = NULL;

        if (!pIniVersion->pName || !pIniVersion->szDirectory) {
            FreeIniVersion(pIniVersion);
            pIniVersion = NULL;
        } else {

            pIniDriver = GetDriverList(hVersionKey,
                                       pIniSpooler,
                                       pIniEnvironment,
                                       pIniVersion);

            pIniVersion->pIniDriver  = pIniDriver;

            while (pIniDriver) {
                if (!UpdateDriverFileRefCnt(pIniEnvironment,pIniVersion,pIniDriver,NULL,0,TRUE)) {
                    FreeIniVersion(pIniVersion);
                    pIniVersion = NULL;
                    break;
                }
                pIniDriver = pIniDriver->pNext;
            }
        }
    }


Done:
    SplRegCloseKey(hVersionKey, pIniSpooler);
    return pIniVersion;
}

/*++

Routine Name:

    FreeIniDriver

Routine Description:

    This handles the memory in an inidriver after first decrementing the driver
    ref-count correctly.

Arguments:

    pIniEnvironment     -   The environment of the driver.
    pIniVersion         -   The version of the driver.
    pIniDriver          -   The driver to delete.


Return Value:

    None.

--*/
VOID
FreeIniDriver(
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      PINIDRIVER          pIniDriver
    )
{
    if (pIniEnvironment && pIniVersion && pIniDriver)
    {
        //
        // This is to reverse the ref-count for when the spooler is first created.
        //
        UpdateDriverFileRefCnt(pIniEnvironment, pIniVersion, pIniDriver, NULL, 0, FALSE);

        //
        // The monitors will be deleted shortly. So we don't need to worry about
        // the language monitors.
        //
        FreeStructurePointers((LPBYTE) pIniDriver, NULL, IniDriverOffsets);
        FreeSplMem(pIniDriver);
    }
}

/*++

Routine Name:

    FreeIniVersion

Routine Description:

    This frees all the memory in an ini-version without handling either the
    drivers or the driver ref-counts in it.

Arguments:

    pIniVersion         -   The version to delete.

Return Value:

    None.

--*/
VOID
FreeIniVersion(
    IN      PINIVERSION pIniVersion
    )
{
    PDRVREFCNT pdrc,pdrctemp;

    FreeSplStr( pIniVersion->pName );
    FreeSplStr( pIniVersion->szDirectory );

    pdrc = pIniVersion->pDrvRefCnt;

    while (pdrc) {
       FreeSplStr(pdrc->szDrvFileName);
       pdrctemp = pdrc->pNext;
       FreeSplMem(pdrc);
       pdrc = pdrctemp;
    }

    FreeSplMem( pIniVersion );
}

/*++

Routine Name:

    DeleteIniVersion

Routine Description:

    This runs all of the drivers in an iniVersion and then calls FreeIniVersion
    to free the contents of the iniversion.

Arguments:

    pIniEnvironment     -   The environment used for handling driver ref-counts.
    pIniVersion         -   The version to delete.

Return Value:

    None.

--*/
VOID
DeleteIniVersion(
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion
    )
{
    if (pIniVersion && pIniEnvironment)
    {
        PINIDRIVER  pIniDriver      = NULL;
        PINIDRIVER  pNextIniDriver  = NULL;

        for(pIniDriver = pIniVersion->pIniDriver; pIniDriver; pIniDriver = pNextIniDriver)
        {
            pNextIniDriver = pIniDriver->pNext;

            FreeIniDriver(pIniEnvironment, pIniVersion, pIniDriver);
        }

        FreeIniVersion(pIniVersion);
    }
}

/*++

Routine Name:

    FreeIniEnvironment

Routine Description:

    This runs all of the ini-versions in an environvironment
    and then deletes the environment.

Arguments:

    pIniEnvironment     -   The environment to free.

Return Value:

    None.

--*/
VOID
FreeIniEnvironment(
    IN      PINIENVIRONMENT     pIniEnvironment
    )
{
    if (pIniEnvironment)
    {
        PINIVERSION pIniVersion     = NULL;
        PINIVERSION pNextIniVersion = NULL;

        for(pIniVersion = pIniEnvironment->pIniVersion; pIniVersion; pIniVersion = pNextIniVersion)
        {
            pNextIniVersion = pIniVersion->pNext;

            DeleteIniVersion(pIniEnvironment, pIniVersion);
        }

        FreeIniPrintProc(pIniEnvironment->pIniPrintProc);
        FreeStructurePointers((LPBYTE)pIniEnvironment, NULL, IniEnvironmentOffsets);
        FreeSplMem(pIniEnvironment);
    }
}

/*++

Routine Name:

    FreeIniPrintProc

Routine Description:

    This deletes all of the print processor fields.

Arguments:

    pIniPrintProc   -   The print processor to delete.

Return Value:

    None.

--*/
VOID
FreeIniPrintProc(
    IN      PINIPRINTPROC       pIniPrintProc
    )
{
    if (pIniPrintProc)
    {
        FreeLibrary(pIniPrintProc->hLibrary);
        DeleteCriticalSection(&pIniPrintProc->CriticalSection);
        FreeStructurePointers((LPBYTE)pIniPrintProc, NULL, IniPrintProcOffsets);
        FreeSplMem(pIniPrintProc);
    }
}

PINIDRIVER
GetDriverList(
    HKEY hVersionKey,
    PINISPOOLER pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion
    )
{
    PINIDRIVER pIniDriverList = NULL;
    DWORD      cDrivers = 0;
    PINIDRIVER pIniDriver;
    WCHAR      DriverName[MAX_PATH];
    DWORD      cchBuffer =0;

    pIniDriverList = NULL;

    cchBuffer = COUNTOF(DriverName);

    while (SplRegEnumKey(hVersionKey, cDrivers++, DriverName, &cchBuffer, NULL, pIniSpooler) == ERROR_SUCCESS)
    {
        cchBuffer = COUNTOF(DriverName);

        DBGMSG(DBG_TRACE, ("Found a driver - "TSTR"\n", DriverName));

        pIniDriver = GetDriver(hVersionKey, DriverName, pIniSpooler, pIniEnvironment, pIniVersion);

        if (pIniDriver != NULL)
        {
            pIniDriver->pNext = pIniDriverList;
            pIniDriverList    = pIniDriver;
        }

        //
        // On a cluster, a driver may have changed while the cluster spooler
        // was hosted by another node. Here we check if we need to update or
        // add a new driver
        //
        if (pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER &&
            ClusterCheckDriverChanged(hVersionKey,
                                      DriverName,
                                      pIniEnvironment->pName,
                                      pIniVersion->pName,
                                      pIniSpooler))
        {
            DWORD dwError;

            //
            // Add or update the driver.
            //
            LeaveSplSem();

            if ((dwError = ClusterAddOrUpdateDriverFromClusterDisk(hVersionKey,
                                                                   DriverName,
                                                                   pIniEnvironment->pName,
                                                                   pIniEnvironment->pDirectory,
                                                                   pIniSpooler)) != ERROR_SUCCESS)

            {
                WCHAR szError[20];

                DBGMSG(DBG_CLUSTER, ("GetDriverList failed to add/update driver "TSTR". Win32 error %u\n",
                                     DriverName, dwError));

                wsprintf(szError, L"%u", dwError);

                SplLogEvent(pIniSpooler,
                            LOG_ERROR,
                            MSG_CANT_ADD_UPDATE_CLUSTER_DRIVER,
                            FALSE,
                            DriverName,
                            pIniSpooler->pMachineName,
                            szError,
                            NULL);
            }

            EnterSplSem();
        }
    }

    return pIniDriverList;
}


PINIDRIVER
GetDriver(
    HKEY hVersionKey,
    LPWSTR DriverName,
    PINISPOOLER pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion
)
{
    HKEY        hDriverKey = NULL;
    DWORD       Type;
    WCHAR       szData[MAX_PATH];
    WCHAR       szTempDir[MAX_PATH];
    DWORD       cbData;
    DWORD       Version;
    DWORD       DriverAttributes;
    LPWSTR      pConfigFile, pDataFile, pDriver;
    LPWSTR      pHelpFile, pMonitorName, pDefaultDataType, pDependentFiles, pTemp;
    LPWSTR      pDriverName, pszzPreviousNames;
    LPWSTR      pszMfgName, pszOEMUrl, pszHardwareID, pszProvider;
    FILETIME    DriverDate;
    DWORDLONG   DriverVersion;
    PINIDRIVER  pIniDriver = NULL;
    DWORD       cb, cLen, cchDependentFiles = 0, cchPreviousNames = 0;
    DWORD       dwTempDir, dwLastError = ERROR_SUCCESS;

    pDriverName = pConfigFile = pDataFile = pDriver = pHelpFile = pTemp = NULL;
    pMonitorName = pDefaultDataType = pDependentFiles = pszzPreviousNames = NULL;
    pszMfgName = pszOEMUrl = pszHardwareID =  pszProvider = NULL;

    if ((dwLastError = SplRegOpenKey(hVersionKey, DriverName, KEY_READ, &hDriverKey, pIniSpooler)) != ERROR_SUCCESS) {
        goto Fail;
    }
    else {

        if ( !(pDriverName=AllocSplStr(DriverName)) ) {
            dwLastError = GetLastError();
            goto Fail;
        }

        RegGetString( hDriverKey, szConfigurationKey, &pConfigFile, &cLen, &dwLastError, TRUE, pIniSpooler );
        if (!pConfigFile) {
            goto Fail;
        }

        RegGetString( hDriverKey, szDataFileKey, &pDataFile, &cLen, &dwLastError, TRUE, pIniSpooler );
        if ( !pDataFile ) {
            goto Fail;
        }

        RegGetString( hDriverKey, szDriverFile, &pDriver, &cLen, &dwLastError, TRUE, pIniSpooler );
        if ( !pDriver ) {
            goto Fail;
        }

        RegGetString( hDriverKey, szHelpFile,  &pHelpFile, &cLen, &dwLastError, FALSE, pIniSpooler );

        RegGetString( hDriverKey, szMonitor, &pMonitorName, &cLen, &dwLastError, FALSE, pIniSpooler );

        RegGetString( hDriverKey, szDatatype, &pDefaultDataType, &cLen, &dwLastError, FALSE, pIniSpooler );

        RegGetMultiSzString( hDriverKey, szDependentFiles, &pDependentFiles, &cchDependentFiles, &dwLastError, FALSE, pIniSpooler );

        RegGetMultiSzString( hDriverKey, szPreviousNames, &pszzPreviousNames, &cchPreviousNames, &dwLastError, FALSE, pIniSpooler );

        RegGetString( hDriverKey, szMfgName, &pszMfgName, &cLen, &dwLastError, FALSE, pIniSpooler );

        RegGetString( hDriverKey, szOEMUrl, &pszOEMUrl, &cLen, &dwLastError, FALSE, pIniSpooler );

        RegGetString( hDriverKey, szHardwareID, &pszHardwareID, &cLen, &dwLastError, TRUE, pIniSpooler );

        RegGetString( hDriverKey, szProvider, &pszProvider, &cLen, &dwLastError, TRUE, pIniSpooler );

        cbData = sizeof(DriverDate);
        if (SplRegQueryValue(hDriverKey, szDriverDate, NULL, (LPBYTE)&DriverDate, &cbData, pIniSpooler)!=ERROR_SUCCESS)
        {
            //
            // don't leave the data uninitialized
            //
            DriverDate.dwLowDateTime = DriverDate.dwHighDateTime = 0;
        }

        cbData = sizeof(DriverVersion);
        if (SplRegQueryValue(hDriverKey, szLongVersion, NULL, (LPBYTE)&DriverVersion, &cbData, pIniSpooler)!=ERROR_SUCCESS)
        {
            //
            // don't leave the data uninitialized
            //
            DriverVersion = 0;
        }

        // Retrieve the version number
        cbData = sizeof(DWORD);
        if (SplRegQueryValue(hDriverKey, szDriverAttributes, &Type, (LPBYTE)&DriverAttributes, &cbData, pIniSpooler) != ERROR_SUCCESS)
        {
             DriverAttributes = 0;
        }

        // Retrieve the version number
        cbData = sizeof(DWORD);
        if (SplRegQueryValue(hDriverKey, szDriverVersion, &Type, (LPBYTE)&Version, &cbData, pIniSpooler) != ERROR_SUCCESS)
        {
             Version = 0;
        }

        // Retrieve the TempDir number
        cbData = sizeof(DWORD);
        if (SplRegQueryValue(hDriverKey, szTempDir, &Type, (LPBYTE)&dwTempDir, &cbData, pIniSpooler) != ERROR_SUCCESS)
        {
             dwTempDir = 0;
        }

        // After REBOOT temp directories are deleted. So check for the presence of the
        // directory on spooler startup.
        if (dwTempDir && pIniEnvironment && pIniVersion)
        {
           _itow(dwTempDir,szTempDir,10);
           if(StrNCatBuff(szData,
                         COUNTOF(szData),
                         pIniSpooler->pDir,
                         L"\\drivers\\",
                         pIniEnvironment->pDirectory,
                         L"\\",
                         pIniVersion->szDirectory,
                         L"\\",
                         szTempDir,
                         NULL) == ERROR_SUCCESS)
           {
               if (!DirectoryExists(szData))
               {
                   // Files must have been moved in Reboot, reset dwTempDir to 0
                   dwTempDir = 0;
               }
           }
        }

        SplRegCloseKey(hDriverKey, pIniSpooler);
    }

    //
    // Win95 driver needs every file as a dependent file for point and print.
    // For others we eliminate duplicates
    //
    if ( pIniEnvironment && _wcsicmp(pIniEnvironment->pName, szWin95Environment) ) {

        pTemp = pDependentFiles;
        pDependentFiles = NULL;

        if ( !BuildTrueDependentFileField(pDriver,
                                          pDataFile,
                                          pConfigFile,
                                          pHelpFile,
                                          pTemp,
                                          &pDependentFiles) )
            goto Fail;

        FreeSplMem(pTemp);
        for ( pTemp = pDependentFiles ; pTemp && *pTemp ;
              pTemp += wcslen(pTemp) + 1 )
        ;

        if ( pTemp )
            cchDependentFiles = (DWORD) (pTemp - pDependentFiles + 1);
        else
            cchDependentFiles = 0;
    }

    cb = sizeof( INIDRIVER );

    if ( pIniDriver = AllocSplMem( cb )) {

        pIniDriver->signature               = ID_SIGNATURE;
        pIniDriver->pName                   = pDriverName;
        pIniDriver->pDriverFile             = pDriver;
        pIniDriver->pDataFile               = pDataFile;
        pIniDriver->pConfigFile             = pConfigFile;
        pIniDriver->cVersion                = Version;
        pIniDriver->pHelpFile               = pHelpFile;
        pIniDriver->pMonitorName            = pMonitorName;
        pIniDriver->pDefaultDataType        = pDefaultDataType;
        pIniDriver->pDependentFiles         = pDependentFiles;
        pIniDriver->cchDependentFiles       = cchDependentFiles;
        pIniDriver->pszzPreviousNames       = pszzPreviousNames;
        pIniDriver->cchPreviousNames        = cchPreviousNames;
        pIniDriver->dwTempDir               = dwTempDir;
        pIniDriver->pszMfgName              = pszMfgName;
        pIniDriver->pszOEMUrl               = pszOEMUrl;
        pIniDriver->pszHardwareID           = pszHardwareID;
        pIniDriver->pszProvider             = pszProvider;
        pIniDriver->dwlDriverVersion        = DriverVersion;
        pIniDriver->ftDriverDate            = DriverDate;
        pIniDriver->dwDriverAttributes      = DriverAttributes;
        pIniDriver->DriverFileMinorVersion  = 0;
        pIniDriver->DriverFileMajorVersion  = 0;

        DBGMSG( DBG_TRACE, ("Data for driver %ws created:\
                             \n\tpDriverFile:\t%ws\
                             \n\tpDataFile:\t%ws\
                             \n\tpConfigFile:\t%ws\n\n",
                             pDriverName, pDriver, pDataFile, pConfigFile));

        if ( pIniDriver->pMonitorName && *pIniDriver->pMonitorName ) {

            //
            // Don't we add ref the monitor here?
            //
            pIniDriver->pIniLangMonitor = FindMonitor(pIniDriver->pMonitorName, pIniSpooler);

            //
            // Cluster spoolers do not have keep their own lists of language monitors.
            // This is because most language monitors are not cluster aware. Therefore,
            // cluster spooler share language monitors with the local spooler.
            //
            if (pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER &&
                !pIniDriver->pIniLangMonitor                 &&
                pLocalIniSpooler)
            {
                //
                // We try to find the langauge monitor off the local spooler
                //
                pIniDriver->pIniLangMonitor = FindMonitor(pIniDriver->pMonitorName, pLocalIniSpooler);
            }

            if (!pIniDriver->pIniLangMonitor)
            {
                DBGMSG(DBG_TRACE, ("Can't find print monitor %ws\n", pIniDriver->pMonitorName));
            }

        }

        return pIniDriver;
    }


Fail:

        FreeSplStr( pDriverName );
        FreeSplStr( pConfigFile );
        FreeSplStr( pDataFile );
        FreeSplStr( pHelpFile );
        FreeSplStr( pMonitorName );
        FreeSplStr( pDefaultDataType );
        FreeSplStr( pDependentFiles );
        FreeSplStr( pszzPreviousNames );
        FreeSplStr( pDriver );
        FreeSplStr( pTemp);
        FreeSplStr( pszMfgName);
        FreeSplStr( pszOEMUrl);
        FreeSplStr( pszProvider);
        FreeSplStr( pszHardwareID);

        if( hDriverKey ) {
            SplRegCloseKey(hDriverKey, pIniSpooler);
        }

        SetLastError( dwLastError );
        return NULL;
}

PINIDRIVER
FindLocalDriver(
    PINISPOOLER pIniSpooler,
    LPWSTR      pz
)
{
    PINIVERSION pIniVersion;

    if ( !pz || !*pz ) {
        return NULL;
    }

    //
    // During Upgrade we load any driver so we have a valid printer, which might not be able to boot.
    //
    return FindCompatibleDriver(GetLocalArchEnv(pIniSpooler),
                                &pIniVersion,
                                pz,
                                dwMajorVersion,
                                dwUpgradeFlag);
}


BOOL
FindLocalDriverAndVersion(
    PINISPOOLER pIniSpooler,
    LPWSTR      pz,
    PINIDRIVER  *ppIniDriver,
    PINIVERSION *ppIniVersion
)
{
    if ( !pz || !*pz || !ppIniDriver || !ppIniVersion) {
        return FALSE;
    }

    //
    // During Upgrade we load any driver so we have a valid printer, which might not be able to boot.
    //
    *ppIniDriver = FindCompatibleDriver( GetLocalArchEnv(pIniSpooler),
                                         ppIniVersion,
                                         pz,
                                         dwMajorVersion,
                                         dwUpgradeFlag );

    if ( !*ppIniDriver || !*ppIniVersion ) {

        return FALSE;
    }

    return TRUE;
}

#if DBG
VOID
InitializeDebug(
    PINISPOOLER pIniSpooler
)
{
    DWORD   Status;
    HKEY    hKey = pIniSpooler->hckRoot;
    DWORD   cbData;
    INT     TimeOut = 60;

    cbData = sizeof(DWORD);

    Status = SplRegQueryValue( hKey,
                               szDebugFlags,
                               NULL,
                               (LPBYTE)&MODULE_DEBUG,
                               &cbData,
                               pIniSpooler );

    // Wait until someone turns off the Pause Flag

    if ( Status != NO_ERROR )
        return;

    while ( MODULE_DEBUG & DBG_PAUSE ) {
        Sleep(1*1000);
        if ( TimeOut-- == 0)
            break;
    }

    DBGMSG(DBG_TRACE, ("DebugFlags %x\n", MODULE_DEBUG));
}
#endif



VOID
GetPrintSystemVersion(
    PINISPOOLER pIniSpooler
    )
{
    DWORD Status;
    HKEY hKey;
    DWORD cbData;

    hKey = pIniSpooler->hckRoot;

    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, szMinorVersion, NULL, NULL,
                                           (LPBYTE)&dwMinorVersion, &cbData);
    DBGMSG(DBG_TRACE, ("This Minor Version - %d\n", dwMinorVersion));



    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, L"FastPrintWaitTimeout", NULL, NULL,
                                      (LPBYTE)&dwFastPrintWaitTimeout, &cbData);
    DBGMSG(DBG_TRACE, ("dwFastPrintWaitTimeout - %d\n", dwFastPrintWaitTimeout));



    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, L"FastPrintThrottleTimeout", NULL, NULL,
                                  (LPBYTE)&dwFastPrintThrottleTimeout, &cbData);
    DBGMSG(DBG_TRACE, ("dwFastPrintThrottleTimeout - %d\n", dwFastPrintThrottleTimeout));



    // If the values look invalid use Defaults

    if (( dwFastPrintThrottleTimeout == 0) ||
        ( dwFastPrintWaitTimeout < dwFastPrintThrottleTimeout)) {

        DBGMSG( DBG_WARNING, ("Bad timeout values FastPrintThrottleTimeout %d FastPrintWaitTimeout %d using defaults\n",
                           dwFastPrintThrottleTimeout, dwFastPrintWaitTimeout));

        dwFastPrintThrottleTimeout = FASTPRINT_THROTTLE_TIMEOUT;
        dwFastPrintWaitTimeout = FASTPRINT_WAIT_TIMEOUT;

    }

    // Calculate a reasonable Threshold based on the two timeouts

    dwFastPrintSlowDownThreshold = dwFastPrintWaitTimeout / dwFastPrintThrottleTimeout;


    // FastPrintSlowDownThreshold
    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, L"FastPrintSlowDownThreshold", NULL, NULL,
                                (LPBYTE)&dwFastPrintSlowDownThreshold, &cbData);
    DBGMSG(DBG_TRACE, ("dwFastPrintSlowDownThreshold - %d\n", dwFastPrintSlowDownThreshold));

    // PortThreadPriority
    cbData = sizeof dwPortThreadPriority;
    Status = RegQueryValueEx(hKey, SPLREG_PORT_THREAD_PRIORITY, NULL, NULL,
                             (LPBYTE)&dwPortThreadPriority, &cbData);

    if (Status != ERROR_SUCCESS ||
       (dwPortThreadPriority != THREAD_PRIORITY_LOWEST          &&
        dwPortThreadPriority != THREAD_PRIORITY_BELOW_NORMAL    &&
        dwPortThreadPriority != THREAD_PRIORITY_NORMAL          &&
        dwPortThreadPriority != THREAD_PRIORITY_ABOVE_NORMAL    &&
        dwPortThreadPriority != THREAD_PRIORITY_HIGHEST)) {

        dwPortThreadPriority = DEFAULT_PORT_THREAD_PRIORITY;

        SetPrinterDataServer(   pIniSpooler,
                                SPLREG_PORT_THREAD_PRIORITY,
                                REG_DWORD,
                                (LPBYTE) &dwPortThreadPriority,
                                sizeof dwPortThreadPriority
                            );
    }
    DBGMSG(DBG_TRACE, ("dwPortThreadPriority - %d\n", dwPortThreadPriority));


    // SchedulerThreadPriority
    cbData = sizeof dwSchedulerThreadPriority;
    Status = RegQueryValueEx(hKey, SPLREG_SCHEDULER_THREAD_PRIORITY, NULL, NULL,
                                   (LPBYTE)&dwSchedulerThreadPriority, &cbData);

    if (Status != ERROR_SUCCESS ||
       (dwSchedulerThreadPriority != THREAD_PRIORITY_LOWEST          &&
        dwSchedulerThreadPriority != THREAD_PRIORITY_BELOW_NORMAL    &&
        dwSchedulerThreadPriority != THREAD_PRIORITY_NORMAL          &&
        dwSchedulerThreadPriority != THREAD_PRIORITY_ABOVE_NORMAL    &&
        dwSchedulerThreadPriority != THREAD_PRIORITY_HIGHEST)) {

        dwSchedulerThreadPriority = DEFAULT_SCHEDULER_THREAD_PRIORITY;

        SetPrinterDataServer(   pIniSpooler,
                                SPLREG_SCHEDULER_THREAD_PRIORITY,
                                REG_DWORD,
                                (LPBYTE) &dwSchedulerThreadPriority,
                                sizeof dwSchedulerThreadPriority
                            );
    }
    DBGMSG(DBG_TRACE, ("dwSchedulerThreadPriority - %d\n", dwSchedulerThreadPriority));

    // WritePrinterSleepTime
    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, L"WritePrinterSleepTime", NULL, NULL,
                    (LPBYTE)&dwWritePrinterSleepTime, &cbData);
    DBGMSG(DBG_TRACE, ("dwWritePrinterSleepTime - %d\n", dwWritePrinterSleepTime));

    // ServerThreadPriority
    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, L"ServerThreadPriority", NULL, NULL,
                    (LPBYTE)&dwServerThreadPriority, &cbData);
    DBGMSG(DBG_TRACE, ("dwServerThreadPriority - %d\n", dwServerThreadPriority));

    // ServerThreadTimeout
    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, L"ServerThreadTimeout", NULL, NULL,
                    (LPBYTE)&ServerThreadTimeout, &cbData);
    DBGMSG(DBG_TRACE, ("ServerThreadTimeout - %d\n", ServerThreadTimeout));


    // EnableBroadcastSpoolerStatus

    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, L"EnableBroadcastSpoolerStatus", NULL, NULL,
                    (LPBYTE)&dwEnableBroadcastSpoolerStatus, &cbData);
    DBGMSG(DBG_TRACE, ("EnableBroadcastSpoolerStatus - %d\n",
                       dwEnableBroadcastSpoolerStatus ));

    // NetPrinterDecayPeriod
    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, L"NetPrinterDecayPeriod", NULL, NULL,
                    (LPBYTE)&NetPrinterDecayPeriod, &cbData);
    DBGMSG(DBG_TRACE, ("NetPrinterDecayPeriod - %d\n", NetPrinterDecayPeriod));


    // RefreshTimesPerDecayPeriod
    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, L"RefreshTimesPerDecayPeriod", NULL, NULL,
                    (LPBYTE)&RefreshTimesPerDecayPeriod, &cbData);
    DBGMSG(DBG_TRACE, ("RefreshTimesPerDecayPeriod - %d\n", RefreshTimesPerDecayPeriod));

    if ( RefreshTimesPerDecayPeriod == 0 ) {

        RefreshTimesPerDecayPeriod = DEFAULT_REFRESH_TIMES_PER_DECAY_PERIOD;
    }

    // BrowsePrintWorkstations
    cbData = sizeof( BrowsePrintWorkstations );
    RegQueryValueEx( hKey, L"BrowsePrintWorkstations", NULL, NULL, (LPBYTE)&BrowsePrintWorkstations, &cbData );

    DBGMSG( DBG_TRACE, ("BrowsePrintWorkstations - %d\n", BrowsePrintWorkstations ));
}

VOID
InitializeSpoolerSettings(
    PINISPOOLER pIniSpooler
    )
{
    HKEY hKey;
    HKEY hKeyProvider;
    DWORD cbData;
    DWORD dwLastError;
    DWORD Status;
    DWORD CacheMasqPrinters;

    DWORDLONG dwlConditionMask = 0;
    OSVERSIONINFOEX osvi;

    hKey = pIniSpooler->hckRoot;

    //
    // BeepEnabled
    //
    cbData = sizeof pIniSpooler->dwBeepEnabled;
    Status = SplRegQueryValue(hKey,
                              SPLREG_BEEP_ENABLED,
                              NULL,
                              (LPBYTE)&pIniSpooler->dwBeepEnabled,
                              &cbData,
                              pIniSpooler);

    if (Status!=ERROR_SUCCESS) {
        DBGMSG(DBG_TRACE, ("BeepEnabled - SplRegQueryValue failed with error %u\n", Status));
    }

    pIniSpooler->dwBeepEnabled = !!pIniSpooler->dwBeepEnabled;

    SetPrinterDataServer(pIniSpooler,
                         SPLREG_BEEP_ENABLED,
                         REG_DWORD,
                         (LPBYTE) &pIniSpooler->dwBeepEnabled,
                         sizeof pIniSpooler->dwBeepEnabled);

    if( pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){

        //
        // Restart job time.
        //
        cbData = sizeof( pIniSpooler->dwJobCompletionTimeout );
        Status = SplRegQueryValue( hKey,
                                   L"JobCompletionTimeout",
                                   NULL,
                                   (LPBYTE)&pIniSpooler->dwJobCompletionTimeout,
                                   &cbData,
                                   pIniSpooler );

        if( Status != ERROR_SUCCESS ){
            pIniSpooler->dwJobCompletionTimeout = DEFAULT_JOB_COMPLETION_TIMEOUT;
        }

        DBGMSG( DBG_TRACE, ("JobCompletionTimeout - %d\n", pIniSpooler->dwJobCompletionTimeout ));
    }

    //
    // Retrieve whether we want to cache masq printer settings, default is FALSE.
    //
    cbData = sizeof(CacheMasqPrinters);

    Status = SplRegQueryValue(hKey,
                              gszCacheMasqPrinters,
                              NULL,
                              (BYTE *)&CacheMasqPrinters,
                              &cbData,
                              pIniSpooler);

    //
    // We only set the bit for caching masq printers if CacbeMasqPrinters is
    // non-NULL.
    //
    if (Status == ERROR_SUCCESS && CacheMasqPrinters != 0) {

        pIniSpooler->dwSpoolerSettings |= SPOOLER_CACHEMASQPRINTERS;
    }

    //
    //  Some Folks like the NT FAX Service Don't want people to be able
    //  to remotely print with specific printer drivers.
    //
    // For Whistler we don't allow sharing the fax printer on Personal & Professional
    //
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);

    osvi.wProductType = VER_NT_WORKSTATION;
    VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_LESS_EQUAL);

    if (VerifyVersionInfo( &osvi,
                           VER_PRODUCT_TYPE,
                           dwlConditionMask)) {

        pIniSpooler->pNoRemotePrintDrivers = AllocSplStr(szNTFaxDriver);
        pIniSpooler->cchNoRemotePrintDrivers = wcslen(szNTFaxDriver) + 1;
        gbRemoteFax = FALSE;
    }

    //
    // If this is embedded NT, then allow masq printers to get non-RAW
    // jobs.  This is for Xerox.
    //
    dwlConditionMask = 0;
    ZeroMemory(&osvi, sizeof(osvi));

    osvi.wSuiteMask = VER_SUITE_EMBEDDEDNT;
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

    if (VerifyVersionInfo( &osvi,
                           VER_SUITENAME,
                           dwlConditionMask)) {

        pIniSpooler->SpoolerFlags |= SPL_NON_RAW_TO_MASQ_PRINTERS;
    }

    Status = SplRegCreateKey( pIniSpooler->hckRoot,
                              pIniSpooler->pszRegistryProviders,
                              0,
                              KEY_READ,
                              NULL,
                              &hKeyProvider,
                              NULL,
                              pIniSpooler );

    if( Status == NO_ERROR ){

        DWORD Flags;

        // NonRawToMasqPrinters

        cbData = sizeof( Flags );
        Status = SplRegQueryValue( hKeyProvider,
                                   SPLREG_NON_RAW_TO_MASQ_PRINTERS,
                                   NULL,
                                   (LPBYTE)&Flags,
                                   &cbData,
                                   pIniSpooler );

        if (Status == ERROR_SUCCESS) {

            if (Flags) {
                pIniSpooler->SpoolerFlags |= SPL_NON_RAW_TO_MASQ_PRINTERS;
            }
        }

        // EventLog

        cbData = sizeof( Flags );
        Status = SplRegQueryValue( hKeyProvider,
                                   SPLREG_EVENT_LOG,
                                   NULL,
                                   (LPBYTE)&Flags,
                                   &cbData,
                                   pIniSpooler );

        if (Status == ERROR_SUCCESS) {

            pIniSpooler->dwEventLogging = Flags;

        } else {

            Status = SetPrinterDataServer( pIniSpooler,
                                           SPLREG_EVENT_LOG,
                                           REG_DWORD,
                                           (LPBYTE)&pIniSpooler->dwEventLogging,
                                           sizeof( pIniSpooler->dwEventLogging ));
        }

        // NetPopup

        cbData = sizeof( Flags );
        Status = SplRegQueryValue( hKeyProvider,
                                   SPLREG_NET_POPUP,
                                   NULL,
                                   (LPBYTE)&Flags,
                                   &cbData,
                                   pIniSpooler );

        if (Status == ERROR_SUCCESS) {

            pIniSpooler->bEnableNetPopups = !!Flags;

            if (Flags != 1 && Flags != 0) {
                Status = SetPrinterDataServer( pIniSpooler,
                                               SPLREG_NET_POPUP,
                                               REG_DWORD,
                                               (LPBYTE)&pIniSpooler->bEnableNetPopups,
                                               sizeof( pIniSpooler->bEnableNetPopups ));
            }
        } else {

            Status = SetPrinterDataServer( pIniSpooler,
                                           SPLREG_NET_POPUP,
                                           REG_DWORD,
                                           (LPBYTE)&pIniSpooler->bEnableNetPopups,
                                           sizeof( pIniSpooler->bEnableNetPopups ));
        }

        // NetPopupToComputer

        cbData = sizeof( Flags );
        Status = SplRegQueryValue( hKeyProvider,
                                   SPLREG_NET_POPUP_TO_COMPUTER,
                                   NULL,
                                   (LPBYTE)&Flags,
                                   &cbData,
                                   pIniSpooler );

        if (Status == ERROR_SUCCESS) {

            pIniSpooler->bEnableNetPopupToComputer = !!Flags;

            if (Flags != 1 && Flags != 0) {
                Status = SetPrinterDataServer( pIniSpooler,
                                               SPLREG_NET_POPUP_TO_COMPUTER,
                                               REG_DWORD,
                                               (LPBYTE)&pIniSpooler->bEnableNetPopupToComputer,
                                               sizeof( pIniSpooler->bEnableNetPopupToComputer ));
            }
        } else {

            Status = SetPrinterDataServer( pIniSpooler,
                                           SPLREG_NET_POPUP_TO_COMPUTER,
                                           REG_DWORD,
                                           (LPBYTE)&pIniSpooler->bEnableNetPopupToComputer,
                                           sizeof( pIniSpooler->bEnableNetPopupToComputer ));
        }

        // RetryPopup

        cbData = sizeof( Flags );
        Status = SplRegQueryValue( hKeyProvider,
                                   SPLREG_RETRY_POPUP,
                                   NULL,
                                   (LPBYTE)&Flags,
                                   &cbData,
                                   pIniSpooler );

        if (Status == ERROR_SUCCESS) {

            pIniSpooler->bEnableRetryPopups = !!Flags;

            if (Flags != 1 && Flags != 0) {
                Status = SetPrinterDataServer( pIniSpooler,
                                               SPLREG_RETRY_POPUP,
                                               REG_DWORD,
                                               (LPBYTE)&pIniSpooler->bEnableRetryPopups,
                                               sizeof( pIniSpooler->bEnableRetryPopups ));
            }
        } else {

            Status = SetPrinterDataServer( pIniSpooler,
                                           SPLREG_RETRY_POPUP,
                                           REG_DWORD,
                                           (LPBYTE)&pIniSpooler->bEnableRetryPopups,
                                           sizeof( pIniSpooler->bEnableRetryPopups ));
        }

        // RestartJobOnPoolError

        cbData = sizeof( Flags );
        Status = SplRegQueryValue( hKeyProvider,
                                   SPLREG_RESTART_JOB_ON_POOL_ERROR,
                                   NULL,
                                   (LPBYTE)&Flags,
                                   &cbData,
                                   pIniSpooler );

        if (Status == ERROR_SUCCESS) {

            pIniSpooler->dwRestartJobOnPoolTimeout = Flags;

        } else {

            Status = SetPrinterDataServer( pIniSpooler,
                                           SPLREG_RESTART_JOB_ON_POOL_ERROR,
                                           REG_DWORD,
                                           (LPBYTE)&pIniSpooler->dwRestartJobOnPoolTimeout,
                                           sizeof( pIniSpooler->dwRestartJobOnPoolTimeout ));
        }

        // RestartJobOnPoolEnabled
        cbData = sizeof( Flags );
        Status = SplRegQueryValue( hKeyProvider,
                                   SPLREG_RESTART_JOB_ON_POOL_ENABLED,
                                   NULL,
                                   (LPBYTE)&Flags,
                                   &cbData,
                                   pIniSpooler );

        if (Status == ERROR_SUCCESS) {

            pIniSpooler->bRestartJobOnPoolEnabled = !!Flags;

            if (Flags != 1 && Flags != 0) {
                Status = SetPrinterDataServer( pIniSpooler,
                                               SPLREG_RESTART_JOB_ON_POOL_ENABLED,
                                               REG_DWORD,
                                               (LPBYTE)&pIniSpooler->bRestartJobOnPoolEnabled,
                                               sizeof( pIniSpooler->bRestartJobOnPoolEnabled ));
            }
        } else {

            Status = SetPrinterDataServer( pIniSpooler,
                                           SPLREG_RESTART_JOB_ON_POOL_ENABLED,
                                           REG_DWORD,
                                           (LPBYTE)&pIniSpooler->bRestartJobOnPoolEnabled,
                                           sizeof( pIniSpooler->bRestartJobOnPoolEnabled ));
        }

        SplRegCloseKey( hKeyProvider, pIniSpooler );
    }
}


DWORD
FinalInitAfterRouterInitComplete(
    DWORD dwUpgrade,
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    This thread does LocalSpl initialization that has to happen after
    the router has completely initialized.

    There are 2 jobs:-
        Upgrading Printer Driver Data
        Sharing Printers

    Ensures that printers are shared.  This case occurs when the spooler
    service not running on startup (and the server is), and then the
    user starts the spooler.

    We also get the benefit of closing down any invalid printer handles
    (in the server).

Arguments:

    dwUpgrade != 0 upgrade printer driver data.

Return Value:

    DWORD - ignored

--*/

{
    DWORD           dwPort;
    PINIPORT        pIniPort;
    PINIMONITOR     pIniLangMonitor;
    PINIPRINTER     pIniPrinter;
    PINIPRINTER     pIniPrinterNext;

    // Do Not share all the printers during an Upgrade.

    if ( dwUpgrade ) {

        return 0;
    }


    WaitForSpoolerInitialization();

    // Try pending driver upgrades on spooler startup
    PendingDriverUpgrades(NULL);

    EnterSplSem();

    // Delete printers in pending deletion state with no jobs
    CleanupDeletedPrinters(pIniSpooler);


    //
    // Re-share all shared printers.
    //

    for( pIniPrinter = pIniSpooler->pIniPrinter;
         pIniPrinter;
         pIniPrinter = pIniPrinterNext ) {

        if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED ) {

            //
            // Up the ref count to prevent deletion
            //
            INCPRINTERREF( pIniPrinter );

            //
            // Unshare it first to close all handles in the
            // server.
            //
            ShareThisPrinter( pIniPrinter,
                              pIniPrinter->pShareName,
                              FALSE );

            //
            // ShareThisPrinter leave SplSem, so check again to
            // decrease window.
            //
            if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED ) {

                BOOL bReturn;

                //
                // Now share it again.
                //
                bReturn = ShareThisPrinter( pIniPrinter,
                                            pIniPrinter->pShareName,
                                            TRUE );

                if( !bReturn ){

                    DWORD rc = GetLastError();

                    if( rc != NERR_ServerNotStarted &&
                        rc != NERR_DuplicateShare ){

                        WCHAR pwszError[256];

                        DBGMSG( DBG_WARNING,
                                ( "NetShareAdd failed %lx\n", rc));

                        wsprintf(pwszError, L"+ %d", rc);

                        SplLogEvent( pIniSpooler,
                                     LOG_ERROR,
                                     MSG_SHARE_FAILED,
                                     TRUE,
                                     pwszError,
                                     pIniPrinter->pName,
                                     pIniPrinter->pShareName,
                                     NULL );
                     }
                 }
            }

            DECPRINTERREF( pIniPrinter );
            pIniPrinterNext = pIniPrinter->pNext;


        } else {

            //
            // The unshared case.
            //
            pIniPrinterNext = pIniPrinter->pNext;
        }


        INCPRINTERREF(pIniPrinter);

        if (pIniPrinterNext)
            INCPRINTERREF(pIniPrinterNext);

        for ( dwPort = 0 ; dwPort < pIniPrinter->cPorts ; ++dwPort ) {

            pIniPort = pIniPrinter->ppIniPorts[dwPort];

            //
            // Bidi monitor can inform spooler of errors. First
            // printer will keep the port at the beginning
            //
            if ( pIniPort->ppIniPrinter[0] != pIniPrinter )
                continue;

            if ( !pIniPort->hPort && dwUpgradeFlag == 0 ) {

                LPTSTR pszPrinter;
                TCHAR szFullPrinter[ MAX_UNC_PRINTER_NAME ];

                if( pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){

                    pszPrinter = szFullPrinter;

                    wsprintf(szFullPrinter,
                             L"%ws\\%ws",
                             pIniSpooler->pMachineName,
                             pIniPrinter->pName );
                } else {

                    pszPrinter = pIniPrinter->pName;
                }

                if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_ENABLE_BIDI )
                    pIniLangMonitor = pIniPrinter->pIniDriver->pIniLangMonitor;
                else
                    pIniLangMonitor = NULL;

                OpenMonitorPort(pIniPort,
                                &pIniLangMonitor,
                                pszPrinter,
                                TRUE);
            }
        }

        if (pIniPrinterNext)
            DECPRINTERREF(pIniPrinterNext);

        DECPRINTERREF(pIniPrinter);
    }
   LeaveSplSem();

    return 0;
}


DWORD
FinalInitAfterRouterInitCompleteThread(
    DWORD dwUpgrade
    )

/*++

Routine Description:

    Async thread called when initializing provider.

Arguments:

Return Value:

--*/

{
    return FinalInitAfterRouterInitComplete( dwUpgrade, pLocalIniSpooler );
}

// DEBUG PURPOSE ONLY - - returns TRUE if pMem is an IniSpooler, FALSE otherwise
BOOL
NotIniSpooler(
    BYTE *pMem
    )
{
    PINISPOOLER pIniSpooler;

    for (pIniSpooler = pLocalIniSpooler ; pIniSpooler ; pIniSpooler = pIniSpooler->pIniNextSpooler)
        if (pIniSpooler == (PINISPOOLER) pMem)
            return FALSE;

    return TRUE;

}


BOOL
ValidateProductSuite(
    PWSTR pszSuiteName
    )
{
    BOOL bRet = FALSE;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    PWSTR pszProductSuite = NULL;
    PWSTR psz;


    Rslt = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        ipszRegistryProductOptions,
        &hKey
        );
    if (Rslt != ERROR_SUCCESS)
        goto exit;

    Rslt = RegQueryValueEx(
        hKey,
        L"ProductSuite",
        NULL,
        &Type,
        NULL,
        &Size
        );
    if (!Size || Rslt != ERROR_SUCCESS)
        goto exit;

    pszProductSuite = AllocSplMem(Size);
    if (!pszProductSuite) {
        goto exit;
    }

    Rslt = RegQueryValueEx(
        hKey,
        L"ProductSuite",
        NULL,
        &Type,
        (LPBYTE) pszProductSuite,
        &Size
        );
    if (Rslt != ERROR_SUCCESS || Type != REG_MULTI_SZ)
        goto exit;

    for(psz = pszProductSuite ; *psz && wcscmp(psz, pszSuiteName) ; psz += wcslen(psz) + 1)
        ;
    if (*psz)
        bRet = TRUE;

exit:

    FreeSplMem(pszProductSuite);

    if (hKey)
        RegCloseKey(hKey);

    return bRet;
}

/*++

Routine Name:

    ClusterAddOrUpdateDriverFromClusterDisk

Routine Description:

    Takes in a driver key and a cluster type pIniSpooler. It will add
    a driver from the cluster disk to the cluster spooler. If the driver
    already exists in the list of drivers, then it will attempt to upgrade
    it.

Arguments:

    hKeyVersion   - key to Ex. "Environments\Windows NT x86\Drivers\Version-3"
    pszDriverName - name a a driver
    pszEnvName    - environemnt of the driver
    pszenvDir     - directory for the driver files on the disk (Ex. w32x86)
    pIniSpooler   - cluster type pIniSpooler

Return Value:

    Win32 error code

--*/
DWORD
ClusterAddOrUpdateDriverFromClusterDisk(
    IN HKEY         hKeyVersion,
    IN LPCWSTR      pszDriverName,
    IN LPCWSTR      pszEnvName,
    IN LPCWSTR      pszEnvDir,
    IN PINISPOOLER  pIniSpooler
    )
{
    LPWSTR        pszzPathDepFiles = NULL;
    DRIVER_INFO_6 Drv              = {0};
    HKEY          hDrvKey          = NULL;
    WCHAR         szVerPath[10]    = {0};
    DWORD         dwError          = ERROR_SUCCESS;
    WCHAR         szData[MAX_PATH];
    WCHAR         szPathConfigFile[MAX_PATH];
    WCHAR         szPathDataFile[MAX_PATH];
    WCHAR         szPathDriverFile[MAX_PATH];
    WCHAR         szPathHelpFile[MAX_PATH];
    DWORD         cbData;
    DWORD         cLen;

    //
    // Open the driver's key
    //
    if ((dwError = SplRegOpenKey(hKeyVersion,
                                 pszDriverName,
                                 KEY_READ,
                                 &hDrvKey,
                                 pIniSpooler)) == ERROR_SUCCESS &&
        (dwError = (Drv.pName = AllocSplStr(pszDriverName)) ? ERROR_SUCCESS : GetLastError()) == ERROR_SUCCESS &&
        RegGetString(hDrvKey, szConfigurationKey, &Drv.pConfigFile,      &cLen, &dwError, TRUE,  pIniSpooler)  &&
        RegGetString(hDrvKey, szDataFileKey,      &Drv.pDataFile,        &cLen, &dwError, TRUE,  pIniSpooler)  &&
        RegGetString(hDrvKey, szDriverFile,       &Drv.pDriverPath,      &cLen, &dwError, TRUE,  pIniSpooler)  &&
        (dwError = Drv.pConfigFile &&
                   Drv.pDataFile   &&
                   Drv.pDriverPath ?  ERROR_SUCCESS : ERROR_INVALID_PARAMETER) == ERROR_SUCCESS                &&
        RegGetString(hDrvKey, szHelpFile,         &Drv.pHelpFile,        &cLen, &dwError, FALSE, pIniSpooler)  &&
        RegGetString(hDrvKey, szMonitor,          &Drv.pMonitorName,     &cLen, &dwError, FALSE, pIniSpooler)  &&
        RegGetString(hDrvKey, szDatatype,         &Drv.pDefaultDataType, &cLen, &dwError, FALSE, pIniSpooler)  &&
        RegGetMultiSzString(hDrvKey, szDependentFiles,   &Drv.pDependentFiles,  &cLen, &dwError, FALSE, pIniSpooler)  &&
        RegGetMultiSzString(hDrvKey, szPreviousNames,    &Drv.pszzPreviousNames,&cLen, &dwError, FALSE, pIniSpooler)  &&
        RegGetString(hDrvKey, szMfgName,          &Drv.pszMfgName,       &cLen, &dwError, FALSE, pIniSpooler)  &&
        RegGetString(hDrvKey, szOEMUrl,           &Drv.pszOEMUrl,        &cLen, &dwError, FALSE, pIniSpooler)  &&
        RegGetString(hDrvKey, szHardwareID,       &Drv.pszHardwareID,    &cLen, &dwError, TRUE,  pIniSpooler)  &&
        RegGetString(hDrvKey, szProvider,         &Drv.pszProvider,      &cLen, &dwError, TRUE,  pIniSpooler)  &&
        (dwError = ClusterFindLanguageMonitor(Drv.pMonitorName, pszEnvName, pIniSpooler))  == ERROR_SUCCESS)
    {
        cbData = sizeof(Drv.ftDriverDate);
        SplRegQueryValue(hDrvKey,
                         szDriverDate,
                         NULL,
                         (LPBYTE)&Drv.ftDriverDate,
                         &cbData,
                         pIniSpooler);

        cbData = sizeof(Drv.dwlDriverVersion);
        SplRegQueryValue(hDrvKey,
                         szLongVersion,
                         NULL,
                         (LPBYTE)&Drv.dwlDriverVersion,
                         &cbData,
                         pIniSpooler);

        cbData = sizeof(Drv.cVersion);
        SplRegQueryValue(hDrvKey,
                         szDriverVersion,
                         NULL,
                         (LPBYTE)&Drv.cVersion,
                         &cbData,
                         pIniSpooler);

        //
        // We need the matching version <-> directory on disk
        // Ex. Version-3 <-> 3
        //
        wsprintf(szVerPath, L"%u", Drv.cVersion);

        //
        // Get fully qualified driver file paths. We will do an add printer driver
        // without using the scratch directory. So the files have to be fully
        // qualified
        //
        if ((dwError = StrNCatBuff(szPathDriverFile,
                                   COUNTOF(szPathDriverFile),
                                   pIniSpooler->pszClusResDriveLetter, L"\\",
                                   szClusterDriverRoot, L"\\",
                                   pszEnvDir, L"\\",
                                   szVerPath, L"\\",
                                   Drv.pDriverPath,
                                   NULL)) == ERROR_SUCCESS &&
            (dwError = StrNCatBuff(szPathDataFile,
                                   COUNTOF(szPathDataFile),
                                   pIniSpooler->pszClusResDriveLetter, L"\\",
                                   szClusterDriverRoot, L"\\",
                                   pszEnvDir, L"\\",
                                   szVerPath, L"\\",
                                   Drv.pDataFile,
                                   NULL)) == ERROR_SUCCESS &&
            (dwError = StrNCatBuff(szPathConfigFile,
                                   COUNTOF(szPathConfigFile),
                                   pIniSpooler->pszClusResDriveLetter, L"\\",
                                   szClusterDriverRoot, L"\\",
                                   pszEnvDir, L"\\",
                                   szVerPath, L"\\",
                                   Drv.pConfigFile,
                                   NULL)) == ERROR_SUCCESS &&
            (dwError = StrNCatBuff(szPathHelpFile,
                                   COUNTOF(szPathHelpFile),
                                   pIniSpooler->pszClusResDriveLetter, L"\\",
                                   szClusterDriverRoot, L"\\",
                                   pszEnvDir, L"\\",
                                   szVerPath, L"\\",
                                   Drv.pHelpFile,
                                   NULL)) == ERROR_SUCCESS &&
            (dwError = StrNCatBuff(szData,
                                   COUNTOF(szData),
                                   pIniSpooler->pszClusResDriveLetter, L"\\",
                                   szClusterDriverRoot, L"\\",
                                   pszEnvDir, L"\\",
                                   szVerPath, L"\\",
                                   NULL)) == ERROR_SUCCESS &&
            (dwError = StrCatPrefixMsz(szData,
                                       Drv.pDependentFiles,
                                       &pszzPathDepFiles)) == ERROR_SUCCESS)
        {
            LPWSTR pszTempDriver = Drv.pDriverPath;
            LPWSTR pszTempData   = Drv.pDataFile;
            LPWSTR pszTempConfig = Drv.pConfigFile;
            LPWSTR pszTempHelp   = Drv.pHelpFile;
            LPWSTR pszTempDep    = Drv.pDependentFiles;

            DBGMSG(DBG_CLUSTER, ("ClusterAddOrUpDrv   szPathDriverFile = "TSTR"\n", szPathDriverFile));
            DBGMSG(DBG_CLUSTER, ("ClusterAddOrUpDrv   szPathDataFile   = "TSTR"\n", szPathDataFile));
            DBGMSG(DBG_CLUSTER, ("ClusterAddOrUpDrv   szPathConfigFile = "TSTR"\n", szPathConfigFile));
            DBGMSG(DBG_CLUSTER, ("ClusterAddOrUpDrv   szPathHelpFile   = "TSTR"\n", szPathHelpFile));

            Drv.pDriverPath        = szPathDriverFile;
            Drv.pEnvironment       = (LPWSTR)pszEnvName;
            Drv.pDataFile          = szPathDataFile;
            Drv.pConfigFile        = szPathConfigFile;
            Drv.pHelpFile          = szPathHelpFile;
            Drv.pDependentFiles    = pszzPathDepFiles;

            if (!SplAddPrinterDriverEx(NULL,
                                       6,
                                       (LPBYTE)&Drv,
                                       APD_COPY_NEW_FILES | APD_DONT_COPY_FILES_TO_CLUSTER,
                                       pIniSpooler,
                                       FALSE,
                                       DO_NOT_IMPERSONATE_USER))
            {
                dwError = GetLastError();
            }

            //
            // Restore pointers
            //
            Drv.pDriverPath     = pszTempDriver;
            Drv.pConfigFile     = pszTempConfig;
            Drv.pDataFile       = pszTempData;
            Drv.pHelpFile       = pszTempHelp;
            Drv.pDependentFiles = pszTempDep;
        }
    }

    FreeSplStr(Drv.pName);
    FreeSplStr(Drv.pDriverPath);
    FreeSplStr(Drv.pConfigFile);
    FreeSplStr(Drv.pDataFile);
    FreeSplStr(Drv.pHelpFile);
    FreeSplStr(Drv.pMonitorName);
    FreeSplStr(Drv.pDefaultDataType);
    FreeSplStr(Drv.pDependentFiles);
    FreeSplStr(Drv.pszzPreviousNames);
    FreeSplStr(Drv.pszMfgName);
    FreeSplStr(Drv.pszOEMUrl);
    FreeSplStr(Drv.pszProvider);
    FreeSplStr(Drv.pszHardwareID);
    FreeSplStr(pszzPathDepFiles);

    if (hDrvKey)
    {
        SplRegCloseKey(hDrvKey, pIniSpooler);
    }

    DBGMSG(DBG_CLUSTER, ("ClusterAddOrUpdateDriverFromClusterDisk returns Win32 error %u\n", dwError));

    return dwError;
}

/*++

Routine Name:

    SplCreateSpoolerWorkerThread

Routine Description:

    This routine will be launched in a separate thread to perform time consuming
    initialization as part of SplCreateSpooler when the spooler is a cluster spooler.
    Tasks that it will do include copying down ICM profiles from the cluster disk.
    The caller needs to AddRef the pIniSpooler so that it doesn't become invalid
    (deleted) while we are using it.

    This function closes the hClusSplReady event handle.

Arguments:

    PINISPOOLER pIniSpooler

Return Value:

    None

--*/
VOID
SplCreateSpoolerWorkerThread(
    IN PVOID pv
    )
{
    PINISPOOLER pIniSpooler;
    WCHAR       szDir[MAX_PATH];

    pIniSpooler = (PINISPOOLER)pv;

    if (pIniSpooler &&
        pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER &&
        pIniSpooler->hClusSplReady)
    {
        HANDLE hSplReady = pIniSpooler->hClusSplReady;

        //
        // Waiting for the creating function (SplCreateSpooler) to terminate
        //
        WaitForSingleObject(pIniSpooler->hClusSplReady, INFINITE);

        EnterSplSem();

        pIniSpooler->hClusSplReady = NULL;

        LeaveSplSem();

        //
        // We use hSplReady so we do not hold the critical section while doing CloseHandle
        //
        CloseHandle(hSplReady);

        CopyICMFromClusterDiskToLocalDisk(pIniSpooler);

        //
        // If the node was upgraded, we need to upgrade the print drivers
        // We cannot load ntprint and printui. So we create a process and
        // call an entry point in ntprint. That one will enumerate all the
        // cluster drivers and will try to upgrade them based on the new cab.
        //
        if (pIniSpooler->dwClusNodeUpgraded)
        {
            DWORD  dwError;
            DWORD  dwCode     = 0;
            LPWSTR pszCommand = NULL;
            LPWSTR pszExe     = NULL;

            //
            // We need to pass as argument the name of the cluster spooler
            //
            if ((dwError = StrCatSystemPath(L"rundll32.exe",
                                            kSystemDir,
                                            &pszExe)) == ERROR_SUCCESS &&
                (dwError = StrCatAlloc(&pszCommand,
                                       L"rundll32.exe ntprint.dll,PSetupUpgradeClusterDrivers ",
                                       pIniSpooler->pMachineName,
                                       NULL)) == ERROR_SUCCESS &&
                (dwError = RunProcess(pszExe, pszCommand, INFINITE, &dwCode)) == ERROR_SUCCESS)
            {
                //
                // dwCode is the return code of the function PSetupUpgradeClusterDrivers in ntprint,
                // executed inside the rundll32 process
                //
                if (dwCode == ERROR_SUCCESS)
                {
                    //
                    // We upgraded all the printer drivers, now we delete the key from the registry
                    // so we don't go though upgrading printer drivers again next time when the
                    // cluster group comes online on this node
                    //
                    ClusterSplDeleteUpgradeKey(pIniSpooler->pszClusResID);
                }
                else
                {
                    DBGMSG(DBG_ERROR, ("Error upgrading cluster drivers! dwCode %u\n", dwCode));
                }
            }

            FreeSplMem(pszCommand);
            FreeSplMem(pszExe);

            DBGMSG(DBG_CLUSTER, ("SplCreateSpoolerWorkerThread dwError %u  dwCode %u\n", dwError, dwCode));
        }

        //
        // Set resource private property ClusterDriverDirectry. This will be used by the
        // ResDll to perform clean up when the spooler is deleted
        //
        if (StrNCatBuff(szDir,
                        COUNTOF(szDir),
                        pIniSpooler->pszClusResDriveLetter,
                        L"\\",
                        szClusterDriverRoot,
                        NULL) == ERROR_SUCCESS)
        {
            SplRegSetValue(pIniSpooler->hckRoot,
                           SPLREG_CLUSTER_DRIVER_DIRECTORY,
                           REG_SZ,
                           (LPBYTE)szDir,
                           (wcslen(szDir) + 1) * sizeof(WCHAR),
                           pIniSpooler);
        }

        EnterSplSem();

        DECSPOOLERREF(pIniSpooler);

        LeaveSplSem();

        DBGMSG(DBG_CLUSTER, ("SplCreateSpoolerWorkerThread terminates pIniSpooler->cRef %u\n", pIniSpooler->cRef));
    }
}

/*++

Routine Name:

    LogFatalPortError

Routine Description:

    This routine logs a message when a printer cannot be brought up because its
    ports are missing.

Arguments:

    pszName -   The name of the printer.

Return Value:

    None.

--*/
VOID
LogFatalPortError(
    IN      PINISPOOLER pIniSpooler,
    IN      PCWSTR      pszName
    )
{
    DWORD  LastError    = ERROR_SUCCESS;
    WCHAR  szError[40]  = {0};

    LastError = GetLastError();

    _snwprintf(szError, COUNTOF(szError), L"%u (0x%x)", LastError, LastError);

    SplLogEvent(pIniSpooler,
                LOG_ERROR,
                MSG_PORT_INITIALIZATION_ERROR,
                FALSE,
                (PWSTR)pszName,
                szError,
                NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\jobid.c ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved

Module Name:

    jobid.c

Abstract:

    Handles job id bitmap.

Author:

    Albert Ting (AlbertT) 24-Oct-96

Environment:

    User Mode -Win32

Revision History:

    Ported from spooler.c code.

--*/

#include "precomp.h"
#pragma hdrstop

#include "jobid.h"

BOOL
ReallocJobIdMap(
    HANDLE hJobIdMap,
    DWORD dwNewMinSize
    )

/*++

Routine Description:

    Reallocates the job id bitmap to a new minimum size.

Arguments:

    hJobId - Handle to job ID bitmap.

    dwNewMinSize - Specifies the minimum size of the job id bitmap.
        Note that the allocation size may be larger.  Also, if 0x10
        is requested, only ids 0x0-0xf are guaranteed to be valid
        (0x10 is the 11th id, and therefore not valid).

Return Value:

    TRUE - Success
    False - Failed.

--*/

{
    PJOB_ID_MAP pJobIdMap = (PJOB_ID_MAP)hJobIdMap;
    PDWORD pMap;

    if( dwNewMinSize & 7 ){
        dwNewMinSize&=~7;
        dwNewMinSize+=8;
    }

    pMap = ReallocSplMem( pJobIdMap->pMap,
                          pJobIdMap->dwMaxJobId/8,
                          dwNewMinSize/8 );

    if( !pMap ){

        DBGMSG( DBG_WARN,
                ( "ReallocJobIdMap failed ReallocSplMem dwNewMinSize %d Error %d\n",
                  dwNewMinSize, GetLastError() ));
    } else {

        pJobIdMap->pMap = pMap;
        pJobIdMap->dwMaxJobId = dwNewMinSize;
    }

    return pMap != NULL;
}

DWORD
GetNextId(
    HANDLE hJobIdMap
    )

/*++

Routine Description:

    Retrieves a free job id, although not necessarily the next
    free bit.

Arguments:

    hJobId - Handle to job ID bitmap.

Return Value:

    DWORD - Next job.

--*/

{
    PJOB_ID_MAP pJobIdMap = (PJOB_ID_MAP)hJobIdMap;
    DWORD id;

    do {

        //
        // Scan forward from current job.
        //
        for( id = pJobIdMap->dwCurrentJobId + 1;
             id < pJobIdMap->dwMaxJobId;
             ++id ){

            if( !bBitOn( hJobIdMap, id )){
                goto FoundJobId;
            }
        }

        //
        // Scan from beginning to current job.
        //
        for( id = 1; id < pJobIdMap->dwCurrentJobId; ++id ){

            if( !bBitOn( hJobIdMap, id )){
                goto FoundJobId;
            }
        }
    } while( ReallocJobIdMap( hJobIdMap, pJobIdMap->dwMaxJobId + 128 ));

    //
    // No job ids; fail.
    //
    return 0;

FoundJobId:

    vMarkOn( hJobIdMap, id );
    pJobIdMap->dwCurrentJobId = id;

    return id;
}


/********************************************************************

    Create and delete functions.

********************************************************************/

HANDLE
hCreateJobIdMap(
    DWORD dwMinSize
    )
{
    PJOB_ID_MAP pJobIdMap;

    pJobIdMap = AllocSplMem( sizeof( JOB_ID_MAP ));

    if( !pJobIdMap ){
        goto Fail;
    }

    pJobIdMap->pMap = AllocSplMem( dwMinSize/8 );
    if( !pJobIdMap->pMap ){
        goto Fail;
    }

    pJobIdMap->dwMaxJobId = dwMinSize;
    pJobIdMap->dwCurrentJobId = 1;

    return (HANDLE)pJobIdMap;

Fail:

    if( pJobIdMap ){
        FreeSplMem( pJobIdMap );
    }
    return NULL;
}



VOID
vDeleteJobIdMap(
    HANDLE hJobIdMap
    )
{
    PJOB_ID_MAP pJobIdMap = (PJOB_ID_MAP)hJobIdMap;

    if( pJobIdMap ){

        if( pJobIdMap->pMap ){
            FreeSplMem( pJobIdMap->pMap );
        }

        FreeSplMem( pJobIdMap );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\job.c ===
/*++

Copyright (c) 1990 - 1996  Microsoft Corporation

Module Name:

    job.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:
    MattFe 23-Feb-96 JobInfo3

--*/

#include <precomp.h>
#pragma hdrstop

#include <offsets.h>
#include "jobid.h"
#include "filepool.hxx"

#define JOB_STATUS_INTERNAL 0
#define JOB_STATUS_EXTERNAL 1

DWORD SettableJobStatusMappings[] = {

//  INTERNAL:               EXTERNAL:

    JOB_PAUSED,             JOB_STATUS_PAUSED,
    JOB_ERROR,              JOB_STATUS_ERROR,
    JOB_OFFLINE,            JOB_STATUS_OFFLINE,
    JOB_PAPEROUT,           JOB_STATUS_PAPEROUT,
    0,                      0
};

DWORD ReadableJobStatusMappings[] = {

//  INTERNAL:               EXTERNAL:

    JOB_PAUSED,             JOB_STATUS_PAUSED,
    JOB_ERROR,              JOB_STATUS_ERROR,
    JOB_PENDING_DELETION,   JOB_STATUS_DELETING,
    JOB_SPOOLING,           JOB_STATUS_SPOOLING,
    JOB_PRINTING,           JOB_STATUS_PRINTING,
    JOB_COMPLETE,           JOB_STATUS_COMPLETE,
    JOB_OFFLINE,            JOB_STATUS_OFFLINE,
    JOB_PAPEROUT,           JOB_STATUS_PAPEROUT,
    JOB_PRINTED,            JOB_STATUS_PRINTED,
    JOB_BLOCKED_DEVQ,       JOB_STATUS_BLOCKED_DEVQ,
    JOB_DELETED,            JOB_STATUS_DELETED,
    JOB_HIDDEN,             JOB_STATUS_DELETED,
    JOB_RESTART,            JOB_STATUS_RESTART,
    0,                      0
};

DWORD gdwZombieCount = 0;


DWORD
MapJobStatus(
    DWORD Type,
    DWORD SourceStatus)
{
    DWORD  TargetStatus;
    PDWORD pMappings;
    INT   MapFrom;
    INT   MapTo;

    if (Type == MAP_READABLE) {

        MapFrom = JOB_STATUS_INTERNAL;
        MapTo = JOB_STATUS_EXTERNAL;

        pMappings = ReadableJobStatusMappings;

    } else {

        MapFrom = JOB_STATUS_EXTERNAL;
        MapTo = JOB_STATUS_INTERNAL;

        pMappings = SettableJobStatusMappings;
    }

    TargetStatus = 0;

    while(*pMappings) {

        if (SourceStatus & pMappings[MapFrom])
            TargetStatus |= pMappings[MapTo];

        pMappings += 2;
    }

    return TargetStatus;
}


PINIJOB
FindJob(
   PINIPRINTER pIniPrinter,
   DWORD JobId,
   PDWORD pPosition)
{
   PINIJOB pIniJob;

   SplInSem();

   for (pIniJob = pIniPrinter->pIniFirstJob, *pPosition = 1;
        pIniJob;
        pIniJob = pIniJob->pIniNextJob, (*pPosition)++) {

      if (pIniJob->JobId == JobId)
         return pIniJob;
   }

   *pPosition = JOB_POSITION_UNSPECIFIED;
   return (NULL);
}

PINIJOB
FindServerJob(
    PINISPOOLER pIniSpooler,
    DWORD JobId,
    PDWORD pdwPosition,
    PINIPRINTER* ppIniPrinter
    )

/*++

Routine Description:

    Finds a pIniJob, position, and pIniPrinter based on a JobId and
    pIniSpooler.  This works because JobIds are unique across pIniSpoolers.

Arguments:

    pIniSpooler - pIniSpooler to search

    JobId - Job to search for.

    pdwPosition - When a valid pIniJob is returned, this is the position in
        the queue of the returned job.

    ppIniPrinter - When a valid pIniJob is returned, this is the queue
        that the job belongs to.

Return Value:

    PINIJOB if success,
    NULL if not found (LastError NOT set)

--*/

{
    DWORD dwPosition;
    PINIJOB pIniJob;

    SplInSem();

    for( *ppIniPrinter = pIniSpooler->pIniPrinter;
         *ppIniPrinter;
         *ppIniPrinter = (*ppIniPrinter)->pNext ){

        if( pIniJob = FindJob( *ppIniPrinter, JobId, pdwPosition )){

            return pIniJob;
        }
    }
    return NULL;
}

PINIJOB
FindIniJob (
    PSPOOL pSpool,
    DWORD  JobId
)
{
    PINIJOB     pIniJob = NULL;
    PINIPRINTER pIniPrinter = NULL;
    DWORD       dwPosition;     

    if (pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) 
    {
        //
        // If it's a server handle, then search all jobs on this spooler.
        // This call also retrieves the pIniPrinter associated
        // with a print job. pIniPrinter is not needed, but FindServerJob
        // requires a valid pointer.
        //
        pIniJob = FindServerJob(pSpool->pIniSpooler,
                                JobId,
                                &dwPosition,
                                &pIniPrinter);
    } 
    else 
    {
        pIniJob = FindJob(pSpool->pIniPrinter, JobId, &dwPosition);
    }

    return pIniJob;
}

DWORD
GetJobSessionId (
    PSPOOL pSpool,
    DWORD  JobId
)
{
    DWORD   SessionId = -1;
    PINIJOB pIniJob = NULL;

    EnterSplSem();

    if (ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) 
    {
        pIniJob = FindIniJob(pSpool, JobId);

        if (pIniJob) 
        {
            SessionId = pIniJob->SessionId;                
        }            
    }

    LeaveSplSem();

    return SessionId;
}

BOOL
SetJobPosition(
    PINIJOB pIniSetJob,
    DWORD   NewPosition
)
{
   PINIJOB pIniJob;
   PINIJOB pIniPrevJob;
   DWORD   Position;
   PINISPOOLER pIniSpooler = NULL;

    SPLASSERT( pIniSetJob != NULL );
    SPLASSERT( pIniSetJob->pIniPrinter != NULL );
    SPLASSERT( pIniSetJob->pIniPrinter->pIniSpooler != NULL );

    pIniSpooler = pIniSetJob->pIniPrinter->pIniSpooler;

SplInSem();

   /* Remove this job from the linked list, and
    * link the jobs either side of the one we're repositioning:
    */
   if (pIniSetJob->pIniPrevJob)
       pIniSetJob->pIniPrevJob->pIniNextJob = pIniSetJob->pIniNextJob;
   else
       pIniSetJob->pIniPrinter->pIniFirstJob = pIniSetJob->pIniNextJob;

   if (pIniSetJob->pIniNextJob)
       pIniSetJob->pIniNextJob->pIniPrevJob = pIniSetJob->pIniPrevJob;
   else
       pIniSetJob->pIniPrinter->pIniLastJob = pIniSetJob->pIniPrevJob;


   pIniJob = pIniSetJob->pIniPrinter->pIniFirstJob;
   pIniPrevJob = NULL;

   /* Find the new position for the job:
    */
   Position = 1;

   while (pIniJob && (Position < NewPosition)) {

       pIniPrevJob = pIniJob;
       pIniJob = pIniJob->pIniNextJob;

       Position++;
   }


   /* If we're at position 1, pIniPrevJob == NULL,
    * if we're at the end of the list, pIniJob == NULL.
    */

   /* Now fix up the new links:
    */
   pIniSetJob->pIniPrevJob = pIniPrevJob;
   pIniSetJob->pIniNextJob = pIniJob;

   if (pIniPrevJob)
       pIniPrevJob->pIniNextJob = pIniSetJob;
   else
       pIniSetJob->pIniPrinter->pIniFirstJob = pIniSetJob;

   if (pIniSetJob->pIniNextJob)
       pIniSetJob->pIniNextJob->pIniPrevJob = pIniSetJob;
   else
       pIniSetJob->pIniPrinter->pIniLastJob = pIniSetJob;


   INCJOBREF( pIniSetJob );

   LogJobInfo(
       pIniSpooler,
       MSG_DOCUMENT_POSITION_CHANGED,
       pIniSetJob->JobId,
       pIniSetJob->pDocument,
       pIniSetJob->pUser,
       pIniSetJob->pIniPrinter->pName,
       NewPosition
       );

   DECJOBREF( pIniSetJob );

   return TRUE;
}


#if DBG
/* For the debug message:
 */
#define HOUR_FROM_MINUTES(Time)     ((Time) / 60)
#define MINUTE_FROM_MINUTES(Time)   ((Time) % 60)

/* Format for %02d:%02d replaceable string:
 */
#define FORMAT_HOUR_MIN(Time)       HOUR_FROM_MINUTES(Time),    \
                                    MINUTE_FROM_MINUTES(Time)
#endif


BOOL
ValidateJobTimes(
    PINIJOB      pIniJob,
    LPJOB_INFO_2 pJob2
)
{
    BOOL        TimesAreValid = FALSE;
    PINIPRINTER pIniPrinter;

    pIniPrinter = pIniJob->pIniPrinter;

    DBGMSG(DBG_TRACE, ("Validating job times\n"
                       "\tPrinter hours: %02d:%02d to %02d:%02d\n"
                       "\tJob hours:     %02d:%02d to %02d:%02d\n",
                       FORMAT_HOUR_MIN(pIniPrinter->StartTime),
                       FORMAT_HOUR_MIN(pIniPrinter->UntilTime),
                       FORMAT_HOUR_MIN(pJob2->StartTime),
                       FORMAT_HOUR_MIN(pJob2->UntilTime)));

    if ((pJob2->StartTime < ONEDAY) && (pJob2->UntilTime < ONEDAY)) {

        if ((pJob2->StartTime == pIniJob->StartTime)
          &&(pJob2->UntilTime == pIniJob->UntilTime)) {

            DBGMSG(DBG_TRACE, ("Times are unchanged\n"));

            TimesAreValid = TRUE;

        } else {

            /* New time must be wholly within the window between StartTime
             * and UntilTime of the printer.
             */
            if (pIniPrinter->StartTime > pIniPrinter->UntilTime) {

                /* E.g. StartTime = 20:00
                 *      UntilTime = 06:00
                 *
                 * This spans midnight, so check we're not in the period
                 * between UntilTime and StartTime:
                 */
                if (pJob2->StartTime > pJob2->UntilTime) {

                    /* This appears to span midnight too.
                     * Make sure the window fits in the printer's window:
                     */
                    if ((pJob2->StartTime >= pIniPrinter->StartTime)
                      &&(pJob2->UntilTime <= pIniPrinter->UntilTime)) {

                        TimesAreValid = TRUE;

                    } else {

                        DBGMSG(DBG_TRACE, ("Failed test 2\n"));
                    }

                } else {

                    if ((pJob2->StartTime >= pIniPrinter->StartTime)
                      &&(pJob2->UntilTime > pIniPrinter->StartTime)) {

                        TimesAreValid = TRUE;

                    } else if ((pJob2->UntilTime < pIniPrinter->UntilTime)
                             &&(pJob2->StartTime < pIniPrinter->UntilTime)) {

                        TimesAreValid = TRUE;

                    } else {

                        DBGMSG(DBG_TRACE, ("Failed test 3\n"));
                    }
                }

            } else if (pIniPrinter->StartTime < pIniPrinter->UntilTime) {

                /* E.g. StartTime = 08:00
                 *      UntilTime = 18:00
                 */
                if ((pJob2->StartTime >= pIniPrinter->StartTime)
                  &&(pJob2->UntilTime <= pIniPrinter->UntilTime)
                  &&(pJob2->StartTime <= pJob2->UntilTime)) {

                    TimesAreValid = TRUE;

                } else {

                    DBGMSG(DBG_TRACE, ("Failed test 4\n"));
                }

            } else {

                /* Printer times  are round the clock:
                 */
                TimesAreValid = TRUE;
            }
        }

    } else {

        TimesAreValid = FALSE;
    }

    DBGMSG(DBG_TRACE, ("Times are %svalid\n", TimesAreValid ? "" : "in"));

    return TimesAreValid;
}

/*++

Routine Name:

    CircularChainedJobsList

Routine Description:

    Check if chaining 2 jobs together will cause us to have a circular chain of jobs.
    This thing is not allowed.

Arguments:

    pIniJob     - pointer to the job that we want to link
    pNextIniJob - pointer to the job to which we want to link

Return Value:

    TRUE  - if chaining the jobs together builds a circular list
    FALSE - if chaining the jobs together is allowed

Last Error:

    None

--*/
BOOL
CircularChainedJobsList(
    IN PINIJOB pIniJob,
    IN PINIJOB pNextIniJob
    )
{
    BOOL  bCircular = FALSE;

    //
    // Validate input parameters
    //
    if (pIniJob && pNextIniJob)
    {
        DWORD Position;

        //
        // Traverse chained list of jobs. Try to arrive from pNextIniJob->JobId to pIniJob->JobId
        //
        while (pNextIniJob = FindJob(pIniJob->pIniPrinter, pNextIniJob->NextJobId, &Position))
        {
            DBGMSG(DBG_TRACE, ("CircularChainedJobsList job %u\n", pNextIniJob->JobId));

            if (pNextIniJob->JobId == pIniJob->JobId)
            {
                bCircular = TRUE;

                break;
            }
        }
    }

    return bCircular;
}

DWORD
SetLocalJob(
    HANDLE  hPrinter,
    PINIJOB pIniJob,
    DWORD   Level,
    LPBYTE  pJob
    )

/*++

Routine Description:

    Sets information about a localspl job.

Arguments:

    hPrinter - Handle to printer OR server.  Since this is could be a
        server, the pSpool->pIniPrinter is not always valid!

        Use pIniJob->pIniPrinter instead of pSpool->pIniPrinter.

    pIniJob - Job that should be set

    Level - Level of pJob structure

    pJob - New information to set

Return Value:

    ERROR_SUCCESS for success, else error code.

Notes:

    The 3.51 spooler has been changed to accept server handles since
    net\dosprint\dosprtw.c does not have a printername, just a job id.
    This relies on the fact that job ids are unique across a pIniSpooler.

    To move a job with a server pSpool, you need administrative access
    on the server handle.

    The TotalPages and PagesPrinted fields can no longer be set.
    Otherwise, users can change the number of pages in their jobs to 0,
    and get charged a lot less (some people charge based on eventlog
    pagecounts).  Also, hpmon does a GetJob/SetJob to set the status,
    and sometimes the page count changes between the Get and Set.

--*/

{
    LPJOB_INFO_2 pJob2 = (PJOB_INFO_2)pJob;
    LPJOB_INFO_1 pJob1 = (PJOB_INFO_1)pJob;
    LPJOB_INFO_3 pJob3 = (PJOB_INFO_3)pJob;
    PINIPRINTPROC pIniPrintProc;
    PINIJOB pOldJob;
    DWORD   OldJobId;
    PINIJOB pNextIniJob;
    DWORD   dwPosition;
    DWORD   ReturnValue = ERROR_SUCCESS;
    LPDEVMODE   pDevMode;

    PINISPOOLER     pIniSpooler     = NULL;
    PINIENVIRONMENT pIniEnvironment = NULL;

    PSPOOL pSpool = (PSPOOL)hPrinter;
    DWORD OldStatus;
    DWORD dwJobVector = 0;

    NOTIFYVECTOR NotifyVector;
    ZERONV(NotifyVector);


    SplInSem();

    switch (Level) {

    case 1:

        if (!pJob1->pDatatype ||
            !CheckDataTypes(pIniJob->pIniPrintProc, pJob1->pDatatype)) {

            return ERROR_INVALID_DATATYPE;
        }

        if (pJob1->Position != JOB_POSITION_UNSPECIFIED) {

            //
            // Check for Administer privilege on the printer
            // if the guy wants to reorder the job:
            //
            if (!AccessGranted(SPOOLER_OBJECT_PRINTER,
                               PRINTER_ACCESS_ADMINISTER,
                               pSpool)) {
                return ERROR_ACCESS_DENIED;
            }

            SetJobPosition(pIniJob, pJob1->Position);
            dwJobVector |= BIT(I_JOB_POSITION);
        }

        if (pJob1->Priority <= MAX_PRIORITY) {

            if (pIniJob->Priority != pJob1->Priority) {
                pIniJob->Priority = pJob1->Priority;
                dwJobVector |= BIT(I_JOB_PRIORITY);
            }
        }

        if (UpdateString(&pIniJob->pUser, pJob1->pUserName)) {
            dwJobVector |= BIT(I_JOB_USER_NAME);
        }

        if (UpdateString(&pIniJob->pDocument, pJob1->pDocument)) {
            dwJobVector |= BIT(I_JOB_DOCUMENT);
        }

        if (UpdateString(&pIniJob->pDatatype, pJob1->pDatatype)) {
            dwJobVector |= BIT(I_JOB_DATATYPE);
        }

        if (UpdateString(&pIniJob->pStatus, pJob1->pStatus)) {
            dwJobVector |= BIT(I_JOB_STATUS_STRING);
        }

        OldStatus = pIniJob->Status;
        pIniJob->Status &= JOB_STATUS_PRIVATE;

        pIniJob->Status |= MapJobStatus(MAP_SETTABLE,
                                        pJob1->Status);

        if (OldStatus != pIniJob->Status) {
            dwJobVector |= BIT(I_JOB_STATUS);
        }

        break;

    case 2:

        //
        // The local spooler and cluster spooler do not share the same Environment structures.
        //
        pIniEnvironment = GetLocalArchEnv(pIniJob->pIniPrinter->pIniSpooler);

        pIniPrintProc = FindPrintProc(pJob2->pPrintProcessor, pIniEnvironment);

        if (!pIniPrintProc) {

            return ERROR_UNKNOWN_PRINTPROCESSOR;
        }

        if( !pJob2->pDatatype ||
            !CheckDataTypes(pIniPrintProc, pJob2->pDatatype)) {

            return ERROR_INVALID_DATATYPE;
        }

        if (pJob2->Position != JOB_POSITION_UNSPECIFIED) {

            //
            // Check for Administer privilege on the printer
            // if the guy wants to reorder the job:
            //
            if (!AccessGranted(SPOOLER_OBJECT_PRINTER,
                               PRINTER_ACCESS_ADMINISTER,
                               pSpool)) {
                return ERROR_ACCESS_DENIED;
            }
        }


        if (ValidateJobTimes(pIniJob, pJob2)) {

            if (pIniJob->StartTime != pJob2->StartTime) {

                pIniJob->StartTime = pJob2->StartTime;
                dwJobVector |= BIT(I_JOB_START_TIME);
            }

            if (pIniJob->UntilTime != pJob2->UntilTime) {

                pIniJob->UntilTime = pJob2->UntilTime;
                dwJobVector |= BIT(I_JOB_UNTIL_TIME);
            }

        } else {

            return ERROR_INVALID_TIME;
        }


        if (pJob2->Position != JOB_POSITION_UNSPECIFIED) {

            SetJobPosition(pIniJob, pJob2->Position);
            dwJobVector |= BIT(I_JOB_POSITION);
        }

        //
        // We really need some error returns here.
        //
        if (pJob2->Priority <= MAX_PRIORITY) {

            if (pIniJob->Priority != pJob2->Priority) {

                pIniJob->Priority = pJob2->Priority;
                dwJobVector |= BIT(I_JOB_PRIORITY);
            }
        }

        if (pIniJob->pIniPrintProc != pIniPrintProc) {

            pIniJob->pIniPrintProc->cRef--;
            pIniJob->pIniPrintProc = pIniPrintProc;
            pIniJob->pIniPrintProc->cRef++;

            dwJobVector |= BIT(I_JOB_PRINT_PROCESSOR);
        }

        if (UpdateString(&pIniJob->pUser, pJob2->pUserName)) {
            dwJobVector |= BIT(I_JOB_USER_NAME);
        }
        if (UpdateString(&pIniJob->pDocument, pJob2->pDocument)) {
            dwJobVector |= BIT(I_JOB_DOCUMENT);
        }
        if (UpdateString(&pIniJob->pNotify, pJob2->pNotifyName)) {
            dwJobVector |= BIT(I_JOB_NOTIFY_NAME);
        }
        if (UpdateString(&pIniJob->pDatatype, pJob2->pDatatype)) {
            dwJobVector |= BIT(I_JOB_DATATYPE);
        }
        if (UpdateString(&pIniJob->pParameters, pJob2->pParameters)) {
            dwJobVector |= BIT(I_JOB_PARAMETERS);
    }

        // <<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#if 0   // NOT COMPILED BECAUSE SPOOLSS\CLIENT does NOT have a DevMode container
        // So its never passed to us correctly, we'd AV

        //
        //  Update the DevMode
        //

        if (pJob2->pDevMode) {

            if ( pIniJob->pDevMode &&
                 pIniJob->pDevMode->dmSize == pJob2->pDevMode->dmSize &&
                 pIniJob->pDevMode->dmDriverExtra == pJob2->pDevMode->dmDriverExtra &&
                 !memcmp( pIniJob->pDevMode, pJob2->pDevMode, ( pIniJob->pDevMode->dmSize + pIniJob->pDevMode->dmDriverExtra ))) {


                //
                // DevModes are the same don't do anything
                //

            } else {

                pDevMode = AllocDevMode( pJob2->pDevMode );

                if ( !pDevMode ) {
                    return  GetLastError();
                }

                if ( pIniJob->pDevMode )
                    FreeSplMem( pIniJob->pDevMode );

                pIniJob->pDevMode = pDevMode;
                dwJobVector |= BIT(I_JOB_DEVMODE);
            }
    }
#endif  // END NOT COMPILED <<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>.

        if (UpdateString(&pIniJob->pStatus, pJob2->pStatus)) {
            dwJobVector |= BIT(I_JOB_STATUS_STRING);
        }

        OldStatus = pIniJob->Status;
        pIniJob->Status &= JOB_STATUS_PRIVATE;

        pIniJob->Status |= MapJobStatus(MAP_SETTABLE,
                                        pJob2->Status);

        if (OldStatus != pIniJob->Status) {
            dwJobVector |= BIT(I_JOB_STATUS);
        }

        break;

    case 3:

        //  SetJob with Job_info_3
        //  The goal is to tell the scheduler the printer order of jobs
        //  so that they can be chained together.   This is first implemented
        //  so that FAX applications can print multiple cover sheets and point to
        //  the same print document.   Each cover sheet / FAX job might be successful
        //  or might fail to print - so status will be shown against the MasterJob
        //  the first job in the chain.
        //  Subsequent Jobs in the chain are then considered to be part of the main document.

        SplInSem();

        // Validate that the NextJob exists

        pNextIniJob = FindJob( pIniJob->pIniPrinter, pJob3->NextJobId, &dwPosition );

        //
        // Check for Errors. Note that we only chain jobs that have the same data type.
        // Also, once you chain a job, you can't chain it to a different job anymore
        //
        if (pNextIniJob        == NULL          ||
            pNextIniJob        == pIniJob       ||
            pIniJob->JobId     != pJob3->JobId  ||
            pJob3->Reserved    != 0             ||
            pIniJob->NextJobId != 0             ||
            CircularChainedJobsList(pIniJob, pNextIniJob) ||
            _wcsicmp(pIniJob->pDatatype, pNextIniJob->pDatatype)) {

            return ERROR_INVALID_PARAMETER;
        }

        //
        //  Check Access to the chained job
        //

        if ( !ValidateObjectAccess( SPOOLER_OBJECT_DOCUMENT,
                                    JOB_ACCESS_ADMINISTER,
                                    pNextIniJob,
                                    NULL,
                                    pNextIniJob->pIniPrinter->pIniSpooler ) ) {

            DBGMSG( DBG_WARNING,
                    ( "LocalSetJob failed ValidateObjectAccess JobId %d pNextIniJob %x, error %d\n",
                      pNextIniJob->JobId, pNextIniJob, GetLastError()));

            return GetLastError();
        }

        if ( (pIniJob->Status & JOB_DESPOOLING) ||
             (pNextIniJob->Status & JOB_DESPOOLING) ) {

            return ERROR_INVALID_PRINTER_STATE;
        }

        // LATER this code has no check for a circular list.

        // Save Old Pointer, incase we want to delete it.

        OldJobId = pIniJob->NextJobId;

        // Point the Current Job to user specified new job
        // and increment its reference count.

        pIniJob->NextJobId = pJob3->NextJobId;
        pNextIniJob->Status |= ( JOB_COMPOUND | JOB_HIDDEN );
        INCJOBREF( pNextIniJob );

        //
        // Page count/Size for the head job should include the other job also
        //
        pIniJob->cPages += pNextIniJob->cPages;
        pIniJob->Size   += pNextIniJob->Size;

        // If there was an old reference then decrement its reference count
        // check for deletion.

        if ( OldJobId ) {

            pOldJob = FindJob( pIniJob->pIniPrinter, OldJobId, &dwPosition );

            DECJOBREF( pOldJob );

            if ( (pOldJob->Status & JOB_COMPOUND) &&
                 (pOldJob->cRef == 0) ) {

                pOldJob->Status &= ~( JOB_COMPOUND | JOB_HIDDEN );

                WriteShadowJob(pOldJob, FALSE);
            }

            DeleteJobCheck( pOldJob );
        }

        //
        //  Hide the Compound Job from the UI, by making it look deleted
        //

        SetPrinterChange( pNextIniJob->pIniPrinter,
                          pNextIniJob,
                          NVDeletedJob,
                          PRINTER_CHANGE_DELETE_JOB | PRINTER_CHANGE_SET_PRINTER,
                          pNextIniJob->pIniPrinter->pIniSpooler );

        break;

    }

    //
    // Log an event if the priority of the job changed
    //
    if (dwJobVector & BIT(I_JOB_PRIORITY))  {

        LogJobInfo(pIniJob->pIniPrinter->pIniSpooler,
                   MSG_DOCUMENT_PRIORITY_CHANGED,
                   pIniJob->JobId,
                   pIniJob->pDocument,
                   pIniJob->pUser,
                   pIniJob->pIniPrinter->pName,
                   pIniJob->Priority);
    }

    CHECK_SCHEDULER();

    NotifyVector[JOB_NOTIFY_TYPE] = dwJobVector;

    SetPrinterChange(pIniJob->pIniPrinter,
                     pIniJob,
                     NotifyVector,
                     PRINTER_CHANGE_SET_JOB,
                     pSpool->pIniSpooler);

    //
    //  if something important changed in the Job
    //  we should update the shadowjob
    //

    if ( pIniJob &&
         ( Level == 3 ||
         ( dwJobVector & ~(BIT(I_JOB_STATUS_STRING))))) {

        WriteShadowJob( pIniJob, FALSE );
    }

    return NO_ERROR;
}


BOOL
PauseJob(
    PINIJOB pIniJob)
{
    PINISPOOLER pIniSpooler = NULL;
    PINIPORT    pIniPort    = NULL;
    BOOL        ReturnValue = TRUE;

    SplInSem();

    pIniJob->Status |= JOB_PAUSED;
    WriteShadowJob(pIniJob, FALSE);

    if(pIniJob->pIniPrintProc)
    {
        INCJOBREF(pIniJob);

        if (pIniJob->pIniPort && !(pIniJob->pIniPort->InCriticalSection & PRINTPROC_PAUSE))
        {
            //
            // Capture the pIniPort so that the InCriticalSection operations we
            // apply to it are at least consistent.
            //
            pIniPort = pIniJob->pIniPort;

            INCPORTREF(pIniPort);

            LeaveSplSem();
            EnterCriticalSection(&pIniJob->pIniPrintProc->CriticalSection);
            EnterSplSem();

            pIniPort->InCriticalSection |= PRINTPROC_PAUSE;

            if (pIniJob->Status & JOB_PRINTING )
            {
                if (pIniPort->hProc)
                {
                    LeaveSplSem();
                    ReturnValue = (*pIniJob->pIniPrintProc->Control)(pIniPort->hProc, JOB_CONTROL_PAUSE );
                    EnterSplSem();
                }

            }

            pIniPort->InCriticalSection &= ~PRINTPROC_PAUSE;

            LeaveCriticalSection(&pIniJob->pIniPrintProc->CriticalSection);

            DECPORTREF(pIniPort);
        }

        DECJOBREF(pIniJob);
    }


    DBGMSG( DBG_INFO, ( "Paused Job %d; Status = %08x\n", pIniJob->JobId, pIniJob->Status ) );

    SPLASSERT( pIniJob != NULL &&
               pIniJob->pIniPrinter != NULL &&
               pIniJob->pIniPrinter->pIniSpooler != NULL );

    pIniSpooler = pIniJob->pIniPrinter->pIniSpooler;

    INCJOBREF( pIniJob );

    LogJobInfo(
        pIniSpooler,
        MSG_DOCUMENT_PAUSED,
        pIniJob->JobId,
        pIniJob->pDocument,
        pIniJob->pUser,
        pIniJob->pIniPrinter->pName,
        0);

    DECJOBREF( pIniJob );

    return ReturnValue;
}

BOOL
ResumeJob(
    PINIJOB pIniJob
)
{
    PINISPOOLER pIniSpooler     = NULL;
    PINIPORT    pIniPort        = NULL;
    BOOL        ReturnValue     = TRUE;
    BOOL        CheckSchedular  = FALSE;

    SplInSem();
    
    pIniJob->Status &= ~JOB_PAUSED;
    WriteShadowJob(pIniJob, FALSE);


    if(pIniJob->pIniPrintProc)
    {
        INCJOBREF(pIniJob);

        if (pIniJob->pIniPort && !(pIniJob->pIniPort->InCriticalSection & PRINTPROC_RESUME))
        {
            pIniPort = pIniJob->pIniPort;

            INCPORTREF(pIniPort);

            LeaveSplSem();
            EnterCriticalSection(&pIniJob->pIniPrintProc->CriticalSection);
            EnterSplSem();

            pIniPort->InCriticalSection |= PRINTPROC_RESUME;

            if ( pIniJob->Status & JOB_PRINTING)
            {
                if ( pIniPort->hProc )
                {
                    LeaveSplSem();
                    ReturnValue = (*pIniJob->pIniPrintProc->Control)(pIniPort->hProc, JOB_CONTROL_RESUME);
                    EnterSplSem();
                }

            }
            else
            {
                CheckSchedular = TRUE;
            }

            pIniPort->InCriticalSection &= ~PRINTPROC_RESUME;

            LeaveCriticalSection(&pIniJob->pIniPrintProc->CriticalSection);

            DECPORTREF(pIniPort);
        }

        DECJOBREF(pIniJob);
    }
    else
    {
        CheckSchedular = TRUE;
    }

    if(CheckSchedular)
    {
        CHECK_SCHEDULER();
    }


    DBGMSG( DBG_INFO, ( "Resumed Job %d; Status = %08x\n", pIniJob->JobId, pIniJob->Status ) );

    SPLASSERT( pIniJob != NULL &&
               pIniJob->pIniPrinter != NULL &&
               pIniJob->pIniPrinter->pIniSpooler != NULL );

    pIniSpooler = pIniJob->pIniPrinter->pIniSpooler;

    INCJOBREF( pIniJob );

    LogJobInfo(
        pIniSpooler,
        MSG_DOCUMENT_RESUMED,
        pIniJob->JobId,
        pIniJob->pDocument,
        pIniJob->pUser,
        pIniJob->pIniPrinter->pName,
        0);


    DECJOBREF( pIniJob );

    return ReturnValue;
}

DWORD
RestartJob(
    PINIJOB pIniJob
)
{

    //
    // If jobs is pending deletion can't restart. Monitor could call this
    // when there is a port error to reprint the job. If user has already
    // deleted the job this should fail
    //
    if ( pIniJob->Status & JOB_PENDING_DELETION )
        return ERROR_INVALID_PARAMETER;

    //
    // A job can be restarted only if:
    // it is currently printing or
    // it is printed or sent to printer.
    //
    if (!(pIniJob->Status & JOB_PRINTING) && !(pIniJob->Status & JOB_PRINTED) && !(pIniJob->Status & JOB_COMPLETE))
    {
        return ERROR_SUCCESS;                
    }

    //  JOB_PRINTING - means you have a print processor open
    //  JOB_DESPOOLING - means a job have been scheduled, it might be PRINTING
    //  or might have completed PRINTING but we are still logging etc.
    //  So be careful if you alter the JOB_PRINTING flag to know everywhere
    //  it is used.

    pIniJob->Status |= JOB_RESTART;

    if (pIniJob->pIniPort)
    {
        pIniJob->pIniPort->InCriticalSection = 0;
    }

    // Release any thread waiting on SeekPrinter
    SeekPrinterSetEvent(pIniJob, NULL, TRUE);

    // Release any thread waiting on LocalSetPort
    SetPortErrorEvent(pIniJob->pIniPort);

    //
    //  JOB_DESPOOLING and JOB_RESTART are checked in the PortThread port.c
    //

    if (!( pIniJob->Status & JOB_DESPOOLING )) {

        pIniJob->Status &= ~( JOB_PRINTED | JOB_BLOCKED_DEVQ | JOB_COMPLETE);
        //
        // Reset cbPrinted and cPagesPrinted.
        //
        pIniJob->cbPrinted = 0;
        pIniJob->cPagesPrinted = 0;
    }

    if ( pIniJob->Status & JOB_TIMEOUT ) {
        pIniJob->Status &= ~( JOB_TIMEOUT | JOB_ABANDON );
        FreeSplStr( pIniJob->pStatus );
        pIniJob->pStatus = NULL;
    }

    SetPrinterChange(pIniJob->pIniPrinter,
                     pIniJob,
                     NVJobStatusAndString,
                     PRINTER_CHANGE_SET_JOB,
                     pIniJob->pIniPrinter->pIniSpooler);

    CHECK_SCHEDULER();

    DBGMSG( DBG_INFO, ( "Restarted Job %d; Status = %08x\n", pIniJob->JobId, pIniJob->Status ) );

    return 0;
}








BOOL
LocalSetJob(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD Command
    )

/*++

Routine Description:

    This function will modify the settings of the specified Print Job.

Arguments:

    hPrinter - Handle to printer OR server.  Since this is could be a
        server, the pSpool->pIniPrinter is not always valid!

        Use pIniJob->pIniPrinter instead of pSpool->pIniPrinter.

    pJob - Points to a valid JOB structure containing at least a valid
        pPrinter, and JobId.

    Command - Specifies the operation to perform on the specified Job. A value
        of FALSE indicates that only the elements of the JOB structure are to
        be examined and set.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PINIJOB pIniJob = NULL;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   LastError = 0;
    DWORD   Position;
    BOOL    rc;
    PINISPOOLER pIniSpooler = NULL;
    PINIPRINTER pIniPrinter = NULL;
    LPWSTR pszDatatype = NULL;
    BOOL bValidDatatype = TRUE;

    DBGMSG( DBG_TRACE, ( "ENTER LocalSetJob\n" ) );

    //
    // We only allow RAW to go to downlevel machines (StartDocPrinter
    // already checks this).  We need to check this here since
    // the AddJob optimization tries to send an non-RAW (EMF) file, and
    // downlevel servers don't like that.
    //
    switch( Level ){
    case 1:
        pszDatatype = ((PJOB_INFO_1)pJob)->pDatatype;
        break;
    case 2:
        pszDatatype = ((PJOB_INFO_2)pJob)->pDatatype;
        break;
    default:

        //
        // 0 and 3 are the only other valid levels.
        //
        SPLASSERT( Level == 0 || Level == 3 );
        break;
    }

   EnterSplSem();

    if ( ValidateSpoolHandle(pSpool, 0 ) ) {

        pIniSpooler = pSpool->pIniSpooler;

        if (pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) {

            //
            // If it's a server handle, then search all jobs on this spooler.
            // This call also retrieves the pIniPrinter associated
            // with a print job.
            //
            pIniJob = FindServerJob( pIniSpooler,
                                     JobId,
                                     &Position,
                                     &pIniPrinter );

        } else if (pSpool->pIniPort && !(pSpool->pIniPort->Status & PP_MONITOR)) {

            //
            // It's a masq printer.  Send the call to the port RPC handle.
            //
            hPrinter = pSpool->hPort;

            if( pszDatatype ){
                bValidDatatype = ValidRawDatatype( pszDatatype );
            }

           LeaveSplSem();

            if( bValidDatatype ){
                rc = SetJob(hPrinter, JobId, Level, pJob, Command);
            } else {
                rc = FALSE;
                SetLastError( ERROR_INVALID_DATATYPE );
            }

            DBGMSG( DBG_TRACE, ( "EXIT LocalSetJob, rc = %d, %d", rc, GetLastError( ) ) );
            return rc;

        } else {

            //
            // It's a regular printer handle.
            //
            SPLASSERT( pSpool->pIniPrinter->pIniSpooler != NULL );
            SPLASSERT( pSpool->pIniPrinter->pIniSpooler->signature == ISP_SIGNATURE );
            SPLASSERT( pSpool->pIniPrinter->pIniSpooler == pSpool->pIniSpooler );

            pIniPrinter = pSpool->pIniPrinter;
            pIniJob = FindJob( pIniPrinter, JobId, &Position );
        }

        if ( pIniJob ){

            DWORD dwError;
            BOOL  bGrantAccess;

            //
            // If we are changing the datatype, and this is a RAW_ONLY
            // printer, and the datatype is not a valid RAW datatype,
            // then fail the call.
            //
            if( pszDatatype &&
                ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_RAW_ONLY ) &&
                !ValidRawDatatype( pszDatatype )){

                SetLastError( ERROR_INVALID_DATATYPE );
                LeaveSplSem();

                DBGMSG( DBG_TRACE, ( "Failed to set to non-RAW datatype (RAW_ONLY)\n" ));
                return FALSE;
            }

            //
            // If the LocalSetJob comes from inside the spooler, it won't come over RPC.
            // The monitor calls SetJob when the job printed so the spooler will let go
            // of the job. If we grant printing but not manage doc privileges to a principal
            // then the monitor loaded in the context of the user won't have access to set 
            // the job. In this case, if the LocalSetJob comes from within the spooler, we
            // grant privileges.
            //
            bGrantAccess = !IsCallViaRPC();
            
            if ( bGrantAccess ||
                 ValidateObjectAccess(SPOOLER_OBJECT_DOCUMENT,
                                      (Command == JOB_CONTROL_CANCEL ||
                                       Command == JOB_CONTROL_DELETE) ?
                                      DELETE : JOB_ACCESS_ADMINISTER,
                                      pIniJob, NULL, pIniSpooler ) ) {

                switch (Command) {
                case 0:
                    break;
                case JOB_CONTROL_PAUSE:
                    //
                    // WMI Trace Event
                    //
                    INCJOBREF(pIniJob);
                    LeaveSplSem();
                    LogWmiTraceEvent(pIniJob->JobId, EVENT_TRACE_TYPE_SPL_PAUSE, NULL);
                    EnterSplSem();
                    DECJOBREF(pIniJob);
                    PauseJob(pIniJob);
                    break;
                case JOB_CONTROL_RESUME:
                    //
                    // WMI Trace Event
                    //
                    INCJOBREF(pIniJob);
                    LeaveSplSem();
                    LogWmiTraceEvent(pIniJob->JobId, EVENT_TRACE_TYPE_SPL_RESUME, NULL);
                    EnterSplSem();
                    DECJOBREF(pIniJob);
                    ResumeJob(pIniJob);
                    break;
                //
                // JOB_CONTROL_DELETE is meant to delete the job.
                // So remove the JOB_RESTART bit and delete the job
                //
                case JOB_CONTROL_DELETE:
                    pIniJob->Status &= ~JOB_RESTART;
                    // Fall thru
                    pIniJob->dwJobControlsPending = 0;
                    DeleteJob(pIniJob,BROADCAST);
                    break;
                case JOB_CONTROL_CANCEL:
                    //
                    // JOB_CONTROL_CANCEL was used by old print monitors
                    // because of that we can't remove the JOB_RESTART bit
                    //
                    //
                    // Reset dwJobControlsPending
                    // Some old port monitors at EndDoc call SetJob with 
                    // JOB_CONTROL_CANCEL instead of JOB_CONTROL_SENT_TO_PRINTER,
                    // Because of this, dwJobControlsPending is not decremented 
                    // and the job doesn't get deleted after printing.
                    //
                    if (!(pIniJob->Status & (JOB_INTERRUPTED | JOB_SPOOLING | JOB_ERROR | JOB_PAPEROUT | JOB_OFFLINE))) {

                        pIniJob->Status |= JOB_PRINTED;
                        pIniJob->Status &= ~JOB_COMPLETE;

                        if ( !(pIniJob->Status & JOB_RESTART) &&
                             pIniJob->pCurrentIniJob == NULL ) {

                            INCJOBREF(pIniJob);
                            LeaveSplSem();

                            if (!(pIniJob->dwAlert & JOB_NO_ALERT)) {
                                SendJobAlert(pIniJob);
                            }

                            EnterSplSem();
                            DECJOBREF(pIniJob);
                        }
                    }

                    pIniJob->Status &= ~JOB_INTERRUPTED;
                    pIniJob->dwJobControlsPending = 0;
                    DeleteJob(pIniJob,BROADCAST);
                    break;
                case JOB_CONTROL_RESTART:
                    if (!(pSpool->TypeofHandle & PRINTER_HANDLE_DIRECT))
                    {
                        //
                        // WMI Trace Event.
                        //
                        INCJOBREF(pIniJob);
                        LeaveSplSem();
                        LogWmiTraceEvent(pIniJob->JobId,
                                         EVENT_TRACE_TYPE_SPL_SPOOLJOB,
                                         NULL);
                        EnterSplSem();
                        DECJOBREF(pIniJob);
                        LastError = RestartJob( pIniJob );
                    }
                    else
                        LastError = ERROR_INVALID_PRINTER_COMMAND;
                    break;

                //
                // With the addition of these commands port monitors should
                // send JOB_CONTROL_SENT_TO_PRINTER when last byte is written
                // to printer, and language monitor (if there is one) should
                // send JOB_CONTROL_LAST_PAGE_EJECTED when the last page
                // has ejected
                //
                case JOB_CONTROL_SENT_TO_PRINTER:
                case JOB_CONTROL_LAST_PAGE_EJECTED:

#if DBG
                    if( !(pIniJob->dwJobControlsPending > 0)){
                        DBGMSG( DBG_WARN, ( "LocalSetJob: dwJobsControlsPending > 0\n" ));
                    }
#endif
                    if ( --pIniJob->dwJobControlsPending ) {
                        //
                        // We still have controls pending, so do nothing
                        //


                    } else {

                        if (!(pIniJob->Status & (JOB_INTERRUPTED | JOB_SPOOLING | JOB_ERROR | JOB_PAPEROUT | JOB_OFFLINE))){

                            if ((Command == JOB_CONTROL_SENT_TO_PRINTER &&
                                 !(pIniJob->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_ENABLE_BIDI)) ||
                                 (Command == JOB_CONTROL_LAST_PAGE_EJECTED)) {

                                pIniJob->Status |= JOB_PRINTED;
                                pIniJob->Status &= ~JOB_COMPLETE;

                                if ( !(pIniJob->Status & JOB_RESTART) &&
                                     pIniJob->pCurrentIniJob == NULL ) {

                                    INCJOBREF(pIniJob);
                                    LeaveSplSem();

                                    if (!(pIniJob->dwAlert & JOB_NO_ALERT)) {
                                        SendJobAlert(pIniJob);
                                    }

                                    EnterSplSem();
                                    DECJOBREF(pIniJob);
                                }
                            }

                            pIniJob->Status &= ~JOB_INTERRUPTED;
                        }

                        if ( pIniJob->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS ) {

                            if ( pIniJob->pStatus ) {

                                FreeSplStr(pIniJob->pStatus);
                                pIniJob->pStatus    = NULL;

                                SetPrinterChange(pIniJob->pIniPrinter,
                                                 pIniJob,
                                                 NVJobStatusAndString,
                                                 PRINTER_CHANGE_SET_JOB,
                                                 pIniJob->pIniPrinter->pIniSpooler );
                            }

                        } else if ( pIniJob->pCurrentIniJob == NULL ||
                                    pIniJob->pCurrentIniJob->NextJobId == 0 ) {

                            DeleteJob(pIniJob,BROADCAST);
                        }
                    }
                    break;

                default:
                    LastError = ERROR_INVALID_PARAMETER;
                    break;
                }

                // If we managed to successfully complete the operation
                // specified by Command, let's go do the set job
                // properties as well.

                if (!LastError) {

                    // We must re-validate our pointers as we might have left
                    // our semaphore

                    if( pIniJob = FindJob( pIniPrinter, JobId, &Position )){
                        LastError = SetLocalJob( hPrinter,
                                                 pIniJob,
                                                 Level,
                                                 pJob );
                    }
                }

            } else

                LastError = GetLastError();
        } else

            LastError = ERROR_INVALID_PARAMETER;
    } else

        LastError = ERROR_INVALID_HANDLE;


    if (LastError) {

        SetLastError(LastError);

        DBGMSG( DBG_TRACE, ( "EXIT LocalSetJob, rc = FALSE, JobID %d, Status %08x, Error %d\n",
                             pIniJob ? pIniJob->JobId : 0,
                             pIniJob ? pIniJob->Status : 0,
                             LastError ) );

       LeaveSplSem();

        return FALSE;

    } else {

        //
        // (DeleteJob calls SetPrinterChange; so does SetLocalJob)
        //
        if ( Command &&
             pIniJob != NULL ) {

            SetPrinterChange(pIniPrinter,
                             pIniJob,
                             NVJobStatus,
                             PRINTER_CHANGE_SET_JOB,
                             pSpool->pIniSpooler );
        }

        DBGMSG( DBG_TRACE, ( "EXIT LocalSetJob, rc = TRUE, JobID %d, Status %08x\n",
                             pIniJob ? pIniJob->JobId : 0,
                             pIniJob ? pIniJob->Status : 0 ) );
    }

   LeaveSplSem();

    return TRUE;
}

#define Nullstrlen(psz)  ((psz) ? wcslen(psz)*sizeof(WCHAR)+sizeof(WCHAR) : 0)

DWORD
GetJobSize(
    DWORD   Level,
    PINIJOB pIniJob
)
{
    DWORD   cb;

SplInSem();

    switch (Level) {

    case 1:
        cb = sizeof(JOB_INFO_1) +
             wcslen(pIniJob->pIniPrinter->pName)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nullstrlen(pIniJob->pMachineName) +
             Nullstrlen(pIniJob->pUser) +
             Nullstrlen(pIniJob->pDocument) +
             Nullstrlen(pIniJob->pDatatype) +
             Nullstrlen(pIniJob->pStatus);
        break;

    case 2:
        cb = sizeof(JOB_INFO_2) +
             wcslen(pIniJob->pIniPrinter->pName)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nullstrlen(pIniJob->pMachineName) +
             Nullstrlen(pIniJob->pUser) +
             Nullstrlen(pIniJob->pDocument) +
             Nullstrlen(pIniJob->pNotify) +
             Nullstrlen(pIniJob->pDatatype) +
             wcslen(pIniJob->pIniPrintProc->pName)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nullstrlen(pIniJob->pParameters) +
             wcslen(pIniJob->pIniPrinter->pIniDriver->pName)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nullstrlen(pIniJob->pStatus);

        if (pIniJob->pDevMode) {
            cb += pIniJob->pDevMode->dmSize + pIniJob->pDevMode->dmDriverExtra;
            cb = (cb + sizeof(ULONG_PTR)-1) & ~(sizeof(ULONG_PTR)-1);
        }

        break;

    case 3:
        cb = sizeof(JOB_INFO_3);
        break;

    default:

        cb = 0;
        break;
    }

    return cb;
}

LPBYTE
CopyIniJobToJob(
    PINIJOB pIniJob,
    DWORD   Level,
    LPBYTE  pJobInfo,
    LPBYTE  pEnd,
    LPBOOL  pbSuccess
)
{
    LPWSTR *pSourceStrings, *SourceStrings;
    LPJOB_INFO_2 pJob = (PJOB_INFO_2)pJobInfo;
    LPJOB_INFO_2 pJob2 = (PJOB_INFO_2)pJobInfo;
    LPJOB_INFO_1 pJob1 = (PJOB_INFO_1)pJobInfo;
    LPJOB_INFO_3 pJob3 = (PJOB_INFO_3)pJobInfo;
    DWORD   i, Status;
    DWORD   *pOffsets;

    *pbSuccess = FALSE;

SplInSem();

    switch (Level) {

    case 1:
        pOffsets = JobInfo1Strings;
        break;

    case 2:
        pOffsets = JobInfo2Strings;
        break;

    case 3:
        pOffsets = JobInfo3Strings;
        break;

    default:
        return pEnd;
    }

    Status = MapJobStatus(MAP_READABLE,
                          pIniJob->Status);

    for (i=0; pOffsets[i] != -1; i++) {
    }

    SourceStrings = pSourceStrings = AllocSplMem(i * sizeof(LPWSTR));

    if ( pSourceStrings ) {

        switch ( Level ) {

        case 1:

            pJob1->JobId        = pIniJob->JobId;

            *pSourceStrings ++= pIniJob->pIniPrinter->pName;
            *pSourceStrings ++= pIniJob->pMachineName;
            *pSourceStrings ++= pIniJob->pUser;
            *pSourceStrings ++= pIniJob->pDocument;
            *pSourceStrings ++= pIniJob->pDatatype;
            *pSourceStrings ++= pIniJob->pStatus;

            pJob1->Status       = Status;
            pJob1->Priority     = pIniJob->Priority;
            pJob1->Position     = 0;
            pJob1->TotalPages   = pIniJob->cPages;
            pJob1->PagesPrinted = pIniJob->cPagesPrinted;
            pJob1->Submitted    = pIniJob->Submitted;

            // If this job is Printing then report back size remaining
            // rather than the job size.   This will allow users to see
            // progress of print jobs from printmanage.

            if (pIniJob->Status & JOB_PRINTING) {

                // For Remote Jobs we are NOT going to have an accurate
                // cPagesPrinted since we are not rendering on the
                // server.   So we have to figure out an estimate

                if ((pIniJob->Status & JOB_REMOTE) &&
                    (pIniJob->cPagesPrinted == 0) &&
                    (pIniJob->Size != 0) &&
                    (pIniJob->cPages != 0)) {

                    pJob1->PagesPrinted = ((pIniJob->cPages * pIniJob->cbPrinted) / pIniJob->Size);

                }

                if (pJob1->TotalPages < pIniJob->cPagesPrinted) {

                    //
                    // Never let the total pages drop below zero.
                    //
                    pJob1->TotalPages = 0;

                } else {

                    pJob1->TotalPages -= pIniJob->cPagesPrinted;
                }
            }
            break;

        case 2:

            pJob2->JobId = pIniJob->JobId;

            *pSourceStrings ++= pIniJob->pIniPrinter->pName;
            *pSourceStrings ++= pIniJob->pMachineName;
            *pSourceStrings ++= pIniJob->pUser;
            *pSourceStrings ++= pIniJob->pDocument;
            *pSourceStrings ++= pIniJob->pNotify;
            *pSourceStrings ++= pIniJob->pDatatype;
            *pSourceStrings ++= pIniJob->pIniPrintProc->pName;
            *pSourceStrings ++= pIniJob->pParameters;
            *pSourceStrings ++= pIniJob->pIniPrinter->pIniDriver->pName;
            *pSourceStrings ++= pIniJob->pStatus;

            if (pIniJob->pDevMode) {

                pEnd -= pIniJob->pDevMode->dmSize + pIniJob->pDevMode->dmDriverExtra;

                pEnd = (LPBYTE)ALIGN_PTR_DOWN(pEnd);

                pJob2->pDevMode = (LPDEVMODE)pEnd;

                CopyMemory( pJob2->pDevMode,
                            pIniJob->pDevMode,
                            pIniJob->pDevMode->dmSize + pIniJob->pDevMode->dmDriverExtra );

            } else {

                pJob2->pDevMode = NULL;

            }

            pJob2->pSecurityDescriptor = NULL;            // Not Supported.

            pJob2->Status       = Status;
            pJob2->Priority     = pIniJob->Priority;
            pJob2->Position     = 0;
            pJob2->StartTime    = pIniJob->StartTime;
            pJob2->UntilTime    = pIniJob->UntilTime;
            pJob2->TotalPages   = pIniJob->cPages;
            pJob2->Size         = pIniJob->Size;
            pJob2->Submitted    = pIniJob->Submitted;
            pJob2->Time         = pIniJob->Time;
            pJob2->PagesPrinted = pIniJob->cPagesPrinted;

            // If this job is Printing then report back size remaining
            // rather than the job size.   This will allow users to see
            // progress of print jobs from printmanage.

            if ( pIniJob->Status & JOB_PRINTING ) {

                pJob2->Size -= pIniJob->cbPrinted;

                // For Remote Jobs we are NOT going to have an accurate
                // cPagesPrinted since we are not rendering on the
                // server.   So we have to figure out an estimate

                if ((pIniJob->Status & JOB_REMOTE) &&
                    (pIniJob->cPagesPrinted == 0) &&
                    (pIniJob->Size != 0) &&
                    (pIniJob->cPages != 0)) {

                    pJob2->PagesPrinted = ((pIniJob->cPages * pIniJob->cbPrinted) / pIniJob->Size);

                }

                if (pJob2->TotalPages < pJob2->PagesPrinted) {

                    //
                    // Never let the total pages drop below zero.
                    //
                    pJob2->TotalPages = 0;

                } else {

                    pJob2->TotalPages -= pJob2->PagesPrinted;
                }
            }

            break;

        case 3:

            pJob3->JobId = pIniJob->JobId;

            if ( pIniJob->pCurrentIniJob == NULL ) {

                pJob3->NextJobId = pIniJob->NextJobId;

            } else {

                //
                //  If we are currently Printing this Job, then the
                //  FAX Monitor Needs to know if there is another job
                //  to know where we are in the chain of jobs
                //

                pJob3->NextJobId = pIniJob->pCurrentIniJob->NextJobId;
            }


            break;


        default:
            return pEnd;
        }

        pEnd = PackStrings( SourceStrings, pJobInfo, pOffsets, pEnd );

        FreeSplMem( SourceStrings );

        *pbSuccess = TRUE;

    } else {

        DBGMSG( DBG_WARNING, ("Failed to alloc Job source strings."));
    }

    return pEnd;
}

BOOL
LocalGetJob(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)

/*++

Routine Description:

    This function will retrieve the settings of the specified Print Job.

Arguments:

    hPrinter - Handle to printer OR server.  Since this is could be a
        server, the pSpool->pIniPrinter is not always valid!  Use
        pIniJob->pIniPrinter instead of pSpool->pIniPrinter.

    pJob - Points to a valid JOB structure containing at least a valid
        pPrinter, and JobId.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.
--*/

{
    PINIJOB     pIniJob;
    DWORD       Position;
    DWORD       cb;
    LPBYTE      pEnd;
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    DWORD       LastError=0;
    PINIPRINTER pIniPrinter;
    BOOL        bSuccess;

   EnterSplSem();

    if ( ValidateSpoolHandle(pSpool, 0 )) {

        if (pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) {

            //
            // If it's a server handle, then search all jobs on this spooler.
            // This call also retrieves the pIniPrinter associated
            // with a print job.
            //
            pIniJob = FindServerJob( pSpool->pIniSpooler,
                                     JobId,
                                     &Position,
                                     &pIniPrinter );

        } else if (pSpool->pIniPort && !(pSpool->pIniPort->Status & PP_MONITOR)) {

            //
            // It's a masq printer.  Send the call to the port RPC handle.
            //
            hPrinter = pSpool->hPort;
           LeaveSplSem();

            return GetJob(hPrinter, JobId, Level, pJob, cbBuf, pcbNeeded);

        } else {

            //
            // It's a regular printer handle.
            //
            pIniPrinter = pSpool->pIniPrinter;
            pIniJob = FindJob( pIniPrinter, JobId, &Position);
        }

        if( pIniJob ){

            cb=GetJobSize(Level, pIniJob);

            *pcbNeeded=cb;

            if (cbBuf >= cb) {

                pEnd = pJob+cbBuf;

                CopyIniJobToJob(pIniJob, Level, pJob, pEnd, &bSuccess);

                if (bSuccess) {

                    switch (Level) {
                    case 1:
                        ((PJOB_INFO_1)pJob)->Position = Position;
                        break;
                    case 2:
                        ((PJOB_INFO_2)pJob)->Position = Position;
                        break;
                    }

                } else

                    LastError = ERROR_NOT_ENOUGH_MEMORY;

            } else

                LastError = ERROR_INSUFFICIENT_BUFFER;

        } else

            LastError = ERROR_INVALID_PARAMETER;
    } else

        LastError = ERROR_INVALID_HANDLE;

   LeaveSplSem();
    SplOutSem();

    if (LastError) {

        SetLastError(LastError);
        return FALSE;
    }

    return TRUE;
}

// This will simply return the first port that is found that has a
// connection to this printer

PINIPORT
FindIniPortFromIniPrinter(
    PINIPRINTER pIniPrinter
)
{
    PINIPORT    pIniPort;
    DWORD       i;

    SPLASSERT( pIniPrinter->signature == IP_SIGNATURE );
    SPLASSERT( pIniPrinter->pIniSpooler != NULL );
    SPLASSERT( pIniPrinter->pIniSpooler->signature == ISP_SIGNATURE );

    pIniPort = pIniPrinter->pIniSpooler->pIniPort;

    while (pIniPort) {

        for (i=0; i<pIniPort->cPrinters; i++) {

            if (pIniPort->ppIniPrinter[i] == pIniPrinter) {
                return pIniPort;
            }
        }

        pIniPort = pIniPort->pNext;
    }

    return NULL;
}

BOOL
LocalEnumJobs(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PINIJOB pIniJob;
    PINIJOB pIniFirstJob;
    DWORD   cb;
    LPBYTE  pEnd;
    DWORD   cJobs;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   Position;
    DWORD   LastError=0;
    BOOL    bSuccess;

    *pcbNeeded = 0;
    *pcReturned = 0;

    SplOutSem();
   EnterSplSem();

    if ( ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {

        if (pSpool->pIniPort && !(pSpool->pIniPort->Status & PP_MONITOR)) {

            hPrinter = pSpool->hPort;

           LeaveSplSem();

            return EnumJobs(hPrinter, FirstJob, NoJobs, Level, pJob, cbBuf,
                            pcbNeeded, pcReturned);
        }

        cb = 0;

        //
        //  Find the first Job
        //

        for ( pIniFirstJob = pSpool->pIniPrinter->pIniFirstJob, cJobs = FirstJob;
              pIniFirstJob && cJobs;
              pIniFirstJob = pIniFirstJob->pIniNextJob ) {

            if ( !( pIniFirstJob->Status & JOB_HIDDEN ) || Level == 3 )
                cJobs--;

        }

        //
        //  Calc size required
        //

        for ( pIniJob = pIniFirstJob, cJobs = NoJobs;
              pIniJob && cJobs;
              pIniJob = pIniJob->pIniNextJob ) {

            if ( !( pIniJob->Status & JOB_HIDDEN ) || Level == 3 ) {
                cb += GetJobSize( Level, pIniJob );
                cJobs--;
            }
        }

        *pcbNeeded = cb;

        if ( cb <= cbBuf ) {

            pEnd = pJob + cbBuf;
            *pcReturned = 0;


            //
            //  Copy in all the Job info into the Users Buffer
            //

            for ( pIniJob = pIniFirstJob, cJobs = NoJobs, Position = FirstJob;
                  pIniJob && cJobs;
                  pIniJob = pIniJob->pIniNextJob ) {


                //
                //  Hide Chained Jobs, unless requesting chaining info
                //

                if ( !( pIniJob->Status & JOB_HIDDEN ) || Level == 3 ) {

                    pEnd = CopyIniJobToJob( pIniJob, Level, pJob, pEnd, &bSuccess );

                    if (!bSuccess) {

                        LastError = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }

                    Position++;

                    switch (Level) {

                        case 1:
                            ((PJOB_INFO_1)pJob)->Position = Position;
                            pJob += sizeof(JOB_INFO_1);
                            break;

                        case 2:
                            ((PJOB_INFO_2)pJob)->Position = Position;
                            pJob += sizeof(JOB_INFO_2);
                            break;

                        case 3:
                            pJob += sizeof(JOB_INFO_3);
                            break;
                    }

                    cJobs--;
                    (*pcReturned)++;
                }
            }

        } else

            LastError = ERROR_INSUFFICIENT_BUFFER;

    } else

        LastError = ERROR_INVALID_HANDLE;

   LeaveSplSem();
    SplOutSem();

    if (LastError) {

        SetLastError(LastError);
        return FALSE;
    }

    return TRUE;
}


#define BUFFER_LENGTH   10
VOID LogJobPrinted(
    PINIJOB pIniJob
)
{
    CHAR  pstrJobId[BUFFER_LENGTH];
    WCHAR pwstrJobId[BUFFER_LENGTH];
    CHAR  pstrSize[BUFFER_LENGTH];
    WCHAR pwstrSize[BUFFER_LENGTH];
    CHAR  pstrPages[BUFFER_LENGTH];
    WCHAR pwstrPages[BUFFER_LENGTH];
    PINISPOOLER pIniSpooler = NULL;

    SPLASSERT( pIniJob != NULL &&
               pIniJob->pIniPrinter != NULL &&
               pIniJob->pIniPrinter->pIniSpooler != NULL );

    pIniSpooler = pIniJob->pIniPrinter->pIniSpooler;

    _itoa(pIniJob->JobId, pstrJobId, BUFFER_LENGTH);
    AnsiToUnicodeString(pstrJobId, pwstrJobId, NULL_TERMINATED);

    _itoa(pIniJob->cbPrinted, pstrSize, BUFFER_LENGTH);
    AnsiToUnicodeString(pstrSize, pwstrSize, NULL_TERMINATED);

    _itoa(pIniJob->cPagesPrinted, pstrPages, BUFFER_LENGTH);
    AnsiToUnicodeString(pstrPages, pwstrPages, NULL_TERMINATED);

    SplLogEvent( pIniSpooler,
                 LOG_INFO,
                 MSG_DOCUMENT_PRINTED,
                 FALSE,
                 pwstrJobId,
                 pIniJob->pDocument ? pIniJob->pDocument : L"",
                 pIniJob->pUser,
                 pIniJob->pIniPrinter->pName,
                 pIniJob->pIniPort->pName,
                 pwstrSize,
                 pwstrPages,
                 NULL );
}


VOID
DeleteJobCheck(
    PINIJOB pIniJob
)
{
   SplInSem();

    if ((pIniJob->cRef == 0) && (pIniJob->Status & JOB_PENDING_DELETION)) {
        DeleteJob(pIniJob, BROADCAST);
    }
}


BOOL
DeleteJob(
    PINIJOB  pIniJob,
    BOOL     bBroadcast
)
{
    WCHAR szShadowFileName[MAX_PATH];
    WCHAR szSpoolFileName[MAX_PATH];
    BOOL  Direct;
    DWORD cJobs;
    DWORD Position;
    PINISPOOLER pIniSpooler = pIniJob->pIniPrinter->pIniSpooler;
    DWORD NextJobId;
    PINIPRINTER pIniPrinter;
    PNOTIFYVECTOR pNotifyVector;
    DWORD SpoolerFlags, JobId;
    BOOL bReturn = TRUE, bDeleteOnClose;
    PMAPPED_JOB *ppMappedJob, pTempMappedJob;
    PSPOOL  pPrinterSpool;
    BOOL bDeleteShdFile;
    HANDLE pFileItem = NULL;
    //
    // WMI Trace events vars.
    //
    WMI_SPOOL_DATA WmiData;
    DWORD CreateInfo;
    BOOL  bCheckScheduler = FALSE;

    //
    // Increment the pIniPrinter so that it and the pIniSpooler don't
    // potentially get deleted when the job goes away.
    //
    pIniPrinter = pIniJob->pIniPrinter;
    INCPRINTERREF( pIniPrinter );

 do {

    pNotifyVector = &NVJobStatus;

    SplInSem();

    SPLASSERT(pIniJob->signature == IJ_SIGNATURE);
    SPLASSERT(pIniJob->pIniPrinter->signature == IP_SIGNATURE );

    NextJobId = pIniJob->NextJobId;

    DBGMSG(DBG_INFO, ("DeleteJob Deleting job 0x%0x Status 0x%0x cRef = %d\n", pIniJob, pIniJob->Status, pIniJob->cRef));

    if (pIniJob->Status & JOB_RESTART)
        goto Done;

    Direct = pIniJob->Status & JOB_DIRECT;

    //
    //  Make sure users see the Pending Deleting bit
    //  over any other status string
    //
    if( pIniJob->pStatus ){

        FreeSplStr( pIniJob->pStatus );
        pIniJob->pStatus = NULL;
        pNotifyVector = &NVJobStatusAndString;
    }

    // Update the job alert flag
    if (!(pIniJob->dwAlert & JOB_ENDDOC_CALL)) {
        pIniJob->dwAlert |= JOB_NO_ALERT;
    }

    // Release any thread waiting on LocalSetPort
    SetPortErrorEvent(pIniJob->pIniPort);

    if (!(pIniJob->Status & JOB_PENDING_DELETION)) {

        pIniJob->Status |= JOB_PENDING_DELETION;

        // Release any thread waiting on SeekPrinter
        SeekPrinterSetEvent(pIniJob, NULL, TRUE);

        //
        // See that we always are StartDocComplete.
        //
        if ( pIniJob->StartDocComplete ) {
            SetEvent( pIniJob->StartDocComplete );
        }

        //
        // Just pending deletion, so don't use DELETE_JOB.
        //
        SetPrinterChange(pIniJob->pIniPrinter,
                         pIniJob,
                         *pNotifyVector,
                         PRINTER_CHANGE_SET_JOB,
                         pIniSpooler );

        if (pIniJob->Status & JOB_PRINTING) {

            BOOL            ReturnValue     = TRUE;
            PINIPRINTPROC   pIniPrintProc   = pIniJob->pIniPrintProc;
            PINIPORT        pIniPort        = NULL;

            INCJOBREF(pIniJob);

            // multiple threads may come in here, but they are all "delete"
            if (pIniJob->pIniPort && !(pIniJob->pIniPort->InCriticalSection & PRINTPROC_CANCEL)) {

                pIniPort = pIniJob->pIniPort;

                INCPORTREF(pIniPort);

                LeaveSplSem();
                EnterCriticalSection(&pIniJob->pIniPrintProc->CriticalSection);
                EnterSplSem();

                pIniPort->InCriticalSection |= PRINTPROC_CANCEL;

                if (pIniPort->hProc) {

                    LeaveSplSem();

                    DBGMSG(DBG_TRACE, ("DeleteJob calling %x hProc %x JOB_CONTROL_CANCEL\n",*pIniPrintProc->Control, pIniPort->hProc));
                    ReturnValue = (*pIniPrintProc->Control)(pIniPort->hProc, JOB_CONTROL_CANCEL);

                    EnterSplSem();
                }

                pIniPort->InCriticalSection &= ~PRINTPROC_CANCEL;

                //
                // Tell any other printproc calls not to call into the print processor.
                //
                pIniPort->InCriticalSection |= PRINTPROC_CANCELLED;

                LeaveCriticalSection(&pIniJob->pIniPrintProc->CriticalSection);

                DECPORTREF(pIniPort);
            }

            DECJOBREF(pIniJob);
        }
    }

    //
    // If we're Pooling, then don't bother with the
    // GetFilenameFromId call
    //
    if ( pIniJob->hFileItem == INVALID_HANDLE_VALUE )
    {
        GetFullNameFromId( pIniJob->pIniPrinter,
                           pIniJob->JobId, FALSE, szShadowFileName, FALSE );
    }

    if (pIniJob->cRef) {

        //
        // Instead of writing out the shadow job, let's just delete it.
        // If the spooler restarts, we will just kill the job.
        //
        // Note that we do not delete the file if the SPL_NO_UPDATE_JOBSHD
        // flag is set, this is so cluster failovers do not lose jobs.
        //
        // We also do not delete it if we're using filepools, we recycle the
        // handle.
        //

        if (!(pIniSpooler->SpoolerFlags & SPL_NO_UPDATE_JOBSHD))
        {
            if ( pIniJob->hFileItem != INVALID_HANDLE_VALUE )
            {
                FinishedWriting( pIniJob->hFileItem, FALSE );
                pIniJob->Status |= JOB_SHADOW_DELETED;
            }
            else
            {
                BOOL Deleted = FALSE;

                //
                // We set the flag here so that no one tries to write the job while we're deleting the file.
                //
                pIniJob->Status |= JOB_SHADOW_DELETED;

                INCJOBREF(pIniJob);

                LeaveSplSem();

                Deleted = DeleteFile(szShadowFileName);

                EnterSplSem();

                DECJOBREF(pIniJob);

                //
                // If we fail to delete the file, clear the deleted flag.
                //
                if (!Deleted) {
                    DBGMSG(DBG_WARNING, ("DeleteJob DeleteFile(%ws) failed %d\n", szShadowFileName, GetLastError()));
                    pIniJob->Status &= ~JOB_SHADOW_DELETED;
                }
            }
        }
        //
        // We don't need an else here because the SPL_NO_UPDATE_JOBSHD
        // will cause a shadowfile not to be written anyway, so trying to write
        // it here is pointless.
        //


        goto Done;
    }

    if (pIniJob->Status & JOB_SPOOLING) {
        DBGMSG(DBG_WARNING,("DeleteJob: returning false because job still spooling\n"));
        bReturn = FALSE;
        goto Done;
    }

    SplInSem();

    SPLASSERT( pIniJob->hWriteFile == INVALID_HANDLE_VALUE );

    // Remove the job from linked list
    // The purpose of this is so the job has no other operations carried out
    // on it whilst we are out of critical section.

    SPLASSERT(pIniJob->cRef == 0);

    if (pIniJob->pIniPrinter->pIniFirstJob == pIniJob)
        pIniJob->pIniPrinter->pIniFirstJob = pIniJob->pIniNextJob;

    SPLASSERT(pIniJob->pIniPrinter->pIniFirstJob != pIniJob);

    if (pIniJob->pIniPrinter->pIniLastJob == pIniJob)
        pIniJob->pIniPrinter->pIniLastJob = pIniJob->pIniPrevJob;

    SPLASSERT(pIniJob->pIniPrinter->pIniLastJob != pIniJob);

    if (pIniJob->pIniPrevJob) {
        pIniJob->pIniPrevJob->pIniNextJob = pIniJob->pIniNextJob;
        SPLASSERT(pIniJob->pIniPrevJob->pIniNextJob != pIniJob);
    }

    if (pIniJob->pIniNextJob) {
        pIniJob->pIniNextJob->pIniPrevJob = pIniJob->pIniPrevJob;
        SPLASSERT(pIniJob->pIniNextJob->pIniPrevJob != pIniJob);
    }

    // MAKE Certain that the Job is gone
    SPLASSERT( pIniJob != FindJob( pIniJob->pIniPrinter, pIniJob->JobId, &Position ) );


    //
    //  Only log the Job Deleted Event if the job was not printed
    //  Or it was printing but it did not print all the bytes of the job
    //  This avoid having multiple event log entries for a job
    //  MSG_DOCUMENT_PRINTED and MSG_DOCUMENT_DELETED.
    //  If its not PRINTED, then most likely someone has manually
    //  deleted the job, so we are interested in logging that event.
    //
    if ( !( pIniJob->Status & JOB_PRINTED ) ||
          ( pIniJob->Status & JOB_PRINTED ) && pIniJob->Size > pIniJob->cbPrinted ) {

         //
         // We are going to leave critical section so up the ref count.
         //
         INCJOBREF(pIniJob);

         SPLASSERT( pIniJob != NULL &&
                    pIniJob->pIniPrinter != NULL &&
                    pIniSpooler != NULL );

         LogJobInfo(
             pIniSpooler,
             MSG_DOCUMENT_DELETED,
             pIniJob->JobId,
             pIniJob->pDocument,
             pIniJob->pUser,
             pIniJob->pIniPrinter->pName,
             0
             );

         DECJOBREF(pIniJob);

    }

    SPLASSERT( pIniJob->cRef == 0 );

    if ( pIniJob->hFileItem != INVALID_HANDLE_VALUE )
    {
        pFileItem = pIniJob->hFileItem;
    }
    else
    {
        GetFullNameFromId( pIniJob->pIniPrinter,
                           pIniJob->JobId, TRUE, szSpoolFileName, FALSE );
    }

    //
    // WMI Trace Events
    //
    if (GetFileCreationInfo(pFileItem, &CreateInfo) != S_OK)
    {
        // Assume all file created.
        CreateInfo = FP_ALL_FILES_CREATED;
    }
    SplWmiCopyEndJobData(&WmiData, pIniJob, CreateInfo);


    FreeSplStr( pIniJob->pDocument );
    FreeSplStr( pIniJob->pUser );
    FreeSplStr( pIniJob->pNotify );
    FreeSplStr( pIniJob->pDatatype );
    FreeSplStr( pIniJob->pMachineName );
    FreeSplStr( pIniJob->pParameters );
    FreeSplStr( pIniJob->pStatus );
    FreeSplStr( pIniJob->pOutputFile );
    FreeSplStr( pIniJob->pszSplFileName );

    if (pIniJob->pDevMode)
        FreeSplMem(pIniJob->pDevMode);

    if (!CloseHandle(pIniJob->hToken))
        DBGMSG( DBG_WARNING, ("CloseHandle(hToken) failed %d\n", GetLastError() ));

    if( pIniJob->pIniPort && pIniJob->pIniPort->hErrorEvent != NULL ){
        CloseHandle(pIniJob->pIniPort->hErrorEvent);
        pIniJob->pIniPort->hErrorEvent = NULL;
    }

    SPLASSERT( pIniJob->pIniPrinter->cJobs  != 0 );
    SPLASSERT( pIniJob->pIniPrintProc->cRef != 0 );
    SPLASSERT( !pIniJob->pIniPort );

    //
    // Freeup the JobId before we decrement cJobs.  We won't delete
    // the printer if cJobs is non-zero.  Since the pIniPrinter holds
    // a reference to pIniSpooler, we know pIniSpooler is valid at this
    // point.
    //

    // Record the JobId for updating the Id map
    JobId = pIniJob->JobId;

    //
    // If the printer in in pending deletion and
    // this is the last job in the queue, tell the driver that the printer
    // is beeing deleted.
    //
    if (pIniJob->pIniPrinter->cJobs == 1 &&
        pIniJob->pIniPrinter->Status & PRINTER_PENDING_DELETION) {

        INCPRINTERREF(pIniPrinter);
        LeaveSplSem();
        SplOutSem();

        PrinterDriverEvent( pIniPrinter, PRINTER_EVENT_DELETE, (LPARAM)NULL );

        EnterSplSem();
        SplInSem();
        DECPRINTERREF(pIniPrinter);

    }

    pIniJob->pIniPrinter->cJobs--;

    DECDRIVERREF( pIniJob->pIniDriver );

    pIniJob->pIniPrintProc->cRef--;

    cJobs = pIniJob->pIniPrinter->cJobs;

    if (pIniJob->pSecurityDescriptor)
        DeleteDocumentSecurity(pIniJob);


    // If we are doing a Purge Printer we don't want to set a printer change
    // event for each job being deleted

    if ( bBroadcast == BROADCAST ) {

        //
        // Flip on the JOB_STATUS_DELETED bit so that it can be reported.
        //
        pIniJob->Status |= JOB_DELETED;

        SetPrinterChange( pIniJob->pIniPrinter,
                          pIniJob,
                          NVDeletedJob,
                          PRINTER_CHANGE_DELETE_JOB | PRINTER_CHANGE_SET_PRINTER,
                          pIniSpooler );
    }

    // On Inspection it might look as though a Printer which is pending
    // deletion which is then purged might case the printer to be deleted
    // and Purge Printer to access violate or access a dead pIniPrinter.
    // However in order to do a purge there must be a valid active
    // hPrinter which would mean the cRef != 0.

    //
    // Check whether we should delete the spool files.
    //
    SpoolerFlags = pIniSpooler->SpoolerFlags;

    DeletePrinterCheck( pIniJob->pIniPrinter );

    SplInSem();
    SPLASSERT(pIniJob->cRef == 0);

    //  If the job was being printed whilst spooling it will have
    //  some syncronization handles which need to be cleaned up

    if ( pIniJob->WaitForWrite != NULL ){
        DBGMSG( DBG_TRACE, ("DeleteJob Closing WaitForWrite handle %x\n", pIniJob->WaitForWrite));
        CloseHandle( pIniJob->WaitForWrite );
        pIniJob->WaitForWrite = NULL;
    }

    if ( pIniJob->WaitForSeek != NULL ){
        DBGMSG( DBG_TRACE, ("DeleteJob Closing WaitForSeek handle %x\n", pIniJob->WaitForSeek));
        CloseHandle( pIniJob->WaitForSeek );
        pIniJob->WaitForSeek = NULL;
    }

    if ( pIniJob->WaitForRead != NULL ){
        DBGMSG( DBG_TRACE, ("DeleteJob Closing WaitForRead handle %x\n", pIniJob->WaitForRead));
        CloseHandle( pIniJob->WaitForRead );
        pIniJob->WaitForRead = NULL;
    }

    bDeleteShdFile = pIniJob->Status & JOB_SHADOW_DELETED;

    SPLASSERT( pIniJob->hWriteFile == INVALID_HANDLE_VALUE );

    DELETEJOBREF(pIniJob);

    FreeSplMem(pIniJob);
    pIniJob = NULL;

    // This flag indicates if the spool file is to be deleted on ClosePrinter
    bDeleteOnClose = FALSE;

    if (!Direct) {

        //
        // Don't delete the files if we don't want JOBSHD changes.
        // This happens when we are taking a cluster offline: we want
        // to free the pIniJobs, but leave the spool files intact so they
        // can be restarted on the other node.
        //
        if( !( SpoolerFlags & SPL_NO_UPDATE_JOBSHD )){

            HANDLE  hToken;

            LeaveSplSem();

            hToken = RevertToPrinterSelf();

            //
            // Delete the spool and shadow files.
            //
            if (!bDeleteShdFile)
            {
                if ( pFileItem )
                {
                    FinishedWriting( pFileItem, FALSE );
                }
                else
                {
                    if (!DeleteFile(szShadowFileName)) {

                        DBGMSG(DBG_WARNING, ("DeleteJob DeleteFile(%ws) failed %d\n", szShadowFileName, GetLastError()));
                    }
                }
            }

            if ( pFileItem )
            {
                FinishedWriting( pFileItem, TRUE );
                FinishedReading( pFileItem );

                //
                // This releases the shadow and Spool files ate the same time.
                //
                ReleasePoolHandle( &pFileItem );

                //
                // We need to check the scheduler to insure that this file item
                // gets removed from the pool if there is no other printing in
                // the system.
                // 
                bCheckScheduler = TRUE;

            }
            else
            {
                if (!DeleteFile(szSpoolFileName)) {

                    bDeleteOnClose = TRUE;
                    DBGMSG(DBG_WARNING, ("DeleteJob DeleteFile(%ws) failed %d\n", szSpoolFileName, GetLastError()));
                }
            }

            ImpersonatePrinterClient(hToken);

            EnterSplSem();
        }
    }

    // If the spool file could not be deleted and it must be deleted on ClosePrinter
    if (!bDeleteOnClose)
    {
        // Free the job id from the id map
        vMarkOff(pIniSpooler->hJobIdMap, JobId);

        // Remove the job info from any of the pSpool structures, since the spool file
        // does not have to be deleted on ClosePrinter.
        for (pPrinterSpool = pIniPrinter->pSpool;
             pPrinterSpool;
             pPrinterSpool = pPrinterSpool->pNext)
        {
            for (ppMappedJob = &(pPrinterSpool->pMappedJob);
                 *ppMappedJob;
                 ppMappedJob = &((*ppMappedJob)->pNext))
            {
                if ((*ppMappedJob)->JobId == JobId)
                {
                    // Delete this entry
                    pTempMappedJob = *ppMappedJob;
                    *ppMappedJob = pTempMappedJob->pNext;
                    FreeSplMem(pTempMappedJob->pszSpoolFile);
                    FreeSplMem(pTempMappedJob);

                    // There are no duplicates in this list
                    break;
                }
            }
        }
    }

    if ( bBroadcast == BROADCAST && dwEnableBroadcastSpoolerStatus ){
        BroadcastChange( pIniSpooler,WM_SPOOLERSTATUS, PR_JOBSTATUS, (LPARAM)cJobs);
    }


    //
    //  Chained Jobs
    //  If the Job we just deleted is part of a chain we need to go along
    //  the chain decrementing the reference count and potentially deleting the
    //  next job in the chain.
    //
    if ( NextJobId != 0 ) {

        //
        //  Decrement the reference count of the NextJobId
        //

        SplInSem();


        pIniJob = FindJob( pIniPrinter, NextJobId, &Position );

        if ( pIniJob != NULL ) {

            //
            //  was incremented in SetJob job_info_3
            //

            DECJOBREF( pIniJob );

            //
            //  Do not attempt to delete the NextJob until its ref count is Zero
            //

            if ( pIniJob->cRef != 0 ) {
                pIniJob = NULL;
            }

        } else {

            DBGMSG(DBG_WARNING, ("DeleteJob pIniJob %x NextJobId %d not found\n", pIniJob, pIniJob->NextJobId ));
        }

    }
    //
    // WMI Trace Events
    //
    if (pIniJob)
    {
        INCJOBREF(pIniJob);
    }
    LeaveSplSem();
    LogWmiTraceEvent(JobId, EVENT_TRACE_TYPE_SPL_DELETEJOB, &WmiData);
    EnterSplSem();
    if (pIniJob)
    {
        DECJOBREF(pIniJob);
    }


 } while ( pIniJob != NULL );

Done:

    //
    // Matches the increment at the beginning of this function.
    //
    DECPRINTERREF( pIniPrinter );
    DeletePrinterCheck( pIniPrinter );

    if (bCheckScheduler) {

        CHECK_SCHEDULER();
    }

    return bReturn;
}


VOID
LogJobInfo(
    PINISPOOLER pIniSpooler,
    NTSTATUS    EventId,
    DWORD       JobId,
    LPWSTR      pDocumentName,
    LPWSTR      pUser,
    LPWSTR      pPrinterName,
    DWORD       dwArgument
    )

/*++

Routine Description:
    Performs generic event logging for all job based events.

Arguments:
    DWORD EventId
    DWORD JobId
    LPWSTR

Return Value:
    VOID

Note:


--*/
{
    WCHAR pwstrJobId[BUFFER_LENGTH];
    WCHAR pwstrBuffer[BUFFER_LENGTH];

    _itow(JobId, pwstrJobId, 10);

    switch (EventId) {

    case MSG_DOCUMENT_DELETED:
    case MSG_DOCUMENT_PAUSED:
    case MSG_DOCUMENT_RESUMED:
       SplLogEvent(  pIniSpooler,
                     LOG_INFO,
                     EventId,
                     TRUE,
                     pwstrJobId,
                     pDocumentName ? pDocumentName : L"",
                     pUser,
                     pPrinterName,
                     NULL );
        break;

    case MSG_DOCUMENT_POSITION_CHANGED:
    case MSG_DOCUMENT_PRIORITY_CHANGED:
        _itow(dwArgument, pwstrBuffer, 10);
        SplLogEvent( pIniSpooler,
                     LOG_INFO,
                     EventId,
                     TRUE,
                     pwstrJobId,
                     pDocumentName ? pDocumentName : L"",
                     pUser,
                     pwstrBuffer,
                     pPrinterName,
                     NULL );
        break;

    case MSG_DOCUMENT_TIMEOUT:
        _itow(dwArgument, pwstrBuffer, 10);
        SplLogEvent( pIniSpooler,
                     LOG_WARNING,
                     EventId,
                     TRUE,
                     pwstrJobId,
                     pDocumentName ? pDocumentName : L"",
                     pUser,
                     pPrinterName,
                     pwstrBuffer,
                     NULL );
        break;

    default:
        DBGMSG( DBG_ERROR, ("LogJobInfo EventId %x not supported\n", EventId ));

    }
}


BOOL
bAddMachineName(
    PSPOOL pSpool,
    PINIJOB pIniJob,
    LPCWSTR pMachineName
    )

/*++

Routine Description:

    Add a machine name to a pIniJob.

Arguments:

    pSpool - Handle of session.

    pIniJob - pIniJob to update (pMachineName field).

    pMachineName - Name passed in from ADDJOB_INFO_2 structure.  OPTIONAL

Return Value:

    TRUE - Success
    FALSE - Failure -- last error set.

--*/

{
    DWORD Status;
    LPWSTR pszRpcFree = NULL;
    LPCWSTR pszPartialName = NULL;

    if( pMachineName ){

        //
        // We have a machine name passed in from the client.
        //
        pszPartialName = pMachineName;

    } else {

        handle_t serverBinding;
        LPWSTR pszBinding;

        Status = RpcBindingServerFromClient( NULL, &serverBinding );
        if( Status != ERROR_SUCCESS ){
            DBGMSG( DBG_WARN,
                    ( "RpcBindingServerFromClient failed with Status %d\n",
                      Status ));
        } else {

            Status = RpcBindingToStringBinding( serverBinding, &pszBinding );
            if( Status != ERROR_SUCCESS ){
                DBGMSG( DBG_WARN,
                        ( "RpcBindingToStringBinding failed with Status %d\n",
                          Status ));
            } else {

                //
                // Acquire just the network address.
                //
                Status = RpcStringBindingParse( pszBinding,
                                                NULL,
                                                NULL,
                                                &pszRpcFree,
                                                NULL,
                                                NULL );
                if( Status == RPC_S_OK ){

                    pszPartialName = pszRpcFree;

                } else  {

                    DBGMSG( DBG_WARN,
                            ( "RpcStringBindingParse failed with Status %d\n",
                              Status ));
                }

                Status = RpcStringFree( &pszBinding );
                if( Status != ERROR_SUCCESS ){
                    DBGMSG( DBG_WARN,
                            ( "RpcStringFree failed with Status %d\n",
                              Status ));
                }
            }

            Status = RpcBindingFree( &serverBinding );
            if( Status != ERROR_SUCCESS ){
                DBGMSG( DBG_WARN,
                        ( "RpcBindingFree failed with Status %d\n",
                          Status ));
            }
        }

        //
        // If no partial name from RPC, use the client info.
        //
        if( !pszPartialName ){

            //
            // Unable to retrieve name; rely on handle's passed in name.
            //
            if( pSpool->SplClientInfo1.pMachineName ){
                pIniJob->pMachineName = AllocSplStr( pSpool->SplClientInfo1.pMachineName );
            }

            //
            // Very last resort, use local machine name.  This is completely
            // bogus, but backward compatible.
            //
            if( !pIniJob->pMachineName ){
                pIniJob->pMachineName = AllocSplStr(pSpool->pIniSpooler->pMachineName);
            }
        }
    }

    //
    // If it's a partial name, make sure it starts with two backslashes.
    //
    if( pszPartialName ){

        if( pszPartialName[0] != '\\' ){

            UINT cb = ( wcslen( pszPartialName ) + 3 ) *
                      sizeof( pszPartialName[0] );

            pIniJob->pMachineName = (LPWSTR)AllocSplMem( cb );

            if( pIniJob->pMachineName ){

                pIniJob->pMachineName[0] = TEXT( '\\' );
                pIniJob->pMachineName[1] = TEXT( '\\' );

                wcscpy( &pIniJob->pMachineName[2], pszPartialName );
            }
        } else {
            pIniJob->pMachineName = AllocSplStr( pszPartialName );
        }
    }

    //
    // Free off any necessary buffers.
    //
    if( pszRpcFree ){

        Status = RpcStringFree( &pszRpcFree );
        if( Status != ERROR_SUCCESS ){
            DBGMSG( DBG_WARN,
                    ( "RpcStringFree failed with Status %d\n", Status ));
        }
    }

    return pIniJob->pMachineName != NULL;
}

PINIJOB
CreateJobEntry(
    PSPOOL pSpool,
    DWORD  Level,
    LPBYTE pDocInfo,
    DWORD  JobId,
    BOOL  bRemote,
    DWORD  JobStatus,
    LPWSTR pMachineName)
{
    PDOC_INFO_1 pDocInfo1 = (PDOC_INFO_1)pDocInfo;
    PINIJOB pIniJob = NULL;
    PINIPRINTPROC pIniPrintProc;
    BOOL        bUserName;
    WCHAR       UserName[MAX_PATH];
    DWORD       cbUserName = MAX_PATH;
    PDEVMODE pDevMode;
    LPWSTR pDefaultDatatype;
    DWORD       cchCount;
    LPWSTR  pName;
    PDEVMODE pDevModeFree = NULL;
    LPWSTR pMachineNameFixup = NULL;

    //
    // Assert that we are in Spooler Semaphore
    //

    SplInSem();

    //
    //  Sorry You cannot print whilst Upgrading
    //

    if ( dwUpgradeFlag != 0 ) {

        SetLastError( ERROR_PRINTQ_FULL );
        goto Fail;
    }


    //
    // Do the check for the printer pending deletion first
    //

    if (pSpool->pIniPrinter->Status & (PRINTER_PENDING_DELETION | PRINTER_NO_MORE_JOBS )) {

        DBGMSG(DBG_WARNING, ("The printer is pending deletion %ws\n", pSpool->pIniPrinter->pName));

        SetLastError(ERROR_PRINTER_DELETED);
        goto Fail;
    }


    //
    //  NT FAX Requires that you not be able to remotely print to a FAX
    //  printer unless you've installed the FAX Server
    //

    if ( bRemote &&
         pSpool->pIniPrinter->pIniSpooler->pNoRemotePrintDrivers ) {

         for ( cchCount = pSpool->pIniSpooler->cchNoRemotePrintDrivers, pName = pSpool->pIniSpooler->pNoRemotePrintDrivers;
               cchCount && *pName;
               cchCount -=  wcslen( pName ) + 1, pName += wcslen( pName ) + 1 ) {

            if ( _wcsicmp( pSpool->pIniPrinter->pIniDriver->pName, pName ) == STRINGS_ARE_EQUAL )  {


                SetLastError( ERROR_NETWORK_ACCESS_DENIED );

                DBGMSG( DBG_WARN, ("CreateJobEntry failing because driver %ws used, error %d\n", pName, GetLastError() ));
                goto Fail;
            }
        }
    }

    pIniJob = AllocSplMem( sizeof( INIJOB ));

    if ( pIniJob == NULL ) {

        DBGMSG( DBG_WARNING, ("AllocSplMem for the IniJob failed in CreateJobEntry\n"));
        goto Fail;
    }

    pIniJob->signature = IJ_SIGNATURE;
    pIniJob->pIniNextJob = pIniJob->pIniPrevJob = NULL;
    pIniJob->hFileItem = INVALID_HANDLE_VALUE;
    pIniJob->pszSplFileName = NULL;
    pIniJob->AddJobLevel = 0;

#ifdef _HYDRA_
    //
    // Must set the Job SessionId
    //
    pIniJob->SessionId = pSpool->SessionId;
#endif
    //
    // Pickup the default datatype/printproc if not in pSpool or
    // DocInfo.
    //

    pIniPrintProc = pSpool->pIniPrintProc ?
                        pSpool->pIniPrintProc :
                        pSpool->pIniPrinter->pIniPrintProc;

    if ( pDocInfo1 && pDocInfo1->pDatatype ) {

        if (!(pIniJob->pDatatype = AllocSplStr( pDocInfo1->pDatatype ))) {
            goto Fail;
        }

    } else {

        pDefaultDatatype = pSpool->pDatatype ?
                               pSpool->pDatatype :
                               pSpool->pIniPrinter->pDatatype;

        //
        // If going direct, we must use a RAW datatype.
        //

        if ((JobStatus & JOB_DIRECT) &&
            (!ValidRawDatatype(pDefaultDatatype))) {

            //
            // Can't use a non-raw, so fail with invalid datatype.
            // Cleanup and exit.
            //
            SetLastError( ERROR_INVALID_DATATYPE );
            goto Fail;

        } else {

            if (!(pIniJob->pDatatype = AllocSplStr( pDefaultDatatype ))) {
                goto Fail;
            }
        }
    }

    pIniJob->pIniPrintProc = FindDatatype( pIniPrintProc,
                                           pIniJob->pDatatype );

    if ( !pIniJob->pIniPrintProc )  {

        SetLastError( ERROR_INVALID_DATATYPE );
        goto Fail;
    }

    pIniJob->pIniPrintProc->cRef++;


    //
    // cRef is decremented in LocalEndDocPrinter and
    // in LocalScheduleJob
    //

    INITJOBREFONE(pIniJob);

    if ( bRemote ) {

        JobStatus |= JOB_REMOTE;
    }


    pIniJob->JobId = JobId;
    pIniJob->Status = JobStatus;

    //
    // Get the name of the user, leave critical section, this might take a long time to call LSA.
    //

   LeaveSplSem();
   SplOutSem();

    bUserName = GetUserName( UserName, &cbUserName );

   EnterSplSem();

    if ( bUserName ) {

        //
        // If we got user name from remote handle check it is the same we get here
        //
#if DBG
        if( pSpool->SplClientInfo1.pUserName &&
            _wcsicmp( UserName, pSpool->SplClientInfo1.pUserName ) &&
            _wcsicmp( UserName, L"ANONYMOUS LOGON" )){

            DBGMSG( DBG_WARN,
                    ( "CreateJobEntry: Bad UserName pSpool= "TSTR" Curent= "TSTR"\n",
                      DBGSTR( pSpool->SplClientInfo1.pUserName ),
                      DBGSTR( UserName )));
        }
#endif

        if (!(pIniJob->pUser = AllocSplStr( UserName ))) {
            goto Fail;
        }

        if (!(pIniJob->pNotify = AllocSplStr( UserName ))) {
            goto Fail;
        }


    } else {

        DBGMSG(DBG_WARNING, ("CreateJobEntry GetUserName failed: %d\n", GetLastError()));
        goto Fail;

    }

    //
    // Create a document security descriptor
    //

    pIniJob->pSecurityDescriptor = CreateDocumentSecurityDescriptor( pSpool->pIniPrinter->pSecurityDescriptor );

    if( !pIniJob->pSecurityDescriptor ){
        goto Fail;
    }

    //
    // Now process the DocInfo structure passed in
    //

    if (pDocInfo1 && pDocInfo1->pDocName)
        pIniJob->pDocument = AllocSplStr(pDocInfo1->pDocName);
    else
        pIniJob->pDocument = AllocSplStr(L"No Document Name");

    if (!pIniJob->pDocument)
        goto Fail;

    if (pDocInfo1 && pDocInfo1->pOutputFile) {
        if (!(pIniJob->pOutputFile = AllocSplStr(pDocInfo1->pOutputFile)))
            goto Fail;
    }
    else
        pIniJob->pOutputFile = NULL;


    GetSid( &pIniJob->hToken );

    //
    // Pickup default if none specified.
    // (Default at time of job submission.)
    //
    if( pSpool->pDevMode ){

        pDevMode = pSpool->pDevMode;

    } else {

        if( bGetDevModePerUser( NULL,
                                pSpool->pIniPrinter->pName,
                                &pDevModeFree )){

            pDevMode = pDevModeFree;

        } else {

            pDevMode = pSpool->pIniPrinter->pDevMode;
        }
    }

    if ( pDevMode ) {

        pIniJob->pDevMode = AllocDevMode( pDevMode );

        if ( pIniJob->pDevMode == NULL )
            goto Fail;

        FreeSplMem( pDevModeFree );
    }

    GetSystemTime( &pIniJob->Submitted );
    pIniJob->pIniPrinter = pSpool->pIniPrinter;
    pSpool->pIniPrinter->cJobs++;
    pSpool->pIniPrinter->cTotalJobs++;
    pIniJob->pIniDriver = pSpool->pIniPrinter->pIniDriver;

    INCDRIVERREF( pIniJob->pIniDriver );

    pIniJob->pIniPort = NULL;
    pIniJob->pParameters = NULL;

    if( !bAddMachineName( pSpool, pIniJob, pMachineName )){
        goto Fail;
    }

    pIniJob->pStatus = NULL;
    pIniJob->cPages = pIniJob->Size = 0;
    pIniJob->cPagesPrinted = 0;
    pIniJob->Priority  = pSpool->pIniPrinter->DefaultPriority == NO_PRIORITY ?
                         DEF_PRIORITY : pSpool->pIniPrinter->DefaultPriority;
    pIniJob->StartTime = pSpool->pIniPrinter->StartTime;
    pIniJob->UntilTime = pSpool->pIniPrinter->UntilTime;
    pIniJob->cbPrinted = 0;
    pIniJob->WaitForWrite = NULL;
    pIniJob->WaitForRead  = NULL;
    pIniJob->hWriteFile   = INVALID_HANDLE_VALUE;
    pIniJob->dwJobNumberOfPagesPerSide = 0;
    pIniJob->dwDrvNumberOfPagesPerSide = 0;
    pIniJob->cLogicalPages             = 0;
    pIniJob->cLogicalPagesPrinted      = 0;

    // Additional fields for SeekPrinter.
    pIniJob->WaitForSeek  = NULL;
    pIniJob->bWaitForEnd  = FALSE;
    pIniJob->bWaitForSeek = FALSE;
    pIniJob->liFileSeekPosn.u.HighPart = 0;
    pIniJob->liFileSeekPosn.u.LowPart  = 0;

    if( dwEnableBroadcastSpoolerStatus ){

        BroadcastChange( pIniJob->pIniPrinter->pIniSpooler,
                         WM_SPOOLERSTATUS,
                         PR_JOBSTATUS,
                         pIniJob->pIniPrinter->cJobs );
    }

    return pIniJob;

Fail:

    if (pIniJob) {
        FreeSplStr(pIniJob->pDatatype);
        FreeSplStr(pIniJob->pUser);
        FreeSplStr(pIniJob->pNotify);
        FreeSplStr(pIniJob->pDocument);
        FreeSplStr(pIniJob->pOutputFile);
        FreeSplStr(pIniJob->pMachineName);

        if ( pIniJob->pDevMode != NULL )
            FreeSplMem(pIniJob->pDevMode);

        if (pIniJob->pSecurityDescriptor)
            DeleteDocumentSecurity(pIniJob);

        if (pIniJob->hToken)
            CloseHandle(pIniJob->hToken);

        FreeSplMem(pIniJob);
    }

    return NULL;
}


BOOL
DeletePrinterCheck(
    PINIPRINTER pIniPrinter
    )
{
    //
    // Enough space for printer, DWORD.  (Zombie string)
    //
    WCHAR TempName[MAX_PATH + 20];
    BOOL bReturn = FALSE;

    SplInSem();

    if ( pIniPrinter->Status & PRINTER_PENDING_DELETION ) {

        if ( pIniPrinter->cJobs == 0 ) {

            if ( pIniPrinter->cRef == 0 ) {

                return DeletePrinterForReal( pIniPrinter, NON_INIT_TIME );
            }

            //
            // If we don't want to update PRINTERINI, then don't
            // zombie the printer.
            //
            if( pIniPrinter->pIniSpooler->SpoolerFlags & SPL_OFFLINE ){
                return TRUE;
            }

            //
            // We will have zombie printers only if we should fail OpenPrinter
            // on printers pending deletion. Because when marking a printer
            // as zombie printer we change the name
            //
            if ( pIniPrinter->pIniSpooler->SpoolerFlags &
                 SPL_FAIL_OPEN_PRINTERS_PENDING_DELETION ) {

                if ( !( pIniPrinter->Status & PRINTER_ZOMBIE_OBJECT )) {

                    if ( !pIniPrinter->cZombieRef ) {
                        PWSTR pNameTemp = NULL;
                        PWSTR pShareNameTemp = NULL;

                        wsprintf( TempName, L"%ws,%d", pIniPrinter->pName, gdwZombieCount++ );

                        pNameTemp = AllocSplStr(TempName);
                        pShareNameTemp = AllocSplStr(TempName);

                        if (pNameTemp && pShareNameTemp) {

                            UpdateWinIni( pIniPrinter );

                            // Change "PrinterName" to "PrinterName,UniqueId"
                            // Since comma is not legal in a printer name
                            // the name will continue to be unique, but different
                            // so that OpenPrinters will still fail.
                            // We have to have a unique ID appended in case someone is crazy enough
                            // to create / delete / create / delete the same printer over and over.


                            CopyPrinterIni( pIniPrinter, TempName );

                            DeletePrinterIni( pIniPrinter );

                            FreeSplStr(pIniPrinter->pName);
                            FreeSplStr(pIniPrinter->pShareName);

                            pIniPrinter->pName = pNameTemp;
                            pIniPrinter->pShareName = pShareNameTemp;

                            if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED ) {

                                pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_SHARED;
                                pIniPrinter->Status |= PRINTER_WAS_SHARED;
                            }

                            pIniPrinter->Status |= PRINTER_ZOMBIE_OBJECT;

                            UpdatePrinterIni( pIniPrinter , UPDATE_CHANGEID );

                            UpdateWinIni( pIniPrinter );

                            bReturn = TRUE;

                        } else {
                            FreeSplStr(pNameTemp);
                            FreeSplStr(pShareNameTemp);

                            DBGMSG(DBG_WARNING, ("%ws printer object could not be zombied\n", pIniPrinter->pName));
                        }

                    } else {

                        DBGMSG(DBG_WARNING, ("%ws Printer object should be zombied but is locked with %d ZombieRefs\n", pIniPrinter->pName, pIniPrinter->cZombieRef));
                    }

                } else {

                    DBGMSG(DBG_TRACE, ("%ws zombie printer object\n", pIniPrinter->pName));
                    bReturn = TRUE;
                }

                DBGMSG( DBG_TRACE, ("%ws pending deletion: There %s still %d reference%s waiting\n",
                                      pIniPrinter->pName,
                                      pIniPrinter->cRef == 1 ? "is" : "are",
                                      pIniPrinter->cRef,
                                      pIniPrinter->cRef == 1 ? "" : "s"));
            }

        } else {

            DBGMSG( DBG_TRACE, ("%ws pending deletion: There %s still %d jobs%s\n",
                                 pIniPrinter->pName,
                                 pIniPrinter->cJobs == 1 ? "is" : "are",
                                 pIniPrinter->cJobs,
                                 pIniPrinter->cJobs == 1 ? "" : "s"));
        }
    }

    return bReturn;
}



VOID
UpdateReferencesToChainedJobs(
    PINISPOOLER pIniSpooler
    )
/*++

Routine Description:

        Walks through all printers and all jobs associated with those printers
        Once it finds a job with a NextJobId, it increments the reference on the
        NextJob.

    Called on reboot

Arguments:
        pIniSpooer  Pointer to the Spooler


Return Value:
        NONE

--*/
{

    PINIJOB pIniJob;
    PINIJOB pNextJob;
    PINIPRINTER pIniPrinter;
    DWORD   Position;

    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );


    for ( pIniPrinter = pIniSpooler->pIniPrinter;
          pIniPrinter;
          pIniPrinter = pIniPrinter->pNext ) {


        SPLASSERT( pIniPrinter->signature == IP_SIGNATURE );


        for ( pIniJob = pIniPrinter->pIniFirstJob;
              pIniJob;
              pIniJob = pIniJob->pIniNextJob ) {


            SPLASSERT( pIniJob->signature == IJ_SIGNATURE );

            if ( pIniJob->NextJobId ) {

                pNextJob = FindJob( pIniPrinter, pIniJob->NextJobId, &Position );

                if ( pNextJob ) {

                    pNextJob->Status |= ( JOB_COMPOUND | JOB_HIDDEN );

                    DBGMSG( DBG_TRACE, ("UpdateReferencesToChainedJobs Found pNextJob %x JobId %d\n",pNextJob, pNextJob->JobId));
                    INCJOBREF( pNextJob );

                } else {

                    DBGMSG( DBG_WARNING, ("UpdateReferenesToChainedJobs unable to find Job %d\n", pIniJob->NextJobId ));

                    pIniJob->NextJobId = 0;

                }
            }
        }
    }
}


VOID UpdateJobAttributes(
    PINIJOB  pIniJob
)

/*++
Function Description: Updates the nup attributes in the pIniJob struct

Parameters: pIniJob   - job struct to be updated

Return Values: NONE
--*/

{
    ATTRIBUTE_INFO_2 AttributeInfo;
    HANDLE           hDrvPrinter = NULL;
    FARPROC          pfnDrvQueryJobAttributes;
    HINSTANCE        hDrvLib = NULL;
    fnWinSpoolDrv    fnList;

    SplOutSem();

    //
    // No job or the job has already been initialized or we're printing Raw
    //
    if (!pIniJob || !pIniJob->pIniPrinter  ||
        pIniJob->dwDrvNumberOfPagesPerSide ||
        pIniJob->dwJobNumberOfPagesPerSide ||
        ValidRawDatatype(pIniJob->pDatatype))
    {
        return;
    }

    // Initialize job attributes;
    pIniJob->dwJobNumberOfPagesPerSide = 1;
    pIniJob->dwDrvNumberOfPagesPerSide = 1;

    // Get the pointer to the client side functions from the router
    if (!SplInitializeWinSpoolDrv(&fnList)) {
        return;
    }

    // Get a client side printer handle to pass to the driver
    if (!(* (fnList.pfnOpenPrinter))(pIniJob->pIniPrinter->pName, &hDrvPrinter, NULL)) {
        DBGMSG(DBG_WARNING, ("Open printer failed\n"));
        goto CleanUp;
    }

    // Load the driver config file
    if (!(hDrvLib = (* (fnList.pfnLoadPrinterDriver))(hDrvPrinter))) {
        DBGMSG(DBG_WARNING, ("Driver could not be loaded\n"));
        goto CleanUp;
    }

    // Call the DrvQueryJobAtributes function in the driver
    if (pfnDrvQueryJobAttributes = GetProcAddress(hDrvLib, "DrvQueryJobAttributes")) {

        if ((* pfnDrvQueryJobAttributes) (hDrvPrinter,
                                          pIniJob->pDevMode,
                                          1,
                                          (LPBYTE) &AttributeInfo)) {

            pIniJob->dwJobNumberOfPagesPerSide = AttributeInfo.dwJobNumberOfPagesPerSide;
            pIniJob->dwDrvNumberOfPagesPerSide = AttributeInfo.dwDrvNumberOfPagesPerSide;
        }
    }

CleanUp:

    if (hDrvPrinter) {
        (* (fnList.pfnClosePrinter))(hDrvPrinter);
    }
    if (hDrvLib) {
        (* (fnList.pfnRefCntUnloadDriver))(hDrvLib, TRUE);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\jobid.h ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved

Module Name:

    jobid.h

Abstract:

    Handles job id bitmap.

Author:

    Albert Ting (AlbertT) 24-Oct-96

Environment:

    User Mode -Win32

Revision History:

    Ported from spooler.c code.

--*/

#ifndef _JOBID_H
#define _JOBID_H

typedef struct _JOB_ID_MAP {
    PDWORD pMap;
    DWORD dwMaxJobId;
    DWORD dwCurrentJobId;
} JOB_ID_MAP, *PJOB_ID_MAP;


#define pMapFromHandle( hJobIdMap ) (((PJOB_ID_MAP)hJobIdMap)->pMap)
#define MaxJobId( hJobIdMap ) (((PJOB_ID_MAP)hJobIdMap)->dwMaxJobId)

#define vMarkOn( hJobId, Id) \
    ((pMapFromHandle( hJobId ))[(Id) / 32] |= (1 << ((Id) % 32) ))

#define vMarkOff( hJobId, Id) \
    ((pMapFromHandle( hJobId ))[(Id) / 32] &= ~(1 << ((Id) % 32) ))

#define bBitOn( hJobId, Id) \
    ((pMapFromHandle( hJobId ))[Id / 32] & ( 1 << ((Id) % 32) ) )

BOOL
ReallocJobIdMap(
    HANDLE hJobIdMap,
    DWORD dwNewMinSize
    );

DWORD
GetNextId(
    HANDLE hJobIdMap
    );

HANDLE
hCreateJobIdMap(
    DWORD dwMinSize
    );

VOID
vDeleteJobIdMap(
    HANDLE hJobIdMap
    );

#endif // ifdef _JOBID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\local.h ===
/*++

Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    local.h

Abstract:

    Header file for Local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    06-Jun-1995       MuhuntS   DRIVER_INFO_3, PRINTER_INFO_5 changes
    17-May-1992       ChuckC    Added CreateSplUniStr, DeleteSplUniStr.
    27 June 94        MattFe    pIniSpooler
    10 July 94        MattFe    Spl entry points for Caching

--*/

#include <ntfytab.h>
#include "splcom.h"

#ifdef __cplusplus
extern "C" {
#endif

//
//  Defines to make code more readable.
//

#define ONEDAY  60*24
#define BROADCAST    TRUE
#define NO_BROADCAST FALSE
#define UPDATE_DS_ONLY  3
#define CHANGEID_ONLY   2
#define UPDATE_CHANGEID 1
#define KEEP_CHANGEID   0
#define OVERWRITE_EXISTING_FILE FALSE
#define FIRST_FILE_TIME_GREATER_THAN_SECOND 1
#define NO_COPY_IF_TARGET_EXISTS TRUE
#define OVERWRITE_IF_TARGET_EXISTS FALSE
#define USE_SCRATCH_DIR TRUE
#define IMPERSONATE_USER TRUE
#define DO_NOT_IMPERSONATE_USER FALSE
#define STRINGS_ARE_EQUAL 0
#define ONE_MINUTE       60*1000
#define TEN_MINUTES   10*ONE_MINUTE
#define TWO_MINUTES    2*ONE_MINUTE
#define SEVEN_MINUTES  7*ONE_MINUTE
#define FIFTEEN_MINUTES 15*ONE_MINUTE
#define HOUR_OF_MINUTES     60
#define ONE_HOUR            ONE_MINUTE*HOUR_OF_MINUTES
#define DAY_OF_HOURS        24
#define DAY_OF_MINUTES      DAY_OF_HOURS*60
#define DEFAULT_NUMBER_MASTER_AND_BACKUP 3
#define DEFAULT_NUMBER_BROWSE_WORKSTATIONS 2
#define DEFAULT_REFRESH_TIMES_PER_DECAY_PERIOD 2;
#define FIND_ANY_VERSION        TRUE
#define FIND_COMPATIBLE_VERSION FALSE
#define DRIVER_UPGRADE          2
#define DRIVER_SEARCH           4
#define NT3X_VERSION    TRUE
#define CURRENT_VERSION FALSE
#define MAX_JOB_FAILURES 5
#define MAX_STATIC_ALLOC 2048

// Default timeout values we will return
#define DEFAULT_DNS_TIMEOUT     15000
#define DEFAULT_TX_TIMEOUT      45000


// Pruning definitions
#define PRUNE_DOWNLEVEL_NEVER           0
#define PRUNE_DOWNLEVEL_NICELY          1
#define PRUNE_DOWNLEVEL_AGGRESSIVELY    2

// Default pruning settings
#define DS_PRINTQUEUE_VERSION_WIN2000   4
#define DEFAULT_PRUNE_DOWNLEVEL         PRUNE_DOWNLEVEL_NEVER       // Never delete downlevel PQ
#define DEFAULT_PRUNING_PRIORITY        THREAD_PRIORITY_NORMAL
#define DEFAULT_PRUNING_RETRIES         2
#define DEFAULT_PRUNING_INTERVAL        (DAY_OF_MINUTES/(DEFAULT_PRUNING_RETRIES + 1)) // 8 hrs
#define DEFAULT_PRUNING_RETRY_LOG       0

#define MAX_PRUNING_RETRIES             10

// Default printQueue settings
#define IMMORTAL                        1
#define DEFAULT_IMMORTAL                !IMMORTAL
#define DEFAULT_VERIFY_PUBLISHED_STATE  INFINITE    // This is the interval
#define DEFAULT_PRINT_PUBLISH_POLICY    1

#define SERVER_THREAD_OFF               0
#define SERVER_THREAD_ON                1
#define SERVER_THREAD_UNCONFIGURED      2

// Default policy values
#define  KM_PRINTERS_ARE_BLOCKED 1       // 1 = blocked, 0 = not blocked
#define  SERVER_DEFAULT_KM_PRINTERS_ARE_BLOCKED  1
#define  WKS_DEFAULT_KM_PRINTERS_ARE_BLOCKED    0

extern  DWORD   DefaultKMPrintersAreBlocked;

extern  DWORD   gdwServerInstallTimeOut;


#define INIT_TIME       TRUE
#define NON_INIT_TIME   FALSE


extern  WCHAR *szPrinterData;
extern  WCHAR *szConfigurationKey;
extern  WCHAR *szDataFileKey;
extern  WCHAR *szDriverVersion;
extern  WCHAR *szTempDir;
extern  WCHAR *szDriversKey;
extern  WCHAR *szPrintersKey;
extern  WCHAR *szDirectory;
extern  WCHAR *szDriverIni;
extern  WCHAR *szDriverFile;
extern  WCHAR *szDriverFileEntry;
extern  WCHAR *szDriverDataFile;
extern  WCHAR *szDriverConfigFile;
extern  WCHAR *szDriverDir;
extern  WCHAR *szPrintProcDir;
extern  WCHAR *szPrinterDir;
extern  WCHAR *szClusterPrinterDir;
extern  WCHAR *szPrinterIni;
extern  WCHAR *szAllShadows;
extern  WCHAR *szNullPort;
extern  WCHAR *szComma;
extern  WCHAR *szName;
extern  WCHAR *szShare;
extern  WCHAR *szPort;
extern  WCHAR *szPrintProcessor;
extern  WCHAR *szDatatype;
extern  WCHAR *szPublishPoint;
extern  WCHAR *szCommonName;
extern  WCHAR *szObjectGUID;
extern  WCHAR *szDsKeyUpdate;
extern  WCHAR *szDsKeyUpdateForeground;
extern  WCHAR *szAction;
extern  WCHAR *szDriver;
extern  WCHAR *szLocation;
extern  WCHAR *szDescription;
extern  WCHAR *szAttributes;
extern  WCHAR *szStatus;
extern  WCHAR *szPriority;
extern  WCHAR *szDefaultPriority;
extern  WCHAR *szUntilTime;
extern  WCHAR *szStartTime;
extern  WCHAR *szParameters;
extern  WCHAR *szSepFile;
extern  WCHAR *szDevMode;
extern  WCHAR *szSecurity;
extern  WCHAR *szSpoolDir;
extern  WCHAR *szNetMsgDll;
extern  WCHAR *szTimeLastChange;
extern  WCHAR *szTotalJobs;
extern  WCHAR *szTotalBytes;
extern  WCHAR *szTotalPages;
extern  WCHAR *szHelpFile;
extern  WCHAR *szMonitor;
extern  WCHAR *szDependentFiles;
extern  WCHAR *szPreviousNames;
extern  WCHAR *szDNSTimeout;
extern  WCHAR *szTXTimeout;
extern  WCHAR *szNull;
extern  WCHAR *szPendingUpgrades;
extern  WCHAR *szMfgName;
extern  WCHAR *szOEMUrl;
extern  WCHAR *szHardwareID;
extern  WCHAR *szProvider;
extern  WCHAR *szDriverDate;
extern  WCHAR *szLongVersion;
extern  WCHAR *szClusDrvTimeStamp;

extern  HANDLE   hInst;
extern  LPWSTR   szPrintShare;
extern  LPWSTR   szPrtProcsShare;
extern  HKEY     hPrinterRootKey, hPrintersKey;
extern  PINISPOOLER pLocalIniSpooler;
extern  HANDLE   SchedulerSignal;
extern  HANDLE   PowerManagementSignal;
extern  DWORD    dwSchedulerThreadPriority;
extern  CRITICAL_SECTION SpoolerSection;

#if DBG
extern  HANDLE   hcsSpoolerSection;
#endif

extern  HANDLE   WinStaDllHandle;

extern  PINIENVIRONMENT pThisEnvironment;
extern  WCHAR *szPrintProcKey;
extern  WCHAR *szEnvironment;
extern  WCHAR *szMajorVersion;
extern  WCHAR *szMinorVersion;
extern  WCHAR *szRegistryRoot;
extern  WCHAR *szEMFThrottle;
extern  WCHAR *szFlushShadowFileBuffers;

extern  WCHAR *szClusterDriverRoot;
extern  WCHAR *szClusterNonAwareMonitors;

extern LPWSTR szRemoteDoc;
extern LPWSTR szLocalDoc;
extern LPWSTR szFastPrintTimeout;

extern  WCHAR *szPrintPublishPolicy;

extern LPWSTR szRaw;
extern DWORD    dwUpgradeFlag;

#define CHECK_SCHEDULER()   SetEvent(SchedulerSignal)

extern DWORD dwFastPrintWaitTimeout;
extern DWORD dwPortThreadPriority;
extern DWORD dwFastPrintThrottleTimeout;
extern DWORD dwFastPrintSlowDownThreshold;
extern DWORD dwWritePrinterSleepTime;
extern DWORD dwServerThreadPriority;
extern DWORD dwEnableBroadcastSpoolerStatus;
extern DWORD ServerThreadTimeout;
extern DWORD ServerThreadRunning;
extern DWORD NetPrinterDecayPeriod;
extern DWORD RefreshTimesPerDecayPeriod;
extern HANDLE ServerThreadSemaphore;
extern BOOL  bNetInfoReady;
extern DWORD FirstAddNetPrinterTickCount;
extern DWORD BrowsePrintWorkstations;

extern DWORD dwFlushShadowFileBuffers;

extern DWORD dwMajorVersion;
extern DWORD dwMinorVersion;

extern DWORD dwUniquePrinterSessionID;

extern DWORD PortToPrinterStatusMappings[];

extern WCHAR *szSpooler;
extern LPCTSTR pszLocalOnlyToken;
extern LPCTSTR pszLocalsplOnlyToken;

typedef DWORD NOTIFYVECTOR[NOTIFY_TYPE_MAX];
typedef NOTIFYVECTOR *PNOTIFYVECTOR;

#define ZERONV(dest) \
    dest[0] = dest[1] = 0

#define COPYNV(dest, src) \
    {   dest[0] = src[0]; dest[1] = src[1]; }

#define ADDNV(dest, src) \
    {   dest[0] |= src[0]; dest[1] |= src[1]; }

#define SIZE_OF_MAP(count)  ( (count) / 8 + 1)
#define SETBIT(map, pos) ((map)[(pos) / 8] |= (1 << ((pos) & 7) ))
#define RESETBIT(map, pos) ((map)[(pos) / 8] &= ~(1 << ((pos) & 7) ))
#define GETBIT(map, id) ((map)[id / 8] & ( 1 << ((id) & 7) ) )

extern NOTIFYVECTOR NVPrinterStatus;
extern NOTIFYVECTOR NVPrinterSD;
extern NOTIFYVECTOR NVJobStatus;
extern NOTIFYVECTOR NVJobStatusString;
extern NOTIFYVECTOR NVJobStatusAndString;
extern NOTIFYVECTOR NVPurge;
extern NOTIFYVECTOR NVDeletedJob;
extern NOTIFYVECTOR NVAddJob;
extern NOTIFYVECTOR NVSpoolJob;
extern NOTIFYVECTOR NVWriteJob;
extern NOTIFYVECTOR NVPrinterAll;
extern NOTIFYVECTOR NVJobPrinted;
extern BOOL         (*pfnPrinterEvent)();

extern BOOL    fW3SvcInstalled;   // Says if IIS or "Peer web Server" is installed on the local machine.
extern PWCHAR  szW3Root;          // The WWWRoot dir, e.g. c:\inetpub\wwwroot

extern  OSVERSIONINFO     OsVersionInfo;
extern  OSVERSIONINFOEX   OsVersionInfoEx;

extern WCHAR *gszNT4EMF;
extern WCHAR *gszNT5EMF;

extern WCHAR *ipszRegistryClusRepository;
extern WCHAR *szDriversDirectory;
extern WCHAR *szDriversKey;
extern WCHAR *szWin95Environment;

typedef struct _JOBDATA {
    struct _JOBDATA   *pNext;
    PINIJOB            pIniJob;
    SIZE_T             MemoryUse;
    DWORD              dwWaitTime;
    DWORD              dwScheduleTime;
    DWORD              dwNumberOfTries;
} JOBDATA, *PJOBDATA;


typedef struct _Strings {
    DWORD   nElements;
    PWSTR   ppszString[1];
} STRINGS, *PSTRINGS;


typedef struct _INTERNAL_DRV_FILE {
    LPWSTR   pFileName;
    DWORD    dwVersion;
    HANDLE   hFileHandle;
    BOOL     bUpdated;
} INTERNAL_DRV_FILE, *PINTERNAL_DRV_FILE;

extern DWORD   dwNumberOfEMFJobsRendering;
extern BOOL    bUseEMFScheduling;
extern SIZE_T   TotalMemoryForRendering;
extern SIZE_T   AvailMemoryForRendering;
extern DWORD   dwLastScheduleTime;

extern PJOBDATA pWaitingList;
extern PJOBDATA pScheduleList;

#define JOB_SCHEDULE_LIST  0x00000001
#define JOB_WAITING_LIST   0x00000002

#define SPL_FIRST_JOB      0x00000001
#define SPL_USE_MEMORY     0x00000002

typedef BOOL (*PFNSPOOLER_MAP)( HANDLE h, PINISPOOLER pIniSpooler );
typedef BOOL (*PFNPRINTER_MAP)( HANDLE h, PINIPRINTER pIniPrinter );

#define DBG_CLUSTER 0x200

VOID
RunForEachSpooler(
    HANDLE h,
    PFNSPOOLER_MAP pfnMap
    );

VOID
RunForEachPrinter(
    PINISPOOLER pIniSpooler,
    HANDLE h,
    PFNPRINTER_MAP pfnMap
    );

BOOL
DsUpdateAllDriverKeys(
    HANDLE h,
    PINISPOOLER pIniSpooler
    );

VOID
InitializeLocalspl(
    VOID
);

VOID
EnterSplSem(
   VOID
);

VOID
LeaveSplSem(
   VOID
);

#if DBG

extern HANDLE ghbtClusterRef;
extern PDBG_POINTERS gpDbgPointers;

VOID
SplInSem(
   VOID
);

VOID
SplOutSem(
   VOID
);
#else
#define SplInSem()
#define SplOutSem()
#endif

PDEVMODE
AllocDevMode(
    PDEVMODE    pDevMode
);

BOOL
FreeDevMode(
    PDEVMODE    pDevMode
);

PINIENTRY
FindIniKey(
   PINIENTRY pIniEntry,
   LPWSTR lpName
);

VOID
RemoveFromJobList(
    PINIJOB    pIniJob,
    DWORD      dwJobList
);

BOOL
CheckSepFile(
   LPWSTR lpFileName
);

int
DoSeparator(
    PSPOOL
);

BOOL
DestroyDirectory(
   LPWSTR lpPrinterDir
);

DWORD
GetFullNameFromId(
    PINIPRINTER pIniPrinter,
    DWORD JobId,
    BOOL fJob,
    LPWSTR   pFileName,
    BOOL Remote
);

DWORD
GetPrinterDirectory(
   PINIPRINTER pIniPrinter,
   BOOL Remote,
   LPWSTR pFileName,
   DWORD MaxLength,
   PINISPOOLER pIniSpooler
);

BOOL
CreateSpoolDirectory(
    PINISPOOLER pIniSpooler
);


VOID
CreatePrintProcDirectory(
   LPWSTR lpEnvironment,
   PINISPOOLER pIniSpooler
);

VOID
ProcessShadowJobs(
    PINIPRINTER pIniPrinter,
    PINISPOOLER pIniSpooler
);

PINIJOB
ReadShadowJob(
   LPWSTR  szDir,
   PWIN32_FIND_DATA pFindFileData,
   PINISPOOLER pIniSpooler
);

BOOL
WriteShadowJob(
   IN   PINIJOB pIniJob,
   IN   BOOL    bLeaveCS
);

BOOL
BuildAllPrinters(
   VOID
);


BOOL
BuildEnvironmentInfo(
PINISPOOLER pIniSpooler
);

BOOL
BuildPrinterInfo(
PINISPOOLER pIniSpooler,
BOOL    UpdateChangeID
);

VOID
ReadJobInfo(
   PWIN32_FIND_DATA pFindFileData
);

BOOL
BuildAllPorts(
);

BOOL
BuildDriverInfo(
    HKEY            hEnvironmentKey,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
);

BOOL
BuildTrueDependentFileField(
    LPWSTR              pDriverPath,
    LPWSTR              pDataFile,
    LPWSTR              pConfigFile,
    LPWSTR              pHelpFile,
    LPWSTR              pInputDependentFiles,
    LPWSTR             *ppDependentFiles
    );

DWORD
GetDriverVersionDirectory(
    LPWSTR pDir,
    DWORD  MaxLength,
    PINISPOOLER pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER pIniDriver,
    LPWSTR lpRemote
    );

PINIVERSION
FindVersionForDriver(
    PINIENVIRONMENT pIniEnvironment,
    PINIDRIVER pIniDriver
    );

BOOL
BuildPrintProcInfo(
    HKEY            hEnvironmentKey,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
);

BOOL MoveNewDriverRelatedFiles(
    LPWSTR              pNewDir,
    LPWSTR              pCurrDir,
    LPWSTR              pOldDir,
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount,
    LPBOOL              pbDriverFileMoved,
    LPBOOL              pbConfigFileMoved
    );

typedef BOOL (*PFNREBUILD)(LPWSTR, PWIN32_FIND_DATA);

BOOL
Rebuild(
   LPWSTR lpDirectory,
   PFNREBUILD pfn
);

BOOL
RemoveFromList(
   PINIENTRY   *ppIniHead,
   PINIENTRY   pIniEntry
);

PINIDRIVER
GetDriver(
    HKEY hVersionKey,
    LPWSTR DriverName,
    PINISPOOLER pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion
    );

DWORD
GetDriverDirectory(
   LPWSTR lpDir,
   DWORD   MaxLength,
   PINIENVIRONMENT lpEnvironment,
   LPWSTR  lpRemotePath,
   PINISPOOLER pIniSpooler
);

DWORD
GetProcessorDirectory(
   LPWSTR *lpDir,
   LPWSTR lpEnvironment,
   PINISPOOLER pIniSpooler
);

LPWSTR
GetFileName(
   LPWSTR pPathName
);

BOOL
CopyDriverFile(
   LPWSTR lpEnvironment,
   LPWSTR lpFileName
);

BOOL
CreateCompleteDirectory(
   LPWSTR lpDir
);

BOOL
OpenMonitorPort(
    PINIPORT        pIniPort,
    PINIMONITOR     *ppIniLangMonitor,
    LPWSTR          pszPrinterName,
    BOOL            bWaitForEvent
    );

BOOL
CloseMonitorPort(
    PINIPORT    pIniPort,
    BOOL        bWaitForEvent
);

VOID
ShutdownPorts(
    PINISPOOLER pIniSpooler
);

BOOL
CreatePortThread(
   PINIPORT pIniPort
);

#define WAIT   TRUE
#define NOWAIT FALSE

BOOL
DestroyPortThread(
    PINIPORT    pIniPort,
    BOOL        bShutdown
);

DWORD
PortThread(
   PINIPORT  pIniPort
);

BOOL
DeleteJob(
   PINIJOB  pIniJob,
   BOOL     bBroadcast
);

VOID
DeleteJobCheck(
    PINIJOB pIniJob
);

BOOL
UpdateWinIni(
    PINIPRINTER pIniPrinter
);

PKEYDATA
CreateTokenList(
    LPWSTR   pKeyData
);

PINIPORT
CreatePortEntry(
    LPWSTR      pPortName,
    PINIMONITOR pIniMonitor,
    PINISPOOLER pIniSpooler
);

VOID
GetPrinterPorts(
    PINIPRINTER pIniPrinter,
    LPWSTR      pszPorts,
    DWORD       *pcbNeeded
);

DWORD
SchedulerThread(
    PINISPOOLER pIniSpooler
);

BOOL
UpdatePrinterIni(
   PINIPRINTER pIniPrinter,
   DWORD    dwChangeID
);

BOOL
UpdatePrinterNetworkName(
   PINIPRINTER pIniPrinter,
   LPWSTR pszPorts
);

BOOL
NoConfigCahngeUpdatePrinterIni(
   PINIPRINTER pIniPrinter
);

BOOL
SetLocalPrinter(
    PINIPRINTER pIniPrinter,
    DWORD   Level,
    PBYTE   pPrinterInfo,
    PDWORD pdwPrinterVector,
    DWORD SecurityInformation
);

BOOL
CopyPrinterDevModeToIniPrinter(
    IN OUT PINIPRINTER      pIniPrinter,
    IN     LPDEVMODE        pDevMode
    );

VOID
MonitorThread(
    PINIPORT  pIniMonitor
);

BOOL
InitializeForms(
    PINISPOOLER pIniSpooler
);

BOOL
InitializeNet(
    VOID
);

BOOL
ShareThisPrinter(
    PINIPRINTER pIniPrinter,
    LPWSTR   pShareName,
    BOOL    Share
);


DWORD
AddPrintShare(
    PINISPOOLER pIniSpooler
    );

PINIJOB
FindJob(
   PINIPRINTER pIniPrinter,
   DWORD JobId,
   PDWORD pPosition
);

PINIJOB
FindServerJob(
    PINISPOOLER pIniSpooler,
    DWORD JobId,
    PDWORD pPosition,
    PINIPRINTER* ppIniPrinter
    );

PINIJOB
FindIniJob (
    PSPOOL pSpool,
    DWORD  JobId
    );

DWORD
GetJobSessionId (
    PSPOOL pSpool,
    DWORD  JobId
    );

BOOL
MyName(
    LPWSTR   pName,
    PINISPOOLER pIniSpooler
);

BOOL
IsValidPrinterName(
    IN LPCWSTR pszPrinter,
    IN DWORD   cchMax
    );

BOOL
RefreshMachineNamesCache(
);

BOOL
CheckMyName(
    LPWSTR   pName,
    PINISPOOLER pIniSpooler
);


PINISPOOLER
FindSpoolerByNameIncRef(
    LPTSTR pszName,
    LPCTSTR *ppszLocalName OPTIONAL
    );

VOID
FindSpoolerByNameDecRef(
    PINISPOOLER pIniSpooler
    );

PINISPOOLER
FindSpoolerByName(
    LPTSTR pszName,
    LPCTSTR *ppszLocalName OPTIONAL
    );


HANDLE
AddNetPrinter(
    LPBYTE  pPrinterInfo,
    PINISPOOLER pIniSpooler
);

BOOL
CreateServerThread(
    VOID
);

BOOL
GetSid(
    PHANDLE hToken
);

BOOL
SetCurrentSid(
    HANDLE  phToken
);

BOOL
LocalEnumPrinters(
    DWORD   Flags,
    LPWSTR  Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

DWORD
LocalOpenPrinter(
   LPWSTR   pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTS pDefault
);

DWORD
LocalOpenPrinterEx(
   LPWSTR               pPrinterName,
   LPHANDLE             phPrinter,
   LPPRINTER_DEFAULTS   pDefault,
   LPBYTE               pSplClientInfo,
   DWORD                dwLevel
);

BOOL
LocalSetJob(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
);

BOOL
LocalGetJob(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
);

BOOL
LocalEnumJobs(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

HANDLE
LocalAddPrinter(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPrinter
);

HANDLE
LocalAddPrinterEx(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPrinter,
    LPBYTE  pSplClientInfo,
    DWORD   dwClientInfoLevel
);

BOOL
DeletePrinterForReal(
    PINIPRINTER pIniPrinter,
    BOOL        bIsInitTime
);

BOOL
LocalDeletePrinter(
   HANDLE   hPrinter
);

BOOL
LocalAddPrinterConnection(
    LPWSTR   pName
);

BOOL
LocalDeletePrinterConnection(
    LPWSTR  pName
);

BOOL
LocalAddPrinterDriver(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo
);

BOOL
LocalAddPrinterDriverEx(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   dwFileCopyFlags
);

LocalAddDriverCatalog(
    IN     HANDLE      hPrinter,
    IN     DWORD       dwLevel,
    IN     VOID        *pvDriverInfCatInfo,
    IN     DWORD       dwCatalogCopyFlags
    );

BOOL
LocalEnumPrinterDrivers(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
LocalGetPrinterDriverDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
LocalDeletePrinterDriver(
   LPWSTR   pName,
   LPWSTR   pEnvironment,
   LPWSTR   pDriverName
);

BOOL
LocalDeletePrinterDriverEx(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pDriverName,
    DWORD   dwDeleteFlag,
    DWORD   dwVersionNum
);

BOOL
LocalAddPerMachineConnection(
   LPCWSTR  pServer,
   LPCWSTR  pPrinterName,
   LPCWSTR  pPrintServer,
   LPCWSTR  pProvider
);

BOOL
LocalDeletePerMachineConnection(
   LPCWSTR  pServer,
   LPCWSTR  pPrinterName
);

BOOL
LocalEnumPerMachineConnections(
   LPCWSTR  pServer,
   LPBYTE   pPrinterEnum,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded,
   LPDWORD  pcReturned
);

BOOL
LocalAddPrintProcessor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPathName,
    LPWSTR  pPrintProcessorName
);

BOOL
LocalEnumPrintProcessors(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
LocalGetPrintProcessorDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
LocalDeletePrintProcessor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPrintProcessorName
);

BOOL
LocalEnumPrintProcessorDatatypes(
    LPWSTR  pName,
    LPWSTR  pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

DWORD
LocalStartDocPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
);

BOOL
LocalStartPagePrinter(
    HANDLE  hPrinter
);

BOOL
LocalGetSpoolFileHandle(
    HANDLE    hPrinter,
    LPWSTR    *pSpoolDir,
    LPHANDLE  phFile,
    HANDLE    hSpoolerProcess,
    HANDLE    hAppProcess
);

BOOL
LocalCommitSpoolData(
    HANDLE  hPrinter,
    DWORD   cbCommit
);

BOOL
LocalCloseSpoolFileHandle(
    HANDLE  hPrinter
);

BOOL
LocalFlushPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten,
    DWORD   cSleep
);

DWORD
LocalSendRecvBidiData(
    HANDLE                    hPrinter,
    LPCTSTR                   pAction,
    PBIDI_REQUEST_CONTAINER   pReqData,
    PBIDI_RESPONSE_CONTAINER* ppResData
);

BOOL
LocalWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
);

BOOL
LocalSeekPrinter(
    HANDLE hPrinter,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER pliNewPointer,
    DWORD dwMoveMethod,
    BOOL bWritePrinter
);

BOOL
LocalEndPagePrinter(
   HANDLE   hPrinter
);

BOOL
LocalAbortPrinter(
   HANDLE   hPrinter
);

BOOL
LocalReadPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pNoBytesRead
);

BOOL
SplReadPrinter(
    HANDLE  hPrinter,
    LPBYTE  *pBuf,
    DWORD   cbBuf
);

BOOL
LocalEndDocPrinter(
   HANDLE   hPrinter
);

BOOL
LocalAddJob(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
LocalScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId
);

DWORD
LocalWaitForPrinterChange(
    HANDLE  hPrinter,
    DWORD   Flags
);

BOOL
SetSpoolClosingChange(
    PSPOOL pSpool
);

BOOL
SetPrinterChange(
    PINIPRINTER pIniPrinter,
    PINIJOB     pIniJob,
    PDWORD      pdwNotifyVectors,
    DWORD       Flags,
    PINISPOOLER pIniSpooler
);

BOOL
LocalEnumMonitors(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
LocalEnumPorts(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
LocalAddPort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName
);

BOOL
LocalConfigurePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
);

BOOL
LocalDeletePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
);


BOOL
LocalXcvData(
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PDWORD  pdwStatus
);

DWORD
XcvOpen(
    PCWSTR              pszServer,
    PCWSTR              pszObject,
    DWORD               dwType,
    PPRINTER_DEFAULTS   pDefault,
    PHANDLE             phXcv,
    PINISPOOLER         pIniSpooler
);

BOOL
XcvClose(
    PINIXCV pIniXcv
);

BOOL
XcvDeletePort(
    PINIXCV     pIniXcv,
    PCWSTR      pszDataName,
    PBYTE       pInputData,
    DWORD       cbInputData,
    PBYTE       pOutputData,
    DWORD       cbOutputData,
    PDWORD      pcbOutputNeeded,
    PDWORD      pdwStatus,
    PINISPOOLER pIniSpooler
);

BOOL
XcvAddPort(
    PINIXCV     pIniXcv,
    PCWSTR      pszDataName,
    PBYTE       pInputData,
    DWORD       cbInputData,
    PBYTE       pOutputData,
    DWORD       cbOutputData,
    PDWORD      pcbOutputNeeded,
    PDWORD      pdwStatus,
    PINISPOOLER pIniSpooler
);


BOOL
AddPortToSpooler(
    PCWSTR      pName,
    PINIMONITOR pIniMonitor,
    PINISPOOLER pIniSpooler
);

BOOL
DeletePortFromSpoolerStart(
    PINIPORT    pIniPort
);


BOOL
DeletePortFromSpoolerEnd(
    PINIPORT    pIniPort,
    PINISPOOLER pIniSpooler,
    BOOL        bSuccess
);



HANDLE
LocalCreatePrinterIC(
    HANDLE  hPrinter,
    LPDEVMODE   pDevMode
);

BOOL
LocalPlayGdiScriptOnPrinterIC(
    HANDLE  hPrinterIC,
    LPBYTE  pIn,
    DWORD   cIn,
    LPBYTE  pOut,
    DWORD   cOut,
    DWORD   ul
);

BOOL
LocalDeletePrinterIC(
    HANDLE  hPrinterIC
);

DWORD
LocalPrinterMessageBox(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPWSTR  pText,
    LPWSTR  pCaption,
    DWORD   dwType
);

BOOL
LocalAddMonitor(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pMonitors
);

BOOL
LocalDeleteMonitor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pMonitorName
);

BOOL
LocalFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    HANDLE hNotify,
    PDWORD pfdwStatus,
    PVOID pvReserved0,
    PVOID pvReserved1
);


BOOL
LocalFindClosePrinterChangeNotification(
    HANDLE hPrinter
);


PINIPRINTPROC
FindDatatype(
    PINIPRINTPROC pDefaultPrintProc,
    LPWSTR  pDatatype
);

PINIPRINTPROC
InitializePrintProcessor(
    HINSTANCE       hLibrary,
    PINIENVIRONMENT pIniEnvironment,
    LPWSTR          pPrintProcessorName,
    LPWSTR          pDLLName
);

HRESULT
InitializeLocalPrintProcessor(
    IN      PINIENVIRONMENT     pIniEnvironment
    );

BOOL
BuildOtherNamesFromMachineName(
    LPWSTR **ppszOtherNames,
    DWORD   *cOtherNames
);

VOID
FreeOtherNames(
    PWSTR **ppszMyOtherNames,
    DWORD *cOtherNames
);

PINIPRINTPROC
LoadPrintProcessor(
    PINIENVIRONMENT pIniEnvironment,
    LPWSTR          pPrintProcessorName,
    LPWSTR          pPathName,
    PINISPOOLER     pIniSpooler
);

PINIMONITOR
CreateMonitorEntry(
    LPWSTR   pMonitorDll,
    LPWSTR   pMonitorName,
    PINISPOOLER pIniSpooler
);

PINIPORT
FindIniPortFromIniPrinter(
    PINIPRINTER pIniPrinter
);


BOOL
GetPrintDriverVersion(
    IN  LPCWSTR pszFileName,
    OUT LPDWORD pdwFileMajorVersion,
    OUT LPDWORD pdwFileMinorVersion
);

BOOL
GetBinaryVersion(
    IN  PCWSTR pszFileName,
    OUT PDWORD pdwFileMajorVersion,
    OUT PDWORD pdwFileMinorVersion
    );

BOOL
IsSpecialDriver(
    IN PINIDRIVER    pIniDriver,
    IN PINIPRINTPROC pIniProc,
    IN PINISPOOLER   pIniSpooler
    );

BOOL
IsLocalFile (
    IN  LPCWSTR     pszFileName,
    IN  PINISPOOLER pIniSpooler
);

BOOL
IsEXEFile(
    IN  LPCWSTR     pszFileName
);

LPBYTE
PackStringToEOB(
    IN  LPWSTR pszSource,
    IN  LPBYTE pEnd
);

LPVOID
MakePTR (
    IN  LPVOID pBuf,
    IN  DWORD  Quantity
);

DWORD
MakeOffset (
    IN  LPVOID pFirst,
    IN  LPVOID pSecond
);

BOOL
ConvertDriverInfoToBLOB (
    IN  LPBYTE  pDriverInfo,
    IN  DWORD   Level
);

BOOL
ConvertBLOBToDriverInfo (
    IN  LPBYTE  pDriverInfo,
    IN  DWORD   Level
)
;

LPWSTR
GetErrorString(
    DWORD   Error
);

DWORD
KMPrintersAreBlocked(
);


#define NULL_TERMINATED 0
INT
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
);

int
Message(
    HWND hwnd,
    DWORD Type,
    int CaptionID,
    int TextID,
    ...
);

DWORD
PromptWriteError(
    PSPOOL pSpool,
    PHANDLE  phThread,
    PDWORD   pdwThreadId
);

DWORD
InitializeEventLogging(
    PINISPOOLER pIniSpooler
);

VOID
SplLogEventWorker(
    IN      PINISPOOLER pIniSpooler,
    IN      WORD        EventType,
    IN      NTSTATUS    EventID,
    IN      BOOL        bInSplSem,
    IN      LPWSTR      pFirstString,
    IN      va_list     vargs
);

VOID
SplLogEvent(
    PINISPOOLER pIniSpooler,
    WORD        EventType,
    NTSTATUS    EventID,
    BOOL        bInSplSem,
    LPWSTR      pFirstString,
    ...
);

VOID
SplLogEventExternal(
    IN      WORD        EventType,
    IN      DWORD       EventID,
    IN      LPWSTR      pFirstString,
    ...
);

#define IDS_LOCALSPOOLER            100
#define IDS_ERROR_WRITING_TO_PORT   101
#define IDS_ERROR_WRITING_TO_DISK   102

#define IDS_PRINTER_DRIVERS         104
#define IDS_UNNAMED                 105
#define IDS_ERROR_WRITING_GENERAL   106
#define IDS_REMOTE_DOC              107
#define IDS_LOCAL_DOC               108
#define IDS_FASTPRINT_TIMEOUT       109
#define IDS_DRIVER_CHECKPOINT       110

// Maximum length of a builtin form
//

#define FORM_NAME_LEN                31
#define CUSTOM_NAME_LEN              31
#define FORM_DATA_LEN                32

// String table Ids for builtin form names
//
#define IDS_FORM_LETTER             200
#define IDS_FORM_LETTER_SMALL       201
#define IDS_FORM_TABLOID            202
#define IDS_FORM_LEDGER             203
#define IDS_FORM_LEGAL              204
#define IDS_FORM_STATEMENT          205
#define IDS_FORM_EXECUTIVE          206
#define IDS_FORM_A3                 207
#define IDS_FORM_A4                 208
#define IDS_FORM_A4_SMALL           209
#define IDS_FORM_A5                 210
#define IDS_FORM_B4                 211
#define IDS_FORM_B5                 212
#define IDS_FORM_FOLIO              213
#define IDS_FORM_QUARTO             214
#define IDS_FORM_10X14              215
#define IDS_FORM_11X17              216
#define IDS_FORM_NOTE               217
#define IDS_FORM_ENVELOPE9          218
#define IDS_FORM_ENVELOPE10         219
#define IDS_FORM_ENVELOPE11         220
#define IDS_FORM_ENVELOPE12         221
#define IDS_FORM_ENVELOPE14         222
#define IDS_FORM_ENVELOPE_CSIZE_SHEET        223
#define IDS_FORM_ENVELOPE_DSIZE_SHEET        224
#define IDS_FORM_ENVELOPE_ESIZE_SHEET        225
#define IDS_FORM_ENVELOPE_DL        226
#define IDS_FORM_ENVELOPE_C5        227
#define IDS_FORM_ENVELOPE_C3        228
#define IDS_FORM_ENVELOPE_C4        229
#define IDS_FORM_ENVELOPE_C6        230
#define IDS_FORM_ENVELOPE_C65       231
#define IDS_FORM_ENVELOPE_B4        232
#define IDS_FORM_ENVELOPE_B5        233
#define IDS_FORM_ENVELOPE_B6        234
#define IDS_FORM_ENVELOPE           235
#define IDS_FORM_ENVELOPE_MONARCH   236
#define IDS_FORM_SIX34_ENVELOPE     237
#define IDS_FORM_US_STD_FANFOLD     238
#define IDS_FORM_GMAN_STD_FANFOLD   239
#define IDS_FORM_GMAN_LEGAL_FANFOLD 240

#if(WINVER >= 0x0400)
#define IDS_FORM_ISO_B4                           241
#define IDS_FORM_JAPANESE_POSTCARD                242
#define IDS_FORM_9X11                             243
#define IDS_FORM_10X11                            244
#define IDS_FORM_15X11                            245
#define IDS_FORM_ENV_INVITE                       246
#define IDS_FORM_LETTER_EXTRA                     247
#define IDS_FORM_LEGAL_EXTRA                      248
#define IDS_FORM_TABLOID_EXTRA                    249
#define IDS_FORM_A4_EXTRA                         250
#define IDS_FORM_LETTER_TRANSVERSE                251
#define IDS_FORM_A4_TRANSVERSE                    252
#define IDS_FORM_LETTER_EXTRA_TRANSVERSE          253
#define IDS_FORM_A_PLUS                           254
#define IDS_FORM_B_PLUS                           255
#define IDS_FORM_LETTER_PLUS                      256
#define IDS_FORM_A4_PLUS                          257
#define IDS_FORM_A5_TRANSVERSE                    258
#define IDS_FORM_B5_TRANSVERSE                    259
#define IDS_FORM_A3_EXTRA                         260
#define IDS_FORM_A5_EXTRA                         261
#define IDS_FORM_B5_EXTRA                         262
#define IDS_FORM_A2                               263
#define IDS_FORM_A3_TRANSVERSE                    264
#define IDS_FORM_A3_EXTRA_TRANSVERSE              265

#define IDS_FORM_DBL_JAPANESE_POSTCARD            266
#define IDS_FORM_A6                               267
#define IDS_FORM_JENV_KAKU2                       268
#define IDS_FORM_JENV_KAKU3                       269
#define IDS_FORM_JENV_CHOU3                       270
#define IDS_FORM_JENV_CHOU4                       271
#define IDS_FORM_LETTER_ROTATED                   272
#define IDS_FORM_A3_ROTATED                       273
#define IDS_FORM_A4_ROTATED                       274
#define IDS_FORM_A5_ROTATED                       275
#define IDS_FORM_B4_JIS_ROTATED                   276
#define IDS_FORM_B5_JIS_ROTATED                   277
#define IDS_FORM_JAPANESE_POSTCARD_ROTATED        278
#define IDS_FORM_DBL_JAPANESE_POSTCARD_ROTATED    279
#define IDS_FORM_A6_ROTATED                       280
#define IDS_FORM_JENV_KAKU2_ROTATED               281
#define IDS_FORM_JENV_KAKU3_ROTATED               282
#define IDS_FORM_JENV_CHOU3_ROTATED               283
#define IDS_FORM_JENV_CHOU4_ROTATED               284
#define IDS_FORM_B6_JIS                           285
#define IDS_FORM_B6_JIS_ROTATED                   286
#define IDS_FORM_12X11                            287
#define IDS_FORM_JENV_YOU4                        288
#define IDS_FORM_JENV_YOU4_ROTATED                289
#define IDS_FORM_P16K                             290
#define IDS_FORM_P32K                             291
#define IDS_FORM_P32KBIG                          292
#define IDS_FORM_PENV_1                           293
#define IDS_FORM_PENV_2                           294
#define IDS_FORM_PENV_3                           295
#define IDS_FORM_PENV_4                           296
#define IDS_FORM_PENV_5                           297
#define IDS_FORM_PENV_6                           298
#define IDS_FORM_PENV_7                           299
#define IDS_FORM_PENV_8                           300
#define IDS_FORM_PENV_9                           301
#define IDS_FORM_PENV_10                          302
#define IDS_FORM_P16K_ROTATED                     303
#define IDS_FORM_P32K_ROTATED                     304
#define IDS_FORM_P32KBIG_ROTATED                  305
#define IDS_FORM_PENV_1_ROTATED                   306
#define IDS_FORM_PENV_2_ROTATED                   307
#define IDS_FORM_PENV_3_ROTATED                   308
#define IDS_FORM_PENV_4_ROTATED                   309
#define IDS_FORM_PENV_5_ROTATED                   310
#define IDS_FORM_PENV_6_ROTATED                   311
#define IDS_FORM_PENV_7_ROTATED                   312
#define IDS_FORM_PENV_8_ROTATED                   313
#define IDS_FORM_PENV_9_ROTATED                   314
#define IDS_FORM_PENV_10_ROTATED                  315

#define IDS_FORM_RESERVED_48                      316
#define IDS_FORM_RESERVED_49                      317
#define IDS_FORM_CUSTOMPAD                        318

#endif /* WINVER >= 0x0400 */

VOID LogJobPrinted(
    PINIJOB pIniJob
);

#define MAP_READABLE 0
#define MAP_SETTABLE 1

DWORD
MapJobStatus(
    DWORD Type,
    DWORD Status
    );

DWORD
MapPrinterStatus(
    DWORD Type,
    DWORD Status
    );


BOOL
OpenPrinterPortW(
    LPWSTR  pPrinterName,
    HANDLE *pHandle,
    LPPRINTER_DEFAULTS pDefault
);

VOID
BroadcastChange(
    PINISPOOLER pIniSpooler,
    DWORD   Message,
    WPARAM  wParam,
    LPARAM  lParam
);

VOID
MyMessageBeep(
    DWORD   fuType,
    PINISPOOLER pIniSpooler
);


VOID
SendJobAlert(
    PINIJOB pIniJob
);

BOOL
CheckDataTypes(
    PINIPRINTPROC pIniPrintProc,
    LPWSTR  pDatatype
);

BOOL
ValidatePortTokenList(
    IN  OUT PKEYDATA        pKeyData,
    IN      PINISPOOLER     pIniSpooler,
    IN      BOOL            bInitialize,
        OUT BOOL            *pbNoPorts          OPTIONAL
);

VOID
FreePortTokenList(
    PKEYDATA    pKeyData
    );

DWORD
ValidatePrinterInfo(
    IN  PPRINTER_INFO_2 pPrinter,
    IN  PINISPOOLER pIniSpooler,
    IN  PINIPRINTER pIniPrinter OPTIONAL,
    OUT LPWSTR* ppszLocalName   OPTIONAL
    );


BOOL
DeletePortEntry(
    PINIPORT    pIniPort
);

BOOL
GetTokenHandle(
    PHANDLE pTokenHandle
);


VOID
LogJobInfo(
    PINISPOOLER pIniSpooler,
    NTSTATUS EventId,
    DWORD JobId,
    LPWSTR pDocumentName,
    LPWSTR pUser,
    LPWSTR pPrinterName,
    DWORD  curPos
    );

LONG
Myatol(
   LPWSTR nptr
   );

ULONG_PTR
atox(
   LPCWSTR psz
   );


DWORD
DeleteSubkeys(
    HKEY hKey,
    PINISPOOLER pIniSpooler
);

DWORD
RemoveRegKey(
    IN LPTSTR pszKey
    );

DWORD
CreateClusterSpoolerEnvironmentsStructure(
    IN PINISPOOLER pIniSpooler
    );

DWORD
CopyNewerOrOlderFiles(
    IN LPCWSTR     pszSourceDir,
    IN LPCWSTR     pszMasterDir,
    IN BOOL (WINAPI *pfn)(LPWSTR, LPWSTR)
    );

PINIENVIRONMENT
GetLocalArchEnv(
    IN PINISPOOLER pIniSpooler
    );

DWORD
ClusterFindLanguageMonitor(
    IN LPCWSTR     pszMonitor,
    IN LPCWSTR     pszEnvName,
    IN PINISPOOLER pIniSpooler
    );

DWORD
ReadTimeStamp(
    IN     HKEY        hkRoot,
    IN OUT SYSTEMTIME *pSysTime,
    IN     LPCWSTR     pszSubKey1,
    IN     LPCWSTR     pszSubKey2,
    IN     LPCWSTR     pszSubKey3,
    IN     LPCWSTR     pszSubKey4,
    IN     LPCWSTR     pszSubKey5,
    IN     PINISPOOLER pIniSpooler
    );

DWORD
WriteTimeStamp(
    IN HKEY        hkRoot,
    IN SYSTEMTIME  SysTime,
    IN LPCWSTR     pszSubKey1,
    IN LPCWSTR     pszSubKey2,
    IN LPCWSTR     pszSubKey3,
    IN LPCWSTR     pszSubKey4,
    IN LPCWSTR     pszSubKey5,
    IN PINISPOOLER pIniSpooler
    );

BOOL
ClusterCheckDriverChanged(
    IN HKEY        hClusterVersionKey,
    IN LPCWSTR     pszDriver,
    IN LPCWSTR     pszEnv,
    IN LPCWSTR     pszVer,
    IN PINISPOOLER pIniSpooler
    );

DWORD
RunProcess(
    IN  LPCWSTR pszExe,
    IN  LPCWSTR pszCommand,
    IN  DWORD   dwTimeOut,
    OUT LPDWORD pdwExitCode OPTIONAL
    );

DWORD
CopyICMFromLocalDiskToClusterDisk(
    IN PINISPOOLER pIniSpooler
    );

DWORD
CopyICMFromClusterDiskToLocalDisk(
    IN PINISPOOLER pIniSpooler
    );

DWORD
CreateProtectedDirectory(
    IN LPCWSTR pszDir
    );

DWORD
AddLocalDriverToClusterSpooler(
    IN LPCWSTR     pszDriver,
    IN PINISPOOLER pIniSpooler
    );

DWORD
StrCatPrefixMsz(
    IN     LPCWSTR  pszPerfix,
    IN     LPWSTR   pszzFiles,
    IN OUT LPWSTR  *ppszFullPathFiles
    );

DWORD
ClusterSplDeleteUpgradeKey(
    IN LPCWSTR pszResourceID
    );

DWORD
ClusterSplReadUpgradeKey(
    IN  LPCWSTR pszResourceID,
    OUT LPDWORD pdwValue
    );

DWORD
CopyFileToDirectory(
    IN LPCWSTR pszFullFileName,
    IN LPCWSTR pszDestDir,
    IN LPCWSTR pszDir1,
    IN LPCWSTR pszDir2,
    IN LPCWSTR pszDir3
    );

DWORD
InstallMonitorFromCluster(
    IN LPCWSTR     pszName,
    IN LPCWSTR     pszEnvName,
    IN LPCWSTR     pszEnvDir,
    IN PINISPOOLER pIniSpooler
    );

PINIDRIVER
FindLocalDriver(
    PINISPOOLER pIniSpooler,
    LPWSTR      pz
);

BOOL
FindLocalDriverAndVersion(
    PINISPOOLER pIniSpooler,
    LPWSTR      pz,
    PINIDRIVER  *ppIniDriver,
    PINIVERSION *ppIniVersion
);

BOOL
IsKMPD(
    LPWSTR  pDriverName
);

BOOL
IniDriverIsKMPD (
    PINISPOOLER     pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION     pIniVersion,
    PINIDRIVER      pIniDriver
    );

PINIDRIVER
FindCompatibleDriver(
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION * ppIniVersion,
    LPWSTR pDriverName,
    DWORD dwMajorVersion,
    int FindAnyDriver
    );

VOID
QueryUpgradeFlag(
    PINISPOOLER pIniSpooler
);


BOOL
LocalAddPortEx(
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   pBuffer,
    LPWSTR   pMonitorName
);


BOOL
ValidateSpoolHandle(
    PSPOOL pSpool,
    DWORD  dwDisallowMask
    );


PSECURITY_DESCRIPTOR
MapPrinterSDToShareSD(
    PSECURITY_DESCRIPTOR pPrinterSD
    );

BOOL
CallDevQueryPrint(
    LPWSTR    pPrinterName,
    LPDEVMODE pDevMode,
    LPWSTR    ErrorString,
    DWORD     dwErrorString,
    DWORD     dwPrinterFlags,
    DWORD     dwJobFlags
    );


BOOL
InitializeWinSpoolDrv(
    VOID
    );


VOID
FixDevModeDeviceName(
    LPWSTR pPrinterName,
    PDEVMODE pDevMode,
    DWORD cbDevMode
    );

VOID
RemoveOldNetPrinters(
    PPRINTER_INFO_1 pCurrentPrinterInfo1,
    PINISPOOLER pIniSpooler
    );

PINIJOB
AssignFreeJobToFreePort(
    PINIPORT pIniPort,
    DWORD   *pTimeToWait
);

BOOL
ValidRawDatatype(
    LPWSTR pszDataType);

BOOL
InternalAddPrinterDriverEx(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   dwFileCopyFlags,
    PINISPOOLER pIniSpooler,
    BOOL    bUseScratchDir,
    BOOL    bImpersonateOnCreate
);

VOID
CheckSizeDetectionThread(
    VOID
);

VOID
Upgrade31DriversRegistryForAllEnvironments(
    PINISPOOLER pIniSpooler
);

VOID
UpgradeForms(
    PINISPOOLER pIniSpooler
);

HANDLE
CreatePrinterHandle(
    LPWSTR      pPrinterName,
    LPWSTR      pFullMachineName,
    PINIPRINTER pIniPrinter,
    PINIPORT    pIniPort,
    PINIPORT    pIniNetPort,
    PINIJOB     pIniJob,
    DWORD       TypeofHandle,
    HANDLE      hPort,
    PPRINTER_DEFAULTS pDefaults,
    PINISPOOLER pIniSpooler,
    DWORD       AccessRequested,
    LPBYTE      pSplClientInfo,
    DWORD   dwLevel,
    HANDLE  hReadFile
);

DWORD
CreateServerHandle(
    LPWSTR   pPrinterName,
    LPHANDLE pPrinterHandle,
    LPPRINTER_DEFAULTS pDefaults,
    PINISPOOLER pIniSpooler,
    DWORD   dwTypeofHandle
);


PINIPRINTER
FindPrinterShare(
   LPCWSTR pShareName,
   PINISPOOLER pIniSpooler
);

BOOL
GetSpoolerPolicy(
    PWSTR   pszValue,
    PBYTE   pData,
    PDWORD  pcbData
);

DWORD
GetDwPolicy(
    PWSTR pszName,
    DWORD dwDefault
);

PINIJOB
CreateJobEntry(
    PSPOOL pSpool,
    DWORD  Level,
    LPBYTE pDocInfo,
    DWORD  JobId,
    BOOL  bRemote,
    DWORD  JobStatus,
    LPWSTR pMachineName
    );

BOOL
DeletePrinterCheck(
    PINIPRINTER pIniPrinter
    );

VOID
DeleteSpoolerCheck(
    PINISPOOLER pIniSpooler
    );


BOOL
DeletePrinterIni(
   PINIPRINTER pIniPrinter
   );

DWORD
SplDeleteThisKey(
    HKEY hParentKey,       // handle to parent of key to delete
    HKEY hThisKey,         // handle of key to delete
    LPWSTR pThisKeyName,   // name of this key
    BOOL bDeleteNullKey,   // if *pThisKeyName is NULL, delete it if TRUE
    PINISPOOLER pIniSpooler
    );

BOOL
CopyPrinterIni(
   PINIPRINTER pIniPrinter,
   LPWSTR pNewName
   );

BOOL
UpdateString(
    LPWSTR* ppszCur,
    LPWSTR pszNew);


BOOL
SetPrinterPorts(
    PSPOOL      pSpool,
    PINIPRINTER pIniPrinter,
    PKEYDATA    pKeyData
);

VOID
InternalDeletePrinter(
    PINIPRINTER pIniPrinter
);

BOOL
PurgePrinter(
    PINIPRINTER pIniPrinter
    );

BOOL
AddIniPrinterToIniPort(
    PINIPORT pIniPort,
    PINIPRINTER pIniPrinter
);

BOOL
AddIniPortToIniPrinter(
    PINIPRINTER pIniPrinter,
    PINIPORT pIniPort
);

LPCWSTR
FindFileName(
    LPCWSTR pPathName
    );

VOID
UpdateJobAttributes(
    PINIJOB  pIniJob
    );

BOOL
InternalCopyFile(
    HANDLE  hFile,
    PWIN32_FIND_DATA pSourceFileData,
    LPWSTR  pTagetFileName,
    BOOL    bOverWriteIfTargetExists
    );

BOOL
UpdateFile(
    PINIVERSION pIniVersion,
    HANDLE      hSourceFile,
    LPWSTR      pSourceFile,
    DWORD       dwVersion,
    LPWSTR      pDestDir,
    DWORD       dwFileCopyFlags,
    BOOL        bImpersonateOnCreate,
    LPBOOL      pbFileUpdated,
    LPBOOL      pbFileMoved,
    BOOL        bSameEnvironment,
    BOOL        bWin95Environment
    );

BOOL
PrinterCreateKey(
    HKEY    hKey,
    LPWSTR  pSubKey,
    PHKEY   phkResult,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    );

BOOL
RegSetString(
    HANDLE  hPrinterKey,
    LPWSTR  pValueName,
    LPWSTR  pStringValue,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    );

BOOL
RegSetDWord(
    HANDLE  hPrinterKey,
    LPWSTR  pValueName,
    DWORD   dwParam,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    );

VOID
CheckAndUpdatePrinterRegAll(
    PINISPOOLER pIniSpooler,
    LPWSTR pszPrinterName,
    LPWSTR pszPort,
    BOOL   bDelete
    );

BOOL
ForEachPrinterCallDriverDrvUpgrade(
    PINISPOOLER         pIniSpooler,
    PINIDRIVER          pIniDriver,
    LPCWSTR             pOldDriverDir,
    PINTERNAL_DRV_FILE  pInternalDriverFile,
    DWORD               dwFileCount,
    LPBYTE              pDriverInfo
);

BOOL
bBitIsSet(
    LPBYTE  pUpdateStatus,
    DWORD   dwPosition
);

VOID
SetBit(
    LPBYTE  pUpdateStatus,
    DWORD   dwPosition
);

BOOL
DeleteAllFilesInDirectory(
    LPWSTR pDirectory,
    BOOL   bWaitForReboot
);

BOOL
DeleteAllFilesAndDirectory(
    LPWSTR pDirectory,
    BOOL   bWaitForReboot
    );

VOID
DeleteDirectoryRecursively(
    LPCWSTR pDirectory,
    BOOL    bWaitForReboot
);

DWORD
CreateNumberedTempDirectory(
    LPCWSTR  pszDirectory,
    LPWSTR  *ppszTempDirectory
    );

VOID
Upgrade35Forms(
    HKEY hFormsKey,
    PINISPOOLER pIniSpooler
    );

BOOL
UpgradeDriverData(
    PINISPOOLER pIniSpooler
    );

BOOL
FileExists(
    LPWSTR pFileName
    );


BOOL
DirectoryExists(
    LPWSTR  pDirectoryName
    );

PINIVERSION
FindVersionEntry(
    PINIENVIRONMENT pIniEnvironment,
    DWORD dwVersion
    );


BOOL
CreateDirectoryWithoutImpersonatingUser(
    LPWSTR pDirectory
    );

VOID
InsertVersionList(
    PINIVERSION* pIniVersionHead,
    PINIVERSION pIniVersion
    );

BOOL
SameMultiSz(
    LPWSTR pszz1,
    LPWSTR pszz2
    );

int
wstrcmpEx(
    LPCWSTR s1,
    LPCWSTR s2,
    BOOL    bCaseSensitive
    );

BOOL
RegSetString(
    HANDLE  hKey,
    LPWSTR  pValueName,
    LPWSTR  pStringValue,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    );

BOOL
RegSetDWord(
    HANDLE  hKey,
    LPWSTR  pValueName,
    DWORD   dwParam,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    );

BOOL
RegSetBinaryData(
    HKEY    hKey,
    LPWSTR  pValueName,
    LPBYTE  pData,
    DWORD   cbData,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    );

BOOL
RegSetMultiString(
    HANDLE  hKey,
    LPWSTR  pValueName,
    LPWSTR  pStringValue,
    DWORD   cbString,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    );

BOOL
RegGetString(
    HANDLE  hKey,
    LPWSTR  pValueName,
    LPWSTR *ppValue,
    LPDWORD pcchCount,
    PDWORD  pdwLastError,
    BOOL    bFailIfNotFound,
    PINISPOOLER pIniSpooler
    );

BOOL
RegGetMultiSzString(
    HANDLE    hKey,
    LPWSTR    pValueName,
    LPWSTR   *ppValue,
    LPDWORD   pcchValue,
    PDWORD    pdwLastError,
    BOOL      bFailIfNotFound,
    PINISPOOLER pIniSpooler
    );

DWORD
ValidatePrinterName(
    LPWSTR          pszNewName,
    PINISPOOLER     pIniSpooler,
    PINIPRINTER     pIniPrinter,
    LPWSTR         *ppszLocalName
    );

DWORD
ValidatePrinterShareName(
    LPWSTR          pszNewShareName,
    PINISPOOLER     pIniSpooler,
    PINIPRINTER     pIniPrinter
    );

BOOL
AllocOrUpdateStringAndTestSame(
    IN      LPWSTR      *ppString,
    IN      LPCWSTR     pNewValue,
    IN      LPCWSTR     pOldValue,
    IN      BOOL        bCaseSensitive,
    IN  OUT BOOL        *pbFail,
    IN  OUT BOOL        *pbIdentical
    );

BOOL
AllocOrUpdateString(
    IN      LPWSTR      *ppString,
    IN      LPCWSTR     pNewValue,
    IN      LPCWSTR     pOldValue,
    IN      BOOL        bCaseSensitive,
    IN  OUT BOOL        *bFail
    );

VOID
FreeStructurePointers(
    LPBYTE  lpStruct,
    LPBYTE  lpStruct2,
    LPDWORD lpOffsets);

VOID
CopyNewOffsets(
    LPBYTE  pStruct,
    LPBYTE  pTempStruct,
    LPDWORD lpOffsets
    );

LPWSTR
GetConfigFilePath(
    IN PINIPRINTER  pIniPrinter
    );

PDEVMODE
ConvertDevModeToSpecifiedVersion(
    IN  PINIPRINTER pIniPrinter,
    IN  PDEVMODE    pDevMode,
    IN  LPWSTR      pszConfigFile,              OPTIONAL
    IN  LPWSTR      pszPrinterNameWithToken,    OPTIONAL
    IN  BOOL        bNt35xVersion
    );

BOOL
CreateRedirectionThread(
    PINIPORT pIniPort
    );

VOID
RemoveDeviceName(
    PINIPORT pIniPort
    );

BOOL
IsPortType(
    LPWSTR  pPort,
    LPWSTR  pPrefix
    );

BOOL
LocalSetPort(
    LPWSTR      pszName,
    LPWSTR      pszPortName,
    DWORD       dwLevel,
    LPBYTE      pPortInfo
    );

DWORD
SetPrinterDataServer(
    PINISPOOLER    pIniSpooler,
    LPWSTR      pValueName,
    DWORD       Type,
    LPBYTE      pData,
    DWORD       cbData
    );

BOOL
BuildPrintObjectProtection(
    IN PUCHAR AceType,
    IN DWORD AceCount,
    IN PSID *AceSid,
    IN ACCESS_MASK *AceMask,
    IN BYTE *InheritFlags,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PGENERIC_MAPPING GenericMap,
    OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor
    );

INT
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR  pAnsi,
    DWORD  StringLength
    );

LPWSTR
AnsiToUnicodeStringWithAlloc(
    LPSTR   pAnsi
    );

VOID
FreeIniSpoolerOtherNames(
    PINISPOOLER pIniSpooler
    );

VOID
FreeIniMonitor(
    PINIMONITOR pIniMonitor
    );

DWORD
RestartJob(
    PINIJOB pIniJob
    );

BOOL
IsCallViaRPC(
    IN VOID
    );

VOID
UpdateReferencesToChainedJobs(
    PINISPOOLER pIniSpooler
    );

BOOL
PrinterDriverEvent(
    PINIPRINTER pIniPrinter,
    INT         PrinterEvent,
    LPARAM      lParam
);

BOOL
SetPrinterShareInfo(
    PINIPRINTER     pIniPrinter
    );

VOID
LinkPortToSpooler(
    PINIPORT pIniPort,
    PINISPOOLER pIniSpooler
    );

VOID
DelinkPortFromSpooler(
    PINIPORT pIniPort,
    PINISPOOLER pIniSpooler
    );


DWORD
FinalInitAfterRouterInitComplete(
    DWORD dwUpgrade,
    PINISPOOLER pIniSpooler
    );

VOID
InstallWebPrnSvc(
    PINISPOOLER pIniSpooler
);

void
WebShare(
    LPWSTR pShareName
);

void
WebUnShare(
    LPWSTR pShareName
);

DWORD
OpenPrinterKey(
    PINIPRINTER pIniPrinter,
    REGSAM      samDesired,
    HANDLE      *phKey,
    LPCWSTR     pKeyName,
    BOOL        bOpen
);

DWORD
GetIniDriverAndDirForThisMachine(
    IN  PINIPRINTER     pIniPrinter,
    OUT LPWSTR          pszDriverDir,
    OUT PINIDRIVER     *ppIniDriver
    );

BOOL
CopyAllFilesAndDeleteOldOnes(
    PINIVERSION         pIniVersion,
    PINTERNAL_DRV_FILE  pInternalDriverFile,
    DWORD               dwFileCount,
    LPWSTR              pDestDir,
    DWORD               dwFileCopyFlags,
    BOOL                bImpersonateOnCreate,
    LPBOOL              pbFileMoved,
    BOOL                bSameEnvironment,
    BOOL                bWin95Environment
    );

BOOL LocalDriverUnloadComplete(
    LPWSTR   pDriverFile);


VOID PendingDriverUpgrades(
    LPWSTR   pDriverFile);

BOOL
GenerateDirectoryNamesForCopyFilesKey(
    PSPOOL      pSpool,
    HKEY        hKey,
    LPWSTR     *ppszSourceDir,
    LPWSTR     *ppszTargetDir,
    DWORD       cbMax
    );

LPWSTR
BuildFilesCopiedAsAString(
    PINTERNAL_DRV_FILE  pInternalDriverFile,
    DWORD               dwCount
    );

VOID
SeekPrinterSetEvent(
    PINIJOB  pIniJob,
    HANDLE   hFile,
    BOOL     bEndDoc
    );

VOID
SetPortErrorEvent(
    PINIPORT pIniPort
    );

BOOL
DeleteIniPrinterDevNode(
    PINIPRINTER     pIniPrinter
    );

VOID
SplConfigChange(
    );

BOOL
DeletePrinterInAllConfigs(
    PINIPRINTER     pIniPrinter
    );

BOOL
WritePrinterOnlineStatusInCurrentConfig(
    PINIPRINTER     pIniPrinter
    );

BOOL
IsDsPresent(
    VOID
    );

PWSTR
FixDelim(
    PCWSTR  pszInBuffer,
    WCHAR   wcDelim
);

PWSTR
Array2DelimString(
    PSTRINGS    pStringArray,
    WCHAR       wcDelim
);

PSTRINGS
ShortNameArray2LongNameArray(
    PSTRINGS pShortNames
);

PSTRINGS
DelimString2Array(
    PCWSTR  pszDelimString,
    WCHAR   wcDelim
);

BOOL
ValidateXcvHandle(
    PINIXCV pIniXcv
);

VOID
FreeStringArray(
    PSTRINGS pStrings
);

PSTRINGS
AllocStringArray(
    DWORD   nStrings
);


VOID
GetRegistryLocation(
    HANDLE hKey,
    LPCWSTR pszPath,
    PHANDLE phKeyOut,
    LPCWSTR *ppszPathOut
    );

PWSTR
GetPrinterUrl(
    PSPOOL pSpool
);

VOID
ClearJobError(
    PINIJOB pIniJob
    );

DWORD
DeletePrinterSubkey(
    PINIPRINTER pIniPrinter,
    PWSTR       pKeyName
);

BOOL
UpdateDriverFileRefCnt(
    PINIENVIRONMENT  pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER  pIniDriver,
    LPCWSTR pDirectory,
    DWORD   dwDeleteFlag,
    BOOL    bIncrementFlag
    );


BOOL
LocalRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD dwColor,
    PVOID pPrinterNotifyRefresh,
    LPVOID* ppPrinterNotifyInfo
    );

BOOL
CopyRegistryKeys(
    HKEY hSourceParentKey,
    LPWSTR szSourceKey,
    HKEY hDestParentKey,
    LPWSTR szDestKey,
    PINISPOOLER pIniSpooler
    );

BOOL
CopyPrinters(
    HKEY    hSourceParentKey,
    LPWSTR  szSourceKey,
    HKEY    hDestParentKey,
    LPWSTR  szDestKey,
    BOOL    bTruncated
    );

BOOL
SplDeleteFile(
    LPCTSTR lpFileName
    );

BOOL
SplMoveFileEx(
    LPCTSTR lpExistingFileName,
    LPCTSTR lpNewFileName,
    DWORD dwFlags
    );

BOOL
IsRunningNTServer (
    LPBOOL  pIsServer
    );

DWORD
GetDefaultForKMPrintersBlockedPolicy (
    );

ULONG_PTR
AlignToRegType(
    IN  ULONG_PTR   Data,
    IN  DWORD       RegType
    );

BOOL
InternalINFInstallDriver(
    LPDRIVER_INFO_7 pDriverInfo
);

DWORD
GetServerInstallTimeOut(
);

DWORD
ReadOverlapped( HANDLE  hFile,
                LPVOID  lpBuffer,
                DWORD   nNumberOfBytesToRead,
                LPDWORD lpNumberOfBytesRead );

BOOL
WriteOverlapped( HANDLE  hFile,
                 LPVOID  lpBuffer,
                 DWORD   nNumberOfBytesToRead,
                 LPDWORD lpNumberOfBytesRead );

#ifdef _HYDRA_
DWORD
GetClientSessionId(
    );

BOOL
ShowThisPrinter(
    PINIPRINTER pIniPrinter
    );

DWORD
DetermineJobSessionId(
    PSPOOL pSpool
    );

typedef BOOLEAN
(*PWINSTATION_SEND_MESSAGEW)(
    HANDLE hServer,
    ULONG LogonId,
    LPWSTR  pTitle,
    ULONG TitleLength,
    LPWSTR  pMessage,
    ULONG MessageLength,
    ULONG Style,
    ULONG Timeout,
    PULONG pResponse,
    BOOL  DoNotWait
    );

int
WinStationMessage(
    DWORD SessionId,
    HWND  hWnd,
    DWORD Type,
    int CaptionID,
    int TextID,
    ...
    );

int
WinStationMessageBox(
    DWORD SessionId,
    HWND  hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType
    );

BOOL
InitializeMessageBoxFunction(
);

VOID
LogFatalPortError(
    IN      PINISPOOLER         pIniSpooler,
    IN      PCWSTR              pszName
    );

VOID
FreeIniEnvironment(
    IN      PINIENVIRONMENT     pIniEnvironment
    );

VOID
DeleteIniVersion(
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion
    );

VOID
FreeIniDriver(
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      PINIDRIVER          pIniDriver
    );

VOID
FreeIniPrintProc(
    IN      PINIPRINTPROC       pIniPrintProc
    );

BOOL
MergeMultiSz(
    IN      PCWSTR              pszMultiSz1,
    IN      DWORD               cchMultiSz1,
    IN      PCWSTR              pszMultiSz2,
    IN      DWORD               cchMultiSz2,
        OUT PWSTR               *ppszMultiSzMerge,
        OUT DWORD               *pcchMultiSzMerge       OPTIONAL
    );

VOID
AddMultiSzNoDuplicates(
    IN      PCWSTR              pszMultiSzIn,
    IN  OUT PWSTR               pszNewMultiSz
    );

DWORD
GetMultiSZLen(
    IN      LPWSTR              pMultiSzSrc
    );

DWORD
CheckShareSame(
    IN      PINIPRINTER         pIniPrinter,
    IN      SHARE_INFO_502      *pShareInfo502,
        OUT BOOL                *pbSame
    );

#endif


BOOL
RetrieveMasqPrinterInfo(
    IN      PSPOOL              pSpool,
        OUT PRINTER_INFO_2      **ppPrinterInfo
    );

DWORD
GetPrinterInfoFromRouter(
    IN      HANDLE              hMasqPrinter,
        OUT PRINTER_INFO_2      **ppPrinterInfo
    );

DWORD
AsyncPopulateMasqPrinterCache(
    IN      VOID                *ThreadData
    );

//
// WMI macros to fill the WMI data struct.
//
#define SplWmiCopyEndJobData(WmiData, pIniJob, CreateInfo) \
{ \
    if ((pIniJob)->pDatatype && \
        (_wcsnicmp((pIniJob)->pDatatype, L"TEXT", 4) == 0)) \
        (WmiData)->uJobData.eDataType = eDataTypeTEXT; \
    else if ((pIniJob)->pDatatype && \
             (_wcsnicmp((pIniJob)->pDatatype, L"NT EMF", 6) == 0)) \
        (WmiData)->uJobData.eDataType = eDataTypeEMF; \
    else \
        (WmiData)->uJobData.eDataType = eDataTypeRAW; \
    (WmiData)->uJobData.ulSize = (pIniJob)->Size; \
    (WmiData)->uJobData.ulPages = (pIniJob)->cPagesPrinted; \
    (WmiData)->uJobData.ulPagesPerSide = (pIniJob)->dwJobNumberOfPagesPerSide; \
    (WmiData)->uJobData.sFilesOpened = 0; \
    (WmiData)->uJobData.sFilesOpened += \
        (((CreateInfo) & FP_SHD_CREATED) ? 1 : 0); \
    (WmiData)->uJobData.sFilesOpened += \
        (((CreateInfo) & FP_SPL_WRITER_CREATED) ? 1 : 0); \
    (WmiData)->uJobData.sFilesOpened += \
        (((CreateInfo) & FP_SPL_READER_CREATED) ? 1 : 0); \
}

#define SplWmiCopyRenderedData(WmiData, pDevmode) \
{ \
    DWORD dmFields = (pDevmode)->dmFields; \
    if (dmFields | DM_YRESOLUTION) { \
        (WmiData)->uEmfData.sXRes = (pDevmode)->dmPrintQuality; \
        (WmiData)->uEmfData.sYRes = (pDevmode)->dmYResolution; \
        (WmiData)->uEmfData.sQuality = 0; \
    } \
    else if (dmFields | DM_PRINTQUALITY) { \
        (WmiData)->uEmfData.sQuality = (pDevmode)->dmPrintQuality; \
        (WmiData)->uEmfData.sXRes = 0; \
        (WmiData)->uEmfData.sYRes = 0; \
    } \
    else { \
        (WmiData)->uEmfData.sQuality = 0; \
        (WmiData)->uEmfData.sXRes = 0; \
        (WmiData)->uEmfData.sYRes = 0; \
    } \
    (WmiData)->uEmfData.sColor = (dmFields | DM_COLOR \
                                  ? (pDevmode)->dmColor \
                                  : 0); \
    (WmiData)->uEmfData.sCopies = (dmFields | DM_COPIES \
                                   ? (pDevmode)->dmCopies \
                                   : 0); \
    (WmiData)->uEmfData.sTTOption = (dmFields | DM_TTOPTION \
                                     ? (pDevmode)->dmTTOption \
                                     : 0); \
    (WmiData)->uEmfData.ulICMMethod = (dmFields | DM_ICMMETHOD \
                                       ? (pDevmode)->dmICMMethod \
                                       : 0); \
    (WmiData)->uEmfData.ulSize = 0;\
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\msgbox.c ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation

Module Name:

    msgbox.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    management for the Local Print Providor

    LocalAddPrinterConnection
    LocalDeletePrinterConnection
    LocalPrinterMessageBox

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/
#define NOMINMAX

#include <precomp.h>

#pragma hdrstop
#include "winsta.h"
#define WINSTATION_PRINTER_MESSAGE_TIMEOUT  (5*60)


HANDLE WinStaDllHandle = NULL;
PWINSTATION_SEND_MESSAGEW pWinStationSendMessage = NULL;

PINIPRINTER
FindPrinterAnywhere(
    LPTSTR pName,
    DWORD SpoolerType
    )

/*++

Routine Description:

    Search for a printer name in all pIniSpoolers.

Arguments:

    pName - Name of printer to search for.

    SpoolerType - Type of spooler the printer should reside in.

Return Value:

    PINIPRINTER - Found pIniPrinter
    NULL - Not found.

--*/

{
    LPCTSTR pszLocalName;
    PINIPRINTER pIniPrinter;
    PINISPOOLER pIniSpooler = FindSpoolerByName( pName,
                                                 &pszLocalName );

    SplInSem();

    if( pIniSpooler &&
        (( pIniPrinter = FindPrinter( pszLocalName, pIniSpooler )) ||
         ( pIniPrinter = FindPrinterShare( pszLocalName, pIniSpooler )))){

        if( pIniPrinter->pIniSpooler->SpoolerFlags & SpoolerType ){
            return pIniPrinter;
        }
    }

    return NULL;
}

BOOL
LocalAddPrinterConnection(
    LPWSTR   pName
)
{
    //
    // Allow us to make clustered connections to local printers
    // (they appear to be remote).
    //
    BOOL bReturn = FALSE;

    EnterSplSem();

    if( FindPrinterAnywhere( pName, SPL_TYPE_CLUSTER )){
        bReturn = TRUE;
    }

    LeaveSplSem();

    SetLastError(ERROR_INVALID_NAME);
    return bReturn;
}

BOOL
LocalDeletePrinterConnection(
    LPWSTR  pName
)
{
    //
    // Allow us to remove clustered connections to local printers
    // (they appear to be remote).
    //
    BOOL bReturn = FALSE;

    EnterSplSem();

    if( FindPrinterAnywhere( pName, SPL_TYPE_CLUSTER )){
        bReturn = TRUE;
    }

    LeaveSplSem();

    SetLastError(ERROR_INVALID_NAME);
    return bReturn;
}



DWORD
LocalPrinterMessageBox(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPWSTR  pText,
    LPWSTR  pCaption,
    DWORD   dwType
)
{
    //
    // Always fail this call.  It's completely bogus and shouldn't be
    // supported.  The router always passes us a bad handle anyway, so
    // we will always return invalid handle.
    //
    SetLastError(ERROR_INVALID_HANDLE);
    return FALSE;
}

BOOL
UpdateJobStatus(
    PSPOOL pSpool,
    DWORD Error
    )

/*++

Routine Description:

    Update job status based on Error.

Arguments:

    pSpool - Handle of session.

    Error - Error returned from port monitor.

Return Value:

    TRUE - Job is still valid.
    FALSE - Job is pending deletion.

--*/

{
    DWORD   dwJobStatus;

    PINIJOB pIniJob = NULL;

    if (pSpool->pIniJob)
        pIniJob = pSpool->pIniJob;
    else if (pSpool->pIniPort)
        pIniJob = pSpool->pIniPort->pIniJob;

    if (pIniJob) {

        EnterSplSem();

        dwJobStatus = pIniJob->Status;

        switch  (Error) {

#ifdef _HYDRA_
        case ERROR_BAD_DEV_TYPE:
        case ERROR_INVALID_NAME:

            //
            // If we have a problem with the port name, we will not find
            // a WinStation to put the message on. So kill the job to
            // prevent the spooler from looping.
            //
            pSpool->Status |= SPOOL_STATUS_CANCELLED;
            pIniJob->Status |= JOB_PENDING_DELETION;
            // Release any thread waiting on LocalSetPort
            SetPortErrorEvent(pIniJob->pIniPort);

            // Release any thread waiting on SeekPrinter
            SeekPrinterSetEvent(pIniJob, NULL, TRUE);

            SetLastError(ERROR_PRINT_CANCELLED);
            LeaveSplSem();
            SplOutSem();
            return FALSE;
#endif

        case ERROR_OUT_OF_PAPER:

            if( !( pIniJob->Status & JOB_PAPEROUT )){

                pIniJob->Status |= JOB_PAPEROUT;
                pIniJob->pIniPrinter->cErrorOutOfPaper++;
            }
            break;

        case ERROR_NOT_READY:

            if( !( pIniJob->Status & JOB_OFFLINE )){

                pIniJob->Status |= JOB_OFFLINE;
                pIniJob->pIniPrinter->cErrorNotReady++;
            }
            break;

        default:

            if( !( pIniJob->Status & JOB_ERROR )){

                pIniJob->Status |= JOB_ERROR;
                pIniJob->pIniPrinter->cJobError++;
            }

            pIniJob->pIniPrinter->dwLastError = Error;

            // Release any thread waiting on SeekPrinter
            SeekPrinterSetEvent(pIniJob, NULL, TRUE);
            break;
        }

        if( dwJobStatus != pIniJob->Status ){

            SetPrinterChange(pIniJob->pIniPrinter,
                             pIniJob,
                             NVJobStatus,
                             PRINTER_CHANGE_SET_JOB,
                             pIniJob->pIniPrinter->pIniSpooler );
        }

        LeaveSplSem();

        if(( pIniJob->Status & JOB_REMOTE ) &&
             pIniJob->pIniPrinter->pIniSpooler->bEnableNetPopups) {

            if (!(pIniJob->Status & JOB_NOTIFICATION_SENT)) {
                SendJobAlert(pIniJob);
                pIniJob->Status |= JOB_NOTIFICATION_SENT;
            }
            MyMessageBeep( MB_ICONEXCLAMATION,
                           pIniJob->pIniPrinter->pIniSpooler );
        }
    }
    return TRUE;
}


DWORD
MyMessageBox(
    HWND    hWnd,
    PSPOOL  pSpool,
    DWORD   Error,
    LPWSTR  pText,
    LPWSTR  pCaption,
    DWORD   dwType
    )
{
    PINIJOB pIniJob = NULL;
    LPWSTR  pErrorString, pDocumentName;
    HANDLE  hToken;
    WCHAR   szUnnamed[80];
    DWORD   dwJobStatus;
#ifdef _HYDRA_
    DWORD SessionId = DetermineJobSessionId(pSpool);
#endif

    if (pSpool->pIniJob)
        pIniJob = pSpool->pIniJob;
    else if (pSpool->pIniPort)
        pIniJob = pSpool->pIniPort->pIniJob;

    if (pIniJob) {

        if (pText) {

#ifdef _HYDRA_
            Error = WinStationMessageBox(SessionId, hWnd, pText, pCaption, dwType);
#else
            Error = MessageBox(hWnd, pText, pCaption, dwType);
#endif

        } else {

            pErrorString = Error == ERROR_NOT_READY ||
                           Error == ERROR_OUT_OF_PAPER ||
                           Error == ERROR_DEVICE_REINITIALIZATION_NEEDED ||
                           Error == ERROR_DEVICE_REQUIRES_CLEANING ||
                           Error == ERROR_DEVICE_DOOR_OPEN ||
                           Error == ERROR_DEVICE_NOT_CONNECTED ? GetErrorString(Error) : NULL;


            hToken = RevertToPrinterSelf();

            pDocumentName = pIniJob->pDocument;

            if (!pDocumentName) {
                *szUnnamed = L'\0';
                LoadString( hInst, IDS_UNNAMED, szUnnamed,
                            sizeof szUnnamed / sizeof *szUnnamed );
                pDocumentName = szUnnamed;
            }

            if (pSpool->pIniPort) {

#ifdef _HYDRA_
                Error = WinStationMessage(SessionId,
                                NULL,
#else
                Error = Message(NULL,
#endif
                                MB_ICONSTOP | MB_RETRYCANCEL | MB_SETFOREGROUND,
                                IDS_LOCALSPOOLER,
                                IDS_ERROR_WRITING_TO_PORT,
                                pDocumentName,
                                pSpool->pIniPort->pName,
                                pErrorString ? pErrorString : szNull);
            } else {

#ifdef _HYDRA_
                Error = WinStationMessage(SessionId,
                                NULL,
#else
                Error = Message(NULL,
#endif
                                MB_ICONSTOP | MB_RETRYCANCEL | MB_SETFOREGROUND,
                                IDS_LOCALSPOOLER,
                                IDS_ERROR_WRITING_TO_DISK,
                                pDocumentName,
                                pErrorString ? pErrorString : szNull);
            }

            ImpersonatePrinterClient(hToken);
            FreeSplStr(pErrorString);
        }

    } else {

        PWCHAR pPrinterName = NULL;

        //
        // There is no pIniJob or pIniPort, so we can't be very informative:
        //
        pErrorString = Error == ERROR_NOT_READY ||
                       Error == ERROR_OUT_OF_PAPER ||
                       Error == ERROR_DEVICE_REINITIALIZATION_NEEDED ||
                       Error == ERROR_DEVICE_REQUIRES_CLEANING ||
                       Error == ERROR_DEVICE_DOOR_OPEN ||
                       Error == ERROR_DEVICE_NOT_CONNECTED ? GetErrorString(Error) : NULL;
                       
        if (pSpool->pIniPrinter)
            pPrinterName = pSpool->pIniPrinter->pName;

        if (!pPrinterName) {

            *szUnnamed = L'\0';
            LoadString( hInst, IDS_UNNAMED, szUnnamed,
                        COUNTOF( szUnnamed ));
            pPrinterName = szUnnamed;
        }

#ifdef _HYDRA_
        Error = WinStationMessage(SessionId,
                        NULL,
#else
        Error = Message(NULL,
#endif
                        MB_ICONSTOP | MB_RETRYCANCEL | MB_SETFOREGROUND,
                        IDS_LOCALSPOOLER,
                        IDS_ERROR_WRITING_GENERAL,
                        pSpool->pIniPrinter->pName,
                        pErrorString ? pErrorString : szNull);

        FreeSplStr(pErrorString);
    }

    if (Error == IDCANCEL) {
        EnterSplSem();
        pSpool->Status |= SPOOL_STATUS_CANCELLED;
        if (pIniJob) {
            pIniJob->Status |= JOB_PENDING_DELETION;
            // Release any thread waiting on LocalSetPort
            SetPortErrorEvent(pIniJob->pIniPort);
            pIniJob->dwAlert |= JOB_NO_ALERT;
            // Release any thread waiting on SeekPrinter
            SeekPrinterSetEvent(pIniJob, NULL, TRUE);
        }
        LeaveSplSem();
        SplOutSem();
        SetLastError(ERROR_PRINT_CANCELLED);

    }
    return Error;
}


// Exclusively for use of the following routines. This is done so we would not have
// to store LastError in PSPOOL.
typedef struct _AUTORETRYTHDINFO {
    PSPOOL       pSpool;
    DWORD        LastError;
} AUTORETRYTHDINFO;
typedef AUTORETRYTHDINFO *PAUTORETRYTHDINFO;


// ------------------------------------------------------------------------
// SpoolerBMThread
//
// Thread start up routine for the spooler error message box thread. Exit
// code is the return ID from MessageBox.
//
// ------------------------------------------------------------------------
DWORD
WINAPI
SpoolerMBThread(
    PAUTORETRYTHDINFO pThdInfo
)
{
    DWORD rc;

    rc = MyMessageBox( NULL, pThdInfo->pSpool, pThdInfo->LastError, NULL, NULL, 0 );

    FreeSplMem( pThdInfo );
    return rc;
}


#define _ONE_SECOND     1000                         // in milliseconds
#define SPOOL_WRITE_RETRY_INTERVAL_IN_SECOND   5     // seconds

// ------------------------------------------------------------------------
// PromptWriteError
//
// we'll start a seperate thread to bring up
// the message box while we'll (secretly) automatically retry on this
// current thread, until user has chosen to retry or cancel. Call the error UI
// on the main thread if printing direct.
//
// ------------------------------------------------------------------------
DWORD
PromptWriteError(
    PSPOOL   pSpool,
    PHANDLE  phThread,
    PDWORD   pdwThreadId
)
{
    DWORD Error = GetLastError();
    DWORD dwExitCode;
    DWORD dwWaitCount = 0;

    SplOutSem();

    if( !UpdateJobStatus( pSpool, Error )){
        return IDCANCEL;
    }

    //
    // If the spooler doesn't have popup retry messageboxes enabled, then
    // just sleep and return.
    //
    if( !pSpool->pIniSpooler->bEnableRetryPopups ){

        Sleep( SPOOL_WRITE_RETRY_INTERVAL_IN_SECOND * _ONE_SECOND );
        return IDRETRY;
    }

    // start a seperate thread to display the message box
    // so we can continue to retry here
    // or simply sleep for 5 seconds if we have already done so

    if( !*phThread ) {

        // start a thread to bring up the message box

        PAUTORETRYTHDINFO pThdInfo;

        pThdInfo = (PAUTORETRYTHDINFO)AllocSplMem( sizeof(AUTORETRYTHDINFO));

        if ( pThdInfo == NULL ) {
            DBGMSG( DBG_WARNING, ("PromptWriteError failed to allocate AUTORETRYTHDINFO %d\n", GetLastError() ));
            goto _DoItOnCurrentThread;
        }

        pThdInfo->pSpool    = pSpool;
        pThdInfo->LastError = Error;

        if (!(*phThread = CreateThread(NULL, 0,
            (LPTHREAD_START_ROUTINE)SpoolerMBThread,
            pThdInfo, 0, pdwThreadId))) {

            DBGMSG(DBG_WARNING, ("PromptWriteError: CreateThread Failed.\n"));
            FreeSplMem( pThdInfo );
            goto _DoItOnCurrentThread;
        }
    }

    while (1) {

        // we've already started a MB thread, check if user has terminated
        // the message box

        if (GetExitCodeThread( *phThread, &dwExitCode) && (dwExitCode != STILL_ACTIVE)) {

            // if the thread has been terminated, find out the exit code
            // which is the return ID from MessageBox, then close the
            // thread handle.

            CloseHandle( *phThread );
            *phThread = 0;
            return dwExitCode;
        }

        if (dwWaitCount++ >= SPOOL_WRITE_RETRY_INTERVAL_IN_SECOND)
            break;

        Sleep(_ONE_SECOND);
    }

    return IDRETRY;

_DoItOnCurrentThread:

    return MyMessageBox(NULL, pSpool, Error, NULL, NULL, 0 );
}

#ifdef _HYDRA_
DWORD
DetermineJobSessionId(
    PSPOOL pSpool
    )

/*++

Routine Description:

    Determine which session to notify for the current job.

Arguments:

    pSpool - Open spooler handle

Return Value:

    SessionId to send notification message to.

--*/

{
    PINIJOB pIniJob = NULL;

    if (pSpool->pIniJob)
        pIniJob = pSpool->pIniJob;
    else if (pSpool->pIniPort)
        pIniJob = pSpool->pIniPort->pIniJob;

    if( pIniJob ) return( pIniJob->SessionId );

    return( pSpool->SessionId );
}

int
WinStationMessageBox(
    DWORD   SessionId,
    HWND    hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT    uType
    )

/*++

Routine Description:

    Displays a message on the WinStation named by SessionId.

    If any problems in actually displaying the message, wait for the
    the message box timeout interval before returning. This prevents
    a spin in the spooler attempting to retry the print job without a
    message box to block the thread.

Arguments:

    SessionId - ID of session to display the message on.

Return Value:

    Result of MessageBox().

--*/

{
    UINT    uOldErrorMode;
    DWORD   MsgLength, CaptionLength, Response;
    BOOL    Result;
    va_list vargs;

    //
    // Standard NT is always SessionId == 0.
    // On Hydra, the system console is always SessionId == 0.
    //
    if( SessionId == 0 ) {
        return( MessageBox( hWnd, lpText, lpCaption, uType ) );
    }

    //
    // If its not SessionId == 0, then we must deliver
    // the message to a session connected on a Hydra
    // server. Non-Hydra will not ever allocate a
    // SessionId != 0.
    //
    // On failure, we send the message to the console.
    //

    if( pWinStationSendMessage == NULL ) {

        uOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
        WinStaDllHandle = LoadLibraryW(L"winsta.dll");
        SetErrorMode(uOldErrorMode);

        if( WinStaDllHandle == NULL ) {
            return( MessageBox( hWnd, lpText, lpCaption, uType ) );
        }

        pWinStationSendMessage = (PWINSTATION_SEND_MESSAGEW)GetProcAddress(
                                     WinStaDllHandle,
                                     "WinStationSendMessageW"
                                     );

        if( pWinStationSendMessage == NULL ) {
            return( MessageBox( hWnd, lpText, lpCaption, uType ) );
        }
    }

    CaptionLength = (wcslen( lpCaption ) + 1) * sizeof(WCHAR);
    MsgLength = (wcslen( lpText ) + 1) * sizeof(WCHAR);

    // Send the message to the WinStation and wait for a response
    Result = pWinStationSendMessage(
                 SERVERNAME_CURRENT,
                 SessionId,
                 (LPWSTR)lpCaption,
                 CaptionLength,
                 (LPWSTR)lpText,
                 MsgLength,
                 uType,
                 WINSTATION_PRINTER_MESSAGE_TIMEOUT,
                 &Response,
                 FALSE
                 );

    if( Result ) {
        // If not an expected response, wait to prevent spinning
        if( (Response != IDTIMEOUT) &&
            (Response != IDOK) &&
            (Response != IDCANCEL) &&
            (Response != IDRETRY) &&
            (Response != IDIGNORE) &&
            (Response != IDYES) &&
            (Response != IDNO) ) {
            // Sleep to prevent a spin
            Sleep( WINSTATION_PRINTER_MESSAGE_TIMEOUT*1000);
        }
        return( Response );
    }
    else {
        // Sleep to prevent a spin
        Sleep( WINSTATION_PRINTER_MESSAGE_TIMEOUT*1000);
        return( 0 );
    }
}

int
WinStationMessage(
    DWORD SessionId,
    HWND  hWnd,
    DWORD Type,
    int CaptionID,
    int TextID,
    ...
    )

/*++

Routine Description:

    Displays a message on the WinStation named by SessionId. This takes
    the message text and caption from the resource file.

    If any problems in actually display the message, wait for the
    the message box timeout interval before returning. This prevents
    a spin in the spooler attempting to retry the print job without a
    message box to block the thread.

Arguments:

    SessionId - ID of session to display the message on.

Return Value:

    Result of MessageBox().

--*/

{
    UINT    uOldErrorMode;
    WCHAR   MsgText[512];
    WCHAR   MsgFormat[256];
    WCHAR   MsgCaption[40];
    DWORD   MsgLength, CaptionLength, Response;
    BOOL    Result;
    va_list vargs;

    if( ( LoadString( hInst, TextID, MsgFormat,
                      sizeof MsgFormat / sizeof *MsgFormat ) > 0 )
     && ( LoadString( hInst, CaptionID, MsgCaption,
                      sizeof MsgCaption / sizeof *MsgCaption ) > 0 ) )
    {
        va_start( vargs, TextID );
        _vsntprintf( MsgText, COUNTOF(MsgText)-1, MsgFormat, vargs );
        MsgText[COUNTOF(MsgText)-1] = 0;
        va_end( vargs );

        if( SessionId == 0 ) {
            return( MessageBox( hWnd, MsgText, MsgCaption, Type ) );
        }

        if( pWinStationSendMessage == NULL ) {

            uOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
            WinStaDllHandle = LoadLibraryW(L"winsta.dll");
            SetErrorMode(uOldErrorMode);

            if( WinStaDllHandle == NULL ) {
                return( MessageBox( hWnd, MsgText, MsgCaption, Type ) );
            }

            pWinStationSendMessage = (PWINSTATION_SEND_MESSAGEW)GetProcAddress(
                                         WinStaDllHandle,
                                         "WinStationSendMessageW"
                                         );

            if( pWinStationSendMessage == NULL ) {
                return( MessageBox( hWnd, MsgText, MsgCaption, Type ) );
            }
        }

        CaptionLength = (wcslen( MsgCaption ) + 1) * sizeof(WCHAR);
        MsgLength = (wcslen( MsgText ) + 1) * sizeof(WCHAR);

        // Send the message to the WinStation and wait for a response
        Result = pWinStationSendMessage(
                     SERVERNAME_CURRENT,
                     SessionId,
                     MsgCaption,
                     CaptionLength,
                     MsgText,
                     MsgLength,
                     Type,     // Style
                     WINSTATION_PRINTER_MESSAGE_TIMEOUT,
                     &Response,
                     FALSE     // DoNotWait
                     );

        if( Result ) {
            // If not an expected response, wait to prevent spinning
            if( (Response != IDTIMEOUT) &&
                (Response != IDOK) &&
                (Response != IDCANCEL) &&
                (Response != IDRETRY) &&
                (Response != IDIGNORE) &&
                (Response != IDYES) &&
                (Response != IDNO) ) {
                // Sleep to prevent a spin
                Sleep( WINSTATION_PRINTER_MESSAGE_TIMEOUT*1000);
            }
            return( Response );
        }
        else {
            // Sleep to prevent a spin
            Sleep( WINSTATION_PRINTER_MESSAGE_TIMEOUT*1000);
            return( 0 );
        }
    }
    else {
        // Sleep to prevent a spin
        Sleep( WINSTATION_PRINTER_MESSAGE_TIMEOUT*1000);
        return 0;
    }
}
#endif

DWORD
LclIsSessionZero (
    IN  HANDLE  hPrinter,
    IN  DWORD   JobId,
    OUT BOOL    *pIsSessionZero
)
/*++

Routine Description:

    Determines if the Job was submitted in Session 0. 

Arguments:

    hPrinter  - printer handle
    JobId     - Job ID
    pResponse - TRUE if the Job was submitted in Session0

Return Value:

    Last Error

--*/
{
    DWORD   dwRetValue  = ERROR_SUCCESS;
    DWORD   SessionId   = -1;
    PSPOOL  pSpool      = (PSPOOL)hPrinter;
    

    if (pSpool && JobId && pIsSessionZero)
    {
        SessionId = GetJobSessionId(pSpool, JobId);
    }

    if(SessionId == -1)
    { 
        dwRetValue = ERROR_INVALID_PARAMETER;
    }
    else
    {
        *pIsSessionZero = (SessionId == 0);
    }

    return dwRetValue;

}


BOOL
LclPromptUIPerSessionUser(
    IN  HANDLE          hPrinter,
    IN  DWORD           JobId,
    IN  PSHOWUIPARAMS   pUIParams,
    OUT DWORD           *pResponse
)
/*++

Routine Description:

    Pops TS Message Box in the Session that created the Job.

Arguments:

    hPrinter  - printer handle
    JobId     - Job ID
    pUIParams - UI Parameters
    pResponse - user's response

Return Value:

    TRUE if it was able to show the UI

--*/
{
    PSPOOL      pSpool      = (PSPOOL)hPrinter;
    DWORD       SessionId   = -1;
    PINIJOB     pIniJob     = NULL;
    DWORD       dwReturnVal = 0;
    DWORD       MessageLength;
    DWORD       TitleLength;
    BOOL        bRetValue   = FALSE;
    
    if (pSpool && JobId && pUIParams && pResponse)
    {
        SessionId = GetJobSessionId(pSpool, JobId);
    }

    if(SessionId == -1)
    { 
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    else
    {
        switch (pUIParams->UIType) 
        {
            case kMessageBox:
            {
                if (pUIParams->MessageBoxParams.cbSize == sizeof(MESSAGEBOX_PARAMS) &&
                    pUIParams->MessageBoxParams.pTitle &&
                    pUIParams->MessageBoxParams.pMessage &&
                    InitializeMessageBoxFunction()) 
                {
                    TitleLength   = (wcslen(pUIParams->MessageBoxParams.pTitle) + 1) * sizeof(WCHAR);
                    MessageLength = (wcslen(pUIParams->MessageBoxParams.pMessage) + 1) * sizeof(WCHAR);

                    bRetValue   =  pWinStationSendMessage(
                                        SERVERNAME_CURRENT,
                                        SessionId, 
                                        pUIParams->MessageBoxParams.pTitle,
                                        TitleLength,
                                        pUIParams->MessageBoxParams.pMessage, 
                                        MessageLength,
                                        pUIParams->MessageBoxParams.Style,
                                        pUIParams->MessageBoxParams.dwTimeout,
                                        pResponse,
                                        !pUIParams->MessageBoxParams.bWait);                                 
                }
                else
                {
                    SetLastError(ERROR_INVALID_PARAMETER);
                }
            }
            default:
            {
                SetLastError(ERROR_INVALID_PARAMETER);
            }
        }
    }
    
    return bRetValue;
}


BOOL
InitializeMessageBoxFunction(
)    
/*++

Routine Description:

    Returns the address of WinStationSendMessageW exported by winsta.dll.
    WTSSendMessage could have been used instead of doing this.
    

Arguments:

    None.

Return Value:

    The address of WinStationSendMessageW.

--*/
{
    UINT    uOldErrorMode;
    
    if (!pWinStationSendMessage)
    {
        if (WinStaDllHandle == NULL) 
        {
            uOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

            WinStaDllHandle = LoadLibraryW(L"winsta.dll");

            SetErrorMode(uOldErrorMode);
        }

        if(WinStaDllHandle != NULL) 
        {
            pWinStationSendMessage = (PWINSTATION_SEND_MESSAGEW)GetProcAddress(
                                      WinStaDllHandle,
                                      "WinStationSendMessageW"
                                      );
        }
    }

    return !!pWinStationSendMessage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\monitor.c ===
/*++


Copyright (c) 1990 - 1996  Microsoft Corporation

Module Name:

    monitor.c

Abstract:

   This module contains all code for Monitor-based Spooler apis

   LocalEnumPorts
   LocalAddMonitor
   LocalDeleteMonitor
   LocalEnumMonitors
   LocalAddPort
   LocalConfigurePort
   LocalDeletePort

   Support Functions in monitor.c - (Warning! Do Not Add to this list!!)

   CopyIniMonitorToMonitor          -- KrishnaG
   GetMonitorSize                   -- KrishnaG

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:
    Khaled Sedky (khaleds) 15-March-2000
        - Added LocalSendRecvBidiData

    Muhunthan Sivapragasam (MuhuntS) 15-Jun-1995
        - Port info 2 changes

    Krishna Ganugapati (KrishnaG) 2-Feb-1994
        - reorganized the entire source file

    Matthew Felton (mattfe) June 1994 pIniSpooler

--*/

#include <precomp.h>
#include <offsets.h>
#include <clusspl.h>

//
// Private declarations
//

HDESK ghdeskServer = NULL;

//
// Function declarations
//



LPBYTE
CopyIniMonitorToMonitor(
    PINIMONITOR pIniMonitor,
    DWORD   Level,
    LPBYTE  pMonitorInfo,
    LPBYTE  pEnd
    );

DWORD
GetMonitorSize(
    PINIMONITOR  pIniMonitor,
    DWORD       Level
    );



BOOL
LocalEnumPorts(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplEnumPorts( pName,
                            Level,
                            pPorts,
                            cbBuf,
                            pcbNeeded,
                            pcReturned,
                            pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}


VOID
SplReenumeratePorts(
    )
{
    LPVOID  pBuf;
    DWORD   cbNeeded, dwDontCare;

    //
    // EnumPorts checks for new ports enumerated by port monitors and updates
    // localspl pIniPorts list
    //
    if ( !SplEnumPorts(NULL, 1, NULL, 0, &cbNeeded,
                       &dwDontCare, pLocalIniSpooler)               &&
         GetLastError() == ERROR_INSUFFICIENT_BUFFER                &&
         (pBuf = AllocSplMem(cbNeeded)) ) {

        SplEnumPorts(NULL, 1, pBuf, cbNeeded, &cbNeeded,
                     &dwDontCare, pLocalIniSpooler);
        FreeSplMem(pBuf);
    }
}


BOOL
GetPortInfo2UsingPortInfo1(
    PINIMONITOR     pIniMonitor,
    LPWSTR          pName,
    LPBYTE          pPorts,
    DWORD           cbBuf,
    LPDWORD         pcbNeeded,
    LPDWORD         pcReturned
    )
{

    BOOL            bRet;
    LPPORT_INFO_1   pPortInfo1;
    LPPORT_INFO_2   pPortInfo2;
    DWORD           cReturned;

    bRet =  (*pIniMonitor->Monitor2.pfnEnumPorts)(
                pIniMonitor->hMonitor,
                pName,
                1,
                pPorts,
                cbBuf,
                pcbNeeded,
                pcReturned );

    if ( !bRet ) {

        //
        // This is the upperbound
        //
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            *pcbNeeded += (*pcbNeeded / sizeof(PORT_INFO_1)) *
                                  (sizeof(PORT_INFO_2) - sizeof(PORT_INFO_1));
    } else {

        *pcbNeeded += *pcReturned * (sizeof(PORT_INFO_2) - sizeof(PORT_INFO_1));

        if ( *pcbNeeded <= cbBuf ) {

            cReturned = *pcReturned;
            while ( cReturned-- ) {

                pPortInfo1 = (LPPORT_INFO_1) (pPorts + cReturned * sizeof(PORT_INFO_1));
                pPortInfo2 = (LPPORT_INFO_2) (pPorts + cReturned * sizeof(PORT_INFO_2));

                pPortInfo2->pPortName    = pPortInfo1->pName;
                pPortInfo2->pMonitorName = NULL;
                pPortInfo2->pDescription = NULL;
                pPortInfo2->fPortType    = 0;
                pPortInfo2->Reserved     = 0;
            }
        } else {

            *pcReturned = 0;
            bRet = FALSE;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    }

    return bRet;
}


BOOL
SplEnumPorts(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    PINISPOOLER pIniSpooler
)
{
    PINIMONITOR     pIniMonitor;
    DWORD           dwIndex, cReturned=0, cbStruct, TotalcbNeeded=0;
    LPBYTE          pBuffer = pPorts, pTemp;
    DWORD           Error=0, TempError  = 0;
    DWORD           BufferSize=cbBuf;
    LPWSTR          pPortName;
    PINIPORT        pIniPort;
    HANDLE          hToken;
    BOOL            bRemoteCall;


    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    //
    // HACK: Some monitors choke if pName is non-NULL.  We can make
    // it NULL at this point since we know that we're using the same
    // ports on the local machine.
    //
    pName = NULL;

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ENUMERATE,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    switch (Level) {

    case 1:
        cbStruct = sizeof(PORT_INFO_1);
        break;

    case 2:
        cbStruct = sizeof(PORT_INFO_2);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    bRemoteCall = !IsLocalCall();

    //
    // We revert to local system context only when the caller is remote.
    // The monitors may load dlls from system32 and remote users like
    // guest or anonymous logon do not have sufficient privileges for that.
    // This is safe to revert to self since we do not support delegation, so 
    // we will never use the credentials of the remote user to go remote again.
    // If the caller is logged on interactively, then we do not switch the
    // context. Thus, a monitor may be able to go on the network for the port
    // enumeration.
    //
    if (bRemoteCall && !(hToken = RevertToPrinterSelf()))
    {
        return FALSE;
    }

    for ( pIniMonitor = pIniSpooler->pIniMonitor ;
          pIniMonitor ;
          pIniMonitor = pIniMonitor->pNext ) {

        //
        // Lang monitor does not have to define this
        //
        if ( !pIniMonitor->Monitor2.pfnEnumPorts )
            continue;

        *pcReturned = 0;

        *pcbNeeded = 0;

        if (!(*pIniMonitor->Monitor2.pfnEnumPorts)(
                   pIniMonitor->hMonitor,
                   pName,
                   Level,
                   pPorts,
                   BufferSize,
                   pcbNeeded,
                   pcReturned)) {

            TempError = GetLastError();
            //
            // Level 2 is a superset of level 1. So we can make a level 1
            // call if the monitor does not support it
            //
            if ( Level == 2 && TempError == ERROR_INVALID_LEVEL ) {

                TempError = 0;
                if ( !GetPortInfo2UsingPortInfo1(pIniMonitor,
                                                 pName,
                                                 pPorts,
                                                 BufferSize,
                                                 pcbNeeded,
                                                 pcReturned) )
                    TempError = GetLastError();
            }

            if ( TempError ) {

                Error = TempError;

                *pcReturned = 0;

                if ( TempError != ERROR_INSUFFICIENT_BUFFER ) {

                    *pcbNeeded  = 0;
                    break;
                }
            }
        } else {

            //
            // Now we look for new ports not in pIniPort list and add them
            //
            EnterSplSem();

            for ( dwIndex = 0, pTemp = pPorts ;
                  dwIndex < *pcReturned ;
                  ++dwIndex ) {

                switch ( Level ) {

                    case 1:
                        pPortName   = ((LPPORT_INFO_1)pTemp)->pName;
                        pTemp      += sizeof(PORT_INFO_1);
                        break;

                    case 2:
                        pPortName   = ((LPPORT_INFO_2)pTemp)->pPortName;
                        pTemp      += sizeof(PORT_INFO_2);
                        break;

                    default:
                        SPLASSERT(Level == 1 || Level == 2);
                }

                pIniPort = FindPort(pPortName, pIniSpooler);
                if ( !pIniPort ) {
                    CreatePortEntry(pPortName, pIniMonitor, pIniSpooler);

                } else if ( !pIniPort->pIniMonitor ) {
                    //
                    // If a fake port gets eventually enumerated by a monitor, 
                    // update the pIniPort structure (USB monitor). It is no
                    // longer a placeholder port at this point.
                    //
                    pIniPort->pIniMonitor = pIniMonitor;
                    pIniPort->Status |= PP_MONITOR;   
                    pIniPort->Status &= ~PP_PLACEHOLDER;                    
                }
            }

            LeaveSplSem();
        }


        cReturned += *pcReturned;

        pPorts += *pcReturned * cbStruct;

        if (*pcbNeeded <= BufferSize)
            BufferSize -= *pcbNeeded;
        else
            BufferSize = 0;

        TotalcbNeeded += *pcbNeeded;
    }

    if (bRemoteCall) 
    {
        ImpersonatePrinterClient(hToken);
    }

    *pcbNeeded = TotalcbNeeded;

    *pcReturned = cReturned;


    if (Error) {

        SetLastError(Error);
        return FALSE;
    } else if (TotalcbNeeded > cbBuf ) {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    } else {

        //
        // Stop routing if this is a cluster'd spooler.  Otherwise,
        // we'll talk to win32spl, which RPCs to us again.
        //
        if( pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){
            return ROUTER_STOP_ROUTING;
        }
        return TRUE;
    }
}


BOOL
LocalEnumMonitors(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplEnumMonitors( pName, Level, pMonitors, cbBuf,
                               pcbNeeded, pcReturned, pIniSpooler );


    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}



BOOL
SplEnumMonitors(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    PINISPOOLER pIniSpooler
)
{
    PINIMONITOR pIniMonitor;
    DWORD   cReturned=0, cbStruct, cb;
    LPBYTE  pBuffer = pMonitors;
    DWORD   BufferSize=cbBuf, rc;
    LPBYTE  pEnd;

    if (!MyName( pName, pIniSpooler )) {

        return ROUTER_UNKNOWN;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ENUMERATE,
                               NULL, NULL, pIniSpooler )) {

        return ROUTER_UNKNOWN;
    }

    switch (Level) {

    case 1:
        cbStruct = sizeof(MONITOR_INFO_1);
        break;

    case 2:
        cbStruct = sizeof(MONITOR_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return ROUTER_UNKNOWN;
    }

   EnterSplSem();

    for ( cb = 0, pIniMonitor = pIniSpooler->pIniMonitor ;
          pIniMonitor ;
          pIniMonitor = pIniMonitor->pNext ) {

        //
        // We'll not enumerate monitors which do not support AddPort
        //
        if ( pIniMonitor->Monitor2.pfnAddPort ||
             pIniMonitor->Monitor2.pfnXcvOpenPort)
            cb+=GetMonitorSize(pIniMonitor, Level);
    }

    *pcbNeeded = cb;
    *pcReturned = 0;

    if (cb <= cbBuf) {

        pEnd=pMonitors + cbBuf;

        for ( pIniMonitor = pIniSpooler->pIniMonitor ;
              pIniMonitor ;
              pIniMonitor = pIniMonitor->pNext ) {

            //
            // We'll not enumerate monitors which do not support AddPort
            //
            if ( !pIniMonitor->Monitor2.pfnAddPort &&
                 !pIniMonitor->Monitor2.pfnXcvOpenPort )
                continue;

            pEnd = CopyIniMonitorToMonitor(pIniMonitor, Level, pMonitors, pEnd);

            switch (Level) {

            case 1:
                pMonitors+=sizeof(MONITOR_INFO_1);
                break;

            case 2:
                pMonitors+=sizeof(MONITOR_INFO_2);
                break;
            }

            (*pcReturned)++;
        }

        if( pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){

            //
            // Stop routing, since we don't want any one else to report
            // back monitors.  If we're on the local machine now and
            // we continue routing, win32spl will RPC back to ourself
            // and re-enumerate the same ports.
            //
            rc = ROUTER_STOP_ROUTING;

        } else {

            rc = ROUTER_SUCCESS;
        }

    } else {

        rc = ROUTER_UNKNOWN;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

   LeaveSplSem();

    return rc;
}

BOOL
LocalAddPort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplAddPort( pName, hWnd, pMonitorName, pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}





BOOL
SplAddPort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName,
    PINISPOOLER pIniSpooler
)
{
    PINIMONITOR pIniMonitor;
    BOOL        rc=FALSE;

    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

   EnterSplSem();
    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );
    pIniMonitor = FindMonitor(pMonitorName, pIniSpooler);
   LeaveSplSem();

    if ( pIniMonitor ) {

        if ( pIniMonitor->Monitor2.pfnAddPort )
            rc = (*pIniMonitor->Monitor2.pfnAddPort)(
                       pIniMonitor->hMonitor,
                       pName,
                       hWnd,
                       pMonitorName );
        else
            SetLastError(ERROR_INVALID_PARAMETER);
    }
    else {

        SetLastError(ERROR_INVALID_NAME);
    }

    if (rc)
        rc = AddPortToSpooler(pName, pIniMonitor, pIniSpooler);

    return rc;
}


BOOL
AddPortToSpooler(
    PCWSTR      pName,
    PINIMONITOR pIniMonitor,
    PINISPOOLER pIniSpooler
)
{
    DWORD i, cbNeeded, cbDummy, cReturned;
    PPORT_INFO_1    pPorts;
    PINIPORT        pIniPort;


    /* If we don't already have the port in our local cache, add it:
     */
    if (!(*pIniMonitor->Monitor2.pfnEnumPorts)(
               pIniMonitor->hMonitor,
               (PWSTR)pName,
               1,
               NULL,
               0,
               &cbNeeded,
               &cReturned)) {

        pPorts = AllocSplMem(cbNeeded);

        if (pPorts) {

            if ((*pIniMonitor->Monitor2.pfnEnumPorts)(
                      pIniMonitor->hMonitor,
                      (PWSTR)pName,
                      1,
                      (LPBYTE)pPorts,
                      cbNeeded,
                      &cbDummy,
                      &cReturned)) {

               EnterSplSem();

                for (i = 0 ; i < cReturned ; ++i) {

                    pIniPort = FindPort(pPorts[i].pName, pIniSpooler);
                    if ( !pIniPort ) {
                        CreatePortEntry(pPorts[i].pName, pIniMonitor, pIniSpooler);

                    //
                    // If we have a port without a monitor and it gets added at
                    // this time. Remove the placeholder status from it.
                    //
                    } else if ( !pIniPort->pIniMonitor ) {
                            pIniPort->pIniMonitor = pIniMonitor;
                            pIniPort->Status |= PP_MONITOR;
                            pIniPort->Status &= ~PP_PLACEHOLDER;
                    }
                }

               LeaveSplSem();
            }

            FreeSplMem(pPorts);
        }
    }

    EnterSplSem();
    SetPrinterChange(NULL,
                     NULL,
                     NULL,
                     PRINTER_CHANGE_ADD_PORT,
                     pIniSpooler);
    LeaveSplSem();

    return TRUE;
}


BOOL
LocalConfigurePort(
    LPWSTR   pName,
    HWND     hWnd,
    LPWSTR   pPortName
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplConfigurePort( pName, hWnd, pPortName, pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}



BOOL
SplConfigurePort(
    LPWSTR   pName,
    HWND     hWnd,
    LPWSTR   pPortName,
    PINISPOOLER pIniSpooler
)
{
    PINIPORT    pIniPort;
    BOOL        rc;

    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

   EnterSplSem();
    pIniPort = FindPort(pPortName, pIniSpooler);
   LeaveSplSem();

    if ((pIniPort) && (pIniPort->Status & PP_MONITOR)) {

        if ( !pIniPort->pIniMonitor->Monitor2.pfnConfigurePort ) {

            SetLastError(ERROR_NOT_SUPPORTED);
            return FALSE;
        }

        if (rc = (*pIniPort->pIniMonitor->Monitor2.pfnConfigurePort)(
                       pIniPort->pIniMonitor->hMonitor,
                       pName,
                       hWnd,
                       pPortName)) {

            EnterSplSem();

            SetPrinterChange(NULL,
                             NULL,
                             NULL,
                             PRINTER_CHANGE_CONFIGURE_PORT,
                             pIniSpooler);
            LeaveSplSem();
        }

        return rc;
    }

    SetLastError(ERROR_UNKNOWN_PORT);
    return FALSE;
}


BOOL
LocalDeletePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplDeletePort( pName,
                             hWnd,
                             pPortName,
                             pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}



BOOL
SplDeletePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName,
    PINISPOOLER pIniSpooler
)
{
    PINIPORT    pIniPort;
    BOOL        rc=FALSE;

    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    EnterSplSem();

    pIniPort = FindPort(pPortName, pIniSpooler);

    if ( !pIniPort || !(pIniPort->Status & PP_MONITOR) ) {
        LeaveSplSem();
        SetLastError(ERROR_UNKNOWN_PORT);
        return FALSE;
    }

    if( !pIniPort->pIniMonitor->Monitor2.pfnDeletePort ){
        LeaveSplSem();
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }

    rc = DeletePortFromSpoolerStart( pIniPort );

    LeaveSplSem();

    if (!rc)
        goto Cleanup;

    rc = (*pIniPort->pIniMonitor->Monitor2.pfnDeletePort)(
               pIniPort->pIniMonitor->hMonitor,
               pName,
               hWnd,
               pPortName);

    rc = DeletePortFromSpoolerEnd(pIniPort, pIniSpooler, rc);

Cleanup:
    SplOutSem();
    return rc;
}



BOOL
DeletePortFromSpoolerEnd(
    PINIPORT    pIniPort,
    PINISPOOLER pIniSpooler,
    BOOL        bSuccess
)
{

    EnterSplSem();

    if(bSuccess) {

        DeletePortEntry( pIniPort );

        //
        // Success, delete the port data and send a notification.
        //
        SetPrinterChange( NULL,
                          NULL,
                          NULL,
                          PRINTER_CHANGE_DELETE_PORT,
                          pIniSpooler );
    } else {

        //
        // Add it back.  If the name is already used (e.g., just added
        // while we were out of the critical section), we're in trouble,
        // but there's not much we can do about it.  (When we restart,
        // we'll re-enumerate the duplicate name from the monitors
        // anyway.)
        //
        DBGMSG( DBG_WARN, ( "SplDeletePort: port.DeletePort failed %d\n", GetLastError()));
        LinkPortToSpooler( pIniPort, pIniSpooler );
    }

    LeaveSplSem();
    SplOutSem();

    return bSuccess;
}


BOOL
DeletePortFromSpoolerStart(
    PINIPORT    pIniPort
    )
{
    BOOL        rc = FALSE;
    PINISPOOLER pIniSpooler = pIniPort->pIniSpooler;

    SplInSem();

    if ( pIniPort->cPrinters || pIniPort->cRef || pIniPort->cJobs ) {

        SetLastError(ERROR_BUSY);
        goto Cleanup;
    }

    //
    // Remove it from the linked list so that no one will try to grab
    // a reference to while we're deleting it.
    //
    DelinkPortFromSpooler( pIniPort, pIniSpooler );
    rc = TRUE;


Cleanup:

    return rc;
}



BOOL
LocalAddMonitor(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pMonitorInfo
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplAddMonitor( pName,
                             Level,
                             pMonitorInfo,
                             pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}




BOOL
SplAddMonitor(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pMonitorInfo,
    PINISPOOLER pIniSpooler
)
{
    PINIMONITOR  pIniMonitor;
    PMONITOR_INFO_2  pMonitor = (PMONITOR_INFO_2)pMonitorInfo;
    HANDLE  hToken;
    HKEY    hKey;
    LONG    Status;
    BOOL    rc = FALSE;
    DWORD   dwPathLen = 0;

    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    if (Level != 2) {

        SetLastError( ERROR_INVALID_LEVEL );
        return FALSE;
    }

    if (!pMonitor            ||
        !pMonitor->pName     ||
        !*pMonitor->pName) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (!pMonitor->pEnvironment  ||
        !*pMonitor->pEnvironment ||
        lstrcmpi(pMonitor->pEnvironment, szEnvironment)) {

        SetLastError( ERROR_INVALID_ENVIRONMENT );
        return FALSE;
    }

    if (!pMonitor->pDLLName  ||
        !*pMonitor->pDLLName ){

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }


   EnterSplSem();

    if (FindMonitor(pMonitor->pName, pIniSpooler)) {

        LeaveSplSem();
        SetLastError(ERROR_PRINT_MONITOR_ALREADY_INSTALLED);
        return FALSE;
    }

    hToken = RevertToPrinterSelf();

    pIniMonitor = CreateMonitorEntry(pMonitor->pDLLName,
                                     pMonitor->pName,
                                     pIniSpooler);

    if (pIniMonitor != (PINIMONITOR)-1) {

        WCHAR   szRegistryRoot[MAX_PATH];
        PINISPOOLER pIniSpoolerMonitor;
        HANDLE hKeyOut;
        LPCWSTR pszPathOut;

        //
        // Note that even though this is built once per pIniSpooler, the
        // list of monitors is the same for all spoolers.  However, the
        // ports that the monitor returns from EnumPorts is different for
        // each pIniSpooler (for clustering).
        //
        // If it's not local, then it could be a cached win32 monitor.
        //
        if( pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL ){
            pIniSpoolerMonitor = pLocalIniSpooler;
        } else {
            pIniSpoolerMonitor = pIniSpooler;
        }

        //
        // Build the registry path.  In some cases it's a relative
        // path from hckRoot; other times it's a hard coded path from
        // HKLM (e.g., win32spl).
        //
        GetRegistryLocation( pIniSpoolerMonitor->hckRoot,
                             pIniSpoolerMonitor->pszRegistryMonitors,
                             &hKeyOut,
                             &pszPathOut );

        Status = StrNCatBuff( szRegistryRoot, 
                              COUNTOF(szRegistryRoot), 
                              pszPathOut,
                              L"\\",
                              pMonitor->pName,
                              NULL );
        
        if (Status == ERROR_SUCCESS)
        {

            Status = RegCreateKeyEx( hKeyOut,
                                     szRegistryRoot,
                                     0,
                                     NULL,
                                     0,
                                     KEY_WRITE,
                                     NULL,
                                     &hKey,
                                     NULL );
    
            if (Status == ERROR_SUCCESS) {
    
                Status = RegSetValueEx( hKey,
                                        L"Driver",
                                        0,
                                        REG_SZ,
                                        (LPBYTE)pMonitor->pDLLName,
                                        (wcslen(pMonitor->pDLLName) + 1)*sizeof(WCHAR));
    
                if (Status == ERROR_SUCCESS) {
                    rc = TRUE;
                } else {
                    SetLastError( Status );
                }
    
                RegCloseKey(hKey);
    
            } else {
                SetLastError( Status );
            }
        }
        else
        {
            SetLastError(Status);
        }

    }

    ImpersonatePrinterClient(hToken);

    //
    //  Bug 54843 if this fails we could still have a IniMonitor on the linked list that
    //  is BAD, it should be removed.  MattFe 19th Jan 95
    //  Note *maybe* we do this because a monitor might fail to initialize
    //  but will correctly function next time you reboot, like hpmon ( dlc doesn't become active until
    //  the next reboot.   Please Verify.

   LeaveSplSem();

    if ( !rc ) {
        DBGMSG( DBG_WARNING, ("SplAddMonitor failed %d\n", GetLastError() ));
    }

    return rc;
}

BOOL
LocalDeleteMonitor(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pMonitorName
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplDeleteMonitor( pName,
                                pEnvironment,
                                pMonitorName,
                                pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}




BOOL
SplDeleteMonitor(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pMonitorName,
    PINISPOOLER pIniSpooler
)
{
    BOOL    Remote=FALSE;
    PINIMONITOR pIniMonitor;
    PINIPORT    pIniPort, pIniPortNext;
    HKEY    hKeyMonitors, hKey;
    LONG    Status;
    BOOL    rc = FALSE;
    HANDLE  hToken;
    HANDLE hKeyOut;
    LPCWSTR pszPathOut;

    if (pName && *pName) {

        if (!MyName( pName, pIniSpooler )) {

            return FALSE;

        } else {

            Remote=TRUE;
        }
    }

    if ((pMonitorName == NULL) || (*pMonitorName == L'\0')) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    EnterSplSem();

    if (!(pIniMonitor=(PINIMONITOR)FindMonitor(pMonitorName,
                                               pIniSpooler))) {

        SetLastError(ERROR_UNKNOWN_PRINT_MONITOR);
        LeaveSplSem();
        return FALSE;
    }

    if ( pIniMonitor->cRef ) {

        SetLastError(ERROR_PRINT_MONITOR_IN_USE);
        LeaveSplSem();
        return FALSE;
    }

    pIniPort = pIniSpooler->pIniPort;

    while (pIniPort) {

        if ((pIniPort->pIniMonitor == pIniMonitor) &&
            (pIniPort->cPrinters || pIniPort->cRef)) {

            SetLastError(ERROR_BUSY);
            LeaveSplSem();
            return FALSE;
        }

        pIniPort = pIniPort->pNext;
    }

    hToken = RevertToPrinterSelf();

    GetRegistryLocation( pIniSpooler->hckRoot,
                         pIniSpooler->pszRegistryMonitors,
                         &hKeyOut,
                         &pszPathOut );

    Status = SplRegOpenKey(hKeyOut,
                           pszPathOut,
                           KEY_READ | KEY_WRITE,
                           &hKeyMonitors,
                           pIniSpooler);

    if (Status == ERROR_SUCCESS)
    {
        Status = SplRegOpenKey(hKeyMonitors, 
                               pMonitorName,
                               KEY_READ | KEY_WRITE, 
                               &hKey,
                               pIniSpooler);

        if (Status == ERROR_SUCCESS)
        {
            Status = DeleteSubkeys(hKey, pIniSpooler);

            SplRegCloseKey(hKey, pIniSpooler);

            if (Status == ERROR_SUCCESS)
                Status = SplRegDeleteKey(hKeyMonitors, pMonitorName, pIniSpooler);
        }

        SplRegCloseKey(hKeyMonitors, pIniSpooler);
    }


    if (Status == ERROR_SUCCESS) {

        pIniPort = pIniSpooler->pIniPort;

        while (pIniPort) {

            pIniPortNext = pIniPort->pNext;

            if (pIniPort->pIniMonitor == pIniMonitor)
                DeletePortEntry(pIniPort);

            pIniPort = pIniPortNext;
        }

        RemoveFromList((PINIENTRY *)&pIniSpooler->pIniMonitor,
                       (PINIENTRY)pIniMonitor);

        FreeIniMonitor( pIniMonitor );

        rc = TRUE;

    }

    if (Status != ERROR_SUCCESS)
        SetLastError(Status);

    ImpersonatePrinterClient(hToken);

    LeaveSplSem();

    return rc;
}

LPBYTE
CopyIniMonitorToMonitor(
    PINIMONITOR pIniMonitor,
    DWORD   Level,
    LPBYTE  pMonitorInfo,
    LPBYTE  pEnd
)
{
    LPWSTR *pSourceStrings, *SourceStrings;
    DWORD j;
    DWORD *pOffsets;

    switch (Level) {

    case 1:
        pOffsets = MonitorInfo1Strings;
        break;

    case 2:
        pOffsets = MonitorInfo2Strings;
        break;

    default:
        return pEnd;
    }

    for (j=0; pOffsets[j] != -1; j++) {
    }

    SourceStrings = pSourceStrings = AllocSplMem(j * sizeof(LPWSTR));

    if (!SourceStrings) {
        DBGMSG(DBG_WARNING, ("Failed to alloc Port source strings.\n"));
        return pEnd;
    }

    switch (Level) {

    case 1:
        *pSourceStrings++=pIniMonitor->pName;
        break;

    case 2:
        *pSourceStrings++=pIniMonitor->pName;
        *pSourceStrings++=szEnvironment;
        *pSourceStrings++=pIniMonitor->pMonitorDll;
        break;
    }

    pEnd = PackStrings(SourceStrings, pMonitorInfo, pOffsets, pEnd);
    FreeSplMem(SourceStrings);

    return pEnd;
}

DWORD
GetMonitorSize(
    PINIMONITOR  pIniMonitor,
    DWORD       Level
)
{
    DWORD cb=0;

    switch (Level) {

    case 1:
        cb=sizeof(MONITOR_INFO_1) + wcslen(pIniMonitor->pName)*sizeof(WCHAR) +
                                    sizeof(WCHAR);
        break;

    case 2:
        cb = wcslen(pIniMonitor->pName) + 1 + wcslen(pIniMonitor->pMonitorDll) + 1
                                            + wcslen(szEnvironment) + 1;
        cb *= sizeof(WCHAR);
        cb += sizeof(MONITOR_INFO_2);
        break;

    default:

        cb = 0;
        break;
    }

    return cb;
}


BOOL
LocalAddPortEx(
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   pBuffer,
    LPWSTR   pMonitorName
)
{
    return  ( SplAddPortEx( pName,
                            Level,
                            pBuffer,
                            pMonitorName,

                            pLocalIniSpooler ));
}


BOOL
SplAddPortEx(
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   pBuffer,
    LPWSTR   pMonitorName,
    PINISPOOLER pIniSpooler
)
{
   PINIMONITOR pIniMonitor;
    BOOL        rc=FALSE;
    DWORD       i, cbNeeded, cReturned, cbDummy;
    PPORT_INFO_1    pPorts = NULL;
    PINIPORT        pIniPort;

    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

   EnterSplSem();
   pIniMonitor = FindMonitor(pMonitorName, pIniSpooler);
   LeaveSplSem();

   if (!pIniMonitor) {
       SetLastError(ERROR_INVALID_NAME);
       return(FALSE);
   }

   if (pIniMonitor->Monitor2.pfnAddPortEx) {
    rc = (*pIniMonitor->Monitor2.pfnAddPortEx)(
               pIniMonitor->hMonitor,
               pName,
               Level,
               pBuffer,
               pMonitorName);
   }
   if (!rc) {
       return(FALSE);
   }

   if (!(*pIniMonitor->Monitor2.pfnEnumPorts)(
              pIniMonitor->hMonitor,
              pName,
              1,
              NULL,
              0,
              &cbNeeded,
              &cReturned)) {

       pPorts = AllocSplMem(cbNeeded);
   }

   if (pPorts) {
       if ((*pIniMonitor->Monitor2.pfnEnumPorts)(
                 pIniMonitor->hMonitor,
                 pName,
                 1,
                 (LPBYTE)pPorts,
                 cbNeeded,
                 &cbDummy,
                 &cReturned)) {

           EnterSplSem();

           for (i = 0; i < cReturned; i++) {
               
                pIniPort = FindPort(pPorts[i].pName, pIniSpooler);
                if ( !pIniPort ) {
                    CreatePortEntry(pPorts[i].pName, pIniMonitor, pIniSpooler);

                } else if ( !pIniPort->pIniMonitor ) {
                    pIniPort->pIniMonitor = pIniMonitor;
                    pIniPort->Status |= PP_MONITOR;                
                }
           }
           LeaveSplSem();
       }

       FreeSplMem(pPorts);
   }

    EnterSplSem();
    SetPrinterChange(NULL,
                     NULL,
                     NULL,
                     PRINTER_CHANGE_ADD_PORT,
                     pIniSpooler);
    LeaveSplSem();

    return rc;
}


VOID
LinkPortToSpooler(
    PINIPORT pIniPort,
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Links a pIniPort onto the pIniSpooler.

Arguments:

    pIniPort - Port to link; must not already be on a ll.

    pIniSpooler - Provides ll for pIniPort.

Return Value:

--*/

{
    SplInSem();
    SPLASSERT( !pIniPort->pIniSpooler );

    pIniPort->pNext = pIniSpooler->pIniPort;
    pIniPort->pIniSpooler = pIniSpooler;
    pIniSpooler->pIniPort = pIniPort;
}

VOID
DelinkPortFromSpooler(
    PINIPORT pIniPort,
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Remove a pIniPort from a pIniSpooler->pIniPort linked list.  The
    pIniPort may or may not be on the list; if it isn't, then this
    routine does nothing.

    Generic delink code ripped out into a subroutine.

    The refcount on pIniPort must be zero.  Anyone that uses pIniPort
    must hold a reference, since it may be deleted outside the
    SplSem when cRef==0.

Arguments:

    pIniPort - Port to delink from the list.  May or may not be on
        pIniSpooler->pIniPort.

    pIniSpooler - Linked list from which the pIniPort will be removed.

Return Value:

--*/

{
    PINIPORT *ppCurPort;

    SplInSem();
    SPLASSERT( !pIniPort->cRef );

    //
    // Keep searching for pIniPort until we hit the end of the
    // list or we've found it.
    //
    for( ppCurPort = &pIniSpooler->pIniPort;
         *ppCurPort && *ppCurPort != pIniPort;
         ppCurPort = &((*ppCurPort)->pNext )){

        ; // Don't do anything.
    }

    //
    // If we found it, delink it.
    //
    if( *ppCurPort ){
        *ppCurPort = (*ppCurPort)->pNext;

        //
        // Null out the back pointer since we have removed it from
        // the pIniSpooler.
        //
        pIniPort->pIniSpooler = NULL;
    }
}

/*++
    Function Name:
        LocalSendRecvBidiData
        
    Description:
        This function is the providor point of communicating with 
        Monitors supporting BIDI data. It allows the providor to 
        set data in the printer and query data from the printer
     
     Parameters:
        hPrinter    : This could be a Printer/Port Handle
        dwAccessBit : Priverledges allowed to the accessing thread
        pAction     :
        pReqData    : Request encapsulatig the queries in an array
        ppResData   : Response returned to client in an array of Data
        
        
     Return Value:
        Win32 Error Code
--*/

DWORD
LocalSendRecvBidiData(
    IN  HANDLE                    hPrinter,
    IN  LPCTSTR                   pAction,
    IN  PBIDI_REQUEST_CONTAINER   pReqData,
    OUT PBIDI_RESPONSE_CONTAINER* ppResData
)
{
    DWORD        dwRet        = ERROR_SUCCESS;
    PSPOOL       pSpool       = (PSPOOL)hPrinter;
    PINIPORT     pIniPort     = NULL;
    PINIMONITOR  pIniMonitor  = NULL;

    EnterSplSem();
    {
        //
        // Process of validating the parameters
        //
        if((!pAction || !*pAction)   ||
           (!pReqData && !ppResData))
        {
            dwRet = ERROR_INVALID_PARAMETER;
        }
        else
        {
            if (!ValidateSpoolHandle( pSpool, PRINTER_HANDLE_SERVER ))
            {
                dwRet = ERROR_INVALID_HANDLE;
            }
            else
            {
                if(pSpool->TypeofHandle & PRINTER_HANDLE_PRINTER)
                {
                    PINIPRINTER     pIniPrinter;
                    PINIMONITOR     pIniLangMonitor = NULL;
                    
                    if(pIniPrinter = pSpool->pIniPrinter)
                    {
                        pIniPort = FindIniPortFromIniPrinter( pIniPrinter );

                        if (pIniPort)
                        {
                        
                            pIniLangMonitor = pIniPrinter->pIniDriver->pIniLangMonitor;
                            
                            if ( pIniLangMonitor &&
                                 !pIniLangMonitor->Monitor2.pfnSendRecvBidiDataFromPort )
                                pIniLangMonitor = NULL;
    
    
                            //
                            // Port needs to be opened?
                            //
                            if ( pIniPort->pIniLangMonitor != pIniLangMonitor ||
                                 !pIniPort->hPort ) 
                            {
                                LPTSTR pszPrinter;
                                TCHAR szFullPrinter[ MAX_UNC_PRINTER_NAME ];
                                
                                if( pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER )
                                {
                                    pszPrinter = szFullPrinter;
                                    wsprintf( szFullPrinter,
                                              L"%ws\\%ws",
                                              pIniPrinter->pIniSpooler->pMachineName,
                                              pIniPrinter->pName );
                                } else {
                                    
                                    pszPrinter = pIniPrinter->pName;
                                }
    
                                    
                                if ( !OpenMonitorPort(pIniPort,
                                                      & pIniLangMonitor,
                                                      pszPrinter,
                                                      FALSE) ) {
    
                                    dwRet = ERROR_INVALID_HANDLE;
                                }
                            }
                        }
                        else
                            dwRet = ERROR_INVALID_HANDLE;

                    }
                }
                else if(pSpool->TypeofHandle & PRINTER_HANDLE_PORT)
                {
                    pIniPort = pSpool->pIniPort;
                }

                if(dwRet == ERROR_SUCCESS && pIniPort && (pIniPort->Status & PP_MONITOR))
                {
                    pIniMonitor = pIniPort->pIniLangMonitor ? 
                                  pIniPort->pIniLangMonitor : 
                                  pIniPort->pIniMonitor;
                    
                    if(pIniMonitor)
                    {
                        //
                        // Calling into the monitor
                        //
                        if(pIniMonitor->Monitor2.pfnSendRecvBidiDataFromPort)
                        {
                        
                            INCPORTREF(pIniPort);
                            INCMONITORREF(pIniMonitor);
                            
                            LeaveSplSem();
                            SplOutSem();
                            
                            dwRet = (*pIniMonitor->Monitor2.pfnSendRecvBidiDataFromPort)(pIniPort->hPort,
                                                                                         pSpool->GrantedAccess,
                                                                                         pAction,
                                                                                         pReqData,
                                                                                         ppResData);
                            EnterSplSem();
                            
                            DECMONITORREF(pIniMonitor);
                            DECPORTREF(pIniPort);
                        }
                        else
                        {
                            //
                            // Here we could use a simulation code;
                            //
                            dwRet = ERROR_NOT_SUPPORTED;
                        }
                    }
                    else
                    {
                        dwRet = ERROR_INVALID_HANDLE;
                    }
                }
                else
                {
                    dwRet = ERROR_INVALID_HANDLE;
                }
            }
        }
    }
    LeaveSplSem();
    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\port.c ===
/*++


Copyright (c) 1990 - 1996 Microsoft Corporation

Module Name:

    port.c

Abstract:

    This module contains functions to control port threads

    PrintDocumentThruPrintProcessor
    CreatePortThread
    DestroyPortThread
    PortThread

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

   KrishnaG  3-Feb-1991 - moved all monitor based functions to monitor.c
   Matthew Felton (mattfe) Feb 1994    Added OpenMonitorPort CloseMonitorPort

--*/

#include <precomp.h>
#pragma hdrstop

#include "clusspl.h"
#include "filepool.hxx"

WCHAR *szFilePort = L"FILE:";


VOID
PrintDocumentThruPrintProcessor(
    PINIPORT pIniPort,
    PPRINTPROCESSOROPENDATA pOpenData
    );


// ShutdownPorts
//
// Called when the DLL_PROCESS_DETATCH is called
// Close all portthreads
// Close all monitorports

VOID
ShutdownPorts(
    PINISPOOLER pIniSpooler
)
{
    PINIPORT pIniPort;

    if (!pIniSpooler || (pIniSpooler == INVALID_HANDLE_VALUE))
    {
        return;
    }

   EnterSplSem();
    SplInSem();

    pIniPort = pIniSpooler->pIniPort;

    while(pIniPort) {

        DestroyPortThread(pIniPort, TRUE);

        //
        // Don't close monitor port since DLL_ATTACH may have been called
        //
        // CloseMonitorPort(pIniPort);

        RemoveDeviceName(pIniPort);
        pIniPort = pIniPort->pNext;
    }

   LeaveSplSem();

    return;
}



BOOL
OpenMonitorPort(
    PINIPORT        pIniPort,
    PINIMONITOR     *ppIniLangMonitor,
    LPWSTR          pszPrinterName,
    BOOL            bWaitForEvent
    )
{
    BOOL            bRet = TRUE;

    SplInSem();
    SPLASSERT (pIniPort != NULL || pIniPort->signature == IPO_SIGNATURE);

    //
    // If going to file or no monitor associated do not have to open
    //
    if ( (pIniPort->Status & PP_FILE) || !(pIniPort->Status & PP_MONITOR) ) {

        return TRUE;
    }

    //
    // If a LM is passed and it does not have an OpenPortEx can't use it
    //
    if ( *ppIniLangMonitor && !(*ppIniLangMonitor)->Monitor2.pfnOpenPortEx )
        *ppIniLangMonitor = NULL;

    //
    // The port is already open by the correct monitor?
    //
    if ( *ppIniLangMonitor == pIniPort->pIniLangMonitor && pIniPort->hPort )
        return TRUE;

    INCPORTREF(pIniPort);
    LeaveSplSem();
    SplOutSem();

    if ( bWaitForEvent &&
         WAIT_OBJECT_0 != WaitForSingleObject(pIniPort->hWaitToOpenOrClose,
                                              INFINITE) ) {

        DBGMSG(DBG_ERROR,
               ("OpenMonitorPort: WaitForSingleObject failed with error %d\n",
                GetLastError()));
        EnterSplSem();
        DECPORTREF(pIniPort);
        return FALSE;
    }

    EnterSplSem();

    if ( pIniPort->hPort ) {

        //
        // If the port is already open by the correct monitor return it
        //
        if ( *ppIniLangMonitor == pIniPort->pIniLangMonitor )
            goto Cleanup;

        if ( !CloseMonitorPort(pIniPort, FALSE) ) {

            DBGMSG(DBG_WARNING,
                   ("CloseMonitorPort failed for %ws -- LastError%d\n",
                   pIniPort->pName, GetLastError()));
            bRet = FALSE;
            goto Cleanup;
        }
    }

    SPLASSERT(!pIniPort->hPort);

    LeaveSplSem();
    SplOutSem();

    DBGMSG(DBG_TRACE,
           ("OpenPort port %ws (IniPort : %x)\n", pIniPort->pName, pIniPort));


    //
    // If we have a language monitor, then use it.   Note that if it's
    // downlevel and we have an uplevel port monitor, we can't use
    // it because we can't pass in the new function vector.
    //
    if ( *ppIniLangMonitor ) {

        SPLASSERT(pIniPort->pIniMonitor);

        if( !(*ppIniLangMonitor)->bUplevel ){

            LPWSTR pszPort = pIniPort->pName;
            WCHAR szPortNew[MAX_PATH];

            if( pIniPort->pIniMonitor->bUplevel ){

                //
                // Downlevel port monitor; create hack string.
                //
                DBGMSG( DBG_WARN,
                        ( "Downlevel LM with uplevel PM %ws %ws\n",
                          (*ppIniLangMonitor)->pName,
                          pIniPort->pIniMonitor->pName ));

                if( !CreateDlName( pIniPort->pName,
                                   pIniPort->pIniMonitor,
                                   szPortNew )){

                    goto SkipLanguageMonitor;
                }

                //
                // We've created a new port string that has the
                // pIniMonitor encoded.
                //
                pszPort = szPortNew;

            }

            //
            // Downlevel language monitor and port monitor.
            //
            bRet = (*(*ppIniLangMonitor)->Monitor.pfnOpenPortEx)(
                       pszPort,
                       pszPrinterName,
                       &pIniPort->hPort,
                       &pIniPort->pIniMonitor->Monitor );

        } else {

            //
            // Both uplevel lang monitor.  Either up or downlevel port.
            //
            bRet = (*(*ppIniLangMonitor)->Monitor2.pfnOpenPortEx)(
                       (*ppIniLangMonitor)->hMonitor,
                       pIniPort->pIniMonitor->hMonitor,
                       pIniPort->pName,
                       pszPrinterName,
                       &pIniPort->hPort,
                       &pIniPort->pIniMonitor->Monitor2 );
        }
    } else {

SkipLanguageMonitor:

        *ppIniLangMonitor = NULL;
        bRet = (*pIniPort->pIniMonitor->Monitor2.pfnOpenPort)(
                   pIniPort->pIniMonitor->hMonitor,
                   pIniPort->pName,
                   &pIniPort->hPort );
    }

    EnterSplSem();

    if ( bRet && pIniPort->hPort ) {

        if ( *ppIniLangMonitor )
            pIniPort->pIniLangMonitor = *ppIniLangMonitor;
        DBGMSG(DBG_TRACE, ("OpenPort success for %ws\n", pIniPort->pName));

        DBGMSG( DBG_WARN,
                ( "OpenMonitorPort: IncSpoolerRef %x\n",
                  pIniPort->pIniSpooler ));
        INCSPOOLERREF( pIniPort->pIniSpooler );

    } else {

        if ( bRet || pIniPort->hPort )
            DBGMSG(DBG_WARNING,
                   ("OpenPort: unexpected return %d with hPort %x\n",
                    bRet, pIniPort->hPort));

        bRet = FALSE;
        pIniPort->hPort = NULL;
        DBGMSG(DBG_WARNING, ("OpenPort failed %ws error %d\n",
               pIniPort->pName, GetLastError()));
    }

Cleanup:
    SplInSem();

    if ( bWaitForEvent)
        SetEvent(pIniPort->hWaitToOpenOrClose);

    if ( !bRet )
        DECPORTREF(pIniPort);
    return bRet;
}


BOOL
CloseMonitorPort(
    PINIPORT    pIniPort,
    BOOL        bWaitForEvent
)
{
    BOOL    bRet = TRUE;
    PINIMONITOR     pIniMonitor;

    SPLASSERT ( pIniPort != NULL ||
                pIniPort->signature == IPO_SIGNATURE );

    INCPORTREF(pIniPort);
    LeaveSplSem();
    SplOutSem();

    if ( bWaitForEvent &&
         WAIT_OBJECT_0 != WaitForSingleObject(pIniPort->hWaitToOpenOrClose,
                                              INFINITE) ) {

        DBGMSG( DBG_ERROR,
                (  "CloseMonitorPort: WaitForSingleObject failed with error %d\n",
                   GetLastError()));
        EnterSplSem();
        DECPORTREF(pIniPort);
        return FALSE;
    }

    EnterSplSem();
    DECPORTREF(pIniPort);

    //
    // If going to file hPort should be NULL
    //
    SPLASSERT(!(pIniPort->Status & PP_FILE) || !pIniPort->hPort);

    if ( !pIniPort->hPort ) {

        goto Cleanup;
    }

    if ( pIniPort->pIniLangMonitor )
        pIniMonitor = pIniPort->pIniLangMonitor;
    else
        pIniMonitor = pIniPort->pIniMonitor;

    //
    // Only Close the Port Once
    //
    SPLASSERT ( pIniMonitor && pIniPort->cRef >= 1 );

    INCPORTREF(pIniPort);
    LeaveSplSem();
    SplOutSem();

    DBGMSG(DBG_TRACE, ("Close Port %ws -- %d\n", pIniPort->pName, pIniPort->cRef));
    bRet = (*pIniMonitor->Monitor2.pfnClosePort)( pIniPort->hPort );

    EnterSplSem();
    DECPORTREF(pIniPort);

    DBGMSG( DBG_WARN,
            ( "CloseMonitorPort: DecSpoolerRef %x\n",
              pIniPort->pIniSpooler ));
    DECSPOOLERREF( pIniPort->pIniSpooler );

    if ( bRet ) {

        pIniPort->hPort = NULL;
        DECPORTREF(pIniPort);
        if ( pIniMonitor == pIniPort->pIniLangMonitor )
            pIniPort->pIniLangMonitor = NULL;


    } else {

        //
        // When net stop spooler is done the monitor could have been
        // called to shutdown (hpmon does it)
        //
        DBGMSG(DBG_WARNING,
               ("ClosePort failed for %ws -- LastError%d\n", pIniPort->pName, GetLastError()));
    }

Cleanup:
    SplInSem();

    if ( bWaitForEvent )
        SetEvent(pIniPort->hWaitToOpenOrClose);

    return bRet;
}


BOOL
CreatePortThread(
   PINIPORT pIniPort
)
{
    DWORD   ThreadId;
    BOOL    bReturnValue = FALSE;

    SplInSem();

    SPLASSERT (( pIniPort != NULL) &&
               ( pIniPort->signature == IPO_SIGNATURE));

    // Don't bother creating a thread for ports that don't have a monitor:

    if (!(pIniPort->Status & PP_MONITOR))
        return TRUE;


    if ( pIniPort->Status & PP_THREADRUNNING)
        return TRUE;


 try {

    pIniPort->Semaphore = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( pIniPort->Semaphore == NULL )
        leave;

    pIniPort->Ready     = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( pIniPort->Ready == NULL ) {
        leave;
    }

    pIniPort->Status |= PP_RUNTHREAD;

    pIniPort->hPortThread = CreateThread(NULL, INITIAL_STACK_COMMIT,
                             (LPTHREAD_START_ROUTINE)PortThread,
                             pIniPort,
                            0, &ThreadId);


    if( pIniPort->hPortThread == NULL ) {

        pIniPort->Status &= ~PP_RUNTHREAD;
        leave;
    }

     if ( !SetThreadPriority(pIniPort->hPortThread, dwPortThreadPriority) ) {
         DBGMSG(DBG_WARNING, ("CreatePortThread - Setting thread priority failed %d\n", GetLastError()));
     }

     LeaveSplSem();

     // Make CreatePortThread Synchronous

     WaitForSingleObject( pIniPort->Ready, INFINITE );

     EnterSplSem();
     SplInSem();

     pIniPort->Status |= PP_THREADRUNNING;

     bReturnValue = TRUE;

 } finally {

    if ( !bReturnValue ) {

        if ( pIniPort->Semaphore != NULL ) {

            CloseHandle( pIniPort->Semaphore );
            pIniPort->Semaphore = NULL;
        }

        if ( pIniPort->Ready != NULL ) {

            CloseHandle( pIniPort->Ready );
            pIniPort->Ready = NULL;
        }
    }
 }
    return bReturnValue;

}






BOOL
DestroyPortThread(
    PINIPORT    pIniPort,
    BOOL        bShutdown
)
{
    SplInSem();

    // PortThread checks for PP_RUNTHREAD
    // and exits if it is not set.

    pIniPort->Status &= ~PP_RUNTHREAD;

    if (pIniPort->Semaphore && !SetEvent(pIniPort->Semaphore)) {
        return  FALSE;
    }

    if( pIniPort->hPortThread != NULL) {

        INCPORTREF(pIniPort);
        LeaveSplSem();

        if ( WaitForSingleObject( pIniPort->hPortThread, INFINITE) == WAIT_FAILED ) {

            EnterSplSem();
            DECPORTREF(pIniPort);
            return FALSE;
        }

        EnterSplSem();
        DECPORTREF(pIniPort);
    }

    if (pIniPort->hPortThread != NULL) {

        CloseHandle(pIniPort->hPortThread);
        pIniPort->hPortThread = NULL;

    }

    //
    // The port may have been changed while the printer was printing.
    // Thus when the port thread finally goes away now is the time to
    // close the monitor. However we can't call the monitor during shutdown
    // since DLL_DETACH may already have been issued to the monitor dll
    //
    if ( !pIniPort->cPrinters && !bShutdown)
        CloseMonitorPort(pIniPort, TRUE);

    return TRUE;
}


VOID
RemoveIniPortFromIniJob(
    PINIJOB     pIniJob,
    PINIPORT    pIniPort
    )
{
    PINISPOOLER pIniSpooler = pIniJob->pIniPrinter->pIniSpooler;

    NOTIFYVECTOR NotifyVector;

    SplInSem();

    //
    // Increment the refcount since deleting the job may delete the
    // pIniJob, which would delete the pIniSpooler.
    //
    INCSPOOLERREF( pIniSpooler );

    SPLASSERT(pIniJob &&
              pIniJob->signature == IJ_SIGNATURE &&
              pIniJob->pIniPort);

    SPLASSERT( pIniJob->pIniPort == pIniPort );

    pIniPort->cJobs--;

    pIniJob->pIniPort = NULL;

    SPLASSERT( pIniJob->Status & JOB_DESPOOLING );

    //  Chained Jobs
    //  For a Chained Master Job do not remove JOB_DESPOOLING
    //  since we don't want the scheduler to reschedule this
    //  to another port

    if ( pIniPort->pIniJob != pIniJob ) {

        //  Normal Path
        //  When NOT a chained job.

        pIniJob->Status &= ~JOB_DESPOOLING;

        COPYNV(NotifyVector, NVJobStatus);
        NotifyVector[JOB_NOTIFY_TYPE] |= BIT(I_JOB_PORT_NAME) |
                                         BIT(I_JOB_PAGES_PRINTED) |
                                         BIT(I_JOB_BYTES_PRINTED);

        SetPrinterChange( pIniJob->pIniPrinter,
                          pIniJob,
                          NotifyVector,
                          PRINTER_CHANGE_SET_JOB,
                          pIniSpooler);
    }

    //  RestartJob() doesn't remove JOB_PRINTED or JOB_BLOCKED_DEVQ
    //  or JOB_DESPOOLING or JOB_COMPLETE if the despooling bit is on
    //  this is to avoid problems where we have completed "Printing"
    //  the job via a print processor and now the port thread is logging
    //  the job printed and sending an alert message.


    if ( pIniJob->Status & JOB_RESTART )
        pIniJob->Status &= ~( JOB_PRINTED | JOB_BLOCKED_DEVQ | JOB_COMPLETE);

    DeleteJobCheck(pIniJob);

    //
    // pIniJob may be gone at this point.
    //

    //
    // If we're at zero then set hEventNoPrintingJobs if it exists.
    //
    if( !pIniSpooler->cFullPrintingJobs &&
        pIniSpooler->hEventNoPrintingJobs ){

        SetEvent( pIniSpooler->hEventNoPrintingJobs );
    }

    //
    // Matches INCSPOOLERREF at beginning of this function.
    //
    DECSPOOLERREF( pIniSpooler );
}

DWORD
PortThread(
    PINIPORT  pIniPort
)
{
    DWORD rc;
    PRINTPROCESSOROPENDATA  OpenData;
    PINIJOB pIniJob;
    DWORD   NextJobId = 0;
    DWORD   Position;
    DWORD   dwDevQueryPrint = 0;
    DWORD   dwJobDirect = 0;
    DWORD   dwDevQueryPrintStatus = 0;
    WCHAR   ErrorString[MAX_PATH];
    BOOL    bRawDatatype;

    //
    // Power management.  While we have port threads, we don't want the
    // system to go to sleep.  Note that if we have a hung job, we will
    // not go to sleep.
    //
    SetThreadExecutionState( ES_SYSTEM_REQUIRED | ES_CONTINUOUS );

   EnterSplSem();

    INCSPOOLERREF( pIniPort->pIniSpooler );

    SPLASSERT( pIniPort->signature == IPO_SIGNATURE );

    if ( pIniPort->Status & PP_MONITOR ) {

        if ( pIniPort->Status & PP_FILE ) {
            rc = (*pIniPort->pIniMonitor->Monitor2.pfnOpenPort)(
                     pIniPort->pIniMonitor->hMonitor,
                     L"FILE:",
                     &pIniPort->hPort );
            DBGMSG(DBG_TRACE, (" After opening the file pseudo monitor port %d\n", rc));
            INCPORTREF( pIniPort );
            INCSPOOLERREF( pIniPort->pIniSpooler );

        } else {
            // LPRMON returns NULL ( fails and expect us to open it again
            // inside PrintingDirectlyToPort, so for now remove this assert
            // since OpenMonitorPort was added to PrintingDirectlyToPort
            // SPLASSERT( pIniPort->hPort != NULL );
        }
    }

    while (TRUE) {

       SplInSem();
        SPLASSERT( pIniPort->signature == IPO_SIGNATURE );

        DBGMSG(DBG_TRACE, ("Re-entering the Port Loop -- will blow away any Current Job\n"));

        pIniPort->Status |= PP_WAITING;
        SetEvent( pIniPort->Ready );
        CHECK_SCHEDULER();

        DBGMSG( DBG_PORT, ("Port %ws: WaitForSingleObject( %x )\n",
                            pIniPort->pName, pIniPort->Semaphore ) );

       LeaveSplSem();
       SplOutSem();

        //
        // Any modification to the pIniPort structure by other threads
        // can be done only at this point.
        //
       
        rc = WaitForSingleObject( pIniPort->Semaphore, INFINITE );
        
       EnterSplSem();
       SplInSem();

        SPLASSERT( pIniPort->signature == IPO_SIGNATURE );

        DBGMSG( DBG_PORT, ("Port %ws: WaitForSingleObject( %x ) returned\n",
                            pIniPort->pName, pIniPort->Semaphore));

        if ( !( pIniPort->Status & PP_RUNTHREAD ) ) {

            DBGMSG(DBG_TRACE, ("Thread for Port %ws Closing Down\n", pIniPort->pName));

            pIniPort->Status &= ~(PP_THREADRUNNING | PP_WAITING);
            CloseHandle( pIniPort->Semaphore );
            pIniPort->Semaphore = NULL;
            CloseHandle( pIniPort->Ready );
            pIniPort->Ready = NULL;


            if ( pIniPort->Status & PP_FILE ) {
                rc = (*pIniPort->pIniMonitor->Monitor2.pfnClosePort)(
                         pIniPort->hPort );

                pIniPort->hPort = NULL;
                DBGMSG(DBG_TRACE, (" After closing  the file pseudo monitor port\n %d\n"));

                DBGMSG( DBG_WARN,
                        ( "PortThread: DecSpoolerRef %x\n",
                          pIniPort->pIniSpooler ));

                DECSPOOLERREF( pIniPort->pIniSpooler );
                DECPORTREF( pIniPort );
            }

            DECSPOOLERREF( pIniPort->pIniSpooler );

            LeaveSplSem();
            SplOutSem();

            //
            // Power management.  We are done.
            //
            SetThreadExecutionState(ES_CONTINUOUS);

            ExitThread (FALSE);
        }

        ResetEvent( pIniPort->Ready );

        //
        // Bad assumption -- that at this point we definitely have a Job
        //

        if ( ( pIniJob = pIniPort->pIniJob ) &&
               pIniPort->pIniJob->pIniPrintProc ) {

            SPLASSERT( pIniJob->signature == IJ_SIGNATURE );
            SPLASSERT( pIniJob->Status & JOB_DESPOOLING );
            //
            // WMI Trace Events
            //
            INCJOBREF(pIniJob);
            LeaveSplSem();
            LogWmiTraceEvent(pIniJob->JobId, EVENT_TRACE_TYPE_SPL_PRINTJOB, NULL);
            EnterSplSem();
            DECJOBREF(pIniJob);



            DBGMSG(DBG_PORT, ("Port %ws: received job\n", pIniPort->pName));
            
            SPLASSERT(pIniJob->cRef != 0);
            DBGMSG(DBG_PORT, ("PortThread(1):cRef = %d\n", pIniJob->cRef));

            //
            // !! HACK !!
            //
            // If the datatype is 1.008 but the print proc doesn't support it,
            // then change it to 1.003 just for the print proc.
            //
            // This happens for the lexmark print processor.  They support
            // NT EMF 1.003, but not 1.008.  They just call GdiPlayEMF, so
            // they really can support 1.008 since they don't look at the
            // data.  However, since they don't advertise this, they can't
            // print.
            //
            // We work around this by switching the datatype back to 1.003.
            //
            if (!_wcsicmp(pIniJob->pDatatype, gszNT5EMF) &&
                !CheckDataTypes(pIniJob->pIniPrintProc, gszNT5EMF))
            {
                OpenData.pDatatype     = AllocSplStr(gszNT4EMF);
            }
            else
            {
                OpenData.pDatatype     = AllocSplStr(pIniJob->pDatatype);
            }

            OpenData.pDevMode      = AllocDevMode(pIniJob->pDevMode);
            OpenData.pParameters   = AllocSplStr(pIniJob->pParameters);
            OpenData.JobId         = pIniJob->JobId;
            OpenData.pDocumentName = AllocSplStr(pIniJob->pDocument);
            OpenData.pOutputFile   = AllocSplStr(pIniJob->pOutputFile);
            //
            // Check if we have RAW Printing
            //
            bRawDatatype = ValidRawDatatype(pIniJob->pDatatype);

            OpenData.pPrinterName = pszGetPrinterName(
                                        pIniJob->pIniPrinter,
                                        pIniPort->pIniSpooler != pLocalIniSpooler,
                                        NULL );

            dwDevQueryPrint = pIniJob->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_ENABLE_DEVQ;

            if ((pIniJob->Status & JOB_DIRECT) ||
               ((pIniJob->Status & JOB_DOWNLEVEL) &&
               ValidRawDatatype(pIniJob->pDatatype))) {

                dwJobDirect = 1;

            }


            // If we are restarting to print a document
            // clear its counters and remove the restart flag

            if ( pIniJob->Status & JOB_RESTART ) {

                pIniJob->Status &= ~(JOB_RESTART | JOB_INTERRUPTED);

                pIniJob->cbPrinted     = 0;
                pIniJob->cPagesPrinted = 0;

                //
                // Only use dwReboots if not RAW.
                //
                if (!bRawDatatype)
                {
                    //
                    // Solves bug 229913;
                    // Decrement number of reboots if job is restarted.
                    // ReadShadowJob checks the number of reboots and delete the job if too many
                    //
                    if( pIniJob->dwReboots ){
                        pIniJob->dwReboots--;
                    }
                }

            }

            //
            // Job is being restarted, so clear all errors?
            //
            ClearJobError( pIniJob );
            pIniJob->dwAlert = 0;

           //
           // Only use dwReboots if not RAW.
           //
           if (!bRawDatatype)
           {
               pIniJob->dwReboots++;
               WriteShadowJob(pIniJob, TRUE);
           }

           LeaveSplSem();
           SplOutSem();

           if ( ( dwDevQueryPrintStatus = CallDevQueryPrint(OpenData.pPrinterName,
                                                            OpenData.pDevMode,
                                                            ErrorString, 
                                                            MAX_PATH,
                                                            dwDevQueryPrint, 
                                                            dwJobDirect) ) ) {
    
                PrintDocumentThruPrintProcessor( pIniPort, &OpenData );
    
            }

           SplOutSem();
           EnterSplSem();

            // Decrement number of EMF jobs rendering and update available memory
            RemoveFromJobList(pIniJob, JOB_SCHEDULE_LIST);

            SPLASSERT( pIniPort->signature == IPO_SIGNATURE );
            SPLASSERT( pIniPort->pIniJob != NULL );
            SPLASSERT( pIniJob == pIniPort->pIniJob);
            SPLASSERT( pIniJob->signature == IJ_SIGNATURE );

            //
            //  Chained Jobs
            //  If we have a chain of jobs, we now need to find the next job in the chain
            //  and make sure its printed to the same port.
            //

            if (!( pIniJob->Status & ( JOB_PENDING_DELETION | JOB_RESTART )) &&
                 ( pIniJob->pCurrentIniJob != NULL )                 &&
                 ( pIniJob->pCurrentIniJob->NextJobId != 0 )) {

                // Follow the Chained Job to the Next Job
                // Look at scheduler to see where it picks up this job and assigns it back
                // to this port thread.

                pIniJob->pCurrentIniJob = FindJob( pIniJob->pIniPrinter, pIniJob->pCurrentIniJob->NextJobId, &Position );

                if ( pIniJob->pCurrentIniJob == NULL ) {

                    pIniPort->pIniJob = NULL;

                    DBGMSG( DBG_WARNING, ("PortThread didn't find NextJob\n"));

                } else {

                    SPLASSERT( pIniJob->pCurrentIniJob->signature == IJ_SIGNATURE );

                    DBGMSG( DBG_WARNING, ("PortThread completed JobId %d, NextJobId %d\n", pIniJob->JobId,
                                           pIniJob->pCurrentIniJob->JobId ));

                }

            } else {

                //
                //  Nothing More in Chain
                //

                pIniJob->pCurrentIniJob = NULL;
                pIniPort->pIniJob       = NULL;
            }

            if( !pIniJob->pCurrentIniJob ){

                //
                // Decrement the pIniSpooler job count.  We only decrement
                // at the end of a chain since we don't increment in the
                // middle of a chained job.
                //
                --pIniJob->pIniPrinter->pIniSpooler->cFullPrintingJobs;
            }

            DBGMSG(DBG_PORT, ("PortThread job has now printed - status:0x%0x\n", pIniJob->Status));

            FreeDevMode(OpenData.pDevMode);
            FreeSplStr(OpenData.pDatatype);
            FreeSplStr(OpenData.pParameters);
            FreeSplStr(OpenData.pDocumentName);
            FreeSplStr(OpenData.pOutputFile);
            FreeSplStr(OpenData.pPrinterName);



            // SPLASSERT( pIniJob->Time != 0 );
            pIniJob->Time = GetTickCount() - pIniJob->Time;

            if (!dwDevQueryPrintStatus) {

                DBGMSG(DBG_PORT, ("PortThread Job has not printed because of DevQueryPrint failed\n"));

                pIniJob->Status |= JOB_BLOCKED_DEVQ;
                SPLASSERT( !(pIniJob->Status & JOB_PRINTED));
                pIniJob->Time = 0;

                FreeSplStr( pIniJob->pStatus );
                pIniJob->pStatus = AllocSplStr(ErrorString);

                SetPrinterChange(pIniJob->pIniPrinter,
                                 pIniJob,
                                 NVJobStatusAndString,
                                 PRINTER_CHANGE_SET_JOB,
                                 pIniJob->pIniPrinter->pIniSpooler );

            } else if ( !( pIniJob->Status & JOB_TIMEOUT ) ) {


                //
                //  Only Log the event and send a popup if the last in the chain
                //

                if ( !(pIniJob->Status & JOB_RESTART) &&
                     pIniJob->pCurrentIniJob == NULL ) {

                    //
                    // A job can be in JOB_COMPLETE state when it was sent ot printer
                    // but the last page isn't ejected yet. A job completely sent to printer
                    // can be either in JOB_COMPLETE or JOB_PRINTED state.
                    // Monitors that doesn't support TEOJ will set the job as JOB_PRINTED
                    // right after the job was sent to printer and we don't want to set it on
                    // JOB_COMPLETE.
                    // For BIDI Monitors we'll come down here possibly before
                    // the monitor sets the job as JOB_PRINTED. We set the job as JOB_COMPLETE
                    // so that the scheduler will ignore it.
                    //
                    if (!(pIniJob->Status & (JOB_ERROR | JOB_PAPEROUT | JOB_OFFLINE)) &&
                        !(pIniJob->Status & JOB_PRINTED))
                    {
                        if (pIniJob->cPages == 0 &&
                           (pIniJob->Size == 0 || pIniJob->dwValidSize == 0) &&
                           !(pIniJob->Status & JOB_TYPE_ADDJOB))
                        {
                            //
                            // Set empty document to Printed as the monitor won't do it.
                            // Make exception for job submitted with AddJob.  The monitor
                            // is still in charge for doing it.
                            //
                            pIniJob->Status |= JOB_PRINTED;
                        }
                        else
                        {
                            pIniJob->Status |= JOB_COMPLETE;
                        }
                    }


                    // For Remote NT Jobs cPagesPrinted and cTotalPagesPrinted
                    // are NOT updated since we are getting RAW data.   So we
                    // use the cPages field instead.

                    if (pIniJob->cPagesPrinted == 0) {
                        pIniJob->cPagesPrinted = pIniJob->cPages;
                        pIniJob->pIniPrinter->cTotalPagesPrinted += pIniJob->cPages;
                    }

                    INCJOBREF(pIniJob);
                    LeaveSplSem();

                    LogJobPrinted(pIniJob);

                    EnterSplSem();
                    DECJOBREF(pIniJob);
                }

            }

            SplInSem();

            DBGMSG(DBG_PORT, ("PortThread(2):cRef = %d\n", pIniJob->cRef));

            //  Hi End Print Shops like to keep around jobs after they have
            //  completed.   They do this so they can print a proof it and then
            //  print it again for the final run.   Spooling the job again may take
            //  several hours which they want to avoid.
            //  Even if KEEPPRINTEDJOBS is set they can still manually delete
            //  the job via printman.

            if (( pIniJob->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS ) ||
                ( pIniJob->Status & JOB_TIMEOUT ) ) {

                //
                // WMI Trace Events.
                //
                // Treat a keep and restart as a delete and spool new job.
                WMI_SPOOL_DATA WmiData;
                DWORD CreateInfo;
                if (GetFileCreationInfo(pIniJob->hFileItem, &CreateInfo) != S_OK) {
                    // Assume all file created.
                    CreateInfo = FP_ALL_FILES_CREATED;
                }
                SplWmiCopyEndJobData(&WmiData, pIniJob, CreateInfo);

                pIniJob->Status &= ~JOB_PENDING_DELETION;
                pIniJob->cbPrinted = 0;

                //
                // Set the job as JOB_COMPLETE if not already set as JOB_PRINTED
                // by Monitor.
                // Monitors that doesn't support TEOJ will set the job as JOB_PRINTED
                // right after the job was sent to printer and we don't want to set it on
                // JOB_COMPLETE.
                // For BIDI Monitors we'll come down here possibly before
                // the monitor sets the job as JOB_PRINTED. We set the job as JOB_COMPLETE
                // so that the scheduler will ignore it.
                //
                if (!(pIniJob->Status & JOB_PRINTED)) {
                    pIniJob->Status |= JOB_COMPLETE;
                }

                //
                // Only use dwReboots if not RAW.
                //
                if (!bRawDatatype)
                {
                    --pIniJob->dwReboots;
                }

                //
                // We need to update the shadow file regardless the job type.
                // There is the job status that we need to update.
                //
                INCJOBREF(pIniJob);
                
                //
                // WriteShadowJob leaves the CS, So make sure that the ref on the 
                // pIniJob is kept high.
                // 
                WriteShadowJob(pIniJob, TRUE);

                LeaveSplSem();
                //
                // WMI Trace Events.
                //
                // The job is done.  If it is restarted you get a new spool job event.
                LogWmiTraceEvent(pIniJob->JobId, EVENT_TRACE_TYPE_SPL_DELETEJOB,
                                 &WmiData);

                EnterSplSem();
                DECJOBREF(pIniJob);


                SPLASSERT( pIniPort->signature == IPO_SIGNATURE );
                SPLASSERT( pIniJob->signature == IJ_SIGNATURE );

            }

            SplInSem();
            
            SPLASSERT( pIniJob->cRef != 0 );
            DECJOBREF(pIniJob);

            RemoveIniPortFromIniJob(pIniJob, pIniPort);

            //
            // N.B. The pIniJob may be gone at this point.
            //

        } else {

            //
            // !! VERIFY !!
            //
            SPLASSERT(pIniJob != NULL);

            if (pIniJob != NULL) {

                DBGMSG(DBG_PORT, ("Port %ws: deleting job\n", pIniPort->pName));

                // SPLASSERT( pIniJob->Time != 0 );
                pIniJob->Time = GetTickCount() - pIniJob->Time;
                //pIniJob->Status |= JOB_PRINTED;

                if ( pIniJob->hFileItem == INVALID_HANDLE_VALUE )
                {
                    CloseHandle( pIniJob->hWriteFile );
                }
                pIniJob->hWriteFile = INVALID_HANDLE_VALUE;

                DBGMSG(DBG_PORT, ("Port %ws - calling DeleteJob because PrintProcessor wasn't available\n"));
                RemoveIniPortFromIniJob(pIniJob, pIniPort);

                DeleteJob(pIniJob,BROADCAST);

                //
                // N.B. The pIniJob may be gone at this point.
                //
            }
        }

        //SetCurrentSid(NULL);
        DBGMSG(DBG_PORT,("Returning back to pickup a new job or to delete the PortThread\n"));

    }

    SPLASSERT( FALSE );
    return 0;
}

VOID
ReportPrintProcError(
    IN PINISPOOLER pIniSpooler,
    IN PINIJOB     pIniJob,
    IN DWORD       Error
    )
{
    LPWSTR pszDescription  = GetErrorString(Error);
    WCHAR  szError[40]     = {0};
        
    _snwprintf(szError, COUNTOF(szError), L"%u (0x%x)", Error, Error);

    SetCurrentSid(pIniJob->hToken);
    
    SplLogEvent(pIniJob->pIniPrinter->pIniSpooler,
                LOG_ERROR,
                MSG_PRINT_ON_PROC_FAILED,
                FALSE,
                pIniJob->pDocument,
                pIniJob->pUser,
                szError,
                pszDescription ? pszDescription : L"",
                NULL);

    SetCurrentSid(NULL);
    
    FreeSplStr(pszDescription);
}

VOID
PrintDocumentThruPrintProcessor(
    PINIPORT pIniPort,
    PPRINTPROCESSOROPENDATA pOpenData
    )
/*++

Routine Description:

    Print the document associated with pIniPort on the print
    processor.

    Status of pIniPort->Status = PP_RUNTHREAD
                                 PP_THREADRUNNING
                                 PP_MONITOR
                                 ~PP_WAITING

    NOTE: If PrintProc->Open is called and succeeds, PrintProc->Close
          must be called to cleanup.

Arguments:

Return Value:

--*/
{
    PINIJOB pIniJob = pIniPort->pIniJob;
    WCHAR szSpecialPortorPrinterName[MAX_UNC_PRINTER_NAME + MAX_PATH + PRINTER_NAME_SUFFIX_MAX];
    BOOL bJobError = FALSE;
    NOTIFYVECTOR NotifyVector;
    LPTSTR pszModify;
    UINT cchLen;
    BOOL bFailJob = FALSE;
    BOOL    bRemoteGuest       = FALSE;
    BOOL    bSpecialCaseDriver = FALSE;
    DWORD   Error;
    
    //
    // Check if printing principal is remote guest. Remote guest does not have enough 
    // permissions to print EMF. The EMF playback code in GDI32 fails for certain EMF records.
    // Because of this, we create an impersonation token based on the process token.
    //
    if ((bSpecialCaseDriver = IsSpecialDriver(pIniJob->pIniDriver, pIniJob->pIniPrintProc, pIniJob->pIniPrinter->pIniSpooler)) || 
        (Error = PrincipalIsRemoteGuest(pIniJob->hToken, &bRemoteGuest)) == ERROR_SUCCESS)
    {
        if (bRemoteGuest || bSpecialCaseDriver)
        {
            Error = ImpersonateSelf(SecurityImpersonation) ? ERROR_SUCCESS : GetLastError();
        }
        else
        {
            Error = SetCurrentSid(pIniJob->hToken) ? ERROR_SUCCESS : GetLastError();
        }
    }

    if (Error != ERROR_SUCCESS)
    {
        ReportPrintProcError(pIniJob->pIniPrinter->pIniSpooler, pIniJob, Error);

        bFailJob = TRUE;

        goto Complete;
    }


    DBGMSG( DBG_TRACE, ("PrintDocumentThruPrintProcessor pIniPort %x pOpenData %x\n", pIniPort, pOpenData));

    COPYNV(NotifyVector, NVJobStatus);

    cchLen = lstrlen( pIniJob->pIniPrinter->pIniSpooler->pMachineName );

    //
    // Do a length check.  PRINTER_NAME_SUFFIX_MAX holds the extra 4 separator
    // characters and the NULL terminator.
    //
    if (lstrlen( pIniPort->pName ) +
        lstrlen( pIniJob->pIniPrinter->pName ) +
        cchLen > COUNTOF( szSpecialPortorPrinterName )) {

        //
        // We should log an event, but this is a very rare event, only
        // in the print api tests.
        //
        bFailJob = TRUE;
        goto Complete;
    }

    //
    // For clustered spoolers, make sure it is fully qualified.
    // pszModify points to the string immediately after the server
    // name that can be modified.
    //
    // Always modify the string at pszModify, but pass in
    // szSpecialPortorPrinterName.
    //
    lstrcpy( szSpecialPortorPrinterName,
             pIniJob->pIniPrinter->pIniSpooler->pMachineName );

    szSpecialPortorPrinterName[cchLen] = '\\';

    pszModify = &szSpecialPortorPrinterName[cchLen+1];

    //
    // \\Server\
    // ^---------------------- szSpecialPortorPrinterName
    //          ^------------- pszModify
    //
    // Append the rest of the string at pszModify:
    //
    // \\Server\PortName, Port
    // \\Server\PrinterName, Job 33
    //

    //
    // Now create the port name, so that we can do the
    // secret open printer. the printer name will be
    // "FILE:, Port" and this will open a PRINTER_HANDLE_PORT
    // If we fail, then if the app thread may be waiting for
    // the pIniJob->StartDocComplete to be set, which would
    // ordinarily be done in the StartDocPrinter of the port.
    // We will do this little courtesy,
    //

    wsprintf( pszModify, L"%ws, Port", pIniPort->pName );

    DBGMSG( DBG_TRACE, ("PrintDocumentThruPrintProcessor Attempting PrintProcessor Open on %ws\n", szSpecialPortorPrinterName ));

    if (!(pIniPort->hProc = (HANDLE)(*pIniJob->pIniPrintProc->Open)
                                        (szSpecialPortorPrinterName, pOpenData))) {


        DBGMSG( DBG_WARNING, ("PrintDocumentThruPrintProcessor Failed Open error %d\n", GetLastError() ));

        bFailJob = TRUE;
        goto Complete;
    }

    //
    // For Jobs, turn this off even if it's not clustered.
    //
    if( !( pIniJob->pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER )){

        pszModify = szSpecialPortorPrinterName;

        //
        //
        // ^---------------------- szSpecialPortorPrinterName
        // ^---------------------- pszModify
        //
        // PortName, Port
        // PrinterName, Job 33
        //
    }

    EnterSplSem();

    pIniJob->Status |= JOB_PRINTING;
    pIniJob->Time    = GetTickCount();

    NotifyVector[JOB_NOTIFY_TYPE] |= BIT(I_JOB_PORT_NAME);

    SetPrinterChange(pIniJob->pIniPrinter,
                     pIniJob,
                     NotifyVector,
                     PRINTER_CHANGE_SET_JOB,
                     pIniJob->pIniPrinter->pIniSpooler);


    LeaveSplSem();

    //
    //  Create Special Name "PrinterName, Job xxx"
    //

    wsprintf( pszModify,
              L"%ws, Job %d",
              pIniJob->pIniPrinter->pName,
              pIniJob->JobId );

    DBGMSG( DBG_TRACE, ("PrintDocumentThruPrintProcessor calling Print hProc %x file %ws\n",
                         pIniPort->hProc, szSpecialPortorPrinterName ));

    if (!(*pIniJob->pIniPrintProc->Print)(pIniPort->hProc, szSpecialPortorPrinterName)) {

        //
        // The print function in the print processor sets the last error. For better understaning
        // of the underlying problem, we log both the Win32 error code and the description of it.
        //
        Error = GetLastError();

        ReportPrintProcError(pIniJob->pIniPrinter->pIniSpooler, pIniJob, Error);

        DBGMSG( DBG_TRACE, ("PrintDocumentThruPrintProcessor Print hProc %x Error %d\n",
                             pIniPort->hProc, GetLastError() ));


        EnterSplSem();

        if ( pIniJob->StartDocComplete ) {
            SetEvent( pIniJob->StartDocComplete );
        }

        bJobError = TRUE;

        LeaveSplSem();

    } else {

        DBGMSG( DBG_TRACE, ("PrintDocumentThruPrintProcessor Print hProc %x %ws Success\n",
                pIniPort->hProc, szSpecialPortorPrinterName ));
    }

    //
    // Now close the print processor.
    //

    EnterSplSem();

    SPLASSERT( pIniPort->hProc != NULL );

    DBGMSG( DBG_TRACE, ("PrintDocumentThruPrintProcessor calling Close hProc %x\n", pIniPort->hProc ));

    pIniJob->Status &= ~JOB_PRINTING;

    LeaveSplSem();

    //
    // JOB_PP_CLOSE is used to prevent the print processor from recursively
    // calling back into itself. This happens for some third party print processor.
    // Race conditions don't apply for this flag since 2 threads don't access it
    // simultaneously.
    //

    if (!(pIniJob->Status & JOB_PP_CLOSE))
    {

        EnterCriticalSection(&pIniJob->pIniPrintProc->CriticalSection);
        pIniJob->Status |= JOB_PP_CLOSE;

        if (!(*pIniJob->pIniPrintProc->Close)(pIniPort->hProc))
        {
            DBGMSG( DBG_WARNING, ("PrintDocumentThruPrintProcessor failed Close hProc %x Error %d\n",
                                   pIniPort->hProc, GetLastError() ));
        }

        pIniPort->hProc = NULL;
        pIniJob->Status &= ~JOB_PP_CLOSE;
        LeaveCriticalSection(&pIniJob->pIniPrintProc->CriticalSection);

        //
        // WMI Trace Events
        //
        if (pIniJob->pDevMode)
        {
            WMI_SPOOL_DATA Data;
            SplWmiCopyRenderedData(&Data, pIniJob->pDevMode);
            LogWmiTraceEvent(pIniJob->JobId, EVENT_TRACE_TYPE_SPL_JOBRENDERED, &Data);
        }
    }

Complete:

    EnterSplSem();

    if (bFailJob) {

        //
        // App might be waiting for the StartDoc to Complete
        //
        if ( pIniJob->StartDocComplete ) {
            SetEvent(pIniJob->StartDocComplete);
        }
        bJobError = TRUE;
    }

    //
    // If the job had an error, mark it pending deletion.  The port monitor
    // may not do this if EndDocPort was never called.
    //

    if ( !(pIniJob->Status & JOB_RESTART) && bJobError ){

        pIniJob->Status |= JOB_PENDING_DELETION;
        // Release any thread waiting on LocalSetPort
        SetPortErrorEvent(pIniJob->pIniPort);
        // Release any thread waiting on SeekPrinter
        SeekPrinterSetEvent(pIniJob, NULL, TRUE);
    }

    LeaveSplSem();

    //
    // RevertToSelf and SetCurrentSid have identical behavior. If one call ImpersonateSelf
    // and the SetCurrentSid instead of RevertToSelf, that's still fine. 
    //
    if (bRemoteGuest)
    {
        RevertToSelf();
    }
    else
    {
        SetCurrentSid(NULL);
    } 
}


VOID
UpdatePortStatusForAllPrinters(
    PINIPORT        pIniPort
    )
/*++

Routine Description:
    This routine is called when an IniPorts status changed so that we go
    through each printer connected to the port and update their port status

Arguments:
    pIniPort    - Port whose status chanegd

Return Value:
    Nothing

--*/
{
    PINIPRINTER     pIniPrinter;
    PINIPORT        pIniPrinterPort;
    DWORD           dwIndex1, dwIndex2, dwPortStatus, dwSeverity;

    for ( dwIndex1 = 0 ; dwIndex1 < pIniPort->cPrinters ; ++dwIndex1 ) {

        pIniPrinter     = pIniPort->ppIniPrinter[dwIndex1];
        dwSeverity      = 0;
        dwPortStatus    = 0;

        //
        // Pick the most severe status associated with all ports
        //
        for ( dwIndex2 = 0 ; dwIndex2 < pIniPrinter->cPorts ; ++dwIndex2 ) {

            pIniPrinterPort = pIniPrinter->ppIniPorts[dwIndex2];

            if ( pIniPrinterPort->Status & PP_ERROR ) {

                dwSeverity      = PP_ERROR;
                dwPortStatus    = PortToPrinterStatus(pIniPrinterPort->PrinterStatus);
                break; // no need to go thru rest of the ports for this printer
            } else if ( pIniPrinterPort->Status & PP_WARNING ) {

                if ( dwSeverity != PP_WARNING ) {

                    dwSeverity      = PP_WARNING;
                    dwPortStatus    = PortToPrinterStatus(pIniPrinterPort->PrinterStatus);
                }
            } else if ( pIniPrinterPort->Status & PP_INFORMATIONAL ) {

                if ( dwSeverity == 0 ) {

                    dwSeverity      = PP_INFORMATIONAL;
                    dwPortStatus    = PortToPrinterStatus(pIniPrinterPort->PrinterStatus);
                }
            }
        }

        if ( pIniPrinter->PortStatus != dwPortStatus ) {

            pIniPrinter->PortStatus = dwPortStatus;
            SetPrinterChange(pIniPrinter,
                             NULL,
                             NVPrinterStatus,
                             PRINTER_CHANGE_SET_PRINTER,
                             pIniPrinter->pIniSpooler);
        }
    }
}


//
// Table is by port status values in winspool.h
//
DWORD PortToPrinterStatusMappings[] = {

    0,
    PRINTER_STATUS_OFFLINE,
    PRINTER_STATUS_PAPER_JAM,
    PRINTER_STATUS_PAPER_OUT,
    PRINTER_STATUS_OUTPUT_BIN_FULL,
    PRINTER_STATUS_PAPER_PROBLEM,
    PRINTER_STATUS_NO_TONER,
    PRINTER_STATUS_DOOR_OPEN,
    PRINTER_STATUS_USER_INTERVENTION,
    PRINTER_STATUS_OUT_OF_MEMORY,
    PRINTER_STATUS_TONER_LOW,
    PRINTER_STATUS_WARMING_UP,
    PRINTER_STATUS_POWER_SAVE,
};


BOOL
LocalSetPort(
    LPWSTR      pszName,
    LPWSTR      pszPortName,
    DWORD       dwLevel,
    LPBYTE      pPortInfo
    )
{
    PINIPORT        pIniPort;
    PPORT_INFO_3    pPortInfo3 = (PPORT_INFO_3) pPortInfo;
    DWORD           dwLastError = ERROR_SUCCESS;
    DWORD           dwNewStatus, dwOldStatus;
    BOOL            bJobStatusChanged = FALSE;
    WCHAR           szPort[MAX_PATH + 9];
    LPWSTR          pszComma;
    PINISPOOLER     pIniSpooler = FindSpoolerByNameIncRef( pszName, NULL );
    BOOL            SemEntered = FALSE;

    if( !pIniSpooler )
    {
        dwLastError = ERROR_INVALID_NAME;
        goto Cleanup;
    }


    if ( !MyName(pszName, pIniSpooler) ) {

        dwLastError = GetLastError();
        goto Cleanup;
    }

    //
    // The monitor needs to be able to set or clear the error for the port. The monitor
    // is loaded by the spooler. If the monitor doesn't link to winspool.drv, then the 
    // call to SetPort comes directly, i.e. not via RPC. In this case we do not want
    // to check for admin privileges. We allow any user to set the port status.
    //
    if (!ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                              IsCallViaRPC() ? SERVER_ACCESS_ADMINISTER : SERVER_ACCESS_ENUMERATE,
                              NULL,
                              NULL, 
                              pIniSpooler )) {

        dwLastError = GetLastError();
        goto Cleanup;
    }

    if( !pszPortName ){

        dwLastError = ERROR_UNKNOWN_PORT ;
        goto Cleanup;
    }

    //
    // Some ports will come in as "port,1234abcd" so truncate the
    // suffix.
    //
    wcsncpy( szPort, pszPortName, COUNTOF( szPort ));

    //
    // Force NULL terminate the port. 
    //
    szPort[COUNTOF(szPort) - 1] = L'\0';

    pszComma = wcschr( szPort, TEXT( ',' ));
    if( pszComma ){
        *pszComma = 0;
    }

    SemEntered = TRUE;

    EnterSplSem();
    pIniPort = FindPort(szPort, pIniSpooler);

    if ( !pIniPort ) {

        dwLastError = ERROR_UNKNOWN_PORT;
        goto Cleanup;
    }

    if ( dwLevel != 3 ) {

        dwLastError = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }

    if ( !pPortInfo ) {

        dwLastError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    switch (pPortInfo3->dwSeverity) {
        case    0:
            if ( pPortInfo3->dwStatus || pPortInfo3->pszStatus ) {

                dwLastError = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            dwNewStatus = 0;
            break;

        case    PORT_STATUS_TYPE_ERROR:
            dwNewStatus = PP_ERROR;
            break;

        case    PORT_STATUS_TYPE_WARNING:
            dwNewStatus = PP_WARNING;
            break;

        case    PORT_STATUS_TYPE_INFO:
            dwNewStatus = PP_INFORMATIONAL;
            break;

        default:
            dwLastError = ERROR_INVALID_PARAMETER;
            goto Cleanup;
    }

    dwOldStatus             = pIniPort->Status;

    //
    // Clear old status
    //
    pIniPort->PrinterStatus = 0;
    pIniPort->Status       &= ~(PP_ERROR | PP_WARNING | PP_INFORMATIONAL);

    if ( pIniPort->pszStatus ) {

        //
        // If the job currently has the same status as port free it
        //
        if ( pIniPort->pIniJob              &&
             pIniPort->pIniJob->pStatus     &&
             !wcscmp(pIniPort->pIniJob->pStatus, pIniPort->pszStatus) ) {

            FreeSplStr(pIniPort->pIniJob->pStatus);
            pIniPort->pIniJob->pStatus = NULL;
            bJobStatusChanged = TRUE;
        }

        FreeSplStr(pIniPort->pszStatus);
        pIniPort->pszStatus = NULL;
    }

    //
    // If string field is used for status use it, else look at dwStatus
    //
    if ( pPortInfo3->pszStatus && *pPortInfo3->pszStatus ) {

        pIniPort->pszStatus = AllocSplStr(pPortInfo3->pszStatus);
        if ( !pIniPort->pszStatus ) {
            dwLastError = GetLastError();
            goto Cleanup;
        }

        if ( pIniPort->pIniJob && !pIniPort->pIniJob->pStatus ) {

            pIniPort->pIniJob->pStatus = AllocSplStr(pIniPort->pszStatus);
            bJobStatusChanged = TRUE;
        }

    } else {

        //
        // If we add new entries to winspool.h they should be added here too
        //
        if ( pPortInfo3->dwStatus >=
                    sizeof(PortToPrinterStatusMappings)/sizeof(PortToPrinterStatusMappings[0]) ) {

            dwLastError = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        pIniPort->PrinterStatus = pPortInfo3->dwStatus;
    }

    if( bJobStatusChanged ){

        SetPrinterChange( pIniPort->pIniJob->pIniPrinter,
                          pIniPort->pIniJob,
                          NVJobStatusString,
                          PRINTER_CHANGE_SET_JOB,
                          pIniPort->pIniJob->pIniPrinter->pIniSpooler );
    }

    pIniPort->Status    |= dwNewStatus;

    UpdatePortStatusForAllPrinters(pIniPort);
    if ( (dwOldStatus & PP_ERROR)   &&
         !(dwNewStatus & PP_ERROR) ) {

        //
        // if it is a transition to an non - error state , set event to unlock LocalWritePrinter
        //
        pIniPort->ErrorTime = 0;
        if( pIniPort->hErrorEvent != NULL ){

            SetEvent(pIniPort->hErrorEvent);
        }

        CHECK_SCHEDULER();
    }

    if ( !(dwOldStatus & PP_ERROR)   &&
         !(dwNewStatus & PP_ERROR) ) {

        //
        // when non-error state persists(after two calls with an non - error state) ,
        // close the hErrorEvent handle
        //
        if( pIniPort->hErrorEvent != NULL ){

            CloseHandle(pIniPort->hErrorEvent);
            pIniPort->hErrorEvent = NULL;
        }
    }


    if ( !(dwOldStatus & PP_ERROR)   &&
          (dwNewStatus & PP_ERROR)   &&
          (pIniPort->cJobs)          &&
          (pIniSpooler->bRestartJobOnPoolEnabled) &&
          ( pPortInfo3->dwStatus ==  PORT_STATUS_OFFLINE ||
            pPortInfo3->dwStatus ==  PORT_STATUS_PAPER_JAM ||
            pPortInfo3->dwStatus ==  PORT_STATUS_PAPER_OUT ||
            pPortInfo3->dwStatus ==  PORT_STATUS_DOOR_OPEN ||
            pPortInfo3->dwStatus ==  PORT_STATUS_PAPER_PROBLEM ||
            pPortInfo3->dwStatus ==  PORT_STATUS_NO_TONER)) {

        //
        // If it is a transition to an error state and port has an job assigned, create event as non-signalled or Reset event it
        // LocalWritePrinter will get stuck if the port is in error state and this event is reset
        //
        if( pIniPort->ErrorTime == 0 ){

            pIniPort->ErrorTime  = GetTickCount();

            if( pIniPort->hErrorEvent == NULL ){

                pIniPort->hErrorEvent = CreateEvent(NULL,
                                                    EVENT_RESET_MANUAL,
                                                    EVENT_INITIAL_STATE_NOT_SIGNALED,
                                                    NULL );
            }else{

                ResetEvent( pIniPort->hErrorEvent );
            }
        }

    }

    if ( (dwOldStatus & PP_ERROR)   &&
         (dwNewStatus & PP_ERROR)   &&
         (pIniPort->cJobs)          &&
         (pIniPort->hErrorEvent != NULL) ) {

        //
        // When error state persists , check the time since error occured.
        //
        if( (GetTickCount() - pIniPort->ErrorTime) > pIniSpooler->dwRestartJobOnPoolTimeout * 1000 ){

            //
            // If time out and printer is a pool ( more than one port assigned ),
            // clear job error and restart the job.
            //
            if( (pIniPort->pIniJob) &&
                (pIniPort->pIniJob->pIniPrinter) &&
                (pIniPort->pIniJob->pIniPrinter->cPorts > 1) ){

                //
                // Don't restart the job if it is already deleted or restarted.
                //
                BOOL bWasRestarted = pIniPort->pIniJob->Status & (JOB_PENDING_DELETION | JOB_RESTART);

                if( !bWasRestarted ){

                    ClearJobError( pIniPort->pIniJob );

                    RestartJob( pIniPort->pIniJob );
                }

                SetEvent( pIniPort->hErrorEvent );
            }



        }

    }

Cleanup:
    if(pIniSpooler)
    {
        FindSpoolerByNameDecRef( pIniSpooler );
    }

    if(SemEntered)
    {
        LeaveSplSem();
        SplOutSem();
    }

    if(dwLastError != ERROR_SUCCESS)
    {
        SetLastError(dwLastError);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

VOID
SetPortErrorEvent(
    PINIPORT pIniPort
)
{
    SplInSem();
    if(pIniPort && pIniPort->hErrorEvent) {
        SetEvent(pIniPort->hErrorEvent);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\portredn.c ===
/*++

Copyright (c) 1990 - 1995 Microsoft Corporation
All rights reserved.

Module Name:

    portredn.c

Abstract:

    This module contains functions to handle port redirection.
    Earlier this was done by localmon, the code is a modified version of
    localmon code.

Author:

    Muhunthan Sivapragasam (MuhuntS) 10-Sep-1995

Revision History:

--*/

#include <precomp.h>

WCHAR   szDeviceNameHeader[]    = L"\\Device\\NamedPipe\\Spooler\\";
WCHAR   szCOM[]     = L"COM";
WCHAR   szLPT[]     = L"LPT";

//
// Definitions for MonitorThread:
//
#define TRANSMISSION_DATA_SIZE  0x400
#define NUMBER_OF_PIPE_INSTANCES 10


typedef struct _TRANSMISSION {
    HANDLE       hPipe;
    BYTE         Data[TRANSMISSION_DATA_SIZE];
    LPOVERLAPPED pOverlapped;
    HANDLE       hPrinter;
    DWORD        JobId;
    PINIPORT     pIniPort;
} TRANSMISSION, *PTRANSMISSION;

typedef struct _REDIRECT_INFO {
    PINIPORT    pIniPort;
    HANDLE      hEvent;
} REDIRECT_INFO, *PREDIRECT_INFO;


VOID
FreeRedirectInfo(
    PREDIRECT_INFO  pRedirectInfo
    )
{
    SplInSem();

    //
    // This is to handle the case when Redirection thread did not initialize
    // correctly and is terminating abnormally
    // Since CloseHandle has not been called it is ok to do this
    //
    if ( pRedirectInfo->pIniPort->hEvent == pRedirectInfo->hEvent )
        pRedirectInfo->pIniPort->hEvent = NULL;

    DECPORTREF(pRedirectInfo->pIniPort);
    CloseHandle(pRedirectInfo->hEvent);
    FreeSplMem(pRedirectInfo);
}


VOID
RemoveColon(
    LPWSTR  pName)
{
    DWORD   Length;

    Length = wcslen(pName);

    if (pName[Length-1] == L':')
        pName[Length-1] = 0;
}


VOID
RemoveDeviceName(
    PINIPORT pIniPort
    )
{
    SplInSem();

    if ( pIniPort->hEvent ) {

        //
        // Redirection thread is told to terminate here; It will close the
        // handle. If it has already terminated then this call will fail
        //
        SetEvent(pIniPort->hEvent);
        pIniPort->hEvent = NULL;
    }

}

#define MAX_ACE 6

PSECURITY_DESCRIPTOR
CreateNamedPipeSecurityDescriptor(
    VOID)

/*++

Routine Description:

    Creates a security descriptor giving everyone access.

Arguments:

Return Value:

    The security descriptor returned by BuildPrintObjectProtection.

--*/

{

    UCHAR AceType[MAX_ACE];
    PSID AceSid[MAX_ACE];          
    BYTE InheritFlags[MAX_ACE];   
    DWORD AceCount;
    PSECURITY_DESCRIPTOR ServerSD = NULL;
    
    //
    // For Code optimization we replace 5 individaul 
    // SID_IDENTIFIER_AUTHORITY with an array of 
    // SID_IDENTIFIER_AUTHORITYs
    // where
    // SidAuthority[0] = UserSidAuthority   
    // SidAuthority[1] = PowerSidAuthority  
    // SidAuthority[2] = EveryOneSidAuthority
    // SidAuthority[3] = CreatorSidAuthority
    // SidAuthority[4] = SystemSidAuthority 
    // SidAuthority[5] = AdminSidAuthority  
    //
    SID_IDENTIFIER_AUTHORITY SidAuthority[MAX_ACE] = {
                                                      SECURITY_NT_AUTHORITY,          
                                                      SECURITY_NT_AUTHORITY,          
                                                      SECURITY_WORLD_SID_AUTHORITY,
                                                      SECURITY_CREATOR_SID_AUTHORITY, 
                                                      SECURITY_NT_AUTHORITY,          
                                                      SECURITY_NT_AUTHORITY           
                                                     };
    //
    // For code optimization we replace 5 individual Sids with 
    // an array of Sids
    // where 
    // Sid[0] = UserSid
    // Sid[1] = PowerSid
    // Sid[2] = EveryOne
    // Sid[3] = CreatorSid
    // Sid[4] = SystemSid
    // Sid[5] = AdminSid
    //
    PSID Sids[MAX_ACE] = {NULL,NULL,NULL,NULL,NULL,NULL};

    ACCESS_MASK AceMask[MAX_ACE] = { 
                                     FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE ,
                                     FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE ,
                                     (FILE_GENERIC_READ | FILE_WRITE_DATA | FILE_ALL_ACCESS) & 
                                     ~WRITE_DAC &~WRITE_OWNER & ~DELETE & ~FILE_CREATE_PIPE_INSTANCE,
                                     STANDARD_RIGHTS_ALL | FILE_GENERIC_WRITE | FILE_GENERIC_READ | FILE_ALL_ACCESS,
                                     STANDARD_RIGHTS_ALL | FILE_GENERIC_WRITE | FILE_GENERIC_READ | FILE_ALL_ACCESS,
                                     STANDARD_RIGHTS_ALL | FILE_GENERIC_WRITE | FILE_GENERIC_READ | FILE_ALL_ACCESS
                                   };

    DWORD SubAuthorities[3*MAX_ACE] = { 
                                       2 , SECURITY_BUILTIN_DOMAIN_RID , DOMAIN_ALIAS_RID_USERS ,  
                                       2 , SECURITY_BUILTIN_DOMAIN_RID , DOMAIN_ALIAS_RID_POWER_USERS ,
                                       1 , SECURITY_WORLD_RID          , 0 ,
                                       1 , SECURITY_CREATOR_OWNER_RID  , 0 ,
                                       1 , SECURITY_LOCAL_SYSTEM_RID   , 0 ,
                                       2 , SECURITY_BUILTIN_DOMAIN_RID , DOMAIN_ALIAS_RID_ADMINS
                                      };
    //
    // Name Pipe SD
    //

    for(AceCount = 0;
        ( (AceCount < MAX_ACE) &&
          AllocateAndInitializeSid(&SidAuthority[AceCount],
                                   (BYTE)SubAuthorities[AceCount*3],
                                   SubAuthorities[AceCount*3+1],
                                   SubAuthorities[AceCount*3+2],
                                   0, 0, 0, 0, 0, 0,
                                   &Sids[AceCount]));
        AceCount++)
    {
        AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
        AceSid[AceCount]           = Sids[AceCount];
        InheritFlags[AceCount]     = 0;
    }

    if(AceCount == MAX_ACE)
    {
        if(!BuildPrintObjectProtection(AceType,
                                      AceCount,
                                      AceSid,
                                      AceMask,
                                      InheritFlags,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &ServerSD ) )
        {
            DBGMSG( DBG_WARNING,( "Couldn't buidl Named Pipe protection" ) );        
        }
    }
    else
    {
        DBGMSG( DBG_WARNING,( "Couldn't Allocate and initialize SIDs" ) );        
    }

    for(AceCount=0;AceCount<MAX_ACE;AceCount++)
    {
        if(Sids[AceCount])
            FreeSid( Sids[AceCount] );
    }
    return ServerSD;
}


LPWSTR
SetupDosDev(
    PINIPORT pIniPort,
    LPWSTR szPipeName,
    DWORD   cchPipeName,
    PSECURITY_ATTRIBUTES pSecurityAttributes,
    PSECURITY_ATTRIBUTES* ppSecurityAttributes
    )
{
    WCHAR                   NewNtDeviceName[MAX_PATH];
    WCHAR                   OldNtDeviceName[MAX_PATH];
    WCHAR                   DosDeviceName[MAX_PATH];
    LPWSTR                  pszNewDeviceName = NULL;
    PSECURITY_DESCRIPTOR    lpSecurityDescriptor = NULL;
    BOOL                    bRet = FALSE;


    wcscpy(DosDeviceName, pIniPort->pName);
    RemoveColon(DosDeviceName);

     if(StrNCatBuff(NewNtDeviceName,
                    COUNTOF(NewNtDeviceName),
                    szDeviceNameHeader,
                    pIniPort->pName,
                    NULL) != ERROR_SUCCESS ) {

        goto Cleanup;
    }
    
    RemoveColon(NewNtDeviceName);

    pszNewDeviceName = AllocSplStr(NewNtDeviceName);

    if ( !pszNewDeviceName ||
         !QueryDosDevice(DosDeviceName, OldNtDeviceName,
                       sizeof(OldNtDeviceName)/sizeof(OldNtDeviceName[0]))) {

        goto Cleanup;
    }

    lpSecurityDescriptor = CreateNamedPipeSecurityDescriptor();

    if (lpSecurityDescriptor) {
        pSecurityAttributes->nLength = sizeof(SECURITY_ATTRIBUTES);
        pSecurityAttributes->lpSecurityDescriptor = lpSecurityDescriptor;
        pSecurityAttributes->bInheritHandle = FALSE;
    } else {
        pSecurityAttributes = NULL;
    }

    //
    // If clause added to preclude multiple entries of the same named pipe in the device
    // name definition.
    // Ram 1\16
    //

    if (lstrcmp(NewNtDeviceName, OldNtDeviceName) != 0) {
       DefineDosDevice(DDD_RAW_TARGET_PATH, DosDeviceName, NewNtDeviceName);
    }

    if (StrNCatBuff(    szPipeName,
                        cchPipeName,
                        L"\\\\.\\Pipe\\Spooler\\",
                        pIniPort->pName,
                        NULL) != ERROR_SUCCESS) {
        goto Cleanup;
    }

    RemoveColon(szPipeName);


    *ppSecurityAttributes = pSecurityAttributes;
    bRet = TRUE;

Cleanup:
    if ( !bRet ) {

        FreeSplStr(pszNewDeviceName);
        pszNewDeviceName = NULL;
    }

    return pszNewDeviceName;
}


VOID
ReadThread(
    PTRANSMISSION pTransmission)
{
    DOC_INFO_1W DocInfo;
    DWORD BytesRead;
    DWORD BytesWritten;
    BOOL bStartDocPrinterResult = FALSE;
    BOOL bReadResult;

    LPWSTR pszPrinter=NULL;

    //
    // ImpersonateNamedPipeClient requires that some data is read before
    // the impersonation is done.
    //
    bReadResult = ReadFile(pTransmission->hPipe,
                           pTransmission->Data,
                           sizeof(pTransmission->Data),
                           &BytesRead,
                           NULL);

    if (!bReadResult)
        goto Fail;

    if (!ImpersonateNamedPipeClient(pTransmission->hPipe)) {

        DBGMSG(DBG_ERROR,("ImpersonateNamedPipeClient failed %d\n",
                          GetLastError()));

        goto Fail;
    }

    SPLASSERT(pTransmission->pIniPort->cPrinters);
    pszPrinter = AllocSplStr(pTransmission->pIniPort->ppIniPrinter[0]->pName);

    if ( !pszPrinter ) {

        goto Fail;
    }


    //
    // Open the printer.
    //
    if (!OpenPrinter(pszPrinter, &pTransmission->hPrinter, NULL)) {

        DBGMSG(DBG_WARN, ("OpenPrinter(%ws) failed: Error %d\n",
                           pszPrinter,
                           GetLastError()));
        goto Fail;
    }

    memset(&DocInfo, 0, sizeof(DOC_INFO_1W));

    if (StartDocPrinter(pTransmission->hPrinter, 1, (LPBYTE)&DocInfo)) {

        DBGMSG(DBG_INFO, ("StartDocPrinter succeeded\n"));
        bStartDocPrinterResult = TRUE;

    } else {

        DBGMSG(DBG_WARN, ("StartDocPrinter failed: Error %d\n",
                           GetLastError()));

        goto Fail;
    }

    while (bReadResult && BytesRead) {

        if (!WritePrinter(pTransmission->hPrinter,
                          pTransmission->Data,
                          BytesRead,
                          &BytesWritten))
        {
            DBGMSG(DBG_WARN, ("WritePrinter failed: Error %d\n",
                               GetLastError()));

            goto Fail;
        }

        bReadResult = ReadFile(pTransmission->hPipe,
                               pTransmission->Data,
                               sizeof(pTransmission->Data),
                               &BytesRead,
                               NULL);
    }

    DBGMSG(DBG_INFO, ("bool %d  BytesRead 0x%x (Error = %d) EOT\n",
                      bReadResult,
                      BytesRead,
                      GetLastError()));


Fail:

    if (bStartDocPrinterResult) {

        if (!EndDocPrinter(pTransmission->hPrinter)) {

            DBGMSG(DBG_WARN, ("EndDocPrinter failed: Error %d\n",
                               GetLastError()));
        }
    }

    FreeSplStr(pszPrinter);
    if (pTransmission->hPrinter)
        ClosePrinter(pTransmission->hPrinter);

    if ( !SetEvent(pTransmission->pOverlapped->hEvent)) {

        DBGMSG(DBG_ERROR, ("SetEvent failed %d\n", GetLastError()));
    }

    FreeSplMem(pTransmission);
}


BOOL
ReconnectNamedPipe(
    HANDLE hPipe,
    LPOVERLAPPED pOverlapped)
{
    DWORD Error;
    BOOL bIOPending = FALSE;

    DisconnectNamedPipe(hPipe);

    if (!ConnectNamedPipe(hPipe,
                          pOverlapped)) {

        Error = GetLastError( );

        if (Error == ERROR_IO_PENDING) {

            DBGMSG(DBG_INFO, ("re-ConnectNamedPipe 0x%x IO pending\n", hPipe));
            bIOPending = TRUE;

        } else {

            DBGMSG(DBG_ERROR, ("re-ConnectNamedPipe 0x%x failed. Error %d\n",
                               hPipe,
                               Error));
        }
    } else {

        DBGMSG(DBG_INFO, ("re-ConnectNamedPipe successful 0x%x\n", hPipe));
    }
    return bIOPending;
}


BOOL
RedirectionThread(
    PREDIRECT_INFO  pRedirectInfo
    )
/*++
    Redirection thread is responsible for freeing pRedirectInfo. Since
    the ref count on port thread is incremented before this is called we
    know that the IniPort will be valid till we decrement the ref count.

    We are also passed the event we should wait to die on.
    This is pIniPort->hEvent. But redirection thread should use the local
    copy passed and not the one in pIniPort. The reason is there could be a
    lag from the time this event is set and the redirection dies. In the
    meantime a new rediction thread could be spun off and in which case the
    pIniPort->hEvent will not be for this thread

    When redirection thread is told to die:
        a. it should decrement the ref count on the pIniPort object when it is
           done with it's reference to pIniPort
        b. it should call CloseHandle on pRedirectInfo->hEvent
--*/
{
    WCHAR   szPipeName[MAX_PATH];
    HANDLE  hPipe[NUMBER_OF_PIPE_INSTANCES];
    SECURITY_ATTRIBUTES SecurityAttributes;
    PSECURITY_ATTRIBUTES pSecurityAttributes;

    //
    // One extra event for our trigger (pIniPort->hEvent)
    //
    HANDLE          ahEvent[NUMBER_OF_PIPE_INSTANCES+1];
    BOOL            abReconnect[NUMBER_OF_PIPE_INSTANCES];
    OVERLAPPED      Overlapped[NUMBER_OF_PIPE_INSTANCES];
    DWORD           WaitResult, i, j, Error, dwThreadId;
    PTRANSMISSION   pTransmission;
    HANDLE          hThread;
    BOOL            bTerminate = FALSE;
    LPWSTR          pszNewDeviceName = NULL;
    WCHAR           DosDeviceName[MAX_PATH];

    SecurityAttributes.lpSecurityDescriptor = NULL;

    //
    // Setup the redirection.
    //
    if ( !(pszNewDeviceName = SetupDosDev(pRedirectInfo->pIniPort,
                                          szPipeName,
                                          COUNTOF(szPipeName),
                                          &SecurityAttributes,
                                          &pSecurityAttributes)) ) {

        EnterSplSem();
        FreeRedirectInfo(pRedirectInfo);
        LeaveSplSem();

        return FALSE;
    }

    //
    // Initialization
    //
    for (i = 0; i < NUMBER_OF_PIPE_INSTANCES; i++) {

        hPipe[i] = INVALID_HANDLE_VALUE;
        Overlapped[i].hEvent = ahEvent[i] = NULL;
    }

    //
    // Put the event in the extra member of the event array.
    //
    ahEvent[NUMBER_OF_PIPE_INSTANCES] = pRedirectInfo->hEvent;

    //
    // Create several instances of a named pipe, create an event for each,
    // and connect to wait for a client:
    //
    for (i = 0; i < NUMBER_OF_PIPE_INSTANCES; i++) {

        abReconnect[i] = FALSE;

        hPipe[i] = CreateNamedPipe(szPipeName,
                                   PIPE_ACCESS_DUPLEX |
                                       FILE_FLAG_OVERLAPPED,
                                   PIPE_WAIT |
                                       PIPE_READMODE_BYTE |
                                       PIPE_TYPE_BYTE,
                                   PIPE_UNLIMITED_INSTANCES,
                                   4096,
                                   64*1024,   // 64k
                                   0,
                                   pSecurityAttributes);

        if ( hPipe[i] == INVALID_HANDLE_VALUE ) {

            DBGMSG(DBG_ERROR, ("CreateNamedPipe failed for %ws. Error %d\n",
                               szPipeName, GetLastError()));
            goto Cleanup;
        }

        ahEvent[i] = Overlapped[i].hEvent = CreateEvent(NULL,
                                                       FALSE,
                                                       FALSE,
                                                       NULL);

        if (!ahEvent[i]) {

            DBGMSG(DBG_ERROR, ("CreateEvent failed. Error %d\n",
                               GetLastError()));
            goto Cleanup;
        }

        if (!ConnectNamedPipe(hPipe[i], &Overlapped[i])){

            Error = GetLastError();

            if (Error == ERROR_IO_PENDING) {

                DBGMSG(DBG_INFO, ("ConnectNamedPipe %d, IO pending\n",
                                  i));

            } else {

                DBGMSG(DBG_ERROR, ("ConnectNamedPipe failed. Error %d\n",
                                   GetLastError()));

                goto Cleanup;
            }
        }
    }

    while (TRUE) {

        DBGMSG(DBG_INFO, ("Waiting to connect...\n"));

        WaitResult = WaitForMultipleObjectsEx(NUMBER_OF_PIPE_INSTANCES + 1,
                                              ahEvent,
                                              FALSE,
                                              INFINITE,
                                              TRUE);

        DBGMSG(DBG_INFO, ("WaitForMultipleObjectsEx returned %d\n",
                          WaitResult));

        if ((WaitResult >= NUMBER_OF_PIPE_INSTANCES)
            && (WaitResult != WAIT_IO_COMPLETION)) {

            DBGMSG(DBG_INFO, ("WaitForMultipleObjects returned %d; Last error = %d\n",
                              WaitResult,
                              GetLastError( ) ) );

            //
            // We need to terminate. But wait for any read thread that is spun
            // off by this redirection thread
            //
            for ( i = 0 ; i < NUMBER_OF_PIPE_INSTANCES ; ++i )
                if ( abReconnect[i] ) {

                    bTerminate = TRUE;
                    break; // the for loop
                }

            if ( i < NUMBER_OF_PIPE_INSTANCES )
                continue; // for the while loop
            else
                goto Cleanup;
        }

        i = WaitResult;

        //
        // If disco and reconnect was pending, do it again here.
        //
        if (abReconnect[i]) {

            abReconnect[i] = FALSE;

            //
            // If redirection thread has been told to quit check for termination
            //
            if ( bTerminate ) {

                for ( j = 0 ; j < NUMBER_OF_PIPE_INSTANCES ; ++j )
                    if ( abReconnect[j] )
                        break; // the for loop

                if ( j < NUMBER_OF_PIPE_INSTANCES )
                    continue; // for while loop
                else
                    goto Cleanup;
            } else {

                ReconnectNamedPipe(hPipe[i], &Overlapped[i]);
                continue;
            }

        }

        //
        // If we have been told to terminate do not spin a read thread
        //
        if ( bTerminate )
            continue;

        //
        // Set up the transmission structure with the handles etc. needed by
        // the completion callback routine:
        //
        pTransmission = (PTRANSMISSION)AllocSplMem(sizeof(TRANSMISSION));

        if (pTransmission) {

            pTransmission->hPipe        = hPipe[i];
            pTransmission->pOverlapped  = &Overlapped[i];
            pTransmission->hPrinter     = NULL;
            pTransmission->pIniPort     = pRedirectInfo->pIniPort;
            abReconnect[i]              = TRUE;

            hThread = CreateThread(NULL,
                                   INITIAL_STACK_COMMIT,
                                   (LPTHREAD_START_ROUTINE)ReadThread,
                                   pTransmission,
                                   0,
                                   &dwThreadId);

            if (hThread) {

                CloseHandle(hThread);
            } else {

                abReconnect[i] = FALSE;
                FreeSplMem(pTransmission);
                DBGMSG(DBG_WARN, ("CreateThread failed. Error %d\n",
                                   GetLastError()));
            }

        } else {

            DBGMSG(DBG_WARN, ("Alloc failed. Error %d\n",
                               GetLastError()));
        }
    }

Cleanup:

    if ( pszNewDeviceName ) {

        wcscpy(DosDeviceName, pRedirectInfo->pIniPort->pName);
        RemoveColon(DosDeviceName);

        DefineDosDevice(DDD_REMOVE_DEFINITION |
                            DDD_EXACT_MATCH_ON_REMOVE |
                            DDD_RAW_TARGET_PATH,
                        DosDeviceName,
                        pszNewDeviceName);

        FreeSplStr(pszNewDeviceName);
    }

    EnterSplSem();
    FreeRedirectInfo(pRedirectInfo);
    LeaveSplSem();


    for (i = 0; i < NUMBER_OF_PIPE_INSTANCES; i++) {

        if ( hPipe[i] != INVALID_HANDLE_VALUE ) {

            CloseHandle(hPipe[i]);
            hPipe[i]    = INVALID_HANDLE_VALUE;
        }
        if ( ahEvent[i] ) {

            CloseHandle(ahEvent[i]);
            ahEvent[i]  = NULL;
            Overlapped[i].hEvent = NULL;
        }
    }

    if (SecurityAttributes.lpSecurityDescriptor)
        DestroyPrivateObjectSecurity(&SecurityAttributes.lpSecurityDescriptor);

    return TRUE;
}


BOOL
CreateRedirectionThread(
   PINIPORT pIniPort)
{
    HANDLE hThread;
    DWORD  dwThreadId;
    PREDIRECT_INFO  pRedirectInfo = NULL;

    SplInSem();
    SPLASSERT(pIniPort->hEvent == NULL);

    //
    // Create redirection thread only once and only for LPT and COM ports
    //
    if ( !IsPortType(pIniPort->pName, szLPT) &&
         !IsPortType(pIniPort->pName, szCOM) ) {

        return TRUE;
    }

    pIniPort->hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    pRedirectInfo       = (PREDIRECT_INFO)  AllocSplMem(sizeof(REDIRECT_INFO));

    if ( !pIniPort->hEvent || !pRedirectInfo ) {

        FreeSplMem(pRedirectInfo);
        if ( pIniPort->hEvent ) {

            CloseHandle(pIniPort->hEvent);
            pIniPort->hEvent = NULL;
        }
        return FALSE;
    }

    INCPORTREF(pIniPort);
    pRedirectInfo->pIniPort = pIniPort;
    pRedirectInfo->hEvent   = pIniPort->hEvent;

    hThread = CreateThread(NULL,
                           INITIAL_STACK_COMMIT,
                           (LPTHREAD_START_ROUTINE)RedirectionThread,
                           pRedirectInfo,
                           0,
                           &dwThreadId);

    if (hThread) {

        CloseHandle(hThread);

    } else {

        pIniPort->hEvent = NULL;
        FreeRedirectInfo(pRedirectInfo);

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\mapsd.c ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation

Module Name:

    mapsd.c

Abstract:

    Mapping Security Descriptors


Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/

#include <precomp.h>

// Object types
//


extern GENERIC_MAPPING GenericMapping[];

PSECURITY_DESCRIPTOR
MapPrinterSDToShareSD(
    PSECURITY_DESCRIPTOR pPrinterSD
    );

BOOL
ProcessSecurityDescriptorDacl(
    PSECURITY_DESCRIPTOR pSourceSD,
    PACL   *ppDacl,
    LPBOOL  pDefaulted
    );

DWORD
MapPrinterMaskToShareMask(
    DWORD PrinterMask
    );

PSECURITY_DESCRIPTOR
MapPrinterSDToShareSD(
    PSECURITY_DESCRIPTOR pPrinterSD
    )
{
    SECURITY_DESCRIPTOR AbsoluteSD;
    PSECURITY_DESCRIPTOR pRelative;
    BOOL Defaulted = FALSE;
    PSID pOwnerSid = NULL;
    PSID pGroupSid = NULL;
    PACL pDacl = NULL;
    BOOL ErrorOccurred = FALSE;
    DWORD   SDLength = 0;
    

    if (!IsValidSecurityDescriptor(pPrinterSD)) {
        return(NULL);
    }
    if (!InitializeSecurityDescriptor (&AbsoluteSD ,SECURITY_DESCRIPTOR_REVISION1)) {
        return(NULL);
    }

    if(GetSecurityDescriptorOwner( pPrinterSD,
                                    &pOwnerSid, &Defaulted ) )
        SetSecurityDescriptorOwner( &AbsoluteSD,
                                    pOwnerSid, Defaulted );
    else
        ErrorOccurred = TRUE;

    if( GetSecurityDescriptorGroup( pPrinterSD,
                                    &pGroupSid, &Defaulted ) )
        SetSecurityDescriptorGroup( &AbsoluteSD,
                                    pGroupSid, Defaulted );
    else
        ErrorOccurred = TRUE;

    if (ProcessSecurityDescriptorDacl(pPrinterSD, &pDacl, &Defaulted)) {
        (VOID)SetSecurityDescriptorDacl (&AbsoluteSD, TRUE, pDacl, FALSE );
    }
    else
        ErrorOccurred = TRUE;

    if (ErrorOccurred) {
        if (pDacl) {
            LocalFree(pDacl);
        }
        return(NULL);
    }


    SDLength = GetSecurityDescriptorLength( &AbsoluteSD);
    pRelative = LocalAlloc(LPTR, SDLength);
    if (!pRelative) {
        LocalFree(pDacl);
        return(NULL);
    }
    if (!MakeSelfRelativeSD (&AbsoluteSD, pRelative, &SDLength)) {
        LocalFree(pRelative);
        LocalFree(pDacl);
        return(NULL);
    }
    LocalFree(pDacl);
    return(pRelative);
}

BOOL
ProcessSecurityDescriptorDacl(
    PSECURITY_DESCRIPTOR pSourceSD,
    PACL   *ppDacl,
    LPBOOL  pDefaulted
    )

{
    BOOL                DaclPresent     = FALSE;
    BOOL                bRet            = FALSE;
    DWORD               DestAceCount    = 0;
    DWORD               DaclLength      = 0;
    PACL                TmpAcl          = NULL;
    PACL                pDacl           = NULL;
    PSID                *ppSid          = NULL;
    ACCESS_MASK         *pAccessMask    = NULL;
    BYTE                *pInheritFlags  = NULL;
    UCHAR               *pAceType       = NULL;
    PACCESS_ALLOWED_ACE pAce            = NULL;
    DWORD               dwLengthSid     = 0;
    PSID                pSourceSid      = NULL;
    PSID                pDestSid        = NULL;
    DWORD               i               = 0;
    PACCESS_ALLOWED_ACE TmpAce          = NULL;       
    ACL_SIZE_INFORMATION AclSizeInfo;


    *ppDacl = NULL;

    bRet = GetSecurityDescriptorDacl( pSourceSD, &DaclPresent, &pDacl, pDefaulted );

    if (bRet) {

        bRet = DaclPresent; 
    }

    if (bRet) {

        GetAclInformation(pDacl, &AclSizeInfo,  sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

        ppSid = LocalAlloc(LPTR, sizeof(PSID)* AclSizeInfo.AceCount);
        pAccessMask = LocalAlloc(LPTR, sizeof(ACCESS_MASK)* AclSizeInfo.AceCount);
        pInheritFlags = LocalAlloc(LPTR, sizeof(BYTE)*AclSizeInfo.AceCount);
        pAceType = LocalAlloc(LPTR, sizeof(UCHAR)*AclSizeInfo.AceCount);

        bRet = ppSid && pAccessMask && pInheritFlags && pAceType;
    }

    for (i = 0 ; bRet && i < AclSizeInfo.AceCount; i++) {
         GetAce(pDacl, i, (LPVOID *)&pAce);
         //
         // Skip the Ace if it is inherit only
         //
         if ( ((PACE_HEADER)pAce)->AceFlags & INHERIT_ONLY_ACE ) {
             continue;
         }

         *(pAceType + DestAceCount) = ((PACE_HEADER)pAce)->AceType;
         *(pAccessMask + DestAceCount) = MapPrinterMaskToShareMask(((PACCESS_ALLOWED_ACE)pAce)->Mask);
         *(pInheritFlags + DestAceCount) =  ((PACE_HEADER)pAce)->AceFlags;
         //
         // Copy the sid information
         //
         pSourceSid = (PSID)(&(((PACCESS_ALLOWED_ACE)pAce)->SidStart));
         dwLengthSid = GetLengthSid(pSourceSid);
         pDestSid = (LPBYTE)LocalAlloc(LPTR, dwLengthSid);

         if (pDestSid) {

             CopySid(dwLengthSid, pDestSid, pSourceSid);

             *(ppSid + DestAceCount) = pDestSid;

         } else {
                    
             //
             // We failed to allocate the memory, we signal that we failed and 
             // fall down to the cleanup code below.
             // 
             bRet = FALSE;

             break;
         }

         DestAceCount++;
    }

    //
    // Compute size of the Dacl
    //
    if (bRet) {

        DaclLength = (DWORD)sizeof(ACL);
        for (i = 0; i < DestAceCount; i++) {

            DaclLength += GetLengthSid( *(ppSid + i)) +
                          (DWORD)sizeof(ACCESS_ALLOWED_ACE) -
                          (DWORD)sizeof(DWORD);  //Subtract out SidStart field length
        }

        TmpAcl = LocalAlloc(LPTR, DaclLength);

        bRet = (TmpAcl != NULL);
    }

    if (bRet) {
        
        bRet = InitializeAcl(TmpAcl, DaclLength, ACL_REVISION2);
    }

    for (i = 0; bRet && i < DestAceCount; i++) {
        if( *(pAceType +i) == ACCESS_ALLOWED_ACE_TYPE )
            (VOID)AddAccessAllowedAce ( TmpAcl, ACL_REVISION2, *(pAccessMask + i), *(ppSid + i));
        else
            (VOID)AddAccessDeniedAce ( TmpAcl, ACL_REVISION2, *(pAccessMask + i), *(ppSid + i));
        if (*(pInheritFlags + i) != 0) {
            (VOID)GetAce( TmpAcl, i, (LPVOID *)&TmpAce );
            TmpAce->Header.AceFlags = *(pInheritFlags + i);
        }
    }

    //
    // Write the Dacl back from the TmpAcl.
    // 
    if (bRet) {

        *ppDacl = TmpAcl;

        TmpAcl = NULL;
    }

    //
    // Free all of our temporary space.
    //
    if (ppSid) {

        for (i = 0; i < DestAceCount; i++) {
            LocalFree(*(ppSid + i));
        }

        LocalFree(ppSid);
    }

    if (pAccessMask) {

        LocalFree(pAccessMask);
    }
    
    if (pInheritFlags) {

        LocalFree(pInheritFlags);
    }
    
    if (pAceType) {

        LocalFree(pAceType);
    }

    if (TmpAcl) {

        LocalFree(TmpAcl);
    }
        
    return bRet;
}

DWORD
MapPrinterMaskToShareMask(
    DWORD PrinterMask
    )
{
    DWORD   ReturnMask = 0;

    MapGenericMask(&PrinterMask, &GenericMapping[SPOOLER_OBJECT_PRINTER]);

    if ((PrinterMask & PRINTER_ACCESS_ADMINISTER)
        || (PrinterMask & PRINTER_ACCESS_USE)) {
        ReturnMask |= GENERIC_ALL;
    }
    return(ReturnMask);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\openprn.c ===
/*++

Copyright (c) 1990 - 1996  Microsoft Corporation

Module Name:

    openprn.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    management for the Local Print Providor

    LocalOpenPrinter
    SplClosePrinter

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Matthew A Felton (mattfe) June 1994 RapidPrint
    Jan 95 Cleanup CreatePrinterHandle

--*/
#define NOMINMAX
#include <precomp.h>
#include "jobid.h"
#include "filepool.hxx"

#define SZXCVPORT       L"XcvPort "
#define SZXCVMONITOR    L"XcvMonitor "

LPCTSTR pszLocalOnlyToken = L"LocalOnly";
LPCTSTR pszLocalsplOnlyToken = L"LocalsplOnly";


HANDLE
CreatePrinterHandle(
    LPWSTR      pPrinterName,
    LPWSTR      pFullMachineName,
    PINIPRINTER pIniPrinter,
    PINIPORT    pIniPort,
    PINIPORT    pIniNetPort,
    PINIJOB     pIniJob,
    DWORD       TypeofHandle,
    HANDLE      hPort,
    PPRINTER_DEFAULTS pDefaults,
    PINISPOOLER pIniSpooler,
    DWORD       DesiredAccess,
    LPBYTE      pSplClientInfo,
    DWORD       dwLevel,
    HANDLE      hReadFile
    )
{
    PSPOOL              pSpool = NULL;
    BOOL                bStatus = FALSE;
    HANDLE              hReturnHandle = NULL;
    LPDEVMODE           pDevMode = NULL;
    PSPLCLIENT_INFO_1   pSplClientInfo1 = (PSPLCLIENT_INFO_1)pSplClientInfo;
    DWORD               ObjectType;

    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );

    if ( dwLevel && ( dwLevel != 1 || !pSplClientInfo) ) {

        DBGMSG(DBG_ERROR,
               ("CreatePrintHandle: Invalid client info %x - %d\n",
                pSplClientInfo, dwLevel));
        pSplClientInfo = NULL;
    }

 try {

    pSpool = (PSPOOL)AllocSplMem( SPOOL_SIZE );

    if ( pSpool == NULL ) {
        DBGMSG( DBG_WARNING, ("CreatePrinterHandle failed to allocate SPOOL %d\n", GetLastError() ));
        leave;
    }

    pSpool->signature = SJ_SIGNATURE;
    pSpool->pIniPrinter = pIniPrinter;
    pSpool->hReadFile = hReadFile;

    pSpool->pIniPort            = pIniPort;
    pSpool->pIniNetPort         = pIniNetPort;
    pSpool->pIniJob             = pIniJob;
    pSpool->TypeofHandle        = TypeofHandle;
    pSpool->hPort               = hPort;
    pSpool->Status              = 0;
    pSpool->pDevMode            = NULL;
    pSpool->pName               = AllocSplStr( pPrinterName );
    pSpool->pFullMachineName    = AllocSplStr( pFullMachineName );
    pSpool->pSplMapView         = NULL;
    pSpool->pMappedJob          = NULL;

    if ( pSpool->pName == NULL ||
         ( pFullMachineName && !pSpool->pFullMachineName )) {

        leave;
    }

    pSpool->pIniSpooler = pIniSpooler;

#ifdef _HYDRA_
    pSpool->SessionId = GetClientSessionId();
#endif

    //
    // Check if it's a local call.
    //
    if( TypeofHandle & PRINTER_HANDLE_REMOTE_CALL ) {

        //
        // We get other useful info like build #, client architecture
        // we do not need this info now -- so we do not put it in PSPOOL
        //
        if ( !pSplClientInfo ) {

            if ( IsNamedPipeRpcCall() )
                TypeofHandle |= PRINTER_HANDLE_3XCLIENT;
        } else if ( dwLevel == 1 ) {
            SPLASSERT(pSplClientInfo1->pUserName && pSplClientInfo1->pMachineName);
            CopyMemory(&pSpool->SplClientInfo1,
                       pSplClientInfo1,
                       sizeof(SPLCLIENT_INFO_1));

            pSpool->SplClientInfo1.pUserName = AllocSplStr(pSplClientInfo1->pUserName);
            pSpool->SplClientInfo1.pMachineName = AllocSplStr(pSplClientInfo1->pMachineName);
            if ( !pSpool->SplClientInfo1.pUserName ||
                 !pSpool->SplClientInfo1.pMachineName ) {

                DBGMSG(DBG_WARNING, ("CreatePrinterHandle: could not allocate memory for user name or machine name\n"));
            }
        }
    }

    if ((TypeofHandle & PRINTER_HANDLE_SERVER) ||
        (TypeofHandle & PRINTER_HANDLE_XCV_PORT)) {

        bStatus = ValidateObjectAccess( SPOOLER_OBJECT_SERVER,
                                        DesiredAccess,
                                        pSpool,
                                        &pSpool->GrantedAccess,
                                        pIniSpooler );

        if ( bStatus                                            &&
             (TypeofHandle & PRINTER_HANDLE_REMOTE_CALL)        &&
             ( (DesiredAccess & SERVER_ACCESS_ADMINISTER)       &&
               ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                                    SERVER_ACCESS_ADMINISTER,
                                    NULL,
                                    NULL,
                                    pIniSpooler)) ){
            pSpool->TypeofHandle |= PRINTER_HANDLE_REMOTE_ADMIN;
        }

        ObjectType = SPOOLER_OBJECT_SERVER;

    } else if( TypeofHandle & PRINTER_HANDLE_JOB ){

        bStatus = ValidateObjectAccess( SPOOLER_OBJECT_DOCUMENT,
                                        DesiredAccess,
                                        pSpool->pIniJob,
                                        &pSpool->GrantedAccess,
                                        pIniSpooler );

        ObjectType = SPOOLER_OBJECT_DOCUMENT;

    } else {

        bStatus = ValidateObjectAccess( SPOOLER_OBJECT_PRINTER,
                                        DesiredAccess,
                                        pSpool,
                                        &pSpool->GrantedAccess,
                                        pIniSpooler );

        ObjectType = SPOOLER_OBJECT_PRINTER;
    }

    MapGenericToSpecificAccess( ObjectType,
                                pSpool->GrantedAccess,
                                &pSpool->GrantedAccess);

    if ( !bStatus ) {

        SetLastError(ERROR_ACCESS_DENIED);
        leave;
    }

    if ( pIniPrinter ) {

        if ( pDefaults ) {

            //
            // Allocate DevMode
            //


            if ( pDefaults->pDevMode ) {

                pDevMode = pDefaults->pDevMode;

            } else {

                pDevMode = pIniPrinter->pDevMode;
            }

            if ( pDevMode != NULL  ) {

                pSpool->pDevMode = AllocSplMem( pDevMode->dmSize + pDevMode->dmDriverExtra );

                if ( pSpool->pDevMode == NULL ) {

                    DBGMSG(DBG_WARNING, ("CreatePrinterHandle failed allocation for devmode %d\n", GetLastError() ));
                    leave;
                }
                memcpy( pSpool->pDevMode, pDevMode, pDevMode->dmSize + pDevMode->dmDriverExtra );
            }
        }

        //
        //  Allocate Datype and Print Processor
        //

        if ( pDefaults && pDefaults->pDatatype ) {

                pSpool->pDatatype = AllocSplStr( pDefaults->pDatatype );
                pSpool->pIniPrintProc = FindDatatype( pIniPrinter->pIniPrintProc, pSpool->pDatatype );

        } else {

            pSpool->pDatatype = AllocSplStr( pIniPrinter->pDatatype );
            pSpool->pIniPrintProc = pIniPrinter->pIniPrintProc;
        }


        if ( pSpool->pIniPrintProc == NULL ) {
            DBGMSG( DBG_WARNING,("CreatePrinterHandle failed to PrintProcessor for datatype %ws %d\n",
                    pSpool->pDatatype, GetLastError() ));
            SetLastError( ERROR_INVALID_DATATYPE );
            leave;
        }

        SPLASSERT( pSpool->pIniPrintProc->signature == IPP_SIGNATURE );

        pSpool->pIniPrintProc->cRef++;

        if ( pSpool->pDatatype == NULL ) {
            DBGMSG( DBG_WARNING,("CreatePrinterHandle failed to allocate DataType %x\n", GetLastError() ));
            SetLastError( ERROR_INVALID_DATATYPE );
            leave;
        }

    }

    // Add us to the linked list of handles for this printer.
    // This will be scanned when a change occurs on the printer,
    // and will be updated with a flag indicating what type of
    // change it was.
    // There is a flag for each handle, because we cannot guarantee
    // that all threads will have time to reference a flag in the
    // INIPRINTER before it is updated.

    if ( TypeofHandle & PRINTER_HANDLE_PRINTER ) {

        pSpool->pNext = pSpool->pIniPrinter->pSpool;
        pSpool->pIniPrinter->pSpool = pSpool;

    } else if ( (TypeofHandle & PRINTER_HANDLE_SERVER) ||
                (TypeofHandle & PRINTER_HANDLE_XCV_PORT) ) {

        //
        // For server handles, hang them off the global IniSpooler:
        //

        pSpool->pNext = pIniSpooler->pSpool;
        pIniSpooler->pSpool = pSpool;

        INCSPOOLERREF( pIniSpooler );

    } else if( TypeofHandle & PRINTER_HANDLE_JOB ){

        INCJOBREF( pIniJob );
    }

    //  Note Only PRINTER_HANDLE_PRINTER are attatched to the
    //  pIniPrinter, since those are the handle which will require
    //  change notifications.

    if ( pSpool->pIniPrinter != NULL ) {

        INCPRINTERREF( pSpool->pIniPrinter );
    }

    hReturnHandle = (HANDLE)pSpool;

 } finally {

    if ( hReturnHandle == NULL ) {

        // Failure CleanUP

        if ( pSpool != NULL ) {

            FreeSplStr(pSpool->SplClientInfo1.pUserName);
            FreeSplStr(pSpool->SplClientInfo1.pMachineName);
            FreeSplStr( pSpool->pName ) ;
            FreeSplStr( pSpool->pDatatype );
            FreeSplStr(pSpool->pFullMachineName);

            if ( pSpool->pIniPrintProc != NULL )
                pSpool->pIniPrintProc->cRef--;

            if ( pSpool->pDevMode )
                FreeSplMem( pSpool->pDevMode );

            FreeSplMem( pSpool );
            pSpool = NULL;

        }
    }
}
    return hReturnHandle;
}



BOOL
DeletePrinterHandle(
    PSPOOL  pSpool
    )
{

    BOOL bRet = FALSE;

    SplInSem();

    if (pSpool->pIniPrintProc) {
        pSpool->pIniPrintProc->cRef--;
    }

    if (pSpool->pDevMode)
        FreeSplMem(pSpool->pDevMode);

    FreeSplStr(pSpool->SplClientInfo1.pUserName);
    FreeSplStr(pSpool->SplClientInfo1.pMachineName);
    FreeSplStr(pSpool->pDatatype);

    SetSpoolClosingChange(pSpool);

    FreeSplStr(pSpool->pName);
    FreeSplStr(pSpool->pFullMachineName);

    bRet = ObjectCloseAuditAlarm( szSpooler, pSpool, pSpool->GenerateOnClose );

    //
    // If there is a WaitForPrinterChange outstanding, we can't free
    // the pSpool, since we may try and reference it.
    //

    // Log warning for freed printer handle
    DBGMSG(DBG_TRACE, ("DeletePrinterHandle 0x%x", pSpool));

    if (pSpool->ChangeEvent) {

        pSpool->eStatus |= STATUS_PENDING_DELETION;

    } else {

        FreeSplMem(pSpool);
    }

    return TRUE;
}


DWORD
CreateServerHandle(
    LPWSTR   pPrinterName,
    LPHANDLE pPrinterHandle,
    LPPRINTER_DEFAULTS pDefaults,
    PINISPOOLER pIniSpooler,
    DWORD   dwTypeofHandle
)
{
    DWORD DesiredAccess;
    DWORD ReturnValue = ROUTER_STOP_ROUTING;

    DBGMSG(DBG_TRACE, ("OpenPrinter(%ws)\n",
                       pPrinterName ? pPrinterName : L"NULL"));

    EnterSplSem();

    if (!pDefaults || !pDefaults->DesiredAccess)
        DesiredAccess = SERVER_READ;
    else
        DesiredAccess = pDefaults->DesiredAccess;

    if (*pPrinterHandle = CreatePrinterHandle( pIniSpooler->pMachineName,
                                               pPrinterName,
                                               NULL, NULL, NULL, NULL,
                                               dwTypeofHandle,
                                               NULL,
                                               pDefaults,
                                               pIniSpooler,
                                               DesiredAccess,
                                               NULL,
                                               0,
                                               INVALID_HANDLE_VALUE )){
        ReturnValue = ROUTER_SUCCESS;

    }
    LeaveSplSem();

    DBGMSG(DBG_TRACE, ("OpenPrinter returned handle %08x\n", *pPrinterHandle));

    return ReturnValue;
}


PINIPRINTER
FindPrinterShare(
   LPCWSTR pszShareName,
   PINISPOOLER pIniSpooler
   )

/*++

Routine Description:

    Try and find the share name in our list of printers.

    Note: Even if the printer isn't shared, we still return a match.

    The caching code will work because it explicitly turns off
    the PRINTER_ATTRIBUTE_SHARE bit so that the cache pIniSpooler
    doesn't create a server thread or call NetShareAdd/Del.

    In the future, consider changing this to check the share bit.
    Create a new bit SPL_SHARE_PRINTERS that indicates whether sharing
    housekeeping should be done.

Arguments:

    pszShareName - Name of share to search for.

Return Value:

    PINIPRINTER Printer that has the share name, NULL if no printer.

--*/
{
    PINIPRINTER pIniPrinter;

    SplInSem();

    if (pszShareName && pszShareName[0]) {

        for( pIniPrinter = pIniSpooler->pIniPrinter;
             pIniPrinter;
             pIniPrinter = pIniPrinter->pNext ){

            if (pIniPrinter->pShareName                              &&
                !lstrcmpi(pIniPrinter->pShareName, pszShareName)) {

                return pIniPrinter;
            }
        }
    }
    return NULL;
}

PINISPOOLER
LocalFindSpoolerByNameIncRef(
    LPWSTR pszPrinterName,
    LPTSTR *ppszLocalName OPTIONAL
    )

/*++

Routine Description:

    See if the printer is owned by localspl.  This is a special
    case to check if it's a masquarading printer.

    Normally we would check for \\Server\Printer to see if \\Server
    is our machine, but we have to look for \\MasqServer\Printer
    too.

Arguments:

    pPrinterName - Name to check.

    ppszLocalName - Returns pointer to local name.  OPTIONAL

Return Value:

    PINISPOOLER - Spooler match.
    NULL - No match.

--*/

{
    PINISPOOLER pIniSpooler;
    LPWSTR      pTemp;

    if (!ppszLocalName)
        ppszLocalName = &pTemp;

    EnterSplSem();

    pIniSpooler = FindSpoolerByName( pszPrinterName,
                                     ppszLocalName );

    if( !pIniSpooler ){

        //
        // Check if it's a masq printer.
        //
        // If the local name isn't the same as the original name, it
        // is in the syntax "\\server\printer."  In this case it may
        // be a masq printer, so check if the printer exists in the
        // local spooler by this name.
        //
        if( *ppszLocalName != pszPrinterName ){

            //
            // Search for the printer, but remove any suffixes it
            // may have.
            //
            WCHAR string[MAX_UNC_PRINTER_NAME + PRINTER_NAME_SUFFIX_MAX];

            wcscpy(string, pszPrinterName);
            if( pTemp = wcschr( string, L',' )){
                *pTemp = 0;
            }

            if( FindPrinter( string, pLocalIniSpooler )){

                //
                // The masq printer exists.  The local name for this
                // masq printer is "\\MasqServer\Printer," so we must
                // reflect this change in ppszLocalName.  This will ensure
                // that the pIniPrinter is found.
                //
                *ppszLocalName = pszPrinterName;
                pIniSpooler = pLocalIniSpooler;
            }
        }
    }

    if( pIniSpooler ){
        INCSPOOLERREF( pIniSpooler );
    }

    LeaveSplSem();

    return pIniSpooler;
}


VOID
LocalFindSpoolerByNameDecRef(
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Matching call to LocalFindSpoolerByNameIncRef.

Arguments:

    pIniSpooler - Spooler to derement; can be NULL.

Return Value:

--*/

{
    EnterSplSem();

    if( pIniSpooler ){
        DECSPOOLERREF( pIniSpooler );
    }
    LeaveSplSem();
}


DWORD
LocalOpenPrinter(
    LPWSTR   pPrinterName,
    LPHANDLE pPrinterHandle,
    LPPRINTER_DEFAULTS pDefaults
    )
{
    return LocalOpenPrinterEx( pPrinterName,
                               pPrinterHandle,
                               pDefaults,
                               NULL,
                               0 );
}

DWORD
LocalOpenPrinterEx(
    LPWSTR              pPrinterName,
    LPHANDLE            pPrinterHandle,
    LPPRINTER_DEFAULTS  pDefaults,
    LPBYTE              pSplClientInfo,
    DWORD               dwLevel
    )
{
    DWORD dwReturn;
    LPWSTR pszLocalName;
    PINISPOOLER pIniSpooler = LocalFindSpoolerByNameIncRef( pPrinterName, 
                                                            &pszLocalName);
    
    //
    // WMI Trace Event.
    //
    LogWmiTraceEvent(0, EVENT_TRACE_TYPE_SPL_ENDTRACKTHREAD, NULL);

    if( !pIniSpooler ) {

        //
        // Check for PrinterName,LocalsplOnly.
        // If we see this token, then fail the call since
        // we only want to check localspl.
        //
        LPCTSTR pSecondPart;

        if( pSecondPart = wcschr( pPrinterName, L',' )){

            ++pSecondPart;

            if( wcscmp( pSecondPart, pszLocalsplOnlyToken ) == STRINGS_ARE_EQUAL ){
                SetLastError( ERROR_INVALID_PRINTER_NAME );
                return ROUTER_STOP_ROUTING;
            }
        }

        SetLastError( ERROR_INVALID_NAME );
        return ROUTER_UNKNOWN;
    }

    dwReturn = SplOpenPrinter( pPrinterName,
                               pPrinterHandle,
                               pDefaults,
                               pIniSpooler,
                               pSplClientInfo,
                               dwLevel);

    LocalFindSpoolerByNameDecRef( pIniSpooler );

    // 
    // We need to give other provider a chance to get the printer name
    //

#if 0
    //
    // If we didn't find a printer but we did find a pIniSpooler and
    // the printer name was a remote name (e.g., "\\localmachine\printer"),
    // then we should stop routing.  In this case, the local machine owns
    // the pIniSpooler, but it didn't find any printers.  Don't bother
    // checking the other providers.
    //
    // In theory, we should be able to quit for local printers too
    // (e.g., OpenPrinter( "UnknownPrinter", ... )), but if any other
    // provider expects to get this name, they no longer will.
    //

    if( dwReturn == ROUTER_UNKNOWN &&
        pszLocalName != pPrinterName ){

        dwReturn = ROUTER_STOP_ROUTING;
    }
#endif

    return dwReturn;
}

DWORD
OpenLocalPrinterName(
    LPCWSTR pPrinterName,
    PINISPOOLER pIniSpooler,
    PDWORD pTypeofHandle,
    PINIPRINTER* ppIniPrinter,
    PINIPORT* ppIniPort,
    PINIPORT* ppIniNetPort,
    PHANDLE phPort,
    PDWORD pOpenPortError,
    LPPRINTER_DEFAULTS pDefaults
    )
{
    PINIPRINTER pIniPrinter;
    PINIPORT pIniPort;
    PINIPORT pIniNetPort = NULL;
    BOOL bOpenPrinterPort;
    LPWSTR pDatatype;

    //
    // If the printer name is the name of a local printer:
    //
    //    Find the first port the printer's attached to.
    //
    //    If the port has a monitor (e.g. LPT1:, COM1 etc.),
    //       we're OK,
    //    Otherwise
    //       try to open the port - this may be a network printer
    //

    if( ( pIniPrinter = FindPrinter( pPrinterName, pIniSpooler )) ||
        ( pIniPrinter = FindPrinterShare( pPrinterName, pIniSpooler ))) {


        pIniPort = FindIniPortFromIniPrinter( pIniPrinter );

        if( pIniPort && ( pIniPort->Status & PP_MONITOR )){

            //
            // A Printer that has a Port with a Monitor is not a
            // DownLevel Connection (or LocalPrinter acting as a
            // remote printer - "Masquarade" case).
            //
            pIniPort = NULL;
        }

        pDatatype = (pDefaults && pDefaults->pDatatype) ?
                        pDefaults->pDatatype :
                        NULL;

        //
        // Validate datatypes for both masq and local.
        //
        if( pDatatype && !FindDatatype( NULL, pDatatype )){
            goto BadDatatype;
        }

        if( pIniPort ){

            //
            // DownLevel Connection Printer; save it in pIniNetPort.
            // SetPrinterPorts checks this value.
            //
            pIniNetPort = pIniPort;

            //
            // Validate datatype.  We only send RAW across the net
            // to masq printers.
            //
            if( pDatatype && !ValidRawDatatype( pDatatype )){
                goto BadDatatype;
            }

            //
            // There is a network port associated with this printer.
            // Make sure we can open it, and get the handle to use on
            // future API calls:
            //
            INCPRINTERREF(pIniPrinter);
            LeaveSplSem();
            bOpenPrinterPort = OpenPrinterPortW( pIniPort->pName, phPort, pDefaults );
            EnterSplSem();
            DECPRINTERREF(pIniPrinter);

            if( !bOpenPrinterPort ){

                *phPort = INVALID_PORT_HANDLE;
                *pOpenPortError = GetLastError();

                //
                // Must be non-zero otherwise it looks like success.
                //
                SPLASSERT( *pOpenPortError );

                if( *pOpenPortError == ERROR_INVALID_PASSWORD ) {

                    //
                    // This call should fail if it's because the password
                    // is invalid, then winspool or printman can prompt
                    // for the password.
                    //
                    DBGMSG(DBG_WARNING, ("OpenPrinterPort1( %ws ) failed with ERROR_INVALID_PASSWORD .  OpenPrinter returning FALSE\n", pIniPort->pName ));
                    return ROUTER_STOP_ROUTING;
                }

                DBGMSG(DBG_WARNING, ("OpenPrinterPort1( %ws ) failed: Error %d.  OpenPrinter returning TRUE\n", pIniPort->pName, *pOpenPortError));

            } else {
                //
                // Clear the placeholder bit from the pIniPort status. This 
                // belongs to a partial print provider.
                // 
                pIniPort->Status &= ~PP_PLACEHOLDER;                
            }

        } else {

            //
            // Not a masq case.  If it's direct, it must be raw.
            //
            // Note: we will use the default if no datatype is specified.
            // However, if the default datatype is non-RAW and the
            // printer is direct, the open will succeed using a
            // non-RAW datatype!
            //
            if(( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DIRECT ) &&
                pDatatype &&
                !ValidRawDatatype( pDatatype )) {

                goto BadDatatype;
            }
        }

        //
        // If this is a placeholder port, assume that it is a monitor port for now.
        // 
        if (pIniPort && pIniPort->Status & PP_PLACEHOLDER) {
            pIniPort    = NULL;
            pIniNetPort = NULL;
        }
        
        *pTypeofHandle |= ( pIniPort ?
                                PRINTER_HANDLE_PORT :
                                PRINTER_HANDLE_PRINTER );

        *ppIniPort = pIniPort;
        *ppIniNetPort = pIniNetPort;
        *ppIniPrinter = pIniPrinter;

        return ROUTER_SUCCESS;
    }

    SetLastError( ERROR_INVALID_NAME );
    return ROUTER_UNKNOWN;

BadDatatype:

    SetLastError( ERROR_INVALID_DATATYPE );
    return ROUTER_STOP_ROUTING;
}


DWORD
CheckPrinterTokens(
    LPCWSTR string,
    LPCWSTR pSecondPart,
    PDWORD pTypeofHandle,
    PINISPOOLER pIniSpooler,
    PINIPRINTER *ppIniPrinter,
    PINIPORT *ppIniPort,
    PINIPORT *ppIniNetPort,
    PHANDLE phPort,
    PDWORD  pOpenPortError,
    PPRINTER_DEFAULTS pDefaults
    )
{
    typedef enum {
        kNone = 0,
        kLocalOnly = 1,
        kLocalsplOnly = 2
    } ETOKEN_TYPE;

    ETOKEN_TYPE eTokenType = kNone;

    DWORD RouterReturnValue = ROUTER_UNKNOWN;

    //
    // LocalOnly
    //
    //     Do not call OpenPrinterPort--use local settings only.
    //     If not recognized by localspl, stop routing.
    //
    //     This is used during upgrade of a downlevel printer connection.
    //     The remote server may not be up, but we can return a print
    //     handle to the local printer.  Get/SetPrinterData calls will
    //     succeed (for upgrade purposes), but printing will fail.
    //
    // LocalsplOnly
    //
    //     Call OpenPrinterPort if necessary.
    //     Stop routing after localspl even if not found.
    //
    //     This is used when the system knows that the printer must exist
    //     on the local machine, and does not want to route further.
    //     This fixes the clustering problem when the server has a stale
    //     print share and successfully validates it against win32spl since
    //     it is cached.
    //

    if( wcsncmp( pSecondPart, pszLocalOnlyToken, wcslen(pszLocalOnlyToken) ) == STRINGS_ARE_EQUAL ){

        eTokenType = kLocalOnly;

    } else if( wcsncmp( pSecondPart, pszLocalsplOnlyToken, wcslen(pszLocalsplOnlyToken) ) == STRINGS_ARE_EQUAL ){

        eTokenType = kLocalsplOnly;
    }

    //
    // If we have a valid token, process it.
    //
    if( eTokenType != kNone ){

        switch( eTokenType ){
        case kLocalOnly:

            //
            // Find the printer associate with it.
            //
            *ppIniPrinter = FindPrinter( string, pIniSpooler );

            if( *ppIniPrinter ){
                *pTypeofHandle |= PRINTER_HANDLE_PRINTER;
                RouterReturnValue = ROUTER_SUCCESS;
            } else {
                RouterReturnValue = ROUTER_STOP_ROUTING;
            }

            break;

        case kLocalsplOnly:

            RouterReturnValue = OpenLocalPrinterName( string,
                                                      pIniSpooler,
                                                      pTypeofHandle,
                                                      ppIniPrinter,
                                                      ppIniPort,
                                                      ppIniNetPort,
                                                      phPort,
                                                      pOpenPortError,
                                                      pDefaults );

            *pTypeofHandle = *pTypeofHandle & (~PRINTER_HANDLE_REMOTE_CALL);

            if( RouterReturnValue == ROUTER_UNKNOWN ){
                RouterReturnValue = ROUTER_STOP_ROUTING;
            }
        }
    }

    DBGMSG( DBG_TRACE,
            ( "CheckPrinterTokens: %ws %d Requested %d %x\n",
              string, RouterReturnValue, *ppIniPrinter ));

    return RouterReturnValue;
}

DWORD
CheckPrinterPortToken(
    LPCWSTR string,
    LPCWSTR pSecondPart,
    PDWORD pTypeofHandle,
    PINIPRINTER* ppIniPrinter,
    PINIPORT* ppIniPort,
    PINIJOB* ppIniJob,
    const LPPRINTER_DEFAULTS pDefaults,
    const PINISPOOLER pIniSpooler
    )
{
    if( wcsncmp( pSecondPart, L"Port", 4 ) != STRINGS_ARE_EQUAL ||
        !( *ppIniPort = FindPort( string, pIniSpooler ))){

        return ROUTER_UNKNOWN;
    }

    //
    // The name is the name of a port:
    //
    if( pDefaults            &&
        pDefaults->pDatatype &&
        !ValidRawDatatype( pDefaults->pDatatype )) {

        SetLastError( ERROR_INVALID_DATATYPE );
        return ROUTER_STOP_ROUTING;
    }

    if ( *ppIniJob = (*ppIniPort)->pIniJob ) {

        *ppIniPrinter = (*ppIniJob)->pIniPrinter;
        *pTypeofHandle |= PRINTER_HANDLE_PORT;

    } else if( (*ppIniPort)->cPrinters ){

        //
        // There is no current job assigned to the port
        // So Open the First Printer Associated with
        // this port.
        //
        *ppIniPrinter = (*ppIniPort)->ppIniPrinter[0];
        *pTypeofHandle |= PRINTER_HANDLE_PRINTER;
    }
    return ROUTER_SUCCESS;
}


DWORD
CheckPrinterJobToken(
    LPCWSTR string,
    LPCWSTR pSecondPart,
    PDWORD pTypeofHandle,
    PINIPRINTER* ppIniPrinter,
    PINIJOB* ppIniJob,
    PHANDLE phReadFile,
    const PINISPOOLER pIniSpooler
    )
{
    HANDLE  hImpersonationToken;
    DWORD Position, dwShareMode, dwDesiredAccess;
    DWORD JobId;
    PINIPRINTER pIniPrinter;
    PINIJOB pIniJob, pCurrentIniJob;
    PWSTR  pszStr = NULL;

    if( wcsncmp( pSecondPart, L"Job ", 4 ) != STRINGS_ARE_EQUAL ||
        !( pIniPrinter = FindPrinter( string, pIniSpooler ))){

        return ROUTER_UNKNOWN;
    }

    //
    //  Get the Job ID ",Job xxxx"
    //
    pSecondPart += 4;

    JobId = Myatol( (LPWSTR)pSecondPart );

    pIniJob = FindJob( pIniPrinter, JobId, &Position );

    if( pIniJob == NULL ) {

        DBGMSG( DBG_WARN, ("OpenPrinter failed to find Job %d\n", JobId ));
        return ROUTER_UNKNOWN;
    }

    DBGMSG( DBG_TRACE, ("OpenPrinter: pIniJob->cRef = %d\n", pIniJob->cRef));

    if( pIniJob->Status & JOB_DIRECT ) {

        SplInSem();

        *pTypeofHandle |= PRINTER_HANDLE_JOB | PRINTER_HANDLE_DIRECT;
        goto Success;
    }

    //
    //  If this job is assigned to a port
    //  Then pick up the correct chained jobid file instead of the master
    //  JobId.
    //


    if ( pIniJob->pCurrentIniJob != NULL ) {

        SPLASSERT( pIniJob->pCurrentIniJob->signature == IJ_SIGNATURE );

        DBGMSG( DBG_TRACE,("CheckPrinterJobToken pIniJob %x JobId %d using chain JobId %d\n",
                pIniJob, pIniJob->JobId, pIniJob->pCurrentIniJob->JobId ));


        pCurrentIniJob = pIniJob->pCurrentIniJob;


        SPLASSERT( pCurrentIniJob->signature == IJ_SIGNATURE );

    } else {

        pCurrentIniJob = pIniJob;

    }

    if ( pCurrentIniJob->hFileItem != INVALID_HANDLE_VALUE )
    {
        LeaveSplSem();

        hImpersonationToken = RevertToPrinterSelf();
        
        GetReaderFromHandle(pCurrentIniJob->hFileItem, phReadFile);

        ImpersonatePrinterClient( hImpersonationToken );

        if ( *phReadFile && (*phReadFile != INVALID_HANDLE_VALUE))
        {
            GetNameFromHandle(pCurrentIniJob->hFileItem, &pszStr, TRUE);
            wcscpy((LPWSTR)string, pszStr);
            FreeSplStr(pszStr);

            EnterSplSem();
            
            *pTypeofHandle |= PRINTER_HANDLE_JOB;
            
            goto Success;
        }
        DBGMSG( DBG_WARN,("Filepools: Failed to get valid reader handle\n"));

        EnterSplSem();
    }
    else
    {
        GetFullNameFromId( pCurrentIniJob->pIniPrinter,
                       pCurrentIniJob->JobId,
                       TRUE,
                       (LPWSTR)string,
                       FALSE );
        
        //  Bug 54845
        //  Even a user without previledge can open a ", JOB #"
        //  if he is physically running on the machine.

        LeaveSplSem();

        hImpersonationToken = RevertToPrinterSelf();

        dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;

        if (pCurrentIniJob->Status & JOB_TYPE_OPTIMIZE) {
            dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;
        } else {
            dwDesiredAccess = GENERIC_READ;
        }

        *phReadFile = CreateFile(string,
                                 dwDesiredAccess,
                                 dwShareMode,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);

        ImpersonatePrinterClient( hImpersonationToken );
        
        EnterSplSem();

        if( *phReadFile != INVALID_HANDLE_VALUE ) {

            DBGMSG( DBG_TRACE,
                    (  "OpenPrinter JobID %d pIniJob %x CreateFile( %ws ), hReadFile %x success",
                       JobId, pIniJob, string, *phReadFile ));

            SplInSem();

            *pTypeofHandle |= PRINTER_HANDLE_JOB;
            goto Success;
        }
    }



    DBGMSG( DBG_WARNING,
            ( "LocalOpenPrinter CreateFile(%ws) GENERIC_READ failed : %d\n",
              string, GetLastError()));

    SPLASSERT( GetLastError( ));

    return ROUTER_STOP_ROUTING;

Success:

    *ppIniJob = pIniJob;
    *ppIniPrinter = pIniPrinter;
    return ROUTER_SUCCESS;
}


DWORD
CheckXcvPortToken(
    LPCWSTR pszSecondPart,
    PDWORD pTypeofHandle,
    const LPPRINTER_DEFAULTS pDefaults,
    const PINISPOOLER pIniSpooler,
    PHANDLE phXcv
    )
{

    DWORD dwRet = ROUTER_SUCCESS;
    DWORD dwType;
    PCWSTR pszPort;
    DWORD dwTypeofHandle = *pTypeofHandle;

    if (!wcsncmp(pszSecondPart, SZXCVPORT, COUNTOF(SZXCVPORT) - 1)) {
        dwType = XCVPORT;
        dwTypeofHandle |= PRINTER_HANDLE_XCV_PORT;
        pszPort = (PCWSTR) pszSecondPart + COUNTOF(SZXCVPORT) - 1;
    }
    else if (!wcsncmp(pszSecondPart, SZXCVMONITOR, COUNTOF(SZXCVMONITOR) - 1)) {
        dwType = XCVMONITOR;
        dwTypeofHandle |= PRINTER_HANDLE_XCV_PORT;
        pszPort = (PCWSTR) pszSecondPart + COUNTOF(SZXCVMONITOR) - 1;
    }
    else
        dwRet = ROUTER_UNKNOWN;

    if (dwRet == ROUTER_SUCCESS) {
        dwRet = XcvOpen(NULL,
                        pszPort,
                        dwType,
                        pDefaults,
                        phXcv,
                        pIniSpooler);

        if (dwRet == ROUTER_SUCCESS)
            *pTypeofHandle = dwTypeofHandle;
    }

    return dwRet;
}




DWORD
SplOpenPrinter(
    LPWSTR              pFullPrinterName,
    LPHANDLE            pPrinterHandle,
    LPPRINTER_DEFAULTS  pDefaults,
    PINISPOOLER         pIniSpooler,
    LPBYTE              pSplClientInfo,
    DWORD               dwLevel
    )

/*++

Routine Description:

    OpenPrinter can open any of the following by specifying a string
    in pPrinterName:-

        Server
            \\MachineName
            NULL

        Job
            PrinterName, Job xxxx

        Port
            PortName, Port

        XcvPort
            \\MachineName\,XcvPort Port
            ,XcvPort Port

        XcvMonitor
            \\MachineName\,XcvMonitor Monitor
            ,XcvMonitor Monitor

        Printer
            PrinterName
            ShareName
            \\MachineName\PrinterName
            \\MachineName\ShareName
            PrinterName, LocalOnly
            ShareName, LocalOnly
            PrinterName, LocalsplOnly
            ShareName, LocalsplOnly

        Note for Printer there are two Types
            1 - Regular LocalPrinter
            2 - DownLevel Connection Printer

        For type 2 a LocalPrinter exists ( pIniPrinter ) but its port
        does not have a monitor associated with it.   In this case
        we also open the port ( typically \\share\printer of a remote
        machine ) before we return success.

    GUI Applications usually use Server and Printer

    Type Job and Port are used by Print Processors:-

        A print processor will Open a Job then read the job using
        ReadPrinter.  A print processor will output to a Port by opening
        the PortName, Port and using WritePrinter.  Usually these strings
        "PrinterName, Job xxx" "PortName, Port" are passed to the print
        processor by the spooler and are currently not documented.   We
        do know that some OEMs have figured out the extentions and we
        might break someone if we change them.

    Type LocalOnlyToken is used by a Printer Driver:-

        Used when we need to upgrade a printer's settings from an older
        version of the driver to a newer one (see drvupgrd.c for details).
        This was added in NT 3.51.

    Type LocasplOnlyToken is used by server:-

        Indicates that we should check localspl only (local or masq).
        Other providers will not be called.

Arguments:

    pPrinterName   - PrinterName ( see above for different types of
                     PrinterName )
    pPrinterHandle - Address to put hPrinter on Success
    pDefaults      - Optional, allows user to specify Datatype,
                     DevMode, DesiredAccess.
    pIniSpooler    - This spooler "owns" the printer.  We will only check
                     against this spooler, and we assume that the callee
                     has already checked that "\\server\printer" lives
                     on this pIniSpooler (i.e., we are \\server).

    ( see SDK Online Help for full explanation )


Return Value:

    TRUE    - *pPrinterHandle will have a PrinterHandle
    FALSE   - use GetLastError

--*/

{
    PINIPRINTER pIniPrinter = NULL;
    PINIPORT    pIniPort = NULL;
    PINIPORT    pIniNetPort = NULL;
    DWORD       LastError = 0;
    LPWSTR      pPrinterName = pFullPrinterName;
    WCHAR       string[MAX_UNC_PRINTER_NAME + PRINTER_NAME_SUFFIX_MAX];
    PINIJOB     pIniJob = NULL;
    HANDLE      hReadFile = INVALID_HANDLE_VALUE;
    DWORD       TypeofHandle = 0;
    LPWSTR      pSecondPart = NULL;
    HANDLE      hPort = INVALID_PORT_HANDLE;
    DWORD       OpenPortError = NO_ERROR;
    BOOL        bRemoteUserPrinterNotShared = FALSE;
    DWORD       MachineNameLength;
    DWORD       RouterReturnValue = ROUTER_UNKNOWN;
    DWORD       DesiredAccess;
    LPTSTR      pcMark;
    BOOL        bRemoteNameRequest = FALSE;
    BOOL        bLocalCall         = FALSE;

#if DBG
    //
    // On DBG builds, force last error to zero so we can catch people
    // that don't set it when they should.
    //
    SetLastError( ERROR_SUCCESS );
#endif

    //
    // Reject "" - pointer to a NULL string.
    //
    if (pFullPrinterName && !pFullPrinterName[0]) {
        SetLastError(ERROR_INVALID_NAME);
        return ROUTER_UNKNOWN;
    }

    if (!pFullPrinterName) {
        return CreateServerHandle( pFullPrinterName,
                                   pPrinterHandle,
                                   pDefaults,
                                   pIniSpooler,
                                   PRINTER_HANDLE_SERVER );
    }

    if( pFullPrinterName[0] == TEXT( '\\' ) && pFullPrinterName[1] == TEXT( '\\' )) {

        wcscpy(string, pFullPrinterName);

        if(pcMark = wcschr(string + 2, TEXT( '\\' ))) {
            *pcMark = TEXT('\0');
        }

        if (MyName(string, pIniSpooler)) { // \\Server\Printer or \\Server

            if (!pcMark) {  // \\Server
                return CreateServerHandle( pFullPrinterName,
                                           pPrinterHandle,
                                           pDefaults,
                                           pIniSpooler,
                                           PRINTER_HANDLE_SERVER );
            }

            // Have \\Server\Printer, Set pPrinterName = Printer
            pPrinterName = pFullPrinterName + (pcMark - string) + 1;
            bRemoteNameRequest = TRUE;

        }
    }

    DBGMSG( DBG_TRACE, ( "OpenPrinter(%ws, %ws)\n", pFullPrinterName, pPrinterName ));

    bLocalCall = IsLocalCall();

    EnterSplSem();


    //
    // For the Mars folks who will come in with the same printer
    // connection, do a DeletePrinterCheck; this will allow
    // Mars connections that have been deleted to be proceed
    // to the Mars print providor
    //
    if (( pIniPrinter = FindPrinter( pPrinterName, pIniSpooler )) ||
        ( pIniPrinter = FindPrinterShare( pPrinterName, pIniSpooler ))) {

        DeletePrinterCheck( pIniPrinter );
        pIniPrinter = NULL;
    }

    //
    // The strategy for the rest of this code is to walk through each
    // different printer handle type, searching for a match.
    //
    // RouterReturnValue will be set to the current state of routing.
    // If a section recognizes and "owns" a printer and successfully
    // opens it, it sets RouterReturnValue to ROUTER_SUCCESS and
    // jumps to DoneRouting which allocs the handle.
    //
    // If it recoginzes the printer but fails to open it, and
    // guarentees that no one else (localspl code or other providers)
    // will recognize it, it should set RouterReturnValue to
    // ROUTER_STOP_ROUTING.  We will quit at this point.
    //
    // If it doesn't recognize the printer, set RouterReturnValue
    // to ROUTER_UNKNOWN and we will keep looking.
    //

    //
    // Try regular printer name: "My Printer" "TestPrinter."
    //

    RouterReturnValue = OpenLocalPrinterName( pPrinterName,
                                              pIniSpooler,
                                              &TypeofHandle,
                                              &pIniPrinter,
                                              &pIniPort,
                                              &pIniNetPort,
                                              &hPort,
                                              &OpenPortError,
                                              pDefaults );

    if( RouterReturnValue != ROUTER_UNKNOWN ){

        if( bRemoteNameRequest ){

            //
            // On success, determine whether the user is remote or local.
            // Note: we only do this for fully qualified names
            // (\\server\share), since using just the share or printer
            // name can only succeed locally.
            //

            if (bLocalCall) {
                if( (pIniSpooler->SpoolerFlags & SPL_REMOTE_HANDLE_CHECK) &&
                    (pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER) )
                    TypeofHandle |= PRINTER_HANDLE_REMOTE_DATA;
            } else {
                if( pIniSpooler->SpoolerFlags & SPL_REMOTE_HANDLE_CHECK )
                    TypeofHandle |= PRINTER_HANDLE_REMOTE_DATA;
                TypeofHandle |= PRINTER_HANDLE_REMOTE_CALL;
            }

            //
            // This is a remote open.
            //
            // If the printer is not shared, ensure the caller
            // has Administer access to the printer.
            //
            // The following seems to belong to the inside of the above "if"
            // clause. As it is, if an interactive user calls in with UNC name,
            // we require him to have ADMIN access if the printer is not shared;
            // but if he uses the printer friendly name, we let him go.
            //
            if( pIniPrinter &&
                !( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED )){

                bRemoteUserPrinterNotShared = TRUE;
            }
        }

        goto DoneRouting;
    }

    SPLASSERT( !TypeofHandle && !pIniPrinter && !pIniPort &&
               !pIniNetPort && !pIniJob && !hPort );

    //
    // Try LocalPrinter with an extention e.g.
    //
    // PortName, Port
    // PrinterName, Job xxxx
    // PrinterName, LocalOnlyToken
    // PrinterName, LocalsplOnlyToken
    //
    // See if the name includes a comma.  Look for qualifiers:
    //    Port Job LocalOnly LocalsplOnly
    //

    wcscpy( string, pPrinterName );

    if( pSecondPart = wcschr( string, L',' )){

        DWORD dwError;
        UINT uType;

        //
        // Turn into 2 strings
        // First PrintName
        // pSecondPart points to the rest.
        //
        *pSecondPart++ = 0;

        //
        // Get rid of Leading Spaces
        //
        while ( *pSecondPart == L' ' && *pSecondPart != 0 ) {
            pSecondPart++;
        }

        SPLASSERT( *pSecondPart );

        //
        //  PrintName, {LocalOnly|LocalsplOnly}
        //
        RouterReturnValue = CheckPrinterTokens( string,
                                                pSecondPart,
                                                &TypeofHandle,
                                                pIniSpooler,
                                                &pIniPrinter,
                                                &pIniPort,
                                                &pIniNetPort,
                                                &hPort,
                                                &OpenPortError,
                                                pDefaults );

        if( RouterReturnValue != ROUTER_UNKNOWN ){
            goto DoneRouting;
        }

        SPLASSERT( !TypeofHandle && !pIniPrinter && !pIniPort &&
                   !pIniNetPort && !pIniJob && !hPort );

        //
        //  PortName, Port
        //
        RouterReturnValue = CheckPrinterPortToken( string,
                                                   pSecondPart,
                                                   &TypeofHandle,
                                                   &pIniPrinter,
                                                   &pIniPort,
                                                   &pIniJob,
                                                   pDefaults,
                                                   pIniSpooler );

        if( RouterReturnValue != ROUTER_UNKNOWN ){
            goto DoneRouting;
        }

        SPLASSERT( !TypeofHandle && !pIniPrinter && !pIniPort &&
                   !pIniNetPort && !pIniJob && !hPort );

        //
        //  PrinterName, Job ###
        //
        RouterReturnValue = CheckPrinterJobToken( string,
                                                  pSecondPart,
                                                  &TypeofHandle,
                                                  &pIniPrinter,
                                                  &pIniJob,
                                                  &hReadFile,
                                                  pIniSpooler );

        if( RouterReturnValue != ROUTER_UNKNOWN ){
            goto DoneRouting;
        }

        SPLASSERT( !TypeofHandle && !pIniPrinter && !pIniPort &&
                   !pIniNetPort && !pIniJob && !hPort );

        //
        //  "\\Server\,XcvPort Object" or ",XcvPort Object"
        //  "\\Server\,XcvMonitor Object" or ",XcvMonitor Object"
        //

        // Verify that we're looking at the right server

        if (bRemoteNameRequest || *pPrinterName == L',') {
            RouterReturnValue = CheckXcvPortToken( pSecondPart,
                                                   &TypeofHandle,
                                                   pDefaults,
                                                   pIniSpooler,
                                                   pPrinterHandle );

        } else {
            RouterReturnValue = ROUTER_UNKNOWN;
        }

        goto WrapUp;
    }

    //
    // We have completed all routing.  Anything other than success
    // should exit now.
    //

DoneRouting:

    if( RouterReturnValue == ROUTER_SUCCESS) {

        //
        // It's an error if the printer is pending deletion or pending creation.
        //
        SPLASSERT( pIniPrinter );

        if (!pIniPrinter                                                          || 
            (pIniPrinter->Status       & PRINTER_PENDING_DELETION)                &&
            (pIniSpooler->SpoolerFlags & SPL_FAIL_OPEN_PRINTERS_PENDING_DELETION) &&
            (pIniPrinter->cJobs == 0)                                             ||
            (pIniPrinter->Status & PRINTER_PENDING_CREATION)) {

            RouterReturnValue = ROUTER_STOP_ROUTING;
            SetLastError( ERROR_INVALID_PRINTER_NAME );
            goto DoneRouting;
        }

        //
        // When the printer is opened, access type may be specified in
        // pDefaults.  If no defaults are supplied (or request access
        // is unspecified), we use PRINTER_ACCESS_USE.
        //
        // Future calls with the handle will check against both the
        // current user privileges on this printer but also this initial
        // access.  (Even if the user is an admin of the printer, unless
        // they open the printer with PRINTER_ALL_ACCESS, they can't
        // administer it.)
        //
        // If the user requires more access, the printer must be reopened.
        //
        if( !pDefaults || !pDefaults->DesiredAccess ){

            if( TypeofHandle & PRINTER_HANDLE_JOB ){
                DesiredAccess = JOB_READ;
            } else {
                DesiredAccess = PRINTER_READ;
            }

        } else {
            DesiredAccess = pDefaults->DesiredAccess;
        }

        //
        // If the user is remote and the printer is not shared, only allow
        // administrators succeed.
        //
        // This allows administrators to admin printers even if they
        // are not shared, and prevents non-admins from opening non-shared
        // printers.
        //

        if( bRemoteUserPrinterNotShared &&
            !(DesiredAccess & PRINTER_ACCESS_ADMINISTER )) {

            PSPOOL pSpool;

            // Get a quick and dirty pSpool to pass in
            pSpool = (PSPOOL)AllocSplMem( SPOOL_SIZE );
            if( pSpool == NULL ) {
                DBGMSG( DBG_WARNING, ("SplOpenPrinter failed to allocate memory %d\n", GetLastError() ));
                RouterReturnValue = ROUTER_STOP_ROUTING;
                goto WrapUp;
            }
            pSpool->signature = SJ_SIGNATURE;
            pSpool->pIniPrinter = pIniPrinter;


            // Add admin request, and see if user has the right.
            DesiredAccess |= PRINTER_ACCESS_ADMINISTER;
            if( !ValidateObjectAccess( SPOOLER_OBJECT_PRINTER,
                                       DesiredAccess,
                                       pSpool,
                                       &pSpool->GrantedAccess,
                                       pIniSpooler )) {
                SetLastError(ERROR_ACCESS_DENIED);
                RouterReturnValue = ROUTER_STOP_ROUTING;
            }
            DesiredAccess &= ~PRINTER_ACCESS_ADMINISTER;

            // clean up
            FreeSplMem( pSpool );

            // If the user had no ADMIN privilege, fail the open call.
            if( RouterReturnValue == ROUTER_STOP_ROUTING )
                goto WrapUp;
        }

        //
        // Create the printer handle that we will return to the user.
        //


        if( pFullPrinterName != pPrinterName) {
            wcsncpy( string, pFullPrinterName, (size_t) (pPrinterName - pFullPrinterName - 1));
            string[pPrinterName - pFullPrinterName - 1] = L'\0';

        } else {

            wcscpy(string, pIniSpooler->pMachineName);
        }


        *pPrinterHandle = CreatePrinterHandle( pFullPrinterName,
                                               string,
                                               pIniPrinter,
                                               pIniPort,
                                               pIniNetPort,
                                               pIniJob,
                                               TypeofHandle,
                                               hPort,
                                               pDefaults,
                                               pIniSpooler,
                                               DesiredAccess,
                                               pSplClientInfo,
                                               dwLevel,
                                               hReadFile );

        if( *pPrinterHandle ){

            //
            // Update the OpenPortError.
            //
            ((PSPOOL)*pPrinterHandle)->OpenPortError = OpenPortError;

        } else {
            SPLASSERT( GetLastError( ));
            RouterReturnValue = ROUTER_STOP_ROUTING;
        }
    }

WrapUp:

    LeaveSplSem();
    //
    // Don't have an SplOutSem as we could be called recursively.
    //

    switch( RouterReturnValue ){
    case ROUTER_SUCCESS:

        DBGMSG( DBG_TRACE, ("OpenPrinter returned handle %x\n", *pPrinterHandle));
        SPLASSERT( *pPrinterHandle );
        break;

    case ROUTER_UNKNOWN:

        SPLASSERT( !TypeofHandle && !pIniPrinter && !pIniPort &&
                   !pIniNetPort && !pIniJob && !hPort );

        //
        // hPort should not be valid.  If it is, we have leaked a handle.
        //
        SPLASSERT( !hPort );
        SPLASSERT( hReadFile == INVALID_HANDLE_VALUE );
        DBGMSG( DBG_TRACE, ( "OpenPrinter failed, invalid name "TSTR"\n",
                             pFullPrinterName ));
        SetLastError( ERROR_INVALID_NAME );
        break;

    case ROUTER_STOP_ROUTING:

        LastError = GetLastError();
        SPLASSERT( LastError );

        //
        // On failure, we may have opened a port or file handle. We need
        // to close it since we won't return a valid handle, and
        // so ClosePrinter will never get called.
        //

        if( hPort != INVALID_PORT_HANDLE ) {
            ClosePrinter( hPort );
        }

        if ( pIniJob && (pIniJob->hFileItem == INVALID_HANDLE_VALUE) )
        {
            if ( hReadFile != INVALID_HANDLE_VALUE ) {
                CloseHandle( hReadFile );
                hReadFile = INVALID_HANDLE_VALUE;
            }
        }

        DBGMSG( DBG_TRACE, ("OpenPrinter "TSTR" failed: Error %d\n",
                            pFullPrinterName, GetLastError()));

        SetLastError( LastError );
        break;
    }

    return RouterReturnValue;
}


BOOL
SplClosePrinter(
    HANDLE hPrinter
    )
{
    PSPOOL pSpool=(PSPOOL)hPrinter;
    PSPOOL *ppIniSpool = NULL;
    PINISPOOLER pIniSpoolerDecRef = NULL;
    PSPLMAPVIEW pSplMapView;
    PMAPPED_JOB pMappedJob;
    BOOL bValid;
    DWORD Position;

    //
    // Allow us to close zombied handles.
    //
    EnterSplSem();

    pSpool->Status &= ~SPOOL_STATUS_ZOMBIE;

    if (pSpool->TypeofHandle & PRINTER_HANDLE_XCV_PORT) {
        bValid = ValidateXcvHandle(pSpool->pIniXcv);
    } else {
        bValid = ValidateSpoolHandle(pSpool, 0);
    }


    LeaveSplSem();

    if( !bValid ){
        return FALSE;
    }

    if (!(pSpool->TypeofHandle & PRINTER_HANDLE_JOB) &&
        pSpool->pIniJob &&
        (pSpool->Status & SPOOL_STATUS_ADDJOB)) {

        LocalScheduleJob(hPrinter, pSpool->pIniJob->JobId);
    }

    if (pSpool->Status & SPOOL_STATUS_STARTDOC) {

        // it looks as though this might cause a double
        // decrement of pIniJob->cRef once inside LocalEndDocPrinter
        // and the other later in this routine.

        LocalEndDocPrinter(hPrinter);
    }

    if (pSpool->TypeofHandle & PRINTER_HANDLE_JOB) {

        if (pSpool->TypeofHandle & PRINTER_HANDLE_DIRECT) {

            //
            // If EndDoc is still waiting for a final ReadPrinter
            //
            if (pSpool->pIniJob->cbBuffer) { // Amount last transmitted

                //
                // Wake up the EndDoc Thread
                //
                SetEvent(pSpool->pIniJob->WaitForRead);

               SplOutSem();

                //
                // Wait until he is finished
                //
                WaitForSingleObject(pSpool->pIniJob->WaitForWrite, INFINITE);

                EnterSplSem();

                //
                // Now it is ok to close the handles
                //
                if (!CloseHandle(pSpool->pIniJob->WaitForWrite)) {
                    DBGMSG(DBG_WARNING, ("CloseHandle failed %d %d\n",
                                       pSpool->pIniJob->WaitForWrite, GetLastError()));
                }

                if (!CloseHandle(pSpool->pIniJob->WaitForRead)) {
                    DBGMSG(DBG_WARNING, ("CloseHandle failed %d %d\n",
                                       pSpool->pIniJob->WaitForRead, GetLastError()));
                }
                pSpool->pIniJob->WaitForRead = NULL;
                pSpool->pIniJob->WaitForWrite = NULL;

                LeaveSplSem();
            }

            DBGMSG(DBG_TRACE, ("ClosePrinter(DIRECT):cRef = %d\n", pSpool->pIniJob->cRef));

        }

        EnterSplSem();

        DBGMSG(DBG_TRACE, ("ClosePrinter:cRef = %d\n", pSpool->pIniJob->cRef));
        DECJOBREF(pSpool->pIniJob);
        DeleteJobCheck(pSpool->pIniJob);

        LeaveSplSem();
    }

    // Unmap all views of the spool file and close file mapping handles
    while (pSplMapView = pSpool->pSplMapView) {

        pSpool->pSplMapView = pSplMapView->pNext;

        if (pSplMapView->pStartMapView) {
            UnmapViewOfFile( (LPVOID) pSplMapView->pStartMapView);
        }
        // CreateFileMapping returns NULL (not INVALID_HANDLE_VALUE) for failure
        if (pSplMapView->hMapSpoolFile) {
            CloseHandle(pSplMapView->hMapSpoolFile);
        }

        FreeSplMem(pSplMapView);
    }

    // Delete all mapped spool files that are not required
    EnterSplSem();

    while (pMappedJob = pSpool->pMappedJob)
    {
        pSpool->pMappedJob = pMappedJob->pNext;

        if (!pSpool->pIniPrinter ||
            !FindJob(pSpool->pIniPrinter, pMappedJob->JobId, &Position))
        {
            // The job is gone and we have to delete the spool file
            LeaveSplSem();

            //
            // This may need looking at for File Pooling
            //
            DeleteFile(pMappedJob->pszSpoolFile);

            EnterSplSem();

            if (pSpool->pIniPrinter)
            {
                vMarkOff( pSpool->pIniPrinter->pIniSpooler->hJobIdMap,
                          pMappedJob->JobId );
            }
        }

        FreeSplMem(pMappedJob->pszSpoolFile);
        FreeSplMem(pMappedJob);
    }

    LeaveSplSem();

    if ( pSpool->hReadFile != INVALID_HANDLE_VALUE ) {

        // Move the file pointer to the number of bytes committed and set the end of
        // file.
        if ((pSpool->pIniJob->Status & JOB_TYPE_OPTIMIZE) &&
            SetFilePointer(pSpool->hReadFile, pSpool->pIniJob->dwValidSize,
                           NULL, FILE_BEGIN) != 0xffffffff) {

             SetEndOfFile(pSpool->hReadFile);
        }

        //
        // File pooling Change, we close the file handle if we aren't file 
        // pooling and we reset the seek pointer if we are file pooling.
        //
        if (pSpool->pIniJob)
        {
            if (pSpool->pIniJob->hFileItem == INVALID_HANDLE_VALUE)
            {
                if ( !CloseHandle( pSpool->hReadFile ) ) {

                    DBGMSG(DBG_WARNING, ("ClosePrinter CloseHandle(%d) failed %d\n", pSpool->hReadFile, GetLastError()));
                }
            }
            else
            {
                //
                // People call ClosePrinter / OpenPrinter in sequence to be able
                // to read from the beginning of the spool file again. To get the
                // same effect, we need to set the seek pointer back to the 
                // beginning of the hReadFile.
                //
                DWORD rc = ERROR_SUCCESS;

                rc = SetFilePointer(pSpool->hReadFile, 0, NULL, FILE_BEGIN);

                if (rc != ERROR_SUCCESS)
                {
                    DBGMSG(DBG_WARNING, ("ClosePrinter SetFilePointer(%p) failed %d\n", pSpool->hReadFile, rc));
                }
            }
        }
    }

    //
    // Close the handle that was opened via OpenPrinterPort:
    //

    if (pSpool->hPort) {

        if (pSpool->hPort != INVALID_PORT_HANDLE) {

            ClosePrinter(pSpool->hPort);

        } else {

            DBGMSG(DBG_WARNING, ("ClosePrinter ignoring bad port handle.\n"));
        }
    }

   EnterSplSem();

    //
    // Remove us from the linked list of handles:
    //
    if (pSpool->TypeofHandle & PRINTER_HANDLE_PRINTER) {

        SPLASSERT( pSpool->pIniPrinter->signature == IP_SIGNATURE );

        ppIniSpool = &pSpool->pIniPrinter->pSpool;
    }
    else if ((pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) ||
             (pSpool->TypeofHandle & PRINTER_HANDLE_XCV_PORT)) {

        SPLASSERT( pSpool->pIniSpooler->signature == ISP_SIGNATURE );

        if (pSpool->TypeofHandle & PRINTER_HANDLE_XCV_PORT)
            XcvClose(pSpool->pIniXcv);

        pIniSpoolerDecRef = pSpool->pIniSpooler;
        ppIniSpool = &pSpool->pIniSpooler->pSpool;
    }

    if (ppIniSpool) {

        while (*ppIniSpool && *ppIniSpool != pSpool)
            ppIniSpool = &(*ppIniSpool)->pNext;

        if (*ppIniSpool)
            *ppIniSpool = pSpool->pNext;

        else {

            DBGMSG( DBG_WARNING, ( "Didn't find pSpool %08x in linked list\n", pSpool ) );
        }
    }

    if (pSpool->pIniPrinter) {

        DECPRINTERREF( pSpool->pIniPrinter );

        DeletePrinterCheck(pSpool->pIniPrinter);

    }

    DeletePrinterHandle(pSpool);

    if( pIniSpoolerDecRef ){
        DECSPOOLERREF( pIniSpoolerDecRef );
    }

   LeaveSplSem();

    //
    // Don't call SplOutSem() since SplAddPrinter calls
    // use from inside the critical section.
    //

    return TRUE;
}

#ifdef _HYDRA_
ULONG
GetClientSessionId(
    )

/*++

Routine Description:

    Get the SessionID from the client who we should be impersonating. If any
    errors, we return 0 to mean the Console SessionId since this may be a
    remote network call.

Arguments:


Return Value:

    SessionID of the effective token

--*/
{
    BOOL          Result;
    HANDLE        TokenHandle;
    ULONG         SessionId, ReturnLength;

    //
    // We should be impersonating the client, so we will get the
    // SessionId from out token.
    //
    // We may not have a valid one if this is a remote network
    // connection.

    Result = OpenThreadToken(
                 GetCurrentThread(),
                 TOKEN_QUERY,
                 FALSE,              // Use impersonation
                 &TokenHandle
                 );

    if( Result ) {

        //
        // Query the SessionID from the token added by HYDRA
        //
        Result = GetTokenInformation(
                     TokenHandle,
                     (TOKEN_INFORMATION_CLASS)TokenSessionId,
                     &SessionId,
                     sizeof(SessionId),
                     &ReturnLength
                     );

        if( !Result ) {
            SessionId = 0; // Default to console
        }

        CloseHandle( TokenHandle );
    }
    else {
        SessionId = 0;
    }

    return( SessionId );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\net.c ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation

Module Name:

    net.c

Abstract:

    This module provides all the network stuuf for localspl

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Notes:

    We just need to get the winspool printer name associated with a given
    queue name.   The SHARE_INFO_2 structure has a shi2_path field that would
    be nice to use, but NetShareGetInfo level 2 is privileged.  So, by
    DaveSn's arm twisting and agreement with windows/spooler/localspl/net.c,
    we're going to use the shi1_remark field for this.  This allows us to
    do NetShareGetInfo level 1, which is not privileged.

    This has been fixed by allowing OpenPrinter to succeed on share names.
    If there is no comment, we put the printer name in as the remark
    (for graceful upgrades from pre-PPC).

Revision History:

    02-Sep-1992 JohnRo
        RAID 3556: DosPrintQGetInfo(from downlevel) level 3, rc=124.  (4&5 too.)

    Jun 93 mattfe pIniSpooler

--*/

#define UNICODE 1

#define NOMINMAX

#include <precomp.h>
#pragma hdrstop

#include "clusspl.h"

#ifdef DBG_SHARE
#include <messages.h>
#endif



NET_API_STATUS (*pfnNetShareAdd)();
NET_API_STATUS (*pfnNetShareSetInfo)();
NET_API_STATUS (*pfnNetShareDel)();
NET_API_STATUS (*pfnNetServerEnum)();
NET_API_STATUS (*pfnNetWkstaUserGetInfo)();
NET_API_STATUS (*pfnNetApiBufferFree)();
NET_API_STATUS (*pfnNetAlertRaiseEx)();
NET_API_STATUS (*pfnNetShareGetInfo)(LPWSTR, LPWSTR, DWORD, LPBYTE *);

extern  SHARE_INFO_2 PrintShareInfo;
extern  SHARE_INFO_2 PrtProcsShareInfo;

BOOL
InitializeNet(
    VOID
)
{
    HANDLE  hNetApi;
    UINT    uOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    hNetApi = LoadLibrary(TEXT("netapi32.dll"));

    SetErrorMode(uOldErrorMode);
    if ( !hNetApi )
        return FALSE;

    pfnNetShareAdd = (NET_API_STATUS (*)()) GetProcAddress(hNetApi,"NetShareAdd");
    pfnNetShareSetInfo = (NET_API_STATUS (*)()) GetProcAddress(hNetApi,"NetShareSetInfo");
    pfnNetShareDel = (NET_API_STATUS (*)()) GetProcAddress(hNetApi,"NetShareDel");
    pfnNetServerEnum = (NET_API_STATUS (*)()) GetProcAddress(hNetApi,"NetServerEnum");
    pfnNetWkstaUserGetInfo = (NET_API_STATUS (*)()) GetProcAddress(hNetApi,"NetWkstaUserGetInfo");
    pfnNetApiBufferFree = (NET_API_STATUS (*)()) GetProcAddress(hNetApi,"NetApiBufferFree");
    pfnNetAlertRaiseEx = (NET_API_STATUS (*)()) GetProcAddress(hNetApi,"NetAlertRaiseEx");
    pfnNetShareGetInfo = (NET_API_STATUS (*)(LPWSTR, LPWSTR, DWORD, LPBYTE *))GetProcAddress(hNetApi, "NetShareGetInfo");

    if ( pfnNetShareAdd == NULL ||
         pfnNetShareSetInfo == NULL ||
         pfnNetShareDel == NULL ||
         pfnNetServerEnum == NULL ||
         pfnNetWkstaUserGetInfo == NULL ||
         pfnNetApiBufferFree == NULL ||
         pfnNetAlertRaiseEx == NULL || 
         pfnNetShareGetInfo == NULL) {

        return FALSE;
    }

    return TRUE;
}


BOOL
SetPrinterShareInfo(
    PINIPRINTER pIniPrinter
    )

/*++

Routine Description:

    Sets the share information about a printer.

    Note: This does not update the share path.  We need to
    delete and re-create the share in order to change the path.

Arguments:

    pIniPrinter - Printer that needs to be updated.

Return Value:

    TRUE - Success
    FALSE - Failed

--*/

{
    SHARE_INFO_502          ShareInfo;
    HANDLE                  hToken;
    PSECURITY_DESCRIPTOR    pShareSecurityDescriptor = NULL;
    DWORD                   ParmError, rc;

    SplInSem();

    pShareSecurityDescriptor = MapPrinterSDToShareSD(pIniPrinter->pSecurityDescriptor);

    if ( !pShareSecurityDescriptor ) {

        rc = ERROR_INVALID_SECURITY_DESCR;
        goto Cleanup;
    }

    ZeroMemory((LPVOID)&ShareInfo, sizeof(ShareInfo));

    ShareInfo.shi502_netname                = pIniPrinter->pShareName;
    ShareInfo.shi502_type                   = STYPE_PRINTQ;
    ShareInfo.shi502_permissions            = 0;
    ShareInfo.shi502_max_uses               = SHI_USES_UNLIMITED;
    ShareInfo.shi502_current_uses           = SHI_USES_UNLIMITED;
    ShareInfo.shi502_passwd                 = NULL;
    ShareInfo.shi502_security_descriptor    = pShareSecurityDescriptor;

    if ( pIniPrinter->pComment && pIniPrinter->pComment[0] ) {

        ShareInfo.shi502_remark = pIniPrinter->pComment;

    } else {

        ShareInfo.shi502_remark = pIniPrinter->pName;
    }


    INCPRINTERREF(pIniPrinter);
    LeaveSplSem();

    SplOutSem();  // We *MUST* be out of our semaphore as the NetShareSet may
                  // come back and call spooler

    hToken = RevertToPrinterSelf();

    rc = (*pfnNetShareSetInfo)(NULL,
                               ShareInfo.shi502_netname,
                               502,
                               &ShareInfo,
                               &ParmError);

    if ( rc ) {

        if (rc == NERR_NetNameNotFound)
        {
            //
            // This can happen deny all access to a shared printer, then
            // restart the computer.  The server service tries to validate
            // it's share on startup, but since it has no access, it fails
            // and deletes it (it also wants a handle to the printer).  When
            // you grant everyone access, we try to change the ACL on the
            // SMB share, but since it was deleted, we fail.  Recreate
            // the share here.
            //
            EnterSplSem();

            if (!ShareThisPrinter(pIniPrinter,
                                  pIniPrinter->pShareName,
                                  TRUE)) {
                rc = GetLastError();
            } else {

                rc = ERROR_SUCCESS;
            }

            LeaveSplSem();
        }

        if (rc) {

            DBGMSG(DBG_WARNING,
                   ("NetShareSetInfo/ShareThisPrinter failed: Error %d, Parm %d\n",
                    rc, ParmError));

            SetLastError(rc);
        }
    }

    ImpersonatePrinterClient(hToken);

    EnterSplSem();
    DECPRINTERREF(pIniPrinter);

Cleanup:
    SplInSem();

    return rc == ERROR_SUCCESS;
}


BOOL
ShareThisPrinter(
    PINIPRINTER pIniPrinter,
    LPWSTR   pShareName,
    BOOL     bShare
    )
/*++

Routine Description:

    Shares or UnShares a Printer.

    Note: this really should be two functions, and the return value
    is very confusing.

    Note: no validation of sharename is done.  This must be done by
    callee, usually in ValidatePrinterInfo.

Arguments:

Return Value:

    Returns whether the printer is shared after this call.

        TRUE  - Shared
        FALSE - Not Shared

--*/
{
    SHARE_INFO_502    ShareInfo = {0};
    DWORD   rc;
    DWORD   ParmError;
    PSECURITY_DESCRIPTOR pShareSecurityDescriptor = NULL;
    PINISPOOLER pIniSpooler = pIniPrinter->pIniSpooler;
    PSHARE_INFO_2 pShareInfo = (PSHARE_INFO_2)pIniSpooler->pDriversShareInfo;
    LPTSTR pszPrinterNameWithToken = NULL;

    HANDLE  hToken;
    BOOL    bReturn = FALSE;
    BOOL    bSame   = FALSE;
    LPWSTR  pShareNameCopy = NULL;

    SPLASSERT( pIniPrinter->pName );
    SplInSem();

    pShareNameCopy = AllocSplStr(pShareName);

    if (!pShareNameCopy) {
        goto Done;
    }

    if ( bShare ) {

        if (!pfnNetShareAdd) {
            SetLastError( ERROR_PROC_NOT_FOUND );
            goto Done;
        }

        //
        // Share name validation has been moved into ValidatePrinterInfo.
        //

        if ((pShareSecurityDescriptor =
            MapPrinterSDToShareSD(pIniPrinter->pSecurityDescriptor)) == NULL) {
            SetLastError(ERROR_INVALID_SECURITY_DESCR);
            goto Done;
        }

        ShareInfo.shi502_netname = pShareNameCopy;  // hplaser

        //
        // If there is a comment, use it; otherwise set the remark
        // to be the printer name.
        //
        // Note: if the printer name changes and we don't have a comment,
        // we will reshare the printer to update the remark.
        //
        if( pIniPrinter->pComment && pIniPrinter->pComment[0] ){

            ShareInfo.shi502_remark = pIniPrinter->pComment;

        } else {

            ShareInfo.shi502_remark = pIniPrinter->pName;
        }

        //
        // Use the fully qualifed name, and make sure it exists in
        // localspl by using LocalsplOnlyToken.
        //
        pszPrinterNameWithToken = pszGetPrinterName(
                                      pIniPrinter,
                                      pIniSpooler != pLocalIniSpooler,
                                      pszLocalsplOnlyToken );

        if( !pszPrinterNameWithToken ){
            goto Done;
        }

        ShareInfo.shi502_path = pszPrinterNameWithToken;
        ShareInfo.shi502_type = STYPE_PRINTQ;
        ShareInfo.shi502_permissions = 0;
        ShareInfo.shi502_max_uses = SHI_USES_UNLIMITED;
        ShareInfo.shi502_current_uses = SHI_USES_UNLIMITED;
        ShareInfo.shi502_passwd = NULL;
        ShareInfo.shi502_security_descriptor = pShareSecurityDescriptor;

        INCPRINTERREF(pIniPrinter);
        LeaveSplSem();

        //
        // We *MUST* be out of our semaphore as the NetShareAdd is
        // going to come round and call OpenPrinter.
        //
        SplOutSem();

        // Go add the Print Share

        hToken = RevertToPrinterSelf();

        // Add a share for the spool\drivers directory:

        if( rc = AddPrintShare( pIniSpooler )){

            EnterSplSem();
            DECPRINTERREF(pIniPrinter);
            ImpersonatePrinterClient(hToken);

            SetLastError(rc);
            goto Done;
        }

#if DBG
        {
            WCHAR UserName[256];
            DWORD cbUserName=256;

            if (MODULE_DEBUG & DBG_SECURITY)
                GetUserName(UserName, &cbUserName);

            DBGMSG( DBG_SECURITY, ( "Calling NetShareAdd in context %ws\n", UserName ) );
        }
#endif

        // Add the printer share:

        rc = (*pfnNetShareAdd)(NULL, 502, (LPBYTE)&ShareInfo, &ParmError);


        // Now take care of Web sharing. i.e. make sure wwwroot\sharename is created if the
        // printer is either local or masqurading. We cannot allow sharing of RPC connections.
        if( fW3SvcInstalled && (pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL))
            WebShare( pShareNameCopy );

        //
        // If the return code is that the share already exists, then check to 
        // see whether this share is to the same device, if it is we just
        // update the info on the share and return success.
        // 
        if (rc == NERR_DuplicateShare) {

            if (ERROR_SUCCESS == CheckShareSame(pIniPrinter, &ShareInfo, &bSame) && bSame)  {

                rc = ERROR_SUCCESS;
            }
        }

        ImpersonatePrinterClient(hToken);

        EnterSplSem();
        DECPRINTERREF(pIniPrinter);

        if (ERROR_SUCCESS != rc) {

            DBGMSG( DBG_WARNING,
                    ( "NetShareAdd failed %lx, Parameter %d\n",
                      rc, ParmError ));

            if ((rc == ERROR_INVALID_PARAMETER) &&
                (ParmError == SHARE_NETNAME_PARMNUM)) {

                rc = ERROR_INVALID_SHARENAME;
            }

            SetLastError(rc);
            goto Done;

        }

        SPLASSERT( pIniPrinter != NULL);
        SPLASSERT( pIniPrinter->signature == IP_SIGNATURE);
        SPLASSERT( pIniPrinter->pIniSpooler != NULL);
        SPLASSERT( pIniPrinter->pIniSpooler->signature == ISP_SIGNATURE );

        CreateServerThread();

        //
        // The Printer is shared.
        //
        bReturn = TRUE;

    } else {

        if ( !pfnNetShareDel ) {
            bReturn = TRUE;
            goto Done;

        }

        INCPRINTERREF( pIniPrinter );
        LeaveSplSem();

        SplOutSem();

        hToken = RevertToPrinterSelf();

        rc = (*pfnNetShareDel)(NULL, pShareName, 0);

        // Now take care of Web unsharing. i.e. make sure wwwroot\sharename is deleted.
        if( fW3SvcInstalled && (pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL) && !(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER))
            WebUnShare( pShareName );

        ImpersonatePrinterClient(hToken);

        EnterSplSem();
        DECPRINTERREF(pIniPrinter);

        // The share may have been deleted manually, so don't worry
        // if we get NERR_NetNameNotFound:

        if ( rc && ( rc != NERR_NetNameNotFound )){

            DBGMSG(DBG_WARNING, ("NetShareDel failed %lx\n", rc));
            SetLastError( rc );
            bReturn = TRUE;
        }
    }

Done:

    if( pShareSecurityDescriptor ){
        LocalFree(pShareSecurityDescriptor);
    }

    FreeSplStr(pszPrinterNameWithToken);
    FreeSplStr(pShareNameCopy);

    return bReturn;
}


/*--
    FillAlertStructWithJobStrings
    
    Allocates memory which has to be freed by caller.
    
    
    
--*/

HRESULT
FillAlertStructWithJobStrings(
    PINIJOB pIniJob,
    PRINT_OTHER_INFO **pAlertInfo,
    PDWORD size
    )
{
    HRESULT RetVal = E_FAIL;
    DWORD cbSizetoAlloc = 0;
    PBYTE pBuffer = NULL;
    LPWSTR psz = NULL;


    if (pIniJob && pAlertInfo && !(*pAlertInfo) && size)
    {
        //
        // Do this in the splSem so that no one can jo a SetJob While we're not looking
        //
        EnterSplSem();

        //
        // We don't know how big these strings are going to be in future, so size 
        // them dynamically and alloc the structure to always be big enough.
        //
        cbSizetoAlloc = sizeof(PRINT_OTHER_INFO);

        //
        // We don't have to check some of these for existence, we know they exist.
        //
        cbSizetoAlloc += wcslen(pIniJob->pNotify) + 1 +
                         wcslen(pIniJob->pIniPrinter->pName) + 1 +
                         wcslen(pIniJob->pIniPrinter->pIniSpooler->pMachineName) + 1;

        if ( pIniJob->pDocument )
        {
            cbSizetoAlloc += wcslen(pIniJob->pDocument) + 1;
        }
        else
        {
            cbSizetoAlloc += 2;
        }

        if (pIniJob->pIniPrinter->pIniSpooler->bEnableNetPopupToComputer &&
            pIniJob->pMachineName)
        {
            cbSizetoAlloc += wcslen(pIniJob->pMachineName) + 1;
        }
        else
        {
            cbSizetoAlloc += wcslen(pIniJob->pNotify) + 1;
        }

        if ( pIniJob->pStatus )
        {
            cbSizetoAlloc += wcslen(pIniJob->pStatus) + 1;
        }
        else
        {
            cbSizetoAlloc += 2;
        }

        //
        // Scale the buffer by the number of bytes per character.
        //
        cbSizetoAlloc = cbSizetoAlloc * sizeof(TCHAR);
        
        //
        // Alloc the memory
        //
        pBuffer = AllocSplMem(cbSizetoAlloc);

        if ( pBuffer )
        {
            psz = (LPWSTR)ALERT_VAR_DATA((PRINT_OTHER_INFO *)pBuffer);
            
            //
            // Do the copying
            //
            
            //
            // Computer Name
            //
            if(pIniJob->pIniPrinter->pIniSpooler->bEnableNetPopupToComputer &&
                pIniJob->pMachineName ){
                wcscpy( psz, pIniJob->pMachineName );
            } else {
                wcscpy( psz, pIniJob->pNotify );
            }
            psz+=wcslen(psz)+1;


            // UserName

            wcscpy(psz, pIniJob->pNotify);
            psz+=wcslen(psz)+1;


            // Document Name

            if (pIniJob->pDocument)
                wcscpy(psz, pIniJob->pDocument);
            else
                wcscpy(psz, L"");

            psz += wcslen(psz) + 1;

            // Printer Name

            wcscpy(psz, pIniJob->pIniPrinter->pName);
            psz += wcslen(psz)+1;

            // Server Name

            wcscpy(psz, pIniJob->pIniPrinter->pIniSpooler->pMachineName);
            psz += wcslen(psz)+1;

            // Status_string
            // We should pass in other status strings for the other status errors, too.
            if (pIniJob->pStatus && (pIniJob->Status & (JOB_ERROR | JOB_OFFLINE | JOB_PAPEROUT)))
                wcscpy(psz, pIniJob->pStatus);
            else
                wcscpy(psz, L"");

            psz += wcslen(psz) + 1;

            //
            // Pass back the size and struct
            //
            *size = (DWORD)((PBYTE)psz - pBuffer);
            *pAlertInfo = (PRINT_OTHER_INFO *)pBuffer;
            RetVal = NOERROR;

        }
        else
        {
            RetVal = E_OUTOFMEMORY;
        }
        //
        // Leave the Spooler Semaphore
        //
        LeaveSplSem();

    }
    else
    {
        RetVal = E_INVALIDARG;
    }
    
    return RetVal;

}


VOID
SendJobAlert(
    PINIJOB pIniJob
    )
{
    PRINT_OTHER_INFO *pinfo = NULL;
    DWORD   RetVal = ERROR_SUCCESS;
    DWORD   Status;
    FILETIME    FileTime;
    DWORD  AlertSize = 0;

#ifdef _HYDRA_
    // Allow Hydra Sessions to be notified since they are remote
    if( (USER_SHARED_DATA->SuiteMask & (1 << TerminalServer)) ) {
        if ( !pIniJob->pNotify               ||
             !pIniJob->pNotify[0]            ||
             !pIniJob->pIniPrinter->pIniSpooler->bEnableNetPopups ) {
             return;
        }
    }
    else {
        if ( !pIniJob->pNotify               ||
             !pIniJob->pNotify[0]            ||
             !(pIniJob->Status & JOB_REMOTE) ||
             !pIniJob->pIniPrinter->pIniSpooler->bEnableNetPopups ) {
             return;
        }
    }
#else
    if ( !pIniJob->pNotify               ||
         !pIniJob->pNotify[0]            ||
         !(pIniJob->Status & JOB_REMOTE) ||
         !pIniJob->pIniPrinter->pIniSpooler->bEnableNetPopups ) {
        return;
    }
#endif

    if ( FAILED(RetVal = FillAlertStructWithJobStrings(pIniJob, &pinfo, &AlertSize)))
    {
        if ( pinfo ) 
            FreeSplMem(pinfo);
                
        return;
    }

    pinfo->alrtpr_jobid = pIniJob->JobId;

    if (pIniJob->Status & (JOB_PRINTING | JOB_DESPOOLING | JOB_PRINTED | JOB_COMPLETE))
        Status = PRJOB_QS_PRINTING;
    else if (pIniJob->Status & JOB_PAUSED)
        Status = PRJOB_QS_PAUSED;
    else if (pIniJob->Status & JOB_SPOOLING)
        Status = PRJOB_QS_SPOOLING;
    else
        Status = PRJOB_QS_QUEUED;

    if (pIniJob->Status & (JOB_ERROR | JOB_OFFLINE | JOB_PAPEROUT)) {

        Status |= PRJOB_ERROR;

        if (pIniJob->Status & JOB_OFFLINE)
            Status |= PRJOB_DESTOFFLINE;

        if (pIniJob->Status & JOB_PAPEROUT)
            Status |= PRJOB_DESTNOPAPER;
    }

    if (pIniJob->Status & JOB_PRINTED)
        Status |= PRJOB_COMPLETE;

    else if (pIniJob->Status & JOB_PENDING_DELETION)
        Status |= PRJOB_DELETED;

    pinfo->alrtpr_status = Status;

    SystemTimeToFileTime( &pIniJob->Submitted, &FileTime );

    //    FileTimeToDosDateTime(&FileTime, &DosDate, &DosTime);
    //    pinfo->alrtpr_submitted  = DosDate << 16 | DosTime;

    RtlTimeToSecondsSince1970((PLARGE_INTEGER) &FileTime,
                              &pinfo->alrtpr_submitted);

    pinfo->alrtpr_size       = pIniJob->Size;


    (*pfnNetAlertRaiseEx)(ALERT_PRINT_EVENT,
                          (PBYTE) pinfo,
                          AlertSize,
                          L"SPOOLER");

    if ( pinfo ) 
        FreeSplMem(pinfo);
}

DWORD
AddPrintShare(
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Adds the print$ share based on pIniSpooler.

Arguments:

    pIniSpooler - Share path is based on this information.  pDriversShareInfo
        must be initialized before calling this routine.

Return Value:

    TRUE - Success.

    FALSE - Failed.  LastError set.

--*/
{
    DWORD rc;
    DWORD ParmError;
    SHARE_INFO_1501 ShareInfo1501 = {0};
    PSHARE_INFO_2 pShareInfo = (PSHARE_INFO_2)pIniSpooler->pDriversShareInfo;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;

    //
    // Assert that the path is identical to the local one since there's
    // only one print$ share.  It should always be.
    //
    SPLASSERT( !lstrcmpi( pShareInfo->shi2_path,
                          ((PSHARE_INFO_2)pLocalIniSpooler->pDriversShareInfo)->shi2_path ));

    rc = (*pfnNetShareAdd)( NULL,
                            2,
                            (LPBYTE)pShareInfo,
                            &ParmError );

    //
    // If it already exists, assume it is set up correctly.
    //
    if( rc == NERR_DuplicateShare ){
        return ERROR_SUCCESS;
    }

    //
    // If we didn't create the share, fail.
    //
    if( rc != ERROR_SUCCESS ){

        DBGMSG( DBG_WARN,
                ( "AddPrintShare: Error %d, Parm %d\n", rc, ParmError));

        return rc;
    }

    //
    // Set security on the newly created share.
    //
    // Bug 54844
    // If this fails, we've created the share but haven't put security
    // on it.  Then since it exists, we'll never try and set it again.
    //

    pSecurityDescriptor = CreateDriversShareSecurityDescriptor();

    if( !pSecurityDescriptor ){
        return GetLastError();
    }

    ShareInfo1501.shi1501_security_descriptor = pSecurityDescriptor;

    rc = (*pfnNetShareSetInfo)( NULL,
                                pShareInfo->shi2_netname,
                                1501,
                                &ShareInfo1501,
                                &ParmError );

    if( rc != ERROR_SUCCESS ){

        DBGMSG( DBG_WARN,
                ( "NetShareSetInfo failed: Error %d, Parm %d\n",
                  rc, ParmError));
    }

    LocalFree(pSecurityDescriptor);

    return rc;
}

/*++

Routine Name:

    CheckShareSame

Routine Description:

    This checks to see whether the given share name is the same on both the 
    local and remote machines.

Arguments:

    pIniPrinter     -   The iniprinter for which we are adding the share.
    pShareInfo502   -   The share info that we are attempting to add the share 
                        with.
    pbSame          -   The return parameter is TRUE if the shares were the same
                        If the rc is not ERROR_SUCCESS, then the info could not
                        be set.

Return Value:

    An error code.

--*/
DWORD
CheckShareSame(
    IN      PINIPRINTER         pIniPrinter,
    IN      SHARE_INFO_502      *pShareInfo502,
        OUT BOOL                *pbSame
    )
{
    DWORD           rc = ERROR_SUCCESS;
    SHARE_INFO_2    *pShareInfoCompare = NULL;
    BOOL            bPathEquivalent = FALSE;
    BOOL            bSame           = FALSE;
    DWORD           ParmError;

    SplOutSem();

    //
    // Get the share info for the share, we should already have determined 
    // that this share exists.
    //
    rc = pfnNetShareGetInfo(NULL, pShareInfo502->shi502_netname, 2, (LPBYTE *)&pShareInfoCompare);

    if (ERROR_SUCCESS == rc)        
    {
        
        if (STYPE_PRINTQ  == pShareInfoCompare->shi2_type)
        {
            //
            // Check to see whether the paths are the same, in the upgrade case, the
            // LocalSplOnly will be taken off, so, compare this too.
            // 
            bSame = !_wcsicmp(pShareInfoCompare->shi2_path, pShareInfo502->shi502_path);

            //
            // If they are not the same, compare it to the name of the printer.
            // 
            if (!bSame)
            {
                EnterSplSem();
                        
                bSame = bPathEquivalent = !_wcsicmp(pIniPrinter->pName, pShareInfoCompare->shi2_path);

                LeaveSplSem();
            }
        }        
    }

    *pbSame = bSame;

    if (ERROR_SUCCESS == rc && bSame)
    {
        //
        // If the paths are identical, we can just set the share info, otherwise
        // we have to delete and recreate the share.
        //
        if (!bPathEquivalent)
        {
            //
            // OK, they are the same, set the share info instead.
            // 
            rc = (*pfnNetShareSetInfo)(NULL, pShareInfo502->shi502_netname, 502, pShareInfo502, &ParmError);
        }
        else
        {
            rc = (*pfnNetShareDel)(NULL, pShareInfo502->shi502_netname, 0);

            if (ERROR_SUCCESS == rc)
            {
                rc = (*pfnNetShareAdd)(NULL, 502, (LPBYTE)pShareInfo502, &ParmError);
            }
        }
    }

    if (pShareInfoCompare)
    {
        pfnNetApiBufferFree(pShareInfoCompare);
    }
        
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\precomp.h ===
/*++ BUILD Version: 0001
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  precomp.h
 *  Combined precompiled header source
 *
 *  This file is a collection of all the common .h files used by the
 *  various source files in this directory. It is precompiled by the
 *  build process to speed up the overall build time.
 *
 *  Put new .h files in here if it has to be seen by multiple source files.
 *  Keep in mind that the definitions in these .h files are potentially
 *  visible to all source files in this project.
 *
 *  History:
 *  mattfe jan 26 95
--*/

#define INC_OLE2


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntregapi.h>

#include <windows.h>
#include <winspool.h>
#include <splapip.h>
#include <winsplp.h>
#include <rpc.h>
#include <dsrole.h>

#include <lm.h>
#include <winsock2.h>
#include <dsgetdc.h>
#include <ntdsapi.h>
#include <spltypes.h>
#include <local.h>
#include <spoolsec.h>
#include <messages.h>
#include <wininet.h>

#include <tchar.h>
#include <activeds.h>
#include <winldap.h>

#include <ctype.h>
#include <wchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <change.h>

#include <memory.h>
#include <ntfytab.h>

#include <winsprlp.h>
#include <gdispool.h>

#include <setupapi.h>
#include <splsetup.h>

// DS
#include "ds.h"
#include "varconv.hxx"
#include "property.hxx"
#include "dsutil.hxx"
#include "splmrg.h"

#include <lmcons.h>
#include <lmwksta.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <lmserver.h>
#include <dsgetdc.h>
#include <oleauto.h>
#include <accctrl.h>
#include <winsock2.h>

#define SECURITY_WIN32
#include <security.h>
#include <sddl.h>

#include <sfcapip.h>
#include <userenv.h>

//
// WMI stuff
//
#include <wmidata.h>
#include <wmistr.h>
#include <evntrace.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\property.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Abstract:

    Adds properties to ds

Author:

    Steve Wilson (NT) December 1996

Revision History:

--*/


#include <precomp.h>
#pragma hdrstop

#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);




HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr;
    VARIANT varInputData;

    hr = PackString2Variant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);

    if (!pSrcStringProperty || !*pSrcStringProperty) {
        hr = pADsObject->PutEx(
                ADS_PROPERTY_CLEAR,
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);

    } else {

        hr = pADsObject->Put(
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);
    }

error:

    VariantClear(&varInputData);

    return hr;
}


HRESULT
get_BSTR_Property(
    IADs *pADsObject,
    BSTR  bstrPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( ppDestStringProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    return hr;
}


HRESULT
put_DWORD_Property(
    IADs  *pADsObject,
    BSTR   bstrPropertyName,
    DWORD *pdwSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    if (!pdwSrcProperty)
        return S_OK;

    hr = PackDWORD2Variant(
            *pdwSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    return hr;
}

HRESULT
get_DWORD_Property(
    IADs  *pADsObject,
    BSTR   bstrPropertyName,
    PDWORD pdwDestProperty
)
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pdwDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDWORDfromVariant(
            varOutputData,
            pdwDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    return hr;

}


HRESULT
put_Dispatch_Property(
    IADs  *pADsObject,
    BSTR   bstrPropertyName,
    IDispatch *pdwSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    if (!pdwSrcProperty)
        return S_OK;

    hr = PackDispatch2Variant(
            pdwSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    return hr;
}


HRESULT
get_Dispatch_Property(
    IADs *pADsObject,
    BSTR  bstrPropertyName,
    IDispatch **ppDispatch
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDispatchfromVariant(
            varOutputData,
            ppDispatch
            );
    BAIL_ON_FAILURE(hr);


error:
    return hr;
}




HRESULT
put_MULTISZ_Property(
    IADs    *pADsObject,
    BSTR    bstrPropertyName,
    BSTR    pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT var;
    VARIANT varInputData;
    BSTR    pStr;
    BSTR    *pStrArray;
    DWORD   i;
    BSTR    pMultiString;

    if (!pSrcStringProperty || !*pSrcStringProperty)
        pMultiString = L"";
    else
        pMultiString = pSrcStringProperty;

    VariantInit(&var);

    // Convert MULTI_SZ to string array (last element of array must be NULL)
    for (i = 0, pStr = pMultiString ; *pStr ; ++i, pStr += wcslen(pStr) + 1)
        ;

    if (!(pStrArray = (BSTR *) AllocSplMem((i + 1)*sizeof(BSTR)))) {
        hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0, pStr = pMultiString ; *pStr ; ++i, pStr += wcslen(pStr) + 1)
        pStrArray[i] = pStr;
    pStrArray[i] = NULL;

    MakeVariantFromStringArray(pStrArray, &var);

    FreeSplMem(pStrArray);

    hr = PackVARIANTinVariant(
            var,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);

    if (!pSrcStringProperty || !*pSrcStringProperty) {
        hr = pADsObject->PutEx(
                ADS_PROPERTY_CLEAR,
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);

    } else {

        hr = pADsObject->Put(
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);
    }

error:

    VariantClear(&var);
    VariantClear(&varInputData);

    return hr;
}

HRESULT
put_BOOL_Property(
    IADs *pADsObject,
    BSTR bstrPropertyName,
    BOOL *bSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;
    BOOL    bVal;

    bVal = bSrcProperty ? *bSrcProperty : 0;

    hr = PackBOOL2Variant(
            bVal,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);

    if (!bSrcProperty) {
        hr = pADsObject->PutEx(
                ADS_PROPERTY_CLEAR,
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);

    } else {

        hr = pADsObject->Put(
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);
    }

error:
    return hr;
}


HRESULT
get_UI1Array_Property(
    IADs *pADsObject,
    BSTR  bstrPropertyName,
    IID  *pIID
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UI1Array2IID(
            varOutputData,
            pIID
            );
    BAIL_ON_FAILURE(hr);


error:
    return hr;
}

/*

HRESULT
put_LONG_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    LONG   lSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackLONGinVariant(
            lSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    return hr;
}

HRESULT
get_LONG_Property(
    IADs * pADsObject,
    BSTR  bstrPropertyName,
    PLONG plDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( plDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackLONGfromVariant(
            varOutputData,
            plDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    return hr;

}

HRESULT
put_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackDATEinVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    return hr;
}

HRESULT
get_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE *pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pdaDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDATEfromVariant(
            varOutputData,
            pdaDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    return hr;
}

HRESULT
put_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT_BOOL   fSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANT_BOOLinVariant(
            fSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    return hr;
}

HRESULT
get_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT_BOOL *pfDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pfDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANT_BOOLfromVariant(
            varOutputData,
            pfDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    return hr;
}

HRESULT
get_VARIANT_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT *pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pvDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANTfromVariant(
            varOutputData,
            pvDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:
    return hr;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\schedule.c ===
/*++

Copyright (c) 1990 - 1996 Microsoft Corporation

Module Name:

    schedule.c

Abstract:

    This module provides all the scheduling services for the Local Spooler

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Krishna Ganugapati (KrishnaG) 07-Dec-1993  - rewrote the scheduler thread to
    gracefully kill off port threads if there are no jobs assigned to ports and
    to recreate the port thread if the port receives a job and is without a thread.

    Matthew A Felton (MattFe) June 1994 RapidPrint implemented

    MattFe April 96 Chained Jobs


--*/

#include <precomp.h>

#include "filepool.hxx"

#define MIDNIGHT                    (60 * 60 * 24)

//
// Ten minutes, seconds are multiplied in by the Scheduler code.
//
#define FPTIMEOUT                   (60 * 10)       

                                                    

#if DBG
/* For the debug message:
 */
#define HOUR_FROM_SECONDS(Time)     (((Time) / 60) / 60)
#define MINUTE_FROM_SECONDS(Time)   (((Time) / 60) % 60)
#define SECOND_FROM_SECONDS(Time)   (((Time) % 60) % 60)

/* Format for %02d:%02d:%02d replaceable string:
 */
#define FORMAT_HOUR_MIN_SEC(Time)   HOUR_FROM_SECONDS(Time),    \
                                    MINUTE_FROM_SECONDS(Time),  \
                                    SECOND_FROM_SECONDS(Time)

/* Format for %02d:%02d replaceable string:
 */
#define FORMAT_HOUR_MIN(Time)       HOUR_FROM_SECONDS(Time),    \
                                    MINUTE_FROM_SECONDS(Time)
#endif


//extern HANDLE hFilePool;


HANDLE SchedulerSignal = NULL;
HANDLE PowerManagementSignal = NULL;


VOID
DbgPrintTime(
);

DWORD
GetTimeToWait(
    DWORD       CurrentTime,
    PINIPRINTER pIniPrinter,
    PINIJOB     pIniJob
);

DWORD
GetCurrentTimeInSeconds(
    VOID
);

VOID
InitializeSchedulingGlobals(
);

VOID
CheckMemoryAvailable(
    PINIJOB  *ppIniJob,
    BOOL     bFixedJob
);

VOID
UpdateJobList(
);

BOOL
AddToJobList(
    PINIJOB    pIniJob,
    SIZE_T     Required,
    DWORD      dwJobList
);

BOOL
SchedulerCheckPort(
    PINISPOOLER pIniSpooler,
    PINIPORT    pIniPort,
    PINIJOB     pFixedIniJob,
    PDWORD      pdwSchedulerTimeout
);

BOOL
SchedulerCheckSpooler(
    PINISPOOLER pIniSpooler,
    PDWORD pdwSchedulerTimeout
);

BOOL
GetJobFromWaitingList(
    PINIPORT   *ppIniPort,
    PINIJOB    *ppIniJob,
    DWORD      dwPriority
);

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)           // Not all control paths return (due to infinite loop)
#endif

DWORD
SchedulerThread(
    PINISPOOLER pIniSpooler
    )
{
    DWORD SchedulerTimeout = INFINITE;    // In seconds
    PINISPOOLER pIniSpoolerNext;
    BOOL    bJobScheduled = FALSE;
    HANDLE  hTempFP = INVALID_HANDLE_VALUE;

    // Initialize the EMF scheduling parameters
    InitializeSchedulingGlobals();

    for( ; ; ) {


        if (SchedulerTimeout == INFINITE) {

            DBGMSG(DBG_TRACE, ("Scheduler thread waiting indefinitely\n"));

        } else {

            DBGMSG(DBG_TRACE, ("Scheduler thread waiting for %02d:%02d:%02d\n",
                                FORMAT_HOUR_MIN_SEC(SchedulerTimeout)));

            //
            // The SchedulerTimeout is in seconds, so we need to multiply
            // by 1000.
            //

            SchedulerTimeout *= 1000;

        }

        if (WaitForSingleObject(SchedulerSignal,
                                SchedulerTimeout) == WAIT_FAILED) {

            DBGMSG(DBG_WARNING, ("SchedulerThread:WaitforSingleObject failed: Error %d\n",
                                 GetLastError()));
        }

        if (WaitForSingleObject(PowerManagementSignal, INFINITE) == WAIT_FAILED)
        {
            DBGMSG(DBG_WARNING, ("SchedulerThread:WaitforSingleObject failed on ACPI event: Error %d\n",
                                 GetLastError()));
        }
        
        /* The timeout will be reset if there are jobs to be printed
         * at a later time.  This will result in WaitForSingleObject
         * timing out when the first one is due to be printed.
         */

        SchedulerTimeout = INFINITE;
        bJobScheduled = FALSE;

        EnterSplSem();

        INCSPOOLERREF( pLocalIniSpooler );

        for( pIniSpooler = pLocalIniSpooler;
             pIniSpooler;
             pIniSpooler = pIniSpoolerNext ){

            //
            // Only schedule check spoolers that are local.
            //
            if( pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL ){
                bJobScheduled = (SchedulerCheckSpooler( pIniSpooler, &SchedulerTimeout )
                                 || bJobScheduled);

                //
                // FP Change
                // Trim the filepool.
                //
                if (pIniSpooler &&
                    (hTempFP = pIniSpooler->hFilePool) != INVALID_HANDLE_VALUE &&
                    !bJobScheduled )
                {
                    //
                    // We've incremented the spooler Refcount, so we can
                    // safely leave the splsem.
                    //
                    LeaveSplSem();
                    if (TrimPool(hTempFP))
                    {
                        if (SchedulerTimeout == INFINITE)
                        {
                            SchedulerTimeout = FPTIMEOUT;
                        }
                    }
                    EnterSplSem();
                }

            }

            pIniSpoolerNext = pIniSpooler->pIniNextSpooler;
            if( pIniSpoolerNext ){
                INCSPOOLERREF( pIniSpoolerNext );
            }

            DECSPOOLERREF( pIniSpooler );
        }

        LeaveSplSem();

    }
    return 0;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

BOOL
SchedulerCheckPort(
    PINISPOOLER pIniSpooler,
    PINIPORT    pIniPort,
    PINIJOB     pFixedIniJob,
    PDWORD      pdwSchedulerTimeout)

/*++
Function Description: Checks if pIniJob can be assigned to pIniPort. If pInijob is NULL we
                      search for another job that can print on pIniPort. The job (if any) is
                      scheduled and the dwSchedulerTimeout is adjusted for the next waiting
                      job

Parameters: pIniSpooler   -- pointer to INISPOOLER struct
            pIniPort      -- Port to a assign a job to
            pFixedIniJob  -- Assign this job, if possible. If NULL search for other jobs
            pdwSchedulerTimeOut -- How much time will the scheduler thread sleep

Return Values: TRUE if a job gets assigned to pIniPort
               FALSE otherwise
--*/

{
    BOOL      bFixedJob, bReturn = FALSE;
    PINIJOB   pIniJob = NULL;
    DWORD     ThisPortTimeToWait;             // In seconds
    DWORD     CurrentTickCount;

    // Check of there is a pre assigned job
    bFixedJob = pFixedIniJob ? TRUE : FALSE;

    DBGMSG(DBG_TRACE, ("Now Processing Port %ws\n", pIniPort->pName));

    SPLASSERT( pIniPort->signature == IPO_SIGNATURE );

    // Check conditions based on which we can assign this
    // port a job.

    // Rule 1 - if there is a job being processed by this
    // port, then  leave this port alone.

    if ( (pIniPort->pIniJob) &&
        !(pIniPort->Status & PP_WAITING )){

        SPLASSERT( pIniPort->pIniJob->signature == IJ_SIGNATURE );

        //  If this port has a job which has timed out AND
        //  there is another job waiting on this port then
        //  push the timed out job out by setting JOB_ABANDON
        //  see spooler.c LocalReadPrinter

        pIniJob = pIniPort->pIniJob;

        if (( pIniJob->Status & JOB_TIMEOUT ) &&
            ( pIniJob->WaitForWrite != NULL ) &&
            ( NULL != AssignFreeJobToFreePort( pIniPort, &ThisPortTimeToWait ) )) {

            INCPORTREF( pIniPort );
            INCJOBREF( pIniJob );

            pIniJob->Status |= JOB_ABANDON;
            ReallocSplStr(&pIniJob->pStatus, szFastPrintTimeout);

            LogJobInfo( pIniSpooler,
                        MSG_DOCUMENT_TIMEOUT,
                        pIniJob->JobId,
                        pIniJob->pDocument,
                        pIniJob->pUser,
                        pIniJob->pIniPrinter->pName,
                        dwFastPrintWaitTimeout );

            SetEvent( pIniJob->WaitForWrite );

            SetPrinterChange(pIniJob->pIniPrinter,
                             pIniJob,
                             NVJobStatusAndString,
                             PRINTER_CHANGE_SET_JOB,
                             pIniJob->pIniPrinter->pIniSpooler);

            DECJOBREF( pIniJob );
            DECPORTREF( pIniPort );
        }

        return bReturn;
    }

    if (bFixedJob) {
        // Use a pre-assigned job
        pIniJob = pFixedIniJob;
    } else {
        // Is there any job that can be scheduled to this port ?
        pIniJob = AssignFreeJobToFreePort(pIniPort, &ThisPortTimeToWait);
        *pdwSchedulerTimeout = min(ThisPortTimeToWait, *pdwSchedulerTimeout);
    }

    if (pIniPort->Status & PP_THREADRUNNING ) {
        if (pIniPort->Status & PP_WAITING) {

            // If we are working on a Chained Job then the job
            // has already been assigned by the port thread from
            // the last job on this port so ignore any other job
            // found for us.

            if (pIniPort->pIniJob) {

                if (bFixedJob && (pIniJob != pIniPort->pIniJob)) {
                    // The fixed job could not assigned because chained jobs
                    // must be printed sequentially
                    pIniJob = NULL;
                } else {
                    pIniJob = pIniPort->pIniJob;
                    DBGMSG( DBG_TRACE, ("ScheduleThread NextJob pIniPort %x JoId %d pIniJob %x\n",
                       pIniPort, pIniJob->JobId, pIniJob ));
                }
            }

            // If the delay in scheduling has been requested by FlushPrinter wait until
            // IdleTime elapses

            //
            // We're using a local here to avoid multiple calls to GetTickCount().
            //
            CurrentTickCount = GetTickCount();

            if (pIniPort->bIdleTimeValid && (int)(pIniPort->IdleTime - CurrentTickCount) > 0) {
                //
                // Our port is not ready to accept a job just yet, we need to
                // remind the Scheduler to wake up in a little while to reassign
                // the job to the port.
                //
                // The difference is in milliseconds, so we divide by 1000 to get to
                // seconds, and add 1 to make sure we return after the timeout has
                // expired.
                //

                *pdwSchedulerTimeout =
                    min( ((pIniPort->IdleTime - CurrentTickCount)/1000) + 1,
                         *pdwSchedulerTimeout);

                //
                // Null out the job so we don't assign it to the port.
                //

                pIniJob = NULL;
            }
            else {
                pIniPort->bIdleTimeValid = FALSE;
            }

            if ( pIniJob ) {
                CheckMemoryAvailable( &pIniJob, bFixedJob );
            }

            if ( pIniJob ) {

                DBGMSG(DBG_TRACE, ("ScheduleThread pIniJob %x Size %d pDocument %ws\n",
                        pIniJob, pIniJob->Size, DBGSTR( pIniJob->pDocument)));


                if (pIniPort != pIniJob->pIniPort) {

                    ++pIniPort->cJobs;
                    pIniJob->pIniPort = pIniPort;
                }

                pIniPort->pIniJob = pIniJob;

                //
                // We have a new job on this port, make sure the Critical Section mask is
                // cleared.
                //
                pIniPort->InCriticalSection = 0;

                if( !pIniJob->pCurrentIniJob ){

                    //
                    // If pCurrentIniJob is NULL, then this is
                    // beginning of a new job (single or linked).
                    //
                    // Clustered spoolers are interested in the
                    // number of jobs that are actually printing.
                    // We need to know when all printing jobs are
                    // done so we can shutdown.
                    //
                    ++pIniJob->pIniPrinter->pIniSpooler->cFullPrintingJobs;

                    if( pIniJob->NextJobId ){

                        //
                        // Chained Jobs
                        // Point the Master Jobs Current Pointer to
                        // the first in the chain.
                        //
                        pIniJob->pCurrentIniJob = pIniJob;
                    }
                }


                pIniPort->Status &=  ~PP_WAITING;

                // If the job is still spooling then we will need
                // to create an event to synchronize the port thread

                if ( !( pIniJob->Status & JOB_DIRECT ) ) {

                    pIniJob->WaitForWrite = NULL;

                    if ( pIniJob->Status & JOB_SPOOLING ) {

                        pIniJob->WaitForWrite = CreateEvent( NULL,
                                                             EVENT_RESET_MANUAL,
                                                             EVENT_INITIAL_STATE_NOT_SIGNALED,
                                                             NULL );

                    }
                }

                // Update cRef so that nobody can delete this job
                // before the Port Thread Starts up

                SplInSem();
                INCJOBREF(pIniJob);

                SetEvent(pIniPort->Semaphore);
                pIniJob->Status |= JOB_DESPOOLING;

                bReturn = TRUE;

            } else {

                //
                // If the port thread is running and it is waiting
                // for a job and there is no job to assign, then
                // kill the port thread
                //
                DBGMSG(DBG_TRACE, ("Now destroying the new port thread %.8x\n", pIniPort));
                DestroyPortThread(pIniPort, FALSE);

                pIniPort->Status &=  ~PP_WAITING;

                if (pIniPort->Status & PP_FILE) {
                    //
                    // We should destroy the Pseudo-File Port at this
                    // point. There are no jobs assigned to this Port
                    // and we are in Critical Section
                    //

                    //
                    // Now deleting the pIniPort entry for the Pseudo-Port
                    //

                    DBGMSG(DBG_TRACE, ("Now deleting the Pseudo-Port %ws\n", pIniPort->pName));

                    if ( !pIniPort->cJobs )
                        DeletePortEntry(pIniPort);

                    return bReturn;
                }
            }
        }
    } else if (!(pIniPort->Status & PP_THREADRUNNING) && pIniJob) {

        //
        // If the port thread is not running, and there is a job to
        // assign, then create a port thread. REMEMBER do not assign
        // the job to the port because we are in a Spooler Section and
        // if we release the Spooler Section, the first thing the port
        // thread does is  reinitialize its pIniPort->pIniJob to NULL
        // Wait the next time around we execute the for loop to assign
        // the job to this port. Should we set *pdwSchedulerTimeOut to zero??
        //
        DBGMSG( DBG_TRACE, ("ScheduleThread Now creating the new port thread pIniPort %x\n", pIniPort));

        CreatePortThread( pIniPort );
        bReturn = TRUE;
    }

    return bReturn;
}

BOOL
SchedulerCheckSpooler(
    PINISPOOLER pIniSpooler,
    PDWORD pdwSchedulerTimeout)

/*++
Function Description: This function assigns a waiting job to a port after every minute.
                      If memory is available it schedules as many jobs from the waiting
                      list as possible.
                      It then loops thru the ports in a round-robin fashion scheduling jobs
                      or adding them to the waiting list.

Parameters:  pIniSpooler         -- pointer to the INISPOOLER struct
             pdwSchedulerTimeout -- duration of time for which the scheduler
                                    thread will sleep

Return Values: NONE
--*/

{
    DWORD       ThisPortTimeToWait = INFINITE;             // In seconds
    DWORD       dwTickCount;
    PINIPORT    pIniPort;
    PINIJOB     pIniJob;
    PINIPORT    pIniNextPort = NULL;
    BOOL        bJobScheduled = FALSE;

    UpdateJobList();

    // If Jobs have been waiting for 1 minute and nothing has been scheduled in
    // that time, schedule one of the waiting jobs.

    dwTickCount = GetTickCount();

    if (pWaitingList &&
        ((dwTickCount - pWaitingList->dwWaitTime) > ONE_MINUTE) &&
        ((dwTickCount - dwLastScheduleTime) > ONE_MINUTE)) {

        if (GetJobFromWaitingList(&pIniPort, &pIniJob, SPL_FIRST_JOB)) {

            bJobScheduled = (SchedulerCheckPort(pIniSpooler, pIniPort, pIniJob, &ThisPortTimeToWait)
                             || bJobScheduled);
            *pdwSchedulerTimeout = min(*pdwSchedulerTimeout, ThisPortTimeToWait);
        }
    }

    // Use the available memory to schedule waiting jobs
    while (GetJobFromWaitingList(&pIniPort, &pIniJob, SPL_USE_MEMORY)) {

       bJobScheduled = (SchedulerCheckPort(pIniSpooler, pIniPort, pIniJob, &ThisPortTimeToWait)
                        || bJobScheduled);
       *pdwSchedulerTimeout = min(*pdwSchedulerTimeout, ThisPortTimeToWait);
    }

    // Loop thru the ports and get the list of jobs that can be scheduled
    for (pIniPort = pIniSpooler->pIniPort;
         pIniPort;
         pIniPort = pIniNextPort) {

       pIniNextPort = pIniPort->pNext;

       //
       // SchedulerCheckPort can leave the critical section and the iniPort can
       // be removed from the list in the meanwhile. So, maintain the Ref on it.
       //
       if (pIniNextPort) {

           INCPORTREF(pIniNextPort);
       }

       bJobScheduled = (SchedulerCheckPort(pIniSpooler, pIniPort, NULL, &ThisPortTimeToWait)
                        || bJobScheduled);
       *pdwSchedulerTimeout = min(*pdwSchedulerTimeout, ThisPortTimeToWait);

       if (pIniNextPort) {

           DECPORTREF(pIniNextPort);
       }
    }

    // If there any jobs left try to reschedule latest after one minute.
    if (pWaitingList) {
        *pdwSchedulerTimeout = min(*pdwSchedulerTimeout, 60);
    }

    return bJobScheduled;
}

VOID
InitializeSchedulingGlobals(
)
/*++
Function Description: Initializes globals used for EMF scheduling

Parameters: NONE

Return Values: NONE
--*/
{
    MEMORYSTATUS   msBuffer;
    HKEY           hPrintRegKey = NULL;
    DWORD          dwType, dwData, dwcbData;

    bUseEMFScheduling = TRUE; // default value

    dwcbData = sizeof(DWORD);

    // Check the registry for the flag for turning off EMF scheduling. If the
    // key is not present/Reg Apis fail default to using the scheduling.
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     szRegistryRoot,
                     0,
                     KEY_READ,
                     &hPrintRegKey) == ERROR_SUCCESS) {

        if (RegQueryValueEx(hPrintRegKey,
                            szEMFThrottle,
                            NULL,
                            &dwType,
                            (LPBYTE) &dwData,
                            &dwcbData) == ERROR_SUCCESS) {

            if (dwData == 0) {
                // Scheduling has been turned off
                bUseEMFScheduling = FALSE;
            }
        }
    }

    // Get the memory status
    GlobalMemoryStatus(&msBuffer);

    // Use half the physical memory in megabytes
    TotalMemoryForRendering = msBuffer.dwTotalPhys / ( 2048 * 1024);
    AvailMemoryForRendering = TotalMemoryForRendering;

    dwNumberOfEMFJobsRendering = 0;
    pWaitingList = NULL;
    pScheduleList = NULL;
    dwLastScheduleTime = GetTickCount();

    if (hPrintRegKey) {
        RegCloseKey(hPrintRegKey);
    }

    return;
}

DWORD
GetMemoryEstimate(
    LPDEVMODE pDevMode
)
/*++
Function Description: Computes a rough estimate of the memory required for rendering a
                      single page based on the DPI and color settings

Parameters: pDevMode -- pointer to the devmode of the job

Return Values: Memory estimate
--*/
{
    DWORD      dwRequired, dwXRes, dwYRes, dwMaxRes;
    DWORD      dwXIndex, dwYIndex;
    DWORD      MemHeuristic[3][2] = {{8 , 4},
                                     {12, 6},
                                     {16, 8}};

    // Get the max resolution on either axis
    dwXRes = dwYRes = 300;

    if (pDevMode) {
        if (pDevMode->dmFields & DM_PRINTQUALITY) {
             switch (pDevMode->dmPrintQuality) {
             case DMRES_DRAFT:
             case DMRES_LOW:
             case DMRES_MEDIUM:
                    dwXRes = dwYRes = 300;
                    break;
             case DMRES_HIGH:
                    dwXRes = dwYRes = 600;
                    break;
             default:
                    dwXRes = dwYRes = (DWORD) pDevMode->dmPrintQuality;
                    break;

             }
        }
        if (pDevMode->dmFields & DM_YRESOLUTION) {
             dwYRes = (DWORD) pDevMode->dmYResolution;
        }
    }

    dwMaxRes = (dwXRes >= dwYRes) ? dwXRes : dwYRes;

    if (dwMaxRes <= 300) {
        dwXIndex = 0;
    } else if (dwMaxRes <= 600) {
        dwXIndex = 1;
    } else {
        dwXIndex = 2;
    }

    // Get the color setting
    dwYIndex = 1;
    if (pDevMode) {
        if ((pDevMode->dmFields & DM_COLOR) &&
            (pDevMode->dmColor == DMCOLOR_COLOR)) {

             dwYIndex = 0;
        }
    }

    dwRequired = MemHeuristic[dwXIndex][dwYIndex];

    return dwRequired;
}

VOID
CheckMemoryAvailable(
    PINIJOB  *ppIniJob,
    BOOL     bFixedJob
)

/*++
Function Description: Checks for availability of memory required for rendering the
                      job. Performs some scheduling based on resource requirements.

Parameters: ppIniJob  - pointer to the PINIJOB to be scheduled
            bFixedJob - flag to disable memory requirement checks

Return Values: NONE
--*/

{
    PINIJOB    pIniJob;
    SIZE_T     Required;

    SplInSem();

    if (ppIniJob) {
        pIniJob = *ppIniJob;
    } else {
        // should not happen
        return;
    }

    // Dont use scheduling algorithm if it has been explicitly turned off
    if (!bUseEMFScheduling) {
        return;
    }

    // Dont use scheduling algorithm for non EMF jobs
    if (!pIniJob->pDatatype ||
        (wstrcmpEx(pIniJob->pDatatype, gszNT4EMF, FALSE) &&
         wstrcmpEx(pIniJob->pDatatype, L"NT EMF 1.006", FALSE) &&
         wstrcmpEx(pIniJob->pDatatype, L"NT EMF 1.007", FALSE) &&
         wstrcmpEx(pIniJob->pDatatype, gszNT5EMF, FALSE)) )  {

        return;
    }

    Required = GetMemoryEstimate(pIniJob->pDevMode);

    if (bFixedJob) {
        // This job has to be assigned without memory availability checks
        RemoveFromJobList(pIniJob, JOB_WAITING_LIST);

        AddToJobList(pIniJob, Required, JOB_SCHEDULE_LIST);

        return;
    }

    // Check if the job has to wait, based on
    // 1.  Some jobs are already waiting OR
    // 2.  There is insufficient memory available due to currently rendering jobs

    if ((pWaitingList != NULL) ||
        ((AvailMemoryForRendering < Required) &&
         (dwNumberOfEMFJobsRendering > 0))) {

         AddToJobList(pIniJob, Required, JOB_WAITING_LIST);
         *ppIniJob = NULL;

         return;
    }

    // The job can be scheduled right away
    AddToJobList(pIniJob, Required, JOB_SCHEDULE_LIST);

    return;
}

PINIJOB
AssignFreeJobToFreePort(
    PINIPORT pIniPort,
    DWORD   *pSecsToWait
    )

/*++
    Note: You must ensure that the port is free. This function will not
    assign a job to this port, but if there exists one, it will return a
    pointer to the INIJOB. Irrespective of whether it finds a job or not,
    it will return the minimum timeout value that the scheduler thread
    should sleep for.
--*/

{
    DWORD           CurrentTime;        // Time in seconds
    DWORD           Timeout = INFINITE; // Time in seconds
    DWORD           SecsToWait; // Time in seconds
    PINIPRINTER     pTopIniPrinter,  pIniPrinter;
    PINIJOB         pTopIniJob, pIniJob;
    PINIJOB         pTopIniJobOnThisPrinter, pTopIniJobSpooling;
    DWORD           i;

    SplInSem();

    if( pIniPort->Status & PP_ERROR ){

        *pSecsToWait = INFINITE;
        return NULL;
    }

    pTopIniPrinter = NULL;
    pTopIniJob = NULL;

    for (i = 0; i < pIniPort->cPrinters ; i++) {
        pIniPrinter = pIniPort->ppIniPrinter[i];

        //
        // if this printer is in a state not to print skip it
        //

        if ( PrinterStatusBad(pIniPrinter->Status) ||
             (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE) ) {

            continue;
        }


        //
        // if we haven't found a top-priority printer yet,
        // or this printer is higher priority than the top-priority
        // printer, see if it has jobs to go. If we  find any, the
        // highest priority one will become the top priority job and
        // this printer will become the top-priority printer.
        //

        if (!pTopIniPrinter ||
            (pIniPrinter->Priority > pTopIniPrinter->Priority)) {

                pTopIniJobOnThisPrinter = NULL;
                pTopIniJobSpooling = NULL;
                pIniJob = pIniPrinter->pIniFirstJob;
                while (pIniJob) {

                    if (!(pIniPort->Status & PP_FILE) &&
                            (pIniJob->Status & JOB_PRINT_TO_FILE)) {
                                pIniJob = pIniJob->pIniNextJob;
                                continue;
                    }

                    if ((pIniPort->Status & PP_FILE) &&
                            !(pIniJob->Status & JOB_PRINT_TO_FILE)) {
                                pIniJob = pIniJob->pIniNextJob;
                                continue;
                    }

                    // Make sure the spooler isn't offline.
                    // Find a job which is not PAUSED, PRINTING etc.
                    // Let jobs that are DIRECT & CANCELLED through
                    // For RapidPrint also allow SPOOLING jobs to print

                    if (!(pIniJob->pIniPrinter->pIniSpooler->SpoolerFlags & SPL_OFFLINE) &&
                        (!(pIniJob->Status & JOB_PENDING_DELETION) || (pIniJob->pIniPrinter->Attributes&PRINTER_ATTRIBUTE_DIRECT)) &&

                        !(pIniJob->Status & ( JOB_PAUSED       | JOB_PRINTING | JOB_COMPLETE |
                                              JOB_PRINTED      | JOB_TIMEOUT  |
                                              JOB_DESPOOLING   | JOB_BLOCKED_DEVQ | JOB_COMPOUND )) &&

                        ((!(pIniJob->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DIRECT) &&
                          !(pIniJob->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_QUEUED)) ||
                         !(pIniJob->Status & JOB_SPOOLING))) {

                        //
                        // if we find such a job, then determine how much
                        // time, we need to wait before this job can actually
                        // print.
                        //

                        CurrentTime = GetCurrentTimeInSeconds();
                        #if DBG
                                if (MODULE_DEBUG & DBG_TIME)
                                    DbgPrintTime();
                        #endif
                        SecsToWait = GetTimeToWait(CurrentTime, pIniPrinter, pIniJob);

                        if (SecsToWait == 0) {

                            // if we needn't wait at all, then we make this job the
                            // TopIniJob if either there is no TopIniJob or this job
                            // has a higher priority than an existing TopIniJob on this
                            // printer.

                            // Keep both the Highest Priority Spooling and Non
                            // spooling job in case we want to favour non spooling
                            // jobs over spooling jobs

                            if ( pIniJob->Status & JOB_SPOOLING ) {

                                if ( pTopIniJobSpooling == NULL ) {

                                    pTopIniJobSpooling = pIniJob;

                                } else if ( pIniJob->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST ) {

                                    //
                                    // For DO_COMPLETE_FIRST we'll take larger jobs
                                    // first over pure priority based
                                    //

                                    if (( pIniJob->dwValidSize > pTopIniJobSpooling->dwValidSize ) ||

                                       (( pIniJob->dwValidSize == pTopIniJobSpooling->dwValidSize ) &&
                                        ( pIniJob->Priority > pTopIniJobSpooling->Priority ))) {

                                        pTopIniJobSpooling = pIniJob;

                                    }

                                //  For Priority Based, pick a higher priority job if it has some
                                //  at least our minimum requirement

                                } else if (( pIniJob->Priority > pTopIniJobSpooling->Priority ) &&
                                           ( pIniJob->dwValidSize >= dwFastPrintSlowDownThreshold )) {

                                    pTopIniJobSpooling = pIniJob;

                                }

                            } else {

                                if (!pTopIniJobOnThisPrinter ||
                                     (pIniJob->Status & JOB_PENDING_DELETION) ||
                                     (pIniJob->Priority > pTopIniJobOnThisPrinter->Priority)) {

                                    pTopIniJobOnThisPrinter = pIniJob;

                                }
                            }

                        } else {

                            //
                            // if we have to wait then keep track of how long we
                            // can doze off before the next job that is to be
                            // scheduled later.
                            //

                            Timeout = min(Timeout, SecsToWait);
                        }
                    }
                    //
                    // loop thru all jobs on this printer.
                    //

                    pIniJob = pIniJob->pIniNextJob;
                }

                //
                // We've already  established that this printer has a
                // higher priority than any previous TopIniPrinter or
                // that there is no TopIniPrinter yet.

                // if we did find a TopIniJobOnThisPrinter for this pIniPrinter
                // update the TopIniPrinter and TopIniJob pointers
                //

                // We don't want to schedule Spooling Jobs whose size doesn't meet
                // our minimum size requirement

                if (( pTopIniJobSpooling != NULL ) &&
                    ( dwFastPrintSlowDownThreshold > pTopIniJobSpooling->Size )) {

                        pTopIniJobSpooling = NULL ;
                }

                if ( pTopIniJobOnThisPrinter == NULL ) {

                    pTopIniJobOnThisPrinter = pTopIniJobSpooling;

                } else {

                    // For FastPrint we can choose to favour Completed jobs over
                    // Spooling jobs

                    if ( !( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST )  &&
                        ( pTopIniJobSpooling ) &&
                        ( pTopIniJobSpooling->Priority >= pTopIniJobOnThisPrinter->Priority )) {

                        pTopIniJobOnThisPrinter = pTopIniJobSpooling;

                     }
                }

                if (pTopIniJobOnThisPrinter) {
                    pTopIniPrinter = pIniPrinter;
                    pTopIniJob = pTopIniJobOnThisPrinter;
                }

        }
        //
        // This ends the if clause for finding a printer with higher priority
        // than the current TopIniPrinter. Loop back and process all printers
    }
    //
    // End of For Loop for all Printers
    //

    //
    // if we have a TopIniJob at this stage, it means we have a job that can be
    // assigned to the IniPort. We will return a pointer to this job back

    // We will also copy the Timeout value that has been computed for this
    // IniPort back to the SchedulerThread.

    *pSecsToWait = Timeout;

    return(pTopIniJob);

}

DWORD
GetCurrentTimeInSeconds(
)
/*++

    Note: This function returns a value representing the time in seconds


--*/
{
    SYSTEMTIME st;

    GetSystemTime(&st);

    return ((((st.wHour * 60) + st.wMinute) * 60) + st.wSecond);
}

/* GetTimeToWait
 *
 * Determines how long it is in seconds from the current time
 * before the specified job should be printed on the specified printer.
 *
 * Parameters:
 *
 *     CurrentTime - Current system time in seconds
 *
 *     pIniPrinter - Pointer to INIPRINTER structure for the printer.
 *         This contains the StartTime and UntilTime fields.
 *
 *     pIniJob - Pointer to INIJOB structure for the job.
 *         This contains the StartTime and UntilTime fields.
 *
 * Return value:
 *
 *     The number of seconds till the job should be printed.
 *     If the job can be printed immediately, this will be 0.
 *     We don't support specifying the day the job should be printed,
 *     so the return value should always be in the following range:
 *
 *         0 <= return value < 86400 (60 * 60 * 24)
 *
 * Remarks:
 *
 *     The user can specify hours on both the printer and the job.
 *     Thus a printer may be configured to print only at night,
 *     say between the hours 20:00 and 06:00.
 *     Any job submitted to the printer outside those hours
 *     will not print until 20:00.
 *     If, in addition, the user specifies the hours when the job
 *     may print (e.g. through Printer Properties -> Details
 *     in Print Manager), the job will print when the two periods
 *     overlap.
 *
 *     This routine finds the two wait periods determined by the
 *     printer hours and the job hours respectively.
 *     The actual time to wait is the longer of the two.
 *     It therefore assumes that the two periods overlap.
 *     This doesn't matter if the routine is called again
 *     when the scheduler thread wakes up again.
 *
 *     CHANGED: 14 June 1993
 *
 *     The printer times are now ignored.
 *     When a job is submitted it inherits the printer's hours.
 *     These are all we need to check.  Now if the printer's hours
 *     are changed, any already existing jobs on that printer
 *     will still print within the originally assigned times.
 *
 *
 */
DWORD
GetTimeToWait(
    DWORD       CurrentTime,
    PINIPRINTER pIniPrinter,
    PINIJOB     pIniJob
)
{
    /* Printer and job start and until times are in minutes.
     * Convert them to seconds, so that we can start printing
     * bang on the minute.
     */
    DWORD PrinterStartTime = (pIniPrinter->StartTime * 60);
    DWORD PrinterUntilTime = (pIniPrinter->UntilTime * 60);
    DWORD JobStartTime = (pIniJob->StartTime * 60);
    DWORD JobUntilTime = (pIniJob->UntilTime * 60);
    DWORD PrinterTimeToWait = 0;
    DWORD JobTimeToWait = 0;
    DWORD TimeToWait = 0;

    /* Current time must be within the window between StartTime and UntilTime
     * of both the printer and the job.
     * But if StartTime and UntilTime are identical, any time is valid.
     */

#ifdef IGNORE_PRINTER_TIMES

    if (PrinterStartTime > PrinterUntilTime) {

        /* E.g. StartTime = 20:00
         *      UntilTime = 06:00
         *
         * This spans midnight, so check we're not in the period
         * between UntilTime and StartTime:
         */
        if ((CurrentTime < PrinterStartTime)
          &&(CurrentTime >= PrinterUntilTime)) {

            /* It's after 06:00, but before 20:00:
             */
            PrinterTimeToWait = (PrinterStartTime - CurrentTime);
        }

    } else if (PrinterStartTime < PrinterUntilTime) {

        /* E.g. StartTime = 08:00
         *      UntilTime = 18:00
         */
        if (CurrentTime < PrinterStartTime) {

            /* It's after midnight, but before printing hours:
             */
            PrinterTimeToWait = (PrinterStartTime - CurrentTime);

        } else if (CurrentTime >= PrinterUntilTime) {

            /* It's before midnight, and after printing hours.
             * In this case, time to wait is the period until
             * midnight plus the start time:
             */
            PrinterTimeToWait = ((MIDNIGHT - CurrentTime) + PrinterStartTime);
        }
    }

#endif /* IGNORE_PRINTER_TIMES

    /* Do the same for the job time constraints:
     */
    if (JobStartTime > JobUntilTime) {

        if ((CurrentTime < JobStartTime)
          &&(CurrentTime >= JobUntilTime)) {

            JobTimeToWait = (JobStartTime - CurrentTime);
        }

    } else if (JobStartTime < JobUntilTime) {

        if (CurrentTime < JobStartTime) {

            JobTimeToWait = (JobStartTime - CurrentTime);

        } else if (CurrentTime >= JobUntilTime) {

            JobTimeToWait = ((MIDNIGHT - CurrentTime) + JobStartTime);
        }
    }


    TimeToWait = max(PrinterTimeToWait, JobTimeToWait);

    DBGMSG(DBG_TRACE, ("Checking time to print %ws\n"
                       "\tCurrent time:  %02d:%02d:%02d\n"
                       "\tPrinter hours: %02d:%02d to %02d:%02d\n"
                       "\tJob hours:     %02d:%02d to %02d:%02d\n"
                       "\tTime to wait:  %02d:%02d:%02d\n\n",
                       pIniJob->pDocument ?
                           pIniJob->pDocument :
                           L"(NULL)",
                       FORMAT_HOUR_MIN_SEC(CurrentTime),
                       FORMAT_HOUR_MIN(PrinterStartTime),
                       FORMAT_HOUR_MIN(PrinterUntilTime),
                       FORMAT_HOUR_MIN(JobStartTime),
                       FORMAT_HOUR_MIN(JobUntilTime),
                       FORMAT_HOUR_MIN_SEC(TimeToWait)));

    return TimeToWait;
}


#if DBG
VOID DbgPrintTime(
)
{
    SYSTEMTIME st;

    GetLocalTime(&st);

    DBGMSG( DBG_TIME,
            ( "Time: %02d:%02d:%02d\n", st.wHour, st.wMinute, st.wSecond ));
}
#endif


VOID UpdateJobList()

/*++
Function Description: Remove Jobs from the scheduled list which take more than 7 minutes.
                      This figure can be tuned up based in performance. There might be
                      some minor wrapping up discrepencies after 49.7 days which can be
                      safely ignored.
                      It also removes deleted, printed and abandoned jobs from the waiting
                      list.

                      This function should be called inside SplSem.
Parameters: NONE

Return Values: NONE
--*/

{
    PJOBDATA  *pJobList, pJobData;
    DWORD     dwTickCount;

    SplInSem();

    dwTickCount = GetTickCount();
    pJobList = &pScheduleList;

    while (pJobData = *pJobList) {

       if ((dwTickCount - pJobData->dwScheduleTime) >= SEVEN_MINUTES) {
           // Dont hold up resources for this job any more.
           RemoveFromJobList(pJobData->pIniJob, JOB_SCHEDULE_LIST);
           continue;
       }

       pJobList = &(pJobData->pNext);
    }

    pJobList = &pWaitingList;

    while (pJobData = *pJobList) {

       if (pJobData->pIniJob->Status & (JOB_PRINTING | JOB_PRINTED | JOB_COMPLETE |
                                        JOB_ABANDON  | JOB_PENDING_DELETION)) {

           RemoveFromJobList(pJobData->pIniJob, JOB_WAITING_LIST);
           continue;
       }

       pJobList = &(pJobData->pNext);
    }

    return;
}


BOOL AddToJobList(
    PINIJOB    pIniJob,
    SIZE_T     Required,
    DWORD      dwJobList)

/*++
Function Description: This function adds pIniJob to the list specified by dwJobList. It also
                      updates the number of rendering EMF jobs and memory available
                      for rendering.
                      This function should be called in SplSem.

Parameters:  pIniJob      -- Job to be removed
             dwRequired   -- Estimate of the memory required to render the job
             dwJobList    -- List to add to (Waiting List or Schedule List)

Return Values: TRUE if the node was added or already present
               FALSE otherwise
--*/

{
    PJOBDATA   *pJobList, pJobData;
    SIZE_T     MemoryUse;
    DWORD      dwTickCount;
    BOOL       bReturn = TRUE;

    SplInSem();

    if (!pIniJob) {
        return bReturn;
    }

    if (dwJobList == JOB_SCHEDULE_LIST) {
        pJobList = &pScheduleList;
    } else { // JOB_WAITING_LIST
        pJobList = &pWaitingList;
    }

    while (pJobData = *pJobList) {

       if (pJobData->pIniJob == pIniJob) {
           // The job is already on the list. Dont add duplicates
           break;
       }
       pJobList = &(pJobData->pNext);
    }

    if (!pJobData) {

        // Append a new node to the list
        if (pJobData = AllocSplMem(sizeof(JOBDATA))) {

            pJobData->pIniJob = pIniJob;
            pJobData->MemoryUse = Required;
            pJobData->dwNumberOfTries = 0;
            dwTickCount = GetTickCount();

            if (dwJobList == JOB_SCHEDULE_LIST) {
                pJobData->dwScheduleTime = dwTickCount;
                pJobData->dwWaitTime = 0;
            } else { // JOB_WAIT_TIME
                pJobData->dwWaitTime = dwTickCount;
                pJobData->dwScheduleTime = 0;
            }

            pJobData->pNext = *pJobList;
            *pJobList = pJobData;

            INCJOBREF(pIniJob);

            if (dwJobList == JOB_SCHEDULE_LIST) {
                // Update the scheduling globals
                ++dwNumberOfEMFJobsRendering;

                if (AvailMemoryForRendering > Required) {
                    AvailMemoryForRendering -= Required;
                } else {
                    AvailMemoryForRendering = 0;
                }

                dwLastScheduleTime = dwTickCount;
            }

        } else {

            bReturn = FALSE;
        }
    }

    return bReturn;
}

VOID RemoveFromJobList(
    PINIJOB    pIniJob,
    DWORD      dwJobList)

/*++
Function Description: This function removes pIniJob from the list specified by dwJobList
                      It also updates the number of rendering EMF jobs and memory available
                      for rendering. The scheduler is awakened if necessary.
                      This function should be called inside SplSem.

Parameters:  pIniJob      -- Job to be removed
             dwJobList    -- List to remove from (Waiting List or Schedule List)

Return Values: NONE
--*/

{
    PJOBDATA   *pJobList, pJobData;
    SIZE_T      Memory;

    SplInSem();

    if (!pIniJob) {
        return;
    }

    if (dwJobList == JOB_SCHEDULE_LIST) {
        pJobList = &pScheduleList;
    } else { // JOB_WAITING_LIST
        pJobList = &pWaitingList;
    }

    while (pJobData = *pJobList) {

       if (pJobData->pIniJob == pIniJob) {
           // Remove from the list
           *pJobList = pJobData->pNext;

           DECJOBREF(pIniJob);

           if (dwJobList == JOB_SCHEDULE_LIST) {
               // Update available memory and number of rendering jobs
               Memory = AvailMemoryForRendering + pJobData->MemoryUse;
               AvailMemoryForRendering = min(Memory, TotalMemoryForRendering);
               --dwNumberOfEMFJobsRendering;

               // Awaken the scheduler since more memory if available
               CHECK_SCHEDULER();
           }

           FreeSplMem(pJobData);

           // Break since there are no duplicates in the list
           break;
       }

       pJobList = &(pJobData->pNext);
    }

    return;
}

BOOL GetJobFromWaitingList(
    PINIPORT   *ppIniPort,
    PINIJOB    *ppIniJob,
    DWORD      dwPriority)

/*++
Function Description: This function picks up the first job in the Waiting List that can
                      be assigned to some free port. It should be called from within the
                      SplSem.

Parameters: ppIniPort    -  pointer to pIniPort where the job can be scheduled
            ppIniJob     -  pointer to pIniJob which can be scheduled
            dwPriority   -  flag to use memory availability check

Return Values: TRUE if a job can be scheduled
               FALSE otherwise
--*/

{
    BOOL        bReturn = FALSE;
    DWORD       dwIndex, CurrentTime, SecsToWait;
    PINIPORT    pIniPort = NULL;
    PINIJOB     pIniJob = NULL;
    PINIPRINTER pIniPrinter = NULL;
    PJOBDATA    pJobData;

    SplInSem();

    // Initialize the port and job pointers;
    *ppIniPort = NULL;
    *ppIniJob  = NULL;

    for (pJobData = pWaitingList;
         pJobData;
         pJobData = pJobData->pNext) {

        pIniJob = pJobData->pIniJob;
        pIniPrinter = pIniJob->pIniPrinter;

        // Check for memory availability
        if (dwPriority == SPL_USE_MEMORY) {
            if ((pJobData->MemoryUse > AvailMemoryForRendering) &&
                (dwNumberOfEMFJobsRendering != 0)) {
                // Insufficient memory
                continue;
            }
        } else { // SPL_FIRST_JOB
            if (pJobData->dwNumberOfTries > 2) {
                continue;
            }
        }

        // If this job cant be printed, go to the next one
        if (pIniJob->Status & ( JOB_PAUSED       | JOB_PRINTING |
                                JOB_PRINTED      | JOB_TIMEOUT  |
                                JOB_DESPOOLING   | JOB_PENDING_DELETION |
                                JOB_BLOCKED_DEVQ | JOB_COMPOUND | JOB_COMPLETE)) {
            continue;
        }

        // If we cant print to this printer, skip the job
        if (!pIniPrinter ||
            PrinterStatusBad(pIniPrinter->Status) ||
            (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE) ||
            (pIniPrinter->pIniSpooler->SpoolerFlags & SPL_OFFLINE)) {

            continue;
        }

        // For direct printing dont consider spooling jobs
        if (( (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_QUEUED) ||
              (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DIRECT)  ) &&
            (pIniJob->Status & JOB_SPOOLING)) {

            continue;
        }

        // Check if the job can print immediately
        CurrentTime = GetCurrentTimeInSeconds();
        SecsToWait = GetTimeToWait(CurrentTime, pIniPrinter, pIniJob);
        if (SecsToWait != 0) {
            continue;
        }

        // Check if any port attached to this printer can print this job
        for (dwIndex = 0;
             dwIndex < pIniPrinter->cPorts;
             ++dwIndex) {

           pIniPort = pIniPrinter->ppIniPorts[dwIndex];

           if (!pIniPort || (pIniPort->Status & PP_ERROR)) {
               continue;
           }

           if (!(pIniPort->Status & PP_FILE) &&
               (pIniJob->Status & JOB_PRINT_TO_FILE)) {
               continue;
           }

           if ((pIniPort->Status & PP_FILE) &&
               !(pIniJob->Status & JOB_PRINT_TO_FILE)) {
               continue;
           }

           // Check if the port is already processing some job
           if ( (pIniPort->pIniJob) &&
               !(pIniPort->Status & PP_WAITING )){
               continue;
           }

           // Check if the port has some chained jobs other than the current one
           if ((pIniPort->Status & PP_THREADRUNNING) &&
               (pIniPort->Status & PP_WAITING)) {

               if ((pIniPort->pIniJob != NULL) &&
                   (pIniPort->pIniJob != pIniJob)) {
                   continue;
               } else {
                   // We have found a port and a job to schedule
                   break;
               }
           }
        }

        if (dwIndex < pIniPrinter->cPorts) {
            // We have a port and job
            bReturn = TRUE;
            pJobData->dwNumberOfTries += 1;
            *ppIniJob = pIniJob;
            *ppIniPort = pIniPort;
            break;
        }
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\prndata.c ===
/*++

Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    prndata.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    mattfe Apr 5 95 - we keep the driver data key open
    and then just do the read / write operations here.

    Steve Wilson (SWilson) Jan 11 96 - Added Server handle functionality to Get & setprinterdata
                                       and pretty much changed everything in the process.

    Steve Wilson (SWilson) May 31 96 - Added SplEnumPrinterData and SplDeletePrinterData
    Steve Wilson (SWilson) Dec 96 - Added SetPrinterDataEx, GetPrinterDataEx, EnumPrinterDataEx,
                                    EnumPrinterKey, DeletePrinterDataEx, and DeleteKey

--*/

#include <precomp.h>
#pragma hdrstop

#include "clusspl.h"
#include "filepool.hxx"
#include <lmcons.h>
#include <lmwksta.h>
#include <lmerr.h>
#include <lmapibuf.h>

#define SECURITY_WIN32
#include <security.h>

#define OPEN_PORT_TIMEOUT_VALUE     3000   // 3 seconds
#define DELETE_PRINTER_DATA 0
#define SET_PRINTER_DATA    1
#define DELETE_PRINTER_KEY  2
extern DWORD   dwMajorVersion;
extern DWORD   dwMinorVersion;
extern BOOL    gbRemoteFax;

extern HANDLE    ghDsUpdateThread;
extern DWORD     gdwDsUpdateThreadId;

DWORD
SetPrinterDataPrinter(
    HANDLE  hPrinter,
    HKEY    hParentKey,
    HKEY    hKey,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData,
    DWORD   bSet
);



typedef enum {
    REG_PRINT,
    REG_PRINTERS,
    REG_PROVIDERS
} REG_PRINT_KEY;


DWORD
GetServerKeyHandle(
    PINISPOOLER     pIniSpooler,
    REG_PRINT_KEY   eKey,
    HKEY            *hPrintKey,
    PINISPOOLER*    ppIniSpoolerOut
);


DWORD
CloseServerKeyHandle(
    REG_PRINT_KEY   eKey,
    HKEY            hPrintKey,
    PINISPOOLER     pIniSpooler
);

DWORD
NonRegDsPresent(
    PINISPOOLER pIniSpooler,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
);

DWORD
NonRegDsPresentForUser(
    PINISPOOLER pIniSpooler,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
);

DWORD
NonRegGetDNSMachineName(
    PINISPOOLER pIniSpooler,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
);

DWORD
PrinterNonRegGetDefaultSpoolDirectory(
    PSPOOL      pSpool,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
);

DWORD
PrinterNonRegGetChangeId(
    PSPOOL      pSpool,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
);

DWORD
RegSetDefaultSpoolDirectory(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);

DWORD
RegSetPortThreadPriority(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);

DWORD
RegSetSchedulerThreadPriority(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);

DWORD
RegSetNoRemoteDriver(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);

DWORD
RegSetNetPopupToComputer(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);


DWORD
RegSetRestartJobOnPoolError(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);

DWORD
RegSetRestartJobOnPoolEnabled(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);


DWORD
RegSetBeepEnabled(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);

DWORD
RegSetEventLog(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);

DWORD
RegSetNetPopup(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);

DWORD
RegSetRetryPopup(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);

DWORD               dwDefaultServerThreadPriority       = DEFAULT_SERVER_THREAD_PRIORITY;
DWORD               dwDefaultSchedulerThreadPriority    = DEFAULT_SCHEDULER_THREAD_PRIORITY;
OSVERSIONINFO       OsVersionInfo;
OSVERSIONINFOEX     OsVersionInfoEx;

typedef struct {
    LPWSTR          pValue;
    BOOL            (*pSet) (   LPWSTR  pValueName,
                                DWORD   dwType,
                                LPBYTE  pData,
                                DWORD   cbData,
                                HKEY    *hKey,
                                PINISPOOLER pIniSpooler
                            );
    REG_PRINT_KEY   eKey;
} SERVER_DATA, *PSERVER_DATA;


typedef struct {
    LPWSTR      pValue;
    LPBYTE      pData;
    DWORD       dwType;
    DWORD       dwSize;
} NON_REGISTRY_DATA, *PNON_REGISTRY_DATA;

typedef struct {
    PWSTR   pValue;
    DWORD    (*pGet)(   PINISPOOLER pIniSpooler,
                        LPDWORD     pType,
                        LPBYTE      pData,
                        DWORD       nSize,
                        LPDWORD     pcbNeeded
                    );
} NON_REGISTRY_FCN, *PNON_REGISTRY_FCN;

typedef struct {
    PWSTR   pValue;
    DWORD    (*pGet)(   PSPOOL      pSpool,
                        LPDWORD     pType,
                        LPBYTE      pData,
                        DWORD       nSize,
                        LPDWORD     pcbNeeded
                    );
} PRINTER_NON_REGISTRY_FCN, *PPRINTER_NON_REGISTRY_FCN;


SERVER_DATA    gpServerRegistry[] = {{SPLREG_DEFAULT_SPOOL_DIRECTORY, RegSetDefaultSpoolDirectory, REG_PRINTERS},
                                    {SPLREG_PORT_THREAD_PRIORITY, RegSetPortThreadPriority, REG_PRINT},
                                    {SPLREG_SCHEDULER_THREAD_PRIORITY, RegSetSchedulerThreadPriority, REG_PRINT},
                                    {SPLREG_BEEP_ENABLED, RegSetBeepEnabled, REG_PRINT},
                                    {SPLREG_NET_POPUP, RegSetNetPopup, REG_PROVIDERS},
                                    {SPLREG_RETRY_POPUP, RegSetRetryPopup, REG_PROVIDERS},
                                    {SPLREG_EVENT_LOG, RegSetEventLog, REG_PROVIDERS},
                                    {SPLREG_NO_REMOTE_PRINTER_DRIVERS, RegSetNoRemoteDriver, REG_PRINT},
                                    {SPLREG_NET_POPUP_TO_COMPUTER, RegSetNetPopupToComputer, REG_PROVIDERS},
                                    {SPLREG_RESTART_JOB_ON_POOL_ERROR, RegSetRestartJobOnPoolError, REG_PROVIDERS},
                                    {SPLREG_RESTART_JOB_ON_POOL_ENABLED, RegSetRestartJobOnPoolEnabled, REG_PROVIDERS},
                                    {0,0,0}};

NON_REGISTRY_DATA gpNonRegistryData[] = {{SPLREG_PORT_THREAD_PRIORITY_DEFAULT, (LPBYTE)&dwDefaultServerThreadPriority, REG_DWORD, sizeof(DWORD)},
                                        {SPLREG_SCHEDULER_THREAD_PRIORITY_DEFAULT, (LPBYTE)&dwDefaultSchedulerThreadPriority, REG_DWORD, sizeof(DWORD)},
                                        {SPLREG_ARCHITECTURE,   (LPBYTE)&LOCAL_ENVIRONMENT, REG_SZ, 0},
                                        {SPLREG_MAJOR_VERSION,  (LPBYTE)&dwMajorVersion,    REG_DWORD,  sizeof(DWORD)},
                                        {SPLREG_MINOR_VERSION,  (LPBYTE)&dwMinorVersion,    REG_DWORD,  sizeof(DWORD)},
                                        {SPLREG_W3SVCINSTALLED, (LPBYTE)&fW3SvcInstalled,   REG_DWORD,  sizeof(DWORD)},
                                        {SPLREG_OS_VERSION,     (LPBYTE)&OsVersionInfo,     REG_BINARY, sizeof(OsVersionInfo)},
                                        {SPLREG_OS_VERSIONEX,   (LPBYTE)&OsVersionInfoEx,   REG_BINARY, sizeof(OsVersionInfoEx)},
                                        {SPLREG_REMOTE_FAX,     (LPBYTE)&gbRemoteFax,       REG_BINARY, sizeof(gbRemoteFax)},
                                        {0,0,0,0}};

NON_REGISTRY_FCN gpNonRegistryFcn[] = { {SPLREG_DS_PRESENT, NonRegDsPresent},
                                        {SPLREG_DS_PRESENT_FOR_USER, NonRegDsPresentForUser},
                                        {SPLREG_DNS_MACHINE_NAME, NonRegGetDNSMachineName},
                                        {0,0}};

PRINTER_NON_REGISTRY_FCN gpPrinterNonRegistryFcn[] =
{
    { SPLREG_DEFAULT_SPOOL_DIRECTORY, PrinterNonRegGetDefaultSpoolDirectory },
    { SPLREG_CHANGE_ID, PrinterNonRegGetChangeId },
    { 0, 0 }
};

extern WCHAR *szPrinterData;

BOOL
AvailableBidiPort(
    PINIPORT        pIniPort,
    PINIMONITOR     pIniLangMonitor
    )
{
    //
    // File ports and ports with no monitor are useless
    //
    if ( (pIniPort->Status & PP_FILE) || !(pIniPort->Status & PP_MONITOR) )
        return FALSE;

    //
    // If no LM then PM should support pfnGetPrinterDataFromPort
    //
    if ( !pIniLangMonitor &&
         !pIniPort->pIniMonitor->Monitor2.pfnGetPrinterDataFromPort )
        return FALSE;

    //
    // A port with no jobs or same monitor is printing then it is ok
    //
    return !pIniPort->pIniJob ||
           pIniLangMonitor == pIniPort->pIniLangMonitor;
}


DWORD
GetPrinterDataFromPort(
    PINIPRINTER     pIniPrinter,
    LPWSTR          pszValueName,
    LPBYTE          pData,
    DWORD           cbBuf,
    LPDWORD         pcbNeeded
    )
/*++

Routine Description:
    Tries to use GetPrinterDataFromPort monitor function to satisfy a
    GetPrinterData call

Arguments:
    pIniPrinter  - Points to an INIPRINTER

Return Value:
    Win32 error code

--*/
{
    DWORD           rc = ERROR_INVALID_PARAMETER;
    DWORD           i, dwFirstPortWithNoJobs, dwFirstPortHeld;
    PINIMONITOR     pIniLangMonitor = NULL;
    PINIPORT        pIniPort;

    SplInSem();
    //
    // Is the printer bidi enabled with the LM supporting
    // pfnGetPrinterDataFromPort? (Note: even PM can support this function)
    //
    if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_ENABLE_BIDI ) {

        pIniLangMonitor = pIniPrinter->pIniDriver->pIniLangMonitor;
        // SPLASSERT(pIniLangMonitor);

        if ( pIniLangMonitor &&
             !pIniLangMonitor->Monitor2.pfnGetPrinterDataFromPort )
            pIniLangMonitor = NULL;
    }

    //
    // Initialize to max
    //
    dwFirstPortWithNoJobs = dwFirstPortHeld = pIniPrinter->cPorts;

    for ( i = 0 ; i < pIniPrinter->cPorts ; ++i ) {

        pIniPort = pIniPrinter->ppIniPorts[i];

        //
        // Skip ports that can't be used
        //
        if ( !AvailableBidiPort(pIniPort, pIniLangMonitor) )
            continue;

        //
        // Port does not need closing?
        //
        if ( pIniLangMonitor == pIniPort->pIniLangMonitor ) {

            //
            // If no jobs also then great let's use it
            //
            if ( !pIniPort->pIniJob )
                goto PortFound;

            if ( dwFirstPortHeld == pIniPrinter->cPorts ) {

                dwFirstPortHeld = i;
            }
        } else if ( !pIniPort->pIniJob &&
                    dwFirstPortWithNoJobs == pIniPrinter->cPorts ) {

            dwFirstPortWithNoJobs = i;
        }
    }

    //
    // If all ports need closing as well as have jobs let's quit
    //
    if ( dwFirstPortWithNoJobs == pIniPrinter->cPorts &&
         dwFirstPortHeld == pIniPrinter->cPorts ) {

        return rc; //Didn't leave CS and did not unset event
    }

    //
    // We will prefer a port with no jobs (even thought it requires closing)
    //
    if ( dwFirstPortWithNoJobs < pIniPrinter->cPorts )
        pIniPort = pIniPrinter->ppIniPorts[dwFirstPortWithNoJobs];
    else
        pIniPort = pIniPrinter->ppIniPorts[dwFirstPortHeld];

PortFound:

    SPLASSERT(AvailableBidiPort(pIniPort, pIniLangMonitor));

    INCPORTREF(pIniPort);
    LeaveSplSem();
    SplOutSem();

    //
    // By unsetting the event for the duration of the GetPrinterDataFromPort
    // we make sure even if a job requiring different monitor got assigned
    // to the port it can't open/close the port.
    //
    // Since GetPrinterDataFromPort is supposed to come back fast it is ok
    //
    if ( WAIT_OBJECT_0 != WaitForSingleObject(pIniPort->hWaitToOpenOrClose,
                                              OPEN_PORT_TIMEOUT_VALUE) ) {

        DBGMSG(DBG_WARNING,
               ("GetPrinterDataFromPort: WaitForSingleObject timed-out\n"));
        goto CleanupFromOutsideSplSem; //Left CS did not unset the event
    }

    //
    // Port needs to be opened?
    //
    if ( pIniPort->pIniLangMonitor != pIniLangMonitor ||
         !pIniPort->hPort ) {

        LPTSTR pszPrinter;
        TCHAR szFullPrinter[ MAX_UNC_PRINTER_NAME ];

        //
        // A job got assigned after we left the CS and before the event
        // was reset?
        //
        if ( pIniPort->pIniJob ) {

            SetEvent(pIniPort->hWaitToOpenOrClose);
            goto CleanupFromOutsideSplSem; //Outside CS did set event
        }

        if( pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){

            pszPrinter = szFullPrinter;

            wsprintf( szFullPrinter,
                      L"%ws\\%ws",
                      pIniPrinter->pIniSpooler->pMachineName,
                      pIniPrinter->pName );
        } else {
            pszPrinter = pIniPrinter->pName;
        }

        EnterSplSem();
        if ( !OpenMonitorPort(pIniPort,
                              &pIniLangMonitor,
                              pszPrinter,
                              FALSE) ) {

            SetEvent(pIniPort->hWaitToOpenOrClose);
            goto Cleanup; //Inside CS but already set the event
        }

        LeaveSplSem();
    }

    SplOutSem();

    if ( !pIniLangMonitor )
        pIniLangMonitor = pIniPort->pIniMonitor;

    if ( (*pIniLangMonitor->Monitor2.pfnGetPrinterDataFromPort)(
              pIniPort->hPort,
              0,
              pszValueName,
              NULL,
              0,
              (LPWSTR)pData,
              cbBuf,
              pcbNeeded) ) {

        rc = ERROR_SUCCESS;
    } else {

        //
        // If monitor fails the call but did not do a SetLastError()
        // we do not want to corrupt the registry
        //
        if ( (rc = GetLastError()) == ERROR_SUCCESS ) {

            ASSERT(rc != ERROR_SUCCESS);
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    //
    // At this point we do not care if someone tries to open/close the port
    // we can set the event before entering the splsem
    //
    SetEvent(pIniPort->hWaitToOpenOrClose);

CleanupFromOutsideSplSem:
    EnterSplSem();

Cleanup:
    SplInSem();
    DECPORTREF(pIniPort);

    return rc;
}

DWORD
SplGetPrintProcCaps(
    PSPOOL   pSpool,
    LPWSTR   pDatatype,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
    )
/*++
Function Description: SplGetPrintProcCaps calls the GetPrintProcCaps function of the
                      Print processor that supports the given datatype.

Parameters:       pSpool    --  handle to the printer
                  pDatatype --  string containing the datatype
                  pData     --  pointer to buffer
                  nSize     --  size of the buffer
                  pcbNeeded --  pointer to the variable to store the required size of
                                buffer.

Return Value:  Error Code
--*/
{
    PINIPRINTPROC   pIniPrintProc;
    PINIPRINTER     pIniPrinter;
    DWORD           dwAttributes, dwIndex, dwReturn;

    // Find the print processor that supports this datatype
    pIniPrintProc = pSpool->pIniPrintProc ? pSpool->pIniPrintProc
                                          : pSpool->pIniPrinter->pIniPrintProc;

    pIniPrintProc = FindDatatype( pIniPrintProc, pDatatype);

    if (!pIniPrintProc)
    {
        return ERROR_INVALID_DATATYPE;
    }

    // Get the features supported by that print processor
    if (!pIniPrintProc->GetPrintProcCaps)
    {
        return ERROR_NOT_SUPPORTED;
    }
    else
    {
        pIniPrinter = pSpool->pIniPrinter;

        dwAttributes = pIniPrinter->Attributes;

        // Check for FILE: port which forces RAW spooling
        for (dwIndex = 0;
             dwIndex < pIniPrinter->cPorts;
             ++dwIndex)
        {
            if (!lstrcmpi(pIniPrinter->ppIniPorts[dwIndex]->pName,
                          L"FILE:"))
            {
                // Found a FILE: port
                dwAttributes |= PRINTER_ATTRIBUTE_RAW_ONLY;
                break;
            }
        }

        // Disable EMF simulated features for version < 3 drivers
        if (pIniPrinter->pIniDriver &&
            (pIniPrinter->pIniDriver->cVersion < 3))
        {
            dwAttributes |= PRINTER_ATTRIBUTE_RAW_ONLY;
        }

        LeaveSplSem();

        dwReturn  = (*(pIniPrintProc->GetPrintProcCaps))(pDatatype,
                                                         dwAttributes,
                                                         pData,
                                                         nSize,
                                                         pcbNeeded);

        EnterSplSem();

        return dwReturn;
    }
}

DWORD
SplGetNonRegData(
    PINISPOOLER         pIniSpooler,
    LPDWORD             pType,
    LPBYTE              pData,
    DWORD               nSize,
    LPDWORD             pcbNeeded,
    PNON_REGISTRY_DATA  pNonRegData
    )
{
    if ( pNonRegData->dwType == REG_SZ && pNonRegData->dwSize == 0 )
        *pcbNeeded = wcslen((LPWSTR) pNonRegData->pData) * sizeof(WCHAR) + sizeof(WCHAR);
    else
        *pcbNeeded = pNonRegData->dwSize;

    if ( *pcbNeeded > nSize )
        return ERROR_MORE_DATA;

    CopyMemory(pData, (LPBYTE)pNonRegData->pData, *pcbNeeded);
    *pType = pNonRegData->dwType;

    return ERROR_SUCCESS;
}


DWORD
SplGetPrinterData(
    HANDLE   hPrinter,
    LPWSTR   pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
    )
{
    PSPOOL              pSpool=(PSPOOL)hPrinter;
    DWORD               rc = ERROR_INVALID_HANDLE;
    DWORD               dwResult;
    PSERVER_DATA        pRegistry;  // points to table of Print Server registry entries
    PNON_REGISTRY_DATA  pNonReg;
    PNON_REGISTRY_FCN   pNonRegFcn;
    HKEY                hPrintKey;
    PINIPRINTER         pIniPrinter;
    HKEY                hKey = NULL;
    DWORD               dwType;
    PINISPOOLER         pIniSpoolerOut;
    HANDLE              hToken = NULL;
    WCHAR               szPrintProcKey[] = L"PrintProcCaps_";
    LPWSTR              pDatatype;

    if (!ValidateSpoolHandle(pSpool, 0)) {
        return rc;
    }

    if (!pValueName || !pcbNeeded) {
        rc = ERROR_INVALID_PARAMETER;
        return rc;
    }

    if (pType)
        dwType = *pType;        // pType may be NULL

    // Server Handle
    if (pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) {

        // Check Registry Table
        for (pRegistry = gpServerRegistry ; pRegistry->pValue ; ++pRegistry) {

            if (!_wcsicmp(pRegistry->pValue, pValueName)) {

                //
                // Retrieve the handle for the Get.
                if ((rc = GetServerKeyHandle(pSpool->pIniSpooler,
                                             pRegistry->eKey,
                                             &hPrintKey,
                                             &pIniSpoolerOut)) == ERROR_SUCCESS) {

                    *pcbNeeded = nSize;
                    rc = SplRegQueryValue(hPrintKey, pValueName, pType, pData, pcbNeeded, pIniSpoolerOut);

                    CloseServerKeyHandle( pRegistry->eKey,
                                          hPrintKey,
                                          pIniSpoolerOut );
                }
                break;
            }
        }

        if (!pRegistry->pValue) {   // May be a non-registry entry

            for (pNonReg = gpNonRegistryData ; pNonReg->pValue ; ++pNonReg) {
                if (!_wcsicmp(pNonReg->pValue, pValueName)) {

                    rc = SplGetNonRegData(pSpool->pIniSpooler,
                                          &dwType,
                                          pData,
                                          nSize,
                                          pcbNeeded,
                                          pNonReg);

                    if (pType)
                        *pType = dwType;

                    goto FinishNonReg;
                }
            }

            for (pNonRegFcn = gpNonRegistryFcn ; pNonRegFcn->pValue ; ++pNonRegFcn) {
                if (!_wcsicmp(pNonRegFcn->pValue, pValueName)) {

                    rc = (*pNonRegFcn->pGet)(pSpool->pIniSpooler, &dwType, pData, nSize, pcbNeeded);

                    if (pType)
                        *pType = dwType;

                    goto FinishNonReg;
                }
            }

FinishNonReg:

            if (!pNonReg->pValue && !pNonRegFcn->pValue) {
                rc = ERROR_INVALID_PARAMETER;
            }
        }
    // Printer handle
    } else {

        PPRINTER_NON_REGISTRY_FCN pPrinterNonRegFcn;

        EnterSplSem();
        pIniPrinter = pSpool->pIniPrinter;

        SPLASSERT(pIniPrinter && pIniPrinter->signature == IP_SIGNATURE);

        //
        // If the pValueName is "PrintProcCaps_[datatype]" call the print processor which
        // supports that datatype and return the options that it supports.
        //
        if (pValueName == wcsstr(pValueName, szPrintProcKey)) {

           pDatatype = (LPWSTR) (pValueName+(wcslen(szPrintProcKey)));
           if (!pDatatype) {

              LeaveSplSem();
              return ERROR_INVALID_DATATYPE;
           } else {

               rc = SplGetPrintProcCaps(pSpool,
                                        pDatatype,
                                        pData,
                                        nSize,
                                        pcbNeeded);
               LeaveSplSem();
               return rc;
           }
        }

        //
        // Check for PrinterNonReg calls.
        //
        for (pPrinterNonRegFcn = gpPrinterNonRegistryFcn ;
             pPrinterNonRegFcn->pValue ;
             ++pPrinterNonRegFcn) {

            if (!_wcsicmp(pPrinterNonRegFcn->pValue, pValueName)) {

                rc = (*pPrinterNonRegFcn->pGet)( pSpool,
                                                 &dwType,
                                                 pData,
                                                 nSize,
                                                 pcbNeeded );

                if( pType ){
                    *pType = dwType;
                }
                LeaveSplSem();
                return rc;
            }
        }

        if (pIniPrinter->Status & PRINTER_PENDING_CREATION) {
            LeaveSplSem();
            rc = ERROR_INVALID_PRINTER_STATE;

        } else {

            //
            // During upgrade do not try to talk to the port since we
            // will not be on the net
            //
            if ( dwUpgradeFlag == 0         &&
                 AccessGranted(SPOOLER_OBJECT_PRINTER,
                               PRINTER_ACCESS_ADMINISTER,
                               pSpool ) ) {

                rc = GetPrinterDataFromPort(pIniPrinter,
                                            pValueName,
                                            pData,
                                            nSize,
                                            pcbNeeded);
            }

            hToken = RevertToPrinterSelf();

            dwResult = OpenPrinterKey(pIniPrinter,
                                     KEY_READ | KEY_WRITE,
                                     &hKey,
                                     szPrinterData,
                                     FALSE);

            if (hToken)
                ImpersonatePrinterClient(hToken);

            if (dwResult != ERROR_SUCCESS) {
                LeaveSplSem();
                return dwResult;
            }

            if ( rc == ERROR_SUCCESS ) {

                *pType = REG_BINARY;

                (VOID)SetPrinterDataPrinter(hPrinter,
                                            NULL,
                                            hKey,
                                            pValueName,
                                            *pType,
                                            pData,
                                            *pcbNeeded,
                                            SET_PRINTER_DATA);

            } else if ( rc != ERROR_INSUFFICIENT_BUFFER ) {

                *pcbNeeded = nSize;
                rc = SplRegQueryValue( hKey,
                                       pValueName,
                                       pType,
                                       pData,
                                       pcbNeeded,
                                       pIniPrinter->pIniSpooler );
            }

            LeaveSplSem();
        }
    }


    if (hKey)
        SplRegCloseKey(hKey, pIniPrinter->pIniSpooler);

    SplOutSem();

    return rc;
}



DWORD
SplGetPrinterDataEx(
    HANDLE   hPrinter,
    LPCWSTR  pKeyName,
    LPCWSTR  pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
    )
{
    PSPOOL              pSpool=(PSPOOL)hPrinter;
    DWORD               rc = ERROR_INVALID_HANDLE;
    PSERVER_DATA        pRegistry;  // points to table of Print Server registry entries
    PINIPRINTER         pIniPrinter;
    HKEY                hKey = NULL;
    HANDLE              hToken = NULL;


    if (!ValidateSpoolHandle(pSpool, 0)) {
        goto Cleanup;
    }

    if (!pValueName || !pcbNeeded) {
        rc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) {
        rc = SplGetPrinterData( hPrinter,
                                (LPWSTR) pValueName,
                                pType,
                                pData,
                                nSize,
                                pcbNeeded);

    } else {

        if (!pKeyName || !*pKeyName) {
            rc = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        EnterSplSem();

        pIniPrinter = pSpool->pIniPrinter;
        INCPRINTERREF(pIniPrinter);

        SPLASSERT(pIniPrinter && pIniPrinter->signature == IP_SIGNATURE);

        if (pIniPrinter->Status & PRINTER_PENDING_CREATION) {
            LeaveSplSem();
            rc = ERROR_INVALID_PRINTER_STATE;

        } else if (!_wcsicmp(pKeyName, szPrinterData)) {
            LeaveSplSem();
            rc = SplGetPrinterData( hPrinter,
                                    (LPWSTR) pValueName,
                                    pType,
                                    pData,
                                    nSize,
                                    pcbNeeded);
        } else {

            hToken = RevertToPrinterSelf();

            rc = OpenPrinterKey(pIniPrinter, KEY_READ, &hKey, pKeyName, TRUE);

            LeaveSplSem();

            if (rc == ERROR_SUCCESS) {
                *pcbNeeded = nSize;
                rc = SplRegQueryValue(hKey,
                                      pValueName,
                                      pType,
                                      pData,
                                      pcbNeeded,
                                      pIniPrinter->pIniSpooler);
            }
        }

        EnterSplSem();
        if (hKey)
            SplRegCloseKey(hKey, pIniPrinter->pIniSpooler);

        DECPRINTERREF(pIniPrinter);
        LeaveSplSem();
    }

Cleanup:

    SplOutSem();

    if (hToken)
        ImpersonatePrinterClient(hToken);


    return rc;
}




DWORD
SplEnumPrinterData(
    HANDLE  hPrinter,
    DWORD   dwIndex,        // index of value to query
    LPWSTR  pValueName,     // address of buffer for value string
    DWORD   cbValueName,    // size of buffer for value string
    LPDWORD pcbValueName,   // address for size of value buffer
    LPDWORD pType,          // address of buffer for type code
    LPBYTE  pData,          // address of buffer for value data
    DWORD   cbData,         // size of buffer for value data
    LPDWORD pcbData         // address for size of data buffer
)
{
    PSPOOL      pSpool=(PSPOOL)hPrinter;
    DWORD       rc = ERROR_INVALID_HANDLE;
    HKEY        hKey = NULL;
    PINIPRINTER pIniPrinter;
    HANDLE      hToken = NULL;


    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {
        return rc;
    }

    if (!pValueName || !pcbValueName) {
        rc = ERROR_INVALID_PARAMETER;
        return rc;
    }


    EnterSplSem();
    pIniPrinter = pSpool->pIniPrinter;

    SPLASSERT(pIniPrinter && pIniPrinter->signature == IP_SIGNATURE);

    if (pIniPrinter->Status & PRINTER_PENDING_CREATION) {
        LeaveSplSem();
        rc = ERROR_INVALID_PRINTER_STATE;

    } else {

        hToken = RevertToPrinterSelf();

        rc = OpenPrinterKey(pSpool->pIniPrinter, KEY_READ, &hKey, szPrinterData, TRUE);

        if (hToken)
            ImpersonatePrinterClient(hToken);

        LeaveSplSem();

        if (rc == ERROR_SUCCESS) {
            if (!cbValueName && !cbData) {    // Both sizes are NULL, so user wants to get buffer sizes

                rc = SplRegQueryInfoKey( hKey,
                                         NULL,
                                         NULL,
                                         NULL,
                                         pcbValueName,
                                         pcbData,
                                         NULL,
                                         NULL,
                                         pIniPrinter->pIniSpooler );

            } else {
                *pcbValueName = cbValueName/sizeof(WCHAR);
                *pcbData = cbData;
                rc = SplRegEnumValue( hKey,
                                      dwIndex,
                                      pValueName,
                                      pcbValueName,
                                      pType,
                                      pData,
                                      pcbData,
                                      pIniPrinter->pIniSpooler );

                *pcbValueName = (*pcbValueName + 1)*sizeof(WCHAR);
            }

            SplRegCloseKey(hKey, pIniPrinter->pIniSpooler);
        }
    }

    return rc;
}


DWORD
SplEnumPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,         // key name
    LPBYTE  pEnumValueStart,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues      // number of values returned
)
{
    PSPOOL      pSpool=(PSPOOL)hPrinter;
    BOOL        bRet = FALSE;
    DWORD       rc = ERROR_SUCCESS;
    PINIPRINTER pIniPrinter;
    HKEY        hKey = NULL;
    DWORD       i;
    LPWSTR      pNextValueName, pValueName = NULL;
    LPBYTE      pData = NULL;
    PPRINTER_ENUM_VALUES pEnumValue;
    DWORD       cchValueName, cbData, cchValueNameTemp, cbDataTemp;
    DWORD       dwType, cbSourceDir=0, cbTargetDir=0;
    HANDLE      hToken = NULL;
    LPWSTR      pszSourceDir = NULL, pszTargetDir = NULL;
    
    EnterSplSem();

    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {
        LeaveSplSem();
        return ERROR_INVALID_HANDLE;
    }

    if (!pKeyName || !*pKeyName) {
        LeaveSplSem();
        return ERROR_INVALID_PARAMETER;
    }

    *pcbEnumValues = 0;
    *pnEnumValues = 0;

    pIniPrinter = pSpool->pIniPrinter;

    SPLASSERT(pIniPrinter && pIniPrinter->signature == IP_SIGNATURE);

    if (pIniPrinter->Status & PRINTER_PENDING_CREATION) {
        LeaveSplSem();
        rc = ERROR_INVALID_PRINTER_STATE;
        goto Cleanup;
    }

    // open specified key
    hToken = RevertToPrinterSelf();

    rc = OpenPrinterKey(pIniPrinter, KEY_READ, &hKey, pKeyName, TRUE);

    LeaveSplSem();

    if (rc != ERROR_SUCCESS) {
        goto Cleanup;
    }

    do {
        // Get the max size
        rc = SplRegQueryInfoKey( hKey,
                                 NULL,
                                 NULL,
                                 pnEnumValues,
                                 &cchValueName,
                                 &cbData,
                                 NULL,
                                 NULL,
                                 pIniPrinter->pIniSpooler );

        if (rc != ERROR_SUCCESS)
            goto Cleanup;

        cchValueName = (cchValueName + 1);
        cbData = (cbData + 1) & ~1;

        // Allocate temporary buffers to determine true required size
        if (!(pValueName = AllocSplMem(cchValueName * sizeof (WCHAR)))) {
            rc = GetLastError();
            goto Cleanup;
        }

        if (!(pData = AllocSplMem(cbData))) {
            rc = GetLastError();
            goto Cleanup;
        }

        // Run through Values and accumulate sizes
        for (i = 0 ; rc == ERROR_SUCCESS && i < *pnEnumValues ; ++i) {

            cchValueNameTemp = cchValueName;
            cbDataTemp = cbData;

            rc = SplRegEnumValue( hKey,
                                  i,
                                  pValueName,
                                  &cchValueNameTemp,
                                  &dwType,
                                  pData,
                                  &cbDataTemp,
                                  pIniPrinter->pIniSpooler);

            *pcbEnumValues = (DWORD) AlignToRegType(*pcbEnumValues, REG_SZ) + 
                             (cchValueNameTemp + 1)*sizeof(WCHAR);

            *pcbEnumValues = (DWORD) AlignToRegType(*pcbEnumValues, dwType) + 
                             cbDataTemp;
        }

        //
        // If the key is a sub key of "CopyFiles" we need to generate
        // the paths for the source/target directories if the call is remote
        //
        if ( (pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_DATA)     &&
             !wcsncmp(pKeyName, L"CopyFiles\\", wcslen(L"CopyFiles\\")) ) {

            if ( !GenerateDirectoryNamesForCopyFilesKey(pSpool,
                                                        hKey,
                                                        &pszSourceDir,
                                                        &pszTargetDir,
                                                        cchValueName*sizeof (WCHAR)) ) {

                rc = GetLastError();
                goto Cleanup;

            } else {

                SPLASSERT(pszSourceDir && pszTargetDir);

                if ( pszSourceDir ) {

                    cbSourceDir = (wcslen(pszSourceDir) + 1)*sizeof(WCHAR);

                    *pcbEnumValues = (DWORD) AlignToRegType(*pcbEnumValues, REG_SZ) + 
                                     sizeof(L"SourceDir") + sizeof(WCHAR);

                    *pcbEnumValues = (DWORD) AlignToRegType(*pcbEnumValues, REG_SZ) + 
                                     cbSourceDir;

                    (*pnEnumValues)++;
                }
                if ( pszTargetDir ) {

                    cbTargetDir = (wcslen(pszTargetDir) + 1)*sizeof(WCHAR);

                    *pcbEnumValues = (DWORD) AlignToRegType(*pcbEnumValues, REG_SZ) + 
                                     sizeof(L"TargetDir") + sizeof(WCHAR);

                    *pcbEnumValues = (DWORD) AlignToRegType(*pcbEnumValues, REG_SZ) + 
                                     cbTargetDir;                            

                    (*pnEnumValues)++;
                }
            }
        }

        *pcbEnumValues += sizeof(PRINTER_ENUM_VALUES)**pnEnumValues;
        
        if (rc == ERROR_SUCCESS) {
            if (*pcbEnumValues > cbEnumValues) {
                rc = ERROR_MORE_DATA;
                break;

            } else {

                // Adjust pointers & Get data
                pEnumValue = (PPRINTER_ENUM_VALUES) pEnumValueStart;

                pNextValueName = (LPWSTR) (pEnumValueStart + *pnEnumValues*sizeof(PRINTER_ENUM_VALUES));

                pNextValueName = (LPWSTR) AlignToRegType((ULONG_PTR)pNextValueName, REG_SZ);

                for(i = 0 ; rc == ERROR_SUCCESS && i < *pnEnumValues ; ++i, ++pEnumValue) {

                    // bytes left in the allocated buffer
                    DWORD cbRemaining = (DWORD)(pEnumValueStart + cbEnumValues - (LPBYTE)pNextValueName);

                    pEnumValue->pValueName  = pNextValueName;
                    // use minimum of cbRemaining and max size
                    pEnumValue->cbValueName = (cbRemaining < cchValueName*sizeof (WCHAR))
                        ? cbRemaining :  cchValueName*sizeof (WCHAR);
                    pEnumValue->cbData = cbData;

                    if ( i == *pnEnumValues - 2 && cbSourceDir ) {

                        pEnumValue->dwType      = REG_SZ;

                        pEnumValue->cbData      = cbSourceDir;

                        pEnumValue->cbValueName = sizeof(L"SourceDir") + sizeof(WCHAR);

                        pEnumValue->pData = (LPBYTE) pEnumValue->pValueName +
                                                     pEnumValue->cbValueName;

                        pEnumValue->pData = (LPBYTE) AlignToRegType((ULONG_PTR)pEnumValue->pData, 
                                                                    pEnumValue->dwType);

                        wcscpy(pEnumValue->pValueName, L"SourceDir");

                        wcscpy((LPWSTR)pEnumValue->pData, pszSourceDir);

                    } else if ( i == *pnEnumValues - 1 && cbTargetDir ) {

                        pEnumValue->dwType      = REG_SZ;

                        pEnumValue->cbData      = cbTargetDir;

                        pEnumValue->cbValueName = sizeof(L"TargetDir") +
                                                  sizeof(WCHAR);

                        pEnumValue->pData = (LPBYTE) pEnumValue->pValueName +
                                                     pEnumValue->cbValueName;

                        pEnumValue->pData = (LPBYTE) AlignToRegType((ULONG_PTR )pEnumValue->pData, 
                                                                     pEnumValue->dwType);

                        wcscpy(pEnumValue->pValueName, L"TargetDir");

                        wcscpy((LPWSTR)pEnumValue->pData, pszTargetDir);

                    } else {
                        DWORD cchValueName = pEnumValue->cbValueName / sizeof (WCHAR);
 
                        // adjust to count of characters
                        rc = SplRegEnumValue(hKey,
                                             i,
                                             pEnumValue->pValueName,
                                             &cchValueName,
                                             &pEnumValue->dwType,
                                             pData,
                                             &pEnumValue->cbData,
                                             pIniPrinter->pIniSpooler);

                        pEnumValue->cbValueName = (cchValueName + 1)*sizeof(WCHAR);

                        pEnumValue->pData = (LPBYTE) pEnumValue->pValueName + pEnumValue->cbValueName;

                        pEnumValue->pData = (LPBYTE) AlignToRegType((ULONG_PTR)pEnumValue->pData, 
                                                                     pEnumValue->dwType);

                        CopyMemory(pEnumValue->pData, pData, pEnumValue->cbData);
                    }

                    if (i + 1 < *pnEnumValues) {
                        pNextValueName = (LPWSTR) AlignToRegType((ULONG_PTR)(pEnumValue->pData + 
                                                                 pEnumValue->cbData), REG_SZ);
                    }

                    if (pEnumValue->cbData == 0) {
                        pEnumValue->pData = NULL;
                    }

                }
                if (rc == ERROR_NO_MORE_ITEMS)
                    rc = ERROR_SUCCESS;
            }
        }

        FreeSplMem(pValueName);
        FreeSplMem(pData);
        pValueName = (LPWSTR) pData = NULL;

    } while(rc == ERROR_MORE_DATA);

    if ( rc == ERROR_SUCCESS )
        bRet = TRUE;

Cleanup:

    SplOutSem();

    FreeSplStr(pszTargetDir);
    FreeSplStr(pszSourceDir);

    FreeSplMem(pValueName);
    FreeSplMem(pData);

    // Close handle
    if (hKey)
        SplRegCloseKey(hKey, pIniPrinter->pIniSpooler);

    if (hToken)
        ImpersonatePrinterClient(hToken);

    if ( !bRet && rc == ERROR_SUCCESS ) {

        // SPLASSERT(dwLastError == ERROR_SUCCESS); -- after ICM is fixed
        rc = ERROR_INVALID_PARAMETER;
    }

    return rc;
}


DWORD
SplEnumPrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,       // key name
    LPWSTR  pSubKey,        // address of buffer for value string
    DWORD   cbSubKey,       // size of buffer for value string
    LPDWORD pcbSubKey       // address for size of value buffer
)
{
    HKEY        hKey = NULL;
    PSPOOL      pSpool=(PSPOOL)hPrinter;
    DWORD       rc = ERROR_SUCCESS;
    PINIPRINTER pIniPrinter;
    PINISPOOLER pIniSpooler;
    LPWSTR      pRootKeyName;
    DWORD       cbSubKeyMax;
    DWORD       cwSubKeyMax;
    DWORD       cwSubKey, cwSubKeyTotal, cbSubKeyTotal, cwSubKeyOutput;
    DWORD       dwIndex;
    DWORD       nSubKeys;
    LPWSTR      pKeys = NULL;
    HANDLE      hToken = NULL;


    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {
        return ERROR_INVALID_HANDLE;
    }

    if (!pKeyName || !pcbSubKey) {
        return ERROR_INVALID_PARAMETER;
    }

    EnterSplSem();

    pIniPrinter = pSpool->pIniPrinter;

    SPLASSERT(pIniPrinter && pIniPrinter->signature == IP_SIGNATURE);

    if (pIniPrinter->Status & PRINTER_PENDING_CREATION) {
        LeaveSplSem();
        rc = ERROR_INVALID_PRINTER_STATE;
        goto Cleanup;
    }

    // open specified key
    hToken = RevertToPrinterSelf();

    rc = OpenPrinterKey(pIniPrinter, KEY_READ, &hKey, pKeyName, TRUE);

    LeaveSplSem();

    if (rc != ERROR_SUCCESS)
        goto Cleanup;

    do {

        // Get the max size
        rc = SplRegQueryInfoKey( hKey,           // Key
                                 &nSubKeys,      // lpcSubKeys
                                 &cwSubKeyMax,   // lpcbMaxSubKeyLen
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 pIniPrinter->pIniSpooler );

        if (rc != ERROR_SUCCESS)
            goto Cleanup;


        ++cwSubKeyMax;  // Add terminating NULL
        cbSubKeyMax = (cwSubKeyMax + 1)*sizeof(WCHAR);

        if (!(pKeys = AllocSplMem(cbSubKeyMax))) {
            rc = GetLastError();
            goto Cleanup;
        }


        // Enumerate keys to get exact size
        for(dwIndex = cwSubKeyTotal = 0 ; dwIndex < nSubKeys && rc == ERROR_SUCCESS ; ++dwIndex) {

            cwSubKey = cwSubKeyMax;

            rc = SplRegEnumKey( hKey,
                                dwIndex,
                                pKeys,
                                &cwSubKey,
                                NULL,
                                pIniPrinter->pIniSpooler );

            cwSubKeyTotal += cwSubKey + 1;
        }

        //
        // cwSubKeyTotal is being reset in the initialization list of the foor loop. Thus
        // its value is not accurate if we do not enter the loop at all (when nSubKeys is 0)
        //
        *pcbSubKey = nSubKeys ? cwSubKeyTotal*sizeof(WCHAR) + sizeof(WCHAR) : 2*sizeof(WCHAR);


        if (rc == ERROR_SUCCESS) {
            if(*pcbSubKey > cbSubKey) {
                rc = ERROR_MORE_DATA;
                break;

            } else {

                //
                // cwSubKeyOutput is the size of the output buffer in wchar
                //
                cwSubKeyOutput = cbSubKey/sizeof(WCHAR);

                for(dwIndex = cwSubKeyTotal = 0 ; dwIndex < nSubKeys && rc == ERROR_SUCCESS ; ++dwIndex) {

                    //
                    // Calculate the remaining output buffer size in characters.
                    // If we're out of room, exit with ERROR_MORE_DATA.
                    // This is needed since it is possible the registry has changed.
                    //
                    if (cwSubKeyOutput < cwSubKeyTotal + 1) {
                        rc = ERROR_MORE_DATA;
                        break;
                    }
                    cwSubKey = cwSubKeyOutput - cwSubKeyTotal;

                    rc = SplRegEnumKey( hKey,
                                        dwIndex,
                                        pSubKey + cwSubKeyTotal,
                                        &cwSubKey,
                                        NULL,
                                        pIniPrinter->pIniSpooler );

                    cwSubKeyTotal += cwSubKey + 1;
                }

                //
                // cwSubKeyTotal is being reset in the initialization list of the foor loop. Thus
                // its value is not accurate if we do not enter the loop at all (when nSubKeys is 0)
                // If we don't enter the for loop, then we don't need to update *pcbSubKey
                //
                if (nSubKeys && (dwIndex == nSubKeys || rc == ERROR_NO_MORE_ITEMS)) {
                    //
                    // Get the most recent data size just in case something changed
                    //
                    *pcbSubKey = cwSubKeyTotal*sizeof(WCHAR) + sizeof(WCHAR);
                    rc = ERROR_SUCCESS;
                }
            }
        }
        FreeSplMem(pKeys);
        pKeys = NULL;

    } while(rc == ERROR_MORE_DATA);

Cleanup:

    // Close handles
    if (hKey)
        SplRegCloseKey(hKey, pIniPrinter->pIniSpooler);

    FreeSplMem(pKeys);

    if (hToken)
        ImpersonatePrinterClient(hToken);

    return rc;
}


DWORD
SplDeletePrinterData(
    HANDLE  hPrinter,
    LPWSTR  pValueName
)
{
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   rc = ERROR_INVALID_HANDLE;
    HKEY    hKey = NULL;
    HANDLE  hToken = NULL;

    EnterSplSem();

    if (ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {

        hToken = RevertToPrinterSelf();

        rc = OpenPrinterKey(pSpool->pIniPrinter, KEY_WRITE, &hKey, szPrinterData, FALSE);

        if (hToken)
            ImpersonatePrinterClient(hToken);

        if (rc == ERROR_SUCCESS) {

            rc = SetPrinterDataPrinter( hPrinter,
                                        NULL,
                                        hKey,
                                        pValueName,
                                        0, NULL, 0, DELETE_PRINTER_DATA);

            SplRegCloseKey(hKey, pSpool->pIniPrinter->pIniSpooler);
        }
    }

    LeaveSplSem();

    return rc;
}


DWORD
SplDeletePrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName
)
{
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   rc = ERROR_INVALID_HANDLE;
    HANDLE  hToken = NULL;
    HKEY    hKey = NULL;

    if (!pKeyName || !*pKeyName) {
        return ERROR_INVALID_PARAMETER;
    }

    EnterSplSem();

    if (ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {

        hToken = RevertToPrinterSelf();

        rc = OpenPrinterKey(pSpool->pIniPrinter, KEY_WRITE, &hKey, pKeyName, TRUE);

        if (hToken)
            ImpersonatePrinterClient(hToken);

        if (rc == ERROR_SUCCESS)
            rc = SetPrinterDataPrinter(hPrinter,
                                       NULL,
                                       hKey,
                                       (LPWSTR) pValueName,
                                       0, NULL, 0, DELETE_PRINTER_DATA);
    }

    LeaveSplSem();

    if (hKey)
        SplRegCloseKey(hKey, pSpool->pIniSpooler);

    return rc;
}


DWORD
SplDeletePrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName
)
{
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   rc = ERROR_INVALID_HANDLE;
    HANDLE  hToken = NULL;
    HKEY    hKey = NULL, hPrinterKey = NULL;

    if (!pKeyName)
        return ERROR_INVALID_PARAMETER;

    EnterSplSem();

    if (ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {

        hToken = RevertToPrinterSelf();

        rc = OpenPrinterKey(pSpool->pIniPrinter, KEY_WRITE | KEY_READ, &hKey, pKeyName, TRUE);

        if (rc == ERROR_SUCCESS)
            rc = OpenPrinterKey(pSpool->pIniPrinter, KEY_WRITE | KEY_READ, &hPrinterKey, NULL, TRUE);

        if (hToken)
            ImpersonatePrinterClient(hToken);

        if (rc == ERROR_SUCCESS) {
            rc = SetPrinterDataPrinter(hPrinter,
                                       hPrinterKey,
                                       hKey,
                                       (LPWSTR) pKeyName,
                                       0, NULL, 0, DELETE_PRINTER_KEY);

        }
    }

    LeaveSplSem();

    if (hPrinterKey)
        SplRegCloseKey(hPrinterKey, pSpool->pIniSpooler);


    return rc;
}


DWORD
SplSetPrinterData(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   rc = ERROR_INVALID_HANDLE;
    HANDLE  hToken = NULL;
    HKEY    hKey = NULL;

    EnterSplSem();

    if (!ValidateSpoolHandle(pSpool, 0)) {
        LeaveSplSem();
        return rc;
    }


    if (pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) {

        if ( !ValidateObjectAccess( SPOOLER_OBJECT_SERVER,
                                    SERVER_ACCESS_ADMINISTER,
                                    NULL, NULL, pSpool->pIniSpooler)) {

            rc = ERROR_ACCESS_DENIED;

        } else {

            rc = SetPrinterDataServer(pSpool->pIniSpooler, pValueName, Type, pData, cbData);
        }
    } else {

        hToken = RevertToPrinterSelf();

        rc = OpenPrinterKey(pSpool->pIniPrinter, KEY_READ | KEY_WRITE, &hKey, szPrinterData, FALSE);

        if (hToken)
            ImpersonatePrinterClient(hToken);

        if (rc == ERROR_SUCCESS) {
            rc = SetPrinterDataPrinter( hPrinter,
                                        NULL,
                                        hKey,
                                        pValueName,
                                        Type, pData, cbData, SET_PRINTER_DATA);

            SplRegCloseKey(hKey, pSpool->pIniPrinter->pIniSpooler);
        }
    }

    LeaveSplSem();

    return rc;
}


DWORD
SplSetPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   rc = ERROR_INVALID_HANDLE;
    HANDLE  hToken = NULL;
    PINIPRINTER pIniPrinter;
    PINIJOB pIniJob;
    HKEY    hKey = NULL;
    PINISPOOLER pIniSpooler;
    LPWSTR  pPrinterKeyName;
    DWORD   DsUpdate = 0;


    if (!ValidateSpoolHandle(pSpool, 0)){
        goto Done;
    }

    if (!pValueName) {
        rc = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    if (pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) {
        return SplSetPrinterData(hPrinter, (LPWSTR) pValueName, Type, pData, cbData);
    }

    if (!pKeyName || !*pKeyName) {
        rc = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    if (!_wcsicmp(szPrinterData, pKeyName)) {
        return SplSetPrinterData(hPrinter, (LPWSTR) pValueName, Type, pData, cbData);
    }

    EnterSplSem();
    pIniPrinter = pSpool->pIniPrinter;
    pIniSpooler = pIniPrinter->pIniSpooler;

    DBGMSG( DBG_EXEC, ("SetPrinterDataEx: %ws %ws %ws %d cbSize=cbData\n",
                       pIniPrinter->pName,
                       pKeyName,
                       pValueName,
                       Type,
                       cbData ));

    SPLASSERT(pIniPrinter &&
              pIniPrinter->signature == IP_SIGNATURE);

    if ( !AccessGranted( SPOOLER_OBJECT_PRINTER,
                         PRINTER_ACCESS_ADMINISTER,
                         pSpool ) ) {

        rc = ERROR_ACCESS_DENIED;
        goto DoneFromSplSem;
    }

    hToken = RevertToPrinterSelf();

    // If this is a DS Key then parse out OID, if any, and write to Registry
    // Also check that data type is correct
    if (!wcscmp(pKeyName, SPLDS_SPOOLER_KEY)){
        DsUpdate = DS_KEY_SPOOLER;
    } else if (!wcscmp(pKeyName, SPLDS_DRIVER_KEY)){
        DsUpdate = DS_KEY_DRIVER;
    } else if (!wcscmp(pKeyName, SPLDS_USER_KEY)){
        DsUpdate = DS_KEY_USER;
    }

    if (DsUpdate) {
        if (Type != REG_SZ && Type != REG_MULTI_SZ && Type != REG_DWORD && !(Type == REG_BINARY && cbData == 1)) {
            rc = ERROR_INVALID_PARAMETER;
            goto DoneFromSplSem;
        }
    }

    // Open or Create the key
    // Create the hPrinterKey if it doesn't exist
    rc = OpenPrinterKey(pIniPrinter,
                        KEY_READ | KEY_WRITE,
                        &hKey,
                        pKeyName,
                        FALSE);
    if (rc != ERROR_SUCCESS)
        goto DoneFromSplSem;


    // Set the value
    rc = SplRegSetValue(hKey,
                        pValueName,
                        Type,
                        pData,
                        cbData,
                        pIniPrinter->pIniSpooler );
    if (rc != ERROR_SUCCESS)
        goto DoneFromSplSem;

    //
    // Set Data succeeded. If the color profiles assocaiated with the
    // print queue were updated we send a notification. TS listens for it
    // and saves print queues settings. Updating color profiles implies
    // touching 4 regitry keys. We want to send the notify only after the
    // last key is updated.
    //
    if (!_wcsicmp(pKeyName, L"CopyFiles\\ICM") &&
        !_wcsicmp(pValueName, L"Module")) 
    {
        UpdatePrinterIni(pIniPrinter, CHANGEID_ONLY);

        SetPrinterChange(pIniPrinter,
                         NULL,
                         NULL,
                         PRINTER_CHANGE_SET_PRINTER_DRIVER,
                         pSpool->pIniSpooler );
    }


    if (hToken) {
        ImpersonatePrinterClient(hToken);
        hToken = NULL;
    }

    if (ghDsUpdateThread && gdwDsUpdateThreadId == GetCurrentThreadId()) {
        // We are in the background thread
        pIniPrinter->DsKeyUpdate |= DsUpdate;
    } else {
        pIniPrinter->DsKeyUpdateForeground |= DsUpdate;
    }
    UpdatePrinterIni(pIniPrinter, UPDATE_DS_ONLY);

DoneFromSplSem:

    if (hToken) {
        ImpersonatePrinterClient(hToken);
    }

    LeaveSplSem();

    if ( rc == ERROR_SUCCESS    &&
         !wcsncmp(pKeyName, L"CopyFiles\\", wcslen(L"CopyFiles\\")) ) {

        (VOID)SplCopyFileEvent(pSpool,
                               (LPWSTR)pKeyName,
                               COPYFILE_EVENT_SET_PRINTER_DATAEX);
    }

Done:

    DBGMSG( DBG_EXEC, ("SetPrinterDataEx: return %d\n", rc));

    if (hKey) {
        SplRegCloseKey(hKey, pIniPrinter->pIniSpooler);
    }

    return rc;
}


// SetPrinterDataServer - also called during initialization
DWORD
SetPrinterDataServer(
    PINISPOOLER pIniSpooler,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    LPWSTR  pKeyName;
    DWORD    rc;
    HANDLE  hToken = NULL;
    PINIPRINTER pIniPrinter;
    PINIJOB pIniJob;
    PSERVER_DATA    pRegistry;  // points to table of Print Server registry entries
    HKEY hKey;
    PINISPOOLER pIniSpoolerOut;


    // Server Handle

    if (!pValueName) {

        rc =  ERROR_INVALID_PARAMETER;

    } else {

        for (pRegistry = gpServerRegistry ; pRegistry->pValue ; ++pRegistry) {

            if (!_wcsicmp(pRegistry->pValue, pValueName)) {

                if ((rc = GetServerKeyHandle( pIniSpooler,
                                              pRegistry->eKey,
                                              &hKey,
                                              &pIniSpoolerOut)) == ERROR_SUCCESS) {

                    hToken = RevertToPrinterSelf();

                    if (pRegistry->pSet) {
                        rc = (*pRegistry->pSet)(pValueName, Type, pData, cbData, hKey, pIniSpoolerOut);
                    }
                    else {
                        rc = ERROR_INVALID_PARAMETER;
                    }

                    CloseServerKeyHandle( pRegistry->eKey,
                                          hKey,
                                          pIniSpoolerOut );


                    if (hToken)
                        ImpersonatePrinterClient(hToken);
                }
                break;
            }
        }

        if (!pRegistry->pValue) {
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    return rc;
}



DWORD
SetPrinterDataPrinter(
    HANDLE  hPrinter,
    HKEY    hParentKey,
    HKEY    hKey,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData,
    DWORD   dwSet        // SET_PRINTER_DATA, DELETE_PRINTER_DATA, or DELETE_PRINTER_KEY
)
{
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    LPWSTR  pKeyName;
    DWORD   rc = ERROR_INVALID_HANDLE;
    HANDLE  hToken = NULL;
    PINIPRINTER pIniPrinter;
    PINIJOB pIniJob;

    SplInSem();

    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )){
        goto Done;
    }

    pIniPrinter = pSpool->pIniPrinter;

    SPLASSERT(pIniPrinter &&
              pIniPrinter->signature == IP_SIGNATURE && hKey);

    if ( !AccessGranted( SPOOLER_OBJECT_PRINTER,
                         PRINTER_ACCESS_ADMINISTER,
                         pSpool ) ) {

        rc = ERROR_ACCESS_DENIED;
        goto Done;
    }

    hToken = RevertToPrinterSelf();

    if (dwSet == SET_PRINTER_DATA) {

        rc = SplRegSetValue(hKey,
                            pValueName,
                            Type,
                            pData,
                            cbData,
                            pIniPrinter->pIniSpooler );

    } else if (dwSet == DELETE_PRINTER_DATA) {

        rc = SplRegDeleteValue(hKey, pValueName, pIniPrinter->pIniSpooler );

    } else if (dwSet == DELETE_PRINTER_KEY) {

        rc = SplDeleteThisKey(hParentKey,
                              hKey,
                              pValueName,
                              FALSE,
                              pIniPrinter->pIniSpooler);
    }


    if (hToken)
        ImpersonatePrinterClient(hToken);


    if ( rc == ERROR_SUCCESS ) {

        UpdatePrinterIni(pIniPrinter, CHANGEID_ONLY);

        SetPrinterChange(pIniPrinter,
                         NULL,
                         NULL,
                         PRINTER_CHANGE_SET_PRINTER_DRIVER,
                         pSpool->pIniSpooler );
    }

    //
    // Now if there are any Jobs waiting for these changes because of
    // DevQueryPrint fix them as well
    //
    pIniJob = pIniPrinter->pIniFirstJob;
    while (pIniJob) {
        if (pIniJob->Status & JOB_BLOCKED_DEVQ) {
            pIniJob->Status &= ~JOB_BLOCKED_DEVQ;
            FreeSplStr(pIniJob->pStatus);
            pIniJob->pStatus = NULL;

            SetPrinterChange(pIniJob->pIniPrinter,
                             pIniJob,
                             NVJobStatusAndString,
                             PRINTER_CHANGE_SET_JOB,
                             pIniJob->pIniPrinter->pIniSpooler );
        }
        pIniJob = pIniJob->pIniNextJob;
    }

    CHECK_SCHEDULER();


Done:

    return rc;
}



DWORD
GetServerKeyHandle(
    PINISPOOLER     pIniSpooler,
    REG_PRINT_KEY   eKey,
    HKEY            *phKey,
    PINISPOOLER*    ppIniSpoolerOut
)
{
    DWORD    rc = ERROR_SUCCESS;
    HANDLE   hToken;
    *ppIniSpoolerOut = NULL;

    hToken = RevertToPrinterSelf();

    switch (eKey) {
        case REG_PRINT:

            *phKey = pIniSpooler->hckRoot;
            *ppIniSpoolerOut = pIniSpooler;

            break;

        case REG_PRINTERS:

            *phKey = pIniSpooler->hckPrinters;
            *ppIniSpoolerOut = pIniSpooler;

            break;

        case REG_PROVIDERS:

            rc = SplRegCreateKey( pIniSpooler->hckRoot,
                                  pIniSpooler->pszRegistryProviders,
                                  0,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  phKey,
                                  NULL,
                                  pIniSpooler);

            *ppIniSpoolerOut = pIniSpooler;

            break;

        default:
            rc = ERROR_INVALID_PARAMETER;
            break;
    }

    ImpersonatePrinterClient(hToken);

    return rc;
}


DWORD
CloseServerKeyHandle(
    REG_PRINT_KEY   eKey,
    HKEY            hKey,
    PINISPOOLER     pIniSpooler
)
{
    DWORD    rc = ERROR_SUCCESS;
    HANDLE   hToken = NULL;

    hToken = RevertToPrinterSelf();

    switch (eKey) {
        case REG_PRINT:
            break;

        case REG_PRINTERS:
            break;

        case REG_PROVIDERS:
            SplRegCloseKey( hKey, pIniSpooler );
            break;

        default:
            rc = ERROR_INVALID_PARAMETER;
            break;
    }

    if (hToken)
        ImpersonatePrinterClient(hToken);

    return rc;
}

DWORD
RegSetDefaultSpoolDirectory(
    LPWSTR      pValueName,
    DWORD       dwType,
    LPBYTE      pData,
    DWORD       cbData,
    HKEY        hKey,
    PINISPOOLER pIniSpooler
)
{
    DWORD               rc = ERROR_SUCCESS;
    LPWSTR              pszNewSpoolDir = NULL;
    SECURITY_ATTRIBUTES SecurityAttributes;

    if ( pIniSpooler == NULL )
    {
        //
        // This check is probably not needed.
        // Old code was checking for NULL so instead of just removing it I
        // changed it to an assert and fail gracefully w/o crash
        //
        rc = ERROR_INVALID_PARAMETER;
        SPLASSERT(pIniSpooler != NULL);
    }
    else if (!pData || wcslen((LPWSTR)pData) > MAX_PATH - 12)
    {
        rc = ERROR_INVALID_PARAMETER;
    }
    else if ( !(pszNewSpoolDir = AllocSplStr((LPWSTR) pData)) )
    {
        rc = ERROR_OUTOFMEMORY;
    }

    if ( rc == ERROR_SUCCESS )
    {
        //
        // Create the directory with the proper security, or fail trying
        //
        SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
        SecurityAttributes.lpSecurityDescriptor = CreateEverybodySecurityDescriptor();
        SecurityAttributes.bInheritHandle = FALSE;

        if ( !CreateDirectory(pszNewSpoolDir, &SecurityAttributes) )
        {
            rc = GetLastError();
            //
            // If the directory already exists it is not a failure
            //
            if ( rc == ERROR_ALREADY_EXISTS )
            {
                rc = ERROR_SUCCESS;
            }
            else if ( rc == ERROR_SUCCESS )
            {
                //
                // Don't rely on last error being set
                //
                rc = ERROR_OUTOFMEMORY;
            }
        }

        LocalFree(SecurityAttributes.lpSecurityDescriptor);
    }

    if ( rc == ERROR_SUCCESS )
    {
        EnterSplSem();
        rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);
        if ( rc == ERROR_SUCCESS ) {

            FreeSplStr(pIniSpooler->pDefaultSpoolDir);
            pIniSpooler->pDefaultSpoolDir = pszNewSpoolDir;
            pszNewSpoolDir = NULL;

            if ( pIniSpooler->hFilePool != INVALID_HANDLE_VALUE )
            {
                (VOID) ChangeFilePoolBasePath(pIniSpooler->hFilePool,
                                              pIniSpooler->pDefaultSpoolDir);
            }
        }
        LeaveSplSem();
    }

    FreeSplStr(pszNewSpoolDir);

    return rc;
}

DWORD
RegSetPortThreadPriority(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    BOOL    rc;

    rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);

    if ((rc == ERROR_SUCCESS) &&
        (cbData >= sizeof(DWORD))) {

        dwPortThreadPriority = *(LPDWORD)pData;
    }

    return rc;
}

DWORD
RegSetSchedulerThreadPriority(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    BOOL    rc;

    rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);

    if ((rc == ERROR_SUCCESS) &&
        (cbData >= sizeof(DWORD))) {

        dwSchedulerThreadPriority = *(LPDWORD)pData;
    }

    return rc;
}

DWORD
RegSetBeepEnabled(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    BOOL    rc;

    rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);

    if ((rc == ERROR_SUCCESS) &&
        (cbData >= sizeof(DWORD)) &&
        pIniSpooler) {

        pIniSpooler->dwBeepEnabled = *(LPDWORD)pData;

        // Make it 1 or 0
        pIniSpooler->dwBeepEnabled = !!pIniSpooler->dwBeepEnabled;
    }

    return rc;
}

DWORD
RegSetRetryPopup(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    BOOL    rc;

    rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);

    if ((rc == ERROR_SUCCESS) &&
        (cbData >= sizeof(DWORD)) &&
        pIniSpooler) {

        pIniSpooler->bEnableRetryPopups = *(LPDWORD) pData;
        // Make it 1 or 0
        pIniSpooler->bEnableRetryPopups = !!pIniSpooler->bEnableRetryPopups;
    }

    return rc;
}

DWORD
RegSetNetPopup(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    BOOL    rc;

    rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);

    if ((rc == ERROR_SUCCESS) &&
        (cbData >= sizeof(DWORD)) &&
        pIniSpooler) {

        pIniSpooler->bEnableNetPopups = *(LPDWORD) pData;
        // Make it 1 or 0
        pIniSpooler->bEnableNetPopups = !!pIniSpooler->bEnableNetPopups;
    }

    return rc;
}

DWORD
RegSetEventLog(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    BOOL    rc;

    rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);

    if ((rc == ERROR_SUCCESS) &&
        (cbData >= sizeof(DWORD)) &&
        pIniSpooler) {

        pIniSpooler->dwEventLogging = *(LPDWORD) pData;
    }

    return rc;
}


DWORD
RegSetNetPopupToComputer(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    BOOL    rc;

    rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);

    if ((rc == ERROR_SUCCESS) &&
        (cbData >= sizeof(DWORD)) &&
        pIniSpooler) {

        pIniSpooler->bEnableNetPopupToComputer = *(LPDWORD) pData;

        // Make it 1 or 0
        pIniSpooler->bEnableNetPopupToComputer = !!pIniSpooler->bEnableNetPopupToComputer;
    }

    return rc;
}


DWORD
RegSetRestartJobOnPoolError(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    BOOL    rc;

    rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);

    if ((rc == ERROR_SUCCESS) &&
        (cbData >= sizeof(DWORD)) &&
        pIniSpooler) {

        pIniSpooler->dwRestartJobOnPoolTimeout = *(LPDWORD) pData;

    }

    return rc;
}

DWORD
RegSetRestartJobOnPoolEnabled(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    BOOL    rc;

    rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);

    if ((rc == ERROR_SUCCESS) &&
        (cbData >= sizeof(DWORD)) &&
        pIniSpooler) {

        pIniSpooler->bRestartJobOnPoolEnabled = *(LPDWORD) pData;

        // Make it 1 or 0
        pIniSpooler->bRestartJobOnPoolEnabled = !!pIniSpooler->bRestartJobOnPoolEnabled;
    }

    return rc;
}

DWORD
RegSetNoRemoteDriver(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    return  ERROR_NOT_SUPPORTED;
}

DWORD
PrinterNonRegGetDefaultSpoolDirectory(
    PSPOOL      pSpool,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
    )
{
    WCHAR szDefaultSpoolDirectory[MAX_PATH];
    DWORD cch;

    cch = GetPrinterDirectory( pSpool->pIniPrinter,
                               FALSE,
                               szDefaultSpoolDirectory,
                               COUNTOF(szDefaultSpoolDirectory),
                               pSpool->pIniSpooler );
    if(!cch) {

        return GetLastError();
    }

    *pcbNeeded = ( cch + 1 ) * sizeof( szDefaultSpoolDirectory[0] );
    *pType = REG_SZ;

    if( nSize < *pcbNeeded ){
        return ERROR_MORE_DATA;
    }

    wcscpy( (LPWSTR)pData, szDefaultSpoolDirectory );
    return ERROR_SUCCESS;
}

DWORD
PrinterNonRegGetChangeId(
    PSPOOL      pSpool,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
    )
{
    LPDWORD pdwChangeID = (LPDWORD)pData;
    DWORD   dwRetval    = ERROR_INVALID_PARAMETER;

    //
    // We need a valid handle, piniPrinter
    //
    if (pSpool && pSpool->pIniPrinter)
    {
        if (pcbNeeded)
        {
            *pcbNeeded = sizeof(pSpool->pIniPrinter->cChangeID);
        }

        //
        // The type is optional.
        //
        if (pType)
        {
            *pType = REG_DWORD;
        }

        //
        // Is the provided buffer large enough.
        //
        if (nSize < sizeof(pSpool->pIniPrinter->cChangeID))
        {
            dwRetval = ERROR_MORE_DATA;
        }
        else
        {
            //
            // Is the provided buffer valid.
            //
            if (pdwChangeID)
            {
                //
                // Get the printer change id.  We really would like
                // more granularity on this.  Just knowing if something
                // changed about this printer is very general.
                //
                *pdwChangeID = pSpool->pIniPrinter->cChangeID;
                dwRetval = ERROR_SUCCESS;
            }
        }
    }

    return dwRetval;
}


DWORD
NonRegGetDNSMachineName(
    PINISPOOLER pIniSpooler,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
)
{
    DWORD   cChars;
    if(!pIniSpooler || !pIniSpooler->pszFullMachineName) {
        return ERROR_INVALID_PARAMETER;
    }

    cChars = wcslen(pIniSpooler->pszFullMachineName);
    *pcbNeeded = ( cChars + 1 ) * sizeof( WCHAR );
    *pType = REG_SZ;

    if( nSize < *pcbNeeded ){
        return ERROR_MORE_DATA;
    }
    wcscpy( (LPWSTR)pData, _wcslwr(pIniSpooler->pszFullMachineName) );
    return ERROR_SUCCESS;
}

DWORD
NonRegDsPresent(
    PINISPOOLER pIniSpooler,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
)
{
    HANDLE                              hToken = NULL;

    *pcbNeeded = sizeof(DWORD);
    *pType = REG_DWORD;

    if (nSize < sizeof(DWORD))
        return ERROR_MORE_DATA;

    hToken = RevertToPrinterSelf();

    *(PDWORD) pData = IsDsPresent();

    if (hToken)
        ImpersonatePrinterClient(hToken);

    return ERROR_SUCCESS;
}


BOOL
IsDsPresent(
)
{
    DOMAIN_CONTROLLER_INFO              *pDCI = NULL;
    BOOL                                bDsPresent;
    DWORD                               dwRet;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDsRole = NULL;


    // Get Domain name
    dwRet = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *) &pDsRole);

    bDsPresent = (dwRet == ERROR_SUCCESS &&
                  pDsRole->MachineRole != DsRole_RoleStandaloneServer &&
                  pDsRole->MachineRole != DsRole_RoleStandaloneWorkstation);

    if (pDsRole) {
        DsRoleFreeMemory((PVOID) pDsRole);
    }

    if (bDsPresent) {
        if (DsGetDcName(NULL, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_PREFERRED, &pDCI) == ERROR_SUCCESS)
            bDsPresent = !!(pDCI->Flags & DS_DS_FLAG);
        else
            bDsPresent = FALSE;

        if (pDCI)
            NetApiBufferFree(pDCI);
    }

    return bDsPresent;
}



DWORD
NonRegDsPresentForUser(
    PINISPOOLER pIniSpooler,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
)
{
    WCHAR                   pUserName[MAX_PATH + 1];
    PWSTR                   pszUserName = pUserName;
    DWORD                   cchUserName = MAX_PATH + 1;
    DWORD                   dwError = ERROR_SUCCESS;
    PWSTR                   pszDomain;
    DOMAIN_CONTROLLER_INFO  *pDCI = NULL;
    WCHAR                   szComputerName[MAX_COMPUTERNAME_LENGTH + 1];

    *pcbNeeded = sizeof(DWORD);
    *pType = REG_DWORD;

    if (nSize < sizeof(DWORD))
        return ERROR_MORE_DATA;


    // GetUserNameEx returns "Domain\User" in pszUserName (e.g.: NTDEV\swilson)
    if (!GetUserNameEx(NameSamCompatible, pszUserName, &cchUserName)) {
        if (cchUserName > MAX_PATH + 1) {

            pszUserName = AllocSplMem(cchUserName);
            if (!pszUserName || !GetUserNameEx(NameSamCompatible, pszUserName, &cchUserName)) {
                dwError = GetLastError();
                goto error;
            }

        } else {
            dwError = GetLastError();
            goto error;
        }
    }

    // Chop off user name
    pszDomain = wcschr(pszUserName, L'\\');

    SPLASSERT(pszDomain);

    if (pszDomain) {  // pszDomain should never be NULL, but just in case...
        *pszDomain =  L'\0';
    } else {
        *(PDWORD) pData = 0;
        goto error;
    }

    // If domain is same a machine name, then we're logged on locally
    nSize = COUNTOF(szComputerName);
    if (GetComputerName(szComputerName, &nSize) && !wcscmp(szComputerName, pszUserName)) {
        *(PDWORD) pData = 0;
        goto error;
    }

    pszDomain = pszUserName;

    if (DsGetDcName(NULL, pszDomain, NULL, NULL, DS_DIRECTORY_SERVICE_PREFERRED, &pDCI) == ERROR_SUCCESS)
        *(PDWORD) pData = !!(pDCI->Flags & DS_DS_FLAG);

error:

    if (pDCI)
        NetApiBufferFree(pDCI);

    if (pszUserName != pUserName)
        FreeSplMem(pszUserName);

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\prtproc.c ===
/*++

Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    prtproc.c

Abstract:

    This module provides all the public exported APIs relating to the
    PrintProcessor based Spooler Apis for the Local Print Providor

    LocalAddPrintProcessor
    LocalEnumPrintProcessors
    LocalDeletePrintProcessor
    LocalGetPrintProcessorDirectory
    LocalEnumPrintProcessorDatatypes

    Support Functions in prtproc.c - (Warning! Do Not Add to this list!!)

    AddPrintProcessorIni
    DeletePrintProcessorIni
    CopyIniPrintProcToPrintProcInfo
    GetPrintProcessorInfoSize

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Felix Maxa (amaxa) 18-Jun-2000
    Modified registry functions to take pIniSpooler
    Added code to propagate print processors to the cluster disk
    
    Matthew A Felton ( MattFe ) 27 June 1994
    pIniSpooler

--*/
#define NOMINMAX

#include <precomp.h>
#include <offsets.h>
#include "clusspl.h"

//
// Support Function Prototypes
//
DWORD
GetPrintProcessorInfoSize(
    PINIPRINTPROC  pIniPrintProc,
    DWORD       Level,
    LPWSTR       pEnvironment
);

LPBYTE
CopyIniPrintProcToPrintProcInfo(
    LPWSTR   pEnvironment,
    PINIPRINTPROC pIniPrintProc,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    LPBYTE  pEnd
);

BOOL
AddPrintProcessorIni(
    PINIPRINTPROC pIniPrintProc,
    PINIENVIRONMENT  pIniEnvironment,
    PINISPOOLER pIniSpooler
);

BOOL
DeletePrintProcessorIni(
    PINIPRINTPROC pIniPrintProc,
    PINIENVIRONMENT  pIniEnvironment,
    PINISPOOLER pIniSpooler
);


BOOL
LocalAddPrintProcessor(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pPathName,
    LPWSTR   pPrintProcessorName
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplAddPrintProcessor( pName, pEnvironment, pPathName,
                                    pPrintProcessorName, pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}






BOOL
SplAddPrintProcessor(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pPathName,
    LPWSTR   pPrintProcessorName,
    PINISPOOLER pIniSpooler
)
{
    PINIPRINTPROC   pIniPrintProc;
    PINIENVIRONMENT pIniEnvironment;
    DWORD   LastError=0;

    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    if(!pPrintProcessorName || wcslen( pPrintProcessorName ) >= MAX_PATH) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

   EnterSplSem();

    if ( ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                              SERVER_ACCESS_ADMINISTER,
                              NULL, NULL, pIniSpooler )) {

        if ((pIniEnvironment = FindEnvironment(pEnvironment, pIniSpooler)) &&
            (pIniEnvironment == FindEnvironment(szEnvironment, pIniSpooler))) {

            if (!FindPrintProc(pPrintProcessorName, pIniEnvironment)) {

                pIniPrintProc = LoadPrintProcessor(pIniEnvironment,
                                                   pPrintProcessorName,
                                                   pPathName,
                                                   pIniSpooler);

                if (!pIniPrintProc || 
                    !AddPrintProcessorIni(pIniPrintProc, pIniEnvironment, pIniSpooler))
                {
                    LastError = GetLastError();
                }
                else
                {
                    //
                    // For a cluster type spooler copy the print proc to the cluster disk
                    //
                    if (pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER) 
                    {
                        WCHAR szDestDir[MAX_PATH]    = {0};
                        WCHAR szSourceFile[MAX_PATH] = {0};
    
                        if ((LastError = StrNCatBuff(szDestDir,
                                                     MAX_PATH,
                                                     pIniSpooler->pszClusResDriveLetter,
                                                     L"\\",
                                                     szClusterDriverRoot,
                                                     L"\\",
                                                     pIniEnvironment->pDirectory,
                                                     NULL)) == ERROR_SUCCESS &&
                            (LastError = StrNCatBuff(szSourceFile, 
                                                     MAX_PATH,
                                                     pIniSpooler->pDir,
                                                     L"\\",
                                                     szPrintProcDir,
                                                     L"\\",
                                                     pIniEnvironment->pDirectory,
                                                     L"\\",
                                                     pPathName,
                                                     NULL)) == ERROR_SUCCESS)
                        {
                            //
                            // This function will take care to create the destination directory tree
                            //
                            LastError = CopyFileToDirectory(szSourceFile, szDestDir, NULL, NULL, NULL);                                        

                            DBGMSG(DBG_CLUSTER, ("ClusterCopyProcessorToClusterDisks returns Win32 error %u\n", LastError));
                        }
                    }
                }

            } else
                LastError = ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED;

        } else
            LastError = ERROR_INVALID_ENVIRONMENT;

    } else
        LastError = GetLastError();

    if (!LastError)
        SetPrinterChange(NULL,
                         NULL,
                         NULL,
                         PRINTER_CHANGE_ADD_PRINT_PROCESSOR,
                         pIniSpooler);

   LeaveSplSem();
    SplOutSem();

    if (LastError) {

        SetLastError(LastError);
        return FALSE;
    }

    return TRUE;
}

BOOL
LocalDeletePrintProcessor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPrintProcessorName
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplDeletePrintProcessor( pName,
                                       pEnvironment,
                                       pPrintProcessorName,
                                       pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}





BOOL
SplDeletePrintProcessor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPrintProcessorName,
    PINISPOOLER pIniSpooler
)
{
    PINIENVIRONMENT pIniEnvironment;
    PINIPRINTPROC  pIniPrintProc;
    BOOL        Remote=FALSE;

    if (pName && *pName) {

        if (!MyName( pName, pIniSpooler )) {

            return FALSE;

        } else {

            Remote = TRUE;
        }
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    EnterSplSem();

    pIniEnvironment = FindEnvironment(pEnvironment, pIniSpooler);

    //
    // Fail the call if we can't find a matching environment or
    // the environemnt doesn't match to the environemnt of the
    // local machine
    //
    if (!pIniEnvironment || 
        lstrcmpi(pIniEnvironment->pName, szEnvironment)) 
    {
        LeaveSplSem();
        SetLastError(ERROR_INVALID_ENVIRONMENT);
        return FALSE;
    }

    if (!(pIniPrintProc=(PINIPRINTPROC)FindIniKey(
                                        (PINIENTRY)pIniEnvironment->pIniPrintProc,
                                        pPrintProcessorName)))
    {
        SetLastError(ERROR_UNKNOWN_PRINTPROCESSOR);
        LeaveSplSem();
        return FALSE;
    } 
    else if (pIniPrintProc->cRef) 
    {
        SetLastError(ERROR_CAN_NOT_COMPLETE);
        LeaveSplSem();
        return FALSE;
    }

    RemoveFromList((PINIENTRY *)&pIniEnvironment->pIniPrintProc,
                   (PINIENTRY)pIniPrintProc);

    DeletePrintProcessorIni(pIniPrintProc, pIniEnvironment, pIniSpooler);
    
    if (!FreeLibrary(pIniPrintProc->hLibrary)) {
        DBGMSG(DBG_TRACE, ("DeletePrintProcessor: FreeLibrary failed\n"));
    }

    FreeSplMem(pIniPrintProc->pDatatypes);

    DeleteCriticalSection(&pIniPrintProc->CriticalSection);

    FreeSplMem(pIniPrintProc);

    SetPrinterChange(NULL,
                     NULL,
                     NULL,
                     PRINTER_CHANGE_DELETE_PRINT_PROCESSOR,
                     pIniSpooler);

   LeaveSplSem();

    return TRUE;
}

BOOL
LocalEnumPrintProcessors(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplEnumPrintProcessors( pName,
                                      pEnvironment,
                                      Level,
                                      pPrintProcessorInfo,
                                      cbBuf,
                                      pcbNeeded,
                                      pcReturned,
                                      pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}



BOOL
SplEnumPrintProcessors(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    PINISPOOLER pIniSpooler
)
{
    PINIPRINTPROC  pIniPrintProc;
    PINIENVIRONMENT pIniEnvironment;
    DWORD       cb, cbStruct;
    LPBYTE      pEnd;
    DWORD       LastError=0;

    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ENUMERATE,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    EnterSplSem();

    //
    // Don't ignore the environment.  This was added in 3.1 as a hack instead
    // of fixing printman.  The problem was that from remote, different
    // environments, it would look for the wrong architecture.  Now the
    // NT 4.0 and 5.0 UI code does the right thing.
    //
    if( !pEnvironment ||
        !(pIniEnvironment = FindEnvironment( pEnvironment, pIniSpooler ))){

        LastError = ERROR_INVALID_ENVIRONMENT;
        goto Done;
    }

    switch (Level) {

    case 1:
        cbStruct = sizeof(PRINTPROCESSOR_INFO_1);
        break;
    default:

        LeaveSplSem();
        SetLastError( ERROR_INVALID_LEVEL );
        return FALSE;
    }

    *pcReturned=0;

    cb=0;

    pIniPrintProc=pIniEnvironment->pIniPrintProc;

    while (pIniPrintProc) {
        cb+=GetPrintProcessorInfoSize(pIniPrintProc, Level, pEnvironment);
        pIniPrintProc=pIniPrintProc->pNext;
    }

    *pcbNeeded=cb;

    if (cb <= cbBuf) {

        pIniPrintProc=pIniEnvironment->pIniPrintProc;
        pEnd=pPrintProcessorInfo+cbBuf;

        while (pEnd && pIniPrintProc) {

            pEnd = CopyIniPrintProcToPrintProcInfo(pEnvironment,
                                                   pIniPrintProc,
                                                   Level,
                                                   pPrintProcessorInfo,
                                                   pEnd);
            pPrintProcessorInfo+=cbStruct;
            (*pcReturned)++;

            pIniPrintProc=pIniPrintProc->pNext;
        }

        if (!pEnd && cbBuf)
            LastError = ERROR_OUTOFMEMORY;

    } else

        LastError = ERROR_INSUFFICIENT_BUFFER;

Done:

   LeaveSplSem();
    SplOutSem();

    if (LastError) {

        SetLastError(LastError);
        return FALSE;
    }

    return TRUE;
}

BOOL
LocalGetPrintProcessorDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplGetPrintProcessorDirectory( pName,
                                             pEnvironment,
                                             Level,
                                             pPrintProcessorInfo,
                                             cbBuf,
                                             pcbNeeded,
                                             pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}


BOOL
SplGetPrintProcessorDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    PINISPOOLER pIniSpooler
)
{
    PINIENVIRONMENT pIniEnvironment;
    DWORD       cb;
    DWORD       dwError   = ERROR_INVALID_ENVIRONMENT;
    LPWSTR      pszString = NULL;
    BOOL        rc        = FALSE;

    if (MyName( pName, pIniSpooler) &&
        ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                             SERVER_ACCESS_ENUMERATE,
                             NULL, 
                             NULL, 
                             pIniSpooler))
    {
        EnterSplSem();

        pIniEnvironment = FindEnvironment(pEnvironment, pIniSpooler);

        if (pIniEnvironment) 
        {
            dwError = GetProcessorDirectory(&pszString, pIniEnvironment->pDirectory, pIniSpooler);

            if (dwError == ERROR_SUCCESS) 
            {
                *pcbNeeded = cb = wcslen(pszString) * sizeof(WCHAR) + sizeof(WCHAR);

                if (cbBuf >= cb) 
                {
                    wcscpy((LPWSTR)pPrintProcessorInfo, pszString);
                    
                    //
                    // Make sure the directory exists
                    //
                    CreatePrintProcDirectory(pIniEnvironment->pDirectory, pIniSpooler);
                    
                    rc = TRUE;
                }
                else
                {
                    dwError = ERROR_INSUFFICIENT_BUFFER;
                }
            }
        }
        
        LeaveSplSem();
        SetLastError(dwError);
        FreeSplMem(pszString);        
    }

    return rc;
}


BOOL
LocalEnumPrintProcessorDatatypes(
    LPWSTR  pName,
    LPWSTR  pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplEnumPrintProcessorDatatypes( pName,
                                              pPrintProcessorName,
                                              Level,
                                              pDatatypes,
                                              cbBuf,
                                              pcbNeeded,
                                              pcReturned,
                                              pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}



BOOL
SplEnumPrintProcessorDatatypes(
    LPWSTR  pName,
    LPWSTR  pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    PINISPOOLER pIniSpooler
)
{
    PINIPRINTPROC   pIniPrintProc;
    PINIENVIRONMENT pIniEnvironment;
    
    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ENUMERATE,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }
    
    EnterSplSem();
    
    pIniPrintProc = FindPrintProc(pPrintProcessorName, GetLocalArchEnv(pIniSpooler));

    LeaveSplSem();

    if (pIniPrintProc)
        return (*pIniPrintProc->EnumDatatypes)(pName, pPrintProcessorName,
                                               Level, pDatatypes, cbBuf,
                                               pcbNeeded, pcReturned);
    else {

        SetLastError(ERROR_UNKNOWN_PRINTPROCESSOR);
        return FALSE;
    }
}

DWORD
GetPrintProcessorInfoSize(
    PINIPRINTPROC  pIniPrintProc,
    DWORD       Level,
    LPWSTR       pEnvironment
)
{
    DWORD cb=0;

    switch (Level) {

    case 1:
        cb=sizeof(PRINTPROCESSOR_INFO_1) +
           wcslen(pIniPrintProc->pName)*sizeof(WCHAR) + sizeof(WCHAR);
        break;

    default:

        cb = 0;
        break;
    }

    return cb;
}

LPBYTE
CopyIniPrintProcToPrintProcInfo(
    LPWSTR   pEnvironment,
    PINIPRINTPROC pIniPrintProc,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    LPBYTE  pEnd
)
{
    LPWSTR *pSourceStrings, *SourceStrings;
    PPRINTPROCESSOR_INFO_1 pDriver1 = (PPRINTPROCESSOR_INFO_1)pPrintProcessorInfo;
    DWORD j;
    DWORD *pOffsets;

    switch (Level) {

    case 1:
        pOffsets = PrintProcessorInfo1Strings;
        break;

    default:
        return pEnd;
    }

    for (j=0; pOffsets[j] != -1; j++) {
    }

    SourceStrings = pSourceStrings = AllocSplMem(j * sizeof(LPWSTR));

    if (!pSourceStrings) {

        DBGMSG(DBG_WARNING, ("Could not allocate %d bytes for print proc source strings.\n",
                           (j * sizeof(LPWSTR))));
        return pEnd;
    }

    switch (Level) {

    case 1:
        *pSourceStrings++=pIniPrintProc->pName;

        pEnd = PackStrings(SourceStrings, (LPBYTE)pPrintProcessorInfo, pOffsets, pEnd);
        break;
    }

    FreeSplMem(SourceStrings);

    return pEnd;
}



BOOL
AddPrintProcessorIni(
    PINIPRINTPROC pIniPrintProc,
    PINIENVIRONMENT  pIniEnvironment,
    PINISPOOLER pIniSpooler
)
{
    HKEY    hEnvironmentsRootKey, hEnvironmentKey, hPrintProcsKey, hPrintProcKey;
    HANDLE  hToken;
    BOOL    ReturnValue = FALSE;

    hToken = RevertToPrinterSelf();

    if (SplRegCreateKey(pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ? pIniSpooler->hckRoot : HKEY_LOCAL_MACHINE, 
                        pIniSpooler->pszRegistryEnvironments, 
                        0,
                        KEY_WRITE, 
                        NULL, 
                        &hEnvironmentsRootKey, 
                        NULL,
                        pIniSpooler) == ERROR_SUCCESS) 
    {
        if (SplRegOpenKey(hEnvironmentsRootKey, 
                          pIniEnvironment->pName, 
                          KEY_WRITE, 
                          &hEnvironmentKey,
                          pIniSpooler) == ERROR_SUCCESS) 
        {
            if (SplRegOpenKey(hEnvironmentKey, 
                              szPrintProcKey, 
                              KEY_WRITE, 
                              &hPrintProcsKey,
                              pIniSpooler) == ERROR_SUCCESS) 
            {
                if (SplRegCreateKey(hPrintProcsKey, 
                                    pIniPrintProc->pName, 
                                    0,
                                    KEY_WRITE, 
                                    NULL,
                                    &hPrintProcKey, 
                                    NULL,
                                    pIniSpooler) == ERROR_SUCCESS) 
                 {

                    if (SplRegSetValue(hPrintProcKey, 
                                       szDriverFile, 
                                       REG_SZ, 
                                       (LPBYTE)pIniPrintProc->pDLLName,
                                       (wcslen(pIniPrintProc->pDLLName) + 1)*sizeof(WCHAR),
                                       pIniSpooler) == ERROR_SUCCESS)
                    {
                        ReturnValue = TRUE;

                        DBGMSG(DBG_CLUSTER, ("AddPrintProcessorIni Success "TSTR" "TSTR"\n", pIniPrintProc->pName, pIniPrintProc->pDLLName));
                    }

                    SplRegCloseKey(hPrintProcKey, pIniSpooler);
                }

                SplRegCloseKey(hPrintProcsKey, pIniSpooler);
            }

            SplRegCloseKey(hEnvironmentKey, pIniSpooler);
        }

        SplRegCloseKey(hEnvironmentsRootKey, pIniSpooler);
    }

    ImpersonatePrinterClient(hToken);

    return ReturnValue;
}



BOOL
DeletePrintProcessorIni(
    PINIPRINTPROC   pIniPrintProc,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
)
{
    HKEY    hEnvironmentsRootKey, hEnvironmentKey, hPrintProcsKey;
    HANDLE  hToken;

    hToken = RevertToPrinterSelf();

    if (SplRegCreateKey(pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ? pIniSpooler->hckRoot : HKEY_LOCAL_MACHINE, 
                        pIniSpooler->pszRegistryEnvironments, 
                        0,
                        KEY_WRITE, 
                        NULL, 
                        &hEnvironmentsRootKey, 
                        NULL,
                        pIniSpooler) == ERROR_SUCCESS) 
    {
        if (SplRegOpenKey(hEnvironmentsRootKey, 
                          pIniEnvironment->pName, 
                          KEY_WRITE, 
                          &hEnvironmentKey,
                          pIniSpooler) == ERROR_SUCCESS) 
        {
            if (SplRegOpenKey(hEnvironmentKey, 
                              szPrintProcKey, 
                              KEY_WRITE, 
                              &hPrintProcsKey,
                              pIniSpooler) == ERROR_SUCCESS) 
            {
                SplRegDeleteKey(hPrintProcsKey, pIniPrintProc->pName, pIniSpooler);

                SplRegCloseKey(hPrintProcsKey, pIniSpooler);

                DBGMSG(DBG_CLUSTER, ("DeletePrintProcessorIni Success "TSTR"\n", pIniPrintProc->pName));
            }

            SplRegCloseKey(hEnvironmentKey, pIniSpooler);
        }

        SplRegCloseKey(hEnvironmentsRootKey, pIniSpooler);
    }

    ImpersonatePrinterClient(hToken);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\security.c ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation

Module Name:

    security.c

Abstract:

    This module interfaces with the security system

Author:

    Andrew Bell (andrewbe) June 1992

Revision History:

--*/

#include <precomp.h>


/******************************************************************************


    The printing security model
    ---------------------------

    In printing we define a hierarchy of three objects:


                                 SERVER

                                 /    \
                                /      \
                               /        ...
                              /

                         PRINTER

                          /   \
                         /     \
                        /       ...
                       /

                  DOCUMENT




    The following types of operation may be performed on each of these objects:


        SERVER:   Install/Deinstall Driver
                  Create Printer
                  Enumerate Printers

        PRINTER:  Pause/Resume
                  Delete
                  Connect to/Disconnect
                  Set
                  Enumerate Documents

        DOCUMENT: Pause/Resume
                  Delete
                  Set Attributes



    For product LanMan NT, five classes of user are defined, and,
    for Windows NT, four classes are defined.
    The following privileges are assigned to each class:



    Administrators

    Print Operators

    System Operators

    Power Users

    Owners

    Everyone (World)




******************************************************************************/

#define DBGCHK( Condition, ErrorInfo ) \
    if( Condition ) DBGMSG( DBG_WARNING, ErrorInfo )

#define TOKENLENGTH( Token ) ( *( ( (PDWORD)Token ) - 1 ) )



/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Came from \\orville\razzle\src\private\newsam\server\bldsam3.c

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/


GENERIC_MAPPING GenericMapping[SPOOLER_OBJECT_COUNT] =
{
    { SERVER_READ,   SERVER_WRITE,   SERVER_EXECUTE,  SERVER_ALL_ACCESS   },
    { PRINTER_READ,  PRINTER_WRITE,  PRINTER_EXECUTE, PRINTER_ALL_ACCESS  },
    { JOB_READ,      JOB_WRITE,      JOB_EXECUTE,     JOB_ALL_ACCESS      }
};

/* !!! Should these be translatable??? */

LPWSTR ObjectTypeName[SPOOLER_OBJECT_COUNT] =
{
    L"Server", L"Printer", L"Document"
};

WCHAR *szSpooler = L"Spooler";


LUID AuditValue;

PSECURITY_DESCRIPTOR pServerSecurityDescriptor;
LUID                 gLoadDriverPrivilegeLuid; 
PSID                 pLocalSystemSid;
PSID                 pGuestsSid;
PSID                 pNetworkLogonSid;

BOOL ServerGenerateOnClose;  /* Do we need this for the server? */

#if DBG
#define DBG_ACCESS_TYPE_SERVER_ALL_ACCESS                   0
#define DBG_ACCESS_TYPE_SERVER_READ                         1
#define DBG_ACCESS_TYPE_SERVER_WRITE                        2
#define DBG_ACCESS_TYPE_SERVER_EXECUTE                      3
#define DBG_ACCESS_TYPE_PRINTER_ALL_ACCESS                  4
#define DBG_ACCESS_TYPE_PRINTER_READ                        5
#define DBG_ACCESS_TYPE_PRINTER_WRITE                       6
#define DBG_ACCESS_TYPE_PRINTER_EXECUTE                     7
#define DBG_ACCESS_TYPE_JOB_ALL_ACCESS                      8
#define DBG_ACCESS_TYPE_JOB_READ                            9
#define DBG_ACCESS_TYPE_JOB_WRITE                          10
#define DBG_ACCESS_TYPE_JOB_EXECUTE                        11
#define DBG_ACCESS_TYPE_PRINTER_ACCESS_USE                 12
#define DBG_ACCESS_TYPE_PRINTER_ACCESS_ADMINISTER          13
#define DBG_ACCESS_TYPE_SERVER_ACCESS_ENUMERATE            14
#define DBG_ACCESS_TYPE_SERVER_ACCESS_ADMINISTER           15
#define DBG_ACCESS_TYPE_JOB_ACCESS_ADMINISTER              16
#define DBG_ACCESS_TYPE_DELETE                             17
#define DBG_ACCESS_TYPE_WRITE_DAC                          18
#define DBG_ACCESS_TYPE_WRITE_OWNER                        19
#define DBG_ACCESS_TYPE_ACCESS_SYSTEM_SECURITY             20
// These two should come last:
#define DBG_ACCESS_TYPE_UNKNOWN                            21
#define DBG_ACCESS_TYPE_COUNT                              22

typedef struct _DBG_ACCESS_TYPE_MAPPING
{
    DWORD  Type;
    LPWSTR Name;
}
DBG_ACCESS_TYPE_MAPPING, *PDBG_ACCESS_TYPE_MAPPING;

DBG_ACCESS_TYPE_MAPPING DbgAccessTypeMapping[DBG_ACCESS_TYPE_COUNT] =
{
    {   SERVER_ALL_ACCESS,          L"SERVER_ALL_ACCESS"            },
    {   SERVER_READ,                L"SERVER_READ"                  },
    {   SERVER_WRITE,               L"SERVER_WRITE"                 },
    {   SERVER_EXECUTE,             L"SERVER_EXECUTE"               },
    {   PRINTER_ALL_ACCESS,         L"PRINTER_ALL_ACCESS"           },
    {   PRINTER_READ,               L"PRINTER_READ"                 },
    {   PRINTER_WRITE,              L"PRINTER_WRITE"                },
    {   PRINTER_EXECUTE,            L"PRINTER_EXECUTE"              },
    {   JOB_ALL_ACCESS,             L"JOB_ALL_ACCESS"               },
    {   JOB_READ,                   L"JOB_READ"                     },
    {   JOB_WRITE,                  L"JOB_WRITE"                    },
    {   JOB_EXECUTE,                L"JOB_EXECUTE"                  },
    {   PRINTER_ACCESS_USE,         L"PRINTER_ACCESS_USE"           },
    {   PRINTER_ACCESS_ADMINISTER,  L"PRINTER_ACCESS_ADMINISTER"    },
    {   SERVER_ACCESS_ENUMERATE,    L"SERVER_ACCESS_ENUMERATE"      },
    {   SERVER_ACCESS_ADMINISTER,   L"SERVER_ACCESS_ADMINISTER"     },
    {   JOB_ACCESS_ADMINISTER,      L"JOB_ACCESS_ADMINISTER"        },
    {   DELETE,                     L"DELETE"                       },
    {   WRITE_DAC,                  L"WRITE_DAC"                    },
    {   WRITE_OWNER,                L"WRITE_OWNER"                  },
    {   ACCESS_SYSTEM_SECURITY,     L"ACCESS_SYSTEM_SECURITY"       },
    {   0,                          L"UNKNOWN"                      }
};


LPWSTR DbgGetAccessTypeName( DWORD AccessType )
{
    PDBG_ACCESS_TYPE_MAPPING pMapping;
    DWORD                   i;

    pMapping = DbgAccessTypeMapping;
    i = 0;

    while( ( i < ( DBG_ACCESS_TYPE_COUNT - 1 ) ) && ( pMapping[i].Type != AccessType ) )
        i++;

    return pMapping[i].Name;
}

#endif /* DBG */


BOOL
BuildJobOwnerSecurityDescriptor(
    IN  HANDLE                hToken,
    OUT PSECURITY_DESCRIPTOR *ppSD
    );

VOID
DestroyJobOwnerSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSD
    );

BOOL
SetRequiredPrivileges(
    IN  HANDLE            TokenHandle,
    OUT PTOKEN_PRIVILEGES *ppPreviousTokenPrivileges,
    OUT PDWORD            pPreviousTokenPrivilegesLength
    );

BOOL
ResetRequiredPrivileges(
    IN HANDLE            TokenHandle,
    IN PTOKEN_PRIVILEGES pPreviousTokenPrivileges,
    IN DWORD             PreviousTokenPrivilegesLength
    );



PSECURITY_DESCRIPTOR
AllocateLocalSD(
    PSECURITY_DESCRIPTOR pSystemAllocatedSD
    );

DWORD
GetHackOutAce(
    PACL pDacl
    );

#define MAX_ACE 20


#if DBG

typedef struct _STANDARD_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    PSID Sid;
} STANDARD_ACE;
typedef STANDARD_ACE *PSTANDARD_ACE;

//
//  The following macros used by DumpAcl(), these macros and DumpAcl() are
//  stolen from private\ntos\se\ctaccess.c (written by robertre) for
//  debugging purposes.
//

//
//  Returns a pointer to the first Ace in an Acl (even if the Acl is empty).
//

#define FirstAce(Acl) ((PVOID)((LPBYTE)(Acl) + sizeof(ACL)))

//
//  Returns a pointer to the next Ace in a sequence (even if the input
//  Ace is the one in the sequence).
//

#define NextAce(Ace) ((PVOID)((LPBYTE)(Ace) + ((PACE_HEADER)(Ace))->AceSize))


VOID
DumpAcl(
    IN PACL Acl
    );

#endif //if DBG


/* Dummy access mask which will never be checked, but required
 * by the ACL editor, so that Document Properties is not undefined
 * for containers (i.e. printers).
 * This mask alone must not be used for any other ACE, since it
 * will be used to find the no-inherit ACE which propagates
 * onto printers.
 */
#define DUMMY_ACE_ACCESS_MASK   READ_CONTROL


/* CreateServerSecurityDescriptor
 *
 * Arguments: None
 *
 * Return: The security descriptor returned by BuildPrintObjectProtection.
 *
 */
PSECURITY_DESCRIPTOR
CreateServerSecurityDescriptor(
    VOID
)
{
    DWORD ObjectType = SPOOLER_OBJECT_SERVER;
    NT_PRODUCT_TYPE NtProductType;
    PSID AceSid[MAX_ACE];          // Don't expect more than MAX_ACE ACEs in any of these.
    ACCESS_MASK AceMask[MAX_ACE];  // Access masks corresponding to Sids
    BYTE InheritFlags[MAX_ACE];  //
    UCHAR AceType[MAX_ACE];
    DWORD AceCount;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    PSID WorldSid = NULL;
    PSID AdminsAliasSid = NULL;
    PSID PrintOpsAliasSid = NULL;
    PSID SystemOpsAliasSid = NULL;
    PSID PowerUsersAliasSid = NULL;
    PSID CreatorOwnerSid = NULL;
    PSECURITY_DESCRIPTOR ServerSD = NULL;
    BOOL OK;


    //
    // Printer SD
    //

    AceCount = 0;

    /* Creator-Owner SID: */

    OK = AllocateAndInitializeSid( &CreatorSidAuthority, 1,
                                   SECURITY_CREATOR_OWNER_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   &CreatorOwnerSid );

    DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );

    if ( !OK ) {
        goto CleanUp;
    }


    /* The following is a dummy ACE needed for the ACL editor.
     * Note this is a gross hack, and will result in two ACEs
     * being propagated onto printers when they are created,
     * one of which must be deleted.
     */
    AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[AceCount]           = CreatorOwnerSid;
    AceMask[AceCount]          = DUMMY_ACE_ACCESS_MASK;
    InheritFlags[AceCount]     = INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE;
    AceCount++;

    AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[AceCount]           = CreatorOwnerSid;
    AceMask[AceCount]          = GENERIC_ALL;
    InheritFlags[AceCount]     = INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE;
    AceCount++;


    /* World SID */

    OK = AllocateAndInitializeSid( &WorldSidAuthority, 1,
                                   SECURITY_WORLD_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   &WorldSid );

    DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );

    if ( !OK ) {
        goto CleanUp;
    }

    AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[AceCount]           = WorldSid;
    AceMask[AceCount]          = SERVER_EXECUTE;
    InheritFlags[AceCount]     = 0;
    AceCount++;

    AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[AceCount]           = WorldSid;
    AceMask[AceCount]          = GENERIC_EXECUTE;
    InheritFlags[AceCount]     = INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE;
    AceCount++;


    /* Admins alias SID */

    OK = AllocateAndInitializeSid( &NtAuthority, 2,
                                   SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_ADMINS,
                                   0, 0, 0, 0, 0, 0,
                                   &AdminsAliasSid );

    DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );

    if ( !OK ) {
        goto CleanUp;
    }

    AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[AceCount]           = AdminsAliasSid;
    AceMask[AceCount]          = SERVER_ALL_ACCESS;
    InheritFlags[AceCount]     = 0;
    AceCount++;

    AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[AceCount]           = AdminsAliasSid;
    AceMask[AceCount]          = GENERIC_ALL;
    InheritFlags[AceCount]     = INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
    AceCount++;

    OK = RtlGetNtProductType( &NtProductType );
    DBGCHK( !OK, ( "Couldn't get product type" ) );

    if ( !OK ) {
        goto CleanUp;
    }

    switch (NtProductType) {
    case NtProductLanManNt:
//    case NtProductMember:

        /* Print Ops alias SID */

        OK = AllocateAndInitializeSid( &NtAuthority, 2,
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_PRINT_OPS,
                                       0, 0, 0, 0, 0, 0,
                                       &PrintOpsAliasSid );

        DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );

        if ( !OK ) {
            goto CleanUp;
        }

        AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
        AceSid[AceCount]           = PrintOpsAliasSid;
        AceMask[AceCount]          = SERVER_ALL_ACCESS;
        InheritFlags[AceCount]     = 0;
        AceCount++;

        AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
        AceSid[AceCount]           = PrintOpsAliasSid;
        AceMask[AceCount]          = GENERIC_ALL;
        InheritFlags[AceCount]     = INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
        AceCount++;

        /* System Ops alias SID */

        OK = AllocateAndInitializeSid( &NtAuthority, 2,
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_SYSTEM_OPS,
                                       0, 0, 0, 0, 0, 0,
                                       &SystemOpsAliasSid );
        DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );

        if ( !OK ) {
            goto CleanUp;
        }

        AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
        AceSid[AceCount]           = SystemOpsAliasSid;
        AceMask[AceCount]          = SERVER_ALL_ACCESS;
        InheritFlags[AceCount]     = 0;
        AceCount++;

        AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
        AceSid[AceCount]           = SystemOpsAliasSid;
        AceMask[AceCount]          = GENERIC_ALL;
        InheritFlags[AceCount]     = INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
        AceCount++;

        break;

    case NtProductWinNt:
    default:

        {
            OSVERSIONINFOEX OsVersion = {0};
            
            OsVersion.dwOSVersionInfoSize = sizeof(OsVersion);

            //
            // Whistler Personal does not have the Power Users group.
            //
            if (GetVersionEx((LPOSVERSIONINFO)&OsVersion) && 
                !(OsVersion.wProductType==VER_NT_WORKSTATION && OsVersion.wSuiteMask & VER_SUITE_PERSONAL)) {
                
                OK = AllocateAndInitializeSid( &NtAuthority, 2,
                                               SECURITY_BUILTIN_DOMAIN_RID,
                                               DOMAIN_ALIAS_RID_POWER_USERS,
                                               0, 0, 0, 0, 0, 0,
                                               &PowerUsersAliasSid );
        
        
                DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );
        
                if ( !OK ) {
                    goto CleanUp;
                }
        
                AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
                AceSid[AceCount]           = PowerUsersAliasSid;
                AceMask[AceCount]          = SERVER_ALL_ACCESS;
                InheritFlags[AceCount]     = 0;
                AceCount++;
        
                AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
                AceSid[AceCount]           = PowerUsersAliasSid;
                AceMask[AceCount]          = GENERIC_ALL;
                InheritFlags[AceCount]     = INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
                AceCount++;
            }
        }

        break;
    }

    DBGCHK( ( AceCount > MAX_ACE ), ( "ACE count exceeded" ) );

    if ( AceCount > MAX_ACE ) {
        goto CleanUp;
    }

    OK = BuildPrintObjectProtection( AceType,
                                     AceCount,
                                     AceSid,
                                     AceMask,
                                     InheritFlags,
                                     AdminsAliasSid,
                                     AdminsAliasSid,
                                     &GenericMapping[ObjectType],
                                     &ServerSD );

    DBGCHK( !OK, ( "BuildPrintObjectProtection failed" ) );

CleanUp:

    if (WorldSid) {
        FreeSid( WorldSid );
    }
    if (AdminsAliasSid) {
        FreeSid( AdminsAliasSid );
    }
    if (CreatorOwnerSid) {
        FreeSid( CreatorOwnerSid );
    }
    if (PrintOpsAliasSid) {
        FreeSid( PrintOpsAliasSid );
    }
    if (SystemOpsAliasSid) {
        FreeSid( SystemOpsAliasSid );
    }
    if (PowerUsersAliasSid) {
        FreeSid( PowerUsersAliasSid );
    }

    pServerSecurityDescriptor = ServerSD;

    return ServerSD;
}


/* CreatePrinterSecurityDescriptor
 *
 * Creates a default security descriptor for a printer by inheritance
 * of the access flags in the local spooler's security descriptor.
 * The resulting descriptor is allocated from the process' heap
 * and should be freed by DeletePrinterSecurityDescriptor.
 *
 * Argument: pCreatorSecurityDescriptor - if the creator supplies
 *     a security descriptor, this should point to it.  Otherwise
 *     it should be NULL.
 *
 * Return: The printer's security descriptor
 *
 */
PSECURITY_DESCRIPTOR
CreatePrinterSecurityDescriptor(
    PSECURITY_DESCRIPTOR pCreatorSecurityDescriptor
)
{
    HANDLE               ClientToken;
    PSECURITY_DESCRIPTOR pPrivateObjectSecurity;
    PSECURITY_DESCRIPTOR pPrinterSecurityDescriptor;
    DWORD                ObjectType = SPOOLER_OBJECT_PRINTER;
    BOOL                 OK;
    HANDLE               hToken;
    BOOL                 DaclPresent;
    PACL                 pDacl;
    BOOL                 DaclDefaulted = FALSE;
    DWORD                HackOutAce;


    if( GetTokenHandle( &ClientToken ) )
    {
        hToken = RevertToPrinterSelf( );

        OK = CreatePrivateObjectSecurity( pServerSecurityDescriptor,
                                          pCreatorSecurityDescriptor,
                                          &pPrivateObjectSecurity,
                                          TRUE,     // This is a container
                                          ClientToken,
                                          &GenericMapping[ObjectType] );

        ImpersonatePrinterClient( hToken );

        CloseHandle(ClientToken);

        DBGCHK( !OK, ( "CreatePrivateObjectSecurity failed: Error %d", GetLastError() ) );

        if( !OK )
            return NULL;

        pPrinterSecurityDescriptor = pPrivateObjectSecurity;

        if( !pCreatorSecurityDescriptor )
        {
            GetSecurityDescriptorDacl( pPrinterSecurityDescriptor,
                                       &DaclPresent,
                                       &pDacl,
                                       &DaclDefaulted );



            /* HACK HACK HACK HACK HACK
             *
             * We defined an extra ACE for the benefit of the ACL editor.
             * This is container-inherit,
             * and we want it to propagate onto documents.
             * However, this means it will also propagate onto printers,
             * which we definitely don't want.
             */
            HackOutAce = GetHackOutAce( pDacl );

            if( HackOutAce != (DWORD)-1 )
                DeleteAce( pDacl, HackOutAce );


#if DBG
            if( MODULE_DEBUG & DBG_SECURITY ){
                DBGMSG( DBG_SECURITY, ( "Printer security descriptor DACL:\n" ));
                DumpAcl( pDacl );
            }
#endif /* DBG */
        }

    }
    else
    {
        OK = FALSE;
    }


    return ( OK ? pPrinterSecurityDescriptor : NULL );
}


/*
 *
 */
DWORD GetHackOutAce( PACL pDacl )
{
    DWORD               i;
    PACCESS_ALLOWED_ACE pAce;
    BOOL                OK = TRUE;

    i = 0;

    while( OK )
    {
        OK = GetAce( pDacl, i, (LPVOID *)&pAce );

        DBGCHK( !OK, ( "Failed to get ACE.  Error %d", GetLastError() ) );

        /* Find the dummy ace that isn't inherit-only:
         */
        if( OK && ( pAce->Mask == DUMMY_ACE_ACCESS_MASK )
          &&( !( pAce->Header.AceFlags & INHERIT_ONLY_ACE ) ) )
            return i;
    }

    return (DWORD)-1;
}


/* SetPrinterSecurityDescriptor
 *
 * Arguments:
 *
 *     SecurityInformation - Type of security information to be applied,
 *         typically DACL_SECURITY_INFORMATION.  (This is a 32-bit array.)
 *
 *     pModificationDescriptor - A pointer to a pointer to a security
 *         descriptor to be applied to the previous descriptor.
 *
 *     pObjectSecurityDescriptor - The previous descriptor which is to be
 *         modified.
 *
 *
 * Return:
 *
 *     Boolean indicating success or otherwise.
 *
 */
BOOL
SetPrinterSecurityDescriptor(
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pModificationDescriptor,
    PSECURITY_DESCRIPTOR *ppObjectsSecurityDescriptor
)
{
    HANDLE  ClientToken;
    DWORD   ObjectType = SPOOLER_OBJECT_PRINTER;
    BOOL    OK = FALSE;
    HANDLE  hToken;

    if( GetTokenHandle( &ClientToken ) )
    {
        /* SetPrivateObjectSecurity should not be called when we are
         * impersonating a client, since it may need to allocate memory:
         */
        hToken = RevertToPrinterSelf( );

        OK = SetPrivateObjectSecurity( SecurityInformation,
                                       pModificationDescriptor,
                                       ppObjectsSecurityDescriptor,
                                       &GenericMapping[ObjectType],
                                       ClientToken );

        ImpersonatePrinterClient( hToken );

        DBGCHK( !OK, ( "SetPrivateObjectSecurity failed: Error %d", GetLastError() ) );

        CloseHandle(ClientToken);
    }

    return OK;
}


/* CreateDocumentSecurityDescriptor
 *
 * Creates a default security descriptor for a document by inheritance
 * of the access flags in the supplied printer security descriptor.
 * The resulting descriptor is allocated from the process' heap
 * and should be freed by DeleteDocumentSecurityDescriptor.
 *
 * Argument: The printer's security descriptor
 *
 * Return: The document's security descriptor
 *
 */
PSECURITY_DESCRIPTOR
CreateDocumentSecurityDescriptor(
    PSECURITY_DESCRIPTOR pPrinterSecurityDescriptor
)
{
    HANDLE               ClientToken;
    PSECURITY_DESCRIPTOR pPrivateObjectSecurity;
    PSECURITY_DESCRIPTOR pDocumentSecurityDescriptor;
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD                ObjectType = SPOOLER_OBJECT_DOCUMENT;
    BOOL                 OK = FALSE;
    HANDLE               hToken;

    if( GetTokenHandle( &ClientToken ) )
    {
        hToken = RevertToPrinterSelf( );

        //
        // The function CreateDocumentSecurityDescriptor does not preserve
        // the last error correctly. If CreatePrivateObjectSecurityEx fails,
        // it sets the last error. But after that, 
        //
        OK = BuildJobOwnerSecurityDescriptor(ClientToken, &pSD) &&
             CreatePrivateObjectSecurityEx(pPrinterSecurityDescriptor,
                                           pSD,
                                           &pPrivateObjectSecurity,
                                           NULL,
                                           FALSE,    // This is not a container
                                           SEF_DACL_AUTO_INHERIT | SEF_SACL_AUTO_INHERIT,
                                           ClientToken,
                                           &GenericMapping[ObjectType] );

        DestroyJobOwnerSecurityDescriptor(pSD);

        ImpersonatePrinterClient( hToken );

        CloseHandle(ClientToken);

        DBGCHK( !OK, ( "CreatePrivateObjectSecurity failed: Error %d", GetLastError() ) );

        if( !OK )
            return NULL;

        pDocumentSecurityDescriptor = pPrivateObjectSecurity;

#if DBG
        if( MODULE_DEBUG & DBG_SECURITY )
        {
            BOOL DaclPresent;
            PACL pDacl;
            BOOL DaclDefaulted = FALSE;

            GetSecurityDescriptorDacl( pDocumentSecurityDescriptor,
                                       &DaclPresent,
                                       &pDacl,
                                       &DaclDefaulted );

            DBGMSG( DBG_SECURITY, ( "Document security descriptor DACL:\n" ));

            DumpAcl( pDacl );
        }
#endif /* DBG */

    }
    else
    {
        OK = FALSE;
    }

    return ( OK ? pDocumentSecurityDescriptor : NULL );
}


/*
 *
 */
BOOL DeletePrinterSecurity(
    PINIPRINTER pIniPrinter
)
{
    BOOL OK;

    OK = DestroyPrivateObjectSecurity( &pIniPrinter->pSecurityDescriptor );
    pIniPrinter->pSecurityDescriptor = NULL;

    DBGCHK( !OK, ( "DestroyPrivateObjectSecurity failed.  Error %d", GetLastError() ) );

    return OK;
}


/*
 *
 */
BOOL DeleteDocumentSecurity(
    PINIJOB pIniJob
)
{
    BOOL OK;

    OK = DestroyPrivateObjectSecurity( &pIniJob->pSecurityDescriptor );

    DBGCHK( !OK, ( "DestroyPrivateObjectSecurity failed.  Error %d", GetLastError() ) );

    OK = ObjectCloseAuditAlarm( szSpooler, pIniJob,
                                pIniJob->GenerateOnClose );

    DBGCHK( !OK, ( "ObjectCloseAuditAlarm failed.  Error %d", GetLastError() ) );

    return OK;
}





#ifdef OLDSTUFF

/* AllocateLocalSD
 *
 * Makes a copy of a security descriptor, allocating it out of the local heap.
 * The source descriptor MUST be in self-relative format.
 *
 * Argument
 *
 *   pSourceSD - Pointer to a self-relative security descriptor
 *
 *
 * Returns
 *
 *   A pointer to a locally allocated security descriptor.
 *
 *   If the function fails to allocate the memory, NULL is returned.
 *
 * Note, if an invalid security descriptor is passed to
 * GetSecurityDescriptorLength, the return value is undefined,
 * therefore the caller should ensure that the source is valid.
 */
PSECURITY_DESCRIPTOR AllocateLocalSD( PSECURITY_DESCRIPTOR pSourceSD )
{
    DWORD                Length;
    PSECURITY_DESCRIPTOR pLocalSD;

    Length = GetSecurityDescriptorLength( pSourceSD );

    pLocalSD = AllocSplMem( Length );

    if( pLocalSD )
    {
        memcpy( pLocalSD, pSourceSD, Length );
    }

    return pLocalSD;
}

#endif /* OLDSTUFF */


//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



BOOL
BuildPrintObjectProtection(
    IN PUCHAR AceType,
    IN DWORD AceCount,
    IN PSID *AceSid,
    IN ACCESS_MASK *AceMask,
    IN BYTE *InheritFlags,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PGENERIC_MAPPING GenericMap,
    OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor
    )

/*++


Routine Description:

    This routine builds a self-relative security descriptor ready
    to be applied to one of the print manager objects.

    If so indicated, a pointer to the last RID of the SID in the last
    ACE of the DACL is returned and a flag set indicating that the RID
    must be replaced before the security descriptor is applied to an object.
    This is to support USER object protection, which must grant some
    access to the user represented by the object.


    The SACL of each of these objects will be set to:


                    Audit
                    Success | Fail
                    WORLD
                    (Write | Delete | WriteDacl | AccessSystemSecurity)



Arguments:

    AceType - Array of AceTypes.
              Must be ACCESS_ALLOWED_ACE_TYPE or ACCESS_DENIED_ACE_TYPE.

    AceCount - The number of ACEs to be included in the DACL.

    AceSid - Points to an array of SIDs to be granted access by the DACL.
        If the target SAM object is a User object, then the last entry
        in this array is expected to be the SID of an account within the
        domain with the last RID not yet set.  The RID will be set during
        actual account creation.

    AceMask - Points to an array of accesses to be granted by the DACL.
        The n'th entry of this array corresponds to the n'th entry of
        the AceSid array.  These masks should not include any generic
        access types.

    InheritFlags - Pointer to an array of inherit flags.
        The n'th entry of this array corresponds to the n'th entry of
        the AceSid array.

    OwnerSid - The SID of the owner to be assigned to the descriptor.

    GroupSid - The SID of the group to be assigned to the descriptor.

    GenericMap - Points to a generic mapping for the target object type.

    ppSecurityDescriptor - Receives a pointer to the security descriptor.
        This will be allcated from the process' heap, not the spooler's,
        and should therefore be freed with LocalFree().


    IN DWORD AceCount,
    IN PSID *AceSid,
    IN ACCESS_MASK *AceMask,
    IN BYTE *InheritFlags,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PGENERIC_MAPPING GenericMap,
    OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor

Return Value:

    TBS.

--*/
{



    SECURITY_DESCRIPTOR     Absolute;
    PSECURITY_DESCRIPTOR    Relative = NULL;
    PACL                    TmpAcl= NULL;
    PACCESS_ALLOWED_ACE     TmpAce;
    DWORD                   SDLength;
    DWORD                   DaclLength;
    DWORD                   i;
    BOOL                    bReturn = FALSE;
    
    //
    // The approach is to set up an absolute security descriptor that
    // looks like what we want and then copy it to make a self-relative
    // security descriptor.
    //

    if (InitializeSecurityDescriptor( &Absolute,
                                      SECURITY_DESCRIPTOR_REVISION1 ) &&

        SetSecurityDescriptorOwner( &Absolute, OwnerSid, FALSE ) && 

        SetSecurityDescriptorGroup( &Absolute, GroupSid, FALSE ) ) {

        //
        // Discretionary ACL
        //
        //      Calculate its length,
        //      Allocate it,
        //      Initialize it,
        //      Add each ACE
        //      Set ACE as InheritOnly if necessary
        //      Add it to the security descriptor
        //

        DaclLength = (DWORD)sizeof(ACL);
        for (i=0; i<AceCount; i++) {

            DaclLength += GetLengthSid( AceSid[i] ) +
                          (DWORD)sizeof(ACCESS_ALLOWED_ACE) -
                          (DWORD)sizeof(DWORD);  //Subtract out SidStart field length
        }

        TmpAcl = AllocSplMem( DaclLength );
        
        if (TmpAcl &&  InitializeAcl( TmpAcl, DaclLength, ACL_REVISION2 )) {

            BOOL bLoop = TRUE;
            for (i=0; bLoop && i < AceCount; i++)
            {
                if( AceType[i] == ACCESS_ALLOWED_ACE_TYPE ) {
                    bLoop = AddAccessAllowedAce ( TmpAcl, ACL_REVISION2, AceMask[i], AceSid[i] );
                } else {
                    bLoop = AddAccessDeniedAce ( TmpAcl, ACL_REVISION2, AceMask[i], AceSid[i] );
                }

                if (bLoop) {
                    if (InheritFlags[i] != 0)
                    {
                        if ( bLoop = GetAce( TmpAcl, i, (LPVOID *)&TmpAce )) {
                            TmpAce->Header.AceFlags = InheritFlags[i];
                        }
                    }
                }
            }

            if (bLoop) {
                #if DBG
                    DBGMSG( DBG_SECURITY, ( "Server security descriptor DACL:\n" ) );

                    DumpAcl(TmpAcl);
                #endif /* DBG */

                if (SetSecurityDescriptorDacl (&Absolute, TRUE, TmpAcl, FALSE )) {
                
                    //
                    // Convert the Security Descriptor to Self-Relative
                    //
                    //      Get the length needed
                    //      Allocate that much memory
                    //      Copy it
                    //      Free the generated absolute ACLs
                    //

                    SDLength = GetSecurityDescriptorLength( &Absolute );

                    Relative = LocalAlloc( 0, SDLength );                                        

                    if (Relative) {
                        bReturn = MakeSelfRelativeSD(&Absolute, Relative, &SDLength );
                    }
                }
            }
        }
    }

    if (bReturn) {
        *ppSecurityDescriptor = Relative;
    } else {

        *ppSecurityDescriptor = NULL;
        if (Relative) {
            LocalFree(Relative);
        }
    }

    if (TmpAcl){
        FreeSplMem(TmpAcl);
    }

    return(bReturn);

}




BOOL
ValidateObjectAccess(
    IN DWORD                ObjectType,
    IN ACCESS_MASK          DesiredAccess,
    IN LPVOID               ObjectHandle,
    OUT PACCESS_MASK        pGrantedAccess,
    IN PINISPOOLER          pIniSpooler
)

/*++


Routine Description:

Arguments:

    ObjectType - SPOOLER_OBJECT_* value, which is an index into the global
        mapping for spooler objects.

    DesiredAccess - The type of access requested.

    ObjectHandle - If ObjectType == SPOOLER_OBJECT_PRINTER, this must be
        a printer handle, if SPOOLER_OBJECT_DOCUMENT, a pointer to a INIJOB
        structure.  For SPOOLER_OBJECT_SERVER this is ignored.

Return Value:

    TRUE if requested access is granted.


--*/
{
    LPWSTR               pObjectName;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    PSPOOL               pSpool = NULL;
    PINIPRINTER          pIniPrinter;
    PINIJOB              pIniJob;
    HANDLE            ClientToken;
    BOOL              AccessCheckOK;
    BOOL              OK;
    BOOL              AccessStatus = TRUE;
    ACCESS_MASK       MappedDesiredAccess;
    DWORD             GrantedAccess = 0;
    PBOOL             pGenerateOnClose;
    BYTE              PrivilegeSetBuffer[256];
    DWORD             PrivilegeSetBufferLength = 256;
    PPRIVILEGE_SET    pPrivilegeSet;
    BOOL              HackForNoImpersonationToken = FALSE;
    DWORD             dwRetCode;

    PTOKEN_PRIVILEGES pPreviousTokenPrivileges;
    DWORD PreviousTokenPrivilegesLength;

    //
    //  Some Print Providers may not require Security
    //

    if ( (pIniSpooler->SpoolerFlags & SPL_SECURITY_CHECK) == FALSE ) return TRUE;


    switch( ObjectType )
    {
    case SPOOLER_OBJECT_SERVER:
    case SPOOLER_OBJECT_XCV:
        if( ObjectHandle )
            pSpool = ObjectHandle;
        ObjectHandle = pIniSpooler;
        pObjectName = pIniSpooler->pMachineName;
        pSecurityDescriptor = pServerSecurityDescriptor;
        pGenerateOnClose = &ServerGenerateOnClose;
        break;

    case SPOOLER_OBJECT_PRINTER:
        pSpool = ObjectHandle;
        pIniPrinter = pSpool->pIniPrinter;
        pObjectName = pIniPrinter->pName;
        pSecurityDescriptor = pIniPrinter->pSecurityDescriptor;
        pGenerateOnClose = &pSpool->GenerateOnClose;
        break;

    case SPOOLER_OBJECT_DOCUMENT:
        pIniJob = (PINIJOB)ObjectHandle;
        pObjectName = pIniJob->pDocument;
        pSecurityDescriptor = pIniJob->pSecurityDescriptor;
        pGenerateOnClose = &pIniJob->GenerateOnClose;
        break;
    }

    MapGenericToSpecificAccess( ObjectType, DesiredAccess, &MappedDesiredAccess );

    if (!(OK = GetTokenHandle(&ClientToken))) {
        if (pGrantedAccess) {
            *pGrantedAccess = 0;
        }
        return(FALSE);
    }

    if (MappedDesiredAccess & ACCESS_SYSTEM_SECURITY) {
        if (!SetRequiredPrivileges( ClientToken,
                                    &pPreviousTokenPrivileges,
                                    &PreviousTokenPrivilegesLength
                                    )) {
            if (pGrantedAccess) {
                *pGrantedAccess = 0;
            }
            CloseHandle(ClientToken);
            return(FALSE);
        }
    }
    pPrivilegeSet = (PPRIVILEGE_SET)PrivilegeSetBuffer;


    /* Call AccessCheck followed by ObjectOpenAuditAlarm rather than
     * AccessCheckAndAuditAlarm, because we may need to enable
     * SeSecurityPrivilege in order to check for ACCESS_SYSTEM_SECURITY
     * privilege.  We must ensure that the security access-checking
     * API has the actual token whose security privilege we have enabled.
     * AccessCheckAndAuditAlarm is no good for this, because it opens
     * the client's token again, which may not have the privilege enabled.
     */
    AccessCheckOK = AccessCheck( pSecurityDescriptor,
                                 ClientToken,
                                 MappedDesiredAccess,
                                 &GenericMapping[ObjectType],
                                 pPrivilegeSet,
                                 &PrivilegeSetBufferLength,
                                 &GrantedAccess,
                                 &AccessStatus );

    if (!AccessCheckOK) {

        if (GetLastError() == ERROR_NO_IMPERSONATION_TOKEN) {
            DBGMSG(DBG_TRACE, ("No impersonation token.  Access will be granted.\n"));
            HackForNoImpersonationToken = TRUE;
            dwRetCode = ERROR_SUCCESS;
            GrantedAccess = MappedDesiredAccess;
        } else {
            dwRetCode = GetLastError();

        }
        pPrivilegeSet = NULL;
    } else {
        
        if (!AccessStatus) {
            dwRetCode = GetLastError();            
        }
    }

    OK = ObjectOpenAuditAlarm( szSpooler,
                               ObjectHandle,
                               ObjectTypeName[ObjectType],
                               pObjectName,
                               pSecurityDescriptor,
                               ClientToken,
                               MappedDesiredAccess,
                               GrantedAccess,
                               pPrivilegeSet,
                               FALSE,  /* No new object creation */
                               AccessStatus,
                               pGenerateOnClose );


    if( MappedDesiredAccess & ACCESS_SYSTEM_SECURITY )
        ResetRequiredPrivileges( ClientToken,
                                 pPreviousTokenPrivileges,
                                 PreviousTokenPrivilegesLength );

    if( !pSpool )
        ObjectCloseAuditAlarm( szSpooler, ObjectHandle, *pGenerateOnClose );


    //
    // Allowing power users to install printer drivers or other dlls into the 
    // trusted component base is a security hole. We now require that administrators
    // and power users have the load driver privilege present in the token in order
    // to be able to preform administrative tasks on the spooler. See bug 352856
    // for more details.
    //
    if (AccessCheckOK && 
        AccessStatus  && 
        ObjectType == SPOOLER_OBJECT_SERVER &&
        GrantedAccess & SERVER_ACCESS_ADMINISTER) 
    {
        BOOL  bPrivPresent;
        DWORD Attributes;
        
        dwRetCode = CheckPrivilegePresent(ClientToken,
                                          &gLoadDriverPrivilegeLuid,
                                          &bPrivPresent,
                                          &Attributes);
    
        if (dwRetCode == ERROR_SUCCESS) 
        {
            //
            // The reason why we check if the load driver privilege is present and
            // not present AND enabled is the following. Let's assume you have been
            // granted the privilege to load drivers.
            // When you logon on interactively SeLoadDriverPrivilege is enabled.
            // When you logon on via the secondary logon (runas which calls
            // CreateProcessWithLogonW) then the privilege is disabled. We do not want
            // to have inconsistent behavior regarding administering the spooler server.
            //
            if (!bPrivPresent) 
            {
                //
                // The caller has been granted SERVER_ACCESS_ADMINISTER permission but
                // the caller doesn't have the privilege to load drivers. We do not 
                // grant the desired access in this case.
                //
                GrantedAccess = 0;
                AccessStatus  = FALSE;
                dwRetCode     = ERROR_ACCESS_DENIED;
            }
        }
        else
        {
            //
            // We cannot determine if the privilege is held, so we need to fail 
            // the AccessCheck function.
            // 
            GrantedAccess = 0;
            AccessCheckOK = FALSE;
            dwRetCode     = GetLastError();
        }          
    }

    CloseHandle (ClientToken);

    if( pGrantedAccess )
        *pGrantedAccess = GrantedAccess;

    //
    // we do the setlasterror here because we may have failed the AccessCheck
    // or we succeeded but are denied access but the ObjectOpenAuditAlarm went
    // thru smoothly and now there is no error code to return on the function
    // so we specify the dwRetCode if we did fail.
    //

    if (!AccessCheckOK || !AccessStatus) {
        SetLastError(dwRetCode);
    }

    return ( ( OK && AccessCheckOK && AccessStatus ) || HackForNoImpersonationToken );
}


/* AccessGranted
 *
 * Checks whether the desired access is granted, by comparing the GrantedAccess
 * mask pointed to by pSpool.
 *
 * Parameters
 *
 *     ObjectType - SPOOLER_OBJECT_* value, which is an index into the global
 *         mapping for spooler objects.  This will not be SPOOLER_OBJECT_DOCUMENT,
 *         since we don't have document handles.  It could potentially be
 *         SPOOLER_OBJECT_SERVER.
 *
 *      DesiredAccess - The type of access requested.
 *
 *      pSpool - A pointer to the SPOOL structure
 *
 * Returns
 *
 *      TRUE - Access is granted
 *      FALSE - Access is not granted
 */
BOOL
AccessGranted(
    DWORD       ObjectType,
    ACCESS_MASK DesiredAccess,
    PSPOOL      pSpool
)
{

    if ( (pSpool->pIniSpooler->SpoolerFlags & SPL_SECURITY_CHECK) == FALSE ) return TRUE;

    MapGenericMask( &DesiredAccess,
                    &GenericMapping[ObjectType] );

    return AreAllAccessesGranted( pSpool->GrantedAccess, DesiredAccess );
}


// Stolen from windows\base\username.c
// !!! Must close the handle that is returned
BOOL
GetTokenHandle(
    PHANDLE pTokenHandle
    )
{
    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                         TRUE,
                         pTokenHandle)) {

        if (GetLastError() == ERROR_NO_TOKEN) {

            // This means we are not impersonating anybody.
            // Instead, lets get the token out of the process.

            if (!OpenProcessToken(GetCurrentProcess(),
                                  TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                  pTokenHandle)) {

                return FALSE;
            }

        } else

            return FALSE;
    }

    return TRUE;
}



VOID MapGenericToSpecificAccess(
    DWORD ObjectType,
    DWORD GenericAccess,
    PDWORD pSpecificAccess
    )
{
    *pSpecificAccess = GenericAccess;

    MapGenericMask( pSpecificAccess,
                    &GenericMapping[ObjectType] );
}


/* GetSecurityInformation
 *
 * Fills in the security information with a mask specifying the contents
 * of the security descriptor.
 *
 * Parameters
 *
 *     pSecurityDescriptor - A pointer to a security descriptor
 *         that the caller wishes to set.  This may be NULL.
 *
 *     pSecurityInformation - A pointer to a buffer to receive
 *         the security information flags.
 *
 *
 * Warning: This is an egregious hack.
 * We need to find out what is being set so we can verify the caller
 * has the required privileges.
 * There's no way an app like Print Manager can tell us what bits
 * of the security descriptor it wants to set.
 *
 * The following flags may be set:
 *
 *     OWNER_SECURITY_INFORMATION
 *     GROUP_SECURITY_INFORMATION
 *     DACL_SECURITY_INFORMATION
 *     SACL_SECURITY_INFORMATION
 *
 * Returns
 *
 *     TRUE - No errors occurred
 *     FALSE - An error occurred
 *
 */
BOOL
GetSecurityInformation(
    PSECURITY_DESCRIPTOR  pSecurityDescriptor,
    PSECURITY_INFORMATION pSecurityInformation
)
{
    SECURITY_INFORMATION SecurityInformation = 0;
    BOOL                 Defaulted;
    PSID                 pSidOwner;
    PSID                 pSidGroup;
    BOOL                 DaclPresent;
    PACL                 pDacl;
    BOOL                 SaclPresent;
    PACL                 pSacl;
    BOOL                 rc = TRUE;


    if( pSecurityDescriptor
      && IsValidSecurityDescriptor( pSecurityDescriptor ) )
    {
        if( GetSecurityDescriptorOwner( pSecurityDescriptor, &pSidOwner, &Defaulted )
         && GetSecurityDescriptorGroup( pSecurityDescriptor, &pSidGroup, &Defaulted )
         && GetSecurityDescriptorDacl( pSecurityDescriptor, &DaclPresent, &pDacl, &Defaulted )
         && GetSecurityDescriptorSacl( pSecurityDescriptor, &SaclPresent, &pSacl, &Defaulted ) )
        {
            if( pSidOwner )
                SecurityInformation |= OWNER_SECURITY_INFORMATION;
            if( pSidGroup )
                SecurityInformation |= GROUP_SECURITY_INFORMATION;
            if( DaclPresent )
                SecurityInformation |= DACL_SECURITY_INFORMATION;
            if( SaclPresent )
                SecurityInformation |= SACL_SECURITY_INFORMATION;
        }

        else
            rc = FALSE;
    }else {
        DBGMSG(DBG_TRACE, ("Either NULL  pSecurityDescriptor or !IsValidSecurityDescriptor %.8x\n", pSecurityDescriptor));
        rc = FALSE;
    }
    DBGMSG( DBG_TRACE, ("GetSecurityInformation returns %d with  SecurityInformation = %08x\n", rc, SecurityInformation) );

    *pSecurityInformation = SecurityInformation;

    return rc;
}


/* GetPrivilegeRequired
 *
 * Returns a mask containing the privileges required to set the specified
 * security information.
 *
 * Parameter
 *
 *     SecurityInformation - Flags specifying the security information
 *         that the caller wishes to set.  This may be 0.
 *
 * Returns
 *
 *     An access mask specifying the privileges required.
 *
 */
ACCESS_MASK
GetPrivilegeRequired(
    SECURITY_INFORMATION SecurityInformation
)
{
    ACCESS_MASK PrivilegeRequired = 0;

    if( SecurityInformation & OWNER_SECURITY_INFORMATION )
        PrivilegeRequired |= WRITE_OWNER;
    if( SecurityInformation & GROUP_SECURITY_INFORMATION )
        PrivilegeRequired |= WRITE_OWNER;
    if( SecurityInformation & DACL_SECURITY_INFORMATION )
        PrivilegeRequired |= WRITE_DAC;
    if( SecurityInformation & SACL_SECURITY_INFORMATION )
        PrivilegeRequired |= ACCESS_SYSTEM_SECURITY;

    return PrivilegeRequired;
}


/* BuildPartialSecurityDescriptor
 *
 * Creates a copy of the source security descriptor, omitting those
 * parts of the descriptor which the AccessGranted mask doesn't give
 * read access to.
 *
 * Parameters
 *
 *     AccessMask - Defines the permissions held by the client.
 *         This may include READ_CONTROL or ACCESS_SYSTEM_SECURITY.
 *
 *     pSourceSecurityDescriptor - A pointer to the security descriptor
 *         upon which the partial security descriptor will be based.
 *         Its Owner, Group, DACL and SACL will be copied appropriately,
 *
 *     ppPartialSecurityDescriptor - A pointer to a variable which
 *         will receive the address of the newly created descriptor.
 *         If the AccessMask parameter contains neither READ_CONTROL
 *         nor ACCESS_SYSTEM_SECURITY, the descriptor will be empty.
 *         The descriptor will be in  self-relative format, and must
 *         be freed by the caller using FreeSplMem().
 *
 *     pPartialSecurityDescriptorLength - A pointer to a variable
 *         to receive the length of the security descriptor.
 *         This should be passed as the second parameter to FreeSplMem()
 *         when the descriptor is freed.
 *
 * Returns
 *
 *     TRUE - No error was detected
 *     FALSE - An error was detected
 *
 */
BOOL
BuildPartialSecurityDescriptor(
    ACCESS_MASK          AccessGranted,
    PSECURITY_DESCRIPTOR pSourceSecurityDescriptor,
    PSECURITY_DESCRIPTOR *ppPartialSecurityDescriptor,
    PDWORD               pPartialSecurityDescriptorLength
)
{
    SECURITY_DESCRIPTOR AbsolutePartialSecurityDescriptor;
    BOOL Defaulted = FALSE;
    PSID pOwnerSid = NULL;
    PSID pGroupSid = NULL;
    BOOL DaclPresent = FALSE;
    PACL pDacl = NULL;
    BOOL SaclPresent = FALSE;
    PACL pSacl = NULL;
    BOOL ErrorOccurred = FALSE;
    DWORD Length = 0;
    PSECURITY_DESCRIPTOR pSelfRelativePartialSecurityDescriptor = NULL;

    /* When we've initialized the security descriptor,
     * it will have no owner, no primary group, no DACL and no SACL:
     */
    if( InitializeSecurityDescriptor( &AbsolutePartialSecurityDescriptor,
                                      SECURITY_DESCRIPTOR_REVISION1 ) )
    {
        /* If the caller has READ_CONTROL permission,
         * set the Owner, Group and DACL:
         */
        if( AreAllAccessesGranted( AccessGranted, READ_CONTROL ) )
        {
            if( GetSecurityDescriptorOwner( pSourceSecurityDescriptor,
                                            &pOwnerSid, &Defaulted ) )
                SetSecurityDescriptorOwner( &AbsolutePartialSecurityDescriptor,
                                            pOwnerSid, Defaulted );
            else
                ErrorOccurred = TRUE;

            if( GetSecurityDescriptorGroup( pSourceSecurityDescriptor,
                                            &pGroupSid, &Defaulted ) )
                SetSecurityDescriptorGroup( &AbsolutePartialSecurityDescriptor,
                                            pGroupSid, Defaulted );
            else
                ErrorOccurred = TRUE;

            if( GetSecurityDescriptorDacl( pSourceSecurityDescriptor,
                                           &DaclPresent, &pDacl, &Defaulted ) )
                SetSecurityDescriptorDacl( &AbsolutePartialSecurityDescriptor,
                                           DaclPresent, pDacl, Defaulted );
            else
                ErrorOccurred = TRUE;
        }

        /* If the caller has ACCESS_SYSTEM_SECURITY permission,
         * set the SACL:
         */
        if( AreAllAccessesGranted( AccessGranted, ACCESS_SYSTEM_SECURITY ) )
        {
            if( GetSecurityDescriptorSacl( pSourceSecurityDescriptor,
                                           &SaclPresent, &pSacl, &Defaulted ) )
                SetSecurityDescriptorSacl( &AbsolutePartialSecurityDescriptor,
                                           SaclPresent, pSacl, Defaulted );
            else
                ErrorOccurred = TRUE;
        }

        if( !ErrorOccurred )
        {
            Length = 0;

            if( !MakeSelfRelativeSD( &AbsolutePartialSecurityDescriptor,
                                     pSelfRelativePartialSecurityDescriptor,
                                     &Length ) )
            {
                if( GetLastError( ) == ERROR_INSUFFICIENT_BUFFER )
                {
                    pSelfRelativePartialSecurityDescriptor = AllocSplMem( Length );

                    if( !pSelfRelativePartialSecurityDescriptor
                     || !MakeSelfRelativeSD( &AbsolutePartialSecurityDescriptor,
                                             pSelfRelativePartialSecurityDescriptor,
                                             &Length ) )
                    {
                        ErrorOccurred = TRUE;
                    }
                }

                else
                {
                    ErrorOccurred = TRUE;

                    DBGMSG(DBG_WARNING, ("MakeSelfRelativeSD failed: Error %d\n",
                                         GetLastError()));
                }
            }
            else
            {
                DBGMSG(DBG_WARNING, ("Expected MakeSelfRelativeSD to fail!\n"));
            }
        }
    }

    else
        ErrorOccurred = TRUE;


    if( !ErrorOccurred )
    {
        *ppPartialSecurityDescriptor = pSelfRelativePartialSecurityDescriptor;
        *pPartialSecurityDescriptorLength = Length;
    }

    return !ErrorOccurred;
}






BOOL
SetRequiredPrivileges(
    IN  HANDLE            TokenHandle,
    OUT PTOKEN_PRIVILEGES *ppPreviousTokenPrivileges,
    OUT PDWORD            pPreviousTokenPrivilegesLength
    )
/*++


Routine Description:

Arguments:

    TokenHandle - A token associated with the current thread or process

    ppPreviousTokenPrivileges - This will be filled with the address of the
        buffer allocated to hold the previously existing privileges for this
        process or thread.

    pPreviousTokenPrivilegesLength - This will be filled with the length of the
        buffer allocated.

Return Value:

    TRUE if successful.


--*/
{
    /* Make enough room for TOKEN_PRIVILEGES with an array of 2 Privileges
     * (there's 1 by default):
     */
#define PRIV_SECURITY   0
#define PRIV_COUNT      1

    LUID              SecurityValue;

    BYTE              TokenPrivilegesBuffer[ sizeof( TOKEN_PRIVILEGES ) +
                                             ( ( PRIV_COUNT - 1 ) *
                                               sizeof( LUID_AND_ATTRIBUTES ) ) ];
    PTOKEN_PRIVILEGES pTokenPrivileges;
    DWORD             FirstTryBufferLength = 256;
    DWORD             BytesNeeded;

    //
    // First, assert Audit privilege
    //

    memset( &SecurityValue, 0, sizeof SecurityValue );

    if( !LookupPrivilegeValue( NULL, SE_SECURITY_NAME, &SecurityValue ) )
    {
        DBGMSG( DBG_WARNING,
                ( "LookupPrivilegeValue failed: Error %d\n", GetLastError( ) ) );
        return FALSE;
    }

    /* Allocate a buffer of a reasonable length to hold the current privileges,
     * so we can restore them later:
     */
    *pPreviousTokenPrivilegesLength = FirstTryBufferLength;
    if( !( *ppPreviousTokenPrivileges = AllocSplMem( FirstTryBufferLength ) ) )
        return FALSE;

    memset( &TokenPrivilegesBuffer, 0, sizeof TokenPrivilegesBuffer );
    pTokenPrivileges = (PTOKEN_PRIVILEGES)&TokenPrivilegesBuffer;

    /*
     * Set up the privilege set we will need
     */
    pTokenPrivileges->PrivilegeCount = PRIV_COUNT;
    pTokenPrivileges->Privileges[PRIV_SECURITY].Luid = SecurityValue;
    pTokenPrivileges->Privileges[PRIV_SECURITY].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges( TokenHandle,
                                FALSE,
                                pTokenPrivileges,
                                *pPreviousTokenPrivilegesLength,
                                *ppPreviousTokenPrivileges,
                                &BytesNeeded )) {

        if( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            *pPreviousTokenPrivilegesLength = BytesNeeded;
            *ppPreviousTokenPrivileges = ReallocSplMem(
                                             *ppPreviousTokenPrivileges,
                                             0,
                                             *pPreviousTokenPrivilegesLength );

            if( *ppPreviousTokenPrivileges )
            {
                if (!AdjustTokenPrivileges( TokenHandle,
                                            FALSE,
                                            pTokenPrivileges,
                                            *pPreviousTokenPrivilegesLength,
                                            *ppPreviousTokenPrivileges,
                                            &BytesNeeded )) {

                    DBGMSG( DBG_WARNING, ("AdjustTokenPrivileges failed: Error %d\n", GetLastError()));
                    goto Fail;
                }
            }
            else
            {
                *pPreviousTokenPrivilegesLength = 0;
                goto Fail;
            }

        }
        else
        {
            DBGMSG( DBG_WARNING, ("AdjustTokenPrivileges failed: Error %d\n", GetLastError()));
            goto Fail;
        }
    }

    return TRUE;

Fail:
    if (*ppPreviousTokenPrivileges) {

        FreeSplMem(*ppPreviousTokenPrivileges);
    }
    return FALSE;
}


BOOL
ResetRequiredPrivileges(
    IN HANDLE            TokenHandle,
    IN PTOKEN_PRIVILEGES pPreviousTokenPrivileges,
    IN DWORD             PreviousTokenPrivilegesLength
    )
/*++


Routine Description:

Arguments:

    TokenHandle - A token associated with the current thread or process

    pPreviousTokenPrivileges - The address of the buffer holding the previous
        privileges to be reinstated.

    PreviousTokenPrivilegesLength - Length of the buffer for deallocation.

Return Value:

    TRUE if successful.


--*/
{
    BOOL OK;

    OK = AdjustTokenPrivileges ( TokenHandle,
                                 FALSE,
                                 pPreviousTokenPrivileges,
                                 0,
                                 NULL,
                                 NULL );

    FreeSplMem( pPreviousTokenPrivileges );

    return OK;
}



/* CreateEverybodySecurityDescriptor
 *
 * Creates a security descriptor giving everyone access
 *
 * Arguments: None
 *
 * Return: The security descriptor returned by BuildPrintObjectProtection.
 *
 */
#undef  MAX_ACE
#define MAX_ACE 5
#define DBGCHK( Condition, ErrorInfo ) \
    if( Condition ) DBGMSG( DBG_WARNING, ErrorInfo )

PSECURITY_DESCRIPTOR
CreateEverybodySecurityDescriptor(
    VOID
)
{
    UCHAR AceType[MAX_ACE];
    PSID AceSid[MAX_ACE];          // Don't expect more than MAX_ACE ACEs in any of these.
    DWORD AceCount;
    //
    // For Code optimization we replace 5 individaul 
    // SID_IDENTIFIER_AUTHORITY with an array of 
    // SID_IDENTIFIER_AUTHORITYs
    // where
    // SidAuthority[0] = UserSidAuthority   
    // SidAuthority[1] = PowerSidAuthority  
    // SidAuthority[2] = CreatorSidAuthority
    // SidAuthority[3] = SystemSidAuthority 
    // SidAuthority[4] = AdminSidAuthority  
    //
    SID_IDENTIFIER_AUTHORITY SidAuthority[MAX_ACE] = {
                                                      SECURITY_NT_AUTHORITY,          
                                                      SECURITY_NT_AUTHORITY,          
                                                      SECURITY_CREATOR_SID_AUTHORITY, 
                                                      SECURITY_NT_AUTHORITY,          
                                                      SECURITY_NT_AUTHORITY           
                                                     };
    //
    // For code optimization we replace 5 individual Sids with 
    // an array of Sids
    // where 
    // Sid[0] = UserSid
    // Sid[1] = PowerSid
    // Sid[2] = CreatorSid
    // Sid[3] = SystemSid
    // Sid[4] = AdminSid
    //
    PSID Sids[MAX_ACE] = {NULL,NULL,NULL,NULL,NULL};
    //
    // Access masks corresponding to Sids
    //
    ACCESS_MASK AceMask[MAX_ACE] = { 
                                     (FILE_GENERIC_EXECUTE | SYNCHRONIZE | FILE_GENERIC_WRITE | FILE_GENERIC_READ) & 
                                     ~READ_CONTROL & ~FILE_WRITE_ATTRIBUTES &
                                     ~FILE_WRITE_EA&~FILE_READ_DATA&~FILE_LIST_DIRECTORY ,
                                     (FILE_GENERIC_EXECUTE | SYNCHRONIZE | FILE_GENERIC_WRITE | FILE_GENERIC_READ) & 
                                     ~READ_CONTROL & ~FILE_WRITE_ATTRIBUTES &
                                     ~FILE_WRITE_EA&~FILE_READ_DATA&~FILE_LIST_DIRECTORY ,
                                     STANDARD_RIGHTS_ALL | FILE_GENERIC_EXECUTE | FILE_GENERIC_WRITE | 
                                     FILE_GENERIC_READ | FILE_ALL_ACCESS ,
                                     STANDARD_RIGHTS_ALL | FILE_GENERIC_EXECUTE | FILE_GENERIC_WRITE | 
                                     FILE_GENERIC_READ | FILE_ALL_ACCESS ,
                                     STANDARD_RIGHTS_ALL | FILE_GENERIC_EXECUTE | FILE_GENERIC_WRITE | 
                                     FILE_GENERIC_READ | FILE_ALL_ACCESS ,
                                   };
    //
    // SubAuthorities leading to the proper Group
    //
    DWORD SubAuthorities[3*MAX_ACE] = { 
                                       2 , SECURITY_BUILTIN_DOMAIN_RID , DOMAIN_ALIAS_RID_USERS ,  
                                       2 , SECURITY_BUILTIN_DOMAIN_RID , DOMAIN_ALIAS_RID_POWER_USERS ,
                                       1 , SECURITY_CREATOR_OWNER_RID  , 0 ,
                                       1 , SECURITY_LOCAL_SYSTEM_RID   , 0 ,
                                       2 , SECURITY_BUILTIN_DOMAIN_RID , DOMAIN_ALIAS_RID_ADMINS
                                      };
    
    //
    // CONTAINER_INHERIT_ACE -> This folder and subfolders
    // OBJECT_INHERIT_ACE -> Files
    //
    BYTE InheritFlags[MAX_ACE] = {
                                   CONTAINER_INHERIT_ACE,
                                   CONTAINER_INHERIT_ACE,
                                   CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                                   CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                                   CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
                                 };
    
    
    PSECURITY_DESCRIPTOR ServerSD = NULL;

    //
    // Printer SD
    //


    for(AceCount = 0;
        ( (AceCount < MAX_ACE) &&
          AllocateAndInitializeSid(&SidAuthority[AceCount],
                                   (BYTE)SubAuthorities[AceCount*3],
                                   SubAuthorities[AceCount*3+1],
                                   SubAuthorities[AceCount*3+2],
                                   0, 0, 0, 0, 0, 0,
                                   &Sids[AceCount]));
        AceCount++)
    {
        AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
        AceSid[AceCount]           = Sids[AceCount];
    }

    if(AceCount == MAX_ACE)
    {
        if(!BuildPrintObjectProtection( AceType,
                                        AceCount,
                                        AceSid,
                                        AceMask,
                                        InheritFlags,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &ServerSD ) )
        {
            DBGMSG( DBG_WARNING,( "Couldn't buidl Print Object protection" ) );        
            ServerSD = NULL;
        }
    }
    else
    {
        DBGMSG( DBG_WARNING,( "Couldn't Allocate and initialize SIDs" ) );        
    }

    for(AceCount=0;AceCount<MAX_ACE;AceCount++)
    {
        if(Sids[AceCount])
            FreeSid( Sids[AceCount] );
    }
    return ServerSD;
}



/* CreateDriversShareSecurityDescriptor
 *
 * Creates a security descriptor for the drivers$ share.
 * This reflects the security descriptor applied to the print server,
 * in that Everyone is given GENERIC_READ | GENERIC_EXECUTE,
 * and everyone with SERVER_ACCESS_ADMINISTER (Administrators,
 * Power Users etc.) is given GENERIC_ALL access to the share,
 *
 * If in future releases we support changes to the print server
 * security descriptor (e.g. allowing the ability to deny
 * SERVER_ACCESS_ENUMERATE), this routine will have to become more
 * sophisticated, as the access to the share will probably need
 * to be modified accordingly.
 *
 * Arguments: None
 *
 * Return: The security descriptor returned by BuildPrintObjectProtection.
 *
 */
#undef  MAX_ACE
#define MAX_ACE 20
#define DBGCHK( Condition, ErrorInfo ) \
    if( Condition ) DBGMSG( DBG_WARNING, ErrorInfo )

PSECURITY_DESCRIPTOR
CreateDriversShareSecurityDescriptor(
    VOID
)
{
    DWORD ObjectType = SPOOLER_OBJECT_SERVER;
    NT_PRODUCT_TYPE NtProductType;
    PSID AceSid[MAX_ACE];          // Don't expect more than MAX_ACE ACEs in any of these.
    ACCESS_MASK AceMask[MAX_ACE];  // Access masks corresponding to Sids
    BYTE InheritFlags[MAX_ACE];  //
    UCHAR AceType[MAX_ACE];
    DWORD AceCount;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    PSID WorldSid = NULL;
    PSID AdminsAliasSid = NULL;
    PSID PrintOpsAliasSid = NULL;
    PSID SystemOpsAliasSid = NULL;
    PSID PowerUsersAliasSid = NULL;
    PSID CreatorOwnerSid = NULL;
    PSECURITY_DESCRIPTOR pDriversShareSD = NULL;
    BOOL OK;


    //
    // Printer SD
    //

    AceCount = 0;

    /* Creator-Owner SID: */

    OK = AllocateAndInitializeSid( &CreatorSidAuthority, 1,
                                   SECURITY_CREATOR_OWNER_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   &CreatorOwnerSid );

    DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );
    if ( !OK ) {
        goto CleanUp;
    }

    /* World SID */

    OK = AllocateAndInitializeSid( &WorldSidAuthority, 1,
                                   SECURITY_WORLD_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   &WorldSid );

    DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );
    if ( !OK ) {
        goto CleanUp;
    }


    AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[AceCount]           = WorldSid;
    AceMask[AceCount]          = GENERIC_READ | GENERIC_EXECUTE;
    InheritFlags[AceCount]     = 0;
    AceCount++;

    /* Admins alias SID */

    OK = AllocateAndInitializeSid( &NtAuthority, 2,
                                   SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_ADMINS,
                                   0, 0, 0, 0, 0, 0,
                                   &AdminsAliasSid );

    DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );
    if ( !OK ) {
        goto CleanUp;
    }


    AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[AceCount]           = AdminsAliasSid;
    AceMask[AceCount]          = GENERIC_ALL;
    InheritFlags[AceCount]     = 0;
    AceCount++;


    OK = RtlGetNtProductType( &NtProductType );
    DBGCHK( !OK, ( "Couldn't get product type" ) );

    if (NtProductType == NtProductLanManNt) {

        /* Print Ops alias SID */

        OK = AllocateAndInitializeSid( &NtAuthority, 2,
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_PRINT_OPS,
                                       0, 0, 0, 0, 0, 0,
                                       &PrintOpsAliasSid );

        DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );
        if ( !OK ) {
            goto CleanUp;
        }

        AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
        AceSid[AceCount]           = PrintOpsAliasSid;
        AceMask[AceCount]          = GENERIC_ALL;
        InheritFlags[AceCount]     = 0;
        AceCount++;

        /* System Ops alias SID */

        OK = AllocateAndInitializeSid( &NtAuthority, 2,
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_SYSTEM_OPS,
                                       0, 0, 0, 0, 0, 0,
                                       &SystemOpsAliasSid );
        DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );
        if ( !OK ) {
            goto CleanUp;
        }

        AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
        AceSid[AceCount]           = SystemOpsAliasSid;
        AceMask[AceCount]          = GENERIC_ALL;
        InheritFlags[AceCount]     = 0;
        AceCount++;

    } else {

        //
        // LanManNT product
        //

        OK = AllocateAndInitializeSid( &NtAuthority, 2,
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_POWER_USERS,
                                       0, 0, 0, 0, 0, 0,
                                       &PowerUsersAliasSid );

        DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );
        if ( !OK ) {
            goto CleanUp;
        }

        AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
        AceSid[AceCount]           = PowerUsersAliasSid;
        AceMask[AceCount]          = GENERIC_ALL;
        InheritFlags[AceCount]     = 0;
        AceCount++;

    }


    DBGCHK( ( AceCount > MAX_ACE ), ( "ACE count exceeded" ) );


    OK = BuildPrintObjectProtection( AceType,
                                     AceCount,
                                     AceSid,
                                     AceMask,
                                     InheritFlags,
                                     AdminsAliasSid,
                                     AdminsAliasSid,
                                     &GenericMapping[ObjectType],
                                     &pDriversShareSD );

CleanUp:

    if (WorldSid) { 
        FreeSid( WorldSid );
    }
    if (AdminsAliasSid) {
        FreeSid( AdminsAliasSid );
    }
    if (CreatorOwnerSid) {
        FreeSid( CreatorOwnerSid );
    }    
    if (PrintOpsAliasSid) {
        FreeSid( PrintOpsAliasSid );
    }
    if (SystemOpsAliasSid) {
        FreeSid( SystemOpsAliasSid );
    }
    if (PowerUsersAliasSid) {
        FreeSid( PowerUsersAliasSid );
    }

    return pDriversShareSD;
}



#if DBG

VOID
DumpAcl(
    IN PACL Acl
    )
/*++

Routine Description:

    This routine dumps via (NetpDbgPrint) an Acl for debug purposes.  It is
    specialized to dump standard aces.

Arguments:

    Acl - Supplies the Acl to dump

Return Value:

    None

--*/
{
    DWORD i;
    PSTANDARD_ACE Ace;

    if( MODULE_DEBUG & DBG_SECURITY ) {

        DBGMSG( DBG_SECURITY, ( " DumpAcl @%08lx\n", Acl ));

        //
        //  Check if the Acl is null
        //

        if (Acl == NULL) {
            return;
        }

        //
        //  Dump the Acl header
        //

        DBGMSG( DBG_SECURITY,
                ( " Revision: %02x, Size: %04x, AceCount: %04x\n",
                  Acl->AclRevision, Acl->AclSize, Acl->AceCount ));

        //
        //  Now for each Ace we want do dump it
        //

        for (i = 0, Ace = FirstAce(Acl);
             i < Acl->AceCount;
             i++, Ace = NextAce(Ace) ) {

            //
            //  print out the ace header
            //

            DBGMSG( DBG_SECURITY, ( " AceHeader: %08lx\n", *(PDWORD)Ace ));

            //
            //  special case on the standard ace types
            //

            if ((Ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ||
                (Ace->Header.AceType == ACCESS_DENIED_ACE_TYPE) ||
                (Ace->Header.AceType == SYSTEM_AUDIT_ACE_TYPE) ||
                (Ace->Header.AceType == SYSTEM_ALARM_ACE_TYPE)) {

                //
                //  The following array is indexed by ace types and must
                //  follow the allowed, denied, audit, alarm seqeuence
                //

                static LPSTR AceTypes[] = { "Access Allowed",
                                            "Access Denied ",
                                            "System Audit  ",
                                            "System Alarm  "
                                           };

                DBGMSG( DBG_SECURITY,
                        ( " %s Access Mask: %08lx\n",
                          AceTypes[Ace->Header.AceType], Ace->Mask ));

            } else {

                DBGMSG( DBG_SECURITY, (" Unknown Ace Type\n" ));

            }

            DBGMSG( DBG_SECURITY,
                    ( " AceSize = %d\n AceFlags = ", Ace->Header.AceSize ));

            if (Ace->Header.AceFlags & OBJECT_INHERIT_ACE) {
                DBGMSG( DBG_SECURITY, ( " OBJECT_INHERIT_ACE\n" ));
                DBGMSG( DBG_SECURITY, ( "            " ));
            }
            if (Ace->Header.AceFlags & CONTAINER_INHERIT_ACE) {
                DBGMSG( DBG_SECURITY, ( " CONTAINER_INHERIT_ACE\n" ));
                DBGMSG( DBG_SECURITY, ( "            " ));
            }

            if (Ace->Header.AceFlags & NO_PROPAGATE_INHERIT_ACE) {
                DBGMSG( DBG_SECURITY, ( " NO_PROPAGATE_INHERIT_ACE\n" ));
                DBGMSG( DBG_SECURITY, ( "            " ));
            }

            if (Ace->Header.AceFlags & INHERIT_ONLY_ACE) {
                DBGMSG( DBG_SECURITY, ( " INHERIT_ONLY_ACE\n" ));
                DBGMSG( DBG_SECURITY, ( "            " ));
            }

            if (Ace->Header.AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG) {
                DBGMSG( DBG_SECURITY, ( " SUCCESSFUL_ACCESS_ACE_FLAG\n" ));
                DBGMSG( DBG_SECURITY, ( "            " ));
            }

            if (Ace->Header.AceFlags & FAILED_ACCESS_ACE_FLAG) {
                DBGMSG( DBG_SECURITY, ( " FAILED_ACCESS_ACE_FLAG\n" ));
                DBGMSG( DBG_SECURITY, ( "            " ));
            }

            DBGMSG( DBG_SECURITY, ( "\n" ));

        }
    }

}

#endif // if DBG

/*++

Routine Name

    BuildJobOwnerSecurityDescriptor

Routine Description:

    This routine builds a SD that will be passed as CreatorDescriptor argument to 
    CreatePrivateObjectSecurityEx. The SD on any new job will be created using
    the SD returned by this function and will inherit from the SD from the print
    queue. 
    
    BuildJobOwnerSecurityDescriptor --> SD      Print queue SD
                                         \     /
                                          \   / Inheritance
                                           \ /
                                          Job SD
                                         
    The SD created in this function will have as owner the user from the 
    hToken argument. (The user impersonated by the thread from where we have the
    hToken). The ACL grants full access on the job to the local system. 
    
    The reason why we need this special SD is the following. If you remove the 
    creatorowner from the print queue SD and no user has manage docs permissions
    CreatePrivateObjectSecurity won't find any inheritable ACEs in the parent.
    Thus it grants full permissions to the owner and to the local system. This 
    leads to a random behavior where according to the UI the user should not be
    able to manage his docs, but the SD on the job will grant manage docs rights.
    
    We don't want that. We want the local system to have full privileges on the job
    and the user who submitted the job should be granted permissions only if:
    - the user has manage doc rights
    - creator owner is present in the print queue SD
    
Arguments:

    hToken - impersonation token of the user who creates a new job
    ppSD   - pointer to recieve SD
    
Return Value:

    Win32 error code
    
--*/
BOOL
BuildJobOwnerSecurityDescriptor(
    IN  HANDLE                hToken,
    OUT PSECURITY_DESCRIPTOR *ppSD
    )
{
    DWORD Error = ERROR_INVALID_PARAMETER;

    if (hToken && ppSD) 
    {
        PVOID  pUserInfo  = NULL;
        DWORD  cbUserInfo = 0;
        
        //
        // Get the owner from the thread token
        //
        Error = GetTokenInformation(hToken,
                                    TokenUser,
                                    NULL,
                                    0,
                                    &cbUserInfo) ? ERROR_SUCCESS : GetLastError();
        
        //
        // Allocate buffer and try getting the owner again
        //
        if (Error == ERROR_INSUFFICIENT_BUFFER) 
        {
            if (pUserInfo = AllocSplMem(cbUserInfo)) 
            {
                Error = GetTokenInformation(hToken,
                                            TokenUser,
                                            pUserInfo,
                                            cbUserInfo,
                                            &cbUserInfo) ? ERROR_SUCCESS : GetLastError();
            }
            else
            {
                Error = GetLastError();
            }
        }
        
        //
        // Build the SD. We grant read control to the owner of the job
        //
        if (Error == ERROR_SUCCESS)
        {
            DWORD       ObjectType = SPOOLER_OBJECT_DOCUMENT;
            PSID        AceSid[2];          
            ACCESS_MASK AceMask[2];
            BYTE        InheritFlags[2];
            UCHAR       AceType[2];
            DWORD       AceCount = 0;
            PSID        pUserSid;
                        
            pUserSid               = ((((TOKEN_USER *)pUserInfo)->User)).Sid;
            
            AceType[AceCount]      = ACCESS_ALLOWED_ACE_TYPE;
            AceSid[AceCount]       = ((((TOKEN_USER *)pUserInfo)->User)).Sid;
            AceMask[AceCount]      = JOB_READ;
            InheritFlags[AceCount] = 0;
            AceCount++;

            AceType[AceCount]      = ACCESS_ALLOWED_ACE_TYPE;
            AceSid[AceCount]       = pLocalSystemSid;
            AceMask[AceCount]      = JOB_ALL_ACCESS;
            InheritFlags[AceCount] = 0;
            AceCount++;
        
            Error = BuildPrintObjectProtection(AceType,
                                               AceCount,
                                               AceSid,
                                               AceMask,
                                               InheritFlags,
                                               pUserSid,
                                               NULL,
                                               &GenericMapping[ObjectType],
                                               ppSD) ? ERROR_SUCCESS : GetLastError();
   
        }
    
        FreeSplMem(pUserInfo);

    }

    SetLastError(Error);

    return Error == ERROR_SUCCESS;
}

/*++

Routine Name

    DestroyJobOwnerSecurityDescriptor

Routine Description:

    This routine frees a SD allocated by CreatejobOwnerSecurityDescriptor
        
Arguments:

    pSD   - pointer to SD
    
Return Value:

    None
    
--*/
VOID
DestroyJobOwnerSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSD
    )
{
    if (pSD) 
    {
        LocalFree(pSD);
    }
}

/*++

Routine Name

    InitializeSecurityStructures

Routine Description:

    This routine initializes security structures.
    
Arguments:

    None
        
Return Value:

    TRUE  - function succeeded
    FALSE - function failed, GetLastError() returns the reason
    
--*/
BOOL
InitializeSecurityStructures(
    VOID
    )
{
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    return !!CreateServerSecurityDescriptor() &&
           LookupPrivilegeValue(NULL, 
                                SE_LOAD_DRIVER_NAME, 
                                &gLoadDriverPrivilegeLuid) &&
           AllocateAndInitializeSid(&NtAuthority,
                                    1,
                                    SECURITY_LOCAL_SYSTEM_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pLocalSystemSid) &&          
           AllocateAndInitializeSid(&NtAuthority,
                                    1,
                                    SECURITY_NETWORK_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pNetworkLogonSid) &&          
           AllocateAndInitializeSid(&NtAuthority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_GUESTS, 
                                    0, 0, 0, 0, 0, 0,
                                    &pGuestsSid);
}

/*++

Routine Name

    PrincipalIsRemoteGuest

Routine Description:

    This routine checks whether remote guest is present in a token.
    Remote guest = network + guest
    
Arguments:

    hToken - handle to token, NULL is ok (see CheckTokenMemberShip)
    pbRemoteGuest - pointer to receive BOOL. true means remote guest
        
Return Value:

    ERROR_SUCCESS - pbRemoteGuest is reliable
    other win32 error code, do not use pbRemoteGuest
    
--*/
DWORD
PrincipalIsRemoteGuest(
    IN  HANDLE  hToken,
    OUT BOOL   *pbRemoteGuest
    )
{
    DWORD Error = ERROR_INVALID_PARAMETER;

    if (pbRemoteGuest)
    {
        BOOL bNetwork = FALSE;
        BOOL bGuests  = FALSE;
        
        if (CheckTokenMembership(hToken, pNetworkLogonSid, &bNetwork) &&
            CheckTokenMembership(hToken, pGuestsSid,       &bGuests))
        {
            *pbRemoteGuest = bNetwork && bGuests;

            Error = ERROR_SUCCESS;
        } 
        else
        {
            *pbRemoteGuest = FALSE;

            Error = GetLastError();
        }
    }
    
    return Error;
}

/*++

Routine Name

    CheckPrivilegePresent

Routine Description:

    This routine checks if a certain privilege is present in a token
    
Arguments:

    hToken      - thread or process token
    pLuid       - pointer to luid for the privilege to be searched for
    pbPresent   - will be set to true is the privilege is present in the token
    pAttributes - will be set to the attributes of the privilege. It is a mask
                  indicating if the privilege is disabled, enabled, enabled by 
                  default.                                                                  
    
Return Value:

    ERROR_SUCCESS - the function executed successfully and the caller can use
                    pbPresent and pAttributes
    other Win32 error
    
--*/
DWORD
CheckPrivilegePresent(
    IN HANDLE   hToken,
    IN PLUID    pLuid,
    IN LPBOOL   pbPresent,
    IN LPDWORD  pAttributes OPTIONAL
    )
{
    DWORD  Error      = ERROR_INVALID_PARAMETER;
    PVOID  pPrivInfo  = NULL;
    DWORD  cbPrivInfo = kGuessTokenPrivileges;
        
    if (pLuid && pbPresent) 
    {
        *pbPresent = FALSE;

        pPrivInfo = AllocSplMem(cbPrivInfo);

        Error = pPrivInfo ? ERROR_SUCCESS : GetLastError();

        if (Error == ERROR_SUCCESS)
        {
            Error = GetTokenInformation(hToken,
                                        TokenPrivileges,
                                        pPrivInfo,
                                        cbPrivInfo,
                                        &cbPrivInfo) ? ERROR_SUCCESS : GetLastError();
        }
        
        //
        // Reallocate buffer and try getting the privileges
        //
        if (Error == ERROR_INSUFFICIENT_BUFFER) 
        {
            FreeSplMem(pPrivInfo);

            pPrivInfo = AllocSplMem(cbPrivInfo);

            Error = pPrivInfo ? ERROR_SUCCESS : GetLastError();
                                                            
            if (Error == ERROR_SUCCESS) 
            {
                Error = GetTokenInformation(hToken,
                                            TokenPrivileges,
                                            pPrivInfo,
                                            cbPrivInfo,
                                            &cbPrivInfo) ? ERROR_SUCCESS : GetLastError();
            }
        }

        if (Error == ERROR_SUCCESS) 
        {
            TOKEN_PRIVILEGES *pTokenPrivileges = (TOKEN_PRIVILEGES *)pPrivInfo;
            DWORD             uCount;
            
            //
            // Search the privilege in the list of privileges present in the token
            //
            for (uCount = 0; uCount < pTokenPrivileges->PrivilegeCount; uCount++) 
            {
                if (pTokenPrivileges->Privileges[uCount].Luid.HighPart == pLuid->HighPart && 
                    pTokenPrivileges->Privileges[uCount].Luid.LowPart  == pLuid->LowPart)
                {
                    //
                    // We found the privilege
                    //
                    *pbPresent = TRUE;

                    if (pAttributes) 
                    {
                        *pAttributes = pTokenPrivileges->Privileges[uCount].Attributes;
                    }

                    break;
                }
            }
        }

        FreeSplMem(pPrivInfo);
    }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\printer.c ===
/*++

Copyright (c) 1990 - 1996  Microsoft Corporation

Module Name:

    printer.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    management for the Local Print Providor

    SplAddPrinter
    LocalAddPrinter
    SplDeletePrinter
    SplResetPrinter

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Matthew A Felton (Mattfe) 27-June-1994
    Allow Multiple pIniSpoolers

    MattFe Jan5 Cleanup SplAddPrinter & UpdatePrinterIni
    Steve Wilson (NT) - Dec 1996 added DeleteThisKey

--*/

#include <precomp.h>

#pragma hdrstop

#include "clusspl.h"

#define     PRINTER_NO_CONTROL          0x00

extern WCHAR *szNull;

WCHAR *szKMPrintersAreBlocked   = L"KMPrintersAreBlocked";
WCHAR *szIniDevices = L"devices";
WCHAR *szIniPrinterPorts = L"PrinterPorts";
DWORD NetPrinterDecayPeriod = 1000*60*60;       // 1 hour
DWORD FirstAddNetPrinterTickCount = 0;


extern GENERIC_MAPPING GenericMapping[SPOOLER_OBJECT_COUNT];


VOID
FixDevModeDeviceName(
    LPWSTR pPrinterName,
    PDEVMODE pDevMode,
    DWORD cbDevMode
    );

VOID
CheckAndUpdatePrinterRegAll(
    PINISPOOLER pIniSpooler,
    LPWSTR pszPrinterName,
    LPWSTR pszPort,
    BOOL   bDelete
    )
{
    //  Print Providers if they are simulating network connections
    //  will have the Win.INI setting taken care of by the router
    //  so don't do they update if they request it.

    if ( pIniSpooler->SpoolerFlags & SPL_UPDATE_WININI_DEVICES ) {

        UpdatePrinterRegAll( pszPrinterName, pszPort, bDelete );
    }
}

DWORD
ValidatePrinterAttributes(
    DWORD   SourceAttributes,
    DWORD   OriginalAttributes,
    LPWSTR  pDatatype,
    LPBOOL  pbValid,
    BOOL    bSettableOnly
    )

/*++
Function Description: Validates the printer attributes to weed out incompatible settings

Parameters: SourceAttributes    - new attributes
            OriginalAttributes  - old attributes
            pDatatype           - default datatype on the printer
            pbValid             - flag to indicate invalid combination of settings
            bSettableOnly       - flag for SplAddPrinter

Return Values: pbValid is set to TRUE if successful and new attributes are returned
               pbValid is set to FALSE otherwise and 0 is returned
--*/

{
    //
    // Let only settable attributes be set, as well as the other bits that are already set in the printer.
    //
    DWORD TargetAttributes = (SourceAttributes & PRINTER_ATTRIBUTE_SETTABLE) |
                             (OriginalAttributes & ~PRINTER_ATTRIBUTE_SETTABLE);

    if (pbValid) *pbValid = TRUE;

    //
    // If the printer is set to spool RAW only, the Default datatype should be a
    // ValidRawDatatype (RAW, RAW FF, ....)
    //
    if ((TargetAttributes & PRINTER_ATTRIBUTE_RAW_ONLY) &&
        (pDatatype != NULL) &&
        !ValidRawDatatype(pDatatype)) {

        if (pbValid) *pbValid = FALSE;
        SetLastError(ERROR_INVALID_DATATYPE);
        return 0;
    }

    // This is for use by SplAddPrinter() to let it set these attributes for a new printer if needed.
    if ( !bSettableOnly ) {

        if( SourceAttributes & PRINTER_ATTRIBUTE_LOCAL )
            TargetAttributes |= PRINTER_ATTRIBUTE_LOCAL;

        /* Don't accept PRINTER_ATTRIBUTE_NETWORK
         * unless the PRINTER_ATTRIBUTE_LOCAL bit is set also.
         * This is a special case of a local printer masquerading
         * as a network printer.
         * Otherwise PRINTER_ATTRIBUTE_NETWORK should be set only
         * by win32spl.
         */
        if( ( SourceAttributes & PRINTER_ATTRIBUTE_NETWORK )
          &&( SourceAttributes & PRINTER_ATTRIBUTE_LOCAL ) )
            TargetAttributes |= PRINTER_ATTRIBUTE_NETWORK;

        //
        // If it is a Fax Printer, set that bit.
        //
        if ( SourceAttributes & PRINTER_ATTRIBUTE_FAX )
            TargetAttributes |= PRINTER_ATTRIBUTE_FAX;
    }

    /* If both queued and direct, knock out direct:
     */
    if((TargetAttributes &
        (PRINTER_ATTRIBUTE_QUEUED | PRINTER_ATTRIBUTE_DIRECT)) ==
        (PRINTER_ATTRIBUTE_QUEUED | PRINTER_ATTRIBUTE_DIRECT)) {
        TargetAttributes &= ~PRINTER_ATTRIBUTE_DIRECT;
    }

    //
    // For direct printing the default data type must be RAW
    //
    if ((TargetAttributes & PRINTER_ATTRIBUTE_DIRECT) &&
        (pDatatype != NULL) &&
        !ValidRawDatatype(pDatatype)) {

        if (pbValid) *pbValid = FALSE;
        SetLastError(ERROR_INVALID_DATATYPE);
        return 0;
    }

    /* If both direct and keep-printed-jobs, knock out keep-printed-jobs
     */
    if((TargetAttributes &
        (PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS | PRINTER_ATTRIBUTE_DIRECT)) ==
        (PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS | PRINTER_ATTRIBUTE_DIRECT)) {
        TargetAttributes &= ~PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS;
    }

    return TargetAttributes;
}



BOOL
CreatePrinterEntry(
   LPPRINTER_INFO_2 pPrinter,
   PINIPRINTER      pIniPrinter,
   PBOOL            pAccessSystemSecurity
)
{
    BOOL bError = FALSE;

    if( !( pIniPrinter->pSecurityDescriptor =
           CreatePrinterSecurityDescriptor( pPrinter->pSecurityDescriptor ) )) {

        return FALSE;
    }

    *pAccessSystemSecurity = FALSE;

    pIniPrinter->signature = IP_SIGNATURE;

    pIniPrinter->pName = AllocSplStr(pPrinter->pPrinterName);

    if (!pIniPrinter->pName) {
        DBGMSG(DBG_WARNING, ("CreatePrinterEntry: Could not allocate PrinterName string\n" ));
        bError = TRUE;
    }

    if (pPrinter->pShareName) {

        pIniPrinter->pShareName = AllocSplStr(pPrinter->pShareName);
        if (!pIniPrinter->pShareName) {
            DBGMSG(DBG_WARNING, ("CreatePrinterEntry: Could not allocate ShareName string\n" ));
            bError = TRUE;


        }
    } else {

        pIniPrinter->pShareName = NULL;

    }

    if (pPrinter->pDatatype) {

        pIniPrinter->pDatatype = AllocSplStr(pPrinter->pDatatype);
        if (!pIniPrinter->pDatatype) {
            DBGMSG(DBG_WARNING, ("CreatePrinterEntry: Could not allocate Datatype string\n" ));
            bError = TRUE;
        }

    } else {

#if DBG
        //
        // Error: the datatype should never be NULL
        // point.
        //
        SplLogEvent( pIniPrinter->pIniSpooler,
                     LOG_ERROR,
                     MSG_SHARE_FAILED,
                     TRUE,
                     L"CreatePrinterEntry",
                     pIniPrinter->pName ?
                            pIniPrinter->pName :
                            L"(Nonep)",
                     pIniPrinter->pShareName ?
                            pIniPrinter->pShareName :
                            L"(Nones)",
                     L"NULL datatype",
                     NULL );
#endif

        pIniPrinter->pDatatype = NULL;
    }


    //
    // If we have failed somewhere, clean up and exit.
    //
    if (bError) {
        FreeSplStr(pIniPrinter->pName);
        FreeSplStr(pIniPrinter->pShareName);
        FreeSplStr(pIniPrinter->pDatatype);
        return FALSE;
    }

    pIniPrinter->Priority = pPrinter->Priority ? pPrinter->Priority
                                               : DEF_PRIORITY;

    pIniPrinter->Attributes = ValidatePrinterAttributes(pPrinter->Attributes,
                                                        pIniPrinter->Attributes,
                                                        NULL,
                                                        NULL,
                                                        FALSE);

    pIniPrinter->StartTime = pPrinter->StartTime;
    pIniPrinter->UntilTime = pPrinter->UntilTime;

    pIniPrinter->pParameters = AllocSplStr(pPrinter->pParameters);

    pIniPrinter->pSepFile = AllocSplStr(pPrinter->pSepFile);

    pIniPrinter->pComment = AllocSplStr(pPrinter->pComment);

    pIniPrinter->pLocation = AllocSplStr(pPrinter->pLocation);

    if (pPrinter->pDevMode) {

        pIniPrinter->cbDevMode = pPrinter->pDevMode->dmSize +
                                 pPrinter->pDevMode->dmDriverExtra;
        SPLASSERT(pIniPrinter->cbDevMode);

        if (pIniPrinter->pDevMode = AllocSplMem(pIniPrinter->cbDevMode)) {

            memcpy(pIniPrinter->pDevMode,
                   pPrinter->pDevMode,
                   pIniPrinter->cbDevMode);

            FixDevModeDeviceName( pIniPrinter->pName,
                                  pIniPrinter->pDevMode,
                                  pIniPrinter->cbDevMode );
        }

    } else {

        pIniPrinter->cbDevMode = 0;
        pIniPrinter->pDevMode = NULL;
    }

    pIniPrinter->DefaultPriority = pPrinter->DefaultPriority;

    pIniPrinter->pIniFirstJob = pIniPrinter->pIniLastJob = NULL;

    pIniPrinter->cJobs = pIniPrinter->AveragePPM = 0;

    pIniPrinter->GenerateOnClose = 0;

    // At present no API can set this up, the user has to use the
    // registry.   LATER we should enhance the API to take this.

    pIniPrinter->pSpoolDir = NULL;

    // Initialize Status Information

    pIniPrinter->cTotalJobs = 0;
    pIniPrinter->cTotalBytes.LowPart = 0;
    pIniPrinter->cTotalBytes.HighPart = 0;
    GetSystemTime(&pIniPrinter->stUpTime);
    pIniPrinter->MaxcRef = 0;
    pIniPrinter->cTotalPagesPrinted = 0;
    pIniPrinter->cSpooling = 0;
    pIniPrinter->cMaxSpooling = 0;
    pIniPrinter->cErrorOutOfPaper = 0;
    pIniPrinter->cErrorNotReady = 0;
    pIniPrinter->cJobError = 0;
    pIniPrinter->DsKeyUpdate = 0;
    pIniPrinter->DsKeyUpdateForeground = 0;
    pIniPrinter->pszObjectGUID = NULL;
    pIniPrinter->pszCN = NULL;
    pIniPrinter->pszDN = NULL;


    //
    //  Start from a Semi Random Number
    //  That way if someone deletes and creates a printer of
    //  the same name it is unlikely to have the same unique ID

    pIniPrinter->cChangeID = GetTickCount();

    if (pIniPrinter->cChangeID == 0 )
        pIniPrinter->cChangeID++;

    //
    // Initialize the masq printer cache, we just start with optimistic values
    //
    pIniPrinter->MasqCache.cJobs = 0;
    pIniPrinter->MasqCache.dwError = ERROR_SUCCESS;
    pIniPrinter->MasqCache.Status = 0;
    pIniPrinter->MasqCache.bThreadRunning = FALSE;

    return TRUE;
}

BOOL
UpdateWinIni(
    PINIPRINTER pIniPrinter
    )
{
    PINIPORT    pIniPort;
    DWORD       i;
    BOOL        bGenerateNetId = FALSE;
    LPWSTR      pszPort;

    SplInSem();

    if( !( pIniPrinter->pIniSpooler->SpoolerFlags & SPL_UPDATE_WININI_DEVICES )){
        return TRUE;
    }

    //
    // Update win.ini for Win16 compatibility
    //
    if ( pIniPrinter->Status & PRINTER_PENDING_DELETION ) {

        CheckAndUpdatePrinterRegAll( pIniPrinter->pIniSpooler,
                                     pIniPrinter->pName,
                                     NULL,
                                     UPDATE_REG_DELETE );

    } else {

        //
        // Initialize in case there are no ports that match this printer.
        //
        pszPort = szNullPort;

        for( pIniPort = pIniPrinter->pIniSpooler->pIniPort;
             pIniPort;
             pIniPort = pIniPort->pNext ){

            for ( i = 0; i < pIniPort->cPrinters; i++ ) {

                if ( pIniPort->ppIniPrinter[i] == pIniPrinter ) {

                    //
                    // UpdatePrinterRegAll will automatically
                    // convert "\\server\share" or ports with
                    // spaces to Nexx:
                    //
                    pszPort = pIniPort->pName;
                    break;
                }
            }
        }

        CheckAndUpdatePrinterRegAll( pIniPrinter->pIniSpooler,
                                     pIniPrinter->pName,
                                     pszPort,
                                     UPDATE_REG_CHANGE );
    }

    BroadcastChange( pIniPrinter->pIniSpooler,
                     WM_WININICHANGE,
                     PR_JOBSTATUS,
                     (LPARAM)szIniDevices);

    return TRUE;
}



BOOL
DeletePrinterIni(
    PINIPRINTER pIniPrinter
    )
{
    DWORD   Status;
    LPWSTR  pSubkey;
    DWORD   cbNeeded;
    LPWSTR  pKeyName = NULL;
    HANDLE  hToken;
    PINISPOOLER pIniSpooler = pIniPrinter->pIniSpooler;
    HKEY hPrinterKey;

    //
    // Only update if the spooler requests it.
    //
    if ((pIniSpooler->SpoolerFlags & SPL_NO_UPDATE_PRINTERINI) ||
        !pIniPrinter->pName) {
        return TRUE;
    }

    hToken = RevertToPrinterSelf();

    if (!(pKeyName = SubChar(pIniPrinter->pName, L'\\', L','))) {
        Status = GetLastError();
        goto error;
    }

    Status = SplRegOpenKey( pIniSpooler->hckPrinters,
                            pKeyName,
                            KEY_ALL_ACCESS,
                            &hPrinterKey,
                            pIniSpooler );

    if (Status == ERROR_SUCCESS) {

        // Delete hPrinterKey - on success this returns ERROR_SUCCESS
        Status = SplDeleteThisKey( pIniSpooler->hckPrinters,
                                   hPrinterKey,
                                   pKeyName,
                                   TRUE,
                                   pIniSpooler );

        if (Status != ERROR_SUCCESS) {
            DBGMSG(DBG_WARNING, ("DeletePrinterIni: DeleteThisKey returned %ld\n", Status ));
        }
    }

    //
    // If entries are in per h/w profile registries delete them.
    //
    DeletePrinterInAllConfigs(pIniPrinter);

error:

    FreeSplStr(pKeyName);

    ImpersonatePrinterClient(hToken);

    return (Status == ERROR_SUCCESS);
}


//
// DeleteThisKey - returns ERROR_SUCCESS on final successful return
//                 deletes a key from Registry
// SWilson Dec 96
//

DWORD
SplDeleteThisKey(
    HKEY hParentKey,       // handle to parent of key to delete
    HKEY hThisKey,         // handle of key to delete
    LPWSTR pThisKeyName,   // name of this key
    BOOL bDeleteNullKey,   // if TRUE, then if pThisKeyName is NULL it is deleted
    PINISPOOLER pIniSpooler
)
{
    DWORD   dwResult = ERROR_SUCCESS, rc;
    WCHAR   Name[MAX_PATH];
    DWORD   cchName;
    LPWSTR  pName;
    HKEY    hSubKey;

    //
    // If hThisKey is NULL , try to open it
    //
    if( hThisKey == NULL) {

        if((hParentKey != NULL) && ( pThisKeyName && *pThisKeyName ) ){

            dwResult = SplRegOpenKey( hParentKey,
                                      pThisKeyName,
                                      KEY_ALL_ACCESS,
                                      &hThisKey,
                                      pIniSpooler );
        }
    }

    //
    // Exit if SplRegOpenKey failed or hParentKey or pThisKeyName are invalid
    //
    if( hThisKey == NULL ){

        return dwResult;
    }

    // Get This key's children & delete them, then delete this key

    while(dwResult == ERROR_SUCCESS) {

        pName = Name;
        cchName = COUNTOF( Name );
        dwResult = SplRegEnumKey( hThisKey,
                                  0,
                                  pName,
                                  &cchName,
                                  NULL,
                                  pIniSpooler );

        if (dwResult == ERROR_MORE_DATA) {

            SPLASSERT(cchName > MAX_PATH);

            if (!(pName = AllocSplMem(cchName * sizeof( *pName )))) {
                dwResult = GetLastError();
            } else {
                dwResult = SplRegEnumKey( hThisKey,
                                          0,
                                          pName,
                                          &cchName,
                                          NULL,
                                          pIniSpooler );
            }
        }

        if (dwResult == ERROR_SUCCESS) {                      // SubKey found
            dwResult = SplRegCreateKey( hThisKey,             // Open SubKey
                                        pName,
                                        0,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hSubKey,
                                        NULL,
                                        pIniSpooler);

            if (dwResult == ERROR_SUCCESS) {
                // Delete This SubKey
                dwResult = SplDeleteThisKey( hThisKey,
                                             hSubKey,
                                             pName,
                                             bDeleteNullKey,
                                             pIniSpooler );
            }
        }

        if (pName != Name)
            FreeSplStr(pName);
    }

    rc = SplRegCloseKey(hThisKey, pIniSpooler);
    SPLASSERT(rc == ERROR_SUCCESS);

    if (dwResult == ERROR_NO_MORE_ITEMS) {   // This Key has no children so can be deleted
        if ( (*pThisKeyName || bDeleteNullKey) && hParentKey != NULL ) {

            dwResult = SplRegDeleteKey(hParentKey, pThisKeyName, pIniSpooler);
            if (dwResult != ERROR_SUCCESS) {
               DBGMSG(DBG_WARNING, ("DeletePrinter: RegDeleteKey failed: %ld\n", dwResult));
            }
        }
        else
        {
            dwResult = ERROR_SUCCESS;
        }
    }

    return dwResult;
}



BOOL
PrinterCreateKey(
    HKEY    hKey,
    LPWSTR  pSubKey,
    PHKEY   phkResult,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    )
{
    BOOL    bReturnValue;
    DWORD   Status;

    Status = SplRegCreateKey( hKey,
                              pSubKey,
                              0,
                              KEY_READ | KEY_WRITE,
                              NULL,
                              phkResult,
                              NULL,
                              pIniSpooler );

    if ( Status != ERROR_SUCCESS ) {

        DBGMSG( DBG_WARNING, ( "PrinterCreateKey: SplRegCreateKey %ws error %d\n", pSubKey, Status ));

        *pdwLastError = Status;
        bReturnValue = FALSE;

    } else {

        bReturnValue = TRUE;
    }

    return bReturnValue;

}


BOOL
UpdatePrinterIni(
   PINIPRINTER pIniPrinter,
   DWORD    dwChangeID
   )
{

    PINISPOOLER pIniSpooler = pIniPrinter->pIniSpooler;
    DWORD   dwLastError = ERROR_SUCCESS;
    LPWSTR  pKeyName = NULL;
    HANDLE  hToken;
    DWORD   dwTickCount;
    BOOL    bReturnValue;
    DWORD   cbData;
    DWORD   cbNeeded;
    LPWSTR  pszPorts;
    HANDLE  hPrinterKey = NULL;
    HANDLE  hBackUpPrinterKey = NULL;

    SplInSem();

    //
    // Only update if the spooler requests it.
    //
    if( pIniSpooler->SpoolerFlags & SPL_NO_UPDATE_PRINTERINI ){
        return TRUE;
    }

    try {

        hToken = RevertToPrinterSelf();

        if ( hToken == FALSE ) {

            DBGMSG( DBG_TRACE, ("UpdatePrinterIni failed RevertToPrinterSelf %x\n", GetLastError() ));
        }

        pKeyName = SubChar(pIniPrinter->pName, L'\\', L',');
        if (!pKeyName) {
            dwLastError = GetLastError();
            leave;
        }

        if ( !PrinterCreateKey( pIniSpooler->hckPrinters,
                                pKeyName,
                                &hPrinterKey,
                                &dwLastError,
                                pIniSpooler )) {

            leave;
        }

        if (dwChangeID == UPDATE_DS_ONLY) {

            RegSetDWord(hPrinterKey, szDsKeyUpdate, pIniPrinter->DsKeyUpdate, &dwLastError, pIniSpooler);

            RegSetDWord(hPrinterKey, szDsKeyUpdateForeground, pIniPrinter->DsKeyUpdateForeground, &dwLastError, pIniSpooler);

            leave;
        }

        if ( dwChangeID != KEEP_CHANGEID ) {

            //
            // WorkStation Caching requires a Unique ID so that they can quickly
            // tell if their Cache is up to date.
            //

            dwTickCount = GetTickCount();

            // Ensure Uniqueness

            if ( dwTickCount == 0 )
                dwTickCount++;

            if ( pIniPrinter->cChangeID == dwTickCount )
                dwTickCount++;

            pIniPrinter->cChangeID = dwTickCount;
            RegSetDWord( hPrinterKey, szTimeLastChange, pIniPrinter->cChangeID, &dwLastError, pIniSpooler );

        }

        if ( dwChangeID != CHANGEID_ONLY ) {

            RegSetDWord( hPrinterKey, szStatus, pIniPrinter->Status, &dwLastError, pIniSpooler );

            RegSetString( hPrinterKey, szName, pIniPrinter->pName, &dwLastError, pIniSpooler );

            if( hBackUpPrinterKey != NULL ){

                RegSetString( hBackUpPrinterKey, szName, pIniPrinter->pName, &dwLastError, pIniSpooler );
            }

            RegSetString( hPrinterKey, szShare, pIniPrinter->pShareName, &dwLastError, pIniSpooler );

            RegSetString( hPrinterKey, szPrintProcessor, pIniPrinter->pIniPrintProc->pName, &dwLastError, pIniSpooler );

            if ( !( pIniPrinter->Status & PRINTER_PENDING_DELETION )) {

                SPLASSERT( pIniPrinter->pDatatype != NULL );
            }

            RegSetString( hPrinterKey, szDatatype, pIniPrinter->pDatatype, &dwLastError, pIniSpooler );

            RegSetString( hPrinterKey, szParameters, pIniPrinter->pParameters, &dwLastError, pIniSpooler );

            RegSetDWord( hPrinterKey, szAction, pIniPrinter->dwAction, &dwLastError, pIniSpooler );

            RegSetString( hPrinterKey, szObjectGUID, pIniPrinter->pszObjectGUID, &dwLastError, pIniSpooler );

            RegSetDWord( hPrinterKey, szDsKeyUpdate, pIniPrinter->DsKeyUpdate, &dwLastError, pIniSpooler);

            RegSetDWord( hPrinterKey, szDsKeyUpdateForeground, pIniPrinter->DsKeyUpdateForeground, &dwLastError, pIniSpooler);

            RegSetString( hPrinterKey, szDescription, pIniPrinter->pComment, &dwLastError, pIniSpooler );

            RegSetString( hPrinterKey, szDriver, pIniPrinter->pIniDriver->pName, &dwLastError, pIniSpooler );

            if( hBackUpPrinterKey != NULL ){

                RegSetString( hBackUpPrinterKey, szDriver, pIniPrinter->pIniDriver->pName, &dwLastError, pIniSpooler );
            }


            if (pIniPrinter->pDevMode) {

                cbData = pIniPrinter->cbDevMode;

            } else {

                cbData = 0;
            }

            RegSetBinaryData( hPrinterKey, szDevMode, (LPBYTE)pIniPrinter->pDevMode, cbData, &dwLastError, pIniSpooler );

            if( hBackUpPrinterKey != NULL ){

                RegSetBinaryData( hBackUpPrinterKey, szDevMode, (LPBYTE)pIniPrinter->pDevMode, cbData, &dwLastError, pIniSpooler );
            }

            RegSetDWord( hPrinterKey, szPriority, pIniPrinter->Priority, &dwLastError, pIniSpooler );

            RegSetDWord( hPrinterKey, szDefaultPriority, pIniPrinter->DefaultPriority, &dwLastError, pIniSpooler );

            RegSetDWord(hPrinterKey, szStartTime, pIniPrinter->StartTime, &dwLastError, pIniSpooler );

            RegSetDWord( hPrinterKey, szUntilTime, pIniPrinter->UntilTime, &dwLastError, pIniSpooler );

            RegSetString( hPrinterKey, szSepFile, pIniPrinter->pSepFile, &dwLastError, pIniSpooler );

            RegSetString( hPrinterKey, szLocation, pIniPrinter->pLocation, &dwLastError, pIniSpooler );

            RegSetDWord( hPrinterKey, szAttributes, pIniPrinter->Attributes, &dwLastError, pIniSpooler );

            RegSetDWord( hPrinterKey, szTXTimeout, pIniPrinter->txTimeout, &dwLastError, pIniSpooler );

            RegSetDWord( hPrinterKey, szDNSTimeout, pIniPrinter->dnsTimeout, &dwLastError, pIniSpooler );

            if (pIniPrinter->pSecurityDescriptor) {

                cbData = GetSecurityDescriptorLength( pIniPrinter->pSecurityDescriptor );

            } else {

                cbData = 0;
            }

            RegSetBinaryData( hPrinterKey, szSecurity, pIniPrinter->pSecurityDescriptor, cbData, &dwLastError, pIniSpooler );

            RegSetString( hPrinterKey, szSpoolDir, pIniPrinter->pSpoolDir, &dwLastError, pIniSpooler );

            cbNeeded = 0;
            GetPrinterPorts( pIniPrinter, 0, &cbNeeded);

            if (!(pszPorts = AllocSplMem(cbNeeded))) {
                dwLastError = GetLastError();
                leave;
            }

            GetPrinterPorts(pIniPrinter, pszPorts, &cbNeeded);

            RegSetString( hPrinterKey, szPort, pszPorts, &dwLastError, pIniSpooler );

            if( hBackUpPrinterKey != NULL ){

                RegSetString( hBackUpPrinterKey, szPort, pszPorts, &dwLastError, pIniSpooler );
            }


            FreeSplMem(pszPorts);

            //
            //  A Provider might want to Write Extra Data from Registry
            //
            if ( pIniSpooler->pfnWriteRegistryExtra != NULL ) {

                if ( !(*pIniSpooler->pfnWriteRegistryExtra)(pIniPrinter->pName, hPrinterKey, pIniPrinter->pExtraData)) {
                    dwLastError = GetLastError();
                }
            }


            if ( ( pIniPrinter->Status & PRINTER_PENDING_CREATION )     &&
                 ( dwLastError == ERROR_SUCCESS ) ) {

                pIniPrinter->Status &= ~PRINTER_PENDING_CREATION;

                RegSetDWord( hPrinterKey, szStatus, pIniPrinter->Status, &dwLastError, pIniSpooler );
            }


        }

    } finally {

        if ( hPrinterKey )
            SplRegCloseKey( hPrinterKey, pIniSpooler);

        if ( hBackUpPrinterKey )
            SplRegCloseKey( hBackUpPrinterKey, pIniSpooler);

        if ( hToken )
            ImpersonatePrinterClient( hToken );
    }

    FreeSplStr(pKeyName);

    if ( dwLastError != ERROR_SUCCESS ) {

        SetLastError( dwLastError );
        bReturnValue = FALSE;

    } else {

        bReturnValue = TRUE;
    }

    return bReturnValue;
}


VOID
RemoveOldNetPrinters(
    PPRINTER_INFO_1 pPrinterInfo1,
    PINISPOOLER pIniSpooler
    )
{
    PININETPRINT   *ppIniNetPrint = &pIniSpooler->pIniNetPrint;
    PININETPRINT    pIniNetPrint;
    DWORD   TickCount;


    TickCount = GetTickCount();

    //
    //  Browse Information only becomes valid after this print server has been
    //  up for the NetPrinterDecayPeriod.
    //

    if (( bNetInfoReady == FALSE ) &&
       (( TickCount - FirstAddNetPrinterTickCount ) > NetPrinterDecayPeriod )) {

        DBGMSG( DBG_TRACE, ("RemoveOldNetPrinters has a valid browse list\n" ));

        bNetInfoReady = TRUE;
    }


    while (*ppIniNetPrint) {


        //
        //  If either the Tickcount has expired OR we want to delete this specific NetPrinter
        //  ( because its no longer shared ).
        //

        if ( (( TickCount - (*ppIniNetPrint)->TickCount ) > NetPrinterDecayPeriod + TEN_MINUTES ) ||

             ( pPrinterInfo1 != NULL                             &&
               pPrinterInfo1->Flags & PRINTER_ATTRIBUTE_NETWORK  &&
             !(pPrinterInfo1->Flags & PRINTER_ATTRIBUTE_SHARED ) &&
               _wcsicmp( pPrinterInfo1->pName, (*ppIniNetPrint)->pName ) == STRINGS_ARE_EQUAL)) {

            pIniNetPrint = *ppIniNetPrint;

            DBGMSG( DBG_TRACE, ("RemoveOldNetPrinters removing %ws not heard for %d millisconds\n",
                                pIniNetPrint->pName, ( TickCount - (*ppIniNetPrint)->TickCount ) ));

            //
            // Remove this item, which also increments the pointer.
            //
            *ppIniNetPrint = pIniNetPrint->pNext;

            FreeSplStr( pIniNetPrint->pName );
            FreeSplStr( pIniNetPrint->pDescription );
            FreeSplStr( pIniNetPrint->pComment );
            FreeSplMem( pIniNetPrint );

        } else {

            ppIniNetPrint = &(*ppIniNetPrint)->pNext;
        }
    }

}




HANDLE
AddNetPrinter(
    LPBYTE  pPrinterInfo,
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Net Printers are created by remote machines calling AddPrinter( Level = 1, Printer_info_1 )
    ( see server.c ).   They are used for browsing, someone can call EnumPrinters and ask to get
    back our browse list - ie all our net printers.

    The printers in this list are decayed out after 1 hour ( default ).

    See return value comment.

    Note client\winspool.c AddPrinterW doesn't allow PRINTER_INFO_1 ( NET printers ), so this can
    only come from system components.

Arguments:

    pPrinterInfo - Point to a PRINTER_INFO_1 structure to add

Return Value:

    NULL - it doesn't return a printer handle.
    LastError = ERROR_SUCCESS, or error code ( like out of memory ).

    NOTE before NT 3.51 it returned a printer handle of type PRINTER_HANDLE_NET, but since the
    only use of this handle was to close it ( which burnt up cpu / net traffic and RPC binding
    handles, we return a NULL handle now to make it more efficient.   Apps ( Server.c ) if it
    cares could call GetLastError.

--*/

{
    PPRINTER_INFO_1 pPrinterInfo1 = (PPRINTER_INFO_1)pPrinterInfo;
    PININETPRINT    pIniNetPrint = NULL;
    PININETPRINT    *ppScan;

    SplInSem();

    //
    //  Validate PRINTER_INFO_1
    //  At minimum it must have a PrinterName.

    if ( pPrinterInfo1->pName == NULL ) {

        DBGMSG( DBG_WARN, ("AddNetPrinter pPrinterInfo1->pName == NULL failed\n"));
        SetLastError( ERROR_INVALID_NAME );
        return NULL;
    }

    if ( FirstAddNetPrinterTickCount == 0 ) {

        FirstAddNetPrinterTickCount = GetTickCount();
    }

    //
    //  Decay out of the browse list any old printers
    //

    RemoveOldNetPrinters( pPrinterInfo1, pIniSpooler );


    //
    //  Do Not Add and printer which is no longer shared.
    //

    if (   pPrinterInfo1->Flags & PRINTER_ATTRIBUTE_NETWORK  &&
        !( pPrinterInfo1->Flags & PRINTER_ATTRIBUTE_SHARED )) {

        SetLastError(ERROR_PRINTER_ALREADY_EXISTS);
        goto Done;
    }

    //
    //  See if we already have this printer
    //

    pIniNetPrint = pIniSpooler->pIniNetPrint;

    while ( pIniNetPrint &&
            pIniNetPrint->pName &&
            lstrcmpi( pPrinterInfo1->pName, pIniNetPrint->pName )) {

        pIniNetPrint = pIniNetPrint->pNext;
    }


    //
    //  If we didn't find this printer already Create one
    //

    if ( pIniNetPrint == NULL && ( pIniNetPrint = AllocSplMem( sizeof(ININETPRINT) )) ) {

        pIniNetPrint->signature    = IN_SIGNATURE;
        pIniNetPrint->pName        = AllocSplStr( pPrinterInfo1->pName );
        pIniNetPrint->pDescription = AllocSplStr( pPrinterInfo1->pDescription );
        pIniNetPrint->pComment     = AllocSplStr( pPrinterInfo1->pComment );

        // Did Any of the above allocations fail ?

        if ( pIniNetPrint->pName == NULL ||
           ( pPrinterInfo1->pDescription != NULL && pIniNetPrint->pDescription == NULL ) ||
           ( pPrinterInfo1->pComment != NULL && pIniNetPrint->pComment == NULL ) ) {

            // Failed - CleanUp

            FreeSplStr( pIniNetPrint->pComment );
            FreeSplStr( pIniNetPrint->pDescription );
            FreeSplStr( pIniNetPrint->pName );
            FreeSplMem( pIniNetPrint );
            pIniNetPrint = NULL;

        } else {

            DBGMSG( DBG_TRACE, ("AddNetPrinter(%ws) NEW\n", pPrinterInfo1->pName ));

            ppScan = &pIniSpooler->pIniNetPrint;

            // Scan through the current known printers, and insert the new one
            // in alphabetical order

            while( *ppScan && (lstrcmp((*ppScan)->pName, pIniNetPrint->pName) < 0)) {
                ppScan = &(*ppScan)->pNext;
            }

            pIniNetPrint->pNext = *ppScan;
            *ppScan = pIniNetPrint;
        }

    } else if ( pIniNetPrint != NULL ) {

        DBGMSG( DBG_TRACE, ("AddNetPrinter(%ws) elapsed since last notified %d milliseconds\n", pIniNetPrint->pName, ( GetTickCount() - pIniNetPrint->TickCount ) ));
    }


    if ( pIniNetPrint ) {

        // Tickle the TickCount so this printer sticks around in the browse list

        pIniNetPrint->TickCount = GetTickCount();

        // Have to set some error code or RPC thinks ERROR_SUCCESS is good.

        SetLastError( ERROR_PRINTER_ALREADY_EXISTS );

        pIniSpooler->cAddNetPrinters++;         // Status Only
    }

Done:

    SPLASSERT( GetLastError() != ERROR_SUCCESS);

    return NULL;
}

/*++

Routine Name:

    ValidatePortTokenList

Routine Description:

    This routine ensures that the given set of ports in pKeyData are valid
    ports in the spooler and returns the buffer with the pointers to strings
    replaced with pointers ref-counted pIniPorts.

    The way we do this needs to be rethought. The overloaded PKEYDATA is confusing
    and unnecessary, we should simply return a new array of PINIPORTS. (It also
    pollutes the PKEYDATA with an unnecessary bFixPortRef member), Also, this
    code is both invoked for initialization and for Validation, but the logic is
    quite different. For initialization, we want to assume that everything in the
    registry is valid and start up with placeholder ports until the monitor can
    enumerate them (this could be because a USB printer is unplugged). In the other
    cases where this is being used for validation we want to fail. This implies that
    we might want to separate this into two functions.


Arguments:

    pKeyData        -   The array of strings that gets turned into an array of
                        ref-counted ports.
    pIniSpooler     -   The ini-spooler on which this is being added.
    bInitialize     -   If TRUE, this code is being invoked for initialization and
                        not for validation.
    pbNoPorts       -   Optional, this will return TRUE if bInitialize is TRUE and
                        none of the ports in the port list can be found. We will
                        then set the printer- offline and log a message.

Return Value:

    TRUE    -   if the ports were all all successfully created or validated.
    FALSE   -   otherwise.

--*/
BOOL
ValidatePortTokenList(
    IN  OUT PKEYDATA        pKeyData,
    IN      PINISPOOLER     pIniSpooler,
    IN      BOOL            bInitialize,
        OUT BOOL            *pbNoPorts          OPTIONAL
    )
{
    PINIPORT    pIniPort    =   NULL;
    DWORD       i           =   0;
    DWORD       j           =   0;
    DWORD       dwPorts     =   0;
    DWORD       Status      =   ERROR_SUCCESS;

    SplInSem();

    Status = !pKeyData ? ERROR_UNKNOWN_PORT : ERROR_SUCCESS;

    //
    // The logic remains the same for ports with only one token as for when we
    // initialize the ports for the first time.
    //
    if (Status == ERROR_SUCCESS)
    {
        bInitialize = pKeyData->cTokens == 1 ? TRUE : bInitialize;
    }

    //
    //  We do not allow non-masc ports and masq ports to be combined. Moreover
    //  only one non-masc port can be used for a printer -- can't do printer
    //  pooling with masq printers
    //
    for ( i = 0 ; Status == ERROR_SUCCESS && i < pKeyData->cTokens ; i++ )
    {

        pIniPort = FindPort(pKeyData->pTokens[i], pIniSpooler);

        //
        // A port is valid if it is found and if it isn't in itself a
        // placeholder port.
        //
        if (pIniPort && !(pIniPort->Status & PP_PLACEHOLDER))
        {
            dwPorts++;
        }

        //
        // If we are initializing, or if there is only one port and if the
        // spooler allows it, then create a dummy port entry. This also
        // handles the masq port case.
        //
        if (bInitialize)
        {
            if (!pIniPort && pIniSpooler->SpoolerFlags & SPL_OPEN_CREATE_PORTS)
            {
                //
                // Note: there is a potential problem here, CreatePortEntry uses
                // a global initialization flag rather than the parameter that is
                // passed in to us.
                //
                pIniPort = CreatePortEntry(pKeyData->pTokens[i], NULL, pIniSpooler);
            }
        }

        //
        // If we don't have a port or if we are not initializing and there isn't
        // a monitor associated with the port. Then we have an error.
        //
        if (!pIniPort || (!(pIniPort->Status & PP_MONITOR) && !bInitialize))
        {
            Status = ERROR_UNKNOWN_PORT;
        }

        //
        // In case of duplicate portnames in pPortName field fail the call. This
        // can't happen if we went through the CreatePortEntry code path and it
        // succeeded
        //
        for ( j = 0 ; Status == ERROR_SUCCESS && j < i ; ++j )
        {
            if ( pIniPort == (PINIPORT)pKeyData->pTokens[j] )
            {
                Status = ERROR_UNKNOWN_PORT;
            }
        }

        //
        // Write the port in.
        //
        if (Status == ERROR_SUCCESS)
        {
            pKeyData->pTokens[i] = (LPWSTR)pIniPort;
        }
    }

    //
    // If everything is successful, addref all of the pIniPorts and set the flag
    // to indicate that this has happened for the cleanup code.
    //
    if (Status == ERROR_SUCCESS)
    {
        for ( i = 0 ; i < pKeyData->cTokens ; ++i ) {

            pIniPort = (PINIPORT)pKeyData->pTokens[i];
            INCPORTREF(pIniPort);
        }

        pKeyData->bFixPortRef = TRUE;
    }

    if (pbNoPorts)
    {
        *pbNoPorts = dwPorts == 0;
    }

    if (Status != ERROR_SUCCESS)
    {
        SetLastError(Status);
    }

    return Status == ERROR_SUCCESS;
}


DWORD
ValidatePrinterName(
    LPWSTR          pszNewName,
    PINISPOOLER     pIniSpooler,
    PINIPRINTER     pIniPrinter,
    LPWSTR          *ppszLocalName
    )

/*++

Routine Description:

    Validates a printer name. Printer and share names exist in the same
    namespace, so validation is done against printer, share names.

Arguments:

    pszNewName - printer name specified

    pIniSpooler - Spooler that owns printer

    pIniPrinter - could be null if the printer is getting created

    ppszLocalName - on success returns local name
                    (\\servername stripped off if necessary).

Return Value:

    DWORD error code.

History:

    MuhuntS (Muhunthan Sivapragasam) July 95

--*/

{
    PINIPRINTER pIniTempPrinter, pIniNextPrinter;
    LPWSTR pszLocalNameTmp = NULL;
    WCHAR  string[MAX_UNC_PRINTER_NAME];
    LPWSTR p;
    LPWSTR pLastSpace = NULL;

    //
    // The function ValidatePrinterName does too many things in one single routine.
    // It checks for validity of the printer name, it isolates the printer name,
    // it eliminates trailing white spaces from the printe name and validates
    // that the printer name is unique.
    //
    // The function IsValidPrinterName ensures that the printer names contains
    // valid characters and valid sequences of characters.
    //
    if (!IsValidPrinterName(pszNewName, MAX_UNC_PRINTER_NAME - 1))
    {
        return ERROR_INVALID_PRINTER_NAME;
    }

    if (*pszNewName == L'\\' && *(pszNewName + 1) == L'\\') {

        p = wcschr(pszNewName + 2, L'\\');

        if (p) {

            // \\Server\Printer -> \\Server
            wcsncpy(string, pszNewName, (size_t) (p - pszNewName));
            string[p - pszNewName] = L'\0';

            if (MyName(string, pIniSpooler))
                pszLocalNameTmp = p + 1; // \\Server\Printer -> \Printer
        }
    }

    if (!pszLocalNameTmp)
        pszLocalNameTmp = pszNewName;


    //
    // Strip trailing spaces.
    //
    for( p = pszLocalNameTmp; *p; ++p ){

        if( *p == L' ' ){

            //
            // If we haven't seen a continuous space, remember this
            // position.
            //
            if( !pLastSpace ){
                pLastSpace = p;
            }
        } else {

            //
            // Non-whitespace.
            //
            pLastSpace = NULL;
        }
    }

    if( pLastSpace ){
        *pLastSpace = 0;
    }

    //
    // Limit PrinterNames to MAX_PATH length, also if the printer name is now
    // empty as a result of stripping out all of the spaces, then the printer
    // name is now invalid.
    //
    if ( wcslen( pszLocalNameTmp ) > MAX_PRINTER_NAME || !*pszLocalNameTmp ) {
        return ERROR_INVALID_PRINTER_NAME;
    }

    //
    // Now validate that printer names are unique. Printer names and
    // share names  reside in the same namespace (see net\dosprint\dosprtw.c).
    //
    for( pIniTempPrinter = pIniSpooler->pIniPrinter;
         pIniTempPrinter;
         pIniTempPrinter = pIniNextPrinter ){

        //
        // Get the next printer now in case we delete the current
        // one in DeletePrinterCheck.
        //
        pIniNextPrinter = pIniTempPrinter->pNext;

        //
        // Skip ourselves, if we are pssed in.
        //
        if( pIniTempPrinter == pIniPrinter ){
            continue;
        }

        //
        // Disallow common Printer/Share names.
        //
        if( !lstrcmpi( pszLocalNameTmp, pIniTempPrinter->pName ) ||
            ( pIniTempPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED  &&
              !lstrcmpi( pszLocalNameTmp, pIniTempPrinter->pShareName ))){

            if( !DeletePrinterCheck( pIniTempPrinter )){

                return ERROR_PRINTER_ALREADY_EXISTS;
            }
        }
    }

    //
    // Success, now update ppszLocalName from pszLocalNameTmp.
    //
    *ppszLocalName = pszLocalNameTmp;

    return ERROR_SUCCESS;
}

DWORD
ValidatePrinterShareName(
    LPWSTR          pszNewShareName,
    PINISPOOLER     pIniSpooler,
    PINIPRINTER     pIniPrinter
    )

/*++

Routine Description:

    Validates the printer share name. Printer and share names exist in the
    same namespace, so validation is done against printer, share names.

Arguments:

    pszNewShareName - share name specified

    pIniSpooler - Spooler that owns printer

    pIniPrinter - could be null if the printer is getting created

Return Value:

    DWORD error code.

History:

    MuhuntS (Muhunthan Sivapragasam) July 95

--*/

{
    PINIPRINTER pIniTempPrinter, pIniNextPrinter;

    if ( !pszNewShareName || !*pszNewShareName || wcslen(pszNewShareName) > PATHLEN-1) {

        return ERROR_INVALID_SHARENAME;
    }

    //
    // Now validate that share names are unique.  Share names and printer names
    // reside in the same namespace (see net\dosprint\dosprtw.c).
    //
    for( pIniTempPrinter = pIniSpooler->pIniPrinter;
         pIniTempPrinter;
         pIniTempPrinter = pIniNextPrinter ) {

        //
        // Get the next printer now in case we delete the current
        // one in DeletePrinterCheck.
        //
        pIniNextPrinter = pIniTempPrinter->pNext;

        //
        // Skip ourselves, if we are pssed in.
        //
        if( pIniTempPrinter == pIniPrinter ){
            continue;
        }

        //
        // Check our share name now.
        //
        if( !lstrcmpi(pszNewShareName, pIniTempPrinter->pName) ||
            ( pIniTempPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED  &&
              !lstrcmpi(pszNewShareName, pIniTempPrinter->pShareName)) ) {

            if( !DeletePrinterCheck( pIniTempPrinter )){

                return ERROR_INVALID_SHARENAME;
            }
        }
    }

    return ERROR_SUCCESS;
}

DWORD
ValidatePrinterInfo(
    IN  PPRINTER_INFO_2 pPrinter,
    IN  PINISPOOLER pIniSpooler,
    IN  PINIPRINTER pIniPrinter OPTIONAL,
    OUT LPWSTR* ppszLocalName   OPTIONAL
    )
/*++

Routine Description:

    Validates that printer names/share do not collide.  (Both printer and
    share names exist in the same namespace.)

    Note: Later, we should remove all this DeletePrinterCheck.  As people
    decrement ref counts, they should DeletePrinterCheck themselves (or
    have it built into the decrement).

Arguments:

    pPrinter - PrinterInfo2 structure to validate.

    pIniSpooler - Spooler that owns printer

    pIniPrinter - If printer already exists, don't check against itself.

    ppszLocalName - Returned pointer to string buffer in pPrinter;
        indicates local name (\\servername stripped off if necessary).

        Valid only on SUCCESS return code.

Return Value:

    DWORD error code.

--*/
{
    LPWSTR pszNewLocalName;
    DWORD  dwLastError;

    if( !CheckSepFile( pPrinter->pSepFile )) {
        return ERROR_INVALID_SEPARATOR_FILE;
    }

    if( pPrinter->Priority != NO_PRIORITY &&
        ( pPrinter->Priority > MAX_PRIORITY ||
          pPrinter->Priority < MIN_PRIORITY )){

        return ERROR_INVALID_PRIORITY;
    }

    if( pPrinter->StartTime >= ONEDAY || pPrinter->UntilTime >= ONEDAY){

        return  ERROR_INVALID_TIME;
    }

    if ( dwLastError = ValidatePrinterName(pPrinter->pPrinterName,
                                           pIniSpooler,
                                           pIniPrinter,
                                           &pszNewLocalName) ) {

        return dwLastError;
    }

    // Share name length validation
    if(pPrinter->pShareName && wcslen(pPrinter->pShareName) > PATHLEN-1){

        return ERROR_INVALID_SHARENAME;
    }

    if ( pPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED ){

        if ( dwLastError = ValidatePrinterShareName(pPrinter->pShareName,
                                                    pIniSpooler,
                                                    pIniPrinter) ) {

            return dwLastError;
        }
    }

    // Server name length validation
    if ( pPrinter->pServerName && wcslen(pPrinter->pServerName) > MAX_PATH-1 ){
        return ERROR_INVALID_PARAMETER;
    }

    // Comment length validation
    if ( pPrinter->pComment && wcslen(pPrinter->pComment) > PATHLEN-1 ){
        return ERROR_INVALID_PARAMETER;
    }

    // Location length validation
    if ( pPrinter->pLocation && wcslen(pPrinter->pLocation) > MAX_PATH-1 ){
        return ERROR_INVALID_PARAMETER;
    }

    // Parameters length validation
    if ( pPrinter->pParameters && wcslen(pPrinter->pParameters) > MAX_PATH-1){
        return ERROR_INVALID_PARAMETER;
    }

    // Datatype length validation
    if ( pPrinter->pDatatype && wcslen(pPrinter->pDatatype) > MAX_PATH-1){
        return ERROR_INVALID_DATATYPE;
    }

    if( ppszLocalName ){

        *ppszLocalName = pszNewLocalName;
    }
    return ERROR_SUCCESS;
}




HANDLE
LocalAddPrinter(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPrinterInfo
)
{
    PINISPOOLER pIniSpooler;
    HANDLE hReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    hReturn = SplAddPrinter( pName,
                             Level,
                             pPrinterInfo,
                             pIniSpooler,
                             NULL, NULL, 0);

    FindSpoolerByNameDecRef( pIniSpooler );
    return hReturn;
}


HANDLE
LocalAddPrinterEx(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPrinterInfo,
    LPBYTE  pSplClientInfo,
    DWORD   dwSplClientLevel
)
{
    PINISPOOLER pIniSpooler;
    HANDLE hReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    hReturn = SplAddPrinter( pName, Level, pPrinterInfo,
                             pIniSpooler, NULL, pSplClientInfo,
                             dwSplClientLevel);

    FindSpoolerByNameDecRef( pIniSpooler );
    return hReturn;
}

VOID
RemovePrinterFromPort(
    IN  PINIPRINTER pIniPrinter,
    IN  PINIPORT    pIniPort
    )
/*++

Routine Description:

    Remove a pIniPrinter structure from a pIniPort.

    Note: This code used to be inside RemovePrinterFromAllPorts. It search the list of printers that uses the port for
    pIniPrinter. When it find it, it adjust the list of printers by moving the elements so that a failure of resizing the
    array won't affect the actual removing.
    RESIZEPORTPRINTERS will try to allocate a new buffer of given size. If succeeds the allocation, it will free the old buffer.
    If not, it will return NULL without freeing anything.

Arguments:

    pIniPrinter - must not be NULL
    pIniPort    - must not be NULL

Return Value:

    VOID

--*/
{
    DWORD           j, k;
    PINIPRINTER    *ppIniPrinter;
    SplInSem();

    if(pIniPort && pIniPrinter) {

        for ( j = 0 ; j < pIniPort->cPrinters ; ++j ) {

            if ( pIniPort->ppIniPrinter[j] != pIniPrinter )
                continue;

            //
            // Adjust the list of printers that use the port
            //
            for ( k = j + 1 ; k < pIniPort->cPrinters ; ++k )
                pIniPort->ppIniPrinter[k-1] = pIniPort->ppIniPrinter[k];

            ppIniPrinter = RESIZEPORTPRINTERS(pIniPort, -1);

            //
            // A memory allocation failure won't affect the actual removal
            //
            if ( ppIniPrinter != NULL )
                pIniPort->ppIniPrinter = ppIniPrinter;

            if ( !--pIniPort->cPrinters )
                RemoveDeviceName(pIniPort);

            break;

        }
    }

}

HANDLE
SplAddPrinter(
    LPWSTR      pName,
    DWORD       Level,
    LPBYTE      pPrinterInfo,
    PINISPOOLER pIniSpooler,
    LPBYTE      pExtraData,
    LPBYTE      pSplClientInfo,
    DWORD       dwSplClientInfoLevel
)
{
    PINIDRIVER      pIniDriver = NULL;
    PINIPRINTPROC   pIniPrintProc;
    PINIPRINTER     pIniPrinter = NULL;
    PINIPORT        pIniPort;
    PPRINTER_INFO_2 pPrinter=(PPRINTER_INFO_2)pPrinterInfo;
    DWORD           cbIniPrinter = sizeof(INIPRINTER);
    BOOL            bSucceeded = TRUE;
    PKEYDATA        pKeyData = NULL;
    DWORD           i;
    HANDLE          hPrinter = NULL;
    DWORD           TypeofHandle = PRINTER_HANDLE_PRINTER;
    PRINTER_DEFAULTS Defaults;
    PINIPORT        pIniNetPort = NULL;
    PINIVERSION     pIniVersion = NULL;
    HANDLE          hPort = NULL;
    BOOL            bAccessSystemSecurity = FALSE, bDriverEventCalled = FALSE;
    DWORD           AccessRequested = 0;
    DWORD           dwLastError = ERROR_SUCCESS;
    PDEVMODE        pNewDevMode = NULL;
    PINIMONITOR     pIniLangMonitor;
    LPWSTR          pszDeviceInstanceId = NULL;


    // Quick Check Outside Critical Section
    // Since it is common for the ServerThread to call
    // AddPrinter Level 1, which we need to continue
    // to route to other Print Providers

    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }


 try {

   EnterSplSem();

    // PRINTER_INFO_1 is only used by printer browsing to replicate
    // data between different print servers.
    // Thus we add a Net printer for level 1.

    if ( Level == 1 ) {

        //
        // All network printers reside in pLocalIniSpooler to avoid
        // duplicates.
        //
        hPrinter = AddNetPrinter( pPrinterInfo, pLocalIniSpooler );
        leave;
    }


    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {
        leave;
    }

    if ( dwLastError = ValidatePrinterInfo( pPrinter,
                                            pIniSpooler,
                                            NULL,
                                            NULL )){

        leave;
    }


    if (!(pKeyData = CreateTokenList(pPrinter->pPortName))) {

        dwLastError = ERROR_UNKNOWN_PORT;
        leave;
    }

    if ( pName && pName[0] ) {

        TypeofHandle |= PRINTER_HANDLE_REMOTE_DATA;
    }

    if ( !IsLocalCall() ) {

        TypeofHandle |= PRINTER_HANDLE_REMOTE_CALL;
    }

    if (!ValidatePortTokenList(pKeyData, pIniSpooler, FALSE, NULL)) {

        //
        // ValidatePortTokenList sets the last error to ERROR_INVALID_PRINTER_NAME
        // when port name is invalid. This is correct only for masquerading printers.
        // Otherwise, it should be ERROR_UNKNOWN_PORT.
        // Masq. Printer: both PRINTER_ATTRIBUTE_NETWORK | PRINTER_ATTRIBUTE_LOCAL are set.
        //
        if (!(pPrinter->Attributes & (PRINTER_ATTRIBUTE_NETWORK | PRINTER_ATTRIBUTE_LOCAL))) {
            SetLastError(ERROR_UNKNOWN_PORT);
        }

        leave;
    }

    FindLocalDriverAndVersion(pIniSpooler, pPrinter->pDriverName, &pIniDriver, &pIniVersion);

    if (!pIniDriver) {

        dwLastError = ERROR_UNKNOWN_PRINTER_DRIVER;
        leave;
    }

    //
    // Check for blocked KM drivers
    //
    if (KMPrintersAreBlocked() &&
        IniDriverIsKMPD(pIniSpooler,
                        FindEnvironment(szEnvironment, pIniSpooler),
                        pIniVersion,
                        pIniDriver)) {

        SplLogEvent( pIniSpooler,
                     LOG_ERROR,
                     MSG_KM_PRINTERS_BLOCKED,
                     TRUE,
                     pPrinter->pPrinterName,
                     NULL );

        dwLastError = ERROR_KM_DRIVER_BLOCKED;
        leave;
    }

    if (!(pIniPrintProc = FindPrintProc(pPrinter->pPrintProcessor,
                                        FindEnvironment(szEnvironment, pIniSpooler)))) {

        dwLastError = ERROR_UNKNOWN_PRINTPROCESSOR;
        leave;
    }

    if ( pPrinter->pDatatype && *pPrinter->pDatatype &&
         !FindDatatype(pIniPrintProc, pPrinter->pDatatype) ) {

        dwLastError = ERROR_INVALID_DATATYPE;
        leave;
    }

    DBGMSG(DBG_TRACE, ("AddPrinter(%ws)\n", pPrinter->pPrinterName ?
                                            pPrinter->pPrinterName : L"NULL"));

    //
    // Set up defaults for CreatePrinterHandle.
    // If we create a printer we have Administer access to it:
    //
    Defaults.pDatatype     = NULL;
    Defaults.pDevMode      = NULL;
    Defaults.DesiredAccess = PRINTER_ALL_ACCESS;

    pIniPrinter = (PINIPRINTER)AllocSplMem( cbIniPrinter );

    if ( pIniPrinter == NULL ) {
        leave;
    }

    pIniPrinter->signature = IP_SIGNATURE;
    pIniPrinter->Status |= PRINTER_PENDING_CREATION;
    pIniPrinter->pExtraData = pExtraData;
    pIniPrinter->pIniSpooler = pIniSpooler;
    pIniPrinter->dwPrivateFlag = 0;

    // Give the printer a unique session ID to pass around in notifications
    pIniPrinter->dwUniqueSessionID = dwUniquePrinterSessionID++;

    //
    // Reference count the pIniSpooler.
    //
    INCSPOOLERREF( pIniSpooler );
    DbgPrinterInit( pIniPrinter );

    INCDRIVERREF(pIniDriver);
    pIniPrinter->pIniDriver = pIniDriver;

    pIniPrintProc->cRef++;
    pIniPrinter->pIniPrintProc = pIniPrintProc;

    pIniPrinter->dnsTimeout = DEFAULT_DNS_TIMEOUT;
    pIniPrinter->txTimeout  = DEFAULT_TX_TIMEOUT;


    INCPRINTERREF( pIniPrinter );

    if ( !CreatePrinterEntry(pPrinter, pIniPrinter, &bAccessSystemSecurity)) {

        leave;
    }

    pIniPrinter->ppIniPorts = AllocSplMem(pKeyData->cTokens * sizeof(INIPORT));

    if ( !pIniPrinter->ppIniPorts ) {

        leave;
    }

    if (!pIniPrinter->pDatatype) {

        pIniPrinter->pDatatype = AllocSplStr(*((LPWSTR *)pIniPrinter->pIniPrintProc->pDatatypes));

        if ( pIniPrinter->pDatatype == NULL )
            leave;
    }

    // Add this printer to the global list for this machine

    SplInSem();
    pIniPrinter->pNext = pIniSpooler->pIniPrinter;
    pIniSpooler->pIniPrinter = pIniPrinter;


    //
    // When a printer is created we will enable bidi by default
    //
    pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_ENABLE_BIDI;
    if ( pIniPrinter->pIniDriver->pIniLangMonitor ) {

        pIniPrinter->Attributes |= PRINTER_ATTRIBUTE_ENABLE_BIDI;
    }


    for ( i = 0; i < pKeyData->cTokens; i++ ) {

        pIniPort = (PINIPORT)pKeyData->pTokens[i];

        if ( !AddIniPrinterToIniPort( pIniPort, pIniPrinter ) ) {
            leave;
        }

        pIniPrinter->ppIniPorts[i] = pIniPort;
        pIniPrinter->cPorts++;

        // If there isn't a monitor for this port,
        // it's a network printer.
        // Make sure we can get a handle for it.
        // This will attempt to open only the first one
        // it finds.  Any others will be ignored.

        if (!(pIniPort->Status & PP_MONITOR) && !hPort) {

            if( bSucceeded = OpenPrinterPortW(pIniPort->pName,
                                                     &hPort, NULL)) {

                // Store the address of the INIPORT structure
                // that refers to the network share.
                // This should correspond to pIniPort in any
                // handles opened on this printer.
                // Only the first INIPORT in the linked list
                // is a valid network port.

                pIniNetPort = pIniPort;
                pIniPrinter->pIniNetPort = pIniNetPort;

                //
                // Clear the placeholder status from the pIniPort.
                //
                pIniPort->Status &= ~PP_PLACEHOLDER;

            } else {

                DBGMSG(DBG_WARNING,
                       ("SplAddPrinter OpenPrinterPort( %ws ) failed: Error %d\n",
                        pIniPort->pName,
                        GetLastError()));
                leave;
            }

        } else if ( !pIniPort->hPort ) {


            LPTSTR pszPrinter;
            TCHAR szFullPrinter[ MAX_UNC_PRINTER_NAME ];

            if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_ENABLE_BIDI )
                pIniLangMonitor = pIniPrinter->pIniDriver->pIniLangMonitor;
            else
                pIniLangMonitor = NULL;

            if( pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){

                pszPrinter = szFullPrinter;

                wsprintf( szFullPrinter,
                          L"%ws\\%ws",
                          pIniSpooler->pMachineName,
                          pIniPrinter->pName );
            } else {

                pszPrinter = pIniPrinter->pName;
            }

            OpenMonitorPort(pIniPort,
                            &pIniLangMonitor,
                            pszPrinter,
                            TRUE);
        }
    }

    if ( !UpdateWinIni( pIniPrinter ) ) {

        leave;
    }


    if (bAccessSystemSecurity) {

        Defaults.DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    AccessRequested = Defaults.DesiredAccess;

    SplInSem();

    hPrinter = CreatePrinterHandle( pIniPrinter->pName,
                                    pName ? pName : pIniSpooler->pMachineName,
                                    pIniPrinter,
                                    pIniPort,
                                    pIniNetPort,
                                    NULL,
                                    TypeofHandle,
                                    hPort,
                                    &Defaults,
                                    pIniSpooler,
                                    AccessRequested,
                                    pSplClientInfo,
                                    dwSplClientInfoLevel,
                                    INVALID_HANDLE_VALUE );

    if ( hPrinter == NULL ) {
        leave;
    }


    if ( !UpdatePrinterIni( pIniPrinter, UPDATE_CHANGEID )) {

        dwLastError = GetLastError();

        SplClosePrinter( hPrinter );
        hPrinter = NULL;
        leave;
    }


    if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED ) {

        INC_PRINTER_ZOMBIE_REF(pIniPrinter);

        //
        // NOTE ShareThisPrinter will leave critical section and the
        // server will call the spooler back again to OpenPrinter this
        // printer.  So this printer MUST be fully created at the point
        // it is shared, so that Open can succeed.
        //
        bSucceeded = ShareThisPrinter(pIniPrinter,
                                      pIniPrinter->pShareName,
                                      TRUE
                                      );

        DEC_PRINTER_ZOMBIE_REF(pIniPrinter);

        if ( !bSucceeded ) {

            //
            // We do not want to delete the existing share in DeletePrinterIni
            //
            pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_SHARED;
            DBGMSG( DBG_WARNING, ("LocalAddPrinter: %ws share failed %ws error %d\n",
                    pIniPrinter->pName,
                    pIniPrinter->pShareName,
                    GetLastError() ));


            //
            //  With PRINTER_PENDING_CREATION turned on we will Delete this printer.
            //

            pIniPrinter->Status |= PRINTER_PENDING_CREATION;

            dwLastError = GetLastError();

            SPLASSERT( hPrinter );
            SplClosePrinter( hPrinter );
            hPrinter = NULL;
            leave;
        }
    }

    pIniPrinter->Status |= PRINTER_OK;
    SplInSem();

    // Call the DriverEvent with PRINTER_INITIALIZE while adding local printers

    LeaveSplSem();

    if (pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL) {


        if (PrinterDriverEvent(pIniPrinter,
                               PRINTER_EVENT_INITIALIZE,
                               (LPARAM)NULL)) {

            bDriverEventCalled = TRUE;

        } else {

            dwLastError = GetLastError();

            if (dwLastError != ERROR_PROC_NOT_FOUND) {

                if (!dwLastError)
                    dwLastError = ERROR_CAN_NOT_COMPLETE;

                EnterSplSem();

                //  With PRINTER_PENDING_CREATION turned on the printer will be deleted.
                pIniPrinter->Status |= PRINTER_PENDING_CREATION;
                SplClosePrinter( hPrinter );
                hPrinter = NULL;

                leave;
             }
        }

    }

    EnterSplSem();

    //
    // If no devmode is given get driver default, if a devmode is given
    // convert it to current version
    //
    // Check if it's local (either pLocalIniSpooler or cluster).
    //
    if ( pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL ) {

        if (!(pNewDevMode = ConvertDevModeToSpecifiedVersion(pIniPrinter,
                                                             pIniPrinter->pDevMode,
                                                             NULL,
                                                             NULL,
                                                             CURRENT_VERSION))) {

           dwLastError = GetLastError();
           if (!dwLastError) {
              dwLastError = ERROR_CAN_NOT_COMPLETE;
           }

           //  With PRINTER_PENDING_CREATION turned on the printer will be deleted.
           pIniPrinter->Status |= PRINTER_PENDING_CREATION;
           SplClosePrinter( hPrinter );
           hPrinter = NULL;

           leave;
        }

        //
        // If call is remote we must convert devmode before setting it
        //
        if ( pNewDevMode || (TypeofHandle & PRINTER_HANDLE_REMOTE_DATA) ) {

            FreeSplMem(pIniPrinter->pDevMode);
            pIniPrinter->pDevMode = pNewDevMode;
            if ( pNewDevMode ) {

                pIniPrinter->cbDevMode = pNewDevMode->dmSize
                                             + pNewDevMode->dmDriverExtra;
                SPLASSERT(pIniPrinter->cbDevMode);

            } else {

                pIniPrinter->cbDevMode = 0;
            }
            pNewDevMode = NULL;
        }
    }

    if ( pIniPrinter->pDevMode ) {

        //
        // Fix up the DEVMODE.dmDeviceName field.
        //
        FixDevModeDeviceName(pIniPrinter->pName,
                             pIniPrinter->pDevMode,
                             pIniPrinter->cbDevMode);
    }

    //
    // We need to write the new devmode to the registry
    //
    if ( !UpdatePrinterIni(pIniPrinter, UPDATE_CHANGEID) ) {

        DBGMSG(DBG_WARNING,
               ("SplAddPrinter: UpdatePrinterIni failed after devmode conversion\n"));
    }

    //
    // For Masq printers, give the provider a chance to update the printer registry, if desired.
    //
    if( pIniNetPort ) {
        static const WCHAR c_szHttp[]   = L"http://";
        static const WCHAR c_szHttps[]  = L"https://";

        if( !_wcsnicmp( pIniPort->pName, c_szHttp, lstrlen ( c_szHttp ) ) ||
            !_wcsnicmp( pIniPort->pName, c_szHttps, lstrlen ( c_szHttps ) ) ) {
            UpdatePrinterNetworkName(pIniPrinter, pIniPort->pName);
        }
    }

    //
    // DS: Create the DS keys
    //
    INCPRINTERREF(pIniPrinter);
    LeaveSplSem();

    RecreateDsKey(hPrinter, SPLDS_DRIVER_KEY);
    RecreateDsKey(hPrinter, SPLDS_SPOOLER_KEY);

    EnterSplSem();
    DECPRINTERREF(pIniPrinter);


    //  From this point on we don't care if any of these fail
    //  we still keep the created printer.

    SplLogEvent( pIniSpooler,
                 LOG_INFO,
                 MSG_PRINTER_CREATED,
                 TRUE,
                 pIniPrinter->pName,
                 NULL );


    //
    // The is a work-around for a TS problem. When a TS printer is added, it
    // shows up in the UI of the users who have logged in before. The reason
    // for this is that the UI has done a FFPCN on the server handle and the
    // Notifications are not aware  of visibility. If you force the UI to
    // refresh now, it will  Enumerate all of the printers again and correctly
    // not show them. The proper fix is to add the visibility checks to the
    // localspl notification code. However, the form of the notification code
    // assumes that it is called in a CS and  would require substantial
    // rewriting to fix this. We know that this is a TS printer because it is
    // added with a security descriptor.
    //
    SetPrinterChange(pIniPrinter,
                     NULL,
                     pPrinter->pSecurityDescriptor ? NVPurge : NVPrinterAll,
                     PRINTER_CHANGE_ADD_PRINTER,
                     pIniSpooler);


 } finally {

    SplInSem();

    if ( hPrinter == NULL ) {

        // FAILURE CLEAN-UP

        // If a subroutine we called failed
        // then we should save its error incase it is
        // altered during cleanup.

        if ( dwLastError == ERROR_SUCCESS ) {
            dwLastError = GetLastError();
        }

        if ( pIniPrinter == NULL ) {

            //  Allow a Print Provider to free its ExtraData
            //  associated with this printer.

            if (( pIniSpooler->pfnFreePrinterExtra != NULL ) &&
                ( pExtraData != NULL )) {

                (*pIniSpooler->pfnFreePrinterExtra)( pExtraData );

            }

        } else if ( pIniPrinter->Status & PRINTER_PENDING_CREATION ) {

            if (bDriverEventCalled) {

               LeaveSplSem();

                // Call Driver Event to report that the printer has been deleted
               PrinterDriverEvent( pIniPrinter, PRINTER_EVENT_DELETE, (LPARAM)NULL );

               EnterSplSem();
            }

            DECPRINTERREF( pIniPrinter );

            InternalDeletePrinter( pIniPrinter );

        }

    } else {

        // Success

        if ( pIniPrinter ) {

            DECPRINTERREF( pIniPrinter );
        }
    }

    FreePortTokenList(pKeyData);

    LeaveSplSem();
    SplOutSem();

    FreeSplMem(pNewDevMode);

    if ( hPrinter == NULL && Level != 1 ) {

        DBGMSG(DBG_WARNING, ("SplAddPrinter failed error %d\n", dwLastError ));
        SPLASSERT(dwLastError);
        SetLastError ( dwLastError );

    }

    DBGMSG( DBG_TRACE, ("SplAddPrinter returned handle %x\n", hPrinter ));
 }
    //
    // Make (HANDLE)-1 indicate ROUTER_STOP_ROUTING.
    //
    if( !hPrinter ){
        hPrinter = (HANDLE)-1;
    }

    return hPrinter;

}


VOID
RemovePrinterFromAllPorts(
    IN  PINIPRINTER pIniPrinter,
    IN  BOOL        bIsInitTime
    )
/*++

Routine Description:

    Remove a pIniPrinter structure from all pIniPort structures that it is associated with.

    Note: This code used to be inside RemovePrinterFromAllPorts. It search the list of printers that uses the port for
    pIniPrinter. When it find it, it adjust the list of printers by moving the elements so that a failure of resizing the
    array won't affect the actual removing.
    RESIZEPORTPRINTERS will try to allocate a new buffer of given size. If succeeds the allocation, it will free the old buffer.
    If not, it will return NULL without freeing anything.

Arguments:

    pIniPrinter - must not be NULL
    pIniPort    - must not be NULL

Return Value:

    VOID

--*/
{
    DWORD           i,j, k;
    PINIPORT        pIniPort;
    PINIPRINTER    *ppIniPrinter;
    SplInSem();

    for ( i = 0 ; i < pIniPrinter->cPorts ; ++i ) {

        pIniPort = pIniPrinter->ppIniPorts[i];

        RemovePrinterFromPort(pIniPrinter, pIniPort);

        //
        // Delete port if is initialization time , it doesn't have printers
        // attached and it has no Monitor;
        // This is a fix for the USBMON problem described below:
        // USBMON doesn't enumerate the ports which are not used by a printer.
        // Spooler doesn't enumerate printers which are in pending deletion state.
        // Scenario:  Spooler initializes , all printers that uses a
        // certain USB_X port are in pending deletion state,
        // the USB_X port doesn't get enumerated by USBMON,
        // but it is created as a fake port by spooler since is still used by
        // the printer in pending deletion state. Eventually the prinetr goes away,
        // but we end up with this fake port.
        //
        if( bIsInitTime && !pIniPort->cPrinters && !pIniPort->pIniMonitor )
            DeletePortEntry(pIniPort);
    }

}



VOID
CloseMonitorsRestartOrphanJobs(
    PINIPRINTER pIniPrinter
    )
{
    PINIPORT    pIniPort;
    DWORD       i;
    BOOL        bFound;

    SplInSem();

    for ( pIniPort = pIniPrinter->pIniSpooler->pIniPort;
          pIniPort != NULL;
          pIniPort = pIniPort->pNext ) {

        if ( pIniPort->pIniJob != NULL &&
             pIniPort->pIniJob->pIniPrinter == pIniPrinter ) {


            // If this printer is no longer associated with this port
            // then restart that job.

            for ( i = 0, bFound = FALSE;
                  i < pIniPort->cPrinters;
                  i++) {

                if (pIniPort->ppIniPrinter[i] == pIniPrinter) {
                    bFound = TRUE;
                }
            }

            if ( !bFound ) {

                DBGMSG( DBG_WARNING, ("CloseMonitorsRestartOrphanJobs Restarting JobId %d\n", pIniPort->pIniJob->JobId ));
                RestartJob( pIniPort->pIniJob );
            }
        }

        if ( !pIniPort->cPrinters &&
             !(pIniPort->Status & PP_THREADRUNNING) ) {

            CloseMonitorPort(pIniPort, TRUE);
        }
    }
}


// This really does delete the printer.
// It should be called only when the printer has no open handles
// and no jobs waiting to print

BOOL
DeletePrinterForReal(
    PINIPRINTER pIniPrinter,
    BOOL        bIsInitTime
    )
{
    PINIPRINTER *ppIniPrinter;
    DWORD       i,j;
    PINISPOOLER pIniSpooler;
    LPWSTR  pComma;
    DWORD   Status;

    SplInSem();
    SPLASSERT( pIniPrinter->pIniSpooler->signature == ISP_SIGNATURE );

    pIniSpooler = pIniPrinter->pIniSpooler;

    if ( pIniPrinter->pName != NULL ) {

        DBGMSG( DBG_TRACE, ("Deleting %ws for real\n", pIniPrinter->pName ));
    }

    CheckAndUpdatePrinterRegAll( pIniSpooler,
                                 pIniPrinter->pName,
                                 NULL,
                                 UPDATE_REG_DELETE );

    DeleteIniPrinterDevNode(pIniPrinter);

    if( pIniPrinter->pIniNetPort) {
        DeletePort(NULL, NULL, pIniPrinter->pIniNetPort->pName);
    }


    DeletePrinterIni( pIniPrinter );

    //  Take this IniPrinter off the list of printers for
    //  this IniSpooler

    SplInSem();
    ppIniPrinter = &pIniSpooler->pIniPrinter;

    while (*ppIniPrinter && *ppIniPrinter != pIniPrinter) {
        ppIniPrinter = &(*ppIniPrinter)->pNext;
    }

    if (*ppIniPrinter)
        *ppIniPrinter = pIniPrinter->pNext;

    //
    //  Decrement useage counts for Print Processor & Driver
    //

    if ( pIniPrinter->pIniPrintProc )
        pIniPrinter->pIniPrintProc->cRef--;

    if ( pIniPrinter->pIniDriver )
        DECDRIVERREF(pIniPrinter->pIniDriver);

    RemovePrinterFromAllPorts(pIniPrinter, bIsInitTime);

    CloseMonitorsRestartOrphanJobs( pIniPrinter );

    DeletePrinterSecurity( pIniPrinter );

    //  When the printer is Zombied it gets a trailing comma
    //  Concatingated with the name ( see job.c deleteprintercheck ).
    //  Remove trailing , from printer name before we log it as deleted.

    if ( pIniPrinter->pName != NULL ) {

        pComma = wcsrchr( pIniPrinter->pName, *szComma );

        if ( pComma != NULL ) {

            *pComma = 0;
        }

        SplLogEvent( pIniSpooler,
                     LOG_WARNING,
                     MSG_PRINTER_DELETED,
                     TRUE,
                     pIniPrinter->pName,
                     NULL );
    }

    FreeStructurePointers((LPBYTE) pIniPrinter, NULL, IniPrinterOffsets);

    //
    // Allow a Print Provider to free its ExtraData
    // associated with this printer.
    //

    if (( pIniSpooler->pfnFreePrinterExtra != NULL ) &&
        ( pIniPrinter->pExtraData != NULL )) {

        (*pIniSpooler->pfnFreePrinterExtra)( pIniPrinter->pExtraData );
    }

    //
    // Reference count the pIniSpooler.
    //
    DECSPOOLERREF( pIniPrinter->pIniSpooler );
    DbgPrinterFree( pIniPrinter );

    FreeSplMem( pIniPrinter );

    return TRUE;
}



VOID
InternalDeletePrinter(
    PINIPRINTER pIniPrinter
    )
{
    BOOL dwRet = FALSE;

    SPLASSERT( pIniPrinter->signature == IP_SIGNATURE );
    SPLASSERT( pIniPrinter->pIniSpooler->signature == ISP_SIGNATURE );

    //
    //  This Might be a partially created printer that has no name
    //

    if ( pIniPrinter->pName != NULL ) {

        DBGMSG(DBG_TRACE, ("LocalDeletePrinter: %ws pending deletion: references = %d; jobs = %d\n",
                           pIniPrinter->pName, pIniPrinter->cRef, pIniPrinter->cJobs));

        INCPRINTERREF( pIniPrinter );

        SplLogEvent( pIniPrinter->pIniSpooler, LOG_WARNING, MSG_PRINTER_DELETION_PENDING,
                  TRUE, pIniPrinter->pName, NULL );

        DECPRINTERREF( pIniPrinter );
    }

    //
    // Mark the printer as "Don't accept any jobs" to make sure
    // that no more are accepted while we are outside CS.
    // Marking the printer in PRINTER_PENDING_DELETION also would
    // prevent adding any jobs, but then the OpenPrinter calls that the
    // driver does inside DrvDriverEvent will fail.
    //
    pIniPrinter->Status |= PRINTER_NO_MORE_JOBS;

    if (pIniPrinter->cJobs == 0)
    {
        INCPRINTERREF(pIniPrinter);
        LeaveSplSem();
        SplOutSem();

        PrinterDriverEvent( pIniPrinter, PRINTER_EVENT_DELETE, (LPARAM)NULL );

        EnterSplSem();
        SplInSem();
        DECPRINTERREF(pIniPrinter);
    }

    pIniPrinter->Status |= PRINTER_PENDING_DELETION;

    if (!(pIniPrinter->Status & PRINTER_PENDING_CREATION)) {

        SetPrinterChange(pIniPrinter,
                         NULL,
                         NVPrinterStatus,
                         PRINTER_CHANGE_DELETE_PRINTER,
                         pIniPrinter->pIniSpooler );
    }

    INC_PRINTER_ZOMBIE_REF( pIniPrinter );

    if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED ) {

        dwRet = ShareThisPrinter(pIniPrinter, pIniPrinter->pShareName, FALSE);

        if (!dwRet) {

            pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_SHARED;
            pIniPrinter->Status |= PRINTER_WAS_SHARED;
            CreateServerThread();

        } else {

            DBGMSG(DBG_WARNING, ("LocalDeletePrinter: Unsharing this printer failed %ws\n", pIniPrinter->pName));
        }
    }

    DEC_PRINTER_ZOMBIE_REF( pIniPrinter );


    // The printer doesn't get deleted until ClosePrinter is called
    // on the last remaining handle.

    UpdatePrinterIni( pIniPrinter, UPDATE_CHANGEID );

    UpdateWinIni( pIniPrinter );

    DeletePrinterCheck( pIniPrinter );
}



BOOL
SplDeletePrinter(
    HANDLE  hPrinter
)
{
    PINIPRINTER pIniPrinter;
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    DWORD       LastError = ERROR_SUCCESS;
    PINISPOOLER pIniSpooler;

    EnterSplSem();

    pIniSpooler = pSpool->pIniSpooler;

    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );


    if ( ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER) ) {

        pIniPrinter = pSpool->pIniPrinter;

        DBGMSG( DBG_TRACE, ( "SplDeletePrinter: %s called\n", pIniPrinter->pName ));

        if ( !AccessGranted(SPOOLER_OBJECT_PRINTER,
                            DELETE, pSpool) ) {

            LastError = ERROR_ACCESS_DENIED;

        } else if (pIniPrinter->cJobs && (pIniPrinter->Status & PRINTER_PAUSED)) {

            // Don't allow a printer to be deleted that is paused and has
            // jobs waiting, otherwise it'll never get deleted:

            LastError = ERROR_PRINTER_HAS_JOBS_QUEUED;

        } else {

            if (!(pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CACHE) &&
                (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED)) {

                if (!pIniPrinter->bDsPendingDeletion) {
                    pIniPrinter->bDsPendingDeletion = TRUE;
                    INCPRINTERREF(pIniPrinter);     // DECPRINTERREF is done in UnpublishByGUID
                    SetPrinterDs(hPrinter, DSPRINT_UNPUBLISH, FALSE);
                }
            }

            InternalDeletePrinter( pIniPrinter );
            (VOID) ObjectDeleteAuditAlarm( szSpooler, pSpool, pSpool->GenerateOnClose );
        }

    } else
        LastError = ERROR_INVALID_HANDLE;

    LeaveSplSem();
    SplOutSem();

    if (LastError) {
        SetLastError(LastError);
        return FALSE;
    }

    return TRUE;
}

BOOL
PurgePrinter(
    PINIPRINTER pIniPrinter
    )
{
    PINIJOB pIniJob;
    PINISPOOLER pIniSpooler = pIniPrinter->pIniSpooler;

SplInSem();

    while (pIniJob = pIniPrinter->pIniFirstJob) {

        while (pIniJob) {

            if ( (pIniJob->cRef == 0) || !(pIniJob->Status & JOB_PENDING_DELETION)) {

                // this job is going to be deleted

                DBGMSG(DBG_TRACE, ("Job Address 0x%.8x Job Status 0x%.8x\n", pIniJob, pIniJob->Status));
                break;
            }
            pIniJob = pIniJob->pIniNextJob;
        }

        // This job needs to be deleted

        if (pIniJob) {
            pIniJob->Status &= ~JOB_RESTART;
            DeleteJob(pIniJob,NO_BROADCAST);
        } else
            break;
    }

    // When purging a printer we don't want to generate a spooler information
    // message for each job being deleted becuase a printer might have a very
    // large number of jobs being purged would lead to a large number of
    // of unnessary and time consuming messages being generated.
    // Since this is a information only message it shouldn't cause any problems
    // Also Win 3.1 didn't have purge printer functionality and the printman
    // generated this message on Win 3.1

    if( dwEnableBroadcastSpoolerStatus ){
        BroadcastChange( pIniSpooler,WM_SPOOLERSTATUS, PR_JOBSTATUS, (LPARAM)0);
    }

    return TRUE;
}


BOOL
SetPrinterPorts(
    PSPOOL      pSpool,         // Caller's printer handle.  May be NULL.
    PINIPRINTER pIniPrinter,
    PKEYDATA    pKeyData
)
{
    DWORD       i,j;
    PINIPORT    pIniNetPort = NULL, pIniPort;
    BOOL        bReturnValue = TRUE;
    PINIPRINTER *ppIniPrinter;


    SPLASSERT( pIniPrinter != NULL );
    SPLASSERT( pIniPrinter->signature == IP_SIGNATURE );
    SPLASSERT( pIniPrinter->pIniSpooler != NULL );
    SPLASSERT( pIniPrinter->pIniSpooler->signature == ISP_SIGNATURE );

    //
    // Can't change the port for a masq printer
    //
    if ( (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_LOCAL)  &&
         (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_NETWORK) ) {

        if ( pKeyData->cTokens == 1 &&
             pSpool->pIniNetPort == (PINIPORT)pKeyData->pTokens[0] )
            return TRUE;

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Can't change printer port to that of a masq printer
    //
    for ( i = 0 ; i < pKeyData->cTokens ; ++i )
        if ( !(((PINIPORT) pKeyData->pTokens[i])->Status & PP_MONITOR) ) {

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

    //
    // Remove the printer from all ports ; break the link from ports to printer
    //
    RemovePrinterFromAllPorts(pIniPrinter, NON_INIT_TIME);

    //
    // Remove all ports from printer; break the link from printer to ports
    //
    FreeSplMem(pIniPrinter->ppIniPorts);
    pIniPrinter->ppIniPorts = NULL;
    pIniPrinter->cPorts = 0;

    // Bug-Bug
    // If we fail to add all the ports inside pKeyData, we'll leave the printer in this state
    // where it's initials ports are gone and only part or none of the ports are added.
    //

    // Go through all the ports that this printer is connected to,
    // and add build the bi-dir links between printer and ports.

    for (i = 0; i < pKeyData->cTokens; i++ ) {

        pIniPort = (PINIPORT)pKeyData->pTokens[i];

        //
        // Add pIniPrinter to pIniPort
        //
        if ( AddIniPrinterToIniPort( pIniPort, pIniPrinter ) ) {

            //
            // If we succeeded, add pIniPort to pIniPrinter
            //
            if ( !AddIniPortToIniPrinter( pIniPrinter, pIniPort ) ) {

                //
                // If fail, then remove pIniPrinter from pIniPort ;
                // If we don't do this, pIniPort will point to invalid memory when piniPrinter gets deleted
                //
                RemovePrinterFromPort(pIniPrinter, pIniPort);

                bReturnValue = FALSE;
                goto Cleanup;
            }

        } else {
            bReturnValue = FALSE;
            goto Cleanup;
        }

    }

    CloseMonitorsRestartOrphanJobs( pIniPrinter );

Cleanup:
    return bReturnValue;
}

/*++

Routine Name:

    AllocResetDevMode

Routine Description:

    This routine makes a copy of the passed in devmode that can be associated
    to the printer handle in the call to reset printer.  The passed in devmode
    can be null in this case the user does not want a devmode, this simplifies
    the caller.  This routine also takes care of a few special cases.  If
    pDevMode is -1 it returns the printers default devmode.  If the printers
    default devmode is null this function will succeed.

Arguments:

    pIniPrinter     - pointer to ini printer structure for the specified printer
    pDevMode,       - pointer to devmode to allocation, this is optional
    *ppDevMode      - pointer where to return new allocated devmode

Return Value:

    TRUE success, FALSE an error occurred.

Last Error:

    ERROR_INVALID_PARAMETER if any of the required parameters are invalid.

--*/
BOOL
AllocResetDevMode(
    IN      PINIPRINTER  pIniPrinter,
    IN      DWORD        TypeofHandle,
    IN      PDEVMODE     pDevMode,      OPTIONAL
       OUT  PDEVMODE     *ppDevMode
    )
{
    BOOL bRetval = FALSE;

    //
    // Validate the input parameters.
    //
    if (pIniPrinter && ppDevMode)
    {
        //
        // Initalize the out parameter
        //
        *ppDevMode = NULL;

        //
        // If pDevMode == -1 then we want to return the printers default devmode.
        // The -1 token is for internal use, and currently only used by the server
        // service, which does not run in the context of the user, hence we must
        // not use a per user devmode.
        //
        if (pDevMode == (PDEVMODE)-1)
        {
            //
            // If the handle is a 3.x we must convert the devmode.
            //
            if (TypeofHandle & PRINTER_HANDLE_3XCLIENT)
            {
                *ppDevMode = ConvertDevModeToSpecifiedVersion(pIniPrinter,
                                                              pDevMode,
                                                              NULL,
                                                              NULL,
                                                              NT3X_VERSION);

                bRetval = !!*ppDevMode;
            }
            else
            {
                //
                // Get the printer's default devmode.
                //
                pDevMode = pIniPrinter->pDevMode;
            }
        }

        //
        // At this point the pDevMode may be either the passed in devmode
        // or the default devmode on the printer.  If the devmode on the printer
        // is null then this function will succeed but will not return a devmode.
        //
        if (pDevMode && pDevMode != (PDEVMODE)-1)
        {
            //
            // Make a copy of the passed in devmode, this is less efficient
            // however it simplfies the callers clean up code, less chance for
            // a mistake.
            //
            UINT cbSize = pDevMode->dmSize + pDevMode->dmDriverExtra;

            *ppDevMode = AllocSplMem(cbSize);

            bRetval = !!*ppDevMode;

            if (bRetval)
            {
                memcpy(*ppDevMode, pDevMode, cbSize);
            }
        }
        else
        {
            DBGMSG(DBG_TRACE,("LocalResetPrinter: Not resetting the pDevMode field\n"));
            bRetval = TRUE;
        }
    }
    else
    {
        //
        // The function returns a bool, we must set the last error.
        //
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return bRetval;
}

/*++

Routine Name:

    AllocResetDataType

Routine Description:

    This routine allocates a new datatype that will be associated with
    a printer handle in ResetPrinter.

Arguments:

    pIniPrinter     - pointer to ini printer structure for the specified printer
    pDatatype       - the new data type to validate and allocate
    ppDatatype      - where to return the new datatype
    ppIniPrintProc  - pointer where to return the associated print processor

Return Value:

    TRUE function succeeded, FALSE an error occurred, use GetLastError() for
    extended error information.

Last Error:

    ERROR_INVALID_PARAMETER if a required parameter is invalid.
    ERROR_INVALID_DATATYPE if the specified datatype is invalid.

--*/
BOOL
AllocResetDataType(
    IN      PINIPRINTER      pIniPrinter,
    IN      PCWSTR           pDatatype,
       OUT  PCWSTR           *ppDatatype,
       OUT  PINIPRINTPROC    *ppIniPrintProc
    )
{
    BOOL bRetval = FALSE;

    //
    // Validate the input parameters.
    //
    if (pIniPrinter && ppDatatype && ppIniPrintProc)
    {
        //
        // Initalize the out parameters
        //
        *ppDatatype     = NULL;
        *ppIniPrintProc = NULL;

        if (pDatatype)
        {
            //
            // If the datatype is -1 we are being requested to
            // return the default datatype for this printer.
            //
            if (pDatatype == (LPWSTR)-1 && pIniPrinter->pDatatype)
            {
                *ppIniPrintProc = FindDatatype(pIniPrinter->pIniPrintProc, pIniPrinter->pDatatype);
            }
            else
            {
                *ppIniPrintProc = FindDatatype(pIniPrinter->pIniPrintProc, (PWSTR)pDatatype);
            }

            //
            // If the print process was found, the datatype is valid,
            // allocate the new datatype.
            //
            if (*ppIniPrintProc)
            {
                *ppDatatype = AllocSplStr(pIniPrinter->pDatatype);
                bRetval = !!*ppDatatype;
            }
            else
            {
                SetLastError(ERROR_INVALID_DATATYPE);
            }
        }
        else
        {
            DBGMSG(DBG_TRACE,("LocalResetPrinter: Not resetting the pDatatype field\n"));
            bRetval = TRUE;
        }
    }
    else
    {
        //
        // The function returns a bool, we must set the last error.
        //
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return bRetval;
}

/*++

Routine Name:

    SplResetPrinter

Routine Description:

    The ResetPrinter function lets an application specify the data type
    and device mode values that are used for printing documents submitted
    by the StartDocPrinter function. These values can be overridden by using
    the SetJob function once document printing has started.

    This routing basically has two jobs.  To reset the devmode of the
    printer handle and to reset the datatype of the printe handle.  Each
    or both operation could be ignored, if the devmode null the devmode
    will not change if the datatye is null the datatype should not change.  If
    both operations are requested and any one fails then both operations
    should fail.

Arguments:

    hPrinter    - Valid printer handle
    pDefault    - Pointer to a printer defaults structure that has a devmode
                  and data type.

Return Value:

    TRUE function succeeded, FALSE an error occurred, use GetLastError() for
    extended error information.

Last Error:

    ERROR_INVALID_PARAMETER if the pDefault is NULL,
    ERROR_INVALID_DATATYPE if the new datatype specified is unknown or invalid

--*/
BOOL
SplResetPrinter(
    IN HANDLE              hPrinter,
    IN LPPRINTER_DEFAULTS  pDefaults
    )
{
    PSPOOL          pSpool              = (PSPOOL)hPrinter;
    BOOL            bRetval             = FALSE;
    PINIPRINTPROC   pNewPrintProc       = NULL;
    LPWSTR          pNewDatatype        = NULL;
    PDEVMODE        pNewDevMode         = NULL;

    DBGMSG(DBG_TRACE, ("ResetPrinter( %08x )\n", hPrinter));

    //
    // Validate the printer handle.
    //
    if (ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER))
    {
        //
        // Validate the pDefaults
        //
        if (pDefaults)
        {
            //
            // Enter the spooler semaphore.
            //
            EnterSplSem();

            //
            // Get the new devmode, a null input devmode indicatest the caller
            // was not interesting in changing the devmode.
            //
            bRetval = AllocResetDevMode(pSpool->pIniPrinter,
                                        pSpool->TypeofHandle,
                                        pDefaults->pDevMode,
                                        &pNewDevMode);

            if (bRetval)
            {
                //
                // Get the new datatype and printprocessor, a null input datatype
                // indicates the caller was not interested in changing the datatype.
                //
                bRetval = AllocResetDataType(pSpool->pIniPrinter,
                                             pDefaults->pDatatype,
                                             &pNewDatatype,
                                             &pNewPrintProc);
            }

            if (bRetval)
            {
                //
                // Release the previous devmode provided we have a new devmode to set
                // a new devmode may not be available in the case the caller did not
                // request a devmode change.
                //
                if (pNewDevMode)
                {
                    FreeSplMem(pSpool->pDevMode);
                    pSpool->pDevMode = pNewDevMode;
                    pNewDevMode = NULL;
                }

                //
                // Release the previous datatype provided we have a new datatype to set
                // a new datatype may not be available in the case the caller did not
                // request a devmode change.
                //
                if (pNewDatatype && pNewPrintProc)
                {
                    FreeSplStr(pSpool->pDatatype);
                    pSpool->pDatatype = pNewDatatype;
                    pNewDatatype = NULL;

                    //
                    // Release the previous print processor, and assign the new one.
                    //
                    pSpool->pIniPrintProc->cRef--;
                    pSpool->pIniPrintProc = pNewPrintProc;
                    pSpool->pIniPrintProc->cRef++;
                    pNewPrintProc = NULL;
                }
            }

            //
            // Exit the spooler semaphore.
            //
            LeaveSplSem();

            //
            // Always release any resources, the mem free routines will handle null pointers.
            //
            FreeSplMem(pNewDevMode);
            FreeSplMem(pNewDatatype);
        }
        else
        {
            SetLastError(ERROR_INVALID_PARAMETER);
        }
    }

    return bRetval;
}

BOOL
CopyPrinterIni(
   PINIPRINTER pIniPrinter,
   LPWSTR pNewName
   )
{
    HKEY    hPrinterKey=NULL;
    DWORD   Status;
    PWSTR   pSourceKeyName = NULL;
    PWSTR   pDestKeyName = NULL;
    HANDLE  hToken;
    PINISPOOLER pIniSpooler = pIniPrinter->pIniSpooler;
    DWORD   dwLastError;
    BOOL    bReturnValue = TRUE;

    SPLASSERT( pIniSpooler != NULL);
    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );

    hToken = RevertToPrinterSelf();

    if (!(pSourceKeyName = SubChar(pIniPrinter->pName, L'\\', L','))) {
        bReturnValue = FALSE;
        goto error;
    }

    if (!(pDestKeyName = SubChar(pNewName, L'\\', L','))) {
        bReturnValue = FALSE;
        goto error;
    }

    if( !CopyRegistryKeys( pIniSpooler->hckPrinters,
                           pSourceKeyName,
                           pIniSpooler->hckPrinters,
                           pDestKeyName,
                           pIniSpooler )) {
        bReturnValue = FALSE;
        goto error;
    }

error:

    FreeSplStr(pSourceKeyName);
    FreeSplStr(pDestKeyName);

    ImpersonatePrinterClient( hToken );

    return bReturnValue;
}

VOID
FixDevModeDeviceName(
    LPWSTR pPrinterName,
    PDEVMODE pDevMode,
    DWORD cbDevMode)

/*++

Routine Description:

    Fixes up the dmDeviceName field of the DevMode to be the same
    as the printer name.

Arguments:

    pPrinterName - Name of the printer (qualified with server for remote)

    pDevMode - DevMode to fix up

    cbDevMode - byte count of devmode.

Return Value:

--*/

{
    DWORD cbDeviceMax;
    DWORD cchDeviceStrLenMax;
    //
    // Compute the maximum length of the device name string
    // this is the min of the structure and allocated space.
    //
    SPLASSERT(cbDevMode && pDevMode);

    if(cbDevMode && pDevMode) {
        cbDeviceMax = ( cbDevMode < sizeof(pDevMode->dmDeviceName)) ?
                        cbDevMode :
                        sizeof(pDevMode->dmDeviceName);

        SPLASSERT(cbDeviceMax);

        cchDeviceStrLenMax = (cbDeviceMax / sizeof(pDevMode->dmDeviceName[0])) -1;

        //
        // !! LATER !!
        //
        // Put in DBG code to debug print if the device name is truncated.
        //
        wcsncpy(pDevMode->dmDeviceName,
                pPrinterName,
                cchDeviceStrLenMax);

        //
        // Ensure NULL termination.
        //
        pDevMode->dmDeviceName[cchDeviceStrLenMax] = 0;

    }

}


BOOL
CopyPrinterDevModeToIniPrinter(
    PINIPRINTER pIniPrinter,
    PDEVMODE   pDevMode)
{
    BOOL bReturn = TRUE;
    DWORD dwInSize = 0;
    DWORD dwCurSize = 0;
    PINISPOOLER pIniSpooler = pIniPrinter->pIniSpooler;
    WCHAR       PrinterName[ MAX_UNC_PRINTER_NAME ];

    if (pDevMode) {

        dwInSize = pDevMode->dmSize + pDevMode->dmDriverExtra;
        if (pIniPrinter->pDevMode) {

            //
            // Detect if the devmodes are identical
            // if they are, no need to copy or send devmode.
            // (Skip the device name though!)
            //
            dwCurSize = pIniPrinter->pDevMode->dmSize
                        + pIniPrinter->pDevMode->dmDriverExtra;

            if (dwInSize == dwCurSize) {

                if (dwInSize > sizeof(pDevMode->dmDeviceName)) {

                    if (!memcmp(&pDevMode->dmSpecVersion,
                                &pIniPrinter->pDevMode->dmSpecVersion,
                                dwCurSize - sizeof(pDevMode->dmDeviceName))) {

                        //
                        // No need to copy this devmode because its identical
                        // to what we already have.
                        //
                        DBGMSG(DBG_TRACE,("Identical DevModes, no update\n"));
                        bReturn = FALSE;

                        goto FixupName;
                    }
                }
            }

            //
            // Free the devmode which we already have.
            //
            FreeSplMem(pIniPrinter->pDevMode);
        }

        pIniPrinter->cbDevMode = pDevMode->dmSize +
                                 pDevMode->dmDriverExtra;
        SPLASSERT(pIniPrinter->cbDevMode);


        if (pIniPrinter->pDevMode = AllocSplMem(pIniPrinter->cbDevMode)) {

            memcpy(pIniPrinter->pDevMode,
                   pDevMode,
                   pIniPrinter->cbDevMode);

            //
            //  Prepend the machine name if this is not localspl
            //

            if ( pIniSpooler != pLocalIniSpooler ) {

                // For Non Local Printers prepend the Machine Name

                wsprintf( PrinterName, L"%ws\\%ws", pIniSpooler->pMachineName, pIniPrinter->pName );

            } else {

                wsprintf( PrinterName, L"%ws", pIniPrinter->pName );

            }

            BroadcastChange( pIniSpooler,WM_DEVMODECHANGE, 0, (LPARAM)PrinterName);
        }

    } else {

        //
        // No old, no new, so no change.
        //
        if (!pIniPrinter->pDevMode)
            return FALSE;
    }

FixupName:

    if (pIniPrinter->pDevMode) {

        //
        // Fix up the DEVMODE.dmDeviceName field.
        //
        FixDevModeDeviceName(pIniPrinter->pName,
                             pIniPrinter->pDevMode,
                             pIniPrinter->cbDevMode);
    }
    return bReturn;
}

BOOL
NameAndSecurityCheck(
    LPCWSTR   pServer
    )
{
   PINISPOOLER pIniSpooler;
   BOOL bReturn = TRUE;

   pIniSpooler = FindSpoolerByNameIncRef( (LPWSTR)pServer, NULL );

   if( !pIniSpooler ){
       return ROUTER_UNKNOWN;
   }
   // Check if the call is for the local machine.
   if ( pServer && *pServer ) {
       if ( !MyName((LPWSTR) pServer, pIniSpooler )) {
           bReturn = FALSE;
           goto CleanUp;
       }
   }

   // Check for admin priviledges.
   if ( !ValidateObjectAccess( SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {
      bReturn = FALSE;
   }

CleanUp:
   // The Local case is handled in the router.
    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}

BOOL
LocalAddPerMachineConnection(
    LPCWSTR   pServer,
    LPCWSTR   pPrinterName,
    LPCWSTR   pPrintServer,
    LPCWSTR   pProvider
    )
{
   return NameAndSecurityCheck(pServer);
}

BOOL
LocalDeletePerMachineConnection(
    LPCWSTR   pServer,
    LPCWSTR   pPrinterName
    )
{
   return NameAndSecurityCheck(pServer);
}

BOOL
LocalEnumPerMachineConnections(
    LPCWSTR   pServer,
    LPBYTE    pPrinterEnum,
    DWORD     cbBuf,
    LPDWORD   pcbNeeded,
    LPDWORD   pcReturned
    )
{
   SetLastError(ERROR_INVALID_NAME);







   return FALSE;
}


BOOL
UpdatePrinterNetworkName(
    PINIPRINTER pIniPrinter,
    LPWSTR pszPorts
    )
{
    PINISPOOLER pIniSpooler = pIniPrinter->pIniSpooler;
    DWORD   dwLastError = ERROR_SUCCESS;
    LPWSTR  pKeyName = NULL;
    HANDLE  hToken;
    BOOL    bReturnValue;
    HANDLE  hPrinterKey = NULL;
    HANDLE  hPrinterHttpDataKey = NULL;


    SplInSem();

    hToken = RevertToPrinterSelf();

    if ( hToken == FALSE ) {

        DBGMSG( DBG_TRACE, ("UpdatePrinterIni failed RevertToPrinterSelf %x\n", GetLastError() ));
    }

    if (!(pKeyName = SubChar(pIniPrinter->pName, L'\\', L','))) {
        dwLastError = GetLastError();
        goto Cleanup;
    }

    if ( !PrinterCreateKey( pIniSpooler->hckPrinters,
                            pKeyName,
                            &hPrinterKey,
                            &dwLastError,
                            pIniSpooler )) {

        goto Cleanup;
    }

    if ( !PrinterCreateKey( hPrinterKey,
                            L"HttpData",
                            &hPrinterHttpDataKey,
                            &dwLastError,
                            pIniSpooler )) {

        goto Cleanup;
    }

    RegSetString( hPrinterHttpDataKey, L"UIRealNetworkName", pszPorts, &dwLastError, pIniSpooler );


Cleanup:

    FreeSplStr(pKeyName);

    if ( hPrinterHttpDataKey )
        SplRegCloseKey( hPrinterHttpDataKey, pIniSpooler);

    if ( hPrinterKey )
        SplRegCloseKey( hPrinterKey, pIniSpooler);

    if ( hToken )
        ImpersonatePrinterClient( hToken );


    if ( dwLastError != ERROR_SUCCESS ) {

        SetLastError( dwLastError );
        bReturnValue = FALSE;

    } else {

        bReturnValue = TRUE;
    }

    return bReturnValue;

}

DWORD
KMPrintersAreBlocked(
)
{
    return GetDwPolicy(szKMPrintersAreBlocked, DefaultKMPrintersAreBlocked);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\server.c ===
/*++

Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    server.c

Abstract:

    Browsing

    This module contains the thread for notifying all Printer Servers

Author:

    Dave Snipp (DaveSn) 2-Aug-1992

Revision History:

--*/

#include <precomp.h>
#include <lm.h>

DWORD   ServerThreadRunning = FALSE;
HANDLE  ServerThreadSemaphore = NULL;
DWORD   ServerThreadTimeout = TEN_MINUTES;
DWORD   RefreshTimesPerDecayPeriod = DEFAULT_REFRESH_TIMES_PER_DECAY_PERIOD;
DWORD   BrowsePrintWorkstations = DEFAULT_NUMBER_BROWSE_WORKSTATIONS;
BOOL    bNetInfoReady = FALSE;            // TRUE when the browse list is "valid"
#define NT_SERVER   ( SV_TYPE_SERVER_NT | SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL )

extern FARPROC pfnNetServerEnum;
extern FARPROC pfnNetApiBufferFree;

DWORD
ServerThread(
    PVOID
    );

BOOL
UpdateServer(
    LPCTSTR pszServer
    );


BOOL
CreateServerThread(
    VOID
    )
{
    HANDLE  ThreadHandle;
    DWORD   ThreadId;

    SplInSem();

    if (!ServerThreadRunning) {

        ServerThreadSemaphore = CreateEvent( NULL, FALSE, FALSE, NULL );

        ThreadHandle = CreateThread( NULL, INITIAL_STACK_COMMIT,
                                     (LPTHREAD_START_ROUTINE)ServerThread,
                                     NULL,
                                     0, &ThreadId );

        if (!SetThreadPriority(ThreadHandle,
                               dwServerThreadPriority))
            DBGMSG(DBG_WARNING, ("Setting thread priority failed %d\n",
                     GetLastError()));

        ServerThreadRunning = TRUE;

        CloseHandle( ThreadHandle );
    }

    if( ServerThreadSemaphore != NULL ){

        // CreateServerThread is called each time a printer is shared out
        // see net.c ShareThisPrinter.
        // So if the ServerThread is sleeping wake prematurely so it can start
        // to tell the world about this new shared printed.

        SetEvent( ServerThreadSemaphore );

    }

    return TRUE;
}


DWORD
ServerThread(
    PVOID pv
    )

/*++

Routine Description:

    Notify other machines in our domain about our shared printers.

    We are going to have to enter and leave, revalidate, enter and leave our
    semaphore inside the loop.

Arguments:

Return Value:

--*/

{
    DWORD   NoReturned, i, Total;
    PSERVER_INFO_101 pserver_info_101;
    PINIPRINTER pIniPrinter;
    PINISPOOLER pIniSpooler;
    DWORD   ReturnValue=FALSE;
    WCHAR   ServerName[128];
    DWORD   StartTickCount;
    DWORD   TimeForAllServers;
    DWORD   dwActualWaitTime = ServerThreadTimeout;
    UINT    cPrintWorkstations;
    UINT    cPrintServers;
    UINT    cServersToInform;
    UINT    cWorkStationsToInform;

    ServerName[0] = ServerName[1] = '\\';

    while (TRUE) {

       SplOutSem();

        DBGMSG( DBG_TRACE, ("ServerThread sleeping for %d\n", dwActualWaitTime));

        WaitForSingleObject( ServerThreadSemaphore, dwActualWaitTime );

        // Wait for a couple of minutes more to avoid the boot time crunch
        Sleep(TWO_MINUTES);

        if ( !ServerThreadRunning ) {

            return FALSE;
        }

        SPLASSERT( pfnNetServerEnum != NULL );

        if (!(*pfnNetServerEnum)(NULL, 101, (LPBYTE *)&pserver_info_101, -1,
                                 &NoReturned, &Total, SV_TYPE_PRINTQ_SERVER,
                                 NULL, NULL)) {
            EnterSplSem();

            StartTickCount = GetTickCount();

            //
            //  1 Master + 3 Backup + 1 Backup per 32 Printer Servers.
            //

            cServersToInform      = DEFAULT_NUMBER_MASTER_AND_BACKUP + NoReturned/32 ;
            cWorkStationsToInform = BrowsePrintWorkstations;

            //
            //  Count the NT Server and Workstation machines ( which have a printq )
            //

            for (   i = 0, cPrintServers = 0, cPrintWorkstations = 0;
                    i < NoReturned;
                    i++ ) {

                if ( pserver_info_101[i].sv101_type & NT_SERVER ) {

                    cPrintServers++;

                } else if ( pserver_info_101[i].sv101_type & SV_TYPE_NT ) {

                    cPrintWorkstations++;
                }
            }

            //
            //  If there are no NT Servers to inform then up the number of Workstations
            //

            if ( cPrintServers == 0 ) {

                cWorkStationsToInform = max( cWorkStationsToInform, cServersToInform );
                cServersToInform = 0;

            } else if ( cPrintServers < cServersToInform ) {

                cWorkStationsToInform = max( cWorkStationsToInform, cServersToInform - cPrintServers );
            }


            DBGMSG( DBG_TRACE, ("ServerThread NetServerEnum returned %d printer servers will inform %d, workstations %d\n", NoReturned, cServersToInform, cWorkStationsToInform ));

            //
            //  Loop Until we have informed the correct Number of WorkStations and Servers
            //

            for (   i = 0,
                    cPrintServers = 0,
                    cPrintWorkstations = 0;

                        i < NoReturned &&
                        ( cPrintServers < cServersToInform || cPrintWorkstations < cWorkStationsToInform );

                            i++ ) {

                DBGMSG( DBG_TRACE, ("ServerThread  Loop Count %d cPrintServer %d cServersToInform %d cPrintWorkstations %d cWorkStationsToInform %d\n",
                                     i, cPrintServers, cServersToInform,  cPrintWorkstations, cWorkStationsToInform ));


                DBGMSG( DBG_TRACE, ("ServerThread %ws type %x\n",pserver_info_101[i].sv101_name, pserver_info_101[i].sv101_type ));

                if (( pserver_info_101[i].sv101_type & NT_SERVER ) ||
                    ( pserver_info_101[i].sv101_type & SV_TYPE_NT && cPrintWorkstations < cWorkStationsToInform )) {

                    wcscpy(&ServerName[2], pserver_info_101[i].sv101_name);

                    if( UpdateServer( ServerName )){

                        // Servers are also counted as WorkStations

                        cPrintWorkstations++;

                        if ( pserver_info_101[i].sv101_type & NT_SERVER ) {

                            cPrintServers++;
                        }
                    }
                }
            }

            TimeForAllServers = GetTickCount() - StartTickCount;

            DBGMSG( DBG_TRACE, ("ServerThread took %d milliseconds for %d Workstations %d Servers\n",
                                TimeForAllServers, cPrintWorkstations, cPrintServers ));

            //
            // Calculate time to wait before we try again.
            //

            if ( NetPrinterDecayPeriod > TimeForAllServers ) {

                dwActualWaitTime = max( ServerThreadTimeout, ( NetPrinterDecayPeriod - TimeForAllServers ) / RefreshTimesPerDecayPeriod );

            } else {

                dwActualWaitTime = ServerThreadTimeout;
            }

            //
            //  Remove WAS Shared Bits
            //

            //
            // Do this for all spoolers.
            //
            for( pIniSpooler = pLocalIniSpooler;
                 pIniSpooler;
                 pIniSpooler = pIniSpooler->pIniNextSpooler ){

                for ( pIniPrinter = pIniSpooler->pIniPrinter;
                      pIniPrinter != NULL;
                      pIniPrinter = pIniPrinter->pNext ) {

                     SplInSem();
                     pIniPrinter->Status &= ~PRINTER_WAS_SHARED;
                }
            }

            LeaveSplSem();

            (*pfnNetApiBufferFree)((LPVOID)pserver_info_101);
        }
    }
    return FALSE;
}

typedef struct _UPDATE_SERVER_MAP_DATA {
    LPCWSTR pszServer;
    BOOL bSuccessfulAdd;
} UPDATE_SERVER_MAP_DATA, *PUPDATE_SERVER_MAP_DATA;

BOOL
UpdateServerPrinterMap(
    HANDLE h,
    PINIPRINTER pIniPrinter
    )

/*++

Routine Description:

    Update the a browser server with one pIniPrinter.

    Leaves Spooler Section--pIniPrinter may be invalid on return
    unless explicitly refcounted by callee.

Arguments:

    pIniPrinter - Printer that should be sent to the server.

    pszServer - Server that needs to be updated.

    pbSuccessfulAdd - Indicates whether the add was successful.

Return Value:

    Succes or failure?

--*/

{
    PUPDATE_SERVER_MAP_DATA pData = (PUPDATE_SERVER_MAP_DATA)h;

    WCHAR   string[MAX_PRINTER_BROWSE_NAME];
    WCHAR   Name[MAX_UNC_PRINTER_NAME];
    PRINTER_INFO_1  Printer1;
    HANDLE  hPrinter;
    PINISPOOLER pIniSpooler;
    DWORD dwLastError;

    Printer1.Flags = 0;

    if (( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED ) ||
        ( pIniPrinter->Status & PRINTER_WAS_SHARED )) {

        //
        // Pass our Printer Attributes so that AddNetPrinter can remove
        // this printer from the browse list if it is not shared.
        //

        Printer1.Flags = pIniPrinter->Attributes | PRINTER_ATTRIBUTE_NETWORK;

        wsprintf(string, L"%ws\\%ws,%ws,%ws",
                         pIniPrinter->pIniSpooler->pMachineName,
                         pIniPrinter->pName,
                         pIniPrinter->pIniDriver->pName,
                         pIniPrinter->pLocation ?
                             pIniPrinter->pLocation :
                             L"");

        Printer1.pDescription = string;

        wsprintf(Name, L"%ws\\%ws", pIniPrinter->pIniSpooler->pMachineName,
                       pIniPrinter->pName);

        Printer1.pName = Name;

        Printer1.pComment = AllocSplStr(pIniPrinter->pComment);

        SplInSem();

        LeaveSplSem();

        //
        // Keep trying until the server is not Too Busy.
        //

        for ( hPrinter = NULL;
              hPrinter == NULL;
              Sleep( GetTickCount() & 0xfff ) ) {

            hPrinter = AddPrinter( (LPTSTR)pData->pszServer, 1, (LPBYTE)&Printer1 );

            dwLastError = GetLastError();

            if ( hPrinter == NULL && dwLastError != RPC_S_SERVER_TOO_BUSY ) {

                if ( dwLastError != ERROR_PRINTER_ALREADY_EXISTS ) {

                    pData->bSuccessfulAdd = FALSE;
                }

                break;
            }
        }


        FreeSplStr(Printer1.pComment);

        if ( hPrinter != NULL ) {

            DBGMSG( DBG_TRACE,
                    ( "ServerThread AddPrinter(%ws, %ws) hPrinter %x Flags %x OK\n",
                      pData->pszServer, Printer1.pName, hPrinter, Printer1.Flags));

            ClosePrinter( hPrinter );
        }

        EnterSplSem();

        if ( hPrinter == NULL ) {


            if ( GetLastError() != ERROR_PRINTER_ALREADY_EXISTS ) {

                DBGMSG( DBG_TRACE,
                        ( "ServerThread AddPrinter(%ws, 1) Flags %x failed %d\n",
                          pData->pszServer, Printer1.Flags, GetLastError()));

                // Don't bother with this server if we get an error
                return FALSE;

            } else {

                //
                // 3.51 will return a NULL handle ( so it doesn't need closing
                // and ERROR_PRINTER_ALREADY_EXISTS on success ( see printer.c addnetprinter )
                //
                DBGMSG( DBG_TRACE,
                        ( "pszServerThread AddPrinter(%ws, %ws) hPrinter %x Flags %x OK\n",
                          pData->pszServer, Printer1.pName, hPrinter, Printer1.Flags));
            }
        }
    }

    return TRUE;
}

BOOL
UpdateServerSpoolerMap(
    HANDLE h,
    PINISPOOLER pIniSpooler
    )
{
    //
    // Do this only for spoolers that want this "feature."
    //
    if( pIniSpooler->SpoolerFlags & SPL_SERVER_THREAD ){
        RunForEachPrinter( pIniSpooler, h, UpdateServerPrinterMap );
    }
    return TRUE;
}

BOOL
UpdateServer(
    LPCTSTR pszServer
    )

/*++

Routine Description:

    Update a server about all the printers on this node.

Arguments:

    pszServer - Server to update in the form "\\server."

Return Value:

    TRUE - Successfully added.
    FALSE - Not.

--*/

{
    UPDATE_SERVER_MAP_DATA Data;
    Data.bSuccessfulAdd = TRUE;
    Data.pszServer = pszServer;

    RunForEachSpooler( &Data, UpdateServerSpoolerMap );

    return Data.bSuccessfulAdd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\separate.c ===
/********************************************************************/
/**                Microsoft NT printing - separator pages         **/
/********************************************************************/

#include <precomp.h>
#pragma hdrstop

#define _CTYPE_DISABLE_MACROS
#include <wingdip.h>
#include <winbasep.h>


/* this is max. no. of chars to be printed on a line */
/* these numbers must be taken from somewhere else */
#define MAXLINE      256
#define DEFAULT_LINE_WIDTH 80

#define BLOCK_CHAR_HEIGHT 16
#define BLOCK_CHAR_WIDTH  8
#define BLOCK_CHAR_DWIDTH 16

#define NORMAL_MODE  'U'
#define BLOCK_START  'B'
#define SINGLE_WIDTH 'S'
#define DOUBLE_WIDTH 'M'
#define TEXT_MODE    'L'
#define WIDTH_CHANGE 'W'
#define END_PAGE     'E'
#define FILE_INSERT  'F'
#define USER_NAME    'N'
#define JOB_ID       'I'
#define DATE_INSERT  'D'
#define TIME_INSERT  'T'
#define HEX_CODE     'H'

/* global structure (instance data) */
typedef struct {
   PSPOOL pSpool;
   HANDLE hFile;
   HANDLE hFileMapping;
   DWORD dwFileCount;
   DWORD dwFileSizeLo;
   DWORD cbOutBufLength;
   DWORD cbLineLength;
   DWORD linewidth;
   char  *OutBuf;
   char  *pOutBufPos;
   char  *pNextFileChar;
   char  *pFileStart;
   char  mode;
   char  cEsc;
   char    cLastChar; // Used to store DBCS lead byte.
   HDC     hDCMem;    // Used to create Kanji banner char.
   HFONT   hFont;     // Used to create Kanji banner char.
   HBITMAP hBitmap;   // Used to create Kanji banner char.
   PVOID   pvBits;    // Used to create Kanji nanner char.
} GLOBAL_SEP_DATA;

/* static variables */
static char *szDefaultSep = "@@B@S@N@4 @B@S@I@4  @U@L   @D@1 @E";
static char *sznewline = "\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n";
static LPWSTR szDefaultSepName = L"DEFAULT.SEP";

/* Forward declarations */
int OpenSepFile(GLOBAL_SEP_DATA *, LPWSTR);
int CloseSepFile(GLOBAL_SEP_DATA *);
int ReadSepChar(GLOBAL_SEP_DATA *);
void UngetSepChar(GLOBAL_SEP_DATA *, int);
int WriteSepBuf(GLOBAL_SEP_DATA *, char *, DWORD);
int DoSeparatorPage(GLOBAL_SEP_DATA *);
int AddNormalChar(GLOBAL_SEP_DATA *, int);
int AddBlockChar(GLOBAL_SEP_DATA *, int);
int FlushOutBuf(GLOBAL_SEP_DATA *);
int FlushNewLine(GLOBAL_SEP_DATA *);
void ReadFileName(GLOBAL_SEP_DATA *, char *, DWORD);
int ConvertAtoH(int);
void ConvertTimetoChar(LPSYSTEMTIME,char *);
void ConvertDatetoChar(LPSYSTEMTIME,char *);

/**************************************************************\
** DoSeparator(pSpool)
**   This function is called by the spooler.  It is the
**   entry point for the separator page code.  It opens the
**   separator page file, processes it, sends the output
**   directly to the printer, and then returns control
**   to the spooler.
**
**   RETURN VALUE: 1 = OK, 0 = error
\**************************************************************/
int DoSeparator(
   PSPOOL pSpool
   )

{
   GLOBAL_SEP_DATA g;
   int status;

   g.pSpool = pSpool;

   if (!OpenSepFile(&g, pSpool->pIniJob->pIniPrinter->pSepFile)) {
      return(0);
   }
   //
   // We used to call OpenProfileUserMapping() and CloseProfileUserMapping()
   // before and after DoSeparatorPage. But they are not multi thread safe
   // and are not needed now that we use SystemTimeToTzSpecificLocalTime
   // instead of GetProfileInt etc..
   //
   status = DoSeparatorPage(&g);
   CloseSepFile(&g);

   if (!status) {
      return(0);
   }
   return(1);
}


/**************************************************************\
** OpenSepFile(pg, szFileName)
**   open file for input.
**   at the moment, this does nothing--stdin and stdout are used
\**************************************************************/
int OpenSepFile(
   GLOBAL_SEP_DATA *pg,
   LPWSTR szFileName
   )
{
   if (!lstrcmpi(szFileName, szDefaultSepName)) {
      /* if szFileName is empty, just use default separator page string */
      pg->hFile = NULL;
      pg->hFileMapping = NULL;
      pg->pFileStart = pg->pNextFileChar = szDefaultSep;
      pg->dwFileSizeLo = strlen(szDefaultSep);
   }
   else {
      HANDLE hImpersonationToken = RevertToPrinterSelf();

      /* otherwise, open the file */
      pg->hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ,
                         NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

      ImpersonatePrinterClient(hImpersonationToken);

      if (pg->hFile==INVALID_HANDLE_VALUE) {
         return(0);
      }
      pg->dwFileSizeLo = GetFileSize(pg->hFile, NULL); /* assume < 4 GB! */
      pg->hFileMapping = CreateFileMapping(pg->hFile, NULL,
                                     PAGE_READONLY, 0, 0, NULL);
      if (!pg->hFileMapping || pg->dwFileSizeLo==-1) {
         CloseSepFile(pg);
         return(0);
      }
      pg->pFileStart =
      pg->pNextFileChar = (char *)
              MapViewOfFile(pg->hFileMapping, FILE_MAP_READ,
                            0, 0, pg->dwFileSizeLo);
      if (!pg->pFileStart) {
         CloseSepFile(pg);
         return(0);
      }
   } /* end of else (szFileName non-NULL) */

   pg->dwFileCount = 0;

   /* now, allocate local buffer for output */
   pg->OutBuf = (char *)AllocSplMem( BLOCK_CHAR_HEIGHT*(MAXLINE+2) );
   if (!pg->OutBuf) {
      CloseSepFile(pg);
      return(0);
   }
   return(1);
}


/**************************************************************\
** CloseSepFile(pg)
**   close files.
\**************************************************************/
int CloseSepFile(GLOBAL_SEP_DATA *pg)
{
   if (pg->OutBuf) {
      FreeSplMem(pg->OutBuf);
   }
   if (pg->hFileMapping) {
      if (pg->pFileStart) {
         UnmapViewOfFile(pg->pFileStart);
      }
      CloseHandle(pg->hFileMapping);
   }
   if (pg->hFile) {
      CloseHandle(pg->hFile);
   }
   return(1);
}


/**************************************************************\
** ReadSepChar(pg)
**   reads a character from the separator file and returns it
\**************************************************************/
int ReadSepChar(GLOBAL_SEP_DATA *pg)
{
   if (pg->dwFileCount >= pg->dwFileSizeLo) {
      return(EOF);
   }
   pg->dwFileCount++;
   return(*pg->pNextFileChar++);
}


/**************************************************************\
** UngetSepChar(pg, c)
**   ungets a character to the separator file
\**************************************************************/
void UngetSepChar(
   GLOBAL_SEP_DATA *pg,
   int c
   )
{
   if (c != EOF && pg->dwFileCount) {
      pg->dwFileCount--;
      pg->pNextFileChar--;
   }
}

/**************************************************************\
** WriteSepBuf(pg, str, cb)
**   write cb bytes of a string to the printer
\**************************************************************/
int WriteSepBuf(
   GLOBAL_SEP_DATA *pg,
   char *str,
   DWORD cb
   )
{
   DWORD cbWritten;

   return(LocalWritePrinter(pg->pSpool, str, cb, &cbWritten)
          && (cbWritten==cb)
         );

#ifdef ALIP
   if (str[cb]) {
      char temp[3000];
      strncpy(temp, str, cb);
      temp[cb]=0;
      return(!fputs(temp,stdout));
   }
   return(!fputs(str,stdout));
#endif
}


/**************************************************************\
** FlushOutBuf(pg)
**   flush the output buffer (block or line mode)
**   WHAT'S TRICKY HERE IS THAT IF WE'RE IN LINE MODE, WE SIMPLY
**   WRITE THE STUFF TO THE FILE, WHEREAS IF WE'RE IN BLOCK
**   CHARACTER MODE, WE FORCE CARRIAGE-RETURN / LINEFEEDS ON
**   EACH OF THE EIGHT BUFFERED LINES THAT MAKE UP THE BLOCK
**   CHARACTERS; i.e., FlushOutBuf() SERVES AS AN EOL IN BLOCK
**   MODE, BUT NOT IN LINE MODE.
**
**   - return TRUE means ok
**   - return FALSE means problem
\**************************************************************/
int FlushOutBuf(GLOBAL_SEP_DATA *pg)
{
   int i,status = TRUE;
   char *pBlkLine;

   if (!pg->cbOutBufLength) {
      return(TRUE);
   }
   if (pg->mode == NORMAL_MODE) {
      /* write out entire buffer at once */
      status = WriteSepBuf(pg, pg->OutBuf, pg->cbOutBufLength);
   }
   else {
      /* BLOCK MODE:
       * force carriage-return and linefeed on all eight lines
       */
      pBlkLine = pg->OutBuf;
      for (i=0; (i < BLOCK_CHAR_HEIGHT) && status; i++) {
         *pg->pOutBufPos     = '\r';
         *(pg->pOutBufPos+1) = '\n';
         status = WriteSepBuf(pg, pBlkLine, pg->cbLineLength+2);
         pg->pOutBufPos += MAXLINE+2;
         pBlkLine   += MAXLINE+2;
      }
      pg->cbLineLength = 0;
   }

   pg->pOutBufPos = pg->OutBuf;
   pg->cbOutBufLength = 0;
   return(status);
}


/**************************************************************\
** FlushNewLine(pg)
**   Starts a new line: if BLOCK MODE, just do FlushOutBuf();
**   if not, send a '\r' '\n' combination, then flush.
**   - return TRUE means ok
**   - return FALSE means problem
\**************************************************************/
int FlushNewLine(GLOBAL_SEP_DATA *pg)
{
   if (pg->mode==NORMAL_MODE && pg->cbLineLength) {
      if (!AddNormalChar(pg,'\r')) return(FALSE);
      if (!AddNormalChar(pg,'\n')) return(FALSE);
   }
   return(FlushOutBuf(pg));
}


/**************************************************************\
** AddNormalChar(pg, c)
**   add a character to the output buffer (not block mode)
**   - return TRUE means ok
**   - return FALSE means problem
\**************************************************************/
int AddNormalChar(
   GLOBAL_SEP_DATA *pg,
   int c
   )
{
   if (c=='\n') {
      /* reset line length count */
      pg->cbLineLength = 0;
   }
   else {
      if (isprint(c) && (++(pg->cbLineLength) > pg->linewidth)) {
         return(TRUE);
      }
   }

   *pg->pOutBufPos++ = (CHAR) c;
   if (++(pg->cbOutBufLength) == BLOCK_CHAR_HEIGHT*(MAXLINE+2)) {
      return(FlushOutBuf(pg));
   }

   return(TRUE);

} /* end of AddNormalChar() */


/**************************************************************\
** AddBlockChar(pg, c)
**   add a character to the output buffer (block mode)
**   return TRUE means ok
**   return FALSE means problem
\**************************************************************/
int AddBlockChar(
   GLOBAL_SEP_DATA *pg,
   int c
   )
{
   int w;
   register int i,k;
   register char *p;
   unsigned char cBits, *pcBits;
   char cBlkFill;
   register int j;
   unsigned char *pcBitsLine;
   HBITMAP hBitmapOld;
   HFONT   hFontOld;
   CHAR    aTextBuf[2];
   SHORT   sTextIndex = 0;
   ULONG   cjBitmap;
   ULONG   cjWidth = BLOCK_CHAR_WIDTH;

#define CJ_DIB16_SCAN(cx) ((((cx) + 15) & ~15) >> 3)
#define CJ_DIB16( cx, cy ) (CJ_DIB16_SCAN(cx) * (cy))

   if( pg->cLastChar == (CHAR)NULL && IsDBCSLeadByte((CHAR)c) ) {
       pg->cLastChar = (CHAR) c;
       return(TRUE);
   }

   if(pg->hDCMem == NULL) {
       pg->hDCMem = CreateCompatibleDC(NULL);
       if (pg->hDCMem == NULL)
       {
           //
           // Only happens when memory is exhausted. Functionality may suffer
           // but we won't AV.
           //
           return FALSE;
       }
   }

   if(pg->hBitmap == NULL) {
       pg->hBitmap = CreateCompatibleBitmap(pg->hDCMem,BLOCK_CHAR_DWIDTH,BLOCK_CHAR_HEIGHT);
       if ( pg->hBitmap == NULL )
       {
           //
           // Only happens when memory is exhausted. Functionality may suffer
           // but we won't AV.
           //
           return FALSE;
       }
   }

   if(pg->pvBits == NULL) {
       pg->pvBits = AllocSplMem(CJ_DIB16(BLOCK_CHAR_DWIDTH,BLOCK_CHAR_HEIGHT));
       if ( pg->pvBits == NULL )
       {
           //
           // Only happens when memory is exhausted. Functionality may suffer
           // but we won't AV.
           //
           return FALSE;
       }
   }

   if(pg->hFont == NULL) {
       LOGFONT lf;

       RtlZeroMemory(&lf,sizeof(LOGFONT));

       lf.lfHeight = BLOCK_CHAR_HEIGHT;
       lf.lfWidth  = ( pg->mode == DOUBLE_WIDTH ) ?
                          BLOCK_CHAR_DWIDTH :
                          BLOCK_CHAR_WIDTH;

       lf.lfWeight = FW_NORMAL;
       lf.lfPitchAndFamily = FIXED_PITCH | FF_MODERN;
       lf.lfCharSet = DEFAULT_CHARSET;

       pg->hFont = CreateFontIndirect(&lf);
   }

   hBitmapOld = SelectObject(pg->hDCMem,pg->hBitmap);
   hFontOld   = SelectObject(pg->hDCMem,pg->hFont);

   if( pg->cLastChar != (CHAR) NULL ) {
       aTextBuf[sTextIndex] = pg->cLastChar;
       sTextIndex ++;
       cjWidth = BLOCK_CHAR_DWIDTH;
   }

   aTextBuf[sTextIndex] = (CHAR) c;

   PatBlt(pg->hDCMem,0,0,BLOCK_CHAR_DWIDTH,BLOCK_CHAR_HEIGHT,WHITENESS);
   TextOutA(pg->hDCMem,0,0,aTextBuf,sTextIndex+1);

   GetBitmapBits(pg->hBitmap,CJ_DIB16(cjWidth,BLOCK_CHAR_HEIGHT),pg->pvBits);

   SelectObject(pg->hDCMem,hBitmapOld);
   SelectObject(pg->hDCMem,hFontOld);

   w = (pg->mode==DOUBLE_WIDTH)? cjWidth * 2 : cjWidth;
   if (pg->cbLineLength+w > pg->linewidth) {
      return(TRUE);
   }

   cBlkFill = '#';

   pcBitsLine = (unsigned char *) pg->pvBits;
   for (i = 0 ;
        i < BLOCK_CHAR_HEIGHT;
        i++, pcBitsLine += CJ_DIB16_SCAN(BLOCK_CHAR_DWIDTH)) {

      /* put block character into buffer line by line, top first */

      pcBits = pcBitsLine;

      p = pg->pOutBufPos + i * (MAXLINE+2);

      cBits = *pcBits;
      j = 0;
      for (k = cjWidth; k--; ) {
         if (pg->mode==DOUBLE_WIDTH) {
             *p = *(p+1) = (cBits & 0x80)? ' ' : cBlkFill;
             p += 2;
         } else {
             *p++ = (cBits & 0x80)? ' ' : cBlkFill;
         }
         cBits <<= 1;
         j++;
         if( j==8 ) {
             pcBits++; cBits = *pcBits; j = 0;
         }
      }

   } /* end of loop through lines of block char */

   pg->cLastChar = (CHAR) NULL;
   pg->pOutBufPos += w;
   pg->cbLineLength += w;
   pg->cbOutBufLength += w;
   return(TRUE);

} /* end of AddBlockChar() */


/**************************************************************\
** DoSeparatorPage(pg)
**   this is the actual processing
\**************************************************************/
int DoSeparatorPage(GLOBAL_SEP_DATA *pg)
{
   int status = TRUE;
   int c;
   char *pchar;
   WCHAR *pwchar;
   char tempbuf[MAX_PATH]; /* assume length of date, time, or job_id < MAXPATH */
   int (*AddCharFxn)() = AddNormalChar;

   if ((c = ReadSepChar(pg))==EOF) {
      return(TRUE);
   }
   pg->linewidth = DEFAULT_LINE_WIDTH;
   pg->cEsc = (CHAR) c;
   pg->pOutBufPos = pg->OutBuf;
   pg->cbOutBufLength = 0;
   pg->cbLineLength = 0;
   pg->mode = NORMAL_MODE;
   pg->hDCMem = (HDC) NULL;
   pg->hFont = (HFONT) NULL;
   pg->hBitmap = (HBITMAP) NULL;
   pg->cLastChar = (CHAR) NULL;
   pg->pvBits = (PVOID) NULL;

   while (status && ((c=ReadSepChar(pg))!=EOF) ) {

      /* find the next escape sequence */
      if (c != pg->cEsc) continue;

      /* found an escape character: now, check the next character */
      if ((c=ReadSepChar(pg))==EOF) {
         break;
      }

      switch (c) {
      case TEXT_MODE:
         if (pg->mode==NORMAL_MODE) {
            while (status && ((c=ReadSepChar(pg)) != EOF)) {
               if (c!=pg->cEsc) {
                  status = AddNormalChar(pg, c);
               }
               else {
                  /* This is to treat <esc><esc> as a normal char */
                  c = ReadSepChar(pg);
                  if (c==pg->cEsc) {
                     status = AddNormalChar(pg, c);
                  }
                  else {
                     UngetSepChar(pg, c);
                     UngetSepChar(pg, pg->cEsc);
                     break; /* breaks from the while, returns to main loop */
                  }
               }
            }
         } /* end of NORMAL_MODE processing */

         else {
            while (status && ((c=ReadSepChar(pg))!=EOF)) {
               if (c=='\n') {
                  status = FlushOutBuf(pg);
               }
               else if (c=='\r') {
                  /* if followed by '\n', ignore.
                   * Otherwise, AddBlockChar() the '\r'.
                   */
                  c = ReadSepChar(pg);
                  if (c!='\n') {
                     status = AddBlockChar(pg, '\r');
                  }
                  UngetSepChar(pg, c);
               }
               else {
                  if (c==pg->cEsc) {
                     /* This is to treat <esc><esc> as a normal char */
                     c = ReadSepChar(pg);
                     if (c==pg->cEsc) {
                        status = AddBlockChar(pg, c);
                     }
                     else {
                        UngetSepChar(pg, c);
                        UngetSepChar(pg, pg->cEsc);
                        break; /* breaks from the while, returns to main loop */
                     }
                  }
                  else {
                     status = AddBlockChar(pg, c);
                  }
               }
            }
         } /* end of BLOCK mode processing */

         break;

      case BLOCK_START:
      case SINGLE_WIDTH:
      case DOUBLE_WIDTH:
      case NORMAL_MODE:
         status = FlushNewLine(pg);
         pg->mode = (CHAR) c;
         AddCharFxn = (pg->mode==NORMAL_MODE)? AddNormalChar : AddBlockChar;
         break;

      case USER_NAME:
         pwchar = pg->pSpool->pIniJob->pUser;

         if (pwchar) {
             char *pchar;
             UNICODE_STRING UnicodeString;
             ANSI_STRING    AnsiString;

             RtlInitUnicodeString(&UnicodeString,pwchar);
             RtlUnicodeStringToAnsiString(&AnsiString,&UnicodeString,TRUE);

             pchar = AnsiString.Buffer;

             if ( pchar )
             {
                 while (*pchar && status) status = (*AddCharFxn)(pg, *pchar++);
             }

             RtlFreeAnsiString(&AnsiString);
         }
         break;

      case DATE_INSERT:
         ConvertDatetoChar(&pg->pSpool->pIniJob->Submitted, tempbuf);
         pchar = tempbuf;
         while (*pchar && status) status = (*AddCharFxn)(pg, *pchar++);
         break;

      case TIME_INSERT:
         ConvertTimetoChar(&pg->pSpool->pIniJob->Submitted, tempbuf);
         pchar = tempbuf;
         while (*pchar && status) status = (*AddCharFxn)(pg, *pchar++);
         break;

      case JOB_ID:
         _itoa(pg->pSpool->pIniJob->JobId, tempbuf, 10);
         pchar = tempbuf;
         while (*pchar && status) status = (*AddCharFxn)(pg, *pchar++);
         break;

      case HEX_CODE:
         /* print a control character--read the hexadecimal code */

         c = ReadSepChar(pg);
         if (isxdigit(c)) {
            int c2 = ReadSepChar(pg);
            if (isxdigit(c2)) {
               c = (char)((ConvertAtoH(c) << 4) + ConvertAtoH(c2));
               status = (*AddCharFxn)(pg, c);
            }
            else {
               UngetSepChar(pg, c2);
               /* perhaps shouldn't do this? If they say @Hxx,
                * implying xx is a hexadecimal code, and the second
                * x is not a hex digit, should we leave that char
                * on the input line to be interpreted next, or should
                * we skip it?  This only matters if it was an escape char,
                * i.e. @Hx@....  Right now, the second @ is considered
                * the start of a new command, and the @Hx is ignored
                * entirely.  The same applies for the UngetSepChar() below.
                */
            }
         }
         else {
            UngetSepChar(pg, c);
         }
         break;

      case WIDTH_CHANGE:
         {
         /* read the decimal number; change line width if reasonable */
         int new_width = 0;

         for (c = ReadSepChar(pg); isdigit(c); c = ReadSepChar(pg)) {
            new_width = 10 * new_width + c - '0';
         }
         UngetSepChar(pg, c);

         if (new_width <= MAXLINE) {
            pg->linewidth = new_width;
         }
         else {
            pg->linewidth = MAXLINE;
         }

         break;
         }

      case '9':
      case '8':
      case '7':
      case '6':
      case '5':
      case '4':
      case '3':
      case '2':
      case '1':
      case '0':
         if (pg->mode==NORMAL_MODE) {
            status = AddNormalChar(pg,'\n');
         }
         if (status) status = FlushOutBuf(pg);
         if (status) status = WriteSepBuf(pg, sznewline, 2*(c-'0'));
         break;

      case END_PAGE:
         /* this just outputs a formfeed character */
         status = FlushNewLine(pg);
         if (status) status = WriteSepBuf(pg, "\f",1);
         break;

      case FILE_INSERT:
         {
         HANDLE hFile2, hMapping2;
         DWORD dwSizeLo2;
         char *pFirstChar;
         HANDLE hImpersonationToken;

         if (!(status = FlushNewLine(pg))) {
            break;
         }
         ReadFileName(pg, tempbuf, sizeof(tempbuf));

         hImpersonationToken = RevertToPrinterSelf();

         hFile2 = CreateFileA(tempbuf, GENERIC_READ, FILE_SHARE_READ,
                      NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

         ImpersonatePrinterClient(hImpersonationToken);

         if (hFile2 != INVALID_HANDLE_VALUE) {
            dwSizeLo2 = GetFileSize(hFile2, NULL); /* assume < 4 gigabytes! */
            hMapping2 = CreateFileMapping(hFile2,NULL,PAGE_READONLY,0,0,NULL);
            if (hMapping2 && (dwSizeLo2 > 0)) {
               pFirstChar = (char *)
                     MapViewOfFile(hMapping2, FILE_MAP_READ, 0, 0, dwSizeLo2);
               if (pFirstChar) {
                  status = WriteSepBuf(pg, pFirstChar, dwSizeLo2);
                  UnmapViewOfFile(pFirstChar);
               }
               CloseHandle(hMapping2);
            }
            CloseHandle(hFile2);
         }

         /* NOTE: if couldn't open file, or error while reading file,
          * status is NOT set to false.  We will simply stop the file
          * insert operation, and continue processing the rest of the
          * the separator page as before.
          */
         else {
            DBGMSG(DBG_WARNING, ("SEPARATOR PAGE: Could not open file %s \n",tempbuf));
         }

         break;
         }


      default:
         break;

      }

   } /* end of main while loop...find next escape sequence, process */

   if (status) status = FlushOutBuf(pg);

   if (pg->hDCMem != (HDC) NULL) DeleteDC(pg->hDCMem);
   if (pg->hFont != (HFONT) NULL) DeleteObject(pg->hFont);
   if (pg->hBitmap != (HBITMAP) NULL) DeleteObject(pg->hBitmap);
   if (pg->pvBits != (PVOID) NULL) FreeSplMem(pg->pvBits);

   return(status);

} /* end of DoSeparatorPage() */


/**************************************************************\
** ConvertAtoH(c)
**   Converts an ASCII character to hexadecimal.
\**************************************************************/
int ConvertAtoH(int c)
{
   return( c - (isdigit(c)? '0' :
                ((isupper(c)? 'A':'a') - 10)));
}


/**************************************************************\
** ConvertTimetoChar()
**   converts system time to a string  (internationalized).
\**************************************************************/
void  ConvertTimetoChar(
   SYSTEMTIME *pSystemTime,
   char *string
   )
{
SYSTEMTIME LocalTime;
LCID lcid;
    // Convert to local time
    SystemTimeToTzSpecificLocalTime(NULL, pSystemTime, &LocalTime);
    // Get lcid of local machine
    lcid=GetSystemDefaultLCID();
    // Convert to string, , using default format for that locale

    GetTimeFormatA(lcid, 0, &LocalTime, NULL, string, MAX_PATH-1);
}

/**************************************************************\
** ConvertDatetoChar()
**   converts system date to a string  (internationalized).
\**************************************************************/
void  ConvertDatetoChar(
   SYSTEMTIME *pSystemTime,
   char *string
   )
{
SYSTEMTIME LocalTime;
LCID lcid;
    // Convert to local time
    SystemTimeToTzSpecificLocalTime(NULL, pSystemTime, &LocalTime);
    // Get lcid of local machine
    lcid = GetSystemDefaultLCID();
    // Convert to string, using default format for that locale
    GetDateFormatA(lcid, 0, &LocalTime, NULL, string, MAX_PATH-1);
}

/**************************************************************\
** ReadFileName(pg, szfilename, dwbufsize)
**   parses a filename from the separator file (following <esc>F).
**   the following scheme is used:
**
**   - read until a single escape, EOF, newline, or carriage return
**     is encountered.  Put this string into a temporary buffer,
**     passed by the calling function.
**
**   - if string begins with a double quote, skip this double quote,
**     and consider the double quote character as an end of string
**     marker, just like the newline.  Thus, @F"myfile
**     will be read as @Fmyfile
**
\**************************************************************/
void ReadFileName(
   GLOBAL_SEP_DATA *pg,
   char *szfilename,
   DWORD dwbufsize
   )
{
   char *pchar = szfilename;
   char c;
   DWORD dwcount = 0;
   BOOL bNotQuote = TRUE;

   if ((pg->dwFileCount < pg->dwFileSizeLo) && (*pg->pNextFileChar=='\"')) {
      pg->dwFileCount++;
      pg->pNextFileChar++;
      bNotQuote = FALSE;
   }
   while ((dwcount < dwbufsize - 1) && (pg->dwFileCount < pg->dwFileSizeLo) && (c=*pg->pNextFileChar)!='\n'
          && c!='\r' && (bNotQuote || c!='\"')) {
      if (c!=pg->cEsc) {
         *pchar++ = c;
         dwcount++;
         pg->pNextFileChar++;
         pg->dwFileCount++;
      }
      else {
         if ((pg->dwFileCount+1) < pg->dwFileSizeLo
               && *(pg->pNextFileChar+1)==pg->cEsc) {
            *pchar++ = pg->cEsc;
            dwcount++;
            pg->pNextFileChar+=2;
            pg->dwFileCount+=2;
         }
         else {
            break;
         }
      }
   } /* end of loop to read characters */

   *pchar = '\0';

} /* end of ReadFileName() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\splmrg.h ===
BOOL LocalMonInit(
    HANDLE hModule
);

LPMONITOR2 LocalMonInitializePrintMonitor2(
    PMONITORINIT pMonitorInit,
    PHANDLE phMonitor
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\sources.inc ===
MAJORCOMP=console
MINORCOMP=localspl

NTPROFILEINPUT=yes

TARGETNAME=localspl
TARGETPATH=$(PROJECT_ROOT)\lib
TARGETTYPE=DYNLINK

LINKLIBS= $(PROJECT_ROOT)\lib\*\winprint.lib \
          $(PROJECT_ROOT)\lib\*\localmon.lib

TARGETLIBS=\
           $(PROJECT_ROOT)\lib\*\spoolss.lib \
           $(WINDOWS_LIB_PATH)\gdi32p.lib \
           $(SDK_LIB_PATH)\kernl32p.lib \
           $(SDK_LIB_PATH)\ole32.lib \
           $(SDK_LIB_PATH)\oleaut32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\user32.lib \
           $(SDK_LIB_PATH)\version.lib \
           $(SDK_LIB_PATH)\oleaut32.lib \
           $(SDK_LIB_PATH)\activeds.lib \
           $(SDK_LIB_PATH)\netapi32.lib \
           $(SDK_LIB_PATH)\adsiid.lib \
           $(SDK_LIB_PATH)\ntdsapi.lib \
           $(SDK_LIB_PATH)\uuid.lib \
           $(SDK_LIB_PATH)\rpcrt4.lib \
           $(SDK_LIB_PATH)\ws2_32.lib \
           $(PROJECT_ROOT)\lib\*\spllib.lib \
           $(SDK_LIB_PATH)\secur32.lib \
           $(BASE_LIB_PATH)\sfc_os.lib \
           $(SDK_LIB_PATH)\userenv.lib \


DLLENTRY=_DllMainCRTStartup 
DLLDEF=..\$(TARGETNAME).def
DLLORDER=..\$(TARGETNAME).prf

EXPECTED_WINVER=4.0

INCLUDES=..\;\
         ..\..\inc;\
         ..\..\perflib;\
         ..\..\..\inc;\
         ..\..\..\..\inc;\
         ..\..\monitors\local;\
         $(WINDOWS_INC_PATH);\
         $(PROJECT_INC_PATH);\
         $(BASE_INC_PATH);\
         $(TERMSRV_INC_PATH)\

MISCFILES=..\sysprint.sep ..\pcl.sep ..\pscript.sep ..\sysprtj.sep

USE_MSVCRT=1

!IFNDEF DISABLE_NET_UNICODE
NET_C_DEFINES=-DNET_IS_UNICODE
!ENDIF


SOURCES=..\printer.c ..\openprn.c ..\setprn.c ..\getprn.c ..\job.c ..\msgbox.c \
        ..\spooler.c ..\addjob.c ..\driver.c ..\util.c ..\init.c ..\schedule.c \
        ..\port.c ..\prndata.c ..\monitor.c ..\prtproc.c ..\data.c ..\net.c \
        ..\forms.c ..\gdi.c ..\separate.c ..\fonts.c ..\localspl.rc \
        ..\security.c ..\server.c ..\eventlog.c ..\change.c ..\copyreg.c \
        ..\version.c ..\copyfile.c ..\files.c ..\config.c ..\upgrade.c \
        ..\sizethrd.c ..\devqury.c ..\mapsd.c ..\drvupgrd.c ..\portredn.c \
        ..\ds.cxx ..\varconv.cxx ..\property.cxx ..\inet.cxx ..\clusspl.c \
        ..\clusreg.c ..\jobid.c ..\xcv.c ..\dsupdate.cxx ..\clusport.c \
        ..\dsutil.cxx ..\dsprune.cxx ..\filepool.cxx ..\catalog.cxx \
        ..\ssp.cxx

UMTYPE=console
UMLIBS=$(PROJECT_ROOT)\lib\*\localspl.lib \
       $(SDK_LIB_PATH)\advapi32.lib \
       $(SDK_LIB_PATH)\mpr.lib \
       $(SDK_LIB_PATH)\netapi32.lib

UMRES=$(O)\localspl.res

C_DEFINES=-DRPC_NO_WINDOWS_H -DUNICODE -DNO_STRICT -DDBGLOG -DSPOOLKM -D_UNICODE -D_HYDRA_

DELAYLOAD=\
            activeds.dll;\
            netapi32.dll;\
            ntdsapi.dll\

DLOAD_ERROR_HANDLER=kernel32

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\sizethrd.c ===
/*++

Copyright (c) 1994 - 1995 Microsoft Corporation

Module Name:

    sizethrd.c

Abstract:

    The NT server share for downlevel jobs does not set the size whilst
    spooling.   The SizeDetectionThread periodically wakes walks all the
    actively spooling jobs and if necessary updates the size.

Author:

    Matthew Felton (mattfe) May 1994

Revision History:

--*/

#include <precomp.h>

#include "filepool.hxx"

#define SIZE_THREAD_WAIT_PERIOD 2.5*1000      // period size thread sleeps
                                              // for polling file sizes

BOOL gbSizeDetectionRunning = FALSE;
BOOL gbRequestSizeDetection = FALSE;

VOID
SizeDetectionThread(
    PVOID pv
    );

VOID
SizeDetectionOnSpooler(
    PINISPOOLER pIniSpooler
    );


VOID
CheckSizeDetectionThread(
    VOID
    )

/*++

Routine Description:

    Check if the size detection thread is running.  If it isn't, then
    start a new one up.

    Note: there is exactly one size detection thread in the system that
    runs through all spoolers.

Arguments:

Return Value:

--*/

{
    DWORD ThreadId;
    HANDLE hThread;

    SplInSem();

    gbRequestSizeDetection = TRUE;

    //
    // If the thread isn't running, start it.  Otherwise request
    // that it starts.
    //
    if( !gbSizeDetectionRunning ){

        hThread = CreateThread( NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)SizeDetectionThread,
                                pLocalIniSpooler,
                                0,
                                &ThreadId );

        if( hThread ){
            gbSizeDetectionRunning = TRUE;
            CloseHandle( hThread );
        }
    }
}

VOID
SizeDetectionThread(
    PVOID pv
    )

/*++

Routine Description:

    Walk through all spoolers and printers to see if there are any
    jobs that have been added via AddJob.  Then see if their size
    has changed.

Arguments:

    PVOID - unused.

Return Value:

--*/

{
    PINISPOOLER pIniSpooler;
    PINISPOOLER pIniNextSpooler;

    EnterSplSem();

    while( gbRequestSizeDetection ){

        //
        // Turn it off since we are at the very beginning of the
        // loop and we check all pIniSpoolers.
        //
        gbRequestSizeDetection = FALSE;

        if( pLocalIniSpooler ){
            INCSPOOLERREF( pLocalIniSpooler );
        }

        //
        // Walk through all spoolers.
        //
        for( pIniSpooler = pLocalIniSpooler;
             pIniSpooler;
             pIniSpooler = pIniNextSpooler ){

            //
            // If this spooler prints, check it.
            //
            if( pIniSpooler->SpoolerFlags & SPL_PRINT ){

                //
                // This will leave the critical section.
                // gbRequestSizeDetection will be turned on if this printer
                // has a spooling job.
                //
                SizeDetectionOnSpooler( pIniSpooler );
            }

            //
            // Save the next spooler then decrement the refcount
            // on the current one.  We must do it in this order because
            // as soon as we release the refcount, it may disappear.
            //
            // We must protect the next spooler immediately since
            // during the DecSpoolerRef( pIniSpooler ), it might
            // get deleted.
            //
            pIniNextSpooler = pIniSpooler->pIniNextSpooler;

            if( pIniNextSpooler ){
                INCSPOOLERREF( pIniNextSpooler );
            }
            DECSPOOLERREF( pIniSpooler );
        }

        LeaveSplSem();
        Sleep( (DWORD)SIZE_THREAD_WAIT_PERIOD );
        EnterSplSem();
    }

    gbSizeDetectionRunning = FALSE;

    LeaveSplSem();

    ExitThread( 0 );
}

VOID
SizeDetectionOnSpooler(
    IN     PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Detect if a spooler has a printing job.

Arguments:

    pIniSpooler - Spooler to check.

Return Value:

--*/

{
    PINIPRINTER pIniPrinter;
    PINIPRINTER pIniNextPrinter;
    PINIJOB     pIniJob, pIniNextJob, pChainedJob;
    DWORD       dwPosition, dwChainedJobSize;

    //
    // Loop through all printers on this spooler.
    //
    for( pIniPrinter = pIniSpooler->pIniPrinter;
         pIniPrinter;
         pIniPrinter = pIniNextPrinter ){

        INCPRINTERREF(pIniPrinter);

        //
        // Loop through all jobs on this printer.
        //
        for( pIniJob = pIniPrinter->pIniFirstJob;
             pIniJob;
             pIniJob = pIniNextJob ){

            SPLASSERT( pIniJob->signature == IJ_SIGNATURE );
            SPLASSERT( pIniPrinter->signature == IP_SIGNATURE );

            INCJOBREF(pIniJob);

            SplInSem();

            if ( (pIniJob->Status & JOB_SPOOLING)       &&
                 (pIniJob->Status & JOB_TYPE_ADDJOB) ) {

                WCHAR   szFileName[MAX_PATH];
                HANDLE  hFile = INVALID_HANDLE_VALUE;
                DWORD   dwFileSize = 0;
                BOOL    DoClose = TRUE;

                gbRequestSizeDetection = TRUE;

                if ( pIniJob->hFileItem != INVALID_HANDLE_VALUE )
                {
                    hFile = GetCurrentWriter(pIniJob->hFileItem, TRUE);

                    if ( hFile == INVALID_HANDLE_VALUE )
                    {
                        wcsncpy(szFileName, pIniJob->pszSplFileName, COUNTOF(szFileName));

                        //
                        // Force NULL terminate the string.
                        //
                        szFileName[COUNTOF(szFileName) - 1] = L'\0';
                    }
                    else
                    {
                        DoClose = FALSE;
                    }

                }
                else
                {
                    GetFullNameFromId (pIniPrinter,
                                       pIniJob->JobId,
                                       TRUE,
                                       szFileName,
                                       FALSE);
                }

                LeaveSplSem();
                SplOutSem();
                if ( hFile == INVALID_HANDLE_VALUE )
                {
                    hFile = CreateFile( szFileName,
                                        0,
                                        FILE_SHARE_WRITE, NULL,
                                        OPEN_EXISTING,
                                        FILE_FLAG_SEQUENTIAL_SCAN,
                                        0 );
                }

                if ( hFile != INVALID_HANDLE_VALUE ) {

                    SeekPrinterSetEvent(pIniJob, hFile, FALSE);
                    dwFileSize = GetFileSize( hFile, 0 );

                    if ( DoClose )
                    {
                        CloseHandle( hFile );
                    }
                }

                EnterSplSem();
                SplInSem();

                SPLASSERT( pIniJob->signature == IJ_SIGNATURE );

                //
                // Chained job size include all the jobs in the chain
                // But since the next jobs size field will have the size
                // of all subsequent jobs we do not need to walk thru the
                // whole chain
                //
                dwChainedJobSize    = 0;
                if ( pIniJob->NextJobId ) {

                    if ( pChainedJob = FindJob(pIniPrinter,
                                               pIniJob->NextJobId,
                                               &dwPosition) )
                        dwChainedJobSize = pChainedJob->Size;
                    else
                        SPLASSERT(pChainedJob != NULL);
                }


                if ( pIniJob->Size < dwFileSize + dwChainedJobSize ) {

                    DWORD dwOldSize = pIniJob->Size;
                    DWORD dwOldValidSize = pIniJob->dwValidSize;

                    //
                    // Fix for print while spooling (AddJob/ScheduleJob)
                    //
                    // The file size has changed.  At this time we only
                    // know that the file is extended, not that the extended
                    // range has valid data (there's a small window where the
                    // extended window has not been filled with data).
                    //
                    // This does guarantee that the _previous_ extension
                    // has been written, however.
                    //
                    pIniJob->dwValidSize = dwOldSize;
                    pIniJob->Size = dwFileSize + dwChainedJobSize;

                    //
                    //  Wait until Jobs reach our size threshold before
                    //  we schedule them.
                    //

                    if (( dwOldValidSize < dwFastPrintSlowDownThreshold ) &&
                        ( dwOldSize >= dwFastPrintSlowDownThreshold ) &&
                        ( pIniJob->WaitForWrite == NULL )) {

                        CHECK_SCHEDULER();
                    }

                    SetPrinterChange(pIniPrinter,
                                     pIniJob,
                                     NVSpoolJob,
                                     PRINTER_CHANGE_WRITE_JOB,
                                     pIniPrinter->pIniSpooler);

                    // Support for despooling whilst spooling
                    // for Down Level jobs

                    if (pIniJob->WaitForWrite != NULL)
                        SetEvent( pIniJob->WaitForWrite );

                }
            }

            pIniNextJob = pIniJob->pIniNextJob;

            //
            // We must protect pIniNextJob immediately,
            // since we will may leave critical section in
            // DeleteJobCheck (it may call DeleteJob).  While out
            // of critical section, pIniNextJob may be deleted,
            // causing it's next pointer to be bogus.  We'll AV
            // after we try and process it.
            //
            if (pIniNextJob) {
                INCJOBREF(pIniNextJob);
            }

            DECJOBREF(pIniJob);
            DeleteJobCheck(pIniJob);

            if (pIniNextJob) {
                DECJOBREF(pIniNextJob);
            }
        }

        pIniNextPrinter = pIniPrinter->pNext;

        if( pIniNextPrinter ){
            INCPRINTERREF( pIniNextPrinter );
        }

        DECPRINTERREF(pIniPrinter);

        if( pIniNextPrinter ){
            DECPRINTERREF( pIniNextPrinter );
        }
    }

    SplInSem();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\setprn.c ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation

Module Name:

    setprn.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    management for the Local Print Providor

    SplSetPrinter

Author:

    Dave Snipp (DaveSn) 15-Mar-1991


Revision History:

    Muhunthan Sivapragasam (MuhuntS) 25-Aug-95
        -- support for level 4, and PRINTER_CONTROL_SET_STATUS.
        -- eliminate duplicate code
    Muhunthan Sivapragasam (MuhuntS) 18-Jun-1995 -- PeinterInfo5 changes
    Krishna Ganugapati (KrishnaG) 1-Jun-1994 -- rewrote these functions.
    SWilson - Added SetPrinter Level 7

--*/
#define NOMINMAX
#include <precomp.h>
#pragma hdrstop

#include "clusspl.h"

#define     PRINTER_NO_CONTROL          0x00

typedef enum {
    SECURITY_SUCCESS = 0,
    SECURITY_NOCHANGE = 1,
    SECURITY_FAIL = 2
} PRINTER_SECURITY_STATUS;

PRINTER_SECURITY_STATUS
SetPrinterSecurity(
    SECURITY_INFORMATION SecurityInformation,
    PINIPRINTER          pIniPrinter,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

VOID
RegClearKey(
    HKEY hKey,
    PINISPOOLER pIniSpooler
    );

DWORD
ValidatePrinterAttributes(
    DWORD   SourceAttributes,
    DWORD   OriginalAttributes,
    LPWSTR  pDatatype,
    LPBOOL  pbValid,
    BOOL    bSettableOnly
    );

BOOL
ChangePrinterAttributes(
    DWORD       dNewAttributes,
    DWORD       dOldAttributes,
    PINIPRINTER pIniPrinter,
    PINISPOOLER pIniSpooler,
    LPWSTR      pszNewShareName,
    BOOL        bShareRecreate,
    BOOL        bShareUpdate
    );

BOOL
NewPort(
    PKEYDATA    pKeyData,
    PINIPRINTER pIniPrinter
);

BOOL
SplSetPrinterExtraEx(
    HANDLE  hPrinter,
    DWORD   dwPrivateFlag
)
{
    BOOL    ReturnValue = FALSE;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    EnterSplSem();

    if (ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {

        pSpool->pIniPrinter->dwPrivateFlag = dwPrivateFlag;
        ReturnValue = TRUE;
    }

    LeaveSplSem();

    return  ReturnValue;
}

BOOL
SplGetPrinterExtraEx(
    HANDLE  hPrinter,
    LPDWORD pdwPrivateFlag
)
{
    BOOL   ReturnValue = FALSE;
    PSPOOL pSpool = (PSPOOL)hPrinter;

    EnterSplSem();

    if ((pSpool != NULL) &&
        (pSpool != INVALID_HANDLE_VALUE) &&
        ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER) &&
        pdwPrivateFlag) {

        *pdwPrivateFlag = pSpool->pIniPrinter->dwPrivateFlag;
        ReturnValue = TRUE;
    }

    LeaveSplSem();

    return  ReturnValue;
}


BOOL
SplSetPrinterExtra(
    HANDLE  hPrinter,
    LPBYTE  pExtraData
)
{
    BOOL    ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

   EnterSplSem();

   if (ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {

        pSpool->pIniPrinter->pExtraData = pExtraData;
        UpdatePrinterIni( pSpool->pIniPrinter , UPDATE_CHANGEID );
        ReturnValue = TRUE;

    } else {

        ReturnValue = FALSE;

    }

   LeaveSplSem();

    return  ReturnValue;
}



BOOL
SplGetPrinterExtra(
    HANDLE  hPrinter,
    PBYTE   *ppExtraData
)
{
    PSPOOL pSpool = (PSPOOL)hPrinter;
    BOOL   ReturnValue;

    if (ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {

        *ppExtraData = pSpool->pIniPrinter->pExtraData;
        ReturnValue = TRUE;

    } else {

        ReturnValue = FALSE;

    }

    return  ReturnValue;
}

BOOL
ValidateLevelAndSecurityAccesses(
    PSPOOL pSpool,
    DWORD  Level,
    LPBYTE pPrinterInfo,
    DWORD  Command,
    PDWORD pdwAccessRequired,
    PDWORD pSecurityInformation
    )
{
    DWORD   AccessRequired = 0;
    DWORD   SecurityInformation= 0;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;

    //
    // Set pdwAccessRequired = 0 and
    // Set pSecurityInformation = 0;

    *pdwAccessRequired = 0;
    *pSecurityInformation = 0;

    switch (Level) {
    case 0:
    case 4:
    case 5:
    case 6:
    case 7:
        AccessRequired = PRINTER_ACCESS_ADMINISTER;
        break;

    case 2:
        pSecurityDescriptor =
            ((PPRINTER_INFO_2)pPrinterInfo)->pSecurityDescriptor;

        AccessRequired = PRINTER_ACCESS_ADMINISTER;
        if (GetSecurityInformation(pSecurityDescriptor,
                                   &SecurityInformation)) {
            AccessRequired |= GetPrivilegeRequired( SecurityInformation );
        } else {
            //
            // Bug 54918 - We should be returning the false on GetSecurityInformation
            // failing. The reason we're not doing it is because this will break
            // Printman. Printman should pass in Valid security descriptors for Level 2
            // Fix in Printman KrishnaG 6/17
            //

            // LastError = GetLastError();
            // return FALSE;
        }
        break;

    case 3:

        pSecurityDescriptor =
            ((PPRINTER_INFO_3)pPrinterInfo)->pSecurityDescriptor;

        if (!pSecurityDescriptor) {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        if (GetSecurityInformation(pSecurityDescriptor,
                                   &SecurityInformation)) {
            AccessRequired |= GetPrivilegeRequired( SecurityInformation );
        } else {
            // LastError = GetLastError();
            return FALSE;
        }
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (!AccessGranted(SPOOLER_OBJECT_PRINTER,
                             AccessRequired,
                             pSpool) ) {
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    *pdwAccessRequired = AccessRequired;
    *pSecurityInformation = SecurityInformation;
    return TRUE;
}

PKEYDATA
CreateAndValidatePortTokenList(
    LPWSTR      pPortName,
    PINISPOOLER pIniSpooler
)
{
    PKEYDATA    pKeyData = CreateTokenList(pPortName);

    if ( pKeyData ) {
        if ( !ValidatePortTokenList(pKeyData, pIniSpooler, FALSE, NULL) ) {

            FreePortTokenList(pKeyData);
            SetLastError(ERROR_UNKNOWN_PORT);
            pKeyData = NULL;
        }
    }

    return pKeyData;
}


BOOL
NewPort(
    PKEYDATA    pKeyData,
    PINIPRINTER pIniPrinter
)
{
    DWORD       i, j;
    BOOL        rc=TRUE;

    if (!pKeyData) {
        SetLastError(ERROR_UNKNOWN_PORT);
        return FALSE;
    }

    // Check if # of requested vs. existing ports differs
    if (pIniPrinter->cPorts != pKeyData->cTokens)
        return TRUE;

    // for each requested port see if printer already has it
    for (i = 0 ; i < pKeyData->cTokens ; ++i) {

        // see if requested port is already assigned to printer
        for (j = 0 ; j < pIniPrinter->cPorts &&
            wcscmp(pIniPrinter->ppIniPorts[j]->pName, ((PINIPORT)pKeyData->pTokens[i])->pName)
            ; ++j) {

            DBGMSG(DBG_TRACE,("NewPort (Existing vs. Requested): \"%ws\" ?= \"%ws\"\n",
            pIniPrinter->ppIniPorts[j]->pName, ((PINIPORT)pKeyData->pTokens[i])->pName));
        }

        if (j == pIniPrinter->cPorts) { // found new port, so return
            DBGMSG(DBG_TRACE,("NewPort FOUND: \"%ws\"\n", ((PINIPORT)pKeyData->pTokens[i])->pName));
            return TRUE;
        }
    }

    return FALSE;
}



VOID
ChangePrinterName(
    LPWSTR      pszNewName,
    PINIPRINTER pIniPrinter,
    PINISPOOLER pIniSpooler,
    LPDWORD     pdwPrinterVector
    )

/*++

Routine Description:

    Changes printer name

Arguments:

    pszNewName - New printer name allocated using AllocSplStr

    pIniPrinter - for the printer we changing name

    pIniSpooler - Spooler that owns printer

    pdwPrinterVector - pointer to notification vector

Return Value:

    nothing

History:

    MuhuntS (Muhunthan Sivapragasam) July 95

--*/

{
    LPWSTR pNewName, pOldName;

    //
    // Before deleting the printer entry make sure you copy
    // all information with respect to the printer to the registry
    // There could be several levels of keys.
    //

    CopyPrinterIni(pIniPrinter, pszNewName);
    DeletePrinterIni(pIniPrinter);

    pOldName = pIniPrinter->pName;
    pIniPrinter->pName = pszNewName;

    *pdwPrinterVector |= BIT(I_PRINTER_PRINTER_NAME);

    //
    // Delete the old entries in WIN.INI:
    //
    CheckAndUpdatePrinterRegAll(pIniSpooler,
                                pOldName,
                                NULL,
                                UPDATE_REG_DELETE );

    FreeSplStr(pOldName);

    //
    // If printer is offline we need to write that info back with new name
    //
    if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE )
        WritePrinterOnlineStatusInCurrentConfig(pIniPrinter);
}

BOOL
SetLocalPrinterSTRESS(
    PINIPRINTER             pIniPrinter,
    PPRINTER_INFO_STRESS    pPrinterSTRESS
)
{

    if ( !pPrinterSTRESS ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Allow the caller to update the counters.
    //
    pIniPrinter->cTotalJobs           = pPrinterSTRESS->cTotalJobs;
    pIniPrinter->cTotalBytes.LowPart  = pPrinterSTRESS->cTotalBytes;
    pIniPrinter->cTotalBytes.HighPart = pPrinterSTRESS->dwHighPartTotalBytes;
    pIniPrinter->MaxcRef              = pPrinterSTRESS->MaxcRef;
    pIniPrinter->cTotalPagesPrinted   = pPrinterSTRESS->cTotalPagesPrinted;
    pIniPrinter->cMaxSpooling         = pPrinterSTRESS->cMaxSpooling;
    pIniPrinter->cErrorOutOfPaper     = pPrinterSTRESS->cErrorOutOfPaper;
    pIniPrinter->cErrorNotReady       = pPrinterSTRESS->cErrorNotReady;
    pIniPrinter->cJobError            = pPrinterSTRESS->cJobError;
    pIniPrinter->dwLastError          = pPrinterSTRESS->dwLastError;
    pIniPrinter->stUpTime             = pPrinterSTRESS->stUpTime;

    pIniPrinter->pIniSpooler->cEnumerateNetworkPrinters =
                pPrinterSTRESS->cEnumerateNetworkPrinters;
    pIniPrinter->pIniSpooler->cAddNetPrinters =
                pPrinterSTRESS->cAddNetPrinters;

    UpdatePrinterIni( pIniPrinter, KEEP_CHANGEID );
    return TRUE;

}

BOOL
SetPrinterStatus(
    PINIPRINTER     pIniPrinter,
    DWORD           Status
    )
{
    DWORD   OldStatus = pIniPrinter->Status;

    pIniPrinter->Status &= PRINTER_STATUS_PRIVATE;

    pIniPrinter->Status |= MapPrinterStatus(MAP_SETTABLE, Status);

    if ( PrinterStatusBad(OldStatus)    &&
         !PrinterStatusBad(pIniPrinter->Status) ) {

        CHECK_SCHEDULER();
    }

    SetPrinterChange(pIniPrinter,
                     NULL,
                     NVPrinterStatus,
                     PRINTER_CHANGE_SET_PRINTER,
                     pIniPrinter->pIniSpooler);

    return TRUE;
}

BOOL
SetLocalPrinter0(
    PINIPRINTER     pIniPrinter,
    DWORD           Command
)
{
    DWORD       Change = PRINTER_CHANGE_SET_PRINTER;
    BOOL        bReturn = TRUE;

    INCPRINTERREF( pIniPrinter );

    switch (Command) {

        case PRINTER_CONTROL_PURGE:

            //
            // PurgePrinter always returns TRUE now, still ..
            //
            if ( PurgePrinter(pIniPrinter) )  {

                SplLogEvent(pIniPrinter->pIniSpooler,
                            LOG_WARNING,
                            MSG_PRINTER_PURGED,
                            TRUE,
                            pIniPrinter->pName,
                            NULL );
                Change |= PRINTER_CHANGE_DELETE_JOB;

            } else {

                bReturn = FALSE;
            }
            break;

        case PRINTER_CONTROL_RESUME:

            pIniPrinter->Status &= ~PRINTER_PAUSED;

            CHECK_SCHEDULER();

            UpdatePrinterIni( pIniPrinter, KEEP_CHANGEID );

            SplLogEvent(pIniPrinter->pIniSpooler,
                        LOG_WARNING,
                        MSG_PRINTER_UNPAUSED,
                        TRUE,
                        pIniPrinter->pName,
                        NULL );
            //
            // WMI Trace Events.
            //
            {
                // Wmi only knows about jobs, so each job needs to be resumed
                // separately.
                PINIJOB pIniJob = pIniPrinter->pIniFirstJob;
                while (pIniJob)
                {
                    if ( !((pIniJob->Status & JOB_DESPOOLING) ||
                           (pIniJob->Status & JOB_PRINTING)   ||
                           (pIniJob->Status & JOB_PRINTED)    ||
                           (pIniJob->Status & JOB_ABANDON)) )
                    {
                        LogWmiTraceEvent(pIniJob->JobId,
                                         EVENT_TRACE_TYPE_SPL_RESUME, NULL);
                    }
                    pIniJob = pIniJob->pIniNextJob;
                }
            }
            break;

        case PRINTER_CONTROL_PAUSE:

            pIniPrinter->Status |= PRINTER_PAUSED;

            UpdatePrinterIni( pIniPrinter, KEEP_CHANGEID );

            SplLogEvent(pIniPrinter->pIniSpooler,
                        LOG_WARNING,
                        MSG_PRINTER_PAUSED,
                        TRUE,
                        pIniPrinter->pName,
                        NULL);
            //
            // WMI Trace Events
            //
            {
                //
                // Wmi only knows about jobs, so each job needs to be paused
                // separately.
                //
                PINIJOB pIniJob = pIniPrinter->pIniFirstJob;
                while (pIniJob)
                {
                    //
                    // HANDLE PRINTING DIRECT ???
                    // I don't believe pausing a printer can stop a job already
                    // being sent to the printer.
                    //
                    if ( !((pIniJob->Status & JOB_DESPOOLING) ||
                           (pIniJob->Status & JOB_PRINTING)   ||
                           (pIniJob->Status & JOB_PRINTED)    ||
                           (pIniJob->Status & JOB_ABANDON)) )
                    {
                        LogWmiTraceEvent(pIniJob->JobId,
                                         EVENT_TRACE_TYPE_SPL_PAUSE,
                                         NULL);
                    }
                    pIniJob = pIniJob->pIniNextJob;
                }
            }
            break;

        default:

            SetLastError(ERROR_INVALID_PRINTER_COMMAND);
            bReturn = FALSE;
            break;
    }

    DECPRINTERREF( pIniPrinter );

    if (bReturn) {

        SetPrinterChange(pIniPrinter,
                         NULL,
                         (Command == PRINTER_CONTROL_PURGE) ? NVPurge
                                                            : NVPrinterStatus,
                         Change,
                         pIniPrinter->pIniSpooler);
    }

    return bReturn;
}


BOOL
ValidateSetPrinter2(
    PINIPRINTER     pIniPrinter,
    PINIPRINTER     pTempIniPrinter,
    PPRINTER_INFO_2  pPrinterInfo2
)
/*++

Routine Description:

    Validates and builds request info about a SetPrinter info call for
    Printer information that could be changed only for level2.

Arguments:

    pIniPrinter -   PINIPRINTER of the printer handle passed in

    pTempIniPrinter - this structure is used to gather info about all
                      parameters being changed

    pPrinterInfo2 - the PrinterInfo2 structure being passed in

Return Value:
    TRUE:   If all the validation is succesful
    FALSE:  If validation of one or more request fails

    On succesful return fields which need to be changed will be set in
    pTempIniPrinter. Cleanup of this structure will be done later.

History:
    MuhuntS (Muhunthan Sivapragasam) Aug 95
--*/
{
    BOOL            bFail           = FALSE;
    DWORD           LastError       = ERROR_SUCCESS;
    PINIVERSION     pIniVersion     = NULL;
    PINIENVIRONMENT pIniEnvironment = NULL;
    BOOL            bSuccess        = FALSE;

    // Servername can't change
    // Printername handled for level 2, 4, 5

    // Sharenname length validation
    if ( pPrinterInfo2->pShareName && wcslen(pPrinterInfo2->pShareName) > PATHLEN-1 ){
        bFail = TRUE;
        LastError = ERROR_INVALID_PARAMETER;
    }

    // Share Name (validation later if required)
    AllocOrUpdateString(&pTempIniPrinter->pShareName,
                        pPrinterInfo2->pShareName,
                        pIniPrinter->pShareName,
                        TRUE,
                        &bFail);

    if ( bFail )
        goto Cleanup;

    // Port Name for level 2, 5

    // DriverName
    bSuccess = FindLocalDriverAndVersion(pIniPrinter->pIniSpooler,
                                         pPrinterInfo2->pDriverName,
                                         &pTempIniPrinter->pIniDriver,
                                         &pIniVersion);

    if ( !bSuccess ) {

       LastError = ERROR_UNKNOWN_PRINTER_DRIVER;
       goto Cleanup;
    }

    pIniEnvironment = GetLocalArchEnv(pIniPrinter->pIniSpooler);

    //
    // If we have a queue with a KMPD, then we need to let the user manage it,
    // even if the policy for blocking KMPD is enabled. However, if the caller
    // wants to change the printer driver to a KMPD, then we do not allow that
    //
    if (pTempIniPrinter->pIniDriver != pIniPrinter->pIniDriver)
    {
        INCDRIVERREF(pTempIniPrinter->pIniDriver);

        if (KMPrintersAreBlocked() &&
            IniDriverIsKMPD(pIniPrinter->pIniSpooler,
                            pIniEnvironment,
                            pIniVersion,
                            pTempIniPrinter->pIniDriver)) {

            SplLogEvent( pIniPrinter->pIniSpooler,
                         LOG_ERROR,
                         MSG_KM_PRINTERS_BLOCKED,
                         TRUE,
                         pIniPrinter->pName,
                         NULL );

            LastError = ERROR_KM_DRIVER_BLOCKED;
            goto Cleanup;
        }
    }

    // Comment length validation
    if ( pPrinterInfo2->pComment && wcslen(pPrinterInfo2->pComment) > PATHLEN-1 ){
        bFail = TRUE;
        LastError = ERROR_INVALID_PARAMETER;
    }

    // Comment
    AllocOrUpdateString(&pTempIniPrinter->pComment,
                        pPrinterInfo2->pComment,
                        pIniPrinter->pComment,
                        TRUE,
                        &bFail);

    // Location length validation
    if ( pPrinterInfo2->pLocation && wcslen(pPrinterInfo2->pLocation) > MAX_PATH-1 ){
        bFail = TRUE;
        LastError = ERROR_INVALID_PARAMETER;
    }

    // Location
    AllocOrUpdateString(&pTempIniPrinter->pLocation,
                        pPrinterInfo2->pLocation,
                        pIniPrinter->pLocation,
                        TRUE,
                        &bFail);

    // DevMode at the end

    // SepFile length validation
    if( !CheckSepFile( pPrinterInfo2->pSepFile )) {
        bFail = TRUE;
        LastError = ERROR_INVALID_SEPARATOR_FILE;
    }

    // SepFile
    AllocOrUpdateString(&pTempIniPrinter->pSepFile,
                        pPrinterInfo2->pSepFile,
                        pIniPrinter->pSepFile,
                        TRUE,
                        &bFail);

    if ( bFail )
        goto Cleanup;

    if ( pIniPrinter->pSepFile != pTempIniPrinter->pSepFile &&
         !CheckSepFile(pPrinterInfo2->pSepFile) ) {

        LastError = ERROR_INVALID_SEPARATOR_FILE;
        goto Cleanup;
    }

    // Print Processor
    pTempIniPrinter->pIniPrintProc = FindPrintProc(
                                         pPrinterInfo2->pPrintProcessor,
                                         pIniEnvironment );

    if ( !pTempIniPrinter->pIniPrintProc ) {

        LastError = ERROR_UNKNOWN_PRINTPROCESSOR;
        goto Cleanup;
    }

    if ( pTempIniPrinter->pIniPrintProc != pIniPrinter->pIniPrintProc )
        pTempIniPrinter->pIniPrintProc->cRef++;

    // Datatype
    if ( !pPrinterInfo2->pDatatype || wcslen(pPrinterInfo2->pDatatype) > MAX_PATH-1) {

        LastError = ERROR_INVALID_DATATYPE;
        goto Cleanup; // Ok to fail ???
    } else {

        AllocOrUpdateString(&pTempIniPrinter->pDatatype,
                            pPrinterInfo2->pDatatype,
                            pIniPrinter->pDatatype,
                            TRUE,
                            &bFail);
    }

    // Parameters length validation
    if (pPrinterInfo2->pParameters && wcslen(pPrinterInfo2->pParameters) > MAX_PATH-1){
        bFail = TRUE;
        LastError = ERROR_INVALID_PARAMETER;
    }

    // Parameters
    AllocOrUpdateString(&pTempIniPrinter->pParameters,
                        pPrinterInfo2->pParameters,
                        pIniPrinter->pParameters,
                        TRUE,
                        &bFail);

    if ( bFail )
        goto Cleanup;

    // SecurityDescriptor for level 2, 3
    // Attributes for level 2, 4, 5

    // Priority
    pTempIniPrinter->Priority = pPrinterInfo2->Priority;
    if ( pTempIniPrinter->Priority != pIniPrinter->Priority &&
         pTempIniPrinter->Priority != NO_PRIORITY &&
         ( pTempIniPrinter->Priority > MAX_PRIORITY ||
           pTempIniPrinter->Priority < MIN_PRIORITY ) ) {

            LastError = ERROR_INVALID_PRIORITY;
            goto Cleanup;
    }
    // Default Priority
    pTempIniPrinter->DefaultPriority = pPrinterInfo2->DefaultPriority;
    if ( pTempIniPrinter->DefaultPriority != pIniPrinter->DefaultPriority &&
         pTempIniPrinter->DefaultPriority != NO_PRIORITY &&
         ( pTempIniPrinter->DefaultPriority > MAX_PRIORITY ||
           pTempIniPrinter->DefaultPriority < MIN_PRIORITY ) ) {

            LastError = ERROR_INVALID_PRIORITY;
            goto Cleanup;
    }

    // Start time
    pTempIniPrinter->StartTime = pPrinterInfo2->StartTime;
    if ( pTempIniPrinter->StartTime != pIniPrinter->StartTime &&
         pTempIniPrinter->StartTime >= ONEDAY ) {

        LastError = ERROR_INVALID_TIME;
        goto Cleanup;
    }

    // Until time
    pTempIniPrinter->UntilTime = pPrinterInfo2->UntilTime;
    if ( pTempIniPrinter->UntilTime != pIniPrinter->UntilTime &&
         pTempIniPrinter->StartTime >= ONEDAY ) {

        LastError = ERROR_INVALID_TIME;
        goto Cleanup;
    }

    // Status for level 0, 2
    // Status can't chg
    // AveragePPM can't chg

Cleanup:
    if ( LastError ) {

        SetLastError(LastError);
        return FALSE;
    }

    if ( bFail )
        return FALSE;

    return TRUE;

}

VOID
ProcessSetPrinter2(
    PINIPRINTER     pIniPrinter,
    PINIPRINTER     pTempIniPrinter,
    PPRINTER_INFO_2 pPrinterInfo2,
    LPDWORD         pdwPrinterVector,
    PDEVMODE        pDevMode
)
/*++

Routine Description:

    Process SetPrinter for level 2. Only fields which can be changed ONLY
    by level 2 will be processed here. That is: All the fields built by
    ValidateSetPrinter2.

Arguments:

    pIniPrinter -   PINIPRINTER of the printer handle passed in

    pTempIniPrinter - this structure is has all the fields which needs to
                      be set. Other fields will be the same as the previous

    pPrinterInfo2 - the PrinterInfo2 structure being passed in

    pdwPrinterVector - Notification Info

    pDevMode        - New dev mode to be set

Return Value:
    nothing

History:
    MuhuntS (Muhunthan Sivapragasam) Aug 95
--*/
{
    HANDLE  hToken;
    PINISPOOLER pIniSpooler = pIniPrinter->pIniSpooler;
    HKEY    hKey = NULL;
    DWORD   dwResult;

    // Sharename
    if ( pTempIniPrinter->pShareName != pIniPrinter->pShareName ) {

        FreeSplStr(pIniPrinter->pShareName);
        pIniPrinter->pShareName = pTempIniPrinter->pShareName;
        *pdwPrinterVector |= BIT(I_PRINTER_SHARE_NAME);
    }

    // Driver
    if ( pTempIniPrinter->pIniDriver != pIniPrinter->pIniDriver ) {

        DECDRIVERREF(pIniPrinter->pIniDriver);

        if (pIniPrinter->pIniSpooler->SpoolerFlags & SPL_PRINTER_DRIVER_EVENT)
        {

            hToken = RevertToPrinterSelf();

            dwResult = OpenPrinterKey(pIniPrinter, KEY_READ | KEY_WRITE, &hKey, szPrinterData, TRUE);

            if (dwResult == ERROR_SUCCESS) {

                DeleteSubkeys( hKey, pIniSpooler );
                RegClearKey( hKey, pIniSpooler );
                SplRegCloseKey(hKey, pIniPrinter->pIniSpooler);
            }

            if (hToken)
                ImpersonatePrinterClient(hToken);

        }

        pIniPrinter->pIniDriver = pTempIniPrinter->pIniDriver;
        *pdwPrinterVector |= BIT(I_PRINTER_DRIVER_NAME);
    }

    // Comment
    if ( pTempIniPrinter->pComment != pIniPrinter->pComment ) {

        FreeSplStr(pIniPrinter->pComment);
        pIniPrinter->pComment = pTempIniPrinter->pComment;
        *pdwPrinterVector |= BIT(I_PRINTER_COMMENT);
    }

    // Location
    if ( pTempIniPrinter->pLocation != pIniPrinter->pLocation ) {

        FreeSplStr(pIniPrinter->pLocation);
        pIniPrinter->pLocation = pTempIniPrinter->pLocation;
        *pdwPrinterVector |= BIT(I_PRINTER_LOCATION);
    }

    // DevMode at the end
    if ( CopyPrinterDevModeToIniPrinter(pIniPrinter,
                                        pDevMode) ) {

        *pdwPrinterVector |= BIT(I_PRINTER_DEVMODE);
    }

    // SepFile
    if ( pTempIniPrinter->pSepFile != pIniPrinter->pSepFile ) {

        FreeSplStr(pIniPrinter->pSepFile);
        pIniPrinter->pSepFile = pTempIniPrinter->pSepFile;
        *pdwPrinterVector |= BIT(I_PRINTER_SEPFILE);
    }

    // PrintProcessor
    if ( pIniPrinter->pIniPrintProc != pTempIniPrinter->pIniPrintProc) {

        pIniPrinter->pIniPrintProc->cRef--;

        pIniPrinter->pIniPrintProc = pTempIniPrinter->pIniPrintProc;
        *pdwPrinterVector |= BIT(I_PRINTER_PRINT_PROCESSOR);
    }

    // Datatype
    if ( pIniPrinter->pDatatype != pTempIniPrinter->pDatatype ) {

         FreeSplStr(pIniPrinter->pDatatype);
         pIniPrinter->pDatatype  =   pTempIniPrinter->pDatatype;
         *pdwPrinterVector |= BIT(I_PRINTER_DATATYPE);
    }

    // Parameters
    if ( pIniPrinter->pParameters != pTempIniPrinter->pParameters ) {

        FreeSplStr(pIniPrinter->pParameters);
        pIniPrinter->pParameters  =   pTempIniPrinter->pParameters;
        *pdwPrinterVector |= BIT(I_PRINTER_PARAMETERS);
    }

    // Priority
    if ( pTempIniPrinter->Priority != pIniPrinter->Priority ) {

        pIniPrinter->Priority = pTempIniPrinter->Priority;
        *pdwPrinterVector |= BIT(I_PRINTER_PRIORITY);
    }

    // Default Priority
    if ( pTempIniPrinter->DefaultPriority != pIniPrinter->DefaultPriority ) {

        pIniPrinter->DefaultPriority = pTempIniPrinter->DefaultPriority;
        *pdwPrinterVector |= BIT(I_PRINTER_DEFAULT_PRIORITY);
    }

    // Start time
    if ( pTempIniPrinter->StartTime != pIniPrinter->StartTime ) {

        pIniPrinter->StartTime = pTempIniPrinter->StartTime;
        *pdwPrinterVector |= BIT(I_PRINTER_START_TIME);
    }

    // Until time
    if ( pTempIniPrinter->UntilTime != pIniPrinter->UntilTime ) {

        pIniPrinter->UntilTime = pTempIniPrinter->UntilTime;
        *pdwPrinterVector |= BIT(I_PRINTER_UNTIL_TIME);
    }

}

VOID
CleanupSetPrinter(
    PINIPRINTER pIniPrinter,
    PINIPRINTER pTempIniPrinter,
    PKEYDATA    pKeyData,
    DWORD       Level,
    BOOL        bReturnValue
)
/*++

Routine Description:

    This routine is called at the end of SplSetPrinter call to free up all
    the allocations done to process it which are not needed.

    At the beginning of a SetPrinter we make an identical copy of the
    pIniPrinter in pTempIniPrinter and collect all arguments in there.
    Now if the call is failing each of the arguments collected in there
    need to be freed.

Arguments:

    pIniPrinter -   PINIPRINTER of the printer handle passed in

    pTempIniPrinter - this structure is has all the fields which needs to
                      be freed. Any field different than pIniPrinter was
                      built part of processing the call and needs to be freed.

    pPrinterInfo2 - built for port info

    bReturnValue - return value of SetPrinter

Return Value:
    nothing

History:
    MuhuntS (Muhunthan Sivapragasam) Aug 95
--*/
{

    //
    // We adjust INIPORT, INIDRIVER refcounts. So should be inside the spl sem
    //
    SplInSem();

    FreePortTokenList(pKeyData);

    if ( pTempIniPrinter ) {

        if ( !bReturnValue  && Level == 2 ) {

            if ( pTempIniPrinter->pShareName != pIniPrinter->pShareName )
                FreeSplStr(pTempIniPrinter->pShareName);

            if ( pTempIniPrinter->pComment != pIniPrinter->pComment )
                FreeSplStr(pTempIniPrinter->pComment);

            if ( pTempIniPrinter->pLocation != pIniPrinter->pLocation )
                FreeSplStr(pTempIniPrinter->pLocation);

            if ( pTempIniPrinter->pSepFile != pIniPrinter->pSepFile )
                FreeSplStr(pTempIniPrinter->pSepFile);

            if ( pTempIniPrinter->pDatatype != pIniPrinter->pDatatype )
                FreeSplStr(pTempIniPrinter->pDatatype);

            if ( pTempIniPrinter->pParameters != pIniPrinter->pParameters )
                FreeSplStr(pTempIniPrinter->pParameters);

            if ( ( pTempIniPrinter->pIniDriver != NULL ) &&
                 ( pTempIniPrinter->pIniDriver != pIniPrinter->pIniDriver )) {

                DECDRIVERREF(pTempIniPrinter->pIniDriver);
            }

            if ( ( pTempIniPrinter->pIniPrintProc != NULL ) &&
                 ( pTempIniPrinter->pIniPrintProc != pIniPrinter->pIniPrintProc )) {

                pTempIniPrinter->pIniPrintProc->cRef--;
            }
        }

        FreeSplMem(pTempIniPrinter);
    }

}


BOOL
ValidateAndBuildSetPrinterRequest(
    PINIPRINTER             pIniPrinter,
    PINIPRINTER             pTempIniPrinter,
    LPBYTE                  pPrinterInfo,
    DWORD                   Level,
    SECURITY_INFORMATION    SecurityInformation,
    LPBOOL                  pbSecurityChg,
    LPBOOL                  pbNameChg,
    LPBOOL                  pbAttributeChg,
    LPWSTR                 *ppszNewPrinterName,
    PKEYDATA               *ppKeyData
)
/*++

Routine Description:

    This routine is called to validate a SetPrinter request. We try to as
    much vaidation as possible at the beginning to see the changes are
    possible. The routine will collect all changes requested in the
    pTempIniPrinter structure.

Arguments:

    pIniPrinter -   PINIPRINTER of the printer handle passed in

    pTempIniPrinter - this structure will be used to collect all the
                      changes requested

    pPrinterInfo - PrinterInfo_N structure passed in

    Level - Level of PrinterInfo_N

    SecurityInformation - security information

    pbSecurityChg - this will be set if a security change is requested

    pbNameChg - this will be set if a name change is requested

    pbAttributeChg - this will be set if a attribute change is requested

    ppszNewPrinterName - *ppszNewPrinterName will give the new printer name
                         to be set on a name change
    ppKeyData - *ppKeyData will give the Port token info for a level 2 or 5
                call

Return Value:
    TRUE - if all the validations succeed
    FALSE - a validation fails

History:
    MuhuntS (Muhunthan Sivapragasam) Aug 95
--*/
{
    PPRINTER_INFO_2 pPrinterInfo2 = (PPRINTER_INFO_2)pPrinterInfo;
    PPRINTER_INFO_3 pPrinterInfo3 = (PPRINTER_INFO_3)pPrinterInfo;
    PPRINTER_INFO_4 pPrinterInfo4 = (PPRINTER_INFO_4)pPrinterInfo;
    PPRINTER_INFO_5 pPrinterInfo5 = (PPRINTER_INFO_5)pPrinterInfo;
    LPWSTR          pPortName;
    DWORD           dwLastError;
    BOOL            bValid = TRUE;

    switch (Level) {

    case 2:
        pTempIniPrinter->pSecurityDescriptor =
                        pPrinterInfo2->pSecurityDescriptor;

        if ( !ValidateSetPrinter2(pIniPrinter, pTempIniPrinter, pPrinterInfo2) )
            return FALSE;

        pTempIniPrinter->pName = pPrinterInfo2->pPrinterName;

        pPortName   = pPrinterInfo2->pPortName;

        if ( !pTempIniPrinter->pIniDriver->pIniLangMonitor )
            pPrinterInfo2->Attributes &= ~PRINTER_ATTRIBUTE_ENABLE_BIDI;

        if ( pIniPrinter->pIniDriver != pTempIniPrinter->pIniDriver ) {

            pPrinterInfo2->Attributes &= ~PRINTER_ATTRIBUTE_ENABLE_BIDI;
            if ( pTempIniPrinter->pIniDriver->pIniLangMonitor )
                pPrinterInfo2->Attributes |= PRINTER_ATTRIBUTE_ENABLE_BIDI;
        }

        pTempIniPrinter->Attributes =
                        ValidatePrinterAttributes(pPrinterInfo2->Attributes,
                                                  pIniPrinter->Attributes,
                                                  pPrinterInfo2->pDatatype,
                                                  &bValid,
                                                  TRUE);

        if (!bValid) {
            return FALSE;
        }

        *pbAttributeChg = pTempIniPrinter->Attributes != pIniPrinter->Attributes;
        break;

    case 3:
        pTempIniPrinter->pSecurityDescriptor = pPrinterInfo3->pSecurityDescriptor;
        if ( !SecurityInformation || !pTempIniPrinter->pSecurityDescriptor ) {

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        break;

    case 4:
        pTempIniPrinter->pName = pPrinterInfo4->pPrinterName;

        if ( !pIniPrinter->pIniDriver->pIniLangMonitor )
            pPrinterInfo4->Attributes &= ~PRINTER_ATTRIBUTE_ENABLE_BIDI;

        pTempIniPrinter->Attributes =
                        ValidatePrinterAttributes(pPrinterInfo4->Attributes,
                                                  pIniPrinter->Attributes,
                                                  pIniPrinter->pDatatype,
                                                  &bValid,
                                                  TRUE);

        if (!bValid) {
            return FALSE;
        }

        *pbAttributeChg = pTempIniPrinter->Attributes != pIniPrinter->Attributes;
        break;

    case 5:
        pTempIniPrinter->pName = pPrinterInfo5->pPrinterName;

        pPortName   = pPrinterInfo5->pPortName;

        if ( !pIniPrinter->pIniDriver->pIniLangMonitor )
            pPrinterInfo5->Attributes &= ~PRINTER_ATTRIBUTE_ENABLE_BIDI;

        pTempIniPrinter->Attributes =
                        ValidatePrinterAttributes(pPrinterInfo5->Attributes,
                                                  pIniPrinter->Attributes,
                                                  pIniPrinter->pDatatype,
                                                  &bValid,
                                                  TRUE);

        if (!bValid) {
            return FALSE;
        }

        *pbAttributeChg = pTempIniPrinter->Attributes != pIniPrinter->Attributes;


        //
        // Validate timeout?
        //
        pTempIniPrinter->dnsTimeout = pPrinterInfo5->DeviceNotSelectedTimeout;
        pTempIniPrinter->txTimeout = pPrinterInfo5->TransmissionRetryTimeout;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    //
    // Validate share name if the shared bit is getting set or share name
    // is being changed
    //
    if ( (pTempIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED) &&
         ( !(pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED) ||
           pTempIniPrinter->pShareName != pIniPrinter->pShareName) ) {

        dwLastError = ValidatePrinterShareName(pTempIniPrinter->pShareName,
                                               pIniPrinter->pIniSpooler,
                                               pIniPrinter);
        if ( dwLastError != ERROR_SUCCESS ) {

            SetLastError(dwLastError);
            return FALSE;
        }
    }

    //
    // Is there a security change?
    //
    if ( SecurityInformation && (Level == 2 || Level == 3) ) {

        DWORD   dwSize;
        dwSize = GetSecurityDescriptorLength(pIniPrinter->pSecurityDescriptor);

        if ( dwSize !=
               GetSecurityDescriptorLength(pTempIniPrinter->pSecurityDescriptor) ||
             memcmp(pTempIniPrinter->pSecurityDescriptor,
                     pIniPrinter->pSecurityDescriptor,
                     dwSize) ) {

            *pbSecurityChg = TRUE;
        }
    }

    //
    // Is there a name change?
    //
    if ( Level == 2 || Level == 4 || Level == 5 ) {

        DWORD   LastError;

        if ( !pTempIniPrinter->pName || !*pTempIniPrinter->pName ) {

           SetLastError(ERROR_INVALID_PARAMETER);
           return FALSE;
        }


        //
        // Validate name if a change is requested
        //
        if ( lstrcmpi(pTempIniPrinter->pName, pIniPrinter->pName) ) {

            LastError = ValidatePrinterName(pTempIniPrinter->pName,
                                            pIniPrinter->pIniSpooler,
                                            pIniPrinter,
                                            ppszNewPrinterName);
            if ( LastError != ERROR_SUCCESS ) {

                *ppszNewPrinterName = NULL;
                SetLastError(LastError);
                return FALSE;
            }

            //
            // Check if printer name really changed for remote calls
            //
            if ( lstrcmpi(*ppszNewPrinterName, pIniPrinter->pName) ) {

                *ppszNewPrinterName = AllocSplStr(*ppszNewPrinterName);
                if ( !*ppszNewPrinterName )
                    return FALSE;
                *pbNameChg  = TRUE;
            } else {

                *ppszNewPrinterName = NULL;
            }
        }

        //
        // Validate attributes if a change is requested
        // Don't allow a change from queued to direct or vice versa
        // if there are already jobs on the printer.
        //
        if ( pIniPrinter->cJobs > 0 ) {

            if ( (pTempIniPrinter->Attributes & PRINTER_ATTRIBUTE_DIRECT) !=
                    (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DIRECT) ) {

                SetLastError(ERROR_PRINTER_HAS_JOBS_QUEUED);
                return FALSE;
            }
        }
    }

    if ( Level == 2 || Level == 5 ) {

        if ( !pPortName || !*pPortName ) {

           SetLastError(ERROR_UNKNOWN_PORT);
           return FALSE;
        }

        *ppKeyData = CreateAndValidatePortTokenList(pPortName,
                                                   pIniPrinter->pIniSpooler);
        if ( !*ppKeyData )
            return FALSE;
    }

    return TRUE;
}

BOOL
SplSetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinterInfo,
    DWORD   Command
)
{
    PSPOOL          pSpool = (PSPOOL)hPrinter;
    DWORD           i, LastError = ERROR_SUCCESS;
    DWORD           AccessRequired = 0;
    PINIPRINTER     pIniPrinter = pSpool->pIniPrinter, pTempIniPrinter = NULL;
    PINISPOOLER     pIniSpooler;
    BOOL            bReturn = TRUE;
    DWORD           dwResult;
    BOOL            bShareUpdate;
    BOOL            bShareRecreate;
    DWORD           dwPrinterVector = 0;
    NOTIFYVECTOR    NotifyVector;
    BOOL            bUpdateDsSpoolerKey = FALSE;
    BOOL            bNewPort;
    BOOL            bDataChanged  = FALSE;
    DWORD           OldAttributes = 0;

    PPRINTER_INFO_2 pPrinterInfo2 = (PPRINTER_INFO_2)pPrinterInfo;
    PPRINTER_INFO_3 pPrinterInfo3 = (PPRINTER_INFO_3)pPrinterInfo;
    PPRINTER_INFO_4 pPrinterInfo4 = (PPRINTER_INFO_4)pPrinterInfo;
    PPRINTER_INFO_5 pPrinterInfo5 = (PPRINTER_INFO_5)pPrinterInfo;
    PPRINTER_INFO_7 pPrinterInfo7 = (PPRINTER_INFO_7)pPrinterInfo;
    PRINTER_INFO_7  PrinterInfo7;

    BOOL                    bSecurityChg, bNameChg, bAttributeChg;
    LPWSTR                  pszNewPrinterName = NULL, pszOldPrinterName = NULL;
    PINIJOB                 pIniJob;
    PKEYDATA                pKeyData = NULL;
    PDEVMODE                pDevMode = NULL;
    PINIDRIVER              pIniDriver;
    PINIPRINTPROC           pIniPrintProc;
    SECURITY_INFORMATION    SecurityInformation;

    ZERONV(NotifyVector);

    bSecurityChg = bNameChg = bAttributeChg = FALSE;
    bShareUpdate = bShareRecreate = FALSE;

    //
    // If level != 0 info struct should be non-null, and command 0
    //
    if ( Level && Command ) {

        SetLastError(ERROR_INVALID_PRINTER_COMMAND);
        return FALSE;
    }

    if ( Level && !pPrinterInfo ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    EnterSplSem();
    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {

        bReturn = FALSE;
        goto Cleanup;
    }

    //
    // If it is a remote call get default devmode from driver and then update it
    //
    if ( Level == 2 ) {

        pDevMode = pPrinterInfo2->pDevMode;
        if ( pDevMode && (pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_DATA) ) {

            //
            // If the driver can't convert devmode user's can't set devmode from remote m/c
            //
            pDevMode = ConvertDevModeToSpecifiedVersion(pIniPrinter,
                                                        pDevMode,
                                                        NULL,
                                                        NULL,
                                                        CURRENT_VERSION);
        }

    }

    SplInSem();

    pIniSpooler = pIniPrinter->pIniSpooler;

    SPLASSERT(pIniPrinter->signature == IP_SIGNATURE );
    SPLASSERT(pIniSpooler->signature == ISP_SIGNATURE );

    if (pSpool->pIniPrinter->Status & PRINTER_ZOMBIE_OBJECT) {

        LastError = ERROR_PRINTER_DELETED;
        goto Cleanup;
    }

   if ( !ValidateLevelAndSecurityAccesses(pSpool,
                                          Level,
                                          pPrinterInfo,
                                          Command,
                                          &AccessRequired,
                                          &SecurityInformation) ){

        bReturn = FALSE;
        goto Cleanup;
    }


    //
    // Level 7 & publishing levels
    //
    if (Level == 7) {

        if ( !(pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CACHE)) {

            if (pPrinterInfo7->dwAction != DSPRINT_PUBLISH &&
                pPrinterInfo7->dwAction != DSPRINT_UNPUBLISH &&
                pPrinterInfo7->dwAction != DSPRINT_REPUBLISH &&
                pPrinterInfo7->dwAction != DSPRINT_UPDATE) {
                LastError = ERROR_INVALID_PARAMETER;
                bReturn = FALSE;
                goto Cleanup;
            }

            DBGMSG(DBG_EXEC, ("SplSetPrinter: DS Action %d: %ws %ws",
                              pPrinterInfo7->dwAction,
                              pIniPrinter->pName,
                              pIniPrinter->pszObjectGUID ?
                                  pIniPrinter->pszObjectGUID : L"<NULL>"));

            bUpdateDsSpoolerKey = TRUE;

        } else {

            //
            // For connections, we rely directly on pPrinterInfo7->dwAction because
            // the we cannot determine a pending publishing state based on attributes and GUID.
            // If the remote printer is in Pending publishing, we need to save this in dwAction.
            //
            if (!pIniPrinter->pszObjectGUID || !pPrinterInfo7->pszObjectGUID) {

                FreeSplStr(pIniPrinter->pszObjectGUID);
                pIniPrinter->pszObjectGUID = NULL;
                dwPrinterVector |= BIT(I_PRINTER_OBJECT_GUID);

            } else if (wcscmp(pIniPrinter->pszObjectGUID, pPrinterInfo7->pszObjectGUID)) {

                FreeSplStr(pIniPrinter->pszObjectGUID);
            }

            if ( pPrinterInfo7->pszObjectGUID ) {

                if (!(pIniPrinter->pszObjectGUID = AllocSplStr(pPrinterInfo7->pszObjectGUID))) {
                    bReturn = FALSE;
                    goto Cleanup;
                }
            }

            pIniPrinter->dwAction = pPrinterInfo7->dwAction;
            dwPrinterVector |= BIT(I_PRINTER_OBJECT_GUID);

        }
        goto Finish;

    } else if (Level != 3 && Level != 0) {
        bUpdateDsSpoolerKey = TRUE;
    }



    //
    // We need to do this for Level 0, 2, 3, 4, 5
    // (except for level 3 which is security case)
    //
    if ( Level != 3 && pSpool->hPort ) {

        if ( pSpool->hPort == INVALID_PORT_HANDLE ) {

            //
            // If this value is 0, then when we return GetLastError,
            // the client will think we succeeded.
            //
            SPLASSERT( pSpool->OpenPortError );

            LastError = pSpool->OpenPortError;
            goto Cleanup;

        } else {

            bReturn = SetPrinter(pSpool->hPort,
                                 Level,
                                 pPrinterInfo,
                                 Command);

            if ( !Level )
                goto Cleanup;
        }
    }

    if ( Level != 6 && Level != 0 ) {

        pTempIniPrinter = (PINIPRINTER) AllocSplMem(sizeof(INIPRINTER));
        if ( !pTempIniPrinter )
            goto Cleanup;
        CopyMemory(pTempIniPrinter, pIniPrinter, sizeof(INIPRINTER));
    }

    //
    // The actual processing begins here
    //
    if ( !Level && !Command ) {

        bReturn = SetLocalPrinterSTRESS(pIniPrinter,
                                        (PPRINTER_INFO_STRESS)pPrinterInfo);
        goto Cleanup;
    } else if ( !Level ) {

        bReturn = SetLocalPrinter0(pIniPrinter, Command);
        goto Cleanup;
    } else if ( Level == 6 ) {

        bReturn = SetPrinterStatus(pIniPrinter,
                                   ((LPPRINTER_INFO_6)pPrinterInfo)->dwStatus);
        goto Cleanup;
    } else {

        if ( !ValidateAndBuildSetPrinterRequest(pIniPrinter,
                                                pTempIniPrinter,
                                                pPrinterInfo,
                                                Level,
                                                SecurityInformation,
                                                &bSecurityChg,
                                                &bNameChg,
                                                &bAttributeChg,
                                                &pszNewPrinterName,
                                                &pKeyData) ) {

            bReturn = FALSE;
            goto Cleanup;

        } // else we follow thru rest of code since all valiations succeded

        // Just a flag stating whether we have a new port
        bNewPort = NewPort(pKeyData, pIniPrinter);
        if (bNewPort) {
            dwPrinterVector |= BIT(I_PRINTER_PORT_NAME);
        }
    }

    //
    // --------------------All validation done---------------------------
    //

    //
    // Now set security information; Remember we have
    // a valid SecurityDescriptor and "SecurityInformation
    // is non-zero at this point. We have validated this
    // information
    //
    if ( bSecurityChg ) {

        if ( SetPrinterSecurityDescriptor(SecurityInformation,
                                          pTempIniPrinter->pSecurityDescriptor,
                                          &pIniPrinter->pSecurityDescriptor) ) {

            dwPrinterVector |= BIT(I_PRINTER_SECURITY_DESCRIPTOR);
            bShareUpdate = TRUE;
        } else {

            bReturn = FALSE;
            goto Cleanup;
        }

    }


    // Can we avoid doing this if bNewPort == NULL?
    if ( Level == 2 || Level == 5 ) {

        //
        // bi-dir associate pIniPrinter with ports inside pKeyData.
        //
        bReturn = SetPrinterPorts(pSpool, pIniPrinter, pKeyData);

        if ( !bReturn )
            goto Cleanup;
    }

    if ( bAttributeChg ) {

        if ( !(pTempIniPrinter->Attributes & PRINTER_ATTRIBUTE_ENABLE_DEVQ) &&
             pIniPrinter->cJobs) {

            pIniJob = pIniPrinter->pIniFirstJob;

            while (pIniJob) {
                if (pIniJob->Status & JOB_BLOCKED_DEVQ) {

                    PNOTIFYVECTOR pNotifyVector = &NVJobStatus;
                    pIniJob->Status &= ~JOB_BLOCKED_DEVQ;

                    if( pIniJob->pStatus ){

                        FreeSplStr(pIniJob->pStatus);
                        pIniJob->pStatus = NULL;
                        pNotifyVector = &NVJobStatusAndString;
                    }

                    SetPrinterChange(pIniJob->pIniPrinter,
                                     pIniJob,
                                     *pNotifyVector,
                                     PRINTER_CHANGE_SET_JOB,
                                     pIniJob->pIniPrinter->pIniSpooler);

                }
                pIniJob = pIniJob->pIniNextJob;
            }
        }
    }

    //
    // The comment must be changed here since ShareThisPrinter
    // will look at pComment when the printer is reshared.
    //
    if ( Level == 2 &&
         pIniPrinter->pComment != pTempIniPrinter->pComment ) {

        FreeSplStr(pIniPrinter->pComment);

        pIniPrinter->pComment = pTempIniPrinter->pComment;

        dwPrinterVector |= BIT(I_PRINTER_COMMENT);

        if (pTempIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED) {

            bShareUpdate = TRUE;
        }
    }

    //
    // Change printer name if different
    //
    if ( bNameChg ) {

        pszOldPrinterName = AllocSplStr(pIniPrinter->pName);

        if (!pszOldPrinterName && pIniPrinter->pName) {
             bReturn = FALSE;
             goto Cleanup;
        }

        ChangePrinterName(pszNewPrinterName, pIniPrinter, pIniSpooler,
                          &dwPrinterVector);

        pszNewPrinterName = NULL;

        //
        // The print share must be recreated since there's no way
        // to change the path without deleting and creating a new one.
        //
        bShareRecreate = TRUE;
    }

    //
    // If Share name changed force update
    //
    if ( pIniPrinter->pShareName != pTempIniPrinter->pShareName ) {

        bShareRecreate = TRUE;
    }

    if ( bAttributeChg || bShareUpdate || bShareRecreate ) {

        OldAttributes = pIniPrinter->Attributes;
        pIniPrinter->Attributes = pTempIniPrinter->Attributes;

        bReturn = ChangePrinterAttributes(pIniPrinter->Attributes,
                                          OldAttributes,
                                          pIniPrinter,
                                          pIniSpooler,
                                          pTempIniPrinter->pShareName,
                                          bShareRecreate,
                                          bShareUpdate);

        if (!bReturn) {
            LastError = GetLastError();
        }

        if (pIniPrinter->Attributes != OldAttributes) {
            dwPrinterVector |= BIT(I_PRINTER_ATTRIBUTES);
        }
    }


    if ( Level == 2 ) {

        ProcessSetPrinter2(pIniPrinter,
                           pTempIniPrinter,
                           pPrinterInfo2,
                           &dwPrinterVector,
                           pDevMode);
    }

Finish:

    // Sometimes SetPrinter can fail certain calls after it has modified some parameters.
    // For instance, we may have failed to update some sharing fields.  If we get to this
    // point (or anywhere after the last goto Cleanup), then we need to update the ds keys.
    // We should really clean up SetPrinter so it undoes everything, but we don't have enough time
    // to fix it properly before NT6.
    bDataChanged = TRUE;

    CHECK_SCHEDULER();

    // Can we avoid doing this if dwPrinterVector == NULL?
    UpdatePrinterIni( pIniPrinter, UPDATE_CHANGEID );

    // Can we avoid doing this if dwPrinterVector == NULL?
    UpdateWinIni( pIniPrinter );  // So the port on the device is correct

    //
    // Log event that the SetPrinter was done.
    //

    INCPRINTERREF(pIniPrinter);
    SplLogEvent(pIniSpooler, LOG_INFO, MSG_PRINTER_SET, TRUE, pIniPrinter->pName, NULL);
    DECPRINTERREF(pIniPrinter);

    NotifyVector[PRINTER_NOTIFY_TYPE] |= dwPrinterVector;
    //
    // Indicate that a change has occurred.
    //
    SetPrinterChange(pIniPrinter,
                     NULL,
                     NotifyVector,
                     PRINTER_CHANGE_SET_PRINTER,
                     pIniSpooler);

Cleanup:

    SplInSem();

    if ( LastError != ERROR_SUCCESS ) {

        SetLastError(LastError);
        bReturn = FALSE;
    }

    CleanupSetPrinter(pIniPrinter, pTempIniPrinter, pKeyData,
                      Level, bReturn);

    if (bDataChanged) {
        INCPRINTERREF(pIniPrinter);
        LeaveSplSem();
        SplOutSem();

        //
        // If the printer driver changed
        // Call the printer driver to initialize itself
        //
        if (dwPrinterVector & BIT(I_PRINTER_DRIVER_NAME)) {

            PDEVMODE pDevMode = NULL;

            PrinterDriverEvent(pIniPrinter, PRINTER_EVENT_INITIALIZE, (LPARAM)NULL);

            //
            // If the driver name changed then convert the devmode to the new driver's
            // devmode. Note this must be done after the printer event initialize
            // because the driver is not able to handle a convert devmode call before
            // being initialized.  Also if the conversion fails we potentially end up
            // having the old devmode in the registry.  We could null out the devmode
            // but is it better to have a bad old devmode in the registry rather than a null
            // devmode.  A null devmode is more dangerous because an application may
            // get really confused with a null devmode rather than a bad devmode
            // which the driver will eventually fix, because they have to handle foreign
            // devmodes any way.
            //

            EnterSplSem();

            //
            // Now convert the devmode to the driver specific devmode.
            //
            pDevMode = ConvertDevModeToSpecifiedVersion(pIniPrinter,
                                                        pIniPrinter->pDevMode,
                                                        NULL,
                                                        NULL,
                                                        CURRENT_VERSION);

            //
            // If a new devmode was returned then release the current printer's
            // devmode and save the new devmode.
            //
            if (pDevMode) {

                FreeSplMem(pIniPrinter->pDevMode);
                pIniPrinter->pDevMode = pDevMode;
                pIniPrinter->cbDevMode = pDevMode->dmSize + pDevMode->dmDriverExtra;
            }

            //
            // Write the newly converted devmode to the registry again.
            //
            UpdatePrinterIni( pIniPrinter, UPDATE_CHANGEID );

            LeaveSplSem();
        }

        //
        // If the printer attributes changed, call the driver with the two
        // different sets of attributes, this is to allow the fax driver to
        // start up the fax service when a printer gets shared out.
        //
        if (dwPrinterVector & BIT(I_PRINTER_ATTRIBUTES)) {

            PRINTER_EVENT_ATTRIBUTES_INFO   AttributesInfo = {
                sizeof(PRINTER_EVENT_ATTRIBUTES_INFO),
                OldAttributes,
                pIniPrinter->Attributes
            };

            PrinterDriverEvent(pIniPrinter, PRINTER_EVENT_ATTRIBUTES_CHANGED, (LPARAM)&AttributesInfo);
        }

        EnterSplSem();
        SplInSem();
        DECPRINTERREF(pIniPrinter);
    }


    // Don't update if this is from cache
    if (!bDataChanged || ((Level == 2 || Level == 5) && !dwPrinterVector) ||
        (pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CACHE)) {

        bUpdateDsSpoolerKey = FALSE;

    } else if (bUpdateDsSpoolerKey) {

        if (Level != 7)
        {
            //
            // Update unly values that changed.
            //
            UpdateDsSpoolerKey(hPrinter, dwPrinterVector);

        } else if (pPrinterInfo7->dwAction != DSPRINT_UNPUBLISH)
        {
            //
            // Update the all values in Registry for level 7.
            //
            UpdateDsSpoolerKey(hPrinter, 0xffffffff);
        }

        //
        // Reset Driver DS Properties if driver changed
        //
        if (dwPrinterVector & BIT(I_PRINTER_DRIVER_NAME)) {

            INCPRINTERREF(pIniPrinter);
            LeaveSplSem();

            //
            // This calls SetPrinterDs with DSPRINT_UPDATE anyway.
            //
            RecreateDsKey(hPrinter, SPLDS_DRIVER_KEY);

            EnterSplSem();
            DECPRINTERREF(pIniPrinter);

        } else if (Level != 7 || pPrinterInfo7->dwAction != DSPRINT_UNPUBLISH) {

            //
            // If the driver didn't change, query the driver again for capabilities.
            //
            UpdateDsDriverKey(hPrinter);
        }
    }

    if (bUpdateDsSpoolerKey) {
        if (pIniPrinter->DsKeyUpdateForeground || (Level == 7 && pPrinterInfo7->dwAction == DSPRINT_UNPUBLISH)) {
            if (Level == 7) {
                if ((dwResult = SetPrinterDs(hPrinter, pPrinterInfo7->dwAction, FALSE)) != ERROR_SUCCESS) {
                    SetLastError(dwResult);
                    bReturn = FALSE;
                }
            } else {
                //
                // Update only, in the background thread.
                //
                SetPrinterDs(hPrinter, DSPRINT_UPDATE, FALSE);
            }
        }
    }

    LeaveSplSem();
    SplOutSem();


    if ( pDevMode && pDevMode != pPrinterInfo2->pDevMode )
        FreeSplMem(pDevMode);

    if ( pszOldPrinterName ) {
        FreeSplStr(pszOldPrinterName);
    }

    FreeSplStr(pszNewPrinterName);

    return bReturn;
}



PRINTER_SECURITY_STATUS
SetPrinterSecurity(
    SECURITY_INFORMATION SecurityInformation,
    PINIPRINTER          pIniPrinter,
    PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    DWORD dwSize;

    if (!pSecurityDescriptor)
        return SECURITY_FAIL;

    if (pIniPrinter->pSecurityDescriptor) {

        dwSize = GetSecurityDescriptorLength(pIniPrinter->pSecurityDescriptor);

        if (dwSize == GetSecurityDescriptorLength(pSecurityDescriptor)) {

            if (!memcmp(pSecurityDescriptor,
                        pIniPrinter->pSecurityDescriptor,
                        dwSize)) {

                return SECURITY_NOCHANGE;
            }
        }
    }

    if( !SetPrinterSecurityDescriptor( SecurityInformation,
                                       pSecurityDescriptor,
                                       &pIniPrinter->pSecurityDescriptor ) ) {

        DBGMSG(DBG_WARNING, ("SetPrinterSecurityDescriptor failed. Error = %d\n",
                              GetLastError()));
        return SECURITY_FAIL;
    }

    UpdatePrinterIni(pIniPrinter, UPDATE_CHANGEID);

    return SECURITY_SUCCESS;
}

VOID
RegClearKey(
    HKEY hKey,
    PINISPOOLER pIniSpooler
    )
{
    DWORD dwError;
    WCHAR szValue[4*MAX_PATH];

    DWORD cchValue;

    while (TRUE) {

        cchValue = COUNTOF(szValue);
        dwError = SplRegEnumValue( hKey,
                                   0,
                                   szValue,
                                   &cchValue,
                                   NULL,
                                   NULL,
                                   NULL,
                                   pIniSpooler );

        if( dwError != ERROR_SUCCESS ){

            if( dwError != ERROR_NO_MORE_ITEMS ){
                DBGMSG( DBG_ERROR, ( "RegClearKey: Failed %d\n", dwError ));
            }
            break;
        }

        dwError = SplRegDeleteValue( hKey, szValue, pIniSpooler );

        if( dwError != ERROR_SUCCESS ){
            DBGMSG( DBG_ERROR, ( "RegDeleteValue: %s Failed %d\n",
                                 szValue, dwError ));
            break;
        }
    }
}

BOOL
ChangePrinterAttributes(
    DWORD       dNewAttributes,
    DWORD       dOldAttributes,
    PINIPRINTER pIniPrinter,
    PINISPOOLER pIniSpooler,
    LPWSTR      pszNewShareName,
    BOOL        bShareRecreate,
    BOOL        bShareUpdate
    )
/*++

Routine Description:

    Changes printer attributes by validating sharing information.
    Already the validated attributes are set, we want to validate
    by changing the share information

Arguments:

    dNewAttributes - New attributes specified on SetPrinter call

    dOldAttributes - pIniPrinter->Attributes before the call

    pIniPrinter - of the printer we are changing attributes

    pIniSpooler - Spooler that owns printer

    pszNewShareName - the share name that will be set if SetPrinter succeeds

    bShareRecreate - Share must be recreated because the printer or share
        name changed.

    bShareUpdate - Share just needs to be updated, since comment / SD changed.

Return Value:

    DWORD TRUE on success, FALSE else.

History:
    MuhuntS (Muhunthan Sivapragasam) July 95

--*/

{
    BOOL        Shared, bReturn = TRUE;

    //
    // We are going to have to be able to restore the attributes if the share
    // modification fails. We need to set the current attributes now because
    // the NetSharexxx is going to call OpenPrinter, and possibly an AddJob
    // which needs the correct Attributes.
    //
    if (dNewAttributes & PRINTER_ATTRIBUTE_SHARED) {

        if (!(dOldAttributes & PRINTER_ATTRIBUTE_SHARED)) {

            pIniPrinter->Attributes |= PRINTER_ATTRIBUTE_SHARED;

            Shared = ShareThisPrinter( pIniPrinter, pszNewShareName, TRUE );

            if ( !Shared ) {

                pIniPrinter->Attributes = dOldAttributes;
                bReturn = FALSE;
            }

        } else {

            //
            // We are shared, and so is the old one.  If share name changed
            // we have to remove old share and reshare.
            //
            if ( bShareRecreate ) {

                if (ShareThisPrinter(pIniPrinter,
                                     pIniPrinter->pShareName,
                                     FALSE)) {

#if DBG
                    WCHAR pwszError[256];

                    wsprintf(pwszError,
                             L"Error %d, removing share",
                             GetLastError());

                    //
                    // Error: the printer shouldn't be shared at this
                    // point.
                    //

                    INCPRINTERREF(pIniPrinter);

                    SplLogEvent(pIniSpooler,
                                LOG_ERROR,
                                MSG_SHARE_FAILED,
                                TRUE,
                                L"SetLocalPrinter ShareThisPrinter FALSE",
                                pIniPrinter->pName,
                                pIniPrinter->pShareName,
                                pwszError,
                                NULL);

                    DECPRINTERREF(pIniPrinter);
#endif

                    bReturn = FALSE;

                } else if (!ShareThisPrinter(pIniPrinter,
                                             pszNewShareName,
                                             TRUE)) {
#if DBG
                    WCHAR pwszError[256];

                    wsprintf(pwszError,
                             L"Error %d, adding share",
                             GetLastError());

                    //
                    // Error: the printer shouldn't be shared at this
                    // point.
                    //

                    INCPRINTERREF(pIniPrinter);

                    SplLogEvent(pIniSpooler,
                                LOG_ERROR,
                                MSG_SHARE_FAILED,
                                TRUE,
                                L"SetLocalPrinter ShareThisPrinter TRUE",
                                pIniPrinter->pName,
                                pIniPrinter->pShareName,
                                pwszError,
                                NULL);

                    DECPRINTERREF(pIniPrinter);
#endif

                    pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_SHARED;
                    pIniPrinter->Status |= PRINTER_WAS_SHARED;
                    bReturn = FALSE;
                }
            } else if ( bShareUpdate ) {
                //
                // If comment/description changed then we just do a NetShareSet
                //
                bReturn = SetPrinterShareInfo(pIniPrinter);

            }
        }

    } else if (dOldAttributes & PRINTER_ATTRIBUTE_SHARED) {

        Shared = ShareThisPrinter(pIniPrinter, pIniPrinter->pShareName, FALSE);

        if (!Shared) {

            pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_SHARED;
            pIniPrinter->Status |= PRINTER_WAS_SHARED;
            CreateServerThread();


        } else {
            pIniPrinter->Attributes = dOldAttributes;
            bReturn = FALSE;
        }
    }

    if (((dOldAttributes & PRINTER_ATTRIBUTE_WORK_OFFLINE) &&
        !(dNewAttributes & PRINTER_ATTRIBUTE_WORK_OFFLINE) ) ||
        (!(dOldAttributes & PRINTER_ATTRIBUTE_WORK_OFFLINE) &&
        (dNewAttributes & PRINTER_ATTRIBUTE_WORK_OFFLINE) ) ) {

        WritePrinterOnlineStatusInCurrentConfig(pIniPrinter);
    }


    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\spltypes.h ===
/*++

Copyright ( c) 1990 - 1996  Microsoft Corporation
All rights reserved

Module Name:

    spltypes.h

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:
    Muhunthan Sivapragasam <MuhuntS> 30 May 1995
    Support for level 3 <SUR>

--*/


#ifndef MODULE
#define MODULE "LSPL:"
#define MODULE_DEBUG LocalsplDebug
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <ntfytab.h>

typedef HANDLE SEM;

typedef struct _KEYDATA {
    BOOL    bFixPortRef;    // Tells if INIPORT list is build and cRef incremented
    DWORD   cTokens;
    LPWSTR  pTokens[1];     // This should remain the last field
} KEYDATA, *PKEYDATA;

typedef struct _INIENTRY {
    DWORD       signature;
    struct _INIENTRY *pNext;
    DWORD       cRef;
    LPWSTR      pName;
} INIENTRY, *PINIENTRY;


//
// Prototypes used by PINIPRINTPROC
//
typedef HANDLE    (WINAPI *pfnOpenPrintProcessor)(LPWSTR, PPRINTPROCESSOROPENDATA);

typedef BOOL      (WINAPI *pfnInstallPrintProcessor)(HWND);

typedef BOOL      (WINAPI *pfnEnumDatatypes)(LPWSTR, LPWSTR, DWORD, LPBYTE, DWORD, LPDWORD, LPDWORD);

typedef BOOL      (WINAPI *pfnPrintDocOnPrintProcessor)(HANDLE, LPWSTR);

typedef BOOL      (WINAPI *pfnClosePrintProcessor)(HANDLE);

typedef BOOL      (WINAPI *pfnControlPrintProcessor)(HANDLE, DWORD);

typedef DWORD     (WINAPI *pfnGetPrintProcCaps)(LPTSTR, DWORD, LPBYTE ,DWORD, LPDWORD);

typedef struct _INIPRINTPROC {             /* iqp */
    DWORD       signature;
    struct _INIPRINTPROC *pNext;
    DWORD       cRef;
    LPWSTR      pName;
    LPWSTR      pDLLName;
    DWORD       cbDatatypes;
    DWORD       cDatatypes;
    LPWSTR      pDatatypes;
    HANDLE      hLibrary;
    pfnInstallPrintProcessor    Install;
    pfnEnumDatatypes            EnumDatatypes;
    pfnOpenPrintProcessor       Open;
    pfnPrintDocOnPrintProcessor Print;
    pfnClosePrintProcessor      Close;
    pfnControlPrintProcessor    Control;
    pfnGetPrintProcCaps         GetPrintProcCaps;
    CRITICAL_SECTION CriticalSection;
    DWORD       FileMinorVersion;
    DWORD       FileMajorVersion;
} INIPRINTPROC, *PINIPRINTPROC;


// Print Processor critical section tags
#define PRINTPROC_CANCEL    0x00000001
#define PRINTPROC_PAUSE     0x00000002
#define PRINTPROC_RESUME    0x00000004
#define PRINTPROC_CLOSE     0x00000008

//
// If we have cancelled a job, we do not want to be able to pause or resume it again,
// so we set both those flags. That will cause the pause and resume codepaths to bail out.
// The flags are reset when we get a new job for the port or restart the job.
//
#define PRINTPROC_CANCELLED  PRINTPROC_PAUSE|PRINTPROC_RESUME


#define IPP_SIGNATURE    0x5050 /* 'PP' is the signature value */

typedef struct _INIDRIVER {            /* id */
    DWORD       signature;
    struct _INIDRIVER *pNext;
    DWORD       cRef;
    LPWSTR      pName;
    LPWSTR      pDriverFile;
    LPWSTR      pConfigFile;
    LPWSTR      pDataFile;
    LPWSTR      pHelpFile;
    DWORD       cchDependentFiles; //length including \0\0
    LPWSTR      pDependentFiles;
    LPWSTR      pMonitorName;
    LPWSTR      pDefaultDataType;
    DWORD       cchPreviousNames;
    LPWSTR      pszzPreviousNames;
    FILETIME    ftDriverDate;
    DWORDLONG   dwlDriverVersion;
    LPTSTR      pszMfgName;
    LPTSTR      pszOEMUrl;
    LPTSTR      pszHardwareID;
    LPTSTR      pszProvider;
    DWORD       dwDriverAttributes;
    DWORD       cVersion;
    DWORD       dwTempDir;
    struct _INIMONITOR *pIniLangMonitor;
    DWORD       dwDriverFlags;
    DWORD       DriverFileMinorVersion;
    DWORD       DriverFileMajorVersion;
} INIDRIVER, *PINIDRIVER;

//
// Printer Driver Flags:
//
#define PRINTER_DRIVER_PENDING_DELETION     0x0001

#define ID_SIGNATURE    0x4444  /* 'DD' is the signature value */

 // struct for holding the reference counts for driver related files.
 typedef struct _DRVREFCNT {
     struct _DRVREFCNT *pNext;
     LPWSTR  szDrvFileName;
     DWORD   refcount;
     DWORD   dwVersion;
     DWORD   dwFileMinorVersion;
     DWORD   dwFileMajorVersion;
     BOOL    bInitialized;
 } DRVREFCNT, *PDRVREFCNT;

typedef struct _INIVERSION {
    DWORD       signature;
    struct _INIVERSION *pNext;
    LPWSTR      pName;
    LPWSTR      szDirectory;
    DWORD       cMajorVersion;
    DWORD       cMinorVersion;
    PDRVREFCNT  pDrvRefCnt;
    PINIDRIVER  pIniDriver;
} INIVERSION, *PINIVERSION;

typedef struct _DRVREFNODE {
    struct _DRVREFNODE *pNext;
    PDRVREFCNT  pdrc;
} DRVREFNODE, *PDRVREFNODE;

#define IV_SIGNATURE   'IV'     // 4956H


typedef struct _INIENVIRONMENT {            /* id */
    DWORD         signature;
    struct _INIENVIRONMENT *pNext;
    DWORD         cRef;
    LPWSTR        pName;
    LPWSTR        pDirectory;
    PINIVERSION   pIniVersion;
    PINIPRINTPROC pIniPrintProc;
    struct _INISPOOLER *pIniSpooler; // Points to owning IniSpooler
} INIENVIRONMENT, *PINIENVIRONMENT;

#define IE_SIGNATURE    0x4545  /* 'EE' is the signature value */

typedef struct
{
    DWORD           Status;
    DWORD           cJobs;
    DWORD           dwError;
    BOOL            bThreadRunning;

} MasqPrinterCache;

typedef struct _INIPRINTER {    /* ip */
    DWORD       signature;
    struct _INIPRINTER *pNext;
    DWORD       cRef;
    LPWSTR      pName;
    LPWSTR      pShareName;
    PINIPRINTPROC pIniPrintProc;
    LPWSTR      pDatatype;
    LPWSTR      pParameters;
    LPWSTR      pComment;
    PINIDRIVER  pIniDriver;
    DWORD       cbDevMode;
    LPDEVMODE   pDevMode;
    DWORD       Priority;           // queue priority (lowest:1 - highest:9)
    DWORD       DefaultPriority;
    DWORD       StartTime;          // print daily after time: from 00:00 in min
    DWORD       UntilTime;          // print daily until time: from 00:00 in min
    LPWSTR      pSepFile;           // full path to separator file, null = def
    DWORD       Status;             // QMPAUSE/ERROR/PENDING
    LPWSTR      pLocation;
    DWORD       Attributes;
    DWORD       cJobs;
    DWORD       AveragePPM;         // BOGUS, nothing updates it
    BOOL        GenerateOnClose;    // Passed to security auditing APIs
    struct _INIPORT *pIniNetPort;   // Non-NULL if there's a network port
    struct _INIJOB *pIniFirstJob;
    struct _INIJOB *pIniLastJob;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    struct _SPOOL  *pSpool;         // Linked list of handles for this printer
    LPWSTR      pSpoolDir;          // Location to write / read spool files
                                    // Only Used for Stress Test Data
    DWORD       cTotalJobs;         // Total Number of Jobs (since boot)
    LARGE_INTEGER cTotalBytes;      // Total Number of Bytes (since boot)
    SYSTEMTIME  stUpTime;           // Time when IniPrinter structure created
    DWORD       MaxcRef;            // Max number open printer handles
    DWORD       cTotalPagesPrinted; // Total Number of Pages Printer on this printer
    DWORD       cSpooling;          // # of Jobs concurrently spooling
    DWORD       cMaxSpooling;       // Max Number of concurrent spooling jobs
    DWORD       cErrorOutOfPaper;   // Count Out Out Of Paper Errors
    DWORD       cErrorNotReady;     // Count Not Ready Errors
    DWORD       cJobError;          // Count Job Errors
    struct _INISPOOLER *pIniSpooler; // Points to owning IniSpooler
    DWORD       cZombieRef;
    DWORD       dwLastError;        // Last Printer Error
    LPBYTE      pExtraData;         //  For extranal Print Providers SplSetPrinterExtra
    DWORD       cChangeID;          // Time Stamp when printer is changed
    DWORD       cPorts;             // Number of ports printer is attached to
    struct _INIPORT **ppIniPorts;         // Ports this printer is going to
    DWORD       PortStatus;         // Error set against IniPorts
    DWORD       dnsTimeout;         // Device not selected timeout in milliseconds
    DWORD       txTimeout;          // Transmission retry timeout in milliseconds
    PWSTR       pszObjectGUID;      // printQueue ObjectGUID
    DWORD       DsKeyUpdate;        // Keeps track of which DS Key update state
    PWSTR       pszDN;              // Distinguished Name
    PWSTR       pszCN;              // Common Name
    DWORD       cRefIC;             // Refcount on CreateICHandle--info only
    DWORD       dwAction;           // DS action
    BOOL        bDsPendingDeletion; // if TRUE, published printer is being deleted
    DWORD       dwUniqueSessionID;  // Unique Session ID for the printers
    DWORD       dwPrivateFlag;
    DWORD       DsKeyUpdateForeground;  // Keeps track of which DS Key changed while publishing
#if DBG
    PVOID       pvRef;
#endif

    MasqPrinterCache  MasqCache;

} INIPRINTER, *PINIPRINTER;

#define IP_SIGNATURE    0x4951  /* 'IQ' is the signature value */

#define FASTPRINT_WAIT_TIMEOUT          (4*60*1000)   // 4 Minutes
#define FASTPRINT_THROTTLE_TIMEOUT      (2*1000)      // 2 seconds
#define FASTPRINT_SLOWDOWN_THRESHOLD    ( FASTPRINT_WAIT_TIMEOUT / FASTPRINT_THROTTLE_TIMEOUT )

#define WRITE_PRINTER_SLEEP_TIME        0   // disabled by default

// pIniPrinter->Attributes are defined in winspool.h PRINTER_ATTRIBUTE_*
// Below are pIniPrinter->Status flags !!!
// See INIT.C some of these are removed at reboot

#define PRINTER_PAUSED                  0x00000001
#define PRINTER_ERROR                   0x00000002
#define PRINTER_OFFLINE                 0x00000004
#define PRINTER_PAPEROUT                0x00000008
#define PRINTER_PENDING_DELETION        0x00000010
#define PRINTER_ZOMBIE_OBJECT           0x00000020
#define PRINTER_PENDING_CREATION        0x00000040
#define PRINTER_OK                      0x00000080
#define PRINTER_FROM_REG                0x00000100
#define PRINTER_WAS_SHARED              0x00000200
#define PRINTER_PAPER_JAM               0x00000400
#define PRINTER_MANUAL_FEED             0x00000800
#define PRINTER_PAPER_PROBLEM           0x00001000
#define PRINTER_IO_ACTIVE               0x00002000
#define PRINTER_BUSY                    0x00004000
#define PRINTER_PRINTING                0x00008000
#define PRINTER_OUTPUT_BIN_FULL         0x00010000
#define PRINTER_NOT_AVAILABLE           0x00020000
#define PRINTER_WAITING                 0x00040000
#define PRINTER_PROCESSING              0x00080000
#define PRINTER_INITIALIZING            0x00100000
#define PRINTER_WARMING_UP              0x00200000
#define PRINTER_TONER_LOW               0x00400000
#define PRINTER_NO_TONER                0x00800000
#define PRINTER_PAGE_PUNT               0x01000000
#define PRINTER_USER_INTERVENTION       0x02000000
#define PRINTER_OUT_OF_MEMORY           0x04000000
#define PRINTER_DOOR_OPEN               0x08000000
#define PRINTER_SERVER_UNKNOWN          0x10000000
#define PRINTER_POWER_SAVE              0x20000000
#define PRINTER_NO_MORE_JOBS            0x40000000


#define PRINTER_STATUS_PRIVATE      ( PRINTER_PAUSED | \
                                      PRINTER_ERROR | \
                                      PRINTER_PENDING_DELETION | \
                                      PRINTER_ZOMBIE_OBJECT | \
                                      PRINTER_PENDING_CREATION | \
                                      PRINTER_OK | \
                                      PRINTER_FROM_REG | \
                                      PRINTER_WAS_SHARED )
#define PrinterStatusBad(dwStatus)  ( (dwStatus & PRINTER_OFFLINE)  || \
                                      (dwStatus & PRINTER_PAUSED) )

#define PRINTER_CHANGE_VALID                    0x75770F0F
#define PRINTER_CHANGE_CLOSE_PRINTER            0xDEADDEAD


// DS publishing state
#define DS_KEY_SPOOLER          0x00000001
#define DS_KEY_DRIVER           0x00000002
#define DS_KEY_USER             0x00000004
#define DS_KEY_REPUBLISH        0x80000000
#define DS_KEY_PUBLISH          0x40000000
#define DS_KEY_UNPUBLISH        0x20000000
#define DS_KEY_UPDATE_DRIVER    0x10000000

#define OID_KEY_NAME L"OID"

#define DN_SPECIAL_CHARS    L",=\r\n+<>#;\"\\"
#define ADSI_SPECIAL_CHARS  L"/"

//
// These are attribute bits that are permitted to be set by SetPrinter().
//
// Note: I have removed PRINTER_ATTRIBUTE_DEFAULT, since it is
// per-user, and not per-printer.
//
#define PRINTER_ATTRIBUTE_SETTABLE ( PRINTER_ATTRIBUTE_ENABLE_BIDI        | \
                                     PRINTER_ATTRIBUTE_QUEUED             | \
                                     PRINTER_ATTRIBUTE_DIRECT             | \
                                     PRINTER_ATTRIBUTE_SHARED             | \
                                     PRINTER_ATTRIBUTE_HIDDEN             | \
                                     PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS    | \
                                     PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST  | \
                                     PRINTER_ATTRIBUTE_ENABLE_DEVQ        | \
                                     PRINTER_ATTRIBUTE_RAW_ONLY           | \
                                     PRINTER_ATTRIBUTE_WORK_OFFLINE)

// Define some constants to make parameters to CreateEvent a tad less obscure:

#define EVENT_RESET_MANUAL                  TRUE
#define EVENT_RESET_AUTOMATIC               FALSE
#define EVENT_INITIAL_STATE_SIGNALED        TRUE
#define EVENT_INITIAL_STATE_NOT_SIGNALED    FALSE

typedef struct _ININETPRINT {    /* in */
    DWORD       signature;
    struct _ININETPRINT *pNext;
    DWORD       TickCount;
    LPWSTR      pDescription;
    LPWSTR      pName;
    LPWSTR      pComment;
} ININETPRINT, *PININETPRINT;

#define IN_SIGNATURE    0x494F  /* 'IO' is the signature value */

typedef struct _INIMONITOR {       /* imo */
    DWORD   signature;
    struct  _INIMONITOR *pNext;
    DWORD   cRef;
    LPWSTR  pName;
    LPWSTR  pMonitorDll;
    HANDLE  hModule;
    HANDLE  hMonitor;
    BOOL    bUplevel;
    struct _INISPOOLER *pIniSpooler;
    PMONITORINIT pMonitorInit;
    MONITOR2 Monitor2;  // Uplevel monitor vector.
    MONITOR  Monitor;   // Downlevel vector.
} INIMONITOR, *PINIMONITOR;

#define IMO_SIGNATURE   0x4C50  /* 'LP' is the signature value */


// Enumerate all Xcv handle types here
enum {
    XCVPORT,
    XCVMONITOR
};

typedef BOOL (*PFNXCVDATA)( HANDLE  hXcv,
                            PCWSTR  pszDataName,
                            PBYTE   pInputData,
                            DWORD   cbInputData,
                            PBYTE   pOutputData,
                            DWORD   cbOutputData,
                            PDWORD  pcbOutputNeeded,
                            PDWORD  pdwStatus
                            );

typedef BOOL (*PFNXCVCLOSE)(HANDLE  hXcv);


typedef struct _INIXCV {       /* xp */
    DWORD   signature;
    struct  _INIXCV *pNext;
    DWORD   cRef;
    PWSTR   pszMachineName;
    PWSTR   pszName;
    struct _INISPOOLER *pIniSpooler;
    union {
        PMONITOR2 pMonitor2;
    };
    HANDLE  hXcv;
} INIXCV, *PINIXCV;

#define XCV_SIGNATURE   0x5850  /* 'XP' is the signature value */

typedef struct _INIPORT {       /* ipo */
    DWORD   signature;
    struct  _INIPORT *pNext;
    DWORD   cRef;
    LPWSTR  pName;
    HANDLE  hProc;          /* Handle to Queue Processor */
    DWORD   Status;              // see PORT_ manifests
    DWORD   PrinterStatus;       // Status values set by language monitor
    LPWSTR  pszStatus;
    HANDLE  Semaphore;           // Port Thread will sleep on this
    struct  _INIJOB *pIniJob;     // Master Job
    DWORD   cJobs;
    DWORD   cPrinters;
    PINIPRINTER *ppIniPrinter; /* -> printer connected to this port */
                               /* no reference count! */
    PINIMONITOR pIniMonitor;
    PINIMONITOR pIniLangMonitor;
    HANDLE  hWaitToOpenOrClose;
    HANDLE  hEvent;
    HANDLE  hPort;
    HANDLE  Ready;
    HANDLE  hPortThread;        // Port Thread Handle
    DWORD   IdleTime;
    DWORD   ErrorTime;
    HANDLE  hErrorEvent;
    struct _INISPOOLER *pIniSpooler;    // Spooler whilch owns this port.
    DWORD   InCriticalSection;          // PrintProc Critsec mask. Should be per port instead
                                        // of per printproc.
    BOOL    bIdleTimeValid;
} INIPORT, *PINIPORT;

#define IPO_SIGNATURE   0x4F50  /* 'OP' is the signature value */

//
//  Also add to debugger extentions
//

#define PP_PAUSED         0x000001
#define PP_WAITING        0x000002
#define PP_RUNTHREAD      0x000004  // port thread should be running
#define PP_THREADRUNNING  0x000008  // port thread are running
#define PP_RESTART        0x000010
#define PP_CHECKMON       0x000020  // monitor might get started/stopped
#define PP_STOPMON        0x000040  // stop monitoring this port
#define PP_QPROCCHECK     0x000100  // queue processor needs to be called
#define PP_QPROCPAUSE     0x000200  // pause (otherwise continue) printing job
#define PP_QPROCABORT     0x000400  // abort printing job
#define PP_QPROCCLOSE     0x000800  // close printing job
#define PP_PAUSEAFTER     0x001000  // hold destination
#define PP_MONITORRUNNING 0x002000  // Monitor is running
#define PP_RUNMONITOR     0x004000  // The Monitor should be running
#define PP_MONITOR        0x008000  // There is a Monitor handling this
#define PP_FILE           0x010000  // We are going to a file
#define PP_ERROR          0x020000  // Error status has been set
#define PP_WARNING        0x040000  // Warning status has been set
#define PP_INFORMATIONAL  0x080000  // Informational status been set
#define PP_DELETING       0x100000  // Port is being deleted
#define PP_STARTDOC       0x200000  // Port called with StartDoc active
#define PP_PLACEHOLDER    0x400000  // The port is a placeholder port.

typedef struct _INIFORM {       /* ifo */
    DWORD   signature;
    struct  _INIFORM *pNext;
    DWORD   cRef;
    LPWSTR  pName;
    SIZEL   Size;
    RECTL   ImageableArea;
    DWORD   Type;           // Built-in or user-defined
    DWORD   cFormOrder;
} INIFORM, *PINIFORM;

#define IFO_SIGNATURE   0x4650  /* 'FP' is the signature value */

#define FORM_USERDEFINED  0x0000


typedef struct _SHARED {
    PINIFORM pIniForm;
} SHARED, *PSHARED;

typedef struct _INISPOOLER {
    DWORD         signature;
    struct _INISPOOLER *pIniNextSpooler;
    DWORD         cRef;
    LPWSTR        pMachineName;
    DWORD         cOtherNames;
    LPWSTR       *ppszOtherNames;
    LPWSTR        pDir;
    PINIPRINTER   pIniPrinter;
    PINIENVIRONMENT pIniEnvironment;
    PINIMONITOR   pIniMonitor;
    PINIPORT      pIniPort;
    PSHARED       pShared;
    PININETPRINT  pIniNetPrint;
    struct _SPOOL *pSpool;     /* Linked list of handles for this server */
    LPWSTR        pDefaultSpoolDir;
    LPWSTR        pszRegistryMonitors;
    LPWSTR        pszRegistryEnvironments;
    LPWSTR        pszRegistryEventLog;
    LPWSTR        pszRegistryProviders;
    LPWSTR        pszEventLogMsgFile;
    PVOID         pDriversShareInfo;
    LPWSTR        pszDriversShare;
    LPWSTR        pszRegistryForms;
    DWORD         SpoolerFlags;
    FARPROC       pfnReadRegistryExtra;
    FARPROC       pfnWriteRegistryExtra;
    FARPROC       pfnFreePrinterExtra;
    DWORD         cEnumerateNetworkPrinters;
    DWORD         cAddNetPrinters;
    DWORD         cFormOrderMax;
    LPWSTR        pNoRemotePrintDrivers;
    DWORD         cchNoRemotePrintDrivers;
    HKEY          hckRoot;
    HKEY          hckPrinters;
    DWORD         cFullPrintingJobs;
    HANDLE        hEventNoPrintingJobs;
    HANDLE        hJobIdMap;
    DWORD         dwEventLogging;
    BOOL          bEnableNetPopups;
    DWORD         dwJobCompletionTimeout;
    DWORD         dwBeepEnabled;
    BOOL          bEnableNetPopupToComputer;
    BOOL          bEnableRetryPopups;
    PWSTR         pszClusterGUID;
    HANDLE        hClusterToken;
    DWORD         dwRestartJobOnPoolTimeout;
    BOOL          bRestartJobOnPoolEnabled;
    BOOL          bImmortal;
    PWSTR         pszFullMachineName;
    HANDLE        hFilePool;
    LPWSTR        pszClusResDriveLetter;
    LPWSTR        pszClusResID;
    DWORD         dwClusNodeUpgraded;
    HANDLE        hClusSplReady;
    DWORD         dwSpoolerSettings;
} INISPOOLER, *PINISPOOLER;

//
// Flags for dwSpoolerSettings, 1 and 2 are used in .Net Server.
//
#define SPOOLER_CACHEMASQPRINTERS            0x00000004

#define ISP_SIGNATURE   'ISPL'

typedef struct _INIJOB {   /* ij */
    DWORD           signature;
    struct _INIJOB *pIniNextJob;
    struct _INIJOB *pIniPrevJob;
    DWORD           cRef;
    DWORD           Status;
    DWORD           JobId;
    DWORD           Priority;
    LPWSTR          pNotify;
    LPWSTR          pUser;
    LPWSTR          pMachineName;
    LPWSTR          pDocument;
    LPWSTR          pOutputFile;
    PINIPRINTER     pIniPrinter;
    PINIDRIVER      pIniDriver;
    LPDEVMODE       pDevMode;
    PINIPRINTPROC   pIniPrintProc;
    LPWSTR          pDatatype;
    LPWSTR          pParameters;
    SYSTEMTIME      Submitted;
    DWORD           Time;
    DWORD           StartTime;      /* print daily after time: from 00:00 in min */
    DWORD           UntilTime;      /* print daily until time: from 00:00 in min */
    DWORD           Size;
    HANDLE          hWriteFile;
    LPWSTR          pStatus;
    PVOID           pBuffer;
    DWORD           cbBuffer;
    HANDLE          WaitForRead;
    HANDLE          WaitForWrite;
    HANDLE          StartDocComplete;
    DWORD           StartDocError;
    PINIPORT        pIniPort;
    HANDLE          hToken;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD           cPagesPrinted;
    DWORD           cPages;
    BOOL            GenerateOnClose; /* Passed to security auditing APIs */
    DWORD           cbPrinted;
    DWORD           NextJobId;           // Job to be printed Next
    struct  _INIJOB *pCurrentIniJob;     // Current Job
    DWORD           dwJobControlsPending;
    DWORD           dwReboots;
    DWORD           dwValidSize;
    LARGE_INTEGER   liFileSeekPosn;
    BOOL            bWaitForEnd;
    HANDLE          WaitForSeek;
    BOOL            bWaitForSeek;
    DWORD           dwJobNumberOfPagesPerSide;
    DWORD           dwDrvNumberOfPagesPerSide;
    DWORD           cLogicalPages;        // number of pages in currently spooling page
    DWORD           cLogicalPagesPrinted; // number of pages in currently printing page
    DWORD           dwAlert;
    LPWSTR          pszSplFileName;
    HANDLE          hFileItem;
    DWORD           AddJobLevel;
#ifdef _HYDRA_
    ULONG           SessionId;        // Current jobs initial SessionId
#endif
#ifdef DEBUG_JOB_CREF
    PVOID           pvRef;
#endif

} INIJOB, *PINIJOB;


typedef struct _BUILTIN_FORM {
    DWORD          Flags;
    DWORD          NameId;
    SIZEL          Size;
    RECTL          ImageableArea;
} BUILTIN_FORM, *PBUILTIN_FORM;


#define IJ_SIGNATURE    0x494A  /* 'IJ' is the signature value */

//  WARNING
//  If you add a new JOB_ status field and it is INTERNAL to the spooler
//  Be sure to also to add it to JOB_STATUS_PRIVATE below (see LocalSetJob)
//  AND to the debug extensions ( dbgspl.c )

#define JOB_PRINTING            0x00000001
#define JOB_PAUSED              0x00000002
#define JOB_ERROR               0x00000004
#define JOB_OFFLINE             0x00000008
#define JOB_PAPEROUT            0x00000010
#define JOB_PENDING_DELETION    0x00000020
#define JOB_SPOOLING            0x00000040
#define JOB_DESPOOLING          0x00000080
#define JOB_DIRECT              0x00000100
#define JOB_COMPLETE            0x00000200
#define JOB_PRINTED             0x00000400
#define JOB_RESTART             0x00000800
#define JOB_REMOTE              0x00001000
#define JOB_NOTIFICATION_SENT   0x00002000
#define JOB_PRINT_TO_FILE       0x00040000
#define JOB_TYPE_ADDJOB         0x00080000
#define JOB_BLOCKED_DEVQ        0x00100000
#define JOB_SCHEDULE_JOB        0x00200000
#define JOB_TIMEOUT             0x00400000
#define JOB_ABANDON             0x00800000
#define JOB_DELETED             0x01000000
#define JOB_TRUE_EOJ            0x02000000
#define JOB_COMPOUND            0x04000000
#define JOB_TYPE_OPTIMIZE       0x08000000
#define JOB_PP_CLOSE            0x10000000
#define JOB_DOWNLEVEL           0x20000000
#define JOB_SHADOW_DELETED      0x40000000
#define JOB_INTERRUPTED         0x80000000
#define JOB_HIDDEN              JOB_COMPOUND

//
// These flags should be saved when we are updating job
// status.  (They are not settable.)

#define JOB_STATUS_PRIVATE (JOB_DESPOOLING | JOB_DIRECT | JOB_COMPLETE | \
                            JOB_RESTART | JOB_PRINTING | JOB_REMOTE | \
                            JOB_SPOOLING | JOB_PRINTED | JOB_PENDING_DELETION |\
                            JOB_ABANDON | JOB_TIMEOUT | JOB_SCHEDULE_JOB | \
                            JOB_BLOCKED_DEVQ | JOB_TYPE_ADDJOB | JOB_PRINT_TO_FILE |\
                            JOB_NOTIFICATION_SENT | JOB_DELETED | JOB_TRUE_EOJ | JOB_COMPOUND |\
                            JOB_TYPE_OPTIMIZE | JOB_PP_CLOSE | JOB_DOWNLEVEL | JOB_INTERRUPTED)

#define JOB_NO_ALERT            0x00000001
#define JOB_ENDDOC_CALL         0x00000002

typedef enum _ESTATUS {
    STATUS_NULL = 0,
    STATUS_FAIL = 0,
    STATUS_PORT = 1,
    STATUS_INFO = 2,
    STATUS_VALID = 4,
    STATUS_PENDING_DELETION = 8,
} ESTATUS;

typedef struct _SPLMAPVIEW {
    struct _SPLMAPVIEW *pNext;
    HANDLE              hMapSpoolFile;
    LPBYTE              pStartMapView;
    DWORD               dwMapSize;
} SPLMAPVIEW, *PSPLMAPVIEW;

typedef struct _MAPPED_JOB {
    struct _MAPPED_JOB *pNext;
    LPWSTR              pszSpoolFile;
    DWORD               JobId;
} MAPPED_JOB, *PMAPPED_JOB;

typedef struct _SPOOL {
    DWORD           signature;
    struct _SPOOL  *pNext;
    DWORD           cRef;
    LPWSTR          pName;
    LPWSTR          pFullMachineName;
    LPWSTR          pDatatype;
    PINIPRINTPROC   pIniPrintProc;
    LPDEVMODE       pDevMode;
    PINIPRINTER     pIniPrinter;
    PINIPORT        pIniPort;
    PINIJOB         pIniJob;
    DWORD           TypeofHandle;
    PINIPORT        pIniNetPort;    /* Non-NULL if there's a network port */
    HANDLE          hPort;
    DWORD           Status;
    ACCESS_MASK     GrantedAccess;
    DWORD           ChangeFlags;
    DWORD           WaitFlags;
    PDWORD          pChangeFlags;
    HANDLE          ChangeEvent;
    DWORD           OpenPortError;
    HANDLE          hNotify;
    ESTATUS         eStatus;
    PINISPOOLER     pIniSpooler;
    PINIXCV         pIniXcv;
    BOOL            GenerateOnClose;
    HANDLE          hFile;
    DWORD           adwNotifyVectors[NOTIFY_TYPE_MAX];
    HANDLE          hReadFile;        // allow multiple readers of a single job
    SPLCLIENT_INFO_1 SplClientInfo1;
    PSPLMAPVIEW     pSplMapView;
    PMAPPED_JOB     pMappedJob;
#ifdef _HYDRA_
    ULONG           SessionId;
#endif
} SPOOL;

typedef SPOOL *PSPOOL;
#define SPOOL_SIZE  sizeof( SPOOL )

#define SJ_SIGNATURE    0x464D  /* 'FM' is the signature value */

#define MAX_SPL_MAPVIEW_SIZE     0x00050000   // Max view size if 5x64K. It should be a multiple
                                              // of the allocation granularity (64K)

typedef struct _SPOOLIC {
    DWORD signature;
    PINIPRINTER pIniPrinter;
} SPOOLIC, *PSPOOLIC;

#define IC_SIGNATURE 0x4349 /* 'CI' is the signature value */

#define SPOOL_STATUS_STARTDOC       0x00000001
#define SPOOL_STATUS_BEGINPAGE      0x00000002
#define SPOOL_STATUS_CANCELLED      0x00000004
#define SPOOL_STATUS_PRINTING       0x00000008
#define SPOOL_STATUS_ADDJOB         0x00000010
#define SPOOL_STATUS_PRINT_FILE     0x00000020
#define SPOOL_STATUS_NOTIFY         0x00000040
#define SPOOL_STATUS_ZOMBIE         0x00000080
#define SPOOL_STATUS_FLUSH_PRINTER  0x00000100

#define PRINTER_HANDLE_PRINTER      0x00000001
#define PRINTER_HANDLE_JOB          0x00000002
#define PRINTER_HANDLE_PORT         0x00000004
#define PRINTER_HANDLE_DIRECT       0x00000008
#define PRINTER_HANDLE_SERVER       0x00000010
#define PRINTER_HANDLE_3XCLIENT     0x00000020
#define PRINTER_HANDLE_REMOTE_CALL  0x00000040 // Client is remote
#define PRINTER_HANDLE_REMOTE_DATA  0x00000080 // Data should appear remote
#define PRINTER_HANDLE_XCV_PORT     0x00000100
#define PRINTER_HANDLE_REMOTE_ADMIN 0x00000200 // User is remote admin (may not have requested admin privileges)

//
// We need to distinguish between remote users and remote data since
// the server service Opens with \\server\printer (for clustering) yet
// this is a remote call.  AddJob should succeed, but the data from
// GetPrinterDriver should appear remote.
//

#define INVALID_PORT_HANDLE     NULL    /* winspool tests for NULL handles */

typedef struct _SHADOWFILE {   /* sf */
    DWORD           signature;
    DWORD           Status;
    DWORD           JobId;
    DWORD           Priority;
    LPWSTR          pNotify;
    LPWSTR          pUser;
    LPWSTR          pDocument;
    LPWSTR          pOutputFile;
    LPWSTR          pPrinterName;
    LPWSTR          pDriverName;
    LPDEVMODE       pDevMode;
    LPWSTR          pPrintProcName;
    LPWSTR          pDatatype;
    LPWSTR          pParameters;
    SYSTEMTIME      Submitted;
    DWORD           StartTime;
    DWORD           UntilTime;
    DWORD           Size;
    DWORD           cPages;
    DWORD           cbSecurityDescriptor;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD           NextJobId;
} SHADOWFILE, *PSHADOWFILE;

#define SF_SIGNATURE    0x494B  /* 'IK' is the signature value */


typedef struct _SHADOWFILE_2 {   /* Sf */
    DWORD           signature;
    DWORD           Status;
    DWORD           JobId;
    DWORD           Priority;
    LPWSTR          pNotify;
    LPWSTR          pUser;
    LPWSTR          pDocument;
    LPWSTR          pOutputFile;
    LPWSTR          pPrinterName;
    LPWSTR          pDriverName;
    LPDEVMODE       pDevMode;
    LPWSTR          pPrintProcName;
    LPWSTR          pDatatype;
    LPWSTR          pParameters;
    SYSTEMTIME      Submitted;
    DWORD           StartTime;
    DWORD           UntilTime;
    DWORD           Size;
    DWORD           cPages;
    DWORD           cbSecurityDescriptor;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD           NextJobId;
    DWORD           Version;
    DWORD           dwReboots;      // If read at ReadShadowJob, this is number of reboots
                                    // done while printing this job
} SHADOWFILE_2, *PSHADOWFILE_2;

#define SF_SIGNATURE_2    0x4966  /* 'If' is the signature value */

typedef struct _SHADOWFILE_3 {   /* Sg */
    DWORD           signature;
    DWORD           cbSize;
    DWORD           Status;
    DWORD           JobId;
    DWORD           Priority;
    LPWSTR          pNotify;
    LPWSTR          pUser;
    LPWSTR          pDocument;
    LPWSTR          pOutputFile;
    LPWSTR          pPrinterName;
    LPWSTR          pDriverName;
    LPDEVMODE       pDevMode;
    LPWSTR          pPrintProcName;
    LPWSTR          pDatatype;
    LPWSTR          pParameters;
    SYSTEMTIME      Submitted;
    DWORD           StartTime;
    DWORD           UntilTime;
    DWORD           Size;
    DWORD           cPages;
    DWORD           cbSecurityDescriptor;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD           NextJobId;
    DWORD           Version;
    DWORD           dwReboots;      // If read at ReadShadowJob, this is number of reboots
                                    // done while printing this job
    LPWSTR          pMachineName;
    DWORD           dwValidSize;
} SHADOWFILE_3, *PSHADOWFILE_3;

#define SF_SIGNATURE_3    0x4967  /* 'Ig' is the signature value */
#define SF_VERSION_3    3

typedef struct
{
    HANDLE          hUserToken;
    PINIPRINTER     pIniPrinter;

} MasqUpdateThreadData;

#define FindEnvironment( psz, pIniSpooler )                                 \
    (PINIENVIRONMENT)FindIniKey( (PINIENTRY)pIniSpooler->pIniEnvironment,   \
                                 (LPWSTR)(psz) )

#define FindPort( psz, pIniSpooler )                                        \
    (PINIPORT)FindIniKey( (PINIENTRY)pIniSpooler->pIniPort,                 \
                          (LPWSTR)(psz))

#define FindPrinter( psz,pIniSpooler )                                      \
    (PINIPRINTER)FindIniKey( (PINIENTRY)pIniSpooler->pIniPrinter,           \
                             (LPWSTR)(psz) )

#define FindPrintProc( psz, pEnv )                                          \
    (PINIPRINTPROC)FindIniKey( (PINIENTRY)(pEnv)->pIniPrintProc,            \
                               (LPWSTR)(psz) )

#define FindForm( psz, pIniSpooler )                                        \
    (PINIFORM)FindIniKey( (PINIENTRY)pIniSpooler->pShared->pIniForm,        \
                          (LPWSTR)(psz) )

#define FindMonitor( psz, pIniSpooler )                                     \
    (PINIMONITOR)FindIniKey( (PINIENTRY)pIniSpooler->pIniMonitor,           \
                             (LPWSTR)(psz) )

PINISPOOLER
FindSpooler(
    LPCTSTR pszMachine,
    DWORD SpoolerFlags
    );

#define RESIZEPORTPRINTERS(a, c)   ReallocSplMem((a)->ppIniPrinter, \
                                     (a)->cPrinters * sizeof((a)->ppIniPrinter), \
                                   ( (a)->cPrinters + (c) ) * sizeof( (a)->ppIniPrinter ) )

#define RESIZEPRINTERPORTS(a, c)   ReallocSplMem((a)->ppIniPorts, \
                                     (a)->cPorts * sizeof((a)->ppIniPorts), \
                                   ( (a)->cPorts + (c) ) * sizeof( (a)->ppIniPorts ) )

#define BIT(index) (1<<index)
#define BIT_ALL ((DWORD)~0)
#define BIT_NONE 0


//
// Enumerations for index tables.
//
enum {
#define DEFINE(field, x, y, table, offset) I_PRINTER_##field,
#include <ntfyprn.h>
#undef DEFINE
    I_PRINTER_END
};

enum {
#define DEFINE(field, x, y, table, offset) I_JOB_##field,
#include <ntfyjob.h>
#undef DEFINE
    I_JOB_END
};


#ifdef DEBUG_STARTENDDOC

#define STARTENDDOC(hPort, pIniJob, flags) DbgStartEndDoc(hPort, pIniJob, flags )

VOID
DbgStartEndDoc(
    HANDLE hPort,
    PINIJOB pIniJob,
    DWORD dwFlags
    );

#else

#define STARTENDDOC(hPort, pIniJob, flags)

#endif

#ifdef DEBUG_JOB_CREF

#define INCJOBREF(pIniJob) DbgJobIncRef(pIniJob)
#define DECJOBREF(pIniJob) DbgJobDecRef(pIniJob)

#define INITJOBREFZERO(pIniJob) DbgJobInit(pIniJob)
#define INITJOBREFONE(pIniJob) { DbgJobInit(pIniJob); DbgJobIncRef(pIniJob); }
#define DELETEJOBREF(pIniJob) DbgJobFree(pIniJob)

VOID
DbgJobIncRef(
    PINIJOB pIniJob);

VOID
DbgJobDecRef(
    PINIJOB pIniJob);


VOID
DbgJobInit(
    PINIJOB pIniJob);

VOID
DbgJobFree(
    PINIJOB pIniJob);

#else

#define INCJOBREF(pIniJob) pIniJob->cRef++
#define DECJOBREF(pIniJob) pIniJob->cRef--

#define INITJOBREFONE(pIniJob) (pIniJob->cRef = 1)
#define INITJOBREFZERO(pIniJob)

#define DELETEJOBREF(pIniJob)

#endif

#ifdef DEBUG_PRINTER_CREF
VOID
DbgPrinterInit(
    PINIPRINTER pIniPrinter);

VOID
DbgPrinterFree(
    PINIPRINTER pIniPrinter);

VOID
DbgPrinterIncRef(
    PINIPRINTER pIniPrinter);

VOID
DbgPrinterDecRef(
    PINIPRINTER pIniPrinter);
#else
#define DbgPrinterInit(pIniPrinter)
#define DbgPrinterFree(pIniPrinter)
#define DbgPrinterIncRef(pIniPrinter)
#define DbgPrinterDecRef(pIniPrinter)
#endif


#define INCPRINTERREF(pIniPrinter) { SPLASSERT( pIniPrinter->signature == IP_SIGNATURE ); \
                                     pIniPrinter->cRef++;                                 \
                                     DbgPrinterIncRef(pIniPrinter);                       \
                                     if ( pIniPrinter->cRef > pIniPrinter->MaxcRef) {     \
                                        pIniPrinter->MaxcRef = pIniPrinter->cRef;         \
                                     }                                                    \
                                   }
#define DECPRINTERREF(pIniPrinter) { SPLASSERT( pIniPrinter->signature == IP_SIGNATURE ); \
                                     SPLASSERT( pIniPrinter->cRef != 0 );                 \
                                     pIniPrinter->cRef--;                                 \
                                     DbgPrinterDecRef(pIniPrinter);                       \
                                   }

#define INC_PRINTER_ZOMBIE_REF(pIniPrinter) pIniPrinter->cZombieRef++
#define DEC_PRINTER_ZOMBIE_REF(pIniPrinter) pIniPrinter->cZombieRef--


#if DBG

#define INCSPOOLERREF(pIniSpooler)                                  \
{                                                                   \
    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );           \
    if( gpDbgPointers ) {                                           \
        gpDbgPointers->pfnCaptureBackTrace( ghbtClusterRef,         \
                                            (ULONG_PTR)pIniSpooler,  \
                                            pIniSpooler->cRef,      \
                                            pIniSpooler->cRef + 1 );\
    }                                                               \
    pIniSpooler->cRef++;                                            \
}

#define DECSPOOLERREF(pIniSpooler)                                  \
{                                                                   \
    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );           \
    SPLASSERT( pIniSpooler->cRef != 0 );                            \
    if( gpDbgPointers ) {                                           \
        gpDbgPointers->pfnCaptureBackTrace( ghbtClusterRef,         \
                                            (ULONG_PTR)pIniSpooler,  \
                                            pIniSpooler->cRef,      \
                                            pIniSpooler->cRef - 1 );\
    }                                                               \
    --pIniSpooler->cRef;                                            \
    DeleteSpoolerCheck( pIniSpooler );                              \
}

#else

#define INCSPOOLERREF(pIniSpooler)                                  \
{                                                                   \
    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );           \
    pIniSpooler->cRef++;                                            \
}

#define DECSPOOLERREF(pIniSpooler)                                  \
{                                                                   \
    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );           \
    SPLASSERT( pIniSpooler->cRef != 0 );                            \
    --pIniSpooler->cRef;                                            \
    DeleteSpoolerCheck( pIniSpooler );                              \
}

#endif


#define INCPORTREF(pIniPort) { SPLASSERT( pIniPort->signature == IPO_SIGNATURE ); \
                                     ++pIniPort->cRef;  \
                                    }

#define DECPORTREF(pIniPort) { SPLASSERT( pIniPort->signature == IPO_SIGNATURE ); \
                               SPLASSERT( pIniPort->cRef != 0 ); \
                                     --pIniPort->cRef;  \
                                    }

#define INCMONITORREF(pIniMonitor) { SPLASSERT( pIniMonitor->signature == IMO_SIGNATURE ); \
                                     ++pIniMonitor->cRef;  \
                                   }

#define DECMONITORREF(pIniMonitor) { SPLASSERT( pIniMonitor->signature == IMO_SIGNATURE ); \
                                     SPLASSERT( pIniMonitor->cRef != 0 ); \
                                     --pIniMonitor->cRef;  \
                                   }

extern DWORD    IniDriverOffsets[];
extern DWORD    IniPrinterOffsets[];
extern DWORD    IniSpoolerOffsets[];
extern DWORD    IniEnvironmentOffsets[];
extern DWORD    IniPrintProcOffsets[];

#define INCDRIVERREF( pIniDriver ) { SPLASSERT( pIniDriver->signature == ID_SIGNATURE ); \
                                     pIniDriver->cRef++;                                 \
                                   }

#define DECDRIVERREF( pIniDriver ) { SPLASSERT( pIniDriver->signature == ID_SIGNATURE ); \
                                     SPLASSERT( pIniDriver->cRef != 0 );                 \
                                     pIniDriver->cRef--;                                 \
                                   }

#define DEFAULT_SERVER_THREAD_PRIORITY          THREAD_PRIORITY_NORMAL
#define DEFAULT_SPOOLER_PRIORITY                THREAD_PRIORITY_NORMAL
#define DEFAULT_PORT_THREAD_PRIORITY            THREAD_PRIORITY_NORMAL
#define DEFAULT_SCHEDULER_THREAD_PRIORITY       THREAD_PRIORITY_NORMAL
#define DEFAULT_JOB_COMPLETION_TIMEOUT          160000
#define DEFAULT_JOB_RESTART_TIMEOUT_ON_POOL_ERROR          600 // 10 minutes

#define PortToPrinterStatus(dwPortStatus) (PortToPrinterStatusMappings[dwPortStatus])

extern PWCHAR ipszRegistryPrinters;
extern PWCHAR ipszRegistryMonitors;
extern PWCHAR ipszRegistryProviders;
extern PWCHAR ipszRegistryEnvironments;
extern PWCHAR ipszClusterDatabaseEnvironments;
extern PWCHAR ipszRegistryForms;
extern PWCHAR ipszEventLogMsgFile;
extern PWCHAR ipszDriversShareName;
extern PWCHAR ipszRegistryEventLog;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\ssp.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    ssp.cxx

Abstract:

    This file wraps around wintrust functions.

Author:

    Larry Zhu   (LZhu)             6-Apr-2001  Created.

Environment:

    User Mode -Win32

Revision History:

    Robert Orleth (ROrleth)        7-Apr-2001 Contributed the following APIs:
                           
         AddCatalogDirect

--*/

#include "precomp.h"
#pragma hdrstop

#include "ssp.hxx"

TSSP::
TSSP(
    VOID
    ) : m_hLibrary(NULL),
        m_pfnCryptCATAdminAcquireContext(NULL),
        m_pfnCryptCATAdminAddCatalog(NULL),
        m_pfnCryptCATAdminReleaseCatalogContext(NULL),
        m_pfnCryptCATAdminReleaseContext(NULL),
        m_pfnWinVerifyTrust(NULL),
        m_hr(E_FAIL)
{
    m_hr = Initialize();
}

TSSP::
~TSSP(
    VOID
    )
{
    if (m_hLibrary)
    {
        (void)FreeLibrary(m_hLibrary);
    }
}

HRESULT
TSSP::
IsValid(
    VOID
    ) const
{
    return m_hr;
}

/*++

Routine Name:

    AddCatalogDirect

Routine Description:

    This routine installs a catalog file, this routine must run with Admin
    privilege.

Arguments:

    pszCatalogFullPath  - Supplies the fully-qualified win32 path of the 
                          catalog to be installed on the system
    pszCatNameOnSystem -  Catalog name used under CatRoot

Return Value:
   
    An HRESULT
    
--*/
HRESULT
TSSP::
AddCatalogDirect(
    IN    PCWSTR       pszCatalogFullPath,
    IN    PCWSTR       pszCatNameOnSystem     OPTIONAL
    )
{
    HRESULT   hRetval     = E_FAIL;
    GUID      guidDriver  = DRIVER_ACTION_VERIFY;
    HCATINFO  hCatInfo    = NULL;
    HCATADMIN hCatAdmin   = NULL;

    hRetval = pszCatalogFullPath ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = m_pfnCryptCATAdminAcquireContext(&hCatAdmin, &guidDriver, 0) ? S_OK : GetLastErrorAsHResultAndFail();
    }

    if (SUCCEEDED(hRetval))
    {
        hCatInfo = m_pfnCryptCATAdminAddCatalog(hCatAdmin, 
                                                const_cast<PWSTR>(pszCatalogFullPath), 
                                                const_cast<PWSTR>(pszCatNameOnSystem),
                                                0);
        hRetval = hCatInfo ? S_OK : GetLastErrorAsHResultAndFail(); 
    }

    if (SUCCEEDED(hRetval)) 
    {
        (void)m_pfnCryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
    }

    if (hCatAdmin) 
    {
        (void)m_pfnCryptCATAdminReleaseContext(hCatAdmin, 0);
    }
   
    return hRetval;
}

/*++

Routine Name:

    VerifyCatalog

Routine Description:

    This routine verifies a single catalog file. A catalog file is
    "self-verifying" in that there is no additional file or data required
    to verify it.

Arguments:

    pszCatalogFullPath - Supplies the fully-qualified Win32 path of the catalog
                         file to be verified

Return Value:

    An HRESULT
    
--*/
HRESULT
TSSP::
VerifyCatalog(
    IN     PCWSTR      pszCatalogFullPath
    )
{
    HRESULT            hRetval          = E_FAIL;    
    GUID               DriverVerifyGuid = DRIVER_ACTION_VERIFY;
    WINTRUST_DATA      WintrustData     = {0};
    WINTRUST_FILE_INFO WintrustFileInfo = {0};

    hRetval = pszCatalogFullPath ? S_OK : E_INVALIDARG;  
    
    if (SUCCEEDED(hRetval)) 
    {
        WintrustFileInfo.cbStruct        = sizeof(WINTRUST_FILE_INFO);
        WintrustFileInfo.pcwszFilePath   = pszCatalogFullPath;
 
        WintrustData.cbStruct            = sizeof(WINTRUST_DATA);
        WintrustData.dwUIChoice          = WTD_UI_NONE;
        WintrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
        WintrustData.dwUnionChoice       = WTD_CHOICE_FILE;
        WintrustData.pFile               = &WintrustFileInfo;
        WintrustData.dwProvFlags         = WTD_REVOCATION_CHECK_NONE;
    
        //
        // WinVerifyTrust uses INVALID_HANDLE_VALUE as hwnd handle for 
        // non-interactive operations. Do NOT pass a NULL as hwnd, since that 
        // will cause the trust provider to interact with users using the 
        // interactive desktop! Refer to SDK for details
        //
        hRetval = m_pfnWinVerifyTrust(INVALID_HANDLE_VALUE, &DriverVerifyGuid, &WintrustData);
    }

    return hRetval;
}

/******************************************************************************

    Private Methods
    
******************************************************************************/    
/*++

Routine Name:

    Initialize

Routine Description:

    Load the system restore library and get the addresses of ssp functions.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT
TSSP::
Initialize(
    VOID
    )
{    
    HRESULT hRetval = E_FAIL;

    m_hLibrary = LoadLibrary(L"wintrust.dll");

    hRetval = m_hLibrary ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval))
    {
        m_pfnCryptCATAdminAcquireContext = reinterpret_cast<PFuncCryptCATAdminAcquireContext>(GetProcAddress(m_hLibrary, "CryptCATAdminAcquireContext"));

        hRetval = m_pfnCryptCATAdminAddCatalog ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        m_pfnCryptCATAdminAddCatalog = reinterpret_cast<PFuncCryptCATAdminAddCatalog>(GetProcAddress(m_hLibrary, "CryptCATAdminAddCatalog"));
    
        hRetval = m_pfnCryptCATAdminAddCatalog ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        m_pfnCryptCATAdminReleaseContext = reinterpret_cast<PFuncCryptCATAdminReleaseContext>(GetProcAddress(m_hLibrary, "CryptCATAdminReleaseContext"));
    
        hRetval = m_pfnCryptCATAdminReleaseContext ? S_OK : GetLastErrorAsHResult();
    }
    
    if (SUCCEEDED(hRetval))
    {
        m_pfnCryptCATAdminReleaseCatalogContext = reinterpret_cast<PFuncCryptCATAdminReleaseCatalogContext>(GetProcAddress(m_hLibrary, "CryptCATAdminReleaseCatalogContext"));
    
        hRetval = m_pfnCryptCATAdminReleaseCatalogContext ? S_OK : GetLastErrorAsHResult();
    }
    
    if (SUCCEEDED(hRetval))
    {
        m_pfnWinVerifyTrust = reinterpret_cast<PFuncWinVerifyTrust>(GetProcAddress(m_hLibrary, "WinVerifyTrust"));
    
        hRetval = m_pfnWinVerifyTrust ? S_OK : GetLastErrorAsHResult();
    }
    
    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\spoolsec.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    spoolsec.h

Abstract:

    Header file for print security

Author:

    Not known

Revision History:

    06-Apr-2001       AMaxa    CheckPrivilegePresent
    
--*/

#ifndef _SPOOLSEC_H_
#define _SPOOLSEC_H_

#ifdef __cplusplus
extern "C" {
#endif

// Object types
//

#define SPOOLER_OBJECT_SERVER   0
#define SPOOLER_OBJECT_PRINTER  1
#define SPOOLER_OBJECT_DOCUMENT 2
#define SPOOLER_OBJECT_COUNT    3
#define SPOOLER_OBJECT_XCV      4

/* These access bits must be different from those exposed in winspool.h,
 * so that no auditing takes place when we do an access check against them:
 */
#define SERVER_ACCESS_ADMINISTER_PRIVATE    0x00000004
#define PRINTER_ACCESS_ADMINISTER_PRIVATE   0x00000008
#define JOB_ACCESS_ADMINISTER_PRIVATE       0x00000080

enum
{
    kGuessTokenPrivileges = 1024
};

PSECURITY_DESCRIPTOR
CreateServerSecurityDescriptor(
    VOID
);

PSECURITY_DESCRIPTOR
CreatePrinterSecurityDescriptor(
    PSECURITY_DESCRIPTOR pCreatorSecurityDescriptor
);

PSECURITY_DESCRIPTOR
CreateDocumentSecurityDescriptor(
    PSECURITY_DESCRIPTOR pPrinterSecurityDescriptor
);

BOOL
SetPrinterSecurityDescriptor(
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pModificationDescriptor,
    PSECURITY_DESCRIPTOR *ppObjectsSecurityDescriptor
);

BOOL
DeletePrinterSecurity(
    PINIPRINTER pIniPrinter
);

BOOL
DeleteDocumentSecurity(
    PINIJOB pIniJob
);

PSECURITY_DESCRIPTOR
CreateEverybodySecurityDescriptor(
    VOID
);

BOOL
ValidateObjectAccess(
    DWORD       ObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID      ObjectHandle,
    PACCESS_MASK pGrantedAccess,
    PINISPOOLER pIniSpooler
);

BOOL
AccessGranted(
    DWORD       ObjectType,
    ACCESS_MASK DesiredAccess,
    PSPOOL      pSpool
);

VOID MapGenericToSpecificAccess(
    DWORD ObjectType,
    DWORD GenericAccess,
    PDWORD pSpecificAccess
);

BOOL
GetTokenHandle(
    PHANDLE TokenHandle
);

BOOL
GetSecurityInformation(
    PSECURITY_DESCRIPTOR  pSecurityDescriptor,
    PSECURITY_INFORMATION pSecurityInformation
);

ACCESS_MASK
GetPrivilegeRequired(
    SECURITY_INFORMATION SecurityInformation
);

BOOL
BuildPartialSecurityDescriptor(
    ACCESS_MASK          AccessGranted,
    PSECURITY_DESCRIPTOR pSourceSecurityDescriptor,
    PSECURITY_DESCRIPTOR *ppPartialSecurityDescriptor,
    PDWORD               pPartialSecurityDescriptorLength
);

PSECURITY_DESCRIPTOR
CreateDriversShareSecurityDescriptor(
    VOID
);

PSECURITY_DESCRIPTOR
CreatePrintShareSecurityDescriptor(
    VOID
);

BOOL
InitializeSecurityStructures(
    VOID
    );

DWORD
PrincipalIsRemoteGuest(
    IN  HANDLE  hToken,
    OUT BOOL   *pbRemoteGuest
    );

DWORD
CheckPrivilegePresent(
    IN     HANDLE   hToken,
    IN     PLUID    pLuid,
    IN OUT LPBOOL   pbPresent,
    IN OUT LPDWORD  pAttributes OPTIONAL
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\spooler.c ===
/*++

Copyright (c) 1990 - 1996  Microsoft Corporation

Module Name:

    spooler.c

Abstract:

    This module provides all the public exported APIs relating to spooling
    and printing for the Local Print Providor. They include

    LocalStartDocPrinter
    LocalWritePrinter
    LocalReadPrinter
    LocalEndDocPrinter
    LocalAbortPrinter

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

#include "jobid.h"
#include "filepool.hxx"

//extern HANDLE hFilePool;

BOOL
SpoolThisJob(
    PSPOOL  pSpool,
    DWORD   Level,
    LPBYTE  pDocInfo
);

BOOL
PrintingDirectlyToPort(
    PSPOOL  pSpool,
    DWORD   Level,
    LPBYTE  pDocInfo,
    LPDWORD pJobId
);

BOOL
PrintingDirect(
    PSPOOL  pSpool,
    DWORD   Level,
    LPBYTE  pDocInfo
);

DWORD
ReadFromPrinter(
    PSPOOL  pSpool,
    LPBYTE  pBuf,
    DWORD   cbBuf
);

BOOL
InternalReadPrinter(
   HANDLE   hPrinter,
   LPVOID   pBuf,
   DWORD    cbBuf,
   LPBYTE   *pMapBuffer,
   LPDWORD  pNoBytesRead,
   BOOL     bReadMappedView
);

BOOL SetMappingPointer(
    PSPOOL pSpool,
    LPBYTE *pMappedBuffer,
    DWORD  cbReadSize
);

DWORD
WriteToPrinter(
    PSPOOL  pSpool,
    LPBYTE  pByte,
    DWORD   cbBuf
);

BOOL
IsGoingToFile(
    LPWSTR pOutputFile,
    PINISPOOLER pIniSpooler
    );

VOID
MyPostThreadMessage(
    IN HANDLE   hThread,
    IN DWORD    idThread,
    IN UINT     Msg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    SplOutSem();

    //
    // PostThreadMessage will fail under the following cases:
    //      a. Too early -- MessageBox has not been created yet
    //      b. Too late -- User has cancelled the dialog
    //
    // In case a. if we wait for few seconds and retry Post will succeed
    // In case b. WaitForSingleObject on thread handle will return WAIT_OBJECT_O
    //
    while ( !PostThreadMessage(idThread, Msg, wParam, lParam) ) {

        DBGMSG(DBG_WARNING, ("PostThreadMessage FAILED %d\n", GetLastError()));

        //
        // As far as thread is alive after 1 second retry the post
        //
        if ( WaitForSingleObject(hThread, 1000) != WAIT_TIMEOUT )
            break;
    }
}


VOID
SeekPrinterSetEvent(
    PINIJOB  pIniJob,
    HANDLE   hFile,
    BOOL     bEndDoc
    )
{
    DWORD    dwFileSizeHigh,dwFileSizeLow;

    if (!hFile) {
       hFile = pIniJob->hWriteFile;
    }

    if (pIniJob->bWaitForSeek && pIniJob->WaitForSeek != NULL ){

       if (!bEndDoc) {

          // Compare the sizes.
          if (pIniJob->Status & JOB_TYPE_OPTIMIZE) {
              dwFileSizeHigh = 0;
              dwFileSizeLow = pIniJob->dwValidSize;
          } else {
              dwFileSizeLow = GetFileSize(hFile, &dwFileSizeHigh);
              if ((dwFileSizeLow == 0xffffffff) && (GetLastError() != NO_ERROR)) {
                  return;
              }
          }

          if ((pIniJob->liFileSeekPosn.u.HighPart > (LONG)dwFileSizeHigh) ||
              ((pIniJob->liFileSeekPosn.u.HighPart == (LONG)dwFileSizeHigh) &&
               (pIniJob->liFileSeekPosn.u.LowPart > dwFileSizeLow))) {
             return;
          }

       }

       SetEvent(pIniJob->WaitForSeek);
    }

    return;
}


DWORD
LocalStartDocPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    PINIPRINTER pIniPrinter;
    PINIPORT    pIniPort;
    PSPOOL      pSpool=(PSPOOL)hPrinter;
    DWORD       LastError=0, JobId=0;
    PDOC_INFO_1 pDocInfo1 = (PDOC_INFO_1)pDocInfo;
    BOOL        bPrintingDirect;

    SPLASSERT(Level == 1);

    if (ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER ) &&
       !(pSpool->Status & SPOOL_STATUS_STARTDOC) &&
       !(pSpool->Status & SPOOL_STATUS_ADDJOB)) {

        if ((pSpool->TypeofHandle & PRINTER_HANDLE_PORT) &&
             (pIniPort = pSpool->pIniPort) &&
             (pIniPort->signature == IPO_SIGNATURE)) {

            if (!(PrintingDirectlyToPort(pSpool, Level, pDocInfo, &JobId))) {
                return FALSE;
            }

        } else if ((pSpool->TypeofHandle & PRINTER_HANDLE_PRINTER) &&
                   (pIniPrinter = pSpool->pIniPrinter)) {

            bPrintingDirect = FALSE;

            if (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DIRECT) {

                bPrintingDirect = TRUE;

            } else {

                EnterSplSem();
                bPrintingDirect = IsGoingToFile(pDocInfo1->pOutputFile,
                                                pSpool->pIniSpooler);

                LeaveSplSem();
            }

            if (bPrintingDirect) {

                if (!PrintingDirect(pSpool, Level, pDocInfo))
                    return FALSE;

            } else {

                if (!SpoolThisJob(pSpool, Level, pDocInfo))
                    return FALSE;
            }

        } else

            LastError = ERROR_INVALID_PARAMETER;

        if (!LastError) {
            pSpool->Status |= SPOOL_STATUS_STARTDOC;
            pSpool->Status &= ~SPOOL_STATUS_CANCELLED;
        }

    } else

        LastError = ERROR_INVALID_HANDLE;


    if (LastError) {
       DBGMSG(DBG_WARNING, ("StartDoc FAILED %d\n", LastError));
        SetLastError(LastError);
        return FALSE;
    }

    if (JobId)
        return JobId;
    else
        return pSpool->pIniJob->JobId;
}

BOOL
LocalStartPagePrinter(
    HANDLE  hPrinter
    )
/*++

    Bug-Bug:  StartPagePrinter and EndPagePrinter calls should be
    supported only for SPOOL_STATUS_STARTDOC handles only. However
    because of our fixes for the engine, we cannot fail StartPagePrinter
    and EndPagePrinter for SPOOL_STATUS_ADDJOB as well.

--*/

{
    PSPOOL pSpool = (PSPOOL)hPrinter;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwFileSize;


    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {
        return(FALSE);
    }
    if (pSpool->Status & SPOOL_STATUS_CANCELLED) {
        SetLastError(ERROR_PRINT_CANCELLED);
        return FALSE;
    }

    if (pSpool->pIniJob != NULL) {

        if ( (pSpool->TypeofHandle & PRINTER_HANDLE_PORT) &&
            ((pSpool->pIniJob->Status & JOB_PRINTING) ||
             (pSpool->pIniJob->Status & JOB_DESPOOLING))) {

        //
        //  Account for Pages Printed in LocalEndPagePrinter
        //


        } else {

            // We Are Spooling
            UpdateJobAttributes(pSpool->pIniJob);

            pSpool->pIniJob->cLogicalPages++;
            if (pSpool->pIniJob->cLogicalPages >=
                   pSpool->pIniJob->dwJobNumberOfPagesPerSide)
            {
                pSpool->pIniJob->cLogicalPages = 0;
                pSpool->pIniJob->cPages++;
            }

            if ( pSpool->pIniJob->Status & JOB_TYPE_ADDJOB ) {

                // If the Job is being written on the client side
                // the size is not getting updated so do it now on
                // the start page

                if ( pSpool->hReadFile != INVALID_HANDLE_VALUE ) {

                    hFile = pSpool->hReadFile;

                } else {

                    hFile = pSpool->pIniJob->hWriteFile;

                }

                if ( hFile != INVALID_HANDLE_VALUE ) {

                    dwFileSize = GetFileSize( hFile, 0 );

                    if ( pSpool->pIniJob->Size < dwFileSize ) {

                         DBGMSG( DBG_TRACE, ("StartPagePrinter adjusting size old %d new %d\n",
                            pSpool->pIniJob->Size, dwFileSize));

                         pSpool->pIniJob->dwValidSize = pSpool->pIniJob->Size;
                         pSpool->pIniJob->Size = dwFileSize;

                         // Support for despooling whilst spooling
                         // for Down Level jobs

                         if (pSpool->pIniJob->WaitForWrite != NULL)
                            SetEvent( pSpool->pIniJob->WaitForWrite );
                    }

                }
            }

        }

    } else {
        DBGMSG(DBG_TRACE, ("StartPagePrinter issued with no Job\n"));
    }



    return TRUE;
}

PINIPORT
FindFilePort(
    LPWSTR pFileName,
    PINISPOOLER pIniSpooler)
{
    PINIPORT pIniPort;

    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );

    pIniPort = pIniSpooler->pIniPort;
    while (pIniPort) {
        if (!wcscmp(pIniPort->pName, pFileName)
                && (pIniPort->Status & PP_FILE)){
                    return (pIniPort);
        }
        pIniPort = pIniPort->pNext;
    }
    return NULL;
}

PINIMONITOR
FindFilePortMonitor(
    PINISPOOLER pIniSpooler
)
{
    PINIPORT pIniPort;

    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );

    pIniPort = pIniSpooler->pIniPort;
    while (pIniPort) {
        if (!wcscmp(pIniPort->pName, L"FILE:")) {
            return pIniPort->pIniMonitor;
        }
        pIniPort = pIniPort->pNext;
    }
    return NULL;
}

BOOL
AddIniPrinterToIniPort(
    PINIPORT pIniPort,
    PINIPRINTER pIniPrinter
    )
{
    DWORD i;
    PINIPRINTER *ppIniPrinter;

    //
    // If Printer already attatched to Port
    //

    for (i = 0; i < pIniPort->cPrinters; i++) {
        if (pIniPort->ppIniPrinter[i] == pIniPrinter) {
            return TRUE;
        }
    }

    ppIniPrinter = RESIZEPORTPRINTERS(pIniPort, 1);

    if ( ppIniPrinter != NULL ) {

        pIniPort->ppIniPrinter = ppIniPrinter;
        if ( !pIniPort->cPrinters )
            CreateRedirectionThread(pIniPort);
        pIniPort->ppIniPrinter[pIniPort->cPrinters++] = pIniPrinter;

        DBGMSG( DBG_TRACE, ("AddIniPrinterToIniPort pIniPrinter %x %ws pIniPort %x %ws\n",
                             pIniPrinter, pIniPrinter->pName,
                             pIniPort, pIniPort->pName ));
        return TRUE;

    } else {
        DBGMSG( DBG_WARNING, ("AddIniPrintertoIniPort failed pIniPort %x pIniPrinter %x error %d\n",
                               pIniPort, pIniPrinter, GetLastError() ));
        return FALSE;
    }
}

BOOL
AddIniPortToIniPrinter(
    IN  PINIPRINTER pIniPrinter,
    IN  PINIPORT pIniPort
)
/*++

Routine Description: 
    Adds a IniPort structure to a IniPrinter.
    A link between a printer and a port must be bi-directional. 
    It is mandatory to call AddIniPrinterToIniPort in pair with this function or to handle the bi-dir link. 

Arguments:

    pIniPrinter - printer that will gonna use the port

    pIniPort    - port to be assigned to printer

Return Value:

    BOOL    - TRUE if the port succesfully assigned to printer or if the printer is already assigned to port

--*/
{
    DWORD i;
    PINIPORT *ppIniPorts;

    //
    // Search if Port is already attached to Printer and return TRUE if it does
    //
    for (i = 0; i < pIniPrinter->cPorts; i++) {
        if (pIniPrinter->ppIniPorts[i] == pIniPort) {
            return TRUE;
        }
    }

    ppIniPorts = RESIZEPRINTERPORTS(pIniPrinter, 1);

    if ( ppIniPorts != NULL ) {

        pIniPrinter->ppIniPorts = ppIniPorts;
        
        pIniPrinter->ppIniPorts[pIniPrinter->cPorts++] = pIniPort;

        DBGMSG( DBG_TRACE, ("AddIniPortToIniPrinter pIniPort %x %ws pIniPrinter %x %ws\n",
                             pIniPort, pIniPort->pName,
                             pIniPrinter, pIniPrinter->pName ));
        return TRUE;

    } else {
        DBGMSG( DBG_WARNING, ("AddIniPrintertoIniPort failed pIniPort %x pIniPrinter %x error %d\n",
                               pIniPort, pIniPrinter, GetLastError() ));
        return FALSE;
    }
}

VOID
AddJobEntry(
    PINIPRINTER pIniPrinter,
    PINIJOB     pIniJob
)
{
   DWORD    Position;
   SplInSem();

    // DO NOT Add the Same Job more than once

    SPLASSERT(pIniJob != FindJob(pIniPrinter, pIniJob->JobId, &Position));

    pIniJob->pIniPrevJob = pIniPrinter->pIniLastJob;

    if (pIniJob->pIniPrevJob)
        pIniJob->pIniPrevJob->pIniNextJob = pIniJob;

    pIniPrinter->pIniLastJob = pIniJob;

    if (!pIniPrinter->pIniFirstJob)
        pIniPrinter->pIniFirstJob=pIniJob;
}

BOOL
CheckDataTypes(
    PINIPRINTPROC pIniPrintProc,
    LPWSTR  pDatatype
)
{
    PDATATYPES_INFO_1 pDatatypeInfo;
    DWORD   i;

    pDatatypeInfo = (PDATATYPES_INFO_1)pIniPrintProc->pDatatypes;

    for (i=0; i<pIniPrintProc->cDatatypes; i++)
        if (!lstrcmpi(pDatatypeInfo[i].pName, pDatatype))
            return TRUE;

    return FALSE;
}

PINIPRINTPROC
FindDatatype(
    PINIPRINTPROC pDefaultPrintProc,
    LPWSTR  pDatatype
)
{
    PINIPRINTPROC pIniPrintProc;

    if ( pDatatype == NULL ) {
        return NULL;
    }

    //
    // !! HACK !!
    //
    // Our method of exposing NT EMF 1.00x is broken.  EMF jobs are created
    // by GDI using NT EMF 1.003 on NT4 and 1.008 on Win2000.  Therefore,
    // a print processor written for NT4 will not work on Win2000 because
    // they didn't know about the new datatype.  Usually the print processor
    // doesn't parse the EMF.  If they do, they are really broken.
    //
    // This hack is to call the IHV print processor with 1.008 EMF.
    //

    if (pDefaultPrintProc)
    {
        //
        // If the datatype is supported by the print processor OR
        // the datatype is NT EMF 1.008 (Win2000) and the print processor
        // supports NT EMF 1.003, then return this print processor.
        //
        if (CheckDataTypes(pDefaultPrintProc, pDatatype) ||
            (!_wcsicmp(pDatatype, gszNT5EMF) &&
             CheckDataTypes(pDefaultPrintProc, gszNT4EMF))) {

            return pDefaultPrintProc;
        }
    }

    pIniPrintProc = pThisEnvironment->pIniPrintProc;

    while ( pIniPrintProc ) {

        if ( CheckDataTypes( pIniPrintProc, pDatatype )) {
           return pIniPrintProc;
        }

        pIniPrintProc = pIniPrintProc->pNext;
    }

    DBGMSG( DBG_WARNING, ( "FindDatatype: Could not find Datatype\n") );

    return FALSE;
}


BOOL
IsGoingToFile(
    LPWSTR pOutputFile,
    PINISPOOLER pIniSpooler)
{
    PINIPORT        pIniPort;
    LPWSTR          pszShare;

    SplInSem();

    SPLASSERT(pIniSpooler->signature == ISP_SIGNATURE);

    // Validate the contents of the pIniJob->pOutputFile
    // if it is a valid file, then return true
    // if it is a port name or any other kind of name then ignore

    if (pOutputFile && *pOutputFile) {

        //
        // we have a non-null pOutputFile
        // match this with all available ports
        //

        pIniPort = pIniSpooler->pIniPort;

        while ( pIniPort ) {

            SPLASSERT( pIniPort->signature == IPO_SIGNATURE );

            if (!_wcsicmp( pIniPort->pName, pOutputFile )) {

                //
                // We have matched the pOutputFile field with a
                // valid port and the port is not a file port
                //
                if (pIniPort->Status & PP_FILE) {
                    pIniPort = pIniPort->pNext;
                    continue;
                }

                return FALSE;
            }

            pIniPort = pIniPort->pNext;
        }

        //
        // We have no port that matches exactly
        // so let's assume its a file.
        //
        // ugly hack -- check for Net: as the name
        //
        // This would normally match files like "NewFile" or "Nextbox,"
        // but since we always fully qualify filenames, we don't encounter
        // any problems.
        //
        if (!_wcsnicmp(pOutputFile, L"Ne", 2)) {
            return FALSE;
        }

        //
        // We have the problem LAN man ports coming as UNC path and being
        // treated as files. This is a HACK for that
        //
        if ( pOutputFile                    &&
             pOutputFile[0] == L'\\'        &&
             pOutputFile[1] == L'\\'        &&
             (pszShare = wcschr(pOutputFile+2, L'\\')) ) {

            pszShare++;
            if ( FindPrinter(pszShare, pIniSpooler) ||
                 FindPrinterShare(pszShare, pIniSpooler) )
                return FALSE;
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
SpoolThisJob(
    PSPOOL  pSpool,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    WCHAR       szFileName[MAX_PATH];
    PDOC_INFO_1 pDocInfo1=(PDOC_INFO_1)pDocInfo;
    HANDLE      hImpersonationToken;
    DWORD       dwId = 0;
    HANDLE      hWriteFile = INVALID_HANDLE_VALUE;
    LPWSTR      pszDatatype = NULL;
    HANDLE      pSplFilePoolItem = NULL;
    HRESULT     RetVal = S_OK;
    LPWSTR      pszName = NULL;

    DBGMSG(DBG_TRACE, ("Spooling document %ws\n",
                       pDocInfo1->pDocName ? pDocInfo1->pDocName : L""));

    if( pDocInfo1 && pDocInfo1->pDatatype ){

        pszDatatype = pDocInfo1->pDatatype;

        //
        // !! HACK !!
        //
        // We will do not support sending NT4 EMF to NT5 servers (NT EMF 1.003).
        // However, the HP LJ 1100 monolith installation program requires
        // that this datatype is available.  So we added this back to winprint,
        // but we don't want people to use it.  Therefore we will reject
        // the datatype here.  Big hack.
        //
        if( !FindDatatype( NULL, pszDatatype ) ||
            !_wcsicmp(pszDatatype, gszNT4EMF)){

            DBGMSG(DBG_WARNING, ("Datatype %ws is invalid\n", pDocInfo1->pDatatype));

            SetLastError(ERROR_INVALID_DATATYPE);
            return FALSE;
        }
    }

   EnterSplSem();

    //
    // Check if we need to disallow EMF printing.
    //
    if( pSpool->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_RAW_ONLY ){

        if( !pszDatatype ){
            pszDatatype = pSpool->pDatatype ?
                              pSpool->pDatatype :
                              pSpool->pIniPrinter->pDatatype;
        }

        if( !ValidRawDatatype( pszDatatype )){
            LeaveSplSem();

            DBGMSG(DBG_WARNING, ("Datatype %ws is not RAW to a RAW printer\n", pDocInfo1->pDatatype));

            SetLastError(ERROR_INVALID_DATATYPE);
            return FALSE;
        }
    }

    dwId = GetNextId( pSpool->pIniPrinter->pIniSpooler->hJobIdMap );

    //
    // If we are using keep printed jobs, or an independent spool directory 
    // exists for this printer, then we don't want to use the file pool.
    //
    if ( pSpool->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS ||
         pSpool->pIniPrinter->pSpoolDir)
    {
        GetFullNameFromId(pSpool->pIniPrinter, dwId, TRUE,
                          szFileName, FALSE);
    }

    LeaveSplSem();
    SplOutSem();

    //
    // WMI Trace Event.
    //
    LogWmiTraceEvent(dwId, EVENT_TRACE_TYPE_SPL_SPOOLJOB, NULL);
    
    if (!(hImpersonationToken = RevertToPrinterSelf())) {
        DBGMSG(DBG_WARNING, ("SpoolThisJob RevertToPrinterSelf failed: %d\n", GetLastError()));
        SplOutSem();
        return FALSE;
    }

    //
    // If keep printed jobs is enabled for this printer, or if the printer has
    // a spool directory, then we don't use the file pool.
    // 
    if (pSpool->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS ||
        pSpool->pIniPrinter->pSpoolDir)
    {
        hWriteFile = CreateFile(szFileName,
                                GENERIC_WRITE | GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL |
                                FILE_FLAG_SEQUENTIAL_SCAN,
                                NULL);
        
    }
    else
    {
        //
        // We're not keeping Printed Jobs, use the Pool.
        //
        //
        // This sets up the Spool and Shadow Files at the same time.
        //
        RetVal = GetFileItemHandle(pSpool->pIniPrinter->pIniSpooler->hFilePool, &pSplFilePoolItem, NULL);
        if (SUCCEEDED(RetVal))
        {
            RetVal = GetWriterFromHandle(pSplFilePoolItem, &hWriteFile, TRUE);
            if (FAILED(RetVal))
            {
                hWriteFile = INVALID_HANDLE_VALUE;
            }
            RetVal = GetNameFromHandle(pSplFilePoolItem, &pszName, TRUE);
            if (SUCCEEDED(RetVal))
            {
                wcscpy(szFileName, pszName);
            }
            else
            {
                wcscpy(szFileName, L"");
            }
        }
        else
        {
            hWriteFile = INVALID_HANDLE_VALUE;
        }
        
    }

    if (!ImpersonatePrinterClient(hImpersonationToken)) {
        DBGMSG(DBG_WARNING, ("SpoolThisJob ImpersonatePrinterClient failed: %d\n", GetLastError()));
        SplOutSem();
        return FALSE;
    }

    if ( hWriteFile == INVALID_HANDLE_VALUE ) {

        DBGMSG(DBG_WARNING, ("SpoolThisJob CreateFile( %ws ) GENERIC_WRITE failed: Error %d\n",
                             szFileName, GetLastError()));

        SplOutSem();
        return FALSE;

    } else {

        DBGMSG(DBG_TRACE, ("SpoolThisJob CreateFile( %ws) GENERIC_WRITE Success:hWriteFile %x\n",szFileName, hWriteFile));

    }


   EnterSplSem();

    if( !(pSpool->pIniJob = CreateJobEntry(pSpool,
                                           Level,
                                           pDocInfo,
                                           dwId,
                                           !IsLocalCall(),
                                           0,
                                           NULL)))
    {
        LeaveSplSem();

        if ( pSplFilePoolItem )
        {
            FinishedWriting(pSplFilePoolItem, TRUE);
            ReleasePoolHandle(&pSplFilePoolItem);            
        }
        else
        {
            CloseHandle( hWriteFile );
            DeleteFile( szFileName );
        }

        SplOutSem();
        return FALSE;
    }

    if ( pSplFilePoolItem )
    {
        pSpool->pIniJob->hFileItem = pSplFilePoolItem;
        if ( pszName )
        {
            pSpool->pIniJob->pszSplFileName = pszName;
        }
    }


    SPLASSERT(!IsGoingToFile(pSpool->pIniJob->pOutputFile,
                             pSpool->pIniSpooler));

    pSpool->pIniJob->Status |= JOB_SPOOLING;

    // Gather Stress Information for Max Number of concurrent spooling jobs

    pSpool->pIniPrinter->cSpooling++;
    if (pSpool->pIniPrinter->cSpooling > pSpool->pIniPrinter->cMaxSpooling)
        pSpool->pIniPrinter->cMaxSpooling = pSpool->pIniPrinter->cSpooling;

    pSpool->pIniJob->hWriteFile = hWriteFile;

    //
    // !! NOTE !!
    //
    // Removed WriteShadowJob call here.
    //
    // We shouldn't need it because if the job is spooling and we
    // restart the spooler, we won't accept the shadow file because it's
    // not yet completely spooled.  Once it has spooled, the EndDocPrinter
    // will call WriteShadowJob, so we should be fine.
    //

    AddJobEntry(pSpool->pIniPrinter, pSpool->pIniJob);

    // This bit can be set in the print to file case.  Clear it for
    // a following spool job.  Bit should really be in the job.
    pSpool->TypeofHandle &= ~PRINTER_HANDLE_DIRECT;

    SetPrinterChange(pSpool->pIniPrinter,
                     pSpool->pIniJob,
                     NVAddJob,
                     PRINTER_CHANGE_ADD_JOB | PRINTER_CHANGE_SET_PRINTER,
                     pSpool->pIniSpooler);

    //
    //  RapidPrint might start despooling right away
    //

    CHECK_SCHEDULER();

   LeaveSplSem();
   SplOutSem();

   return TRUE;
}

BOOL
PrintingDirect(
    PSPOOL  pSpool,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    PDOC_INFO_1 pDocInfo1=(PDOC_INFO_1)pDocInfo;
    PINIPORT pIniPort = NULL;
    BOOL bGoingToFile = FALSE;
    DWORD       dwId = 0;    // WMI Var

    DBGMSG(DBG_TRACE, ("Printing document %ws direct\n",
                       pDocInfo1->pDocName ? pDocInfo1->pDocName : L"(Null)"));

    if (pDocInfo1 &&
        pDocInfo1->pDatatype &&
        !ValidRawDatatype(pDocInfo1->pDatatype)) {

        DBGMSG(DBG_WARNING, ("Datatype is not RAW\n"));

        SetLastError(ERROR_INVALID_DATATYPE);
        return FALSE;
    }

   EnterSplSem();

   if (pDocInfo1 && pDocInfo1->pOutputFile
         && IsGoingToFile(pDocInfo1->pOutputFile, pSpool->pIniSpooler)) {
             bGoingToFile = TRUE;
   }

   if (bGoingToFile) {

       //
       // If we already have a thread/process printing to this filename
       // fail. Do not allow multiple processes/threads to write to the
       // same output file.
       //

       if (FindFilePort(pDocInfo1->pOutputFile, pSpool->pIniSpooler)) {
           LeaveSplSem();
           SetLastError(ERROR_SHARING_VIOLATION);
           return(FALSE);
       }
   }
   
   //
   // WMI Trace Events
   //
   dwId = GetNextId( pSpool->pIniPrinter->pIniSpooler->hJobIdMap );

   LeaveSplSem();
   LogWmiTraceEvent(dwId, EVENT_TRACE_TYPE_SPL_SPOOLJOB, NULL);
   EnterSplSem();

    pSpool->pIniJob = CreateJobEntry(
                          pSpool,
                          Level,
                          pDocInfo,
                          dwId,
                          !IsLocalCall(),
                          JOB_DIRECT,
                          NULL);

    if (!pSpool->pIniJob) {

        LeaveSplSem();
        return FALSE;
    }

    pSpool->pIniJob->StartDocComplete = CreateEvent( NULL,
                                                     EVENT_RESET_AUTOMATIC,
                                                     EVENT_INITIAL_STATE_NOT_SIGNALED,
                                                     NULL );

    pSpool->pIniJob->WaitForWrite = CreateEvent( NULL,
                                                 EVENT_RESET_AUTOMATIC,
                                                 EVENT_INITIAL_STATE_NOT_SIGNALED,
                                                 NULL );

    pSpool->pIniJob->WaitForRead  = CreateEvent( NULL,
                                                 EVENT_RESET_AUTOMATIC,
                                                 EVENT_INITIAL_STATE_NOT_SIGNALED,
                                                 NULL );


    AddJobEntry(pSpool->pIniPrinter, pSpool->pIniJob);

    pSpool->TypeofHandle |= PRINTER_HANDLE_DIRECT;

    if (bGoingToFile) {
        PINIMONITOR pIniMonitor;

        pSpool->pIniJob->Status |= JOB_PRINT_TO_FILE;
        pIniMonitor = FindFilePortMonitor( pSpool->pIniSpooler );
        pIniPort = CreatePortEntry( pSpool->pIniJob->pOutputFile,
                                        pIniMonitor, pSpool->pIniSpooler);
        if (!pIniPort) {
            DECJOBREF(pSpool->pIniJob);
            DeleteJob(pSpool->pIniJob, NO_BROADCAST);
            LeaveSplSem();
            return FALSE;
        }

        pIniPort->Status |= PP_FILE;
        AddIniPrinterToIniPort(pIniPort, pSpool->pIniPrinter);
    }

    CHECK_SCHEDULER();

    if (pSpool->pIniJob->pIniPort) {
        SplInSem();
        pSpool->pIniJob->Status |= JOB_PRINTING;
    }

    SetPrinterChange(pSpool->pIniPrinter,
                     pSpool->pIniJob,
                     NVAddJob,
                     PRINTER_CHANGE_ADD_JOB | PRINTER_CHANGE_SET_PRINTER,
                     pSpool->pIniSpooler);

   LeaveSplSem();
   SplOutSem();

    // Wait until the port thread calls StartDocPrinter through
    // the print processor:

    DBGMSG(DBG_PORT, ("PrintingDirect: Calling WaitForSingleObject( %x )\n",
                      pSpool->pIniJob->StartDocComplete));

    WaitForSingleObject( pSpool->pIniJob->StartDocComplete, INFINITE );

   EnterSplSem();

    // Close the event and set its value to NULL.
    // If anything goes wrong, or if the job gets cancelled,
    // the port thread will check this event, and if it's non-NULL,
    // it will set it to allow this thread to wake up.

    DBGMSG(DBG_PORT, ("PrintingDirect: Calling CloseHandle( %x )\n",
                      pSpool->pIniJob->StartDocComplete));

    CloseHandle(pSpool->pIniJob->StartDocComplete);
    pSpool->pIniJob->StartDocComplete = NULL;

    /* If an error occurred, set the error on this thread:
     */
    if (pSpool->pIniJob->StartDocError) {

        SetLastError(pSpool->pIniJob->StartDocError);

        // We have to decrement by 2 because we've just created this job
        // in CreateJobEntry setting it to 1 and the other thread who
        // actually failed the StartDoc above (PortThread) did
        // not know to blow away the job. He just failed the StartDocPort.

        // No, we don't have to decrement by 2 because the PortThread
        // decrement does go through, am restoring to decrement by 1

        SPLASSERT(pSpool->pIniJob->cRef != 0);
        DECJOBREF(pSpool->pIniJob);
        DeleteJobCheck(pSpool->pIniJob);

        DBGMSG(DBG_TRACE, ("PrintingDirect:cRef %d\n", pSpool->pIniJob->cRef));

       LeaveSplSem();

        return FALSE;
    }

   LeaveSplSem();

    return TRUE;
}

VOID
ClearJobError(
    PINIJOB pIniJob
    )
/*++

Routine Description:

    Clears the error status bits of a job.

    This routine should be called when port monitor successfully
    sends bytes to the printer.

Arguments:

    pIniJob - Job in error state that should be cleared.

Return Value:

--*/

{
    SplInSem();

    pIniJob->Status &= ~(JOB_PAPEROUT | JOB_OFFLINE | JOB_ERROR);

    SetPrinterChange( pIniJob->pIniPrinter,
                      pIniJob,
                      NVJobStatus,
                      PRINTER_CHANGE_SET_JOB,
                      pIniJob->pIniPrinter->pIniSpooler );
}

BOOL
LocalCloseSpoolFileHandle(
    HANDLE  hPrinter)

/*++
Function Description: Sets the end of file pointer for the spool file. In memory mapped writes
                      the spool size grows in 64K chunks and it needs to be truncated after the
                      writes are completed.

Parameters: hPrinter   -- printer handle

Return Values: TRUE if successful;
               FALSE otherwise
--*/

{
    BOOL    bReturn = TRUE;
    DWORD   LastError = ERROR_SUCCESS;
    PSPOOL  pSpool = (PSPOOL) hPrinter;

    EnterSplSem();

    // Check handle validity
    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {

         LastError = ERROR_INVALID_HANDLE;

    } else if (!(pSpool->Status & SPOOL_STATUS_STARTDOC) ||
               (pSpool->Status & SPOOL_STATUS_ADDJOB)) {

         LastError = ERROR_SPL_NO_STARTDOC;

    } else if (!pSpool->pIniJob ||
               (pSpool->pIniJob->hWriteFile == INVALID_HANDLE_VALUE) ||
               (pSpool->TypeofHandle & (PRINTER_HANDLE_PORT |
                                        PRINTER_HANDLE_DIRECT)) ||
               !(pSpool->pIniJob->Status & JOB_TYPE_OPTIMIZE)) {

         LastError = ERROR_INVALID_HANDLE;

    } else if ((pSpool->Status & SPOOL_STATUS_CANCELLED) &&
               (pSpool->pIniJob->Status & (JOB_PENDING_DELETION))) {

         LastError = ERROR_PRINT_CANCELLED;
    }

    if (LastError) {
        SetLastError(LastError);
        bReturn = FALSE;
        goto CleanUp;
    }

    if (!(pSpool->pIniJob->Status & JOB_DESPOOLING)) {

        // Move the file pointer to the number of bytes committed and set the end of
        // file.
        if (SetFilePointer(pSpool->pIniJob->hWriteFile, pSpool->pIniJob->dwValidSize,
                           NULL, FILE_BEGIN) != 0xffffffff) {
            SetEndOfFile(pSpool->pIniJob->hWriteFile);
        }
    }

CleanUp:

    LeaveSplSem();

    return bReturn;
}

BOOL
LocalCommitSpoolData(
    HANDLE  hPrinter,
    DWORD   cbCommit)

/*++
Function Description: This function updates the Valid data size in the spool file.
                      The application writes directly into the spool file and commits the
                      data written using CommitSpoolData.

Parameters:   hPrinter    -- printer handle
              cbCommit    -- number of bytes to be committed

Return Values: TRUE if successful;
               FALSE otherwise
--*/

{
    BOOL     bReturn = TRUE;
    DWORD    LastError = ERROR_SUCCESS, dwPosition;

    PSPOOL   pSpool = (PSPOOL) hPrinter;
    PINIJOB  pIniJob = NULL, pChainedJob;

    if (!cbCommit) {
        return bReturn;
    }

    EnterSplSem();

    // Check handle validity
    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {

         LastError = ERROR_INVALID_HANDLE;

    } else if (!(pSpool->Status & SPOOL_STATUS_STARTDOC) ||
               (pSpool->Status & SPOOL_STATUS_ADDJOB)) {

         LastError = ERROR_SPL_NO_STARTDOC;

    } else if (!pSpool->pIniJob ||
               (pSpool->pIniJob->hWriteFile == INVALID_HANDLE_VALUE) ||
               (pSpool->TypeofHandle & (PRINTER_HANDLE_PORT|
                                        PRINTER_HANDLE_DIRECT)) ||
               !(pSpool->pIniJob->Status & JOB_TYPE_OPTIMIZE)) {

         LastError = ERROR_INVALID_HANDLE;

    } else if ((pSpool->Status & SPOOL_STATUS_CANCELLED) ||
               (pSpool->pIniJob->Status & (JOB_PENDING_DELETION))) {

         LastError = ERROR_PRINT_CANCELLED;
    }

    if (LastError) {
        SetLastError(LastError);
        bReturn = FALSE;
        goto CleanUp;
    }

    pIniJob = pSpool->pIniJob;

    pIniJob->dwValidSize += cbCommit;
    pIniJob->Size += cbCommit;
    SetFilePointer(pIniJob->hWriteFile, cbCommit, NULL, FILE_CURRENT);

    // Chained job size include all the jobs in the chain
    // But since the next jobs size field will have the size
    // of all subsequent jobs we do not need to walk thru the
    // whole chain
    if (pIniJob->NextJobId) {

        if (pChainedJob = FindJob(pSpool->pIniPrinter,
                                  pIniJob->NextJobId,
                                  &dwPosition)) {

            pIniJob->Size += pChainedJob->Size;

        } else {

            SPLASSERT(pChainedJob != NULL);
        }
    }

    // SetEvent on WaitForSeek if sufficient number bytes have been written out.
    SeekPrinterSetEvent(pSpool->pIniJob, NULL, FALSE);

    //  For Printing whilst Despooling, make sure we have enough bytes before
    //  scheduling this job
    if (((pIniJob->dwValidSize - cbCommit) < dwFastPrintSlowDownThreshold) &&
        (pIniJob->dwValidSize >= dwFastPrintSlowDownThreshold) &&
        (pIniJob->WaitForWrite == NULL)) {

        CHECK_SCHEDULER();
    }

    // Support for despooling whilst spooling

    if ( pIniJob->WaitForWrite != NULL )
        SetEvent( pIniJob->WaitForWrite );

    SetPrinterChange(pSpool->pIniPrinter,
                     pIniJob,
                     NVSpoolJob,
                     PRINTER_CHANGE_WRITE_JOB,
                     pSpool->pIniSpooler);

    // If there was no error, and the job was marked in an error
    // state, clear it.
    if (pIniJob->Status & (JOB_PAPEROUT | JOB_OFFLINE | JOB_ERROR)) {
        ClearJobError(pIniJob);
    }

CleanUp:

    LeaveSplSem();

    return bReturn;
}

BOOL
LocalGetSpoolFileHandle(
    HANDLE    hPrinter,
    LPWSTR    *pSpoolDir,
    LPHANDLE  phFile,
    HANDLE    hSpoolerProcess,
    HANDLE    hAppProcess)

/*++
Function Description: This function duplicates the spoolfile handle for local jobs into the
                      applications process space. For remote jobs it returns the spool directory.
                      The router will create a temp file and return its handle to the
                      application.

Parameters: hPrinter         --  printer handle
            pSpoolDir        --  pointer to recieve the spool directory
            phFile           --  pointer to get the duplicate handle
            hSpoolerProcess  --  spooler process handle
            hAppProcess      --  application process handle

Return Values: TRUE if the LOCAL job and handle can be duplicated
                       OR  REMOTE job and spool directory is available
               FALSE otherwise
--*/

{
    BOOL           bReturn = TRUE, bDuplicate;
    PSPOOL         pSpool;
    DWORD          LastError = 0;
    PMAPPED_JOB    pMappedJob = NULL, pTempMappedJob;
    LPWSTR         pszSpoolFile = NULL;

    if (pSpoolDir) {
        *pSpoolDir = NULL;
    }
    if (phFile) {
        *phFile = INVALID_HANDLE_VALUE;
    }

    if ((hPrinter && !phFile) || (!hPrinter && !pSpoolDir)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    EnterSplSem();

    // For a local hPrinter return the SpoolFile handle
    if (hPrinter) {

        pSpool = (PSPOOL) hPrinter;

        // Check handle validity
        if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {

             LastError = ERROR_INVALID_HANDLE;

        } else if (!(pSpool->Status & SPOOL_STATUS_STARTDOC) ||
                   (pSpool->Status & SPOOL_STATUS_ADDJOB)) {

             LastError = ERROR_SPL_NO_STARTDOC;

        } else if (!pSpool->pIniJob ||
                   (pSpool->pIniJob->hWriteFile == INVALID_HANDLE_VALUE) ||
                   (pSpool->TypeofHandle & (PRINTER_HANDLE_PORT |
                                            PRINTER_HANDLE_DIRECT))) {

             LastError = ERROR_INVALID_HANDLE;

        } else if ((pSpool->Status & SPOOL_STATUS_CANCELLED) &&
                   (pSpool->pIniJob->Status & JOB_PENDING_DELETION)) {

             LastError = ERROR_PRINT_CANCELLED;
        }

        if (LastError) {

            SetLastError(LastError);
            bReturn = FALSE;

        } else {
            // Duplicate hWriteFile into the App process
            bReturn = ((pMappedJob = AllocSplMem(sizeof( MAPPED_JOB ))) != NULL) &&

                      ((pszSpoolFile = AllocSplMem(MAX_PATH * sizeof( WCHAR ))) != NULL) &&

                      DuplicateHandle(hSpoolerProcess,
                                      pSpool->pIniJob->hWriteFile,
                                      hAppProcess,
                                      phFile,
                                      0,
                                      TRUE,
                                      DUPLICATE_SAME_ACCESS);

            if (bReturn) {

                // Store the jobid and the spool file name in pSpool, so that in the event
                // that EndDoc is not called by the application/GDI, the spooler can delete the
                // spool file and free the job id from the id map on ClosePrinter.

                pSpool->pIniJob->Status |= JOB_TYPE_OPTIMIZE;
                
                if (pSpool->pIniJob->hFileItem != INVALID_HANDLE_VALUE)
                {
                    wcscpy(pszSpoolFile, pSpool->pIniJob->pszSplFileName);

                    
                }
                else
                {
                    GetFullNameFromId(pSpool->pIniJob->pIniPrinter, pSpool->pIniJob->JobId, TRUE,
                                      pszSpoolFile, FALSE);
                }


                // Avoid duplicate entries in the pSpool->pMappedJob list
                bDuplicate = FALSE;

                for (pTempMappedJob = pSpool->pMappedJob;
                     pTempMappedJob;
                     pTempMappedJob = pTempMappedJob->pNext) {

                    if (pTempMappedJob->JobId == pSpool->pIniJob->JobId) {
                        bDuplicate = TRUE;
                        break;
                    }
                }

                if (!bDuplicate) {

                    pMappedJob->pszSpoolFile = pszSpoolFile;
                    pMappedJob->JobId = pSpool->pIniJob->JobId;
                    pMappedJob->pNext = pSpool->pMappedJob;
                    pSpool->pMappedJob = pMappedJob;

                } else {

                    FreeSplMem(pszSpoolFile);
                    FreeSplMem(pMappedJob);
                }
            }
        }

    } else {

        // Use the default spool dir or spool\Printers
        if (pLocalIniSpooler->pDefaultSpoolDir) {

            *pSpoolDir = AllocSplStr(pLocalIniSpooler->pDefaultSpoolDir);

        } else if (pLocalIniSpooler->pDir) {

            *pSpoolDir = AllocSplMem( (wcslen(pLocalIniSpooler->pDir) +
                                       wcslen(szPrinterDir) + 2) * sizeof(WCHAR));

            if (*pSpoolDir) {
                wsprintf(*pSpoolDir, L"%ws\\%ws", pLocalIniSpooler->pDir, szPrinterDir);
            }
        }

        if (!*pSpoolDir) {
            bReturn = FALSE;
        }
    }

    LeaveSplSem();

    if (!bReturn) {
        if (pMappedJob) {
            FreeSplMem(pMappedJob);
        }
        if (pszSpoolFile) {
            FreeSplMem(pszSpoolFile);
        }
    }

    return bReturn;
}

BOOL
LocalFlushPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten,
    DWORD   cSleep
)

/*++
Function Description: FlushPrinter is typically used by the driver to send a burst of zeros
                      to the printer and introduce a delay in the i/o line to the printer.
                      The spooler does not schedule any job for cSleep milliseconds.

                      The driver can call FlushPrinter several times to have a cumulative
                      effect. The printer could be sleeping for a long time, but that is acceptable
                      since the driver is authenticated to keep doing WritePrinters indefinitely.
                      Thus FlushPrinter does not introduce any security loophole.

Parameters:  hPrinter  - printer handle
             pBuf      - buffer to be sent to the printer
             cbBuf     - size of the buffer
             pcWritten - pointer to return the number of bytes written
             cSleep    - sleep time in milliseconds.

Return Values: TRUE if successful;
               FALSE otherwise
--*/

{
    BOOL         bReturn = FALSE;
    DWORD        CurrentTime;
    PSPOOL       pSpool = (PSPOOL)hPrinter;
    PINIPORT     pIniPort;
    PINIMONITOR  pIniMonitor;

    EnterSplSem();

    //
    // Validate parameters
    //
    if (!pcWritten ||
        (cbBuf && !pBuf))
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto CleanUp;
    }

    //
    // FlushPrinter can be called only for port handles where a prior call to WritePrinter
    // failed
    //
    if (!ValidateSpoolHandle( pSpool, PRINTER_HANDLE_SERVER ) ||
        !(pSpool->TypeofHandle & PRINTER_HANDLE_PORT)         ||
        !(pSpool->Status & SPOOL_STATUS_FLUSH_PRINTER))
    {
        SetLastError( ERROR_INVALID_HANDLE );
        goto CleanUp;
    }

    //
    // Send the contents of the buffer to the port with a monitor. It doesn't make sense for
    // file ports or masq printers.
    //
    pIniPort = pSpool->pIniPort;

    if ( pIniPort && pIniPort->Status & PP_ERROR)
    {
        //
        // Don't send more data to a printer who's writing to a port in error state. LocalFlushPrinter is called in order to reset the printer
        // By doing this, when printer buffer gets full, the writing will hung and job cannot be restarted/deleted anymore
        //
        SetLastError( ERROR_PRINT_CANCELLED );
        goto CleanUp;
    }

    if (pIniPort && (pIniPort->Status & PP_MONITOR))
    {
        pIniMonitor = pIniPort->pIniMonitor;

        //
        // Use the language monitor if one is present
        //
        if (pIniPort->pIniLangMonitor)
        {
            pIniMonitor = pIniPort->pIniLangMonitor;
        }

        if (pIniMonitor)
        {
            //
            // LeaveSplSem before calling into the monitor
            //

            INCPORTREF( pIniPort );
            pIniMonitor->cRef++;

            *pcWritten = 0;

            LeaveSplSem();
            SplOutSem();

            bReturn = (*pIniMonitor->Monitor2.pfnWritePort)( pIniPort->hPort,
                                                             pBuf,
                                                             cbBuf,
                                                             pcWritten );

            EnterSplSem();

            DECPORTREF( pIniPort );
            --pIniMonitor->cRef;
        }
    }

    //
    // Update the IniPort to introduce cSleep ms delay before scheduling
    //
    if (pIniPort)
    {
        CurrentTime = GetTickCount();

        if (pIniPort->bIdleTimeValid && (int)(pIniPort->IdleTime - CurrentTime) > 0)
        {
            pIniPort->IdleTime += cSleep;
        }
        else
        {
            pIniPort->IdleTime = CurrentTime + cSleep;
            pIniPort->bIdleTimeValid = TRUE;
        }
    }

CleanUp:

    LeaveSplSem();

    return bReturn;
}

VOID
QuitThread(
    LPHANDLE phThread,
    DWORD    dwThreadId,
    BOOL     bInsideSplSem
)
{   //
    // This function is called on LocalWritePrinter to destroy thread created on PromptErrorMessage
    //
    if( phThread && *phThread ) {

        if( WAIT_TIMEOUT == WaitForSingleObject( *phThread, 0 )) {

            if(bInsideSplSem){

                SplInSem();
                LeaveSplSem();
            }

            //
            // See if the thread is still running or dismissed by user.
            // If it is still running, wait for it to terminate before pIniJob can be freed.
            //
            MyPostThreadMessage( *phThread, dwThreadId, WM_QUIT, IDRETRY, 0 );

            WaitForSingleObject( *phThread, INFINITE );

            if(bInsideSplSem){

                SplOutSem();
                EnterSplSem();
            }
        }

        CloseHandle( *phThread );
        *phThread = NULL;
    }
}

BOOL
LocalWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
)
{
    PSPOOL  pSpool=(PSPOOL)hPrinter;
    PINIPORT    pIniPort;
    DWORD   cWritten, cTotal;
    DWORD   rc;
    LPBYTE  pByte=pBuf;
    DWORD   LastError=0;
    PINIJOB pIniJob, pChainedJob;
    PINIMONITOR pIniMonitor;
    HANDLE  hThread = NULL;
    DWORD   dwThreadId=0, dwPosition;
    DWORD   dwWaitingResult;
    DWORD   Size = 0;
    
    *pcWritten = 0;

    SplOutSem();

    EnterSplSem();

    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER ))

        LastError = ERROR_INVALID_HANDLE;

    else if (!(pSpool->Status & SPOOL_STATUS_STARTDOC))

        LastError = ERROR_SPL_NO_STARTDOC;

    else if (pSpool->Status & SPOOL_STATUS_ADDJOB)

        LastError = ERROR_SPL_NO_STARTDOC;

    else if (pSpool->pIniJob &&
             !(pSpool->TypeofHandle & (PRINTER_HANDLE_PORT |
                                       PRINTER_HANDLE_DIRECT))  &&
             ((pSpool->pIniJob->hWriteFile == INVALID_HANDLE_VALUE) ||
              (pSpool->pIniJob->Status & JOB_TYPE_OPTIMIZE))) {

        LastError = ERROR_INVALID_HANDLE;

        DBGMSG( DBG_TRACE, ("LocalWritePrinter: hWriteFile == INVALID_HANDLE_VALUE hPrinter %x\n",hPrinter ));
    }

    else if (pSpool->Status & SPOOL_STATUS_CANCELLED)

        LastError = ERROR_PRINT_CANCELLED;

    else if (pSpool->pIniJob && (pSpool->pIniJob->Status & JOB_PENDING_DELETION) )

        LastError = ERROR_PRINT_CANCELLED;

    pIniPort = pSpool->pIniPort;

    if (LastError) {

        DBGMSG(DBG_TRACE, ("WritePrinter LastError: %x hPrinter %x\n", LastError, hPrinter));

        //
        // Mark port handles to allow FlushPrinter to be called when WritePrinter fails.
        //
        if (LastError == ERROR_PRINT_CANCELLED &&
            pSpool->TypeofHandle & PRINTER_HANDLE_PORT)
        {
            pSpool->Status |= SPOOL_STATUS_FLUSH_PRINTER;
        }

        LeaveSplSem();
        SplOutSem();

        SetLastError(LastError);
        return FALSE;
    }

    LeaveSplSem();
    SplOutSem();
    
    //
    // WMI Trace Events
    //
    // The port thread is already being tracked.
    if (!(pSpool->TypeofHandle & PRINTER_HANDLE_PORT))
    {
        if( pSpool->pIniJob )
        {
            LogWmiTraceEvent(pSpool->pIniJob->JobId,
                             EVENT_TRACE_TYPE_SPL_TRACKTHREAD,
                             NULL);
        } 
        else if ( pSpool->pIniPort && pSpool->pIniPort->pIniJob )
        {
            LogWmiTraceEvent(pSpool->pIniPort->pIniJob->JobId,
                             EVENT_TRACE_TYPE_SPL_TRACKTHREAD, NULL);
        }
    }
    
    cWritten = cTotal = 0;

    while (cbBuf) {

       SplOutSem();

        if ( pSpool->TypeofHandle & PRINTER_HANDLE_PORT ) {

            //
            // For a print pool, check if the port is in error state  and if the event that syncronizes 
            // restarting is not null.
            // A more natural testing if this synchronisation must be done is by testing against
            // dwRestartJobOnPoolEnabled but this is bogus when dwRestartJobOnPoolEnabled is TRUE
            // and SNMP is disabled ( LocalSetPort is not called and the event is not created )
            //
            EnterSplSem();

            if ( (pSpool->pIniPrinter->cPorts > 1) && 
                 (pSpool->pIniPort->Status & PP_ERROR) && 
                 (pIniPort->hErrorEvent != NULL) ) {

                //
                // This event will be set on LocalSetPort when port gets into a non eror state
                // or when timeout and job is restarted (on another port).
                // Printing is cancelled if the event is not set in DelayErrorTime.
                //
                LeaveSplSem();
                SplOutSem();
                dwWaitingResult = WaitForSingleObject( pIniPort->hErrorEvent, pSpool->pIniSpooler->dwRestartJobOnPoolTimeout * 1000 );

                EnterSplSem();

                if( pSpool->pIniJob ){
                    pIniJob = pSpool->pIniJob;
                } else if( pSpool->pIniPort && pSpool->pIniPort->pIniJob ){
                    pIniJob = pSpool->pIniPort->pIniJob;
                } else {
                    pIniJob = NULL;
                }

                //
                // Check if the job was be deleted or restarted
                //
                if( pIniJob && pIniJob->Status & (JOB_PENDING_DELETION | JOB_RESTART)){

                    // We had started a message box. See if the thread is still running or dismissed by user.
                    // If it is still running, wait for it to terminate before pIniJob can be freed.
                    // We need to leave the semaphore, since the UI thread we
                    // are waiting on could need to acquire it.
                    QuitThread( &hThread, dwThreadId, TRUE );

                    SetLastError( ERROR_PRINT_CANCELLED );
                    rc = FALSE;

                    goto Fail;

                }

                //
                // If the error problem wasn't solved , set the job on error and continue
                //
                if( dwWaitingResult == WAIT_TIMEOUT ){

                    pIniJob->Status |= JOB_ERROR;
                    SetPrinterChange( pIniJob->pIniPrinter,
                                      pIniJob,
                                      NVJobStatus,
                                      PRINTER_CHANGE_SET_JOB,
                                      pIniJob->pIniPrinter->pIniSpooler );
                }


            }

            LeaveSplSem();
            SplOutSem();


            if ( pSpool->pIniPort->Status & PP_MONITOR ) {

                if ( pSpool->pIniPort->pIniLangMonitor ) {

                    pIniMonitor = pSpool->pIniPort->pIniLangMonitor;
                } else {

                    pIniMonitor = pSpool->pIniPort->pIniMonitor;
                }

                SplOutSem();
                cWritten = 0;
                rc = (*pIniMonitor->Monitor2.pfnWritePort)(
                         pSpool->pIniPort->hPort,
                         pByte,
                         cbBuf,
                         &cWritten );

                //
                // Only update if cWritten != 0.  If it is zero
                // (for instance, when hpmon is stuck at Status
                // not available), then we go into a tight loop
                // sending out notifications.
                //
                if (cWritten) {

                    //
                    // For stress Test information gather the total
                    // number of types written.
                    //
                    EnterSplSem();

                    pSpool->pIniPrinter->cTotalBytes.QuadPart =
                        pSpool->pIniPrinter->cTotalBytes.QuadPart +
                        cWritten;

                    LeaveSplSem();
                    SplOutSem();

                } else {

                    if (rc && dwWritePrinterSleepTime) {

                        //
                        // Sleep to avoid consuming too much CPU.
                        // Hpmon has this problem where they return
                        // success, but don't write any bytes.
                        //
                        // Be very careful: this may get called several
                        // times by a monitor that writes a lot of zero
                        // bytes (perhaps at the beginning of jobs).
                        //
                        Sleep(dwWritePrinterSleepTime);
                    }
                }
            }
            else {

                DBGMSG(DBG_TRACE, ("LocalWritePrinter: Port has no monitor\n"));

                if (pSpool->Status & SPOOL_STATUS_PRINT_FILE) {

                    DBGMSG(DBG_TRACE, ("LocalWritePrinter: Port has no monitor - writing to file\n"));
                    rc = WriteFile(pSpool->hFile, pByte, cbBuf, &cWritten, NULL);
                } else {

                    DBGMSG(DBG_TRACE, ("LocalWritePrinter: Port has no monitor - calling into router\n"));
                    rc = WritePrinter(pSpool->hPort, pByte, cbBuf, &cWritten);
                }

            }

        } else if ( pSpool->TypeofHandle & PRINTER_HANDLE_DIRECT ) {

            cWritten = WriteToPrinter(pSpool, pByte, cbBuf);

            if (cWritten) {

                pSpool->pIniJob->dwValidSize = pSpool->pIniJob->Size;
                pSpool->pIniJob->Size+=cWritten;

                EnterSplSem();
                SetPrinterChange(pSpool->pIniPrinter,
                                 pSpool->pIniJob,
                                 NVSpoolJob,
                                 PRINTER_CHANGE_WRITE_JOB,
                                 pSpool->pIniSpooler);
                LeaveSplSem();
            }
            SplOutSem();

            rc = (BOOL)cWritten;

        } else {

            SplOutSem();

            rc = WriteFile(pSpool->pIniJob->hWriteFile, pByte, cbBuf, &cWritten, NULL);
            if (cWritten) {
                Size = GetFileSize( pSpool->pIniJob->hWriteFile,NULL);
                
                EnterSplSem();


                pSpool->pIniJob->Size = Size;

                //
                // Chained job size include all the jobs in the chain
                // But since the next jobs size field will have the size
                // of all subsequent jobs we do not need to walk thru the
                // whole chain
                //
                if ( pSpool->pIniJob->NextJobId ) {

                    if ( pChainedJob = FindJob(pSpool->pIniPrinter,
                                               pSpool->pIniJob->NextJobId,
                                               &dwPosition) )
                        pSpool->pIniJob->Size += pChainedJob->Size;
                    else
                        SPLASSERT(pChainedJob != NULL);
                }

                pSpool->pIniJob->dwValidSize = pSpool->pIniJob->Size;

                // SetEvent on WaitForSeek if sufficient number bytes have been written out.
                LeaveSplSem();

                SeekPrinterSetEvent(pSpool->pIniJob, NULL, FALSE);

                EnterSplSem();

                //
                //  For Printing whilst Despooling, make sure we have enough bytes before
                //  scheduling this job
                //

                if (( (pSpool->pIniJob->Size - cWritten) < dwFastPrintSlowDownThreshold ) &&
                    ( pSpool->pIniJob->Size >= dwFastPrintSlowDownThreshold ) &&
                    ( pSpool->pIniJob->WaitForWrite == NULL )) {

                    CHECK_SCHEDULER();

                }

                // Support for despooling whilst spooling

                if ( pSpool->pIniJob->WaitForWrite != NULL )
                    SetEvent( pSpool->pIniJob->WaitForWrite );

                SetPrinterChange(pSpool->pIniPrinter,
                                 pSpool->pIniJob,
                                 NVSpoolJob,
                                 PRINTER_CHANGE_WRITE_JOB,
                                 pSpool->pIniSpooler);
               LeaveSplSem();
               SplOutSem();

            }
        }

        SplOutSem();

        (*pcWritten)+=cWritten;
        cbBuf-=cWritten;
        pByte+=cWritten;

        EnterSplSem();

        if( pSpool->pIniJob ){
            pIniJob = pSpool->pIniJob;
        } else if( pSpool->pIniPort && pSpool->pIniPort->pIniJob ){
            pIniJob = pSpool->pIniPort->pIniJob;
        } else {
            pIniJob = NULL;
        }

        if( pIniJob ){

            if( pIniJob && pIniJob->Status & (JOB_PENDING_DELETION | JOB_RESTART) ){

                    // We had started a message box. See if the thread is still running or dismissed by user.
                    // If it is still running, wait for it to terminate before pIniJob can be freed.
                    // We need to leave the semaphore, since the UI thread we
                    // are waiting on could need to acquire it.
                    QuitThread( &hThread, dwThreadId, TRUE );

                    SetLastError( ERROR_PRINT_CANCELLED );
                    rc = FALSE;

                    goto Fail;

                }

            //
            // If there was no error, and the job was marked in an error
            // state, clear it.
            //
            if( rc &&
                ( pIniJob->Status & (JOB_PAPEROUT | JOB_OFFLINE | JOB_ERROR ))){
                ClearJobError( pIniJob );
            }
        }

        LeaveSplSem();

        //
        // If we failed and we have more bytes to write, then put
        // up the warning.  Some monitors may return FALSE, but actually
        // write data to the port.  Therefore we need to check both rc
        // and also cbBuf.
        //
        if (!rc && cbBuf)
        {
            //
            // Warning: We are sending in a stack variable. We need to be sure
            // the error UI thread is cleaned up before LocalWritePrinter()
            // returns!
            //
            if( PromptWriteError( pSpool, &hThread, &dwThreadId ) == IDCANCEL )
            {
                //
                // In this case I know thread will die by itself
                //
                CloseHandle(hThread);
                hThread = NULL;

                EnterSplSem();
                goto Fail;
            }
        }
        else
        {
            // We have started a message box and now the automatically
            // retry has succeeded, we need to kill the message box
            // and continue to print.
            QuitThread( &hThread, dwThreadId, FALSE );
        }
    }
    rc = TRUE;

    EnterSplSem();

Fail:

    SplInSem();

    //
    // Mark port handles to allow FlushPrinter to be called when WritePrinter fails.
    //
    if (!rc && (pSpool->TypeofHandle & PRINTER_HANDLE_PORT))
    {
        pSpool->Status |= SPOOL_STATUS_FLUSH_PRINTER;
    }

    LeaveSplSem();

    DBGMSG(DBG_TRACE, ("WritePrinter Written %d : %d\n", *pcWritten, rc));

    SplOutSem();

    SPLASSERT( hThread == NULL );

    return rc;
}

BOOL
WaitForSeekPrinter(
    PSPOOL pSpool,
    HANDLE hFile,
    LARGE_INTEGER liSeekFilePosition,
    DWORD  dwMoveMethod
)

/*++
Function Description: WaitForSeekPrinter waits till there is enough data written to the
                      spool file before the file pointer can be moved.

Parameters: pSpool - pointer to the SPOOL struct.
            hFile  - handle to the file whose pointer is to be set.
            liDistanceToMove - Offset to move the file pointer.
            dwMoveMethod - position to take offset. FILE_BEGIN | FILE_CURRENT | FILE_END

Return Values: TRUE for success
               FALSE otherwise
--*/

{

    BOOL  bWaitForWrite = FALSE, bReturn = FALSE;
    DWORD dwFileSizeHigh, dwFileSizeLow, dwWaitResult;

    LARGE_INTEGER liCurrentFilePosition;

    // For Print while spooling wait till sufficient number of bytes have been written.
    if ( pSpool->pIniJob->Status & JOB_SPOOLING ) {

       if ( dwMoveMethod == FILE_END ) {

          pSpool->pIniJob->bWaitForEnd = TRUE;
          bWaitForWrite = TRUE;

       } else {
          // Save the current file position.
          liCurrentFilePosition.QuadPart = 0;
          liCurrentFilePosition.u.LowPart = SetFilePointer( hFile,
                                                            liCurrentFilePosition.u.LowPart,
                                                            &liCurrentFilePosition.u.HighPart,
                                                            FILE_CURRENT );
          if ((liCurrentFilePosition.u.LowPart == 0xffffffff) && (GetLastError() != NO_ERROR)) {
             goto CleanUp;
          }

          // Get the current size of the file
          if (pSpool->pIniJob->Status & JOB_TYPE_OPTIMIZE) {
              dwFileSizeLow = pSpool->pIniJob->dwValidSize;
              dwFileSizeHigh = 0;
          } else {
              dwFileSizeLow = GetFileSize(hFile, &dwFileSizeHigh);
              if ((dwFileSizeLow == 0xffffffff) && (GetLastError() != NO_ERROR)) {
                  goto CleanUp;
              }
          }

          // Set the new file pointer.
          liSeekFilePosition.u.LowPart = SetFilePointer( hFile,
                                                         liSeekFilePosition.u.LowPart,
                                                         &liSeekFilePosition.u.HighPart,
                                                         dwMoveMethod );
          if ((liSeekFilePosition.u.LowPart == 0xffffffff) && (GetLastError() != NO_ERROR)) {
              goto CleanUp;
          }

          // Reset the file pointer using the saved current file position.
          liCurrentFilePosition.u.LowPart = SetFilePointer( hFile,
                                                            liCurrentFilePosition.u.LowPart,
                                                            &liCurrentFilePosition.u.HighPart,
                                                            FILE_BEGIN );
          if ((liCurrentFilePosition.u.LowPart == 0xffffffff) && (GetLastError() != NO_ERROR)) {
             goto CleanUp;
          }

          // Check new position of the file pointer with the current file size.
          if ((liSeekFilePosition.u.HighPart > (LONG)dwFileSizeHigh) ||
              ( (liSeekFilePosition.u.HighPart == (LONG)dwFileSizeHigh) &&
                (liSeekFilePosition.u.LowPart > dwFileSizeLow))) {

              // Set the fields in INIJOB.
              pSpool->pIniJob->liFileSeekPosn.QuadPart  = liSeekFilePosition.QuadPart;
              bWaitForWrite = TRUE;
          }

       }

       if (bWaitForWrite) {
          // Create and wait on an event. Exit the Spooler semaphore.
          if (pSpool->pIniJob->WaitForSeek == NULL) {
              pSpool->pIniJob->WaitForSeek  = CreateEvent( NULL,
                                                           EVENT_RESET_AUTOMATIC,
                                                           EVENT_INITIAL_STATE_NOT_SIGNALED,
                                                           NULL );
          }
          if (!pSpool->pIniJob->WaitForSeek ||
              !ResetEvent(pSpool->pIniJob->WaitForSeek)) {
              pSpool->pIniJob->WaitForSeek = NULL;
              goto CleanUp;
          }

          pSpool->pIniJob->bWaitForSeek =  TRUE;

          // Increment ref counts before leaving the semaphore
          pSpool->cRef++;
          INCJOBREF(pSpool->pIniJob);

          LeaveSplSem();

          dwWaitResult = WaitForSingleObject(pSpool->pIniJob->WaitForSeek,
                                             INFINITE);

          EnterSplSem();

          pSpool->cRef--;
          DECJOBREF(pSpool->pIniJob);

          // If wait failed or the handles are invalid fail the call
          if ((dwWaitResult == WAIT_FAILED)              ||
              (dwWaitResult == WAIT_TIMEOUT)             ||
              (pSpool->Status & SPOOL_STATUS_CANCELLED)  ||
              (pSpool->pIniJob->Status & (JOB_TIMEOUT | JOB_PENDING_DELETION |
                                          JOB_ABANDON | JOB_RESTART))) {

              goto CleanUp;
          }
       }
    }

    // Set the return value.
    bReturn = TRUE;

CleanUp:

    pSpool->pIniJob->bWaitForSeek =  FALSE;

    return bReturn;
}


BOOL
LocalSeekPrinter(
    HANDLE hPrinter,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER pliNewPointer,
    DWORD dwMoveMethod,
    BOOL bWritePrinter
    )

/*++

Routine Description: LocalSeekPrinter moves the file pointer in the spool file to the position
                     indicated by liDistanceToMove. This call is synchronous and it waits if
                     the job is being spooled and the required number of bytes have not been
                     written as yet.

Arguments: hPrinter - handle to the Printer.
           liDistanceToMove - offset to move the file pointer.
           pliNewPointer - pointer to a LARGE_INTEGER which will contain the new position
                           of the file pointer.
           dwMoveMethod - position to take offset. FILE_BEGIN | FILE_CURRENT | FILE_END

Return Value: TRUE if the file pointer can be moved to the required location
              FALSE otherwise.

--*/

{
    PSPOOL pSpool = (PSPOOL)hPrinter;
    HANDLE hFile;
    BOOL   bReturn = FALSE;
    DWORD  dwFileSizeHigh, dwFileSizeLow;

    SplOutSem();
    EnterSplSem();

    // Check for handle validity
    if( !ValidateSpoolHandle( pSpool, PRINTER_HANDLE_SERVER )){
        DBGMSG( DBG_WARNING, ("LocalSeekPrinter ERROR_INVALID_HANDLE\n"));
        goto CleanUp;
    }

    if( pSpool->Status & SPOOL_STATUS_CANCELLED ){
        DBGMSG( DBG_WARNING, ("LocalSeekPrinter ERROR_PRINT_CANCELLED\n"));
        SetLastError( ERROR_PRINT_CANCELLED );
        goto CleanUp;
    }

    if( !( pSpool->TypeofHandle & PRINTER_HANDLE_JOB ) ||
        ( pSpool->TypeofHandle & PRINTER_HANDLE_DIRECT )){

        DBGMSG( DBG_WARNING, ("LocalSeekPrinter: not a job handle, or direct\n" ));
        SetLastError( ERROR_NOT_SUPPORTED );
        goto CleanUp;
    }

    // Avoid waiting for jobs that can't print.
    if( !pSpool->pIniJob ||
        pSpool->pIniJob->Status & (JOB_TIMEOUT | JOB_ABANDON |
                                   JOB_PENDING_DELETION | JOB_RESTART) ) {
        DBGMSG( DBG_WARNING, ("LocalSeekPrinter ERROR_PRINT_CANCELLED\n"));
        SetLastError( ERROR_PRINT_CANCELLED );
        goto CleanUp;
    }

    // Seek fails while writing to the spool file.
    if( bWritePrinter ) {
        goto CleanUp;
    } else {
        hFile = pSpool->hReadFile;
    }

    // Wait for data to be written, if necessary.
    if (!WaitForSeekPrinter( pSpool,
                             hFile,
                             liDistanceToMove,
                             dwMoveMethod )) {
       goto CleanUp;
    }

    // Set the file pointer.
    pliNewPointer->u.LowPart = SetFilePointer( hFile,
                                               liDistanceToMove.u.LowPart,
                                               &liDistanceToMove.u.HighPart,
                                               dwMoveMethod );

    if( pliNewPointer->u.LowPart == 0xffffffff && GetLastError() != NO_ERROR ){
        goto CleanUp;
    }

    pliNewPointer->u.HighPart = liDistanceToMove.u.HighPart;

    // Fail the call if the pointer is moved beyond the end of file.
    // Get the current size of the file
    if (pSpool->pIniJob->Status & JOB_TYPE_OPTIMIZE) {
        dwFileSizeLow = pSpool->pIniJob->dwValidSize;
        dwFileSizeHigh = 0;
    } else {
        dwFileSizeLow = GetFileSize(hFile, &dwFileSizeHigh);
        if ((dwFileSizeLow == 0xffffffff) && (GetLastError() != NO_ERROR)) {
            goto CleanUp;
        }
    }

    // Check new position of the file pointer with the current file size.
    if ((pliNewPointer->u.HighPart > (LONG)dwFileSizeHigh) ||
        ( (pliNewPointer->u.HighPart == (LONG)dwFileSizeHigh) &&
          (pliNewPointer->u.LowPart > dwFileSizeLow))) {

         SetLastError(ERROR_NO_MORE_ITEMS);
         goto CleanUp;
    }

    bReturn = TRUE;

CleanUp:

    LeaveSplSem();

    return bReturn;
}


BOOL
LocalEndPagePrinter(
    HANDLE  hPrinter
)
{
    PSPOOL pSpool = (PSPOOL)hPrinter;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwFileSize;

    
    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {
        return(FALSE);
    }


    if (pSpool->Status & SPOOL_STATUS_CANCELLED) {
        SetLastError(ERROR_PRINT_CANCELLED);
        return FALSE;
    }

    if (pSpool->pIniJob != NULL) {

        if ( (pSpool->TypeofHandle & PRINTER_HANDLE_PORT) &&
            ((pSpool->pIniJob->Status & JOB_PRINTING) ||
             (pSpool->pIniJob->Status & JOB_DESPOOLING))) {

            // Despooling ( RapidPrint )
            UpdateJobAttributes(pSpool->pIniJob);

            pSpool->pIniJob->cLogicalPagesPrinted++;
            if (pSpool->pIniJob->cLogicalPagesPrinted >=
                         pSpool->pIniJob->dwDrvNumberOfPagesPerSide)
            {
                pSpool->pIniJob->cLogicalPagesPrinted = 0;
                pSpool->pIniJob->cPagesPrinted++;
                pSpool->pIniPrinter->cTotalPagesPrinted++;
            }

        } else {

            //
            // Spooling
            //

            if ( pSpool->pIniJob->Status & JOB_TYPE_ADDJOB ) {

                // If the Job is being written on the client side
                // the size is not getting updated so do it now on
                // the start page

                if ( pSpool->hReadFile != INVALID_HANDLE_VALUE ) {

                    hFile = pSpool->hReadFile;

                } else {

                    hFile = pSpool->pIniJob->hWriteFile;

                }

                if ( hFile != INVALID_HANDLE_VALUE ) {

                    dwFileSize = GetFileSize( hFile, 0 );

                    if ( pSpool->pIniJob->Size < dwFileSize ) {

                         DBGMSG( DBG_TRACE, ("EndPagePrinter adjusting size old %d new %d\n",
                            pSpool->pIniJob->Size, dwFileSize));

                         pSpool->pIniJob->dwValidSize = pSpool->pIniJob->Size;
                         pSpool->pIniJob->Size = dwFileSize;

                         // Support for despooling whilst spooling
                         // for Down Level jobs

                         if (pSpool->pIniJob->WaitForWrite != NULL)
                            SetEvent( pSpool->pIniJob->WaitForWrite );
                    }

                }

                CHECK_SCHEDULER();

            }

        }

    } else {

        DBGMSG(DBG_TRACE, ("LocalEndPagePrinter issued with no Job\n"));

    }

    return TRUE;
}

BOOL
LocalAbortPrinter(
   HANDLE hPrinter
)
{
    PSPOOL  pSpool=(PSPOOL)hPrinter;

    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {
       DBGMSG( DBG_WARNING, ("ERROR in AbortPrinter: %x\n", ERROR_INVALID_HANDLE));
        return FALSE;
    }

    if (!(pSpool->Status & SPOOL_STATUS_STARTDOC)) {
        SetLastError(ERROR_SPL_NO_STARTDOC);
        return(FALSE);
    }

    if (pSpool->pIniPort && !(pSpool->pIniPort->Status & PP_MONITOR)) {

        if (pSpool->Status & SPOOL_STATUS_PRINT_FILE) {
            
            if (!CloseHandle(pSpool->hFile)) {
                return(FALSE);
            }
            pSpool->Status &= ~SPOOL_STATUS_PRINT_FILE;
            pSpool->Status  |= SPOOL_STATUS_CANCELLED;
            return(TRUE);

        } else {
            return AbortPrinter(pSpool->hPort);
        }
    }



    pSpool->Status |= SPOOL_STATUS_CANCELLED;

    if (pSpool->TypeofHandle & PRINTER_HANDLE_PRINTER) {

        EnterSplSem();
        if (pSpool->pIniJob) {

            //
            // Reset JOB_RESTART flag, otherwise the job doesn't get deleted.
            // If AbortPrinter is called while the job is restarting, DeleteJob ignores the
            // job if JOB_RESTART is set and the Scheduler also ignores the job since it is 
            // marked as JOB_PENDING_DELETION. The job would stay in Deleting-Restarting forever.
            //
            pSpool->pIniJob->Status |= JOB_PENDING_DELETION;
            pSpool->pIniJob->Status &= ~JOB_RESTART;
            //
            // Release any thread waiting on LocalSetPort
            //
            SetPortErrorEvent(pSpool->pIniJob->pIniPort);
        }
        LeaveSplSem();
    }

    //
    // KrishnaG - fixes bug  2646, we need to clean up AbortPrinter
    // rewrite so that it doesn't fail on cases which EndDocPrinter should fail
    // get rid of comment when done
    //

    LocalEndDocPrinter(hPrinter);

    return TRUE;
}

BOOL
SplReadPrinter(
    HANDLE  hPrinter,
    LPBYTE  *pBuf,
    DWORD   cbBuf
)
/*++
Function Description: SplReadPrinter is an internal ReadPrinter which uses a memory mapped
                      spool file and returns the pointer to the required data in *pBuf.

Parameters: hPrinter          -- printer handle
            *pBuf             -- pointer to the buffer (mapped view)
            cbBuf             -- number of bytes to be read

Return Value: TRUE if successful;
              FALSE otherwise
--*/
{
    DWORD  NoBytesRead;
    BOOL   bReturn;

    // Not used currently

    bReturn = InternalReadPrinter(hPrinter, NULL, cbBuf, pBuf, &NoBytesRead, TRUE);

    if (!bReturn && (GetLastError() == ERROR_SUCCESS)) {
        // Memory mapped ReadPrinter may fail without setting the last error
        SetLastError(ERROR_NOT_SUPPORTED);
    }

    return bReturn;
}

BOOL
LocalReadPrinter(
    HANDLE   hPrinter,
    LPVOID   pBuf,
    DWORD    cbBuf,
    LPDWORD  pNoBytesRead
)
/*++
Routine Description: LocalReadPrinter reads the required number of bytes(or available) into the
                     specified buffer.

Arguments:  hPrinter      -- printer handle
            pBuf          -- pointer to the buffer to store data
            cbBuf         -- number of bytes to be read
            pNoBytesRead  -- pointer to variable to return number of bytes read

Return Value: TRUE if successful;
              FALSE otherwise
--*/
{
    return InternalReadPrinter(hPrinter, pBuf, cbBuf, NULL, pNoBytesRead, FALSE);
}

BOOL
InternalReadPrinter(
   HANDLE   hPrinter,
   LPVOID   pBuf,
   DWORD    cbBuf,
   LPBYTE   *pMapBuffer,
   LPDWORD  pNoBytesRead,
   BOOL     bReadMappedView
)
/*++
Routine Description: InternalReadPrinter reads the required number of bytes(or available) into the
                     specified buffer or returns a pointer to the mapped file view.

Arguments:  hPrinter      -- printer handle
            pBuf          -- pointer to the buffer to store data
            cbBuf         -- number of bytes to be read
            *pMapBuffer   -- pointer to the mapped file view
            pNoBytesRead  -- pointer to variable to return number of bytes read
            bReadMappedView -- flag for using mapped spool file

Return Value: TRUE if successful;
              FALSE otherwise
--*/
{
    PSPOOL      pSpool=(PSPOOL)hPrinter;
    DWORD       Error=0, rc;
    HANDLE      hWait;
    DWORD       dwFileSize = 0, dwCurrentPosition, dwOldValidSize;
    DWORD       ThisPortSecsToWait;
    DWORD       cbReadSize = cbBuf;
    DWORD       SizeInFile = 0;
    DWORD       BytesAllowedToRead = 0;
    NOTIFYVECTOR NotifyVector;
    PINIMONITOR  pIniMonitor;
    
    SplOutSem();

    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {
        DBGMSG( DBG_WARNING, ("LocalReadPrinter ERROR_INVALID_HANDLE\n"));
        return FALSE;
    }

    if (pSpool->Status & SPOOL_STATUS_CANCELLED) {
        DBGMSG( DBG_WARNING, ("LocalReadPrinter ERROR_PRINT_CANCELLED\n"));
        SetLastError(ERROR_PRINT_CANCELLED);
        return FALSE;
    }

    if ( pNoBytesRead != NULL ) {
        *pNoBytesRead = 0;
    }

    if (bReadMappedView) {
        // Supported only for JOB handles that aren't DIRECT
        if ( !(pSpool->TypeofHandle & PRINTER_HANDLE_JOB) ||
             pSpool->TypeofHandle & PRINTER_HANDLE_DIRECT ) {

             SetLastError(ERROR_NOT_SUPPORTED);
             return FALSE;
        }
    }

    if (pSpool->TypeofHandle & PRINTER_HANDLE_JOB) {

        if (pSpool->pIniJob->Status & (JOB_PENDING_DELETION | JOB_RESTART)) {
            DBGMSG( DBG_WARNING, ("LocalReadPrinter Error IniJob->Status %x\n",pSpool->pIniJob->Status));
            SetLastError(ERROR_PRINT_CANCELLED);
            return FALSE;
        }

        if (pSpool->TypeofHandle & PRINTER_HANDLE_DIRECT) {

            *pNoBytesRead = ReadFromPrinter(pSpool, pBuf, cbReadSize);

            SplOutSem();
            return TRUE;

        }

        //
        // Check that the user has read access.
        //
        if( !AccessGranted( SPOOLER_OBJECT_DOCUMENT,
                            JOB_READ,
                            pSpool )){

            SetLastError( ERROR_ACCESS_DENIED );
            return FALSE;
        }


        SplOutSem();
        EnterSplSem();

        //
        // RapidPrint
        //
        // NOTE this while loop is ONLY in operation if during RapidPrint
        // ie when we are Printing the same job we are Spooling
        //

        while (( pSpool->pIniJob->WaitForWrite != NULL ) &&
               ( pSpool->pIniJob->Status & JOB_SPOOLING )) {

            // Get the current file position.
            dwCurrentPosition = SetFilePointer( pSpool->hReadFile,
                                                0,
                                                NULL,
                                                FILE_CURRENT );

            if (dwCurrentPosition < pSpool->pIniJob->dwValidSize) {
                // Wait is not required
                break;
            }

            SplInSem();

            //
            // We cannot rely on pIniJob->Size to be accurate since for
            // downlevel jobs or jobs that to AddJob they are writing
            // to a file without calling WritePrinter.
            // So we call the file system to get an accurate file size
            //

            dwFileSize = GetFileSize( pSpool->hReadFile, 0 );

            if ( pSpool->pIniJob->Size != dwFileSize ) {

                DBGMSG( DBG_TRACE, ("LocalReadPrinter adjusting size old %d new %d\n",
                    pSpool->pIniJob->Size, dwFileSize));

                dwOldValidSize = pSpool->pIniJob->dwValidSize;

                //
                // Fix for print while spooling.  If it was AddJobed, then
                // the valid size is going to be the previous size, since
                // we know the old data will be flushed by the time the new
                // one is extended.
                //
                if( pSpool->pIniJob->Status & JOB_TYPE_ADDJOB ){

                    //
                    // The previous size becomes the next valid size.
                    //
                    pSpool->pIniJob->dwValidSize = pSpool->pIniJob->Size;

                } else if (!(pSpool->pIniJob->Status & JOB_TYPE_OPTIMIZE)) {

                    //
                    // The valid size is not necessary for non-AddJob
                    // jobs, since the write has been committed.
                    //
                    pSpool->pIniJob->dwValidSize = dwFileSize;
                }

                pSpool->pIniJob->Size = dwFileSize;

                if (dwOldValidSize != pSpool->pIniJob->dwValidSize) {

                    SetPrinterChange(pSpool->pIniPrinter,
                                     pSpool->pIniJob,
                                     NVSpoolJob,
                                     PRINTER_CHANGE_WRITE_JOB,
                                     pSpool->pIniSpooler);

                }

                continue;
            }

            if (pSpool->pIniJob->Status & (JOB_PENDING_DELETION | JOB_RESTART | JOB_ABANDON )) {

                SetLastError(ERROR_PRINT_CANCELLED);

                LeaveSplSem();
                SplOutSem();

                DBGMSG( DBG_WARNING, ("LocalReadPrinter Error 2 IniJob->Status %x\n",pSpool->pIniJob->Status));
                return FALSE;

            }

            //
            // Wait until something is written to the file
            //
            hWait = pSpool->pIniJob->WaitForWrite;
            ResetEvent( hWait );

            DBGMSG( DBG_TRACE, ("LocalReadPrinter Waiting for Data %d milliseconds\n",dwFastPrintWaitTimeout));

           LeaveSplSem();
           SplOutSem();

            rc = WaitForSingleObjectEx( hWait, dwFastPrintWaitTimeout, FALSE );

           SplOutSem();
           EnterSplSem();

            DBGMSG( DBG_TRACE, ("LocalReadPrinter Returned from Waiting %x\n", rc));
            SPLASSERT ( pSpool->pIniJob != NULL );

            //
            // If we did NOT timeout then we may have some Data to read
            //
            if ( rc != WAIT_TIMEOUT )
                continue;

            //
            // If there are any other jobs that could be printed on
            // this port give up waiting.
            //
            pSpool->pIniJob->Status |= JOB_TIMEOUT;

            // Set the event for SeekPrinter to fail rendering threads
            SeekPrinterSetEvent(pSpool->pIniJob, NULL, TRUE);

            if ( NULL == AssignFreeJobToFreePort(pSpool->pIniJob->pIniPort, &ThisPortSecsToWait) )
                continue;

            //
            // There is another Job waiting
            // Freeze this job, the user can Restart it later
            //
            pSpool->pIniJob->Status |= JOB_ABANDON;


            CloseHandle( pSpool->pIniJob->WaitForWrite );
            pSpool->pIniJob->WaitForWrite = NULL;

            // Assign it our Error String

            ReallocSplStr(&pSpool->pIniJob->pStatus, szFastPrintTimeout);

            SetPrinterChange(pSpool->pIniJob->pIniPrinter,
                             pSpool->pIniJob,
                             NVJobStatusAndString,
                             PRINTER_CHANGE_SET_JOB,
                             pSpool->pIniJob->pIniPrinter->pIniSpooler );

            DBGMSG( DBG_WARNING,
                    ("LocalReadPrinter Timeout on pIniJob %x %ws %ws\n",
                      pSpool->pIniJob,
                      pSpool->pIniJob->pUser,
                      pSpool->pIniJob->pDocument));

            LogJobInfo( pSpool->pIniSpooler,
                        MSG_DOCUMENT_TIMEOUT,
                        pSpool->pIniJob->JobId,
                        pSpool->pIniJob->pDocument,
                        pSpool->pIniJob->pUser,
                        pSpool->pIniJob->pIniPrinter->pName,
                        dwFastPrintWaitTimeout );

            SetLastError(ERROR_SEM_TIMEOUT);

            LeaveSplSem();
            SplOutSem();

            return FALSE;

        }   // END WHILE

        pSpool->pIniJob->Status &= ~( JOB_TIMEOUT | JOB_ABANDON );

        //
        // RapidPrint
        //
        // Some printers (like HP 4si with PSCRIPT) timeout if they
        // don't get data, so if we fall below a threshold of data
        // in the spoolfile then throttle back the Reads to 1 Byte
        // per second until we have more data to ship to the printer
        //
        if (( pSpool->pIniJob->WaitForWrite != NULL ) &&
            ( pSpool->pIniJob->Status & JOB_SPOOLING )) {

            // Get the current file position.
            dwCurrentPosition = SetFilePointer( pSpool->hReadFile,
                                                0,
                                                NULL,
                                                FILE_CURRENT );

            SizeInFile = pSpool->pIniJob->Size - dwCurrentPosition;

            if ( dwFastPrintSlowDownThreshold >= SizeInFile ) {

                cbReadSize = 1;

                hWait = pSpool->pIniJob->WaitForWrite;
                ResetEvent( hWait );

                DBGMSG( DBG_TRACE, ("LocalReadPrinter Throttling IOs waiting %d milliseconds SizeInFile %d\n",
                                        dwFastPrintThrottleTimeout,SizeInFile));

               LeaveSplSem();
               SplOutSem();

                rc = WaitForSingleObjectEx( hWait, dwFastPrintThrottleTimeout, FALSE );

               SplOutSem();
               EnterSplSem();

                DBGMSG( DBG_TRACE, ("LocalReadPrinter Returned from Waiting %x\n", rc));
                SPLASSERT ( pSpool->pIniJob != NULL );

            } else {

                BytesAllowedToRead = SizeInFile - dwFastPrintSlowDownThreshold;

                if ( cbReadSize > BytesAllowedToRead ) {
                    cbReadSize = BytesAllowedToRead;
                }
            }
        }

        //
        // A client calls AddJob to get the spool filename and
        // ScheduleJob when the file is completed.  According to the
        // api spec, the spooler should not look at the job until
        // ScheduleJob has been called.
        //
        // However, our print while spooling implementation tries
        // to read the job before ScheduleJob is called.  We do this
        // by checking if the size of the file has changed.
        //
        // This causes a problem: the server service extends the
        // file then writes to it.  The spooler's size detection
        // thread sees this extension and reads the file before
        // the data is written, which puts garbage (zeros) into the
        // data stream.
        //
        // The server always extends, writes, extends, writes, etc.
        // The spooler can exploit the fact that they are in order
        // and read a write only when the file is extended again,
        // or the file is complete.
        //
        // Note that the API is still broken, but this fixes it
        // for the server service (a client could extend, extend,
        // write, write, which breaks this fix).
        //

        if( pSpool->pIniJob->Status & JOB_SPOOLING ){

            // Get the current file position.
            dwCurrentPosition = SetFilePointer( pSpool->hReadFile,
                                                0,
                                                NULL,
                                                FILE_CURRENT );

            SPLASSERT( dwCurrentPosition <= pSpool->pIniJob->dwValidSize );

            //
            // Even though the file system will satisfy a large request, limit
            // it to the extent of the previous (not current) write.
            //

            BytesAllowedToRead = pSpool->pIniJob->dwValidSize - dwCurrentPosition;


            if( cbReadSize > BytesAllowedToRead ){
                cbReadSize = BytesAllowedToRead;
            }
        }

        LeaveSplSem();
        SplOutSem();

        if (bReadMappedView) {
            // Mapping partial views serves no purpose, since it can't be used incrementally.
            if (cbBuf != cbReadSize) {
                rc = FALSE;
            } else {
                rc = SetMappingPointer(pSpool, pMapBuffer, cbReadSize);
            }

            if (rc) {
               *pNoBytesRead = cbReadSize;
            }

        } else {
            
            rc = ReadFile( pSpool->hReadFile, pBuf, cbReadSize, pNoBytesRead, NULL);        
        }

        if (!bReadMappedView) {

            DBGMSG( DBG_TRACE,
                    ("LocalReadPrinter rc %x hReadFile %x pBuf %x cbReadSize %d *pNoBytesRead %d\n",
                    rc, pSpool->hReadFile, pBuf, cbReadSize, *pNoBytesRead));
        }

        //  Provide Feedback so user can see printing progress
        //  on despooling, the size is update here and not in write
        //  printer because the journal data is larger than raw

        if ( ( pSpool->pIniJob->Status & JOB_PRINTING ) &&
             ( *pNoBytesRead != 0 )) {
           
           SplOutSem();
           EnterSplSem();

            dwFileSize = GetFileSize( pSpool->hReadFile, 0 );

            COPYNV(NotifyVector, NVWriteJob);

            if ( pSpool->pIniJob->Size < dwFileSize ) {

                DBGMSG( DBG_TRACE, ("LocalReadPrinter 2 adjusting size old %d new %d\n",
                    pSpool->pIniJob->Size, dwFileSize));

                pSpool->pIniJob->Size = dwFileSize;

                ADDNV(NotifyVector, NVSpoolJob);
            }

            pSpool->pIniJob->cbPrinted += *pNoBytesRead;

            //
            // HACK !!! Each time we read from the spool file we add the
            // number of bytes read to pIniJob->cbPrinted. GDI will read twice certain
            // parts of the spool file. The spooler cannot know what is read twice, so it adds
            // to cbPrinted the number of bytes read at each call of this function.
            // This causes cbPrinted to be larger than the actual size of the spool file.
            //
            // Don't let the ratio cbPrinted/cbSize get above 1
            // 
            if (pSpool->pIniJob->cbPrinted > pSpool->pIniJob->Size) 
            {
                pSpool->pIniJob->cbPrinted = pSpool->pIniJob->Size;
            }
            
            //
            // Provide Feedback to Printman that data has been
            // written.  Note the size written is not used to
            // update the IniJob->cbPrinted becuase there is a
            // difference in size between journal data (in the
            // spool file) and the size of RAW bytes written to
            // the printer.
            //
            SetPrinterChange(pSpool->pIniPrinter,
                             pSpool->pIniJob,
                             NotifyVector,
                             PRINTER_CHANGE_WRITE_JOB,
                             pSpool->pIniSpooler);

           LeaveSplSem();
           SplOutSem();

        }

    } else if ( pSpool->TypeofHandle & PRINTER_HANDLE_PORT ) {

        if (pSpool->pIniPort->Status & PP_FILE)
        rc = ReadFile( pSpool->hReadFile, pBuf, cbReadSize, pNoBytesRead, NULL);

        else if ( pSpool->pIniPort->Status & PP_MONITOR ) {

            if ( pSpool->pIniPort->pIniLangMonitor ) {

                pIniMonitor = pSpool->pIniPort->pIniLangMonitor;
            } else {

                pIniMonitor = pSpool->pIniPort->pIniMonitor;
            }

            SplOutSem();
            
            rc = (*pIniMonitor->Monitor2.pfnReadPort)(
                     pSpool->pIniPort->hPort,
                     pBuf,
                     cbReadSize,
                     pNoBytesRead );
            
        } else
            rc = ReadPrinter(pSpool->hPort, pBuf, cbReadSize, pNoBytesRead);

    } else {

        SetLastError(ERROR_INVALID_HANDLE);
        rc = FALSE;
    }

    SplOutSem();

    DBGMSG( DBG_TRACE, ("LocalReadPrinter returns hPrinter %x pIniJob %x rc %x pNoBytesRead %d\n",hPrinter, pSpool->pIniJob, rc, *pNoBytesRead));

    return rc;
}

LPBYTE SearchForExistingView(
    PSPOOL  pSpool,
    DWORD   dwRequired)

/*++
Function Description -- Searches for an existing mapped view of the spool file which
                        has the required number of bytes.

Parameters --  pSpool     -- Pointer to a SPOOL structure
               dwRequired -- Number of bytes to be mapped from the start of the page

Return Value -- pointer to the start of the mapped view;
                NULL if the call fails.
--*/

{
    LPBYTE        pReturn = NULL;
    PSPLMAPVIEW   pSplMapView;

    for (pSplMapView = pSpool->pSplMapView;
         pSplMapView;
         pSplMapView = pSplMapView->pNext) {

        if (dwRequired <= pSplMapView->dwMapSize) {
            pReturn = pSplMapView->pStartMapView;
            break;
        }
    }

    return pReturn;
}

LPBYTE CreateNewMapView(
    PSPOOL  pSpool,
    DWORD   dwRequired)

/*++
Function Description -- Creates a new mapping view of the required segment of the spool
                        file

Parameters --  pSpool     -- Pointer to a SPOOL structure
               dwRequired -- Number of bytes to be mapped from the start of the page

Return Value -- pointer to the start of the mapped view;
                NULL if the call fails.
--*/

{
    HANDLE          hMapSpoolFile;
    LPBYTE          pStartMapView;
    DWORD           dwMapSize, dwFileSize;
    LPBYTE          pReturn = NULL;
    PSPLMAPVIEW     pSplMapView;

    pSplMapView  =  (PSPLMAPVIEW) AllocSplMem(sizeof(SPLMAPVIEW));

    if (!pSplMapView) {
        // Allocation failed.
        goto CleanUp;
    }

    dwFileSize = GetFileSize(pSpool->hReadFile, NULL);

    pSplMapView->dwMapSize = (dwFileSize <= MAX_SPL_MAPVIEW_SIZE) ? dwFileSize
                                                                  : dwRequired;

    pSplMapView->hMapSpoolFile = NULL;
    pSplMapView->pStartMapView = NULL;
    pSplMapView->pNext = NULL;

    // Create file mapping
    pSplMapView->hMapSpoolFile = CreateFileMapping(pSpool->hReadFile, NULL, PAGE_READONLY,
                                                   0, pSplMapView->dwMapSize, NULL);
    if (!pSplMapView->hMapSpoolFile) {
        goto CleanUp;
    }

    // Map a view of the file
    pSplMapView->pStartMapView = (LPBYTE) MapViewOfFile(pSplMapView->hMapSpoolFile, FILE_MAP_READ,
                                                        0, 0, pSplMapView->dwMapSize);

    pReturn = pSplMapView->pStartMapView;

CleanUp:

    if (!pReturn && pSplMapView) {
        // Free any allocated resources
        if (pSplMapView->pStartMapView) {
            UnmapViewOfFile( (LPVOID) pSplMapView->pStartMapView);
        }
        if (pSplMapView->hMapSpoolFile) {
            CloseHandle(pSplMapView->hMapSpoolFile);
        }
        FreeSplMem(pSplMapView);
    }

    if (pReturn) {
        pSplMapView->pNext = pSpool->pSplMapView;
        pSpool->pSplMapView = pSplMapView;
    }

    return pReturn;
}

BOOL SetMappingPointer(
    PSPOOL pSpool,
    LPBYTE *pMapBuffer,
    DWORD  cbReadSize
)
/*++
Function Description: SetMappingPointer creates a file mapping object and a mapped view (if necessary).
                      If the required number of bytes are present in the view, the pointer to the
                      data is returned in the buffer (pMappedBuffer) else the call fails.
                      The current offset is taken from pSpool->hReadFile and if the buffer is available,
                      the offset of hReadFile is changed correspondingly. This ensures that SplReadPrinter
                      and ReadPrinter can be used alternately.

                      ****Modifications required for 64 bit architecture****

Parameters:   pSpool        -- pointer to the SPOOL structure
              *pMapBuffer   -- pointer to the mapped file view
              cbReadView    -- number of bytes to be read

Return Values: TRUE if successful;
               FALSE otherwise
--*/
{
    BOOL   bReturn = FALSE;
    DWORD  dwCurrentPosition, dwNewPosition, dwRequired;
    LPBYTE pStartMapView;

    dwCurrentPosition = SetFilePointer(pSpool->hReadFile, 0, NULL, FILE_CURRENT);

    if (dwCurrentPosition == 0xffffffff && GetLastError() != NO_ERROR) {
        goto CleanUp;
    }

    dwRequired = dwCurrentPosition + cbReadSize;

    if (dwRequired > MAX_SPL_MAPVIEW_SIZE) {
        // Map size is insufficient; fail the call
        SetLastError(ERROR_NOT_SUPPORTED);
        goto CleanUp;
    }

    pStartMapView = SearchForExistingView(pSpool, dwRequired);

    if (!pStartMapView) {
        pStartMapView = CreateNewMapView(pSpool, dwRequired);
    }

    if (!pStartMapView) {
        // Required view not created
        goto CleanUp;
    }

    // Check for DWORD alignment
    if ((((ULONG_PTR) pStartMapView + dwCurrentPosition) & 3) != 0) {
        // Fails unaligned reads
        SetLastError(ERROR_MAPPED_ALIGNMENT);
        goto CleanUp;
    }

    dwNewPosition = SetFilePointer(pSpool->hReadFile, cbReadSize, NULL, FILE_CURRENT);

    if (dwNewPosition == 0xffffffff && GetLastError() != NO_ERROR) {
        goto CleanUp;
    }

    if (pMapBuffer) {
        *pMapBuffer = (LPBYTE) ((ULONG_PTR) pStartMapView + dwCurrentPosition);
    }

    bReturn = TRUE;

CleanUp:

    // All the handles and associated resources will be freed along with pSpool
    return bReturn;
}

BOOL
LocalEndDocPrinter(
   HANDLE hPrinter
   )

/*++

Routine Description:

    By Default the routine is in critical section.
    The reference counts for any object we are working on (pSpool and pIniJob)
    are incremented, so that when we leave critical section for lengthy
    operations these objects are not deleted.

Arguments:


Return Value:


--*/

{
    PSPOOL      pSpool=(PSPOOL)hPrinter;
    BOOL        bReturn = TRUE;
    DWORD       rc;
    PINIMONITOR pIniMonitor;
    
    DBGMSG(DBG_TRACE, ("Entering LocalEndDocPrinter with %x\n", hPrinter));
    
    SplOutSem();
    EnterSplSem();

    if (pSpool          &&
        pSpool->pIniJob &&
        !(pSpool->TypeofHandle & PRINTER_HANDLE_PORT)) {
        
        INCJOBREF(pSpool->pIniJob);
        LeaveSplSem();
        
        LogWmiTraceEvent(pSpool->pIniJob->JobId, EVENT_TRACE_TYPE_SPL_TRACKTHREAD, NULL);

        EnterSplSem();
        DECJOBREF(pSpool->pIniJob);
    }
    
    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER ))  {
        LeaveSplSem();
        return(FALSE);
    }
    
    if (!(pSpool->Status & SPOOL_STATUS_STARTDOC)) {
        SetLastError(ERROR_SPL_NO_STARTDOC);
        LeaveSplSem();
        return(FALSE);
    }

    if (pSpool->Status & SPOOL_STATUS_ADDJOB) {
        SetLastError(ERROR_SPL_NO_STARTDOC);
        LeaveSplSem();
        return(FALSE);
    }
    
    if ( pSpool->pIniJob ) {
        pSpool->pIniJob->dwAlert |= JOB_ENDDOC_CALL;
    }

    pSpool->Status &= ~SPOOL_STATUS_STARTDOC;

    //
    // Case-1 Printer Handle is PRINTER_HANDLE_PORT
    // Note - there are two cases to keep in mind here

    // A] The first case is the despooling thread calling
    // a port with a monitor - LPT1:/COM1: or any port
    // created by the monitor

    // B] The second case is when the application thread is
    // doing an EndDocPrinter to a port which has no monitor
    // This is the local printer masquerading as a remote  printer
    // case. Remember for this case there is no IniJob created
    // on the local printer at all. We just pass the call
    // straight to the remote printer

    if (pSpool->TypeofHandle & PRINTER_HANDLE_PORT) {

        SPLASSERT(!(pSpool->TypeofHandle & PRINTER_HANDLE_PRINTER));

        //
        // Now check if this pSpool object's port has
        // a monitor

        if ( pSpool->pIniPort->Status & PP_MONITOR ) { //Case A]

            //
            // Check if our job is really around
            //

            if (!pSpool->pIniJob) {
                SetLastError(ERROR_CAN_NOT_COMPLETE);
                bReturn = FALSE;
                goto CleanUp;
            }

            //
            // Originally we had a call to UpdateJobAttributes, but
            // we do not believe it is needed since it is also called during
            // LocalStartDocPrinter.  Note that you can't change the DevMode
            // in SetLocalJob, so once we calculate the information, we
            // don't have to worry about it changing.
            //

            if (pSpool->pIniJob->cLogicalPagesPrinted)
            {
                pSpool->pIniJob->cLogicalPagesPrinted = 0;
                pSpool->pIniJob->cPagesPrinted++;
                pSpool->pIniPrinter->cTotalPagesPrinted++;

                SetPrinterChange(pSpool->pIniPrinter,
                                 pSpool->pIniJob,
                                 NVWriteJob,
                                 PRINTER_CHANGE_WRITE_JOB,
                                 pSpool->pIniSpooler);
            }

            //
            // We need to leave the spooler critical section
            // because we're going call into the Monitor.
            // so bump up ref count on pSpool and pIniJob
            //
            pSpool->cRef++;

            INCJOBREF(pSpool->pIniJob);

            if ( pSpool->pIniPort->pIniLangMonitor ) {

                pIniMonitor = pSpool->pIniPort->pIniLangMonitor;
                //
                // If job is printing thru a language monitor we will get
                // SetJob with JOB_CONTROL_LAST_PAGE_EJECTED in addition to
                // JOB_CONTROL_SENT_TO_PRINTER
                //
                pSpool->pIniJob->dwJobControlsPending += 2;
            } else {

                pIniMonitor = pSpool->pIniPort->pIniMonitor;
                pSpool->pIniJob->dwJobControlsPending++;
            }

            //
            // LocalEndDocPrinter cal be called because a normal termination of
            // a job or because of a delete/restart operation.
            // We need to know this when the monitor sends JOB_CONTROL_LAST_PAGE_EJECTED
            // to make the distinction if this is a real TEOJ or not.
            // Since JOB_PENDING_DELETION and JOB_RESTART are cleared later on,
            // we'll set this special flag.
            // JOB_INTERRUPTED means that LocalEndDocPrinter was issued by a 
            // was a cancel/restart action.
            //
            if (pSpool->pIniJob->Status & (JOB_PENDING_DELETION | JOB_RESTART)) {

                pSpool->pIniJob->Status |= JOB_INTERRUPTED;                
            }

            LeaveSplSem();

            SPLASSERT(pIniMonitor);

            STARTENDDOC( pSpool->pIniPort, pSpool->pIniJob, 1 );

            SPLASSERT( pSpool->pIniPort->Status & PP_STARTDOC );

            SplOutSem();

            (*pIniMonitor->Monitor2.pfnEndDocPort)(pSpool->pIniPort->hPort);

            EnterSplSem();
            pSpool->pIniPort->Status &= ~PP_STARTDOC;
            pSpool->cRef--;


            DECJOBREF(pSpool->pIniJob);

            goto CleanUp;

        } else { // Case B]

            //
            // We leave critical section here so bump pSpool object only
            // Note ----THERE IS NO INIJOB HERE AT ALL---Note
            // this call is synchronous; we will call into the router
            // who will then call the appropriate network print providor
            // e.g win32spl.dll
            //
             pSpool->cRef++;
             LeaveSplSem();

             if (pSpool->Status & SPOOL_STATUS_PRINT_FILE) {
                 if (!CloseHandle(pSpool->hFile)) {
                     DBGMSG(DBG_TRACE, ("LocalEndDocPrinter: Printing to File, CloseHandle failed\n"));
                     bReturn = FALSE;
                 } else {
                    DBGMSG(DBG_TRACE, ("LocalEndDocPrinter: Printing to File, CloseHandle succeeded\n"));
                    pSpool->Status &= ~SPOOL_STATUS_PRINT_FILE;
                    bReturn = TRUE;
                }
             } else {
                bReturn = (BOOL) EndDocPrinter(pSpool->hPort);
             }

             EnterSplSem();
             pSpool->cRef--;
             goto CleanUp;
        }
    }

    SplInSem();
    //
    //  Case-2  Printer Handle is Direct
    //
    //
    //  and the else clause is
    //
    //
    // Case-3  Printer Handle is Spooled
    //

    if (!pSpool->pIniJob) {
        SetLastError(ERROR_CAN_NOT_COMPLETE);
        bReturn = FALSE;
        goto CleanUp;
    }


    if (pSpool->TypeofHandle & PRINTER_HANDLE_DIRECT) {

        HANDLE WaitForRead = pSpool->pIniJob->WaitForRead;
        PINIPORT pIniPort1 = pSpool->pIniJob->pIniPort;
        if (pIniPort1) {        // Port may have been deleted by another EndDocPrinter

            SPLASSERT(!(pSpool->TypeofHandle & PRINTER_HANDLE_PORT));

            // Printer Handle is Direct

            pSpool->cRef++;
            INCJOBREF(pSpool->pIniJob);
            pIniPort1->cRef++;

            //
            // If the job was canceled by the user, there is no need to wait
            // for the write and read events. In certain cases when the job is
            // direct and canceled before LocalEndDocPrinter, those events
            // will never be signaled again. So waiting on them will be infinite
            //
            if (!(pSpool->pIniJob->Status & JOB_PENDING_DELETION)) 
            {
                LeaveSplSem();
    
                if( (WaitForRead != NULL) ){
                    WaitForSingleObject(WaitForRead, INFINITE);
                }
            
                pSpool->pIniJob->cbBuffer = 0;
                SetEvent(pSpool->pIniJob->WaitForWrite);
                WaitForSingleObject(pIniPort1->Ready, INFINITE);
    
                SplOutSem();
                EnterSplSem();

            } else {
                //
                // If the job is canceled, there are no more Write operations coming in.
                // Unlock the port thread which is waiting on this event inside ReadPrinter.
                //
                SetEvent(pSpool->pIniJob->WaitForWrite);
                //
                // Set cbBuffer on 0, since there are no more Read/Write oparatins expected.
                //
                pSpool->pIniJob->cbBuffer = 0;
            }

            pSpool->cRef--;
            pIniPort1->cRef--;
            DECJOBREF(pSpool->pIniJob);

            if ((pIniPort1->Status & PP_DELETING) && !pIniPort1->cRef)
                DeletePortEntry(pIniPort1);
        }

    } else {

        // Printer Handle is Spooled

        SPLASSERT(!(pSpool->TypeofHandle & PRINTER_HANDLE_PORT));
        SPLASSERT(!(pSpool->TypeofHandle & PRINTER_HANDLE_DIRECT));

        // Update page count
        LeaveSplSem();

        UpdateJobAttributes(pSpool->pIniJob);

        EnterSplSem();

        if (pSpool->pIniJob->cLogicalPages)
        {
            pSpool->pIniJob->cLogicalPages = 0;
            pSpool->pIniJob->cPages++;

            // Notify the change in the page count
            SetPrinterChange(pSpool->pIniPrinter,
                             pSpool->pIniJob,
                             NVSpoolJob,
                             PRINTER_CHANGE_WRITE_JOB,
                             pSpool->pIniSpooler);
        }

#if 0
        // Thought to be a performance hit
        // so removed from PPC release.

        // In the event of a power failure we want to make certain that all
        // data for this job has been written to disk

        rc = FlushFileBuffers(pSpool->pIniJob->hWriteFile);

        if ( !rc ) {
            DBGMSG(DBG_WARNING, ("LocalEndDocPrinter FlushFileBuffers failed hWriteFile %x Error %d\n",
                                  pSpool->pIniJob->hWriteFile, GetLastError() ));
        }
#endif

        if (pSpool->pIniJob->hFileItem != INVALID_HANDLE_VALUE)
        {
            // If this job is a keeper or the job is greater than 200KB and not
            // already printing close the write file, so that the memory from
            // the file can be reclaimed by the system.  Without this the
            // spooler can eat up a lot of memory.  File pooling doesn't
            // significantly help speed up printing of the larger files anyway.
            // If the printer is stopped or the job is big and not already
            // despooling or printing then close files, which closes the memory
            // mappings (buffered I/O).

            // Not necessarily bad, this also is true if the printer is paused.
            if ((PrinterStatusBad(pSpool->pIniJob->pIniPrinter->Status) ||
                 (pSpool->pIniJob->pIniPrinter->Attributes &
                  PRINTER_ATTRIBUTE_WORK_OFFLINE)) &&
                !(pSpool->pIniJob->Status & JOB_PRINTING) &&
                !(pSpool->pIniJob->Status & JOB_DESPOOLING))
            {
                LeaveSplSem();
                CloseFiles(pSpool->pIniJob->hFileItem, TRUE);
                EnterSplSem();
            }
            else if (!(pSpool->pIniJob->Status & JOB_PRINTING) &&
                 (pSpool->pIniJob->Size > FP_LARGE_SIZE))
            {
                LeaveSplSem();
                CloseFiles(pSpool->pIniJob->hFileItem, TRUE);
                EnterSplSem();
            }
            FinishedWriting(pSpool->pIniJob->hFileItem, TRUE);
            pSpool->pIniJob->hWriteFile = INVALID_HANDLE_VALUE;
            
        }
        else if (!CloseHandle(pSpool->pIniJob->hWriteFile)) {
            DBGMSG(DBG_WARNING, ("CloseHandle failed %d %d\n", pSpool->pIniJob->hWriteFile, GetLastError()));

        } else {
            DBGMSG(DBG_TRACE, ("LocalEndDocPrinter: ClosedHandle Success hWriteFile\n" ));
            pSpool->pIniJob->hWriteFile = INVALID_HANDLE_VALUE;
        }

        // Despooling whilst spooling requires us to wake the writing
        // thread if it is waiting.

        if ( pSpool->pIniJob->WaitForWrite != NULL )
            SetEvent(pSpool->pIniJob->WaitForWrite);

        // Set the event for SeekPrinter
        SeekPrinterSetEvent(pSpool->pIniJob, NULL, TRUE);

    }

    SPLASSERT(pSpool);
    SPLASSERT(pSpool->pIniJob);


    // Case 2 - (Direct)  and Case 3 - (Spooled) will both execute
    // this block of code because both direct and spooled handles
    // are first and foremost PRINTER_HANDLE_PRINTER handles


    if (pSpool->TypeofHandle & PRINTER_HANDLE_PRINTER) {

        SPLASSERT(!(pSpool->TypeofHandle & PRINTER_HANDLE_PORT));

        // WARNING
        // If pIniJob->Status has JOB_SPOOLING removed and we leave
        // the critical section then the scheduler thread will
        // Start the job printing.   This could cause a problem
        // in that the job could be completed and deleted
        // before the shadow job is complete.   This would lead
        // to access violations.

        SPLASSERT(pSpool);
        SPLASSERT(pSpool->pIniJob);

        if (pSpool->pIniJob->Status & JOB_SPOOLING) {

            pSpool->pIniJob->Status &= ~JOB_SPOOLING;
            pSpool->pIniJob->pIniPrinter->cSpooling--;
        }


        // It looks like the ref count on the job is != 0, so the job should not
        // get deleted while this shadow is being written.
        // Having this operation in the critsec is preventing us from getting
        // good CPU utilization.  Icecap is showing many (100+ in some cases)
        // other spool threads waiting on this when I push the server.
        WriteShadowJob(pSpool->pIniJob, TRUE);
        
        SplInSem();

        //
        // This line of code is crucial; for timing reasons it
        // has been moved from the Direct (Case 2) and the
        // Spooled (Case 3) clauses. This decrement is for the
        // initial
        //

        SPLASSERT(pSpool->pIniJob->cRef != 0);
        DECJOBREF(pSpool->pIniJob);

        if (pSpool->pIniJob->Status & JOB_PENDING_DELETION) {

            DBGMSG(DBG_TRACE, ("EndDocPrinter: Deleting Pending Deletion Job\n"));
            DeleteJob(pSpool->pIniJob,BROADCAST);
            pSpool->pIniJob = NULL;

        } else {

            if ( pSpool->pIniJob->Status & JOB_TIMEOUT ) {

                pSpool->pIniJob->Status &= ~( JOB_TIMEOUT | JOB_ABANDON );
                FreeSplStr(pSpool->pIniJob->pStatus);
                pSpool->pIniJob->pStatus = NULL;
            }

            DBGMSG(DBG_TRACE, ("EndDocPrinter:PRINTER:cRef = %d\n", pSpool->pIniJob->cRef));
            CHECK_SCHEDULER();
        }
    }

    if (pSpool->pIniJob) {

        SetPrinterChange(pSpool->pIniPrinter,
                         pSpool->pIniJob,
                         NVJobStatus,
                         PRINTER_CHANGE_SET_JOB,
                         pSpool->pIniSpooler);
    }

CleanUp:
    
    if (pSpool->pIniJob) {
        pSpool->pIniJob->dwAlert &= ~JOB_ENDDOC_CALL;
        
        //
        // WMI Trace Events
        //
        if (((pSpool->pIniJob->Status & JOB_PAUSED) ||
             (pSpool->pIniJob->pIniPrinter->Status & PRINTER_PAUSED)) &&
            (!((pSpool->pIniJob->Status & JOB_PRINTING)   ||
               (pSpool->pIniJob->Status & JOB_PRINTED))))
        {
            INCJOBREF(pSpool->pIniJob);
            LeaveSplSem();

            LogWmiTraceEvent(pSpool->pIniJob->JobId, EVENT_TRACE_TYPE_SPL_PAUSE, NULL);
            
            EnterSplSem();
            DECJOBREF(pSpool->pIniJob);
        }
    }

    LeaveSplSem();
    SplOutSem();
    
    return bReturn;
}

BOOL
PrintingDirectlyToPort(
    PSPOOL  pSpool,
    DWORD   Level,
    LPBYTE  pDocInfo,
    LPDWORD pJobId
)
{
    PDOC_INFO_1 pDocInfo1=(PDOC_INFO_1)pDocInfo;
    BOOL    rc;
    DWORD   Error;
    BOOL bPrinttoFile = FALSE;
    BOOL bErrorOccurred = FALSE;
    PINIMONITOR pIniMonitor = NULL, pIniLangMonitor = NULL;
    LPWSTR      pszPrinter;
    HANDLE      hThread = NULL;
    DWORD       dwThreadId = 0;
    TCHAR       szFullPrinter[MAX_UNC_PRINTER_NAME];
    
    //
    // Some monitors rely on having the non-qualified name, so only
    // use the fully qualified name for clustered spoolers.
    //
    // This means that anyone writing a cluster aware monitor will
    // need to handle both types of names.
    //
    if( pSpool->pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){

        //
        // Must use fully qualified name.
        //
        pszPrinter = szFullPrinter;

        wsprintf( szFullPrinter,
                  L"%ws\\%ws",
                  pSpool->pIniPrinter->pIniSpooler->pMachineName,
                  pSpool->pIniPrinter->pName );

    } else {

        //
        // Local name is sufficient.
        //
        pszPrinter = pSpool->pIniPrinter->pName;
    }

    DBGMSG( DBG_TRACE,
            ( "PrintingDirectlyToPort: Printing document %ws direct to port\n",
              DBGSTR( pDocInfo1->pDocName )));

    if (pDocInfo1 &&
        pDocInfo1->pDatatype &&
        !ValidRawDatatype(pDocInfo1->pDatatype)) {

        //
        // XEROX
        //
        // We want to skip the error if this flags is on and there
        // is no monitor.
        //
        if (!(pSpool->pIniSpooler->SpoolerFlags & SPL_NON_RAW_TO_MASQ_PRINTERS &&
              !(pSpool->pIniPort->Status & PP_MONITOR))){

            DBGMSG(DBG_WARNING, ("Datatype is not RAW\n"));

            SetLastError(ERROR_INVALID_DATATYPE);
            rc = FALSE;
            goto CleanUp;
        }
    }

    if (pSpool->pIniPort->Status & PP_MONITOR) {

        if ( !(pSpool->pIniPort->Status & PP_FILE) &&
             (pSpool->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_ENABLE_BIDI) )
            pIniLangMonitor = pSpool->pIniPrinter->pIniDriver->pIniLangMonitor;


        //
        // WARNING!!
        //
        // We should never leave this loop unless we check for the presence of the UI
        // thread (hThread) and make sure it has been terminted.
        //
        //
        do {

            //
            // This fixes Intergraph's problem -- of wanting to print
            // to file but their 3.1 print-processor  does not pass
            // thru the file name.
            //
            if (pSpool->pIniJob->Status & JOB_PRINT_TO_FILE) {
                if ( pDocInfo1 && !pDocInfo1->pOutputFile ) {
                    pDocInfo1->pOutputFile = pSpool->pIniJob->pOutputFile;
                }
            }

            //
            // Some monitors (LPRMON) may fail to initialize at startup
            // because a driver they are dependent on.
            //

            SplOutSem();
            EnterSplSem();

            //
            // Check if being deleted.
            //
            if( pSpool->pIniJob->Status & JOB_PENDING_DELETION ){

                LeaveSplSem();
                SetLastError(ERROR_PRINT_CANCELLED);

                if( hThread ) {

                    //
                    // See if the thread is still running or
                    // dismissed by user.
                    //
                    if( WAIT_TIMEOUT == WaitForSingleObject( hThread, 0 )) {

                        MyPostThreadMessage(hThread, dwThreadId,
                                            WM_QUIT, IDRETRY, 0);
                        WaitForSingleObject( hThread, INFINITE );
                    }
                    CloseHandle( hThread );
                    hThread = NULL;
                }

                rc = FALSE;
                goto CleanUp;
            }


            rc = OpenMonitorPort(pSpool->pIniPort,
                                 &pIniLangMonitor,
                                 pszPrinter,
                                 TRUE);

            //
            // If the port monitor would not work with a lang monitor try to
            // use port monitor directly
            //
            if ( !rc && pIniLangMonitor ) {

                PINIMONITOR pIniLangMonitor2 = NULL;

                rc = OpenMonitorPort(pSpool->pIniPort,
                                     &pIniLangMonitor2,
                                     pszPrinter,
                                     TRUE);

                if ( rc )
                    pIniLangMonitor = NULL;
            }

            LeaveSplSem();

            if ( rc ) {

                if ( pIniLangMonitor )
                    pIniMonitor = pIniLangMonitor;
                else
                    pIniMonitor = pSpool->pIniPort->pIniMonitor;

                STARTENDDOC( pSpool->pIniPort, pSpool->pIniJob, 0 );

                
                SplOutSem();
                rc = (*pIniMonitor->Monitor2.pfnStartDocPort)(
                                             pSpool->pIniPort->hPort,
                                             pszPrinter,
                                             pSpool->pIniJob->JobId,
                                             Level, pDocInfo);

            }
                
            if ( rc ) {

                pSpool->pIniPort->Status |= PP_STARTDOC;

                //
                // StartDoc successful.
                //
                if ( hThread ) {

                    //
                    // We have started a message box and now the
                    // automatically retry has succeeded, we need to
                    // kill the message box and continue to print.
                    //
                    // See if the thread is still running or dismissed
                    // by user.
                    //
                    if ( WAIT_TIMEOUT == WaitForSingleObject( hThread, 0 )) {

                        MyPostThreadMessage(hThread, dwThreadId,
                                            WM_QUIT, IDRETRY, 0 );
                        WaitForSingleObject( hThread, INFINITE );
                    }
                    CloseHandle( hThread );
                    hThread = NULL;
                }
            } else {

                Error = GetLastError();

                //
                // Check for pending deletion first, which prevents the
                // dialog from coming up if the user hits Del.
                //
                if ( (pSpool->pIniJob->Status & (JOB_PENDING_DELETION | JOB_RESTART)) ||
                     (PromptWriteError( pSpool, &hThread, &dwThreadId ) == IDCANCEL)) {

                    if ( hThread ) {

                        //
                        // See if the thread is still running or
                        // dismissed by user.
                        //
                        if ( WAIT_TIMEOUT == WaitForSingleObject( hThread, 0 )) {
                            MyPostThreadMessage(hThread, dwThreadId,
                                                WM_QUIT, IDRETRY, 0 );
                            WaitForSingleObject( hThread, INFINITE );
                        }
                        CloseHandle( hThread );
                        hThread = NULL;
                    }

                    pSpool->pIniJob->StartDocError = Error;
                    SetLastError(ERROR_PRINT_CANCELLED);
                    rc = FALSE;
                    goto CleanUp;
                }
                bErrorOccurred = TRUE;
            }
            

        } while (!rc);

        //
        // If an error occurred, we set some error bits in the job
        // status field.  Clear them now since the StartDoc succeeded.
        //
        if( bErrorOccurred ){
            EnterSplSem();
            ClearJobError( pSpool->pIniJob );
            LeaveSplSem();
        }

        pSpool->Status |= SPOOL_STATUS_STARTDOC;

        if ( pIniLangMonitor ) {

            pSpool->pIniJob->Status |= JOB_TRUE_EOJ;
        }

        if ( pSpool->pIniJob->pIniPrinter->pSepFile &&
             *pSpool->pIniJob->pIniPrinter->pSepFile) {

            DoSeparator(pSpool);
        }

        // Let the application's thread return from PrintingDirect:

        DBGMSG(DBG_PORT, ("PrintingDirectlyToPort: Calling SetEvent( %x )\n",
                          pSpool->pIniJob->StartDocComplete));

        if(pSpool->pIniJob->StartDocComplete) {

            if ( !SetEvent( pSpool->pIniJob->StartDocComplete ) ) {

                DBGMSG( DBG_WARNING, ("SetEvent( %x ) failed: Error %d\n",
                                      pSpool->pIniJob->StartDocComplete,
                                      GetLastError() ));
            }
        }

    } else  {

        DBGMSG(DBG_TRACE, ("Port has no monitor: Calling StartDocPrinter or maybe printing to file\n"));

        EnterSplSem();
        bPrinttoFile = (pDocInfo1 && IsGoingToFile(pDocInfo1->pOutputFile,
                                        pSpool->pIniSpooler));
        LeaveSplSem();

        if (bPrinttoFile) {

            HANDLE hFile = INVALID_HANDLE_VALUE;

            DBGMSG(DBG_TRACE, ("Port has no monitor: Printing to File %ws\n", pDocInfo1->pOutputFile));

            hFile = CreateFile( pDocInfo1->pOutputFile,
                                GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                NULL );

            if (hFile == INVALID_HANDLE_VALUE) {
                DBGMSG(DBG_TRACE, ("Port has no monitor: File open failed\n"));
                rc = FALSE;
            } else {
                DBGMSG(DBG_TRACE, ("Port has no monitor: File open succeeded\n"));
                SetEndOfFile(hFile);
                pSpool->hFile = hFile;
                pSpool->Status |= SPOOL_STATUS_PRINT_FILE;

                //
                // Have to set JobId to some non zero value otherwise
                // StartDocPrinter expects the JobId to be off the pSpool->pIniJob
                // We have none so we'll access violate!!
                //
                *pJobId = TRUE;
                rc = TRUE;
            }


        } else {
            DBGMSG(DBG_TRACE, ("Port has no monitor: Calling StartDocPrinter\n"));

            *pJobId = StartDocPrinter(pSpool->hPort, Level, pDocInfo);
            rc = *pJobId != 0;
        }

        if (!rc) {
            DBGMSG(DBG_WARNING, ("StartDocPrinter failed: Error %d\n", GetLastError()));
        }
    }

    SPLASSERT( hThread == NULL );

CleanUp:

    return rc;
}

DWORD
WriteToPrinter(
    PSPOOL  pSpool,
    LPBYTE  pByte,
    DWORD   cbBuf
)
{

    if( pSpool->pIniJob->WaitForRead != NULL ) {

        WaitForSingleObject(pSpool->pIniJob->WaitForRead, INFINITE);

        cbBuf = pSpool->pIniJob->cbBuffer = min(cbBuf, pSpool->pIniJob->cbBuffer);
        memcpy(pSpool->pIniJob->pBuffer, pByte, cbBuf);

    } else {

        pSpool->pIniJob->cbBuffer = cbBuf = 0;

    }

    SetEvent(pSpool->pIniJob->WaitForWrite);

    return cbBuf;
}

DWORD
ReadFromPrinter(
    PSPOOL  pSpool,
    LPBYTE  pBuf,
    DWORD   cbBuf
)
{
    pSpool->pIniJob->pBuffer = pBuf;
    pSpool->pIniJob->cbBuffer = cbBuf;

    SetEvent(pSpool->pIniJob->WaitForRead);

    WaitForSingleObject(pSpool->pIniJob->WaitForWrite, INFINITE);

    return pSpool->pIniJob->cbBuffer;
}

BOOL
ValidRawDatatype(
    LPWSTR pszDatatype)
{
    if (!pszDatatype || _wcsnicmp(pszDatatype, szRaw, 3))
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\upgrade.c ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation

Module Name:

    upgrade.c

Abstract:

    The routines in this file are for Upgrading from NT 3.1 to NT 4.0 for Drivers
    for all CPU Environment.

    This is achieved by copy the files to a %systemroot%\system32\spool\tmp
    directory then calling copying them back 1 at a time and calling
    InternalAddPrinterDriver, which will do version checking and copy them to the
    correct version.

    This code only has to worry about upgrading from NT 3.1, because NT 3.1 didn't have
    the ability to store different versions of drivers.   If we are upgrading from 3.5 or
    3.51 the drivers and registy will already have them installed in the correct location.

    Setup is responsible ( after the spooler has been loaded ) to actually bring down new
    versions of each printer driver.   It does that by calling EnumPrinterDrivers to figure
    out what we have, then calling AddPrinterDriver to install a new version of each driver.
    ( at some point it will do that for all environments.


Author:

    Krishna Ganugapati (KrishnaG) 21-Apr-1994

Revision History:

    Matthew A Felton ( MattFe ) Aug 9 1995
    Remove the code which was married to TextMode setup to move drivers for one directory to another
    Now all environment upgrade from 3.1 is handled the same.

--*/

#include <precomp.h>
#pragma hdrstop

#include "clusspl.h"

extern WCHAR *szSpoolDirectory;
extern WCHAR *szDirectory;
extern PWCHAR ipszRegistryWin32Root;
extern DWORD dwUpgradeFlag;
extern BUILTIN_FORM BuiltInForms[];

VOID
UpgradeDrivers(
    HKEY hEnvironmentsRootKey,
    LPWSTR pszEnvironmentName,
    PINISPOOLER pIniSpooler
    )
{
    HKEY  hEnvironmentKey;
    HKEY  hDriversKey;
    WCHAR VersionName[MAX_PATH];
    DWORD cbBuffer, cchBuffer;
    DWORD cVersion;
    PINIDRIVER pIniDriver;
    WCHAR szEnvironmentDriverDirectory[MAX_PATH];
    WCHAR szEnvironmentScratchDirectory[MAX_PATH];
    DRIVER_INFO_2 DriverInfo;
    DWORD Level = 2;


    //
    //  Open Environment Key e.g. W32X86
    //

    if ( RegOpenKeyEx( hEnvironmentsRootKey,
                       pszEnvironmentName,
                       0,
                       KEY_ALL_ACCESS,
                       &hEnvironmentKey) != ERROR_SUCCESS) {

        DBGMSG( DBG_WARN, ("UpgradeDrivers Could not open %ws key\n", pszEnvironmentName));
        return;
    }

    //
    // Open Drivers Key
    //


    if ( RegOpenKeyEx( hEnvironmentKey,
                       szDriversKey,
                       0,
                       KEY_ALL_ACCESS,
                       &hDriversKey)  != ERROR_SUCCESS) {

        DBGMSG( DBG_WARN, ("UpgradeDrivers Could not open %ws key\n", szDriversKey));
        RegCloseKey( hEnvironmentKey );
        return;
    }


    cbBuffer = sizeof( szEnvironmentScratchDirectory );

    if ( RegQueryValueEx( hEnvironmentKey,
                          L"Directory",
                          NULL,
                          NULL,
                          (LPBYTE)szEnvironmentScratchDirectory,
                          &cbBuffer) != ERROR_SUCCESS) {

        DBGMSG( DBG_TRACE, ("UpgradeDrivers  RegQueryValueEx -- Error %d\n", GetLastError()));
    }

    DBGMSG(DBG_TRACE, ("UpgradeDrivers The name of the scratch directory is %ws\n", szEnvironmentScratchDirectory));

    if((StrNCatBuff(szEnvironmentDriverDirectory,
                   COUNTOF(szEnvironmentDriverDirectory),
                   pIniSpooler->pDir,
                   L"\\drivers\\",
                   szEnvironmentScratchDirectory,
                   NULL)==ERROR_SUCCESS))
    {
         DBGMSG(DBG_TRACE, ("UpgradeDrivers The name of the driver directory is %ws\n", szEnvironmentDriverDirectory));
     
     
         cVersion = 0;
         memset(VersionName, 0, sizeof(VersionName));
         cchBuffer = COUNTOF(VersionName);
     
     
         //
         //  Loop through all the NT 3.1 driver and do an AddPrinterDriver to move them
         //  to the correct destination.
         //
     
         while ( RegEnumKeyEx( hDriversKey,
                               cVersion,
                               VersionName,
                               &cchBuffer,
                               NULL,
                               NULL,
                               NULL,
                               NULL) == ERROR_SUCCESS) {
     
             DBGMSG( DBG_TRACE, ("UpgradeDrivers Name of the sub-key is %ws\n", VersionName));
     
     
             //
             //  If Key begins "Version-" then it is not a printer driver, skip it
             //
     
             if ( !_wcsnicmp( VersionName, L"Version-", 8 )) {
     
                 cVersion++;
                 memset(VersionName, 0, sizeof(VersionName));
                 cchBuffer = COUNTOF(VersionName);
                 continue;
             }
     
             DBGMSG( DBG_TRACE,("UpgradeDrivers  Older Driver Version Found\n", VersionName));
     
             if ( !(pIniDriver = GetDriver( hDriversKey, VersionName, pIniSpooler, NULL, NULL ))) {
     
                 RegDeleteKey(hDriversKey, VersionName);
                 cVersion = 0;
                 memset(VersionName, 0, sizeof(VersionName));
                 cchBuffer = COUNTOF(VersionName);
                 continue;
             }
     
             memset( &DriverInfo, 0, sizeof(DRIVER_INFO_2));
     
             DriverInfo.pName        = pIniDriver->pName;
             DriverInfo.pEnvironment = pszEnvironmentName;
             DriverInfo.pDriverPath  = pIniDriver->pDriverFile;
             DriverInfo.pConfigFile  = pIniDriver->pConfigFile;
             DriverInfo.pDataFile    = pIniDriver->pDataFile;
             DriverInfo.cVersion     = pIniDriver->cVersion;
     
             InternalAddPrinterDriverEx( NULL, Level, (LPBYTE)&DriverInfo, APD_COPY_NEW_FILES,
                                         pIniSpooler, USE_SCRATCH_DIR, DO_NOT_IMPERSONATE_USER );
     
             //
             // Get Rid of the NT 3.1 Driver Key, since it is now in the correct Version-0 sub key
             //
             RegDeleteKey( hDriversKey, VersionName );
     
             cVersion = 0;
             memset(VersionName, 0, sizeof( VersionName ));
             cchBuffer = COUNTOF(VersionName);
             FreeSplStr(pIniDriver->pName);
             FreeSplStr(pIniDriver->pDriverFile);
             FreeSplStr(pIniDriver->pConfigFile);
             FreeSplStr(pIniDriver->pDataFile);
             FreeSplMem(pIniDriver);
         }
    }
    RegCloseKey(hDriversKey);
    RegCloseKey(hEnvironmentKey);
}




VOID
Upgrade31DriversRegistryForAllEnvironments(
    PINISPOOLER pIniSpooler
    )
/*++

Routine Description:

    This routine "Upgrades" the registry and moves printer drivers to their correct
    location based on the version of the printer driver.

    This only has to happen when upgrading from NT 3.1, because on newer builds the
    registry and drivers are correct.

    ON NT 3.1 the drivers are in %systemroot%\system32\spool\drivers\w32x86

    On new builds the are in     %systemroot%\system32\spool\drivers\w32x86\2   ( version 2 )

    3.1 registry the drivers are stored ...\Environments\Windows NT x86\Drivers

    on new builds they are in       ...\Environments\Windows NT x86\Drivers\Version-2 ( version 2 )

    So all the old Version 0 drivers need to be moved to the correct location and the registy updated


Arguments:

    pIniSpooer - pointer to spooler


Return Value:

    None

--*/
{
    HKEY hEnvironmentsRootKey;
    WCHAR EnvironmentName[MAX_PATH];
    DWORD cEnvironment;
    DWORD cchBuffer;
    DWORD   dwLastError = ERROR_SUCCESS;

   LeaveSplSem();
    SplOutSem();


    dwLastError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                pIniSpooler->pszRegistryEnvironments,
                                0,
                                KEY_ALL_ACCESS,
                                &hEnvironmentsRootKey );

    if ( dwLastError != ERROR_SUCCESS) {

        DBGMSG( DBG_WARN, ("Upgrade31DriversRegistryForAllEnvironments Could not open %ws key error %d\n", pIniSpooler->pszRegistryEnvironments, dwLastError));

        SetLastError( dwLastError );
        return;
    }

    cEnvironment = 0;
    cchBuffer = COUNTOF( EnvironmentName );
    memset(EnvironmentName, 0, sizeof( EnvironmentName ));

    while ( RegEnumKeyEx( hEnvironmentsRootKey,
                          cEnvironment,
                          EnvironmentName,
                          &cchBuffer,
                          NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {

        DBGMSG( DBG_TRACE, ("Upgrade31DriversRegistryForAllEnvironments Name of the sub-key is %ws\n", EnvironmentName));

        UpgradeDrivers( hEnvironmentsRootKey, EnvironmentName, pIniSpooler );

        cEnvironment++;
        memset( EnvironmentName, 0, sizeof(EnvironmentName) );
        cchBuffer = COUNTOF( EnvironmentName );
    }

    RegCloseKey( hEnvironmentsRootKey );

   SplOutSem();
   EnterSplSem();

    return;
}


DWORD
RemoveCachedInfo(
    )
/*++

Description:
    Removes all the cached info about the connections user had on upgrade.
    This is temporary solution. Later we will need to go through each
    connection and "upgrade" the cached info -- particularly DevMode


Return Vlaue:
    ERROR_SUCCESS on successfully deleting. Otherwis error code

--*/
{
    DWORD   dwLastError;
    HKEY    hRootKey;

    dwLastError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               ipszRegistryWin32Root,
                               0,
                               KEY_ALL_ACCESS,
                               &hRootKey);

    if ( dwLastError != ERROR_SUCCESS ) {

        DBGMSG(DBG_WARNING,
               ("RemoveCachedConnectionInfo RegOepnKeyEx error %d\n",
               dwLastError));
        goto Cleanup;
    }

    dwLastError = DeleteSubkeys(hRootKey, NULL);

    RegCloseKey(hRootKey);
    if ( dwLastError != ERROR_SUCCESS ) {

        DBGMSG(DBG_WARNING,
               ("RemoveCachedConnectionInfo RegSetValue error %d\n", dwLastError));
    }

Cleanup:

    return dwLastError;
}


VOID
QueryUpgradeFlag(
    PINISPOOLER pIniSpooler
    )
/*++

    Description: the query update flag is set up by TedM. We will read this flag
    if the flag has been set, we will set a boolean variable saying that we're in
    the upgrade mode. All upgrade activities will be carried out based on this flag.
    For subsequents startups of the spooler, this flag will be unvailable so we
    won't run the spooler in upgrade mode.

    This code has been moved into router spoolss\dll\init.c

--*/
{
    dwUpgradeFlag  = SplIsUpgrade ();

    //
    // Not needed anymore since ntprint.dll will perform the clean up
    //
    //if ( dwUpgradeFlag )
    //    RemoveCachedInfo();

    DBGMSG(DBG_TRACE, ("The Spooler Upgrade flag is %d\n", dwUpgradeFlag));
    return;
}

VOID UpgradeForms(
                  PINISPOOLER pIniSpooler
                 )
{
    PBUILTIN_FORM pBuiltInForm;
    HKEY          hFormsKey;
    WCHAR         BuiltInFormName[MAX_PATH];
    WCHAR         CustomFormName[FORM_NAME_LEN+1];
    WCHAR         CustomPad[CUSTOM_NAME_LEN+1];
    BYTE          FormData[32];
    DWORD         cbCustomFormName;
    DWORD         cbFormData;
    int           cForm;

    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                      pIniSpooler->pszRegistryForms,
                      0,
                      KEY_ALL_ACCESS,
                      &hFormsKey) != ERROR_SUCCESS)
    {
         DBGMSG( DBG_WARN, ("UpgradeForms Could not open %ws key\n", ipszRegistryForms));
         return;
    }


    if(!LoadStringW(hInst,
                    IDS_FORM_CUSTOMPAD,
                    CustomPad,
                    CUSTOM_NAME_LEN+1))
    {
       DBGMSG( DBG_WARN, ("UpgradeForms Could not find Custom string in resources"));
       goto CleanUp;
    }

    for(cForm=0;

        memset(CustomFormName, 0, sizeof(CustomFormName)),
        cbCustomFormName = COUNTOF(CustomFormName),
        RegEnumValueW(hFormsKey,
                      cForm,
                      CustomFormName,
                      &cbCustomFormName,
                      NULL,
                      NULL,
                      NULL,
                      NULL) == ERROR_SUCCESS;

        cForm++)
    {
        for(pBuiltInForm = BuiltInForms; pBuiltInForm->NameId; pBuiltInForm++)
        {
            if(!LoadStringW(hInst,
                            pBuiltInForm->NameId,
                            BuiltInFormName,
                            FORM_NAME_LEN+1))
            {
               DBGMSG( DBG_WARN, ("UpgradeForms Could not find Built in Form with Resource ID = %d in resource",pBuiltInForm->NameId));
               goto CleanUp;
            }

            if(!_wcsicmp(BuiltInFormName,CustomFormName))
            {
                SPLASSERT(wcslen(CustomFormName)<=FORM_NAME_LEN);
                cbFormData=FORM_DATA_LEN;
                if(RegQueryValueExW(hFormsKey, CustomFormName,
                                 NULL,NULL, (LPBYTE)FormData,
                                 &cbFormData)!=ERROR_SUCCESS)
                {
                   DBGMSG( DBG_WARN, ("UpgradeForms Could not find value %ws",CustomFormName));
                   goto CleanUp;
                }
                if(RegDeleteValueW(hFormsKey,CustomFormName)!=ERROR_SUCCESS)
                {
                   DBGMSG( DBG_WARN, ("UpgradeForms Could not delete value %ws",CustomFormName));
                   goto CleanUp;
                }
                wcsncat(CustomFormName,CustomPad,
                        CUSTOM_NAME_LEN-wcslen(CustomFormName));
                if(RegSetValueExW(hFormsKey,CustomFormName, 0, REG_BINARY,
                               (LPBYTE)FormData,
                               cbFormData)!=ERROR_SUCCESS)
                {
                   DBGMSG( DBG_WARN, ("UpgradeForms Could not set value %s",CustomFormName));
                   goto CleanUp;
                }
                cForm = -1;
                break;
            }
        }
    }
CleanUp:
    RegCloseKey(hFormsKey);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\upgrade2.c ===
/*++

Copyright (c) 1994 - 1995 Microsoft Corporation

Module Name:

    upgrade2.c

Abstract:

    The routines in this file are Registry Mungers for the Upgrade case of
    NT 3.1 to NT 3.5.

    In NT 3.1 we didn't have registry entries Version-0 Version-1 etc. nor directories.

    Also Setup copies the drivers to both \0 and \1 directories
    so we now have to generate Version-0 and Version-1 structures in the
    registry and validate that the drivers in \1 really are version 1
    and those in \0 are Version-0.

    These routines only operate on the Environment that matches the CPU
    that we are running on.   This is because Setup doesn't upgrade drivers
    for other platforms during upgrade.

    Code for "Upgrading" the other CPU environments is found in upgrade.c

Author:

    Krishna Ganugapati (KrishnaG) 21-Apr-1994

Revision History:

--*/

#include <precomp.h>

#define         DAYTONA_VERSION                         1
#define         PRODUCT1_VERSION                        0


DWORD
GetDriverMajorVersion(
    LPWSTR pFileName
    );

DWORD
UpgradeValidateDriverFilesinVersionDirectory(
    LPWSTR pEnvironmentDirectory,
    DWORD  dwVersion,
    LPWSTR pDriverFile,
    LPWSTR pConfigFile,
    LPWSTR pDataFile
    );

BOOL
UpgradeWriteDriverIni(
    PINIDRIVER pIniDriver,
    DWORD  dwVersion,
    LPWSTR pszEnvironmentName,
    PINISPOOLER pIniSpooler
);

extern WCHAR *szSpoolDirectory;
extern WCHAR *szDirectory;
extern DWORD dwUpgradeFlag;

VOID
UpgradeOurDriver(
        HKEY hEnvironmentsRootKey,
        LPWSTR pszEnvironmentName,
        PINISPOOLER pIniSpooler
)
/*++

Routine Description:

    This function upgrades drivers for our spooler's environment. It expects driver
    files to have been migrated by setup to the 1 and to the 0 directories. We
    will scan the registry, check if there are any driver entries around and
    migrate each entry.

Arguments:

    hEnvironmentsRootKey    this is a handle to Print\Environments opened with
    KEY_ALL_ACCESS

    pszEnvironmentName      this is the string describing our environment

Return Value:

    VOID

--*/
{
        HKEY hEnvironmentKey;
        HKEY hDriversKey;
        WCHAR VersionName[MAX_PATH];
        DWORD cbBuffer;
        DWORD cVersion;
        PINIDRIVER pIniDriver;
        WCHAR szEnvironmentScratchDirectory[MAX_PATH];
        DWORD Type;
        DWORD Level = 2;
        DWORD dwVersion = 0;


        if ( RegOpenKeyEx( hEnvironmentsRootKey, pszEnvironmentName, 0,
                           KEY_ALL_ACCESS, &hEnvironmentKey) != ERROR_SUCCESS) {

            DBGMSG(DBG_WARNING, ("UpgradeOurDrivers Could not open %ws key\n", pszEnvironmentName ));

            RegCloseKey(hEnvironmentsRootKey);
            return;
        }


        cbBuffer = sizeof( szEnvironmentScratchDirectory );

        if ( RegQueryValueEx( hEnvironmentKey, L"Directory",
                              NULL, NULL, (LPBYTE)szEnvironmentScratchDirectory,
                              &cbBuffer) != ERROR_SUCCESS) {

            DBGMSG(DBG_TRACE, ("RegQueryValueEx -- Error %d\n", GetLastError()));
        }


        if ( RegOpenKeyEx( hEnvironmentKey, szDriversKey, 0,
                           KEY_ALL_ACCESS, &hDriversKey)  != ERROR_SUCCESS) {

            DBGMSG(DBG_TRACE, ("Could not open %ws key\n", szDriversKey));

            RegCloseKey( hEnvironmentKey );
            RegCloseKey( hEnvironmentsRootKey );
            return;
        }

        cVersion = 0;

        memset( VersionName, 0, sizeof(WCHAR)*MAX_PATH );

        cbBuffer = COUNTOF( VersionName );

        while ( RegEnumKeyEx( hDriversKey, cVersion, VersionName,
                              &cbBuffer, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {

            DBGMSG(DBG_TRACE, ("Name of the sub-key is %ws\n", VersionName));

            if ( !_wcsnicmp( VersionName, L"Version-", 8 )) {

                cVersion++;
                memset( VersionName, 0, sizeof(WCHAR)*MAX_PATH );
                cbBuffer = COUNTOF( VersionName );
                continue;
            }

            DBGMSG(DBG_TRACE,("Older Driver Version Found", VersionName));

            if ( !(pIniDriver = GetDriver( hDriversKey, VersionName, pIniSpooler ))) {

                RegDeleteKey( hDriversKey, VersionName );
                cVersion = 0;
                memset(VersionName, 0, sizeof(WCHAR)*MAX_PATH);
                cbBuffer = COUNTOF( VersionName );
                continue;
            }

            //
            // Validate that the file is in the 1 directory  and in the 0
            // directory.
            //

            if (UpgradeValidateDriverFilesinVersionDirectory(
                            szEnvironmentScratchDirectory,
                            (DWORD)DAYTONA_VERSION,
                            pIniDriver->pDriverFile,
                            pIniDriver->pConfigFile,
                            pIniDriver->pDataFile) == DAYTONA_VERSION){
                UpgradeWriteDriverIni(pIniDriver, DAYTONA_VERSION, pszEnvironmentName, pIniSpooler);
            }

            if (UpgradeValidateDriverFilesinVersionDirectory(
                            szEnvironmentScratchDirectory,
                            (DWORD)PRODUCT1_VERSION,
                            pIniDriver->pDriverFile,
                            pIniDriver->pConfigFile,
                            pIniDriver->pDataFile) == PRODUCT1_VERSION){
                UpgradeWriteDriverIni(pIniDriver, PRODUCT1_VERSION, pszEnvironmentName, pIniSpooler);
            }

            RegDeleteKey( hDriversKey, VersionName );
            cVersion = 0;
            memset( VersionName, 0, sizeof(WCHAR)*MAX_PATH );
            cbBuffer = COUNTOF( VersionName );
            FreeSplStr( pIniDriver->pName );
            FreeSplStr( pIniDriver->pDriverFile );
            FreeSplStr( pIniDriver->pConfigFile );
            FreeSplStr( pIniDriver->pDataFile );
            FreeSplMem( pIniDriver );
        }

        RegCloseKey( hDriversKey );
        RegCloseKey( hEnvironmentKey );
}

VOID
Upgrade31DriversRegistryForThisEnvironment(
    LPWSTR szEnvironment,
    PINISPOOLER pIniSpooler
    )
{
    HKEY hEnvironmentsRootKey;

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, pIniSpooler->pszRegistryEnvironments, 0,
                       KEY_ALL_ACCESS, &hEnvironmentsRootKey) != ERROR_SUCCESS) {

        DBGMSG(DBG_TRACE, ("Could not open %ws key\n", pIniSpooler->pszRegistryEnvironments));
        return;
    }

    UpgradeOurDriver( hEnvironmentsRootKey, szEnvironment, pIniSpooler );

    RegCloseKey( hEnvironmentsRootKey );
}






DWORD
UpgradeGetEnvironmentDriverDirectory(
    LPWSTR   pDir,
    LPWSTR   pEnvironmentDirectory
)
{
   DWORD i=0;
   LPWSTR psz;
   WCHAR Buffer[MAX_PATH];

   GetSystemDirectory(Buffer, sizeof(Buffer));
   wcscat(Buffer, szSpoolDirectory);
   psz = Buffer;
   while (pDir[i++] = *psz++)
        ;
   pDir[i-1] = L'\\';
   psz = szDriverDir;
   while (pDir[i++] = *psz++)
       ;
   pDir[i-1] = L'\\';
   psz = pEnvironmentDirectory;
   while (pDir[i++]=*psz++)
      ;
   return i-1;
}

DWORD
UpgradeValidateDriverFilesinVersionDirectory(
    LPWSTR pEnvironmentDirectory,
    DWORD  dwVersion,
    LPWSTR pDriverFile,
    LPWSTR pConfigFile,
    LPWSTR pDataFile
    )
{
    WCHAR szDriverBuffer[MAX_PATH];
    WCHAR szTempBuffer[MAX_PATH];
    WCHAR pDir[MAX_PATH];

    DBGMSG(DBG_TRACE, ("UpgradeValidateDriverFilesinVersionDirectory\n"));
    DBGMSG(DBG_TRACE, ("\tpEnvironmentDirectory: %ws\n", pEnvironmentDirectory));
    DBGMSG(DBG_TRACE, ("\tdwVersion: %d\n", dwVersion));
    DBGMSG(DBG_TRACE, ("\tpDriverFile: %ws\n", pDriverFile));
    DBGMSG(DBG_TRACE, ("\tpConfigFile: %ws\n", pConfigFile));
    DBGMSG(DBG_TRACE, ("\tpDataFile: %ws\n", pDataFile));
    if (!pDriverFile || !pConfigFile || !pDataFile) {
        return((DWORD)-1);
    }

    UpgradeGetEnvironmentDriverDirectory(pDir,pEnvironmentDirectory);

    wsprintf(szDriverBuffer, L"%ws\\%d\\%ws",pDir, dwVersion, pDriverFile);

    DBGMSG( DBG_TRACE,("Driver File is %ws\n", szDriverBuffer));

    if ( !FileExists( szDriverBuffer )) {
        return((DWORD)-1);
    }

    wsprintf(szTempBuffer, L"%ws\\%d\\%ws", pDir, dwVersion, pConfigFile);

    DBGMSG(DBG_TRACE,("Configuration File is %ws\n", szTempBuffer));

    if ( !FileExists( szTempBuffer )) {
        return((DWORD)-1);
    }

    wsprintf(szTempBuffer, L"%ws\\%d\\%ws", pDir, dwVersion, pDataFile);

    DBGMSG(DBG_TRACE,("Data File is %ws\n", szTempBuffer));

    if ( !FileExists( szTempBuffer )) {
        return((DWORD)-1);
    }

    //
    // Fixed with right version
    //

    return (GetDriverMajorVersion(szDriverBuffer));
}

BOOL
UpgradeWriteDriverIni(
    PINIDRIVER pIniDriver,
    DWORD  dwVersion,
    LPWSTR pszEnvironmentName,
    PINISPOOLER pIniSpooler
)
{
    HKEY    hEnvironmentsRootKey, hEnvironmentKey, hDriversKey, hDriverKey;
    HKEY hVersionKey;
    WCHAR szVersionName[MAX_PATH];
    DWORD dwMinorVersion = 0;
    WCHAR szVersionDirectory[MAX_PATH];


    memset(szVersionDirectory, 0, sizeof(WCHAR)*MAX_PATH);
    wsprintf(szVersionDirectory,L"%d", dwVersion);
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, pIniSpooler->pszRegistryEnvironments, 0,
                       NULL, 0, KEY_WRITE, NULL, &hEnvironmentsRootKey, NULL)
                                == ERROR_SUCCESS) {
        DBGMSG(DBG_TRACE,("Created key %ws\n", pIniSpooler->pszRegistryEnvironments));

        if (RegCreateKeyEx(hEnvironmentsRootKey, pszEnvironmentName, 0,
                         NULL, 0, KEY_WRITE, NULL, &hEnvironmentKey, NULL)
                                == ERROR_SUCCESS) {

            DBGMSG(DBG_TRACE, ("Created key %ws\n", pszEnvironmentName));

            if (RegCreateKeyEx(hEnvironmentKey, szDriversKey, 0,
                             NULL, 0, KEY_WRITE, NULL, &hDriversKey, NULL)
                                    == ERROR_SUCCESS) {
                DBGMSG(DBG_TRACE, ("Created key %ws\n", szDriversKey));
                wsprintf(szVersionName,L"Version-%d",dwVersion);
                DBGMSG(DBG_TRACE, ("Trying to create version key %ws\n", szVersionName));
                if (RegCreateKeyEx(hDriversKey, szVersionName, 0, NULL,
                                    0, KEY_WRITE, NULL, &hVersionKey, NULL)
                                            == ERROR_SUCCESS) {

                    DBGMSG(DBG_TRACE, ("Created key %ws\n", szVersionName));

                    RegSetValueEx(hVersionKey, szDirectory, 0, REG_SZ,
                                  (LPBYTE)szVersionDirectory,
                                  wcslen(szVersionDirectory)*sizeof(WCHAR) +
                                  sizeof(WCHAR));

                    RegSetValueEx(hVersionKey, szMajorVersion, 0, REG_DWORD,
                                  (LPBYTE)&dwVersion,
                                  sizeof(DWORD));
                    RegSetValueEx(hVersionKey, szMinorVersion, 0, REG_DWORD,
                                  (LPBYTE)&dwMinorVersion,
                                  sizeof(DWORD));

                    if (RegCreateKeyEx(hVersionKey, pIniDriver->pName, 0, NULL,
                                       0, KEY_WRITE, NULL, &hDriverKey, NULL)
                                            == ERROR_SUCCESS) {
                        DBGMSG(DBG_TRACE,("Created key %ws\n", pIniDriver->pName));

                        RegSetValueEx(hDriverKey, szConfigurationKey, 0, REG_SZ,
                                      (LPBYTE)pIniDriver->pConfigFile,
                                      wcslen(pIniDriver->pConfigFile)*sizeof(WCHAR) +
                                      sizeof(WCHAR));

                        RegSetValueEx(hDriverKey, szDataFileKey, 0, REG_SZ,
                                      (LPBYTE)pIniDriver->pDataFile,
                                      wcslen(pIniDriver->pDataFile)*sizeof(WCHAR) +
                                      sizeof(WCHAR));
                        RegSetValueEx(hDriverKey, szDriverFile, 0, REG_SZ,
                                      (LPBYTE)pIniDriver->pDriverFile,
                                      wcslen(pIniDriver->pDriverFile)*sizeof(WCHAR) +
                                      sizeof(WCHAR));
                        RegSetValueEx(hDriverKey, szDriverVersion, 0, REG_DWORD,
                                      (LPBYTE)&dwVersion,
                                      sizeof(pIniDriver->cVersion));

                        RegCloseKey(hDriverKey);
                    }
                    RegCloseKey(hVersionKey);
                }
                RegCloseKey(hDriversKey);
            }

            RegCloseKey(hEnvironmentKey);
        }

        RegCloseKey(hEnvironmentsRootKey);
    }
    return TRUE;
}

VOID
QueryUpgradeFlag(
    PINISPOOLER pIniSpooler
)
/*++

    Description: the query update flag is set up by TedM. We will read this flag
    if the flag has been set, we will set a boolean variable saying that we're in
    the upgrade mode. All upgrade activities will be carried out based on this flag.
    For subsequents startups of the spooler, this flag will be unvailable so we
    won't run the spooler in upgrade mode.

--*/
{
    DWORD dwRet;
    DWORD cbData;
    DWORD dwType = 0;
    HKEY hKey;

    dwUpgradeFlag  = 0;

    dwRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, pIniSpooler->pszRegistryRoot, 0, KEY_ALL_ACCESS, &hKey);

    if (dwRet != ERROR_SUCCESS) {

        DBGMSG(DBG_TRACE, ("The Spooler Upgrade flag is %d\n", dwUpgradeFlag));
        return;
    }


    cbData = sizeof(DWORD);

    dwRet = RegQueryValueEx(hKey, L"Upgrade", NULL, &dwType, (LPBYTE)&dwUpgradeFlag, &cbData);

    if (dwRet != ERROR_SUCCESS) {
        dwUpgradeFlag = 0;
    }


    dwRet = RegDeleteValue(hKey, L"Upgrade");

    if (dwRet != ERROR_SUCCESS) {

        DBGMSG(DBG_TRACE, ("QueryUpgradeFlag: failed to delete the Upgrade Value\n"));
    }

    RegCloseKey(hKey);

    DBGMSG(DBG_TRACE, ("The Spooler Upgrade flag is %d\n", dwUpgradeFlag));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\util.c ===
/*++


Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module provides all the utility functions for the Routing Layer and
    the local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Felix Maxa (amaxa) 18-Jun-2000
    Added utility functions for cluster spoolers. Part of the DCR regarding
    installation of printer drivers on cluster spoolers

    Muhunthan Sivapragasam ( MuhuntS ) 5-June-1995
        Moved from printer.c:
            RegSetBinaryData
            RegSetString
            RegSetDWord

        Wrote:
            SameMultiSz
            RegGetValue

    Matthew A Felton ( MattFe ) 23-mar-1995
        DeleteAllFilesAndDirectory
        DeleteAllFilesInDirectory
        CreateDirectoryWithoutImpersonatingUser


--*/

#include <precomp.h>
#pragma hdrstop

#include <winddiui.h>
#include <lm.h>
#include <aclapi.h>
#include <winsta.h>
#include "clusspl.h"


typedef LONG (WINAPI *pfnWinStationSendWindowMessage)(
        HANDLE  hServer,
        ULONG   sessionID,
        ULONG   timeOut,
        ULONG   hWnd,
        ULONG   Msg,
        WPARAM  wParam,
        LPARAM  lParam,
        LONG    *pResponse);

extern  BOOL (*pfnOpenPrinter)(LPTSTR, LPHANDLE, LPPRINTER_DEFAULTS);
extern  BOOL (*pfnClosePrinter)(HANDLE);
extern  LONG (*pfnDocumentProperties)(HWND, HANDLE, LPWSTR, PDEVMODE, PDEVMODE, DWORD);

#define DEFAULT_MAX_TIMEOUT      300000 // 5 minute timeout.

CRITICAL_SECTION SpoolerSection;
PDBG_POINTERS gpDbgPointers = NULL;
pfnWinStationSendWindowMessage pfWinStationSendWindowMessage = NULL;

VOID
RunForEachSpooler(
    HANDLE h,
    PFNSPOOLER_MAP pfnMap
    )
{
    PINISPOOLER pIniSpooler;
    PINISPOOLER pIniNextSpooler;

    SplInSem();

    if( pLocalIniSpooler ){

        INCSPOOLERREF( pLocalIniSpooler );

        for( pIniSpooler = pLocalIniSpooler; pIniSpooler; pIniSpooler = pIniNextSpooler ){

            if( (*pfnMap)( h, pIniSpooler ) ){
                pIniNextSpooler = pIniSpooler->pIniNextSpooler;
            } else {
                pIniNextSpooler = NULL;
            }

            if( pIniNextSpooler ){

                INCSPOOLERREF( pIniNextSpooler );
            }
            DECSPOOLERREF( pIniSpooler );
        }
    }
}

VOID
RunForEachPrinter(
    PINISPOOLER pIniSpooler,
    HANDLE h,
    PFNPRINTER_MAP pfnMap
    )
{
    PINIPRINTER pIniPrinter;
    PINIPRINTER pIniNextPrinter;

    SplInSem();

    pIniPrinter = pIniSpooler->pIniPrinter;

    if( pIniPrinter ){

        INCPRINTERREF( pIniPrinter );

        for( ; pIniPrinter; pIniPrinter = pIniNextPrinter ){

            if( (*pfnMap)( h, pIniPrinter ) ){
                pIniNextPrinter = pIniPrinter->pNext;
            } else {
                pIniNextPrinter = NULL;
            }

            if( pIniNextPrinter ){

                INCPRINTERREF( pIniNextPrinter );
            }

            DECPRINTERREF( pIniPrinter );
            DeletePrinterCheck( pIniPrinter );
        }
    }
}

#if DBG
HANDLE hcsSpoolerSection = NULL;

VOID
SplInSem(
    VOID
    )
{
    if( hcsSpoolerSection ){

        SPLASSERT( gpDbgPointers->pfnInsideCritSec( hcsSpoolerSection ));

    } else {

        SPLASSERT( SpoolerSection.OwningThread == (HANDLE)(ULONG_PTR)(GetCurrentThreadId( )));
    }
}

VOID
SplOutSem(
    VOID
    )
{
    if( hcsSpoolerSection ){

        SPLASSERT( gpDbgPointers->pfnOutsideCritSec( hcsSpoolerSection ));

    } else {

        SPLASSERT( SpoolerSection.OwningThread != (HANDLE)((ULONG_PTR)GetCurrentThreadId( )));
    }
}

#endif // DBG

VOID
EnterSplSem(
    VOID
    )
{
#if DBG
    if( hcsSpoolerSection ){

        gpDbgPointers->pfnEnterCritSec( hcsSpoolerSection );

    } else {

        EnterCriticalSection( &SpoolerSection );
    }
#else
    EnterCriticalSection( &SpoolerSection );
#endif
}

VOID
LeaveSplSem(
    VOID
    )
{
#if DBG
    if( hcsSpoolerSection ){

        gpDbgPointers->pfnLeaveCritSec( hcsSpoolerSection );

    } else {

        LeaveCriticalSection( &SpoolerSection );
    }
#else
    LeaveCriticalSection( &SpoolerSection );

#endif
}

PDEVMODE
AllocDevMode(
    PDEVMODE pDevMode
    )
{
    PDEVMODE pDevModeAlloc = NULL;
    DWORD    Size;

    if (pDevMode) {

        Size = pDevMode->dmSize + pDevMode->dmDriverExtra;

        if(pDevModeAlloc = AllocSplMem(Size)) {

            memcpy(pDevModeAlloc, pDevMode, Size);
        }
    }

    return pDevModeAlloc;
}

BOOL
FreeDevMode(
    PDEVMODE pDevMode
    )
{
    if (pDevMode) {

        FreeSplMem((PVOID)pDevMode);
        return TRUE;

    } else {
        return  FALSE;
    }
}

PINIENTRY
FindName(
   PINIENTRY pIniKey,
   LPWSTR pName
)
{
   if (pName) {
      while (pIniKey) {

         if (!lstrcmpi(pIniKey->pName, pName)) {
            return pIniKey;
         }

      pIniKey=pIniKey->pNext;
      }
   }

   return FALSE;
}


BOOL
FileExists(
    LPWSTR pFileName
    )
{
    if( GetFileAttributes( pFileName ) == 0xffffffff ){
        return FALSE;
    }
    return TRUE;
}



BOOL
DirectoryExists(
    LPWSTR  pDirectoryName
    )
{
    DWORD   dwFileAttributes;

    dwFileAttributes = GetFileAttributes( pDirectoryName );

    if ( dwFileAttributes != 0xffffffff &&
         dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

        return TRUE;
    }

    return FALSE;
}



BOOL
CheckSepFile(
   IN LPWSTR pFileName
   )
{
    BOOL bRetval = FALSE;

    //
    // NULL or "" is OK:
    //
    if (!pFileName || !*pFileName)
    {
        bRetval = TRUE;
    }
    else
    {
        //
        // If the name is not NULL or "" then the name must be less
        // than MAX_PATH and exist.
        //
        if ((wcslen(pFileName) < MAX_PATH-1) && FileExists(pFileName))
        {
            bRetval = TRUE;
        }
    }

    return bRetval;
}


DWORD
GetFullNameFromId(
   PINIPRINTER pIniPrinter,
   DWORD JobId,
   BOOL fJob,
   LPWSTR pFileName,
   BOOL Remote
   )
{
   DWORD i;

   //
   // MAX_PATH - 9 is tha maximum number of chars that we want to store in pFileName since we
   // want to concatenate the SPL/SHD file
   // If GetPrinterDirectory fails i is 0.
   // The right way to fix this is that the caller of GetFullNameFromId chackes for the return value
   // which is not the case.
   //
   i = GetPrinterDirectory(pIniPrinter, Remote, pFileName, MAX_PATH-9, pIniPrinter->pIniSpooler);

   pFileName[i++]=L'\\';

   wsprintf(&pFileName[i], L"%05d.%ws", JobId, fJob ? L"SPL" : L"SHD");

#ifdef PREVIOUS
   for (i = 5; i--;) {
      pFileName[i++] = (CHAR)((JobId % 10) + '0');
      JobId /= 10;
   }
#endif

   while (pFileName[i++])
      ;

   return i-1;
}

DWORD
GetPrinterDirectory(
   PINIPRINTER pIniPrinter,         // Can be NULL
   BOOL Remote,
   LPWSTR pDir,
   DWORD MaxLength,
   PINISPOOLER pIniSpooler
)
{
   DWORD i=0;
   LPWSTR psz;

   if (Remote) {

       DBGMSG(DBG_ERROR, ("GetPrinterDirectory called remotely.  Not currently supported."));
       return 0;

   }

   if ((pIniPrinter == NULL) || (pIniPrinter->pSpoolDir == NULL) ) {

        if (pIniSpooler->pDefaultSpoolDir == NULL) {

            //
            // No default directory, then create a default. For cluster spoolers,
            // the default directory is N:\Spool, where N is the shared drive letter
            //
            if( StrNCatBuff(pDir,
                            MaxLength,
                            pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ? pIniSpooler->pszClusResDriveLetter :
                                                                           pIniSpooler->pDir,
                            L"\\",
                            pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ? szClusterPrinterDir : szPrinterDir,
                            NULL) != ERROR_SUCCESS ) {
                return 0;
            }

            pIniSpooler->pDefaultSpoolDir = AllocSplStr(pDir);

        } else {

            // Give Caller the Default

            wcscpy(pDir, pIniSpooler->pDefaultSpoolDir);

        }

   } else {

       // Have Per Printer Directory

       wcscpy (pDir, pIniPrinter->pSpoolDir);

   }
   return (wcslen(pDir));
}



DWORD
GetDriverDirectory(
    LPWSTR   pDir,
    DWORD    MaxLength,
    PINIENVIRONMENT  pIniEnvironment,
    LPWSTR   lpRemotePath,
    PINISPOOLER pIniSpooler
)
{
   LPWSTR psz;

   if (lpRemotePath) {

       if( StrNCatBuff(pDir,
                        MaxLength,
                        lpRemotePath,
                        L"\\",
                        pIniSpooler->pszDriversShare,
                        L"\\",
                        pIniEnvironment->pDirectory,
                        NULL) != ERROR_SUCCESS ) {
            return 0;
        }


   } else {

       if( StrNCatBuff( pDir,
                        MaxLength,
                        pIniSpooler->pDir,
                        L"\\",
                        szDriverDir,
                        L"\\",
                        pIniEnvironment->pDirectory,
                        NULL) != ERROR_SUCCESS ) {
            return 0;
        }
   }

   return wcslen(pDir);
}



DWORD
GetProcessorDirectory(
    LPWSTR   *pDir,
    LPWSTR   pEnvironment,
    PINISPOOLER pIniSpooler
)
{
    return StrCatAlloc(pDir,
                       pIniSpooler->pDir,
                       L"\\",
                       szPrintProcDir,
                       L"\\",
                       pEnvironment,
                       NULL);
}



PINIENTRY
FindIniKey(
   PINIENTRY pIniEntry,
   LPWSTR pName
)
{
   if ( pName == NULL ) {
      return NULL;
   }

   SplInSem();

   while ( pIniEntry && lstrcmpi( pName, pIniEntry->pName ))
      pIniEntry = pIniEntry->pNext;

   return pIniEntry;
}


BOOL
CreateCompleteDirectory(
    LPWSTR pDir
)
{
    LPWSTR pBackSlash=pDir;

    do {
        pBackSlash = wcschr( pBackSlash, L'\\' );

        if ( pBackSlash != NULL )
            *pBackSlash = 0;

        CreateDirectory(pDir, NULL);

        if ( pBackSlash )
            *pBackSlash++=L'\\';

   } while ( pBackSlash );

    // BUBUG Always returns TRUE

   return TRUE;
}




LPCWSTR
FindFileName(
    LPCWSTR pPathName
    )

/*++

Routine Description:

    Retrieve the filename portion of a path.

    This will can the input string until it finds the last backslash,
    then return the portion of the string immediately following it.
    If the string terminates with a backslash, then NULL is returned.

    Note: this can return illegal file names; no validation is done.

Arguments:

    pPathName - Path name to parse.

Return Value:

    Last portion of file name or NULL if none available.

--*/

{
    LPCWSTR pSlash;
    LPCWSTR pTemp;

    if( !pPathName ){
       return NULL;
    }

    pTemp = pPathName;
    while( pSlash = wcschr( pTemp, L'\\' )) {
        pTemp = pSlash+1;
    }

    if( !*pTemp ){
       return NULL;
    }

    return pTemp;
}

LPWSTR
GetFileName(
    LPWSTR pPathName
)
{
   LPCWSTR pFileName;

   pFileName = FindFileName( pPathName );

   if (pFileName) {

       return( AllocSplStr( pFileName ) );

   } else {

       return(NULL);
   }
}



VOID
CreatePrintProcDirectory(
   LPWSTR pEnvironment,
   PINISPOOLER pIniSpooler
)
{
    DWORD cb;
    LPWSTR pEnd;
    LPWSTR pPathName;

    cb = wcslen(pIniSpooler->pDir)*sizeof(WCHAR) +
         wcslen(pEnvironment)*sizeof(WCHAR) +
         wcslen(szPrintProcDir)*sizeof(WCHAR) +
         4*sizeof(WCHAR);

    if (pPathName=AllocSplMem(cb)) {

        wcscpy(pPathName, pIniSpooler->pDir);

        pEnd=pPathName+wcslen(pPathName);

        if( CreateDirectory(pPathName, NULL) ||
            ( GetLastError() == ERROR_ALREADY_EXISTS )) {

            wcscpy(pEnd++, L"\\");

            wcscpy(pEnd, szPrintProcDir);

            if( CreateDirectory(pPathName, NULL) ||
                ( GetLastError() == ERROR_ALREADY_EXISTS )) {

                pEnd+=wcslen(pEnd);

                wcscpy(pEnd++, L"\\");

                wcscpy(pEnd, pEnvironment);

                if (CreateDirectory(pPathName, NULL) ||
                    (GetLastError() == ERROR_ALREADY_EXISTS)) {

                    pEnd+=wcslen(pEnd);
                }
            }
        }

        FreeSplMem(pPathName);
    }
}

BOOL
RemoveFromList(
   PINIENTRY   *ppIniHead,
   PINIENTRY   pIniEntry
)
{
   while (*ppIniHead && *ppIniHead != pIniEntry) {
      ppIniHead = &(*ppIniHead)->pNext;
   }

   if (*ppIniHead)
      *ppIniHead = (*ppIniHead)->pNext;

   return(TRUE);
}

PKEYDATA
CreateTokenList(
    LPWSTR   pKeyData
)
{
    DWORD       cTokens;
    DWORD       cb;
    PKEYDATA    pResult;
    LPWSTR       pDest;
    LPWSTR       psz = pKeyData;
    LPWSTR      *ppToken;

    if (!psz || !*psz)
        return NULL;

    cTokens=1;

    // Scan through the string looking for commas,
    // ensuring that each is followed by a non-NULL character:

    while ((psz = wcschr(psz, L',')) && psz[1]) {

        cTokens++;
        psz++;
    }

    cb = sizeof(KEYDATA) + (cTokens-1) * sizeof(LPWSTR) +
         wcslen(pKeyData)*sizeof(WCHAR) + sizeof(WCHAR);

    if (!(pResult = (PKEYDATA)AllocSplMem(cb)))
        return NULL;

    // Initialise pDest to point beyond the token pointers:

    pDest = (LPWSTR)((LPBYTE)pResult + sizeof(KEYDATA) +
                                      (cTokens-1) * sizeof(LPWSTR));

    // Then copy the key data buffer there:

    wcscpy(pDest, pKeyData);

    ppToken = pResult->pTokens;

    psz = pDest;

    do {

        *ppToken++ = psz;

        if ( psz = wcschr(psz, L',') )
            *psz++ = L'\0';

    } while (psz);

    pResult->cTokens = cTokens;

    return( pResult );
}

VOID
FreePortTokenList(
    PKEYDATA    pKeyData
    )
{
    PINIPORT    pIniPort;
    DWORD       i;

    if ( pKeyData ) {

        if ( pKeyData->bFixPortRef ) {

            for ( i = 0 ; i < pKeyData->cTokens ; ++i ) {

                pIniPort = (PINIPORT)pKeyData->pTokens[i];
                DECPORTREF(pIniPort);
            }
        }
        FreeSplMem(pKeyData);
    }
}

VOID
GetPrinterPorts(
    PINIPRINTER pIniPrinter,
    LPWSTR      pszPorts,
    DWORD       *pcbNeeded
)
{
    PINIPORT    pIniPort;
    BOOL        Comma;
    DWORD       i;
    DWORD       cbNeeded = 0;

    SPLASSERT(pcbNeeded);

    // Determine required size
    Comma = FALSE;
    for ( i = 0 ; i < pIniPrinter->cPorts ; ++i ) {

        pIniPort = pIniPrinter->ppIniPorts[i];

        if ( pIniPort->Status & PP_FILE )
            continue;

        if ( Comma )
            cbNeeded += wcslen(szComma)*sizeof(WCHAR);

        cbNeeded += wcslen(pIniPort->pName)*sizeof(WCHAR);
        Comma = TRUE;
    }

    //
    // Add in size of NULL
    //
    cbNeeded += sizeof(WCHAR);        


    if (pszPorts && cbNeeded <= *pcbNeeded) {

        //
        // If we are given a buffer & buffer is big enough, then fill it
        //
        Comma = FALSE;
        for ( i = 0 ; i < pIniPrinter->cPorts ; ++i ) {

            pIniPort = pIniPrinter->ppIniPorts[i];

            if ( pIniPort->Status & PP_FILE )
                continue;

            if ( Comma ) {

                wcscat(pszPorts, szComma);
                wcscat(pszPorts, pIniPort->pName);
            } else {

                wcscpy(pszPorts, pIniPort->pName);
            }

            Comma = TRUE;
        }
    }

    *pcbNeeded = cbNeeded;
}

BOOL
MyName(
    LPWSTR   pName,
    PINISPOOLER pIniSpooler
)
{
    EnterSplSem();

    if (CheckMyName(pName, pIniSpooler))
    {
        LeaveSplSem();
        return TRUE;
    }

    //
    // Only refresh machine names if pName is an IP or DNS address
    //
    if (pIniSpooler == pLocalIniSpooler &&
        wcschr(pName, L'.') &&
        RefreshMachineNamesCache() &&
        CheckMyName(pName, pIniSpooler))
    {
        LeaveSplSem();
        return TRUE;
    }

    SetLastError(ERROR_INVALID_NAME);

    LeaveSplSem();
    return FALSE;
}


BOOL
RefreshMachineNamesCache(
)
{
    PWSTR   *ppszOtherNames;
    DWORD   cOtherNames;

    SplInSem();

    //
    // Get other machine names first.  Only if it succeeds do we replace the cache.
    //
    if (!BuildOtherNamesFromMachineName(&ppszOtherNames, &cOtherNames))
        return FALSE;

    FreeOtherNames(&pLocalIniSpooler->ppszOtherNames, &pLocalIniSpooler->cOtherNames);
    pLocalIniSpooler->ppszOtherNames = ppszOtherNames;
    pLocalIniSpooler->cOtherNames = cOtherNames;

    return TRUE;
}


BOOL
CheckMyName(
    LPWSTR   pName,
    PINISPOOLER pIniSpooler
)
{
    DWORD   dwIndex = 0;

    if (!pName || !*pName)
        return TRUE;

    if (*pName == L'\\' && *(pName+1) == L'\\') {

        if (!lstrcmpi(pName, pIniSpooler->pMachineName))
            return TRUE;

        while (dwIndex < pIniSpooler->cOtherNames) {
            if (!lstrcmpi(pName+2, pIniSpooler->ppszOtherNames[dwIndex]))
                return TRUE;
            ++dwIndex;
        }
    }
    return FALSE;
}


BOOL
GetSid(
    PHANDLE phToken
)
{
    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_IMPERSONATE | TOKEN_QUERY,
                         TRUE,
                         phToken)) {

        DBGMSG(DBG_WARNING, ("OpenThreadToken failed: %d\n", GetLastError()));
        return FALSE;

    } else

        return TRUE;
}

BOOL
SetCurrentSid(
    HANDLE  hToken
)
{
#if DBG
    WCHAR UserName[256];
    DWORD cbUserName=256;

    if( MODULE_DEBUG & DBG_TRACE )
        GetUserName(UserName, &cbUserName);

    DBGMSG(DBG_TRACE, ("SetCurrentSid BEFORE: user name is %ws\n", UserName));
#endif

    //
    // Normally the function SetCurrentSid is not supposed to change the last error
    // of the routine where it is called. NtSetInformationThread conveniently returns
    // a status and does not touch the last error.
    //
    NtSetInformationThread(NtCurrentThread(), ThreadImpersonationToken,
                           &hToken, sizeof(hToken));

#if DBG
    cbUserName = 256;

    if( MODULE_DEBUG & DBG_TRACE )
        GetUserName(UserName, &cbUserName);

    DBGMSG(DBG_TRACE, ("SetCurrentSid AFTER: user name is %ws\n", UserName));
#endif

    return TRUE;
}

LPWSTR
GetErrorString(
    DWORD   Error
)
{
    WCHAR   Buffer1[512];
    LPWSTR  pErrorString=NULL;
    DWORD   dwFlags;
    HANDLE  hModule = NULL;

    if ((Error >= NERR_BASE) && (Error <= MAX_NERR)) {
        dwFlags = FORMAT_MESSAGE_FROM_HMODULE;
        hModule = LoadLibrary(szNetMsgDll);

    } else {
        dwFlags = FORMAT_MESSAGE_FROM_SYSTEM;
        hModule = NULL;
    }

    //
    // Only display out of paper and device disconnected errors.
    //
    if ((Error == ERROR_NOT_READY ||
         Error == ERROR_OUT_OF_PAPER ||
         Error == ERROR_DEVICE_REINITIALIZATION_NEEDED ||
         Error == ERROR_DEVICE_REQUIRES_CLEANING ||
         Error == ERROR_DEVICE_DOOR_OPEN ||
         Error == ERROR_DEVICE_NOT_CONNECTED) &&

        FormatMessage(dwFlags,
                      hModule,
                      Error,
                      0,
                      Buffer1,
                      COUNTOF(Buffer1),
                      NULL)) {

       EnterSplSem();
        pErrorString = AllocSplStr(Buffer1);
       LeaveSplSem();
    }

    if (hModule) {
        FreeLibrary(hModule);
    }

    return pErrorString;
}

#define NULL_TERMINATED 0



INT
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    )
/*++

Routine Description:

    Converts an Ansi String to a UnicodeString

Arguments:

    pAnsi - A valid source ANSI string.

    pUnicode - A pointer to a buffer large enough to accommodate
               the converted string.

    StringLength - The length of the source ANSI string.
                   If 0 (NULL_TERMINATED), the string is assumed to be
                   null-terminated.


Return Value:

    The return value from MultiByteToWideChar, the number of
    wide characters returned.


  andrewbe, 11 Jan 1993
--*/
{
    if( StringLength == NULL_TERMINATED )
        StringLength = strlen( pAnsi );

    return MultiByteToWideChar( CP_ACP,
                                MB_PRECOMPOSED,
                                pAnsi,
                                StringLength + 1,
                                pUnicode,
                                StringLength + 1 );
}





INT
Message(
    HWND hwnd,
    DWORD Type,
    int CaptionID,
    int TextID, ...)
{
/*++

Routine Description:

    Displays a message by loading the strings whose IDs are passed into
    the function, and substituting the supplied variable argument list
    using the varargs macros.

Arguments:

    hwnd        Window Handle
    Type
    CaptionID
    TextId


Return Value:

--*/

    WCHAR   MsgText[512];
    WCHAR   MsgFormat[256];
    WCHAR   MsgCaption[40];
    va_list vargs;

    if( ( LoadString( hInst, TextID, MsgFormat,
                      sizeof MsgFormat / sizeof *MsgFormat ) > 0 )
     && ( LoadString( hInst, CaptionID, MsgCaption,
                      sizeof MsgCaption / sizeof *MsgCaption ) > 0 ) )
    {
        va_start( vargs, TextID );
        _vsntprintf( MsgText, COUNTOF(MsgText)-1, MsgFormat, vargs );
        MsgText[COUNTOF(MsgText)-1] = 0;
        va_end( vargs );

        return MessageBox(hwnd, MsgText, MsgCaption, Type);
    }
    else
        return 0;
}

typedef struct {
    DWORD   Message;
    WPARAM  wParam;
    LPARAM  lParam;
} MESSAGE, *PMESSAGE;

//  The Broadcasts are done on a separate thread, the reason it CSRSS
//  will create a server side thread when we call user and we don't want
//  that to be paired up with the RPC thread which is in the spooss server.
//  We want it to go away the moment we have completed the SendMessage.
//  We also call SendNotifyMessage since we don't care if the broadcasts
//  are syncronous this uses less resources since usually we don't have more
//  than one broadcast.

//
// TESTING
//
DWORD dwSendFormMessage = 0;

VOID
SplBroadcastChange(
    HANDLE  hPrinter,
    DWORD   Message,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    PINISPOOLER pIniSpooler;

    if (ValidateSpoolHandle( pSpool, 0 )) {

        pIniSpooler = pSpool->pIniSpooler;
        BroadcastChange(pIniSpooler, Message, wParam, lParam);
    }
}


VOID
BroadcastChange(
    IN PINISPOOLER  pIniSpooler,
    IN DWORD        Message,
    IN WPARAM       wParam,
    IN LPARAM       lParam
    )
{
    if (( pIniSpooler != NULL ) && ( pIniSpooler->SpoolerFlags & SPL_BROADCAST_CHANGE )) {

        BOOL bIsTerminalServerInstalled = (USER_SHARED_DATA->SuiteMask & (1 << TerminalServer));

        //
        // Currently we cannot determine if the TermService process is running, so at the momemt
        // we assume it is always running.
        //
        BOOL bIsTerminalServerRunning = TRUE;

        //
        // If terminal server is installed and enabled then load the winsta.dll if not already
        // loaded and get the send window message function.
        //
        if ( bIsTerminalServerInstalled && !pfWinStationSendWindowMessage ) {

            //
            // The winstadllhandle is shared among other files in the spooler, so don't
            // load the dll again if it is already loaded.  Note: we are not in a critical
            // section because winsta.dll is never unload, hence if there are two threads
            // that execute this code at the same time we may potenially load the library
            // twice.
            //
            if ( !WinStaDllHandle ) {

                UINT uOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

                WinStaDllHandle = LoadLibraryW(L"winsta.dll");

                SetErrorMode(uOldErrorMode);
            }

            if ( WinStaDllHandle ) {

                pfWinStationSendWindowMessage = (pfnWinStationSendWindowMessage)GetProcAddress( WinStaDllHandle,
                                                                                                "WinStationSendWindowMessage" );
            }
        }

        if ( pfWinStationSendWindowMessage ) {

            //
            // Only send the message to the session that orginated
            // the call, this will go to the console session when a
            // change is made by a remote client.
            //
            LONG Response = 0;
            LONG lRetval  = FALSE;
            HANDLE hToken = NULL;

            ULONG uSession = GetClientSessionId();

            //
            // It appears the WinStationSendWindowMessage function has to
            // be in system context if the impersonating user is not an
            // an admin on the machine.
            //
            hToken = RevertToPrinterSelf();

            lRetval = pfWinStationSendWindowMessage( SERVERNAME_CURRENT,
                                                     uSession,
                                                     1,                    // Wait at most one second
                                                     HandleToULong(HWND_BROADCAST),
                                                     Message,
                                                     wParam,
                                                     lParam,
                                                     &Response );

            ImpersonatePrinterClient(hToken);
        }

        //
        // We send the message normally if we have a null pfWinstationSendWindowMessage
        // function or if terminal server is not running.
        //
        if ( !pfWinStationSendWindowMessage || !bIsTerminalServerRunning ){

            SendNotifyMessage( HWND_BROADCAST,
                               Message,
                               wParam,
                               lParam );

        }

    } else {

        DBGMSG(DBG_TRACE, ("BroadCastChange Ignoring Change\n"));
    }
}


VOID
MyMessageBeep(
    DWORD   fuType,
    PINISPOOLER pIniSpooler
    )
{
    if ( pIniSpooler->dwBeepEnabled != 0 ) {
        MessageBeep(fuType);
    }
}


// Recursively delete any subkeys of a given key.
// Assumes that RevertToPrinterSelf() has been called.

DWORD
DeleteSubkeys(
    HKEY hKey,
    PINISPOOLER pIniSpooler
    )
{
    DWORD   cchData;
    WCHAR   SubkeyName[MAX_PATH];
    HKEY    hSubkey;
    LONG    Status;

    cchData = COUNTOF( SubkeyName );

    while ((Status = SplRegEnumKey( hKey,
                                    0,
                                    SubkeyName,
                                    &cchData,
                                    NULL,
                                    pIniSpooler )) == ERROR_SUCCESS ) {

        Status = SplRegCreateKey( hKey,
                                  SubkeyName,
                                  0,
                                  KEY_READ | KEY_WRITE,
                                  NULL,
                                  &hSubkey,
                                  NULL,
                                  pIniSpooler );

        if( Status == ERROR_SUCCESS ) {

            Status = DeleteSubkeys( hSubkey, pIniSpooler );

            SplRegCloseKey( hSubkey, pIniSpooler);

            if( Status == ERROR_SUCCESS )
                SplRegDeleteKey( hKey, SubkeyName, pIniSpooler );
        }

        //
        // N.B. Don't increment since we've deleted the zeroth item.
        //
        cchData = COUNTOF( SubkeyName );
    }

    if( Status == ERROR_NO_MORE_ITEMS )
        Status = ERROR_SUCCESS;

    return Status;
}




long Myatol(LPWSTR nptr)
{
    int c;                                  // current char
    long total;                             // current total
    int sign;                               // if '-', then negative, otherwise positive

    // skip whitespace

    while (isspace(*nptr))
        ++nptr;

    c = *nptr++;
    sign = c;                               // save sign indication
    if (c == '-' || c == '+')
        c = *nptr++;                        // skip sign

    total = 0;

    while (isdigit(c)) {
        total = 10 * total + (c - '0');     // accumulate digit
        c = *nptr++;                        // get next char
    }

    if (sign == '-')
        return -total;
    else
        return total;                       // return result, negated if necessary
}


ULONG_PTR
atox(
   LPCWSTR psz
   )

/*++

Routine Description:

    Converts a string to a hex value, skipping any leading
    white space.  Cannot be uppercase, cannot contain leading 0x.

Arguments:

    psz - pointer to hex string that needs to be converted.  This string
        can have leading characters, but MUST be lowercase.

Return Value:

    DWORD value.

--*/

{
    ULONG_PTR Value = 0;
    ULONG_PTR Add;

    _wcslwr((LPWSTR)psz);

    while( isspace( *psz )){
        ++psz;
    }

    for( ;; ++psz ){

        if( *psz >= TEXT( '0' ) && *psz <= TEXT( '9' )){
            Add = *psz - TEXT( '0' );
        } else if( *psz >= TEXT( 'a' ) && *psz <= TEXT( 'f' )){
            Add = *psz - TEXT( 'a' ) + 0xa;
        } else {
            break;
        }

        Value *= 0x10;
        Value += Add;
    }

    return Value;
}


BOOL
ValidateSpoolHandle(
    PSPOOL pSpool,
    DWORD  dwDisallowMask
    )
{
    BOOL    ReturnValue;
    try {

        //
        // Zombied handles should return back error.  The client
        // side will see ERROR_INVALID_HANDLE, close it and revalidate.
        //
        if (( pSpool == NULL ) ||
            ( pSpool == INVALID_HANDLE_VALUE ) ||
            ( pSpool->Status & SPOOL_STATUS_ZOMBIE ) ||
            ( pSpool->signature != SJ_SIGNATURE ) ||
            ( pSpool->TypeofHandle & dwDisallowMask ) ||
            ( pSpool->TypeofHandle & PRINTER_HANDLE_XCV_PORT ) ||
            ( pSpool->pIniSpooler->signature != ISP_SIGNATURE ) ||

            ( ( pSpool->TypeofHandle & PRINTER_HANDLE_PRINTER ) &&
              ( pSpool->pIniPrinter->signature !=IP_SIGNATURE ) )) {

                ReturnValue = FALSE;

        } else {

                ReturnValue = TRUE;

        }


    }except (1) {

        ReturnValue = FALSE;

    }

    if ( !ReturnValue )
        SetLastError( ERROR_INVALID_HANDLE );

    return ReturnValue;

}


BOOL
UpdateString(
    LPWSTR* ppszCur,
    LPWSTR pszNew)
{
    //
    // !! LATER !!
    //
    // Replace with non-nls wcscmp since we want byte comparison and
    // only care if the strings are different (ignore ordering).
    //
    if ((!*ppszCur || !**ppszCur) && (!pszNew || !*pszNew))
        return FALSE;

    if (!*ppszCur || !pszNew || wcscmp(*ppszCur, pszNew)) {

        ReallocSplStr(ppszCur, pszNew);
        return TRUE;
    }
    return FALSE;
}




BOOL
CreateDirectoryWithoutImpersonatingUser(
    LPWSTR pDirectory
    )
/*++

Routine Description:

    This routine stops impersonating the user and creates a directory

Arguments:

    pDirectory - Fully Qualified path of directory.


Return Value:

    TRUE    - Success
    FALSE   - failed ( call GetLastError )

--*/
{
    HANDLE  hToken      = INVALID_HANDLE_VALUE;
    BOOL    bReturnValue;

    SPLASSERT( pDirectory != NULL );

    hToken = RevertToPrinterSelf();

    bReturnValue = CreateDirectory( pDirectory, NULL );

    if ( bReturnValue == FALSE ) {

        DBGMSG( DBG_WARNING, ("CreateDirectoryWithoutImpersonatingUser failed CreateDirectory %ws error %d\n", pDirectory, GetLastError() ));
    }

    if ( hToken != INVALID_HANDLE_VALUE ) {
        ImpersonatePrinterClient(hToken);
    }

    return bReturnValue;
}




BOOL
DeleteAllFilesInDirectory(
    LPWSTR pDirectory,
    BOOL   bWaitForReboot
)
/*++

Routine Description:

    Deletes all files the specified directory
    If it can't be deleted it gets marked for deletion on next reboot.


Arguments:

    pDirectory  - Fully Qualified path of directory.
    bWaitForReboot - Don't delete the files until a reboot


Return Value:

    TRUE    - Success
    FALSE   - failed something major, like allocating memory.

--*/

{
    BOOL    bReturnValue = FALSE;
    HANDLE  hFindFile;
    WIN32_FIND_DATA     FindData;
    WCHAR   ScratchBuffer[ MAX_PATH ];


    DBGMSG( DBG_TRACE, ("DeleteAllFilesInDirectory: bWaitForReboot = %\n", bWaitForReboot ));

    SPLASSERT( pDirectory != NULL );

    if (StrNCatBuff(ScratchBuffer, COUNTOF(ScratchBuffer), pDirectory, L"\\*", NULL) != ERROR_SUCCESS)
        return FALSE;

    hFindFile = FindFirstFile( ScratchBuffer, &FindData );

    if ( hFindFile != INVALID_HANDLE_VALUE ) {

        do {

            //
            //  Don't Attempt to Delete Directories
            //

            if ( !( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) ) {

                //
                //  Fully Qualified Path
                //

                if (StrNCatBuff(   ScratchBuffer,
                                    COUNTOF(ScratchBuffer),
                                    pDirectory,
                                    L"\\",
                                    FindData.cFileName,
                                    NULL) == ERROR_SUCCESS) {

                    if ( bWaitForReboot || !DeleteFile( ScratchBuffer ) ) {

                        DBGMSG( DBG_WARNING, ("DeleteAllFilesInDirectory failed DeleteFile( %ws ) error %d\n", ScratchBuffer, GetLastError() ));

                        if ( !MoveFileEx( ScratchBuffer, NULL, MOVEFILE_DELAY_UNTIL_REBOOT ) ) {

                            DBGMSG( DBG_WARNING, ("DeleteAllFilesInDirectory failed MoveFileEx %ws error %d\n", ScratchBuffer, GetLastError() ));

                        } else {

                            DBGMSG( DBG_TRACE, ("MoveFileEx %ws Delay until reboot OK\n", ScratchBuffer ));
                        }


                    } else {

                        DBGMSG( DBG_TRACE, ("Deleted %ws OK\n", ScratchBuffer ));
                    }
                }
            }


        } while( FindNextFile( hFindFile, &FindData ) );

        bReturnValue = FindClose( hFindFile );


    } else {

        DBGMSG( DBG_WARNING, ("DeleteOldDrivers failed findfirst ( %ws ), error %d\n", ScratchBuffer, GetLastError() ));
    }

    return  bReturnValue;

}

BOOL
DeleteAllFilesAndDirectory(
    LPWSTR pDirectory,
    BOOL   bWaitForReboot
)
/*++

Routine Description:

    Deletes all files the specified directory, then deletes the directory.
    If the Directory cannot be deleted right away, it is set to be deleted
    at reboot time.

    Security NOTE - This routine runs as SYSTEM, not imperonating the user


Arguments:

    pDirectory  - Fully Qualified path of directory.


Return Value:

    TRUE    - Success
    FALSE   - failed something major, like allocating memory.

--*/
{
    BOOL    bReturnValue;
    HANDLE  hToken      = INVALID_HANDLE_VALUE;

    DBGMSG( DBG_TRACE, ("DeleteAllFilesAndDirectory: bWaitForReboot = %d\n", bWaitForReboot ));

    hToken = RevertToPrinterSelf();


    if( bReturnValue = DeleteAllFilesInDirectory( pDirectory, bWaitForReboot ) ) {


        if ( bWaitForReboot || !RemoveDirectory( pDirectory )) {

            if (!SplMoveFileEx( pDirectory, NULL, MOVEFILE_DELAY_UNTIL_REBOOT )) {

                DBGMSG( DBG_WARNING, ("DeleteAllFilesAndDirectory failed to delete %ws until reboot %d\n", pDirectory, GetLastError() ));
            } else {

                DBGMSG( DBG_TRACE, ( "DeleteAllFilesAndDirectory: MoveFileEx Delay until reboot OK\n" ));
            }

        } else {

            DBGMSG( DBG_TRACE, ("DeleteAllFilesAndDirectory deleted %ws OK\n", pDirectory ));
        }
    }


    if ( hToken != INVALID_HANDLE_VALUE ) {
        ImpersonatePrinterClient(hToken);
    }

    return  bReturnValue;
}


VOID
DeleteDirectoryRecursively(
    LPCWSTR pszDirectory,
    BOOL    bWaitForReboot
)
/*++

Routine Name:

  DeleteDirectoryRecursively

Routine Description:

    Recursively Deletes the specified directory
    If it can't be deleted it gets marked for deletion on next reboot.

Arguments:

    pDirectory  - Fully Qualified path of directory.
    bWaitForReboot - Don't delete the files until a reboot

Return Value:

    Nothing.

--*/
{
    HANDLE  hFindFile;
    WIN32_FIND_DATA     FindData;
    WCHAR   ScratchBuffer[ MAX_PATH ];

    if ( pszDirectory &&
         StrNCatBuff(ScratchBuffer,
                     COUNTOF(ScratchBuffer),
                     pszDirectory,
                     L"\\*",
                     NULL) == ERROR_SUCCESS ) {

        hFindFile = FindFirstFile(ScratchBuffer, &FindData);

        if ( hFindFile != INVALID_HANDLE_VALUE ) {

            do {
                //
                // Don't delete current and parent directory.
                //
                if (wcscmp(FindData.cFileName, L".")  != 0 &&
                    wcscmp(FindData.cFileName, L"..") != 0 &&
                    StrNCatBuff( ScratchBuffer,
                                 COUNTOF(ScratchBuffer),
                                 pszDirectory,
                                 L"\\",
                                 FindData.cFileName,
                                 NULL) == ERROR_SUCCESS) {

                    if (!(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

                        if (bWaitForReboot || !DeleteFile(ScratchBuffer)) {

                            //
                            // Delete the file on reboot if asked or if deletion failed.
                            //
                            SplMoveFileEx(ScratchBuffer, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
                        }

                    } else {

                        //
                        // Delete subdirectory
                        //
                        DeleteAllFilesAndDirectory(ScratchBuffer, bWaitForReboot);
                    }
                }

            } while (FindNextFile(hFindFile, &FindData));

            FindClose(hFindFile);

            if (bWaitForReboot || !RemoveDirectory(pszDirectory)) {

                //
                // Delete the directory on reboot if asked or if deletion failed.
                //
                SplMoveFileEx(pszDirectory, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
            }
        }
    }

    return;
}

DWORD
CreateNumberedTempDirectory(
    IN  LPCWSTR  pszDirectory,
    OUT LPWSTR  *ppszTempDirectory
    )
/*++

Routine Name:

    CreateNumberedTempDirectory

Routine Description:

    Creates a temporary subdirectory named 1... 500
    The lenght of ppTempDirectory cannot be bigger than MAX_PATH
    Returns the number of directory created or -1 for failure

Arguments:

    pszDirectory - directory where to created temporary
    ppszTempDirectory - path of the new temporary directory

Return Value:

    If success, returns the number of directory created.
    Returns -1 if a failure occurs.
--*/
{
    DWORD   dwIndex, dwTempDir;
    WCHAR   szTempDir[4];
    WCHAR  *pszTemporary = NULL;

    dwTempDir = -1;

    if (pszDirectory && ppszTempDirectory)
    {
        *ppszTempDirectory = NULL;

        if (pszTemporary = AllocSplMem((wcslen(pszDirectory) + COUNTOF(szTempDir) + 1) * sizeof(WCHAR)))
        {
            for (dwIndex = 1; dwIndex < 500; ++dwIndex)
            {
                _itow(dwIndex, szTempDir, 10);

                if (StrNCatBuff(pszTemporary,
                                MAX_PATH,
                                pszDirectory,
                                L"\\",
                                szTempDir,
                                NULL) == ERROR_SUCCESS &&
                    !DirectoryExists(pszTemporary) &&
                    CreateDirectory(pszTemporary, NULL))
                {
                    dwTempDir = dwIndex;
                    break;
                }
            }
        }
    }

    if (dwTempDir != -1)
    {
        *ppszTempDirectory = pszTemporary;
    }
    else
    {
        SetLastError(ERROR_NO_SYSTEM_RESOURCES);
        FreeSplMem(pszTemporary);
    }

    return dwTempDir;
}


//
// Dependent file fields are LPWSTR field of filenames separated by \0
// and terminated by \0\0
// 2 such fields are same if same set of filenames appear
// (order of filenames does not matter)
//
BOOL
SameMultiSz(
    LPWSTR pszz1,
    LPWSTR pszz2
    )
{
    LPWSTR psz1, psz2;

    if ( !pszz1 && !pszz2 )
        return TRUE;

    if ( !pszz1 || !pszz2 )
        return FALSE;

    //
    // Check there are same number of strings
    //
    for ( psz1 = pszz1, psz2 = pszz2 ;
          *psz1 && *psz2 ;
          psz1 += wcslen(psz1)+1, psz2 += wcslen(psz2)+1 )
    ;

    //
    // If different number of strings return FALSE
    //
    if ( *psz1 || *psz2 )
       return FALSE;

    //
    // Check in pszz2 for each string in pszz1
    //
    for ( psz1 = pszz1 ; *psz1 ; psz1 += wcslen(psz1) + 1 ) {

        for ( psz2 = pszz2 ;
              *psz2 && _wcsicmp(psz1, psz2) ;
              psz2 += wcslen(psz2) + 1 )
        ;

        //
        // Did we find psz1 in pszz2
        //
        if ( ! *psz2 ) {
            return FALSE;
        }
    }

    return TRUE;
}


int
wstrcmpEx(
    LPCWSTR s1,
    LPCWSTR s2,
    BOOL    bCaseSensitive
    )
{
    if ( s1 && *s1 ) {
        if ( s2 && *s2 ) {
            return bCaseSensitive ? wcscmp(s1, s2) : _wcsicmp(s1, s2);
        }
        else {
            return 1;
        }
    }
    else {
        if ( s2 && *s2 ) {
            return -1;
        }
        else {
            return 0;
        }
    }
}


BOOL
RegSetString(
    HANDLE  hKey,
    LPWSTR  pValueName,
    LPWSTR  pStringValue,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    )
{
    BOOL    bReturnValue;
    LPWSTR  pString;
    DWORD   cbString;
    DWORD   Status;

    if ( pStringValue ) {

        pString = pStringValue;
        cbString = ( wcslen( pStringValue ) + 1 )*sizeof(WCHAR);

    } else {

        pString = szNull;
        cbString = sizeof(WCHAR);
    }

    Status =  SplRegSetValue( hKey,
                              pValueName,
                              REG_SZ,
                              (LPBYTE)pString,
                              cbString,
                              pIniSpooler );

    if ( Status != ERROR_SUCCESS ) {

        DBGMSG( DBG_WARNING, ("RegSetString value %ws string %ws error %d\n", pValueName, pString, Status ));

        *pdwLastError = Status;
        bReturnValue = FALSE;

    } else {

        bReturnValue = TRUE;

    }

    return bReturnValue;

}

BOOL
RegSetDWord(
    HANDLE  hKey,
    LPWSTR  pValueName,
    DWORD   dwParam,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    )
{
    BOOL    bReturnValue;
    LPWSTR  pString;
    DWORD   Status;

    Status = SplRegSetValue( hKey,
                             pValueName,
                             REG_DWORD,
                             (LPBYTE)&dwParam,
                             sizeof(DWORD),
                             pIniSpooler );

    if ( Status != ERROR_SUCCESS ) {

        DBGMSG( DBG_WARNING, ("RegSetDWord value %ws DWORD %x error %d\n",
                               pValueName, dwParam, Status ));


        *pdwLastError = Status;
        bReturnValue = FALSE;

    } else {

        bReturnValue = TRUE;
    }

    return bReturnValue;

}

BOOL
RegSetBinaryData(
    HKEY    hKey,
    LPWSTR  pValueName,
    LPBYTE  pData,
    DWORD   cbData,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    )
{
    DWORD   Status;
    BOOL    bReturnValue;


    Status = SplRegSetValue( hKey,
                             pValueName,
                             REG_BINARY,
                             pData,
                             cbData,
                             pIniSpooler );

    if ( Status != ERROR_SUCCESS ) {

        DBGMSG( DBG_WARNING, ("RegSetBinaryData Value %ws pData %x cbData %d error %d\n",
                               pValueName,
                               pData,
                               cbData,
                               Status ));

        bReturnValue = FALSE;
        *pdwLastError = Status;

    } else {

        bReturnValue = TRUE;
    }

    return bReturnValue;
}

BOOL
RegSetMultiString(
    HANDLE  hKey,
    LPWSTR  pValueName,
    LPWSTR  pStringValue,
    DWORD   cchString,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    )
{
    BOOL    bReturnValue;
    DWORD   Status;
    LPWSTR  pString;
    WCHAR   szzNull[2];

    if ( pStringValue ) {
        pString    = pStringValue;
        cchString *= sizeof(WCHAR);
    } else {
        szzNull[0] = szzNull[1] = '\0';
        pString   = szNull;
        cchString = 2 * sizeof(WCHAR);
    }

    Status = SplRegSetValue( hKey,
                             pValueName,
                             REG_MULTI_SZ,
                             (LPBYTE)pString,
                             cchString,
                             pIniSpooler );

    if ( Status != ERROR_SUCCESS ) {

        DBGMSG( DBG_WARNING, ("RegSetMultiString value %ws string %ws error %d\n", pValueName, pString, Status ));

        *pdwLastError = Status;
        bReturnValue = FALSE;

    } else {

        bReturnValue = TRUE;

    }

    return bReturnValue;
}

BOOL
RegGetString(
    HANDLE    hKey,
    LPWSTR    pValueName,
    LPWSTR   *ppValue,
    LPDWORD   pcchValue,
    PDWORD    pdwLastError,
    BOOL      bFailIfNotFound,
    PINISPOOLER pIniSpooler
    )
/*++

Routine Description:
    Allocates memory and reads a value from Registry for a value which was
    earlier set by calling RegSetValueEx.


Arguments:
    hKey            : currently open key to be used to query the registry
    pValueName      : value to be used to query the registry
    ppValue         : on return value of TRUE *ppValue (memory allocated by
                      the routine) will have the value
    pdwLastError    : on failure *dwLastError will give the error
    bFailIfNotFound : Tells if the field is mandatory (if not found error)

Return Value:
    TRUE : value is found and succesfully read.
           Memory will be allocated to hold the value
    FALSE: Value was not read.
           If bFailIfNotFound was TRUE error code will be set.

History:
    Written by MuhuntS (Muhunthan Sivapragasam)June 95

--*/
{
    BOOL    bReturnValue = TRUE;
    LPWSTR  pString;
    DWORD   cbValue;
    DWORD   Status, Type;

    //
    // First query to find out size
    //
    cbValue = 0;
    Status =  SplRegQueryValue( hKey,
                                pValueName,
                                &Type,
                                NULL,
                                &cbValue,
                                pIniSpooler );

    if ( Status != ERROR_SUCCESS ) {

        // Set error code only if it is a required field
        if ( bFailIfNotFound )
            *pdwLastError = Status;

        bReturnValue = FALSE;

    } else if ( (Type == REG_SZ && cbValue > sizeof(WCHAR) ) ||
                (Type == REG_MULTI_SZ && cbValue > 2*sizeof(WCHAR)) ) {

        //
        // Something (besides \0 or \0\0) to read
        //

        if ( !(*ppValue=AllocSplMem(cbValue) ) ) {

            *pdwLastError = GetLastError();
            bReturnValue  = FALSE;
        } else {

            Status = SplRegQueryValue( hKey,
                                       pValueName,
                                       &Type,
                                       (LPBYTE)*ppValue,
                                       &cbValue,
                                       pIniSpooler );

            if ( Status != ERROR_SUCCESS ) {

                DBGMSG( DBG_WARNING, ("RegGetString value %ws string %ws error %d\n", pValueName, **ppValue, Status ));
                *pdwLastError = Status;
                bReturnValue  = FALSE;

            } else {

                *pcchValue = cbValue / sizeof(WCHAR);
                bReturnValue = TRUE;
            }

        }
    }

    return bReturnValue;
}

BOOL
RegGetMultiSzString(
    HANDLE    hKey,
    LPWSTR    pValueName,
    LPWSTR   *ppValue,
    LPDWORD   pcchValue,
    PDWORD    pdwLastError,
    BOOL      bFailIfNotFound,
    PINISPOOLER pIniSpooler
    )
/*++

Routine Description:
    Duplicate function for RegGetString. Handles multi-sz strings so that Spooler
    doesn't crash.

Arguments:
    hKey            : currently open key to be used to query the registry
    pValueName      : value to be used to query the registry
    ppValue         : on return value of TRUE *ppValue (memory allocated by
                      the routine) will have the value
    pdwLastError    : on failure *dwLastError will give the error
    bFailIfNotFound : Tells if the field is mandatory (if not found error)

Return Value:
    TRUE : value is found and succesfully read.
           Memory will be allocated to hold the value
    FALSE: Value was not read.
           If bFailIfNotFound was TRUE error code will be set.

History:
    Written by AdinaTru. This function is a fix for the case when 3rd party applications 
    install drivers by writing registry string values instead of multi-sz. This causes Spooler
    to AV because it will handle a string as a multi-sz string. The goal of having this function 
    was to provide a quick fix/low regression risk for XP RC2 release. A bug was opened for rewriting 
    RegGetMultiSzString and RegGetString in BlackComb timeframe.

--*/
{
    BOOL    bReturnValue = TRUE;
    LPWSTR  pString;
    DWORD   cbValue;
    DWORD   Status, Type;

    //
    // First query to find out size
    //
    cbValue = 0;
    Status =  SplRegQueryValue( hKey,
                                pValueName,
                                &Type,
                                NULL,
                                &cbValue,
                                pIniSpooler );

    if ( Status != ERROR_SUCCESS ) {

        // Set error code only if it is a required field
        if ( bFailIfNotFound )
            *pdwLastError = Status;

        bReturnValue = FALSE;

    } else if ( (Type == REG_SZ && cbValue > sizeof(WCHAR) ) ||
                (Type == REG_MULTI_SZ && cbValue > 2*sizeof(WCHAR)) ) {

        //
        // Something (besides \0 or \0\0) to read
        //

        //
        // We expect a REG_MULTI_SZ string. Add an extra zero so Spooler doesn't crash.
        // XP RC2 fix.
        //
        if (Type == REG_SZ) {
            cbValue += sizeof(WCHAR);
        }

        if ( !(*ppValue=AllocSplMem(cbValue) ) ) {

            *pdwLastError = GetLastError();
            bReturnValue  = FALSE;
        } else {

            Status = SplRegQueryValue( hKey,
                                       pValueName,
                                       &Type,
                                       (LPBYTE)*ppValue,
                                       &cbValue,
                                       pIniSpooler );

            if ( Status != ERROR_SUCCESS ) {

                DBGMSG( DBG_WARNING, ("RegGetString value %ws string %ws error %d\n", pValueName, **ppValue, Status ));
                *pdwLastError = Status;
                bReturnValue  = FALSE;
                //
                // Caller will must the memory regardless of success or failure. 
                //
            } else {

                *pcchValue = cbValue / sizeof(WCHAR);
                bReturnValue = TRUE;
            }

        }
    }

    return bReturnValue;
}

VOID
FreeStructurePointers(
    LPBYTE  lpStruct,
    LPBYTE  lpStruct2,
    LPDWORD lpOffsets)
/*++

Routine Description:
    This routine frees memory allocated to all the pointers in the structure
    If lpStruct2 is specified only pointers in lpStruct which are different
    than the ones in lpStruct will be freed

Arguments:
    lpStruct:   Pointer to the structure
    lpStruct2:  Pointer to the structure to compare with (optional)
    lpOffsets:  An array of DWORDS (terminated by -1) givings offsets in the
                structure which have memory which needs to be freed

Return Value:
    nothing

History:
    MuhuntS -- Aug 95

--*/
{
    register INT i;

    if ( lpStruct2 ) {

        for( i=0; lpOffsets[i] != 0xFFFFFFFF; ++i ) {

            if ( *(LPBYTE *) (lpStruct+lpOffsets[i]) &&
                 *(LPBYTE *) (lpStruct+lpOffsets[i]) !=
                        *(LPBYTE *) (lpStruct2+lpOffsets[i]) )

                FreeSplMem(*(LPBYTE *) (lpStruct+lpOffsets[i]));
        }
    } else {

        for( i=0; lpOffsets[i] != 0xFFFFFFFF; ++i ) {

            if ( *(LPBYTE *) (lpStruct+lpOffsets[i]) )
                FreeSplMem(*(LPBYTE *) (lpStruct+lpOffsets[i]));
        }
    }
}

/*++

Routine Name:

    AllocOrUpdateStringAndTestSame

Routine Description:

    This routine can be used to do an atomic update of values in a structure.
    Create a temporary structure and copy the old structure to it.
    Then call this routine for all LPWSTR fields to check and update strings

    If the value 