BOOL fOverwrite)
{
	TRACE0("MetaUtil: CMetaUtil::CopyKey\n");
	ASSERT_NULL_OR_POINTER(bstrSrcKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(bstrDestKey, OLECHAR);

	if ((bstrSrcKey == NULL) || (bstrDestKey == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszSrcKey[ADMINDATA_MAX_NAME_LEN];
	TCHAR tszDestKey[ADMINDATA_MAX_NAME_LEN];

	_tcscpy(tszSrcKey, OLE2T(bstrSrcKey));
	CannonizeKey(tszSrcKey);

	_tcscpy(tszDestKey, OLE2T(bstrDestKey));
	CannonizeKey(tszDestKey);

	return ::CopyKey(m_pIMeta, tszSrcKey, tszDestKey, fOverwrite, TRUE);
}

/*===================================================================
CMetaUtil::MoveKey

Move a key

Parameters:
    bstrSrcKey		[in] Source Key Name
	bstrDestKey		[in] Destination key name
	fOverwrite		[in] If true then already existing properties
					at destination are overwritten.

Returns:
	E_INVALIDARG if bstrSrcKey == NULL OR bstrDestKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::MoveKey(BSTR bstrSrcKey, BSTR bstrDestKey, BOOL fOverwrite)
{
	TRACE0("MetaUtil: CMetaUtil::MoveKey\n");
	ASSERT_NULL_OR_POINTER(bstrSrcKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(bstrDestKey, OLECHAR);

	if ((bstrSrcKey == NULL) || (bstrDestKey == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszSrcKey[ADMINDATA_MAX_NAME_LEN];
	TCHAR tszDestKey[ADMINDATA_MAX_NAME_LEN];

	_tcscpy(tszSrcKey, OLE2T(bstrSrcKey));
	CannonizeKey(tszSrcKey);

	_tcscpy(tszDestKey, OLE2T(bstrDestKey));
	CannonizeKey(tszDestKey);

	return ::CopyKey(m_pIMeta, tszSrcKey, tszDestKey, fOverwrite, FALSE);
}

/*===================================================================
CMetaUtil::GetProperty

Gets a property object from the metabase.

Parameters:
    bstrKey		[in] Key containing property to get
	varId		[in] Identifier of property to get.  Either the 
				Id (number) or Name (string).
	ppIReturn	[out, retval] Interface for retreived property.
	
Returns:
	E_INVALIDARG if bstrKey == NULL or ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::GetProperty(BSTR bstrKey, 
									VARIANT varId, 
									IProperty **ppIReturn)
{
	TRACE0("MetaUtil: CMetaUtil::GetProperty\n");

	ASSERT_NULL_OR_POINTER(bstrKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(ppIReturn, IProperty *);

	if ((bstrKey == NULL) || (ppIReturn == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszKey[ADMINDATA_MAX_NAME_LEN];

	_tcscpy(tszKey,OLE2T(bstrKey));
	CannonizeKey(tszKey);

	return ::GetProperty(m_pIMeta, m_pCSchemaTable, tszKey, varId, ppIReturn);
}

/*===================================================================
CMetaUtil::CreateProperty

Creates a property object that can be written to the Metbase or
retreives the property if it already exists.

Parameters:
    bstrKey		[in] Key containing property to get
	varId		[in] Identifier of property to get.  Either the 
				Id (number) or Name (string).
	ppIReturn	[out, retval] Interface for retreived property.
	
Returns:
	E_INVALIDARG if bstrKey == NULL or ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::CreateProperty(BSTR bstrKey, 
									   VARIANT varId, 
									   IProperty **ppIReturn)
{
	TRACE0("MetaUtil: CMetaUtil::CreateProperty\n");

	ASSERT_NULL_OR_POINTER(bstrKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(ppIReturn, IProperty *);

	if ((bstrKey == NULL) || (ppIReturn == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszKey[ADMINDATA_MAX_NAME_LEN];

	_tcscpy(tszKey,OLE2T(bstrKey));
	CannonizeKey(tszKey);

	return ::CreateProperty(m_pIMeta, m_pCSchemaTable, tszKey, varId, ppIReturn);
}

/*===================================================================
CMetaUtil::DeleteProperty

Deletes a property from the metabase.

Parameters:
    bstrKey		[in] Key containing property to get
	varId		[in] Identifier of property to get.  Either the 
				Id (number) or Name (string).
	
Returns:
	E_INVALIDARG if bstrKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::DeleteProperty(BSTR bstrKey, VARIANT varId)
{
	TRACE0("MetaUtil: CMetaUtil::DeleteProperty\n");

	ASSERT_NULL_OR_POINTER(bstrKey, OLECHAR);

	if (bstrKey == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszKey[ADMINDATA_MAX_NAME_LEN];

	_tcscpy(tszKey,OLE2T(bstrKey));
	CannonizeKey(tszKey);

	return ::DeleteProperty(m_pIMeta, m_pCSchemaTable, tszKey, varId);
}

/*===================================================================
CMetaUtil::ExpandString

Expands a string with environment variables.  Maximum output is 1024
bytes.

Parameters:
    bstrIn		[in] String to expand
	pbstrRet	[out, retval] Expanded string
	
Returns:
	E_INVALIDARG if bstrIn == NULL or pbstrRet == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::ExpandString(BSTR bstrIn, BSTR *pbstrRet)
{
	ASSERT_POINTER(bstrIn, OLECHAR);
	ASSERT_NULL_OR_POINTER(pbstrRet, BSTR);

	if ((bstrIn == NULL) || (pbstrRet == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszRet[1024];
	int iRet;

	iRet = ExpandEnvironmentStrings(OLE2T(bstrIn), tszRet, 1024);
	if (iRet == 0) {
		::ReportError(GetLastError());
	}

	*pbstrRet = T2BSTR(tszRet);

	return S_OK;
}

/*===================================================================
MetaUtil::PropIdToName

Converts a property Id to its name, as listed in 
_Machine_/Schema/Properties/Names

Parameters:
    bstrKey		[in] Approximate key where property is located, 
				needed to determine what schema to use.
	lId			[in] Id of property
	pbstrName	[out, retval] Output name of property
	
Returns:
	E_INVALIDARG if bstrKey == NULL or pbstrName == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::PropIdToName(BSTR bstrKey, long lId, BSTR *pbstrName)
{
	ASSERT_NULL_OR_POINTER(bstrKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(pbstrName, BSTR);

	if ((bstrKey == NULL) || (pbstrName == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszKey[ADMINDATA_MAX_NAME_LEN];
	CPropInfo *pCPropInfo;

	// Convert the base key to cannonical form
	_tcscpy(tszKey, OLE2T(bstrKey));
	CannonizeKey(tszKey);

	// Get the property info from the Schema Table
	pCPropInfo = m_pCSchemaTable->GetPropInfo(tszKey, lId);

	// Did we find it?  Is there a name entry?
	if ((pCPropInfo == NULL) || (pCPropInfo->GetName() == NULL)) {
		// No, return ""
		*pbstrName = T2BSTR(_T(""));
	}
	else {
		// Yes, return the name
		*pbstrName = T2BSTR(pCPropInfo->GetName());
	}
	return S_OK;
}

/*===================================================================
MetaUtil::PropNameToId

Converts a property name to its id, as listed in 
_Machine_/Schema/Properties/Names

Parameters:
    bstrKey		[in] Approximate key where property is located, 
				needed to determine what schema to use.
	pbstrName	[in] Name of property
	lId			[out, retval] Output id of property
	
Returns:
	E_INVALIDARG if bstrKey == NULL OR bstrName == NULL OR plId == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::PropNameToId(BSTR bstrKey, BSTR bstrName, long *plId)
{
	ASSERT_NULL_OR_POINTER(bstrKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(bstrName, OLECHAR);
	ASSERT_NULL_OR_POINTER(plId, long);

	if ((bstrKey == NULL) || (bstrName == NULL) || (plId == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszKey[ADMINDATA_MAX_NAME_LEN];
	CPropInfo *pCPropInfo;

	// Convert the base key to cannonical form
	_tcscpy(tszKey, OLE2T(bstrKey));
	CannonizeKey(tszKey);

	// Get the property info from the Schema Table
	pCPropInfo = m_pCSchemaTable->GetPropInfo(tszKey, OLE2T(bstrName));

	// Did we find it?
	if (pCPropInfo == NULL) {
		// No, return 0
		*plId = 0;
	}
	else {
		// Yes, return the id
		*plId = pCPropInfo->GetId();
	}
	return S_OK;
}

/*===================================================================
MetaUtil::get_Config

Gets the value of a configuration setting.

Valid Settings:
	MaxPropertySize
	MaxKeySize
	MaxNumberOfErrors

Parameters:
    bstrSetting		[in] Name of the setting
	pvarValue		[out, retval] Value of the setting
	
Returns:
	E_INVALIDARG if bstrSettting doesn't match any known settings
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::get_Config(BSTR bstrSetting, VARIANT *pvarValue)
{
	ASSERT_POINTER(bstrSetting, OLECHAR);
	ASSERT_POINTER(pvarValue, VARIANT);

	USES_CONVERSION;
	LPTSTR tszSetting;

    if( !bstrSetting )
    {
        return ::ReportError(E_INVALIDARG);
    }

	VariantInit(pvarValue);
	tszSetting = OLE2T(bstrSetting);

	if (_tcsicmp(tszSetting, _T("MaxPropertySize")) == 0) {
		V_VT(pvarValue) = VT_I4;
		V_I4(pvarValue) = m_dwMaxPropSize;
	}
	else if (_tcsicmp(tszSetting, _T("MaxKeySize")) == 0) {
		V_VT(pvarValue) = VT_I4;
		V_I4(pvarValue) = m_dwMaxKeySize;
	}
	else if (_tcsicmp(tszSetting, _T("MaxNumberOfErrors")) == 0) {
		V_VT(pvarValue) = VT_I4;
		V_I4(pvarValue) = m_dwMaxNumErrors;
	}
	else {
		return ::ReportError(E_INVALIDARG);
	}

	return S_OK;
}

/*===================================================================
MetaUtil::put_Config

Sets the value of a configuration setting.

Valid Settings:
	MaxPropertySize
	MaxKeySize
	MaxNumberOfErrors

Parameters:
    bstrSetting		[in] Name of the setting
	varValue		[out, retval] New value of the setting
	
Returns:
	E_INVALIDARG if bstrSettting doesn't match any known settings or
		if varValue is of an unexpected subtype.
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::put_Config(BSTR bstrSetting, VARIANT varValue)
{
	ASSERT_POINTER(bstrSetting, OLECHAR);

	USES_CONVERSION;
	HRESULT hr;
	LPTSTR tszSetting;

	tszSetting = OLE2T(bstrSetting);

	// Cleanup any IDispatch or byref stuff
	CComVariant varValue2;

	hr = VariantResolveDispatch(&varValue, &varValue2);
	if (FAILED(hr)) {
        return hr;
	}

	if (_tcsicmp(tszSetting, _T("MaxPropertySize")) == 0) {
		// Set Maximum Property Size
		switch (V_VT(&varValue2)) {
		
		case VT_I1:  case VT_I2:  case VT_I4: case VT_I8:
		case VT_UI1: case VT_UI2: case VT_UI8:

		// Coerce all integral types to VT_UI4
		if (FAILED(hr = VariantChangeType(&varValue2, &varValue2, 0, VT_UI4))) {
			return ::ReportError(hr);
			}

		// fallthru to VT_UI4

		case VT_UI4:

			m_dwMaxPropSize = V_UI4(&varValue2);
			break;

		default:

			// Unexpected data type
			return ::ReportError(E_INVALIDARG);
		}
	}
	else if (_tcsicmp(tszSetting, _T("MaxKeySize")) == 0) {
		// Set Maximum Key Size
		switch (V_VT(&varValue2)) {
		
		case VT_I1:  case VT_I2:  case VT_I4: case VT_I8:
		case VT_UI1: case VT_UI2: case VT_UI8:

		// Coerce all integral types to VT_UI4
		if (FAILED(hr = VariantChangeType(&varValue2, &varValue2, 0, VT_UI4))) {
			return ::ReportError(hr);
			}

		// fallthru to VT_UI4

		case VT_UI4:

			m_dwMaxKeySize = V_UI4(&varValue2);
			break;

		default:

			// Unexpected data type
			return ::ReportError(E_INVALIDARG);
		}
	}
	else if (_tcsicmp(tszSetting, _T("MaxNumberOfErrors")) == 0) {
		// Set Maximum Number of Errors
		switch (V_VT(&varValue2)) {
		
		case VT_I1:  case VT_I2:  case VT_I4: case VT_I8:
		case VT_UI1: case VT_UI2: case VT_UI8:

		// Coerce all integral types to VT_UI4
		if (FAILED(hr = VariantChangeType(&varValue2, &varValue2, 0, VT_UI4))) {
			return ::ReportError(hr);
			}

		// fallthru to VT_UI4

		case VT_UI4:

			m_dwMaxNumErrors = V_UI4(&varValue2);
			break;

		default:

			// Unexpected data type
			return ::ReportError(E_INVALIDARG);
		}
	}
	else {
		return ::ReportError(E_INVALIDARG);
	}

	return S_OK;
}

/*------------------------------------------------------------------
 * Methods also supported by the collections
 *
 * Actual implementation here to avoid redundant code
 */

/*===================================================================
CreateKey

Create a new key

Parameters:
	pIMeta		[in] Smart pointer to metabase, passed by reference
	            to avoid the copy and unneeded AddRef/Release.
				Would have used const, however the '->' operator
				would not work.
    tszKey		[in] Key to create

Returns:
	E_INVALIDARG if bstrKey == NULL
	S_OK on success
===================================================================*/
HRESULT CreateKey(CComPtr<IMSAdminBase> &pIMeta, 
				  LPCTSTR tszKey) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_STRING(tszKey);

	USES_CONVERSION;
	HRESULT hr;

	TCHAR tszParent[ADMINDATA_MAX_NAME_LEN];
	TCHAR tszChild[ADMINDATA_MAX_NAME_LEN];

	::SplitKey(tszKey, tszParent, tszChild);

	// Open the parent key
	METADATA_HANDLE hMDParent;

	hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						 T2W(tszParent),
						 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
					     MUTIL_OPEN_KEY_TIMEOUT,
						 &hMDParent);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Create the child
	hr = pIMeta->AddKey(hMDParent, T2W(tszChild)); 
	if (FAILED(hr)) {
		pIMeta->CloseKey(hMDParent);
		return ::ReportError(hr);
	}

	// Close the parent key
	pIMeta->CloseKey(hMDParent);

	return S_OK;
}

/*===================================================================
DeleteKey

Delete a key

Parameters:
	pIMeta		[in] Smart pointer to metabase, passed by reference
	            to avoid the copy and unneeded AddRef/Release.
				Would have used const, however the '->' operator
				would not work.
    tszKey		[in] Key to delete

Returns:
	E_INVALIDARG if pbSuccess == NULL
	S_OK on success
===================================================================*/
HRESULT DeleteKey(CComPtr<IMSAdminBase> &pIMeta, 
				  LPCTSTR tszKey) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_STRING(tszKey);

	USES_CONVERSION;
	HRESULT hr;

	TCHAR tszParent[ADMINDATA_MAX_NAME_LEN];
	TCHAR tszChild[ADMINDATA_MAX_NAME_LEN];

	::SplitKey(tszKey, tszParent, tszChild);

	// Open the parent key
	METADATA_HANDLE hMDParent;

	hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						 T2W(tszParent),
						 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
					     MUTIL_OPEN_KEY_TIMEOUT,
						 &hMDParent);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Delete the child
	hr = pIMeta->DeleteKey(hMDParent, T2W(tszChild)); 
	if (FAILED(hr)) {
		pIMeta->CloseKey(hMDParent);
		return ::ReportError(hr);
	}

	// Close the parent key
	pIMeta->CloseKey(hMDParent);

	return S_OK;
}

/*===================================================================
CMetaUtil::CopyKey

Copy or move a key

Parameters:
    bstrSrcKey		[in] Source Key Name
	bstrDestKey		[in] Destination key name
	fOverwrite		[in] If true then already existing properties
					at destination are overwritten.
	fCopy			[in] If true than copy the key, else move it

Returns:
	S_OK on success
===================================================================*/
HRESULT CopyKey(CComPtr<IMSAdminBase> &pIMeta, 
				LPTSTR tszSrcKey, 
				LPTSTR tszDestKey, 
				BOOL fOverwrite, 
				BOOL fCopy) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_STRING(tszSrcKey);
	ASSERT_STRING(tszDestKey);

	USES_CONVERSION;
	HRESULT hr;


	// Check for overlap
	TCHAR tszParent[ADMINDATA_MAX_NAME_LEN];
	int i;

	i = 0;
	while ((tszSrcKey[i] != _T('\0')) && (tszDestKey[i] != _T('\0')) &&
		   (tszSrcKey[i] == tszDestKey[i])) {
		tszParent[i] = tszSrcKey[i];
		i++;
	}
    
    // Terminate tszParent
	tszParent[i] = _T('\0');

	if (i == 0) {
		// Nothing in common

		TCHAR tszSrcParent[ADMINDATA_MAX_NAME_LEN];
		TCHAR tszSrcChild[ADMINDATA_MAX_NAME_LEN];
		TCHAR tszDestParent[ADMINDATA_MAX_NAME_LEN];
		TCHAR tszDestChild[ADMINDATA_MAX_NAME_LEN];

		::SplitKey(tszSrcKey, tszSrcParent, tszSrcChild);
		::SplitKey(tszDestKey, tszDestParent, tszDestChild);

		// Open the parent source key
		METADATA_HANDLE hMDSrcParent;

		hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
							 T2W(tszSrcParent),
							 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
							 MUTIL_OPEN_KEY_TIMEOUT,
							 &hMDSrcParent);
		if (FAILED(hr)) {
			return ::ReportError(hr);
		}

		// Open the parent dest key
		METADATA_HANDLE hMDDestParent;

		hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
							 T2W(tszDestParent),
							 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
							 MUTIL_OPEN_KEY_TIMEOUT,
							 &hMDDestParent);
		if (FAILED(hr)) {
			return ::ReportError(hr);
		}


		// Copy the children
		hr = pIMeta->CopyKey(hMDSrcParent, T2W(tszSrcChild), 
							 hMDDestParent, T2W(tszDestChild), 
							 fOverwrite, fCopy);
		if (FAILED(hr)) {
			pIMeta->CloseKey(hMDSrcParent);
			pIMeta->CloseKey(hMDDestParent);
			return ::ReportError(hr);
		}

		// Close the parents
		pIMeta->CloseKey(hMDSrcParent);
		pIMeta->CloseKey(hMDDestParent);
	}
	else {
		// Something in common

		// Back up to the first slash
		while ((i > 0) && (tszParent[i] != _T('/'))) {
			i--;
		}

		// Cut it off at the slash
		tszParent[i] = _T('\0');

		int iParentKeyLen;
		iParentKeyLen = _tcslen(tszParent);

		LPTSTR tszSrcChild;
		LPTSTR tszDestChild;

		// Figure out the relative new and old names
		tszSrcChild = tszSrcKey + iParentKeyLen;
		if (*tszSrcChild == _T('/')) {
			tszSrcChild++;
		}

		tszDestChild = tszDestKey + iParentKeyLen;
		if (*tszDestChild == _T('/')) {
			tszDestChild++;
		}

		// Open the parent key
		METADATA_HANDLE hMDParent;

		hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
							 T2W(tszParent),
							 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
							 MUTIL_OPEN_KEY_TIMEOUT,
							 &hMDParent);
		if (FAILED(hr)) {
			return ::ReportError(hr);
		}


		// Copy the children
		hr = pIMeta->CopyKey(hMDParent, T2W(tszSrcChild), 
							 hMDParent, T2W(tszDestChild), 
							 fOverwrite, fCopy);
		if (FAILED(hr)) {
			pIMeta->CloseKey(hMDParent);
			return ::ReportError(hr);
		}

		// Close the parent
		pIMeta->CloseKey(hMDParent);
	}

	return S_OK;
}

/*===================================================================
GetProperty

Gets a property object from the metabase.

Parameters:
	pIMeta			[in] Smart pointer to metabase, passed by 
					reference to avoid the copy and unneeded 
					AddRef/Release.  Would have used const, however 
					the '->' operator would not work.
	pCSchemaTable	[in] Metabase schema table to use to look up 
					property names
    tszKey			[in] Key containing property to get
	varId			[in] Identifier of property to get.  Either the 
					Id (number) or Name (string).
	ppIReturn		[out, retval] Interface for retreived property.
	
Returns:
	S_OK on success
===================================================================*/
HRESULT GetProperty(CComPtr<IMSAdminBase> &pIMeta,
					CMetaSchemaTable *pCSchemaTable,
					LPCTSTR tszKey, 
					VARIANT varId, 
					IProperty **ppIReturn) 
{
	ASSERT(pIMeta != NULL);
	ASSERT_STRING(tszKey);
	ASSERT_POINTER(ppIReturn, IProperty *);

	HRESULT hr;
	DWORD dwId;

	// Figure out the property id
	hr = ::VarToMetaId(pCSchemaTable, tszKey, varId, &dwId);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Create the property object
	CComObject<CProperty> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CProperty>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(pIMeta, pCSchemaTable, tszKey, dwId, FALSE);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IProperty
	hr = pObj->QueryInterface(IID_IProperty, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;
}

/*===================================================================
CreateProperty

Creates a property object that can be written to the Metbase or
retreives the property if it already exists.

Parameters:
	pIMeta			[in] Smart pointer to metabase, passed by 
					reference to avoid the copy and unneeded 
					AddRef/Release.  Would have used const, however 
					the '->' operator would not work.
	pCSchemaTable	[in] Metabase schema table to use to look up 
					property names
    tszKey			[in] Key containing property to get
	varId			[in] Identifier of property to get.  Either the 
					Id (number) or Name (string).
	ppIReturn		[out, retval] Interface for retreived property.
	
Returns:
	S_OK on success
===================================================================*/
HRESULT CreateProperty(CComPtr<IMSAdminBase> &pIMeta,
					   CMetaSchemaTable *pCSchemaTable,
					   LPCTSTR tszKey, 
					   VARIANT varId, 
					   IProperty **ppIReturn) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_STRING(tszKey);
	ASSERT_POINTER(ppIReturn, IProperty *);

	HRESULT hr;
	DWORD dwId;

	// Figure out the property id
	hr = ::VarToMetaId(pCSchemaTable, tszKey, varId, &dwId);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Create the property object
	CComObject<CProperty> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CProperty>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(pIMeta, pCSchemaTable, tszKey, dwId, TRUE);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IProperty
	hr = pObj->QueryInterface(IID_IProperty, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;
}

/*===================================================================
DeleteProperty

Deletes a property from the metabase.

Parameters:
    pIMeta			[in] Smart pointer to metabase, passed by 
					reference to avoid the copy and unneeded 
					AddRef/Release.  Would have used const, however 
					the '->' operator would not work.
	pCSchemaTable	[in] Metabase schema table to use to look up 
					property names
    tszKey			[in] Key containing property to get
	varId			[in] Identifier of property to get.  Either the 
					Id (number) or Name (string).
	
Returns:
	S_OK on success
===================================================================*/
HRESULT DeleteProperty(CComPtr<IMSAdminBase> &pIMeta,
					   CMetaSchemaTable *pCSchemaTable,
					   LPTSTR tszKey, 
					   VARIANT varId) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_STRING(tszKey);

	USES_CONVERSION;
	HRESULT hr;
	DWORD dwId;

	hr = ::VarToMetaId(pCSchemaTable, tszKey, varId, &dwId);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Open the key
	METADATA_HANDLE hMDKey;

	hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						 T2W(tszKey),
						 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
					     MUTIL_OPEN_KEY_TIMEOUT,
						 &hMDKey);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Delete the property
	hr = pIMeta->DeleteData(hMDKey, NULL, dwId, ALL_METADATA); 
	if (FAILED(hr)) {
		pIMeta->CloseKey(hMDKey);
		return ::ReportError(hr);
	}

	// Close the key
	pIMeta->CloseKey(hMDKey);

	return S_OK;
}

/*===================================================================
VarToMetaId

Converts a variant to a metabase property id.  IDispatch is resolved,
strings are looked up in the schema property list and integers are
converted to a DWORD.

Parameters:
	pCSchemaTable	[in] Metabase schema table to use to look up 
					property names
    tszKey			[in] Key the property is under (needed to get the 
					right schema)
	varId			[in] Variant to resolve
	pdwId			[out] Metabase property Id that varId resolved to

Returns:
	E_INVALIDARG if varId subtype isn't an integer or string
	ERROR_FILE_NOT_FOUND if varId is a BSTR that doesn't match any
		property names.
	S_OK on success
===================================================================*/
HRESULT VarToMetaId(CMetaSchemaTable *pCSchemaTable,
					LPCTSTR tszKey, 
					VARIANT varId, 
					DWORD *pdwId) 
{
	ASSERT_STRING(tszKey);
	ASSERT_POINTER(pdwId, DWORD);

	USES_CONVERSION;
	HRESULT hr;
	CComVariant varId2;
	CPropInfo *pCPropInfo;

    // VBScript can call us with a VARIANT that isn't a simple type,
    // such as VT_VARIANT|VT_BYREF.  This resolves it to a simple type.
    if (FAILED(hr = VariantResolveDispatch(&varId, &varId2)))
        return hr;

    switch (V_VT(&varId2)) {

    case VT_BSTR:
        // Look up the property name
		pCPropInfo = pCSchemaTable->GetPropInfo(tszKey, OLE2T(V_BSTR(&varId2)));
		if (pCPropInfo == NULL) {
			return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		}
		*pdwId = pCPropInfo->GetId();

		return S_OK;
        break;
        
    case VT_I1:  case VT_I2:  case VT_I4: case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI8:
        // Coerce all integral types to VT_UI4, which is the same as REG_DWORD
        if (FAILED(hr = VariantChangeType(&varId2, &varId2, 0, VT_UI4)))
            return hr;

        // fallthru to VT_UI4

    case VT_UI4:
		*pdwId = V_UI4(&varId2);
        break;

    default:
        return E_INVALIDARG;   // Cannot handle this data type
    }

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\propcol.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: PropCol.cpp

Owner: t-BrianM

This file contains implementation of the property collection and
property object.
===================================================================*/

#include "stdafx.h"
#include "MetaUtil.h"
#include "MUtilObj.h"
#include "PropCol.h"


/*------------------------------------------------------------------
 * C P r o p e r t y C o l l e c t i o n
 */

/*===================================================================
CPropertyCollection::CPropertyCollection

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CPropertyCollection::CPropertyCollection() : m_pCSchemaTable(NULL),
											 m_tszKey(NULL)
{
}

/*===================================================================
CPropertyCollection::Init

Constructor

Parameters:
	pIMeta		ATL Smart pointer to the metabase
	tszKey		Name of key to enumerate properties of

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CPropertyCollection::Init(const CComPtr<IMSAdminBase> &pIMeta,
								  CMetaSchemaTable *pCSchemaTable, 
								  LPTSTR tszKey) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_NULL_OR_STRING(tszKey);

	USES_CONVERSION;
	HRESULT hr;

	m_pIMeta = pIMeta;
	m_pCSchemaTable = pCSchemaTable;
	m_pCSchemaTable->AddRef();

	// Copy tszKey to m_tszKey
	if (tszKey == NULL) {
		// Key is root
		m_tszKey = NULL;
	}
	else {
		// Allocate and copy the passed string to the member string
		m_tszKey = new TCHAR[_tcslen(tszKey) + 1];
		if (m_tszKey == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
		_tcscpy(m_tszKey, tszKey);
		CannonizeKey(m_tszKey);
		
		// Make sure the key exists by opening and closing it
		METADATA_HANDLE hMDKey;

		hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
							   T2W(m_tszKey),
							   METADATA_PERMISSION_READ,
							   MUTIL_OPEN_KEY_TIMEOUT,
							   &hMDKey);
		if (FAILED(hr)) {
			return ::ReportError(hr);
		}

		m_pIMeta->CloseKey(hMDKey);
	}

	return S_OK; 
}

/*===================================================================
CPropertyCollection::~CPropertyCollection

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CPropertyCollection::~CPropertyCollection() 
{
	m_pCSchemaTable->Release();

	if (m_tszKey != NULL) {
		delete m_tszKey;
	}
}

/*===================================================================
CPropertyCollection::InterfaceSupportsErrorInfo

Standard ATL implementation

===================================================================*/
STDMETHODIMP CPropertyCollection::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IPropertyCollection,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*===================================================================
CPropertyCollection::get_Count

Get method for Count property.  Counts the number of properties for
this key.

Parameters:
	plReturn	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if plReturn == NULL
	S_OK on success

Notes:
	Actually counts all of the properties.  Do not call in a loop!
===================================================================*/
STDMETHODIMP CPropertyCollection::get_Count(long * plReturn)
{
	TRACE0("MetaUtil: CPropertyCollection::get_Count\n");

	ASSERT_NULL_OR_POINTER(plReturn, long);

	if (plReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;

	METADATA_RECORD mdr;
	BYTE *pbData;
	DWORD dwDataLen;
	DWORD dwReqDataLen;

	dwDataLen = 1024;
	pbData = new BYTE[dwDataLen];
	if (pbData == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}

	*plReturn = 0;
	for(;;) {  // FOREVER, will return out of loop
		// Get a property
		mdr.dwMDIdentifier = 0;
		mdr.dwMDAttributes = 0;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.pbMDData = pbData;
		mdr.dwMDDataLen = dwDataLen;
		mdr.dwMDDataTag = 0;
		hr = m_pIMeta->EnumData(METADATA_MASTER_ROOT_HANDLE, 
								T2W(m_tszKey), 
								&mdr,
								*plReturn,
								&dwReqDataLen);

		if (FAILED(hr)) {
			if (HRESULT_CODE(hr) == ERROR_NO_MORE_ITEMS) {
				// Done, cleanup and return the result
				delete pbData;
				return S_OK;
			}
			else if (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) {
				// Make a bigger buffer and try again
				delete pbData;
				dwDataLen = dwReqDataLen;
				pbData = new BYTE[dwDataLen];
				if (pbData == NULL) {
					return ::ReportError(E_OUTOFMEMORY);
					}
			}
			else {
				delete pbData;
				return ::ReportError(hr);
			}
		}
		else { // SUCCEEDED(hr)
			// Count it
			(*plReturn)++;
		}
	}
}

/*===================================================================
CPropertyCollection::get_Item

Get method for Item property.  Returns a key given its index.

Parameters:
	varId		[in] 1 based index or Name of the property to get
	ppIReturn	[out, retval] Interface for the property object

Returns:
	E_INVALIDARG if ppIReturn == NULL or lIndex <= 0
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
STDMETHODIMP CPropertyCollection::get_Item(long lIndex, 
										   LPDISPATCH * ppIReturn)
{
	TRACE0("MetaUtil: CPropertyCollection::get_Item\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, LPDISPATCH);

	if ((ppIReturn == NULL) || (lIndex <= 0)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;

	// Get the requested property
	METADATA_RECORD mdr;
	BYTE *pbData;
	DWORD dwReqDataLen;

	pbData = new BYTE[1024];
	if (pbData == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}

	mdr.dwMDIdentifier = 0;
	mdr.dwMDAttributes = 0;
	mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
	mdr.pbMDData = pbData;
	mdr.dwMDDataLen = 1024;
	mdr.dwMDDataTag = 0;
	hr = m_pIMeta->EnumData(METADATA_MASTER_ROOT_HANDLE, 
							T2W(m_tszKey), 
							&mdr,
							lIndex - 1,
							&dwReqDataLen);

	// If the buffer was too small, try again with a bigger one
	if (FAILED(hr) && (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER)) {
		delete pbData;
		pbData = new BYTE[dwReqDataLen];
		if (pbData == NULL) {
			return ::ReportError(hr);
		}

		mdr.dwMDIdentifier = 0;
		mdr.dwMDAttributes = 0;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.pbMDData = pbData;
		mdr.dwMDDataLen = dwReqDataLen;
		mdr.dwMDDataTag = 0;

		hr = m_pIMeta->EnumData(METADATA_MASTER_ROOT_HANDLE, 
								T2W(m_tszKey), 
								&mdr,
								lIndex - 1,
								&dwReqDataLen);
	}

	// If we got it create a properties object
	if (SUCCEEDED(hr)) {
		// Create the property object
		CComObject<CProperty> *pObj = NULL;
		ATLTRY(pObj = new CComObject<CProperty>);
		if (pObj == NULL) {
			delete pbData;
			return ::ReportError(E_OUTOFMEMORY);
		}
		hr = pObj->Init(m_pIMeta, m_pCSchemaTable, m_tszKey, &mdr);
		if (FAILED(hr)) {
			delete pbData;
			return ::ReportError(hr);
		}

		// Set the interface to IDispatch
		hr = pObj->QueryInterface(IID_IDispatch, (void **) ppIReturn);
		if (FAILED(hr)) {
			delete pbData;
			return ::ReportError(hr);
		}
		ASSERT(*ppIReturn != NULL);
	}
	else {  // FAILED(hr)
		delete pbData;
		return ::ReportError(hr);
	}

	delete pbData;
	return S_OK;
}

/*===================================================================
CPropertyCollection::get__NewEnum

Get method for _NewEnum property.  Returns an enumeration object for
the properties.

Parameters:
	ppIReturn	[out, retval] Interface for the enumeration object

Returns:
	E_INVALIDARG if ppIReturn == NULL
	E_OUTOFMEMORY if allocation failed
	S_OK on success
===================================================================*/
STDMETHODIMP CPropertyCollection::get__NewEnum(LPUNKNOWN * ppIReturn)
{
	TRACE0("MetaUtil: CPropertyCollection::get__NewEnum\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, LPUNKNOWN);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;

	// Create the property enumeration
	CComObject<CPropertyEnum> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CPropertyEnum>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pIMeta, m_pCSchemaTable, m_tszKey, 0);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IUnknown
	hr = pObj->QueryInterface(IID_IUnknown, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;
}

/*===================================================================
CPropertyCollection::Get

Get a property object from the base key of the collection.

Parameters:
	varId		[in] Identifier of property to get.  Either the 
				Id (number) or Name (string).
	ppIReturn	[out, retval] Interface for the property object

Returns:
	E_INVALIDARG if ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CPropertyCollection::Get(VARIANT varId, IProperty **ppIReturn)
{
	TRACE0("MetaUtil: CPropertyCollection::Get\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, IProperty *);

	if (ppIReturn == NULL) {
		return E_INVALIDARG;
	}

	return ::GetProperty(m_pIMeta, m_pCSchemaTable, m_tszKey, varId, ppIReturn);
}

/*===================================================================
CPropertyCollection::Add

Add a property object to the base key of the collection.

Parameters:
	varId		[in] Identifier of property to get.  Either the 
				Id (number) or Name (string).
	ppIReturn	[out, retval] Interface for the property object

Returns:
	E_INVALIDARG if ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CPropertyCollection::Add(VARIANT varId, IProperty **ppIReturn)
{
	TRACE0("MetaUtil: CPropertyCollection::Add\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, IProperty *);

	if (ppIReturn == NULL) {
		return E_INVALIDARG;
	}

	return ::CreateProperty(m_pIMeta, m_pCSchemaTable, m_tszKey, varId, ppIReturn);
}

/*===================================================================
CPropertyCollection::Remove

Remove a property from the base key of the collection.

Parameters:
	varId		[in] Identifier of property to remove.  Either the 
				Id (number) or Name (string).

Returns:
	S_OK on success
===================================================================*/
STDMETHODIMP CPropertyCollection::Remove(VARIANT varId)
{
	TRACE0("MetaUtil: CPropertyCollection::Remove\n");

	return ::DeleteProperty(m_pIMeta, m_pCSchemaTable, m_tszKey, varId);
}


/*------------------------------------------------------------------
 * C P r o p e r t y E n u m
 */

/*===================================================================
CPropertyEnum::CPropertyEnum

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CPropertyEnum::CPropertyEnum() : m_pCSchemaTable(NULL),
								 m_tszKey(NULL),
								 m_iIndex(0)
{
}

/*===================================================================
CPropertyEnum::Init

Constructor

Parameters:
	pIMeta		ATL Smart pointer to the metabase
	tszKey		Name of key to enumerate properties of
	iIndex		Index of next element in enumeration

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CPropertyEnum::Init(const CComPtr<IMSAdminBase> &pIMeta,
							CMetaSchemaTable *pCSchemaTable, 
							LPCTSTR tszKey, 
							int iIndex) 
{ 
	ASSERT(pIMeta.p != NULL);
	ASSERT_NULL_OR_STRING(tszKey);
	ASSERT(iIndex >= 0);

	m_pIMeta = pIMeta;
	m_pCSchemaTable = pCSchemaTable;
	m_pCSchemaTable->AddRef();

	// Copy m_tszKey
	if (tszKey == NULL) {
		// Key is root
		m_tszKey = NULL;
	}
	else {
		// Allocate and copy the passed string to the member string
		m_tszKey = new TCHAR[_tcslen(tszKey) + 1];
		if (m_tszKey == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
		_tcscpy(m_tszKey, tszKey);
		CannonizeKey(m_tszKey);
	}

	m_iIndex = iIndex;

	return S_OK; 
}

/*===================================================================
CPropertyEnum::~CPropertyEnum

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CPropertyEnum::~CPropertyEnum() 
{
	m_pCSchemaTable->Release();

	if (m_tszKey != NULL) {
		delete m_tszKey;
	}
}

/*===================================================================
CPropertyEnum::Next

Gets the next n items from the enumberation.

Parameters:
	ulNumToGet	[in] Number of elements to get
	rgvarDest	[out] Array to put them in
	pulNumGot	[out] If not NULL, number of elements rgvarDest got

Returns:
	E_INVALIDARG if rgvarDest == NULL
	E_OUTOFMEMORY if allocation failed
	S_OK if outputs ulNumToGet items
	S_FALSE if outputs less than ulNumToGet items
===================================================================*/
STDMETHODIMP CPropertyEnum::Next(unsigned long ulNumToGet, 
								 VARIANT FAR* rgvarDest, 
								 unsigned long FAR* pulNumGot) 
{
	TRACE0("MetaUtil: CPropertyEnum::Next\n");

	ASSERT_NULL_OR_POINTER(pulNumGot, unsigned long);
	// Make sure the array is big enough and we can write to it
	ASSERT((rgvarDest == NULL) || IsValidAddress(rgvarDest, ulNumToGet * sizeof(VARIANT), TRUE));

	if (rgvarDest == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;

	METADATA_RECORD mdr;
	BYTE *pbData;
	DWORD dwDataLen;
	DWORD dwReqDataLen;
	unsigned int uiDestIndex;
	IDispatch *pIDispatch;

	dwDataLen = 1024;
	pbData = new BYTE[dwDataLen];
	if (pbData == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}

	// For each property to get
	uiDestIndex = 0;
	while (uiDestIndex < ulNumToGet) {
		// Get a property
		mdr.dwMDIdentifier = 0;
		mdr.dwMDAttributes = 0;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.pbMDData = pbData;
		mdr.dwMDDataLen = dwDataLen;
		mdr.dwMDDataTag = 0;
		hr = m_pIMeta->EnumData(METADATA_MASTER_ROOT_HANDLE, 
								T2W(m_tszKey), 
								&mdr,
								m_iIndex,
								&dwReqDataLen);

		if (FAILED(hr)) {
			if (HRESULT_CODE(hr) == ERROR_NO_MORE_ITEMS) {
				// Done, cleanup and return the result
				if (pulNumGot != NULL) {
					*pulNumGot = uiDestIndex;
				}
				delete pbData;
				return S_FALSE;
			}
			else if (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) {
				// Try again with a bigger buffer
				delete pbData;
				dwDataLen = dwReqDataLen;
				pbData = new BYTE[dwDataLen];
				if (pbData == NULL) {
					return ::ReportError(E_OUTOFMEMORY);
					}
			}
			else {
				delete pbData;
				return ::ReportError(hr);
			}
		}
		else { // SUCCEEDED(hr)
			// Create the property object
			CComObject<CProperty> *pObj = NULL;
			ATLTRY(pObj = new CComObject<CProperty>);
			if (pObj == NULL) {
				delete pbData;
				return ::ReportError(E_OUTOFMEMORY);
			}
			hr = pObj->Init(m_pIMeta, m_pCSchemaTable, m_tszKey, &mdr);
			if (FAILED(hr)) {
				delete pbData;
				return ::ReportError(hr);
			}

			// Set the interface to IDispatch
			hr = pObj->QueryInterface(IID_IDispatch, (void **) &pIDispatch);
			if (FAILED(hr)) {
				delete pbData;
				return ::ReportError(hr);
			}
			ASSERT(pIDispatch != NULL);

			// Put it in the output array
			VariantInit(&(rgvarDest[uiDestIndex]));
			rgvarDest[uiDestIndex].vt = VT_DISPATCH;
			rgvarDest[uiDestIndex].pdispVal = pIDispatch;

			// Next element
			m_iIndex++;
			uiDestIndex++;
		}
	}

	delete pbData;

	if (pulNumGot != NULL) {
		*pulNumGot = uiDestIndex;
	}

	return S_OK;
}

/*===================================================================
CPropertyEnum::Skip

Skips the next n items in an enumeration

Parameters:
	ulNumToSkip	[in] Number of elements to skip

Returns:
	S_OK always
===================================================================*/
STDMETHODIMP CPropertyEnum::Skip(unsigned long ulNumToSkip) 
{
	TRACE0("MetaUtil: CPropertyEnum::Skip\n");

	m_iIndex += ulNumToSkip;

	return S_OK;
}

/*===================================================================
CPropertyEnum::Reset

Rests the enumeration to the first item

Parameters:
	None

Returns:
	S_OK always
===================================================================*/
STDMETHODIMP CPropertyEnum::Reset() 
{
	TRACE0("MetaUtil: CPropertyEnum::Reset\n");

	m_iIndex = 0;

	return S_OK;
}

/*===================================================================
CPropertyEnum::Clone

Gets an interface pointer to a copy of the enumeration at its
current state.

Parameters:
	ppIReturn	[out] Pointer to interface for copy

Returns:
	E_INVALIDARG if ppIReturn == NULL
	E_OUTOFMEMORY if not enough memory to create clone
	S_OK on success
===================================================================*/
STDMETHODIMP CPropertyEnum::Clone(IEnumVARIANT FAR* FAR* ppIReturn)  
{
	TRACE0("MetaUtil: CPropertyEnum::Clone\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, LPUNKNOWN);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;

	// Create a copy of the enumeration
	CComObject<CPropertyEnum> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CPropertyEnum>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pIMeta, m_pCSchemaTable, m_tszKey, m_iIndex);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IEnumVARIANT
	hr = pObj->QueryInterface(IID_IEnumVARIANT, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;
}



/*------------------------------------------------------------------
 * C P r o p e r t y
 */

/*===================================================================
CProperty::CProperty

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CProperty::CProperty() : m_pCSchemaTable(NULL),
						 m_tszKey(NULL),
						 m_dwId(0),
						 m_dwAttributes(0),
						 m_dwUserType(0),
						 m_dwDataType(0)
{
	VariantInit(&m_varData);
}

/*===================================================================
CProperty::Init

Constructor

Parameters:
	tszKey	Name of key where the property is located
	dwId	Id of property
	bCreate TRUE if this property can be created (does not have to exist)

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CProperty::Init(const CComPtr<IMSAdminBase> &pIMeta,
						CMetaSchemaTable *pCSchemaTable,
						LPCTSTR tszKey, 
						DWORD dwId, 
						BOOL bCreate) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_NULL_OR_STRING(tszKey);

	USES_CONVERSION;
	HRESULT hr;

	m_pIMeta = pIMeta;
	m_pCSchemaTable = pCSchemaTable;
	m_pCSchemaTable->AddRef();

	// Set the Key and Id members
	if (tszKey == NULL) {
		m_tszKey = NULL;
	}
	else {
		m_tszKey = new TCHAR[_tcslen(tszKey) + 1];
		if (m_tszKey == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
		_tcscpy(m_tszKey, tszKey);
		CannonizeKey(m_tszKey);
	}

	m_dwId = dwId;

	// Open the key (to be sure it exists)
	METADATA_HANDLE hMDKey;

	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   T2W(m_tszKey),
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDKey);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	
	// Get the property
	METADATA_RECORD mdr;
	BYTE *pbData;
	DWORD dwReqLen;

	pbData = new BYTE[1024];
	if (pbData == NULL) {
		m_pIMeta->CloseKey(hMDKey);
		return ::ReportError(hr);
	}

	mdr.dwMDIdentifier = m_dwId;
	mdr.dwMDAttributes = 0;
	mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
    mdr.pbMDData = pbData;
	mdr.dwMDDataLen = 1024;
	mdr.dwMDDataTag = 0;

	hr = m_pIMeta->GetData(hMDKey,
						   NULL,
						   &mdr,
						   &dwReqLen);

	// If the buffer was too small, try again with a bigger one
	if (FAILED(hr) && (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER)) {
		delete pbData;
		pbData = new BYTE[dwReqLen];
		if (pbData == NULL) {
			m_pIMeta->CloseKey(hMDKey);
			return ::ReportError(hr);
		}

		mdr.dwMDIdentifier = m_dwId;
		mdr.dwMDAttributes = 0;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.pbMDData = pbData;
		mdr.dwMDDataLen = dwReqLen;
		mdr.dwMDDataTag = 0;

		hr = m_pIMeta->GetData(hMDKey,
							   NULL,
							   &mdr,
							   &dwReqLen);
	}

	// If we got it fill in the fields
	if (SUCCEEDED(hr)) {
		m_dwAttributes = mdr.dwMDAttributes;
		m_dwUserType = mdr.dwMDUserType;
		m_dwDataType = mdr.dwMDDataType;
		SetDataToVar(mdr.pbMDData, mdr.dwMDDataLen);
	}
	// If the property doesn't exist and we're creating, set defaults
	else if ((bCreate) && (hr == MD_ERROR_DATA_NOT_FOUND)) {
		m_dwAttributes = 0;
		m_dwUserType = 0;
		m_dwDataType = 0;
		VariantClear(&m_varData);
	}
	else {  //(FAILED(hr))
		delete pbData;
		m_pIMeta->CloseKey(hMDKey);
		return ::ReportError(hr);
	}

	delete pbData;

	// Close the key
	m_pIMeta->CloseKey(hMDKey);

	return S_OK;
}

/*===================================================================
CProperty::Init

Constructor

Parameters:
	tszKey	Name of key where property is located
	mdr		METADATA_RECORD containing the current property info

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CProperty::Init(const CComPtr<IMSAdminBase> &pIMeta,
						CMetaSchemaTable *pCSchemaTable, 
						LPCTSTR tszKey, 
						METADATA_RECORD *mdr) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_NULL_OR_STRING(tszKey);

	HRESULT hr;

	m_pIMeta = pIMeta;
	m_pCSchemaTable = pCSchemaTable;
	m_pCSchemaTable->AddRef();

	// Set the Key member
	if (tszKey == NULL) {
		m_tszKey = NULL;
	}
	else {
		m_tszKey = new TCHAR[_tcslen(tszKey) + 1];
		if (m_tszKey == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
		_tcscpy(m_tszKey, tszKey);
	}

	// Use mdr to set the rest
	m_dwId = mdr->dwMDIdentifier;
	m_dwAttributes = mdr->dwMDAttributes;
	m_dwUserType = mdr->dwMDUserType;
	m_dwDataType = mdr->dwMDDataType;
	hr = SetDataToVar(mdr->pbMDData, mdr->dwMDDataLen);
	if (FAILED(hr)) {
		::ReportError(hr);
	}

	return S_OK;
}

/*===================================================================
CProperty::~CProperty

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CProperty::~CProperty() 
{
	m_pCSchemaTable->Release();

	if (m_tszKey != NULL) {
		delete m_tszKey;
	}

	VariantClear(&m_varData);
}

/*===================================================================
CProperty::InterfaceSupportsErrorInfo

Standard ATL implementation

===================================================================*/
STDMETHODIMP CProperty::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IProperty,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*===================================================================
CProperty::get_Id

Get method for Id property.  Identifier for this metabase property.

Parameters:
	plId	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if pulId == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CProperty::get_Id(long *plId)
{
	//TRACE0("MetaUtil: CProperty::get_Id\n");
	ASSERT_NULL_OR_POINTER(plId, long);

	if (plId == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	*plId = (long) m_dwId;

	return S_OK;
}

/*===================================================================
CProperty::get_Name

Get method for Name property.  Name of this metabase property.

Parameters:
	pbstrName	[out, retval] Value to return to client.  If property
				has no name "" is returned

Returns:
	E_INVALIDARG if pbstrName == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CProperty::get_Name(BSTR *pbstrName)
{
	TRACE0("MetaUtil: CProperty::get_Name\n");
	ASSERT_NULL_OR_POINTER(pbstrName, BSTR);

	if (pbstrName == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	CPropInfo *pCPropInfo;

	// Get the property info from the Schema Table
	pCPropInfo = m_pCSchemaTable->GetPropInfo(m_tszKey, m_dwId);

	// Did we find it?  Is there a name entry
	if ((pCPropInfo == NULL) || (pCPropInfo->GetName() == NULL)) {
		// No, return ""
		*pbstrName = T2BSTR(_T(""));
	}
	else {
		// Yes, return the name
		*pbstrName = T2BSTR(pCPropInfo->GetName());
	}

	return S_OK;
}

/*===================================================================
CProperty::get_Attributes

Get method for Attributes property.  Gets the attribute flags for
this property.

Parameters:
	plAttributes	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if pulAttributes == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CProperty::get_Attributes(long *plAttributes)
{
	//TRACE0("MetaUtil: CProperty::get_Attributes\n");
	ASSERT_NULL_OR_POINTER(plAttributes, long);

	if (plAttributes == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	*plAttributes = (long) m_dwAttributes;

	return S_OK;
}

/*===================================================================
CProperty::put_Attributes

Put method for Attributes property.  Sets the attribute flags for
this property.

Parameters:
	lAttributes	[in] New value for attributes.

Returns:
	S_OK always
===================================================================*/
STDMETHODIMP CProperty::put_Attributes(long lAttributes)
{
	TRACE0("MetaUtil: CProperty::put_Attributes\n");

	m_dwAttributes = (DWORD) lAttributes;

	return S_OK;
}

/*===================================================================
CProperty::get_UserType

Get method for UserType property.  Gets the User Type for this
metabase property.

Parameters:
	plUserType	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if pulUserType == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CProperty::get_UserType(long *plUserType)
{
	//TRACE0("MetaUtil: CProperty::get_UserType\n");
	ASSERT_NULL_OR_POINTER(plUserType, long);

	if (plUserType == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	*plUserType = (long) m_dwUserType;

	return S_OK;
}

/*===================================================================
CProperty::put_UserType

Put method for UserType property.  Sets the user type

Parameters:
	lUserType	[in] New value for user type.

Returns:
	S_OK always
===================================================================*/
STDMETHODIMP CProperty::put_UserType(long lUserType)
{
	TRACE0("MetaUtil: CProperty::put_UserType\n");

	m_dwUserType = (DWORD) lUserType;

	return S_OK;
}

/*===================================================================
CProperty::get_DataType

Get method for DataType property.  Gets the type of data stored in
the metabase property.

Parameters:
	plDataType	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if pulDataType == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CProperty::get_DataType(long *plDataType)
{
	//TRACE0("MetaUtil: CProperty::get_DataType\n");
	ASSERT_NULL_OR_POINTER(plDataType, long);

	if (plDataType == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	*plDataType = (long) m_dwDataType;

	return S_OK;
}

/*===================================================================
CProperty::put_DataType

Put method for DataType property.  Sets the data type

Parameters:
	lDataType	[in] New value for data type.

Returns:
	S_OK always
===================================================================*/
STDMETHODIMP CProperty::put_DataType(long lDataType)
{
	TRACE0("MetaUtil: CProperty::put_DataType\n");

	m_dwDataType = (DWORD) lDataType;

	return S_OK;
}

/*===================================================================
CProperty::get_Data

Get method for Data property.  Gets the data for this metabase
property.

Parameters:
	pvarData	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if pvarData == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CProperty::get_Data(VARIANT *pvarData)
{
	//TRACE0("MetaUtil: CProperty::get_Data\n");
	ASSERT_NULL_OR_POINTER(pvarData, VARIANT);

	if (pvarData == NULL) {
		return E_INVALIDARG;
	}

	HRESULT hr;

	hr = VariantCopy(pvarData, &m_varData);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	return S_OK;
}

/*===================================================================
CProperty::put_Data

Put method for Data property.  Sets the data

Parameters:
	varData	[in] New value for data
===================================================================*/
STDMETHODIMP CProperty::put_Data(VARIANT varData)
{
	TRACE0("MetaUtil: CProperty::put_Data\n");

	HRESULT hr;

	hr = VariantCopy(&m_varData, &varData);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	return S_OK;
}

/*===================================================================
CProperty::Write

Writes changes made to this object to the metabase

Parameters:
	None

Returns:
	S_OK on success
===================================================================*/
STDMETHODIMP CProperty::Write()
{
	USES_CONVERSION;

	TRACE0("MetaUtil: CProperty::Write\n");

	HRESULT hr;

	// Open the key for write access
	METADATA_HANDLE hMDKey;

	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   T2W(m_tszKey),
						   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDKey);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	
	// Create the data record
	METADATA_RECORD mdr;

	mdr.dwMDIdentifier = m_dwId;
	mdr.dwMDAttributes = m_dwAttributes;
	mdr.dwMDUserType = m_dwUserType;
	mdr.dwMDDataType = m_dwDataType;
	hr = GetDataFromVar(mdr.pbMDData, mdr.dwMDDataLen);
	if (FAILED(hr)) {
		m_pIMeta->CloseKey(hMDKey);
		return ::ReportError(hr);
	}
	mdr.dwMDDataTag = 0;

	// Set the data
	hr = m_pIMeta->SetData(hMDKey,
						   L"",
						   &mdr);
	if (FAILED(hr)) {
		m_pIMeta->CloseKey(hMDKey);
		delete mdr.pbMDData;
		return ::ReportError(hr);
	}

	// Close the key
	m_pIMeta->CloseKey(hMDKey);
	delete mdr.pbMDData;

	return S_OK;
}

/*===================================================================
CProperty::SetDataToVar

Private function to save property data from its raw form to the
variant data member.

Parameters:
	pbData		Raw property data to convert to variant
	dwDataLen	Length of property data

Returns:
	ERROR_INVALID_DATA if m_dwDataType is not recognized
	E_OUTOFMEMORY if allocation failed
	S_OK on success
===================================================================*/
HRESULT CProperty::SetDataToVar(BYTE *pbData, DWORD dwDataLen) 
{
	ASSERT((pbData == NULL) || IsValidAddress(pbData, dwDataLen, FALSE));

	HRESULT hr;

	hr = VariantClear(&m_varData);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	switch(m_dwDataType) {

	case DWORD_METADATA:
		// I4 subtype
		V_VT(&m_varData) = VT_I4;
		V_I4(&m_varData) = *(reinterpret_cast<long *> (pbData));
		break;

	case STRING_METADATA:
	case EXPANDSZ_METADATA:
		// BSTR subtype
		V_VT(&m_varData) = VT_BSTR;
		V_BSTR(&m_varData) = W2BSTR(reinterpret_cast<LPCWSTR> (pbData));
		break;

	case MULTISZ_METADATA: {
		ULONG   cStrings = 0;
		// Metabase string are Unicode
        LPCWSTR pwsz     = reinterpret_cast<LPCWSTR> (pbData);
        LPCWSTR pwszEnd  = reinterpret_cast<LPCWSTR> (pbData + dwDataLen);

        // Data is a series of null-terminated strings terminated by two nulls.
        // Figure out how many values we have
        while ((*pwsz != L'\0') && (pwsz < pwszEnd))
        {
            cStrings++;
            pwsz += wcslen(pwsz) + 1; // skip string and trailing \0
        }

        // Create a SAFEARRAY to hold the return result.  The array
        // has to be of VARIANTs, not BSTRs, as you might expect, because
        // VBScript will not accept an array of BSTRs (although VB5 will).
        SAFEARRAYBOUND rgsabound[1] = {{cStrings, 0L}};
        SAFEARRAY*     psa = SafeArrayCreate(VT_VARIANT, 1, rgsabound);

        if (psa == NULL)
            return ::ReportError(E_OUTOFMEMORY);

        // now stuff the values into the array
        LONG i = 0;
        pwsz   = reinterpret_cast<LPCWSTR> (pbData);

        while ((*pwsz != L'\0') && (pwsz < pwszEnd))
        {
            // Stuff the string into a BSTR VARIANT
            CComVariant vt = W2BSTR(pwsz);
            ASSERT(V_VT(&vt) == VT_BSTR);
            HRESULT hr = SafeArrayPutElement(psa, &i, (void*) &vt);
            if (FAILED(hr))
                ::ReportError(hr);
            i++;
            pwsz += wcslen(pwsz) + 1; // skip string and trailing \0
        }

        V_VT(&m_varData) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(&m_varData) = psa;

        break;
	}

	case BINARY_METADATA:
		// BSTR of byte data subtype
		V_VT(&m_varData) = VT_BSTR;
		V_BSTR(&m_varData) = SysAllocStringByteLen((char *) pbData, dwDataLen);
		break;

	default:
		// Unknown data type
		return ::ReportError(ERROR_INVALID_DATA);
	}
	
	return S_OK;
}

/*===================================================================
CProperty::GetDataFromVar

Private function to get data from the variant data member to its
raw form.

Supported SubTypes:

	DWORD_METADATA:
		I1, I2, I4, I8, UI1, UI2, UI4, UI8

	STRING_METADATA and EXPANDSZ_METADATA:
		BSTR

	MULTISZ_METADATA
		VT_ARRAY | VT_VARIANT (1 Dimension, stops on NULL or EMPTY)
		VT_ARRAY | VT_BSTR    (1 Dimension)

	BINARY_METADATA
		BSTR
		
Parameters:
	pbData		Pointer to output buffer (allocated by this function)
	dwDataLen	Length of data in output buffer

Returns:
    ERROR_INVALID_DATA if m_dwDataType is not recognized or does not
		match the expected variant subtype.
	E_OUTOFMEMORY on allocation failure
	S_OK on succes

Notes:
	Case statements are used for each dwMDDataType value to facilitate
	adding support for additional VariantSubType to Data conversions.

    MULTISZ_METADATA with VT_ARRAY | VT_VARIANT stops at a NULL or
	EMPTY entry because it is easy to allocate an array one bigger
	than you need in VBScript.  Instead of erroring in this case, I 
	stop when I hit such an entry.  This also allows a larger array 
	to be allocated that is terminated by NULL or EMPTY.
===================================================================*/
HRESULT CProperty::GetDataFromVar(BYTE * &pbData, DWORD &dwDataLen) 
{	
	USES_CONVERSION;
	HRESULT hr;

	// Cleanup any IDispatch or byref stuff
	CComVariant varData;

	hr = VariantResolveDispatch(&m_varData, &varData);
	if (FAILED(hr)) {
        return hr;
	}

	switch(m_dwDataType) {

	case DWORD_METADATA:
		// I4 subtype

		switch (V_VT(&varData)) {
		
		case VT_I1:  case VT_I2:  case VT_I4: case VT_I8:
		case VT_UI1: case VT_UI2: case VT_UI8:

		// Coerce all integral types to VT_UI4, which is the same as DWORD_METADATA
		if (FAILED(hr = VariantChangeType(&varData, &varData, 0, VT_UI4)))
			return ::ReportError(hr);

		// fallthru to VT_UI4

		case VT_UI4:
			
			dwDataLen = sizeof(DWORD);
			pbData = reinterpret_cast<BYTE *> (new DWORD);
			if (pbData == NULL) {
				return ::ReportError(E_OUTOFMEMORY);
			}

			*(reinterpret_cast<DWORD *> (pbData)) = V_UI4(&varData);
			break;

		default:
			// Unexpected data type
			return ::ReportError(ERROR_INVALID_DATA);
		}
		
		break;

	case STRING_METADATA:
	case EXPANDSZ_METADATA:
		// BSTR subtype

		switch (V_VT(&varData)) {

		case VT_BSTR:
			// Ignores the length field, terminate at the first NULL
			dwDataLen = (wcslen(OLE2W(V_BSTR(&varData))) + 1) * sizeof(wchar_t);

			pbData = new BYTE[dwDataLen];
            if( pbData == NULL )
            {
                return ::ReportError(E_OUTOFMEMORY);
            }
			memcpy(pbData, OLE2W(V_BSTR(&varData)), dwDataLen);

		default:
			// Unexpected data type
			return ::ReportError(ERROR_INVALID_DATA);
		}

		break;

	case MULTISZ_METADATA:
		// ARRAY of BSTR subtype
		
		// if it's a 1 Dimentional Array subtype
		if (((V_VT(&varData) & VT_ARRAY) == VT_ARRAY) && 
			(SafeArrayGetDim(V_ARRAY(&varData)) == 1) ) {
			
			// Get Array Bounds
			long lLBound;
			long lUBound;
			long lNumElements;
			hr = SafeArrayGetLBound(V_ARRAY(&varData), 1, &lLBound);
			if (FAILED(hr)) {
				return ::ReportError(hr);
			}
			hr = SafeArrayGetUBound(V_ARRAY(&varData), 1, &lUBound);
			if (FAILED(hr)) {
				return ::ReportError(hr);
			}

			lNumElements = lUBound - lLBound + 1;

			// Process the element types
			switch (V_VT(&varData)) {

			case VT_ARRAY | VT_VARIANT : {

				VARIANT *rgvarRaw;   // Before resolveIDispatch
				CComVariant *rgvar;  // After resolveIDispatch
				LPWSTR wszIndex;
				int i;
				int iStrLen;

				rgvar = new CComVariant[lUBound - lLBound + 1];
				if (rgvar == NULL) {
					return ::ReportError(E_OUTOFMEMORY);
				}

				hr = SafeArrayAccessData(V_ARRAY(&varData), (void **) &rgvarRaw);
				if (FAILED(hr)) {
					return ::ReportError(hr);
				}

				// Pass 1, resolve IDispatch, check types and figure out how much memory is needed
				dwDataLen = 0;
				for (i = 0; i < lNumElements; i++) {
					hr = VariantResolveDispatch(&(rgvarRaw[i]), &(rgvar[i]));
					if (FAILED(hr)) {
						return hr;
					}

					if (V_VT(&(rgvar[i])) != VT_BSTR) {
						if ((V_VT(&(rgvar[i])) == VT_EMPTY) ||
							(V_VT(&(rgvar[i])) == VT_NULL)) {
							// NULL or EMPTY, Stop Here
							lNumElements = i;
							break;
						}
						else {
							SafeArrayUnaccessData(V_ARRAY(&varData));
							return ::ReportError(ERROR_INVALID_DATA);
						}
					}

					dwDataLen += (wcslen(OLE2W(V_BSTR(&(rgvar[i])))) + 1) * sizeof(wchar_t);
				}
				dwDataLen += sizeof(wchar_t);

				// Allocate
				pbData = new BYTE[dwDataLen];
				if (pbData == NULL) {
					SafeArrayUnaccessData(V_ARRAY(&varData));
					return ::ReportError(E_OUTOFMEMORY);
				}

				// Pass 2, copy to desination
				wszIndex = reinterpret_cast<LPWSTR> (pbData);
				for (i = 0; i < lNumElements; i++) {
					iStrLen = (wcslen(OLE2W(V_BSTR(&(rgvar[i])))) + 1);
					memcpy(wszIndex, OLE2W(V_BSTR(&(rgvar[i]))), iStrLen * sizeof(wchar_t));
					wszIndex += iStrLen;
				}
				*wszIndex = L'\0';

				SafeArrayUnaccessData(V_ARRAY(&varData));

				break;
			}

			case VT_ARRAY | VT_BSTR : {

				BSTR *rgbstr;
				LPWSTR wszIndex;
				int i;
				int iStrLen;

				hr = SafeArrayAccessData(V_ARRAY(&varData), (void **) &rgbstr);
				if (FAILED(hr)) {
					return ::ReportError(hr);
				}

				// Pass 1, figure out how much memory is needed
				dwDataLen = 0;
				for (i = 0; i < lNumElements; i++) {
					dwDataLen += (wcslen(OLE2W(rgbstr[i])) + 1) * sizeof(wchar_t);
				}
				dwDataLen += sizeof(wchar_t);

				// Allocate
				pbData = new BYTE[dwDataLen];
				if (pbData == NULL) {
					SafeArrayUnaccessData(V_ARRAY(&varData));
					return ::ReportError(E_OUTOFMEMORY);
				}

				// Pass 2, copy to desination
				wszIndex = reinterpret_cast<LPWSTR> (pbData);
				for (i = 0; i < lNumElements; i++) {
					iStrLen = (wcslen(OLE2W(rgbstr[i])) + 1);
					memcpy(wszIndex, OLE2W(rgbstr[i]), iStrLen * sizeof(wchar_t));
					wszIndex += iStrLen;
				}
				*wszIndex = L'\0';

				SafeArrayUnaccessData(V_ARRAY(&varData));

				break;
			}

			default:
				// Unexpected data type
				return ::ReportError(ERROR_INVALID_DATA);	
			}
		}
		else { // Array is not one dimensional
			// Unexpected data type
			return ::ReportError(ERROR_INVALID_DATA);
		}

		break;

	case BINARY_METADATA:
		// BSTR of bytes subtype
		switch (V_VT(&varData)) {

		case VT_BSTR:
			// Use the length field, since NULL values are allowed
			dwDataLen = SysStringByteLen(V_BSTR(&varData));

			pbData = new BYTE[dwDataLen];
                        if( pbData == NULL )
                        {
                            return ::ReportError(E_OUTOFMEMORY);
                        }
			memcpy(pbData, V_BSTR(&varData), dwDataLen);

		default:
			// Unexpected data type
			return ::ReportError(ERROR_INVALID_DATA);
		}

		break;

	default:
		// Unknown metabase data type
		return ::ReportError(ERROR_INVALID_DATA);
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\propcol.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: PropCol.h

Owner: t-BrianM

This file contains the headers for the property collection and
property object.
===================================================================*/

#ifndef __PROPCOL_H_
#define __PROPCOL_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols


/*
 * C P r o p e r t y C o l l e c t i o n
 *
 * Implements property collections
 */

class CPropertyCollection : 
	public IDispatchImpl<IPropertyCollection, &IID_IPropertyCollection, &LIBID_MetaUtil>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	CPropertyCollection();
	HRESULT Init(const CComPtr<IMSAdminBase> &pIMeta, CMetaSchemaTable *pCSchemaTable, LPTSTR tszKey);
	~CPropertyCollection();

BEGIN_COM_MAP(CPropertyCollection)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IPropertyCollection)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CPropertyCollection)  

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPropertyCollection
	STDMETHOD(get_Count)(/*[out, retval]*/ long *plReturn);
	STDMETHOD(get_Item)(/*[in]*/ long lIndex, /*[out, retval]*/ LPDISPATCH *ppIReturn);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ LPUNKNOWN *ppIReturn);
	STDMETHOD(Get)(/*[in]*/ VARIANT varId, /*[out, retval]*/ IProperty **ppIReturn);
	STDMETHOD(Add)(/*[in]*/ VARIANT varId, /*[out, retval]*/ IProperty **ppIReturn);
	STDMETHOD(Remove)(/*[in]*/ VARIANT varId);

private:
	LPTSTR m_tszKey;

	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;

	CMetaSchemaTable *m_pCSchemaTable; 
};


/*
 * C P r o p e r t y E n u m
 *
 * Implements property enumberations
 */

class CPropertyEnum : 
	public IEnumVARIANT,
	public CComObjectRoot
{
public:
	CPropertyEnum();
	HRESULT Init(const CComPtr<IMSAdminBase> &pIMeta, CMetaSchemaTable *pCSchemaTable, LPCTSTR tszKey, int iIndex);
	~CPropertyEnum();

BEGIN_COM_MAP(CPropertyEnum)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CPropertyEnum) 

//IEnumVARIANT
	STDMETHOD(Next)(unsigned long ulNumToGet, 
					VARIANT FAR* rgvarDest, 
					unsigned long FAR* pulNumGot);
	STDMETHOD(Skip)(unsigned long ulNumToSkip);
	STDMETHOD(Reset)();
	STDMETHOD(Clone)(IEnumVARIANT FAR* FAR* ppIReturn);

private:
	int m_iIndex;
	LPTSTR m_tszKey;

	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;

	CMetaSchemaTable *m_pCSchemaTable;
};


/*
 * C P r o p e r t y
 *
 * Implements property objects.
 */

class CProperty : 
	public IDispatchImpl<IProperty, &IID_IProperty, &LIBID_MetaUtil>,
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	CProperty();
	HRESULT Init(const CComPtr<IMSAdminBase> &pIMeta, CMetaSchemaTable *pCSchemaTable, LPCTSTR tszKey, DWORD dwId, BOOL bCreate);
	HRESULT Init(const CComPtr<IMSAdminBase> &pIMeta, CMetaSchemaTable *pCSchemaTable, LPCTSTR tszKey, METADATA_RECORD *mdr);
	~CProperty();

BEGIN_COM_MAP(CProperty)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IProperty)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CProperty) 

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IProperty
	STDMETHOD(get_Id)(/*[out, retval]*/ long *plId);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pbstrName);
	STDMETHOD(get_Attributes)(/*[out, retval]*/ long *plAttributes);
	STDMETHOD(put_Attributes)(/*[in]*/ long plAttributes);
	STDMETHOD(get_UserType)(/*[out, retval]*/ long *plAttributes);
	STDMETHOD(put_UserType)(/*[in]*/ long plAttributes);
	STDMETHOD(get_DataType)(/*[out, retval]*/ long *plAttributes);
	STDMETHOD(put_DataType)(/*[in]*/ long plAttributes);
	STDMETHOD(get_Data)(/*[out, retval]*/ VARIANT *pvarData);
	STDMETHOD(put_Data)(/*[in]*/ VARIANT varData);
	STDMETHOD(Write)();

private:
	LPTSTR  m_tszKey;
	DWORD   m_dwId;

	DWORD   m_dwAttributes;
	DWORD   m_dwUserType;
	DWORD   m_dwDataType;
	VARIANT m_varData;

	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;

	CMetaSchemaTable *m_pCSchemaTable;

	HRESULT SetDataToVar(BYTE *pbData, DWORD dwDataLen);
	HRESULT GetDataFromVar(BYTE * &pbData, DWORD &dwDataLen);
};

#endif //ifndef __PROPCOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\mutilobj.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: MUtilObj.h

Owner: t-BrianM

This file contains the headers for the main MetaUtil object and
utility functions.
===================================================================*/

#ifndef __METAUTIL_H_
#define __METAUTIL_H_

#include "resource.h"   // main symbols
#include <iadmw.h>		// Metabase base object unicode interface
#include <iiscnfg.h>	// MD_ & IIS_MD_ defines
#include "utility.h"
#include "MetaSchm.h"
#include "keycol.h"
#include "propcol.h"
#include "chkerror.h"

#define MUTIL_OPEN_KEY_TIMEOUT 5000  //Timeout for metabase OpenKey() calls

/*
 * C M e t a U t i l
 *
 * Implements the main MetaUtil object
 */

class ATL_NO_VTABLE CMetaUtil : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMetaUtil, &CLSID_MetaUtil>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMetaUtil, &IID_IMetaUtil, &LIBID_MetaUtil>
{
public:
	CMetaUtil();
	HRESULT FinalConstruct();
	void FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_METAUTIL)

BEGIN_COM_MAP(CMetaUtil)
	COM_INTERFACE_ENTRY(IMetaUtil)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
// DECLARE_NOT_AGGREGATABLE(CMetaUtil)

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMetaUtil
	STDMETHOD(EnumProperties)(/*[in]*/ BSTR bstrKey, /*[out, retval]*/ IPropertyCollection **ppIReturn);
	STDMETHOD(EnumKeys)(/*[in]*/ BSTR bstrBaseKey, /*[out, retval]*/ IKeyCollection **ppIReturn);
	STDMETHOD(EnumAllKeys)(/*[in]*/ BSTR bstrBaseKey, /*[out, retval]*/ IKeyCollection **ppIReturn);

	STDMETHOD(CreateKey)(/*[in]*/ BSTR bstrKey);
	STDMETHOD(DeleteKey)(/*[in]*/ BSTR bstrKey);
	STDMETHOD(RenameKey)(/*[in]*/ BSTR bstrOldName, /*[in]*/ BSTR bstrNewName);
	STDMETHOD(CopyKey)(/*[in]*/ BSTR bstrSrcKey, /*[in]*/ BSTR bstrDestKey, /*[in]*/ BOOL fOverwrite);
	STDMETHOD(MoveKey)(/*[in]*/ BSTR bstrSrcKey, /*[in]*/ BSTR bstrDestKey, /*[in]*/ BOOL fOverwrite);

	STDMETHOD(GetProperty)(/*[in]*/ BSTR bstrKey, /*[in]*/ VARIANT varId, /*[out, retval]*/ IProperty **ppIReturn);
	STDMETHOD(CreateProperty)(/*[in]*/ BSTR bstrKey, /*[in]*/ VARIANT varId, /*[out, retval]*/ IProperty **ppIReturn);
	STDMETHOD(DeleteProperty)(/*[in]*/ BSTR bstrKey, /*[in]*/ VARIANT varId);

	STDMETHOD(CheckSchema)(/*[in]*/ BSTR bstrMachine, /*[out, retval]*/ ICheckErrorCollection **ppIReturn);
	STDMETHOD(CheckKey)(/*[in]*/ BSTR bstrKey, /*[out, retval]*/ ICheckErrorCollection **ppIReturn);

	STDMETHOD(ExpandString)(/*[in]*/ BSTR bstrIn, /*[out, retval]*/ BSTR *pbstrRet);
	STDMETHOD(PropIdToName)(/*[in]*/ BSTR bstrKey, /*[in]*/ long lId, /*[out, retval]*/ BSTR *pbstrName);
	STDMETHOD(PropNameToId)(/*[in]*/ BSTR bstrKey, /*[in]*/ BSTR bstrName, /*[out, retval]*/ long *plId);

	STDMETHOD(get_Config)(/*[in]*/ BSTR bstrSetting, /*[out, retval]*/ VARIANT *pvarValue);
	STDMETHOD(put_Config)(/*[in]*/ BSTR bstrSetting, /*[in]*/ VARIANT varValue);

private:
	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;

	// Schema table
	CMetaSchemaTable *m_pCSchemaTable;

	// Configuration variables
	DWORD m_dwMaxPropSize;
	DWORD m_dwMaxKeySize;
	DWORD m_dwMaxNumErrors;

	// General check methods
	void AddError(CComObject<CCheckErrorCollection> *pCErrorCol, long lId, long lSeverity, LPCTSTR tszKey, LPCTSTR tszSubKey, DWORD dwProperty);
	BOOL KeyExists(METADATA_HANDLE hMDKey, LPTSTR tszSubKey);
	BOOL PropertyExists(METADATA_HANDLE hMDKey, LPTSTR tszSubKey, DWORD dwId);

	// CheckSchema specific methods
	HRESULT CheckPropertyNames(CComObject<CCheckErrorCollection> *pCErrorCol, METADATA_HANDLE hMDMachine, LPTSTR tszMachine);
	HRESULT CheckPropertyTypes(CComObject<CCheckErrorCollection> *pCErrorCol, METADATA_HANDLE hMDMachine, LPTSTR tszMachine);
	HRESULT CheckClasses(CComObject<CCheckErrorCollection> *pCErrorCol, METADATA_HANDLE hMDMachine, LPTSTR tszMachine);
	HRESULT CheckClassProperties(CComObject<CCheckErrorCollection> *pCErrorCol, METADATA_HANDLE hMDClassKey, LPTSTR tszClassKey, LPTSTR tszClassSubKey);

	// CheckKey specific methods
	BOOL CheckCLSID(LPCTSTR tszCLSID);
	BOOL CheckMTXPackage(LPCTSTR tszPackId);
	HRESULT CheckKeyType(CComObject<CCheckErrorCollection> *pCErrorCol, METADATA_HANDLE hMDKey, LPTSTR tszKey);
	HRESULT CheckIfFileExists(LPCTSTR pszFSPath, BOOL *pfExists);
};

// Methods also supported by the collections
HRESULT CreateKey(CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszKey);
HRESULT DeleteKey(CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszKey);
HRESULT CopyKey(CComPtr<IMSAdminBase> &pIMeta, LPTSTR tszSrcKey, LPTSTR tszDestKey, BOOL fOverwrite, BOOL fCopy);
HRESULT GetProperty(CComPtr<IMSAdminBase> &pIMeta, CMetaSchemaTable *pCSchemaTable, LPCTSTR tszKey, VARIANT varId, IProperty **ppIReturn);
HRESULT CreateProperty(CComPtr<IMSAdminBase> &pIMeta, CMetaSchemaTable *pCSchemaTable, LPCTSTR tszKey, VARIANT varId, IProperty **ppIReturn);
HRESULT DeleteProperty(CComPtr<IMSAdminBase> &pIMeta, CMetaSchemaTable *pCSchemaTable, LPTSTR tszKey, VARIANT varId);

// Utility
HRESULT VarToMetaId(CMetaSchemaTable *pCSchemaTable, LPCTSTR tszKey, VARIANT varId, DWORD *pdwId);

// Schema Error Constants (*_S is severity)
#define MUTIL_CHK_NO_SCHEMA						1000
#define MUTIL_CHK_NO_SCHEMA_S					1
#define MUTIL_CHK_NO_PROPERTIES					1001
#define MUTIL_CHK_NO_PROPERTIES_S				1
#define MUTIL_CHK_NO_PROP_NAMES					1002
#define MUTIL_CHK_NO_PROP_NAMES_S				1
#define MUTIL_CHK_NO_PROP_TYPES					1003
#define MUTIL_CHK_NO_PROP_TYPES_S				1
#define MUTIL_CHK_NO_CLASSES					1004
#define MUTIL_CHK_NO_CLASSES_S					1
#define MUTIL_CHK_PROP_NAME_BAD_TYPE			1100
#define MUTIL_CHK_PROP_NAME_BAD_TYPE_S			1
#define MUTIL_CHK_PROP_NAME_NOT_UNIQUE			1101
#define MUTIL_CHK_PROP_NAME_NOT_UNIQUE_S		1
#define MUTIL_CHK_PROP_NAME_NOT_CASE_UNIQUE		1102
#define MUTIL_CHK_PROP_NAME_NOT_CASE_UNIQUE_S	1
#define MUTIL_CHK_PROP_TYPE_BAD_TYPE			1200
#define MUTIL_CHK_PROP_TYPE_BAD_TYPE_S			1

#define MUTIL_CHK_PROP_TYPE_BAD_DATA			1201
#define MUTIL_CHK_PROP_TYPE_BAD_DATA_S			2
#define MUTIL_CHK_CLASS_NO_MANDATORY			1300
#define MUTIL_CHK_CLASS_NO_MANDATORY_S			1
#define MUTIL_CHK_CLASS_NO_OPTIONAL				1301
#define MUTIL_CHK_CLASS_NO_OPTIONAL_S			1
#define MUTIL_CHK_CLASS_NOT_CASE_UNIQUE			1302
#define MUTIL_CHK_CLASS_NOT_CASE_UNIQUE_S		2
#define MUTIL_CHK_CLASS_PROP_NO_TYPE		    1303
#define MUTIL_CHK_CLASS_PROP_NO_TYPE_S			2
#define MUTIL_CHK_CLASS_PROP_BAD_DATA_TYPE		1304
#define MUTIL_CHK_CLASS_PROP_BAD_DATA_TYPE_S	2
#define MUTIL_CHK_CLASS_PROP_BAD_USER_TYPE		1305
#define MUTIL_CHK_CLASS_PROP_BAD_USER_TYPE_S	2
#define MUTIL_CHK_CLASS_PROP_BAD_ATTR			1306
#define MUTIL_CHK_CLASS_PROP_BAD_ATTR_S			2

#define MUTIL_CHK_DATA_TOO_BIG					2000
#define MUTIL_CHK_DATA_TOO_BIG_S				3
#define MUTIL_CHK_KEY_TOO_BIG					2001
#define MUTIL_CHK_KEY_TOO_BIG_S					3
#define MUTIL_CHK_CLSID_NOT_FOUND				2002
#define MUTIL_CHK_CLSID_NOT_FOUND_S				1
#define MUTIL_CHK_MTX_PACK_ID_NOT_FOUND			2003
#define MUTIL_CHK_MTX_PACK_ID_NOT_FOUND_S		1
#define MUTIL_CHK_PATH_NOT_FOUND				2004
#define MUTIL_CHK_PATH_NOT_FOUND_S				1
#define MUTIL_CHK_NO_NAME_ENTRY					2100
#define MUTIL_CHK_NO_NAME_ENTRY_S				3
#define MUTIL_CHK_NO_TYPE_ENTRY					2101
#define MUTIL_CHK_NO_TYPE_ENTRY_S				3
#define MUTIL_CHK_BAD_DATA_TYPE					2102
#define MUTIL_CHK_BAD_DATA_TYPE_S				2
#define MUTIL_CHK_BAD_USER_TYPE					2103
#define MUTIL_CHK_BAD_USER_TYPE_S				2
#define MUTIL_CHK_BAD_ATTR						2104
#define MUTIL_CHK_BAD_ATTR_S					2

#define MUTIL_CHK_NO_KEYTYPE					2200
#define MUTIL_CHK_NO_KEYTYPE_S					3
#define MUTIL_CHK_NO_KEYTYPE_NOT_FOUND			2201
#define MUTIL_CHK_NO_KEYTYPE_NOT_FOUND_S		1
#define MUTIL_CHK_MANDATORY_PROP_MISSING		2202
#define MUTIL_CHK_MANDATORY_PROP_MISSING_S		2

#define MUTIL_CHK_TOO_MANY_ERRORS				9000
#define MUTIL_CHK_TOO_MANY_ERRORS_S				3

#endif //__METAUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MetaUtil.rc
//
#define IDS_PROJNAME						100
#define IDR_METAUTIL						101
#define IDS_CHK_BASE						10000
#define IDS_CHK_NO_SCHEMA					11000
#define IDS_CHK_NO_PROPERTIES				11001
#define IDS_CHK_NO_PROP_NAMES				11002
#define IDS_CHK_NO_PROP_TYPES				11003
#define IDS_CHK_NO_CLASSES					11004
#define IDS_CHK_PROP_NAME_BAD_TYPE			11100
#define IDS_CHK_PROP_NAME_NOT_UNIQUE		11101
#define IDS_CHK_PROP_NAME_NOT_CASE_UNIQUE	11102
#define IDS_CHK_PROP_TYPE_BAD_TYPE			11200
#define IDS_CHK_PROP_TYPE_BAD_DATA			11201

#define IDS_CHK_CLASS_NO_MANDATORY			11300
#define IDS_CHK_CLASS_NO_OPTIONAL			11301
#define IDS_CHK_CLASS_NOT_CASE_UNIQUE		11302
#define IDS_CHK_CLASS_PROP_NO_TYPE			11303
#define IDS_CHK_CLASS_PROP_BAD_DATA_TYPE    11304
#define IDS_CHK_CLASS_PROP_BAD_USER_TYPE    11305
#define IDS_CHK_CLASS_PROP_BAD_ATTR		    11306
#define IDS_CHK_DATA_TOO_BIG				12000
#define IDS_CHK_KEY_TOO_BIG					12001
#define IDS_CHK_CLSID_NOT_FOUND				12002
#define IDS_CHK_MTX_PACK_ID_NOT_FOUND		12003
#define IDS_CHK_PATH_NOT_FOUND				12004
#define IDS_CHK_NO_NAME_ENTRY				12100
#define IDS_CHK_NO_TYPE_ENTRY				12101
#define IDS_CHK_BAD_DATA_TYPE				12102
#define IDS_CHK_BAD_USER_TYPE				12103
#define IDS_CHK_BAD_ATTR					12104
#define IDS_CHK_NO_KEYTYPE					12200
#define IDS_CHK_NO_KEYTYPE_NOT_FOUND		12201
#define IDS_CHK_MANDATORY_PROP_MISSING		12202
#define IDS_CHK_TOO_MANY_ERRORS				19000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           118
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\utility.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: Utility.h

Owner: t-BrianM

This file contains the headers for the utility functions.
===================================================================*/

#ifndef __UTILITY_H_
#define __UTILITY_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/*
 * U t i l i t i e s
 */

// Sets up the ErrorInfo structure
HRESULT ReportError(DWORD dwErr);
HRESULT ReportError(HRESULT hr);

// Metabase key manipulation
LPTSTR CannonizeKey(LPTSTR tszKey);
void SplitKey(LPCTSTR tszKey, LPTSTR tszParent, LPTSTR tszChild);
void GetMachineFromKey(LPCTSTR tszFullKey, LPTSTR tszMachine);
BOOL KeyIsInSchema(LPCTSTR tszFullKey);
BOOL KeyIsInIISAdmin(LPCTSTR tszFullKey);

// Variant manipulation
HRESULT VariantResolveDispatch(VARIANT* pVarIn, VARIANT* pVarOut);

#endif //__UTILITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B40F6F44_E116_11D0_9E58_00C04FB94FEF__INCLUDED_)
#define AFX_STDAFX_H__B40F6F44_E116_11D0_9E58_00C04FB94FEF__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <OleAuto.h>    // OLE Automation types

#undef  ASSERT
#include <irtldbg.h>
#undef  ASSERT
#define ASSERT(x) IRTLASSERT(x)

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B40F6F44_E116_11D0_9E58_00C04FB94FEF__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\pwalker\ntstuff.c ===
#include "pwalker.h"
#pragma hdrstop

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)


//
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;
	
typedef LONG KPRIORITY;

typedef struct _SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER SpareLi1;
    LARGE_INTEGER SpareLi2;
    LARGE_INTEGER SpareLi3;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SpareUl2;
    ULONG SpareUl3;
    ULONG PeakVirtualSize;
    ULONG VirtualSize;
    ULONG PageFaultCount;
    ULONG PeakWorkingSetSize;
    ULONG WorkingSetSize;
    ULONG QuotaPeakPagedPoolUsage;
    ULONG QuotaPagedPoolUsage;
    ULONG QuotaPeakNonPagedPoolUsage;
    ULONG QuotaNonPagedPoolUsage;
    ULONG PagefileUsage;
    ULONG PeakPagefileUsage;
    ULONG PrivatePageCount;
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef LONG NTSTATUS;

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation,
    SystemProcessorInformation,             // obsolete...delete
    SystemPerformanceInformation,
    SystemTimeOfDayInformation,
    SystemPathInformation,
    SystemProcessInformation,
    SystemCallCountInformation,
    SystemDeviceInformation,
    SystemProcessorPerformanceInformation,
    SystemFlagsInformation,
    SystemCallTimeInformation,
    SystemModuleInformation,
    SystemLocksInformation,
    SystemStackTraceInformation,
    SystemPagedPoolInformation,
    SystemNonPagedPoolInformation,
    SystemHandleInformation,
    SystemObjectInformation,
    SystemPageFileInformation,
    SystemVdmInstemulInformation,
    SystemVdmBopInformation,
    SystemFileCacheInformation,
    SystemPoolTagInformation,
    SystemInterruptInformation,
    SystemDpcBehaviorInformation,
    SystemFullMemoryInformation,
    SystemLoadGdiDriverInformation,
    SystemUnloadGdiDriverInformation,
    SystemTimeAdjustmentInformation,
    SystemSummaryMemoryInformation,
    SystemUnused1,
    SystemUnused2,
    SystemCrashDumpInformation,
    SystemExceptionInformation,
    SystemCrashDumpStateInformation,
    SystemKernelDebuggerInformation,
    SystemContextSwitchInformation,
    SystemRegistryQuotaInformation,
    SystemExtendServiceTableInformation,
    SystemPrioritySeperation,
    SystemUnused3,
    SystemUnused4,
    SystemUnused5,
    SystemUnused6,
    SystemCurrentTimeZoneInformation,
    SystemLookasideInformation,
    SystemTimeSlipNotification
} SYSTEM_INFORMATION_CLASS;

#define STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS)0xC0000004L)

typedef NTSTATUS (NTAPI * FN_NTQUERYSYSTEMINFORMATION)(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

//
//  Task list structure as returned by GetTaskList().
//

typedef struct _TASK_LISTA
{
    DWORD  dwProcessId;
    DWORD  dwParentProcessId;
    DWORD  dwPriority;
    DWORD  dwThreadCount;
    CHAR   ProcessName[MAX_PATH];

} TASK_LISTA, *PTASK_LISTA, FAR *LPTASK_LISTA;

typedef struct _TASK_LISTW
{
    DWORD  dwProcessId;
    DWORD  dwParentProcessId;
    DWORD  dwPriority;
    DWORD  dwThreadCount;
    WCHAR  ProcessName[MAX_PATH];

} TASK_LISTW, *PTASK_LISTW, FAR *LPTASK_LISTW;

#ifdef UNICODE
#define TASK_LIST   TASK_LISTW
#define LPTASK_LIST LPTASK_LISTW
#else
#define TASK_LIST   TASK_LISTA
#define LPTASK_LIST LPTASK_LISTA
#endif

#define CKMP_ALLOC(cb)           (VOID *)LocalAlloc( LPTR, (cb) )
#define CKMP_REALLOC(p,cb)       (VOID *)LocalReAlloc( (HLOCAL)p, (cb), LPTR )
#define CKMP_FREE(p)             LocalFree( (HLOCAL)(p) )

#define INITIAL_SIZE			65536
#define EXTEND_SIZE				32768

HLOCAL
GetLocalTaskListNt(
    LPDWORD pdwNumTasks
    )
{
    LPTASK_LISTW                pTaskListW;
    PSYSTEM_PROCESS_INFORMATION processInfo;
    PSYSTEM_PROCESS_INFORMATION processScan;
    NTSTATUS                    status;
    ULONG                       bufferSize;
    ULONG                       totalOffset;
    ULONG                       processCount;
    ULONG                       i;
	FN_NTQUERYSYSTEMINFORMATION _pfnNtQuerySystemInformation = NULL;
	HMODULE						hNtdll;

    hNtdll = GetModuleHandleA( "NTDLL.DLL" );
    if( hNtdll != NULL )
    {
        _pfnNtQuerySystemInformation = (FN_NTQUERYSYSTEMINFORMATION)
            GetProcAddress( hNtdll, "NtQuerySystemInformation" );
	}

    //
    // Bail if we couldn't find the entrypoint.
    //

    if( _pfnNtQuerySystemInformation == NULL ) {
        return NULL;
    }

    //
    // Read the process info.
    //

    bufferSize = INITIAL_SIZE;

retry:

    processInfo = CKMP_ALLOC( bufferSize );

    if( processInfo == NULL ) {
        return NULL;
    }

    status = _pfnNtQuerySystemInformation(
                 SystemProcessInformation,
                 processInfo,
                 bufferSize,
                 NULL
                 );

    if( status == STATUS_INFO_LENGTH_MISMATCH ) {
        CKMP_FREE( processInfo );
        bufferSize += EXTEND_SIZE;
        goto retry;
    }

    if( !NT_SUCCESS(status) ) {
        return NULL;
    }

    //
    // Count the number of active processes.
    //

    processCount = 0;
    totalOffset = 0;
    processScan = processInfo;

    for( ; ; ) {

        processCount++;

        if( processScan->NextEntryOffset == 0 ) {
            break;
        }

        totalOffset += processScan->NextEntryOffset;
        processScan = (PVOID)( (PCHAR)processInfo + totalOffset );

    }

    //
    // Now allocate the user's buffer.
    //

    pTaskListW = CKMP_ALLOC( processCount * sizeof(*pTaskListW) );

    if( pTaskListW == NULL ) {
        CKMP_FREE( processInfo );
        return NULL;
    }

    //
    // And map 'em over.
    //

    totalOffset = 0;
    processScan = processInfo;

    for( i = 0 ; i < processCount ; i++ ) {

        PWCHAR name;
        ULONG len;

        pTaskListW[i].dwProcessId = (DWORD)processScan->UniqueProcessId;
        pTaskListW[i].dwParentProcessId = (DWORD)processScan->InheritedFromUniqueProcessId;
        pTaskListW[i].dwPriority = (DWORD)processScan->BasePriority;
        pTaskListW[i].dwThreadCount = (DWORD)processScan->NumberOfThreads;

        if( processScan->ImageName.Buffer == NULL ) {

            name = L"Idle";
            len = sizeof( L"Idle" ) - sizeof(WCHAR);

        } else {

            name = processScan->ImageName.Buffer;
            len = processScan->ImageName.Length;

        }

        RtlCopyMemory(
            pTaskListW[i].ProcessName,
            name,
            len
            );

        pTaskListW[i].ProcessName[len / sizeof(WCHAR)] = L'\0';

        totalOffset += processScan->NextEntryOffset;
        processScan = (PVOID)( (PCHAR)processInfo + totalOffset );

    }

    //
    // Cleanup & we're outta here.
    //

    *pdwNumTasks = (DWORD)processCount;
    CKMP_FREE( processInfo );

    return (HLOCAL) pTaskListW;

}   // GetLocalTaskListNt

BOOL 
GetLocalTaskNameNt( 
	HLOCAL hTaskList, 
	DWORD dwItem,
	LPSTR lpszTaskName,
	DWORD cbMaxTaskName
	)
{
	LPTASK_LISTW pTaskListW = (LPTASK_LISTW) hTaskList;
	BOOL success;
	
	success = WideCharToMultiByte( CP_ACP, 0,
					pTaskListW[dwItem].ProcessName, -1,
					lpszTaskName, cbMaxTaskName, NULL, NULL );
	return success;
}


DWORD
GetLocalTaskProcessIdNt( 
	HLOCAL hTaskList, 
	DWORD dwItem
	)
{
	LPTASK_LISTW pTaskListW = (LPTASK_LISTW) hTaskList;
	
	return pTaskListW[dwItem]. dwProcessId;
}


void 
FreeLocalTaskListNt( 
	HLOCAL hTaskList 
	)
{
	CKMP_FREE( hTaskList );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\pwalker\pwalker.h ===
#pragma warning(disable:4057 4100 4201 4214 4514)
#define WIN32_LEAN_AND_MEAN
#define STRICT
#include <windows.h>
#include <commctrl.h>
#include <commdlg.h>
#include <windowsx.h>
#include <tlhelp32.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <stdio.h>
#pragma hdrstop

HLOCAL
GetLocalTaskListNt(
    LPDWORD pdwNumTasks
    );

BOOL 
GetLocalTaskNameNt( 
	HLOCAL hTaskList, 
	DWORD dwItem,
	LPSTR lpszTaskName,
	DWORD cbMaxTaskName
	);

DWORD
GetLocalTaskProcessIdNt( 
	HLOCAL hTaskList, 
	DWORD dwItem
	);

void 
FreeLocalTaskListNt( 
	HLOCAL hTaskList 
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\utility.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: Utility.h

Owner: t-BrianM

This file contains implementation of the utility functions.
===================================================================*/

#include "stdafx.h"
#include "MetaUtil.h"
#include "MUtilObj.h"

/*------------------------------------------------------------------
 * U t i l i t i e s
 */

/*===================================================================
Report Error

Sets up IErrorInfo.  Does a simple FormatMessage and returns the
correct HRESULT.  Ripped from a-georgr's stuff.

Parameters:
	hr		HRESULT to return to caller
	dwErr	Win32 error code to format message for

Returns:
	hr
===================================================================*/
HRESULT ReportError(HRESULT hr, DWORD dwErr)
{
    HLOCAL pMsgBuf = NULL;

    // If there's a message associated with this error, report that
    if (::FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, dwErr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &pMsgBuf, 0, NULL)
        > 0)
    {
        AtlReportError(CLSID_MetaUtil, (LPCTSTR) pMsgBuf,
                       IID_IMetaUtil, hr);
    }

    // TODO: add some error messages to the string resources and
    // return those, if FormatMessage doesn't return anything (not
    // all system errors have associated error messages).
    
    // Free the buffer, which was allocated by FormatMessage
    if (pMsgBuf != NULL)
        ::LocalFree(pMsgBuf);

    return hr;
}


// Report a Win32 error code
HRESULT ReportError(DWORD dwErr)
{
    return ::ReportError(HRESULT_FROM_WIN32(dwErr), dwErr);
}


// Report an HRESULT error
HRESULT ReportError(HRESULT hr)
{
    return ::ReportError(hr, (DWORD) hr);
}


/*===================================================================
Cannonize Key

Converts a key into cannonical form.  To do this it does the following:
	o Removes leading slashes
	o Converts back-slashes to forward-slashes
	CONSIDER: Resolve . and ..
	CONSIDER: Case conversion

Parameters:
	tszKey		[in, out] Key to cannonize

Returns:
	Nothing
===================================================================*/
LPTSTR CannonizeKey(LPTSTR tszKey) {
	LPTSTR tszSrc;
	LPTSTR tszDest;

	tszSrc = tszKey;
	tszDest = tszKey;

	// Remove leading slashes
	while ((*tszSrc == _T('/')) || (*tszSrc == _T('\\'))) {
		tszSrc++;
	}

	// Convert slashes
	while (*tszSrc) {
		if (*tszSrc == _T('\\')) {
			*tszDest = _T('/');
		}
		else {
			*tszDest = *tszSrc;
		}
		tszSrc++;
		tszDest++;
	}

	*tszDest = '\0';

	return tszKey;
}

/*===================================================================
Split Key

Splits a key path into parent and child parts.  For example:
tszKey =    "/LM/Root/Path1/Path2/Path3"
tszParent = "/LM/Root/Path1/Path2"
tszChild =  "Path3"

Parameters:
	tszKey		[in] Key to split
	tszParent	[out] Parent part of key (allocated for ADMINDATA_MAX_NAME_LEN)
	tszChild	[out] Child part of key (allocated for ADMINDATA_MAX_NAME_LEN)

Returns:
	Nothing
===================================================================*/
void SplitKey(LPCTSTR tszKey, LPTSTR tszParent, LPTSTR tszChild) {
	ASSERT_STRING(tszKey);
	ASSERT(IsValidAddress(tszParent,ADMINDATA_MAX_NAME_LEN * sizeof(TCHAR), TRUE));
	ASSERT(IsValidAddress(tszChild,ADMINDATA_MAX_NAME_LEN * sizeof(TCHAR), TRUE));

	LPTSTR tszWork;

	// Copy the key to the parent
	_tcscpy(tszParent, tszKey);

	// Find the end of the parent
	tszWork = tszParent;
	while (*tszWork != _T('\0')) {
		tszWork++;
	}

	// Find the start of the child
	while ( (tszWork != tszParent) && (*tszWork != _T('/')) ) {
		tszWork--;
	}

	// Cut off and copy the child
	if (*tszWork == _T('/')) {
		// Multiple parts
		*tszWork = _T('\0');
		tszWork++;
		_tcscpy(tszChild, tszWork);
	}
	else if (*tszWork != _T('\0')) {
		// One part
		_tcscpy(tszChild, tszWork);
		*tszWork = _T('\0');
	}
	else {
		// No parts
		tszChild[0] = _T('\0');
	}
}

/*===================================================================
Get Machine From Key

Gets the machine name part of a full key path.  Assumes that the machine
name is the first component of the path.  For example:
tszKey =     "/LM/Root/Path1/Path2/Path3"
tszMachine = "LM"

Parameters:
	tszKey		[in] Full Key to get machine name of
	tszMachine	[out] Machine name part of path (allocated for ADMINDATA_MAX_NAME_LEN)

Returns:
	Nothing
===================================================================*/
void GetMachineFromKey(LPCTSTR tszFullKey, LPTSTR tszMachine) {
	ASSERT_STRING(tszFullKey);
	ASSERT(IsValidAddress(tszMachine, ADMINDATA_MAX_NAME_LEN * sizeof(TCHAR), TRUE));

	int iSource;
	int iDest;

	iSource = 0;

	// Copy the machine name
	iDest = 0;
	while ((tszFullKey[iSource] != _T('/')) && 
		   (tszFullKey[iSource] != _T('\0'))) {

		tszMachine[iDest] = tszFullKey[iSource];

		iSource++;
		iDest++;
	}

	// Cap it off with NULL
	tszMachine[iDest] = _T('\0');
}

/*===================================================================
Key Is In Schema

Determines if a full key path is or is part of the schema.
For Example:

TRUE
"/Schema"
"/Schema/Properties"
"/Schema/Properties/Words"

FALSE
""
"/LM"
"/LM/ROOT/Schema"
"/LM/ROOT/Path/Schema"
"/LM/ROOT/Path1/Path2"

Parameters:
	tszKey		[in] Key to evaluate

Returns:
	TRUE if key is in the schema
===================================================================*/
BOOL KeyIsInSchema(LPCTSTR tszFullKey) {
	ASSERT_STRING(tszFullKey);

	LPTSTR tszWork;

	// Remove the const so I can play with the read pointer
	tszWork = const_cast <LPTSTR> (tszFullKey);

	// Skip the slash 
	if (*tszWork != _T('\0') && *tszWork == _T('/')) {
		tszWork++;
	}

	// Check for "schema\0" or "schema/"
	if ((_tcsicmp(tszWork, _T("schema")) == 0) ||
		(_tcsnicmp(tszWork, _T("schema/"), 7) == 0)) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}

/*===================================================================
Key Is In IISAdmin

Determines if a full key path is or is part of IISAdmin.
For Example:

TRUE
"/LM/IISAdmin"
"/SomeMachine/IISAdmin"
"/LM/IISAdmin/Extensions"
"/LM/IISAdmin/Extensions/DCOMCLSIDs"

FALSE
""
"/LM"
"/LM/ROOT/IISAdmin"
"/LM/ROOT/Path/IISAdmin"
"/LM/ROOT/Path1/Path2"

Parameters:
	tszKey		[in] Key to evaluate

Returns:
	TRUE if key is in IISAdmin
===================================================================*/
BOOL KeyIsInIISAdmin(LPCTSTR tszFullKey) {
	ASSERT_STRING(tszFullKey);

	LPTSTR tszWork;

	// Remove the const so I can play with the read pointer
	tszWork = const_cast <LPTSTR> (tszFullKey);

	// Skip leading slashes
	while (*tszWork == _T('/')) {
		tszWork++;
	}

	// Skip the machine name
	while ((*tszWork != _T('/')) && (*tszWork != _T('\0'))) {
		tszWork++;
	}

	// Skip the slash after the machine name
	if (*tszWork != '\0') {
		tszWork++;
	}

	// Check for "iisadmin\0" or "iisadmin/"
	if ((_tcsicmp(tszWork, _T("iisadmin")) == 0) ||
		(_tcsnicmp(tszWork, _T("iisadmin/"), 8) == 0)) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}


// 
// VariantResolveDispatch
//   Convert an IDispatch VARIANT to a (non-Dispatch) VARIANT by
//   invoking its default property until the object that remains
//   is not an IDispatch.  If the original VARIANT is not an IDispatch
//   then the behavior is identical to VariantCopyInd(), with the
//   exception that arrays are copied.
// 
// Parameters:
//   pVarOut       - if successful, the return value is placed here
//   pVarIn        - the variant to copy
//   GUID& riidObj - the calling interface (for error reporting)
//   nObjID        - the Object's name from the resource file
// 
//   pVarOut need not be initialized.  Since pVarOut is a new
//   variant, the caller must VariantClear this object.
// 
// Returns:
//   The result of calling IDispatch::Invoke.  (either NOERROR or
//   the error resulting from the call to Invoke)   may also return
//   E_OUTOFMEMORY if an allocation fails
// 
//   This function always calls Exception() if an error occurs -
//   this is because we need to call Exception() if an IDispatch
//   method raises an exception.  Instead of having the client
//   worry about whether we called Exception() on its behalf or
//   not, we always raise the exception.
// 

HRESULT
VariantResolveDispatch(
    VARIANT* pVarIn,
    VARIANT* pVarOut)
{
    ASSERT(pVarIn != NULL  &&  pVarOut != NULL);
    
    VariantInit(pVarOut);

    HRESULT hrCopy;
    
    if (V_VT(pVarIn) & VT_BYREF)
        hrCopy = VariantCopyInd(pVarOut, pVarIn);
    else
        hrCopy = VariantCopy(pVarOut, pVarIn);
    
    if (FAILED(hrCopy))
        return ::ReportError(hrCopy);
    
    // Follow the IDispatch chain.
    while (V_VT(pVarOut) == VT_DISPATCH)
    {
        VARIANT     varResolved;        // value of IDispatch::Invoke
        DISPPARAMS  dispParamsNoArgs = {NULL, NULL, 0, 0}; 
        EXCEPINFO   ExcepInfo;
        HRESULT     hrInvoke;
        
        // If the variant is equal to Nothing, then it can be argued
        // with certainty that it does not have a default property!
        // hence we return DISP_E_MEMBERNOTFOUND for this case.
        if (V_DISPATCH(pVarOut) == NULL)
            hrInvoke = DISP_E_MEMBERNOTFOUND;
        else
        {
            VariantInit(&varResolved);
            hrInvoke = V_DISPATCH(pVarOut)->Invoke(
                DISPID_VALUE,
                IID_NULL,
                LOCALE_SYSTEM_DEFAULT,
                DISPATCH_PROPERTYGET | DISPATCH_METHOD,
                &dispParamsNoArgs,
                &varResolved,
                &ExcepInfo,
                NULL);
        }
        
        if (FAILED(hrInvoke))
        {
            if (hrInvoke != DISP_E_EXCEPTION)
                hrInvoke = ::ReportError(hrInvoke);
            // for DISP_E_EXCEPTION, SetErrorInfo has already been called
            
            VariantClear(pVarOut);
            return hrInvoke;
        }
        
        // The correct code to restart the loop is:
        //
        //      VariantClear(pVar)
        //      VariantCopy(pVar, &varResolved);
        //      VariantClear(&varResolved);
        //
        // however, the same affect can be achieved by:
        //
        //      VariantClear(pVar)
        //      *pVar = varResolved;
        //      VariantInit(&varResolved)
        //
        // this avoids a copy.  The equivalence rests in the fact that
        // *pVar will contain the pointers of varResolved, after we
        // trash varResolved (WITHOUT releasing strings or dispatch
        // pointers), so the net ref count is unchanged. For strings,
        // there is still only one pointer to the string.
        //
        // NOTE: the next iteration of the loop will do the VariantInit.
        
        VariantClear(pVarOut);
        *pVarOut = varResolved;
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\pwalker\pwalker.c ===
#include "pwalker.h"
#pragma hdrstop

#include "resource.h"

#define DLG_MSG(hwnd, message, fn)    \
    case (message): return (BOOL) HANDLE_##message((hwnd), (wParam), (lParam), (fn))
#define WPPS WritePrivateProfileString
#define GPPI GetPrivateProfileInt
#define Clear(x) memset(&x, 0, sizeof(x))

#define DUMP_WINDOW_EXTRA 16

#define GET_DUMP_PROCESS(hwnd) (HANDLE) GetWindowLong(hwnd, 0)
#define GET_DUMP_START(hwnd) GetWindowLong(hwnd, 4)
#define GET_DUMP_END(hwnd) GetWindowLong(hwnd, 8)
#define GET_DUMP_OFFSET(hwnd) GetWindowLong(hwnd, 12)
#define GET_DUMP_CY(hwnd) GetWindowLong(hwnd, 16)

#define SET_DUMP_PROCESS(hwnd, x) SetWindowLong(hwnd, 0, (DWORD) x)
#define SET_DUMP_START(hwnd, x) SetWindowLong(hwnd, 4, x)
#define SET_DUMP_END(hwnd, x) SetWindowLong(hwnd, 8, x)
#define SET_DUMP_OFFSET(hwnd, x) SetWindowLong(hwnd, 12, x)
#define SET_DUMP_CY(hwnd, x) SetWindowLong(hwnd, 16, x)
#define IDC_STATUS 8888

// Type definitions for pointers to call tool help functions. 
typedef BOOL (WINAPI *MODULEWALK)(HANDLE hSnapshot, LPMODULEENTRY32 lpme); 
typedef BOOL (WINAPI *THREADWALK)(HANDLE hSnapshot, LPTHREADENTRY32 lpte); 
typedef BOOL (WINAPI *PROCESSWALK)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe); 
typedef HANDLE (WINAPI *CREATESNAPSHOT)(DWORD dwFlags, DWORD th32ProcessID);  

//
// global variables
//
static CREATESNAPSHOT pCreateToolhelp32Snapshot = NULL; 
static MODULEWALK  pModule32First  = NULL;
static MODULEWALK  pModule32Next   = NULL;
static PROCESSWALK pProcess32First = NULL;
static PROCESSWALK pProcess32Next  = NULL;
static THREADWALK  pThread32First  = NULL;
static THREADWALK  pThread32Next   = NULL;

static HINSTANCE ghInstance = NULL;
static HWND ghwndProcesses = NULL;
static HWND ghwndMemory = NULL;
static HWND ghwndStatus = NULL;
static HCURSOR ghWait = NULL;
static BOOL gfToolhelp = FALSE;
static HANDLE ghSnapshot = NULL;
static HANDLE ghTargetProcess = NULL;
static HWND ghwndDump = NULL;
static UINT um_dump = 0;
static DWORD gcyLine = 0;
static char gszIniFile[] = "pwalker.ini";
static char gszPreferences[] = "Preferences";
static char gszDialogX[] = "X";
static char gszDialogY[] = "Y";
static char gszDumpWindowClass[] = "Dump Window";
static char gszDumpX[] = "Dump X";
static char gszDumpY[] = "Dump Y";
static char gszDumpCX[] = "DumpCX";
static char gszDumpCY[] = "DumpCY";

//
// forward functions declarations
//
BOOL CALLBACK main_dlgproc( HWND, UINT, WPARAM, LPARAM );
void main_OnCommand( HWND, UINT, HWND, UINT );
LONG main_OnNotify( HWND, int, LPNMHDR );
BOOL main_OnInitDialog( HWND, HWND, LPARAM );
void main_OnClose( HWND );
void main_OnDestroy( HWND );
BOOL InitToolhelp32 ( void );
void WalkProcesses( void );
void WalkProcess( void );
void DumpProcessMemory( void );
LRESULT CALLBACK dump_wndproc( HWND, UINT, WPARAM, LPARAM );
int ListView_GetFocusItem( HWND );
DWORD ListView_GetItemData( HWND, int );
void __cdecl PrintStatus(LPCSTR, ...);
void SaveSnapshot( HWND );

//
// main 
//
int PASCAL 
WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR lpCmd, int nShow)
{
	//
	// init common controls and toolhelp
	//
	InitCommonControls( );
	gfToolhelp = InitToolhelp32( );
	um_dump = RegisterWindowMessage( "Dump!" );
	ghWait = LoadCursor( NULL, IDC_WAIT );

	{
		TEXTMETRIC tm;
		HDC hDC;
		HFONT hFont;

		hDC = CreateCompatibleDC( NULL );
		hFont = SelectFont( hDC, GetStockFont( ANSI_FIXED_FONT ) );
		GetTextMetrics( hDC, &tm );
		SelectFont( hDC, hFont );
		DeleteDC( hDC );
		gcyLine = tm.tmHeight;
	}

	
	//
	// store instance handle (we'll need it later)
	//
	ghInstance = hInstance;

	//
	// create main window (all initializations are inside WM_INITDIALOG)
	//
	DialogBox( hInstance, MAKEINTATOM( IDD_MAIN ), NULL, main_dlgproc );

	return 0;
}

//
// main dialog window proc
//
BOOL CALLBACK 
main_dlgproc( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam )
{
	switch( message ) {
		DLG_MSG( hwnd, WM_COMMAND, main_OnCommand );
		DLG_MSG( hwnd, WM_NOTIFY, main_OnNotify );
		DLG_MSG( hwnd, WM_INITDIALOG, main_OnInitDialog );
		DLG_MSG( hwnd, WM_CLOSE, main_OnClose );
		DLG_MSG( hwnd, WM_DESTROY, main_OnDestroy );
	}

	return FALSE;
}

void 
main_OnCommand( HWND hwnd, UINT id, HWND hCtl, UINT code)
{
	switch( id ) {
	case IDOK:
		if( GetFocus( ) == ghwndProcesses ) {
			WalkProcess( );
			break;
		}
		if( GetFocus( ) == ghwndMemory ) {
			DumpProcessMemory( );
		}
		break;
	case IDM_UPDATE:
		WalkProcesses( );
		break;
	case IDM_SAVE:
		SaveSnapshot( hwnd );
		break;
	case IDM_EXIT:
		PostMessage( hwnd, WM_CLOSE, 0, 0 );
		break;
	}
}

//
//
//
LONG
main_OnNotify( HWND hwnd, int id, LPNMHDR lpHdr )
{

	if( lpHdr->idFrom == IDC_PROCESSES && lpHdr->code == NM_CLICK ) {
		WalkProcess( );
	}

	if( lpHdr->idFrom == IDC_MEMORY && lpHdr->code == NM_CLICK ) {
		DumpProcessMemory( );
	}

	return 0;
}


//
// initialize dialog box
//
BOOL 
main_OnInitDialog( HWND hwnd, HWND hwndFocus, LPARAM lParam )
{
	HICON hIcon;
	RECT R, r, rStatus;
	int x, y, cx, cy;
	LV_COLUMN co;
	
	//
	//
	//
	hIcon = LoadIcon( ghInstance, MAKEINTATOM( IDI_MAIN ) );
	SendMessage( hwnd, WM_SETICON, ICON_BIG, (LPARAM) hIcon );

    // Create the status window.     
	ghwndStatus = CreateStatusWindow( 
		WS_VISIBLE | WS_CHILD | WS_BORDER, 
		" ", hwnd, IDC_STATUS );
	SendMessage( ghwndStatus, SB_SIMPLE, TRUE, 0 );
	GetWindowRect(ghwndStatus, &rStatus );

	//
	// position dialog
	//
	GetWindowRect( hwnd, &r );
	GetWindowRect( GetDesktopWindow( ), &R );
	x = R.left + ((R.right - R.left) - (r.right - r.left)) / 2;
	y = R.top + ((R.bottom - R.top) - (r.bottom - r.top)) / 2;
	x = GetPrivateProfileInt( gszPreferences, gszDialogX, x, gszIniFile);
	y = GetPrivateProfileInt( gszPreferences, gszDialogY, y, gszIniFile);
	cx = r.right - r.left;
	cy = r.bottom - r.top + (rStatus.bottom - rStatus.top);
	SetWindowPos( hwnd, NULL, x, y, cx, cy, SWP_NOZORDER);
	x = rStatus.left;
	y = rStatus.top + (rStatus.bottom - rStatus.top);
	SetWindowPos( ghwndStatus, 0, x, y, 0, 0, SWP_NOZORDER | SWP_NOSIZE );

	//
	// create columns in "Processes" list control
	//
	ghwndProcesses = GetDlgItem( hwnd, IDC_PROCESSES );
	SetWindowFont( ghwndProcesses, GetStockFont( ANSI_FIXED_FONT ), FALSE );
	Clear( co );
	co.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
	co.fmt = LVCFMT_LEFT;
	co.cx = 200;
	co.pszText = "Process";
	ListView_InsertColumn( ghwndProcesses, 0, &co );
	co.pszText = "Total Committed";
	co.cx = 200;
	ListView_InsertColumn( ghwndProcesses, 1, &co );

	ghwndMemory = GetDlgItem( hwnd, IDC_MEMORY );
	SetWindowFont( ghwndMemory, GetStockFont( ANSI_FIXED_FONT ), FALSE );

	co.cx = 100;
	co.fmt = LVCFMT_RIGHT;
	co.pszText = "Address";
	ListView_InsertColumn( ghwndMemory, 0, &co );

	co.pszText = "AllocBase";
	ListView_InsertColumn( ghwndMemory, 1, &co );

	co.pszText = "Size";
	ListView_InsertColumn( ghwndMemory, 2, &co );

	co.cx = 120;
	co.fmt = LVCFMT_LEFT;
	co.pszText = "Protection";
	ListView_InsertColumn( ghwndMemory, 3, &co );
	co.cx = 100;
	co.pszText = "Type";
	ListView_InsertColumn( ghwndMemory, 4, &co );

	FORWARD_WM_COMMAND( hwnd, IDM_UPDATE, 0, 0, PostMessage );
	SetFocus( ghwndProcesses );

	return TRUE;
}

//
// just end dialog
//
void
main_OnClose( HWND hwnd )
{
	EndDialog( hwnd, IDOK );
}

//
//	perform any dialog cleanup
//
void
main_OnDestroy( HWND hwnd )
{
	char buf[12];
	RECT r;

	if( IsWindow( ghwndDump ) ) {
		DestroyWindow( ghwndDump );
	}

	if( gfToolhelp && ghTargetProcess ) {
		CloseHandle( ghTargetProcess );
	}

	if( gfToolhelp && ghSnapshot ) {
		CloseHandle( ghSnapshot );
	}

	//
	// save dialog position
	//
	GetWindowRect( hwnd, &r );
	wsprintf( buf, "%d", r.left );
	WPPS( gszPreferences, gszDialogX, buf, gszIniFile );
	wsprintf( buf, "%d", r.top );
	WPPS( gszPreferences, gszDialogY, buf, gszIniFile );

}

// Function that initializes tool help functions. 
BOOL InitToolhelp32 (void) 
{ 
    BOOL   bRet  = FALSE;     
	HMODULE hKernel = NULL;  

    // Obtain the module handle of the kernel to retrieve addresses of 
    // the tool helper functions. 
    hKernel = GetModuleHandle("KERNEL32.DLL");      
	if (hKernel)    { 
        pCreateToolhelp32Snapshot = 
            (CREATESNAPSHOT)GetProcAddress(hKernel, 
            "CreateToolhelp32Snapshot");  
        pModule32First  = (MODULEWALK)GetProcAddress(hKernel, 
            "Module32First"); 
        pModule32Next   = (MODULEWALK)GetProcAddress(hKernel, 
            "Module32Next");  
        pProcess32First = (PROCESSWALK)GetProcAddress(hKernel, 
            "Process32First"); 
        pProcess32Next  = (PROCESSWALK)GetProcAddress(hKernel, 
            "Process32Next");  
        pThread32First  = (THREADWALK)GetProcAddress(hKernel, 
            "Thread32First"); 
        pThread32Next   = (THREADWALK)GetProcAddress(hKernel, 
            "Thread32Next");  
        // All addresses must be non-NULL to be successful. 
        // If one of these addresses is NULL, one of 
        // the needed lists cannot be walked. 
        bRet =  pModule32First && pModule32Next  && pProcess32First && 
                pProcess32Next && pThread32First && pThread32Next && 
                pCreateToolhelp32Snapshot;     
	} else {
        bRet = FALSE; // could not get the module handle of kernel  
	}
    return bRet; 
}  

void
WalkProcesses( void )
{
	LV_ITEM li;
	int item = 0;
	DWORD dwTasks;
	PROCESSENTRY32 pe;
	HLOCAL hTaskList;
	char *pszExename;
	HCURSOR hCursor = SetCursor( ghWait );

	Clear( pe );
	pe.dwSize = sizeof( pe );

	Clear( li );
	li.mask = LVIF_TEXT | LVIF_PARAM;

	ListView_DeleteAllItems( ghwndProcesses );
	ListView_DeleteAllItems( ghwndMemory );

	if( gfToolhelp ) {
		if( ghSnapshot ) {
			CloseHandle( ghSnapshot );
		}
		ghSnapshot = pCreateToolhelp32Snapshot( TH32CS_SNAPALL, 0 );
		if( !ghSnapshot ) {
			goto done;
		}
		if( pProcess32First( ghSnapshot, &pe ) ) {
			do {
				pszExename = strrchr( pe.szExeFile, '\\' );
				if( pszExename ) {
					pszExename++;
				}else{
					pszExename = pe.szExeFile;
				}
				li.pszText = pszExename;
				li.lParam = pe.th32ProcessID;
				ListView_InsertItem( ghwndProcesses, &li );
				li.iItem = item++;
			} while( pProcess32Next( ghSnapshot, &pe ) );
		}
	}else{

		hTaskList = GetLocalTaskListNt( &dwTasks );
		for( li.iItem = 0; li.iItem < (int) dwTasks; li.iItem++ ) {
	
			GetLocalTaskNameNt( hTaskList, li.iItem, 
				pe.szExeFile, sizeof( pe.szExeFile ) );
			pszExename = strrchr( pe.szExeFile, '\\' );
			if( pszExename ) {
				pszExename++;
			}else{
				pszExename = pe.szExeFile;
			}
			li.pszText = pszExename;
			li.lParam = GetLocalTaskProcessIdNt( hTaskList, li.iItem);
			ListView_InsertItem( ghwndProcesses, &li );
		}
		FreeLocalTaskListNt( hTaskList );
	}
done:
	SetFocus( ghwndProcesses );
	SetCursor( hCursor );
	return ;
}

void 
WalkProcess( void )
{
	MEMORY_BASIC_INFORMATION bi;
	VOID * lpAddress;
	LV_ITEM li;
	int item;
	char buf[32];
	DWORD dwProcess;
	HCURSOR hCursor = SetCursor( ghWait );

	item = ListView_GetFocusItem( ghwndProcesses );
	if( ghTargetProcess && gfToolhelp ) {
		CloseHandle( ghTargetProcess );
	}
	dwProcess = ListView_GetItemData( ghwndProcesses, item );
	__try {
		ghTargetProcess = OpenProcess( 
			PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, 
			FALSE, dwProcess );
	} __except( EXCEPTION_EXECUTE_HANDLER ) {
		PrintStatus( "Failure to open process %x (%d)", 
			dwProcess, GetLastError() );
	}

	SetWindowRedraw( ghwndMemory, FALSE );

	Clear( bi );
	Clear( li );
	lpAddress = NULL;

	ListView_DeleteAllItems( ghwndMemory );

	__try {

		while( VirtualQueryEx( ghTargetProcess, lpAddress, &bi, sizeof( bi ) ) ) {
			lpAddress = (PVOID)((DWORD) lpAddress + bi.RegionSize );
			if( bi.State != MEM_COMMIT ) {
				continue;
			}

			li.iSubItem = 0;
 			li.mask = LVIF_TEXT | LVIF_PARAM;
			wsprintf( buf, "%08x", bi.BaseAddress );
			li.pszText = buf;
			li.lParam = (DWORD) bi.BaseAddress;
			ListView_InsertItem( ghwndMemory, &li );

			li.iSubItem = 1;
 			li.mask = LVIF_TEXT;
			wsprintf( buf, "%08x", bi.AllocationBase );
			li.pszText = buf;
			ListView_SetItem( ghwndMemory, &li );

			li.iSubItem = 2;
			wsprintf( buf, "%d", bi.RegionSize );
			li.pszText = buf;
			ListView_SetItem( ghwndMemory, &li );

			li.iSubItem = 3;
			buf[0] = '\0';

			if( (bi.Protect & PAGE_NOACCESS) == PAGE_NOACCESS ) {
				strcat( buf, "NOACCESS " );
			}
			if( (bi.Protect & PAGE_READONLY) == PAGE_READONLY ) {
				strcat( buf, "RO " );
			}
			if( (bi.Protect & PAGE_READWRITE) == PAGE_READWRITE ) {
				strcat( buf, "RW " );
			}
			if( (bi.Protect & PAGE_WRITECOPY) == PAGE_WRITECOPY ) {
				strcat( buf, "WC " );
			}
			if( (bi.Protect & PAGE_EXECUTE) == PAGE_EXECUTE ) {
				strcat( buf, "X " );
			}
			if( (bi.Protect & PAGE_EXECUTE_READ) == PAGE_EXECUTE_READ ) {
				strcat( buf, "XR " );
			}
			if( (bi.Protect & PAGE_EXECUTE_READWRITE) == 
				PAGE_EXECUTE_READWRITE ) {
				strcat( buf, "XRW " );
			}
			if( (bi.Protect & PAGE_EXECUTE_WRITECOPY) == 
				PAGE_EXECUTE_WRITECOPY ) {
				strcat( buf, "XWC " );
			}
			if( (bi.Protect & PAGE_GUARD) == PAGE_GUARD ) {
				strcat( buf, "Guard " );
			}
			if( (bi.Protect & PAGE_NOCACHE) == PAGE_NOCACHE ) {
				strcat( buf, "Nc " );
			}

			li.pszText = buf;
			ListView_SetItem( ghwndMemory, &li );


			li.iSubItem = 4;
			switch( bi.Type ) {
			case MEM_IMAGE:
				li.pszText = "Image";
				break;
			case MEM_MAPPED:
				li.pszText = "Mapped";
				break;
			case MEM_PRIVATE:
				li.pszText = "Private";
				break;
			default:
				li.pszText = "Bogus";
				break;
			}
			ListView_SetItem( ghwndMemory, &li );

			li.iItem++;
		}
	} __except( EXCEPTION_EXECUTE_HANDLER ) {
		PrintStatus( "Failure in VirtualQueryEx (%d)", GetLastError() );
	}

	SetWindowRedraw( ghwndMemory, TRUE );
	InvalidateRect( ghwndMemory, NULL, TRUE );
	UpdateWindow( ghwndMemory );
	SetCursor( hCursor );
}

//
// 
//
void 
DumpProcessMemory( ) 
{
	WNDCLASS wc;
	int x,y,cx,cy;
	int item;
	DWORD dwAddress;
	HCURSOR hCursor = SetCursor( ghWait );

	item = ListView_GetFocusItem( ghwndMemory );
	dwAddress = ListView_GetItemData( ghwndMemory, item );

	if( !GetClassInfo( ghInstance, gszDumpWindowClass, &wc ) ) {
		Clear( wc );
		wc.hInstance = ghInstance;
		wc.lpfnWndProc = dump_wndproc;
		wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
		wc.hIcon = LoadIcon( ghInstance, MAKEINTATOM( IDI_DUMP ) );
		wc.hCursor = LoadCursor( NULL, IDC_ARROW );
		wc.cbWndExtra = DUMP_WINDOW_EXTRA;
		wc.lpszClassName = gszDumpWindowClass;

		if(!RegisterClass( &wc ) ) {
			PrintStatus( "Failure to register dump window class" );
			goto done;
		}
	}

	if( !IsWindow( ghwndDump ) ) {

		x = y = cx = cy = CW_USEDEFAULT;

		x = GPPI( gszPreferences, gszDumpX, x, gszIniFile );
		y = GPPI( gszPreferences, gszDumpY, y, gszIniFile );
		cx = GPPI( gszPreferences, gszDumpCX, cx, gszIniFile );
		cy = GPPI( gszPreferences, gszDumpCY, cy, gszIniFile );

		ghwndDump = CreateWindow( gszDumpWindowClass, "", 
			WS_OVERLAPPEDWINDOW | WS_VSCROLL,
			x, y, cx, cy, NULL, NULL, ghInstance, NULL );

		if( ghwndDump ) {
			SendMessage( ghwndDump, um_dump, 
			         (WPARAM) ghTargetProcess, (LPARAM) dwAddress );
			ShowWindow( ghwndDump, SW_SHOW );
			UpdateWindow( ghwndDump );
		}else{
			PrintStatus( "Error: %d", GetLastError() );
		}
	}else{
		SendMessage( ghwndDump, um_dump, 
			     (WPARAM) ghTargetProcess, (LPARAM) dwAddress );
	}
done:
	SetCursor( hCursor );
}

BOOL 
dump_OnCreate( HWND hwnd, LPCREATESTRUCT lpCreate )
{
	SetScrollRange( hwnd, SB_VERT, 0, 100, FALSE );
	SetScrollPos( hwnd, SB_VERT, 0, TRUE );
	return TRUE;
}

void
dump_OnDestroy( HWND hwnd )
{
	RECT r;
	char buf[32];


	GetWindowRect( hwnd, &r );
	wsprintf( buf, "%d", r.left );
	WPPS( gszPreferences, gszDumpX, buf, gszIniFile );
	wsprintf( buf, "%d", r.top );
	WPPS( gszPreferences, gszDumpY, buf, gszIniFile );
	wsprintf( buf, "%d", r.right - r.left );
	WPPS( gszPreferences, gszDumpCX, buf, gszIniFile );
	wsprintf( buf, "%d", r.bottom - r.top );
	WPPS( gszPreferences, gszDumpCY, buf, gszIniFile );

}

void
dump_OnPaint( HWND hwnd )
{
	PAINTSTRUCT ps;
	HFONT hFont;
	RECT r;
	int line, byte, nLines;
	char buf[1024];
	BYTE mem[18];
	char *p = buf;
	DWORD dwOffset = GET_DUMP_OFFSET( hwnd );
	DWORD dwEnd = GET_DUMP_END( hwnd );
	DWORD dwRead;
	HANDLE hProcess = GET_DUMP_PROCESS( hwnd );
	
	BeginPaint( hwnd, &ps );
	hFont = SelectFont( ps.hdc, GetStockObject( ANSI_FIXED_FONT ) );

	GetClientRect( hwnd, &r );
	nLines = (r.bottom - r.top) / gcyLine;

	for( line = 0; line < nLines; line++ ) {
		Clear( mem );

		__try {
			ReadProcessMemory( hProcess, (PVOID) dwOffset, mem, 16, &dwRead );
		} __except( EXCEPTION_EXECUTE_HANDLER ) {
			strcpy( mem, "????????????????");
		}

		wsprintf(buf, "%08x ", dwOffset);

		p = buf + 9;
		for(byte = 0; byte < 16; byte++ ) {
			wsprintf( p, "%02x  ", mem[byte] );
			p += (byte == 7) ? 4 : 3;
		}

		for( byte = 0; byte < 16; byte++ ) {
			if( mem[byte] >= ' ' ) {
				p[byte] = mem[byte]; 
			}else{
				p[byte] = ' ';
			}
		}
		p[16] = '\0';

		TextOut( ps.hdc, 0, line * gcyLine, buf, strlen( buf ) );

		dwOffset += 16;

		if( dwOffset > dwEnd) {
			break;
		}

	}


	SelectFont( ps.hdc, hFont );
	EndPaint( hwnd, &ps );
}

void 
dump_OnVScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos)
{
	DWORD dwOffset = GET_DUMP_OFFSET( hwnd );
	DWORD dwStart = GET_DUMP_START( hwnd );
	DWORD dwEnd = GET_DUMP_END( hwnd );
	RECT r, ri;
	DWORD cyLines, Line, maxLine, newLine;

	GetClientRect( hwnd, &r );
	r.bottom -= (r.bottom - r.top) % gcyLine;
	cyLines = (r.bottom - r.top) / gcyLine;

	Line = (dwOffset - dwStart ) / 16;
	maxLine = ( dwEnd - dwStart ) / 16 - cyLines;

	switch( code ) {
	case SB_TOP:
		newLine = 0;
		break;
	case SB_BOTTOM:
		newLine = maxLine;
		break;
	case SB_PAGEUP:
		newLine = max( Line - cyLines + 1, 0 );
		break;
	case SB_PAGEDOWN:
		newLine = min( Line + cyLines - 1, maxLine );
		break;
	case SB_LINEUP:
		newLine = max( 0, Line - 1 );
		break;
	case SB_LINEDOWN:
		newLine = min( Line + 1, maxLine );
		break;
	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		newLine = MulDiv( pos, maxLine, 100 );
		break;
	default:
		goto done;
	}

	SET_DUMP_OFFSET( hwnd, dwStart + newLine * 16 );

	pos = MulDiv(newLine, 100, maxLine );
	SetScrollPos( hwnd, SB_VERT, pos, TRUE );
	ScrollWindowEx( hwnd, 0, ( Line - newLine ) * gcyLine, 
		NULL, &r, NULL, &ri, SW_INVALIDATE );
	InvalidateRect( hwnd, &ri, TRUE );

done:
	UpdateWindow( hwnd );
}

void
dump_OnSize( HWND hwnd, int state, int cx, int cy )
{
	InvalidateRect( hwnd, NULL, TRUE );
	UpdateWindow( hwnd );
}

void
dump_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)
{
	switch( vk ) {
	case VK_DOWN:
		FORWARD_WM_VSCROLL( hwnd, NULL, SB_LINEDOWN, 0, PostMessage );
		break;
	case VK_UP:
		FORWARD_WM_VSCROLL( hwnd, NULL, SB_LINEUP, 0, PostMessage );
		break;

	case VK_PRIOR:
		FORWARD_WM_VSCROLL( hwnd, NULL, SB_PAGEUP, 0, PostMessage );
		break;
	case VK_NEXT:
	case ' ':
		FORWARD_WM_VSCROLL( hwnd, NULL, SB_PAGEDOWN, 0, PostMessage );
		break;

	case VK_HOME:
		FORWARD_WM_VSCROLL( hwnd, NULL, SB_TOP, 0, PostMessage );
		break;
	
	case VK_END:
		FORWARD_WM_VSCROLL( hwnd, NULL, SB_BOTTOM, 0, PostMessage );
		break;

	case VK_ESCAPE:
		PostMessage( hwnd, WM_CLOSE, 0, 0 );
		break;

	}
}

//
// dump window proc
//
LRESULT CALLBACK
dump_wndproc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam )
{
	switch( message ) {
		HANDLE_MSG( hwnd, WM_CREATE, dump_OnCreate );
		HANDLE_MSG( hwnd, WM_DESTROY, dump_OnDestroy );
		HANDLE_MSG( hwnd, WM_PAINT, dump_OnPaint );
		HANDLE_MSG( hwnd, WM_VSCROLL, dump_OnVScroll );
		HANDLE_MSG( hwnd, WM_SIZE, dump_OnSize );
		HANDLE_MSG( hwnd, WM_KEYDOWN, dump_OnKey );
	default:
		if( message == um_dump ) {
			char buf[80];
			MEMORY_BASIC_INFORMATION bi;
			HANDLE hProcess = (HANDLE) wParam;
			DWORD dwOffset = (DWORD) lParam;

			wsprintf( buf, "Process %x at %x", wParam, lParam );
			SetWindowText( hwnd, buf );
			SetScrollPos( hwnd, SB_VERT, 0, TRUE );
			InvalidateRect( hwnd, NULL, TRUE );

			Clear( bi );
			if(! VirtualQueryEx( hProcess, (PVOID) dwOffset, 
				                 &bi, sizeof( bi ) ) ) {
				PrintStatus( "Error: %d", GetLastError() );
			}
			SET_DUMP_PROCESS( hwnd, hProcess );
			SET_DUMP_START( hwnd, (DWORD) bi.BaseAddress );
			SET_DUMP_END( hwnd, (DWORD) bi.BaseAddress + bi.RegionSize );
			SET_DUMP_OFFSET( hwnd, (DWORD) bi.BaseAddress );
		}
	}

	return DefWindowProc( hwnd, message, wParam, lParam );
}

//
// returns the number of the item which has focus or -1
//
int ListView_GetFocusItem( HWND hwnd )
{
	int cItems = ListView_GetItemCount( hwnd );
	int item;

	for( item = 0; item < cItems; item++ ) {
		if( ListView_GetItemState( hwnd, item, LVIS_FOCUSED ) ) {
			return item;
		}
	}

	return -1;
}

//
// returns .lParam of the specified item or -1
//
DWORD ListView_GetItemData( HWND hwnd, int item)
{
	LV_ITEM li;

	if( item != -1 ) {
		Clear( li );
		li.mask = LVIF_PARAM;
		li.iItem = item;

		if( ListView_GetItem( hwnd, &li ) ) {
			return li.lParam;
		}
	}

	return (DWORD) -1;
}


//
// formats message to status bar
//
void __cdecl
PrintStatus(LPCSTR fmt, ...)
{
	char buf[4096];
	va_list marker;

	va_start( marker, fmt );
	wvsprintf( buf, fmt, marker );
	va_end( marker );

	SendMessage( ghwndStatus, SB_SETTEXT, 0, (LPARAM) buf );
}

//
//
//
void SaveSnapshot( HWND hwnd )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\pwalker\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDD_MAIN                        101
#define IDI_MAIN                        102
#define IDR_MAIN                        103
#define IDI_DUMP                        104
#define IDC_PROCESSES                   1000
#define IDC_MEMORY                      1001
#define IDM_UPDATE                      40001
#define IDM_SAVE                        40002
#define IDM_EXIT                        40004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40005
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\setkey\strings.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       strings.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-28-95   Johnl    Created
//
//----------------------------------------------------------------------------

#define IDS_BASE                       4000

#define IDS_BANNER1                    (IDS_BASE+1)
#define IDS_BANNER2                    (IDS_BASE+2)
#define IDS_BAD_FLAG                   (IDS_BASE+3)
#define IDS_BAD_ARG                    (IDS_BASE+4)
#define IDS_MISSING_ARG                (IDS_BASE+5)
#define IDS_FAILED_TO_SET              (IDS_BASE+6)
#define IDS_SUCCESSFUL_SET             (IDS_BASE+7)
#define IDS_SUCCESSFUL_SET_DEF         (IDS_BASE+8)

#define IDS_USAGE1                     (IDS_BASE+20)
#define IDS_USAGE2                     (IDS_BASE+21)
#define IDS_USAGE3                     (IDS_BASE+22)
#define IDS_USAGE4                     (IDS_BASE+23)
#define IDS_USAGE5                     (IDS_BASE+24)
#define IDS_USAGE6                     (IDS_BASE+25)
#define IDS_USAGE7                     (IDS_BASE+26)
#define IDS_USAGE8                     (IDS_BASE+27)
#define IDS_USAGE9                     (IDS_BASE+28)
#define IDS_USAGE10                    (IDS_BASE+29)
#define IDS_USAGE11                    (IDS_BASE+30)
#define IDS_USAGE12                    (IDS_BASE+31)
#define IDS_USAGE13                    (IDS_BASE+32)
#define IDS_USAGE14                    (IDS_BASE+33)
#define IDS_USAGE15                    (IDS_BASE+34)
#define IDS_USAGE16                    (IDS_BASE+35)
#define IDS_USAGE17                    (IDS_BASE+36)
#define IDS_USAGE18                    (IDS_BASE+37)
#define IDS_USAGE19                    (IDS_BASE+38)
#define IDS_USAGE20                    (IDS_BASE+39)

#define IDS_FILE_NOT_FOUND             (IDS_BASE+50)
#define IDS_KEYCHECK_FAILED            (IDS_BASE+51)
#define IDS_FAILED_OPENING_SERVER      (IDS_BASE+52)
#define IDS_SETSECRET_FAILED           (IDS_BASE+53)
#define IDS_BAD_PASSWORD               (IDS_BASE+54)
#define IDS_SECPKG_NOT_FOUND           (IDS_BASE+55)

#define IDS_NO_KEYS_INSTALLED          (IDS_BASE+70)
#define IDS_DELETE_SUCCESSFUL          (IDS_BASE+71)

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\setkey\setkey.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    httpfilt.cxx

Abstract:

    This module contains the code to create or set the HTTP PCT/SSL keys and
    password

Author:

    John Ludeman (johnl)   19-Oct-1995

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsecapi.h>

#include <windows.h>

#define SECURITY_WIN32
#include <sspi.h>
#include <spseal.h>
#include <issperr.h>
#include <sslsp.h>
#include <w3svc.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <io.h>
#include <strings.h>

//
// macros
//

#define IS_ARG(c)   ((c) == L'-' || (c) == L'/')

#define TO_UNICODE( pch, ach )  \
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, (pch), -1, (ach), sizeof((ach))/sizeof(WCHAR))

#define TO_ANSI( pch, ach )     \
    WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK, pch, -1, ach, sizeof(ach), 0, 0 )

//
//  Private constants.
//

//
//  Private types.
//

BOOL fUUDecode = TRUE;

//
//  Private prototypes.
//

DWORD
SetRegKeys(
    IN  LPWSTR        pszServer,
    IN  LPWSTR        pszPrivateKeyFile,
    IN  LPWSTR        pszCertificateFile,
    IN  LPWSTR        pszPassword,
    IN  LPWSTR        pszAddress
    );

BOOL
SetKeySecret(
    WCHAR * pszServer,
    WCHAR * pszFormat,
    WCHAR * pszAddress,
    VOID *  pvData,
    DWORD   cbData
    );

void usage();

VOID
uudecode_cert(
    char   * bufcoded,
    DWORD  * pcbDecoded
    );

VOID
printfids(
    DWORD ids,
    ...
    );

DWORD
DeleteAll(
    WCHAR * pszServer
    );

BOOL
TsGetSecretW(
    WCHAR *       pszSecretName,
    WCHAR * *     ppchValue
    );

//
//  Public functions.
//


int
__cdecl
main(
    int   argc,
    char * argv[]
    )
{
    DWORD  err;
    CHAR   buff[MAX_PATH+1];
    BOOL   fDeleteAll = FALSE;

    LPWSTR password = NULL;
    LPWSTR privatekey = NULL;
    LPWSTR cert = NULL;
    LPWSTR address = NULL;
    LPWSTR server = NULL;

    WCHAR  achpassword[MAX_PATH+1];
    WCHAR  achprivatekey[MAX_PATH+1];
    WCHAR  achcert[MAX_PATH+1];
    WCHAR  achaddress[MAX_PATH+1];
    WCHAR  achserver[MAX_PATH+1];


    printfids( IDS_BANNER1 );
    printfids( IDS_BANNER2 );

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {

            case 'u':
            case 'U':
                fUUDecode = FALSE;
                break;

            case 'd':
            case 'D':
                fDeleteAll = TRUE;
                break;

            default:
                printfids( IDS_BAD_FLAG, **argv );
                usage();

            }
        } else if ( !server && (*argv)[0] == L'\\' && (*argv)[1] == L'\\'
                    && !password ) {
            TO_UNICODE( (*argv) + 2, achserver );
            server = achserver;
        } else if (!password) {
            TO_UNICODE( *argv, achpassword );
            password = achpassword;
        } else if (!privatekey) {
            TO_UNICODE( *argv, achprivatekey );
            privatekey = achprivatekey;
        } else if (!cert) {
            TO_UNICODE( *argv, achcert );
            cert = achcert;
        } else if (!address) {
            TO_UNICODE( *argv, achaddress );
            address = achaddress;
        } else {
            printfids( IDS_BAD_ARG, *argv);
            usage();
        }
    }

    if ( fDeleteAll )
    {
        return DeleteAll( server );
    }

    //
    //  Address and server are optional
    //

    if (!(password && privatekey && cert)) {
        printfids( IDS_MISSING_ARG );
        usage();
    }

    if ( err = SetRegKeys( server, privatekey, cert, password, address ) )
    {
        printfids( IDS_FAILED_TO_SET );
    }
    else
    {
        if ( address )
        {
            TO_ANSI( address, buff );
            printfids( IDS_SUCCESSFUL_SET,
                       buff );
        }
        else
        {
            printfids( IDS_SUCCESSFUL_SET_DEF );
        }

    }

    return err;

}   // main

void usage()
{
    printfids( IDS_USAGE1 );
    printfids( IDS_USAGE2 );
    //printfids( IDS_USAGE3 );      // -p help
    printfids( IDS_USAGE4 );
    printfids( IDS_USAGE5 );
    printfids( IDS_USAGE6 );
    printfids( IDS_USAGE7 );
    printfids( IDS_USAGE8 );
    printfids( IDS_USAGE9 );
    printfids( IDS_USAGE10 );
    printfids( IDS_USAGE11 );
    printfids( IDS_USAGE12 );
    printfids( IDS_USAGE13 );
    //printfids( IDS_USAGE14 );     // -p help
    printfids( IDS_USAGE15 );
    printfids( IDS_USAGE16 );
    printfids( IDS_USAGE17 );
    printfids( IDS_USAGE18 );
    printfids( IDS_USAGE19 );
    printfids( IDS_USAGE20 );

    exit(1);
}


//+---------------------------------------------------------------------------
//
//  Function:   SetRegKeys
//
//  Synopsis:   This loads the data contained in two files, a private key
//              file, which contains the key, and a certificate file,
//              which contains the certificate of the public portion of the key.
//              These are loaded, then turned into a credential handle, then
//              set in the registry as secrets
//
//  Arguments:  [pszServer]          -- Server to create secrets, NULL for local
//              [pszPrivateKeyFile]  -- Unicode file name
//              [pszCertificateFile] -- Unicode file name
//              [pszPassword]        -- Unicode password
//              [pszAddress]         -- Unicode IP address for name or NULL
//
//  History:    9-27-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
SetRegKeys(
    IN  LPWSTR        pszServer,
    IN  LPWSTR        pszPrivateKeyFile,
    IN  LPWSTR        pszCertificateFile,
    IN  LPWSTR        pszPassword,
    IN  LPWSTR        pszAddress
    )
{
    HANDLE          hFile;
    SSL_CREDENTIAL_CERTIFICATE  creds;
    DWORD           cbRead;
    SECURITY_STATUS scRet = 0;
    TimeStamp       tsExpiry;
    CHAR            achPassword[MAX_PATH + 1];
    CredHandle      hCreds;
    DWORD           cch;
    CHAR            buff[MAX_PATH+1];

    //
    // Fetch data from files:
    //

    hFile = CreateFileW( pszPrivateKeyFile,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL
                         );

    if (hFile == INVALID_HANDLE_VALUE)
    {
        TO_ANSI( pszPrivateKeyFile, buff );

        printfids( IDS_FILE_NOT_FOUND,
                   GetLastError(),
                   buff );

        return GetLastError();
    }

    creds.cbPrivateKey = GetFileSize( hFile, NULL );

    if (creds.cbPrivateKey == (DWORD) -1 )
    {
        CloseHandle( hFile );
        return GetLastError();
    }

    creds.pPrivateKey = LocalAlloc( LMEM_FIXED, creds.cbPrivateKey );

    if ( !creds.pPrivateKey )
    {
        CloseHandle( hFile );
        return GetLastError();
    }

    if (! ReadFile( hFile,
                    creds.pPrivateKey,
                    creds.cbPrivateKey,
                    &cbRead,
                    NULL ) )
    {
        CloseHandle( hFile );

        LocalFree( creds.pPrivateKey );

        return GetLastError();
    }

    CloseHandle( hFile );

    //
    //  Only the certificate is UUencoded
    //

    hFile = CreateFileW( pszCertificateFile,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL );

    if (hFile == INVALID_HANDLE_VALUE)
    {
        TO_ANSI( pszCertificateFile, buff );
        printfids( IDS_FILE_NOT_FOUND,
                   GetLastError(),
                   buff );

        LocalFree( creds.pPrivateKey );
        return GetLastError();
    }

    creds.cbCertificate = GetFileSize( hFile, NULL );

    if (creds.cbCertificate == (DWORD) -1 )
    {
        CloseHandle( hFile );

        LocalFree( creds.pPrivateKey );

        return GetLastError();
    }

    creds.pCertificate = LocalAlloc( LMEM_FIXED, creds.cbCertificate + 1);

    if ( !creds.pCertificate )
    {
        CloseHandle( hFile );

        LocalFree( creds.pPrivateKey );

        return GetLastError();
    }

    if (! ReadFile( hFile,
                    creds.pCertificate,
                    creds.cbCertificate,
                    &cbRead,
                    NULL ) )
    {
        CloseHandle( hFile );

        LocalFree( creds.pPrivateKey );

        LocalFree( creds.pCertificate );

        return GetLastError();
    }

    CloseHandle( hFile );

    //
    //  Zero terminate so we can uudecode
    //

    ((BYTE *)creds.pCertificate)[cbRead] = '\0';

    if ( fUUDecode )
    {
        uudecode_cert( creds.pCertificate,
                       &creds.cbCertificate );
    }

    //
    // Whew!  Now that we have safely loaded the keys from disk, get a cred
    // handle based on the certificate/prv key combo
    //

    //
    //  BUGBUG - password field should be Unicode, do a quick conversion
    //  until structure is fixed
    //

    cch = TO_ANSI( pszPassword, achPassword );

    if ( !cch )
    {
        return GetLastError();
    }

    creds.pszPassword = achPassword;

    //
    //  Note we always do the credential check locally even if the server is
    //  remote.  This means the local machine must have the correct security
    //  provider package installed.
    //

#if 0
    if ( !pszServer )
    {
#endif
        scRet = AcquireCredentialsHandleW(  NULL,               // My name (ignored)
                                            SSLSP_NAME_W,       // Package
                                            SECPKG_CRED_INBOUND,// Use
                                            NULL,               // Logon Id (ign.)
                                            &creds,             // auth data
                                            NULL,               // dce-stuff
                                            NULL,               // dce-stuff
                                            &hCreds,            // Handle
                                            &tsExpiry );

        if ( FAILED(scRet) )
        {
            if ( scRet == SEC_E_NOT_OWNER )
            {
                printfids( IDS_BAD_PASSWORD );
            }
            else if ( scRet == SEC_E_SECPKG_NOT_FOUND )
            {
                printfids( IDS_SECPKG_NOT_FOUND );
            }
            else
            {
                printfids( IDS_KEYCHECK_FAILED,
                           scRet );
            }
        }
#if 0
    }
    else
    {
        printf("\nWarning! Bypassing credential check because target is remote\n");
    }
#endif

    //
    //  If we successfully acquired a credential handle, set the secrets
    //

    if ( !FAILED( scRet ))
    {
        if ( !pszServer )
        {
            FreeCredentialsHandle( &hCreds );
        }

        //
        //  Supply the default name if none was supplied
        //

        if ( !pszAddress )
            pszAddress = L"Default";

        //
        //  Set the secrets
        //

        if ( !SetKeySecret( pszServer,
                            L"W3_PUBLIC_KEY_%s",
                            pszAddress,
                            creds.pCertificate,
                            creds.cbCertificate ) ||
             !SetKeySecret( pszServer,
                            L"W3_PRIVATE_KEY_%s",
                            pszAddress,
                            creds.pPrivateKey,
                            creds.cbPrivateKey ) ||
             !SetKeySecret( pszServer,
                            L"W3_KEY_PASSWORD_%s",
                            pszAddress,
                            achPassword,
                            strlen( achPassword ) + 1) )
        {
            printfids( IDS_SETSECRET_FAILED,
                       GetLastError());

            scRet = (SECURITY_STATUS) GetLastError();
        }
        else
        {
            WCHAR InstalledKeys[16384];
            WCHAR * pchKeys;

            *InstalledKeys = L'\0';

            //
            //  Ok if this fails, it may not exist yet
            //

            if ( TsGetSecretW( W3_SSL_KEY_LIST_SECRET,
                               &pchKeys ))
            {
                wcscpy( InstalledKeys, pchKeys );
            }

            wcscat( InstalledKeys, pszAddress );
            wcscat( InstalledKeys, L"," );

#if DBG
            printf("New list: %S\n", InstalledKeys);
#endif

            if ( !SetKeySecret( pszServer,
                                L"W3_KEY_LIST",
                                pszAddress,
                                InstalledKeys,
                                (wcslen( InstalledKeys ) + 1) * sizeof(WCHAR)))
            {
#if DBG
                printf("Warning: failed to set key list data, error %d\n");
#endif
                scRet = (SECURITY_STATUS) GetLastError();
            }
        }
    }

    //
    // Zero out and free the key data memory, on success or fail
    //

    ZeroMemory( creds.pPrivateKey, creds.cbPrivateKey );
    ZeroMemory( creds.pCertificate, creds.cbCertificate );
    ZeroMemory( achPassword, cch );
    ZeroMemory( pszPassword, cch );

    LocalFree( creds.pPrivateKey );
    LocalFree( creds.pCertificate );

    //
    // Tell the caller about it.
    //

    return( scRet );

}

BOOL
SetKeySecret(
    WCHAR * pszServer,
    WCHAR * pszFormat,
    WCHAR * pszAddress,
    VOID *  pvData,
    DWORD   cbData
    )
{
    BOOL                  fResult;
    NTSTATUS              ntStatus;
    LSA_UNICODE_STRING    unicodeName;
    LSA_UNICODE_STRING    unicodeSecret;
    LSA_UNICODE_STRING    unicodeServer;
    LSA_HANDLE            hPolicy;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR                 achSecretName[MAX_PATH+1];
    CHAR                  buff[MAX_PATH+1];


    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    if ( pszServer )
    {
        unicodeServer.Buffer        = pszServer;
        unicodeServer.Length        = wcslen( pszServer ) * sizeof(WCHAR);
        unicodeServer.MaximumLength = unicodeServer.Length + sizeof(WCHAR);
    }

    ntStatus = LsaOpenPolicy( pszServer ? &unicodeServer : NULL,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
    {
        SetLastError( LsaNtStatusToWinError( ntStatus ) );

        TO_ANSI( pszServer, buff );

        printfids(IDS_FAILED_OPENING_SERVER,
                  buff,
                  GetLastError() );

        return FALSE;
    }

    //
    //  Build the secret name
    //

    wsprintfW( achSecretName,
               pszFormat,
               pszAddress );

    unicodeSecret.Buffer        = pvData;
    unicodeSecret.Length        = (USHORT) cbData;
    unicodeSecret.MaximumLength = (USHORT) cbData;

    unicodeName.Buffer        = achSecretName;
    unicodeName.Length        = wcslen( achSecretName ) * sizeof(WCHAR);
    unicodeName.MaximumLength = unicodeName.Length + sizeof(WCHAR);

    //
    //  Query the secret value.
    //

    ntStatus = LsaStorePrivateData( hPolicy,
                                    &unicodeName,
                                    pvData ? &unicodeSecret : NULL );

    fResult = NT_SUCCESS(ntStatus);

    //
    //  Cleanup & exit.
    //

    LsaClose( hPolicy );

    if ( !fResult )
        SetLastError( LsaNtStatusToWinError( ntStatus ));

    return fResult;

}   // SetKeySecret

VOID
printfids(
    DWORD ids,
    ...
    )
{
    CHAR szBuff[2048];
    CHAR szString[2048];
    va_list  argList;

    //
    //  Try and load the string
    //

    if ( !LoadString( GetModuleHandle( NULL ),
                      ids,
                      szString,
                      sizeof( szString ) ))
    {
        printf( "Error loading string ID %d\n",
                ids );

        return;
    }

    va_start( argList, ids );
    vsprintf( szBuff, szString, argList );
    va_end( argList );

    printf( szBuff );
}

const int pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

//
//  We have to squirt a record into the decoded stream
//

#define CERT_RECORD            13
#define CERT_SIZE_HIBYTE        2       //  Index into record of record size
#define CERT_SIZE_LOBYTE        3

unsigned char abCertHeader[] = {0x30, 0x82,           // Record
                                0x00, 0x00,           // Size of cert + buff
                                0x04, 0x0b, 0x63, 0x65,// Cert record data
                                0x72, 0x74, 0x69, 0x66,
                                0x69, 0x63, 0x61, 0x74,
                                0x65 };

VOID uudecode_cert(char   * bufcoded,
                   DWORD  * pcbDecoded )
{
    int nbytesdecoded;
    char *bufin = bufcoded;
    unsigned char *bufout = bufcoded;
    unsigned char *pbuf;
    int nprbytes;
    char * beginbuf = bufcoded;

    /* Strip leading whitespace. */

    while(*bufcoded==' ' ||
          *bufcoded == '\t' ||
          *bufcoded == '\r' ||
          *bufcoded == '\n' )
    {
          bufcoded++;
    }

    //
    //  If there is a beginning '---- ....' then skip the first line
    //

    if ( bufcoded[0] == '-' && bufcoded[1] == '-' )
    {
        bufin = strchr( bufcoded, '\n' );

        if ( bufin )
        {
            bufin++;
            bufcoded = bufin;
        }
        else
        {
            bufin = bufcoded;
        }
    }
    else
    {
        bufin = bufcoded;
    }

    //
    //  Strip all cr/lf from the block
    //

    pbuf = bufin;
    while ( *pbuf )
    {
        if ( *pbuf == '\r' || *pbuf == '\n' )
        {
            memmove( pbuf, pbuf+1, strlen( pbuf + 1) + 1 );
        }
        else
        {
            pbuf++;
        }
    }

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */

    while(pr2six[*(bufin++)] <= 63);
    nprbytes = bufin - bufcoded - 1;
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    bufin  = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    //
    //  Now we need to add a new wrapper sequence around the certificate
    //  indicating this is a certificate
    //

    memmove( beginbuf + sizeof(abCertHeader),
             beginbuf,
             nbytesdecoded );

    memcpy( beginbuf,
            abCertHeader,
            sizeof(abCertHeader) );

    //
    //  The beginning record size is the total number of bytes decoded plus
    //  the number of bytes in the certificate header
    //

    beginbuf[CERT_SIZE_HIBYTE] = (BYTE) (((USHORT)nbytesdecoded+CERT_RECORD) >> 8);
    beginbuf[CERT_SIZE_LOBYTE] = (BYTE) ((USHORT)nbytesdecoded+CERT_RECORD);

    nbytesdecoded += sizeof(abCertHeader);

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;
}

BOOL
TsGetSecretW(
    WCHAR *       pszSecretName,
    WCHAR * *     ppchValue
    )
/*++
    Description:

        Retrieves the specified unicode secret

        Note we're loose with the allocated buffer since we're a simple
        command line app.

    Arguments:

        pszSecretName - LSA Secret to retrieve
        ppchValue - Receives pointer to allocated buffer

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    NTSTATUS              ntStatus;
    LSA_UNICODE_STRING *  punicodePassword = NULL;
    LSA_UNICODE_STRING    unicodeSecret;
    LSA_HANDLE            hPolicy;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;


    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( NULL,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
    {
        SetLastError( LsaNtStatusToWinError( ntStatus ) );
        return FALSE;
    }

    unicodeSecret.Buffer        = pszSecretName;
    unicodeSecret.Length        = wcslen( pszSecretName ) * sizeof(WCHAR);
    unicodeSecret.MaximumLength = unicodeSecret.Length + sizeof(WCHAR);

    //
    //  Query the secret value.
    //

    ntStatus = LsaRetrievePrivateData( hPolicy,
                                       &unicodeSecret,
                                       &punicodePassword );

    if( NT_SUCCESS(ntStatus) )
    {
        *ppchValue = (WCHAR *) punicodePassword->Buffer;

        return TRUE;
    }

    return FALSE;

}   // TsGetSecretW

DWORD
DeleteAll(
    WCHAR * pszServer
    )
{
    WCHAR * pchKeys;
    WCHAR * pszAddress;

    if ( !TsGetSecretW( L"W3_KEY_LIST",
                        &pchKeys ))
    {
        printfids( IDS_NO_KEYS_INSTALLED );
        return NO_ERROR;
    }

#if DBG
    printf("Installed keys: %S\n", pchKeys);
#endif

    pszAddress = pchKeys;
    while ( pchKeys = wcschr( pchKeys, L',' ))
    {
        //
        //  Ignore empty segments
        //

        if ( *pszAddress != L',' )
        {
            *pchKeys = L'\0';

#if DBG
            printf("deleting %S\n", pszAddress );
#endif

            //
            //  Nuke the secrets
            //

            SetKeySecret( pszServer,
                          L"W3_PUBLIC_KEY_%s",
                          pszAddress,
                          NULL,
                          0 );
            SetKeySecret( pszServer,
                          L"W3_PRIVATE_KEY_%s",
                          pszAddress,
                          NULL,
                          0 );
            SetKeySecret( pszServer,
                          L"W3_KEY_PASSWORD_%s",
                          pszAddress,
                          NULL,
                          0 );
        }

        pchKeys++;
        pszAddress = pchKeys;
    }

    //
    //  Now delete the list key
    //


    if ( !SetKeySecret( pszServer,
                        L"W3_KEY_LIST",
                        L"",
                        NULL,
                        0 ))
    {
#if DBG
        printf("Warning: failed to set key list data, error %d\n");
#endif
        return GetLastError();
    }

    printfids( IDS_DELETE_SUCCESSFUL );

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\terrain\tools\metasnap\convert.h ===
//**************************************************************
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  convert.h
//  
//  Description: Conversion tables for metabase properties  
//				 corresponding to ADSI names
//
//  History: 15-July-98  Tamas Nemeth (t-tamasn)  Created.
//
//**************************************************************

#if !defined (__CONVERT_H)
#define __CONVERT_H 


#include <afx.h>
#include <tchar.h>
//*************************************************
// METABASE CONSTANT - ADSI PROPERTY NAME TABLE 
//*************************************************

struct tPropertyNameTable;
tPropertyNameTable gPropertyNameTable[];

struct tPropertyNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;

	static CString MapCodeToName(DWORD dwCode, tPropertyNameTable * PropertyNameTable=::gPropertyNameTable);
};


//************************************************
// PROPERTY PREDEFINED VALUES TABLE
//************************************************

struct tValueTable;
tValueTable gValueTable[];

struct tValueTable 
{
	enum {TYPE_EXCLUSIVE=1};
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwRelatedPropertyCode; // code of the Property this value can be used for
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static CString MapValueContentToString(DWORD dwValueContent, DWORD dwRelatedPropertyCode, tValueTable * ValueTable=::gValueTable);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\terrain\tools\ipperm\ipperm.cpp ===
//***********************************************************
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  metasnap.cpp
//  
//  Description: Metabase Snapshot utility tool main  
//
//  History: 15-July-98  Tamas Nemeth (t-tamasn)  Created.
//
//***********************************************************




#define INITGUID

#define E_UNKNOWN_ARG 0x10000
#define E_WRONG_NUMBER_ARGS 0x20000
#define E_NULL_PTR 0x30000

#define DEFAULT_MD_TIMEOUT 0x1000
#define DEFAULT_GETALL_BUFFER_SIZE 4096
//#define DBG_ASSERT(exp)
//# define DBG_ASSERT(exp)                         ((void)0) /* Do Nothing */

//#include "stdafx.h"
//#include "winsock.h"
//#undef dllexp
//#include "tcpdllp.hxx"
//#define  _RDNS_STANDALONE
//#include "afx.h"
#include <objbase.h>
#include <coguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <mbstring.h>

#include "iadmw.h"
#include "iiscnfg.h"
#include "uiutils.h"

//#include <pudebug.h>
//extern "C" DEBUG_PRINTS * g_pDebug = NULL;

//#undef dllexp
//#include "tcpdllp.hxx"
//#define  _RDNS_STANDALONE


enum ERROR_PARAMETER
{
	MACHINE_NAME,
	START_KEY_NAME,
};

struct _CMD_PARAMS
{
	LPWSTR szMachineName;
	LPWSTR szStartKey;
	BOOL bShowSecure; //
	DWORD dwErrParameter; // to determine which parameter is incorrect
};

typedef struct _CMD_PARAMS CMD_PARAMS;
//typedef CString* pCString;

// Global variables:

//DWORD* dwSortArray;
PBYTE pbGetAllBuffer;

// Function prototypes:

HRESULT PrintKeyRecursively(IMSAdminBase *pcAdmCom, WCHAR *lpwstrFullPath, CMD_PARAMS* pcpCommandStructure);
HRESULT PrintAllPropertiesAtKey (IMSAdminBase *pcAdmCom, METADATA_HANDLE hmdHandle, 
							                          CMD_PARAMS* pcpCommandStructure);
VOID    PrintProperty(METADATA_GETALL_RECORD & mdr, BOOL bShowSecure);
VOID    PrintDataTypeAndValue(METADATA_GETALL_RECORD *pmdgr, BOOL bShowSecure);

DWORD ParseCommands (int argc, char *argv[], CMD_PARAMS *pcpCommandStructure);
VOID DisplayHelp();


// new stuff
DWORD
AddAccessEntries(
    IN  ADDRESS_CHECK & ac,
    IN  BOOL fName,
    IN  BOOL fGrant,
    //OUT CObListPlus & oblAccessList,
    OUT DWORD & cEntries
    )
/*++

Routine Description:

    Add specific kind of addresses from the list to the oblist of
    access entries

Arguments:

    ADDRESS_CHECK & ac              : Address list input object
    BOOL fName                      : TRUE for names, FALSE for ip
    BOOL fGrant                     : TRUE for granted, FALSE for denied        
    CObListPlus & oblAccessList     : ObList to add access entries to
    int & cEntries                  : Returns the number of entries
    
Return Value:

    Error code

Notes:

    Sentinel entries (ip 0.0.0.0) are not added to the oblist, but
    are reflected in the cEntries return value

--*/
{
    DWORD i;
    DWORD dwFlags;

    if (fName)
    {
        //
        // Domain names
        //
        LPSTR lpName;

        cEntries = ac.GetNbName(fGrant);
		//printf("Number of names: %ld.\n",cEntries);
        for (i = 0L; i < cEntries; ++i)
        {
            if (ac.GetName(fGrant, i,  &lpName, &dwFlags))
            {
				if (fGrant)
					printf("\tGranted to %s.\n",lpName);
				else
					printf("\tDenied to %s.\n",lpName);
			/*CString strDomain(lpName);
                if (!(dwFlags & DNSLIST_FLAG_NOSUBDOMAIN))
                {
                    strDomain = _T("*.") + strDomain;
                }*/

                //oblAccessList.AddTail(new CIPAccessDescriptor(fGrant, strDomain));
            }
        }
    }
    else
    {
        //
        // IP Addresses
        //
        LPBYTE lpMask;
        LPBYTE lpAddr;
        cEntries = ac.GetNbAddr(fGrant);
		//printf("Number of addresses: %ld.\n",cEntries);
        for (i = 0L; i < cEntries; ++i)
        {
            if (ac.GetAddr(fGrant, i,  &dwFlags, &lpMask, &lpAddr))
            {
	 			if (lpAddr[0] != 0 || lpAddr[1] != 0 || lpAddr[2] !=0 || lpAddr[3] !=0)
				{

 					if (lpAddr[0] != 0 || lpAddr[1] != 0 || lpAddr[2] !=0 || lpAddr[3] !=0)
					if (fGrant)
						printf("\tGranted to %d",lpAddr[0]);
					else
						printf("\tDenied to %d",lpAddr[0]);

					for (int j = 1; j<4; j++)
						printf(".%d",lpAddr[j]);
					
 					if (lpMask[0] != 255 || lpMask[1] != 255 || lpMask[2] !=255 || lpMask[3] !=255)
					{
						printf(" (Mask: %d",lpMask[0]);					
						for (int j = 1; j<4; j++)
							printf(".%d",lpMask[j]);
						printf(")");
					}
					printf(".\n");
				}
				else 
					printf("\tDenied to everyone.\n");
            }
        }
    }

    return ERROR_SUCCESS;
}
DWORD
BuildIplOblistFromBlob(
    IN METADATA_GETALL_RECORD & mdgr
	//OUT CObListPlus & oblAccessList,
   // OUT BOOL & fGrantByDefault
    )
{
    //oblAccessList.RemoveAll();

    if (mdgr.dwMDDataLen == 0)
    {
        return ERROR_SUCCESS;
    }

    ADDRESS_CHECK ac;
    ac.BindCheckList(mdgr.pbMDData, mdgr.dwMDDataLen);

    DWORD cGrantAddr, cGrantName, cDenyAddr, cDenyName;

    //                   Name/IP Granted/Deny
    // ============================================================
    AddAccessEntries(ac, TRUE,   TRUE, cGrantName);
    AddAccessEntries(ac, FALSE,  TRUE, cGrantAddr);
    AddAccessEntries(ac, TRUE,   FALSE, cDenyName);
    AddAccessEntries(ac, FALSE,  FALSE, cDenyAddr);

    ac.UnbindCheckList();

//    fGrantByDefault = (cDenyAddr + cDenyName != 0L)
  //      || (cGrantAddr + cGrantName == 0L);

    return ERROR_SUCCESS;
}  




// end new



VOID __cdecl main (int argc, char *argv[])
{
	if (argc == 1)
	{
		DisplayHelp();
		return;
	}
	
	CMD_PARAMS pcpCommands;
	DWORD dwRetVal = ParseCommands (argc, argv, &pcpCommands);

	if (dwRetVal != ERROR_SUCCESS)
	{
		if (dwRetVal == E_OUTOFMEMORY)
			fprintf (stderr, "ERROR: Out of memory.");
		else if (dwRetVal == E_WRONG_NUMBER_ARGS)
			fprintf (stderr, "ERROR: Invalid number of arguments.");
		else if (dwRetVal == E_INVALIDARG)
		{
			fprintf (stderr, "ERROR: Invalid input value");
			switch (pcpCommands.dwErrParameter)
			{
				case (MACHINE_NAME):
					fputs (" for MachineName.", stderr);
					break;
				case (START_KEY_NAME):
					fputs (" for StartKey.", stderr);
					break;
				default:
					fputs (".", stderr);
					break;
			}
		}
		else 
			fprintf (stderr, "ERROR: Unknown error in processing arguments.");

		fputs(" Enter \"metasnap\" without arguments to display help.\n", stderr);
		return;
	}

	IMSAdminBase *pcAdmCom = NULL;   //interface pointer
	IClassFactory * pcsfFactory = NULL;
	COSERVERINFO csiMachineName;
	COSERVERINFO *pcsiParam = NULL;

	// Fill the structure for CoGetClassObject:
		csiMachineName.pAuthInfo = NULL;
		csiMachineName.dwReserved1 = 0;
		csiMachineName.dwReserved2 = 0;
		pcsiParam = &csiMachineName;
		csiMachineName.pwszName = pcpCommands.szMachineName;

	// Initialize COM:
    HRESULT hresError = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (FAILED(hresError))
	{
		fprintf (stderr, "ERROR: COM Initialization failed. Error: %d (%#x)\n", hresError, hresError);
        return;
	}

	hresError = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
							IID_IClassFactory, (void**) &pcsfFactory);

	if (FAILED(hresError)) 
	{
		switch (hresError)
		{
		case HRESULT_FROM_WIN32(REGDB_E_CLASSNOTREG): 
			fprintf(stderr, "ERROR: IIS Metabase does not exist.\n");
			break;
		case HRESULT_FROM_WIN32(E_ACCESSDENIED): 
			fprintf(stderr, "ERROR: Access to Metabase denied.\n");
			break;
		case HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE):  
			fprintf(stderr, "ERROR: The specified host is unavailable.\n");
			break;
 		default:
			fprintf (stderr, "ERROR: Couldn't get Metabase Object. Error: %d (%#x)\n", hresError, hresError);
			break;
		}
        return;
	}

	hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &pcAdmCom);

	if (FAILED(hresError)) 
	{
		switch (hresError)
		{
		case HRESULT_FROM_WIN32(RPC_S_SEC_PKG_ERROR):
			fprintf (stderr, "ERROR: A security-related error occurred.\n");
			break;
		case HRESULT_FROM_WIN32(E_OUTOFMEMORY):
			fprintf (stderr, "ERROR: There is not enough memory available.\n");
			break;
		default:
			fprintf (stderr, "ERROR: Couldn't create Metabase Instance. Error: %d (%#x)\n", hresError, hresError);
			break;
		}
		pcsfFactory->Release();
		return;
	}

	pcsfFactory->Release();

	METADATA_HANDLE hmdHandle;
	
	hresError = pcAdmCom->OpenKey (
								METADATA_MASTER_ROOT_HANDLE,
								pcpCommands.szStartKey,
								METADATA_PERMISSION_READ,
								DEFAULT_MD_TIMEOUT,
								&hmdHandle);

	if (FAILED(hresError)) 
	{
		switch (hresError)
		{
		case HRESULT_FROM_WIN32(ERROR_PATH_BUSY):
			fprintf (stderr, "ERROR: The specified key is already in use.\n"); 
			break;
		case HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
			fprintf (stderr, "ERROR: The specified key is not found.\n");
			break;
		default:
			fprintf (stderr, "ERROR: Couldn't open Metabase Key. Error: %d (%#x)\n", hresError, hresError);
			break;
		}
		pcAdmCom->Release();
		return; 
	}

	// Recurse and dump children
	printf("\nIP address and domain name access restrictions:\n");
	hresError = PrintKeyRecursively(pcAdmCom, pcpCommands.szStartKey, &pcpCommands);

	if (hresError != ERROR_SUCCESS)
	{
		switch (hresError)
		{
		case HRESULT_FROM_WIN32(ERROR_PATH_BUSY):
			fprintf (stderr, "ERROR: Could not open a key because it is already in use.\n"); 
			break;
		case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
			fprintf (stderr, "ERROR: There is not enough memory available.\n");
			break;
		default:
			fprintf (stderr, "ERROR: Failed dumping metabase. Error: %u (%#x)\n", hresError, hresError);
			break;
		}
	}

	pcAdmCom->CloseKey (hmdHandle);
	pcAdmCom->Release();

	if (hresError == ERROR_SUCCESS)
		fputs("Successfully printed IP Security information.\n", stderr);
}

DWORD ParseCommands (int argc, char *argv [], CMD_PARAMS *pcpCommandStructure)
{
	if (pcpCommandStructure == NULL) 
		return E_NULL_PTR;

	if ( argc > 3 )
		return E_WRONG_NUMBER_ARGS;

	// Set default values:
	pcpCommandStructure->szMachineName = (LPWSTR) HeapAlloc (GetProcessHeap(), 
											HEAP_ZERO_MEMORY, (9 + 1) * sizeof (WCHAR) );

	if (pcpCommandStructure->szMachineName == NULL)
		return E_OUTOFMEMORY;

	wcscpy(pcpCommandStructure->szMachineName,L"localhost");
	pcpCommandStructure->bShowSecure = FALSE;


	// Handle StartKey:
	DWORD dwStartKeyLen = _mbstrlen(argv[1]) + 3;
	pcpCommandStructure->szStartKey = (LPWSTR) HeapAlloc (GetProcessHeap(), 
									HEAP_ZERO_MEMORY, (dwStartKeyLen + 1) * sizeof (WCHAR));
	LPWSTR lpwstrTemp = (LPWSTR) HeapAlloc (GetProcessHeap(), 
									HEAP_ZERO_MEMORY, (dwStartKeyLen + 1) * sizeof (WCHAR));

//	_mbscpy(lpwstrTemp,"/LM");
//	wcscat(lpwstrTemp, argv[1]);
//	printf("%S\n",lpwstrTemp);
	//	wcscpy(pcpCommands.szStartKey, lpwstrTemp);

	if (pcpCommandStructure->szStartKey == NULL)
		return E_OUTOFMEMORY;

	DWORD dwResult = MultiByteToWideChar(
		CP_ACP,
		0,
		argv[1],
		dwStartKeyLen + 1,
		pcpCommandStructure->szStartKey,
		dwStartKeyLen + 1);

	if (dwResult == 0)
	{
		pcpCommandStructure->dwErrParameter = START_KEY_NAME;
		return E_INVALIDARG;
	}
	// Add /lm to StartKey:
	wcscpy(lpwstrTemp,L"/LM");
	wcscat(lpwstrTemp, pcpCommandStructure->szStartKey);
	wcscpy(pcpCommandStructure->szStartKey, lpwstrTemp);

	// Chop off trailing slashes:
	LPWSTR lpwchTemp = pcpCommandStructure->szStartKey;	
	for (DWORD i=0; i < dwStartKeyLen-1; i++)
		lpwchTemp++;

	if (!wcscmp(lpwchTemp, TEXT("/") ) || !wcscmp(lpwchTemp, TEXT("\\")) )
			*(lpwchTemp) = (WCHAR)'\0';

	// Look for MachineName:

	if ( argc > 2 && strcmp("-s",argv[2]))
	{
		DWORD dwMachineNameLen = _mbstrlen(argv[2]);
		pcpCommandStructure->szMachineName = (LPWSTR) HeapAlloc (GetProcessHeap(), 
									HEAP_ZERO_MEMORY, (dwMachineNameLen + 1) * sizeof (WCHAR) );

		if (pcpCommandStructure->szMachineName == NULL)
			return E_OUTOFMEMORY;

		dwResult = MultiByteToWideChar(
			CP_ACP,
			0,
			argv[2],
			dwMachineNameLen + 1,
			pcpCommandStructure->szMachineName,
			dwMachineNameLen + 1);

		if (dwResult == 0)
		{
			pcpCommandStructure->dwErrParameter = MACHINE_NAME;
			return E_INVALIDARG;
		}

		// Check for "-s" flag:
		if (argc == 4)
		{
			if ( !strcmp("-s",argv[3]) )
				pcpCommandStructure->bShowSecure = TRUE;
			else
				return E_INVALIDARG;
		}
	}
	else if (argc == 3 && !strcmp("-s",argv[2]))
			pcpCommandStructure->bShowSecure = TRUE;
	else if (argc > 2)
		return E_INVALIDARG;

	return ERROR_SUCCESS;
}


HRESULT PrintKeyRecursively(IMSAdminBase *pcAdmCom, WCHAR *lpwstrFullPath, CMD_PARAMS* pcpCommandStructure)
{
	METADATA_HANDLE hmdHandle;
	HRESULT hresError = pcAdmCom->OpenKey(
								METADATA_MASTER_ROOT_HANDLE,
								lpwstrFullPath,
								METADATA_PERMISSION_READ,
								DEFAULT_MD_TIMEOUT,
								&hmdHandle);

	if (hresError != ERROR_SUCCESS)
		return hresError;
   // Get all data into a buffer:

	DWORD dwNumDataEntries ;
	DWORD dwDataSetNumber;
	DWORD dwRequestBufferSize = DEFAULT_GETALL_BUFFER_SIZE;
	DWORD dwRequiredDataLen;

	  // Allocate a default buffer size
	pbGetAllBuffer = (PBYTE)HeapAlloc 
						(GetProcessHeap(),
						HEAP_ZERO_MEMORY,
						DEFAULT_GETALL_BUFFER_SIZE);

	if (pbGetAllBuffer == NULL)
		return HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);

	hresError = pcAdmCom -> GetAllData (
				hmdHandle,
				TEXT ("/"),
				0,
				0,
				0,
				&dwNumDataEntries,
				&dwDataSetNumber,
				dwRequestBufferSize,
				pbGetAllBuffer,
				&dwRequiredDataLen);


	if (hresError == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
	{
		// retry the GetAllData with the new buffer size

		dwRequestBufferSize = dwRequiredDataLen;
		pbGetAllBuffer = (PBYTE)HeapReAlloc 
									(GetProcessHeap(),
									0,
									pbGetAllBuffer,
									dwRequestBufferSize);

		if (!pbGetAllBuffer)
			return HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);

		hresError = pcAdmCom -> GetAllData (
				hmdHandle,
				TEXT ("/"),
				0,
				0,
				0,
				&dwNumDataEntries,
				&dwDataSetNumber,
				dwRequestBufferSize,
				pbGetAllBuffer,
				&dwRequiredDataLen);
	}

	if (hresError != ERROR_SUCCESS)
	{
		HeapFree (GetProcessHeap(), 0, pbGetAllBuffer);
		return hresError;
	}

	METADATA_GETALL_RECORD *pmdgr = NULL;
	
	for (DWORD dwIndex = 0; dwIndex < dwNumDataEntries; dwIndex ++)
	{
		pmdgr = &(((METADATA_GETALL_RECORD *) pbGetAllBuffer)[dwIndex]);
		pmdgr->pbMDData = pmdgr->dwMDDataOffset + pbGetAllBuffer;

		if (pmdgr->dwMDIdentifier == 6019 && pmdgr->dwMDDataType == BINARY_METADATA &&
			pmdgr->dwMDDataLen > 0)
		{
			printf("  [%S]\n",lpwstrFullPath);
		//	PrintProperty(*pmdgr, pcpCommandStructure->bShowSecure);
			
			BuildIplOblistFromBlob( *pmdgr);

		}
	}



	WCHAR *lpwstrTempPath = (WCHAR*) HeapAlloc 
									(GetProcessHeap(),
									HEAP_ZERO_MEMORY,
									METADATA_MAX_NAME_LEN * sizeof (WCHAR));

	if (lpwstrTempPath == NULL)
		return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

	// Find out number of the children:
	DWORD dwChildCount = 0;
	while (1)
	{
		hresError = pcAdmCom->EnumKeys (
								hmdHandle,
								TEXT("/"),
								lpwstrTempPath,
								dwChildCount);

		if (hresError != ERROR_SUCCESS)
			break;
		dwChildCount++;
	}

	if (dwChildCount == 0)
		return ERROR_SUCCESS;

	// Dynamically allocate arrays:
	LPWSTR * lpwstrChildPath = new LPWSTR[dwChildCount];
	DWORD * dwSortedIndex = new DWORD[dwChildCount];

	// Initialization:
	for (dwIndex = 0; dwIndex < dwChildCount; dwIndex++)
	{
		dwSortedIndex[dwIndex] = dwIndex;

		hresError = pcAdmCom->EnumKeys (
								hmdHandle,
								TEXT("/"),
								lpwstrTempPath,
								dwIndex);

		lpwstrChildPath[dwIndex] = (WCHAR*) HeapAlloc
									(GetProcessHeap(),
									HEAP_ZERO_MEMORY,
									(wcslen (lpwstrTempPath) + 1) * sizeof (WCHAR));

		if (lpwstrChildPath[dwIndex] == NULL)
		{
			hresError = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
			break;
		}
		else
			wcscpy(lpwstrChildPath[dwIndex], lpwstrTempPath);
	}

	if (hresError == ERROR_SUCCESS)
	{
		// Sort children lexicographically (here we assume that dwChildCount is small)
		if (dwChildCount > 1 )
		{
			 DWORD dwTemp;
			 for (DWORD i = 1; i < dwChildCount; i++)
				for (DWORD j=0; j < dwChildCount-i; j++)
				{
					if (wcscmp(lpwstrChildPath[dwSortedIndex[j]],lpwstrChildPath[dwSortedIndex[j+1]]) > 0)
					{
						dwTemp = dwSortedIndex[j+1];
						dwSortedIndex[j+1] = dwSortedIndex[j];
						dwSortedIndex[j] = dwTemp;
					}
				}
		}

		for (dwIndex = 0; dwIndex < dwChildCount; dwIndex++)
		{
			// create the full path name for the child:
			wsprintf(lpwstrTempPath,TEXT("%s/%s"),lpwstrFullPath,lpwstrChildPath[dwSortedIndex[dwIndex]]);
			HeapFree (GetProcessHeap(), 0, lpwstrChildPath[dwSortedIndex[dwIndex]]);
			hresError = PrintKeyRecursively (pcAdmCom, lpwstrTempPath, pcpCommandStructure);

			if (hresError != ERROR_SUCCESS)
				break;
		}
	}

	// Close keys, free memory and exit
	pcAdmCom->CloseKey(hmdHandle);
	delete lpwstrChildPath;
	delete dwSortedIndex;
	HeapFree (GetProcessHeap(), 0, lpwstrTempPath);

	return hresError;
}






VOID DisplayHelp()
{
	fprintf (stderr, "\n DESCRIPTION: Displays the IP address/domain name restictions.\n\n");
	fprintf (stderr, " FORMAT: ipperm <StartKey> <MachineName>\n\n");
	fprintf (stderr, "    <StartKey>   : metabase key to start at.\n");
	fprintf (stderr, "    <MachineName>: name of host (optional, default: localhost).\n\n");
	fprintf (stderr, " EXAMPLES: ipperm  /w3svc/1  t-tamasn2\n");
	fprintf (stderr, "           ipperm  /  >  dump.txt  (dump all to text)\n\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\terrain\tools\ipperm\uiutils.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rdns.hxx

Abstract:

    Reverse DNS service

Author:

    Philippe Choquier (phillich)    5-june-1996

--*/

#if !defined(_RDNS_INCLUDE)
#define _RDNS_INCLUDE

#include "windef.h"

//# include "string.hxx"

typedef LPVOID DNSARG;

typedef void (*DNSFUNC)( DNSARG, BOOL, LPSTR );

#define RDNS_REQUEST_TYPE_IP2DNS    0
#define RDNS_REQUEST_TYPE_DNS2IP    1

#define SIZEOF_IP_ADDRESS           4
/*
typedef struct _DNSFUNCDESC
{
    DWORD   dwRequestType;
    DNSFUNC pFunc;
} DNSFUNCDESC, *PDNSFUNCDESC;

extern BOOL InitRDns();
extern void TerminateRDns();

 
BOOL 
AsyncHostByAddr(
    PDNSFUNCDESC pFunc,    // will store DNS name, post dummy completion status
                    // if NULL ( or g_cMaxThreadLimit==0 ) then sync request
    DNSARG pArg,      // ptr to be passed to FUNC
    struct sockaddr *pHostAddr, 

    BOOL *pfSync,   // updated with TRUE if sync call
    LPSTR pName,
    DWORD dwMaxNameLen
    );

 
BOOL
AsyncAddrByHost(
    PDNSFUNCDESC pFunc,    // will store DNS name, post dummy completion status
                    // if NULL ( or g_cMaxThreadLimit==0 ) then sync request
    DNSARG pArg,      // ptr to be passed to FUNC
    struct sockaddr *pHostAddr,

    BOOL *pfSync,   // updated with TRUE if sync call
    LPSTR pName
    );


BOOL
FireUpNewThread(
    PDNSFUNCDESC pFunc,
    DNSARG pArg,
    LPVOID pOvr
    );

#define XAR_GRAIN   256

//
// extensible array class
//
*/
class XAR {
public:
    XAR() { m_fDidAlloc = FALSE; m_pAlloc = NULL; m_cAlloc = m_cUsed = 0; }
    ~XAR() { }
    //~XAR() { if ( m_fDidAlloc ) LocalFree( m_pAlloc ); }

    BOOL Init( LPBYTE p=NULL, DWORD c=0) { m_fDidAlloc = FALSE; m_pAlloc = p; m_cAlloc = m_cUsed = c; return TRUE; }
    VOID Terminate() 
        { 
          /*  if ( m_fDidAlloc ) 
            {
                LocalFree( m_pAlloc ); 
            }*/
            m_fDidAlloc = FALSE; 
            m_pAlloc = NULL; 
            m_cAlloc = m_cUsed = 0; 
        }
    BOOL Resize( DWORD dwDelta );
    DWORD GetUsed() { return m_cUsed; }
    VOID SetUsed( DWORD c ) { m_cUsed = c; }
    VOID AdjustUsed( int c ) { m_cUsed += (DWORD)c; }
    LPBYTE GetAlloc() { return m_pAlloc; }

private:
    LPBYTE m_pAlloc;
    DWORD  m_cAlloc;
    DWORD  m_cUsed;
    BOOL   m_fDidAlloc;
} ;
/*
//
// This type defines a relocatable index inside a dynamic array.
// to allow easy fixups when part of the array is to be extended/shrinked
// index are identified by setting bit 31 to 1. Other DWORD in the reference
// part of the array are assumed to have bit 31 set to 0.
// The size of the reference part of the array is defined by cRefSize
//
*/
typedef DWORD SELFREFINDEX;

// combine array base address with SELFREFINDEX
#define MAKEPTR(a,b)    ((LPBYTE)(a)+((b)&0x7fffffff))
// build a SELFREFINDEX from an offset in array
#define MAKEREF(a)      ((a)|0x80000000)
// build an offset from a SELFREFINDEX
#define MAKEOFFSET(a)   ((a)&0x7fffffff)

//
// ADDRESS_CHECK_LIST Flags. bit31 must not be used.
//

#define RDNS_FLAG_DODNS2IPCHECK     0x00000001

// uses non-standard extension : zero-sized array in struct
#pragma warning(disable:4200)

// array header

typedef struct _ADDRESS_CHECK_LIST {
    SELFREFINDEX    iDenyAddr;      // address deny list
                                    // points to ADDRESS_HEADER
    SELFREFINDEX    iGrantAddr;     // address grant list
                                    // points to ADDRESS_HEADER
    SELFREFINDEX    iDenyName;      // DNS name deny list
                                    // points to NAME_HEADER
    SELFREFINDEX    iGrantName;     // DNS name grant list
                                    // points to NAME_HEADER
    DWORD           dwFlags;
    DWORD           cRefSize;       // size of reference area ( in bytes )
} ADDRESS_CHECK_LIST, *PADDRESS_CHECK_LIST;

typedef struct _ADDRESS_LIST_ENTRY {
    DWORD           iFamily;
    DWORD           cAddresses;
    DWORD           cFullBytes;
    DWORD           LastByte;
    SELFREFINDEX    iFirstAddress;  // points to array of addresses
                                    // which size are derived from iFamily
} ADDRESS_LIST_ENTRY, *PADDRESS_LIST_ENTRY;

typedef struct _ADDRESS_HEADER {
    DWORD               cEntries;   // # of Entries[]
    DWORD               cAddresses; // total # of addresses in all 
                                    // ADDRESS_LIST_ENTRY
    ADDRESS_LIST_ENTRY  Entries[];
} ADDRESS_HEADER, *PADDRESS_HEADER ;

typedef struct _NAME_LIST_ENTRY {
    DWORD           cComponents;    // # of DNS components
    DWORD           cNames;         
    SELFREFINDEX    iName[];        // array of references to DNS names
} NAME_LIST_ENTRY, *PNAME_LIST_ENTRY;

typedef struct _NAME_HEADER {
    DWORD           cEntries;
    DWORD           cNames;         // total # of names for all Entries[]
    //NAME_LIST_ENTRY Entries[0];   // array of name classes
} NAME_HEADER, *PNAME_HEADER ;
/*
typedef struct ADDRCMPDESC {
    LPBYTE  pMask;
    UINT    cFullBytes;
    UINT    LastByte;
    UINT    cSizeAddress;
} ADDRCMPDESC, *PADDRCMPDESC;

typedef struct NAMECMPDESC {
    LPVOID  pName;
    LPBYTE  pBase;
} NAMECMPDESC, *PNAMECMPDESC;


typedef LPVOID ADDRCHECKARG;
typedef void (*ADDRCHECKFUNC)(ADDRCHECKARG, BOOL );
typedef void (*ADDRCHECKFUNCEX)(ADDRCHECKARG, BOOL, LPSTR );

typedef int (__cdecl *CMPFUNC)(const void*, const void*, LPVOID);

#define SIZE_FAST_REVERSE_DNS   128
*/
enum AC_RESULT {
    AC_NOT_CHECKED,
    AC_IN_DENY_LIST,
    AC_NOT_IN_DENY_LIST,    // deny list present but not in deny list
    AC_IN_GRANT_LIST,
    AC_NOT_IN_GRANT_LIST,   // grant list present but not in grant list
    AC_NO_LIST
} ;

#define DNSLIST_FLAG_NOSUBDOMAIN        0x80000000
#define DNSLIST_FLAGS                   0x80000000  // bitmask of all flags

class ADDRESS_CHECK {
public:
      ADDRESS_CHECK() {}
      ~ADDRESS_CHECK() {}
    //
      BOOL BindCheckList( LPBYTE p = NULL, DWORD c = 0 );
      VOID UnbindCheckList() { m_Storage.Terminate(); }
 /*     BOOL BindAddr( struct sockaddr* pAddr )
    {
        m_pAddr = pAddr;
        m_fDnsResolved = FALSE;
	m_fIpResolved = FALSE;
	m_dwErrorResolving = 0;
        m_strDnsName.Reset();
        
        return TRUE;
    }

      VOID UnbindAddr()
    {
        m_pAddr = NULL;
        m_strDnsName.Reset();
        m_fDnsResolved = FALSE;
    }

      XAR* GetStorage() { return &m_Storage; }
      AC_RESULT CheckAccess(
        LPBOOL           pfSync,
        ADDRCHECKFUNC    pFunc,
        ADDRCHECKARG     pArg
        );

    //
    void AdjustRefs( LPBYTE, DWORD dwCut, DWORD dwAdj );

*/    //
    UINT GetAddrSize( DWORD );
  //  VOID MakeAcd( PADDRCMPDESC pacd, LPBYTE pMask, UINT cLen );

    // for UI, addr
  //    BOOL AddAddr( BOOL fGrant, DWORD dwFamily, LPBYTE pMask, LPBYTE pAddr );
    //  BOOL DeleteAddr( BOOL fGrant, DWORD iIndex );
      BOOL GetAddr( BOOL fGrant, DWORD iIndex, LPDWORD pdwFamily, LPBYTE* pMask, LPBYTE* pAddr );
      DWORD GetNbAddr( BOOL fGrant );
    BOOL LocateAddr( BOOL fGrant, DWORD iIndex, PADDRESS_HEADER* ppHd, PADDRESS_LIST_ENTRY* pHeader, LPDWORD iIndexInHeader );
     // BOOL DeleteAllAddr( BOOL fGrant );
    //  BOOL SetFlag( DWORD dwFlag, BOOL fEnable );
    //  DWORD GetFlags();

    // test all mask for this family, do bsearch on each
   // BOOL IsMatchAddr( BOOL fGrant, DWORD dwFamily, LPBYTE pAddr );

 /*   AC_RESULT CheckAddress(
        struct sockaddr* pAddr
        );

      BOOL QueryDnsName( 
        LPBOOL           pfSync,
        ADDRCHECKFUNCEX  pFunc,
        ADDRCHECKARG     pArg,
        LPSTR *          ppName
        );
      AC_RESULT CheckIpAccess( LPBOOL pfNeedDns);
      AC_RESULT CheckDnsAccess()
        { return CheckName( m_strDnsName.QueryStr() ); }

      BOOL IsDnsResolved()
        { return m_fDnsResolved; }
      LPSTR QueryResolvedDnsName()
        { return m_strDnsName.QueryStr(); }
      DWORD QueryErrorResolving()
        { return m_dwErrorResolving; }
*/
    // for UI, name
  //    BOOL AddName( BOOL fGrant, LPSTR pName, DWORD dwFlags = 0 );
   // BOOL AddReversedName( BOOL fGrant, LPSTR pName );
     // BOOL DeleteName( BOOL fGrant, DWORD iIndex );
      BOOL GetName( BOOL fGrant, DWORD iIndex,  LPSTR* ppName, LPDWORD pdwFlags = NULL );
   // BOOL GetReversedName( BOOL fGrant, DWORD iIndex, LPSTR pName, LPDWORD pdwSize );
      DWORD GetNbName( BOOL fGrant );
    BOOL LocateName( BOOL fGrant, DWORD iIndex, PNAME_HEADER* ppHd, PNAME_LIST_ENTRY* pHeader, LPDWORD iIndexInHeader );
    //  BOOL DeleteAllName( BOOL fGrant );
     // DWORD QueryCheckListSize() { return m_Storage.GetUsed(); }
     // LPBYTE QueryCheckListPtr() { return m_Storage.GetAlloc(); }
    //UINT GetNbComponent( LPSTR pName );

    // test all classes, do bsearch on each
 /*   BOOL IsMatchName( BOOL fGrant, LPSTR pName );

    BOOL CheckReversedName( LPSTR pName );  // synchronous version
      AC_RESULT CheckName( LPSTR pName );     // synchronous version
    LPSTR InitReverse( LPSTR pR, LPSTR pTarget, LPBOOL pfAlloc );
    VOID TerminateReverse( LPSTR, BOOL );

    VOID AddrCheckDnsCallBack(
        BOOL    fSt,
        LPSTR   pDns
        );
    VOID AddrCheckDnsCallBack2(
        BOOL                fSt,
        struct sockaddr*    pAddr
        );
    VOID AddrCheckDnsCallBack3(
        BOOL                fSt,
        struct sockaddr*    pAddr
        );
    VOID ResolveDnsCallBack(
        BOOL    fSt,
        LPSTR   pDns
        );

#if DBG
    VOID DumpAddrAndName( VOID );
    VOID DumpAddr( BOOL );
    VOID DumpName( BOOL );
#endif
*/
private:
    XAR                 m_Storage;
   // struct  sockaddr *  m_pAddr;
   // struct  sockaddr    m_ResolvedAddr;
   // STR                 m_strDnsName;
    BOOL                m_fDnsResolved;
    BOOL                m_fIpResolved;
    DWORD               m_dwErrorResolving;
//    ADDRCHECKFUNC       m_HttpReqCallback;
  //  ADDRCHECKFUNCEX     m_HttpReqCallbackEx;
    //ADDRCHECKARG        m_HttpReqParam;
} ;

/*
typedef struct _SID_CACHE_ENTRY
{
    DWORD   tExpire;   // now + TTL
    DWORD   dwSidLen;
    BYTE    Sid[0];
} SID_CACHE_ENTRY, *PSID_CACHE_ENTRY;


class CSidCache
{
public:
    CSidCache() {}
    ~CSidCache() {}
    //
    BOOL Init();
    VOID Terminate();
    //
      BOOL AddToCache( PSID, DWORD dwTTL );   // TTL in seconds
      BOOL IsInCache( PSID );
      BOOL CheckPresentAndResetTtl( PSID, DWORD );
    //
    BOOL Scavenger();

private:
    XAR  xaStore;   // buffer of SID_CACHE_ENTRY
    CRITICAL_SECTION    csLock;
} ;

//
// PEN : Password Expiration Notification API
//

extern CSidCache g_scPen;

  BOOL PenAddToCache( PSID, DWORD  );
  BOOL PenIsInCache( PSID );
  BOOL PenCheckPresentAndResetTtl( PSID, DWORD );
#define PenInit g_scPen.Init
#define PenTerminate g_scPen.Terminate
#define PenScavenger g_scPen.Scavenger
#define PEN_TTL (10*60)     // in seconds

#if DBG
extern VOID TestAPI();
#endif

#if defined(_RDNS_STANDALONE)

typedef
VOID
(* PFN_SCHED_CALLBACK)(
    VOID * pContext
    );

 
DWORD
ScheduleWorkItem(
    PFN_SCHED_CALLBACK pfnCallback,
    PVOID              pContext,
    DWORD              msecTimeInterval,
    BOOL               fPeriodic = FALSE
    )
{
    return 0;
}

 
BOOL
RemoveWorkItem(
    DWORD  pdwCookie
    )
{
    return FALSE;
}

#endif
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\terrain\tools\ipperm\uiutils.cpp ===
#include "uiutils.h"

BOOL
ADDRESS_CHECK::LocateName(
    BOOL fGrant,
    DWORD iIndex,
    PNAME_HEADER* ppHd,
    PNAME_LIST_ENTRY* pHeader,
    LPDWORD piIndexInHeader
    )
/*++

Routine Description:

    Locate a name in the specified list, returns ptr
    to header & element in address list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index in list ( 0-based )
    ppHd - updated with ptr to name header
    pHeader - updated with ptr to name list entry
    piIndexInHeader - updated with index in array pHeader->iName

Return Value:

    TRUE if iIndex valid in array defined by fGrant, FALSE otherwise

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PNAME_HEADER        pHd;
    PNAME_LIST_ENTRY    pE;
    UINT                iL;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        *ppHd = pHd   = (PNAME_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantName : pList->iDenyName);
        pE = (PNAME_LIST_ENTRY)((LPBYTE)pHd + sizeof(NAME_HEADER));
        for ( iL = 0 ; iL < pHd->cEntries ; ++iL )
        {
            if ( iIndex < pE->cNames )
            {
                *pHeader = pE;
                *piIndexInHeader = iIndex;
                return TRUE;
            }
            iIndex -= pE->cNames;
            pE = (PNAME_LIST_ENTRY)((LPBYTE)pE + sizeof(NAME_LIST_ENTRY) + pE->cNames * sizeof(SELFREFINDEX));
        }
    }

    return FALSE;
}



//inline
DWORD
ADDRESS_CHECK::GetNbAddr(
    BOOL fGrant
    )
/*++

Routine Description:

    Get number of entries in list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list

Return Value:

    Number of entries in list

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PADDRESS_HEADER     pHd;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        pHd   = (PADDRESS_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantAddr : pList->iDenyAddr);
        return pHd->cAddresses;
    }

    return 0;
}


BOOL
ADDRESS_CHECK::BindCheckList(
    LPBYTE p,
    DWORD c
    )
/*++

Routine Description:

    Bind a check list ( presented as a BLOB ) to an
    ADDRESS_CHECK object

Arguments:

    p - ptr to BLOB
    c - size of BLOB

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    PADDRESS_CHECK_LIST pList;
    UINT                l;

  /*  if ( p == NULL )
    {
        if ( m_Storage.Init() && m_Storage.Resize( sizeof(ADDRESS_CHECK_LIST)
                + sizeof(ADDRESS_HEADER) * 2
                + sizeof(NAME_HEADER) * 2 ) )
        {
            DWORD i;
            pList = (PADDRESS_CHECK_LIST)m_Storage.GetAlloc();
            pList->iDenyAddr = i = MAKEREF( sizeof(ADDRESS_CHECK_LIST) );
            i += sizeof(ADDRESS_HEADER);
            pList->iGrantAddr = i;
            i += sizeof(ADDRESS_HEADER);
            pList->iDenyName = i;
            i += sizeof(NAME_HEADER);
            pList->iGrantName = i;
            i += sizeof(NAME_HEADER);
            pList->cRefSize = MAKEOFFSET(i);
            pList->dwFlags = RDNS_FLAG_DODNS2IPCHECK;

            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
  */  {
        return m_Storage.Init( p, c );
    }
}


BOOL
ADDRESS_CHECK::GetAddr(
    BOOL fGrant,
    DWORD iIndex,
    LPDWORD pdwFamily,
    LPBYTE* pMask,
    LPBYTE* pAddr
    )
/*++

Routine Description:

    Get an address entry

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index in list (0-based )
    pdwFamily - updated with address family ( as in sockaddr.sa_type )
    pMask - updated with ptr to mask
    pAddr - updated with ptr to address

Return Value:

    TRUE if iIndex valid in array defined by fGrant, FALSE otherwise

--*/
{
    PADDRESS_LIST_ENTRY pHeader;
    PADDRESS_HEADER     pHd;
    DWORD               iIndexInHeader;
    LPBYTE              pStore = m_Storage.GetAlloc();

    if ( LocateAddr( fGrant, iIndex, &pHd, &pHeader, &iIndexInHeader ) )
    {
        UINT cS = GetAddrSize( pHeader->iFamily );
        *pdwFamily = pHeader->iFamily;
        pStore = MAKEPTR(pStore, pHeader->iFirstAddress);
        *pMask = pStore;
        *pAddr = pStore+iIndexInHeader*cS;

        return TRUE;
    }

    return FALSE;
}

  
BOOL
ADDRESS_CHECK::GetName(
    BOOL        fGrant,
    DWORD       iIndex,
    LPSTR*      ppName,
    LPDWORD     pdwFlags
    )
/*++

Routine Description:

    Get DNS name in specified list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index (0-based) in specified list
    ppName - updated with ptr to DNS name
    pdwFlags - updated with DNS flags, can be NULL

Return Value:

    TRUE if iIndex valid in specified list, otherwise FALSE

--*/
{
    PNAME_LIST_ENTRY    pHeader;
    PNAME_HEADER        pHd;
    DWORD               iIndexInHeader;
    LPBYTE              pStore = m_Storage.GetAlloc();

    if ( LocateName( fGrant, iIndex, &pHd, &pHeader, &iIndexInHeader ) )
    {
        *ppName = (LPSTR)MAKEPTR(pStore, pHeader->iName[iIndexInHeader] );
        if ( pdwFlags )
        {
            *pdwFlags = pHeader->cComponents & DNSLIST_FLAGS;
        }

        return TRUE;
    }

    return FALSE;
}


DWORD
ADDRESS_CHECK::GetNbName(
    BOOL fGrant
    )
/*++

Routine Description:

    Get number of entries in list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list

Return Value:

    Number of entries in list

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PNAME_HEADER        pHd;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        pHd   = (PNAME_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantName : pList->iDenyName);
        return pHd->cNames;
    }

    return 0;
}

UINT
ADDRESS_CHECK::GetAddrSize(
    DWORD dwF
    )
/*++

Routine Description:

    Returns address size in byte based on family ( sockaddr.sa_type )

Arguments:

    dwF - address family ( as in sockaddr.sa_type )

Return Value:

    Address length, in byte. 0 for unknown address families

--*/
{
    DWORD dwS;

   // switch ( dwF )
   // {
     //   case AF_INET:
            dwS = SIZEOF_IP_ADDRESS;
       //     break;

       // default:
         //   dwS = 0;
           // break;
   // }

    return dwS;
}
BOOL
ADDRESS_CHECK::LocateAddr(
    BOOL fGrant,
    DWORD iIndex,
    PADDRESS_HEADER* ppHd,
    PADDRESS_LIST_ENTRY* pHeader,
    LPDWORD piIndexInHeader
    )
/*++

Routine Description:

    Locate an address in the specified list, returns ptr
    to header & element in address list

Arguments:

    fGrant - TRUE to locate in grant list, FALSE for deny list
    iIndex - index in list (0-based )
    ppHd - updated with ptr to address header
    pHeader - updated with ptr to address list entry
    piIndexInHeader - updated with index in array addressed by
                      pHeader->iFirstAddress

Return Value:

    TRUE if iIndex valid in array defined by fGrant, FALSE otherwise

--*/
{
    LPBYTE              pStore = m_Storage.GetAlloc();
    PADDRESS_CHECK_LIST pList;
    PADDRESS_HEADER     pHd;
    UINT                iL;

    if ( pStore )
    {
        pList = (PADDRESS_CHECK_LIST)pStore;
        *ppHd = pHd   = (PADDRESS_HEADER)MAKEPTR( pStore, fGrant ? pList->iGrantAddr : pList->iDenyAddr);
        for ( iL = 0 ; iL < pHd->cEntries ; ++iL )
        {
            // adjust index by 1: 1st entry is mask
            if ( iIndex < (pHd->Entries[iL].cAddresses-1) )
            {
                *pHeader = pHd->Entries+iL;
                *piIndexInHeader = iIndex+1;
                return TRUE;
            }
            iIndex -= (pHd->Entries[iL].cAddresses-1);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\terrain\tools\dllexist\main.cpp ===
/* DLLexist.exe July 1998
	
		DLLexist is a command line tool made for use with the IIS/Terrain Toolkit.
	  
		It finds the directory where IIS is installed by checking the registry key 
		of the IISADMIN Service.  

		Then it dumps the Name, Size, Version Number, Manufacturer and Description
		of every DLL in the IIS directory.

		This information is output to standard out where it is meant to be
		piped to a file.
*/


#include <windows.h>		// for file calls	
#include <iostream.h>
#include <string.h>			// for strlen function and others
#include <stdio.h>			// for printf function and others


#define IISADMINKEY "SYSTEM\\CurrentControlSet\\Services\\IISADMIN"
#define IISADMINNAME "ImagePath"
#define IISEXENAME "\\inetinfo.exe"	
// above are used to find the IIS install directory

#define NOTAVAILABLE "NA"			// when a version # or size is unavailable


void GetFileVer( CHAR *szFileName, CHAR *szVersion, CHAR *szCompanyName, CHAR *szFileDescription );
void GetFileSize( CHAR *szFileName, CHAR *szSize );
BOOL getIISDir(char *, unsigned int);
BOOL setCurrentDir(char *);
void printCurrentDir(void);
void printFileName(WIN32_FIND_DATA *);



int __cdecl  main(int argc, char** argv)
{	
	char buff[255];
	WIN32_FIND_DATA foundFileData;
	HANDLE searchHandle;

	// get the IIS install directory in buff
	if(!getIISDir(buff,256))
		return 1;

	// set cwd to the IIS install dir
	if(!setCurrentDir(buff))
		return 1;

	//Print the header information
	printf("%-12s %-15s %-10s %-30s %-30s","Filename","Version","FileSize","Company","Description");
	printf("\n");

	// Loop through all DLL's and dump their information
	searchHandle = FindFirstFile("*.dll",&foundFileData);
	if(searchHandle == INVALID_HANDLE_VALUE)
		return 1;

	printFileName(&foundFileData); 
	while( (FindNextFile(searchHandle,&foundFileData)) != 0 )
		printFileName(&foundFileData);

	return 0;
	
}


// prints the cFileName member of a WIN32_FIND_DATA struct
// THIS FUNCTION TRUSTS that d points to a VALID structure
// on same line, the version number is also printed;
void printFileName(WIN32_FIND_DATA *d)
{
	char *version = new char[256];
	char *filesize = new char[256];
	char *company = new char[256];
	char *description = new char[256];

	GetFileVer(d->cFileName,version,company,description);
	GetFileSize(d->cFileName,filesize);

	printf("%-12s %-15s %-10s %-30s %-30s",d->cFileName,version,filesize,company,description);
	printf("\n");

	delete [] version;
	delete [] filesize;
	delete [] company;
	delete [] description;
}

// attempts to change current directory to directory specified in p
// return true if successful, false otherwise
BOOL setCurrentDir(char *p)
{
	if( (SetCurrentDirectory(p))==0)
		return false;
	else
		return true;
}

// prints current working directory
void printCurrentDir(void)
{
	char buffer[255];
	if((GetCurrentDirectory(256,buffer)==0) )
		printf("Current Directory Failed\n");
	else
		printf("%s\n", buffer);

	return;
}


// getIISDir(...) returns the IIS directory.
// It does a lookup in the registry for the IISADMIN service to get the IIS directory
// c is buffer to put IIS path in
// s is the size of c
// depends on the HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\IISADMIN\ImagePath Key
BOOL getIISDir(char *c, unsigned int s)
{

	DWORD buffSize;
	unsigned char buffer[255];
	LONG retVal;
	HKEY iisKey;
	int stringSize;

	buffSize = 256;
	retVal = RegOpenKeyEx(	HKEY_LOCAL_MACHINE,
							IISADMINKEY,
							0, 
							KEY_EXECUTE, 
							&iisKey 
						); 
	if(retVal != ERROR_SUCCESS)
		return false;

	retVal =  RegQueryValueEx(	iisKey,
								IISADMINNAME, 
								NULL, 
								NULL,
								buffer, 
								&buffSize 
						); 
	if(retVal != ERROR_SUCCESS)
		return false;

	stringSize = strlen((const char*)buffer);
	buffer[stringSize-strlen(IISEXENAME)] = 0;
	
	if( s< (strlen( (const char*)buffer)))
			return false;

	strcpy(c,(const char*)buffer);
	return true;
}


/* 
	GetFileSize takes a filename in szFileName and returns the
	size of that file in bytes in szSize.  If GetFileSize fails
	then NOTAVAILABLE is returned in szSize
*/
void GetFileSize( CHAR *szFileName, CHAR *szSize )
{
	HANDLE fileHandle;
	DWORD	fileSize;

	fileHandle = CreateFile(szFileName, 
							GENERIC_READ,  
							FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
							NULL,
							OPEN_EXISTING,
							NULL,
							NULL);
	
	if(fileHandle == INVALID_HANDLE_VALUE)
	{
		strcpy(szSize,NOTAVAILABLE);
		return;
	}

	fileSize = GetFileSize(	fileHandle,
							NULL 
						   );
 
	if(fileSize == 0xFFFFFFFF)
	{
		strcpy(szSize,NOTAVAILABLE);
		return;
	}
	wsprintf(szSize,"%d",fileSize);
	CloseHandle(fileHandle);
}



/* 
	Get FileVer Info, grabbed from tonygod

	szFilename contains filename
	szVersion will contain versionInfo if successful
	NOTAVAILABLE otherwise

	szCompanyName will contain companyName if successful
	NOTAVAILABLE otherwise

	szFileDescription will contain fileDescription if successful
	NOTAVAILABLE otherwise

*/

void GetFileVer( CHAR *szFileName, CHAR *szVersion, CHAR *szCompanyName, CHAR *szFileDescription)
{
    BOOL bResult;
    DWORD dwHandle = 0;
    DWORD dwSize = 0;
    LPVOID lpvData;
    UINT uLen;
    VS_FIXEDFILEINFO *pvs;
	LPVOID	buffer;  // a void *

    dwSize = GetFileVersionInfoSize( szFileName, &dwHandle );
    if ( dwSize == 0 ) 
	{
		strcpy(szVersion,NOTAVAILABLE);
		strcpy(szCompanyName,NOTAVAILABLE);
		strcpy(szFileDescription,NOTAVAILABLE); 
        return;
    }
		
    lpvData = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize );
    if ( lpvData == NULL ) 
	{
        strcpy(szVersion,NOTAVAILABLE);
		strcpy(szCompanyName,NOTAVAILABLE);
		strcpy(szFileDescription,NOTAVAILABLE); 
        return;
    }
    
    bResult = GetFileVersionInfo(
        szFileName,
        dwHandle,
        dwSize,
        lpvData
        );

    if ( !bResult ) 
	{
        strcpy(szVersion,NOTAVAILABLE);
		strcpy(szCompanyName,NOTAVAILABLE);
		strcpy(szFileDescription,NOTAVAILABLE); 
        return;	
    }

    bResult = VerQueryValue(	lpvData,
								"\\",
								(LPVOID *)&pvs,
								&uLen
							);
    if ( !bResult ) 
        strcpy(szVersion,NOTAVAILABLE);
	else
		wsprintf( szVersion, "%d.%d.%d.%d",		HIWORD(pvs->dwFileVersionMS),
												LOWORD(pvs->dwFileVersionMS),
												HIWORD(pvs->dwFileVersionLS),
												LOWORD(pvs->dwFileVersionLS));

	
	/* the below query strings need to be fixed, should make a call to VerQueryValue with \VarInfo\Translation */
	/* right now it checks for unicode first and then it checks for Us English, this picks up all this works ... must
		fix later*/
	
	char szQueryStr[ 0x100 ];
	char szQueryStr2[0x100 ];
 
	// Format the strings with the 1200 codepage (Unicode)
	wsprintf(szQueryStr,"\\StringFileInfo\\%04X%04X\\%s",GetUserDefaultLangID(), 1200,"FileDescription" );
	wsprintf(szQueryStr2, "\\StringFileInfo\\%04X%04X\\%s", GetUserDefaultLangID(), 1200, "CompanyName" );
	
	bResult = VerQueryValue(lpvData,szQueryStr,&buffer,&uLen);               
	if(uLen == 0)
	{
		VerQueryValue(lpvData,"\\StringFileInfo\\040904E4\\FileDescription",&buffer,&uLen);
		if(uLen == 0)
			strcpy(szFileDescription,NOTAVAILABLE);
		else
			strcpy(szFileDescription,(const char *)buffer);	
	}
	else
	{
		strcpy(szFileDescription,(const char *)buffer);
	}


	bResult = VerQueryValue(lpvData,szQueryStr2,&buffer,&uLen);              
	if(uLen == 0)
	{
		VerQueryValue(lpvData,"\\StringFileInfo\\040904E4\\CompanyName",&buffer,&uLen);              
		if(uLen == 0)
			strcpy(szCompanyName,NOTAVAILABLE);
		else
			strcpy(szCompanyName,(const char *)buffer);		
	}
	else
	{
		strcpy(szCompanyName,(const char *)buffer);
	}
    HeapFree( GetProcessHeap(), 0, lpvData );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\terrain\tools\metasnap\convert.cpp ===
//**************************************************************
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  convert.cpp
//  
//  Description: Conversion tables for metabase properties  
//				 corresponding to ADSI names
//
//  History: 15-July-98  Tamas Nemeth (t-tamasn)  Created.
//
//**************************************************************

#include "convert.h"
#include <iiscnfgp.h>  // has MD_* constants


//*************************************************
// METABASE CONSTANT - ADSI PROPERTY NAME TABLE 
//*************************************************

tPropertyNameTable  gPropertyNameTable[]=
{
//  These are global to all services and should only be set at the IIS root
    {MD_MAX_BANDWIDTH                ,_T("MaxBandwidth")},
    {MD_KEY_TYPE                     ,_T("KeyType")},
//  These properties are applicable to both HTTP and FTP virtual servers
    {MD_CONNECTION_TIMEOUT           ,_T("ConnectionTimeout")},
    {MD_MAX_CONNECTIONS              ,_T("MaxConnections")},
    {MD_SERVER_COMMENT               ,_T("ServerComment")},
    {MD_SERVER_STATE                 ,_T("ServerState")},
    {MD_SERVER_COMMAND               ,_T("ServerCommand")},
    {MD_SERVER_AUTOSTART             ,_T("ServerAutoStart")},
    {MD_CLUSTER_SERVER_COMMAND       ,_T("ClusterServerCommand")},
    {MD_CLUSTER_ENABLED              ,_T("ClusterEnabled")},
    {MD_SERVER_SIZE                  ,_T("ServerSize")},
    {MD_SERVER_LISTEN_BACKLOG        ,_T("ServerListenBacklog")},
    {MD_SERVER_LISTEN_TIMEOUT        ,_T("ServerListenTimeout")},
    {MD_DOWNLEVEL_ADMIN_INSTANCE     ,_T("DownlevelAdminInstance")},
    {MD_SERVER_BINDINGS              ,_T("ServerBindings")},
    {MD_SERVER_CONFIGURATION_INFO,    _T("ServerConfigurationInfo")},

//internals
    {MD_SERVER_PLATFORM              ,_T("ServerPlatform")},
    {MD_SERVER_VERSION_MAJOR         ,_T("MajorVersion")},
    {MD_SERVER_VERSION_MINOR         ,_T("MinorVersion")},
    {MD_SERVER_CAPABILITIES          ,_T("Capabilities")},

//  These properties are specific to HTTP and belong to the virtual server
    {MD_SECURE_BINDINGS              ,_T("SecureBindings")},
    {MD_NTAUTHENTICATION_PROVIDERS   ,_T("NTAuthenticationProviders")},
    {MD_SCRIPT_TIMEOUT               ,_T("CGITimeout")},
    {MD_CACHE_EXTENSIONS             ,_T("CacheISAPI")},
    {MD_CREATE_PROCESS_AS_USER       ,_T("CreateProcessAsUser")},
    {MD_CREATE_PROC_NEW_CONSOLE      ,_T("CreateCGIWithNewConsole")},
    {MD_POOL_IDC_TIMEOUT             ,_T("PoolIDCTimeout")},
    {MD_ALLOW_KEEPALIVES             ,_T("AllowKeepAlive")},
    {MD_FILTER_LOAD_ORDER            ,_T("FilterLoadOrder")},
    {MD_FILTER_IMAGE_PATH            ,_T("FilterPath")},
    {MD_FILTER_STATE                 ,_T("FilterState")},
    {MD_FILTER_ENABLED               ,_T("FilterEnabled")},
    {MD_FILTER_FLAGS                 ,_T("FilterFlags")},
    {MD_FILTER_DESCRIPTION           ,_T("FilterDescription")},

    { MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS, _T("AllowPathInfoForScriptMappings")},
    { MD_AUTH_CHANGE_URL,                     _T("AuthChangeUrl")},
    {MD_AUTH_EXPIRED_URL,                     _T("AuthExpiredUrl")},
    {MD_AUTH_NOTIFY_PWD_EXP_URL,              _T("NotifyPwdExpUrl")},
    {MD_AUTH_EXPIRED_UNSECUREURL,             _T("AuthExpiredUnsecureUrl")},
    {MD_AUTH_NOTIFY_PWD_EXP_UNSECUREURL,      _T("NotifyPwdExpUnsecureUrl")},
    {MD_ADV_NOTIFY_PWD_EXP_IN_DAYS,           _T("PasswordExpirePrenotifyDays")},
    {MD_AUTH_CHANGE_FLAGS,                    _T("PasswordChangeFlags")},
    {MD_ADV_CACHE_TTL,                        _T("PasswordCacheTTL")},
    {MD_NET_LOGON_WKS,                        _T("NetLogonWorkstation")},
    {MD_USE_HOST_NAME,                        _T("UseHostName")},
#if defined(CAL_ENABLED)
    {MD_CAL_VC_PER_CONNECT,                   _T("CalVcPerConnect")},
    {MD_CAL_AUTH_RESERVE_TIMEOUT,             _T("CalReserveTimeout")},
    {MD_CAL_SSL_RESERVE_TIMEOUT,              _T("CalSslReserveTimeout")},
    {MD_CAL_W3_ERROR,                         _T("CalLimitHttpError")},
#endif
    { MD_IN_PROCESS_ISAPI_APPS      , _T("InProcessIsapiApps")},
    { MD_CUSTOM_ERROR_DESC          , _T("CustomErrorDescriptions")},

    {MD_MAPCERT                      ,_T("MapCert")},
    {MD_MAPNTACCT                    ,_T("MaPNTAccT")},
    {MD_MAPNAME                      ,_T("MapName")},
    {MD_MAPENABLED                   ,_T("MapEnabled")},
    {MD_MAPREALM                     ,_T("MapRealm")},
    {MD_MAPPWD                       ,_T("MapPwd")},
    {MD_ITACCT                       ,_T("ITACCT")},
    {MD_CPP_CERT11                   ,_T("CppCert11")},
    {MD_SERIAL_CERT11                ,_T("SerialCert11")},
    {MD_CPP_CERTW                    ,_T("CppCertw")},
    {MD_SERIAL_CERTW                 ,_T("SerialCertw")},
    {MD_CPP_DIGEST                   ,_T("CppDigest")},
    {MD_SERIAL_DIGEST                ,_T("SerialDigest")},
    {MD_CPP_ITA                      ,_T("CppIta")},
    {MD_SERIAL_ITA                   ,_T("SerialIta")},

// Compression Filter Properties
    {MD_HC_COMPRESSION_DIRECTORY     ,_T("HcCompressionDirectory")},
    {MD_HC_CACHE_CONTROL_HEADER      ,_T("HcCacheControlHeader")},
    {MD_HC_EXPIRES_HEADER            ,_T("HcExpiresHeader")},
    {MD_HC_DO_DYNAMIC_COMPRESSION    ,_T("HcDoDynamicCompression")},
    {MD_HC_DO_STATIC_COMPRESSION     ,_T("HcDoStaticCompression")},
    {MD_HC_DO_ON_DEMAND_COMPRESSION  ,_T("HcDoOnDemandCompression")},
    {MD_HC_DO_DISK_SPACE_LIMITING    ,_T("HcDoDiskSpaceLimiting")},
    {MD_HC_NO_COMPRESSION_FOR_HTTP_10,_T("HcNoCompressionForHttp10")},
    {MD_HC_NO_COMPRESSION_FOR_PROXIES,_T("HcNoCompressionForProxies")},
    {MD_HC_NO_COMPRESSION_FOR_RANGE  ,_T("HcNoCompressionForRange")},
    {MD_HC_SEND_CACHE_HEADERS        ,_T("HcSendCacheHeaders")},
    {MD_HC_MAX_DISK_SPACE_USAGE      ,_T("HcMaxDiskSpaceUsage")},
    {MD_HC_IO_BUFFER_SIZE            ,_T("HcIoBufferSize")},
    {MD_HC_COMPRESSION_BUFFER_SIZE   ,_T("HcCompressionBufferSize")},
    {MD_HC_MAX_QUEUE_LENGTH          ,_T("HcMaxQueueLength")},
    {MD_HC_FILES_DELETED_PER_DISK_FREE,_T("HcFilesDeletedPerDiskFree")},
    {MD_HC_MIN_FILE_SIZE_FOR_COMP    ,_T("HcMinFileSizeForComp")},
    {MD_HC_COMPRESSION_DLL           ,_T("HcCompressionDll")},
    {MD_HC_FILE_EXTENSIONS           ,_T("HcFileExtensions")},
    {MD_HC_MIME_TYPE                 ,_T("HcMimeType")},
    {MD_HC_PRIORITY                  ,_T("HcPriority")},
    {MD_HC_DYNAMIC_COMPRESSION_LEVEL ,_T("HcDynamicCompressionLevel")},
    {MD_HC_ON_DEMAND_COMP_LEVEL      ,_T("HcOnDemandCompLevel")},
    {MD_HC_CREATE_FLAGS              ,_T("HcCreateFlags")},
// Job Object Site Properties
    {MD_CPU_LIMITS_ENABLED           ,_T("CpuLimitsEnabled")},
    {MD_CPU_RESET_INTERVAL           ,_T("CpuResetInterval")},
    {MD_CPU_LOGGING_INTERVAL         ,_T("CpuLoggingInterval")},
    {MD_CPU_LOGGING_OPTIONS          ,_T("CpuLoggingOptions")},
    {MD_CPU_LOGGING_MASK             ,_T("CpuLoggingMask")},
    {MD_CPU_CGI_LIMIT                ,_T("CpuCgiLimit")},
    {MD_CPU_LIMIT_LOGEVENT           ,_T("CpuLimitLogEvent")},
    {MD_CPU_LIMIT_PRIORITY           ,_T("CpuLimitPriority")},
    {MD_CPU_LIMIT_PROCSTOP           ,_T("CpuLimitProcStop")},
    {MD_CPU_LIMIT_PAUSE              ,_T("CpuLimitPause")},
// Job Object per file properties
    {MD_CPU_CGI_ENABLED              ,_T("CpuCgiEnabled")},
    {MD_CPU_APP_ENABLED              ,_T("CpuAppEnabled")},


// Virtual root properties - note MD_ACCESS_PERM is also generally set at
// the virtual directory.  These are used for both HTTP and FTP
    {MD_VR_PATH                      ,_T("Path")},
    {MD_VR_USERNAME                  ,_T("UNCUserName")},
    {MD_VR_PASSWORD                  ,_T("UNCPassword")},
    {MD_VR_ACL                       ,_T("VrAcl")},
// This is used to flag down updated vr entries - Used for migrating vroots
    {MD_VR_UPDATE                    ,_T("VrUpdate")},

//  Logging related attributes
    {MD_LOG_TYPE                     ,_T("LogType")},
    {MD_LOGFILE_DIRECTORY            ,_T("LogFileDirectory")},
    {MD_LOGFILE_PERIOD               ,_T("LogFilePeriod")},
    {MD_LOGFILE_TRUNCATE_SIZE        ,_T("LogFileTruncateSize")},
    {MD_LOGSQL_DATA_SOURCES          ,_T("LogOdbcDataSource")},
    {MD_LOGSQL_TABLE_NAME            ,_T("LogOdbcTableName")},
    {MD_LOGSQL_USER_NAME             ,_T("LogOdbcUserName")},
    {MD_LOGSQL_PASSWORD              ,_T("LogOdbcPassword")},
//  {MD_LOG_CLSID                    ,_T("LogClsid")},
//  {MD_LOG_STATE                    ,_T("LogState")},
    {MD_LOGEXT_FIELD_MASK            ,_T("ExtLogFieldMask")},
    {MD_LOGEXT_FIELD_MASK2           ,_T("ExtLogFieldMask2")},
    {MD_LOG_PLUGIN_ORDER             ,_T("LogPluginClsid")},

//  These are FTP specific properties
    {MD_EXIT_MESSAGE                 ,_T("ExitMessage")},
    {MD_GREETING_MESSAGE             ,_T("GreetingMessage")},
    {MD_MAX_CLIENTS_MESSAGE          ,_T("MaxClientsMessage")},
    {MD_MSDOS_DIR_OUTPUT             ,_T("MSDOSDirOutput")},
    {MD_ALLOW_ANONYMOUS              ,_T("AllowAnonymous")},
    {MD_ANONYMOUS_ONLY               ,_T("AnonymousOnly")},
    {MD_LOG_ANONYMOUS                ,_T("LogAnonymous")},
    {MD_LOG_NONANONYMOUS             ,_T("LogNonAnonymous")},

//  These are SSL specific properties
    {MD_SSL_PUBLIC_KEY               ,_T("SslPublicKey")},
    {MD_SSL_PRIVATE_KEY              ,_T("SslPrivateKey")},
    {MD_SSL_KEY_PASSWORD             ,_T("SslKeyPassword")},
    {MD_SSL_KEY_REQUEST              ,_T("SslKeyRequest")},
    {MD_SSL_FRIENDLY_NAME            ,_T("SslFriendlyName")},
    {MD_SSL_IDENT                    ,_T("SslIdent")},

// These are server certificate properties
    {MD_SSL_CERT_HASH                ,_T("SslCertHash")},
    {MD_SSL_CERT_CONTAINER           ,_T("SslCertContainer")},
    {MD_SSL_CERT_PROVIDER            ,_T("SslCertProvider")},
    {MD_SSL_CERT_PROVIDER_TYPE       ,_T("SslCertProviderType")},
    {MD_SSL_CERT_OPEN_FLAGS          ,_T("SslCertOpenFlags")},
    {MD_SSL_CERT_STORE_NAME          ,_T("SslCertStoreName")},

// These are Certificate Trust List properties
    {MD_SSL_CTL_IDENTIFIER          ,_T("SslCtlIdentifier")},
    {MD_SSL_CTL_CONTAINER           ,_T("SslCtlContainer")},
    {MD_SSL_CTL_PROVIDER            ,_T("SslCtlProvider")},
    {MD_SSL_CTL_PROVIDER_TYPE       ,_T("SslCtlProviderType")},
    {MD_SSL_CTL_OPEN_FLAGS          ,_T("SslCtlOpenFlags")},
    {MD_SSL_CTL_STORE_NAME          ,_T("SslCtlStoreName")},
    {MD_SSL_CTL_SIGNER_HASH         ,_T("SslCtlSignerHash")},

// Metabase property that defines whether to use DS mapper or not
    {MD_SSL_USE_DS_MAPPER           ,_T("SslUseDSMapper")},

// Metabase property that holds SSL replication information
    {MD_SSL_REPLICATION_INFO        ,_T("SslReplicationInfo")},

// Metabase properties that are used by the CertWiz ActiveX control, that
// is used for the Certificate/CTL UI management tool

    {MD_SSL_CERT_ENROLL_HISTORY     ,_T("SslCertEnrollHistory")},
    {MD_SSL_CERT_ENROLL_TIME        ,_T("SslCertEnrollTime")},
    {MD_SSL_CERT_ENROLL_STATE       ,_T("SslCertEnrollState")},
    {MD_SSL_CERT_ENROLL_STATE_ERROR ,_T("SslCertEnrollStateError")},


// Metabase properties used for Fortezza certificates
    {MD_SSL_CERT_IS_FORTEZZA        ,_T("IsFortezza")},
    {MD_SSL_CERT_FORTEZZA_PIN       ,_T("FortezzaPin")},
    {MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER     ,_T("FortezzaPin")},
    {MD_SSL_CERT_FORTEZZA_PERSONALITY       ,_T("FortezzaPersonality")},
    {MD_SSL_CERT_FORTEZZA_PROG_PIN          ,_T("FortezzaProgPin")},

// Metabase properties that are used by the CertWiz ActiveX control to keep
// track of the user's entry history, and whether DEBUG is enabled.  We keep
// these private properties on a per VS basis.
    {MD_SSL_CERT_WIZ_DEBUG                  ,_T("WizDebug")},
    {MD_SSL_CERT_WIZHIST_SZ_TARGET_CA       ,_T("WizhistTargetCA")},
    {MD_SSL_CERT_WIZHIST_SZ_FILE_NAME_USED_LAST     ,_T("WizhistFileNameUsedLast")},
    {MD_SSL_CERT_WIZHIST_SZ_DN_COMMON_NAME  ,_T("WizhistCN")},
    {MD_SSL_CERT_WIZHIST_SZ_DN_O            ,_T("WizhistO")},
    {MD_SSL_CERT_WIZHIST_SZ_DN_OU           ,_T("WizhistOU")},
    {MD_SSL_CERT_WIZHIST_SZ_DN_C            ,_T("WizhistC")},
    {MD_SSL_CERT_WIZHIST_SZ_DN_L            ,_T("WizhistL")},
    {MD_SSL_CERT_WIZHIST_SZ_DN_S            ,_T("WizhistS")},
    {MD_SSL_CERT_WIZHIST_SZ_USER_NAME       ,_T("WizhistUserName")},
    {MD_SSL_CERT_WIZHIST_SZ_USER_PHONE      ,_T("WizhistUserPhone")},
    {MD_SSL_CERT_WIZHIST_SZ_USER_EMAIL      ,_T("WizhistUserEmail")},

    {MD_SSL_CERT_WIZGUID_ICERTGETCONFIG     ,_T("WizguidICERTGETCONFIG")},
    {MD_SSL_CERT_WIZGUID_ICERTREQUEST       ,_T("WizguidICERTREQUEST")},
    {MD_SSL_CERT_WIZGUID_XENROLL            ,_T("WizguidXENROLL")},

//  File and Directory related properties - these should be added in the
//  metabase with a user type of 
    {MD_AUTHORIZATION                ,_T("Authorization")},
    {MD_AUTHORIZATION_PERSISTENCE    ,_T("AuthorizationPersistence")},
    {MD_REALM                        ,_T("Realm")},
    {MD_HTTP_EXPIRES                 ,_T("HttpExpires")},
    {MD_HTTP_PICS                    ,_T("HttpPics")},
    {MD_HTTP_CUSTOM                  ,_T("HttpCustomHeaders")},
    {MD_DIRECTORY_BROWSING           ,_T("DirectoryBrowsing")},
    {MD_DEFAULT_LOAD_FILE            ,_T("DefaultDoc")},
    {MD_CONTENT_NEGOTIATION      ,    _T("ContentNegotiation")},
    {MD_CUSTOM_ERROR                 ,_T("HTTPErrors")},
    {MD_FOOTER_DOCUMENT              ,_T("DefaultDocFooter")},
    {MD_FOOTER_ENABLED               ,_T("EnableDocFooter")},
    {MD_HTTP_REDIRECT                ,_T("HttpRedirect")},
    {MD_DEFAULT_LOGON_DOMAIN         ,_T("DefaultLogonDomain")},
    {MD_LOGON_METHOD                 ,_T("LogonMethod")},
    {MD_SCRIPT_MAPS                  ,_T("ScriptMaps")},
    {MD_SCRIPT_TIMEOUT               ,_T("ScriptTimeout")},
    {MD_MIME_MAP                     ,_T("MimeMap")},
    {MD_ACCESS_PERM                  ,_T("AccessPerm")},
    {MD_SSL_ACCESS_PERM              ,_T("SslAccessPerm")},
    {MD_IP_SEC                       ,_T("IPSecurity")},
    {MD_ANONYMOUS_USER_NAME          ,_T("AnonymousUserName")},
    {MD_ANONYMOUS_PWD                ,_T("AnonymousUserPass")},
    {MD_ANONYMOUS_USE_SUBAUTH        ,_T("AnonymousPasswordSync")},
    {MD_DONT_LOG                     ,_T("DontLog")},
    {MD_ADMIN_ACL                    ,_T("AdminACL")},
    {MD_SSI_EXEC_DISABLED            ,_T("SSIExecDisable")},
    {MD_DO_REVERSE_DNS               ,_T("EnableReverseDns")},
    {MD_WIN32_ERROR                  ,_T("Win32Error")},
    {MD_ALLOW_REPLACE_ON_RENAME      ,_T("AllowReplaceOnRename")},
    {MD_CC_NO_CACHE                  ,_T("CacheControlNoCache")},
    {MD_CC_MAX_AGE                   ,_T("CacheControlMaxAge")},
    {MD_CC_OTHER                     ,_T("CacheControlCustom")},

//ASP and WAM params
    { MD_ASP_BUFFERINGON                  , _T("AspBufferingOn")},
    { MD_ASP_LOGERRORREQUESTS             , _T("AspLogErrorRequests")},
    { MD_ASP_SCRIPTERRORSSENTTOBROWSER    , _T("AspScriptErrorSentToBrowser")},
    { MD_ASP_SCRIPTERRORMESSAGE           , _T("AspScriptErrorMessage")},
    { MD_ASP_SCRIPTFILECACHESIZE          , _T("AspScriptFileCacheSize")},
    { MD_ASP_SCRIPTENGINECACHEMAX         , _T("AspScriptEngineCacheMax")},
    { MD_ASP_SCRIPTTIMEOUT                , _T("AspScriptTimeout")},
    { MD_ASP_SESSIONTIMEOUT               , _T("AspSessionTimeout")},
    { MD_ASP_ENABLEPARENTPATHS            , _T("AspEnableParentPaths")},
    { MD_ASP_MEMFREEFACTOR                , _T("AspMemFreeFactor")},
    { MD_ASP_MINUSEDBLOCKS                , _T("AspMinUseDblocks")},
    { MD_ASP_ALLOWSESSIONSTATE            , _T("AspAllowSessionState")},
    { MD_ASP_SCRIPTLANGUAGE               , _T("AspScriptLanguage")},
    { MD_ASP_QUEUETIMEOUT                 , _T("AspQueueTimeout")},
    //{ MD_ASP_STARTCONNECTIONPOOL          , _T("AspStartConnectionPool")},
    { MD_ASP_ALLOWOUTOFPROCCMPNTS         , _T("AspAllowOutOfProcComponents")},
    { MD_ASP_EXCEPTIONCATCHENABLE         , _T("AspExceptionCatchEnable")},
    { MD_ASP_CODEPAGE                     , _T("AspCodepage")},
    { MD_ASP_SCRIPTLANGUAGELIST           , _T("AspScriptLanguages")},
    { MD_ASP_ENABLESERVERDEBUG            , _T("AppAllowDebugging")},
    { MD_ASP_ENABLECLIENTDEBUG            , _T("AspEnableClientDebug")},
    { MD_ASP_TRACKTHREADINGMODEL          , _T("AspTrackThreadingModel")},

    // new 5.0 ASP params
    { MD_ASP_ENABLEASPHTMLFALLBACK        , _T("AspEnableAspHTMLFallback")},
    { MD_ASP_ENABLECHUNKEDENCODING        , _T("AspEnableChunkedEncoding")},
    { MD_ASP_ENABLETYPELIBCACHE           , _T("AspEnableTypeLibCache")},
    { MD_ASP_ERRORSTONTLOG                , _T("AspErrorsToNTLog")},
    { MD_ASP_PROCESSORTHREADMAX           , _T("AspProcessorThreadMax")},
    { MD_ASP_REQEUSTQUEUEMAX              , _T("AspRequestQueueMax")},
    { MD_ASP_ENABLEAPPLICATIONRESTART     , _T("AspEnableApplicationRestart")},
    { MD_ASP_QUEUECONNECTIONTESTTIME      , _T("AspQueueConnectionTestTime")},
    { MD_ASP_SESSIONMAX                   , _T("AspSessionMax")},

    // Thread gate params
    { MD_ASP_THREADGATEENABLED            , _T("AspThreadGateEnabled")},
    { MD_ASP_THREADGATETIMESLICE          , _T("AspThreadGateTimeSlice")},
    { MD_ASP_THREADGATESLEEPDELAY         , _T("AspThreadGateSleepDelay")},
    { MD_ASP_THREADGATESLEEPMAX           , _T("AspThreadGateSleepMax")},
    { MD_ASP_THREADGATELOADLOW            , _T("AspThreadGateLoadLow")},
    { MD_ASP_THREADGATELOADHIGH           , _T("AspThreadGateLoadHigh")},

// WAM params
    //{ MD_APP_COMMAND                  , _T("AppCommand")},
    //{ MD_APP_STATUS                   , _T("AppStatus")},
    //{ MD_APP_ERRORCODE                , _T("AppErrorCode")},
    { MD_APP_ROOT                     , _T("AppRoot")},
    { MD_APP_ISOLATED                 , _T("AppIsolated")},
    { MD_APP_WAM_CLSID                , _T("AppWamClsid")},
    { MD_APP_PACKAGE_ID               , _T("AppPackageId")},
    { MD_APP_PACKAGE_NAME             , _T("ApPackageName")},
    { MD_APP_LAST_OUTPROC_PID         , _T("AppLastOutprocId")},
    //{ MD_APP_WAM_RUNTIME_FLAG         , _T("AppWamRuntimmeFlag")},
    //{ MD_APP_OOP_CRASH_LIMIT          , _T("AppOopCrashLimit")},

    {0,0}
};

CString tPropertyNameTable::MapCodeToName(DWORD dwCode, tPropertyNameTable * PropertyNameTable)
{
    for(int i=0; PropertyNameTable[i].lpszName!=0;i++)
    {
        if(dwCode == PropertyNameTable[i].dwCode)
            return PropertyNameTable[i].lpszName;
    }
    return _T("");
}


//************************************************
// PROPERTY PREDEFINED VALUES TABLE
//************************************************

struct tValueTable gValueTable[]=
{
//  Valid values for MD_AUTHORIZATION
    {MD_AUTH_ANONYMOUS               ,_T("Anonymous"),  MD_AUTHORIZATION},
    {MD_AUTH_BASIC                   ,_T("Basic"),      MD_AUTHORIZATION},
    {MD_AUTH_NT                      ,_T("NT"),     MD_AUTHORIZATION},
    {MD_AUTH_MD5                     ,_T("MD5"),        MD_AUTHORIZATION},
    {MD_AUTH_MAPBASIC                ,_T("MapBasic"),   MD_AUTHORIZATION},
//  Valid values for MD_ACCESS_PERM
    {MD_ACCESS_READ                  ,_T("Read"),   MD_ACCESS_PERM},
    {MD_ACCESS_WRITE                 ,_T("Write"),  MD_ACCESS_PERM},
    {MD_ACCESS_EXECUTE               ,_T("Execute"),    MD_ACCESS_PERM},
    {MD_ACCESS_SSL                   ,_T("SSL"),        MD_ACCESS_PERM},// Require SSL
    {MD_ACCESS_NEGO_CERT             ,_T("NegoCert"),   MD_ACCESS_PERM},// Allow client SSL certs
    {MD_ACCESS_REQUIRE_CERT          ,_T("RequireCert"),MD_ACCESS_PERM},// Require client SSL certs
    {MD_ACCESS_MAP_CERT              ,_T("MapCert"),MD_ACCESS_PERM},// Map SSL cert to NT account
    {MD_ACCESS_SSL128                ,_T("SSL128"), MD_ACCESS_PERM},// Require 128 bit SSL
    {MD_ACCESS_SCRIPT                ,_T("Script"), MD_ACCESS_PERM},// Script
    {MD_ACCESS_NO_REMOTE_READ        ,_T("NoRemoteRead"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_WRITE       ,_T("NoRemoteWrite"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_EXECUTE     ,_T("NoRemoteExecute"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_SCRIPT      ,_T("NoRemoteScript"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_MASK                  ,_T("MaskAll"),    MD_ACCESS_PERM},
//  Valid values for MD_SSL_ACCESS_PERM
    {MD_ACCESS_READ                  ,_T("Read"),   MD_SSL_ACCESS_PERM},
    {MD_ACCESS_WRITE                 ,_T("Write"),  MD_SSL_ACCESS_PERM},
    {MD_ACCESS_EXECUTE               ,_T("Execute"),    MD_SSL_ACCESS_PERM},
    {MD_ACCESS_SSL                   ,_T("SSL"),        MD_SSL_ACCESS_PERM},// Require SSL
    {MD_ACCESS_NEGO_CERT             ,_T("NegoCert"),   MD_SSL_ACCESS_PERM},// Allow client SSL certs
    {MD_ACCESS_REQUIRE_CERT          ,_T("RequireCert"),MD_SSL_ACCESS_PERM},// Require client SSL certs
    {MD_ACCESS_MAP_CERT              ,_T("MapCert"),MD_SSL_ACCESS_PERM},// Map SSL cert to NT account
    {MD_ACCESS_SSL128                ,_T("SSL128"), MD_SSL_ACCESS_PERM},// Require 128 bit SSL
    {MD_ACCESS_SCRIPT                ,_T("Script"), MD_SSL_ACCESS_PERM},// Script
    {MD_ACCESS_NO_REMOTE_READ        ,_T("NoRemoteRead"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_WRITE       ,_T("NoRemoteWrite"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_EXECUTE     ,_T("NoRemoteExecute"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_SCRIPT      ,_T("NoRemoteScript"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_MASK                  ,_T("MaskAll"),    MD_SSL_ACCESS_PERM},
//  Valid values for MD_DIRECTORY_BROWSING
    {MD_DIRBROW_SHOW_DATE            ,_T("Date"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_SHOW_TIME            ,_T("Time"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_SHOW_SIZE            ,_T("Size"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_SHOW_EXTENSION       ,_T("Extension"), MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_LONG_DATE            ,_T("LongDate"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_ENABLED              ,_T("Enabled"),   MD_DIRECTORY_BROWSING},// Allow directory browsing
    {MD_DIRBROW_LOADDEFAULT          ,_T("LoadDefault"),MD_DIRECTORY_BROWSING},// Load default doc if exists
    {MD_DIRBROW_MASK                 ,_T("MaskAll"),        MD_DIRECTORY_BROWSING},
//  Valid values for MD_LOGON_METHOD
    {MD_LOGON_INTERACTIVE    ,_T("Interactive"),    MD_LOGON_METHOD, tValueTable::TYPE_EXCLUSIVE},
    {MD_LOGON_BATCH          ,_T("Batch"),      MD_LOGON_METHOD, tValueTable::TYPE_EXCLUSIVE},
    {MD_LOGON_NETWORK        ,_T("Network"),        MD_LOGON_METHOD, tValueTable::TYPE_EXCLUSIVE},
//  Valid values for MD_FILTER_STATE
    {MD_FILTER_STATE_LOADED          ,_T("Loaded"), MD_FILTER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_FILTER_STATE_UNLOADED        ,_T("Unloaded"),   MD_FILTER_STATE,    tValueTable::TYPE_EXCLUSIVE },
//  Valid values for MD_FILTER_FLAGS
    {/*SF_NOTIFY_SECURE_PORT*/0x00000001         ,_T("SecurePort"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_NONSECURE_PORT*/0x00000002      ,_T("NonSecurePort"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_READ_RAW_DATA*/0x000008000      ,_T("ReadRawData"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_PREPROC_HEADERS*/0x00004000     ,_T("PreprocHeaders"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_AUTHENTICATION*/0x00002000      ,_T("Authentication"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_URL_MAP*/0x00001000             ,_T("UrlMap"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_ACCESS_DENIED*/0x00000800       ,_T("AccessDenied"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_SEND_RESPONSE*/0x00000040       ,_T("SendResponse"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_SEND_RAW_DATA*/0x00000400       ,_T("SendRawData"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_LOG*/0x00000200                 ,_T("NotifyLog"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_END_OF_REQUEST*/0x00000080      ,_T("EndOfRequest"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_END_OF_NET_SESSION*/0x00000100  ,_T("EndOfNetSession"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_AUTHENTICATIONEX*/  0x20000000  ,_T("AuthenticationX"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_REQUEST_SECURITY_CONTEXT_CLOSE*/0x10000000,_T("RequestSecurityContextClose"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_RENEGOTIATE_CERT*/0x08000000,   _T("RenegotiateCert"), MD_FILTER_FLAGS},

    {/*SF_NOTIFY_ORDER_HIGH*/0x00080000   ,_T("OrderHigh"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_ORDER_MEDIUM*/0x00040000   ,_T("OrderMedium"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_ORDER_LOW*/0x00020000   ,_T("OrderLow"), MD_FILTER_FLAGS},

//  Valid values for MD_SERVER_STATE
    {MD_SERVER_STATE_STARTING        ,_T("Starting"),   MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_STARTED         ,_T("Started"),    MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_STOPPING        ,_T("Stopping"),   MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_STOPPED         ,_T("Stopped"),    MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_PAUSING         ,_T("Pausing"),    MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_PAUSED          ,_T("Paused"),     MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_CONTINUING      ,_T("Continuing"), MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
//  Valid values for MD_SERVER_COMMAND
    {MD_SERVER_COMMAND_START         ,_T("Start"),      MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_COMMAND_STOP          ,_T("Stop"),       MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_COMMAND_PAUSE         ,_T("Pause"),      MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_COMMAND_CONTINUE      ,_T("Continue"),   MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
//  Valid values for MD_SERVER_SIZE
    {MD_SERVER_SIZE_SMALL            ,_T("Small"),  MD_SERVER_SIZE, tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_SIZE_MEDIUM           ,_T("Medium"), MD_SERVER_SIZE, tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_SIZE_LARGE            ,_T("Large"),  MD_SERVER_SIZE, tValueTable::TYPE_EXCLUSIVE},

    //{APPCMD_NONE, _T("None"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_VERIFY, _T("Verify"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_GETSTATUS, _T("GetStatus"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CREATE, _T("Create"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CREATEINPROC, _T("CreateInProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CREATEOUTPROC, _T("CreateOutProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CHANGETOINPROC, _T("ChangeToInProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CHANGETOOUTPROC, _T("ChangeToOutProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_DELETE, _T("Delete"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_UNLOAD, _T("Unload"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},

    //{APPSTATUS_Error, _T("Error"),            MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Created, _T("Created"),        MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Deleted, _T("Deleted"),        MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_UnLoaded, _T("Unloaded"),      MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Killed, _T("Killed"),  MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Running, _T("Running"),        MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Stopped, _T("Stopped"),        MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_NoApplication, _T("NoApplication"),    MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_AppSubNode, _T("AppSubNode"),  MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},

// NEED LOGGING Updates
#if 0
    {MD_LOGTYPE_NONE     ,_T("LOGTYPE_NONE")},
    {MD_LOGTYPE_FILE     ,_T("LOGTYPE_FILE")},
    {MD_LOGTYPE_ODBC     ,_T("LOGTYPE_ODBC")},
    {MD_LOGFILE_PERIOD_MAXSIZE   ,_T("LOGFILE_PERIOD_MAXSIZE")},
    {MD_LOGFILE_PERIOD_DAILY     ,_T("LOGFILE_PERIOD_DAILY")},
    {MD_LOGFILE_PERIOD_WEEKLY    ,_T("LOGFILE_PERIOD_WEEKLY")},
    {MD_LOGFILE_PERIOD_MONTHLY   ,_T("LOGFILE_PERIOD_MONTHLY")},
#endif
    {0,0}
};

CString  tValueTable::MapValueContentToString(DWORD dwValueContent, DWORD dwRelatedPropertyCode, tValueTable * ValueTable)
{
    CString strResult=_T("");
    for(int i=0; ValueTable[i].lpszName!=0;i++)
    {
        if(ValueTable[i].dwRelatedPropertyCode==dwRelatedPropertyCode)
        {
            if(ValueTable[i].dwFlags==tValueTable::TYPE_EXCLUSIVE)
            {
                if (ValueTable[i].dwCode == dwValueContent)
                    return ValueTable[i].lpszName;
            }
            else if ((ValueTable[i].dwCode & dwValueContent) == ValueTable[i].dwCode)
            {
                strResult = strResult + ValueTable[i].lpszName + _T(" ");
            }

        }
    }
    strResult.TrimRight();
    return strResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs\ctplus0.c ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999.
//
//  File:       ctplus.c
//
//  Contents:   Contains character type (orthography) data and routine
//                    to get at it.
//
//  History:    23-May-96   pathal      Created.
//
//---------------------------------------------------------------------------

#include "precomp.h"
#include <winnls.h>

//----------------------------------------------------------------------------
//  s_abBreakList
//
//  This array starts at -1, so that EOF can be found in the array.  It
//  depends on (EOF == -1) being true.  Also, all references to it must be
//  of the form (s_abCharTypeList+1)[x]
//
//  000
//  EOF
//
//  001-080
//  The lower 7F entries from the ASCII Code Page (0000-00ff) are mapped in place
//  (ex. UNICODE 0009 (HT) == 009)
//      The word characters are: $,0-9,A-Z,_,a-z
//      The word separators are: bs,tab,lf,vtab,cr,spc,
//                               ",#,%,&,',(,),*,+,comma,-,/,
//                               :,;,<,=,>,@,[,],`
//      The phrase seperators are: !,.,?,\,^,{,|,},~
//
//  NOTE: Symbols are treated as WS or PS.
//
//  081-0FF
//  The lower 7E entries from the Half Width Variant Code Page (FF00-FF7F) are
//  mapped to 081-0FF.
//
//  100-1FF
//  The lower FF entries from the General Punctuation Code Page (2000-2044) are
//  mapped to 100-1ff.
//
//  200-2FF
//  The lower FF entries from the CJK Auxiliary Code Page (3000-30FF) are mapped
//  to 200-2ff.
//
// pathal - 5/20/96
// Special default character processing for selection
// The following is a list of white space characters that T-Hammer will not right select on:
//          0x0009 (tab), 0x0020 (ansi space), 0x2005 (narrow space, 0x3000 (wide space)
// (Note: see AnalyzeHPBs for special end SPB processing of adjacent white space)
// The following is a list of nls characters to be treated as text by T-Hammer:
//      (in other words T-Hammer will neither right nor left-select on them):
//          0x001F (non-required hyphen), 0x0027 (single quote), 0x2019 (right quote),
//          0x200C (non-width optional break), 0x200D (non-width no break)
//----------------------------------------------------------------------------

const BYTE
s_abCharTypeList[0x301] =
    {
        (BYTE) -1,                                       // EOF (-1)
        PS,PS,PS,PS,PS,PS,PS,PS, WS,WS,WS,WS,PS,WS,PS,PS, // 000 - 015
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,CH,PS, // 016 - 031
        WS,PS,WS,WS,CH,CH,WS,PS,                          // sp ! " # $ % & '
        WS,WS,WS,WS,WS,WS,PS,WS,                          //  ( ) * + , - . /
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  0 1 2 3 4 5 6 7
        CH,CH,WS,WS,WS,WS,WS,PS,                          //  8 9 : ; < = > ?
        WS,CH,CH,CH,CH,CH,CH,CH,                          //  @ A B C D E F G
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  H I J K M L N O
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  P Q R S T U V Y
        CH,CH,CH,WS,PS,WS,PS,CH,                          //  X Y Z [ \ ] ^ _
        WS,CH,CH,CH,CH,CH,CH,CH,                          //  ` a b c d e f g
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  h i j k m l n o
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  p q r s t u v y
        CH,CH,CH,PS,PS,PS,CH,PS,                          //  x y z { | } ~ del
        WS,PS,WS,WS,CH,CH,WS,WS,                          // FF00-FF07 (sp ! " # $ % & ')
        WS,WS,WS,WS,WS,WS,PS,WS,                          //  ( ) * + , - . /
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  0 1 2 3 4 5 6 7
        VC,VC,WS,WS,WS,WS,WS,PS,                          //  8 9 : ; < = > ?
        WS,VC,VC,VC,VC,VC,VC,VC,                          //  @ A B C D E F G
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  H I J K M L N O
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  P Q R S T U V Y
        VC,VC,VC,WS,VC,WS,PS,VC,                          //  X Y Z [ \ ] ^ _
        WS,VC,VC,VC,VC,VC,VC,VC,                          //  ` a b c d e f g
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  h i j k m l n o
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  p q r s t u v y
        VC,VC,VC,PS,PS,PS,VC,PS,                          //  x y z { | } ~ del
        VC,PS,WS,WS,WS,WS,VC,VC,                          //  FF60-FF67
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF68-FF6F
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF70-FF77
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF70-FF7E
        WS,WS,WS,WS,WS,WS,WS,WS,                          // 2000-2007
       WS,WS,WS,WS,CH,CH,WS,WS,                          //  2008-200F
        WS,CH,WS,WS,WS,KC,PS,WS,                          //  2010-2017
        WS,CH,WS,WS,WS,WS,WS,WS,                          //  2018-201F
        WS,WS,PS,PS,PS,PS,PS,CH,                          //  2020-2027
        PS,PS,CH,CH,CH,CH,CH,PS,                          //  2028-202F
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2030-2037
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2038-203F
        WS,WS,WS,PS,WS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2040-204F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2050-205F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2060-206F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2070-207F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2080-208F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2090-209F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20A0-20AF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20B0-20BF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20C0-20CF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20D0-20DF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20E0-20EF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20F0-20FF
        WS,WS,PS,HC,HC,IC,IC,HC,                          // 3000-3007
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3008-300F
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3010-3017
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3018-301F
        HC,HC,HC,HC,HC,HC,HC,HC,                          //  3020-3027
        HC,HC,HC,HC,HC,HC,HC,HC,                          //  3028-302F
        WS,HC,IC,HC,IC,HC,HC,HC,                          //  3030-3037
        PS,PS,PS,PS,PS,PS,PS,WS,                          //  3038-303F
        WS,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3040-304F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3050-305F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3060-306F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3070-307F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3080-308F
        HC,HC,HC,HC,HC,PS,PS,PS,                          //  3090-3097
        PS,HC,HC,WS,WS,HC,HC,PS,                          //  3098-309F
        WS,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30A0-30AF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30B0-30BF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30C0-30CF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30D0-30DF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30E0-30EF
        KC,KC,KC,KC,KC,KC,IC,PS,                          //  30F0-30F7
        PS,PS,PS,WS,KC,KC,KC,PS,                          //  30F8-30FF
    };

//
// Type C1 bits are:
//
//   C1_UPPER                  0x0001      // upper case
//   C1_LOWER                  0x0002      // lower case
//   C1_DIGIT                  0x0004      // decimal digits             1
//   C1_SPACE                  0x0008      // spacing characters         2
//   C1_PUNCT                  0x0010      // punctuation characters     4
//   C1_CNTRL                  0x0020      // control characters         8
//   C1_BLANK                  0x0040      // blank characters          10
//   C1_XDIGIT                 0x0080      // other digits              20
//   C1_ALPHA                  0x0100      // any linguistic character  40
//
// But since I don't care about C1_UPPER and C1_LOWER I can right-shift
// the output of GetStringTypeEx and keep a 128 Byte lookup table.
//
// The precedence rules are: (Alpha, XDigit, Digit) --> CH
//                           (Punct) --> PS
//                           (Space, Blank, Control) --> WS
//

const BYTE
s_abCTypeList[128] =
    {
      WS, CH, WS, CH, PS, CH, WS, CH,   // 00 - 07
      WS, CH, WS, CH, PS, CH, WS, CH,   // 08 - 0F
      WS, CH, WS, CH, PS, CH, WS, CH,   // 10 - 17
      WS, CH, WS, CH, PS, CH, WS, CH,   // 18 - 1F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 20 - 27
      CH, CH, CH, CH, CH, CH, CH, CH,   // 20 - 27
      CH, CH, CH, CH, CH, CH, CH, CH,   // 30 - 37
      CH, CH, CH, CH, CH, CH, CH, CH,   // 30 - 37
      CH, CH, CH, CH, CH, CH, CH, CH,   // 40 - 47
      CH, CH, CH, CH, CH, CH, CH, CH,   // 48 - 4F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 50 - 57
      CH, CH, CH, CH, CH, CH, CH, CH,   // 58 - 5F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 60 - 67
      CH, CH, CH, CH, CH, CH, CH, CH,   // 68 - 6F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 70 - 77
      CH, CH, CH, CH, CH, CH, CH, CH,   // 78 - 7F
    };

//+---------------------------------------------------------------------------
//  Member:     WBREAKJ::TypeOf
//
//  Synopsis:   Returns the type of a character
//
//  Arguments:  [c]   -- Unicode Character
//
//  Returns:    type, one of CH, WS, PS, EOF
//
//  History:    08-Apr-94   PatHal      Adapted for Japanese WB
//
//  Notes:      This returns the type of a character, using the static
//              array s_abCharTypeList.  It adds 1 so that EOF (-1) can be in
//              the array, and accessed normally.
//
//              This is not done by overloading the [] opeator, because in
//              future versions it will not necessarly be a table lookup.
//
//  See above (typeof comments) for an explanation of the mapping
//
//----------------------------------------------------------------------------
BYTE
GetCharType(WCHAR wc )
{
    WCHAR wc2;

    // Map interesting stuff (0000, 2000, 3000, FF00) to the table range,
    // 0x0000 - 0x0300.
    //
    wc2 = (wc & 0x00FF);

    switch (wc & 0xFF00) {

        case 0xFF00:  // Half-Width Variants
            if (wc2 & 0x80) {
                return(VC);  // including Hangul
            }
            wc2 |=  0x0080;
            break;

        case 0xFE00:  // Small Variants
            if ((wc2 <= 0x006B) && (wc2 != 0x0069)) {
                return(WS);
            }
            // Treat Small $ and arabic symbols as CH
            return(CH);
            // break;

        case 0x3000:  // CJK Auxiliary
            wc2 |=  0x0200;
            break;

        case 0x2000:  // General Punctuation
            wc2 |=  0x0100;
            break;

        case 0x0000:  // Code page 0
            // Use System NLS map for code page 0
            if (wc2 & 0x80)
            {
                WORD wCharType = 0;

                GetStringTypeEx( MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED ),
                                 CT_CTYPE1,
                                 &wc2,
                                 1,
                                 &wCharType );
                return s_abCTypeList[wCharType >> 2];
            }
            break;

        default:
            //
            // Treat the whole CJK Range as Kanji
            //
            if ((wc >= 0x4E00) && (wc <= 0x9FFF)) {
                return(IC);
            }

            //
            // Treat All Gaiji as Kanji Char, too
            //
            if ((wc >= 0xE000) && (wc < 0xE758)) {
                return(IC);
            }

            //
            // Treat all CJK symbols as word separators
            // NOTE: This means that the stemmer must be smart about searching
            // for zipcodes when given one with a preceding zipcode char.
            //
            if ((wc >= 0x3200) && (wc <= 0x33DD)) {
                return(WS);
            }

            // If it's not interesting return CH as default;
            return(CH);
            // break;
    }

    return( (s_abCharTypeList+1)[wc2] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs\ctplus0.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1995, Microsoft Corporation.  All Rights Reserved.
//
//  File:       ctplus.h
//
//  Contents:   Local definitions for ctplus.c
//
//  History:    23-May-96   pathal      Created.
//
//---------------------------------------------------------------------------

#ifndef _CTPLUS_0_H_
#define _CTPLUS_0_H_

#define HC     0x01                             // Hiragana char
#define IC       0x02                             // Ideograph char
#define KC     0x03                             // Katakana char
#define WS     0x04                            // Word seperator
#define VC     0x05                             // Hankaku (variant) char
#define PS      0x06                            // Phrase seperator
#define CH      0x07                           // Code page 0 - ASCII Char.

BYTE
GetCharType(WCHAR wc );

// Declare character types transitions
// Intuitively frequency ordered
//
typedef enum _CT {
   CT_START = 0x00,
   CT_HIRAGANA = 0x01,
   CT_KANJI = 0x02,
   CT_KATAKANA = 0x03,
   CT_WORD_SEP = 0x04,
   CT_HANKAKU =0x05,
   CT_PHRASE_SEP = 0x06,
   CT_ROMAJI   = 0x07,
} CT;

#define CT_MAX    0x08

#endif // _CTPLUS_0_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\terrain\tools\perms\perms.h ===
//
// System include files.
//

#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
// #include <lmcons.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <string.h>
#include <stdio.h>

#include <windef.h> 
#include <winbase.h>
#include <winnetwk.h>
#include <crt\ctype.h>
// #include "seopaque.h"
#include <lmaccess.h>



#define USAGE_ARG     0
#define INVALID_ACC   1
#define INVALID_ARG   2
#define INVALID_PTH   3
#define INVALID_SWT   4
#define INVALID_FIL   5
#define HELP          6
#define MAXARGS       4
#define LSA_WIN_STANDARD_BUFFER_SIZE     0x000000200L 
#define STANDARD_BUFFER_SIZE             512 


char *MESSAGES[] = 
{
	"PERMS [domain\\|computer\\]user path [/i] [/s] [/?]\n",

	"User on domain or computer can't be located or accessed.",

	"Invalid argument: \n",

	"Path to file is not valid.",

	"Invalid switch.",

	"File name can't be located: ",

	"Displays a user's permissions to specified files and directories.\n\n"
	"PERMS   [domain\\|computer\\]username   path  [/i]  [/s]  [/?] \n\n"
	" [domain\\|computer\\]username\n"
	"               Name of user whose permissions are to be checked. If \n"
	"               no domain is given, defaults to local computer.\n\n"
	" path          A file or directory, wildcards (*,?) are accepted.\n\n" 
	" /i            Assumes the specified user is logged on interactively\n"
	"               to computer where the file/directory resides.\n"  
	"               With this switch, PERMS assumes the user is a member\n"
	"               of the INTERACTIVE group. Without this switch, PERMS\n"
	"               assumes the user is a member of the NETWORK group.\n\n"
	" /s            Check permissions on files in subdirectories.\n\n"
	"The following letters indicate granted access types:\n\n"
	"      R Read \n"
	"      W Write \n"
	"      X Execute \n"
	"      D Delete \n"
	"      P Change Permissions \n"
	"      O Take Ownership \n\n"
	"      A General All \n"
	"      - No Access \n\n"
	"* The specified user is the owner of the file or directory.\n"
	"# A group the user is a member of owns the file or directory.\n\n"
	"? The user's access permisssions can not be determined or the information\n"
	"  may not exist (if the file system is FAT).\n"
};




static SID_IDENTIFIER_AUTHORITY    SepNullSidAuthority    = SECURITY_NULL_SID_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY    SepWorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY    SepLocalSidAuthority   = SECURITY_LOCAL_SID_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY    SepCreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY    SepNtAuthority = SECURITY_NT_AUTHORITY;


																									

//                                
// Universal well known SIDs      
//                                
																	
PSID  SeNullSid;                  
PSID  SeWorldSid;                 
PSID  SeLocalSid;                 
PSID  SeCreatorOwnerSid;          
PSID  SeCreatorGroupSid;          
																	
//                                
// Sids defined by NT             
//                                
																	
PSID SeNtAuthoritySid;            
																	
PSID SeDialupSid;                 
PSID SeNetworkSid;                
PSID SeBatchSid;                  
PSID SeInteractiveSid;            
PSID SeServiceSid;                
PSID SeLocalSystemSid;            
PSID SeAliasAdminsSid;            
PSID SeAliasUsersSid;             
PSID SeAliasGuestsSid;            
PSID SeAliasPowerUsersSid;        
PSID SeAliasAccountOpsSid;        
PSID SeAliasSystemOpsSid;         
PSID SeAliasPrintOpsSid;          
PSID SeAliasBackupOpsSid;         
																	

																									 
//                                                 
// System default DACL                             
//                                                 
																									 
PACL SeSystemDefaultDacl;                          
																									 

PACL SePublicDefaultDacl;   



#define TstAllocatePool(IgnoredPoolType,NumberOfBytes)    \
		RtlAllocateHeap(RtlProcessHeap(), 0, NumberOfBytes)

#define TstDeallocatePool(Pointer) \
		RtlFreeHeap(RtlProcessHeap(), 0, Pointer)


OBJECT_ATTRIBUTES ObjectAttributes;
SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

//
// Globally Visible Table of Sids.
//

PSID AccountDomainSid = NULL;
PSID PrimaryDomainSid = NULL;
PSID *TrustedDomainSids = NULL;

BOOL
VariableInitialization();

BOOL
LookupSidsInSamDomain(
		IN OPTIONAL PUNICODE_STRING WorkstationName,
		IN PUNICODE_STRING DomainControllerName,
		IN PUNICODE_STRING SamDomainName
		);

BOOL
GeneralBuildSid(
		PSID *Sid,
		PSID DomainSid,
		ULONG RelativeId
		);

VOID
InitObjectAttributes(
		IN POBJECT_ATTRIBUTES ObjectAttributes,
		IN PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService
		);

VOID usage(INT message_num, PCHAR string_val);
BOOL LookupAllUserSidsWS(LPSTR lpSystemName);
VOID DisplayPerms(IN LPTSTR filename,
									IN BOOL valid_access);
BOOL GetFilePermissions(
			 PSECURITY_DESCRIPTOR SecurityDescriptor,
			 PSID UserAccountSids);
BOOL IsDomainName(
			 LPSTR TestDomainName,
			 LPSTR DomainNameBuff);
BOOL ProcessAcl(
			 PACL Acl
			 );

BOOL SetBackOperatorPriv(HANDLE TokenHandle);
BOOL GetTokenHandle(PHANDLE TokenHandle);
BOOL GetFileSecurityBackup(
			LPSTR lpFileName,
			SECURITY_INFORMATION RequestedInformation,
			PSECURITY_DESCRIPTOR pSecurityDescriptor,
			DWORD nLength,
			LPDWORD lpnLengthNeeded,
			BOOL BackUpPrivFlag
			);

BOOL GetFileSecurityBackupW(
			LPWSTR lpFileName,
			SECURITY_INFORMATION RequestedInformation,
			PSECURITY_DESCRIPTOR pSecurityDescriptor,
			DWORD nLength,
			LPDWORD lpnLengthNeeded,
			BOOL UseBackUp
			);
VOID QuerySecAccessMask(
			IN SECURITY_INFORMATION SecurityInformation,
			OUT LPDWORD DesiredAccess
			);



BOOL CleanUpSource(IN LPTSTR InSting,
		 OUT LPTSTR OutString,
		 OUT BOOL *DirectoryFlag);

BOOL IsDirectory(IN LPTSTR InTestFile,
								 IN BOOL *ValidFile);

BOOL IsWildCard(IN LPSTR psz);

BOOL SetSlash(IN LPTSTR InString,
							IN OUT LPTSTR TestString);

BOOL RemoveEndSlash(LPSTR psz);

BOOL AddDotSlash(LPSTR TestString);

BOOL AddWildCards(LPSTR TestString);

BOOL IsLastCharSlash(LPSTR TestString);

BOOL StripRootDir(IN LPTSTR InDir,
		 OUT LPTSTR OutRootDir);

BOOL RemoveEndDot(LPSTR TestString);

BOOL IsRelativeString(LPSTR TestString);

//
// Macros for calculating the address of the components of a security
// descriptor.  This will calculate the address of the field regardless
// of whether the security descriptor is absolute or self-relative form.
// A null value indicates the specified field is not present in the
// security descriptor.
//

#define SepOwnerAddrSecurityDescriptor( SD )                                   \
					 ( ((SD)->Owner == NULL) ? (PSID)NULL :                             \
							 (   ((SD)->Control & SE_SELF_RELATIVE) ?                        \
											 (PSID)RtlOffsetToPointer((SD), (SD)->Owner)  :          \
											 (PSID)((SD)->Owner)                                     \
							 )                                                               \
					 )

#define SepGroupAddrSecurityDescriptor( SD )                                   \
					 ( ((SD)->Group == NULL) ? (PSID)NULL :                              \
							 (   ((SD)->Control & SE_SELF_RELATIVE) ?                        \
											 (PSID)RtlOffsetToPointer((SD), (SD)->Group)  :          \
											 (PSID)((SD)->Group)                                     \
							 )                                                               \
					 )

#define SepSaclAddrSecurityDescriptor( SD )                                    \
					 ( (!((SD)->Control & SE_SACL_PRESENT) || ((SD)->Sacl == NULL) ) ?   \
						 (PACL)NULL :                                                      \
							 (   ((SD)->Control & SE_SELF_RELATIVE) ?                        \
											 (PACL)RtlOffsetToPointer((SD), (SD)->Sacl)  :           \
											 (PACL)((SD)->Sacl)                                      \
							 )                                                               \
					 )

#define SepDaclAddrSecurityDescriptor( SD )                                    \
					 ( (!((SD)->Control & SE_DACL_PRESENT) || ((SD)->Dacl == NULL) ) ?   \
						 (PACL)NULL :                                                      \
							 (   ((SD)->Control & SE_SELF_RELATIVE) ?                        \
											 (PACL)RtlOffsetToPointer((SD), (SD)->Dacl)  :           \
											 (PACL)((SD)->Dacl)                                      \
							 )                                                               \
					 )


BOOL RecurseSubs(IN LPTSTR FileName,
						IN LPTSTR FilePath,
						IN PSID UserSid,
						IN BOOL BackPriv,
						IN BOOL Recurse);

VOID syserror(IN DWORD error_val);

#define LARGEPSID 2048
#define FILE_GEN_ALL 0x001f01ff
#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))
#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs\exports.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994
//
//  File:       exports.cxx
//
//  Contents:   Code to export word breaker class factories
//
//  History:    01-July-1996     PatHal   Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "classid.hxx"
#include "wbclassf.hxx"
#include "stemcf.hxx"

long gulcInstances = 0;

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE
DllGetClassObject(
    REFCLSID   cid,
    REFIID     iid,
    void **    ppvObj )
{
    IUnknown *  pResult = 0;
    SCODE       sc      = S_OK;

    __try {

        switch ( cid.Data1 ) {

        // Japanese language wordbreaker
        //
        case 0xcd169790:
           if ( cid == CLSID_Japanese_Default_WBreaker ) {
             pResult = (IUnknown *) new CWordBreakerCF(
                MAKELCID( MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT),
                SORT_DEFAULT ));
             sc = pResult->QueryInterface( iid, ppvObj );

             pResult->Release(); // Release extra refcount from QueryInterface
           }
           else
              sc = E_NOINTERFACE;
           break;

        // Japanese language stemmer
        //
        case 0xcdbeae30:
           if ( cid == CLSID_Japanese_Default_Stemmer )
           {
             pResult = (IUnknown *) new CStemmerCF(
                MAKELCID( MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT),
                SORT_DEFAULT ));
             sc = pResult->QueryInterface( iid, ppvObj );

             pResult->Release(); // Release extra refcount from QueryInterface
           }
           else
              sc = E_NOINTERFACE;
           break;

        // Chinese Traditional language wordbreaker
        //
        case 0x954f1760:
           if ( cid == CLSID_Chinese_Traditional_WBreaker ) 
		   {
             pResult = (IUnknown *) new CWordBreakerCF(
                MAKELCID( MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL),
                SORT_DEFAULT ));
             sc = pResult->QueryInterface( iid, ppvObj );

             pResult->Release(); // Release extra refcount from QueryInterface
           }
           else
              sc = E_NOINTERFACE;
           break;

        // Chinese Traditional language stemmer
        //
        case 0x969927e0:
           if ( cid == CLSID_Chinese_Traditional_Stemmer )
           {
             pResult = (IUnknown *) new CStemmerCF(
                MAKELCID( MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL),
                SORT_DEFAULT ));
             sc = pResult->QueryInterface( iid, ppvObj );

             pResult->Release(); // Release extra refcount from QueryInterface
           }
           else
              sc = E_NOINTERFACE;
           break;

        // Chinese Traditional language wordbreaker
        //
        case 0x9717fc70:
           if ( cid == CLSID_Chinese_Simplified_WBreaker ) 
		   {
             pResult = (IUnknown *) new CWordBreakerCF(
                MAKELCID( MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED),
                SORT_DEFAULT ));
             sc = pResult->QueryInterface( iid, ppvObj );

             pResult->Release(); // Release extra refcount from QueryInterface
           }
           else
              sc = E_NOINTERFACE;
           break;

        // Chinese Traditional language stemmer
        //
        case 0x9768f960:
           if ( cid == CLSID_Chinese_Simplified_Stemmer )
           {
             pResult = (IUnknown *) new CStemmerCF(
                MAKELCID( MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED),
                SORT_DEFAULT ));
             sc = pResult->QueryInterface( iid, ppvObj );

             pResult->Release(); // Release extra refcount from QueryInterface
           }
           else
              sc = E_NOINTERFACE;
           break;

        default:
             sc = E_NOINTERFACE;
        }
    } __except(1) {

        if ( pResult )
            pResult->Release();

        sc = E_UNEXPECTED;
    }

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllCanUnloadNow( void )
{
    if ( gulcInstances <= 0 )
        return( S_OK );
    else
        return( S_FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\thttp\thttp.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    thttp.c

Abstract:

    Simple test program for the HTTP API.

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

--*/

#include <windows.h>
#include <wininet.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <io.h>

//
// macros
//

#define IS_ARG(c)   ((c) == '-')

//
//  Private constants.
//

#define DEFAULT_CONTEXT 1
#define OPEN_CONTEXT    2
#define CONNECT_CONTEXT 3
#define REQUEST_CONTEXT 4

#define LOAD_ENTRY( hMod, Name )  \
   (p##Name = (pfn##Name) GetProcAddress( (hMod), #Name ))

//
//  Private types.
//

typedef struct _QUERY_LEVEL
{
    DWORD   QueryType;
    CHAR  * QueryName;

} QUERY_LEVEL;

#define MK_QUERY(x) { HTTP_QUERY_ ## x, #x }

typedef
INTERNETAPI
HINTERNET
(WINAPI *
pfnInternetOpenA)(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );

typedef
INTERNETAPI
INTERNET_STATUS_CALLBACK
(WINAPI *
pfnInternetSetStatusCallback)(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    );

typedef
INTERNETAPI
HINTERNET
(WINAPI *
pfnInternetConnectA)(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszUserName OPTIONAL,
    IN LPCSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );

typedef
INTERNETAPI
HINTERNET
(WINAPI *
pfnHttpOpenRequestA)(
    IN HINTERNET hConnect,
    IN LPCSTR lpszVerb,
    IN LPCSTR lpszObjectName,
    IN LPCSTR lpszVersion,
    IN LPCSTR lpszReferrer OPTIONAL,
    IN LPCSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnHttpAddRequestHeadersA)(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnHttpSendRequestA)(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnHttpQueryInfoA)(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnInternetCloseHandle)(
    IN HINTERNET hInternet
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnInternetReadFile)(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );

//
//  Private globals.
//

CHAR MoreHeaders[] = "Pragma: This is garbage!\r\n";

HMODULE hWininet;

LPTSTR AcceptTypes[] =
    {
        "*/*",
         NULL
    };

QUERY_LEVEL QueryLevels[] =
    {
        MK_QUERY( STATUS_CODE ),
        MK_QUERY( STATUS_TEXT ),
        MK_QUERY( VERSION ),
        MK_QUERY( MIME_VERSION ),

        MK_QUERY( CONTENT_TYPE ),
        MK_QUERY( CONTENT_TRANSFER_ENCODING ),
        MK_QUERY( CONTENT_ID     ),
        MK_QUERY( CONTENT_DESCRIPTION ),
        MK_QUERY( CONTENT_LENGTH ),
        MK_QUERY( CONTENT_LANGUAGE ),
        MK_QUERY( ALLOW ),
        MK_QUERY( PUBLIC ),
        MK_QUERY( DATE ),
        MK_QUERY( EXPIRES ),
        MK_QUERY( LAST_MODIFIED ),
        MK_QUERY( MESSAGE_ID ),
        MK_QUERY( URI ),
        MK_QUERY( DERIVED_FROM ),
        MK_QUERY( COST ),
        MK_QUERY( LINK ),
        MK_QUERY( PRAGMA ),
        MK_QUERY( CONNECTION ),
        MK_QUERY( RAW_HEADERS_CRLF )
    };
#define NUM_LEVELS (sizeof(QueryLevels) / sizeof(QueryLevels[0]))

BOOL Verbose = FALSE;
BOOL Quiet   = FALSE;   // Don't print failed headers and content
BOOL Recurse = FALSE;   // Follow links
BOOL Cache   = FALSE;   // Don't allow caching (i.e., force reload)
BOOL Stats   = FALSE;   // Print stats
BOOL Logs   = FALSE;    // Print log
BOOL LargeBuf= TRUE;   // Use 8k reads rather then 512 byte
BOOL KeepAlive = FALSE;
DWORD AccessType = PRE_CONFIG_INTERNET_ACCESS;
BOOL EnableCallbacks = FALSE;
BOOL UserSuppliedContext = FALSE;

INTERNET_STATUS_CALLBACK PreviousCallback;

DWORD cLevel     = 0;   // Current recurse level
DWORD cMaxLevel  = 10;  // Max Recurse level
DWORD cbReceived = 0;
DWORD cmsecStart = 0;
DWORD cFiles     = 0;
DWORD cIterations= 1;   // Total iterations to perform request

LPSTR GatewayServer = NULL;

INTERNET_PORT nServerPort = 0;

DWORD LogError = ERROR_SUCCESS;

HANDLE AsyncEvent = NULL;
BOOL AsyncMode = FALSE;
DWORD AsyncResult;
DWORD AsyncError;
DWORD Context = 0;


pfnInternetOpenA              pInternetOpenA;
pfnInternetSetStatusCallback  pInternetSetStatusCallback;
pfnInternetConnectA           pInternetConnectA;
pfnHttpOpenRequestA           pHttpOpenRequestA;
pfnHttpAddRequestHeadersA     pHttpAddRequestHeadersA;
pfnHttpSendRequestA           pHttpSendRequestA;
pfnHttpQueryInfoA             pHttpQueryInfoA;
pfnInternetCloseHandle        pInternetCloseHandle;
pfnInternetReadFile           pInternetReadFile;


//
//  Private prototypes.
//

void usage(void);

DWORD
DoTest(
    LPSTR Host,
    LPSTR Verb,
    LPSTR Object
    );

BOOL
add_headers(
    HINTERNET hHttpRequest,
    LPSTR lpszHeaders,
    DWORD dwHeadersLength
    );

void my_callback(HINTERNET, DWORD, DWORD, LPVOID, DWORD);

VOID
FindLink(
    LPSTR   Host,
    LPSTR   Verb,
    CHAR *  buf,
    DWORD   len,
    CHAR *  pchLink,
    BOOL *  pfCopyingLink,
    CHAR *  pchReferer
    );

DWORD ReadHtml(HINTERNET hInternet, LPVOID buf, DWORD len, LPDWORD pRead);

BOOL
LoadWininet(
    VOID
    );

//
//  Public functions.
//


int
__cdecl
main(
    int   argc,
    char * argv[]
    )
{
    LPSTR host = NULL;
    LPSTR verb = NULL;
    LPSTR object = NULL;

    if ( !LoadWininet() )
    {
        printf(" Unable to load wininet.dll, error %d\n", GetLastError() );
        return GetLastError();
    }

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case '?':
                usage();
                break;

            case 'c':
                EnableCallbacks = TRUE;
                break;

            case 'C':
                Cache = TRUE;
                break;

            case 'G':
                printf("'G' flag is not supported at this time\n");
                GatewayServer = ++*argv;
                //AccessType = GATEWAY_INTERNET_ACCESS;
                break;

            case 'i':

                if ( isdigit( argv[0][1] ))
                {
                    cIterations = atoi( ++*argv );

                    while ( isdigit( *(*argv)++ ))
                        ;
                }
                break;

            case 'k':
                KeepAlive = TRUE;
                break;

            case 'l':
                LargeBuf = TRUE;
                break;

            case 'L':
                AccessType = LOCAL_INTERNET_ACCESS;
                break;

            case 'p':
                object = ++*argv;
                break;

            case 'P':

                if ( isdigit( argv[0][1] ))
                {
                    nServerPort = (INTERNET_PORT)atoi( ++*argv );

                    while ( isdigit( *(*argv)++ ))
                        ;
                }
                break;

            case 'q':
                Quiet = TRUE;
                break;

            case 'r':
                Recurse = TRUE;

                if ( isdigit( argv[0][1] ))
                {
                    cMaxLevel = atoi( ++*argv );

                    while ( isdigit( *(*argv)++ ))
                        ;
                }
                break;

            case 's':
                Stats = TRUE;
                cmsecStart = GetTickCount();
                break;

            case 'v':
                Verbose = TRUE;
                break;

            case 'x':
                ++*argv;
                if (!**argv) {
                    Context = DEFAULT_CONTEXT;
                } else {
                    Context = (DWORD)strtoul(*argv, NULL, 0);
                    UserSuppliedContext = TRUE;
                }
                break;

            case 'y':
                AsyncMode = TRUE;
                break;

            case 'z':
                Logs = TRUE;
                cmsecStart = GetTickCount();
                break;

            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
            }
        } else if (!host) {
            host = *argv;
        } else if (!verb) {
            verb = *argv;
        } else if (!object) {
            object = *argv;
        } else {
            printf("error: unrecognized command line argument: \"%s\"\n", *argv);
            usage();
        }
    }

    if (!verb) {
        verb = "GET";
    }

    if (!object) {
        object = "\r\n";
    }

    if (!(host && verb && object)) {
        printf("error: missing command-line argument\n");
        usage();
    }

    if (AsyncMode) {

        //
        // create an auto-reset event
        //

        AsyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    }

    //
    //  Make stdout "binary" so we can retrieve GIFs, JPEGs, etc.
    //

    _setmode( _fileno( stdout ), _O_BINARY );

    //
    //  Perform some tests.
    //

    while ( cIterations-- )
    {
        DWORD Error;

        Error = DoTest(host, verb, object );

        if( Error != ERROR_SUCCESS ) {
            LogError = Error;
        }
    }

    if ( Stats )
    {
        DWORD csecTotal = (GetTickCount() - cmsecStart) / 1000;
        DWORD cMin      = csecTotal / 60;
        DWORD cSec      = csecTotal % 60;

        fprintf( stderr,
                 "=====================================\n"
                 "Total data bytes received: %ld\n"
                 "Total files retrieved:     %ld\n"
                 "Total time:                %d:%d\n"
                 "=====================================\n",
                 cbReceived,
                 cFiles,
                 cMin,
                 cSec );
    }

    if ( Logs )
    {
        DWORD csecTotal = (GetTickCount() - cmsecStart) ;
        SYSTEMTIME SystemTime;

        GetLocalTime( &SystemTime );

        fprintf( stderr,
                "LOG: [%02u/%02u %02u:%02u:%02u] "
                 "%-10s %-32s %4s %8d %8d\n",
                    SystemTime.wMonth,
                    SystemTime.wDay,
                    SystemTime.wHour,
                    SystemTime.wMinute,
                    SystemTime.wSecond,
                        GatewayServer,
                        host,
                        object,
                        LogError,
                        csecTotal );
    }


    return 0;

}   // main

void usage() {
    printf("usage: thttp [-c] [-C] [-l] [-L] [-k] [-p<path>] [-q] [-r] [-s] [-v] [-P]\n"
                "        [-x$] [-y] [-z] [-G<servername>] <host> [<verb>] [<object>]\n"
           "\n"
           "where: -c    = Enable call-backs\n"
           "       -C    = Enable caching\n"
           "       -i[n] = Iterate n times\n"
           "       -l    = Large network buffer\n"
           "       -L    = Force local access (i.e., do not use gateway)\n"
           "       -k    = Use Keep-Alive\n"
           "       -p    = path (e.g. if path starts with '/')\n"
           "       -q    = Quiet mode, no failed headers, no content\n"
           "       -r[n] = Recurse into links, n = max recurse level\n"
           "       -s    = Print network statistics\n"
           "       -v    = Verbose mode\n"
           "       -G    = specific gateway server\n"
           "       -P[n] = Use port n; default = 80\n"
           "       -x    = Context value. $ is number string (binary, hex, decimal)\n"
           "       -y    = Async mode\n"
           "       -z    = print log\n"
           "Verb defaults to \"GET\"\n"
           "Object defaults to \"\\r\\n\"\n"
           );
    exit(1);
}

BOOL
LoadWininet(
    VOID
    )
{
    if ( !(hWininet = LoadLibrary( "wininet.dll" )) )
    {
        printf("Failed to load wininet.dll\n" );
        return FALSE;
    }

    if ( !LOAD_ENTRY( hWininet, InternetOpenA ) ||
         !LOAD_ENTRY( hWininet, InternetSetStatusCallback ) ||
         !LOAD_ENTRY( hWininet, InternetConnectA ) ||
         !LOAD_ENTRY( hWininet, HttpOpenRequestA ) ||
         !LOAD_ENTRY( hWininet, HttpAddRequestHeadersA ) ||
         !LOAD_ENTRY( hWininet, HttpSendRequestA ) ||
         !LOAD_ENTRY( hWininet, HttpQueryInfoA ) ||
         !LOAD_ENTRY( hWininet, InternetCloseHandle ) ||
         !LOAD_ENTRY( hWininet, InternetReadFile ) )
    {
        return FALSE;
    }

    return TRUE;
}

DWORD
DoTest(
    LPSTR Host,
    LPSTR Verb,
    LPSTR Object
    )
{
    DWORD Error = ERROR_SUCCESS;
    HINTERNET InternetHandle = NULL;
    HINTERNET InternetConnectHandle = NULL;
    HINTERNET hhttp = NULL;
    DWORD     len;
    int       i;
    CHAR      buf[8192];
    CHAR      bufLink[512];
    BOOL      fCopyingLink = FALSE;

    *bufLink = '\0';

    //
    // open internet.
    //

    if (Verbose) {
        printf("calling InternetOpen()...\n");
    }

    InternetHandle = pInternetOpenA(
                        "THTTP: HTTP API Test Application", // lpszCallerName
                        AccessType,                         // dwAccessType
                        GatewayServer,                      // lpszProxyName
                        INTERNET_INVALID_PORT_NUMBER,       // nProxyPort
                        AsyncMode ? INTERNET_FLAG_ASYNC : 0 // dwFlags (async)
                        );
    if (InternetHandle == NULL) {
        if (AsyncMode) {
            Error = GetLastError();
            if (Error == ERROR_IO_PENDING) {
                if (Verbose) {
                    fprintf(stderr, "error: InternetOpen() is async (spanish inquisition mode)\n");
                    printf("waiting for async InternetOpen()...\n");
                }
                WaitForSingleObject(AsyncEvent, INFINITE);
                if (AsyncResult == 0) {
                    fprintf(stderr, "error: async InternetOpen() returns %d\n",
                        AsyncError);
                    goto Cleanup;
                } else {
                    InternetHandle = (HINTERNET)AsyncResult;
                }
            } else {
                fprintf(stderr, "error: async InternetOpen() returns %d\n", Error);
                goto Cleanup;
            }
        } else {
            fprintf( stderr,
                     "InternetOpen() failed, error %d\n",
                        Error = GetLastError() );

            goto Cleanup;
        }
    }

    if (Verbose) {
        printf("InternetOpen() returns %x\n", InternetHandle);
    }

    if (EnableCallbacks) {

        //
        // let's have a status callback
        //
        // Note that call-backs can be set even before we have opened a handle
        // to the internet/gateway
        //

        PreviousCallback = pInternetSetStatusCallback(InternetHandle, my_callback);
        if (Verbose) {
            printf("previous Internet callback = %x\n", PreviousCallback);
        }
    }


    //
    // Call internet connect to connect to the http server.
    //

    if (Verbose) {
        printf("calling InternetConnect()...\n");
    }

    InternetConnectHandle = pInternetConnectA(
                                InternetHandle,         // hInternetSession
                                Host,                   // lpszServerName
                                nServerPort,            // nServerPort
                                NULL,                   // lpszUserName
                                NULL,                   // lpszPassword
                                INTERNET_SERVICE_HTTP,  // dwService
                                0,                      // dwFlags
                                UserSuppliedContext ? Context : CONNECT_CONTEXT
                                );


    if( InternetConnectHandle == NULL )
    {
        if (AsyncMode) {
            Error = GetLastError();
            if (Error == ERROR_IO_PENDING) {
                if (Verbose) {
                    fprintf(stderr, "error: InternetConnect() is async (spanish inquisition mode)\n");
                    printf("waiting for async InternetConnect()...\n");
                }
                WaitForSingleObject(AsyncEvent, INFINITE);
                if (AsyncResult == 0) {
                    fprintf(stderr, "error: async InternetConnect() returns %d\n",
                        AsyncError);
                    goto Cleanup;
                } else {
                    InternetConnectHandle = (HINTERNET)AsyncResult;
                }
            } else {
                fprintf(stderr, "error: async InternetConnect() returns %d\n", Error);
                goto Cleanup;
            }
        } else {
            fprintf( stderr,
                     "InternetConnect() failed, error %d\n",
                        Error = GetLastError() );

            goto Cleanup;
        }
    }

    if (Verbose) {
        printf("InternetConnect() returns %x\n", InternetConnectHandle);
    }

    //
    //  Open a request handle.
    //

    if (Verbose) {
        printf("calling HttpOpenRequest()...\n");
    }

    hhttp = pHttpOpenRequestA(
                InternetConnectHandle,      // hHttpSession
                Verb,                       // lpszVerb
                Object,                     // lpszObjectName
                NULL,                       // lpszVersion
                NULL,                       // lpszReferer
                AcceptTypes,                // lplpszAcceptTypes
                (Cache ? 0 :
                         INTERNET_FLAG_RELOAD),
                UserSuppliedContext ? Context : REQUEST_CONTEXT
                );

    if( hhttp == NULL )
    {
        if (AsyncMode) {
            Error = GetLastError();
            if (Error == ERROR_IO_PENDING) {
                if (Verbose) {
                    fprintf(stderr, "error: HttpOpenRequest() is async (spanish inquisition mode)\n");
                    printf("waiting for async HttpOpenRequest()...\n");
                }
                WaitForSingleObject(AsyncEvent, INFINITE);
                if (AsyncResult == 0) {
                    fprintf(stderr, "error: async HttpOpenRequest() returns %d\n",
                        AsyncError);
                    goto Cleanup;
                } else {
                    hhttp = (HINTERNET)AsyncResult;
                }
            } else {
                fprintf(stderr, "error: async HttpOpenRequest() returns %d\n", Error);
                goto Cleanup;
            }
        } else {
            fprintf( stderr,
                     "HttpOpenRequest() failed, error %d\n",
                        Error = GetLastError() );

            goto Cleanup;
        }
    }

    if (Verbose) {
        printf("HttpOpenRequest() returns %x\n", hhttp);
    }

    //
    // add keep-alive header if requested
    //

    if (KeepAlive) {
        if (!add_headers(hhttp, "Connection: Keep-Alive\r\n", (DWORD)-1)) {
            fprintf(stderr, "HttpAddRequestHeaders() returns %d\n", GetLastError());
        }
    }

    //
    //  Add additional request headers.
    //

    if( !add_headers(
            hhttp,
            "Pragma: bite-me\r\n",
            (DWORD)-1L ) )
    {
        fprintf( stderr,
                 "HttpAddRequestHeaders() failed, error %d\n",
                 GetLastError() );
    }

    if( !add_headers(
            hhttp,
            "Pragma: bite-me-again\r\n",
            (DWORD)-1L ) )
    {
        fprintf( stderr,
                 "HttpAddRequestHeaders() failed, error %d\n",
                 GetLastError() );
    }

    if( !add_headers(
            hhttp,
            "Pragma: bite-me-a-third-time\r\n",
            (DWORD)-1L ) )
    {
        fprintf( stderr,
                 "HttpAddRequestHeaders() failed, error %d\n",
                 GetLastError() );
    }

    //
    //  Send the request.
    //

    if (Verbose) {
        printf("calling HttpSendRequest()...\n");
    }

    if( !pHttpSendRequestA(
            hhttp,          // hHttpRequest
            MoreHeaders,    // lpszHeaders
            (DWORD)-1L,     // dwHeadersLength
            NULL,           // lpOptional
            0 ) )           // dwOptionalLength
    {
        if (AsyncMode) {
            Error = GetLastError();
            if (Error == ERROR_IO_PENDING) {
                if (Verbose) {
                    printf("HttpSendRequest() waiting for async completion\n");
                }
                WaitForSingleObject(AsyncEvent, INFINITE);
                Error = AsyncError;
                if (!AsyncResult) {
                    printf("error: ASYNC HttpSendRequest() returns FALSE\n");
                    if (Error == ERROR_SUCCESS) {
                        printf("error: ASYNC HttpSendRequest() (FALSE) returns ERROR_SUCCESS!\n");
                    } else {
                        printf("ASYNC HttpSendRequest() returns %d\n", Error);
                    }
                } else if (Verbose) {
                    printf("ASYNC HttpSendRequest() success\n");
                }
            } else {
                printf("error: ASYNC HttpSendRequest() returns %d\n", Error);
            }
        } else {
            fprintf( stderr,
                     "HttpSendRequest() failed, error %d\n",
                        Error = GetLastError() );
        }
    } else if (AsyncMode) {

        //
        // we expect async HttpSendRequest() to always return FALSE w/ error
        // or ERROR_IO_PENDING
        //

        printf("ASYNC HttpSendRequest() returns TRUE\n");
    // } else {

        //
        // Error is still ERROR_SUCCESS from initialization
        //

    }

    if (Error == ERROR_SUCCESS) {

        //
        //  Process the queries.
        //

        if ( Quiet )
        {
            len = sizeof(buf);

            //
            //  Only look for failures to retrieve if we're in quiet mode
            //

            if ( !pHttpQueryInfoA(
                    hhttp,
                    HTTP_QUERY_STATUS_CODE,
                    buf,
                    &len,
                    NULL ))
            {
                fprintf( stderr,
                         "HttpQueryInfo( HTTP_QUERY_STATUS_CODE ) failed, error %d\n",
                         GetLastError() );
            }

            if ( *buf != '2' )
            {
                Error = atoi(buf);
                goto PrintAllHeaders;
            }

            cFiles++;
        }
        else
        {
PrintAllHeaders:

            if( !Logs ) {
                for( i = 0 ; i < NUM_LEVELS ; i++ )
                {
                    len = sizeof(buf);

                    if( !pHttpQueryInfoA(
                            hhttp,
                            QueryLevels[i].QueryType,
                            buf,
                            &len,
                            NULL ) )
                    {
                        if ( QueryLevels[i].QueryType == HTTP_QUERY_STATUS_CODE &&
                             *buf == '2' )
                        {
                            cFiles++;
                        }

                        if ( !Quiet && GetLastError() != ERROR_HTTP_HEADER_NOT_FOUND )
                        {
                            fprintf( stderr,
                                     "HttpQueryInfo( %s ) failed, error %d\n",
                                     QueryLevels[i].QueryName,
                                     GetLastError() );
                        }
                    }
                    else
                    {
                        fprintf( stderr,
                                 "%s = %s\n",
                                 QueryLevels[i].QueryName,
                                 buf );
                    }
                }
            }
        }

        //
        //  Read the data.
        //

        for( ; ; )
        {
            len = LargeBuf ? sizeof(buf) : 512;

            Error = ReadHtml(hhttp, buf, len, &len);
            if (Error != ERROR_SUCCESS) {
                fprintf( stderr,
                         "InternetReadFile() failed, error %d\n",
                            Error = GetLastError() );

                break;
            }

            cbReceived += len;

            if( len == 0 )
            {
                if ( !Quiet )
                {
                    fprintf( stderr,
                             "EOF\n" );
                }

                break;
            }

            if ( !Quiet )
            {
                fwrite( buf, 1, (size_t)len, stdout );
            }

            if ( Recurse && cLevel < cMaxLevel )
            {
                CHAR ContentType[50];
                DWORD cbContentType = sizeof( ContentType );

                //
                //  Only look for links if the content type is text/html
                //

                if( pHttpQueryInfoA(
                        hhttp,
                        HTTP_QUERY_CONTENT_TYPE,
                        ContentType,
                        &cbContentType,
                        NULL ) &&
                    !_stricmp( ContentType,
                              "text/html" ))
                {
                    FindLink( Host,
                              Verb,
                              buf,
                              len,
                              bufLink,
                              &fCopyingLink,
                              Object );
                }
            }
        }

        //
        //  Perform an extraneous read.
        //

        len = sizeof(buf);

        Error = ReadHtml(hhttp, buf, len, &len);
        if (Error != ERROR_SUCCESS) {
            fprintf( stderr,
                     "InternetReadFile() failed, error %d\n",
                      Error = GetLastError() );
        }
        else
        if( len != 0 )
        {
            fprintf( stderr,
                     "BOGUS EXTRANEOUS READ: %d\n",
                     len );
        }
    }

Cleanup:

    //
    //  Close handles.
    //

    if( hhttp != NULL )
    {
        if( !pInternetCloseHandle( hhttp ) )
        {
            fprintf( stderr,
                     "InternetCloseHandle() failed, error %d\n",
                     GetLastError() );
        }
    }

    if( InternetConnectHandle != NULL )
    {
        if( !pInternetCloseHandle( InternetConnectHandle ) )
        {
            fprintf( stderr,
                     "InternetCloseHandle() failed, error %d\n",
                     GetLastError() );
        }
    }

    if( InternetHandle != NULL )
    {
        if( !pInternetCloseHandle( InternetHandle ) )
        {
            fprintf( stderr,
                     "InternetCloseHandle() failed, error %d\n",
                     GetLastError() );
        }
    }

    cLevel--;
    return( Error );
}   // DoTest

BOOL
add_headers(
    HINTERNET hHttpRequest,
    LPSTR lpszHeaders,
    DWORD dwHeadersLength
    )
{
    BOOL ok;

    ok = pHttpAddRequestHeadersA(hHttpRequest, lpszHeaders, dwHeadersLength, 0);
    if (AsyncMode) {
        if (!ok) {

            DWORD err;

            err = GetLastError();
            if (err == ERROR_IO_PENDING) {
                if (Verbose) {
                    printf("warning: HttpAddRequestHeaders() is async - unexpected\n");
                    printf("waiting for async HttpAddRequestHeaders()...\n");
                }
                WaitForSingleObject(AsyncEvent, INFINITE);
                ok = (BOOL)AsyncResult;
                if (!ok) {
                    printf("error: async HttpAddRequestHeaders() returns %d\n",
                        AsyncError);
                }
            } else {
                printf("error: async HttpAddRequestHeaders() returns %d\n", err);
            }
        }
    }
    return ok;
}

VOID
my_callback(
    HINTERNET hInternet,
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    )
{
    char* type$;
    BOOL unknown = FALSE;

    switch (Status) {
    case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

    case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

    case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

    case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

    case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

    case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

    case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

    case INTERNET_STATUS_REQUEST_COMPLETE:
        type$ = "REQUEST COMPLETE";
        if (AsyncMode) {
            AsyncResult = ((LPINTERNET_ASYNC_RESULT)Info)->dwResult;
            AsyncError = ((LPINTERNET_ASYNC_RESULT)Info)->dwError;
            SetEvent(AsyncEvent);
        } else {
            printf("error: REQUEST_COMPLETE not expected - not async\n");
        }
        break;

    default:
        type$ = "???";
        unknown = TRUE;
        break;
    }
    if (Verbose) {
        printf("callback: handle %x [context %x [%s]] %s ",
                hInternet,
                Context,
                UserSuppliedContext             ? "User"
                : (Context == DEFAULT_CONTEXT)  ? "Default"
                : (Context == OPEN_CONTEXT)     ? "Open"
                : (Context == CONNECT_CONTEXT)  ? "Connect"
                : (Context == REQUEST_CONTEXT)  ? "Request"
                : "???",
                type$
                );
        if (Info && !unknown) {
            if (Status == INTERNET_STATUS_REQUEST_COMPLETE) {
                if (Verbose) {
                    printf("dwResult = %x, dwError = %d\n",
                            ((LPINTERNET_ASYNC_RESULT)Info)->dwResult,
                            ((LPINTERNET_ASYNC_RESULT)Info)->dwError
                            );
                }
            } else {
                printf(Info);
            }
        }
        putchar('\n');
    }
}

VOID
FindLink(
    LPSTR   Host,
    LPSTR   Verb,
    CHAR *  buf,
    DWORD   len,
    CHAR *  pchLink,
    BOOL *  pfCopyingLink,
    CHAR *  pchReferer
    )
{
    DWORD Error;
    CHAR * pchEnd = buf + len;
    CHAR * pch = buf;
    DWORD  cchLink = strlen( pchLink );

    while ( TRUE )
    {
        if ( *pfCopyingLink )
        {
FindEOT:
            //
            //  Look for end of href
            //

            while ( pch < pchEnd )
            {
                if ( *pch == '"' )
                    goto FoundEOT;

                pchLink[cchLink++] = *pch;

                pch++;
            }

            //
            //  Used up all of the buffer and we didn't find the end of the tag,
            //  get some more data
            //

            pchLink[cchLink] = '\0';

            return;

FoundEOT:
            pchLink[cchLink] = '\0';
            *pfCopyingLink = FALSE;

            //
            //  We only traverse URLs of the form '/dir/bar/doc.htm'
            //

            if ( pchLink[0] != '/' )
            {
                CHAR * pchLastSlash;
                CHAR   achTemp[512];

                //
                //  If it's relative, use the referer to make it absolute
                //
                //  Note we don't process /dir/bar/doc.htm#GoHere tags
                //

                if ( (pchLastSlash = strrchr( pchReferer, '/' )) &&
                     strncmp( pchLink, "ftp:", 4 )               &&
                     strncmp( pchLink, "http:", 5 )              &&
                     strncmp( pchLink, "gopher:", 7 )            &&
                     strncmp( pchLink, "mailto:", 7 )            &&
                     !strchr( pchLink, '#' ))
                {
                    *(pchLastSlash + 1) = '\0';
                    strcpy( achTemp, pchReferer );
                    strcat( achTemp, pchLink );
                    strcpy( pchLink, achTemp );
                }
                else
                {
                    fprintf( stderr,
                             "Ignoring %s\n",
                             pchLink );
                    return;
                }
            }

            fprintf( stderr,
                     "Traversing %s\n",
                     pchLink );

            cLevel++;

            Error = DoTest(
                            Host,
                            Verb,
                            pchLink );

            if( Error != ERROR_SUCCESS ) {
                LogError = Error;
            }

        }
        else
        {
            *pchLink = '\0';

            //
            //  Scan for the beginning of an href tag
            //

            while ( pch < pchEnd )
            {
                if ( *pch == '<' )
                {
                    //
                    //  Look for "<A HREF="", note we aren't flexible about spacing
                    //

                    if ( !_strnicmp( pch, "<A HREF=\"", 9 ) ||
                         !_strnicmp( pch, "<IMG SRC=\"", 10 ))
                    {
                        pch += (toupper(pch[1]) == 'A' ? 9 : 10);
                        *pfCopyingLink = TRUE;
                        cchLink = 0;
                        goto FindEOT;
                    }
                }

                pch++;
            }

            //
            //  No tag found, return
            //

            return;
        }
    }
}

DWORD ReadHtml(HINTERNET hInternet, LPVOID buf, DWORD len, LPDWORD pRead) {

    DWORD error = ERROR_SUCCESS;

    if (!pInternetReadFile(hInternet, buf, len, pRead)) {
        if (AsyncMode) {
            error = GetLastError();
            if (error == ERROR_IO_PENDING) {
                if (Verbose) {
                    printf("ASYNC InternetReadFile() waiting for async completion\n");
                }
                WaitForSingleObject(AsyncEvent, INFINITE);
                error = AsyncError;
                if (!AsyncResult) {
                    printf("error: ASYNC InternetReadFile() returns FALSE\n");
                    if (error == ERROR_SUCCESS) {
                        printf("error: ASYNC InternetReadFile() (FALSE) returns ERROR_SUCCESS!\n");
                    } else {
                        printf("ASYNC InternetReadFile() returns %d\n", error);
                    }
                } else if (Verbose) {
                    printf("ASYNC InternetReadFile() success\n");

                    //
                    // error should be ERROR_SUCCESS from callback
                    //

                    if (error != ERROR_SUCCESS) {
                        printf("error: async error = %d. Expected ERROR_SUCCESS\n", error);
                    }
                }
            } else {
                printf("error: ASYNC InternetReadFile() returns %d\n", error);
            }
        } else {
            error = GetLastError();
            printf("error: SYNC InternetReadFile() returns %d\n", error);
        }
    } else if (AsyncMode) {

        //
        // we expect async InternetReadFile() to always return FALSE w/ error
        // or ERROR_IO_PENDING
        //

        if (Verbose) {
            printf("ASYNC InternetReadFile() returns TRUE\n");
        }
    } else {

        //
        // error is still ERROR_SUCCESS from initialization
        //

        if (Verbose) {
            printf("SYNC InternetReadFile() returns TRUE\n");
        }
    }
    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\terrain\tools\metasnap\metasnap.cpp ===
//***********************************************************
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  metasnap.cpp
//  
//  Description: Metabase Snapshot utility tool main  
//
//  History: 15-July-98  Tamas Nemeth (t-tamasn)  Created.
//
//***********************************************************

//#define NDEBUG
//#define WIN32
#define INITGUID

//#define _WINDOWSWIN32
//#define WIN32_WINNT     0x400

//#define _WIN32WIN_
//#define UNICODE
//#define MD_CHECKED

#define DEFAULT_MD_TIMEOUT 20000 // 20 seconds
#define DEFAULT_GETALL_BUFFER_SIZE  65536  // 64k
#include <wchar.h>

#include <afx.h>
#include <objbase.h>
#include <coguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <mbstring.h>

#include "convert.h"
#include "iadmw.h"
#include "iiscnfg.h"

struct _CMD_PARAMS
{
	LPWSTR pwstrMachineName;
	LPWSTR pwstrStartKey;
	BOOL bShowSecure; 
};

typedef struct _CMD_PARAMS CMD_PARAMS;
typedef CString* pCString;

// Global variables:

PBYTE     g_pbGetAllBuffer;
DWORD	  g_dwGetAllBufferSize;
DWORD*    g_dwSortArray;
pCString* g_pstrPropName;

// Function prototypes:

HRESULT PrintKeyRecursively(IMSAdminBase *  pcAdmCom, 
							WCHAR *         lpwstrFullPath,
							METADATA_HANDLE hmdHandle, 
							WCHAR *         lpwstrRelPath,
							BOOL            bShowSecure);

HRESULT PrintAllPropertiesAtKey(IMSAdminBase*   pcAdmCom, 
								METADATA_HANDLE hmdHandle, 
								BOOL            bShowSecure);

VOID PrintProperty(METADATA_GETALL_RECORD&  mdr, 
				   pCString                 pstrPropName, 
				   BOOL                     bShowSecure);

VOID PrintDataTypeAndValue(METADATA_GETALL_RECORD *  pmdgr, 
						   BOOL                      bShowSecure);

HRESULT ParseCommands(int          argc, 
					  char *       argv[],
					  CMD_PARAMS * pcpCommands);

VOID DisplayHelp();

// Comparison functions required by qsort:

int __cdecl PropNameCompare(const void *index1,
					const void *index2);

int __cdecl PropIDCompare(const void *index1,
				  const void *index2);




HRESULT __cdecl main(int argc, char *argv[])
/*++

Routine Description:

    Metabase Snapshot Tool main.

Arguments:
    
	  argc, argv[]     Standard command line input.

Return Value:

    HRESULT - ERROR_SUCCESS
			  E_OUTOFMEMORY
			  E_INVALIDARG
              Errors returned by COM Interface
			  Errors returned by MultiByteToWideChar converted to HRESULT
--*/
{
	if (argc == 1)
	{
		DisplayHelp();
		return ERROR_SUCCESS;
	}

	// Parse command line arguments:
	CMD_PARAMS cpCommands;
	HRESULT hresError = ParseCommands(argc, argv, &cpCommands);

	if (hresError != ERROR_SUCCESS)
	{
		if (hresError == E_OUTOFMEMORY)
			fprintf (stderr, "ERROR: Out of memory.");
		else if (hresError == E_INVALIDARG)
			fprintf (stderr, "ERROR: Invalid arguments.");
		else 
			fprintf (stderr,"ERROR: Couldn't process arguments. Error: %d (%#x)\n", hresError, hresError);

		fprintf(stderr, " Enter \"metasnap\" without arguments for help.\n");
		return hresError;
	}
	
	// Allocate memory:
	g_dwGetAllBufferSize = DEFAULT_GETALL_BUFFER_SIZE;
	g_pbGetAllBuffer = (PBYTE) HeapAlloc (GetProcessHeap(),
										  HEAP_ZERO_MEMORY,
										  DEFAULT_GETALL_BUFFER_SIZE);

	if (g_pbGetAllBuffer == NULL)
	{	
		fprintf(stderr, "ERROR: Out of memory.\n");
		return E_OUTOFMEMORY;
	}

	// Here come some COM function calls:

	IMSAdminBase *pcAdmCom = NULL;   //interface pointer
	IClassFactory * pcsfFactory = NULL;
	COSERVERINFO csiMachineName;
	COSERVERINFO *pcsiParam = NULL;

	// Fill the structure for CoGetClassObject:
		csiMachineName.pAuthInfo = NULL;
		csiMachineName.dwReserved1 = 0;
		csiMachineName.dwReserved2 = 0;
		pcsiParam = &csiMachineName;
		csiMachineName.pwszName = cpCommands.pwstrMachineName;

	// Initialize COM:
    hresError = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (FAILED(hresError))
	{
		fprintf (stderr, "ERROR: COM Initialization failed. Error: %d (%#x)\n", hresError, hresError);
        return hresError;
	}

	hresError = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
							IID_IClassFactory, (void**) &pcsfFactory);

	if (FAILED(hresError)) 
	{
		switch (hresError)
		{
		case HRESULT_FROM_WIN32(REGDB_E_CLASSNOTREG): 
			fprintf(stderr, "ERROR: IIS Metabase does not exist.\n");
			break;
		case HRESULT_FROM_WIN32(E_ACCESSDENIED): 
			fprintf(stderr, "ERROR: Access to Metabase denied.\n");
			break;
		case HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE):  
			fprintf(stderr, "ERROR: The specified host is unavailable.\n");
			break;
 		default:
			fprintf (stderr, "ERROR: Couldn't get Metabase Object. Error: %d (%#x)\n", hresError, hresError);
			break;
		}
        return hresError;
	}

	hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &pcAdmCom);

	if (FAILED(hresError)) 
	{
		switch (hresError)
		{
		case HRESULT_FROM_WIN32(RPC_S_SEC_PKG_ERROR):
			fprintf (stderr, "ERROR: A security-related error occurred.\n");
			break;
		case E_OUTOFMEMORY:
			fprintf (stderr, "ERROR: There is not enough memory available.\n");
			break;
		default:
			fprintf (stderr, "ERROR: Couldn't create Metabase Instance. Error: %d (%#x)\n", hresError, hresError);
			break;
		}
		pcsfFactory->Release();
		return hresError;
	}

	pcsfFactory->Release();
	
	// Print header line:
	printf(" ID         NAME                            ATTRIB  USERTYPE    SIZE    DATATYPE    VALUE\n");

	// Recursively print metabase from StartKey:
	hresError = PrintKeyRecursively(pcAdmCom, 
									cpCommands.pwstrStartKey,
									METADATA_MASTER_ROOT_HANDLE, 
									cpCommands.pwstrStartKey, 
									cpCommands.bShowSecure);

	if (hresError != ERROR_SUCCESS)
		fprintf (stderr, "ERROR: Failed dumping metabase. Error: %u (%#x)\n", hresError, hresError);
	else
		fprintf (stderr, "Successfully dumped metabase.\n");

	pcAdmCom->Release();
	return hresError;

} // end main




HRESULT ParseCommands (int			argc, 
					   char *		argv[], 
					   CMD_PARAMS*	pcpCommands)
/*++

Routine Description:

    Parses the argument vector into a command parameters structure.

Arguments:

	argc          Number of arguments.
	
	argv[]        Argument vector.
	
	pcpCommands   Pointer to a command parameters struct.

Return Value:

    HRESULT - ERROR_SUCCESS
              E_INVALIDARG
			  E_OUTOFMEMORY
			  Errors returned by MultiByteToWideChar converted to HRESULT		
--*/
{
	if ( (argc < 2) || (argc > 4) )
		return E_INVALIDARG;

	// Allocate buffers:
	DWORD dwStartKeyLen = _mbstrlen(argv[1]);
	pcpCommands->pwstrStartKey = (LPWSTR) HeapAlloc(GetProcessHeap(), 
													 HEAP_ZERO_MEMORY,
													 (dwStartKeyLen + 1) 
													 * sizeof (WCHAR));

	pcpCommands->pwstrMachineName = (LPWSTR) HeapAlloc(GetProcessHeap(), 
											        HEAP_ZERO_MEMORY, 
													(METADATA_MAX_NAME_LEN + 1) 
													* sizeof (WCHAR) );

	if (pcpCommands->pwstrStartKey == NULL || pcpCommands->pwstrStartKey == NULL)
		return E_OUTOFMEMORY;

	// Take care of StartKey:
	
	DWORD dwResult = MultiByteToWideChar(
		CP_ACP,
		0,
		argv[1],
		dwStartKeyLen + 1,
		pcpCommands->pwstrStartKey,
		dwStartKeyLen + 1);

	if (dwResult == 0)
		return HRESULT_FROM_WIN32(GetLastError());

	// Chop off trailing slashes: 
	LPWSTR lpwchTemp = &(pcpCommands->pwstrStartKey[dwStartKeyLen-1]);	
	if (!wcscmp(lpwchTemp, (const unsigned short *)TEXT("/") ) ||
		!wcscmp(lpwchTemp, (const unsigned short *)TEXT("\\")) )
			*lpwchTemp = (WCHAR)'\0';

	// Initialize bShowSecure:
	pcpCommands->bShowSecure = FALSE;
	

	// Look for MachineName:
	if ( argc > 2 && strcmp("-s",argv[2])) // machine name is specified
	{
		DWORD dwMachineNameLen = _mbstrlen(argv[2]);

		dwResult = MultiByteToWideChar(
			CP_ACP,
			0,
			argv[2],
			dwMachineNameLen + 1,
			pcpCommands->pwstrMachineName,
			dwMachineNameLen + 1);

		if (dwResult == 0)
			return HRESULT_FROM_WIN32(GetLastError());

		// Check for "-s" flag:
		if (argc == 4)
			if ( !strcmp("-s",argv[3]) )
				pcpCommands->bShowSecure = TRUE;
			else
				return E_INVALIDARG;
	}
	else if (argc == 3 && !strcmp("-s",argv[2])) // no MachineName, but have -s
	{
		wcscpy(pcpCommands->pwstrMachineName,L"localhost"); //set default
		pcpCommands->bShowSecure = TRUE;
	}
	else if (argc > 2)
		return E_INVALIDARG;

	return ERROR_SUCCESS;

} // end ParseCommands


HRESULT PrintAllPropertiesAtKey(IMSAdminBase* pcAdmCom, 
								METADATA_HANDLE hmdHandle, 
								BOOL bShowSecure)
/*++

Routine Description:

    Prints all metabase properties under a give metabase key in alphabetical order of 
	their ADSI name. Properties with no corresponding ADSI name are ordered by their 
	identifier.

Arguments:

    pcAdmCom     Pointer to a metabase object.

	hmdHandle	 Handle to a metabase key.

    bShowSecure  Boolean flag specifying whether to display confidential data.

Return Value:

    HRESULT - ERROR_SUCCESS
			  E_OUTOFMEMORY
              Errors returned by Metabase Interface function calls

--*/
{
   // Get all data into a buffer:
	DWORD dwNumDataEntries;
	DWORD dwDataSetNumber;
	DWORD dwRequiredDataLen;

	HRESULT hresError = pcAdmCom -> GetAllData (
				hmdHandle,
				(const unsigned short *)TEXT ("/"),
				0,
				0,
				0,
				&dwNumDataEntries,
				&dwDataSetNumber,
				g_dwGetAllBufferSize,
				g_pbGetAllBuffer,
				&dwRequiredDataLen);


	if (hresError == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
	{
		// retry the GetAllData with the new buffer size
		g_dwGetAllBufferSize = dwRequiredDataLen;
		g_pbGetAllBuffer = (PBYTE)HeapReAlloc 
									(GetProcessHeap(),
									0,
									g_pbGetAllBuffer,
									g_dwGetAllBufferSize);

		if (!g_pbGetAllBuffer)
			return E_OUTOFMEMORY;

		hresError = pcAdmCom -> GetAllData(
				hmdHandle,
				(const unsigned short *)TEXT ("/"),
				0,
				0,
				0,
				&dwNumDataEntries,
				&dwDataSetNumber,
				g_dwGetAllBufferSize,
				g_pbGetAllBuffer,
				&dwRequiredDataLen);
	}

	if (hresError != ERROR_SUCCESS)
		return hresError;

	METADATA_GETALL_RECORD *pmdgr = NULL;
	
	// Dynamically allocate arrays:
	g_dwSortArray = new DWORD[dwNumDataEntries];
	g_pstrPropName = new pCString[dwNumDataEntries];
	
	DWORD dwIndex = 0;
	
	if (g_dwSortArray == NULL || g_pstrPropName == NULL)
	{	
		hresError = E_OUTOFMEMORY;
		goto exitPoint;
	}

	for (dwIndex = 0; dwIndex < dwNumDataEntries; dwIndex ++)
	{   
		g_pstrPropName[dwIndex] = new CString;
		if (g_pstrPropName[dwIndex] == NULL)
		{
			hresError = E_OUTOFMEMORY;
			goto exitPoint;
		}
	}

	// Initialize arrays:
	for (dwIndex = 0; dwIndex < dwNumDataEntries; dwIndex ++)
	{
		pmdgr = &(((METADATA_GETALL_RECORD *) g_pbGetAllBuffer)[dwIndex]);
		(*g_pstrPropName[dwIndex]) = tPropertyNameTable::MapCodeToName(pmdgr->dwMDIdentifier);
		g_dwSortArray[dwIndex] = dwIndex;
	}

	 // Sort entries using Quicksort algorithm: 
	if (dwNumDataEntries > 1)
	{
		qsort( (void *)g_dwSortArray, 
			    dwNumDataEntries, 
				sizeof(DWORD), 
				PropNameCompare );

		// locate index of first non-empty entry:
		for (dwIndex = 0; dwIndex <dwNumDataEntries && 
				!g_pstrPropName[g_dwSortArray[dwIndex]]->Compare(_T("")); dwIndex ++)
		{}

		qsort( (void *)g_dwSortArray, dwIndex, sizeof(DWORD), PropIDCompare );
	}

	// print all properties in order:
	for (dwIndex = 0; dwIndex < dwNumDataEntries; dwIndex ++)
	{
		pmdgr = &(((METADATA_GETALL_RECORD *) g_pbGetAllBuffer)[g_dwSortArray[dwIndex]]);

		// Convert the data pointer from offset to absolute
		pmdgr->pbMDData = pmdgr->dwMDDataOffset + g_pbGetAllBuffer;
		PrintProperty(*pmdgr, g_pstrPropName[g_dwSortArray[dwIndex]], bShowSecure);
	}

exitPoint:
	for (DWORD dwCount = 0; dwCount < dwIndex; dwCount ++)
		delete g_pstrPropName[dwCount];

	delete g_dwSortArray;
	delete g_pstrPropName;

	return hresError;
} // end PrintAllPropertiesAtKey



HRESULT PrintKeyRecursively(IMSAdminBase *pcAdmCom, 
							WCHAR *lpwstrFullPath,
							METADATA_HANDLE hmdHandle, 
							WCHAR *lpwstrRelPath,
							BOOL bShowSecure)
/*++

Routine Description:

    Performs a depth-first traversal of the metabase. Nodes at the same level are visited 
	in alphabetical order. At each key prints the full key name and its contents in
	alphabetical order.

Arguments:

    pcAdmCom        Pointer to a metabase object.

	lpwstrFullPath  Pointer to full key name.	
	
	hmdHandle		Handle to metabase key from last level.

	lpwstrRelPath   Pointer to path to the key relative to hmdHandle.
	
    bShowSecure     Boolean flag specifying whether to display confidential data.

Return Value:

    HRESULT - ERROR_SUCCESS
			  E_OUTOFMEMORY
              Errors returned by Metabase Interface function calls
--*/
{
	// Print [full key name]:
	printf("[%S]\n",lpwstrFullPath);

	METADATA_HANDLE hmdNewHandle;

	HRESULT hresError = pcAdmCom->OpenKey(
								hmdHandle,
								lpwstrRelPath,
								METADATA_PERMISSION_READ,
								DEFAULT_MD_TIMEOUT,
								&hmdNewHandle);

	if (FAILED(hresError)) 
	{
		switch (hresError)
		{
		case HRESULT_FROM_WIN32(ERROR_PATH_BUSY):
			fprintf (stderr, "ERROR: The specified key is already in use.\n"); 
			break;
		case HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
			fprintf (stderr, "ERROR: The specified key is not found.\n");
			break;
		default:
			fprintf (stderr, "ERROR: Couldn't open Metabase Key. Error: %d (%#x)\n", hresError, hresError);
			break;
		}
		return hresError; 
	}

	hresError = PrintAllPropertiesAtKey(pcAdmCom, 
										hmdNewHandle, 
										bShowSecure);

	if (hresError != ERROR_SUCCESS)
	{
		fprintf (stderr, "ERROR: Could not print [%S]. Error: %#x\n", lpwstrFullPath, hresError);
		pcAdmCom->CloseKey(hmdNewHandle);
		return hresError;
	}

	WCHAR *lpwstrTempPath = (WCHAR*) HeapAlloc 
									(GetProcessHeap(),
									HEAP_ZERO_MEMORY,
									METADATA_MAX_NAME_LEN * sizeof (WCHAR));

	if (lpwstrTempPath == NULL)
	{
		pcAdmCom->CloseKey(hmdNewHandle);
		return E_OUTOFMEMORY;
	}

	// Find out number of the children:
	DWORD dwChildCount = 0;
	while (1)
	{
		hresError = pcAdmCom->EnumKeys (
								hmdNewHandle,
								(const unsigned short *)TEXT("/"),
								lpwstrTempPath,
								dwChildCount);

		if (hresError != ERROR_SUCCESS)
			break;
		dwChildCount++;
	}

	if (dwChildCount == 0) // we are done
	{
		pcAdmCom->CloseKey(hmdNewHandle);
		return ERROR_SUCCESS;
	}

	// Dynamically allocate arrays:
	LPWSTR * lpwstrChildPath = new LPWSTR[dwChildCount];
	DWORD * dwSortedIndex = new DWORD[dwChildCount];

	DWORD dwIndex = 0;
	
	if (lpwstrChildPath == NULL || dwSortedIndex == NULL)
	{	
		hresError = E_OUTOFMEMORY;
		goto exitPoint;
	}

	for (dwIndex = 0; dwIndex < dwChildCount; dwIndex ++)
	{   
		lpwstrChildPath[dwIndex] = (WCHAR*) HeapAlloc(GetProcessHeap(),
													  HEAP_ZERO_MEMORY,
													  (METADATA_MAX_NAME_LEN + 1) 
													  * sizeof (WCHAR));
		if (lpwstrChildPath[dwIndex] == NULL)
		{
			hresError = E_OUTOFMEMORY;
			goto exitPoint;
		}
	}

	// Initialization:
	for (dwIndex = 0; dwIndex < dwChildCount; dwIndex++)
	{
		dwSortedIndex[dwIndex] = dwIndex;

		hresError = pcAdmCom->EnumKeys (
								hmdNewHandle,
								(const unsigned short *)TEXT("/"),
								lpwstrChildPath[dwIndex],
								dwIndex);
	}

	if (hresError == ERROR_SUCCESS)
	{
		// Sort children lexicographically (here we assume that dwChildCount is small)
		if (dwChildCount > 1 )
		{
			 DWORD dwTemp;
			 for (DWORD i = 1; i < dwChildCount; i++)
				for (DWORD j=0; j < dwChildCount-i; j++)
				{
					if (wcscmp(lpwstrChildPath[dwSortedIndex[j]],lpwstrChildPath[dwSortedIndex[j+1]]) > 0)
					{
						dwTemp = dwSortedIndex[j+1];
						dwSortedIndex[j+1] = dwSortedIndex[j];
						dwSortedIndex[j] = dwTemp;
					}
				}
		}

		for (dwIndex = 0; dwIndex < dwChildCount; dwIndex++)
		{
			// create the full path name for the child:
			wsprintf((LPTSTR)lpwstrTempPath,TEXT("%s/%s"),
										lpwstrFullPath,
										lpwstrChildPath[dwSortedIndex[dwIndex]]);

			hresError = PrintKeyRecursively(
				pcAdmCom, 
				lpwstrTempPath, 
				hmdNewHandle, 
				lpwstrChildPath[dwSortedIndex[dwIndex]],
				bShowSecure);

			if (hresError != ERROR_SUCCESS)
				break;
		}
	}

exitPoint:

	// Close open keys, free memory and exit
	for (DWORD dwCount = 0; dwCount < dwIndex; dwCount ++)
		HeapFree (GetProcessHeap(), 0, lpwstrChildPath[dwCount]);

	pcAdmCom->CloseKey(hmdNewHandle);
	delete lpwstrChildPath;
	delete dwSortedIndex;
	HeapFree (GetProcessHeap(), 0, lpwstrTempPath);

	return hresError;
}



VOID PrintProperty(METADATA_GETALL_RECORD & mdr, 
				   pCString pstrPropName, 
				   BOOL bShowSecure)
/*++

Routine Description:

    Prints a metabase property in a human readable format. Secure 
	data is replaced by stars if bShowSecure is false.

Arguments:

    mdr          A metadata getall record struct (passed in by reference).
	
	pstrPropName Pointer to the ADSI name corresponding to the metadata 
				 identifier (comes from the table in convert.cpp)
    
	bShowSecure  Boolean flag specifying whether to display confidential data.

Return Value:
				None.
--*/
{
    // Print identifier and name of property:
	printf(" %-10ld %-35S", mdr.dwMDIdentifier, LPCTSTR(*pstrPropName));

    // Print attribute flags:

    CString strFlagsToPrint=(L"");

    if (mdr.dwMDAttributes & METADATA_INHERIT)
        strFlagsToPrint+=(L"I");
    if (mdr.dwMDAttributes & METADATA_INSERT_PATH)
        strFlagsToPrint+=(L"P");    
    if(mdr.dwMDAttributes & METADATA_ISINHERITED)
        strFlagsToPrint+=(L"i");     
    if(!mdr.dwMDAttributes )  //METADATA_NO_ATTRIBUTES
        strFlagsToPrint+=(L"N");
    if(mdr.dwMDAttributes & METADATA_PARTIAL_PATH)
        strFlagsToPrint+=(L"p");
    if (mdr.dwMDAttributes & METADATA_REFERENCE)
        strFlagsToPrint+=(L"R");
    if (mdr.dwMDAttributes & METADATA_SECURE)
        strFlagsToPrint+=(L"S");
    if (mdr.dwMDAttributes & METADATA_VOLATILE)
        strFlagsToPrint+=(L"V");
    
    printf( " %-6S",LPCTSTR(strFlagsToPrint));

    // Print user type:

    CString strUserType=(L"");
    
	switch (mdr.dwMDUserType)
	{
	case IIS_MD_UT_SERVER:
        strUserType=(L"SER");
		break;
    case IIS_MD_UT_FILE:
        strUserType=(L"FIL");
		break;
    case IIS_MD_UT_WAM:
        strUserType=(L"WAM");
		break;
    case ASP_MD_UT_APP:
        strUserType=(L"ASP");
		break;
	default:
		break;
	}

	if (strUserType == (L""))
		printf(" %-10ld",mdr.dwMDUserType);
	else
		printf( "%-10S",LPCTSTR(strUserType));

    // Print data size:
	printf(" %-10ld",mdr.dwMDDataLen);
	
    // Print data type and value:
	PrintDataTypeAndValue (&mdr, bShowSecure);
	
}


VOID PrintDataTypeAndValue (METADATA_GETALL_RECORD *pmdgr, 
							BOOL bShowSecure)
/*++

Routine Description:

    Prints the data type and data value fields of a metabase property in a human 
	readable format. Secure data is replaced by stars if bShowSecure is false.

Arguments:

    pmdgr        Pointer to a metadata getall record struct.

    bShowSecure  Boolean flag specifying whether to display confidential data.

Return Value:
				None.
--*/
{
    BOOL bSecure =(pmdgr->dwMDAttributes & METADATA_SECURE);

	DWORD i;
    switch (pmdgr->dwMDDataType) 
	{
		case DWORD_METADATA:
			printf("DWO  ");
			if (!bShowSecure && bSecure)
				printf( "********");
			else
			{
	            printf( "0x%x", *(DWORD *)(pmdgr->pbMDData));
	      
				// try to convert to readable info        
				CString strNiceContent;
	            strNiceContent=tValueTable::MapValueContentToString(
															*(DWORD *)(pmdgr->pbMDData), 
															pmdgr->dwMDIdentifier);           
				if(!strNiceContent.IsEmpty())
	               printf( "={%S}",LPCTSTR(strNiceContent));
	            else        //at least decimal value can be useful
	                printf( "={%ld}",*(DWORD *)(pmdgr->pbMDData));
	        }
	        break;

		case BINARY_METADATA:
			printf("BIN  0x");
			if (!bShowSecure && bSecure)
				printf("** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ");
			else
				for (i=0; i<pmdgr->dwMDDataLen; i++) 
					printf( "%02x ", ((PBYTE)(pmdgr->pbMDData))[i]);
			break;

	    case STRING_METADATA:
	    case EXPANDSZ_METADATA:
			if(pmdgr->dwMDDataType == STRING_METADATA)
					printf( "STR  ");
			else
					printf( "ESZ  ");
			
			if (!bShowSecure && bSecure)
				printf("\"********************\"" );  
			else
				printf("\"%S\"",pmdgr->pbMDData);
			break;

		case MULTISZ_METADATA:
	        printf( ("MSZ  ")); 
			if (!bShowSecure && bSecure)
	           printf(  ("\"********************\"" ));
			else
			{
				WCHAR * lpwstrPtr = (WCHAR*)pmdgr->pbMDData;
				while (*lpwstrPtr != 0)
				{
					printf("\"%S\" ",lpwstrPtr);
					lpwstrPtr += (wcslen(lpwstrPtr) + 1);
				}
			}
			break;
		
		default:
			printf( ("UNK  "));
			break;
	}	
	printf("\n");
}


VOID DisplayHelp()
/*++

Routine Description:

    Displays usage information and provides examples.

Arguments:
				None.

Return Value:
				None.

--*/
{
	fprintf (stderr, "\n DESCRIPTION: Takes a snapshot of the metabase.\n\n");
	fprintf (stderr, " FORMAT: metasnap <StartKey> <MachineName> [-s]\n\n");
	fprintf (stderr, "    <StartKey>   : metabase key to start at.\n");
	fprintf (stderr, "    <MachineName>: name of host (optional, default: localhost).\n");
	fprintf (stderr, "    [-s]         : show secure data (ACLs, passwords) flag.\n\n");
	fprintf (stderr, " EXAMPLES: metasnap  /lm/w3svc/1  t-tamasn2  -s\n");
	fprintf (stderr, "           metasnap  \"/LM/Logging/ODBC Logging\"\n");
	fprintf (stderr, "           metasnap  /  >  dump.txt  (dumps everything to text)\n");
}


// Comparison functions required by qsort:

int __cdecl PropIDCompare(const void *index1, const void *index2)
/*++

Routine Description:

    Compares the identifiers of two metabase properties. This function
	is used exclusively by qsort (from stdlib).

Arguments:

	index1, index2  Pointers to entries in g_dwSortArray. g_dwSortArray specifies the 
					ordering of the metabase records after sorting.

Return Value:

	1  if the identifier of the metabase property specified by index1 is greater 
	   than the identifier of the one corresponding to index2
	0  if they are equal
   -1  otherwise

--*/
{
	METADATA_GETALL_RECORD *pmdr1, *pmdr2;
	pmdr1 = &(((METADATA_GETALL_RECORD *) g_pbGetAllBuffer)[ *(DWORD*)index1]);
	pmdr2 = &(((METADATA_GETALL_RECORD *) g_pbGetAllBuffer)[ *(DWORD*)index2]);
	if (pmdr1->dwMDIdentifier > pmdr2->dwMDIdentifier)
		return 1;
	else if (pmdr1->dwMDIdentifier < pmdr2->dwMDIdentifier)
		return (-1);
	return 0;
}

int __cdecl PropNameCompare(const void *index1, const void *index2)
/*++

Routine Description:

    Compares two CStrings. This function is used exclusively by qsort (from stdlib).

Arguments:

	index1, index2  Pointers to entries in g_dwSortArray. g_dwSortArray specifies the 
					ordering of the metabase records after sorting.

Return Value:

	1  if the ADSI name of the metabase property specified by index1 precedes 
	   alphabetically the ADSI name of the one corresponding to index2
	0  if they are the same
   -1  otherwise

--*/
{
   return g_pstrPropName[ *(DWORD*)index1]->Compare(*g_pstrPropName[*(DWORD*)index2]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\terrain\tools\perms\perms.c ===
//
// Modification: 
//			oct.29, 1997 changed by a-zexu to debug bug#113977(incorrect output info).
//			May 10, 1998 changed by a-zexu to debug bug#158667.
//
//


#include "PERMS.H"                                  


PSID SidEveryone = NULL;
PSID SidOwnerGroup = NULL;
PSID SidFromLookupName = NULL;
PSID ASidFromLookupName[10];
PSID *AccountSids = NULL;
DWORD cbSidFromLookupName=0;
SAM_HANDLE SamServerHandle = NULL;
SAM_HANDLE SamDomainHandle = NULL;
ACCESS_MASK grant_mask = 0;                                                                               
BOOL g_noAccess = FALSE;
BOOL owner_flag = FALSE; 
BOOL owner_group = FALSE;
BOOL Local_Machine = TRUE;
ULONG Total_Sids=0;
BOOL inter_logon=FALSE;            /* interactive login flag */
PSECURITY_DESCRIPTOR SidFromGetFileSecurity;    /* address of security descriptor */
	
_cdecl main(int argc, char *argv[])
{
	char
								UserNameBuff[LSA_WIN_STANDARD_BUFFER_SIZE],    /* user name buff */
								SystemNameBuff[LSA_WIN_STANDARD_BUFFER_SIZE],  /* system name buff */
								FileNameBuff[LSA_WIN_STANDARD_BUFFER_SIZE],  /* system name buff */
								FileSystemNameBuff[LSA_WIN_STANDARD_BUFFER_SIZE],  /* system name buff */
								RefDFromLookupName[LSA_WIN_STANDARD_BUFFER_SIZE],
								GeneralUseBuffer[LSA_WIN_STANDARD_BUFFER_SIZE],
								LocalSystemName[MAX_COMPUTERNAME_LENGTH + 1],
								FileName[LSA_WIN_STANDARD_BUFFER_SIZE],
								FilePath[LSA_WIN_STANDARD_BUFFER_SIZE];

	DWORD         cchRefDFromLookupName=0,
								SidsizeFromGetFileSecurity=0,
								lpcbsdRequired=0,
								SNameLen = MAX_COMPUTERNAME_LENGTH + 1;

	SID_NAME_USE  UseFromLookupName;                               

	DWORD         cchNameFromLookupSid;                            
	char          NameFromLookupSid[LSA_WIN_STANDARD_BUFFER_SIZE]; 
	char          RefDFromLookupSid[LSA_WIN_STANDARD_BUFFER_SIZE]; 
	DWORD         cchRefDFromLookupSid, 
								WStatus,
								WNetSize = LSA_WIN_STANDARD_BUFFER_SIZE;                            
	SID_NAME_USE  UseFromLookupSid;                                
	PSID usid;                /* user SID pointer */
	LPDWORD sidsize;
	LPSTR        User = NULL,
								System,
								Path,
								File = NULL,
								FileMachine = NULL;
	LPDWORD domain_size;
	PSID_NAME_USE psnu;
	LPTSTR pbslash;                  /* address of string for back slash  */
	SECURITY_INFORMATION           /* requested information  */
					 si =(OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION
					 |DACL_SECURITY_INFORMATION);
	DWORD cbsd, LastError;            /* size of security descriptor buffer */
 
	BOOL  BoolStatus=TRUE;
	int i, k, j;
	ULONG ui;
	BOOL sys=FALSE, 
					fl=FALSE,
					LocalFlag=FALSE,
					BackUpPriv=TRUE,
					DriveFlag=FALSE,
					RecurseFlag=FALSE,
					RestorePriv=TRUE,
					DirFlag=FALSE;
	ULONG AccountSidsLength;
	HANDLE TokenHandle,
				 FindFileHandle;
	WIN32_FIND_DATA FindFileData;
	
	// Set Back up privs for process
	// Get our process token
	if(!GetTokenHandle(&TokenHandle))
	{
		syserror(GetLastError());
		return(TRUE);
	}

	// Have valid process token handle
	// Now set the backup operator priv

	if(!SetBackOperatorPriv(TokenHandle))
		BackUpPriv = FALSE;

	CloseHandle(TokenHandle);

	 // Initialize some memory say for 100 sids 
	 AccountSidsLength = 100 * sizeof ( PSID );
	 AccountSids = (PSID *) LocalAlloc( LPTR,  AccountSidsLength );
	 
	 // Initialize some memory for a large file security discriptor 
	 SidFromGetFileSecurity = (PSECURITY_DESCRIPTOR) GlobalAlloc( GPTR, (DWORD) LARGEPSID);
	 
	 // Check to see if memory was allocated
	 if(AccountSids == NULL || SidFromGetFileSecurity == NULL ) 
	 {
			syserror(GetLastError());
			return(TRUE);
	 }
	
	UserNameBuff[0] = (char) NULL;
	SystemNameBuff[0] = (char) NULL;
	FilePath[0] = (char) NULL;
	FileNameBuff[0] = (char) NULL;
	FileSystemNameBuff[0] = (char) NULL;
	GeneralUseBuffer[0] = (char) NULL;
	
	/* Check for valid command line argument syntax before processing */
	/* check for some count greater than zero and less than max argc count */
	if(argc > 1 && argc <= MAXARGS)
	{
		/* Need to make the following assumptions: That the first command line arg
			 can be a help request or other switch "/? -? /i -i" or an account name. 
			 and not a switch option, could be additional switches or a path name.
			 Also, switches can be intermixed the account name and path. Path is
			 not required local directory is assumed. First parse switches, 
			 account and path.
		*/
		

		/* Loop through  command line args */
		for(i=1; i<argc; i++)
		{
			/* check length of args, 2 may indicate a switch */
			switch(strlen(argv[i]))
			{
				case 1:
					if(sys == FALSE)    // if file flagg true have an invalid case
					{
						strcpy(UserNameBuff, argv[i]);
						// System is local
						System = NULL;
						sys = TRUE;
					}
					else 
					{   
						// copy the argument into the file name buffer
						strcpy(FileNameBuff,argv[i]);
						// Make the Machine name NULL for local machine
						FileMachine = NULL;
						LocalFlag = TRUE;
						fl = TRUE;
					}
				break;

				case 2:     /* Valid size for switch */
					/* check for switch flag */
					if( argv[i][0] == '/' || argv[i][0] == '-')
					{
						switch((int)argv[i][1])
						{ // Help Switch
							case (int) '?':
								usage(HELP, NULL);
								return(TRUE);

							// Interactive Logon Switchs
							case (int) 'i':
								inter_logon = TRUE;
								continue;

							case (int) 'I':
								inter_logon = TRUE;
								continue;

							// Recurse Subdirectories
							case (int) 's':
								 RecurseFlag = TRUE;
								continue;

							case (int) 'S':
								 RecurseFlag = TRUE;
								continue;


							default:
								usage(INVALID_SWT, argv[i]);
								usage(USAGE_ARG, NULL);
								return(TRUE);
						}
					}
					else      /* if not swiches then must be a  or 2 char path name */
					{  
						if(sys == FALSE)    // if file flag true have an invalid case
						{
							strcpy(UserNameBuff, argv[i]);
							// System is local
							System = NULL;
							sys = TRUE;
						}
						else 
						{   
							// copy the argument into the file name buffer
							strcpy(FileNameBuff,argv[i]);
							// Check for "_:" drive type
							pbslash = strchr(argv[i], 0x3a);
							if(pbslash != NULL)
							{
								strcat(FileNameBuff, "\\");
								// Set File pointer
								File = (LPTSTR) &FileNameBuff[0];
							}

							fl = TRUE;
						}
					}
					break;
				
				default:    /* look for account or path */
					// Also we know that a sys/user machine\user is the first string
						if(sys == FALSE)
						{  
						// need to to find the "\" in the 
							pbslash = strchr(argv[i], 0x5c);
							// check pointer location if a NULL no "\" or at first postion in string
							// if no slash have a account name only
							if(pbslash == NULL)
							{
								strcpy(UserNameBuff, argv[i]);
								// Set System to NULL
								System = NULL;
								sys = TRUE;
								break;
							}
							if( pbslash == argv[i])
							{
								usage(INVALID_ARG, argv[i]);
								usage(USAGE_ARG, NULL);
								return(TRUE);
							}
							// copy the string from the "\" tho the user buffer
							strcpy(UserNameBuff, ++pbslash);
							// copy the string up to the "\" in to the system buffer
							// now terminate the string at "\" to a NULL
							--pbslash;
							*pbslash = '\0';

							// Check to see if we have a domain name
							if(!IsDomainName(argv[i], (LPSTR) SystemNameBuff))
							{
								// add the "\\" to the begining of string
								strcpy(SystemNameBuff, "\\\\");
								strcat(SystemNameBuff, argv[i]);
								System = (LPTSTR) &SystemNameBuff[0];
							}
							else
							{
								System = (LPTSTR) &SystemNameBuff[0];
							//  printf("\n :%s is :%s \n", argv[i], System);
							}
							sys = TRUE;
						}
						else // File argument
						{   
							// Get the local machine name
							// machine is in UNC form.
							// add the "\\" to the begining of string
							strcpy(LocalSystemName, "\\\\");
							if(!GetComputerName(&LocalSystemName[2],
															 &SNameLen))
							{
								syserror(GetLastError());
								return(TRUE);
							}

							// Check for "\\" in first 2 chars in file path for UNC path
							if( strncmp(argv[i], "\\\\", 2) == 0)
							{
								// copy "\\ to the next \" to the file machine name
								for(j=0; j < (int) strlen(argv[i]); j++)
								{
									if(j<2)
										FileSystemNameBuff[j] = argv[i][j];
									else
									{
										// check for 3rd "\"
										if(argv[i][j] == 0x5c)
											break;
										FileSystemNameBuff[j] = argv[i][j];
									}
								}
								// add null to string
								FileSystemNameBuff[j] = '\0';
								// now need to check for the local machine name
								// The get file security call will fail if local
								// Compare the local machine name to the file machine
								if(_stricmp(LocalSystemName, FileSystemNameBuff) == 0)
								{
									// Have a local Machine UNC path
									// Check account machine name
									if(_stricmp(LocalSystemName, System) == 0)
									{
										// Have a local Machine equal to account machine
										// no need to look up sids for file machine.
										LocalFlag = TRUE;
									}
									
									// Make the Machine name NULL for local machine
									FileMachine = NULL;
									// Need to strip off UNC name of local machine
									// The j counter is at "\" character

									strcpy(FileNameBuff, &argv[i][j]);
								}
								else  // Have a nonlocal path
								{
									// Need to check system name against account machine
									if(System != NULL)
										if(_stricmp(FileSystemNameBuff, System) == 0)
										{
											// Have a file Machine equal to account machine
											// no need to look up sids for file machine.
											LocalFlag = TRUE;
										}
									strcpy(FileNameBuff,argv[i]);
									FileMachine = (LPTSTR) &FileSystemNameBuff[0];

								}
								// printf("\n file machine: %s", FileMachine);

							}
							else  // have a local file  (assume local) or logical
							{
								// Need to get the logical or drive ie "_:" 
								pbslash = strchr(argv[i], 0x3a);
							// check pointer location if a NULL assume a "\xx\xx" type path
							if(pbslash == NULL)
							{
								strcpy(FileNameBuff,argv[i]);
								// set the filemachine name to a null to force local 
								FileMachine = NULL;
							}
							else
							{
								// Have a logical drive or a machine drive
								// Need the drive part 
								k = (int) strlen(argv[i]);
								for(j=0; j < k; j++)
								{
										GeneralUseBuffer[j] = argv[i][j];
										// check for  ":"
										if(argv[i][j] == 0x3a)
											break;
								}
								// add null to string
								GeneralUseBuffer[++j] = '\0';
								// WNetGetConnection
								WStatus = WNetGetConnection((LPTSTR) GeneralUseBuffer,    // Drive name
															(LPTSTR) FileSystemNameBuff,   // Returned Name
															&WNetSize);
	// Check return status
								if(WStatus == NO_ERROR) 
								{
									// Have a valid redirected drive
									// Build the full path name 
									strcat(FileNameBuff, argv[i]);
									// Next get the machine name of the share
									// copy "\\ to the next \" to the file machine name
									for(j=0; j < (int) strlen(FileSystemNameBuff); j++)
									{
										if(j>2)
										{
											// check for 3rd "\"
											if(FileSystemNameBuff[j] == 0x5c)
												break;
										}
									}
									// Add NULL
									FileSystemNameBuff[j] = '\0';
									FileMachine = (LPTSTR) &FileSystemNameBuff[0];
								}
								else
								{
									// Have a local machine drive 
									strcpy(FileNameBuff,argv[i]);
									// Check for drive only path "_:\" or "_:"
									// FindFirstFile has with it.
									// Need to convert "_:" to "_:\"
									if(k <= 3)
										DriveFlag = TRUE;

									// Check for a System = NULL
									if(System != NULL)
									{
										// Check User Account system against local name
										if(_stricmp(LocalSystemName, System) == 0)
										{
											// Have a local user account machine
											LocalFlag = TRUE;
										}
									}
									else // System is Local machine 
											LocalFlag = TRUE;

									// set the filemachine name to a null to force local 
									FileMachine = NULL;

								}
							}
						}  
							fl = TRUE;
							// Set File pointer
							File = (LPTSTR) &FileNameBuff[0];
		
						}
					
					break;

			}   /* end switch */
		}   /* end for argv loop */

		User = (LPTSTR) &UserNameBuff[0];
		// Make sure GeneralUseBuffer is null
		GeneralUseBuffer[0] = (CHAR) NULL;
		// Check to see if file was entered
		if(fl == FALSE)
		{
			usage(INVALID_FIL, (CHAR) NULL);
			return(FALSE);
		}
		

		// Clean up the file name ie "." ".." ".\" etc
		if(!CleanUpSource((LPTSTR) FileNameBuff, (LPTSTR) FileName, &DirFlag))
		{
			usage(INVALID_FIL, (LPTSTR) FileNameBuff);
			return(FALSE);
		}
		File = &FileName[0];
		Path = &FilePath[0];
		strcpy(Path, File);
		//Find last Slash
		pbslash = strrchr(Path, 0x5c);
		if(pbslash != NULL)
		{ 
			pbslash++;
			*pbslash = (CHAR) NULL;
		}
		

		/*** Get everyone SID by use LookupAccountName ***/	

		/* Have no buffer sizes first call to LookupAccountName will return 
			 need buffer sizes */		
		if( LookupAccountName( NULL, 
				TEXT("everyone"), 
				SidEveryone,
				&cbSidFromLookupName,    
				RefDFromLookupName,      
				&cchRefDFromLookupName,  
				&UseFromLookupName))
		{
			usage(INVALID_ACC, User);       
			usage(USAGE_ARG, NULL);
			return(TRUE);
		}		

		/* Now have valid buffer sizes to call LookupAccountName for a valid SID */
		/* allocate memory for the sid */		
		SidEveryone =  LocalAlloc( (UINT) LMEM_FIXED, (UINT) cbSidFromLookupName);
		
		if(SidEveryone == NULL) 
		{                                                    
			syserror(GetLastError());
			return(TRUE);                                                          
		}     
		
		if( !LookupAccountName( NULL,
				TEXT("everyone"), 
				SidEveryone,
				&cbSidFromLookupName,    
				RefDFromLookupName,      
				&cchRefDFromLookupName,  
				&UseFromLookupName))
		{
			usage(INVALID_ACC, User);       
			usage(USAGE_ARG, NULL);
			return(TRUE);
		}


		/* Have no buffer sizes first call to LookupAccountName will return 
			 need buffer sizes */		
		if( LookupAccountName( System, 
				User, 
				SidFromLookupName,
				&cbSidFromLookupName,    
				RefDFromLookupName,      
				&cchRefDFromLookupName,  
				&UseFromLookupName))
		{
			usage(INVALID_ACC, User);       
			usage(USAGE_ARG, NULL);
			return(TRUE);
		}		

		/* Now have valid buffer sizes to call LookupAccountName for a valid SID */
		/* allocate memory for the sid */
		
		SidFromLookupName =  LocalAlloc( (UINT) LMEM_FIXED, (UINT) cbSidFromLookupName);
		
		if(SidFromLookupName == NULL) 
		{                                                    
			syserror(GetLastError());
			return(TRUE);                                                          
		}                                                                           
		
		
		if( !LookupAccountName( System,
				User, 
				SidFromLookupName, 
				&cbSidFromLookupName,    
				RefDFromLookupName,      
				&cchRefDFromLookupName,  
				&UseFromLookupName))
		{
			usage(INVALID_ACC, User);       
			usage(USAGE_ARG, NULL);
			return(TRUE);
		}
		
		ASidFromLookupName[0] = SidFromLookupName;
		if(!VariableInitialization())
		{
			syserror(GetLastError());
			return(TRUE);
		}
		
		// look up the user's group sids for the machine the accounts on
		BoolStatus = LookupAllUserSidsWS(System);
		
		// look up the user's group sid for the workstation that the file resides on
		// Need to check if the account machine and file machine are the same.
		// If not done duplicate sids will be build.
		
		if( LocalFlag == FALSE)
		{
			if( !LookupAllUserSidsWS(FileMachine))
			{
				// system error message
				syserror(GetLastError());
				return(TRUE);
			}
		}
		// Not a directory 
		if(!DirFlag)
		{
		 // Need to get the findfirstfile
		 FindFileHandle = FindFirstFile(File, &FindFileData);
		 if(FindFileHandle == INVALID_HANDLE_VALUE)
		 {
				usage(INVALID_FIL, (LPTSTR) FileNameBuff);
				return(FALSE);
		 }

//		 FindClose(FindFileHandle);		

		 if(Path != NULL)
		 {
				strcpy(File, Path);
				// This sould give a valid path
				strcat(File,FindFileData.cFileName);
			}
			else    
				strcpy(File,FindFileData.cFileName);
		}
		else // need to fake out the Finfirstfile data structure
			FindFileData.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;

		// Now have all of the user sid and the first file.
		// Loop through the files
		while(1)
		{
			if(strcmp(FindFileData.cFileName, ".") != 0) 
				if(strcmp(FindFileData.cFileName, "..") != 0)
			{

				/* The call to GetFileSecurity works similar to LookupAccountName 
					 in that the first call get need buffer sizes */
		 

				// Use a fairly larger buffer size of returned size value.
				// This will keep the number of malloc type calls down.
				SidsizeFromGetFileSecurity = LARGEPSID;
				BoolStatus = GetFileSecurityBackup(File, 
						si, 
						SidFromGetFileSecurity, 
						SidsizeFromGetFileSecurity,  /* buffer size */
						&lpcbsdRequired,    /* required buffer size */
						BackUpPriv);
				if(!BoolStatus)
				{
					// GetFileSecurity failed need to check if buffer was to small
					if(lpcbsdRequired != 0)
					{
						SidsizeFromGetFileSecurity = lpcbsdRequired;
						// Reallocate the memory to the new size
						SidFromGetFileSecurity =  GlobalReAlloc( SidFromGetFileSecurity, lpcbsdRequired, GMEM_ZEROINIT);  
						BoolStatus = GetFileSecurityBackup(File, 
								si, 
								SidFromGetFileSecurity, 
								SidsizeFromGetFileSecurity,    
								&lpcbsdRequired,     
								BackUpPriv);
						if(!BoolStatus)
						{ 
							syserror(GetLastError());
							return(TRUE);
						}
					}
					else // Have a problem with file
					{
						usage(INVALID_FIL, (LPTSTR) File);
						return(FALSE);
					}
				}
				// Clear access masks
				grant_mask = 0;
				if(!GetFilePermissions(SidFromGetFileSecurity, (PSID) SidFromLookupName))
				{
					syserror(GetLastError());
					return(TRUE);
				}
				// Need to chech for directory structure
				if(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
					// Display the directory perms
					if(!IsLastCharSlash(File))
					 strcat(File, "\\");
					DisplayPerms(File, TRUE);
					// Check Recurse subdirectories flagg
					// This is ugly but time is short
					if(!DirFlag)
						if(RecurseFlag == TRUE)
						{
							// Need the Filename, Path, user account sid, and Backup priv flag
							RecurseSubs(FindFileData.cFileName, Path, SidFromLookupName, BackUpPriv,
							RecurseFlag);
						}
				}
				else  // For initial files that are directories
					if(!DirFlag)
						DisplayPerms(File, TRUE);
			} // End if "." .""
			// Go for the next file 
			// for recursing subdirectories.
			if(DirFlag)
			{
				// Check recurse flag
				if(RecurseFlag)
				{
					// Need to update the path
					strcpy(Path, File);
					// Add the wild card
					strcat(File, "*");

					FindClose(FindFileHandle);
					// Need to get the findfirstfile
					FindFileHandle = FindFirstFile(File, &FindFileData);
					if(FindFileHandle == INVALID_HANDLE_VALUE)
					{
						syserror(GetLastError());
						return(TRUE);
					}
					// Add path to file
					strcpy(File, Path);
					// This sould give a valid path
					strcat(File,FindFileData.cFileName);
					DirFlag = FALSE;
					continue;
				}
				// Have only a single directory
				// if(!IsLastCharSlash(File))
				//  strcat(File, "\\");
				// DisplayPerms(File, TRUE);
				break;
			}
				
			if(FindNextFile(FindFileHandle, &FindFileData))
			{
				if(Path != NULL)
				{
					strcpy(File, Path);
					// This sould give a valid path
					strcat(File,FindFileData.cFileName);
				}
				else    
					strcpy(File,FindFileData.cFileName);

			}
			else    // Have end of files
				break;

		} // End While loop

		FindClose(FindFileHandle);

		// free memory
		if(AccountSids)
			LocalFree(AccountSids);
		if(SidFromLookupName)
			LocalFree(SidFromLookupName);
		if(SidEveryone)
			LocalFree(SidEveryone);

		return(TRUE);

	} /* end of main if */
	else
		usage(HELP, NULL);  

	return(TRUE);
} /* End of Main */

/* ********************************************************************* 
	Recure Subdirectories
************************************************************************ */
BOOL
RecurseSubs(IN LPTSTR FileName,
						IN LPTSTR FilePath,
						IN PSID UserSid,
						IN BOOL BackPriv,
						IN BOOL Recurse)
{
	char
		PathBuff[LSA_WIN_STANDARD_BUFFER_SIZE],  
		FileNameBuffer[LSA_WIN_STANDARD_BUFFER_SIZE],  
		GeneralUseBuffer[LSA_WIN_STANDARD_BUFFER_SIZE];

		DWORD cchRefDFromLookupName=0,
					SidsizeFromGetFileSecurity=0,
					lpcbsdRequired=0;

	SID_NAME_USE  UseFromLookupSid;                                
	LPSTR RPath,
				RFile;
	SECURITY_INFORMATION si;          /* requested information  */
	BOOL  BoolStatus=TRUE;
	ULONG AccountSidsLength;
	HANDLE FileHandle;
	WIN32_FIND_DATA FindFileData;

	
	
	// Need to create a wildcard file name for FindFirstFile    
	sprintf(FileNameBuffer, "%s%s%s", FilePath,  FileName, "\\*");
	RFile = (LPTSTR) &FileNameBuffer[0];
	// Update path to include the new directory
	sprintf(PathBuff, "%s%s%s", FilePath, FileName, "\\");
	RPath = (LPTSTR) &PathBuff[0];
	FileHandle = FindFirstFile(RFile, &FindFileData);
	if(FileHandle == INVALID_HANDLE_VALUE)
		return(FALSE);    
	
	si =(OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION
				 |DACL_SECURITY_INFORMATION);
		
		
	// Now have all of the user sid and the first file.
	// Loop through the files
	while(1)
	{
		
		// Need to check for "." and ".."
	 
		if(strcmp(FindFileData.cFileName, ".") != 0) 
			if(strcmp(FindFileData.cFileName, "..") != 0)
		{
			sprintf(RFile, "%s%s", RPath,  FindFileData.cFileName);
			/* The call to GetFileSecurity works similar to LookupAccountName 
				in that the first call get need buffer sizes */
		 

			// Use a fairly larger buffer size of returned size value.
			// This will keep the number of malloc type calls down.
			SidsizeFromGetFileSecurity = LARGEPSID;
			BoolStatus = GetFileSecurityBackup(RFile, 
					si, 
					SidFromGetFileSecurity, 
					SidsizeFromGetFileSecurity,  /* buffer size */
					&lpcbsdRequired,    /* required buffer size */
					BackPriv);
		 if(!BoolStatus)
		 {
		 // GetFileSecurity failed need to check if buffer was to small
			if(lpcbsdRequired != 0)
			{
				SidsizeFromGetFileSecurity = lpcbsdRequired;
				// Reallocate the memory to the new size
				SidFromGetFileSecurity =  GlobalReAlloc( SidFromGetFileSecurity, lpcbsdRequired, GMEM_ZEROINIT);  
				BoolStatus = GetFileSecurityBackup(RFile, 
					si, 
					SidFromGetFileSecurity, 
					SidsizeFromGetFileSecurity,    
					&lpcbsdRequired,     
					BackPriv);
				if(!BoolStatus)
				{
					 
					return(FALSE);
			 }

			}
			// Have general failure this is a access priv problem.
			DisplayPerms(RFile, FALSE);
		}
		if(BoolStatus)  // Valid file security discriptor
		{
			grant_mask = 0;
	
			if(!GetFilePermissions(SidFromGetFileSecurity, (PSID) UserSid))
				return(FALSE);
			// Need to chech for directory structure
			if(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				 // Display the directory perms
				 strcat(RFile, "\\");
				 DisplayPerms(RFile, TRUE);
				 // Recurse subdirectories
				 // Need the Filename, Path, user account sid, and Backup priv flag
				 RecurseSubs(FindFileData.cFileName, RPath, SidFromLookupName, BackPriv,
				 Recurse);
		 
			}
			else
				DisplayPerms(RFile, TRUE);
		} // End of valid security descriptor else
	} // end of ". or .." if
	 // Go for the next file 
	 if(!FindNextFile(FileHandle, &FindFileData))
		break;
	} // End While loop
	
	return(TRUE);
}


/* ***************************************************************
	Usage Error subroutine
******************************************************************* */


void usage(IN INT message_num, 
					 IN PCHAR string_val)
{
	if(string_val == NULL)
		fprintf(stderr, "\n%s\n", MESSAGES[message_num]);
	else
		fprintf(stderr,"\n%s %s\n", MESSAGES[message_num], string_val);
}

/*
	System Error subroutine
*/


void syserror(DWORD error_val)
{
	CHAR MessageBuf[512];
	DWORD eval,
				Lang_Val;

	Lang_Val = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
	FormatMessage(
	FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
								NULL,
								error_val,
								Lang_Val,
								(LPTSTR) MessageBuf,
								512,
								NULL);

 printf("\n%s", MessageBuf);               
}

/* ********************************************************************* */
BOOL IsDomainName(
						 IN LPSTR TestDomainName, 
						 IN LPSTR DomainNameBuff)
{
	NTSTATUS dNtStatus;
	ANSI_STRING  AnsiString;
	UNICODE_STRING UDomainName;
	NET_API_STATUS NetCallStatus;
	LPBYTE xbuff = NULL;
	LPWSTR NDomainName;
	UINT BuffSize;
	INT AnsiSize, slen;
	
	UDomainName.Buffer = NULL;
	// get a unicode string  
	RtlInitAnsiString( &AnsiString, TestDomainName );
	dNtStatus = RtlAnsiStringToUnicodeString( &UDomainName, &AnsiString, TRUE );
	// Free up the ansi string to use it later
//	RtlFreeAnsiString(&AnsiString);
	// Compute the needed amount of memory for a zero terminated string  
	// Allocate the memory and zero it 
	BuffSize = (UINT) (UDomainName.Length * 2) + 4;
	NDomainName = LocalAlloc( (UINT) LPTR, 
								 BuffSize);        

	if (NDomainName == NULL)
	{
			syserror(GetLastError());
			exit(FALSE);                                                          
	}                                                                           
	// Copy the wide string to the allocated memory 
	RtlMoveMemory( NDomainName, UDomainName.Buffer, BuffSize-4);
	// Should now have a zero terminated string
	
	// now check for the domain name 
	NetCallStatus = NetGetDCName(NULL, NDomainName,
																 &xbuff );
	if(NetCallStatus == ERROR_SUCCESS)
	{
		// Convert the wchar null string to ansi sting is passed back machine 
		// name of domain controler
		// Use the current unicode buffer
		slen = wcslen((USHORT *) xbuff) * 2;
		UDomainName.Length = (USHORT) slen;
		UDomainName.MaximumLength = (USHORT) slen + 2;
		UDomainName.Buffer = (PWSTR) xbuff;
		dNtStatus = RtlUnicodeStringToAnsiString( &AnsiString, &UDomainName, TRUE );
		// return the string pointer
		RtlMoveMemory( DomainNameBuff, AnsiString.Buffer, 
		(UINT) strlen(AnsiString.Buffer) +1);
		LocalFree(NDomainName);

		return(TRUE);
	}
	LocalFree(NDomainName);

	return(FALSE);
}

/* ********************************************************************* */

BOOL
LookupAllUserSidsWS( IN LPSTR lpSystemName  
		)

/*++

Routine Description:


Arguments:


Return Value:

		BOOL - TRUE is returned if successful, else FALSE.

--*/

{
	NTSTATUS xNtStatus;
	ANSI_STRING  AnsiString;
	UNICODE_STRING USystemName;
	ULONG Count;
	OBJECT_ATTRIBUTES ObjectAttributes;
	SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
	LSA_HANDLE PolicyHandle = NULL;
	UNICODE_STRING AccountDomainName;
	PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo;
	USystemName.Buffer = NULL;

		
		
		RtlInitAnsiString( &AnsiString, lpSystemName );
		xNtStatus = RtlAnsiStringToUnicodeString( &USystemName, &AnsiString, TRUE );

		if (!NT_SUCCESS(xNtStatus)) 
		{
			SetLastError(xNtStatus);
			return(FALSE);
		}
		//
		// Open a handle to the target Workstation's Policy Object so that we can
		// information from it and also so that we can use it for looking up.
		// Sids
		//

		InitObjectAttributes(
											&ObjectAttributes,
											&SecurityQualityOfService
														);


		xNtStatus = LsaOpenPolicy(
											&USystemName,   // WorkstationName,
											&ObjectAttributes,
											POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,
											&PolicyHandle
													);

		if (!NT_SUCCESS(xNtStatus)) 
		{
			// try local machine
			PolicyHandle = NULL;
			xNtStatus = LsaOpenPolicy(
											NULL,    // WorkstationName,
											&ObjectAttributes,
											POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,
											&PolicyHandle
													);


			if (!NT_SUCCESS(xNtStatus)) 
			{
				SetLastError(xNtStatus);
				return(FALSE);
			}
		}
		//  Lookup the Group Sids contained in the Workstation's                                                                             
		// SAM Account Domain
		//
		// First, obtain the Name and Sid of the SAM Account Domain from the
		// Workstation's LSA Policy Object.
		//
		 

		xNtStatus = LsaQueryInformationPolicy(
		PolicyHandle,
		PolicyAccountDomainInformation,
		(PVOID *) &PolicyAccountDomainInfo
		);
		
		if (!NT_SUCCESS(xNtStatus)) 
		{
			SetLastError(xNtStatus);
			return(FALSE);
		}

		AccountDomainName = PolicyAccountDomainInfo->DomainName;
		
		xNtStatus = LsaClose(PolicyHandle);
		if(!NT_SUCCESS(xNtStatus)) 
		{

			SetLastError(xNtStatus);
			return(FALSE);
		}

		if(!LookupSidsInSamDomain(
										&USystemName,   // WorkstationName,
										&USystemName,   // WorkstationName,
										&AccountDomainName
										)) 
		return(FALSE);
		
		if( USystemName.Buffer != NULL ) 
		{

				RtlFreeUnicodeString( &USystemName );
		}
		
	return(TRUE);
}


BOOL                                                                       
GeneralBuildSid(                                                         
		OUT PSID *Sid,                                                                
		IN PSID DomainSid,                                                           
		IN ULONG RelativeId                                                          
		)                                                                         

/*++                                                                          
		
Routine Description:                                                          
		
		This function builds a Sid from a Domain Sid and a RelativeId.            
		
Arguments:                                                                    
		
		Sid - Receives a pointer to the constructed Sid.                          
		
		DomainSid - Points to a Domain Sid                                        
		
		RelativeId - Contains a Relative Id

		
	
 
	
		
				
								
		BOOL - TRUE if successful, else FALSE.                                 
	
--*/                                                                          
	
{                                                                             
	PSID OutputSid = NULL;                                                      
	ULONG OutputSidLength;                                                      
	UCHAR SubAuthorityCount;
	
	SubAuthorityCount = *RtlSubAuthorityCountSid( DomainSid ) + (UCHAR) 1;      
		OutputSidLength = RtlLengthRequiredSid( SubAuthorityCount );

	OutputSid = LocalAlloc( (UINT) LMEM_FIXED, (UINT) OutputSidLength );        

	if (OutputSid == NULL) {                                                    

			return(FALSE);                                                          
	}                                                                           
 
	RtlMoveMemory( OutputSid, DomainSid, OutputSidLength - sizeof (ULONG));     
		(*RtlSubAuthorityCountSid( OutputSid ))++;                                  
		(*RtlSubAuthoritySid(OutputSid, SubAuthorityCount - (UCHAR) 1)) = RelativeId; 
 
	*Sid = OutputSid;  
	
	return(TRUE);                                                               
}                                                                             



VOID
InitObjectAttributes(
		IN POBJECT_ATTRIBUTES ObjectAttributes,
		IN PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService
		)

/* ++

Routine Description:

		This function initializes the given Object Attributes structure, including
		Security Quality Of Service.  Memory must be allcated for both
		ObjectAttributes and Security QOS by the caller.

Arguments:

		ObjectAttributes - Pointer to Object Attributes to be initialized.

		SecurityQualityOfService - Pointer to Security QOS to be initialized.

Return Value:

		None.

-- */

{
		SecurityQualityOfService->Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
		SecurityQualityOfService->ImpersonationLevel = SecurityImpersonation;
		SecurityQualityOfService->ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
		SecurityQualityOfService->EffectiveOnly = FALSE;

		//
		// Set up the object attributes prior to opening the LSA.
		//

		InitializeObjectAttributes(
				ObjectAttributes,
				NULL,
				0L,
				NULL,
				NULL
		);

		//
		// The InitializeObjectAttributes macro presently stores NULL for
		// the SecurityQualityOfService field, so we must manually copy that
		// structure for now.
		//

		ObjectAttributes->SecurityQualityOfService = SecurityQualityOfService;
}


BOOL
LookupSidsInSamDomain(
		IN OPTIONAL PUNICODE_STRING WorkstationName,
		IN PUNICODE_STRING DomainControllerName,
		IN PUNICODE_STRING SamDomainName
		)

/*++

Routine Description:

		This function enumerates all the SAM accounts of a specified type
		in a specified SAM domain on a specified target system.  The system
		must be one of the following:

		o The Workstation itself.
		o A Domain Controller for the Primary Domain of the Workstation.
		o A Domain Controller for one of the Trusted Domains of the
			Workstation.


		Having enumerated the accounts, the function then performs
		an LsaLookupSids call via the specified Workstation to lookup all of
		these account Sids, and then compares the returned information
		with that expected.

Arguments:

		WorkstationName - Specifies a Workstation Name.  The name may be
				the NULL string, which means the current system.

		DomainControllerName - Specifies the name of a target Domain Controller
				for (the Workstation's Primary Domain or one of its Trusted
				Domains.

		SamDomainName - Specifies the name of the SAM Domain. This is either
				the BUILTIN Domain or the name of the Accounts Domain.

		SamAccountType - Specifies the type of SAM account to be enumerated
				and looked up.

Return Values:

		BOOL - TRUE if successful, else FALSE.

--*/

{
		NTSTATUS CtStatus;
		BOOL BooleanStatus = TRUE;
		OBJECT_ATTRIBUTES SamObjectAttributes;
		OBJECT_ATTRIBUTES LsaObjectAttributes;
		PSID SamDomainSid = NULL;
		SID WorldTypeSid = SECURITY_WORLD_SID_AUTHORITY;
		PSAM_RID_ENUMERATION EnumerationBuffer = NULL;
		ULONG DomainIndex;
		ULONG UserAccountControl;
		ULONG GroupCount;
		ULONG SidCount=0;
		ULONG Relid=0;
		ULONG RidIndex=0;
		ULONG GenRid;
		ULONG CountReturned;
		PULONG AliasBuffer;
		UNICODE_STRING TmpDomainControllerName;
		PVOID EnumerationInformation;
		ULONG EnumerationContext;
		ULONG PreferedMaximumLength;
		
		//
		// Connect to the SAM server.
		//

				CtStatus = SamConnect(
								 DomainControllerName,
								 &SamServerHandle,
								 SAM_SERVER_ENUMERATE_DOMAINS | SAM_SERVER_LOOKUP_DOMAIN,
								 &SamObjectAttributes
								 );

			if (!NT_SUCCESS(CtStatus)) 
			{

				// try local machine
				CtStatus = SamConnect(
								 NULL,    // DomainControllerName,
								 &SamServerHandle,
								 SAM_SERVER_ENUMERATE_DOMAINS | SAM_SERVER_LOOKUP_DOMAIN,
								 &SamObjectAttributes
								 );
				if (!NT_SUCCESS(CtStatus)) 
				{
					SetLastError(CtStatus);
					return(FALSE);
				}
			}

		//
		// Lookup the Named Domain in the Sam Server to get its Sid.
		//
		CountReturned = 0;
		EnumerationContext = 0;
		EnumerationBuffer = NULL;
		PreferedMaximumLength = 512;
		CtStatus = SamEnumerateDomainsInSamServer(
														SamServerHandle,
														&EnumerationContext,
														(PVOID *) &EnumerationBuffer,
														PreferedMaximumLength,
														&CountReturned
														);
		if(!NT_SUCCESS(CtStatus)) 
		{
			SetLastError(CtStatus);
			return(FALSE);
		}

		if((INT) CountReturned == 0) 
		{
			SetLastError(CtStatus);
			return(FALSE);
		}


	 //
	 // Now look up the sid for the domains in the samserver
	 //
		
	for(DomainIndex = 0; DomainIndex < CountReturned; DomainIndex++) 
	{

//    if(SamDomainHandle != NULL)
//      CtStatus = SamCloseHandle(SamDomainHandle);
		SamDomainHandle = NULL;
		SamDomainSid = NULL;
		GroupCount = 0;
		SidCount = 0;

		CtStatus = SamLookupDomainInSamServer(
								SamServerHandle,
								(PUNICODE_STRING) &EnumerationBuffer[ DomainIndex ].Name,     // SamDomainName,
								&SamDomainSid
								);

		if(!NT_SUCCESS(CtStatus)) 
		{
			SetLastError(CtStatus);
			return(FALSE);
		}

		//
		// Open the Domain
		//
		
		CtStatus = SamOpenDomain(
								SamServerHandle,
								(GENERIC_READ | GENERIC_EXECUTE), //(DOMAIN_LIST_ACCOUNTS|DOMAIN_GET_ALIAS_MEMBERSHIP)
								SamDomainSid,
								&SamDomainHandle
								);

		if (!NT_SUCCESS(CtStatus)) 
		{
			SetLastError(CtStatus);
			return(FALSE);
		}
		CtStatus = SamGetAliasMembership(
										SamDomainHandle,
										1,
										ASidFromLookupName,
										&GroupCount,
										&AliasBuffer
										);
		 if(!NT_SUCCESS(CtStatus)) 
		 {
			SetLastError(CtStatus);
			return(FALSE);
		}

			if (GroupCount == 0)
			{
			 //  SamCloseHandle(SamDomainHandle);
				 SamFreeMemory(AliasBuffer);
				SamDomainSid = NULL;
				GroupCount = 0;
				SidCount = 0;
				continue;
			}
		//
		// Now construct the Account Sids from the Rids just enumerated.
		// We prepend the Sam Domain Sid to the Rids.
		//
			SidCount = RidIndex + GroupCount;
			for (RidIndex; RidIndex < SidCount; RidIndex++) 
			{
				Relid =  AliasBuffer[ RidIndex ];
				if (!GeneralBuildSid(
								&(AccountSids[Total_Sids++]),
								SamDomainSid,
								AliasBuffer[ RidIndex ]
								)) 
				{
					SetLastError(CtStatus);
					return(FALSE);
				}
			}  // end for loop

	// free up Sam memory to use again
	SamFreeMemory(AliasBuffer);

	}  // domain for loop 
				
	// add world sid        
	AccountSids[Total_Sids++] = SeWorldSid;


	// if interactive logon
	if(inter_logon)
	{
		// printf("\n adding Interactive sid ");
		AccountSids[Total_Sids++] = SeInteractiveSid;
	}
	else
		AccountSids[Total_Sids++] = SeNetworkSid;


	// Add in Account Sid 
	AccountSids[Total_Sids++] = SidFromLookupName;

	//
	// If necessary, close the SAM Domain Handle for the Workstation.
	//
	if(SamDomainHandle != NULL)
		CtStatus = SamCloseHandle( SamDomainHandle);
	//
	// If necessary, disconnect from the SAM Server.
	//

	if(SamServerHandle != NULL)
		CtStatus = SamCloseHandle( SamServerHandle );

	return(TRUE);
}


//
//
//

void DisplayPerms(IN LPTSTR filename, IN BOOL valid_access)
{
	if(g_noAccess)
	{
		printf("-");
		goto exit;
	}

	if(valid_access)
	{
		if(owner_flag == TRUE)
			printf("*");
		else if(owner_group == TRUE)
			printf("#");

		if( grant_mask == 0)
		{
			printf("?");
			goto exit;
		}

		if(grant_mask == FILE_GEN_ALL)
		{
			printf("A");
			goto exit;
		}
		if((FILE_GENERIC_READ & grant_mask) == FILE_GENERIC_READ)
			printf("R");

		if((FILE_GENERIC_WRITE & grant_mask) == FILE_GENERIC_WRITE)
			printf("W");
	
		if((FILE_GENERIC_EXECUTE & grant_mask) == FILE_GENERIC_EXECUTE)
			printf("X");
	
		if((DELETE & grant_mask) == DELETE)
			printf("D");
	
		if((WRITE_DAC & grant_mask) == WRITE_DAC)
			printf("P");
	
		if((WRITE_OWNER & grant_mask) == WRITE_OWNER)
			printf("O");
	} // End if !valid_access
	else
		printf("?");

exit:	
	printf("\t%s\n", filename);		
	return;
}



BOOL GetFilePermissions(
		 IN PSECURITY_DESCRIPTOR SecurityDescriptor,
		 OUT PSID UserAccountSids)

{

		PISECURITY_DESCRIPTOR ISecurityDescriptor;
		UCHAR Revision;
		SECURITY_DESCRIPTOR_CONTROL Control;
		PSID Owner;
		PSID Group;
		PACL Sacl;
		PACL Dacl;
		ULONG ui;


		ISecurityDescriptor = ( PISECURITY_DESCRIPTOR )SecurityDescriptor;

		Revision = ISecurityDescriptor->Revision;
		Control  = ISecurityDescriptor->Control;

		Owner    = SepOwnerAddrSecurityDescriptor( ISecurityDescriptor );
		Group    = SepGroupAddrSecurityDescriptor( ISecurityDescriptor );
		Sacl     = SepSaclAddrSecurityDescriptor( ISecurityDescriptor );
		Dacl     = SepDaclAddrSecurityDescriptor( ISecurityDescriptor );

		
		if(EqualSid(UserAccountSids, Owner))
			owner_flag = TRUE;
		// check all the group sids for owner
		for(ui=0; ui < Total_Sids; ui++)
		{
			if(EqualSid(AccountSids[ui], Owner))
			{
				SidOwnerGroup = AccountSids[ui];
				owner_group = TRUE;
			}
		}

		
		if(Dacl == NULL)
		{
			return(TRUE);
		}
		else
		{
			// Check the user sid ACLS
			if(!ProcessAcl( Dacl))
			{
				return(FALSE);
			}

		}
	return(TRUE);
}

/* ********************************************************************** */


// changed by a-zexu @ 5/10/98
BOOL ProcessAcl(PACL Acl)
{
	ULONG i;
	PACCESS_ALLOWED_ACE Ace;
	BOOL KnownType = FALSE;
	ULONG isid;
	ACCESS_MASK  mask = 0;
	PCHAR AceTypes[] = { "Access Allowed",
						 "Access Denied ",
						 "System Audit  ",
						 "System Alarm  " };

	
	// Check if the Acl is null.  
	if (Acl == NULL)
		return(FALSE);

	// Now for each Ace check the Sids of Owner
	if(owner_group)
	{
		mask = 0;

		for (i = 0, Ace = FirstAce(Acl);
				 i < Acl->AceCount;
				 i++, Ace = NextAce(Ace) ) 
		{
			if(EqualSid(SidOwnerGroup, &Ace->SidStart))
			{
				//  Special case on the standard ace types
				if(Ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) 
				{
					mask = Ace->Mask;
				}
				else if(Ace->Header.AceType == ACCESS_DENIED_ACE_TYPE) 
					g_noAccess = TRUE;
			}
		} //end ace loop
		
		grant_mask |= mask;
	}

	// Now for each Ace check the Sids of Everyone
	if(!g_noAccess && SidEveryone)
	{	
		mask = 0;

		for (i = 0, Ace = FirstAce(Acl);
				 i < Acl->AceCount;
				 i++, Ace = NextAce(Ace) ) 
		{
			if(EqualSid(SidEveryone, &Ace->SidStart))
			{
				//  Special case on the standard ace types
				if(Ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) 
				{
					mask = Ace->Mask;
				}
				else if(Ace->Header.AceType == ACCESS_DENIED_ACE_TYPE) 
					g_noAccess = TRUE;
			}
		} //end ace loop

		grant_mask |= mask;
	}

	// Now for each Ace check the Sids of the user
	if(!g_noAccess)
	{
		mask = 0;

		for (i = 0, Ace = FirstAce(Acl);
				 i < Acl->AceCount;
				 i++, Ace = NextAce(Ace) ) 
		{
			if(EqualSid(SidFromLookupName, &Ace->SidStart))
			{
				//  Special case on the standard ace types
				if(Ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) 
				{
					mask = Ace->Mask;
				}
				else if(Ace->Header.AceType == ACCESS_DENIED_ACE_TYPE) 
					g_noAccess = TRUE;
			}
		} //end ace loop

		grant_mask |= mask;
	}
	
	return(TRUE);
}
/********************************************************************/


BOOL
VariableInitialization()
/*++

Routine Description:

		This function initializes the global variables used by and exposed
		by security.

Arguments:

		None.

Return Value:

		TRUE if variables successfully initialized.
		FALSE if not successfully initialized.

--*/
{

		PVOID HeapHandel;                                  
																															 
		ULONG SidWithZeroSubAuthorities;
		ULONG SidWithOneSubAuthority;
		ULONG SidWithTwoSubAuthorities;
		ULONG SidWithThreeSubAuthorities;
		
		SID_IDENTIFIER_AUTHORITY NullSidAuthority;
		SID_IDENTIFIER_AUTHORITY WorldSidAuthority;
		SID_IDENTIFIER_AUTHORITY LocalSidAuthority;
		SID_IDENTIFIER_AUTHORITY CreatorSidAuthority;
		SID_IDENTIFIER_AUTHORITY SeNtAuthority;

		
																													 
		//                                                 
		// Get the handle to the current process heap      
		//                                                 

		HeapHandel = RtlProcessHeap();                     
																													 

		
		
		NullSidAuthority         = SepNullSidAuthority;
		WorldSidAuthority        = SepWorldSidAuthority;
		LocalSidAuthority        = SepLocalSidAuthority;
		CreatorSidAuthority      = SepCreatorSidAuthority;
		SeNtAuthority            = SepNtAuthority;


		//
		//  The following SID sizes need to be allocated
		//

		SidWithZeroSubAuthorities  = RtlLengthRequiredSid( 0 );
		SidWithOneSubAuthority     = RtlLengthRequiredSid( 1 );
		SidWithTwoSubAuthorities   = RtlLengthRequiredSid( 2 );
		SidWithThreeSubAuthorities = RtlLengthRequiredSid( 3 );

		//
		//  Allocate and initialize the universal SIDs
		//

		SeNullSid         = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithOneSubAuthority);
		SeWorldSid        = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithOneSubAuthority);
		SeLocalSid        = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithOneSubAuthority);
		SeCreatorOwnerSid = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithOneSubAuthority);
		SeCreatorGroupSid = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithOneSubAuthority);

		//
		// Fail initialization if we didn't get enough memory for the universal
		// SIDs.
		//

		if ( (SeNullSid         == NULL) ||
				 (SeWorldSid        == NULL) ||
				 (SeLocalSid        == NULL) ||
				 (SeCreatorOwnerSid == NULL) ||
				 (SeCreatorGroupSid == NULL)
			 ) 
		{
				return( FALSE );
		}

		RtlInitializeSid( SeNullSid,         &NullSidAuthority, 1 );
		RtlInitializeSid( SeWorldSid,        &WorldSidAuthority, 1 );
		RtlInitializeSid( SeLocalSid,        &LocalSidAuthority, 1 );
		RtlInitializeSid( SeCreatorOwnerSid, &CreatorSidAuthority, 1 );
		RtlInitializeSid( SeCreatorGroupSid, &CreatorSidAuthority, 1 );

		*(RtlSubAuthoritySid( SeNullSid, 0 ))         = SECURITY_NULL_RID;
		*(RtlSubAuthoritySid( SeWorldSid, 0 ))        = SECURITY_WORLD_RID;
		*(RtlSubAuthoritySid( SeLocalSid, 0 ))        = SECURITY_LOCAL_RID;
		*(RtlSubAuthoritySid( SeCreatorOwnerSid, 0 )) = SECURITY_CREATOR_OWNER_RID;
		*(RtlSubAuthoritySid( SeCreatorGroupSid, 0 )) = SECURITY_CREATOR_GROUP_RID;

		//
		// Allocate and initialize the NT defined SIDs
		//

		SeNetworkSid      = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithOneSubAuthority);
		SeInteractiveSid  = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithOneSubAuthority);
		SeLocalSystemSid  = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithOneSubAuthority);

		SeAliasAdminsSid   = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithTwoSubAuthorities);
		SeAliasUsersSid  = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithTwoSubAuthorities);
		SeAliasGuestsSid   = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithTwoSubAuthorities);
		SeAliasPowerUsersSid = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithTwoSubAuthorities);
		SeAliasAccountOpsSid = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithTwoSubAuthorities);
		SeAliasSystemOpsSid  = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithTwoSubAuthorities);
		SeAliasPrintOpsSid   = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithTwoSubAuthorities);
		SeAliasBackupOpsSid  = (PSID)RtlAllocateHeap(HeapHandel, 0,SidWithTwoSubAuthorities);

		//
		// Fail initialization if we didn't get enough memory for the NT SIDs.
		//

		if((SeNetworkSid          == NULL) ||
				 (SeInteractiveSid      == NULL) ||
				 (SeLocalSystemSid      == NULL) ||
				 (SeAliasAdminsSid      == NULL) ||
				 (SeAliasUsersSid       == NULL) ||
				 (SeAliasGuestsSid      == NULL) ||
				 (SeAliasPowerUsersSid  == NULL) ||
				 (SeAliasAccountOpsSid  == NULL) ||
				 (SeAliasSystemOpsSid   == NULL) ||
				 (SeAliasPrintOpsSid    == NULL) ||
				 (SeAliasBackupOpsSid   == NULL)
			 ) {
				return(FALSE);
		}

		RtlInitializeSid( SeNetworkSid,         &SeNtAuthority, 1 );
		RtlInitializeSid( SeInteractiveSid,     &SeNtAuthority, 1 );
		RtlInitializeSid( SeLocalSystemSid,     &SeNtAuthority, 1 );


		*(RtlSubAuthoritySid( SeNetworkSid,         0 )) = SECURITY_NETWORK_RID;
		*(RtlSubAuthoritySid( SeInteractiveSid,     0 )) = SECURITY_INTERACTIVE_RID;
		*(RtlSubAuthoritySid( SeLocalSystemSid,     0 )) = SECURITY_LOCAL_SYSTEM_RID;


		return(TRUE);

}


/* ************************************************************************* */



BOOL
GetTokenHandle(
		IN OUT PHANDLE TokenHandle
		)
//
// This routine will open the current process and return
// a handle to its token.
//
// These handles will be closed for us when the process
// exits.
//
{

		HANDLE ProcessHandle;
		BOOL Result;

		ProcessHandle = OpenProcess(
												PROCESS_QUERY_INFORMATION,
												FALSE,
												GetCurrentProcessId()
												);

		if (ProcessHandle == NULL)
				return(FALSE);


		Result = OpenProcessToken (
								 ProcessHandle,
								 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
								 TokenHandle
								 );

		if (!Result)
				return(FALSE);

		return(TRUE);
}

/* *********************************************************************** */

BOOL
SetBackOperatorPriv(
			IN HANDLE TokenHandle
		)
//
// This routine turns on SeSetBackupPrivilege in the current
// token.  Once that has been accomplished, we can open the file
// for READ_OWNER even if we are denied that access by the ACL
// on the file.

{
		LUID SetBackupPrivilegeValue;
		TOKEN_PRIVILEGES TokenPrivileges;


		//
		// First, find out the value of Backup Privilege
		//


		if(!LookupPrivilegeValue(
								 NULL,
								 "SeBackupPrivilege",
								 &SetBackupPrivilegeValue
								 ))
				return(FALSE);

		//
		// Set up the privilege set we will need
		//

		TokenPrivileges.PrivilegeCount = 1;
		TokenPrivileges.Privileges[0].Luid = SetBackupPrivilegeValue;
		TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;




		(VOID) AdjustTokenPrivileges (
								TokenHandle,
								FALSE,
								&TokenPrivileges,
								sizeof( TOKEN_PRIVILEGES ),
								NULL,
								NULL
								);

		if(GetLastError() != NO_ERROR ) 
				return(FALSE);

		return(TRUE);
}




BOOL
GetFileSecurityBackupW(
		LPWSTR lpFileName,
		SECURITY_INFORMATION RequestedInformation,
		PSECURITY_DESCRIPTOR pSecurityDescriptor,
		DWORD nLength,
		LPDWORD lpnLengthNeeded,
		BOOL UseBackUp
		)

/*++

Routine Description:

		This API returns top the caller a copy of the security descriptor
		protecting a file or directory.  Based on the caller's access
		rights and privileges, this procedure will return a security
		descriptor containing the requested security descriptor fields.
		To read the handle's security descriptor the caller must be
		granted READ_CONTROL access or be the owner of the object.  In
		addition, the caller must have SeSecurityPrivilege privilege to
		read the system ACL.

Arguments:

		lpFileName - Represents the name of the file or directory whose
				security is being retrieved.

		RequestedInformation - A pointer to the security information being
				requested.

		pSecurityDescriptor - A pointer to the buffer to receive a copy of
				the secrity descriptor protecting the object that the caller
				has the rigth to view.  The security descriptor is returned in
				self-relative format.

		nLength - The size, in bytes, of the security descriptor buffer.

		lpnLengthNeeded - A pointer to the variable to receive the number
				of bytes needed to store the complete secruity descriptor.  If
				returned number of bytes is less than or equal to nLength then
				the entire security descriptor is returned in the output
				buffer, otherwise none of the descriptor is returned.

Return Value:

		TRUE is returned for success, FALSE if access is denied or if the
				buffer is too small to hold the security descriptor.


--*/
{
		NTSTATUS WStatus;
		HANDLE FileHandle;
		ACCESS_MASK DesiredAccess;

		OBJECT_ATTRIBUTES Obja;
		UNICODE_STRING FileName;
		RTL_RELATIVE_NAME RelativeName;
		IO_STATUS_BLOCK IoStatusBlock;
		PVOID FreeBuffer;

		QuerySecAccessMask(
				RequestedInformation,
				&DesiredAccess
				);

		if(!RtlDosPathNameToNtPathName_U(
														lpFileName,
														&FileName,
														NULL,
														&RelativeName
														))
			return(FALSE);

		FreeBuffer = FileName.Buffer;

		if(RelativeName.RelativeName.Length) 
		{
				FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
		}
		else 
		{
				RelativeName.ContainingDirectory = NULL;
		}

		InitializeObjectAttributes(
				&Obja,
				&FileName,
				OBJ_CASE_INSENSITIVE,
				RelativeName.ContainingDirectory,
				NULL
				);
		// Check for backup operator priv.
		if(UseBackUp)
		{
			WStatus = NtOpenFile(
								 &FileHandle,
								 DesiredAccess,
								 &Obja,
								 &IoStatusBlock,
								 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 
								 FILE_OPEN_FOR_BACKUP_INTENT  
								 );
		}
		else
		{
			WStatus = NtOpenFile(
								 &FileHandle,
								 DesiredAccess,
								 &Obja,
								 &IoStatusBlock,
								 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 
								 0
								 );
		}

		RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

		if(NT_SUCCESS(WStatus)) 
		{
				WStatus = NtQuerySecurityObject(
										 FileHandle,
										 RequestedInformation,
										 pSecurityDescriptor,
										 nLength,
										 lpnLengthNeeded
										 );
				NtClose(FileHandle);
		}


		if(!NT_SUCCESS(WStatus)) 
		{
		 //   LastNTError(WStatus);
				return(FALSE);
		}

		return(TRUE);
}

BOOL
GetFileSecurityBackup(
		LPSTR lpFileName,
		SECURITY_INFORMATION RequestedInformation,
		PSECURITY_DESCRIPTOR pSecurityDescriptor,
		DWORD nLength,
		LPDWORD lpnLengthNeeded,
		BOOL BackUpPrivFlag
		)

/*++

Routine Description:

		ANSI thunk to GetFileSecurityBackupW

--*/

{

		PUNICODE_STRING Unicode;
		ANSI_STRING AnsiString;
		NTSTATUS FStatus;

		Unicode = &NtCurrentTeb()->StaticUnicodeString;
		RtlInitAnsiString(&AnsiString,lpFileName);
		FStatus = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
		if(!NT_SUCCESS(FStatus)) 
		{
		 //   LastNTError(FStatus);
				return FALSE;
		}
		return ( GetFileSecurityBackupW( Unicode->Buffer,
															 RequestedInformation,
															 pSecurityDescriptor,
															 nLength,
															 lpnLengthNeeded,
															 BackUpPrivFlag
												)
					 );
}





VOID
QuerySecAccessMask(
		IN SECURITY_INFORMATION SecurityInformation,
		OUT LPDWORD DesiredAccess
		)

/*++

Routine Description:

		This routine builds an access mask representing the accesses necessary
		to query the object security information specified in the
		SecurityInformation parameter.  While it is not difficult to determine
		this information, the use of a single routine to generate it will ensure
		minimal impact when the security information associated with an object is
		extended in the future (to include mandatory access control information).

Arguments:

		SecurityInformation - Identifies the object's security information to be
				queried.

		DesiredAccess - Points to an access mask to be set to represent the
				accesses necessary to query the information specified in the
				SecurityInformation parameter.

Return Value:

		None.

--*/

{

		//
		// Figure out accesses needed to perform the indicated operation(s).
		//

		(*DesiredAccess) = 0;

		if ((SecurityInformation & OWNER_SECURITY_INFORMATION) ||
				(SecurityInformation & GROUP_SECURITY_INFORMATION) ||
				(SecurityInformation & DACL_SECURITY_INFORMATION)) {
				(*DesiredAccess) |= READ_CONTROL;
		}

		if ((SecurityInformation & SACL_SECURITY_INFORMATION)) {
				(*DesiredAccess) |= ACCESS_SYSTEM_SECURITY;
		}

		return;

} // end function




/* ******************************************************************
	 This routines filter out odd user inputs . .. ../ / _: and
	 unc //xxx/xxx. The routine adds a backslash to root level
	 directories only. For the "FROM" String.
	 ****************************************************************** */
BOOL CleanUpSource(IN LPTSTR InString,
		 OUT LPTSTR OutString,
		 OUT BOOL *DirectoryFlag)
{
	LPTSTR searchchar,
				 schar,
				 OutstringAddr=NULL;

	char CurDir[STANDARD_BUFFER_SIZE],
			 SaveCurDir[STANDARD_BUFFER_SIZE],
			 TempBuff[STANDARD_BUFFER_SIZE];
	DWORD DirNameLen;
	BOOL Valid=TRUE;

	strcpy(OutString, InString);
	
	OutstringAddr=OutString;

	// Check for ":" file type
	searchchar = strchr(OutString, ':');
	if(searchchar != NULL)
	{
		// Have a device type root dir
		// Check the next char of NULL
		searchchar++;
		if(*searchchar == (CHAR) NULL)
		{
			// add a "\" after the ":"
			*searchchar = 0x5c;
			searchchar++;
			// Terminate the string
			*searchchar = (CHAR) NULL;
			*DirectoryFlag = TRUE;
			return(TRUE);
		}
		// Have a : Check for "\"
		// Note this takes care of _:\ paths Can't Do Checking on redirected
		// drives with findfirstfile program will blow out later
		
		if(*searchchar == 0x5c)
		{
			//check for NULL
			searchchar++;
			if(*searchchar == (CHAR) NULL)
			{
				*DirectoryFlag = TRUE;
				return(TRUE);
			}
		}
		// Need to check for relative path stuff ".\.\.." etc
		if(IsRelativeString(InString))
		{
			strcpy(TempBuff, InString);
			// Save Current directory
			DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, 
									 (LPTSTR) SaveCurDir);
			if(DirNameLen == 0)
				return(FALSE);
			// Find the end directory
			searchchar = strrchr(InString, 0x5c);       
			schar = strrchr(TempBuff, 0x5c);
			if(schar == NULL)
				return(FALSE);
			// Chech for . or ..
			schar++;
			if(*schar == '.')
			{
				schar++;
				if(*schar == '.')
				{
					schar++;
					*schar == (CHAR) NULL;
					searchchar+3;
				}
			}
			else
			{
				schar--;
				*schar == (CHAR) NULL;
			}
			// Have the path now get the real path
			if(!SetCurrentDirectory(TempBuff))
				return(FALSE);
			// Now Save the current directory
			DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) CurDir);
			if(DirNameLen == 0)
				return(FALSE);
			*OutstringAddr = (CHAR) NULL;
			// Build The String with real path
			strcpy(OutString, CurDir);
			// Remove end "\" from "C:\" GetCurrentDir.. returns with "\" on root 
			RemoveEndSlash(OutString);
			strcat(OutString, searchchar);
			// return to the user's diretory
			if(!SetCurrentDirectory(SaveCurDir))
				 return(FALSE);
		
			}
			// Check for wild card
			if(IsWildCard(OutString))
			{
				*DirectoryFlag = FALSE;
				return(TRUE);
			}
			// Check for Direcory or file
			if(!IsDirectory(OutString, &Valid))
				*DirectoryFlag = FALSE;
			else
				*DirectoryFlag = TRUE;
			
			if(Valid == FALSE)
				return(FALSE);
			return(TRUE);
	}
	// Have a nondevice name
	
	// Check for "\\" in first 2 chars in file path for UNC path
	if(strncmp(InString, "\\\\", 2) == 0)
	{
		// Bump pointer 
		InString +=3;
		// Serarch for the next "\"
		searchchar = strchr(InString, 0x5c); 
		if(searchchar == NULL)
			return(FALSE);
		// Have the 3rd one check for fourth on in typical UNC string
		searchchar++;
		searchchar = strchr(searchchar, 0x5c);
		if(searchchar == NULL)
		{ // Have UNC Pth Only
			// Need to add "\" to end of string
			strcat(OutString, "\\");
			*DirectoryFlag = TRUE;
			return(TRUE);
		}
		else
		{
			// Have the fouth "\" need to check for file or directory
			// Check for wild card
			if(IsWildCard(OutString))
			{
				*DirectoryFlag = FALSE;
				return(TRUE);
			}
			// Check for Direcory or file
			if(!IsDirectory(OutString, &Valid))
				*DirectoryFlag = FALSE;
			else
				*DirectoryFlag = TRUE;
			if(Valid == FALSE)
				return(FALSE);
			 return(TRUE);
		 }
	} // End of "\\"
										 

	 // Check for a "\"
	if(*OutString == 0x5c)
	{ 
		// Have a leading "\" check next char
		OutString++;
		if(*OutString != (CHAR) NULL)
		{
			// Check for wild card
			if(IsWildCard(InString))
			{
				*DirectoryFlag = FALSE;
				return(TRUE);
			}
			// Check for directory
			if(!IsDirectory(InString, &Valid))
				*DirectoryFlag = FALSE;
			else
				*DirectoryFlag = TRUE;
			if(Valid == FALSE)
				return(FALSE);
			 return(TRUE);
		}
		// Have a single need to get full "_:\"
		DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) CurDir);
		if(DirNameLen == 0)
			return(FALSE);
		// Now feed the result in to StripRootDir
		// Set OutString to a NULL char to recive the string
		OutString--;
		*OutString = (CHAR) NULL;
		if(!StripRootDir( (LPTSTR) CurDir, OutString))
			return(FALSE);
		*DirectoryFlag = TRUE;
		return(TRUE);
	}  // End of "\"
	
	// Now check for .. ../
	if(strncmp(InString, "..", 2) == 0)
	{
		// Save Current directory
		DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) SaveCurDir);
		if(DirNameLen == 0)
			return(FALSE);
		// Chech the Input string for the last Slash
		searchchar = strrchr(InString, 0x5c);       
		if(searchchar == NULL)
		{  // Just have .. 
			// set current dir to where the path (InString) is
			if(!SetCurrentDirectory(InString))
			return(FALSE);
			// Now Save the current directory
			DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) CurDir);
		 if(DirNameLen == 0)
				return(FALSE);
			strcpy(OutString, CurDir);
			*DirectoryFlag = TRUE;
			// return to the user's diretory
			if(!SetCurrentDirectory(SaveCurDir))
				 return(FALSE);
			return(TRUE);
		}
		else // Have smething after the ..
		{
			// Need to check for a ending ".."
			schar = strstr(searchchar, "..");
			if(schar != NULL)
			{
				// set current dir to where the path (InString) is
				if(!SetCurrentDirectory(InString))
					return(FALSE);
		
				// Now Save the current directory
				DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) CurDir);
				if(DirNameLen == 0)
					return(FALSE);
				// Save the path 
				strcpy(OutString, CurDir);
				*DirectoryFlag = TRUE;
				// return to the user's diretory
				if(!SetCurrentDirectory(SaveCurDir))
					 return(FALSE);
				return(TRUE);
			}
			// Save the last "\" Position
			schar = strrchr(OutString, 0x5c);

			// Terminate the string after the last slash 
			*schar = (CHAR) NULL;
			// set current dir to where the path (OutString) is
			if(!SetCurrentDirectory(OutString))
				return(FALSE);
			// Now Save the current directory
			DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) CurDir);
			if(DirNameLen == 0)
				return(FALSE);
			// Save the path 
			strcpy(OutString, CurDir);
			// Copy anything after and including the "\" for the input string
			strcat(OutString, searchchar);
			// Check for wildcard
			if(IsWildCard(InString))
			{
				// Restore dir path
				if(!SetCurrentDirectory(SaveCurDir))
					return(FALSE);
				*DirectoryFlag = FALSE;
				return(TRUE);
			}
			
			// Check for Direcory or file
			if(!IsDirectory(OutString, &Valid))
				*DirectoryFlag = FALSE;
			else
				*DirectoryFlag = TRUE;
			
			// Restore dir path
			if(!SetCurrentDirectory(SaveCurDir))
				return(FALSE);
			
			if(Valid == FALSE)
				return(FALSE);
			
			return(TRUE);
		}
	}  // End of "..\"


	// "." and ".\"
	if(*InString == '.')
	{
		// Save Current directory
		DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) SaveCurDir);
		if(DirNameLen == 0)
			return(FALSE);
		// Chech the Input string for the last Slash
		searchchar = strrchr(InString, 0x5c);       
		if(searchchar == NULL)
		{  // Just have . or something after it ._ 
			// set current dir to where the path (InString) is
			if(!SetCurrentDirectory(InString))
			{
				strcpy(OutString, SaveCurDir);
				// Add "\" directory
				strcat(OutString, "\\");
				strcat(OutString, InString);
				*DirectoryFlag = FALSE;
				return(TRUE);
			}
			// Now Save the current directory
			DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) CurDir);
		 if(DirNameLen == 0)
				return(FALSE);
			strcpy(OutString, CurDir);
			*DirectoryFlag = TRUE;
			// return to the user's diretory
			if(!SetCurrentDirectory(SaveCurDir))
				 return(FALSE);
			return(TRUE);
		}
		else // Have smething after the .
		{
			// Need to check for a ending ".."
			schar = strstr(searchchar, "..");
			if(schar != NULL)
			{
				// set current dir to where the path (InString) is
				if(!SetCurrentDirectory(InString))
					return(FALSE);
		
				// Now Save the current directory
				DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) CurDir);
				if(DirNameLen == 0)
					return(FALSE);
				// Save the path 
				strcpy(OutString, CurDir);
				*DirectoryFlag = TRUE;
				// return to the user's diretory
				if(!SetCurrentDirectory(SaveCurDir))
					 return(FALSE);
				return(TRUE);
			}
			// Save the last "\" Position
			schar = strrchr(OutString, 0x5c);

			// Terminate the string after the last slash 
			*schar = (CHAR) NULL;
			// set current dir to where the path (OutString) is
			if(!SetCurrentDirectory(OutString))
				return(FALSE);
			// Now Save the current directory
			DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) CurDir);
			if(DirNameLen == 0)
				return(FALSE);
			// Save the path 
			strcpy(OutString, CurDir);
			// Copy anything after and including the "\" for the input string
			strcat(OutString, searchchar);
			// Check for wildcard
			if(IsWildCard(InString))
			{
				// Restore dir path
				if(!SetCurrentDirectory(SaveCurDir))
					return(FALSE);
				*DirectoryFlag = FALSE;
				return(TRUE);
			}
			
			// Check for Direcory or file
			if(!IsDirectory(OutString, &Valid))
				*DirectoryFlag = FALSE;
			else
				*DirectoryFlag = TRUE;
			
			// Restore dir path
			if(!SetCurrentDirectory(SaveCurDir))
				return(FALSE);
			
			if(Valid == FALSE)
				return(FALSE);
			
			return(TRUE);
		}
	}  // End of "." ".\"



	// Now only have a file name or directory local
	DirNameLen = GetCurrentDirectory(STANDARD_BUFFER_SIZE, (LPTSTR) CurDir);
	if(DirNameLen == 0)
		return(FALSE);
	strcpy(OutString, CurDir);
	// Check if last last char slash
	if(!IsLastCharSlash(OutString))
		strcat(OutString, "\\");
	strcat(OutString, InString);
	// Check for wild Card
	if(IsWildCard(InString))
	{  
		*DirectoryFlag = FALSE;
		return(TRUE);
	}
	// Check for Directory
	if(!IsDirectory(OutString, &Valid))
		*DirectoryFlag = FALSE;
	else
		*DirectoryFlag = TRUE;
	if(Valid == FALSE)
		return(FALSE);
	return(TRUE);

}

/* ********************************************************************
*********************************************************************** */
BOOL IsDirectory(IN LPTSTR InTestFile,
								 IN BOOL *FileValid)
{
	WIN32_FIND_DATA FindFileData;
	HANDLE FindFileHandle;
	char IsBuff[STANDARD_BUFFER_SIZE];

	strcpy(IsBuff, InTestFile);
	if(RemoveEndSlash((LPTSTR) IsBuff))
		FindFileHandle = FindFirstFile(IsBuff, &FindFileData);
	else
		FindFileHandle = FindFirstFile(InTestFile, &FindFileData);


	if(FindFileHandle == INVALID_HANDLE_VALUE)
	{
//    printf("\n problem with findfirstfile in IsDirectory");
		*FileValid = FALSE;
		return(FALSE);
	}
	if(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	{  
		FindClose(FindFileHandle);		// changed by a-zexu @ 10/19/97
		return(TRUE);
	}
	FindClose(FindFileHandle);	// changed by a-zexu @ 10/19/97
	return(FALSE);


}


BOOL IsWildCard(LPSTR psz)
{
		char ch;

		while (ch = *psz++)
				{
				if (ch == '*' || ch == '?')
						return(TRUE);
				}
		return(FALSE);
}


BOOL RemoveEndSlash(LPSTR TestString)
{
	LPTSTR slashptr;
	
	slashptr = strrchr(TestString, 0x5c);
	if(slashptr == NULL)
		return(FALSE);
	// Check Next char for NULL
	slashptr++;
	if(*slashptr == (CHAR) NULL)
	{
		slashptr--;
		*slashptr = (CHAR) NULL;
		return(TRUE);
	}
	return(FALSE);
}


BOOL SetSlash(IN LPTSTR InString,
							IN OUT LPTSTR TestString)
{
	LPTSTR slashptr;
	strcpy(TestString, InString);  
	slashptr = strrchr(TestString, 0x5c);
	if(slashptr == NULL)
		return(FALSE);
	slashptr++;
	*slashptr = (CHAR) NULL;
	return(TRUE);
}


BOOL AddDotSlash(LPSTR TestString)
{
	LPTSTR slashptr;
	
	// Find End of String
	slashptr = strrchr(TestString, (CHAR) NULL);
	if(slashptr == NULL)
		return(FALSE);
	// Check previous char for "\"
	slashptr--;
	if(*slashptr == 0x5c)
	{
		slashptr++;
		*slashptr = '.';
		slashptr++;
		*slashptr = (CHAR) NULL;
	}
	else
	{
		slashptr++;
		*slashptr = 0x5c;
		slashptr++;
		*slashptr = '.';
		slashptr++;
		*slashptr = (CHAR) NULL;
	}
	return(TRUE);

}

BOOL AddWildCards(LPSTR TestString)
{
	LPTSTR slashptr;
	
	// Find End of String
	slashptr = strrchr(TestString, (CHAR) NULL);
	if(slashptr == NULL)
		return(FALSE);
	// Check previous char for "\"
	slashptr--;
	if(*slashptr == 0x5c)
	{
		slashptr++;
		*slashptr = '*';
		slashptr++;
		*slashptr = '.';
		slashptr++;
		*slashptr = '*';
		slashptr++;
		*slashptr = (CHAR) NULL;
	}
	else
	{
		slashptr++;
		*slashptr = 0x5c;
		slashptr++;
		*slashptr = '*';
		slashptr++;
		*slashptr = '.';
		slashptr++;
		*slashptr = '*';
		slashptr++;
		*slashptr = (CHAR) NULL;
	}
	return(TRUE);

}

BOOL IsLastCharSlash(LPSTR TestString)
{
	LPTSTR slashptr;
	
	// Find End of String
	slashptr = strrchr(TestString, (CHAR) NULL);
	if(slashptr == NULL)
		return(FALSE);
	// Check previous char for "\"
	slashptr--;
	if(*slashptr == 0x5c)
		return(TRUE);
	return(FALSE);
}


BOOL IsRelativeString(LPSTR TestString)
{
	LPTSTR slashptr;
	// Start looking for Relative strings order is important
	slashptr = strstr(TestString, "..\\");
	if(slashptr != NULL)
		return(TRUE);
	slashptr = strstr(TestString, ".\\");
	if(slashptr != NULL)
		return(TRUE);
	slashptr = strstr(TestString, "\\..");
	if(slashptr != NULL)
		return(TRUE);
	slashptr = strstr(TestString, "\\.");
	if(slashptr != NULL)
	{
		// Check Next Char for NULL or "\"
		slashptr++;
		if(*slashptr == (CHAR) NULL);
			return(TRUE);
		if(*slashptr == 0x5c);
			return(TRUE);
	}
	return(FALSE);

}


BOOL RemoveEndDot(LPSTR TestString)
{
	LPTSTR slashptr;
	
	// Find End of String
	slashptr = strrchr(TestString, (CHAR) NULL);
	if(slashptr == NULL)
		return(FALSE);
	// Check previous char for "."
	slashptr--;
	if(*slashptr == '.')
	{
		*slashptr = (CHAR) NULL;
	}
	return(TRUE);
}



/* *********************************************************************
	 ********************************************************************* */
BOOL StripRootDir(IN LPTSTR InDir,
		 OUT LPTSTR OutRootDir)
{
	LPTSTR searchchar;
	
	strcpy(OutRootDir, InDir);

	// Check for ":" file type
	searchchar = strchr(OutRootDir, ':');
	if(searchchar != NULL)
	{
		// Have a device type root dir
		searchchar++;
		// add a "\" after the ":"
		*searchchar = 0x5c;
		searchchar++;
		// Terminate the string
		*searchchar = (CHAR) NULL;
		return(TRUE);
	}
	else  // Have a nondevice name
	{
		// Check for "\\" in first 2 chars in file path for UNC path
	 if( strncmp(OutRootDir, "\\\\", 2) == 0)
	 {
		 // Bump pointer 
		 OutRootDir +=3;
		 // Serarch for the next "\"
		 searchchar = strchr(OutRootDir, 0x5c); 
		 if(searchchar == NULL)
			return(FALSE);
		 // Have the 3rd one check for fourth on in typical UNC string
		 searchchar++;
		 searchchar = strchr(searchchar, 0x5c);
		 if(searchchar == NULL)
		 { // Have UNC Pth Only
			 // Need to add "\" to end of string
			 OutRootDir += strlen(OutRootDir);
			 *OutRootDir = 0x5c;
			 ++OutRootDir;
			 *OutRootDir = (CHAR) NULL;
			 return(TRUE);
		 }
		 else
		 {
			 // Have the fouth "\"
			 ++searchchar;
			 // Add NULL
			 *searchchar = (CHAR) NULL;
			 return(TRUE);
		 }
	 }
	 else // Have a "\" or whatever
	 {
		 *OutRootDir = (CHAR) NULL;
		 return(TRUE);
	 }
	}
	// Should not get here
	return(FALSE);
}

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs\iwbreak.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997
//
//  File:       IWBreak.cxx
//
//  Contents:   FarEast Word Breaker glue code
//
//  History:    01-Jul-96   PatHal             Created.
//              merged and modifed for NT 5,   Weibz
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "iwbreak.hxx"

extern long gulcInstances;

#ifdef IWBDBG
void  WbDbgOutputInt(WCHAR *pTitle, INT  data)
{

         WCHAR  Outdbg[20];
         int    itmp, ii;

         OutputDebugStringW(pTitle);

         for (ii=0; ii<20; ii++)
           Outdbg[ii] = 0x0020;

         ii =7;
         itmp = data;
         Outdbg[ii--] = 0x0000;

         while (itmp) {

            if ( (itmp % 16) < 10 )
               Outdbg[ii] = itmp % 16 + L'0';
            else
               Outdbg[ii] = itmp % 16 + L'A' - 10;

            ii --;
            itmp = itmp / 16;
         }

         OutputDebugStringW(Outdbg);

}

#endif

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::CWordBreaker
//
//  Synopsis:   Constructor for the CWordBreaker class.
//
//  Arguments:  [lcid] -- locale id
//
//----------------------------------------------------------------------------

CWordBreaker::CWordBreaker( LCID lcid )
        : _cRefs(1),
          _lcid(lcid)
{
    InterlockedIncrement( &gulcInstances );
#if defined(TH_LOG)
    _hLog = ThLogOpen( "log.utf");
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::~CWordBreaker
//
//  Synopsis:   Destructor for the CWordBreaker class.
//
//  Notes:      All termination/deallocation is done by embedded smart pointers
//
//----------------------------------------------------------------------------

CWordBreaker::~CWordBreaker()
{
   InterlockedDecrement( &gulcInstances );
#if defined(TH_LOG)
    ThLogClose( _hLog );
#endif
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::QueryInterface( REFIID riid, void  ** ppvObject)
{
    //
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown     = 00000000-0000-0000-C000-000000000046
    // IID_IWordBreaker = D53552C8-77E3-101A-B552-08002B33B0E6
    //                    --------
    //                           |
    //                           +--- Unique!
    //

    Assert( (IID_IUnknown.Data1     & 0x000000FF) == 0x00 );
    Assert( (IID_IWordBreaker.Data1 & 0x000000FF) == 0xC8 );

    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 )
    {
    case 0x00000000:
        if ( memcmp( &IID_IUnknown, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0xD53552C8:
        if ( memcmp( &IID_IWordBreaker, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)(IWordBreaker *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;
    return(sc);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CWordBreaker::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CWordBreaker::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::Init
//
//  Synopsis:   Initialize word-breaker
//
//  Arguments:  [fQuery]         -- TRUE if query-time
//              [ulMaxTokenSize] -- Maximum size token stored by caller
//              [pfLicense]      -- Set to true if use restricted
//
//  Returns:    Status code
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::Init(
    BOOL fQuery,
    ULONG ulMaxTokenSize,
    BOOL *pfLicense )
{

    if ( NULL == pfLicense )
       return E_INVALIDARG;

    if (IsBadWritePtr(pfLicense, sizeof(DWORD))) {
        return E_INVALIDARG;
    }

    *pfLicense = TRUE;
    _fQuery = fQuery;
    _ulMaxTokenSize = ulMaxTokenSize;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::ComposePhrase
//
//  Synopsis:   Convert a noun and a modifier into a phrase.
//
//  Arguments:  [pwcNoun] -- pointer to noun.
//              [cwcNoun] -- count of chars in pwcNoun
//              [pwcModifier] -- pointer to word modifying pwcNoun
//              [cwcModifier] -- count of chars in pwcModifier
//              [ulAttachmentType] -- relationship between pwcNoun &pwcModifier
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CWordBreaker::ComposePhrase(
    WCHAR const *pwcNoun,
    ULONG cwcNoun,
    WCHAR const *pwcModifier,
    ULONG cwcModifier,
    ULONG ulAttachmentType,
    WCHAR *pwcPhrase,
    ULONG *pcwcPhrase )
{
    //
    // Need to code in later
    //
    if ( _fQuery )
        return( E_NOTIMPL );
    else
        return ( WBREAK_E_QUERY_ONLY );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::GetLicenseToUse
//
//  Synopsis:   Returns a pointer to vendors license information
//
//  Arguments:  [ppwcsLicense] -- ptr to ptr to which license info is returned
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CWordBreaker::GetLicenseToUse(
    const WCHAR **ppwcsLicense )
{
    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-1998";

    if ( NULL == ppwcsLicense )
       return E_INVALIDARG;

    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) {
        return E_INVALIDARG;
    }

    *ppwcsLicense = wcsCopyright;
    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::BreakText
//
//  Synopsis:   Break input stream into words.
//
//  Arguments:  [pTextSource] -- source of Unicode text
//              [pWordSink] -- sink for collecting words
//              [pPhraseSink] -- sink for collecting phrases
//
//  Notes:      Since the input buffer may be greater than MAX_BUFFER_LEN
//              we process the buffer in chunks of length MAX_BUFFER_LEN.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::BreakText(
    TEXT_SOURCE *pTextSource,
    IWordSink *pWordSink,
    IPhraseSink *pPhraseSink )
{

    SCODE sc = S_OK;

    if ( NULL == pWordSink ) {
        // BUGBUG, propagate the null word sink error code
        return sc;
    }

    // BUGBUG, need to normalize nums within T-Hammer, pass as flag?

    // turn on noun phrase analysis if there is a phrase sink
    if ( 0 != pPhraseSink ) {
        // BUGBUG, do we need to pass a separate flag to T-Hammer for this?
        // ignore the phrase sink for now
        // return sc;
    }

    if ( ( NULL == pTextSource ) ||
         ( pTextSource->iEnd < pTextSource->iCur ) ) {
        return E_INVALIDARG;
    }

    if (pTextSource->iEnd == pTextSource->iCur) {
        return S_OK;
    }

    CONST WCHAR *pwcInput, *pwcStem;
    ULONG cwc, cwcTail, iwcCurrent;

    DWORD i;
    BYTE ct;
    BOOL fRomanWord = FALSE;

    __try {

        cwcTail = pTextSource->iEnd - pTextSource->iCur;


#ifdef IWBDBG
        {
          WCHAR  tmp[2];
          DWORD  ii;

          WbDbgOutputInt(L"\niCur=", pTextSource->iCur);
          WbDbgOutputInt(L"\niEnd=", pTextSource->iEnd);

          OutputDebugStringW(L"\n the Source String is:\n");
          for (ii=pTextSource->iCur; ii<pTextSource->iEnd; ii++) {
            tmp[0] = *(pTextSource->awcBuffer + ii);
            tmp[1] = L'\0';
            OutputDebugStringW(tmp);
          }

          OutputDebugStringW(L"\n");

        }

#endif
        do {

            cwc = pTextSource->iEnd - pTextSource->iCur;

            // Reinit the callback data structure
            iwcCurrent = pTextSource->iCur;
            pwcStem = pwcInput = pTextSource->awcBuffer + pTextSource->iCur;

            for (i=0; i< cwc; i++, pwcInput++) {

                if (*(pwcInput) != 0) {
                    ct = GetCharType(*pwcInput);

                    if (ct == CH) {
                        if (!fRomanWord) {
                            pwcStem = pwcInput;
                            fRomanWord = TRUE;
                        }
                    }
                    else {
                        if (fRomanWord) {
                            DWORD cwcTemp = (DWORD)(pwcInput - pwcStem);
                            if (cwcTemp > 0) {
                                (pWordSink->PutWord)(cwcTemp, pwcStem, cwcTemp,
                                 iwcCurrent + (i - cwcTemp));
                            }
                            fRomanWord = FALSE;
                        }
//                        else {
                            switch (ct) {
                            case PS:
                                (pWordSink->PutBreak)( WORDREP_BREAK_EOS );
                            case WS:
                                break;
                            default:
                                (pWordSink->PutWord)(1, pwcInput, 1, iwcCurrent + i);
                                break;
                            }
//                        }
                    }
                }
            }

            if ( !fRomanWord )
               pTextSource->iCur += i;
            else {
               CONST WCHAR  *pStart;

               pStart = pTextSource->awcBuffer + pTextSource->iCur;
               pTextSource->iCur += (DWORD)(pwcStem - pStart);

               fRomanWord = FALSE;
            }

            cwcTail = pTextSource->iEnd - pTextSource->iCur;

        } while ( SUCCEEDED(pTextSource->pfnFillTextBuffer(pTextSource)) );

        // Don't ignore the tail HPB
        if (cwcTail > 0) {

            iwcCurrent = pTextSource->iCur;
            pwcInput = pTextSource->awcBuffer + pTextSource->iCur;


            for (i=0; i< cwcTail; i++, pwcInput++) {
                if (*(pwcInput) != 0) {
                    ct = GetCharType(*pwcInput);

                    if (ct == CH) {
                        if (!fRomanWord) {
                            pwcStem = pwcInput;
                            fRomanWord = TRUE;
                        }
                    }
                    else {
                        if (fRomanWord) {
                            DWORD cwcTemp = (DWORD)(pwcInput - pwcStem);
                            (pWordSink->PutWord)(cwcTemp, pwcStem, cwcTemp,
                                iwcCurrent + (i - cwcTemp));
                            fRomanWord = FALSE;
                        }
//                        else {
                            switch (ct) {
                            case PS:
                                (pWordSink->PutBreak)( WORDREP_BREAK_EOS );
                            case WS:
                                break;
                            default:
                                (pWordSink->PutWord)(1, pwcInput, 1, iwcCurrent + i);
                                break;
                            }
//                        }
                    }
                }
            }
        }

        // put the last English word
        if (fRomanWord) {
            DWORD cwcTemp = (DWORD)(pwcInput - pwcStem);

            assert( cwctemp > 0 );

            if ( 0 == *(pwcInput-1) ) {
                 i--;
                 cwcTemp--;
            }

            (pWordSink->PutWord)(cwcTemp, pwcStem, cwcTemp,
                                 iwcCurrent + (i - cwcTemp));

            fRomanWord = FALSE;
        }

    } __except(1) {

        sc = E_UNEXPECTED;
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    01-July-96       PatHal        Created
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <excpt.h>

#define UNICODE

// NT Private includes
#include "filter.h"
#include "query.h"
#include "cierror.h"
#include "assert.h"

extern "C"
{
#   include "thammer.h"
#   include "thammerp.h"
#   include "ctplus0.h"
#if defined(TH_LOG)
#   include "log.h"
#endif // TH_LOG
}

#undef Assert
#define Assert(a)

// Base services
//

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs\iwbreak2.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997
//
//  File:       IWBreak.cxx
//
//  Contents:   FarEast Word Breaker glue code
//
//  History:    01-Jul-96   PatHal             Created.
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "iwbreak.hxx"

extern long gulcInstances;

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::CWordBreaker
//
//  Synopsis:   Constructor for the CWordBreaker class.
//
//  Arguments:  [lcid] -- locale id
//
//----------------------------------------------------------------------------

CWordBreaker::CWordBreaker( LCID lcid )
        : _cRefs(1),
          _lcid(lcid)
{
    InterlockedIncrement( &gulcInstances );
#if defined(TH_LOG)
    _hLog = ThLogOpen( "log.utf");
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::~CWordBreaker
//
//  Synopsis:   Destructor for the CWordBreaker class.
//
//  Notes:      All termination/deallocation is done by embedded smart pointers
//
//----------------------------------------------------------------------------

CWordBreaker::~CWordBreaker()
{
   InterlockedDecrement( &gulcInstances );
#if defined(TH_LOG)
    ThLogClose( _hLog );
#endif
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::QueryInterface( REFIID riid, void  ** ppvObject)
{
    //
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown     = 00000000-0000-0000-C000-000000000046
    // IID_IWordBreaker = D53552C8-77E3-101A-B552-08002B33B0E6
    //                    --------
    //                           |
    //                           +--- Unique!
    //

    Assert( (IID_IUnknown.Data1     & 0x000000FF) == 0x00 );
    Assert( (IID_IWordBreaker.Data1 & 0x000000FF) == 0xC8 );

    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 )
    {
    case 0x00000000:
        if ( memcmp( &IID_IUnknown, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0xD53552C8:
        if ( memcmp( &IID_IWordBreaker, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)(IWordBreaker *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;
    return(sc);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CWordBreaker::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CWordBreaker::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::Init
//
//  Synopsis:   Initialize word-breaker
//
//  Arguments:  [fQuery]         -- TRUE if query-time
//              [ulMaxTokenSize] -- Maximum size token stored by caller
//              [pfLicense]      -- Set to true if use restricted
//
//  Returns:    Status code
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::Init(
    BOOL fQuery,
    ULONG ulMaxTokenSize,
    BOOL *pfLicense )
{
    if (IsBadWritePtr(pfLicense, sizeof(DWORD))) {
        return E_FAIL;
    }

    *pfLicense = TRUE;
    _fQuery = fQuery;
    _ulMaxTokenSize = ulMaxTokenSize;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::ComposePhrase
//
//  Synopsis:   Convert a noun and a modifier into a phrase.
//
//  Arguments:  [pwcNoun] -- pointer to noun.
//              [cwcNoun] -- count of chars in pwcNoun
//              [pwcModifier] -- pointer to word modifying pwcNoun
//              [cwcModifier] -- count of chars in pwcModifier
//              [ulAttachmentType] -- relationship between pwcNoun &pwcModifier
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CWordBreaker::ComposePhrase(
    WCHAR const *pwcNoun,
    ULONG cwcNoun,
    WCHAR const *pwcModifier,
    ULONG cwcModifier,
    ULONG ulAttachmentType,
    WCHAR *pwcPhrase,
    ULONG *pcwcPhrase )
{
    //
    // Need to code in later
    //
    if ( _fQuery )
        return( E_NOTIMPL );
    else
        return ( WBREAK_E_QUERY_ONLY );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::GetLicenseToUse
//
//  Synopsis:   Returns a pointer to vendors license information
//
//  Arguments:  [ppwcsLicense] -- ptr to ptr to which license info is returned
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CWordBreaker::GetLicenseToUse(
    const WCHAR **ppwcsLicense )
{
    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-1995";
    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) {
        return E_FAIL;
    }

    *ppwcsLicense = wcsCopyright;
    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::BreakText
//
//  Synopsis:   Break input stream into words.
//
//  Arguments:  [pTextSource] -- source of Unicode text
//              [pWordSink] -- sink for collecting words
//              [pPhraseSink] -- sink for collecting phrases
//
//  Notes:      Since the input buffer may be greater than MAX_BUFFER_LEN
//              we process the buffer in chunks of length MAX_BUFFER_LEN.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::BreakText(
    TEXT_SOURCE *pTextSource,
    IWordSink *pWordSink,
    IPhraseSink *pPhraseSink )
{
    SCODE sc = S_OK;

    if ( 0 == pWordSink ) {
        // BUGBUG, propagate the null word sink error code
        return sc;
    }

    // BUGBUG, need to normalize nums within T-Hammer, pass as flag?

    // turn on noun phrase analysis if there is a phrase sink
    if ( 0 != pPhraseSink ) {
        // BUGBUG, do we need to pass a separate flag to T-Hammer for this?
        // ignore the phrase sink for now
        // return sc;
    }

    if ( ( 0 == pTextSource ) ||
         ( pTextSource->iEnd < pTextSource->iCur ) ) {
        return E_FAIL;
    }

    if (pTextSource->iEnd == pTextSource->iCur) {
        return S_OK;
    }

    CONST WCHAR *pwcInput, *pwcStem;
    ULONG cwc, cwcTail, iwcCurrent;

    DWORD i;
    BYTE ct;
    BOOL fRomanWord = FALSE;

    __try {

        cwcTail = pTextSource->iEnd - pTextSource->iCur;

#if defined(TH_LOG)
        // DEBUG:  Print out one QUERY or INDEX banner per entry to BreakText
        //
        WCHAR wszBanner[256];
        if (_fQuery) {
            wsprintfW( wszBanner, L"\r\n== QUERY ===================================================\r\n");
        }
        else {
            wsprintfW( wszBanner, L"\r\n== INDEX ===================================================\r\n");
        }
        ThLogWrite( _hLog, wszBanner );
#endif // defined(TH_LOG)

        do {

            cwc = pTextSource->iEnd - pTextSource->iCur;

            // Reinit the callback data structure
            iwcCurrent = pTextSource->iCur;
            pwcStem = pwcInput = pTextSource->awcBuffer + pTextSource->iCur;

#if defined(TH_LOG)
            // DEBUG:  Print out one of these banners for every buffer of text
            //
            wsprintfW( wszBanner, L"\r\n*********************************************************\r\n");
            ThLogWrite( _hLog, wszBanner );
            wsprintfW( wszBanner, L"iCur = %d, iEnd = %d\r\n\r\n", pTextSource->iCur, pTextSource->iEnd);
            ThLogWrite( _hLog, wszBanner );
            WCHAR *pwc = (WCHAR*)LocalAlloc( LMEM_FIXED, (cwc+1) * sizeof(WCHAR));
            if (pwc != NULL) {
                memcpy( pwc, &pTextSource->awcBuffer[ pTextSource->iCur ], cwc * sizeof(WCHAR) );
                *(pwc+cwc)=L'\0';
                ThLogWrite( _hLog, pwc );
                LocalFree(pwc);
            }
#endif defined(TH_LOG)

            for (i=0; i< cwc-1; i++, pwcInput++) {
                if (*(pwcInput+1) != 0) {
                    ct = GetCharType(*pwcInput);

                    if (ct == CH) {
                        if (!fRomanWord) {
                            pwcStem = pwcInput;
                            fRomanWord = TRUE;
                        }
                    }
                    else {
                        if (fRomanWord) {
                            DWORD cwcTemp = pwcInput - pwcStem;
                            if (cwcTemp > 0) {
                                (pWordSink->PutWord)(cwcTemp, pwcStem, cwcTemp,
                                 iwcCurrent + (i - cwcTemp));
                            }
                            fRomanWord = FALSE;
                        }
                        else {
                            switch (ct) {
                            case PS:
                                (pWordSink->PutBreak)( WORDREP_BREAK_EOS );
                            case WS:
                                break;
                            default:
                                (pWordSink->PutWord)(2, pwcInput, 2, iwcCurrent + i);
                                break;
                            }
                        }
                    }
                }
            }

            pTextSource->iCur += i;
            cwcTail = 1;

        } while ( SUCCEEDED(pTextSource->pfnFillTextBuffer(pTextSource)) );

        // Don't ignore the tail HPB
        if (cwcTail > 1) {

            iwcCurrent = pTextSource->iCur;
            pwcInput = pTextSource->awcBuffer + pTextSource->iCur;

#if defined(TH_LOG)
            wsprintfW( wszBanner, L"\r\n** TAIL *************************************************\r\n");
            ThLogWrite( _hLog, wszBanner );
            wsprintfW( wszBanner, L"iCur = %d, iEnd = %d, cwcTail = %d\r\n\r\n", pTextSource->iCur, pTextSource->iEnd, cwcTail);
            ThLogWrite( _hLog, wszBanner );
            WCHAR *pwc = (WCHAR*)LocalAlloc( LMEM_FIXED, (cwcTail+1) * sizeof(WCHAR));
            if (pwc != NULL) {
                memcpy( pwc, &pTextSource->awcBuffer[ pTextSource->iCur ], cwcTail * sizeof(WCHAR) );
                *(pwc+cwcTail)=L'\0';
                ThLogWrite( _hLog, pwc );
                LocalFree(pwc);
            }
#endif defined(TH_LOG)

            for (i=0; i< cwcTail-1; i++, pwcInput++) {
                if (*(pwcInput+1) != 0) {
                    ct = GetCharType(*pwcInput);

                    if (ct == CH) {
                        if (!fRomanWord) {
                            pwcStem = pwcInput;
                            fRomanWord = TRUE;
                        }
                    }
                    else {
                        if (fRomanWord) {
                            DWORD cwcTemp = pwcInput - pwcStem;
                            (pWordSink->PutWord)(cwcTemp, pwcStem, cwcTemp,
                                iwcCurrent + (i - cwcTemp));
                            fRomanWord = FALSE;
                        }
                        else {
                            switch (ct) {
                            case PS:
                                (pWordSink->PutBreak)( WORDREP_BREAK_EOS );
                            case WS:
                                break;
                            default:
                                (pWordSink->PutWord)(2, pwcInput, 2, iwcCurrent + i);
                                break;
                            }
                        }
                    }
                }
            }
        }

        // put the last English word
        if (fRomanWord) {
            DWORD cwcTemp = pwcInput - pwcStem;
            if (cwcTemp > 0) {
                (pWordSink->PutWord)(cwcTemp, pwcStem, cwcTemp,
                iwcCurrent + (i - cwcTemp));
            }
            fRomanWord = FALSE;
        }

    } __except(1) {

        sc = E_UNEXPECTED;
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

RCOPTIONS=-l 804

SYNCHRONIZE_DRAIN=1

C_DEFINES=$(C_DEFINES) -DCHINESES

MAJORCOMP=INTLWB
MINORCOMP=ChsBrKr

USE_MSVCRT=0

TARGETNAME=ChsBrKr
TARGETPATH=obj
TARGETTYPE=DYNLINK

SUBSYSTEM_VERSION=4.00


INCLUDES=..;$(INCLUDES)


SOURCES=..\ChsBrkr.rc \
        ..\wbclassf.cxx\
        ..\exports.cxx\
        ..\iwbreak.cxx\
        ..\stemcf.cxx\
        ..\stemmer.cxx\
        ..\register.cxx \
        ..\ctplus0.c\
        ..\log.c

UMTYPE=windows

DLLBASE=0x44e00000

DLLENTRY=DllMain

PRECOMPILED_INCLUDE=..\pch.cxx

CONDITIONAL_INCLUDES= \
        $(CONDITIONAL_INCLUDES) \
        thammer.h

DLLDEF=..\ChsBrKr.def

#
# Support for IceCap profiling.
#

!if "$(PERFFLAGS)" == "TRUE"
! if exist ($(SDK_LIB_PATH)\icap.lib)
!  if !defined(MSC_Optimiztion)
MSC_OPTIMIZATION=-Oxs -Gh -MD
!  elseif "$(MSC_OPTIMIZATION)" == "-GX"
MSC_OPTIMIZATION=-Oxs -GX -Gh -MD
!  else
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) -Gh -MD
!  endif

USE_PDB=1

!  if "$(USE_PENTER)" == "TRUE"
LINKLIBS=$(LINKLIBS) $(SDK_LIB_PATH)\penter.lib
UMLIBS=$(UMLIBS) $(SDK_LIB_PATH)\penter.lib
!  else
LINKLIBS=$(LINKLIBS) $(SDK_LIB_PATH)\ICAP.lib
UMLIBS=$(UMLIBS) $(SDK_LIB_PATH)\ICAP.lib
!  endif

!  if "$(DBG)" == "1"
!   message Warning: Profiling with DBG on!
!  endif

! else
!  error Cannot build for IceCap profiling without ICAP.LIB
! endif
!endif

LINKER_FLAGS=$(LINKER_FLAGS) -IGNORE:4077

LINKLIBS=$(LINKLIBS)\
         $(SDK_LIB_PATH)\ntdll.lib \
         $(SDK_LIB_PATH)\user32.lib\
         $(SDK_LIB_PATH)\kernel32.lib\
         $(SDK_LIB_PATH)\advapi32.lib \
         $(SDK_LIB_PATH)\uuid.lib\
         $(SDK_LIB_PATH)\query.lib

MISCFILES=..\noise.chs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs\precomp.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1994, Microsoft Corporation.  All Rights Reserved.
//
//  File:       precomop.h
//
//  Contents:   Internal include file for Token Hammer.
//
//  History:    22-May-95       PatHal          Created
//
//---------------------------------------------------------------------------

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#define UNICODE
#include <windows.h>
#include <memory.h>
#include <malloc.h>
#include <string.h>
#include <wchar.h>
#include <excpt.h>

//#include "cierror.h"
#include  "ctplus0.h"
//#include  "filter.h"
#include  "log.h"
//#include  "query.h"
#include  "thammer.h"
#include  "thammerp.h"

#define unreference(x)  (x)

#endif //_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs\register.cxx ===
//+---------------------------------------------------------------------------
//
// Copyright (C) 1998 - 1999, Microsoft Corporation.
//
// File:        Register.cxx
//
// Contents:    Self-registration for Word Breaker /Stemmer.
//
// Functions:   DllRegisterServer, DllUnregisterServer
//
// History:     12-Jan-98       Weibz       Created
//              08-Jan-99       AlanW       Modified to use langreg.hxx
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "langreg.hxx"

//
// Registry constants
//

SLangRegistry const LangResource = {
    L"Chinese_Simplified",
    2052,
    {   L"{9717fc70-c1bc-11d0-9692-00a0c908146e}",
        L"Chinese_Simplified Word Breaker",
        L"chsbrkr.dll", L"Both" },

    {   L"{9768f960-c1bc-11d0-9692-00a0c908146e}",
        L"Chinese_Simplified Stemmer",
        L"chsbrkr.dll", L"Both" }
};


//+---------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Self-registration
//
//  History:    12-Jan-98       Weibz       Created 
//
//----------------------------------------------------------------------------

STDAPI DllUnregisterServer()
{
    long dwErr = UnRegisterALanguageResource( LangResource );
    if ( ERROR_SUCCESS != dwErr )
        return S_FALSE;

    return S_OK;
} //DllUnregisterServer

//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Self-registration
//
//  History:    12-Jan-98       Weibz       Created
//
//----------------------------------------------------------------------------

STDAPI DllRegisterServer()
{
    //
    // Register classes
    //

    long dwErr = RegisterALanguageResource( LangResource );

    if ( ERROR_SUCCESS != dwErr )
        return SELFREG_E_CLASS;

    return S_OK;
} //DllRegisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs\log.c ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1994, Microsoft Corporation.  All Rights Reserved.
//
//  File:       Log.c
//
//  Contents:   Logging code.
//
//  History:    18-Dec-96   pathal     Created.
//
//---------------------------------------------------------------------------

#include "precomp.h"

#if defined(_DEBUG) || defined( TH_LOG)

VOID
ThLogWrite(
    HANDLE hLogFile,
    WCHAR *pwszLog)
{
    DWORD cbToWrite, cbWritten;
    PVOID pv;

    if (hLogFile != NULL) {
        pv = pwszLog;
        cbToWrite = lstrlen(pwszLog) * sizeof(WCHAR);

        if (!WriteFile( hLogFile, pv, cbToWrite, &cbWritten, NULL) ||
             (cbToWrite != cbWritten)) {
            wprintf(L"Error: WriteFile word failed with error %d.\r\n", GetLastError());
        }
    }
}


HANDLE
ThLogOpen(
    IN CONST CHAR *pszLogFile)
{
    HANDLE hLogFile;

    hLogFile = CreateFileA( pszLogFile, GENERIC_WRITE, 0, NULL,
             CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hLogFile!=INVALID_HANDLE_VALUE) {
        WCHAR wszUniBOM[3] = { 0xFEFF, 0, 0 };
        ThLogWrite( hLogFile, wszUniBOM );
    }

    return hLogFile;
}

VOID
ThLogClose(
    IN HANDLE hLogFile )
{
    if (hLogFile != NULL) {
        CloseHandle( hLogFile );
    }
}

#endif // defined(_DEBUG) || defined( TH_LOG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs\log.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.  All Rights Reserved.
//
//  File:       Log.h
//
//  History:    18-Dec-96   PatHal      Created.
//
//---------------------------------------------------------------------------

#if defined(_DEBUG) || defined(TH_LOG)

VOID ThLogWrite( HANDLE hLogFile, WCHAR *pwsz );
HANDLE ThLogOpen( CONST CHAR *pszLog );
VOID ThLogClose( HANDLE hLogFile );

#else

#define ThLogWrite( hLogFile, pwsz)
#define ThLogOpen( pwszLog )
#define ThDebugCloseLog( hLogFile )

#endif // defined(_DEBUG) || defined(TH_LOG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs\stemmer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1995.
//
//  File:       stemmer.cxx
//
//  Contents:   NLG's FarEast Stemmer
//
//  History:    01-July-1996   PatHal       Created.
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "stemmer.hxx"

extern long gulcInstances;

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::CStemmer
//
//  Synopsis:   Constructor for the CStemmer class.
//
//  Arguments:  [lcid] -- locale id
//
//----------------------------------------------------------------------------

CStemmer::CStemmer( LCID lcid )
        : _cRefs(1)
{
   InterlockedIncrement( &gulcInstances );
}


//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::~CStemmer
//
//  Synopsis:   Destructor for the CStemmer class.
//
//  Notes:      All termination/deallocation is done by embedded smart pointers
//
//----------------------------------------------------------------------------

CStemmer::~CStemmer()
{
   InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::QueryInterface( REFIID riid, void  ** ppvObject)
{
    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 & 0x000000FF )
    {
    case 0x00:
        if ( riid == IID_IUnknown )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0x40:
        if ( riid == IID_IStemmer )
            pUnkTemp = (IUnknown *)(IStemmer *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;
    return(sc);
}


//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CStemmer::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CStemmer::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::Init
//
//  Synopsis:   Initialize stemmer
//
//  Arguments:  [ulMaxTokenSize] -- Maximum size token stored by caller
//              [pfLicense]      -- Set to true if use restricted
//
//  Returns:    Status code
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::Init(
    ULONG ulMaxTokenSize,
    BOOL *pfLicense )
{

    if ( NULL == pfLicense )
       return E_INVALIDARG;

    if (IsBadWritePtr(pfLicense, sizeof(DWORD))) {
        return E_INVALIDARG;
    }

    *pfLicense = TRUE;
    _ulMaxTokenSize = ulMaxTokenSize;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::GetLicenseToUse
//
//  Synopsis:   Returns a pointer to vendors license information
//
//  Arguments:  [ppwcsLicense] -- ptr to ptr to which license info is returned
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CStemmer::GetLicenseToUse( const WCHAR **ppwcsLicense )
{
    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-1998";

    if (NULL == ppwcsLicense )
       return E_INVALIDARG;

    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) {
        return E_INVALIDARG;
    }

    *ppwcsLicense = wcsCopyright;
    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::StemWord
//
//  Synopsis:   Stem a word into its inflected forms, eg swim to swims and swimming
//
//  Arguments:  [pwcInBuf] -- input Unicode word
//              [cwc] -- count of characters in word
//              [pStemSink] -- sink to collect inflected forms
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::StemWord(
    WCHAR const *pwc,
    ULONG cwc,
    IStemSink *pStemSink )
{
    SCODE sc = S_OK;

    if ( NULL == pStemSink || NULL == pwc ) {
        return E_FAIL;
    }

    if ( 0 == cwc) {
        return S_OK;
    }

    CONST WCHAR *pwcStem;
    DWORD i;
    BYTE ct;
    BOOL fRomanWord = FALSE;

    __try {

        for ( i=0; i< cwc; i++, pwc++) {
            ct = GetCharType(*pwc);

            if (ct == CH) {
                if (!fRomanWord) {
                    pwcStem = pwc;
                    fRomanWord = TRUE;
                }
            }
            else {
                if (fRomanWord) {
                    (pStemSink->PutWord)( pwcStem, (DWORD)(pwc - pwcStem) );
                    fRomanWord = FALSE;
                }
//                else {
                    switch (ct) {
                    case PS:
                    case WS:
                        break;
                    default:
                        (pStemSink->PutWord)( pwc, 1 );
                        break;
                    }
//                }
            }
        }

        // put the last English word
        if (fRomanWord) {
            (pStemSink->PutWord)( pwcStem, (DWORD)(pwc - pwcStem) );
            fRomanWord = FALSE;
        }

        // output inflected words to stemmer sink in EnumInflections callback
    } __except (1) {

        sc = E_UNEXPECTED;
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs\stemcf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       stemcf.cxx
//
//  Contents:   Stemmer class factory
//
//  History:    01-July-1996     PatHal   Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "stemcf.hxx"
#include "stemmer.hxx"

extern long gulcInstances;

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::CStemmerCF
//
//  Synopsis:   Stemmer class factory constructor
//
//--------------------------------------------------------------------------

CStemmerCF::CStemmerCF( LCID lcid )
        : _cRefs( 1 ), _lcid( lcid )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::~CStemmerCF
//
//  Synopsis:   Stemmer class factory destructor
//
//--------------------------------------------------------------------------

CStemmerCF::~CStemmerCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerCF::QueryInterface( REFIID riid,
                                                        void  ** ppvObject )
{
    //
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown      = 00000000-0000-0000-C000-000000000046
    // IID_IClassFactory = 00000001-0000-0000-C000-000000000046
    //                           --
    //                           |
    //                           +--- Unique!
    //

    Assert( (IID_IUnknown.Data1      & 0x000000FF) == 0x00 );
    Assert( (IID_IClassFactory.Data1 & 0x000000FF) == 0x01 );

    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 & 0x000000FF )
    {
    case 0x00:
        if ( riid == IID_IUnknown )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0x01:
        if ( riid == IID_IClassFactory )
            pUnkTemp = (IUnknown *)(IClassFactory *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;

    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CStemmerCF::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CStemmerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::CreateInstance
//
//  Synopsis:   Creates new CStemmer object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerCF::CreateInstance( IUnknown * pUnkOuter,
                                                    REFIID riid,
                                                    void  * * ppvObject )
{
    CStemmer *pIUnk = 0;
    SCODE sc = S_OK;

    __try
    {
        pIUnk = new CStemmer( _lcid );
        sc = pIUnk->QueryInterface(  riid , ppvObject );

        pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    __except(1)
    {
        Assert( 0 == pIUnk );

        sc = E_UNEXPECTED;
    }

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs\stemmer2.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1995.
//
//  File:       stemmer.cxx
//
//  Contents:   NLG's FarEast Stemmer
//
//  History:    01-July-1996   PatHal       Created.
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "stemmer.hxx"

extern long gulcInstances;

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::CStemmer
//
//  Synopsis:   Constructor for the CStemmer class.
//
//  Arguments:  [lcid] -- locale id
//
//----------------------------------------------------------------------------

CStemmer::CStemmer( LCID lcid )
        : _cRefs(1)
{
   InterlockedIncrement( &gulcInstances );
}


//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::~CStemmer
//
//  Synopsis:   Destructor for the CStemmer class.
//
//  Notes:      All termination/deallocation is done by embedded smart pointers
//
//----------------------------------------------------------------------------

CStemmer::~CStemmer()
{
   InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::QueryInterface( REFIID riid, void  ** ppvObject)
{
    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 & 0x000000FF )
    {
    case 0x00:
        if ( riid == IID_IUnknown )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0x40:
        if ( riid == IID_IStemmer )
            pUnkTemp = (IUnknown *)(IStemmer *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;
    return(sc);
}


//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CStemmer::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CStemmer::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::Init
//
//  Synopsis:   Initialize stemmer
//
//  Arguments:  [ulMaxTokenSize] -- Maximum size token stored by caller
//              [pfLicense]      -- Set to true if use restricted
//
//  Returns:    Status code
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::Init(
    ULONG ulMaxTokenSize,
    BOOL *pfLicense )
{
    if (IsBadWritePtr(pfLicense, sizeof(DWORD))) {
        return E_FAIL;
    }

    *pfLicense = TRUE;
    _ulMaxTokenSize = ulMaxTokenSize;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::GetLicenseToUse
//
//  Synopsis:   Returns a pointer to vendors license information
//
//  Arguments:  [ppwcsLicense] -- ptr to ptr to which license info is returned
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CStemmer::GetLicenseToUse( const WCHAR **ppwcsLicense )
{
    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-1995";

    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) {
        return ( E_FAIL );
    }

    *ppwcsLicense = wcsCopyright;
    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::StemWord
//
//  Synopsis:   Stem a word into its inflected forms, eg swim to swims and swimming
//
//  Arguments:  [pwcInBuf] -- input Unicode word
//              [cwc] -- count of characters in word
//              [pStemSink] -- sink to collect inflected forms
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::StemWord(
    WCHAR const *pwc,
    ULONG cwc,
    IStemSink *pStemSink )
{
    SCODE sc = S_OK;

    if ( 0 == pStemSink || 0 == pwc ) {
        return E_FAIL;
    }

    if ( 0 == cwc) {
        return S_OK;
    }

    CONST WCHAR *pwcStem;
    DWORD i;
    BYTE ct;
    BOOL fRomanWord = FALSE;

    __try {

        for ( i=1; i< ( cwc - 1 ); i++, pwc++) {
            ct = GetCharType(*pwc);

            if (ct == CH) {
                if (!fRomanWord) {
                    pwcStem = pwc;
                    fRomanWord = TRUE;
                }
            }
            else {
                if (fRomanWord) {
                    (pStemSink->PutWord)( pwcStem, pwc - pwcStem );
                    fRomanWord = FALSE;
                }
                else {
                    switch (ct) {
                    case PS:
                    case WS:
                        break;
                    default:
                        (pStemSink->PutWord)( pwc, 2 );
                        break;
                    }
                }
            }
        }

        // put the last English word
        if (fRomanWord) {
            (pStemSink->PutWord)( pwcStem, pwc - pwcStem );
            fRomanWord = FALSE;
        }

        // output inflected words to stemmer sink in EnumInflections callback
    } __except (1) {

        sc = E_UNEXPECTED;
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs\thammerp.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1994, Microsoft Corporation.  All Rights Reserved.
//
//  File:       thammerp.h
//
//  History:    07-Jun-95   PatHal      Created.
//
//---------------------------------------------------------------------------

#ifndef _THAMMERP_H_
#define  _THAMMERP_H_

// Following values used for setting fMode parameters when calling
// the EnumTokens or Tokenize api.  These are used to control the content
// of the pichOffsets, pwszStem, and pwszToken strings sent to the callback
// procedure.  Note: default is fastest.

// "Selection Chunks" mode is used for Word Smart Selection.  Offsets sent
// to the callback do not necessarily correspond to morphemes boundaries.
// The chunk boundary offsets are encoded in the Japanese morphology
// that exists in T-Hammer as a resource.
#define TOKENIZE_MODE_SELECTION_OFFSETS          0x00000010

// "Stem Chunks" mode is used for Auto Summarization.  Offsets sent
// to the callback correspond to stems (and one containing all bound morphemes)
// LATER!  How should prefixes be handled?  If we remove them from the
// output then the last offset of one call will no longer equal the first offset from
// the next call.
#define TOKENIZE_MODE_STEM_OFFSETS               0x00000020

// " Summarization Stems" mode is used for Auto Summarization.  Output
// is the "stem" portion of the Bunsetsu Phrase.  For example, for Japanese
// "oyogu" the outputted form would be the stem "oyo".
#define TOKENIZE_MODE_SUMMARIZATION_OFFSETS       0x00000040

// "Break Compounds" is a special mode that instructs t-hammer to break
// compound nouns in the stem.  Use this with "Summarization Stems".
// The default is to not break the compounds (i.e. this is off by default).
#define TOKENIZE_MODE_BREAK_COMPOUNDS           0x00000080

// "ChBreak Unknowns" is a special mode that controls tokenization of unknown
// strings.  When set this forces T-Hammer to output unknown stems on a per
// character basis.  By default, this is not set which means that an unknown string
// (for example, a proper name) is outputted as a single contiguous chunk
#define TOKENIZE_MODE_CHBREAK_UNKNOWNS          0x00000100

// "Stem Info" mode is used for Dictionary Form and for obtaining POS and MCat
//  info for all.  Each callback contains one stem.  Prefixes are ignored
#define TOKENIZE_MODE_STEM_INFO               0x00000200

// "Sentence Offsets" mode is used to return sentence breaks - no further
// analysis is performed.  This is useful to segment corpora before adding
// to a test database (e.g. Babble)
#define TOKENIZE_MODE_SENTENCE_OFFSETS               0x00000400

// "Best Break" is the default.  Only the single most
// probable breaks will be output.
#define TOKENIZE_MODE_BEST_BREAK                0x00001000

// "Alternate Breaks" instructs tokenizer to output all possible
// breaks
#define TOKENIZE_MODE_ALTERNATE_BREAKS          0x00020000

// "Bunsetsu Phrases" is a default, too.   Outputs phrase breaks.
// Warning: for a word-tagged corpus, use "Break Morpheme"
#define TOKENIZE_MODE_BUNSETSU_PHRASES          0x00040000

// "Best Tags" is also default.  Outputs only one most probable
// tag for a given segmentation.   Break ambiguity and tag ambiguity are
// orthogonal attributes of the output string, hence you can "or" them together
#define TOKENIZE_MODE_BEST_TAGS                 0x00080000

// "Alternate Tags" instructs tokenizer to output all possible taggings for
// each break.  Warning: for some languages, there will be many more tag
// alternatives than break alternatives, so the output will be quite verbose.
#define TOKENIZE_MODE_ALTERNATE_TAGS            0x00100000

// "Debug" instructs tokenizer to output morpheme label information for
// alternates and tag strings for morphemes
#define TOKENIZE_MODE_VERBOSE                     0x00200000




// "Output DebugLog" is only meaningful useful for debug builds.  Setting
// this flag on and calling debug T-Hammer has the effect that T-Hammer
// outputs verbose tracing information for the morphology and stem analysis
// to a separate file named debug.utf.  CAUTION: this file is typically 500 times
// the size of the source corpus in size, so be forewarned.
#define TOKENIZE_MODE_OUTPUT_DEBUGLOG           0x00800000

// "Disable PL" means the Primary Lexicon will be disabled. This mode is for
// debug purposes only. Retail versions don't have it.
#define TOKENIZE_MODE_DISABLE_PL                0x01000000

// Instrumentation switches for collecting scoring statistics
// First switch is for Postfix Score Info
#define TOKENIZE_MODE_SCOREINFO_POSTFIX           0x02000000
// Second switch is for SPB Scoring Info
#define TOKENIZE_MODE_SCOREINFO_SPB           0x04000000

// Output morpheme records for FE-Morph API
#define TOKENIZE_MODE_MORPHEME_RECORDS          0x10000000

// Output multiple selection analyses for tagging tool
#define TOKENIZE_MODE_SELECTION_OFFSETS_EX      0x20000000

// Output summarization offsets with POS for spelling variant(conversion)
#define TOKENIZE_MODE_SUMMARIZATION_OFFSETS_EX1  0x40000000

// Output words in their dictionary form
#define TOKENIZE_MODE_DICTIONARY_FORM  0x80000000

// Output words in their dictionary form
#define TOKENIZE_MODE_SEPARATE_MORPHEMES  0x00400000

// The EnumPhrases and batch-processing Tokenize api are only used in the debug build


//+--------------------------------------------------------------------------
// defines and typedefs for "Record" subsystem
//---------------------------------------------------------------------------

#define IATTR_NIL  0
#define IATTR_SPB  1
#define IATTR_STEM 2
#define IATTR_POS  3
#define IATTR_MCAT 4
#define IATTR_FT   5
#define IATTR_LT   6

#define TH_NULL_HANDLE (TH_HANDLE)0

typedef UINT TH_HANDLE;

typedef struct tagTH_ATTRVAL
{
    UINT      iAttr; // attribute index
    TH_HANDLE hVal;  // value handle
} TH_ATTRVAL, *PTH_ATTRVAL;

typedef struct tagTH_RECORD
{
    UINT cAttrMax;
    UINT cAttrVals;
    TH_ATTRVAL *pAttrVals; // variable length attribute value array

    UINT cBitMax;
    UINT cBitVals;
    DWORD *pBitVals;  // variable length bit value array
} TH_RECORD, *PTH_RECORD;

typedef enum tagTH_TYPE
{
    TH_TYPE_INT = 1,
    TH_TYPE_STR,
    TH_TYPE_REG,
    // add more here
    TH_TYPE_MAX
} TH_TYPE;

#define TYPEOF(x)  HIWORD(x)
#define INDEXOF(x) LOWORD(x)

// pcai - 6/18/97 Makes it clear for MCat's
//
typedef BYTE MCAT;
#define SV_WORD_LEN_MAX     0x10
#define SV_WORD_IREAD_MAX   SV_WORD_LEN_MAX


//+--------------------------------------------------------------------------
//  Routine:    EnumPhrasesCallback
//
//  Synopsis: Sends delimited output (tokens) to test app callback procedure
//
//  Parameters:
//      pwszToken- pointer to wide character token string,
//      fTokenType - flag describing the types of tag in pwszToken (see above).
//
// Returns:
//  TRUE - to abort token enumeration
//  FALSE - to continue
//---------------------------------------------------------------------------
// BOOL
// EnumPhrasesCallback (
//     PWSTR pwszToken,
//     DWORD fTokenType);

typedef BOOL (CALLBACK * ENUM_PHRASES_CALLBACK)(
    IN PWSTR pwszToken,
    IN DWORD fTokenType,
    IN OUT LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumPhrases (corresponds to mode 4 of tokenize test harness)
//
//  Synopsis:  This is the entry point for tokenizing phrases.  Sends tokenized
//  phrases which can either be offsets or zero-delimited strings to the callback
//  (defined below)
//
//  Parameters:
//  pwszText - pointer to wide-character text buffer to be tokenized,
//  cchText - count of characters in text buffer,
//  fTokenizeMode - flag describing the callback mode  (see above),
//     pEnumTokOutputProc - pointer to callback procedure handling token
//     enumeration,
//  lpData - client defined data
//
//  Returns:
//      TH_ERROR_SUCCESS - if the call completed successfully
//      TH_ERROR_NOHPBS - if there were no HPBs
//      TH_ERROR_INVALID_INPUT - if the input buffer was bad
//      TH_ERROR_INVALID_CALLBACK - if the input callback was bad
//---------------------------------------------------------------------------
INT
APIENTRY
EnumPhrases(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_PHRASES_CALLBACK pcbEnumPhrases,
    IN LPARAM lpData);

typedef INT (APIENTRY *LP_ENUM_PHRASES)(
   IN PCWSTR pwszText,
   IN DWORD cchText,
   IN DWORD fBeginEndHPBMode,
   IN ENUM_PHRASES_CALLBACK pcbEnumPhrases,
   IN LPARAM lpData);

// T-Hammer uses the folg. values to set the fTokenType parameter
// when calling back to EnumTokOutputProc.  The Tokenize test app
// uses this type information to control the comparison to the re-
// tokenized corpus as well as to format the output in general.

// "Phrase" signifies that the the end of the pwszToken string marks a
// phrase boundary.  This is the default.
#define TOKEN_TYPE_PHRASE            0x01

// "Morpheme" signifies an intra-phrase morpheme
// boundary (including the stem).
#define TOKEN_TYPE_MORPHEME     0x02

// "Alternate" signifies that the current pwszToken string is an alternate
// (primary tokens are sent before alternates).
#define TOKEN_TYPE_ALTERNATE    0x04

// "Hard Break" signifies an unambiguous text boundary.
// Note that between punctuation types the output is either all alternate
// or all non-alternate.  Any bitwise OR combination of the following
// types is possible.
#define TOKEN_TYPE_HARDBREAK  0x08

// "Label" means the token should not be used to compare to test corpus,
// but should be output parenthetically (or stored as the morpheme name),
// for example with enclosing parens
#define TOKEN_TYPE_LABEL             0x10

// "Stem" signifies that this morpheme is part of the head which corresponds
// to a "jiritsugo" for Japanese.  This is used for coloring in the tagtool
#define TOKEN_TYPE_STEM             0x20

//+--------------------------------------------------------------------------
//  Routine:    Tokenize
//
//  Synopsis: Internal word-breaker entry point for executing tokenization.
//  Returns array of delimited offsets in pibBreaks
//
//  Parameters:
//  pwszText - pointer to wide-character text buffer to be tokenized,
//  cchText - count of characters in text buffer,
//  pichBreaks - pointer to return buffer, which is filled with delimiter (breaks) offset information
//  pcBreaks - size of previous buffer; number of actual breaks used is returned
//
//  Returns:
//       TH_ERROR_SUCCESS - if the call completed successfully
//       TH_ERROR_INVALID_INPUT - if the input buffer was bad
//       TH_ERROR_INVALID_CALLBACK - if the input callback was bad
//
//  Note: Tokenize will never fail with NOHPBs, since it assumes that
//  the beginning and ends are HPBs
//
//  Notes:
//      Like lstrlen, this function try/excepts on the input buffer and returns FALSE when an exception
//      involving invalid memory dereferencing.
//
//  Open Issue:
//  1.  Do we need to change the name of this API?  "Tokenize" is a generic
//       name - maybe we should save it for a more general-purpose API.
//---------------------------------------------------------------------------
INT
APIENTRY
Tokenize(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fTokenizeMode,
    OUT PDWORD pichBreaks,
    IN OUT PDWORD cBreaks);

typedef DWORD (APIENTRY *LP_TOKENIZE)(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fTokenizeMode,
    OUT PDWORD pichBreaks,
    IN OUT PDWORD cBreaks);

//+--------------------------------------------------------------------------
//  Routine:    EnumSummarizationOffsetsEx
//
//  Temporary private entry point to overload Summarization and get back the
//  number of cch procesed.  Please refer to EnumSummarizationOffsets (thammer.h)
//  for details
//---------------------------------------------------------------------------
INT
APIENTRY
EnumSummarizationOffsetsEx(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_SUMMARIZATION_OFFSETS_CALLBACK pcbEnumSummarizationOffsets,
    IN OUT DWORD *pcchTextProcessed,
    IN LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumSelectionOffsetsExCallback
//
//  Synopsis: same as EnumSelectionOffsetsCallback with an added parameter
//  that allows mutliple analyses to be sent back to client
//
//  Parameters:
//      ...
//      fInfo - dword bit mask that contains info on whether an analysis is primary
//              and/or spb initial
//      ...
//---------------------------------------------------------------------------
// BOOL
// EnumSelectionOffsetsExCallback (
//    IN CONST DWORD *pichOffsets,
//    IN DWORD cOffsets,
//    IN DWORD fInfo,
//    IN OUT LPARAM lpData);

#define SELN_OFFSETS_INFO_PRIMARY    0x00000001
#define SELN_OFFSETS_INFO_SPB_END    0x00000002

typedef BOOL (CALLBACK * ENUM_SELECTION_OFFSETS_EX_CALLBACK)(
    IN CONST DWORD *pichOffsets,
    IN CONST DWORD cOffsets,
    IN CONST DWORD fInfo,
    IN OUT LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumSelectionOffsetsEx
//
//  Synopsis:  Same as EnumSelectionOffsets, but takes an "extended" callback
//   (see above for details)
//---------------------------------------------------------------------------
INT
APIENTRY
EnumSelectionOffsetsEx(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_SELECTION_OFFSETS_EX_CALLBACK pcbEnumSelectionOffsetsEx,
    IN LPARAM lpData);

typedef INT (APIENTRY *LP_ENUM_SELECTION_OFFSETS_EX)(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_SELECTION_OFFSETS_EX_CALLBACK pcbEnumSelectionOffsetsEx,
    IN LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:  EnumSPBRecordsCallback
//
//  Synopsis:
//
//  Parameters:
//      pRec - points to an array of TH_RECORDs
//      cRec - number of TH_RECORD structs in the pRec[] array
//      iScoreIPL - well-formedness score of the given sentence.
//      pvData - points to client defined data
//
//  Returns:
//---------------------------------------------------------------------------
// BOOL
// EnumSPBRecordsCallback(
//    IN PTH_RECORD pRec,
//    IN DWORD cRec,
//    IN DWORD dwFlags,
//    IN DWORD iScoreIPL,
//    IN PVOID pvData);

#define SPBRECS_SENTEDGE 0x00000001

typedef BOOL (CALLBACK * ENUM_SPB_RECORD_CALLBACK)(
    IN PTH_RECORD pRec,
    IN DWORD cRec,
    IN DWORD dwFlags,
    IN DWORD iScoreIPL,
    IN PVOID pvData);

//+--------------------------------------------------------------------------
//  Routine:  EnumSPBRecords
//
//  Synopsis: 
//
//  Parameters:
//      pwszText - points to a sentence to analyze
//      pcbEnumSPBRecordsCB - callback function pointer.
//      lpData - points to client defined data
//
//  Returns:
//---------------------------------------------------------------------------
INT APIENTRY
EnumSPBRecords(
    IN PCWSTR pwszText,
    IN DWORD fMode,               // for TOKENIZE_MODE_DICTIONARY_FORM
    IN ENUM_SPB_RECORD_CALLBACK pcbEnumSPBRecordsCB,
    IN PVOID pvData);

typedef INT (APIENTRY *LP_ENUM_SPB_RECORDS)(
    IN PCWSTR pwszText,
    IN DWORD fMode,               // for TOKENIZE_MODE_DICTIONARY_FORM
    IN ENUM_SPB_RECORD_CALLBACK pcbEnumSPBRecordsCB,
    IN PVOID pvData);


PCWSTR
GetStringVal(
    TH_HANDLE hVal);

typedef PCWSTR (APIENTRY *LP_GET_STRING_VAL)(
    TH_HANDLE hVal);

DWORD
GetIntegerVal(
    TH_HANDLE hVal);

typedef DWORD (APIENTRY *LP_GET_INTEGER_VAL)(
    TH_HANDLE hVal);

TH_HANDLE
GetAttr(
    const PTH_RECORD pRec,
    UINT iAttr);

typedef TH_HANDLE (APIENTRY *LP_GET_ATTR) (
    const PTH_RECORD pRec,
    UINT iAttr);

//+--------------------------------------------------------------------------
//  Routine:  FxCallback
//
//  Synopsis:
//
//  Parameters:
//
//  Returns:
//---------------------------------------------------------------------------
// BOOL WINAPI
// FxCallback(
//    DWORD iFilter,
//    WCHAR *pwzFilter,
//    DWORD cRec,
//    TH_RECORD *pRec,
//    VOID *pvData);
//
typedef BOOL (WINAPI *LP_FXCB)(
    IN DWORD iFilter,
    IN WCHAR *pwzFilter,
    DWORD cRec,
    TH_RECORD *pRec,
    IN VOID *pvData);

//+--------------------------------------------------------------------------
//  Routine:  Fx
//
//  Synopsis:
//
//  Parameters:
//
//  Returns:
//---------------------------------------------------------------------------
BOOL WINAPI
Fx(
    IN PVOID *ppvFilter,
    IN DWORD cFilter,
    IN PCWSTR pwzPhrase,
    IN LP_FXCB pfnFxCallback,
    IN PVOID pvData);

typedef BOOL (WINAPI *LP_FX)(
    IN PVOID *ppvFilter,
    IN DWORD cFilter,
    IN PCWSTR pwzPhrase,
    IN LP_FXCB pfnFxCallback,
    IN PVOID pvData);

// SV-related structs and functions

//+--------------------------------------------------------------------------
//  Structure:  SV_INFO
//
//  Synopsis:   This structure is used by the SVAPI functions.
//
//---------------------------------------------------------------------------
typedef struct _SVINFO
{
    unsigned sid   : 18;        // sense id
    unsigned svid  : 6;         // id for spelling variant
    unsigned cRead : 8;         // # of elements in the reading chain for this sid
    BYTE bIPL;                  // IPL of this spelling variant
    MCAT mcat;                  // index of MCat

    // array of reading indices for the sid
    // if awRead[i] < READING_BASE, it represents a kana
    // otherwise, (awRead[i] - READING_BASE) is the
    // index into the reading table
    WORD aiwRead[SV_WORD_IREAD_MAX];

} SV_INFO;

//+--------------------------------------------------------------------------
//  Routine:  SVFindSid
//
//  Fill SV_INFO structure by searching for pwzWord in the SV-lexicon.
//  This routine is called in order to normalize/convert/reconvert
//  a word to its matching sense id(s).  This routine returns one or more
//  SV_INFO records, each being a match to the word.
//
//  Parameters: pwzWord = pointer to word for which an sid is needed
//              pwzMcat = MCat string.
//                        If pwzMcat is not valid , search for the best sid
//                        in all MCat's.
//              asvi    = array of SV_INFO for receiving sid, svid
//                        and reading indices
//                          (must be pre-allocated by the caller)
//              csviMax    = Max # of matches desired.
//                        SVFINDSID_GET_FIRST: only the first match
//                        SVFINDSID_GET_BEST: only the best match(lowest IPL)
//                        Otherwise, the first bMax matches.
//
//  Returns:    SVFINDSID_RET_NONE - no matches are found
//              otherwise returns the number of matches returned in asvi
//
//---------------------------------------------------------------------------
DWORD APIENTRY
SV_FindSid(
        IN CONST WCHAR *pwzWord,
        IN CONST WCHAR *pwzMcat,
    IN OUT SV_INFO *asvi,
    IN DWORD csviMax);

typedef DWORD (APIENTRY *LP_SV_FINDSID) (
        IN CONST WCHAR *pwzWord,
        IN CONST WCHAR *pwzMcat,
        IN OUT SV_INFO *asvi,
    IN DWORD csviMax);

//+--------------------------------------------------------------------------
//  Routine:  SVFindSid
//
//  Get sv orthography given SV_INFO structure.
//
//  Parameters: pwzWord = pointer to word for receiving the sv's orthography
//                          (must be pre-allocated by the caller)
//              psvi    = pointer to SV_INFO for receiving return information
//                          (must contain meaningful information)
//
//  Returns:    TRUE - successful
//              FALSE - unsuccessful
//---------------------------------------------------------------------------
BOOL APIENTRY
SV_GetOrtho(
        IN SV_INFO *psvi,
        IN OUT WCHAR *pwzOrtho);

typedef BOOL (APIENTRY *LP_SV_GETORTHO) (
        IN SV_INFO *psvi,
        IN OUT WCHAR *pwzOrtho);

//+--------------------------------------------------------------------------
//  Routine:  TurnOn_FindSVStems
//
//  Synopsis:   Turn on the flag for using FindSVStems().
//
//  Parameters: none
//
//  Returns:    none
//---------------------------------------------------------------------------
BOOL APIENTRY SV_EnableFindSVStems();

typedef VOID (APIENTRY *LP_SV_ENABLE_FINDSVSTEMS) ();

#define SVID_ALL_KANJI          0
#define SVID_ALL_KANA           1

#define SV_FINDSID_GET_FIRST 1
#define SV_FINDSID_GET_BEST  0xFFFFFFFF

// SVFindSid's return values
#define SV_FINDSID_RET_NONE  0
#define SV_FINDSID_ERROR     0xFFFFFFFF

#endif // _THAMMERP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\cfactory.cpp ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CFactory
Purpose:   Base class for reusing a single class factory for
           all components in a DLL
Remarks:
Owner:     i-shdong@microsoft.com
Platform:  Win32
Revise:    First created by: i-shdong    11/17/1999
============================================================================*/
#include "MyAfx.h"

#include "Registry.h"
#include "CUnknown.h"
#include "CFactory.h"


// Static variables
LONG CFactory::s_cServerLocks = 0 ;    // Count of locks

HMODULE CFactory::s_hModule = NULL ;   // DLL module handle

// CFactory implementation

// Constructor
CFactory::CFactory(const CFactoryData* pFactoryData)
: m_cRef(1)
{
    m_pFactoryData = pFactoryData ;
}

// IUnknown implementation

HRESULT __stdcall CFactory::QueryInterface(REFIID iid, void** ppv)
{
    IUnknown* pI ;
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory)) {
        pI = this ;
    } else {
       *ppv = NULL;
        return E_NOINTERFACE;
    }
    pI->AddRef() ;
    *ppv = pI ;
    return S_OK;
}

ULONG __stdcall CFactory::AddRef()
{
    return ::InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall CFactory::Release()
{
    if (::InterlockedDecrement(&m_cRef) == 0) {
        delete this;
        return 0 ;
    }
    return m_cRef;
}


// IClassFactory implementation

HRESULT __stdcall CFactory::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{

    // No Aggregate
    if (pUnknownOuter != NULL) {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create the component.
    CUnknown* pNewComponent ;
    HRESULT hr = m_pFactoryData->CreateInstance(pUnknownOuter,
                                                &pNewComponent) ;
    if (FAILED(hr)) {
        return hr ;
    }

    // Initialize the component.
    hr = pNewComponent->Init();
    if (FAILED(hr)) {
        // Initialization failed.  Release the component.
        pNewComponent->NondelegatingRelease() ;
        return hr ;
    }

    // Get the requested interface.
    hr = pNewComponent->NondelegatingQueryInterface(iid, ppv) ;

    // Release the reference held by the class factory.
    pNewComponent->NondelegatingRelease() ;
    return hr ;
}

// LockServer
HRESULT __stdcall CFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        ::InterlockedIncrement(&s_cServerLocks) ;
    } else {
        ::InterlockedDecrement(&s_cServerLocks) ;
    }

    return S_OK ;
}


// GetClassObject
//   - Create a class factory based on a CLSID.
HRESULT CFactory::GetClassObject(const CLSID& clsid,
                                 const IID& iid,
                                 void** ppv)
{
    if ((iid != IID_IUnknown) && (iid != IID_IClassFactory)) {
        return E_NOINTERFACE ;
    }

    // Traverse the array of data looking for this class ID.
    for (int i = 0; i < g_cFactoryDataEntries; i++) {
        const CFactoryData* pData = &g_FactoryDataArray[i] ;
        if (pData->IsClassID(clsid)) {

            // Found the ClassID in the array of components we can
            // create. So create a class factory for this component.
            // Pass the CFactoryData structure to the class factory
            // so that it knows what kind of components to create.
            *ppv = (IUnknown*) new CFactory(pData) ;
            if (*ppv == NULL) {
                return E_OUTOFMEMORY ;
            }
            return S_OK ;
        }
    }
    return CLASS_E_CLASSNOTAVAILABLE ;
}


// Determine if the component can be unloaded.
HRESULT CFactory::CanUnloadNow()
{
    if (CUnknown::ActiveComponents() || IsLocked()) {
        return S_FALSE ;
    } else {
        return S_OK ;
    }
}


// Register all components.
HRESULT CFactory::RegisterAll()
{
    for (int i = 0 ; i < g_cFactoryDataEntries ; i++) {
        RegisterServer(s_hModule,
                       *(g_FactoryDataArray[i].m_pCLSID),
                       g_FactoryDataArray[i].m_RegistryName,
                       g_FactoryDataArray[i].m_szVerIndProgID,
                       g_FactoryDataArray[i].m_szProgID) ;
    }
    return S_OK ;
}

HRESULT CFactory::UnregisterAll()
{
    for (int i = 0 ; i < g_cFactoryDataEntries ; i++) {
        UnregisterServer(*(g_FactoryDataArray[i].m_pCLSID),
                         g_FactoryDataArray[i].m_szVerIndProgID,
                         g_FactoryDataArray[i].m_szProgID) ;
    }
    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs\wbclassf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994
//
//  File:       wbclassf.cxx
//
//  Contents:   Word Breaker class factory
//
//  History:    01-July-1995     PatHal   Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "wbclassf.hxx"
#include "iwbreak.hxx"

extern long gulcInstances;

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::CWordBreakerCF
//
//  Synopsis:   Word Breaker class factory constructor
//
//--------------------------------------------------------------------------

CWordBreakerCF::CWordBreakerCF( LCID lcid )
        : _cRefs( 1 ), _lcid( lcid )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::~CWordBreakerCF
//
//  Synopsis:   Word Breaker class factory destructor
//
//--------------------------------------------------------------------------

CWordBreakerCF::~CWordBreakerCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CWordBreakerCF::QueryInterface( REFIID riid,
                                                        void  ** ppvObject )
{
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown      = 00000000-0000-0000-C000-000000000046
    // IID_IClassFactory = 00000001-0000-0000-C000-000000000046
    //                           --
    //                           |
    //                           +--- Unique!
    //

    Assert( (IID_IUnknown.Data1& 0x000000FF) == 0x00 );
    Assert( (IID_IClassFactory.Data1 & 0x000000FF) == 0x01 );

    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 & 0x000000FF ) {
    case 0x00:
        if ( memcmp( &IID_IUnknown, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0x01:
        if ( memcmp( &IID_IClassFactory, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)(IClassFactory *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;

    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CWordBreakerCF::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CWordBreakerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::CreateInstance
//
//  Synopsis:   Creates new CWordBreaker object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreakerCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID riid,
    void  * * ppvObject )
{
    CWordBreaker *pIUnk = 0;
    SCODE sc = S_OK;

    if (NULL != pUnkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return E_NOINTERFACE;
    }

    __try {
        pIUnk = new CWordBreaker( _lcid );
        sc = pIUnk->QueryInterface(  riid , ppvObject );

        pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    __except(1)
    {
        Assert( 0 == pIUnk );

        sc = E_UNEXPECTED;
    }

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreakerCF::LockServer(
    BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs\thammer.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1994, 1995, 1996 Microsoft Corporation.  All Rights Reserved.
//
//  File:       thammer.h
//
//  This include file defines 3 exported APIs and their callbacks that export
//  word-breaking functionality for non-spaced Asian languages (Japanese, Chinese)
//
//  Summary of exports:
//      EnumSelectionOffsets - This function returns the offsets for the
//          selection chunks as specified in the Selection Profile (set at compile-time)
//      EnumSummarizationOffsets - This function returns the offsets for the
//          prefix (if any), the stem, and bound morphemes (fuzokugo).
//      EnumStemOffsets - This function returns the offsets for the stem only.
//          Offsets corresponding to any prefix or postfix characters will not
//          be returned.
//
//  History:                    pathal          Created.
//              25-Jun-97       pathal          Add TH_ERROR_INIT_FAILED
//              05-Jul-97       pathal          Add EnumSentenceOffsets, etc.
//---------------------------------------------------------------------------

// Return errors: the following error codes can be returned from any of
// T-Hammer's exported APIs (EnumSelectionOffsets, EnumSummarizationOffsets,
// and EnumStemOffsets)
//

#define TH_ERROR_SUCCESS 0
#define TH_ERROR_NOHPBS 1
#define TH_ERROR_INVALID_INPUT 2
#define TH_ERROR_INVALID_CALLBACK 3
#define TH_ERROR_INIT_FAILED 4
#define TH_ERROR_NOT_IMPLEMENTED 5

// Offset delimiter: the following code is used to delimit the end of a list of
// token offsets returned to one of the Enum* callback routines.  This is not
// an error code.

#define TH_SELECTION_INVALID_OFFSET 0xFFFFFFFF

// TOKENIZE_MODE: Begin and End HPB Modes
//
// Begin and End HPB modes signify that a hard phrase break comes before the
// first character in the string and/or follows after the last character in the string
// If these flags are not set, then the default behavior of EnumTokens is to start
// enumerating tokens to the right of the leftmost HPB, which probably won't
// be at the first character (unless it is a punctuation symbol) and to conclude
// enumeration at the rightmost HPB, which likely will not be the true end of the
// string.  So, these flags in affect force HPBs at the 0th and nth offsets, where
// n is the number of characters in the input buffer
//
// WARNNIG: Since Tokenize operates in batch mode, it assumes that the
// start and end of the input buffer are HPBs. These flags are only used for
// EnumTokens
//
#define TOKENIZE_MODE_BEGIN_HPB             0x00000001
#define TOKENIZE_MODE_END_HPB             0x00000002

// Note on HPBs:  HPB = hard phrase break.
// HPBs are statistically determined from analyzing a tagged corpora.
// Roughly, they cor-respond to places where you csn break with 100%
// precision (=confidence). Mostly this is around punctuation characters
// and certain conspicuous [case markers | character type] bigrams.


// When the Hide Punctuation mode is set in the tokenize flag parameter
// T-Hammer strips punctuation out of the Stem Offsets and Summarization Offsets
// callback
//
#define TOKENIZE_MODE_HIDE_PUNCTUATION    0x00000004

//+--------------------------------------------------------------------------
//  Routine:    EnumSelectionOffsetsCallback
//
//  Synopsis: client-side callback that receives a list of offsets for selection chunks
//
//  Parameters:
//      pichOffsets - pointer to first element in an array of offsets into client
//          text buffer. NOTE: callback is not allowed to stash pichChunks for
//          later processing.  pichChunks will not persist between successive
//          callbacks.  If the callback wants to use the data pointed to by pich
//          it must copy it to its own store
//      cOffsets - number of offsets passed to client (always > 1)
//      lpData - client defined data
//
// Return:
//  TRUE - to abort token enumeration
//  FALSE - to continue
//---------------------------------------------------------------------------
// BOOL
// EnumSelectionOffsetsCallback (
//    IN CONST DWORD *pichOffsets,
//    IN DWORD cOffsets,
//    IN OUT LPARAM lpData);

typedef BOOL (CALLBACK * ENUM_SELECTION_OFFSETS_CALLBACK)(
    IN CONST DWORD *pichOffsets,
    IN CONST DWORD cOffsets,
    IN OUT LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumSelectionOffsets
//
//  Synopsis:  This is the main entry point for tokenizing text.  Sends tokens,
//  which can either be offsets or zero delimited strings to callback.
//
//  Parameters:
//  pwszText - pointer to wide-character text buffer to be tokenized,
//  cchText - count of characters in text buffer,
//  fBeginEndHPBMode - flag describing the callback mode  (see above),
//  pcbEnumSelectionOffsets - pointer to callback procedure handling token
//     enumeration,
//  lpData - client defined data
//
//  Returns:
//      TH_ERROR_SUCCESS - if the call completed successfully
//      TH_ERROR_NOHPBS - if there were no HPBs
//      TH_ERROR_INVALID_INPUT - if the input buffer was bad
//      TH_ERROR_INVALID_CALLBACK - if the input callback was bad
//---------------------------------------------------------------------------
INT
APIENTRY
EnumSelectionOffsets(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_SELECTION_OFFSETS_CALLBACK pcbEnumSelectionOffsets,
    IN LPARAM lpData);

typedef INT (APIENTRY *LP_ENUM_SELECTION_OFFSETS)(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_SELECTION_OFFSETS_CALLBACK pcbEnumSelectionOffsets,
    IN LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumSummarizationOffsetsCallback
//
//  Synopsis: client-side callback that receives a list of offsets for each stem
//      in the free morpheme (jiritsugo) phrase.   Last offset is always contains
//      the complete string of bound morphemes (fuzokugo).  For example,
//      for "kaisan shite nai sou desu", offsets are returned for "kaisan" and
//      "shite nai sou desu".  So, counting the first initial offset, there are three
//      offsets.
//
//  Parameters:
//      pichOffsets - pointer to first element in an array of offsets into client
//          text buffer. NOTE: callback is not allowed to stash pichOffsets for
//          later processing.  pichOffsets will not persist between successive
//          callbacks.  If the callback wants to use the data pointed to by pich
//          it must copy it to its own store
//      cOffsets - number of offsets passed to client (always > 1)
//      lpData - client defined data
//
// Return:
//  TRUE - to abort token enumeration
//  FALSE - to continue
//---------------------------------------------------------------------------
// BOOL
// EnumSummarizationOffsets (
//    IN CONST DWORD *pichOffsets,
//    IN DWORD cOffsets,
//    IN OUT LPARAM lpData);

typedef BOOL (CALLBACK * ENUM_SUMMARIZATION_OFFSETS_CALLBACK)(
    IN CONST DWORD *pichOffsets,
    IN CONST DWORD cOffsets,
    IN OUT LPARAM lpData);

typedef BOOL (CALLBACK * ENUM_SUMMARIZATION_OFFSETS_EX1_CALLBACK)(
    IN CONST DWORD *pichOffsets,
    IN CONST DWORD cOffsets,
    IN PCWSTR pwzPOS,
    IN PCWSTR pwzMCat,
    IN OUT LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumSummarizationOffsets
//
//  Synopsis:  This is the entry point for returning offsets for tokens used
//  in summarization.   These tokens correspond to stems and bound morphemes
//  (fuzokugo) in the text.  A list of offsets (and a count) is sent to the
//  EnumSummarizationOffsets callback (see above)
//
//  Parameters:
//  pwszText - pointer to wide-character text buffer to be tokenized,
//  cchText - count of characters in text buffer,
//  fTokenizeMode - flag describing the callback mode  (see above),
//     pEnumTokOutputProc - pointer to callback procedure handling token
//     enumeration,
//  lpData - client defined data
//
//  Returns:
//      TH_ERROR_SUCCESS - if the call completed successfully
//      TH_ERROR_NOHPBS - if there were no HPBs
//      TH_ERROR_INVALID_INPUT - if the input buffer was bad
//      TH_ERROR_INVALID_CALLBACK - if the input callback was bad
//---------------------------------------------------------------------------
INT
APIENTRY
EnumSummarizationOffsets(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_SUMMARIZATION_OFFSETS_CALLBACK pcbEnumSummarizationOffsets,
    IN LPARAM lpData);

INT
APIENTRY
EnumSummarizationOffsetsEx1(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_SUMMARIZATION_OFFSETS_EX1_CALLBACK pcbEnumSummarizationOffsetsEx1,
    IN LPARAM lpData);

typedef INT (APIENTRY *LP_ENUM_SUMMARIZATION_OFFSETS)(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_SUMMARIZATION_OFFSETS_CALLBACK pcbEnumSummarizationOffsets,
    IN LPARAM lpData);

typedef INT (APIENTRY *LP_ENUM_SUMMARIZATION_OFFSETS_EX1)(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_SUMMARIZATION_OFFSETS_EX1_CALLBACK pcbEnumSummarizationOffsetsEx1,
    IN LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumStemOffsetsCallback
//
//  Synopsis: client-side callback that receives a zero--terminated stem per SPB
//
//  Parameters:
//      pwszStem - zero terminated stem string
//      lpData - client defined data
//
// Return:
//  TRUE - to abort token enumeration
//  FALSE - to continue
//---------------------------------------------------------------------------
// BOOL
// EnumStemOffsetsCallback (
//    IN WCHAR *pwszStem,
//    IN OUT LPARAM lpData);

typedef BOOL (CALLBACK * ENUM_STEM_OFFSETS_CALLBACK)(
    IN CONST DWORD *pichOffsets,
    IN CONST DWORD cOffsets,
    IN OUT LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumStemOffsets
//
//  Synopsis:  This is the entry point for tokenizing stems.  Sends offsets,
//  for stems to the EnumStemOffsets callback (see above)
//
//  Parameters:
//  pwszText - pointer to wide-character text buffer to be tokenized,
//  cchText - count of characters in text buffer,
//  fTokenizeMode - flag describing the callback mode  (see above),
//     pEnumTokOutputProc - pointer to callback procedure handling token
//     enumeration,
//  lpData - client defined data
//
//  Returns:
//      TH_ERROR_SUCCESS - if the call completed successfully
//      TH_ERROR_NOHPBS - if there were no HPBs
//      TH_ERROR_INVALID_INPUT - if the input buffer was bad
//      TH_ERROR_INVALID_CALLBACK - if the input callback was bad
//---------------------------------------------------------------------------
INT
APIENTRY
EnumStemOffsets(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_STEM_OFFSETS_CALLBACK pcbEnumStemOffsets,
    IN OUT DWORD *pcchTextProcessed,
    IN LPARAM lpData);

typedef INT (APIENTRY *LP_ENUM_STEM_OFFSETS)(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_STEM_OFFSETS_CALLBACK pcbEnumStemOffsets,
    IN OUT DWORD *pcchTextProcessed,
    IN LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumStemInfoCallback
//
//  Synopsis: client-side callback that receives offsets and stem information
//
//  Parameters:
//      ichOffset - offset to first character in stem
//      cchLen - length of the stem
//      pwszPOS - string containing POS info
//      pwszMCat - string containing MCat info
//      pwszDictionaryForm - string containing Dictionary Form
//      lpData - client defined data
//
// Return:
//  TRUE - to abort token enumeration
//  FALSE - to continue
//---------------------------------------------------------------------------
// BOOL
// EnumStemInfoCallback (
//    IN CONST DWORD ichOffset,
//    IN CONST DWORD cchLen,
//    IN PCWSTR pwszPOS,
//    IN PCWSTR pwszMCat,
//    IN PCWSTR pwszDictionaryForm,
//    IN OUT LPARAM lpData);

typedef BOOL (CALLBACK * ENUM_STEM_INFO_CALLBACK)(
    IN CONST DWORD ichOffset,
    IN CONST DWORD cchLen,
    IN PCWSTR pwszPOS,
    IN PCWSTR pwszMCat,
    IN PCWSTR pwszDictionaryForm,
    IN OUT LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumStemInfo
//
//  Synopsis:  Call this routine to get information about stems.
//  For example, if you want the dictionary form, part-of-speech or
//  MCat information for a stem, then this is the API for you
//
//  Parameters:
//  pwszText - pointer to wide-character text buffer to be tokenized,
//  cchText - count of characters in text buffer,
//  fTokenizeMode - flag describing the callback mode  (see above),
//  pcbEnumStemInfo - pointer to callback procedure handling stem info
//      enumeration
//  lpData - client defined data
//
//  Returns:
//      TH_ERROR_SUCCESS - if the call completed successfully
//      TH_ERROR_NOHPBS - if there were no HPBs
//      TH_ERROR_INVALID_INPUT - if the input buffer was bad
//      TH_ERROR_INVALID_CALLBACK - if the input callback was bad
//---------------------------------------------------------------------------
INT
APIENTRY
EnumStemInfo(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_STEM_INFO_CALLBACK pcbEnumStemInfo,
    IN OUT DWORD *pcchTextProcessed,
    IN LPARAM lpData);

typedef INT (APIENTRY *LP_ENUM_STEM_INFO)(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_STEM_INFO_CALLBACK pcbEnumStemInfo,
    IN OUT DWORD *pcchTextProcessed,
    IN LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumSentenceOffsetsCallback
//
//  Synopsis: client-side callback that receives a list of offsets for sentence breaks
//
//  Parameters:
//      ichOffsetStart - offset to start of sentence
//      ichOffsetEnd - offset to end of sentence (includes terminating punctuation)
//      lpData - client defined data
//
// Return:
//  TRUE - to abort token enumeration
//  FALSE - to continue
//---------------------------------------------------------------------------
// BOOL
// EnumSentenceOffsetsCallback (
//    IN DWORD ichOffsetStart,
//    IN DWORD ichOffsetEnd,
//    IN OUT LPARAM lpData);

typedef BOOL (CALLBACK * ENUM_SENTENCE_OFFSETS_CALLBACK)(
    IN DWORD ichOffsetStart,
    IN DWORD ichOffsetEnd,
    IN OUT LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumSentenceOffsets
//
//  Synopsis:  This is the main entry point for breaking sentences.
//      Sends offsets delimiting sentences to the callback.
//
//  Parameters:
//  pwszText - pointer to wide-character text buffer to be tokenized,
//  cchText - count of characters in text buffer,
//  fTokenizeMode - not used.  later this will be used to control how
//      partial sentences are handled.
//  pEnumSentenceOffsetsCallback - pointer to callback procedure handling offsets
//  lpData - client defined data
//
//  Returns:
//      TH_ERROR_SUCCESS - if the call completed successfully
//      TH_ERROR_NOHPBS - if there were no HPBs
//      TH_ERROR_INVALID_INPUT - if the input buffer was bad
//      TH_ERROR_INVALID_CALLBACK - if the input callback was bad
//---------------------------------------------------------------------------
INT
APIENTRY
EnumSentenceOffsets(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fTokenizeMode,
    IN ENUM_SENTENCE_OFFSETS_CALLBACK pcbEnumSentenceOffsets,
    IN LPARAM lpData);

typedef INT (APIENTRY *LP_ENUM_SENTENCE_OFFSETS)(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fTokenizeMode,
    IN ENUM_SENTENCE_OFFSETS_CALLBACK pcbEnumSentenceOffsets,
    IN LPARAM lpData);


//+--------------------------------------------------------------------------
//  Routine:    FEMorphCallback
//
//  Synopsis:  The callback that gets a text stream from T-Hammer.
//
//  Parameters:
//      pwszWMorphRecs - a pointer to wide character text stream,
//                   which contains mophological analyses of a given sentence
//      pvData - pointer to private data
//
//  Returns:
//      TRUE if no more analysis is needed
//---------------------------------------------------------------------------
// BOOL
// FEMorphCallback(
//    IN PWSTR pwszMorphRecs);

typedef BOOL (CALLBACK * FEMORPH_CALLBACK)(
    IN PWSTR pwszMorphRecs,
    IN VOID *pvData);

//+--------------------------------------------------------------------------
//  Routine:    FEMorph
//
//  Synopsis:  This is the entry point for NLPWIN morpheme analysis.
//  Sends a morpheme record string back to the lex callback in NLPWIN
//
//  Parameters:
//  pwszText - pointer to wide-character text buffer to be tokenized,
//  pcbFEMorphCB - pointer to callback procedure handling morph rec enumeration
//  pvData - pointer to private data
//
//  Returns:
//---------------------------------------------------------------------------
INT
APIENTRY
FEMorph(
    IN PCWSTR pwszText,
    IN FEMORPH_CALLBACK pcbFEMorphCB,
    IN VOID *pvData);

typedef INT (APIENTRY *LP_FEMORPH)(
    IN PCWSTR pwszText,
    IN FEMORPH_CALLBACK pcbFEMorphCB,
    IN VOID *pvData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\charfreq.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component:  CharFreq
Purpose:    To manage the CharFreq resource(CharFreq is one of the linguistic resources)
            The CharFreq is stored as the struct CCharFreq followed the frequecy table  
Notes:      
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    4/23/97
============================================================================*/
#include "myafx.h"

#include "charfreq.h"

// CJK unified idographs block in Unicode
#define  CJK_UFIRST 0x4e00  
#define  CJK_ULAST  0x9fff

// Constructor
CCharFreq::CCharFreq()
{
    m_idxFirst = 0;
    m_idxLast = 0;
    m_rgFreq = NULL;
}

// Destructor
CCharFreq::~CCharFreq()
{
}

// Init the Freq table from a file pointer to the table memory
BOOL CCharFreq::fOpen(BYTE* pbFreqMap)
{
    assert(pbFreqMap);
    assert(!m_rgFreq);

    CCharFreq* pFreq;

    pFreq = (CCharFreq*)pbFreqMap;
    if (pFreq->m_idxFirst >= pFreq->m_idxLast) {
        return FALSE;
    }

    m_idxFirst = pFreq->m_idxFirst;
    m_idxLast  = pFreq->m_idxLast;
    m_rgFreq   = (UCHAR*)(pbFreqMap + sizeof(m_idxFirst) + sizeof(m_idxLast)); 
    
    return TRUE;
}

// Close: clear the freq table setting
void CCharFreq::Close(void)
{
    m_idxFirst = 0;
    m_idxLast = 0;
    m_rgFreq = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\charfreq.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component:  CharFreq
Purpose:    To manage the CharFreq resource(CharFreq is one of the linguistic resources)
            The CharFreq is stored as the struct CCharFreq followed the frequecy table  
Notes:      
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    4/23/97
============================================================================*/
#ifndef _CHARFREQ_H_
#define _CHARFREQ_H_


#pragma pack(1)
class CCharFreq
{
    public:
        USHORT  m_idxFirst;
        USHORT  m_idxLast;
        UCHAR*  m_rgFreq;

    public:
        // Constructor
        CCharFreq();
        // Destructor
        ~CCharFreq();

        // Init the Freq table from a file pointer to the table memory
        BOOL fOpen(BYTE* pbFreqMap);
        // Close: clear the freq table setting
        void Close(void);

        // Return the frequency of the given idx
        UCHAR CCharFreq::uchGetFreq(WCHAR wch)
        {   
            assert(m_rgFreq);

            if (wch >= m_idxFirst && wch <= m_idxLast) {
                return (UCHAR)(m_rgFreq[wch-m_idxFirst]);
            } else {
                return (UCHAR)0;
            }
        }
};
#pragma pack()


#endif  // _CHARFREQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\cfactory.h ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CFactory
Purpose:    Define CFactory class
Remarks:
Owner:      i-shdong@microsoft.com
Platform:   Win32
Revise:     First created by: i-shdong    11/17/1999
============================================================================*/

#ifndef __CFactory_h__
#define __CFactory_h__

// Forward reference
class CFactoryData ;

// Global data used by CFactory
extern CFactoryData g_FactoryDataArray[] ;
extern int g_cFactoryDataEntries ;

//  Component creation function
class CUnknown ;

typedef HRESULT (*FPCREATEINSTANCE)(IUnknown*, CUnknown**) ;

// CFactoryData
//   - Information CFactory needs to create a component
//     supported by the DLL
class CFactoryData
{
public:
        // The class ID for the component
        const CLSID* m_pCLSID ;

        // Pointer to the function that creates it
        FPCREATEINSTANCE CreateInstance ;

        // Name of the component to register in the registry
        //const char* m_RegistryName ;
        LPCTSTR m_RegistryName ;

        // ProgID
        //const char* m_szProgID ;
        LPCTSTR m_szProgID ;

        // Version-independent ProgID
        //const char* m_szVerIndProgID ;
        LPCTSTR m_szVerIndProgID ;

        // Helper function for finding the class ID
        BOOL IsClassID(const CLSID& clsid) const
                { return (*m_pCLSID == clsid) ;}

} ;


// Class Factory
class CFactory : public IClassFactory
{
public:
        // IUnknown
        virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv) ;
        virtual ULONG   __stdcall AddRef() ;
        virtual ULONG   __stdcall Release() ;

        // IClassFactory
        virtual HRESULT __stdcall CreateInstance(IUnknown* pUnknownOuter,
                                                 const IID& iid,
                                                 void** ppv) ;
        virtual HRESULT __stdcall LockServer(BOOL bLock) ;

        // Constructor - Pass pointer to data of component to create.
        CFactory(const CFactoryData* pFactoryData) ;

        // Destructor
        ~CFactory() { } ;

        //
        // Static FactoryData support functions
        //

        // DllGetClassObject support
        static HRESULT GetClassObject(const CLSID& clsid,
                                      const IID& iid,
                                      void** ppv) ;

        // Helper function for DllCanUnloadNow
        static BOOL IsLocked()
                { return (s_cServerLocks > 0) ;}

        // Functions to [un]register all components
        static HRESULT RegisterAll() ;
        static HRESULT UnregisterAll() ;

        // Function to determine if component can be unloaded
        static HRESULT CanUnloadNow() ;

public:
        // Reference Count
        LONG m_cRef ;

        // Pointer to information about class this factory creates
        const CFactoryData* m_pFactoryData ;

        // Count of locks
        static LONG s_cServerLocks ;

        // Module handle
        static HINSTANCE s_hModule ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\cunknown.cpp ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CUnknown
Purpose:   Implementation of IUnknown Base class CUnknown
Remarks:
Owner:     i-shdong@microsoft.com
Platform:  Win32
Revise:    First created by: i-shdong    11/17/1999
============================================================================*/
#include "MyAfx.h"

#include "CUnknown.h"

/*============================================================================
Count of active objects
   - Use to determine if we can unload the DLL.
============================================================================*/
long CUnknown::s_cActiveComponents = 0 ;

// Constructor
CUnknown::CUnknown(IUnknown* pUnknownOuter)
: m_cRef(1)
{
	// Set m_pUnknownOuter pointer.
	if (pUnknownOuter == NULL)
	{
		m_pUnknownOuter = reinterpret_cast<IUnknown*>
		                     (static_cast<INondelegatingUnknown*>
		                     (this)) ;  // notice cast
	}
	else
	{
		m_pUnknownOuter = pUnknownOuter ;
	}
	// Increment count of active components.
	::InterlockedIncrement(&s_cActiveComponents) ;
}

// Destructor
CUnknown::~CUnknown()
{
	::InterlockedDecrement(&s_cActiveComponents) ;
}

// FinalRelease - called by Release before it deletes the component
void CUnknown::FinalRelease()
{
	m_cRef = 1 ;
}

// IUnknown
//   - Override to handle custom interfaces.
HRESULT __stdcall 
	CUnknown::NondelegatingQueryInterface(const IID& iid, void** ppv)
{
	// CUnknown supports only IUnknown.
	if (iid == IID_IUnknown)
	{
		return FinishQI(reinterpret_cast<IUnknown*>
		                   (static_cast<INondelegatingUnknown*>(this)),
		                ppv) ;
	}	
	else
	{
		*ppv = NULL ;
		return E_NOINTERFACE ;
	}
}

// AddRef
ULONG __stdcall CUnknown::NondelegatingAddRef()
{
	return InterlockedIncrement(&m_cRef) ;
}


// Release
ULONG __stdcall CUnknown::NondelegatingRelease()
{
	InterlockedDecrement(&m_cRef) ;
	if (m_cRef == 0)
	{
		FinalRelease() ;
		delete this ;
		return 0 ;
	}
	return m_cRef ;
}


// FinishQI
//   - Helper function to simplify overriding
//     QueryInterface
HRESULT CUnknown::FinishQI(IUnknown* pI, void** ppv) 
{
	*ppv = pI ;
	pI->AddRef() ;
	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\cunknown.h ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CUnknown
Purpose:   Define CUnknown class
Remarks:
Owner:     i-shdong@microsoft.com
Platform:  Win32
Revise:    First created by: i-shdong    11/17/1999
============================================================================*/

#ifndef __CUnknown_h__
#define __CUnknown_h__

// Nondelegating IUnknown interface
//   - Nondelegating version of IUnknown
interface INondelegatingUnknown
{
	virtual HRESULT __stdcall 
		NondelegatingQueryInterface(const IID& iid, void** ppv) = 0 ;
	virtual ULONG   __stdcall NondelegatingAddRef() = 0 ;
	virtual ULONG   __stdcall NondelegatingRelease() = 0 ;
} ;

/*============================================================================
Declaration of CUnknown 
  - Base class for implementing IUnknown
============================================================================*/
class CUnknown : public INondelegatingUnknown
{
public:
	// IUnknown implementation
	// Nondelegating IUnknown implementation
	virtual HRESULT __stdcall NondelegatingQueryInterface(const IID&,
	                                                      void**) ;
	virtual ULONG   __stdcall NondelegatingAddRef() ;
	virtual ULONG   __stdcall NondelegatingRelease() ;

	// Constructor
	CUnknown(IUnknown* pUnknownOuter) ;

	// Destructor
	virtual ~CUnknown() ;

	// Initialization
	virtual HRESULT Init() { return S_OK ;}

	// Notification to derived classes that we are releasing
	virtual void FinalRelease() ;

	// Count of currently active components
	static long ActiveComponents() 
		{ return s_cActiveComponents ;}
	
	// Helper function
	HRESULT FinishQI(IUnknown* pI, void** ppv) ;

protected:
	// Support for delegation
	IUnknown* GetOuterUnknown() const
		{ return m_pUnknownOuter ;}

private:
	// Reference count for this object
	long m_cRef ;
	
	// Pointer to (external) outer IUnknown
	IUnknown* m_pUnknownOuter ;

	// Count of all active instances
	static long s_cActiveComponents ; 
} ;

// Delegating IUnknown
//   - Delegates to the nondelegating IUnknown, or to the
//     outer IUnknown if the component is aggregated.
//
#define DECLARE_IUNKNOWN		                             \
	virtual HRESULT __stdcall	                             \
		QueryInterface(const IID& iid, void** ppv)           \
	{	                                                     \
		return GetOuterUnknown()->QueryInterface(iid,ppv) ;  \
	} ;	                                                     \
	virtual ULONG __stdcall AddRef()	                     \
	{	                                                     \
		return GetOuterUnknown()->AddRef() ;                 \
	} ;	                                                     \
	virtual ULONG __stdcall Release()	                     \
	{	                                                     \
		return GetOuterUnknown()->Release() ;                \
	} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\chsbrkr.cpp ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: DLL Main and exported functions
Purpose:   DLL Main and exported functions
Remarks:
Owner:     i-shdong@microsoft.com
Platform:  Win32
Revise:    First created by: i-shdong    11/17/1999
============================================================================*/
#include "MyAfx.h"

#include "Registry.h"
#include "CFactory.h"

HINSTANCE   v_hInst = NULL;

// DLL module information
BOOL APIENTRY DllMain(HINSTANCE hModule, 
                      DWORD dwReason, 
                      void* lpReserved )
{
    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
        CFactory::s_hModule = hModule ;
        v_hInst = hModule;
        DisableThreadLibraryCalls(hModule);
        break;

    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE ;
}

// Exported functions

STDAPI DllCanUnloadNow()
{
    return CFactory::CanUnloadNow() ; 
}

// Get class factory
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv) 
{
    return CFactory::GetClassObject(clsid, iid, ppv) ;
}

// Server registration
STDAPI DllRegisterServer()
{
    HRESULT hr;
    hr = CFactory::RegisterAll() ;
    if (hr != S_OK) {
        return hr;
    }
    return hr;
}


STDAPI DllUnregisterServer()
{
    HRESULT hr;
    hr = CFactory::UnregisterAll() ;
    if (hr != S_OK) {
        return hr;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\errordef.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: Error ID

Purpose:   Define critique error ID for proof engine
Notes:     This header is included by ProofEng.h and WordLink.h
Owner:     donghz@microsoft.com
Platform:  Win32
Revise:    First created by: donghz	2/24/98
============================================================================*/
#ifndef _ERRORDEF_H_
#define _ERRORDEF_H_

#define ERRDef_NIL			0	// No error
#define ERRDef_CEW			1	// Common error word
#define ERRDef_FEI			2	// Single char which can not used as word
#define ERRDef_TAI			3	// Disused measure unit
#define ERRDef_LMCHECK		4	// Can not pass the SLM checking
#define ERRDef_DUPPUNCT		5	// Dup usage of punctuation
#define ERRDef_PUNCTMATCH	6	// Unmatched punctuation pair
#define ERRDef_WORDUSAGE	7	// Error usage of specific word
#define ERRDef_DUPWORD		8	// Unexpected duplicated of words
#define ERRDef_NUMERIAL		9	// Error numerial words
#define ERRDef_NOSTDNUM		10	// Non-standard numerial words usage
#define ERRDef_UNSMOOTH		11	// Not a perfectly smooth usage of a specific word
#define ERRDef_QUOTATION	12	// Quotation word which could not pass SLM Check
#define ERRDef_AMOUNT		13	// Amount category error
#define ERRDef_TIME			14	// Time category error


#endif	// _ERRORDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\fixtable.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component:  FixTable
Purpose:    Declare the CFixTable class. It contain fixed length string in fixed 
            element number.
            Proof98 engine use this class to contain proper names: Person, Place,
            and Foreign Names
            The element number can not be changed once initialized, the elements
            will be used cycled
            I implement this class just using linear approach at first, and would
            implement it in more efficient data structure some day, if necessary.
Notes:      This is an independent fundamental class as some basic ADT
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    6/1/97
============================================================================*/
#include "myafx.h"

#include "FixTable.h"

//  Constructor
CFixTable::CFixTable()
{
    m_ciElement  = 0;
    m_cwchElement = 0;
    m_iNext      = 0;
    m_pwchBuf     = NULL;
}


//  Destructor
CFixTable::~CFixTable()
{
    FreeTable();
}


/*
*   Initialize the table using iElementCount and cchElementSize
*   The cchElementSize contain the terminating '\0'
*   Return FALSE if memory allocating error or other error occur
*/
BOOL CFixTable::fInit(USHORT ciElement, USHORT cwchElement)
{
    assert(ciElement > 1 && cwchElement > 3);

    FreeTable();
    if ((m_pwchBuf = new WCHAR[ciElement * cwchElement]) == NULL) {
        return FALSE;
    }
    memset((LPVOID)m_pwchBuf, 0, ciElement * cwchElement * sizeof(WCHAR));
    m_ciElement = ciElement;
    m_cwchElement = cwchElement;
    return TRUE;
}

/*
*   Free the element memory of the table
*/
void CFixTable::FreeTable(void)
{
    if (m_pwchBuf != NULL) {
        delete [] m_pwchBuf;
        m_pwchBuf = NULL;
    }
}

/*
*   Add an element into the table, and the terminating '\0' will be appended
*   Return count of bytes added, the string will be truncated at m_cchElement-1
*/
USHORT CFixTable::cwchAdd(LPCWSTR pwchText, USHORT cwchLen)
{
    LPWSTR pSrc;
    LPWSTR pDst;

    assert(pwchText && cwchLen );
    if (cwchLen > m_cwchElement - 1) {
        return 0;
    }
    if (fFind(pwchText, cwchLen)) {
        return 0; // duplicated element
    }
    for (pSrc = const_cast<LPWSTR>(pwchText),
         pDst = (m_pwchBuf + m_iNext * m_cwchElement);
         cwchLen && *pSrc; cwchLen--) {

        *pDst++ = *pSrc++;
    }
    *pDst = '\0';

    m_iNext++;
    if (m_iNext == m_ciElement) {
        m_iNext = 0;
    }
    
    return (USHORT)(pSrc - pwchText);
}

/*
*   Get the max matched item in the table. Must full matched for table item
*   Return length of the max matched item
*/
USHORT CFixTable::cwchMaxMatch(LPCWSTR pwchText, USHORT cwchLen)
{
    LPWSTR pwchItem;
    USHORT iwch;
    USHORT idx;
    USHORT cwchMax = 0;

    assert(pwchText && cwchLen);
    for (idx = 0; idx < m_ciElement; idx++) {
        pwchItem = m_pwchBuf + idx * m_cwchElement;
        if (pwchItem[0] == L'\0') {
            break; // empty element encountered
        }
        for (iwch = 0; pwchItem[iwch] && (iwch < cwchLen); iwch += 1 ) {
            if (pwchText[iwch] != pwchItem[iwch]) {
                        break;
            }
        }
        if (!pwchItem[iwch] && iwch > cwchMax) {
                cwchMax = iwch;
        }
    }
    return cwchMax;
}

/*
*   Search the first cchLen bytes of pchText in the table
*   If matched element found in the table return TRUE, or return FALSE
*/
BOOL CFixTable::fFind(LPCWSTR pwchText, USHORT cwchLen)
{
    LPWSTR pwch1;
    LPWSTR pwch2;
    USHORT idx;
    USHORT cwch;

    assert(pwchText);
    
    if (cwchLen > m_cwchElement - 1) {
        return FALSE;
    }
    for (idx = 0; idx < m_ciElement; idx++)  {
        pwch2 = m_pwchBuf + idx * m_cwchElement;
        if (*pwch2 == L'\0') {
            break; // empty element encountered
        }
        cwch = cwchLen;
        for (pwch1 = const_cast<LPWSTR>(pwchText); cwch && *pwch2; cwch--) {
            if (*pwch1++ != *pwch2++) {
                break;
            }
        }
        if (cwch == 0) {
            return TRUE;
        }
    }
    return FALSE;
}

/*
*   Clear all elements in the table into empty string
*/
void CFixTable::ClearAll(void)
{
    for (m_iNext = m_ciElement; m_iNext; m_iNext--) {
        m_pwchBuf[(m_iNext - 1) * m_cwchElement] = L'\0';
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\fixtable.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component:  FixTable
Purpose:    Declare the CFixTable class. It contain fixed length string in fixed 
            element number.
            Proof98 engine use this class to contain proper names: Person, Place,
            and Foreign Names
            The element number can not be changed once initialized, the elements
            will be used cycled
            I implement this class just using linear approach at first, and would
            implement it in more efficient data structure some day, if necessary.
Notes:      This is an independent fundamental class as some basic ADT
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    6/1/97
============================================================================*/
#ifndef _FIXTABLE_H_
#define _FIXTABLE_H_

class CFixTable
{
    public:
        CFixTable();
        ~CFixTable();

        /*
        *   Initialize the table using iElementCount and cchElementSize
        *   The cchElementSize contain the terminating '\0'
        *   Return FALSE if memory allocating error or other error occur
        */
        BOOL fInit(USHORT ciElement, USHORT cwchElement);

        /*
        *   Free the element memory of the table
        */
        void FreeTable(void);

        /*
        *   Add an element into the table, and the terminating '\0' will be appended
        *   Return count of bytes added, the string will be truncated at m_cchElement-1
        */
        USHORT cwchAdd(LPCWSTR pwchText, USHORT cwchLen);

        /*
        *   Get the max matched item in the table. Must full matched for table item
        *   Return length of the max matched item
        */
        USHORT cwchMaxMatch(LPCWSTR pwchText, USHORT cwchLen);

        /*
        *   Clear all elements in the table into empty string
        */
        void ClearAll(void);

    private:
        USHORT  m_ciElement;
        USHORT  m_cwchElement;
        USHORT  m_iNext;

        LPWSTR  m_pwchBuf;

    private:
        /*
        *   Search the first cwchLen chars of pwchText in the table
        *   If matched element found in the table return TRUE, or return FALSE
        */
        BOOL fFind(LPCWSTR pwchText, USHORT cwchLen);
};

#endif  // _FIXTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\jargon.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CJargon
Purpose:    Declare the CJargon class for new words identification. There are a lot of
            tasks to do in Jargon moudle:
            1. Name of palce (Jargon1.cpp)
            2. Name of foreign person and places (Jargon1.cpp)
            3. Name of orgnizations (Jargon1.cpp)
            4. Name of HanZu person (Jargon1.cpp)
Notes:      The CJargon class will be implemented in several cpp files:
            Jargon.cpp, Jargon1.cpp, Jargon2.cpp
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#ifndef _JARGON_H_
#define _JARGON_H_

// Forward declaration of classes
class CLexicon;
class CWordLink;
class CFixTable;
struct CWord;


//  Define the CJargon class
class CJargon
{
    public:
        CJargon();
        ~CJargon();

        // Initialize the Jargon class
        int ecInit(CLexicon* pLexicon);

        // Process control function of Jargon class
        int ecDoJargon(CWordLink* pLink);

    private:
        CWordLink*  m_pLink;
        CLexicon*   m_pLex;

        CFixTable*  m_ptblName;
        CFixTable*  m_ptblPlace;
        CFixTable*  m_ptblForeign;

        int         m_iecError;     // Runtime error code
        CWord*      m_pWord;        // Current word pointer shared inside one pass of analysis
        CWord*      m_pTail;        // Right or left end of the likely proper name,
                                    // according to the specific sort of names.

    private:
        // Terminate the Jargon class
        void TermJargon(void);

        /*============================================================================
        Proper names identification stuffs
        ============================================================================*/
        //  Proper names identification scan pass controlling function
        //  Return TRUE if successful.
        //  Return FALSE if runtime error and set error code in m_iecError
        BOOL fIdentifyProperNames();

        //  Handle name of HanZu places
        //  Return TRUE if merged, or FALSE if un-merged. No error return.
        BOOL fHanPlaceHandler();
        
        //  Handle organization name identification
        //  Return TRUE if merged, or FALSE if un-merged. No error return.
        BOOL fOrgNameHandler(void);
        
        //  Foreign proper name identification
        //  Return TRUE if merged, or FALSE if un-merged. No error return.
        BOOL fForeignNameHandler(CWord* pTail);
        //  Get foreign string
        //  return TRUE if the is an multi-section foreign name found and merged
        //  return FALSE if only one section found, and the word follows the last word node 
        //  in the likely foreign name will be returned in ppTail
        //  Note: m_pWord is not moved!!!
        BOOL fGetForeignString(CWord** ppTail);

        //  HanZu person name identification
        //  Return TRUE if merged, or FALSE if un-merged. No error return.
        BOOL fHanPersonHandler(void);
        //  Merge  + 
        //  Return TRUE if merged, or FALSE if un-merged. No error return.
        BOOL fChengWeiHandler(void);

        
        //-----------------------
        //  Service functions:
        //-----------------------
        //  Add pWord to specific table
        void AddWordToTable(CWord* pWord, CFixTable* pTable);
        //  Check proper name table, and merge match words
        BOOL fInTable(CWord* pWord, CFixTable* pTable);

};

#endif // _JARGON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\jargon1.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CJargon
Purpose:    Implement process control and public functions in CJargon class
            There are a lot of tasks to do in Jargon moudle:
            1. Name of palce (Jargon1.cpp)
            2. Name of foreign person and places (Jargon1.cpp)
            3. Name of orgnizations (Jargon1.cpp)
            4. Name of HanZu person (Jargon1.cpp)               
Notes:      The CJargon class will be implemented in several cpp files:
            Jargon.cpp, Jargon1.cpp, Jargon2.cpp
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#include "myafx.h"

#include "jargon.h"
#include "lexicon.h"
#include "wordlink.h"
#include "fixtable.h"
#include "proofec.h"
#include "lexprop.h"
#include "scchardef.h"

#define PN_UNMERGE  0
#define PN_MERGED   1
#define PN_ERROR    2


/*============================================================================
CJargon::fIdentifyProperNames():
    Control function for proper names identification
Returns:
    TRUE if successful.
    FALSE if runtime error and set error code in m_iecError
============================================================================*/
BOOL CJargon::fIdentifyProperNames()
{
    assert(m_iecError == 0); // the error code public field should be cleared
    assert(m_pLink != NULL);
    assert(*(m_pLink->pwchGetText()) != 0);

    m_pWord = m_pLink->pGetHead();
    assert(m_pWord && m_pWord->pwchGetText() == m_pLink->pwchGetText());

    if (m_pWord->fIsTail()) {
        return TRUE; // Single word sentence
    }

    // Scan pass for name of place and organization
    for (; m_pWord; m_pWord = m_pWord->pNextWord()) {
       if (fHanPlaceHandler()) {
            continue;
        }
        fOrgNameHandler();
    }

    // Scan pass for foreign name
    m_pWord = m_pLink->pGetHead();
    for(; m_pWord && !m_pWord->fIsTail(); m_pWord = m_pWord->pNextWord()) {
        CWord* pTail;
        // Merge  + 
        if (fChengWeiHandler()) {
            continue;
        }

        // Handle foreign name
        if (m_pWord->fGetAttri(LADef_pnWai) && 
            !m_pWord->fGetAttri(LADef_pnNoFHead)) {
            if (fGetForeignString(&pTail)) {
                //_DUMPLINK(m_pLink, m_pWord);
                continue;
            } else if (pTail && m_pWord->pNextWord() != pTail &&
                       fForeignNameHandler(pTail)) {
                //_DUMPLINK(m_pLink, m_pWord);
                continue;
            } else {
            }
        }

        // Handle HanZu person name
        fHanPersonHandler();
    }
    return TRUE;
}


/*============================================================================
CJargon::fHanPlaceHandler():
    PLACE: Handle name of HanZu places
Returns:
    TRUE if success
    FALSE if runtime error, error code in m_iecError
============================================================================*/
inline BOOL CJargon::fHanPlaceHandler()
{
    CWord*  pTailWord;
    int     nMerge;

    assert(m_iecError == PRFEC::gecNone);
    if (m_pWord->fIsTail() || 
        !m_pWord->fGetAttri(LADef_pnYi) &&
        !m_pWord->fGetAttri(LADef_nounPlace)) {
        return FALSE; // fired by  or 
    }
        
    if (m_pWord->fGetAttri(LADef_nounPlace)) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pnDi)) {
            // *{} + <> => Merge(1,2);
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_nounPlace);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return TRUE;
        } else {
            return FALSE;
        }
    }
    
    if (fInTable(m_pWord, m_ptblPlace)) {
        // *# => Merge
        if (!m_pWord->fIsTail() && 
            ( m_pWord->pNextWord()->fGetAttri(LADef_pnDi) ||
              m_pWord->pNextWord()->fGetAttri(LADef_nounPlace) ) ) {
            // *# + [<>, {}] => Merge(1,2); 
            m_pLink->MergeWithNext(m_pWord, FALSE);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
        }
        m_pWord->SetAttri(LADef_nounPlace);
        m_pWord->SetAttri(LADef_posN);
        //_DUMPLINK(m_pLink, m_pWord);
        return TRUE;
    }

    assert(m_pWord->fGetAttri(LADef_pnYi) && !m_pWord->fIsTail());
    if (m_pWord->fIsHead()) {
        return FALSE;
    }

    // Find tail of a likely place name
    pTailWord = m_pWord->pNextWord();
    nMerge = 0;
    while (pTailWord &&
           pTailWord->fGetAttri(LADef_pnYi) &&
           !pTailWord->fGetAttri(LADef_pnDi)) {
        pTailWord = pTailWord->pNextWord();
        nMerge ++;
    }
    
    if (pTailWord == NULL) {
        return FALSE;
    }

    if (pTailWord->fGetAttri(LADef_pnDi)) {
        // The *# ended with 
        assert(m_pWord->pPrevWord());
        if (m_pWord->pPrevWord()->fGetAttri(LADef_nounPlace) ||
            m_pWord->pPrevWord()->fGetAttri(LADef_pnLianMing) &&
            !m_pWord->pPrevWord()->fIsHead() && 
            m_pWord->pPrevWord()->pPrevWord()->fGetAttri(LADef_nounPlace)) {
            // {} + *# + <> => Merge(2,3);
            // {} + [""] + *# + <> => Merge(3,4);
            // first merge all the *#, free the words been merged
            m_pWord = m_pLink->pRightMerge(m_pWord, nMerge, FALSE);
            // merge with the <>
            m_pLink->MergeWithNext(m_pWord, FALSE);

            // Add the *# into the table of place name
            assert(m_pWord->cwchLen() > 1);
            AddWordToTable(m_pWord, m_ptblPlace);

            if (!m_pWord->fIsTail() &&
                m_pWord->pNextWord()->fGetAttri(LADef_pnDi)) {
                // {} + [""] + *# + <> + <> => Merge(3,4,5); SetWordInfo(*, CIDDef::idEnumPlace, <>, {});
                // {} + *# + <> + <> => Merge(2,3,4); SetWordInfo(*, CIDDef::idEnumPlace, <>, {});
                m_pLink->MergeWithNext(m_pWord, FALSE);  // Merge the second <>
                //_DUMPLINK(m_pLink, m_pWord);
            } else {
                //_DUMPLINK(m_pLink, m_pWord);
            }
            m_pWord->SetAttri(LADef_posN);
            m_pWord->SetAttri(LADef_nounPlace);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            return TRUE;
        }
    }

    // The *# is not ended with <>
    if (nMerge &&
        !m_pWord->pPrevWord()->fIsHead() && !pTailWord->fIsTail() && 
        m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_DUNHAO) &&   // ""
        m_pWord->pPrevWord()->pPrevWord()->fGetAttri(LADef_nounPlace) && 
        ( pTailWord->pNextWord()->fIsWordChar(SC_CHAR_DUNHAO) ||
          pTailWord->pNextWord()->fIsWordChar(SC_CHAR_DENG) ) ) {
        // {} + "" + *# + [""] => Merge(3); 
        // merge all the *#, free the words been merged
        m_pWord = m_pLink->pRightMerge(m_pWord, nMerge, FALSE);
        // Add the *# into the table of place name
        assert(m_pWord->cwchLen() > 1);
        AddWordToTable(m_pWord, m_ptblPlace);
        m_pWord->SetAttri(LADef_posN);
        m_pWord->SetAttri(LADef_nounPlace);
#ifdef LADef_iwbAltPhr
        m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
        //_DUMPLINK(m_pLink, m_pWord);
        return TRUE;
    }

    return FALSE;
}


/*============================================================================
CJargon::fOrgNameHandler():
    handle Orgnization name identification
Returns:
    TRUE if success
    FALSE if runtime error, error code in m_iecError
============================================================================*/
#define MAX_UNKNOWN_TM  8
BOOL CJargon::fOrgNameHandler(void)
{
    BOOL    fOK = FALSE;    // Is any valid Org name found
    CWord*  pHead;          // Head of the Org name
    CWord*  pTry;           // Try to combind more words after a valid one found
    int     cwchTM;         // length of unknown trademark

    assert(m_iecError == PRFEC::gecNone && m_pWord);
    // Fired by <> or <>
    if (!m_pWord->fGetAttri(LADef_pnDian) &&
        !m_pWord->fGetAttri(LADef_nounOrg)) {
        return FALSE;
    }

    // Skip one or more <> words before current word
    pHead = m_pWord->pPrevWord(); 
    while (pHead && (pHead->fGetAttri(LADef_pnShang) || // []
           pHead->fGetAttri(LADef_numOrdinal) ||
           pHead->fGetAttri(LADef_numInteger)) ) {
        pHead = pHead->pPrevWord();
    }
    if (pHead == NULL) {
        goto gotoExit;
    }

    // continue to go backward
    if (pHead->fGetAttri(LADef_nounOrg) || pHead->fGetAttri(LADef_nounPlace)) {
        // [{},{}] + <>...<> + [<>, {}] => {}
        fOK = TRUE; // can be a valid Org name
        //_DUMPLINK(m_pLink, m_pWord);
    } else if (pHead->fGetAttri(LADef_nounTM)) {
        // {} + <>...<> + [<>, {}] => {}
        fOK = TRUE;
        //_DUMPLINK(m_pLink, m_pWord);
        pTry = pHead->pPrevWord();
        if (pTry && pTry->fGetAttri(LADef_nounPlace)) {
            // {} + {} + <>...<> + [<>, {}] => {}
            pHead = pTry; 
            //_DUMPLINK(m_pLink, m_pWord);
        } else {
            goto gotoExit;
        } // Terminate
    } else {
        // Try to locate a unknown trademark
        assert(pHead);  // protect from changes 
        pTry = pHead;   // keep this point for unknown trademark detection
        cwchTM = pHead->cwchLen();
        pHead = pHead->pPrevWord();
        while (1) {
            // search the {} or {} before unknown trademark, for better performance
            if (pHead == NULL || cwchTM > MAX_UNKNOWN_TM) {
                goto gotoExit;
            }
            if (pHead->fGetAttri(LADef_nounPlace) ||
                pHead->fGetAttri(LADef_nounOrg)) {
                break; // got it!
            }
            cwchTM += pHead->cwchLen();
            pHead = pHead->pPrevWord();
        }
        // Now we can check the unknown string between pHead(Excluded) to pTry(Incuded)
        while (pTry != pHead) {
            if (pTry->fGetFlag(CWord::WF_SBCS) || 
                pTry->fGetAttri(LADef_punPunct) ||
                pTry->fGetAttri(LADef_pnNoTM) ) {
                // Should not include some specific sort of word nodes
                goto gotoExit;
            }
            pTry = pTry->pPrevWord();
            assert(pTry != NULL); // impossible?
        }
        //_DUMPLINK(m_pLink, m_pWord);
        fOK = TRUE;
    }

    // Try to bind more words before the Org name just found
    assert(fOK && pHead); // A valid Org name has been found
    if ((pTry = pHead->pPrevWord()) == NULL) {
        goto gotoExit;
    }

    if (pTry->fGetAttri(LADef_nounOrg) || pTry->fGetAttri(LADef_nounPlace)) {
        // [{},{}] + (  ) => {}  One level is enough to bind all
        pHead = pTry;
        //_DUMPLINK(m_pLink, m_pWord);
    } else if (pTry->fGetAttri(LADef_pnShang) ||
               pTry->fGetAttri(LADef_numOrdinal) ||
               pTry->fGetAttri(LADef_numInteger)) {
        // [{},{}] + <>...<> + (  ) => {}
        pTry = pTry->pPrevWord(); 
        while (pTry && (pTry->fGetAttri(LADef_pnShang) ||
                        pTry->fGetAttri(LADef_numOrdinal) || 
                        pTry->fGetAttri(LADef_numInteger))) {
            pTry = pTry->pPrevWord(); // skip one or more <>
        }

        if (pTry == NULL) {
            goto gotoExit;
        }

        if (pTry->fGetAttri(LADef_nounOrg) ||
            pTry->fGetAttri(LADef_nounPlace)) {

            pHead = pTry; // Got it!
            //_DUMPLINK(m_pLink, m_pWord);
        }
    } else {
    }
    
gotoExit:
    if (fOK) { // A valid Org name found
        assert(pHead);
        // Merge words from pHead to m_pWord
        pTry = m_pWord->pNextWord();
        m_pWord = pHead;
        while (m_pWord->pNextWord() != pTry) {
            assert(pHead != NULL);
            m_pLink->MergeWithNext(m_pWord, FALSE);
        }
        assert(m_pWord->cwchLen() > 1); // Make sure the WMDef_wmChar mark was not lost
        m_pWord->SetAttri(LADef_posN);
        m_pWord->SetAttri(LADef_nounOrg);
#ifdef LADef_iwbAltPhr
        m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
        //_DUMPLINK(m_pLink, m_pWord);
        return TRUE;
    }

    return FALSE;
}


/*============================================================================
CJargon::fGetForeignString()
    Get foreign string
Returns:
    TRUE if the is an multi-section foreign name found and merged
    FALSE if only one section found, and the word follows the last word node 
          in the likely foreign name will be returned in ppTail
Remarks:
    m_pWord is not moved!!!
============================================================================*/
inline BOOL CJargon::fGetForeignString(CWord** ppTail)
{
    CWord*  pWord;
    CWord*  pNext;
    CWord*  pHead;
    CWord*  pTail;
    BOOL    fOK, fAdd = FALSE;

    assert(m_iecError == PRFEC::gecNone);
    assert(!m_pWord->fIsTail() && m_pWord->fGetAttri(LADef_pnWai));
    
    // Test "A.St." previous to current word. 
    // Handle both DBCS point "" and SBCS point "."
    fOK = FALSE;
    pHead = m_pWord;
    if (!m_pWord->fIsHead() && !m_pWord->pPrevWord()->fIsHead() ) {
        pWord = m_pWord->pPrevWord();
        if ( (   (pWord->fIsWordChar(SC_CHAR_WAIDIAN) || 
                  pWord->fIsWordChar(SC_CHAR_SHUDIAN)  ) &&
                 pWord->pPrevWord()->fGetAttri(LADef_genDBForeign)
             ) ||
             (   pWord->fIsWordChar(SC_CHAR_ANSIDIAN) &&
                 pWord->pPrevWord()->fGetFlag(CWord::WF_SBCS) &&
                 pWord->pPrevWord()->fGetAttri(LADef_posN)
             ) ) {
            fOK = TRUE;
            pHead = pWord->pPrevWord();
            pWord = pHead->pPrevWord();
            if (pWord && !pWord->fIsHead()) {
                // to find the second backword foreign name section
                if( (   (pWord->fIsWordChar(SC_CHAR_WAIDIAN) || 
                         pWord->fIsWordChar(SC_CHAR_SHUDIAN)  ) &&
                        pWord->pPrevWord()->fGetAttri(LADef_genDBForeign)
                    ) ||
                    (   pWord->fIsWordChar(SC_CHAR_ANSIDIAN) &&
                        pWord->pPrevWord()->fGetFlag(CWord::WF_SBCS) &&
                        pWord->pPrevWord()->fGetAttri(LADef_posN)
                    ) ) {
                    pHead = pWord->pPrevWord();
                }
            } // End of if (pWord && !pWord->fIsHead())
        }
    }
    
    // Find the right boundary of the foreign name  
    pTail = m_pWord;
    pWord = m_pWord;
    pNext = m_pWord->pNextWord();
    while (1) {
        // Get a valid section
        while (pNext && pNext->fGetAttri(LADef_pnWai)) {
            if (!pNext->fGetAttri(LADef_pnNoFTail)) {
                pTail = pNext;
            }
            pNext = pNext->pNextWord();
        }
        if (pTail->pNextWord() != pNext) {
            break;
        }
        // Test more section
        if (pNext && !pNext->fIsTail() && 
            ( pNext->fIsWordChar(SC_CHAR_WAIDIAN) || 
              pNext->fIsWordChar(SC_CHAR_SHUDIAN) ||
              pWord->fIsWordChar(SC_CHAR_ANSIDIAN)
            ) && 
            ( pNext->pNextWord()->fGetAttri(LADef_pnWai) &&
              !pNext->pNextWord()->fGetAttri(LADef_pnNoFHead)
            ) ) {
            // A valid point foreign name separator
            fOK = TRUE;
            // Add this section to the foreign name list
            if (pWord->pNextWord() != pNext) { // don't add if only one word node
                assert((pNext->pwchGetText() - pWord->pwchGetText()) > 1);
                m_ptblForeign->cwchAdd(pWord->pwchGetText(),
                                       (UINT)(pNext->pwchGetText()-pWord->pwchGetText()));
            }
            pNext = pNext->pNextWord();
            pWord = pNext;
            pTail = pNext;          
        } else {
            //_DUMPLINK(m_pLink, pNext);
            break;
        }
        if (pNext->pNextWord()) {
            pNext = pNext->pNextWord();
        }
    } // end of while(1)

    // Add the last section to the foreign name list
    if (fOK && pWord != pTail) { // don't add if only one word node
        assert(pTail && (pTail->pwchGetText() - pWord->pwchGetText()) >= 1 && pTail->cwchLen());
        m_ptblForeign->cwchAdd(pWord->pwchGetText(),
                               (UINT)(pTail->pwchGetText() - pWord->pwchGetText() + pTail->cwchLen()));
    }

    pTail = pTail->pNextWord();

    if (fOK) { // More than one section in the foreign name, merge directly
        m_pWord = pHead;
        while (m_pWord->pNextWord() != pTail) {
            assert(m_pWord->pNextWord());
            m_pLink->MergeWithNext(m_pWord, FALSE);
        }
        m_pWord->SetAttri(LADef_posN);
        m_pWord->SetAttri(LADef_nounPerson);
#ifdef LADef_iwbAltPhr
        m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
    }
    *ppTail = pTail;
    return fOK;
}


/*============================================================================
CJargon::fForeignNameHandler():
    Foreign proper name identification
Returns:
    TRUE if success
    FALSE if runtime error, error code in m_iecError
============================================================================*/
inline BOOL CJargon::fForeignNameHandler(CWord* pTail)
{
    BOOL    fOK;
    CWord*  pWord;
    int     nMerge = 0;

    assert(m_iecError == PRFEC::gecNone);
    assert(m_pWord->fGetAttri(LADef_pnWai) &&
            !m_pWord->fGetAttri(LADef_pnNoFHead) &&
            !m_pWord->fIsTail());

    if ((fOK = fInTable(m_pWord, m_ptblForeign))) { // In 
        pTail = m_pWord->pNextWord();
        if (pTail == NULL) {
            m_pWord->SetAttri(LADef_posN);
            m_pWord->SetAttri(LADef_nounTerm);
            //_DUMPLINK(m_pLink, m_pWord);
            return TRUE;
        }
        //_DUMPLINK(m_pLink, m_pWord);
    }

    // Try to decided what kind of name it is for a likely foreign name
    // Try name of person first:
    if (!m_pWord->fIsHead() &&
        m_pWord->pPrevWord()->fGetAttri(LADef_pnQian)) {
        // <> + * => Merge()
        //_DUMPLINK(m_pLink, m_pWord);
        goto gotoMergePerson;
    }
    if (pTail->pNextWord() &&
        pTail->fGetAttri(LADef_pnHou)) {
        // * + <> => Merge()
        //_DUMPLINK(m_pLink, m_pWord);
        goto gotoMergePerson;
    }           
    if (!m_pWord->fIsHead() && !m_pWord->pPrevWord()->fIsHead() &&
        m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_DE4) &&
        ( m_pWord->pPrevWord()->pPrevWord()->fGetAttri(LADef_pnDian) ||
          m_pWord->pPrevWord()->pPrevWord()->fGetAttri(LADef_nounPlace) ||
          m_pWord->pPrevWord()->pPrevWord()->fGetAttri(LADef_nounOrg) ) ) {
        // [<>,{}] + "" + * => Merge(), 
        // SetWordInfo(), AddForeignList()
        //_DUMPLINK(m_pLink, m_pWord);
        goto gotoMergePerson;
    }
    if (!pTail->fIsTail() &&
        (pTail->fGetAttri(LADef_punPunct)|| pTail->fIsWordChar(SC_CHAR_DENG))&&
        (m_pWord->fIsHead() || m_pWord->pPrevWord()->fGetAttri(LADef_punPunct))){
        // [{},<>] + * + [<>,""] => Merge(),
        // SetWordInfo(), AddForeignList()
        //_DUMPLINK(m_pLink, m_pWord);
        goto gotoMergePerson;
    }
    
    // Try name of place or organization
    if (!pTail->fIsTail()) {
        if (pTail->fGetAttri(LADef_pnShang) ||
            pTail->fGetAttri(LADef_nounOrg)) {
            // * + [<>,{}] => Merge()
            if (!fOK) { // Not in the foreign name list
                while (m_pWord->pNextWord() != pTail) {
                    m_pLink->MergeWithNext(m_pWord, FALSE);
                }
                AddWordToTable(m_pWord, m_ptblForeign);
            }
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_posN);
            m_pWord->SetAttri(LADef_nounTM);
            //_DUMPLINK(m_pLink, m_pWord);
            return TRUE;
        }
        if (pTail->fGetAttri(LADef_pnDian) && !m_pWord->fIsHead() && 
            ( m_pWord->pPrevWord()->fGetAttri(LADef_nounPlace) ||
              m_pWord->pPrevWord()->fGetAttri(LADef_nounOrg)) ) {
            // [{}{}] + * + <> => Merge(2,3)
            if (!fOK) {
                while (m_pWord->pNextWord() != pTail) {
                    m_pLink->MergeWithNext(m_pWord, FALSE);
                }
                AddWordToTable(m_pWord, m_ptblForeign);
            }
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
            m_pWord->SetAttri(LADef_nounOrg);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return TRUE;
        }
        if (pTail->fGetAttri(LADef_pnDi)) {
            // * + <> => Merge(1,2,3) mark as {}
            pTail = pTail->pNextWord();
            if (pTail && pTail->fGetAttri(LADef_pnDi)) {
                pTail = pTail->pNextWord();
            }
            //_DUMPLINK(m_pLink, m_pWord);
            goto gotoMergePlace;
        }
    } // End of if(!pTail->fIsTail())

    if (!m_pWord->fIsHead()) {
        pWord = m_pWord->pPrevWord();
        if (pWord->fGetAttri(LADef_pnCheng)) {
            // <> + * => Mark(*) as <>
            //_DUMPLINK(m_pLink, m_pWord);
            goto gotoMergePlace;
        }
        if (pWord->fGetAttri(LADef_nounPlace)) {
            // {} + * => Mark * as {}
            //_DUMPLINK(m_pLink, m_pWord);
            goto gotoMergePlace;
        }
        if (pWord->fGetAttri(LADef_pnLianMing) && !pWord->fIsHead()) {
            if (pWord->pPrevWord()->fGetAttri(LADef_pnHou) ||
                pWord->pPrevWord()->fGetAttri(LADef_nounPerson) ) {
                // [,] + [""] + * => Merge(),
                // SetWordInfo(), AddForeignList()
                //_DUMPLINK(m_pLink, m_pWord);
                goto gotoMergePerson;
            } else if (pWord->pPrevWord()->fGetAttri(LADef_nounPlace)) {
                //_DUMPLINK(m_pLink, m_pWord);
                goto gotoMergePlace;
            } else {
            }
        }
    } // End of if(!m_pWord->fIsHead())
    
    if (fOK) { // Found in ForeignTable but could not identify which kind of name it is!
        m_pWord->SetAttri(LADef_posN);
        m_pWord->SetAttri(LADef_nounTerm);
        //_DUMPLINK(m_pLink, m_pWord);
        return TRUE;
    }

    if (pTail && (pTail->pwchGetText() - m_pWord->pwchGetText()) >= 4) {
        // very long 
        while (m_pWord->pNextWord() != pTail) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
        }
        m_pWord->SetAttri(LADef_posN);
        m_pWord->SetAttri(LADef_nounTerm);
#ifdef LADef_iwbAltPhr
        m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
        //_DUMPLINK(m_pLink, m_pWord);
        return TRUE;
    }

    return FALSE;

gotoMergePlace:
    if (!fOK) {
        while (m_pWord->pNextWord() != pTail) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
        }
        AddWordToTable(m_pWord, m_ptblForeign);
#ifdef LADef_iwbAltPhr
        m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
    }
    m_pWord->SetAttri(LADef_posN);
    m_pWord->SetAttri(LADef_nounPlace);
    //_DUMPLINK(m_pLink, m_pWord);
    return TRUE;

gotoMergePerson:
    if (!fOK) {
        while (m_pWord->pNextWord() != pTail) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
        }
        AddWordToTable(m_pWord, m_ptblForeign);
#ifdef LADef_iwbAltPhr
        m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
    }
    m_pWord->SetAttri(LADef_posN);
    m_pWord->SetAttri(LADef_nounPerson);
    //_DUMPLINK(m_pLink, m_pWord);
    return TRUE;
}


/*============================================================================
CJargon::fHanPersonHandler():
    HanZu person name identification
Returns:
    TRUE if success
    FALSE if runtime error, error code in m_iecError
============================================================================*/
inline BOOL CJargon::fHanPersonHandler(void)
{
    CWord*  pTail = NULL;
    CWord*  pNext;
    CWord*  pPrev;
    USHORT  cwchLen;

    assert(m_iecError == PRFEC::gecNone);
    if ( m_pWord->fIsTail() || 
        ( !m_pWord->fGetAttri(LADef_pnXing) &&
          !m_pWord->fGetAttri(LADef_pnMing2)) ) {
        return FALSE;
    }

    cwchLen = m_pWord->fGetAttri(LADef_pnXing) ? m_pWord->cwchLen() : 0;
    if (fInTable(m_pWord, m_ptblName)) {
        // In 
        //_DUMPLINK(m_pLink, m_pWord);
        if ( (m_pWord->cwchLen() - cwchLen) == 1 &&
            !m_pWord->fIsTail() &&
            m_pWord->pNextWord()->fGetAttri(LADef_pnMing) &&
            !m_pWord->pNextWord()->fGetAttri(LADef_genCi) ) {
            // *# + <> => Merge(1,2);
            m_pLink->MergeWithNext(m_pWord, FALSE);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
        }
        m_pWord->SetAttri(LADef_posN);
        m_pWord->SetAttri(LADef_nounPerson);
        return TRUE;
    }

    if (m_pWord->fGetAttri(LADef_pnXing)) { // *<>
        assert(!m_pWord->fIsTail());
        pNext = m_pWord->pNextWord();
        if (!pNext->fIsTail() &&
            pNext->fGetAttri(LADef_pnMing) &&
            pNext->pNextWord()->fGetAttri(LADef_pnMing) ) {
            // *<> + <> + <>
            if ( (m_pWord->fGetFlag(CWord::WF_CHAR) &&
                !m_pWord->fGetAttri(LADef_genCi)) ||
                !pNext->fGetAttri(LADef_genCi) ||
                !pNext->pNextWord()->fGetAttri(LADef_genCi) ) {
                // *<> + <> + <> && [1,2,3] <> => Merge(1,2,3);
                m_pLink->MergeWithNext(m_pWord, FALSE);
                m_pLink->MergeWithNext(m_pWord, FALSE);
#ifdef LADef_iwbAltPhr
                m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
                m_pWord->SetAttri(LADef_posN);
                m_pWord->SetAttri(LADef_nounPerson);
                // Add this name to the naming table
                AddWordToTable(m_pWord, m_ptblName);
                //_DUMPLINK(m_pLink, m_pWord);
                return TRUE;
            }
            // Need confirm
            pTail = pNext->pNextWord()->pNextWord();
            //_DUMPLINK(m_pLink, m_pWord);
        } else if (pNext->fGetAttri(LADef_pnMing) ||
                   pNext->fGetAttri(LADef_pnMing2)) { 
            // *<> + <: >
            if ((m_pWord->fGetFlag(CWord::WF_CHAR) &&
                !m_pWord->fGetAttri(LADef_genCi)) ||
                (pNext->fGetFlag(CWord::WF_CHAR) &&
                !pNext->fGetAttri(LADef_genCi)) ) {
                // *<> + <> && [1,2] <> => Merge(1,2);
                m_pLink->MergeWithNext(m_pWord, FALSE);
                m_pWord->SetAttri(LADef_posN);
                m_pWord->SetAttri(LADef_nounPerson);
#ifdef LADef_iwbAltPhr
                m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
                // Add this name to the naming table
                AddWordToTable(m_pWord, m_ptblName);
                //_DUMPLINK(m_pLink, m_pWord);
                return TRUE;
            }
            // Need confirm
            pTail = pNext->pNextWord();
            //_DUMPLINK(m_pLink, m_pWord);
        } else { 
            // Other cases for <>
            if (pNext->fGetAttri(LADef_pnHou) ||
                pNext->fGetAttri(LADef_pnXingZhi)) {
                // *<> + [<>, <>] => Merge(1,2);
                m_pLink->MergeWithNext(m_pWord, FALSE);
                m_pWord->SetAttri(LADef_posN);
                m_pWord->SetAttri(LADef_nounPerson);
#ifdef LADef_iwbAltPhr
                m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
                //_DUMPLINK(m_pLink, m_pWord);
                return TRUE;
            }
            if (!pNext->fIsTail() && pNext->fGetAttri(LADef_pnPaiHang) &&
                pNext->pNextWord()->fGetAttri(LADef_pnChengWei) ) {
                // *<> + # + # => Merge(1,2,3); 
                m_pLink->MergeWithNext(m_pWord, FALSE);
                m_pLink->MergeWithNext(m_pWord, FALSE);
                m_pWord->SetAttri(LADef_posN);
                m_pWord->SetAttri(LADef_nounPerson);
#ifdef LADef_iwbAltPhr
                m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
                //_DUMPLINK(m_pLink, m_pWord);
                return TRUE;
            }
            if (!m_pWord->fIsHead() && 
                ( m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_XIAO) ||
                  m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_LAO)) ) {
                // [""] + *<> =>Merge(1,2);
                m_pWord = m_pWord->pPrevWord();
                m_pLink->MergeWithNext(m_pWord, FALSE);
                m_pWord->SetAttri(LADef_posN);
                m_pWord->SetAttri(LADef_nounPerson);
#ifdef LADef_iwbAltPhr
                m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
                //_DUMPLINK(m_pLink, m_pWord);
                return TRUE;
            }
        }
    } else {
        // *<>: 
        assert(m_pWord->fGetAttri(LADef_pnMing2));
        if (m_pWord->fGetAttri(LADef_nounPerson)) { // *{}
            if (m_pWord->pNextWord()->fGetAttri(LADef_pnMing)) { // *{} + <>
                // To be confirmed
                pTail = m_pWord->pNextWord()->pNextWord();
//                assert(pTail);
                //_DUMPLINK(m_pLink, m_pWord);
            } else {
                return TRUE;
            }
        }
    } // end of *<>

    // Could not fall in here w/ pTail == NULL!!!
    if (pTail == NULL) {
        return FALSE;
    }

    // Confirm the likely name of persons
    if (!m_pWord->fIsHead()) {
        pPrev = m_pWord->pPrevWord();
        if (pPrev->fGetAttri(LADef_pnQian) ||
            pPrev->fGetAttri(LADef_pnLianMing)) {
            // [<>, []] + *# => Merge(2...)
            //_DUMPLINK(m_pLink, m_pWord);
            goto gotoMerge;
        }
        if (pPrev->fGetAttri(LADef_nounPerson) && pPrev->cwchLen() == 3) {
            // {} + *# (1 [""]) =>
            //_DUMPLINK(m_pLink, m_pWord);
            //goto gotoMerge;
        }
        if (pTail->pNextWord() &&
            pPrev->fGetAttri(LADef_punPunct) &&
            ( pTail->fGetAttri(LADef_punPunct) ||
              pTail->fGetAttri(LADef_pnLianMing)) ) {
            // <> + *# + [<>, ""] =>
            //_DUMPLINK(m_pLink, m_pWord);
            goto gotoMerge;
        }
    }

    if (pTail->pNextWord()) {
        if (pTail->fGetAttri(LADef_pnHou)) { // *# + <> =>
            //_DUMPLINK(m_pLink, m_pWord);
            goto gotoMerge;
        }
        if (pTail->fGetAttri(LADef_pnAction)) { // *# + <> =>
            //_DUMPLINK(m_pLink, m_pWord);
            goto gotoMerge;
        }
    }

    return FALSE;  // No name found!

gotoMerge:
    while (m_pWord->pNextWord() != pTail) {
        m_pLink->MergeWithNext(m_pWord, FALSE);
    }
    m_pWord->SetAttri(LADef_posN);
    // Add this name to the naming table
    AddWordToTable(m_pWord, m_ptblName);
    if (!m_pWord->fIsTail() && 
        ( m_pWord->pNextWord()->fGetAttri(LADef_pnDian) ||
          m_pWord->pNextWord()->fGetAttri(LADef_nounOrg)) ) {
        // *#{} + [<>, {}] => Merge(1,2); SetWordInfo(*, 0, 0, {});
        m_pLink->MergeWithNext(m_pWord, FALSE);
        m_pWord->SetAttri(LADef_nounOrg);
#ifdef LADef_iwbAltPhr
        m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
        //_DUMPLINK(m_pLink, m_pWord);
        return TRUE;
    }
    m_pWord->SetAttri(LADef_nounPerson);
#ifdef LADef_iwbAltPhr
    m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
    //_DUMPLINK(m_pLink, m_pWord);
    return TRUE;
}


/*============================================================================
Merge  + 
============================================================================*/
inline BOOL CJargon::fChengWeiHandler(void)
{
    assert(m_iecError == PRFEC::gecNone);

    if (m_pWord->fGetAttri(LADef_pnChengWei) && !m_pWord->fIsHead()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_pnPaiHang)) {
            // * +  => Merge(1,2); SetWordInfo(<>);
            // occurs 742 times in 20M corpus
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_pnQian);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return TRUE;
        }
    }
    return FALSE;
}


/*============================================================================
Service functions
============================================================================*/
// Add pWord to specific table
void CJargon::AddWordToTable(CWord* pWord, CFixTable* pTable)
{
    pTable->cwchAdd( pWord->pwchGetText(), pWord->cwchLen() );
}


// Check proper name table, and merge match words
BOOL CJargon::fInTable(CWord* pWord, CFixTable* pTable)
{
    CWord*  pNext = pWord->pNextWord();
    LPWSTR  pwchWord = pWord->pwchGetText();
    USHORT  cwchMatch, cwchLen = pWord->cwchLen();
    USHORT  ciWord = 0;

    cwchMatch = pTable->cwchMaxMatch(pwchWord, (UINT)(m_pLink->cwchGetLength() -
                                               ( pWord->pwchGetText() -
                                                 m_pLink->pwchGetText())));
    if (!cwchMatch) {
        return FALSE;
    }
    while (pNext && (cwchLen < cwchMatch)) {
        cwchLen += pNext->cwchLen();
        pNext = pNext->pNextWord();
        ciWord++;
    }
    if (cwchLen == cwchMatch) {
        // Match at word bounary, merge words
        for (cwchMatch = 0; cwchMatch < ciWord; cwchMatch++) {
            m_pLink->MergeWithNext(pWord, FALSE);
#ifdef LADef_iwbAltPhr
            pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
        }
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\lexdef.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component:  LexDef
Purpose:    Declare the file structure of lexicon.
            This is only a header file w/o any CPP, this header will be included
            by both Lexicon and LexMan module.          
Notes:      We drop this file in Engine sub project only because we want to make 
            Engine code self-contained
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/5/97
============================================================================*/
#ifndef _LEXDEF_H_
#define _LEXDEF_H_

// define Unicode character blocks
#define LEX_LATIN_FIRST     0x0020
#define LEX_LATIN_LAST      0x00bf
#define LEX_GENPUNC_FIRST   0x2010
#define LEX_GENPUNC_LAST    0x2046
#define LEX_NUMFORMS_FIRST  0x2153
#define LEX_NUMFORMS_LAST   0x2182
#define LEX_ENCLOSED_FIRST  0x2460
#define LEX_ENCLOSED_LAST   0x24ea
#define LEX_CJKPUNC_FIRST   0x3000
#define LEX_CJKPUNC_LAST    0x33ff
#define LEX_CJK_FIRST       0x4e00
#define LEX_CJK_LAST        0x9fff
#define LEX_FORMS_FIRST     0xff01
#define LEX_FORMS_LAST      0xff64

// basic latin  [0x20,0x7e]
#define LEX_IDX_OFST_LATIN   0
#define LEX_LATIN_TOTAL      (LEX_LATIN_LAST - LEX_LATIN_FIRST + 1)
// General punctuation [0x2010,0x2046]
#define LEX_IDX_OFST_GENPUNC (LEX_IDX_OFST_LATIN + LEX_LATIN_TOTAL)
#define LEX_GENPUNC_TOTAL    (LEX_GENPUNC_LAST - LEX_GENPUNC_FIRST + 1)
// Number Forms :  ...
#define LEX_IDX_OFST_NUMFORMS   (LEX_IDX_OFST_GENPUNC + LEX_GENPUNC_TOTAL)
#define LEX_NUMFORMS_TOTAL      (LEX_NUMFORMS_LAST - LEX_NUMFORMS_FIRST + 1)
// Enclosed Alphanumerics; ... ... ...
#define LEX_IDX_OFST_ENCLOSED   (LEX_IDX_OFST_NUMFORMS + LEX_NUMFORMS_TOTAL)
#define LEX_ENCLOSED_TOTAL      (LEX_ENCLOSED_LAST - LEX_ENCLOSED_FIRST + 1)
// CJK symbols and punctuation [0x3000,0x301f]
#define LEX_IDX_OFST_CJKPUNC (LEX_IDX_OFST_ENCLOSED + LEX_ENCLOSED_TOTAL)
#define LEX_CJKPUNC_TOTAL    (LEX_CJKPUNC_LAST - LEX_CJKPUNC_FIRST + 1)
// CJK unified idographs [0x4e00,0x9fff]
#define LEX_IDX_OFST_CJK     (LEX_IDX_OFST_CJKPUNC + LEX_CJKPUNC_TOTAL)
#define LEX_CJK_TOTAL        (LEX_CJK_LAST - LEX_CJK_FIRST + 1)
// halfwidth and fullwidth forms [0xff01,0xff64]
#define LEX_IDX_OFST_FORMS   (LEX_IDX_OFST_CJK + LEX_CJK_TOTAL)
#define LEX_FORMS_TOTAL      ((LEX_FORMS_LAST - LEX_FORMS_FIRST + 1) + 1)

#define LEX_IDX_OFST_OTHER   (LEX_IDX_OFST_FORMS + LEX_FORMS_TOTAL)
#define LEX_INDEX_COUNT      (LEX_IDX_OFST_OTHER + 1)

// define encoding/decodeing magic number
#define LEX_CJK_MAGIC       0x5000
#define LEX_LATIN_MAGIC     0x8000
#define LEX_GENPUNC_MAGIC   (LEX_LATIN_MAGIC + LEX_LATIN_TOTAL)
#define LEX_NUMFORMS_MAGIC  (LEX_GENPUNC_MAGIC + LEX_GENPUNC_TOTAL)
#define LEX_ENCLOSED_MAGIC  (LEX_NUMFORMS_MAGIC + LEX_NUMFORMS_TOTAL)
#define LEX_CJKPUNC_MAGIC   (LEX_ENCLOSED_MAGIC + LEX_ENCLOSED_TOTAL)
#define LEX_FORMS_MAGIC     0xff00
// all encoded word in lex would has MostSignificant set to 1
#define LEX_MSBIT       0x8000
// no lex flag and offset mask for lex index item
#define LEX_INDEX_NOLEX 0x80000000
#define LEX_OFFSET_MASK 0x7fffffff

/*============================================================================
Struct  CRTLexHeader
Desc:   File header of lexicon. The offset of both Index and Lex data section will be 
        defined, and some version info are also defined in this structure
============================================================================*/
#pragma pack(1)

struct CRTLexHeader
{
    DWORD   m_dwVersion;
    DWORD   m_ofbIndex;         // Offset of Index section, it's the length of CLexHeader
    DWORD   m_ofbText;          // Offset of Lex section
    DWORD   m_ofbProp;          // property, attributes and index of feature set
    DWORD   m_ofbFeature;
    DWORD   m_cbLexSize;        // size of the whole lexicon
};

/*============================================================================
Struct  CRTLexIndex
Desc:   Index node data structure
        (m_dwIndex & 0x80000000), if no multi-char word in lexicon.
        Use (m_dwIndex & 0x7FFFFFFF) to keep tracking the position in lex section
        The offset is count in 2 bytes, bytes offset = (m_ofwLex * 2) (same as WIC)
        For words with no property, just set m_ofbProp = 0
============================================================================*/
struct CRTLexIndex
{
    DWORD   m_ofwLex;   // offset in the lex area count by WORD !
    DWORD   m_ofbProp;  // offset in the property area
};

/*============================================================================
Struct  CRTLexRec
Desc:   Structure of word mark of multi-char word in the lexicon
        For words with no property, just set m_ofbProp = 0
============================================================================*/
struct CRTLexRec
{
    DWORD   m_ofbProp;      // Both HiWord and LoWord's high bit == 0
    // follows by the lex text
    // WCHAR m_rgchLex[];
};

/*============================================================================
Struct  CRTLexProp
Desc:   Structure of lex property
============================================================================*/
struct CRTLexProp
{
    WORD    m_iWordID;
    // WORD m_wFlags;       // more property of lex can be add here
    USHORT  m_ciAttri;
    USHORT  m_ciFeature;
    // follows the attributes and feature index
    // USHORT m_rgAttri[];
    // CRTLexFeature m_rgFertureIndex[];
};

/*============================================================================
Struct  CRTLexFeature
Desc:   Structure of lex feature index
============================================================================*/
struct CRTLexFeature
{
    USHORT  m_wFID;
    USHORT  m_cwchLen;
    DWORD   m_ofbFSet;  // offset point to the feature area
};

/*============================================================================
The feature text of lex stored as "abcd\0efgh\0ijk\0...."
There is no separators between features, also no separators between lex feature sets
============================================================================*/

#pragma pack()


#endif // _LEXDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\iwordbreaker.h ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: WordBreaker.h    
Purpose:   Declaration of the CIWordBreaker
Remarks:
Owner:     i-shdong@microsoft.com
Platform:  Win32
Revise:    First created by: i-shdong    11/17/1999
============================================================================*/

#ifndef __IWordBreaker_H_
#define __IWordBreaker_H_

extern "C" const IID IID_IWordBreaker;
class CUnknown;
class CWBEngine;
class CWordLink;
struct CWord;

// CIWordBreaker
class CIWordBreaker : public CUnknown,
                      public IWordBreaker
{

public:	
	// Creation
	static HRESULT CreateInstance(IUnknown* pUnknownOuter,
	                              CUnknown** ppNewComponent ) ;

private:
    DECLARE_IUNKNOWN

    // Nondelegating IUnknown
	virtual HRESULT __stdcall 
		NondelegatingQueryInterface( const IID& iid, void** ppv) ;

    // Initialization
	virtual HRESULT Init() ;

	// Cleanup
	virtual void FinalRelease() ;

    // IWordBreaker
	STDMETHOD(Init)( 
            /* [in] */ BOOL fQuery,
            /* [in] */ ULONG ulMaxTokenSize,
            /* [out] */ BOOL __RPC_FAR *pfLicense);

    STDMETHOD(BreakText)( 
            /* [in] */ TEXT_SOURCE __RPC_FAR *pTextSource,
            /* [in] */ IWordSink __RPC_FAR *pWordSink,
            /* [in] */ IPhraseSink __RPC_FAR *pPhraseSink);
        
    STDMETHOD(ComposePhrase)( 
            /* [size_is][in] */ const WCHAR __RPC_FAR *pwcNoun,
            /* [in] */ ULONG cwcNoun,
            /* [size_is][in] */ const WCHAR __RPC_FAR *pwcModifier,
            /* [in] */ ULONG cwcModifier,
            /* [in] */ ULONG ulAttachmentType,
            /* [size_is][out] */ WCHAR __RPC_FAR *pwcPhrase,
            /* [out][in] */ ULONG __RPC_FAR *pcwcPhrase);
        
    STDMETHOD(GetLicenseToUse)( 
            /* [string][out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcsLicense);

private:    
	CIWordBreaker(IUnknown* pUnknownOuter);

    ~CIWordBreaker();

    // Put all word in m_pLink to IWordSink
    SCODE PutWord(IWordSink *pWordSink, DWORD& cwchSrcPos, DWORD cwchText, BOOL fEnd);
    // Put all word in m_pLink to IPhraseSink
    SCODE PutPhrase(IPhraseSink *pPhraseSink, DWORD& cwchSrcPos, DWORD cwchText, BOOL fEnd);
    // Put all word in m_pLink to both IWordBreaker and IPhraseSink
    SCODE PutBoth(IWordSink *pWordSink, IPhraseSink *pPhraseSink,
                  DWORD& cwchSrcPos, DWORD cwchText, BOOL fEnd);
    // PutWord() all of the pWord's child word 
    SCODE PutAllChild(IWordSink *pWordSink, CWord* pWord,
                     ULONG cwchSrcPos, ULONG cwchPutWord);
    
    //	Load the lexicon and charfreq resource into memory
    BOOL CIWordBreaker::fOpenLexicon(void);

protected:
    LPBYTE      m_pbLex;
	CWBEngine*	m_pEng;
	CWordLink*	m_pLink;
    ULONG       m_ulMaxTokenSize;
    BOOL        m_fQuery;
    BOOL        m_fInit;
    LPWSTR      m_pwchBuf;
	// Mutex to protect member access
	HANDLE m_hMutex ;
	// Handle to the free threaded marshaller
	IUnknown* m_pIUnknownFreeThreadedMarshaler ;
};

#endif //__WordBreaker_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\jargon.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CJargon
Purpose:    Implement process control and public functions in CJargon class
            There are a lot of tasks to do in Jargon moudle:
            1. Name of palce (Jargon1.cpp)
            2. Name of foreign person and places (Jargon1.cpp)
            3. Name of orgnizations (Jargon1.cpp)
            4. Name of HanZu person (Jargon1.cpp)               
Notes:      The CJargon class will be implemented in several cpp files:
            Jargon.cpp, Jargon1.cpp, Jargon2.cpp
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#include "myafx.h"

#include "jargon.h"
#include "lexicon.h"
#include "wordlink.h"
#include "proofec.h"
#include "fixtable.h"


/*============================================================================
Implementation of PUBLIC member functions
============================================================================*/
// Constructor
CJargon::CJargon()
{
    m_pLink = NULL;
    m_pLex = NULL;
    m_iecError = 0;
    m_pWord = NULL;
    m_pTail = NULL;
    m_ptblName = NULL;
    m_ptblPlace = NULL;
    m_ptblForeign = NULL;
}


// Destructor
CJargon::~CJargon()
{
    TermJargon();
}


// Initialize the CJargon class
int CJargon::ecInit(CLexicon* pLexicon)
{
    assert(m_pLex == NULL && m_pLink == NULL);
    assert(pLexicon);

    m_pLex = pLexicon;
    
    // Init the 3 FixTable
    if ((m_ptblName = new CFixTable)== NULL || !m_ptblName->fInit(50, 10)) {
        goto gotoOOM;
    }
    if ((m_ptblPlace = new CFixTable)== NULL || !m_ptblPlace->fInit(40, 20)) {
        goto gotoOOM;
    }
    if ((m_ptblForeign =new CFixTable)==NULL || !m_ptblForeign->fInit(60, 15)){
        goto gotoOOM;
    }

    return PRFEC::gecNone;
gotoOOM:
    TermJargon();
    return PRFEC::gecOOM;
}


// Process control function of CJargon class
int CJargon::ecDoJargon(CWordLink* pLink)
{
    assert(pLink);

    m_pLink = pLink;
    m_iecError = PRFEC::gecNone;
    m_pWord = NULL;
    m_pTail = NULL;

    // Perform the proper name identification
    if (!fIdentifyProperNames()) {
        assert(m_iecError != PRFEC::gecNone);
        return m_iecError;
    }

    return PRFEC::gecNone;
}

        
/*============================================================================
Implementation of Private member functions
============================================================================*/
// Terminate the Jargon class
void CJargon::TermJargon(void)
{
    m_pLex = NULL;
    m_pLink = NULL;
    m_iecError = 0;
    m_pWord = NULL;
    m_pTail = NULL;
    if (m_ptblName != NULL) {
        delete m_ptblName;
        m_ptblName = NULL;
    }
    if (m_ptblPlace != NULL) {
        delete m_ptblPlace;
        m_ptblPlace = NULL;
    }
    if (m_ptblForeign != NULL) {
        delete m_ptblForeign;
        m_ptblForeign = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\iwordbreaker.cpp ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: WordBreaker.h    
Purpose:   Implementation of the CIWordBreaker
Remarks:
Owner:     i-shdong@microsoft.com
Platform:  Win32
Revise:    First created by: i-shdong    11/17/1999
============================================================================*/
#include "MyAfx.h"

#include <query.h>
#include <cierror.h>
#include <filterr.h>

#include "CUnknown.h"
#include "IWordBreaker.h"
#include "WordLink.h"
#include "WBEngine.h"
#include "Utility.h"
#include "Lock.h"

extern HINSTANCE   v_hInst;

// constructor
CIWordBreaker::CIWordBreaker(IUnknown* pUnknownOuter)
: CUnknown(pUnknownOuter)
{
    m_pEng = NULL;
    m_pLink = NULL;
    m_ulMaxTokenSize = 0;
    m_fQuery = FALSE;
    m_pbLex = NULL;
    m_fInit = FALSE;
    m_pwchBuf = NULL;
	m_hMutex = NULL ;
	m_pIUnknownFreeThreadedMarshaler = NULL ;
}

// destructor
CIWordBreaker::~CIWordBreaker()
{
    if (m_pwchBuf != NULL) {
        delete [] m_pwchBuf;
    }
    if (m_pEng != NULL) {
        delete m_pEng;
    }
    if (m_pLink != NULL) {
        delete m_pLink;
    }
    if (m_hMutex != NULL) {
        CloseHandle(m_hMutex);
    }
}

/*============================================================================
CIWordBreaker::Init
    Implement IWordBreaker::Init method. 

Returns:
    S_OK, Init ok.
    E_INVALIDARG, if pfLicense is NULL.

Remarks:
    For client, Init must be called before any other method of IWordBreaker.
============================================================================*/
STDMETHODIMP CIWordBreaker::Init( 
            /* [in] */ BOOL fQuery,
            /* [in] */ ULONG ulMaxTokenSize,
            /* [out] */ BOOL __RPC_FAR *pfLicense)
{
    if (pfLicense == NULL) {
        return  E_INVALIDARG;
    }

	CSimpleLock Lock(m_hMutex) ;

    m_fQuery = fQuery;

    if (! ulMaxTokenSize) {
        return E_INVALIDARG;
    }
    if (m_ulMaxTokenSize < ulMaxTokenSize) {
        if (m_pwchBuf != NULL) {
            delete [] m_pwchBuf;
            m_pwchBuf = NULL;
        }
        m_pwchBuf = new WCHAR[ulMaxTokenSize];
        if (m_pwchBuf == NULL) {
            m_fInit = FALSE;
            return WBREAK_E_INIT_FAILED;
        }
    }
    m_ulMaxTokenSize = ulMaxTokenSize;
    *pfLicense = TRUE;

    if (! (m_fInit = fOpenLexicon())) {
        return WBREAK_E_INIT_FAILED;
    } else {
        return S_OK;
    }
}

/*============================================================================
CIWordBreaker::BreakText

    Implement IWordBreaker::BreakText method. This call parses the text it 
receives from pTextSource to find both individual tokens and noun phrases,
then calls methods of pWordSink and pPhraseSink with the results.

Returns:
    S_OK, The raw text in pTextSource has be parsed and no more text is available to refill the buffer.
    E_INVALIDARG, if pTextSource is NULL or Both pWordSink and pPhraseSink is NULL

Remarks:
    MM1 limit: Only less than 64K text should be refill a time.

============================================================================*/
STDMETHODIMP CIWordBreaker::BreakText( 
            /* [in] */ TEXT_SOURCE __RPC_FAR *pTextSource,
            /* [in] */ IWordSink __RPC_FAR *pWordSink,
            /* [in] */ IPhraseSink __RPC_FAR *pPhraseSink)
{
    if (pTextSource == NULL) {
        return  E_INVALIDARG;
    }
    if (pWordSink == NULL && pPhraseSink == NULL) {
        return  E_INVALIDARG;
    } 

    CSimpleLock Lock(m_hMutex) ;

	SCODE	iret;
    SCODE   sFillTextBuffer = S_OK, sPut = S_OK;
    ULONG   cwchText, cwchStart, cwchLine;
    LPCWSTR pwchText = NULL; 
    BOOL    fEndOfText = FALSE; 

    if ((m_pEng = new CWBEngine) == NULL) {
        return ERROR_OUTOFMEMORY;
    }
    if ((m_pLink = new CWordLink) == NULL) {
        delete m_pEng;
        m_pEng = NULL;
        return ERROR_OUTOFMEMORY;
    }
    if ((iret = m_pEng->InitEngine(m_pbLex)) != S_OK) {
        goto gotoExit;
    };

    do {
        // Alloc ANSI buffer and convert Unicode text into ANSI text
        cwchText = pTextSource->iEnd - pTextSource->iCur;
        pwchText = pTextSource->awcBuffer + pTextSource->iCur;

        // refill the raw text buffer
        if ( FAILED(sFillTextBuffer) ) {
            fEndOfText = TRUE;
            iret = sFillTextBuffer == WBREAK_E_END_OF_TEXT ? S_OK : sFillTextBuffer;
        }

        // Hack: query on alpha, client may call with a "\0" string;
		if (cwchText == 0 || 
            cwchText == 1 && *pwchText == NULL) {
		    goto gotoExit;
        }

        // Break the text buffer and fill in the Token List
        do {
            cwchText = pTextSource->iEnd - pTextSource->iCur;
            pwchText = pTextSource->awcBuffer + pTextSource->iCur;

            CWBEngine::FindSentence(pwchText, cwchText, (INT*)&cwchLine);
            assert(cwchLine && cwchLine < 0x0FFFF);
            // Initialize the WordLink
            m_pLink->InitLink(pwchText, (USHORT)(cwchLine));
            // Break the next part of the text buffer
            if (!m_fQuery && ERROR_SUCCESS != m_pEng->BreakLink(m_pLink) ||
                m_fQuery && ERROR_SUCCESS != m_pEng->BreakLink(m_pLink, m_fQuery)) {
                iret = E_FAIL;
                goto gotoExit;
            }

            // Fill in the chunk list and callback Word if the chunk list full
            if (pPhraseSink == NULL) {
                sPut = PutWord(pWordSink, pTextSource->iCur,
                                     cwchText, fEndOfText);
            } else if (pWordSink == NULL) {
                sPut = PutPhrase(pPhraseSink, pTextSource->iCur,
                                     cwchText, fEndOfText);
            } else {
                sPut = PutBoth(pWordSink, pPhraseSink, pTextSource->iCur,
                                     cwchText, fEndOfText);
            }
            // After put word, pTextSource->iCur has been increased correctly
            // by PutWord / PutPhrase / PutBoth
        } while (SUCCEEDED(sPut) && m_pLink->cwchGetLength() < cwchText); 

        if (FAILED(sPut)) {
            fEndOfText = TRUE;
            iret = sPut;
        }
        // need refill buffer
        if (! fEndOfText) {
            sFillTextBuffer=(*(pTextSource->pfnFillTextBuffer))(pTextSource);
        }
    } while  (! fEndOfText);

gotoExit:
    if (m_pLink != NULL) {
        delete m_pLink;
        m_pLink = NULL;
    }
    if (m_pEng != NULL) {
        delete m_pEng;
        m_pEng = NULL;
    }
    if (iret >= FILTER_E_END_OF_CHUNKS &&
        iret <= FILTER_E_PASSWORD ) {
        iret = S_OK;
    }
	return iret;
}
        
/*============================================================================
CIWordBreaker::ComposePhrase

    Implement IWordBreaker::ComposePhrase method. This methord convert a noun
and a modifier back into a linguistically correct source phrase.

Returns:
    S_OK, license information pointer in *ppwcsLicense.
    E_INVALIDARG, if one of pointers in param is NULL.
    WBREAK_E_QUERY_ONLY, if called at index time

Remarks:
    this method isn't implemented in MM1, would be implemented in MM2.

============================================================================*/
STDMETHODIMP CIWordBreaker::ComposePhrase( 
            /* [size_is][in] */ const WCHAR __RPC_FAR *pwcNoun,
            /* [in] */ ULONG cwcNoun,
            /* [size_is][in] */ const WCHAR __RPC_FAR *pwcModifier,
            /* [in] */ ULONG cwcModifier,
            /* [in] */ ULONG ulAttachmentType,
            /* [size_is][out] */ WCHAR __RPC_FAR *pwcPhrase,
            /* [out][in] */ ULONG __RPC_FAR *pcwcPhrase)
{

    if (pwcNoun == NULL || pwcModifier == NULL 
        || pwcPhrase == NULL || pcwcPhrase == NULL ) {
        return  E_INVALIDARG;
    }
    if (! m_fQuery) {
        return WBREAK_E_QUERY_ONLY;
    }
    if ( *pcwcPhrase <= cwcNoun + cwcModifier ) {
        *pcwcPhrase = cwcNoun + cwcModifier + 1;
        return WBREAK_E_BUFFER_TOO_SMALL;
    }

    CSimpleLock Lock(m_hMutex) ;

    wcsncpy( pwcPhrase, pwcModifier, cwcModifier );
    wcsncat( pwcPhrase, pwcNoun, cwcNoun );
    *pcwcPhrase = cwcNoun + cwcModifier + 1;
    return S_OK;
}

LPWSTR  g_pwcsLicense = L"Copyright Microsoft Corporation, 1999";

/*============================================================================
CIWordBreaker::GetLicenseToUse

    Implement IWordBreaker::GetLicenseToUse method. return a pointer to the 
license information provided by WordBreaker.

Returns:
    S_OK, license information pointer in *ppwcsLicense.
    E_INVALIDARG, if ppwcsLicense is NULL.

============================================================================*/
STDMETHODIMP CIWordBreaker::GetLicenseToUse( 
            /* [string][out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcsLicense)
{

    if (ppwcsLicense == NULL) {
        return  E_INVALIDARG;
    }
    *ppwcsLicense = g_pwcsLicense;
    return S_OK;
}

// QueryInterface Implementation
HRESULT __stdcall CIWordBreaker::NondelegatingQueryInterface(const IID& iid,
                                                             void** ppv)
{ 	
	if (iid == IID_IWordBreaker) {
		return FinishQI(static_cast<IWordBreaker*>(this), ppv) ;

    } else if (iid == IID_IMarshal) {
		return m_pIUnknownFreeThreadedMarshaler->QueryInterface(iid,
		                                                        ppv) ;
	} else {
		return CUnknown::NondelegatingQueryInterface(iid, ppv) ;
	}
}

// Creation function used by CFactory
HRESULT CIWordBreaker::CreateInstance(IUnknown* pUnknownOuter,
	                                  CUnknown** ppNewComponent )
{
    if (pUnknownOuter != NULL)
    {
        // Don't allow aggregation (just for the heck of it).
        return CLASS_E_NOAGGREGATION ;
    }
	
    if (NULL == (*ppNewComponent = new CIWordBreaker(pUnknownOuter))) {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

// Initialize the component by creating the contained component
HRESULT CIWordBreaker::Init()
{
	HRESULT hr = CUnknown::Init() ;
	if (FAILED(hr))
	{
		return hr ;
	}

	// Create a mutex to protect member access
	m_hMutex = CreateMutex(NULL, FALSE, NULL) ;
	if (m_hMutex == NULL)
	{
		return E_FAIL ;
	}

	// Aggregate the free-threaded marshaler.
	hr = ::CoCreateFreeThreadedMarshaler(
	        GetOuterUnknown(),
	        &m_pIUnknownFreeThreadedMarshaler) ;
	if (FAILED(hr))
	{
		return E_FAIL ;
	}

	return S_OK ;
}

// FinalRelease - Called by Release before it deletes the component
void CIWordBreaker::FinalRelease()
{
	// Call base class to incremement m_cRef and prevent recursion.
	CUnknown::FinalRelease() ;

    if (m_pIUnknownFreeThreadedMarshaler != NULL)
	{
		m_pIUnknownFreeThreadedMarshaler->Release() ;
	}
}

// Put all word in m_pLink to IWordSink
SCODE CIWordBreaker::PutWord(IWordSink *pWordSink,
                              DWORD& cwchSrcPos,
                              DWORD cwchText,
                              BOOL fEnd)
{
	CWord	*pWord, *pChild;
	DWORD	cwchWord, cwchPutWord, cwch;
    LPCWSTR pwchTemp; 
    WORD    wFtr;
    SCODE   scode = S_OK;
    BOOL    fPunct;

    assert(m_pLink);
    assert(pWordSink);

    // Fill in the chunk list and callback Word if the chunk list full
    pWord = m_pLink->pGetHead();
    if (pWord == NULL) {
        assert(0);
        return scode;
    }
   
    for(; SUCCEEDED(scode) && pWord; pWord = pWord->pNextWord()) {
        cwchPutWord = cwchWord = pWord->cwchLen();
        if( pWord->fIsTail() && pWord != m_pLink->pGetHead()
            && m_pLink->cwchGetLength() >= cwchText
            && ! fEnd
            && cwchPutWord < cwchText ) {
            // the last word node breaked in this buffer maybe isn't a 
            // whole word, so keep this in buffer and refill the buffer
            // to get a whole word.
            return scode;
        }

        if (pWord->fGetAttri(LADef_punJu)) { // end of sentence
            scode = pWordSink->PutBreak( WORDREP_BREAK_EOS );
        } else if (pWord->fGetAttri(LADef_punPunct)) {
                // punctuation or space , don't PutWord
        } else {
            fPunct = iswctype(*(pWord->pwchGetText()), _SPACE | _PUNCT | _CONTROL);            
            for (cwch = 1; fPunct && cwch < cwchPutWord; cwch++) {
                fPunct = iswctype(*(pWord->pwchGetText()+cwch), _SPACE | _PUNCT | _CONTROL);
            }
            if (fPunct) {
                // punctuation or space , don't PutWord
                cwchSrcPos += cwchWord;
                continue;
            }

            if (m_fQuery && pWord->fGetAttri(LADef_iwbAltPhr)) {
                assert(pWord->fHasChild());

                // StartAltPhrase
                scode = pWordSink->StartAltPhrase();
                scode = SUCCEEDED(scode) ? PutAllChild(pWordSink, pWord, cwchSrcPos, cwchPutWord)
                                         : scode;
                
                // StartAltPhrase
                scode = SUCCEEDED(scode) ? pWordSink->StartAltPhrase()
                                         : scode;
                scode = SUCCEEDED(scode) ? pWordSink->PutWord( cwchPutWord, 
                                                        pWord->pwchGetText(),
                                                        cwchPutWord, 
                                                        cwchSrcPos )
                                         : scode;
                scode = SUCCEEDED(scode) ? pWordSink->EndAltPhrase()
                                         : scode;
                cwchSrcPos += cwchWord;
                continue;
            }

            if (pWord->fGetAttri(LADef_iwbNPhr1)) {
                assert(cwchPutWord > 1);
                // putword modifier
                scode = pWordSink->PutWord(1, pWord->pwchGetText(), 1, cwchSrcPos);
                // putword noun
                scode = SUCCEEDED(scode) ? pWordSink->PutWord(cwchPutWord - 1,pWord->pwchGetText() + 1,
                                                    cwchPutWord - 1,cwchSrcPos + 1)
                                         : scode;
                cwchSrcPos += cwchWord;
                continue;
            } 
            
            if (pWord->fGetAttri(LADef_iwbNPhr2)) {
                assert(cwchPutWord > 2);
                // putword modifier
                scode = pWordSink->PutWord(2, pWord->pwchGetText(), 2, cwchSrcPos);
                // putword noun
                scode = SUCCEEDED(scode) ? pWordSink->PutWord(cwchPutWord - 2,pWord->pwchGetText() + 2,
                                                        cwchPutWord - 2,cwchSrcPos + 2)
                                         : scode;
                cwchSrcPos += cwchWord;
                continue;
            } 
            
            if (pWord->fGetAttri(LADef_iwbNPhr3)) {
                assert(cwchPutWord > 3);
                // putword modifier
                scode = pWordSink->PutWord(3, pWord->pwchGetText(), 3, cwchSrcPos);
                // putword noun
                scode = SUCCEEDED(scode) ? pWordSink->PutWord(cwchPutWord - 3,pWord->pwchGetText() + 3,
                                                cwchPutWord - 3,cwchSrcPos + 3)
                                         : scode;
                cwchSrcPos += cwchWord;
                continue;
            } 
            
            if (wFtr = m_pEng->GetPhrFeature(pWord)) {
                WORD    wBit = 0x01;
                ULONG   cwTotal = 0, cwSubWord = 0;
                assert(cwchPutWord <= 16);

                if (m_fQuery) {
                    // StartAltPhrase
                    scode = pWordSink->StartAltPhrase();
                    // for ////// wFtr = 0x00AD
                    // = 0000 0000 1010 1101b
                    // is  1  0  1 1  0  1  0  1, 0000, 0000, ( bit0 --> bit15 )
                    //           
                    while (SUCCEEDED(scode) && cwTotal < cwchPutWord) {
                        cwSubWord = 0;
						/* Bug: compile bug
                        while (wBit == ((wFtr >> (cwTotal + cwSubWord)) & 0x01) ) {
                            cwSubWord++;
                        }
						*/
						// Bugfix
						if (wBit) {
							while (wFtr & (0x01 << (cwTotal + cwSubWord))) {
	                            cwSubWord++;
		                        assert(cwTotal + cwSubWord <= cwchPutWord);
							}
							wBit = 0;
						} else {
							while ( ! (wFtr & (0x01 << (cwTotal + cwSubWord)))) {
	                            cwSubWord++;
		                        assert(cwTotal + cwSubWord <= cwchPutWord);
							}
							wBit = 1;
						}
						// End Bugfix

//                        assert(cwTotal + cwSubWord <= cwchPutWord);
                        scode = pWordSink->PutWord( cwSubWord, 
                                            pWord->pwchGetText() + cwTotal,
                                            cwchPutWord, 
                                            cwchSrcPos );
                        cwTotal += cwSubWord;
//                        wBit = wBit == 0 ? 1 : 0;
                    }
                    scode = SUCCEEDED(scode) ? pWordSink->StartAltPhrase()
                                             : scode;
                    scode = SUCCEEDED(scode) ? pWordSink->PutWord( cwchPutWord, 
                                                    pWord->pwchGetText(),
                                                    cwchPutWord, 
                                                    cwchSrcPos )
                                             : scode;
                    scode = SUCCEEDED(scode) ? pWordSink->EndAltPhrase()
                                             : scode;
                } else {
                    while (SUCCEEDED(scode) && cwTotal < cwchPutWord) {
                        cwSubWord = 0;
						/* Bug: compile bug
                        while (wBit == ((wFtr >> (cwTotal + cwSubWord)) & 0x01) ) {
                            cwSubWord++;
                        }
						*/
						// Bugfix
						if (wBit) {
							while (wFtr & (0x01 << (cwTotal + cwSubWord))) {
	                            cwSubWord++;
		                        assert(cwTotal + cwSubWord <= cwchPutWord);
							}
							wBit = 0;
						} else {
							while ( ! (wFtr & (0x01 << (cwTotal + cwSubWord)))) {
	                            cwSubWord++;
		                        assert(cwTotal + cwSubWord <= cwchPutWord);
							}
							wBit = 1;
						}
						// End Bugfix

//                        assert(cwTotal + cwSubWord <= cwchPutWord);
                        scode = pWordSink->PutWord( cwSubWord, 
                                            pWord->pwchGetText() + cwTotal,
                                            cwSubWord, 
                                            cwchSrcPos + cwTotal);
                        cwTotal += cwSubWord;
//                        wBit = wBit == 0 ? 1 : 0;
                    }
                }
                cwchSrcPos += cwchWord;
                continue;
            }

            if (cwchPutWord > (DWORD)m_ulMaxTokenSize && pWord->fHasChild()) {
                // too large word node. break
                scode = PutAllChild(pWordSink, pWord, cwchSrcPos, cwchPutWord);
                cwchSrcPos += cwchWord;
                continue;
            }
           
            // PutAltWord if need
            if (pWord->fGetAttri(LADef_iwbAltWd1) &&
                pWord->fHasChild() ) {
                assert(pWord->pChildWord());
                pChild = pWord->pChildWord();
                scode = pWordSink->PutAltWord(pChild->cwchLen(),
                                      pChild->pwchGetText(),
                                      cwchPutWord, 
                                      cwchSrcPos );
            } else if (pWord->fGetAttri(LADef_iwbAltWd2) &&
                       pWord->fHasChild() ) {
                assert(pWord->pChildWord());
                assert(pWord->pChildWord()->pNextWord());
                pChild = pWord->pChildWord()->pNextWord();
                scode = pWordSink->PutAltWord(pChild->cwchLen(),
                                      pChild->pwchGetText(),
                                      cwchPutWord, 
                                      cwchSrcPos );
            } else if (pWord->fGetAttri(LADef_iwbAltWdc13) &&
                       pWord->fHasChild() ) {
                assert(pWord->pChildWord());
                pChild = pWord->pChildWord();
                assert(pChild->pNextWord());
                assert(pChild->pNextWord()->pNextWord());
                wcsncpy(m_pwchBuf, pChild->pwchGetText(),
                        pChild->cwchLen());
                wcsncpy(m_pwchBuf + pChild->cwchLen(),
                        pChild->pNextWord()->pNextWord()->pwchGetText(),
                        pChild->pNextWord()->pNextWord()->cwchLen());
                scode = pWordSink->PutAltWord(pChild->cwchLen() + pChild->pNextWord()->pNextWord()->cwchLen(),
                                      m_pwchBuf,
                                      cwchPutWord, 
                                      cwchSrcPos );
            } else {
                // Hack: word node breaked by WBEngine include tail space characters 
                // so we should get rid of this space characters
                if ( cwchPutWord > 1 ) {
                    pwchTemp = pWord->pwchGetText() + cwchPutWord - 1;
                    while ( iswspace(*pwchTemp) && cwchPutWord ) {
                        cwchPutWord --;
                        pwchTemp --;
                    }
                    if (cwchPutWord == 0) {
                        cwchSrcPos += cwchWord;
                        continue;
                    }
                }
            }
            // PutWord()
            scode = SUCCEEDED(scode) ? pWordSink->PutWord( cwchPutWord, 
                                                    pWord->pwchGetText(),
                                                    cwchPutWord, 
                                                    cwchSrcPos )
                                     : scode;
        }
        cwchSrcPos += cwchWord;
    } // end of for(; pWord; pWord = pWord->pNextWord()) 
    return scode;
}

// Put all word in m_pLink to IPhraseSink
SCODE CIWordBreaker::PutPhrase(IPhraseSink *pPhraseSink,
                DWORD& cwchSrcPos,
                DWORD cwchText,
                BOOL fEnd)
{
	CWord	*pWord;
	DWORD	cwchPutWord;
    SCODE   scode = S_OK;

    assert(m_pLink);
    assert(pPhraseSink);

    // Fill in the chunk list and callback Word if the chunk list full
    pWord = m_pLink->pGetHead();
    if (pWord == NULL) {
        assert(0);
        return scode;
    }
   
    for(; SUCCEEDED(scode) && pWord; pWord = pWord->pNextWord()) {
        cwchPutWord = pWord->cwchLen();
        if( pWord->fIsTail() && pWord != m_pLink->pGetHead()
            && m_pLink->cwchGetLength() >= cwchText
            && ! fEnd
            && cwchPutWord < cwchText ) {
            // the last word node breaked in this buffer maybe isn't a 
            // whole word, so keep this in buffer and refill the buffer
            // to get a whole word.
            return scode;
        }
        if (pWord->fGetAttri(LADef_iwbNPhr1)) {
            assert(cwchPutWord > 1);
            if (m_fQuery) {
                scode = pPhraseSink->PutPhrase(pWord->pwchGetText(),cwchPutWord);
            } else {
                scode = pPhraseSink->PutSmallPhrase(pWord->pwchGetText()+1,
                    cwchPutWord-1,
                    pWord->pwchGetText(),
                    1, 
                    0 );
            }
        } else if (pWord->fGetAttri(LADef_iwbNPhr2)) {
            assert(cwchPutWord > 2);
            if (m_fQuery) {
                scode = pPhraseSink->PutPhrase(pWord->pwchGetText(),cwchPutWord);
            } else {
                scode = pPhraseSink->PutSmallPhrase(pWord->pwchGetText()+2,
                    cwchPutWord-2,
                    pWord->pwchGetText(),
                    2, 
                    0 );
            }
        } else if (pWord->fGetAttri(LADef_iwbNPhr3)) {
            assert(cwchPutWord > 3);
            if (m_fQuery) {
                scode = pPhraseSink->PutPhrase(pWord->pwchGetText(),cwchPutWord);
            } else {
                scode = pPhraseSink->PutSmallPhrase(pWord->pwchGetText()+3,
                    cwchPutWord-3,
                    pWord->pwchGetText(),
                    3, 
                    0 );
            }
        } else {
        }
    }
    return scode;
}

// Put all word in m_pLink to both IWordBreaker and IPhraseSink
SCODE CIWordBreaker::PutBoth(IWordSink *pWordSink,
                             IPhraseSink *pPhraseSink,
                             DWORD& cwchSrcPos,
                             DWORD cwchText,
                             BOOL fEnd)
{
	CWord	*pWord, *pChild;
	DWORD	cwchWord, cwchPutWord, cwch;
    LPCWSTR pwchTemp; 
    SCODE   scode = S_OK;
    WORD    wFtr;
    BOOL    fPunct;

    assert(m_pLink);
    assert(pPhraseSink);
    assert(pWordSink);

    // Fill in the chunk list and callback Word if the chunk list full
    pWord = m_pLink->pGetHead();
    if (pWord == NULL) {
        assert(0);
        return scode;
    }
   
    for(; SUCCEEDED(scode) && pWord; pWord = pWord->pNextWord()) {
        cwchPutWord = cwchWord = pWord->cwchLen();
        if( pWord->fIsTail() && pWord != m_pLink->pGetHead()
            && m_pLink->cwchGetLength() >= cwchText
            && ! fEnd
            && cwchPutWord < cwchText ) {
            // the last word node breaked in this buffer maybe isn't a 
            // whole word, so keep this in buffer and refill the buffer
            // to get a whole word.
            return scode;
        }

        if (pWord->fGetAttri(LADef_punJu)) { // end of sentence
            scode = pWordSink->PutBreak( WORDREP_BREAK_EOS );
        } else if (pWord->fGetAttri(LADef_punPunct)) {
                // punctuation or space , don't PutWord
        } else {
            fPunct = iswctype(*(pWord->pwchGetText()), _SPACE | _PUNCT | _CONTROL);
            for (cwch = 1; fPunct && cwch < cwchPutWord; cwch++) {
                fPunct = iswctype(*(pWord->pwchGetText()+cwch), _SPACE | _PUNCT | _CONTROL);
            }
            if (fPunct) {
                // punctuation or space , don't PutWord
                cwchSrcPos += cwchWord;
                continue;
            }

            if (m_fQuery && pWord->fGetAttri(LADef_iwbAltPhr)) {
                assert(pWord->fHasChild());

                // StartAltPhrase
                scode = pWordSink->StartAltPhrase();
                scode = SUCCEEDED(scode) ? PutAllChild(pWordSink, pWord, cwchSrcPos, cwchPutWord)
                                         : scode;
                
                // StartAltPhrase
                scode = SUCCEEDED(scode) ? pWordSink->StartAltPhrase()
                                         : scode;
                scode = SUCCEEDED(scode) ? pWordSink->PutWord( cwchPutWord, 
                                                        pWord->pwchGetText(),
                                                        cwchPutWord, 
                                                        cwchSrcPos )
                                         : scode;
                scode = SUCCEEDED(scode) ? pWordSink->EndAltPhrase()
                                         : scode;
                cwchSrcPos += cwchWord;
                continue;
            }

            if (pWord->fGetAttri(LADef_iwbNPhr1)) {
                assert(cwchPutWord > 1);
                if (m_fQuery) {
                    scode = pPhraseSink->PutPhrase(pWord->pwchGetText(),cwchPutWord);
                } else {
                    scode = pPhraseSink->PutSmallPhrase(pWord->pwchGetText() + 1,
                                                cwchPutWord - 1,
                                                pWord->pwchGetText(),
                                                1, 
                                                0 );
                }
                // putword modifier
                scode = SUCCEEDED(scode) ? pWordSink->PutWord(1, pWord->pwchGetText(), 1, cwchSrcPos)
                                         : scode;
                // putword noun
                scode = SUCCEEDED(scode) ? pWordSink->PutWord(cwchPutWord - 1,pWord->pwchGetText() + 1,
                                                        cwchPutWord - 1,cwchSrcPos + 1)
                                         : scode;
                cwchSrcPos += cwchWord;
                continue;
            } 
            
            if (pWord->fGetAttri(LADef_iwbNPhr2)) {
                assert(cwchPutWord > 2);
                if (m_fQuery) {
                    scode = pPhraseSink->PutPhrase(pWord->pwchGetText(),cwchPutWord);
                } else {
                    scode = pPhraseSink->PutSmallPhrase(pWord->pwchGetText() + 2,
                                                cwchPutWord - 2,
                                                pWord->pwchGetText(),
                                                2, 
                                                0 );
                }
                // putword modifier
                scode = SUCCEEDED(scode) ? pWordSink->PutWord(2, pWord->pwchGetText(), 2, cwchSrcPos)
                                         : scode;
                // putword noun
                scode = SUCCEEDED(scode) ? pWordSink->PutWord(cwchPutWord - 2,pWord->pwchGetText() + 2,
                                                              cwchPutWord - 2,cwchSrcPos + 2)
                                         : scode;
                cwchSrcPos += cwchWord;
                continue;
            } 
            
            if (pWord->fGetAttri(LADef_iwbNPhr3)) {
                assert(cwchPutWord > 3);
                if (m_fQuery) {
                    scode = pPhraseSink->PutPhrase(pWord->pwchGetText(),cwchPutWord);
                } else {
                    scode = pPhraseSink->PutSmallPhrase(pWord->pwchGetText() + 3,
                                                cwchPutWord - 3,
                                                pWord->pwchGetText(),
                                                3, 
                                                0 );
                }
                // putword modifier
                scode = SUCCEEDED(scode) ? pWordSink->PutWord(3, pWord->pwchGetText(), 3, cwchSrcPos)
                                         : scode;
                // putword noun
                scode = SUCCEEDED(scode) ? pWordSink->PutWord(cwchPutWord - 3,pWord->pwchGetText() + 3,
                                                                cwchPutWord - 3,cwchSrcPos + 3)
                                         : scode;
                cwchSrcPos += cwchWord;
                continue;
            }
            
            if (wFtr = m_pEng->GetPhrFeature(pWord)) {
                WORD    wBit = 0x01;
                ULONG   cwTotal = 0, cwSubWord = 0;
                assert(cwchPutWord <= 16);

                if (m_fQuery) {
                    // StartAltPhrase
                    scode = pWordSink->StartAltPhrase();
                    // for ////// wFtr = 0x00AD
                    // = 0000 0000 1010 1101b
                    // is  1  0  1 1  0  1  0  1, 0000, 0000, ( bit0 --> bit15 )
                    //           
                    while (SUCCEEDED(scode) && cwTotal < cwchPutWord) {
                        cwSubWord = 0;
						/* Bug: compile bug
                        while (wBit == ((wFtr >> (cwTotal + cwSubWord)) & 0x01) ) {
                            cwSubWord++;
                        }
						*/
						// Bugfix
						if (wBit) {
							while (wFtr & (0x01 << (cwTotal + cwSubWord))) {
	                            cwSubWord++;
		                        assert(cwTotal + cwSubWord <= cwchPutWord);
							}
							wBit = 0;
						} else {
							while ( ! (wFtr & (0x01 << (cwTotal + cwSubWord)))) {
	                            cwSubWord++;
		                        assert(cwTotal + cwSubWord <= cwchPutWord);
							}
							wBit = 1;
						}
						// End Bugfix

//                        assert(cwTotal + cwSubWord <= cwchPutWord);
                        scode = pWordSink->PutWord( cwSubWord, 
                                            pWord->pwchGetText() + cwTotal,
                                            cwchPutWord, 
                                            cwchSrcPos );
                        cwTotal += cwSubWord;
//                        wBit = wBit == 0 ? 1 : 0;
                    }
                    scode = SUCCEEDED(scode) ? pWordSink->StartAltPhrase()
                                             : scode;
                    scode = SUCCEEDED(scode) ? pWordSink->PutWord( cwchPutWord, 
                                                        pWord->pwchGetText(),
                                                        cwchPutWord, 
                                                        cwchSrcPos )
                                         : scode;
                    scode = SUCCEEDED(scode) ? pWordSink->EndAltPhrase()
                                         : scode;
                } else {
                    while (SUCCEEDED(scode) && cwTotal < cwchPutWord) {
                        cwSubWord = 0;
						/* Bug: compile bug
                        while (wBit == ((wFtr >> (cwTotal + cwSubWord)) & 0x01) ) {
                            cwSubWord++;
                        }
						*/
						// Bugfix
						if (wBit) {
							while (wFtr & (0x01 << (cwTotal + cwSubWord))) {
	                            cwSubWord++;
		                        assert(cwTotal + cwSubWord <= cwchPutWord);
							}
							wBit = 0;
						} else {
							while ( ! (wFtr & (0x01 << (cwTotal + cwSubWord)))) {
	                            cwSubWord++;
		                        assert(cwTotal + cwSubWord <= cwchPutWord);
							}
							wBit = 1;
						}
						// End Bugfix

//                        assert(cwTotal + cwSubWord <= cwchPutWord);
                        scode = pWordSink->PutWord( cwSubWord, 
                                                    pWord->pwchGetText() + cwTotal,
                                                    cwSubWord, 
                                                    cwchSrcPos + cwTotal);
                        cwTotal += cwSubWord;
//                        wBit = wBit == 0 ? 1 : 0;
                    }
                }
                cwchSrcPos += cwchWord;
                continue;
            }

            if (cwchPutWord > (DWORD)m_ulMaxTokenSize && pWord->fHasChild()) {
                // too large word node. break
                scode = PutAllChild(pWordSink, pWord, cwchSrcPos, cwchPutWord);
                cwchSrcPos += cwchWord;
                continue;
            }

            // PutAltWord if need
            if (pWord->fGetAttri(LADef_iwbAltWd1) &&
                pWord->fHasChild() ) {

                assert(pWord->pChildWord());
                pChild = pWord->pChildWord();
                scode = pWordSink->PutAltWord(pChild->cwchLen(),
                                      pChild->pwchGetText(),
                                      cwchPutWord, 
                                      cwchSrcPos );
            } else if (pWord->fGetAttri(LADef_iwbAltWd2) &&
                       pWord->fHasChild() ) {
                assert(pWord->pChildWord());
                assert(pWord->pChildWord()->pNextWord());
                pChild = pWord->pChildWord()->pNextWord();
                scode = pWordSink->PutAltWord(pChild->cwchLen(),
                                      pChild->pwchGetText(),
                                      cwchPutWord, 
                                      cwchSrcPos );
            } else if (pWord->fGetAttri(LADef_iwbAltWdc13) &&
                       pWord->fHasChild() ) {
                assert(pWord->pChildWord());
                pChild = pWord->pChildWord();
                assert(pChild->pNextWord());
                assert(pChild->pNextWord()->pNextWord());
                wcsncpy(m_pwchBuf, pChild->pwchGetText(),
                        pChild->cwchLen());
                wcsncpy(m_pwchBuf + pChild->cwchLen(),
                        pChild->pNextWord()->pNextWord()->pwchGetText(),
                        pChild->pNextWord()->pNextWord()->cwchLen());
                scode = pWordSink->PutAltWord(pChild->cwchLen() + pChild->pNextWord()->pNextWord()->cwchLen(),
                                      m_pwchBuf,
                                      cwchPutWord, 
                                      cwchSrcPos );
            } else {
                // Hack: word node breaked by WBEngine include tail space characters 
                // so we should get rid of this space characters
                if ( cwchPutWord > 1 ) {
                    pwchTemp = pWord->pwchGetText() + cwchPutWord - 1;
                    while ( iswspace(*pwchTemp) && cwchPutWord ) {
                        cwchPutWord --;
                        pwchTemp --;
                    }
                    if (cwchPutWord == 0) {
                        cwchSrcPos += cwchWord;
                        continue;
                    }
                }
            }
            // PutWord()
            scode = SUCCEEDED(scode) ? pWordSink->PutWord( cwchPutWord, 
                                                    pWord->pwchGetText(),
                                                    cwchPutWord, 
                                                    cwchSrcPos )
                                     : scode;
        }
        cwchSrcPos += cwchWord;
    } // end of for(; pWord; pWord = pWord->pNextWord()) 
    return scode;
}

// PutWord() all of the pWord's child word 
SCODE CIWordBreaker::PutAllChild(IWordSink *pWordSink,
                                CWord* pWord,
                                ULONG cwchSrcPos,
                                ULONG cwchPutWord )
{
    assert(pWord);
    assert(pWord->fHasChild());

    SCODE scode = S_OK;

    CWord *pChild;

    pChild = pWord->pChildWord();
    while (SUCCEEDED(scode) && pChild) {
        if (pChild->fHasChild()) {
            scode = PutAllChild(pWordSink, pChild, cwchSrcPos, cwchPutWord);
        } else if (pChild->fGetAttri(LADef_iwbNPhr1)) {
            assert(cwchPutWord > 1);
            // putword modifier
            scode = pWordSink->PutWord(1, pChild->pwchGetText(), 1, cwchSrcPos);
            // putword noun
            scode = pWordSink->PutWord(pChild->cwchLen() - 1,
                pChild->pwchGetText() + 1,
                cwchPutWord,
                cwchSrcPos);
        } else if (pChild->fGetAttri(LADef_iwbNPhr2)) {
            assert(cwchPutWord > 2);
            // putword modifier
            scode = pWordSink->PutWord(2, pChild->pwchGetText(), 2, cwchSrcPos);
            // putword noun
            scode = pWordSink->PutWord(pChild->cwchLen() - 2,
                pChild->pwchGetText() + 2,
                cwchPutWord,
                cwchSrcPos);
        } else if (pChild->fGetAttri(LADef_iwbNPhr3)) {
            assert(cwchPutWord > 3);
            // putword modifier
            scode = pWordSink->PutWord(3, pChild->pwchGetText(), 3, cwchSrcPos);
            // putword noun
            scode = pWordSink->PutWord(pChild->cwchLen() - 3,
                pChild->pwchGetText() + 3,
                cwchPutWord,
                cwchSrcPos);
        } else {
            scode = pWordSink->PutWord(pChild->cwchLen(), pChild->pwchGetText(),
                cwchPutWord, cwchSrcPos );
        }
        pChild = pChild->pNextWord();
    }
    return scode;
}


//	Load the lexicon and charfreq resource into memory
BOOL CIWordBreaker::fOpenLexicon(void)
{
    HRSRC   hRSRC; 
    HGLOBAL hLexRes;


    if ( (hRSRC = FindResource(v_hInst, _T("MainDic"), _T("DIC"))) != NULL &&
         (hLexRes = LoadResource(v_hInst, hRSRC)) != NULL &&
         (m_pbLex = (BYTE*)LockResource(hLexRes)) != NULL) {

        return TRUE;
    }

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\lexicon.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Module:     LEXICON
Prefix:     Lex
Purpose:    Implementation of the CLexicon object. CLexicon is used to manage 
            the SC Lexicon for word breaker and proofreading process.
Notes:
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    5/28/97
============================================================================*/
#include "myafx.h"
#include <limits.h>

#include "lexicon.h"
#include "lexdef.h"
#include "lexprop.h"    // for Dynamic version checking!

/*============================================================================
Implementation of Public member functions
============================================================================*/

// Constructor
CLexicon::CLexicon()
{
    m_ciIndex   = 0;
    m_rgIndex   = NULL;
    m_pwLex     = NULL;
    m_pbProp    = NULL;
    m_pbFtr     = NULL;
    m_cbProp    = 0;
    m_cbFtr     = 0;
}
    
//  Destructor
CLexicon::~CLexicon()
{
}


/*============================================================================
CLexicon::fInit()
    load the LexHeader and calculate the offset of index and lex section
Returns:
    FALSE if invalid LexHeader 
============================================================================*/
BOOL CLexicon::fOpen(BYTE* pbLexHead)
{
    assert(m_ciIndex == 0); // Catch duplicated initialization
    assert(pbLexHead);      // Catch invalid mapping address

    CRTLexHeader* pheader = (CRTLexHeader*)pbLexHead;
    // Validate the lexicon version
    if (pheader->m_dwVersion != LexDef_Version) {
        assert(0);
        return FALSE;
    }
    m_dwLexVersion = pheader->m_dwVersion;

    
    // Validate the lex header setting.
    // Only run in debug build because version checking in release build is enough
    assert(pheader->m_ofbIndex == sizeof(CRTLexHeader));
    assert(pheader->m_ofbText > pheader->m_ofbIndex);
    assert(((pheader->m_ofbText - pheader->m_ofbIndex) % sizeof(CRTLexIndex)) == 0);
    assert(pheader->m_ofbProp > pheader->m_ofbText);
    assert(pheader->m_ofbFeature > pheader->m_ofbProp);
    assert(pheader->m_cbLexSize >= pheader->m_ofbFeature);
    assert(((pheader->m_ofbText - pheader->m_ofbIndex) / sizeof(CRTLexIndex)) == LEX_INDEX_COUNT);

    m_ciIndex   = (USHORT)((pheader->m_ofbText - pheader->m_ofbIndex) / sizeof(CRTLexIndex));
    m_rgIndex   = (CRTLexIndex*)(pbLexHead + pheader->m_ofbIndex);
    m_pwLex     = (WORD*)(pbLexHead + pheader->m_ofbText);
    m_pbProp    = (BYTE*)(pbLexHead + pheader->m_ofbProp);
    m_pbFtr     = (BYTE*)(pbLexHead + pheader->m_ofbFeature);
    // Because I expose the offset of the lex property as a handle to the client,
    // I have to perform runtime address checking to protect from invalid handle
    // To store the size of feature text section is for this checking
    m_cbProp    = pheader->m_ofbFeature - pheader->m_ofbProp;
    m_cbFtr     = pheader->m_cbLexSize - pheader->m_ofbFeature;

#ifdef DEBUG
    // Verify the lexicon in debug build. It will take a long init time!!!
    if (!fVerifyLexicon(pheader->m_cbLexSize)) {
        assert(0);
        return FALSE;
    }
#endif // DEBUG
    
    return TRUE;
}


/*============================================================================
CLexicon::Close()
    clear current lexicon setting, file closed by LangRes
============================================================================*/
void CLexicon::Close(void)
{
    m_ciIndex   = 0;
    m_rgIndex   = NULL;
    m_pwLex     = NULL;
    m_pbProp    = NULL;
    m_pbFtr     = NULL;
    m_cbProp    = 0;
    m_cbFtr     = 0;
}
    
#pragma optimize("t", on)
/*============================================================================
CLexicon::fGetCharInfo(): 
    get the word info of the given single char word
============================================================================*/
BOOL CLexicon::fGetCharInfo(const WCHAR wChar, CWordInfo* pwinfo)
{
    assert(m_ciIndex != 0);
    assert(pwinfo);

    USHORT idx = wCharToIndex(wChar);
    if (idx >= m_ciIndex) {
        return FALSE;
    }

    SetWordInfo(m_rgIndex[idx].m_ofbProp, pwinfo);
    return TRUE;
}

// Hack:  define a static const attribute of LADef_genDBForeign
static const USHORT LA_DBForeign = LADef_genDBForeign;
        
/*============================================================================
CLexicon::cwchMaxMatch(): 
    lexicon based max match algorithm
Returns:
    length of the matched string
Notes:
    chars in pwchStart must be Unicode.
    English words 
============================================================================*/
USHORT CLexicon::cwchMaxMatch(
                     LPCWSTR pwchStart, 
                     USHORT cwchLen,
                     CWordInfo* pwinfo )
{
    WORD    wC1Seat;        // Position of the first char in the index array
    WORD    wcChar;         // WORD encoded of char
    
    assert(m_ciIndex != 0); // Catch uninitialized call
    
    assert(pwchStart && cwchLen); // Catch invalid input buffer
    assert(pwinfo); // catch NULL pointer
    
    if (cwchLen == 0) {
        assert(0);
        return (USHORT)0;
    }
    
    // Locate the first character in the index
    wC1Seat = wCharToIndex(*pwchStart);
    
    // Hack: for foreign character, fill pwinfo manually,
    //       and point to a LADef_genDBForeign attribute
    if (wC1Seat == LEX_IDX_OFST_OTHER) {
        pwinfo->m_dwWordID = 0;
        pwinfo->m_ciAttri = 1;
        pwinfo->m_rgAttri = const_cast<USHORT*>(&LA_DBForeign);
        pwinfo->m_hLex = m_rgIndex[wC1Seat].m_ofbProp;
        return (USHORT)1;
    }

    if (cwchLen == 1 || 
        (m_rgIndex[wC1Seat].m_ofwLex & LEX_INDEX_NOLEX) ||
        ((wcChar = wchEncoding( *(pwchStart+1) )) == 0) ) {
        SetWordInfo(m_rgIndex[wC1Seat].m_ofbProp, pwinfo);
        return (USHORT)1;
    }
    
    LPCWSTR pwchEnd;
    LPCWSTR pwchSrc;
    DWORD   dwLexStart;     // Start of the lex range
    DWORD   dwLexEnd;       // end of the lex range
    DWORD   dwLexPos;       // position of the entry head in the lexicon

    DWORD   dwlow;
    DWORD   dwmid;
    DWORD   dwhigh;
    DWORD   cwLexRec = sizeof(CRTLexRec) / sizeof(WORD);

    USHORT  cwcMatchLen;
    USHORT  cwcMaxMatch;
        
    assert(wcChar);
    // prepare to match more characters
    pwchSrc = pwchStart + 1;
    pwchEnd = pwchStart + cwchLen;
    // Get the lex range
    dwLexStart = m_rgIndex[wC1Seat].m_ofwLex;
    dwLexEnd = m_rgIndex[wC1Seat+1].m_ofwLex & (~LEX_INDEX_NOLEX);
    assert((dwLexStart + cwLexRec) < dwLexEnd );   // at least one char
    
    /***************************************************
    *   Binary search for any C2 match in the lexicon
    ****************************************************/
    dwlow = dwLexStart;
    dwhigh = dwLexEnd;
    dwLexPos = UINT_MAX;    // as a flag to identify whether C2 matched
    while (dwlow < dwhigh) {
        dwmid = (dwlow + dwhigh) / 2;
        while (m_pwLex[dwmid] & LEX_MSBIT) {
            dwmid--;    // search head of the word
        }
        while ( !(m_pwLex[dwmid] & LEX_MSBIT) ) {
            dwmid++;    // dwmid fall in word mark fields
        }
        
        if (wcChar > m_pwLex[dwmid]) {
            while ( (dwmid < dwLexEnd) && (m_pwLex[dwmid] & LEX_MSBIT) ) {
                dwmid++;    // search head of next word
            }
            dwlow = dwmid;
            continue;   
        }

        if (wcChar < m_pwLex[dwmid]) {   
            dwhigh = dwmid - cwLexRec; // no overflow here !
            continue;   
        }

        if (wcChar == m_pwLex[dwmid]) {  
            dwLexPos = dwmid - cwLexRec;
            break;      
        }
    }

    if (dwLexPos == UINT_MAX) {
        // No C2 match
        SetWordInfo(m_rgIndex[wC1Seat].m_ofbProp, pwinfo);
        return (USHORT)1;
    }
    
    /***************************************
    *   Try to match the max word from C2
    ****************************************/
    dwlow = dwLexPos;
    dwhigh = dwLexPos;  // store the C2 match position for backward search
    dwLexPos = UINT_MAX;    // use the special value as the flag of match
    cwcMaxMatch = 0;
    
    // search forward first
    while (TRUE) {
        // Current direction test
        dwmid = dwlow + cwLexRec;
        pwchSrc = pwchStart + 1;

        while (TRUE) {
            wcChar = wchEncoding( *pwchSrc );
            if (wcChar == m_pwLex[dwmid]) {  
                dwmid ++;   
                if( !(m_pwLex[dwmid] & LEX_MSBIT)  || dwmid == dwLexEnd) { // Full match
                    cwcMatchLen = (BYTE)(dwmid - dwlow - cwLexRec + 1);
                    dwLexPos = dwlow;
                    break;  
                }
                pwchSrc ++;
                if (pwchSrc < pwchEnd) {
                    continue;
                }
            }
            break;  
        }

        if ( wcChar > m_pwLex[dwmid] &&          // Optimization!!! current lex too small 
            cwcMaxMatch <= (dwmid - dwlow) &&   // match parts in NOT shorter and shorter
            pwchSrc < pwchEnd ) {      // of course there are chars left in the string to be matched

            cwcMaxMatch = (BYTE)(dwmid - dwlow);
            // step forward to next lex entry
            while ((dwmid < dwLexEnd) && (m_pwLex[dwmid] & LEX_MSBIT)) {
                dwmid++;
            }
            dwlow = dwmid;
        } else {
            break;
        }
    }

    // search backward if necessary
    while (dwLexPos == UINT_MAX && dwhigh > dwLexStart) { // control no overflow here
        while (m_pwLex[dwhigh-1] & LEX_MSBIT) {
            dwhigh--; // back to previous word head
        }
        dwmid = dwhigh;
        pwchSrc = pwchStart + 1;
        wcChar = wchEncoding( *pwchSrc );
        
        while (wcChar == m_pwLex[dwmid] && pwchSrc < pwchEnd) {
            dwmid++;
            if ( !(m_pwLex[dwmid] & LEX_MSBIT) ) {
                cwcMatchLen = (BYTE)(dwmid - dwhigh + 1);
                dwLexPos = dwhigh - cwLexRec;
                break;
            }
            pwchSrc ++;
            wcChar = wchEncoding( *pwchSrc );
        }
        if (dwmid == dwhigh)  {// C2 can not match any more
            break;
        }
        dwhigh -= cwLexRec;
    }
    
    // if no multi-char word is matched
    if ( dwLexPos == UINT_MAX ) {
        SetWordInfo(m_rgIndex[wC1Seat].m_ofbProp, pwinfo);
        return (USHORT)1;
    } else {
        // fill multi-char wrd info structure
        SetWordInfo(dwWordIDDecoding(((CRTLexRec*)(&m_pwLex[dwLexPos]))->m_ofbProp), pwinfo);
        return (cwcMatchLen);
    }
}


/*============================================================================
CLexicon::pwchGetFeature(): 
    retrieve the specific feature for given lex handle
Returns:
    the feature buffer and length of the feature if found
    NULL if the feature was not found or invalid lex handle
Notes:
    Because lexicon object does not know how to explain the feature buffer,
    to parse the feature buffer is the client's work.
============================================================================*/
LPWSTR CLexicon::pwchGetFeature(
                    const DWORD hLex, 
                    const USHORT iFtrID, 
                    USHORT* pcwchFtr) const
{
    *pcwchFtr = 0;
    if ((hLex + sizeof(CRTLexProp)) >= m_cbProp) {
        assert(0);
        return NULL;
    }
    CRTLexProp* pProp = (CRTLexProp*)(m_pbProp + hLex);
    if ( pProp->m_ciFeature == 0 || 
         (hLex + sizeof(CRTLexProp) + pProp->m_ciAttri * sizeof(USHORT) + 
         pProp->m_ciFeature * sizeof(CRTLexFeature)) >= m_cbProp) {
        assert(pProp->m_ciFeature == 0);
        return NULL;
    }
    CRTLexFeature* pFtr=(CRTLexFeature*)((USHORT*)(pProp +1)+ pProp->m_ciAttri);
    int lo = 0, mi, hi = pProp->m_ciFeature - 1;
    LPWSTR pwchFtr = NULL;
    if (pProp->m_ciFeature <= 10) { // Using linear search for small feature array
        while (lo <= hi && pFtr[lo].m_wFID < iFtrID) {
            lo++;
        }
        if (pFtr[lo].m_wFID == iFtrID && 
            (pFtr[lo].m_ofbFSet + pFtr[lo].m_cwchLen * sizeof(WCHAR)) <= m_cbFtr){
            pwchFtr = (LPWSTR)(m_pbFtr + pFtr[lo].m_ofbFSet);
            *pcwchFtr = pFtr[lo].m_cwchLen;
//            assert(pwchFtr[*pcwchFtr - 1] == L'\0');
        } else {
            assert(pFtr[lo].m_wFID > iFtrID);
        }
    } else { // Using binary search for large feature array
        while (lo <= hi) {
            mi = (lo + hi) / 2;
            if (iFtrID < pFtr[mi].m_wFID) {
                hi = mi - 1;
            } else if(iFtrID > pFtr[mi].m_wFID) {
                lo = mi + 1;
            } else { // match!!!
                if ((pFtr[mi].m_ofbFSet + pFtr[mi].m_cwchLen * sizeof(WCHAR)) 
                    <= m_cbFtr) {
                    pwchFtr = (LPWSTR)(m_pbFtr + pFtr[mi].m_ofbFSet);
                    *pcwchFtr = pFtr[mi].m_cwchLen;
                    assert(pwchFtr[*pcwchFtr - 1] == L'\0');
                    break;
                } else {
                    assert(0);
                }
            }
        } // end of while (lo <= hi)
    }
    return pwchFtr;
}


/*============================================================================
CLexicon::fIsCharFeature():
    Test whether the given SC character is included in a given feature
============================================================================*/
BOOL CLexicon::fIsCharFeature(
                  const DWORD  hLex, 
                  const USHORT iFtrID, 
                  const WCHAR  wChar) const
{
    LPWSTR  pwchFtr;
    USHORT  cwchFtr;
    if (NULL == (pwchFtr = pwchGetFeature(hLex, iFtrID, &cwchFtr))) {
        return FALSE;
    }
    for (USHORT ilen = 0; ilen < cwchFtr; ) {
        for (USHORT iwch = ilen; iwch < cwchFtr && pwchFtr[iwch]; iwch++) {
            ;
        }
        if ((iwch - ilen) == 1 && pwchFtr[ilen] == wChar){
            return TRUE;
        }
        ilen = iwch + 1;
    }
    return FALSE;
}


/*============================================================================
CLexicon::fIsWordFeature():
    Test whether the given buffer is included in a given feature
============================================================================*/
BOOL CLexicon::fIsWordFeature(
                  const DWORD hLex, 
                  const USHORT iFtrID, 
                  LPCWSTR pwchWord, 
                  const USHORT cwchWord) const
{
    assert(pwchWord);
    assert(cwchWord);

    LPWSTR  pwchFtr;
    USHORT  cwchFtr;

    if(NULL == (pwchFtr = pwchGetFeature(hLex, iFtrID, &cwchFtr))) {
        return FALSE;
    }
    // Only linear search here, assume no very large feature here
    assert(cwchFtr < 256); // less than 100 feature words
    for (USHORT ilen = 0; ilen < cwchFtr; ) {
        for (USHORT iwch = ilen; iwch < cwchFtr && pwchFtr[iwch]; iwch++) {
            ;
        }
        if (iwch - ilen == cwchWord) {
            for (iwch = 0; ; iwch++) {
                if (iwch == cwchWord) {
                    return TRUE;
                }
                if (pwchFtr[ilen + iwch] - pwchWord[iwch]) {
                    break;
                }
            }
            iwch = cwchWord;
        }
        ilen = iwch + 1;
    }
    return FALSE;
}

/*============================================================================
Implementation of Private member functions
============================================================================*/

/*============================================================================
CLexicon::SetWordInfo():
    Fill the CWordInfo structure by the lex properties
============================================================================*/
inline void CLexicon::SetWordInfo(DWORD ofbProp, CWordInfo* pwinfo) const
{
    assert((ofbProp + sizeof(CRTLexProp)) < m_cbProp);

    CRTLexProp* pProp = (CRTLexProp*)(m_pbProp + ofbProp);
    pwinfo->m_dwWordID = pProp->m_iWordID;
    pwinfo->m_ciAttri = pProp->m_ciAttri;
    pwinfo->m_rgAttri = NULL;
    if (pProp->m_ciAttri > 0) {
        assert((BYTE*)((USHORT*)(pProp + 1) + pProp->m_ciAttri) <= (m_pbProp + m_cbProp)); 
        pwinfo->m_rgAttri = (USHORT*)(pProp + 1);
    }
    pwinfo->m_hLex = ofbProp;
}


/*============================================================================
CLexicon::wCharToIndex():
    Calculate the index value from a Chinese char
============================================================================*/
inline WORD CLexicon::wCharToIndex(WCHAR wChar)
{ 
    if (wChar >= LEX_CJK_FIRST && wChar <= LEX_CJK_LAST) {
        // return LEX_IDX_OFST_CJK + (wChar - LEX_CJK_FIRST);
        // tuning speed
        return  wChar - (LEX_CJK_FIRST - LEX_IDX_OFST_CJK);

    } else if (wChar >= LEX_LATIN_FIRST && wChar <= LEX_LATIN_LAST) {
        // return LEX_IDX_OFST_LATIN + (wChar - LEX_LATIN_FIRST);
        return  wChar - (LEX_LATIN_FIRST - LEX_IDX_OFST_LATIN);

    } else if (wChar >= LEX_GENPUNC_FIRST && wChar <= LEX_GENPUNC_LAST) {
        // return LEX_IDX_OFST_GENPUNC + (wChar - LEX_GENPUNC_FIRST);
        return  wChar - (LEX_GENPUNC_FIRST - LEX_IDX_OFST_GENPUNC);

    } else if (wChar >= LEX_NUMFORMS_FIRST && wChar <= LEX_NUMFORMS_LAST) {
        // return LEX_IDX_OFST_NUMFORMS + (wChar - LEX_NUMFORMS_FIRST);
        return  wChar - (LEX_NUMFORMS_FIRST - LEX_IDX_OFST_NUMFORMS);

    } else if (wChar >= LEX_ENCLOSED_FIRST && wChar <= LEX_ENCLOSED_LAST) {
        // return LEX_IDX_OFST_ENCLOSED + (wChar - LEX_ENCLOSED_FIRST);
        return wChar - (LEX_ENCLOSED_FIRST - LEX_IDX_OFST_ENCLOSED);

    } else if (wChar >= LEX_CJKPUNC_FIRST && wChar <= LEX_CJKPUNC_LAST) {
        // return LEX_IDX_OFST_CJKPUNC + (wChar - LEX_CJKPUNC_FIRST);
        return  wChar - (LEX_CJKPUNC_FIRST - LEX_IDX_OFST_CJKPUNC);

    } else if (wChar >= LEX_FORMS_FIRST && wChar <= LEX_FORMS_LAST) {
        // return LEX_IDX_OFST_FORMS + (wChar - LEX_FORMS_FIRST);
        return  wChar - (LEX_FORMS_FIRST - LEX_IDX_OFST_FORMS);

    } else {
        return LEX_IDX_OFST_OTHER;
    }
}

    
/*============================================================================
CLexicon::dwWordIDDecoding():
    Decoding the Encoded WordID from the lexicon record
============================================================================*/
inline DWORD CLexicon::dwWordIDDecoding(DWORD dwStore)
{ 
    return ((dwStore & 0x7FFF0000) >> 1) + (dwStore & 0x7FFF); 
}

// encoding the Unicode char wChar
inline WCHAR CLexicon::wchEncoding(WCHAR wChar)
{
    if (wChar >= LEX_CJK_FIRST && wChar <= LEX_CJK_LAST) {
        return wChar + (LEX_CJK_MAGIC | ((WCHAR)LexDef_Version & 0x00ff));

    } else if (wChar >= LEX_LATIN_FIRST && wChar <= LEX_LATIN_LAST) {
        // return LEX_LATIN_MAGIC + (wChar - LEX_LATIN_FIRST);
        return wChar + (LEX_LATIN_MAGIC - LEX_LATIN_FIRST);

    } else if (wChar >= LEX_GENPUNC_FIRST && wChar <= LEX_GENPUNC_LAST) {
        // return LEX_GENPUNC_MAGIC + (wChar - LEX_GENPUNC_FIRST);
        return wChar + (LEX_GENPUNC_MAGIC - LEX_GENPUNC_FIRST);

    } else if (wChar >= LEX_NUMFORMS_FIRST && wChar <= LEX_NUMFORMS_LAST) {
        // return LEX_NUMFORMS_MAGIC + (wChar - LEX_NUMFORMS_FIRST);
        return wChar + (LEX_NUMFORMS_MAGIC - LEX_NUMFORMS_FIRST);

    } else if (wChar >= LEX_ENCLOSED_FIRST && wChar <= LEX_ENCLOSED_LAST) {
        // return LEX_ENCLOSED_MAGIC + (wChar - LEX_ENCLOSED_FIRST);
        return wChar + (LEX_ENCLOSED_MAGIC - LEX_ENCLOSED_FIRST);

    } else if (wChar >= LEX_CJKPUNC_FIRST && wChar <= LEX_CJKPUNC_LAST) {
        // return LEX_CJKPUNC_MAGIC + (wChar - LEX_CJKPUNC_FIRST);
        return wChar + (LEX_CJKPUNC_MAGIC - LEX_CJKPUNC_FIRST);

    } else if (wChar >= LEX_FORMS_FIRST && wChar <= LEX_FORMS_LAST) {
        // return LEX_FORMS_MAGIC + (wChar - LEX_FORMS_FIRST);
        return wChar - (LEX_FORMS_FIRST - LEX_FORMS_MAGIC);

    } else {
//        assert(0);
        return 0;
    }
}

// decoding the Unicode char from wEncoded
WCHAR CLexicon::wchDecodeing(WCHAR wEncoded)
{
    assert(wEncoded > LEX_LATIN_MAGIC);
    if (wEncoded >= (LEX_CJK_FIRST + (LEX_CJK_MAGIC | (LexDef_Version & 0x00ff))) &&
        wEncoded <= (LEX_CJK_FIRST + (LEX_CJK_MAGIC | (LexDef_Version & 0x00ff))+LEX_CJK_TOTAL)) {
        return wEncoded - (LEX_CJK_MAGIC | ((WCHAR)LexDef_Version & 0x00ff));

    } else if (wEncoded >= LEX_FORMS_MAGIC && wEncoded < LEX_FORMS_MAGIC + LEX_FORMS_TOTAL) {
        // return wEncoded - LEX_FORMS_MAGIC + LEX_FORMS_FIRST;
        return wEncoded + (LEX_FORMS_FIRST - LEX_FORMS_MAGIC);

    } else if (wEncoded < LEX_LATIN_MAGIC) {
        assert(0);
        return 0;

    } else if (wEncoded < LEX_GENPUNC_MAGIC) {
        // return wEncoded - LEX_LATIN_MAGIC + LEX_LATIN_FIRST;
        return wEncoded - (LEX_LATIN_MAGIC - LEX_LATIN_FIRST);

    } else if (wEncoded < LEX_NUMFORMS_MAGIC) {
        // return wEncoded - LEX_GENPUNC_MAGIC + LEX_GENPUNC_FIRST;
        return wEncoded - (LEX_GENPUNC_MAGIC - LEX_GENPUNC_FIRST);

    } else if (wEncoded < LEX_ENCLOSED_MAGIC) {
        // return wEncoded - LEX_NUMFORMS_MAGIC + LEX_NUMFORMS_FIRST;
        return wEncoded - (LEX_NUMFORMS_MAGIC - LEX_NUMFORMS_FIRST);

    } else if (wEncoded < LEX_CJKPUNC_MAGIC) {
        // return wEncoded - LEX_ENCLOSED_MAGIC + LEX_ENCLOSED_FIRST;
        return wEncoded - (LEX_ENCLOSED_MAGIC - LEX_ENCLOSED_FIRST);

    } else if (wEncoded < (LEX_CJKPUNC_MAGIC + LEX_CJKPUNC_TOTAL)) {
        // return wEncoded - LEX_CJKPUNC_MAGIC + LEX_CJKPUNC_FIRST;
        return wEncoded - (LEX_CJKPUNC_MAGIC - LEX_CJKPUNC_FIRST);

    } else {
        assert(0);
        return 0;
    }
}

#pragma optimize( "", on )

/*******************************************************************************************
*   Implementation of Private debugging member functions
*******************************************************************************************/
#ifdef DEBUG
/*============================================================================
CLexicon::fVerifyLexicon():
    Verify the lexicon format for each word.
============================================================================*/
BOOL CLexicon::fVerifyLexicon(DWORD cbSize)
{
    int     iret = FALSE;
    DWORD   idx;
    WCHAR*   pwTail;
    WCHAR*   pw1;
    WCHAR*   pw2;
    USHORT  cw1, cw2;
    CRTLexRec*  pLex;
    CRTLexProp* pProp;
    CRTLexFeature* pFtr;
    USHORT  ci;
    DWORD   ofbFtr;
    BOOL    fOK;

    // Initialize the prop offset array
    m_rgofbProp = NULL;
    m_ciProp = m_ciMaxProp = 0;
    // Verify index and lex section
    assert((m_rgIndex[0].m_ofwLex & LEX_OFFSET_MASK) == 0);

    for (idx = 0; idx < LEX_INDEX_COUNT-1; idx++) {
        if (m_rgIndex[idx].m_ofbProp != 0) {
            if (m_ciProp == m_ciMaxProp && !fExpandProp()) { 
                assert(0); 
                goto gotoExit; 
            }
            m_rgofbProp[m_ciProp++] = m_rgIndex[idx].m_ofbProp;
        }
        if (m_rgIndex[idx].m_ofwLex & LEX_INDEX_NOLEX) { // no multi-char lex!
            assert( (m_rgIndex[idx].m_ofwLex & LEX_OFFSET_MASK) == 
                     (m_rgIndex[idx + 1].m_ofwLex & LEX_OFFSET_MASK) ); // error lex offset!
            continue;
        }
        // Has multi-char lex!
        assert( (m_rgIndex[idx].m_ofwLex+ sizeof(CRTLexRec)/sizeof(WORD)+1)<=
                 (m_rgIndex[idx + 1].m_ofwLex & LEX_OFFSET_MASK) ); // error lex offset!
        pwTail = m_pwLex + (m_rgIndex[idx + 1].m_ofwLex & LEX_OFFSET_MASK);
        pLex = (CRTLexRec*)(m_pwLex + m_rgIndex[idx].m_ofwLex);
        if (pLex->m_ofbProp != 0) {
            if (m_ciProp == m_ciMaxProp && !fExpandProp()) {
                assert(0);
                goto gotoExit;
            }
            m_rgofbProp[m_ciProp++] = dwWordIDDecoding(pLex->m_ofbProp);
        }
        pw1 = (WORD*)(pLex + 1);
        for (cw1 = 0; (pw1 + cw1) < pwTail && (pw1[cw1] & LEX_MSBIT); cw1++) {
            ;   // to the next word
        }
        while ((pw1 + cw1) < pwTail) {
            assert((pw1 + cw1 + sizeof(CRTLexRec)/sizeof(WORD) +1)<=pwTail); // 0 size lex
            pLex = (CRTLexRec*)(pw1 + cw1);
            if (pLex->m_ofbProp != 0) {
                if (m_ciProp == m_ciMaxProp && !fExpandProp()) {
                    assert(0);
                    goto gotoExit;
                }
                m_rgofbProp[m_ciProp++] = dwWordIDDecoding(pLex->m_ofbProp);
            }
            pw2 = (WORD*)(pLex + 1); fOK = FALSE;
            for (cw2 = 0; (pw2 + cw2) < pwTail && (pw2[cw2] & LEX_MSBIT); cw2++) {
                if (fOK == FALSE && (cw2 >= cw1 || pw1[cw2] < pw2[cw2])) {
                    fOK = TRUE;
                }
            }
            assert(fOK); // error lex order
            pw1 = pw2; cw1 = cw2;
        }
        assert(pw1 + cw1 == pwTail); // error offset in index
    } // end of index loop
            
    // Finish checking index and lex section, m_rgofbProp filled with all prop offsets
    if (m_ciProp == m_ciMaxProp && !fExpandProp()) {
        assert(0);
        goto gotoExit;
    }
    m_rgofbProp[m_ciProp] = m_cbProp; // fill the end of array
    ofbFtr = 0;
    for (idx = 0; idx < m_ciProp; idx++) {
        assert(m_rgofbProp[idx] + sizeof(CRTLexProp) <= m_cbProp &&
                m_rgofbProp[idx + 1] <= m_cbProp); // offset over boundary!!!
        pProp = (CRTLexProp*)(m_pbProp + m_rgofbProp[idx]);
        assert((m_rgofbProp[idx] + sizeof(CRTLexProp) + 
                pProp->m_ciAttri * sizeof(USHORT) +
                pProp->m_ciFeature * sizeof(CRTLexFeature)) 
                == m_rgofbProp[idx + 1]); // error prop offset
        // verify the attributes order
        pw1 = (USHORT*)(pProp + 1); 
        for (cw1 = 1; cw1 < pProp->m_ciAttri; cw1++) { // Validate the attributes order
            assert(pw1[cw1] > pw1[cw1 - 1]); 
        }
        if (pProp->m_ciAttri > 0) { // Validate the range of attribute ID value 
            assert(pw1[pProp->m_ciAttri - 1] <= LADef_MaxID);
        }
        // verify the feature order
        if (pProp->m_ciFeature > 0) {
            pFtr = (CRTLexFeature*)((USHORT*)(pProp + 1) + pProp->m_ciAttri);
            assert(pFtr->m_ofbFSet == ofbFtr); // no leak bytes in the feature section
            assert(pFtr->m_cwchLen > 0); // zero feature set
            ofbFtr += pFtr->m_cwchLen * sizeof(WCHAR);
            assert(ofbFtr <= m_cbFtr); // feature offset over boundary
            cw1 = pFtr->m_wFID;
            for (ci = 1, pFtr++; ci < pProp->m_ciFeature; ci++, pFtr++) {
                assert(pFtr->m_ofbFSet == ofbFtr); // no leak bytes in the feature section
                assert(pFtr->m_cwchLen > 0); // zero feature set
                ofbFtr += pFtr->m_cwchLen * sizeof(WCHAR);
                assert(ofbFtr <= m_cbFtr); // feature offset over boundary
                cw2 = pFtr->m_wFID;
                assert(cw2 > cw1); // error feature set order
                cw1 = cw2;
            }
            assert(cw1 <= LFDef_MaxID); // Validate the range of feature ID value
        }
    } // end of property loop
    assert(ofbFtr == m_cbFtr);

    iret = TRUE;
gotoExit:
    if (m_rgofbProp != NULL) {
        delete [] m_rgofbProp;
    }
    return iret;
}


//  Expand prop offset array
BOOL CLexicon::fExpandProp(void)
{
    DWORD* pNew = new DWORD[m_ciMaxProp + 20000];
    if (pNew == NULL) {
        return FALSE;
    }
    if (m_rgofbProp != NULL) {
        memcpy(pNew, m_rgofbProp, m_ciProp * sizeof(DWORD));
        delete [] m_rgofbProp;
    }
    m_rgofbProp = pNew;
    m_ciMaxProp += 20000;
    return TRUE;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\lexicon.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Module:     LEXICON
Prefix:     Lex
Purpose:    Declare the CLexicon object. CLexicon is used to manage the SC Lexicon
            for word breaker and proofreading process.
Notes:
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    5/28/97
============================================================================*/
#ifndef _LEXICON_H_
#define _LEXICON_H_

// Foreward declaration of structures and classes
struct CRTLexIndex;
struct CRTLexRec;
struct CRTLexProp;

/*============================================================================
Struct WORDINFO:
Desc:   Word information data structure, transfer word info from lexicon to it's user
Prefix: winfo
============================================================================*/
struct CWordInfo
{
    friend class CLexicon;

    public:        
        inline DWORD GetWordID() const { return m_dwWordID; };
        inline DWORD GetLexHandle( ) const { return m_hLex; };
        inline USHORT AttriNum() const { return m_ciAttri; };
        inline USHORT GetAttri( USHORT iAttri ) const { 
            assert (m_ciAttri == 0 || m_rgAttri != NULL);
            assert (iAttri < m_ciAttri);
            if (iAttri < m_ciAttri) {
                return m_rgAttri[iAttri]; 
            } else {
                return 0;
            }
        }

        // Query a specific attribute
        BOOL fGetAttri(USHORT iAttriID) const {
            assert (m_ciAttri == 0 || m_rgAttri != NULL);
            for (int i = 0; i < m_ciAttri && m_rgAttri[i] <= iAttriID; i++) {
                if (m_rgAttri[i] == iAttriID) {
                    return TRUE;
                }
            }
            return FALSE;
        }

    private:
        DWORD   m_dwWordID;     //  32 bit word id
        USHORT  m_ciAttri;
        USHORT* m_rgAttri;
        DWORD   m_hLex;

};

/*============================================================================
Class CLexicon:
Desc:   Declare the lexicon class
Prefix: lex
============================================================================*/
class CLexicon
{
    public:
        //  Constructor
        CLexicon();
        //  Destructor
        ~CLexicon();

        //  fInit: load the LexHeader and calculate the offset of index and lex section
        //  Return FALSE if invalid LexHeader 
        BOOL fOpen(BYTE* pbLexHead);
        //  Close: clear current lexicon setting, file closed by LangRes
        void Close(void);
        //  Get LexVersion
        DWORD dwGetLexVersion(void) const {
            return m_dwLexVersion; 
        }

        //  fGetCharInfo: get the word info of the given single char word
        BOOL fGetCharInfo(const WCHAR wChar, CWordInfo* pwinfo);
        
        //  cchMaxMatch: lexicon based max match algorithm
        //  Return length of the matched string
        USHORT cwchMaxMatch(LPCWSTR pwchStart, 
                            const USHORT cwchLen, 
                            CWordInfo* pwinfo);
        /*============================================================================
        CLexicon::pwchGetFeature(): 
            retrieve the specific feature for given lex handle
        Returns:
            the feature buffer and length of the feature if found
            NULL if the feature was not found or invalid lex handle
        Notes:
            Because lexicon object does not know how to explain the feature buffer,
            to parse the feature buffer is the client's work.
        ============================================================================*/
        LPWSTR pwchGetFeature(const DWORD hLex, const USHORT iFtrID, USHORT* pcwchFtr) const;
        //  The following two functions involve the Lexicon in the Feature test format!!!
        //  Test whether the given SC character is included in a given feature
        BOOL fIsCharFeature(const DWORD hLex, const USHORT iFtrID, const WCHAR wChar) const;
        //  Test whether the given buffer is included in a given feature
        BOOL fIsWordFeature(const DWORD hLex, const USHORT iFtrID, 
                            LPCWSTR pwchWord, const USHORT cwchWord) const;

    private:
        DWORD           m_dwLexVersion; // Lex Version
        
        USHORT          m_ciIndex;      // Count of index entry
        CRTLexIndex*    m_rgIndex;      // index section
        WORD*           m_pwLex;        // lexicon section
        BYTE*           m_pbProp;       // property section
        BYTE*           m_pbFtr;        // feature text section
        //  Store the lenght of property and feature section for runtime address validation
        //  These two fields are only necessary to access feature by lex handle
        DWORD           m_cbProp;       // length of the property section
        DWORD           m_cbFtr;        // length of the feature text section

    private:

        //  Set WordInfo from lex index or lex record
        void SetWordInfo(DWORD ofbProp, CWordInfo* pwinfo) const;

        //  Calculate the index value from a Chinese char
        inline WORD wCharToIndex( WCHAR wChar );
        
        //  Decoding the Encoded WordID from the lexicon record
        DWORD dwWordIDDecoding(DWORD dwEncoded);

        // encoding the Unicode char wChar
        inline WCHAR wchEncoding(WCHAR wChar);

        // decoding the Unicode char from wEncoded
        WCHAR wchDecodeing(WCHAR wEncoded);

#ifdef DEBUG
        // Debugging functions that make the lexicon access safe 
    private:
        DWORD*  m_rgofbProp;
        DWORD   m_ciProp;
        DWORD   m_ciMaxProp;
        //  Verify the lexicon format for each word.
        BOOL fVerifyLexicon(DWORD cbSize);
        //  Expand prop offset array
        BOOL fExpandProp(void);
#endif // DEBUG

};

#endif  // #ifndef _LEXICON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\lock.h ===
#ifndef __CSimpleLock_h__
#define __CSimpleLock_h__

///////////////////////////////////////////////////////////
//
// Lock.h
//   - This class provides a simple locking mechanism.
//

class CSimpleLock
{
public:
	// Lock 
	CSimpleLock(HANDLE hMutex) 
	{
		m_hMutex = hMutex ;
		WaitForSingleObject(hMutex, INFINITE) ;
	}

	// Unlock
	~CSimpleLock()
	{
		ReleaseMutex(m_hMutex) ;
	}

private:
	HANDLE m_hMutex  ;
};

#endif ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\lexprop.h ===
//--------------------------------------------------------------------------------------
 //	LexProp.h																			
 //	Project:	Chinese Grammar'9                  										
 //	Module:		LexProp																	
 //	Purpose:	Define symbols of lex attributes and features used by the Rules and Parser
 //	Notes:		This header file is generated by the lexicon builder of the lex manager	
 //	Owner:		donghz@microsoft.com													
 //	Platform:	Win32																	
 //	Revise:		First created by: donghz	12/5/97										
 //--------------------------------------------------------------------------------------
 #ifndef _LEXPROP_H_ 
 #define _LEXPROP_H_ 


// Define Lex version verify ID
#define LexDef_Version 173

// Define Max WordID
#define LexDef_MaxWordID 58325
// Define Max CharID
#define LexDef_MaxCharID 3483

// Define the ID of groups of Attributes
#define LGDef_WrdBrk_First 1
#define LADef_genBreakPunct 1 	// 
#define LADef_genCi 2 	// 
#define LADef_genCuo 3 	// 
#define LADef_posA 4 	// 
#define LADef_posB 5 	// 
#define LADef_posD 6 	// 
#define LADef_posM 7 	// 
#define LADef_posN 8 	// 
#define LADef_posO 9 	// 
#define LADef_posP 10 	// 
#define LADef_posQ 11 	// 
#define LADef_posT 12 	// 
#define LADef_posV 13 	// 
#define LADef_posZ 14 	// 
#define LADef_genDBForeign 15 	// DBCS
#define LADef_tmPoint 16 	// 
#define LADef_tmGapMinute 17 	// 
#define LADef_amtApprox 18 	// 
#define LADef_genAmbiMorph 19 	// Morph
#define LADef_amtWanQian 20 	// /// 
#define LGDef_WrdBrk_Last 20

#define LGDef_IWordBreaker_First 21
#define LADef_iwbAltPhr 21 	// StartAltPhrase( ) / EndAltPhrase() with child words.
#define LADef_iwbAltWd1 22 	// PutAltWord ( the first word in this word's childs )
#define LADef_iwbAltWd2 23 	// PutAltWord ( the second word in this word's childs )
#define LADef_iwbAltWdc13 24 	// PutAltWord ( combination of the first word and the third word in this word's childs )
#define LADef_iwbNPhr1 25 	// Modifier + Noun Phrase, Modifier
#define LADef_iwbNPhr2 26 	// Modifier + Noun Phrase, Modifier
#define LADef_iwbNPhr3 27 	// Modifier + Noun Phrase, Modifier
#define LGDef_IWordBreaker_Last 27

#define LGDef_NounSubClass_First 28
#define LADef_nounOrg 28 	// 
#define LADef_nounPerson 29 	// 
#define LADef_nounPlace 30 	// 
#define LADef_nounTM 31 	// 
#define LADef_nounTerm 32 	// 
#define LADef_nounShiDuan 33 	// 
#define LGDef_NounSubClass_Last 33

#define LGDef_Punct_First 34
#define LADef_punPunct 34 	// DBCS
#define LADef_punJu 35 	// 
#define LADef_punPair 36 	// 
#define LGDef_Punct_Last 36

#define LGDef_Number_First 37
#define LADef_numArabic 37 	// DBCS
#define LADef_numChinese 38 	// DBCS
#define LADef_numCode 39 	// 
#define LADef_numGan 40 	// 
#define LADef_numInteger 41 	// 
#define LADef_numPercent 42 	// 
#define LADef_numSBCS 43 	// SBCS
#define LADef_numZhi 44 	// 
#define LADef_numXi 45 	// 
#define LADef_numMixed 46 	// 8120
#define LADef_numOrdinal 47 	// 
#define LADef_numDecimal 48 	// 
#define LADef_numTipDecimal 49 	// 
#define LADef_numTipOrdinal 50 	// 
#define LADef_numNumber 51 	// 
#define LGDef_Number_Last 51

#define LGDef_Morpheme_First 52
#define LADef_afxPrefix 52 	// 
#define LADef_afxSuffix 53 	// 
#define LADef_pfxAa 54 	// <>
#define LADef_pfxChao 55 	// <>
#define LADef_pfxDai 56 	// <>
#define LADef_pfxFan 57 	// <>
#define LADef_pfxFei 58 	// <>
#define LADef_pfxFu 59 	// <>
#define LADef_pfxGuo 60 	// <>
#define LADef_pfxLao 61 	// <>
#define LADef_pfxWei1 62 	// <>
#define LADef_pfxWei3 63 	// <>
#define LADef_pfxXiao 64 	// <>
#define LADef_pfxZhun 65 	// <>
#define LADef_pfxZong 66 	// <>
#define LADef_sfxChang 67 	// <>
#define LADef_sfxDan 68 	// <>
#define LADef_sfxDui 69 	// <>
#define LADef_sfxEr 70 	// <>
#define LADef_sfxFa 71 	// <>
#define LADef_sfxFang 72 	// <>
#define LADef_sfxGan 73 	// <>
#define LADef_sfxGuan 74 	// <>
#define LADef_sfxHua 75 	// <>
#define LADef_sfxJi 76 	// <>
#define LADef_sfxJia 77 	// <>
#define LADef_sfxJie 78 	// <>
#define LADef_sfxLao 79 	// <>
#define LADef_sfxLun 80 	// <>
#define LADef_sfxLv 81 	// <>
#define LADef_sfxMen 82 	// <>
#define LADef_sfxPin 83 	// <>
#define LADef_sfxQi 84 	// <>
#define LADef_sfxSheng 85 	// <>
#define LADef_sfxSheng3 86 	// <>
#define LADef_sfxShi 87 	// <>
#define LADef_sfxShi1 88 	// <>
#define LADef_sfxShi4 89 	// <>
#define LADef_sfxTi 90 	// <>
#define LADef_sfxTing 91 	// <>
#define LADef_sfxTou 92 	// <>
#define LADef_sfxXing2 93 	// <>
#define LADef_sfxXing4 94 	// <>
#define LADef_sfxXue 95 	// <>
#define LADef_sfxYan 96 	// <>
#define LADef_sfxYe 97 	// <>
#define LADef_sfxYi 98 	// <>
#define LADef_sfxYuan 99 	// <>
#define LADef_sfxZhang 100 	// <>
#define LADef_sfxZhe 101 	// <>
#define LADef_sfxZheng 102 	// <>
#define LADef_sfxZi 103 	// <>
#define LADef_sfxZhi 104 	// <>
#define LGDef_Morpheme_Last 104

#define LGDef_Duplicate_First 105
#define LADef_dupAAABB 105 	// AABB
#define LADef_dupAABAB 106 	// ABAB
#define LADef_dupABB 107 	// ABB
#define LADef_dupMAABB 108 	// AABB
#define LADef_dupMABAB 109 	// ABAB
#define LADef_dupMM 110 	// 
#define LADef_dupNAABB 111 	// AABB
#define LADef_dupNN 112 	// 
#define LADef_dupQQ 113 	// 
#define LADef_dupVAABB 114 	// AABB
#define LADef_dupVABAB 115 	// ABAB
#define LADef_dupVV 116 	// 
#define LADef_dupVVO 117 	// VVO
#define LADef_dupZABAB 118 	// ABAB
#define LADef_dupAA 119 	// 
#define LADef_dupDD 120 	// 
#define LADef_dupDAABB 121 	// AABB
#define LADef_dupDABAB 122 	// ABAB
#define LADef_dupAAToD 123 	// 
#define LGDef_Duplicate_Last 123

#define LGDef_Pattern_First 124
#define LADef_patD1 124 	// DADB
#define LADef_patV1 125 	// VV
#define LADef_patV2 126 	// VV
#define LADef_patV3 127 	// VV
#define LADef_patV4 128 	// VV
#define LADef_patV5 129 	// VV
#define LGDef_Pattern_Last 129

#define LGDef_SeparateWord_First 130
#define LADef_sepBuDe 130 	// <///>
#define LADef_sepChaBu 131 	// 
#define LADef_sepChaDing 132 	// 
#define LADef_sepHou 133 	// 
#define LADef_sepQDong 134 	// 
#define LADef_sepQian 135 	// 
#define LADef_sepQShi 136 	// 
#define LADef_sepVG 137 	// 
#define LADef_sepVO 138 	// 
#define LADef_sepVR 139 	// 
#define LGDef_SeparateWord_Last 139

#define LGDef_FlagWord_First 140
#define LADef_flgNoABu 140 	// <>
#define LADef_flgNoVBu 141 	// <>
#define LADef_flgNoVMei 142 	// <>
#define LGDef_FlagWord_Last 142

#define LGDef_Misc_First 143
#define LADef_miscElement 143 	// 
#define LADef_miscYear 144 	// 
#define LGDef_Misc_Last 144

#define LGDef_ProperName_First 145
#define LADef_pnCheng 145 	// 
#define LADef_pnDi 146 	// 
#define LADef_pnDian 147 	// 
#define LADef_pnHou 148 	// 
#define LADef_pnMing 149 	// ()
#define LADef_pnMing2 150 	// 
#define LADef_pnQian 151 	// 
#define LADef_pnShang 152 	// 
#define LADef_pnWai 153 	// 
#define LADef_pnXing 154 	// 
#define LADef_pnYi 155 	// 
#define LADef_pnLianMing 156 	// 
#define LADef_pnAction 157 	// 
#define LADef_pnChengWei 158 	// 
#define LADef_pnNoTM 159 	// 
#define LADef_pnPaiHang 160 	// 
#define LADef_pnNoFHead 161 	// 
#define LADef_pnNoFTail 162 	// 
#define LADef_pnXingZhi 163 	// 
#define LGDef_ProperName_Last 163

// Define the MaxID of Lex Attributes
#define LADef_MaxID 163


// Define the ID of Features
#define LFDef_verbModifier 1 	// 
#define LFDef_verbObject 2 	// 
#define LFDef_iwbPhr 3 	// IWordBreaker Phrase

// Define the MaxID of Lex Features
#define LFDef_MaxID 3


#endif // _LEXPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\morph2.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CMorph
Purpose:    Implement the numerical words binding and special M+Q usage processing
Notes:      There are some analysis exceed the scope of morphological in the M+Q 
            analysis, they are some phrase structure analyzing stuff, but I think 
            implement them here is more reasonable and effecient
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#include "myafx.h"

#include "morph.h"
#include "wordlink.h"
#include "scchardef.h"
//#include "engindbg.h"

//  Define the return value of rules handler functions
#define NUM_UNPROCESS   0
#define NUM_PROCESSED   1
#define NUM_ERROR       2

/*============================================================================
Implement Private functions for Numerical words analysis
============================================================================*/
//  Level 1:

/*============================================================================
CMorph::fNumerialAnalysis():
    Numerical Analysis control function. 
Returns:
    TRUE if done
    FALSE if error occurred, and the error code in m_iecError
============================================================================*/
BOOL CMorph::fNumerialAnalysis()
{
    int     iret;

    assert(m_iecError == 0); // the error code public field should be cleared
    assert(m_pLink != NULL);

    m_pWord = m_pLink->pGetHead();
    assert(m_pWord);

    if (m_pWord->fIsTail()) {
        return TRUE;
    }

    // Scan from left to right for numerial words processing
    for (; m_pWord; m_pWord = m_pWord->pNextWord()) {
        // Test the number word, combind and parse the number word
        if ((iret = GetNumber()) == NUM_UNPROCESS) {
            continue;
        }
        if (iret == NUM_ERROR) { 
            assert(m_iecError != 0);
            return FALSE;
        }
        
        // Bind ordinal number
        if (!m_pWord->fIsHead() &&
            m_pWord->pPrevWord()->fGetAttri(LADef_numTipOrdinal)) {

            if ((iret = BindOrdinal()) == NUM_PROCESSED) {
                continue;
            }
            if (iret == NUM_ERROR) {
                assert(m_iecError != 0);
                return FALSE;
            }
        }

        // Bind decimal number
        if (!m_pWord->fIsHead() &&
            m_pWord->pPrevWord()->fGetAttri(LADef_numTipDecimal) ||
            !m_pWord->fIsTail() &&
            m_pWord->pNextWord()->fGetAttri(LADef_numTipDecimal) ) {

            if ((iret = BindDecimal()) == NUM_PROCESSED) {
                continue;
            }
            if (iret == NUM_ERROR) {
                assert(m_iecError != 0);
                return FALSE;
            }
        }

        // Bind Range of Integers , ,  
        if (m_pWord->fGetAttri(LADef_numInteger)) {
            if (BindRange() == NUM_ERROR) {
                assert(m_iecError != 0);
                return FALSE;
            }
        }
    }

#ifdef DEBUG
    // Validate numNumber node
    m_pWord = m_pLink->pGetHead();
    for (; m_pWord; m_pWord = m_pWord->pNextWord()) {
        int dbg_ciTag = 0;
        if (m_pWord->fGetAttri(LADef_numNumber)) {
            if (m_pWord->fGetAttri(LADef_numInteger)) {
                dbg_ciTag++;
            }
            if (m_pWord->fGetAttri(LADef_numPercent)) {
                dbg_ciTag++;
            }
            if (m_pWord->fGetAttri(LADef_numDecimal)) {
                dbg_ciTag++;
            }
            if (m_pWord->fGetAttri(LADef_numOrdinal)) {
                dbg_ciTag++;
            }
            assert(dbg_ciTag <= 1); // Only one of these 3 can be set
            if (dbg_ciTag == 0) {
                assert(m_pWord->fGetAttri(LADef_numCode)); // Must have some attribute
                //_DUMPLINK(m_pLink, m_pWord);
            } else if (m_pWord->fGetAttri(LADef_numCode)) {
                // Only numInteger could co-exist with numCode
                assert(m_pWord->fGetAttri(LADef_numInteger)); 
                //_DUMPLINK(m_pLink, m_pWord);
            } else {
            }
        }
    }
#endif // DEBUG

    return TRUE;
}


//  Level 2: 

/*============================================================================
CMorph::GetNumber():
    Analysis number word string, check error and mark the class of the merged
    number words.
Remarks:
    number testing from current word!
============================================================================*/
inline int CMorph::GetNumber()
{
    int iret = NUM_UNPROCESS;
    if (m_pWord->fGetAttri(LADef_numSBCS)) {
        numSBCSParser();
        if (m_pWord->pPrevWord() &&
            ( m_pWord->pPrevWord()->fGetAttri(LADef_numArabic) ||
              m_pWord->pPrevWord()->fGetAttri(LADef_numChinese))) {
            // 
            m_pWord->SetErrID(ERRDef_NOSTDNUM);
            //_DUMPLINK(m_pLink, m_pWord);
        }
        iret = NUM_PROCESSED;
    } else if (m_pWord->fGetAttri(LADef_numArabic)) {
        if (!m_pWord->fGetFlag(CWord::WF_REDUCED)) { // Has not been processed
            numArabicParser();
        }
        if (m_pWord->pPrevWord() &&
            ( m_pWord->pPrevWord()->fGetAttri(LADef_numSBCS) ||
              m_pWord->pPrevWord()->fGetAttri(LADef_numChinese))) {
            // 
            m_pWord->SetErrID(ERRDef_NOSTDNUM);
            //_DUMPLINK(m_pLink, m_pWord);
        }
        iret = NUM_PROCESSED;
    } else if (m_pWord->fGetAttri(LADef_numChinese)) {
        if (!m_pWord->fGetFlag(CWord::WF_REDUCED)) { // Has not been processed
            numChineseParser();
            // Return at once when error found
            if (m_pWord->GetErrID() != ERRDef_NIL) {
                return NUM_PROCESSED;
            }
        }
        if (m_pWord->fGetFlag(CWord::WF_CHAR) &&
            !m_pWord->fGetAttri(LADef_numXi) &&
            ( m_pWord->fIsWordChar(SC_CHAR_WAN) ||
              m_pWord->fIsWordChar(SC_CHAR_QIAN) ||
              m_pWord->fIsWordChar(SC_CHAR_YI4) ) &&
            !m_pWord->fIsHead() ) {

            CWord* pPrev = m_pWord->pPrevWord();
            if (pPrev->fGetAttri(LADef_numDecimal)) {
                if (pPrev->fGetAttri(LADef_numChinese)) {
                    m_pWord = m_pLink->pLeftMerge(m_pWord, 1);
                    m_pWord->SetAttri(LADef_numChinese);
                } else {
                    m_pWord = m_pLink->pLeftMerge(m_pWord, 1);
                    m_pWord->SetAttri(LADef_numMixed);
                }
                //_DUMPCASE(m_pLink, m_pWord, 1000);
                m_pWord->SetAttri(LADef_numInteger);
            } else if (pPrev->fGetAttri(LADef_numSBCS) ||
                       pPrev->fGetAttri(LADef_numArabic) ) { // 8, 5, 
                m_pWord = m_pLink->pLeftMerge(m_pWord, 1);
                if (!m_pWord->fIsHead() &&
                    m_pWord->pPrevWord()->fGetAttri(LADef_numMixed)) {
                    // 85
                    m_pWord = m_pLink->pLeftMerge(m_pWord, 1);
                }
                if (!m_pWord->fIsTail() &&
                    ( m_pWord->pNextWord()->fIsWordChar(SC_CHAR_DUO) ||
                      m_pWord->pNextWord()->fIsWordChar(SC_CHAR_YU) ) ) {
                    // 85 /
                    m_pLink->MergeWithNext(m_pWord);
                    m_pWord->SetAttri(LADef_amtApprox);
                }
                m_pWord->SetAttri(LADef_numMixed);
                m_pWord->SetAttri(LADef_numInteger);
                //_DUMPCASE(m_pLink, m_pWord, 1001);
            } else if (( pPrev->fIsWordChar(SC_CHAR_DUO) ||
                         pPrev->fIsWordChar(SC_CHAR_YU)) &&
                       !pPrev->fIsHead() &&
                       pPrev->pPrevWord()->fGetAttri(LADef_numInteger) ) {
                //  +  + /
                if (pPrev->pPrevWord()->fGetAttri(LADef_numChinese)) {
                    //  / 
                    m_pWord = m_pLink->pLeftMerge(m_pWord, 2);
                    m_pWord->SetAttri(LADef_numInteger);
                    m_pWord->SetAttri(LADef_numChinese);
                    m_pWord->SetAttri(LADef_amtApprox);
                    //_DUMPCASE(m_pLink, m_pWord, 1002);
                } else if (pPrev->pPrevWord()->fGetAttri(LADef_numArabic) ||
                           pPrev->pPrevWord()->fGetAttri(LADef_numSBCS) ) {
                    // Merge mixed number
                    m_pWord = m_pLink->pLeftMerge(m_pWord, 2);
                    if (!m_pWord->fIsHead() &&
                        m_pWord->pPrevWord()->fGetAttri(LADef_numMixed)) {
                        // 1200
                        m_pWord = m_pLink->pLeftMerge(m_pWord, 1);
                    }
                    //_DUMPCASE(m_pLink, m_pWord, 1003);
                    m_pWord->SetAttri(LADef_numInteger);
                    m_pWord->SetAttri(LADef_numMixed);
                    m_pWord->SetAttri(LADef_amtApprox);
                } else {
                }
            } else {
            }
        } else if (!m_pWord->fIsHead() &&
                   ( m_pWord->pPrevWord()->fGetAttri(LADef_numSBCS) || 
                     m_pWord->pPrevWord()->fGetAttri(LADef_numArabic) ) ) {
            // 
            m_pWord->SetErrID(ERRDef_NOSTDNUM);
            //_DUMPCASE(m_pLink, m_pWord, 1004);
        } else {
        }

        m_pWord->SetAttri(LADef_numNumber);
        iret = NUM_PROCESSED;
    } else if (m_pWord->fGetAttri(LADef_numGan) && !m_pWord->fIsTail() &&
               m_pWord->pNextWord()->fGetAttri(LADef_numZhi) ) {
        // Merge 
        numGanZhiHandler();
        m_pWord->SetAttri(LADef_posT);
        iret = NUM_PROCESSED;
    } else {
    }

    return iret;
}


//  
int CMorph::BindOrdinal()
{
    int iret;
    assert(!m_pWord->fIsHead() &&
           m_pWord->pPrevWord()->fGetAttri(LADef_numTipOrdinal));

    if (m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_DI)) {
        iret = ordDi_Proc();    // 
    } else if (m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_CHU)) {
        iret = ordChu_Proc();   // 
    } else {
        //_DUMPLINK(m_pLink, m_pWord);
        return NUM_UNPROCESS;
    }
    m_pWord->SetAttri(LADef_numNumber);
    return NUM_PROCESSED;
}


//  
int CMorph::BindDecimal()
{
    assert(!m_pWord->fIsHead() &&
           m_pWord->pPrevWord()->fGetAttri(LADef_numTipDecimal) ||
           !m_pWord->fIsTail() &&
           m_pWord->pNextWord()->fGetAttri(LADef_numTipDecimal) );

    CWord*  pWord;
    int     iret;
    BOOL    fHit = FALSE;
    // Handle 
    if (!m_pWord->fIsTail() &&
        m_pWord->pNextWord()->fGetAttri(LADef_numTipDecimal)) {

        pWord = m_pWord->pNextWord();
        if (pWord->fIsWordChar(SC_CHAR_DIAN3)) {        // 
            iret = decDian_Proc();      
        } else if (pWord->fIsWordChar(SC_CHAR_BEI)) {   // 
            iret = decBei_Proc();
        } else if (pWord->fIsWordChar(SC_CHAR_CHENG)) { // 
            iret = decCheng_Proc();
        } else {
            //_DUMPLINK(m_pLink, m_pWord);
            iret = NUM_UNPROCESS;
        }

        if (iret == NUM_PROCESSED) {
            fHit = TRUE;
        } else if (iret == NUM_ERROR) {
            return NUM_ERROR;
        } else {
        }
    }

    // Handle 
    if (!m_pWord->fIsHead() &&
        m_pWord->pPrevWord()->fGetAttri(LADef_numTipDecimal)) {

        pWord = m_pWord->pPrevWord();
        if (pWord->fIsWordText(SC_WORD_BAIFENZHI)) {    // 
            iret = decBaiFen_Proc();
        } else if (pWord->fIsWordText(SC_WORD_FENZHI)) {// 
            iret = decFenZhi_Proc();
        } else if (pWord->fIsWordText(SC_WORD_QIANFENZHI) ||  // 
                   pWord->fIsWordText(SC_WORD_WANFENZHI))  {  // 
            iret = decBaiFen_Proc();
        } else {
            //_DUMPLINK(m_pLink, m_pWord);
            iret = NUM_UNPROCESS;
        }

        if (iret == NUM_PROCESSED) {
            fHit = TRUE;
        } else if (iret == NUM_ERROR) {
            return NUM_ERROR;
        } else {
        }
    }
    if (fHit) {
        return NUM_PROCESSED;
    }
    return NUM_UNPROCESS;
}


//  : //
inline int CMorph::BindRange()
{
    assert(m_pWord->fGetAttri(LADef_numInteger));

    if (m_pWord->fIsHead()) {
        return NUM_UNPROCESS;
    }

    USHORT iStyle;
    CWord* pWord = m_pWord->pPrevWord();
    if( pWord->fGetFlag(CWord::WF_CHAR) &&
        ( pWord->fIsWordChar(SC_CHAR_ZHI4) ||
          pWord->fIsWordChar(SC_CHAR_DUNHAO) ||
          pWord->fIsWordChar(SC_CHAR_LIANHAO) ) &&
        !pWord->fIsHead() &&
        pWord->pPrevWord()->fGetAttri(LADef_numInteger) ) { // Match!
        // Get number style of m_pWord
        if (m_pWord->fGetAttri(LADef_numSBCS)) {
            iStyle = LADef_numSBCS;
        } else if (m_pWord->fGetAttri(LADef_numArabic)) {
            iStyle = LADef_numArabic;
        } else if (m_pWord->fGetAttri(LADef_numChinese)) {
            iStyle = LADef_numChinese;
        } else if (m_pWord->fGetAttri(LADef_numMixed)) {
            iStyle = LADef_numMixed;
        } else {
            //_DUMPLINK(m_pLink, m_pWord);
            iStyle = 0;
        }
        // Check style with previous integer
        if (!pWord->pPrevWord()->fGetAttri(iStyle)) { // Unmatched style!
            if ((iStyle == LADef_numSBCS || iStyle == LADef_numArabic) &&
                ( pWord->pPrevWord()->fGetAttri(LADef_numSBCS) ||
                  pWord->pPrevWord()->fGetAttri(LADef_numArabic) ) ) {
                // Mixed usage of SBCS and Arabic numbers
                m_pWord->SetErrID(ERRDef_NOSTDNUM);
                //_DUMPLINK(m_pLink, pWord);
            }
            return NUM_UNPROCESS;
        }
        // Merge the integer range
        m_pWord = pWord->pPrevWord();
        m_pLink->MergeWithNext(m_pWord);
        m_pLink->MergeWithNext(m_pWord);
        m_pWord->SetAttri(iStyle);
        m_pWord->SetAttri(LADef_numInteger);
        m_pWord->SetAttri(LADef_amtApprox);
        m_pWord->SetAttri(LADef_numNumber);
        //_DUMPLINK(m_pLink, m_pWord);
    } else {
        //_DUMPLINK(m_pLink, m_pWord);
    }

    return NUM_UNPROCESS;
}

    
//  Level 3:
//  Parse the 3 kinds of number: numSBCS, numArabic, numChinese

//  Parser for SBCS number called by GetNumber()
void CMorph::numSBCSParser()
{
    assert(m_pWord->fGetFlag(CWord::WF_SBCS) &&
           m_pWord->fGetAttri(LADef_numSBCS));

    BOOL fFloat = FALSE;
    BOOL fPercent = FALSE;
    WCHAR* pwch = m_pWord->pwchGetText();
    WCHAR* pwchTail = m_pWord->pwchGetText()+m_pWord->cwchLen();

    // only one character
    if (m_pWord->cwchLen() == 1) {
        // Clear the numSBCS attribute if only '.' or '%' alone
        if (*pwch == SC_CHAR_ANSIPERCENT || *pwch == SC_CHAR_ANSIDIAN) {
            m_pWord->ClearAttri(LADef_numSBCS);
            return;
        }
    }

    // Multi-char SBCS number
    while (pwch < pwchTail) {
        if (*pwch == SC_CHAR_ANSIDIAN) {
            fFloat = TRUE;
        } else if (*pwch == SC_CHAR_ANSIPERCENT) {
            fPercent = TRUE;
        }
        pwch++;
    }
    if (fPercent) {
        m_pWord->SetAttri(LADef_numPercent);
    } else if (fFloat) {
        m_pWord->SetAttri(LADef_numDecimal);
    } else {
        if (!m_pWord->fIsHead() && !m_pWord->pPrevWord()->fIsHead() &&
            m_pWord->pPrevWord()->pPrevWord()->fGetAttri(LADef_numSBCS) &&
            m_pWord->pPrevWord()->pPrevWord()->fGetAttri(LADef_numInteger) &&
            *(m_pWord->pPrevWord()->pwchGetText()) == SC_CHAR_ANSISLASH ) {
            // fraction like 2/3
            m_pWord = m_pWord->pPrevWord()->pPrevWord();
            m_pLink->MergeWithNext(m_pWord);
            m_pLink->MergeWithNext(m_pWord);
            m_pWord->SetAttri(LADef_numSBCS);
            m_pWord->SetAttri(LADef_numPercent);
            //_DUMPLINK(m_pLink, m_pWord);
        } else {
            m_pWord->SetAttri(LADef_numCode);
            m_pWord->SetAttri(LADef_numInteger);
        }
    }
    // Mark numNumber
    m_pWord->SetAttri(LADef_numNumber);

    return;
}


//  Parser for DBCS Arabic number called by GetNumber()
void CMorph::numArabicParser() 
{
    assert(!m_pWord->fGetFlag(CWord::WF_SBCS) && !m_pWord->fGetFlag(CWord::WF_REDUCED));
    assert(m_pWord->fGetAttri(LADef_numArabic));
    
    // Merge continuous Arabic numbers
    BOOL fFloat = FALSE;
    BOOL fPercent = FALSE;
    while (m_pWord->pNextWord() &&
           m_pWord->pNextWord()->fGetAttri(LADef_numArabic)) {
        if (m_pWord->pNextWord()->fIsWordChar(SC_CHAR_SHUDIAN)) {
            if (!fFloat && m_pWord->pNextWord()->pNextWord() &&
                m_pWord->pNextWord()->pNextWord()->fGetAttri(LADef_numArabic)) {

                fFloat = TRUE;
            } else {
                break;
            }
        } else if (m_pWord->pNextWord()->fIsWordChar(SC_CHAR_PERCENT)) {
            fPercent = TRUE;
        } else if (fPercent) {
            m_pWord->SetErrID(ERRDef_NUMERIAL);
        }
        m_pLink->MergeWithNext(m_pWord);
    }

    if (m_pWord->fGetFlag(CWord::WF_CHAR)) {
        if (m_pWord->fIsWordChar(SC_CHAR_PERCENT) ||
            m_pWord->fIsWordChar(SC_CHAR_SHUDIAN)) { 
            if (!m_pWord->fIsHead() && m_pWord->fGetAttri(LADef_numSBCS)) {
                // DBCS "" or "" follow the SBCS number
                m_pWord = m_pLink->pLeftMerge(m_pWord, 1);
                m_pWord->SetErrID(ERRDef_NOSTDNUM);
                //_DUMPLINK(m_pLink, m_pWord);
            } else {
                // Only DBCS "" or "", return w/o mark numArabic
            }
            return;
        }
    }

    // Set the attribute for multi-char Arabic number
    if (fPercent) {
        m_pWord->SetAttri(LADef_numPercent);
        //_DUMPLINK(m_pLink, m_pWord);
    } else if (fFloat) {
        m_pWord->SetAttri(LADef_numDecimal);
        //_DUMPLINK(m_pLink, m_pWord);
    } else {
        if ( !m_pWord->fIsHead() && !m_pWord->pPrevWord()->fIsHead() &&
             m_pWord->pPrevWord()->pPrevWord()->fGetAttri(LADef_numArabic) &&
             m_pWord->pPrevWord()->pPrevWord()->fGetAttri(LADef_numInteger) &&
             m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_SLASH) ) {
            // fraction like 2/3
            m_pWord = m_pWord->pPrevWord()->pPrevWord();
            m_pLink->MergeWithNext(m_pWord);
            m_pLink->MergeWithNext(m_pWord);
            m_pWord->SetAttri(LADef_numPercent);
            //_DUMPLINK(m_pLink, m_pWord);
        } else {
            m_pWord->SetAttri(LADef_numCode);
            m_pWord->SetAttri(LADef_numInteger);
            //_DUMPLINK(m_pLink, m_pWord);
        }
    }
    m_pWord->SetAttri(LADef_numArabic);
    m_pWord->SetAttri(LADef_numNumber);
    return;
}


//  Parser for DBCS Chinese number called by GetNumber()
//  Define the events constant
#define EVENT_LING  0
#define EVENT_XI    1
#define EVENT_LIANG 2
#define EVENT_SHI   3
#define EVENT_BAI   4
#define EVENT_QIAN  5
#define EVENT_WAN   6
#define EVENT_YI    7
#define EVENT_JI    8
#define EVENT_END   9

//  Define the events array
static struct { 
    WCHAR   m_wchEvent;
    char    m_iEvent;
    } v_rgEvent[] = {
                     { SC_DIGIT_YI,    EVENT_XI   },// 0x4e00 ""
                     { SC_DIGIT_QI,    EVENT_XI   },// 0x4e03 ""
                     { SC_DIGIT_WAN,   EVENT_WAN  },// 0x4e07 ""
                     { SC_DIGIT_SAN,   EVENT_XI   },// 0x4e09 ""
                     { SC_DIGIT_LIANG, EVENT_LIANG},// 0x4e24 ""
                     { SC_DIGIT_JIU,   EVENT_XI   },// 0x4e5d ""
                     { SC_DIGIT_ER,    EVENT_XI   },// 0x4e8c ""
                     { SC_DIGIT_WU,    EVENT_XI   },// 0x4e94 ""
                     { SC_DIGIT_YI4,   EVENT_YI   },// 0x4ebf ""
                     { SC_DIGIT_BA,    EVENT_XI   },// 0x516b ""
                     { SC_DIGIT_LIU,   EVENT_XI   },// 0x516d ""
                     { SC_CHAR_JI,     EVENT_JI   },// 0x51e0 ""
                     { SC_DIGIT_SHI,   EVENT_SHI  },// 0x5341 ""
                     { SC_DIGIT_QIAN,  EVENT_QIAN },// 0x5343 ""
                     { SC_DIGIT_SI,    EVENT_XI   },// 0x56db ""
                     { SC_DIGIT_BAI,   EVENT_BAI  },// 0x767e ""
                     { SC_DIGIT_LING,  EVENT_LING },// 0x96f6 ""
                     { SC_ARABIC_LING, EVENT_LING },// 0xff10 ""
                     { SC_DBCS_LING,   EVENT_LING } // 0X3007 ""
    };

static const char v_ciEvents = 10;

//  Define the state transfer array
//  Ambiguities! can not find errors like  or  (Unexpected "")
static char v_rgStateTrans[][v_ciEvents] = { 
    //                                    End
    /*  0       */  -1,  1,  1,  3,  6,  9, 12, 24,  1, -1,
    /*  1       */   2,  1,  1,  3,  6,  9, 12, 24, -1,  0,
    /*  2     */  -1, -1, -1, -1,  6,  9, 12, 24, -1, -1,
    /*  3       */  -1,  4, -1, -1, -1, -1, -1, -1,  4,  0,
    /*  4       */   5,  4, -1, -1,  6, -1, -1, -1, -1,  0,
    /*  5     */  -1, -1, -1, -1, -1,  9, 12, 24, -1, -1,
    /*  6       */  -1,  7,  7, -1, -1, -1, -1, -1,  7, -1,
    /*  7       */   8,  7,  7, -1, -1,  9, -1, -1, -1,  0,
    /*  8     */  -1, -1, -1, -1, -1, -1, 12, 24, -1, -1,
    /*  9       */  -1, 10, 10, -1, -1, -1, -1, -1, 10, -1,
    /* 10       */  11, 10, 10, -1, -1, -1, 12, -1, -1,  0,
    /* 11     */  -1, -1, -1, -1, -1, -1, 12, 24, -1, -1,
    /* 12       */  -1, 13, 13, 15, 18, 21, -1, -1, 13, -1,
    /* 13       */  14, 13, 13, 15, -1, -1, -1, -1, -1,  0,
    /* 14     */  -1, -1, -1, -1, 18, 21, -1, 24, -1, -1,
    /* 15     */  -1, 16, 16, -1, -1, -1, -1, -1, 16,  0,
    /* 16     */  17, 16, 16, -1, 18, -1, -1, -1, -1,  0,
    /* 17   */  -1, -1, -1, -1, 18, 21, -1, 24, -1, -1,
    /* 18     */  -1, 19, 19, -1, -1, -1, -1, -1, 19, -1,
    /* 19     */  20, 19, 19, -1, -1, 21, -1, -1, -1,  0,
    /* 20   */  -1, -1, -1, -1, -1, 21, -1, 24, -1, -1,
    /* 21     */  -1, 22, 22, -1, -1, -1, -1, -1, 22, -1,
    /* 22     */  23, 22, 22, -1, -1, -1, -1, 24, -1,  0,
    /* 23   */  -1, -1, -1, -1, -1, -1, -1, 24, -1, -1,
    /* 24       */  -1, 25, 25, 27, 30, 32, -1, -1, 25, -1,
    /* 25       */  26, 25, 25, 27, -1, -1, -1, -1, -1,  0,
    /* 26     */  -1, -1, -1, -1, 30, 32, -1, -1, -1, -1,
    /* 27     */  -1, 28, 28, -1, -1, -1, -1, -1, 28,  0,
    /* 28     */  29, 28, 28, -1, 30, -1, -1, -1, -1,  0,
    /* 29   */  -1, -1, -1, -1, -1, 32, -1, -1, -1, -1,
    /* 30     */  -1, 31, 31, -1, -1, -1, -1, -1, 31, -1,
    /* 31     */  -1, 31, 31, -1, -1, 32, -1, -1, -1,  0,
    /* 32     */  -1, 33, 33, -1, -1, -1, -1, -1, 33, -1,
    /* 33     */  -1, 33, 33, -1, -1, -1, -1, -1, -1,  0
};

void CMorph::numChineseParser() 
{
    assert(!m_pWord->fGetFlag(CWord::WF_REDUCED));
    assert(m_pWord->fGetAttri(LADef_numChinese));

    char iEvent, iState;
    BOOL fXi = m_pWord->fGetAttri(LADef_numXi);
    BOOL fWei = !fXi;
    BOOL fJi = m_pWord->fIsWordChar(SC_CHAR_JI);
    // Merge the continuous Chinese number words
    while (m_pWord->pNextWord() &&
           m_pWord->pNextWord()->fGetAttri(LADef_numChinese)) {
        fJi = (fJi || m_pWord->fIsWordChar(SC_CHAR_JI));
        if (m_pWord->pNextWord()->fGetAttri(LADef_numXi)) {
            fXi = TRUE;
        } else {
            fWei = TRUE;
        }
        m_pLink->MergeWithNext(m_pWord);
    }
    m_pWord->SetAttri(LADef_numChinese);

    // Only one character numerial word
    if (m_pWord->cwchLen() == 1) {
        if ( m_pWord->fGetAttri(LADef_numXi) ||    // ..., , , 
             m_pWord->fIsWordChar(SC_DIGIT_SHI) ) {// 
            //_DUMPLINK(m_pLink, m_pWord);
        } else {  //  or , , , 
            m_pWord->SetAttri(LADef_amtApprox);
            //_DUMPLINK(m_pLink, m_pWord);
        }
        // Bind  ////
        if (m_pWord->pPrevWord() &&
            m_pWord->pPrevWord()->fGetAttri(LADef_amtWanQian) &&
            ( m_pWord->fGetAttri(LADef_amtApprox) &&
              !m_pWord->fIsWordChar(SC_CHAR_JI) ||
              m_pWord->fIsWordChar(SC_DIGIT_SHI)) ) {

            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord);
            m_pWord->SetAttri(LADef_amtApprox);
        }
        m_pWord->SetAttri(LADef_numInteger);
        return;
    }
    // Only  words like: 
    if (!fXi && fWei) {
        // Sould not contain dup chars
        if (fCheckDupChar(m_pWord)) {
            m_pWord->SetErrID(ERRDef_NUMERIAL);
            return;
        }
        // Bind //// //
        if (m_pWord->pPrevWord() &&
            m_pWord->pPrevWord()->fGetAttri(LADef_amtWanQian)) {

            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord);
        }
        m_pWord->SetAttri(LADef_amtApprox);
        m_pWord->SetAttri(LADef_numInteger);
        //_DUMPLINK(m_pLink, m_pWord);
        return;
    }
    // Only  words
    if (fXi && !fWei) {
        if (m_pWord->cwchLen() == 2) {
            if (fValidApproxNum(m_pWord->pwchGetText())) {
                // Valid 
                m_pWord->SetAttri(LADef_amtApprox);
                m_pWord->SetAttri(LADef_numInteger);
                //_DUMPLINK(m_pLink, m_pWord);
            } else if (!m_pWord->fIsTail() &&
                        m_pWord->pNextWord()->fGetAttri(LADef_posQ)) {
                // Other [ + ]
                if (!m_pWord->fIsHead() &&
                    m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_DIAN3)) {
                    //_DUMPCASE(m_pLink, m_pWord, 1031);
                } else if (!m_pWord->fIsTail() &&
                    m_pWord->pNextWord()->fIsWordChar(SC_CHAR_NIAN)) {
                    //_DUMPCASE(m_pLink, m_pWord, 1021);
                } else if (m_pWord->fIsWordLastChar(SC_CHAR_LIANG)) {
                    //_DUMPCASE(m_pLink, m_pWord, 1011);
                } else if (!m_pWord->fGetFlag(CWord::WF_REDUCED)) {
                    // Don't mark error on words like 
                } else {
                    //  
                    m_pWord->SetErrID(ERRDef_NUMERIAL);
                    //_DUMPCASE(m_pLink, m_pWord, 1001);
                }
            } else {
            }
        } // end of if (m_pWord->cwchLen() == 2) 
        if (m_pWord->cwchLen() > 2 && fJi) {
            m_pWord->SetErrID(ERRDef_NUMERIAL);
            //_DUMPCASE(m_pLink, m_pWord, 1002);
        }
        m_pWord->SetAttri(LADef_numCode);
        return;
    }

    // XiWei mixed as integer
    m_pWord->SetAttri(LADef_numInteger);

    // Analyz the  string from right to left
    fXi = FALSE; iState = 0;
    WCHAR* pwchChar = m_pWord->pwchGetText() + m_pWord->cwchLen();
    while (pwchChar > m_pWord->pwchGetText()) {
        pwchChar -= 1; // Move to the last char in the Chinese number string
        // Search in the events array and get current event
        iEvent = EVENT_END;
        int lo = 0, hi = sizeof(v_rgEvent) / sizeof(v_rgEvent[0]) - 1, mi, icmp;
        while (lo <= hi) {
            mi = (lo + hi) / 2;
            if ((icmp = *pwchChar - v_rgEvent[mi].m_wchEvent) == 0) {
                // Match!
                iEvent = v_rgEvent[mi].m_iEvent;
                break;
            } else if (icmp < 0) {
                hi = mi - 1;
            } else {
                lo = mi + 1;
            }
        }

        assert(iEvent != EVENT_END);

        // Handle some special cases for the state machine
        if ((iEvent == EVENT_XI || iEvent == EVENT_LIANG) && fXi) {
            //  +  (: ..., . : , , )
            if (m_pWord->fGetAttri(LADef_amtApprox)) {
                // more than one [+] structure in the same 
                iState = -1;
                break;
            } else {
                assert((pwchChar + 2) <= m_pWord->pNextWord()->pwchGetText());

                if (!fValidApproxNum(pwchChar)) { // [+]
                    iState = -1;
                    break;
                }
                // Not handle error: , 
            }
            m_pWord->SetAttri(LADef_amtApprox); //  if there is a [+]
        }
        fXi = (iEvent == EVENT_XI || iEvent == EVENT_LIANG) ? TRUE : FALSE;

        // Transfer to next state
        iState = v_rgStateTrans[iState][iEvent];
        if(iState == -1) {
            //_DUMPLINK(m_pLink, m_pWord);
            break;
        }
    }
    // Check the end event
    if (iState != -1 && v_rgStateTrans[iState][EVENT_END] == 0) {
        // Valid Chinese number!
    } else { // error found!
        if (!m_pWord->fIsHead() && 
            m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_DIAN3) &&
            ( m_pWord->fIsWordLastChar(SC_CHAR_WAN) ||
              m_pWord->fIsWordLastChar(SC_CHAR_YI4) ) ) {
            //    
            m_pWord = m_pLink->pSplitWord(m_pWord, m_pWord->cwchLen() - 1);
            m_pWord->SetAttri(LADef_numCode);
            m_pWord->SetAttri(LADef_numChinese);
            m_pWord->pNextWord()->SetAttri(LADef_numInteger);
            m_pWord->pNextWord()->SetAttri(LADef_amtApprox);
            m_pWord->pNextWord()->SetAttri(LADef_numChinese);
            //_DUMPCASE(m_pLink, m_pWord, 1004);
        } else if ( m_pWord->cwchLen() == 2 &&
                    ( m_pWord->fIsWordText(SC_WORD_WANLIANG) ||
                      m_pWord->fIsWordText(SC_WORD_YI4LIANG) ) ) {
            //  or 
            m_pWord = m_pLink->pSplitWord(m_pWord, 1);
            m_pWord->SetAttri(LADef_numInteger);
            m_pWord->SetAttri(LADef_numChinese);
            m_pWord->SetAttri(LADef_amtApprox);
            if (!fRecheckLexInfo(m_pWord->pNextWord())) {
                assert(0);
            }
            //_DUMPCASE(m_pLink, m_pWord, 1006);
        } else {
            m_pWord->SetErrID(ERRDef_NUMERIAL);
            //_DUMPCASE(m_pLink, m_pWord, 1003);
        }
    }
    return;
}


void CMorph::numGanZhiHandler()     // 
{
    // Occurs 29 times in 20M IME Corpus
    assert(!m_pWord->fIsTail());

    m_pLink->MergeWithNext(m_pWord);
    if (!m_pWord->fIsTail() && m_pWord->pNextWord()->fIsWordChar(SC_CHAR_NIAN)){
        m_pLink->MergeWithNext(m_pWord);
    }
    m_pWord->SetAttri(LADef_posT);
    //_DUMPLINK(m_pLink, m_pWord);
    return;
}


/*============================================================================
//  Following case processors:
//      Return NUM_PROCESSED if merged successfully or any error found
//      Return NUM_UNPROCESS if could not merged
//      Return NUM_ERROR if any error occurred, the error code in m_iecError
============================================================================*/

//  Ordinal number processors: called by BindOrdinal()
inline int CMorph::ordDi_Proc()         // 
{
    if (m_pWord->fGetAttri(LADef_numInteger) &&
        !m_pWord->fGetAttri(LADef_amtApprox) ||
        m_pWord->fIsWordChar(SC_CHAR_JI)) {
        //  + () or  + 
        USHORT    iStyle;
        if (m_pWord->fGetAttri(LADef_numChinese)) {
            iStyle = LADef_numChinese;
        } else if (m_pWord->fGetAttri(LADef_numArabic)) {
            iStyle = LADef_numArabic;
        } else if (m_pWord->fGetAttri(LADef_numSBCS)) {
            iStyle = LADef_numSBCS;
        } else if (m_pWord->fGetAttri(LADef_numMixed)){
            iStyle = LADef_numMixed;
        } else {
            assert(0);
            iStyle = 0;
        }
        m_pWord = m_pWord->pPrevWord();
        m_pLink->MergeWithNext(m_pWord);
        m_pWord->SetAttri(iStyle);
        m_pWord->SetAttri(LADef_numOrdinal);
        // Properties of LADef_numNumber are set in upper level
        //_DUMPLINK(m_pLink, m_pWord);
        return NUM_PROCESSED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return NUM_UNPROCESS;
}

inline int CMorph::ordChu_Proc()            // 
{
    if (m_pWord->fGetFlag(CWord::WF_CHAR) &&
        m_pWord->fGetAttri(LADef_numChinese) &&
        m_pWord->fGetAttri(LADef_numInteger) ) {
        //  + 
        m_pWord = m_pWord->pPrevWord();
        m_pLink->MergeWithNext(m_pWord);
        m_pWord->SetAttri(LADef_numOrdinal);
        // Properties of LADef_numNumber are set in upper level
        //_DUMPLINK(m_pLink, m_pWord);
        return NUM_PROCESSED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return NUM_UNPROCESS;
}


//  Decimal number processors: called by BindDecimal()
inline int CMorph::decBaiFen_Proc()     // 
{
    if (m_pWord->fGetAttri(LADef_numInteger) ||
        m_pWord->fGetAttri(LADef_numDecimal) ||
        m_pWord->fIsWordChar(SC_CHAR_JI) ) {

        if (m_pWord->fGetAttri(LADef_numChinese)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord);
            if (!m_pWord->fIsHead() &&
                m_pWord->pPrevWord()->fGetAttri(LADef_numInteger)) {

                if (m_pWord->pPrevWord()->fGetAttri(LADef_numChinese)) {
                    m_pWord = m_pWord->pPrevWord();
                    m_pLink->MergeWithNext(m_pWord);
                    //_DUMPLINK(m_pLink, m_pWord);
                } else {
                    // Error: 3
                    m_pWord->pPrevWord()->SetErrID(ERRDef_NUMERIAL);
                    //_DUMPLINK(m_pLink, m_pWord);
                }
            }
            m_pWord->SetAttri(LADef_numPercent);
            m_pWord->SetAttri(LADef_numNumber);
            //_DUMPLINK(m_pLink, m_pWord);
            return NUM_PROCESSED;
        } else {
            // Error: 50
            m_pWord->SetErrID(ERRDef_NUMERIAL);
            //_DUMPLINK(m_pLink, m_pWord);
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return NUM_UNPROCESS;
}


inline int CMorph::decCheng_Proc()          // 
{
    CWord* pWord;

    assert(m_pWord->pNextWord()->fIsWordChar(SC_CHAR_CHENG));

    if (!(m_pWord->fGetFlag(CWord::WF_CHAR) && m_pWord->fGetAttri(LADef_numInteger)) &&
        !(m_pWord->cwchLen() == 2 && fValidApproxNum(m_pWord->pwchGetText())) ) {
        // 
        m_pLink->MergeWithNext(m_pWord);
        m_pWord->SetErrID(ERRDef_NUMERIAL);
        //_DUMPLINK(m_pLink, m_pWord);
        return NUM_PROCESSED;
    }
    // Merge with 
    m_pLink->MergeWithNext(m_pWord);

    // Test number after 
    if (!m_pWord->fIsTail()) {
        pWord = m_pWord;
        m_pWord = m_pWord->pNextWord();
        if (GetNumber() == NUM_PROCESSED &&
            m_pWord->fGetFlag(CWord::WF_CHAR) &&
            m_pWord->fGetAttri(LADef_numInteger)) {
            // 
            m_pLink->MergeWithNext(pWord);
            //_DUMPLINK(m_pLink, m_pWord);
        } else if (m_pWord->fIsWordChar(SC_CHAR_BAN)) { // 
            m_pLink->MergeWithNext(pWord);
            //_DUMPLINK(m_pLink, m_pWord);
        }
        m_pWord = pWord;
    }

    // Test  or 
    if (!m_pWord->fIsHead() && !m_pWord->pPrevWord()->fIsHead()) {
        pWord = m_pWord->pPrevWord();
        if (pWord->fGetFlag(CWord::WF_CHAR) &&
            pWord->pPrevWord()->fGetFlag(CWord::WF_CHAR) &&
            pWord->pPrevWord()->fGetAttri(LADef_numInteger) && 
            ( pWord->fIsWordChar(SC_CHAR_DUNHAO) || 
              pWord->fIsWordChar(SC_CHAR_ZHI4)) ) {

            m_pWord = pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord);
            m_pLink->MergeWithNext(m_pWord);
            m_pWord->SetAttri(LADef_amtApprox);
            //_DUMPLINK(m_pLink, m_pWord);
        }
    }

    m_pWord->SetAttri(LADef_numPercent); // 
    m_pWord->SetAttri(LADef_numNumber);
    //_DUMPLINK(m_pLink, m_pWord);
    return NUM_PROCESSED;
}


inline int CMorph::decDian_Proc()           // 
{
    CWord*  pWord;
    int     iret = NUM_PROCESSED;

    assert(m_pWord->pNextWord()->fIsWordChar(SC_CHAR_DIAN3));

    if (!m_pWord->pNextWord()->fIsTail()) {
        pWord = m_pWord;
        m_pWord = m_pWord->pNextWord()->pNextWord();
        if (GetNumber() == NUM_PROCESSED &&
            m_pWord->fGetAttri(LADef_numChinese)) {
            //   
            BOOL fTime = m_pWord->fGetAttri(LADef_numInteger);
            m_pLink->MergeWithNext(pWord);
            m_pLink->MergeWithNext(pWord);
            if (fTime && !pWord->fIsTail() && pWord->pNextWord()->fIsWordChar(SC_CHAR_FEN)){
                // Merge with : 
                m_pLink->MergeWithNext(pWord);
                if (!pWord->fIsTail() &&
                    pWord->pNextWord()->fGetAttri(LADef_numChinese)) {

                    m_pWord = pWord->pNextWord();
                    if (NUM_PROCESSED == GetNumber() &&
                        !m_pWord->fIsTail() &&
                        m_pWord->pNextWord()->fIsWordChar(SC_CHAR_MIAO)) {
                        // Merge with  + 
                        m_pLink->MergeWithNext(pWord);
                        m_pLink->MergeWithNext(pWord);
                    }
                }
                pWord->SetAttri(LADef_tmGapMinute);
                pWord->SetAttri(LADef_tmPoint);
                pWord->SetAttri(LADef_posT);
                //_DUMPCASE(m_pLink, pWord, 1001);
            } else {
                if (pWord->fIsWordLastChar(SC_CHAR_SHI2)) { // 
                    pWord->SetErrID(ERRDef_NUMERIAL);
                } else { // Valid 
                    pWord->SetAttri(LADef_numDecimal);
                    pWord->SetAttri(LADef_numNumber);
                    pWord->SetAttri(LADef_numChinese);
                    //_DUMPCASE(m_pLink, pWord, 1002);
                }
            }
        } else {
            iret = NUM_UNPROCESS;
            //_DUMPLINK(m_pLink, pWord);
        }
        m_pWord = pWord;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return iret;
}


inline int CMorph::decFenZhi_Proc()     // 
{
    BOOL fError = FALSE;

    if (!m_pWord->fGetAttri(LADef_numChinese)) {
        fError = TRUE;
        //_DUMPLINK(m_pLink, m_pWord);
    }
    m_pWord = m_pWord->pPrevWord();
    m_pLink->MergeWithNext(m_pWord);
    if (!m_pWord->fIsHead() &&
        m_pWord->pPrevWord()->fGetAttri(LADef_numChinese)) {

        m_pWord = m_pWord->pPrevWord();
        m_pLink->MergeWithNext(m_pWord);
    } else {
        fError = TRUE;
        //_DUMPLINK(m_pLink, m_pWord);
    }
    if (fError) {
        m_pWord->SetErrID(ERRDef_NUMERIAL);
    }
    m_pWord->SetAttri(LADef_numPercent);
    m_pWord->SetAttri(LADef_numNumber);
    return NUM_PROCESSED;
}


inline int CMorph::decBei_Proc()            // 
{
    m_pLink->MergeWithNext(m_pWord);
    if (!m_pWord->fIsTail() &&
        m_pWord->pNextWord()->fIsWordChar(SC_CHAR_BAN)) { 
        // 
        m_pLink->MergeWithNext(m_pWord);
        //_DUMPLINK(m_pLink, m_pWord);
    }
    m_pWord->SetAttri(LADef_numPercent);
    m_pWord->SetAttri(LADef_numNumber);
    //_DUMPLINK(m_pLink, m_pWord);
    return NUM_PROCESSED;
}



//  Level 4:
//  Service routines

//  Test 2-char Chinese string, and return whether it is a valid approx number
BOOL CMorph::fValidApproxNum(WCHAR* pwchWord)
{
    static WCHAR* rgszApproxNum[] = { 
                    SC_APXNUM_YILIANG ,    // L"\x4e00\x4e24"   // ""
                    SC_APXNUM_YIER    ,    // L"\x4e00\x4e8c"   // ""
                    SC_APXNUM_QIBA    ,    // L"\x4e03\x516b"   // ""
                    SC_APXNUM_SANLIANG,    // L"\x4e09\x4e24"   // ""
                    SC_APXNUM_SANWU   ,    // L"\x4e09\x4e94"   // ""
                    SC_APXNUM_SANSI   ,    // L"\x4e09\x56db"   // ""
                    SC_APXNUM_LIANGSAN,    // L"\x4e24\x4e09"   // ""
                    SC_APXNUM_ERSAN   ,    // L"\x4e8c\x4e09"   // ""
                    SC_APXNUM_WULIU   ,    // L"\x4e94\x516d"   // ""
                    SC_APXNUM_SIWU    ,    // L"\x56db\x4e94"   // ""
                    SC_APXNUM_LIUQI   ,    // L"\x516d\x4e03"   // ""
                    SC_APXNUM_BAJIU        // L"\x516b\x4e5d"   // ""
    };
    for (int i = 0; i < sizeof(rgszApproxNum) / sizeof(rgszApproxNum[0]); i++) {
        if (*((DWORD UNALIGNED *)pwchWord) == *((DWORD*)(rgszApproxNum[i]))) {
            return TRUE;
        }
    }
    return FALSE;
}


// Test duplicated conjunction char in the word
BOOL CMorph::fCheckDupChar(CWord* pWord)
{
    if (pWord->pNextWord() == NULL) {
        return FALSE;
    }
    int cw = pWord->cwchLen() - 1;
    for (int i = 0; i < cw; i++) {
        LPWSTR pwChar = pWord->pwchGetText();
        if (pwChar[i] == pwChar[i+1]) {
            return TRUE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\morph1.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CMorph
Purpose:    Implement resegmentation of some secific ambiguous words
Notes:      
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#include "myafx.h"

#include "morph.h"
#include "wordlink.h"
#include "lexicon.h"
#include "scchardef.h"
//#include "engindbg.h"
#include "proofec.h"

#define AMBI_UNRESEG    0
#define AMBI_RESEGED    1
#define AMBI_ERROR      2

/*============================================================================
Private functions for adjusting specific kind of ambiguities
============================================================================*/

/*============================================================================
CMorph::fAmbiAdjust():
    Scan the word link and handle the specific class of words (LADef_genAmbiMorph)
    We use table driven again to handle the specific words
============================================================================*/
BOOL CMorph::fAmbiAdjust()
{
    assert(m_iecError == 0); // the error code public field should be cleared
    assert(m_pLink != NULL);

    m_pWord = m_pLink->pGetHead();
    assert(m_pWord);

    if (m_pWord->fIsTail()) {
        return TRUE;
    }

    // Scan from left to right for pattern match
    for (; m_pWord && m_pWord->pNextWord() != NULL;
           m_pWord = m_pWord->pNextWord()) {
        if (m_pWord->fGetAttri(LADef_genAmbiMorph)) {
            if (ResegWordsHandler() == AMBI_ERROR) {
                return FALSE;
            }
        }
    }
    return TRUE;
}


#define ID_ambiShiFen   1       // 
#define ID_ambiZhiYi    2       // 
#define ID_ambiYiDian   3       // 
#define ID_ambiYiShi    4       // 
#define ID_ambiBaDu     5       // 
#define ID_ambiBaiNian  6       // 
#define ID_ambiWanFen   7       // 

//  Dispatch the control to specific word processor
int CMorph::ResegWordsHandler()
{
    static struct { 
        WCHAR*  m_lpszKey;
        int     m_idEntry;
        } rgResegEntry[] = {
            { SC_WORD_YISHI, ID_ambiYiShi },    // L"\x4e00\x65f6"  // ""
            { SC_WORD_YIDIAN, ID_ambiYiDian },  // L"\x4e00\x70b9"  // ""
            { SC_WORD_WANFEN, ID_ambiWanFen },  // L"\x4e07\x5206"  // ""
            { SC_WORD_ZHIYI, ID_ambiZhiYi },    // L"\x4e4b\x4e00"  // ""
            { SC_WORD_BADU, ID_ambiBaDu },      // L"\x516b\x5ea6"  // ""
            { SC_WORD_SHIFEN, ID_ambiShiFen },  // L"\x5341\x5206"  // ""
            { SC_WORD_BAINIAN, ID_ambiBaiNian } // L"\x767e\x5e74"  // ""
        };

    assert(m_pWord->fGetAttri(LADef_genAmbiMorph));

    WCHAR*  pwchWord = m_pWord->pwchGetText();
    int     lo = 0, hi = sizeof(rgResegEntry) / sizeof(rgResegEntry[0]) - 1;
    int     mi, icmp = 0;
    int     idEntry = -1;

    while (lo <= hi) {
        mi = (lo + hi) / 2;
        // compare the text
        WCHAR*  pwchKey = rgResegEntry[mi].m_lpszKey;
        int     i = 0;
        while (1) {
            if (pwchKey[i] == L'\0') { 
                if (i < m_pWord->cwchLen()) {
                    icmp = 1; 
                }
                break; 
            }
            if (i >= m_pWord->cwchLen()) {
                icmp = -1;
                break;
            }
            if ((icmp = (pwchWord[i] - pwchKey[i])) != 0) {
                break;
            }
            i++;
        }
        // locate next mid point
        if (icmp < 0) {
            hi = mi - 1;
        } else if (icmp > 0) {
            lo = mi + 1;
        } else { // match!
            idEntry = rgResegEntry[mi].m_idEntry;
            break;
        }
    }
    if (idEntry == -1) {
        assert(0); // Uncovered cases
        return AMBI_UNRESEG;
    }
    // Handle case by case
    switch (idEntry) {
        case ID_ambiShiFen:
            return ambiShiFen_Proc();

        case ID_ambiZhiYi:
            return ambiZhiYi_Proc();

        case ID_ambiYiDian:
            return ambiYiDian_Proc();

        case ID_ambiYiShi:
            return ambiYiShi_Proc();

        case ID_ambiBaDu:       // 
            return ambiBaDu_Proc();

        case ID_ambiBaiNian:    // 
            return ambiBaiNian_Proc();

        case ID_ambiWanFen:     // 
            return ambiWanFen_Proc();

        default:
            assert(0);
            break;
    }
    return AMBI_UNRESEG;
}


/*============================================================================
*   Following ambi words processors:
*       Return AMBI_RESEGED if ambi reseg successfully or any error found
*       Return AMBI_UNRESEG if could not reseg
*       Return AMBI_ERROR if any error occurred, the error code in m_iecError
============================================================================*/

inline int CMorph::ambiShiFen_Proc()    // 
{
    if (!m_pWord->fIsHead() &&
        ( m_pWord->pPrevWord()->fGetAttri(LADef_numChinese) ||
          m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_SHI) ||  // 
          m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_DIAN3)) ) { // 
        // 
        //_DUMPLINK(m_pLink, m_pWord);
    } else if (!m_pWord->fIsTail() && 
               ( m_pWord->pNextWord()->fIsWordText(SC_WORD_ZHIYI) ||   // 
                 m_pWord->pNextWord()->fIsWordChar(SC_CHAR_ZHI)) ) {   // 
        // 
        //_DUMPLINK(m_pLink, m_pWord);
    } else {
        // Used as adv. 
        // Occur 3983 times in 40M Corpus
        //_DUMPLINK(m_pLink, m_pWord);
        return AMBI_UNRESEG;
    }

    // Occur 209 times in 40M Corpus. Re-break it into two single-char words
    if (!fBreakIntoChars()) {
        return AMBI_ERROR;
    }
    return AMBI_RESEGED;
}


inline int CMorph::ambiZhiYi_Proc() // 
{
    if (!m_pWord->fIsHead() && m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_FEN)){
        if (!fBreakIntoChars()) {
            return AMBI_ERROR;
        }
        // Merge  with previous 
        m_pWord = m_pWord->pPrevWord();
        m_pLink->MergeWithNext(m_pWord);
        if (!fRecheckLexInfo(m_pWord)) {
            return AMBI_ERROR;
        }
        //_DUMPLINK(m_pLink, m_pWord);
        return AMBI_RESEGED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AMBI_UNRESEG;
}


inline int CMorph::ambiYiDian_Proc()    // 
{
    if( !m_pWord->fIsTail() &&
        m_pWord->pNextWord()->fGetAttri(LADef_numChinese) ||
        !m_pWord->fIsHead() &&
        m_pWord->pPrevWord()->fGetAttri(LADef_numChinese) ) {

        if (!fBreakIntoChars()) {
            return AMBI_ERROR;
        }
        //_DUMPLINK(m_pLink, m_pWord);
        return AMBI_RESEGED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AMBI_UNRESEG;
}


inline int CMorph::ambiYiShi_Proc() // 
{
    if (!m_pWord->fIsHead() && 
        ( m_pWord->pPrevWord()->fGetAttri(LADef_numChinese) ||
          m_pWord->pPrevWord()->fGetAttri(LADef_posT) ||
          m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_CHU) ||
          m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_GAO)) ) {
        if (!fBreakIntoChars()) {
            return AMBI_ERROR;
        }
        //_DUMPLINK(m_pLink, m_pWord);
        return AMBI_RESEGED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AMBI_UNRESEG;
}


inline int CMorph::ambiBaDu_Proc()      // 
{
    if (!m_pWord->fIsHead() &&
        m_pWord->pPrevWord()->fGetAttri(LADef_numChinese)) {
        //   => break 
        if (!fBreakIntoChars()) {
            return AMBI_ERROR;
        }
        //_DUMPLINK(m_pLink, m_pWord);
        return AMBI_RESEGED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AMBI_UNRESEG;
}


inline int CMorph::ambiBaiNian_Proc()   // 
{
    if (!m_pWord->fIsHead() &&
        m_pWord->pPrevWord()->fGetAttri(LADef_numChinese)) {
        //   => break 
        if (!fBreakIntoChars()) {
            return AMBI_ERROR;
        }
        //_DUMPLINK(m_pLink, m_pWord);
        return AMBI_RESEGED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AMBI_UNRESEG;
}


inline int CMorph::ambiWanFen_Proc()    // 
{
    if (!m_pWord->fIsTail() && 
        ( m_pWord->pNextWord()->fIsWordText(SC_WORD_ZHIYI) ||   // 
          m_pWord->pNextWord()->fIsWordChar(SC_CHAR_ZHI)) ) {   // 
        // 
        if (!fBreakIntoChars()) {
            return AMBI_ERROR;
        }
        //_DUMPLINK(m_pLink, m_pWord);
        return AMBI_RESEGED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AMBI_UNRESEG;
}


/*============================================================================
Service functions for adjusting specific kind of ambiguities
============================================================================*/

/*============================================================================
CMorph::fBreakIntoChars():
    Break a multi-char words into single-char words and reset their property by
    lookup the lexicon char by char. 
Return:
    TRUE if successful, and keep m_pWord point to the first single-char word
    FALSE if any error occurred
============================================================================*/
BOOL CMorph::fBreakIntoChars()
{
    if (m_pWord->fGetFlag(CWord::WF_SBCS) ||
        m_pWord->fGetFlag(CWord::WF_REDUCED)) {
        // Could not rebreak the reduced node or SBCS word node
        assert(0); 
        m_iecError = PRFEC::gecUnknown;
        return FALSE;
    }
    CWord* pWord = m_pWord;
#ifdef DEBUG
    CWord* dbg_pWord = m_pWord->pPrevWord();
#endif // DEBUG
    CWordInfo winfo;
    assert(!pWord->fGetFlag(CWord::WF_CHAR));
    while (!pWord->fGetFlag(CWord::WF_CHAR)) {
        if ((pWord = m_pLink->pSplitWord(pWord, 1)) == NULL) { // OOM in pSplitWord()
            m_iecError = PRFEC::gecOOM;
            return FALSE;
        }
        if (!m_pLex->fGetCharInfo(*(pWord->pwchGetText()), &winfo)) {
            m_iecError = PRFEC::gecUnknown;
            return FALSE;
        }
        // Set the word property
        pWord->SetWordID(winfo.GetWordID());
        pWord->SetLexHandle(winfo.GetLexHandle());
        for (USHORT i = 0; i < winfo.AttriNum(); i++) {
            pWord->SetAttri(winfo.GetAttri(i));
        }
        pWord = pWord->pNextWord();
    }
    // Lookup the last char in the lexicon
    if (!m_pLex->fGetCharInfo(*(pWord->pwchGetText()), &winfo)) {
        m_iecError = PRFEC::gecUnknown;
        return FALSE;
    }
    // Set the word property
    pWord->SetWordID(winfo.GetWordID());
    pWord->SetLexHandle(winfo.GetLexHandle());
    for (USHORT i = 0; i < winfo.AttriNum(); i++) {
        pWord->SetAttri(winfo.GetAttri(i));
    }

#ifdef DEBUG
    assert(dbg_pWord == m_pWord->pPrevWord());
#endif // DEBUG
    
    return TRUE;
}

/*============================================================================
CMorph::fRecheckLexInfo(CWord* pWord):
    Lookup the lexicon for the given word node, and reset the lex prop of it.
Return:
    TRUE if the word can be found in the lexicon
    FALSE if the word can not be found in the lexicon
============================================================================*/
BOOL CMorph::fRecheckLexInfo(CWord* pWord)
{
    assert(pWord->pNextWord());
    assert(!pWord->fGetFlag(CWord::WF_SBCS));

    CWordInfo   winfo;
    USHORT      cwchLen = pWord->cwchLen();
    // Lookup the lexicon for the word
    if (cwchLen != m_pLex->cwchMaxMatch(pWord->pwchGetText(),cwchLen, &winfo)){
        m_iecError = PRFEC::gecUnknown;
        return FALSE;
    }
    // Set the word property
    pWord->SetWordID(winfo.GetWordID());
    pWord->SetLexHandle(winfo.GetLexHandle());
    for (USHORT i = 0; i < winfo.AttriNum(); i++) {
        pWord->SetAttri(winfo.GetAttri(i));
    }
    if (cwchLen == 1) {
        pWord->SetFlag(CWord::WF_CHAR);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\morph.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CMorph
Purpose:    Define the morphological analysis on the sentence:
                1. Merge DBCS foreign character string (morph.cpp)
                2. Hnadle punctuation pair check and combind short quotation (morph.cpp)
                3. Resegment on some specific ambiguous words (morph1.cpp)
                4. Binding numerial words (morph2.cpp)
                5. Handle special M+Q usage (morph2.cpp)
                6. Handle affix attachment and usage of some specific words (morph3.cpp)
                7. Identify morphological patterns(Repeat, Pattern and 
                   Separacte words) (morph4.cpp)
                8. Merge 2-char compond verb and noun that are OOV (morph5.cpp)
            Morph-analysis is the first step in the Chinese parsing
Notes:      In order to make the Morphological module easy to manage, this class
            will be implemented in severial cpp files:
                morph.cpp, morph1.cpp, morph2.cpp, morph3.cpp, morph4.cpp, morph5.cpp
            All these cpp files share this header file
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#ifndef _MORPH_H_
#define _MORPH_H_

// Forward declaration of classes
class CLexicon;
class CWordLink;
struct CWord;
struct CWordInfo;

//   Define the CMorph class
class CMorph
{
    public:
        CMorph();
        ~CMorph();

        // Initialize the morph class
        int ecInit(CLexicon* pLexicon);

        // process affix attachment
        int ecDoMorph(CWordLink* pLink, BOOL fAfxAttach = TRUE);

    private:
        int         m_iecError; // runtime error code

        CWordLink*  m_pLink;
        CLexicon*   m_pLex;

        CWord*      m_pWord;

    private:
        // Terminate the Morph class
        void TermMorph(void);

        /*============================================================================
        Private functions for pre-combind process
        ============================================================================*/

        //  Pre-combind process control function.
        //  One pass scan the WordLink and call process functions
        BOOL fPreCombind();

        //  DBForeignHandler combind the conjunctive DB foreign characters
        int DBForeignHandler(void);
        //  Short quotation merge proc
        int QuoteHandler(void);

        /*============================================================================
        In order to handle different operation for different quote marks pair, 
        I use a separate process function for each kind of quote pair
        ============================================================================*/
        int preQuote1_Proc(void);   //  
        int preQuote2_Proc(void);   //  
        int preQuote3_Proc(void);   //  
        int preQuote4_Proc(void);   //  
        int preQuote5_Proc(void);   //  
        int preQuote6_Proc(void);   //  
        int preQuote7_Proc(void);   //  
        int preQuote8_Proc(void);   //  
        int preQuote9_Proc(void);   //  
        int preQuote10_Proc(void);  //  
        
        /*
        *   Common routine to handle       
        *   Merge into one node means will not proofread on the quote text any more!!!
        */
        int preQuoteMerge(WCHAR wchLeft, WCHAR wchRight);


        /*============================================================================
        //  Private functions for adjusting specific kind of ambiguities
        ============================================================================*/
        //  Scan the word link and handle the specific class of words (LADef_genAmbiMorph)
        //  We use table driven again to handle the specific words
        BOOL fAmbiAdjust();

        //  Dispatch the control to specific word processor
        int ResegWordsHandler();

        /*
        *   Following ambi words processors:
        *       Return AMBI_RESEGED if ambi reseg successfully or any error found
        *       Return AMBI_UNRESEG if could not reseg
        *       Return AMBI_ERROR if any error occurred, the error code in m_iecError
        */
        int ambiShiFen_Proc();  // 
        int ambiZhiYi_Proc();   // 
        int ambiYiDian_Proc();  // 
        int ambiYiShi_Proc();   // 
        int ambiBaDu_Proc();    // 
        int ambiBaiNian_Proc(); // 
        int ambiWanFen_Proc();  // 

        //  Break a multi-char words into single-char words and reset their property by
        //  lookup the lexicon char by char. 
        //  Return TRUE if successful, and keep m_pWord point to the first single-char word
        //  Return FALSE if any error occurred
        BOOL fBreakIntoChars();

        //  Lookup the lexicon for the given word node, and reset the lex prop of it.
        //  Return TRUE if the word can be found in the lexicon
        //  Reture FALSE if the word can not be found in the lexicon
        BOOL fRecheckLexInfo(CWord* pWord);


        /*============================================================================
        //  Private functions for Numerical words analysis
        ============================================================================*/
        /*--------- Level 1 ---------*/
        //  Numerical Analysis control function. return TRUE if done
        //  Return FALSE if error occurred, and the error code in m_iecError
        BOOL fNumerialAnalysis();


        /*--------- Level 2 ---------*/
        //  Analysis number word string, check error and mark the class of the merged
        //  number words.
        //  Note: number testing from current word!
        int GetNumber();

        //  
        int BindOrdinal();
        //  
        int BindDecimal();
        //  : //
        int BindRange();
        
        /*--------- Level 3 ---------*/
        //  Parser for SBCS number called by GetNumber()
        void numSBCSParser(); 
        //  Parser for DBCS Arabic number called by GetNumber()
        void numArabicParser(); 
        //  Parser for DBCS Chinese number called by GetNumber()
        void numChineseParser(); 
        //  Bind  called by GetNumber()
        void numGanZhiHandler();
        
        /*
        *   Following case processors:
        *       Return NUM_PROCESSED if merged successfully or any error found
        *       Return NUM_UNPROCESS if could not merged
        *       Return NUM_ERROR if any error occurred, the error code in m_iecError
        */
        //  Ordinal number processors: called by BindOrdinal()
        int ordDi_Proc();           // 
        int ordChu_Proc();          // 

        //  Decimal number processors: called by BindDecimal()
        int decBaiFen_Proc();       // , , 
        int decBei_Proc();          // 
        int decCheng_Proc();        // 
        int decDian_Proc();         // 
        int decFenZhi_Proc();       // 

        /*--------- Level 4 ---------*/
        //  Service routines
        //  Test 2-char Chinese string, and return whether it is a valid approx number
        BOOL fValidApproxNum(WCHAR* pwchWord);
        // Test duplicated conjunction char in the word
        BOOL fCheckDupChar(CWord* pWord);


        //--------------------------------------------------------------------------------
        //  Private functions for affix attachment
        //--------------------------------------------------------------------------------
        //  Affix attachment control function. Return TRUE if done.
        //  Return FALSE if error occurred, and set error code in m_iecError
        BOOL fAffixAttachment();

        /* 
        *   Prefix and suffix handler functions:
        *       Return AFFIX_ATTACHED if attached successfully
        *       Return AFFIX_UNATTACH if could not attached
        *       Return AFFIX_ERROR if runtime error occurred
        */
        int PrefixHandler(void);
        int SuffixHandler(void);
        
        //  Get Prefix ID, return -1 if pWord is not a prefix
        int GetPrefixID(void);
        //  Get Suffix ID, return -1 if pWord is not a suffix
        int GetSuffixID(void);

        /* 
        *   Prefix process functions:
        *       Return AFFIX_ATTACHED if attached successfully
        *       Return AFFIX_UNATTACH if could not attached
        *       Return AFFIX_ERROR if runtime error occurred
        */
        int pfxAa_Proc(void);       // 
        int pfxChao_Proc(void);     // 
        int pfxDai_Proc(void);      // 
        int pfxFan_Proc(void);      // 
        int pfxFei_Proc(void);      // 
        int pfxFu_Proc(void);       // 
        int pfxGuo_Proc(void);      // 
        int pfxLao_Proc(void);      // 
        int pfxWei1_Proc(void);     // 
        int pfxWei3_Proc(void);     // 
        int pfxXiao_Proc(void);     // 
        int pfxZhun_Proc(void);     // 
        int pfxZong_Proc(void);     // 

        /* 
        *   Suffix process functions:
        *       Return AFFIX_ATTACHED if attached successfully
        *       Return AFFIX_UNATTACH if could not attached
        *       Return AFFIX_ERROR if runtime error occurred
        */
        int sfxZhang_Proc(void);    // 
        int sfxChang_Proc(void);    // 
        int sfxDan_Proc(void);      // 
        int sfxDui_Proc(void);      // 
        int sfxEr_Proc(void);       // 
        int sfxFa_Proc(void);       // 
        int sfxFang_Proc(void);     // 
        int sfxGan_Proc(void);      // 
        int sfxGuan_Proc(void);     // 
        int sfxHua_Proc(void);      // 
        int sfxJi_Proc(void);       // 
        int sfxJia_Proc(void);      // 
        int sfxJie_Proc(void);      // 
        int sfxLao_Proc(void);      // 
        int sfxLv_Proc(void);       // 
        int sfxLun_Proc(void);      // 
        int sfxMen_Proc(void);      // 
        int sfxPin_Proc(void);      // 
        int sfxQi_Proc(void);       // 
        int sfxSheng_Proc(void);    // 
        int sfxSheng3_Proc(void);   // 
        int sfxShi1_Proc(void);     // 
        int sfxShi4_Proc(void);     // 
        int sfxShi_Proc(void);      // 
        int sfxTi_Proc(void);       // 
        int sfxTing_Proc(void);     // 
        int sfxTou_Proc(void);      // 
        int sfxXing2_Proc(void);    // 
        int sfxXing4_Proc(void);    // 
        int sfxXue_Proc(void);      // 
        int sfxYan_Proc(void);      // 
        int sfxYe_Proc(void);       // 
        int sfxYi_Proc(void);       // 
        int sfxYuan_Proc(void);     // 
        int sfxZhe_Proc(void);      // 
        int sfxZheng_Proc(void);    // 
        int sfxZhi_Proc(void);      // 
        int sfxZi_Proc(void);       // 
        
        //  sfxXing2_Proc() service function
        BOOL fCheckXingQian(CWord* pWord);
        //  sfxShi_Proc() service function
        BOOL fCheckShiQian(CWord* pWord);


        /*============================================================================
        //  Private functions for pattern identification
        ============================================================================*/
        /*
        *   Pattern match control function. 
        *   WordLink scan, procedure control and error handling. Return TRUE if finished, 
        *   or FALSE if runtime error, and set error code to m_iecError.
        */
        BOOL fPatternMatch(void);

        // DupHandler: find duplicate cases and call coordinate proc functions
        int DupHandler(void);
        // PatHandler: find pattern and call coordinate proc functions
        int PatHandler(void);
        // SepHandler: find separate word and call coordinate proc functions
        int SepHandler(void);

        // Duplicate word processing functions
        int dupNN_Proc(void);       // *N N
        int dupNAABB_Proc(void);    // A *AB B
        int dupMM_Proc(void);       // *M M
        int dupMABAB_Proc(void);    // *AB AB
        int dupMAABB_Proc(void);    // A *AB B
        int dupQQ_Proc(void);       // *Q Q
        int dupVV_Proc(void);       // *V V
        int dupVABAB_Proc(void);    // *AB AB
        int dupVAABB_Proc(void);    // A *AB B
        int dupVVO_Proc(void);      // V *VO
        int dupAA_Proc(void);       // *A A
        int dupAAABB_Proc(void);    // A *AB B
        int dupAABAB_Proc(void);    // *AB AB
        int dupABB_Proc(void);      // *AB B
        int dupZABAB_Proc(void);    // *AB AB
        int dupDD_Proc(void);       // *D D
        int dupDAABB_Proc(void);    // A *AB B
        int dupDABAB_Proc(void);    // *AB AB

        // Pattern processing functions
        int patV1_Proc(void);       // *V  V
        int patV2_Proc(void);       // *V  V
        int patV3_Proc(void);       // *V  V
        int patV4_Proc(void);       // *V  V 
        int patV5_Proc(void);       // *V  V 
        int patA1_Proc(void);       // A  *AB
        int patD1_Proc(void);       // *D A D B
        int patABuA_Proc(void);     // *V  V
        int patVMeiV_Proc(void);    // *V  V

        // Separate word processing functions
        int sepVO_Proc(CWord* pBin, CWordInfo* pwinfo); // 
        int sepVR_Proc(CWord* pJie, CWordInfo* pwinfo); // 
        int sepVG_Proc(CWord* pQu, CWordInfo* pwinfo);  // 

};

#endif // _MORPH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\morph3.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CMorph
Purpose:    Implement the affix attachment process in the Morph-analysis class.
Notes:      This implementation use table driven, handle prefix and suffix one by one

    How to add a new prefix or suffix handler:
            1. Mark afxPrefix or afxSuffix on the specific lex
            2. Collect all words that the affix can attached in the lexicon,
               and list these words in a separated text file with attribute def header
               name the attri with "pfx..." or "sfx...", and set group as "Morpheme"
            3. Add this attribute into the lex database, and rebuild the lexicon
               and LexProp.h file
            4. Insert the CAfxMap element into the specific mapping array, carefully
               choose the correct insert position in GBK sorting order
            5. Define the interface of affix processing function for the new affix in 
               Morph.h
            6. Implement the affix processing function to handle the attachment and 
               error detection at the correct position in this file.
            7. Insert a new case of the specific attribute ID into the switch block
               in PrefixHandler or SuffixHandler function

Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#include "myafx.h"

#include "morph.h"
#include "lexicon.h"
#include "wordlink.h"
//#include "engindbg.h"
#include "scchardef.h"
#include "slmdef.h"

//  Define local constants
#define AFFIX_UNATTACH  0
#define AFFIX_ATTACHED  1
#define AFFIX_ERROR     2


//  Declare local datatypes of structure and global variables

// Define the affix id mapping structure
struct CAfxMap {
    WCHAR   m_wchAffix;
    int     m_iAttriID;
};

// Define the Prefix ID map
static CAfxMap v_rgpfxMap[] = {
        { SC_PFXCHAR_DAI,  LADef_pfxDai  }, // 0x4ee3  // ""
        { SC_PFXCHAR_WEI3, LADef_pfxWei3 }, // 0x4f2a  // ""
        { SC_PFXCHAR_ZHUN, LADef_pfxZhun }, // 0x51c6  // ""
        { SC_PFXCHAR_FU,   LADef_pfxFu   }, // 0x526f  // ""
        { SC_PFXCHAR_FAN,  LADef_pfxFan  }, // 0x53cd  // ""
        { SC_PFXCHAR_XIAO, LADef_pfxXiao }, // 0x5c0f  // ""
        { SC_PFXCHAR_WEI1, LADef_pfxWei1 }, // 0x5fae  // ""
        { SC_PFXCHAR_ZONG, LADef_pfxZong }, // 0x603b  // ""
        { SC_PFXCHAR_LAO,  LADef_pfxLao  }, // 0x8001  // ""
        { SC_PFXCHAR_CHAO, LADef_pfxChao }, // 0x8d85  // ""
        { SC_PFXCHAR_GUO,  LADef_pfxGuo  }, // 0x8fc7  // ""
        { SC_PFXCHAR_AA,   LADef_pfxAa   }, // 0x963f  // ""
        { SC_PFXCHAR_FEI,  LADef_pfxFei  }  // 0x975e  // ""
    };

// Define the suffix ID map
static CAfxMap v_rgsfxMap[] = {
        { SC_SFXCHAR_YE,    LADef_sfxYe     },// 0x4e1a  // ""
        { SC_SFXCHAR_YI,    LADef_sfxYi     },// 0x4eea  // ""
        { SC_SFXCHAR_MEN,   LADef_sfxMen    },// 0x4eec  // ""
        { SC_SFXCHAR_TI,    LADef_sfxTi     },// 0x4f53  // ""
        { SC_SFXCHAR_ER,    LADef_sfxEr     },// 0x513f  // ""
        { SC_SFXCHAR_ZHI,   LADef_sfxZhi    },// 0x5236  // ""
        { SC_SFXCHAR_HUA,   LADef_sfxHua    },// 0x5316  // ""
        { SC_SFXCHAR_DAN,   LADef_sfxDan    },// 0x5355  // ""
        { SC_SFXCHAR_YUAN,  LADef_sfxYuan   },// 0x5458  // ""
        { SC_SFXCHAR_PIN,   LADef_sfxPin    },// 0x54c1  // ""
        { SC_SFXCHAR_QI,    LADef_sfxQi     },// 0x5668  // ""
        { SC_SFXCHAR_CHANG, LADef_sfxChang  },// 0x573a  // ""
        { SC_SFXCHAR_XING2, LADef_sfxXing2  },// 0x578b  // ""
        { SC_SFXCHAR_DUI,   LADef_sfxDui    },// 0x5806  // ""
        { SC_SFXCHAR_TOU,   LADef_sfxTou    },// 0x5934  // ""
        { SC_SFXCHAR_ZI,    LADef_sfxZi     },// 0x5b50  // ""
        { SC_SFXCHAR_XUE,   LADef_sfxXue    },// 0x5b66  // ""
        { SC_SFXCHAR_JIA,   LADef_sfxJia    },// 0x5bb6  // ""  
        { SC_SFXCHAR_SHI4,  LADef_sfxShi4   },// 0x5e02  // ""
        { SC_SFXCHAR_SHI1,  LADef_sfxShi1   },// 0x5e08  // ""
        { SC_SFXCHAR_SHI,   LADef_sfxShi    },// 0x5f0f  // ""
        { SC_SFXCHAR_XING4, LADef_sfxXing4  },// 0x6027  // ""
        { SC_SFXCHAR_GAN,   LADef_sfxGan    },// 0x611f  // ""
        { SC_SFXCHAR_FANG,  LADef_sfxFang   },// 0x65b9  // ""
        { SC_SFXCHAR_JI,    LADef_sfxJi     },// 0x673a  // ""
        { SC_SFXCHAR_FA,    LADef_sfxFa     },// 0x6cd5  // ""
        { SC_SFXCHAR_YAN,   LADef_sfxYan    },// 0x708e  // ""
        { SC_SFXCHAR_LV,    LADef_sfxLv     },// 0x7387  // ""  
        { SC_SFXCHAR_SHENG, LADef_sfxSheng  },// 0x751f  // ""
        { SC_SFXCHAR_JIE,   LADef_sfxJie    },// 0x754c  // ""
        { SC_SFXCHAR_ZHENG, LADef_sfxZheng  },// 0x75c7  // ""
        { SC_SFXCHAR_SHENG3,LADef_sfxSheng3 },// 0x7701  // ""
        { SC_SFXCHAR_LAO,   LADef_sfxLao    },// 0x8001  // ""
        { SC_SFXCHAR_ZHE,   LADef_sfxZhe    },// 0x8005  // ""
        { SC_SFXCHAR_TING,  LADef_sfxTing   },// 0x8247  // ""
        { SC_SFXCHAR_GUAN,  LADef_sfxGuan   },// 0x89c2  // ""
        { SC_SFXCHAR_LUN,   LADef_sfxLun    },// 0x8bba  // ""
        { SC_SFXCHAR_ZHANG, LADef_sfxZhang  } // 0x957f  // ""
    };

#ifdef DEBUG
// Verify the sorting order of the id map of prefix and suffix
static BOOL fVerifyMaps(void)
{
    for (int i = 1; i < sizeof(v_rgpfxMap) / sizeof(CAfxMap); i++) {
        if (v_rgpfxMap[i].m_wchAffix < v_rgpfxMap[i-1].m_wchAffix) {
            return FALSE;
        }
    }
    for (i = 1; i < sizeof(v_rgsfxMap) / sizeof(CAfxMap); i++) {
        if(v_rgsfxMap[i].m_wchAffix < v_rgsfxMap[i-1].m_wchAffix) {
            return FALSE;
        }
    }
    return TRUE;
}
#endif // DEBUG

                   
/*============================================================================
Implement functions of affix attachment
============================================================================*/

// Affix attachment control function
BOOL CMorph::fAffixAttachment()
{
    assert(fVerifyMaps()); // Verify the id map of prefix and suffix in debugging code
    assert(m_iecError == 0); // the error code public field should be cleared
    assert(m_pLink != NULL);

    int iret;

    m_pWord = m_pLink->pGetHead();
    assert (m_pWord != NULL); // error: missing the terminate word node!

    // First pass scan fron left to right, suffix precede to prefix
    for ( ; m_pWord; m_pWord = m_pWord->pNextWord()) {

        if (!m_pWord->fGetAttri(LADef_afxSuffix)) {
            continue;
        }
        if ((iret = SuffixHandler()) == AFFIX_ERROR) {
            assert(0); // runtime error in suffix attachment
            return FALSE;
        } else if (iret == AFFIX_ATTACHED) {
            // suffix attached successfully
            assert(m_pWord->fGetFlag(CWord::WF_REDUCED));
            if (m_pWord->pPrevWord() &&
                m_pWord->pPrevWord()->fGetAttri(LADef_afxPrefix)) {
                // previous word is a prefix, try to attach
                m_pWord = m_pWord->pPrevWord(); // move current word pointer to prev word
                if ((iret = PrefixHandler()) == AFFIX_ERROR) {
                    assert(0); // runtime error in prefix attachment
                    return FALSE;
                } else if (iret == AFFIX_UNATTACH) {
                    assert(m_pWord->pNextWord() != NULL);
                    m_pWord = m_pWord->pNextWord();
                } else {
                }
            } // end of if (prev word is a prefix)
        } else {// end of if AFFIX_ATTACHED
        }
    }

    m_pWord = m_pLink->pGetTail();
    assert (m_pWord != NULL); // error: missing the terminate word node!
    // Second pass scan from right to left, prefix precede to suffix
    for ( m_pWord = m_pWord->pPrevWord(); m_pWord;
          m_pWord = m_pWord->pPrevWord() ) {
        if (!m_pWord->fGetAttri(LADef_afxPrefix)) {
            continue;
        }
        if ((iret = PrefixHandler()) == AFFIX_ERROR) {
            assert(0); // runtime error in prefix attachment
            return FALSE;
        } else if (iret == AFFIX_ATTACHED) { // prefix attached successfully
            assert(m_pWord->fGetFlag(CWord::WF_REDUCED));
            if (m_pWord->pNextWord() &&
                m_pWord->pNextWord()->fGetAttri(LADef_afxSuffix)) {
                // next word is a suffix, try to attach
                m_pWord = m_pWord->pNextWord(); // move current word pointer to next word
                if ((iret = SuffixHandler()) == AFFIX_ERROR) {
                    assert(0); // runtime error in suffix attachment
                    return FALSE;
                } else if (iret == AFFIX_UNATTACH) {
                    assert(m_pWord->pPrevWord() != NULL);
                    m_pWord = m_pWord->pPrevWord();
                } else {
                }
            } // end of if (next word is a suffix)
        } else {
        }
    } 

    return TRUE;
}


/*============================================================================
CMorph::PrefixHandler(void):
    Prefix handler functions:
Returns:
    AFFIX_ATTACHED if attached successfully
    AFFIX_UNATTACH if could not attached
    AFFIX_ERROR if runtime error occurred
============================================================================*/

int CMorph::PrefixHandler(void)
{
    assert(m_pWord->fGetAttri(LADef_afxPrefix));

    int iret = AFFIX_UNATTACH;
    
    switch(GetPrefixID()) {
        case LADef_pfxAa:       // 
            iret = pfxAa_Proc();
            break;

        case LADef_pfxChao:     // 
            iret = pfxChao_Proc();
            break;

        case LADef_pfxDai:      // 
            iret = pfxDai_Proc();
            break;

        case LADef_pfxFan:      // 
            iret = pfxFan_Proc();
            break;

        case LADef_pfxFei:      // 
            iret = pfxFei_Proc();
            break;

        case LADef_pfxFu:       // 
            iret = pfxFu_Proc();
            break;

        case LADef_pfxGuo:      // 
            iret = pfxGuo_Proc();
            break;

        case LADef_pfxLao:      // 
            iret = pfxLao_Proc();
            break;

        case LADef_pfxWei1:     // 
            iret = pfxWei1_Proc();
            break;

        case LADef_pfxWei3:     // 
            iret = pfxWei3_Proc();
            break;

        case LADef_pfxXiao:     // 
            iret = pfxXiao_Proc();
            break;

        case LADef_pfxZhun:     // 
            iret = pfxZhun_Proc();
            break;

        case LADef_pfxZong:     // 
            iret = pfxZong_Proc();
            break;

        default:
            // error attri id value in lexicon
            assert(0);
            break;
    }
/*  if(iret == AFFIX_ATTACHED) {
        //_DUMPLINK(m_pLink, m_pWord);
        }
*/  return iret;
}


/*============================================================================
CMorph::SuffixHandler(void):
    Suffix handler functions:
Returns:
    AFFIX_ATTACHED if attached successfully
    AFFIX_UNATTACH if could not attached
    AFFIX_ERROR if runtime error occurred
============================================================================*/
int CMorph::SuffixHandler(void)
{
    assert(m_pWord->fGetAttri(LADef_afxSuffix));

    int iret = AFFIX_UNATTACH;
    
    switch(GetSuffixID()) {
        case LADef_sfxZhang:    // 
            iret = sfxZhang_Proc();
            break;

        case LADef_sfxChang:    // 
            iret = sfxChang_Proc();
            break;

        case LADef_sfxDan:      // 
            iret = sfxDan_Proc();
            break;

        case LADef_sfxDui:      // 
            iret = sfxDui_Proc();
            break;

        case LADef_sfxEr:       // 
            iret = sfxEr_Proc();
            break;

        case LADef_sfxFa:       // 
            iret = sfxFa_Proc();
            break;

        case LADef_sfxFang:     // 
            iret = sfxFang_Proc();
            break;

        case LADef_sfxGan:      // 
            iret = sfxGan_Proc();
            break;

        case LADef_sfxGuan:     // 
            iret = sfxGuan_Proc();
            break;

        case LADef_sfxHua:      // 
            iret = sfxHua_Proc();
            break;

        case LADef_sfxJi:       // 
            iret = sfxJi_Proc();
            break;

        case LADef_sfxJia:      // 
            iret = sfxJia_Proc();
            break;

        case LADef_sfxJie:      // 
            iret = sfxJie_Proc();
            break;

        case LADef_sfxLao:      // 
            iret = sfxLao_Proc();
            break;

        case LADef_sfxLv:       // 
            iret = sfxLv_Proc();
            break;

        case LADef_sfxLun:      // 
            iret = sfxLun_Proc();
            break;

        case LADef_sfxMen:      // 
            iret = sfxMen_Proc();
            break;

        case LADef_sfxPin:      // 
            iret = sfxPin_Proc();
            break;

        case LADef_sfxQi:       // 
            iret = sfxQi_Proc();
            break;

        case LADef_sfxSheng:    // 
            iret = sfxSheng_Proc();
            break;

        case LADef_sfxSheng3:   // 
            iret = sfxSheng3_Proc();
            break;

        case LADef_sfxShi1:     // 
            iret = sfxShi1_Proc();
            break;

        case LADef_sfxShi4:     // 
            iret = sfxShi4_Proc();
            break;

        case LADef_sfxShi:      // 
            iret = sfxShi_Proc();
            break;

        case LADef_sfxTi:       // 
            iret = sfxTi_Proc();
            break;

        case LADef_sfxTing:     // 
            iret = sfxTing_Proc();
            break;

        case LADef_sfxTou:      // 
            iret = sfxTou_Proc();
            break;

        case LADef_sfxXing2:    // 
            iret = sfxXing2_Proc();
            break;

        case LADef_sfxXing4:    //    
            iret = sfxXing4_Proc();
            break;

        case LADef_sfxXue:      // 
            iret = sfxXue_Proc();
            break;

        case LADef_sfxYan:      // 
            iret = sfxYan_Proc();
            break;

        case LADef_sfxYe:       // 
            iret = sfxYe_Proc();
            break;

        case LADef_sfxYi:       // 
            iret = sfxYi_Proc();
            break;

        case LADef_sfxYuan:     // 
            iret = sfxYuan_Proc();
            break;

        case LADef_sfxZhe:      // 
            iret = sfxZhe_Proc();
            break;

        case LADef_sfxZheng:    // 
            iret = sfxZheng_Proc();
            break;

        case LADef_sfxZhi:      // 
            iret = sfxZhi_Proc();
            break;

        case LADef_sfxZi:       // 
            iret = sfxZi_Proc();
            break;

        default:
            // error attri id setting in lexicon
            assert(0);
            break;
        }
/*  if(iret == AFFIX_ATTACHED) {
        //_DUMPLINK(m_pLink, m_pWord);
        }
*/  return iret;
}


/*============================================================================
CMorph::GetPrefixID(void):
    Get Prefix ID
Returns:
    LADef_pfx...
    -1 if m_pWord is not a prefix
============================================================================*/
inline int CMorph::GetPrefixID(void)
{
    // only single char words mark as prefix
    if (!m_pWord->fGetFlag(CWord::WF_CHAR)) {
        assert(0); // all prefix should be single char words
        return -1;
    }

    assert(m_pWord->cwchLen() == 1);

    WCHAR*   pwchWord = m_pWord->pwchGetText();
#ifdef DEBUG
    // Serialize search to verify the result
    int dbg_iret = -1;
    for (int dbg_i =0; dbg_i < sizeof(v_rgpfxMap) / sizeof(CAfxMap); dbg_i++) {
        if (v_rgpfxMap[dbg_i].m_wchAffix == *pwchWord ) {
            dbg_iret = v_rgpfxMap[dbg_i].m_iAttriID;
            break;
        }
    }
    // the attri ID of matched prefix stored in the dbg_iret.
#endif // DEBUG

    // Binary search for the specific prefix
    int lo = 0, hi = (sizeof(v_rgpfxMap) / sizeof(CAfxMap)) - 1, mi, icmp;
    while (lo <= hi) {
        mi = (lo + hi) / 2;
        if ((icmp = *pwchWord - v_rgpfxMap[mi].m_wchAffix) == 0) {
            assert(v_rgpfxMap[mi].m_iAttriID == dbg_iret);
            return v_rgpfxMap[mi].m_iAttriID;
        } else if (icmp < 0) {
            hi = mi - 1;
        } else {
            lo = mi + 1;
        }
    }
    assert(dbg_iret == -1);
    return -1; // can not found the prefix!
}


/*============================================================================
CMorph::GetPrefixID(void):
    Get Suffix ID
Returns:
    LADef_sfx...
    -1 if m_pWord is not a suffix
Remarks: because it's likely to extend the prefix or suffix to more than single char
         words, so I dup the binary search code in two isolated functions.
         I do not like to make the assumption that prefix and suffix MUST share a same
         search mechanism, although they are same till now!
============================================================================*/
inline int CMorph::GetSuffixID(void)
{
    // only single char words mark as suffix
    if (!m_pWord->fGetFlag(CWord::WF_CHAR)) {
        assert(0); // all suffix should be single char words
        return -1;
    }

    assert(m_pWord->cwchLen() == 1);

    WCHAR*   pwchWord = m_pWord->pwchGetText();
#ifdef DEBUG
    // Serialize search to verify the result
    int dbg_iret = -1;
    for (int dbg_i =0; dbg_i < sizeof(v_rgsfxMap) / sizeof(CAfxMap); dbg_i++) {
        if (v_rgsfxMap[dbg_i].m_wchAffix == *pwchWord ) {
            dbg_iret = v_rgsfxMap[dbg_i].m_iAttriID;
            break;
        }
    }
    // the attri ID of matched prefix stored in the dbg_iret.
#endif // DEBUG

    // Binary search for the specific prefix
    int lo = 0, hi = (sizeof(v_rgsfxMap) / sizeof(CAfxMap)) - 1, mi, icmp;
    while (lo <= hi) {
        mi = (lo + hi) / 2;
        if ((icmp = *pwchWord - v_rgsfxMap[mi].m_wchAffix) == 0) {
            assert(v_rgsfxMap[mi].m_iAttriID == dbg_iret);
            return v_rgsfxMap[mi].m_iAttriID;
        } else if (icmp < 0) {
            hi = mi - 1;
        } else {
            lo = mi + 1;
        }
    }
    assert(dbg_iret == -1);
    return -1; // can not found the prefix!
}


/*============================================================================
//  Implement prefix process functions for each prefix
//  For prefix process functions:
//      Return AFFIX_ATTACHED if attached successfully
//      Return AFFIX_UNATTACH if could not attached
//      Return AFFIX_ERROR if runtime error occurred
============================================================================*/
inline int CMorph::pfxAa_Proc(void)     // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxAa)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxChao_Proc(void)   // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxChao)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posB);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxDai_Proc(void)    // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxDai)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxFan_Proc(void)    // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxFan)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxFei_Proc(void)    // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxFei)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posB);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxFu_Proc(void)     // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxFu)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxGuo_Proc(void)    // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxGuo)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posB);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxLao_Proc(void)    // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxLao)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxWei1_Proc(void)   // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxWei1)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxWei3_Proc(void)   // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxWei3)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxXiao_Proc(void)   // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxXiao)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxZhun_Proc(void)   // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxZhun)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::pfxZong_Proc(void)   // 
{
    if (m_pWord->pNextWord()->pNextWord()) {
        if (m_pWord->pNextWord()->fGetAttri(LADef_pfxZong)) {
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}


/*============================================================================
//  Implement suffix process functions for each suffix
//  For suffix process functions:
//      Return AFFIX_ATTACHED if attached successfully
//      Return AFFIX_UNATTACH if could not attached
//      Return AFFIX_ERROR if runtime error occurred
============================================================================*/

inline int CMorph::sfxZhang_Proc(void)      // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxZhang)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semZhang);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxChang_Proc(void)      // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxChang)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semChang);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxDan_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxDan)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semDan);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxDui_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxDui)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semDui);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxEr_Proc(void)         // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxEr)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semEr);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxFa_Proc(void)         // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxFa)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semFa);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxFang_Proc(void)       // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxFang)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semFang);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxGan_Proc(void)        // 
{
    if (m_pWord->pPrevWord() == NULL) {
        m_pWord->SetErrID(ERRDef_WORDUSAGE);
        return AFFIX_UNATTACH;
    }
    CWord* pPrev = m_pWord->pPrevWord();
    if (pPrev->fGetAttri(LADef_sfxGan)) {
        m_pWord = pPrev;
        m_pLink->MergeWithNext(m_pWord, FALSE);
        m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
        m_pWord->SetWordID(SLMDef_semGan);
        //_DUMPLINK(m_pLink, m_pWord);
        return AFFIX_ATTACHED;
    }
    if (pPrev->fIsWordChar(SC_CHAR_ZHI)) { // " "
        if (pPrev->pPrevWord() && pPrev->pPrevWord()->cwchLen() >= 2) { // "AB..  "
            m_pWord = pPrev->pPrevWord();
            m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semGan);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        } else { // " or A"
            pPrev->SetErrID(ERRDef_WORDUSAGE); // Mark error on ""
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_UNATTACH;
        }
    }
    if (pPrev->cwchLen() == 1) {
        if (m_pLex->fIsCharFeature(m_pWord->GetLexHandle(),
                                   LFDef_verbModifier, 
                                   *(pPrev->pwchGetText()) ) ) {
            m_pWord = pPrev;
            m_pLink->MergeWithNext(m_pWord);
            m_pWord->SetAttri(LADef_posV);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
        //_DUMPLINK(m_pLink, m_pWord);
        return AFFIX_UNATTACH;
    }
    // ""
    // pPrev->m_idErr = ERRDef_WORDUSAGE;
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxGuan_Proc(void)       // 
{
    if (m_pWord->pPrevWord() != NULL) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxGuan)) {
            m_pWord = m_pWord->pPrevWord();
            if (m_pWord->pPrevWord() &&
                m_pWord->pPrevWord()->fGetAttri(LADef_sfxGuan)) {
                // <  > <  >
                m_pWord = m_pWord->pPrevWord();
                m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
            } else {
                m_pLink->MergeWithNext(m_pWord, FALSE);
            }
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semGuan);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    // Mark "" as posV, will not confuse the proper name identification rules
    m_pWord->SetAttri(LADef_posV);
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxHua_Proc(void)        // 
{
    if (m_pWord->pPrevWord() != NULL) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxHua)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posV);
            m_pWord->SetAttri(LADef_posA);
            m_pWord->SetAttri(LADef_pfxFei); // < ... >
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semHua);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        } else if (m_pWord->pPrevWord()->fGetAttri(LADef_miscElement)) {
            // :  
            BOOL fFound = FALSE;
            if (m_pWord->pNextWord() &&
                m_pWord->pNextWord()->fGetAttri(LADef_miscElement)) { // 

                m_pLink->MergeWithNext(m_pWord);
                fFound = TRUE;
            } else if (m_pWord->pNextWord() &&
                       m_pWord->pNextWord()->fGetAttri(LADef_posM) && 
                       m_pWord->pNextWord()->pNextWord()->pNextWord() &&
                       m_pWord->pNextWord()->pNextWord()->fGetAttri(LADef_miscElement)){
                // 
                m_pLink->MergeWithNext(m_pWord);
                m_pLink->MergeWithNext(m_pWord);
                fFound = TRUE;
            }
            if (fFound) {
                m_pWord = m_pWord->pPrevWord();
                if (m_pWord->pPrevWord() &&
                    m_pWord->pPrevWord()->fGetAttri(LADef_posM)){

                    m_pWord = m_pWord->pPrevWord();
                    m_pLink->MergeWithNext(m_pWord);
                }
                m_pLink->MergeWithNext(m_pWord);
                m_pWord->SetAttri(LADef_nounTerm);
                m_pWord->SetAttri(LADef_posN);
                //_DUMPLINK(m_pLink, m_pWord);
                return AFFIX_ATTACHED;
            }
        } else {
        }
    }
    if (m_pWord->pNextWord() &&
        m_pWord->pNextWord()->pNextWord() &&
        m_pWord->pNextWord()->pNextWord()->pNextWord() &&
        m_pWord->pNextWord()->pNextWord()->fIsWordChar(SC_CHAR_WEI)) {
        // Test  A  B pattern
        m_pWord = m_pLink->pRightMerge(m_pWord, 3, FALSE);
        m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltPhr
        m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
        //_DUMPLINK(m_pLink, m_pWord);
        return AFFIX_ATTACHED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxJi_Proc(void)         // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxJi)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semJi);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxJia_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxJia)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semJia);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxJie_Proc(void)        // 
{
    CWord* pPrev = m_pWord->pPrevWord();
    if (pPrev) {
        if (pPrev->fGetAttri(LADef_sfxJie)) {
            m_pWord = pPrev;
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semJie);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
#ifndef _CHSWBRKR_DLL_IWORDBREAKER
        if (pPrev->fIsWordChar(SC_CHAR_WEI)) {
            // Try "..." pattern
            int ilen = 0;
            pPrev = pPrev->pPrevWord();
            for (; ilen < 3 && pPrev; ilen++, pPrev = pPrev->pPrevWord()) {
                if (pPrev->fGetAttri(LADef_punPunct)) {
                    break;
                }
                if (pPrev->fIsWordChar(SC_CHAR_YI3)) { // Matach!!
                    while (pPrev->pNextWord() != m_pWord) {
                        m_pLink->MergeWithNext(pPrev);
                    }
                    m_pWord = pPrev;
                    m_pLink->MergeWithNext(m_pWord);
                    m_pWord->SetAttri(LADef_posP);
                    //_DUMPLINK(m_pLink, m_pWord);
                    return AFFIX_ATTACHED;
                }
            }
        }
#endif // _CHSWBRKR_DLL_IWORDBREAKER
        m_pWord->SetAttri(LADef_posN); // As noun execpt in the proper name.
    } else {
        // Should not be the first word in a sentence
        m_pWord->SetErrID(ERRDef_WORDUSAGE);
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxLao_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxLao)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semLao);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxLv_Proc(void)         // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxLv)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semLv);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
        // { V()+V()+ } or { V()+N()+ } 
        // , 
    }
    if (m_pWord->pNextWord() &&
        m_pWord->pNextWord()->fGetFlag(CWord::WF_CHAR) &&
        m_pLex->fIsCharFeature(m_pWord->GetLexHandle(),
                               LFDef_verbObject, 
                               *(m_pWord->pNextWord()->pwchGetText()) ) ) {
        //  + (~/~/~/~/~/~) (40M Corpus)
        m_pLink->MergeWithNext(m_pWord, FALSE);
        m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
        //_DUMPLINK(m_pLink, m_pWord);
        return AFFIX_ATTACHED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxLun_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxLun)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semLun);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxMen_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxMen)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semMen);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxPin_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxPin)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semPin);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxQi_Proc(void)         // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxQi)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semQi);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxSheng_Proc(void)      // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxSheng)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semSheng);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxSheng3_Proc(void)     // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxSheng3)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semSheng3);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxShi1_Proc(void)       // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxShi1)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semShi1);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxShi4_Proc(void)       // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxShi4)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semShi4);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxShi_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxShi)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posB);
            m_pWord->SetAttri(LADef_pfxFei);
            m_pWord->SetAttri(LADef_pfxChao);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semShi);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        } else if (m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_YI)) { // "  "
            assert(m_pWord->pNextWord());
            if (m_pWord->pNextWord()->pNextWord() &&
                m_pWord->pNextWord()->fGetFlag(CWord::WF_CHAR) &&
                m_pWord->pNextWord()->fGetAttri(LADef_posM) &&
                m_pWord->pNextWord()->pNextWord()->pNextWord() &&
                m_pWord->pNextWord()->pNextWord()->pNextWord()->fGetFlag(CWord::WF_CHAR) &&
                m_pWord->pNextWord()->pNextWord()->fGetAttri(LADef_posQ) ) {
                //    pattern 
                m_pWord = m_pWord->pPrevWord();
                m_pWord = m_pLink->pRightMerge(m_pWord, 3, FALSE);
                m_pWord->SetAttri(LADef_posD); // 
                //_DUMPLINK(m_pLink, m_pWord);
#ifdef LADef_iwbAltPhr
                m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            } else {
                // " " 
                m_pWord = m_pWord->pPrevWord();
                m_pLink->MergeWithNext(m_pWord, FALSE);
                m_pWord->SetAttri(LADef_posZ);
#ifdef LADef_iwbAltPhr
                m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
                //_DUMPLINK(m_pLink, m_pWord);
            }
            return AFFIX_ATTACHED;
        } else if (fCheckShiQian(m_pWord->pPrevWord())) {
#ifndef _CHSWBRKR_DLL_IWORDBREAKER
        // "": 
            do  {
                m_pWord = m_pWord->pPrevWord();
                m_pLink->MergeWithNext(m_pWord);
            } while (m_pWord->pPrevWord() && fCheckShiQian(m_pWord->pPrevWord()));
            m_pWord->SetAttri(LADef_posB);
            m_pWord->SetWordID(SLMDef_semShi);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
#endif // _CHSWBRKR_DLL_IWORDBREAKER
        } else {
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

//  sfxShi_Proc() service function
inline BOOL CMorph::fCheckShiQian(CWord* pWord)
{
    assert(pWord->pNextWord());
    if (pWord->fGetAttri(LADef_posM) ||
        pWord->fGetAttri(LADef_numArabic) ||
        pWord->fGetAttri(LADef_nounPlace) ||
        pWord->fGetAttri(LADef_nounTM) ||
        pWord->fGetAttri(LADef_nounTerm) && pWord->fGetFlag(CWord::WF_QUOTE) ||
        pWord->fGetAttri(LADef_genDBForeign) ||
        pWord->fGetAttri(LADef_nounPerson) ) {

        return TRUE;
    }
    return FALSE;
}

inline int CMorph::sfxTi_Proc(void)         // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxTi)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semTi);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxTing_Proc(void)       // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxTing)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semTing);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    m_pWord->SetAttri(LADef_posN); // Mark as Noun if could no combind
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxTou_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxTou)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semTou);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxXing2_Proc(void)      // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxXing2)) {
            m_pWord = m_pWord->pPrevWord();
            if (m_pWord->pPrevWord() &&
                m_pWord->pPrevWord()->fGetAttri(LADef_sfxXing2)) {
                //  N-X-  A-X-NA
                // "  ", "  " 
                // ""!
                m_pWord = m_pWord->pPrevWord();
                m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
                //_DUMPLINK(m_pLink, m_pWord);
            } else {
                m_pLink->MergeWithNext(m_pWord, FALSE);
            }
            m_pWord->SetAttri(LADef_posB);
            m_pWord->SetAttri(LADef_pfxFei);
            m_pWord->SetAttri(LADef_pfxChao);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semXing2);
            // m_pWord->SetAttri(LADef_pfxQuan); ""
            // m_pWord->SetAttri(LADef_...); 
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        } else if (fCheckXingQian(m_pWord->pPrevWord())) {
        // "":
#ifndef _CHSWBRKR_DLL_IWORDBREAKER
            do  {
                m_pWord = m_pWord->pPrevWord();
                m_pLink->MergeWithNext(m_pWord);
            } while(m_pWord->pPrevWord() && fCheckXingQian(m_pWord->pPrevWord()));
            m_pWord->SetAttri(LADef_posB);
            m_pWord->SetWordID(SLMDef_semXing2);
            // 40M IME !
            // m_pWord->SetAttri(LADef_...); , 
            // !!!, 
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
#endif // _CHSWBRKR_DLL_IWORDBREAKER
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

//  sfxXing2_Proc() service function
inline BOOL CMorph::fCheckXingQian(CWord* pWord)
{
    assert(pWord->pNextWord());

    if (pWord->fGetAttri(LADef_posM) ||
        pWord->fGetAttri(LADef_numArabic) ||
        pWord->fGetAttri(LADef_nounPlace) ||
        pWord->fGetAttri(LADef_nounTM) ||
        pWord->fGetAttri(LADef_nounTerm) && pWord->fGetFlag(CWord::WF_QUOTE) ||
        pWord->fGetAttri(LADef_genDBForeign) ||
        pWord->fGetAttri(LADef_nounPerson) ) {

        return TRUE;
    }
    return FALSE;
}

inline int CMorph::sfxXing4_Proc(void)      // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxXing4)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semXing4);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxXue_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxXue)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semXue);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxYan_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxYan)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semYan);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxYe_Proc(void)         // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxYe)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semYe);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxYi_Proc(void)         // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxYi)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semYi);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxYuan_Proc(void)       // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxYuan)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semYuan);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxZhe_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxZhe)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semZhe);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxZheng_Proc(void)      // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxZheng)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semZheng);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxZhi_Proc(void)        // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxZhi)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semZhi);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}

inline int CMorph::sfxZi_Proc(void)         // 
{
    if (m_pWord->pPrevWord()) {
        if (m_pWord->pPrevWord()->fGetAttri(LADef_sfxZi)) {
            m_pWord = m_pWord->pPrevWord();
            m_pLink->MergeWithNext(m_pWord, FALSE);
            m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltPhr
            m_pWord->SetAttri(LADef_iwbAltPhr);
#endif // LADef_iwbAltPhr
            m_pWord->SetWordID(SLMDef_semZi);
            //_DUMPLINK(m_pLink, m_pWord);
            return AFFIX_ATTACHED;
        }
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return AFFIX_UNATTACH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\morph4.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CMorph
Purpose:    Identify the Morphological pattern
Notes:      Include 3 parts: Duplicate, Pattern, and Separacte words
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#include "myafx.h"

#include "morph.h"
#include "wordlink.h"
//#include "engindbg.h"
#include "lexicon.h"
#include "scchardef.h"
#include "slmdef.h"

//  Define local constants
#define PTN_UNMATCH     0
#define PTN_MATCHED     1
#define PTN_ERROR       2

//  Implement functions for pattern identification

/*============================================================================
CMorph::fPatternMatch(void):
    Pattern match control function. 
    WordLink scan, procedure control and error handling. 
Returns:
    TRUE if finished, 
    FALSE if runtime error, and set error code to m_iecError.
============================================================================*/
BOOL CMorph::fPatternMatch(void)
{
    assert(m_iecError == 0); // the error code public field should be cleared
    assert(m_pLink != NULL);

    int iret;
    m_pWord = m_pLink->pGetHead();
    assert(m_pWord != NULL); // error: missing the terminate word node!

    // Scan from left to right for pattern match
    for ( ; m_pWord && m_pWord->pNextWord() != NULL;
            m_pWord = m_pWord->pNextWord()) {
        if (m_pWord->fGetFlag(CWord::WF_SBCS) ||
            m_pWord->fGetFlag(CWord::WF_REDUCED)) {
            continue;
        }
        if ((iret = DupHandler()) != PTN_UNMATCH) {
            if (iret == PTN_ERROR) {
                return FALSE;
            }
            assert(m_pWord->fGetFlag(CWord::WF_REDUCED));
            m_pWord->SetWordID(SLMDef_semDup);
            continue;
        }
        if ((iret = PatHandler()) != PTN_UNMATCH) {
            if (iret == PTN_ERROR) {
                return FALSE;
            }
            assert(m_pWord->fGetFlag(CWord::WF_REDUCED));
            m_pWord->SetWordID(SLMDef_semPattern);
            continue;
        }
        if ((iret = SepHandler()) != PTN_UNMATCH) {
            if (iret == PTN_ERROR) {
                return FALSE;
            }
            continue;
        }
    }
    return TRUE;
}

// DupHandler: find duplicate cases and call coordinate proc functions
inline int CMorph::DupHandler(void)
{
    int     iret; 
    int     cwCurr, cwNext;
    CWord*  pNext;
    WCHAR*  pwch;
    BOOL    fRight;

    assert(m_pWord->pNextWord());
    assert(!m_pWord->fGetFlag(CWord::WF_SBCS) && !m_pWord->fGetFlag(CWord::WF_REDUCED));

    if ((cwCurr = m_pWord->cwchLen()) > 2) {
        return PTN_UNMATCH;
    }

    fRight = FALSE;
    iret = PTN_UNMATCH;
    pwch = m_pWord->pwchGetText();
    pNext = m_pWord->pNextWord();
    if (pNext->pNextWord() &&
        !pNext->fGetFlag(CWord::WF_SBCS) &&
        (cwNext = pNext->cwchLen()) <= 2) {
        // possible AA/ABAB/ABB
        if (cwCurr == 1) {
            if (cwNext == 1 && *pwch == *(pwch+1)) {
                // Match (*A A)
                if (m_pWord->fGetAttri(LADef_dupQQ)) {
                    iret = dupQQ_Proc();
                } else if (m_pWord->fGetAttri(LADef_dupAA)) {
                    iret = dupAA_Proc();
                } else if (m_pWord->fGetAttri(LADef_dupVV)) {
                    iret = dupVV_Proc(); // , 
                } else if (m_pWord->fGetAttri(LADef_dupDD)) {
                    iret = dupDD_Proc();
                } else if (m_pWord->fGetAttri(LADef_dupMM)) {
                    iret = dupMM_Proc();
                } else if (m_pWord->fGetAttri(LADef_dupNN)) {
                    iret = dupNN_Proc();
                } else {
                    // invalid AA case fall in here!!!
                    if (!m_pWord->fGetAttri(LADef_posM) && 
                        !m_pWord->fGetAttri(LADef_numArabic) && 
                        !m_pWord->fGetAttri(LADef_posO) ) {

                        m_pWord->pNextWord()->SetErrID(ERRDef_DUPWORD);
                        //_DUMPLINK(m_pLink, m_pWord);
                    }
                }
            }
            return iret;
        } else if (cwNext == 2 &&
                   *pwch == *(pwch + 2) &&
                   *(pwch + 1) == *(pwch + 3)) { 
            // Match (*AB AB)
            assert (cwCurr = 2);
            if (m_pWord->fGetAttri(LADef_dupMABAB)) {
                iret = dupMABAB_Proc();
            } else if (m_pWord->fGetAttri(LADef_dupVABAB)) {
                iret = dupVABAB_Proc();
            } else if (m_pWord->fGetAttri(LADef_dupZABAB)) {
                iret = dupZABAB_Proc();
            } else if (m_pWord->fGetAttri(LADef_dupAABAB)) {
                iret = dupAABAB_Proc();
            } else if (m_pWord->fGetAttri(LADef_dupDABAB)) {
                iret = dupDABAB_Proc();
            } else {
                // Invalid ABAB cases fall in here!!!
                m_pWord->pNextWord()->SetErrID(ERRDef_DUPWORD);
                //_DUMPLINK(m_pLink, m_pWord);
            }
            return iret;
        } else if (cwNext == 1 && *(pwch + 1) == *(pwch + 2)) {
            // Match (*AB B)
            assert(cwCurr == 2);
            fRight = TRUE;
        } else {
            return iret;
        }
    } // end of if possible AA/ABAB/ABB

    // match left char
    if (m_pWord->cwchLen() == 2 && m_pWord->pPrevWord() && 
            m_pWord->pPrevWord()->cwchLen() == 1 && *pwch == *(pwch-1)) {
        // Match (A *AB )
        if (fRight) { // Match (A AB B)!
            if (m_pWord->fGetAttri(LADef_dupVAABB)) {
                iret = dupVAABB_Proc();
            } else if (m_pWord->fGetAttri(LADef_dupAAABB)) {
                iret = dupAAABB_Proc();
            } else if (m_pWord->fGetAttri(LADef_dupMAABB)) {
                iret = dupMAABB_Proc();
            } else if (m_pWord->fGetAttri(LADef_dupDAABB)) {
                iret = dupDAABB_Proc();
            } else if (m_pWord->fGetAttri(LADef_dupNAABB)) {
                iret = dupNAABB_Proc();
            } else {
                // Invalid AABB cases fall in here!
                // Mark error on *AB
                m_pWord->SetErrID(ERRDef_DUPWORD);
                //_DUMPLINK(m_pLink, m_pWord);
            }
        } else {
            if (m_pWord->fGetAttri(LADef_dupVVO)) {
                iret = dupVVO_Proc();
            } else {
                // Invalid AAB cases fall in here!
                // Mark error on A
                m_pWord->pPrevWord()->SetErrID(ERRDef_DUPWORD);
                //_DUMPLINK(m_pLink, m_pWord);
            }
        }
        return iret;
    }

    if (fRight) { // Match (*AB B) but could not match (A *AB B)!
        if (m_pWord->fGetAttri(LADef_dupABB)) {
            return dupABB_Proc();
        } else {
            // Invalid ABB cases fall in here!
            pNext = m_pWord->pNextWord();
            if (!pNext->fIsWordChar(SC_CHAR_DE4) &&    // ": /..."
                !pNext->fIsWordChar(SC_CHAR_YI3) &&    // ": /..."
                !pNext->fIsWordChar(SC_CHAR_WEI) ) {      // ": /..."
              
                pNext->SetErrID(ERRDef_DUPWORD);
                //_DUMPLINK(m_pLink, m_pWord);
            }           
        }
    }

    return PTN_UNMATCH;
}

// PatHandler: find pattern and call coordinate proc functions
inline int CMorph::PatHandler(void)
{
    CWord*  pNextNext;
    assert(m_pWord->pNextWord());
    assert(!m_pWord->fGetFlag(CWord::WF_SBCS) && !m_pWord->fGetFlag(CWord::WF_REDUCED));

    if (m_pWord->pNextWord()->pNextWord() == NULL ||
        m_pWord->pNextWord()->pNextWord()->pNextWord() == NULL) {
        return PTN_UNMATCH;
    }
    pNextNext = m_pWord->pNextWord()->pNextWord();
    
    // try "VV" first
    if (m_pWord->fGetAttri(LADef_patV3) &&
        pNextNext->pNextWord()->pNextWord() &&
        m_pWord->pNextWord()->fIsWordChar(SC_CHAR_LE) &&
        pNextNext->fIsWordChar(SC_CHAR_YI) &&
        m_pWord->fIsTextIdentical(pNextNext->pNextWord()) ) {
        // Match!
        return patV3_Proc();
    }

    // try other A x A patterns
    int iret = PTN_UNMATCH;
    if (!m_pWord->fGetAttri(LADef_punPunct) &&
        m_pWord->fIsTextIdentical(pNextNext)) {
        // Match m_pWord and pNextNext!
        if (m_pWord->pNextWord()->fIsWordChar(SC_CHAR_YI)) {
            iret = patV1_Proc();
        } else if (m_pWord->pNextWord()->fIsWordChar(SC_CHAR_LE)) {
            iret = patV2_Proc();
        } else if (m_pWord->pNextWord()->fIsWordChar(SC_CHAR_LAI) && 
                  pNextNext->pNextWord()->pNextWord() &&
                  pNextNext->pNextWord()->fIsWordChar(SC_CHAR_QU)) {
            iret = patV4_Proc();
        } else if (m_pWord->pNextWord()->fIsWordChar(SC_CHAR_SHANG) && 
                   pNextNext->pNextWord()->pNextWord() &&
                   pNextNext->pNextWord()->fIsWordChar(SC_CHAR_XIA)) {
            iret = patV5_Proc();
        } else if (m_pWord->pNextWord()->fIsWordChar(SC_CHAR_BU)) {
            iret = patABuA_Proc();
        } else if (m_pWord->pNextWord()->fIsWordChar(SC_CHAR_MEI)) {
            iret = patVMeiV_Proc();
        } else if (m_pWord->fGetAttri(LADef_patD1)) {
            iret = patD1_Proc();
        } else {
            // No handler for the (*A x A ) pattern, error?
            //_DUMPLINK(m_pLink, m_pWord);
        }
        return iret;
    }
    return PTN_UNMATCH;
}

// SepHandler: find separate word and call coordinate proc functions
#define SEPARATE_LENGTH     3   // count of words between the two parts of the separate words
inline int CMorph::SepHandler(void)
{
    assert(m_pWord->pNextWord());
    assert(!m_pWord->fGetFlag(CWord::WF_SBCS) && !m_pWord->fGetFlag(CWord::WF_REDUCED));

    CWord*  pHou; // the second part of the separat words
    WCHAR   rgwchLex[6];
    CWordInfo   winfo;

    if (!m_pWord->fGetAttri(LADef_sepQian)) {
        return PTN_UNMATCH;
    }
    // found the first part of the separate word
    pHou = m_pWord->pNextWord();
    USHORT ilen = SEPARATE_LENGTH;
    while (1) {
        if (pHou->pNextWord() == NULL ||
            pHou->fGetAttri(LADef_punPunct) || ilen-- <= 0) {
            return PTN_UNMATCH;
        }
        if (pHou->fGetAttri(LADef_sepHou)) {
            break;
        }
        pHou = pHou->pNextWord();
    }
    // both of the two parts matched
    assert(pHou && pHou->pNextWord());

    if (m_pWord->cwchLen() + pHou->cwchLen() > sizeof(rgwchLex)/sizeof(rgwchLex[0])) {
        assert(0);
        return PTN_UNMATCH;
    }
    ilen = m_pWord->cwchLen();
    memcpy(rgwchLex, m_pWord->pwchGetText(), ilen * sizeof (WCHAR));
    memcpy(&rgwchLex[ilen], pHou->pwchGetText(), pHou->cwchLen() * sizeof (WCHAR));
    ilen += pHou->cwchLen();
    if (ilen != m_pLex->cwchMaxMatch(rgwchLex, ilen, &winfo)) {
        return PTN_UNMATCH;
    }
    
    // the separate word found
    if (winfo.fGetAttri(LADef_sepVR)) {
        return sepVR_Proc(pHou, &winfo);
    } else if (winfo.fGetAttri(LADef_sepVG)) {
        return sepVG_Proc(pHou, &winfo);
    } else if (winfo.fGetAttri(LADef_sepVO)) {
        return sepVO_Proc(pHou, &winfo);
    }
    
    //_DUMPLINK(m_pLink, m_pWord);

    return PTN_UNMATCH;

}

// Duplicate word processing functions
int CMorph::dupNN_Proc(void)        // *N N
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupNAABB_Proc(void) // A *AB B
{
    assert(m_pWord->pPrevWord());

    m_pWord = m_pWord->pPrevWord();
    m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
    m_pWord->SetAttri(LADef_posN);
#ifdef LADef_iwbAltWd2
    m_pWord->SetAttri(LADef_iwbAltWd2);
#endif // LADef_iwbAltWd2
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupMM_Proc(void)        // *M M
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posM);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupMABAB_Proc(void) // *AB AB
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posM);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupMAABB_Proc(void) // A *AB B
{
    assert(m_pWord->pPrevWord());
//    m_pLink->MergeWithNext(m_pWord);
//    m_pLink->MergeWithNext(m_pWord);
    m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
    m_pWord->SetAttri(LADef_posM);
#ifdef LADef_iwbAltWd2
    m_pWord->SetAttri(LADef_iwbAltWd2);
#endif // LADef_iwbAltWd2
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupQQ_Proc(void)        // *Q Q
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posQ);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    if (!m_pWord->fIsHead() &&
        m_pWord->pPrevWord()->fIsWordChar(SC_CHAR_YI)) {

        m_pWord = m_pLink->pLeftMerge(m_pWord, 1);
        //_DUMPLINK(m_pLink, m_pWord);
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupVV_Proc(void)        // *V V
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupVABAB_Proc(void) // *AB AB
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupVAABB_Proc(void) // A *AB B
{
    assert(m_pWord->pPrevWord());
    m_pWord = m_pWord->pPrevWord();
//    m_pLink->MergeWithNext(m_pWord);
//    m_pLink->MergeWithNext(m_pWord);
    m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
    m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd2
    m_pWord->SetAttri(LADef_iwbAltWd2);
#endif // LADef_iwbAltWd2
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupVVO_Proc(void)       // V *VO
{
    assert(m_pWord->pPrevWord());
    m_pWord = m_pWord->pPrevWord();
    m_pLink->MergeWithNext(m_pWord, FALSE);
    // Set attributes for VVO words
    m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd2
    m_pWord->SetAttri(LADef_iwbAltWd2);
#endif // LADef_iwbAltWd2
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupAA_Proc(void)        // *A A
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    // Set attributes for AA words
    if (m_pWord->fGetAttri(LADef_dupAAToD)) {
        // 
        m_pWord->SetAttri(LADef_posD);
        //_DUMPLINK(m_pLink, m_pWord);
    } else {
        m_pWord->SetAttri(LADef_posV);
        //_DUMPLINK(m_pLink, m_pWord);
    }
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    return PTN_MATCHED;
}

int CMorph::dupAAABB_Proc(void) // A *AB B
{
    assert(m_pWord->pPrevWord());

    m_pWord = m_pWord->pPrevWord();
//    m_pLink->MergeWithNext(m_pWord);
//    m_pLink->MergeWithNext(m_pWord);
    m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
    m_pWord->SetAttri(LADef_posZ);
#ifdef LADef_iwbAltWd2
    m_pWord->SetAttri(LADef_iwbAltWd2);
#endif // LADef_iwbAltWd2
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupAABAB_Proc(void) // *AB AB
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupABB_Proc(void)       // *AB B
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posZ);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupZABAB_Proc(void) // *AB AB
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posZ);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupDD_Proc(void)        // *D D
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posD);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupDAABB_Proc(void) // A *AB B
{
    assert(m_pWord->pPrevWord());
    m_pWord = m_pWord->pPrevWord();
//    m_pLink->MergeWithNext(m_pWord);
//    m_pLink->MergeWithNext(m_pWord);
    m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
    m_pWord->SetAttri(LADef_posD);
#ifdef LADef_iwbAltWd2
    m_pWord->SetAttri(LADef_iwbAltWd2);
#endif // LADef_iwbAltWd2
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::dupDABAB_Proc(void) // *AB AB
{
    m_pLink->MergeWithNext(m_pWord, FALSE);
    m_pWord->SetAttri(LADef_posD);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}


// Pattern processing functions
int CMorph::patV1_Proc(void)        // *V  V
{
    if (m_pWord->fGetAttri(LADef_patV1)) {
//        m_pLink->MergeWithNext(m_pWord);
//        m_pLink->MergeWithNext(m_pWord);
        m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
        m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
        m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
        //_DUMPLINK(m_pLink, m_pWord);
        return PTN_MATCHED;
    } else {
        // Invalid words in (*V  V) pattern
        //_DUMPLINK(m_pLink, m_pWord);
    }
    return PTN_UNMATCH;
}

int CMorph::patV2_Proc(void)        // *V  V
{
    if (m_pWord->fGetAttri(LADef_patV1)) {
//        m_pLink->MergeWithNext(m_pWord);
//        m_pLink->MergeWithNext(m_pWord);
        m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
        m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
        m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
        //_DUMPLINK(m_pLink, m_pWord);
        return PTN_MATCHED;
    } else {
        // Invalid words in (*V  V) pattern
        //_DUMPLINK(m_pLink, m_pWord);
    }
    return PTN_UNMATCH;
}

int CMorph::patV3_Proc(void)        // *V  V
{
    assert(m_pWord->fGetAttri(LADef_patV3));

    m_pWord = m_pLink->pRightMerge(m_pWord, 3, FALSE);
    m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
    m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_MATCHED;
}

int CMorph::patV4_Proc(void)        // *V  V 
{
    if (m_pWord->fGetAttri(LADef_patV4)) {
        m_pWord = m_pLink->pRightMerge(m_pWord, 3, FALSE);
        m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
        m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
        //_DUMPLINK(m_pLink, m_pWord);
        return PTN_MATCHED;
    } else {
        m_pWord->pNextWord()->pNextWord()->SetErrID(ERRDef_DUPWORD);
        //_DUMPLINK(m_pLink, m_pWord);
    }
    return PTN_UNMATCH;
}

int CMorph::patV5_Proc(void)        // *V  V 
{
    if (m_pWord->fGetAttri(LADef_patV5)) {
        m_pWord = m_pLink->pRightMerge(m_pWord, 3, FALSE);
        m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
        m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
        //_DUMPLINK(m_pLink, m_pWord);
        return PTN_MATCHED;
    } else {
        m_pWord->pNextWord()->pNextWord()->SetErrID(ERRDef_DUPWORD);
        //_DUMPLINK(m_pLink, m_pWord);
    }
    return PTN_UNMATCH;
}

int CMorph::patD1_Proc(void)        // *D A D B
{    
#ifndef _CHSWBRKR_DLL_IWORDBREAKER // for IWordBreaker inrerface, don't merge
    CWord* pLast = m_pWord->pNextWord()->pNextWord()->pNextWord();
    assert(pLast);
    if (m_pWord->pNextWord()->fGetAttri(LADef_posV) &&
        pLast->fGetAttri(LADef_posV) &&
        m_pWord->pNextWord()->cwchLen() == pLast->cwchLen()) {

        m_pWord = m_pLink->pRightMerge(m_pWord,3);
        m_pWord->SetAttri(LADef_posV);
        //_DUMPLINK(m_pLink, m_pWord);
        return PTN_MATCHED;
    } else if (m_pWord->pNextWord()->fGetAttri(LADef_posA) &&
               pLast->fGetAttri(LADef_posA) &&
               m_pWord->pNextWord()->cwchLen() == pLast->cwchLen()) {
        m_pWord = m_pLink->pRightMerge(m_pWord,3);
        m_pWord->SetAttri(LADef_posA);
        //_DUMPLINK(m_pLink, m_pWord);
        return PTN_MATCHED;
    } else {
        //_DUMPLINK(m_pLink, m_pWord);
    }
#endif // _CHSWBRKR_DLL_IWORDBREAKER
    return PTN_UNMATCH;
}

int CMorph::patABuA_Proc(void)      // (*V  V) or (*A  A)
{
    if (m_pWord->fGetAttri(LADef_posV)) {
        if (!m_pWord->fGetAttri(LADef_flgNoVBu)) {
            m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
            m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
            m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
            //_DUMPLINK(m_pLink, m_pWord);
            return PTN_MATCHED;
        }
    } else if (m_pWord->fGetAttri(LADef_posA)) {
        if (!m_pWord->fGetAttri(LADef_flgNoABu)) {
            m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
            m_pWord->SetAttri(LADef_posA);
#ifdef LADef_iwbAltWd1
            m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
            //_DUMPLINK(m_pLink, m_pWord);
            return PTN_MATCHED;
        }
    } else {
        //_DUMPLINK(m_pLink, m_pWord);
    }
    return PTN_UNMATCH;
}

int CMorph::patVMeiV_Proc(void)     // *V  V
{
    if (m_pWord->fGetAttri(LADef_posV) &&
        !m_pWord->fGetAttri(LADef_flgNoVMei)) {

        m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
        m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWd1
        m_pWord->SetAttri(LADef_iwbAltWd1);
#endif // LADef_iwbAltWd1
        //_DUMPLINK(m_pLink, m_pWord);
        return PTN_MATCHED;
    } else {
        //_DUMPLINK(m_pLink, m_pWord);
    }
    return PTN_UNMATCH;
}


// Separate word processing functions
int CMorph::sepVO_Proc(CWord* pBin, CWordInfo* pwinfo)  // 
{
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_UNMATCH;
}

int CMorph::sepVR_Proc(CWord* pJie, CWordInfo* pwinfo)  // 
{
    assert(m_pWord->pNextWord() && m_pWord->pNextWord()->pNextWord());

    if (( m_pWord->pNextWord()->fIsWordChar(SC_CHAR_BU) || 
          m_pWord->pNextWord()->fIsWordChar(SC_CHAR_DE)   ) &&
        m_pWord->pNextWord()->pNextWord() == pJie ) {

        m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
        m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWdc13
        m_pWord->SetAttri(LADef_iwbAltWdc13);
#endif // LADef_iwbAltWdc13
        // For SLM!
        m_pWord->SetWordID(pwinfo->GetWordID());
        //_DUMPLINK(m_pLink, m_pWord);
        return PTN_MATCHED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_UNMATCH;
}

int CMorph::sepVG_Proc(CWord* pQu, CWordInfo* pwinfo)   // 
{
    assert(m_pWord->pNextWord() && m_pWord->pNextWord()->pNextWord());

    if (( m_pWord->pNextWord()->fIsWordChar(SC_CHAR_BU) || 
          m_pWord->pNextWord()->fIsWordChar(SC_CHAR_DE)   ) &&
        m_pWord->pNextWord()->pNextWord() == pQu ) {

        m_pWord = m_pLink->pRightMerge(m_pWord, 2, FALSE);
        m_pWord->SetAttri(LADef_posV);
#ifdef LADef_iwbAltWdc13
        m_pWord->SetAttri(LADef_iwbAltWdc13);
#endif // LADef_iwbAltWdc13
        // For SLM!
        m_pWord->SetWordID(pwinfo->GetWordID());
        //_DUMPLINK(m_pLink, m_pWord);
        return PTN_MATCHED;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return PTN_UNMATCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\morph5.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CMorph
Purpose:	Combind 2-char compond verb and noun that OOV
Notes:		There are many 2-char verb and noun which can not be collected in the 
			lexicon but they are quite stable and few boundary ambiguities if combind.
			Most of them have one of the following structures:
				A + N
				V + N
				V + A
				N + N
			This step can be viewed as implementation of secondary Lexicon. 
			But we implement this using lex feature and attributes
Owner:		donghz@microsoft.com
Platform:	Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#include "myafx.h"

#include "morph.h"
#include "wordlink.h"
#include "scchardef.h"
//#include "engindbg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\myafx.cpp ===
// MyAFX.cpp
// Pre-compile header

#include "myafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\myafx.h ===
// MyAFX.h
// Pre-compile header
#ifndef _MY_AFX_H
#define _MY_AFX_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#define WINVER 0x0400

#ifdef _DEBUG
#undef DEBUG
#define DEBUG
#endif

#define _CHSWBRKR_DLL_IWORDBREAKER

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <objbase.h>

#include <assert.h>
#include <crtdbg.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\myplex.cpp ===
// MyPlex.cpp

#include "myafx.h"

#include "MyPlex.h"
// *****************************************************************************************
//  Implementation of CMyPlex
// *****************************************************************************************
CMyPlex* CMyPlex::Create(
            CMyPlex*& pHead,    // Head block this block will insert before
            UINT nMax,          // Number of elements in this block
            UINT cbElement)     // Size of each element
{
    assert(nMax > 0 && cbElement > 0);
    CMyPlex* p = (CMyPlex*)new BYTE[sizeof(CMyPlex) + nMax * cbElement];
    if (!p) {
        return NULL;
    }
    p->m_pNext = pHead;
    pHead = p;      // Note: pHead passed by reference!
    return p;
}

void CMyPlex::FreeChain()
{
    CMyPlex* p = this;
    while(p != NULL) {
        BYTE* pBytes = (BYTE*)p;
        CMyPlex* pNext = p->m_pNext;
        delete[] pBytes;
        p = pNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\myplex.h ===
// MyPlex.h
// a fixed size memory allocator stolen from MFC's source code
#ifndef _MYPLEX_H_
#define _MYPLEX_H_

// *****************************************************************************************
//  Declare Plex structure for LexNode memory management
// *****************************************************************************************
#pragma pack(1)
struct CMyPlex
{
    CMyPlex* m_pNext;

    void* Data() { return this+1; }
    static CMyPlex* Create(CMyPlex*& pHead, UINT nMax, UINT cbElement);
    void FreeChain();   // Free this block and all linked
};
#pragma pack()

#endif  // _MYPLEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\morphw.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CMorph
Purpose:    Implement the public member functions and control process of the Morph-
            analysis class. The pre-combind process
Notes:      In order to make all the 3 parts of Morph-analysis isolated, this class
            will be implemented into 4 cpp files:
                Morph.cpp   implement the public member function and control process
                Morph1.cpp  implement the numerical words binding
                Morph2.cpp  implement the affix attachment
                Morph3.cpp  implement the morphological pattern identification
            All these 4 cpp files will share morph.h header file
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    12/27/97
============================================================================*/
#include "myafx.h"

#include "morph.h"
#include "scchardef.h"
#include "lexicon.h"
#include "wordlink.h"
//#include "engindbg.h"
#include "proofec.h"

// Define return value for pre-combind processing functions
#define PRE_UNMERGE 1
#define PRE_MERGED  2
#define PRE_ERROR   3
// Define the max length of short quote(exclude the quote mark nodes), short quote
// will be merge to a single node, and treated as term of proper noun
#define MORPH_SHORT_QUOTE   4

/*============================================================================
Implementation of PUBLIC member functions
============================================================================*/

// Constructor
CMorph::CMorph()
{
    m_pLink = NULL;
    m_pLex = NULL;
}


// Destructor
CMorph::~CMorph()
{
    TermMorph();
}


// Initialize the morph class
int CMorph::ecInit(CLexicon* pLexicon)
{
    assert(pLexicon);

    m_pLex = pLexicon;
    return PRFEC::gecNone;
}


// process affix attachment
int CMorph::ecDoMorph(CWordLink* pLink, BOOL fAfxAttach)
{
    assert(pLink);

    m_pLink = pLink;
    m_iecError = PRFEC::gecNone;

    m_pWord = m_pLink->pGetHead();
    assert(m_pWord != NULL);    // error: missing the terminate word node!

    if (m_pWord == NULL) {
        assert(0); // should not run to here for a empty link!
        return PRFEC::gecNone;
    }
    if (m_pWord->pNextWord() == NULL) {
        return PRFEC::gecNone;
    }
    if (!fPreCombind()) {
        return m_iecError;
    }
    if (!fAmbiAdjust()) {
        return m_iecError;
    }
    if (!fNumerialAnalysis()) {
        return m_iecError;
    }
    if (!fPatternMatch()) {
        return m_iecError;
    }
    if (fAfxAttach && !fAffixAttachment()) {
        return m_iecError;
    }

    return PRFEC::gecNone;
}

/*============================================================================
Implementation of Private member functions
============================================================================*/
// Terminate the Morph class
void CMorph::TermMorph(void)
{
    m_pLex = NULL;
    m_pLink = NULL;
}


/*============================================================================
Private functiona for pre-combind process
============================================================================*/
//  Pre-combind process control function.
//  One pass scan the WordLink and call process functions
BOOL CMorph::fPreCombind()
{
    assert(m_iecError == 0); // the error code public field should be cleared
    assert(m_pLink != NULL);

    int iret;

    // Scan from left to right for DBForeign Combined
    m_pWord = m_pLink->pGetHead();
    assert(m_pWord != NULL && m_pWord->pNextWord() != NULL); // error: missing the terminate word node!

    for ( ; m_pWord->pNextWord() != NULL; m_pWord = m_pWord->pNextWord()) {
        if (m_pWord->fGetFlag(CWord::WF_SBCS) ||
            m_pWord->fGetFlag(CWord::WF_REDUCED)) {
            continue;
        }
        if ((iret = DBForeignHandler()) != PRE_UNMERGE) {
            if (iret == PRE_ERROR) {
                return FALSE;
            }
            continue;
        }
    }

    // Scan from left to right for quotation process
    m_pWord = m_pLink->pGetHead();
    for ( ; m_pWord->pNextWord() != NULL; m_pWord = m_pWord->pNextWord()) {
        if (m_pWord->fGetFlag(CWord::WF_SBCS) ||
            m_pWord->fGetFlag(CWord::WF_REDUCED)) {
            continue;
        }
        if ((iret = QuoteHandler()) != PRE_UNMERGE) {
            if (iret == PRE_ERROR) {
                return FALSE;
            }
            continue;
        }
    }
    return TRUE;
}


//  DBForeignHandler combind the conjunctive DB foreign characters
inline int CMorph::DBForeignHandler(void)
{
    assert(m_pWord->pNextWord());
    assert(!m_pWord->fGetFlag(CWord::WF_SBCS) && !m_pWord->fGetFlag(CWord::WF_REDUCED));

    if (m_pWord->fGetAttri(LADef_genDBForeign)) {
        while (m_pWord->pNextWord()->pNextWord() && 
                m_pWord->pNextWord()->fGetAttri(LADef_genDBForeign)) {
            m_pLink->MergeWithNext(m_pWord);
        }
        if (m_pWord->fGetFlag(CWord::WF_REDUCED)) {
            m_pWord->SetAttri(LADef_genDBForeign);
            //_DUMPLINK(m_pLink, m_pWord);
            return PRE_MERGED;
        }
    }
    return PRE_UNMERGE;
}


//  Short quotation merge proc
inline int CMorph::QuoteHandler(void)
{
    assert(m_pWord->pNextWord());
    assert(!m_pWord->fGetFlag(CWord::WF_SBCS) && !m_pWord->fGetFlag(CWord::WF_REDUCED));

    int iret;
    if (m_pWord->fGetAttri(LADef_punPair)) {
        if (m_pWord->GetErrID() == ERRDef_PUNCTMATCH) {
            return PRE_MERGED; // Don't check on the error quote marks!
        }
        assert(m_pWord->cwchLen() == 1);
        if (m_pWord->fIsWordChar(SC_CHAR_PUNL1)) {
            iret = preQuote1_Proc();
        } else if (m_pWord->fIsWordChar(SC_CHAR_PUNL2)) {
            iret = preQuote2_Proc();
        } else if (m_pWord->fIsWordChar(SC_CHAR_PUNL3)) {
            iret = preQuote3_Proc();
        } else if (m_pWord->fIsWordChar(SC_CHAR_PUNL4)) {
            iret = preQuote4_Proc();
        } else if (m_pWord->fIsWordChar(SC_CHAR_PUNL5)) {
            iret = preQuote5_Proc();
        } else if (m_pWord->fIsWordChar(SC_CHAR_PUNL6)) {
            iret = preQuote6_Proc();
        } else if (m_pWord->fIsWordChar(SC_CHAR_PUNL7)) {
            iret = preQuote7_Proc();
        } else if (m_pWord->fIsWordChar(SC_CHAR_PUNL8)) {
            iret = preQuote8_Proc();
        } else if (m_pWord->fIsWordChar(SC_CHAR_PUNL9)) {
            iret = preQuote9_Proc();
        } else if (m_pWord->fIsWordChar(SC_CHAR_PUNL10)) {
            iret = preQuote10_Proc();
        } else { 
            if (m_pWord->pPrevWord() != NULL &&
                !m_pWord->pPrevWord()->fGetFlag(CWord::WF_QUOTE)) {
                // Found unmatched right quote!!!
                m_pWord->SetErrID(ERRDef_PUNCTMATCH);
            }
            iret = PRE_MERGED;
        }
        return iret;
    }
    //_DUMPLINK(m_pLink, m_pWord);
    return PRE_UNMERGE;
}


/*============================================================================
In order to handle different operation for different quote marks pair, 
I use a separate process function for each kind of quote pair
============================================================================*/
inline int CMorph::preQuote1_Proc(void)    //  
{
    return preQuoteMerge(SC_CHAR_PUNL1, SC_CHAR_PUNR1);
}


inline int CMorph::preQuote2_Proc(void)    //  
{
    return preQuoteMerge(SC_CHAR_PUNL2, SC_CHAR_PUNR2);
}


inline int CMorph::preQuote3_Proc(void)    //  
{
    return PRE_UNMERGE;
}


inline int CMorph::preQuote4_Proc(void)    //  
{
    return preQuoteMerge(SC_CHAR_PUNL4, SC_CHAR_PUNR4);
}

inline int CMorph::preQuote5_Proc(void)    //  
{
    return preQuoteMerge(SC_CHAR_PUNL5, SC_CHAR_PUNR5);
}

inline int CMorph::preQuote6_Proc(void)    //  
{
    return preQuoteMerge(SC_CHAR_PUNL6, SC_CHAR_PUNR6);
}

inline int CMorph::preQuote7_Proc(void)    //  
{
    return preQuoteMerge(SC_CHAR_PUNL7, SC_CHAR_PUNR7);
}

inline int CMorph::preQuote8_Proc(void)    //  
{
    return preQuoteMerge(SC_CHAR_PUNL8, SC_CHAR_PUNR8);
}

inline int CMorph::preQuote9_Proc(void)    //  
{
    return preQuoteMerge(SC_CHAR_PUNL9, SC_CHAR_PUNR9);
}

inline int CMorph::preQuote10_Proc(void)   //  
{
    return preQuoteMerge(SC_CHAR_PUNL10, SC_CHAR_PUNR10);
}


/*============================================================================
Common routine to handle       
Merge into one node means will not proofread on the quote text any more!!!
============================================================================*/
int CMorph::preQuoteMerge(WCHAR wchLeft, WCHAR wchRight)
{
    assert(m_pWord->pNextWord());

    int     ciWord = 0;
    CWord*  pNext = m_pWord->pNextWord();

    do {
        if (pNext->fGetAttri(LADef_punPair)) {
            if (pNext->fIsWordChar(wchRight)) { // found  after 
                if(ciWord && ciWord < MORPH_SHORT_QUOTE) {
                    m_pLink->pRightMerge(m_pWord->pNextWord(), ciWord - 1);
                    m_pWord->SetFlag(CWord::WF_QUOTE);
                    m_pWord->SetAttri(LADef_nounTerm);
                    //_DUMPLINK(m_pLink, m_pWord);
                }
                return PRE_MERGED;
            } 
        }
        pNext->SetFlag(CWord::WF_QUOTE);
        ciWord++;
        pNext = pNext->pNextWord();
    } while (pNext != NULL);

    return PRE_UNMERGE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\proofec.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component:  Grammar Error Codes

Purpose:	Define error code for Proof Engine. 
			All algorithm modules: WrdBreak, Rules and HeuRead return these error codes
			MainDic also return these error code to PrfEngine module
			These error code are get from CGAPI directly
Owner:		donghz@microsoft.com
Platform:	Win32
Revise:		First created by: donghz	5/29/97
============================================================================*/

/*============================================================================
Grammar Error Codes
This error code set is very stable, because it defined in the common CGAPI spec.
Only level 2 modules (algorithm and MainDic) employ this error code set, and these
error codes can passed to the CGAPI caller through PrfEngine layer directly
============================================================================*/
#ifndef _PROOFEC_H
#define _PROOFEC_H

struct PRFEC
{
	enum EC
	{
		gecNone					=	0,  /* no errors */
		gecErrors				=	1,  /* one or more errors; see GRB */
		gecUnknown				=	2,  /* unknown error */
		gecPartialSentence		=	3,  /* refill GIB; save text >= ichStart */
		gecSkipSentence			=	4,  /* internal error; skip this sentence */
		gecEndOfDoc				=   5,  /* hit end of doc; last portion blank */
		gecOOM                  =   6,  /* out of memory; skip sentence */
		gecBadMainDict			=	7,  /* bad main dictionary */
		gecBadUserDict			=	8,  /* bad user dictionary */
		gecModuleInUse			=	9,  /* another app is using this dll */
		gecBadProfile			=  10,  /* can't open profile; using defaults */
		gecNoMainDict			=  11,  /* main dict not loaded yet */
		gecHaveMainDict			=  12,  /* have main dict (during GramOpenMdt) */
		gecNoSuchError			=  13,  /* no such error in grb */
		//gecCantPutupDlg		=  14,     now use gecOOM instead 
		gecCancelDlg 			=  15,  /* options dialog was canceled */
		gecRuleIsOn 			=  16,  /* rule is not ignored */
		gecIOErrorMdt           =  17,  /* Read,write,or share error with Mdt. */
		gecIOErrorUdr           =  18,  /* Read,write,or share error with Udr. */
		gecIOErrorPrf           =  19,  /* Read,write,or share error with Profile file */
		gecNoStats              =  20,  /* Stats not currently available */
		gecUdrFull              =  21,  /* User dictionary full*/
		gecInvalidUdrEntry      =  22,  /* Invalid user dictionary entry*/
		//Tnetative.
		gecForeignLanguage      =  22,  /* passed sentence is not a sentence in lid*/
		gecInterrupted          =  23,  /* checking interrupted by caller */
        // new Udr error
		gecNoUserDict			=  24   /* No user dictionary */
	};
};

#endif //PROOFEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\scchardef.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component:  SCCharDef.h
Purpose:    Define constents of special SC Characters
            These special characters are used in the specific grammar rules
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    1/15/98
============================================================================*/
#ifndef _SCCHARDEF_H_
#define _SCCHARDEF_H_

#define SC_CHAR_DI4     0x5730  // ""
#define SC_CHAR_GUO     0x8fc7  // ""
#define SC_CHAR_HE      0x548c  // ""
#define SC_CHAR_YOU     0x6709  // ""
#define SC_CHAR_ZHE     0x7740  // ""
#define SC_CHAR_YI      0x4e00  // ""
#define SC_CHAR_LE      0x4e86  // ""
#define SC_CHAR_LAI     0x6765  // ""
#define SC_CHAR_QU      0x53bb  // ""
#define SC_CHAR_SHANG   0x4e0a  // ""
#define SC_CHAR_XIA     0x4e0b  // ""
#define SC_CHAR_BU      0x4e0d  // ""
#define SC_CHAR_MEI     0x6ca1  // ""
#define SC_CHAR_DE      0x5f97  // ""
#define SC_CHAR_ZHI     0x4e4b  // ""
#define SC_CHAR_WEI     0x4e3a  // ""
#define SC_CHAR_XIN     0x65b0  // ""
#define SC_CHAR_YI3     0x4ee5  // ""
#define SC_CHAR_SHUDIAN 0xff0e  // ""
#define SC_CHAR_PERCENT 0xff05  // ""
#define SC_CHAR_ANSIPERCENT 0x0025  // "%"
#define SC_CHAR_SLASH   0xff0f  // ""
#define SC_CHAR_ANSISLASH 0x002f  // "/"
#define SC_CHAR_SHI2    0x5341  // ""
#define SC_CHAR_BAI     0x767e  // ""
#define SC_CHAR_QIAN    0x5343  // ""
#define SC_CHAR_WAN     0x4e07  // ""
#define SC_CHAR_YI4     0x4ebf  // ""
#define SC_CHAR_LIANG   0x4e24  // ""
#define SC_CHAR_DUNHAO  0x3001  // ""
#define SC_CHAR_DOUHAO  0xff0c  // ""
#define SC_CHAR_LIANHAO 0xff5e  // ""
#define SC_CHAR_ZHI4    0x81f3  // ""
#define SC_CHAR_BAN     0x534a  // ""
#define SC_CHAR_GAO     0x9ad8  // ""
#define SC_CHAR_ZHONG   0x4e2d  // ""
// Ordinal Tips
#define SC_CHAR_DI      0x7b2c  // ""
#define SC_CHAR_CHU     0x521d  // ""
// Decimal Tips
#define SC_CHAR_DIAN3   0x70b9  // ""
#define SC_CHAR_CHENG   0x6210  // ""
#define SC_CHAR_YOU4    0x53c8  // ""
#define SC_CHAR_BEI     0x500d  // ""
// Approx Tips
#define SC_CHAR_DUO     0x591a  // ""
#define SC_CHAR_YU      0x4f59  // ""
#define SC_CHAR_LAI     0x6765  // ""
#define SC_CHAR_JI      0x51e0  // ""
#define SC_CHAR_YUE1    0x7ea6  // ""
#define SC_CHAR_JIN     0x8fd1  // ""
#define SC_CHAR_SHU     0x6570  // ""
//#define SC_CHAR_SHANG 0x4e0a  // ""
// Quantity Tips
#define SC_CHAR_GE      0x4e2a  // ""
#define SC_CHAR_NIAN    0x5e74  // ""
#define SC_CHAR_YUE     0x6708  // ""
#define SC_CHAR_RI      0x65e5  // ""
#define SC_CHAR_SHI     0x65f6  // ""
#define SC_CHAR_FEN     0x5206  // ""
#define SC_CHAR_MIAO    0x79d2  // ""
#define SC_CHAR_ZHONG1  0x949f  // ""
#define SC_CHAR_ZHENG   0x6574  // ""

// Jargon
#define SC_CHAR_DENG    0x7b49  // ""
#define SC_CHAR_WAIDIAN 0x00b7  // ""
#define SC_CHAR_ANSIDIAN 0x002e  // "."
#define SC_CHAR_DE4     0x7684  // ""
#define SC_CHAR_XIAO    0x5c0f  // ""
#define SC_CHAR_LAO     0x8001  // ""

// Punctuation pairs
#define SC_CHAR_PUNL1   0x201c  // ""
#define SC_CHAR_PUNR1   0x201d  // ""
#define SC_CHAR_PUNL2   0x300a  // ""
#define SC_CHAR_PUNR2   0x300b  // ""
#define SC_CHAR_PUNL3   0xff08  // ""
#define SC_CHAR_PUNR3   0xff09  // ""
#define SC_CHAR_PUNL4   0x2018  // ""
#define SC_CHAR_PUNR4   0x2019  // ""
#define SC_CHAR_PUNL5   0x3014  // ""
#define SC_CHAR_PUNR5   0x3015  // ""
#define SC_CHAR_PUNL6   0x3016  // ""
#define SC_CHAR_PUNR6   0x3017  // ""
#define SC_CHAR_PUNL7   0x3010  // ""
#define SC_CHAR_PUNR7   0x3011  // ""
#define SC_CHAR_PUNL8   0x3008  // ""
#define SC_CHAR_PUNR8   0x3009  // ""
#define SC_CHAR_PUNL9   0xff3b  // ""
#define SC_CHAR_PUNR9   0xff3d  // ""
#define SC_CHAR_PUNL10  0xff5b  // ""
#define SC_CHAR_PUNR10  0xff5d  // ""

// Time category char def
#define SC_CHAR_MO      0x672b  // ""
#define SC_CHAR_QIAN2   0x524d  // ""
#define SC_CHAR_DI3     0x5e95  // ""
#define SC_CHAR_NEI     0x5185  // ""
#define SC_CHAR_ZHONG3  0x7ec8  // ""
#define SC_CHAR_MEI3    0x6bcf  // ""
#define SC_CHAR_MOU     0x67d0  // ""
#define SC_CHAR_JIN1    0x4eca  // ""
#define SC_CHAR_YUAN    0x5143  // ""
#define SC_CHAR_TIAN    0x5929  // ""
#define SC_CHAR_LING    0x96f6  // ""
#define SC_CHAR_DA      0x5927  // ""
#define SC_CHAR_SHI4    0x662f  // ""
#define SC_CHAR_BI      0x6bd4  // ""
// Chinese digits
#define SC_DIGIT_LING   SC_CHAR_LING    // 0x96f6 ""
#define SC_DIGIT_YI     SC_CHAR_YI      // 0x4e00 ""
#define SC_DIGIT_LIANG  SC_CHAR_LIANG   // 0x4e24 ""
#define SC_DIGIT_ER     0x4e8c          // 0x4e8c ""
#define SC_DIGIT_SAN    0x4e09          // 0x4e09 ""
#define SC_DIGIT_SI     0x56db          // 0x56db ""
#define SC_DIGIT_WU     0x4e94          // 0x4e94 ""
#define SC_DIGIT_LIU    0x516d          // 0x516d ""
#define SC_DIGIT_QI     0x4e03          // 0x4e03 ""
#define SC_DIGIT_BA     0x516b          // 0x516b ""
#define SC_DIGIT_JIU    0x4e5d          // 0x4e5d ""
#define SC_DIGIT_SHI    SC_CHAR_SHI2    // 0x5341 ""
#define SC_DIGIT_BAI    SC_CHAR_BAI     // 0x767e ""
#define SC_DIGIT_QIAN   SC_CHAR_QIAN    // 0x5343 ""
#define SC_DIGIT_WAN    SC_CHAR_WAN     // 0x4e07 ""
#define SC_DIGIT_YI4    SC_CHAR_YI4     // 0x4ebf ""
#define SC_ARABIC_LING  0xff10          // 0xff10 ""
#define SC_SBCS_LING    0X0030          // 0X0030 "0"
#define SC_DBCS_LING    0X3007          // 0X3007 ""
// prefix char
#define SC_PFXCHAR_AA   0x963f  // ""
#define SC_PFXCHAR_CHAO 0x8d85  // ""
#define SC_PFXCHAR_DAI  0x4ee3  // ""
#define SC_PFXCHAR_FAN  0x53cd  // ""
#define SC_PFXCHAR_FEI  0x975e  // ""
#define SC_PFXCHAR_FU   0x526f  // ""
#define SC_PFXCHAR_GUO  SC_CHAR_GUO  // 0x8fc7  // ""
#define SC_PFXCHAR_LAO  SC_CHAR_LAO  // 0x8001  // ""
#define SC_PFXCHAR_WEI1 0x5fae  // ""
#define SC_PFXCHAR_WEI3 0x4f2a  // ""
#define SC_PFXCHAR_XIAO SC_CHAR_XIAO // 0x5c0f  // ""
#define SC_PFXCHAR_ZHUN 0x51c6  // ""
#define SC_PFXCHAR_ZONG 0x603b  // ""
// suffix char
#define SC_SFXCHAR_CHANG    0x573a  // ""
#define SC_SFXCHAR_ZHANG    0x957f  // ""
#define SC_SFXCHAR_DAN      0x5355  // ""
#define SC_SFXCHAR_DUI      0x5806  // ""
#define SC_SFXCHAR_ER       0x513f  // ""
#define SC_SFXCHAR_FA       0x6cd5  // ""
#define SC_SFXCHAR_FANG     0x65b9  // ""
#define SC_SFXCHAR_GAN      0x611f  // ""
#define SC_SFXCHAR_GUAN     0x89c2  // ""
#define SC_SFXCHAR_HUA      0x5316  // ""
#define SC_SFXCHAR_JI       0x673a  // ""
#define SC_SFXCHAR_JIA      0x5bb6  // ""
#define SC_SFXCHAR_JIE      0x754c  // ""
#define SC_SFXCHAR_LAO      0x8001  // ""
#define SC_SFXCHAR_LV       0x7387  // ""
#define SC_SFXCHAR_LUN      0x8bba  // ""
#define SC_SFXCHAR_MEN      0x4eec  // ""
#define SC_SFXCHAR_PIN      0x54c1  // ""
#define SC_SFXCHAR_QI       0x5668  // ""
#define SC_SFXCHAR_SHENG    0x751f  // ""
#define SC_SFXCHAR_SHENG3   0x7701  // ""
#define SC_SFXCHAR_SHI1     0x5e08  // ""
#define SC_SFXCHAR_SHI      0x5f0f  // ""
#define SC_SFXCHAR_SHI4     0x5e02  // ""
#define SC_SFXCHAR_TI       0x4f53  // ""
#define SC_SFXCHAR_TING     0x8247  // ""
#define SC_SFXCHAR_TOU      0x5934  // ""
#define SC_SFXCHAR_XING2    0x578b  // ""
#define SC_SFXCHAR_XING4    0x6027  // ""
#define SC_SFXCHAR_XUE      0x5b66  // ""
#define SC_SFXCHAR_YAN      0x708e  // ""
#define SC_SFXCHAR_YE       0x4e1a  // ""
#define SC_SFXCHAR_YI       0x4eea  // ""
#define SC_SFXCHAR_YUAN     0x5458  // ""
#define SC_SFXCHAR_ZHE      0x8005  // ""
#define SC_SFXCHAR_ZHENG    0x75c7  // ""
#define SC_SFXCHAR_ZHI      0x5236  // ""
#define SC_SFXCHAR_ZI       0x5b50  // ""

#define SC_DTWORD_YI     L"\x4e00"    // ""
#define SC_DTWORD_LIANG  L"\x4e24"    // ""
#define SC_DTWORD_ER     L"\x4e8c"    // ""
#define SC_DTWORD_SAN    L"\x4e09"    // ""
#define SC_DTWORD_SI     L"\x56db"    // ""
#define SC_DTWORD_WU     L"\x4e94"    // ""
#define SC_DTWORD_LIU    L"\x516d"    // ""
#define SC_DTWORD_QI     L"\x4e03"    // ""
#define SC_DTWORD_BA     L"\x516b"    // ""
#define SC_DTWORD_JIU    L"\x4e5d"    // ""
#define SC_DTWORD_SHI    L"\x5341"    // ""
#define SC_DTWORD_BAI    L"\x767e"    // ""
#define SC_DTWORD_QIAN   L"\x5343"    // ""
#define SC_DTWORD_WAN    L"\x4e07"    // ""
#define SC_DTWORD_YI4    L"\x4ebf"    // ""

#define SC_WORD_BENYUE      L"\x672c\x6708"  // ""
#define SC_WORD_SHANGYUE    L"\x4e0a\x6708"  // ""
#define SC_WORD_XIAYUE      L"\x4e0b\x6708"  // ""
#define SC_WORD_JINNIAN     L"\x4eca\x5e74"  // ""
#define SC_WORD_QUNIAN      L"\x53bb\x5e74"  // ""
#define SC_WORD_MINGNIAN    L"\x660e\x5e74"  // ""
#define SC_WORD_ZHIYI       L"\x4e4b\x4e00"  // ""
#define SC_WORD_WANLIANG    L"\x4e07\x4e24"  // ""
#define SC_WORD_YI4LIANG    L"\x4ebf\x4e24"  // ""
#define SC_WORD_BADU        L"\x516b\x5ea6"  // ""
#define SC_WORD_BAINIAN     L"\x767e\x5e74"  // ""
#define SC_WORD_SHIFEN      L"\x5341\x5206"  // ""
#define SC_WORD_WANFEN      L"\x4e07\x5206"  // ""
#define SC_WORD_YIDIAN      L"\x4e00\x70b9"  // ""
#define SC_WORD_YISHI       L"\x4e00\x65f6"  // ""
// Decimal Tips
#define SC_WORD_FENZHI      L"\x5206\x4e4b"  // ""
#define SC_WORD_BAIFENZHI   L"\x767e\x5206\x4e4b"  // ""
#define SC_WORD_QIANFENZHI  L"\x5343\x5206\x4e4b"  // ""
#define SC_WORD_WANFENZHI   L"\x4e07\x5206\x4e4b"  // ""
// Approx Tips
#define SC_WORD_GUALING     L"\x6302\x96f6" // ""
#define SC_WORD_ZUOYOU      L"\x5de6\x53f3" // ""
#define SC_WORD_HAOJI       L"\x597d\x51e0" // ""
#define SC_WORD_BAINIAN     L"\x767e\x5e74" // ""
// Time category word def
#define SC_WORD_GONGYUAN        L"\x516c\x5143" // ""
#define SC_WORD_GONGYUANQIAN    L"\x516c\x5143\x524d"   // ""
#define SC_WORD_BANGE           L"\x534a\x4e2a" // ""
#define SC_WORD_MOUGE           L"\x67d0\x4e2a" // ""
#define SC_WORD_MEIGE           L"\x6bcf\x4e2a" // ""
// Time Category analysis
#define SC_TMWORD_SHIJI         L"\x4e16\x7eaa" // ""
#define SC_TMWORD_NIANDAI       L"\x5e74\x4ee3" // ""
#define SC_TMWORD_NIAN          L"\x5e74" // ""
#define SC_TMWORD_NIANDU        L"\x5e74\x5ea6" // ""
#define SC_TMWORD_NIANTOU       L"\x5e74\x5934" // ""
#define SC_TMWORD_CAINIAN       L"\x8d22\x5e74" // ""
#define SC_TMWORD_JIDU          L"\x5b63\x5ea6" // ""
#define SC_TMWORD_YUE           L"\x6708" // ""
#define SC_TMWORD_YUEFEN        L"\x6708\x4efd" // ""
#define SC_TMWORD_ZHOU          L"\x5468" // ""
#define SC_TMWORD_XINGQI        L"\x661f\x671f" // ""
#define SC_TMWORD_LIBAI         L"\x793c\x62dc" // ""
#define SC_TMWORD_TIAN          L"\x5929" // ""
#define SC_TMWORD_RI            L"\x65e5" // ""
#define SC_TMWORD_XIAOSHI       L"\x5c0f\x65f6" // ""
#define SC_TMWORD_ZHONGTOU      L"\x949f\x5934" // ""
#define SC_TMWORD_SHI           L"\x65f6" // ""
#define SC_TMWORD_DIAN          L"\x70b9" // ""
#define SC_TMWORD_FEN           L"\x5206" // ""
#define SC_TMWORD_FENZHONG      L"\x5206\x949f" // ""
#define SC_TMWORD_MIAO          L"\x79d2" // ""
// ambi
#define SC_WORD_NIANTOU         L"\x5e74\x5934" // ""
#define SC_WORD_RIQIAN          L"\x65e5\x524d" // ""

#define SC_QTWORD_BEI           L"\x500d"   // ""
#define SC_QTWORD_GE            L"\x4e2a"   // ""
#define SC_QTWORD_ZHONG         L"\x79cd"   // ""

#define SC_DMWORD_ZHE           L"\x8fd9"   // ""
#define SC_DMWORD_GE            L"\x5404"   // ""
#define SC_DMWORD_NA            L"\x90a3"   // ""

#define SC_APXWORD_DUO          L"\x591a"   // ""
#define SC_APXWORD_JIN          L"\x8fd1"   // ""
#define SC_APXWORD_LAI          L"\x6765"   // ""
#define SC_APXWORD_SHU          L"\x6570"   // ""
#define SC_APXWORD_YU           L"\x4f59"   // ""
#define SC_APXWORD_YUE          L"\x7ea6"   // ""

#define SC_APXNUM_YIER          L"\x4e00\x4e8c"   // ""
#define SC_APXNUM_YILIANG       L"\x4e00\x4e24"   // ""
#define SC_APXNUM_LIANGSAN      L"\x4e24\x4e09"   // ""
#define SC_APXNUM_SANLIANG      L"\x4e09\x4e24"   // ""
#define SC_APXNUM_ERSAN         L"\x4e8c\x4e09"   // ""
#define SC_APXNUM_SANSI         L"\x4e09\x56db"   // ""
#define SC_APXNUM_SANWU         L"\x4e09\x4e94"   // ""
#define SC_APXNUM_SIWU          L"\x56db\x4e94"   // ""
#define SC_APXNUM_WULIU         L"\x4e94\x516d"   // ""
#define SC_APXNUM_LIUQI         L"\x516d\x4e03"   // ""
#define SC_APXNUM_QIBA          L"\x4e03\x516b"   // ""
#define SC_APXNUM_BAJIU         L"\x516b\x4e5d"   // ""

#endif // _SCCHARDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\registry.h ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: Registry
Purpose:   Helper functions registering and unregistering a component
Remarks:
Owner:     i-shdong@microsoft.com
Platform:  Win32
Revise:    First created by: i-shdong    11/17/1999
============================================================================*/
#ifndef __Registry_H__
#define __Registry_H__

// Set the given key and its value.
BOOL setKeyAndValue(LPCTSTR pszPath,
                    LPCTSTR szSubkey,
                    LPCTSTR szValue,
                    LPCTSTR szName = NULL) ;

// Convert a CLSID into a char string.
void CLSIDtoString(const CLSID& clsid,
                   LPCTSTR szCLSID,
                   int length) ;

// Determine if a particular subkey exists.
BOOL SubkeyExists(LPCTSTR pszPath,
                  LPCTSTR szSubkey) ;

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, LPCTSTR szKeyChild) ;

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule,
                       const CLSID& clsid,
                       LPCTSTR szFriendlyName,
                       LPCTSTR szVerIndProgID,
                       LPCTSTR szProgID) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid,
                         LPCTSTR szVerIndProgID,
                         LPCTSTR szProgID) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ChsBrkr.rc
//
#define IDS_PROJNAME                    100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\registry.cpp ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: Registry
Purpose:   Helper functions registering and unregistering a component
Remarks:
Owner:     i-shdong@microsoft.com
Platform:  Win32
Revise:    First created by: i-shdong    11/17/1999
============================================================================*/
#include "MyAfx.h"

#include "registry.h"
// Constants
// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39 ;

// Convert a CLSID to a char string.
BOOL CLSIDtoString(const CLSID& clsid,
                   LPTSTR szCLSID,
                   int length)
{
    assert(szCLSID);
    assert(length >= CLSID_STRING_SIZE) ;
    // Get CLSID
#ifdef _UNICODE
    HRESULT hr = StringFromGUID2(clsid, szCLSID, length) ;
    if (!SUCCEEDED(hr)) {
        assert(0);
        return FALSE;
    }
#else
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    if (!SUCCEEDED(hr)) {
        assert(0);
        // Free memory.
        CoTaskMemFree(wszCLSID) ;
        return FALSE;
    }
    // Covert from wide characters to non-wide.
    wcstombs(szCLSID, wszCLSID, length) ;
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
#endif
    return TRUE;
}

// Delete a key and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        LPCTSTR lpszKeyChild)  // Key to delete
{
    assert(lpszKeyChild);
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
                             KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS) {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
                        NULL, NULL, &time) == S_OK) {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS) {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

// Determine if a particular subkey exists.
BOOL SubkeyExists(LPCTSTR pszPath,    // Path of key to check
                  LPCTSTR szSubkey)   // Key to check
{
    HKEY hKey ;
    TCHAR szKeyBuf[80] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, pszPath) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _TEXT("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Determine if key exists by trying to open it.
    LONG lResult = ::RegOpenKeyEx(HKEY_CLASSES_ROOT,
                                  szKeyBuf,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hKey) ;
    if (lResult == ERROR_SUCCESS)
    {
        RegCloseKey(hKey) ;
        return TRUE ;
    }
    return FALSE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(LPCTSTR szKey,
                    LPCTSTR szSubkey,
                    LPCTSTR szValue,
                    LPCTSTR szName)
{
    HKEY hKey;
    TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _TEXT("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
                                  szKeyBuf,
                                  0, NULL, REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS, NULL,
                                  &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
                      (BYTE *)szValue,
                      sizeof(TCHAR) * (_tcslen(szValue)+1)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

// Register the component in the registry.
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       LPCTSTR szFriendlyName, // Friendly Name
                       LPCTSTR szVerIndProgID, // Programmatic
                       LPCTSTR szProgID)       //   IDs
{
    // Get server location.
    TCHAR szModule[512] ;
    DWORD dwResult = ::GetModuleFileName(hModule,
                                         szModule,
                                         sizeof(szModule)/sizeof(TCHAR)) ;
    assert(dwResult != 0) ;

    // Convert the CLSID into a char.
    TCHAR szCLSID[CLSID_STRING_SIZE] ;
    CLSIDtoString(clsid, szCLSID, sizeof(szCLSID) / sizeof(TCHAR)) ;

    // Build the key CLSID\\{...}
    TCHAR szKey[64] ;
    _tcscpy(szKey, _TEXT("CLSID\\")) ;
    _tcscat(szKey, szCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _TEXT("InprocServer32"), szModule) ;

    // Add Threading Model
    setKeyAndValue(szKey,
                   _TEXT("InprocServer32"),
                   _TEXT("Both"),
                   _TEXT("ThreadingModel")) ;

    // Add the ProgID subkey under the CLSID key.
    setKeyAndValue(szKey, _TEXT("ProgID"), szProgID) ;

    // Add the version-independent ProgID subkey under CLSID key.
    setKeyAndValue(szKey, _TEXT("VersionIndependentProgID"),
                   szVerIndProgID) ;

    // Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
    setKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ;
    setKeyAndValue(szVerIndProgID, _TEXT("CLSID"), szCLSID) ;
    setKeyAndValue(szVerIndProgID, _TEXT("CurVer"), szProgID) ;

    // Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
    setKeyAndValue(szProgID, NULL, szFriendlyName) ;
    setKeyAndValue(szProgID, _TEXT("CLSID"), szCLSID) ;

    return S_OK ;
}

// Remove the component from the registry.
LONG UnregisterServer(const CLSID& clsid,         // Class ID
                      LPCTSTR szVerIndProgID, // Programmatic
                      LPCTSTR szProgID)       //   IDs
{
    // Convert the CLSID into a char.
    TCHAR szCLSID[CLSID_STRING_SIZE] ;
    CLSIDtoString(clsid, szCLSID, sizeof(szCLSID) / sizeof(TCHAR)) ;

    // Build the key CLSID\\{...}
    TCHAR szKey[80] ;
    _tcscpy(szKey, _TEXT("CLSID\\")) ;
    _tcscat(szKey, szCLSID) ;

    // Check for a another server for this component.
    if (SubkeyExists(szKey, _TEXT("LocalServer32"))) {
        // Delete only the path for this server.
        _tcscat(szKey, _TEXT("\\InprocServer32")) ;
        LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
        assert(lResult == ERROR_SUCCESS) ;
    } else {
        // Delete all related keys.
        // Delete the CLSID Key - CLSID\{...}
        LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
        assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

        // Delete the version-independent ProgID Key.
        lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;
        assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

        // Delete the ProgID key.
        lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;
        assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    }
    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\slmdef.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component:  SLMDef
Purpose:    Declare constants and the file structure of Statistical Language Model.
                1. Define the syntactic categories used in SLM.
                2. Define the special WordID, semantic categories in some point of view.
                3. Define the file structure of the runtime WordMatrix.
            This is only a header file w/o any CPP, this header will be included
            by all SLM modules. 
            
Notes:      We drop this file in Engine sub project only because we want to make 
            Engine code self-contained
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    2/6/98
============================================================================*/
#ifndef _SLMDEF_H_
#define _SLMDEF_H_

//  Define the type of WordID
typedef WORD WORDID;

/*============================================================================
Define the syntactic categories used in the SLM.
============================================================================*/

//  Count of syntactic category
#define SLMDef_CountOfSynCat    19

//  All syntactic categories defined in SLMDef_syn prefix
#define SLMDef_synChar      0
#define SLMDef_synVN        1   // ()
#define SLMDef_synVA        2   // 
#define SLMDef_synV         3   // 
#define SLMDef_synAN        4   // ()
#define SLMDef_synA         5   // 
#define SLMDef_synN         6   // 
#define SLMDef_synT         7   // 
#define SLMDef_synS         8   // 
#define SLMDef_synF         9   // 
#define SLMDef_synM         10  // 
#define SLMDef_synQ         11  // 
#define SLMDef_synB         12  // 
#define SLMDef_synR         13  // 
#define SLMDef_synZ         14  // 
#define SLMDef_synD         15  // 
#define SLMDef_synP         16  // 
#define SLMDef_synC         17  // 
#define SLMDef_synMisc      18  // ()


/*============================================================================
Define the special WordID, it stands for the semantic categories in some point of view.
============================================================================*/

//  Count of semantic category (special WordID)
#define SLMDef_CountOfSemCat    55

//  All semantic categories defines in SLMDef_sem prefix
#define SLMDef_semNone      0   // Words non't involved in SLM check
//  
#define SLMDef_semPerson    1   // 
#define SLMDef_semPlace     2   // 
#define SLMDef_semOrg       3   // 
#define SLMDef_semTM        4   // 
#define SLMDef_semTerm      5   // 
//  
#define SLMDef_semInteger   6   // 
#define SLMDef_semCode      7   // 
#define SLMDef_semDecimal   8   // 
#define SLMDef_semPercent   9   // 
#define SLMDef_semOrdinal   10  // 
//  
#define SLMDef_semRRen      11  // 
//  
#define SLMDef_semChang     12  // <>
#define SLMDef_semDan       13  // <>
#define SLMDef_semDui       14  // <>
#define SLMDef_semEr        15  // <>
#define SLMDef_semFa        16  // <>
#define SLMDef_semFang      17  // <>
#define SLMDef_semGan       18  // <>
#define SLMDef_semGuan      19  // <>
#define SLMDef_semHua       20  // <>
#define SLMDef_semJi        21  // <>
#define SLMDef_semJia       22  // <>
#define SLMDef_semJie       23  // <>
#define SLMDef_semLao       24  // <>
#define SLMDef_semLun       25  // <>
#define SLMDef_semLv        26  // <>
#define SLMDef_semMen       27  // <>
#define SLMDef_semPin       28  // <>
#define SLMDef_semQi        29  // <>
#define SLMDef_semSheng     30  // <>
#define SLMDef_semSheng3    31  // <>
#define SLMDef_semShi       32  // <>
#define SLMDef_semShi1      33  // <>
#define SLMDef_semShi4      34  // <>
#define SLMDef_semTi        35  // <>
#define SLMDef_semTing      36  // <>
#define SLMDef_semTou       37  // <>
#define SLMDef_semXing2     38  // <>
#define SLMDef_semXing4     39  // <>
#define SLMDef_semXue       40  // <>
#define SLMDef_semYan       41  // <>
#define SLMDef_semYe        42  // <>
#define SLMDef_semYi        43  // <>
#define SLMDef_semYuan      44  // <>
#define SLMDef_semZhang     45  // <>
#define SLMDef_semZhe       46  // <>
#define SLMDef_semZheng     47  // <>
#define SLMDef_semZi        48  // <>
#define SLMDef_semZhi       49  // <>
//  Pattern
#define SLMDef_semDup       50  // 
#define SLMDef_semPattern   51  // Pattern
//  
#define SLMDef_semIdiom     52  // 
#define SLMDef_semPunct     53  // ()
#define SLMDef_semMisc      54  // 


//------------------------------------------------------------------------------------------
//  Define the file structure of the runtime WordMatrix.
//------------------------------------------------------------------------------------------
#pragma pack(1)
// Define the WordMatrix header
struct CWordMatrixHeader {
    DWORD   m_dwLexVersion;
    DWORD   m_ciWordID;
    DWORD   m_ofbMatrix;        // Start position of the matrix
    DWORD   m_cbMatrix;         // Length of the matrix, only for verification
};

// Define the WordMatrix index item
struct CWordMatrixIndex {
    DWORD   m_ofbMatrix;
    UINT    m_ciLeftNode    : (32 - SLMDef_CountOfSynCat);
    UINT    m_bitLeft       : SLMDef_CountOfSynCat;
    UINT    m_ciRightNode   : (32 - SLMDef_CountOfSynCat);
    UINT    m_bitRight      : SLMDef_CountOfSynCat;
};

// All WordMatrix node listed one by one continuously, no separators between sections

#pragma pack()


#endif  // _SLMDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\server.cpp ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: Server.cpp
Purpose:   This file contains the component server code.
           The FactoryDataArray contains the components that 
           can be served.
Remarks:
Owner:     i-shdong@microsoft.com
Platform:  Win32
Revise:    First created by: i-shdong    11/17/1999
============================================================================*/
#include "MyAfx.h"

#include "query.h"
#include "CUnknown.h"
#include "CFactory.h"
#include "IWordBreaker.h"

#include "classid.hxx"

// Each component derived from CUnknown defines a static function
// for creating the component with the following prototype. 
// HRESULT CreateInstance(IUnknown* pUnknownOuter, 
//                        CUnknown** ppNewComponent) ;
// This function is used to create the component.
//

//
// The following array contains the data used by CFactory
// to create components. Each element in the array contains
// the CLSID, the pointer to the creation function, and the name
// of the component to place in the Registry.
//
CFactoryData g_FactoryDataArray[] =
{
    {&CLSID_Chinese_Simplified_WBreaker, CIWordBreaker::CreateInstance, 
        _TEXT("Chinese_Simplified Word Breaker"),  // Friendly Name
        _TEXT("Chinese_Simplified Word Breaker.2"),// ProgID
        _TEXT("Chinese_Simplified Word Breaker")}  // Version-independent ProgID
} ;
int g_cFactoryDataEntries
    = sizeof(g_FactoryDataArray) / sizeof(CFactoryData) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\utility.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: Utility.h

Purpose:   Utility stuffs
Notes:     
Owner:     donghz@microsoft.com
Platform:  Win32
Revise:    First created by: donghz 4/21/97
============================================================================*/
#ifndef _UTILITY_H_
#define _UTILITY_H_

#include <assert.h>

#ifdef  __cplusplus
extern  "C"
{
#endif  // __cplusplus

// Get base directory of the given path
BOOL GetBaseDirectory(LPCTSTR szFullPath, LPTSTR szBaseDir, int cBaseBuf);

// Get the file name from the given path
LPTSTR GetFileNameFromPath(LPCTSTR lpszPath);

// Check whether the given char is an EUDC char
BOOL fIsGBKEUDCChar(WORD wChar);

// Check whether the given char is an EUDC char
BOOL fIsEUDCChar(WCHAR wChar);

//    Check whether the given Unicode char is an CJK Unified Ideograph char
BOOL fIsIdeograph(WORD wChar); // wChar is an Unicode char

/*============================================================================
IsSurrogateChar
    Test if the 2 WCHAR at given pointer is a Surrogate char.
Entry:  pwch - pointer to 2 WCHAR
Return: TRUE
        FALSE    
Caution:
    Caller side must make sure the 4 bytes are valid memory!
============================================================================*/
inline BOOL IsSurrogateChar(LPCWSTR pwch)
{
    assert(! IsBadReadPtr((CONST VOID*)pwch, sizeof(WCHAR) * 2));
    if (((*pwch & 0xFC00) == 0xD800) && ((*(pwch+1) & 0xFC00) == 0xDC00)) {
        return TRUE;
    }

    assert(((*pwch & 0xFC00) != 0xD800) && ((*(pwch+1) & 0xFC00) != 0xDC00));
    return FALSE;
};

// Calculate length with Surrogate support of given 2byte Unicode string
UINT WideCharStrLenToSurrogateStrLen(LPCWSTR pwch, UINT cwch);

// Calculate length in WCHAR of given Surrogate string
UINT SurrogateStrLenToWideCharStrLen(const WORD *pwSurrogate, UINT cchSurrogate);

int ustrcmp (const unsigned char * src, const unsigned char * dst);

/*============================================================================
My DBCS validation function
============================================================================*/
//  Define Lex CodePage table constants
#define LEXLB   0x80    // Lex DBCS Lead byte
#define LEXTB   0x40    // Lex DBCS Trail byte
#define LEXSB   0x01    // ANSI single byte

//  Define the static s_LexCPTable
static UCHAR s_LexCPTable[256] =
    {
        0,      0,      0,      0,      0,      0,      0,      0,              // 0x07
        0,      0,      0,      0,      0,      0,      0,      0,              // 0x0F
        0,      0,      0,      0,      0,      0,      0,      0,              // 0x17
        0,      0,      0,      0,      0,      0,      0,      0,              // 0x1F

        LEXSB,  LEXSB,  LEXSB,  LEXSB,  LEXSB,  LEXSB,  LEXSB,  LEXSB,          // 0x27
        LEXSB,  LEXSB,  LEXSB,  LEXSB,  LEXSB,  LEXSB,  LEXSB,  LEXSB,          // 0x2F
        LEXSB,  LEXSB,  LEXSB,  LEXSB,  LEXSB,  LEXSB,  LEXSB,  LEXSB,          // 0x37
        LEXSB,  LEXSB,  LEXSB,  LEXSB,  LEXSB,  LEXSB,  LEXSB,  LEXSB,          // 0x3F

        LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,          // 0x43
        LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,          // 0x47
        LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,          // 0x4B
        LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,          // 0x4F
        LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,          // 0x53
        LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,          // 0x57
        LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,          // 0x5B
        LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,          // 0x5F
        LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,          // 0x63
        LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,          // 0x67
        LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,          // 0x6B
        LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,          // 0x6F
        LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,          // 0x73
        LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,          // 0x77
        LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,          // 0x7B
        LEXSB | LEXTB,  LEXSB | LEXTB,  LEXSB | LEXTB,  0,                      // 0x7F

        LEXTB,          LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0x83
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0x87
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0x8B
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0x8F
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0x93
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0x97
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0x9B
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0x9F
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xA3
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xA7
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xAB
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xAF
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xB3
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xB7
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xBB
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xBF
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xC3
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xC7
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xCB
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xCF
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xD3
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xD7
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xDB
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xDF
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xE3
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xE7
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xEB
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xEF
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xF3
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xF7
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,          // 0xFB
        LEXLB | LEXTB,  LEXLB | LEXTB,  LEXLB | LEXTB,  0                       // 0xFF
    };


inline BOOL fIsDBCSLead(UCHAR uch)
{
    return (s_LexCPTable[uch] & LEXLB);
}
        

inline BOOL fIsDBCSTrail(UCHAR uch)
{
    return (s_LexCPTable[uch] & LEXTB); 
}
    

#ifdef  __cplusplus
}
#endif  // __cplusplus

#endif  // _UTILITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\utility.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: Utility.cpp

Purpose:   Utility stuffs
Notes:     
Owner:     donghz@microsoft.com
Platform:  Win32
Revise:    First created by: donghz 4/22/97
============================================================================*/
#include <windows.h>
#include <assert.h>

#include "Utility.h"

/*============================================================================
BOOL GetBaseDirectory()
    Get base directory of the given path
Return: 
    TRUE if base dir parse success, szBaseDir = "c:\...\...\"
    FALSE, szBaseDir = ""
============================================================================*/
BOOL GetBaseDirectory(
        LPCTSTR szFullPath, 
        LPTSTR  szBaseDir, 
        int cBaseBuf)//Specifies the number bytes (ANSI version) 
                     //or characters (Unicode version) of szBaseDir
{
    assert(! IsBadStringPtr(szFullPath, MAX_PATH));
    assert(cBaseBuf && ! IsBadStringPtr(szBaseDir, cBaseBuf));
    int ilen;

    szBaseDir[0] = NULL;
    
    for (ilen = lstrlen(szFullPath); 
         ilen && *(szFullPath + ilen) != TEXT('\\'); ilen--) {
         ;
    }
    if (!ilen || ilen >= cBaseBuf) {
        return FALSE;
    }
    // szBaseDir = "c:\...\...\"
    lstrcpyn(szBaseDir, szFullPath, ilen+2);
    return TRUE;
}
        
/*============================================================================
LPTSTR GetFileNameFromPath()
    Get the file name from the given path
Returns:
    the pointer to the start position in the path
============================================================================*/
LPTSTR GetFileNameFromPath(LPCTSTR lpszPath)
{
    LPTSTR pc = const_cast<LPTSTR>(lpszPath);
    LPTSTR pbs = const_cast<LPTSTR>(lpszPath);
    while (*pc) {
        if(*pc == TEXT('\\')) {
            pbs = pc+1;
        }
        pc++;
    }
    return pbs;
}

/*============================================================================
fIsGBKEUDCChar
    Check whether the given char is an EUDC char
Returns:
    TRUE if hit EUDC area
============================================================================*/
BOOL fIsGBKEUDCChar(WORD wChar)
{
    if(wChar >= 0xA1B0 && wChar <= 0xFEF7) { // GB 2312 Area 0xB0A1-0xF7FE
        return FALSE;
    }
    if( (wChar >= 0x40A1 && wChar <= 0xA0A7) || // 0xA140 - 0xA7A0
        (wChar >= 0xA1AA && wChar <= 0xFEAF) || // 0xAAA1 - 0xAFFE
        (wChar >= 0xFAF8 && wChar <= 0xFEFE)    // 0xF8FA - 0xFEFE
      ) {
        return TRUE;
    }
    return FALSE;
}

/*============================================================================
fIsEUDCChar
    Check whether the given Unicode char is an EUDC char
Returns:
    TRUE if hit EUDC area
============================================================================*/
BOOL fIsEUDCChar(WORD wChar) // wChar is an Unicode char
{
    if (wChar >= 0xE000 && wChar <= 0xF8FF) {
        return TRUE;
    }
    return FALSE;
}

/*============================================================================
fIsIdeograph
    Check whether the given Unicode char is an CJK Unified Ideograph char
Returns:
    TRUE
============================================================================*/
BOOL fIsIdeograph(WORD wChar) // wChar is an Unicode char
{
    if (wChar >= 0x4E00 && wChar <= 0x9FFF) {
        return TRUE;
    }
    return FALSE;
}

/*============================================================================
ustrcmp
Entry:	const char * src - string for left-hand side of comparison
		const char * dst - string for right-hand side of comparison
Return:	returns -1 if src <  dst
		returns  0 if src == dst
		returns +1 if src >  dst
============================================================================*/
int ustrcmp (const unsigned char * src, const unsigned char * dst)
{
	int ret = 0;

	while( !( ret = (int)((unsigned char)*src - (unsigned char)*dst) ) && *dst )
		++src, ++dst;

	if ( ret < 0 )
		ret = -1 ;
	else if ( ret > 0 )
		ret = 1 ;

	return( ret );
}


/*============================================================================
WideCharStrLenToSurrogateStrLen
    Calculate length with Surrogate support of given 2byte Unicode string
Return: 
============================================================================*/
UINT WideCharStrLenToSurrogateStrLen(LPCWSTR pwch, UINT cwch)
{
    assert(! IsBadReadPtr((CONST VOID*)pwch, sizeof(WCHAR) * cwch));

    UINT cchSurrogate = cwch;
    for (UINT i=0; i<cwch - 1; i++) {
        if (IsSurrogateChar(pwch+i)) {
            i++;
            cchSurrogate --;
        }
    }
    assert(i==cwch || i==cwch - 1);

    return cchSurrogate;
}

/*============================================================================
SurrogateStrLenToWideCharStrLen
    Calculate length in WCHAR of given Surrogate string
Return: 
    wchar length of pwSurrogate
============================================================================*/
UINT SurrogateStrLenToWideCharStrLen(const WORD *pwSurrogate, UINT cchSurrogate)
{
    assert(! IsBadReadPtr((CONST VOID*)pwSurrogate, sizeof(WCHAR) * cchSurrogate));

    UINT  cwch = cchSurrogate;

    for (UINT i=0; i<cchSurrogate; i++, cwch++) {
        if ((*(pwSurrogate+cwch) & 0xFC00) == 0xD800) {
            cwch++;
            assert((*(pwSurrogate+cwch) & 0xFC00) == 0xDC00);
        }
    }
    assert(i==cchSurrogate && cwch>=cchSurrogate);
    assert(! IsBadReadPtr((CONST VOID*)pwSurrogate, sizeof(WCHAR) * cwch));

    return cwch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\wbdicdef.h ===
/*
*	WBDicDef.h
*	Define the dic header for CHammer word breaker 
*/
#ifndef _WBDICDEF_H_
#define _WBDICDEF_H_

// define the dic header
struct CWBDicHeader
	{
	DWORD	m_ofbCharFreq;
	DWORD	m_ofbLexicon;
	};


#endif	// _WBDICDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\wbengine.cpp ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: WBEngine    
Purpose:   CWBEngine class is the control and interface class of WordBreaking Engine
           It depend on all other class in WordBreaking Engine
Remarks:
Owner:     donghz@microsoft.com
Platform:  Win32
Revise:    First created by: donghz                6/6/97
           Isolated as a WordBreaker by donghz     8/5/97
============================================================================*/
#include "myafx.h"

#include "WBEngine.h"
#include "wbdicdef.h"
#include "WrdBreak.h"
#include "Lexicon.h"
#include "CharFreq.h"
#include "WordLink.h"
#include "ProofEC.h"
#include "utility.h"
#include "morph.h"
#include "jargon.h"
#include "WCStack.h"
#include "SCCharDef.h"

//  Constructor
CWBEngine::CWBEngine()
{
    m_fInit         = FALSE;
    // initialize the object handles
    m_pWordBreak    = NULL;
    m_pMorph        = NULL;
    m_pJargon       = NULL;
    m_pLexicon      = NULL;
    m_pCharFreq     = NULL;
    // Initialize the file mapping handles
    m_pbLex = NULL;
}


//  Destructor
CWBEngine::~CWBEngine()
{
    if (m_fInit) {
        TermEngine();
    }
}


//  Break given WordLink
HRESULT CWBEngine::BreakLink(CWordLink* pLink,
                           BOOL fQuery) // Index time break or Query time break
{
    int     iret;

    if (!m_fInit) {
        assert(0);
        iret = E_FAIL;
        goto gotoExit;
    }

    iret = m_pWordBreak->ecBreakSentence(pLink);
    if (iret != PRFEC::gecNone && iret != PRFEC::gecPartialSentence) {
        iret = E_FAIL;
        goto gotoExit;
    }
    iret = m_pMorph->ecDoMorph(pLink, fQuery);
    if (iret != PRFEC::gecNone) {
        iret = E_FAIL;
        goto gotoExit;
    }

    if (fQuery) {
        iret = m_pJargon->ecDoJargon(pLink);
        if (iret != PRFEC::gecNone) {
            iret = E_FAIL;
            goto gotoExit;
        }
    }

    iret = S_OK;
gotoExit:
    return iret;
}

// get the iwbPhr feature data of the pWord, and convert to WORD
// if no iwbPhr feature , return 0;
WORD CWBEngine::GetPhrFeature(CWord* pWord)
{
    WORD wFtr = 0;
    USHORT  cwFtr = 0;
    LPBYTE  pbFtr;
    pbFtr = (LPBYTE)m_pLexicon->pwchGetFeature(pWord->GetLexHandle(),
                                               LFDef_iwbPhr, &cwFtr);
    assert(cwFtr <= 1);
    if (pbFtr && cwFtr == 1) {
        wFtr = ((WORD)pbFtr[0] << 8) | (WORD)pbFtr[1];
    }
    return wFtr;
}


//  Initialize the WordBreak object, Lexicon and CharFreq object
//  Return ERROR_SUCCESS if success
HRESULT CWBEngine::InitEngine(LPBYTE pbLex)
{
    assert(pbLex);
    int      iret = ERROR_OUTOFMEMORY;
    
    if (m_fInit) {
        assert(0);
        return ERROR_SUCCESS;
    }

    m_pbLex = pbLex;
    // alloc the lexicon and charfreq objects
    if ((m_pLexicon = new CLexicon) == NULL) {
        goto gotoError;
    }
    if ((m_pCharFreq = new CCharFreq) == NULL) {
        goto gotoError;
    }
    // open the lexicon and mapping the lexicon and charfreq resource into memory
    if (!fOpenLexicon()) {
        iret = E_FAIL;
        goto gotoError;
    }

    // Alloc and initialize the word breaker object
    if ((m_pWordBreak = new CWordBreak) == NULL) {
        goto gotoError;
    }
    if (PRFEC::gecNone != m_pWordBreak->ecInit(m_pLexicon, m_pCharFreq)) {
        goto gotoError;
    }
    if ((m_pMorph = new CMorph) == NULL) {
        goto gotoError;
    }
    if (PRFEC::gecNone != m_pMorph->ecInit(m_pLexicon)) {
        goto gotoError;
    }

    if ((m_pJargon = new CJargon) == NULL) {
        goto gotoError;
    }
    if (PRFEC::gecNone != m_pJargon->ecInit(m_pLexicon)) {
        goto gotoError;
    }

    m_fInit = TRUE;
    return ERROR_SUCCESS;
gotoError:
    TermEngine();
    return iret;
}


//  Terminate the Proof Engine
void CWBEngine::TermEngine(void)
{
    if (m_pWordBreak) { 
        delete m_pWordBreak; 
        m_pWordBreak = NULL;
    }

    if (m_pMorph) {
        delete m_pMorph;
        m_pMorph = NULL;
    }

    if (m_pJargon) {
        delete m_pJargon;
        m_pJargon = NULL;
    }

    CloseLexicon();

    if (m_pLexicon) {
        delete m_pLexicon;
        m_pLexicon = NULL;
    }
    if (m_pCharFreq) {
        delete m_pCharFreq;
        m_pCharFreq = NULL;
    }

    m_pbLex = NULL;
    m_fInit = FALSE;
    return;
}


//  Open the lexicon and charfreq resource into memory
//  The lexicon file format is encapsulated in this function
BOOL CWBEngine::fOpenLexicon(void)
{
    CWBDicHeader*   phdr;

    assert(m_pbLex);
    // Validate the header of the lex file
    phdr = (CWBDicHeader*)m_pbLex;
    if (phdr->m_ofbCharFreq != sizeof(CWBDicHeader) ||
        phdr->m_ofbLexicon <= phdr->m_ofbCharFreq ) {
        goto gotoError; // error lex format!
    }

    // Open the char freq table
    if (!m_pCharFreq->fOpen(m_pbLex + phdr->m_ofbCharFreq)) {
        goto gotoError;
    }
    // Open the lexicon
    if (!m_pLexicon->fOpen(m_pbLex + phdr->m_ofbLexicon)) {
        goto gotoError;
    }

    return TRUE;
gotoError:
    CloseLexicon();
    return FALSE;
}


// Close the lexicon file and unmap the lexicon and charfreq file mapping
inline void CWBEngine::CloseLexicon(void)
{
    if (m_pCharFreq) {
        m_pCharFreq->Close();
    }
    if (m_pLexicon) {
        m_pLexicon->Close();
    }
    return;
}


// define ANSI char type for driving the LSM
#define TEXT_NULL		0
#define TEXT_NUMBER		1
#define TEXT_JU	        2	// Sentence terminating punctuations
#define TEXT_PUNCT		4	// Punctuation except sentence terminators
#define TEXT_TEXT		5

/*============================================================================
FindSentence():
    Find a sentence in text buffer.

Arguments:   [in] pszBuffStart
                  This is the beginning of the buffer.
             [in] wchLen
                  This is the length of the buffer. if no sentence end is 
                  found after this , then PRFEC::gecPartialSentence is 
                  returned to signify no complete sentence found.
             [out] pcchSent
                  The number of characters found in the sentence, 
                  not including the trailing spaces, and
                  not including the NULL terminator.
                  
Returns:     PRFEC::gecNone
                  The Sentence Seperator found a complete sentence
             PRFEC::gecPartialSentence
                  If no sentence end point could be established,
                  or the sentence was too long.
============================================================================*/
INT CWBEngine::FindSentence(LPCWSTR pwszStart,
                               const INT wchLen,
                               INT *pwchSent)
{
    assert(! IsBadReadPtr(pwszStart, wchLen * sizeof(WCHAR)));

	INT		ich;
	INT 	iChar;
    INT     iret = PRFEC::gecUnknown;
    CWCStack    PunctStack;
	LPCWSTR  pMid;
	BYTE	hich, loch;
    WCHAR   wch, wchUnmatchedPunct = 0;

	pMid = pwszStart;

    PunctStack.Init();

gotoRescan:

    for (ich = 0; ich < wchLen; ich++) {
		iChar = TEXT_TEXT;
		hich = HIBYTE(pMid[ich]);
        if (hich == 0  || hich == 0xff) {// ansi or Full Size ansi
            if (pMid[ich] > 0xFF5f) {
				iChar = TEXT_TEXT;
            } else {
				loch = LOBYTE(pMid[ich]);
                if (hich == 0xFF) {
                    loch += 0x20;
                }
				switch(loch)
				{
					case '\x0d':
                        iChar = TEXT_JU;
                        break;

					case '.':
                        iChar = TEXT_JU;
                        if (ich < wchLen-1 &&
                            ich > 0 &&
                            ( pMid[ich-1] >= '0' && pMid[ich-1] <= '9' ||         // ansi 0 ~ 9
                              pMid[ich-1] >= 0xFF10 && pMid[ich-1] <= 0xFF19 ) && // wide  ~ 
                            ( pMid[ich+1] >= '0' && pMid[ich+1] <= '9' ||         // ansi 0 ~ 9
                              pMid[ich+1] >= 0xFF10 && pMid[ich+1] <= 0xFF19 ) ) {// wide  ~ 

    						iChar = TEXT_PUNCT;
                        }
						break;

                    case ':': case ';':
                        iChar = TEXT_JU;
						break;

					case '!': case '?':
                        iChar = TEXT_JU;
                        if (ich < wchLen-1 &&                            
                            ( pMid[ich+1] == '!' || pMid[ich+1] == '?' ||
                              pMid[ich+1] == 0xFF01 || pMid[ich+1] == 0xFF1F) ) {  // wide '' || ''

                            ich ++;
                        }
                        break;

					case '(':
					case '[':
                    case '{' :
                        iChar = TEXT_PUNCT;
                        PunctStack.EPush(pMid[ich]);
                        break;

                    case ')':
                        if (PunctStack.Pop(wch)) {
                            if (HIBYTE(wch) != hich ||
                                LOBYTE(wch) + (hich ? 0x20 : 0) != '(' ) {
                                // push the poped wchar back to the stack
                                PunctStack.Push(wch);
                            }
                        }
                        if (! PunctStack.IsEmpty()) {
                            iChar = TEXT_PUNCT;
                        } 
                        break;

                    case ']' :
                        if (PunctStack.Pop(wch)) {
                            if (HIBYTE(wch) != hich ||
                                LOBYTE(wch) + (hich ? 0x20 : 0) != '[' ) {
                                // push the poped wchar back to the stack
                                PunctStack.Push(wch);
                            }
                        }
                        if (! PunctStack.IsEmpty()) {
                            iChar = TEXT_PUNCT;
                        } 
                        break;

                    case '}':
                        if (PunctStack.Pop(wch)) {
                            if (HIBYTE(wch) != hich ||
                                LOBYTE(wch) + (hich ? 0x20 : 0) != '{' ) {
                                // push the poped wchar back to the stack
                                PunctStack.Push(wch);
                            } 
                        }
                        if (! PunctStack.IsEmpty()) {
                            iChar = TEXT_PUNCT;
                        } 
                        break;

					default:
						iChar = TEXT_TEXT;
						break;
				} // end of switch()
			} // end of if else
		} // end of if ansi
		else {
			// check for Hanzi punc chars
			switch (pMid[ich])
			{
			case 0x3002: //
//            case 0xff0c: //
//            case 0x3001: //
                iChar = TEXT_JU;
                break;

            case SC_CHAR_PUNL1:
            case SC_CHAR_PUNL2:
            case SC_CHAR_PUNL3:
            case SC_CHAR_PUNL4:
            case SC_CHAR_PUNL5:
            case SC_CHAR_PUNL6:
            case SC_CHAR_PUNL7:
            case SC_CHAR_PUNL8:
            case SC_CHAR_PUNL9:
            case SC_CHAR_PUNL10:
                iChar = TEXT_PUNCT;
                PunctStack.EPush(pMid[ich]);
                break;

            case SC_CHAR_PUNR1:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL1) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            case SC_CHAR_PUNR2:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL2) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            case SC_CHAR_PUNR3:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL3) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            case SC_CHAR_PUNR4:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL4) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            case SC_CHAR_PUNR5:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL5) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            case SC_CHAR_PUNR6:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL6) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            case SC_CHAR_PUNR7:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL7) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            case SC_CHAR_PUNR8:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL8) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            case SC_CHAR_PUNR9:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL9) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            case SC_CHAR_PUNR10:
                if (PunctStack.Pop(wch) &&
                    wch != SC_CHAR_PUNL10) {
                    // Error punctuation pair, maybe between other pair, ignore
                    // push the poped wchar back to the stack
                    PunctStack.Push(wch);
                }
                if (! PunctStack.IsEmpty()) {
                    iChar = TEXT_PUNCT;
                } 
                // else do not change iChar.
                break;

            default:
				iChar = TEXT_TEXT;
				break;
			}
		}

        if (iChar == TEXT_JU) {
            if (PunctStack.IsEmpty()) {
                ich++;
                iret = PRFEC::gecNone;
                break;
            } else {
                PunctStack.Pop(wch);
                if (wch == wchUnmatchedPunct && PunctStack.IsEmpty()) {
                    ich++;
                    iret = PRFEC::gecPartialSentence;
                    break;
                }
                PunctStack.Push(wch);
            }
		}
	} // end for

    if (iret == PRFEC::gecUnknown) {
        iret = PRFEC::gecPartialSentence;
        if (! PunctStack.IsEmpty()) {
            // some pair punctuation error.
            PunctStack.Pop(wchUnmatchedPunct);
            PunctStack.Empty();
            goto gotoRescan;
        }
    }

    assert(iret == PRFEC::gecNone || iret == PRFEC::gecPartialSentence);

    BOOL fCR = FALSE;
    // trail space, CR/LF
    while (ich < wchLen) {
        if (pMid[ich] == L'\r' || 
            pMid[ich] == L'\n' ) {
            
            fCR = TRUE;
            ich ++;
        } else if (! fCR && pMid[ich] == L' ') {
            
            ich ++;
        } else {
            break;
        }
    }

    *pwchSent = ich;

	return iret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\wbengine.h ===
/*============================================================================
Microsoft Simplified Chinese WordBreaker

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: WBEngine    
Purpose:   CWBEngine class is the control and interface class of WordBreaking Engine
           It depend on all other class in WordBreaking Engine
Remarks:
Owner:     donghz@microsoft.com
Platform:  Win32
Revise:    First created by: donghz                6/6/97
           Isolated as a WordBreaker by donghz     8/5/97
============================================================================*/
#ifndef _WBENGINE_H_
#define _WBENGINE_H_

//   Foreward declaration of some class
class CWordBreak;
class CLexicon;
class CCharFreq;
class CWordLink;
class CMorph;
struct CWord;
class CJargon;

//   Declare the CWBEngine class
class CWBEngine
{
    public:
        CWBEngine();
        ~CWBEngine();

        /*
        *   Initialize the WordBreak object, Lexicon and CharFreq object
        *   Return ERROR_SUCCESS if success
        */
        HRESULT InitEngine(LPBYTE pbLex);
        //   Break the given WordLink
        HRESULT BreakLink(CWordLink* pLink, BOOL fQuery = FALSE);

        // get the iwbPhr feature data of the pWord, and convert to WORD
        // if no iwbPhr feature , return 0;
        WORD    GetPhrFeature(CWord* pWord);

        // Find a sentence in text buffer.
        static INT FindSentence(LPCWSTR pwszStart,
                                const INT wchLen,
                                INT *pwchSent);


    private:
        BOOL        m_fInit;        // Whether the ProofEngine has been initialized

        CWordBreak* m_pWordBreak;
        CMorph*     m_pMorph;
        CJargon*    m_pJargon;

        CLexicon*   m_pLexicon;
        CCharFreq*  m_pCharFreq;

        BYTE*       m_pbLex;

    private:
        /*
        *   Terminate the Word Breaking Engine
        */
        void TermEngine(void);
        /*
        *   Open the lexicon file and mapping the lexicon and charfreq resource into memory
        *   The lexicon file format is encapsulated in this function
        */
        BOOL fOpenLexicon(void);
        /*
        *   Close the lexicon file and unmap the lexicon and charfreq file mapping
        */
        inline void CloseLexicon(void);
};

#endif  // _PROOFENG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\wrdbreak.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Module:     WordBreak
Purpose:    Implement the CWordBreak class. This class is in Algorithm Layer.
            Perform the max-match word segmentation, and ambiguous resolution
Notes:      This module depend on CLexicon, CWordLink and CWord class.
            Code in this module interact with linguistic resource layer through
            CWord object, and only use the WordInfo data type in Lexicon
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    2/12/97
============================================================================*/
#include "myafx.h"

#include "wrdbreak.h"
#include "wordlink.h"
#include "lexprop.h"
#include "lexicon.h"
#include "charfreq.h"
#include "proofec.h"
#include "utility.h"

#define _ANSI_LOW		0x0020
#define _ANSI_HIGH      0x007E
#define _WANSI_LOW		0xFF21
#define _WANSI_HIGH		0xFF5A
#define _EUROPEAN_LOW   0x0100
#define _EUROPEAN_HIGH  0x1FFF

/*============================================================================
Implementation of PUBLIC member functions
============================================================================*/
//  Constructor
CWordBreak::CWordBreak()
{
    m_pLexicon  = NULL;
    m_pFreq     = NULL;
    m_pwinfo    = NULL;
    m_pLink     = NULL;
    
    for (int i=0; i < MAX_AMBI_WORDS; i++) {
        m_rgAmbi[i] = NULL;
    }
}


//  Destructor
CWordBreak::~CWordBreak()
{
    if (m_pwinfo) {
        delete m_pwinfo;
    }
}

/*============================================================================
CWordBreak::ecInit():
    initialize the WordBreaker and set the object handles
Returns:
    Return PRFEC
Remarks:
    It's valid to initialize the WordBreaker more than once!
============================================================================*/
int CWordBreak::ecInit(CLexicon* pLexicon, CCharFreq* pFreq)
{
    assert(pLexicon && pFreq);

    if (!m_pwinfo) {
        if ((m_pwinfo = new CWordInfo) == NULL) {
            m_pLexicon = NULL;
            m_pFreq = NULL;
            return PRFEC::gecOOM;
        }
    }
    m_pLink     = NULL;
    m_pLexicon  = pLexicon;
    m_pFreq     = pFreq;
    return PRFEC::gecNone;
}
      
/*============================================================================
Implementation of PRIVATE member functions
============================================================================*/
#pragma optimize("t", on)

// define ANSI char type for driving the LSM
#define WB_ANSI_NULL		0
#define WB_ANSI_NUMBER		1
#define WB_ANSI_SENTENCE	2	// Sentence terminating punctuations
#define WB_ANSI_PUNCT		3	// Punctuation except sentence terminators
#define WB_ANSI_CONTROL     4
#define WB_ANSI_TEXT		5
#define WB_ANSI_SPACE		6
#define WB_NOT_ANSI         7

/*============================================================================
ecBreakANSI()
    Break ANSI into words, and add words to the WordLink
Returns:
    PRFEC error code
============================================================================*/
int	CWordBreak::ecBreakANSI(LPCWSTR pwchAnsi, USHORT cwchLen, USHORT& cwchBreaked)
{
    assert(pwchAnsi);
    assert(cwchLen);
    assert(pwchAnsi[0] >= _ANSI_LOW && pwchAnsi[0] <= _ANSI_HIGH ||
		   pwchAnsi[0] >= _WANSI_LOW && pwchAnsi[0] <= _WANSI_HIGH );

	USHORT	wch, wchPrev = 0;
	USHORT	wState;
	USHORT	wChar;
    BOOL    fFullWidth;
	BYTE	hich, loch;
	CWord   *pword;
    
	wState = wChar = WB_ANSI_NULL;
    fFullWidth = (BOOL)(HIBYTE(pwchAnsi[0]));

	for (wch = 0; wch < cwchLen && wState != WB_NOT_ANSI; wch++) {
        wState = wChar;
        if (wch == cwchLen ) {
            // end of the line
            wChar = WB_NOT_ANSI;            
        } 
        hich = HIBYTE(pwchAnsi[wch]);
        loch = LOBYTE(pwchAnsi[wch]);

        if (fFullWidth &&
			(pwchAnsi[wch] < _WANSI_LOW || pwchAnsi[wch] > _WANSI_HIGH) ||
            ! fFullWidth &&
			(pwchAnsi[wch] < _ANSI_LOW || pwchAnsi[wch] > _ANSI_HIGH)) { 
            //  Not ansi any more
            wChar = WB_NOT_ANSI;
        } else {
            if (hich == 0xFF) {
                loch += 0x20;
            }

            switch (loch) {

            case '0': case '1': case '2': case '3': case '4': 
            case '5': case '6': case '7': case '8': case '9':
            case '%':
                wChar = WB_ANSI_NUMBER;
                break;

            case '.':
                if (wState == WB_ANSI_NUMBER && wch < cwchLen-1 && 
                    (! fFullWidth &&
                     LOBYTE(pwchAnsi[wch+1]) >= '0' &&
                     LOBYTE(pwchAnsi[wch+1]) <= '9'    ) ||
                    (fFullWidth &&
                     LOBYTE(pwchAnsi[wch+1]) + 0x20 >= '0' &&
                     LOBYTE(pwchAnsi[wch+1]) + 0x20 <= '9'    )) {

                    wChar = WB_ANSI_NUMBER;
                } else {
                    wChar = WB_ANSI_SENTENCE;
                }
                break;
                
            case '!': case '?': case ';': case ':':
                wChar = WB_ANSI_SENTENCE;
                break;

            case '#': case '$' : case '&' : case '*': case '=':
            case '+': case '-' : case '/' : case '<': case '>':
            case ',': case '\"': case '\'': case '(': case ')':
            case '[': case ']' : case '{' : case '}': case '_':
            case '`': case '^' : case '@': case '|':
                wChar = WB_ANSI_PUNCT;
                break;

            case ' ':  // space 
                wChar = WB_ANSI_SPACE;
                break;

            default:
                wChar = WB_ANSI_TEXT;
                break;
                
            } // end of switch()
        }

		if (wChar != wState && wState != WB_ANSI_NULL) {
            if ((pword = m_pLink->pAllocWord()) == NULL) {
				return PRFEC::gecOOM;
            }
            pword->FillWord(pwchAnsi + wchPrev, wch - wchPrev);
            if (! fFullWidth) {
                pword->SetFlag(CWord::WF_SBCS);
            }
			switch (wState) {
            
            case WB_ANSI_NUMBER:
                if (fFullWidth) {
                    pword->SetAttri(LADef_numArabic);
                } else {
                    pword->SetAttri(LADef_numSBCS);
                }
                break;
            
            case WB_ANSI_SENTENCE:
                pword->SetAttri(LADef_punPunct);
                pword->SetAttri(LADef_punJu);
                break;
            
            case WB_ANSI_PUNCT:
                pword->SetAttri(LADef_punPunct);
                if (LOBYTE(pwchAnsi[wch]) == ',') {
                    pword->SetAttri(LADef_punJu);
                }
                break;

            case WB_ANSI_TEXT:
                if (fFullWidth) {
                    pword->SetAttri(LADef_genDBForeign);
                }
                break;

            case WB_ANSI_CONTROL:
            case WB_ANSI_SPACE:
                break;

            default:
                pword->SetAttri(LADef_posN);
                break;
            }

			m_pLink->AppendWord(pword);
            wchPrev = wch;
			wState = wChar;
        }
    } // end of for(wch...)

    assert(wch <= cwchLen);
    // Link the last word
    if (wch == cwchLen) {
        if ((pword = m_pLink->pAllocWord()) == NULL) {
            return PRFEC::gecOOM;
        }
        pword->FillWord(pwchAnsi + wchPrev, wch - wchPrev);
        if (! fFullWidth) {
            pword->SetFlag(CWord::WF_SBCS);
        }
        switch (wState) {
            
        case WB_ANSI_NUMBER:
            if (fFullWidth) {
                pword->SetAttri(LADef_numArabic);
            } else {
                pword->SetAttri(LADef_numSBCS);
            }
            break;
            
        case WB_ANSI_SENTENCE:
            pword->SetAttri(LADef_punPunct);
            pword->SetAttri(LADef_punJu);
            break;
            
        case WB_ANSI_PUNCT:
            pword->SetAttri(LADef_punPunct);
            if (LOBYTE(pwchAnsi[wch]) == ',') {
                pword->SetAttri(LADef_punJu);
            }
            break;
            
        case WB_ANSI_TEXT:
            if (fFullWidth) {
                pword->SetAttri(LADef_genDBForeign);
            }
            break;
            
        case WB_ANSI_CONTROL:
        case WB_ANSI_SPACE:
            break;
            
        default:
            pword->SetAttri(LADef_posN);
            break;
        }
        
        m_pLink->AppendWord(pword);
        cwchBreaked = wch;
    } else {
        cwchBreaked = wch - 1;
    }
	return PRFEC::gecNone;
}

/*============================================================================
ecBreakEuro()
    Break european chars into words, and add words to the WordLink
Returns:
    PRFEC error code
============================================================================*/
int	CWordBreak::ecBreakEuro(LPCWSTR pwchEuro, USHORT cwchLen, USHORT& cwchBreaked)
{
    assert(pwchEuro);
    assert(cwchLen);
    assert(pwchEuro[0] >= _EUROPEAN_LOW && pwchEuro[0] <= _EUROPEAN_HIGH);

	CWord*	pWord;
    USHORT  wch;

    for (wch = 0; wch <= cwchLen; wch++) {
        if (pwchEuro[wch] < _EUROPEAN_LOW || pwchEuro[wch] > _EUROPEAN_HIGH) {
            break;
        }
    }
    
    if ((pWord = m_pLink->pAllocWord()) == NULL) {
        return PRFEC::gecOOM;
    }
    pWord->FillWord(pwchEuro, wch);
    pWord->SetAttri(LADef_genDBForeign);
    m_pLink->AppendWord(pWord);
    cwchBreaked = wch;
	return PRFEC::gecNone;
}


#define AMBI_WDNUM_THRESHOLD    3
#define AMBI_FREQ_THRESHOLD1    50
/*============================================================================
CWordBreak::ecDoBreak():
    Break Chinese section into words, and add words to the WordLink
    Call ambiguity function to resolve ambiguities
Returns:
    PRFEC error code
============================================================================*/
int CWordBreak::ecDoBreak(void)
{
    int     iret;
    LPCWSTR pwchText;
    USHORT  cwchText;
    USHORT  iwchWord = 0;   // offset of current word from the head position of current section
    USHORT  ciAmbi;     // count of Ambi words
    USHORT  cwMatch;
	CWord*  pword;

    cwchText = m_pLink->cwchGetLength();
    pwchText = m_pLink->pwchGetText();
    while (iwchWord < cwchText)  {
        // Handle surrogates
        if (iwchWord + 1 < cwchText && IsSurrogateChar(pwchText+iwchWord)) {

            cwMatch = 2;
            while (iwchWord + cwMatch + 1 < cwchText &&
                   IsSurrogateChar(pwchText+iwchWord + cwMatch)) {
                cwMatch += 2;
            }
            if ((pword = m_pLink->pAllocWord()) == NULL) {
                return PRFEC::gecOOM;
            }
            pword->FillWord(pwchText + iwchWord, cwMatch);
            //  pword->SetAttri(LADef_genDBForeign);
            m_pLink->AppendWord(pword);
            iwchWord += cwMatch;
            continue;
        } else if (pwchText[iwchWord] >= _ANSI_LOW && pwchText[iwchWord] <= _ANSI_HIGH ||
			       pwchText[iwchWord] >= _WANSI_LOW && pwchText[iwchWord] <= _WANSI_HIGH ) {
            // ANSI or Full size ANSI break
            iret = ecBreakANSI(pwchText+iwchWord, cwchText - iwchWord, cwMatch);
            if ( iret != PRFEC::gecNone ) {
                return iret;
            }
            iwchWord += cwMatch;
            continue;
        } else if (pwchText[iwchWord] <= _EUROPEAN_HIGH &&
                   pwchText[iwchWord] >= _EUROPEAN_LOW) {
            // European text break
            iret = ecBreakEuro(pwchText+iwchWord, cwchText - iwchWord, cwMatch);
            if ( iret != PRFEC::gecNone ) {
                return iret;
            }
            iwchWord += cwMatch;
            continue;
        } else {
        }
        ciAmbi = 1;
        cwMatch = m_pLexicon->cwchMaxMatch( pwchText + iwchWord, 
                                            cwchText - iwchWord, m_pwinfo);
        if ((m_rgAmbi[0] = m_pLink->pAllocWord()) == NULL) {
            return PRFEC::gecOOM;
        }
        m_rgAmbi[0]->FillWord(pwchText + iwchWord, cwMatch, m_pwinfo);
        iwchWord += cwMatch;
        if (cwMatch == 1) {
            m_pLink->AppendWord(m_rgAmbi[0]);
            m_rgAmbi[0] = NULL;
            continue;
        }

        // Detect ambiguity
        if ( !fNoAmbiWord(m_rgAmbi[0]) ) {
            while ((cwMatch > 1) && 
                   cwMatch <= AMBI_WDNUM_THRESHOLD &&
                   ciAmbi < MAX_AMBI_WORDS && iwchWord < cwchText ) {

                cwMatch = m_pLexicon->cwchMaxMatch(pwchText + iwchWord - 1,
                                         cwchText - iwchWord + 1, m_pwinfo);
                if (cwMatch > 1) { 
                    // Ambiguous found!
                    if (! (m_rgAmbi[ciAmbi] = m_pLink->pAllocWord()) ) {
                        break;  // we can not return with some unlinked word nodes in m_rgAmbi
                    }
                    m_rgAmbi[ciAmbi]->FillWord( pwchText + iwchWord - 1, 
                                                cwMatch, m_pwinfo);
                    iwchWord += cwMatch - 1;
                    ciAmbi++;
                }
            } // while(iwchWord < cwchText && ciAmbi < MAX_AMBI_WORDS)
        
        } 

        if (ciAmbi > 1) { // Resolve ambiguities
                iret = ecResolveAmbi(ciAmbi);
                for (int i = 0; i < ciAmbi; i++) { 
                    if(m_rgAmbi[i] != NULL) { 
                        m_pLink->FreeWord(m_rgAmbi[i]);
                        m_rgAmbi[i] = NULL;
                    }
                }
                 // assert don't over boundary
                assert(ciAmbi == MAX_AMBI_WORDS || m_rgAmbi[ciAmbi] == NULL);
                if (iret != PRFEC::gecNone) {
                    return iret;
                }
        } else {
            // No ambiguities
            m_pLink->AppendWord(m_rgAmbi[0]);
            m_rgAmbi[0] = NULL;
        }
    } // end of sentence word link loop for(iwchWord = 0; iwchWord < cwchText; )

    assert(iwchWord <= cwchText);

    return PRFEC::gecNone;
}
        
/*============================================================================
CWordBreak::ecResolveAmbi():
    Single char cross ambiguity resolution function
    Ambiguious word pointers stored in m_rgAmbi, m_pLink is the owner of these words
Returns:
    PRFEC error code
Remarks:
    Elements of m_rgAmbi contain word pointer which have been add the the WordLink
    will be set to NULL, the other word nodes should be freed by the caller
    The whole ambiguious string must be processed by this function
    Two words ambiguous, unigram threshold to become single char word, unigram of 0xB3A4()
============================================================================*/
int CWordBreak::ecResolveAmbi(USHORT ciAmbi)
{
    CWordInfo   winfo;
    UCHAR       freq1, freq2, freq3;
    UCHAR       nResolved;
    USHORT      cwMatch, iwch, cwch;
    LPWSTR      pwch;

    assert(MAX_AMBI_WORDS < 255); // make sure nResolved will not overflow

    switch (ciAmbi) {
        case 2:
            if ((m_rgAmbi[0]->cwchLen()== 2) && (m_rgAmbi[1]->cwchLen()== 2)){
                // AB BC
                if (!m_pLexicon->fGetCharInfo(*(m_rgAmbi[1]->pwchGetText()+1),
                                              m_pwinfo)) {
                    return PRFEC::gecUnknown;
                }
                if ( !m_rgAmbi[0]->fGetAttri(LADef_pnQian) || // ""
                     !m_pwinfo->fGetAttri(LADef_pnXing) &&    // ""
                     !m_pwinfo->fGetAttri(LADef_pnWai) ) {    // ""
                    if (m_pFreq->uchGetFreq(*(m_rgAmbi[0]->pwchGetText())) >
                        m_pFreq->uchGetFreq(*(m_rgAmbi[1]->pwchGetText()+1)) ) {
                        // if Freq(A) > Freq(C) then A/BC
                        // BUG: don't use m_pwinfo here, it keep the wordinfo of C!
                        // if(!m_pLexicon->fGetCharInfo(m_pLink->pchGetText() + m_rgAmbi[0].m_pWord->m_ichStart, m_pwinfo)) {
                        if (!m_pLexicon->fGetCharInfo(
                                            *(m_rgAmbi[0]->pwchGetText()),
                                            &winfo)) {
                            assert(0);
                            return PRFEC::gecUnknown;
                        }
                        if (!fLinkNewAmbiWord(m_rgAmbi[0]->pwchGetText(),
                                              1, &winfo)){
                            return PRFEC::gecOOM;
                        }
                        LinkAmbiWord(1);
                        return PRFEC::gecNone;
                    }
                }
                // if Freq(A) <= Freq(B) .or. ("" + "") .or. ("" + "") then AB/C
                LinkAmbiWord(0);
                if (!fLinkNewAmbiWord(m_rgAmbi[1]->pwchGetText()+1,
                                      1, m_pwinfo)) {
                    return PRFEC::gecOOM;
                }
                return PRFEC::gecNone;
            }
            
            // case 2:
            if ((m_rgAmbi[0]->cwchLen()== 2) && (m_rgAmbi[1]->cwchLen() > 2)) {
                // AB BCD
                if (m_pFreq->uchGetFreq(*(m_rgAmbi[0]->pwchGetText()))
                             <= AMBI_FREQ_THRESHOLD1) {
                    if (m_pLexicon->cwchMaxMatch(m_rgAmbi[1]->pwchGetText()+1,
                                                 m_rgAmbi[1]->cwchLen()-1, 
                                                 m_pwinfo) 
                                    == (m_rgAmbi[1]->cwchLen() - 1)) {
                        // if Freq(A) <= Threshold1 .and. IsWord(CD) then AB/CD
                        LinkAmbiWord(0);
                        if (!fLinkNewAmbiWord(m_rgAmbi[1]->pwchGetText() + 1,
                                              m_rgAmbi[1]->cwchLen() - 1,
                                              m_pwinfo) ) {
                            return PRFEC::gecOOM;
                        }
                        return PRFEC::gecNone;
                    }
                }
                // if Freq(A) > Threshold1 .or. !IsWord(CD) then A/BCD
                if (!m_pLexicon->fGetCharInfo(*(m_rgAmbi[0]->pwchGetText()),
                                              m_pwinfo)) {
                        return PRFEC::gecUnknown;
                }
                if (!fLinkNewAmbiWord(m_rgAmbi[0]->pwchGetText(),1, m_pwinfo)){
                    return PRFEC::gecOOM;
                }
                LinkAmbiWord(1);
                return PRFEC::gecNone;
            }

            // case: 2
            if ((m_rgAmbi[0]->cwchLen() > 2) && (m_rgAmbi[1]->cwchLen() == 2)) {
                // ABC CD
                if (!m_pLexicon->fGetCharInfo(*(m_rgAmbi[1]->pwchGetText() + 1),
                                              m_pwinfo)) {
                    return PRFEC::gecUnknown;
                }
                if ((m_pFreq->uchGetFreq(*(m_rgAmbi[1]->pwchGetText() + 1))
                              <= AMBI_FREQ_THRESHOLD1) &&
                    (!m_rgAmbi[0]->fGetAttri(LADef_pnQian) ||  // ""
                     !m_pwinfo->fGetAttri(LADef_pnXing) &&         // ""
                     !m_pwinfo->fGetAttri(LADef_pnWai)) ) {        // ""
                    // if Freq(D) <= Threshold1 .and. ( !("" + "") .and. !("" + "") ) then...
                    // BUG: don't use m_pwinfo here, it keep the wordinfo of C!
                    if (m_pLexicon->cwchMaxMatch(m_rgAmbi[0]->pwchGetText(),
                                                 m_rgAmbi[0]->cwchLen() - 1,
                                                 &winfo)
                                    == (m_rgAmbi[0]->cwchLen()-1)) {
                        // if IsWord(AB) then AB/CD
                        if (!fLinkNewAmbiWord(m_rgAmbi[0]->pwchGetText(),
                                              m_rgAmbi[0]->cwchLen() - 1,
                                              &winfo)) {
                            return PRFEC::gecOOM;
                        }
                        LinkAmbiWord(1);
                        return PRFEC::gecNone;
                    }
                }
                // if Freq(D) > Threshold1 or ( ("" + "") .or. ("" + "") ) or !IsWord(AB) 
                // then ABC/D
                LinkAmbiWord(0);
                if (!fLinkNewAmbiWord(m_rgAmbi[1]->pwchGetText() + 1, 
                                      1, m_pwinfo)) {
                    return PRFEC::gecOOM;
                }
                return PRFEC::gecNone;
            }
                
            // case 2:
            if ((m_rgAmbi[0]->cwchLen() > 2) && (m_rgAmbi[1]->cwchLen() > 2)) {
                // ABC CDE
                if (m_pLexicon->cwchMaxMatch(m_rgAmbi[0]->pwchGetText(),
                                             m_rgAmbi[0]->cwchLen() - 1,
                                             m_pwinfo) 
                                == (m_rgAmbi[0]->cwchLen() - 1)) {
                    // if IsWord(AB) then AB/CDE
                    if (!fLinkNewAmbiWord(m_rgAmbi[0]->pwchGetText(),
                                          m_rgAmbi[0]->cwchLen() - 1,
                                          m_pwinfo)) {
                        return PRFEC::gecOOM;
                    }
                    LinkAmbiWord(1);
                    return PRFEC::gecNone;
                }
                // if !IsWord(AB) then ABC/D...E    (re-break D...E string)
                LinkAmbiWord(0);
                pwch = m_rgAmbi[1]->pwchGetText() + 1;
                cwch = m_rgAmbi[1]->cwchLen() - 1;
                iwch = 0;
                while (iwch < cwch) {
                    cwMatch = m_pLexicon->cwchMaxMatch(pwch + iwch,
                                                       cwch - iwch, m_pwinfo);
                    assert(cwMatch);
                    if (!fLinkNewAmbiWord(pwch + iwch, cwMatch, m_pwinfo)) {
                        return PRFEC::gecOOM;
                    }
                    iwch += cwMatch;
                }
                return PRFEC::gecNone;
            }

            // case 2:
            assert(0);  // Never run to here!
            break;

        case 3:
            if (m_rgAmbi[1]->cwchLen() == 2) {
                // A.C CD D.E
                if ((m_rgAmbi[0]->cwchLen()==3) && (m_rgAmbi[2]->cwchLen()==2)){
                    // ABC CD DE
                    cwMatch =m_pLexicon->cwchMaxMatch(m_rgAmbi[0]->pwchGetText(),
                                                      m_rgAmbi[0]->cwchLen()-1,
                                                      m_pwinfo);
                    if( (cwMatch == m_rgAmbi[0]->cwchLen()-1) &&
                        (m_pFreq->uchGetFreq(*(m_rgAmbi[1]->pwchGetText()))+2<
                         m_pFreq->uchGetFreq(*(m_rgAmbi[2]->pwchGetText()+1)))){
                        // if IsWord(AB) .and. (Freq(E)-Freq(C) > 2) then AB/CD/E
                        if (!fLinkNewAmbiWord(m_rgAmbi[0]->pwchGetText(), 
                                              cwMatch, m_pwinfo)) {
                            return PRFEC::gecOOM;
                        }
                        LinkAmbiWord(1);
                        if (!m_pLexicon->fGetCharInfo(
                                            *(m_rgAmbi[2]->pwchGetText()+1),
                                            m_pwinfo)) {
                            return PRFEC::gecUnknown;
                        }
                        if (!fLinkNewAmbiWord(m_rgAmbi[2]->pwchGetText()+1, 
                                              1, m_pwinfo)) {
                            return PRFEC::gecOOM;
                        }
                        return PRFEC::gecNone;
                    }
                } // end if(ABC CD DE) and only some special cases have been handled
                else if ((m_rgAmbi[0]->cwchLen() == 2) && 
                         (m_rgAmbi[2]->cwchLen() == 3)) {
                    // AB BC CDE
                    cwMatch = m_pLexicon->cwchMaxMatch(
                                              m_rgAmbi[2]->pwchGetText()+1,
                                              m_rgAmbi[2]->cwchLen()-1,
                                              m_pwinfo);
                    if( (cwMatch == m_rgAmbi[2]->cwchLen()-1) &&
                        ( m_pFreq->uchGetFreq(*(m_rgAmbi[0]->pwchGetText()))-2 >
                          m_pFreq->uchGetFreq(*(m_rgAmbi[2]->pwchGetText()))) ){
                        // if IsWord(DE) .and. (Freq(A)-Freq(C) > 2) then A/BC/DE
                        if (!m_pLexicon->fGetCharInfo(
                                            *(m_rgAmbi[0]->pwchGetText()),
                                            &winfo)) {
                            return PRFEC::gecUnknown;
                        }
                        if (!fLinkNewAmbiWord(m_rgAmbi[0]->pwchGetText(), 
                                              1, &winfo)) {
                            return PRFEC::gecOOM;
                        }
                        LinkAmbiWord(1);
                        if (!fLinkNewAmbiWord(m_rgAmbi[2]->pwchGetText()+1,
                                              cwMatch, m_pwinfo)) {
                            return PRFEC::gecOOM;
                        }
                        return PRFEC::gecNone;
                    }
                } // end of if(AB BC CDE) and only some special cases have been handled
                else {
                }
                // else
                // if (AB BC CD) or (A.B BC C.D) then A.B/C.D
                LinkAmbiWord(0);
                LinkAmbiWord(2);
                return PRFEC::gecNone;
            } // if(m_rgAmbi[1]->cwchLen() == 2)
            else {  // the middle word contain more then 2 characters
                    /*
                    *   I have no idea to handle these cases and get better 
                    *   accuracy than the recursive approach
                    */
                goto gotoRecursive;
            }
            break;

        case 4:
            if( (m_rgAmbi[0]->cwchLen()== 2) && (m_rgAmbi[1]->cwchLen()== 2) &&
                (m_rgAmbi[2]->cwchLen()== 2) && (m_rgAmbi[3]->cwchLen()== 2)) {
                // AB BC CD DE
                // This is the most common case in terms of statistical result
                // if we get the MAX[Freq(A), Freq(C), Freq(E)], then everything are easy
                freq1 = m_pFreq->uchGetFreq(*(m_rgAmbi[0]->pwchGetText()));
                freq2 = m_pFreq->uchGetFreq(*(m_rgAmbi[2]->pwchGetText()));
                freq3 = m_pFreq->uchGetFreq(*(m_rgAmbi[3]->pwchGetText() + 1));

                if ( (freq1 > freq2) && (freq1 >= freq3) ) {
                    //    A/BC/DE
                    if (!m_pLexicon->fGetCharInfo(*(m_rgAmbi[0]->pwchGetText()),
                                                  m_pwinfo)) {
                        return PRFEC::gecUnknown;
                    }
                    if (!fLinkNewAmbiWord(m_rgAmbi[0]->pwchGetText(), 
                                          1, m_pwinfo)) {
                        return PRFEC::gecOOM;
                    }
                    LinkAmbiWord(1);
                    LinkAmbiWord(3);
                    return PRFEC::gecNone;
                } else if( (freq2 >= freq1) && (freq2 > freq3) ) {
                    //    AB/C/DE
                    LinkAmbiWord(0);
                    if (!m_pLexicon->fGetCharInfo(*(m_rgAmbi[2]->pwchGetText()),
                                                  m_pwinfo)) {
                        return PRFEC::gecUnknown;
                    }
                    if (!fLinkNewAmbiWord(m_rgAmbi[2]->pwchGetText(), 
                                          1, m_pwinfo)) {
                        return PRFEC::gecOOM;
                    }
                    LinkAmbiWord(3);
                    return PRFEC::gecNone;
                } else {
                    // if(freq3 >= freq2 && freq3 >= freq1)
                    //    AB/CD/E
                    LinkAmbiWord(0);
                    LinkAmbiWord(2);
                    if (!m_pLexicon->fGetCharInfo(*(m_rgAmbi[3]->pwchGetText()+1),
                                                  m_pwinfo)) {
                        return PRFEC::gecUnknown;
                    }
                    if (!fLinkNewAmbiWord(m_rgAmbi[3]->pwchGetText() + 1, 
                                          1, m_pwinfo)) {
                        return PRFEC::gecOOM;
                    }
                    return PRFEC::gecNone;
                }
            } // end of if(AB BC CD DE)
            else {
                /*
                *   There are too many cases in 4 words nested ambiguities
                *   I have to left all other cases to be resolved in recursive approach
                */
                goto gotoRecursive;
            }

        case 5:
            // I just handle the easy but most common case directly here
            if ((m_rgAmbi[1]->cwchLen()== 2) && (m_rgAmbi[3]->cwchLen()== 2)){
                LinkAmbiWord(0);
                LinkAmbiWord(2);
                LinkAmbiWord(4);
                return PRFEC::gecNone;
            } else {
                /*
                *   I have to left all other cases for recursive approach
                */
                goto gotoRecursive;
            }
            break;

        default:
gotoRecursive:
            /*
            *   I left all other cases to fall in here, and handle them using the 
            *   recursive approach. The depth of the recursive stack are controlled
            *   by the MAX_AMBI_WORDS. Thanks god, it take only 12 bytes stack overhead
            *   in each recursive call.
            *   In terms of recursive ambiguity resolving, I just handle the first word
            *   in the ambi string, and reset the array of m_rgAmbi[] to call this function
            *   recursively, till all words in the string have been processed
            *   It's quit dangous to free the word node and move the elements in m_rgAmbi[],
            *   please be careful if you touch m_rgAmbi[] or make any assumption on it, 
            *   when you do some change on this piece of code some day.
            *   I have no better idea to avoid spreading these tricky things more than 
            *   one place until now <donhz 5/31>
            */
            assert(ciAmbi > 2); // I have process all cases when ciAmbi == 2
            if (m_rgAmbi[1]->cwchLen()== 2 ) {
                // just split the 2nd word and then free it
                assert(ciAmbi > 3); // A.B BC C.D has been processed in ciAmbi == 3
                LinkAmbiWord(0);
                // I employ nResolved to keep the number of words have been resolved,
                // and it will used to reset the m_rgAmbi[] and ciAmbi for next
                // recursive call. 
                nResolved = 2; 
            } else {
                // if(m_rgAmbi[1]->cwchLen() > 2)
                // there are more complicated cases here
                if (m_rgAmbi[0]->cwchLen()== 2 ) {
                    // AB BC.D ...
                    cwMatch = m_pLexicon->cwchMaxMatch(
                                            m_rgAmbi[1]->pwchGetText() + 1,
                                            m_rgAmbi[1]->cwchLen() - 1,
                                            m_pwinfo);
                    if (cwMatch == m_rgAmbi[1]->cwchLen() - 1) {
                        // if IsWord(C.D) then AB/C.D...
                        LinkAmbiWord(0);
                        m_rgAmbi[1]->ClearWord();
                        m_rgAmbi[1]->FillWord(m_rgAmbi[1]->pwchGetText() + 1, 
                                              cwMatch, m_pwinfo);
                        nResolved = 1;
                    } else { 
                        // if !IsWord(C.D) then let A alone
                        if (!m_pLexicon->fGetCharInfo(*(m_rgAmbi[0]->pwchGetText()),
                                                      m_pwinfo)){
                            // I have not do any thing until now, so return and don't worry
                            return PRFEC::gecUnknown;   
                        }
                        if (!fLinkNewAmbiWord(m_rgAmbi[0]->pwchGetText(),
                                              1, m_pwinfo)) {
                            return PRFEC::gecOOM;
                        }
                        nResolved = 1;
                    }
                } else {
                    // if (m_rgAmbi[0]->cwchLen() > 2 )
                    // A.BC CD.E ...
                    if ( (m_rgAmbi[0]->cwchLen() == 3)  &&
                         ( m_pLexicon->cwchMaxMatch(m_rgAmbi[0]->pwchGetText(),
                                                    m_rgAmbi[0]->cwchLen() - 1,
                                                    m_pwinfo)
                                       == (m_rgAmbi[0]->cwchLen() - 1) ) ) {
                        // if (ABC CD.E ...) .and. IsWord(AB) then A.B/CD.E...
                        if (!fLinkNewAmbiWord(m_rgAmbi[0]->pwchGetText(),
                                              m_rgAmbi[0]->cwchLen() - 1,
                                              m_pwinfo)){
                            return PRFEC::gecOOM;
                        }
                        nResolved = 1;
                    }
                    else if( (cwMatch = m_pLexicon->cwchMaxMatch(
                                                m_rgAmbi[1]->pwchGetText()+1,
                                                m_rgAmbi[1]->cwchLen() - 1,
                                                m_pwinfo)) 
                             == (m_rgAmbi[1]->cwchLen() - 1) ) {
                        // if IsWord(D.E) then A.BC/D.E...
                        // Not too bad!
                        LinkAmbiWord(0);
                        m_rgAmbi[1]->ClearWord();
                        m_rgAmbi[1]->FillWord(m_rgAmbi[1]->pwchGetText() + 1, 
                                              cwMatch, m_pwinfo);
                        nResolved = 1;
                    }
                    else {// if ( (ABC CD.E ...) .and. !IsWord(AB) .and. !IsWord(D.E) ) .or.
                          //    ( (AB.C CD.E ...) .and. !IsWord(D.E) ) 
                          // then AB.C/D/././EF...       (Re-break string before E)
                        LinkAmbiWord(0);
                        // Re-break section "D."
                        if (m_rgAmbi[1]->cwchLen() == 3) {
                            // the only case indeed, if we stop ambiguity detection at >=4 char words
                            if (!m_pLexicon->fGetCharInfo(
                                                *(m_rgAmbi[1]->pwchGetText()+1),
                                                m_pwinfo)) {
                                return PRFEC::gecUnknown;
                            }
                            if (!fLinkNewAmbiWord(m_rgAmbi[1]->pwchGetText()+1,
                                                  1, m_pwinfo)) {
                                return PRFEC::gecOOM;
                            }
                        } else {
                            // if(m_rgAmbi[1]->cwchLen() > 3)
                            // re-break "D." in a word breaking loop
                            assert(m_rgAmbi[1]->cwchLen() > 6);
                            pwch = m_rgAmbi[1]->pwchGetText() + 1;
                            cwch = m_rgAmbi[1]->cwchLen() - 2;
                            iwch = 0;
                            while (iwch < cwch) {
                                cwMatch = m_pLexicon->cwchMaxMatch(pwch + iwch,
                                                                   cwch - iwch,
                                                                   m_pwinfo);
                                assert(cwMatch);
                                if (!fLinkNewAmbiWord(pwch + iwch, 
                                                      cwMatch, m_pwinfo)) {
                                    return PRFEC::gecOOM;
                                }
                                iwch += cwMatch;
                            }
                        }
                        nResolved = 2;
                        if (ciAmbi == 3) {
                            // Don't leave a single word in m_rgAmbi[], 
                            // there are no abmiguities any more
                            LinkAmbiWord(2);
                            return PRFEC::gecNone; // Another way to exit!!!
                        }
                    }
                } // end of if (m_rgAmbi[0]->cwchLen() > 2 )
            } // end of if(m_rgAmbi[1]->cwchLen() > 2)

            /*
            *   All cases of 1st word have been handled.
            *   Now, it's time to reset m_rgAmbi[] and ciAmbi.
            */
            for (iwch = 0; iwch < nResolved; iwch++) {
                if (m_rgAmbi[iwch] != NULL) {
                    m_pLink->FreeWord(m_rgAmbi[iwch]); // free unlinked word node
                }
            }
            for (iwch = nResolved; iwch < ciAmbi; iwch++) {
                m_rgAmbi[iwch - nResolved] = m_rgAmbi[iwch];
            }
            for (iwch = ciAmbi - nResolved; iwch < ciAmbi; iwch++) {
                m_rgAmbi[iwch] = NULL;
            }
            ciAmbi -= nResolved;
            assert(ciAmbi >= 2);

            /*
            *   The last thing to do is calling myself recursively
            */
            return ecResolveAmbi(ciAmbi);

        } // end of main switch()

    assert(0); // It's impossible to get here
    return PRFEC::gecUnknown; 
}

#pragma optimize( "", on ) 
    
/*============================================================================
BOOL CWordBreak::fNoAmbiWord():
    Check whether the word can participate ambiguity detection
Returns:
    TRUE if it can not.
    FALSE for normal word
============================================================================*/
inline BOOL CWordBreak::fNoAmbiWord(CWord* pWord)
{
    assert(!pWord->fGetFlag(CWord::WF_SBCS));
    assert(pWord->cwchLen() > 1);
    return (BOOL)( // pWord->cwchLen() == 1 ||
                    pWord->fGetAttri(LADef_punPunct) || 
                    pWord->fGetAttri(LADef_genCuo) || 
                    pWord->fProperName()
                 );
}
    

/*============================================================================
CWordBreak::LinkAmbiWord():
    Link specific Ambi word in m_rgAmbi[], and mark it as WF_AMBI
============================================================================*/
inline void CWordBreak::LinkAmbiWord(
                            USHORT iAmbi)// index of Ambi word in m_rgAmbi[]
{
    assert(m_rgAmbi[iAmbi]);
    m_rgAmbi[iAmbi]->SetFlag(CWord::WF_WORDAMBI);
    m_pLink->AppendWord(m_rgAmbi[iAmbi]); 
    m_rgAmbi[iAmbi] = NULL;
}


/*============================================================================
CWordBreak::fLinkNewAmbiWord():
    Link a new work to the WordLink, and mark it as WF_AMBI
============================================================================*/
inline BOOL CWordBreak::fLinkNewAmbiWord(
                         LPCWSTR pwchWord, 
                         USHORT cwchLen, 
                         CWordInfo* pwinfo)
{
    CWord* pWord = m_pLink->pAllocWord();
    if (pWord != NULL) {
        pWord->FillWord( pwchWord, cwchLen, pwinfo );
        pWord->SetFlag(CWord::WF_WORDAMBI);
        m_pLink->AppendWord(pWord);
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\wordlink.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: Word and WordLink

Purpose:   Define the CWord and CWordLink classes
           Using CMyPlex to alloc and manage memory for word object in the link
Notes:     This module is a fundamental stuff for SCProof'98, 
           it does NOT depend on any other class.
Owner:     donghz@microsoft.com
Platform:  Win32
Revise:    First created by: donghz    5/26/97
============================================================================*/

#ifndef _WORDLINK_H_
#define _WORDLINK_H_

#include "LexProp.h"
#include "ErrorDef.h"
#include "assert.h"
// Forward declaration of classes and structures
struct CMyPlex;
struct CWordInfo;
// Define the type of error ID
typedef USHORT ERRID;
// define macro DWORDINDEX, which is used to count the DWORD's( the iAttriID's 
// bit representation is fall into this DWORD ) index in attributes array
#define DWORDINDEX( iAttriID )    ((iAttriID) >> 5)
// define macro BITMASK, which is uesd to Get/Set/Clear the iAttriID's 
// bit representation in the DWORD
#define BITMASK( iAttriID )      (1 << ((iAttriID) & 0x1F))
// Define the element count in the attribute array (count of DWORD)
#define WORD_ATTRI_SIZE     (DWORDINDEX(LADef_MaxID) + 1)

/*============================================================================
Class:   CWord
Perpose: Word node in the word link, 
         Declare CWordLink as a friend class, so that word link can access
         those link  pointers directly.
============================================================================*/
#pragma pack(1)     // align at WORD boundary
struct CWord
{
    friend class CWordLink;

    public:
        // constructor
        CWord();

    public:
        inline BOOL fGetFlag(DWORD dwFlag) const { return (BOOL)(m_dwFlag & dwFlag);}
        inline void SetFlag(DWORD dwFlag) { m_dwFlag |= dwFlag; }
        inline void ClearFlag(DWORD dwFlag) { m_dwFlag &= (~dwFlag); }
        inline void ClearAllFlag(void) { m_dwFlag = 0; }

        inline BOOL fGetAttri(USHORT iAttriID) const
        {
            assert (iAttriID <= LADef_MaxID);
            assert (DWORDINDEX(iAttriID) < WORD_ATTRI_SIZE);

            return iAttriID <= LADef_MaxID ? 
                (BOOL)(m_aAttri[DWORDINDEX(iAttriID)] & BITMASK( iAttriID ))
                : FALSE;
        }

        inline void SetAttri(USHORT iAttriID) 
        {
            assert (iAttriID <= LADef_MaxID);
            assert (DWORDINDEX(iAttriID) < WORD_ATTRI_SIZE);

            if (iAttriID <= LADef_MaxID) {
                m_aAttri[DWORDINDEX(iAttriID)] |= BITMASK( iAttriID );
            }
        }

        inline void ClearAttri(USHORT iAttriID) 
        {
            assert (iAttriID <= LADef_MaxID);
            assert (DWORDINDEX(iAttriID) < WORD_ATTRI_SIZE);

            if (iAttriID <= LADef_MaxID) {
                m_aAttri[DWORDINDEX(iAttriID)] &= ~BITMASK( iAttriID );
            }
        }

        inline void ClearAllAttri(void) 
        {
            ZeroMemory( (LPVOID)m_aAttri, sizeof(DWORD)*WORD_ATTRI_SIZE);
        }

        inline BOOL fProperName(void) const
        {
            return (BOOL)(  fGetAttri(LADef_nounPerson) || 
                            fGetAttri(LADef_nounPlace)  ||
                            fGetAttri(LADef_nounOrg)    || 
                            fGetAttri(LADef_nounTM)     || 
                            fGetAttri(LADef_nounTerm)
                         );
        }

        inline CWord* pPrevWord() const
        { 
            assert (m_pPrev == NULL || m_pPrev->m_pNext == this);
            return m_pPrev; 
        }

        inline CWord* pNextWord() const
        { 
            assert (m_pNext == NULL || m_pNext->m_pPrev == this);
            return m_pNext; 
        }

        /*============================================================================
        CWord::pChildWord()
        Get the Word's child word head.
        ============================================================================*/
        inline CWord* CWord::pChildWord() const
        {
#ifdef DEBUG
            if (fHasChild()) {
                CWord* pWord = m_pMergedFrom;
                USHORT cwchText=0;
                assert(pWord != NULL);
                assert(pWord->m_pPrev == NULL);
                while (pWord) {
                    assert(pWord->cwchLen() > 0);
                    assert(pWord->fGetFlag(CWord::WF_SBCS) ||
                        (pWord->cwchLen() == 1 && 
                        pWord->fGetFlag(CWord::WF_CHAR)) ||
                        (pWord->cwchLen() > 1 && 
                        !pWord->fGetFlag(CWord::WF_CHAR)) );
                    assert(pWord->m_pMergedTo == this );
                    assert(m_pwchText + cwchText == pWord->m_pwchText);
                    cwchText += pWord->m_cwchText;
                    pWord->pChildWord(); // do a recursion to child's child
                    pWord = pWord->pNextWord();
                }                
                assert(m_cwchText==cwchText);
            }
#endif // DEBUG
            return m_pMergedFrom;
        }

        inline BOOL fIsHead() const { return (BOOL)(m_pPrev == NULL); }
        inline BOOL fIsTail() const { return (BOOL)(m_pNext == NULL); }
        inline BOOL fHasChild() const { return (BOOL)(m_pMergedFrom != NULL); }
        inline LPWSTR pwchGetText(void) { return m_pwchText; }
        inline USHORT cwchLen() const { return (USHORT)(m_cwchText); }
        inline DWORD dwGetWordID(void) { return m_dwWordID; }
        inline void  SetWordID(DWORD dwID) { m_dwWordID = dwID; }
        inline DWORD GetLexHandle(void) { return m_hLex; }
        inline void  SetLexHandle(DWORD hLex) { m_hLex = hLex; }
        inline ERRID GetErrID(void)  { return m_idErr; }
        inline void  SetErrID( ERRID dwErr ) { m_idErr = dwErr; }

        // Clear data members of the given word node
        inline void ClearWord(void) 
        {
            m_dwWordID = 0;
            m_hLex = 0;
            m_dwFlag = 0;
            ZeroMemory( (LPVOID)m_aAttri, sizeof(DWORD)*WORD_ATTRI_SIZE);
            m_idErr = 0;
        }
        // Copy the pWord to this word
        inline void CopyWord(CWord* pWord)
        {
            assert (pWord);
            memcpy((void*)this, (void*)pWord, sizeof(CWord));
        }
        void FillWord( LPCWSTR pwchText, USHORT cwchText,
                              CWordInfo* pwinfo = NULL );

        // Check whether current word is a Chinese Hanzi word
        // Exclude: 1. SBCS word node.
        //          2. Punctuation node.
        //          3. DBCS Foreign char (include symbols) node
        inline BOOL fIsHanzi(void) const
        {
            if(fGetAttri(LADef_punPunct) || fGetFlag(WF_SBCS) 
#ifdef LADef_genDBForeign
                || fGetAttri(LADef_genDBForeign)
#endif
                )  {
                return FALSE;
            }
            return TRUE;
        }

        //  Compare word with a Chinese character, if match return TRUE, or return FALSE
        inline BOOL fIsWordChar(const WCHAR wChar) const {
            assert (m_pwchText);
            assert (m_cwchText);

            if (m_cwchText == 1 && m_pwchText != NULL && *m_pwchText ==wChar) {
                return TRUE;
            }
            return FALSE;
        }
        
        //  Compare the first char of the word with a Chinese character, 
        //  if match return TRUE, or return FALSE
        inline BOOL fIsWordFirstChar(const WCHAR wChar) const {
            assert (m_pwchText);
            assert (m_cwchText);

            if (m_cwchText >= 1 && m_pwchText != NULL && *m_pwchText ==wChar) {
                return TRUE;
            }
            return FALSE;
        }

        //  Compare the last char of the word with a Chinese character, 
        //  if match return TRUE, or return FALSE
        inline BOOL fIsWordLastChar(const WCHAR wChar) const {
            assert (m_pwchText);
            assert (m_cwchText);

            if (m_cwchText >= 1 && m_pwchText != NULL 
                && *(m_pwchText+m_cwchText - 1) == wChar) {
                return TRUE;
            }
            return FALSE;
        }


        //  Compare this word's text with given text, return TRUE if match, or return FALSE
        BOOL fIsWordText(LPCWSTR lpwcText) const;
        //  Compare this word with other word, if the text of them identical return TRUE, or return FALSE
        BOOL fIsTextIdentical(const CWord* pWord) const;

    private:
        DWORD   m_dwWordID;
        DWORD   m_hLex;     // lexicon handle to get feature
        DWORD   m_dwFlag;
        DWORD   m_aAttri[WORD_ATTRI_SIZE]; // attributes
        ERRID   m_idErr;
        USHORT  m_cwchText;  // word's text length
        WCHAR*  m_pwchText;  // pointer to the text in source buffer

        CWord*  m_pPrev;
        CWord*  m_pNext;
        CWord*  m_pMergedFrom;// pointer to the words which this word merged from
#ifdef  DEBUG
        CWord*  m_pMergedTo;  // pointer to the word which this word was merged to
#endif  // DEBUG

    public:
        enum WFLAG  // flag bit setting of m_dwFlag
        {
            WF_SBCS     = 0x1,      // SBCS WordNode
            WF_CHAR     = 0x2,      // DBCS single character word
            WF_WORDAMBI = 0x4,      // Mark the ambiguious word
            WF_POSAMBI  = 0x8,      // The word is binded by rules, not in the lexicon
            WF_LMFAULT  = 0x10,     // Can not pass LM checking
            WF_REDUCED  = 0x20,     // Word node merged by rules
            WF_QUOTE    = 0x40,     // Word node between any pair quote marks, 
                                    // exclude the quote marks!!
            WF_DEBUG    = 0x80000000    // Reserve this bit for debug usage
        };

#ifdef DEBUG
        inline CWord* pParentWord() const { return m_pMergedTo; }
        inline BOOL   fIsChild() const { return (BOOL)(m_pMergedTo!=NULL); }

        inline BOOL fIsNew(void) const
        {
            if(m_idErr == 0 && m_dwWordID == 0 && m_hLex == 0 && m_dwFlag == 0) {
                for(int i = 0; i < WORD_ATTRI_SIZE; i++) {
                    if(m_aAttri[i] != 0)
                        return FALSE;
                    }
                return TRUE;
            }
            return FALSE;
        }
#endif // DEBUG
};
#pragma pack()


/*============================================================================
Class:   CWordLink
Purpose: To manage the word link as a container, employ CMyPlex in the inplementation   
Usage:   The instance need be created only one time, memory will not be freed 
         until destuction. Call FreeLink after use, and call InitLink to set the 
         buffer pointer before use.
Note:    In order to get high performance, I left some runtime error checking in 
         the debugging code, so more testing on debug version is required
         This class run in best performance for both running time and space, 
         all links contain similar word number, like sentence or sub-sentence
============================================================================*/
class CWordLink
{
    public:
        enum { // Define the WordLink flags
            WLF_PARTIAL = 0x1,
        };

    public:
        CWordLink(UINT ciBlockWordCount = 40);
        ~CWordLink();

        //  Init word link set the text buffer pointer
        void InitLink(const WCHAR* pwchText, USHORT cwchLen, DWORD dwFormat = 0);

        //  Get text pointer
        inline LPCWSTR pwchGetText(void) { return m_pwchText; }
        //  Get length of the WordLink
        inline USHORT cwchGetLength(void) { return m_cwchLen; }
        //  Set the length of WordLink, when a sentence terminater found
        inline void SetLength(USHORT cwchLen) { m_cwchLen = cwchLen; }
        //  Get format identifier of current text of WordLink
        inline DWORD dwGetFormat(void) { return m_dwFormat; }

        //  Get the first CWord node in the WordLink
        CWord* pGetHead(void);
        CWord* pGetTail(void) {
            return m_pTail;
        }

        //  Get specific WordLink flag
        inline BOOL fGetFlag(DWORD dwFlag) { return (BOOL)(m_dwFlag | dwFlag); }
        //  Set WordLink flag
        inline void SetFlag(DWORD dwFlag) { m_dwFlag |= dwFlag; }
        //  Clear a specific WordLink flag
        inline void ClearFlag(DWORD dwFlag) { m_dwFlag &= (~dwFlag); }
        //  Clear all flags
        inline void ClearAllFlag(void) { m_dwFlag = 0; }
        
        //  Alloc a new word, but do not chain the word into the link. 
        //  All data members will be clear, and return NULL if OOM.
        CWord* pAllocWord(void);
        //  Append a word object into the link.
        void AppendWord(CWord* pWord);
        //  Free word to the free chain, pWord must out of current WordLink
        void FreeWord(CWord* pWord);
        //  Free the word link begin with CWord* (link words to the free chain)
        void FreeLink( CWord* pWord );
        
        //  Split the given word into two words, return pointer to the right word if success
        //  return NULL if failed. cchSplitAt must fall in DBCS boundary.
        //  Note: Don't try to split SBCS nodes!!!
        CWord* pSplitWord(CWord* pWord, USHORT cwchSplitAt);
        //  Merge pWord with its next word to a single word, and free its next word
        //  pWord should not be the last word in the sentence
        //  fFree: if TRUE, free the Words been merged. FALSE, chain the Word been
        //  merged as the new word's child
        void MergeWithNext(CWord* pWord, BOOL fFree = TRUE);

        //  Merge pWord and it's left ciWords words, and return pointer to the merged word
        //  ciWords: 0 - don't merge, 1 - merge one time, 2 - merge two time (contain 3 words)
        //  fFree: if TRUE, free the Words been merged. FALSE, chain the Word been
        //  merged as the new word's child
        CWord* pLeftMerge(CWord* pWord, UINT ciWords, BOOL fFree = TRUE);
        //  Merge pWord and it's right ciWords words, and return pointer to the merged word
        //  ciWords: 0 - don't merge, 1 - merge one time, 2 - merge two time (contain 3 words)
        //  fFree: if TRUE, free the Words been merged. FALSE, chain the Word been
        //  merged as the new word's child
        CWord* pRightMerge(CWord* pWord, UINT ciWords, BOOL fFree = TRUE);

    private:
        DWORD       m_dwFlag;
        DWORD       m_dwFormat;

        CWord*      m_pHead;
        CWord*      m_pTail;

        UINT        m_ciBlockSize;  // number of words in each block
        CMyPlex*    m_pWordPool;
        CWord*      m_pFree;

        LPCWSTR     m_pwchText;      // buffer length validation need be taken by caller
        USHORT      m_cwchLen;

    private:
        // Merge word nodes from pLeft to pRight
        // only called by pLeftMerge() and pRightMerge() and MergeWithNext()
        // to do the merge work
        CWord* pMerge(CWord* pLeft, CWord* pRight, BOOL fFree);

        //  Alloc a new word fro the free chain, expand the blocks if free chain empty
        CWord* pNewWord(void);
        
        //  Free word in the link and reset the link (only link words to the free chain)
        void FreeLink(void);

#ifdef  DEBUG
    private:
        //  Debugging function to check whether a word pointer is in the link
        BOOL fInLink(CWord* pWord);
        // Debugging function to check whether a word pointer is in one of the 
        // child chains.
        inline BOOL CWordLink::fInChild(CWord* pWord);
        // Debugging function to check whether a word pointer is in the child chain 
        // of the pParent.
        BOOL fInChildOf(CWord* pWord, CWord* pParent);
        //  Debugging function to check whether the pWord is in CMyPlex blocks
        BOOL fInBlocks(CWord* pWord);
        //   Debugging function to check whether the pWord is in free links
        BOOL fInFree(CWord* pWord);
        //  Debugging function to check whether there are some word node leak to
        //  out of the link and the free chain
        //  Return TRUE if any leak is detected, or FALSE if no leak detected   
        //  Note: I hire thr most significant bit in CWord::m_dwFlag as the debugging use
        BOOL fDetectLeak(void);
        void SetDetectFlag(CWord* pWord);
#endif  // DEBUG

};

#endif  // _WORDLINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht\ctplus0.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1995, Microsoft Corporation.  All Rights Reserved.
//
//  File:       ctplus.h
//
//  Contents:   Local definitions for ctplus.c
//
//  History:    23-May-96   pathal      Created.
//
//---------------------------------------------------------------------------

#ifndef _CTPLUS_0_H_
#define _CTPLUS_0_H_

#define HC     0x01                             // Hiragana char
#define IC       0x02                             // Ideograph char
#define KC     0x03                             // Katakana char
#define WS     0x04                            // Word seperator
#define VC     0x05                             // Hankaku (variant) char
#define PS      0x06                            // Phrase seperator
#define CH      0x07                           // Code page 0 - ASCII Char.

BYTE
GetCharType(WCHAR wc );

// Declare character types transitions
// Intuitively frequency ordered
//
typedef enum _CT {
   CT_START = 0x00,
   CT_HIRAGANA = 0x01,
   CT_KANJI = 0x02,
   CT_KATAKANA = 0x03,
   CT_WORD_SEP = 0x04,
   CT_HANKAKU =0x05,
   CT_PHRASE_SEP = 0x06,
   CT_ROMAJI   = 0x07,
} CT;

#define CT_MAX    0x08

#endif // _CTPLUS_0_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht\exports.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994
//
//  File:       exports.cxx
//
//  Contents:   Code to export word breaker class factories
//
//  History:    01-July-1996     PatHal   Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "classid.hxx"
#include "wbclassf.hxx"
#include "stemcf.hxx"

long gulcInstances = 0;

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE
DllGetClassObject(
    REFCLSID   cid,
    REFIID     iid,
    void **    ppvObj )
{
    IUnknown *  pResult = 0;
    SCODE       sc      = S_OK;

    __try {

        switch ( cid.Data1 ) {

        // Japanese language wordbreaker
        //
        case 0xcd169790:
           if ( cid == CLSID_Japanese_Default_WBreaker ) {
             pResult = (IUnknown *) new CWordBreakerCF(
                MAKELCID( MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT),
                SORT_DEFAULT ));
             sc = pResult->QueryInterface( iid, ppvObj );

             pResult->Release(); // Release extra refcount from QueryInterface
           }
           else
              sc = E_NOINTERFACE;
           break;

        // Japanese language stemmer
        //
        case 0xcdbeae30:
           if ( cid == CLSID_Japanese_Default_Stemmer )
           {
             pResult = (IUnknown *) new CStemmerCF(
                MAKELCID( MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT),
                SORT_DEFAULT ));
             sc = pResult->QueryInterface( iid, ppvObj );

             pResult->Release(); // Release extra refcount from QueryInterface
           }
           else
              sc = E_NOINTERFACE;
           break;

        // Chinese Traditional language wordbreaker
        //
        case 0x954f1760:
           if ( cid == CLSID_Chinese_Traditional_WBreaker ) 
		   {
             pResult = (IUnknown *) new CWordBreakerCF(
                MAKELCID( MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL),
                SORT_DEFAULT ));
             sc = pResult->QueryInterface( iid, ppvObj );

             pResult->Release(); // Release extra refcount from QueryInterface
           }
           else
              sc = E_NOINTERFACE;
           break;

        // Chinese Traditional language stemmer
        //
        case 0x969927e0:
           if ( cid == CLSID_Chinese_Traditional_Stemmer )
           {
             pResult = (IUnknown *) new CStemmerCF(
                MAKELCID( MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL),
                SORT_DEFAULT ));
             sc = pResult->QueryInterface( iid, ppvObj );

             pResult->Release(); // Release extra refcount from QueryInterface
           }
           else
              sc = E_NOINTERFACE;
           break;

        // Chinese Traditional language wordbreaker
        //
        case 0x9717fc70:
           if ( cid == CLSID_Chinese_Simplified_WBreaker ) 
		   {
             pResult = (IUnknown *) new CWordBreakerCF(
                MAKELCID( MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED),
                SORT_DEFAULT ));
             sc = pResult->QueryInterface( iid, ppvObj );

             pResult->Release(); // Release extra refcount from QueryInterface
           }
           else
              sc = E_NOINTERFACE;
           break;

        // Chinese Traditional language stemmer
        //
        case 0x9768f960:
           if ( cid == CLSID_Chinese_Simplified_Stemmer )
           {
             pResult = (IUnknown *) new CStemmerCF(
                MAKELCID( MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED),
                SORT_DEFAULT ));
             sc = pResult->QueryInterface( iid, ppvObj );

             pResult->Release(); // Release extra refcount from QueryInterface
           }
           else
              sc = E_NOINTERFACE;
           break;

        default:
             sc = E_NOINTERFACE;
        }
    } __except(1) {

        if ( pResult )
            pResult->Release();

        sc = E_UNEXPECTED;
    }

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllCanUnloadNow( void )
{
    if ( gulcInstances <= 0 )
        return( S_OK );
    else
        return( S_FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht\log.c ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1994, Microsoft Corporation.  All Rights Reserved.
//
//  File:       Log.c
//
//  Contents:   Logging code.
//
//  History:    18-Dec-96   pathal     Created.
//
//---------------------------------------------------------------------------

#include "precomp.h"

#if defined(_DEBUG) || defined( TH_LOG)

VOID
ThLogWrite(
    HANDLE hLogFile,
    WCHAR *pwszLog)
{
    DWORD cbToWrite, cbWritten;
    PVOID pv;

    if (hLogFile != NULL) {
        pv = pwszLog;
        cbToWrite = lstrlen(pwszLog) * sizeof(WCHAR);

        if (!WriteFile( hLogFile, pv, cbToWrite, &cbWritten, NULL) ||
             (cbToWrite != cbWritten)) {
            wprintf(L"Error: WriteFile word failed with error %d.\r\n", GetLastError());
        }
    }
}


HANDLE
ThLogOpen(
    IN CONST CHAR *pszLogFile)
{
    HANDLE hLogFile;

    hLogFile = CreateFileA( pszLogFile, GENERIC_WRITE, 0, NULL,
             CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hLogFile!=INVALID_HANDLE_VALUE) {
        WCHAR wszUniBOM[3] = { 0xFEFF, 0, 0 };
        ThLogWrite( hLogFile, wszUniBOM );
    }

    return hLogFile;
}

VOID
ThLogClose(
    IN HANDLE hLogFile )
{
    if (hLogFile != NULL) {
        CloseHandle( hLogFile );
    }
}

#endif // defined(_DEBUG) || defined( TH_LOG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht\log.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.  All Rights Reserved.
//
//  File:       Log.h
//
//  History:    18-Dec-96   PatHal      Created.
//
//---------------------------------------------------------------------------

#if defined(_DEBUG) || defined(TH_LOG)

VOID ThLogWrite( HANDLE hLogFile, WCHAR *pwsz );
HANDLE ThLogOpen( CONST CHAR *pszLog );
VOID ThLogClose( HANDLE hLogFile );

#else

#define ThLogWrite( hLogFile, pwsz)
#define ThLogOpen( pwszLog )
#define ThDebugCloseLog( hLogFile )

#endif // defined(_DEBUG) || defined(TH_LOG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\wrdbreak.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Module:     WordBreak
Purpose:    Declare the CWordBreak class. This class is in Algorithm Layer.
            Perform the max-match word segmentation, and ambiguous resolution
            Both Chinese string and ANSI string will be broken into words
            WordBreaker also take sentence breaking function, and return the length
            processed through reference
Notes:      Both WordLink, Lexicon and CharFreq will be used
Owner:      donghz@microsoft.com
Platform:   Win32
Revise:     First created by: donghz    5/29/97
============================================================================*/
#ifndef _WRDBREAK_H_
#define _WRDBREAK_H_

#include "wordlink.h"
// Max count of nested ambiguous can be processed
#define MAX_AMBI_WORDS      20

// Foreward declarations
class   CLexicon;
class   CCharFreq;
class   CWordLink;
struct  CWord;
struct  CWordInfo;

/*============================================================================
Class:  CWordBreak:
Desc:   Declare the CWordBreak class
Prefix: 
============================================================================*/
class CWordBreak
{
    public:
        // Constructor
        CWordBreak();
        // Destructor
        ~CWordBreak();

        /*============================================================================
        *   fInit: initialize the WordBreaker and set the object handles
        *   It's valid to initialize the WordBreaker more than once!
        *   Return PRFEC
        ============================================================================*/
        int ecInit(CLexicon* pLexicon, CCharFreq* pFreq);

        /*============================================================================
        ecBreakSentence: break sentence into word and add the words to WordLink
        ============================================================================*/
        inline int CWordBreak::ecBreakSentence(CWordLink* pLink)   // WordLink to be broken
        {                       
            assert(pLink && m_pLexicon && m_pFreq);
            assert(pLink->pwchGetText() != NULL);
            assert(pLink->cwchGetLength() > 0);
            
            m_pLink = pLink;
            m_fSentence = FALSE;    // whether the input buffer contain a intact sentence
            return ecDoBreak();
        }
        
    private:
        CLexicon*   m_pLexicon;
        CCharFreq*  m_pFreq;

        CWordInfo*  m_pwinfo;
        CWordLink*  m_pLink;        // Contain pointer and length of the text buffer
        BOOL        m_fSentence;    // set TRUE if ant sentence terminator found
        CWord*      m_rgAmbi[MAX_AMBI_WORDS]; // store ambiguious words
                
    private:
        CWordBreak(CWordBreak&) { };

    private:


        //  Break ANSI into words, and add words to the WordLink
        int ecBreakANSI(LPCWSTR pwchAnsi, USHORT cwchLen, USHORT& cwchBreaked);

        //  Break European chars into words, and add words to the WordLink
        int ecBreakEuro(LPCWSTR pwchEuro, USHORT cwchLen, USHORT& cwchBreaked);

        //  Break Chinese section into words, and add words to the WordLink
        //  Call ambiguity function to resolve ambiguities
        int ecDoBreak();

        /*============================================================================
        *   Single char cross ambiguity resolution function
        *   Ambiguious word pointers stored in m_rgpWord, m_pLink is the owner of these words
        *   Elements of m_rgpWord contain word pointer which have been add the the WordLink
        *   will be set to NULL, the other word nodes should be freed by the caller
        *   This function return PRFEC error code, because it probably be interrupt by
        *   the user when running in background mode
        *   Note: the whole ambiguious string must be processed by this function
        ============================================================================*/
        int ecResolveAmbi(USHORT ciAmbi);

        /*============================================================================
        *   Check whether the word can participate ambiguity detection
        *   Return TRUE if it can not. and return FALSE for normal word
        ============================================================================*/
        BOOL fNoAmbiWord(CWord* pWord);

        /*============================================================================
        *   Link specific Ambi word in m_rgAmbi[]
        ============================================================================*/
        void LinkAmbiWord(USHORT iAmbi);    // index of Ambi word in m_rgAmbi[]

        /*============================================================================
        *   Link a new word to the WordLink, and mark it as WF_AMBI
        ============================================================================*/
        BOOL fLinkNewAmbiWord(LPCWSTR pwchWord, USHORT cwchLen, CWordInfo* pwinfo);
};

#endif  // _WBREAK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\wcstack.h ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: CWCStack
Purpose:    Define CWCStack class.
            CWCStack class is a simple stack for wide char.
Notes:      No cpp.
Platform:   Win32
Revise:     First created by: i-shdong    03/01/2000
============================================================================*/
#ifndef _WCSTACK_H_
#define _WCSTACK_H_

class CWCStack
{
    public:
        CWCStack() {
            m_lpwcStack = NULL;
            m_nTop = 0;
            m_nSize = 0;
        };

        ~CWCStack() {
            if (m_lpwcStack) {
                delete [] m_lpwcStack;
            }
        };

    public:
        // Init the stack, 
        // nSize: stack size
        // Return FALSE if can't allocate stack from memory.
        // Stack can be reinited, if so, the prev stack is destroyed and released
        BOOL Init(const UINT nSize = 16) {
            if (m_lpwcStack) {
                delete [] m_lpwcStack;
            }
            m_lpwcStack = new WCHAR[nSize];
            if (m_lpwcStack == NULL) {
                return FALSE;
            }
            m_nTop = 0;
            m_nSize = nSize;
            return TRUE;
        };

        // Destroy the stack
        void Destroy(void) {
            if (m_lpwcStack) {
                delete [] m_lpwcStack;
            }
            m_nTop = 0;
            m_nSize = 0;
        };


        // Pop the stack top to wch.
        // Return FALSE if stack empty.
        BOOL Pop(WCHAR & wch) {
            assert(m_lpwcStack);
            assert(m_nTop >= 0);
            if (m_nTop > 0) {
                -- m_nTop;
                wch = m_lpwcStack[m_nTop];
                return TRUE;
            } else {
                return FALSE;
            }
        }

        // Push wch to stack 
        // Return FALSE is stack is full.
        BOOL  Push(const WCHAR wch) {
            assert(m_lpwcStack);
            assert(m_nTop >= 0);
            if (m_nTop < m_nSize) {
                m_lpwcStack[m_nTop] = wch;
                m_nTop ++;
                return TRUE;
            } else {
                return FALSE;
            }
        };

        // Push wch to stack , increase stack if full.
        BOOL EPush(const WCHAR wch) {
            assert(m_lpwcStack);
            assert(m_nTop >= 0);
            if (m_nTop == m_nSize) {
                if (! Extend()) {
                    return FALSE;
                }
            }
            assert(m_nTop < m_nSize);
            m_lpwcStack[m_nTop] = wch;
            m_nTop ++;
            return TRUE;
        };

        // Empty the stack
        inline void Empty(void) {
            assert(m_lpwcStack);
            assert(m_nTop >= 0);
            m_nTop = 0;
        };

        // Return TRUE is stack is full
        inline BOOL IsFull(void) const {
            return (BOOL)(m_nTop == m_nSize);
        };

        // Return TRUE if stack is empty
        inline BOOL IsEmpty(void) const {
            return (BOOL)(m_nTop == 0);
        };

        // Extend stack more space
        // Return FALSE if no enough memory and the stack is unchanged.
        // Return TRUE if ok. 
        BOOL Extend(const UINT nExtend = 16) {
            assert(m_lpwcStack);
            assert(m_nTop >= 0);

            LPWSTR lpwcNew = new WCHAR[m_nSize + nExtend];

            if (lpwcNew == NULL) {
                return  FALSE;
            } else {
                wcsncpy(lpwcNew, m_lpwcStack, m_nTop);
                delete [] m_lpwcStack;
                m_lpwcStack = lpwcNew;
                m_nSize += nExtend;
                return  TRUE;
            }
        };

    private:
        LPWSTR  m_lpwcStack;
        UINT    m_nTop;
        UINT    m_nSize;

    private:
        //   Disabled operations.
        CWCStack(const CWCStack & Copy);
        void operator = (const CWCStack & Copy);

};

#endif // _WCSTACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    01-July-96       PatHal        Created
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <excpt.h>

#define UNICODE

// NT Private includes
#include "filter.h"
#include "query.h"
#include "cierror.h"
#include "assert.h"

extern "C"
{
#   include "thammer.h"
#   include "thammerp.h"
#   include "ctplus0.h"
#if defined(TH_LOG)
#   include "log.h"
#endif // TH_LOG
}

#undef Assert
#define Assert(a)

// Base services
//

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht\precomp.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1994, Microsoft Corporation.  All Rights Reserved.
//
//  File:       precomop.h
//
//  Contents:   Internal include file for Token Hammer.
//
//  History:    22-May-95       PatHal          Created
//
//---------------------------------------------------------------------------

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#define UNICODE
#include <windows.h>
#include <memory.h>
#include <malloc.h>
#include <string.h>
#include <wchar.h>
#include <excpt.h>

//#include "cierror.h"
#include  "ctplus0.h"
//#include  "filter.h"
#include  "log.h"
//#include  "query.h"
#include  "thammer.h"
#include  "thammerp.h"

#define unreference(x)  (x)

#endif //_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht\stemcf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       stemcf.cxx
//
//  Contents:   Stemmer class factory
//
//  History:    01-July-1996     PatHal   Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "stemcf.hxx"
#include "stemmer.hxx"

extern long gulcInstances;

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::CStemmerCF
//
//  Synopsis:   Stemmer class factory constructor
//
//--------------------------------------------------------------------------

CStemmerCF::CStemmerCF( LCID lcid )
        : _cRefs( 1 ), _lcid( lcid )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::~CStemmerCF
//
//  Synopsis:   Stemmer class factory destructor
//
//--------------------------------------------------------------------------

CStemmerCF::~CStemmerCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerCF::QueryInterface( REFIID riid,
                                                        void  ** ppvObject )
{
    //
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown      = 00000000-0000-0000-C000-000000000046
    // IID_IClassFactory = 00000001-0000-0000-C000-000000000046
    //                           --
    //                           |
    //                           +--- Unique!
    //

    Assert( (IID_IUnknown.Data1      & 0x000000FF) == 0x00 );
    Assert( (IID_IClassFactory.Data1 & 0x000000FF) == 0x01 );

    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 & 0x000000FF )
    {
    case 0x00:
        if ( riid == IID_IUnknown )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0x01:
        if ( riid == IID_IClassFactory )
            pUnkTemp = (IUnknown *)(IClassFactory *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;

    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CStemmerCF::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CStemmerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::CreateInstance
//
//  Synopsis:   Creates new CStemmer object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerCF::CreateInstance( IUnknown * pUnkOuter,
                                                    REFIID riid,
                                                    void  * * ppvObject )
{
    CStemmer *pIUnk = 0;
    SCODE sc = S_OK;

    __try
    {
        pIUnk = new CStemmer( _lcid );
        sc = pIUnk->QueryInterface(  riid , ppvObject );

        pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    __except(1)
    {
        Assert( 0 == pIUnk );

        sc = E_UNEXPECTED;
    }

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\chs2\src\wordlink.cpp ===
/*============================================================================
Microsoft Simplified Chinese Proofreading Engine

Microsoft Confidential.
Copyright 1997-1999 Microsoft Corporation. All Rights Reserved.

Component: Word and WordLink

Purpose:   Define the CWord and CWordLink classes
           Using CMyPlex to alloc and manage memory for word object in the link
Notes:     This module is a fundamental stuff for SCProof'98, 
           it does NOT depend on any other class.
Owner:     donghz@microsoft.com
Platform:  Win32
Revise:    First created by: donghz    5/26/97
============================================================================*/
#include "myafx.h"

#include "wordlink.h"
#include "myplex.h"
#include "lexicon.h"

/*============================================================================
Implementation of functions in CWord
============================================================================*/

/*============================================================================
CWord constructor
============================================================================*/
CWord::CWord( ) 
{
    m_dwWordID = 0;
    m_hLex = 0;
    m_dwFlag = 0;
    for (int i = 0; i < WORD_ATTRI_SIZE; i++)
        m_aAttri[i] = 0;
    m_idErr = 0;
    m_cwchText = 0;
    m_pwchText = NULL;
    m_pPrev = NULL;
    m_pNext = NULL;
    m_pMergedFrom = NULL;
#ifdef DEBUG
    m_pMergedTo = NULL;
#endif
}

/*============================================================================
CWord::FillWord():
    Fill the word.
============================================================================*/
void CWord::FillWord( LPCWSTR pwchText, USHORT cwchText, CWordInfo* pwinfo )
{
    assert(pwchText);
    assert(cwchText);

    m_pwchText = const_cast<LPWSTR>(pwchText);
    m_cwchText = cwchText;
    m_dwFlag = 0;
    ZeroMemory( (LPVOID)m_aAttri, sizeof(DWORD)*WORD_ATTRI_SIZE);
    m_idErr = 0;
    if (m_cwchText == 1) {
        SetFlag(CWord::WF_CHAR);
    }
    if (pwinfo != NULL) {
        m_dwWordID = pwinfo->GetWordID();
        m_hLex = pwinfo->GetLexHandle();
        for (USHORT i = 0; i < pwinfo->AttriNum(); i++) {
            SetAttri( pwinfo->GetAttri(i) );
        }
    } else {
        m_dwWordID = 0;
        m_hLex = 0;
    }
}

/*============================================================================
CWord::fIsWordText()
    Compare this word's text with given text.
Returns:
    TRUE if match
    FALSE if not
============================================================================*/
BOOL CWord::fIsWordText(LPCWSTR lpwcText) const
{
    assert(m_pwchText && m_cwchText);
    assert(lpwcText);
    if(m_cwchText != wcslen(lpwcText))
        return FALSE;
    for(USHORT i = 0; i < m_cwchText; i++) {
        if(lpwcText[i] != m_pwchText[i])
            return FALSE;
    }
    return TRUE;
}

/*============================================================================
CWord::fIsTextIdentical(const CWord*)
    Compare this word's text with other word's text
Returns:
    TRUE if the text of them identical
    FALSE if not
============================================================================*/
BOOL CWord::fIsTextIdentical(const CWord* pWord) const
{
    assert(m_pwchText);
    assert(m_cwchText);
    assert(pWord);
    assert(pWord->m_pwchText);
    if (m_pwchText == NULL || pWord->m_pwchText == NULL 
        || m_cwchText != pWord->m_cwchText) {
        return FALSE;
    }
    return (BOOL)(wcsncmp(m_pwchText, pWord->m_pwchText, m_cwchText) == 0);
}

/*============================================================================
Implementation of functions in CWordLink
============================================================================*/

/*============================================================================
CWordLink constructor
============================================================================*/
CWordLink::CWordLink(UINT ciBlockWordCount)
{
    // Assert: all blocks are in same size!
    m_dwFlag = 0;
    m_dwFormat = 0;
    m_ciBlockSize = ciBlockWordCount;

    m_pwchText  = NULL;
    m_pWordPool = NULL;
    m_pHead     = NULL;
    m_pTail     = NULL;
    m_pFree     = NULL;
}


/*============================================================================
CWordLink destructor
============================================================================*/
CWordLink::~CWordLink()
{
#ifdef DEBUG
    assert(!fDetectLeak()); // Assert: no memory leak detected
#endif
    if(m_pWordPool)
        m_pWordPool->FreeChain();
}

    
/*============================================================================
CWordLink::InitLink()
    Init word link, set the text buffer pointer and length.
Remarks:
    If there are words in the link, free the link at first
    dwFormat is a format hint info generate by WinWord, 
    it's a very important property of the sentence
============================================================================*/
void CWordLink::InitLink(const WCHAR* pwchText, USHORT cwchLen, DWORD dwFormat)
{
    FreeLink();
    m_dwFlag = 0;
    m_pwchText = pwchText;
    m_cwchLen = cwchLen;
    m_dwFormat = dwFormat;
}

    
/*============================================================================
CWord::pGetHead()
    Get the head Word node of the WordLink.
Remarks:
    In debug mode, do a all nodes verify one by one.
============================================================================*/
#ifdef DEBUG
CWord* CWordLink::pGetHead(void)
{ 
    // Verify each node before iterate the WordLink
    CWord* pWord = m_pHead;
    WCHAR* pwchText;
    USHORT cwchText=0;

    if (pWord != NULL) {
        pwchText = pWord->m_pwchText;
        // head node's m_pwchText must match this WordLink's m_pwchText !
        assert(pwchText == m_pwchText); 
    }
    while (pWord) {
        assert(pWord->cwchLen() > 0);
        assert(pWord->fGetFlag(CWord::WF_SBCS) ||
                (pWord->cwchLen() == 1 && pWord->fGetFlag(CWord::WF_CHAR)) ||
                (pWord->cwchLen() > 1 && !pWord->fGetFlag(CWord::WF_CHAR)) );
        assert(pwchText + cwchText == pWord->m_pwchText);
        cwchText += pWord->m_cwchText;
        pWord->pChildWord(); // do a recursion to childs
        pWord = pWord->pNextWord();
    }
    return (CWord*)m_pHead; 
}
#else
CWord* CWordLink::pGetHead(void) { return m_pHead; };
#endif // DEBUG


/*============================================================================
CWordLink::pAllocWord()
    Alloc a new word, but do not chain the word into the link.
    All public fields in the word object set to 0.
Returns:
    a CWord point to the new word.
    NULL if alloc failure.
============================================================================*/
CWord* CWordLink::pAllocWord(void)
{
    assert(m_pwchText); // Catch uninitialized call
    CWord*  pWord = pNewWord();
    if (pWord != NULL) {
        ZeroMemory( pWord, sizeof(CWord) );
/************
        pWord->ClearWord();
        pWord->m_pwchText = NULL;
        pWord->m_cwchText = 0;
        pWord->m_pNext = NULL;
        pWord->m_pPrev = NULL;
        pWord->m_pMergedFrom = NULL;
#ifdef DEBUG
        pWord->m_pMergedTo = NULL;
#endif // DEBUG
************/
    }
    return pWord;
}

/*============================================================================
CWordLink::AppendWord()
    Append a word object into the link.
============================================================================*/
void CWordLink::AppendWord(CWord* pWord)
{
#ifdef DEBUG
    assert(m_pwchText && m_cwchLen); // Catch uninitialized call
    // Word's text pointer must fall in WordLink's text buffer
    assert(pWord->m_pwchText >= m_pwchText && pWord->m_cwchText); 
    assert(pWord->m_pwchText + pWord->m_cwchText <= m_pwchText + m_cwchLen);
    assert(!fInLink(pWord));   // pWord must outof current link
    assert(!fInChild(pWord));  
    assert(fInBlocks(pWord));  // pWord must owned by current WordLink
    if (m_pTail) {
        // No zero-length word allowed
        assert(pWord->m_pwchText == m_pTail->m_pwchText + m_pTail->m_cwchText); 
    } else {
        assert(pWord->m_pwchText == m_pwchText);
    }
#endif // DEBUG

    pWord->m_pNext = NULL;
    if (!m_pHead) {
        assert(pWord->m_pwchText == m_pwchText);
        m_pHead = pWord;
    }   else {
        assert(pWord->m_pwchText > m_pwchText);
        m_pTail->m_pNext = pWord;
    }
    pWord->m_pPrev = m_pTail;
    m_pTail = pWord;
}


/*============================================================================
CWordLink::FreeWord()
    Free word to the free chain, pWord must out of current WordLink
============================================================================*/
void CWordLink::FreeWord(CWord* pWord)
{
    assert(pWord);
    assert(m_pwchText);          // Catch uninitialized call
#ifdef DEBUG
    assert(!fInLink(pWord));    // pWord should not in current link
    assert(!fInChild(pWord));   // must not in any of the child links
    assert(!fInFree(pWord));    // must not in free link
    assert(fInBlocks(pWord));   // pWord must owned by this WordLink instance
#endif // DEBUG
    // link the word to the free link
    pWord->m_pNext = m_pFree;
    m_pFree = pWord;
}

/*============================================================================
CWordLink::FreeLink(CWord*)
    Free the word link begin with CWord* (link words to the free chain)
============================================================================*/
void CWordLink::FreeLink( CWord* pWord )
{
    assert(pWord);
#ifdef DEBUG
    assert(fInBlocks(pWord));   // pWord must owned by this WordLink instance
    if (pWord != m_pHead) {
        if (m_pwchText) {
            assert(!fInLink(pWord));    // pWord should not in current link
            assert(!fInChild(pWord));  
        }
    }
#endif // DEBUG

    CWord* pNode = pWord;
    while (pNode->m_pNext) {
        if (pNode->m_pMergedFrom) {
            FreeLink(pNode->m_pMergedFrom);
        }
        pNode = pNode->m_pNext;
#ifdef DEBUG
        assert(!fInFree(pWord));
#endif // DEBUG
    }
    if (pNode->m_pMergedFrom) {
        FreeLink(pNode->m_pMergedFrom);
    }
    pNode->m_pNext = m_pFree;
    m_pFree = pWord;
}

/*============================================================================
CWordLink::pSplitWord()
    Split a proper word into two words and insert the new word into the link
Returns:
    Return the new word pointer if success, return NULL if failed to alloc new word
    or invalid cchSplitAt
Remarks:
    only Chinese word can be splitted
============================================================================*/
CWord* CWordLink::pSplitWord(CWord* pWord, USHORT cwchSplitAt)
{
    assert(m_pwchText); // Catch uninitialized call
    assert(pWord);
#ifdef DEBUG
    assert(fInLink(pWord)); // pWord must in current link
#endif // DEBUG
    assert(cwchSplitAt < pWord->m_cwchText);
    assert(!pWord->fGetFlag(CWord::WF_SBCS) && cwchSplitAt > 0);

    if (cwchSplitAt == 0 || cwchSplitAt >= pWord->m_cwchText) {
        return NULL;
    }

    if (pWord->m_pMergedFrom != NULL) {
        // free the child chains!
        CWord* pTemp = pWord->m_pMergedFrom;
        pWord->m_pMergedFrom = NULL;
        FreeLink(pTemp);
    }
    CWord*  pNew = pNewWord();
    if (pNew != NULL) {
        // link the new word into the WordLink
        pNew->m_pPrev = pWord;
        if (pWord->m_pNext == NULL) {
            m_pTail = pNew;
            pNew->m_pNext = NULL;
        } else {
            pWord->m_pNext->m_pPrev = pNew;
            pNew->m_pNext = pWord->m_pNext;
        }
        pWord->m_pNext = pNew;
        pNew->m_pMergedFrom = NULL;
#ifdef DEBUG
        pNew->m_pMergedTo = NULL;
#endif // DEBUG
        // Initialize the new word node
        pNew->ClearWord();
        pNew->m_pwchText = pWord->m_pwchText + cwchSplitAt;
        pNew->m_cwchText = pWord->m_cwchText - cwchSplitAt;
        if(pNew->m_cwchText == 1) {
            pNew->SetFlag(CWord::WF_CHAR);
        }
        // reset the original word node
        pWord->ClearWord();
        pWord->m_cwchText = cwchSplitAt;
        if(cwchSplitAt == 1) {
            pWord->SetFlag(CWord::WF_CHAR);
        }
    }
    return pWord;   
}

/*============================================================================
CWordLink::MergeWithNext()
    Merge pWord with its next word to a new single word, and chain the old two
    word as the new word's child word
Remarks:
    pWord should not be the last word in the sentence
============================================================================*/
void CWordLink::MergeWithNext(
                     CWord* pWord,
                     BOOL fFree) // TRUE: free the words been merged
                     // FALSE: chain the words been merged as new word's child
{
    assert(m_pwchText);
    assert(pWord);
#ifdef DEBUG
    assert(fInLink(pWord));
#endif // DEBUG 
    assert(pWord->m_pNext);  // catch the last word in the link

    pMerge(pWord, pWord->m_pNext, fFree);
}


/*============================================================================
CWordLink::pLeftMerge()
    Merge pWord and it's left ciWords words, the ciWords+1 words chained to 
    be the new merged word's childs.
Returns:
    pointer to the merged word.
    if there is not enough left word nodes, words are NOT merged
============================================================================*/
CWord* CWordLink::pLeftMerge(
          CWord* pWord, //  merge begin from pWord with left ciWords words
          UINT ciWords, //  0 - don't merge, 1 - merge one time(merge with prev)
                        //  2 - merge two time (contain 3 words)
          BOOL fFree) // TRUE: free the words been merged
                      // FALSE: chain the words been merged as new word's child
{
    assert(pWord);
#ifdef DEBUG
    assert(fInLink(pWord));
#endif 
    if (ciWords == 0) {
        return pWord;
    }
    assert(ciWords > 0);

    CWord* pLeft = pWord;
    CWord* pRight = pWord;
    for(UINT i = 0; i < ciWords; i++) {        
        if((pLeft = pLeft->m_pPrev) == NULL) { // Defensive way!
            assert(0);
            return pWord;
        }
    }
    return pMerge(pLeft, pRight, fFree);
}


/*============================================================================
CWordLink::pRightMerge()
    Merge pWord and it's right ciWords words, the ciWords+1 words chained to 
    be the new merged word's childs.
Returns:
    pointer to the merged word.
    NULL if there is not enough right word nodes, and words are NOT merged
============================================================================*/
CWord* CWordLink::pRightMerge(
          CWord* pWord, //  merge begin from pWord with right ciWords words
          UINT ciWords, //  0 - don't merge, 1 - merge one time(merge with next)
                        //  2 - merge two time (contain 3 words)
          BOOL fFree) // TRUE: free the words been merged
                      // FALSE: chain the words been merged as new word's child
{
    assert(pWord);
#ifdef DEBUG
    assert(fInLink(pWord));
#endif // DEBUG

    if (ciWords == 0) {
        return pWord;
    }
    assert(ciWords > 0);
    CWord* pLeft = pWord;
    CWord* pRight = pWord;
    for(UINT i = 0; i < ciWords; i++) {
        if ((pRight = pRight->m_pNext) == NULL) { // Defensive way!
            assert(0);
            return pWord;
        }
    }
    return pMerge(pLeft, pRight, fFree);
}

/*============================================================================
Implementation of private functions in CWordLink
============================================================================*/

// Merge word nodes from pLeft to pRight
// only called by pLeftMerge() and pRightMerge() and MergeWithNext()
// to do the merge work
CWord* CWordLink::pMerge(CWord* pLeft, CWord* pRight, BOOL fFree)
{
    assert(pLeft);
    assert(pRight);

    CWord* pNew;
    BOOL   fSBCS = (BOOL)(pLeft->fGetFlag(CWord::WF_SBCS));
    USHORT cwchText = pLeft->m_cwchText;

    pNew = pLeft;
    do {
        pNew = pNew->m_pNext;
        assert(pNew != NULL);
        fSBCS = fSBCS && pNew->fGetFlag(CWord::WF_SBCS);
        cwchText += pNew->m_cwchText;
    } while (pNew != pRight);
    // alloc a new word node to save the pLeft and serve as the old pLeft in child
    // the pLeft serve as the merged word.
    pNew = fFree ? NULL : pAllocWord();
    // pNew != NULL
    if (pNew != NULL) {
        assert(fFree == FALSE);
        pNew->CopyWord(pLeft);
#ifdef DEBUG
        if (pLeft->fHasChild()) {
            CWord* pTemp;
            pTemp = pLeft->pChildWord();
            while (pTemp) {
                pTemp->m_pMergedTo = pNew;
                pTemp = pTemp->m_pNext;
            }        
        }
#endif // DEBUG
    } else {
        // pNew == NULL, low-resource of system, force the words been merged be freed.
        fFree = TRUE;
        pNew = pLeft->pNextWord();
    }

    if ( pRight->m_pNext == NULL ) { // tail node
        m_pTail = pLeft;
        pLeft->m_pNext = NULL;
    } else {
        pRight->m_pNext->m_pPrev = pLeft;
        pLeft->m_pNext = pRight->m_pNext;
    }
    pLeft->m_cwchText = cwchText;

    if (fFree) {
        // pNew comes from pLeft->pNextWord() 
        pNew->m_pPrev = NULL;
        pRight->m_pNext = NULL;
        FreeLink(pNew);

        if (pLeft->fHasChild()) {
            pNew = pLeft->pChildWord();
            assert(pNew);
            pLeft->m_pMergedFrom = NULL;
#ifdef DEBUG
            pNew->m_pMergedTo = NULL;
#endif // DEBUG
            FreeLink(pNew);
        }
    } else {
        // link the pNew to pWord chain as the pLeft's child
        pNew->m_pPrev = NULL;
        pNew->m_pNext->m_pPrev = pNew;
        pRight->m_pNext = NULL;
        pLeft->m_pMergedFrom = pNew;
#ifdef DEBUG
        while ( pNew != NULL ) {
            pNew->m_pMergedTo = pLeft;
            pNew = pNew->m_pNext;
        }
        assert(pLeft->pChildWord());
#endif //DEBUG
    }
    // reset the merged node
    pLeft->ClearWord();
    if(fSBCS) {
        pLeft->SetFlag(CWord::WF_SBCS);
    }
    assert(pLeft->fGetFlag(CWord::WF_SBCS) || pLeft->m_cwchText > 1);
    pLeft->SetFlag(CWord::WF_REDUCED); // All merged word node should be reduced
    return pLeft;
}

/*============================================================================
CWordLink::pNewWord()
    Alloc a new word from the free chain, expand the blocks if free chain empty
============================================================================*/
inline CWord* CWordLink::pNewWord()
{
    CWord* pWord;

    if (!m_pFree) {
        CMyPlex* pNewBlock = CMyPlex::Create(m_pWordPool, m_ciBlockSize, 
                                                          sizeof(CWord));
        if (!pNewBlock)
            return NULL;    // can not allocate more memory block

        // chain them into free list
        pWord = (CWord*)pNewBlock->Data();
        // free in reverse order to make it easier to debug 
        pWord += m_ciBlockSize - 1;
        for(int i = (m_ciBlockSize - 1); i >= 0; i--, pWord--) {
            pWord->m_pNext = m_pFree;
            m_pFree = pWord;
        }
    }
    assert(m_pFree != NULL);    // we must have nodes in the free list now!

    pWord = m_pFree;
    m_pFree = m_pFree->m_pNext;

    return pWord;
}

/*============================================================================
CWordLink::FreeLink(void)
    Free word in the link and reset the link (only link words to the free chain)
Remarks:
    This method call FreeLink( CWord *pWord ) recursion to free link and child link
============================================================================*/
void CWordLink::FreeLink(void)
{
#ifdef DEBUG
    assert(!fDetectLeak()); // Assert: no memory leak detected
#endif // DEBUG
    if (m_pwchText) {
        if (m_pHead) { 
            CWord* pTemp = m_pHead;
            m_pwchText = NULL;
            m_pHead = NULL;
            m_pTail = NULL;
            FreeLink(pTemp);
        } else {
            assert(m_pwchText == NULL);
            assert(m_pHead == NULL);
            assert(m_pTail == NULL);
        }
    }
    assert(!m_pHead);
}

/*============================================================================
Implementation of private debugging functions
============================================================================*/
#ifdef  DEBUG

/*============================================================================
CWordLink::fInLink()
    Debugging function to check whether a word pointer is in the link.
    Not check whether the pointer is in child chain.
============================================================================*/
BOOL CWordLink::fInLink(CWord* pWord)
{
    CWord* pcw = m_pHead;
    while (pcw) {
        if (pcw == pWord)
            return TRUE;
        pcw = pcw->m_pNext;
    }
    return FALSE;
}

/*============================================================================
CWordLink::fInChild()
    Debugging function to check whether a word pointer is in one of the 
    child chains.
============================================================================*/
inline BOOL CWordLink::fInChild(CWord* pWord)
{
    CWord* pcw = m_pHead;
    while (pcw) {
        if (pcw->m_pMergedFrom != NULL && fInChildOf(pWord, pcw)) {
            return TRUE;
        }
        pcw = pcw->pNextWord();
    }
    return FALSE;
}

/*============================================================================
CWordLink::fInChildOf()
    Debugging function to check whether a word pointer is in the child chain 
    of the pParent.
============================================================================*/
BOOL CWordLink::fInChildOf(CWord* pWord, CWord* pParent)
{
    CWord* pcw = pParent->pChildWord();
    while (pcw) {
        if (pcw == pWord) {
            return TRUE;
        } else if (pcw->m_pMergedFrom != NULL && fInChildOf(pWord, pcw)) {
            return TRUE;
        } else {
        }
        pcw = pcw->m_pNext;
    }
    return FALSE;
}

/*============================================================================
CWordLink::fInBlocks()
    Debugging function to check whether the pWord is in CMyPlex blocks
============================================================================*/
BOOL CWordLink::fInBlocks(CWord* pWord)
{
    CWord* pFirstWord;
    CMyPlex* pBlock = m_pWordPool;
    while(pBlock) {
        pFirstWord = (CWord*)(pBlock->Data());
        if(pWord >= pFirstWord && pWord < (pFirstWord + m_ciBlockSize)) {
            return TRUE;
        }
        pBlock = pBlock->m_pNext;
    }
    return FALSE;
}

/*============================================================================
CWordLink::fInFree()
    Debugging function to check whether the pWord is in free links
============================================================================*/
BOOL CWordLink::fInFree(CWord* pWord)
{
    CWord* pcw = m_pFree;
    while (pcw) {
        if (pcw == pWord) {
            return TRUE;
        }
        pcw = pcw->m_pNext;
    }
    return FALSE;
}

/*============================================================================
CWordLink::SetDetectFlag
    Debugging function to set the word node leak flg used by fDetectLeak()
============================================================================*/
void CWordLink::SetDetectFlag(CWord* pWord)
{
    CWord* pcw = pWord;
    while (pcw) {
        if (pcw->m_pMergedFrom != NULL) {
            SetDetectFlag( pcw->m_pMergedFrom );
        }
        pcw->SetFlag(CWord::WF_DEBUG);
        pcw = pcw->m_pNext;
    }
    return;
}

/*============================================================================
CWordLink::fDetectLeak()
    Debugging function to check whether there are some word node leak to
    out of the link and the free chain
Returns:
    TRUE if any leak is detected, 
    FALSE if no leak detected
Remarks: 
    I hire the most significant bit in CWord::m_bFlag as the debugging use
============================================================================*/
BOOL CWordLink::fDetectLeak(void)
{
    CWord* pWord;
    CMyPlex* pBlock;
    UINT i;

    // clear flag bit for all words in all blocks
    for(pBlock = m_pWordPool; pBlock; pBlock = pBlock->m_pNext) {
        for(i = 0, pWord = (CWord*)(pBlock->Data()); 
                                  i < m_ciBlockSize; i++, pWord++) {
            pWord->ClearFlag(CWord::WF_DEBUG);
        }
    }

    // mark the flag bit for words in current link and in the free chain
    SetDetectFlag( m_pHead );
    for(pWord = m_pFree; pWord; pWord = pWord->m_pNext) {
        pWord->SetFlag(CWord::WF_DEBUG);
    }

    // Check whether there are any leak words
    for(pBlock = m_pWordPool; pBlock; pBlock = pBlock->m_pNext) {
        for(i = 0, pWord = (CWord*)(pBlock->Data()); i < m_ciBlockSize; i++, pWord++) {
            if(!pWord->fGetFlag(CWord::WF_DEBUG)) {
                return TRUE;
            }
        }
    }

    return FALSE;
}


#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht\stemmer2.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1995.
//
//  File:       stemmer.cxx
//
//  Contents:   NLG's FarEast Stemmer
//
//  History:    01-July-1996   PatHal       Created.
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "stemmer.hxx"

extern long gulcInstances;

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::CStemmer
//
//  Synopsis:   Constructor for the CStemmer class.
//
//  Arguments:  [lcid] -- locale id
//
//----------------------------------------------------------------------------

CStemmer::CStemmer( LCID lcid )
        : _cRefs(1)
{
   InterlockedIncrement( &gulcInstances );
}


//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::~CStemmer
//
//  Synopsis:   Destructor for the CStemmer class.
//
//  Notes:      All termination/deallocation is done by embedded smart pointers
//
//----------------------------------------------------------------------------

CStemmer::~CStemmer()
{
   InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::QueryInterface( REFIID riid, void  ** ppvObject)
{
    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 & 0x000000FF )
    {
    case 0x00:
        if ( riid == IID_IUnknown )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0x40:
        if ( riid == IID_IStemmer )
            pUnkTemp = (IUnknown *)(IStemmer *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;
    return(sc);
}


//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CStemmer::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CStemmer::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::Init
//
//  Synopsis:   Initialize stemmer
//
//  Arguments:  [ulMaxTokenSize] -- Maximum size token stored by caller
//              [pfLicense]      -- Set to true if use restricted
//
//  Returns:    Status code
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::Init(
    ULONG ulMaxTokenSize,
    BOOL *pfLicense )
{
    if (IsBadWritePtr(pfLicense, sizeof(DWORD))) {
        return E_FAIL;
    }

    *pfLicense = TRUE;
    _ulMaxTokenSize = ulMaxTokenSize;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::GetLicenseToUse
//
//  Synopsis:   Returns a pointer to vendors license information
//
//  Arguments:  [ppwcsLicense] -- ptr to ptr to which license info is returned
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CStemmer::GetLicenseToUse( const WCHAR **ppwcsLicense )
{
    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-1995";

    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) {
        return ( E_FAIL );
    }

    *ppwcsLicense = wcsCopyright;
    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::StemWord
//
//  Synopsis:   Stem a word into its inflected forms, eg swim to swims and swimming
//
//  Arguments:  [pwcInBuf] -- input Unicode word
//              [cwc] -- count of characters in word
//              [pStemSink] -- sink to collect inflected forms
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::StemWord(
    WCHAR const *pwc,
    ULONG cwc,
    IStemSink *pStemSink )
{
    SCODE sc = S_OK;

    if ( 0 == pStemSink || 0 == pwc ) {
        return E_FAIL;
    }

    if ( 0 == cwc) {
        return S_OK;
    }

    CONST WCHAR *pwcStem;
    DWORD i;
    BYTE ct;
    BOOL fRomanWord = FALSE;

    __try {

        for ( i=1; i< ( cwc - 1 ); i++, pwc++) {
            ct = GetCharType(*pwc);

            if (ct == CH) {
                if (!fRomanWord) {
                    pwcStem = pwc;
                    fRomanWord = TRUE;
                }
            }
            else {
                if (fRomanWord) {
                    (pStemSink->PutWord)( pwcStem, pwc - pwcStem );
                    fRomanWord = FALSE;
                }
                else {
                    switch (ct) {
                    case PS:
                    case WS:
                        break;
                    default:
                        (pStemSink->PutWord)( pwc, 2 );
                        break;
                    }
                }
            }
        }

        // put the last English word
        if (fRomanWord) {
            (pStemSink->PutWord)( pwcStem, pwc - pwcStem );
            fRomanWord = FALSE;
        }

        // output inflected words to stemmer sink in EnumInflections callback
    } __except (1) {

        sc = E_UNEXPECTED;
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht\wbclassf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994
//
//  File:       wbclassf.cxx
//
//  Contents:   Word Breaker class factory
//
//  History:    01-July-1995     PatHal   Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "wbclassf.hxx"
#include "iwbreak.hxx"

extern long gulcInstances;

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::CWordBreakerCF
//
//  Synopsis:   Word Breaker class factory constructor
//
//--------------------------------------------------------------------------

CWordBreakerCF::CWordBreakerCF( LCID lcid )
        : _cRefs( 1 ), _lcid( lcid )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::~CWordBreakerCF
//
//  Synopsis:   Word Breaker class factory destructor
//
//--------------------------------------------------------------------------

CWordBreakerCF::~CWordBreakerCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CWordBreakerCF::QueryInterface( REFIID riid,
                                                        void  ** ppvObject )
{
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown      = 00000000-0000-0000-C000-000000000046
    // IID_IClassFactory = 00000001-0000-0000-C000-000000000046
    //                           --
    //                           |
    //                           +--- Unique!
    //

    Assert( (IID_IUnknown.Data1& 0x000000FF) == 0x00 );
    Assert( (IID_IClassFactory.Data1 & 0x000000FF) == 0x01 );

    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 & 0x000000FF ) {
    case 0x00:
        if ( memcmp( &IID_IUnknown, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0x01:
        if ( memcmp( &IID_IClassFactory, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)(IClassFactory *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;

    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CWordBreakerCF::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CWordBreakerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::CreateInstance
//
//  Synopsis:   Creates new CWordBreaker object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreakerCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID riid,
    void  * * ppvObject )
{
    CWordBreaker *pIUnk = 0;
    SCODE sc = S_OK;

    if (NULL != pUnkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return E_NOINTERFACE;
    }

    __try {
        pIUnk = new CWordBreaker( _lcid );
        sc = pIUnk->QueryInterface(  riid , ppvObject );

        pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    __except(1)
    {
        Assert( 0 == pIUnk );

        sc = E_UNEXPECTED;
    }

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreakerCF::LockServer(
    BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht\iwbreak.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997
//
//  File:       IWBreak.cxx
//
//  Contents:   FarEast Word Breaker glue code
//
//  History:    01-Jul-96   PatHal             Created.
//                          weibz              Merged and modified to NT5
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "iwbreak.hxx"

extern long gulcInstances;

#ifdef IWBDBG
void  WbDbgOutputInt(WCHAR *pTitle, INT  data)
{

         WCHAR  Outdbg[20];
         int    itmp, ii;

         OutputDebugStringW(pTitle);

         for (ii=0; ii<20; ii++)
           Outdbg[ii] = 0x0020;

         ii =7;
         itmp = data;
         Outdbg[ii--] = 0x0000;

         while (itmp) {

            if ( (itmp % 16) < 10 )
               Outdbg[ii] = itmp % 16 + L'0';
            else
               Outdbg[ii] = itmp % 16 + L'A' - 10;

            ii --;
            itmp = itmp / 16;
         }

         OutputDebugStringW(Outdbg);

}

#endif

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::CWordBreaker
//
//  Synopsis:   Constructor for the CWordBreaker class.
//
//  Arguments:  [lcid] -- locale id
//
//----------------------------------------------------------------------------

CWordBreaker::CWordBreaker( LCID lcid )
        : _cRefs(1),
          _lcid(lcid)
{
    InterlockedIncrement( &gulcInstances );
#if defined(TH_LOG)
    _hLog = ThLogOpen( "log.utf");
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::~CWordBreaker
//
//  Synopsis:   Destructor for the CWordBreaker class.
//
//  Notes:      All termination/deallocation is done by embedded smart pointers
//
//----------------------------------------------------------------------------

CWordBreaker::~CWordBreaker()
{
   InterlockedDecrement( &gulcInstances );
#if defined(TH_LOG)
    ThLogClose( _hLog );
#endif
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::QueryInterface( REFIID riid, void  ** ppvObject)
{
    //
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown     = 00000000-0000-0000-C000-000000000046
    // IID_IWordBreaker = D53552C8-77E3-101A-B552-08002B33B0E6
    //                    --------
    //                           |
    //                           +--- Unique!
    //

    Assert( (IID_IUnknown.Data1     & 0x000000FF) == 0x00 );
    Assert( (IID_IWordBreaker.Data1 & 0x000000FF) == 0xC8 );

    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 )
    {
    case 0x00000000:
        if ( memcmp( &IID_IUnknown, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0xD53552C8:
        if ( memcmp( &IID_IWordBreaker, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)(IWordBreaker *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;
    return(sc);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CWordBreaker::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CWordBreaker::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::Init
//
//  Synopsis:   Initialize word-breaker
//
//  Arguments:  [fQuery]         -- TRUE if query-time
//              [ulMaxTokenSize] -- Maximum size token stored by caller
//              [pfLicense]      -- Set to true if use restricted
//
//  Returns:    Status code
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::Init(
    BOOL fQuery,
    ULONG ulMaxTokenSize,
    BOOL *pfLicense )
{

    if ( NULL == pfLicense )
       return E_INVALIDARG;

    if (IsBadWritePtr(pfLicense, sizeof(DWORD))) {
        return E_INVALIDARG;
    }

    *pfLicense = TRUE;
    _fQuery = fQuery;
    _ulMaxTokenSize = ulMaxTokenSize;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::ComposePhrase
//
//  Synopsis:   Convert a noun and a modifier into a phrase.
//
//  Arguments:  [pwcNoun] -- pointer to noun.
//              [cwcNoun] -- count of chars in pwcNoun
//              [pwcModifier] -- pointer to word modifying pwcNoun
//              [cwcModifier] -- count of chars in pwcModifier
//              [ulAttachmentType] -- relationship between pwcNoun &pwcModifier
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CWordBreaker::ComposePhrase(
    WCHAR const *pwcNoun,
    ULONG cwcNoun,
    WCHAR const *pwcModifier,
    ULONG cwcModifier,
    ULONG ulAttachmentType,
    WCHAR *pwcPhrase,
    ULONG *pcwcPhrase )
{
    //
    // Need to code in later
    //
    if ( _fQuery )
        return( E_NOTIMPL );
    else
        return ( WBREAK_E_QUERY_ONLY );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::GetLicenseToUse
//
//  Synopsis:   Returns a pointer to vendors license information
//
//  Arguments:  [ppwcsLicense] -- ptr to ptr to which license info is returned
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CWordBreaker::GetLicenseToUse(
    const WCHAR **ppwcsLicense )
{
    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-1998";

    if ( NULL == ppwcsLicense )
       return E_INVALIDARG;

    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) {
        return E_INVALIDARG;
    }

    *ppwcsLicense = wcsCopyright;
    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::BreakText
//
//  Synopsis:   Break input stream into words.
//
//  Arguments:  [pTextSource] -- source of Unicode text
//              [pWordSink] -- sink for collecting words
//              [pPhraseSink] -- sink for collecting phrases
//
//  Notes:      Since the input buffer may be greater than MAX_BUFFER_LEN
//              we process the buffer in chunks of length MAX_BUFFER_LEN.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::BreakText(
    TEXT_SOURCE *pTextSource,
    IWordSink *pWordSink,
    IPhraseSink *pPhraseSink )
{

    SCODE sc = S_OK;

    if ( NULL == pWordSink ) {
        // BUGBUG, propagate the null word sink error code
        return sc;
    }

    // BUGBUG, need to normalize nums within T-Hammer, pass as flag?

    // turn on noun phrase analysis if there is a phrase sink
    if ( 0 != pPhraseSink ) {
        // BUGBUG, do we need to pass a separate flag to T-Hammer for this?
        // ignore the phrase sink for now
        // return sc;
    }

    if ( ( NULL == pTextSource ) ||
         ( pTextSource->iEnd < pTextSource->iCur ) ) {
        return E_INVALIDARG;
    }

    if (pTextSource->iEnd == pTextSource->iCur) {
        return S_OK;
    }

    CONST WCHAR *pwcInput, *pwcStem;
    ULONG cwc, cwcTail, iwcCurrent;

    DWORD i;
    BYTE ct;
    BOOL fRomanWord = FALSE;

    __try {

        cwcTail = pTextSource->iEnd - pTextSource->iCur;


#ifdef IWBDBG
        {
          WCHAR  tmp[2];
          DWORD  ii;

          WbDbgOutputInt(L"\niCur=", pTextSource->iCur);
          WbDbgOutputInt(L"\niEnd=", pTextSource->iEnd);

          OutputDebugStringW(L"\n the Source String is:\n");
          for (ii=pTextSource->iCur; ii<pTextSource->iEnd; ii++) {
            tmp[0] = *(pTextSource->awcBuffer + ii);
            tmp[1] = L'\0';
            OutputDebugStringW(tmp);
          }

          OutputDebugStringW(L"\n");

        }

#endif
        do {

            cwc = pTextSource->iEnd - pTextSource->iCur;

            // Reinit the callback data structure
            iwcCurrent = pTextSource->iCur;
            pwcStem = pwcInput = pTextSource->awcBuffer + pTextSource->iCur;

            for (i=0; i< cwc; i++, pwcInput++) {

                if (*(pwcInput) != 0) {
                    ct = GetCharType(*pwcInput);

                    if (ct == CH) {
                        if (!fRomanWord) {
                            pwcStem = pwcInput;
                            fRomanWord = TRUE;
                        }
                    }
                    else {
                        if (fRomanWord) {
                            DWORD cwcTemp = (DWORD)(pwcInput - pwcStem);
                            if (cwcTemp > 0) {
                                (pWordSink->PutWord)(cwcTemp, pwcStem, cwcTemp,
                                 iwcCurrent + (i - cwcTemp));
                            }
                            fRomanWord = FALSE;
                        }
//                        else {
                            switch (ct) {
                            case PS:
                                (pWordSink->PutBreak)( WORDREP_BREAK_EOS );
                            case WS:
                                break;
                            default:
                                (pWordSink->PutWord)(1, pwcInput, 1, iwcCurrent + i);
                                break;
                            }
//                        }
                    }
                }
            }

            if ( !fRomanWord )
               pTextSource->iCur += i;
            else {
               CONST WCHAR  *pStart;

               pStart = pTextSource->awcBuffer + pTextSource->iCur;
               pTextSource->iCur += (DWORD)(pwcStem - pStart);

               fRomanWord = FALSE;
            }

            cwcTail = pTextSource->iEnd - pTextSource->iCur;

        } while ( SUCCEEDED(pTextSource->pfnFillTextBuffer(pTextSource)) );

        // Don't ignore the tail HPB
        if (cwcTail > 0) {

            iwcCurrent = pTextSource->iCur;
            pwcInput = pTextSource->awcBuffer + pTextSource->iCur;


            for (i=0; i< cwcTail; i++, pwcInput++) {
                if (*(pwcInput) != 0) {
                    ct = GetCharType(*pwcInput);

                    if (ct == CH) {
                        if (!fRomanWord) {
                            pwcStem = pwcInput;
                            fRomanWord = TRUE;
                        }
                    }
                    else {
                        if (fRomanWord) {
                            DWORD cwcTemp = (DWORD)(pwcInput - pwcStem);
                            (pWordSink->PutWord)(cwcTemp, pwcStem, cwcTemp,
                                iwcCurrent + (i - cwcTemp));
                            fRomanWord = FALSE;
                        }
//                        else {
                            switch (ct) {
                            case PS:
                                (pWordSink->PutBreak)( WORDREP_BREAK_EOS );
                            case WS:
                                break;
                            default:
                                (pWordSink->PutWord)(1, pwcInput, 1, iwcCurrent + i);
                                break;
                            }
//                        }
                    }
                }
            }
        }

        // put the last English word
        if (fRomanWord) {
            DWORD cwcTemp = (DWORD)(pwcInput - pwcStem);

            assert( cwcTemp > 0);

            if ( 0 == *(pwcInput-1) ) {
                 i--;
                 cwcTemp--;
            }

            (pWordSink->PutWord)(cwcTemp, pwcStem, cwcTemp,
                                 iwcCurrent + (i - cwcTemp));

            fRomanWord = FALSE;
        }

    } __except(1) {

        sc = E_UNEXPECTED;
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht\ctplus0.c ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999.
//
//  File:       ctplus.c
//
//  Contents:   Contains character type (orthography) data and routine
//                    to get at it.
//
//  History:    23-May-96   pathal      Created.
//
//---------------------------------------------------------------------------

#include "precomp.h"
#include <winnls.h>

//----------------------------------------------------------------------------
//  s_abBreakList
//
//  This array starts at -1, so that EOF can be found in the array.  It
//  depends on (EOF == -1) being true.  Also, all references to it must be
//  of the form (s_abCharTypeList+1)[x]
//
//  000
//  EOF
//
//  001-080
//  The lower 7F entries from the ASCII Code Page (0000-00ff) are mapped in place
//  (ex. UNICODE 0009 (HT) == 009)
//      The word characters are: $,0-9,A-Z,_,a-z
//      The word separators are: bs,tab,lf,vtab,cr,spc,
//                               ",#,%,&,',(,),*,+,comma,-,/,
//                               :,;,<,=,>,@,[,],`
//      The phrase seperators are: !,.,?,\,^,{,|,},~
//
//  NOTE: Symbols are treated as WS or PS.
//
//  081-0FF
//  The lower 7E entries from the Half Width Variant Code Page (FF00-FF7F) are
//  mapped to 081-0FF.
//
//  100-1FF
//  The lower FF entries from the General Punctuation Code Page (2000-2044) are
//  mapped to 100-1ff.
//
//  200-2FF
//  The lower FF entries from the CJK Auxiliary Code Page (3000-30FF) are mapped
//  to 200-2ff.
//
// pathal - 5/20/96
// Special default character processing for selection
// The following is a list of white space characters that T-Hammer will not right select on:
//          0x0009 (tab), 0x0020 (ansi space), 0x2005 (narrow space, 0x3000 (wide space)
// (Note: see AnalyzeHPBs for special end SPB processing of adjacent white space)
// The following is a list of nls characters to be treated as text by T-Hammer:
//      (in other words T-Hammer will neither right nor left-select on them):
//          0x001F (non-required hyphen), 0x0027 (single quote), 0x2019 (right quote),
//          0x200C (non-width optional break), 0x200D (non-width no break)
//----------------------------------------------------------------------------

const BYTE
s_abCharTypeList[0x301] =
    {
        (BYTE) -1,                                       // EOF (-1)
        PS,PS,PS,PS,PS,PS,PS,PS, WS,WS,WS,WS,PS,WS,PS,PS, // 000 - 015
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,CH,PS, // 016 - 031
        WS,PS,WS,WS,CH,CH,WS,PS,                          // sp ! " # $ % & '
        WS,WS,WS,WS,WS,WS,PS,WS,                          //  ( ) * + , - . /
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  0 1 2 3 4 5 6 7
        CH,CH,WS,WS,WS,WS,WS,PS,                          //  8 9 : ; < = > ?
        WS,CH,CH,CH,CH,CH,CH,CH,                          //  @ A B C D E F G
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  H I J K M L N O
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  P Q R S T U V Y
        CH,CH,CH,WS,PS,WS,PS,CH,                          //  X Y Z [ \ ] ^ _
        WS,CH,CH,CH,CH,CH,CH,CH,                          //  ` a b c d e f g
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  h i j k m l n o
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  p q r s t u v y
        CH,CH,CH,PS,PS,PS,CH,PS,                          //  x y z { | } ~ del
        WS,PS,WS,WS,CH,CH,WS,WS,                          // FF00-FF07 (sp ! " # $ % & ')
        WS,WS,WS,WS,WS,WS,PS,WS,                          //  ( ) * + , - . /
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  0 1 2 3 4 5 6 7
        VC,VC,WS,WS,WS,WS,WS,PS,                          //  8 9 : ; < = > ?
        WS,VC,VC,VC,VC,VC,VC,VC,                          //  @ A B C D E F G
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  H I J K M L N O
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  P Q R S T U V Y
        VC,VC,VC,WS,VC,WS,PS,VC,                          //  X Y Z [ \ ] ^ _
        WS,VC,VC,VC,VC,VC,VC,VC,                          //  ` a b c d e f g
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  h i j k m l n o
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  p q r s t u v y
        VC,VC,VC,PS,PS,PS,VC,PS,                          //  x y z { | } ~ del
        VC,PS,WS,WS,WS,WS,VC,VC,                          //  FF60-FF67
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF68-FF6F
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF70-FF77
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF70-FF7E
        WS,WS,WS,WS,WS,WS,WS,WS,                          // 2000-2007
       WS,WS,WS,WS,CH,CH,WS,WS,                          //  2008-200F
        WS,CH,WS,WS,WS,KC,PS,WS,                          //  2010-2017
        WS,CH,WS,WS,WS,WS,WS,WS,                          //  2018-201F
        WS,WS,PS,PS,PS,PS,PS,CH,                          //  2020-2027
        PS,PS,CH,CH,CH,CH,CH,PS,                          //  2028-202F
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2030-2037
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2038-203F
        WS,WS,WS,PS,WS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2040-204F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2050-205F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2060-206F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2070-207F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2080-208F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2090-209F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20A0-20AF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20B0-20BF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20C0-20CF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20D0-20DF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20E0-20EF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20F0-20FF
        WS,WS,PS,HC,HC,IC,IC,HC,                          // 3000-3007
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3008-300F
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3010-3017
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3018-301F
        HC,HC,HC,HC,HC,HC,HC,HC,                          //  3020-3027
        HC,HC,HC,HC,HC,HC,HC,HC,                          //  3028-302F
        WS,HC,IC,HC,IC,HC,HC,HC,                          //  3030-3037
        PS,PS,PS,PS,PS,PS,PS,WS,                          //  3038-303F
        WS,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3040-304F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3050-305F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3060-306F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3070-307F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3080-308F
        HC,HC,HC,HC,HC,PS,PS,PS,                          //  3090-3097
        PS,HC,HC,WS,WS,HC,HC,PS,                          //  3098-309F
        WS,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30A0-30AF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30B0-30BF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30C0-30CF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30D0-30DF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30E0-30EF
        KC,KC,KC,KC,KC,KC,IC,PS,                          //  30F0-30F7
        PS,PS,PS,WS,KC,KC,KC,PS,                          //  30F8-30FF
    };

//
// Type C1 bits are:
//
//   C1_UPPER                  0x0001      // upper case
//   C1_LOWER                  0x0002      // lower case
//   C1_DIGIT                  0x0004      // decimal digits             1
//   C1_SPACE                  0x0008      // spacing characters         2
//   C1_PUNCT                  0x0010      // punctuation characters     4
//   C1_CNTRL                  0x0020      // control characters         8
//   C1_BLANK                  0x0040      // blank characters          10
//   C1_XDIGIT                 0x0080      // other digits              20
//   C1_ALPHA                  0x0100      // any linguistic character  40
//
// But since I don't care about C1_UPPER and C1_LOWER I can right-shift
// the output of GetStringTypeEx and keep a 128 Byte lookup table.
//
// The precedence rules are: (Alpha, XDigit, Digit) --> CH
//                           (Punct) --> PS
//                           (Space, Blank, Control) --> WS
//

const BYTE
s_abCTypeList[128] =
    {
      WS, CH, WS, CH, PS, CH, WS, CH,   // 00 - 07
      WS, CH, WS, CH, PS, CH, WS, CH,   // 08 - 0F
      WS, CH, WS, CH, PS, CH, WS, CH,   // 10 - 17
      WS, CH, WS, CH, PS, CH, WS, CH,   // 18 - 1F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 20 - 27
      CH, CH, CH, CH, CH, CH, CH, CH,   // 20 - 27
      CH, CH, CH, CH, CH, CH, CH, CH,   // 30 - 37
      CH, CH, CH, CH, CH, CH, CH, CH,   // 30 - 37
      CH, CH, CH, CH, CH, CH, CH, CH,   // 40 - 47
      CH, CH, CH, CH, CH, CH, CH, CH,   // 48 - 4F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 50 - 57
      CH, CH, CH, CH, CH, CH, CH, CH,   // 58 - 5F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 60 - 67
      CH, CH, CH, CH, CH, CH, CH, CH,   // 68 - 6F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 70 - 77
      CH, CH, CH, CH, CH, CH, CH, CH,   // 78 - 7F
    };

//+---------------------------------------------------------------------------
//  Member:     WBREAKJ::TypeOf
//
//  Synopsis:   Returns the type of a character
//
//  Arguments:  [c]   -- Unicode Character
//
//  Returns:    type, one of CH, WS, PS, EOF
//
//  History:    08-Apr-94   PatHal      Adapted for Japanese WB
//
//  Notes:      This returns the type of a character, using the static
//              array s_abCharTypeList.  It adds 1 so that EOF (-1) can be in
//              the array, and accessed normally.
//
//              This is not done by overloading the [] opeator, because in
//              future versions it will not necessarly be a table lookup.
//
//  See above (typeof comments) for an explanation of the mapping
//
//----------------------------------------------------------------------------
BYTE
GetCharType(WCHAR wc )
{
    WCHAR wc2;

    // Map interesting stuff (0000, 2000, 3000, FF00) to the table range,
    // 0x0000 - 0x0300.
    //
    wc2 = (wc & 0x00FF);

    switch (wc & 0xFF00) {

        case 0xFF00:  // Half-Width Variants
            if (wc2 & 0x80) {
                return(VC);  // including Hangul
            }
            wc2 |=  0x0080;
            break;

        case 0xFE00:  // Small Variants
            if ((wc2 <= 0x006B) && (wc2 != 0x0069)) {
                return(WS);
            }
            // Treat Small $ and arabic symbols as CH
            return(CH);
            // break;

        case 0x3000:  // CJK Auxiliary
            wc2 |=  0x0200;
            break;

        case 0x2000:  // General Punctuation
            wc2 |=  0x0100;
            break;

        case 0x0000:  // Code page 0
            // Use System NLS map for code page 0
            if (wc2 & 0x80)
            {
                WORD wCharType = 0;

                GetStringTypeEx( MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL ),
                                 CT_CTYPE1,
                                 &wc2,
                                 1,
                                 &wCharType );
                return s_abCTypeList[wCharType >> 2];
            }
            break;

        default:
            //
            // Treat the whole CJK Range as Kanji
            //
            if ((wc >= 0x4E00) && (wc <= 0x9FFF)) {
                return(IC);
            }

            //
            // Treat All Gaiji as Kanji Char, too
            //
            if ((wc >= 0xE000) && (wc < 0xE758)) {
                return(IC);
            }

            //
            // Treat all CJK symbols as word separators
            // NOTE: This means that the stemmer must be smart about searching
            // for zipcodes when given one with a preceding zipcode char.
            //
            if ((wc >= 0x3200) && (wc <= 0x33DD)) {
                return(WS);
            }

            // If it's not interesting return CH as default;
            return(CH);
            // break;
    }

    return( (s_abCharTypeList+1)[wc2] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht\iwbreak2.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997
//
//  File:       IWBreak.cxx
//
//  Contents:   FarEast Word Breaker glue code
//
//  History:    01-Jul-96   PatHal             Created.
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "iwbreak.hxx"

extern long gulcInstances;

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::CWordBreaker
//
//  Synopsis:   Constructor for the CWordBreaker class.
//
//  Arguments:  [lcid] -- locale id
//
//----------------------------------------------------------------------------

CWordBreaker::CWordBreaker( LCID lcid )
        : _cRefs(1),
          _lcid(lcid)
{
    InterlockedIncrement( &gulcInstances );
#if defined(TH_LOG)
    _hLog = ThLogOpen( "log.utf");
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::~CWordBreaker
//
//  Synopsis:   Destructor for the CWordBreaker class.
//
//  Notes:      All termination/deallocation is done by embedded smart pointers
//
//----------------------------------------------------------------------------

CWordBreaker::~CWordBreaker()
{
   InterlockedDecrement( &gulcInstances );
#if defined(TH_LOG)
    ThLogClose( _hLog );
#endif
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::QueryInterface( REFIID riid, void  ** ppvObject)
{
    //
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown     = 00000000-0000-0000-C000-000000000046
    // IID_IWordBreaker = D53552C8-77E3-101A-B552-08002B33B0E6
    //                    --------
    //                           |
    //                           +--- Unique!
    //

    Assert( (IID_IUnknown.Data1     & 0x000000FF) == 0x00 );
    Assert( (IID_IWordBreaker.Data1 & 0x000000FF) == 0xC8 );

    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 )
    {
    case 0x00000000:
        if ( memcmp( &IID_IUnknown, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0xD53552C8:
        if ( memcmp( &IID_IWordBreaker, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)(IWordBreaker *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;
    return(sc);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CWordBreaker::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CWordBreaker::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::Init
//
//  Synopsis:   Initialize word-breaker
//
//  Arguments:  [fQuery]         -- TRUE if query-time
//              [ulMaxTokenSize] -- Maximum size token stored by caller
//              [pfLicense]      -- Set to true if use restricted
//
//  Returns:    Status code
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::Init(
    BOOL fQuery,
    ULONG ulMaxTokenSize,
    BOOL *pfLicense )
{
    if (IsBadWritePtr(pfLicense, sizeof(DWORD))) {
        return E_FAIL;
    }

    *pfLicense = TRUE;
    _fQuery = fQuery;
    _ulMaxTokenSize = ulMaxTokenSize;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::ComposePhrase
//
//  Synopsis:   Convert a noun and a modifier into a phrase.
//
//  Arguments:  [pwcNoun] -- pointer to noun.
//              [cwcNoun] -- count of chars in pwcNoun
//              [pwcModifier] -- pointer to word modifying pwcNoun
//              [cwcModifier] -- count of chars in pwcModifier
//              [ulAttachmentType] -- relationship between pwcNoun &pwcModifier
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CWordBreaker::ComposePhrase(
    WCHAR const *pwcNoun,
    ULONG cwcNoun,
    WCHAR const *pwcModifier,
    ULONG cwcModifier,
    ULONG ulAttachmentType,
    WCHAR *pwcPhrase,
    ULONG *pcwcPhrase )
{
    //
    // Need to code in later
    //
    if ( _fQuery )
        return( E_NOTIMPL );
    else
        return ( WBREAK_E_QUERY_ONLY );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::GetLicenseToUse
//
//  Synopsis:   Returns a pointer to vendors license information
//
//  Arguments:  [ppwcsLicense] -- ptr to ptr to which license info is returned
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CWordBreaker::GetLicenseToUse(
    const WCHAR **ppwcsLicense )
{
    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-1995";
    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) {
        return E_FAIL;
    }

    *ppwcsLicense = wcsCopyright;
    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::BreakText
//
//  Synopsis:   Break input stream into words.
//
//  Arguments:  [pTextSource] -- source of Unicode text
//              [pWordSink] -- sink for collecting words
//              [pPhraseSink] -- sink for collecting phrases
//
//  Notes:      Since the input buffer may be greater than MAX_BUFFER_LEN
//              we process the buffer in chunks of length MAX_BUFFER_LEN.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::BreakText(
    TEXT_SOURCE *pTextSource,
    IWordSink *pWordSink,
    IPhraseSink *pPhraseSink )
{
    SCODE sc = S_OK;

    if ( 0 == pWordSink ) {
        // BUGBUG, propagate the null word sink error code
        return sc;
    }

    // BUGBUG, need to normalize nums within T-Hammer, pass as flag?

    // turn on noun phrase analysis if there is a phrase sink
    if ( 0 != pPhraseSink ) {
        // BUGBUG, do we need to pass a separate flag to T-Hammer for this?
        // ignore the phrase sink for now
        // return sc;
    }

    if ( ( 0 == pTextSource ) ||
         ( pTextSource->iEnd < pTextSource->iCur ) ) {
        return E_FAIL;
    }

    if (pTextSource->iEnd == pTextSource->iCur) {
        return S_OK;
    }

    CONST WCHAR *pwcInput, *pwcStem;
    ULONG cwc, cwcTail, iwcCurrent;

    DWORD i;
    BYTE ct;
    BOOL fRomanWord = FALSE;

    __try {

        cwcTail = pTextSource->iEnd - pTextSource->iCur;

#if defined(TH_LOG)
        // DEBUG:  Print out one QUERY or INDEX banner per entry to BreakText
        //
        WCHAR wszBanner[256];
        if (_fQuery) {
            wsprintfW( wszBanner, L"\r\n== QUERY ===================================================\r\n");
        }
        else {
            wsprintfW( wszBanner, L"\r\n== INDEX ===================================================\r\n");
        }
        ThLogWrite( _hLog, wszBanner );
#endif // defined(TH_LOG)

        do {

            cwc = pTextSource->iEnd - pTextSource->iCur;

            // Reinit the callback data structure
            iwcCurrent = pTextSource->iCur;
            pwcStem = pwcInput = pTextSource->awcBuffer + pTextSource->iCur;

#if defined(TH_LOG)
            // DEBUG:  Print out one of these banners for every buffer of text
            //
            wsprintfW( wszBanner, L"\r\n*********************************************************\r\n");
            ThLogWrite( _hLog, wszBanner );
            wsprintfW( wszBanner, L"iCur = %d, iEnd = %d\r\n\r\n", pTextSource->iCur, pTextSource->iEnd);
            ThLogWrite( _hLog, wszBanner );
            WCHAR *pwc = (WCHAR*)LocalAlloc( LMEM_FIXED, (cwc+1) * sizeof(WCHAR));
            if (pwc != NULL) {
                memcpy( pwc, &pTextSource->awcBuffer[ pTextSource->iCur ], cwc * sizeof(WCHAR) );
                *(pwc+cwc)=L'\0';
                ThLogWrite( _hLog, pwc );
                LocalFree(pwc);
            }
#endif defined(TH_LOG)

            for (i=0; i< cwc-1; i++, pwcInput++) {
                if (*(pwcInput+1) != 0) {
                    ct = GetCharType(*pwcInput);

                    if (ct == CH) {
                        if (!fRomanWord) {
                            pwcStem = pwcInput;
                            fRomanWord = TRUE;
                        }
                    }
                    else {
                        if (fRomanWord) {
                            DWORD cwcTemp = pwcInput - pwcStem;
                            if (cwcTemp > 0) {
                                (pWordSink->PutWord)(cwcTemp, pwcStem, cwcTemp,
                                 iwcCurrent + (i - cwcTemp));
                            }
                            fRomanWord = FALSE;
                        }
                        else {
                            switch (ct) {
                            case PS:
                                (pWordSink->PutBreak)( WORDREP_BREAK_EOS );
                            case WS:
                                break;
                            default:
                                (pWordSink->PutWord)(2, pwcInput, 2, iwcCurrent + i);
                                break;
                            }
                        }
                    }
                }
            }

            pTextSource->iCur += i;
            cwcTail = 1;

        } while ( SUCCEEDED(pTextSource->pfnFillTextBuffer(pTextSource)) );

        // Don't ignore the tail HPB
        if (cwcTail > 1) {

            iwcCurrent = pTextSource->iCur;
            pwcInput = pTextSource->awcBuffer + pTextSource->iCur;

#if defined(TH_LOG)
            wsprintfW( wszBanner, L"\r\n** TAIL *************************************************\r\n");
            ThLogWrite( _hLog, wszBanner );
            wsprintfW( wszBanner, L"iCur = %d, iEnd = %d, cwcTail = %d\r\n\r\n", pTextSource->iCur, pTextSource->iEnd, cwcTail);
            ThLogWrite( _hLog, wszBanner );
            WCHAR *pwc = (WCHAR*)LocalAlloc( LMEM_FIXED, (cwcTail+1) * sizeof(WCHAR));
            if (pwc != NULL) {
                memcpy( pwc, &pTextSource->awcBuffer[ pTextSource->iCur ], cwcTail * sizeof(WCHAR) );
                *(pwc+cwcTail)=L'\0';
                ThLogWrite( _hLog, pwc );
                LocalFree(pwc);
            }
#endif defined(TH_LOG)

            for (i=0; i< cwcTail-1; i++, pwcInput++) {
                if (*(pwcInput+1) != 0) {
                    ct = GetCharType(*pwcInput);

                    if (ct == CH) {
                        if (!fRomanWord) {
                            pwcStem = pwcInput;
                            fRomanWord = TRUE;
                        }
                    }
                    else {
                        if (fRomanWord) {
                            DWORD cwcTemp = pwcInput - pwcStem;
                            (pWordSink->PutWord)(cwcTemp, pwcStem, cwcTemp,
                                iwcCurrent + (i - cwcTemp));
                            fRomanWord = FALSE;
                        }
                        else {
                            switch (ct) {
                            case PS:
                                (pWordSink->PutBreak)( WORDREP_BREAK_EOS );
                            case WS:
                                break;
                            default:
                                (pWordSink->PutWord)(2, pwcInput, 2, iwcCurrent + i);
                                break;
                            }
                        }
                    }
                }
            }
        }

        // put the last English word
        if (fRomanWord) {
            DWORD cwcTemp = pwcInput - pwcStem;
            if (cwcTemp > 0) {
                (pWordSink->PutWord)(cwcTemp, pwcStem, cwcTemp,
                iwcCurrent + (i - cwcTemp));
            }
            fRomanWord = FALSE;
        }

    } __except(1) {

        sc = E_UNEXPECTED;
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht\stemmer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1995.
//
//  File:       stemmer.cxx
//
//  Contents:   NLG's FarEast Stemmer
//
//  History:    01-July-1996   PatHal       Created.
//                             weibz        Merged and Modified to NT5
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "stemmer.hxx"

extern long gulcInstances;

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::CStemmer
//
//  Synopsis:   Constructor for the CStemmer class.
//
//  Arguments:  [lcid] -- locale id
//
//----------------------------------------------------------------------------

CStemmer::CStemmer( LCID lcid )
        : _cRefs(1)
{
   InterlockedIncrement( &gulcInstances );
}


//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::~CStemmer
//
//  Synopsis:   Destructor for the CStemmer class.
//
//  Notes:      All termination/deallocation is done by embedded smart pointers
//
//----------------------------------------------------------------------------

CStemmer::~CStemmer()
{
   InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::QueryInterface( REFIID riid, void  ** ppvObject)
{
    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 & 0x000000FF )
    {
    case 0x00:
        if ( riid == IID_IUnknown )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0x40:
        if ( riid == IID_IStemmer )
            pUnkTemp = (IUnknown *)(IStemmer *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;
    return(sc);
}


//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CStemmer::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CStemmer::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::Init
//
//  Synopsis:   Initialize stemmer
//
//  Arguments:  [ulMaxTokenSize] -- Maximum size token stored by caller
//              [pfLicense]      -- Set to true if use restricted
//
//  Returns:    Status code
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::Init(
    ULONG ulMaxTokenSize,
    BOOL *pfLicense )
{

    if ( NULL == pfLicense )
       return E_INVALIDARG;

    if (IsBadWritePtr(pfLicense, sizeof(DWORD))) {
        return E_INVALIDARG;
    }

    *pfLicense = TRUE;
    _ulMaxTokenSize = ulMaxTokenSize;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::GetLicenseToUse
//
//  Synopsis:   Returns a pointer to vendors license information
//
//  Arguments:  [ppwcsLicense] -- ptr to ptr to which license info is returned
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CStemmer::GetLicenseToUse( const WCHAR **ppwcsLicense )
{
    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-1998";

    if ( NULL == ppwcsLicense )
       return E_INVALIDARG;

    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) {
        return E_INVALIDARG;
    }

    *ppwcsLicense = wcsCopyright;
    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::StemWord
//
//  Synopsis:   Stem a word into its inflected forms, eg swim to swims and swimming
//
//  Arguments:  [pwcInBuf] -- input Unicode word
//              [cwc] -- count of characters in word
//              [pStemSink] -- sink to collect inflected forms
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::StemWord(
    WCHAR const *pwc,
    ULONG cwc,
    IStemSink *pStemSink )
{
    SCODE sc = S_OK;

    if ( NULL == pStemSink || NULL == pwc ) {
        return E_FAIL;
    }

    if ( 0 == cwc) {
        return S_OK;
    }

    CONST WCHAR *pwcStem;
    DWORD i;
    BYTE ct;
    BOOL fRomanWord = FALSE;

    __try {

        for ( i=0; i< cwc; i++, pwc++) {
            ct = GetCharType(*pwc);

            if (ct == CH) {
                if (!fRomanWord) {
                    pwcStem = pwc;
                    fRomanWord = TRUE;
                }
            }
            else {
                if (fRomanWord) {
                    (pStemSink->PutWord)( pwcStem, (DWORD)(pwc - pwcStem) );
                    fRomanWord = FALSE;
                }
//                else {
                    switch (ct) {
                    case PS:
                    case WS:
                        break;
                    default:
                        (pStemSink->PutWord)( pwc, 1 );
                        break;
                    }
//                }
            }
        }

        // put the last English word
        if (fRomanWord) {
            (pStemSink->PutWord)( pwcStem, (DWORD)(pwc - pwcStem) );
            fRomanWord = FALSE;
        }

        // output inflected words to stemmer sink in EnumInflections callback
    } __except (1) {

        sc = E_UNEXPECTED;
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht\thammer.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1994, 1995, 1996 Microsoft Corporation.  All Rights Reserved.
//
//  File:       thammer.h
//
//  This include file defines 3 exported APIs and their callbacks that export
//  word-breaking functionality for non-spaced Asian languages (Japanese, Chinese)
//
//  Summary of exports:
//      EnumSelectionOffsets - This function returns the offsets for the
//          selection chunks as specified in the Selection Profile (set at compile-time)
//      EnumSummarizationOffsets - This function returns the offsets for the
//          prefix (if any), the stem, and bound morphemes (fuzokugo).
//      EnumStemOffsets - This function returns the offsets for the stem only.
//          Offsets corresponding to any prefix or postfix characters will not
//          be returned.
//
//  History:                    pathal          Created.
//              25-Jun-97       pathal          Add TH_ERROR_INIT_FAILED
//              05-Jul-97       pathal          Add EnumSentenceOffsets, etc.
//---------------------------------------------------------------------------

// Return errors: the following error codes can be returned from any of
// T-Hammer's exported APIs (EnumSelectionOffsets, EnumSummarizationOffsets,
// and EnumStemOffsets)
//

#define TH_ERROR_SUCCESS 0
#define TH_ERROR_NOHPBS 1
#define TH_ERROR_INVALID_INPUT 2
#define TH_ERROR_INVALID_CALLBACK 3
#define TH_ERROR_INIT_FAILED 4
#define TH_ERROR_NOT_IMPLEMENTED 5

// Offset delimiter: the following code is used to delimit the end of a list of
// token offsets returned to one of the Enum* callback routines.  This is not
// an error code.

#define TH_SELECTION_INVALID_OFFSET 0xFFFFFFFF

// TOKENIZE_MODE: Begin and End HPB Modes
//
// Begin and End HPB modes signify that a hard phrase break comes before the
// first character in the string and/or follows after the last character in the string
// If these flags are not set, then the default behavior of EnumTokens is to start
// enumerating tokens to the right of the leftmost HPB, which probably won't
// be at the first character (unless it is a punctuation symbol) and to conclude
// enumeration at the rightmost HPB, which likely will not be the true end of the
// string.  So, these flags in affect force HPBs at the 0th and nth offsets, where
// n is the number of characters in the input buffer
//
// WARNNIG: Since Tokenize operates in batch mode, it assumes that the
// start and end of the input buffer are HPBs. These flags are only used for
// EnumTokens
//
#define TOKENIZE_MODE_BEGIN_HPB             0x00000001
#define TOKENIZE_MODE_END_HPB             0x00000002

// Note on HPBs:  HPB = hard phrase break.
// HPBs are statistically determined from analyzing a tagged corpora.
// Roughly, they cor-respond to places where you csn break with 100%
// precision (=confidence). Mostly this is around punctuation characters
// and certain conspicuous [case markers | character type] bigrams.


// When the Hide Punctuation mode is set in the tokenize flag parameter
// T-Hammer strips punctuation out of the Stem Offsets and Summarization Offsets
// callback
//
#define TOKENIZE_MODE_HIDE_PUNCTUATION    0x00000004

//+--------------------------------------------------------------------------
//  Routine:    EnumSelectionOffsetsCallback
//
//  Synopsis: client-side callback that receives a list of offsets for selection chunks
//
//  Parameters:
//      pichOffsets - pointer to first element in an array of offsets into client
//          text buffer. NOTE: callback is not allowed to stash pichChunks for
//          later processing.  pichChunks will not persist between successive
//          callbacks.  If the callback wants to use the data pointed to by pich
//          it must copy it to its own store
//      cOffsets - number of offsets passed to client (always > 1)
//      lpData - client defined data
//
// Return:
//  TRUE - to abort token enumeration
//  FALSE - to continue
//---------------------------------------------------------------------------
// BOOL
// EnumSelectionOffsetsCallback (
//    IN CONST DWORD *pichOffsets,
//    IN DWORD cOffsets,
//    IN OUT LPARAM lpData);

typedef BOOL (CALLBACK * ENUM_SELECTION_OFFSETS_CALLBACK)(
    IN CONST DWORD *pichOffsets,
    IN CONST DWORD cOffsets,
    IN OUT LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumSelectionOffsets
//
//  Synopsis:  This is the main entry point for tokenizing text.  Sends tokens,
//  which can either be offsets or zero delimited strings to callback.
//
//  Parameters:
//  pwszText - pointer to wide-character text buffer to be tokenized,
//  cchText - count of characters in text buffer,
//  fBeginEndHPBMode - flag describing the callback mode  (see above),
//  pcbEnumSelectionOffsets - pointer to callback procedure handling token
//     enumeration,
//  lpData - client defined data
//
//  Returns:
//      TH_ERROR_SUCCESS - if the call completed successfully
//      TH_ERROR_NOHPBS - if there were no HPBs
//      TH_ERROR_INVALID_INPUT - if the input buffer was bad
//      TH_ERROR_INVALID_CALLBACK - if the input callback was bad
//---------------------------------------------------------------------------
INT
APIENTRY
EnumSelectionOffsets(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_SELECTION_OFFSETS_CALLBACK pcbEnumSelectionOffsets,
    IN LPARAM lpData);

typedef INT (APIENTRY *LP_ENUM_SELECTION_OFFSETS)(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_SELECTION_OFFSETS_CALLBACK pcbEnumSelectionOffsets,
    IN LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumSummarizationOffsetsCallback
//
//  Synopsis: client-side callback that receives a list of offsets for each stem
//      in the free morpheme (jiritsugo) phrase.   Last offset is always contains
//      the complete string of bound morphemes (fuzokugo).  For example,
//      for "kaisan shite nai sou desu", offsets are returned for "kaisan" and
//      "shite nai sou desu".  So, counting the first initial offset, there are three
//      offsets.
//
//  Parameters:
//      pichOffsets - pointer to first element in an array of offsets into client
//          text buffer. NOTE: callback is not allowed to stash pichOffsets for
//          later processing.  pichOffsets will not persist between successive
//          callbacks.  If the callback wants to use the data pointed to by pich
//          it must copy it to its own store
//      cOffsets - number of offsets passed to client (always > 1)
//      lpData - client defined data
//
// Return:
//  TRUE - to abort token enumeration
//  FALSE - to continue
//---------------------------------------------------------------------------
// BOOL
// EnumSummarizationOffsets (
//    IN CONST DWORD *pichOffsets,
//    IN DWORD cOffsets,
//    IN OUT LPARAM lpData);

typedef BOOL (CALLBACK * ENUM_SUMMARIZATION_OFFSETS_CALLBACK)(
    IN CONST DWORD *pichOffsets,
    IN CONST DWORD cOffsets,
    IN OUT LPARAM lpData);

typedef BOOL (CALLBACK * ENUM_SUMMARIZATION_OFFSETS_EX1_CALLBACK)(
    IN CONST DWORD *pichOffsets,
    IN CONST DWORD cOffsets,
    IN PCWSTR pwzPOS,
    IN PCWSTR pwzMCat,
    IN OUT LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumSummarizationOffsets
//
//  Synopsis:  This is the entry point for returning offsets for tokens used
//  in summarization.   These tokens correspond to stems and bound morphemes
//  (fuzokugo) in the text.  A list of offsets (and a count) is sent to the
//  EnumSummarizationOffsets callback (see above)
//
//  Parameters:
//  pwszText - pointer to wide-character text buffer to be tokenized,
//  cchText - count of characters in text buffer,
//  fTokenizeMode - flag describing the callback mode  (see above),
//     pEnumTokOutputProc - pointer to callback procedure handling token
//     enumeration,
//  lpData - client defined data
//
//  Returns:
//      TH_ERROR_SUCCESS - if the call completed successfully
//      TH_ERROR_NOHPBS - if there were no HPBs
//      TH_ERROR_INVALID_INPUT - if the input buffer was bad
//      TH_ERROR_INVALID_CALLBACK - if the input callback was bad
//---------------------------------------------------------------------------
INT
APIENTRY
EnumSummarizationOffsets(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_SUMMARIZATION_OFFSETS_CALLBACK pcbEnumSummarizationOffsets,
    IN LPARAM lpData);

INT
APIENTRY
EnumSummarizationOffsetsEx1(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_SUMMARIZATION_OFFSETS_EX1_CALLBACK pcbEnumSummarizationOffsetsEx1,
    IN LPARAM lpData);

typedef INT (APIENTRY *LP_ENUM_SUMMARIZATION_OFFSETS)(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_SUMMARIZATION_OFFSETS_CALLBACK pcbEnumSummarizationOffsets,
    IN LPARAM lpData);

typedef INT (APIENTRY *LP_ENUM_SUMMARIZATION_OFFSETS_EX1)(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_SUMMARIZATION_OFFSETS_EX1_CALLBACK pcbEnumSummarizationOffsetsEx1,
    IN LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumStemOffsetsCallback
//
//  Synopsis: client-side callback that receives a zero--terminated stem per SPB
//
//  Parameters:
//      pwszStem - zero terminated stem string
//      lpData - client defined data
//
// Return:
//  TRUE - to abort token enumeration
//  FALSE - to continue
//---------------------------------------------------------------------------
// BOOL
// EnumStemOffsetsCallback (
//    IN WCHAR *pwszStem,
//    IN OUT LPARAM lpData);

typedef BOOL (CALLBACK * ENUM_STEM_OFFSETS_CALLBACK)(
    IN CONST DWORD *pichOffsets,
    IN CONST DWORD cOffsets,
    IN OUT LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumStemOffsets
//
//  Synopsis:  This is the entry point for tokenizing stems.  Sends offsets,
//  for stems to the EnumStemOffsets callback (see above)
//
//  Parameters:
//  pwszText - pointer to wide-character text buffer to be tokenized,
//  cchText - count of characters in text buffer,
//  fTokenizeMode - flag describing the callback mode  (see above),
//     pEnumTokOutputProc - pointer to callback procedure handling token
//     enumeration,
//  lpData - client defined data
//
//  Returns:
//      TH_ERROR_SUCCESS - if the call completed successfully
//      TH_ERROR_NOHPBS - if there were no HPBs
//      TH_ERROR_INVALID_INPUT - if the input buffer was bad
//      TH_ERROR_INVALID_CALLBACK - if the input callback was bad
//---------------------------------------------------------------------------
INT
APIENTRY
EnumStemOffsets(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_STEM_OFFSETS_CALLBACK pcbEnumStemOffsets,
    IN OUT DWORD *pcchTextProcessed,
    IN LPARAM lpData);

typedef INT (APIENTRY *LP_ENUM_STEM_OFFSETS)(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_STEM_OFFSETS_CALLBACK pcbEnumStemOffsets,
    IN OUT DWORD *pcchTextProcessed,
    IN LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumStemInfoCallback
//
//  Synopsis: client-side callback that receives offsets and stem information
//
//  Parameters:
//      ichOffset - offset to first character in stem
//      cchLen - length of the stem
//      pwszPOS - string containing POS info
//      pwszMCat - string containing MCat info
//      pwszDictionaryForm - string containing Dictionary Form
//      lpData - client defined data
//
// Return:
//  TRUE - to abort token enumeration
//  FALSE - to continue
//---------------------------------------------------------------------------
// BOOL
// EnumStemInfoCallback (
//    IN CONST DWORD ichOffset,
//    IN CONST DWORD cchLen,
//    IN PCWSTR pwszPOS,
//    IN PCWSTR pwszMCat,
//    IN PCWSTR pwszDictionaryForm,
//    IN OUT LPARAM lpData);

typedef BOOL (CALLBACK * ENUM_STEM_INFO_CALLBACK)(
    IN CONST DWORD ichOffset,
    IN CONST DWORD cchLen,
    IN PCWSTR pwszPOS,
    IN PCWSTR pwszMCat,
    IN PCWSTR pwszDictionaryForm,
    IN OUT LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumStemInfo
//
//  Synopsis:  Call this routine to get information about stems.
//  For example, if you want the dictionary form, part-of-speech or
//  MCat information for a stem, then this is the API for you
//
//  Parameters:
//  pwszText - pointer to wide-character text buffer to be tokenized,
//  cchText - count of characters in text buffer,
//  fTokenizeMode - flag describing the callback mode  (see above),
//  pcbEnumStemInfo - pointer to callback procedure handling stem info
//      enumeration
//  lpData - client defined data
//
//  Returns:
//      TH_ERROR_SUCCESS - if the call completed successfully
//      TH_ERROR_NOHPBS - if there were no HPBs
//      TH_ERROR_INVALID_INPUT - if the input buffer was bad
//      TH_ERROR_INVALID_CALLBACK - if the input callback was bad
//---------------------------------------------------------------------------
INT
APIENTRY
EnumStemInfo(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_STEM_INFO_CALLBACK pcbEnumStemInfo,
    IN OUT DWORD *pcchTextProcessed,
    IN LPARAM lpData);

typedef INT (APIENTRY *LP_ENUM_STEM_INFO)(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_STEM_INFO_CALLBACK pcbEnumStemInfo,
    IN OUT DWORD *pcchTextProcessed,
    IN LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumSentenceOffsetsCallback
//
//  Synopsis: client-side callback that receives a list of offsets for sentence breaks
//
//  Parameters:
//      ichOffsetStart - offset to start of sentence
//      ichOffsetEnd - offset to end of sentence (includes terminating punctuation)
//      lpData - client defined data
//
// Return:
//  TRUE - to abort token enumeration
//  FALSE - to continue
//---------------------------------------------------------------------------
// BOOL
// EnumSentenceOffsetsCallback (
//    IN DWORD ichOffsetStart,
//    IN DWORD ichOffsetEnd,
//    IN OUT LPARAM lpData);

typedef BOOL (CALLBACK * ENUM_SENTENCE_OFFSETS_CALLBACK)(
    IN DWORD ichOffsetStart,
    IN DWORD ichOffsetEnd,
    IN OUT LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumSentenceOffsets
//
//  Synopsis:  This is the main entry point for breaking sentences.
//      Sends offsets delimiting sentences to the callback.
//
//  Parameters:
//  pwszText - pointer to wide-character text buffer to be tokenized,
//  cchText - count of characters in text buffer,
//  fTokenizeMode - not used.  later this will be used to control how
//      partial sentences are handled.
//  pEnumSentenceOffsetsCallback - pointer to callback procedure handling offsets
//  lpData - client defined data
//
//  Returns:
//      TH_ERROR_SUCCESS - if the call completed successfully
//      TH_ERROR_NOHPBS - if there were no HPBs
//      TH_ERROR_INVALID_INPUT - if the input buffer was bad
//      TH_ERROR_INVALID_CALLBACK - if the input callback was bad
//---------------------------------------------------------------------------
INT
APIENTRY
EnumSentenceOffsets(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fTokenizeMode,
    IN ENUM_SENTENCE_OFFSETS_CALLBACK pcbEnumSentenceOffsets,
    IN LPARAM lpData);

typedef INT (APIENTRY *LP_ENUM_SENTENCE_OFFSETS)(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fTokenizeMode,
    IN ENUM_SENTENCE_OFFSETS_CALLBACK pcbEnumSentenceOffsets,
    IN LPARAM lpData);


//+--------------------------------------------------------------------------
//  Routine:    FEMorphCallback
//
//  Synopsis:  The callback that gets a text stream from T-Hammer.
//
//  Parameters:
//      pwszWMorphRecs - a pointer to wide character text stream,
//                   which contains mophological analyses of a given sentence
//      pvData - pointer to private data
//
//  Returns:
//      TRUE if no more analysis is needed
//---------------------------------------------------------------------------
// BOOL
// FEMorphCallback(
//    IN PWSTR pwszMorphRecs);

typedef BOOL (CALLBACK * FEMORPH_CALLBACK)(
    IN PWSTR pwszMorphRecs,
    IN VOID *pvData);

//+--------------------------------------------------------------------------
//  Routine:    FEMorph
//
//  Synopsis:  This is the entry point for NLPWIN morpheme analysis.
//  Sends a morpheme record string back to the lex callback in NLPWIN
//
//  Parameters:
//  pwszText - pointer to wide-character text buffer to be tokenized,
//  pcbFEMorphCB - pointer to callback procedure handling morph rec enumeration
//  pvData - pointer to private data
//
//  Returns:
//---------------------------------------------------------------------------
INT
APIENTRY
FEMorph(
    IN PCWSTR pwszText,
    IN FEMORPH_CALLBACK pcbFEMorphCB,
    IN VOID *pvData);

typedef INT (APIENTRY *LP_FEMORPH)(
    IN PCWSTR pwszText,
    IN FEMORPH_CALLBACK pcbFEMorphCB,
    IN VOID *pvData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht\thammerp.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1994, Microsoft Corporation.  All Rights Reserved.
//
//  File:       thammerp.h
//
//  History:    07-Jun-95   PatHal      Created.
//
//---------------------------------------------------------------------------

#ifndef _THAMMERP_H_
#define  _THAMMERP_H_

// Following values used for setting fMode parameters when calling
// the EnumTokens or Tokenize api.  These are used to control the content
// of the pichOffsets, pwszStem, and pwszToken strings sent to the callback
// procedure.  Note: default is fastest.

// "Selection Chunks" mode is used for Word Smart Selection.  Offsets sent
// to the callback do not necessarily correspond to morphemes boundaries.
// The chunk boundary offsets are encoded in the Japanese morphology
// that exists in T-Hammer as a resource.
#define TOKENIZE_MODE_SELECTION_OFFSETS          0x00000010

// "Stem Chunks" mode is used for Auto Summarization.  Offsets sent
// to the callback correspond to stems (and one containing all bound morphemes)
// LATER!  How should prefixes be handled?  If we remove them from the
// output then the last offset of one call will no longer equal the first offset from
// the next call.
#define TOKENIZE_MODE_STEM_OFFSETS               0x00000020

// " Summarization Stems" mode is used for Auto Summarization.  Output
// is the "stem" portion of the Bunsetsu Phrase.  For example, for Japanese
// "oyogu" the outputted form would be the stem "oyo".
#define TOKENIZE_MODE_SUMMARIZATION_OFFSETS       0x00000040

// "Break Compounds" is a special mode that instructs t-hammer to break
// compound nouns in the stem.  Use this with "Summarization Stems".
// The default is to not break the compounds (i.e. this is off by default).
#define TOKENIZE_MODE_BREAK_COMPOUNDS           0x00000080

// "ChBreak Unknowns" is a special mode that controls tokenization of unknown
// strings.  When set this forces T-Hammer to output unknown stems on a per
// character basis.  By default, this is not set which means that an unknown string
// (for example, a proper name) is outputted as a single contiguous chunk
#define TOKENIZE_MODE_CHBREAK_UNKNOWNS          0x00000100

// "Stem Info" mode is used for Dictionary Form and for obtaining POS and MCat
//  info for all.  Each callback contains one stem.  Prefixes are ignored
#define TOKENIZE_MODE_STEM_INFO               0x00000200

// "Sentence Offsets" mode is used to return sentence breaks - no further
// analysis is performed.  This is useful to segment corpora before adding
// to a test database (e.g. Babble)
#define TOKENIZE_MODE_SENTENCE_OFFSETS               0x00000400

// "Best Break" is the default.  Only the single most
// probable breaks will be output.
#define TOKENIZE_MODE_BEST_BREAK                0x00001000

// "Alternate Breaks" instructs tokenizer to output all possible
// breaks
#define TOKENIZE_MODE_ALTERNATE_BREAKS          0x00020000

// "Bunsetsu Phrases" is a default, too.   Outputs phrase breaks.
// Warning: for a word-tagged corpus, use "Break Morpheme"
#define TOKENIZE_MODE_BUNSETSU_PHRASES          0x00040000

// "Best Tags" is also default.  Outputs only one most probable
// tag for a given segmentation.   Break ambiguity and tag ambiguity are
// orthogonal attributes of the output string, hence you can "or" them together
#define TOKENIZE_MODE_BEST_TAGS                 0x00080000

// "Alternate Tags" instructs tokenizer to output all possible taggings for
// each break.  Warning: for some languages, there will be many more tag
// alternatives than break alternatives, so the output will be quite verbose.
#define TOKENIZE_MODE_ALTERNATE_TAGS            0x00100000

// "Debug" instructs tokenizer to output morpheme label information for
// alternates and tag strings for morphemes
#define TOKENIZE_MODE_VERBOSE                     0x00200000




// "Output DebugLog" is only meaningful useful for debug builds.  Setting
// this flag on and calling debug T-Hammer has the effect that T-Hammer
// outputs verbose tracing information for the morphology and stem analysis
// to a separate file named debug.utf.  CAUTION: this file is typically 500 times
// the size of the source corpus in size, so be forewarned.
#define TOKENIZE_MODE_OUTPUT_DEBUGLOG           0x00800000

// "Disable PL" means the Primary Lexicon will be disabled. This mode is for
// debug purposes only. Retail versions don't have it.
#define TOKENIZE_MODE_DISABLE_PL                0x01000000

// Instrumentation switches for collecting scoring statistics
// First switch is for Postfix Score Info
#define TOKENIZE_MODE_SCOREINFO_POSTFIX           0x02000000
// Second switch is for SPB Scoring Info
#define TOKENIZE_MODE_SCOREINFO_SPB           0x04000000

// Output morpheme records for FE-Morph API
#define TOKENIZE_MODE_MORPHEME_RECORDS          0x10000000

// Output multiple selection analyses for tagging tool
#define TOKENIZE_MODE_SELECTION_OFFSETS_EX      0x20000000

// Output summarization offsets with POS for spelling variant(conversion)
#define TOKENIZE_MODE_SUMMARIZATION_OFFSETS_EX1  0x40000000

// Output words in their dictionary form
#define TOKENIZE_MODE_DICTIONARY_FORM  0x80000000

// Output words in their dictionary form
#define TOKENIZE_MODE_SEPARATE_MORPHEMES  0x00400000

// The EnumPhrases and batch-processing Tokenize api are only used in the debug build


//+--------------------------------------------------------------------------
// defines and typedefs for "Record" subsystem
//---------------------------------------------------------------------------

#define IATTR_NIL  0
#define IATTR_SPB  1
#define IATTR_STEM 2
#define IATTR_POS  3
#define IATTR_MCAT 4
#define IATTR_FT   5
#define IATTR_LT   6

#define TH_NULL_HANDLE (TH_HANDLE)0

typedef UINT TH_HANDLE;

typedef struct tagTH_ATTRVAL
{
    UINT      iAttr; // attribute index
    TH_HANDLE hVal;  // value handle
} TH_ATTRVAL, *PTH_ATTRVAL;

typedef struct tagTH_RECORD
{
    UINT cAttrMax;
    UINT cAttrVals;
    TH_ATTRVAL *pAttrVals; // variable length attribute value array

    UINT cBitMax;
    UINT cBitVals;
    DWORD *pBitVals;  // variable length bit value array
} TH_RECORD, *PTH_RECORD;

typedef enum tagTH_TYPE
{
    TH_TYPE_INT = 1,
    TH_TYPE_STR,
    TH_TYPE_REG,
    // add more here
    TH_TYPE_MAX
} TH_TYPE;

#define TYPEOF(x)  HIWORD(x)
#define INDEXOF(x) LOWORD(x)

// pcai - 6/18/97 Makes it clear for MCat's
//
typedef BYTE MCAT;
#define SV_WORD_LEN_MAX     0x10
#define SV_WORD_IREAD_MAX   SV_WORD_LEN_MAX


//+--------------------------------------------------------------------------
//  Routine:    EnumPhrasesCallback
//
//  Synopsis: Sends delimited output (tokens) to test app callback procedure
//
//  Parameters:
//      pwszToken- pointer to wide character token string,
//      fTokenType - flag describing the types of tag in pwszToken (see above).
//
// Returns:
//  TRUE - to abort token enumeration
//  FALSE - to continue
//---------------------------------------------------------------------------
// BOOL
// EnumPhrasesCallback (
//     PWSTR pwszToken,
//     DWORD fTokenType);

typedef BOOL (CALLBACK * ENUM_PHRASES_CALLBACK)(
    IN PWSTR pwszToken,
    IN DWORD fTokenType,
    IN OUT LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumPhrases (corresponds to mode 4 of tokenize test harness)
//
//  Synopsis:  This is the entry point for tokenizing phrases.  Sends tokenized
//  phrases which can either be offsets or zero-delimited strings to the callback
//  (defined below)
//
//  Parameters:
//  pwszText - pointer to wide-character text buffer to be tokenized,
//  cchText - count of characters in text buffer,
//  fTokenizeMode - flag describing the callback mode  (see above),
//     pEnumTokOutputProc - pointer to callback procedure handling token
//     enumeration,
//  lpData - client defined data
//
//  Returns:
//      TH_ERROR_SUCCESS - if the call completed successfully
//      TH_ERROR_NOHPBS - if there were no HPBs
//      TH_ERROR_INVALID_INPUT - if the input buffer was bad
//      TH_ERROR_INVALID_CALLBACK - if the input callback was bad
//---------------------------------------------------------------------------
INT
APIENTRY
EnumPhrases(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_PHRASES_CALLBACK pcbEnumPhrases,
    IN LPARAM lpData);

typedef INT (APIENTRY *LP_ENUM_PHRASES)(
   IN PCWSTR pwszText,
   IN DWORD cchText,
   IN DWORD fBeginEndHPBMode,
   IN ENUM_PHRASES_CALLBACK pcbEnumPhrases,
   IN LPARAM lpData);

// T-Hammer uses the folg. values to set the fTokenType parameter
// when calling back to EnumTokOutputProc.  The Tokenize test app
// uses this type information to control the comparison to the re-
// tokenized corpus as well as to format the output in general.

// "Phrase" signifies that the the end of the pwszToken string marks a
// phrase boundary.  This is the default.
#define TOKEN_TYPE_PHRASE            0x01

// "Morpheme" signifies an intra-phrase morpheme
// boundary (including the stem).
#define TOKEN_TYPE_MORPHEME     0x02

// "Alternate" signifies that the current pwszToken string is an alternate
// (primary tokens are sent before alternates).
#define TOKEN_TYPE_ALTERNATE    0x04

// "Hard Break" signifies an unambiguous text boundary.
// Note that between punctuation types the output is either all alternate
// or all non-alternate.  Any bitwise OR combination of the following
// types is possible.
#define TOKEN_TYPE_HARDBREAK  0x08

// "Label" means the token should not be used to compare to test corpus,
// but should be output parenthetically (or stored as the morpheme name),
// for example with enclosing parens
#define TOKEN_TYPE_LABEL             0x10

// "Stem" signifies that this morpheme is part of the head which corresponds
// to a "jiritsugo" for Japanese.  This is used for coloring in the tagtool
#define TOKEN_TYPE_STEM             0x20

//+--------------------------------------------------------------------------
//  Routine:    Tokenize
//
//  Synopsis: Internal word-breaker entry point for executing tokenization.
//  Returns array of delimited offsets in pibBreaks
//
//  Parameters:
//  pwszText - pointer to wide-character text buffer to be tokenized,
//  cchText - count of characters in text buffer,
//  pichBreaks - pointer to return buffer, which is filled with delimiter (breaks) offset information
//  pcBreaks - size of previous buffer; number of actual breaks used is returned
//
//  Returns:
//       TH_ERROR_SUCCESS - if the call completed successfully
//       TH_ERROR_INVALID_INPUT - if the input buffer was bad
//       TH_ERROR_INVALID_CALLBACK - if the input callback was bad
//
//  Note: Tokenize will never fail with NOHPBs, since it assumes that
//  the beginning and ends are HPBs
//
//  Notes:
//      Like lstrlen, this function try/excepts on the input buffer and returns FALSE when an exception
//      involving invalid memory dereferencing.
//
//  Open Issue:
//  1.  Do we need to change the name of this API?  "Tokenize" is a generic
//       name - maybe we should save it for a more general-purpose API.
//---------------------------------------------------------------------------
INT
APIENTRY
Tokenize(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fTokenizeMode,
    OUT PDWORD pichBreaks,
    IN OUT PDWORD cBreaks);

typedef DWORD (APIENTRY *LP_TOKENIZE)(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fTokenizeMode,
    OUT PDWORD pichBreaks,
    IN OUT PDWORD cBreaks);

//+--------------------------------------------------------------------------
//  Routine:    EnumSummarizationOffsetsEx
//
//  Temporary private entry point to overload Summarization and get back the
//  number of cch procesed.  Please refer to EnumSummarizationOffsets (thammer.h)
//  for details
//---------------------------------------------------------------------------
INT
APIENTRY
EnumSummarizationOffsetsEx(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_SUMMARIZATION_OFFSETS_CALLBACK pcbEnumSummarizationOffsets,
    IN OUT DWORD *pcchTextProcessed,
    IN LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumSelectionOffsetsExCallback
//
//  Synopsis: same as EnumSelectionOffsetsCallback with an added parameter
//  that allows mutliple analyses to be sent back to client
//
//  Parameters:
//      ...
//      fInfo - dword bit mask that contains info on whether an analysis is primary
//              and/or spb initial
//      ...
//---------------------------------------------------------------------------
// BOOL
// EnumSelectionOffsetsExCallback (
//    IN CONST DWORD *pichOffsets,
//    IN DWORD cOffsets,
//    IN DWORD fInfo,
//    IN OUT LPARAM lpData);

#define SELN_OFFSETS_INFO_PRIMARY    0x00000001
#define SELN_OFFSETS_INFO_SPB_END    0x00000002

typedef BOOL (CALLBACK * ENUM_SELECTION_OFFSETS_EX_CALLBACK)(
    IN CONST DWORD *pichOffsets,
    IN CONST DWORD cOffsets,
    IN CONST DWORD fInfo,
    IN OUT LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:    EnumSelectionOffsetsEx
//
//  Synopsis:  Same as EnumSelectionOffsets, but takes an "extended" callback
//   (see above for details)
//---------------------------------------------------------------------------
INT
APIENTRY
EnumSelectionOffsetsEx(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_SELECTION_OFFSETS_EX_CALLBACK pcbEnumSelectionOffsetsEx,
    IN LPARAM lpData);

typedef INT (APIENTRY *LP_ENUM_SELECTION_OFFSETS_EX)(
    IN PCWSTR pwszText,
    IN DWORD cchText,
    IN DWORD fBeginEndHPBMode,
    IN ENUM_SELECTION_OFFSETS_EX_CALLBACK pcbEnumSelectionOffsetsEx,
    IN LPARAM lpData);

//+--------------------------------------------------------------------------
//  Routine:  EnumSPBRecordsCallback
//
//  Synopsis:
//
//  Parameters:
//      pRec - points to an array of TH_RECORDs
//      cRec - number of TH_RECORD structs in the pRec[] array
//      iScoreIPL - well-formedness score of the given sentence.
//      pvData - points to client defined data
//
//  Returns:
//---------------------------------------------------------------------------
// BOOL
// EnumSPBRecordsCallback(
//    IN PTH_RECORD pRec,
//    IN DWORD cRec,
//    IN DWORD dwFlags,
//    IN DWORD iScoreIPL,
//    IN PVOID pvData);

#define SPBRECS_SENTEDGE 0x00000001

typedef BOOL (CALLBACK * ENUM_SPB_RECORD_CALLBACK)(
    IN PTH_RECORD pRec,
    IN DWORD cRec,
    IN DWORD dwFlags,
    IN DWORD iScoreIPL,
    IN PVOID pvData);

//+--------------------------------------------------------------------------
//  Routine:  EnumSPBRecords
//
//  Synopsis: 
//
//  Parameters:
//      pwszText - points to a sentence to analyze
//      pcbEnumSPBRecordsCB - callback function pointer.
//      lpData - points to client defined data
//
//  Returns:
//---------------------------------------------------------------------------
INT APIENTRY
EnumSPBRecords(
    IN PCWSTR pwszText,
    IN DWORD fMode,               // for TOKENIZE_MODE_DICTIONARY_FORM
    IN ENUM_SPB_RECORD_CALLBACK pcbEnumSPBRecordsCB,
    IN PVOID pvData);

typedef INT (APIENTRY *LP_ENUM_SPB_RECORDS)(
    IN PCWSTR pwszText,
    IN DWORD fMode,               // for TOKENIZE_MODE_DICTIONARY_FORM
    IN ENUM_SPB_RECORD_CALLBACK pcbEnumSPBRecordsCB,
    IN PVOID pvData);


PCWSTR
GetStringVal(
    TH_HANDLE hVal);

typedef PCWSTR (APIENTRY *LP_GET_STRING_VAL)(
    TH_HANDLE hVal);

DWORD
GetIntegerVal(
    TH_HANDLE hVal);

typedef DWORD (APIENTRY *LP_GET_INTEGER_VAL)(
    TH_HANDLE hVal);

TH_HANDLE
GetAttr(
    const PTH_RECORD pRec,
    UINT iAttr);

typedef TH_HANDLE (APIENTRY *LP_GET_ATTR) (
    const PTH_RECORD pRec,
    UINT iAttr);

//+--------------------------------------------------------------------------
//  Routine:  FxCallback
//
//  Synopsis:
//
//  Parameters:
//
//  Returns:
//---------------------------------------------------------------------------
// BOOL WINAPI
// FxCallback(
//    DWORD iFilter,
//    WCHAR *pwzFilter,
//    DWORD cRec,
//    TH_RECORD *pRec,
//    VOID *pvData);
//
typedef BOOL (WINAPI *LP_FXCB)(
    IN DWORD iFilter,
    IN WCHAR *pwzFilter,
    DWORD cRec,
    TH_RECORD *pRec,
    IN VOID *pvData);

//+--------------------------------------------------------------------------
//  Routine:  Fx
//
//  Synopsis:
//
//  Parameters:
//
//  Returns:
//---------------------------------------------------------------------------
BOOL WINAPI
Fx(
    IN PVOID *ppvFilter,
    IN DWORD cFilter,
    IN PCWSTR pwzPhrase,
    IN LP_FXCB pfnFxCallback,
    IN PVOID pvData);

typedef BOOL (WINAPI *LP_FX)(
    IN PVOID *ppvFilter,
    IN DWORD cFilter,
    IN PCWSTR pwzPhrase,
    IN LP_FXCB pfnFxCallback,
    IN PVOID pvData);

// SV-related structs and functions

//+--------------------------------------------------------------------------
//  Structure:  SV_INFO
//
//  Synopsis:   This structure is used by the SVAPI functions.
//
//---------------------------------------------------------------------------
typedef struct _SVINFO
{
    unsigned sid   : 18;        // sense id
    unsigned svid  : 6;         // id for spelling variant
    unsigned cRead : 8;         // # of elements in the reading chain for this sid
    BYTE bIPL;                  // IPL of this spelling variant
    MCAT mcat;                  // index of MCat

    // array of reading indices for the sid
    // if awRead[i] < READING_BASE, it represents a kana
    // otherwise, (awRead[i] - READING_BASE) is the
    // index into the reading table
    WORD aiwRead[SV_WORD_IREAD_MAX];

} SV_INFO;

//+--------------------------------------------------------------------------
//  Routine:  SVFindSid
//
//  Fill SV_INFO structure by searching for pwzWord in the SV-lexicon.
//  This routine is called in order to normalize/convert/reconvert
//  a word to its matching sense id(s).  This routine returns one or more
//  SV_INFO records, each being a match to the word.
//
//  Parameters: pwzWord = pointer to word for which an sid is needed
//              pwzMcat = MCat string.
//                        If pwzMcat is not valid , search for the best sid
//                        in all MCat's.
//              asvi    = array of SV_INFO for receiving sid, svid
//                        and reading indices
//                          (must be pre-allocated by the caller)
//              csviMax    = Max # of matches desired.
//                        SVFINDSID_GET_FIRST: only the first match
//                        SVFINDSID_GET_BEST: only the best match(lowest IPL)
//                        Otherwise, the first bMax matches.
//
//  Returns:    SVFINDSID_RET_NONE - no matches are found
//              otherwise returns the number of matches returned in asvi
//
//---------------------------------------------------------------------------
DWORD APIENTRY
SV_FindSid(
        IN CONST WCHAR *pwzWord,
        IN CONST WCHAR *pwzMcat,
    IN OUT SV_INFO *asvi,
    IN DWORD csviMax);

typedef DWORD (APIENTRY *LP_SV_FINDSID) (
        IN CONST WCHAR *pwzWord,
        IN CONST WCHAR *pwzMcat,
        IN OUT SV_INFO *asvi,
    IN DWORD csviMax);

//+--------------------------------------------------------------------------
//  Routine:  SVFindSid
//
//  Get sv orthography given SV_INFO structure.
//
//  Parameters: pwzWord = pointer to word for receiving the sv's orthography
//                          (must be pre-allocated by the caller)
//              psvi    = pointer to SV_INFO for receiving return information
//                          (must contain meaningful information)
//
//  Returns:    TRUE - successful
//              FALSE - unsuccessful
//---------------------------------------------------------------------------
BOOL APIENTRY
SV_GetOrtho(
        IN SV_INFO *psvi,
        IN OUT WCHAR *pwzOrtho);

typedef BOOL (APIENTRY *LP_SV_GETORTHO) (
        IN SV_INFO *psvi,
        IN OUT WCHAR *pwzOrtho);

//+--------------------------------------------------------------------------
//  Routine:  TurnOn_FindSVStems
//
//  Synopsis:   Turn on the flag for using FindSVStems().
//
//  Parameters: none
//
//  Returns:    none
//---------------------------------------------------------------------------
BOOL APIENTRY SV_EnableFindSVStems();

typedef VOID (APIENTRY *LP_SV_ENABLE_FINDSVSTEMS) ();

#define SVID_ALL_KANJI          0
#define SVID_ALL_KANA           1

#define SV_FINDSID_GET_FIRST 1
#define SV_FINDSID_GET_BEST  0xFFFFFFFF

// SVFindSid's return values
#define SV_FINDSID_RET_NONE  0
#define SV_FINDSID_ERROR     0xFFFFFFFF

#endif // _THAMMERP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht\register.cxx ===
//+---------------------------------------------------------------------------
//
// Copyright (C) 1998 - 1999, Microsoft Corporation.
//
// File:        Register.cxx
//
// Contents:    Self-registration for Word Breaker /Stemmer.
//
// Functions:   DllRegisterServer, DllUnregisterServer
//
// History:     12-Jan-98       Weibz       Created
//              08-Jan-99       AlanW       Modified to use langreg.hxx
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "langreg.hxx"

//
// Registry constants
//

SLangRegistry const LangResource = {
    L"Chinese_Traditional",
    1028,
    {   L"{954F1760-C1BC-11D0-9692-00A0C908146E}",
        L"Chinese_Traditional Word Breaker",
        L"chtbrkr.dll", L"Both" },

    {   L"{969927E0-C1BC-11D0-9692-00A0C908146E}",
        L"Chinese_Traditional Stemmer",
        L"chtbrkr.dll", L"Both" }
};


//+---------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Self-registration
//
//  History:    12-Jan-98       Weibz       Created 
//
//----------------------------------------------------------------------------

STDAPI DllUnregisterServer()
{
    long dwErr = UnRegisterALanguageResource( LangResource );
    if ( ERROR_SUCCESS != dwErr )
        return S_FALSE;

    return S_OK;
} //DllUnregisterServer

//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Self-registration
//
//  History:    12-Jan-98       Weibz       Created
//
//----------------------------------------------------------------------------

STDAPI DllRegisterServer()
{
    //
    // Register classes
    //

    long dwErr = RegisterALanguageResource( LangResource );

    if ( ERROR_SUCCESS != dwErr )
        return SELFREG_E_CLASS;

    return S_OK;
} //DllRegisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht2\srcs\baselex.h ===
#ifdef _BASE_LEX_
#else
#define _BASE_LEX_

#define ATTR_DM             0x01
#define ATTR_COMPOUND       0x02
#define ATTR_RULE_WORD      0x04
#define ATTR_EUDP_WORD      0x08
#define ATTR_ERROR_WORD     0x10

#define MAX_CHAR_PER_WORD   10

#define CHT_UNICODE_BEGIN   0x4E00
#define CHT_UNICODE_END     0x9FA5

#define MAX_CHAR_PER_WORD    10

#define APLEXICON_COUNT       1000

typedef struct tagSLexHeader {
    DWORD dwMaxCharPerWord;
    DWORD dwWordNumber[MAX_CHAR_PER_WORD];
} SLexHeader, *PSLexHeader;

class CBaseLex {
public:
    virtual BOOL GetWordInfo(LPCWSTR lpcwString, DWORD dwLength,
        PWORD pwAttrib) = 0;
};
typedef CBaseLex* PCBaseLex; 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht2\srcs\chtbrkr.cpp ===
#include <windows.h>
#include "lexicon.h"
#include "rulelex.h"
#include "LexMgr.h"
#include "CHTBrKr.h"
#include "BaseLex.h"


CCHTWordBreaker::CCHTWordBreaker(void)
{
    m_pcLexicon = NULL;
    m_ppWordLattice = NULL;
    m_pdwCandidateNumber = NULL;
    m_dwSentenceLength = 0;
    m_dwLatticeLength = 0;
    m_pdwMaxWordLength = NULL;
    m_psBreakResult = NULL;
	m_pcRuleLex = NULL;
}
    
CCHTWordBreaker::~CCHTWordBreaker(void)
{
    DWORD i;

    if (m_pcLexicon) {
        delete m_pcLexicon;
        m_pcLexicon = NULL;
    }
    if (m_ppWordLattice) {
        for (i = 0; i < m_dwSentenceLength; ++i) {
            if (m_ppWordLattice[i]) {
                delete m_ppWordLattice[i];
            }
        }
        delete m_ppWordLattice;
        m_ppWordLattice = NULL;
    }
    if (m_pdwCandidateNumber) {
        delete m_pdwCandidateNumber;
        m_pdwCandidateNumber = NULL;
    }
    if (m_pdwMaxWordLength) {
        delete m_pdwMaxWordLength;
        m_pdwMaxWordLength = NULL;
    }
    if (m_psBreakResult) {
        if (m_psBreakResult->puWordLen) {
            delete m_psBreakResult->puWordLen;
        }
        if (m_psBreakResult->pbTerminalCode) {
            delete m_psBreakResult->pbTerminalCode;
        }
        if (m_psBreakResult->puWordAttrib) {
            delete m_psBreakResult->puWordAttrib;
        }
    }
    m_dwSentenceLength = 0;
    m_dwLatticeLength = 0;
}

BOOL CCHTWordBreaker::AllocLattice(
    DWORD dwLength)
{
    BOOL fRet = FALSE;
    DWORD i;

    m_pdwMaxWordLength= new DWORD[dwLength];
    if (!m_pdwMaxWordLength) { goto _exit; }

    m_pdwCandidateNumber = new DWORD[dwLength];
    if (!m_pdwCandidateNumber) { goto _exit; }
     
    m_ppWordLattice = new PSLatticeNode[dwLength];
    if (!m_ppWordLattice) { goto _exit; }
    for (i = 0; i < dwLength; ++i) {
        m_ppWordLattice[i] = NULL;
    }
    for (i = 0; i < dwLength; ++i) {
        m_ppWordLattice[i] = new SLatticeNode[MAX_CHAR_PER_WORD];
        if (!m_ppWordLattice[i]) { goto _exit; }
        m_pdwCandidateNumber[i] = 0;
    }
    m_dwLatticeLength = dwLength;
    fRet = TRUE;
_exit:
    if (!fRet) {
        DestroyLattice();
    }        
    return fRet;
}

void CCHTWordBreaker::DestroyLattice()
{
    DWORD i;

    if (m_pdwCandidateNumber) {
        delete m_pdwCandidateNumber;
        m_pdwCandidateNumber = NULL;
    }
    if (m_pdwMaxWordLength) {
        delete m_pdwMaxWordLength; 
        m_pdwMaxWordLength = NULL;
    }
    if (m_ppWordLattice) {
        for (i = 0; i < m_dwLatticeLength; ++i) {
            if (m_ppWordLattice[i]) {
                delete m_ppWordLattice[i];
            } 
        }
        m_ppWordLattice = NULL;
        m_dwLatticeLength = 0;
    }
}


BOOL CCHTWordBreaker::InitData(
    HINSTANCE hInstance) 
{
    BOOL fRet = FALSE;

    m_pcLexicon = new CCHTLexicon;
    if (!m_pcLexicon) { goto _exit; }
    fRet = m_pcLexicon->InitData(hInstance);
    if (!fRet) { goto _exit; }

    m_pcRuleLex = new CRuleLexicon;
    if (!m_pcRuleLex)  { goto _exit; }

    m_psBreakResult = new SBreakResult;
    if (!m_psBreakResult) { goto _exit; }
	FillMemory(m_psBreakResult, sizeof(SBreakResult), 0);
    m_psBreakResult->puWordLen = new UINT[LATTICE_LENGHT];
    m_psBreakResult->pbTerminalCode = new BYTE[LATTICE_LENGHT];
    m_psBreakResult->puWordAttrib = new UINT[LATTICE_LENGHT];
    if (!AllocLattice(LATTICE_LENGHT)) { goto _exit; }  
    fRet = TRUE;
_exit:
    if (!fRet) {
        if (m_pcLexicon) { 
            delete m_pcLexicon;
            m_pcLexicon = NULL;
        }
        if (m_pcRuleLex) {
            delete m_pcRuleLex;
            m_pcRuleLex = NULL;
        }
        if (m_psBreakResult) {
            if (m_psBreakResult->puWordLen) {
                delete m_psBreakResult->puWordLen;
            }
            if (m_psBreakResult->pbTerminalCode) {
                delete m_psBreakResult->pbTerminalCode;
            }
            if (m_psBreakResult->puWordAttrib) {
                delete m_psBreakResult->puWordAttrib;
            }
            m_psBreakResult = NULL;  
        }
        DestroyLattice();
    }
    return fRet;
}

BOOL CCHTWordBreaker::LatticeGrow(
    DWORD dwNewLength)
{
    BOOL fRet = FALSE;

    if (dwNewLength <= m_dwLatticeLength) { 
        fRet = TRUE;
        goto _exit;
    }
    DestroyLattice();
    if (AllocLattice(dwNewLength)) {
        fRet = TRUE;
    } else {
        AllocLattice(LATTICE_LENGHT);
    }
    if (m_psBreakResult) {
        if (m_psBreakResult->puWordLen) {
            delete m_psBreakResult->puWordLen;
        }
        if (m_psBreakResult->pbTerminalCode) {
            delete m_psBreakResult->pbTerminalCode;
        }
        if (m_psBreakResult->puWordAttrib) {
            delete m_psBreakResult->puWordAttrib;
        }
        m_psBreakResult->puWordLen = new UINT[dwNewLength];
        m_psBreakResult->pbTerminalCode = new BYTE[dwNewLength];
        m_psBreakResult->puWordAttrib  = new UINT[dwNewLength];
    }

_exit:
    return fRet;
}

DWORD CCHTWordBreaker::BreakText(
    LPCWSTR   lpcwszText,
    INT       nTextLen,
    CBaseLex* pcBaseLex,
    DWORD     dwMaxWordLen,
    BOOL      fBreakWithParser)
{
    m_psBreakResult->dwWordNumber = 0;

    if (!LatticeGrow(nTextLen)) { goto _exit; }

    if (BuildLattice(lpcwszText, nTextLen, pcBaseLex, dwMaxWordLen)) {
        GetResult();
        // process Surrogate Char begin
/*
	    INT nCurrentIndex;
        DWORD dwSurIndex;
        nCurrentIndex = 0;
        for (dwSurIndex = 0; dwSurIndex < m_psBreakResult->dwWordNumber; ++dwSurIndex) {
            if (m_psBreakResult->puWordLen[dwSurIndex] == 1) { // High word of surrogate char should be breaked into signal char word
                if (lpcwszText[nCurrentIndex] >= 0xd800 && lpcwszText[nCurrentIndex] <= 0xdbff) { // High word is 
				    if (nCurrentIndex >= nTextLen - 1) { // Should be an error
                    } else if (lpcwszText[nCurrentIndex + 1] >= 0xdc00 && lpcwszText[nCurrentIndex + 1] <= 0xdfff) { // Is surrogate char
				        DWORD dwMoveDataNum;
                        dwMoveDataNum = m_psBreakResult->dwWordNumber - (dwSurIndex + 1 + 1);
					    m_psBreakResult->puWordLen[dwSurIndex] = 2;
                        CopyMemory(&(m_psBreakResult->puWordLen[dwSurIndex + 1]), &(m_psBreakResult->puWordLen[dwSurIndex + 1 + 1]), dwMoveDataNum * sizeof(UINT));
                        CopyMemory(&(m_psBreakResult->pbTerminalCode[dwSurIndex + 1]), &(m_psBreakResult->pbTerminalCode[dwSurIndex + 1 + 1]), dwMoveDataNum * sizeof(BYTE));
                        CopyMemory(&(m_psBreakResult->puWordAttrib[dwSurIndex + 1]), &(m_psBreakResult->puWordAttrib[dwSurIndex + 1 + 1]), dwMoveDataNum * sizeof(UINT));
                        m_psBreakResult->dwWordNumber -= 1;
					    //nCurrentIndex -= 1;
                    } else {// Should be an error
                    }
                }
            }
            nCurrentIndex += m_psBreakResult->puWordLen[dwSurIndex];
        } */
        // process Surrogate Char end

        if (fBreakWithParser) {
#ifdef PARSER
            DWORD i, dwBeginIndex, dwParseLen;
		    PWORD pwTerminalCode;
            pwTerminalCode = NULL;
            dwParseLen = 0;
            pwTerminalCode = new WORD[m_psBreakResult->dwWordNumber];
            MultiByteToWideChar(950, MB_PRECOMPOSED, (const char *)m_psBreakResult->pbTerminalCode, 
			    m_psBreakResult->dwWordNumber, pwTerminalCode, m_psBreakResult->dwWordNumber); 
            for (dwBeginIndex = 0; dwBeginIndex < m_psBreakResult->dwWordNumber; dwBeginIndex += 1) {
                if (m_psBreakResult->pbTerminalCode[dwBeginIndex] == ' ') { continue; }
                for (dwParseLen = 1; dwBeginIndex + dwParseLen < m_psBreakResult->dwWordNumber; ++dwParseLen) {
                    if (m_psBreakResult->pbTerminalCode[dwBeginIndex + dwParseLen] == ' ') {
                        break;
                    }
                }
                for ( ; dwParseLen > 1; --dwParseLen) {
                    if (m_pcRuleLex->IsAWord(&pwTerminalCode[dwBeginIndex], dwParseLen)) {
                        break;
                    } 
                }
                if (dwParseLen > 1) { // adjust break result
                    for (i = 1; i < dwParseLen; ++i) {      
                        m_psBreakResult->puWordLen[dwBeginIndex] += m_psBreakResult->puWordLen[dwBeginIndex + i];
                    }
                    m_psBreakResult->puWordAttrib[dwBeginIndex] = ATTR_RULE_WORD;
                    DWORD dwMoveDataNum;
                    dwMoveDataNum = m_psBreakResult->dwWordNumber - (dwBeginIndex + dwParseLen);
                    CopyMemory(&(m_psBreakResult->puWordLen[dwBeginIndex + 1]),
                        &(m_psBreakResult->puWordLen[dwBeginIndex + dwParseLen]),
                        dwMoveDataNum * sizeof(UINT));
                    CopyMemory(&(m_psBreakResult->pbTerminalCode[dwBeginIndex + 1]),
                        &(m_psBreakResult->pbTerminalCode[dwBeginIndex + dwParseLen]),
                        dwMoveDataNum * sizeof(BYTE));
                    CopyMemory(&(m_psBreakResult->puWordAttrib[dwBeginIndex + 1]),
                        &(m_psBreakResult->puWordAttrib[dwBeginIndex + dwParseLen]),
                        dwMoveDataNum * sizeof(UINT));
                    m_psBreakResult->dwWordNumber -= (dwParseLen - 1);
                }
            }
		    if (pwTerminalCode) {
		        delete [] pwTerminalCode;
            }
#endif
        }// if support parser
    } // if build lattice success

_exit:
    return m_psBreakResult->dwWordNumber;
}

DWORD CCHTWordBreaker::GetResult(void)
{
    DWORD dwRet = 0;
    DWORD dwLen = 0;
    SLocalPath sLocalPath[2];
    UINT  uBestIndex = 0, uCandIndex, uLocalPathIndex;
    DWORD dw2ndIndex, dw3rdIndex;
    DWORD i, j, k;


    m_psBreakResult->dwWordNumber = 0;

    uCandIndex = (uBestIndex + 1) % 2;    
    
    while (dwLen < m_dwSentenceLength) {
        uLocalPathIndex = 0;
        if (m_pdwCandidateNumber[dwLen] == 1) {
            sLocalPath[uBestIndex].dwLength[0] = 1;
            sLocalPath[uBestIndex].bTerminalCode[0] = m_ppWordLattice[dwLen][0].bTerminalCode;
            sLocalPath[uBestIndex].wAttribute[0] = m_ppWordLattice[dwLen][0].wAttr;
        } else {
            FillMemory(&sLocalPath[uBestIndex], sizeof(SLocalPath), 0);
            for (i = 0; i < m_pdwCandidateNumber[dwLen]; ++i) {
                FillMemory(&sLocalPath[uCandIndex], sizeof(SLocalPath), 0);
                ++sLocalPath[uCandIndex].uStep;
                sLocalPath[uCandIndex].dwLength[uLocalPathIndex] = m_ppWordLattice[dwLen][i].uLen;
                sLocalPath[uCandIndex].wUnicount[uLocalPathIndex] = m_ppWordLattice[dwLen][i].wCount;
                sLocalPath[uCandIndex].wAttribute[uLocalPathIndex] = m_ppWordLattice[dwLen][i].wAttr;
                sLocalPath[uCandIndex].bTerminalCode[uLocalPathIndex++] = m_ppWordLattice[dwLen][i].bTerminalCode;
                dw2ndIndex = dwLen + m_ppWordLattice[dwLen][i].uLen; 
                if (dw2ndIndex < m_dwSentenceLength) {
                    for (j = 0; j < m_pdwCandidateNumber[dw2ndIndex]; ++j) {
                        ++sLocalPath[uCandIndex].uStep;
                        sLocalPath[uCandIndex].dwLength[uLocalPathIndex] = m_ppWordLattice[dw2ndIndex][j].uLen;
                        sLocalPath[uCandIndex].wUnicount[uLocalPathIndex] = m_ppWordLattice[dw2ndIndex][j].wCount;
                        sLocalPath[uCandIndex].wAttribute[uLocalPathIndex] = m_ppWordLattice[dw2ndIndex][j].wAttr;
                        sLocalPath[uCandIndex].bTerminalCode[uLocalPathIndex++] = m_ppWordLattice[dw2ndIndex][j].bTerminalCode;
                        dw3rdIndex = dw2ndIndex + m_ppWordLattice[dw2ndIndex][j].uLen;
                        if (dw3rdIndex < m_dwSentenceLength) {
                            for (k = 0; k < m_pdwCandidateNumber[dw3rdIndex]; ++k) {
                                ++sLocalPath[uCandIndex].uStep;
                                sLocalPath[uCandIndex].dwLength[uLocalPathIndex] = m_ppWordLattice[dw3rdIndex][k].uLen;
                                sLocalPath[uCandIndex].wUnicount[uLocalPathIndex] = m_ppWordLattice[dw3rdIndex][k].wCount;
                                sLocalPath[uCandIndex].wAttribute[uLocalPathIndex] = m_ppWordLattice[dw3rdIndex][k].wAttr;
                                sLocalPath[uCandIndex].bTerminalCode[uLocalPathIndex++] = m_ppWordLattice[dw3rdIndex][k].bTerminalCode;
                                GetScore(&(sLocalPath[uCandIndex])); 
                                if (CompareScore(&(sLocalPath[uCandIndex]), &(sLocalPath[uBestIndex])) > 0) {
                                    CopyMemory(&sLocalPath[uBestIndex], &sLocalPath[uCandIndex], sizeof(SLocalPath));
                                }
                                --uLocalPathIndex;
                                --sLocalPath[uCandIndex].uStep;
                            }
                        } else {
                            GetScore(&(sLocalPath[uCandIndex])); 
                            if (CompareScore(&(sLocalPath[uCandIndex]), &(sLocalPath[uBestIndex])) > 0) {
                                CopyMemory(&sLocalPath[uBestIndex], &sLocalPath[uCandIndex], sizeof(SLocalPath));
                            }
                        }
                        --uLocalPathIndex;
                        --sLocalPath[uCandIndex].uStep;
                    }
                } else {
                    GetScore(&(sLocalPath[uCandIndex])); 
                    if (CompareScore(&(sLocalPath[uCandIndex]), &(sLocalPath[uBestIndex])) > 0) {
                        CopyMemory(&sLocalPath[uBestIndex], &sLocalPath[uCandIndex], sizeof(SLocalPath));
                    }
                }
                --uLocalPathIndex;
                --sLocalPath[uCandIndex].uStep;
            }
        }
        m_psBreakResult->puWordLen[m_psBreakResult->dwWordNumber] = sLocalPath[uBestIndex].dwLength[0];
        m_psBreakResult->pbTerminalCode[m_psBreakResult->dwWordNumber] = sLocalPath[uBestIndex].bTerminalCode[0];
        m_psBreakResult->puWordAttrib[m_psBreakResult->dwWordNumber] = sLocalPath[uBestIndex].wAttribute[0];
        ++m_psBreakResult->dwWordNumber;
        dwLen += sLocalPath[uBestIndex].dwLength[0];
    }

    return m_psBreakResult->dwWordNumber;
}

INT CCHTWordBreaker::CompareScore(
    PSLocalPath psLocalPath1,
    PSLocalPath psLocalPath2)
{
    if (psLocalPath1->uPathLength > psLocalPath2->uPathLength) {
        return 1;
    } else if (psLocalPath1->uPathLength < psLocalPath2->uPathLength) {
        return -1;
    } else if (psLocalPath1->uStep < psLocalPath2->uStep) {
        return 1;
    } else if (psLocalPath1->uStep > psLocalPath2->uStep) {
        return -1;
    } else {
    }

    if (psLocalPath1->fVariance > psLocalPath2->fVariance) {
        return -1;
    } 
    if (psLocalPath1->fVariance < psLocalPath2->fVariance) {
        return 1;
    } 
    if (psLocalPath1->uCompoundNum > psLocalPath2->uCompoundNum) {
        return -1;
    } 
    if (psLocalPath1->uCompoundNum < psLocalPath2->uCompoundNum) {
        return 1;
    } 
    if (psLocalPath1->uDMNum > psLocalPath2->uDMNum) {
        return -1;
    } 
    if (psLocalPath1->uDMNum < psLocalPath2->uDMNum) {
        return 1;
    } 
    if (psLocalPath1->wUniCountSum > psLocalPath2->wUniCountSum) {
        return 1;
    } 
    if (psLocalPath1->wUniCountSum < psLocalPath2->wUniCountSum) {
        return -1;
    } 
    return 0;
}

void CCHTWordBreaker::GetScore(
    PSLocalPath psLocalPath)
{
    UINT i;
    double fAverageSum;

    psLocalPath->uCompoundNum = 0;
    psLocalPath->uDMNum = 0;
    psLocalPath->uPathLength = 0;
    psLocalPath->fVariance = 0;
    psLocalPath->wUniCountSum = 0;

    for (i = 0; i < psLocalPath->uStep; ++i) {
        if (psLocalPath->wAttribute[i] & ATTR_COMPOUND) {
            psLocalPath->uCompoundNum++;    
        }
        if (psLocalPath->wAttribute[i] & ATTR_DM) {
            psLocalPath->uDMNum++;        
        }
        psLocalPath->uPathLength += psLocalPath->dwLength[i];
        psLocalPath->wUniCountSum += psLocalPath->wUnicount[i];
    }
    fAverageSum = (double)psLocalPath->uPathLength / psLocalPath->uStep; 
    for (i = 0; i < psLocalPath->uStep; ++i) {
        if (fAverageSum > psLocalPath->dwLength[i]) {
            psLocalPath->fVariance += (fAverageSum - psLocalPath->dwLength[i]);         
        } else {
            psLocalPath->fVariance += (psLocalPath->dwLength[i] - fAverageSum);    
        }
    }
}

         
BOOL CCHTWordBreaker::BuildLattice(
    LPCWSTR   lpcwszText,
    DWORD     dwTextLen,
    CBaseLex* pcBaseLex,
    DWORD     dwMaxWordLen)
{ 
    DWORD i, j;

    FillMemory(m_pdwCandidateNumber, sizeof(DWORD) * dwTextLen, 0);
    // we should use head link
    for (i = 0; i < dwTextLen; ++i) {
        m_pdwMaxWordLength[i] = 1;
        for (j = i; (j - i + 1) <= dwMaxWordLen && j < dwTextLen; ++j) {
            if (m_pcLexicon->GetWordInfo(&lpcwszText[i], (j - i + 1), 
                &(m_ppWordLattice[i][m_pdwCandidateNumber[i]].wCount),
                &(m_ppWordLattice[i][m_pdwCandidateNumber[i]].wAttr),
                &(m_ppWordLattice[i][m_pdwCandidateNumber[i]].bTerminalCode))) { 
                m_ppWordLattice[i][m_pdwCandidateNumber[i]++].uLen = (j - i + 1);
                if (j - i + 1 > m_pdwMaxWordLength[i]) {
                    m_pdwMaxWordLength[i] = j - i + 1 ;
                }
            } else if (pcBaseLex && pcBaseLex->GetWordInfo(&lpcwszText[i], (j - i + 1), 
                &(m_ppWordLattice[i][m_pdwCandidateNumber[i]].wAttr))) {
                m_ppWordLattice[i][m_pdwCandidateNumber[i]].wCount = APLEXICON_COUNT;
                m_ppWordLattice[i][m_pdwCandidateNumber[i]].bTerminalCode = ' ';
                m_ppWordLattice[i][m_pdwCandidateNumber[i]++].uLen = (j - i + 1);
                if (j - i + 1 > m_pdwMaxWordLength[i]) {
                    m_pdwMaxWordLength[i] = j - i + 1 ;
                }
            } else {
            }
        }
        if (!m_pdwCandidateNumber[i]) {
            m_ppWordLattice[i][0].uLen = 1;
            m_ppWordLattice[i][0].wCount = 0;
            m_ppWordLattice[i][0].wAttr = 0;
            m_ppWordLattice[i][0].fVariance = 0;
            m_ppWordLattice[i][0].bTerminalCode = ' ';
            ++m_pdwCandidateNumber[i];
        }
    }
    m_dwSentenceLength = dwTextLen;
    return TRUE;
}
/*
DWORD CCHTWordBreaker::LongestRuleWord(
    DWORD dwIndex)
{
    DWORD dwRet = 0, i;
    
    for (i = 0; i < m_pdwCandidateNumber[dwIndex]; ++i) {
        if (m_ppWordLattice[dwIndex][i].bAttr & ATTR_RULE_WORD) {
            if (m_ppWordLattice[dwIndex][i].uLen > dwRet) {
                dwRet = m_ppWordLattice[dwIndex][i].uLen;
            }
            
        }
    }
    return dwRet;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht2\srcs\chtbrkr.h ===
#ifndef _CHT_WORD_BREAKER_H__
#define _CHT_WORD_BREAKER_H__

#define BUFFER_GROW_UINT      30
#define LATTICE_LENGHT        50 
#define LOCAL_LENGTH           3

class CBaseLex;

typedef struct tagSLatticeNode {
    WORD   wCount;
    WORD   wAttr;
    BYTE   bTerminalCode;
    UINT   uLen;
    double fVariance;
    DWORD  dwUniCount; 
} SLatticeNode, *PSLatticeNode, **PPSLatticeNode;

typedef struct tagSLocalPath {
    DWORD  dwLength[LOCAL_LENGTH];
    WORD   wUnicount[LOCAL_LENGTH];
    WORD   wAttribute[LOCAL_LENGTH];
    BYTE   bTerminalCode[LOCAL_LENGTH];
    // for rule 1 - 5
    UINT   uPathLength;
    double fVariance;
    UINT   uCompoundNum;
    UINT   uDMNum;
    WORD   wUniCountSum;
    UINT   uStep;
}SLocalPath, *PSLocalPath;

typedef struct tagBreakResult{
    DWORD dwWordNumber;
    PUINT puWordLen;
    PUINT puWordAttrib;
    PBYTE pbTerminalCode;
} SBreakResult, *PSBreakResult;

class CCHTWordBreaker {
public:
    CCHTWordBreaker();
    ~CCHTWordBreaker();

public:
    BOOL  InitData(HINSTANCE hInstance);
    DWORD BreakText(LPCWSTR lpcwszText, INT nTextLen, CBaseLex* pcBaseLex = NULL, DWORD dwMaxWordLen = MAX_CHAR_PER_WORD,
        BOOL fBreakWithParser = TRUE);
    DWORD GetBreakResult(PUINT* ppuResult) {
        *ppuResult = m_psBreakResult->puWordLen;
        return m_psBreakResult->dwWordNumber;
    }
    DWORD GetBreakResultWithAttribute(PUINT* ppuResult, PUINT* ppuAttrib) {
        *ppuAttrib = m_psBreakResult->puWordAttrib;
        return GetBreakResult(ppuResult);
    }
    BOOL  AddSpecialWord(LPCWSTR lpcwEUDPStr, WORD wAttrib) {
        return m_pcLexicon->AddInLexiconInsert(lpcwEUDPStr, wAttrib);    
    }
    DWORD GetAltWord(LPCWSTR lpcwString, DWORD dwLength, LPWSTR* lppwAltWordBuf) {
        return m_pcLexicon->GetAltWord(lpcwString, dwLength, lppwAltWordBuf);
    }
private:
    BOOL AllocLattice(DWORD dwLength);
    void DestroyLattice(void);
    BOOL LatticeGrow(DWORD dwNewLength);

private:
    BOOL  BuildLattice(LPCWSTR lpcwszText, DWORD dwTextLen, CBaseLex *pcBaseLex, DWORD dwWordLen);
    DWORD GetResult();
    void  GetScore(PSLocalPath psLocalPath);
    INT   CompareScore(PSLocalPath psLocalPath1, PSLocalPath psLocalPath);
//  DWORD LongestRuleWord(DWORD dwIndex); 
private:
    PCCHTLexicon   m_pcLexicon;
    PPSLatticeNode m_ppWordLattice;
    PDWORD         m_pdwCandidateNumber;
    DWORD          m_dwSentenceLength;
    DWORD          m_dwLatticeLength;
    PDWORD         m_pdwMaxWordLength;
    PSBreakResult  m_psBreakResult;
    PCRuleLexicon  m_pcRuleLex;
};
typedef CCHTWordBreaker *PCCHTWordBreaker;

#endif //_CHT_WORD_BREAKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht2\srcs\defbrkr.h ===
#ifndef __DEFAULT_WORD_BREAKER_H_
#define __DEFAULT_WORD_BREAKER_H_

class CDefWordBreaker {
public:
    CDefWordBreaker();
    ~CDefWordBreaker() {};
    SCODE BreakText(TEXT_SOURCE *pTextSource, IWordSink *pWordSink, IPhraseSink *pPhraseSink, DWORD dwBase); 
private:    
    BOOL IsWordChar(int nIndex, PWORD _aCharInfo1, PWORD _aCharInfo3, const WCHAR* pwcChunk) const;
    BOOL ScanChunk(PWORD _aCharInfo1, PWORD _aCharInfo3, const WORD* pwcChunk, ULONG ucwc);
    void Tokenize(TEXT_SOURCE *pTextSource, ULONG cwc, IWordSink *pWordSink, ULONG& cwcProcd, PWORD _aCharInfo1, PWORD _aCharInfo3, DWORD dwBase);
private:
    WORD ccCompare; 
};

#else 

#endif // __DEFAULT_WORD_BREAKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht2\srcs\defbrkr.cpp ===
#include <windows.h>
#include "IWBrKr.h"
#include "DefBrKr.h"

#define ZERO_WIDTH_SPACE   0x200B
#define MAX_Def_WordBrKr_Prcess_Len   1000

BOOL IsWinNT(void)
{
    OSVERSIONINFOA  osVersionInfo;
    BOOL fRet = FALSE;
    
    osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
    GetVersionExA(&osVersionInfo);
    if (osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        fRet = TRUE; 
    }
    return fRet;
}

BOOL MyGetStringTypeEx(
    LCID   LocalID,
    DWORD  dwInfoType,
    const WCHAR *lpSrcStr,   // unicode base
    INT    cchSrc,
    LPWORD lpCharType)
{
    BOOL fRet = FALSE;

    if (IsWinNT()) {
        fRet = GetStringTypeW(dwInfoType, lpSrcStr, cchSrc,lpCharType);
    } else {
        DWORD dwANSISize = 0;
        dwANSISize = WideCharToMultiByte(GetACP(), WC_COMPOSITECHECK, lpSrcStr, cchSrc,
            NULL, 0, NULL, NULL);
        if (dwANSISize) {
            LPSTR lpAnsiStr = NULL;
            lpAnsiStr = new CHAR[dwANSISize];
            if (lpAnsiStr) {
                dwANSISize = WideCharToMultiByte(GetACP(), WC_COMPOSITECHECK, lpSrcStr, cchSrc,
                    lpAnsiStr, dwANSISize, NULL, NULL);
                fRet = GetStringTypeExA(LocalID, dwInfoType, lpAnsiStr, dwANSISize, lpCharType);
                if (ERROR_INVALID_PARAMETER == GetLastError() && (CT_CTYPE1 == dwInfoType || CT_CTYPE3 == dwInfoType)) {
                    for (INT i = 0; i < cchSrc; ++i) {
                        switch (dwInfoType) {
                        case CT_CTYPE1:
                            lpCharType[i] = C1_ALPHA;
                            break;
                        case CT_CTYPE3:
                            lpCharType[i] = (C3_NONSPACING | C3_ALPHA);
                            break;
                        }
                    }
                    fRet = TRUE;
                }
                delete [] lpAnsiStr;
                lpAnsiStr = NULL;
            }
        }
    }
    return fRet;
}


CDefWordBreaker::CDefWordBreaker()
{
    ccCompare = MAX_Def_WordBrKr_Prcess_Len;
}
//+-------------------------------------------------------------------------
//
//  Method:     CDefWordBreaker::IsWordChar
//
//  Synopsis:   Find whether the i'th character in the buffer _awString
//              is a word character (rather than word break)
//
//  Arguments:  [i] -- index into _awString
//
//  History:    22-Jul-1994  BartoszM       Created
//
//--------------------------------------------------------------------------

inline BOOL CDefWordBreaker::IsWordChar(
    int i,
    PWORD _aCharInfo1,
    PWORD _aCharInfo3,
    const WCHAR* pwcChunk) const
{
    if ( (_aCharInfo1[i] & (C1_ALPHA | C1_DIGIT))
        || (_aCharInfo3[i] & C3_NONSPACING)  )
    {
        return TRUE;
    }

    WCHAR c = pwcChunk[i];

    if (c == L'_')
        return TRUE;

    if (c == 0xa0) // non breaking space
    {
        // followed by a non-spacing character
        // (looking ahead is okay)
        if (_aCharInfo3[i+1] & C3_NONSPACING)
            return TRUE;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefWordBreaker::ScanChunk
//
//  Synopsis:   For each character find its type
//
//
//  History:    16-Aug-94  BartoszM     Created
//
//----------------------------------------------------------------------------
BOOL CDefWordBreaker::ScanChunk(
    PWORD _aCharInfo1, 
    PWORD _aCharInfo3,
    const WCHAR *pwcChunk,
    ULONG ucwc)
{
    BOOL fRet = FALSE;

    // POSIX character typing, Source, Size of source, Character info
    if (!MyGetStringTypeEx(GetSystemDefaultLCID(), CT_CTYPE1, pwcChunk, ucwc, _aCharInfo1)) { 
     // Additional POSIX, Source, Size of source, Character info 3
    } else if (!MyGetStringTypeEx(GetSystemDefaultLCID(), CT_CTYPE3, pwcChunk, ucwc, _aCharInfo3)) {         // 
    } else {
        fRet = TRUE;
    }
    return fRet;
}

/*
BOOL CDefWordBreaker::ScanChunk(
    PWORD _aCharInfo1, 
    PWORD _aCharInfo3,
    const WCHAR *pwcChunk,
    ULONG ucwc)
{

    //
    // GetStringTypeW is returning error 87 (ERROR_INVALID_PARAMETER) if
    // we pass in a null string.
    //
//  Win4Assert( (0 != _cMapped) && (0 != _pwcChunk) );

    if (IsWinNT())
    {
        if (!MyGetStringTypeEx(0,                     // Dummy
                              CT_CTYPE1,              // POSIX character typing
                              pwcChunk,               // Source
                              ucwc,                   // Size of source
                              _aCharInfo1 ) )         // Character info
        {
            return FALSE;
        }

        if ( !MyGetStringTypeEx(0,                    // Dummy
                              CT_CTYPE3,              // Additional POSIX
                              pwcChunk,               // Source
                              ucwc,                   // Size of source
                              _aCharInfo3 ) )         // Character info 3
        {
            return FALSE;
        }
    }
    else
    {
        //
        // BUGBUG: This is all wrong -- we don't know if this is the right
        //         locale to use and there isn't a way to know at this point.
        //

        if (!MyGetStringTypeEx( GetSystemDefaultLCID(),
                                CT_CTYPE1,              // POSIX character typing
                                pwcChunk,               // Source
                                ucwc,                   // Size of source
                                _aCharInfo1 ) )         // Character info
        {
//           ciDebugOut(( DEB_ERROR, "GetStringTypeW returned %d\n",
//                         GetLastError() ));

            // Win9x just stinks.  No 2 ways about it.

            if ( ERROR_INVALID_PARAMETER == GetLastError() )
            {
                for ( unsigned i = 0; i < ucwc; i++ )
                    _aCharInfo1[i] = C1_ALPHA;

                return TRUE;
            }

            return FALSE;
        }

        if ( !MyGetStringTypeEx(GetSystemDefaultLCID(),
                                CT_CTYPE3,              // Additional POSIX
                                pwcChunk,               // Source
                                ucwc,                   // Size of source
                                _aCharInfo3 ) )         // Character info 3
        {
//            ciDebugOut(( DEB_ERROR, "GetStringTypeW CTYPE3 returned %d\n",
 //                        GetLastError() ));

            // Win9x just stinks.  No 2 ways about it.

            if ( ERROR_INVALID_PARAMETER == GetLastError() )
            {
                for ( unsigned i = 0; i < ucwc; i++ )
                    _aCharInfo3[i] = ( C3_NONSPACING | C3_ALPHA );

                return TRUE;
            }

            return FALSE;
        }
    }

    return TRUE;
} //ScanChunk
*/
//+---------------------------------------------------------------------------
//
//  Member:     CDefWordBreaker::BreakText
//
//  Synopsis:   Break input stream into words.
//
//  Arguments:  [pTextSource] - source of input buffers
//              [pWordSink] - sink for words
//              [pPhraseSink] - sink for noun phrases
//
//  History:    07-June-91  t-WadeR     Created
//              12-Oct-92   AmyA        Added Unicode support
//              18-Nov-92   AmyA        Overloaded
//              11-Apr-94   KyleP       Sync with spec
//              26-Aug-94   BartoszM    Fixed Unicode parsing
//
//----------------------------------------------------------------------------

SCODE CDefWordBreaker::BreakText(
    TEXT_SOURCE *pTextSource,
    IWordSink   *pWordSink,
    IPhraseSink *pPhraseSink,
    DWORD       dwBase)
{
    LPWORD _aCharInfo1 = NULL;
    LPWORD _aCharInfo3 = NULL;

    if ( 0 == pTextSource )
        return E_INVALIDARG;

    if ( 0 == pWordSink || pTextSource->iCur == pTextSource->iEnd)
        return S_OK;

    if (pTextSource->iCur > pTextSource->iEnd)
    {
//        Win4Assert ( !"BreakText called with bad TEXT_SOURCE" );
        return E_FAIL;
    }

    SCODE sc = S_OK;

    ULONG cwc, cwcProcd;     // cwcProcd is # chars actually processed by Tokenize()

    do {
      //
      // Flag for first time thru loop below. This is to fix the case
      // where the length of the buffer passed in is less than
      // MAX_II_BUFFER_LEN. In this case iEnd-iCur is <= MAX_II_BUFFER_LEN
      // and we break out the inner loop and call
      // pfnFillTextBuffer without having processed any characters,
      // and so pfnFillTextBuffer returns TRUE without adding any new
      // characters and this results in an infinite loop.
        BOOL fFirstTime = TRUE;
        while (pTextSource->iCur < pTextSource->iEnd) {
            cwc = pTextSource->iEnd - pTextSource->iCur;
            // Process in buckets of MAX_II_BUFER_LEN only
            if (cwc >= CDefWordBreaker::ccCompare) {
                cwc = CDefWordBreaker::ccCompare;
            } else if ( !fFirstTime) {
                break;
            } else {
            }

            if (_aCharInfo1) {
                delete [] _aCharInfo1;
                _aCharInfo1 = NULL;
            }
            if (_aCharInfo3) {
                delete [] _aCharInfo3;
                _aCharInfo3 = NULL;
            }
            _aCharInfo1 = new WORD[cwc + 1];
            _aCharInfo3 = new WORD[cwc + 1];
            if (_aCharInfo1 && _aCharInfo3) {
                Tokenize( pTextSource, cwc, pWordSink, cwcProcd, _aCharInfo1, _aCharInfo3, dwBase);
            }

//          Win4Assert( cwcProcd <= cwc );
            pTextSource->iCur += cwcProcd;
            fFirstTime = FALSE;
        }
    } while(SUCCEEDED(pTextSource->pfnFillTextBuffer(pTextSource)));

    cwc = pTextSource->iEnd - pTextSource->iCur;
    // we know that the remaining text should be less than ccCompare

    // Win4Assert( cwc < CDefWordBreaker::ccCompare );

    if (0 != cwc) {
        if (_aCharInfo1) {
            delete [] _aCharInfo1;
            _aCharInfo1 = NULL;
        }
        if (_aCharInfo3) {
            delete [] _aCharInfo3;
            _aCharInfo3 = NULL;
        }
        _aCharInfo1 = new WORD[cwc + 1];
        _aCharInfo3 = new WORD[cwc + 1];
        if (_aCharInfo1 && _aCharInfo1) {
            Tokenize(pTextSource, cwc, pWordSink, cwcProcd, _aCharInfo1, _aCharInfo3, dwBase);
        }
    }

    if (_aCharInfo1) {
        delete [] _aCharInfo1;
        _aCharInfo1 = NULL;
    }
    if (_aCharInfo3) {
        delete [] _aCharInfo3;
         _aCharInfo3 = NULL;
    }

    return sc;
} //BreakText

//+---------------------------------------------------------------------------
//
//  Member:     CDefWordBreaker::Tokenize
//
//  Synopsis:   Tokenize the input buffer into words
//
//  Arguments:  [pTextSource]  --  input text source
//              [cwc]          --  # chars to process
//              [pWordSink]    --  sink for words
//              [cwcProd]      --  # chars actually processed returned here
//
//  History:    10-Aug-95   SitaramR    Created
//
//----------------------------------------------------------------------------

void CDefWordBreaker::Tokenize( TEXT_SOURCE *pTextSource,
                                ULONG cwc,
                                IWordSink *pWordSink,
                                ULONG& cwcProcd,
                                PWORD _aCharInfo1,
                                PWORD _aCharInfo3,
                                DWORD dwBase)
{
    const WCHAR* pwcChunk = NULL;
    WCHAR        _awcBufZWS[MAX_Def_WordBrKr_Prcess_Len];

    pwcChunk = &pTextSource->awcBuffer[pTextSource->iCur];

    if (!ScanChunk(_aCharInfo1, _aCharInfo3, pwcChunk, cwc)) {
        return;
    }

    BOOL fWordHasZWS = FALSE;     // Does the current word have a zero-width-space ?
    unsigned uLenZWS;             // Length of a word minus embedded zero-width-spaces

    //
    // iBeginWord is the offset into _aCharInfo of the beginning character of
    // a word.  iCur is the first *unprocessed* character.
    // They are indexes into the mapped chunk.
    //

    unsigned iBeginWord = 0;
    unsigned iCur = 0;

    //
    // Pump words from mapped chunk to word sink
    //
    while (iCur < cwc)
    {
        //
        // Skip whitespace, punctuation, etc.
        //
        for (; iCur < cwc; iCur++)
            if (IsWordChar (iCur, _aCharInfo1, _aCharInfo3, pwcChunk))
                break;

        // iCur points to a word char or is equal to _cMapped

        iBeginWord = iCur;
        if (iCur < cwc)
            iCur++; // we knew it pointed at word character

        //
        // Find word break. Filter may output Unicode zero-width-space, which
        // should be ignored by the wordbreaker.
        //
        fWordHasZWS = FALSE;
        for (; iCur < cwc; iCur++)
        {
            if (!IsWordChar(iCur, _aCharInfo1, _aCharInfo3, pwcChunk))
            {
                if (pwcChunk[iCur] == ZERO_WIDTH_SPACE )
                    fWordHasZWS = TRUE;
                else
                    break;
            }
        }

        if (fWordHasZWS)
        {
            //
            // Copy word into _awcBufZWS after stripping zero-width-spaces
            //

            uLenZWS = 0;
            for ( unsigned i=iBeginWord; i<iCur; i++ )
            {
                if (pwcChunk[i] != ZERO_WIDTH_SPACE )
                    _awcBufZWS[uLenZWS++] = pwcChunk[i];
            }
        }

        // iCur points to a non-word char or is equal to _cMapped

        if (iCur < cwc)
        {
            // store the word and its source position
            if ( fWordHasZWS )
                pWordSink->PutWord( uLenZWS, _awcBufZWS,                       // stripped word
                                    iCur - iBeginWord, pTextSource->iCur + iBeginWord + dwBase);
            else
                pWordSink->PutWord( iCur - iBeginWord, pwcChunk + iBeginWord, // the word
                                    iCur - iBeginWord, pTextSource->iCur + iBeginWord + dwBase);

            iCur++; // we knew it pointed at non-word char
            iBeginWord = iCur; // in case we exit the loop now
        }

    } // next word

//    Win4Assert( iCur == _cMapped );
    // End of words in chunk.
    // iCur == _cMapped
    // iBeginWord points at beginning of word or == _cMapped

    if ( 0 == iBeginWord )
    {
        // A single word fills from beginning of this chunk
        // to the end. This is either a very long word or
        // a short word in a leftover buffer.

        // store the word and its source position
        if ( fWordHasZWS )
            pWordSink->PutWord( uLenZWS, _awcBufZWS,       // stripped word
                                iCur, pTextSource->iCur + dwBase); // its source pos.
        else
            pWordSink->PutWord( iCur, pwcChunk,           // the word
                                iCur, pTextSource->iCur + dwBase); // its source pos.

        //
        // Position it to not add the word twice.
        //
        iBeginWord = iCur;
    }

    //
    // If this is the last chunk from text source, then process the
    // last fragment
    //

    if ( cwc < CDefWordBreaker::ccCompare && iBeginWord != iCur )
    {
        // store the word and its source position
        if ( fWordHasZWS )
            pWordSink->PutWord( uLenZWS, _awcBufZWS,                        // stripped word
                                iCur - iBeginWord, pTextSource->iCur + iBeginWord + dwBase);
        else
            pWordSink->PutWord( iCur - iBeginWord, pwcChunk + iBeginWord,  // the word
                                iCur - iBeginWord, pTextSource->iCur + iBeginWord + dwBase);

        iBeginWord = iCur;
    }

    cwcProcd = iBeginWord;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht2\srcs\lexmgr.cpp ===
#include <windows.h>
#include "lexicon.h"
#include "lexmgr.h"
#include "PropNoun.h"
#include <stdio.h>
#include <imm.h>
#include <stdio.h>

CCHTLexicon::CCHTLexicon()
{
    m_psLexiconHeader = NULL;
    m_pbLexiconBase = NULL;
#ifdef CHINESE_PROP_NAME
    m_pcPropName = NULL;
#endif
    m_sAddInLexicon.dwMaxWordNumber = 0;
    m_sAddInLexicon.dwWordNumber = 0;
    m_sAddInLexicon.psWordData = NULL;
    FillMemory(m_sAddInLexicon.wWordBeginIndex, 
        sizeof(m_sAddInLexicon.wWordBeginIndex), 0);
}

CCHTLexicon::~CCHTLexicon()
{
    DWORD i;
    // Do not build one char word signature
    if (m_psLexiconHeader) {
        for (i = 0 ; i < m_psLexiconHeader->dwMaxCharPerWord; ++i) {
            if (m_sWordInfo[i].pbFirstCharSignature) {
                delete m_sWordInfo[i].pbFirstCharSignature;
			}
            if (m_sWordInfo[i].pbLastCharSignature) {
                delete m_sWordInfo[i].pbLastCharSignature;
			}
		}
	}
#ifdef CHINESE_PROP_NAME
    if (m_pcPropName) {
        delete m_pcPropName;
    }
#endif
    // Free add in lexicon
    if (m_sAddInLexicon.psWordData) {
        for (i = 0; i < m_sAddInLexicon.dwWordNumber; ++i) {
            delete m_sAddInLexicon.psWordData[i].lpwszWordStr;
            m_sAddInLexicon.psWordData[i].lpwszWordStr = NULL;
        }
        delete m_sAddInLexicon.psWordData;
        m_sAddInLexicon.psWordData = NULL;
    }
    m_sAddInLexicon.dwMaxWordNumber = 0;
    m_sAddInLexicon.dwWordNumber = 0;
}
 
BOOL CCHTLexicon::InitData(
    HINSTANCE hInstance)
{
    HRSRC   hResInfo;
    HGLOBAL hResData;
    BOOL    fRet = FALSE;
    TCHAR   tszLexiconResName[MAX_PATH];
    DWORD   i;

    // Init main lexicon
    lstrcpy(tszLexiconResName, TEXT("LEXICON"));
    if (!(hResInfo = FindResource(hInstance, tszLexiconResName, TEXT("BIN")))) {
    } else if (!(hResData = LoadResource(hInstance, hResInfo))) {
    } else if (!(m_pbLexiconBase = (LPBYTE)LockResource(hResData))) {
    } else {
        m_psLexiconHeader = (PSLexFileHeader)m_pbLexiconBase;
        for (i = 0 ; i < m_psLexiconHeader->dwMaxCharPerWord; ++i) {
            m_sWordInfo[i].lpwWordString = (LPWSTR)(m_pbLexiconBase + 
                m_psLexiconHeader->sLexInfo[i].dwWordStringOffset);
            m_sWordInfo[i].pbAttribute = (LPBYTE)(m_pbLexiconBase + 
                m_psLexiconHeader->sLexInfo[i].dwWordAttribOffset);
            m_sWordInfo[i].pwUnicount = (PWORD)(m_pbLexiconBase + 
                m_psLexiconHeader->sLexInfo[i].dwWordCountOffset);
            m_sWordInfo[i].pbTerminalCode = (LPBYTE)(m_pbLexiconBase + 
                m_psLexiconHeader->sLexInfo[i].dwTerminalCodeOffset);
        }
        BuildSignatureData();
        fRet = TRUE;
    }

    // Init alt lexicon
    lstrcpy(tszLexiconResName, TEXT("ALTWORD"));
    if (!(hResInfo = FindResource(hInstance, tszLexiconResName, TEXT("BIN")))) {
    } else if (!(hResData = LoadResource(hInstance, hResInfo))) {
    } else if (!(m_pbAltWordBase = (LPBYTE)LockResource(hResData))) {
    } else {
        m_psAltWordHeader = (PSAltLexFileHeader)m_pbAltWordBase;
        for (i = 0 ; i < m_psAltWordHeader->dwMaxCharPerWord; ++i) {
            m_sAltWordInfo[i].lpwWordString = (LPWSTR)(m_pbAltWordBase + 
                m_psAltWordHeader->sAltWordInfo[i].dwWordStringOffset);
            m_sAltWordInfo[i].pdwGroupID = (PDWORD)(m_pbAltWordBase + 
                m_psAltWordHeader->sAltWordInfo[i].dwWordGroupOffset);
        }
        fRet = TRUE;
    }


#ifdef CHINESE_PROP_NAME
    m_pcPropName = new CProperNoun(hInstance);
    if (m_pcPropName) {
        m_pcPropName->InitData();
    }
#endif

#ifdef _DEBUG
    FILE   *fp;
    DWORD  j;
    WCHAR  wUnicodeString[MAX_CHAR_PER_WORD + 1];
    CHAR   cANSIString[MAX_CHAR_PER_WORD * 2 + 1];
    WORD   wCount;
    fp = fopen("DM.dmp", "wt");
    for (i = 0 ; i < m_psLexiconHeader->dwMaxCharPerWord; ++i) {
        for (j = 0; j < m_psLexiconHeader->sLexInfo[i].dwWordNumber; ++j) {
            if (m_sWordInfo[i].pbAttribute[j] & ATTR_DM) {
                wCount = m_sWordInfo[i].pwUnicount[j];
                if (i == 0) {
                    wUnicodeString[0] = (WORD)(CHT_UNICODE_BEGIN + j);
                } else {
                    CopyMemory(wUnicodeString, &(m_sWordInfo[i].lpwWordString[j * (i + 1)]),
                        sizeof(WCHAR) * (i + 1));
                }
                wUnicodeString[i + 1] = '\0';
                WideCharToMultiByte(950, WC_COMPOSITECHECK, wUnicodeString, i + 1 + 1,
                  cANSIString, sizeof(cANSIString), NULL, NULL);
                fprintf(fp, "%s %d\n", cANSIString, wCount);
            } 
        }
    }
    fclose(fp);
    fp = fopen("COMPOUND.dmp", "wt");
    for (i = 0 ; i < m_psLexiconHeader->dwMaxCharPerWord; ++i) {
        for (j = 0; j < m_psLexiconHeader->sLexInfo[i].dwWordNumber; ++j) {
            if (m_sWordInfo[i].pbAttribute[j] & ATTR_COMPOUND) {
                wCount = m_sWordInfo[i].pwUnicount[j];
                if (i == 0) {
                    wUnicodeString[0] = (WORD)(CHT_UNICODE_BEGIN + j);
                } else {
                    CopyMemory(wUnicodeString, &(m_sWordInfo[i].lpwWordString[j * (i + 1)]),
                        sizeof(WCHAR) * (i + 1));
                }
                wUnicodeString[i + 1] = '\0';
                WideCharToMultiByte(950, WC_COMPOSITECHECK, wUnicodeString, i + 1 + 1,
                  cANSIString, sizeof(cANSIString), NULL, NULL);
                fprintf(fp, "%s %d\n", cANSIString, wCount);
            } 
        }
    }
    fclose(fp);
#endif
    // Init EUDP to special word
    LoadEUDP();
    
    return fRet;
}

void CCHTLexicon::BuildSignatureData(void)
{
    DWORD i, j, dwWordNumber;
    WORD  wFirstChar, wLastChar;

    for (i = 0; i < MAX_CHAR_PER_WORD; ++i) {
        m_sWordInfo[i].pbFirstCharSignature = NULL;
        m_sWordInfo[i].pbLastCharSignature = NULL;
    }

    // Do not build one char word signature
    for (i = 0 ; i < m_psLexiconHeader->dwMaxCharPerWord; ++i) {
        dwWordNumber = m_psLexiconHeader->sLexInfo[i].dwWordNumber; 
        if (i != 0 && dwWordNumber > WORD_NUM_TO_BUILD_SIGNATURE) {
            m_sWordInfo[i].pbFirstCharSignature = new BYTE[(CHT_UNICODE_END - CHT_UNICODE_BEGIN + 1) / 8 + 1];
            if (NULL == m_sWordInfo[i].pbFirstCharSignature) { continue; }
            FillMemory(m_sWordInfo[i].pbFirstCharSignature, (CHT_UNICODE_END - CHT_UNICODE_BEGIN + 1) / 8, 0); 
            for (j = 0; j < dwWordNumber; ++j) { 
                wFirstChar = m_sWordInfo[i].lpwWordString[(i + 1) * j];
                if (wFirstChar >= CHT_UNICODE_BEGIN) {
                    m_sWordInfo[i].pbFirstCharSignature[(wFirstChar - CHT_UNICODE_BEGIN) / 8] |=
                        (0x00000001 << ((wFirstChar - CHT_UNICODE_BEGIN) % 8));
                }
            }
            m_sWordInfo[i].pbLastCharSignature = new BYTE[(CHT_UNICODE_END - CHT_UNICODE_BEGIN + 1) / 8 + 1];
            if (NULL == m_sWordInfo[i].pbLastCharSignature)  { continue; }
            FillMemory(m_sWordInfo[i].pbLastCharSignature, (CHT_UNICODE_END - CHT_UNICODE_BEGIN + 1) / 8, 0); 
            for (j = 0; j < dwWordNumber; ++j) { 
                wLastChar = m_sWordInfo[i].lpwWordString[(i + 1) * (j + 1) - 1];
                if (wLastChar >= CHT_UNICODE_BEGIN) {
                    m_sWordInfo[i].pbLastCharSignature[(wLastChar - CHT_UNICODE_BEGIN) / 8] |=
                        (0x00000001 << ((wLastChar - CHT_UNICODE_BEGIN) % 8));
                }
            }
        } else {
            m_sWordInfo[i].pbFirstCharSignature = NULL;
            m_sWordInfo[i].pbLastCharSignature = NULL;
        }
    }
}


BOOL CCHTLexicon::GetWordInfo(
    LPCWSTR lpcwString, 
    DWORD   dwLength, 
    PWORD   pwUnicount, 
    PWORD   pwAttrib,
    PBYTE   pbTerminalCode)
{
    BOOL fRet;
    BYTE bMainLexAttrib;

    fRet = GetMainLexiconWordInfo(lpcwString, dwLength, pwUnicount, 
        &bMainLexAttrib, pbTerminalCode);
    *pwAttrib = bMainLexAttrib;
    if (fRet) { goto _exit; }

#ifdef CHINESE_PROP_NAME    
    if (dwLength == 3) {
        if (m_pcPropName->IsAChineseName(lpcwString, dwLength)) {
            *pbTerminalCode = ' ';
            *pwAttrib = ATTR_RULE_WORD;
            *pwUnicount = 100;
            fRet = TRUE;
            goto _exit;
        }
    }
#endif
    fRet = GetAddInWordInfo(lpcwString, dwLength, pwUnicount, 
        pwAttrib, pbTerminalCode);    
_exit:
    return fRet;
}

BOOL CCHTLexicon::GetMainLexiconWordInfo(
    LPCWSTR lpcwString, 
    DWORD   dwLength, 
    PWORD   pwUnicount, 
    PBYTE   pbAttrib,
    PBYTE   pbTerminalCode)
{
    INT    nBegin, nEnd, nMid;
    INT    nCmp;
    BOOL   fRet = FALSE;
    LPWSTR lpwLexString;
    DWORD  dwFirstCharIndex, dwLastCharIndex;

    if (dwLength > m_psLexiconHeader->dwMaxCharPerWord) { goto _exit; }
    
    if (lpcwString[0] < CHT_UNICODE_BEGIN || lpcwString[0] > CHT_UNICODE_END) {
        goto _exit; 
    }
    dwFirstCharIndex = lpcwString[0] - CHT_UNICODE_BEGIN;

    if (dwLength == 1) {
        *pwUnicount = m_sWordInfo[dwLength - 1].pwUnicount[dwFirstCharIndex];
        *pbAttrib = m_sWordInfo[dwLength - 1].pbAttribute[dwFirstCharIndex];
        *pbTerminalCode = m_sWordInfo[dwLength - 1].pbTerminalCode[dwFirstCharIndex];
        fRet = TRUE;         
    } else {
        // Check signature first
        if (m_sWordInfo[dwLength - 1].pbFirstCharSignature) {
            if (!(m_sWordInfo[dwLength - 1].pbFirstCharSignature[dwFirstCharIndex / 8] &
                (0x00000001 << (dwFirstCharIndex % 8)))) { goto _exit; }
        }
        if (lpcwString[dwLength - 1] >= CHT_UNICODE_BEGIN && lpcwString[dwLength - 1] <= CHT_UNICODE_END) {
            if (m_sWordInfo[dwLength - 1].pbLastCharSignature) {
                dwLastCharIndex = lpcwString[dwLength - 1] - CHT_UNICODE_BEGIN;
                if (!(m_sWordInfo[dwLength - 1].pbLastCharSignature[dwLastCharIndex / 8] &
                    (0x00000001 << (dwLastCharIndex % 8)))) { goto _exit; }
            }
        }
        nBegin = 0;
        nEnd = m_psLexiconHeader->sLexInfo[dwLength - 1].dwWordNumber - 1;
        lpwLexString = m_sWordInfo[dwLength - 1].lpwWordString;
        DWORD dwCompByteNum = sizeof(WCHAR) * dwLength;
        while (nBegin <= nEnd) {
            nMid = (nBegin + nEnd) / 2; 
            nCmp = memcmp(&(lpwLexString[nMid * dwLength]), lpcwString, dwCompByteNum);
            if (nCmp > 0) {
                nEnd = nMid - 1;
            } else if (nCmp < 0) {
                nBegin = nMid + 1;
            } else {
                *pwUnicount = m_sWordInfo[dwLength - 1].pwUnicount[nMid];
                *pbAttrib = m_sWordInfo[dwLength - 1].pbAttribute[nMid];
                *pbTerminalCode = m_sWordInfo[dwLength - 1].pbTerminalCode[nMid];
                fRet = TRUE;
                break;
            }
        }
    }
_exit:
    if (!fRet) {
        *pwUnicount = 0; 
        *pbAttrib = 0;
        *pbTerminalCode = ' ';
    }
    return fRet;
}


// Load EUDP
int CALLBACK EUDPCountA(
    LPCSTR  lpcszReading,
    DWORD   dwStyle,
    LPCSTR  lpcszString,
    LPVOID  lpvData)
{            
    PSAddInLexicon psAddInLexicon;

    if (lstrlenA(lpcszString) / sizeof(WCHAR) <= MAX_CHAR_PER_WORD) {
        psAddInLexicon = (PSAddInLexicon)lpvData;
        ++psAddInLexicon->dwWordNumber;
    }
    return 1;
}
int CALLBACK EUDPCountW(
    LPCWSTR lpcwszReading,
    DWORD   dwStyle,
    LPCWSTR lpcwszString,
    LPVOID  lpvData)
{
    PSAddInLexicon psAddInLexicon;
    
    if (lstrlenW(lpcwszString) <= MAX_CHAR_PER_WORD) {            
        psAddInLexicon = (PSAddInLexicon)lpvData;
        ++psAddInLexicon->dwWordNumber;
    }
    return 1;
}
int CALLBACK EUDPLoadA(
    LPCSTR  lpcszReading,
    DWORD   dwStyle,
    LPCSTR  lpcszString,
    LPVOID  lpvData)
{
    PSAddInLexicon psAddInLexicon;
    WORD           wStrLen;

    wStrLen = (WORD)lstrlenA(lpcszString);
    if (wStrLen / sizeof(WCHAR) <= MAX_CHAR_PER_WORD) {
         psAddInLexicon = (PSAddInLexicon)lpvData;
         psAddInLexicon->psWordData[psAddInLexicon->dwWordNumber].lpwszWordStr = 
             new WORD[wStrLen / sizeof(WCHAR) + 1]; // zero end
         MultiByteToWideChar(950, MB_PRECOMPOSED, lpcszString, wStrLen  + 1,
             psAddInLexicon->psWordData[psAddInLexicon->dwWordNumber].lpwszWordStr, 
             wStrLen / sizeof(WCHAR) + 1);
         psAddInLexicon->psWordData[psAddInLexicon->dwWordNumber].wAttrib = ATTR_EUDP_WORD;     
         psAddInLexicon->psWordData[psAddInLexicon->dwWordNumber].wLen = wStrLen / sizeof(WCHAR);
         ++psAddInLexicon->dwWordNumber;
    }
    return 1;
}
int CALLBACK EUDPLoadW(
    LPCWSTR lpcwszReading,
    DWORD   dwStyle,
    LPCWSTR lpcwszString,
    LPVOID  lpvData)
{            
   PSAddInLexicon psAddInLexicon;
   WORD           wStrLen;

   wStrLen = (WORD)lstrlenW(lpcwszString);
   if (wStrLen <= MAX_CHAR_PER_WORD) {
       psAddInLexicon = (PSAddInLexicon)lpvData;
       psAddInLexicon->psWordData[psAddInLexicon->dwWordNumber].lpwszWordStr =
           new WORD[wStrLen + 1];
       CopyMemory(psAddInLexicon->psWordData[psAddInLexicon->dwWordNumber].lpwszWordStr,
           lpcwszString, (wStrLen + 1) * sizeof(WCHAR)); 
       psAddInLexicon->psWordData[psAddInLexicon->dwWordNumber].wAttrib = ATTR_EUDP_WORD;
       psAddInLexicon->psWordData[psAddInLexicon->dwWordNumber].wLen = wStrLen;
       ++psAddInLexicon->dwWordNumber;
    }
    return 1;
}

int __cdecl CompSWordData(
    const void *arg1,
    const void *arg2)
{
    PSWordData psWordData1, psWordData2;
    
    psWordData1 = (PSWordData)arg1;
    psWordData2 = (PSWordData)arg2;

    if (psWordData1->wLen < psWordData2->wLen) {
        return -1;
    } else if (psWordData1->wLen > psWordData2->wLen) {
        return 1;
    } else {
        return memcmp(psWordData1->lpwszWordStr, 
            psWordData2->lpwszWordStr, psWordData1->wLen * sizeof(WCHAR));
    }

}

void CCHTLexicon::LoadEUDP(void)
{
    DWORD i;

    m_sAddInLexicon.dwWordNumber = 0;
    m_sAddInLexicon.dwMaxWordNumber = 0;
    m_sAddInLexicon.psWordData = NULL;

    OSVERSIONINFOA OSVerInfo;
    OSVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionExA(&OSVerInfo);
    if (OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        ImmEnumRegisterWordW(HKL((ULONG_PTR) 0xE0080404), EUDPCountW, NULL,
            IME_REGWORD_STYLE_USER_PHRASE, NULL, &m_sAddInLexicon);
    } else {
        ImmEnumRegisterWordA(HKL((ULONG_PTR) 0xE0080404), EUDPCountA, NULL,
            IME_REGWORD_STYLE_USER_PHRASE, NULL, &m_sAddInLexicon);    
    }
    if (m_sAddInLexicon.dwWordNumber) {
        m_sAddInLexicon.dwMaxWordNumber = m_sAddInLexicon.dwWordNumber + EUDP_GROW_NUMBER;
        m_sAddInLexicon.psWordData = new SWordData[m_sAddInLexicon.dwMaxWordNumber];
        m_sAddInLexicon.dwWordNumber = 0;
        if (OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
            ImmEnumRegisterWordW(HKL((ULONG_PTR) 0xE0080404), EUDPLoadW, NULL,
                IME_REGWORD_STYLE_USER_PHRASE, NULL, &m_sAddInLexicon);
        } else {
            ImmEnumRegisterWordA(HKL((ULONG_PTR) 0xE0080404), EUDPLoadA, NULL,
                IME_REGWORD_STYLE_USER_PHRASE, NULL, &m_sAddInLexicon);            
        }
        qsort(m_sAddInLexicon.psWordData, m_sAddInLexicon.dwWordNumber,
            sizeof(SWordData), CompSWordData);
        for (i = 0; i < m_sAddInLexicon.dwWordNumber; ++i) {
            ++m_sAddInLexicon.wWordBeginIndex[m_sAddInLexicon.psWordData[i].wLen - 1];
        }
        WORD wCount = m_sAddInLexicon.wWordBeginIndex[0];
        for (i = 1; i <= MAX_CHAR_PER_WORD; ++i) {
            WORD wTemp = m_sAddInLexicon.wWordBeginIndex[i];
            m_sAddInLexicon.wWordBeginIndex[i] = wCount;
            wCount += wTemp;
        }
    } else {
        m_sAddInLexicon.dwMaxWordNumber = 0;
    }
}

// Add AP word
BOOL CCHTLexicon::AddInLexiconInsert(
    LPCWSTR lpcwszWordStr,
    WORD    wAttrib)
{
    BOOL    fRet = FALSE;
    WORD    wStrLen, i, j;
    INT     nIndex;

    wStrLen = (WORD)lstrlenW(lpcwszWordStr);
    if (wStrLen > MAX_CHAR_PER_WORD) { goto _exit; }
    // if exit, just change it's attrib;
    // Be carefully, EUDP > Error word
    if ((nIndex = GetAddInWordInfoIndex(lpcwszWordStr, wStrLen)) != -1) {
        if (m_sAddInLexicon.psWordData[nIndex].wAttrib == ATTR_EUDP_WORD) {
        } else { 
            m_sAddInLexicon.psWordData[nIndex].wAttrib = wAttrib;
        }
        goto _exit;
    }
    // Enlarge space
    if (m_sAddInLexicon.dwMaxWordNumber == m_sAddInLexicon.dwWordNumber) {
        PSWordData psTempWordData;
        psTempWordData = new SWordData [m_sAddInLexicon.dwMaxWordNumber + EUDP_GROW_NUMBER]; 
        if (!psTempWordData) { goto _exit; }
        CopyMemory(psTempWordData, m_sAddInLexicon.psWordData,
            m_sAddInLexicon.dwWordNumber * sizeof(SWordData));
        delete [] m_sAddInLexicon.psWordData;
        m_sAddInLexicon.psWordData = psTempWordData;
        m_sAddInLexicon.dwMaxWordNumber += EUDP_GROW_NUMBER;
    }
    // Insert word
    for (i = m_sAddInLexicon.wWordBeginIndex[wStrLen - 1]; i < m_sAddInLexicon.wWordBeginIndex[wStrLen]; ++i) {
        if (memcmp(lpcwszWordStr, m_sAddInLexicon.psWordData[i].lpwszWordStr,
            wStrLen * sizeof(WCHAR)) < 0) {
             break;
        }
    }
    for (j = (WORD)m_sAddInLexicon.dwWordNumber; j > i; --j) { 
        m_sAddInLexicon.psWordData[j] = m_sAddInLexicon.psWordData[j - 1];
    }
    m_sAddInLexicon.psWordData[i].lpwszWordStr = new WORD[wStrLen + 1];
    CopyMemory(m_sAddInLexicon.psWordData[i].lpwszWordStr, lpcwszWordStr, 
        (wStrLen + 1) * sizeof(WORD));
    m_sAddInLexicon.psWordData[i].wAttrib = wAttrib;
    m_sAddInLexicon.psWordData[i].wLen = wStrLen;
    ++m_sAddInLexicon.dwWordNumber;
    for (i = wStrLen; i <= MAX_CHAR_PER_WORD; ++i) {
        ++m_sAddInLexicon.wWordBeginIndex[i];
    }
    fRet =  TRUE;
_exit:
#ifdef _DEBUG
    for (i = 1; i <= MAX_CHAR_PER_WORD; ++i) {
        for (j = m_sAddInLexicon.wWordBeginIndex[i - 1]; j < m_sAddInLexicon.wWordBeginIndex[i]; ++j) {
            if (m_sAddInLexicon.psWordData[j].wLen != i) {
                MessageBox(0, TEXT("Error string length"), TEXT("Error"), MB_OK);
            }
            if (j == m_sAddInLexicon.wWordBeginIndex[i] - 1) {
            } else if (memcmp(m_sAddInLexicon.psWordData[j].lpwszWordStr,
                m_sAddInLexicon.psWordData[j + 1].lpwszWordStr, 
                m_sAddInLexicon.psWordData[j].wLen * sizeof(WORD)) >= 0) {
                MessageBox(0, TEXT("Error string order"), TEXT("Error"), MB_OK);
            } else {
            }
        }
    }
#endif
    return fRet;
}

BOOL CCHTLexicon::GetAddInWordInfo(
    LPCWSTR lpcwString, 
    DWORD   dwLength, 
    PWORD   pwUnicount, 
    PWORD   pwAttrib,
    PBYTE   pbTerminalCode)
{
    BOOL   fRet = FALSE;
    INT    nIndex;

    if (dwLength > MAX_CHAR_PER_WORD) { goto _exit; }
    nIndex = GetAddInWordInfoIndex(lpcwString, dwLength);
    if (nIndex == -1) { goto _exit; }

    if (pwUnicount) {
        *pwUnicount = 10000;
    } 
    if (pwAttrib) {
        *pwAttrib = m_sAddInLexicon.psWordData[nIndex].wAttrib;
    }
    if (pbTerminalCode) {
        *pbTerminalCode = ' ';
    }
    fRet = TRUE;
_exit:
    return fRet;
}

// return -1 if not find
INT CCHTLexicon::GetAddInWordInfoIndex(
    LPCWSTR lpcwString, 
    DWORD   dwLength)
{
    INT  nRet = -1;
    INT  nBegin, nEnd, nMid;
    INT  nCmp;

    if (dwLength > MAX_CHAR_PER_WORD) { goto _exit; }
    if (m_sAddInLexicon.wWordBeginIndex[dwLength - 1] == m_sAddInLexicon.wWordBeginIndex[dwLength]) {
        goto _exit;
    }
    nBegin = m_sAddInLexicon.wWordBeginIndex[dwLength - 1];
    nEnd = m_sAddInLexicon.wWordBeginIndex[dwLength] - 1;
    while (nBegin <= nEnd) {
        nMid = (nBegin + nEnd) / 2; 
        nCmp = memcmp(m_sAddInLexicon.psWordData[nMid].lpwszWordStr,
            lpcwString, dwLength * sizeof(WCHAR));
        if (nCmp > 0) {
            nEnd = nMid - 1;
        } else if (nCmp < 0) {
            nBegin = nMid + 1;
        } else {
            nRet = nMid;
            break;
        }
    }
_exit:
    return nRet;
}



DWORD CCHTLexicon::GetAltWord(
    LPCWSTR   lpcwString,
    DWORD     dwLength,
    LPWSTR*   lppwAltWordBuf)
{
    INT    nBegin, nEnd, nMid;
    INT    nCmp;
    DWORD  dwRet = 0;
    LPWSTR lpwAltWordString;
    DWORD  dwGroupID;

    if (dwLength > m_psAltWordHeader->dwMaxCharPerWord) { goto _exit; }

    nBegin = 0;
    nEnd = m_psAltWordHeader->sAltWordInfo[dwLength - 1].dwWordNumber - 1;
    lpwAltWordString = m_sAltWordInfo[dwLength - 1].lpwWordString;
    DWORD dwCompByteNum;
    dwCompByteNum = sizeof(WCHAR) * dwLength;
    while (nBegin <= nEnd) {
            nMid = (nBegin + nEnd) / 2; 
            nCmp = memcmp(&(lpwAltWordString[nMid * dwLength]), lpcwString, dwCompByteNum);
            if (nCmp > 0) {
                nEnd = nMid - 1;
            } else if (nCmp < 0) {
                nBegin = nMid + 1;
            } else {
                dwGroupID = m_sAltWordInfo[dwLength - 1].pdwGroupID[nMid];
                // Fill AltWord
                *lppwAltWordBuf = new WCHAR[dwLength + 1];
                if (*lppwAltWordBuf) {
                    for (DWORD i = 0; i < m_psAltWordHeader->sAltWordInfo[dwLength - 1].dwWordNumber; ++i) {
                        if (i != (DWORD)nMid && m_sAltWordInfo[dwLength - 1].pdwGroupID[i] == dwGroupID) {
                            CopyMemory((LPVOID)*lppwAltWordBuf, 
                                (LPVOID)&(m_sAltWordInfo[dwLength - 1].lpwWordString[i * dwLength]), 
                                sizeof(WCHAR) * dwLength);
                            (*lppwAltWordBuf)[dwLength] = NULL;
                            ++dwRet;
                            goto _exit;
                        }
                    }
                }
                break;
            }
    }
_exit:
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht2\srcs\export.cpp ===
#include <windows.h>

#include <objbase.h>
#include <initguid.h>
#include "IWBrKr.h"
#include "DefBrKr.h"

#include "rulelex.h"
#include "lexicon.h"
#include "LexMgr.h"
#include "chtbrkr.h"
#include "cierror.h"

static LONG g_lServerLockCnt = 0;
static LONG g_lComponentCnt = 0;

TCHAR g_tszModuleFileName[MAX_PATH];
HINSTANCE g_hInstance;

#define WBREAK_E_END_OF_TEXT             ((HRESULT)0x80041780L)

static WCHAR g_wszLicense[] = {L"Use of the IWordBreaker interface that is in violation of the license agreement, without the consent of the vendor(s) specified in the notice, may result in server civil and criminal penalties"};

TCHAR tszEnglishLangSpecificKey[] = TEXT("System\\CurrentControlSet\\Control\\ContentIndex\\Language\\English_US");

extern "C" BOOL CALLBACK DllMain(HINSTANCE, DWORD, LPVOID);

BOOL CALLBACK DllMain(
    HINSTANCE hInstance,        // instance handle of this library
    DWORD     fdwReason,        // reason called
    LPVOID    lpvReserve)       // reserve pointer
{
    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        g_hInstance = hInstance;
        GetModuleFileName(g_hInstance, g_tszModuleFileName, 
            sizeof(g_tszModuleFileName) / sizeof(TCHAR));
        break;
    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}


// Export API 
STDAPI DllCanUnloadNow(void)
{
    if (g_lServerLockCnt) {
    } else if (g_lComponentCnt) {
    } else {
        return S_OK;
    }
    return S_FALSE;
}
       
STDAPI DllGetClassObject(
    const CLSID& clsid,
    const IID&   iid,
    void       **ppv)
{
    IChtBrKrClassFactory *pIChtBrKrClassFactory;
        HRESULT hr;


        InterlockedIncrement(&g_lServerLockCnt);

        if (clsid != CLSID_CHTBRKR && clsid != CLSID_WHISTLER_CHTBRKR) { 
                hr = CLASS_E_CLASSNOTAVAILABLE ;
        goto _exit;
        }

        pIChtBrKrClassFactory = new IChtBrKrClassFactory;

        if (!pIChtBrKrClassFactory) { 
                hr = E_OUTOFMEMORY; 
            goto _exit;
        }
 
    hr = pIChtBrKrClassFactory->QueryInterface(iid, ppv);

_exit:
        InterlockedDecrement(&g_lServerLockCnt);
 
        return hr;
}


// Factory
IChtBrKrClassFactory::IChtBrKrClassFactory(void)
    :m_lRefCnt(1)
{
    InterlockedIncrement(&g_lComponentCnt);
}

IChtBrKrClassFactory::~IChtBrKrClassFactory(void)
{
    InterlockedDecrement(&g_lComponentCnt);
}

STDMETHODIMP_(ULONG) IChtBrKrClassFactory::AddRef(void)
{
    return InterlockedIncrement(&m_lRefCnt);
}

STDMETHODIMP_(ULONG) IChtBrKrClassFactory::Release(void)
{
    if (InterlockedDecrement(&m_lRefCnt) == 0) {
        delete this;
        return 0;
    }
    return m_lRefCnt;
}

STDMETHODIMP IChtBrKrClassFactory::QueryInterface(
    const IID&   iid,
    void       **ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory)) {
        *ppv = static_cast<IChtBrKrClassFactory *>(this);
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP IChtBrKrClassFactory::LockServer(
    BOOL fLock)
{
    if (fLock) {
        InterlockedIncrement(&g_lServerLockCnt);
    } else {
        InterlockedDecrement(&g_lServerLockCnt);
    }
    return S_OK;
}

STDMETHODIMP IChtBrKrClassFactory::CreateInstance(
    IUnknown  *pUnknownOuter,
    const IID& iid,
    void     **ppv)
{
    IWordBreaker *pIWordBreaker;
    HRESULT hr;

    *ppv = NULL;

    if (pUnknownOuter) { return CLASS_E_NOAGGREGATION; }
    
    pIWordBreaker = new IWordBreaker; 

    if (!pIWordBreaker) { return  E_OUTOFMEMORY; } 
    
    hr = pIWordBreaker->QueryInterface(iid, ppv);
     
    pIWordBreaker->Release();
    
    return hr;
}

SCODE _stdcall MyFillTestBuffer(
    TEXT_SOURCE __RPC_FAR *pTextSource)
{
    return WBREAK_E_END_OF_TEXT;   
}

// IWordBreaker
IWordBreaker::IWordBreaker(void)
    :m_lRefCnt(1),
     m_pcWordBreaker(NULL),
     m_pNonChineseTextSource(NULL),
     m_pNonChineseWordBreaker(NULL),
     m_pcDefWordBreaker(NULL),
     m_fIsQueryTime(FALSE)
{
    InterlockedIncrement(&g_lComponentCnt);
    // CHT word breaker
    m_pcWordBreaker = new CCHTWordBreaker;
    if (!m_pcWordBreaker) {
    } else if (m_pcWordBreaker->InitData(g_hInstance)) {
    } else {
        delete m_pcWordBreaker;
        m_pcWordBreaker = NULL;
    }

    // Default wordbreaker 
    m_pcDefWordBreaker = new CDefWordBreaker;

    // Non CHT Word breaker
    m_pNonChineseTextSource = new TEXT_SOURCE;
    if (m_pNonChineseTextSource) { 
        HKEY  hKey;
        TCHAR tszCLSID[MAX_PATH];
        DWORD dwBufSize = MAX_PATH;
        CLSID szCLSID;
        HRESULT hr;
        m_pNonChineseTextSource->pfnFillTextBuffer = MyFillTestBuffer;
#if 0
        if (RegCreateKey(HKEY_LOCAL_MACHINE, tszEnglishLangSpecificKey, &hKey) == ERROR_SUCCESS) {
            if (RegQueryValueEx(hKey, TEXT("WBreakerClass"), NULL, NULL, (LPBYTE)tszCLSID, &dwBufSize) == ERROR_SUCCESS) {
                CoInitialize(NULL);
                CLSIDFromString(tszCLSID, &szCLSID);
                hr = CoCreateInstance(szCLSID, NULL, CLSCTX_SERVER, IID_IWordBreaker,
                    (LPVOID*)&m_pNonChineseWordBreaker);
                if (!SUCCEEDED(hr)) {
                    m_pNonChineseWordBreaker = NULL;
                }
            }
        }
#endif
    }
}

IWordBreaker::~IWordBreaker(void)
{
    InterlockedDecrement(&g_lComponentCnt);

    if (m_pcWordBreaker) {
        delete m_pcWordBreaker;
    }
    if (m_pNonChineseTextSource) {
        delete m_pNonChineseTextSource;
    }
    if (m_pNonChineseWordBreaker) {
        if (m_pNonChineseWordBreaker->Release() == 0) {
            m_pNonChineseWordBreaker = NULL;
        }
    }
    if (m_pcDefWordBreaker) {
        delete m_pcDefWordBreaker;
    }
}

STDMETHODIMP IWordBreaker::QueryInterface(
    const IID&   iid,
    void       **ppv)
{
    *ppv = NULL;

    if ((iid == IID_IUnknown) || (iid == IID_IWordBreaker)) {
        *ppv = static_cast<IWordBreaker *>(this);
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) IWordBreaker::AddRef(void)
{
    return InterlockedIncrement(&m_lRefCnt);
}

STDMETHODIMP_(ULONG) IWordBreaker::Release(void)
{
    if (m_lRefCnt == 0 || InterlockedDecrement(&m_lRefCnt) == 0) {
        delete this;
        return 0;
    }
    return m_lRefCnt;
}

STDMETHODIMP IWordBreaker::Init(
    BOOL  fQuery, 
    ULONG ulMaxTokenSize, 
    BOOL  *pfLicense)
{
    m_uMaxCharNumberPerWord = ulMaxTokenSize;
    *pfLicense = FALSE;
    m_fIsQueryTime = fQuery;
        if (NULL != m_pNonChineseWordBreaker) {
            m_pNonChineseWordBreaker->Init(fQuery, ulMaxTokenSize, pfLicense);
        }
    return S_OK;
}

BOOL IsChineseChar(
    WCHAR wUnicode)
{
    BOOL fRet;

    if (wUnicode >= 0x4E00 && wUnicode <= 0x9FA5) {
        fRet = TRUE;
    } else if (wUnicode >= 0xd800 && wUnicode <= 0xdbff) {
        fRet = TRUE; 
    } else if (wUnicode >= 0xdc00 && wUnicode <= 0xdfff) {
        fRet = TRUE;
    } else if (wUnicode >= 0x1100 && wUnicode <= 0x11ff) {
       fRet = TRUE;
    } else if (wUnicode >= 0x2e80 && wUnicode <= 0xffff) {
    } else {
        fRet = FALSE;
    }

    return fRet;
}

BOOL IsSpecialFullShapeChar(
    WCHAR wChar)
{
    BOOL fRet;

    if (wChar >=0xff21 && wChar <=0xff3a) {
        fRet = TRUE;
    } else if (wChar >=0xff41 && wChar <=0xff5a) {
        fRet = TRUE;
    } else if (wChar >=0xff10 && wChar <=0xff19) {
        fRet = TRUE;
    } else {
        fRet = FALSE;
    }
    return fRet;
}


DWORD GetNormaizeWord(
    LPWSTR   lpwWordStr,
    UINT     uWordLen,
    LPWSTR*  lppwNormalizedWordStr) 
{
    DWORD dwNormalizedWordLen = 0;
    UINT  i;
    WCHAR wChar;

    for (i = 0; i < uWordLen; ++i) {
        if (!IsSpecialFullShapeChar(lpwWordStr[i])) {
            goto _exit;           
        }
    }
    *lppwNormalizedWordStr = new WCHAR[uWordLen];
    if (*lppwNormalizedWordStr) {
        for (dwNormalizedWordLen = 0; dwNormalizedWordLen < uWordLen; ++dwNormalizedWordLen) {
            wChar = lpwWordStr[dwNormalizedWordLen];
            if (wChar >=0xff21 && wChar <=0xff3a) { // A - Z
                (*lppwNormalizedWordStr)[dwNormalizedWordLen] = wChar - (0xff21 - 0x0041);
            } else if (wChar >=0xff41 && wChar <=0xff5a) { // a - z
                (*lppwNormalizedWordStr)[dwNormalizedWordLen] = wChar - (0xff41 - 0x0061);
            } else if (wChar >=0xff10 && wChar <=0xff19) { // 0 - 9
                (*lppwNormalizedWordStr)[dwNormalizedWordLen] = wChar - (0xff10 - 0x0030);
            } else {
                (*lppwNormalizedWordStr[dwNormalizedWordLen]) = wChar;
            }       
        }
    }

_exit:
    return dwNormalizedWordLen;
}

BOOL MyPutWordOrPhrase(
    CCHTWordBreaker* m_pcWordBreaker,
    TEXT_SOURCE      *pTextSource,
    IWordSink        *pWordSink,
    IPhraseSink      *pPhraseSink,
    DWORD            dwStartPosInTextStore,
    PDWORD           pdwPrivBufToTextSourceMapping,
    LPWSTR           lptszStencece, // Pure sentence, no enter in sentence
    DWORD            dwSentenceLen,
    DWORD            dwWordNum,
    PUINT            puBreakResult,
    BOOL             fPutWord,
    BOOL*            fIsAPhrase)

{
    DWORD  i, dwSentenceIndex = 0, dwWordLen;
    BOOL   fRet = TRUE;
    LPWSTR lpwNormalizedWordStr; 
    DWORD  dwNormalizedWordLen;

    for (i = 0; i < dwWordNum; ++i) {
        dwWordLen = pdwPrivBufToTextSourceMapping[dwSentenceIndex + puBreakResult[i] - 1] -
            pdwPrivBufToTextSourceMapping[dwSentenceIndex] + 1;
        if (fPutWord && pWordSink) {
            if (dwNormalizedWordLen = GetNormaizeWord(&(lptszStencece[dwSentenceIndex]), puBreakResult[i], &lpwNormalizedWordStr)) {
                pWordSink->PutAltWord(dwNormalizedWordLen, lpwNormalizedWordStr, dwWordLen, dwStartPosInTextStore + pdwPrivBufToTextSourceMapping[dwSentenceIndex]);
                delete [] lpwNormalizedWordStr;
            } 
            DWORD   dwAltWordNumber;
            LPWSTR  lpwAltWord;
            if (dwAltWordNumber = m_pcWordBreaker->GetAltWord(&lptszStencece[dwSentenceIndex], puBreakResult[i], &lpwAltWord)) {
                pWordSink->PutAltWord(puBreakResult[i], lpwAltWord, dwWordLen, dwStartPosInTextStore + pdwPrivBufToTextSourceMapping[dwSentenceIndex]);   
                delete [] lpwAltWord;
            }
                    pWordSink->PutWord(puBreakResult[i], &lptszStencece[dwSentenceIndex],
                dwWordLen, dwStartPosInTextStore + pdwPrivBufToTextSourceMapping[dwSentenceIndex]);
        } else if (!fPutWord && fIsAPhrase) {
            if (fIsAPhrase[i] && pPhraseSink) {
                        pPhraseSink->PutPhrase(
                    &(pTextSource->awcBuffer[dwStartPosInTextStore + pdwPrivBufToTextSourceMapping[dwSentenceIndex]]),
                    dwWordLen);                
            }
        } else {
        }
        dwSentenceIndex += puBreakResult[i];
    }
    return fRet;
}


DWORD FullShapeCharProcess(
    LPWSTR lptszStencece,
    DWORD  dwSentenceLen,
    DWORD  dwWordNum,
    PUINT  puBreakResult)
{
    DWORD dwSentenceIndex = 0;
    DWORD dwMergeWordCount = 0;

    for (DWORD i = 0; i < dwWordNum; ++i) {
        dwMergeWordCount = 0; 
        while (i + dwMergeWordCount < dwWordNum && puBreakResult[i + dwMergeWordCount] == 1 && 
            IsSpecialFullShapeChar(lptszStencece[dwSentenceIndex + dwMergeWordCount])) {
            ++dwMergeWordCount;
        } 
        if (dwMergeWordCount > 1) {
            puBreakResult[i] += (dwMergeWordCount - 1);
/*
            if (pfIsAPhrase) {
                CopyMemory(&(pfIsAPhrase[i + 1]), &(pfIsAPhrase[i + dwMergeWordCount]), 
                    sizeof(BOOL) * (dwWordNum - (i + dwMergeWordCount)));  
            }
*/
            if (puBreakResult) {
                CopyMemory(&(puBreakResult[i + 1]), &(puBreakResult[i + dwMergeWordCount]), 
                    sizeof(UINT) * (dwWordNum - (i + dwMergeWordCount)));   
            }
            dwWordNum -= (dwMergeWordCount - 1);
            dwSentenceIndex += dwMergeWordCount;
        } else {
            dwSentenceIndex += puBreakResult[i];
        }
    }

    return dwWordNum;
}

BOOL IsEnter(
    LPCWSTR lpwStr) 
{
    BOOL fRet;

    if (lpwStr[0] == 0x000D && lpwStr[1] == 0x000A) {
        fRet = TRUE;
    } else {
        fRet = FALSE;
    }

    return fRet;
}

STDMETHODIMP IWordBreaker::BreakText(
    TEXT_SOURCE *pTextSource, 
    IWordSink   *pWordSink, 
    IPhraseSink *pPhraseSink)
{
    LPTSTR           lptszStencece = NULL;
        PDWORD           pdwIndex = NULL;         
    PUINT            puResult, puResultAttrib;
    DWORD            dwBufferSize = 0, dwBufferUsed = 0;
        DWORD            dwIndex = 0;
    DWORD            dwWordNum;
    HRESULT          hr = S_OK;
    BOOL             fIsPreChineseLanguage, fIsCurChineseLanguage;
        BOOL             fIsEnter;
        DWORD            dwEnterCount = 0;
    PUINT            puOrigionalResult = NULL;
    PUINT            puNewResult = NULL; // after decompose compose word
    BOOL*            pfIsAPhrase = NULL;
    PUINT            puOrigionalResultAttrib = NULL;
    DWORD            dwNewResultNum = 0;
    DWORD            dwSentenceIndex, dwOrgWordIndex, dwSubWordNum;
    

    if (!pTextSource) {
        hr = E_INVALIDARG;
        goto _exit;
    }
    dwBufferSize = BUFFER_GROW_UINT;
    lptszStencece = (LPTSTR)HeapAlloc(GetProcessHeap(), 0, dwBufferSize * sizeof(WCHAR));
    pdwIndex = (PDWORD)HeapAlloc(GetProcessHeap(), 0, dwBufferSize * sizeof(DWORD));
    if (!lptszStencece || !pdwIndex) {
        hr = E_OUTOFMEMORY; 
        goto _exit;
    }

    while (TRUE) {
        while (pTextSource->iCur < pTextSource->iEnd) {
                        fIsEnter = FALSE;
            fIsCurChineseLanguage = IsChineseChar(pTextSource->awcBuffer[pTextSource->iCur]); // Enter is not a Chinese char
            
                        // Process "Enter"
            // Rule: One Enter only -> connect
            //       More Than one Enter-> split
            //       Enter after a full width char -> split
                        if (!fIsCurChineseLanguage && dwBufferUsed != 0 && fIsPreChineseLanguage) {
                                if (pTextSource->iCur < pTextSource->iEnd - 1) {
                                    if (IsEnter(&(pTextSource->awcBuffer[pTextSource->iCur]))) {
                        if ((pTextSource->iCur + 3 < pTextSource->iEnd) && IsEnter(&(pTextSource->awcBuffer[pTextSource->iCur + 2]))) {
                        } else if (IsSpecialFullShapeChar(lptszStencece[dwBufferUsed - 1])) {
                        } else {
                                                fIsCurChineseLanguage = TRUE; // we treat "Enter" as Chinese char
                                                fIsEnter = TRUE;
                                                    ++dwEnterCount;
                        }
                                        }
                                }
                        }
                        if (dwBufferUsed == 0) { // first char
                fIsPreChineseLanguage = fIsCurChineseLanguage;
            } else if (fIsPreChineseLanguage && fIsCurChineseLanguage) {
            } else if (!fIsPreChineseLanguage && !fIsCurChineseLanguage) {
            } else { // language change, process it
_Break_Text:
                if (fIsPreChineseLanguage) {
/*                                      
                                        PWCHAR pwOutputDebugString;
                    pwOutputDebugString = new WCHAR[dwBufferUsed + 1];
                                        CopyMemory(pwOutputDebugString, lptszStencece, sizeof(WCHAR) * dwBufferUsed);
                    pwOutputDebugString[dwBufferUsed] = NULL;
                                        OutputDebugString(pwOutputDebugString);
*/                                      
                    dwWordNum = m_pcWordBreaker->BreakText(lptszStencece, dwBufferUsed);   
                    dwWordNum = m_pcWordBreaker->GetBreakResultWithAttribute(&puResult, &puResultAttrib);
                    puOrigionalResult = new UINT[dwWordNum];
                    puNewResult = new UINT[dwBufferUsed]; // alloc max size
                    pfIsAPhrase = new BOOL[dwWordNum];
                    puOrigionalResultAttrib = new UINT [dwWordNum];
                    if (puOrigionalResult && puNewResult && pfIsAPhrase && puOrigionalResultAttrib) {
                        dwNewResultNum = 0;
                        CopyMemory(puOrigionalResult, puResult, sizeof(UINT) * dwWordNum);
                        CopyMemory(puOrigionalResultAttrib, puResultAttrib, sizeof(UINT) * dwWordNum);
                        for (dwSentenceIndex = 0, dwOrgWordIndex = 0; dwOrgWordIndex < dwWordNum; ++dwOrgWordIndex) {
                            pfIsAPhrase[dwOrgWordIndex] = FALSE;
                            if (puOrigionalResult[dwOrgWordIndex] > 2) {
                                dwSubWordNum = m_pcWordBreaker->BreakText(&(lptszStencece[dwSentenceIndex]), 
                                    puOrigionalResult[dwOrgWordIndex], NULL, puOrigionalResult[dwOrgWordIndex] - 1, FALSE);   
                                dwSubWordNum = m_pcWordBreaker->GetBreakResult(&puResult);
                                if (puOrigionalResultAttrib[dwOrgWordIndex] == ATTR_RULE_WORD) {
                                    pfIsAPhrase[dwOrgWordIndex] = TRUE;    
                                } else {
                                    for (DWORD dwSubWordIndex = 0; dwSubWordIndex < dwSubWordNum; ++dwSubWordIndex) {
                                        if (puResult[dwSubWordIndex] > 1) {
                                            pfIsAPhrase[dwOrgWordIndex] = TRUE;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (pfIsAPhrase[dwOrgWordIndex]) {
                                CopyMemory(&(puNewResult[dwNewResultNum]), puResult, sizeof(UINT) * dwSubWordNum);
                                dwNewResultNum += dwSubWordNum;
                            } else {
                                puNewResult[dwNewResultNum++] = puOrigionalResult[dwOrgWordIndex];
                            }
                            dwSentenceIndex += puOrigionalResult[dwOrgWordIndex];
                        }
                        if (m_fIsQueryTime) { // Put Phrase at query time
                            MyPutWordOrPhrase(m_pcWordBreaker, pTextSource, pWordSink, pPhraseSink, pTextSource->iCur - dwBufferUsed - dwEnterCount * 2, 
                                pdwIndex, lptszStencece, dwBufferUsed, dwWordNum, puOrigionalResult, FALSE, pfIsAPhrase);
                        }
                        // special process for full width A-Z, a-z, 0-9
                        dwNewResultNum = FullShapeCharProcess(lptszStencece, dwBufferUsed, dwNewResultNum, puNewResult);
                        // Put Word
                        MyPutWordOrPhrase(m_pcWordBreaker, pTextSource, pWordSink, pPhraseSink, pTextSource->iCur - dwBufferUsed - dwEnterCount * 2, 
                            pdwIndex, lptszStencece, dwBufferUsed, dwNewResultNum, puNewResult, TRUE, NULL);
                    } else { // can not do special processing
                        MyPutWordOrPhrase(m_pcWordBreaker, pTextSource, pWordSink, pPhraseSink, pTextSource->iCur - dwBufferUsed - dwEnterCount * 2, 
                            pdwIndex, lptszStencece, dwBufferUsed, dwWordNum, puResult, TRUE, NULL);                            
                    }
                    if (puOrigionalResult) { delete [] puOrigionalResult; } 
                    if (puNewResult) { delete [] puNewResult; } 
                    if (pfIsAPhrase) { delete [] pfIsAPhrase; }
                    if (puOrigionalResultAttrib) { delete [] puOrigionalResultAttrib; }
                    puResult = NULL;
                                        dwEnterCount = 0;
                } else { // not TC language sentence
                    /*
                    m_pNonChineseTextSource->iCur = 0;
                    m_pNonChineseTextSource->iEnd = dwBufferUsed;  
                    m_pNonChineseTextSource->awcBuffer = &(pTextSource->awcBuffer[pTextSource->iCur - dwBufferUsed]);//lptszStencece;
                    */
                    m_pNonChineseTextSource->iCur = pTextSource->iCur - dwBufferUsed;
                    m_pNonChineseTextSource->iEnd = pTextSource->iCur;  
                    m_pNonChineseTextSource->awcBuffer = pTextSource->awcBuffer;
               //   if (m_pNonChineseWordBreaker) {
               //       m_pNonChineseWordBreaker->BreakText(m_pNonChineseTextSource, pWordSink, pPhraseSink);
               //   } else 
                                if (m_pcDefWordBreaker) {
                        //m_pcDefWordBreaker->BreakText(m_pNonChineseTextSource, pWordSink, pPhraseSink, pTextSource->iCur - dwBufferUsed);
                        m_pcDefWordBreaker->BreakText(m_pNonChineseTextSource, pWordSink, pPhraseSink, 0);
                    } /*else if (m_pNonChineseWordBreaker) {
                        //m_pNonChineseWordBreaker->BreakText(m_pNonChineseTextSource, pWordSink, pPhraseSink);
                    } */ else {
                    }
                }
                fIsPreChineseLanguage = fIsCurChineseLanguage;
                dwBufferUsed = 0;       
                                dwIndex = 0;
                                dwEnterCount = 0;
            }
            if (dwBufferUsed >= dwBufferSize) { // buffer full
                LPVOID lpMem1, lpMem2;
                lpMem1 = HeapReAlloc(GetProcessHeap(), 0, lptszStencece, 
                    (dwBufferSize + BUFFER_GROW_UINT) * sizeof(WCHAR));
                lpMem2 = HeapReAlloc(GetProcessHeap(), 0, pdwIndex, 
                    (dwBufferSize + BUFFER_GROW_UINT) * sizeof(DWORD));
                if (!lpMem1 || !lpMem2) { goto _Break_Text;
                } else {
                    lptszStencece = (LPTSTR)lpMem1;
                    pdwIndex = (PDWORD)lpMem2;
                    dwBufferSize += BUFFER_GROW_UINT;
                }
            }
                        if (pTextSource->iCur < pTextSource->iEnd) {
                                if (fIsEnter) {
                                    pTextSource->iCur += 2;
                                        dwIndex += 2;
                                } else {
                    lptszStencece[dwBufferUsed] = pTextSource->awcBuffer[pTextSource->iCur++];
                                        pdwIndex[dwBufferUsed] = dwIndex;
                                        ++dwBufferUsed;
                                        ++dwIndex;
                                }
                        }
        }
                if (dwBufferUsed) { goto _Break_Text; }
        if (FAILED(pTextSource->pfnFillTextBuffer(pTextSource))) {
            break;
        }
    }
_exit:
    if (lptszStencece) {
        HeapFree(GetProcessHeap(), 0, lptszStencece);
    }
        if (pdwIndex) {
            HeapFree(GetProcessHeap(), 0, pdwIndex);
        }
    return hr;
}

STDMETHODIMP IWordBreaker::ComposePhrase(
    const WCHAR *pwcNoun, 
    ULONG cwcNoun, 
    const WCHAR *pwcModifier,
    ULONG cwcModifier, 
    ULONG ulAttachmentType,
    WCHAR *pwcPhrase, 
    ULONG *pcwcPhrase)
{
    return E_NOTIMPL;
}
    
STDMETHODIMP IWordBreaker::GetLicenseToUse(
    const WCHAR **ppwcsLicense)
{
    *ppwcsLicense = g_wszLicense;
    
    return S_OK;
}

/*
    while (TRUE) {
        while (pTextSource->iCur != pTextSource->iEnd) {
            lptszStencece[dwBufferUsed] = pTextSource->awcBuffer[pTextSource->iCur++];
            if (lptszStencece[dwBufferUsed] >= 0x4E00 && lptszStencece[dwBufferUsed] <= 0x9FA5) {
                dwBufferUsed++;
                if (dwBufferUsed >= dwBufferSize) {
                    LPVOID lpMem;
                    lpMem = HeapReAlloc(GetProcessHeap(), 0, lptszStencece, dwBufferSize + BUFFER_GROW_UINT);
                    if (!lpMem) {
                        goto _heap_realloc_fail;
                    } else {
                        lptszStencece = (LPTSTR)lpMem ;
                        dwBufferSize += BUFFER_GROW_UINT;
                    }
                }
            } else {
                if (dwBufferUsed == 0) {
                    ++dwBufferUsed;    
                } else {
                    --pTextSource->iCur;
                }
_heap_realloc_fail:
                dwWordNum = pcWordBreaker->BreakText(lptszStencece, dwBufferUsed);   
                dwWordNum = pcWordBreaker->GetBreakResult(&puResult);
                // To do .....
                DWORD dwSrcPos;
                dwSrcPos = pTextSource->iCur - dwBufferUsed;
                for (i = 0; i < dwWordNum; ++i) {
                    pWordSink->PutWord(puResult[i], &pTextSource->awcBuffer[dwSrcPos], puResult[i], dwSrcPos);
                    dwSrcPos += puResult[i];
                }
                puResult = NULL;
                dwBufferUsed = 0;
            }
        }
        if (FAILED(pTextSource->pfnFillTextBuffer(pTextSource))) {
            break;
        }
    }
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht2\srcs\lexicon.h ===
#ifndef __CHTLEXICON_H_
#define __CHTLEXICON_H_

// Use one BYTE, return WORD to AP
// AP can use high BYTE as a private data
#define ATTR_DM             0x01
#define ATTR_COMPOUND       0x02
#define ATTR_RULE_WORD      0x04
#define ATTR_EUDP_WORD      0x08


#define MAX_CHAR_PER_WORD   10

#define CHT_UNICODE_BEGIN   0x4E00
#define CHT_UNICODE_END     0x9FA5

typedef struct tagSLexInfo {
    DWORD dwWordNumber;
    DWORD dwWordStringOffset;
    DWORD dwWordCountOffset;
    DWORD dwWordAttribOffset;
    DWORD dwTerminalCodeOffset;
} SLexInfo, *PSLexInfo;

typedef struct tagLexFileHeader {
    DWORD     dwMaxCharPerWord;
    SLexInfo  sLexInfo[MAX_CHAR_PER_WORD];     
} SLexFileHeader, *PSLexFileHeader;

typedef struct tagSAltLexInfo {
    DWORD dwWordNumber;
    DWORD dwWordStringOffset;
    DWORD dwWordGroupOffset;
} SAltLexInfo, *PSAltLexInfo;

typedef struct tagAltLexFileHeader {
    DWORD       dwMaxCharPerWord;
    SAltLexInfo sAltWordInfo[MAX_CHAR_PER_WORD];     
} SAltLexFileHeader, *PSAltLexFileHeader;
#else

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht2\srcs\iwbrkr.h ===
#ifndef _CHTBRKR_H__
#define _CHTBRKR_H__

extern "C" TCHAR g_tszModuleFileName[MAX_PATH];
extern "C" HINSTANCE g_hInstance;

class CCHTWordBreaker;
class CDefWordBreaker;

// {1680E7C3-9430-4a51-9B82-1E7E7AEE5258}
DEFINE_GUID(CLSID_CHTBRKR, 0x1680E7C3, 0x9430, 0x4A51, 0x9B, 0x82, 
            0x1E, 0x7E, 0x7A, 0xEE, 0x52, 0x58);
// {954F1760-C1BC-11D0-9692-00A0C908146E}
DEFINE_GUID(CLSID_WHISTLER_CHTBRKR, 0x954F1760, 0xC1BC, 0x11D0, 0x96, 0x92, 
            0x00, 0xA0, 0xC9, 0x08, 0x14, 0x6E);

DEFINE_GUID(IID_IWordBreaker, 0xD53552C8, 0x77E3, 0x101A, 0xB5, 0x52, 
            0x08, 0x0, 0x2B ,0x33 ,0xB0, 0xE6);
typedef SCODE ( __stdcall __RPC_FAR *PFNFILLTEXTBUFFER )( 
    struct tagTEXT_SOURCE __RPC_FAR *pTextSource);
typedef struct tagTEXT_SOURCE{
    PFNFILLTEXTBUFFER pfnFillTextBuffer;
    const WCHAR *awcBuffer;
    ULONG iEnd;
    ULONG iCur;
}TEXT_SOURCE;

typedef enum tagWORDREP_BREAK_TYPE{
    WORDREP_BREAK_EOW = 0,
    WORDREP_BREAK_EOS = 1,
    WORDREP_BREAK_EOP = 2,
    WORDREP_BREAK_EOC = 3
} WORDREP_BREAK_TYPE;

class IChtBrKrClassFactory: public IClassFactory
{
public:
	 IChtBrKrClassFactory();
	 ~IChtBrKrClassFactory();
public:
	// IUnknown members
    STDMETHOD(QueryInterface)	(THIS_ REFIID refiid, VOID **ppv);
    STDMETHOD_(ULONG,AddRef)	(THIS);
    STDMETHOD_(ULONG,Release)	(THIS);

	// IFEClassFactory members
    STDMETHOD(CreateInstance)	(THIS_ LPUNKNOWN, REFIID, void **);
    STDMETHOD(LockServer)		(THIS_ BOOL);
private:
    LONG        m_lRefCnt;
};

DECLARE_INTERFACE_(IWordSink, IUnknown)
{
public:
    STDMETHOD(PutWord) (THIS_ ULONG cwc, const WCHAR *pwcInBuf, ULONG cwcSrcLen, ULONG cwcSrcPos) PURE;
    STDMETHOD(PutAltWord) (THIS_ ULONG cwc, const WCHAR *pwcInBuf, ULONG cwcSrcLen, ULONG cwcSrcPos) PURE;
    STDMETHOD(StartAltPhrase) (THIS) PURE;
    STDMETHOD(EndAltPhrase) (THIS) PURE;
    STDMETHOD(PutBreak) (THIS_ WORDREP_BREAK_TYPE breakType) PURE;        
};

DECLARE_INTERFACE_(IPhraseSink, IUnknown)
{
public:
    STDMETHOD(PutSmallPhrase) (THIS_ const WCHAR *pwcNoun, ULONG cwcNoun, const WCHAR *pwcModifier,
        ULONG cwcModifier, ULONG ulAttachmentType) PURE;
    STDMETHOD(PutPhrase) (THIS_ const WCHAR *pwcPhrase, ULONG cwcPhrase) PURE;
};


class IWordBreaker: public IUnknown
{
public:
    IWordBreaker();
    ~IWordBreaker();
public:
    STDMETHOD(QueryInterface)	(THIS_ REFIID refiid, VOID **ppv);
    STDMETHOD_(ULONG,AddRef)	(THIS);
    STDMETHOD_(ULONG,Release)	(THIS);

public:
    STDMETHOD(Init)	(THIS_ BOOL fQuery, ULONG ulMaxTokenSize, BOOL *pfLicense);
    STDMETHOD(BreakText) (THIS_ TEXT_SOURCE *pTextSource, IWordSink *pWordSink, IPhraseSink *pPhraseSink);
    STDMETHOD(ComposePhrase) (THIS_ const WCHAR *pwcNoun, ULONG cwcNoun, const WCHAR *pwcModifier,
        ULONG cwcModifier, ULONG ulAttachmentType, WCHAR *pwcPhrase, ULONG *pcwcPhrase);
    STDMETHOD(GetLicenseToUse) (THIS_  const WCHAR **ppwcsLicense);
private:
    UINT             m_uMaxCharNumberPerWord;
    LONG             m_lRefCnt;
    CCHTWordBreaker* m_pcWordBreaker;
    TEXT_SOURCE*     m_pNonChineseTextSource;
    IWordBreaker*    m_pNonChineseWordBreaker;
    CDefWordBreaker* m_pcDefWordBreaker;
    BOOL             m_fIsQueryTime;
};
   
#else
#endif //_CHTBRKR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht2\srcs\propnoun.cpp ===
#include <windows.h>
#include <assert.h>
#include "PropNoun.H"

int __cdecl CharCompare(
    const void *item1,
    const void *item2)
{
    PCharProb pChar1 = (PCharProb) item1;
    PCharProb pChar2 = (PCharProb) item2;
    
    if (pChar1->dwUnicode > pChar2->dwUnicode) {
        return 1;
    } else if (pChar1->dwUnicode < pChar2->dwUnicode) {
        return -1;
    } else {
        return 0;
    }
}

int __cdecl UnicodeCompare(
    const void *item1,
    const void *item2)
{
    int nSize1 = lstrlenW((LPWSTR) item1) * sizeof(WCHAR),
        nSize2 = lstrlenW((LPWSTR) item2) * sizeof(WCHAR);
    return memcmp(item1, item2, nSize1 > nSize2 ? nSize1 : nSize2);
}

int __cdecl EngNameCompare(
    const void *item1,
    const void *item2)
{
    PEngName p1 = (PEngName) item1;
    PEngName p2 = (PEngName) item2;

    if (p1->wPrevUnicode > p2->wPrevUnicode) {
        return 1;
    } else if (p1->wPrevUnicode < p2->wPrevUnicode) {
        return -1;
    } else {
        if (p1->wNextUnicode > p2->wNextUnicode) {
            return 1;
        } else if (p1->wNextUnicode < p2->wNextUnicode) {
            return -1;
        } else {
            return 0;
        }
    }
}

CProperNoun::CProperNoun(
    HINSTANCE hInstance) :
    m_dProperNameThreshold(FL_PROPER_NAME_THRESHOLD),
    m_pCharProb(NULL),
    m_dwTotalCharProbNum(0),
    m_pEngNameData(NULL),
    m_hProcessHeap(0),
    m_hInstance(hInstance)
{
}

CProperNoun::~CProperNoun()
{
}

BOOL CProperNoun::InitData()
{
    BOOL fRet = FALSE;
    HRSRC hResource;
    HGLOBAL hGlobal;

    m_hProcessHeap = GetProcessHeap();

    //  Find resource
    hResource = FindResource(m_hInstance, TEXT("CNAME"), TEXT("BIN"));
    if (!hResource) { goto _exit; }

    //  Load resource
    hGlobal = LoadResource(m_hInstance, hResource);
    if (!hGlobal) { goto _exit; }

    m_pCharProb = (PCharProb) LockResource(hGlobal);
    if (!m_pCharProb) { goto _exit; }
    m_dwTotalCharProbNum = SizeofResource(m_hInstance, hResource) / sizeof(CharProb);
/*
    //  Find resource
    hResource = FindResource(m_hInstance, TEXT("ENAME"),
        TEXT("BIN"));
    if (!hResource) { goto _exit; }

    //  Load resource
    hGlobal = LoadResource(m_hInstance, hResource);
    if (!hGlobal) { goto _exit; }

    m_pEngNameData = (PEngNameData) LockResource(hGlobal);
    m_pEngNameData->pwUnicode = (PWORD) ((PBYTE) m_pEngNameData +
        sizeof(m_pEngNameData->dwTotalEngUnicodeNum) +
        sizeof(m_pEngNameData->dwTotalEngNamePairNum));
    m_pEngNameData->pEngNamePair = (PEngName) ((PBYTE) m_pEngNameData +
        sizeof(m_pEngNameData->dwTotalEngUnicodeNum) +
        sizeof(m_pEngNameData->dwTotalEngNamePairNum) +
        sizeof(m_pEngNameData->pwUnicode[0]) * m_pEngNameData->dwTotalEngUnicodeNum);

//    m_pEngName = (PEngName) LockResource(hGlobal);
//    m_dwTotalEngNameNum = SizeofResource(m_hInstance, hResource) / sizeof(EngName);
*/
    qsort(m_pwszSurname, m_dwTotalSurnameNum, sizeof(m_pwszSurname[0]), UnicodeCompare);

    fRet = TRUE;

_exit:

    return fRet;
}

BOOL CProperNoun::IsAProperNoun(
    LPWSTR lpwszChar,
    UINT uCount)
{
    return (IsAChineseName(lpwszChar, uCount) || IsAEnglishName(lpwszChar, uCount));
}

BOOL CProperNoun::IsAChineseName(
    LPCWSTR lpcwszChar,
    UINT    uCount)
{
    static WCHAR wszChar[3] = { NULL };
    PWCHAR pwsResult;

    wszChar[0] = lpcwszChar[0];

    //  Find surname
    if (pwsResult = (PWCHAR) bsearch(wszChar, m_pwszSurname, m_dwTotalSurnameNum, sizeof(m_pwszSurname[0]),
        UnicodeCompare)) {
        FLOAT flProbability = 1;
        PCharProb pCharProb;
        CharProb CProb;

        //  Calculate probability to be a proper noun
        for (UINT i = 1; i < uCount; ++i) {
            CProb.dwUnicode = lpcwszChar[i];
            if (pCharProb = (PCharProb) bsearch(&CProb, m_pCharProb,
                m_dwTotalCharProbNum, sizeof(m_pCharProb[0]), CharCompare)) {
                flProbability *= pCharProb->flProbability;
            } else {
                flProbability *= (FLOAT) FL_DEFAULT_CHAR_PROBABILITY;
            }
        }

        if (flProbability >= m_dProperNameThreshold) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL CProperNoun::IsAEnglishName(
    LPCWSTR lpwszChar,
    UINT uCount)
{
    static EngName Name;

    Name.wPrevUnicode = lpwszChar[0];
    Name.wNextUnicode = lpwszChar[uCount - 1];

    if (bsearch(&Name, m_pEngNameData->pEngNamePair, m_pEngNameData->dwTotalEngUnicodeNum, sizeof(EngName), EngNameCompare)) {
        return TRUE;
    }

    return FALSE;
}

WCHAR CProperNoun::m_pwszSurname[][3] = {
    L"B",
    L"R",
    L"_",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"C",
    L"K",
    L"T",
    L"]",
    L"q",
    L"v",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"V",
    L"w",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"E",
    L"d",
    L"f",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"H",
    L"L",
    L"f",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"P",
    L"s",
    L"u",
    L"x",
    L"}",
    L"",
    L"",
    L"",
    L"L",
    L"Z",
    L"k",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"J",
    L"\\",
    L"",
    L"",
    L"",
    L"I",
    L"R",
    L"_",
    L"d",
    L"h",
    L"q",
    L"x",
    L"",
    L"J",
    L"S",
    L"]",
    L"p",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"L",
    L"V",
    L"]",
    L"c",
    L"u",
    L"}",
    L"",
    L"",
    L"",
    L"",
    L"Z",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"K",
    L"q",
    L"|",
    L"}",
    L"",
    L"",
    L"O",
    L"Z",
    L"d",
    L"h",
    L"i",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"\\",
    L"s",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"^",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"J",
    L"q",
    L"{",
    L"",
    L"",
    L"",
    L"O",
    L"P",
    L"R",
    L"d",
    L"k",
    L"s",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"q",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"Q",
    L"l",
    L"p",
    L"",
    L"",
    L"a",
    L"",
    L"",
    L"",
    L"p",
    L"u",
    L"",
    L"",
    L"",
    L"B",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"G",
    L"H",
    L"|",
    L"",
    L"",
    L"",
    L"P",
    L"c",
    L"p",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"F",
    L"N",
    L"R",
    L"d",
    L"j",
    L"s",
    L"",
    L"",
    L"",
    L"t",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"C",
    L"Q",
    L"e",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"Y",
    L"u",
    L"",
    L"",
    L"",
    L"",
    L"",
    L"U",
    L"",
    L"",
    L"e",
    L"s",
    L"",
    L"\\",
    L"k"
};

DWORD CProperNoun::m_dwTotalSurnameNum = sizeof(m_pwszSurname) / sizeof(m_pwszSurname[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht2\srcs\rulelex.h ===
#ifndef _RULE_LEXICON_H_
#define _RULE_LEXICON_H_

class CRuleLexicon {
public:
    CRuleLexicon();
    ~CRuleLexicon();

    BOOL IsAWord(LPCWSTR lpsString, INT nLength);
};

typedef CRuleLexicon *PCRuleLexicon;

#else

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht2\srcs\rulelex.cpp ===
#include <windows.h>
#include "scntable.h"
#include "RuleLex.H"

CRuleLexicon::CRuleLexicon()
{
}

CRuleLexicon::~CRuleLexicon()
{
}

BOOL CRuleLexicon::IsAWord(
    LPCWSTR lpwszString,
    INT nLength)
{
    DFAState State;
    WCHAR wc;
    INT nCurrPos = 0;
    Transition t;

    do {
        State = g_nStartState;
        while (nCurrPos <= nLength) {
            if (nCurrPos == nLength) {
                ++nCurrPos;
                wc = ' ';
            } else {
                wc = lpwszString[nCurrPos++];
            }
            if (!(g_uFirstChar <= wc && wc <= g_uLastChar)) {
                return FALSE;
            }
            t = g_sMinimalDFA[State - 1][g_CharClass[wc - g_uFirstChar] - 1];
            switch(t.Action) {
            case Move:
                if (0 == t.NextState) {
                    return FALSE;
                } else {
                    State = t.NextState;
                }
                break;

            case Error:
                return FALSE;
                break;

            case Halt:
                if (t.Major && (nCurrPos > nLength)) {
                    return TRUE;
                } else {
                    return FALSE;
                }
                break;

            default:
                return FALSE;
            }
        }
    } while (nCurrPos <= nLength);

    if (nCurrPos == nLength) {
        return TRUE;
    } else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht2\srcs\lexmgr.h ===
#ifndef __LEXMGR_H_
#define __LEXMGR_H_

#define WORD_NUM_TO_BUILD_SIGNATURE     0
#define IME_REGWORD_STYLE_USER_PHRASE   (IME_REGWORD_STYLE_USER_FIRST + 0)
#define EUDP_GROW_NUMBER                30 

class CProperNoun;

// note if use sizeof(), struct must be 8 bytes alignment. 
typedef struct tagSWordInfo {
    LPWSTR  lpwWordString;
    PWORD   pwUnicount;
    PBYTE   pbAttribute;
    PBYTE   pbTerminalCode;
    PBYTE   pbFirstCharSignature;
    PBYTE   pbLastCharSignature;
} SWordInfo, *PSWordInfo;

// note if use sizeof(), struct must be 8 bytes alignment. 
typedef struct tagSWordData {
    LPWSTR    lpwszWordStr;
    WORD      wAttrib;
    WORD      wLen;
} SWordData, *PSWordData;

typedef struct tagSAddInLexicon {
    DWORD       dwWordNumber;
    DWORD       dwMaxWordNumber;
    PSWordData  psWordData;
    WORD        wWordBeginIndex[MAX_CHAR_PER_WORD + 1];
} SAddInLexicon, *PSAddInLexicon;

typedef struct tagSAltWordInfo {
    LPWSTR  lpwWordString;
    PDWORD  pdwGroupID;
} SAltWordInfo, *PSAltWordInfo;

class CCHTLexicon {
public:
    CCHTLexicon();
    ~CCHTLexicon();
    BOOL InitData(HINSTANCE hInstance);

    BOOL GetWordInfo(LPCWSTR lpcwString, DWORD dwLength, PWORD pwUnicount,
        PWORD pwAttrib, PBYTE pbTerminalCode);
    BOOL AddInLexiconInsert(LPCWSTR lpcwEUDPStr, WORD wAttrib);
    DWORD GetAltWord(LPCWSTR lpcwString, DWORD dwLength, LPWSTR* lppwAltWordBuf);
private:
    void LoadEUDP(void);
    void BuildSignatureData(void);
    BOOL GetMainLexiconWordInfo(LPCWSTR lpcwString, DWORD dwLength, PWORD pwUnicount, PBYTE pbAttrib, PBYTE pbTerminalCode);
    BOOL GetAddInWordInfo(LPCWSTR lpcwString, DWORD dwLength, PWORD pwUnicount, PWORD pwAttrib, PBYTE pbTerminalCode);
    INT  GetAddInWordInfoIndex(LPCWSTR lpcwString, DWORD dwLength);
    BOOL GetAPLexiconWordInfo(LPCWSTR lpcwString, DWORD dwLength, PWORD pwUnicount, PWORD pwAttrib, PBYTE pbTerminalCode, PSAddInLexicon psAPLexicon);
private:
    PSLexFileHeader  m_psLexiconHeader;
    PBYTE            m_pbLexiconBase;
#ifdef CHINESE_PROP_NAME
    CProperNoun*     m_pcPropName;
#endif
    SWordInfo        m_sWordInfo[MAX_CHAR_PER_WORD];
    // special: for EUDP and AP's word
    SAddInLexicon    m_sAddInLexicon;
    // Alternative word
    PBYTE              m_pbAltWordBase;
    PSAltLexFileHeader m_psAltWordHeader;
    SAltWordInfo       m_sAltWordInfo[MAX_CHAR_PER_WORD];
};

typedef CCHTLexicon *PCCHTLexicon;

#else
#endif //__LEXMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht2\srcs\propnoun.h ===
#ifndef __PROPER_NOUN_H__
#define __PROPER_NOUN_H__

#define NAME_LENGTH                     (3)
#define FL_PROPER_NAME_THRESHOLD        (0.0005 * 0.0005)
#define FL_DEFAULT_CHAR_PROBABILITY     (0.00005)

typedef struct {
    DWORD dwUnicode;
    FLOAT flProbability;
} CharProb, *PCharProb;

typedef struct {
    WORD wPrevUnicode;
    WORD wNextUnicode;
} EngName, *PEngName;

typedef struct {
    DWORD dwTotalEngUnicodeNum;
    DWORD dwTotalEngNamePairNum;
    PWORD pwUnicode;
    PEngName pEngNamePair;
} EngNameData, *PEngNameData;


class CProperNoun {
public:
    CProperNoun(HINSTANCE hInstance);
    ~CProperNoun();

    BOOL InitData();

    BOOL IsAProperNoun(LPWSTR lpwszChar, UINT uCount);
    BOOL IsAChineseName(LPCWSTR lpcwszChar, UINT uCount);
    BOOL IsAEnglishName(LPCWSTR lpcwszChar, UINT uCount);

private:
    friend int __cdecl CharCompare(const void *item1, const void *item2);
    friend int __cdecl EngNameCompare(const void *item1, const void *item2);

    DOUBLE      m_dProperNameThreshold;
    PCharProb   m_pCharProb;
    DWORD       m_dwTotalCharProbNum;

    PEngNameData m_pEngNameData;

    static WCHAR m_pwszSurname[][3];
    static DWORD m_dwTotalSurnameNum;

    HANDLE      m_hProcessHeap;
    HINSTANCE   m_hInstance;
};

typedef CProperNoun * PCProperNoun;

#else

#endif  //  __PROPER_NOUN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht2\srcs\scntable.h ===
#ifndef _SCANNER_TABLE_H_
#define _SCANNER_TABLE_H_

typedef INT DFAState;
typedef INT TokenNum;
typedef WCHAR CharClass;
typedef enum { Invalid_DFAAction, Move, Halt, Error } DFAAction;
typedef struct {
    DFAAction Action;
    DFAState NextState;
    TokenNum Major;
} Transition, *PTransition;

const INT g_nNumClasses = 66;

Transition g_sMinimalDFA [][g_nNumClasses] = {

    { { Move ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },
    { Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },
    { Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },
    { Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 },{ Halt ,      1,      0 }},

    { { Halt ,      1,      1 },{ Move ,     44,      1 },{ Move ,     44,      1 },{ Move ,     44,      1 },{ Halt ,     44,      1 },{ Move ,     21,      1 },{ Halt ,     21,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Move ,     32,      1 },{ Move ,      5,      1 },{ Halt ,      5,      1 },{ Halt ,      5,      1 },{ Move ,     14,      1 },
    { Move ,     14,      1 },{ Halt ,     14,      1 },{ Move ,     25,      1 },{ Move ,     16,      1 },{ Move ,     48,      1 },{ Move ,     62,      1 },{ Move ,     72,      1 },{ Halt ,     72,      1 },{ Move ,     82,      1 },{ Move ,     24,      1 },{ Halt ,     24,      1 },{ Move ,     10,      1 },{ Move ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },
    { Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Move ,     52,      1 },{ Move ,     36,      1 }},

    { { Move ,      1,      1 },{ Move ,      2,      1 },{ Move ,     44,      1 },{ Move ,     44,      1 },{ Halt ,     44,      1 },{ Move ,     21,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      6,      1 },{ Move ,      6,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     45,      1 },{ Move ,     45,      1 },{ Move ,      0,      0 },
    { Halt ,     45,      1 },{ Move ,     20,      1 },{ Move ,     66,      1 },{ Move ,     11,      1 },{ Move ,     22,      1 },{ Move ,     38,      1 },{ Move ,     66,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Halt ,     66,      1 },{ Move ,      7,      1 },{ Move ,      8,      1 },{ Move ,     57,      1 },{ Move ,     66,      1 },{ Move ,     32,      1 },{ Move ,      0,      0 },{ Move ,     55,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     43,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     29,      1 },{ Move ,      0,      0 },{ Move ,     12,      1 },{ Move ,     49,      1 },{ Move ,     46,      1 },
    { Move ,      0,      0 },{ Move ,     37,      1 },{ Move ,     15,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     15,      1 },{ Move ,     77,      1 },{ Move ,     77,      1 },{ Move ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },
    { Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },
    { Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },
    { Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 },{ Halt ,     77,      1 }},

    { { Move ,      0,      0 },{ Move ,     74,      1 },{ Move ,     74,      1 },{ Move ,     74,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     70,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     23,      1 },{ Move ,     23,      1 },{ Move ,     23,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     60,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,     39,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     39,      1 },{ Move ,     30,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Move ,     45,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Move ,     20,      1 },{ Halt ,     20,      1 },{ Move ,     11,      1 },{ Move ,     22,      1 },{ Move ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Move ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },
    { Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Move ,     33,      1 },{ Move ,     31,      1 },{ Halt ,     31,      1 },{ Move ,     49,      1 },{ Halt ,     49,      1 },
    { Halt ,     49,      1 },{ Move ,     37,      1 },{ Move ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 }},

    { { Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },
    { Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },
    { Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },
    { Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 }},

    { { Halt ,     15,      1 },{ Move ,     27,      1 },{ Move ,     27,      1 },{ Move ,     27,      1 },{ Move ,     80,      1 },{ Halt ,     80,      1 },{ Halt ,     80,      1 },{ Halt ,     80,      1 },{ Move ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Move ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },
    { Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },
    { Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     19,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     19,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },
    { Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Move ,     49,      1 },{ Halt ,     49,      1 },
    { Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 }},

    { { Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },
    { Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },
    { Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },
    { Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 },{ Halt ,     49,      1 }},

    { { Halt ,     49,      1 },{ Move ,     17,      1 },{ Move ,     17,      1 },{ Move ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Move ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 }},

    { { Move ,      0,      0 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Move ,      0,      0 },{ Move ,     21,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     26,      1 },{ Move ,     26,      1 },{ Move ,     26,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     17,      1 },{ Move ,     17,      1 },{ Move ,     17,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      5,      1 },{ Move ,      5,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,      5,      1 },{ Move ,     30,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Move ,     45,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Move ,     20,      1 },{ Halt ,     20,      1 },{ Move ,     11,      1 },{ Move ,     22,      1 },{ Move ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Halt ,     61,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Move ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },
    { Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Move ,     49,      1 },{ Halt ,     49,      1 },
    { Halt ,     49,      1 },{ Move ,     37,      1 },{ Move ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Halt ,     15,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     15,      1 },{ Move ,     30,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Halt ,     51,      1 },{ Move ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Move ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },
    { Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },{ Halt ,     55,      1 },
    { Halt ,     55,      1 },{ Move ,     37,      1 },{ Move ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 }},

    { { Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },
    { Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },
    { Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },
    { Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 },{ Halt ,     15,      1 }},

    { { Move ,      0,      0 },{ Move ,     54,      1 },{ Move ,     54,      1 },{ Move ,     54,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Halt ,     54,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     32,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,     37,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     23,      1 },{ Move ,     23,      1 },{ Move ,     23,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     60,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Halt ,     60,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     60,      1 },{ Move ,     24,      1 },{ Move ,     24,      1 },{ Move ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },
    { Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },
    { Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },
    { Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 },{ Halt ,     24,      1 }},

    { { Halt ,     24,      1 },{ Move ,     78,      1 },{ Move ,     78,      1 },{ Move ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },
    { Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },
    { Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },
    { Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 },{ Halt ,     78,      1 }},

    { { Move ,      0,      0 },{ Move ,     26,      1 },{ Move ,     26,      1 },{ Move ,     26,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,     75,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     48,      1 },{ Move ,     62,      1 },{ Move ,     72,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     27,      1 },{ Move ,     27,      1 },{ Move ,     27,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      5,      1 },{ Move ,      5,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     50,      1 },{ Halt ,     50,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Halt ,     50,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     28,      1 },{ Move ,     28,      1 },{ Move ,     28,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      5,      1 },{ Move ,      5,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     14,      1 },{ Halt ,     14,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     18,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     18,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Halt ,     51,      1 },{ Move ,     21,      1 },{ Halt ,     21,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Move ,     52,      1 },{ Move ,     36,      1 }},

    { { Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },
    { Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },
    { Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Move ,     33,      1 },{ Halt ,     33,      1 },{ Halt ,     33,      1 },{ Halt ,     33,      1 },{ Halt ,     33,      1 },
    { Halt ,     33,      1 },{ Halt ,     33,      1 },{ Halt ,     33,      1 },{ Halt ,     33,      1 },{ Halt ,     33,      1 },{ Halt ,     33,      1 },{ Halt ,     33,      1 }},

    { { Move ,      0,      0 },{ Move ,     24,      1 },{ Move ,     24,      1 },{ Move ,     24,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     24,      1 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },
    { Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },
    { Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Halt ,     64,      1 },{ Move ,     46,      1 },
    { Halt ,     46,      1 },{ Halt ,     46,      1 },{ Halt ,     46,      1 },{ Halt ,     46,      1 },{ Halt ,     46,      1 },{ Halt ,     46,      1 },{ Halt ,     46,      1 }},

    { { Halt ,     46,      1 },{ Move ,     28,      1 },{ Move ,     28,      1 },{ Move ,     28,      1 },{ Halt ,     28,      1 },{ Halt ,     28,      1 },{ Halt ,     28,      1 },{ Halt ,     28,      1 },{ Move ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Move ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },
    { Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },
    { Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 },{ Halt ,     67,      1 }},

    { { Halt ,     67,      1 },{ Move ,     42,      1 },{ Move ,     42,      1 },{ Move ,     42,      1 },{ Halt ,     42,      1 },{ Halt ,     42,      1 },{ Halt ,     42,      1 },{ Halt ,     42,      1 },{ Move ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Move ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },
    { Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },
    { Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 },{ Halt ,     66,      1 }},

    { { Move ,      0,      0 },{ Move ,     87,      1 },{ Move ,     87,      1 },{ Move ,     87,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     87,      1 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Halt ,     64,      1 },{ Move ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },
    { Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },
    { Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },
    { Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 }},

    { { Move ,      0,      0 },{ Move ,     30,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     45,      1 },{ Move ,     45,      1 },{ Move ,      0,      0 },
    { Halt ,     45,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     32,      1 },{ Move ,      0,      0 },{ Move ,     55,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     50,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     46,      1 },
    { Move ,      0,      0 },{ Move ,     37,      1 },{ Move ,     15,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     23,      1 },{ Move ,     23,      1 },{ Move ,     23,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     60,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     60,      1 },{ Move ,     40,      1 },{ Move ,     40,      1 },{ Move ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },
    { Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },
    { Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },
    { Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 },{ Halt ,     40,      1 }},

    { { Move ,      0,      0 },{ Move ,     41,      1 },{ Move ,     41,      1 },{ Move ,     41,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,     75,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     62,      1 },{ Move ,     72,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     42,      1 },{ Move ,     42,      1 },{ Move ,     42,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      5,      1 },{ Move ,      5,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     50,      1 },{ Halt ,     50,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     73,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     73,      1 },{ Move ,     44,      1 },{ Move ,     44,      1 },{ Move ,     44,      1 },{ Halt ,     44,      1 },{ Move ,     21,      1 },{ Halt ,     21,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Move ,     32,      1 },{ Move ,      5,      1 },{ Halt ,      5,      1 },{ Halt ,      5,      1 },{ Move ,     14,      1 },
    { Move ,     14,      1 },{ Halt ,     14,      1 },{ Move ,     25,      1 },{ Move ,     16,      1 },{ Move ,     48,      1 },{ Move ,     62,      1 },{ Move ,     72,      1 },{ Halt ,     72,      1 },{ Move ,     82,      1 },{ Move ,     24,      1 },{ Halt ,     24,      1 },{ Move ,     10,      1 },{ Move ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },
    { Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Halt ,     50,      1 },{ Move ,     52,      1 },{ Move ,     36,      1 }},

    { { Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },
    { Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },
    { Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },
    { Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 },{ Halt ,     36,      1 }},

    { { Halt ,     36,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },
    { Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Halt ,     51,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Move ,     37,      1 },{ Halt ,     37,      1 },{ Halt ,     37,      1 },{ Halt ,     37,      1 },{ Halt ,     37,      1 },{ Halt ,     37,      1 }},

    { { Halt ,     37,      1 },{ Move ,     17,      1 },{ Move ,     17,      1 },{ Move ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },
    { Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },
    { Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },
    { Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 }},

    { { Move ,      0,      0 },{ Move ,     41,      1 },{ Move ,     41,      1 },{ Move ,     41,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     64,      1 },{ Move ,     63,      1 },{ Move ,     63,      1 },{ Move ,     63,      1 },{ Halt ,     63,      1 },{ Halt ,     63,      1 },{ Halt ,     63,      1 },{ Halt ,     63,      1 },{ Move ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 }},

    { { Halt ,     58,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Halt ,     51,      1 },{ Move ,     21,      1 },{ Halt ,     21,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Move ,     52,      1 },{ Move ,     36,      1 }},

    { { Move ,      0,      0 },{ Move ,     59,      1 },{ Move ,     59,      1 },{ Move ,     59,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     76,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     53,      1 },{ Move ,     53,      1 },{ Move ,     53,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Halt ,     53,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     53,      1 },{ Move ,     54,      1 },{ Move ,     54,      1 },{ Move ,     54,      1 },{ Halt ,     54,      1 },{ Move ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },
    { Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Move ,     79,      1 },{ Move ,     90,      1 }},

    { { Move ,      0,      0 },{ Move ,     86,      1 },{ Move ,     86,      1 },{ Move ,     86,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     32,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     56,      1 },{ Move ,     56,      1 },{ Move ,     56,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,     75,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     72,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     34,      1 },{ Move ,     50,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     50,      1 },{ Move ,     17,      1 },{ Move ,     17,      1 },{ Move ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Halt ,     17,      1 },{ Move ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },
    { Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },
    { Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },
    { Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 }},

    { { Halt ,     47,      1 },{ Move ,     59,      1 },{ Move ,     59,      1 },{ Move ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },
    { Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Halt ,     59,      1 },{ Move ,     76,      1 },{ Halt ,     76,      1 },{ Halt ,     76,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 }},

    { { Move ,      0,      0 },{ Move ,     53,      1 },{ Move ,     53,      1 },{ Move ,     53,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     30,      1 },{ Move ,     51,      1 },{ Move ,     51,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     45,      1 },{ Move ,     45,      1 },{ Move ,      0,      0 },
    { Halt ,     45,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     32,      1 },{ Move ,      0,      0 },{ Move ,     55,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     46,      1 },
    { Move ,      0,      0 },{ Move ,     37,      1 },{ Move ,     15,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     56,      1 },{ Move ,     56,      1 },{ Move ,     56,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     56,      1 },{ Move ,     63,      1 },{ Move ,     63,      1 },{ Move ,     63,      1 },{ Halt ,     63,      1 },{ Halt ,     63,      1 },{ Halt ,     63,      1 },{ Halt ,     63,      1 },{ Move ,     47,      1 },{ Halt ,     47,      1 },{ Halt ,     47,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Move ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },
    { Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Halt ,     58,      1 },{ Move ,      5,      1 },{ Move ,      5,      1 },{ Halt ,      5,      1 },{ Halt ,      5,      1 },{ Move ,     14,      1 },
    { Move ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },
    { Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 },{ Halt ,     14,      1 }},

    { { Halt ,     14,      1 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Move ,     64,      1 },{ Halt ,     64,      1 },{ Move ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },
    { Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },
    { Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },
    { Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 },{ Halt ,     21,      1 }},

    { { Move ,      0,      0 },{ Move ,     65,      1 },{ Move ,     65,      1 },{ Move ,     65,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,     75,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     50,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     14,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     14,      1 },{ Move ,     68,      1 },{ Move ,     68,      1 },{ Move ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },
    { Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Halt ,     68,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 }},

    { { Move ,      0,      0 },{ Move ,     69,      1 },{ Move ,     69,      1 },{ Move ,     69,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Halt ,     69,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     34,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     34,      1 },{ Move ,     71,      1 },{ Move ,     71,      1 },{ Move ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },
    { Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Halt ,     71,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 }},

    { { Move ,      0,      0 },{ Move ,     65,      1 },{ Move ,     65,      1 },{ Move ,     65,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Halt ,     65,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     65,      1 },{ Move ,     74,      1 },{ Move ,     74,      1 },{ Move ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },
    { Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },
    { Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Halt ,     74,      1 },{ Move ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },
    { Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 },{ Halt ,     35,      1 }},

    { { Halt ,     35,      1 },{ Move ,     69,      1 },{ Move ,     69,      1 },{ Move ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },
    { Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },
    { Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },
    { Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 },{ Halt ,     69,      1 }},

    { { Move ,      0,      0 },{ Move ,     68,      1 },{ Move ,     68,      1 },{ Move ,     68,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     77,      1 },{ Move ,     77,      1 },{ Move ,     77,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     81,      1 },{ Move ,     40,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     13,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     78,      1 },{ Move ,     78,      1 },{ Move ,     78,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     89,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     71,      1 },{ Move ,     71,      1 },{ Move ,     71,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     32,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Halt ,     32,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     32,      1 },{ Move ,     84,      1 },{ Move ,     84,      1 },{ Move ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },
    { Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },
    { Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },
    { Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 },{ Halt ,     84,      1 }},

    { { Halt ,     84,      1 },{ Move ,     83,      1 },{ Move ,     83,      1 },{ Move ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },
    { Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },
    { Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },
    { Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 },{ Halt ,     83,      1 }},

    { { Move ,      0,      0 },{ Move ,     83,      1 },{ Move ,     83,      1 },{ Move ,     83,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     24,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     84,      1 },{ Move ,     84,      1 },{ Move ,     84,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     40,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     85,      1 },{ Move ,     85,      1 },{ Move ,     85,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Halt ,     85,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},

    { { Halt ,     85,      1 },{ Move ,     86,      1 },{ Move ,     86,      1 },{ Move ,     86,      1 },{ Halt ,     86,      1 },{ Move ,     21,      1 },{ Halt ,     21,      1 },{ Move ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },
    { Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Halt ,     45,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Move ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Halt ,      9,      1 },{ Move ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },
    { Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Halt ,     32,      1 },{ Move ,     79,      1 },{ Move ,     90,      1 }},

    { { Move ,      0,      0 },{ Move ,     87,      1 },{ Move ,     87,      1 },{ Move ,     87,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     52,      1 },{ Move ,      0,      0 }},

    { { Move ,      0,      0 },{ Move ,     88,      1 },{ Move ,     88,      1 },{ Move ,     88,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,     79,      1 },{ Move ,      0,      0 }},

    { { Halt ,     79,      1 },{ Move ,     85,      1 },{ Move ,     85,      1 },{ Move ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },
    { Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },
    { Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },
    { Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 },{ Halt ,     85,      1 }},

    { { Move ,      0,      0 },{ Move ,     88,      1 },{ Move ,     88,      1 },{ Move ,     88,      1 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },
    { Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 },{ Move ,      0,      0 }},
};
const UINT g_uFirstChar = 9;  //  included
const UINT g_uLastChar = 123;  //  included
const WCHAR g_CharClass [] = {
    1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 65, 0, 0, 64, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 0,
    0, 66, 0, 0, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
    17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 0, 0, 0, 0, 0, 54, 28, 29, 30,
    31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
    51, 52, 53, 0
};
DFAState g_nStartState = 3;

#else  //  !_SCANNER_TABLE_H_

#endif //  _SCANNER_TABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht2\srcs\regcom.cpp ===
#include <windows.h>
#include "rulelex.h"
#include "lexicon.h"
#include "LexMgr.h"
#include "chtbrkr.h"
#include "IWBrKr.h"

TCHAR tszLangSpecificKey[] = TEXT("System\\CurrentControlSet\\Control\\ContentIndex\\Language\\Chinese_Traditional");

HRESULT COMRegister(
    BOOL fRegister)
{
    HKEY hKey;
    WCHAR tszCLSID[MAX_PATH];
    TCHAR tszBuf[MAX_PATH * 2];
    HRESULT hr = S_OK;

//HKEY_CLASSES_ROOT\\CLSID\\CLSID_CHTBRKR, {E1B6B375-3412-11D3-A9E2-00AA0059F9F6};
    StringFromGUID2(CLSID_CHTBRKR, tszCLSID, sizeof(tszCLSID));
    lstrcpy(tszBuf, TEXT("CLSID\\"));
    lstrcat(tszBuf, tszCLSID);
    if (fRegister) {
        lstrcat(tszBuf, TEXT("\\InprocServer32"));
        if (RegCreateKey(HKEY_CLASSES_ROOT, tszBuf, &hKey) != ERROR_SUCCESS) {
            hr = S_FALSE;
            goto _exit;
        }
        RegSetValueEx(hKey, NULL, 0, REG_SZ, (LPBYTE)g_tszModuleFileName, 
        lstrlen(g_tszModuleFileName) * sizeof(TCHAR));
        RegCloseKey(hKey);
    } else {
        RegDeleteKey(HKEY_CLASSES_ROOT, tszBuf);
    }

// HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\ContentIndex\\
//     Language\\Chinese_Traditional
/*
    if (RegCreateKey(HKEY_LOCAL_MACHINE, tszLangSpecificKey, &hKey) != ERROR_SUCCESS) {
        hr = S_FALSE;
        goto _exit;        
    }
    if (fRegister) {
        RegSetValueEx(hKey, TEXT("WBreakerClass"), 0, REG_SZ, (LPBYTE)tszCLSID, 
            lstrlen(tszCLSID) * sizeof (TCHAR));
    } else {
        RegDeleteValue(hKey, TEXT("WBreakerClass")); 
    }
*/
_exit:
    return hr;

}

STDAPI DllRegisterServer(void)
{
    return COMRegister(TRUE);
}

STDAPI DllUnregisterServer(void) 
{
    return COMRegister(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\cht2\srcs\wordbrkr.h ===
#ifndef YYSTYPE
#define YYSTYPE int
#endif
#define	tSubZero	258
#define	tDegree	259
#define	tSection	260
#define	tTunnel	261
#define	tLane	262
#define	tDash	263
#define	tNumber	264
#define	tFloor	265
#define	tMinute	266
#define	tSecond	267
#define	tThis	268
#define	tNoise	269
#define	tDay1	270
#define	tDay2	271
#define	tYear	272
#define	tFirst	273
#define	tMonth	274
#define	tMonthly	275
#define	tHour1	276
#define	tHour2	277
#define	tHour3	278
#define	tQuarter	279
#define	tAny	280
#define	tOther1	281
#define	tOther2	282
#define	tRemain	283
#define	tOf	284
#define	tHalf	285
#define	tTh	286
#define	tThat	287
#define	tClass	288
#define	tAtMost	289
#define	tAtLeast	290
#define	tSeveral	291
#define	tSquare	292
#define	tCube	293
#define	tOver	294
#define	tAnd	295
#define	tWeakStrong	296
#define	tMoreThan1	297
#define	tMoreThan2	298
#define	tMoreThan3	299
#define	tNo	300
#define	tNot	301
#define	tOn	302
#define	tDesc	303
#define	tPnm	304
#define	tNdabe	305
#define	tNdaac	306
#define	tNdaad	307
#define	tNdaas	308
#define	tNdabb	309
#define	tNdabd1	310
#define	tNdabf	311
#define	tTpnm	312
#define	tWq	313
#define	tQq	314
#define	tDq	315
#define	tPq	316
#define	tDd	317
#define	tOs	318
#define	tUd	319
#define	tPn	320
#define	tEach	321
#define	tDs	322
#define	tTmp	323
#define	tOther	324
#define	tTdm10_	325
#define	tFirst1	326
#define	tFirst2	327
#define	tTdm4_	328
#define	tEach1	329
#define	tEach2	330
#define	tTdm2_3_	331
#define	tTdm6_	332
#define	tHour	333
#define	tAt	334
#define	tMore	335
#define	tDot	336
#define	tError	337


extern YYSTYPE yylval;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\tracer\src\cintf.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  CIntf.cpp
//      Purpose  :  Redirect all the C calls to the global tracer.
//
//      Project  :  Tracer
//
//      Author   :  urib
//
//      Log:
//          Dec  2 1996 urib Creation
//          Dec 10 1996 urib Fix TraceSZ to VaTraceSZ.
//          Feb 11 1997 urib Support UNICODE format string in the Trace.
//          Jan 20 1999 urib  Assert value is checked in the macro.
//
////////////////////////////////////////////////////////////////////////////////

#include "Tracer.h"

#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)

void TraceAssert(  PSZ pszTestValue,
                   PSZ pszFile,
                   int iLineNo)
{
    g_pTracer->TraceAssert(pszTestValue, pszFile, iLineNo);
}
void TraceAssertSZ(PSZ pszTestValue, PSZ pszText, PSZ pszFile, int iLineNo)
{
    g_pTracer->TraceAssertSZ(pszTestValue, pszText, pszFile, iLineNo);
}
void TraceAssertWSZ(PSZ pszTestValue, PWSTR pwszText, PSZ pszFile, int iLineNo)
{
    char    rchBuffer[1000];
    wcstombs(rchBuffer, pwszText, 1000);
    rchBuffer[1000 - 1] = '\0';

    g_pTracer->TraceAssertSZ(pszTestValue, rchBuffer, pszFile, iLineNo);
}

BOOL IsFailure(BOOL fTestValue, PSZ pszFile, int iLineNo)
{
    return g_pTracer->IsFailure(fTestValue, pszFile, iLineNo);
}

BOOL IsBadAlloc (void* pTestValue, PSZ pszFile, int iLineNo)
{
    return g_pTracer->IsBadAlloc(pTestValue, pszFile, iLineNo);
}

BOOL IsBadHandle(HANDLE hTestValue, PSZ pszFile, int iLineNo)
{
    return g_pTracer->IsBadHandle(hTestValue, pszFile, iLineNo);
}

BOOL IsBadResult(HRESULT hrTestValue, PSZ pszFile, int iLineNo)
{
    return g_pTracer->IsBadResult(hrTestValue, pszFile, iLineNo);
}

void TraceSZ(ERROR_LEVEL el, TAG tag, PSZ pszFormatString, ...)
{
    va_list arglist;

    va_start(arglist, pszFormatString);

    g_pTracer->VaTraceSZ(0, "File: not supported in c files", 0, el, tag, pszFormatString, arglist);
}

void TraceWSZ(ERROR_LEVEL el, TAG tag, PWSTR pwszFormatString, ...)
{
    va_list arglist;

    va_start(arglist, pwszFormatString);

    g_pTracer->VaTraceSZ(0, "File: not supported in c files", 0, el, tag, pwszFormatString, arglist);
}

HRESULT RegisterTagSZ(PSZ pszTagName, TAG* ptag)
{
    return g_pTracer->RegisterTagSZ(pszTagName, *ptag);
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\tracer\src\tracerdefault.h ===
#ifndef _TRACER_DEFAULT_H_
#define _TRACER_DEFAULT_H_

#define LOG_FILE_SIZE               0x80000
#define MAX_TAG_NUMBER              5000

#define DEVICE_FLAG_DEFAULT           TRACER_DEVICE_FLAG_FILE
#define TRACER_ERROR_LEVEL_DEFAULT    elVerbose
#define TRACER_ASSERT_LEVEL_DEFAULT   (ASSERT_LEVEL_MESSAGE | ASSERT_LEVEL_POPUP)
#define PRINT_LOCATION_DEFAULT        0
#define PRINT_PROGRAM_NAME_DEFAULT    1
#define PRINT_TIME_DEFAULT            1
#define PRINT_THREAD_ID_DEFAULT       1
#define PRINT_ERROR_LEVEL_DEFAULT     0
#define PRINT_TAG_ID_DEFAULT          0
#define PRINT_TAG_NAME_DEFUALT        1
#define PRINT_PROCCESS_ID_DEFAULT     0

#define TAG_ERROR_LEVEL_DEFAULT       elError

#endif // _TRACER_DEFAULT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\tracer\src\tracer.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  Tracer.cpp
//      Purpose  :  Redirect the tracing to the global tracer.
//
//      Project  :  Tracer
//
//      Author   :  t-urib
//
//      Log:
//          Jan 22 1996 t-urib Creation
//          Jan 27 1996 t-urib Add release/debug support.
//          Dec  8 1996 urib   Clean Up
//          Dec 10 1996 urib  Fix TraceSZ to VaTraceSZ.
//          Feb 11 1997 urib  Support UNICODE format string.
//          Jan 20 1999 urib  Assert macro checks the test value.
//          Feb 22 1999 urib  Fix const declarations.
//          Nov 15 2000 victorm  Add tracer restriction check to Is...() functions
//
////////////////////////////////////////////////////////////////////////////////

#include "Tracer.h"
#include "Tracmain.h"


#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)

////////////////////////////////////////////////////////////////////////////////
//
//  class CTracer implementation
//
////////////////////////////////////////////////////////////////////////////////

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::~CTracer
//      Purpose  :  It's good to define empty virtual constructor on base types.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib Clean Up
//
//////////////////////////////////////////////////////////////////////////////*/
CTracer::~CTracer()
{
}


/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::Free
//      Purpose  :  To call the deletor passed in the constructor.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib Clean Up
//
//////////////////////////////////////////////////////////////////////////////*/
void
CTracer::Free()
{
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::TraceSZ
//      Purpose  :  To log the printf formatted data according to the tag and
//                    error level
//
//      Parameters:
//          [in]    DWORD       dwError
//          [in]    LPCSTR      pszFile,
//          [in]    int         iLine,
//          [in]    ERROR_LEVEL el   the tag and el parameters are used to
//                                    decide what traces will take place and to
//                                    what devices.
//          [in]    TAG         tag
//          [in]    PSZ/PWSTR   pszFormatString The traced data
//          [in]    ...                         Arguments (like in printf)
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib Clean Up
//          Feb 11 1997 urib Support UNICODE format string.
//
//////////////////////////////////////////////////////////////////////////////*/
void
CTracer::TraceSZ(
    DWORD       dwError,
    LPCSTR      pszFile,
    int         iLine,
    ERROR_LEVEL el,
    TAG         tag,
    LPCSTR      pszFormatString,
    ...)
{
    va_list arglist;

    va_start(arglist, pszFormatString);

    g_pTracer->VaTraceSZ(dwError, pszFile, iLine, el, tag, pszFormatString, arglist);
}

void
CTracer::TraceSZ(
    DWORD       dwError,
    LPCSTR      pszFile,
    int         iLine,
    ERROR_LEVEL el,
    TAG         tag,
    PCWSTR      pwszFormatString,
    ...)
{
    va_list arglist;

    va_start(arglist, pwszFormatString);

    g_pTracer->VaTraceSZ(dwError, pszFile, iLine, el, tag, pwszFormatString, arglist);
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::VaTraceSZ
//      Purpose  :
//
//      Parameters:
//          [in]    ERROR_LEVEL el   the tag and el parameters are used to
//                                    decide what traces will take place and to
//                                    what devices.
//          [in]    TAG         tag
//          [in]    PSZ/PWSTR   pszFormatString The traced data
//          [in]    va_list     arglist         Arguments
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib Clean Up
//          Dec 10 1996 urib Fix TraceSZ to VaTraceSZ.
//          Feb 11 1997 urib Support UNICODE format string.
//
//////////////////////////////////////////////////////////////////////////////*/
void
CTracer::VaTraceSZ(
    DWORD       dwError,
    LPCSTR      pszFile,
    int         iLine,
    ERROR_LEVEL el,
    TAG         tag,
    LPCSTR      pszFormatString,
    va_list     arglist)
{
    g_pTracer->VaTraceSZ(
        dwError,
        pszFile,
        iLine,
        el,
        tag,
        pszFormatString,
        arglist);
}

void
CTracer::VaTraceSZ(
    DWORD       dwError,
    LPCSTR      pszFile,
    int         iLine,
    ERROR_LEVEL el,
    TAG         tag,
    PCWSTR      pwszFormatString,
    va_list     arglist)
{
    g_pTracer->VaTraceSZ(
        dwError,
        pszFile,
        iLine,
        el,
        tag,
        pwszFormatString,
        arglist);
}



/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::RawVaTraceSZ
//      Purpose  :  Traces without any extra information.
//
//      Parameters:
//          [in]    PSZ/PWSTR   pszFormatString The traced data
//          [in]    va_list     arglist         Arguments
//
//      Returns  :   [N/A]
//
//      Log:
//          Jun 11 1999 micahk Create
//
//////////////////////////////////////////////////////////////////////////////*/
void
CTracer::RawVaTraceSZ(
    LPCSTR      pszFormatString,
    va_list     arglist)
{
    g_pTracer->RawVaTraceSZ(
        pszFormatString,
        arglist);
}

void
CTracer::RawVaTraceSZ(
    PCWSTR      pwszFormatString,
    va_list     arglist)
{
    g_pTracer->RawVaTraceSZ(
        pwszFormatString,
        arglist);
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::RegisterTagSZ
//      Purpose  :  To register the tag in the registry and return a tag ID.
//
//      Parameters:
//          [in]    LPCSTR   pszTagName - the tag name.
//          [out]   TAG&  tag        - the id returned for that name.
//
//      Returns  :   HRESULT - Standard error code
//
//      Log:
//          Dec  8 1996 urib Clean Up
//
//////////////////////////////////////////////////////////////////////////////*/
HRESULT
CTracer::RegisterTagSZ(LPCSTR pszTagName, TAG& tag)
{
    return g_pTracer->RegisterTagSZ(pszTagName, tag);
}


/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::TraceAssertSZ
//      Purpose  :  To trace the assert if happened.
//
//      Parameters:
//          [in]  LPCSTR pszTestSring - the expression text
//          [in]  LPCSTR pszText - some data attached
//          [in]  LPCSTR pszFile - the source file
//          [in]        int iLine - the source line
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib  Clean Up
//          Jan 20 1999 urib  Assert macro checks the test value.
//
//////////////////////////////////////////////////////////////////////////////*/
void
CTracer::TraceAssertSZ(
    LPCSTR pszTestSring,
    LPCSTR pszText,
    LPCSTR pszFile,
    int iLine)
{
    g_pTracer->TraceAssertSZ(pszTestSring, pszText, pszFile, iLine);
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::TraceAssert
//      Purpose  :  To trace the assert if happened.
//
//      Parameters:
//          [in]    LPCSTR  pszTestSring - the expression text
//          [in]    LPCSTR  pszFile - the source file
//          [in]    int     iLine - the source line
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib  Clean Up
//          Jan 20 1999 urib  Assert macro checks the test value.
//
//////////////////////////////////////////////////////////////////////////////*/
void
CTracer::TraceAssert(
    LPCSTR pszTestSring,
    LPCSTR pszFile,
    int iLine)
{
    TraceAssertSZ(pszTestSring, "", pszFile, iLine);
}




////////////////////////////////////////////////////////////////////////////////
//
//  Is bad functions - return TRUE if the expression checked is bad!
//
////////////////////////////////////////////////////////////////////////////////

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::IsBadAlloc
//      Purpose  :  Do  what is needed when a memory allocatin fails.
//
//      Parameters:
//          [in]    void    *ptr
//          [in]    LPCSTR  pszFile - source file
//          [in]    int     iLine   - line in source file
//
//      Returns  :   BOOL returns if the ptr is a bad one.
//
//      Log:
//          Dec  8 1996 urib Clean Up
//
//////////////////////////////////////////////////////////////////////////////*/
BOOL
CTracer::IsBadAlloc(
    void    *ptr,
    LPCSTR  pszFile,
    int     iLine)
{
    if(BAD_POINTER(ptr))
    {
        if (CheckTraceRestrictions(elError, TAG_ERROR))
		{
            TraceSZ(0,pszFile, iLine, elError, TAG_ERROR,
                    "Memory allocation failed");
        }
        return(TRUE);
    }
    return(FALSE);
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::IsBadHandle
//      Purpose  :  Do  what is needed when a handle is not valid
//
//      Parameters:
//          [in]    HANDLE  h
//          [in]    LPCSTR  pszFile - source file
//          [in]    int     iLine   - line in source file
//
//      Returns  :   BOOL returns if the handle is a bad one.
//
//      Log:
//          Dec  8 1996 urib Clean Up
//
//////////////////////////////////////////////////////////////////////////////*/
BOOL
CTracer::IsBadHandle(
    HANDLE  h,
    LPCSTR  pszFile,
    int     iLine)
{
    if(BAD_HANDLE(h))
    {
        if (CheckTraceRestrictions(elError, TAG_WARNING))
		{
            TraceSZ(0,pszFile, iLine, elError, TAG_WARNING,
                    "Handle is not valid");
        }
        return(TRUE);
    }
    return(FALSE);
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::IsBadResult
//      Purpose  :  Do  what is needed when a functions returns bad result.
//
//      Parameters:
//          [in]    HRESULT hr
//          [in]    LPCSTR  pszFile - source file
//          [in]    int     iLine   - line in source file
//
//      Returns  :   BOOL returns if the result is an error.
//
//      Log:
//          Dec  8 1996 urib Clean Up
//
//////////////////////////////////////////////////////////////////////////////*/
BOOL
CTracer::IsBadResult(
    HRESULT hr,
    LPCSTR  pszFile,
    int     iLine)
{
    if(BAD_RESULT(hr))
    {
        if (CheckTraceRestrictions(elError, TAG_WARNING))
		{
			TraceSZ(hr,pszFile, iLine, elError, TAG_WARNING,
					"Error encountered");
		}
        return(TRUE);
    }
    return(FALSE);
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CTracer::IsFailure
//      Purpose  :  Do  what is needed when a API returns false
//
//      Parameters:
//          [in]        BOOL    fSuccess
//          [in]  LPCSTR     pszFile - source file
//          [in]        int     iLine   - line in source file
//
//      Returns  :   BOOL returns if the return value is false.
//
//      Log:
//          Dec  8 1996 urib Clean Up
//
//////////////////////////////////////////////////////////////////////////////*/
BOOL
CTracer::IsFailure(
    BOOL    fSuccess,
    LPCSTR  pszFile,
    int     iLine)
{
    if(!fSuccess)
    {
        if (CheckTraceRestrictions(elError, TAG_WARNING))
		{
            DWORD   dwError = GetLastError();
    
            char*   pszMessageBuffer;
    
            FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                dwError,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (PSZ)&pszMessageBuffer,
                0,
                NULL );
    
            TraceSZ(dwError,pszFile, iLine, elError, TAG_WARNING,
                    "return code is %s,"
                    " GetLastError returned %d - %s ",
                    (fSuccess ? "TRUE" : "FALSE"),
                    dwError,
                    pszMessageBuffer);
    
            // Free the buffer allocated by the system
            LocalFree( pszMessageBuffer );
        }

    }
    return(!fSuccess);
}


#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\tracer\src\global.cpp ===
#include <windows.h>
#include "globvars.hxx"

// The code below is from globvars.cxx which is a part of pkmutill.lib
// I copied it here in order not to muck with precompiled header objects required to link with pkmutill.lib

#pragma warning(disable:4073)
#pragma init_seg(lib)

BOOL	g_fIsNT = TRUE;

// disable compiler warning which just tells us we're putting stuff in the library 
// initialization section.

class CInitGlobals
{
public:
    CInitGlobals()
    {
        g_fIsNT = IsNT();
    }
} g_InitGlobals;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\tracer\inc\tracer.h ===
#ifndef _TRACER_H_
#define _TRACER_H_

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <stdarg.h>

//
// global defines.
//

#define MAX_FLAG_NAME 32
#define MAX_TAG_NAME  64

#define DEVICE_FLAG         0
#define ERROR_LEVEL_FLAG    1
#define ASSERT_LEVEL_FLAG   2
#define PRINT_LOCATION      3
#define PRINT_PROGRAM_NAME  4
#define PRINT_TIME          5
#define PRINT_THREAD_ID     6
#define PRINT_ERROR_LEVEL   7
#define PRINT_TAG_ID        8
#define PRINT_TAG_NAME      9
#define PRINT_PROCESS_ID    10
#define LAST_FLAG           11

#define TRACER_DEVICE_FLAG_FILE         0x00000001L
#define TRACER_DEVICE_FLAG_DEBUGOUT     0x00000002L
#define TRACER_DEVICE_FLAG_STDOUT       0x00000004L
#define TRACER_DEVICE_FLAG_STDERR       0x00000008L

//
// basic classes
//

typedef enum _ERROR_LEVEL
{
    elFirst = 0,
    elCrash,
    elError,
    elWarning,
    elInfo,
    elVerbose,
    elLast
} ERROR_LEVEL;

typedef ULONG TAG;

///////////////////////////////////////////////////////////////////////////////
// CTracerTagEntry
///////////////////////////////////////////////////////////////////////////////
class CTracerTagEntry
{
public:
    CTracerTagEntry() :
        m_TagErrLevel(elFirst)
    {
        m_pszTagName[0] = '\0';
    }

public:
    ERROR_LEVEL m_TagErrLevel;
    char  m_pszTagName[MAX_TAG_NAME];

};

///////////////////////////////////////////////////////////////////////////////
// CTracerFlagEntry
///////////////////////////////////////////////////////////////////////////////

class CTracerFlagEntry
{
public:
    CTracerFlagEntry() :
        m_ulFlagValue(0)
    {
        m_pszName[0] = '\0';
    }

public:
    ULONG m_ulFlagValue;
    char  m_pszName[MAX_FLAG_NAME];
};


///////////////////////////////////////////////////////////////////////////////
// CTracer
///////////////////////////////////////////////////////////////////////////////
typedef enum {
    logUseLogName,
    logUseAppName 
} LogState;

class CTracer
{
  public:

    // The virtual distructor is here to allow derived classes to
    //   define distructors
    virtual ~CTracer();

    // This function deallocates the tracer! it calls the Function pointer
    //   passed in the constructor or if not given - the default
    //   delete operator for the dll.
    virtual void Free();


    // The TraceSZ function output is defined by the tags and error level mode.
    //   The control of this mode is via the registry.
    //   (Default LOCAL_MACHINE\SOFTWARE\Microsoft\Tracer)
    //   TraceSZ gets the mode by calling IsEnabled.
    //-------------------------------------------------------------------------
    // accepts printf format for traces
    virtual void
    TraceSZ(DWORD, LPCSTR, int, ERROR_LEVEL, TAG, LPCSTR, ...);
    virtual void
    TraceSZ(DWORD, LPCSTR, int, ERROR_LEVEL, TAG, PCWSTR, ...);

    // Prints the implements the TraceSZ function.
    virtual void
    VaTraceSZ(DWORD, LPCSTR, int, ERROR_LEVEL, TAG, LPCSTR, va_list);
    virtual void
    VaTraceSZ(DWORD, LPCSTR, int, ERROR_LEVEL, TAG, PCWSTR, va_list);

    // Raw output functions
    virtual void
    RawVaTraceSZ(LPCSTR, va_list);
    virtual void
    RawVaTraceSZ(PCWSTR, va_list);

    // Create or open a new tag for tracing
    virtual HRESULT RegisterTagSZ(LPCSTR, TAG&);

    // Two Assert functions one allows attaching a string.
    //-------------------------------------------------------------------------
    // assert, different implementations possible - gui or text
    virtual void TraceAssertSZ(LPCSTR, LPCSTR, LPCSTR, int);

    // assert, different implementations possible - gui or text
    virtual void TraceAssert(LPCSTR, LPCSTR, int);

    // The following function are used to check return values and validity of
    //   pointers and handles. If the item checked is bad the function will
    //   return TRUE and a trace will be made for that.
    //-------------------------------------------------------------------------
    // Verify a boolean function return code
    virtual BOOL IsFailure(BOOL, LPCSTR, int);

    // verify allocation
    virtual BOOL IsBadAlloc(void*, LPCSTR, int);

    // Verify a Handle
    virtual BOOL IsBadHandle(HANDLE, LPCSTR, int);

    // Verify an OLE hresult function
    virtual BOOL IsBadResult(HRESULT, LPCSTR, int);

  public:

    TAG*       m_ptagNextTagId;
    // A array of tags.
    CTracerTagEntry*   m_aTags;

    // Contains the flags that control wich output devices are used.

    ULONG* m_pulNumOfFlagEntries;
    CTracerFlagEntry*   m_aFlags;

    // log file 

    LogState m_LogState;
    char* m_pszLogName;
};

extern "C" CTracer* g_pTracer;

class CSetLogFile
{
public:
    CSetLogFile()
    {
        g_pTracer->m_LogState = logUseAppName;
    }

    CSetLogFile(char* pszName)
    {
        g_pTracer->m_LogState = logUseLogName;
        g_pTracer->m_pszLogName = pszName;
    }

};
///////////////////////////////////////////////////////////////////////////////
// CTempTrace
///////////////////////////////////////////////////////////////////////////////

class CTempTrace
{
public:
    CTempTrace(LPCSTR  pszFile, int iLine);

    void TraceSZ(ERROR_LEVEL, ULONG, LPCSTR, ...);
    void TraceSZ(ERROR_LEVEL, ULONG, DWORD dwError, LPCSTR, ...);

    void TraceSZ(ERROR_LEVEL, ULONG, PCWSTR, ...);
    void TraceSZ(ERROR_LEVEL, ULONG, DWORD dwError, PCWSTR, ...);

private:

    LPCSTR  m_pszFile;
    int     m_iLine;

};

///////////////////////////////////////////////////////////////////////////////
// CTempTrace1
///////////////////////////////////////////////////////////////////////////////

class CTempTrace1
{
public:
    CTempTrace1(LPCSTR  pszFile, int iLine, TAG tag, ERROR_LEVEL el);

    void TraceSZ(LPCSTR, ...);
    void TraceSZ(DWORD dwError, LPCSTR, ...);

    void TraceSZ(PCWSTR, ...);
    void TraceSZ(DWORD dwError, PCWSTR, ...);

private:

    LPCSTR  m_pszFile;
    int     m_iLine;
    TAG    m_ulTag;
    ERROR_LEVEL m_el;

};

///////////////////////////////////////////////////////////////////////////////
// CLongTrace
///////////////////////////////////////////////////////////////////////////////

class CLongTrace
{
public:
    CLongTrace(LPCSTR  pszFile, int iLine);
    ~CLongTrace();
    BOOL Init(ERROR_LEVEL, TAG);

private:
    BOOL    m_fRelease;
    LPCSTR  m_pszFile;
    int     m_iLine;
};

///////////////////////////////////////////////////////////////////////////////
// CLongTraceOutput
///////////////////////////////////////////////////////////////////////////////

class CLongTraceOutput
{
public:
    CLongTraceOutput(LPCSTR  pszFile, int iLine);

    void TraceSZ(LPCSTR, ...);
    void TraceSZ(PCWSTR, ...);

private:
    LPCSTR  m_pszFile;
    int     m_iLine;
};

///////////////////////////////////////////////////////////////////////////////
// CTracerTag
///////////////////////////////////////////////////////////////////////////////

class CTracerTag
{
#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
  public:

    CTracerTag(PSZ pszTagName)
    {
        HRESULT hrTagRegistrationResult;

        hrTagRegistrationResult = g_pTracer->RegisterTagSZ(pszTagName, m_ulTag);

        if(FAILED(hrTagRegistrationResult))
            throw "Tag could not be registered";

    }

    operator TAG()
    {
        return m_ulTag;
    }

  public:
    TAG m_ulTag;
#else  /* DEBUG */
  public:
    CTracerTag(PSZ){}
#endif /* DEBUG */
};


extern CTracerTag tagError;
extern CTracerTag tagWarning;
extern CTracerTag tagInformation;
extern CTracerTag tagVerbose;
extern CTracerTag tagGeneral;
//
// global defines
//

#define BAD_POINTER(ptr)    (NULL == (ptr))
#define BAD_HANDLE(h)       ((0 == ((HANDLE)h))||   \
                             (INVALID_HANDLE_VALUE == ((HANDLE)h)))
#define BAD_RESULT(hr)      (FAILED(hr))

#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)

#ifdef    __cplusplus

#define CheckTraceRestrictions(el, tag) \
    ((g_pTracer->m_aTags[tag].m_TagErrLevel >= el) && \
    (g_pTracer->m_aFlags[ERROR_LEVEL_FLAG].m_ulFlagValue >= (ULONG)el) && \
    g_pTracer->m_aFlags[DEVICE_FLAG].m_ulFlagValue)

#define Trace(x) \
    {CTempTrace tmp(__FILE__, __LINE__);tmp.TraceSZ x;}

#define Trace1(el, tag, x)    \
    { \
        if (CheckTraceRestrictions(el, tag.m_ulTag)) \
        { \
            CTempTrace1 tmp(__FILE__, __LINE__, tag.m_ulTag, el); \
            tmp.TraceSZ x; \
        } \
    }

#define BeginLongTrace(x)   {CLongTrace tmp(__FILE__, __LINE__);if (tmp.Init x) {
#define LongTrace(x)        {CLongTraceOutput tmp(__FILE__, __LINE__);tmp.TraceSZ x;}
#define EndLongTrace        }}

#define RegisterTag(psz, tag)   g_pTracer->RegisterTagSZ((psz), tag)

#define IS_FAILURE(x)       g_pTracer->IsFailure((x), __FILE__, __LINE__)
#define IS_BAD_ALLOC(x)     g_pTracer->IsBadAlloc((void*)(x), __FILE__, __LINE__)
#define IS_BAD_HANDLE(x)    g_pTracer->IsBadHandle((HANDLE)(x), __FILE__, __LINE__)
#define IS_BAD_RESULT(x)    g_pTracer->IsBadResult((x), __FILE__, __LINE__)

#define Assert(x)           {if (!(x)) {g_pTracer->TraceAssert(#x, __FILE__, __LINE__);}}
#define AssertSZ(x, psz)    {if (!(x)) {g_pTracer->TraceAssertSZ(#x, (PSZ)(psz),__FILE__, __LINE__);}}

#define SET_TRACER(x)       SetTracer(x)

#define SET_TRACER_LOGGING_TO_FILE_OFF g_pTracer->m_aFlags[DEVICE_FLAG].m_ulFlagValue &= ~TRACER_DEVICE_FLAG_FILE;
#define USE_COMMON_LOG_FILE(name)  CSetLogFile SetLogFile(name);

#else  /* __cplusplus */

#define IS_FAILURE(x)       IsFailure((x), __FILE__, __LINE__)
#define IS_BAD_ALLOC(x)     IsBadAlloc((void*)(x), __FILE__, __LINE__)
#define IS_BAD_HANDLE(x)    IsBadHandle((HANDLE)(x), __FILE__, __LINE__)
#define IS_BAD_RESULT(x)    IsBadResult((x), __FILE__, __LINE__)

#define Assert(x)           {if (!(x)) {TraceAssert(#x,__FILE__, __LINE__);}}

#ifdef UNICODE
#define AssertSZ(x, psz)    {if (!(x)) {TraceAssertWSZ(#x, (pwsz), __FILE__, __LINE__);}}
#define Trace(x)            TraceWSZ x
#else
#define AssertSZ(x, psz)    {if (!(x)) {TraceAssertSZ(#x, (psz),__FILE__, __LINE__);}}
#define Trace(x)            TraceSZ x
#endif

#define RegisterTag(psz, tag)   RegisterTagSZ((psz), &(tag))

#endif /* __cplusplus */

#define GIS_FAILURE(x)      IsFailure((x), __FILE__, __LINE__)
#define GIS_BAD_ALLOC(x)    IsBadAlloc((void*)(x), __FILE__, __LINE__)
#define GIS_BAD_HANDLE(x)   IsBadHandle((HANDLE)(x), __FILE__, __LINE__)
#define GIS_BAD_RESULT(x)   IsBadResult((x), __FILE__, __LINE__)

#define GAssert(x)          {if (!(x)) {TraceAssert(#x, __FILE__, __LINE__);}}
#define GAssertSZ(x, psz)   {if (!(x)) {TraceAssertSZ(#x, (PSZ)(psz), __FILE__, __LINE__);}}

#define GTrace(x)           TraceSZ x

#define DECLARE_TAG(name, psz) static CTracerTag  name(psz);
#define DECLARE_GLOBAL_TAG(name, psz) CTracerTag  name(psz);
#define USES_TAG(name) extern CTracerTag name;

#else  // DEBUG

#define IS_FAILURE(x)       (!(x))
#define IS_BAD_ALLOC(x)     BAD_POINTER((void*)(x))
#define IS_BAD_HANDLE(x)    BAD_HANDLE((HANDLE)(x))
#define IS_BAD_RESULT(x)    BAD_RESULT(x)

#define Assert(x)
#define AssertSZ(x, psz)

#define Trace(x)
#define Trace1(el,tag,x)

#define BeginLongTrace(x)   {if (0) {
#define LongTrace(x)        ;
#define EndLongTrace        }}

#define RegisterTag(psz, tag)

#define SET_TRACER(x)
#define SET_TRACER_LOGGING_TO_FILE_OFF
#define USE_COMMON_LOG_FILE(name)  

#define GIS_FAILURE(x)      IS_FAILURE(x)
#define GIS_BAD_ALLOC(x)    IS_BAD_ALLOC(x)
#define GIS_BAD_HANDLE(x)   IS_BAD_HANDLE(x)
#define GIS_BAD_RESULT(x)   IS_BAD_RESULT(x)

#define GAssert(x)          Assert(x)
#define GAssertSZ(x, psz)   AssertSZ(x, psz)

#define GTrace(x)

#define DECLARE_TAG(name, psz)
#define DECLARE_GLOBAL_TAG(name, psz)
#define USES_TAG(name)

#endif // DEBUG

//
// Turn off Asserts for retail, even if USE_TRACER is specified
//
#if (!defined(DEBUG))

#ifdef Assert
#undef Assert
#define Assert(x)
#endif // Assert

#ifdef AssertSZ
#undef AssertSZ
#define AssertSZ(x, psz)
#endif // AssertSZ

#ifdef GAssert
#undef GAssert
#define GAssert(x)
#endif // GAssert

#ifdef GAssertSZ
#undef GAssertSZ
#define GAssertSZ(x, psz)
#endif // GAssertSZ

#endif // DEBUG

#ifndef PQS_CODE
#undef _ASSERTE

#if (defined (DEBUG) && !defined(_NO_TRACER)) 
#define _ASSERTE(x) Assert(x)
#else
#define _ASSERTE(x) 0
#endif

#endif // PQS_CODE


////////////////////////////////////////////////////////////////////////////////
//
// Define this to export the classes
//
////////////////////////////////////////////////////////////////////////////////
#ifdef  TRACER_EXPORT
#define TracerExported  __declspec( dllexport )
#else
#define TracerExported
#endif

////////////////////////////////////////////////////////////////////////////////
//
// class CTraced definition + implementation
//
//  pupose : A base class for every class who wants to use a special.
//
//
////////////////////////////////////////////////////////////////////////////////
#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)

void __cdecl ShutdownTracer();

class TracerExported CTraced {
  public:
    // A Constructor - sets a default Tracer. replace it by calling SetTracer
    //   in the derived class constructor.
    CTraced()
    {
        m_pTracer = NULL;
    }

    // The destructor deletes the existing tracer.
    ~CTraced()
    {
        if (m_pTracer)
            m_pTracer->Free();
    }

    // replace the current tracer while erasing it.
    BOOL SetTracer(CTracer* pTracer)
    {
        CTracer* pTempTracer = m_pTracer;
        m_pTracer = pTracer;

        if (pTempTracer)
          pTempTracer->Free();

        return TRUE;
    }

    // Return a pointer to the tracer this function is called by the macro's so
    //   if one wants to supply a different mechanism he can override it.
    virtual CTracer* GetTracer()
    {
        if(m_pTracer)
            return m_pTracer;
        else
            return g_pTracer;
    }

  protected:
    // A pointer to the tracer.
    CTracer *m_pTracer;
};

#else  /* DEBUG */
class TracerExported CTraced {};
#endif /* DEBUG */

////////////////////////////////////////////////////////////////////////////////
//
// The C interface prototypes. The macros calls them.
//
////////////////////////////////////////////////////////////////////////////////
#ifdef    __cplusplus
extern "C"
{
#endif /* __cplusplus */

void TraceAssert(   PSZ, PSZ, int);
void TraceAssertSZ( PSZ, PSZ, PSZ, int);
void TraceAssertWSZ(PSZ, PWSTR, PSZ, int);

BOOL IsFailure  (BOOL   , PSZ, int);
BOOL IsBadAlloc (void*  , PSZ, int);
BOOL IsBadHandle(HANDLE , PSZ, int);
BOOL IsBadResult(HRESULT, PSZ, int);

void TraceSZ(ERROR_LEVEL, TAG, PSZ, ...);
void TraceWSZ(ERROR_LEVEL, TAG, PWSTR, ...);

HRESULT RegisterTagSZ(PSZ, TAG*);

#ifdef    __cplusplus
}
#endif /* __cplusplus */

#ifdef    __cplusplus
////////////////////////////////////////////////////////////////////////////////
//
// Some extra classes.
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// An accumulating timer. Use it to define accuulator.
//       (See cpptest.cpp in the Sample)
//
// It is be used to compute average times of function etc.
//
//      timer - the vaiable name
//  tag   - the tag to trace to
//  string - a prefix
//
////////////////////////////////////////////////////////////////////////////////
#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
#define AccumulatingTimer(timer, tag, string, actimer)  \
CTracerAccumulatingTimer        timer(tag, string, actimer)
#else
#define AccumulatingTimer(timer, tag, string, actimer)
#endif

#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
class CTracerAccumulatingTimer
{
  public:
    CTracerAccumulatingTimer(
        TAG   tag,
        PSZ     pszSomeText = NULL,
        CTracerAccumulatingTimer *pTimer = NULL)
    :m_ulAccumulatedTimeInMiliseconds(0)
    ,m_ulEventNumber(0)
    ,m_tagTheTagToTraceTo(tag)
    ,m_pAccumulator(pTimer)
    {
        if (pszSomeText)
            strncpy(m_rchText, pszSomeText, MAX_PATH);
        else
            m_rchText[0] = '\0';
    }

    operator TAG(){return m_tagTheTagToTraceTo;}

    void AddEvent(ULONG ulEventDurationInMiliseconds, PSZ pszSomeText)
    {
        m_ulAccumulatedTimeInMiliseconds += ulEventDurationInMiliseconds;
        m_ulEventNumber++;

        Trace((
            elInfo,
            m_tagTheTagToTraceTo,
            "%s%s took %d miliseconds,"
            " average is %d miliseconds,"
            " accumulated %d miliseconds,"
            " op# %d",
            m_rchText,
            pszSomeText,
            ulEventDurationInMiliseconds,
            m_ulAccumulatedTimeInMiliseconds/m_ulEventNumber,
            m_ulAccumulatedTimeInMiliseconds,
            m_ulEventNumber));

        if(m_pAccumulator)
            m_pAccumulator->AddEvent(
                ulEventDurationInMiliseconds,
                m_rchText);
    }

  protected:
    // The time
    ULONG   m_ulAccumulatedTimeInMiliseconds;

    // The event counter
    ULONG   m_ulEventNumber;

    // The tag the trace will use.
    TAG     m_tagTheTagToTraceTo;

    // some text to specify which scope or code block is it
    char    m_rchText[MAX_PATH + 1];

    // pointer to accumulating time
    CTracerAccumulatingTimer        *m_pAccumulator;
};
#endif

////////////////////////////////////////////////////////////////////////////////
//
// A scope timer. It will trace the time that passed from the instanciation
//   to the end of the scope.
//       (See cpptest.cpp in the Sample)
//
// It is be used to compute times of function etc.
//
//  tag   - the tag to trace to
//  string - a prefix
//
////////////////////////////////////////////////////////////////////////////////
#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
#define ScopeTimer(tag, string) CTracerScopeTimer       __scopetimer(tag, string)
#else
#define ScopeTimer(tag, string)
#endif

////////////////////////////////////////////////////////////////////////////////
//
// A scope timer that uses and updates an accumulator timer.
//   It will trace the time that passed from the instanciation
//   to the end of the scope and tell this time to the accumulator as well.
//       (See cpptest.cpp in the Sample)
//
//  tag   - the tag to trace to
//  string - a prefix
//  actimer - an AccumulatingTimer object.
//
//     comment - if both the scope timer and the accumulating timer has the
//                 same tags - the scope timer will not trace.
//
////////////////////////////////////////////////////////////////////////////////
#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
#define ScopeAccumulatingTimer(tag, string, actimer) \
CTracerScopeTimer       __scopetimer(tag, string, actimer)
#else
#define ScopeAccumulatingTimer(tag, string, actimer)
#endif

#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
class CTracerScopeTimer
{
  public:
    CTracerScopeTimer(
        TAG tag,
        PSZ pszSomeText = NULL,
        CTracerAccumulatingTimer *pTimer = NULL)
        :m_ulStartTimeInMiliseconds(GetTickCount())
        ,m_tagTheTagToTraceTo(tag)
        ,m_pAccumulator(pTimer)
    {
        if (pszSomeText)
            strncpy(m_rchText, pszSomeText, MAX_PATH);
        else
            m_rchText[0] = '\0';
    }


    ~CTracerScopeTimer()
    {
        ULONG   ulFinishTimeInMiliseconds = GetTickCount();
        ULONG   ulStartToFinishTimeInMiliseconds;

        if (ulFinishTimeInMiliseconds >
            m_ulStartTimeInMiliseconds)
            ulStartToFinishTimeInMiliseconds =
            ulFinishTimeInMiliseconds - m_ulStartTimeInMiliseconds;
        else
            ulStartToFinishTimeInMiliseconds =
                ulFinishTimeInMiliseconds + 1 +
                    (0xffffffff - m_ulStartTimeInMiliseconds);

        if(!m_pAccumulator ||
            (m_tagTheTagToTraceTo != (ULONG)(*m_pAccumulator)))
            Trace((
                elInfo,
                m_tagTheTagToTraceTo,
                "%s took %d miliseconds",
                m_rchText,
                ulStartToFinishTimeInMiliseconds));

        if(m_pAccumulator)
            m_pAccumulator->AddEvent(
                ulStartToFinishTimeInMiliseconds,
                m_rchText);
    }

  protected:
    // The counter
    ULONG   m_ulStartTimeInMiliseconds;

    // The tag the trace will use.
    TAG     m_tagTheTagToTraceTo;

    // some text to specify which scope or code block is it
    char    m_rchText[MAX_PATH + 1];

    // pointer to accumulating time
    CTracerAccumulatingTimer        *m_pAccumulator;
};
#endif
#endif /* __cplusplus */



#endif // _TRACER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\tracer\src\mutex.h ===
/*//////////////////////////////////////////////////////////////////////////////
//
//      Filename :  Mutex.h
//      Purpose  :  A mutex objects
//
//      Project  :  Tracer
//      Component:
//
//      Author   :  urib
//
//      Log:
//          Dec  8 1996 urib Creation
//          Jun 26 1997 urib Add error checking. Improve coding.
//
//////////////////////////////////////////////////////////////////////////////*/

#ifndef MUTEX_H
#define MUTEX_H

//////////////////////////////////////////////////////////////////////////////*/
//
//  CMutex class definition
//
//////////////////////////////////////////////////////////////////////////////*/

class CMutex
{
  public:
    // Creates a mutex or opens an existing one.
    void Init (PSZ pszMutexName = NULL);

    // Lets the class act as a mutex handle.
    operator HANDLE();

    // Releases the mutex so other threads could take it.
    void Release();

    // Closes the handle on scope end.
    ~CMutex();

  private:
    HANDLE  m_hMutex;

};

//////////////////////////////////////////////////////////////////////////////*/
//
//  CMutexCatcher class definition
//
//////////////////////////////////////////////////////////////////////////////*/

class CMutexCatcher
{
  public:
    // Constructor - waits on the mutex.
    CMutexCatcher(CMutex& m);

    // Releases the mutex on scope end.
    ~CMutexCatcher();

  private:
    CMutex* m_pMutex;
};


//////////////////////////////////////////////////////////////////////////////*/
//
//  CMutex class implementation
//
//////////////////////////////////////////////////////////////////////////////*/

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMutex::Init
//      Purpose  :  Creates a mutex or opens an existing one.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   [N/A]
//
//      Log:
//          Jun 29 1997 urib Creation
//
////////////////////////////////////////////////////////////////////////////////
inline
void CMutex::Init(PSZ pszMutexName)
{
    BOOL    fSuccess = TRUE;

    LPSECURITY_ATTRIBUTES   lpSecAttr = NULL;
    
    SECURITY_DESCRIPTOR sdMutexSecurity;
    SECURITY_ATTRIBUTES saMutexAttributes =
    {
        sizeof(SECURITY_ATTRIBUTES),
        &sdMutexSecurity,
        FALSE
    };


    if(g_fIsWinNt)
    {
        fSuccess = InitializeSecurityDescriptor(
            &sdMutexSecurity,
            SECURITY_DESCRIPTOR_REVISION);

        // Give full control to everyone.
        fSuccess = SetSecurityDescriptorDacl(
            &sdMutexSecurity,
            TRUE,
            FALSE,
            FALSE);

        lpSecAttr = &saMutexAttributes;

    }

    m_hMutex = CreateMutex(lpSecAttr, FALSE, pszMutexName);
    if (NULL == m_hMutex)
    {
        char    rchError[1000];
        sprintf(rchError, "Tracer:CreateMutex failed with error %#x"
                " on line %d file %s\n",
                GetLastError(),
                __LINE__,
                __FILE__);
        OutputDebugString(rchError);
        throw "CreateMutex failed";
    }
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMutex::CMutex
//      Purpose  :  Lets the class act as a mutex handle.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   HANDLE
//
//      Log:
//          Jun 29 1997 urib Creation
//
////////////////////////////////////////////////////////////////////////////////
inline
CMutex::operator HANDLE()
{
    return m_hMutex;
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMutex::Release()
//      Purpose  :  Releases the mutex so other threads could take it.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   [N/A]
//
//      Log:
//          Jun 29 1997 urib Creation
//
////////////////////////////////////////////////////////////////////////////////
inline
void
CMutex::Release()
{
    BOOL    fSuccess = TRUE;

    if(m_hMutex != NULL)
    {
        fSuccess = ReleaseMutex(m_hMutex);
    }

    if (!fSuccess)
    {
        char    rchError[1000];
        sprintf(rchError, "Tracer:ReleaseMutex failed with error %#x"
                " on line %d file %s\n",
                GetLastError(),
                __LINE__,
                __FILE__);
        OutputDebugString(rchError);
    }
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMutex::~CMutex
//      Purpose  :  Closes the handle on scope end.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   [N/A]
//
//      Log:
//          Jun 29 1997 urib Creation
//
////////////////////////////////////////////////////////////////////////////////
inline
CMutex::~CMutex()
{
    BOOL    fSuccess = TRUE;


    if(m_hMutex != NULL)
    {
        fSuccess = CloseHandle(m_hMutex);
    }

    if (!fSuccess)
    {
        char    rchError[1000];
        sprintf(rchError, "Tracer:ReleaseMutex failed with error %#x"
                " on line %d file %s\n",
                GetLastError(),
                __LINE__,
                __FILE__);
        OutputDebugString(rchError);
    }
}

//////////////////////////////////////////////////////////////////////////////*/
//
//  CMutexCatcher class implementation
//
//////////////////////////////////////////////////////////////////////////////*/

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMutexCatcher::CMutexCatcher
//      Purpose  :  Constructor - waits on the mutex.
//
//      Parameters:
//          [in]    CMutex& m
//
//      Returns  :   [N/A]
//
//      Log:
//          Jun 29 1997 urib Creation
//
////////////////////////////////////////////////////////////////////////////////
inline
CMutexCatcher::CMutexCatcher(CMutex& m)
    :m_pMutex(&m)
{
    DWORD dwResult;

    dwResult = WaitForSingleObject(*m_pMutex, INFINITE);
    // Wait for a minute and shout!

    if (WAIT_OBJECT_0 != dwResult)
    {
        char    rchError[1000];
        sprintf(rchError,
                "Tracer:WaitForSingleObject returned an error - %x"
                " something is wrong"
                " on line %d file %s\n",
                dwResult,
                __LINE__,
                __FILE__);
        OutputDebugString(rchError);
        throw "WaitForSingleObject failed";
    }

}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMutexCatcher::~CMutexCatcher
//      Purpose  :  Constructor - waits on the mutex.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   [N/A]
//
//      Log:
//          Jun 29 1997 urib Creation
//
////////////////////////////////////////////////////////////////////////////////
inline
CMutexCatcher::~CMutexCatcher()
{
    m_pMutex->Release();
}



#endif // MUTEX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\abbrev.cpp ===
#include "base.h"
#include "formats.h"


const CAbbTerm g_aEngAbbList[] =
{
    {L"B.A.Ed",	    6,	NULL,	0}, // (Bachelor_of_Arts_in_Education)
    {L"B.A.Sc",	    6,	NULL,	0}, // (Bachelor_of_Agricultural_Science Bachelor_of_Applied_Science)
    {L"B.Ae.E",	    6,	NULL,	0}, // (Bachelor_of_Aeronautical_Engineering)
    {L"B.Arch",	    6,	NULL,	0}, // (Bachelor_of_Architecture)
    {L"B.Ch.E",	    6,	NULL,	0}, // (Bachelor_of_Chemical_Engineering)
    {L"B.Ed",	    4,	NULL,	0}, // (Bachelor_of_Education)
    {L"B.Eng",	    5,	NULL,	0}, // (Bachelor_of_Engineering)
    {L"B.Eng.Sci",	9,	NULL,	0}, // (Bachelor_of_Engineering_Science)
    {L"B.Engr",	    6,	NULL,	0}, // (Bachelor_of_Engineering)
    {L"B.Lit",	    5,	NULL,	0}, // (Bachelor_of_Literature)
    {L"B.Litt",	    6,	NULL,	0}, // (Bachelor_of_Literature)
    {L"B.Mus",	    5,	NULL,	0}, // (Bachelor_of_Music)
    {L"B.Pd",	    4,	NULL,	0}, // (Bachelor_of_Pedagogy)
    {L"B.Ph",	    4,	NULL,	0}, // (Bachelor_of_Philosophy)
    {L"B.Phil",	    6,	NULL,	0}, // (Bachelor_of_Philosophy)
    {L"B.R.E",	    5,	NULL,	0}, 
    {L"B.S.Arch",	8,	NULL,	0}, // (Bachelor_of_Science_in_Architecture)
    {L"B.S.Ch",	    6,	NULL,	0}, // (Bachelor_of_Science_in_Chemistry)
    {L"B.S.Ec",	    6,	NULL,	0}, // (Bachelor_of_Science_in_Economics)
    {L"B.S.Ed",	    6,	NULL,	0}, // (Bachelor_of_Science_in_Education)
    {L"B.S.For",	7,	NULL,	0}, // (Bachelor_of_Science_in_Forestry)
    {L"B.Sc",	    4,	NULL,	0}, // (Bachelor_of_Science)
    {L"B.Th",	    4,	NULL,	0}, // (Bachelor_of_Theology)
    {L"Ch.E",	    4,	NULL,	0}, // (chemical_engineer)
    {L"D.Bib",	    5,	NULL,	0}, 
    {L"D.Ed",	    4,	NULL,	0}, // (Doctor_of_Education)
    {L"D.Lit",	    5,	NULL,	0}, // (Doctor_of_Literature)
    {L"D.Litt",	    6,	NULL,	0}, 
    {L"D.Ph",	    4,	NULL,	0}, // (Doctor_of_Philosophy)
    {L"D.Phil",	    6,	NULL,	0}, // (Doctor_of_Philosophy)
    {L"D.Sc",	    4,	NULL,	0}, 
    {L"Ed.M",	    4,	NULL,	0}, // (Master_of_Education)
    {L"HH.D",	    4,	NULL,	0}, // (Doctor_of_Humanities)
    {L"L.Cpl",	    5,	NULL,	0}, // (Lance_corporal)
    {L"LL.B",	    4,	NULL,	0}, // (Bachelor_of_Laws)
    {L"LL.D",	    4,	NULL,	0}, // (Doctor_of_Laws)
    {L"LL.M",	    4,	NULL,	0}, // (Master_of_Laws)
    {L"Lit.B",	    5,	NULL,	0}, // (Bachelor_of_Literature)
    {L"Lit.D",	    5,	NULL,	0}, // (Doctor_of_Literature)
    {L"Litt.B",	    6,	NULL,	0}, // (Bachelor_of_Literature)
    {L"Litt.D",	    6,	NULL,	0}, // (Doctor_of_Literature)
    {L"M.A.Ed",	    6,	NULL,	0}, // (Master_of_Arts_in_Education)
    {L"M.Agr",	    5,	NULL,	0}, // (Master_of_Agriculture)
    {L"M.Div",	    5,	NULL,	0}, // (Master_of_Divinity)
    {L"M.Ed",	    4,	NULL,	0}, // (Master_of_Education)
    {L"M.Sc",	    4,	NULL,	0}, // (Master_of_Science)
    {L"M.Sgt",	    5,	NULL,	0}, // (Master_sergeant)
    {L"Mus.B",	    5,	NULL,	0}, // (Bachelor_of_Music)
    {L"Mus.D",	    5,	NULL,	0}, // (Doctor_of_Music)
    {L"Mus.Dr",	    6,	NULL,	0}, // (Doctor_of_Music)
    {L"Mus.M",	    5,	NULL,	0}, // (Master_of_Music)
    {L"N.Dak",	    5,	NULL,	0}, // (North_Dakota)
    {L"N.Ire",	    5,	NULL,	0}, // (Northern_Ireland)
    {L"N.Mex",	    5,	NULL,	0}, // (New_Mexico)
    {L"Pd.B",	    4,	L"pdb",	3}, // (Bachelor_of_Pedagogy) 
    {L"Pd.D",	    4,	L"pdd",	3}, // (Doctor_of_Pedagogy)
    {L"Pd.M",	    4,	L"phm",	3}, // (Master_of_Pedagogy)
    {L"Ph.B",	    4,	L"phb",	3}, // (Bachelor_of_Philosophy)
    {L"Ph.C",	    4,	L"phc",	3}, // (pharmaceutical_chemist)
    {L"Ph.D",	    4,	L"phd",	3}, // (Doctor_of_Philosophy)
    {L"Ph.G",	    4,	L"phg",	3}, // (graduate_in_pharmacy)
    {L"Ph.M",	    4,	L"phm",	0}, // (Master_of_Philosophy)
    {L"Phar.B",	    6,	NULL,	0}, // (Bachelor_of_Pharmacy)
    {L"Phar.D",	    6,	NULL,	0}, // (Doctor_of_Pharmacy)
    {L"Phar.M",	    6,	NULL,	0}, // (Master_of_Pharmacy)
    {L"R.C.Ch",	    6,	NULL,	0}, // (Roman_Catholic_Church)
    {L"S.A",	    3,	NULL,	0}, 
    {L"S.Afr",	    5,	NULL,	0}, // (South_Africa)
    {L"S.Dak",	    5,	NULL,	0}, // (South_Dakota)
    {L"S.M.Sgt",	7,	NULL,	0}, // (Senior_master_sergeant)
    {L"S.Sgt",	    5,	NULL,	0}, // (Staff_sergeant)
    {L"Sc.B",	    4,	NULL,	0}, 
    {L"Sc.D",	    4,	NULL,	0}, 
    {L"Sgt.Maj",	7,	NULL,	0}, // (Sergeant_major)
    {L"Sup.Ct",	    6,	NULL,	0}, // (Superior_court Supreme_court)
    {L"T.Sgt",	    5,	NULL,	0}, // (Technical_sergeant)
    {L"Th.B",	    4,	NULL,	0}, // (Bachelor_of_Theology)
    {L"Th.D",	    4,	NULL,	0}, // (Doctor_of_Theology)
    {L"Th.M",	    4,	NULL,	0}, // (Master_of_Theology)
    {L"V.Adm",	    5,	NULL,	0}, // (Vice_admiral)
    {L"W.Va",	    4,	NULL,	0}, 
    {L"W.W.I",	    5,	NULL,	0}, 
    {L"W.W.II",	    6,	NULL,	0}, 
    {L"n.wt",	    4,	NULL,	0}, 
    {L"nt.wt",	    5,	NULL,	0}, // (net_weight)
    {L"s.ap",	    4,	NULL,	0}, 
    {L"x-div",	    5,	NULL,	0}, 
    {L"x-int",	    5,	NULL,	0}, 

    {L"\0",         0,  NULL,   0}
};



const CAbbTerm g_aFrenchAbbList[] =
{
    {L"LL.AA",      5,      NULL,   0},
    {L"LL.MM",      5,      NULL,   0},
    {L"NN.SS",      5,      NULL,   0},
    {L"S.Exc",      5,      NULL,   0},
    {L"eod.loc",    7,      NULL,   0},
    {L"eod.op",     6,      NULL,   0},
    {L"op.cit",     6,      NULL,   0},
    {L"op.laud",    7,      NULL,   0},
    {L"ouvr.cit",   8,      NULL,   0},
    {L"pet.cap",    7,      NULL,   0},
    {L"\0",         0,  NULL,   0}
};

const CAbbTerm g_aSpanishAbbList[] =
{
    {L"AA.AA",      5,      NULL,   0},
    {L"AA.RR",      5,      NULL,   0},
    {L"AA.SS",      5,      NULL,   0},
    {L"Bmo.P",      5,      NULL,   0},
    {L"EE.UU",      5,      NULL,   0},
    {L"N.Recop",    7,      NULL,   0},
    {L"Nov.Recop",  9,      NULL,   0},
    {L"RR.MM",      5,      NULL,   0},
    {L"RR.PP",      5,      NULL,   0},
    {L"Rvda.M",     6,      NULL,   0},
    {L"SS.AA",      5,      NULL,   0},
    {L"SS.AA.II",   8,      NULL,   0},
    {L"SS.AA.RR",   8,      NULL,   0},
    {L"SS.AA.SS",   8,      NULL,   0},
    {L"SS.MM",      5,      NULL,   0},
    {L"Smo.P",      5,      NULL,   0},
    {L"V.Em",       4,      NULL,   0},
    {L"art.cit",    7,      NULL,   0},
    {L"op.cit",     6,      NULL,   0},
    {L"\0",         0,  NULL,   0}
};

const CAbbTerm g_aItalianAbbList[] =
{
    {L"\0",         0,  NULL,   0}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\tracer\src\tracmain.cpp ===
#include "tracer.h"
#include "tracmain.h"
#include "tracerdefault.h"

#pragma warning( disable : 4073 )
#pragma init_seg(lib)
#pragma warning( default : 4073 )

BOOL    g_fIsWinNt = TRUE;
CInitTracerGlobals g_InitTracerGlobals;

#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
////////////////////////////////////////////////////////////////////////////////
//
// Critical section object.
//
////////////////////////////////////////////////////////////////////////////////

class CTracerCriticalSection : protected CRITICAL_SECTION
{
  public:
    CTracerCriticalSection()
    {
        InitializeCriticalSection(this);
    }

    ~CTracerCriticalSection()
    {
        DeleteCriticalSection(this);
    }

    void Lock(ULONG = 0)
    {
        EnterCriticalSection(this);
    }

    void Unlock()
    {
        LeaveCriticalSection(this);
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// Critical section catcher
//
////////////////////////////////////////////////////////////////////////////////

class CTracerCriticalSectionCatcher
{
  public:
    CTracerCriticalSectionCatcher(CTracerCriticalSection& tcs)
        :m_refCritSect(tcs)
    {
        m_refCritSect.Lock();
    }

    ~CTracerCriticalSectionCatcher()
    {
        m_refCritSect.Unlock();
    }

  private:
    CTracerCriticalSection&   m_refCritSect;
};


static PSZ s_aTracerFlagsNames[] =
{
    "Device flag",
    "Error level",
    "Assert level",
    "Print location",
    "Print program name",
    "Print time",
    "Print thread id",
    "Print error level",
    "Print tag id",
    "Print tag name",
    "Print process id"
};

static PSZ s_aTagNames[] =
{
    "Out of Tag Array",
    "General traces",
    "Errors",
    "Warnings",
    "Information"
};

extern "C" CTracer*             g_pTracer = NULL;
static CNullTracer              s_ReplacementTracer;
static CMainTracer              s_MainTracer;

static CTracerCriticalSection   s_TracerCriticalSection;
static CLongTrace               *s_theLongTrace = NULL;

DECLARE_GLOBAL_TAG(tagError, "Errors");
DECLARE_GLOBAL_TAG(tagWarning, "Warnings");
DECLARE_GLOBAL_TAG(tagInformation, "Information");
DECLARE_GLOBAL_TAG(tagVerbose, "Verbose");
DECLARE_GLOBAL_TAG(tagGeneral, "General");

CNullTracer::CNullTracer()
{
    m_aTags = m_Tags;
    m_aFlags = m_Flags;
    m_ptagNextTagId = NULL;
    m_pulNumOfFlagEntries = NULL;
    g_pTracer = this;

}

////////////////////////////////////////////////////////////////////////////////
//
//  class  -  CMainTracer - implementation
//
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMainTracer::CMainTracer
//      Purpose  :  Constructor.
//
//      Parameters:
//          [in]    PSZ         pszRegistryPath - the key to take our data from.
//          [in]    DEALLOCATOR pfuncDealloc - the function with whom to
//                                                deallocate ourselves.
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib   Creation
//          Sep  5 1999 orenk  Single allocation of tag array done here
//          Jun 12 2000 yairh Initialize mutex that protects log file creation.
//
////////////////////////////////////////////////////////////////////////////////

CMainTracer::CMainTracer()
{
    try
    {
        m_bNeedToCreatOrAttachToLogFile = TRUE;
        m_pszLogName = NULL;
        m_LogState = logUseAppName;

        m_mCreateLogFile.Init(NULL);

        m_mTagId.Init("Tracer_Tag_ID_Incrementation_Protector");
        CMutexCatcher   cMutexForTagIdIncrementation(m_mTagId);
        g_fIsWinNt = IsWinNt();

        char        pszErrBuffer[TRACER_MAX_TRACE];

        DWORD dwLen = GetEnvironmentVariable(
                                    "SystemDrive",
                                    m_pszSysDrive,
                                    MAX_PATH);
        if (0 == dwLen)
        {
            dwLen = GetSystemDirectory( m_pszSysDrive, MAX_PATH );

            if (1 >= dwLen || m_pszSysDrive[1] != ':' )
            {
                sprintf(pszErrBuffer, "%s Error %x\r\n",
                        "Failed to find System drive. "
                        "Tracing is disabled",
                        GetLastError());
                Log(TRACER_DEVICE_FLAG_DEBUGOUT, pszErrBuffer);
                return;
            }

            dwLen = 2;
            m_pszSysDrive[ dwLen ] = '\0';
        }

        if (dwLen > MAX_PATH)
        {
            Log(TRACER_DEVICE_FLAG_DEBUGOUT,
                "System drive path is greater then MAX_PATH."
                "Tracing is disabled\r\n");
            return;
        }

        char    pszBuffer[MAX_PATH + 1];
        PSZ     pszFileName;
        ULONG   ulProgramNameLength;

        ulProgramNameLength = GetModuleFileName(
                                            NULL,
                                            pszBuffer,
                                            MAX_PATH);
        pszBuffer[ulProgramNameLength] = '\0';
        if (0 == _stricmp(pszBuffer + ulProgramNameLength - 4, ".exe"))
        {
            pszBuffer[ulProgramNameLength - 4] = '\0';
        }

        // Verify it is NULL terminated.
        pszFileName = strrchr(pszBuffer, '\\');

        // Remember only the file name.
        strncpy(
            m_pszProgramName,
            (pszFileName ? pszFileName + 1 : pszBuffer),
            TRACER_MAX_PROGRAM_NAME);

        ulProgramNameLength = strlen(m_pszProgramName);

        // My own preference.
        _strlwr(m_pszProgramName);

        m_fIsRunningAsService = ::IsRunningAsService();

        //
        // opening the shared memory
        //

        LPSECURITY_ATTRIBUTES lpSecAttr = NULL;
        SECURITY_DESCRIPTOR sdKeySecurity;
        SECURITY_ATTRIBUTES saKeyAttributes =
        {
            sizeof(SECURITY_ATTRIBUTES),
            &sdKeySecurity,
            FALSE
        };


        if(g_fIsWinNt)
        {
            if (!InitializeSecurityDescriptor(
                                    &sdKeySecurity,
                                    SECURITY_DESCRIPTOR_REVISION))
            {
                sprintf(pszErrBuffer, "%s Error %x\r\n",
                        "InitializeSecurityDescriptor failed "
                        "Tracing is disabled\r\n",
                        GetLastError());

                Log(TRACER_DEVICE_FLAG_DEBUGOUT,
                    pszErrBuffer);
                return;
            }

            if (!SetSecurityDescriptorDacl(
                                &sdKeySecurity,
                                TRUE,
                                FALSE,
                                FALSE))
            {
                sprintf(pszErrBuffer, "%s Error %x\r\n",
                        "SetSecurityDescriptorDacl failed "
                        "Tracing is disabled\r\n",
                        GetLastError());

                Log(TRACER_DEVICE_FLAG_DEBUGOUT,
                    pszErrBuffer);
                return;
            }

            lpSecAttr = &saKeyAttributes;
        }

        strcpy(pszBuffer, m_pszSysDrive);
        strcat(pszBuffer, "\\PKM_TRACER");

#if defined(_DONT_CREATE_TRACER_DIRECTROY)
        {
            //
            // in this option the tracer is disabled unless the TRACER directory
            // exist.
            //

            CAutoHandle ah;
            ah = CreateFile(
                        pszBuffer,
                        0,
                        0,
                        lpSecAttr,
                        OPEN_EXISTING ,
                        FILE_FLAG_BACKUP_SEMANTICS,
                        NULL);
            if (BAD_HANDLE((HANDLE)ah))
            {
                //
                // the directory does not exist.
                //
                return;
            }

        }
#else
        if (false == CreateDirectory(pszBuffer, NULL))
        {
            if (GetLastError() != ERROR_ALREADY_EXISTS)
            {
                sprintf(pszErrBuffer, "%s Error %x\r\n",
                        "Fail To create tracer directory"
                        "Tracing is disabled\r\n",
                        GetLastError());

                Log(TRACER_DEVICE_FLAG_DEBUGOUT,
                    pszErrBuffer);
                return;
            }
        }
#endif


        strcat(pszBuffer, "\\");
        strcat(pszBuffer, m_pszProgramName);
        strcat(pszBuffer, ".trc");
        bool bExistingFile = false;
        m_ahSharedMemoryFile = CreateFile(
                                    pszBuffer,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    lpSecAttr,
                                    OPEN_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
        if (BAD_HANDLE((HANDLE)m_ahSharedMemoryFile))
        {
            sprintf(pszErrBuffer, "%s error %x\r\n",
                    "Fail To open the shared memory file."
                    "Tracing is disabled\r\n",
                    GetLastError());

            Log(TRACER_DEVICE_FLAG_DEBUGOUT,
                pszErrBuffer);
            return;
        }

        if (ERROR_ALREADY_EXISTS  == GetLastError())
        {
            bExistingFile = true;
        }

        strcpy(pszBuffer, m_pszProgramName);
        strcat(pszBuffer, "_SharedMemory");

        m_ahSharedMemory = CreateFileMapping(
                                    (HANDLE)m_ahSharedMemoryFile,
                                    lpSecAttr,
                                    PAGE_READWRITE,
                                    0,
                                    (MAX_TAG_NUMBER + LAST_FLAG + 10) * sizeof(DWORD),
                                    pszBuffer);
        if (BAD_HANDLE((HANDLE)m_ahSharedMemory))
        {
             sprintf(pszErrBuffer, "%s error %x\r\n",
                    "Fail To open the shared memory object."
                    "Tracing is disabled\r\n",
                    GetLastError());

             Log(TRACER_DEVICE_FLAG_DEBUGOUT,
                pszErrBuffer);

            return;
        }

        PBYTE pbMem = (PBYTE) MapViewOfFile(
                                (HANDLE) m_ahSharedMemory,
                                FILE_MAP_ALL_ACCESS,
                                0,
                                0,
                                0);
        if (!pbMem)
        {
             sprintf(pszErrBuffer, "%s error %x\r\n",
                    "Fail To map view of file."
                    "Tracing is disabled\r\n",
                    GetLastError());

             Log(TRACER_DEVICE_FLAG_DEBUGOUT,
                pszErrBuffer);

             return;
        }

        m_amSharedMemory = pbMem;

        if (bExistingFile)
        {
            bool fRet = ReadFromExistingSharedMemory(pbMem);
            if (false == fRet)
            {
                return;
            }
        }
        else
        {
            bool fRet = InitializeSharedMemory(pbMem);
            if (false == fRet)
            {
                return;
            }
        }

    }
    catch(...)
    {
        Log(TRACER_DEVICE_FLAG_DEBUGOUT,
            "Fail To initialize the tracer."
            "Tracing is disabled\r\n");
        return;
    }

    g_pTracer = this;
}

CMainTracer::~CMainTracer()
{
}

bool CMainTracer::ReadFromExistingSharedMemory(PBYTE pbMem)
{
    bool bRet = ::ReadFromExistingSharedMemory(
                                        pbMem,
                                        &m_pulNumOfFlagEntries,
                                        &m_aFlags,
                                        &m_ptagNextTagId,
                                        &m_aTags);

    if (!bRet)
    {
        Log(TRACER_DEVICE_FLAG_DEBUGOUT,
            "Invalid shared memory file"
            "Tracing is desabled\r\n");
        return false;
    }

    return true;
}

bool CMainTracer::InitializeSharedMemory(PBYTE pbMem)
{
    char* pszTracerStamp = (char*) (pbMem + TRACER_STAMP_OFFSET);
    strcpy(pszTracerStamp, TRACER_STAMP);

    ULONG* pulFlagsTableOffset = (ULONG*) (pbMem + TRACER_FLAGS_TABLE_OFFSET);
    ULONG* pulTagsTableOffset =  (ULONG*) (pbMem + TAGS_TABLE_OFFSET);

    *pulFlagsTableOffset = LAST_OFFSET;

    m_pulNumOfFlagEntries = (ULONG*) (pbMem + *pulFlagsTableOffset);
    *m_pulNumOfFlagEntries = LAST_FLAG;

    m_aFlags = (CTracerFlagEntry*) (m_pulNumOfFlagEntries + 1);

    for (ULONG ul = 0; ul < LAST_FLAG; ul++)
    {
        m_aFlags[ul].m_ulFlagValue = 0;
        strcpy(m_aFlags[ul].m_pszName, s_aTracerFlagsNames[ul]);
    }

    m_aFlags[DEVICE_FLAG].m_ulFlagValue        = DEVICE_FLAG_DEFAULT;
    m_aFlags[ERROR_LEVEL_FLAG].m_ulFlagValue   = TRACER_ERROR_LEVEL_DEFAULT;
    m_aFlags[ASSERT_LEVEL_FLAG].m_ulFlagValue  = TRACER_ASSERT_LEVEL_DEFAULT;
    m_aFlags[PRINT_LOCATION].m_ulFlagValue     = PRINT_LOCATION_DEFAULT;
    m_aFlags[PRINT_PROGRAM_NAME].m_ulFlagValue = PRINT_PROGRAM_NAME_DEFAULT;
    m_aFlags[PRINT_TIME].m_ulFlagValue         = PRINT_TIME_DEFAULT;
    m_aFlags[PRINT_THREAD_ID].m_ulFlagValue    = PRINT_THREAD_ID_DEFAULT;
    m_aFlags[PRINT_ERROR_LEVEL].m_ulFlagValue  = PRINT_ERROR_LEVEL_DEFAULT;
    m_aFlags[PRINT_TAG_ID].m_ulFlagValue       = PRINT_TAG_ID_DEFAULT;
    m_aFlags[PRINT_TAG_NAME].m_ulFlagValue     = PRINT_TAG_NAME_DEFUALT;
    m_aFlags[PRINT_PROCESS_ID].m_ulFlagValue   = PRINT_PROCCESS_ID_DEFAULT;

    *pulTagsTableOffset = (ULONG)(ULONG_PTR)(((PBYTE) (m_aFlags + (ULONG_PTR)(*m_pulNumOfFlagEntries))) - pbMem);

    m_ptagNextTagId = (TAG*) (pbMem + *pulTagsTableOffset);
    *m_ptagNextTagId = 0;
    m_aTags = (CTracerTagEntry*) (m_ptagNextTagId + 1);

    for (ul = 0; ul < TAG_LAST; ul++)
    {
        m_aTags[ul].m_TagErrLevel = TAG_ERROR_LEVEL_DEFAULT;
        strcpy(m_aTags[ul].m_pszTagName, s_aTagNames[ul]);
    }

    *m_ptagNextTagId  = TAG_LAST;

    return true;
}

HRESULT CMainTracer::RegisterTagSZ(LPCSTR pszTagName, TAG& ulTagId)
{
    CMutexCatcher   cMutexForTagIdIncrementation(m_mTagId);

    ULONG ul;
    for (ul = 0; ul < *m_ptagNextTagId; ul++)
    {
        if (0 == strncmp(pszTagName, m_aTags[ul].m_pszTagName, MAX_TAG_NAME - 1))
        {
            ulTagId = ul;
            return S_OK;
        }
    }

    if (*m_ptagNextTagId >= MAX_TAG_NUMBER)
    {
        char    pszBuffer[1000];

        _snprintf(pszBuffer, 999, "Tags Overflow!: tag \"%s\" exceeds array bounds (%d) and will be ignored."
                                  "Call the build man!!!\r\n",pszTagName, MAX_TAG_NUMBER);

        Log(TRACER_DEVICE_FLAG_DEBUGOUT,
            pszBuffer);

        ulTagId = TAG_OUT_OF_TAG_ARRAY;
        return S_OK;
    }

    m_aTags[*m_ptagNextTagId].m_TagErrLevel = TAG_ERROR_LEVEL_DEFAULT;
    strncpy(m_aTags[*m_ptagNextTagId].m_pszTagName, pszTagName, MAX_TAG_NAME - 1);
    m_aTags[*m_ptagNextTagId].m_pszTagName[MAX_TAG_NAME] = '\0';
    ulTagId = *m_ptagNextTagId;

    (*m_ptagNextTagId)++;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMainTracer::TraceSZ
//      Purpose  :  To trace out the printf formatted data according to the
//                    error level and tag.
//
//      Parameters:
//          [in]    DWORD       dwError
//          [in]    LPCSTR      pszFile
//          [in]    int         iLine
//          [in]    ERROR_LEVEL el
//          [in]    TAG         tag
//          [in]    LPCSTR      pszFormatString
//          [in]    ...
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib Creation
//          Feb 11 1997 urib Support UNICODE format string.
//
//////////////////////////////////////////////////////////////////////////////*/
void
CMainTracer::TraceSZ(
    DWORD       dwError,
    LPCSTR      pszFile,
    int         iLine,
    ERROR_LEVEL el,
    TAG         tag,
    LPCSTR      pszFormatString,
    ...)
{
    va_list arglist;

    va_start(arglist, pszFormatString);

    VaTraceSZ(dwError, pszFile, iLine, el, tag, pszFormatString, arglist);
}

void
CMainTracer::TraceSZ(
    DWORD       dwError,
    LPCSTR      pszFile,
    int         iLine,
    ERROR_LEVEL el,
    TAG         tag,
    PCWSTR      pwszFormatString,
    ...)
{
    va_list arglist;

    va_start(arglist, pwszFormatString);

    VaTraceSZ(dwError, pszFile, iLine, el, tag, pwszFormatString, arglist);
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMainTracer::VaTraceSZ
//      Purpose  :  To trace out the printf formatted data according to the
//                    error level and tag.
//
//      Parameters:
//          [in]    DWORD       dwError
//          [in]    LPCSTR      pszFile
//          [in]    int         iLine
//          [in]    ERROR_LEVEL el
//          [in]    TAG         tag
//          [in]    LPCSTR      pszFormatString
//          [in]    va_list     arglist
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib Creation
//          Dec 10 1996 urib Fix TraceSZ to VaTraceSZ.
//          Feb 11 1997 urib Support UNICODE format string.
//          Apr 12 1998 urib Add time to log.
//          Apr 12 1999 urib Make error level printing compatible between
//                             the two function versions. Don't add a second
//                             newline (From MicahK).
//          Sep  9 1999 orenk Check for tags out of array bounds.
//
//
////////////////////////////////////////////////////////////////////////////////
void
CMainTracer::VaTraceSZ(
            DWORD       dwError,
            LPCSTR      pszFile,
            int         iLine,
            ERROR_LEVEL el,
            TAG         tag,
            LPCSTR      pszFormatString,
            va_list     arglist)
{
    char        pszBuffer[TRACER_MAX_TRACE];
    int         iCharsWritten = 0;
    DWORD       dwDeviceFlags = m_aFlags[DEVICE_FLAG].m_ulFlagValue;
    SYSTEMTIME  st;


    bool fTwoLinesLogMsg = false;
    if (dwError || m_aFlags[PRINT_LOCATION].m_ulFlagValue)
    {
        if (pszFile)
        {
            iCharsWritten += sprintf(
                pszBuffer + iCharsWritten,
                "%s(%d) : ",
                pszFile,
                iLine
                );
        }
        if ( dwError )
        {
            iCharsWritten += sprintf(
                pszBuffer + iCharsWritten,
                "Err: 0x%08x=",
                dwError
                );

            DWORD dwMsgLen = GetErrorStringFromCode( dwError,
                                          pszBuffer+iCharsWritten,
                                          TRACER_MAX_TRACE - iCharsWritten );
            if ( dwMsgLen )
            {
                iCharsWritten += (int) dwMsgLen;
            }
        }

        if (iCharsWritten)
        {
            pszBuffer[iCharsWritten++] = '\r';
            pszBuffer[iCharsWritten++] = '\n';
            pszBuffer[iCharsWritten] = '\0';
            Log(dwDeviceFlags, pszBuffer);
            fTwoLinesLogMsg = true;
        }

    }

    iCharsWritten = 0;

    if (fTwoLinesLogMsg)
    {
        iCharsWritten += sprintf(
            pszBuffer + iCharsWritten,
            "   "
            );
    }

    GetLocalTime(&st);

    if (m_aFlags[PRINT_PROGRAM_NAME].m_ulFlagValue)
    {
        iCharsWritten += sprintf(
            pszBuffer + iCharsWritten,
            "%s ",
            m_pszProgramName
            );
    }

    if (m_aFlags[PRINT_TIME].m_ulFlagValue)
    {
        iCharsWritten += sprintf(
            pszBuffer + iCharsWritten,
            " %02d:%02d:%02d.%03d ",
            st.wHour,
            st.wMinute,
            st.wSecond,
            st.wMilliseconds
            );
    }

    if (m_aFlags[PRINT_ERROR_LEVEL].m_ulFlagValue)
    {
        iCharsWritten += sprintf(
            pszBuffer + iCharsWritten,
            "el:%x ",
            el
            );
    }

    if (m_aFlags[PRINT_TAG_ID].m_ulFlagValue)
    {
        iCharsWritten += sprintf(
            pszBuffer + iCharsWritten,
            "tagid:%-3x ",
            tag
            );
    }

    if (m_aFlags[PRINT_TAG_NAME].m_ulFlagValue)
    {
        iCharsWritten += sprintf(
            pszBuffer + iCharsWritten,
            "tag:\"%s\" ",
            m_aTags[tag].m_pszTagName
            );
    }

    if (m_aFlags[PRINT_PROCESS_ID].m_ulFlagValue)
    {
        iCharsWritten += sprintf(
            pszBuffer + iCharsWritten,
            "pid:0x%-4x ",
            GetCurrentProcessId()
            );
    }

    if (m_aFlags[PRINT_THREAD_ID].m_ulFlagValue)
    {
        iCharsWritten += sprintf(
            pszBuffer + iCharsWritten,
            "tid:0x%-4x ",
            GetCurrentThreadId()
            );
    }


    int iRet;
    iRet = _vsnprintf(
        pszBuffer + iCharsWritten,
        TRACER_MAX_TRACE - iCharsWritten - 5, // I like this number.
        pszFormatString,
        arglist);

    if (-1 == iRet)
    {
        iCharsWritten = TRACER_MAX_TRACE;
    }
    else
    {
        iCharsWritten += iRet;
    }

    if (iCharsWritten > TRACER_MAX_TRACE - 3)
    {
        iCharsWritten = TRACER_MAX_TRACE - 3;
    }

    if (pszBuffer[iCharsWritten-1] != '\n')
    {
        pszBuffer[iCharsWritten++] = '\r';
        pszBuffer[iCharsWritten++] = '\n';
    }
    pszBuffer[iCharsWritten] = '\0';

    Log(dwDeviceFlags, pszBuffer);

}

void
CMainTracer::RawVaTraceSZ(
            LPCSTR      pszFormatString,
            va_list     arglist)
{
    char        pszBuffer[TRACER_MAX_TRACE];
    int         iCharsWritten = 0;
    iCharsWritten = _vsnprintf(
        pszBuffer,
        TRACER_MAX_TRACE - 5, // I like this number.
        pszFormatString,
        arglist);

    if (iCharsWritten < 0)
    {
        iCharsWritten = 0;
    }
    pszBuffer[iCharsWritten] = '\0';

    Log(m_aFlags[DEVICE_FLAG].m_ulFlagValue, pszBuffer);
}


void
CMainTracer::VaTraceSZ(
            DWORD       dwError,
            LPCSTR      pszFile,
            int         iLine,
            ERROR_LEVEL el,
            TAG         tag,
            PCWSTR      pwszFormatString,
            va_list     arglist)
{
    WCHAR       rwchBuffer[TRACER_MAX_TRACE];
    int         iCharsWritten = 0;
    DWORD       dwDeviceFlags = m_aFlags[DEVICE_FLAG].m_ulFlagValue;
    SYSTEMTIME  st;

    bool fTwoLinesLogMsg = false;

    if (dwError || m_aFlags[PRINT_LOCATION].m_ulFlagValue)
    {
        char rpszBuff[TRACER_MAX_TRACE];

        if (pszFile)
        {
            iCharsWritten += sprintf(
                rpszBuff+iCharsWritten,
                "%s(%d) : ",
                pszFile,
                iLine
                );
        }
        if ( dwError )
        {

            iCharsWritten += sprintf(
                rpszBuff + iCharsWritten,
                "Err: 0x%08x=",
                dwError
                );


            DWORD dwMsgLen = GetErrorStringFromCode(
                                          dwError,
                                          rpszBuff + iCharsWritten,
                                          TRACER_MAX_TRACE - iCharsWritten);
            iCharsWritten += dwMsgLen;
        }

        if (iCharsWritten)
        {
            rpszBuff[iCharsWritten++] = '\r';
            rpszBuff[iCharsWritten++] = '\n';
            rpszBuff[iCharsWritten] = '\0';
            Log(dwDeviceFlags, rpszBuff);
            fTwoLinesLogMsg = true;
        }
    }

    GetLocalTime(&st);
    iCharsWritten = 0;

    if (fTwoLinesLogMsg)
    {
        iCharsWritten += swprintf(
            rwchBuffer + iCharsWritten,
            L"   "
            );
    }

    if (m_aFlags[PRINT_PROGRAM_NAME].m_ulFlagValue)
    {
        iCharsWritten += swprintf(
            rwchBuffer + iCharsWritten,
            L"%S ",
            m_pszProgramName
            );
    }

    if (m_aFlags[PRINT_TIME].m_ulFlagValue)
    {
        iCharsWritten += swprintf(
            rwchBuffer + iCharsWritten,
            L" %02d:%02d:%02d.%03d ",
            st.wHour,
            st.wMinute,
            st.wSecond,
            st.wMilliseconds
            );
    }

    if (m_aFlags[PRINT_ERROR_LEVEL].m_ulFlagValue)
    {
        iCharsWritten += swprintf(
            rwchBuffer + iCharsWritten,
            L"el:0x%x ",
            el
            );
    }

    if (m_aFlags[PRINT_TAG_ID].m_ulFlagValue)
    {
        iCharsWritten += swprintf(
            rwchBuffer + iCharsWritten,
            L"tagid:0x%x ",
            tag
            );
    }

    if (m_aFlags[PRINT_TAG_NAME].m_ulFlagValue)
    {
        iCharsWritten += swprintf(
            rwchBuffer + iCharsWritten,
            L"tag:\"%S\" ",
            m_aTags[tag].m_pszTagName
            );
    }

    if (m_aFlags[PRINT_PROCESS_ID].m_ulFlagValue)
    {
        iCharsWritten += swprintf(
            rwchBuffer + iCharsWritten,
            L"pid:0x%x ",
            GetCurrentProcessId()
            );
    }

    if (m_aFlags[PRINT_THREAD_ID].m_ulFlagValue)
    {
        iCharsWritten += swprintf(
            rwchBuffer + iCharsWritten,
            L"tid:0x%x ",
            GetCurrentThreadId()
            );
    }

    int iRet;
    iRet = _vsnwprintf(
        rwchBuffer + iCharsWritten,
        TRACER_MAX_TRACE - iCharsWritten - 5, // I like this number.
        pwszFormatString,
        arglist);

    if (-1 == iRet)
    {
        iCharsWritten = TRACER_MAX_TRACE;
    }
    else
    {
        iCharsWritten += iRet;
    }

    if (iCharsWritten > TRACER_MAX_TRACE - 3)
    {
        iCharsWritten = TRACER_MAX_TRACE - 3;
    }

    rwchBuffer[iCharsWritten++] = L'\r';
    rwchBuffer[iCharsWritten++] = L'\n';
    rwchBuffer[iCharsWritten] = L'\0';

    Log(dwDeviceFlags, rwchBuffer);

    iCharsWritten = 0;


}

void
CMainTracer::RawVaTraceSZ(
            LPCWSTR     pwszFormatString,
            va_list     arglist)
{
    WCHAR       rwchBuffer[TRACER_MAX_TRACE];
    int         iCharsWritten = 0;
    iCharsWritten += _vsnwprintf(
        rwchBuffer + iCharsWritten,
        TRACER_MAX_TRACE - iCharsWritten - 5, // I like this number.
        pwszFormatString,
        arglist);

    rwchBuffer[iCharsWritten] = L'\0';

    Log(m_aFlags[DEVICE_FLAG].m_ulFlagValue, rwchBuffer);
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMainTracer::Log
//      Purpose  :  To actually print the formatted data.
//
//      Parameters:
//          [in]        DWORD   dwDevicesFlags - flags to say where to print
//          [in]        LPSTR   pszText        - buffer to print.
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib  Creation
//          Feb 11 1997 urib  Support UNICODE format string.
//          Mar  2 1997 urib  Fix fprintf usage bug.
//          Jun  2 1997 urib  Fix bug - fclose file only if it is open!
//          Aug 13 1998 urib  Restore last error if we overrided it.
//          Jun 12 2000 yairh Protect writing only. Log file creation protection
//                              is inside CreatOrAttachToLogFile.
//
//////////////////////////////////////////////////////////////////////////////*/
void
CMainTracer::Log(DWORD dwDevicesFlags, LPSTR pszText)
{
    LONG        lError = GetLastError();

    // debug trace
    if (TRACER_DEVICE_FLAG_DEBUGOUT & dwDevicesFlags)
        OutputDebugString(pszText);

    // Disk file trace
    if (TRACER_DEVICE_FLAG_FILE & dwDevicesFlags)
    {
        if (m_bNeedToCreatOrAttachToLogFile)
        {
            CreatOrAttachToLogFile();
        }

        if (m_pszLog)
        {
            CMutexCatcher   cMutexForTagIdIncrementation(m_mLogFile);
            ULONG ulSize = strlen(pszText);

            if (*m_pulNextFreeSpaceInLogFile + ulSize > LOG_FILE_SIZE - 0x10)
            {
                char pszBuf[MAX_PATH];
                char pszBuf1[MAX_PATH];

                strcpy(pszBuf, m_pszSysDrive);
                strcat(pszBuf, "\\PKM_TRACER\\");
                strcat(pszBuf, m_pszLogName);
                strcat(pszBuf, ".log");

                strcpy(pszBuf1, pszBuf);
                strcat(pszBuf1, ".old");
                CopyFile(pszBuf, pszBuf1, false);
                memset(m_pszLog, 0, LOG_FILE_SIZE);
                *m_pulNextFreeSpaceInLogFile = LOG_START_POINT;
                *(m_pszLog + sizeof(ULONG)) = '\r';
                *(m_pszLog + sizeof(ULONG) + sizeof(char)) = '\n';
            }

            memcpy(m_pszLog + *m_pulNextFreeSpaceInLogFile, pszText, ulSize);
            *m_pulNextFreeSpaceInLogFile = *m_pulNextFreeSpaceInLogFile + ulSize;
        }
    }
    // stderr trace
    if (TRACER_DEVICE_FLAG_STDERR & dwDevicesFlags)
        fprintf(stderr, "%s", pszText);

    // stdout trace
    if (TRACER_DEVICE_FLAG_STDOUT & dwDevicesFlags)
        fprintf(stdout, "%s", pszText);

    SetLastError(lError);
}

void
CMainTracer::Log(DWORD dwDevicesFlags, PWSTR pwszText)
{
    LONG        lError = GetLastError();

    // debug trace
    if (TRACER_DEVICE_FLAG_DEBUGOUT & dwDevicesFlags)
        OutputDebugStringW(pwszText);

    // Disk file trace
    if (TRACER_DEVICE_FLAG_FILE & dwDevicesFlags)
    {
        if (m_bNeedToCreatOrAttachToLogFile)
        {
            CreatOrAttachToLogFile();
        }
        if (m_pszLog)
        {
            CMutexCatcher   cMutexForTagIdIncrementation(m_mLogFile);
            ULONG ulSize = wcslen(pwszText);

            if (*m_pulNextFreeSpaceInLogFile + ulSize > LOG_FILE_SIZE - 0x10)
            {
                char pszBuf[MAX_PATH];
                char pszBuf1[MAX_PATH];

                strcpy(pszBuf, m_pszSysDrive);
                strcat(pszBuf, "\\PKM_TRACER\\");
                strcat(pszBuf, m_pszLogName);
                strcat(pszBuf, ".log");

                strcpy(pszBuf1, pszBuf);
                strcat(pszBuf1, ".old");
                CopyFile(pszBuf, pszBuf1, false);
                memset(m_pszLog, 0, LOG_FILE_SIZE);
                *m_pulNextFreeSpaceInLogFile = LOG_START_POINT;
                *(m_pszLog + sizeof(ULONG)) = '\r';
                *(m_pszLog + sizeof(ULONG) + sizeof(char)) = '\n';
            }

            ulSize = wcstombs(
                            m_pszLog + *m_pulNextFreeSpaceInLogFile,
                            pwszText,
                            ulSize);
            if (ulSize != -1)
            {
                *m_pulNextFreeSpaceInLogFile = *m_pulNextFreeSpaceInLogFile + ulSize;
            }
        }
    }

    // stderr trace
    if (TRACER_DEVICE_FLAG_STDERR & dwDevicesFlags)
        fprintf(stderr, "%S", pwszText);

    // stdout trace
    if (TRACER_DEVICE_FLAG_STDOUT & dwDevicesFlags)
        fprintf(stdout, "%S", pwszText);

    SetLastError(lError);
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMainTracer::TraceAssertSZ
//      Purpose  :  To trace data on the failed assertion.
//
//      Parameters:
//          [in]  LPCSTR pszTestSring - assertion test expression
//          [in]  LPCSTR pszText      - some text attached
//          [in]  LPCSTR pszFile      - source file name
//          [in]  int    iLine        - source line number
//
//      Returns  :   [N/A]
//
//      Log:
//          Dec  8 1996 urib  Creation
//          Feb  2 1997 urib  First write the assert line and message box later.
//          Feb 11 1997 urib  Better service assert.
//          May 10 1999 urib  Add message to msgbox.
//
//////////////////////////////////////////////////////////////////////////////*/

void
CMainTracer::TraceAssertSZ(
      LPCSTR    pszTestSring,
      LPCSTR    pszText,
      LPCSTR    pszFile,
      int       iLine)
{
    char    buff[TRACER_MAX_TRACE + 1];
    DWORD dwAssertLevel = m_aFlags[ASSERT_LEVEL_FLAG].m_ulFlagValue;
    BOOL fBreak = FALSE;

    if ( dwAssertLevel & ASSERT_LEVEL_MESSAGE )
    {
        TraceSZ(
            0,
            pszFile,
            iLine,
            elError,
            tagError,
            "Assertion failed : %s : \"%s\" == 0 ",
            pszText,
            pszTestSring);
    }


    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    int id = 0;

    BOOL    fDebugAPIPresent = FALSE;
    LocalIsDebuggerPresent(&fDebugAPIPresent);

    if ( IsRunningAsService())
    {
        if ( dwAssertLevel & ASSERT_LEVEL_LOOP )
        {
            TraceSZ(0, pszFile, iLine,elCrash, tagError, "Stuck in assert."
                    "In order to release - set a breakpoint in file :%s"
                    " in line %d. When it breaks, set the next instruction "
                    "to be the \"ulNextInstruction\" line after the loop.",
                    __FILE__,
                    __LINE__);
            while (1)
                Sleep(1000);

            ULONG ulNextInstruction = 0;
        }
        else if (dwAssertLevel & ASSERT_LEVEL_POPUP)
        {
           _snprintf(
               buff, TRACER_MAX_TRACE,
               "Assert: %s: Expression: %s\r\n\r\nProcess: "
               "%s\r\n\r\nProcessID.ThreadID: %d.%d\r\n\r\nFile:"
               " %s\r\n\r\nLine: %u",
               pszText, pszTestSring, m_pszProgramName, pid, tid, pszFile, iLine );

            id = MessageBox(NULL,
                            buff,
                            m_pszProgramName,
                            MB_SETFOREGROUND | MB_DEFAULT_DESKTOP_ONLY |
                            MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL);

            //
            // If id == 0, then an error occurred.  There are two possibilities
            //   that can cause the error:  Access Denied, which means that this
            //   process does not have access to the default desktop, and
            //   everything else (usually out of memory).
            //

            if (!id)
            {
#ifdef _WIN32_WINNT
                    //
                    // Retry this one with the SERVICE_NOTIFICATION flag on.
                    // That should get us to the right desktop.
                    //
                    UINT uOldErrorMode = SetErrorMode(0);

                    id = MessageBox(NULL,
                            buff,
                            m_pszProgramName,
                            MB_SETFOREGROUND | MB_SERVICE_NOTIFICATION |
                            MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL);

                    SetErrorMode(uOldErrorMode);
#endif //_WIN32_WINNT
            }

            if ( IDCANCEL == id )
            {
                fBreak = TRUE;
            }
        }
        else if( dwAssertLevel & ASSERT_LEVEL_BREAK )
        {
            fBreak = TRUE;
        }
    }
    else if ( dwAssertLevel & ASSERT_LEVEL_POPUP )
    {
       _snprintf(
           buff, TRACER_MAX_TRACE,
           "Assert: %s: Expression: %s\r\n\r\nProcess: "
           "%s\r\n\r\nProcessID.ThreadID: %d.%d\r\n\r\nFile:"
           " %s\r\n\r\nLine: %u",
           pszText, pszTestSring, m_pszProgramName, pid, tid, pszFile, iLine );

        id =  MessageBox(NULL, buff, m_pszProgramName, MB_ICONSTOP|MB_OKCANCEL);

        if ( IDCANCEL == id )
        {
            fBreak = TRUE;
        }

    }
    else if( dwAssertLevel & ASSERT_LEVEL_BREAK )
    {
        fBreak = TRUE;
    }
    if( fBreak )
    {
        if(fDebugAPIPresent)
        {
            while( !LocalIsDebuggerPresent(&fDebugAPIPresent) )
            {
                _snprintf(
                       buff,
                       TRACER_MAX_TRACE,
                       "In order to debug the assert you need to attach a debugger to process %d",
                       GetCurrentProcessId());

                MessageBox(NULL,
                        buff,
                        m_pszProgramName,
                        MB_SETFOREGROUND | MB_SERVICE_NOTIFICATION |
                        MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OK);
            }
        }

        DebugBreak();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMainTracer::GetErrorStringFromCode
//
//  Synopsis:   Fetches the value of the error string from the error code
//
//  Arguments:  [dwError]   - Error code
//              [pszBuffer] - Buffer in which to put the error string
//              [ccBuffer]  - Maximum number of chars to put into the string,
//              including the null terminator.
//
//  Returns:    TRUE if successful, FALSE o/w
//
//  History:    12-13-98   srikants   Created
//
//  Notes:      Currently it handles only WIN32 errors. It needs to be enhanced
//              to include ole errors, search errors, etc.
//
//----------------------------------------------------------------------------

DWORD CMainTracer::GetErrorStringFromCode(
    DWORD dwError,
    char * pszBuffer,
    ULONG ccBuffer )
{
    Assert( dwError );  // This should not get called if dwError is 0
    Assert( pszBuffer );
    Assert( ccBuffer > 1 );

    DWORD dwLen = FormatMessageA( FORMAT_MESSAGE_FROM_SYSTEM,
                                  NULL,
                                  HRESULT_CODE(dwError),
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                  pszBuffer,
                                  ccBuffer-1,
                                  NULL);

    return dwLen;

}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMainTracer::LocalIsDebuggerPresent
//      Purpose  :  The wrapper around IsDebuggerPresent() API
//                  Will also return the information about whether the actual API is available or not
//
//      Parameters:
//          [BOOL* pfIsAPIAvailable]    - returns FALSE if there's no API (WIN95 case)
//
//      Log:
//          Feb 23 2000      eugenesa   Created
//
//////////////////////////////////////////////////////////////////////////////*/

typedef BOOL (WINAPI *PfnIsDebuggerPresent) (VOID);
static LPCSTR s_kernel32 = "kernel32";

BOOL
CMainTracer::LocalIsDebuggerPresent(BOOL* pfIsAPIAvailable)
{
    static PfnIsDebuggerPresent s_pfnIsDebuggerPresent  = (PfnIsDebuggerPresent)::GetProcAddress( ::GetModuleHandle(s_kernel32), "IsDebuggerPresent");

    if(s_pfnIsDebuggerPresent != NULL)
    {
        if(pfIsAPIAvailable)
        {
            *pfIsAPIAvailable = TRUE;
        }

        return s_pfnIsDebuggerPresent();
    }

    if(pfIsAPIAvailable)
    {
        *pfIsAPIAvailable = FALSE;
    }

    return FALSE;
}


/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMainTracer::IsRunningAsService
//      Purpose  :  Access to the running mode - service/executable
//
//      Parameters:
//          [N/A]
//
//      Returns  :   BOOL
//
//      Log:
//          Feb 11 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
BOOL
CMainTracer::IsRunningAsService()
{
    return m_fIsRunningAsService;
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CMainTracer::CreatOrAttachToLogFile
//      Purpose  :  Create log file.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   [N/A]
//
//      Log:
//          Jun 12 2000 yairh Creation
//          Jun 12 2000 yairh Fix protection.
//
////////////////////////////////////////////////////////////////////////////////

void CMainTracer::CreatOrAttachToLogFile()
{
    CMutexCatcher cMutex(m_mCreateLogFile);
    if (!m_bNeedToCreatOrAttachToLogFile)
    {
        return;
    }

    char    pszBuffer[TRACER_MAX_TRACE + 1];
    char        pszErrBuffer[TRACER_MAX_TRACE];
    m_pszLog = NULL;

    LPSECURITY_ATTRIBUTES lpSecAttr = NULL;
    SECURITY_DESCRIPTOR sdKeySecurity;
    SECURITY_ATTRIBUTES saKeyAttributes =
    {
        sizeof(SECURITY_ATTRIBUTES),
        &sdKeySecurity,
        FALSE
    };


    if(g_fIsWinNt)
    {
        if (!InitializeSecurityDescriptor(
                                &sdKeySecurity,
                                SECURITY_DESCRIPTOR_REVISION))
        {
            sprintf(pszErrBuffer, "%s Error %x\r\n",
                    "InitializeSecurityDescriptor failed "
                    "Tracing is disabled\r\n",
                    GetLastError());

            Log(TRACER_DEVICE_FLAG_DEBUGOUT,
                pszErrBuffer);
            return;
        }

        if (!SetSecurityDescriptorDacl(
                            &sdKeySecurity,
                            TRUE,
                            FALSE,
                            FALSE))
        {
            sprintf(pszErrBuffer, "%s Error %x\r\n",
                    "SetSecurityDescriptorDacl failed "
                    "Tracing is disabled\r\n",
                    GetLastError());

            Log(TRACER_DEVICE_FLAG_DEBUGOUT,
                pszErrBuffer);
            return;
        }

        lpSecAttr = &saKeyAttributes;
    }

    //
    // log file initialization
    //
    m_bNeedToCreatOrAttachToLogFile = FALSE;

    if (logUseAppName == m_LogState)
    {
        m_pszLogName = m_pszProgramName;
    }

    bool bExistingFile = false;

    strcpy(pszBuffer, m_pszLogName);
    strcat(pszBuffer, "_LogFileProtector");
    m_mLogFile.Init(pszBuffer);

    strcpy(pszBuffer, m_pszSysDrive);
    strcat(pszBuffer, "\\PKM_TRACER\\");
    strcat(pszBuffer, m_pszLogName);
    strcat(pszBuffer, ".log");

    m_ahLogFile = CreateFile(
                        pszBuffer,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        lpSecAttr,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (BAD_HANDLE((HANDLE)m_ahLogFile))
    {
         sprintf(pszErrBuffer, "%s error %x\r\n",
                "Fail To open log file. "
                "Tracing is disabled\r\n",
                GetLastError());

         Log(TRACER_DEVICE_FLAG_DEBUGOUT,
            pszErrBuffer);

        return;
    }

    if (ERROR_ALREADY_EXISTS  == GetLastError())
    {
        bExistingFile = true;
    }

    strcpy(pszBuffer, m_pszLogName);
    strcat(pszBuffer, "_LogFile");

    m_ahLog = CreateFileMapping(
                            (HANDLE)m_ahLogFile,
                            lpSecAttr,
                            PAGE_READWRITE,
                            0,
                            LOG_FILE_SIZE,
                            pszBuffer);

    if (BAD_HANDLE((HANDLE)m_ahLog))
    {
         sprintf(pszErrBuffer, "%s error %x\r\n",
                "Fail To open log file shared memory "
                "Tracing is disabled\r\n",
                GetLastError());

         Log(TRACER_DEVICE_FLAG_DEBUGOUT,
            pszErrBuffer);

        return;
    }

    m_ulLogSize = LOG_FILE_SIZE;

    m_pszLog = (char*) MapViewOfFile(
                            (HANDLE) m_ahLog,
                            FILE_MAP_ALL_ACCESS,
                            0,
                            0,
                            0);
    if (!m_pszLog)
    {
         sprintf(pszErrBuffer, "%s error %x\r\n",
                "Fail To open log file map view of file "
                "Tracing is disabled\r\n",
                GetLastError());

         Log(TRACER_DEVICE_FLAG_DEBUGOUT,
            pszErrBuffer);

        return;
    }

    m_amLog = (PBYTE) m_pszLog;

    m_pulNextFreeSpaceInLogFile = (ULONG*) m_pszLog;

    if (!bExistingFile)
    {
        memset(m_pszLog, 0, LOG_FILE_SIZE);
        *(m_pszLog + sizeof(ULONG)) = '\r'; // new line;
        *(m_pszLog + sizeof(ULONG) + sizeof(char)) = '\n'; // new line;
        *m_pulNextFreeSpaceInLogFile = LOG_START_POINT;
    }
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  ::IsRunningAsService
//      Purpose  :  To return if this process is running as a NT service.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   BOOL
//
//      Log:
//          Feb  1 1996 unknown source
//
//////////////////////////////////////////////////////////////////////////////*/
BOOL
IsRunningAsService()
{

    if(!g_fIsWinNt)
    {
        return FALSE;
    }

    HANDLE hProcessToken;
    DWORD groupLength = 50;

    PTOKEN_GROUPS groupInfo = (PTOKEN_GROUPS)LocalAlloc(0, groupLength);

    SID_IDENTIFIER_AUTHORITY siaNt = SECURITY_NT_AUTHORITY;
    PSID InteractiveSid;
    PSID ServiceSid;
    DWORD i;


    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
    {
        LocalFree(groupInfo);
        return(FALSE);
    }


    if (groupInfo == NULL)
    {
        CloseHandle(hProcessToken);
        LocalFree(groupInfo);
        return(FALSE);
    }


    if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
        groupLength, &groupLength))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            CloseHandle(hProcessToken);
            LocalFree(groupInfo);
            return(FALSE);
        }


        LocalFree(groupInfo);

        groupInfo = (PTOKEN_GROUPS)LocalAlloc(0, groupLength);

        if (groupInfo == NULL)
        {
            CloseHandle(hProcessToken);
            return(FALSE);
        }


        if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
            groupLength, &groupLength))
        {
            CloseHandle(hProcessToken);
            LocalFree(groupInfo);
            return(FALSE);
        }
    }


    //
    //  We now know the groups associated with this token.  We want to look to see if
    //  the interactive group is active in the token, and if so, we know that
    //  this is an interactive process.
    //
    //  We also look for the "service" SID, and if it's present, we know we're a service.
    //
    //  The service SID will be present iff the service is running in a
    //  user account (and was invoked by the service controller).
    //


    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_INTERACTIVE_RID,
        0, 0, 0, 0, 0, 0, 0, &InteractiveSid))
    {
        LocalFree(groupInfo);
        CloseHandle(hProcessToken);
        return(FALSE);
    }


    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_SERVICE_RID,
        0, 0, 0, 0, 0, 0, 0, &ServiceSid))
    {
        FreeSid(InteractiveSid);
        LocalFree(groupInfo);
        CloseHandle(hProcessToken);
        return(FALSE);
    }


    for (i = 0; i < groupInfo->GroupCount ; i += 1)
    {
        SID_AND_ATTRIBUTES sanda = groupInfo->Groups[i];
        PSID Sid = sanda.Sid;

        //
        //      Check to see if the group we're looking at is one of
        //      the 2 groups we're interested in.
        //

        if (EqualSid(Sid, InteractiveSid))
        {

            //
            //  This process has the Interactive SID in its
            //  token.  This means that the process is running as
            //  an EXE.
            //

            FreeSid(InteractiveSid);
            FreeSid(ServiceSid);
            LocalFree(groupInfo);
            CloseHandle(hProcessToken);
            return(FALSE);
        }
        else if (EqualSid(Sid, ServiceSid))
        {
            //
            //  This process has the Service SID in its
            //  token.  This means that the process is running as
            //  a service running in a user account.
            //

            FreeSid(InteractiveSid);
            FreeSid(ServiceSid);
            LocalFree(groupInfo);
            CloseHandle(hProcessToken);
            return(TRUE);
        }
    }

    //
    //  Neither Interactive or Service was present in the current users token,
    //  This implies that the process is running as a service, most likely
    //  running as LocalSystem.
    //

    FreeSid(InteractiveSid);
    FreeSid(ServiceSid);
    LocalFree(groupInfo);
    CloseHandle(hProcessToken);

    return(TRUE);
}

CLongTrace::CLongTrace(LPCSTR  pszFile, int iLine)
:   m_iLine(iLine),
    m_fRelease(FALSE)
{
    if (NULL == pszFile)
    {
        m_pszFile = "Unknown File";
    }
    else
    {
        m_pszFile = pszFile;
    }
}

CLongTrace::~CLongTrace()
{
    if (m_fRelease)
    {
        s_theLongTrace = NULL;
        m_fRelease = FALSE;
        s_TracerCriticalSection.Unlock();
    }
}

BOOL CLongTrace::Init(ERROR_LEVEL el, TAG tag)
{
    // First grab the critical section
    s_TracerCriticalSection.Lock();
    m_fRelease = TRUE;
    s_theLongTrace = this;


    if (CheckTraceRestrictions(el,tag))
    {
        g_pTracer->TraceSZ(0, m_pszFile, m_iLine, el, tag, "");
        return TRUE;
    }

    // destructor unlocks critical section
    return FALSE;
}

CLongTraceOutput::CLongTraceOutput(LPCSTR  pszFile, int iLine)
:   m_iLine(iLine)
{
    if (NULL == pszFile)
    {
        m_pszFile = "Unknown File";
    }
    else
    {
        m_pszFile = pszFile;
    }
}

void CLongTraceOutput::TraceSZ(LPCSTR psz , ...)
{
    if (NULL == s_theLongTrace)
    {
        CHAR szMessage[1000];
        _snprintf(szMessage, 1000, "Bad LongTrace in File %s line %d!\n", m_pszFile, m_iLine);

        OutputDebugString(szMessage);
    }
    else
    {
        va_list arglist;

        va_start(arglist, psz);
        g_pTracer->RawVaTraceSZ(psz, arglist);
    }
}

void CLongTraceOutput::TraceSZ(PCWSTR pwcs , ...)
{
    if (NULL == s_theLongTrace)
    {
        CHAR szMessage[1000];
        _snprintf(szMessage, 1000, "Bad LongTrace in File %s line %d!\n", m_pszFile, m_iLine);

        OutputDebugString(szMessage);
    }
    else
    {
        va_list arglist;

        va_start(arglist, pwcs);
        g_pTracer->RawVaTraceSZ(pwcs, arglist);
    }
}

CTempTrace::CTempTrace(LPCSTR pszFile, int iLine) :
m_pszFile(pszFile)
{
    m_iLine = iLine;
}


void
CTempTrace::TraceSZ(ERROR_LEVEL el, TAG tag, LPCSTR psz, ...)
{
    if (CheckTraceRestrictions(el,tag))
    {
        LPCSTR pszFile = m_pszFile ? m_pszFile : "Unknown File";

        va_list arglist;

        va_start(arglist, psz);
        g_pTracer->VaTraceSZ(0, pszFile, m_iLine, el, tag, psz, arglist);
    }
}

void
CTempTrace::TraceSZ(ERROR_LEVEL el, TAG tag, DWORD dwError, LPCSTR psz, ...)
{
    if (CheckTraceRestrictions(el,tag))
    {
        LPCSTR pszFile = m_pszFile ? m_pszFile : "Unknown File";

        va_list arglist;

        va_start(arglist, psz);
        g_pTracer->VaTraceSZ(dwError, pszFile, m_iLine, el, tag, psz, arglist);
    }
}

void
CTempTrace::TraceSZ(ERROR_LEVEL el, TAG tag, PCWSTR pwcs, ...)
{
    if (CheckTraceRestrictions(el,tag))
    {
        LPCSTR pszFile = m_pszFile ? m_pszFile : "Unknown File";

        va_list arglist;

        va_start(arglist, pwcs);
        g_pTracer->VaTraceSZ(0, pszFile , m_iLine, el, tag, pwcs, arglist);
    }
}

void
CTempTrace::TraceSZ(ERROR_LEVEL el, TAG tag, DWORD dwError, PCWSTR pwcs, ...)
{
    if (CheckTraceRestrictions(el,tag))
    {
        LPCSTR pszFile = m_pszFile ? m_pszFile : "Unknown File";

        va_list arglist;

        va_start(arglist, pwcs);
        g_pTracer->VaTraceSZ(dwError, pszFile, m_iLine, el, tag, pwcs, arglist);
    }
}

CTempTrace1::CTempTrace1(LPCSTR pszFile, int iLine, TAG tag, ERROR_LEVEL el) :
    m_pszFile(pszFile),
    m_iLine(iLine),
    m_ulTag(tag),
    m_el(el)
{
}


void
CTempTrace1::TraceSZ(LPCSTR psz, ...)
{
    LPCSTR pszFile = m_pszFile ? m_pszFile : "Unknown File";

    va_list arglist;

    va_start(arglist, psz);
    g_pTracer->VaTraceSZ(0, pszFile, m_iLine, m_el, m_ulTag, psz, arglist);
}

void
CTempTrace1::TraceSZ(DWORD dwError, LPCSTR psz, ...)
{
    LPCSTR pszFile = m_pszFile ? m_pszFile : "Unknown File";

    va_list arglist;

    va_start(arglist, psz);
    g_pTracer->VaTraceSZ(dwError, pszFile, m_iLine, m_el, m_ulTag, psz, arglist);
}

void
CTempTrace1::TraceSZ(PCWSTR pwcs, ...)
{
    LPCSTR pszFile = m_pszFile ? m_pszFile : "Unknown File";

    va_list arglist;

    va_start(arglist, pwcs);
    g_pTracer->VaTraceSZ(0, pszFile , m_iLine, m_el, m_ulTag, pwcs, arglist);
}

void
CTempTrace1::TraceSZ(DWORD dwError, PCWSTR pwcs, ...)
{
    LPCSTR pszFile = m_pszFile ? m_pszFile : "Unknown File";

    va_list arglist;

    va_start(arglist, pwcs);
    g_pTracer->VaTraceSZ(dwError, pszFile, m_iLine, m_el, m_ulTag, pwcs, arglist);
}

void __cdecl ShutdownTracer()
{
}
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\base.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  base.h
//      Project  :  pqs
//      Component:  wordbreaker
//
//      Author   :  urib
//
//      Log:
//          Jun 27 2000 urib  Move to use Trace(,, ()) instead of Trace((,,)).
//
////////////////////////////////////////////////////////////////////////////////
#ifndef  BASE_H
#define  BASE_H

#pragma once

#define PQS_CODE

#define STRICT
#include    <windows.h>

#include    "tracer.h"

//
// Append PQS to all our tags
//

//
// Append PQS to all our tags
//
typedef unsigned char*  PUSZ;

#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
#define TRACER_ON
#endif

#ifdef  TRACER_ON

#undef  DECLARE_TAG
#undef  DECLARE_GLOBAL_TAG
#undef  USES_TAG
#undef  Trace


#define Trace(el, tag, x)    \
    { \
        if (CheckTraceRestrictions(el, tag)) \
        { \
            CTempTrace1 tmp(__FILE__, __LINE__, tag, el); \
            tmp.TraceSZ x; \
        } \
    }

#define DECLARE_TAG(tagname, psz) \
static CTracerTag  tagname##Writer("PQS "##psz); \
static TAG         tagname = tagname##Writer;

#define DECLARE_GLOBAL_TAG(tagname, psz) \
static CTracerTag  tagname##Writer("PQS "##psz); \
extern TAG         tagname = tagname##Writer;

#define USES_TAG(name) extern TAG name;

#else

#undef  Trace
#define Trace(el, tag, x)

#endif

#include    "excption.h"
#include    "MemoryManagement.h"

#endif /* BASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\tracer\src\tracmain.h ===
#ifndef _TRACMAIN_H_
#define _TRACMAIN_H_

extern BOOL g_fIsWinNt;

#include "tracer.h"
#include "mutex.h"

#ifndef BAD_HANDLE
#define BAD_HANDLE(h)       ((0 == (h))||(INVALID_HANDLE_VALUE == (h)))
#endif

#define TRACER_MAX_TRACE            1000
#define TRACER_MAX_PROGRAM_NAME     32
#define LOG_START_POINT             sizeof(ULONG)+2*sizeof(char)

// Assert Levels
#define ASSERT_LEVEL_MESSAGE           0x00000001      // Output a message
#define ASSERT_LEVEL_BREAK             0x00000002      // Int 3 on assertion
#define ASSERT_LEVEL_POPUP             0x00000004      // And popup message
#define ASSERT_LEVEL_LOOP              0x00000008      // Loop

#define TRACER_STAMP_OFFSET         0
#define TRACER_FLAGS_TABLE_OFFSET   4
#define TAGS_TABLE_OFFSET           8
#define LAST_OFFSET                 12

#define TRACER_STAMP        "y.h"   

#define TAG_OUT_OF_TAG_ARRAY    0
#define TAG_GENERAL             1
#define TAG_ERROR               2
#define TAG_WARNING             3
#define TAG_INFORMATION         4
#define TAG_LAST                5    
      

BOOL IsRunningAsService();

class CAutoHandle
{
  public:
    // Constructor
    CAutoHandle(HANDLE h = NULL)
        :m_h(h){}

    // Behave like a HANDLE in assignments
    CAutoHandle& operator=(HANDLE h)
    {
        if (m_h == h)
        {
            return *this;
        }
        else if (m_h)
        {
            CloseHandle(m_h);
        }

        m_h = h;
        return(*this);
    }

    // Every kind of a  handle needs different closing.
    virtual
    ~CAutoHandle()
    {
        if (!BAD_HANDLE(m_h))
        {
            CloseHandle(m_h);
            m_h = NULL;
        }
    }

    // Behave like a handle
    operator HANDLE() const
    {
        return m_h;
    }

    // Allow access to the actual memory of the handle.
    HANDLE* operator &()
    {
        return &m_h;
    }

  protected:
    // The handle.
    HANDLE  m_h;
};


class CAutoMapFile
{
  public:
    // Constructor
    CAutoMapFile()
        :m_p(NULL){}

    CAutoMapFile& operator=(PBYTE p)
    {
		if ( m_p == p )
		{
	        return(*this);
		}
		UnMap();
		m_p = p;
        return(*this);
    }

    virtual
    ~CAutoMapFile()
    {
		UnMap();
    }

    operator PBYTE() const
    {
        return m_p;
    }

	// Unmap memory map file
	void UnMap()
	{
		if (m_p)
		{
            UnmapViewOfFile(m_p);
			m_p = NULL;
		}
	}

  protected:
    PBYTE m_p;
};

inline bool ReadFromExistingSharedMemory(
    PBYTE pbMem,
    ULONG** ppulNumOfFlagEntries,
    CTracerFlagEntry** paFlags,
    ULONG** ppulNextTagId,
    CTracerTagEntry** paTags
    )
{
    char* pszTracerStamp = (char*) (pbMem + TRACER_STAMP_OFFSET);
    if (strcmp(pszTracerStamp,TRACER_STAMP))
    {
        return false;                
    }

    ULONG ulFlagsTableOffset = *((ULONG*) (pbMem + TRACER_FLAGS_TABLE_OFFSET));
    ULONG ulTagsTableOffset = *((ULONG*) (pbMem + TAGS_TABLE_OFFSET));

    *ppulNumOfFlagEntries = (ULONG*) (pbMem + ulFlagsTableOffset);
    *paFlags = (CTracerFlagEntry*) (*ppulNumOfFlagEntries + 1);

    *ppulNextTagId = (ULONG*) (pbMem + ulTagsTableOffset);
    *paTags = (CTracerTagEntry*) (*ppulNextTagId + 1);

    return true;
}

////////////////////////////////////////////////////////////////////////////////
//
// The Null tracer. Doesn't trace anything
//
////////////////////////////////////////////////////////////////////////////////

class CNullTracer : public CTracer
{
public:
    CNullTracer();
    virtual ~CNullTracer(){}
    virtual void Free(){}
    virtual void TraceSZ(DWORD, LPCSTR, int, ERROR_LEVEL, TAG, LPCSTR, ...){}
    virtual void TraceSZ(DWORD, LPCWSTR, int, ERROR_LEVEL, TAG, PCWSTR, ...){}
    virtual void
        VaTraceSZ(DWORD, LPCSTR, int iLine, ERROR_LEVEL, TAG, LPCSTR, va_list){}
    virtual void
        VaTraceSZ(DWORD, LPCSTR, int iLine, ERROR_LEVEL, TAG, PCWSTR, va_list){}
    virtual void
        RawVaTraceSZ(LPCSTR, va_list) {}
    virtual void
        RawVaTraceSZ(PCWSTR, va_list) {}
    virtual HRESULT RegisterTagSZ(LPCSTR, TAG& ulTag){ulTag = 0; return S_OK;}
    virtual void TraceAssertSZ(LPCSTR, LPCSTR, LPCSTR, int){}
    virtual void TraceAssert(LPCSTR, LPCSTR, int){}

    virtual BOOL IsFailure(BOOL b, LPCSTR, int){return !b;}
    virtual BOOL IsBadAlloc(void* p, LPCSTR, int){return !p;}
    virtual BOOL IsBadHandle(HANDLE h, LPCSTR, int){return BAD_HANDLE(h);}
    virtual BOOL IsBadResult(HRESULT hr, LPCSTR, int){return FAILED(hr);}

public:
    CTracerTagEntry m_Tags[1];
    CTracerFlagEntry m_Flags[LAST_FLAG];
};

////////////////////////////////////////////////////////////////////////////////
//
//  class  -  CMainTracer - definition
//
////////////////////////////////////////////////////////////////////////////////

class CMainTracer : public CTracer {
  public:
    // Constructors - szProgramName prefix for all traces,
    //  second parameter - log file or stream
    CMainTracer();

    // Some clean up is required.
    ~CMainTracer();

    // The TraceSZ function output is defined by the tags mode
    //  one can change the tags mode by calling Enable tag and
    //  get the mode by calling IsEnabled.
    //-------------------------------------------------------------------------
    // accepts printf format for traces

    virtual void
    TraceSZ(DWORD dwError, LPCSTR, int, ERROR_LEVEL, TAG, LPCSTR, ...);

    virtual void
    TraceSZ(DWORD dwError, LPCSTR, int, ERROR_LEVEL, TAG, PCWSTR,...);

    // Implement the TraceSZ function.
    virtual void
    VaTraceSZ(DWORD dwError, LPCSTR, int, ERROR_LEVEL, TAG, LPCSTR, va_list);
    virtual void
    VaTraceSZ(DWORD dwError, LPCSTR, int, ERROR_LEVEL, TAG, PCWSTR, va_list);

    // Raw output functions
    virtual void
    RawVaTraceSZ(LPCSTR, va_list);
    virtual void
    RawVaTraceSZ(PCWSTR, va_list);

    // assert, different implementations possible - gui or text
    virtual void TraceAssertSZ(LPCSTR, LPCSTR, LPCSTR, int);

    // Create or open a new tag for tracing
    HRESULT RegisterTagSZ(LPCSTR, TAG&);

public:

    // Actually print it.
    void    Log(DWORD, LPSTR);
    void    Log(DWORD, PWSTR);

    DWORD   GetErrorStringFromCode(DWORD dwError, char *pszBuffer, ULONG ccBuffer);

    bool ReadFromExistingSharedMemory(PBYTE pvMem);
    bool InitializeSharedMemory(PBYTE pvMem);

    BOOL    IsRunningAsService();
    BOOL    LocalIsDebuggerPresent(BOOL* pfIsAPIAvailable);
    
    void CreatOrAttachToLogFile();

  public:

    // Mutex to atomize the tag id registry incrementation.
    CMutex              m_mTagId;
    CMutex              m_mLogFile;
    CMutex              m_mCreateLogFile;

    char m_pszProgramName[MAX_PATH];
    char m_pszSysDrive[MAX_PATH];
    
    CAutoHandle m_ahSharedMemoryFile;
    CAutoHandle m_ahSharedMemory;
    CAutoMapFile m_amSharedMemory;

    CAutoHandle m_ahLogFile;
    CAutoHandle m_ahLog;
    CAutoMapFile m_amLog;

    char* m_pszLog;
    ULONG m_ulLogSize;
    ULONG* m_pulNextFreeSpaceInLogFile;

    BOOL    m_fIsRunningAsService;
    BOOL m_bNeedToCreatOrAttachToLogFile;
};

inline BOOL IsWinNt()
{
    OSVERSIONINFOA verinfo;
    verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

    if (GetVersionExA (&verinfo))
    {
        if (verinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            return TRUE;
        }
    }
    return FALSE;
}

class CInitTracerGlobals
{
public:
    CInitTracerGlobals()
    {
        g_fIsWinNt = IsWinNt();
    }
};

#endif // _TRACMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\formats.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//  Filename :  Formats.cpp
//  Purpose  :  Global dictionaries
//
//  Project  :  WordBreakers
//  Component:  English word breaker
//
//  Author   :  yairh
//
//  Log:
//
//      May 30 2000 yairh creation
//
////////////////////////////////////////////////////////////////////////////////

#include "base.h"
#include "tokenizer.h"

const CCliticsTerm g_aClitics[] =
{
    { L"l\'",           2 , HEAD_MATCH_TRUNCATE},
    { L"l\x0a0\'",      3 , HEAD_MATCH_TRUNCATE},
    { L"d\'",           2 , HEAD_MATCH_TRUNCATE},
    { L"d\x0a0\'",      3 , HEAD_MATCH_TRUNCATE},
    { L"j\'",           2 , HEAD_MATCH_TRUNCATE},
    { L"j\x0a0\'",      3 , HEAD_MATCH_TRUNCATE},
    { L"m\'",           2 , HEAD_MATCH_TRUNCATE},
    { L"m\x0a0\'",      3 , HEAD_MATCH_TRUNCATE},
    { L"n\'",           2 , HEAD_MATCH_TRUNCATE},
    { L"n\x0a0\'",      3 , HEAD_MATCH_TRUNCATE},
    { L"s\'",           2 , HEAD_MATCH_TRUNCATE},
    { L"s\x0a0\'",      3 , HEAD_MATCH_TRUNCATE},
    { L"q\'",           2 , HEAD_MATCH_TRUNCATE},
    { L"q\x0a0\'",      3 , HEAD_MATCH_TRUNCATE},
    { L"t\'",           2 , HEAD_MATCH_TRUNCATE},
    { L"t\x0a0\'",      3 , HEAD_MATCH_TRUNCATE},
    { L"un\'",          3 , HEAD_MATCH_TRUNCATE},
    { L"un\x0a0\'",     4 , HEAD_MATCH_TRUNCATE},
    { L"nell\'",        5 , HEAD_MATCH_TRUNCATE},
    { L"nell\x0a0\'",   6 , HEAD_MATCH_TRUNCATE},
    { L"all\'",         4 , HEAD_MATCH_TRUNCATE},
    { L"all\x0a0\'",    5 , HEAD_MATCH_TRUNCATE},
    { L"dell\'",        5 , HEAD_MATCH_TRUNCATE},
    { L"dell\x0a0\'",   6 , HEAD_MATCH_TRUNCATE},
    { L"Sull\'",        5 , HEAD_MATCH_TRUNCATE},
    { L"Sull\x0a0\'",   6 , HEAD_MATCH_TRUNCATE},
    { L"tutt\'",        5 , HEAD_MATCH_TRUNCATE},
    { L"tutt\x0a0\'",   6 , HEAD_MATCH_TRUNCATE},
    { L"qu\'",          3 , HEAD_MATCH_TRUNCATE},
    { L"qu\x0a0\'",     4 , HEAD_MATCH_TRUNCATE},
    { L"\'s",           2 , TAIL_MATCH_TRUNCATE},
    { L"\'ll",          3 , TAIL_MATCH_TRUNCATE},
    { L"\'m",           2 , TAIL_MATCH_TRUNCATE},
    { L"\'ve",          3 , TAIL_MATCH_TRUNCATE},
    { L"\'re",          3 , TAIL_MATCH_TRUNCATE},
    { L"\'d",           2 , TAIL_MATCH_TRUNCATE},

    { L"-je",           3 , TAIL_MATCH_TRUNCATE},
    { L"-tu",           3 , TAIL_MATCH_TRUNCATE},

    { L"-il",           3 , TAIL_MATCH_TRUNCATE},
    { L"-elle",         5 , TAIL_MATCH_TRUNCATE},
    { L"-on",           3 , TAIL_MATCH_TRUNCATE},
    { L"-ils",          4 , TAIL_MATCH_TRUNCATE},
    { L"-elles",        6 , TAIL_MATCH_TRUNCATE},

    { L"-t-il",         5 , TAIL_MATCH_TRUNCATE},
    { L"-t-elle",       7 , TAIL_MATCH_TRUNCATE},
    { L"-t-on",         5 , TAIL_MATCH_TRUNCATE},
    { L"-t-ils",        6 , TAIL_MATCH_TRUNCATE},
    { L"-t-elles",      8 , TAIL_MATCH_TRUNCATE},

    { L"-t'",           3 , TAIL_MATCH_TRUNCATE},
    { L"-t'y",          4 , TAIL_MATCH_TRUNCATE},
    { L"-t'en",         5 , TAIL_MATCH_TRUNCATE},

    { L"-m'",           3 , TAIL_MATCH_TRUNCATE},
    { L"-m'y",          4 , TAIL_MATCH_TRUNCATE},
    { L"-m'en",         5 , TAIL_MATCH_TRUNCATE},

    { L"-l'",           3 , TAIL_MATCH_TRUNCATE},
    { L"-l'y",          4 , TAIL_MATCH_TRUNCATE},
    { L"-l'en",         5 , TAIL_MATCH_TRUNCATE},

    { L"-z-y",          4 , TAIL_MATCH_TRUNCATE},
    { L"-z-en",         5 , TAIL_MATCH_TRUNCATE},
    { L"-y",            2 , TAIL_MATCH_TRUNCATE},
    { L"'y",            2 , TAIL_MATCH_TRUNCATE},
    { L"-y-en",         5 , TAIL_MATCH_TRUNCATE},

    { L"-nous",         5 , TAIL_MATCH_TRUNCATE},
    { L"-nous-y",       7 , TAIL_MATCH_TRUNCATE},
    { L"-nous-en",      9 , TAIL_MATCH_TRUNCATE},

    { L"-vous",         5 , TAIL_MATCH_TRUNCATE},
    { L"-vous-y",       7 , TAIL_MATCH_TRUNCATE},
    { L"-vous-en",      8 , TAIL_MATCH_TRUNCATE},

    { L"-toi",          4 , TAIL_MATCH_TRUNCATE},
    { L"-toi-z-y",      8 , TAIL_MATCH_TRUNCATE},
    { L"-toi-z-en",     9 , TAIL_MATCH_TRUNCATE},

    { L"-moi",          4 , TAIL_MATCH_TRUNCATE},
    { L"-moi-z-y",      8 , TAIL_MATCH_TRUNCATE},
    { L"-moi-z-en",     9 , TAIL_MATCH_TRUNCATE},

    { L"-lui",          4 , TAIL_MATCH_TRUNCATE},
    { L"-lui-en",       7 , TAIL_MATCH_TRUNCATE},

    { L"-leur",         5 , TAIL_MATCH_TRUNCATE},
    { L"-leur-en",      8 , TAIL_MATCH_TRUNCATE},

    { L"-eux",          4 , TAIL_MATCH_TRUNCATE},

    { L"-en",           3 , TAIL_MATCH_TRUNCATE},
    { L"'en",           3 , TAIL_MATCH_TRUNCATE},

    { L"-la",           3 , TAIL_MATCH_TRUNCATE},
    { L"-la-leur",      8 , TAIL_MATCH_TRUNCATE},
    { L"-la-vous",      8 , TAIL_MATCH_TRUNCATE},
    { L"-la-nous",      8 , TAIL_MATCH_TRUNCATE},
    { L"-la-nous-y",    10 , TAIL_MATCH_TRUNCATE},
    { L"-la-lui",       7 , TAIL_MATCH_TRUNCATE},
    { L"-la-lui-en",    10 , TAIL_MATCH_TRUNCATE},
    { L"-la-toi",       7 , TAIL_MATCH_TRUNCATE},
    { L"-la-moi",       7 , TAIL_MATCH_TRUNCATE},
    { L"-la-moi-z-y",   11, TAIL_MATCH_TRUNCATE},
    { L"-la-moi-z-en",  12 , TAIL_MATCH_TRUNCATE},

    { L"-le",           3 , TAIL_MATCH_TRUNCATE},
    { L"-le-leur",      8 , TAIL_MATCH_TRUNCATE},
    { L"-le-vous",      8 , TAIL_MATCH_TRUNCATE},
    { L"-le-nous",      8 , TAIL_MATCH_TRUNCATE},
    { L"-le-nous-y",    10 , TAIL_MATCH_TRUNCATE},
    { L"-le-lui",       7 , TAIL_MATCH_TRUNCATE},
    { L"-le-lui-en",    10 , TAIL_MATCH_TRUNCATE},
    { L"-le-toi",       7 , TAIL_MATCH_TRUNCATE},
    { L"-le-moi",       7 , TAIL_MATCH_TRUNCATE},
    { L"-le-moi-z-y",   11, TAIL_MATCH_TRUNCATE},
    { L"-le-moi-z-en",  12 , TAIL_MATCH_TRUNCATE},

    { L"-les",          4 , TAIL_MATCH_TRUNCATE},
    { L"-les-leur",     9 , TAIL_MATCH_TRUNCATE},
    { L"-les-vous",     9 , TAIL_MATCH_TRUNCATE},
    { L"-les-nous",     9 , TAIL_MATCH_TRUNCATE},
    { L"-les-nous-y",   11 , TAIL_MATCH_TRUNCATE},
    { L"-les-lui",      8 , TAIL_MATCH_TRUNCATE},
    { L"-les-lui-en",   11 , TAIL_MATCH_TRUNCATE},
    { L"-les-toi",      8 , TAIL_MATCH_TRUNCATE},
    { L"-les-moi",      8 , TAIL_MATCH_TRUNCATE},
    { L"-les-moi-z-y",  12, TAIL_MATCH_TRUNCATE},
    { L"-les-moi-z-en", 13 , TAIL_MATCH_TRUNCATE},
    
    { L"-ce",           3 , TAIL_MATCH_TRUNCATE},
    { L"-cis",          4 , TAIL_MATCH_TRUNCATE},
    { L"-cies-l",      8 , TAIL_MATCH_TRUNCATE},
    { L"-cies",         5 , TAIL_MATCH_TRUNCATE},
    { L"-cie",          4 , TAIL_MATCH_TRUNCATE},
    { L"-ci",           3 , TAIL_MATCH_TRUNCATE},
    { L"-l",           3 , TAIL_MATCH_TRUNCATE},
    { L"-cis-l",       7 , TAIL_MATCH_TRUNCATE},
    { L"-cies-ci",      8 , TAIL_MATCH_TRUNCATE},
    { L"-cie-l",       7 , TAIL_MATCH_TRUNCATE},

    { L"\0",            0 , NON_MATCH_TRUNCATE}
};


const CCliticsTerm g_SClitics =
{ L"s\'", 1, TAIL_MATCH_TRUNCATE }; 


const CCliticsTerm g_EmptyClitics =
{ L"\0", 0, NON_MATCH_TRUNCATE };


const CDateTerm g_aDateFormatList[] =
{
//    format       len Type            D_M1   D_M1    D_M2   D_M2    Year    Year
//                                    offset  len     len    offset  len     offset
    {L"#.#.##",     6,  0,              0,      1,      2,      1,      4,      2},
    {L"##.#.##",    7,  0,              0,      2,      3,      1,      5,      2},
    {L"#.##.##",    7,  0,              0,      1,      2,      2,      5,      2},
    {L"##.##.##",   8,  0,              0,      2,      3,      2,      6,      2},
    {L"#.#.###",    7,  0,              0,      1,      2,      1,      4,      3},
    {L"##.#.###",   8,  0,              0,      2,      3,      1,      5,      3},
    {L"#.##.###",   8,  0,              0,      1,      2,      2,      5,      3},
    {L"##.##.###",  9,  0,              0,      2,      3,      2,      6,      3},
    {L"#.#.####",   8,  0,              0,      1,      2,      1,      4,      4},
    {L"##.#.####",  9,  0,              0,      2,      3,      1,      5,      4},
    {L"#.##.####",  9,  0,              0,      1,      2,      2,      5,      4},
    {L"##.##.####", 10, 0,              0,      2,      3,      2,      6,      4},
    {L"###.#.#",    7,  YYMMDD_TYPE,    6,      1,      4,      1,      0,      3},
    {L"###.##.#",   8,  YYMMDD_TYPE,    7,      1,      4,      2,      0,      3},
    {L"###.#.##",   8,  YYMMDD_TYPE,    6,      2,      4,      1,      0,      3},
    {L"###.##.##",  9,  YYMMDD_TYPE,    7,      2,      4,      2,      0,      3},
    {L"####.#.#",   8,  YYMMDD_TYPE,    7,      1,      5,      1,      0,      4},
    {L"####.##.#",  9,  YYMMDD_TYPE,    8,      1,      5,      2,      0,      4},
    {L"####.#.##",  9,  YYMMDD_TYPE,    7,      2,      5,      1,      0,      4},
    {L"####.##.##", 10, YYMMDD_TYPE,    8,      2,      5,      2,      0,      4},
    {L"\0",         0,  0,}
};


const CTimeTerm g_aTimeFormatList[] =
{
//    format           len   hour   hour    min       min     sec     sec  AM/PM 
//                           offset  len     offset    len    offset   len
    {L"#:#",            3,    0,     1,      2,        1,       0,      0,   None   },
    {L"##:#",           4,    0,     2,      3,        1,       0,      0,   None   },
    {L"#:##",           4,    0,     1,      2,        2,       0,      0,   None   },
    {L"##:##",          5,    0,     2,      3,        2,       0,      0,   None   },
    {L"#:#:#",          5,    0,     1,      2,        1,       4,      1,   None   },
    {L"#:#:##",         6,    0,     1,      2,        1,       4,      2,   None   },
    {L"##:#:#",         6,    0,     2,      3,        1,       5,      1,   None   },
    {L"##:#:##",        7,    0,     2,      3,        1,       5,      2,   None   },
    {L"#:##:#",         6,    0,     1,      2,        2,       5,      1,   None   },
    {L"#:##:##",        7,    0,     1,      2,        2,       5,      2,   None   },
    {L"##:##:#",        7,    0,     2,      3,        2,       6,      1,   None   },
    {L"##:##:##",       8,    0,     2,      3,        2,       6,      2,   None   },

    {L"#AM",            3,    0,     1,      0,        0,       0,      0,   Am    },
    {L"##AM",           4,    0,     2,      0,        0,       0,      0,   Am    },
    {L"#:#AM",          5,    0,     1,      2,        1,       0,      0,   Am    },
    {L"##:#AM",         6,    0,     2,      3,        1,       0,      0,   Am    },
    {L"#:##AM",         6,    0,     1,      2,        2,       0,      0,   Am    },
    {L"##:##AM",        7,    0,     2,      3,        2,       0,      0,   Am    },
    {L"#:#:#AM",        7,    0,     1,      2,        1,       4,      1,   Am    },
    {L"#:#:##AM",       8,    0,     1,      2,        1,       4,      2,   Am    },
    {L"##:#:#AM",       8,    0,     2,      3,        1,       5,      1,   Am    },
    {L"##:#:##AM",      9,    0,     2,      3,        1,       5,      2,   Am    },
    {L"#:##:#AM",       8,    0,     1,      2,        2,       5,      1,   Am    },
    {L"#:##:##AM",      9,    0,     1,      2,        2,       5,      2,   Am    },
    {L"##:##:#AM",      9,    0,     2,      3,        2,       6,      1,   Am    },
    {L"##:##:##AM",     10,   0,     2,      3,        2,       6,      2,   Am    },
                        
    {L"#PM",            3,    0,     1,      0,        0,       0,      0,   Pm    },
    {L"##PM",           4,    0,     2,      0,        0,       0,      0,   Pm    },
    {L"#:#PM",          5,    0,     1,      2,        1,       0,      0,   Pm    },
    {L"##:#PM",         6,    0,     2,      3,        1,       0,      0,   Pm    },
    {L"#:##PM",         6,    0,     1,      2,        2,       0,      0,   Pm    },
    {L"##:##PM",        7,    0,     2,      3,        2,       0,      0,   Pm    },
    {L"#:#:#PM",        7,    0,     1,      2,        1,       4,      1,   Pm    },
    {L"#:#:##PM",       8,    0,     1,      2,        1,       4,      2,   Pm    },
    {L"##:#:#PM",       8,    0,     2,      3,        1,       5,      1,   Pm    },
    {L"##:#:##PM",      9,    0,     2,      3,        1,       5,      2,   Pm    },
    {L"#:##:#PM",       8,    0,     1,      2,        2,       5,      1,   Pm    },
    {L"#:##:##PM",      9,    0,     1,      2,        2,       5,      2,   Pm    },
    {L"##:##:#PM",      9,    0,     2,      3,        2,       6,      1,   Pm    },
    {L"##:##:##PM",     10,   0,     2,      3,        2,       6,      2,   Pm    },
                        
    {L"#a.m",           4,    0,     1,      0,        0,       0,      0,   Am    },
    {L"##a.m",          5,    0,     2,      0,        0,       0,      0,   Am    },
    {L"#:#a.m",         6,    0,     1,      2,        1,       0,      0,   Am    },
    {L"##:#a.m",        7,    0,     2,      3,        1,       0,      0,   Am    },
    {L"#:##a.m",        7,    0,     1,      2,        2,       0,      0,   Am    },
    {L"##:##a.m",       8,    0,     2,      3,        2,       0,      0,   Am    },
    {L"#:#:#a.m",       8,    0,     1,      2,        1,       4,      1,   Am    },
    {L"#:#:##a.m",      9,    0,     1,      2,        1,       4,      2,   Am    },
    {L"##:#:#a.m",      9,    0,     2,      3,        1,       5,      1,   Am    },
    {L"##:#:##a.m",     10,   0,     2,      3,        1,       5,      2,   Am    },
    {L"#:##:#a.m",      9,    0,     1,      2,        2,       5,      1,   Am    },
    {L"#:##:##a.m",     10,   0,     1,      2,        2,       5,      2,   Am    },
    {L"##:##:#a.m",     10,   0,     2,      3,        2,       6,      1,   Am    },
    {L"##:##:##a.m",    11,   0,     2,      3,        2,       6,      2,   Am    },
                        
    {L"#p.m",           4,    0,     1,      0,        0,       0,      0,   Pm    },
    {L"##p.m",          5,    0,     2,      0,        0,       0,      0,   Pm    },
    {L"#:#p.m",         6,    0,     1,      2,        1,       0,      0,   Pm    },
    {L"##:#p.m",        7,    0,     2,      3,        1,       0,      0,   Pm    },
    {L"#:##p.m",        7,    0,     1,      2,        2,       0,      0,   Pm    },
    {L"##:##p.m",       8,    0,     2,      3,        2,       0,      0,   Pm    },
    {L"#:#:#p.m",       8,    0,     1,      2,        1,       4,      1,   Pm    },
    {L"#:#:##p.m",      9,    0,     1,      2,        1,       4,      2,   Pm    },
    {L"##:#:#p.m",      9,    0,     2,      3,        1,       5,      1,   Pm    },
    {L"##:#:##p.m",     10,   0,     2,      3,        1,       5,      2,   Pm    },
    {L"#:##:#p.m",      9,    0,     1,      2,        2,       5,      1,   Pm    },
    {L"#:##:##p.m",     10,   0,     1,      2,        2,       5,      2,   Pm    },
    {L"##:##:#p.m",     10,   0,     2,      3,        2,       6,      1,   Pm    },
    {L"##:##:##p.m",    11,   0,     2,      3,        2,       6,      2,   Pm    },

    {L"#H",             2,    0,     1,      0,        0,       0,      0,   None   },
    {L"##H",            3,    0,     2,      0,        0,       0,      0,   None   },
    {L"#H#",            3,    0,     1,      2,        1,       0,      0,   None   },
    {L"##H#",           4,    0,     2,      3,        1,       0,      0,   None   },
    {L"#H##",           4,    0,     1,      2,        2,       0,      0,   None   },
    {L"##H##",          5,    0,     2,      3,        2,       0,      0,   None   },

    {L"\0",             0,    0,     0,      0,        0,       0,      0,   None   },

};

CAutoClassPointer<CClitics> g_pClitics;

CAutoClassPointer<CSpecialAbbreviationSet> g_pEngAbbList;
CAutoClassPointer<CSpecialAbbreviationSet> g_pFrnAbbList;
CAutoClassPointer<CSpecialAbbreviationSet> g_pItlAbbList;
CAutoClassPointer<CSpecialAbbreviationSet> g_pSpnAbbList;

CAutoClassPointer<CDateFormat> g_pDateFormat;
CAutoClassPointer<CTimeFormat> g_pTimeFormat;

CClitics::CClitics()
{
    DictStatus status;

    WCHAR* pTerm;
    int i;
    for (i = 0, pTerm = g_aClitics[i].pwcs;
         *pTerm != L'\0';
         i++, pTerm = g_aClitics[i].pwcs)
    {
        status = m_trieClitics.trie_Insert(
                                        pTerm,
                                        TRIE_IGNORECASE,
                                        const_cast<CCliticsTerm*>(&g_aClitics[i]),
                                        NULL);

        Assert (DICT_SUCCESS == status);
    }
}


CSpecialAbbreviationSet::CSpecialAbbreviationSet(const CAbbTerm* pAbbTermList)
{
    DictStatus status;

    WCHAR* pTerm;
    int i;
    for (i = 0, pTerm = pAbbTermList[i].pwcsAbb;
         *pTerm != L'\0';
         i++, pTerm = pAbbTermList[i].pwcsAbb)
    {
        status = m_trieAbb.trie_Insert(
                                    pTerm,
                                    TRIE_IGNORECASE,
                                    const_cast<CAbbTerm*>(&pAbbTermList[i]),
                                    NULL);

        Assert (DICT_SUCCESS == status);
    }

}


CDateFormat::CDateFormat()
{
    DictStatus status;

    WCHAR* pTerm;
    int i;
    for (i = 0, pTerm = g_aDateFormatList[i].pwcsFormat;
         *pTerm != L'\0';
         i++, pTerm = g_aDateFormatList[i].pwcsFormat)
    {
        status = m_trieDateFormat.trie_Insert(
                                        pTerm,
                                        TRIE_IGNORECASE,
                                        const_cast<CDateTerm*>(&g_aDateFormatList[i]),
                                        NULL);

        Assert (DICT_SUCCESS == status);
    }
}

CTimeFormat::CTimeFormat()
{
    DictStatus status;

    WCHAR* pTerm;
    int i;
    for (i = 0, pTerm = g_aTimeFormatList[i].pwcsFormat;
         *pTerm != L'\0';
         i++, pTerm = g_aTimeFormatList[i].pwcsFormat)
    {
        status = m_trieTimeFormat.trie_Insert(
                                        pTerm,
                                        TRIE_IGNORECASE,
                                        const_cast<CTimeTerm*>(&g_aTimeFormatList[i]),
                                        NULL);

        Assert (DICT_SUCCESS == status);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\custombreaking.h ===
////////////////////////////////////////////////////////////////////////////////
//
//  Filename :  CustomBreaking.h
//  Purpose  :  enable the user to specify in a file a list of tokens that 
//              should not be broken.
//
//  Project  :  WordBreakers
//  Component:  word breaker
//
//  Author   :  yairh
//
//  Log:
//
//      Jul 20 2000 yairh creation
//
////////////////////////////////////////////////////////////////////////////////

#ifndef _CUSTOM_BREAKING_H_
#define _CUSTOM_BREAKING_H_

#include "trie.h"
#include "vararray.h"
#include "AutoPtr.h"
#include "wbutils.h"

///////////////////////////////////////////////////////////////////////////////
// Class CCustomWordTerm
///////////////////////////////////////////////////////////////////////////////
class CCustomWordTerm
{
public:

    CCustomWordTerm(const WCHAR* pwcs);
    ~CCustomWordTerm()
    {
        delete m_pwcs;
    }

    bool CheckWord(
                const ULONG ulLen, 
                ULONG ulOffsetToBaseWord,
                ULONG ulBaseWordLen,
                const WCHAR* pwcsBuf,
                ULONG* pMatchOffset,
                ULONG* pulMatchLen);

    ULONG GetTxtStart()
    {
        return m_ulStartTxt;
    }

    ULONG GetTxtEnd()
    {
        return m_ulEndTxt;
    }

    WCHAR* GetTxt()
    {
        return m_pwcs;
    }

private:
    ULONG m_ulStartTxt;
    ULONG m_ulEndTxt;
    ULONG m_ulLen;
    WCHAR* m_pwcs;
     
};

///////////////////////////////////////////////////////////////////////////////
// Class CCustomWordCollection
///////////////////////////////////////////////////////////////////////////////
class CCustomWordCollection
{
public:

    CCustomWordCollection() :
        m_vaWordCollection(1),
        m_ulCount(0)
    {
    }

    void AddWord(const WCHAR* pwcs);
    
    CCustomWordTerm* GetFirstWord()
    {
        if (m_ulCount)
        {
            return m_vaWordCollection[(ULONG)0].Get();
        }
        return NULL;
    }

    bool CheckWord(
                const ULONG ulLen, 
                ULONG ulOffsetToBaseWord,
                ULONG ulBaseWordLen,
                const WCHAR* pwcsBuf,
                ULONG* pulMatchOffset,
                ULONG* pulMatchLen);
private:
    ULONG m_ulCount;
    CVarArray< CAutoClassPointer<CCustomWordTerm> > m_vaWordCollection;
};


///////////////////////////////////////////////////////////////////////////////
// Class CCustomBreaker
///////////////////////////////////////////////////////////////////////////////
class CCustomBreaker
{
public:

    CCustomBreaker(LCID lcid);

    bool IsNotEmpty()
    {
        return (m_ulWordCount > 0);
    }
    
    bool BreakText(
                ULONG ulLen,
                WCHAR* pwcsBuf,
                ULONG* pulOutLen,
                ULONG* pulOffset);


private:

    CTrie<CCustomWordCollection, CWbToUpper> m_Trie; 
    ULONG m_ulWordCount;
};

extern CAutoClassPointer<CCustomBreaker> g_apEngCustomBreaker;
extern CAutoClassPointer<CCustomBreaker> g_apEngUKCustomBreaker;
extern CAutoClassPointer<CCustomBreaker> g_apFrnCustomBreaker;
extern CAutoClassPointer<CCustomBreaker> g_apSpnCustomBreaker;
extern CAutoClassPointer<CCustomBreaker> g_apItlCustomBreaker;

#endif // _CUSTOM_BREAKING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\formats.h ===
////////////////////////////////////////////////////////////////////////////////
//
//  Filename :  Formats.h
//  Purpose  :  Global dictionaries
//
//  Project  :  WordBreakers
//  Component:  English word breaker
//
//  Author   :  yairh
//
//  Log:
//
//      May 30 2000 yairh creation
//
////////////////////////////////////////////////////////////////////////////////

#ifndef _FORMATS_H_
#define _FORMATS_H_

#include "trie.h"
#include "wbutils.h"

///////////////////////////////////////////////////////////////////////////////
// Class CCliticsTerm
///////////////////////////////////////////////////////////////////////////////

#define NON_MATCH_TRUNCATE  0
#define HEAD_MATCH_TRUNCATE 1
#define TAIL_MATCH_TRUNCATE 2

struct CCliticsTerm
{
    WCHAR* pwcs;
    ULONG  ulLen;
    ULONG  ulOp;
};

///////////////////////////////////////////////////////////////////////////////
// Class CClitics
///////////////////////////////////////////////////////////////////////////////

class CClitics
{
public:
    CClitics();

    CTrie<CCliticsTerm, CWbToUpper> m_trieClitics;
};

///////////////////////////////////////////////////////////////////////////////
// Class CAbbTerm
///////////////////////////////////////////////////////////////////////////////

struct CAbbTerm
{
    WCHAR* pwcsAbb;
    ULONG ulAbbLen;
    WCHAR* pwcsCanonicalForm;
    ULONG ulCanLen;
};

///////////////////////////////////////////////////////////////////////////////
// Class CSpecialAbbreviation
///////////////////////////////////////////////////////////////////////////////

class CSpecialAbbreviationSet
{
public:
    CSpecialAbbreviationSet(const CAbbTerm* pAbbTermList);

    CTrie<CAbbTerm, CWbToUpper> m_trieAbb;
};


///////////////////////////////////////////////////////////////////////////////
// Class CDateTerm 
///////////////////////////////////////////////////////////////////////////////
struct CDateTerm 
{
    WCHAR* pwcsFormat;
    BYTE   bLen;
    BYTE   bType;
    BYTE   bD_M1Offset;
    BYTE   bD_M1Len;
    BYTE   bD_M2Offset;
    BYTE   bD_M2Len;
    BYTE   bYearOffset;
    BYTE   bYearLen;
};

#define YYMMDD_TYPE 1
///////////////////////////////////////////////////////////////////////////////
// Class CDateFormat 
///////////////////////////////////////////////////////////////////////////////

class CDateFormat
{
public:
    CDateFormat();

    CTrie<CDateTerm, CWbToUpper> m_trieDateFormat;
};

///////////////////////////////////////////////////////////////////////////////
// Class CTimeTerm 
///////////////////////////////////////////////////////////////////////////////
enum TimeFormat
{
    None = 0,
    Am,
    Pm
};

struct CTimeTerm 
{
    WCHAR* pwcsFormat;
    BYTE   bLen;
    BYTE   bHourOffset;
    BYTE   bHourLen;
    BYTE   bMinOffset;
    BYTE   bMinLen;
    BYTE   bSecOffset;
    BYTE   bSecLen;
    TimeFormat AmPm;
    
};

///////////////////////////////////////////////////////////////////////////////
// Class CTimeFormat 
///////////////////////////////////////////////////////////////////////////////

class CTimeFormat
{
public:
    CTimeFormat();

    CTrie<CTimeTerm, CWbToUpper> m_trieTimeFormat;
};


extern CAutoClassPointer<CClitics> g_pClitics;
extern CAutoClassPointer<CSpecialAbbreviationSet> g_pEngAbbList;
extern CAutoClassPointer<CSpecialAbbreviationSet> g_pFrnAbbList;
extern CAutoClassPointer<CSpecialAbbreviationSet> g_pSpnAbbList;
extern CAutoClassPointer<CSpecialAbbreviationSet> g_pItlAbbList;
extern CAutoClassPointer<CDateFormat> g_pDateFormat;
extern CAutoClassPointer<CTimeFormat> g_pTimeFormat;
extern const CCliticsTerm g_aClitics[];
extern const CCliticsTerm g_SClitics;
extern const CCliticsTerm g_EmptyClitics;

extern const CAbbTerm g_aEngAbbList[];
extern const CAbbTerm g_aFrenchAbbList[];
extern const CAbbTerm g_aSpanishAbbList[];
extern const CAbbTerm g_aItalianAbbList[];

extern const CDateTerm g_aDateFormatList[];
extern const CTimeTerm s_aTimeFormatList[];

#define  MAX_DATE_FORMAT_LEN 10
#define  MAX_TIME_FORMAT_LEN 12

#endif // _FORMATS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\custombreaking.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//  Filename :  Tokenizer.cpp
//  Purpose  :  Tokenizer declerations
//
//  Project  :  WordBreakers
//  Component:  English word breaker
//
//  Author   :  yairh
//
//  Log:
//
//      Jan 06 2000 yairh creation
//      Apr 05 2000 dovh - Fixed two problematic debug / tracer buffer size
//          problems.  (Fix Bug 15449).
//      May 07 2000 dovh - USE_WS_SENTINEL algorithm in BreakText
//
////////////////////////////////////////////////////////////////////////////////

#include "base.h"
#include "CustomBreaking.h"
#include "proparray.h"
#include "AutoPtr.h"
#include "excption.h"
#include "SpanishUtils.h"
#include "WbUtils.h"
#ifndef WHISTLER_BUILD
#include "LanguageResources_i.c"
#endif  // WHISTLER_BUILD


CAutoClassPointer<CCustomBreaker> g_apEngCustomBreaker;
CAutoClassPointer<CCustomBreaker> g_apEngUKCustomBreaker;
CAutoClassPointer<CCustomBreaker> g_apFrnCustomBreaker;
CAutoClassPointer<CCustomBreaker> g_apSpnCustomBreaker;
CAutoClassPointer<CCustomBreaker> g_apItlCustomBreaker;


CCustomWordTerm::CCustomWordTerm(const WCHAR* pwcs) :
    m_ulStartTxt(0),
    m_ulEndTxt(0),
    m_pwcs(NULL)
{
    ULONG ulLen = wcslen(pwcs);
    CAutoArrayPointer<WCHAR> ap;
    ap = new WCHAR[ulLen + 1];
    wcscpy(ap.Get(), pwcs);

    while ((m_ulStartTxt < ulLen) && 
           TEST_PROP(GET_PROP(ap.Get()[m_ulStartTxt]), CUSTOM_PUNCT_HEAD))
    {
        m_ulStartTxt++;
    }

    if (m_ulStartTxt == ulLen)
    {
        THROW_HRESULT_EXCEPTION(E_INVALIDARG);
    }

    m_ulEndTxt = ulLen;

    while(m_ulEndTxt &&
          TEST_PROP(GET_PROP(ap.Get()[m_ulEndTxt - 1]), CUSTOM_PUNCT_TAIL))
    {
        m_ulEndTxt--;
    }

    if (m_ulEndTxt <= m_ulStartTxt)
    {
        THROW_HRESULT_EXCEPTION(E_INVALIDARG);    
    }

    m_pwcs = ap.Detach();
    m_ulLen = ulLen;
}

bool CCustomWordTerm::CheckWord(
    const ULONG ulBufLen, 
    ULONG ulOffsetToBaseWord,
    ULONG ulBaseWordLen,
    const WCHAR* pwcsBuf,
    ULONG* pulMatchOffset,
    ULONG* pulMatchLen)
{
    ULONG ulStartTxt = m_ulStartTxt; 
  
    while (ulOffsetToBaseWord && 
           ulStartTxt && 
           m_pwcs[ulStartTxt] == pwcsBuf[ulOffsetToBaseWord])
    {
        ulOffsetToBaseWord--;
        ulStartTxt--;
        ulBaseWordLen++;
    }

    if (ulStartTxt)
    {
        return false;
    }
           
    ULONG ulEndTxt = m_ulEndTxt;

    while ((ulEndTxt < m_ulLen) &&
           (ulOffsetToBaseWord + ulBaseWordLen < ulBufLen) &&
           (m_pwcs[ulEndTxt] == pwcsBuf[ulOffsetToBaseWord + ulBaseWordLen ]))
    {
        ulEndTxt++;
        ulBaseWordLen++;
    }

    if (ulEndTxt != m_ulLen)
    {
        return false;
    }

    *pulMatchOffset = ulOffsetToBaseWord;
    *pulMatchLen = ulBaseWordLen;
    return true;  
}



void CCustomWordCollection::AddWord(const WCHAR* pwcs)
{
    CAutoClassPointer<CCustomWordTerm> ap;

    ap = new CCustomWordTerm(pwcs);
    m_vaWordCollection[m_ulCount] = ap.Get();
    m_ulCount++;
    ap.Detach();
}
    
bool CCustomWordCollection::CheckWord(
    const ULONG ulLen, 
    const ULONG ulOffsetToBaseWord,
    const ULONG ulBaseWordLen,
    const WCHAR* pwcsBuf,
    ULONG* pulMatchOffset,
    ULONG* pulMatchLen)
{
    for (ULONG ul = 0; ul < m_ulCount; ul++)
    {
        bool fRet = m_vaWordCollection[ul]->CheckWord(
                                                 ulLen,
                                                 ulOffsetToBaseWord,
                                                 ulBaseWordLen,
                                                 pwcsBuf, 
                                                 pulMatchOffset,
                                                 pulMatchLen);
        if (fRet)
        {
            return true;
        }
    }
    
    return false;
}

CCustomBreaker::CCustomBreaker(LCID lcid) :
    m_Trie(true),
    m_ulWordCount(0)
{
    CVarString vsPath;

    if (false == GetCustomWBFilePath(lcid, vsPath))
    {
        return;
    }

    CStandardCFile Words((LPWSTR)vsPath, L"r", false);
    if (!((FILE*)Words))
    {
        return;
    }

    WCHAR pwcsBuf[64];
    DictStatus status;

    while(fgetws(pwcsBuf, 64, (FILE*) Words))
    {
        m_ulWordCount++;

        ULONG ulLen = wcslen(pwcsBuf);

        if (ulLen && pwcsBuf[ulLen - 1] == L'\n')
        {
            pwcsBuf[ulLen - 1] = L'\0';
            ulLen--;
        }

        if (0 == ulLen)
        {
            continue;
        }

        try
        {
            CAutoClassPointer<CCustomWordCollection> apCollection = new CCustomWordCollection;
            apCollection->AddWord(pwcsBuf);

            WCHAR* pwcsKey = pwcsBuf + apCollection->GetFirstWord()->GetTxtStart();
            pwcsBuf[apCollection->GetFirstWord()->GetTxtEnd()] = L'\0';
            
            DictStatus status;
            CCustomWordCollection* pExistingCollection;
            
            status = m_Trie.trie_Insert(
                                    pwcsKey,
                                    TRIE_DEFAULT,
                                    apCollection.Get(),
                                    &pExistingCollection);
            if (DICT_ITEM_ALREADY_PRESENT == status)
            {
                pExistingCollection->AddWord(apCollection->GetFirstWord()->GetTxt());
            }
            else if (DICT_SUCCESS == status)
            {
                apCollection.Detach();
                continue;
            }
            
        }
        catch (CHresultException& h)
        {
            if (E_INVALIDARG == (HRESULT)h)
            {
                continue;
            }
            else
            {
                throw h;
            }
        }
    }
}

// 
// The idea behind the algorithm is to store a list of special patterns that should not
// be broken. We also want to be able to recognize those patterns when few punctuations 
// are attached to them. For example if .NET is a special pattern then in the following 
// patterns (.NET) .NET! .NET? we also want to recognize the .NET pattern and emit .NET
// It is more complicated in the next case - NET!. The expected behavior is not to break it.
// So algorithm need to identify when a punctuation is part of the token and not be broken
// and when it is just a breaker. 
// The algorithm is
// 1. Initialization.
//      for each token is the file 
//     	a. Remove punctuations from the beginning and ending of the token - we will 
//         reference it as the base form of the token.
//      b. Insert the base form to a dictionary. Each base form will be pointing to the 
//         generating token. Few tokens can be mapped to the same base form 
//         (NET? and NET!) so each base form will point to a collection of generating tokens 
// 2. Breaking.
//       For each pattern you get from the document
//          a.  perform 1a.
//          b.  look for the resulting base form in the dictionary. 
//          c.  per each item in the collection check whether the generating token exist in the 
//              pattern we got from the document.           
//          

bool CCustomBreaker::BreakText(
    ULONG ulLen,
    WCHAR* pwcsBuf,
    ULONG* pulOutLen,
    ULONG* pulOffset)
{
    DictStatus status;

    CCustomWordCollection* pCollection;
    short sCount = 0;
    
    ULONG ul = 0;
    while ((ul < ulLen) && 
           TEST_PROP(GET_PROP(pwcsBuf[ul]), CUSTOM_PUNCT_HEAD))
    {
        ul++;
    }

    ULONG ulOffsetToBase = ul;

    if (ulOffsetToBase == ulLen)
    {
        return false;
    }

    ULONG ulBaseLen = ulLen;

    while(ulBaseLen &&
          TEST_PROP(GET_PROP(pwcsBuf[ulBaseLen - 1]), CUSTOM_PUNCT_TAIL))
    {
        ulBaseLen--;
    }

    if (ulBaseLen <= ulOffsetToBase)
    {
        return false;    
    }

    ulBaseLen -= ulOffsetToBase;

    status = m_Trie.trie_Find(
                            pwcsBuf + ulOffsetToBase,
                            TRIE_LONGEST_MATCH,
                            1,
                            &pCollection,
                            &sCount);
    if (sCount)
    {
        bool bRet;

        bRet = pCollection->CheckWord(
                        ulLen, 
                        ulOffsetToBase,
                        ulBaseLen,
                        pwcsBuf,
                        pulOffset,
                        pulOutLen);
        return bRet;
    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\frenchtokenizer.cpp ===
#include "base.h"
#include "FrenchTokenizer.h"

void CFrenchTokenizer::OutputHyphenation(
    CTokenState& State,
    const CCliticsTerm* pCliticsTerm)
{
    HRESULT hr;
    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    ULONG ulAddToStart = 0;
    ULONG ulDecFromEnd = 0;

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        ulAddToStart = pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        ulDecFromEnd = pCliticsTerm->ulLen;
    }

    ULONG ulCur = State.m_ulStart + ulAddToStart;
    ULONG ulEnd = State.m_ulEnd - ulDecFromEnd;

    while (ulCur < ulEnd)
    {
        if ( HAS_PROP_DASH(GET_PROP(m_pCurToken->m_State.m_pwcsToken[ulCur])))
        {
            m_pCurToken->m_State.m_pwcsToken[ulCur] = L'-';
        }
        ulCur++;
    }

    ulCur = State.m_ulStart + ulAddToStart;
    CCliticsTerm* pDashTerm = NULL;
    bool fFoundDashClitics = false;

    while (ulCur < ulEnd)
    {
        if (m_pCurToken->m_State.m_pwcsToken[ulCur] == L'-')
        {
            DictStatus status;

            short sResCount = 0;
            if (ulCur > State.m_ulStart)
            {
                status = g_pClitics->m_trieClitics.trie_Find(
                                            State.m_pwcsToken + ulCur,
                                            TRIE_LONGEST_MATCH | TRIE_IGNORECASE,
                                            1,
                                            &pDashTerm,
                                            &sResCount);
                if (sResCount && (pDashTerm->ulLen == (ulEnd - ulCur)))
                {
                    Trace(
                        elVerbose,
                        s_tagTokenizerDecision,
                        ("%*.*S  has a %S clitcs",
                        State.m_ulEnd - State.m_ulStart,
                        State.m_ulEnd - State.m_ulStart,
                        State.m_pwcsToken + State.m_ulStart,
                        pDashTerm->pwcs
                        ));

                    fFoundDashClitics = true;
                    break;
                }
            }

        }
        ulCur++;
    }

    if (fFoundDashClitics)
    {
        Assert(pDashTerm);
        if (pDashTerm->ulOp == HEAD_MATCH_TRUNCATE)
        {
            ulAddToStart += pDashTerm->ulLen;
        }
        else if (pDashTerm->ulOp == TAIL_MATCH_TRUNCATE)
        {
            ulDecFromEnd += pDashTerm->ulLen;
        }
    }

    if (ulDecFromEnd || ulAddToStart)
    {
        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart,
                        State.m_pwcsToken + State.m_ulStart,
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }

    hr = m_apWordSink->PutWord(
                    State.m_ulEnd - State.m_ulStart - ulDecFromEnd - ulAddToStart,
                    State.m_pwcsToken + State.m_ulStart + ulAddToStart,
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\langsupport.cpp ===
#include "base.h"
#include "langsupport.h"

#define LANG_ENG_US 0
#define LANG_ENG_UK 1
#define LANG_FRN    2
#define LANG_SPN    3
#define LANG_ITL    4

#define NUM_OF_LANG 5

LangInfo g_rLangDefaultValues[NUM_OF_LANG] = 
{
    {L',', L'.', L':', false},  // US
    {L',', L'.', L':', true},   // UK
    {(WCHAR)0xA0, L',', L':', true},   // FRN
    {L'.', L',', L':', true},   // SPN
    {L'.', L',', L'.', true},   // ITL
};


CLangSupport::CLangSupport(LCID lcid)
{
    int i;
    WCHAR pwcs[4];

    CSpecialAbbreviationSet* pAbbSet;
    ULONG ulLang;

    switch (PRIMARYLANGID(LANGIDFROMLCID(lcid)))
    {
    case LANG_ENGLISH:
        if (lcid == MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT))
        {
            ulLang = LANG_ENG_US;
        }
        else
        {
            ulLang = LANG_ENG_UK;
        }
        pAbbSet = g_pEngAbbList.Get();
        break;
    case LANG_FRENCH:
        ulLang = LANG_FRN;
        pAbbSet = g_pFrnAbbList.Get();
        break;
    case LANG_SPANISH:
        ulLang = LANG_SPN;
        pAbbSet = g_pSpnAbbList.Get();
        break;
    case LANG_ITALIAN:
        ulLang = LANG_ITL;
        pAbbSet = g_pItlAbbList.Get();
        break;
    default:
        Assert(0);
    }

    *((LangInfo*)this) =  g_rLangDefaultValues[ulLang];
    m_pAbbSet = pAbbSet;

    i = GetLocaleInfo(
		    lcid,
		    LOCALE_SDECIMAL | LOCALE_NOUSEROVERRIDE ,
		    pwcs,
		    4);

    if (i > 0)
    {
        m_wchSDecimal = pwcs[0];
    }

    i = GetLocaleInfo(
		    lcid,
		    LOCALE_STHOUSAND | LOCALE_NOUSEROVERRIDE ,
		    pwcs,
		    4);
    if (i > 0)
    {
        m_wchSThousand = pwcs[0];
    }

    DWORD dwVal;
    i = GetLocaleInfo(
		    lcid,
		    LOCALE_IDATE | LOCALE_NOUSEROVERRIDE | LOCALE_RETURN_NUMBER,
		    (WCHAR*)&dwVal,
		    2);
    if (i > 0)
    {
        if ((dwVal == 1) || (dwVal == 2))
        {
            m_bDayMonthOrder = true;
        }
        else
        {
            m_bDayMonthOrder = false;
        }
    }

    i = GetLocaleInfo(
		    lcid,
		    LOCALE_STIME | LOCALE_NOUSEROVERRIDE ,
		    pwcs,
		    4);
    if (i > 0)
    {
        m_wchSTime = pwcs[0];
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\global.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//  Filename :  Global.cpp
//  Purpose  :  Global Initalization.
//
//  Project  :  WordBreakers
//  Component:  English word breaker
//
//  Author   :  yairh
//
//  Log:
//
//      May 30 2000 yairh creation
//
////////////////////////////////////////////////////////////////////////////////

#include "base.h"
#include "tokenizer.h"
#include "formats.h"
#include "synchro.h"

extern CAutoClassPointer<CPropArray> g_pPropArray;

static bool s_fGlobalInit = false;

static CSyncCriticalSection s_csGlobalInit;

void InitializeGlobalData()
{
    if (s_fGlobalInit)
    {
        return;
    }
    
    CSyncMutexCatcher cs(s_csGlobalInit);
    if (s_fGlobalInit)
    {
        return;    
    }

    CAutoClassPointer<CPropArray> apPropArray = new CPropArray;
    CAutoClassPointer<CClitics> apClitics = new CClitics;
    CAutoClassPointer<CSpecialAbbreviationSet> apEngAbbList = new CSpecialAbbreviationSet(g_aEngAbbList);
    CAutoClassPointer<CSpecialAbbreviationSet> apFrnAbbList = new CSpecialAbbreviationSet(g_aFrenchAbbList);
    CAutoClassPointer<CSpecialAbbreviationSet> apSpnAbbList = new CSpecialAbbreviationSet(g_aSpanishAbbList);
    CAutoClassPointer<CSpecialAbbreviationSet> apItlAbbList = new CSpecialAbbreviationSet(g_aItalianAbbList);
    CAutoClassPointer<CDateFormat> apDateFormat = new CDateFormat;
    CAutoClassPointer<CTimeFormat> apTimeFormat = new CTimeFormat;

    g_pPropArray = apPropArray.Detach(); 
    g_pClitics = apClitics.Detach();

    g_pEngAbbList = apEngAbbList.Detach() ;
    g_pFrnAbbList = apFrnAbbList.Detach();
    g_pSpnAbbList = apSpnAbbList.Detach() ;
    g_pItlAbbList = apItlAbbList.Detach() ;

    g_pDateFormat = apDateFormat.Detach();
    g_pTimeFormat = apTimeFormat.Detach();


    s_fGlobalInit = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\frenchtokenizer.h ===
#ifndef _FRENCH_TOKENIZER_H_
#define _FRENCH_TOKENIZER_H_

#include "tokenizer.h"

class CFrenchTokenizer : public CTokenizer
{
public:
    CFrenchTokenizer(
        TEXT_SOURCE* pTxtSource,
        IWordSink   * pWordSink,
        IPhraseSink * pPhraseSink,
        LCID lcid,
        BOOL bQueryTime,
        ULONG ulMaxTokenSize) :
        CTokenizer(pTxtSource, pWordSink, pPhraseSink, lcid, bQueryTime, ulMaxTokenSize)
    {
    }

    virtual ~CFrenchTokenizer()
    {
    }

protected:

    virtual void OutputHyphenation(
                CTokenState& State, 
                const CCliticsTerm* pCliticsTerm);


};

#endif // _FRENCH_TOKENIZER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\langsupport.h ===
#ifndef _LANG_SUPPORT_H_
#define _LANG_SUPPORT_H_

#include "propflags.h"
#include "formats.h"
#include "tracer.h"

struct LangInfo
{
    WCHAR m_wchSThousand;
    WCHAR m_wchSDecimal;
    WCHAR m_wchSTime;

    bool m_bDayMonthOrder;

    LangInfo& operator= (LangInfo& I)
    {
        m_wchSThousand = I.m_wchSThousand;
        m_wchSDecimal = I.m_wchSDecimal;
        m_wchSTime = I.m_wchSTime;
        m_bDayMonthOrder = I.m_bDayMonthOrder;

        return *this;
    }

};

class CLangSupport : public LangInfo
{
public:

    CLangSupport(LCID lcid);

    WCHAR GetDecimalSeperator()
    {
        return m_wchSDecimal; 
    }

    WCHAR GetThousandSeperator()
    {
        return m_wchSThousand; 
    }

    WCHAR GetTimeSeperator()
    {
        return m_wchSTime; 
    }

    bool IsDayMonthOrder()
    {
        return m_bDayMonthOrder;
    }

    CSpecialAbbreviationSet* GetAbbSet()
    {
        return m_pAbbSet;
    }

private:

    CSpecialAbbreviationSet* m_pAbbSet;

};


#endif // _LANG_SUPPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\propflags.h ===
////////////////////////////////////////////////////////////////////////////////
//
//  Filename :  PropFlags.h
//  Purpose  :  properties definitions
//
//  Project  :  WordBreakers
//  Component:  English word breaker
//
//  Author   :  yairh
//
//  Log:
//
//    Jan 06 2000 yairh creation
//    May 07 2000 dovh - const array generation:
//                split PropArray.h => PropArray.h + PropFlags.h
//    May 11 2000 dovh - Simplify GET_PROP to do double indexing always.
//    Nov 11 2000 dovh - Special underscore treatment
//                       (Only added PROP_ALPHA_NUMERIC flag here)
//
////////////////////////////////////////////////////////////////////////////////

#ifndef _PROP_FLAGS_H_
#define _PROP_FLAGS_H_

#define USE_WS_SENTINEL
// #undef USE_WS_SENTINEL

// #define DECLARE_BYTE_ARRAY
#undef DECLARE_BYTE_ARRAY

// #define DECLARE_ULONGLONG_ARRAY
#undef DECLARE_ULONGLONG_ARRAY

const WCHAR TRACE_CHAR[] = \
    {L'S',  L'E', L'U', L'L', L'N', L'~', L'!',  L'@',  L'#', L'$',  \
     L'%',  L'-', L'&', L'*', L'(', L')', L'-',  L'_',  L'=', L'+',  \
     L'\\', L'|', L'{', L'}', L'[', L']', L'\"', L'\'', L';', L':',  \
     L'?',  L'/', L'<', L'>', L'.', L',', L'w',  L'C',  L'T', L'B',  \
     L's',  L'X', L'S', L'\0'};

//
//  NOTE: DO NOT CHANGE THE ORDER.
//  UPDATE GEN_PROP_STRING_VALUE MACRO BELOW WHENEVER FLAGS DEFINITIONS CHANGE!
//

#define PROP_DEFAULT                ((ULONGLONG)0)

#define PROP_WS                     (((ULONGLONG)1)<< 0)
#define PROP_EOS                    (((ULONGLONG)1)<< 1)
#define PROP_UPPER_CASE             (((ULONGLONG)1)<< 2)
#define PROP_LOWER_CASE             (((ULONGLONG)1)<< 3)
#define PROP_PERIOD                 (((ULONGLONG)1)<< 4)
#define PROP_COMMA                  (((ULONGLONG)1)<< 5)
#define PROP_RESERVED_BREAKER       (((ULONGLONG)1)<< 6)
#define PROP_RESERVED               (((ULONGLONG)1)<< 7)

#define PROP_NUMBER                 (((ULONGLONG)1)<< 8)
#define PROP_TILDE                  (((ULONGLONG)1)<< 9)
#define PROP_EXCLAMATION_MARK       (((ULONGLONG)1)<<10)
#define PROP_AT                     (((ULONGLONG)1)<<11)
#define PROP_POUND                  (((ULONGLONG)1)<<12)
#define PROP_DOLLAR                 (((ULONGLONG)1)<<13)
#define PROP_PERCENTAGE             (((ULONGLONG)1)<<14)
#define PROP_MINUS                  (((ULONGLONG)1)<<15)

#define PROP_AND                    (((ULONGLONG)1)<<16)
#define PROP_ASTERISK               (((ULONGLONG)1)<<17)
#define PROP_LEFT_PAREN             (((ULONGLONG)1)<<18)
#define PROP_RIGHT_PAREN            (((ULONGLONG)1)<<19)
#define PROP_DASH                   (((ULONGLONG)1)<<20)
#define PROP_UNDERSCORE             (((ULONGLONG)1)<<21)
#define PROP_EQUAL                  (((ULONGLONG)1)<<22)
#define PROP_PLUS                   (((ULONGLONG)1)<<23)

#define PROP_BACKSLASH              (((ULONGLONG)1)<<24)
#define PROP_OR                     (((ULONGLONG)1)<<25)
#define PROP_LEFT_CURLY_BRACKET     (((ULONGLONG)1)<<26)
#define PROP_RIGHT_CURLY_BRACKET    (((ULONGLONG)1)<<27)
#define PROP_LEFT_BRAKCET           (((ULONGLONG)1)<<28)
#define PROP_RIGHT_BRAKCET          (((ULONGLONG)1)<<29)
#define PROP_DOUBLE_QUOTE           (((ULONGLONG)1)<<30)
#define PROP_APOSTROPHE             (((ULONGLONG)1)<<31)

#define PROP_SEMI_COLON             (((ULONGLONG)1)<<32)
#define PROP_COLON                  (((ULONGLONG)1)<<33)
#define PROP_QUESTION_MARK          (((ULONGLONG)1)<<34)
#define PROP_SLASH                  (((ULONGLONG)1)<<35)
#define PROP_LT                     (((ULONGLONG)1)<<36)
#define PROP_GT                     (((ULONGLONG)1)<<37)
#define PROP_W                      (((ULONGLONG)1)<<38)
#define PROP_CURRENCY               (((ULONGLONG)1)<<39)
#define PROP_BREAKER                (((ULONGLONG)1)<<40)
#define PROP_TRANSPERENT            (((ULONGLONG)1)<<41)
#define PROP_NBS                    (((ULONGLONG)1)<<42)
#define PROP_ALPHA_XDIGIT           (((ULONGLONG)1)<<43)
#define PROP_COMMERSIAL_SIGN        (((ULONGLONG)1)<<44)

#define WB_PROP_COUNT               45


//
//  The following is the contents of the GEN_PROP_STRING array
//  used by the array generator.
//
//  NOTE: DO NOT CHANGE THE ORDER.
//  UPDATE MACRO WHENEVER FLAGS DEFINITIONS CHANGE TO REFLECT CHANGES!
//
//  extern const WCHAR* GEN_PROP_STRING[ WB_PROP_COUNT ];
//

#define GEN_PROP_STRING_VALUE       \
{                                   \
                                    \
    L"PROP_WS",                     \
    L"PROP_EOS",                    \
    L"PROP_UPPER_CASE",             \
    L"PROP_LOWER_CASE",             \
    L"PROP_PERIOD",                 \
    L"PROP_COMMA",                  \
    L"PROP_RESERVED_BREAKER",       \
    L"PROP_RESERVED",               \
                                    \
    L"PROP_NUMBER",                 \
    L"PROP_TILDE",                  \
    L"PROP_EXCLAMATION_MARK",       \
    L"PROP_AT",                     \
    L"PROP_POUND",                  \
    L"PROP_DOLLAR",                 \
    L"PROP_PERCENTAGE",             \
    L"PROP_MINUS",                  \
                                    \
    L"PROP_AND",                    \
    L"PROP_ASTERISK",               \
    L"PROP_LEFT_PAREN",             \
    L"PROP_RIGHT_PAREN",            \
    L"PROP_DASH",                   \
    L"PROP_UNDERSCORE",             \
    L"PROP_EQUAL",                  \
    L"PROP_PLUS",                   \
                                    \
    L"PROP_BACKSLASH",              \
    L"PROP_OR",                     \
    L"PROP_LEFT_CURLY_BRACKET",     \
    L"PROP_RIGHT_CURLY_BRACKET",    \
    L"PROP_LEFT_BRAKCET",           \
    L"PROP_RIGHT_BRAKCET",          \
    L"PROP_DOUBLE_QUOTE",           \
    L"PROP_APOSTROPHE",             \
                                    \
    L"PROP_SEMI_COLON",             \
    L"PROP_COLON",                  \
    L"PROP_QUESTION_MARK",          \
    L"PROP_SLASH",                  \
    L"PROP_LT",                     \
    L"PROP_GT",                     \
    L"PROP_W",                      \
    L"PROP_CURRENCY",               \
    L"PROP_BREAKER"                 \
    L"PROP_TRANSPERENT"             \
    L"PROP_NBS"                     \
    L"PROP_ALPHA_XDIGIT"            \
    L"PROP_COMMERSIAL_SIGN"         \
}

#define PROP_ALPHA  (PROP_LOWER_CASE | PROP_UPPER_CASE)
#define PROP_ALPHA_NUMERIC (PROP_LOWER_CASE | PROP_UPPER_CASE | PROP_NUMBER)
#define PROP_DATE_SEPERATOR (PROP_DASH | PROP_SLASH | PROP_PERIOD)
#define PROP_XDIGIT (PROP_NUMBER | PROP_ALPHA_XDIGIT)

#define PROP_FIRST_LEVEL_BREAKER \
     (PROP_BREAKER | PROP_EXCLAMATION_MARK | PROP_ASTERISK | \
     PROP_LEFT_PAREN | PROP_RIGHT_PAREN | PROP_BACKSLASH | PROP_EQUAL | PROP_OR | \
     PROP_LEFT_CURLY_BRACKET | PROP_RIGHT_CURLY_BRACKET | PROP_LEFT_BRAKCET | PROP_RIGHT_BRAKCET | \
     PROP_DOUBLE_QUOTE | PROP_SEMI_COLON | PROP_QUESTION_MARK | PROP_SLASH | \
     PROP_COMMA | PROP_GT | PROP_LT | PROP_WS )
 
#define PROP_SECOND_LEVEL_BREAKER \
    (PROP_TILDE | PROP_AT | PROP_DOLLAR | PROP_PERCENTAGE | PROP_AND |\
     PROP_DASH | PROP_PLUS | PROP_COLON | PROP_PERIOD | PROP_POUND)

#define PROP_DEFAULT_BREAKER (PROP_FIRST_LEVEL_BREAKER | PROP_SECOND_LEVEL_BREAKER) 

//
// Hyphenation
//

#define HYPHENATION_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COMMA | PROP_COLON | PROP_LEFT_PAREN | PROP_NBS)
#define HYPHENATION_PUNCT_TAIL \
    (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | \
     PROP_RIGHT_PAREN | PROP_PERIOD | PROP_NBS)

//
// Abbreviation, acronym
//

#define ACRONYM_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COMMA | PROP_COLON | PROP_LEFT_PAREN | PROP_NBS)

#define ACRONYM_PUNCT_TAIL \
    (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | \
     PROP_RIGHT_PAREN | PROP_NBS)

#define ABBREVIATION_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COMMA | PROP_COLON | PROP_LEFT_PAREN | \
                                 PROP_NBS | PROP_APOSTROPHE)

#define ABBREVIATION_PUNCT_TAIL \
    (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | \
     PROP_RIGHT_PAREN | PROP_NBS | PROP_APOSTROPHE)

#define ABBREVIATION_EOS \
    (PROP_SEMI_COLON | PROP_COLON | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | PROP_NBS)

#define SPECIAL_ABBREVIATION_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COMMA | PROP_COLON | PROP_LEFT_PAREN | PROP_NBS)

#define SPECIAL_ABBREVIATION_PUNCT_TAIL \
    (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | \
     PROP_RIGHT_PAREN | PROP_PERIOD | PROP_NBS)

//
// Parenthesis
//
#define PAREN_PUNCT_TAIL (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_PERIOD | \
                          PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | PROP_NBS | PROP_APOSTROPHE)

#define PAREN_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | \
                          PROP_QUESTION_MARK | PROP_NBS | PROP_APOSTROPHE)

//
// Clitics
//

#define CLITICS_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COMMA | PROP_COLON | PROP_LEFT_PAREN | PROP_NBS)
#define CLITICS_PUNC_TAIL \
    (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | \
     PROP_RIGHT_PAREN | PROP_PERIOD | PROP_NBS)

//
// Numbers date time
//

#define NUM_DATE_TIME_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COMMA | PROP_COLON | PROP_LEFT_PAREN | \
                                  PROP_LEFT_BRAKCET | PROP_LEFT_CURLY_BRACKET | PROP_NBS)
#define NUM_DATE_TIME_PUNCT_TAIL \
    (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | \
     PROP_RIGHT_PAREN | PROP_PERIOD | PROP_RIGHT_BRAKCET | PROP_RIGHT_CURLY_BRACKET | PROP_NBS | \
     PROP_PERCENTAGE)

#define TIME_ADDITIONAL_PUNCT_HEAD (PROP_APOSTROPHE)

#define TIME_ADDITIONAL_PUNCT_TAIL (PROP_APOSTROPHE)

#define DATE_ADDITIONAL_PUNCT_HEAD (PROP_APOSTROPHE)

#define DATE_ADDITIONAL_PUNCT_TAIL (PROP_APOSTROPHE)


//
// Currency
//
#define CURRENCY_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COMMA | PROP_COLON | PROP_LEFT_PAREN | \
                             PROP_LEFT_BRAKCET | PROP_LEFT_CURLY_BRACKET | PROP_APOSTROPHE | \
                             PROP_NBS)

#define CURRENCY_PUNCT_TAIL \
    (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | \
     PROP_RIGHT_PAREN | PROP_PERIOD | PROP_RIGHT_BRAKCET | PROP_RIGHT_CURLY_BRACKET | \
     PROP_APOSTROPHE | PROP_NBS)

//
// Misc
//
#define MISC_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COMMA | PROP_COLON | PROP_LEFT_PAREN | PROP_NBS)

#define MISC_PUNCT_TAIL \
    (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | \
     PROP_RIGHT_PAREN | PROP_PERIOD | PROP_NBS)

//
// Commersial sign
// 
#define COMMERSIAL_SIGN_PUNCT_HEAD (PROP_SEMI_COLON | PROP_COMMA | PROP_COLON | PROP_LEFT_PAREN | PROP_NBS)

#define COMMERSIAL_SIGN_PUNCT_TAIL \
    (PROP_SEMI_COLON | PROP_COLON | PROP_COMMA | PROP_EXCLAMATION_MARK | PROP_QUESTION_MARK | \
     PROP_RIGHT_PAREN | PROP_PERIOD | PROP_NBS)

//
// EOS
//
#define EOS_SUFFIX \
        (PROP_WS | PROP_RIGHT_BRAKCET | PROP_RIGHT_PAREN | PROP_RIGHT_CURLY_BRACKET | \
         PROP_APOSTROPHE | PROP_NBS)


//
// default
//

#define SIMPLE_PUNCT_HEAD (PROP_NBS | PROP_UNDERSCORE | PROP_DEFAULT_BREAKER | PROP_APOSTROPHE)
#define SIMPLE_PUNCT_TAIL (PROP_NBS | PROP_UNDERSCORE | PROP_DEFAULT_BREAKER | PROP_APOSTROPHE)

#define MAX_NUM_PROP 64

//
//  PROP_FLAGS MACROS:
//

#ifndef DECLARE_ULONGLONG_ARRAY

#define GET_PROP(wch)                                               \
    ( g_pPropArray->m_apCodePage[wch >> 8][(UCHAR)wch] )

#ifdef DECLARE_BYTE_ARRAY
extern const BYTE g_BytePropFlagArray[  ];

#define IS_WS(wch) (g_BytePropFlagArray[wch] & PROP_WS)
#define IS_EOS(wch) (g_BytePropFlagArray[wch] & PROP_EOS)
#define IS_BREAKER(wch) (g_BytePropFlagArray[wch] & PROP_RESERVED_BREAKER)
#else
#define IS_WS(wch) (GET_PROP(wch).m_ulFlag & PROP_WS)
#define IS_EOS(wch) (GET_PROP(wch).m_ulFlag & PROP_EOS)
#define IS_BREAKER(wch) (GET_PROP(wch).m_ulFlag & PROP_DEFAULT_BREAKER)
#endif // DECLARE_BYTE_ARRAY

#else

class CPropFlag;
extern const ULONGLONG g_UllPropFlagArray[ ];

#define GET_PROP(wch) (g_PropFlagArray[wch])
#define IS_WS(wch) (g_UllPropFlagArray[wch] & PROP_WS)
#define IS_EOS(wch) (g_UllPropFlagArray[wch] & PROP_EOS)
#define IS_BREAKER(wch) (g_UllPropFlagArray[wch] & PROP_DEFAULT_BREAKER)

#endif // DECLARE_ULONGLONG_ARRAY

#define HAS_PROP_ALPHA(prop)        (prop.m_ulFlag & PROP_ALPHA)
#define HAS_PROP_EXTENDED_ALPHA(prop) (prop.m_ulFlag & (PROP_ALPHA | PROP_TRANSPERENT))
#define HAS_PROP_UPPER_CASE(prop)   (prop.m_ulFlag & PROP_UPPER_CASE)
#define HAS_PROP_LOWER_CASE(prop)   (prop.m_ulFlag & PROP_LOWER_CASE)
#define HAS_PROP_NUMBER(prop)       (prop.m_ulFlag & PROP_NUMBER)
#define HAS_PROP_CURRENCY(prop)     (prop.m_ulFlag & PROP_CURRENCY)
#define HAS_PROP_LEFT_PAREN(prop)   (prop.m_ulFlag & PROP_LEFT_PAREN)
#define HAS_PROP_RIGHT_PAREN(prop)  (prop.m_ulFlag & PROP_RIGHT_PAREN)
#define HAS_PROP_APOSTROPHE(prop)   (prop.m_ulFlag & PROP_APOSTROPHE)
#define HAS_PROP_BACKSLASH(prop)    (prop.m_ulFlag & PROP_BACKSLASH)
#define HAS_PROP_SLASH(prop)        (prop.m_ulFlag & PROP_SLASH)
#define HAS_PROP_PERIOD(prop)       (prop.m_ulFlag & PROP_PERIOD)
#define HAS_PROP_COMMA(prop)        (prop.m_ulFlag & PROP_COMMA)
#define HAS_PROP_COLON(prop)        (prop.m_ulFlag & PROP_COLON)
#define HAS_PROP_DASH(prop)         (prop.m_ulFlag & PROP_DASH)
#define HAS_PROP_W(prop)            (prop.m_ulFlag & PROP_W)
#define IS_PROP_SIMPLE(prop)        \
    (!prop.m_ulFlag ||              \
     ((prop.m_ulFlag & (PROP_ALPHA | PROP_TRANSPERENT | PROP_W | PROP_ALPHA_XDIGIT)) &&  \
      !(prop.m_ulFlag & ~(PROP_ALPHA | PROP_TRANSPERENT | PROP_W | PROP_ALPHA_XDIGIT)))) 

#define TEST_PROP(prop, i)          (prop.m_ulFlag & (i))
#define TEST_PROP1(prop1, prop2)    (prop1.m_ulFlag & prop2.m_ulFlag)

#endif // _PROP_FLAGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\proparray.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  PropArray.h
//      Purpose  :  properties definitions
//
//      Project  :  WordBreakers
//      Component:  English word breaker
//
//      Author   :  yairh
//
//      Log:
//
//      Jan 06 2000 yairh creation
//      May 07 2000 dovh - const array generation:
//                  split PropArray.h => PropArray.h + PropFlags.h
//      May 11 2000 dovh - Simplify GET_PROP to do double indexing always.
//
////////////////////////////////////////////////////////////////////////////////

#ifndef _PROP_ARRAY_H_
#define _PROP_ARRAY_H_

#include "PropFlags.h"

///////////////////////////////////////////////////////////////////////////////
// Class CPropFlag
///////////////////////////////////////////////////////////////////////////////

class CPropFlag
{
public:

    //
    // methods
    //

    CPropFlag();
    CPropFlag(ULONGLONG ul);

    void Clear();
    void Set(ULONGLONG ul);
    CPropFlag& operator= (const CPropFlag& f);
    CPropFlag& operator|= (const CPropFlag& f);

public:

    //
    // members
    //

    ULONGLONG m_ulFlag;
};

inline CPropFlag::CPropFlag(): m_ulFlag(0)
{
}

inline CPropFlag::CPropFlag(ULONGLONG ul): m_ulFlag(ul)
{
}

inline void CPropFlag::Clear()
{
    m_ulFlag = 0;
}

inline void CPropFlag::Set(ULONGLONG ul)
{
    m_ulFlag |= ul;

#ifdef DECLARE_BYTE_ARRAY
    if (ul & PROP_DEFAULT_BREAKER)
    {
        m_ulFlag |= PROP_RESERVED_BREAKER;
    }
#endif // DECLARE_BYTE_ARRAY

}

inline CPropFlag& CPropFlag::operator= (const CPropFlag& f)
{
    m_ulFlag = f.m_ulFlag;
    return *this;
}

inline CPropFlag& CPropFlag::operator|= (const CPropFlag& f)
{
    m_ulFlag |= f.m_ulFlag;
    return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Class CTokenState
///////////////////////////////////////////////////////////////////////////////

class CPropArray
{
public:

    //
    // methods
    //

    CPropArray();
    ~CPropArray();

    CPropFlag& GetPropForUpdate(WCHAR wch);

public:

    //
    // members
    //

    CPropFlag* m_apCodePage[1<<8];

    CPropFlag m_aDefaultCodePage[1<<8];
};

inline CPropArray::CPropArray()
{
    for (WCHAR wch = 0; wch < (1<<8); wch++)
    {
        m_apCodePage[wch] = NULL;
    }

    //
    // White space characters
    //

    for(wch=0x0; wch <= 0x1F; wch++)   // control 0x0 - 0x1F
    {
        GetPropForUpdate(wch).Set(PROP_WS);
    }

    for(wch=0x80; wch <= 0x9F; wch++)   // control 0x80 - 0x9F
    {
        GetPropForUpdate(wch).Set(PROP_WS);
    }

    GetPropForUpdate(0x7F).Set(PROP_WS);  // control

    GetPropForUpdate(0x0020).Set(PROP_WS);   // space
    GetPropForUpdate(0x0022).Set(PROP_WS);  // quotation mark
    GetPropForUpdate(0x00AB).Set(PROP_WS);  // left angle double pointing quotation mark 
    GetPropForUpdate(0x00BB).Set(PROP_WS);  // right angle double pointing quotation mark
    GetPropForUpdate(0x201A).Set(PROP_WS);  // Single low-9 quotation mark
    GetPropForUpdate(0x201B).Set(PROP_WS);  // Single low-9 quotation mark
    GetPropForUpdate(0x201C).Set(PROP_WS);  // Left double quotation mark
    GetPropForUpdate(0x201D).Set(PROP_WS);  // Right double quotation mark
    GetPropForUpdate(0x201E).Set(PROP_WS);  // Double low-9 quotation mark
    GetPropForUpdate(0x201F).Set(PROP_WS);  // Double high-reversed-9 quotation mark

    GetPropForUpdate(0x2039).Set(PROP_WS);  // single left pointing quotation mark
    GetPropForUpdate(0x203A).Set(PROP_WS);  // single right pointing quotation mark

    GetPropForUpdate(0x301D).Set(PROP_WS);  // Reverse double prime quotation mark
    GetPropForUpdate(0x301E).Set(PROP_WS);  // Double prime quotation mark
    GetPropForUpdate(0x301F).Set(PROP_WS);  // Low double prime quotation mark

    for(wch=0x2000; wch <= 0x200B; wch++)   // space 0x2000 - 0x200B
    {
        GetPropForUpdate(wch).Set(PROP_WS);
    }
 
    GetPropForUpdate(0x3000).Set(PROP_WS);  // space
    GetPropForUpdate(0xFF02).Set(PROP_WS);  // Full width quotation mark

    // Geometrical shapes, arrows and other characters that can be ignored

    for(wch=0x2190; wch <= 0x21F3; wch++)   // Arrows
    {
        GetPropForUpdate(wch).Set(PROP_WS);
    }
    
    for(wch=0x2500; wch <= 0x257F; wch++)   // Box Drawing
    {
        GetPropForUpdate(wch).Set(PROP_WS);
    }
    
    for(wch=0x2580; wch <= 0x2595; wch++)   // Block Elements
    {
        GetPropForUpdate(wch).Set(PROP_WS);
    }

    for(wch=0x25A0; wch <= 0x25F7; wch++)   // Geometric Shapes
    {
        GetPropForUpdate(wch).Set(PROP_WS);
    }

    //
    // Exclmation mark
    //

    GetPropForUpdate(0x0021).Set(PROP_EXCLAMATION_MARK);
    GetPropForUpdate(0x00A1).Set(PROP_EXCLAMATION_MARK);
    GetPropForUpdate(0x01C3).Set(PROP_EXCLAMATION_MARK);
    GetPropForUpdate(0x203C).Set(PROP_EXCLAMATION_MARK);
    GetPropForUpdate(0x203D).Set(PROP_EXCLAMATION_MARK);
    GetPropForUpdate(0x2762).Set(PROP_EXCLAMATION_MARK);
    GetPropForUpdate(0xFF01).Set(PROP_EXCLAMATION_MARK);  // Full width

    //
    // Number sign
    //

    GetPropForUpdate(0x0023).Set(PROP_POUND);   // #
    GetPropForUpdate(0xFF03).Set(PROP_POUND);   // Full width

    //
    // Dollar sign
    //

    GetPropForUpdate(0x0024).Set(PROP_DOLLAR);  // $
    GetPropForUpdate(0xFF04).Set(PROP_DOLLAR);  // Full width

    //
    // Percentage sign
    //

    GetPropForUpdate(0x0025).Set(PROP_PERCENTAGE);
    GetPropForUpdate(0x2030).Set(PROP_PERCENTAGE);
    GetPropForUpdate(0x2031).Set(PROP_PERCENTAGE);
    GetPropForUpdate(0xFF05).Set(PROP_PERCENTAGE); // Full width

    //
    // Ampersand
    //

    GetPropForUpdate(0x0026).Set(PROP_AND);   // &

    //
    // Apostrophe
    //

    GetPropForUpdate(0x0027).Set(PROP_APOSTROPHE);
    GetPropForUpdate(0x2018).Set(PROP_APOSTROPHE);
    GetPropForUpdate(0x2019).Set(PROP_APOSTROPHE);
    GetPropForUpdate(0x2032).Set(PROP_APOSTROPHE);
    GetPropForUpdate(0xFF07).Set(PROP_APOSTROPHE);  // Full width

    //
    // Parenthesis
    //

    GetPropForUpdate(0x0028).Set(PROP_LEFT_PAREN);    // (
    GetPropForUpdate(0xFF08).Set(PROP_LEFT_PAREN);    // Full width
    GetPropForUpdate(0x0029).Set(PROP_RIGHT_PAREN);   // )
    GetPropForUpdate(0xFF09).Set(PROP_RIGHT_PAREN);   // Full width

    //
    // Asterisk
    //

    GetPropForUpdate(0x002A).Set(PROP_ASTERISK);   // *
    GetPropForUpdate(0x2217).Set(PROP_ASTERISK);
    GetPropForUpdate(0x2731).Set(PROP_ASTERISK);
    GetPropForUpdate(0xFF0A).Set(PROP_ASTERISK);   // Full width

    //
    // Plus sign
    //

    GetPropForUpdate(0x002B).Set(PROP_PLUS);  // +
    GetPropForUpdate(0xFF0B).Set(PROP_PLUS);  // Full width

    //
    // Comma
    //
    
    GetPropForUpdate(0x002C).Set(PROP_COMMA);
    GetPropForUpdate(0x3001).Set(PROP_COMMA);
    GetPropForUpdate(0xFF0C).Set(PROP_COMMA); // Full width
    GetPropForUpdate(0xFF64).Set(PROP_COMMA); // Half width

    //
    // HYPEHN
    //

    GetPropForUpdate(0x002D).Set(PROP_DASH);   // - 
    GetPropForUpdate(0x00AD).Set(PROP_DASH);   // soft hyphen
    GetPropForUpdate(0x2010).Set(PROP_DASH);
    GetPropForUpdate(0x2011).Set(PROP_DASH);
    GetPropForUpdate(0x2012).Set(PROP_DASH);
    GetPropForUpdate(0x2013).Set(PROP_DASH);
    GetPropForUpdate(0xFF0D).Set(PROP_DASH);   // Full width 
 
    //
    // MINUS
    //

    GetPropForUpdate(0x002D).Set(PROP_MINUS);
    GetPropForUpdate(0x2212).Set(PROP_MINUS);
    GetPropForUpdate(0xFF0D).Set(PROP_MINUS);    // Full width 

    //
    // Full stop period
    //

    GetPropForUpdate(0x002E).Set(PROP_PERIOD);   // .
    GetPropForUpdate(0x3002).Set(PROP_PERIOD);  
    GetPropForUpdate(0xFF0E).Set(PROP_PERIOD);   // Full width  

    //
    // SLASH
    //

    GetPropForUpdate(0x002F).Set(PROP_SLASH);   // /
    GetPropForUpdate(0xFF0F).Set(PROP_SLASH);   // Full width
 
    //
    // NUMBERS
    //

    for (wch = 0x0030; wch <= 0x0039 ; wch++)   // 0 - 9
    {
        GetPropForUpdate(wch).Set(PROP_NUMBER);
    }

    for (wch = 0xFF10; wch <= 0xFF19 ; wch++)   // 0 - 9 Full width
    {
        GetPropForUpdate(wch).Set(PROP_NUMBER);
    }

    //
    // HEX NUMBERS
    //

    for (wch = 0x0041; wch <= 0x0046 ; wch++)   // A - F
    {
        GetPropForUpdate(wch).Set(PROP_ALPHA_XDIGIT);
    }

    for (wch = 0x0061; wch <= 0x0066 ; wch++)   // a - f
    {
        GetPropForUpdate(wch).Set(PROP_ALPHA_XDIGIT);
    }

    for (wch = 0xFF21; wch <= 0xFF26 ; wch++)   // A - F Full width
    {
        GetPropForUpdate(wch).Set(PROP_ALPHA_XDIGIT);
    }

    for (wch = 0xFF41; wch <= 0xFF46 ; wch++)   // a - f Full width
    {
        GetPropForUpdate(wch).Set(PROP_ALPHA_XDIGIT);
    }

    //
    // Colon
    //

    GetPropForUpdate(0x003A).Set(PROP_COLON);  // :
    GetPropForUpdate(0x2236).Set(PROP_COLON);
    GetPropForUpdate(0xFF1A).Set(PROP_COLON);  // Full width :

    //
    // Semicolon
    //

    GetPropForUpdate(0x003B).Set(PROP_SEMI_COLON); // ;
    GetPropForUpdate(0xFF1B).Set(PROP_SEMI_COLON); // Full width ;

    //
    // Less then
    //

    GetPropForUpdate(0x003C).Set(PROP_LT);   // <
    GetPropForUpdate(0xFF1C).Set(PROP_LT);   // Full width <

    //
    // Equal sign 
    //

    GetPropForUpdate(0x003D).Set(PROP_EQUAL);   // =
    GetPropForUpdate(0x2260).Set(PROP_EQUAL);   // not equal sign
    GetPropForUpdate(0x2261).Set(PROP_EQUAL);   // identical to
    GetPropForUpdate(0xFF1D).Set(PROP_EQUAL);   // Full width =

    //
    // Greater then
    //

    GetPropForUpdate(0x003E).Set(PROP_GT);  // >
    GetPropForUpdate(0xFF1E).Set(PROP_GT);  // Full width >

    //
    // Question mark
    //

    GetPropForUpdate(0x003F).Set(PROP_QUESTION_MARK);  // ?
    GetPropForUpdate(0x00BF).Set(PROP_QUESTION_MARK);  // inverted question mark
    GetPropForUpdate(0x037E).Set(PROP_QUESTION_MARK);  // greek question mark
    GetPropForUpdate(0x203D).Set(PROP_QUESTION_MARK);  // interrobang
    GetPropForUpdate(0x2048).Set(PROP_QUESTION_MARK);  // question exclemation mark
    GetPropForUpdate(0x2049).Set(PROP_QUESTION_MARK);  // exclamation question mark
    GetPropForUpdate(0xFF1F).Set(PROP_QUESTION_MARK);  // Full width ?

    //
    // Commercial AT
    //

    GetPropForUpdate(0x0040).Set(PROP_AT);  // @
    GetPropForUpdate(0xFF20).Set(PROP_AT);  // Full width @

    //
    // Commersial signs
    //
    GetPropForUpdate(0x00A9).Set(PROP_COMMERSIAL_SIGN); // copy right sign
    GetPropForUpdate(0x00AE).Set(PROP_COMMERSIAL_SIGN); // registered sign
    GetPropForUpdate(0x2120).Set(PROP_COMMERSIAL_SIGN); // service mark
    GetPropForUpdate(0x2121).Set(PROP_COMMERSIAL_SIGN); // telephone sign 
    GetPropForUpdate(0x2122).Set(PROP_COMMERSIAL_SIGN); // trade mark sign

    //
    // Letters
    //

    // upper case

    for (wch = 0x0041; wch <= 0x005A; wch++)    // A - Z
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }

    for (wch = 0x00C0; wch <= 0x00D6; wch++)
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }

    for (wch = 0x00D8; wch <= 0x00DE; wch++)
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }

    for (wch = 0xFF21; wch <= 0xFF3A; wch++)    // Full width A - Z
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }

    // Latin extended

    for (wch = 0x0100; wch <= 0x017D; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }

    GetPropForUpdate(0x0181).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0182).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0184).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0186).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0187).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0189).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x018A).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x018B).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x018E).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x018F).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0190).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0191).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0193).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0194).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0196).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0197).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x0198).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x019C).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x019D).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x019F).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01A0).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01A2).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01A4).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01A6).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01A7).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01A9).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01AA).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01AC).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01AE).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01AF).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01B1).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01B2).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01B3).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01B5).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01B7).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01B8).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01BC).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01C4).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01C5).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01C7).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01C8).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01CA).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01CB).Set(PROP_UPPER_CASE);

    for (wch = 0x01CD; wch <= 0x01DB; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }
    
    for (wch = 0x01DE; wch <= 0x01EE; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }

    GetPropForUpdate(0x01F1).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01F2).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01F4).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01F6).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01F7).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01F8).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01FA).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01FC).Set(PROP_UPPER_CASE);
    GetPropForUpdate(0x01FE).Set(PROP_UPPER_CASE);

    for (wch = 0x0200; wch <= 0x0232; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }

    // Latin extended additional

    for (wch = 0x1E00; wch <= 0x1E94; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }

    for (wch = 0x1EA0; wch <= 0x1EF8; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_UPPER_CASE);
    }

    // lower case

    for (wch = 0x0061; wch <= 0x007A; wch++)  // a - z
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    for (wch = 0x00DF; wch <= 0x00F6; wch++)
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    for (wch = 0x00F8; wch <= 0x00FF; wch++)
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    for (wch = 0xFF41; wch <= 0xFF5A; wch++)  // Full width a - z
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }
    // Latin extended
     
    for (wch = 0x0101; wch <= 0x017E; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    GetPropForUpdate(0x017F).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x0180).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x0183).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x0185).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x0188).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x018C).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x018D).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x0192).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x0195).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x0199).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x019A).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x019B).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x019E).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01A1).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01A3).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01A5).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01A8).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01AB).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01AD).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01B0).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01B4).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01B6).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01B9).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01BA).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01BB).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01BD).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01BE).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01BF).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01C6).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01C9).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01CC).Set(PROP_LOWER_CASE);

    for (wch = 0x01CE; wch <= 0x01DC; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    for (wch = 0x01DD; wch <= 0x01EF; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    GetPropForUpdate(0x01F0).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01F3).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01F5).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01F9).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01FB).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01FD).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01FF).Set(PROP_LOWER_CASE);
    GetPropForUpdate(0x01).Set(PROP_LOWER_CASE);

    for (wch = 0x0201; wch <= 0x0233; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    for (wch = 0x0250; wch <= 0x02AD; wch++)
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    // Latin extended additional

    for (wch = 0x1E01; wch <= 0x1E95; wch+=2)         
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    for (wch = 0x1E96; wch <= 0x1E9B; wch++)
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    for (wch = 0x1EA1; wch <= 0x1EF9; wch+=2)
    {
        GetPropForUpdate(wch).Set(PROP_LOWER_CASE);
    }

    // special letters

    GetPropForUpdate(L'w').Set(PROP_W);
    GetPropForUpdate(L'W').Set(PROP_W);

    //
    // Bracket
    //
    
    GetPropForUpdate(0x005B).Set(PROP_LEFT_BRAKCET); // [
    GetPropForUpdate(0xFF3B).Set(PROP_LEFT_BRAKCET); // Full width [
    GetPropForUpdate(0x2329).Set(PROP_LEFT_BRAKCET); // left pointing angle bracket
    GetPropForUpdate(0x3008).Set(PROP_LEFT_BRAKCET); // left angle bracket
 
    GetPropForUpdate(0x005D).Set(PROP_RIGHT_BRAKCET); // ]
    GetPropForUpdate(0xFF3D).Set(PROP_RIGHT_BRAKCET); // Full width ]
    GetPropForUpdate(0x232A).Set(PROP_RIGHT_BRAKCET); // right pointing angle bracket
    GetPropForUpdate(0x3009).Set(PROP_RIGHT_BRAKCET); // right angle bracket
    GetPropForUpdate(0x300A).Set(PROP_LEFT_BRAKCET);
    GetPropForUpdate(0x300B).Set(PROP_RIGHT_BRAKCET);
    GetPropForUpdate(0x300C).Set(PROP_LEFT_BRAKCET);
    GetPropForUpdate(0xFF62).Set(PROP_LEFT_BRAKCET);
    GetPropForUpdate(0x300D).Set(PROP_RIGHT_BRAKCET);
    GetPropForUpdate(0xFF63).Set(PROP_RIGHT_BRAKCET);
    GetPropForUpdate(0x300E).Set(PROP_LEFT_BRAKCET);
    GetPropForUpdate(0x300F).Set(PROP_RIGHT_BRAKCET);
    GetPropForUpdate(0x3010).Set(PROP_LEFT_BRAKCET);
    GetPropForUpdate(0x3011).Set(PROP_RIGHT_BRAKCET);
    GetPropForUpdate(0x3014).Set(PROP_LEFT_BRAKCET);
    GetPropForUpdate(0x3015).Set(PROP_RIGHT_BRAKCET);
    GetPropForUpdate(0x3016).Set(PROP_LEFT_BRAKCET);
    GetPropForUpdate(0x3017).Set(PROP_RIGHT_BRAKCET);
    GetPropForUpdate(0x3018).Set(PROP_LEFT_BRAKCET);
    GetPropForUpdate(0x3019).Set(PROP_RIGHT_BRAKCET);
    GetPropForUpdate(0x301A).Set(PROP_LEFT_BRAKCET);
    GetPropForUpdate(0x301B).Set(PROP_RIGHT_BRAKCET);


    GetPropForUpdate(0x007B).Set(PROP_LEFT_CURLY_BRACKET);  // {
    GetPropForUpdate(0xFF5B).Set(PROP_LEFT_CURLY_BRACKET);  // Full width {
    GetPropForUpdate(0x007D).Set(PROP_RIGHT_CURLY_BRACKET); // }
    GetPropForUpdate(0xFF5D).Set(PROP_RIGHT_CURLY_BRACKET); // Full width }

    //
    // Backslash
    //

    GetPropForUpdate(0x005C).Set(PROP_BACKSLASH);   // \ 
    GetPropForUpdate(0xFF3C).Set(PROP_BACKSLASH);   // Full width \ 

    //
    // Underscore
    //

    GetPropForUpdate(0x005F).Set(PROP_UNDERSCORE);  // _
    GetPropForUpdate(0xFF3F).Set(PROP_UNDERSCORE);  // Full width _

    //
    // Or
    //

    GetPropForUpdate(0x007C).Set(PROP_OR);  // |
    GetPropForUpdate(0xFF5C).Set(PROP_OR);  // Full width |

    //
    // Tilde
    //

    GetPropForUpdate(0x007E).Set(PROP_TILDE);   // ~
    GetPropForUpdate(0xFF5E).Set(PROP_TILDE);   // Full width ~
    GetPropForUpdate(0x223C).Set(PROP_TILDE);
    GetPropForUpdate(0xFF5E).Set(PROP_TILDE);

    //
    // NBS
    //

    GetPropForUpdate(0x00A0).Set(PROP_NBS);   // NBS
    GetPropForUpdate(0x202F).Set(PROP_NBS);   // narrow no break space
    GetPropForUpdate(0xFEFF).Set(PROP_NBS);   // zero width no break space

    //
    // End of sentence
    //

    GetPropForUpdate(0x002E).Set(PROP_EOS);   // .
    GetPropForUpdate(0xFF0E).Set(PROP_EOS);   // Full width .
    GetPropForUpdate(0x3002).Set(PROP_EOS);   // Ideographic full stop
    GetPropForUpdate(0xFF61).Set(PROP_EOS);   // Half width ideographic full stop

    GetPropForUpdate(0x2024).Set(PROP_EOS);  // One dot leader
    GetPropForUpdate(0x2025).Set(PROP_EOS);  // Two dot leader
    GetPropForUpdate(0x2026).Set(PROP_EOS);  // Three dot leader

    GetPropForUpdate(0x003F).Set(PROP_EOS);  // ?
    GetPropForUpdate(0xFF1F).Set(PROP_EOS);  // Full width ?
    GetPropForUpdate(0x00BF).Set(PROP_EOS);  // inverted question mark
    GetPropForUpdate(0x037E).Set(PROP_EOS);  // greek question mark
    GetPropForUpdate(0x203D).Set(PROP_EOS);  // interrobang
    GetPropForUpdate(0x2048).Set(PROP_EOS);  // question exclemation mark
    GetPropForUpdate(0x2049).Set(PROP_EOS);  // exclamation question mark


    GetPropForUpdate(0x0021).Set(PROP_EOS);
    GetPropForUpdate(0xFF01).Set(PROP_EOS);  // Full width
    GetPropForUpdate(0x00A1).Set(PROP_EOS);
    GetPropForUpdate(0x01C3).Set(PROP_EOS);
    GetPropForUpdate(0x203C).Set(PROP_EOS);
    GetPropForUpdate(0x203D).Set(PROP_EOS);
    GetPropForUpdate(0x2762).Set(PROP_EOS);

    GetPropForUpdate(0x003B).Set(PROP_EOS); // ;
    GetPropForUpdate(0xFF1B).Set(PROP_EOS); // Full width ;

    //
    // Currency
    //

    GetPropForUpdate(0x0024).Set(PROP_CURRENCY);  // dollar
    GetPropForUpdate(0xFF04).Set(PROP_CURRENCY);  // Full width dollar
    GetPropForUpdate(0x00A2).Set(PROP_CURRENCY);  // cent
    GetPropForUpdate(0xFFE0).Set(PROP_CURRENCY);  // Full width cent
    GetPropForUpdate(0x00A3).Set(PROP_CURRENCY);  // pound
    GetPropForUpdate(0xFFE1).Set(PROP_CURRENCY);  // Full width pound
    GetPropForUpdate(0x00A4).Set(PROP_CURRENCY);  // General currency sign
    GetPropForUpdate(0x00A5).Set(PROP_CURRENCY);  // yen
    GetPropForUpdate(0xFFE5).Set(PROP_CURRENCY);  // Full width yen
    GetPropForUpdate(0x09F2).Set(PROP_CURRENCY);  // Bengali Rupee Mark
    GetPropForUpdate(0x09F3).Set(PROP_CURRENCY);  // Bengali Rupee Sign
    GetPropForUpdate(0x0E3F).Set(PROP_CURRENCY);  // Baht (Thailand)
    GetPropForUpdate(0x20A0).Set(PROP_CURRENCY);  // Euro
    GetPropForUpdate(0x20A1).Set(PROP_CURRENCY);  // Colon (Costa Rica, El Salv.)
    GetPropForUpdate(0x20A2).Set(PROP_CURRENCY);  // Cruzeiro (Brazil)
    GetPropForUpdate(0x20A3).Set(PROP_CURRENCY);  // French Franc
    GetPropForUpdate(0x20A4).Set(PROP_CURRENCY);  // Lira (Italy, Turkey)
    GetPropForUpdate(0x20A5).Set(PROP_CURRENCY);  // Mill Sign (USA, 1/10 cent)
    GetPropForUpdate(0x20A6).Set(PROP_CURRENCY);  // Naira Sign (Nigeria)
    GetPropForUpdate(0x20A7).Set(PROP_CURRENCY);  // Peseta (Spain)
    GetPropForUpdate(0x20A8).Set(PROP_CURRENCY);  // Rupee
    GetPropForUpdate(0x20A9).Set(PROP_CURRENCY);  // Won (Korea)
    GetPropForUpdate(0xFFE6).Set(PROP_CURRENCY);  // Full width Won (Korea)
    GetPropForUpdate(0x20AA).Set(PROP_CURRENCY);  // New Sheqel (Israel)
    GetPropForUpdate(0x20AB).Set(PROP_CURRENCY);  // Dong (Vietnam)
    GetPropForUpdate(0x20AC).Set(PROP_CURRENCY);  // Euro sign  
    GetPropForUpdate(0x20AD).Set(PROP_CURRENCY);  // Kip sign  
    GetPropForUpdate(0x20AE).Set(PROP_CURRENCY);  // Tugrik sign  
    GetPropForUpdate(0x20AF).Set(PROP_CURRENCY);  // Drachma sign  

    //
    // Breaker
    //

    GetPropForUpdate(0x005E).Set(PROP_BREAKER);  // ^
    GetPropForUpdate(0xFF3E).Set(PROP_BREAKER);  // Full width ^
    GetPropForUpdate(0x00A6).Set(PROP_BREAKER);  // Broken vertical bar
    GetPropForUpdate(0xFFE4).Set(PROP_BREAKER);  // Full width Broken vertical bar
    GetPropForUpdate(0x00A7).Set(PROP_BREAKER);  // section sign
    GetPropForUpdate(0x00AB).Set(PROP_BREAKER);  // Not sign
    GetPropForUpdate(0x00B1).Set(PROP_BREAKER);  // Plus minus sign
    GetPropForUpdate(0x00B6).Set(PROP_BREAKER);  // Pargraph sign
    GetPropForUpdate(0x00B7).Set(PROP_BREAKER);  // Middle dot
    GetPropForUpdate(0x00D7).Set(PROP_BREAKER);  // Multiplication sign
    GetPropForUpdate(0x00F7).Set(PROP_BREAKER);  // Devision sign
    GetPropForUpdate(0x01C0).Set(PROP_BREAKER); 
    GetPropForUpdate(0x01C1).Set(PROP_BREAKER);  
    GetPropForUpdate(0x01C2).Set(PROP_BREAKER);  
    GetPropForUpdate(0x200C).Set(PROP_BREAKER);  // Formating character  
    GetPropForUpdate(0x200D).Set(PROP_BREAKER);  // Formating character
    GetPropForUpdate(0x200E).Set(PROP_BREAKER);  // Formating character
    GetPropForUpdate(0x200F).Set(PROP_BREAKER);  // Formating character
    GetPropForUpdate(0x2014).Set(PROP_BREAKER);  // Em dash  
    GetPropForUpdate(0x2015).Set(PROP_BREAKER);  // Horizontal bar  
    GetPropForUpdate(0x2016).Set(PROP_BREAKER);  // Double vertical line
    
    for (wch = 0x2020; wch <= 0x2027; wch++)          
    {
        GetPropForUpdate(wch).Set(PROP_BREAKER);
    }

    for (wch = 0x2028; wch <= 0x202E; wch++)     // Formating characters          
    {
        GetPropForUpdate(wch).Set(PROP_BREAKER);
    }

    for (wch = 0x2030; wch <= 0x2038; wch++)     // General punctuation     
    {
        GetPropForUpdate(wch).Set(PROP_BREAKER);
    }

    GetPropForUpdate(0x203B).Set(PROP_BREAKER);

    for (wch = 0x203F; wch <= 0x2046; wch++)     // General punctuation     
    {
        GetPropForUpdate(wch).Set(PROP_BREAKER);
    }

    for (wch = 0x204A; wch <= 0x206F; wch++)     // General punctuation     
    {
        GetPropForUpdate(wch).Set(PROP_BREAKER);
    }

    for (wch = 0x2190; wch <= 0x21F3; wch++)     // Arrows     
    {
        GetPropForUpdate(wch).Set(PROP_BREAKER);
    }

    for (wch = 0x2200; wch <= 0x22EF; wch++)     // Mathematical operators
    {
        GetPropForUpdate(wch).Set(PROP_BREAKER);
    }

    for (wch = 0x2300; wch <= 0x239A; wch++)     // Miscellaneous technical
    {
        GetPropForUpdate(wch).Set(PROP_BREAKER);
    }

    GetPropForUpdate(0x3003).Set(PROP_BREAKER);  // Ditto mark
    GetPropForUpdate(0x3012).Set(PROP_BREAKER);  // Postal mark
    GetPropForUpdate(0x3013).Set(PROP_BREAKER);  // Geta mark
    GetPropForUpdate(0x301C).Set(PROP_BREAKER);  // Wave dash
    GetPropForUpdate(0x3020).Set(PROP_BREAKER);  // Postal mark face

    GetPropForUpdate(0xFFE2).Set(PROP_BREAKER);  // Full width not sign

    //
    // Transperent (all charaters that can treated as non existing for breaking)
    //
    
    GetPropForUpdate(0x0060).Set(PROP_TRANSPERENT);   // grave accent
    GetPropForUpdate(0xFF40).Set(PROP_TRANSPERENT);   // Full width grave accent
    GetPropForUpdate(0x00A0).Set(PROP_TRANSPERENT);   // NBS
    GetPropForUpdate(0x00AF).Set(PROP_TRANSPERENT);   // Macron
    GetPropForUpdate(0xFFE3).Set(PROP_TRANSPERENT);   // Full width Macron
    GetPropForUpdate(0x00B4).Set(PROP_TRANSPERENT);   // Acute Accent
    GetPropForUpdate(0x00B8).Set(PROP_TRANSPERENT);   // Cedilla Accent

    GetPropForUpdate(0x202F).Set(PROP_TRANSPERENT);   // narrow no break space
    GetPropForUpdate(0xFEFF).Set(PROP_TRANSPERENT);   // zero width no break space

    GetPropForUpdate(0x00A8).Set(PROP_TRANSPERENT);   // Diaeresis

    for (wch = 0x02B0; wch <= 0x02EE; wch++)          // Modifiers
    {
        GetPropForUpdate(wch).Set(PROP_TRANSPERENT);
    }

    for (wch = 0x0300; wch <= 0x0362; wch++)          // Combining Diacritical Marks
    {
        GetPropForUpdate(wch).Set(PROP_TRANSPERENT);
    }

    GetPropForUpdate(0x2017).Set(PROP_TRANSPERENT);   // Double low line  
    GetPropForUpdate(0x203E).Set(PROP_TRANSPERENT);   // Over line  

    for (wch = 0x20D0; wch <= 0x20E3; wch++)          // Combining Diacritical Marks for symbols
    {
        GetPropForUpdate(wch).Set(PROP_TRANSPERENT);
    }

    for (wch = 0x302A; wch <= 0x302F; wch++)          // Diacritics
    {
        GetPropForUpdate(wch).Set(PROP_TRANSPERENT);
    }
    //
    //  Complement m_apCodePage:
    //
    //  Replace all NULL entries
    //  m_apCodePage[i] == NULL by
    //  the same code page: m_aDefaultCodePage ==
    //  A row of default values  (== zero)
    //

    for (USHORT usCodePage = 0; usCodePage < (1<<8); usCodePage++)
    {
        if ( !m_apCodePage[usCodePage] )
        {
            m_apCodePage[usCodePage] = m_aDefaultCodePage;
        }

    } // for

}

inline CPropArray::~CPropArray()
{
    for (int i=0; i< (1<<8); i++)
    {
        if (m_apCodePage[i] != m_aDefaultCodePage)
        {
            delete m_apCodePage[i];
        }
    }
}

inline CPropFlag& CPropArray::GetPropForUpdate(WCHAR wch)
{

    unsigned short usCodePage = wch >> 8;
    if (!m_apCodePage[usCodePage])
    {
        m_apCodePage[usCodePage] = new CPropFlag[1<<8];
    }

    return (m_apCodePage[usCodePage])[wch & 0xFF];
}


extern CAutoClassPointer<CPropArray> g_pPropArray;

#ifdef DECLARE_ULONGLONG_ARRAY
extern CPropFlag * g_PropFlagArray;
#endif // DECLARE_ULONGLONG_ARRAY


#endif // _PROP_ARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WordBreaker.rc
//
#define IDS_PROJNAME                         100
#define IDR_ENGUSWRDBRK                      101
#define IDR_ENGUKWRDBRK                      102
#define IDR_FRNFRNWRDBRK                     103
#define IDR_ITLITLWRDBRK                     104
#define IDR_SPNMDRWRDBRK                     105

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\spanishdict.cpp ===
#include "base.h"
#include "SpanishDict.h"

#define MAX_WORD_LEN 128


CSpanishDict::CSpanishDict(WCHAR* pwcsInitFilePath) :
    m_vaDictItem4(DICT_4_INIT_SIZE),
    m_vaDictItem8(DICT_8_INIT_SIZE),
    m_vaDictItemStr(DICT_STR_INIT_SIZE),
    m_ulDictItem4Count(0),
    m_ulDictItem8Count(0),
    m_ulDictItemStrCount(0)
{
    m_apSpanishSuffix = new CSpanishSuffixDict();
    
    CStandardCFile Words(pwcsInitFilePath, L"r");

    WCHAR pwcsBuf[MAX_WORD_LEN];
    DictStatus status;

    while(fgetws(pwcsBuf, MAX_WORD_LEN, (FILE*) Words))
    {
        if (pwcsBuf[0] == L'\n')
        {
            continue;
        }

        SpanishDictItem pItem(pwcsBuf);

        if (pItem.m_ulLen <= COMPRESS_4_SIZE)
        {
            m_vaDictItem4[m_ulDictItem4Count].ulStr = pItem.m_ulStrCompress;
            m_vaDictItem4[m_ulDictItem4Count].ulData = pItem.m_dwCompress;
            m_ulDictItem4Count++;
        }
        else if (pItem.m_ulLen <= COMPRESS_8_SIZE)
        {
            m_vaDictItem8[m_ulDictItem8Count].ullStr = pItem.m_ullStrCompress;
            m_vaDictItem8[m_ulDictItem8Count].ulData = pItem.m_dwCompress;
            m_ulDictItem8Count++;
        }
        else
        {
            m_vaDictItemStr[m_ulDictItemStrCount].pszStr = new unsigned char[pItem.m_ulLen + 1];
            
            bool bRet;
            bRet = g_apSpanishUtil->ConvertToChar(
                                            pItem.m_pwcs,
                                            pItem.m_ulLen,
                                            m_vaDictItemStr[m_ulDictItemStrCount].pszStr,
                                            pItem.m_ulLen + 1);

            Assert(bRet);
            m_vaDictItemStr[m_ulDictItemStrCount].ulData = pItem.m_dwCompress;
            m_ulDictItemStrCount++;
            
        }

    }
}


void CSpanishDict::BreakWord(
    ULONG ulLen, 
    WCHAR* pwcsWord, 
    bool* pfExistAlt, 
    ULONG* pulAltLen, 
    WCHAR* pwcsAlt)
{
    *pfExistAlt = false;
    if (ulLen <= 2)
    {
        return;
    }

    //
    // very fast heuristic to find non breakable words
    //

    if (pwcsWord[ulLen - 1] != L'e' &&
        pwcsWord[ulLen - 1] != L's' &&
        pwcsWord[ulLen - 2] != L'l')
    {
        return;
    }

    
    DictStatus status;
    short sResCount;

    WCHAR pwcsBuf[MAX_WORD_LEN];
    WCHAR* pwcs = pwcsWord;
    
    ULONG ul = ulLen;
    pwcsBuf[ul] = L'\0';
    while (ul > 0)
    {
        pwcsBuf[ul - 1] = *pwcs;
        ul--;
        pwcs++;
    }
    
    CSuffixTerm* prTerm[10];
    status = m_apSpanishSuffix->m_SuffixTrie.trie_Find(
                            pwcsBuf,
                            TRIE_ALL_MATCHES | TRIE_IGNORECASE,
                            10,
                            prTerm,
                            &sResCount);

    WCHAR pwcsTemp[MAX_WORD_LEN];
    ULONG ulTempLen;

    while (sResCount > 0)
    {
        CSuffixTerm* pTerm = prTerm[sResCount - 1];
        Assert(ulLen < MAX_WORD_LEN);
        wcsncpy(pwcsTemp, pwcsWord, ulLen);
        pwcsTemp[ulLen] = L'\0';

        ulTempLen = ulLen;
        bool bRet;
        ULONG ulCompressedData;

        if (!(pTerm->ulType & (TYPE11 | TYPE12 | TYPE13 |TYPE14)))
        {
            Assert(ulLen >= pTerm->ulCut);
            if (ulLen == pTerm->ulCut)
            {
                sResCount--;
                continue;
            }
            pwcsTemp[ulLen - pTerm->ulCut] = L'\0';
            ulTempLen = ulLen - pTerm->ulCut;


            bRet = Find(pwcsTemp, ulTempLen, ulCompressedData);

            if (pTerm->ulType == TYPE1 && (!bRet))
            {
                pwcsTemp[ulTempLen] = L's';
                pwcsTemp[ulTempLen + 1] = L'\0';
                bRet = Find(pwcsTemp, ulTempLen + 1, ulCompressedData);
            }

            if ( (!bRet) ||
                 (!(g_apSpanishUtil->GetTypeFromCompressedData(ulCompressedData) & pTerm->ulType)))
            {
                sResCount--;
                continue;
            }

            *pfExistAlt = true;
            wcscpy(pwcsAlt, pwcsTemp);
            *pulAltLen = ulTempLen;
            g_apSpanishUtil->ReplaceAccent(pwcsAlt, ulCompressedData);

            switch (pTerm->ulType)            
            {
            case TYPE1:
                return;
            case TYPE2:
                *pulAltLen += 3;
                wcscat(pwcsAlt, L"ndo");
                return;
            case TYPE3:
                *pulAltLen += 1;
                wcscat(pwcsAlt, L"n");
                return;
            case TYPE4:
                *pulAltLen += 3;
                wcscat(pwcsAlt, L"mos");
                return;
            case TYPE5:
                *pulAltLen += 1;
                wcscat(pwcsAlt, L"d");
                return;
            case TYPE6:
                *pulAltLen += 1;
                wcscat(pwcsAlt, L"r");
                return;
            case TYPE7:
            case TYPE8:
            case TYPE9:
            case TYPE10:
            case TYPE15:
            case TYPE16:
                return;
            default:
                Assert(false);
            }
        }
        else
        {
            *pfExistAlt = true;

            switch (pTerm->ulType)            
            {
            case TYPE11:
                {
                    Assert(ulTempLen >= pTerm->ulLen);
                    if (ulTempLen == pTerm->ulLen)                   
                    {
                        break;
                    }
                    pwcsTemp[ulTempLen - pTerm->ulLen] = L'\0';
                    ulTempLen -= pTerm->ulLen;

                    bRet = Find(pwcsTemp, ulTempLen, ulCompressedData);

                    if (bRet && 
                        (g_apSpanishUtil->GetTypeFromCompressedData(ulCompressedData) & pTerm->ulType))
                    {
                        wcscpy(pwcsAlt, pwcsTemp);
                        *pulAltLen = ulTempLen;
                        g_apSpanishUtil->ReplaceAccent(pwcsAlt, ulCompressedData);
                        *pfExistAlt = true;
                        return;
                    }
                }
                break;
            case TYPE12:
            case TYPE14:
                {
                    pwcsTemp[ulTempLen-3] = L's';   // removing the no form the nos
                    pwcsTemp[ulTempLen-2] = L'\0';  
                    bRet = Find(pwcsTemp, ulTempLen - 2, ulCompressedData);

                    if (bRet && 
                        (g_apSpanishUtil->GetTypeFromCompressedData(ulCompressedData) & pTerm->ulType))
                    {
                        wcscpy(pwcsAlt, pwcsTemp);
                        g_apSpanishUtil->ReplaceAccent(pwcsAlt, ulCompressedData);
                        *pulAltLen = ulTempLen - 2;
                        *pfExistAlt = true;
                        return;
                    }
                    
                    Assert(pTerm->ulLen >= 3);
                    Assert(ulTempLen >= pTerm->ulLen);
                    if (ulTempLen == pTerm->ulLen)
                    {
                        break;
                    }

                    ulTempLen -= pTerm->ulLen;
                    pwcsTemp[ulTempLen] = L'\0';

                    bRet = Find(pwcsTemp, ulTempLen, ulCompressedData);
                    if (bRet && 
                        (g_apSpanishUtil->GetTypeFromCompressedData(ulCompressedData) & pTerm->ulType))
                    {
                        wcscpy(pwcsAlt, pwcsTemp);
                        g_apSpanishUtil->ReplaceAccent(pwcsAlt, ulCompressedData);
                        *pulAltLen = ulTempLen - 2;
                        *pfExistAlt = true;
                        return;
                    }

                }
                break;

            case TYPE13:
                {
                    pwcsTemp[ulTempLen-1] = L'\0';  
                    bRet = Find(pwcsTemp, ulTempLen - 1, ulCompressedData);
                   

                    if (bRet && 
                        (g_apSpanishUtil->GetTypeFromCompressedData(ulCompressedData) & pTerm->ulType))
                    {
                        wcscpy(pwcsAlt, pwcsTemp);
                        g_apSpanishUtil->ReplaceAccent(pwcsAlt, ulCompressedData);
                        *pulAltLen = ulTempLen - 1;
                        *pfExistAlt = true;
                        return;
                    }
                    
                    Assert(pTerm->ulLen >= 3);
                    Assert(ulTempLen >= pTerm->ulLen);
                    Assert(ulTempLen >= pTerm->ulLen);
                    if (ulTempLen == pTerm->ulLen)
                    {
                        break;
                    }

                    ulTempLen -= pTerm->ulLen;
                    pwcsTemp[ulTempLen] = L'\0';

                    bRet = Find(pwcsTemp, ulTempLen, ulCompressedData);
                    
                    if (bRet && 
                        (g_apSpanishUtil->GetTypeFromCompressedData(ulCompressedData) & pTerm->ulType))
                    {
                        wcscpy(pwcsAlt, pwcsTemp);
                        g_apSpanishUtil->ReplaceAccent(pwcsAlt, ulCompressedData);
                        *pulAltLen = ulTempLen - 2;
                        *pfExistAlt = true;
                        return;
                    }

                }
                break;
            }
        }


        sResCount--;
    }

    pwcsAlt[0] = L'\0';
    *pfExistAlt = false;
}


bool CSpanishDict::Find(WCHAR* pwcs, ULONG ulLen, ULONG& ulData)
{
    bool bRet;

    if (ulLen <= COMPRESS_4_SIZE)
    {
        CompressDictItem4 Key;
        bRet = g_apSpanishUtil->CompressStr4(pwcs, ulLen, Key.ulStr);
        if (!bRet)
        {
            return false;
        }

        CompressDictItem4* pItem;    
        pItem = BinaryFind<CompressDictItem4>(
                                    (CompressDictItem4*)m_vaDictItem4,
                                    m_ulDictItem4Count,
                                    Key);

        if (!pItem)
        {
            return false;
        }

        ulData = pItem->ulData;
    }
    else if (ulLen <= COMPRESS_8_SIZE)
    {
        CompressDictItem8 Key;
        bRet = g_apSpanishUtil->CompressStr8(pwcs, ulLen, Key.ullStr);
        if (!bRet)
        {
            return false;
        }

        CompressDictItem8* pItem;    
        pItem = BinaryFind<CompressDictItem8>(
                                    (CompressDictItem8*)m_vaDictItem8,
                                    m_ulDictItem8Count,
                                    Key);

        if (!pItem)
        {
            return false;
        }

        ulData = pItem->ulData;
    }
    else
    {
        unsigned char psz[32];
        bool bRet;
        bRet = g_apSpanishUtil->ConvertToChar(pwcs, ulLen, psz, 32);
        if (!bRet)
        {
            return false;
        }

        PsudoCompressDictItemStr Key;
        Key.pszStr = psz;
        CompressDictItemStr* pItem;

        pItem = BinaryFind<CompressDictItemStr>(
                                    (CompressDictItemStr*)m_vaDictItemStr,
                                    m_ulDictItemStrCount,
                                    Key);

        if (!pItem)
        {
            return false;
        }

        ulData = pItem->ulData;
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\spanishdict.h ===
#ifndef _SPANISH_DICT_H_
#define _SPANISH_DICT_H_

#include "trie.h"
#include "SpanishUtils.h"
#include "VarArray.h"

#define DICT_4_INIT_SIZE 5400  // base on the current dictionary size.
#define DICT_8_INIT_SIZE 12100
#define DICT_STR_INIT_SIZE 400


struct CompressDictItem4
{
    int Compare(CompressDictItem4 & item)
    {
        return ulStr - item.ulStr;
    }

    ULONG ulStr;
    ULONG ulData;
};

struct CompressDictItem8
{
    int Compare(CompressDictItem8 & item)
    {
        if (ullStr > item.ullStr)
        {
            return 1;
        }
        else if (ullStr < item.ullStr)
        {
            return -1;
        }
        return 0;
    }

    ULONGLONG ullStr;
    ULONG ulData;
};

struct CompressDictItemStr
{
    CompressDictItemStr() :
        pszStr(NULL),
        ulData(0)
    {
    }

    ~CompressDictItemStr()
    {
        delete[] pszStr;
    }

    int Compare(CompressDictItemStr& item)
    {
        return g_apSpanishUtil->aiStrcmp(pszStr, item.pszStr);
    }

    unsigned char* pszStr;
    ULONG ulData;
};

struct PsudoCompressDictItemStr : public CompressDictItemStr
{
    ~PsudoCompressDictItemStr()
    {
        pszStr = NULL; // we don't own the memory
    }    
};

template<class T>
T* BinaryFind(T* Array, ULONG ulArraySize, T& ItemToFind)
{
    Assert(ulArraySize);
    LONG lStart = 0;
    LONG lEnd = ulArraySize - 1;
    T* pCurrItem;

    while(lEnd >= lStart)
    {
        
        ULONG lCurrIndex = (lEnd + lStart) / 2;
        pCurrItem = &(Array[lCurrIndex]);
        int iRet = pCurrItem->Compare(ItemToFind);
        if (0 == iRet)
        {
            return pCurrItem;
        }
        else if (iRet > 0)
        {
            lEnd = lCurrIndex - 1;
        }
        else
        {
            lStart = lCurrIndex + 1; 
        }
    }

    return NULL;
}


class CSpanishDict
{
public:
    CSpanishDict(WCHAR* pwcsInitFilePath);

    void BreakWord(
            ULONG ulLen, 
            WCHAR* pwcsWord, 
            bool* pfExistAlt, 
            ULONG* pulAltLen, 
            WCHAR* pwcsAlt);

private:
    //
    // methods
    //

    bool Find(WCHAR* pwcs, ULONG ulLen, ULONG& ulData);
private:

    //
    // members
    //

    ULONG m_ulDictItem4Count;
    CVarArray<CompressDictItem4> m_vaDictItem4;

    ULONG m_ulDictItem8Count;
    CVarArray<CompressDictItem8> m_vaDictItem8;

    ULONG m_ulDictItemStrCount;
    CVarArray<CompressDictItemStr> m_vaDictItemStr;

    CAutoClassPointer<CSpanishSuffixDict> m_apSpanishSuffix;
};

#endif // _SPANISH_DICT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\spanishtokenizer.cpp ===
#include "base.h"
#include "SpanishTokenizer.h"
#include "WbUtils.h"

CAutoClassPointer<CSpanishDict> g_apSpanishDict;

CSpanishTokenizer::CSpanishTokenizer(
    TEXT_SOURCE* pTxtSource,
    IWordSink   * pWordSink,
    IPhraseSink * pPhraseSink,
    LCID lcid,
    BOOL bQueryTime,
    ULONG ulMaxTokenSize) :
    CTokenizer(pTxtSource, pWordSink, pPhraseSink, lcid, bQueryTime, ulMaxTokenSize)
{
    if (NULL == g_apSpanishDict.Get())
    {
        CSyncMutexCatcher cs(m_csSpanishDictInit);
        if (NULL == g_apSpanishDict.Get())
        {
            CAutoArrayPointer<WCHAR> apwcsPath;

            apwcsPath = CreateFilePath(L"SpanishDict.txt");

            if (NULL == g_apSpanishUtil.Get())
            {
                g_apSpanishUtil = new CSpanishUtil;
            }
        
            if (NULL == g_apSpanishDict.Get())
            {
                g_apSpanishDict = new CSpanishDict(apwcsPath.Get());
            }
        }
    }
}

void CSpanishTokenizer::OutputSimpleToken(
            CTokenState& State,
            const CCliticsTerm* pTerm)
{
    HRESULT hr;
    ULONG ulOffsetInTxtSourceBuffer = 
                    m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    if ((TAIL_MATCH_TRUNCATE == pTerm->ulOp) ||
        (HEAD_MATCH_TRUNCATE == pTerm->ulOp))
    {
        if (0 == ( State.m_ulEnd - State.m_ulStart - pTerm->ulLen ))
        {
            return;
        }

        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart,
                        &State.m_pwcsToken[State.m_ulStart],
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }


        if (pTerm->ulOp == TAIL_MATCH_TRUNCATE)
        {
            hr = m_apWordSink->PutWord(
                            State.m_ulEnd - State.m_ulStart - pTerm->ulLen,
                            &State.m_pwcsToken[State.m_ulStart],
                            State.m_ulEnd - State.m_ulStart,
                            ulOffsetInTxtSourceBuffer);
            if (FAILED(hr))
            {
                THROW_HRESULT_EXCEPTION(hr);
            }

        }
        else
        {
            Assert(pTerm->ulOp == HEAD_MATCH_TRUNCATE);
            hr = m_apWordSink->PutWord(
                            State.m_ulEnd - State.m_ulStart - pTerm->ulLen,
                            &State.m_pwcsToken[State.m_ulStart + pTerm->ulLen],
                            State.m_ulEnd - State.m_ulStart,
                            ulOffsetInTxtSourceBuffer);
            if (FAILED(hr))
            {
                THROW_HRESULT_EXCEPTION(hr);
            }
        }

        return;
    }


    WCHAR pwcsAlt[32];
    ULONG ulAltLen;
    bool bAlt = false; 
    ULONG ulWordLen = State.m_ulEnd - State.m_ulStart;
    
    if (ulWordLen < 32)
    {
        g_apSpanishDict->BreakWord(
                                ulWordLen,
                                State.m_pwcsToken + State.m_ulStart,
                                &bAlt,
                                &ulAltLen,
                                pwcsAlt);
    }

    if (bAlt)
    {
        hr = m_apWordSink->PutAltWord(
                ulAltLen,
                pwcsAlt,
                State.m_ulEnd - State.m_ulStart,
                ulOffsetInTxtSourceBuffer
                );        

        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }
    }
    
    hr = m_apWordSink->PutWord(
                    State.m_ulEnd - State.m_ulStart,
                    &State.m_pwcsToken[State.m_ulStart],
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer
                    );
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\spanishtokenizer.h ===
#ifndef _SPANISH_TOKENIZER_H_
#define _SPANISH_TOKENIZER_H_

#include "tokenizer.h"
#include "Synchro.h"
#include "SpanishDict.h"


extern CAutoClassPointer<CSpanishDict> g_apSpanishDict;

class CSpanishTokenizer : public CTokenizer
{
public:
    CSpanishTokenizer(
        TEXT_SOURCE* pTxtSource,
        IWordSink   * pWordSink,
        IPhraseSink * pPhraseSink,
        LCID lcid,
        BOOL bQueryTime,
        ULONG ulMaxTokenSize); 

    // destructor frees the passed buffer, if it exists
    virtual ~CSpanishTokenizer(void)
    {
    }

protected: 

    virtual void OutputSimpleToken(
                CTokenState& State,
                const CCliticsTerm* pTerm);

private:

    CSyncCriticalSection m_csSpanishDictInit;
};

#endif // _SPANISH_TOKENIZER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\spanishutils.cpp ===
#include "base.h"
#include "SpanishUtils.h"

CAutoClassPointer<CSpanishUtil> g_apSpanishUtil = NULL;

const CSuffixTerm g_rSpanishSuffix[] =
{
    {L"et"  ,2, 2, TYPE1},    // te
    {L"es"  ,2, 2, TYPE1},	  // se
    {L"em"  ,2, 2, TYPE1},	  // me
    {L"son" ,3, 3, TYPE1},	  // nos
    {L"sol" ,3, 3, TYPE1},	  // los
    {L"sal" ,3, 3, TYPE1},	  // las
    {L"sel" ,3, 3, TYPE1},	  // les
    {L"ol"  ,2, 2, TYPE1},	  // lo
    {L"el"  ,2, 2, TYPE1},	  // le
    {L"al"  ,2, 2, TYPE1},    // la
    {L"etes",4, 4, TYPE1},    // sete

#ifdef DICT_GEN
    {L"odn\x0e1"   ,4, 3, TYPE2},  // ndo
#endif
    {L"etodn\x0e1" ,6, 5, TYPE2},  // ndote
    {L"esodn\x0e1" ,6, 5, TYPE2},  // ndose
    {L"emodn\x0e1" ,6, 5, TYPE2},  // ndome
    {L"olodn\x0e1" ,6, 5, TYPE2},  // ndolo
    {L"elodn\x0e1" ,6, 5, TYPE2},  // ndole
    {L"alodn\x0e1" ,6, 5, TYPE2},  // ndola
    {L"sonodn\x0e1",7, 6, TYPE2},  // ndonos
    {L"solodn\x0e1",7, 6, TYPE2},  // ndolos
    {L"salodn\x0e1",7, 6, TYPE2},  // ndolas
    {L"selodn\x0e1",7, 6, TYPE2},  // ndoles

    {L"etne"  ,4, 3, TYPE3},   //ente
    {L"esne"  ,4, 3, TYPE3},   //en	se
    {L"emne"  ,4, 3, TYPE3},   //enme	
    {L"sonne" ,5, 4, TYPE3},   //ennos	
    {L"solne" ,5, 4, TYPE3},   //enlos	
    {L"salne" ,5, 4, TYPE3},   //enlas	
    {L"selne" ,5, 4, TYPE3},   //enles	
    {L"olne"  ,4, 3, TYPE3},   //enlo	
    {L"elne"  ,4, 3, TYPE3},   //enle	
    {L"alne"  ,4, 3, TYPE3},   //enla
    {L"emetne",6, 5, TYPE3},   //enteme

    {L"etsom"  ,5, 5, TYPE4},  //moste
    {L"essom"  ,5, 5, TYPE4},  //mosse	
    {L"emsom"  ,5, 5, TYPE4},  //mosme	
    {L"sonsom" ,6, 6, TYPE4},  //mosnos	
    {L"solsom" ,6, 6, TYPE4},  //moslos	
    {L"salsom" ,6, 6, TYPE4},  //moslas	
    {L"selsom" ,6, 6, TYPE4},  //mosles	
    {L"olsom"  ,5, 5, TYPE4},  //moslo	
    {L"elsom"  ,5, 5, TYPE4},  //mosle	
    {L"alsom"  ,5, 5, TYPE4},  //mosla
    {L"etessom",7, 7, TYPE4},  //mossete

    {L"soetda",6, 5, TYPE5},   // adteos
    {L"emetda",6, 5, TYPE5},   // adteme
    {L"etda"  ,4, 3, TYPE5},   // adte 
    {L"esda"  ,4, 3, TYPE5},   // adse
    {L"emda"  ,4, 3, TYPE5},   // adem
    {L"sonda" ,5, 4, TYPE5},   // adnos
    {L"solda" ,5, 4, TYPE5},   // adlos
    {L"salda" ,5, 4, TYPE5},   // adlas
    {L"selda" ,5, 4, TYPE5},   // adles
    {L"olda"  ,4, 3, TYPE5},   // adlo
    {L"elda"  ,4, 3, TYPE5},   // adle
    {L"alda"  ,4, 3, TYPE5},   // adla

    {L"etr\x0e1" ,4, 3, TYPE6}, // rte
    {L"esr\x0e1" ,4, 3, TYPE6}, // rse	
    {L"emr\x0e1" ,4, 3, TYPE6}, // rme	
    {L"sonr\x0e1",5, 4, TYPE6}, // rnos	
    {L"solr\x0e1",5, 4, TYPE6}, // rlos	
    {L"salr\x0e1",5, 4, TYPE6}, // rlas	
    {L"selr\x0e1",5, 4, TYPE6}, // rles	
    {L"olr\x0e1" ,4, 3, TYPE6}, // rlo	
    {L"elr\x0e1" ,4, 3, TYPE6}, // rle	
    {L"alr\x0e1" ,4, 3, TYPE6}, // rla

    {L"emes" ,4, 4, TYPE7},  // seme
    {L"sones",5, 5, TYPE7},  // senos
    {L"soles",5, 5, TYPE7},  // selos
    {L"oles" ,4, 4, TYPE7},  // selo
    {L"seles",5, 5, TYPE7},  // seles
    {L"eles" ,4, 4, TYPE7},  // sele
    {L"sales",5, 5, TYPE7},  // sesal
    {L"ales" ,4, 4, TYPE7},  // sela

    {L"emem", 4, 4, TYPE16}, // meme
    {L"sonem",5, 5, TYPE16}, // menos
    
    {L"solem",5, 5, TYPE8}, // melos
    {L"olem" ,4, 4, TYPE8}, // melo
    {L"selem",5, 5, TYPE8}, // meles
    {L"elem" ,4, 4, TYPE8}, // mele
    {L"salem",5, 5, TYPE8}, // mesal
    {L"alem" ,4, 4, TYPE8}, // mela

    {L"emet" ,4, 4, TYPE9}, // teme
    {L"sonet",5, 5, TYPE9}, // tenos
    {L"solet",5, 5, TYPE9}, // telos
    {L"olet" ,4, 4, TYPE9}, // telo
    {L"selet",5, 5, TYPE9}, // teles
    {L"elet" ,4, 4, TYPE9}, // tele
    {L"salet",5, 5, TYPE9}, // tesal
    {L"alet" ,4, 4, TYPE9}, // tela

    {L"etsoets\x0e9",8, 4, TYPE10},	  // steoste
    {L"soets\x0e9"  ,6, 2, TYPE10},	  // steos

    {L"sole",4, 0,TYPE11},  // elos 
    {L"ole" ,3, 0,TYPE11},  // elo
    {L"eme" ,3, 0,TYPE11},  // eme
    {L"sele",4, 0,TYPE11},  // eles
    {L"ele" ,3, 0,TYPE11},  // ele
    {L"sale",4, 0,TYPE11},  // elas
    {L"ale" ,3, 0,TYPE11},  // ela

    {L"sona",4, 0,TYPE12},  // anos

    {L"ese",3, 0, TYPE13},  // ese
    {L"esa",3, 0, TYPE13},  // ase

    {L"sone",4, 0,TYPE14},  // enos

    {L"olner",5, 5, TYPE15}, // renlo

    {L"\0",0,0,0}
};


CSpanishUtil::CSpanishUtil()
{
    WCHAR wch;
    for (wch = 0; wch < 256; wch++)
    {
        m_rCharConvert[wch] = towupper(wch);
        m_rAccentConvert[wch] = 0;
        m_rCharCompress[wch] = 0;
    }

    memset(m_rReverseAccentConvert, 0, sizeof(char) * 16);

    m_rCharConvert[0xc0] = L'A';
    m_rCharConvert[0xc1] = L'A';
    m_rCharConvert[0xc2] = L'A';
    m_rCharConvert[0xc3] = L'A';
    m_rCharConvert[0xc4] = L'A';
    m_rCharConvert[0xc5] = L'A';
    m_rCharConvert[0xc8] = L'E';
    m_rCharConvert[0xc9] = L'E';
    m_rCharConvert[0xca] = L'E';
    m_rCharConvert[0xcb] = L'E';
    m_rCharConvert[0xcc] = L'I';
    m_rCharConvert[0xcd] = L'I';
    m_rCharConvert[0xce] = L'I';
    m_rCharConvert[0xcf] = L'I';
    m_rCharConvert[0xd2] = L'O';
    m_rCharConvert[0xd3] = L'O';
    m_rCharConvert[0xd4] = L'O';
    m_rCharConvert[0xd5] = L'O';
    m_rCharConvert[0xd6] = L'O';
    m_rCharConvert[0xd9] = L'U';
    m_rCharConvert[0xda] = L'U';
    m_rCharConvert[0xdb] = L'U';
    m_rCharConvert[0xdc] = L'U';

    m_rCharConvert[0xe0] = L'A';
    m_rCharConvert[0xe1] = L'A';
    m_rCharConvert[0xe2] = L'A';
    m_rCharConvert[0xe3] = L'A';
    m_rCharConvert[0xe4] = L'A';
    m_rCharConvert[0xe5] = L'A';
    m_rCharConvert[0xe8] = L'E';
    m_rCharConvert[0xe9] = L'E';
    m_rCharConvert[0xea] = L'E';
    m_rCharConvert[0xeb] = L'E';
    m_rCharConvert[0xec] = L'I';
    m_rCharConvert[0xed] = L'I';
    m_rCharConvert[0xee] = L'I';
    m_rCharConvert[0xef] = L'I';
    m_rCharConvert[0xf2] = L'O';
    m_rCharConvert[0xf3] = L'O';
    m_rCharConvert[0xf4] = L'O';
    m_rCharConvert[0xf5] = L'O';
    m_rCharConvert[0xf6] = L'O';
    m_rCharConvert[0xf9] = L'U';
    m_rCharConvert[0xfa] = L'U';
    m_rCharConvert[0xfb] = L'U';
    m_rCharConvert[0xfc] = L'U';

    for (wch = 0; wch < 256; wch++)
    {
        if (m_rCharConvert[wch] >= L'A' && m_rCharConvert[wch] <= L'Z')
        {
            m_rCharCompress[wch] = m_rCharConvert[wch] - L'A' + 1; 
        }
    }

    m_rCharCompress[0xD1] = 28;
    m_rCharCompress[0xF1] = 28;


    m_rAccentConvert[0xe1] = 1;
    m_rAccentConvert[0xf3] = 2;
    m_rAccentConvert[0xcd] = 3;
    m_rAccentConvert[0xe9] = 4;
    m_rAccentConvert[0xfa] = 5;
    m_rAccentConvert[0xfc] = 6;
    m_rAccentConvert[0x61] = 7;
    m_rAccentConvert[0x6f] = 8;
    m_rAccentConvert[0x69] = 9;
    m_rAccentConvert[0x65] = 10;
    m_rAccentConvert[0x75] = 11;

    m_rReverseAccentConvert[1] = (WCHAR)0xe1;
    m_rReverseAccentConvert[2] = (WCHAR)0xf3;
    m_rReverseAccentConvert[3] = (WCHAR)0xcd;
    m_rReverseAccentConvert[4] = (WCHAR)0xe9;
    m_rReverseAccentConvert[5] = (WCHAR)0xfa;
    m_rReverseAccentConvert[6] = (WCHAR)0xfc;
    m_rReverseAccentConvert[7] = (WCHAR)0x61;
    m_rReverseAccentConvert[8] = (WCHAR)0x6f;
    m_rReverseAccentConvert[9] = (WCHAR)0x69;
    m_rReverseAccentConvert[10] = (WCHAR)0x65;
    m_rReverseAccentConvert[11] = (WCHAR)0x75;

}

int CSpanishUtil::aiWcscmp(const WCHAR* p, const WCHAR* t)
{
    while (*p && *t && (m_rCharConvert[*p] == m_rCharConvert[*t]))
    {
        p++;
        t++;
    }

    if ((m_rCharConvert[*p] == m_rCharConvert[*t]))
    {
        return 0;
    }
    if ((m_rCharConvert[*p] > m_rCharConvert[*t]))
    {
        return 1;
    }

    return -1;
}

int CSpanishUtil::aiStrcmp(const unsigned char* p, const unsigned char* t)
{
    while (*p && *t && (m_rCharConvert[*p] == m_rCharConvert[*t]))
    {
        p++;
        t++;
    }

    if (m_rCharConvert[*p] == m_rCharConvert[*t])
    {
        return 0;
    }
    if (m_rCharConvert[*p] > m_rCharConvert[*t])
    {
        return 1;
    }

    return -1;
}

int CSpanishUtil::aiWcsncmp(const WCHAR* p, const WCHAR* t, const int iLen)
{
    int i = 0;
    while ((i < iLen) && *p && *t && (m_rCharConvert[*p] == m_rCharConvert[*t]))
    {
        p++;
        t++;
        i++;
    }

    if ((i == iLen) || (m_rCharConvert[*p] == m_rCharConvert[*t]))
    {
        return 0;
    }
    if (m_rCharConvert[*p] > m_rCharConvert[*t])
    {
        return 1;
    }

    return -1;
}



CSpanishSuffixDict::CSpanishSuffixDict()
{
    WCHAR* pwcsCur;
    int i;
    DictStatus status;

	for (i = 0, pwcsCur = g_rSpanishSuffix[i].pwcs; 
		 *pwcsCur != L'\0'; 
		 i++, pwcsCur = g_rSpanishSuffix[i].pwcs)
	{
        status = m_SuffixTrie.trie_Insert(
                                        pwcsCur,
                                        TRIE_IGNORECASE,
                                        const_cast<CSuffixTerm*>(&g_rSpanishSuffix[i]),
                                        NULL);

        Assert (DICT_SUCCESS == status);
	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__6977EBD2_A246_11D3_BB8C_0090272FA362__INCLUDED_)
#define AFX_STDAFX_H__6977EBD2_A246_11D3_BB8C_0090272FA362__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif 

#define _ATL_APARTMENT_THREADED

#ifdef _PQS_LEAK_DETECTION
#undef new 
#endif

#include <atlbase.h>

#ifdef _PQS_LEAK_DETECTION
#define new DEBUG_NEW
#endif

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__6977EBD2_A246_11D3_BB8C_0090272FA362__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\spanishutils.h ===
////////////////////////////////////////////////////////////////////////////////
//
//  Filename :  SpanishUtils.h
//  Purpose  :  Genral utilities for spanish
//
//  Project  :  WordBreakers
//  Component:  Spanish word breaker
//
//  Author   :  yairh
//
//  Log:
//
//      Jun 20 2000 yairh creation
//
////////////////////////////////////////////////////////////////////////////////

#ifndef _SPANISH_UTILS_H_
#define _SPANISH_UTILS_H_

#include "trie.h"


#define TYPE1  1<<0
#define TYPE2  1<<1
#define TYPE3  1<<2
#define TYPE4  1<<3
#define TYPE5  1<<4
#define TYPE6  1<<5
#define TYPE7  1<<6
#define TYPE8  1<<7
#define TYPE9  1<<8
#define TYPE10  1<<9
#define TYPE11  1<<10
#define TYPE12  1<<11
#define TYPE13  1<<12
#define TYPE14  1<<13
#define TYPE15  1<<14
#define TYPE16  1<<15

#define COMPRESS_4_SIZE 6
#define COMPRESS_8_SIZE 12


class CSpanishUtil
{
public:
    CSpanishUtil::CSpanishUtil();

    int aiWcscmp(const WCHAR* p, const WCHAR* t);
    int aiStrcmp(const unsigned char* p, const unsigned char* t);
    int aiWcsncmp(const WCHAR* p, const WCHAR* t, const int iLen);

    void ReplaceAccent(WCHAR* pwcs, DWORD dwCompressedBuf)
    { 
        WORD w = (WORD) dwCompressedBuf; 
        BYTE bLoc;                         
        BYTE bc = 0;                      
        bc = (w & 0xF00) >> 8;  
        if (bc)
        {
            bLoc = (w & 0xF000) >> 12;        
            pwcs[bLoc] = (WCHAR)m_rReverseAccentConvert[bc];                   
        }                               
        bc = w & 0xF;                    
        if (bc)
        {
            bLoc = (w & 0xF0) >> 4;           
            pwcs[bLoc] = (WCHAR) m_rReverseAccentConvert[bc];                   
        }                               
    } 

    ULONG GetTypeFromCompressedData(DWORD dw)
    {
        return dw >> 16;
    }
    
    DWORD CompressData(
                ULONG ulType, 
                BYTE bLoc1,
                BYTE bChar1,
                BYTE bLoc2,
                BYTE bChar2)
    {
        return (ulType << 16) | (bLoc1 << 12) | (bChar1 << 8) | (bLoc2 << 4) | (bChar2);
    }

    ULONG AddTypeToCompressedData(ULONG ul, ULONG ulType)
    {
        return (ul | (ulType << 16));
    }


    bool CompressStr4(WCHAR* pwcsStr, ULONG ulLen, ULONG& ulCompress)
    {
        //
        // each char is 5 bits
        //

        int iShift = 27;
        ulCompress = 0;
        
        ULONG ul = 0;
        while(ul < ulLen)
        {
            Assert(iShift>=0);
            if ((*pwcsStr > 0xFF) || (m_rCharCompress[*pwcsStr] == 0) )
            {
                return false;
            }
            ulCompress |= m_rCharCompress[*pwcsStr] << iShift;

            iShift -= 5;
            pwcsStr++;
            ul++;
        }

        return true;
    }

    bool CompressStr8(WCHAR* pwcsStr, ULONG ulLen, ULONGLONG& ullCompress)
    {
        //
        // each char is 5 bits
        //

        int iShift = 59;
        ullCompress = 0;

        ULONG ul = 0;
        while(ul < ulLen)
        {
            Assert(iShift>=0);
            if ((*pwcsStr > 0xFF) || m_rCharCompress[*pwcsStr] == 0 )
            {
                return false;
            }
            ullCompress |= ((ULONGLONG)m_rCharCompress[*pwcsStr]) << iShift;

            iShift -= 5;
            pwcsStr++;
            ul++;
        }

        return true;
    }

    bool ConvertToChar(const WCHAR* pwcs, const ULONG ulLen, unsigned char* pszOut, ULONG ulOutLen)
    {
        if (ulOutLen < ulLen + 1)
        {
            return false;
        }

        ULONG ul = 0;
        
        while (ul < ulLen)
        {
            if (*pwcs > 0xFF)
            {
                return false;
            }
            *pszOut = *((char*)pwcs);
            pszOut++;
            pwcs++;
            ul++;
        }

        *pszOut = '\0';
        return true;
    }
public:

    //
    // members.
    //

    WCHAR m_rCharConvert[256];
    BYTE  m_rCharCompress[256];
    
    char  m_rAccentConvert[256];
    WCHAR m_rReverseAccentConvert[16];

};

extern CAutoClassPointer<CSpanishUtil> g_apSpanishUtil;

class CToAccUpper
{
public:
    static
    WCHAR
    MapToUpper(
        IN WCHAR wc
        )
    {
        if ( (wc & 0xff00) == 0 )
        {
            return ( g_apSpanishUtil->m_rCharConvert[wc] );
        }
        else
        {
            return ( towupper(wc) );
        } // if


    }
};

class SpanishDictItem
{
public:
    SpanishDictItem(ULONG  ulW, WCHAR* pwcsW, ULONG ulAL, WCHAR* pwcsA, ULONG ulC, ULONG ulT)
    {
        m_fOwnMemory = true;
        Assert(ulW == ulAL);

        m_ulLen = ulW;
        m_pwcs = new WCHAR[ulW + 1];
        wcsncpy(m_pwcs, pwcsW, ulW);
        m_pwcs[ulW] = L'\0';

        m_pwcsAlt = new WCHAR[ulAL + 1];
        wcsncpy(m_pwcsAlt, pwcsA, ulAL);
        m_pwcsAlt[ulAL] = L'\0';
        m_ulAltLen = ulAL;

        m_ulCounter = ulC;
        m_ulType = ulT;

        WCHAR* p = pwcsW;
        BYTE i = 0;
        BYTE k = 0;
        BYTE r[4] = {0};
        while (*p)
        {
            if (*p != pwcsA[i])
            {
                Assert(k < 4);
                Assert(i < 16);
                Assert(
                    g_apSpanishUtil->m_rCharConvert[*p] == 
                    g_apSpanishUtil->m_rCharConvert[pwcsA[i]]);
                
                r[k] = i;
                r[k+1] = g_apSpanishUtil->m_rAccentConvert[pwcsA[i]];
                k+=2;
            }

            i++;
            p++;
        }

        m_dwCompress = g_apSpanishUtil->CompressData(m_ulType, r[0], r[1], r[2], r[3]); 
        if (m_ulLen <= COMPRESS_4_SIZE)
        {
            bool b = g_apSpanishUtil->CompressStr4(m_pwcs, m_ulLen, m_ulStrCompress);
            Assert(b);
        }
        else if (m_ulLen <= COMPRESS_8_SIZE)
        {
            bool b = g_apSpanishUtil->CompressStr8(m_pwcs, m_ulLen, m_ullStrCompress);
            Assert(b);
        }

    }

    SpanishDictItem(WCHAR* pwcsBuf)
    {
        m_fOwnMemory = false;

        ULONG ul = wcslen(pwcsBuf);
        pwcsBuf[ul - 1] = L'\0';
        WCHAR* p = pwcsBuf;

        WCHAR* ppwcsParams[7];
        ppwcsParams[0] = p;
        int i = 1;
        while(*p)
        {
            if (*p == L';')
            {
                *p = L'\0';
                ppwcsParams[i] = p+1;
                i++;
            }
            p++;
        }

        m_pwcs = ppwcsParams[0];
        m_ulLen = _wtol(ppwcsParams[1]);
        m_pwcsAlt = ppwcsParams[2];
        m_ulAltLen = _wtol(ppwcsParams[3]);
        m_ulType = _wtol(ppwcsParams[4]);
        m_dwCompress = _wtol(ppwcsParams[5]);
        if (m_ulLen <= COMPRESS_4_SIZE)
        {
            m_ulStrCompress = _wtol(ppwcsParams[6]);
        }
        else if (m_ulLen <= COMPRESS_8_SIZE)
        {
            m_ullStrCompress = _wtoi64(ppwcsParams[6]);
        }


    }

    ~SpanishDictItem()
    {
        if (m_fOwnMemory)
        {
            delete[] m_pwcs;
            delete[] m_pwcsAlt;
        }
    }

    void AddType(ULONG ulType)
    {
        m_ulType |= ulType;
        m_dwCompress = g_apSpanishUtil->AddTypeToCompressedData(m_dwCompress, ulType);
    }

    int Serialize(WCHAR* pwcsBuf)
    {
        if (m_ulLen <= COMPRESS_4_SIZE)
        {
            return swprintf(
                        pwcsBuf, 
                        L"%s;%d;%s;%d;%d;%u;%u\n", 
                        m_pwcs, 
                        m_ulLen, 
                        m_pwcsAlt, 
                        m_ulAltLen, 
                        m_ulType, 
                        m_dwCompress,
                        m_ulStrCompress);
        }
        else if (m_ulLen <= COMPRESS_8_SIZE)
        {
            return swprintf(
                        pwcsBuf, 
                        L"%s;%d;%s;%d;%d;%u;%I64u\n", 
                        m_pwcs, 
                        m_ulLen, 
                        m_pwcsAlt, 
                        m_ulAltLen, 
                        m_ulType, 
                        m_dwCompress,
                        m_ullStrCompress);

        }
        return swprintf(
                    pwcsBuf, 
                    L"%s;%d;%s;%d;%d;%u;0\n", 
                    m_pwcs, 
                    m_ulLen, 
                    m_pwcsAlt, 
                    m_ulAltLen, 
                    m_ulType, 
                    m_dwCompress);

    }

    ULONG  m_ulLen;
    WCHAR* m_pwcs;
    ULONG  m_ulAltLen;
    WCHAR* m_pwcsAlt;
    ULONG  m_ulCounter;
    ULONG  m_ulType;
    DWORD  m_dwCompress;
    ULONG  m_ulStrCompress;
    ULONGLONG m_ullStrCompress;

    bool   m_fOwnMemory;

};


class CStandardCFile
{
  public:
    CStandardCFile(WCHAR *pwcsFileName, WCHAR *pwcsMode, bool fThrowExcptionOn = true)
    {
        char pszBuf[MAX_PATH];
        wcstombs(pszBuf, pwcsFileName, MAX_PATH);
        char pszMode[10];
        wcstombs(pszMode, pwcsMode, 10);

        m_pFile = fopen(pszBuf, pszMode);
        if (! m_pFile && fThrowExcptionOn)
        {
            throw CGenericException(L"Could not open file");
        }
    }

    ~CStandardCFile()
    {
        if (m_pFile)
        {
            fclose(m_pFile);
        }
    }

    operator FILE*()
    {
        return m_pFile;
    }

  protected:
    FILE    *m_pFile;
};

struct CSuffixTerm
{
    WCHAR* pwcs;
    ULONG ulLen;
    ULONG ulCut;
    ULONG ulType;
};

extern const CSuffixTerm g_rSpanishSuffix[] ;

class CSpanishSuffixDict
{
public:
    CSpanishSuffixDict();

    CTrie<CSuffixTerm, CToAccUpper> m_SuffixTrie;
};

#endif // _SPANISH_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\tokenizer.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//  Filename :  Tokenizer.cpp
//  Purpose  :  Tokenizer implementation
//
//  Project  :  WordBreakers
//  Component:  English word breaker
//
//  Author   :  yairh
//
//  Log:
//
//      Jan 06 2000 yairh creation
//      Apr 04 2000 dovh on behalf of dlee - Fix CTokenizer::OutputClitics
//          to avoid PutWord of length 0 (leads to multiple PutWord at
//          same location (duplicate keys), and index corruption!
//          Example: :...'s :...'s (. stands for junk character)
//      Apr 05 2000 dovh - Fixed two problematic debug / tracer buffer size
//          problems.  (Related to Bug 15449).
//      May 07 2000 dovh - USE_WS_SENTINEL algorithm in BreakText
//      May 11 2000 dovh - Simplify VerifyMisc test.
//      Nov 11 2000 dovh - Special underscore treatment
//          Add AddBackUnderscores '_' + alphanumeric treatment.
//
////////////////////////////////////////////////////////////////////////////////

#include "base.h"
#include "Tokenizer.h"
#include "PropArray.h"
#include "excption.h"
#include "formats.h"

DECLARE_TRIE_SENTINEL;
CWbToUpper g_WbToUpper;

CAutoClassPointer<CPropArray> g_pPropArray;

CTokenizer::CTokenizer(
    TEXT_SOURCE* pTxtSource,
    IWordSink   * pWordSink,
    IPhraseSink * pPhraseSink,
    LCID lcid,
    BOOL bQueryTime,
    ULONG ulMaxTokenSize) :
    m_pTxtSource(pTxtSource),
    m_apWordSink(pWordSink),
    m_apPhraseSink(pPhraseSink),
    m_Lcid(lcid),
    m_bQueryTime(bQueryTime),
    m_bNoMoreTxt(false),
    m_Token(ulMaxTokenSize),
    m_bWhiteSpaceGuarranteed(false)
{
    m_ulMaxTokenSize = min(ulMaxTokenSize, TOKENIZER_MAXBUFFERLIMIT);

    m_apLangSupport = new CLangSupport(lcid);

    m_pCurToken = &m_Token;

    if (pTxtSource->iEnd > pTxtSource->iCur)
    {
        CalculateUpdateEndOfBuffer();
    }
    else
    {
        m_ulUpdatedEndOfBuffer = pTxtSource->iEnd;
    }
}


void CTokenizer::BreakText()
{
    Trace(
        elVerbose,
        s_tagTokenizer,
        ("CTokenizer::BreakText()"));


    WCHAR wch;
    ULONGLONG ullflags(PROP_DEFAULT);

    //
    // USE_WS_SENTINEL Algorithm:
    //

    HRESULT hr = S_OK;

    if (m_pTxtSource->iCur >= m_ulUpdatedEndOfBuffer)
    {

        hr = FillBuffer();

    }

    while ( SUCCEEDED(hr) )
    {
        if ( m_bWhiteSpaceGuarranteed )
        {
            while (true)
            {
                wch = m_pTxtSource->awcBuffer[m_pTxtSource->iCur];

                ullflags = (GET_PROP(wch).m_ulFlag);

                if (ullflags & PROP_WS)
                {
                    if (m_pCurToken->IsNotEmpty())
                    {
                        ProcessToken();
                    }
                    m_pTxtSource->iCur++;

                    if (m_pTxtSource->iCur >= m_ulUpdatedEndOfBuffer)
                    {
                        hr = FillBuffer();
                        break;

                    }
                    continue;

                }

                //
                // The following lines are inline expenstion of what
                // used to be CToken::RecordChar:
                //

                Assert(m_pCurToken->m_ulBufPos < m_ulMaxTokenSize);
                m_pCurToken->m_awchBuf[m_pCurToken->m_ulBufPos] = wch;
                m_pCurToken->m_ulBufPos++;
                m_pCurToken->m_State.m_Properties.m_ulFlag |= ullflags;
                m_pTxtSource->iCur++;

            } // while
        }
        else
        {
            while (true)
            {
                if (m_pTxtSource->iCur >= m_ulUpdatedEndOfBuffer)
                {
                    Assert(m_pTxtSource->iCur == m_ulUpdatedEndOfBuffer);

                    //
                    // before we switch between buffers if the current token is not empty we
                    // need to proccess it. m_ulUpdatedEndOfBuffer always points to a breaker character
                    // (usually it is a WS) thus no token can start at a certain buffer and end in the
                    // proceeding buffer.
                    //

                    if (m_pCurToken->IsNotEmpty())
                    {
                        ProcessToken();
                    }

                    hr = FillBuffer();
                    if (FAILED(hr))
                    {
                        break;
                    }
                }

                wch = m_pTxtSource->awcBuffer[m_pTxtSource->iCur];

                ULONGLONG ullflags(GET_PROP(wch).m_ulFlag);

                if (ullflags & PROP_WS)
                {
                    if (m_pCurToken->IsNotEmpty())
                    {
                        ProcessToken();
                    }
                    m_pTxtSource->iCur++;
                    continue;
                }

                //
                // the following lines are inline expenstion of what used to be CToken::RecordChar.
                //

                Assert(m_pCurToken->m_ulBufPos < m_ulMaxTokenSize);
                m_pCurToken->m_awchBuf[m_pCurToken->m_ulBufPos] = wch;
                m_pCurToken->m_ulBufPos++;
                m_pCurToken->m_State.m_Properties.m_ulFlag |= ullflags;
                m_pTxtSource->iCur++;

            } // while

        } // if

    } // while ( !FAILED(hr) )

} // CTokenizer::BreakText

void CTokenizer::ProcessToken()
{
    ULONG ulOffset;

    if (m_pTxtSource->iCur < m_pCurToken->m_ulBufPos)
    {
        Trace(
            elWarning,
            s_tagTokenizer,
            ("CTokenizer::ProcessToken() wrong offset calculation"));

        //
        // BUGBUG need to understand why we got to this place.
        //

        ulOffset = m_pCurToken->m_ulBufPos + 1;
    }
    else if (m_pTxtSource->iCur == m_pCurToken->m_ulBufPos)
    {
        ulOffset = m_pCurToken->m_ulBufPos;
    }
    else
    {
        ulOffset = m_pTxtSource->iCur;
    }

    m_pCurToken->MarkEndToken(ulOffset);
    #ifdef DEBUG
        TraceToken();
    #endif

    //
    // simple token.
    //
    if (IS_PROP_SIMPLE(m_pCurToken->m_State.m_Properties))
    {
        OutputSimpleToken(
                        m_pCurToken->m_State,
                        &g_EmptyClitics);

    }
    else
    {
        ProcessTokenInternal();
    }

    if (m_pCurToken->m_fHasEos)
    {
        Trace(
            elVerbose,
            s_tagTokenizerDecision,
            ("EOS"));

        HRESULT hr;
        hr = m_apWordSink->PutBreak(WORDREP_BREAK_EOS);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }

    m_pCurToken->Clear();
}

void CTokenizer::ProcessTokenInternal()
{

    do
    {

        //
        // url
        //

        if (HAS_PROP_SLASH(m_pCurToken->m_State.m_Properties) &&
            HAS_PROP_COLON(m_pCurToken->m_State.m_Properties) &&
            HAS_PROP_ALPHA(m_pCurToken->m_State.m_Properties))
        {
            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to be <alpha>:// url", 
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));

            if (VerifyAlphaUrl())
            {
                break;
            }
        }

        if (HAS_PROP_PERIOD(m_pCurToken->m_State.m_Properties) &&
            HAS_PROP_W(m_pCurToken->m_State.m_Properties))
        {
            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to be www. url", 
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));

            if (VerifyWwwUrl())
            {
                break;
            }
        }


        //
        // Acronym
        //

        if (HAS_PROP_PERIOD(m_pCurToken->m_State.m_Properties) &&
            HAS_PROP_UPPER_CASE(m_pCurToken->m_State.m_Properties))
        {
            if (!HAS_PROP_LOWER_CASE(m_pCurToken->m_State.m_Properties) ||
                HAS_PROP_APOSTROPHE(m_pCurToken->m_State.m_Properties))
            {

                Trace(
                    elVerbose,
                    s_tagTokenizerSuspect,
                    ("%*.*S  suspected to be an acronym",
                    m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                    m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                    m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                    ));

                if (VerifyAcronym())
                {
                    break;
                }
            }

            //
            // Abbreviation
            //

            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to be an abbreviation",
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));
                

            if (VerifyAbbreviation())
            {
                break;
            }

            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to be a special abbreviation", 
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));

            if (VerifySpecialAbbreviation())
            {
                break;
            }

        }

        //
        // Hyphenation
        //
        if (HAS_PROP_DASH(m_pCurToken->m_State.m_Properties) &&
            HAS_PROP_ALPHA(m_pCurToken->m_State.m_Properties))
        {
            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to have a hyphenation",
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));

            if (VerifyHyphenation())
            {
                break;
            }
        }

        //
        // (s) parenthesis
        //

        if (HAS_PROP_LEFT_PAREN(m_pCurToken->m_State.m_Properties) &&
            HAS_PROP_RIGHT_PAREN(m_pCurToken->m_State.m_Properties) &&
            HAS_PROP_ALPHA(m_pCurToken->m_State.m_Properties))
        {
            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to have a (s) Parenthesis",
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));

            if (VerifyParens())
            {
                break;
            }
        }


        //
        // Currency
        //
        if (HAS_PROP_CURRENCY(m_pCurToken->m_State.m_Properties) &&
            HAS_PROP_NUMBER(m_pCurToken->m_State.m_Properties))
        {
            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to be a currency",
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));

            if (VerifyCurrency())
            {
                break;
            }
        }

        //
        // Numbers / time / dates
        //

        if (HAS_PROP_NUMBER(m_pCurToken->m_State.m_Properties))
        {
            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to be a number or a time or a date",
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));

            if (VerifyNumberOrTimeOrDate())
            {
                break;
            }
        }

        //
        // commersial signs
        //
        if (TEST_PROP(m_pCurToken->m_State.m_Properties, PROP_COMMERSIAL_SIGN) &&
            HAS_PROP_ALPHA(m_pCurToken->m_State.m_Properties))
        {
            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to have a commesial sign",
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));

            if (VerifyCommersialSign())
            {
                break;
            }
        }

        //
        // Misc - C++, J++, A+, A- .. C#
        //

        if ( TEST_PROP(m_pCurToken->m_State.m_Properties, (PROP_MINUS|PROP_PLUS|PROP_POUND)) &&
             HAS_PROP_ALPHA(m_pCurToken->m_State.m_Properties) )
        {
            Trace(
                elVerbose,
                s_tagTokenizerSuspect,
                ("%*.*S  suspected to belong to the misc list",
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
                m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
                ));


            if (VerifyMisc())
            {
                break;
            }
        }

        //
        // default
        //

        ProcessDefault();

    } while (false);

}

#ifdef DEBUG
void CTokenizer::TraceToken()
{
    WCHAR buf[MAX_NUM_PROP+1];

    size_t bufLen = wcslen(TRACE_CHAR);
    Assert(bufLen < MAX_NUM_PROP + 1);
    buf[bufLen] = L'\0';
    
    for(int i=0; i<bufLen; i++)
    {
        if(TEST_PROP(m_pCurToken->m_State.m_Properties, (1<<i)))
        {
          buf[i] = TRACE_CHAR[i];
        }
        else
        {
            buf[i] = L'_';
        }
    }

    Trace(
        elVerbose,
        s_tagTokenizerTrace,
        ("[%S] - %*.*S", 
        buf,
        m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
        m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
        m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
        ));


}
#endif // DEBUG

bool CTokenizer::VerifyAlphaUrl()
{
    //
    // looking for <alpha>:// pattern
    //

    CTokenState State(m_pCurToken->m_State);

    ULONG ul = State.m_ulStart;

    if (!HAS_PROP_ALPHA(GET_PROP(State.m_pwcsToken[ul])))
    {
        return false;
    }

    while (HAS_PROP_EXTENDED_ALPHA(GET_PROP(State.m_pwcsToken[ul])))
    {
        ul++;
    }

    if (!(HAS_PROP_COLON(GET_PROP(State.m_pwcsToken[ul]))))
    {
        return false;
    }
    ul++;

    if (!(HAS_PROP_SLASH(GET_PROP(State.m_pwcsToken[ul]))))
    {
        return false;
    }
    ul++;

    if (!(HAS_PROP_SLASH(GET_PROP(State.m_pwcsToken[ul]))))
    {
        return false;
    }

    {
        Trace(
            elVerbose,
            s_tagTokenizerDecision,
            ("%*.*S  is an <alpha>:// url",
            State.m_ulEnd - State.m_ulStart,
            State.m_ulEnd - State.m_ulStart,
            State.m_pwcsToken + State.m_ulStart
            ));

    }

    OutputUrl(State);

    return true;
}

bool CTokenizer::VerifyWwwUrl()
{
    CTokenState State(m_pCurToken->m_State);

    if (State.m_ulEnd - State.m_ulStart <= 4)
    {
        return false;
    }

    if (0 != _wcsnicmp(State.m_pwcsToken + State.m_ulStart, L"www.", 4))
    {
        return false;
    }

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  is a www. url",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    OutputUrl(State);

    return true;
}

bool CTokenizer::VerifyAcronym()
{
    //
    // looking for I.B.M or I.B.M. or A.B.CC but not A.B.CC.
    //

    CTokenState State(m_pCurToken->m_State);

    CPropFlag   AbbPuctTail(ACRONYM_PUNCT_TAIL);
    CPropFlag   AbbPuctHead(ACRONYM_PUNCT_HEAD);
    bool fNeedToRemoveEos = true;

    if (TEST_PROP(State.m_Properties, (ACRONYM_PUNCT_TAIL | ACRONYM_PUNCT_HEAD)))
    {
        if (TEST_PROP(GET_PROP(State.m_pwcsToken[State.m_ulEnd- 1]), ABBREVIATION_EOS))
        {
            fNeedToRemoveEos = false;
        }

        ULONG ulCharRemoved = m_pCurToken->RemoveTailPunct(AbbPuctTail, State);
        ulCharRemoved += m_pCurToken->RemoveHeadPunct(AbbPuctHead, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    const CCliticsTerm* pCliticsTerm;
    pCliticsTerm = VerifyClitics(State);

    ULONG ulEnd = State.m_ulEnd;
    ULONG ulCur = State.m_ulStart;

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        ulCur += pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        ulEnd -= pCliticsTerm->ulLen;
    }

    //
    // finding the last period
    //
    while ((ulEnd > ulCur) && 
           HAS_PROP_UPPER_CASE(GET_PROP(State.m_pwcsToken[ulEnd- 1])))
    {
        ulEnd--;
    }

    if ((ulEnd == ulCur) || 
        !HAS_PROP_PERIOD(GET_PROP(State.m_pwcsToken[ulEnd- 1])))
    {
        return false;
    }

    ULONG ulCounter = 0;

    while (ulCur < ulEnd)
    {
        if (ulCounter%2 == 0)
        {
            if (!HAS_PROP_UPPER_CASE(GET_PROP(State.m_pwcsToken[ulCur])))
            {
                return false;
            }
        }
        else
        {
            if (!HAS_PROP_PERIOD(GET_PROP(State.m_pwcsToken[ulCur])))
            {
                return false;
            }
        }
        ulCur++;
        ulCounter++;
    }

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  is an acronym",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    if (fNeedToRemoveEos && (pCliticsTerm->ulOp != TAIL_MATCH_TRUNCATE))
    {
        m_pCurToken->m_fHasEos = false;
    }
    OutputAcronym(State, pCliticsTerm);

    return true;
}

bool CTokenizer::VerifyAbbreviation()
{
    //
    // looking for Sr. Jr.
    // we define abbreviation as a pattern with 2 letters ending with a dot and the first letter
    // is a capital one
    //

    CTokenState State(m_pCurToken->m_State);
    CPropFlag   AbbPuctTail(ABBREVIATION_PUNCT_TAIL);
    CPropFlag   AbbPuctHead(ABBREVIATION_PUNCT_HEAD);
    bool fNeedToRemoveEos = true;

    if (TEST_PROP(State.m_Properties, (ABBREVIATION_PUNCT_TAIL | ABBREVIATION_PUNCT_HEAD)))
    {
        if (TEST_PROP(GET_PROP(State.m_pwcsToken[State.m_ulEnd- 1]), ABBREVIATION_EOS))
        {
            fNeedToRemoveEos = false;
        }

        ULONG ulCharRemoved = m_pCurToken->RemoveTailPunct(AbbPuctTail, State);
        ulCharRemoved += m_pCurToken->RemoveHeadPunct(AbbPuctHead, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    if ((State.m_ulEnd - State.m_ulStart) != 3)
    {
        return false;
    }

    if (!HAS_PROP_UPPER_CASE(GET_PROP(State.m_pwcsToken[State.m_ulStart])))
    {
        return false;
    }

    if (!HAS_PROP_EXTENDED_ALPHA(GET_PROP(State.m_pwcsToken[State.m_ulStart + 1])))
    {
        return false;
    }

    if (!HAS_PROP_PERIOD(GET_PROP(State.m_pwcsToken[State.m_ulStart + 2])))
    {
        return false;
    }

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  is an abbreviation",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));


    if (fNeedToRemoveEos)
    {
        m_pCurToken->m_fHasEos = false;
    }

    OutputAbbreviation(State);
    return true;

}

bool CTokenizer::VerifySpecialAbbreviation()
{
    CTokenState State(m_pCurToken->m_State);
    CPropFlag   AbbPuctTail(SPECIAL_ABBREVIATION_PUNCT_TAIL);
    CPropFlag   AbbPuctHead(SPECIAL_ABBREVIATION_PUNCT_HEAD);

    if (TEST_PROP(State.m_Properties, (SPECIAL_ABBREVIATION_PUNCT_TAIL | SPECIAL_ABBREVIATION_PUNCT_HEAD)))
    {
        ULONG ulCharRemoved = m_pCurToken->RemoveTailPunct(AbbPuctTail, State);
        ulCharRemoved += m_pCurToken->RemoveHeadPunct(AbbPuctHead, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }

        if (!HAS_PROP_PERIOD(State.m_Properties))
        {
            return false;
        }
    }

    const CCliticsTerm* pCliticsTerm;
    pCliticsTerm = VerifyClitics(State);

    ULONG ulAddToStart = 0;
    ULONG ulDecFromEnd = 0;

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        ulAddToStart = pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        ulDecFromEnd = pCliticsTerm->ulLen;
    }


    CAbbTerm* pTerm;
    short sResCount = 0;
    DictStatus status;

    CSpecialAbbreviationSet* pAbbSet = m_apLangSupport->GetAbbSet();
    status = pAbbSet->m_trieAbb.trie_Find(
                                State.m_pwcsToken + State.m_ulStart + ulAddToStart,
                                TRIE_LONGEST_MATCH | TRIE_IGNORECASE,
                                1,
                                &pTerm,
                                &sResCount);

    if (sResCount &&
        (pTerm->ulAbbLen == (State.m_ulEnd - State.m_ulStart - ulAddToStart - ulDecFromEnd)))
    {
        Trace(
            elVerbose,
            s_tagTokenizerDecision,
            ("%*.*S is an abbreviation",
            State.m_ulEnd - State.m_ulStart,
            State.m_ulEnd - State.m_ulStart,
            State.m_pwcsToken + State.m_ulStart
            ));

        OutputSpecialAbbreviation(State, pTerm, pCliticsTerm);
        return true;
    }

    return false;
}

bool CTokenizer::VerifyMisc()
{
    CTokenState State(m_pCurToken->m_State);
    CPropFlag   MiscPuctTail(MISC_PUNCT_TAIL);
    CPropFlag   MiscPuctHead(MISC_PUNCT_HEAD);

    if (TEST_PROP(State.m_Properties, (MISC_PUNCT_TAIL | MISC_PUNCT_HEAD)))
    {
        ULONG ulCharRemoved = m_pCurToken->RemoveTailPunct(MiscPuctTail, State);
        ulCharRemoved += m_pCurToken->RemoveHeadPunct(MiscPuctHead, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    const CCliticsTerm* pCliticsTerm;
    pCliticsTerm = VerifyClitics(State);

    ULONG ulAddToStart = 0;
    ULONG ulDecFromEnd = 0;

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        ulAddToStart = pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        ulDecFromEnd = pCliticsTerm->ulLen;
    }

    bool bPatternContainOnlyUpperCase = true;
    ULONG ulSuffixSize = 0;
    
    if (TEST_PROP(State.m_Properties, PROP_POUND))
    {
        //
        // look for A# C#
        //

        ULONG ulEnd = State.m_ulEnd - ulDecFromEnd;
        ULONG ulStart = State.m_ulStart + ulAddToStart;
        if (ulEnd - ulStart != 2)
        {
            return false;
        }

        if (!TEST_PROP(GET_PROP(State.m_pwcsToken[ulEnd - 1]), PROP_POUND))
        {
            return false;
        }

        if (!TEST_PROP(GET_PROP(State.m_pwcsToken[ulStart]), PROP_UPPER_CASE))
        {
            return false;
        }
        
        ulSuffixSize = 1;
    }
    else
    {
        //
        // look for C++ COM+ ...
        //

        ULONG ul = State.m_ulEnd - ulDecFromEnd - 1;
        while ((int)ul >= (int)(State.m_ulStart + ulAddToStart))
        {
            if (!TEST_PROP(GET_PROP(State.m_pwcsToken[ul]), PROP_PLUS | PROP_MINUS))
            {
                break;
            }
            ulSuffixSize++;
            ul--;
        }

        if (ulSuffixSize > 2)
        {
            return false;
        }

        while ((int)ul >= (int)(State.m_ulStart + ulAddToStart))
        {
            CPropFlag prop(GET_PROP(State.m_pwcsToken[ul]));
            if (!HAS_PROP_EXTENDED_ALPHA(prop))
            {
                return false;
            }
            if (!TEST_PROP(prop, PROP_UPPER_CASE))
            {
                bPatternContainOnlyUpperCase = false;
            }

            ul--;
        }
    }

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S is detected",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    OutputMisc(
            State,
            bPatternContainOnlyUpperCase,
            ulSuffixSize,
            pCliticsTerm);

    return true;

}

bool CTokenizer::VerifyHyphenation()
{
    //
    // looking for data-base
    //

    CPropFlag PunctHead(HYPHENATION_PUNCT_HEAD);
    CPropFlag PunctTail(HYPHENATION_PUNCT_TAIL);
    CTokenState State(m_pCurToken->m_State);

    if (TEST_PROP(State.m_Properties, (HYPHENATION_PUNCT_HEAD | HYPHENATION_PUNCT_TAIL)))
    {
        ULONG ulCharRemoved;
        ulCharRemoved = m_pCurToken->RemoveHeadPunct(PunctHead, State);
        ulCharRemoved += m_pCurToken->RemoveTailPunct(PunctTail, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    if (!HAS_PROP_DASH(State.m_Properties))
    {
        return false;
    }

    const CCliticsTerm* pCliticsTerm;
    pCliticsTerm = VerifyClitics(State);

    ULONG ulAddToStart = 0;
    ULONG ulDecFromEnd = 0;

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        ulAddToStart = pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        ulDecFromEnd = pCliticsTerm->ulLen;
    }


    ULONG ulCur = State.m_ulStart + ulAddToStart;
    ULONG ulEnd = State.m_ulEnd - ulDecFromEnd;

    bool bReadAlpha = false;

    do
    {
        while (ulCur < ulEnd)
        {
            if (HAS_PROP_EXTENDED_ALPHA(GET_PROP(m_pCurToken->m_State.m_pwcsToken[ulCur])))
            {
                ulCur++;
                bReadAlpha = true;
                continue;
            }
            break;
        }

        if (!bReadAlpha)
        {
            return false;
        }

        if (ulCur < ulEnd)
        {
            if (!HAS_PROP_DASH(GET_PROP(m_pCurToken->m_State.m_pwcsToken[ulCur])))
            {
                return false;
            }
        }
        else
        {
            break;
        }

        ulCur++;
        bReadAlpha = false;
    }
    while (ulCur < ulEnd);

    if (!bReadAlpha)
    {
        //
        // last characters where not alpha ex. free-
        //
        return false;
    }

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  is an hyphenation",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    OutputHyphenation(State, pCliticsTerm);

    return true;
}

bool CTokenizer::VerifyParens()
{
    CPropFlag PunctTail(PAREN_PUNCT_TAIL);
    CPropFlag PunctHead(PAREN_PUNCT_HEAD);

    CTokenState State(m_pCurToken->m_State);

    if (TEST_PROP(State.m_Properties, (PAREN_PUNCT_TAIL | PAREN_PUNCT_HEAD)))
    {
        ULONG ulCharRemoved;
        ulCharRemoved = m_pCurToken->RemoveTailPunct(PunctTail, State);
        ulCharRemoved += m_pCurToken->RemoveHeadPunct(PunctHead, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    //
    // looking for (s)
    //

    if ((State.m_ulEnd - State.m_ulStart) < 4)
    {
        return false;
    }

    if (0 != wcsncmp(State.m_pwcsToken + State.m_ulEnd - 3, L"(s)", 3))
    {
        return false;
    }

    for (ULONG ul = State.m_ulStart; ul < State.m_ulEnd - 3; ul++)
    {
        if (!HAS_PROP_EXTENDED_ALPHA(GET_PROP(State.m_pwcsToken[ul])))
        {
            return false;
        }
    }

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  has (s) parenthesis",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    OutputParens(State);

    return true;
}

const CCliticsTerm* CTokenizer::VerifyClitics(CTokenState& S)
{
    if (TEST_PROP(GET_PROP(S.m_pwcsToken[S.m_ulStart]), PROP_APOSTROPHE))
    {
        S.m_ulStart++;
        
        if ((TEST_PROP(GET_PROP(S.m_pwcsToken[S.m_ulEnd - 1]), PROP_APOSTROPHE)) &&
            (S.m_ulEnd > S.m_ulStart))
        {
            S.m_ulEnd--;
        }

        m_pCurToken->ComputeStateProperties(S);
    }

    if (!(HAS_PROP_APOSTROPHE(S.m_Properties)))
    {
        return &g_EmptyClitics;
    }

    CPropFlag PunctTail(CLITICS_PUNC_TAIL);
    CPropFlag PunctHead(CLITICS_PUNCT_HEAD);

    CTokenState State(S);

    if (TEST_PROP(State.m_Properties, (CLITICS_PUNC_TAIL | CLITICS_PUNCT_HEAD)))
    {
        ULONG ulCharRemoved;
        ulCharRemoved = m_pCurToken->RemoveTailPunct(PunctTail, State);
        ulCharRemoved += m_pCurToken->RemoveHeadPunct(PunctHead, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    Trace(
        elVerbose,
        s_tagTokenizerSuspect,
        ("%*.*S  suspected to have an apostophe",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));



    ULONG ulApostrophePos = -1;
    ULONG ulCur;
    for (ulCur = State.m_ulStart; ulCur < State.m_ulEnd ; ulCur++)
    {

        if (TEST_PROP(GET_PROP(State.m_pwcsToken[ulCur]), PROP_APOSTROPHE))
        {
            if ((-1 != ulApostrophePos) || (State.m_ulStart == ulCur))
            {
                //
                // this is not the first \' this is not a valid clitics
                // or the term start with a new apostrophe
                //
                return &g_EmptyClitics;
            }
            ulApostrophePos = ulCur;
            //
            // replace the apostrophe with an ascii apostrophe.
            //
            State.m_pwcsToken[ulCur] = L'\'';
            continue;
        }
    }

    //
    // looking for  xxxxs'
    //
    if ((ulApostrophePos == State.m_ulEnd - 1) &&
        (State.m_pwcsToken[ulApostrophePos - 1] == L's'))
    {

        Trace(
            elVerbose,
            s_tagTokenizerDecision,
            ("%*.*S  has a s' clitcs",
            State.m_ulEnd - State.m_ulStart,
            State.m_ulEnd - State.m_ulStart,
            State.m_pwcsToken + State.m_ulStart
            ));

        S = State;
        return &g_SClitics;

    }

    //
    // looking for tail clitics like xxx's
    //

    DictStatus status;

    CCliticsTerm* pTerm;
    short sResCount = 0;

    if (ulCur > State.m_ulStart)
    {
        status = g_pClitics->m_trieClitics.trie_Find(
                                    State.m_pwcsToken + ulApostrophePos,
                                    TRIE_LONGEST_MATCH | TRIE_IGNORECASE,
                                    1,
                                    &pTerm,
                                    &sResCount);
        if (sResCount && pTerm->ulLen == (State.m_ulEnd - ulApostrophePos))
        {
            Trace(
                elVerbose,
                s_tagTokenizerDecision,
                ("%*.*S  has a %S clitcs",
                State.m_ulEnd - State.m_ulStart,
                State.m_ulEnd - State.m_ulStart,
                State.m_pwcsToken + State.m_ulStart,
                pTerm->pwcs
                ));

            S = State;
            return pTerm;
        }
    }

    //
    // looking for head clitics like l'xxxx
    //

    status = g_pClitics->m_trieClitics.trie_Find(
                                State.m_pwcsToken + State.m_ulStart,
                                TRIE_LONGEST_MATCH | TRIE_IGNORECASE,
                                1,
                                &pTerm,
                                &sResCount);
    if (sResCount)
    {
        Trace(
            elVerbose,
            s_tagTokenizerDecision,
            ("%*.*S  has a %S clitcs",
            State.m_ulEnd - State.m_ulStart,
            State.m_ulEnd - State.m_ulStart,
            State.m_pwcsToken + State.m_ulStart,
            pTerm->pwcs
            ));

        S = State;
        return pTerm;
    }

    return &g_EmptyClitics;
}

bool CTokenizer::VerifyNumberOrTimeOrDate()
{
    CPropFlag PunctHead(NUM_DATE_TIME_PUNCT_HEAD);
    CPropFlag PunctTail(NUM_DATE_TIME_PUNCT_TAIL);
    CTokenState State(m_pCurToken->m_State);

    if (TEST_PROP(State.m_Properties,
                  (NUM_DATE_TIME_PUNCT_HEAD | NUM_DATE_TIME_PUNCT_TAIL)))
    {
        ULONG ulCharRemoved;
        ulCharRemoved= m_pCurToken->RemoveHeadPunct(PunctHead, State);
        ulCharRemoved += m_pCurToken->RemoveTailPunct(PunctTail, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    if ((TEST_PROP(
            State.m_Properties,
            (GET_PROP(m_apLangSupport->GetTimeSeperator()).m_ulFlag))) ||
         HAS_PROP_ALPHA(State.m_Properties))
    {
        //
        // suspected to be time 12:33 14:22 15:22:33
        // or  AM/PM time format 12:22AM 13PM
        //


        Trace(
            elVerbose,
            s_tagTokenizerSuspect,
            ("%*.*S  suspected to be AM/PM time", 
            State.m_ulEnd - State.m_ulStart,
            State.m_ulEnd - State.m_ulStart,
            State.m_pwcsToken + State.m_ulStart
            ));

        if (VerifyTime(State))
        {
            return true;
        }

    }


    Trace(
        elVerbose,
        s_tagTokenizerSuspect,
        ("%*.*S  suspected to be a simple number", 
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    if (VerifyNumber(State))
    {
        return true;
    }

    if (TEST_PROP(State.m_Properties, PROP_DATE_SEPERATOR))
    {
        //
        // suspected to be a date 1999-05-04 or 1998/11/10 1999.05.04
        //

        Trace(
            elVerbose,
            s_tagTokenizerSuspect,
            ("%*.*S  suspected to be a date", 
            m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
            m_pCurToken->m_State.m_ulEnd - m_pCurToken->m_State.m_ulStart,
            m_pCurToken->m_State.m_pwcsToken + m_pCurToken->m_State.m_ulStart
            ));

        return VerifyDate(State);
    }


    return false;
}


bool CTokenizer::VerifyTime(CTokenState& S)
{
    CTokenState State(S);
    CPropFlag PunctHead(TIME_ADDITIONAL_PUNCT_HEAD);
    CPropFlag PunctTail(TIME_ADDITIONAL_PUNCT_TAIL);

    if (TEST_PROP(State.m_Properties,
                  (TIME_ADDITIONAL_PUNCT_HEAD | TIME_ADDITIONAL_PUNCT_TAIL)))
    {
        ULONG ulCharRemoved;
        ulCharRemoved= m_pCurToken->RemoveHeadPunct(PunctHead, State);
        ulCharRemoved += m_pCurToken->RemoveTailPunct(PunctTail, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    if ((State.m_ulEnd - State.m_ulStart) > MAX_TIME_FORMAT_LEN)
    {
        return false;
    }

    WCHAR pwcsBuf[MAX_TIME_FORMAT_LEN + 1];
    ULONG ulCur = State.m_ulStart;
    WCHAR wcSeperator = 0xFFFF;
    ULONG ul = 0;

    //
    // formatting the text to a date format
    //

    while (ulCur < State.m_ulEnd)
    {
        CPropFlag prop(GET_PROP(State.m_pwcsToken[ulCur]));
        if (HAS_PROP_NUMBER(prop))
        {
            pwcsBuf[ul] = L'#';
        }
        else if (State.m_pwcsToken[ulCur] == m_apLangSupport->GetTimeSeperator())
        {
            if (0xFFFF == wcSeperator)
            {
                wcSeperator = State.m_pwcsToken[ulCur];
            }
            else if (wcSeperator != State.m_pwcsToken[ulCur])
            {
                return false;
            }
            pwcsBuf[ul] = L':';
        }
        else if (HAS_PROP_ALPHA(prop) || HAS_PROP_PERIOD(prop))
        {
            pwcsBuf[ul] = State.m_pwcsToken[ulCur];
        }
        else
        {
            return false;
        }

        ul++;
        ulCur++;
    }

    pwcsBuf[ul] = L'\0';

    CTimeTerm* pTerm;
    short sResCount = 0;
    DictStatus status;

    status = g_pTimeFormat->m_trieTimeFormat.trie_Find(
                                pwcsBuf,
                                TRIE_LONGEST_MATCH | TRIE_IGNORECASE,
                                1,
                                &pTerm,
                                &sResCount);
    if (!(sResCount && (pTerm->bLen == ul)))
    {
        return false;
    }

    LONG lHour;
    LONG lMin;
    LONG lSec;
    TimeFormat AmPm;

    GetValuesFromTimeString(
                        pTerm,
                        State.m_pwcsToken + State.m_ulStart ,
                        &lHour,
                        &lMin,
                        &lSec,
                        &AmPm);

    if (None == AmPm)
    {
        if (lHour > 24)
        {
            return false;
        }
    }
    else
    {
        if (lHour > 12)
        {
            return false;
        }

        if (Am == AmPm)
        {
            if (12 == lHour)
            {
                lHour = 0;
            }
        }
        else
        {
            if (lHour < 12)
            {
                lHour += 12;
            }
        }

    }

    if (lMin > 59)
    {
        return false;
    }

    if (lSec > 59)
    {
        return false;
    }

    WCHAR pwcsTime[9] = {L'\0',L'\0',L'\0',L'\0',L'\0',L'\0',L'\0',L'\0',L'\0',};

    swprintf(pwcsTime, L"TT%02d%02d", lHour, lMin);

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  is a time -> %S",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart,
        pwcsTime));

    OutputTime(pwcsTime, State);

    return true;
}

bool CTokenizer::VerifyDate(CTokenState& S)
{
    CTokenState State(S);
    CPropFlag PunctHead(DATE_ADDITIONAL_PUNCT_HEAD);
    CPropFlag PunctTail(DATE_ADDITIONAL_PUNCT_TAIL);
    if (TEST_PROP(State.m_Properties,
                  (DATE_ADDITIONAL_PUNCT_HEAD | DATE_ADDITIONAL_PUNCT_TAIL)))
    {
        ULONG ulCharRemoved;
        ulCharRemoved= m_pCurToken->RemoveHeadPunct(PunctHead, State);
        ulCharRemoved += m_pCurToken->RemoveTailPunct(PunctTail, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }


    WCHAR pwcsBuf[MAX_DATE_FORMAT_LEN + 1];

    if (State.m_ulEnd - State.m_ulStart > MAX_DATE_FORMAT_LEN)
    {
        return false;
    }

    ULONG ulCur = State.m_ulStart;
    WCHAR wcSeperator = 0xFFFF;
    ULONG ul = 0;

    //
    // formatting the text to a date format
    //

    while (ulCur < State.m_ulEnd)
    {
        CPropFlag prop(GET_PROP(State.m_pwcsToken[ulCur]));
        if (HAS_PROP_NUMBER(prop))
        {
            pwcsBuf[ul] = L'#';
        }
        else if (HAS_PROP_PERIOD(prop) ||
                 HAS_PROP_DASH(prop) ||
                 HAS_PROP_SLASH(prop))
        {
            if (0xFFFF == wcSeperator)
            {
                wcSeperator = State.m_pwcsToken[ulCur];
            }
            else if (wcSeperator != State.m_pwcsToken[ulCur])
            {
                return false;
            }
            pwcsBuf[ul] = L'.';
        }
        else
        {
            return false;
        }

        ul++;
        ulCur++;
    }

    pwcsBuf[ul] = L'\0';

    CDateTerm* pTerm;
    short sResCount = 0;
    DictStatus status;

    status = g_pDateFormat->m_trieDateFormat.trie_Find(
                                pwcsBuf,
                                TRIE_LONGEST_MATCH | TRIE_IGNORECASE,
                                1,
                                &pTerm,
                                &sResCount);
    if (!(sResCount && (pTerm->bLen == ul)))
    {
        return false;
    }

    LONG lD_M1;
    LONG lD_M2;
    LONG lYear;

    GetValuesFromDateString(
                    pTerm,
                    State.m_pwcsToken + State.m_ulStart,
                    &lD_M1,
                    &lD_M2,
                    &lYear);

    LONG lDay;
    LONG lMonth;

    //
    // language dependent
    //

    if (m_apLangSupport->IsDayMonthOrder() ||
        pTerm->bType == YYMMDD_TYPE)
    {
        lDay = lD_M1;
        lMonth = lD_M2;
    }
    else
    {
        lDay = lD_M2;
        lMonth = lD_M1;
    }

    if (!((lDay > 0) && (lDay <= 31)))
    {
        return false;
    }

    if (!((lMonth > 0) && (lMonth <= 12)))
    {
        return false;
    }


    WCHAR pwcsDate1[11] = { L'D', L'D', L'0', L'0', L'0', L'0', L'0', L'0', L'0', L'0', L'\0'};
    WCHAR pwcsDate2[11];
    bool bY2K = false;

    if (lYear <= 99)  // Y2k bug
    {
        _ltow(lYear + 1900, pwcsDate1 + 2, 10);
        bY2K = true;
    }
    else if (lYear < 1000)
    {
        _ltow(lYear, pwcsDate1 + 3, 10);
    }
    else
    {
        _ltow(lYear, pwcsDate1 + 2, 10);
    }

    if (lMonth < 10)
    {
        pwcsDate1[6] = L'0';
        _ltow(lMonth, pwcsDate1 + 7, 10);
    }
    else
    {
        _ltow(lMonth, pwcsDate1 + 6, 10);
    }

    if (lDay < 10)
    {
        pwcsDate1[8] = L'0';
        _ltow(lDay, pwcsDate1 + 9, 10);
    }
    else
    {
        _ltow(lDay, pwcsDate1 + 8, 10);
    }

    if (bY2K)
    {
        wcscpy(pwcsDate2, pwcsDate1);
        pwcsDate2[2] = L'2';
        pwcsDate2[3] = L'0';
    }

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  is a date",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    if (bY2K)
    {
        OutputDate(pwcsDate1, pwcsDate2, State);
    }
    else
    {
        OutputDate(pwcsDate1, NULL, State);
    }
    return true;
}

bool CTokenizer::VerifyNumber(CTokenState& S)
{
    CTokenState State(S);

    WCHAR pwcsNumber[TOKENIZER_MAXBUFFERLIMIT + 10];

    ULONG ulOutLen;
    ULONG ulOffsetToTxt;

    const CCliticsTerm* pCliticsTerm;
    pCliticsTerm = VerifyClitics(State);

    ULONG ulAddToStart = 0;
    ULONG ulDecFromEnd = 0;

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        ulAddToStart = pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        ulDecFromEnd = pCliticsTerm->ulLen;
    }

    bool fRet = CheckAndCreateNumber(
                            State.m_pwcsToken + State.m_ulStart + ulAddToStart,
                            State.m_ulEnd - State.m_ulStart - ulAddToStart - ulDecFromEnd,
                            pwcsNumber,
                            &ulOffsetToTxt,
                            &ulOutLen);

    if (!fRet)
    {
        return false;
    }

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  is a number",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    OutputNumbers(State, ulOutLen, pwcsNumber + ulOffsetToTxt, pCliticsTerm);

    return true;
}

bool CTokenizer::VerifyCurrency()
{
    //
    // format is either $12.22 or 12.22$
    //
    CPropFlag PunctHead(CURRENCY_PUNCT_HEAD);
    CPropFlag PunctTail(CURRENCY_PUNCT_TAIL);
    CTokenState State(m_pCurToken->m_State);

    if (TEST_PROP(State.m_Properties,
                  (CURRENCY_PUNCT_HEAD | CURRENCY_PUNCT_TAIL)))
    {
        ULONG ulCharRemoved;
        ulCharRemoved= m_pCurToken->RemoveHeadPunct(PunctHead, State);
        ulCharRemoved += m_pCurToken->RemoveTailPunct(PunctTail, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    const CCliticsTerm* pCliticsTerm;
    pCliticsTerm = VerifyClitics(State);

    ULONG ulAddToStart = 0;
    ULONG ulDecFromEnd = 0;

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        ulAddToStart = pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        ulDecFromEnd = pCliticsTerm->ulLen;
    }


    WCHAR wchCurrency;
    WCHAR pwcsCurrency[TOKENIZER_MAXBUFFERLIMIT + 10];
    WCHAR* pwcsStr = State.m_pwcsToken + State.m_ulStart;

    if (HAS_PROP_CURRENCY(GET_PROP(State.m_pwcsToken[State.m_ulStart + ulAddToStart])))
    {
        wchCurrency = State.m_pwcsToken[State.m_ulStart + ulAddToStart];
        pwcsStr += 1;
    }
    else if (HAS_PROP_CURRENCY(GET_PROP(State.m_pwcsToken[State.m_ulEnd - 1 - ulDecFromEnd])))
    {
        wchCurrency = State.m_pwcsToken[State.m_ulEnd - 1 - ulDecFromEnd];
    }
    else
    {
        return false;
    }

    ULONG ulOutLen;
    ULONG ulOffsetToTxt;

    if (false == CheckAndCreateNumber(
                                    pwcsStr + ulAddToStart,
                                    State.m_ulEnd - State.m_ulStart - 1 - ulAddToStart - ulDecFromEnd,
                                    pwcsCurrency,
                                    &ulOffsetToTxt,
                                    &ulOutLen))
    {
        return false;
    }

    Assert(ulOffsetToTxt + ulOutLen + 1 < m_ulMaxTokenSize + 4);
    pwcsCurrency[ulOffsetToTxt + ulOutLen] = wchCurrency;
    pwcsCurrency[ulOffsetToTxt + ulOutLen + 1] = L'\0';

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  is a currency",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    OutputCurrency(ulOutLen+1, pwcsCurrency + ulOffsetToTxt , State, pCliticsTerm);

    return true;
}

bool CTokenizer::VerifyCommersialSign()
{
    CTokenState State(m_pCurToken->m_State);
    CPropFlag   CommPunctTail(COMMERSIAL_SIGN_PUNCT_TAIL);
    CPropFlag   CommPunctHead(COMMERSIAL_SIGN_PUNCT_HEAD);

    if (TEST_PROP(State.m_Properties, (COMMERSIAL_SIGN_PUNCT_TAIL | COMMERSIAL_SIGN_PUNCT_HEAD)))
    {
        ULONG ulCharRemoved = m_pCurToken->RemoveTailPunct(CommPunctTail, State);
        ulCharRemoved += m_pCurToken->RemoveHeadPunct(CommPunctHead, State);
        if (ulCharRemoved)
        {
            m_pCurToken->ComputeStateProperties(State);
        }
    }

    if (TEST_PROP(GET_PROP(State.m_pwcsToken[State.m_ulEnd - 1]),
                  PROP_COMMERSIAL_SIGN))
    {
        //
        // the length of the token must be greater then 1 since it includes an alpha
        // and the commersial sign
        //
        Assert((State.m_ulEnd - State.m_ulStart) > 1);
        OutputCommersialSignToken(State);
        return true;
    }

    return false;
}

void CTokenizer::ProcessDefault()
{
    CTokenState State(m_pCurToken->m_State);

    if (TEST_PROP(State.m_Properties, PROP_DEFAULT_BREAKER))
    {
        if (TEST_PROP(State.m_Properties, PROP_FIRST_LEVEL_BREAKER))
        {
            CPropFlag prop(PROP_FIRST_LEVEL_BREAKER);

            BreakCompundString(State, prop);

            return;
        }

        if (TEST_PROP(State.m_Properties, PROP_SECOND_LEVEL_BREAKER))
        {
            CPropFlag prop(PROP_SECOND_LEVEL_BREAKER);

            BreakCompundString(State, prop);

            return;
        }
    }

    //
    // this is a simple token
    //

    const CCliticsTerm* pCliticsTerm;
    pCliticsTerm = VerifyClitics(State);

    if (pCliticsTerm == &g_EmptyClitics)
    {
        if (TEST_PROP(State.m_Properties, PROP_NBS))
        {
            CPropFlag prop(PROP_NBS);

            BreakCompundString(State, prop);

            return;
        }

        CPropFlag PunctHead(SIMPLE_PUNCT_HEAD);
        CPropFlag PunctTail(SIMPLE_PUNCT_TAIL);

        if (TEST_PROP(State.m_Properties,
                      (SIMPLE_PUNCT_HEAD | SIMPLE_PUNCT_TAIL)))
        {
            ULONG ulCharRemoved;
            ulCharRemoved= m_pCurToken->RemoveHeadPunct(PunctHead, State);
            ulCharRemoved += m_pCurToken->RemoveTailPunct(PunctTail, State);

            if ( TEST_PROP(State.m_Properties, PROP_UNDERSCORE) )
            {

                bool hasFrontUnderscore =
                    (State.m_ulStart > m_pCurToken->m_State.m_ulStart) &&
                    TEST_PROP( GET_PROP(State.m_pwcsToken[State.m_ulStart-1]),
                        PROP_UNDERSCORE ) &&
                    TEST_PROP( GET_PROP(State.m_pwcsToken[State.m_ulStart]),
                        PROP_ALPHA_NUMERIC );

                bool hasBackUnderscore =
                    (State.m_ulEnd < m_pCurToken->m_State.m_ulEnd) &&
                    TEST_PROP(GET_PROP(State.m_pwcsToken[State.m_ulEnd]),
                        PROP_UNDERSCORE) &&
                    TEST_PROP(GET_PROP(State.m_pwcsToken[State.m_ulEnd-1]),
                        PROP_ALPHA_NUMERIC);

                //
                //  Note: To change the policy to "leave ALL attached underscore
                //  seuences, simply change below condition to:
                //  if ( (hasFrontUnderscore || hasBackUnderscore) )
                //

                if ( (hasFrontUnderscore ^ hasBackUnderscore) )
                {
                    ulCharRemoved -=

                    AddBackUnderscores(
                        State,
                        hasFrontUnderscore,
                        hasBackUnderscore
                        );

                }

            } // if ( TEST_PROP(State.m_Properties, PROP_UNDERSCORE) )

            if (ulCharRemoved)
            {
                m_pCurToken->ComputeStateProperties(State);
            }
        }
    }

    if (State.m_ulEnd == State.m_ulStart)
    {
        //
        // case we remove all chracters in the above statement
        //
        return;
    }

    Trace(
        elVerbose,
        s_tagTokenizerDecision,
        ("%*.*S  is a simple token",
        State.m_ulEnd - State.m_ulStart,
        State.m_ulEnd - State.m_ulStart,
        State.m_pwcsToken + State.m_ulStart
        ));

    OutputSimpleToken(State, pCliticsTerm);
}

//
//  CTokenizer::AddBackUnderscores:
//
//  Treat cases of a "simple" token with head and/or tail underscore
//  sequence (consecutive underscores prefix or suffix); those
//  do not get flipped off and remain part of the token.
//  This routine is called after underscore removal, (as a result of
//  Remove[Head|Tail]Punct) and adds them back in.
//
//  return value: Number of underscores added back in.
//
ULONG
CTokenizer::AddBackUnderscores(
    IN CTokenState& State,
    IN bool hasFrontUnderscore,
    IN bool hasBackUnderscore
    )
{
    ULONG ulCharsAdded = 0;

    if ( hasFrontUnderscore )
    {
        // Move left over consecutive underscores
        ulCharsAdded = m_pCurToken->FindLeftmostUnderscore(State);

    }

    if ( hasBackUnderscore )
    {

        // Move right over consecutive underscores
        ulCharsAdded += m_pCurToken->FindRightmostUnderscore(State);

    } // if ( hasFrontUnderscore )

    return ulCharsAdded;

} // CTokenizer::AddBackUnderscores()

void CTokenizer::OutputUrl(CTokenState& State)
{
    HRESULT hr;

    ULONG ulOffsetInTxtSourceBuffer =
                m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    ULONG ulCur = State.m_ulStart;
    ULONG ulStart = ulCur;
    ULONG ulLenInTxtSourceBuffer = 0;
    ULONG ulOffsetDueToAnEscapeChar;

    while (ulCur < State.m_ulEnd)
    {
        ulLenInTxtSourceBuffer++;
        ulOffsetDueToAnEscapeChar = 0;

        if ((State.m_pwcsToken[ulCur] == L'%') &&
            (ulCur <= State.m_ulEnd - 2))
        {
            //
            // replacing escape charaters with real ones.
            //
            if (TEST_PROP(GET_PROP(State.m_pwcsToken[ulCur+1]) , PROP_XDIGIT) &&
                TEST_PROP(GET_PROP(State.m_pwcsToken[ulCur+2]) , PROP_XDIGIT))
            {
                short sVal;
                sVal = ConvertHexCharToNumber(State.m_pwcsToken[ulCur + 1]);
                sVal *= 16;
                sVal += ConvertHexCharToNumber(State.m_pwcsToken[ulCur + 2]);

                State.m_pwcsToken[ulCur+2] = sVal;
                for (ULONG ul = ulCur -1 ; ul >= ulStart; ul--)
                {
                    State.m_pwcsToken[ul+2] = State.m_pwcsToken[ul];
                }
                ulCur += 2;
                ulStart+=2;
                ulOffsetDueToAnEscapeChar = 2;
                ulLenInTxtSourceBuffer += 2;
            }
            else if ((ulCur <= State.m_ulEnd - 5)                                   &&
                     ((State.m_pwcsToken[ulCur+1] == L'u') ||
                      (State.m_pwcsToken[ulCur+1] == L'U'))                         &&
                     TEST_PROP(GET_PROP(State.m_pwcsToken[ulCur+2]) , PROP_XDIGIT)  &&
                     TEST_PROP(GET_PROP(State.m_pwcsToken[ulCur+3]) , PROP_XDIGIT)  &&
                     TEST_PROP(GET_PROP(State.m_pwcsToken[ulCur+4]) , PROP_XDIGIT)  &&
                     TEST_PROP(GET_PROP(State.m_pwcsToken[ulCur+5]) , PROP_XDIGIT))
            {
                short sVal;
                sVal = ConvertHexCharToNumber(State.m_pwcsToken[ulCur + 2]);
                sVal *= 0x1000;
                sVal += ConvertHexCharToNumber(State.m_pwcsToken[ulCur + 3]);
                sVal *= 0x100;
                sVal += ConvertHexCharToNumber(State.m_pwcsToken[ulCur + 4]);
                sVal *= 0x10;
                sVal += ConvertHexCharToNumber(State.m_pwcsToken[ulCur + 5]);

                State.m_pwcsToken[ulCur+5] = sVal;

                for (ULONG ul = ulCur -1 ; ul >= ulStart; ul--)
                {
                    State.m_pwcsToken[ul+5] = State.m_pwcsToken[ul];
                }
                ulCur += 5;
                ulStart+=5;
                ulOffsetDueToAnEscapeChar = 5;
                ulLenInTxtSourceBuffer += 5;
            }
        }

        if ( IS_BREAKER( State.m_pwcsToken[ulCur] ) )
        {
            if (ulCur - ulStart == 0)
            {
                //
                // only punctuation
                //
                ulCur++;
                ulStart = ulCur;
                ulOffsetInTxtSourceBuffer += ulOffsetDueToAnEscapeChar + 1;
                ulLenInTxtSourceBuffer = 0;
                continue;
            }

            hr = m_apWordSink->PutWord(
                                    ulCur - ulStart,
                                    &State.m_pwcsToken[ulStart],
                                    ulLenInTxtSourceBuffer - 1 - ulOffsetDueToAnEscapeChar,
                                    ulOffsetInTxtSourceBuffer);
            if (FAILED(hr))
            {
                THROW_HRESULT_EXCEPTION(hr);
            }

            ulStart = ulCur + 1;
            ulOffsetInTxtSourceBuffer += ulLenInTxtSourceBuffer;
            ulLenInTxtSourceBuffer = 0;

        }
        ulCur++;

    }

    //
    // last word.
    //

    if (ulStart < ulCur)
    {
        hr = m_apWordSink->PutWord(
                            ulCur - ulStart,
                            &State.m_pwcsToken[ulStart],
                            ulLenInTxtSourceBuffer,
                            ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }
}

void CTokenizer::OutputNumbers(
    CTokenState& State,
    ULONG ulLen,
    WCHAR* pwcsNumber,
    const CCliticsTerm* pCliticsTerm)
{
    HRESULT hr;
    //
    // Input: 1.22 Output: 1.22, NN1D22
    //

    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    if (ulLen > m_ulMaxTokenSize)
    {
        hr = m_apWordSink->PutWord(
                        State.m_ulEnd - State.m_ulStart,
                        &State.m_pwcsToken[State.m_ulStart],
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }
        return;
    }

    hr = m_apWordSink->PutAltWord(
                    State.m_ulEnd - State.m_ulStart,
                    &State.m_pwcsToken[State.m_ulStart],
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart - pCliticsTerm->ulLen,
                        State.m_pwcsToken + State.m_ulStart + pCliticsTerm->ulLen,
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart - pCliticsTerm->ulLen,
                        State.m_pwcsToken + State.m_ulStart,
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }

    hr = m_apWordSink->PutWord(
                    ulLen,
                    pwcsNumber,
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }


}

void CTokenizer::OutputParens(CTokenState& State)
{
    HRESULT hr;
    //
    // format is xxx(s)
    // Input: xxx(s) Output: xxx
    //

    State.m_pwcsToken[State.m_ulEnd - 3] = L'\0';

    hr = m_apWordSink->PutWord(
                State.m_ulEnd - 3 - State.m_ulStart,
                &State.m_pwcsToken[State.m_ulStart],
                State.m_ulEnd - State.m_ulStart,
                m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State));
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

}

void CTokenizer::OutputAcronym(CTokenState& State, const CCliticsTerm* pCliticsTerm)
{
    HRESULT hr;
    //
    // Input: I.B.M Output: I.B.M, IBM
    //

    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    ULONG ulAddToStart = 0;
    ULONG ulDecFromEnd = 0;

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        ulAddToStart = pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        ulDecFromEnd = pCliticsTerm->ulLen;

    }

    hr = m_apWordSink->PutAltWord(
                State.m_ulEnd - ulDecFromEnd - (State.m_ulStart + ulAddToStart),
                State.m_pwcsToken + State.m_ulStart + ulAddToStart,
                State.m_ulEnd - State.m_ulStart,
                ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

    ULONG ulCur = State.m_ulStart + ulAddToStart;
    ULONG ulNext = ulCur;

    while (ulCur < State.m_ulEnd)
    {
        if (!HAS_PROP_PERIOD(GET_PROP(State.m_pwcsToken[ulCur])))
        {
            State.m_pwcsToken[ulNext] = State.m_pwcsToken[ulCur];
            ulNext++;
            ulCur++;
            continue;
        }
        ulCur++;
    }

    if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        hr = m_apWordSink->PutAltWord(
                        ulNext - (State.m_ulStart + ulAddToStart),
                        State.m_pwcsToken + State.m_ulStart + ulAddToStart,
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }


    hr = m_apWordSink->PutWord(
                    ulNext - ulDecFromEnd - (State.m_ulStart + ulAddToStart),
                    State.m_pwcsToken + State.m_ulStart + ulAddToStart,
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

}

void CTokenizer::OutputAbbreviation(CTokenState& State)
{
    HRESULT hr;
    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    hr = m_apWordSink->PutAltWord(
                State.m_ulEnd - State.m_ulStart - 1,
                &State.m_pwcsToken[State.m_ulStart],
                State.m_ulEnd - State.m_ulStart,
                ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

    hr = m_apWordSink->PutWord(
                    State.m_ulEnd - State.m_ulStart,
                    &State.m_pwcsToken[State.m_ulStart],
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

}

void CTokenizer::OutputSpecialAbbreviation(
    CTokenState& State,
    CAbbTerm* pTerm,
    const CCliticsTerm* pCliticsTerm)
{
    HRESULT hr;
    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    WCHAR* pwcsAbb = pTerm->pwcsAbb;
    ULONG  ulLen = pTerm->ulAbbLen;

    if (pTerm->pwcsCanonicalForm)
    {
        pwcsAbb = pTerm->pwcsCanonicalForm;
        ulLen = pTerm->ulCanLen;
    }

    if (TAIL_MATCH_TRUNCATE == pCliticsTerm->ulOp)
    {
        WCHAR pwcs[TOKENIZER_MAXBUFFERLIMIT];
        wcscpy(pwcs, pwcsAbb);
        wcscpy(pwcs + ulLen, pCliticsTerm->pwcs);

        hr = m_apWordSink->PutAltWord(
                        ulLen + pCliticsTerm->ulLen,
                        pwcs,
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }

    hr = m_apWordSink->PutWord(
                    ulLen,
                    pwcsAbb,
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

}

void CTokenizer::OutputHyphenation(CTokenState& State, const CCliticsTerm* pCliticsTerm)
{
    //
    // Input: Data-Base Output Data Base, DataBase (only in query time)
    //
    HRESULT hr;
    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    ULONG ulAddToStart = 0;
    ULONG ulDecFromEnd = 0;

    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        ulAddToStart = pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        ulDecFromEnd = pCliticsTerm->ulLen;
    }

    ULONG ulCur = State.m_ulStart + ulAddToStart;
    ULONG ulStart = ulCur;
    ULONG ulRelPosInTxtSrcBuff = ulOffsetInTxtSourceBuffer;

    if (m_bQueryTime)
    {
        ULONG ulNext = ulCur;
        hr = m_apWordSink->StartAltPhrase();
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

        ULONG ulAdd = ulAddToStart;
        while (ulCur < State.m_ulEnd)
        {
            if ( HAS_PROP_DASH(GET_PROP(m_pCurToken->m_State.m_pwcsToken[ulCur])))
            {
                hr = m_apWordSink->PutWord(
                                ulNext - ulStart,
                                &State.m_pwcsToken[ulStart],
                                ulNext - ulStart + ulAdd,
                                ulRelPosInTxtSrcBuff);
                if (FAILED(hr))
                {
                    THROW_HRESULT_EXCEPTION(hr);
                }

                ulRelPosInTxtSrcBuff += ulNext - ulStart + 1 + ulAdd;
                ulStart = ulNext;
                ulCur++;
                ulAdd = 0;
                continue;
            }

            State.m_pwcsToken[ulNext] = State.m_pwcsToken[ulCur];
            ulNext++;
            ulCur++;
        }

        Assert(ulCur > ulStart);

        if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
        {
            hr = m_apWordSink->PutAltWord(
                            ulNext - ulStart,
                            &State.m_pwcsToken[ulStart],
                            ulNext - ulStart,
                            ulRelPosInTxtSrcBuff);
            if (FAILED(hr))
            {
                THROW_HRESULT_EXCEPTION(hr);
            }

        }

        hr = m_apWordSink->PutWord(
                        ulNext - ulStart - ulDecFromEnd,
                        &State.m_pwcsToken[ulStart],
                        ulNext - ulStart,
                        ulRelPosInTxtSrcBuff);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

        hr = m_apWordSink->StartAltPhrase();
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

        if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
        {
            hr = m_apWordSink->PutAltWord(
                    ulNext - State.m_ulStart,
                    &State.m_pwcsToken[State.m_ulStart],
                    State.m_ulEnd - State.m_ulStart - ulAddToStart,
                    ulOffsetInTxtSourceBuffer);
            if (FAILED(hr))
            {
                THROW_HRESULT_EXCEPTION(hr);
            }

        }

        hr = m_apWordSink->PutWord(
                        ulNext - State.m_ulStart - ulDecFromEnd - ulAddToStart,
                        State.m_pwcsToken + State.m_ulStart + ulAddToStart,
                        State.m_ulEnd - State.m_ulStart + ulAddToStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

        hr = m_apWordSink->EndAltPhrase();
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }
    else
    {
       ULONG ulAdd = ulAddToStart;

        while (ulCur < State.m_ulEnd)
        {
            if (HAS_PROP_DASH(GET_PROP(m_pCurToken->m_State.m_pwcsToken[ulCur])))
            {
                hr = m_apWordSink->PutWord(
                                ulCur - ulStart,
                                &State.m_pwcsToken[ulStart],
                                ulCur - ulStart + ulAdd,
                                ulRelPosInTxtSrcBuff);
                if (FAILED(hr))
                {
                    THROW_HRESULT_EXCEPTION(hr);
                }

                ulRelPosInTxtSrcBuff += ulCur - ulStart + 1 + ulAdd;
                ulStart = ulCur + 1;
                ulAdd = 0;
            }
            ulCur++;
        }

        Assert(ulCur > ulStart);

        if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
        {
            hr = m_apWordSink->PutAltWord(
                            ulCur - ulStart,
                            &State.m_pwcsToken[ulStart],
                            ulCur - ulStart,
                            ulRelPosInTxtSrcBuff);
            if (FAILED(hr))
            {
                THROW_HRESULT_EXCEPTION(hr);
            }

        }

        hr = m_apWordSink->PutWord(
                        ulCur - ulStart - ulDecFromEnd,
                        &State.m_pwcsToken[ulStart],
                        ulCur - ulStart,
                        ulRelPosInTxtSrcBuff);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }
    }
}

void CTokenizer::OutputTime(WCHAR* pwcsTime, CTokenState& State)
{
    HRESULT hr;
    //
    // Output: TT1353
    //

    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    hr = m_apWordSink->PutAltWord(
                    State.m_ulEnd - State.m_ulStart,
                    &State.m_pwcsToken[State.m_ulStart],
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }


    hr = m_apWordSink->PutWord(
                    6,
                    pwcsTime,
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }
}

void CTokenizer::OutputDate(
    WCHAR* pwcsDate1,
    WCHAR* pwcsDate2,
    CTokenState& State)
{
    HRESULT hr;
    //
    // Output: DD19990921
    //

    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);
    hr = m_apWordSink->PutAltWord(
                    State.m_ulEnd - State.m_ulStart,
                    &State.m_pwcsToken[State.m_ulStart],
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }


    if (pwcsDate2)
    {
        hr = m_apWordSink->PutAltWord(
                        10,
                        pwcsDate2,
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }

    hr = m_apWordSink->PutWord(
                    10,
                    pwcsDate1,
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

}

void CTokenizer::OutputSimpleToken(CTokenState& State, const CCliticsTerm* pTerm)
{
    HRESULT hr;
    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    if ((TAIL_MATCH_TRUNCATE == pTerm->ulOp) ||
        (HEAD_MATCH_TRUNCATE == pTerm->ulOp))
    {
        if (0 == ( State.m_ulEnd - State.m_ulStart - pTerm->ulLen ))
        {
            return;
        }

        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart,
                        &State.m_pwcsToken[State.m_ulStart],
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }


        if (pTerm->ulOp == TAIL_MATCH_TRUNCATE)
        {
            hr = m_apWordSink->PutWord(
                            State.m_ulEnd - State.m_ulStart - pTerm->ulLen,
                            &State.m_pwcsToken[State.m_ulStart],
                            State.m_ulEnd - State.m_ulStart,
                            ulOffsetInTxtSourceBuffer);
            if (FAILED(hr))
            {
                THROW_HRESULT_EXCEPTION(hr);
            }

        }
        else
        {
            Assert(pTerm->ulOp == HEAD_MATCH_TRUNCATE);
            hr = m_apWordSink->PutWord(
                            State.m_ulEnd - State.m_ulStart - pTerm->ulLen,
                            &State.m_pwcsToken[State.m_ulStart + pTerm->ulLen],
                            State.m_ulEnd - State.m_ulStart,
                            ulOffsetInTxtSourceBuffer);
            if (FAILED(hr))
            {
                THROW_HRESULT_EXCEPTION(hr);
            }
        }

        return;
    }

    hr = m_apWordSink->PutWord(
                    State.m_ulEnd - State.m_ulStart,
                    &State.m_pwcsToken[State.m_ulStart],
                    State.m_ulEnd - State.m_ulStart,
                    m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State));
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

}


void CTokenizer::OutputCurrency(
    ULONG ulLen,
    WCHAR* pwcsCurrency,
    CTokenState& State,
    const CCliticsTerm* pTerm)
{
    HRESULT hr;
    //
    // Output: CC12.22$
    //

    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    if (ulLen > m_ulMaxTokenSize)
    {
        hr = m_apWordSink->PutWord(
                        State.m_ulEnd - State.m_ulStart,
                        &State.m_pwcsToken[State.m_ulStart],
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }
        return;
    }

    hr = m_apWordSink->PutAltWord(
                    State.m_ulEnd - State.m_ulStart,
                    &State.m_pwcsToken[State.m_ulStart],
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }


    if (pTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart - pTerm->ulLen,
                        &State.m_pwcsToken[State.m_ulStart],
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }
    else if (pTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart - pTerm->ulLen,
                        &State.m_pwcsToken[State.m_ulStart + pTerm->ulLen],
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }

    hr = m_apWordSink->PutWord(
                    ulLen,
                    pwcsCurrency,
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }


}

void CTokenizer::OutputCommersialSignToken(
	CTokenState& State)
{
    HRESULT hr;
    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);
    hr = m_apWordSink->PutAltWord(
                    State.m_ulEnd - State.m_ulStart - 1,
                    State.m_pwcsToken + State.m_ulStart,
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

    hr = m_apWordSink->PutWord(
                    State.m_ulEnd - State.m_ulStart,
                    State.m_pwcsToken + State.m_ulStart,
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }
	
}

void CTokenizer::OutputMisc(
    CTokenState& State,
    bool bPatternContainOnlyUpperCase,
    ULONG ulSuffixSize,
    const CCliticsTerm* pCliticsTerm)
{
    HRESULT hr;
    ULONG ulOffsetInTxtSourceBuffer = m_pCurToken->CalculateStateOffsetInTxtSourceBuffer(State);

    ULONG ulAddToStart = 0;
    ULONG ulDecFromEnd = 0;


    if (pCliticsTerm->ulOp == HEAD_MATCH_TRUNCATE)
    {
        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart - pCliticsTerm->ulLen,
                        State.m_pwcsToken + State.m_ulStart + pCliticsTerm->ulLen,
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

        ulAddToStart = pCliticsTerm->ulLen;
    }
    else if (pCliticsTerm->ulOp == TAIL_MATCH_TRUNCATE)
    {
        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart - pCliticsTerm->ulLen,
                        State.m_pwcsToken + State.m_ulStart,
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

        ulDecFromEnd = pCliticsTerm->ulLen;
    }

    if (!bPatternContainOnlyUpperCase)
    {
        hr = m_apWordSink->PutAltWord(
                        State.m_ulEnd - State.m_ulStart - ulAddToStart - ulDecFromEnd - ulSuffixSize,
                        State.m_pwcsToken + State.m_ulStart + ulAddToStart,
                        State.m_ulEnd - State.m_ulStart,
                        ulOffsetInTxtSourceBuffer);
        if (FAILED(hr))
        {
            THROW_HRESULT_EXCEPTION(hr);
        }

    }

    hr = m_apWordSink->PutWord(
                    State.m_ulEnd - State.m_ulStart,
                    &State.m_pwcsToken[State.m_ulStart],
                    State.m_ulEnd - State.m_ulStart,
                    ulOffsetInTxtSourceBuffer);
    if (FAILED(hr))
    {
        THROW_HRESULT_EXCEPTION(hr);
    }

}

#define NUMBER_NO_ERROR 0
#define NUMBER_SEPERATOR_ERROR 1
#define NUMBER_ERROR 2

bool CTokenizer::CheckAndCreateNumber(
    WCHAR* pwcsStr,
    ULONG ulLen,
    WCHAR* pwcsOut,
    ULONG* pulOffsetToTxt,   // the actual output does not always start at the beginning of buffer
    ULONG* pulOutLen)
{

    int iRet;

    iRet = CheckAndCreateNumber(
                        pwcsStr,
                        ulLen,
                        m_apLangSupport->GetDecimalSeperator(),
                        m_apLangSupport->GetThousandSeperator(),
                        pwcsOut,
                        pulOffsetToTxt,
                        pulOutLen);
    if (NUMBER_NO_ERROR == iRet)
    {
        return true;
    }
    else if (NUMBER_ERROR == iRet)
    {
        return false;
    }

    iRet = CheckAndCreateNumber(
                        pwcsStr,
                        ulLen,
                        L'.',  // default value
                        0xFFFF, // no thousand sperator
                        pwcsOut,
                        pulOffsetToTxt,
                        pulOutLen);
    if (NUMBER_NO_ERROR == iRet)
    {
        return true;
    }

    return false;
}


//
//  return value:
//  NUMBER_NO_ERROR - success
//  NUMBER_SEPERATOR_ERROR - error due to sperators
//  NUMBER_ERROR - error since it's not a number.
//

int CTokenizer::CheckAndCreateNumber(
    WCHAR* pwcsStr,
    ULONG ulLen,
    WCHAR wchSDecimal,
    WCHAR wchSThousand,
    WCHAR* pwcsOut,
    ULONG* pulOffsetToTxt,   // the actual output does not always start at the beginning of buffer
    ULONG* pulOutLen)
{
    Assert(ulLen > 0);
    //
    // assumes that the out buffer is big enough.
    // looking for the following formats: 1111 1111.2222 1,111,111.222
    //

    ULONG ulCur = ulLen - 1;
    ULONG ulNumCharsBeforDigitSeperator = 0;
    ULONG ulNextChar = ulLen - 1 + 3;  // +3 is for the NN at the begging of the formated token +
                                       // additional 0 in the begining in case  .50

    bool fHasFraction = false;

    while ((((int)(ulCur)) >= 0) &&
           HAS_PROP_NUMBER(GET_PROP(pwcsStr[ulCur])))
    {
        pwcsOut[ulNextChar] = pwcsStr[ulCur];
        ulCur--;
        ulNextChar--;
        ulNumCharsBeforDigitSeperator++;
    }

    if (ulCur == ulLen - 1)
    {
        //
        // did not read any digits.
        //
        return NUMBER_ERROR;
    }

    if ((((int)ulCur) >= 0) && (pwcsStr[ulCur] == wchSDecimal))
    {
        fHasFraction = true;
        pwcsOut[ulNextChar] = L'D';
        ulCur--;
        ulNextChar--;
        ulNumCharsBeforDigitSeperator = 0;
    }

    ULONG ulNumOfThousandSeperator = 0;
    while (((int)ulCur) >= 0)
    {
        if (pwcsStr[ulCur] == wchSThousand)
        {
            if (3 != ulNumCharsBeforDigitSeperator)
            {
                return NUMBER_SEPERATOR_ERROR;
            }
            ulNumCharsBeforDigitSeperator = 0;
            ulNumOfThousandSeperator++;
        }
        else if(HAS_PROP_NUMBER(GET_PROP(pwcsStr[ulCur])))
        {
            pwcsOut[ulNextChar] = pwcsStr[ulCur];
            ulNumCharsBeforDigitSeperator++;
            ulNextChar--;
        }
        else
        {
            if (TEST_PROP(
                    GET_PROP(pwcsStr[ulCur]), PROP_DEFAULT_BREAKER))
            {
                return NUMBER_SEPERATOR_ERROR;
            }

            return NUMBER_ERROR;
        }

        ulCur--;
    }

    *pulOutLen = ulLen;

    if (L'D' == pwcsOut[ulNextChar+1])
    {
        Assert(ulNextChar >= 2);
        //
        // the number has the following format .50
        //
        pwcsOut[ulNextChar] = L'0';
        ulNextChar--;
        *pulOutLen += 1;
    }

    Assert(ulNextChar >= 1);
    pwcsOut[ulLen + 3] = L'\0';
    pwcsOut[ulNextChar] = L'N';
    pwcsOut[ulNextChar - 1] = L'N';

    *pulOutLen = *pulOutLen + 2 - ulNumOfThousandSeperator; // don't use += because 2 - ulNextChar + 1
    *pulOffsetToTxt = ulNextChar - 1;
                                                            // can be negative and since it is ULONG we
                                                            // can get the wrong result.
    if (fHasFraction)
    {
        while (HAS_PROP_NUMBER(GET_PROP(pwcsOut[*pulOutLen + *pulOffsetToTxt - 1])) &&
               (0 == ConvertCharToDigit(pwcsOut[*pulOutLen + *pulOffsetToTxt - 1])))
        {
            Assert(*pulOutLen > 3);
            (*pulOutLen)--;
        }

        if (L'D' == pwcsOut[*pulOutLen + *pulOffsetToTxt - 1])
        {
            (*pulOutLen)--;
        }
    }
    return NUMBER_NO_ERROR;
}



void CTokenizer::GetValuesFromDateString(
    CDateTerm* pFormat,
    WCHAR* pwcsDate,
    LONG* plD_M1,     // we can't tell in this stage whether this is a Day or a month.
    LONG* plD_M2,
    LONG* plYear)
{
    BYTE i;
    int iBase;

    *plD_M1 = 0;
    for ( i = pFormat->bD_M1Len, iBase = 1; i > 0; i--, iBase *= 10)
    {
        *plD_M1 += ConvertCharToDigit(pwcsDate[pFormat->bD_M1Offset + i - 1]) * iBase;
    }

    *plD_M2 = 0;
    for ( i = pFormat->bD_M2Len, iBase = 1; i > 0; i--, iBase *= 10)
    {
        *plD_M2 += ConvertCharToDigit(pwcsDate[pFormat->bD_M2Offset + i - 1]) * iBase;
    }

    *plYear = 0;
    for ( i = pFormat->bYearLen, iBase = 1; i > 0; i--, iBase *= 10)
    {
        *plYear += ConvertCharToDigit(pwcsDate[pFormat->bYearOffset + i - 1]) * iBase;
    }

}

void CTokenizer::GetValuesFromTimeString(
    CTimeTerm* pFormat,
    WCHAR* pwcsTime,
    LONG* plHour,
    LONG* plMin,
    LONG* plSec,
    TimeFormat* pAmPm)
{
    BYTE i;
    int iBase;

    *plHour = 0;
    for ( i = pFormat->bHourLen, iBase = 1; i > 0; i--, iBase *= 10)
    {
        *plHour += ConvertCharToDigit(pwcsTime[pFormat->bHourOffset + i - 1]) * iBase;
    }

    *plMin = 0;
    for ( i = pFormat->bMinLen, iBase = 1; i > 0; i--, iBase *= 10)
    {
        *plMin += ConvertCharToDigit(pwcsTime[pFormat->bMinOffset + i - 1]) * iBase;
    }

    *plSec = 0;
    for ( i = pFormat->bSecLen, iBase = 1; i > 0; i--, iBase *= 10)
    {
        *plSec += ConvertCharToDigit(pwcsTime[pFormat->bSecOffset + i - 1]) * iBase;
    }

    *pAmPm = pFormat->AmPm;

}

void CTokenizer::BreakCompundString(CTokenState& State, CPropFlag& propBreaker)
{
    //
    // still there are puctutaitons inside the token
    // we break them up and resubmit them.
    //
    ULONG ulStart = State.m_ulStart;
    ULONG ulCur = ulStart;

    while (ulCur < State.m_ulEnd)
    {
        if ( TEST_PROP1(GET_PROP(State.m_pwcsToken[ulCur]), propBreaker))
        {
            if (ulCur - ulStart == 0)
            {
                //
                // only punctuation
                //
                ulCur++;
                ulStart = ulCur;
                continue;
            }

            m_pCurToken->m_State.m_ulStart = 0;
            m_pCurToken->m_State.m_ulEnd = ulCur - ulStart;
             m_pCurToken->m_State.m_pwcsToken = State.m_pwcsToken + ulStart;
            m_pCurToken->ComputeStateProperties(m_pCurToken->m_State);
            //
            // we just created a sub token need to procces it
            //

            ProcessTokenInternal();
            ulStart = ulCur + 1;

        }
        ulCur++;
    }

    if (ulStart < ulCur)
    {
        //
        // last sub token
        //
        m_pCurToken->m_State.m_ulStart = 0;
        m_pCurToken->m_State.m_ulEnd = ulCur - ulStart;
        m_pCurToken->m_State.m_pwcsToken = State.m_pwcsToken + ulStart;
        m_pCurToken->ComputeStateProperties(m_pCurToken->m_State);
        //
        // we just created a sub token need to procces it
        //

        ProcessTokenInternal();
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\wrdbrk.cpp ===
// WrdBrk.cpp : Implementation of CWrdBrk
#include "base.h"
#include "stdafx.h"
#include "query.h"
#include "WordBreaker.h"
#include "WrdBrk.h"

/////////////////////////////////////////////////////////////////////////////
// CWrdBrk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\wrdbrk.h ===
// WrdBrk.h : Declaration of the CWrdBrk

#ifndef __WRDBRK_H_
#define __WRDBRK_H_

#include "resource.h"
#include "Query.h"
#include "autoptr.h"
#include "excption.h"
#include "tokenizer.h"
#include "FrenchTokenizer.h"
#include "SpanishTokenizer.h"


DECLARE_TAG(s_tagWordBreaker, "Word Breaker");

template <class T, const CLSID* pclsid, const long IDR, class Tokenizer>
class CBaseWrdBrk :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<T, pclsid>,
    public IWordBreaker
{
public:
    CBaseWrdBrk(LCID lcid) :
        m_fInitialize(FALSE),
        m_lcid(lcid)
    {
        Trace(
            elVerbose,
            s_tagWordBreaker,
            ("WordBreaker constructed"));

        m_pUnkMarshaler = NULL;
    }

// IWordBreaker
public:

DECLARE_REGISTRY_RESOURCEID(IDR)
DECLARE_NOT_AGGREGATABLE(T)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(T)
    COM_INTERFACE_ENTRY(IWordBreaker)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    STDMETHOD(Init)(
            BOOL fQuery,
            ULONG ulMaxTokenSize,
            BOOL * pfLicense )
    {
        BEGIN_STDMETHOD(CWrdBrk::Init, s_tagWordBreaker);

        Trace(
            elVerbose,
            s_tagWordBreaker,
            ("WordBreaker Init"));

        if (NULL == pfLicense)
        {
            return E_INVALIDARG;
        }

        m_fInitialize = TRUE;
        m_fQueryTime = fQuery;
        m_ulMaxTokenSize = ulMaxTokenSize;

        return S_OK;
        END_STDMETHOD(CWrdBrk::Init, s_tagWordBreaker);
    }

    STDMETHOD(BreakText)(
            TEXT_SOURCE * pTextSource,
            IWordSink   * pWordSink,
            IPhraseSink * pPhraseSink )
    {

        BEGIN_STDMETHOD(CWrdBrk::BreakText, s_tagWordBreaker);
        Trace(
            elVerbose,
            s_tagWordBreaker,
            ("WordBreaker Break Text, lcid - %x",
            m_lcid));

        if (NULL == pTextSource)
        {
            return E_INVALIDARG;
        }

        Tokenizer t(pTextSource,
                     pWordSink,
                     pPhraseSink,
                     m_lcid,
                     m_fQueryTime,
                     m_ulMaxTokenSize);
        t.BreakText();
        return S_OK;

        END_STDMETHOD(CWrdBrk::BreakText, s_tagWordBreaker);
    }

    STDMETHOD(ComposePhrase)(
            WCHAR const * pwcNoun,
            ULONG         cwcNoun,
            WCHAR const * pwcModifier,
            ULONG         cwcModifier,
            ULONG         ulAttachmentType,
            WCHAR       * pwcPhrase,
            ULONG       * pcwcPhrase )
    {
        BEGIN_STDMETHOD(CWrdBrk::ComposePhrase, s_tagWordBreaker);
        return E_NOTIMPL;
        END_STDMETHOD(CWrdBrk::ComposePhrase, s_tagWordBreaker);
    }

    STDMETHOD(GetLicenseToUse)(
            WCHAR const ** ppwcsLicense )
    {
        BEGIN_STDMETHOD(CWrdBrk::GetLicenseToUse, s_tagWordBreaker);

        if ( NULL == ppwcsLicense )
            return E_INVALIDARG;

        static WCHAR const * wcsCopyright = L"Copyright Microsoft Inc.";
        *ppwcsLicense = wcsCopyright;

        return( S_OK );
        END_STDMETHOD(CWrdBrk::GetLicenseToUse, s_tagWordBreaker);
    }

protected:

    BOOL m_fInitialize;
    BOOL m_fQueryTime;
    ULONG m_ulMaxTokenSize;
    LCID m_lcid;

public:

    CComPtr<IUnknown> m_pUnkMarshaler;

};

/////////////////////////////////////////////////////////////////////////////
// CEngUSWrdBrk
class ATL_NO_VTABLE CEngUSWrdBrk :
    public CBaseWrdBrk<CEngUSWrdBrk, &CLSID_EngUSWrdBrk, IDR_ENGUSWRDBRK, CTokenizer>
{
public:
    CEngUSWrdBrk() :
      CBaseWrdBrk<CEngUSWrdBrk, &CLSID_EngUSWrdBrk, IDR_ENGUSWRDBRK, CTokenizer>
          (MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
           SORT_DEFAULT ))

    {
    }

};

/////////////////////////////////////////////////////////////////////////////
// CEngUKWrdBrk

class ATL_NO_VTABLE CEngUKWrdBrk :
    public CBaseWrdBrk<CEngUKWrdBrk, &CLSID_EngUKWrdBrk, IDR_ENGUKWRDBRK, CTokenizer>
{
public:
    CEngUKWrdBrk() :
      CBaseWrdBrk<CEngUKWrdBrk, &CLSID_EngUKWrdBrk, IDR_ENGUKWRDBRK, CTokenizer>
          (MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_UK),
           SORT_DEFAULT ))

    {
    }

};

/////////////////////////////////////////////////////////////////////////////
// CFrnFrnWrdBrk

class ATL_NO_VTABLE CFrnFrnWrdBrk :
    public CBaseWrdBrk<CFrnFrnWrdBrk, &CLSID_FrnFrnWrdBrk, IDR_FRNFRNWRDBRK, CFrenchTokenizer>
{
public:
    CFrnFrnWrdBrk() :
      CBaseWrdBrk<CFrnFrnWrdBrk, &CLSID_FrnFrnWrdBrk, IDR_FRNFRNWRDBRK, CFrenchTokenizer>
          (MAKELCID(MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH),
           SORT_DEFAULT ))

    {
    }

};


/////////////////////////////////////////////////////////////////////////////
// CItlItlWrdBrk

class ATL_NO_VTABLE CItlItlWrdBrk :
    public CBaseWrdBrk<CItlItlWrdBrk, &CLSID_ItlItlWrdBrk, IDR_ITLITLWRDBRK, CTokenizer>
{
public:
    CItlItlWrdBrk() :
      CBaseWrdBrk<CItlItlWrdBrk, &CLSID_ItlItlWrdBrk, IDR_ITLITLWRDBRK, CTokenizer>
          (MAKELCID(MAKELANGID(LANG_ITALIAN, SUBLANG_ITALIAN),
           SORT_DEFAULT ))

    {
    }

};

/////////////////////////////////////////////////////////////////////////////
// CSpnMdrWrdBrk

class ATL_NO_VTABLE CSpnMdrWrdBrk :
    public CBaseWrdBrk<CSpnMdrWrdBrk, &CLSID_SpnMdrWrdBrk, IDR_SPNMDRWRDBRK, CSpanishTokenizer>
{
public:
    CSpnMdrWrdBrk() :
      CBaseWrdBrk<CSpnMdrWrdBrk, &CLSID_SpnMdrWrdBrk, IDR_SPNMDRWRDBRK, CSpanishTokenizer>
          (MAKELCID(MAKELANGID(LANG_SPANISH , SUBLANG_SPANISH_MODERN),
           SORT_DEFAULT ))

    {
    }

};


#endif //__WRDBRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\tokenizer.h ===
////////////////////////////////////////////////////////////////////////////////
//
//  Filename :  Tokenizer.h
//  Purpose  :  Tokenizer declerations
//
//  Project  :  WordBreakers
//  Component:  English word breaker
//
//  Author   :  yairh
//
//  Log:
//
//      Jan 06 2000 yairh creation
//      Apr 05 2000 dovh - Fixed two problematic debug / tracer buffer size
//          problems.  (Fix Bug 15449).
//      May 07 2000 dovh - USE_WS_SENTINEL algorithm in BreakText
//      Nov 11 2000 dovh - Special underscore treatment
//          Added inline support routines (FindLeftmostUnderscore etc.)
//
////////////////////////////////////////////////////////////////////////////////

#ifndef _TOKENIZER_H_
#define _TOKENIZER_H_

#include "tracer.h"
#include "PropArray.h"
#include "Query.h"
#include "stdafx.h"
#include "cierror.h"
#include "LangSupport.h"
#include "Formats.h"

#define TOKENIZER_MAXBUFFERLIMIT 1024 // max size of a token is 1024 chars

DECLARE_TAG(s_tagTokenizer, "Tokenizer");
DECLARE_TAG(s_tagTokenizerOutput, "Tokenizer Output");
DECLARE_TAG(s_tagTokenizerTrace, "Tokenizer Trace");
DECLARE_TAG(s_tagTokenizerDecision, "Tokenizer Decision");
DECLARE_TAG(s_tagTokenizerSuspect, "Tokenizer Suspect");

#if defined(DEBUG)
///////////////////////////////////////////////////////////////////////////////
// Class CTraceWordSink
///////////////////////////////////////////////////////////////////////////////
class CTraceWordSink : public IWordSink
{
public:
    CTraceWordSink(IWordSink* p) : m_apWordSink(p)
    {
    }

    ULONG __stdcall AddRef()
    {
        return 1;
    }

    ULONG __stdcall Release()
    {
        return 0;
    }

    STDMETHOD(QueryInterface)(
        IN  REFIID  riid,
        IN  void    **ppvObject)
    {
        Assert(false);
        return E_FAIL;
    }

    STDMETHOD(PutWord)(
                ULONG cwc,
                WCHAR const* pwcInBuf,
                ULONG cwcSrcLen,
                ULONG cwcSrcPos)
    {
        Assert(cwc < TOKENIZER_MAXBUFFERLIMIT + 10);
#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
        if (CheckTraceRestrictions(elVerbose, s_tagTokenizerOutput))
        {
            Trace(
                elVerbose,
                s_tagTokenizerOutput,
                ("PutWord: %*.*S, %d, %d, %d", 
                cwc,
                cwc,
                pwcInBuf,
                cwc, 
                cwcSrcLen, 
                cwcSrcPos));
        }
#endif

        return m_apWordSink->PutWord(cwc, pwcInBuf, cwcSrcLen, cwcSrcPos);
    }

    STDMETHOD(PutAltWord)(
                ULONG cwc,
                WCHAR const* pwcInBuf,
                ULONG cwcSrcLen,
                ULONG cwcSrcPos)
    {
        Assert(cwc < TOKENIZER_MAXBUFFERLIMIT + 10);
#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
        if (CheckTraceRestrictions(elVerbose, s_tagTokenizerOutput))
        {
            Trace(
                elVerbose,
                s_tagTokenizerOutput,
                ("PutAltWord: %*.*S, %d, %d, %d", 
                cwc,
                cwc,
                pwcInBuf,
                cwc, 
                cwcSrcLen, 
                cwcSrcPos));
        }
#endif
        return m_apWordSink->PutAltWord(cwc, pwcInBuf, cwcSrcLen, cwcSrcPos);
    }

    STDMETHOD(StartAltPhrase)()
    {
        Trace(
            elVerbose,
            s_tagTokenizerOutput,
            ("StartAltPhrase"));

        return m_apWordSink->StartAltPhrase();
    }

    STDMETHOD(EndAltPhrase)()
    {
        Trace(
            elVerbose,
            s_tagTokenizerOutput,
            ("EndAltPhrase"));

        return m_apWordSink->EndAltPhrase();
    }

    STDMETHOD(PutBreak)(WORDREP_BREAK_TYPE breakType)
    {
        WCHAR* p;
#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)
        if (CheckTraceRestrictions(elVerbose, s_tagTokenizerOutput))
        {
            switch (breakType)
            {
            case WORDREP_BREAK_EOW:
                p = L"WORDREP_BREAK_EOW";
                break;
            case WORDREP_BREAK_EOS:
                p = L"WORDREP_BREAK_EOS";
                break;
            case WORDREP_BREAK_EOP:
                p = L"WORDREP_BREAK_EOP";
                break;
            case WORDREP_BREAK_EOC:
                p = L"WORDREP_BREAK_EOC";
                break;
            default:
                p = L"Unknown break type";
            }
            Trace(
                elVerbose,
                s_tagTokenizerOutput,
                ("PutBreak %S", p));
        }
#endif
        return m_apWordSink->PutBreak(breakType);
    }

    CTraceWordSink* operator ->()
    {
        return this;
    }
private:
    CComPtr<IWordSink> m_apWordSink;
};
#endif

///////////////////////////////////////////////////////////////////////////////
// Class CTokenState
///////////////////////////////////////////////////////////////////////////////

class CTokenState
{
public:
    //
    // methods
    //

    CTokenState();
    CTokenState(CTokenState& s);

    CTokenState& operator = (CTokenState& S);

    void Clear(ULONG ulEnd);

public:
    //
    // members
    //

    ULONG m_ulStart;
    ULONG m_ulEnd;
    CPropFlag m_Properties;
    WCHAR* m_pwcsToken;
};

inline CTokenState::CTokenState() : m_ulStart(0), m_ulEnd(0)
{
}

inline CTokenState::CTokenState(CTokenState& s) :
    m_ulStart(s.m_ulStart),
    m_ulEnd(s.m_ulEnd),
    m_pwcsToken(s.m_pwcsToken),
    m_Properties(s.m_Properties)
{
}

inline CTokenState& CTokenState::operator = (CTokenState& S)
{
    m_ulStart = S.m_ulStart;
    m_ulEnd = S.m_ulEnd;
    m_Properties = S.m_Properties;
    m_pwcsToken = S.m_pwcsToken;

    return *this;
}

inline void CTokenState::Clear(ULONG ulEnd)
{
    m_ulStart = 0;
    m_ulEnd = ulEnd;
    m_Properties.Clear();
    m_pwcsToken = NULL;
}


///////////////////////////////////////////////////////////////////////////////
// Class CToken
///////////////////////////////////////////////////////////////////////////////

class CToken
{
public:
    //
    // methods
    //

    CToken(ULONG ulMaxTokenSize);

    bool IsNotEmpty();
    void Clear();
    bool IsFull();
    void MarkEndToken(ULONG ulCurPosInTxtSourceBuffer);
    ULONG RemoveHeadPunct(CPropFlag& PunctProperties, CTokenState& State);
    ULONG RemoveTailPunct(CPropFlag& PunctProperties, CTokenState& State);
    void ComputeStateProperties(CTokenState& State);
    ULONG CalculateStateOffsetInTxtSourceBuffer(CTokenState& State);

    ULONG FindLeftmostUnderscore(CTokenState& State);
    ULONG FindRightmostUnderscore(CTokenState& State);

public:
    //
    // members
    //
    ULONG m_ulBufPos;
    bool m_fHasEos;
    ULONG m_ulOffsetInTxtSourceBuffer;

    ULONG m_ulMaxTokenSize;

    CTokenState m_State;

    WCHAR m_awchBuf[TOKENIZER_MAXBUFFERLIMIT + 1];

};

inline CToken::CToken(ULONG ulMaxTokenSize) :
    m_ulBufPos(0),
    m_fHasEos(false),
    m_ulOffsetInTxtSourceBuffer(0),
    m_ulMaxTokenSize(ulMaxTokenSize)
{
    m_awchBuf[0] = L'\0';
}

inline bool CToken::IsNotEmpty()
{
    return (m_ulBufPos > 0);
}

inline void CToken::Clear()
{
    m_ulBufPos = 0;
    m_awchBuf[0] = L'\0';
    m_State.Clear(0);
    m_fHasEos = false;
    m_ulOffsetInTxtSourceBuffer = 0;
}


inline bool CToken::IsFull()
{
    return (m_ulBufPos == m_ulMaxTokenSize);
}

inline void CToken::MarkEndToken(ULONG ulCurPosInTxtSourceBuffer)
{
    Assert(m_ulBufPos < m_ulMaxTokenSize + 1);
    m_awchBuf[m_ulBufPos] = L'\0';
    m_State.m_pwcsToken = m_awchBuf;
    m_State.m_ulStart = 0;
    m_State.m_ulEnd = m_ulBufPos;


    if (TEST_PROP(m_State.m_Properties, PROP_EOS) &&
        (m_ulBufPos < m_ulMaxTokenSize))
    {
        ULONG ulCur = m_State.m_ulEnd - 1;

        while (TEST_PROP(GET_PROP(m_awchBuf[ulCur]), EOS_SUFFIX))
        {
            ulCur--;
        }

        if (IS_EOS(m_awchBuf[ulCur]))
        {
            m_fHasEos = true;
        }
    }

    //
    // BUGBUG need to enalble the assert
    //

    // Assert(ulCurPosInTxtSourceBuffer > m_ulBufPos);

    m_ulOffsetInTxtSourceBuffer = ulCurPosInTxtSourceBuffer - m_ulBufPos;
}

inline ULONG CToken::CalculateStateOffsetInTxtSourceBuffer(CTokenState& State)
{
    ULONG ulOffset =
        m_ulOffsetInTxtSourceBuffer +
        (State.m_pwcsToken - m_awchBuf) +
        State.m_ulStart;

    return ulOffset;
}

inline ULONG CToken::RemoveHeadPunct(CPropFlag& PunctProperties, CTokenState& State)
{
    Assert(m_State.m_ulStart <= State.m_ulStart);
    Assert(State.m_ulStart <= State.m_ulEnd);
    Assert(State.m_ulEnd <= m_State.m_ulEnd);

    for (ULONG ul = State.m_ulStart; ul < State.m_ulEnd; ul++)
    {
        if (!TEST_PROP1(GET_PROP(State.m_pwcsToken[ul]), PunctProperties) )
        {
            break;
        }
    }
    State.m_ulStart = ul;

    //
    // return num of characters removed
    //
    return ul;
}

inline ULONG CToken::RemoveTailPunct(CPropFlag& PunctProperties, CTokenState& State)
{
    Assert(m_State.m_ulStart <= State.m_ulStart);
    Assert(State.m_ulStart <= State.m_ulEnd);
    Assert(State.m_ulEnd <= m_State.m_ulEnd);

    for (ULONG ul = State.m_ulEnd; ul > State.m_ulStart; ul--)
    {
        if (!TEST_PROP1(GET_PROP(State.m_pwcsToken[ul - 1]), PunctProperties) )
        {
            break;
        }
    }

    ULONG ulNumOfRemovedChars = State.m_ulEnd - ul;
    State.m_ulEnd = ul;

    return ulNumOfRemovedChars;
}


inline void CToken::ComputeStateProperties(CTokenState& State)
{
    Assert(m_State.m_ulStart <= State.m_ulStart);
    Assert(State.m_ulStart <= State.m_ulEnd);
    Assert(State.m_ulEnd <= m_State.m_ulEnd);

    State.m_Properties.Clear();

    for (ULONG ul = State.m_ulStart; ul < State.m_ulEnd; ul++)
    {
        State.m_Properties |= GET_PROP(State.m_pwcsToken[ul]);
    }
}

////////////////////////////////////////////////////////////////////////////////
//
//  Support routines for UNDERSCORE '_' treatment.
//
//  Current algorithm has the following behavior for tokens containing
//  ALPHANUMERIC characters and UNDERSCORES:
//
//  1.  Single underscores and consecutive underscore sequence surrounded by
//      alphanumeric characters (IE underscores buried within words) are
//      treated as alphanumeric characters, and do not break words, or get
//      omitted.  Examples: Foo_Bar => Foo_Bar, and X___Y => X___Y
//
//  2.  An underscore / underscore sequence tacked to the right (left) end
//      end of an alphanumeric (+ embedded underscores) token, will be part of
//      the token, as long as the sequence is attacked only to one side of the
//      alphanumeric token.  If there are BOTH header and trailer consecutive
//      underscore sequences, both header & trailer sequence will be omitted.
//      Examples: __Foo_Bar => __Foo_Bar , alpha_beta_ => alpha_beta_ ,
//      __HEADERFILE__ => __HEADERFILE__ , __MY_FILE_H__ => MY_FILE_H
//
//  3.  Caveat: Note that other than the two rules stated above underscores are
//      NOT treated as ALPHANUMERIC characters. he behavior on a mixed sequence
//      of underscores, and other  non-alphanumeric characters is undefined!
//
////////////////////////////////////////////////////////////////////////////////

//
//  Assumes: on entry State.m_ulStart is the first alphanumeric in token
//  returns: num of underscores scanned
//
inline ULONG
CToken::FindLeftmostUnderscore(CTokenState& State)
{
    Assert(m_State.m_ulStart < State.m_ulStart);
    Assert(State.m_ulStart <= State.m_ulEnd);
    Assert(State.m_ulEnd <= m_State.m_ulEnd);
    Assert( TEST_PROP(GET_PROP(State.m_pwcsToken[State.m_ulStart-1]), PROP_UNDERSCORE) );

    ULONG ulNumUnderscores = 0;

    for (ULONG ul = State.m_ulStart;
        (ul > m_State.m_ulStart) &&
            (TEST_PROP(GET_PROP(State.m_pwcsToken[ul-1]), PROP_UNDERSCORE) );
        ul--)
        ;

    ulNumUnderscores = State.m_ulStart - ul;

    State.m_ulStart = ul;

    //
    // return num of underscores scanned
    //
    return (ulNumUnderscores);

} // CToken::FindLeftmostUnderscore

//
//  Assumes: on entry State.m_ulEnd is the last alphanumeric in token
//  returns: num of underscores scanned
//
inline ULONG
CToken::FindRightmostUnderscore(CTokenState& State)
{
    Assert(m_State.m_ulStart <= State.m_ulStart);
    Assert(State.m_ulStart <= State.m_ulEnd);
    Assert(State.m_ulEnd < m_State.m_ulEnd);
    Assert( TEST_PROP(GET_PROP(State.m_pwcsToken[State.m_ulEnd]), PROP_UNDERSCORE) );

    ULONG ulNumUnderscores = 0;

    for (ULONG ul = State.m_ulEnd;
        (ul < m_State.m_ulEnd) &&
            (TEST_PROP(GET_PROP(State.m_pwcsToken[ul]), PROP_UNDERSCORE) );
        ul++)
        ;

    ulNumUnderscores = ul - State.m_ulEnd;

    State.m_ulEnd = ul;

    //
    // return num of underscores scanned
    //
    return (ulNumUnderscores);

} // CToken::FindRightmostUnderscore


///////////////////////////////////////////////////////////////////////////////
// Class CTokenizer
///////////////////////////////////////////////////////////////////////////////

class CTokenizer
{
public:

    CTokenizer(
        TEXT_SOURCE* pTxtSource,
        IWordSink   * pWordSink,
        IPhraseSink * pPhraseSink,
        LCID lcid,
        BOOL bQueryTime,
        ULONG ulMaxTokenSize);


    // destructor frees the passed buffer, if it exists
    virtual ~CTokenizer(void)
    {
    }

    void BreakText();

protected:

    //
    // methods
    //

    void ProcessToken();
    void ProcessTokenInternal();
    void BreakCompundString(CTokenState& State, CPropFlag& prop);

    HRESULT FillBuffer();
    void CalculateUpdateEndOfBuffer();

    bool CheckAndCreateNumber(
                         WCHAR* pwcsStr,
                         ULONG ulLen,
                         WCHAR* pwcsOut,
                         ULONG* pulOffsetToTxt,
                         ULONG* pulOutLen);

    int CheckAndCreateNumber(
                         WCHAR* pwcsStr,
                         ULONG ulLen,
                         WCHAR wchSDecimal,
                         WCHAR wchSThousand,
                         WCHAR* pwcsOut,
                         ULONG* pulOffsetToTxt,
                         ULONG* pulOutLen);

    short ConvertHexCharToNumber(WCHAR wch);
    void GetValuesFromDateString(
        CDateTerm* pFormat,
        WCHAR* pwcsDate,
        LONG* plD_M1,     // we can't tell in this stage whether this is a Day or a month.
        LONG* plD_M2,
        LONG* plYear);

    void GetValuesFromTimeString(
        CTimeTerm* pFormat,
        WCHAR* pwcsTime,
        LONG* plHour,
        LONG* plMin,
        LONG* plSec,
        TimeFormat* pAmPm);

    LONG ConvertCharToDigit(WCHAR wch);
#ifdef DEBUG
    void TraceToken();
#endif DEBUG

    bool VerifyAlphaUrl();
    bool VerifyWwwUrl();
    bool VerifyAcronym();
    bool VerifyAbbreviation();
    bool VerifySpecialAbbreviation();
    bool VerifyHyphenation();
    bool VerifyParens();
    const CCliticsTerm* VerifyClitics(CTokenState& State);
    bool VerifyNumber(CTokenState& State);
    bool VerifyNumberOrTimeOrDate();
    bool VerifyTime(CTokenState& State);
    bool VerifyDate(CTokenState& State);
    bool VerifyCurrency();
    bool VerifyMisc();
    bool VerifyCommersialSign();

    void ProcessDefault();

    ULONG
    AddBackUnderscores(
        IN CTokenState& State,
        IN bool hasFrontUnderscore,
        IN bool hasBackUnderscore
        );
    bool CheckAndRemoveOneSidedUnderscores(CTokenState& State);

    void OutputUrl(
                CTokenState& State);
    void OutputAcronym(
                CTokenState& State,
                const CCliticsTerm* pCliticsTerm);
    void OutputAbbreviation(
                CTokenState& State);
    void OutputSpecialAbbreviation(
                CTokenState& State,
                CAbbTerm* pTerm,
                const CCliticsTerm* pCliticsTerm);
    virtual void OutputHyphenation(
                CTokenState& State,
                const CCliticsTerm* pCliticsTerm);
    void OutputParens(
                CTokenState& State);
    void OutputNumbers(
                CTokenState& State,
                ULONG ulLen,
                WCHAR* pwcsNumber,
                const CCliticsTerm* pCliticsTerm);
    void OutputTime(
                WCHAR* pwcsTime,
                CTokenState& State);
    void OutputDate(
                WCHAR* pwcsDate1,
                WCHAR* pwcsDate2,
                CTokenState& State);
    virtual void OutputSimpleToken(
                CTokenState& State,
                const CCliticsTerm* pTerm);
    void OutputCurrency(
                ULONG ulLen,
                WCHAR* pwcsCurrency,
                CTokenState& State,
                const CCliticsTerm* pTerm);
    void OutputMisc(
                CTokenState& State,
                bool bPatternContainOnlyUpperCase,
                ULONG ulSuffixSize,
                const CCliticsTerm* pCliticsTerm);
    void OutputCommersialSignToken(CTokenState& State);

    //
    // members
    //

    LCID m_Lcid;
    CAutoClassPointer<CLangSupport> m_apLangSupport;

    CToken* m_pCurToken;
    CToken m_Token;

#if defined(DEBUG)
    CTraceWordSink m_apWordSink;
#else
    CComPtr<IWordSink> m_apWordSink;
#endif
    CComPtr<IPhraseSink> m_apPhraseSink;
    TEXT_SOURCE* m_pTxtSource;

    BOOL m_bQueryTime;

    ULONG m_ulUpdatedEndOfBuffer;
    bool m_bNoMoreTxt;

    //
    //  All Chunks in buffer have a white space
    //
    bool m_bWhiteSpaceGuarranteed;
    ULONG m_ulMaxTokenSize;

};

inline HRESULT CTokenizer::FillBuffer()
{
    Trace(
        elVerbose,
        s_tagTokenizer,
        ("WBreakGetNextChar: Filling the buffer"));

    HRESULT hr;

    if (!m_bNoMoreTxt)
    {
        do
        {
            //
            // this loop usually performs only one rotations. we use it to solve the
            // problem when the user return 0 characters and a success return code.
            // the following code assumes that in case you get a success return code then
            // the buffer is not empty.
            //

            hr = m_pTxtSource->pfnFillTextBuffer(m_pTxtSource);
        } while ((m_pTxtSource->iEnd <= m_pTxtSource->iCur) && SUCCEEDED(hr));

        if ( FAILED(hr))
        {
             m_bNoMoreTxt = true;
        }
    }

    if (m_bNoMoreTxt && m_pTxtSource->iCur >= m_pTxtSource->iEnd)
    {
        //
        // we reached the end of the buffer.
        //
        return WBREAK_E_END_OF_TEXT;
    }

    CalculateUpdateEndOfBuffer();

    return S_OK;
}

inline void CTokenizer::CalculateUpdateEndOfBuffer()
{
    //
    // m_ulUpdatedEndOfBuffer is a marker for the last character that we can read
    // from the current buffer before and additional call to fill buffer is needed.
    // we use this marker to avoid terms spitted between two consecutive buffers.
    // in order to achieve the above m_ulUpdatedEndOfBuffer will point to a breaker
    // character. (the only exception to that is when we have a very long term that does
    // not contains breaker characters).
    //

    //
    // we split the buffer into chunks of TOKENIZER_MAXBUFFERLIMIT size. in each
    // chunk we make sure that there is a breaker.
    //

    ULONG ulStartChunk = m_pTxtSource->iCur;
    ULONG ulEndChunk ;
    bool fLastRound = false;

    Assert(m_pTxtSource->iEnd > m_pTxtSource->iCur);

    ulEndChunk = m_pTxtSource->iCur + m_ulMaxTokenSize > (m_pTxtSource->iEnd - 1) ?
            (m_pTxtSource->iEnd - 1) : m_pTxtSource->iCur + m_ulMaxTokenSize;
    ULONG ulCur;
    ULONG ulBreakerMarker = 0;
    m_bWhiteSpaceGuarranteed = false;

    while(true)
    {
        ulCur = ulEndChunk;

        //
        // per each chunk we go backward and try to find a WS.
        //
        while ((ulCur > ulStartChunk) &&
               (!IS_WS(m_pTxtSource->awcBuffer[ulCur])))
        {
            ulCur--;
        }

        if (ulCur == ulStartChunk)
        {

            //
            // the last chunk that we checked did not contain any WS
            //

            if (m_ulMaxTokenSize == (ulEndChunk - ulStartChunk))
            {
                //
                // full buffer case. we look for a default breaker.
                //

                ulCur = ulEndChunk;

                while ( (ulCur > ulStartChunk) &&
                        !IS_BREAKER( m_pTxtSource->awcBuffer[ulCur] )
                      )
                {
                    ulCur--;
                }

                //
                // if we found a breaker then ulBreakerMarker will set to it else
                // the term does not contain any breakers and we set the ulBreakerMarker
                // to the end of the term. this is the only case that we spilt terms.
                //
                ulBreakerMarker = ulCur > ulStartChunk ? ulCur : ulEndChunk;
            }
            else
            {
                if (ulStartChunk > m_pTxtSource->iCur)
                {
                    //
                    // case we had a previous chunk. in this case ulStartChunk points to
                    // a breaker
                    //

                    //
                    // ulStart points to the WS from the previous chunk.
                    //
                    ulBreakerMarker = ulStartChunk;
                }
                else
                {
                    ulBreakerMarker = m_pTxtSource->iEnd;
                }
            }

            break;
        }

        if (fLastRound)
        {
            //
            // ulCur points to a WS
            //
            ulBreakerMarker = ulCur + 1;
            m_bWhiteSpaceGuarranteed = true;

            break;
        }

        //
        // move to the next chunk
        //
        ulStartChunk = ulCur + 1; // ulStarChunk will points to a breaker
        if (ulStartChunk + m_ulMaxTokenSize < (m_pTxtSource->iEnd - 1))
        {
            ulEndChunk = ulStartChunk + m_ulMaxTokenSize;

        }
        else
        {
            ulEndChunk = m_pTxtSource->iEnd - 1;
            fLastRound = true;
        }
    }

    Assert(ulBreakerMarker <= m_pTxtSource->iEnd);
    m_ulUpdatedEndOfBuffer = ulBreakerMarker;

}


inline short CTokenizer::ConvertHexCharToNumber(WCHAR wch)
{
    //
    // assumes wch is a valid HEX character
    //
    Assert(wch >= L'0');

    if (wch <= L'9')
    {
        return (wch - L'0');
    }
    else if (wch <= L'F')
    {
        Assert(wch >= L'A');
        return (wch - L'A' + 10);
    }
    else if (wch <= L'f')
    {
        Assert(wch >= L'a');
        return (wch - L'a' + 10);
    }
    else if (wch <= 0xFF19)
    {
        Assert(wch >= 0xFF10);
        return (wch - 0xFF10);
    }
    else if (wch <= 0xFF26)
    {
        Assert(wch >= 0xFF21);
        return (wch - 0xFF21 + 10);
    }
    else
    {
        Assert((wch >= 0xFF41) && (wch <= 0xFF46));
        return (wch - 0xFF41 + 10);
    }

}

inline LONG CTokenizer::ConvertCharToDigit(WCHAR wch)
{
    Assert((wch >= L'0' && wch <= L'9') || ((wch >= 0xFF10) && (wch <= 0xFF19)));
    if (wch <= L'9')
    {
        return (wch - L'0');
    }

    return (wch - 0xFF10); // Full width characters.
}

#endif _TOKENIZER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\autoptr.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  AutoPtr.h
//      Purpose  :  To supply auto pointers of different kinds.
//                      CAutoPointer<T, Deletor> Generic pointer needs a deletor
//                                                 class to instaciate.
//                      CAutoMallocPonter<T>     A malloc allocated pointer.
//                      CAutoClassPointer<T>     A "new" allocated pointer
//                      CAutoArrayPointer<T>     A "new[]" allocated pointer
//                      CAutoOlePointer<T>       A pointer that should be
//                                                 "Release()".
//
//      Project  :  PersistentQuery
//      Component:  Common
//
//      Author   :  urib
//
//      Log:
//
//          Jan 15 1997 urib  Creation
//          Jan 19 1997 urib  Fix Ole pointer. Enable instanciation without
//                              ownership
//          Jun  9 1997 urib  Better OlePointer. Some safety fixes.
//          Nov 17 1997 urib  Add ole task pointer.
//          Jun 30 1998 dovh  Add Assert to CAutoPointer operator=
//          Feb 25 1999 urib  Add smart pointer typedef macro.
//          Jun 23 1999 urib  Add equality op.
//          Aug  5 1999 urib  Fix a memory leak bug in the assignment operator
//                              of CAutoPointer. Add assignment operation
//                              creation macro.
//          Dec  1 1999 urib  Change return type from int to bool in IsValid.
//
////////////////////////////////////////////////////////////////////////////////

#ifndef AUTOPTR_H
#define AUTOPTR_H

#include "tracer.h"
#include <comdef.h>

#pragma once

////////////////////////////////////////////////////////////////////////////////
//
//  return type for 'identifier::operator ->'is not a UDT or reference to a UDT.
//  Will produce errors if applied using infix notation
//
////////////////////////////////////////////////////////////////////////////////
#pragma warning(disable: 4284 4786)

template<class T, class Deletor>
class CAutoPointer
{
    typedef Deletor m_Deletor;
    typedef T       m_PointerType;

  public:
    // Constructors
    CAutoPointer(T* pt = NULL, BOOL fOwnMemory = TRUE)
        :m_fIOwnTheMemory(fOwnMemory && (pt != NULL))
        ,m_ptThePointer(pt) {}

    CAutoPointer(const CAutoPointer<T, Deletor>& acp)
    {
        m_fIOwnTheMemory = acp.m_fIOwnTheMemory;
        m_ptThePointer = acp.Detach();
    }

    // Assignemnt operation.
    CAutoPointer<T, Deletor>&
    operator=(const CAutoPointer<T, Deletor>& acp)
    {
        if (m_ptThePointer != acp.m_ptThePointer)
        {
            if (m_fIOwnTheMemory)
                Deletor::DeleteOperation(m_ptThePointer);
            m_fIOwnTheMemory = acp.m_fIOwnTheMemory;
            m_ptThePointer = acp.Detach();
        }
        else
        {
            Assert( (!m_fIOwnTheMemory) || acp.m_fIOwnTheMemory );
            //  Note: R.H.S "inherits" memory oenership from L.H.S.,
            //  and L.H.S. ownership is cancelled by Detach!

            bool ftmp = acp.m_fIOwnTheMemory;
            acp.Detach();
            m_fIOwnTheMemory = ftmp;
        }

        return (*this);
    }

    CAutoPointer<T, Deletor>&
    operator=(int null)
    {
        Assert(null == 0);

        return operator=(reinterpret_cast<T*>(NULL));
    }

    bool
    operator==(const CAutoPointer<T, Deletor>& acp)
    {
        return m_ptThePointer == acp.m_ptThePointer;
    }


    // If it is our memory delete the pointer.
    ~CAutoPointer()
    {
        if(m_fIOwnTheMemory)
            Deletor::DeleteOperation(m_ptThePointer);
    }

    // Return the pointer and mark that it is no longer our memory.
    T*
    Detach() const
    {
        // This is to escape the const restriction. We don't change the pointer
        //   but we still do the marking.
        ((CAutoPointer<T, Deletor>*)this)->m_fIOwnTheMemory = FALSE;
        return (m_ptThePointer);
    }

    // Return the actual pointer if you want to use it someplace
    T*
    Get() const
    {
        return m_ptThePointer;
    }

    // Return if the pointer is valid.
    bool
    IsValid()
    {
        return !!m_ptThePointer;
    }


    // Indirection
    T&
    operator *() const
    {
        return * Get();
    }

    // Dereference
    T*
    operator ->() const
    {
        return Get();
    }

  protected:
    // The pointer to keep.
    T*      m_ptThePointer;

    // Is the memory ours?
    bool    m_fIOwnTheMemory;

};

#define CONSTRUCTORS(AutoPointer)                                       \
                                                                        \
AutoPointer(m_PointerType* pt = NULL,                                   \
            BOOL fOwnMemory = TRUE)                                     \
    :CAutoPointer<m_PointerType, m_Deletor>(pt, fOwnMemory)             \
{                                                                       \
}                                                                       \
                                                                        \
AutoPointer(const AutoPointer<m_PointerType>& aop)                      \
    :CAutoPointer<m_PointerType, m_Deletor>(aop)                        \
{                                                                       \
}                                                                       \


#define ASSIGNMENT_OPERATORS(AutoPointer)                               \
                                                                        \
AutoPointer<m_PointerType>&                                             \
operator=(const AutoPointer<m_PointerType>& acp)                        \
{                                                                       \
    CAutoPointer<m_PointerType, m_Deletor>::operator=(acp);             \
                                                                        \
    return *this;                                                       \
}                                                                       \
                                                                        \
AutoPointer<m_PointerType>&                                             \
operator=(int null)                                                     \
{                                                                       \
    CAutoPointer<m_PointerType, m_Deletor>::operator=(null);            \
                                                                        \
    return *this;                                                       \
}



////////////////////////////////////////////////////////////////////////////////
//
//  CAutoClassPointer class definition
//
////////////////////////////////////////////////////////////////////////////////
template <class T>
class CClassDeletor
{
  public:
    static
    void
    DeleteOperation(T* pt)
    {
        if (pt)
            delete pt;
    }
};

template<class T>
class CAutoClassPointer : public CAutoPointer<T, CClassDeletor<T> >
{
  public:
    CONSTRUCTORS(CAutoClassPointer);
    ASSIGNMENT_OPERATORS(CAutoClassPointer);
};


////////////////////////////////////////////////////////////////////////////////
//
//  CAutoOlePointer class definition
//
////////////////////////////////////////////////////////////////////////////////
template <class T>
class COleDeletor
{
  public:
    static
    void
    DeleteOperation(T* pt)
    {
        if (pt)
            pt->Release();
    }
};

template<class T>
class CAutoOlePointer : public CAutoPointer<T, COleDeletor<T> >
{
public:
    CONSTRUCTORS(CAutoOlePointer);
    ASSIGNMENT_OPERATORS(CAutoOlePointer);

public:
    T** operator &()
    {
        m_fIOwnTheMemory = TRUE;
        return &m_ptThePointer;
    }
};

////////////////////////////////////////////////////////////////////////////////
//
//  CAutoTaskPointer class definition
//
////////////////////////////////////////////////////////////////////////////////
template <class T>
class CTaskDeletor
{
  public:
    static
    void
    DeleteOperation(T* pt)
    {
        if (pt)
            CoTaskMemFree(pt);
    }
};

template<class T>
class CAutoTaskPointer : public CAutoPointer<T, CTaskDeletor<T> >
{
public:
    CONSTRUCTORS(CAutoTaskPointer);
    ASSIGNMENT_OPERATORS(CAutoTaskPointer);

public:
    T** operator &()
    {
        m_fIOwnTheMemory = TRUE;
        return &m_ptThePointer;
    }
};

////////////////////////////////////////////////////////////////////////////////
//
//  CAutoMallocPointer class definition
//
////////////////////////////////////////////////////////////////////////////////
template <class T>
class CMallocDeletor
{
  public:
    static
    void
    DeleteOperation(T* pt)
    {
        if (pt)
            free(pt);
    }
};

template<class T>
class CAutoMallocPointer : public CAutoPointer<T, CMallocDeletor<T> >
{
  public:

      CONSTRUCTORS(CAutoMallocPointer);
      ASSIGNMENT_OPERATORS(CAutoMallocPointer);

  public:

    T& operator[](size_t n)
    {
        return *(Get() + n);
    }
};

////////////////////////////////////////////////////////////////////////////////
//
//  CAutoArrayPointer class definition
//
////////////////////////////////////////////////////////////////////////////////
template <class T>
class CArrayDeletor
{
  public:
    static
    void
    DeleteOperation(T* pt)
    {
        if (pt)
            delete[] pt;
    }
};

template<class T>
class CAutoArrayPointer : public CAutoPointer<T, CArrayDeletor<T> >
{
public:
    CONSTRUCTORS(CAutoArrayPointer);
    ASSIGNMENT_OPERATORS(CAutoArrayPointer);

public:

    T& operator[](size_t n)
    {
        return *(Get() + n);
    }
};



//
//  Simple macro to define the standard COM pointer.
//
#define PQ_COM_SMARTPTR_TYPEDEF(Interface)      \
    _COM_SMARTPTR_TYPEDEF(Interface, IID_##Interface)

#endif /* AUTOPTR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\comdefs.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  ComDefs.H
//      Purpose  :  Filtering Engine / Service common definitions including
//                  FLAGS, STATUS, and CONSTANT MACROS
//
//      Project  :  PQS
//      Component:  Filter
//
//      Author   :  dovh
//
//      Log      :  Aug-05-1995 dovh - Creation
//
//      May-25-1996 - Dov Harel (DovH): Added a few flags & status codes.
//          In particular replaced
//          FTF_STATUS_QUERY_ID_MISMATCH and FTF_STATUS_QUERY_ID_NOT_FOUND by
//          FTF_STATUS_REQUEST_ID_MISMATCH and FTF_STATUS_REQUEST_ID_NOT_FOUND
//          resp.  replaced FTF_FLAG_ACCEPT_ANY_QUERY_ID by
//          FTF_FLAG_ACCEPT_ANY_REQUEST_ID
//      Jun-10-1996 Dov Harel (DovH)
//          Added FTF_FLAG_WRITE_EMPTY_RESULTS_FILE
//      Sep-30-1996 Dov Harel (DovH)
//          Added FTF_FLAG_DUMP_RESTRICTED_SUBSET
//      Dec-11-1996 Dov Harel (DovH)
//          UNICODE Preparation: Convert char to TCHAR
//
//      Feb-18-1997 Dov Harel (DovH) - #define FTF_STATUS_SERVICE_IS_PAUSED ...
//      Nov-30-1997 Dov Harel (DovH) - #define FTF_STATUS_PATTERN_TOO_SHORT ...
//      Jan-26-1998 Uri Barash(UriB) - Move query db name define to Names.h
//      Jan-29-1997 dovh - Add FTF_FLAG_BATCH_FAILED flag.
//      Feb-23-1998 yairh - change all errors to be an HRESULT error
//      Jul-15-1997 dovh - Move #ifdef MINDEX to Diffs.h
//      Nov-12-1998 yairh - add query set defines
//      Jan-05-1999 urib - Move MAX_PATTERN_LENGTH here from mpat.h
//      Mar-02-1999 dovh - Move SET_FE_HANDLE/GET_FE_HANDLE here from Tls.h
//      May-18-1999 urib - Define the UNICODE word breaker character.
//      Feb-22-2000 urib - Move stuff away.
//
////////////////////////////////////////////////////////////////////////////////


#ifndef __FILTER__COMDEFS_H__
#define __FILTER__COMDEFS_H__

//
//  FTF_FLAG_ MACRO DEFINITIONS:
//

#define FTF_FLAG_CASE_INSENSITIVE_FLAG              0X00000001L
#define FTF_FLAG_SUBDIR_SEARCH                      0X00000002L
#define FTF_FLAG_ASYNC_REQUEST                      0X00000004L

#define FTF_FLAG_LOCAL_OPERATION                    0X00000010L
#define FTF_FLAG_DEMO_VIEW                          0X00000020L
#define FTF_FLAG_IGNORE_EXTERNAL_TERMS              0X00000040L
#define FTF_FLAG_RESERVED_07                        0X00000080L

#define FTF_FLAG_ACCEPT_ANY_REQUEST_ID              0X00000200L
#define FTF_FLAG_CHECK_EXP_ID_MATCH                 0X00000400L

#define FTF_FLAG_ADD_EXP_REQUEST                    0X00001000L
#define FTF_FLAG_REMOVE_EXP_REQUEST                 0X00002000L
#define FTF_FLAG_QUERY_MGR_CLIENT                   0X00004000L
#define FTF_FLAG_DOC_MGR_CLIENT                     0X00008000L

#define FTF_FLAG_EMPTY_DEFAULT_NOTIFY_SET           0X00010000L
#define FTF_FLAG_EMPTY_NOTIFY_SET                   0X00020000L
#define FTF_FLAG_WRITE_EMPTY_RESULTS_FILE           0X00040000L
#define FTF_FLAG_BATCH_FAILED                       0X00080000L

//
//  DUMP EXPRESSIONS OPTIONS (REUSED FLAGS)
//

#define FTF_FLAG_CONDENSE_BLANKS                    0X00000001L
#define FTF_FLAG_CONSEQUTIVE_EXP_IDS                0X00000002L
#define FTF_FLAG_RESERVED                           0X00000004L
#define FTF_FLAG_DUMP_RESTRICTED_SUBSET             0X00000008L

//
//  FTF_CONST_ MACRO DEFINITIONS:
//

#define FTF_CONST_MAX_NAME_LENGTH                            64
#define FTF_CONST_SHORT_FILENAME_LENGTH                      16
#define FTF_CONST_MEDIUM_FILENAME_LENGTH                     32
#define FTF_CONST_MAX_FILENAME_LENGTH                       128
#define FTF_CONST_MAX_PATH_LENGTH                           256
#define FTF_CONST_FILENAMES_BUFFER_SIZE                    3072
#define FTF_CONST_MAX_SUBMIT_FILECOUNT                       32
#define FTF_CONST_MAX_SUBMIT_DIRCOUNT                        32
#define FTF_CONST_MAX_REQUESTS_STATUS                       128
#define FTF_CONST_MAX_SUBMIT_EXPCOUNT                        32
#define FTF_CONST_EXPS_BUFFER_SIZE                         3072


//
//  FTF_CONST_SHUTDOWN_ OPTIONS (EXPEDIENCY LEVEL):
//

#define FTF_CONST_SHUTDOWN_ON_EMPTY_QUEUE                     1
#define FTF_CONST_SHUTDOWN_IMMEDIATE                          2


#define MAX_PATTERN_LENGTH                                  1024
#define TEXT_BUFFER_MAX_SIZE        (16384 - MAX_PATTERN_LENGTH)
//
// NOTICE: MAX_PHRASE_LEN >= UNDIRECTED_PROXIMITY_INTERVAL
//

#define MAX_PHRASE_LEN 50
#define UNDIRECTED_PROXIMITY_INTERVAL 50

#if UNDIRECTED_PROXIMITY_INTERVAL > MAX_PHRASE_LEN
#error BUG: MAX_PHRASE_LEN >= UNDIRECTED_PROXIMITY_INTERVAL
#endif

#define PQ_WORD_BREAK                                    0x0001L

typedef enum {
    DICT_SUCCESS,
    DICT_ITEM_ALREADY_PRESENT,
    DICT_ITEM_NOT_FOUND,
    DICT_FIRST_ITEM,
    DICT_LAST_ITEM,
    DICT_EMPTY_DICTIONARY,
    DICT_NULL_ITEM
} DictStatus;

#endif // __FILTER__COMDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\wordbreaker.cpp ===
// WordBreaker.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f WordBreakerps.mk in the project directory.

#include "base.h"
#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "query.h"
#include "WordBreaker.h"

#include "WordBreaker_i.c"
#include "WrdBrk.h"
#include "Tokenizer.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_EngUSWrdBrk, CEngUSWrdBrk)
    OBJECT_ENTRY(CLSID_EngUKWrdBrk, CEngUKWrdBrk)
    OBJECT_ENTRY(CLSID_FrnFrnWrdBrk, CFrnFrnWrdBrk)
    OBJECT_ENTRY(CLSID_ItlItlWrdBrk, CItlItlWrdBrk)
    OBJECT_ENTRY(CLSID_SpnMdrWrdBrk, CSpnMdrWrdBrk)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

void InitializeGlobalData();

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        InitializeGlobalData();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\wbutils.h ===
#ifndef _WB_UTILS_H_
#define _WB_UTILS_H_

#include "excption.h"
#include "regkey.h"

inline WCHAR* CreateFilePath(const WCHAR* pwcsFile)
{
    HMODULE h;

    h = GetModuleHandle(L"LangWrbk.dll");
    if (NULL == h)
    {
        THROW_WIN32ERROR_EXCEPTION(GetLastError());
    }

    CAutoArrayPointer<WCHAR> apwcsPath;
    ULONG ulInitSize = 128;
    ULONG ulPathLen;

    do
    {
        ulInitSize *= 2;
    
        apwcsPath = new WCHAR[ulInitSize + wcslen(pwcsFile) + 1];

        ulPathLen = GetModuleFileName(
                                    h,
                                    apwcsPath.Get(),
                                    ulInitSize);
    } while (ulPathLen >= ulInitSize);

    if (0 == ulPathLen)
    {
        THROW_WIN32ERROR_EXCEPTION(GetLastError());
    }

    while ((ulPathLen > 0) && 
           (apwcsPath.Get()[ulPathLen - 1] != L'\\'))
    {
        ulPathLen--;
    }

    apwcsPath.Get()[ulPathLen] = L'\0';
    wcscat(apwcsPath.Get(), pwcsFile);

    return apwcsPath.Detach();
}


class CWbToUpper
{

public:

    CWbToUpper();

    //
    //  SOME ACCESS FUNCTIONS:
    //
    __forceinline
    static
    WCHAR
    MapToUpper(
        IN WCHAR wc
        )
    {
        extern CWbToUpper g_WbToUpper;
        if (wc < 0x100)
        {
            return g_WbToUpper.m_pwcsCaseMapTable[wc];
        }
        else
        {
            WCHAR wchOut;
            LCMapString( 
                LOCALE_NEUTRAL,
                LCMAP_UPPERCASE,
                &wc,
                1,
                &wchOut,
                1 );
            return wchOut;
        }
    }


public:

    WCHAR m_pwcsCaseMapTable[0x100];

};  // CFE_CWbToUpper

extern CWbToUpper g_WbToUpper;

inline CWbToUpper::CWbToUpper( )
{
    //
    // the code use to use LCMapString (with LANG_NEUTRAL) to initialize the UPPER array.
    // LCMapString behaves weirdly on Greek WIN98 (possibly  a bug)
    //
    
    for (WCHAR wch = 0; wch <= 0xFF; wch++)
    {
        m_pwcsCaseMapTable[wch] = wch;
    }

    for (WCHAR wch = 0x61; wch <= 0x7A; wch++)
    {
        m_pwcsCaseMapTable[wch] = wch - 0x20;
    }

    for (WCHAR wch = 0xE0; wch <= 0xFE; wch++)
    {
        m_pwcsCaseMapTable[wch] = wch - 0x20;
    }

}


#endif // _WB_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\autohndl.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  AutoHndl.h
//      Purpose  :  To automatically close open handles.
//
//      Project  :  FTFS
//      Component:  Common
//
//      Author   :  urib
//
//      Log:
//          Jan 20 1997 urib  Creation
//          Jun 12 1997 urib  Define the BAD_HANDLE macro if needed.
//          Feb 22 2000 urib  fix bug 12038. Assignment doesn't free old handle.
//
////////////////////////////////////////////////////////////////////////////////


#ifndef AUTOHNDL_H
#define AUTOHNDL_H

#ifndef BAD_HANDLE
#define BAD_HANDLE(h)       ((0 == ((HANDLE)h))||   \
                             (INVALID_HANDLE_VALUE == ((HANDLE)h)))
#endif

////////////////////////////////////////////////////////////////////////////////
//
//  CAutoHandle class definition
//
////////////////////////////////////////////////////////////////////////////////

class CAutoHandle
{
public:
    // Constructor
    CAutoHandle(HANDLE h = NULL)
        :m_h(h){}

    // Behave like a HANDLE in assignments
    CAutoHandle& operator=(HANDLE h)
    {
        if ((!BAD_HANDLE(m_h)) &&   // A valid handle is kept by us
            (m_h != h))             // A new handle is different!
        {
            CloseHandle(m_h);
        }

        m_h = h;
        return(*this);
    }

    // Every kind of a  handle needs different closing.
    virtual
    ~CAutoHandle()
    {
        if (!BAD_HANDLE(m_h))
        {
            CloseHandle(m_h);
            m_h = NULL;
        }
    }

    // Behave like a handle
    operator HANDLE() const
    {
        return m_h;
    }

    // Allow access to the actual memory of the handle.
    HANDLE* operator &()
    {
        Assert(BAD_HANDLE(m_h));

        return &m_h;
    }

    HANDLE Detach()
    {
        HANDLE h = m_h;
        m_h = NULL;
        return h;
    }
protected:
    // The handle.
    HANDLE  m_h;


private:
    CAutoHandle(CAutoHandle&);
    CAutoHandle& operator=(CAutoHandle&);
};

////////////////////////////////////////////////////////////////////////////////
//
//  CAutoChangeNotificationHandle class definition
//
////////////////////////////////////////////////////////////////////////////////

class CAutoChangeNotificationHandle :public CAutoHandle
{
public:
    // Constructor
    CAutoChangeNotificationHandle(HANDLE h = NULL)
        :CAutoHandle(h){};

    // These operators are not derived and therefore must be reimplemented.
    CAutoChangeNotificationHandle& operator=(HANDLE h)
    {
        m_h = h;
        return(*this);
    }

    // The proper closing.
    virtual
    ~CAutoChangeNotificationHandle()
    {
        if (!BAD_HANDLE(m_h))
        {
            FindCloseChangeNotification(m_h);
            m_h = NULL;
        }
    }

private:
    CAutoChangeNotificationHandle(CAutoChangeNotificationHandle&);
    operator=(CAutoChangeNotificationHandle&);
};

#endif /* AUTOHNDL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\regkey.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  RegKey.h
//      Purpose  :  To contain a registry key.
//
//      Project  :  Common
//      Component:
//
//      Author   :  urib
//
//      Log:
//          Dec  5 1996 urib Creation
//          Jan  1 1997 urib Change GetValue to QueryValue.
//          Mar  2 1997 urib Add iterator of subkeys.
//          Apr 15 1997 urib Add QueryValue that recieves VarString.
//                             Move to UNICODE.
//          Jun 12 1997 urib Documentation fix.
//          Oct 21 1997 urib  Support boolean QueryValue.
//          Nov 18 1997 dovh  Added PWSTR SetValue.
//          Aug 17 1998 urib  More creation options. Better exceptions.
//          Feb 11 1999 urib  Fix prototypes const behavior.
//          Mar 15 2000 urib  Add CReadOnlyRegistryKey class.
//          Nov  8 2000 urib  Support evironment variables in registry values.
//
////////////////////////////////////////////////////////////////////////////////
#ifndef REGKEY_H
#define REGKEY_H

#include "Base.h"
#include "VarTypes.h"
#include "Excption.h"

////////////////////////////////////////////////////////////////////////////////
//
//  class  -  CRegistryKey - definition
//
////////////////////////////////////////////////////////////////////////////////

class CRegistryKey
{
  public:
    // Constructor - Initialize from an open handle and a path.
    CRegistryKey(
        HKEY       hkOpenedKey,
        PCWSTR     pwszPathToKey,
        DWORD      dwCreationDisposition = OPEN_ALWAYS,
        REGSAM     samDesired = KEY_ALL_ACCESS);

    // Close the key.
    ~CRegistryKey() {RegCloseKey(m_hkKey);}

    // Behave like a handle.
    operator HKEY() {return m_hkKey;}

    // Query string values
    LONG QueryValue(
        PCWSTR  pwszValueName,
        PWSTR   pwszBuffer,
        ULONG&  ulBufferSizeInBytes);

    // Query string values
    LONG QueryValue(
        PCWSTR      pwszValueName,
        CVarString& vsData);

    // Query 32 bit values
    LONG QueryValue(
        PCWSTR  pwszValueName,
        DWORD&  dwValue);

    // Query boolean values
    LONG QueryValue(
        PCWSTR  pwszValueName,
        bool&   fValue);

    // Set 32 bit values
    LONG SetValue(
        PCWSTR  pwszValueName,
        DWORD   dwValue);

    // Set wide charachter string values
    LONG
    CRegistryKey::SetValue(
        PCWSTR pwszValueName,
        PCWSTR pwszValueData
        );

    // Iterator for subkeys.
    class CIterator
    {
      public:
        // Advance one step.
        BOOL    Next();

        // Return the name of the current subkey.
        operator PWSTR() {return m_rwchSubKeyName;}

        // Free the iterator.
        ULONG
        Release() {delete this; return 0;}

      protected:
        // Hidden constructor so one can get this class only via GetIterator
        CIterator(CRegistryKey*   prkKey);

        // The index of the subkey enumerated.
        ULONG m_ulIndex;

        // Pointer to the registry key that created us.
        CRegistryKey*   m_prkKey;

        // the current subkey name.
        WCHAR   m_rwchSubKeyName[MAX_PATH + 1];

        // enable registry key to create us.
        friend CRegistryKey;
    };

    // Allocates and returns an iterator for subkeys
    CIterator* GetIterator();

protected:
    // Query string values without expanding environment variables
    LONG QueryStringValueNoEnvExpansion(
        PCWSTR  pwszValueName,
        PWSTR   pwszBuffer,
        ULONG&  ulBufferSizeInBytes,
        bool   *pfValueTypeExpand);

    // Query string values without expanding environment variables
    LONG QueryStringValueNoEnvExpansion(
        PCWSTR      pwszValueName,
        CVarString& vsData,
        bool       *pfValueTypeExpand);

private:
    // The registry key handle.
    HKEY m_hkKey;
};

////////////////////////////////////////////////////////////////////////////////
//
//  class  -  CReadOnlyRegistryKey - definition
//
////////////////////////////////////////////////////////////////////////////////
class CReadOnlyRegistryKey : public CRegistryKey
{
public:
    CReadOnlyRegistryKey(
        HKEY       hkOpenedKey,
        PCWSTR     pwszPathToKey)
        :CRegistryKey(
            hkOpenedKey,
            pwszPathToKey,
            OPEN_EXISTING,
            KEY_READ)
    {
    }

protected:
    // Set 32 bit values
    LONG
    SetValue(
        PCWSTR  pwszValueName,
        DWORD   dwValue);

    // Set wide charachter string values
    LONG
    SetValue(
        PCWSTR pwszValueName,
        PCWSTR pwszValueData
        );
};

////////////////////////////////////////////////////////////////////////////////
//
//  class  -  CRegistryKey - implementation
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::CRegistryKey
//      Purpose  :  CTor. Opens/creates the registry key.
//
//      Parameters:
//          [in]     HKEY       hkOpenedKey
//          [in]     PWSTR      pwszPathToKey
//
//      Returns  :   [N/A]
//
//      Log:
//          Apr 15 1997 urib  Creation
//          Aug 17 1998 urib  More creation options. Better exceptions.
//          Mar 15 2000 urib  Add default parameter to allow specifying the
//                              desired acces.
//
////////////////////////////////////////////////////////////////////////////////
inline
CRegistryKey::CRegistryKey(
    HKEY    hkOpenedKey,
    PCWSTR  pwszPathToKey,
    DWORD   dwCreationDisposition,
    REGSAM  samDesired)
    :m_hkKey(0)
{
    LONG    lRegistryReturnCode;
    DWORD   dwOpenScenario;

    switch (dwCreationDisposition)
    {
    case CREATE_ALWAYS: // Create a new key - erase existing one.
        lRegistryReturnCode = RegDeleteKey(hkOpenedKey, pwszPathToKey);
        if ((ERROR_SUCCESS != lRegistryReturnCode) ||
            (ERROR_FILE_NOT_FOUND != lRegistryReturnCode))
        {
            THROW_WIN32ERROR_EXCEPTION(lRegistryReturnCode);
        }

        // Fall through ...

    case OPEN_ALWAYS:   // Open key - if key does not exist, create it.
    case CREATE_NEW:    // Create a new key - fail if exists.
        lRegistryReturnCode = RegCreateKeyEx(
            hkOpenedKey,
            pwszPathToKey,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            samDesired,
            NULL,
            &m_hkKey,
            &dwOpenScenario);
        if (ERROR_SUCCESS != lRegistryReturnCode)
        {
            THROW_WIN32ERROR_EXCEPTION(lRegistryReturnCode);
        }
        else if ((REG_OPENED_EXISTING_KEY == dwOpenScenario) &&
                 (OPEN_ALWAYS != dwCreationDisposition))
        {
            THROW_WIN32ERROR_EXCEPTION(ERROR_ALREADY_EXISTS);
        }
        break;

    case OPEN_EXISTING: // Open existing key - fail if key doesn't exist.
        lRegistryReturnCode = RegOpenKeyEx(
            hkOpenedKey,
            pwszPathToKey,
            0,
            samDesired,
            &m_hkKey);
        if (ERROR_SUCCESS != lRegistryReturnCode)
        {
            THROW_WIN32ERROR_EXCEPTION(lRegistryReturnCode);
        }
        break;
    }
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::QueryValue
//      Purpose  :  Query a registry string value into a buffer.
//
//      Parameters:
//          [in]    PCWSTR  pwszValueName
//          [out]   PWSTR   pwszBuffer
//          [out]   ULONG&  ulBufferSizeInBytes
//
//      Returns  :   LONG
//
//      Log:
//          Apr 15 1997 urib Creation
//          Nov  8 2000 urib  Support evironment variables in registry values.
//
////////////////////////////////////////////////////////////////////////////////
inline
LONG
CRegistryKey::QueryValue(
    PCWSTR  pwszValueName,
    PWSTR   pwszBuffer,
    ULONG&  ulBufferSizeInBytes)
{
    LONG    lRegistryReturnCode;
    ULONG   ulBufferSizeInWchar = ulBufferSizeInBytes / sizeof(WCHAR);

    bool    bIsExpanded;

    DWORD       dwResult;
    CVarString  vsBeforExpansion;

    Assert(sizeof(TCHAR) == sizeof(WCHAR));


    lRegistryReturnCode = QueryStringValueNoEnvExpansion(
        pwszValueName,
        pwszBuffer,
        ulBufferSizeInBytes,
        &bIsExpanded);
    if ((ERROR_SUCCESS != lRegistryReturnCode) &&
        (ERROR_MORE_DATA != lRegistryReturnCode))
    {
        return lRegistryReturnCode;
    }

    if  (bIsExpanded)
    {
        //
        //  We need the string value either for calculating the required length
        //    or for actually returning the data
        //
        if ((ERROR_MORE_DATA == lRegistryReturnCode) ||
            (NULL == pwszBuffer))
        {
            //
            // We are just calculating...
            //

            lRegistryReturnCode = QueryStringValueNoEnvExpansion(
                pwszValueName,
                vsBeforExpansion,
                &bIsExpanded);
            if (ERROR_SUCCESS != lRegistryReturnCode)
            {
                return lRegistryReturnCode;
            }
        }
        else
        {
            vsBeforExpansion.Cpy(pwszBuffer);
        }

        {
            WCHAR   wchDummieString;
            ULONG   ulExpansionBufferSizeInWchar = ulBufferSizeInWchar;

            if (NULL == pwszBuffer)
            {
                pwszBuffer = &wchDummieString;
                ulExpansionBufferSizeInWchar = 1;
            }

            dwResult = ExpandEnvironmentStrings(
                vsBeforExpansion,   // string with environment variables
                pwszBuffer,         // string with expanded strings
                ulExpansionBufferSizeInWchar);
                                    // maximum characters in expanded string
            if (0 == dwResult)
            {
                return ERROR_BAD_ENVIRONMENT;
            }

            //
            //  Return the final size number in bytes through ulBufferSizeInBytes
            //

            ulBufferSizeInBytes = dwResult * sizeof(WCHAR);

            if (dwResult > ulBufferSizeInWchar)
                return ERROR_MORE_DATA;

        }
    }

    return ERROR_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::QueryStringValueNoEnvExpansion
//      Purpose  :  Query a registry string value into a buffer.
//                    Do not expand environment variables
//
//      Parameters:
//          [in]    PCWSTR  pwszValueName
//          [out]   PWSTR   pwszBuffer
//          [out]   ULONG&  ulBufferSizeInBytes
//          [out]   bool*   pfValueTypeExpand
//
//      Returns  :   LONG
//
//      Log:
//          Apr 15 1997 urib Creation
//          Nov  8 2000 urib  Support evironment variables in registry values.
//
////////////////////////////////////////////////////////////////////////////////
inline
LONG
CRegistryKey::QueryStringValueNoEnvExpansion(
    PCWSTR  pwszValueName,
    PWSTR   pwszBuffer,
    ULONG&  ulBufferSizeInBytes,
    bool   *pbValueTypeExpand)
{
    LONG    lRegistryReturnCode;
    DWORD   dwValueType;

    lRegistryReturnCode = RegQueryValueEx(
        m_hkKey,
        pwszValueName,
        NULL,
        &dwValueType,
        (LPBYTE)pwszBuffer,
        &ulBufferSizeInBytes);

    if ((REG_SZ != dwValueType) &&
        (REG_EXPAND_SZ != dwValueType))
        return ERROR_BAD_FORMAT;

    if (pbValueTypeExpand)
    {
        *pbValueTypeExpand = (REG_EXPAND_SZ == dwValueType);
    }

    return lRegistryReturnCode;
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::QueryValue
//      Purpose  :  Query a registry string value into a CVarString.
//
//      Parameters:
//          [in]    PCWSTR      pwszValueName
//          [out]   CVarString& vsData
//
//      Returns  :   LONG
//
//      Log:
//          Apr 15 1997 urib Creation
//
////////////////////////////////////////////////////////////////////////////////
inline
LONG
CRegistryKey::QueryValue(
    PCWSTR      pwszValueName,
    CVarString& vsData)
{
    LONG    lRegistryReturnCode;
    DWORD   dwBufferSize;

    lRegistryReturnCode = QueryValue(
        pwszValueName,
        NULL,
        dwBufferSize);
    if (ERROR_SUCCESS == lRegistryReturnCode)
    {
        vsData.SetMinimalSize(dwBufferSize + 1);

        lRegistryReturnCode = QueryValue(
            pwszValueName,
            (PWSTR)vsData,
            dwBufferSize);
    }

    return lRegistryReturnCode;
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::QueryStringValueNoEnvExpansion
//      Purpose  :  Query a registry string value into a CVarString.
//
//      Parameters:
//          [in]    PCWSTR      pwszValueName
//          [out]   CVarString& vsData
//          [out]   bool       *pbValueTypeExpand
//
//      Returns  :   LONG
//
//      Log:
//          Apr 15 1997 urib Creation
//
////////////////////////////////////////////////////////////////////////////////
inline
LONG
CRegistryKey::QueryStringValueNoEnvExpansion(
    PCWSTR      pwszValueName,
    CVarString& vsData,
    bool       *pbValueTypeExpand)
{
    LONG    lRegistryReturnCode;
    DWORD   dwBufferSize;

    lRegistryReturnCode = QueryStringValueNoEnvExpansion(
        pwszValueName,
        NULL,
        dwBufferSize,
        pbValueTypeExpand);
    if (ERROR_SUCCESS == lRegistryReturnCode)
    {
        vsData.SetMinimalSize(dwBufferSize + 1);

        lRegistryReturnCode = QueryStringValueNoEnvExpansion(
            pwszValueName,
            (PWSTR)vsData,
            dwBufferSize,
            pbValueTypeExpand);
    }

    return lRegistryReturnCode;
}


/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::QueryValue
//      Purpose  :  Query a registry 32 bit value.
//
//      Parameters:
//          [in]    PCWSTR   pwszValueName
//          [out]   DWORD&   dwValue
//
//      Returns  :   LONG
//
//      Log:
//          Apr 15 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
inline
LONG
CRegistryKey::QueryValue(
    PCWSTR  pwszValueName,
    DWORD&  dwValue)
{
    LONG    lRegistryReturnCode;
    DWORD   dwValueType;
    DWORD   dwValueSize;

    // Read disk flag
    dwValueSize = sizeof(dwValue);

    lRegistryReturnCode = RegQueryValueEx(
        m_hkKey,
        pwszValueName,
        NULL,
        &dwValueType,
        (LPBYTE)&dwValue,
        &dwValueSize);
    if (REG_DWORD != dwValueType)
        return ERROR_BAD_FORMAT;

    return lRegistryReturnCode;
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::QueryValue
//      Purpose  :  Query a registry boolean value.
//
//      Parameters:
//          [in]    PCWSTR  pwszValueName
//          [out]   bool&   fValue
//
//      Returns  :   LONG
//
//      Log:
//          Apr 15 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
inline
LONG
CRegistryKey::QueryValue(
    PCWSTR  pwszValueName,
    bool&   fValue)
{
    LONG    lRegistryReturnCode;
    DWORD   dwValueType;
    DWORD   dwValueSize;
    DWORD   dwValue;

    // Read disk flag
    dwValueSize = sizeof(dwValue);

    lRegistryReturnCode = RegQueryValueEx(
        m_hkKey,
        pwszValueName,
        NULL,
        &dwValueType,
        (LPBYTE)&dwValue,
        &dwValueSize);
    if (REG_DWORD != dwValueType)
        return ERROR_BAD_FORMAT;

    fValue = !!dwValue;

    return lRegistryReturnCode;
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::SetValue
//      Purpose  :  To set a 32 bit registry value.
//
//      Parameters:
//          [in]    PCWSTR  pwszValueName
//          [in]    DWORD   dwValue
//
//      Returns  :   [N/A]
//
//      Log:
//          Apr 15 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
inline
LONG
CRegistryKey::SetValue(
    PCWSTR  pwszValueName,
    DWORD   dwValue)
{
    LONG    lRegistryReturnCode;

    lRegistryReturnCode = RegSetValueEx(
        m_hkKey,
        pwszValueName,
        NULL,
        REG_DWORD,
        (PUSZ)&dwValue,
        sizeof(DWORD));

    return lRegistryReturnCode;
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::SetValue
//      Purpose  :  To set a wide character string value
//
//      Parameters:
//          [in]    PCWSTR  pwszValueName
//          [in]    PCWSTR  pwszValueData
//
//      Returns  :   [N/A]
//
//      Log:
//          Nov 16 1997 DovH Creation
//
//////////////////////////////////////////////////////////////////////////////*/
inline
LONG
CRegistryKey::SetValue(
    PCWSTR  pwszValueName,
    PCWSTR  pwszValueData
    )
{
    LONG    lRegistryReturnCode;

    lRegistryReturnCode =

    RegSetValueEx(
        m_hkKey,
        pwszValueName,
        NULL,
        REG_SZ,
        (BYTE*)pwszValueData,
        (wcslen(pwszValueData)+1) * sizeof(WCHAR)
        );

    return lRegistryReturnCode;

} // CRegistryKey::SetValue

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey::GetIterator
//      Purpose  :  To return a subkey enumerator.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   CRegistryKey::CIterator*
//
//      Log:
//          Apr 15 1997 urib  Creation
//          Aug 17 1998 urib  Better exceptions.
//
//////////////////////////////////////////////////////////////////////////////*/
inline
CRegistryKey::CIterator*
CRegistryKey::GetIterator()
{
    CIterator* pit;
    try
    {
        pit = new CIterator(this);
        if (!pit)
            THROW_MEMORY_EXCEPTION();
    }
    catch(...)
    {
        pit = NULL;
    }

    return pit;
}

////////////////////////////////////////////////////////////////////////////////
//
//  class  -  CRegistryKey::CIterator - implementation
//
////////////////////////////////////////////////////////////////////////////////

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CRegistryKey:CIterator::Next
//      Purpose  :  Advance to the next subkey.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   BOOL
//
//      Log:
//          Apr 15 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
inline
BOOL
CRegistryKey::CIterator::Next()
{
    LONG    lResult;

    lResult = RegEnumKey(
        *m_prkKey,
        m_ulIndex,
        m_rwchSubKeyName,
        MAX_PATH);

    if (ERROR_SUCCESS  == lResult)
    {
        m_ulIndex++;
        return TRUE;
    }
    else if (ERROR_NO_MORE_ITEMS == lResult)
        return FALSE;
    else
    {
        Assert(0);
        return FALSE;
    }
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CIterator::CRegistryKey::CIterator
//      Purpose  :  CTor.
//
//      Parameters:
//          [in]    CRegistryKey*   prkKey
//
//      Returns  :   [N/A]
//
//      Log:
//          Apr 15 1997 urib Creation
//          Aug 17 1998 urib  Better exceptions.
//
//////////////////////////////////////////////////////////////////////////////*/
inline
CRegistryKey::CIterator::CIterator(CRegistryKey*   prkKey)
    :m_ulIndex(0)
    ,m_prkKey(prkKey)
{
    if (!Next())
        THROW_WIN32ERROR_EXCEPTION(ERROR_CANTOPEN);
}

#endif // REGKEY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\memorymanagement.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  MemoryManagement.h
//      Purpose  :  To collect all memory management issues.
//
//      Project  :  Persistent Query
//      Component:  Common
//
//      Author   :  urib
//
//      Log:
//          Apr 13 2000 urib  Creation
//
////////////////////////////////////////////////////////////////////////////////

#ifndef MEMORYMANAGEMENT_H
#define MEMORYMANAGEMENT_H

#include "Excption.h"
#include "Excption.h"

#if !(defined(_PQS_LEAK_DETECTION) && defined(_DEBUG))

////////////////////////////////////////////////////////////////////////////////
//
//  Debug OFF
//  Debug OFF
//  Debug OFF
//
////////////////////////////////////////////////////////////////////////////////

inline
void* __cdecl operator new(size_t s) throw (CMemoryException)
{
    void *p = malloc(s);
    if (NULL == p)
    {
        throw CMemoryException(L"Define _PQS_LEAK_DETECTION for real data here",
                               0);
    }

    return p;
}

#else // !(defined(_PQS_LEAK_DETECTION) && defined(_DEBUG))

////////////////////////////////////////////////////////////////////////////////
//
//  Debug ON
//  Debug ON
//  Debug ON
//
////////////////////////////////////////////////////////////////////////////////

#include    <new>
#include    <new.h>
#include    <crtdbg.h>
#include    <stdlib.h>
#include    "Injector.h"
#include    "Excption.h"



////////////////////////////////////////////////////////////////////////////////
//
//  Throws an exception in case it is recommended by the injector.
//
////////////////////////////////////////////////////////////////////////////////
inline
void Inject(
    ULONG           ulSize,
    const char *    szFileName,
    int             nLine)
{
    if (DoInjection(ulSize, szFileName, nLine))
    {
        THROW_MEMORY_EXCEPTION();
    }
}

////////////////////////////////////////////////////////////////////////////////
//
//  Add injection to the CRT debug allocation routines.
//
////////////////////////////////////////////////////////////////////////////////
inline
void* dbgRealloc(
    void * p,
    size_t s,
    const char * szFileName,
    int nLine)
{
    Inject(s,szFileName,nLine);
    return _realloc_dbg(p, s, _NORMAL_BLOCK, szFileName, nLine);
}

inline
void* dbgMalloc(
        unsigned int s,
        const char * szFileName,
        int nLine
        )
{
    Inject(s,szFileName,nLine);
    return _malloc_dbg(s, _NORMAL_BLOCK, szFileName, nLine);
}

////////////////////////////////////////////////////////////////////////////////
//
//  Add exception throwing on NULL allocation. Add Injector support.
//
////////////////////////////////////////////////////////////////////////////////
inline
void* __cdecl operator new(size_t s, const char* pszFile, unsigned long ulLine)
						        throw (CMemoryException)
{
    Inject(s, pszFile, ulLine);

    void *p = _malloc_dbg(s, _NORMAL_BLOCK, pszFile, ulLine);
    if (NULL == p)
    {
        WCHAR   rwchFilename[1000];

        mbstowcs(rwchFilename,
                 pszFile,
                 sizeof(rwchFilename) / sizeof(rwchFilename[0]));


        throw CMemoryException(rwchFilename, ulLine);
    }

    return p;
}


////////////////////////////////////////////////////////////////////////////////
//
//  Unwinding placment delete operator exists only in VC 6 and up
//
////////////////////////////////////////////////////////////////////////////////
inline
void __cdecl operator delete(void * _P, const char *, unsigned long)
{
    ::operator delete(_P);
}



////////////////////////////////////////////////////////////////////////////////
//
//  Redirect malloc, realloc and new to the debug version specifying
//    allocation location.
//
////////////////////////////////////////////////////////////////////////////////

#undef  malloc
#define malloc(s)         dbgMalloc(s, __FILE__, __LINE__)

#undef  realloc
#define realloc(p, s)     dbgRealloc(p, s, __FILE__, __LINE__)

#define DEBUG_NEW new(__FILE__,__LINE__)
#define new DEBUG_NEW


#endif // !(defined(_PQS_LEAK_DETECTION) && defined(_DEBUG))


#endif MEMORYMANAGEMENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\gtable.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  GTable.h
//      Purpose  :  True Global tables class defilitions
//
//      Project  :  PQS
//      Component:  FILTER
//
//      Author   :  dovh
//
//      Log      :  Nov-11-1998 dovh - Creation
//
//      Dec-01-1998 dovh - Add tags.cxx functionality
//          replace read tags file.
//      Jan-18-1999 dovh - Add CFE_BitseTables.
//      Jan-26-1999 dovh - Add CFE_GlobalConstTable fields.
//      Feb-02-1999 dovh - Move AddSectionTags: Gtable ==> FEGlobal
//      May-16-1999 urib - Move separator map : Gtable ==> FEGlobal
//      Dec-11-2000 dovh - MapToUpper: Assert the argument is in the
//                         correct range
//
////////////////////////////////////////////////////////////////////////////////

#ifndef   __G_TABLE_H__
#define   __G_TABLE_H__
#include "excption.h"
//
//  G L O B A L   C O N S T A N T   M A C R O S :
//

#define PQS_HASH_SEQ_LEN             3
#define XML_HASH_SEQ_LEN             2

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CCToUpper Class Definition
//      Purpose  :  Encapsulate True Immutable Globals.
//
//      Log      :  Nov-11-1998 dovh - Creation
//
//////////////////////////////////////////////////////////////////////////////*/

class CToUpper
{

public:

    CToUpper();

    //
    //  SOME ACCESS FUNCTIONS:
    //
    __forceinline
    static
    WCHAR
    MapToUpper(
        IN WCHAR wc
        )
    {
        extern CToUpper g_ToUpper;
        Assert(wc < 0X10000);
        return g_ToUpper.m_pwcsCaseMapTable[wc];
    }


public:

    WCHAR m_pwcsCaseMapTable[0X10000];

};  // CFE_CToUpper

extern CToUpper g_ToUpper;

inline CToUpper::CToUpper( )
{
    for (WCHAR wch = 0; wch < 0XFFFF; wch++)
    {
        WCHAR wchOut;
        LCMapString(
            LOCALE_NEUTRAL,
            LCMAP_UPPERCASE,
            &wch,
            1,
            &wchOut,
            1 );

        //
        //  Run the full fledged accent removal technique!
        //

        WCHAR pwcsFold[5];

        int iResult = FoldString(
                MAP_COMPOSITE,
                &wchOut,
                1,
                pwcsFold,
                5);

        Assert(iResult);
        Assert(iResult < 5);
        m_pwcsCaseMapTable[wch] = pwcsFold[0];
    }

    m_pwcsCaseMapTable[0XFFFF] = 0XFFFF; // can't put that in the loop since wch is WCHAR (will result in infinit loop)
}

#endif // __G_TABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\trie.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  TRIE.H
//      Purpose  :  Basic C MACROS/DEFS used by the Trie package
//
//      Project  :  PQS
//      Component:  FE_CORE
//
//      Author   :  dovh
//
//      Log      :
//          MMM DD YYYY dovh  Creation
//          Dec 11 1996 DovH  UNICODE Preparation: Convert char to TCHAR.
//          Dec  1 1998 dovh  Use HCFE_GlobalHandle
//          Nov  2 1999 YairH Fix copilation errors.
//          Nov  8 1999 urib  Fix tabulation format.
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __TRIE_H__
#define __TRIE_H__

#pragma once

#include "comdefs.h"
#include "gtable.h"
#include "autoptr.h"
#include "excption.h"
#include "tracer.h"

DECLARE_TAG(s_tagTrie, "Trie")

//
//  T R I E   P A C K A G E   F L A G S :
//

#define TRIE_DEFAULT                    0X00000000L

#define TRIE_IGNORECASE                 0X00000001L

#define TRIE_SHORTEST_MATCH             0X00000010L
#define TRIE_LONGEST_MATCH              0X00000020L
#define TRIE_ALL_MATCHES                0X00000040L
#define TRIE_FILTER_VERIFY              0X00000080L

#define TRIE_EXCHANGE_ITEM              0X00000100L
#define TRIE_OUT_BUFFER_EMPTY           0X00000200L

#define TRIE_NODE_SUFFIXCOUNT_INIT              0
#define TRIE_NODE_SUFFIXSIZE_INIT               2

#define DECLARE_TRIE_SENTINEL  CTrieNode<BYTE> g_trie_Sentinel


template <class T, class C = CToUpper >
class CTrieNode
{
public:
    CTrieNode();
    CTrieNode(short sSize);
    CTrieNode(
        T* NewItem,
        ULONG options,
        const WCHAR* NewString,
        ULONG ulCharToCopy = 0xffffffff);
    ~CTrieNode();

    void DeleteItem();

    void
    AddSuffix(
        ULONG options,
        CTrieNode<T, C>* newSuffix,
        USHORT index = 0xffff
        );

    void
    SplitNode(
        CTrieNode<T, C>* parent,            //  Parent of node
        short index,                     //  Index of node in parent->suffix
        const WCHAR * NewString,            //  String sharing prefix with node->string
        size_t charsMatched,
        T* item,                         //  Item associated with (sub)string
        ULONG options                    //  Insertion options
        );

    void Print(ULONG  ulOffset);

    int
    trie_StrMatchIns(
        const WCHAR * s,
        const WCHAR * t,
        size_t * matchCount
        );

    inline
    int
    trie_StrMatch(
        const WCHAR * s,
        const WCHAR * t,
        size_t * matchCount
        );

private:
    void DoubleSuffixArray();

public:
    short suffixCount;                          //  Number of suffixes
    short suffixSize;                           //  Size of suffixes array
    CTrieNode ** suffix;                        //  Pointer to suffixes array

    T* item;                                    //  Pointer to item corresponding to node

    size_t charCount;                           //  String length
    WCHAR* string;                              //  Zero terminated string

public:

};

extern CTrieNode<BYTE> g_trie_Sentinel;


template <class T, class C = CToUpper >
class CTrie
{
public:

    CTrie(bool fDeleteItemsOnDestruction = false);

    ~CTrie();

    DictStatus
    trie_Insert(                            //  Insert string into trie
        const WCHAR * string,               //  String key of item
        unsigned long options,              //  Insertion flags
        T * item,                           //  Item to be inserted
        T ** pTrieItem                      //  Matching item already in trie
        );

    DictStatus
    trie_Find(
        const WCHAR * string,         //  A string
        unsigned long options,        //  Search flags
        short outBufferSize,          //  Max number of results wanted
        T ** outBuffer,               //  Buffer to be filled with matching items
        short * resultCount           //  Number of matching prefixes returned
        );

    void Print();

private:
    CTrieNode<T, C>* root;
    bool fDeleteItems;
};


///////////////////////////////////////////////////////////////////////////////
// CTrieNode implementation
///////////////////////////////////////////////////////////////////////////////

template <class T, class C >
inline CTrieNode<T, C>::CTrieNode() :
    suffixCount(0),
    suffixSize(0),
    charCount(0),
    item(NULL),
    suffix(NULL)
{
    string = new WCHAR[1];
    string[0] = L'\0';
}

template <class T, class C >
inline CTrieNode<T, C>::CTrieNode(short sSize) :
    suffixCount(0),
    suffixSize(sSize),
    string(NULL),
    charCount(0),
    item(NULL),
    suffix(NULL)
{
    Assert(sSize > 0);
    suffix = new CTrieNode<T, C>*[suffixSize];
    memset(suffix,0, suffixSize*sizeof(CTrieNode<T, C>*));
}

template <class T, class C >
inline CTrieNode<T, C>::CTrieNode(
    T* NewItem,
    ULONG options,
    const WCHAR* NewString,
    ULONG ulCharToCopy) :
    suffixCount(TRIE_NODE_SUFFIXCOUNT_INIT),
    suffixSize(TRIE_NODE_SUFFIXSIZE_INIT)
{
    charCount = min(wcslen(NewString), ulCharToCopy);
    CAutoArrayPointer<WCHAR> apwcsNewString = new WCHAR[charCount + 1];
    string = apwcsNewString.Get();

    wcsncpy(string, NewString, charCount);
    string[charCount] = L'\0';

    suffix = new CTrieNode<T, C>*[suffixSize];
    memset(suffix, 0, sizeof(CTrieNode<T, C>*) * suffixSize);
    item = NewItem;

    apwcsNewString.Detach();
}

template <class T, class C >
inline void CTrieNode<T, C>::DeleteItem()
{
    for (short s = 0; s < suffixCount; s++)
    {
        if (suffix[s] != (CTrieNode<T, C>*)&g_trie_Sentinel)
        {
            suffix[s]->DeleteItem();
        }
    }
    delete item;
}

template <class T, class C >
inline CTrieNode<T, C>::~CTrieNode()
{
    Trace(
            elInfo,
            s_tagTrie,(
            "CTrieNode:"
            "Released"));

    for (short s = 0; s < suffixCount; s++)
    {
        if (suffix[s] != (CTrieNode<T, C>*)&g_trie_Sentinel)
        {
            delete suffix[s];
        }
    }
    delete[] suffix;
    delete string;

}

template <class T, class C >
inline
int
CTrieNode<T, C>::trie_StrMatch(
    const WCHAR * s,
    const WCHAR * t,
    size_t * matchCount
    )
{
    const WCHAR * s0 = s;
    const WCHAR * t0 = t;

    //
    //  Straigh K&R ptr version...
    //
    for ( ; *s0 == *t0; s0++, t0++ )
    {
        if (*s0 == TEXT('\0'))
        {
            *matchCount = s0 - s;
            Assert( (*s0 - *t0) == 0 );
            return (0);
        }
    }

    *matchCount = s0 - s;
    return ( *s0 - *t0 );

} // end trie_StrMatch

template <class T, class C >
inline
int
CTrieNode<T, C>::trie_StrMatchIns(
    const WCHAR * s,
    const WCHAR * t,
    size_t * matchCount
    )
{
    const WCHAR * s0 = s;
    const WCHAR * t0 = t;

    //
    //  Straigh K&R ptr version...
    //
    for ( ; C::MapToUpper(*s0) == C::MapToUpper(*t0); s0++, t0++ )
    {
        if (*s0 == TEXT('\0'))
        {
            *matchCount = s0 - s;
            Assert ( (C::MapToUpper(*s0) - C::MapToUpper(*t0)) == 0 );
            return (0);
        }
    }

    *matchCount = s0 - s;
    return ( C::MapToUpper(*s0) - C::MapToUpper(*t0) );

} // end trie_StrMatchIns



/*++
    Function trie_AddSuffix:

        Insert a new suffix into the suffix array of node.

    Routine Parameters:

        node - Add a newSuffix to node->suffix array.

        index - index in node->suffix to at which newSuffix should be added
            to preserve increasing lexicographic ordering on node->suffix.

        newSuffix - new suffix node to be added as child of node.

    Return value:

--*/

template <class T, class C >
inline void
CTrieNode<T, C>::AddSuffix(
    ULONG options,
    CTrieNode<T, C>* newSuffix,
    USHORT index
    )
{
    //
    //  Make sure there is enough room for the new child:
    //
    Assert(suffixCount <= suffixSize);
    if (suffixCount == suffixSize)
    {
        DoubleSuffixArray();
    }

    if (0xffff == index)
    {
        if (options & TRIE_IGNORECASE)
        {
            for ( index=0;
                  (index < suffixCount) &&
                  (C::MapToUpper(suffix[index]->string[0]) < C::MapToUpper(newSuffix->string[0]));
                  index++
                )
                ;
        }
        else
        {
            for ( index=0;
                  (index < suffixCount) &&
                  (suffix[index]->string[0] < newSuffix->string[0]);
                  index++
                )
                ;
        }
    }

#ifdef DEBUG
    if (options & TRIE_IGNORECASE)
    {
        Assert((index == 0 ) ||
               (index == suffixCount) ||
               (C::MapToUpper(suffix[index]->string[0]) > C::MapToUpper(newSuffix->string[0])));
    
    }
    else
    {
        Assert((index == 0 ) ||
               (index == suffixCount) ||
               (suffix[index]->string[0] > newSuffix->string[0]));
    }
#endif

    //
    //  Shift node->suffix[index .. node->suffixCount] one location to the right
    //  to make room for newSuffix at location index:
    //
    if ( index < suffixCount )
    {
        for (short i=suffixCount; i>index; i--)
        {
            suffix[i] = suffix[i-1];
        }
    }
    suffixCount++;

    //
    // WARNING: after the next line do not add more allocations. The new suffix
    // might be an automatic pointer that in this case will be released twice,
    // as part of the destruction of the class and as automatic pointer
    //

    suffix[index] = newSuffix;

} // end AddSuffix

/*++

    Function trie_SplitNode:

        Assume string and node->string has a non-empty common prefix, which
        is a strict substring of node->string.  Splits node->string into the common
        prefix, and the two suffixes (string may be a prefix of node->string) in which
        case the corresponding suffix is NULL, represented by trie_Sentinel?).
        Add two new children representing the admissible continuations of
        the common suffix.

    Return value:


    Log:

    Apr-14-1998 dovh - PerlWarn: change to ==:
        Assert( node = parent->suffix[ index ] );

--*/


template <class T, class C >
inline void
CTrieNode<T, C>::SplitNode(
    CTrieNode<T, C>* parent,            //  Parent of node
    short index,                     //  Index of node in parent->suffix
    const WCHAR * NewString,            //  String sharing prefix with node->string
    size_t charsMatched,
    T* item,                         //  Item associated with (sub)string
    ULONG options                    //  Insertion options
    )
{
    //
    //  Verify that the prefix common to string and node->string is
    //  a non-NULL proper prefix of node->string:
    //

    Assert( ( (options & TRIE_IGNORECASE) ?
              (C::MapToUpper(*string) == C::MapToUpper(*NewString)) :
              (*string == *NewString) )
        );

    Assert(charsMatched < wcslen(string));

    //
    //  Set up the prefix node to replace node as child of parent:
    //
    CAutoClassPointer<CTrieNode<T, C> > nodePrefix =
                new CTrieNode<T, C>(NULL, options, string, charsMatched);

    //
    //  Compute respective suffix of string and add as the second child
    //  of nodePrefix:
    //
    if ( wcslen(NewString) == charsMatched )
    {
        //
        //  TRIE_ITEM: Add trie_Sentinel to nodePrefix;
        //  nodePrefix should point to new item!
        //
        nodePrefix->AddSuffix(0,(CTrieNode<T, C>*)&g_trie_Sentinel, 0);
        nodePrefix->item = item;
    }
    else
    {
        Assert( charsMatched < wcslen(NewString) );

        //
        //  Allocate the string suffix node:
        //
        CAutoClassPointer<CTrieNode<T, C> > strSuffix =
                new CTrieNode(item, options, &NewString[charsMatched]);

        nodePrefix->AddSuffix(options, strSuffix.Get());
        strSuffix.Detach();
    }

    WCHAR* pwcsCurrStr = string;
    size_t CurrCharCount = charCount;
    try
    {
        size_t newCharCount = charCount - charsMatched;
        Assert(newCharCount > 0);
        CAutoArrayPointer<WCHAR> apwcsNewStr = new WCHAR[newCharCount + 1];
        wcscpy(apwcsNewStr.Get(), &(string[charsMatched]));

        string = apwcsNewStr.Get();
        charCount = newCharCount;

        //
        //  Add node as a child of nodePrefix:
        //  (Recall: node->string == respective suffix)
        //
        nodePrefix->AddSuffix(options, this);

        apwcsNewStr.Detach();
        delete[] pwcsCurrStr;
    }
    catch (CMemoryException& e)
    {
        string = pwcsCurrStr;
        charCount = CurrCharCount;

        throw e;
    }

    //
    //  Replace node by nodePrefix as the respective child of parent:
    //
    Assert( this == parent->suffix[ index ] );
    parent->suffix[ index ] = nodePrefix.Get();

    nodePrefix.Detach();

} // end trie_SplitNode

template <class T, class C >
inline void
CTrieNode<T, C>::Print(ULONG  ulOffset)
{
    for (ULONG i = 0; i < ulOffset; i++)
    {
        printf(" ");
    }
    if (this == (CTrieNode<T, C>*)&g_trie_Sentinel)
    {
        printf("Sentinel\n");
    }
    else
    {
        printf("%S\n",string);
    }

    for (short k = 0; k < suffixCount; k++)
    {
        suffix[k]->Print(ulOffset + 4);
    }
}

template <class T, class C >
inline void
CTrieNode<T, C>::DoubleSuffixArray()
{
    short newSize;

    if (0 == suffixSize)
    {
        newSize = TRIE_NODE_SUFFIXSIZE_INIT;
    }
    else
    {
        newSize = suffixSize * 2;
    }

    CTrieNode<T, C> ** newPSuffix;

    Assert(suffixCount == suffixSize);
    newPSuffix = new CTrieNode<T, C>*[newSize];
    memcpy(newPSuffix, suffix, suffixSize*sizeof(CTrieNode<T, C>*));
    delete[] suffix;
    suffix = newPSuffix;
    suffixSize = newSize;

} // end trie_DoubleNode

///////////////////////////////////////////////////////////////////////////////
// CTrie implementation
///////////////////////////////////////////////////////////////////////////////

template <class T, class C >
inline CTrie<T, C>::CTrie(bool fDeleteItemsOnDestruction) :
  fDeleteItems(fDeleteItemsOnDestruction)
{
    root = new CTrieNode<T, C>(TRIE_NODE_SUFFIXSIZE_INIT);
}

template <class T, class C >
inline CTrie<T, C>::~CTrie()
{
    if (fDeleteItems)
    {
        root->DeleteItem();
    }

    delete root;
}


/*++

    Function trie_Insert:

        Insert a given string into trie if it's not already a member trie.

    Routine Parameters:

        trie - Trie to insert item into.
        string - String key of item.
        options - Insertion options.  If options == 0 the item will be inserted
            only if the string key is not already in the tree.  If options
            is TRIE_EXCHANGE_ITEM the existing trie item will be replaced by
            the item argument in the Trie.  In that case the existing item
            associated with string in the trie will be returned in the
            *pTrieItem argument.
        item - New item to be inserted.
        pTrieItem - If an item associated with string already exists,
            then *pTrieItem points to that item upon return.

    Return value:

        DICT_SUCCESS if string was inserted successfully, else
        DICT_ITEM_ALREADY_PRESENT.


--*/
template <class T, class C >
inline DictStatus
CTrie<T, C>::trie_Insert(                            //  Insert string into trie
    const WCHAR * string,               //  String key of item
    unsigned long options,              //  Insertion flags
    T * item,                           //  Item to be inserted
    T ** pTrieItem                      //  Matching item already in trie
    )
{
    CTrieNode<T, C> * t, * c;

    int cmp = -1;
    const WCHAR * subString = string;
    size_t subStringSize = wcslen(subString);
    size_t strIndex = 0;
    size_t charsMatched = 0;
    CAutoClassPointer<CTrieNode<T, C> >  apNewSuffix;

    t = root;

    if (pTrieItem != NULL)
    {
        *pTrieItem = NULL;
    }

    while (true)
    {
        short i = 0;

        //
        //  Search in this level sorted alternatives list:
        //
        for ( i = 0;
              i < t->suffixCount;
              i++
            )
        {
            c = t->suffix[i];

            //  Quick "skip check":
            cmp = (options & TRIE_IGNORECASE) ?
                            (C::MapToUpper(*c->string) - C::MapToUpper(*subString)) :
                            (*c->string - *subString);
            if ( cmp < 0)
            {
                continue;
            }

            if (cmp > 0)
            {

                //
                //  First character of t->string does not match,
                //  insert a copy of subString before c (== t->suffix[i]):
                //
                apNewSuffix = new CTrieNode<T, C>(item, options, subString);
                t->AddSuffix(options, apNewSuffix.Get(), i);
                apNewSuffix.Detach();
                return DICT_SUCCESS;

            }
            else
            {
                //  At least one character matched.
                //  subStringSize = _tcslen(subString);

                cmp = (options & TRIE_IGNORECASE) ?
                    c->trie_StrMatchIns(c->string, subString, &charsMatched) :
                    c->trie_StrMatch(c->string, subString, &charsMatched);

                Assert(charsMatched <= min(c->charCount, subStringSize));

                if (cmp == 0)
                {
                    //  t->charCount (<= subStringSize) characters matched
                    //
                    Assert(c->charCount == subStringSize);
                    //  subString matched exactly:
                    //
                    if ((c->suffixCount == 0) ||
                        (c->suffix[0] == (CTrieNode<T, C>*)&g_trie_Sentinel))
                    {
                        //  string already present:
                        //
                        if (pTrieItem != NULL)
                        {
                            *pTrieItem = c->item;
                        }

                        if (options & TRIE_EXCHANGE_ITEM)
                        {
                            Assert(pTrieItem!= NULL);
                            c->item = item;
                        }

                        return(DICT_ITEM_ALREADY_PRESENT);
                    }
                    else
                    {
                        //
                        //  Insert the NULL trie_Sentinel at the front of
                        //  the c->suffix list; and terminate!
                        //
                        //  c should point to new item!
                        //
                        c->AddSuffix(options, (CTrieNode<T, C>*)&g_trie_Sentinel, 0);
                        c->item = item;
                        return( DICT_SUCCESS );

                    }

                }
                else
                {
                    //
                    //  cmp != 0:
                    //

                    if (charsMatched == c->charCount)
                    {
                        //  CASE I: t->string is shorter than subString,
                        //  and all of t->string matched.
                        //  Continue the search through the suffixes subtree:
                        //
                        strIndex += c->charCount;
                        Assert( strIndex < wcslen(string) );
                        subString = &string[strIndex];
                        subStringSize = wcslen(subString);

                        t = c;
                        i = -1;
                        continue;
                    }
                    else
                    {
                        //  CASE II: the child c and subString have a common prefix which is
                        //  a non-NULL strict prefix of c->string.  Split c into the common
                        //  prefix node (a new node which will replace c as a child of t),
                        //  with two children: c (with a corresponding suffix); and a new
                        //  node (with the respective suffix of subString);
                        //

                        c->SplitNode(
                            t,          //  Parent of node to split
                            i,          //  Index of node in parent->suffix
                            subString,  //  String sharing prefix with node->string
                            charsMatched,
                            item,
                            options
                            );
                        return( DICT_SUCCESS );

                    }

                } // end if (cmp == 0)

            } // end if (cmp > 0)

        } // end for

        //
        //  Either the new string was successfully inserted, in which case
        //  we would have returned already; or we reached the end of the
        //  suffix array:
        //

        //
        //  Insert a copy of subString at the end of t->suffix:
        //


        apNewSuffix = new CTrieNode<T, C>(item, options, subString);

        //
        //  Add item parameter to trie_NewNode!
        //
        t->AddSuffix(options, apNewSuffix.Get(), i);
        apNewSuffix.Detach();

        if (t->suffixCount == 1 && t->charCount != 0)
        {
            //
            //  First child of t and t is not the root of the trie;
            //  add a sentinel to t to designate
            //  that t->string is an actual item:
            //
            t->AddSuffix(options, (CTrieNode<T, C>*)&g_trie_Sentinel, 0);

        }
        return DICT_SUCCESS;

   } // end while

   Assert(0);
   return(DICT_ITEM_NOT_FOUND);

} // end trie_Insert

template <class T, class C >
inline DictStatus
CTrie<T, C>::trie_Find(
    const WCHAR * string,         //  A string
    unsigned long options,        //  Search flags
    short outBufferSize,          //  Max number of results wanted
    T ** outBuffer,               //  Buffer to be filled with matching items
    short * resultCount           //  Number of matching prefixes returned
    )

{
    CTrieNode<T, C> * node = root;
    CTrieNode<T, C> * child = NULL;
    int cmp = -1;
    DictStatus status = DICT_ITEM_NOT_FOUND;
    const WCHAR * subString = string;
    size_t strIndex = 0;
    size_t charsMatched = 0;
    int i;

    //  at least one option matches:
    Assert( options &
            (TRIE_SHORTEST_MATCH | TRIE_LONGEST_MATCH | TRIE_ALL_MATCHES)
          );

    //  at most one option matches:
    Assert ( ( ((options & TRIE_SHORTEST_MATCH)>>4) +
               ((options & TRIE_LONGEST_MATCH)>>5) +
               ((options & TRIE_ALL_MATCHES)>>6)
             ) == 1
           );

    //
    //  Initialization:
    //

    Assert(outBufferSize > 0);
    Assert(outBuffer);
    memset(outBuffer, 0, sizeof(CTrieNode<T, C>*) * outBufferSize);

    *resultCount = 0;

    while ( status != DICT_SUCCESS &&
            *resultCount < outBufferSize
          )
    {
        if (child != NULL)
        {
            strIndex += child->charCount;
            subString = &string[strIndex];
            node = child;
        }


        //
        //  Future: low & high can be improved by a partial binary search on
        //  the first character of string in node->suffix:
        //  if (node->suffixSize > threshold)
        //      trie_BinarySearch( &low, &high, subString[0]);
        //

        //
        //  Search in this level sorted alternatives list:
        //
        for ( i = 0;
              i < node->suffixCount;
              i++
            )
        {
            //  Quick "skip check":

            child = node->suffix[i];
            cmp = options & TRIE_IGNORECASE ?
                C::MapToUpper(*child->string) - C::MapToUpper(*subString) :
                *child->string - *subString;

            if ( cmp < 0 )
            {
                continue;
            }
            else
            {
                break;
            }

        } // end for

        Assert(cmp >= 0 || i == node->suffixCount);

        if (cmp != 0)
        {
            //
            //  First character did not match => subString mismatched;
            //  Bail out:
            //

            break;  //  From while loop!
        }

        //
        //  cmp == 0 => first character matched;
        //  Try to match more of subString:
        //
        //  Note: subStringSize == _tcslen(subString);
        //

        cmp = (options & TRIE_IGNORECASE) ?
            child->trie_StrMatchIns(child->string, subString, &charsMatched) :
            child->trie_StrMatch(child->string, subString, &charsMatched);

        Assert(charsMatched <= min(child->charCount, MAX_PATTERN_LENGTH));

        if (charsMatched != child->charCount)
        {
            //
            //  child->string did not match;
            //  there are no more prefixes of string in trie
            //

            //  return (status);
            break;  //  From while loop!
        }
        //
        //  Interesting case: all of child->string matched.
        //

        if (child->item != NULL)
        {
            //
            //  Child represents a real item:
            //  Add child->item to result set:
            //
            outBuffer[*resultCount] = child->item;

            if (0 == cmp)
            {
                status = DICT_SUCCESS;
            }

            if ( (options & TRIE_SHORTEST_MATCH) ==
                 TRIE_SHORTEST_MATCH
               )
            {
                //  (*resultCount)++;
                //  return(status);
                break;  //  From while loop!
            }
            else
            {
                if ( (options & TRIE_ALL_MATCHES) ==
                     TRIE_ALL_MATCHES
                   )
                {
                    (*resultCount)++;
                }
            }

            //
            //  Descend into subtree rooted at child:
            //
            continue;
        }
        else
        {
            //
            //  Child does not represent a real item;
            //  keep looking for matches.
            //  descend into subtree rooted at child:
            //
            continue;
        }

    } // end while

    if ( ((options & TRIE_LONGEST_MATCH)||
         (options & TRIE_SHORTEST_MATCH)) &&
         (outBuffer[*resultCount] != NULL))
    {
        (*resultCount)++;
    }

    return(status);

} // end trie_Find

template <class T, class C >
inline void
CTrie<T, C>::Print()
{
    root->Print(0);
}

#endif // __TRIE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\ftferror.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  FTFError.h
//      Purpose  :  This file contains the definition to ftfs returned errors.
//
//      Project  :  FTFS
//      Component:  Common
//
//      Author   :  urib  (Copied from mapicode.h)
//
//      Log:
//          Jul 15 1996 urib  Creation
//          Oct 15 1996 urib  Add some errors.
//          Feb  3 1997 urib  Declare the map from Win32 error to HRESULT.
//          Sep 16 1997 urib  Add time out error.
//          Feb 26 1998 urib  Move FTF_STATUS error constants from comdefs.
//          Mar 11 1998 dovh  Add FTF_STATUS_REQUEST_QUEUE_ALMOST_FULL status.
//          May 11 1999 dovh  Add FTF_E_ALREADY_INITIALIZED status.
//          Jul 26 1999 urib  Fix constants names.
//          Feb 17 2000 urib  Add unsupported type error.
//          Feb 21 2000 urib  Add unsupported like operator error.
//          Feb 21 2000 urib  Add noise word only query error.
//
////////////////////////////////////////////////////////////////////////////////
#ifndef   FTFERROR_H
#define   FTFERROR_H

#include <winerror.h>

/*
 *  On Windows NT 3.5 and Windows 95, scodes are 32-bit values
 *  laid out as follows:
 *
 *    3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *   |S|R|C|N|r|    Facility         |               Code            |
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *
 *   where
 *
 *      S - Severity - indicates success/fail
 *
 *          0 - Success
 *          1 - Fail (COERROR)
 *
 *      R - reserved portion of the facility code, corresponds to NT's
 *          second severity bit.
 *
 *      C - reserved portion of the facility code, corresponds to NT's
 *          C field.
 *
 *      N - reserved portion of the facility code. Used to indicate a
 *          mapped NT status value.
 *
 *      r - reserved portion of the facility code. Reserved for internal
 *          use. Used to indicate HRESULT values that are not status
 *          values, but are instead message ids for display strings.
 *
 *      Facility - is the facility code
 *          FACILITY_NULL                    0x0
 *          FACILITY_RPC                     0x1
 *          FACILITY_DISPATCH                0x2
 *          FACILITY_STORAGE                 0x3
 *          FACILITY_ITF                     0x4
 *          FACILITY_WIN32                   0x7
 *          FACILITY_WINDOWS                 0x8
 *
 *      Code - is the facility's status code
 *
 */


#define     FACILITY_FTFS                    0x20

/* We do succeed sometimes...                */
#define     FTF_SUCCESS                      0L


/*
 *  We can't use OLE 2.0 macros to build sCodes because the definition has
 *  changed and we wish to conform to the new definition.
 */
#define MAKE_FTF_SCODE(sev,fac,code)                    \
    ((SCODE)        (((unsigned long)(sev)<<31) |       \
                     ((unsigned long)(fac)<<16) |       \
                     ((unsigned long)(code)   )  ))

/* The following two macros are used to build OLE 2.0 style sCodes */

#define MAKE_FTF_E( err )  (MAKE_FTF_SCODE( 1, FACILITY_FTFS, err ))
#define MAKE_FTF_S( warn ) (MAKE_FTF_SCODE( 0, FACILITY_FTFS, warn ))

/* General errors */

#define FTF_E_NOT_ENOUGH_MEMORY         E_OUTOFMEMORY
#define FTF_E_INVALID_PARAMETER         E_INVALIDARG

#define FTF_E_BAD_FORMAT                MAKE_FTF_E(ERROR_BAD_FORMAT)
#define FTF_E_INTERNAL_ERROR            MAKE_FTF_E(ERROR_INTERNAL_ERROR)
#define FTF_E_ITEM_NOT_FOUND            MAKE_FTF_E(ERROR_FILE_NOT_FOUND)
#define FTF_E_ITEM_ALREADY_EXISTS       MAKE_FTF_E(ERROR_FILE_EXISTS)
#define FTF_E_ALREADY_INITIALIZED       MAKE_FTF_E(ERROR_ALREADY_INITIALIZED)

#define FTF_E_TIMEOUT                   MAKE_FTF_E(ERROR_SEM_TIMEOUT)

#define FTF_E_NOT_INITIALIZED           MAKE_FTF_E(OLE_E_BLANK)

#define FTF_E_TOO_BIG                   MAKE_FTF_E( 0x302 )
#define FTF_E_NO_ICORPUSSTATISTICS      MAKE_FTF_E( 0x303 )
#define FTF_E_QUERY_SETS_FULL           MAKE_FTF_E( 0x304 )

#define FTF_W_PARTIAL_COMPLETION        MAKE_FTF_S( 0x313 )
#define FTF_W_ALREADY_INITIALIZED       MAKE_FTF_S( 0x314 )
//
//  FTF_STATUS_ MACRO DEFINITIONS:
//

#define FTF_E_EXPRESSION_PARSING_ERROR  MAKE_FTF_E(12)
#define FTF_E_PATTERN_TOO_SHORT         MAKE_FTF_E(21)
#define FTF_E_PATTERN_TOO_LONG          MAKE_FTF_E(22)
#define FTF_E_UNSUPPORTED_PROPERTY_TYPE MAKE_FTF_E(24)
#define FTF_E_UNSUPPORTED_REGEXP_OP     MAKE_FTF_E(25)
#define FTF_E_TOO_MANY_PROPERTIES       MAKE_FTF_E(26)
#define FTF_E_TOO_MANY_SPECIFIC_ALL     MAKE_FTF_E(27)
#define FTF_E_ONLY_NOISE_WORDS          ((HRESULT)0x80041605L)//QUERY_E_ALLNOISE


//
//  XML STACK ETC...
//
#define FTF_E_STACK_EMPTY               MAKE_FTF_E(201)
#define FTF_E_STACK_UNDERFLOW           MAKE_FTF_E(202)

#endif // FTFERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\vararray.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  VarArray.h
//      Purpose  :  To define a variable size array.
//
//      Project  :  FTFS
//      Component:  Common
//
//      Author   :  urib
//
//      Log:
//          Feb 23 1997 urib  Creation
//          Sep 14 1997 urib  Allow VarArray to behave like a C array - buffer.
//          Oct 21 1997 urib  Fix bug in resizing. Add a GetSize method.
//          Jan 26 1999 urib  Fix bug #23 VarArray constructor bug.
//          Apr 16 2000 LiorM Performance: CVarArray with and w/o ctor dtor
//          Dec 24 2000 urib  Add an initial embedded array
//          Jan  9 2001 urib  Fix a bug in SetSize.
//
////////////////////////////////////////////////////////////////////////////////

#ifndef VARARRAY_H
#define VARARRAY_H

#include <new.h>
#include "Tracer.h"
#include "VarBuff.h"

////////////////////////////////////////////////////////////////////////////////
//
//  CVarArray class definition
//
////////////////////////////////////////////////////////////////////////////////

template <class T, ULONG ulInitialEmbeddedSizeInItems = 1, bool FSIMPLE = false>
class CVarArray :
    // Hide buffer functionallity.
    protected CVarBuffer<T, ulInitialEmbeddedSizeInItems>

{
public:
    typedef CVarBuffer<T, ulInitialEmbeddedSizeInItems> CVarBufferBaseType;

    // Constructor - user can specify recomended initial allocation size.
    CVarArray(ULONG ulInitialSizeInItems = 0)
        :CVarBufferBaseType(ulInitialSizeInItems)
    {
        if (!FSIMPLE)
        {

            ULONG ulCurrent;

            for (ulCurrent = 0; ulCurrent < ulInitialSizeInItems; ulCurrent++)
                Construct(GetCell(ulCurrent));

        }
    }

    // Returns the array size
    ULONG   GetSize()
    {
        return  CVarBufferBaseType::GetSize();
    }

    // Calls the buffer SetSize, and initialize the new cells.
    void    SetSize(ULONG ulNewSizeInItems)
    {
        if (!FSIMPLE)
        {
            ULONG ulSize = GetSize();

            //
            //  Optimization - if the increase is big we do't want to have
            //    several allocation caused by several GetCell calls.
            //
            CVarBufferBaseType::SetSize(ulNewSizeInItems);

            ULONG ulCurrent;

            //
            //  If size is decreasing destruct the erased cells
            //
            for (ulCurrent = ulNewSizeInItems; ulCurrent < ulSize; ulCurrent++)
                Destruct(GetCell(ulCurrent));

            //
            //  If size is increasing construct the new cells
            //
            for (ulCurrent = ulSize; ulCurrent < ulNewSizeInItems; ulCurrent++)
                Construct(GetCell(ulCurrent));
        }

        //
        //  Mark the true current size
        //
        CVarBufferBaseType::SetSize(ulNewSizeInItems);

        Assert(GetSize() == ulNewSizeInItems);
    }

    // Act like an array.
    T& operator[](ULONG ul)
    {
        return *GetCell(ul);
    }

    // Act like a C array - memory buffer.
    operator T* ()
    {
        return GetCell(0);
    }

    // Call cells destructors
    ~CVarArray()
    {
        if (!FSIMPLE)
        {
            ULONG ulCurrent;
            for (ulCurrent = 0; ulCurrent < GetSize(); ulCurrent++)
            {
                T* pt = GetCell(ulCurrent);

                Destruct(pt);
            }
        }
    }

  protected:
    // Helper fuction to return the address on a cell.
    T*  GetCell(ULONG ul)
    {
        if (GetSize() < ul + 1)
            SetSize(ul + 1);

        return GetBuffer() + ul;
    }

    static
    T*  Construct(void* p)
    {
#ifdef _PQS_LEAK_DETECTION
#undef new
#endif
        return new(p) T();
#ifdef _PQS_LEAK_DETECTION
#define new DEBUG_NEW
#endif
    }

    static
    void Destruct(T* pt)
    {
        pt->~T();
    }
};





#endif /* VARARRAY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\synchro.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  Synchro.h
//      Purpose  :  Synchronization objects
//
//      Project  :  Common
//      Component:
//
//      Author   :  urib
//
//      Log:
//          Aug 28 1997 urib  Creation.
//          Sep 16 1997 urib  Add CSyncMutexCatcher
//          Nov 13 1997 urib  Add interlocked  mutex.
//          Feb 18 1997 urib  Add critical section class to lock C style critical
//                              sections.(With DovH)
//
////////////////////////////////////////////////////////////////////////////////

#ifndef SYNCHRO_H
#define SYNCHRO_H

#include "Tracer.h"
#include "Excption.h"
#include "AutoHndl.h"

class ASyncObject;
class CSyncMutex;
class CSyncCriticalSection;
class CSyncOldCriticalSection;
class CSyncInterlockedMutex;
class CSyncMutexCatcher;

////////////////////////////////////////////////////////////////////////////////
//
//  ASyncMutexObject abstract class definition
//
////////////////////////////////////////////////////////////////////////////////

class ASyncMutexObject
{
  public:
    virtual void Lock(ULONG ulTimeOut = 60 * 1000) = NULL;
    virtual void Unlock() = NULL;
};

////////////////////////////////////////////////////////////////////////////////
//
//  CSyncMutex class definition
//
////////////////////////////////////////////////////////////////////////////////

class CSyncMutex : public ASyncMutexObject
{
  public:
    CSyncMutex(
        LPSECURITY_ATTRIBUTES   lpMutexAttributes = NULL,
        BOOL                    bInitialOwner = FALSE,
        LPCTSTR                 lpName = NULL)
    {
        m_ahMutex = CreateMutex(lpMutexAttributes, bInitialOwner, lpName);
        if(IS_BAD_HANDLE(m_ahMutex))
        {
            Trace(
                elError,
                tagError,(
                "CSyncMutex:"
                "Could not create mutex"));

            throw CWin32ErrorException();
        }
    }

    virtual void Lock(ULONG ulTimeOut)
    {
        DWORD   dwWaitResult;

        dwWaitResult = WaitForSingleObject(m_ahMutex, ulTimeOut);
        if (WAIT_ABANDONED == dwWaitResult)
        {
            Trace(
                elError,
                tagError,(
                "CSyncMutex:"
                "Mutex abandoned"));
        }
        else if (WAIT_TIMEOUT == dwWaitResult)
        {
            Trace(
                elError,
                tagError,(
                "CSyncMutex:"
                "Timeout"));
            throw CWin32ErrorException(ERROR_SEM_TIMEOUT);
        }
        else if (WAIT_FAILED == dwWaitResult)
        {
            IS_FAILURE(FALSE);
            Trace(
                elError,
                tagError,(
                "CSyncMutex:"
                "Wait for single object failed with error %d",
                GetLastError()));
            throw CWin32ErrorException();
        }

        Assert(WAIT_OBJECT_0 == dwWaitResult);
    }

    virtual void Unlock()
    {
        if (IS_FAILURE(ReleaseMutex(m_ahMutex)))
        {
            Trace(
                elError,
                tagError,(
                "~CSyncMutex:"
                "ReleaseMutex failed"));
        }
    }

    operator HANDLE()
    {
        return m_ahMutex;
    }
  protected:
    CAutoHandle m_ahMutex;
};

////////////////////////////////////////////////////////////////////////////////
//
//  CSyncCriticalSection class implementation
//
////////////////////////////////////////////////////////////////////////////////

class ASyncCriticalSection : protected CRITICAL_SECTION, public ASyncMutexObject
{
  public:

    ~ASyncCriticalSection()
    {
        DeleteCriticalSection(this);
    }

    virtual void Lock(ULONG = 0)
    {
        EnterCriticalSection(this);
    }

    virtual void Unlock()
    {
        LeaveCriticalSection(this);
    }
};

class CSyncCriticalSection : public ASyncCriticalSection
{
  public:
    CSyncCriticalSection()
    {
        InitializeCriticalSection(this);
    }
};

#if _WIN32_WINNT >= 0x0500
class CSyncCriticalSectionWithSpinCount : public ASyncCriticalSection
{
  public:
    CSyncCriticalSectionWithSpinCount(ULONG ulSpinCount = 4000)
    {
        InitializeCriticalSectionAndSpinCount(this, ulSpinCount);
    }
};
#endif

////////////////////////////////////////////////////////////////////////////////
//
//  CSyncOldCriticalSection class implementation
//
////////////////////////////////////////////////////////////////////////////////

class CSyncOldCriticalSection : public ASyncMutexObject
{
  public:
    CSyncOldCriticalSection(CRITICAL_SECTION* pCriticalSection)
        :m_pCriticalSection(pCriticalSection) {}

    virtual void Lock(ULONG = 0)
    {
        EnterCriticalSection(m_pCriticalSection);
    }

    virtual void Unlock()
    {
        LeaveCriticalSection(m_pCriticalSection);
    }

  protected:
    CRITICAL_SECTION *m_pCriticalSection;
};

////////////////////////////////////////////////////////////////////////////////
//
//  CSyncInterlockedMutex class definition
//
////////////////////////////////////////////////////////////////////////////////

class CSyncInterlockedMutex :public ASyncMutexObject
{
  public:
    CSyncInterlockedMutex()
        :m_lMutex(FALSE)
    {
    }

    virtual void Lock(ULONG ulTimeOut = 60 * 1000)
    {
        ULONG ulWaiting = 0;

        LONG    lLastValue;

        while (lLastValue = InterlockedExchange(&m_lMutex, 1))
        {
            Sleep(100);
            if ((ulWaiting += 100) > ulTimeOut)
            {
                throw CGenericException(L"TimeOut");
            }
        }
    }

    virtual void Unlock()
    {
        m_lMutex = FALSE;
    }

  private:
    LONG   m_lMutex;
};

////////////////////////////////////////////////////////////////////////////////
//
//  CSyncMutexCatcher class implementation
//
////////////////////////////////////////////////////////////////////////////////

class CSyncMutexCatcher
{
  public:
    CSyncMutexCatcher(ASyncMutexObject& smo, ULONG ulTimeOut = 60 * 1000)
        :m_refSyncObject(smo)
    {
        m_refSyncObject.Lock();
    }

    ~CSyncMutexCatcher()
    {
        m_refSyncObject.Unlock();
    }

  private:
    ASyncMutexObject&   m_refSyncObject;
};


#endif // SYNCHRO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\excption.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  Excption.h
//      Purpose  :  To define the generic exception.
//
//      Project  :  pqs
//      Component:  Common
//
//      Author   :  urib
//
//      Log:
//          Jan 19 1997 urib  Creation
//          Mar  2 1997 urib  Add win32 error exception.
//          Jun 25 1997 urib  Move definition  of translator class to header.
//                              Change name to CExceptionTranslatorSetter.
//                              This is done because every thread needs to use
//                              it as it enters our scope.
//          Sep 16 1997 urib  Supply default parameter to CWin32ErrorException.
//          Oct 21 1997 urib  Added macros to throw exceptions that know their
//                            location.
//          Feb 12 1998 urib  Print error information from within Hresult
//                              Exception.
//          Feb 17 1998 urib  Move translator code from cpp to header.
//          Jun 22 1998 yairh add GetFile & GetLine methods
//          Jul 19 1998 urib  Specify calling convention on exception translator
//                              function.
//          Aug 17 1998 urib  Remove the ... catch clause.
//          Jan 10 1999 urib  Support a throwing new.
//          Jan 21 1999 urib  Fix THROW macros to force arguments to be WCHAR
//                              string even in non UNICODE environment.
//          Feb  1 1999 urib  Add null pointer exception. Add throwing new to
//                              COM macros.
//          Mar 15 2000 urib  Add missing "leaving function" trace.
//          Apr 12 2000 urib  Move new manipulation to memory management module.
//          Sep  6 2000 urib  Fix EnterLeave macros.
//          Oct 25 2000 urib  Check allocation failure on Generic exception.
//
////////////////////////////////////////////////////////////////////////////////

#ifndef EXCPTION_H
#define EXCPTION_H

#include <eh.h>
#include <stdexcpt.h>
#include "Tracer.h"
#include "AutoPtr.h"
#include "FtfError.h"


////////////////////////////////////////////////////////////////////////////////
//
//  CException class definition
//
////////////////////////////////////////////////////////////////////////////////

class CException
{
  public:
    CException(PWSTR pwszFile = NULL, ULONG ulLine = 0)
    {
        m_pwszFile = pwszFile;
        m_ulLine = ulLine;

        Trace(
            elError,
            tagError,(
            "CException:"
            "on file %S, line %d",
            (pwszFile ? pwszFile :
                L"Fix this exception to return "
                L"a file and line"),
            ulLine));
    }

    // Get an error string.
    virtual
    BOOL GetErrorMessage(
        PWSTR   pwszError,
        UINT    nMaxError,
        PUINT   pnHelpContext = NULL ) = NULL;

#if 0
    // Notify via message box.
    virtual
    int ReportError(
        UINT nType      = MB_OK,
        UINT nMessageID = 0 )
    {
        UNREFERENCED_PARAMETER(nMessageID);

        WCHAR   rwchErrorString[1000];

        GetErrorMessage(rwchErrorString, 1000);

        return MessageBoxW(
            NULL,
            rwchErrorString,
            L"Exception occured",
            nType);
    }
#endif

    virtual
    ~CException(){};

    PWSTR GetFile() { return m_pwszFile; }
    ULONG GetLine() { return m_ulLine; }

    virtual void PrintErrorMsg(
                char* pszFunction,
                ULONG_PTR dwThis,
                char* pszFile,
                int iLine,
                TAG tag = 0)
    {
        WCHAR   rwchError[1000];

        GetErrorMessage(rwchError, sizeof(rwchError)/sizeof(WCHAR));

        Trace(
            elError,
            tag,(
            "COM Exception Catcher:"
            "%s (this = %#x) threw an exception. "
            "Error is message\"%S\". "
            "Caught in file %s line %d.",
            pszFunction,
            dwThis,
            rwchError,
            pszFile,
            iLine));

    }

  protected:
    PWSTR   m_pwszFile;
    ULONG   m_ulLine;
};

////////////////////////////////////////////////////////////////////////////////
//
//  CStructuredException class definition
//
////////////////////////////////////////////////////////////////////////////////

class CStructuredException : public CException
{
  public:
    CStructuredException(UINT uiSeCode)
        :m_uiSeCode(uiSeCode){};

    // Get an error string.
    virtual
    BOOL GetErrorMessage(
        PWSTR   pwszError,
        UINT    nMaxError,
        PUINT   pnHelpContext = NULL )
    {
        UNREFERENCED_PARAMETER(pnHelpContext);

        int iRet;
        iRet = _snwprintf(
            pwszError,
            nMaxError,
            L"Structured exception %#X",
            GetExceptionCode());

        pwszError[nMaxError - 1] = '\0';

        return iRet;
    }

    // Return the exception code.
    UINT
    GetExceptionCode()
    {
        return m_uiSeCode;
    }

    // The translator.
    static
    void _cdecl Translator(UINT ui, EXCEPTION_POINTERS*)
    {
        throw CStructuredException(ui);
    }

  private:
    UINT m_uiSeCode;

};


////////////////////////////////////////////////////////////////////////////////
//
//  CGenericException class definition
//
////////////////////////////////////////////////////////////////////////////////

class CGenericException : public CException
{
  public:
    CGenericException(LPWSTR pwszTheError)
    {
        m_apwszTheError = _wcsdup(pwszTheError);
        if (!m_apwszTheError.IsValid())
        {
            m_apwszTheError =
                L"Memory allocation failed in the exception object creation";

            m_apwszTheError.Detach();
        }
    }

    // Get an error string.
    virtual
    BOOL GetErrorMessage(
        PWSTR   pwszError,
        UINT    nMaxError,
        PUINT   pnHelpContext = NULL )
    {
        UNREFERENCED_PARAMETER(pnHelpContext);

        int iRet;
        iRet = _snwprintf(
            pwszError,
            nMaxError,
            L"%s",
            m_apwszTheError);

        pwszError[nMaxError - 1] = '\0';

        return iRet;
    }

  private:
    CAutoMallocPointer<WCHAR>   m_apwszTheError;

};

////////////////////////////////////////////////////////////////////////////////
//
//  CHresultException class definition
//
////////////////////////////////////////////////////////////////////////////////

class CHresultException : public CException
{
  public:
    CHresultException(HRESULT   hrResult = E_FAIL,
                      PWSTR     pwszFile = NULL,
                      ULONG     ulLine = 0)
        :m_hrResult(hrResult), CException(pwszFile, ulLine)
    {
        WCHAR   rwchError[1000];

        GetErrorMessage(rwchError, sizeof(rwchError)/sizeof(WCHAR));

        Trace(
            elError,
            tagError,(
            "Exception:"
            "%S",
            rwchError));
    }

    // Get an error string.
    virtual
    BOOL GetErrorMessage(
        PWSTR   pwszError,
        UINT    nMaxError,
        PUINT   pnHelpContext = NULL )
    {
        UNREFERENCED_PARAMETER(pnHelpContext);

        int iRet;
        iRet = _snwprintf(
            pwszError,
            nMaxError,
            L"HResult exception %#X",
            m_hrResult);

        pwszError[nMaxError - 1] = '\0';

        return iRet;
    }

    operator HRESULT()
    {
        return m_hrResult;
    }

    virtual void PrintErrorMsg(
                char* pszFunction,
                ULONG_PTR dwThis,
                char* pszFile,
                int iLine,
                DWORD dwError,
                TAG tag = 0)
    {
        WCHAR   rwchError[1000];

        GetErrorMessage(rwchError, sizeof(rwchError)/sizeof(WCHAR));

        Trace(
            elError,
            tag,(
            "COM Exception Catcher:"
            "%s (this = %#x) threw an hresult(%#x) exception. "
            "Error message is \"%S\". "
            "Caught in file %s line %d.",
            pszFunction,
            dwThis,
            dwError,
            rwchError,
            pszFile,
            iLine));

    }

  protected:
    HRESULT m_hrResult;

};

////////////////////////////////////////////////////////////////////////////////
//
//  CWin32ErrorException class definition
//
////////////////////////////////////////////////////////////////////////////////

class CWin32ErrorException : public CHresultException
{
  public:
    CWin32ErrorException(LONG   lResult = GetLastError(),
                         PWSTR  pwszFile = NULL,
                         ULONG  ulLine = 0)
        :CHresultException(MAKE_FTF_E(lResult), pwszFile, ulLine){}
};

////////////////////////////////////////////////////////////////////////////////
//
//  CMemoryException class definition
//
////////////////////////////////////////////////////////////////////////////////

class CMemoryException : public CWin32ErrorException
{
  public:
    CMemoryException(PWSTR pwszFile = NULL, ULONG ulLine = 0)
        :CWin32ErrorException(E_OUTOFMEMORY, pwszFile, ulLine){};

    // Get an error string.
    virtual
    BOOL GetErrorMessage(
        PWSTR   pwszError,
        UINT    nMaxError,
        PUINT   pnHelpContext = NULL )
    {
        UNREFERENCED_PARAMETER(pnHelpContext);

        int iRet;
        iRet = _snwprintf(pwszError, nMaxError, L"Memory exception !!!");
        pwszError[nMaxError - 1] = '\0';

        return iRet;
    }
};

////////////////////////////////////////////////////////////////////////////////
//
//  Macros for exception throwing and catching
//
////////////////////////////////////////////////////////////////////////////////
#define __PQWIDE(str) L##str
#define PQWIDE(str) __PQWIDE(str)

#define THROW_MEMORY_EXCEPTION()                 \
    throw CMemoryException(PQWIDE(__FILE__), __LINE__)

#define THROW_HRESULT_EXCEPTION(hr)                 \
    throw CHresultException(hr, PQWIDE(__FILE__), __LINE__)

#define THROW_WIN32ERROR_EXCEPTION(hr)                 \
    throw CWin32ErrorException(hr, PQWIDE(__FILE__), __LINE__)


#if (defined (DEBUG) && !defined(_NO_TRACER)) || defined(USE_TRACER)

class   CEnterLeavePrinting
{
public:
    CEnterLeavePrinting(TAG tag, char* pszFuncName, void* pThisPointer)
        :m_tag(tag)
        ,m_pszFuncName(pszFuncName)
        ,m_pThisPointer(pThisPointer)
    {
        Trace(
            elVerbose,
            m_tag,(
            "Entering %s (this = %#x):",
            m_pszFuncName,
            pThisPointer));
    }
    ~CEnterLeavePrinting()
    {
        Trace(
            elVerbose,
            m_tag,(
            "Leaving  %s (this = %#x):",
            m_pszFuncName,
            m_pThisPointer));
    }
protected:

    TAG     m_tag;
    char*   m_pszFuncName;
    void*   m_pThisPointer;
};


//
//  Use this macro at the beginning of an HRESULT COM method
//
#define BEGIN_STDMETHOD(function, tag)                                      \
CEnterLeavePrinting print(tag, #function, this);                            \
try                                                                         \
{

//
//  Use this macro at the end of an HRESULT COM method
//
#define END_STDMETHOD(function, tag)                                        \
}                                                                           \
catch(CHresultException& hre)                                               \
{                                                                           \
    hre.PrintErrorMsg(                                                      \
                #function,                                                  \
                (ULONG_PTR)this,                                            \
                __FILE__,                                                   \
                __LINE__,                                                   \
                (HRESULT)hre),                                              \
                tag;                                                        \
    return hre;                                                             \
}                                                                           \
catch(CException& e)                                                        \
{                                                                           \
    e.PrintErrorMsg(                                                        \
                #function,                                                  \
                (ULONG_PTR)this,                                            \
                __FILE__,                                                   \
                __LINE__,                                                   \
                tag);                                                       \
    return E_FAIL;                                                          \
}

//
//  Use this macro at the end of a void COM method
//
#define END_VOIDMETHOD(function, tag)                                       \
}                                                                           \
catch(CHresultException& hre)                                               \
{                                                                           \
    hre.PrintErrorMsg(                                                      \
                #function,                                                  \
                (ULONG_PTR)this,                                            \
                __FILE__,                                                   \
                __LINE__,                                                   \
                tag,                                                        \
                (HRESULT)hre);                                              \
}                                                                           \
catch(CException& e)                                                        \
{                                                                           \
    e.PrintErrorMsg(                                                        \
                #function,                                                  \
                (ULONG_PTR)this,                                            \
                __FILE__,                                                   \
                __LINE__,                                                   \
                tag                                                         \
               );                                                           \
}
#else

//
//  Use this macro at the beginning of an HRESULT COM method
//
#define BEGIN_STDMETHOD(function, tag)                                      \
try                                                                         \
{

//
//  Use this macro at the end of an HRESULT COM method
//
#define END_STDMETHOD(function, tag)                                        \
}                                                                           \
catch(CHresultException& hre)                                               \
{                                                                           \
    hre.PrintErrorMsg(                                                      \
                #function,                                                  \
                (ULONG_PTR)this,                                            \
                __FILE__,                                                   \
                __LINE__,                                                   \
                (HRESULT)hre);                                              \
    return hre;                                                             \
}                                                                           \
catch(CException& e)                                                        \
{                                                                           \
    e.PrintErrorMsg(                                                        \
                #function,                                                  \
                (ULONG_PTR)this,                                            \
                __FILE__,                                                   \
                __LINE__);                                                  \
    return E_FAIL;                                                          \
}

//
//  Use this macro at the end of a void COM method
//
#define END_VOIDMETHOD(function, tag)                                       \
}                                                                           \
catch(CHresultException& hre)                                               \
{                                                                           \
    hre.PrintErrorMsg(                                                      \
                #function,                                                  \
                (ULONG_PTR)this,                                            \
                __FILE__,                                                   \
                __LINE__,                                                   \
                (HRESULT)hre);                                              \
}                                                                           \
catch(CException& e)                                                        \
{                                                                           \
    e.PrintErrorMsg(                                                        \
                #function,                                                  \
                (ULONG_PTR)this,                                            \
                __FILE__,                                                   \
                __LINE__);                                                  \
}

#endif // DEBUG
#endif /* EXCPTION_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\vartypes.h ===
/*//////////////////////////////////////////////////////////////////////////////
//
//      Filename :  VarTypes.h
//      Purpose  :  To define vaiable legth data types.
//                    Contains:
//                      CVarBuffer
//                      CVarString
//                      CVarArray
//
//      Project  :  FTFS
//      Component:  Common
//
//      Author   :  urib
//
//      Log:
//          Jan 30 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/

#ifndef VARTYPES_H
#define VARTYPES_H

#include "Base.h"
#include "AutoPtr.h"
#include "Excption.h"

/* An automatic string */
#include "VarStr.h"

/* An automatic buffer */
#include "VarBuff.h"

/* An automatic buffer */
#include "VarArray.h"

#endif /* VARTYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\varbuff.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  VarBuff.h
//      Purpose  :  To hold the definition for the variable length buffer.
//                    One should remember not to take pointers into the buffer
//                    since it can be reallocated automatically.
//                    Errors are reported via exceptions (CMemoryException()).
//
//      Project  :  FTFS
//      Component:
//
//      Author   :  urib
//
//      Log:
//          Feb  2 1997 urib  Creation
//          Feb 25 1997 urib  Fix compilation error in constructor.
//          Jan 26 1999 urib  Allow zero initial size.
//          May  1 2000 urib  Allow specification of allocated size.
//          May 14 2000 urib  Add support for embedded initial array.
//
////////////////////////////////////////////////////////////////////////////////

#ifndef VARBUFF_H
#define VARBUFF_H

#include "Excption.h"
#include "AutoPtr.h"

////////////////////////////////////////////////////////////////////////////////
//
//  CVarBuffer class definition
//
////////////////////////////////////////////////////////////////////////////////

template<class T, ULONG ulInitialEmbeddedSizeInItems = 1>
class CVarBuffer
{
  public:
    // Constructor
    CVarBuffer(ULONG ulInitialSizeInItems = 0,
               ULONG ulInitialAllocatedSizeInItems = 10);

    // Concatenates the given buffer to this buffer.
    void    Cat(ULONG ulItems, T* pMemory);

    // Copies the given buffer to this buffer.
    void    Cpy(ULONG ulItems, T* pMemory);

    // Return the buffer's memory.
    T*      GetBuffer();

    // Returns the buffer's size. The size is set by the initial value given to
    //   the constructor, Cat, Cpy, operations beyond the current size or Calls
    //   to the SetSize function.
    ULONG   GetSize();

    // Set the buffer minimal size.
    void    SetSize(ULONG ulNewSizeInItems);

    // Act as a buffer.
    operator T*();

  protected:

    // This function enlarges the array.
    void    Double();

    bool    IsAllocated();

    T*      GetEmbeddedArray();

    // A pointer to the buffer
    CAutoMallocPointer<T>   m_aptBuffer;

    // An embedded initial buffer
    byte    m_rbEmbeddedBuffer[ulInitialEmbeddedSizeInItems * sizeof(T)];

    // The used portion of the buffer.
    ULONG   m_ulSizeInItems;

    // The allocated portion of the buffer.
    ULONG   m_ulAllocatedInItems;
};

//////////////////////////////////////////////////////////////////////////////*/
//
//  CVarBuffer class implementation
//
//////////////////////////////////////////////////////////////////////////////*/

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulInitialEmbeddedSizeInItems>::CVarBuffer
//      Purpose  :  Initialize the buffer, allocate memory.
//                    Set the used buffer size to be ulInitialSizeInItems.
//                    May throw a CMemoryException on low memory.
//
//      Parameters:
//          [in]    ULONG ulInitialSizeInItems
//
//      Returns  :   [N/A]
//
//      Log:
//          Feb 25 1997 urib  Creation
//          Jan 28 1999 urib  Allow 0 size buffers.
//          May  1 2000 urib  Allow specification of allocated size.
//
////////////////////////////////////////////////////////////////////////////////
template<class T, int ulInitialEmbeddedSizeInItems>
inline
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::CVarBuffer(
        ULONG ulInitialSizeInItems,
        ULONG ulInitialAllocatedSizeInItems)
    :m_aptBuffer(GetEmbeddedArray(), false)
    ,m_ulSizeInItems(ulInitialSizeInItems)
    ,m_ulAllocatedInItems(ulInitialEmbeddedSizeInItems)
{
    //
    //  Allocation cannot be smaller than size.
    //
    if (ulInitialAllocatedSizeInItems < ulInitialSizeInItems)
    {
        ulInitialAllocatedSizeInItems = ulInitialSizeInItems;
    }

    //
    //  Allocate if needed.
    //
    if (m_ulAllocatedInItems < ulInitialAllocatedSizeInItems)
    {
        m_aptBuffer = (T*) malloc (sizeof(T) * ulInitialAllocatedSizeInItems);
        if(!m_aptBuffer.IsValid())
        {
            THROW_MEMORY_EXCEPTION();
        }

        m_ulAllocatedInItems = ulInitialAllocatedSizeInItems;
    }
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulInitialEmbeddedSizeInItems>::Cat
//      Purpose  :  Concatenate this memory to the buffer's end. Reallocates
//                    if needed. Sets the size to the size before the
//                    call + ulItems.
//                    May throw a CMemoryException on low memory.
//
//      Parameters:
//          [in]    ULONG   ulItems
//          [in]    T*      ptMemory
//
//      Returns  :   [N/A]
//
//      Log:
//          Feb 25 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
template<class T, int ulInitialEmbeddedSizeInItems>
inline
void
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::Cat(ULONG ulItems, T* ptMemory)
{
    // Remember the size before changing it
    ULONG ulLastSize = m_ulSizeInItems;

    // Change the size - allocate if needed
    SetSize(m_ulSizeInItems + ulItems);

    // Copy the new data to the buffer
    memcpy(GetBuffer() + ulLastSize, ptMemory, ulItems * sizeof(T));
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulInitialEmbeddedSizeInItems>::Cpy
//      Purpose  :  Copy this memory to the buffer (from the beginning).
//                    Set the used buffer size to be ulItems.
//                    May throw a CMemoryException on low memory.
//
//      Parameters:
//          [in]    ULONG   ulItems
//          [in]    T*      ptMemory
//
//      Returns  :   [N/A]
//
//      Log:
//          Feb 25 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
template<class T, int ulInitialEmbeddedSizeInItems>
inline
void
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::Cpy(ULONG ulItems, T* ptMemory)
{
    m_ulSizeInItems = 0;
    Cat(ulItems, ptMemory);
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulInitialEmbeddedSizeInItems>::GetBuffer
//      Purpose  :  Return the actual memory. Don't save the return value in a
//                    pointer since the buffer may reallocate. Save the offset.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   T* - the buffer.
//
//      Log:
//          Feb 25 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
template<class T, int ulInitialEmbeddedSizeInItems>
inline
T*
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::GetBuffer()
{
    return m_aptBuffer.Get();
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulInitialEmbeddedSizeInItems>::GetSize
//      Purpose  :  Return the size of the buffer. The return value of this
//                    function is set by SetSize, Cpy, Cat, and the size
//                    specified in the constructor.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   ULONG
//
//      Log:
//          Feb 25 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
template<class T, int ulInitialEmbeddedSizeInItems>
inline
ULONG
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::GetSize()
{
    return m_ulSizeInItems;
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulInitialEmbeddedSizeInItems>::SetSize
//      Purpose  :  Sets the size in items to be ulNewSizeInItems.
//                    May throw a CMemoryException on low memory.
//
//      Parameters:
//          [in]    ULONG ulNewSizeInItems
//
//      Returns  :   [N/A]
//
//      Log:
//          Feb 25 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
template<class T, int ulInitialEmbeddedSizeInItems>
inline
void
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::SetSize(ULONG ulNewSizeInItems)
{
    // While the buffer is not in the proper size keep growing.
    while (ulNewSizeInItems > m_ulAllocatedInItems)
        Double();

    // OK. We're big. Set the size.
    m_ulSizeInItems = ulNewSizeInItems;
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulInitialEmbeddedSizeInItems>::operator void*()
//      Purpose  :  To return a pointer to the buffer.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   T*
//
//      Log:
//          Feb 25 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
template<class T, int ulInitialEmbeddedSizeInItems>
inline
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::operator T*()
{
    return GetBuffer();
}

/*//////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulInitialEmbeddedSizeInItems>::Double
//      Purpose  :  Double the alocated memory size. Not the used size.
//                    May throw a CMemoryException on low memory.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   [N/A]
//
//      Log:
//          Feb 25 1997 urib Creation
//
//////////////////////////////////////////////////////////////////////////////*/
template<class T, int ulInitialEmbeddedSizeInItems>
inline
void
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::Double()
{
    ULONG ulNewAllocatedSizeInItems = 2 * m_ulAllocatedInItems;

    T* ptTemp;

    if (!IsAllocated())
    {
        ptTemp = (T*)malloc(ulNewAllocatedSizeInItems * sizeof(T));
        if (!ptTemp)
        {
            THROW_MEMORY_EXCEPTION();
        }

        memcpy(ptTemp, m_aptBuffer.Get(), m_ulSizeInItems * sizeof(T));
    }
    else
    {
        ptTemp = (T*)realloc(m_aptBuffer.Get(),
            ulNewAllocatedSizeInItems * sizeof(T));
        if (!ptTemp)
        {
            THROW_MEMORY_EXCEPTION();
        }

        m_aptBuffer.Detach();
    }

    m_aptBuffer = ptTemp;

    m_ulAllocatedInItems = ulNewAllocatedSizeInItems;
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulInitialEmbeddedSizeInItems>::::IsAllocated()
//      Purpose  :  A predicate to easily test if we still use the embedded
//                    array or not.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   bool - true - an alternative array was allocated.
//
//      Log:
//          May 14 2000 urib  Creation
//
////////////////////////////////////////////////////////////////////////////////

template<class T, int ulInitialEmbeddedSizeInItems>
inline
bool
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::IsAllocated()
{
    return m_aptBuffer.Get() != GetEmbeddedArray();
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  CVarBuffer<T, ulIni...zeInItems>::GetEmbeddedArray()
//      Purpose  :  Return the embedded array.
//
//      Parameters:
//          [N/A]
//
//      Returns  :   [N/A]
//
//      Log:
//          May 14 2000 urib  Creation
//
////////////////////////////////////////////////////////////////////////////////

template<class T, int ulInitialEmbeddedSizeInItems>
inline
T*
CVarBuffer<T, ulInitialEmbeddedSizeInItems>::GetEmbeddedArray()
{
    return (T*) m_rbEmbeddedBuffer;
}

#endif /* VARBUFF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\baseapi.cpp ===
// =========================================================================
//  Copyright (C) 1997 - 1998, Microsoft Corporation.  All Rights Reserved.
//
// File Name  : BASEAPI.CPP
// Function   : NLP BASE ENGINE API Definition
// =========================================================================

#include    <string.h>
#include    <malloc.h>
#include    <sys\stat.h>

#include    "basecore.hpp"
#include    "basecode.hpp"
#include    "basedef.hpp"
#include    "basegbl.hpp"
#include    "MainDict.h"

extern int Compose_RIEUL_Irregular (char *, char *);
extern int Compose_HIEUH_Irregular (char *, char *);
extern int Compose_PIEUP_Irregular (char *, char *);
extern int Compose_TIEUT_Irregular (char *, char *);
extern int Compose_SIOS_Irregular (char *, char *);
extern BOOL Compose_YEO_Irregular (char *, char *);
extern BOOL Compose_REO_REU_Irregular (char *, char *);
extern BOOL Compose_GEORA_Irregular (char *, char *);
extern BOOL Compose_Regular (char *, char *);

extern void      SetSilHeosa (int, WORD *);

#include    "stemkor.h"


// by dhyu -- 1996. 1
typedef struct
{
    LPCSTR    contract;
    LPCSTR  noconstract;
} contract_tossi;

contract_tossi ContractTossi [] =
{
{ "\xa4\xa4", "\xB4\xC2"},
{ "\xA4\xA9", "\xB8\xA6"},
{ "\xA4\xA4\xC4\xBF\xB3\xE7", "\xB4\xC2\xC4\xBF\xB3\xE7"},
{ NULL, NULL}
};

/*
char ChangableFirstStem [][2] =
{
    {__K_D_D, __V_m},        // ssangtikeut, eu
    {

}
*/

inline
BOOL isHANGEUL(char cCh1,char cCh2)
{
    unsigned char ch1,ch2 ;

    ch1=(unsigned char)cCh1;
    ch2 =(unsigned char)cCh2;

    if ( ((ch1 >= 0xb0)  && (ch1 <= 0xc8)) && (ch2>=0xa1) )
        return TRUE;
    else if ( ((ch1 >= 0x81) && (ch1 <= 0xc5)) && ( ((ch2 >= 0x41) && (ch2 <= 0x5a)) || ((ch2 >= 0x61) && (ch2 <= 0x7a)) || ((ch2 >= 0x81) && (ch2 <= 0xa0)) ) )
        return TRUE;
    else if ( ((ch1 >= 0x81) && (ch1 <= 0xa0)) && (ch2 >= 0xa1) )
        return TRUE;
    //else if ( ((ch1 >= 0xca) && (ch1 <= 0xfe)) && (ch2 >= 0xa1) )
    //    return TRUE;
    else if ((ch1 == 0xa4) && (ch2 >= 0xa1))
        return TRUE;

    return FALSE;
}

WINSRC StemmerInit(HSTM  *hStm)    // Stemmer Engine session Handle
{
    STMI    *pstmi;
    HGLOBAL     hgbl;


    hgbl = GlobalAlloc(GHND, sizeof(STMI));
    if (hgbl == NULL)   return FAIL;
    else
        *hStm = (HSTM) hgbl;

    pstmi = (STMI*)GlobalLock(hgbl);
    if (pstmi == NULL) return FAIL;

    pstmi->Option = 0x00000000;

    GlobalUnlock(hgbl);
    return  NULL;     // normal operation
}

WINSRC StemmerSetOption (HSTM hStm, UINT Option)
{
    STMI    *pstmi;
    HGLOBAL hgbl = (HGLOBAL) hStm;

    pstmi = (STMI *)GlobalLock(hgbl);

    if (pstmi == NULL)
    {
        MessageBox (NULL, "StemmerSetOption", "Fail", MB_OK);
        GlobalUnlock(hgbl);
        return srcModuleError | srcInvalidID;
    }

    pstmi->Option = Option;

    GlobalUnlock (hgbl);
    return NULL;
}

WINSRC StemmerGetOption (HSTM hStm, UINT *Option)
{
    STMI    *pstmi;
    HGLOBAL hgbl = (HGLOBAL) hStm;

    pstmi = (STMI *)GlobalLock(hgbl);
    if (pstmi == NULL)
    {
        GlobalUnlock(hgbl);
        return srcModuleError | srcInvalidID;
    }


    *Option = pstmi->Option;

    GlobalUnlock (hgbl);
    return NULL;
}

WINSRC StemmerOpenMdr(HSTM sid, char  *lpspathMain) // Dictionary File path
{
    STMI    *pstmi;
    HGLOBAL    hgbl;

    hgbl = (HGLOBAL) sid;
    pstmi = (STMI  *)GlobalLock(hgbl);
    if (pstmi == NULL)
    {
        GlobalUnlock(hgbl);
        return srcModuleError | srcInvalidID;
    }

    if (lstrlen(lpspathMain) == 0)
    {
        GlobalUnlock(hgbl);
        return srcIOErrorMdr | srcInvalidMdr;
    }


    if (!OpenMainDict (lpspathMain))
    {
        GlobalUnlock(hgbl);
        return srcIOErrorMdr | srcInvalidMdr;
    }

    GlobalUnlock(hgbl);

    return NULL;    // normal operation
}


WINSRC StemmerCloseMdr(HSTM sid)
{

    STMI    *pstmi;
    HGLOBAL    hgbl;

    hgbl = (HGLOBAL) sid;
    pstmi = (STMI  *)GlobalLock(hgbl);

    if (pstmi == NULL) return FAIL;

    if (pstmi->bMdr)
        CloseMainDict ();

    GlobalUnlock(hgbl);

    return NULL;  // normal operation
}

WINSRC StemmerDecomposeW (HSTM hStm,
                       LPCWSTR iword,
                       LPWDOB lpSob)
{
    LPSTR MultiByteIword;
    DOB sob;
    int index = 0;

    int len = WideCharToMultiByte (UWANSUNG_CODE_PAGE, 0, (LPCWSTR) iword, -1, NULL, 0, NULL, NULL);
    MultiByteIword = (LPSTR) LocalAlloc (LPTR, sizeof (char) * len);
// add a check for this point
    if ( MultiByteIword == NULL ) {
       return srcModuleError;
    }

    len = WideCharToMultiByte (UWANSUNG_CODE_PAGE, 0, (LPCWSTR) iword, -1, MultiByteIword, len, NULL, NULL);

    sob.wordlist = (LPSTR) LocalAlloc (LPTR, sizeof (char) * lpSob->sch);

// add a check for this point
    if ( sob.wordlist == NULL ) {
       LocalFree(MultiByteIword);
       return srcModuleError;
    }

    sob.sch = lpSob->sch;
    SRC src = StemmerDecompose(hStm, MultiByteIword, &sob);
    lpSob->num = sob.num;

    if (src == NULL)
    {
        char *tmpstr;

        for (int j = 0, index2 = 0; j < sob.num; j++)
        {
            tmpstr = sob.wordlist+index2;
            len = MultiByteToWideChar(UWANSUNG_CODE_PAGE, 0, tmpstr, -1, NULL, 0);
            LPWSTR tmpwstr = (LPWSTR) LocalAlloc (LPTR, sizeof (WCHAR) * len);

//  add a check for this point
            if ( tmpwstr == NULL ) {
               LocalFree (MultiByteIword);
               LocalFree (sob.wordlist);
               return srcModuleError;
            }

            MultiByteToWideChar(UWANSUNG_CODE_PAGE, 0, tmpstr, -1, (LPWSTR) tmpwstr, len);
            memcpy (lpSob->wordlist+index, tmpwstr, len*sizeof(WCHAR));
            memcpy (lpSob->wordlist+index+len, tmpstr+lstrlen (tmpstr)+1, 2);
            memcpy (lpSob->wordlist+index+len + 1, tmpwstr+len-1, sizeof(WCHAR));
            index += (len+2);
            index2 += (lstrlen(tmpstr)+4);
            LocalFree (tmpwstr);
        }
    }
    lpSob->len = (WORD)index;

    LocalFree (MultiByteIword);
    LocalFree (sob.wordlist);

    return src;
}

SRC GetOneResult (RLIST *rList, LPDOB lpSob)
{
    WORD value;
    int count;

    if (rList->num >= rList->max)
        return srcNoMoreResult;

    lpSob->len = 0;
    lpSob->num = 0;

    for (UINT i = rList->num, index = 0; i < rList->max; i++)
    {
        count = 0;
        while (rList->next [index+count] != '+' && rList->next [index+count] != '\t')
            count++;

        if (lpSob->len + count < lpSob->sch)
        {
            memcpy (lpSob->wordlist+lpSob->len, rList->next+index, count);
            lpSob->num++;
        }
        else
            return srcOOM | srcExcessBuffer;

        lpSob->len += (WORD)count;
        lpSob->wordlist [lpSob->len++] = '\0';
        SetSilHeosa(rList->vbuf [i], &value);
        memcpy (lpSob->wordlist + lpSob->len, &value, 2);
        lpSob->wordlist [lpSob->len+2] = '\0';
        lpSob->len += 3;
        if (rList->next[index+count] == '\t')
            break;
        index += (count + 1);
    }

    rList->next += (index+count+1);
    rList->num = i+1;

    return NULL;
}

WINSRC StemmerDecompose(HSTM hstm,
                     LPCSTR iword,      // input word
                     LPDOB psob)        // the number of candidates
{
    int len = lstrlen ((char *) iword);


    if (len >= 45)
    {
        psob->num = 1;
        lstrcpy ((LPSTR) psob->wordlist, (LPSTR) iword);
        psob->len = (WORD)len;
        return srcInvalid;
    }

    for (int i = 0; i < len; i += 2)
        if (!isHANGEUL (iword [i], iword [i+1]))
        {
            psob->num = 1;
            lstrcpy ((LPSTR) psob->wordlist, (LPSTR) iword);
            psob->len = (WORD)len;
            return srcInvalid;
        }

    STMI    *pstmi;
    HGLOBAL hgbl = (HGLOBAL) hstm;

    pstmi = (STMI *)GlobalLock(hgbl);
    if (pstmi == NULL)
    {
        GlobalUnlock(hgbl);
        return srcModuleError | srcInvalidID;
    }

    BaseEngine BaseCheck;

    char lrgsz [400];
    memset (pstmi->rList.lrgsz, NULLCHAR, 400);
    lstrcpy (pstmi->rList.iword, iword);
    pstmi->rList.max = 0;
    BOOL affixFlag = TRUE;

    if (pstmi->Option & SO_ALONE)
    {
        int num = BaseCheck.NLP_BASE_ALONE (iword, lrgsz);
        if (num > 0)
        {
            affixFlag = FALSE;
            lstrcat (pstmi->rList.lrgsz, lrgsz);
            for (int i = 0; i < num; i++)
                pstmi->rList.vbuf [pstmi->rList.max + i] = BaseCheck.vbuf [i];
            pstmi->rList.max += num;
        }
    }

    if (pstmi->Option & SO_NOUNPHRASE)
    {
        int num = BaseCheck.NLP_BASE_NOUN (iword, lrgsz);
        if (num > 0)
        {
            affixFlag = FALSE;
            lstrcat (pstmi->rList.lrgsz, lrgsz);
            for (int i = 0; i < num; i++)
                pstmi->rList.vbuf [pstmi->rList.max + i] = BaseCheck.vbuf [i];
            pstmi->rList.max += num;
        }
    }

    if (pstmi->Option & SO_PREDICATE)
    {
        int num = BaseCheck.NLP_BASE_VERB (iword, lrgsz);
        if (num > 0)
        {
            lstrcat (pstmi->rList.lrgsz, lrgsz);
            for (int i = 0; i < num; i++)
                pstmi->rList.vbuf [pstmi->rList.max + i] = BaseCheck.vbuf [i];
            pstmi->rList.max += num;
        }
    }

    if (pstmi->Option & SO_COMPOUND)
    {
        if (pstmi->rList.max == 0)
        {
            int num = BaseCheck.NLP_BASE_COMPOUND (iword, lrgsz);
            if (num > 0)
            {
                lstrcpy (pstmi->rList.lrgsz, lrgsz);
                for (int i = 0; i < num; i++)
                    pstmi->rList.vbuf [i] = BaseCheck.vbuf [i];
                pstmi->rList.max = num;
            }
        }
    }

    if (affixFlag && pstmi->Option & SO_SUFFIX)
    {
        int num = BaseCheck.NLP_BASE_AFFIX (iword, lrgsz);
        if (num > 0)
        {
            lstrcat (pstmi->rList.lrgsz, lrgsz);
            for (int i = 0; i < num; i++)
                pstmi->rList.vbuf [pstmi->rList.max + i] = BaseCheck.vbuf [i];
            pstmi->rList.max += num;
        }
    }

    pstmi->rList.num = 0;
    pstmi->rList.next = pstmi->rList.lrgsz;

    SRC src = GetOneResult (&(pstmi->rList), psob);
    if (src == srcNoMoreResult)
    {
        src = srcInvalid;
        lstrcpy (psob->wordlist, iword);
    }

    GlobalUnlock(hgbl);
    return src;
}

WINSRC StemmerDecomposeMoreW (HSTM hStm, LPCWSTR lpWord, LPWDOB lpSob)
{
    LPSTR MultiByteIword;
    DOB sob;

    int len = WideCharToMultiByte (UWANSUNG_CODE_PAGE, 0, lpWord, -1, NULL, 0, NULL, NULL);
    MultiByteIword = (LPSTR) LocalAlloc (LPTR, sizeof (char) * len);

//  add a check for this point
    if ( MultiByteIword == NULL  )  {
       return srcModuleError;
    }

    len = WideCharToMultiByte (UWANSUNG_CODE_PAGE, 0, lpWord, -1, MultiByteIword, len, NULL, NULL);

    sob.wordlist = (LPSTR) LocalAlloc (LPTR, sizeof (char) * lpSob->sch);

//  add a check for this point
    if ( sob.wordlist == NULL  )  {
        LocalFree(MultiByteIword);
        return srcModuleError;
    }

    sob.sch = lpSob->sch;
    SRC src = StemmerDecomposeMore(hStm, MultiByteIword, &sob);
    lpSob->num = sob.num;

    int index = 0;
    if (src == NULL)
    {
        char *tmpstr;
        for (int j = 0, index2 = 0; j < sob.num; j++)
        {
            tmpstr = sob.wordlist+index2;
            len = MultiByteToWideChar(UWANSUNG_CODE_PAGE, 0, tmpstr, -1, NULL, 0);
            LPWSTR tmpwstr = (LPWSTR) LocalAlloc (LPTR, sizeof (WCHAR) * len);

//  add a check for this point
            if ( tmpwstr == NULL  )  {
               LocalFree(MultiByteIword);
               LocalFree(sob.wordlist);
               return srcModuleError;
            }

            MultiByteToWideChar(UWANSUNG_CODE_PAGE, 0, tmpstr, -1, (LPWSTR) tmpwstr, len);
            memcpy (lpSob->wordlist+index, tmpwstr, len*sizeof(WCHAR));
            memcpy (lpSob->wordlist+index+len, tmpstr+lstrlen (tmpstr)+1, 2);
            memcpy (lpSob->wordlist+index+len + 1, tmpwstr+len-1, sizeof(WCHAR));
            index += (len+2);
            index2 += (lstrlen(tmpstr)+4);
            LocalFree (tmpwstr);
        }
    }
    lpSob->len = (WORD)index;

    LocalFree (MultiByteIword);
    LocalFree (sob.wordlist);

    return src;
}

WINSRC StemmerDecomposeMore (HSTM hStm, LPCSTR lpWord, LPDOB lpSob)
{
    STMI    *pstmi;
    HGLOBAL hgbl = (HGLOBAL) hStm;

    pstmi = (STMI *)GlobalLock(hgbl);
    if (pstmi == NULL)
    {
        GlobalUnlock(hgbl);
        return srcModuleError | srcInvalidID;
    }

    if (lstrcmp (pstmi->rList.iword, lpWord))
    {
        return srcModuleError;
    }

    SRC src = GetOneResult (&(pstmi->rList), lpSob);

    GlobalUnlock(hgbl);

    return src;
}

WINSRC StemmerEnumDecomposeW (HSTM hStm, LPCWSTR lpWord, LPWDOB lpSob, LPFNDECOMPOSEW lpfnCallBack)
{
    LPSTR MultiByteIword;
    DOB sob;

    int len = lstrlen ((char *) lpWord);
    if (len >= 45)
    {
        lpSob->num = 1;
        wcscpy (lpSob->wordlist, lpWord);
        lpSob->len = (WORD)len;
        return srcInvalid;
    }

    for (int i = 0; i < len; i++)
        if (0xabff < lpWord [i] && lpWord [i] < 0xd7a4)
        {
            lpSob->num = 1;
            lstrcpy ((LPSTR) lpSob->wordlist, (LPSTR) lpWord);
            lpSob->len = (WORD)len;
            return srcInvalid;
        }

    STMI    *pstmi;
    HGLOBAL hgbl = (HGLOBAL) hStm;

    pstmi = (STMI *)GlobalLock(hgbl);
    if (pstmi == NULL)
    {
        GlobalUnlock(hgbl);
        return srcModuleError | srcInvalidID;
    }

    BaseEngine BaseCheck;

    len = WideCharToMultiByte (UWANSUNG_CODE_PAGE, 0, lpWord, -1, NULL, 0, NULL, NULL);
    MultiByteIword = (LPSTR) LocalAlloc (LPTR, sizeof (char) * len);

//  add a check for this point
    if ( MultiByteIword == NULL  )  {
        GlobalUnlock(hgbl);
        return srcModuleError;
    }

    len = WideCharToMultiByte (UWANSUNG_CODE_PAGE, 0, lpWord, -1, MultiByteIword, len, NULL, NULL);

    sob.wordlist = (LPSTR) LocalAlloc (LPTR, sizeof (char) * lpSob->sch);

//  add a check for this point
    if ( sob.wordlist == NULL  )  {
        GlobalUnlock(hgbl);
        LocalFree(MultiByteIword);
        return srcModuleError;
    }

    sob.sch = lpSob->sch;

    char lrgsz [400];
    memset (pstmi->rList.lrgsz, NULLCHAR, 400);
    lstrcpy (pstmi->rList.iword, MultiByteIword);
    pstmi->rList.max = 0;
    int num = BaseCheck.NLP_BASE_NOUN (MultiByteIword, lrgsz);
    if (num > 0)
    {
        lstrcpy (pstmi->rList.lrgsz, lrgsz);
        for (int i = 0; i < num; i++)
            pstmi->rList.vbuf [i] = BaseCheck.vbuf [i];
        pstmi->rList.max = num;
    }
    num = BaseCheck.NLP_BASE_ALONE (MultiByteIword, lrgsz);
    if (num > 0)
    {
        lstrcat (pstmi->rList.lrgsz, lrgsz);
        for (int i = 0; i < num; i++)
            pstmi->rList.vbuf [pstmi->rList.max + i] = BaseCheck.vbuf [i];
        pstmi->rList.max += num;
    }
    num = BaseCheck.NLP_BASE_VERB (MultiByteIword, lrgsz);
    if (num > 0)
    {
        lstrcat (pstmi->rList.lrgsz, lrgsz);
        for (int i = 0; i < num; i++)
            pstmi->rList.vbuf [pstmi->rList.max + i] = BaseCheck.vbuf [i];
        pstmi->rList.max += num;
    }
    if (num == 0)
    {
        num = BaseCheck.NLP_BASE_COMPOUND (MultiByteIword, lrgsz);
        if (num > 0)
        {
            lstrcpy (pstmi->rList.lrgsz, lrgsz);
            for (int i = 0; i < num; i++)
                pstmi->rList.vbuf [i] = BaseCheck.vbuf [i];
            pstmi->rList.max = num;
        }
    }

    pstmi->rList.num = 0;
    pstmi->rList.next = pstmi->rList.lrgsz;

    while (GetOneResult (&(pstmi->rList), &sob) == NULL)
    {
        char *tmpstr;
        for (int j = 0, index2 = 0, index = 0; j < sob.num; j++)
        {
            tmpstr = sob.wordlist+index2;
            len = MultiByteToWideChar(UWANSUNG_CODE_PAGE, 0, tmpstr, -1, NULL, 0);
            LPWSTR tmpwstr = (LPWSTR) LocalAlloc (LPTR, sizeof (WCHAR) * len);
            // add a check for this point

            if ( tmpwstr == NULL ) {
               GlobalUnlock(hgbl);
               LocalFree (MultiByteIword);
               LocalFree (sob.wordlist);
               return srcModuleError;
            }

            MultiByteToWideChar(UWANSUNG_CODE_PAGE, 0, tmpstr, -1, (LPWSTR) tmpwstr, len);
            memcpy (lpSob->wordlist+index, tmpwstr, len*sizeof(WCHAR));
            memcpy (lpSob->wordlist+index+len, tmpstr+lstrlen (tmpstr)+1, 2);
            memcpy (lpSob->wordlist+index+len + 1, tmpwstr+len-1, sizeof(WCHAR));
            index += (len+2);
            index2 += (lstrlen(tmpstr)+4);
            LocalFree (tmpwstr);
        }
        lpSob->len = (WORD)index;
        lpSob->num = sob.num;
        lpfnCallBack (lpSob);
    }

    GlobalUnlock(hgbl);

    LocalFree (MultiByteIword);
    LocalFree (sob.wordlist);

    return NULL;
}

WINSRC StemmerEnumDecompose (HSTM hStm, LPCSTR lpWord, LPDOB lpSob, LPFNDECOMPOSE lpfnCallBack)
{
    int len = lstrlen ((char *) lpWord);
    if (len >= 45)
    {
        lpSob->num = 1;
        lstrcpy ((LPSTR) lpSob->wordlist, lpWord);
        lpSob->len = (WORD)len;
        return srcInvalid;
    }

    for (int i = 0; i < len; i += 2)
        if (!isHANGEUL (lpWord [i], lpWord [i+1]))
        {
            lpSob->num = 1;
            lstrcpy ((LPSTR) lpSob->wordlist, (LPSTR) lpWord);
            lpSob->len = (WORD)len;
            return srcInvalid;
        }

    STMI    *pstmi;
    HGLOBAL hgbl = (HGLOBAL) hStm;

    pstmi = (STMI *)GlobalLock(hgbl);
    if (pstmi == NULL)
    {
        GlobalUnlock(hgbl);
        return srcModuleError | srcInvalidID;
    }

    BaseEngine BaseCheck;

    char lrgsz [400];
    memset (pstmi->rList.lrgsz, NULLCHAR, 400);
    lstrcpy (pstmi->rList.iword, lpWord);
    int num = BaseCheck.NLP_BASE_NOUN (lpWord, lrgsz);
    pstmi->rList.max = 0;
    if (num > 0)
    {
        lstrcpy (pstmi->rList.lrgsz, lrgsz);
        for (int i = 0; i < num; i++)
            pstmi->rList.vbuf [i] = BaseCheck.vbuf [i];
        pstmi->rList.max = num;
    }
    num = BaseCheck.NLP_BASE_ALONE (lpWord, lrgsz);
    if (num > 0)
    {
        lstrcat (pstmi->rList.lrgsz, lrgsz);
        for (int i = 0; i < num; i++)
            pstmi->rList.vbuf [pstmi->rList.max + i] = BaseCheck.vbuf [i];
        pstmi->rList.max += num;
    }
    num = BaseCheck.NLP_BASE_VERB (lpWord, lrgsz);
    if (num > 0)
    {
        lstrcat (pstmi->rList.lrgsz, lrgsz);
        for (int i = 0; i < num; i++)
            pstmi->rList.vbuf [pstmi->rList.max + i] = BaseCheck.vbuf [i];
        pstmi->rList.max += num;
    }
    if (num == 0)
    {
        num = BaseCheck.NLP_BASE_COMPOUND (lpWord, lrgsz);
        if (num > 0)
        {
            lstrcpy (pstmi->rList.lrgsz, lrgsz);
            for (int i = 0; i < num; i++)
                pstmi->rList.vbuf [i] = BaseCheck.vbuf [i];
            pstmi->rList.max = num;
        }
    }


    pstmi->rList.num = 0;
    pstmi->rList.next = pstmi->rList.lrgsz;

    while (GetOneResult (&(pstmi->rList), lpSob) == NULL)
        lpfnCallBack (lpSob);

    GlobalUnlock(hgbl);

    return NULL;
}

WINSRC StemmerComposeW (HSTM hstm, WCIB sib, LPWSTR rword)
{
    CIB tmpsib;
    LPSTR MultiByteRword;

    int len = (wcslen (sib.silsa) + 1) * 2;
    tmpsib.silsa = (LPSTR) LocalAlloc (LPTR, sizeof (char) * len);

// add a check for this point.
    if ( tmpsib.silsa == NULL ) {
       return srcModuleError;
    }

    len = WideCharToMultiByte (CP_ACP, 0, (LPCWSTR) sib.silsa, -1, tmpsib.silsa, len, NULL, NULL);

    int len2 = (wcslen (sib.heosa) + 1) * 2;
    tmpsib.heosa = (LPSTR) LocalAlloc (LPTR, sizeof (char) * len2);

// add a check for this point.
    if ( tmpsib.heosa == NULL ) {
       LocalFree(tmpsib.silsa);
       return srcModuleError;
    }

    len2 = WideCharToMultiByte (UWANSUNG_CODE_PAGE, 0, (LPCWSTR) sib.heosa, -1, tmpsib.heosa, len2, NULL, NULL);

    MultiByteRword = (LPSTR) LocalAlloc (LPTR, sizeof (char) * (len + len2));

// add a check for this point.
    if ( MultiByteRword == NULL ) {
       LocalFree(tmpsib.silsa);
       LocalFree(tmpsib.heosa);
       return srcModuleError;
    }

    tmpsib.pos = sib.pos;
    SRC src = StemmerCompose (hstm, tmpsib, MultiByteRword);

    len = MultiByteToWideChar(UWANSUNG_CODE_PAGE, 0, MultiByteRword, -1, NULL, 0);
    MultiByteToWideChar(UWANSUNG_CODE_PAGE, 0, MultiByteRword, -1, (LPWSTR) rword, len);

    LocalFree (tmpsib.silsa);
    LocalFree (tmpsib.heosa);
    LocalFree (MultiByteRword);

    return src;
}

int CVCheckNP(char  *stem, char  *ending, BYTE action)
//   Check vowel harmony for NOUN + Tossi. If the last letter of stem is RIEUR, that should seriously be considered.
{
    int len = strlen (ending) + 1;

        if ((action & 0x80) && (action & 0x40))  // CV = 11
                return VALID;

        if (!(action & 0x80) && (action & 0x40)) {     // CV = 01
                if (stem[0] >= __V_k)
                        return VALID;
                if (stem[0] == __K_R && ending[0] == __K_R && ending[1] == __V_h)
                // Tossi is "RO"(CV=01) and the last letter of stem is RIEUR.
                        return VALID;
                if (ending[0] == __K_S && ending[1] == __V_j) {
                // "SEO" --> "E SEO"
                        memmove (ending+2, ending, len);
                        ending [0] = __K_I;
                        ending [1] = __V_p;
                        return MORECHECK;
                }
                if (ending[0] == __K_N && ending[1] == __V_m && ending[2] == __K_N) {
                // "NEUN" --> "EUN"
                        ending [0] = __K_I;
                }
                if (ending[0] == __K_G && ending[1] == __V_k) {
                // "GA" --> "I"
                    ending[0] = __K_I;
                    ending[1] = __V_l;
                        return MORECHECK;
                }
                if (ending[0] == __K_I && ending[1] == __V_hk) {
                // "WA" --> "GWA"
                    ending [0] = __K_G;
                        return MORECHECK;
                }
                if (ending [0] == __K_R) {
                        if (ending[1] == __V_m && ending[2] == __K_R) {
                        // "REUL" --> "EUL"
                            ending [0] = __K_I;
                                return INVALID;
                        }
                        if (ending[1] == __V_h) {
                        // "RO" --> "EU RO"
                            memmove (ending+2, ending, len);
                            ending [0] = __K_I;
                            ending [1] = __V_m;
                                return MORECHECK;
                        }
                        // add "I" to the first part of ending
                        memmove (ending+2, ending, len);
                        ending [0] = __K_I;
                        ending [1] = __V_l;
                        return MORECHECK;
                }
                if ((ending [0] == __K_N) ||
                    (ending [0] == __K_S && ending [1] == __V_l) || // "SI"
                    (ending [0] == __K_I && ending [1] == __V_u) || // "YEO"
                    (ending[0] == __K_I && ending[1] == __V_i && ending[2] == __K_M // "YA MAL RO" --> "I YA MAL RO"
                        && ending[3] == __V_k && ending[4] == __K_R && ending[5] == __K_R && ending[6] == __V_h))
                {
                // Add "I" to the first part of ending
                    memmove (ending+2, ending, len);
                    ending [0] = __K_I;
                    ending [1] = __V_l;
                        return MORECHECK;
                }
                return MORECHECK;
        }

        // CV==10
        if (stem[0] >= __V_k) {
                if (ending [0] == __K_G) {
                 // "GWA" --> "WA"
                    ending [0] = __K_I;
                        return MORECHECK;
                }
                if (ending[1] == __V_l) {
                        if (len == 3) {
                        // "I" --> "GA"
                            ending [0] = __K_G;
                            ending [1] = __V_k;
                                return MORECHECK;
                        }
                        else {
                                // remove "I"
                            memmove (ending, ending+2, len-2);
                                return INVALID;
                        }
                }
                if (ending[1] == __V_k)
                {
                    ending [1] = __V_i;
                    return MORECHECK;
                }
                if (ending[2] == __K_N) {
                // "EUN" --> "NEUN"
                    ending [0] = __K_N;
                                return MORECHECK;
                }
                if (len == 4) {
                // "EUL" --> "REUL"
                    ending [0] = __K_R;
                        return MORECHECK;
                }
                else {
                // Remove "EU"
                    memmove (ending, ending+2, len-2);
                        return INVALID;
                }
        }
        if (stem[0] == __K_R && ending[0] == __K_I && ending[1] == __V_m
            && ending[2] == __K_R && ending[3] == __V_h) {
                // Remove "EU"
            memmove (ending, ending+2, len-2);
                return INVALID;
        }
        return VALID;
}

WINSRC StemmerCompose (HSTM hstm, CIB sib, LPSTR rword)
{
    STMI    *pstmi;
    HGLOBAL hgbl = (HGLOBAL) hstm;
    int ret, i;
    BYTE action;

    pstmi = (STMI *)GlobalLock(hgbl);
    if (pstmi == NULL)
    {
        GlobalUnlock(hgbl);
        return srcModuleError | srcInvalidID;
    }

    lstrcpy (rword, (char *)sib.silsa);

    for (i = 0; sib.silsa [i] != 0; i += 2)
        if (!isHANGEUL (sib.silsa [i], sib.silsa [i+1]))
        {
            lstrcat (rword, sib.heosa);
            return NULL;
        }

    for (i = 0; sib.heosa [i] != 0; i +=2)
        if (!isHANGEUL (sib.heosa [i], sib.heosa [i+1]))
        {
            lstrcat (rword, sib.heosa);
            return NULL;
        }

    CODECONVERT conv;

    char *incode = (char *) LocalAlloc (LPTR, sizeof (char) * (lstrlen (sib.silsa)*3+1 + lstrlen (sib.heosa)*3+7));

// add a check for this point.
    if ( incode == NULL ) {
       GlobalUnlock(hgbl);
       return srcModuleError;
    }

    char *inheosa = (char *) LocalAlloc (LPTR, sizeof (char) * (lstrlen (sib.heosa)*3+7));

// add a check for this point.
    if ( inheosa == NULL ) {
       GlobalUnlock(hgbl);
       LocalFree(incode);
       return srcModuleError;
    }

    conv.HAN2INS (sib.silsa, incode, codeWanSeong);
    conv.HAN2INR (sib.heosa, inheosa, codeWanSeong);

    LPSTR tmptossi = (LPSTR) LocalAlloc (LPTR, sizeof (char) * lstrlen (sib.heosa)*2 );
// add a check for this point
    if (tmptossi == NULL )  {
       GlobalUnlock(hgbl);
       LocalFree(incode);
       LocalFree(inheosa);
       return srcModuleError;
    }

    char *inending = (char *) LocalAlloc (LPTR, sizeof (char) * (lstrlen(sib.heosa)*3+7));
// add a check for this point
    if ( inending== NULL )  {
       GlobalUnlock(hgbl);
       LocalFree(incode);
       LocalFree(inheosa);
       LocalFree(tmptossi);
       return srcModuleError;
    }

    char *inrword = (char *) LocalAlloc (LPTR, sizeof (char) * (lstrlen(sib.silsa)*3+lstrlen(sib.heosa)*3+6));
// add a check for this point
    if (inrword == NULL )  {
       GlobalUnlock(hgbl);
       LocalFree(incode);
       LocalFree(inheosa);
       LocalFree(tmptossi);
       LocalFree(inending);
       return srcModuleError;
    }


    switch (sib.pos & 0x0f00)
    {
        case POS_NOUN :
        case POS_PRONOUN :
        case POS_NUMBER :

            lstrcpy (tmptossi, sib.heosa);
            if (FindHeosaWord (inheosa, _TOSSI, &action) & FINAL)
            {
                conv.ReverseIN (inheosa, inending);
                conv.ReverseIN (incode, inrword);
                CVCheckNP (inrword, inending, action);


                conv.INS2HAN (inending, tmptossi, codeWanSeong);

                // we should check contraction tossi, for example, Nieun, Rieul
                for (i = 0; ContractTossi [i].contract != NULL; i++)
                    if (lstrcmp (ContractTossi [i].contract, tmptossi)==0)
                        conv.HAN2INS ((char *)tmptossi, inending, codeWanSeong);

                lstrcat (incode, inending);
                conv.INS2HAN(incode, (char *)rword, codeWanSeong);
                //LocalFree (incode);
                LocalFree (inheosa);
                LocalFree (tmptossi);
                LocalFree (inending);
                LocalFree (inrword);
                GlobalUnlock (hgbl);
                return NULL;
            }

            lstrcat (rword, tmptossi);
            LocalFree (incode);
            LocalFree (inheosa);
            LocalFree (tmptossi);
            LocalFree (inending);
            LocalFree (inrword);
            GlobalUnlock (hgbl);
            return srcComposeError;

            break;

        case POS_VERB :
        case POS_ADJECTIVE :
        case POS_AUXVERB :
        case POS_AUXADJ :

            conv.HAN2INS ((char *)sib.heosa, inending, codeWanSeong);
            conv.HAN2INR ((char *)sib.silsa, incode, codeWanSeong);
            if ((ret = Compose_RIEUL_Irregular (incode, inending)) != NOT_COMPOSED)
                goto ErrorCheck;
            if ((ret = Compose_HIEUH_Irregular (incode, inending)) != NOT_COMPOSED)
                goto ErrorCheck;
            if ((ret = Compose_PIEUP_Irregular (incode, inending)) != NOT_COMPOSED)
                goto ErrorCheck;
            if ((ret = Compose_TIEUT_Irregular (incode, inending)) != NOT_COMPOSED)
                goto ErrorCheck;
            if ((ret = Compose_SIOS_Irregular (incode, inending)) != NOT_COMPOSED)
                goto ErrorCheck;
            if (Compose_YEO_Irregular (incode, inending))
                goto Quit;
            if (Compose_REO_REU_Irregular (incode, inending))
                goto Quit;
            if (Compose_GEORA_Irregular (incode, inending))
                goto Quit;
            Compose_Regular (incode, inending);

ErrorCheck : if (ret == COMPOSE_ERROR)
             {
                lstrcat (rword, sib.heosa);
                LocalFree (incode);
                LocalFree (inheosa);
                LocalFree (tmptossi);
                LocalFree (inending);
                LocalFree (inrword);
                GlobalUnlock (hgbl);
                return srcComposeError;
             }
Quit:        conv.ReverseIN (incode, inrword);
            lstrcat (inrword, inending);
            conv.INS2HAN (inrword, (char *)rword, codeWanSeong);

            break;
        default :
            lstrcat (rword, sib.heosa);
            LocalFree (incode);
            LocalFree (inheosa);
            LocalFree (tmptossi);
            LocalFree (inending);
            LocalFree (inrword);
            GlobalUnlock (hgbl);
            return srcComposeError;
    }

    LocalFree (incode);
    LocalFree (inheosa);
    LocalFree (tmptossi);
    LocalFree (inending);
    LocalFree (inrword);
    GlobalUnlock (hgbl);
    return NULL;
}

WINSRC StemmerTerminate(HSTM hstm)
{
    STMI    *pstmi;
    HGLOBAL hgbl = (HGLOBAL) hstm;

    pstmi = (STMI *)GlobalLock(hgbl);
    if (pstmi == NULL)
    {
        GlobalUnlock(hgbl);
        return srcModuleError | srcInvalidID;
    }

    GlobalUnlock (hgbl);
    GlobalFree (hgbl);

    return NULL;  //normal operation
}

WINSRC StemmerOpenUdr (HSTM stmi, LPCSTR lpPathUdr)
{
    return NULL;
}

WINSRC StemmerCloseUdr (HSTM stmi)
{
    return NULL;
}

WINSRC StemmerCompareW (HSTM hstm, LPCWSTR lpStr1, LPCWSTR lpStr2, LPWSTR lpStem, LPWSTR lpEnding1, LPWSTR lpEnding2, WORD *pos)
{
    LPSTR MultiByteStr1, MultiByteStr2, MultiByteStem, MultiByteEnding1, MultiByteEnding2;

    int len1 = WideCharToMultiByte (UWANSUNG_CODE_PAGE, 0, lpStr1, -1, NULL, 0, NULL, NULL);
    MultiByteStr1 = (LPSTR) LocalAlloc (LPTR, sizeof (char) * len1);
    // add a check for this point.
    if (MultiByteStr1 == NULL ) {
       return  srcModuleError;
    }

    len1 = WideCharToMultiByte (UWANSUNG_CODE_PAGE, 0, lpStr1, -1, MultiByteStr1, len1, NULL, NULL);

    int len2 = WideCharToMultiByte (UWANSUNG_CODE_PAGE, 0, lpStr2, -1, NULL, 0, NULL, NULL);
    MultiByteStr2 = (LPSTR) LocalAlloc (LPTR, sizeof (char) * len2);
    // add a check for this point.
    if (MultiByteStr2 == NULL ) {
       LocalFree(MultiByteStr1);
       return  srcModuleError;
    }

    len2 = WideCharToMultiByte (UWANSUNG_CODE_PAGE, 0, lpStr2, -1, MultiByteStr2, len2, NULL, NULL);

    int len = len1 > len2 ? len1 : len2;

    MultiByteStem = (LPSTR) LocalAlloc (LPTR, sizeof (char) * len);
    // add a check for this point.
    if (MultiByteStem == NULL ) {
       LocalFree(MultiByteStr1);
       LocalFree(MultiByteStr2);
       return  srcModuleError;
    }

    MultiByteEnding1 = (LPSTR) LocalAlloc (LPTR, sizeof (char) * len);
    // add a check for this point.
    if (MultiByteEnding1 == NULL ) {
       LocalFree(MultiByteStr1);
       LocalFree(MultiByteStr2);
       LocalFree(MultiByteStem);
       return  srcModuleError;
    }

    MultiByteEnding2 = (LPSTR) LocalAlloc (LPTR, sizeof (char) * len);
    // add a check for this point.
    if (MultiByteEnding2 == NULL ) {
       LocalFree(MultiByteStr1);
       LocalFree(MultiByteStr2);
       LocalFree(MultiByteStem);
       LocalFree(MultiByteEnding1);
       return  srcModuleError;
    }


    SRC src = StemmerCompare(hstm, MultiByteStr1, MultiByteStr2,  MultiByteStem, MultiByteEnding1, MultiByteEnding2, pos);

    MultiByteToWideChar(UWANSUNG_CODE_PAGE, 0, MultiByteStem, -1, lpStem, sizeof (lpStem));
    MultiByteToWideChar(UWANSUNG_CODE_PAGE, 0, MultiByteEnding1, -1, lpEnding1, sizeof (lpEnding1));
    MultiByteToWideChar(UWANSUNG_CODE_PAGE, 0, MultiByteEnding2, -1, lpEnding2, sizeof (lpEnding2));

    LocalFree (MultiByteStr1);
    LocalFree (MultiByteStr2);
    LocalFree (MultiByteStem);
    LocalFree (MultiByteEnding1);
    LocalFree (MultiByteEnding2);

    return src;
}

WINSRC StemmerCompare (HSTM hstm, LPCSTR lpStr1, LPCSTR lpStr2, LPSTR lpStem, LPSTR lpEnding1, LPSTR lpEnding2, WORD *pos)
{
    // First, check the chosung of two strings
    //        if they are different, we may not use stemming.
    CODECONVERT conv;
    char inheosa1 [80], inheosa2 [80];
    BYTE    action;

    char *incodeStr1 = new char [lstrlen (lpStr1) * 4 + 1];
    char *incodeStr2 = new char [lstrlen (lpStr2) * 4 + 1];
    conv.HAN2INS ((char *)lpStr1, incodeStr1, codeWanSeong);
    conv.HAN2INS ((char *)lpStr2, incodeStr2, codeWanSeong);

    if (incodeStr1 [0] != incodeStr2 [0])
        return srcInvalid;

    if (incodeStr1 [1] != incodeStr2 [1])
    {
        return srcInvalid;
    }

    delete incodeStr1;
    delete incodeStr2;

    STMI    *pstmi;
    HGLOBAL hgbl = (HGLOBAL) hstm;

    pstmi = (STMI *)GlobalLock(hgbl);
    if (pstmi == NULL)
    {
        GlobalUnlock(hgbl);
        return srcModuleError | srcInvalidID;
    }

    BaseEngine BaseCheck;

    char stem1[10][100], stem2[10][100], ending1[10][100], ending2[10][100], lrgsz [400];
    int num1, num2, count;
    WORD winfo [10];
    if ((pstmi->Option & SO_NOUNPHRASE) && (pstmi->Option & (SO_NP_NOUN | SO_NP_PRONOUN | SO_NP_NUMBER | SO_NP_DEPENDENT)))
    {
        int num = BaseCheck.NLP_BASE_NOUN (lpStr1, lrgsz);
        BOOL first = TRUE;
        for (int i = 0, index = 0, l = 0, index2 = 0; i < num; i++)
        {
            count = 0;
            while (lrgsz [index+count] != '+' && lrgsz[index+count] != '\t')
                count++;

            if (first)
            {
                memcpy (stem1 [l], lrgsz+index, count);
                stem1 [l][count] = '\0';
                winfo [l] = BaseCheck.vbuf [i];
                first = FALSE;
            }
            else
            {
                memcpy (ending1 [l]+index2, lrgsz+index, count);
                index2 += count;
            }

            if (lrgsz[index+count] == '\t')
            {
                ending1 [l][index2] = '\0';
                l++;
                first = TRUE;
                index2 = 0;
            }
            index += (count + 1);
        }
        num1 = l;
        num = BaseCheck.NLP_BASE_NOUN (lpStr2, lrgsz);
        for (i = 0, index = 0, l = 0, index2 = 0; i < num; i++)
        {
            count = 0;
            while (lrgsz [index+count] != '+' && lrgsz [index+count] != '\t')
                count++;

            if (first)
            {
                memcpy (stem2 [l], lrgsz+index, count);
                stem2 [l][count] = '\0';
                first = FALSE;
            }
            else
            {
                memcpy (ending2 [l]+index2, lrgsz+index, count);
                index2 += count;
            }

            if (lrgsz[index+count] == '\t')
            {
                ending2 [l][index2] = '\0';
                l++;
                first = TRUE;
                index2 = 0;
            }
            index += (count + 1);
        }
        num2 = l;

        int j;
        for (i = 0; i < num1; i++)
        {
            for (j = 0; j < num2; j++)
                if (lstrcmp (stem1[i], stem2 [j]) == 0)
                    break;
            if (j != num2)
                break;
        }

        if (i != num1)
        {
            lstrcpy (lpStem, stem1 [i]);
            lstrcpy (lpEnding1, ending1 [i]);
            lstrcpy (lpEnding2, ending2 [j]);
            *pos = winfo [i];
            GlobalUnlock (hgbl);
            return NULL;
        }
    }

    if (pstmi->Option & (SO_PREDICATE | SO_AUXILIARY))
    {
        int num = BaseCheck.NLP_BASE_VERB (lpStr1, lrgsz);
        BOOL first = TRUE;
        for (int i = 0, index = 0, l = 0, index2 = 0; i < num; i++)
        {
            count = 0;
            while (lrgsz [index+count] != '+' && lrgsz[index+count] != '\t')
                count++;

            if (first)
            {
                memcpy (stem1 [l], lrgsz+index, count);
                stem1 [l][count] = '\0';
                winfo [l] = BaseCheck.vbuf [i];
                first = FALSE;
            }
            else
            {
                memcpy (ending1 [l]+index2, lrgsz+index, count);
                index2 += count;
            }

            if (lrgsz[index+count] == '\t')
            {
                ending1 [l][index2] = '\0';
                l++;
                first = TRUE;
                index2 = 0;
            }
            index += (count + 1);
        }
        num1 = l;
        num = BaseCheck.NLP_BASE_VERB (lpStr2, lrgsz);
        for (i = 0, index = 0, l = 0, index2 = 0; i < num; i++)
        {
            count = 0;
            while (lrgsz [index+count] != '+' && lrgsz [index+count] != '\t')
                count++;

            if (first)
            {
                memcpy (stem2 [l], lrgsz+index, count);
                stem2 [l][count] = '\0';
                first = FALSE;
            }
            else
            {
                memcpy (ending2 [l]+index2, lrgsz+index, count);
                index2 += count;
            }

            if (lrgsz[index+count] == '\t')
            {
                ending2 [l][index2] = '\0';
                l++;
                first = TRUE;
                index2 = 0;
            }
            index += (count + 1);
        }
        num2 = l;

        int j;
        for (i = 0; i < num1; i++)
        {
            for (j = 0; j < num2; j++)
                if (lstrcmp (stem1[i], stem2 [j]) == 0)
                    break;
            if (j != num2)
                break;
        }

        if (i != num1)
        {
            lstrcpy (lpStem, stem1 [i]);
            lstrcpy (lpEnding1, ending1 [i]);
            lstrcpy (lpEnding2, ending2 [j]);
            *pos = winfo [i];
            GlobalUnlock (hgbl);
            return NULL;
        }
    }

    // for proper noun, for example, name
    if (pstmi->Option & SO_NP_PROPER)
    {
        int len1 = lstrlen(lpStr1);
        int len2 = lstrlen(lpStr2);
        int shortlen = len1 > len2 ? len2 : len1;
        if (strncmp (lpStr1, lpStr2, shortlen) == 0)
        {
            lstrcpy (lpStem, lpStr1);
            lpStem [shortlen] = '\0';
            char index [1];
            index[0] = 'm';

            CODECONVERT Conv;
            BOOL res1 = TRUE, res2= TRUE;

            lstrcpy (lpEnding1, lpStr1 + shortlen);
            lstrcpy (lpEnding2, lpStr2 + shortlen);
            if (lstrlen (lpEnding1))
            {
                Conv.HAN2INS ((char *)lpEnding1, inheosa1, codeWanSeong);
                if (!(FindHeosaWord(inheosa1, _TOSSI, &action) & FINAL))
                    res1 = FALSE;
            }

            if (lstrlen (lpEnding2))
            {
                Conv.HAN2INS ((char *)lpEnding2, inheosa2, codeWanSeong);
                if (!(FindHeosaWord(inheosa2, _TOSSI, &action) & FINAL))
                    res2 = FALSE;
            }

            if (res1 && res2)
            {
                *pos = POS_NOUN | PROPER_NOUN;
                GlobalUnlock (hgbl);
                return NULL;
            }
        }
    }

    GlobalUnlock (hgbl);
    return srcInvalid;
}

WINSRC StemmerIsEndingW (HSTM hstm, LPCWSTR lpStr, UINT flag, BOOL *found)
{

    LPSTR MultiByteStr;

    int len = WideCharToMultiByte (UWANSUNG_CODE_PAGE, 0, lpStr, -1, NULL, 0, NULL, NULL);
    MultiByteStr = (LPSTR) LocalAlloc (LPTR, len);
    // add a check for this point
    if (MultiByteStr == NULL ) {
       return srcModuleError;
    }
    len = WideCharToMultiByte (UWANSUNG_CODE_PAGE, 0, lpStr, -1, MultiByteStr, len, NULL, NULL);

    SRC src = StemmerIsEnding(hstm, MultiByteStr, flag, found);

    LocalFree (MultiByteStr);
    return src;

}

WINSRC StemmerIsEnding (HSTM hstm, LPCSTR lpStr, UINT flag, BOOL *found)
{
    BOOL tossiCheck, endingCheck;

    switch (flag)
    {
        case IS_TOSSI :    tossiCheck = TRUE; endingCheck = FALSE; break;
        case IS_ENDING : endingCheck = TRUE; tossiCheck = FALSE; break;
        case IS_TOSSI | IS_ENDING : tossiCheck = endingCheck = TRUE; break;
        default : return srcModuleError;
    }


    STMI    *pstmi;
    HGLOBAL hgbl = (HGLOBAL) hstm;

    pstmi = (STMI *)GlobalLock(hgbl);
    if (pstmi == NULL)
    {
        GlobalUnlock(hgbl);
        return srcModuleError | srcInvalidID;
    }

    BYTE    action;
    char *inheosa = (char *)LocalAlloc (LPTR, lstrlen(lpStr) * 4 + 1);
    // add a check for this point
    if (inheosa == NULL ) {
        GlobalUnlock(hgbl);
        return srcModuleError;
    }

    CODECONVERT Conv;
    Conv.HAN2INR ((char *)lpStr, inheosa, codeWanSeong);

    *found = FALSE;

    if (tossiCheck)
    {
        int res = FindHeosaWord(inheosa, _TOSSI, &action);
        if (res & FINAL)
        {
            *found = TRUE;
            endingCheck = FALSE;
        }
    }
    if (endingCheck)
    {
        int res = FindHeosaWord(inheosa, _ENDING, &action);
        if (res == FINAL)
            *found = TRUE;
    }

    LocalFree (inheosa);

    GlobalUnlock (hgbl);
    return NULL;
}

/*
BOOL WINAPI DllMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved){
    extern char TempJumpNum [], TempSujaNum [], TempBaseNum [], TempNumNoun [], TempSuffixOut [];
    extern char bTemp [], TempETC [], TempDap [];
    extern LenDict JumpNum;
    extern LenDict SujaNum;
    extern LenDict BaseNum;
    extern LenDict NumNoun;
    extern LenDict Suffix;
    extern LenDict B_Dict;
    extern LenDict T_Dict;
    extern LenDict Dap;

 switch(dwReason) {
      case DLL_PROCESS_ATTACH :
            JumpNum.InitLenDict(TempJumpNum, 5, 5);
            SujaNum.InitLenDict(TempSujaNum, 8, 27);
            BaseNum.InitLenDict(TempBaseNum, 5, 3);
            NumNoun.InitLenDict(TempNumNoun, 8, 32);
            Suffix.InitLenDict(TempSuffixOut, 8, 8);
            B_Dict.InitLenDict(bTemp, 5, 1);
            T_Dict.InitLenDict(TempETC, 10, 7);
            Dap.InitLenDict(TempDap, 5, 1);
            break ;
    case DLL_THREAD_ATTACH:
            break;
    case DLL_THREAD_DETACH:
            break;
    case DLL_PROCESS_DETACH  :
            break ;
    }    //switch

    return TRUE ;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\enu\wordbreaker\common\inc\varstr.h ===
////////////////////////////////////////////////////////////////////////////////
//
//      Filename :  VarStr.h
//      Purpose  :  To hold definition for CVarString
//
//      Project  :  Persistent Query
//      Component:  Common
//
//      Author   :  urib
//
//      Log:
//          Feb  2 1997 urib  Creation
//          Jun 19 1997 urib  Add counted operators.
//          Jun 24 1997 urib  Fix bad const declarations.
//          Dec 29 1997 urib  Add includes.
//          Feb  2 1999 yairh fix bug in SetMinimalSize.
//          Feb  8 1999 urib  Enable different built in sizes.
//          Feb 25 1999 urib  Add SizedStringCopy.
//          Jul  5 1999 urib  Fix SizedStringCopy..
//          May  1 2000 urib  Cleanup.
//          Nov 23 2000 urib  Fix a bug in counted copy and cat.
//
////////////////////////////////////////////////////////////////////////////////

#ifndef VARSTR_H
#define VARSTR_H

#pragma once

#include "AutoPtr.h"
#include "Excption.h"

////////////////////////////////////////////////////////////////////////////////
//
//  CVarString class definition
//
////////////////////////////////////////////////////////////////////////////////
template <ULONG ulStackSize = 0x10>
class TVarString
{
public:
    // Constructor - tips the implementation on the string size.
    TVarString(ULONG ulInitialSize = 0);
    // Constructor - copy this string.
    TVarString(PCWSTR);
    // Constructor - convert to UNICODE and copy this string.
    TVarString(const PSZ);
    // Copy Constructor
    TVarString(const TVarString&);
    ~TVarString();

    // Copy/Convert and copy the string.
    TVarString& Cpy(PCWSTR);
    TVarString& Cpy(const ULONG, PCWSTR);
    TVarString& Cpy(const PSZ);

    // Concatenate/Convert and concatenate the string to the existing string.
    TVarString& Cat(PCWSTR);
    TVarString& Cat(const ULONG, PCWSTR);
    TVarString& Cat(const PSZ);

    // Compare/Convert and compare the string to the existing string.
    int     Cmp(PCWSTR) const;
    int     Cmp(const PSZ) const;

    // Return the string length.
    ULONG   Len() const;

    // Allow access to the string memory.
    operator PWSTR() const;

    // Hint the implementation about the string size.
    void    SetMinimalSize(ULONG);

    // Set a specific character
    void    SetCharacter(ULONG, WCHAR);

    // Appends a backslash to the string if the last character is not a
    //   backslash.
    void    AppendBackslash();

    // Appends a slash to the string if the last character is not a
    //   slash.
    void    AppendSlash();

protected:
    // A predicate to see if memory is allocated or not.
    bool    IsAllocated();

    // The allocation size
    ULONG   m_ulSize;

    // This is the place for the standard string.
    WCHAR   m_rwchNormalString[ulStackSize + 1];

    // If the string is becoming too big we will allocate space for it.
    WCHAR*  m_pTheString;
private:
    TVarString&
    operator=(const TVarString& vsOther)
    {
        Cpy(vsOther);
        return *this;
    }
};


template <ULONG ulStackSize>
inline
TVarString<ulStackSize>::TVarString(ULONG ulInitialSize)
    :m_pTheString(m_rwchNormalString)
    ,m_ulSize(ulStackSize)
{
    SetMinimalSize(ulInitialSize);

    m_pTheString[0] = L'\0';
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>::TVarString(PCWSTR pwsz)
    :m_pTheString(m_rwchNormalString)
    ,m_ulSize(ulStackSize)
{
    Cpy(pwsz);
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>::TVarString(const PSZ psz)
    :m_pTheString(m_rwchNormalString)
    ,m_ulSize(ulStackSize)
{
    Cpy(psz);
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>::TVarString(const TVarString<ulStackSize>& vsOther)
    :m_pTheString(m_rwchNormalString)
    ,m_ulSize(ulStackSize)
{
    Cpy(vsOther);
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>::~TVarString()
{
    if (IsAllocated())
    {
        free(m_pTheString);
    }
}

template <ULONG ulStackSize>
inline
bool
TVarString<ulStackSize>::IsAllocated()
{
    return m_pTheString != m_rwchNormalString;
}

template <ULONG ulStackSize>
inline
void
TVarString<ulStackSize>::SetMinimalSize(ULONG ulNewSize)
{
    // We allocate a little more so if someone would like to add a slash
    //   or something, it will not cause us to realocate.
    //   On debug builds, I want to check for string overflows so I don't
    //   want the extra memory. Activating the reallocation mechanism is also'
    //   a good thing in debug builds.
#if !(defined(DEBUG))
    ulNewSize++;
#endif

    //
    // if the new size is smaller then what we have - bye bye
    //
    if (ulNewSize > m_ulSize)
    {
        //
        // We already allocated a string. Should change it's size
        //
        if (IsAllocated())
        {
            PWSTR pwszTemp = (PWSTR) realloc(
                m_pTheString,
                (ulNewSize + 1) * sizeof(WCHAR));

            if (NULL == pwszTemp)
            {
                THROW_MEMORY_EXCEPTION();
            }

            //
            // Save the new memory block.
            //
            m_pTheString = pwszTemp;

        }
        else
        {
            //
            // We move the string from the buffer to the allocation.
            //   Note that this is dangerous if someone took the buffer address.
            //   The user must always use the access method and never cache the
            //   string pointer.
            //
            m_pTheString = (PWSTR) malloc(sizeof(WCHAR) * (ulNewSize + 1));
            if (NULL == m_pTheString)
            {
                THROW_MEMORY_EXCEPTION();
            }

            wcsncpy(m_pTheString, m_rwchNormalString, m_ulSize + 1);
        }

        m_ulSize = ulNewSize;
    }
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>&
TVarString<ulStackSize>::Cpy(PCWSTR pwsz)
{
    return Cpy(wcslen(pwsz), pwsz);
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>&
TVarString<ulStackSize>::Cpy(const ULONG ulCount, PCWSTR pwsz)
{
    SetMinimalSize(ulCount + 1);

    wcsncpy(m_pTheString, pwsz, ulCount);

    m_pTheString[ulCount] = L'\0';

    return *this;
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>&
TVarString<ulStackSize>::Cpy(const PSZ psz)
{
    ULONG ulLength = strlen(psz);

    SetMinimalSize(ulLength);

    mbstowcs(m_pTheString, psz, ulLength + 1);

    return *this;
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>&
TVarString<ulStackSize>::Cat(PCWSTR pwsz)
{
    ULONG ulLength = wcslen(pwsz);

    return Cat(ulLength, pwsz);
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>&
TVarString<ulStackSize>::Cat(const ULONG ulLength, PCWSTR pwsz)
{
    ULONG   ulCurrentLength = Len();

    SetMinimalSize(ulCurrentLength + ulLength + 1);

    wcsncpy(m_pTheString + ulCurrentLength, pwsz, ulLength);

    m_pTheString[ulCurrentLength + ulLength] = L'\0';

    return *this;
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>&
TVarString<ulStackSize>::Cat(const PSZ psz)
{
    ULONG ulCurrentLength = Len();
    ULONG ulLength = strlen(psz);
    ULONG ulCharsToCopy = ulLength + 1;

    SetMinimalSize(ulCharsToCopy + ulCurrentLength);

    mbstowcs(m_pTheString + ulCurrentLength, psz, ulCharsToCopy);

    return *this;
}

template <ULONG ulStackSize>
inline
int
TVarString<ulStackSize>::Cmp(PCWSTR pwsz) const
{
    return wcscmp(m_pTheString, pwsz);
}

template <ULONG ulStackSize>
inline
int
TVarString<ulStackSize>::Cmp(const PSZ psz) const
{
    ULONG ulLength = strlen(psz);

    CAutoMallocPointer<WCHAR> apBuffer = (PWSTR) malloc(
        (ulLength + 1) * sizeof(WCHAR));

    mbstowcs(apBuffer.Get(), psz, ulLength + 1);

    return Cmp(apBuffer.Get());
}

template <ULONG ulStackSize>
inline
ULONG
TVarString<ulStackSize>::Len() const
{
    return wcslen(m_pTheString);
}

template <ULONG ulStackSize>
inline
TVarString<ulStackSize>::operator PWSTR() const
{
    return m_pTheString;
}

template <ULONG ulStackSize>
inline
void
TVarString<ulStackSize>::SetCharacter(ULONG ulIndex, WCHAR wch)
{
    SetMinimalSize(ulIndex + 2); // index to size + null

    if (L'\0' == m_pTheString[ulIndex])
    {
        m_pTheString[ulIndex + 1] = L'\0';
    }
    else if (L'\0' == wch)
    {
    }

    m_pTheString[ulIndex] = wch;
}

template <ULONG ulStackSize>
inline
void
TVarString<ulStackSize>::AppendSlash()
{
    if (L'/' != m_pTheString[Len() - 1])
        Cat(L"/");
}

template <ULONG ulStackSize>
inline
void
TVarString<ulStackSize>::AppendBackslash()
{
    if (L'\\' != m_pTheString[Len() - 1])
        Cat(L"\\");
}

typedef TVarString<4>       CShortVarString;
typedef TVarString<16>      CVarString;
typedef TVarString<256>     CLongVarString;
typedef TVarString<1024>    CHugeVarString;


////////////////////////////////////////////////////////////////////////////////
//
// String related utilities definition
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  ::SizedStringCopy
//      Purpose  :  This function copies ulSize wide characters from the source
//                    to the destination. It does not treat '\0' characters as
//                    end of string and does not append the end of string mark
//                    to the destination. Intended to be used instead of memcpy
//                    when copying wide string characters.
//
//      Parameters:
//          [in]    PWSTR pwszTarget
//          [in]    PCWSTR pwszSource
//          [in]    ULONG ulSize
//
//      Returns  :   PWSTR
//
//      Log:
//          Jan  2 2001 urib  Creation
//
////////////////////////////////////////////////////////////////////////////////

inline
PWSTR
SizedStringCopy(PWSTR pwszTarget, PCWSTR pwszSource, ULONG ulSize)
{
    return (PWSTR) memcpy(
                  (void*)pwszTarget,
                  (void*)pwszSource,
                  ulSize * sizeof(pwszSource[0]));
}

////////////////////////////////////////////////////////////////////////////////
//
//      Name     :  ::CoTaskDuplicateString
//      Purpose  :  strdup. Throwing though.
//
//      Parameters:
//          [in]    PCWSTR pwsz
//
//      Returns  :   PWSTR
//
//      Log:
//          Dec 25 2000 urib  Creation
//
////////////////////////////////////////////////////////////////////////////////

inline
PWSTR   CoTaskDuplicateString(PCWSTR pwsz)
{
    CAutoTaskPointer<WCHAR> apTempName =
        (PWSTR)CoTaskMemAlloc(sizeof(WCHAR) * (1 + wcslen(pwsz)));

    if (!apTempName.IsValid())
    {
         THROW_MEMORY_EXCEPTION();
    }

    wcscpy(apTempName.Get(), pwsz);

    return apTempName.Detach();
}

#endif /* VARSTR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\basecik.hpp ===
// =========================================================================
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
// =========================================================================

#include <stdlib.h>
#include <string.h>
#include <io.h>
#include "basecore.hpp"
#include "basegbl.hpp"

char    TempCikha[7][9] = 
        {
            {__K_I,   __V_k, __K_S_D,   __K_I, __V_j, __K_S_D, __K_I, __V_m, 0},    
            {__K_I,   __V_k, __K_S_D,   __K_I, __V_m,       0,     0,     0, 0},    
            {__K_I,   __V_j, __K_S_D,   __K_I, __V_j, __K_S_D, __K_I, __V_m, 0},    
            {__K_I,   __V_j, __K_S_D,   __K_I, __V_m,       0,     0,     0, 0},    
            {__K_S_D, __K_I,   __V_j, __K_S_D, __K_I,   __V_m,     0,     0, 0},    
            {__K_S_D, __K_I,   __V_m,       0,     0,       0,     0,     0, 0},    
            {__K_I,   __V_m,       0,       0,     0,       0,     0,     0, 0}     
        };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\baseaux.hpp ===
// =========================================================================
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
// =========================================================================

#include <string.h>
#include <stdlib.h>
#include "basecore.hpp"
#include "basegbl.hpp"

/*
char    Temp[2][5] = 
        {
            {__K_I, __V_j, __K_B, __K_S, 0}, 
            {__K_I, __V_l, __K_S_D, 0}       
        };
*/

char    TempDOP[] = {__K_D, __V_h, __K_B, 0};   

char    TempR[] = {__K_I, __V_l, __K_R, __V_m, 0}; 

char    TempP[] = {__K_P, __V_j, 0}; 

char ExceptAuxEnding[7][13] = 
{                   
               {__V_l, __K_J,     0,     0,     0,     0,     0,     0,     0,     0,     0, 0,  1}, 
               {__V_l, __K_J, __V_k, __K_I,     0,     0,     0,     0,     0,     0,     0, 0,  3}, 
               {__V_l, __K_J, __V_j, __K_I,     0,     0,     0,     0,     0,     0,     0, 0,  3}, 
               {__V_k, __K_H, __K_G, __V_l, __K_J, __K_M, __V_m, __K_I,     0,     0,     0, 0,  7}, 
               {__V_k, __K_H, __K_G, __V_l, __K_J, __K_M,     0,     0,     0,     0,     0, 0,  5}, 
               {__K_B, __V_j, __K_R, __V_m, __K_S, __K_G, __V_l, __K_J, __K_M, __V_m, __K_I, 0, 10}, 
               {__K_B, __V_j, __K_R, __V_m, __K_S, __K_G, __V_l, __K_J, __K_M,     0,     0, 0,  8}, 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\basecik.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
/////////////////////////////////////////////////////////////////////////////
#include "basecik.hpp"
#include "MainDict.h"

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_Cikha_Proc() 
//  Parameters      : char  *stem
//  Summary         :
//  Call Functions  : 
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_Cikha_Proc(char  *stem) 
{
    char    r_vowel,
            tmpstem[80],
            tmpending[10];  
    int     len, ix, res, ulspos, temp; 
            
    lstrcpy(tmpstem, stem);
    ulspos = lstrlen(tmpstem)-1;   
    
    if(__IsDefStem(ulspos, 5) == 1 &&    
       tmpstem[ulspos-5] == __K_M && tmpstem[ulspos-4] == __K_J && 
       tmpstem[ulspos-3] == __V_l && tmpstem[ulspos-2] == __K_G && 
       tmpstem[ulspos-1] == __K_H && tmpstem[ulspos] == __V_k)         
    {   
        temp = ulspos;
        __DelStemN(tmpstem, &temp, 6);
        ulspos = temp;
                                      
        
        if(((len = NLP_Cikha_Conditions(tmpstem, TempCikha[0])) != INVALID) ||
           ((len = NLP_Cikha_Conditions(tmpstem, TempCikha[1])) != INVALID))
        {                                   
            r_vowel = UDEF;     // undefined                                       
            for(ix = ulspos - len ; ix >= 0; ix--)  
            {
                if (tmpstem[ix] >= __V_k) 
                {
                    r_vowel = tmpstem[ix];
                    break;
                }
            }                
            if (r_vowel == __V_k || r_vowel == __V_h || r_vowel == __V_i)   
            {
                temp = ulspos;
                __DelStemN(tmpstem, &temp, len);
                ulspos = temp;   
                if((res = NLP_AUX_Find(tmpstem, 0)) < INVALID)            
                {            
                    return Cikha_VALID;
                }
                switch(tmpstem[ulspos])
                {                 
                    case __K_B:     
                            if(FindIrrWord(tmpstem, _IV_BP) & FINAL)                                      
                            {
                                return INVALID;
                            }                                                    
                            break;
                    case __K_S:     
                            if(FindIrrWord(tmpstem, _IV_SP) & FINAL)                                      
                            {                                                       
                                return INVALID;
                            }          
                            break;
                    case __K_D:     
                            if(FindIrrWord(tmpstem, _IV_DP) & FINAL)                                      
                            {
                                if(FindIrrWord(tmpstem, _RV_D) & FINAL)  // v2r
                                {   
                                    char tstem [80];
                                    Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
                                    lstrcat (lrgsz, tstem);
                                    vbuf [wcount++] = POS_VERB;
                                    return Cikha_VALID;           
                                } 
                                return INVALID;                                       
                            }                   
                            break;
                    case __K_R:     
                            __RepStem1(tmpstem, ulspos, __K_D);     
                            
                            if(FindIrrWord(tmpstem, _IV_DP) & FINAL)                                                   
                            {
                                char tstem [80];
                                Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
                                lstrcat (lrgsz, tstem);
                                vbuf [wcount++] = POS_VERB;
                                return Cikha_VALID;
                            }
                            __RepStem1(tmpstem, ulspos, __K_R);
                            break;
                }                 
                if(tmpstem[ulspos] >= __V_k)    
                {
                    temp = ulspos;
                    __AddStem1(tmpstem, &temp, __K_S);       
                    ulspos = temp;                                          
                    
                    if(FindIrrWord(tmpstem, _IV_SP) & FINAL)                                      
                    {                                     
                        char tstem [80];
                        Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
                        lstrcat (lrgsz, tstem);
                        vbuf [wcount++] = POS_ADJECTIVE;
                        return Cikha_VALID;
                    }             
                    __RepStem1(tmpstem, ulspos, __K_I);     
                    temp = ulspos;
                    __AddStem1(tmpstem, &temp, __V_m);       
                    ulspos = temp;       
                    
                    if(FindIrrWord(tmpstem, _IV_OmP) & FINAL)                                      
                    {                    
                        char tstem [80];
                        Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
                        lstrcat (lrgsz, tstem);
                        vbuf [wcount++] = POS_ADJECTIVE;
                        return Cikha_VALID;
                    }                                                               
                    temp = ulspos;
                    __DelStem2(tmpstem, &temp);      
                    ulspos = temp; 
                    if(tmpstem[ulspos] == __V_k)    
                    {
                        return MORECHECK;
                    }                                     
                }                    
                char tstem [80];
                Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
                if (FindSilsaWord (tstem) & _VERB)
                {
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = POS_VERB;
                    return Cikha_VALID;                   
                }                                                                            
            }                
        }                 
        
        lstrcpy(tmpstem, stem);    
        ulspos = lstrlen(tmpstem)-1;               
        temp = ulspos;
        __DelStemN(tmpstem, &temp, 6);       
        ulspos = temp;      
           
        
        if(((len = NLP_Cikha_Conditions(tmpstem, TempCikha[2])) != INVALID) ||
           ((len = NLP_Cikha_Conditions(tmpstem, TempCikha[3])) != INVALID))
        {                                   
            r_vowel = UDEF;     // undefined                
            for(ix = ulspos - len ; ix >= 0; ix--)  
            {
                if (tmpstem[ix] >= __V_k) 
                {
                    r_vowel = tmpstem[ix];
                    break;
                }
            }                
            if (r_vowel != __V_k && r_vowel != __V_h && r_vowel != __V_i)   
            {                         
                temp = ulspos;
                __DelStemN(tmpstem, &temp, len);
                ulspos = temp;   
                if((res = NLP_AUX_Find(tmpstem, 0)) < INVALID)            
                {            
                    return Cikha_VALID;
                }
                switch(tmpstem[ulspos])
                {                 
                    case __K_B:     
                            if(FindIrrWord(tmpstem, _IV_BM) & FINAL)                                      
                            {
                                return INVALID;
                            }                                                    
                            break;
                    case __K_S:     
                            if(FindIrrWord(tmpstem, _IV_SM) & FINAL)                                      
                            {
                                return INVALID;
                            }          
                            break;
                    case __K_D:     
                            if(FindIrrWord(tmpstem, _IV_DM) & FINAL)                                      
                            {
                                if(FindIrrWord(tmpstem, _RV_D) & FINAL)  // v2r
                                {             
                                    char tstem [80];
                                    Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
                                    lstrcat (lrgsz, tstem);
                                    vbuf [wcount++] = POS_VERB;
                                    return Cikha_VALID;           
                                } 
                                return INVALID;                                       
                            }                   
                            break;
                    case __K_R:     
                            __RepStem1(tmpstem, ulspos, __K_D);     
                            
                            if(FindIrrWord(tmpstem, _IV_DM) & FINAL)                                                   
                            {
                                char tstem [80];
                                Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
                                lstrcat (lrgsz, tstem);
                                vbuf [wcount++] = POS_VERB;
                                return Cikha_VALID;
                            }
                            __RepStem1(tmpstem, ulspos, __K_R);
                            break;
                }                 
                if(tmpstem[ulspos] >= __V_k)    
                {
                    temp = ulspos;
                    __AddStem1(tmpstem, &temp, __K_S);       
                    ulspos = temp;                                          
                    
                    if(FindIrrWord(tmpstem, _IV_SM) & FINAL)                                      
                    {                                     
                        char tstem [80];
                        Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
                        lstrcat (lrgsz, tstem);
                        vbuf [wcount++] = POS_VERB;
                        return Cikha_VALID;
                    }             
                    temp = ulspos;
                    __DelStem1(tmpstem, &temp);       
                    ulspos = temp; 
                    if(tmpstem[ulspos] == __V_j)    
                    {
                        return MORECHECK;
                    }                                     
                }                                        
                char tstem [80];
                Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
                if (FindSilsaWord (tstem) & _VERB)
                {
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = POS_VERB;
                    return Cikha_VALID;                   
                }                                                                            
            }                
        }                        
        
        
        lstrcpy(tmpstem, stem);    
        ulspos = lstrlen(tmpstem)-1;               
        temp = ulspos;
        __DelStemN(tmpstem, &temp, 6);       
        ulspos = temp;        
        
        if(((len = NLP_Cikha_Conditions(tmpstem, TempCikha[4])) != INVALID) ||
           ((len = NLP_Cikha_Conditions(tmpstem, TempCikha[5])) != INVALID))
        {                                   
            if(tmpstem[ulspos-len] >= __V_k)     
            {                    
                temp = ulspos;
                __DelStemN(tmpstem, &temp, len);
                ulspos = temp;                
                if(len == 6)
                {                 
                    lstrcpy(tmpending, TempCikha[4]);                
                }
                else
                {                    
                    lstrcpy(tmpending, TempCikha[5]);                
                }
                 _strrev(tmpending);

                if((res = NLP_Cikha_SS(tmpstem, tmpending)) < INVALID)
                {
                    return Cikha_VALID;
                }
                return res;                                    
            }
        }          
        if((len = NLP_Cikha_Conditions(tmpstem, TempCikha[6])) != INVALID) 
        {                                   
            if(tmpstem[ulspos-len] <= __K_H)     
            {                                         
                temp = ulspos;
                __DelStemN(tmpstem, &temp, len);
                ulspos = temp;  
                if((res = NLP_AUX_Find(tmpstem, 0)) < INVALID)            
                {            
                    return Cikha_VALID;
                }
                switch(tmpstem[ulspos])
                {                 
                    case __K_B:     
                            if((FindIrrWord(tmpstem, _IV_BP) & FINAL) ||
                               (FindIrrWord(tmpstem, _IV_BM) & FINAL))                                      
                            {
                                return INVALID;
                            }                                                    
                            break;
                    case __K_S:     
                            if((FindIrrWord(tmpstem, _IV_SP) & FINAL) ||
                               (FindIrrWord(tmpstem, _IV_SM) & FINAL))                                      
                            {
                                return INVALID;
                            }          
                            break;
                    case __K_D:     
                            if((FindIrrWord(tmpstem, _IV_DP) & FINAL) ||
                               (FindIrrWord(tmpstem, _IV_DM) & FINAL))                                      
                            {
                                if(FindIrrWord(tmpstem, _RV_D) & FINAL) // v2r
                                {   
                                    char tstem [80];
                                    Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
                                    lstrcat (lrgsz, tstem);
                                    vbuf [wcount++] = POS_VERB;
                                    return Cikha_VALID;           
                                } 
                                return INVALID;                                       
                            }                   
                            break;  
                }               
                char tstem [80];
                Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
                if (FindSilsaWord (tstem) & _VERB)
                {
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = POS_VERB;
                    return Cikha_VALID;                   
                }                                                                  
                temp = ulspos;
                __AddStem2(tmpstem, &temp, __K_I, __V_m);    
                ulspos = temp;                       
            }                
        }                                         
        
        if(tmpstem[ulspos] >= __V_k)              
        {                          
            if((res = NLP_AUX_Find(tmpstem, 0)) < INVALID)            
            {            
                return Cikha_VALID;
            }              
            char tstem [80];
            Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
            if (FindSilsaWord (tstem) & _VERB)
            {
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                return Cikha_VALID;                   
            }                 
            if(__IsDefStem(ulspos, 1) == 1 && tmpstem[ulspos-1] == __K_I && tmpstem[ulspos] == __V_m)  
            {
                temp = ulspos;
                __DelStem2(tmpstem, &temp);    
                ulspos = temp;                          
                if(tmpstem[ulspos] == __K_R)    
                {
                    __RepStem1(tmpstem, ulspos, __K_D);     
                    if((FindIrrWord(tmpstem, _IV_DP) & FINAL) ||    // v2+
                       (FindIrrWord(tmpstem, _IV_DM) & FINAL))      // v2-
                    {
                        char tstem [80];
                        Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
                        lstrcat (lrgsz, tstem);
                        vbuf [wcount++] = POS_VERB;
                        return Cikha_VALID;
                    }    
                    return INVALID;
                }                
                if(tmpstem[ulspos] >= __V_k)    
                {
                    temp = ulspos;
                    __AddStem1(tmpstem, &temp, __K_S);    
                    ulspos = temp;  
                    if((FindIrrWord(tmpstem, _IV_SP) & FINAL) ||    // v4+
                       (FindIrrWord(tmpstem, _IV_SM) & FINAL))      // v4-
                    {
                        char tstem [80];
                        Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
                        lstrcat (lrgsz, tstem);
                        vbuf [wcount++] = POS_VERB;
                        return Cikha_VALID;
                    }    
                    return INVALID;
                }                         
            }
            else if(__IsDefStem(ulspos, 1) == 1 && tmpstem[ulspos-1] == __K_I && tmpstem[ulspos] == __V_n)  
            {                              
                temp = ulspos;
                __DelStem1(tmpstem, &temp);    
                ulspos = temp;            
                __RepStem1(tmpstem, ulspos, __K_B);     
                if(FindIrrWord(tmpstem, _IV_BM) & FINAL)   // v3-                
                {
                    char tstem [80];
                    Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = POS_VERB;
                    return Cikha_VALID;
                }                
                if(__IsDefStem(ulspos, 2) == 1 && __IsDefStem(ulspos, 3) == 0 &&    
                   tmpstem[ulspos-2] == __K_D && tmpstem[ulspos-1] == __V_h && tmpstem[ulspos] == __K_B)
                {
                    char tstem [80];
                    Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = POS_VERB;
                    return Cikha_VALID;
                }                                                    
            }
            else if(__IsDefStem(ulspos, 1) == 1 && tmpstem[ulspos-1] == __K_I && tmpstem[ulspos] == __V_h)  
            {
                temp = ulspos;
                __DelStem1(tmpstem, &temp);    
                ulspos = temp;            
                __RepStem1(tmpstem, ulspos, __K_B);     
                if(__IsDefStem(ulspos, 2) == 1 && __IsDefStem(ulspos, 3) == 0 &&    
                   tmpstem[ulspos-2] == __K_D && tmpstem[ulspos-1] == __V_h && tmpstem[ulspos] == __K_B)
                {
                    return INVALID;
                }                                                    
                if(FindIrrWord(tmpstem, _IV_BP) & FINAL)   // v3+                
                {
                    char tstem [80];
                    Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = POS_VERB;
                    return Cikha_VALID;
                }                
            }                                                                       
            return BT;             
        }                            
    }                        
    return MORECHECK;             
} 

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_Cikha_Conditions() 
//  Parameters      : char  *stem    
//                    char  *conditions
//  Summary         :
//  Call Functions  : 
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_Cikha_Conditions(char  *stem, char  *condition)
{
    int i_stem = lstrlen(stem) - 1;
    int i_condition = lstrlen(condition) - 1;     
                                                 
    for( ; i_condition >= 0 && i_stem >= 0 ; )
    {
        if(stem[i_stem] != condition[i_condition])
        {
            return INVALID;
        }         
        i_stem--;
        i_condition--;
    }                     
    if(i_condition = -1 && i_stem >= 0)
    {
        return lstrlen(condition);
    }
    return INVALID;
} 

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_Cikha_SS() 
//  Parameters      : char  *stem    
//                    char  *conditions
//  Summary         :
//  Call Functions  : 
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_Cikha_SS(char  *stem, char *ending)
{
    char    tmp[80];
    int     ret, rULSPOS, temp;
            
    rULSPOS = lstrlen(stem)-1;
    lstrcpy(tmp, stem);
           
    ret = MORECHECK;                            
    switch (stem[rULSPOS])
    {
        case __V_l :        
            ret = NLP_Cikha_SS_Vl(stem, ending); 
            break;
        case __V_u :        
            if (__IsDefStem(rULSPOS, 1) == 1 && stem[rULSPOS-1] == __K_I) 
            {                                       
                ret = NLP_Cikha_SS_Vu_mrg(stem, ending);
                if (ret == Machine_T)        
                {
                    temp = rULSPOS;
                    __DelStem2(tmp, &temp);  
                    rULSPOS = temp;
                    if ((ret = NLP_Machine_T(tmp, ending)) == MORECHECK)    
                    {
                        ret = BT;
                    }                        
                }
                break;        
            }
            else
            {
                ret = NLP_Cikha_SS_Vu_irr(stem, ending);
            }                
            break; 
        case __V_nj :       
            ret = NLP_Cikha_SS_Vnj(stem, ending);
            break;
        case __V_hk :       
            ret = NLP_Cikha_SS_Vhk(stem, ending);
            break;
        case __V_ho :       
            ret = NLP_Cikha_SS_Vho(stem, ending);
            break;
        case __V_o :        
            if (__IsDefStem(rULSPOS, 1) == 1 && stem[rULSPOS-1] == __K_H) 
            {
                ret = NLP_Cikha_SS_Vo_KH(stem, ending);
            }    
            else 
            {
                ret = NLP_Cikha_SS_Vo(stem, ending);
            }                
            break;
        case __V_p :        
            ret = NLP_Cikha_SS_Vp(stem);
            break;
        case __V_j :        
            if (__IsDefStem(rULSPOS, 1) == 1 && stem[rULSPOS-1] == __K_R) 
                ret = NLP_Cikha_SS_Vj_KR(stem);
            else    ret = NLP_Cikha_SS_Vj(stem);                       
            break;                    
        case __V_k :        
            ret = NLP_Cikha_SS_Vk(stem, ending);           
            break;
        default :   ret = BT;
    }
    return ret;
}    

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------  
int BaseEngine::NLP_Cikha_SS_Vl(char  *stem,
                                char  *ending) 
{
    char    bupstem[80];
    int     res, rULSPOS, rLMEPOS, temp;
                
    lstrcpy(bupstem, stem);
    rULSPOS = lstrlen(stem)-1;
    rLMEPOS = lstrlen(ending)-1;
    
    if (__IsDefStem(rULSPOS, 1) == 1 && bupstem[rULSPOS-1] == __K_I ) 
    {                                                           
        if (__IsDefEnd(rLMEPOS, 0) == 1 && ending[rLMEPOS] == __K_S_D)  
        {                                                       
            temp = rULSPOS;
            __AddStem1(bupstem, &temp, __K_S_D);                 
            rULSPOS = temp;
            if((res = NLP_AUX_Find(bupstem, 0)) < INVALID)    
            {
                return res;
            }   
            if((res = NLP_AUX_Find(bupstem, 1)) < INVALID)    
            {
                return res;
            }                    
            
            if (FindIrrWord(bupstem, _ISS) & FINAL)
            {
                char tstem [80];
                Conv.INS2HAN (bupstem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                return Cikha_VALID;
            }                       
        }
        return INVALID;          
    }
    return BT;
}

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Cikha_SS_Vu_mrg(char  *stem,
                              char  *ending) 
{
    char    bupstem[80];
    int     res, rULSPOS, temp;
                
    rULSPOS = lstrlen(stem)-1;
    lstrcpy(bupstem, stem);
    
    if (__IsDefStem(rULSPOS, 3) == 1 && 
        bupstem[rULSPOS-3] == __K_H && bupstem[rULSPOS-2] == __V_k ) 
    {        
        temp = rULSPOS;
        __DelStem2(bupstem, &temp);                                  
        rULSPOS = temp;
        if ((res = NLP_AUX_Find(bupstem, 0)) < INVALID)    
        {
            return res;             
        }            
        char tstem [80];
        Conv.INS2HAN (bupstem, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _VERB)
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return Cikha_VALID;
        }            
        return BT;
    }                
    __RepStem1(bupstem, rULSPOS, __V_l);                            
    if ((res = NLP_AUX_Find(bupstem, 0)) < INVALID)
    {
        return res;
    }      
    char tstem [80];
    Conv.INS2HAN (bupstem, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _VERB)
    {
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return Cikha_VALID;
    }        
    if (ACT_N_E == 1 && bupstem[rULSPOS-2] >= __V_k)   
    {
        return Machine_T;
    }    
    return BT;
}

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Cikha_SS_Vu_irr(char  *stem,
                              char  *ending) 
{
    char    bupstem[80];
    int     res, rULSPOS;
            
    rULSPOS = lstrlen(stem)-1;
    lstrcpy(bupstem,stem);
    
    if (FindIrrWord(bupstem, _ZUV_YO) & FINAL)  
    {
        char tstem [80];
        Conv.INS2HAN (bupstem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return Cikha_VALID;                                     
    }
    __RepStem1(bupstem, rULSPOS, __V_l);                        
    
    if ((res = NLP_AUX_Find(bupstem, 0)) < INVALID)  
    {
        return res;                        
    }    
    char tstem [80];
    Conv.INS2HAN (bupstem, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _VERB)
    {
        char tstem [80];
        Conv.INS2HAN (bupstem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return Cikha_VALID;   
    }
    return BT;
}

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Cikha_SS_Vnj(char  *stem,
                           char  *ending) 
{
    char    bupstem[80];
    int     res, rULSPOS, temp;
            
    rULSPOS = lstrlen(stem)-1;
    lstrcpy(bupstem,stem);

    __RepStem1(bupstem, rULSPOS, __V_n);        
    
    if ((res = NLP_AUX_Find(bupstem, 0)) < INVALID)
    {
        return res;
    }      
    char tstem [80];
    Conv.INS2HAN (bupstem, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _VERB)
    {
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return Cikha_VALID;
    }         
    if (__IsDefStem(rULSPOS, 1) == 1 && bupstem[rULSPOS-1] == __K_I) 
    {                                                               
        temp = rULSPOS;
        __DelStem1(bupstem, &temp);
        rULSPOS = temp;
        __RepStem1(bupstem, rULSPOS, __K_B);                        
        if (FindIrrWord(bupstem, _IV_BM) & FINAL)   
        {
            char tstem [80];
            Conv.INS2HAN (bupstem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return Cikha_VALID;
        }
    }
    return BT;
}

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Cikha_SS_Vhk(char  *stem,
                           char  *ending) 
{
    char    bupstem[80];
    int     res, rULSPOS, temp;
            
    rULSPOS = lstrlen(stem)-1;
    lstrcpy(bupstem,stem);

    __RepStem1(bupstem, rULSPOS, __V_h);                 
    
    if ((res = NLP_AUX_Find(bupstem, 0)) < INVALID)
    {
        return res;
    }
    char tstem [80];
    Conv.INS2HAN (bupstem, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _VERB)
    {
        char tstem [80];
        Conv.INS2HAN (bupstem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return Cikha_VALID;
    }    
    if (__IsDefStem(rULSPOS, 1) == 1 && bupstem[rULSPOS-1] == __K_I) 
    {                                                   
        temp = rULSPOS;
        __DelStem1(bupstem, &temp);
        rULSPOS = temp;
        __RepStem1(bupstem, rULSPOS, __K_B);            
        if (FindIrrWord(bupstem, _IV_BP) & FINAL)   
        {
            char tstem [80];
            Conv.INS2HAN (bupstem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return Cikha_VALID;                                      
        }
    }
    return BT;
}

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Cikha_SS_Vho(char  *stem,
                           char  *ending) 
{
    char    bupstem[80];
    int     res, rULSPOS;
            
    rULSPOS = lstrlen(stem)-1;
    lstrcpy(bupstem,stem);

    __RepStem1(bupstem, rULSPOS, __V_hl);           
    
    if ((res = NLP_AUX_Find(bupstem, 0)) < INVALID)     
    {
        return res;
    }       
    char tstem [80];
    Conv.INS2HAN (bupstem, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _VERB)
    {
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return Cikha_VALID;
    }                                                     
    return BT;
}       

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Cikha_SS_Vo_KH(char  *stem,
                             char  *ending) 
{
    char    bupstem[80];
    int     res, rULSPOS;
            
    rULSPOS = lstrlen(stem)-1;
    lstrcpy(bupstem,stem);

    __RepStem1(bupstem, rULSPOS, __V_k);            

    if ((res = NLP_AUX_Find(bupstem, 0)) < INVALID)     
    {
        return res;
    }
    char tstem [80];
    Conv.INS2HAN (bupstem, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _VERB) 
    {
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return Cikha_VALID;
    }             
    return BT;
}
// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Cikha_SS_Vo(char  *stem,
                          char  *ending) 
{
    char    bupstem[80];
    int     res, rULSPOS;
            
    rULSPOS = lstrlen(stem)-1;
    lstrcpy(bupstem,stem);

    if ((res = NLP_AUX_Find(bupstem, 0)) < INVALID)     
    {
        return res;
    }
    char tstem [80];
    Conv.INS2HAN (bupstem, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _VERB) 
    {
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return Cikha_VALID;
    }                                                                       
    return BT;
}
// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Cikha_SS_Vp(  char  *stem) 
{
    char    bupstem[80];
    int        rULSPOS;
    
    rULSPOS = lstrlen(stem)-1;
    lstrcpy(bupstem,stem);

    if (FindIrrWord(bupstem, _ZUV_E) & FINAL)   
    {                                                           
        char tstem [80];
        Conv.INS2HAN (bupstem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return Cikha_VALID;                                       
    }            
    return BT;
}
// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Cikha_SS_Vil( char  *stem) 
{
    char    bupstem[80];
    int        rULSPOS, temp;
    
    rULSPOS = lstrlen(stem)-1;
    lstrcpy(bupstem,stem);

    if (__IsDefStem(rULSPOS, 1) == 1 && bupstem[rULSPOS-1] == __K_I) 
    {                                                               
        __RepStem1(bupstem, rULSPOS, __V_i);         
        temp = rULSPOS;
        __AddStem1(bupstem, &temp, __K_H);                           
        rULSPOS = temp;

        if (FindIrrWord(bupstem, _IA_HP) & FINAL)   
        {
            char tstem [80];
            Conv.INS2HAN (bupstem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return Cikha_VALID;
        }
        __RepStem2(bupstem, rULSPOS, __V_u, __K_H);                 
        if (FindIrrWord(bupstem, _IA_HM) & FINAL)   
        {
            char tstem [80];
            Conv.INS2HAN (bupstem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return Cikha_VALID;
        }
    }
    return BT;
}
// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Cikha_SS_Vul( char  *stem) 
{
    char    bupstem[80];
    int        temp, rULSPOS;
    
    rULSPOS = lstrlen(stem)-1;
    lstrcpy(bupstem,stem);

    if (__IsDefStem(rULSPOS, 1) == 1 && bupstem[rULSPOS-1] == __K_I) 
    {                                                               
        __RepStem1(bupstem, rULSPOS, __V_u);

        temp = rULSPOS;
        __AddStem1(bupstem, &temp, __K_H);                           
        rULSPOS = temp;

        if (FindIrrWord(bupstem, _IA_HM) & FINAL)   
        {                                                           
            char tstem [80];
            Conv.INS2HAN (bupstem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return Cikha_VALID;                                      
        }            
    }    
    return BT;
}   

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Cikha_SS_Vj_KR( char  *stem) 
{
    char    bupstem[80];
    int        rULSPOS, temp;
    
    rULSPOS = lstrlen(stem)-1;
    lstrcpy(bupstem,stem);

    temp = rULSPOS;
    __DelStem2(bupstem, &temp);                                      
    rULSPOS = temp;

   if (bupstem[rULSPOS] == __K_R)                                   
    {                                                               
        temp = rULSPOS;
        __AddStem1(bupstem, &temp, __V_m);                           
        rULSPOS = temp;
        if (FindIrrWord(bupstem, _IV_RmM) & FINAL)  
        {
            char tstem [80];
            Conv.INS2HAN (bupstem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return Cikha_VALID;
        }
        temp = rULSPOS;
        __DelStem1(bupstem, &temp);                                  
        __AddStem2(bupstem, &temp, __K_R, __V_m);                    
        rULSPOS = temp;
        if (FindIrrWord(bupstem, _IV_OmM) & FINAL)  
        {
            char tstem [80];
            Conv.INS2HAN (bupstem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return Cikha_VALID;
        } 
        return BT;
    }
    temp = rULSPOS;
    __AddStem2(bupstem, &temp, __K_R, __V_m);                        
    rULSPOS = temp;
                
    if (FindIrrWord(bupstem, _IV_OmM) & FINAL)      //v8-
    {
        char tstem [80];
        Conv.INS2HAN (bupstem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return Cikha_VALID;
    }                
    return BT;
}
// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Cikha_SS_Vj( char  *stem) 
{
    char    bupstem[80];
    int        rULSPOS;
    
    rULSPOS = lstrlen(stem)-1;
    lstrcpy(bupstem,stem);

    if (__IsDefStem(rULSPOS, 1) == 1 && __IsDefStem(rULSPOS, 2) == 0 && 
        bupstem[rULSPOS-1] == __K_P && bupstem[rULSPOS] == __V_j)   
    {        
        char tstem [80];
        Conv.INS2HAN (bupstem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return Cikha_VALID;
    }                
    if (FindIrrWord(bupstem, _ZUV_O) & FINAL)       
    {
        char tstem [80];
        Conv.INS2HAN (bupstem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return Cikha_VALID;                                       
    }
    __RepStem1(bupstem, rULSPOS, __V_m);                            
    if (FindIrrWord(bupstem, _IV_OmM) & FINAL)      
    {
        char tstem [80];
        Conv.INS2HAN (bupstem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return Cikha_VALID;
    }
    return BT;
}
// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Cikha_SS_Vk(  char  *stem,
                            char  *ending) 
{
    char    bupstem[80];
    int     res, rULSPOS, temp;
            
    rULSPOS = lstrlen(stem)-1;
    lstrcpy(bupstem,stem);
    
    if (__IsDefStem(rULSPOS, 1) == 1 && bupstem[rULSPOS-1] == __K_H)    
    {
        return BT;
    }                
    if ((res = NLP_AUX_Find(bupstem, 0)) < INVALID)
    {
        return res;
    }    
    if (FindIrrWord(bupstem, _ZUV_A) & FINAL)  
    {                                               
        char tstem [80];
        Conv.INS2HAN (bupstem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return Cikha_VALID;                                 
    }                                                     
    if (__IsDefStem(rULSPOS, 2) == 1 &&
        bupstem[rULSPOS-1] == __K_R &&      
        bupstem[rULSPOS-2] == __K_R)        
    {                                                         
        temp = rULSPOS;
        __DelStem2(bupstem, &temp);                          
        __AddStem1(bupstem, &temp, __V_m);                   
        rULSPOS = temp;

        if (FindIrrWord(bupstem, _IV_RmP) & FINAL) 
        {
            char tstem [80];
            Conv.INS2HAN (bupstem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return Cikha_VALID;
        }
        return BT;
    }
    __RepStem1(bupstem, rULSPOS, __V_m);                        
    if (FindIrrWord(bupstem, _IV_OmP) & FINAL)  
    {
        char tstem [80];
        Conv.INS2HAN (bupstem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return Cikha_VALID;
    }            
    return BT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\baseaux.cpp ===
// =========================================================================
//  Copyright (C) 1997 - 1998, Microsoft Corporation.  All Rights Reserved.
//
// File Name  : BASEAUX.CPP
// Function   : BASE ENGINE FUNCTION COLLECTION (AUX PROCESS)
//            : NLP Base Engine Function
// =========================================================================
#include "baseaux.hpp" 
#include "MainDict.h"


// Many peoples write verb and auxiliary verb without blank.
// In that case, we have to separate the ending of verb and the stem of auxiliary verb.
// Parameters : incode is reverse order.
// Return value : the start position of the stem of auxiliary verb
// made by dhyu -- 1996.3
int SeparateEnding (char *incode)
{
    int len = lstrlen (incode)-1;
    if (incode [len] == __K_I && incode [len-1] == __V_j)
        return len - 1;
    if (incode [len] == __K_I  && incode [len-1] == __V_k)
        return len - 1;
    if (incode [len] == __K_G && incode [len-1] == __V_p)
        return len - 1;
    if (incode [len] == __K_G && incode [len-1] == __V_h)
        return len - 1;
    if (incode [len] == __K_J && incode [len-1] == __V_l)
        return len - 1;
    return 0;
}

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_AUX_Find() 
//  Call Functions  : 
//  Description     :   
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_AUX_Find(char  *stem,
                             char    pum) 
{
    char    aux_stem[80], 
            aux_ending[80],
            tmp[80];

    int     reg, luls, temp;
        
    memset(aux_stem, NULL, 80);
    memset(aux_ending, NULL, 80);
    lstrcpy(aux_stem, stem);
                  
    if((reg = NLP_GET_AUX(aux_stem, aux_ending, pum)) != lTRUE)
    {     
        return reg;
    }        
    
    lstrcpy(tmp, aux_stem);
    luls = AUX_ULSPOS;        
    
    if(AUX_ACT_SS == 1) 
    {
        switch(AUXULS)
        {
            case __V_u :        
                if((reg = NLP_AUX_SS_Vu(aux_stem)) == Manha_Proc)
                {
                    temp = luls;
                    __DelStem2(tmp, &temp);   
                    luls = temp;                                  
                    if((reg = NLP_Manha_Proc(tmp)) < INVALID)    
                    {
                        if(reg == Manha_VALID)
                        {
                            reg = AUX_SS_Manha_VALID;
                        } 
                        else if(reg == Yenha_VALID)
                        {
                            reg = AUX_SS_Yenha_VALID;
                        }                                               
                    }
                }
                else if(reg == Manhaeci_Proc)
                {
                    __RepStem1(tmp, luls, __V_l);                    
                    if((reg = NLP_Manhaeci_Proc(tmp)) == Manhaeci_VALID)
                    {
                        reg = AUX_SS_Manhaeci_VALID;
                    }                                    
                }
                if (reg != MORECHECK)
                {
                    char tstem [80];
                    lstrcat (lrgsz, "+");
                    Conv.INR2HAN (aux_ending, tstem, codeWanSeong);
                    if (lstrlen (tstem) > 2)
                    {
                        int mark = SeparateEnding (aux_ending);
                        if (mark > 0)
                        {
                            char tmpending [80];
                            lstrcpy (tmpending, aux_ending);
                            Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                            lstrcat (lrgsz, tstem);
                            vbuf [wcount++] = POS_ENDING;
                            lstrcat (lrgsz, "+");
                            tmpending [mark] = '\0';
                            Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                        }
                    }
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;
                }
                return reg;                            
            case __V_nj :          
                if((reg = NLP_AUX_SS_Vnj(aux_stem)) == Dap_Proc)
                {
                    temp = luls;             
                    __DelStem1(tmp, &temp);  
                    luls = temp;
                    __RepStem1(tmp, luls, __K_B);
                    reg = NLP_Dap_Proc(tmp);  
                    if(reg == Dap_VALID)
                    {
                        reg = AUX_SS_Dap_VALID;
                    }                        
                }
                if (reg != MORECHECK)
                {
                    char tstem [80];
                    lstrcat (lrgsz, "+");
                    Conv.INR2HAN (aux_ending, tstem, codeWanSeong);
                    if (lstrlen (tstem) > 2)
                    {
                        int mark = SeparateEnding (aux_ending);
                        if (mark > 0)
                        {
                            char tmpending [80];
                            lstrcpy (tmpending, aux_ending);
                            Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                            lstrcat (lrgsz, tstem);
                            vbuf [wcount++] = POS_ENDING;
                            lstrcat (lrgsz, "+");
                            tmpending [mark] = '\0';
                            Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                        }
                    }
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;
                }
                return reg;
            case __V_hk :
                reg = NLP_AUX_SS_Vhk(aux_stem);
                if (reg != MORECHECK)
                {
                    char tstem [80];
                    lstrcat (lrgsz, "+");
                    Conv.INR2HAN (aux_ending, tstem, codeWanSeong);
                    if (lstrlen (tstem) > 2)
                    {
                        int mark = SeparateEnding (aux_ending);
                        if (mark > 0)
                        {
                            char tmpending [80];
                            lstrcpy (tmpending, aux_ending);
                            Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                            lstrcat (lrgsz, tstem);
                            vbuf [wcount++] = POS_ENDING;
                            lstrcat (lrgsz, "+");
                            tmpending [mark] = '\0';
                            Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                        }
                    }
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;
                }
                return reg;
            case __V_ho :                                                    
                __RepStem1(tmp, luls, __V_hl);
                if(AUX_ACT_VB == 1) 
                {
                    char tstem [80];
                    Conv.INS2HAN (tmp, tstem, codeWanSeong);
                    if (FindSilsaWord (tstem) & _VERB)
                    {
                        lstrcat (lrgsz, tstem);
                        vbuf [wcount++] = POS_VERB;
                        lstrcat (lrgsz, "+");
                        Conv.INR2HAN (aux_ending, tstem, codeWanSeong);
                        if (lstrlen (tstem) > 2)
                        {
                            int mark = SeparateEnding (aux_ending);
                            if (mark > 0)
                            {
                                char tmpending [80];
                                lstrcpy (tmpending, aux_ending);
                                Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                                lstrcat (lrgsz, tstem);
                                vbuf [wcount++] = POS_ENDING;
                                lstrcat (lrgsz, "+");
                                tmpending [mark] = '\0';
                                Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                            }
                        }
                        lstrcat (lrgsz, tstem);
                        vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;
                        return AUX_SS_VERB_VALID;
                    }
                }                
                if(AUX_ACT_AD == 1) 
                {
                    char tstem [80];
                    Conv.INS2HAN (tmp, tstem, codeWanSeong);
                    if (FindSilsaWord (tstem) & _ADJECTIVE)
                    {
                        lstrcat (lrgsz, tmp);
                        vbuf [wcount++] = POS_ADJECTIVE;
                        lstrcat (lrgsz, "+");
                        if (lstrlen (tstem) > 2)
                        {
                            int mark = SeparateEnding (aux_ending);
                            if (mark > 0)
                            {
                                char tmpending [80];
                                lstrcpy (tmpending, aux_ending);
                                Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                                lstrcat (lrgsz, tstem);
                                vbuf [wcount++] = POS_ENDING;
                                lstrcat (lrgsz, "+");
                                tmpending [mark] = '\0';
                                Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                            }
                        }
                        lstrcat (lrgsz, tstem);
                        vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;
                        return AUX_SS_ADJ_VALID;
                    }
                }
                return MORECHECK;
            case __V_o :
                if((reg = NLP_AUX_SS_Vo(aux_stem)) == Manha_Proc)
                {
                    __RepStem1(tmp, luls, __V_k);   
                    if((reg = NLP_Manha_Proc(tmp)) < INVALID)    
                    {   
                        if(reg == Manha_VALID)
                        {
                            reg = AUX_SS_Manha_VALID;
                        } 
                        else if(reg == Yenha_VALID)
                        {
                            reg = AUX_SS_Yenha_VALID;
                        }                                               
                    }                        
                }
                if (reg != MORECHECK)
                {
                    char tstem [80];
                    lstrcat (lrgsz, "+");
                    Conv.INR2HAN (aux_ending, tstem, codeWanSeong);
                    if (lstrlen (tstem) > 2)
                    {
                        int mark = SeparateEnding (aux_ending);
                        if (mark > 0)
                        {
                            char tmpending [80];
                            lstrcpy (tmpending, aux_ending);
                            Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                            lstrcat (lrgsz, tstem);
                            vbuf [wcount++] = POS_ENDING;
                            lstrcat (lrgsz, "+");
                            tmpending [mark] = '\0';
                            Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                        }
                    }
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;
                }
                return reg;               
            case __V_p :                             
                reg = NLP_AUX_SS_Vp(aux_stem);
                if (reg != MORECHECK)
                {
                    char tstem [80];
                    lstrcat (lrgsz, "+");
                    Conv.INR2HAN (aux_ending, tstem, codeWanSeong);
                    if (lstrlen (tstem) > 2)
                    {
                        int mark = SeparateEnding (aux_ending);
                        if (mark > 0)
                        {
                            char tmpending [80];
                            lstrcpy (tmpending, aux_ending);
                            Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                            lstrcat (lrgsz, tstem);
                            vbuf [wcount++] = POS_ENDING;
                            lstrcat (lrgsz, "+");
                            tmpending [mark] = '\0';
                            Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                        }
                    }
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;
                }
                return reg;
            case __V_O :                             
                reg = NLP_AUX_SS_Vil(aux_stem);
                if (reg != MORECHECK)
                {
                    char tstem [80];
                    lstrcat (lrgsz, "+");
                    Conv.INR2HAN (aux_ending, tstem, codeWanSeong);
                    if (lstrlen (tstem) > 2)
                    {
                        int mark = SeparateEnding (aux_ending);
                        if (mark > 0)
                        {
                            char tmpending [80];
                            lstrcpy (tmpending, aux_ending);
                            Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                            lstrcat (lrgsz, tstem);
                            vbuf [wcount++] = POS_ENDING;
                            lstrcat (lrgsz, "+");
                            tmpending [mark] = '\0';
                            Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                        }
                    }
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;
                }
                return reg;
            case __V_P :                             
                reg = NLP_AUX_SS_Vul(aux_stem);
                if (reg != MORECHECK)
                {
                    char tstem [80];
                    lstrcat (lrgsz, "+");
                    Conv.INR2HAN (aux_ending, tstem, codeWanSeong);
                    if (lstrlen (tstem) > 2)
                    {
                        int mark = SeparateEnding (aux_ending);
                        if (mark > 0)
                        {
                            char tmpending [80];
                            lstrcpy (tmpending, aux_ending);
                            Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                            lstrcat (lrgsz, tstem);
                            vbuf [wcount++] = POS_ENDING;
                            lstrcat (lrgsz, "+");
                            tmpending [mark] = '\0';
                            Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                        }
                    }
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;
                }
                return reg;
            case __V_j :
                if(aux_stem[luls-1] == __K_R)
                    reg = NLP_AUX_SS_Vj_KR(aux_stem);
                else
                    reg = NLP_AUX_SS_Vj(aux_stem);

                if (reg != MORECHECK)
                {
                    char tstem [80];
                    lstrcat (lrgsz, "+");
                    Conv.INR2HAN (aux_ending, tstem, codeWanSeong);
                    if (lstrlen (tstem) > 2)
                    {
                        int mark = SeparateEnding (aux_ending);
                        if (mark > 0)
                        {
                            char tmpending [80];
                            lstrcpy (tmpending, aux_ending);
                            Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                            lstrcat (lrgsz, tstem);
                            vbuf [wcount++] = POS_ENDING;
                            lstrcat (lrgsz, "+");
                            tmpending [mark] = '\0';
                            Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                        }
                    }
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;
                }
                return reg;
            case __V_k :
                if((reg = NLP_AUX_SS_Vk(aux_stem)) == Gop_Proc)
                {
                    __RepStem1(tmp, luls, __V_m);
                    reg = NLP_Gop_Proc(tmp);
                    if(reg == Gop_VALID)
                    {
                        reg = AUX_SS_Gop_VALID;
                    }                        
                }       
                if (reg != MORECHECK)
                {
                    char tstem [80];
                    lstrcat (lrgsz, "+");
                    Conv.INR2HAN (aux_ending, tstem, codeWanSeong);
                    if (lstrlen (tstem) > 2)
                    {
                        int mark = SeparateEnding (aux_ending);
                        if (mark > 0)
                        {
                            char tmpending [80];
                            lstrcpy (tmpending, aux_ending);
                            Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                            lstrcat (lrgsz, tstem);
                            vbuf [wcount++] = POS_ENDING;
                            lstrcat (lrgsz, "+");
                            tmpending [mark] = '\0';
                            Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                        }
                    }
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;
                }
                return reg;                                        
            case __V_np :                 
                if(__IsDefStem(luls, 1) == 1 && __IsDefStem(luls, 2) == 0 && 
                    tmp[luls-1] == __K_G_D)  
                {      
                    char tstem [80];
                    char SK_WE[3] = {'\xB2', '\xE7', 0};

                    lstrcat (lrgsz, SK_WE);
                    vbuf [wcount++] = POS_VERB;
                    lstrcat (lrgsz, "+");
                    Conv.INR2HAN (aux_ending, tstem, codeWanSeong);
                
                    if (lstrlen (tstem) > 2)
                    {
                        int mark = SeparateEnding (aux_ending);
                        if (mark > 0)
                        {
                            char tmpending [80];
                            lstrcpy (tmpending, aux_ending);
                            Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                            lstrcat (lrgsz, tstem);
                            vbuf [wcount++] = POS_ENDING;
                            lstrcat (lrgsz, "+");
                            tmpending [mark] = '\0';
                            Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                        }
                    }
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;
                    
                    return AUX_SS_VERB_VALID;
                }                
                return INVALID;
            default : return MORECHECK;
        }                                                
    }
    
    if((reg = NLP_AUX_VCV_Check(aux_stem, aux_ending)) < INVALID)
    {
        if(AUX_ACT_VB == 1) 
        {
            char tstem [80];
            Conv.INS2HAN (aux_stem, tstem, codeWanSeong);
            if (FindSilsaWord (tstem) & _VERB)
            {             
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                lstrcat (lrgsz, "+");
                Conv.INR2HAN (aux_ending, tstem, codeWanSeong);
                
                if (lstrlen (tstem) > 2)
                {
                    int mark = SeparateEnding (aux_ending);
                    if (mark > 0)
                    {
                        char tmpending [80];
                        lstrcpy (tmpending, aux_ending);
                        Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                        lstrcat (lrgsz, tstem);
                        vbuf [wcount++] = POS_ENDING;
                        lstrcat (lrgsz, "+");
                        tmpending [mark] = '\0';
                        Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                    }
                }
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;                
                return AUX_VERB_VALID;
            }                
        }                                               
        if(AUX_ACT_AD == 1) 
        {
            char tstem [80];
            Conv.INS2HAN (aux_stem, tstem, codeWanSeong);
            if (FindSilsaWord (tstem) & _ADJECTIVE) 
            {
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_ADJECTIVE;
                lstrcat (lrgsz, "+");
                Conv.INR2HAN (aux_ending, tstem, codeWanSeong);

                if (lstrlen (tstem) > 2)
                {
                    int mark = SeparateEnding (aux_ending);
                    if (mark > 0)
                    {
                        char tmpending [80];
                        lstrcpy (tmpending, aux_ending);
                        Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                        lstrcat (lrgsz, tstem);
                        vbuf [wcount++] = POS_ENDING;
                        lstrcat (lrgsz, "+");
                        tmpending [mark] = '\0';
                        Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                    }
                }
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;
                return AUX_ADJ_VALID;
            }                
            if(NLP_Dap_Proc(aux_stem) == Dap_VALID) 
            {   
                char tstem [80];
                lstrcat (lrgsz, "+");
                Conv.INR2HAN (aux_ending, tstem, codeWanSeong);

                if (lstrlen (tstem) > 2)
                {
                    int mark = SeparateEnding (aux_ending);
                    if (mark > 0)
                    {
                        char tmpending [80];
                        lstrcpy (tmpending, aux_ending);
                        Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                        lstrcat (lrgsz, tstem);
                        vbuf [wcount++] = POS_ENDING;
                        lstrcat (lrgsz, "+");
                        tmpending [mark] = '\0';
                        Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                    }
                }
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;
                
                return AUX_Dap_VALID;
            }                            
            if(NLP_Gop_Proc(aux_stem) == Gop_VALID)
            {
                char tstem [80];
                lstrcat (lrgsz, "+");
                Conv.INR2HAN (aux_ending, tstem, codeWanSeong);

                if (lstrlen (tstem) > 2)
                {
                    int mark = SeparateEnding (aux_ending);
                    if (mark > 0)
                    {
                        char tmpending [80];
                        lstrcpy (tmpending, aux_ending);
                        Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                        lstrcat (lrgsz, tstem);
                        vbuf [wcount++] = POS_ENDING;
                        lstrcat (lrgsz, "+");
                        tmpending [mark] = '\0';
                        Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                    }
                }
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;
                
                return AUX_Gop_VALID;
            }                           
            if((reg = NLP_Manha_Proc(aux_stem)) < INVALID)
            {
                if(reg == Manha_VALID)
                {
                    char tstem [80];
                    lstrcat (lrgsz, "+");
                    Conv.INR2HAN (aux_ending, tstem, codeWanSeong);

                    if (lstrlen (tstem) > 2)
                    {
                        int mark = SeparateEnding (aux_ending);
                        if (mark > 0)
                        {
                            char tmpending [80];
                            lstrcpy (tmpending, aux_ending);
                            Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                            lstrcat (lrgsz, tstem);
                            vbuf [wcount++] = POS_ENDING;
                            lstrcat (lrgsz, "+");
                            tmpending [mark] = '\0';
                            Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                        }
                    }
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;
                    
                    return AUX_Manha_VALID;
                }                            
                if(reg == Yenha_VALID)
                {
                    char tstem [80];
                    lstrcat (lrgsz, "+");
                    Conv.INR2HAN (aux_ending, tstem, codeWanSeong);

                    if (lstrlen (tstem) > 2)
                    {
                        int mark = SeparateEnding (aux_ending);
                        if (mark > 0)
                        {
                            char tmpending [80];
                            lstrcpy (tmpending, aux_ending);
                            Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                            lstrcat (lrgsz, tstem);
                            vbuf [wcount++] = POS_ENDING;
                            lstrcat (lrgsz, "+");
                            tmpending [mark] = '\0';
                            Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                        }
                    }
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;
                    
                    return AUX_Yenha_VALID;
                }            
            }                
            if((reg = NLP_Manhaeci_Proc(aux_stem)) == Manhaeci_VALID)
            {
                char tstem [80];
                lstrcat (lrgsz, "+");
                Conv.INR2HAN (aux_ending, tstem, codeWanSeong);

                if (lstrlen (tstem) > 2)
                {
                    int mark = SeparateEnding (aux_ending);
                    if (mark > 0)
                    {
                        char tmpending [80];
                        lstrcpy (tmpending, aux_ending);
                        Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                        lstrcat (lrgsz, tstem);
                        vbuf [wcount++] = POS_ENDING;
                        lstrcat (lrgsz, "+");
                        tmpending [mark] = '\0';
                        Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                    }
                }
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;

                return AUX_Manhaeci_VALID;
            }                            
        }                                               
    }      
    else if(reg == INVALID)
    {
        return INVALID;
    }       
    if(AUX_ACT_C == 0 && AUX_ACT_V == 1) 
    {
        if(__IsDefStem(AUXULS, 2) == 1 && 
            aux_stem[luls] == __V_n && aux_stem[luls-1] == __K_I)
        {
            if((reg = NLP_AUX_IRR_01(aux_stem)) == Dap_Proc)
            {
                temp = luls;
                __DelStem1(tmp, &temp);
                luls = temp;
                __RepStem1(tmp, luls, __K_B);   
                reg = NLP_Dap_Proc(tmp); 
                if(reg == Dap_VALID)
                {
                    reg = AUX_Irr_Dap_VALID;
                }                    
            }
            if(reg != MORECHECK)
            {
                char tstem [80];
                lstrcat (lrgsz, "+");
                Conv.INR2HAN (aux_ending, tstem, codeWanSeong);

                if (lstrlen (tstem) > 2)
                {
                    int mark = SeparateEnding (aux_ending);
                    if (mark > 0)
                    {
                        char tmpending [80];
                        lstrcpy (tmpending, aux_ending);
                        Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                        lstrcat (lrgsz, tstem);
                        vbuf [wcount++] = POS_ENDING;
                        lstrcat (lrgsz, "+");
                        tmpending [mark] = '\0';
                        Conv.INR2HAN (tmpending, tstem, codeWanSeong);
                    }
                }
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;

                return reg;
            }
        }                                     
    }
    switch (AUXLME)
    {
        case __K_N :
            reg = NLP_AUX_IRR_KN(aux_stem); break;
        case __K_R :
            reg = NLP_AUX_IRR_KR(aux_stem); break;
        case __K_I :
            if(AUXULS == __K_R)
            {
                reg = NLP_AUX_IRR_KI_KR(aux_stem, aux_ending); break;
            }                
    else if(AUXULS >= __V_k)
            {
                reg = NLP_AUX_IRR_KI_V(aux_stem, aux_ending); break;
            }     
    else
        return MORECHECK;           
    }

    if (reg != MORECHECK)
    {
        char tstem [80];
        lstrcat (lrgsz, "+");
        Conv.INR2HAN (aux_ending, tstem, codeWanSeong);

        if (lstrlen (tstem) > 2)
        {
            int mark = SeparateEnding (aux_ending);
            if (mark > 0)
            {
                char tmpending [80];
                lstrcpy (tmpending, aux_ending);
                Conv.INR2HAN (tmpending+mark, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_ENDING;
                lstrcat (lrgsz, "+");
                tmpending [mark] = '\0';
                Conv.INR2HAN (tmpending, tstem, codeWanSeong);
            }
        }
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = (pum == 0) ? POS_AUXVERB : POS_AUXADJ;

        return reg;
    }

    return MORECHECK;
} 

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_GET_AUX()  
//  Parameters      : char  *aux_stem :
//                    char  *aux_ending : 
//                    char  *dummyl :
//                    char pum :
//  Summary         :
//  Description     :   
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_GET_AUX(char  *aux_stem,
                            char  *aux_ending, 
                            char pum)
{
    BYTE    tempaction;
    char    action,
            dummyl[1];
            
    int     res,
            checked = -1, 
            aux_pos = 0, 
            dictnum = (pum == 0) ? 7 : 8,             
            codelen = lstrlen(aux_stem) - 1;    

    for (int i = 0; i <= codelen; i++) 
    {
         aux_ending[i] = aux_stem[codelen-i];    
         aux_ending[i+1] = NULLCHAR;
         if (pum == 0)
             res = FindHeosaWord(aux_ending, _AUXVERB, &tempaction);
         else
             res = FindHeosaWord(aux_ending, _AUXADJ, &tempaction);
        switch (res)
        {
        case FINAL :
        case FINAL_MORE :
            checked = i;
            action = tempaction; 
            continue;
        case FALSE_MORE :
            continue;
        case NOT_FOUND :
            break;
        }            
        break;
    }                          
    if(checked == -1)
    {
        return MORECHECK;   
    }
    aux_stem[codelen-checked] = NULLCHAR;   
    aux_ending[checked+1] = NULLCHAR;
    AUX_ULSPOS = codelen-checked-1; 
    AUX_LMEPOS = checked;          
    AUX_ACT_C  = GetBit(action, 7); 
    AUX_ACT_V  = GetBit(action, 6);
    AUX_ACT_VB = GetBit(action, 5); 
    AUX_ACT_AD = GetBit(action, 4);
    AUX_ACT_SS = GetBit(action, 2);  
    
    for (int z = 0; z < 7; z++)
    {
        if(strcmp(aux_ending, ExceptAuxEnding[z]) == 0) 
        {
            aux_pos = -1;                    
            break;
        }        
    } 
        
    return lTRUE;
}

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_AUX_IRR_01() 
//  Parameters      : char  *stem :
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_AUX_IRR_01( char  *aux_stem)
{
    char    tmp[80]; 
    int        luls, temp;

    lstrcpy(tmp, aux_stem);
    luls = AUX_ULSPOS;
                
    if(__IsDefStem(luls, 1) == 1 && 
        tmp[luls-1] == __K_I && tmp[luls] == __V_n) 
    {                                   
        temp = luls;
        __DelStem1(tmp, &temp);
        luls = temp;
        __RepStem1(tmp, luls, __K_B);   
        if (FindIrrWord (tmp, _IV_BM) & FINAL)                
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_Irr_VERB_VALID;
        }
        if(strcmp(tmp, TempDOP) == 0)   
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_Irr_VERB_VALID;
        }
        if(AUX_ACT_AD == 1) 
        {
            if(FindIrrWord (tmp, _RA_B) & FINAL)                
            {
                return INVALID;
            }                                  
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            if (FindSilsaWord (tstem) & _ADJECTIVE) 
            {
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_ADJECTIVE;
                return AUX_Irr_ADJ_VALID;
            }
            return Dap_Proc;
        }
    }
    return MORECHECK;
}    

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_AUX_IRR_KN() 
//  Parameters      : char  *stem :
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_AUX_IRR_KN( char  *aux_stem)
{
    char    tmp[80]; 
    int        luls, temp;

    lstrcpy(tmp, aux_stem);
    luls = AUX_ULSPOS;
                
    if(AUX_ACT_C == 1) 
    {                   
        if(FindIrrWord(tmp, _YOP) & FINAL ||  
            FindIrrWord (tmp, _ISS) & FINAL)    
        {   
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return AUX_Irr_ADJ_VALID;
        }            
    }
    temp = luls;
    __AddStem1(tmp, &temp, __K_R);  
    luls = temp;

    char tstem [80];
    Conv.INS2HAN (tmp, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _VERB)
    {
        char tstem [80];
        Conv.INS2HAN (tmp, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return AUX_Irr_VERB_VALID;
    }
    if(AUX_ACT_AD == 1) 
    {
        char tstem [80];
        Conv.INS2HAN (tmp, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _ADJECTIVE) 
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return AUX_Irr_ADJ_VALID;
        }
        __RepStem1(tmp, luls, __K_H);    
        if(FindIrrWord(tmp, _IA_HP) & FINAL || 
            FindIrrWord(tmp, _IA_HM) & FINAL)   
        {            
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return AUX_Irr_ADJ_VALID;          
        }            
    }                             
    return MORECHECK;                            
}

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_AUX_IRR_KR() 
//  Parameters      : char  *stem :
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_AUX_IRR_KR( char  *aux_stem)
{
    char    tmp[80]; 
    int        temp, luls;

    lstrcpy(tmp, aux_stem);
    luls = AUX_ULSPOS;
                
    temp = luls;
    __AddStem1(tmp, &temp, __K_R);  
    luls = temp;
            
    char tstem [80];
    Conv.INS2HAN (tmp, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _VERB)  
    {
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return AUX_Irr_VERB_VALID;
    }
    if(AUX_ACT_AD == 1) 
    {
        char tstem [80];
        Conv.INS2HAN (tmp, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _ADJECTIVE) 
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return AUX_Irr_ADJ_VALID;
        }
        __RepStem1(tmp, luls, __K_H);    
        if(FindIrrWord(tmp, _IA_HP) & FINAL || 
            FindIrrWord(tmp, _IA_HM) & FINAL)   
        {            
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return AUX_Irr_ADJ_VALID;            
        }            
    }
    return MORECHECK;
}

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_AUX_IRR_KI_KR() 
//  Parameters      : char  *stem :
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_AUX_IRR_KI_KR(  char  *aux_stem,
                                    char  *aux_ending)
{
    char    end[80],
            tmp[80]; 
    int        luls, llme;

    lstrcpy(tmp, aux_stem);
    lstrcpy(end, aux_ending);
    luls = AUX_ULSPOS;
    llme = AUX_LMEPOS;

    __RepStem1(tmp, luls, __K_D);  
    if(end[llme-1] == __V_j) 
    {
        if(FindIrrWord(tmp, _IV_DM) & FINAL)  //v2-
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_Irr_VERB_VALID;
        }            
        return MORECHECK;
    }            
    if(end[llme-1] == __V_k) 
    {
        if(FindIrrWord(tmp, _IV_DP) & FINAL)  //v2+
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_Irr_VERB_VALID;
        }     
        return MORECHECK;
    }                    
    if(FindIrrWord(tmp, _IV_DP) & FINAL || //v2+
        FindIrrWord(tmp, _IV_DM) & FINAL)   //v2-
    {        
        char tstem [80];
        Conv.INS2HAN (tmp, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return AUX_Irr_VERB_VALID;
    }   
    return MORECHECK;
}

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_AUX_IRR_KI_V() 
//  Parameters      : char  *stem :
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_AUX_IRR_KI_V(   char  *aux_stem,
                                    char  *aux_ending)
{
    char    end[80],
            tmp[80]; 
    int        temp, luls, llme;

    lstrcpy(tmp, aux_stem);
    lstrcpy(end, aux_ending);
    luls = AUX_ULSPOS;
    llme = AUX_LMEPOS;

    temp = luls;
    __AddStem1(tmp, &temp, __K_S);  
    luls = temp;

    if(end[llme-1] == __V_j) 
    {
        if(FindIrrWord(tmp, _IV_SM) & FINAL)   //v4- 
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_Irr_VERB_VALID;
        }     
        return MORECHECK;
    }        
    if(end[llme-1] == __V_k) 
    {
        if(FindIrrWord(tmp, _IV_SP) & FINAL)   //v4+
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_Irr_VERB_VALID;
        }
        temp = luls;
        __DelStem1(tmp, &temp);
        __AddStem2(tmp, &temp, __K_I, __V_m);
        luls = temp;        
        if(FindIrrWord(tmp, _IV_OmP) & FINAL)   //v8+
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_Irr_VERB_VALID;
        }        
        return MORECHECK;
    }                    
    if(FindIrrWord(tmp, _IV_SP) & FINAL || //v4+
        FindIrrWord(tmp, _IV_SM) & FINAL)   //v4-
    {            
        char tstem [80];
        Conv.INS2HAN (tmp, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return AUX_Irr_VERB_VALID;
    }
    return MORECHECK;
}

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_AUX_SS_Vu() 
//  Parameters      : char  *stem :
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_AUX_SS_Vu(  char  *aux_stem)
{
    char    tmp[80]; 
    int        temp, luls;

    lstrcpy(tmp, aux_stem);
    luls = AUX_ULSPOS;

    if(__IsDefStem(luls, 1) == 1 && tmp[luls-1] == __K_I) 
    {                  
        if(__IsDefStem(luls, 3) == 1 && 
            tmp[luls-3] == __K_H && tmp[luls-2] == __V_k ) 
        {    
            temp = luls;
            __DelStem2(tmp, &temp); 
            luls = temp;                                                     
            if(AUX_ACT_VB == 1)                            
            {
                char tstem [80];
                Conv.INS2HAN (tmp, tstem, codeWanSeong);
                if (FindSilsaWord (tstem) & _VERB)
                {
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = POS_VERB;
                    return AUX_SS_VERB_VALID;
                }                    
            }
            if(AUX_ACT_AD == 1) 
            {
                char tstem [80];
                Conv.INS2HAN (tmp, tstem, codeWanSeong);
                if (FindSilsaWord (tstem) & _ADJECTIVE) 
                {
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = POS_ADJECTIVE;
                    return AUX_SS_ADJ_VALID;
                }
            }
            return Manha_Proc;
        }
    }                                    
    if(AUX_ACT_VB == 1)    
    {
        if(FindIrrWord(tmp, _ZUV_YO) & FINAL)
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_SS_VERB_VALID;
        }
    }            
    __RepStem1(tmp, luls, __V_l); 
    if(AUX_ACT_VB == 1) 
    {
        char tstem [80];
        Conv.INS2HAN (tmp, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _VERB)
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_SS_VERB_VALID;
        }
    }
    if(AUX_ACT_AD == 1) 
    {
        char tstem [80];
        Conv.INS2HAN (tmp, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _ADJECTIVE) 
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return AUX_SS_ADJ_VALID;
        }
    }      
    return Manhaeci_Proc;
}

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_AUX_SS_Vnj() 
//  Parameters      : char  *stem :
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_AUX_SS_Vnj(  char  *aux_stem)
{
    char    tmp[80]; 
    int        temp, luls;

    lstrcpy(tmp, aux_stem);
    luls = AUX_ULSPOS;

    __RepStem1(tmp, luls, __V_n);  

    if(AUX_ACT_VB == 1) 
    {
        char tstem [80];
        Conv.INS2HAN (tmp, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _VERB)
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_SS_VERB_VALID;            
        }
    }
    if(__IsDefStem(luls, 1) == 1 && tmp[luls-1] == __K_I) 
    {                               
        temp = luls;
        __DelStem1(tmp, &temp);
        luls = temp;
        __RepStem1(tmp, luls, __K_B);            
        if(AUX_ACT_VB == 1)                               
        {
            if(FindIrrWord(tmp, _IV_BM) & FINAL) 
            {
                char tstem [80];
                Conv.INS2HAN (tmp, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                return AUX_SS_VERB_VALID;
            }     
        }                 
        if(AUX_ACT_AD == 1) 
        {
            if(FindIrrWord(tmp, _RA_B) & FINAL)  
            {
                return INVALID;
            }
            if(FindIrrWord(tmp, _IA_BP) & FINAL) 
            {
                return INVALID;
            }
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            if (FindSilsaWord (tstem) & _ADJECTIVE) 
            {
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_ADJECTIVE;
                return AUX_SS_ADJ_VALID;
            }
            return Dap_Proc;
        }
    }
    return MORECHECK;
}

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_AUX_SS_Vhk() 
//  Parameters      : char  *stem :
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_AUX_SS_Vhk(  char  *aux_stem)
{
    char    tmp[80]; 
    int        temp, luls;

    lstrcpy(tmp, aux_stem);
    luls = AUX_ULSPOS;

    __RepStem1(tmp, luls, __V_h); 

    if(AUX_ACT_VB == 1)      
    {
        char tstem [80];
        Conv.INS2HAN (tmp, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _VERB)
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_SS_VERB_VALID;
        }
    }
    if(__IsDefStem(luls, 1) == 1 && tmp[luls-1] == __K_I) 
    {                             
        temp = luls;
        __DelStem1(tmp, &temp);
        luls = temp;
        __RepStem1(tmp, luls, __K_B); 
        if(AUX_ACT_VB == 1) 
        {
            if(FindIrrWord(tmp, _IV_BP) & FINAL)
            {
                char tstem [80];
                Conv.INS2HAN (tmp, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                return AUX_SS_VERB_VALID;
            }
        }                             
        if(AUX_ACT_AD == 1) 
        {
            if(FindIrrWord(tmp, _IA_BP) & FINAL) 
            {
                char tstem [80];
                Conv.INS2HAN (tmp, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_ADJECTIVE;
                return AUX_SS_ADJ_VALID;
            }                          
        }                            
    }              
    return MORECHECK;
}    

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_AUX_SS_Vo() 
//  Parameters      : char  *stem :
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_AUX_SS_Vo(  char  *aux_stem)
{
    char    tmp[80]; 
    int        temp, luls;

    lstrcpy(tmp, aux_stem);
    luls = AUX_ULSPOS;

    if(__IsDefStem(luls, 1) == 1 && tmp[luls-1] == __K_H) 
    {                                   
        __RepStem1(tmp, luls, __V_k);   
        if(AUX_ACT_VB == 1)                     
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            if (FindSilsaWord (tstem) & _VERB)
            {
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                return AUX_SS_VERB_VALID;                    
            }
        }
        if(AUX_ACT_AD == 1) 
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            if (FindSilsaWord (tstem) & _ADJECTIVE) 
            {
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_ADJECTIVE;
                return AUX_SS_ADJ_VALID;                    
            }
        }
        return Manha_Proc;
    }
    if(AUX_ACT_VB == 1)    
    {
        char tstem [80];
        Conv.INS2HAN (tmp, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _VERB)
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_SS_VERB_VALID;                    
        }
    }        
    if(AUX_ACT_AD == 1) 
    {
        if(FindIrrWord(tmp, _ZUA_AE) & FINAL) 
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return AUX_SS_ADJ_VALID;                    
        }                                                                
        __RepStem1(tmp, luls, __V_k);
        temp = luls;
        __AddStem1(tmp, &temp, __K_H); 
        luls = temp;
        if(FindIrrWord(tmp, _IA_HP) & FINAL) 
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return AUX_SS_ADJ_VALID;                    
        }
        __RepStem2(tmp, luls, __V_j, __K_H); 
        if(FindIrrWord(tmp, _IA_HM) & FINAL) 
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return AUX_SS_ADJ_VALID;                    
        }            
    }        
    return MORECHECK;
}

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_AUX_SS_Vp() 
//  Parameters      : char  *stem :
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_AUX_SS_Vp(  char  *aux_stem)
{
    char    tmp[80]; 
    int        luls, temp;

    lstrcpy(tmp, aux_stem);
    luls = AUX_ULSPOS;

    if(AUX_ACT_VB == 1)  
    {
        if(FindIrrWord(tmp, _ZUV_E) & FINAL) 
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_SS_VERB_VALID;    
        }
    }
    if(AUX_ACT_AD == 1) 
    {
        if(FindIrrWord(tmp, _ZUA_E) & FINAL) 
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return AUX_SS_ADJ_VALID; 
        }  
        __RepStem1(tmp, luls, __V_j);
        temp = luls;
        __AddStem1(tmp, &temp, __K_H);  
        luls = temp;
        if(FindIrrWord(tmp, _IA_HM) & FINAL)  
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return AUX_SS_ADJ_VALID;
        }    
    }  
    return MORECHECK;
}    

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_AUX_SS_Vil() 
//  Parameters      : char  *stem :
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_AUX_SS_Vil(  char  *aux_stem)
{
    char    tmp[80]; 
    int        temp, luls;

    lstrcpy(tmp, aux_stem);
    luls = AUX_ULSPOS;

    if(AUX_ACT_AD == 1 && 
        __IsDefStem(luls, 1) == 1 && tmp[luls-1] == __K_I) 
    {                               
        __RepStem1(tmp, luls, __V_i);
        temp = luls;
        __AddStem1(tmp, &temp, __K_H);  
        luls = temp;   
        if(FindIrrWord(tmp, _IA_HP) & FINAL)  
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return AUX_SS_ADJ_VALID;
        }
        __RepStem2(tmp, luls, __V_u, __K_H); 
        if(FindIrrWord(tmp, _IA_HM) & FINAL) 
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return AUX_SS_ADJ_VALID;
        }            
    }
    return MORECHECK;
}    

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_AUX_SS_Vul() 
//  Parameters      : char  *stem :
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_AUX_SS_Vul(  char  *aux_stem)
{
    char    tmp[80]; 
    int        temp, luls;

    lstrcpy(tmp, aux_stem);
    luls = AUX_ULSPOS;

    if(AUX_ACT_AD == 1 && 
        __IsDefStem(luls, 1) == 1 && tmp[luls-1] == __K_I) 
    {    
        __RepStem1(tmp, luls, __V_u);
        temp = luls;
        __AddStem1(tmp, &temp, __K_H); 
        luls = temp;
        if(FindIrrWord(tmp, _IA_HM) & FINAL)
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return AUX_SS_ADJ_VALID;
        }            
    }
    return MORECHECK;
}    

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_AUX_SS_Vj_KR() 
//  Parameters      : char  *stem :
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_AUX_SS_Vj_KR(  char  *aux_stem)
{
    char    tmp[80]; 
    int        temp, luls;

    lstrcpy(tmp, aux_stem);
    luls = AUX_ULSPOS;

    temp = luls;
    __DelStem2(tmp, &temp);   
    luls = temp;

    if(__IsDefStem(luls, 1) == 1 && 
        tmp[luls-1] == __K_R && tmp[luls]==__V_m) 
    {               
        if(strcmp(tmp, TempR) == 0)   
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_SS_VERB_VALID;
        }
        if(AUX_ACT_AD == 1)
        {
            if(FindIrrWord(tmp, _IA_Rj) & FINAL) 
            {
                char tstem [80];
                Conv.INS2HAN (tmp, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_ADJECTIVE;
                return AUX_SS_ADJ_VALID;   
            }
        }
        return MORECHECK;
    }
    if(tmp[luls] == __K_R) 
    {                 
        temp = luls;
        __AddStem1(tmp, &temp, __V_m);  
        luls = temp;
        if(AUX_ACT_VB == 1) 
        {
            if(FindIrrWord(tmp, _IV_RmM) & FINAL) 
            {
                char tstem [80];
                Conv.INS2HAN (tmp, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                return AUX_SS_VERB_VALID;    
            }
        }            
        if(AUX_ACT_AD == 1) 
        {
            if(FindIrrWord(tmp, _IA_RmM) & FINAL) 
            {
                char tstem [80];
                Conv.INS2HAN (tmp, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_ADJECTIVE;
                return AUX_SS_ADJ_VALID; 
            }
        }
        temp = luls;
        __DelStem2(tmp, &temp);      
        __AddStem1(tmp, &temp, __K_R);    
        __AddStem2(tmp, &temp, __K_R, __V_m);     
        luls = temp;
        if(FindIrrWord(tmp, _IV_OmM) & FINAL) 
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_SS_VERB_VALID;     
        }
        return MORECHECK;
    }
    temp = luls;
    __AddStem2(tmp, &temp, __K_R, __V_m);
    luls = temp;   
    if(AUX_ACT_VB == 1) 
    {
        if(FindIrrWord(tmp, _IV_OmM) & FINAL) 
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_SS_VERB_VALID;       
        }
    }        
    return MORECHECK;
}    

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_AUX_SS_Vj() 
//  Parameters      : char  *stem :


//  Call Functions  : 


//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_AUX_SS_Vj(  char  *aux_stem)
{
    char    tmp[80]; 
    int        luls;

    lstrcpy(tmp, aux_stem);
    luls = AUX_ULSPOS;

    if(AUX_ACT_VB == 1) 
    {
        if(strcmp(tmp, TempP) == 0)    // PEO
        {
    __RepStem1(tmp,luls,__V_n);
    char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_SS_VERB_VALID;                               
    }
        else if (FindIrrWord(tmp, _ZUV_O) & FINAL)   
        {            
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_SS_VERB_VALID;                               
        }
    }
    __RepStem1(tmp, luls, __V_m);                               
    if(AUX_ACT_VB == 1)                                                  
    {
        if(FindIrrWord(tmp, _IV_OmM) & FINAL)  
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_SS_VERB_VALID;
        }
    }
    if(AUX_ACT_AD == 1) 
    {
        if(FindIrrWord(tmp, _IA_OmM) & FINAL)  
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return AUX_SS_ADJ_VALID;
        }
    }            
    return MORECHECK;
}    

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_AUX_SS_Vk() 
//  Parameters      : char  *stem :


//  Call Functions  : 


//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_AUX_SS_Vk(  char  *aux_stem)
{
    char    tmp[80]; 
    int        luls, temp;

    lstrcpy(tmp, aux_stem);
    luls = AUX_ULSPOS;

    if(__IsDefStem(luls, 1) == 1 && tmp[luls-1] == __K_H)      
    {
        return MORECHECK;                   // by hjw : 95/3/14 INVALID -> MORECHECK
    }
    if(AUX_ACT_VB == 1)
    {
        if(FindIrrWord(tmp, _ZUV_A) & FINAL)   
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_SS_VERB_VALID;                               
        }
    }                
    if(AUX_ACT_AD == 1)
    {
        if(FindIrrWord(tmp, _ZUA_A) & FINAL)   
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return AUX_SS_ADJ_VALID;                               
        }
    }
    if(__IsDefStem(luls, 1) == 1 && tmp[luls-1] == __K_R) 
    {                                                           
        if(__IsDefStem(luls, 2) == 1 && tmp[luls-2] == __K_R) 
        {                                                       
            temp = luls;
            __DelStem2(tmp, &temp);                              
            __AddStem1(tmp, &temp, __V_m);                       
            luls = temp;                                     
            if(AUX_ACT_VB == 1)                                
            {
                if(FindIrrWord(tmp, _IV_RmP) & FINAL) 
                {
                    char tstem [80];
                    Conv.INS2HAN (tmp, tstem, codeWanSeong);
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = POS_VERB;
                    return AUX_SS_VERB_VALID;                       
                }                
            }
            if(AUX_ACT_AD == 1) 
            {
                if(FindIrrWord(tmp, _IA_RmP) & FINAL) 
                {
                    char tstem [80];
                    Conv.INS2HAN (tmp, tstem, codeWanSeong);
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = POS_ADJECTIVE;
                    return AUX_SS_ADJ_VALID;                       
                }   
            }                
            return MORECHECK;         
        }
    }        
    __RepStem1(aux_stem, AUX_ULSPOS, __V_m);                    
    if(AUX_ACT_VB == 1) 
    {
        if(FindIrrWord(tmp, _IV_OmP) & FINAL) 
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_SS_VERB_VALID;                               
        }
    }
    if(AUX_ACT_AD == 1) 
    {
        if(FindIrrWord(tmp, _IA_OmP) & FINAL) 
        {
            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return AUX_SS_ADJ_VALID;                               
        }            
    }
    return MORECHECK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\basecode.hpp ===
// =========================================================================
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
// =========================================================================

typedef struct ResultList
{
    char lrgsz [400];
    char iword [400];
    int vbuf [400];
    UINT max;
    UINT num;
    char *next;
}RLIST;

typedef struct StemmerInfo
{
        UINT            Option;
        RLIST            rList;
        BOOL            bMdr;
} STMI;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\basedict.hpp ===
//////////////////////////////////////////////////
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
// File    : DICTTYPE.HPP
// Project : project SIK

//////////////////////////////////////////////////
#if !defined __DICTTYPE_HPP
#define   __DICTTYPE_HPP    1

class  Dict
{
    public:
        virtual int FindWord(char  *w, char  &action, char  *index)  = 0; //For just abstract base class
};


//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
class  LenDict
{
        HGLOBAL hDict;
        char  *dict; int BUCKETSIZE; int WORDNUM;
    public:
        LenDict()    {}
        LenDict(char *tempdict, int bsize, int wordnum) {
            InitLenDict (tempdict, bsize, wordnum);
        }
        void InitLenDict(char *tempdict, int bsize, int wordnum) {
            dict = tempdict;
            BUCKETSIZE = bsize;
            WORDNUM = wordnum;
        }

    
    
        int FindWord(char  *stem, int &ulspos, int startindex = 0) ;
        void RestWord(char  *stem, int &ulspos, int restindex) ;
    private:
        inline int  __IsDefStem(int ulspos, int num) 
                { return ((ulspos-num) >= 0) ? 1 : 0; }
        inline void __DelStemN(char  *stem, int &ulspos, int num) 
                { stem[ulspos-num+1] = 0;       ulspos -= num; }

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\basedef.hpp ===
//////////////////////////////////////////////////
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
// File    : CHKDATA.HPP
// Project : Project SIK

//////////////////////////////////////////////////
#if !defined (__BASEDEF_HPP)
#define  __BASEDEF_HPP   1

#include <windows.h>
#include "stemkor.h"

//////////////////////////////////////////////////////////////







//////////////////////////////////////////////////////////////
#define     UDEF       -1       // undefined
#define     __K_G       1       
#define     __K_G_D     2       
#define     __K_N       3       
#define     __K_D       5       
#define     __K_D_D     6       
#define     __K_R       7       
#define     __K_M      10       
#define     __K_B      11       
#define     __K_B_D    12       
#define     __K_S      13       
#define     __K_S_D    14       
#define     __K_I      15       
#define     __K_J      16       
#define     __K_J_D    17       
#define     __K_C      18       
#define     __K_K      19       
#define     __K_T      20       
#define     __K_P      21       
#define     __K_H      22       

#define     __V_k      23       
#define     __V_o      24       
#define     __V_i      25       
#define     __V_O      26       
#define     __V_j      27       
#define     __V_p      28       
#define     __V_u      29       
#define     __V_P      30       
#define     __V_h      31       
#define     __V_hk     33       
#define     __V_ho     34       
#define     __V_hl     35       
#define     __V_y      36       
#define     __V_n      37       
#define     __V_nj     38       
#define     __V_np     39       
#define     __V_nl     40       
#define     __V_b      41       
#define     __V_m      42       
#define     __V_ml     43       
#define     __V_l      44       


#define     NULLCHAR   0x00

// by hjw : 95/3/16                                      
#define     lTRUE                           1
#define     lFALSE                          2
#define     FALSEMORE                       3
#define     SUCCESS                         4
#define     FAIL                            5
#define     VALID                           10
#define     INVALID                         300
#define     BT                              400
#define     MORECHECK                       500


// VALID Return Type Definition


// VALID Return Type Change        
#define     SS_AUX                          50      // AUX_?_VALID + SS_AUX = SS_AUX_?_VALID
#define     SS_T                            170     
#define     Irr_AUX                         80      // AUX_?_VALID + Irr_AUX = Irr_AUX_?_VALID
#define     Irr_SS                          90      // SS_?_VALID + Irr_SS = Irr_SS_?_VALID
#define     Jap_T                           210     
                                                                                   

#define     NOUN_VALID                      11
#define     Deol_VALID                      12
#define     Pref_VALID                      13
#define     Suf_VALID                       14
#define     PreSuf_VALID                    15
#define     PRON_VALID                      16
#define     NUM_VALID                       17


#define     ALN_VALID                       20



// KTC_Proc                                 
#define     KTC_VERB_VALID                  30
#define     KTC_ADJ_VALID                   31


#define     VERB_VALID                      40
#define     ADJ_VALID                       41
#define     Dap_VALID                       42
#define     Gop_VALID                       43
#define     Manha_VALID                     44
#define     Yenha_VALID                     45
#define     Manhaeci_VALID                  46
#define     Cikha_VALID                     47
                                            


#define     AUX_VERB_VALID                  50
#define     AUX_ADJ_VALID                   51
#define     AUX_Dap_VALID                   52
#define     AUX_Gop_VALID                   53
#define     AUX_Manha_VALID                 54
#define     AUX_Yenha_VALID                 55
#define     AUX_Manhaeci_VALID              56

#define     AUX_SS_VERB_VALID               60
#define     AUX_SS_ADJ_VALID                61
#define     AUX_SS_Dap_VALID                62
#define     AUX_SS_Gop_VALID                63
#define     AUX_SS_Manha_VALID              64
#define     AUX_SS_Yenha_VALID              65
#define     AUX_SS_Manhaeci_VALID           66

#define     AUX_Irr_VERB_VALID              70
#define     AUX_Irr_ADJ_VALID               71
#define     AUX_Irr_Dap_VALID               72


#define     SS_VERB_VALID                   80
#define     SS_ADJ_VALID                    81
#define     SS_Dap_VALID                    82
#define     SS_Gop_VALID                    83
#define     SS_Manha_VALID                  84
#define     SS_Yenha_VALID                  85
#define     SS_Manhaeci_VALID               86
#define     SS_Cikha_VALID                  87
#define     SS_NOUN_VALID                   91
#define     SS_Deol_VALID                   92
#define     SS_Pref_VALID                   93
#define     SS_Suf_VALID                    94
#define     SS_PreSuf_VALID                 95
#define     SS_PRON_VALID                   96
#define     SS_NUM_VALID                    97
#define     SS_AUX_VERB_VALID               100
#define     SS_AUX_ADJ_VALID                101
#define     SS_AUX_Dap_VALID                102
#define     SS_AUX_Gop_VALID                103
#define     SS_AUX_Manha_VALID              104
#define     SS_AUX_Yenha_VALID              105
#define     SS_AUX_Manhaeci_VALID           106
#define     SS_AUX_SS_VERB_VALID            110
#define     SS_AUX_SS_ADJ_VALID             111
#define     SS_AUX_SS_Dap_VALID             112
#define     SS_AUX_SS_Gop_VALID             113
#define     SS_AUX_SS_Manha_VALID           114
#define     SS_AUX_SS_Yenha_VALID           115
#define     SS_AUX_SS_Manhaeci_VALID        116
#define     SS_AUX_Irr_VERB_VALID           120
#define     SS_AUX_Irr_ADJ_VALID            121
#define     SS_AUX_Irr_Dap_VALID            122


#define     Irr_VERB_VALID                  130
#define     Irr_ADJ_VALID                   131
#define     Irr_Dap_VALID                   132
#define     Irr_AUX_VERB_VALID              140
#define     Irr_AUX_ADJ_VALID               141
#define     Irr_AUX_Dap_VALID               142
#define     Irr_AUX_Gop_VALID               143
#define     Irr_AUX_Manha_VALID             144
#define     Irr_AUX_Yenha_VALID             145
#define     Irr_AUX_Manhaeci_VALID          146
#define     Irr_AUX_SS_VERB_VALID           150
#define     Irr_AUX_SS_ADJ_VALID            151
#define     Irr_AUX_SS_Dap_VALID            152
#define     Irr_AUX_SS_Gop_VALID            153
#define     Irr_AUX_SS_Manha_VALID          154
#define     Irr_AUX_SS_Yenha_VALID          155
#define     Irr_AUX_SS_Manhaeci_VALID       156
#define     Irr_AUX_Irr_VERB_VALID          160
#define     Irr_AUX_Irr_ADJ_VALID           161
#define     Irr_AUX_Irr_Dap_VALID           162
#define     Irr_SS_VERB_VALID               170
#define     Irr_SS_ADJ_VALID                171
#define     Irr_SS_Dap_VALID                172
#define     Irr_SS_Gop_VALID                173
#define     Irr_SS_Manha_VALID              174
#define     Irr_SS_Yenha_VALID              175
#define     Irr_SS_Manhaeci_VALID           176
#define     Irr_SS_Cikha_VALID              177
#define     Irr_SS_NOUN_VALID               181
#define     Irr_SS_Deol_VALID               182
#define     Irr_SS_Pref_VALID               183
#define     Irr_SS_Suf_VALID                184
#define     Irr_SS_PreSuf_VALID             185
#define     Irr_SS_PRON_VALID               186
#define     Irr_SS_NUM_VALID                187
#define     Irr_SS_AUX_VERB_VALID           190
#define     Irr_SS_AUX_ADJ_VALID            191
#define     Irr_SS_AUX_Dap_VALID            192
#define     Irr_SS_AUX_Gop__VALID           193
#define     Irr_SS_AUX_Manha_VALID          194
#define     Irr_SS_AUX_Yenha_VALID          195
#define     Irr_SS_AUX_Manhaeci_VALID       196
#define     Irr_SS_AUX_SS_VERB_VALID        200
#define     Irr_SS_AUX_SS_ADJ_VALID         201
#define     Irr_SS_AUX_SS_Dap_VALID         202
#define     Irr_SS_AUX_SS_Gop_VALID         203
#define     Irr_SS_AUX_SS_Manha_VALID       204
#define     Irr_SS_AUX_SS_Yenha_VALID       205
#define     Irr_SS_AUX_SS_Manhaeci_VALID    206
#define     Irr_SS_AUX_Irr_VERB_VALID       210
#define     Irr_SS_AUX_Irr_ADJ_VALID        211
#define     Irr_SS_AUX_Irr_Dap_VALID        212


#define     Jap_VALID                       220
#define     Jap_NOUN_VALID                  221
#define     Jap_PRON_VALID                  222
#define     Jap_Deol_VALID                  223
#define     Jap_Pref_VALID                  224
#define     Jap_Suf_VALID                   225
#define     Jap_PreSuf_VALID                226
#define     Jap_NUM_VALID                   227


#define     NCV_VALID                       190
#define     VCV_VALID                       191
#define     Bloc_VALID                      192

// Function Call Definition
#define     Dap_Proc                        201
#define     Gop_Proc                        202
#define     Manha_Proc                      203
#define     Manhaeci_Proc                   204
#define     Machine_T                       205
#define     Block_Comm                      206
#define     Irr_KN_Vl                       207
#define     Irr_OPS                         208
#define     SS                              209

#define     WORDLEN     32
#define     uWORDLEN    64

// by dhyu --- 1996. 3
// These defines are return values in compose routine.
#define        COMPOSED        1
#define        NOT_COMPOSED    2
#define        COMPOSE_ERROR   3

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\basedict.cpp ===
//////////////////////////////////////////////////
//  Copyright (C) 1997 - 1998, Microsoft Corporation.  All Rights Reserved.
//
// File    : DICTTYPE.CPP
// Project : project SIK

//////////////////////////////////////////////////
#include <io.h>
#include <stdlib.h>
#include <string.h>
#include "basecore.hpp"
#include "stemkor.h"



////////////////////////////////////////////////////////////////////////
int LenDict::FindWord(char *stem,
                      int &ulspos,
                      int startindex)
{
    for(int i = startindex; i < WORDNUM; i++) // Check the length of stem
    {    
        if(__IsDefStem(ulspos, dict[(i+1)*BUCKETSIZE-1]) == 1)
        {
            if(strcmp(stem+(ulspos-dict[(i+1)*BUCKETSIZE-1]),
                