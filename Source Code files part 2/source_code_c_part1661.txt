   IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_Subject_Proxy( 
    IFaxDocument * This,
    /* [in] */ BSTR bstrSubject);


void __RPC_STUB IFaxDocument_put_Subject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_Note_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ BSTR *pbstrNote);


void __RPC_STUB IFaxDocument_get_Note_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_Note_Proxy( 
    IFaxDocument * This,
    /* [in] */ BSTR bstrNote);


void __RPC_STUB IFaxDocument_put_Note_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_ScheduleTime_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ DATE *pdateScheduleTime);


void __RPC_STUB IFaxDocument_get_ScheduleTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_ScheduleTime_Proxy( 
    IFaxDocument * This,
    /* [in] */ DATE dateScheduleTime);


void __RPC_STUB IFaxDocument_put_ScheduleTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_ReceiptAddress_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ BSTR *pbstrReceiptAddress);


void __RPC_STUB IFaxDocument_get_ReceiptAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_ReceiptAddress_Proxy( 
    IFaxDocument * This,
    /* [in] */ BSTR bstrReceiptAddress);


void __RPC_STUB IFaxDocument_put_ReceiptAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_DocumentName_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ BSTR *pbstrDocumentName);


void __RPC_STUB IFaxDocument_get_DocumentName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_DocumentName_Proxy( 
    IFaxDocument * This,
    /* [in] */ BSTR bstrDocumentName);


void __RPC_STUB IFaxDocument_put_DocumentName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_CallHandle_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ long *plCallHandle);


void __RPC_STUB IFaxDocument_get_CallHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_CallHandle_Proxy( 
    IFaxDocument * This,
    /* [in] */ long lCallHandle);


void __RPC_STUB IFaxDocument_put_CallHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_CoverPageType_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ FAX_COVERPAGE_TYPE_ENUM *pCoverPageType);


void __RPC_STUB IFaxDocument_get_CoverPageType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_CoverPageType_Proxy( 
    IFaxDocument * This,
    /* [in] */ FAX_COVERPAGE_TYPE_ENUM CoverPageType);


void __RPC_STUB IFaxDocument_put_CoverPageType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_ScheduleType_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ FAX_SCHEDULE_TYPE_ENUM *pScheduleType);


void __RPC_STUB IFaxDocument_get_ScheduleType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_ScheduleType_Proxy( 
    IFaxDocument * This,
    /* [in] */ FAX_SCHEDULE_TYPE_ENUM ScheduleType);


void __RPC_STUB IFaxDocument_put_ScheduleType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_ReceiptType_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ FAX_RECEIPT_TYPE_ENUM *pReceiptType);


void __RPC_STUB IFaxDocument_get_ReceiptType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_ReceiptType_Proxy( 
    IFaxDocument * This,
    /* [in] */ FAX_RECEIPT_TYPE_ENUM ReceiptType);


void __RPC_STUB IFaxDocument_put_ReceiptType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_GroupBroadcastReceipts_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ VARIANT_BOOL *pbUseGrouping);


void __RPC_STUB IFaxDocument_get_GroupBroadcastReceipts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_GroupBroadcastReceipts_Proxy( 
    IFaxDocument * This,
    /* [in] */ VARIANT_BOOL bUseGrouping);


void __RPC_STUB IFaxDocument_put_GroupBroadcastReceipts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_Priority_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ FAX_PRIORITY_TYPE_ENUM *pPriority);


void __RPC_STUB IFaxDocument_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_Priority_Proxy( 
    IFaxDocument * This,
    /* [in] */ FAX_PRIORITY_TYPE_ENUM Priority);


void __RPC_STUB IFaxDocument_put_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_TapiConnection_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ IDispatch **ppTapiConnection);


void __RPC_STUB IFaxDocument_get_TapiConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IFaxDocument_putref_TapiConnection_Proxy( 
    IFaxDocument * This,
    /* [in] */ IDispatch *pTapiConnection);


void __RPC_STUB IFaxDocument_putref_TapiConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDocument_Submit_Proxy( 
    IFaxDocument * This,
    /* [in] */ BSTR bstrFaxServerName,
    /* [retval][out] */ VARIANT *pvFaxOutgoingJobIDs);


void __RPC_STUB IFaxDocument_Submit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDocument_ConnectedSubmit_Proxy( 
    IFaxDocument * This,
    /* [in] */ IFaxServer *pFaxServer,
    /* [retval][out] */ VARIANT *pvFaxOutgoingJobIDs);


void __RPC_STUB IFaxDocument_ConnectedSubmit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_AttachFaxToReceipt_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ VARIANT_BOOL *pbAttachFax);


void __RPC_STUB IFaxDocument_get_AttachFaxToReceipt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_AttachFaxToReceipt_Proxy( 
    IFaxDocument * This,
    /* [in] */ VARIANT_BOOL bAttachFax);


void __RPC_STUB IFaxDocument_put_AttachFaxToReceipt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxDocument_INTERFACE_DEFINED__ */


#ifndef __IFaxSender_INTERFACE_DEFINED__
#define __IFaxSender_INTERFACE_DEFINED__

/* interface IFaxSender */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxSender;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0D879D7D-F57A-4CC6-A6F9-3EE5D527B46A")
    IFaxSender : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BillingCode( 
            /* [retval][out] */ BSTR *pbstrBillingCode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BillingCode( 
            /* [in] */ BSTR bstrBillingCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_City( 
            /* [retval][out] */ BSTR *pbstrCity) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_City( 
            /* [in] */ BSTR bstrCity) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Company( 
            /* [retval][out] */ BSTR *pbstrCompany) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Company( 
            /* [in] */ BSTR bstrCompany) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Country( 
            /* [retval][out] */ BSTR *pbstrCountry) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Country( 
            /* [in] */ BSTR bstrCountry) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Department( 
            /* [retval][out] */ BSTR *pbstrDepartment) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Department( 
            /* [in] */ BSTR bstrDepartment) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Email( 
            /* [retval][out] */ BSTR *pbstrEmail) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Email( 
            /* [in] */ BSTR bstrEmail) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FaxNumber( 
            /* [retval][out] */ BSTR *pbstrFaxNumber) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FaxNumber( 
            /* [in] */ BSTR bstrFaxNumber) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HomePhone( 
            /* [retval][out] */ BSTR *pbstrHomePhone) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_HomePhone( 
            /* [in] */ BSTR bstrHomePhone) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pbstrName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TSID( 
            /* [retval][out] */ BSTR *pbstrTSID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TSID( 
            /* [in] */ BSTR bstrTSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OfficePhone( 
            /* [retval][out] */ BSTR *pbstrOfficePhone) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OfficePhone( 
            /* [in] */ BSTR bstrOfficePhone) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OfficeLocation( 
            /* [retval][out] */ BSTR *pbstrOfficeLocation) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OfficeLocation( 
            /* [in] */ BSTR bstrOfficeLocation) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ BSTR *pbstrState) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_State( 
            /* [in] */ BSTR bstrState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreetAddress( 
            /* [retval][out] */ BSTR *pbstrStreetAddress) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StreetAddress( 
            /* [in] */ BSTR bstrStreetAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Title( 
            /* [retval][out] */ BSTR *pbstrTitle) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Title( 
            /* [in] */ BSTR bstrTitle) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ZipCode( 
            /* [retval][out] */ BSTR *pbstrZipCode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ZipCode( 
            /* [in] */ BSTR bstrZipCode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LoadDefaultSender( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveDefaultSender( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxSenderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxSender * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxSender * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxSender * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxSender * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxSender * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxSender * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxSender * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BillingCode )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrBillingCode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BillingCode )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrBillingCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_City )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrCity);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_City )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrCity);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Company )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrCompany);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Company )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrCompany);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Country )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrCountry);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Country )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrCountry);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Department )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrDepartment);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Department )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrDepartment);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Email )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrEmail);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Email )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrEmail);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FaxNumber )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrFaxNumber);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FaxNumber )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrFaxNumber);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HomePhone )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrHomePhone);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HomePhone )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrHomePhone);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TSID )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrTSID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TSID )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrTSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OfficePhone )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrOfficePhone);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OfficePhone )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrOfficePhone);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OfficeLocation )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrOfficeLocation);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OfficeLocation )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrOfficeLocation);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrState);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_State )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreetAddress )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrStreetAddress);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StreetAddress )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrStreetAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrTitle);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Title )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrTitle);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ZipCode )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrZipCode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ZipCode )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrZipCode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LoadDefaultSender )( 
            IFaxSender * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SaveDefaultSender )( 
            IFaxSender * This);
        
        END_INTERFACE
    } IFaxSenderVtbl;

    interface IFaxSender
    {
        CONST_VTBL struct IFaxSenderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxSender_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxSender_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxSender_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxSender_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxSender_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxSender_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxSender_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxSender_get_BillingCode(This,pbstrBillingCode)	\
    (This)->lpVtbl -> get_BillingCode(This,pbstrBillingCode)

#define IFaxSender_put_BillingCode(This,bstrBillingCode)	\
    (This)->lpVtbl -> put_BillingCode(This,bstrBillingCode)

#define IFaxSender_get_City(This,pbstrCity)	\
    (This)->lpVtbl -> get_City(This,pbstrCity)

#define IFaxSender_put_City(This,bstrCity)	\
    (This)->lpVtbl -> put_City(This,bstrCity)

#define IFaxSender_get_Company(This,pbstrCompany)	\
    (This)->lpVtbl -> get_Company(This,pbstrCompany)

#define IFaxSender_put_Company(This,bstrCompany)	\
    (This)->lpVtbl -> put_Company(This,bstrCompany)

#define IFaxSender_get_Country(This,pbstrCountry)	\
    (This)->lpVtbl -> get_Country(This,pbstrCountry)

#define IFaxSender_put_Country(This,bstrCountry)	\
    (This)->lpVtbl -> put_Country(This,bstrCountry)

#define IFaxSender_get_Department(This,pbstrDepartment)	\
    (This)->lpVtbl -> get_Department(This,pbstrDepartment)

#define IFaxSender_put_Department(This,bstrDepartment)	\
    (This)->lpVtbl -> put_Department(This,bstrDepartment)

#define IFaxSender_get_Email(This,pbstrEmail)	\
    (This)->lpVtbl -> get_Email(This,pbstrEmail)

#define IFaxSender_put_Email(This,bstrEmail)	\
    (This)->lpVtbl -> put_Email(This,bstrEmail)

#define IFaxSender_get_FaxNumber(This,pbstrFaxNumber)	\
    (This)->lpVtbl -> get_FaxNumber(This,pbstrFaxNumber)

#define IFaxSender_put_FaxNumber(This,bstrFaxNumber)	\
    (This)->lpVtbl -> put_FaxNumber(This,bstrFaxNumber)

#define IFaxSender_get_HomePhone(This,pbstrHomePhone)	\
    (This)->lpVtbl -> get_HomePhone(This,pbstrHomePhone)

#define IFaxSender_put_HomePhone(This,bstrHomePhone)	\
    (This)->lpVtbl -> put_HomePhone(This,bstrHomePhone)

#define IFaxSender_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)

#define IFaxSender_put_Name(This,bstrName)	\
    (This)->lpVtbl -> put_Name(This,bstrName)

#define IFaxSender_get_TSID(This,pbstrTSID)	\
    (This)->lpVtbl -> get_TSID(This,pbstrTSID)

#define IFaxSender_put_TSID(This,bstrTSID)	\
    (This)->lpVtbl -> put_TSID(This,bstrTSID)

#define IFaxSender_get_OfficePhone(This,pbstrOfficePhone)	\
    (This)->lpVtbl -> get_OfficePhone(This,pbstrOfficePhone)

#define IFaxSender_put_OfficePhone(This,bstrOfficePhone)	\
    (This)->lpVtbl -> put_OfficePhone(This,bstrOfficePhone)

#define IFaxSender_get_OfficeLocation(This,pbstrOfficeLocation)	\
    (This)->lpVtbl -> get_OfficeLocation(This,pbstrOfficeLocation)

#define IFaxSender_put_OfficeLocation(This,bstrOfficeLocation)	\
    (This)->lpVtbl -> put_OfficeLocation(This,bstrOfficeLocation)

#define IFaxSender_get_State(This,pbstrState)	\
    (This)->lpVtbl -> get_State(This,pbstrState)

#define IFaxSender_put_State(This,bstrState)	\
    (This)->lpVtbl -> put_State(This,bstrState)

#define IFaxSender_get_StreetAddress(This,pbstrStreetAddress)	\
    (This)->lpVtbl -> get_StreetAddress(This,pbstrStreetAddress)

#define IFaxSender_put_StreetAddress(This,bstrStreetAddress)	\
    (This)->lpVtbl -> put_StreetAddress(This,bstrStreetAddress)

#define IFaxSender_get_Title(This,pbstrTitle)	\
    (This)->lpVtbl -> get_Title(This,pbstrTitle)

#define IFaxSender_put_Title(This,bstrTitle)	\
    (This)->lpVtbl -> put_Title(This,bstrTitle)

#define IFaxSender_get_ZipCode(This,pbstrZipCode)	\
    (This)->lpVtbl -> get_ZipCode(This,pbstrZipCode)

#define IFaxSender_put_ZipCode(This,bstrZipCode)	\
    (This)->lpVtbl -> put_ZipCode(This,bstrZipCode)

#define IFaxSender_LoadDefaultSender(This)	\
    (This)->lpVtbl -> LoadDefaultSender(This)

#define IFaxSender_SaveDefaultSender(This)	\
    (This)->lpVtbl -> SaveDefaultSender(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_BillingCode_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrBillingCode);


void __RPC_STUB IFaxSender_get_BillingCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_BillingCode_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrBillingCode);


void __RPC_STUB IFaxSender_put_BillingCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_City_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrCity);


void __RPC_STUB IFaxSender_get_City_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_City_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrCity);


void __RPC_STUB IFaxSender_put_City_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_Company_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrCompany);


void __RPC_STUB IFaxSender_get_Company_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_Company_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrCompany);


void __RPC_STUB IFaxSender_put_Company_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_Country_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrCountry);


void __RPC_STUB IFaxSender_get_Country_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_Country_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrCountry);


void __RPC_STUB IFaxSender_put_Country_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_Department_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrDepartment);


void __RPC_STUB IFaxSender_get_Department_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_Department_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrDepartment);


void __RPC_STUB IFaxSender_put_Department_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_Email_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrEmail);


void __RPC_STUB IFaxSender_get_Email_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_Email_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrEmail);


void __RPC_STUB IFaxSender_put_Email_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_FaxNumber_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrFaxNumber);


void __RPC_STUB IFaxSender_get_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_FaxNumber_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrFaxNumber);


void __RPC_STUB IFaxSender_put_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_HomePhone_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrHomePhone);


void __RPC_STUB IFaxSender_get_HomePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_HomePhone_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrHomePhone);


void __RPC_STUB IFaxSender_put_HomePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_Name_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrName);


void __RPC_STUB IFaxSender_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_Name_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB IFaxSender_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_TSID_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrTSID);


void __RPC_STUB IFaxSender_get_TSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_TSID_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrTSID);


void __RPC_STUB IFaxSender_put_TSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_OfficePhone_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrOfficePhone);


void __RPC_STUB IFaxSender_get_OfficePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_OfficePhone_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrOfficePhone);


void __RPC_STUB IFaxSender_put_OfficePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_OfficeLocation_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrOfficeLocation);


void __RPC_STUB IFaxSender_get_OfficeLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_OfficeLocation_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrOfficeLocation);


void __RPC_STUB IFaxSender_put_OfficeLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_State_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrState);


void __RPC_STUB IFaxSender_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_State_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrState);


void __RPC_STUB IFaxSender_put_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_StreetAddress_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrStreetAddress);


void __RPC_STUB IFaxSender_get_StreetAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_StreetAddress_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrStreetAddress);


void __RPC_STUB IFaxSender_put_StreetAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_Title_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrTitle);


void __RPC_STUB IFaxSender_get_Title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_Title_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrTitle);


void __RPC_STUB IFaxSender_put_Title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_ZipCode_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrZipCode);


void __RPC_STUB IFaxSender_get_ZipCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_ZipCode_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrZipCode);


void __RPC_STUB IFaxSender_put_ZipCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxSender_LoadDefaultSender_Proxy( 
    IFaxSender * This);


void __RPC_STUB IFaxSender_LoadDefaultSender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxSender_SaveDefaultSender_Proxy( 
    IFaxSender * This);


void __RPC_STUB IFaxSender_SaveDefaultSender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxSender_INTERFACE_DEFINED__ */


#ifndef __IFaxRecipient_INTERFACE_DEFINED__
#define __IFaxRecipient_INTERFACE_DEFINED__

/* interface IFaxRecipient */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxRecipient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9A3DA3A0-538D-42b6-9444-AAA57D0CE2BC")
    IFaxRecipient : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FaxNumber( 
            /* [retval][out] */ BSTR *pbstrFaxNumber) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FaxNumber( 
            /* [in] */ BSTR bstrFaxNumber) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pbstrName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR bstrName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxRecipientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxRecipient * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxRecipient * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxRecipient * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxRecipient * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxRecipient * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxRecipient * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxRecipient * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FaxNumber )( 
            IFaxRecipient * This,
            /* [retval][out] */ BSTR *pbstrFaxNumber);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FaxNumber )( 
            IFaxRecipient * This,
            /* [in] */ BSTR bstrFaxNumber);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IFaxRecipient * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            IFaxRecipient * This,
            /* [in] */ BSTR bstrName);
        
        END_INTERFACE
    } IFaxRecipientVtbl;

    interface IFaxRecipient
    {
        CONST_VTBL struct IFaxRecipientVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxRecipient_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxRecipient_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxRecipient_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxRecipient_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxRecipient_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxRecipient_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxRecipient_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxRecipient_get_FaxNumber(This,pbstrFaxNumber)	\
    (This)->lpVtbl -> get_FaxNumber(This,pbstrFaxNumber)

#define IFaxRecipient_put_FaxNumber(This,bstrFaxNumber)	\
    (This)->lpVtbl -> put_FaxNumber(This,bstrFaxNumber)

#define IFaxRecipient_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)

#define IFaxRecipient_put_Name(This,bstrName)	\
    (This)->lpVtbl -> put_Name(This,bstrName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRecipient_get_FaxNumber_Proxy( 
    IFaxRecipient * This,
    /* [retval][out] */ BSTR *pbstrFaxNumber);


void __RPC_STUB IFaxRecipient_get_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxRecipient_put_FaxNumber_Proxy( 
    IFaxRecipient * This,
    /* [in] */ BSTR bstrFaxNumber);


void __RPC_STUB IFaxRecipient_put_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRecipient_get_Name_Proxy( 
    IFaxRecipient * This,
    /* [retval][out] */ BSTR *pbstrName);


void __RPC_STUB IFaxRecipient_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxRecipient_put_Name_Proxy( 
    IFaxRecipient * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB IFaxRecipient_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxRecipient_INTERFACE_DEFINED__ */


#ifndef __IFaxRecipients_INTERFACE_DEFINED__
#define __IFaxRecipients_INTERFACE_DEFINED__

/* interface IFaxRecipients */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxRecipients;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B9C9DE5A-894E-4492-9FA3-08C627C11D5D")
    IFaxRecipients : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ IFaxRecipient **ppFaxRecipient) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrFaxNumber,
            /* [defaultvalue][in] */ BSTR bstrRecipientName,
            /* [retval][out] */ IFaxRecipient **ppFaxRecipient) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxRecipientsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxRecipients * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxRecipients * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxRecipients * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxRecipients * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxRecipients * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxRecipients * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxRecipients * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxRecipients * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxRecipients * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ IFaxRecipient **ppFaxRecipient);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxRecipients * This,
            /* [retval][out] */ long *plCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IFaxRecipients * This,
            /* [in] */ BSTR bstrFaxNumber,
            /* [defaultvalue][in] */ BSTR bstrRecipientName,
            /* [retval][out] */ IFaxRecipient **ppFaxRecipient);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IFaxRecipients * This,
            /* [in] */ long lIndex);
        
        END_INTERFACE
    } IFaxRecipientsVtbl;

    interface IFaxRecipients
    {
        CONST_VTBL struct IFaxRecipientsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxRecipients_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxRecipients_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxRecipients_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxRecipients_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxRecipients_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxRecipients_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxRecipients_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxRecipients_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxRecipients_get_Item(This,lIndex,ppFaxRecipient)	\
    (This)->lpVtbl -> get_Item(This,lIndex,ppFaxRecipient)

#define IFaxRecipients_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IFaxRecipients_Add(This,bstrFaxNumber,bstrRecipientName,ppFaxRecipient)	\
    (This)->lpVtbl -> Add(This,bstrFaxNumber,bstrRecipientName,ppFaxRecipient)

#define IFaxRecipients_Remove(This,lIndex)	\
    (This)->lpVtbl -> Remove(This,lIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxRecipients_get__NewEnum_Proxy( 
    IFaxRecipients * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxRecipients_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxRecipients_get_Item_Proxy( 
    IFaxRecipients * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ IFaxRecipient **ppFaxRecipient);


void __RPC_STUB IFaxRecipients_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxRecipients_get_Count_Proxy( 
    IFaxRecipients * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxRecipients_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxRecipients_Add_Proxy( 
    IFaxRecipients * This,
    /* [in] */ BSTR bstrFaxNumber,
    /* [defaultvalue][in] */ BSTR bstrRecipientName,
    /* [retval][out] */ IFaxRecipient **ppFaxRecipient);


void __RPC_STUB IFaxRecipients_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxRecipients_Remove_Proxy( 
    IFaxRecipients * This,
    /* [in] */ long lIndex);


void __RPC_STUB IFaxRecipients_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxRecipients_INTERFACE_DEFINED__ */


#ifndef __IFaxIncomingArchive_INTERFACE_DEFINED__
#define __IFaxIncomingArchive_INTERFACE_DEFINED__

/* interface IFaxIncomingArchive */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxIncomingArchive;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("76062CC7-F714-4FBD-AA06-ED6E4A4B70F3")
    IFaxIncomingArchive : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseArchive( 
            /* [retval][out] */ VARIANT_BOOL *pbUseArchive) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UseArchive( 
            /* [in] */ VARIANT_BOOL bUseArchive) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ArchiveFolder( 
            /* [retval][out] */ BSTR *pbstrArchiveFolder) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ArchiveFolder( 
            /* [in] */ BSTR bstrArchiveFolder) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SizeQuotaWarning( 
            /* [retval][out] */ VARIANT_BOOL *pbSizeQuotaWarning) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SizeQuotaWarning( 
            /* [in] */ VARIANT_BOOL bSizeQuotaWarning) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HighQuotaWaterMark( 
            /* [retval][out] */ long *plHighQuotaWaterMark) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_HighQuotaWaterMark( 
            /* [in] */ long lHighQuotaWaterMark) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LowQuotaWaterMark( 
            /* [retval][out] */ long *plLowQuotaWaterMark) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LowQuotaWaterMark( 
            /* [in] */ long lLowQuotaWaterMark) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AgeLimit( 
            /* [retval][out] */ long *plAgeLimit) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AgeLimit( 
            /* [in] */ long lAgeLimit) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SizeLow( 
            /* [retval][out] */ long *plSizeLow) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SizeHigh( 
            /* [retval][out] */ long *plSizeHigh) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMessages( 
            /* [defaultvalue][in] */ long lPrefetchSize,
            /* [retval][out] */ IFaxIncomingMessageIterator **pFaxIncomingMessageIterator) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMessage( 
            /* [in] */ BSTR bstrMessageId,
            /* [retval][out] */ IFaxIncomingMessage **pFaxIncomingMessage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxIncomingArchiveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxIncomingArchive * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxIncomingArchive * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxIncomingArchive * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxIncomingArchive * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxIncomingArchive * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxIncomingArchive * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxIncomingArchive * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseArchive )( 
            IFaxIncomingArchive * This,
            /* [retval][out] */ VARIANT_BOOL *pbUseArchive);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseArchive )( 
            IFaxIncomingArchive * This,
            /* [in] */ VARIANT_BOOL bUseArchive);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ArchiveFolder )( 
            IFaxIncomingArchive * This,
            /* [retval][out] */ BSTR *pbstrArchiveFolder);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ArchiveFolder )( 
            IFaxIncomingArchive * This,
            /* [in] */ BSTR bstrArchiveFolder);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SizeQuotaWarning )( 
            IFaxIncomingArchive * This,
            /* [retval][out] */ VARIANT_BOOL *pbSizeQuotaWarning);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SizeQuotaWarning )( 
            IFaxIncomingArchive * This,
            /* [in] */ VARIANT_BOOL bSizeQuotaWarning);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HighQuotaWaterMark )( 
            IFaxIncomingArchive * This,
            /* [retval][out] */ long *plHighQuotaWaterMark);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HighQuotaWaterMark )( 
            IFaxIncomingArchive * This,
            /* [in] */ long lHighQuotaWaterMark);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LowQuotaWaterMark )( 
            IFaxIncomingArchive * This,
            /* [retval][out] */ long *plLowQuotaWaterMark);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LowQuotaWaterMark )( 
            IFaxIncomingArchive * This,
            /* [in] */ long lLowQuotaWaterMark);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AgeLimit )( 
            IFaxIncomingArchive * This,
            /* [retval][out] */ long *plAgeLimit);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AgeLimit )( 
            IFaxIncomingArchive * This,
            /* [in] */ long lAgeLimit);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SizeLow )( 
            IFaxIncomingArchive * This,
            /* [retval][out] */ long *plSizeLow);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SizeHigh )( 
            IFaxIncomingArchive * This,
            /* [retval][out] */ long *plSizeHigh);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxIncomingArchive * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxIncomingArchive * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMessages )( 
            IFaxIncomingArchive * This,
            /* [defaultvalue][in] */ long lPrefetchSize,
            /* [retval][out] */ IFaxIncomingMessageIterator **pFaxIncomingMessageIterator);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMessage )( 
            IFaxIncomingArchive * This,
            /* [in] */ BSTR bstrMessageId,
            /* [retval][out] */ IFaxIncomingMessage **pFaxIncomingMessage);
        
        END_INTERFACE
    } IFaxIncomingArchiveVtbl;

    interface IFaxIncomingArchive
    {
        CONST_VTBL struct IFaxIncomingArchiveVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxIncomingArchive_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxIncomingArchive_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxIncomingArchive_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxIncomingArchive_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxIncomingArchive_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxIncomingArchive_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxIncomingArchive_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxIncomingArchive_get_UseArchive(This,pbUseArchive)	\
    (This)->lpVtbl -> get_UseArchive(This,pbUseArchive)

#define IFaxIncomingArchive_put_UseArchive(This,bUseArchive)	\
    (This)->lpVtbl -> put_UseArchive(This,bUseArchive)

#define IFaxIncomingArchive_get_ArchiveFolder(This,pbstrArchiveFolder)	\
    (This)->lpVtbl -> get_ArchiveFolder(This,pbstrArchiveFolder)

#define IFaxIncomingArchive_put_ArchiveFolder(This,bstrArchiveFolder)	\
    (This)->lpVtbl -> put_ArchiveFolder(This,bstrArchiveFolder)

#define IFaxIncomingArchive_get_SizeQuotaWarning(This,pbSizeQuotaWarning)	\
    (This)->lpVtbl -> get_SizeQuotaWarning(This,pbSizeQuotaWarning)

#define IFaxIncomingArchive_put_SizeQuotaWarning(This,bSizeQuotaWarning)	\
    (This)->lpVtbl -> put_SizeQuotaWarning(This,bSizeQuotaWarning)

#define IFaxIncomingArchive_get_HighQuotaWaterMark(This,plHighQuotaWaterMark)	\
    (This)->lpVtbl -> get_HighQuotaWaterMark(This,plHighQuotaWaterMark)

#define IFaxIncomingArchive_put_HighQuotaWaterMark(This,lHighQuotaWaterMark)	\
    (This)->lpVtbl -> put_HighQuotaWaterMark(This,lHighQuotaWaterMark)

#define IFaxIncomingArchive_get_LowQuotaWaterMark(This,plLowQuotaWaterMark)	\
    (This)->lpVtbl -> get_LowQuotaWaterMark(This,plLowQuotaWaterMark)

#define IFaxIncomingArchive_put_LowQuotaWaterMark(This,lLowQuotaWaterMark)	\
    (This)->lpVtbl -> put_LowQuotaWaterMark(This,lLowQuotaWaterMark)

#define IFaxIncomingArchive_get_AgeLimit(This,plAgeLimit)	\
    (This)->lpVtbl -> get_AgeLimit(This,plAgeLimit)

#define IFaxIncomingArchive_put_AgeLimit(This,lAgeLimit)	\
    (This)->lpVtbl -> put_AgeLimit(This,lAgeLimit)

#define IFaxIncomingArchive_get_SizeLow(This,plSizeLow)	\
    (This)->lpVtbl -> get_SizeLow(This,plSizeLow)

#define IFaxIncomingArchive_get_SizeHigh(This,plSizeHigh)	\
    (This)->lpVtbl -> get_SizeHigh(This,plSizeHigh)

#define IFaxIncomingArchive_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxIncomingArchive_Save(This)	\
    (This)->lpVtbl -> Save(This)

#define IFaxIncomingArchive_GetMessages(This,lPrefetchSize,pFaxIncomingMessageIterator)	\
    (This)->lpVtbl -> GetMessages(This,lPrefetchSize,pFaxIncomingMessageIterator)

#define IFaxIncomingArchive_GetMessage(This,bstrMessageId,pFaxIncomingMessage)	\
    (This)->lpVtbl -> GetMessage(This,bstrMessageId,pFaxIncomingMessage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_get_UseArchive_Proxy( 
    IFaxIncomingArchive * This,
    /* [retval][out] */ VARIANT_BOOL *pbUseArchive);


void __RPC_STUB IFaxIncomingArchive_get_UseArchive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_put_UseArchive_Proxy( 
    IFaxIncomingArchive * This,
    /* [in] */ VARIANT_BOOL bUseArchive);


void __RPC_STUB IFaxIncomingArchive_put_UseArchive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_get_ArchiveFolder_Proxy( 
    IFaxIncomingArchive * This,
    /* [retval][out] */ BSTR *pbstrArchiveFolder);


void __RPC_STUB IFaxIncomingArchive_get_ArchiveFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_put_ArchiveFolder_Proxy( 
    IFaxIncomingArchive * This,
    /* [in] */ BSTR bstrArchiveFolder);


void __RPC_STUB IFaxIncomingArchive_put_ArchiveFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_get_SizeQuotaWarning_Proxy( 
    IFaxIncomingArchive * This,
    /* [retval][out] */ VARIANT_BOOL *pbSizeQuotaWarning);


void __RPC_STUB IFaxIncomingArchive_get_SizeQuotaWarning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_put_SizeQuotaWarning_Proxy( 
    IFaxIncomingArchive * This,
    /* [in] */ VARIANT_BOOL bSizeQuotaWarning);


void __RPC_STUB IFaxIncomingArchive_put_SizeQuotaWarning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_get_HighQuotaWaterMark_Proxy( 
    IFaxIncomingArchive * This,
    /* [retval][out] */ long *plHighQuotaWaterMark);


void __RPC_STUB IFaxIncomingArchive_get_HighQuotaWaterMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_put_HighQuotaWaterMark_Proxy( 
    IFaxIncomingArchive * This,
    /* [in] */ long lHighQuotaWaterMark);


void __RPC_STUB IFaxIncomingArchive_put_HighQuotaWaterMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_get_LowQuotaWaterMark_Proxy( 
    IFaxIncomingArchive * This,
    /* [retval][out] */ long *plLowQuotaWaterMark);


void __RPC_STUB IFaxIncomingArchive_get_LowQuotaWaterMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_put_LowQuotaWaterMark_Proxy( 
    IFaxIncomingArchive * This,
    /* [in] */ long lLowQuotaWaterMark);


void __RPC_STUB IFaxIncomingArchive_put_LowQuotaWaterMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_get_AgeLimit_Proxy( 
    IFaxIncomingArchive * This,
    /* [retval][out] */ long *plAgeLimit);


void __RPC_STUB IFaxIncomingArchive_get_AgeLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_put_AgeLimit_Proxy( 
    IFaxIncomingArchive * This,
    /* [in] */ long lAgeLimit);


void __RPC_STUB IFaxIncomingArchive_put_AgeLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_get_SizeLow_Proxy( 
    IFaxIncomingArchive * This,
    /* [retval][out] */ long *plSizeLow);


void __RPC_STUB IFaxIncomingArchive_get_SizeLow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_get_SizeHigh_Proxy( 
    IFaxIncomingArchive * This,
    /* [retval][out] */ long *plSizeHigh);


void __RPC_STUB IFaxIncomingArchive_get_SizeHigh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_Refresh_Proxy( 
    IFaxIncomingArchive * This);


void __RPC_STUB IFaxIncomingArchive_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_Save_Proxy( 
    IFaxIncomingArchive * This);


void __RPC_STUB IFaxIncomingArchive_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_GetMessages_Proxy( 
    IFaxIncomingArchive * This,
    /* [defaultvalue][in] */ long lPrefetchSize,
    /* [retval][out] */ IFaxIncomingMessageIterator **pFaxIncomingMessageIterator);


void __RPC_STUB IFaxIncomingArchive_GetMessages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_GetMessage_Proxy( 
    IFaxIncomingArchive * This,
    /* [in] */ BSTR bstrMessageId,
    /* [retval][out] */ IFaxIncomingMessage **pFaxIncomingMessage);


void __RPC_STUB IFaxIncomingArchive_GetMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxIncomingArchive_INTERFACE_DEFINED__ */


#ifndef __IFaxIncomingQueue_INTERFACE_DEFINED__
#define __IFaxIncomingQueue_INTERFACE_DEFINED__

/* interface IFaxIncomingQueue */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxIncomingQueue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("902E64EF-8FD8-4B75-9725-6014DF161545")
    IFaxIncomingQueue : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Blocked( 
            /* [retval][out] */ VARIANT_BOOL *pbBlocked) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Blocked( 
            /* [in] */ VARIANT_BOOL bBlocked) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetJobs( 
            /* [retval][out] */ IFaxIncomingJobs **pFaxIncomingJobs) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetJob( 
            /* [in] */ BSTR bstrJobId,
            /* [retval][out] */ IFaxIncomingJob **pFaxIncomingJob) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxIncomingQueueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxIncomingQueue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxIncomingQueue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxIncomingQueue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxIncomingQueue * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxIncomingQueue * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxIncomingQueue * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxIncomingQueue * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Blocked )( 
            IFaxIncomingQueue * This,
            /* [retval][out] */ VARIANT_BOOL *pbBlocked);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Blocked )( 
            IFaxIncomingQueue * This,
            /* [in] */ VARIANT_BOOL bBlocked);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxIncomingQueue * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxIncomingQueue * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetJobs )( 
            IFaxIncomingQueue * This,
            /* [retval][out] */ IFaxIncomingJobs **pFaxIncomingJobs);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetJob )( 
            IFaxIncomingQueue * This,
            /* [in] */ BSTR bstrJobId,
            /* [retval][out] */ IFaxIncomingJob **pFaxIncomingJob);
        
        END_INTERFACE
    } IFaxIncomingQueueVtbl;

    interface IFaxIncomingQueue
    {
        CONST_VTBL struct IFaxIncomingQueueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxIncomingQueue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxIncomingQueue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxIncomingQueue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxIncomingQueue_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxIncomingQueue_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxIncomingQueue_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxIncomingQueue_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxIncomingQueue_get_Blocked(This,pbBlocked)	\
    (This)->lpVtbl -> get_Blocked(This,pbBlocked)

#define IFaxIncomingQueue_put_Blocked(This,bBlocked)	\
    (This)->lpVtbl -> put_Blocked(This,bBlocked)

#define IFaxIncomingQueue_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxIncomingQueue_Save(This)	\
    (This)->lpVtbl -> Save(This)

#define IFaxIncomingQueue_GetJobs(This,pFaxIncomingJobs)	\
    (This)->lpVtbl -> GetJobs(This,pFaxIncomingJobs)

#define IFaxIncomingQueue_GetJob(This,bstrJobId,pFaxIncomingJob)	\
    (This)->lpVtbl -> GetJob(This,bstrJobId,pFaxIncomingJob)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingQueue_get_Blocked_Proxy( 
    IFaxIncomingQueue * This,
    /* [retval][out] */ VARIANT_BOOL *pbBlocked);


void __RPC_STUB IFaxIncomingQueue_get_Blocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxIncomingQueue_put_Blocked_Proxy( 
    IFaxIncomingQueue * This,
    /* [in] */ VARIANT_BOOL bBlocked);


void __RPC_STUB IFaxIncomingQueue_put_Blocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingQueue_Refresh_Proxy( 
    IFaxIncomingQueue * This);


void __RPC_STUB IFaxIncomingQueue_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingQueue_Save_Proxy( 
    IFaxIncomingQueue * This);


void __RPC_STUB IFaxIncomingQueue_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingQueue_GetJobs_Proxy( 
    IFaxIncomingQueue * This,
    /* [retval][out] */ IFaxIncomingJobs **pFaxIncomingJobs);


void __RPC_STUB IFaxIncomingQueue_GetJobs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingQueue_GetJob_Proxy( 
    IFaxIncomingQueue * This,
    /* [in] */ BSTR bstrJobId,
    /* [retval][out] */ IFaxIncomingJob **pFaxIncomingJob);


void __RPC_STUB IFaxIncomingQueue_GetJob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxIncomingQueue_INTERFACE_DEFINED__ */


#ifndef __IFaxOutgoingArchive_INTERFACE_DEFINED__
#define __IFaxOutgoingArchive_INTERFACE_DEFINED__

/* interface IFaxOutgoingArchive */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxOutgoingArchive;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C9C28F40-8D80-4E53-810F-9A79919B49FD")
    IFaxOutgoingArchive : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseArchive( 
            /* [retval][out] */ VARIANT_BOOL *pbUseArchive) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UseArchive( 
            /* [in] */ VARIANT_BOOL bUseArchive) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ArchiveFolder( 
            /* [retval][out] */ BSTR *pbstrArchiveFolder) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ArchiveFolder( 
            /* [in] */ BSTR bstrArchiveFolder) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SizeQuotaWarning( 
            /* [retval][out] */ VARIANT_BOOL *pbSizeQuotaWarning) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SizeQuotaWarning( 
            /* [in] */ VARIANT_BOOL bSizeQuotaWarning) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HighQuotaWaterMark( 
            /* [retval][out] */ long *plHighQuotaWaterMark) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_HighQuotaWaterMark( 
            /* [in] */ long lHighQuotaWaterMark) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LowQuotaWaterMark( 
            /* [retval][out] */ long *plLowQuotaWaterMark) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LowQuotaWaterMark( 
            /* [in] */ long lLowQuotaWaterMark) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AgeLimit( 
            /* [retval][out] */ long *plAgeLimit) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AgeLimit( 
            /* [in] */ long lAgeLimit) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SizeLow( 
            /* [retval][out] */ long *plSizeLow) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SizeHigh( 
            /* [retval][out] */ long *plSizeHigh) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMessages( 
            /* [defaultvalue][in] */ long lPrefetchSize,
            /* [retval][out] */ IFaxOutgoingMessageIterator **pFaxOutgoingMessageIterator) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMessage( 
            /* [in] */ BSTR bstrMessageId,
            /* [retval][out] */ IFaxOutgoingMessage **pFaxOutgoingMessage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutgoingArchiveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutgoingArchive * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutgoingArchive * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutgoingArchive * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutgoingArchive * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutgoingArchive * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutgoingArchive * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutgoingArchive * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseArchive )( 
            IFaxOutgoingArchive * This,
            /* [retval][out] */ VARIANT_BOOL *pbUseArchive);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseArchive )( 
            IFaxOutgoingArchive * This,
            /* [in] */ VARIANT_BOOL bUseArchive);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ArchiveFolder )( 
            IFaxOutgoingArchive * This,
            /* [retval][out] */ BSTR *pbstrArchiveFolder);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ArchiveFolder )( 
            IFaxOutgoingArchive * This,
            /* [in] */ BSTR bstrArchiveFolder);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SizeQuotaWarning )( 
            IFaxOutgoingArchive * This,
            /* [retval][out] */ VARIANT_BOOL *pbSizeQuotaWarning);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SizeQuotaWarning )( 
            IFaxOutgoingArchive * This,
            /* [in] */ VARIANT_BOOL bSizeQuotaWarning);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HighQuotaWaterMark )( 
            IFaxOutgoingArchive * This,
            /* [retval][out] */ long *plHighQuotaWaterMark);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HighQuotaWaterMark )( 
            IFaxOutgoingArchive * This,
            /* [in] */ long lHighQuotaWaterMark);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LowQuotaWaterMark )( 
            IFaxOutgoingArchive * This,
            /* [retval][out] */ long *plLowQuotaWaterMark);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LowQuotaWaterMark )( 
            IFaxOutgoingArchive * This,
            /* [in] */ long lLowQuotaWaterMark);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AgeLimit )( 
            IFaxOutgoingArchive * This,
            /* [retval][out] */ long *plAgeLimit);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AgeLimit )( 
            IFaxOutgoingArchive * This,
            /* [in] */ long lAgeLimit);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SizeLow )( 
            IFaxOutgoingArchive * This,
            /* [retval][out] */ long *plSizeLow);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SizeHigh )( 
            IFaxOutgoingArchive * This,
            /* [retval][out] */ long *plSizeHigh);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxOutgoingArchive * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxOutgoingArchive * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMessages )( 
            IFaxOutgoingArchive * This,
            /* [defaultvalue][in] */ long lPrefetchSize,
            /* [retval][out] */ IFaxOutgoingMessageIterator **pFaxOutgoingMessageIterator);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMessage )( 
            IFaxOutgoingArchive * This,
            /* [in] */ BSTR bstrMessageId,
            /* [retval][out] */ IFaxOutgoingMessage **pFaxOutgoingMessage);
        
        END_INTERFACE
    } IFaxOutgoingArchiveVtbl;

    interface IFaxOutgoingArchive
    {
        CONST_VTBL struct IFaxOutgoingArchiveVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutgoingArchive_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutgoingArchive_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutgoingArchive_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutgoingArchive_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutgoingArchive_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutgoingArchive_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutgoingArchive_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutgoingArchive_get_UseArchive(This,pbUseArchive)	\
    (This)->lpVtbl -> get_UseArchive(This,pbUseArchive)

#define IFaxOutgoingArchive_put_UseArchive(This,bUseArchive)	\
    (This)->lpVtbl -> put_UseArchive(This,bUseArchive)

#define IFaxOutgoingArchive_get_ArchiveFolder(This,pbstrArchiveFolder)	\
    (This)->lpVtbl -> get_ArchiveFolder(This,pbstrArchiveFolder)

#define IFaxOutgoingArchive_put_ArchiveFolder(This,bstrArchiveFolder)	\
    (This)->lpVtbl -> put_ArchiveFolder(This,bstrArchiveFolder)

#define IFaxOutgoingArchive_get_SizeQuotaWarning(This,pbSizeQuotaWarning)	\
    (This)->lpVtbl -> get_SizeQuotaWarning(This,pbSizeQuotaWarning)

#define IFaxOutgoingArchive_put_SizeQuotaWarning(This,bSizeQuotaWarning)	\
    (This)->lpVtbl -> put_SizeQuotaWarning(This,bSizeQuotaWarning)

#define IFaxOutgoingArchive_get_HighQuotaWaterMark(This,plHighQuotaWaterMark)	\
    (This)->lpVtbl -> get_HighQuotaWaterMark(This,plHighQuotaWaterMark)

#define IFaxOutgoingArchive_put_HighQuotaWaterMark(This,lHighQuotaWaterMark)	\
    (This)->lpVtbl -> put_HighQuotaWaterMark(This,lHighQuotaWaterMark)

#define IFaxOutgoingArchive_get_LowQuotaWaterMark(This,plLowQuotaWaterMark)	\
    (This)->lpVtbl -> get_LowQuotaWaterMark(This,plLowQuotaWaterMark)

#define IFaxOutgoingArchive_put_LowQuotaWaterMark(This,lLowQuotaWaterMark)	\
    (This)->lpVtbl -> put_LowQuotaWaterMark(This,lLowQuotaWaterMark)

#define IFaxOutgoingArchive_get_AgeLimit(This,plAgeLimit)	\
    (This)->lpVtbl -> get_AgeLimit(This,plAgeLimit)

#define IFaxOutgoingArchive_put_AgeLimit(This,lAgeLimit)	\
    (This)->lpVtbl -> put_AgeLimit(This,lAgeLimit)

#define IFaxOutgoingArchive_get_SizeLow(This,plSizeLow)	\
    (This)->lpVtbl -> get_SizeLow(This,plSizeLow)

#define IFaxOutgoingArchive_get_SizeHigh(This,plSizeHigh)	\
    (This)->lpVtbl -> get_SizeHigh(This,plSizeHigh)

#define IFaxOutgoingArchive_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxOutgoingArchive_Save(This)	\
    (This)->lpVtbl -> Save(This)

#define IFaxOutgoingArchive_GetMessages(This,lPrefetchSize,pFaxOutgoingMessageIterator)	\
    (This)->lpVtbl -> GetMessages(This,lPrefetchSize,pFaxOutgoingMessageIterator)

#define IFaxOutgoingArchive_GetMessage(This,bstrMessageId,pFaxOutgoingMessage)	\
    (This)->lpVtbl -> GetMessage(This,bstrMessageId,pFaxOutgoingMessage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_get_UseArchive_Proxy( 
    IFaxOutgoingArchive * This,
    /* [retval][out] */ VARIANT_BOOL *pbUseArchive);


void __RPC_STUB IFaxOutgoingArchive_get_UseArchive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_put_UseArchive_Proxy( 
    IFaxOutgoingArchive * This,
    /* [in] */ VARIANT_BOOL bUseArchive);


void __RPC_STUB IFaxOutgoingArchive_put_UseArchive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_get_ArchiveFolder_Proxy( 
    IFaxOutgoingArchive * This,
    /* [retval][out] */ BSTR *pbstrArchiveFolder);


void __RPC_STUB IFaxOutgoingArchive_get_ArchiveFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_put_ArchiveFolder_Proxy( 
    IFaxOutgoingArchive * This,
    /* [in] */ BSTR bstrArchiveFolder);


void __RPC_STUB IFaxOutgoingArchive_put_ArchiveFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_get_SizeQuotaWarning_Proxy( 
    IFaxOutgoingArchive * This,
    /* [retval][out] */ VARIANT_BOOL *pbSizeQuotaWarning);


void __RPC_STUB IFaxOutgoingArchive_get_SizeQuotaWarning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_put_SizeQuotaWarning_Proxy( 
    IFaxOutgoingArchive * This,
    /* [in] */ VARIANT_BOOL bSizeQuotaWarning);


void __RPC_STUB IFaxOutgoingArchive_put_SizeQuotaWarning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_get_HighQuotaWaterMark_Proxy( 
    IFaxOutgoingArchive * This,
    /* [retval][out] */ long *plHighQuotaWaterMark);


void __RPC_STUB IFaxOutgoingArchive_get_HighQuotaWaterMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_put_HighQuotaWaterMark_Proxy( 
    IFaxOutgoingArchive * This,
    /* [in] */ long lHighQuotaWaterMark);


void __RPC_STUB IFaxOutgoingArchive_put_HighQuotaWaterMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_get_LowQuotaWaterMark_Proxy( 
    IFaxOutgoingArchive * This,
    /* [retval][out] */ long *plLowQuotaWaterMark);


void __RPC_STUB IFaxOutgoingArchive_get_LowQuotaWaterMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_put_LowQuotaWaterMark_Proxy( 
    IFaxOutgoingArchive * This,
    /* [in] */ long lLowQuotaWaterMark);


void __RPC_STUB IFaxOutgoingArchive_put_LowQuotaWaterMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_get_AgeLimit_Proxy( 
    IFaxOutgoingArchive * This,
    /* [retval][out] */ long *plAgeLimit);


void __RPC_STUB IFaxOutgoingArchive_get_AgeLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_put_AgeLimit_Proxy( 
    IFaxOutgoingArchive * This,
    /* [in] */ long lAgeLimit);


void __RPC_STUB IFaxOutgoingArchive_put_AgeLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_get_SizeLow_Proxy( 
    IFaxOutgoingArchive * This,
    /* [retval][out] */ long *plSizeLow);


void __RPC_STUB IFaxOutgoingArchive_get_SizeLow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_get_SizeHigh_Proxy( 
    IFaxOutgoingArchive * This,
    /* [retval][out] */ long *plSizeHigh);


void __RPC_STUB IFaxOutgoingArchive_get_SizeHigh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_Refresh_Proxy( 
    IFaxOutgoingArchive * This);


void __RPC_STUB IFaxOutgoingArchive_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_Save_Proxy( 
    IFaxOutgoingArchive * This);


void __RPC_STUB IFaxOutgoingArchive_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_GetMessages_Proxy( 
    IFaxOutgoingArchive * This,
    /* [defaultvalue][in] */ long lPrefetchSize,
    /* [retval][out] */ IFaxOutgoingMessageIterator **pFaxOutgoingMessageIterator);


void __RPC_STUB IFaxOutgoingArchive_GetMessages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_GetMessage_Proxy( 
    IFaxOutgoingArchive * This,
    /* [in] */ BSTR bstrMessageId,
    /* [retval][out] */ IFaxOutgoingMessage **pFaxOutgoingMessage);


void __RPC_STUB IFaxOutgoingArchive_GetMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutgoingArchive_INTERFACE_DEFINED__ */


#ifndef __IFaxOutgoingQueue_INTERFACE_DEFINED__
#define __IFaxOutgoingQueue_INTERFACE_DEFINED__

/* interface IFaxOutgoingQueue */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxOutgoingQueue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("80B1DF24-D9AC-4333-B373-487CEDC80CE5")
    IFaxOutgoingQueue : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Blocked( 
            /* [retval][out] */ VARIANT_BOOL *pbBlocked) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Blocked( 
            /* [in] */ VARIANT_BOOL bBlocked) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Paused( 
            /* [retval][out] */ VARIANT_BOOL *pbPaused) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Paused( 
            /* [in] */ VARIANT_BOOL bPaused) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowPersonalCoverPages( 
            /* [retval][out] */ VARIANT_BOOL *pbAllowPersonalCoverPages) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowPersonalCoverPages( 
            /* [in] */ VARIANT_BOOL bAllowPersonalCoverPages) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseDeviceTSID( 
            /* [retval][out] */ VARIANT_BOOL *pbUseDeviceTSID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UseDeviceTSID( 
            /* [in] */ VARIANT_BOOL bUseDeviceTSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Retries( 
            /* [retval][out] */ long *plRetries) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Retries( 
            /* [in] */ long lRetries) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RetryDelay( 
            /* [retval][out] */ long *plRetryDelay) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RetryDelay( 
            /* [in] */ long lRetryDelay) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountRateStart( 
            /* [retval][out] */ DATE *pdateDiscountRateStart) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscountRateStart( 
            /* [in] */ DATE dateDiscountRateStart) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountRateEnd( 
            /* [retval][out] */ DATE *pdateDiscountRateEnd) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscountRateEnd( 
            /* [in] */ DATE dateDiscountRateEnd) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AgeLimit( 
            /* [retval][out] */ long *plAgeLimit) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AgeLimit( 
            /* [in] */ long lAgeLimit) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Branding( 
            /* [retval][out] */ VARIANT_BOOL *pbBranding) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Branding( 
            /* [in] */ VARIANT_BOOL bBranding) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetJobs( 
            /* [retval][out] */ IFaxOutgoingJobs **pFaxOutgoingJobs) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetJob( 
            /* [in] */ BSTR bstrJobId,
            /* [retval][out] */ IFaxOutgoingJob **pFaxOutgoingJob) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutgoingQueueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutgoingQueue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutgoingQueue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutgoingQueue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutgoingQueue * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutgoingQueue * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutgoingQueue * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutgoingQueue * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Blocked )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ VARIANT_BOOL *pbBlocked);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Blocked )( 
            IFaxOutgoingQueue * This,
            /* [in] */ VARIANT_BOOL bBlocked);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Paused )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ VARIANT_BOOL *pbPaused);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Paused )( 
            IFaxOutgoingQueue * This,
            /* [in] */ VARIANT_BOOL bPaused);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowPersonalCoverPages )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ VARIANT_BOOL *pbAllowPersonalCoverPages);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowPersonalCoverPages )( 
            IFaxOutgoingQueue * This,
            /* [in] */ VARIANT_BOOL bAllowPersonalCoverPages);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseDeviceTSID )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ VARIANT_BOOL *pbUseDeviceTSID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseDeviceTSID )( 
            IFaxOutgoingQueue * This,
            /* [in] */ VARIANT_BOOL bUseDeviceTSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Retries )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ long *plRetries);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Retries )( 
            IFaxOutgoingQueue * This,
            /* [in] */ long lRetries);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RetryDelay )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ long *plRetryDelay);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RetryDelay )( 
            IFaxOutgoingQueue * This,
            /* [in] */ long lRetryDelay);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiscountRateStart )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ DATE *pdateDiscountRateStart);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DiscountRateStart )( 
            IFaxOutgoingQueue * This,
            /* [in] */ DATE dateDiscountRateStart);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiscountRateEnd )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ DATE *pdateDiscountRateEnd);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DiscountRateEnd )( 
            IFaxOutgoingQueue * This,
            /* [in] */ DATE dateDiscountRateEnd);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AgeLimit )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ long *plAgeLimit);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AgeLimit )( 
            IFaxOutgoingQueue * This,
            /* [in] */ long lAgeLimit);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Branding )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ VARIANT_BOOL *pbBranding);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Branding )( 
            IFaxOutgoingQueue * This,
            /* [in] */ VARIANT_BOOL bBranding);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxOutgoingQueue * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxOutgoingQueue * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetJobs )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ IFaxOutgoingJobs **pFaxOutgoingJobs);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetJob )( 
            IFaxOutgoingQueue * This,
            /* [in] */ BSTR bstrJobId,
            /* [retval][out] */ IFaxOutgoingJob **pFaxOutgoingJob);
        
        END_INTERFACE
    } IFaxOutgoingQueueVtbl;

    interface IFaxOutgoingQueue
    {
        CONST_VTBL struct IFaxOutgoingQueueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutgoingQueue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutgoingQueue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutgoingQueue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutgoingQueue_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutgoingQueue_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutgoingQueue_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutgoingQueue_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutgoingQueue_get_Blocked(This,pbBlocked)	\
    (This)->lpVtbl -> get_Blocked(This,pbBlocked)

#define IFaxOutgoingQueue_put_Blocked(This,bBlocked)	\
    (This)->lpVtbl -> put_Blocked(This,bBlocked)

#define IFaxOutgoingQueue_get_Paused(This,pbPaused)	\
    (This)->lpVtbl -> get_Paused(This,pbPaused)

#define IFaxOutgoingQueue_put_Paused(This,bPaused)	\
    (This)->lpVtbl -> put_Paused(This,bPaused)

#define IFaxOutgoingQueue_get_AllowPersonalCoverPages(This,pbAllowPersonalCoverPages)	\
    (This)->lpVtbl -> get_AllowPersonalCoverPages(This,pbAllowPersonalCoverPages)

#define IFaxOutgoingQueue_put_AllowPersonalCoverPages(This,bAllowPersonalCoverPages)	\
    (This)->lpVtbl -> put_AllowPersonalCoverPages(This,bAllowPersonalCoverPages)

#define IFaxOutgoingQueue_get_UseDeviceTSID(This,pbUseDeviceTSID)	\
    (This)->lpVtbl -> get_UseDeviceTSID(This,pbUseDeviceTSID)

#define IFaxOutgoingQueue_put_UseDeviceTSID(This,bUseDeviceTSID)	\
    (This)->lpVtbl -> put_UseDeviceTSID(This,bUseDeviceTSID)

#define IFaxOutgoingQueue_get_Retries(This,plRetries)	\
    (This)->lpVtbl -> get_Retries(This,plRetries)

#define IFaxOutgoingQueue_put_Retries(This,lRetries)	\
    (This)->lpVtbl -> put_Retries(This,lRetries)

#define IFaxOutgoingQueue_get_RetryDelay(This,plRetryDelay)	\
    (This)->lpVtbl -> get_RetryDelay(This,plRetryDelay)

#define IFaxOutgoingQueue_put_RetryDelay(This,lRetryDelay)	\
    (This)->lpVtbl -> put_RetryDelay(This,lRetryDelay)

#define IFaxOutgoingQueue_get_DiscountRateStart(This,pdateDiscountRateStart)	\
    (This)->lpVtbl -> get_DiscountRateStart(This,pdateDiscountRateStart)

#define IFaxOutgoingQueue_put_DiscountRateStart(This,dateDiscountRateStart)	\
    (This)->lpVtbl -> put_DiscountRateStart(This,dateDiscountRateStart)

#define IFaxOutgoingQueue_get_DiscountRateEnd(This,pdateDiscountRateEnd)	\
    (This)->lpVtbl -> get_DiscountRateEnd(This,pdateDiscountRateEnd)

#define IFaxOutgoingQueue_put_DiscountRateEnd(This,dateDiscountRateEnd)	\
    (This)->lpVtbl -> put_DiscountRateEnd(This,dateDiscountRateEnd)

#define IFaxOutgoingQueue_get_AgeLimit(This,plAgeLimit)	\
    (This)->lpVtbl -> get_AgeLimit(This,plAgeLimit)

#define IFaxOutgoingQueue_put_AgeLimit(This,lAgeLimit)	\
    (This)->lpVtbl -> put_AgeLimit(This,lAgeLimit)

#define IFaxOutgoingQueue_get_Branding(This,pbBranding)	\
    (This)->lpVtbl -> get_Branding(This,pbBranding)

#define IFaxOutgoingQueue_put_Branding(This,bBranding)	\
    (This)->lpVtbl -> put_Branding(This,bBranding)

#define IFaxOutgoingQueue_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxOutgoingQueue_Save(This)	\
    (This)->lpVtbl -> Save(This)

#define IFaxOutgoingQueue_GetJobs(This,pFaxOutgoingJobs)	\
    (This)->lpVtbl -> GetJobs(This,pFaxOutgoingJobs)

#define IFaxOutgoingQueue_GetJob(This,bstrJobId,pFaxOutgoingJob)	\
    (This)->lpVtbl -> GetJob(This,bstrJobId,pFaxOutgoingJob)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_Blocked_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ VARIANT_BOOL *pbBlocked);


void __RPC_STUB IFaxOutgoingQueue_get_Blocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_Blocked_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ VARIANT_BOOL bBlocked);


void __RPC_STUB IFaxOutgoingQueue_put_Blocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_Paused_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ VARIANT_BOOL *pbPaused);


void __RPC_STUB IFaxOutgoingQueue_get_Paused_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_Paused_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ VARIANT_BOOL bPaused);


void __RPC_STUB IFaxOutgoingQueue_put_Paused_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_AllowPersonalCoverPages_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ VARIANT_BOOL *pbAllowPersonalCoverPages);


void __RPC_STUB IFaxOutgoingQueue_get_AllowPersonalCoverPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_AllowPersonalCoverPages_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ VARIANT_BOOL bAllowPersonalCoverPages);


void __RPC_STUB IFaxOutgoingQueue_put_AllowPersonalCoverPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_UseDeviceTSID_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ VARIANT_BOOL *pbUseDeviceTSID);


void __RPC_STUB IFaxOutgoingQueue_get_UseDeviceTSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_UseDeviceTSID_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ VARIANT_BOOL bUseDeviceTSID);


void __RPC_STUB IFaxOutgoingQueue_put_UseDeviceTSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_Retries_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ long *plRetries);


void __RPC_STUB IFaxOutgoingQueue_get_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_Retries_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ long lRetries);


void __RPC_STUB IFaxOutgoingQueue_put_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_RetryDelay_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ long *plRetryDelay);


void __RPC_STUB IFaxOutgoingQueue_get_RetryDelay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_RetryDelay_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ long lRetryDelay);


void __RPC_STUB IFaxOutgoingQueue_put_RetryDelay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_DiscountRateStart_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ DATE *pdateDiscountRateStart);


void __RPC_STUB IFaxOutgoingQueue_get_DiscountRateStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_DiscountRateStart_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ DATE dateDiscountRateStart);


void __RPC_STUB IFaxOutgoingQueue_put_DiscountRateStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_DiscountRateEnd_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ DATE *pdateDiscountRateEnd);


void __RPC_STUB IFaxOutgoingQueue_get_DiscountRateEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_DiscountRateEnd_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ DATE dateDiscountRateEnd);


void __RPC_STUB IFaxOutgoingQueue_put_DiscountRateEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_AgeLimit_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ long *plAgeLimit);


void __RPC_STUB IFaxOutgoingQueue_get_AgeLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_AgeLimit_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ long lAgeLimit);


void __RPC_STUB IFaxOutgoingQueue_put_AgeLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_Branding_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ VARIANT_BOOL *pbBranding);


void __RPC_STUB IFaxOutgoingQueue_get_Branding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_Branding_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ VARIANT_BOOL bBranding);


void __RPC_STUB IFaxOutgoingQueue_put_Branding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_Refresh_Proxy( 
    IFaxOutgoingQueue * This);


void __RPC_STUB IFaxOutgoingQueue_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_Save_Proxy( 
    IFaxOutgoingQueue * This);


void __RPC_STUB IFaxOutgoingQueue_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_GetJobs_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ IFaxOutgoingJobs **pFaxOutgoingJobs);


void __RPC_STUB IFaxOutgoingQueue_GetJobs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_GetJob_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ BSTR bstrJobId,
    /* [retval][out] */ IFaxOutgoingJob **pFaxOutgoingJob);


void __RPC_STUB IFaxOutgoingQueue_GetJob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutgoingQueue_INTERFACE_DEFINED__ */


#ifndef __IFaxIncomingMessageIterator_INTERFACE_DEFINED__
#define __IFaxIncomingMessageIterator_INTERFACE_DEFINED__

/* interface IFaxIncomingMessageIterator */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxIncomingMessageIterator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FD73ECC4-6F06-4F52-82A8-F7BA06AE3108")
    IFaxIncomingMessageIterator : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Message( 
            /* [retval][out] */ IFaxIncomingMessage **pFaxIncomingMessage) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PrefetchSize( 
            /* [retval][out] */ long *plPrefetchSize) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PrefetchSize( 
            /* [in] */ long lPrefetchSize) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AtEOF( 
            /* [retval][out] */ VARIANT_BOOL *pbEOF) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveFirst( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveNext( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxIncomingMessageIteratorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxIncomingMessageIterator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxIncomingMessageIterator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxIncomingMessageIterator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxIncomingMessageIterator * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxIncomingMessageIterator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxIncomingMessageIterator * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxIncomingMessageIterator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Message )( 
            IFaxIncomingMessageIterator * This,
            /* [retval][out] */ IFaxIncomingMessage **pFaxIncomingMessage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrefetchSize )( 
            IFaxIncomingMessageIterator * This,
            /* [retval][out] */ long *plPrefetchSize);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrefetchSize )( 
            IFaxIncomingMessageIterator * This,
            /* [in] */ long lPrefetchSize);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AtEOF )( 
            IFaxIncomingMessageIterator * This,
            /* [retval][out] */ VARIANT_BOOL *pbEOF);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MoveFirst )( 
            IFaxIncomingMessageIterator * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MoveNext )( 
            IFaxIncomingMessageIterator * This);
        
        END_INTERFACE
    } IFaxIncomingMessageIteratorVtbl;

    interface IFaxIncomingMessageIterator
    {
        CONST_VTBL struct IFaxIncomingMessageIteratorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxIncomingMessageIterator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxIncomingMessageIterator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxIncomingMessageIterator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxIncomingMessageIterator_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxIncomingMessageIterator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxIncomingMessageIterator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxIncomingMessageIterator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxIncomingMessageIterator_get_Message(This,pFaxIncomingMessage)	\
    (This)->lpVtbl -> get_Message(This,pFaxIncomingMessage)

#define IFaxIncomingMessageIterator_get_PrefetchSize(This,plPrefetchSize)	\
    (This)->lpVtbl -> get_PrefetchSize(This,plPrefetchSize)

#define IFaxIncomingMessageIterator_put_PrefetchSize(This,lPrefetchSize)	\
    (This)->lpVtbl -> put_PrefetchSize(This,lPrefetchSize)

#define IFaxIncomingMessageIterator_get_AtEOF(This,pbEOF)	\
    (This)->lpVtbl -> get_AtEOF(This,pbEOF)

#define IFaxIncomingMessageIterator_MoveFirst(This)	\
    (This)->lpVtbl -> MoveFirst(This)

#define IFaxIncomingMessageIterator_MoveNext(This)	\
    (This)->lpVtbl -> MoveNext(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessageIterator_get_Message_Proxy( 
    IFaxIncomingMessageIterator * This,
    /* [retval][out] */ IFaxIncomingMessage **pFaxIncomingMessage);


void __RPC_STUB IFaxIncomingMessageIterator_get_Message_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessageIterator_get_PrefetchSize_Proxy( 
    IFaxIncomingMessageIterator * This,
    /* [retval][out] */ long *plPrefetchSize);


void __RPC_STUB IFaxIncomingMessageIterator_get_PrefetchSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessageIterator_put_PrefetchSize_Proxy( 
    IFaxIncomingMessageIterator * This,
    /* [in] */ long lPrefetchSize);


void __RPC_STUB IFaxIncomingMessageIterator_put_PrefetchSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessageIterator_get_AtEOF_Proxy( 
    IFaxIncomingMessageIterator * This,
    /* [retval][out] */ VARIANT_BOOL *pbEOF);


void __RPC_STUB IFaxIncomingMessageIterator_get_AtEOF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessageIterator_MoveFirst_Proxy( 
    IFaxIncomingMessageIterator * This);


void __RPC_STUB IFaxIncomingMessageIterator_MoveFirst_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessageIterator_MoveNext_Proxy( 
    IFaxIncomingMessageIterator * This);


void __RPC_STUB IFaxIncomingMessageIterator_MoveNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxIncomingMessageIterator_INTERFACE_DEFINED__ */


#ifndef __IFaxIncomingMessage_INTERFACE_DEFINED__
#define __IFaxIncomingMessage_INTERFACE_DEFINED__

/* interface IFaxIncomingMessage */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxIncomingMessage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7CAB88FA-2EF9-4851-B2F3-1D148FED8447")
    IFaxIncomingMessage : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ BSTR *pbstrId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Pages( 
            /* [retval][out] */ long *plPages) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ long *plSize) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceName( 
            /* [retval][out] */ BSTR *pbstrDeviceName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Retries( 
            /* [retval][out] */ long *plRetries) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionStart( 
            /* [retval][out] */ DATE *pdateTransmissionStart) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionEnd( 
            /* [retval][out] */ DATE *pdateTransmissionEnd) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CSID( 
            /* [retval][out] */ BSTR *pbstrCSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TSID( 
            /* [retval][out] */ BSTR *pbstrTSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallerId( 
            /* [retval][out] */ BSTR *pbstrCallerId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RoutingInformation( 
            /* [retval][out] */ BSTR *pbstrRoutingInformation) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyTiff( 
            /* [in] */ BSTR bstrTiffPath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxIncomingMessageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxIncomingMessage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxIncomingMessage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxIncomingMessage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxIncomingMessage * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxIncomingMessage * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxIncomingMessage * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxIncomingMessage * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ BSTR *pbstrId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Pages )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ long *plPages);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ long *plSize);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceName )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ BSTR *pbstrDeviceName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Retries )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ long *plRetries);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionStart )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ DATE *pdateTransmissionStart);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionEnd )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ DATE *pdateTransmissionEnd);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CSID )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ BSTR *pbstrCSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TSID )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ BSTR *pbstrTSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallerId )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ BSTR *pbstrCallerId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RoutingInformation )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ BSTR *pbstrRoutingInformation);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyTiff )( 
            IFaxIncomingMessage * This,
            /* [in] */ BSTR bstrTiffPath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IFaxIncomingMessage * This);
        
        END_INTERFACE
    } IFaxIncomingMessageVtbl;

    interface IFaxIncomingMessage
    {
        CONST_VTBL struct IFaxIncomingMessageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxIncomingMessage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxIncomingMessage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxIncomingMessage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxIncomingMessage_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxIncomingMessage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxIncomingMessage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxIncomingMessage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxIncomingMessage_get_Id(This,pbstrId)	\
    (This)->lpVtbl -> get_Id(This,pbstrId)

#define IFaxIncomingMessage_get_Pages(This,plPages)	\
    (This)->lpVtbl -> get_Pages(This,plPages)

#define IFaxIncomingMessage_get_Size(This,plSize)	\
    (This)->lpVtbl -> get_Size(This,plSize)

#define IFaxIncomingMessage_get_DeviceName(This,pbstrDeviceName)	\
    (This)->lpVtbl -> get_DeviceName(This,pbstrDeviceName)

#define IFaxIncomingMessage_get_Retries(This,plRetries)	\
    (This)->lpVtbl -> get_Retries(This,plRetries)

#define IFaxIncomingMessage_get_TransmissionStart(This,pdateTransmissionStart)	\
    (This)->lpVtbl -> get_TransmissionStart(This,pdateTransmissionStart)

#define IFaxIncomingMessage_get_TransmissionEnd(This,pdateTransmissionEnd)	\
    (This)->lpVtbl -> get_TransmissionEnd(This,pdateTransmissionEnd)

#define IFaxIncomingMessage_get_CSID(This,pbstrCSID)	\
    (This)->lpVtbl -> get_CSID(This,pbstrCSID)

#define IFaxIncomingMessage_get_TSID(This,pbstrTSID)	\
    (This)->lpVtbl -> get_TSID(This,pbstrTSID)

#define IFaxIncomingMessage_get_CallerId(This,pbstrCallerId)	\
    (This)->lpVtbl -> get_CallerId(This,pbstrCallerId)

#define IFaxIncomingMessage_get_RoutingInformation(This,pbstrRoutingInformation)	\
    (This)->lpVtbl -> get_RoutingInformation(This,pbstrRoutingInformation)

#define IFaxIncomingMessage_CopyTiff(This,bstrTiffPath)	\
    (This)->lpVtbl -> CopyTiff(This,bstrTiffPath)

#define IFaxIncomingMessage_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_Id_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ BSTR *pbstrId);


void __RPC_STUB IFaxIncomingMessage_get_Id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_Pages_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ long *plPages);


void __RPC_STUB IFaxIncomingMessage_get_Pages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_Size_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ long *plSize);


void __RPC_STUB IFaxIncomingMessage_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_DeviceName_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ BSTR *pbstrDeviceName);


void __RPC_STUB IFaxIncomingMessage_get_DeviceName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_Retries_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ long *plRetries);


void __RPC_STUB IFaxIncomingMessage_get_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_TransmissionStart_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ DATE *pdateTransmissionStart);


void __RPC_STUB IFaxIncomingMessage_get_TransmissionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_TransmissionEnd_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ DATE *pdateTransmissionEnd);


void __RPC_STUB IFaxIncomingMessage_get_TransmissionEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_CSID_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ BSTR *pbstrCSID);


void __RPC_STUB IFaxIncomingMessage_get_CSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_TSID_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ BSTR *pbstrTSID);


void __RPC_STUB IFaxIncomingMessage_get_TSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_CallerId_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ BSTR *pbstrCallerId);


void __RPC_STUB IFaxIncomingMessage_get_CallerId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_RoutingInformation_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ BSTR *pbstrRoutingInformation);


void __RPC_STUB IFaxIncomingMessage_get_RoutingInformation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_CopyTiff_Proxy( 
    IFaxIncomingMessage * This,
    /* [in] */ BSTR bstrTiffPath);


void __RPC_STUB IFaxIncomingMessage_CopyTiff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_Delete_Proxy( 
    IFaxIncomingMessage * This);


void __RPC_STUB IFaxIncomingMessage_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxIncomingMessage_INTERFACE_DEFINED__ */


#ifndef __IFaxOutgoingJobs_INTERFACE_DEFINED__
#define __IFaxOutgoingJobs_INTERFACE_DEFINED__

/* interface IFaxOutgoingJobs */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxOutgoingJobs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C56D8E6-8C2F-4573-944C-E505F8F5AEED")
    IFaxOutgoingJobs : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxOutgoingJob **pFaxOutgoingJob) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutgoingJobsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutgoingJobs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutgoingJobs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutgoingJobs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutgoingJobs * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutgoingJobs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutgoingJobs * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutgoingJobs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxOutgoingJobs * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxOutgoingJobs * This,
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxOutgoingJob **pFaxOutgoingJob);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxOutgoingJobs * This,
            /* [retval][out] */ long *plCount);
        
        END_INTERFACE
    } IFaxOutgoingJobsVtbl;

    interface IFaxOutgoingJobs
    {
        CONST_VTBL struct IFaxOutgoingJobsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutgoingJobs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutgoingJobs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutgoingJobs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutgoingJobs_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutgoingJobs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutgoingJobs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutgoingJobs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutgoingJobs_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxOutgoingJobs_get_Item(This,vIndex,pFaxOutgoingJob)	\
    (This)->lpVtbl -> get_Item(This,vIndex,pFaxOutgoingJob)

#define IFaxOutgoingJobs_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJobs_get__NewEnum_Proxy( 
    IFaxOutgoingJobs * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxOutgoingJobs_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJobs_get_Item_Proxy( 
    IFaxOutgoingJobs * This,
    /* [in] */ VARIANT vIndex,
    /* [retval][out] */ IFaxOutgoingJob **pFaxOutgoingJob);


void __RPC_STUB IFaxOutgoingJobs_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJobs_get_Count_Proxy( 
    IFaxOutgoingJobs * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxOutgoingJobs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutgoingJobs_INTERFACE_DEFINED__ */


#ifndef __IFaxOutgoingJob_INTERFACE_DEFINED__
#define __IFaxOutgoingJob_INTERFACE_DEFINED__

/* interface IFaxOutgoingJob */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxOutgoingJob;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6356DAAD-6614-4583-BF7A-3AD67BBFC71C")
    IFaxOutgoingJob : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Subject( 
            /* [retval][out] */ BSTR *pbstrSubject) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DocumentName( 
            /* [retval][out] */ BSTR *pbstrDocumentName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Pages( 
            /* [retval][out] */ long *plPages) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ long *plSize) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubmissionId( 
            /* [retval][out] */ BSTR *pbstrSubmissionId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ BSTR *pbstrId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OriginalScheduledTime( 
            /* [retval][out] */ DATE *pdateOriginalScheduledTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubmissionTime( 
            /* [retval][out] */ DATE *pdateSubmissionTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReceiptType( 
            /* [retval][out] */ FAX_RECEIPT_TYPE_ENUM *pReceiptType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ FAX_PRIORITY_TYPE_ENUM *pPriority) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Sender( 
            /* [retval][out] */ IFaxSender **ppFaxSender) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Recipient( 
            /* [retval][out] */ IFaxRecipient **ppFaxRecipient) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPage( 
            /* [retval][out] */ long *plCurrentPage) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceId( 
            /* [retval][out] */ long *plDeviceId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ FAX_JOB_STATUS_ENUM *pStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtendedStatusCode( 
            /* [retval][out] */ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtendedStatus( 
            /* [retval][out] */ BSTR *pbstrExtendedStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AvailableOperations( 
            /* [retval][out] */ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Retries( 
            /* [retval][out] */ long *plRetries) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ScheduledTime( 
            /* [retval][out] */ DATE *pdateScheduledTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionStart( 
            /* [retval][out] */ DATE *pdateTransmissionStart) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionEnd( 
            /* [retval][out] */ DATE *pdateTransmissionEnd) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CSID( 
            /* [retval][out] */ BSTR *pbstrCSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TSID( 
            /* [retval][out] */ BSTR *pbstrTSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GroupBroadcastReceipts( 
            /* [retval][out] */ VARIANT_BOOL *pbGroupBroadcastReceipts) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Restart( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyTiff( 
            /* [in] */ BSTR bstrTiffPath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutgoingJobVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutgoingJob * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutgoingJob * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutgoingJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutgoingJob * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutgoingJob * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutgoingJob * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutgoingJob * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Subject )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ BSTR *pbstrSubject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocumentName )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ BSTR *pbstrDocumentName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Pages )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ long *plPages);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ long *plSize);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubmissionId )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ BSTR *pbstrSubmissionId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ BSTR *pbstrId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OriginalScheduledTime )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ DATE *pdateOriginalScheduledTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubmissionTime )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ DATE *pdateSubmissionTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReceiptType )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ FAX_RECEIPT_TYPE_ENUM *pReceiptType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ FAX_PRIORITY_TYPE_ENUM *pPriority);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Sender )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ IFaxSender **ppFaxSender);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Recipient )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ IFaxRecipient **ppFaxRecipient);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPage )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ long *plCurrentPage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceId )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ long *plDeviceId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ FAX_JOB_STATUS_ENUM *pStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtendedStatusCode )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtendedStatus )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ BSTR *pbstrExtendedStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvailableOperations )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Retries )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ long *plRetries);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ScheduledTime )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ DATE *pdateScheduledTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionStart )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ DATE *pdateTransmissionStart);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionEnd )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ DATE *pdateTransmissionEnd);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CSID )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ BSTR *pbstrCSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TSID )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ BSTR *pbstrTSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GroupBroadcastReceipts )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ VARIANT_BOOL *pbGroupBroadcastReceipts);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IFaxOutgoingJob * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IFaxOutgoingJob * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Restart )( 
            IFaxOutgoingJob * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyTiff )( 
            IFaxOutgoingJob * This,
            /* [in] */ BSTR bstrTiffPath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxOutgoingJob * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IFaxOutgoingJob * This);
        
        END_INTERFACE
    } IFaxOutgoingJobVtbl;

    interface IFaxOutgoingJob
    {
        CONST_VTBL struct IFaxOutgoingJobVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutgoingJob_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutgoingJob_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutgoingJob_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutgoingJob_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutgoingJob_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutgoingJob_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutgoingJob_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutgoingJob_get_Subject(This,pbstrSubject)	\
    (This)->lpVtbl -> get_Subject(This,pbstrSubject)

#define IFaxOutgoingJob_get_DocumentName(This,pbstrDocumentName)	\
    (This)->lpVtbl -> get_DocumentName(This,pbstrDocumentName)

#define IFaxOutgoingJob_get_Pages(This,plPages)	\
    (This)->lpVtbl -> get_Pages(This,plPages)

#define IFaxOutgoingJob_get_Size(This,plSize)	\
    (This)->lpVtbl -> get_Size(This,plSize)

#define IFaxOutgoingJob_get_SubmissionId(This,pbstrSubmissionId)	\
    (This)->lpVtbl -> get_SubmissionId(This,pbstrSubmissionId)

#define IFaxOutgoingJob_get_Id(This,pbstrId)	\
    (This)->lpVtbl -> get_Id(This,pbstrId)

#define IFaxOutgoingJob_get_OriginalScheduledTime(This,pdateOriginalScheduledTime)	\
    (This)->lpVtbl -> get_OriginalScheduledTime(This,pdateOriginalScheduledTime)

#define IFaxOutgoingJob_get_SubmissionTime(This,pdateSubmissionTime)	\
    (This)->lpVtbl -> get_SubmissionTime(This,pdateSubmissionTime)

#define IFaxOutgoingJob_get_ReceiptType(This,pReceiptType)	\
    (This)->lpVtbl -> get_ReceiptType(This,pReceiptType)

#define IFaxOutgoingJob_get_Priority(This,pPriority)	\
    (This)->lpVtbl -> get_Priority(This,pPriority)

#define IFaxOutgoingJob_get_Sender(This,ppFaxSender)	\
    (This)->lpVtbl -> get_Sender(This,ppFaxSender)

#define IFaxOutgoingJob_get_Recipient(This,ppFaxRecipient)	\
    (This)->lpVtbl -> get_Recipient(This,ppFaxRecipient)

#define IFaxOutgoingJob_get_CurrentPage(This,plCurrentPage)	\
    (This)->lpVtbl -> get_CurrentPage(This,plCurrentPage)

#define IFaxOutgoingJob_get_DeviceId(This,plDeviceId)	\
    (This)->lpVtbl -> get_DeviceId(This,plDeviceId)

#define IFaxOutgoingJob_get_Status(This,pStatus)	\
    (This)->lpVtbl -> get_Status(This,pStatus)

#define IFaxOutgoingJob_get_ExtendedStatusCode(This,pExtendedStatusCode)	\
    (This)->lpVtbl -> get_ExtendedStatusCode(This,pExtendedStatusCode)

#define IFaxOutgoingJob_get_ExtendedStatus(This,pbstrExtendedStatus)	\
    (This)->lpVtbl -> get_ExtendedStatus(This,pbstrExtendedStatus)

#define IFaxOutgoingJob_get_AvailableOperations(This,pAvailableOperations)	\
    (This)->lpVtbl -> get_AvailableOperations(This,pAvailableOperations)

#define IFaxOutgoingJob_get_Retries(This,plRetries)	\
    (This)->lpVtbl -> get_Retries(This,plRetries)

#define IFaxOutgoingJob_get_ScheduledTime(This,pdateScheduledTime)	\
    (This)->lpVtbl -> get_ScheduledTime(This,pdateScheduledTime)

#define IFaxOutgoingJob_get_TransmissionStart(This,pdateTransmissionStart)	\
    (This)->lpVtbl -> get_TransmissionStart(This,pdateTransmissionStart)

#define IFaxOutgoingJob_get_TransmissionEnd(This,pdateTransmissionEnd)	\
    (This)->lpVtbl -> get_TransmissionEnd(This,pdateTransmissionEnd)

#define IFaxOutgoingJob_get_CSID(This,pbstrCSID)	\
    (This)->lpVtbl -> get_CSID(This,pbstrCSID)

#define IFaxOutgoingJob_get_TSID(This,pbstrTSID)	\
    (This)->lpVtbl -> get_TSID(This,pbstrTSID)

#define IFaxOutgoingJob_get_GroupBroadcastReceipts(This,pbGroupBroadcastReceipts)	\
    (This)->lpVtbl -> get_GroupBroadcastReceipts(This,pbGroupBroadcastReceipts)

#define IFaxOutgoingJob_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IFaxOutgoingJob_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IFaxOutgoingJob_Restart(This)	\
    (This)->lpVtbl -> Restart(This)

#define IFaxOutgoingJob_CopyTiff(This,bstrTiffPath)	\
    (This)->lpVtbl -> CopyTiff(This,bstrTiffPath)

#define IFaxOutgoingJob_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxOutgoingJob_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_Subject_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ BSTR *pbstrSubject);


void __RPC_STUB IFaxOutgoingJob_get_Subject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_DocumentName_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ BSTR *pbstrDocumentName);


void __RPC_STUB IFaxOutgoingJob_get_DocumentName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_Pages_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ long *plPages);


void __RPC_STUB IFaxOutgoingJob_get_Pages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_Size_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ long *plSize);


void __RPC_STUB IFaxOutgoingJob_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_SubmissionId_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ BSTR *pbstrSubmissionId);


void __RPC_STUB IFaxOutgoingJob_get_SubmissionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_Id_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ BSTR *pbstrId);


void __RPC_STUB IFaxOutgoingJob_get_Id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_OriginalScheduledTime_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ DATE *pdateOriginalScheduledTime);


void __RPC_STUB IFaxOutgoingJob_get_OriginalScheduledTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_SubmissionTime_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ DATE *pdateSubmissionTime);


void __RPC_STUB IFaxOutgoingJob_get_SubmissionTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_ReceiptType_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ FAX_RECEIPT_TYPE_ENUM *pReceiptType);


void __RPC_STUB IFaxOutgoingJob_get_ReceiptType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_Priority_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ FAX_PRIORITY_TYPE_ENUM *pPriority);


void __RPC_STUB IFaxOutgoingJob_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_Sender_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ IFaxSender **ppFaxSender);


void __RPC_STUB IFaxOutgoingJob_get_Sender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_Recipient_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ IFaxRecipient **ppFaxRecipient);


void __RPC_STUB IFaxOutgoingJob_get_Recipient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_CurrentPage_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ long *plCurrentPage);


void __RPC_STUB IFaxOutgoingJob_get_CurrentPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_DeviceId_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ long *plDeviceId);


void __RPC_STUB IFaxOutgoingJob_get_DeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_Status_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ FAX_JOB_STATUS_ENUM *pStatus);


void __RPC_STUB IFaxOutgoingJob_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_ExtendedStatusCode_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode);


void __RPC_STUB IFaxOutgoingJob_get_ExtendedStatusCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_ExtendedStatus_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ BSTR *pbstrExtendedStatus);


void __RPC_STUB IFaxOutgoingJob_get_ExtendedStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_AvailableOperations_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations);


void __RPC_STUB IFaxOutgoingJob_get_AvailableOperations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_Retries_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ long *plRetries);


void __RPC_STUB IFaxOutgoingJob_get_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_ScheduledTime_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ DATE *pdateScheduledTime);


void __RPC_STUB IFaxOutgoingJob_get_ScheduledTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_TransmissionStart_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ DATE *pdateTransmissionStart);


void __RPC_STUB IFaxOutgoingJob_get_TransmissionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_TransmissionEnd_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ DATE *pdateTransmissionEnd);


void __RPC_STUB IFaxOutgoingJob_get_TransmissionEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_CSID_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ BSTR *pbstrCSID);


void __RPC_STUB IFaxOutgoingJob_get_CSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_TSID_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ BSTR *pbstrTSID);


void __RPC_STUB IFaxOutgoingJob_get_TSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_GroupBroadcastReceipts_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ VARIANT_BOOL *pbGroupBroadcastReceipts);


void __RPC_STUB IFaxOutgoingJob_get_GroupBroadcastReceipts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_Pause_Proxy( 
    IFaxOutgoingJob * This);


void __RPC_STUB IFaxOutgoingJob_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_Resume_Proxy( 
    IFaxOutgoingJob * This);


void __RPC_STUB IFaxOutgoingJob_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_Restart_Proxy( 
    IFaxOutgoingJob * This);


void __RPC_STUB IFaxOutgoingJob_Restart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_CopyTiff_Proxy( 
    IFaxOutgoingJob * This,
    /* [in] */ BSTR bstrTiffPath);


void __RPC_STUB IFaxOutgoingJob_CopyTiff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_Refresh_Proxy( 
    IFaxOutgoingJob * This);


void __RPC_STUB IFaxOutgoingJob_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_Cancel_Proxy( 
    IFaxOutgoingJob * This);


void __RPC_STUB IFaxOutgoingJob_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutgoingJob_INTERFACE_DEFINED__ */


#ifndef __IFaxOutgoingMessageIterator_INTERFACE_DEFINED__
#define __IFaxOutgoingMessageIterator_INTERFACE_DEFINED__

/* interface IFaxOutgoingMessageIterator */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxOutgoingMessageIterator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F5EC5D4F-B840-432F-9980-112FE42A9B7A")
    IFaxOutgoingMessageIterator : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Message( 
            /* [retval][out] */ IFaxOutgoingMessage **pFaxOutgoingMessage) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AtEOF( 
            /* [retval][out] */ VARIANT_BOOL *pbEOF) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PrefetchSize( 
            /* [retval][out] */ long *plPrefetchSize) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PrefetchSize( 
            /* [in] */ long lPrefetchSize) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveFirst( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveNext( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutgoingMessageIteratorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutgoingMessageIterator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutgoingMessageIterator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutgoingMessageIterator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutgoingMessageIterator * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutgoingMessageIterator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutgoingMessageIterator * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutgoingMessageIterator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Message )( 
            IFaxOutgoingMessageIterator * This,
            /* [retval][out] */ IFaxOutgoingMessage **pFaxOutgoingMessage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AtEOF )( 
            IFaxOutgoingMessageIterator * This,
            /* [retval][out] */ VARIANT_BOOL *pbEOF);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrefetchSize )( 
            IFaxOutgoingMessageIterator * This,
            /* [retval][out] */ long *plPrefetchSize);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrefetchSize )( 
            IFaxOutgoingMessageIterator * This,
            /* [in] */ long lPrefetchSize);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MoveFirst )( 
            IFaxOutgoingMessageIterator * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MoveNext )( 
            IFaxOutgoingMessageIterator * This);
        
        END_INTERFACE
    } IFaxOutgoingMessageIteratorVtbl;

    interface IFaxOutgoingMessageIterator
    {
        CONST_VTBL struct IFaxOutgoingMessageIteratorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutgoingMessageIterator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutgoingMessageIterator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutgoingMessageIterator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutgoingMessageIterator_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutgoingMessageIterator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutgoingMessageIterator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutgoingMessageIterator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutgoingMessageIterator_get_Message(This,pFaxOutgoingMessage)	\
    (This)->lpVtbl -> get_Message(This,pFaxOutgoingMessage)

#define IFaxOutgoingMessageIterator_get_AtEOF(This,pbEOF)	\
    (This)->lpVtbl -> get_AtEOF(This,pbEOF)

#define IFaxOutgoingMessageIterator_get_PrefetchSize(This,plPrefetchSize)	\
    (This)->lpVtbl -> get_PrefetchSize(This,plPrefetchSize)

#define IFaxOutgoingMessageIterator_put_PrefetchSize(This,lPrefetchSize)	\
    (This)->lpVtbl -> put_PrefetchSize(This,lPrefetchSize)

#define IFaxOutgoingMessageIterator_MoveFirst(This)	\
    (This)->lpVtbl -> MoveFirst(This)

#define IFaxOutgoingMessageIterator_MoveNext(This)	\
    (This)->lpVtbl -> MoveNext(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessageIterator_get_Message_Proxy( 
    IFaxOutgoingMessageIterator * This,
    /* [retval][out] */ IFaxOutgoingMessage **pFaxOutgoingMessage);


void __RPC_STUB IFaxOutgoingMessageIterator_get_Message_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessageIterator_get_AtEOF_Proxy( 
    IFaxOutgoingMessageIterator * This,
    /* [retval][out] */ VARIANT_BOOL *pbEOF);


void __RPC_STUB IFaxOutgoingMessageIterator_get_AtEOF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessageIterator_get_PrefetchSize_Proxy( 
    IFaxOutgoingMessageIterator * This,
    /* [retval][out] */ long *plPrefetchSize);


void __RPC_STUB IFaxOutgoingMessageIterator_get_PrefetchSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessageIterator_put_PrefetchSize_Proxy( 
    IFaxOutgoingMessageIterator * This,
    /* [in] */ long lPrefetchSize);


void __RPC_STUB IFaxOutgoingMessageIterator_put_PrefetchSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessageIterator_MoveFirst_Proxy( 
    IFaxOutgoingMessageIterator * This);


void __RPC_STUB IFaxOutgoingMessageIterator_MoveFirst_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessageIterator_MoveNext_Proxy( 
    IFaxOutgoingMessageIterator * This);


void __RPC_STUB IFaxOutgoingMessageIterator_MoveNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutgoingMessageIterator_INTERFACE_DEFINED__ */


#ifndef __IFaxOutgoingMessage_INTERFACE_DEFINED__
#define __IFaxOutgoingMessage_INTERFACE_DEFINED__

/* interface IFaxOutgoingMessage */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxOutgoingMessage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F0EA35DE-CAA5-4A7C-82C7-2B60BA5F2BE2")
    IFaxOutgoingMessage : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubmissionId( 
            /* [retval][out] */ BSTR *pbstrSubmissionId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ BSTR *pbstrId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Subject( 
            /* [retval][out] */ BSTR *pbstrSubject) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DocumentName( 
            /* [retval][out] */ BSTR *pbstrDocumentName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Retries( 
            /* [retval][out] */ long *plRetries) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Pages( 
            /* [retval][out] */ long *plPages) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ long *plSize) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OriginalScheduledTime( 
            /* [retval][out] */ DATE *pdateOriginalScheduledTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubmissionTime( 
            /* [retval][out] */ DATE *pdateSubmissionTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ FAX_PRIORITY_TYPE_ENUM *pPriority) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Sender( 
            /* [retval][out] */ IFaxSender **ppFaxSender) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Recipient( 
            /* [retval][out] */ IFaxRecipient **ppFaxRecipient) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceName( 
            /* [retval][out] */ BSTR *pbstrDeviceName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionStart( 
            /* [retval][out] */ DATE *pdateTransmissionStart) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionEnd( 
            /* [retval][out] */ DATE *pdateTransmissionEnd) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CSID( 
            /* [retval][out] */ BSTR *pbstrCSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TSID( 
            /* [retval][out] */ BSTR *pbstrTSID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyTiff( 
            /* [in] */ BSTR bstrTiffPath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutgoingMessageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutgoingMessage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutgoingMessage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutgoingMessage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutgoingMessage * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutgoingMessage * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutgoingMessage * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutgoingMessage * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubmissionId )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ BSTR *pbstrSubmissionId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ BSTR *pbstrId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Subject )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ BSTR *pbstrSubject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocumentName )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ BSTR *pbstrDocumentName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Retries )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ long *plRetries);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Pages )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ long *plPages);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ long *plSize);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OriginalScheduledTime )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ DATE *pdateOriginalScheduledTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubmissionTime )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ DATE *pdateSubmissionTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ FAX_PRIORITY_TYPE_ENUM *pPriority);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Sender )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ IFaxSender **ppFaxSender);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Recipient )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ IFaxRecipient **ppFaxRecipient);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceName )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ BSTR *pbstrDeviceName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionStart )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ DATE *pdateTransmissionStart);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionEnd )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ DATE *pdateTransmissionEnd);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CSID )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ BSTR *pbstrCSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TSID )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ BSTR *pbstrTSID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyTiff )( 
            IFaxOutgoingMessage * This,
            /* [in] */ BSTR bstrTiffPath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IFaxOutgoingMessage * This);
        
        END_INTERFACE
    } IFaxOutgoingMessageVtbl;

    interface IFaxOutgoingMessage
    {
        CONST_VTBL struct IFaxOutgoingMessageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutgoingMessage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutgoingMessage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutgoingMessage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutgoingMessage_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutgoingMessage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutgoingMessage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutgoingMessage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutgoingMessage_get_SubmissionId(This,pbstrSubmissionId)	\
    (This)->lpVtbl -> get_SubmissionId(This,pbstrSubmissionId)

#define IFaxOutgoingMessage_get_Id(This,pbstrId)	\
    (This)->lpVtbl -> get_Id(This,pbstrId)

#define IFaxOutgoingMessage_get_Subject(This,pbstrSubject)	\
    (This)->lpVtbl -> get_Subject(This,pbstrSubject)

#define IFaxOutgoingMessage_get_DocumentName(This,pbstrDocumentName)	\
    (This)->lpVtbl -> get_DocumentName(This,pbstrDocumentName)

#define IFaxOutgoingMessage_get_Retries(This,plRetries)	\
    (This)->lpVtbl -> get_Retries(This,plRetries)

#define IFaxOutgoingMessage_get_Pages(This,plPages)	\
    (This)->lpVtbl -> get_Pages(This,plPages)

#define IFaxOutgoingMessage_get_Size(This,plSize)	\
    (This)->lpVtbl -> get_Size(This,plSize)

#define IFaxOutgoingMessage_get_OriginalScheduledTime(This,pdateOriginalScheduledTime)	\
    (This)->lpVtbl -> get_OriginalScheduledTime(This,pdateOriginalScheduledTime)

#define IFaxOutgoingMessage_get_SubmissionTime(This,pdateSubmissionTime)	\
    (This)->lpVtbl -> get_SubmissionTime(This,pdateSubmissionTime)

#define IFaxOutgoingMessage_get_Priority(This,pPriority)	\
    (This)->lpVtbl -> get_Priority(This,pPriority)

#define IFaxOutgoingMessage_get_Sender(This,ppFaxSender)	\
    (This)->lpVtbl -> get_Sender(This,ppFaxSender)

#define IFaxOutgoingMessage_get_Recipient(This,ppFaxRecipient)	\
    (This)->lpVtbl -> get_Recipient(This,ppFaxRecipient)

#define IFaxOutgoingMessage_get_DeviceName(This,pbstrDeviceName)	\
    (This)->lpVtbl -> get_DeviceName(This,pbstrDeviceName)

#define IFaxOutgoingMessage_get_TransmissionStart(This,pdateTransmissionStart)	\
    (This)->lpVtbl -> get_TransmissionStart(This,pdateTransmissionStart)

#define IFaxOutgoingMessage_get_TransmissionEnd(This,pdateTransmissionEnd)	\
    (This)->lpVtbl -> get_TransmissionEnd(This,pdateTransmissionEnd)

#define IFaxOutgoingMessage_get_CSID(This,pbstrCSID)	\
    (This)->lpVtbl -> get_CSID(This,pbstrCSID)

#define IFaxOutgoingMessage_get_TSID(This,pbstrTSID)	\
    (This)->lpVtbl -> get_TSID(This,pbstrTSID)

#define IFaxOutgoingMessage_CopyTiff(This,bstrTiffPath)	\
    (This)->lpVtbl -> CopyTiff(This,bstrTiffPath)

#define IFaxOutgoingMessage_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_SubmissionId_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ BSTR *pbstrSubmissionId);


void __RPC_STUB IFaxOutgoingMessage_get_SubmissionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_Id_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ BSTR *pbstrId);


void __RPC_STUB IFaxOutgoingMessage_get_Id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_Subject_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ BSTR *pbstrSubject);


void __RPC_STUB IFaxOutgoingMessage_get_Subject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_DocumentName_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ BSTR *pbstrDocumentName);


void __RPC_STUB IFaxOutgoingMessage_get_DocumentName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_Retries_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ long *plRetries);


void __RPC_STUB IFaxOutgoingMessage_get_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_Pages_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ long *plPages);


void __RPC_STUB IFaxOutgoingMessage_get_Pages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_Size_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ long *plSize);


void __RPC_STUB IFaxOutgoingMessage_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_OriginalScheduledTime_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ DATE *pdateOriginalScheduledTime);


void __RPC_STUB IFaxOutgoingMessage_get_OriginalScheduledTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_SubmissionTime_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ DATE *pdateSubmissionTime);


void __RPC_STUB IFaxOutgoingMessage_get_SubmissionTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_Priority_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ FAX_PRIORITY_TYPE_ENUM *pPriority);


void __RPC_STUB IFaxOutgoingMessage_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_Sender_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ IFaxSender **ppFaxSender);


void __RPC_STUB IFaxOutgoingMessage_get_Sender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_Recipient_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ IFaxRecipient **ppFaxRecipient);


void __RPC_STUB IFaxOutgoingMessage_get_Recipient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_DeviceName_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ BSTR *pbstrDeviceName);


void __RPC_STUB IFaxOutgoingMessage_get_DeviceName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_TransmissionStart_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ DATE *pdateTransmissionStart);


void __RPC_STUB IFaxOutgoingMessage_get_TransmissionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_TransmissionEnd_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ DATE *pdateTransmissionEnd);


void __RPC_STUB IFaxOutgoingMessage_get_TransmissionEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_CSID_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ BSTR *pbstrCSID);


void __RPC_STUB IFaxOutgoingMessage_get_CSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_TSID_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ BSTR *pbstrTSID);


void __RPC_STUB IFaxOutgoingMessage_get_TSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_CopyTiff_Proxy( 
    IFaxOutgoingMessage * This,
    /* [in] */ BSTR bstrTiffPath);


void __RPC_STUB IFaxOutgoingMessage_CopyTiff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_Delete_Proxy( 
    IFaxOutgoingMessage * This);


void __RPC_STUB IFaxOutgoingMessage_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutgoingMessage_INTERFACE_DEFINED__ */


#ifndef __IFaxIncomingJobs_INTERFACE_DEFINED__
#define __IFaxIncomingJobs_INTERFACE_DEFINED__

/* interface IFaxIncomingJobs */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxIncomingJobs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("011F04E9-4FD6-4C23-9513-B6B66BB26BE9")
    IFaxIncomingJobs : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxIncomingJob **pFaxIncomingJob) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxIncomingJobsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxIncomingJobs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxIncomingJobs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxIncomingJobs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxIncomingJobs * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxIncomingJobs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxIncomingJobs * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxIncomingJobs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxIncomingJobs * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxIncomingJobs * This,
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxIncomingJob **pFaxIncomingJob);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxIncomingJobs * This,
            /* [retval][out] */ long *plCount);
        
        END_INTERFACE
    } IFaxIncomingJobsVtbl;

    interface IFaxIncomingJobs
    {
        CONST_VTBL struct IFaxIncomingJobsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxIncomingJobs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxIncomingJobs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxIncomingJobs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxIncomingJobs_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxIncomingJobs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxIncomingJobs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxIncomingJobs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxIncomingJobs_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxIncomingJobs_get_Item(This,vIndex,pFaxIncomingJob)	\
    (This)->lpVtbl -> get_Item(This,vIndex,pFaxIncomingJob)

#define IFaxIncomingJobs_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJobs_get__NewEnum_Proxy( 
    IFaxIncomingJobs * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxIncomingJobs_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJobs_get_Item_Proxy( 
    IFaxIncomingJobs * This,
    /* [in] */ VARIANT vIndex,
    /* [retval][out] */ IFaxIncomingJob **pFaxIncomingJob);


void __RPC_STUB IFaxIncomingJobs_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJobs_get_Count_Proxy( 
    IFaxIncomingJobs * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxIncomingJobs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxIncomingJobs_INTERFACE_DEFINED__ */


#ifndef __IFaxIncomingJob_INTERFACE_DEFINED__
#define __IFaxIncomingJob_INTERFACE_DEFINED__

/* interface IFaxIncomingJob */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxIncomingJob;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("207529E6-654A-4916-9F88-4D232EE8A107")
    IFaxIncomingJob : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ long *plSize) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ BSTR *pbstrId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPage( 
            /* [retval][out] */ long *plCurrentPage) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceId( 
            /* [retval][out] */ long *plDeviceId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ FAX_JOB_STATUS_ENUM *pStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtendedStatusCode( 
            /* [retval][out] */ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtendedStatus( 
            /* [retval][out] */ BSTR *pbstrExtendedStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AvailableOperations( 
            /* [retval][out] */ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Retries( 
            /* [retval][out] */ long *plRetries) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionStart( 
            /* [retval][out] */ DATE *pdateTransmissionStart) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionEnd( 
            /* [retval][out] */ DATE *pdateTransmissionEnd) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CSID( 
            /* [retval][out] */ BSTR *pbstrCSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TSID( 
            /* [retval][out] */ BSTR *pbstrTSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallerId( 
            /* [retval][out] */ BSTR *pbstrCallerId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RoutingInformation( 
            /* [retval][out] */ BSTR *pbstrRoutingInformation) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_JobType( 
            /* [retval][out] */ FAX_JOB_TYPE_ENUM *pJobType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyTiff( 
            /* [in] */ BSTR bstrTiffPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxIncomingJobVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxIncomingJob * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxIncomingJob * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxIncomingJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxIncomingJob * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxIncomingJob * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxIncomingJob * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxIncomingJob * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ long *plSize);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ BSTR *pbstrId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPage )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ long *plCurrentPage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceId )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ long *plDeviceId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ FAX_JOB_STATUS_ENUM *pStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtendedStatusCode )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtendedStatus )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ BSTR *pbstrExtendedStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvailableOperations )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Retries )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ long *plRetries);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionStart )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ DATE *pdateTransmissionStart);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionEnd )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ DATE *pdateTransmissionEnd);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CSID )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ BSTR *pbstrCSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TSID )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ BSTR *pbstrTSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallerId )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ BSTR *pbstrCallerId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RoutingInformation )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ BSTR *pbstrRoutingInformation);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_JobType )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ FAX_JOB_TYPE_ENUM *pJobType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IFaxIncomingJob * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxIncomingJob * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyTiff )( 
            IFaxIncomingJob * This,
            /* [in] */ BSTR bstrTiffPath);
        
        END_INTERFACE
    } IFaxIncomingJobVtbl;

    interface IFaxIncomingJob
    {
        CONST_VTBL struct IFaxIncomingJobVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxIncomingJob_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxIncomingJob_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxIncomingJob_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxIncomingJob_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxIncomingJob_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxIncomingJob_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxIncomingJob_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxIncomingJob_get_Size(This,plSize)	\
    (This)->lpVtbl -> get_Size(This,plSize)

#define IFaxIncomingJob_get_Id(This,pbstrId)	\
    (This)->lpVtbl -> get_Id(This,pbstrId)

#define IFaxIncomingJob_get_CurrentPage(This,plCurrentPage)	\
    (This)->lpVtbl -> get_CurrentPage(This,plCurrentPage)

#define IFaxIncomingJob_get_DeviceId(This,plDeviceId)	\
    (This)->lpVtbl -> get_DeviceId(This,plDeviceId)

#define IFaxIncomingJob_get_Status(This,pStatus)	\
    (This)->lpVtbl -> get_Status(This,pStatus)

#define IFaxIncomingJob_get_ExtendedStatusCode(This,pExtendedStatusCode)	\
    (This)->lpVtbl -> get_ExtendedStatusCode(This,pExtendedStatusCode)

#define IFaxIncomingJob_get_ExtendedStatus(This,pbstrExtendedStatus)	\
    (This)->lpVtbl -> get_ExtendedStatus(This,pbstrExtendedStatus)

#define IFaxIncomingJob_get_AvailableOperations(This,pAvailableOperations)	\
    (This)->lpVtbl -> get_AvailableOperations(This,pAvailableOperations)

#define IFaxIncomingJob_get_Retries(This,plRetries)	\
    (This)->lpVtbl -> get_Retries(This,plRetries)

#define IFaxIncomingJob_get_TransmissionStart(This,pdateTransmissionStart)	\
    (This)->lpVtbl -> get_TransmissionStart(This,pdateTransmissionStart)

#define IFaxIncomingJob_get_TransmissionEnd(This,pdateTransmissionEnd)	\
    (This)->lpVtbl -> get_TransmissionEnd(This,pdateTransmissionEnd)

#define IFaxIncomingJob_get_CSID(This,pbstrCSID)	\
    (This)->lpVtbl -> get_CSID(This,pbstrCSID)

#define IFaxIncomingJob_get_TSID(This,pbstrTSID)	\
    (This)->lpVtbl -> get_TSID(This,pbstrTSID)

#define IFaxIncomingJob_get_CallerId(This,pbstrCallerId)	\
    (This)->lpVtbl -> get_CallerId(This,pbstrCallerId)

#define IFaxIncomingJob_get_RoutingInformation(This,pbstrRoutingInformation)	\
    (This)->lpVtbl -> get_RoutingInformation(This,pbstrRoutingInformation)

#define IFaxIncomingJob_get_JobType(This,pJobType)	\
    (This)->lpVtbl -> get_JobType(This,pJobType)

#define IFaxIncomingJob_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#define IFaxIncomingJob_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxIncomingJob_CopyTiff(This,bstrTiffPath)	\
    (This)->lpVtbl -> CopyTiff(This,bstrTiffPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_Size_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ long *plSize);


void __RPC_STUB IFaxIncomingJob_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_Id_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ BSTR *pbstrId);


void __RPC_STUB IFaxIncomingJob_get_Id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_CurrentPage_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ long *plCurrentPage);


void __RPC_STUB IFaxIncomingJob_get_CurrentPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_DeviceId_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ long *plDeviceId);


void __RPC_STUB IFaxIncomingJob_get_DeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_Status_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ FAX_JOB_STATUS_ENUM *pStatus);


void __RPC_STUB IFaxIncomingJob_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_ExtendedStatusCode_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode);


void __RPC_STUB IFaxIncomingJob_get_ExtendedStatusCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_ExtendedStatus_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ BSTR *pbstrExtendedStatus);


void __RPC_STUB IFaxIncomingJob_get_ExtendedStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_AvailableOperations_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations);


void __RPC_STUB IFaxIncomingJob_get_AvailableOperations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_Retries_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ long *plRetries);


void __RPC_STUB IFaxIncomingJob_get_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_TransmissionStart_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ DATE *pdateTransmissionStart);


void __RPC_STUB IFaxIncomingJob_get_TransmissionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_TransmissionEnd_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ DATE *pdateTransmissionEnd);


void __RPC_STUB IFaxIncomingJob_get_TransmissionEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_CSID_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ BSTR *pbstrCSID);


void __RPC_STUB IFaxIncomingJob_get_CSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_TSID_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ BSTR *pbstrTSID);


void __RPC_STUB IFaxIncomingJob_get_TSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_CallerId_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ BSTR *pbstrCallerId);


void __RPC_STUB IFaxIncomingJob_get_CallerId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_RoutingInformation_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ BSTR *pbstrRoutingInformation);


void __RPC_STUB IFaxIncomingJob_get_RoutingInformation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_JobType_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ FAX_JOB_TYPE_ENUM *pJobType);


void __RPC_STUB IFaxIncomingJob_get_JobType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_Cancel_Proxy( 
    IFaxIncomingJob * This);


void __RPC_STUB IFaxIncomingJob_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_Refresh_Proxy( 
    IFaxIncomingJob * This);


void __RPC_STUB IFaxIncomingJob_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_CopyTiff_Proxy( 
    IFaxIncomingJob * This,
    /* [in] */ BSTR bstrTiffPath);


void __RPC_STUB IFaxIncomingJob_CopyTiff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxIncomingJob_INTERFACE_DEFINED__ */


#ifndef __IFaxDeviceProvider_INTERFACE_DEFINED__
#define __IFaxDeviceProvider_INTERFACE_DEFINED__

/* interface IFaxDeviceProvider */
/* [unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_PROVIDER_STATUS_ENUM
    {	fpsSUCCESS	= 0,
	fpsSERVER_ERROR	= fpsSUCCESS + 1,
	fpsBAD_GUID	= fpsSERVER_ERROR + 1,
	fpsBAD_VERSION	= fpsBAD_GUID + 1,
	fpsCANT_LOAD	= fpsBAD_VERSION + 1,
	fpsCANT_LINK	= fpsCANT_LOAD + 1,
	fpsCANT_INIT	= fpsCANT_LINK + 1
    } 	FAX_PROVIDER_STATUS_ENUM;


EXTERN_C const IID IID_IFaxDeviceProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("290EAC63-83EC-449C-8417-F148DF8C682A")
    IFaxDeviceProvider : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FriendlyName( 
            /* [retval][out] */ BSTR *pbstrFriendlyName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImageName( 
            /* [retval][out] */ BSTR *pbstrImageName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UniqueName( 
            /* [retval][out] */ BSTR *pbstrUniqueName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TapiProviderName( 
            /* [retval][out] */ BSTR *pbstrTapiProviderName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorVersion( 
            /* [retval][out] */ long *plMajorVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorVersion( 
            /* [retval][out] */ long *plMinorVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorBuild( 
            /* [retval][out] */ long *plMajorBuild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorBuild( 
            /* [retval][out] */ long *plMinorBuild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Debug( 
            /* [retval][out] */ VARIANT_BOOL *pbDebug) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ FAX_PROVIDER_STATUS_ENUM *pStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InitErrorCode( 
            /* [retval][out] */ long *plInitErrorCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceIds( 
            /* [retval][out] */ VARIANT *pvDeviceIds) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxDeviceProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxDeviceProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxDeviceProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxDeviceProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxDeviceProvider * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxDeviceProvider * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxDeviceProvider * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxDeviceProvider * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ BSTR *pbstrFriendlyName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImageName )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ BSTR *pbstrImageName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UniqueName )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ BSTR *pbstrUniqueName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TapiProviderName )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ BSTR *pbstrTapiProviderName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MajorVersion )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ long *plMajorVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorVersion )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ long *plMinorVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MajorBuild )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ long *plMajorBuild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorBuild )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ long *plMinorBuild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Debug )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ VARIANT_BOOL *pbDebug);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ FAX_PROVIDER_STATUS_ENUM *pStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InitErrorCode )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ long *plInitErrorCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceIds )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ VARIANT *pvDeviceIds);
        
        END_INTERFACE
    } IFaxDeviceProviderVtbl;

    interface IFaxDeviceProvider
    {
        CONST_VTBL struct IFaxDeviceProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxDeviceProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxDeviceProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxDeviceProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxDeviceProvider_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxDeviceProvider_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxDeviceProvider_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxDeviceProvider_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxDeviceProvider_get_FriendlyName(This,pbstrFriendlyName)	\
    (This)->lpVtbl -> get_FriendlyName(This,pbstrFriendlyName)

#define IFaxDeviceProvider_get_ImageName(This,pbstrImageName)	\
    (This)->lpVtbl -> get_ImageName(This,pbstrImageName)

#define IFaxDeviceProvider_get_UniqueName(This,pbstrUniqueName)	\
    (This)->lpVtbl -> get_UniqueName(This,pbstrUniqueName)

#define IFaxDeviceProvider_get_TapiProviderName(This,pbstrTapiProviderName)	\
    (This)->lpVtbl -> get_TapiProviderName(This,pbstrTapiProviderName)

#define IFaxDeviceProvider_get_MajorVersion(This,plMajorVersion)	\
    (This)->lpVtbl -> get_MajorVersion(This,plMajorVersion)

#define IFaxDeviceProvider_get_MinorVersion(This,plMinorVersion)	\
    (This)->lpVtbl -> get_MinorVersion(This,plMinorVersion)

#define IFaxDeviceProvider_get_MajorBuild(This,plMajorBuild)	\
    (This)->lpVtbl -> get_MajorBuild(This,plMajorBuild)

#define IFaxDeviceProvider_get_MinorBuild(This,plMinorBuild)	\
    (This)->lpVtbl -> get_MinorBuild(This,plMinorBuild)

#define IFaxDeviceProvider_get_Debug(This,pbDebug)	\
    (This)->lpVtbl -> get_Debug(This,pbDebug)

#define IFaxDeviceProvider_get_Status(This,pStatus)	\
    (This)->lpVtbl -> get_Status(This,pStatus)

#define IFaxDeviceProvider_get_InitErrorCode(This,plInitErrorCode)	\
    (This)->lpVtbl -> get_InitErrorCode(This,plInitErrorCode)

#define IFaxDeviceProvider_get_DeviceIds(This,pvDeviceIds)	\
    (This)->lpVtbl -> get_DeviceIds(This,pvDeviceIds)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_FriendlyName_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ BSTR *pbstrFriendlyName);


void __RPC_STUB IFaxDeviceProvider_get_FriendlyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_ImageName_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ BSTR *pbstrImageName);


void __RPC_STUB IFaxDeviceProvider_get_ImageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_UniqueName_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ BSTR *pbstrUniqueName);


void __RPC_STUB IFaxDeviceProvider_get_UniqueName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_TapiProviderName_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ BSTR *pbstrTapiProviderName);


void __RPC_STUB IFaxDeviceProvider_get_TapiProviderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_MajorVersion_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ long *plMajorVersion);


void __RPC_STUB IFaxDeviceProvider_get_MajorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_MinorVersion_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ long *plMinorVersion);


void __RPC_STUB IFaxDeviceProvider_get_MinorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_MajorBuild_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ long *plMajorBuild);


void __RPC_STUB IFaxDeviceProvider_get_MajorBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_MinorBuild_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ long *plMinorBuild);


void __RPC_STUB IFaxDeviceProvider_get_MinorBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_Debug_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ VARIANT_BOOL *pbDebug);


void __RPC_STUB IFaxDeviceProvider_get_Debug_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_Status_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ FAX_PROVIDER_STATUS_ENUM *pStatus);


void __RPC_STUB IFaxDeviceProvider_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_InitErrorCode_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ long *plInitErrorCode);


void __RPC_STUB IFaxDeviceProvider_get_InitErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_DeviceIds_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ VARIANT *pvDeviceIds);


void __RPC_STUB IFaxDeviceProvider_get_DeviceIds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxDeviceProvider_INTERFACE_DEFINED__ */


#ifndef __IFaxDevice_INTERFACE_DEFINED__
#define __IFaxDevice_INTERFACE_DEFINED__

/* interface IFaxDevice */
/* [unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_DEVICE_RECEIVE_MODE_ENUM
    {	fdrmNO_ANSWER	= 0,
	fdrmAUTO_ANSWER	= fdrmNO_ANSWER + 1,
	fdrmMANUAL_ANSWER	= fdrmAUTO_ANSWER + 1
    } 	FAX_DEVICE_RECEIVE_MODE_ENUM;


EXTERN_C const IID IID_IFaxDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49306C59-B52E-4867-9DF4-CA5841C956D0")
    IFaxDevice : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ long *plId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceName( 
            /* [retval][out] */ BSTR *pbstrDeviceName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProviderUniqueName( 
            /* [retval][out] */ BSTR *pbstrProviderUniqueName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PoweredOff( 
            /* [retval][out] */ VARIANT_BOOL *pbPoweredOff) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReceivingNow( 
            /* [retval][out] */ VARIANT_BOOL *pbReceivingNow) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SendingNow( 
            /* [retval][out] */ VARIANT_BOOL *pbSendingNow) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UsedRoutingMethods( 
            /* [retval][out] */ VARIANT *pvUsedRoutingMethods) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *pbstrDescription) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR bstrDescription) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SendEnabled( 
            /* [retval][out] */ VARIANT_BOOL *pbSendEnabled) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SendEnabled( 
            /* [in] */ VARIANT_BOOL bSendEnabled) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReceiveMode( 
            /* [retval][out] */ FAX_DEVICE_RECEIVE_MODE_ENUM *pReceiveMode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ReceiveMode( 
            /* [in] */ FAX_DEVICE_RECEIVE_MODE_ENUM ReceiveMode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RingsBeforeAnswer( 
            /* [retval][out] */ long *plRingsBeforeAnswer) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RingsBeforeAnswer( 
            /* [in] */ long lRingsBeforeAnswer) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CSID( 
            /* [retval][out] */ BSTR *pbstrCSID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CSID( 
            /* [in] */ BSTR bstrCSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TSID( 
            /* [retval][out] */ BSTR *pbstrTSID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TSID( 
            /* [in] */ BSTR bstrTSID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetExtensionProperty( 
            /* [in] */ BSTR bstrGUID,
            /* [retval][out] */ VARIANT *pvProperty) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetExtensionProperty( 
            /* [in] */ BSTR bstrGUID,
            /* [in] */ VARIANT vProperty) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UseRoutingMethod( 
            /* [in] */ BSTR bstrMethodGUID,
            /* [in] */ VARIANT_BOOL bUse) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RingingNow( 
            /* [retval][out] */ VARIANT_BOOL *pbRingingNow) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AnswerCall( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxDevice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxDevice * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxDevice * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxDevice * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxDevice * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            IFaxDevice * This,
            /* [retval][out] */ long *plId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceName )( 
            IFaxDevice * This,
            /* [retval][out] */ BSTR *pbstrDeviceName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderUniqueName )( 
            IFaxDevice * This,
            /* [retval][out] */ BSTR *pbstrProviderUniqueName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PoweredOff )( 
            IFaxDevice * This,
            /* [retval][out] */ VARIANT_BOOL *pbPoweredOff);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReceivingNow )( 
            IFaxDevice * This,
            /* [retval][out] */ VARIANT_BOOL *pbReceivingNow);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SendingNow )( 
            IFaxDevice * This,
            /* [retval][out] */ VARIANT_BOOL *pbSendingNow);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UsedRoutingMethods )( 
            IFaxDevice * This,
            /* [retval][out] */ VARIANT *pvUsedRoutingMethods);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IFaxDevice * This,
            /* [retval][out] */ BSTR *pbstrDescription);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IFaxDevice * This,
            /* [in] */ BSTR bstrDescription);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SendEnabled )( 
            IFaxDevice * This,
            /* [retval][out] */ VARIANT_BOOL *pbSendEnabled);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SendEnabled )( 
            IFaxDevice * This,
            /* [in] */ VARIANT_BOOL bSendEnabled);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReceiveMode )( 
            IFaxDevice * This,
            /* [retval][out] */ FAX_DEVICE_RECEIVE_MODE_ENUM *pReceiveMode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReceiveMode )( 
            IFaxDevice * This,
            /* [in] */ FAX_DEVICE_RECEIVE_MODE_ENUM ReceiveMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RingsBeforeAnswer )( 
            IFaxDevice * This,
            /* [retval][out] */ long *plRingsBeforeAnswer);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RingsBeforeAnswer )( 
            IFaxDevice * This,
            /* [in] */ long lRingsBeforeAnswer);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CSID )( 
            IFaxDevice * This,
            /* [retval][out] */ BSTR *pbstrCSID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CSID )( 
            IFaxDevice * This,
            /* [in] */ BSTR bstrCSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TSID )( 
            IFaxDevice * This,
            /* [retval][out] */ BSTR *pbstrTSID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TSID )( 
            IFaxDevice * This,
            /* [in] */ BSTR bstrTSID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxDevice * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxDevice * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetExtensionProperty )( 
            IFaxDevice * This,
            /* [in] */ BSTR bstrGUID,
            /* [retval][out] */ VARIANT *pvProperty);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetExtensionProperty )( 
            IFaxDevice * This,
            /* [in] */ BSTR bstrGUID,
            /* [in] */ VARIANT vProperty);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UseRoutingMethod )( 
            IFaxDevice * This,
            /* [in] */ BSTR bstrMethodGUID,
            /* [in] */ VARIANT_BOOL bUse);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RingingNow )( 
            IFaxDevice * This,
            /* [retval][out] */ VARIANT_BOOL *pbRingingNow);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AnswerCall )( 
            IFaxDevice * This);
        
        END_INTERFACE
    } IFaxDeviceVtbl;

    interface IFaxDevice
    {
        CONST_VTBL struct IFaxDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxDevice_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxDevice_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxDevice_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxDevice_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxDevice_get_Id(This,plId)	\
    (This)->lpVtbl -> get_Id(This,plId)

#define IFaxDevice_get_DeviceName(This,pbstrDeviceName)	\
    (This)->lpVtbl -> get_DeviceName(This,pbstrDeviceName)

#define IFaxDevice_get_ProviderUniqueName(This,pbstrProviderUniqueName)	\
    (This)->lpVtbl -> get_ProviderUniqueName(This,pbstrProviderUniqueName)

#define IFaxDevice_get_PoweredOff(This,pbPoweredOff)	\
    (This)->lpVtbl -> get_PoweredOff(This,pbPoweredOff)

#define IFaxDevice_get_ReceivingNow(This,pbReceivingNow)	\
    (This)->lpVtbl -> get_ReceivingNow(This,pbReceivingNow)

#define IFaxDevice_get_SendingNow(This,pbSendingNow)	\
    (This)->lpVtbl -> get_SendingNow(This,pbSendingNow)

#define IFaxDevice_get_UsedRoutingMethods(This,pvUsedRoutingMethods)	\
    (This)->lpVtbl -> get_UsedRoutingMethods(This,pvUsedRoutingMethods)

#define IFaxDevice_get_Description(This,pbstrDescription)	\
    (This)->lpVtbl -> get_Description(This,pbstrDescription)

#define IFaxDevice_put_Description(This,bstrDescription)	\
    (This)->lpVtbl -> put_Description(This,bstrDescription)

#define IFaxDevice_get_SendEnabled(This,pbSendEnabled)	\
    (This)->lpVtbl -> get_SendEnabled(This,pbSendEnabled)

#define IFaxDevice_put_SendEnabled(This,bSendEnabled)	\
    (This)->lpVtbl -> put_SendEnabled(This,bSendEnabled)

#define IFaxDevice_get_ReceiveMode(This,pReceiveMode)	\
    (This)->lpVtbl -> get_ReceiveMode(This,pReceiveMode)

#define IFaxDevice_put_ReceiveMode(This,ReceiveMode)	\
    (This)->lpVtbl -> put_ReceiveMode(This,ReceiveMode)

#define IFaxDevice_get_RingsBeforeAnswer(This,plRingsBeforeAnswer)	\
    (This)->lpVtbl -> get_RingsBeforeAnswer(This,plRingsBeforeAnswer)

#define IFaxDevice_put_RingsBeforeAnswer(This,lRingsBeforeAnswer)	\
    (This)->lpVtbl -> put_RingsBeforeAnswer(This,lRingsBeforeAnswer)

#define IFaxDevice_get_CSID(This,pbstrCSID)	\
    (This)->lpVtbl -> get_CSID(This,pbstrCSID)

#define IFaxDevice_put_CSID(This,bstrCSID)	\
    (This)->lpVtbl -> put_CSID(This,bstrCSID)

#define IFaxDevice_get_TSID(This,pbstrTSID)	\
    (This)->lpVtbl -> get_TSID(This,pbstrTSID)

#define IFaxDevice_put_TSID(This,bstrTSID)	\
    (This)->lpVtbl -> put_TSID(This,bstrTSID)

#define IFaxDevice_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxDevice_Save(This)	\
    (This)->lpVtbl -> Save(This)

#define IFaxDevice_GetExtensionProperty(This,bstrGUID,pvProperty)	\
    (This)->lpVtbl -> GetExtensionProperty(This,bstrGUID,pvProperty)

#define IFaxDevice_SetExtensionProperty(This,bstrGUID,vProperty)	\
    (This)->lpVtbl -> SetExtensionProperty(This,bstrGUID,vProperty)

#define IFaxDevice_UseRoutingMethod(This,bstrMethodGUID,bUse)	\
    (This)->lpVtbl -> UseRoutingMethod(This,bstrMethodGUID,bUse)

#define IFaxDevice_get_RingingNow(This,pbRingingNow)	\
    (This)->lpVtbl -> get_RingingNow(This,pbRingingNow)

#define IFaxDevice_AnswerCall(This)	\
    (This)->lpVtbl -> AnswerCall(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_Id_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ long *plId);


void __RPC_STUB IFaxDevice_get_Id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_DeviceName_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ BSTR *pbstrDeviceName);


void __RPC_STUB IFaxDevice_get_DeviceName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_ProviderUniqueName_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ BSTR *pbstrProviderUniqueName);


void __RPC_STUB IFaxDevice_get_ProviderUniqueName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_PoweredOff_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ VARIANT_BOOL *pbPoweredOff);


void __RPC_STUB IFaxDevice_get_PoweredOff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_ReceivingNow_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ VARIANT_BOOL *pbReceivingNow);


void __RPC_STUB IFaxDevice_get_ReceivingNow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_SendingNow_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ VARIANT_BOOL *pbSendingNow);


void __RPC_STUB IFaxDevice_get_SendingNow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_UsedRoutingMethods_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ VARIANT *pvUsedRoutingMethods);


void __RPC_STUB IFaxDevice_get_UsedRoutingMethods_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_Description_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ BSTR *pbstrDescription);


void __RPC_STUB IFaxDevice_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDevice_put_Description_Proxy( 
    IFaxDevice * This,
    /* [in] */ BSTR bstrDescription);


void __RPC_STUB IFaxDevice_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_SendEnabled_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ VARIANT_BOOL *pbSendEnabled);


void __RPC_STUB IFaxDevice_get_SendEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDevice_put_SendEnabled_Proxy( 
    IFaxDevice * This,
    /* [in] */ VARIANT_BOOL bSendEnabled);


void __RPC_STUB IFaxDevice_put_SendEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_ReceiveMode_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ FAX_DEVICE_RECEIVE_MODE_ENUM *pReceiveMode);


void __RPC_STUB IFaxDevice_get_ReceiveMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDevice_put_ReceiveMode_Proxy( 
    IFaxDevice * This,
    /* [in] */ FAX_DEVICE_RECEIVE_MODE_ENUM ReceiveMode);


void __RPC_STUB IFaxDevice_put_ReceiveMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_RingsBeforeAnswer_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ long *plRingsBeforeAnswer);


void __RPC_STUB IFaxDevice_get_RingsBeforeAnswer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDevice_put_RingsBeforeAnswer_Proxy( 
    IFaxDevice * This,
    /* [in] */ long lRingsBeforeAnswer);


void __RPC_STUB IFaxDevice_put_RingsBeforeAnswer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_CSID_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ BSTR *pbstrCSID);


void __RPC_STUB IFaxDevice_get_CSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDevice_put_CSID_Proxy( 
    IFaxDevice * This,
    /* [in] */ BSTR bstrCSID);


void __RPC_STUB IFaxDevice_put_CSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_TSID_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ BSTR *pbstrTSID);


void __RPC_STUB IFaxDevice_get_TSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDevice_put_TSID_Proxy( 
    IFaxDevice * This,
    /* [in] */ BSTR bstrTSID);


void __RPC_STUB IFaxDevice_put_TSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDevice_Refresh_Proxy( 
    IFaxDevice * This);


void __RPC_STUB IFaxDevice_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDevice_Save_Proxy( 
    IFaxDevice * This);


void __RPC_STUB IFaxDevice_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDevice_GetExtensionProperty_Proxy( 
    IFaxDevice * This,
    /* [in] */ BSTR bstrGUID,
    /* [retval][out] */ VARIANT *pvProperty);


void __RPC_STUB IFaxDevice_GetExtensionProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDevice_SetExtensionProperty_Proxy( 
    IFaxDevice * This,
    /* [in] */ BSTR bstrGUID,
    /* [in] */ VARIANT vProperty);


void __RPC_STUB IFaxDevice_SetExtensionProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDevice_UseRoutingMethod_Proxy( 
    IFaxDevice * This,
    /* [in] */ BSTR bstrMethodGUID,
    /* [in] */ VARIANT_BOOL bUse);


void __RPC_STUB IFaxDevice_UseRoutingMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_RingingNow_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ VARIANT_BOOL *pbRingingNow);


void __RPC_STUB IFaxDevice_get_RingingNow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDevice_AnswerCall_Proxy( 
    IFaxDevice * This);


void __RPC_STUB IFaxDevice_AnswerCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxDevice_INTERFACE_DEFINED__ */


#ifndef __IFaxActivityLogging_INTERFACE_DEFINED__
#define __IFaxActivityLogging_INTERFACE_DEFINED__

/* interface IFaxActivityLogging */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxActivityLogging;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1E29078B-5A69-497B-9592-49B7E7FADDB5")
    IFaxActivityLogging : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LogIncoming( 
            /* [retval][out] */ VARIANT_BOOL *pbLogIncoming) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LogIncoming( 
            /* [in] */ VARIANT_BOOL bLogIncoming) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LogOutgoing( 
            /* [retval][out] */ VARIANT_BOOL *pbLogOutgoing) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LogOutgoing( 
            /* [in] */ VARIANT_BOOL bLogOutgoing) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DatabasePath( 
            /* [retval][out] */ BSTR *pbstrDatabasePath) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DatabasePath( 
            /* [in] */ BSTR bstrDatabasePath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxActivityLoggingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxActivityLogging * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxActivityLogging * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxActivityLogging * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxActivityLogging * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxActivityLogging * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxActivityLogging * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxActivityLogging * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogIncoming )( 
            IFaxActivityLogging * This,
            /* [retval][out] */ VARIANT_BOOL *pbLogIncoming);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogIncoming )( 
            IFaxActivityLogging * This,
            /* [in] */ VARIANT_BOOL bLogIncoming);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogOutgoing )( 
            IFaxActivityLogging * This,
            /* [retval][out] */ VARIANT_BOOL *pbLogOutgoing);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogOutgoing )( 
            IFaxActivityLogging * This,
            /* [in] */ VARIANT_BOOL bLogOutgoing);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DatabasePath )( 
            IFaxActivityLogging * This,
            /* [retval][out] */ BSTR *pbstrDatabasePath);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DatabasePath )( 
            IFaxActivityLogging * This,
            /* [in] */ BSTR bstrDatabasePath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxActivityLogging * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxActivityLogging * This);
        
        END_INTERFACE
    } IFaxActivityLoggingVtbl;

    interface IFaxActivityLogging
    {
        CONST_VTBL struct IFaxActivityLoggingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxActivityLogging_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxActivityLogging_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxActivityLogging_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxActivityLogging_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxActivityLogging_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxActivityLogging_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxActivityLogging_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxActivityLogging_get_LogIncoming(This,pbLogIncoming)	\
    (This)->lpVtbl -> get_LogIncoming(This,pbLogIncoming)

#define IFaxActivityLogging_put_LogIncoming(This,bLogIncoming)	\
    (This)->lpVtbl -> put_LogIncoming(This,bLogIncoming)

#define IFaxActivityLogging_get_LogOutgoing(This,pbLogOutgoing)	\
    (This)->lpVtbl -> get_LogOutgoing(This,pbLogOutgoing)

#define IFaxActivityLogging_put_LogOutgoing(This,bLogOutgoing)	\
    (This)->lpVtbl -> put_LogOutgoing(This,bLogOutgoing)

#define IFaxActivityLogging_get_DatabasePath(This,pbstrDatabasePath)	\
    (This)->lpVtbl -> get_DatabasePath(This,pbstrDatabasePath)

#define IFaxActivityLogging_put_DatabasePath(This,bstrDatabasePath)	\
    (This)->lpVtbl -> put_DatabasePath(This,bstrDatabasePath)

#define IFaxActivityLogging_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxActivityLogging_Save(This)	\
    (This)->lpVtbl -> Save(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxActivityLogging_get_LogIncoming_Proxy( 
    IFaxActivityLogging * This,
    /* [retval][out] */ VARIANT_BOOL *pbLogIncoming);


void __RPC_STUB IFaxActivityLogging_get_LogIncoming_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxActivityLogging_put_LogIncoming_Proxy( 
    IFaxActivityLogging * This,
    /* [in] */ VARIANT_BOOL bLogIncoming);


void __RPC_STUB IFaxActivityLogging_put_LogIncoming_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxActivityLogging_get_LogOutgoing_Proxy( 
    IFaxActivityLogging * This,
    /* [retval][out] */ VARIANT_BOOL *pbLogOutgoing);


void __RPC_STUB IFaxActivityLogging_get_LogOutgoing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxActivityLogging_put_LogOutgoing_Proxy( 
    IFaxActivityLogging * This,
    /* [in] */ VARIANT_BOOL bLogOutgoing);


void __RPC_STUB IFaxActivityLogging_put_LogOutgoing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxActivityLogging_get_DatabasePath_Proxy( 
    IFaxActivityLogging * This,
    /* [retval][out] */ BSTR *pbstrDatabasePath);


void __RPC_STUB IFaxActivityLogging_get_DatabasePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxActivityLogging_put_DatabasePath_Proxy( 
    IFaxActivityLogging * This,
    /* [in] */ BSTR bstrDatabasePath);


void __RPC_STUB IFaxActivityLogging_put_DatabasePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxActivityLogging_Refresh_Proxy( 
    IFaxActivityLogging * This);


void __RPC_STUB IFaxActivityLogging_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxActivityLogging_Save_Proxy( 
    IFaxActivityLogging * This);


void __RPC_STUB IFaxActivityLogging_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxActivityLogging_INTERFACE_DEFINED__ */


#ifndef __IFaxEventLogging_INTERFACE_DEFINED__
#define __IFaxEventLogging_INTERFACE_DEFINED__

/* interface IFaxEventLogging */
/* [unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_LOG_LEVEL_ENUM
    {	fllNONE	= 0,
	fllMIN	= fllNONE + 1,
	fllMED	= fllMIN + 1,
	fllMAX	= fllMED + 1
    } 	FAX_LOG_LEVEL_ENUM;


EXTERN_C const IID IID_IFaxEventLogging;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0880D965-20E8-42E4-8E17-944F192CAAD4")
    IFaxEventLogging : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InitEventsLevel( 
            /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pInitEventLevel) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_InitEventsLevel( 
            /* [in] */ FAX_LOG_LEVEL_ENUM InitEventLevel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InboundEventsLevel( 
            /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pInboundEventLevel) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_InboundEventsLevel( 
            /* [in] */ FAX_LOG_LEVEL_ENUM InboundEventLevel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutboundEventsLevel( 
            /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pOutboundEventLevel) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OutboundEventsLevel( 
            /* [in] */ FAX_LOG_LEVEL_ENUM OutboundEventLevel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GeneralEventsLevel( 
            /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pGeneralEventLevel) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_GeneralEventsLevel( 
            /* [in] */ FAX_LOG_LEVEL_ENUM GeneralEventLevel) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxEventLoggingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxEventLogging * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxEventLogging * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxEventLogging * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxEventLogging * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxEventLogging * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxEventLogging * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxEventLogging * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InitEventsLevel )( 
            IFaxEventLogging * This,
            /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pInitEventLevel);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InitEventsLevel )( 
            IFaxEventLogging * This,
            /* [in] */ FAX_LOG_LEVEL_ENUM InitEventLevel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InboundEventsLevel )( 
            IFaxEventLogging * This,
            /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pInboundEventLevel);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InboundEventsLevel )( 
            IFaxEventLogging * This,
            /* [in] */ FAX_LOG_LEVEL_ENUM InboundEventLevel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutboundEventsLevel )( 
            IFaxEventLogging * This,
            /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pOutboundEventLevel);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OutboundEventsLevel )( 
            IFaxEventLogging * This,
            /* [in] */ FAX_LOG_LEVEL_ENUM OutboundEventLevel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GeneralEventsLevel )( 
            IFaxEventLogging * This,
            /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pGeneralEventLevel);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GeneralEventsLevel )( 
            IFaxEventLogging * This,
            /* [in] */ FAX_LOG_LEVEL_ENUM GeneralEventLevel);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxEventLogging * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxEventLogging * This);
        
        END_INTERFACE
    } IFaxEventLoggingVtbl;

    interface IFaxEventLogging
    {
        CONST_VTBL struct IFaxEventLoggingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxEventLogging_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxEventLogging_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxEventLogging_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxEventLogging_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxEventLogging_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxEventLogging_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxEventLogging_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxEventLogging_get_InitEventsLevel(This,pInitEventLevel)	\
    (This)->lpVtbl -> get_InitEventsLevel(This,pInitEventLevel)

#define IFaxEventLogging_put_InitEventsLevel(This,InitEventLevel)	\
    (This)->lpVtbl -> put_InitEventsLevel(This,InitEventLevel)

#define IFaxEventLogging_get_InboundEventsLevel(This,pInboundEventLevel)	\
    (This)->lpVtbl -> get_InboundEventsLevel(This,pInboundEventLevel)

#define IFaxEventLogging_put_InboundEventsLevel(This,InboundEventLevel)	\
    (This)->lpVtbl -> put_InboundEventsLevel(This,InboundEventLevel)

#define IFaxEventLogging_get_OutboundEventsLevel(This,pOutboundEventLevel)	\
    (This)->lpVtbl -> get_OutboundEventsLevel(This,pOutboundEventLevel)

#define IFaxEventLogging_put_OutboundEventsLevel(This,OutboundEventLevel)	\
    (This)->lpVtbl -> put_OutboundEventsLevel(This,OutboundEventLevel)

#define IFaxEventLogging_get_GeneralEventsLevel(This,pGeneralEventLevel)	\
    (This)->lpVtbl -> get_GeneralEventsLevel(This,pGeneralEventLevel)

#define IFaxEventLogging_put_GeneralEventsLevel(This,GeneralEventLevel)	\
    (This)->lpVtbl -> put_GeneralEventsLevel(This,GeneralEventLevel)

#define IFaxEventLogging_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxEventLogging_Save(This)	\
    (This)->lpVtbl -> Save(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_get_InitEventsLevel_Proxy( 
    IFaxEventLogging * This,
    /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pInitEventLevel);


void __RPC_STUB IFaxEventLogging_get_InitEventsLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_put_InitEventsLevel_Proxy( 
    IFaxEventLogging * This,
    /* [in] */ FAX_LOG_LEVEL_ENUM InitEventLevel);


void __RPC_STUB IFaxEventLogging_put_InitEventsLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_get_InboundEventsLevel_Proxy( 
    IFaxEventLogging * This,
    /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pInboundEventLevel);


void __RPC_STUB IFaxEventLogging_get_InboundEventsLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_put_InboundEventsLevel_Proxy( 
    IFaxEventLogging * This,
    /* [in] */ FAX_LOG_LEVEL_ENUM InboundEventLevel);


void __RPC_STUB IFaxEventLogging_put_InboundEventsLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_get_OutboundEventsLevel_Proxy( 
    IFaxEventLogging * This,
    /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pOutboundEventLevel);


void __RPC_STUB IFaxEventLogging_get_OutboundEventsLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_put_OutboundEventsLevel_Proxy( 
    IFaxEventLogging * This,
    /* [in] */ FAX_LOG_LEVEL_ENUM OutboundEventLevel);


void __RPC_STUB IFaxEventLogging_put_OutboundEventsLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_get_GeneralEventsLevel_Proxy( 
    IFaxEventLogging * This,
    /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pGeneralEventLevel);


void __RPC_STUB IFaxEventLogging_get_GeneralEventsLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_put_GeneralEventsLevel_Proxy( 
    IFaxEventLogging * This,
    /* [in] */ FAX_LOG_LEVEL_ENUM GeneralEventLevel);


void __RPC_STUB IFaxEventLogging_put_GeneralEventsLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_Refresh_Proxy( 
    IFaxEventLogging * This);


void __RPC_STUB IFaxEventLogging_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_Save_Proxy( 
    IFaxEventLogging * This);


void __RPC_STUB IFaxEventLogging_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxEventLogging_INTERFACE_DEFINED__ */


#ifndef __IFaxOutboundRoutingGroups_INTERFACE_DEFINED__
#define __IFaxOutboundRoutingGroups_INTERFACE_DEFINED__

/* interface IFaxOutboundRoutingGroups */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxOutboundRoutingGroups;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("235CBEF7-C2DE-4BFD-B8DA-75097C82C87F")
    IFaxOutboundRoutingGroups : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxOutboundRoutingGroup **pFaxOutboundRoutingGroup) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ IFaxOutboundRoutingGroup **pFaxOutboundRoutingGroup) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT vIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutboundRoutingGroupsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutboundRoutingGroups * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutboundRoutingGroups * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutboundRoutingGroups * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutboundRoutingGroups * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutboundRoutingGroups * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutboundRoutingGroups * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutboundRoutingGroups * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxOutboundRoutingGroups * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxOutboundRoutingGroups * This,
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxOutboundRoutingGroup **pFaxOutboundRoutingGroup);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxOutboundRoutingGroups * This,
            /* [retval][out] */ long *plCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IFaxOutboundRoutingGroups * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ IFaxOutboundRoutingGroup **pFaxOutboundRoutingGroup);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IFaxOutboundRoutingGroups * This,
            /* [in] */ VARIANT vIndex);
        
        END_INTERFACE
    } IFaxOutboundRoutingGroupsVtbl;

    interface IFaxOutboundRoutingGroups
    {
        CONST_VTBL struct IFaxOutboundRoutingGroupsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutboundRoutingGroups_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutboundRoutingGroups_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutboundRoutingGroups_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutboundRoutingGroups_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutboundRoutingGroups_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutboundRoutingGroups_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutboundRoutingGroups_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutboundRoutingGroups_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxOutboundRoutingGroups_get_Item(This,vIndex,pFaxOutboundRoutingGroup)	\
    (This)->lpVtbl -> get_Item(This,vIndex,pFaxOutboundRoutingGroup)

#define IFaxOutboundRoutingGroups_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IFaxOutboundRoutingGroups_Add(This,bstrName,pFaxOutboundRoutingGroup)	\
    (This)->lpVtbl -> Add(This,bstrName,pFaxOutboundRoutingGroup)

#define IFaxOutboundRoutingGroups_Remove(This,vIndex)	\
    (This)->lpVtbl -> Remove(This,vIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingGroups_get__NewEnum_Proxy( 
    IFaxOutboundRoutingGroups * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxOutboundRoutingGroups_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingGroups_get_Item_Proxy( 
    IFaxOutboundRoutingGroups * This,
    /* [in] */ VARIANT vIndex,
    /* [retval][out] */ IFaxOutboundRoutingGroup **pFaxOutboundRoutingGroup);


void __RPC_STUB IFaxOutboundRoutingGroups_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingGroups_get_Count_Proxy( 
    IFaxOutboundRoutingGroups * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxOutboundRoutingGroups_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingGroups_Add_Proxy( 
    IFaxOutboundRoutingGroups * This,
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ IFaxOutboundRoutingGroup **pFaxOutboundRoutingGroup);


void __RPC_STUB IFaxOutboundRoutingGroups_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingGroups_Remove_Proxy( 
    IFaxOutboundRoutingGroups * This,
    /* [in] */ VARIANT vIndex);


void __RPC_STUB IFaxOutboundRoutingGroups_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutboundRoutingGroups_INTERFACE_DEFINED__ */


#ifndef __IFaxOutboundRoutingGroup_INTERFACE_DEFINED__
#define __IFaxOutboundRoutingGroup_INTERFACE_DEFINED__

/* interface IFaxOutboundRoutingGroup */
/* [unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_GROUP_STATUS_ENUM
    {	fgsALL_DEV_VALID	= 0,
	fgsEMPTY	= fgsALL_DEV_VALID + 1,
	fgsALL_DEV_NOT_VALID	= fgsEMPTY + 1,
	fgsSOME_DEV_NOT_VALID	= fgsALL_DEV_NOT_VALID + 1
    } 	FAX_GROUP_STATUS_ENUM;


EXTERN_C const IID IID_IFaxOutboundRoutingGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CA6289A1-7E25-4F87-9A0B-93365734962C")
    IFaxOutboundRoutingGroup : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pbstrName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ FAX_GROUP_STATUS_ENUM *pStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceIds( 
            /* [retval][out] */ IFaxDeviceIds **pFaxDeviceIds) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutboundRoutingGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutboundRoutingGroup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutboundRoutingGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutboundRoutingGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutboundRoutingGroup * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutboundRoutingGroup * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutboundRoutingGroup * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutboundRoutingGroup * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IFaxOutboundRoutingGroup * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IFaxOutboundRoutingGroup * This,
            /* [retval][out] */ FAX_GROUP_STATUS_ENUM *pStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceIds )( 
            IFaxOutboundRoutingGroup * This,
            /* [retval][out] */ IFaxDeviceIds **pFaxDeviceIds);
        
        END_INTERFACE
    } IFaxOutboundRoutingGroupVtbl;

    interface IFaxOutboundRoutingGroup
    {
        CONST_VTBL struct IFaxOutboundRoutingGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutboundRoutingGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutboundRoutingGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutboundRoutingGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutboundRoutingGroup_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutboundRoutingGroup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutboundRoutingGroup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutboundRoutingGroup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutboundRoutingGroup_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)

#define IFaxOutboundRoutingGroup_get_Status(This,pStatus)	\
    (This)->lpVtbl -> get_Status(This,pStatus)

#define IFaxOutboundRoutingGroup_get_DeviceIds(This,pFaxDeviceIds)	\
    (This)->lpVtbl -> get_DeviceIds(This,pFaxDeviceIds)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingGroup_get_Name_Proxy( 
    IFaxOutboundRoutingGroup * This,
    /* [retval][out] */ BSTR *pbstrName);


void __RPC_STUB IFaxOutboundRoutingGroup_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingGroup_get_Status_Proxy( 
    IFaxOutboundRoutingGroup * This,
    /* [retval][out] */ FAX_GROUP_STATUS_ENUM *pStatus);


void __RPC_STUB IFaxOutboundRoutingGroup_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingGroup_get_DeviceIds_Proxy( 
    IFaxOutboundRoutingGroup * This,
    /* [retval][out] */ IFaxDeviceIds **pFaxDeviceIds);


void __RPC_STUB IFaxOutboundRoutingGroup_get_DeviceIds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutboundRoutingGroup_INTERFACE_DEFINED__ */


#ifndef __IFaxDeviceIds_INTERFACE_DEFINED__
#define __IFaxDeviceIds_INTERFACE_DEFINED__

/* interface IFaxDeviceIds */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxDeviceIds;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2F0F813F-4CE9-443E-8CA1-738CFAEEE149")
    IFaxDeviceIds : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ long *plDeviceId) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ long lDeviceId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetOrder( 
            /* [in] */ long lDeviceId,
            /* [in] */ long lNewOrder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxDeviceIdsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxDeviceIds * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxDeviceIds * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxDeviceIds * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxDeviceIds * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxDeviceIds * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxDeviceIds * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxDeviceIds * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxDeviceIds * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxDeviceIds * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ long *plDeviceId);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxDeviceIds * This,
            /* [retval][out] */ long *plCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IFaxDeviceIds * This,
            /* [in] */ long lDeviceId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IFaxDeviceIds * This,
            /* [in] */ long lIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetOrder )( 
            IFaxDeviceIds * This,
            /* [in] */ long lDeviceId,
            /* [in] */ long lNewOrder);
        
        END_INTERFACE
    } IFaxDeviceIdsVtbl;

    interface IFaxDeviceIds
    {
        CONST_VTBL struct IFaxDeviceIdsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxDeviceIds_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxDeviceIds_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxDeviceIds_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxDeviceIds_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxDeviceIds_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxDeviceIds_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxDeviceIds_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxDeviceIds_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxDeviceIds_get_Item(This,lIndex,plDeviceId)	\
    (This)->lpVtbl -> get_Item(This,lIndex,plDeviceId)

#define IFaxDeviceIds_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IFaxDeviceIds_Add(This,lDeviceId)	\
    (This)->lpVtbl -> Add(This,lDeviceId)

#define IFaxDeviceIds_Remove(This,lIndex)	\
    (This)->lpVtbl -> Remove(This,lIndex)

#define IFaxDeviceIds_SetOrder(This,lDeviceId,lNewOrder)	\
    (This)->lpVtbl -> SetOrder(This,lDeviceId,lNewOrder)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxDeviceIds_get__NewEnum_Proxy( 
    IFaxDeviceIds * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxDeviceIds_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxDeviceIds_get_Item_Proxy( 
    IFaxDeviceIds * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ long *plDeviceId);


void __RPC_STUB IFaxDeviceIds_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxDeviceIds_get_Count_Proxy( 
    IFaxDeviceIds * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxDeviceIds_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDeviceIds_Add_Proxy( 
    IFaxDeviceIds * This,
    /* [in] */ long lDeviceId);


void __RPC_STUB IFaxDeviceIds_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDeviceIds_Remove_Proxy( 
    IFaxDeviceIds * This,
    /* [in] */ long lIndex);


void __RPC_STUB IFaxDeviceIds_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDeviceIds_SetOrder_Proxy( 
    IFaxDeviceIds * This,
    /* [in] */ long lDeviceId,
    /* [in] */ long lNewOrder);


void __RPC_STUB IFaxDeviceIds_SetOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxDeviceIds_INTERFACE_DEFINED__ */


#ifndef __IFaxOutboundRoutingRules_INTERFACE_DEFINED__
#define __IFaxOutboundRoutingRules_INTERFACE_DEFINED__

/* interface IFaxOutboundRoutingRules */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxOutboundRoutingRules;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCEFA1E7-AE7D-4ED6-8521-369EDCCA5120")
    IFaxOutboundRoutingRules : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ IFaxOutboundRoutingRule **pFaxOutboundRoutingRule) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ItemByCountryAndArea( 
            /* [in] */ long lCountryCode,
            /* [in] */ long lAreaCode,
            /* [retval][out] */ IFaxOutboundRoutingRule **pFaxOutboundRoutingRule) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveByCountryAndArea( 
            /* [in] */ long lCountryCode,
            /* [in] */ long lAreaCode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ long lCountryCode,
            /* [in] */ long lAreaCode,
            /* [in] */ VARIANT_BOOL bUseDevice,
            /* [in] */ BSTR bstrGroupName,
            /* [in] */ long lDeviceId,
            /* [retval][out] */ IFaxOutboundRoutingRule **pFaxOutboundRoutingRule) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutboundRoutingRulesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutboundRoutingRules * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutboundRoutingRules * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutboundRoutingRules * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutboundRoutingRules * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutboundRoutingRules * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutboundRoutingRules * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutboundRoutingRules * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxOutboundRoutingRules * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxOutboundRoutingRules * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ IFaxOutboundRoutingRule **pFaxOutboundRoutingRule);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxOutboundRoutingRules * This,
            /* [retval][out] */ long *plCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ItemByCountryAndArea )( 
            IFaxOutboundRoutingRules * This,
            /* [in] */ long lCountryCode,
            /* [in] */ long lAreaCode,
            /* [retval][out] */ IFaxOutboundRoutingRule **pFaxOutboundRoutingRule);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveByCountryAndArea )( 
            IFaxOutboundRoutingRules * This,
            /* [in] */ long lCountryCode,
            /* [in] */ long lAreaCode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IFaxOutboundRoutingRules * This,
            /* [in] */ long lIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IFaxOutboundRoutingRules * This,
            /* [in] */ long lCountryCode,
            /* [in] */ long lAreaCode,
            /* [in] */ VARIANT_BOOL bUseDevice,
            /* [in] */ BSTR bstrGroupName,
            /* [in] */ long lDeviceId,
            /* [retval][out] */ IFaxOutboundRoutingRule **pFaxOutboundRoutingRule);
        
        END_INTERFACE
    } IFaxOutboundRoutingRulesVtbl;

    interface IFaxOutboundRoutingRules
    {
        CONST_VTBL struct IFaxOutboundRoutingRulesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutboundRoutingRules_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutboundRoutingRules_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutboundRoutingRules_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutboundRoutingRules_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutboundRoutingRules_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutboundRoutingRules_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutboundRoutingRules_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutboundRoutingRules_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxOutboundRoutingRules_get_Item(This,lIndex,pFaxOutboundRoutingRule)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pFaxOutboundRoutingRule)

#define IFaxOutboundRoutingRules_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IFaxOutboundRoutingRules_ItemByCountryAndArea(This,lCountryCode,lAreaCode,pFaxOutboundRoutingRule)	\
    (This)->lpVtbl -> ItemByCountryAndArea(This,lCountryCode,lAreaCode,pFaxOutboundRoutingRule)

#define IFaxOutboundRoutingRules_RemoveByCountryAndArea(This,lCountryCode,lAreaCode)	\
    (This)->lpVtbl -> RemoveByCountryAndArea(This,lCountryCode,lAreaCode)

#define IFaxOutboundRoutingRules_Remove(This,lIndex)	\
    (This)->lpVtbl -> Remove(This,lIndex)

#define IFaxOutboundRoutingRules_Add(This,lCountryCode,lAreaCode,bUseDevice,bstrGroupName,lDeviceId,pFaxOutboundRoutingRule)	\
    (This)->lpVtbl -> Add(This,lCountryCode,lAreaCode,bUseDevice,bstrGroupName,lDeviceId,pFaxOutboundRoutingRule)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRules_get__NewEnum_Proxy( 
    IFaxOutboundRoutingRules * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxOutboundRoutingRules_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRules_get_Item_Proxy( 
    IFaxOutboundRoutingRules * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ IFaxOutboundRoutingRule **pFaxOutboundRoutingRule);


void __RPC_STUB IFaxOutboundRoutingRules_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRules_get_Count_Proxy( 
    IFaxOutboundRoutingRules * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxOutboundRoutingRules_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRules_ItemByCountryAndArea_Proxy( 
    IFaxOutboundRoutingRules * This,
    /* [in] */ long lCountryCode,
    /* [in] */ long lAreaCode,
    /* [retval][out] */ IFaxOutboundRoutingRule **pFaxOutboundRoutingRule);


void __RPC_STUB IFaxOutboundRoutingRules_ItemByCountryAndArea_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRules_RemoveByCountryAndArea_Proxy( 
    IFaxOutboundRoutingRules * This,
    /* [in] */ long lCountryCode,
    /* [in] */ long lAreaCode);


void __RPC_STUB IFaxOutboundRoutingRules_RemoveByCountryAndArea_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRules_Remove_Proxy( 
    IFaxOutboundRoutingRules * This,
    /* [in] */ long lIndex);


void __RPC_STUB IFaxOutboundRoutingRules_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRules_Add_Proxy( 
    IFaxOutboundRoutingRules * This,
    /* [in] */ long lCountryCode,
    /* [in] */ long lAreaCode,
    /* [in] */ VARIANT_BOOL bUseDevice,
    /* [in] */ BSTR bstrGroupName,
    /* [in] */ long lDeviceId,
    /* [retval][out] */ IFaxOutboundRoutingRule **pFaxOutboundRoutingRule);


void __RPC_STUB IFaxOutboundRoutingRules_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutboundRoutingRules_INTERFACE_DEFINED__ */


#ifndef __IFaxOutboundRoutingRule_INTERFACE_DEFINED__
#define __IFaxOutboundRoutingRule_INTERFACE_DEFINED__

/* interface IFaxOutboundRoutingRule */
/* [unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_RULE_STATUS_ENUM
    {	frsVALID	= 0,
	frsEMPTY_GROUP	= frsVALID + 1,
	frsALL_GROUP_DEV_NOT_VALID	= frsEMPTY_GROUP + 1,
	frsSOME_GROUP_DEV_NOT_VALID	= frsALL_GROUP_DEV_NOT_VALID + 1,
	frsBAD_DEVICE	= frsSOME_GROUP_DEV_NOT_VALID + 1
    } 	FAX_RULE_STATUS_ENUM;


EXTERN_C const IID IID_IFaxOutboundRoutingRule;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1F795D5-07C2-469F-B027-ACACC23219DA")
    IFaxOutboundRoutingRule : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CountryCode( 
            /* [retval][out] */ long *plCountryCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AreaCode( 
            /* [retval][out] */ long *plAreaCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ FAX_RULE_STATUS_ENUM *pStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseDevice( 
            /* [retval][out] */ VARIANT_BOOL *pbUseDevice) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UseDevice( 
            /* [in] */ VARIANT_BOOL bUseDevice) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceId( 
            /* [retval][out] */ long *plDeviceId) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DeviceId( 
            /* [in] */ long DeviceId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GroupName( 
            /* [retval][out] */ BSTR *pbstrGroupName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_GroupName( 
            /* [in] */ BSTR bstrGroupName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutboundRoutingRuleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutboundRoutingRule * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutboundRoutingRule * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutboundRoutingRule * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutboundRoutingRule * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutboundRoutingRule * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutboundRoutingRule * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutboundRoutingRule * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CountryCode )( 
            IFaxOutboundRoutingRule * This,
            /* [retval][out] */ long *plCountryCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AreaCode )( 
            IFaxOutboundRoutingRule * This,
            /* [retval][out] */ long *plAreaCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IFaxOutboundRoutingRule * This,
            /* [retval][out] */ FAX_RULE_STATUS_ENUM *pStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseDevice )( 
            IFaxOutboundRoutingRule * This,
            /* [retval][out] */ VARIANT_BOOL *pbUseDevice);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseDevice )( 
            IFaxOutboundRoutingRule * This,
            /* [in] */ VARIANT_BOOL bUseDevice);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceId )( 
            IFaxOutboundRoutingRule * This,
            /* [retval][out] */ long *plDeviceId);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeviceId )( 
            IFaxOutboundRoutingRule * This,
            /* [in] */ long DeviceId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GroupName )( 
            IFaxOutboundRoutingRule * This,
            /* [retval][out] */ BSTR *pbstrGroupName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GroupName )( 
            IFaxOutboundRoutingRule * This,
            /* [in] */ BSTR bstrGroupName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxOutboundRoutingRule * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxOutboundRoutingRule * This);
        
        END_INTERFACE
    } IFaxOutboundRoutingRuleVtbl;

    interface IFaxOutboundRoutingRule
    {
        CONST_VTBL struct IFaxOutboundRoutingRuleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutboundRoutingRule_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutboundRoutingRule_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutboundRoutingRule_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutboundRoutingRule_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutboundRoutingRule_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutboundRoutingRule_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutboundRoutingRule_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutboundRoutingRule_get_CountryCode(This,plCountryCode)	\
    (This)->lpVtbl -> get_CountryCode(This,plCountryCode)

#define IFaxOutboundRoutingRule_get_AreaCode(This,plAreaCode)	\
    (This)->lpVtbl -> get_AreaCode(This,plAreaCode)

#define IFaxOutboundRoutingRule_get_Status(This,pStatus)	\
    (This)->lpVtbl -> get_Status(This,pStatus)

#define IFaxOutboundRoutingRule_get_UseDevice(This,pbUseDevice)	\
    (This)->lpVtbl -> get_UseDevice(This,pbUseDevice)

#define IFaxOutboundRoutingRule_put_UseDevice(This,bUseDevice)	\
    (This)->lpVtbl -> put_UseDevice(This,bUseDevice)

#define IFaxOutboundRoutingRule_get_DeviceId(This,plDeviceId)	\
    (This)->lpVtbl -> get_DeviceId(This,plDeviceId)

#define IFaxOutboundRoutingRule_put_DeviceId(This,DeviceId)	\
    (This)->lpVtbl -> put_DeviceId(This,DeviceId)

#define IFaxOutboundRoutingRule_get_GroupName(This,pbstrGroupName)	\
    (This)->lpVtbl -> get_GroupName(This,pbstrGroupName)

#define IFaxOutboundRoutingRule_put_GroupName(This,bstrGroupName)	\
    (This)->lpVtbl -> put_GroupName(This,bstrGroupName)

#define IFaxOutboundRoutingRule_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxOutboundRoutingRule_Save(This)	\
    (This)->lpVtbl -> Save(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_get_CountryCode_Proxy( 
    IFaxOutboundRoutingRule * This,
    /* [retval][out] */ long *plCountryCode);


void __RPC_STUB IFaxOutboundRoutingRule_get_CountryCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_get_AreaCode_Proxy( 
    IFaxOutboundRoutingRule * This,
    /* [retval][out] */ long *plAreaCode);


void __RPC_STUB IFaxOutboundRoutingRule_get_AreaCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_get_Status_Proxy( 
    IFaxOutboundRoutingRule * This,
    /* [retval][out] */ FAX_RULE_STATUS_ENUM *pStatus);


void __RPC_STUB IFaxOutboundRoutingRule_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_get_UseDevice_Proxy( 
    IFaxOutboundRoutingRule * This,
    /* [retval][out] */ VARIANT_BOOL *pbUseDevice);


void __RPC_STUB IFaxOutboundRoutingRule_get_UseDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_put_UseDevice_Proxy( 
    IFaxOutboundRoutingRule * This,
    /* [in] */ VARIANT_BOOL bUseDevice);


void __RPC_STUB IFaxOutboundRoutingRule_put_UseDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_get_DeviceId_Proxy( 
    IFaxOutboundRoutingRule * This,
    /* [retval][out] */ long *plDeviceId);


void __RPC_STUB IFaxOutboundRoutingRule_get_DeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_put_DeviceId_Proxy( 
    IFaxOutboundRoutingRule * This,
    /* [in] */ long DeviceId);


void __RPC_STUB IFaxOutboundRoutingRule_put_DeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_get_GroupName_Proxy( 
    IFaxOutboundRoutingRule * This,
    /* [retval][out] */ BSTR *pbstrGroupName);


void __RPC_STUB IFaxOutboundRoutingRule_get_GroupName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_put_GroupName_Proxy( 
    IFaxOutboundRoutingRule * This,
    /* [in] */ BSTR bstrGroupName);


void __RPC_STUB IFaxOutboundRoutingRule_put_GroupName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_Refresh_Proxy( 
    IFaxOutboundRoutingRule * This);


void __RPC_STUB IFaxOutboundRoutingRule_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_Save_Proxy( 
    IFaxOutboundRoutingRule * This);


void __RPC_STUB IFaxOutboundRoutingRule_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutboundRoutingRule_INTERFACE_DEFINED__ */


#ifndef __IFaxInboundRoutingExtensions_INTERFACE_DEFINED__
#define __IFaxInboundRoutingExtensions_INTERFACE_DEFINED__

/* interface IFaxInboundRoutingExtensions */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxInboundRoutingExtensions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2F6C9673-7B26-42DE-8EB0-915DCD2A4F4C")
    IFaxInboundRoutingExtensions : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxInboundRoutingExtension **pFaxInboundRoutingExtension) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxInboundRoutingExtensionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxInboundRoutingExtensions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxInboundRoutingExtensions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxInboundRoutingExtensions * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxInboundRoutingExtensions * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxInboundRoutingExtensions * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxInboundRoutingExtensions * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxInboundRoutingExtensions * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxInboundRoutingExtensions * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxInboundRoutingExtensions * This,
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxInboundRoutingExtension **pFaxInboundRoutingExtension);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxInboundRoutingExtensions * This,
            /* [retval][out] */ long *plCount);
        
        END_INTERFACE
    } IFaxInboundRoutingExtensionsVtbl;

    interface IFaxInboundRoutingExtensions
    {
        CONST_VTBL struct IFaxInboundRoutingExtensionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxInboundRoutingExtensions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxInboundRoutingExtensions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxInboundRoutingExtensions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxInboundRoutingExtensions_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxInboundRoutingExtensions_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxInboundRoutingExtensions_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxInboundRoutingExtensions_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxInboundRoutingExtensions_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxInboundRoutingExtensions_get_Item(This,vIndex,pFaxInboundRoutingExtension)	\
    (This)->lpVtbl -> get_Item(This,vIndex,pFaxInboundRoutingExtension)

#define IFaxInboundRoutingExtensions_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtensions_get__NewEnum_Proxy( 
    IFaxInboundRoutingExtensions * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxInboundRoutingExtensions_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtensions_get_Item_Proxy( 
    IFaxInboundRoutingExtensions * This,
    /* [in] */ VARIANT vIndex,
    /* [retval][out] */ IFaxInboundRoutingExtension **pFaxInboundRoutingExtension);


void __RPC_STUB IFaxInboundRoutingExtensions_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtensions_get_Count_Proxy( 
    IFaxInboundRoutingExtensions * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxInboundRoutingExtensions_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxInboundRoutingExtensions_INTERFACE_DEFINED__ */


#ifndef __IFaxInboundRoutingExtension_INTERFACE_DEFINED__
#define __IFaxInboundRoutingExtension_INTERFACE_DEFINED__

/* interface IFaxInboundRoutingExtension */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxInboundRoutingExtension;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("885B5E08-C26C-4EF9-AF83-51580A750BE1")
    IFaxInboundRoutingExtension : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FriendlyName( 
            /* [retval][out] */ BSTR *pbstrFriendlyName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImageName( 
            /* [retval][out] */ BSTR *pbstrImageName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UniqueName( 
            /* [retval][out] */ BSTR *pbstrUniqueName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorVersion( 
            /* [retval][out] */ long *plMajorVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorVersion( 
            /* [retval][out] */ long *plMinorVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorBuild( 
            /* [retval][out] */ long *plMajorBuild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorBuild( 
            /* [retval][out] */ long *plMinorBuild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Debug( 
            /* [retval][out] */ VARIANT_BOOL *pbDebug) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ FAX_PROVIDER_STATUS_ENUM *pStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InitErrorCode( 
            /* [retval][out] */ long *plInitErrorCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Methods( 
            /* [retval][out] */ VARIANT *pvMethods) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxInboundRoutingExtensionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxInboundRoutingExtension * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxInboundRoutingExtension * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxInboundRoutingExtension * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxInboundRoutingExtension * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxInboundRoutingExtension * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxInboundRoutingExtension * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxInboundRoutingExtension * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ BSTR *pbstrFriendlyName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImageName )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ BSTR *pbstrImageName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UniqueName )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ BSTR *pbstrUniqueName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MajorVersion )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ long *plMajorVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorVersion )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ long *plMinorVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MajorBuild )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ long *plMajorBuild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorBuild )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ long *plMinorBuild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Debug )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ VARIANT_BOOL *pbDebug);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ FAX_PROVIDER_STATUS_ENUM *pStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InitErrorCode )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ long *plInitErrorCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Methods )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ VARIANT *pvMethods);
        
        END_INTERFACE
    } IFaxInboundRoutingExtensionVtbl;

    interface IFaxInboundRoutingExtension
    {
        CONST_VTBL struct IFaxInboundRoutingExtensionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxInboundRoutingExtension_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxInboundRoutingExtension_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxInboundRoutingExtension_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxInboundRoutingExtension_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxInboundRoutingExtension_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxInboundRoutingExtension_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxInboundRoutingExtension_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxInboundRoutingExtension_get_FriendlyName(This,pbstrFriendlyName)	\
    (This)->lpVtbl -> get_FriendlyName(This,pbstrFriendlyName)

#define IFaxInboundRoutingExtension_get_ImageName(This,pbstrImageName)	\
    (This)->lpVtbl -> get_ImageName(This,pbstrImageName)

#define IFaxInboundRoutingExtension_get_UniqueName(This,pbstrUniqueName)	\
    (This)->lpVtbl -> get_UniqueName(This,pbstrUniqueName)

#define IFaxInboundRoutingExtension_get_MajorVersion(This,plMajorVersion)	\
    (This)->lpVtbl -> get_MajorVersion(This,plMajorVersion)

#define IFaxInboundRoutingExtension_get_MinorVersion(This,plMinorVersion)	\
    (This)->lpVtbl -> get_MinorVersion(This,plMinorVersion)

#define IFaxInboundRoutingExtension_get_MajorBuild(This,plMajorBuild)	\
    (This)->lpVtbl -> get_MajorBuild(This,plMajorBuild)

#define IFaxInboundRoutingExtension_get_MinorBuild(This,plMinorBuild)	\
    (This)->lpVtbl -> get_MinorBuild(This,plMinorBuild)

#define IFaxInboundRoutingExtension_get_Debug(This,pbDebug)	\
    (This)->lpVtbl -> get_Debug(This,pbDebug)

#define IFaxInboundRoutingExtension_get_Status(This,pStatus)	\
    (This)->lpVtbl -> get_Status(This,pStatus)

#define IFaxInboundRoutingExtension_get_InitErrorCode(This,plInitErrorCode)	\
    (This)->lpVtbl -> get_InitErrorCode(This,plInitErrorCode)

#define IFaxInboundRoutingExtension_get_Methods(This,pvMethods)	\
    (This)->lpVtbl -> get_Methods(This,pvMethods)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_FriendlyName_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ BSTR *pbstrFriendlyName);


void __RPC_STUB IFaxInboundRoutingExtension_get_FriendlyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_ImageName_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ BSTR *pbstrImageName);


void __RPC_STUB IFaxInboundRoutingExtension_get_ImageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_UniqueName_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ BSTR *pbstrUniqueName);


void __RPC_STUB IFaxInboundRoutingExtension_get_UniqueName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_MajorVersion_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ long *plMajorVersion);


void __RPC_STUB IFaxInboundRoutingExtension_get_MajorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_MinorVersion_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ long *plMinorVersion);


void __RPC_STUB IFaxInboundRoutingExtension_get_MinorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_MajorBuild_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ long *plMajorBuild);


void __RPC_STUB IFaxInboundRoutingExtension_get_MajorBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_MinorBuild_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ long *plMinorBuild);


void __RPC_STUB IFaxInboundRoutingExtension_get_MinorBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_Debug_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ VARIANT_BOOL *pbDebug);


void __RPC_STUB IFaxInboundRoutingExtension_get_Debug_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_Status_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ FAX_PROVIDER_STATUS_ENUM *pStatus);


void __RPC_STUB IFaxInboundRoutingExtension_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_InitErrorCode_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ long *plInitErrorCode);


void __RPC_STUB IFaxInboundRoutingExtension_get_InitErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_Methods_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ VARIANT *pvMethods);


void __RPC_STUB IFaxInboundRoutingExtension_get_Methods_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxInboundRoutingExtension_INTERFACE_DEFINED__ */


#ifndef __IFaxInboundRoutingMethods_INTERFACE_DEFINED__
#define __IFaxInboundRoutingMethods_INTERFACE_DEFINED__

/* interface IFaxInboundRoutingMethods */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxInboundRoutingMethods;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("783FCA10-8908-4473-9D69-F67FBEA0C6B9")
    IFaxInboundRoutingMethods : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxInboundRoutingMethod **pFaxInboundRoutingMethod) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxInboundRoutingMethodsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxInboundRoutingMethods * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxInboundRoutingMethods * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxInboundRoutingMethods * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxInboundRoutingMethods * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxInboundRoutingMethods * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxInboundRoutingMethods * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxInboundRoutingMethods * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxInboundRoutingMethods * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxInboundRoutingMethods * This,
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxInboundRoutingMethod **pFaxInboundRoutingMethod);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxInboundRoutingMethods * This,
            /* [retval][out] */ long *plCount);
        
        END_INTERFACE
    } IFaxInboundRoutingMethodsVtbl;

    interface IFaxInboundRoutingMethods
    {
        CONST_VTBL struct IFaxInboundRoutingMethodsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxInboundRoutingMethods_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxInboundRoutingMethods_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxInboundRoutingMethods_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxInboundRoutingMethods_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxInboundRoutingMethods_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxInboundRoutingMethods_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxInboundRoutingMethods_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxInboundRoutingMethods_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxInboundRoutingMethods_get_Item(This,vIndex,pFaxInboundRoutingMethod)	\
    (This)->lpVtbl -> get_Item(This,vIndex,pFaxInboundRoutingMethod)

#define IFaxInboundRoutingMethods_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethods_get__NewEnum_Proxy( 
    IFaxInboundRoutingMethods * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxInboundRoutingMethods_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethods_get_Item_Proxy( 
    IFaxInboundRoutingMethods * This,
    /* [in] */ VARIANT vIndex,
    /* [retval][out] */ IFaxInboundRoutingMethod **pFaxInboundRoutingMethod);


void __RPC_STUB IFaxInboundRoutingMethods_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethods_get_Count_Proxy( 
    IFaxInboundRoutingMethods * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxInboundRoutingMethods_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxInboundRoutingMethods_INTERFACE_DEFINED__ */


#ifndef __IFaxInboundRoutingMethod_INTERFACE_DEFINED__
#define __IFaxInboundRoutingMethod_INTERFACE_DEFINED__

/* interface IFaxInboundRoutingMethod */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxInboundRoutingMethod;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("45700061-AD9D-4776-A8C4-64065492CF4B")
    IFaxInboundRoutingMethod : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pbstrName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GUID( 
            /* [retval][out] */ BSTR *pbstrGUID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FunctionName( 
            /* [retval][out] */ BSTR *pbstrFunctionName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtensionFriendlyName( 
            /* [retval][out] */ BSTR *pbstrExtensionFriendlyName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtensionImageName( 
            /* [retval][out] */ BSTR *pbstrExtensionImageName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ long *plPriority) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Priority( 
            /* [in] */ long lPriority) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxInboundRoutingMethodVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxInboundRoutingMethod * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxInboundRoutingMethod * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxInboundRoutingMethod * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxInboundRoutingMethod * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxInboundRoutingMethod * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxInboundRoutingMethod * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxInboundRoutingMethod * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IFaxInboundRoutingMethod * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IFaxInboundRoutingMethod * This,
            /* [retval][out] */ BSTR *pbstrGUID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FunctionName )( 
            IFaxInboundRoutingMethod * This,
            /* [retval][out] */ BSTR *pbstrFunctionName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtensionFriendlyName )( 
            IFaxInboundRoutingMethod * This,
            /* [retval][out] */ BSTR *pbstrExtensionFriendlyName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtensionImageName )( 
            IFaxInboundRoutingMethod * This,
            /* [retval][out] */ BSTR *pbstrExtensionImageName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IFaxInboundRoutingMethod * This,
            /* [retval][out] */ long *plPriority);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Priority )( 
            IFaxInboundRoutingMethod * This,
            /* [in] */ long lPriority);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxInboundRoutingMethod * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxInboundRoutingMethod * This);
        
        END_INTERFACE
    } IFaxInboundRoutingMethodVtbl;

    interface IFaxInboundRoutingMethod
    {
        CONST_VTBL struct IFaxInboundRoutingMethodVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxInboundRoutingMethod_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxInboundRoutingMethod_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxInboundRoutingMethod_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxInboundRoutingMethod_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxInboundRoutingMethod_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxInboundRoutingMethod_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxInboundRoutingMethod_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxInboundRoutingMethod_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)

#define IFaxInboundRoutingMethod_get_GUID(This,pbstrGUID)	\
    (This)->lpVtbl -> get_GUID(This,pbstrGUID)

#define IFaxInboundRoutingMethod_get_FunctionName(This,pbstrFunctionName)	\
    (This)->lpVtbl -> get_FunctionName(This,pbstrFunctionName)

#define IFaxInboundRoutingMethod_get_ExtensionFriendlyName(This,pbstrExtensionFriendlyName)	\
    (This)->lpVtbl -> get_ExtensionFriendlyName(This,pbstrExtensionFriendlyName)

#define IFaxInboundRoutingMethod_get_ExtensionImageName(This,pbstrExtensionImageName)	\
    (This)->lpVtbl -> get_ExtensionImageName(This,pbstrExtensionImageName)

#define IFaxInboundRoutingMethod_get_Priority(This,plPriority)	\
    (This)->lpVtbl -> get_Priority(This,plPriority)

#define IFaxInboundRoutingMethod_put_Priority(This,lPriority)	\
    (This)->lpVtbl -> put_Priority(This,lPriority)

#define IFaxInboundRoutingMethod_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxInboundRoutingMethod_Save(This)	\
    (This)->lpVtbl -> Save(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethod_get_Name_Proxy( 
    IFaxInboundRoutingMethod * This,
    /* [retval][out] */ BSTR *pbstrName);


void __RPC_STUB IFaxInboundRoutingMethod_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethod_get_GUID_Proxy( 
    IFaxInboundRoutingMethod * This,
    /* [retval][out] */ BSTR *pbstrGUID);


void __RPC_STUB IFaxInboundRoutingMethod_get_GUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethod_get_FunctionName_Proxy( 
    IFaxInboundRoutingMethod * This,
    /* [retval][out] */ BSTR *pbstrFunctionName);


void __RPC_STUB IFaxInboundRoutingMethod_get_FunctionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethod_get_ExtensionFriendlyName_Proxy( 
    IFaxInboundRoutingMethod * This,
    /* [retval][out] */ BSTR *pbstrExtensionFriendlyName);


void __RPC_STUB IFaxInboundRoutingMethod_get_ExtensionFriendlyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethod_get_ExtensionImageName_Proxy( 
    IFaxInboundRoutingMethod * This,
    /* [retval][out] */ BSTR *pbstrExtensionImageName);


void __RPC_STUB IFaxInboundRoutingMethod_get_ExtensionImageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethod_get_Priority_Proxy( 
    IFaxInboundRoutingMethod * This,
    /* [retval][out] */ long *plPriority);


void __RPC_STUB IFaxInboundRoutingMethod_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethod_put_Priority_Proxy( 
    IFaxInboundRoutingMethod * This,
    /* [in] */ long lPriority);


void __RPC_STUB IFaxInboundRoutingMethod_put_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethod_Refresh_Proxy( 
    IFaxInboundRoutingMethod * This);


void __RPC_STUB IFaxInboundRoutingMethod_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethod_Save_Proxy( 
    IFaxInboundRoutingMethod * This);


void __RPC_STUB IFaxInboundRoutingMethod_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxInboundRoutingMethod_INTERFACE_DEFINED__ */



#ifndef __FAXCOMEXLib_LIBRARY_DEFINED__
#define __FAXCOMEXLib_LIBRARY_DEFINED__

/* library FAXCOMEXLib */
/* [helpstring][version][uuid] */ 

typedef 
enum FAX_ROUTING_RULE_CODE_ENUM
    {	frrcANY_CODE	= 0
    } 	FAX_ROUTING_RULE_CODE_ENUM;


EXTERN_C const IID LIBID_FAXCOMEXLib;

#ifndef __IFaxServerNotify_DISPINTERFACE_DEFINED__
#define __IFaxServerNotify_DISPINTERFACE_DEFINED__

/* dispinterface IFaxServerNotify */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID_IFaxServerNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("2E037B27-CF8A-4abd-B1E0-5704943BEA6F")
    IFaxServerNotify : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IFaxServerNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxServerNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxServerNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxServerNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxServerNotify * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxServerNotify * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxServerNotify * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxServerNotify * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IFaxServerNotifyVtbl;

    interface IFaxServerNotify
    {
        CONST_VTBL struct IFaxServerNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxServerNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxServerNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxServerNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxServerNotify_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxServerNotify_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxServerNotify_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxServerNotify_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IFaxServerNotify_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_FaxServer;

#ifdef __cplusplus

class DECLSPEC_UUID("CDA8ACB0-8CF5-4F6C-9BA2-5931D40C8CAE")
FaxServer;
#endif

EXTERN_C const CLSID CLSID_FaxDeviceProviders;

#ifdef __cplusplus

class DECLSPEC_UUID("EB8FE768-875A-4F5F-82C5-03F23AAC1BD7")
FaxDeviceProviders;
#endif

EXTERN_C const CLSID CLSID_FaxDevices;

#ifdef __cplusplus

class DECLSPEC_UUID("5589E28E-23CB-4919-8808-E6101846E80D")
FaxDevices;
#endif

EXTERN_C const CLSID CLSID_FaxInboundRouting;

#ifdef __cplusplus

class DECLSPEC_UUID("E80248ED-AD65-4218-8108-991924D4E7ED")
FaxInboundRouting;
#endif

EXTERN_C const CLSID CLSID_FaxFolders;

#ifdef __cplusplus

class DECLSPEC_UUID("C35211D7-5776-48CB-AF44-C31BE3B2CFE5")
FaxFolders;
#endif

EXTERN_C const CLSID CLSID_FaxLoggingOptions;

#ifdef __cplusplus

class DECLSPEC_UUID("1BF9EEA6-ECE0-4785-A18B-DE56E9EEF96A")
FaxLoggingOptions;
#endif

EXTERN_C const CLSID CLSID_FaxActivity;

#ifdef __cplusplus

class DECLSPEC_UUID("CFEF5D0E-E84D-462E-AABB-87D31EB04FEF")
FaxActivity;
#endif

EXTERN_C const CLSID CLSID_FaxOutboundRouting;

#ifdef __cplusplus

class DECLSPEC_UUID("C81B385E-B869-4AFD-86C0-616498ED9BE2")
FaxOutboundRouting;
#endif

EXTERN_C const CLSID CLSID_FaxReceiptOptions;

#ifdef __cplusplus

class DECLSPEC_UUID("6982487B-227B-4C96-A61C-248348B05AB6")
FaxReceiptOptions;
#endif

EXTERN_C const CLSID CLSID_FaxSecurity;

#ifdef __cplusplus

class DECLSPEC_UUID("10C4DDDE-ABF0-43DF-964F-7F3AC21A4C7B")
FaxSecurity;
#endif

EXTERN_C const CLSID CLSID_FaxDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("0F3F9F91-C838-415E-A4F3-3E828CA445E0")
FaxDocument;
#endif

EXTERN_C const CLSID CLSID_FaxSender;

#ifdef __cplusplus

class DECLSPEC_UUID("265D84D0-1850-4360-B7C8-758BBB5F0B96")
FaxSender;
#endif

EXTERN_C const CLSID CLSID_FaxRecipients;

#ifdef __cplusplus

class DECLSPEC_UUID("EA9BDF53-10A9-4D4F-A067-63C8F84F01B0")
FaxRecipients;
#endif

EXTERN_C const CLSID CLSID_FaxIncomingArchive;

#ifdef __cplusplus

class DECLSPEC_UUID("8426C56A-35A1-4C6F-AF93-FC952422E2C2")
FaxIncomingArchive;
#endif

EXTERN_C const CLSID CLSID_FaxIncomingQueue;

#ifdef __cplusplus

class DECLSPEC_UUID("69131717-F3F1-40E3-809D-A6CBF7BD85E5")
FaxIncomingQueue;
#endif

EXTERN_C const CLSID CLSID_FaxOutgoingArchive;

#ifdef __cplusplus

class DECLSPEC_UUID("43C28403-E04F-474D-990C-B94669148F59")
FaxOutgoingArchive;
#endif

EXTERN_C const CLSID CLSID_FaxOutgoingQueue;

#ifdef __cplusplus

class DECLSPEC_UUID("7421169E-8C43-4B0D-BB16-645C8FA40357")
FaxOutgoingQueue;
#endif

EXTERN_C const CLSID CLSID_FaxIncomingMessageIterator;

#ifdef __cplusplus

class DECLSPEC_UUID("6088E1D8-3FC8-45C2-87B1-909A29607EA9")
FaxIncomingMessageIterator;
#endif

EXTERN_C const CLSID CLSID_FaxIncomingMessage;

#ifdef __cplusplus

class DECLSPEC_UUID("1932FCF7-9D43-4D5A-89FF-03861B321736")
FaxIncomingMessage;
#endif

EXTERN_C const CLSID CLSID_FaxOutgoingJobs;

#ifdef __cplusplus

class DECLSPEC_UUID("92BF2A6C-37BE-43FA-A37D-CB0E5F753B35")
FaxOutgoingJobs;
#endif

EXTERN_C const CLSID CLSID_FaxOutgoingJob;

#ifdef __cplusplus

class DECLSPEC_UUID("71BB429C-0EF9-4915-BEC5-A5D897A3E924")
FaxOutgoingJob;
#endif

EXTERN_C const CLSID CLSID_FaxOutgoingMessageIterator;

#ifdef __cplusplus

class DECLSPEC_UUID("8A3224D0-D30B-49DE-9813-CB385790FBBB")
FaxOutgoingMessageIterator;
#endif

EXTERN_C const CLSID CLSID_FaxOutgoingMessage;

#ifdef __cplusplus

class DECLSPEC_UUID("91B4A378-4AD8-4AEF-A4DC-97D96E939A3A")
FaxOutgoingMessage;
#endif

EXTERN_C const CLSID CLSID_FaxIncomingJobs;

#ifdef __cplusplus

class DECLSPEC_UUID("A1BB8A43-8866-4FB7-A15D-6266C875A5CC")
FaxIncomingJobs;
#endif

EXTERN_C const CLSID CLSID_FaxIncomingJob;

#ifdef __cplusplus

class DECLSPEC_UUID("C47311EC-AE32-41B8-AE4B-3EAE0629D0C9")
FaxIncomingJob;
#endif

EXTERN_C const CLSID CLSID_FaxDeviceProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("17CF1AA3-F5EB-484A-9C9A-4440A5BAABFC")
FaxDeviceProvider;
#endif

EXTERN_C const CLSID CLSID_FaxDevice;

#ifdef __cplusplus

class DECLSPEC_UUID("59E3A5B2-D676-484B-A6DE-720BFA89B5AF")
FaxDevice;
#endif

EXTERN_C const CLSID CLSID_FaxActivityLogging;

#ifdef __cplusplus

class DECLSPEC_UUID("F0A0294E-3BBD-48B8-8F13-8C591A55BDBC")
FaxActivityLogging;
#endif

EXTERN_C const CLSID CLSID_FaxEventLogging;

#ifdef __cplusplus

class DECLSPEC_UUID("A6850930-A0F6-4A6F-95B7-DB2EBF3D02E3")
FaxEventLogging;
#endif

EXTERN_C const CLSID CLSID_FaxOutboundRoutingGroups;

#ifdef __cplusplus

class DECLSPEC_UUID("CCBEA1A5-E2B4-4B57-9421-B04B6289464B")
FaxOutboundRoutingGroups;
#endif

EXTERN_C const CLSID CLSID_FaxOutboundRoutingGroup;

#ifdef __cplusplus

class DECLSPEC_UUID("0213F3E0-6791-4D77-A271-04D2357C50D6")
FaxOutboundRoutingGroup;
#endif

EXTERN_C const CLSID CLSID_FaxDeviceIds;

#ifdef __cplusplus

class DECLSPEC_UUID("CDC539EA-7277-460E-8DE0-48A0A5760D1F")
FaxDeviceIds;
#endif

EXTERN_C const CLSID CLSID_FaxOutboundRoutingRules;

#ifdef __cplusplus

class DECLSPEC_UUID("D385BECA-E624-4473-BFAA-9F4000831F54")
FaxOutboundRoutingRules;
#endif

EXTERN_C const CLSID CLSID_FaxOutboundRoutingRule;

#ifdef __cplusplus

class DECLSPEC_UUID("6549EEBF-08D1-475A-828B-3BF105952FA0")
FaxOutboundRoutingRule;
#endif

EXTERN_C const CLSID CLSID_FaxInboundRoutingExtensions;

#ifdef __cplusplus

class DECLSPEC_UUID("189A48ED-623C-4C0D-80F2-D66C7B9EFEC2")
FaxInboundRoutingExtensions;
#endif

EXTERN_C const CLSID CLSID_FaxInboundRoutingExtension;

#ifdef __cplusplus

class DECLSPEC_UUID("1D7DFB51-7207-4436-A0D9-24E32EE56988")
FaxInboundRoutingExtension;
#endif

EXTERN_C const CLSID CLSID_FaxInboundRoutingMethods;

#ifdef __cplusplus

class DECLSPEC_UUID("25FCB76A-B750-4B82-9266-FBBBAE8922BA")
FaxInboundRoutingMethods;
#endif

EXTERN_C const CLSID CLSID_FaxInboundRoutingMethod;

#ifdef __cplusplus

class DECLSPEC_UUID("4B9FD75C-0194-4B72-9CE5-02A8205AC7D4")
FaxInboundRoutingMethod;
#endif

EXTERN_C const CLSID CLSID_FaxJobStatus;

#ifdef __cplusplus

class DECLSPEC_UUID("7BF222F4-BE8D-442f-841D-6132742423BB")
FaxJobStatus;
#endif

EXTERN_C const CLSID CLSID_FaxRecipient;

#ifdef __cplusplus

class DECLSPEC_UUID("60BF3301-7DF8-4bd8-9148-7B5801F9EFDF")
FaxRecipient;
#endif


#ifndef __FaxConstants_MODULE_DEFINED__
#define __FaxConstants_MODULE_DEFINED__


/* module FaxConstants */
/* [dllname] */ 

/* [helpstring] */ const long lDEFAULT_PREFETCH_SIZE	=	prv_DEFAULT_PREFETCH_SIZE;

/* [helpstring] */ const BSTR bstrGROUPNAME_ALLDEVICES	=	L"<All Devices>";

#endif /* __FaxConstants_MODULE_DEFINED__ */
#endif /* __FAXCOMEXLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\i386\fre\sdk\faxcontrol.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for faxcontrol.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __faxcontrol_h__
#define __faxcontrol_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IFaxControl_FWD_DEFINED__
#define __IFaxControl_FWD_DEFINED__
typedef interface IFaxControl IFaxControl;
#endif 	/* __IFaxControl_FWD_DEFINED__ */


#ifndef __FaxControl_FWD_DEFINED__
#define __FaxControl_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxControl FaxControl;
#else
typedef struct FaxControl FaxControl;
#endif /* __cplusplus */

#endif 	/* __FaxControl_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IFaxControl_INTERFACE_DEFINED__
#define __IFaxControl_INTERFACE_DEFINED__

/* interface IFaxControl */
/* [unique][helpstring][dual][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_IFaxControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("32B56515-D48B-4DD9-87AC-9216F6BEAA6F")
    IFaxControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsFaxServiceInstalled( 
            /* [retval][out] */ VARIANT_BOOL *pbVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsLocalFaxPrinterInstalled( 
            /* [retval][out] */ VARIANT_BOOL *pbVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallFaxService( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallLocalFaxPrinter( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxControl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxControl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsFaxServiceInstalled )( 
            IFaxControl * This,
            /* [retval][out] */ VARIANT_BOOL *pbVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsLocalFaxPrinterInstalled )( 
            IFaxControl * This,
            /* [retval][out] */ VARIANT_BOOL *pbVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallFaxService )( 
            IFaxControl * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallLocalFaxPrinter )( 
            IFaxControl * This);
        
        END_INTERFACE
    } IFaxControlVtbl;

    interface IFaxControl
    {
        CONST_VTBL struct IFaxControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxControl_get_IsFaxServiceInstalled(This,pbVal)	\
    (This)->lpVtbl -> get_IsFaxServiceInstalled(This,pbVal)

#define IFaxControl_get_IsLocalFaxPrinterInstalled(This,pbVal)	\
    (This)->lpVtbl -> get_IsLocalFaxPrinterInstalled(This,pbVal)

#define IFaxControl_InstallFaxService(This)	\
    (This)->lpVtbl -> InstallFaxService(This)

#define IFaxControl_InstallLocalFaxPrinter(This)	\
    (This)->lpVtbl -> InstallLocalFaxPrinter(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxControl_get_IsFaxServiceInstalled_Proxy( 
    IFaxControl * This,
    /* [retval][out] */ VARIANT_BOOL *pbVal);


void __RPC_STUB IFaxControl_get_IsFaxServiceInstalled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxControl_get_IsLocalFaxPrinterInstalled_Proxy( 
    IFaxControl * This,
    /* [retval][out] */ VARIANT_BOOL *pbVal);


void __RPC_STUB IFaxControl_get_IsLocalFaxPrinterInstalled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxControl_InstallFaxService_Proxy( 
    IFaxControl * This);


void __RPC_STUB IFaxControl_InstallFaxService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxControl_InstallLocalFaxPrinter_Proxy( 
    IFaxControl * This);


void __RPC_STUB IFaxControl_InstallLocalFaxPrinter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxControl_INTERFACE_DEFINED__ */



#ifndef __FAXCONTROLLib_LIBRARY_DEFINED__
#define __FAXCONTROLLib_LIBRARY_DEFINED__

/* library FAXCONTROLLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_FAXCONTROLLib;

EXTERN_C const CLSID CLSID_FaxControl;

#ifdef __cplusplus

class DECLSPEC_UUID("98F63271-6C09-48B3-A571-990155932D0B")
FaxControl;
#endif
#endif /* __FAXCONTROLLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxsrc.inc ===
#
# All binaries will end up in the fax directory
#

# Mapping of old fax image names to new (Whistler) image names.
# fax projects uses this macros to figure out the name of the image they should generate.
# If you want to change the name of an image you should change the macro here and not
# change the project SOURCE file directly.

!ifndef FAXROOT
FAXROOT=$(BASEDIR)\printscan\faxsrv\src
!endif


FAXSETUP=SETUP
FAXSVC=FXSSVC
FAXADMIN=FXSADMIN
WINFAX=FXSAPI
WINFAXP=FXSAPIP
FAXCOM=FXSCOM
FAXCOMEX=FXSCOMEX
FAXDRV=FXSDRV
FAXEVENT=FXSEVENT
FAXMON=FXSMON
FAXPERF=FXSPERF
FAXROUTE=FXSROUTE
FAXTIFF=FXSTIFF
FAXT30=FXST30
FAXUI=FXSUI
FAXXP32=FXSXP32
FAXPNTPRT=FXSPTPRT
ROUTEEXT=FXSRTEXT
FAXQUEUE=FXSQUEUE
FAXCOVER=FXSCOVER
FAXSEND=FXSSEND
FAXEXT32=FXSEXT32
FAXOCM=FXSOCM
FAXCTXTMNU=FXSCTXT
FAXWZRD=FXSWZRD
FAXRES=FXSRES
T30PROP=FXST30P
FxsRouteMethodSnp=FXSRTMTD
FxsRouteExtSnp=FXSRTEXT
MSFXSSNP=FXSADMIN
FAXCOUNT=FXSCOUNT
FAXPERF=FXSPERF
FAXEXT_ECF=FXSEXT
FAXCLIENT=FXSCLNT
FAXCLIENTRES=FXSCLNTR
FAXST=FXSST
FAXCFGWZRD=FXSCFGWZ


BINPLACE_OVERRIDE_FLAGS=
C_DEFINES=$(C_DEFINES) -DBUILD_PRODUCT=$(BUILD_PRODUCT)

!if !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG -DFAX_HEAP_DEBUG
!if "$(PROCESSOR_ARCHITECTURE)" == "x86"
MSC_OPTIMIZATION=-Od
!endif
!endif

!ifndef NOUNICODE
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
LINKLIBS=$(FAXROOT)\util\unicode\$O\faxutil.lib
!else
C_DEFINES=$(C_DEFINES) -D_MBCS
LINKLIBS=$(FAXROOT)\util\ansii\$O\faxutil.lib
!endif

C_DEFINES=$(C_DEFINES) -DTAPI_CURRENT_VERSION=0x00020000 -DNT5BETA2

FAXLIB=$(FAXROOT)\lib

INCLUDES=$(FAXROOT)\inc;$(FAXROOT)\build

MSC_WARNING_LEVEL=/W3 /WX
LINKER_FLAGS=-IGNORE:4006,4088,4104

COMPILER_WARNINGS=-FI$(SDK_INC_PATH)\warning.h -FI$(FAXROOT)\inc\warning.h

!if $(PPC)
COMPILER_WARNINGS=$(COMPILER_WARNINGS) /W3 /WX
!endif

#
# force the build lab's checked
# build machines to have full symbolic
# debug info
#
!if "$(NTDEBUG)" == "cvp"
BINPLACE_FLAGS=$(BINPLACE_FLAGS) -Z
NTDEBUG=ntsd
NTDEBUGTYPE=windbg
!endif

#
# make us completely self contained
#
COFFBASE_TXT_FILE=$(FAXROOT)\NT_coffbase.txt
BINPLACE_PLACEFILE=$(FAXROOT)\NT_placefil.txt


#
# Figure out where to place the images
#

!ifndef OVERRIDE_DEFAULT_BINPLACE
_NTTREE=$(_NTTREE)\fax\i386
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\i386\fre\sdk\winfax.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    winfax.h

Abstract:

    This module contains the WIN32 FAX APIs.

--*/



#ifndef _FAXAPI_
#define _FAXAPI_


#ifndef MIDL_PASS
#include <tapi.h>
#endif

#if !defined(_WINFAX_)
#define WINFAXAPI DECLSPEC_IMPORT
#else
#define WINFAXAPI
#endif



#ifdef __cplusplus
extern "C" {
#endif

//
// FAX ERROR CODES
//

#define FAX_ERR_START                                   7001L   // First fax specific error code

#define FAX_ERR_SRV_OUTOFMEMORY                         7001L
#define FAX_ERR_GROUP_NOT_FOUND                         7002L
#define FAX_ERR_BAD_GROUP_CONFIGURATION                 7003L
#define FAX_ERR_GROUP_IN_USE                            7004L
#define FAX_ERR_RULE_NOT_FOUND                          7005L
#define FAX_ERR_NOT_NTFS                                7006L
#define FAX_ERR_DIRECTORY_IN_USE                        7007L
#define FAX_ERR_FILE_ACCESS_DENIED                      7008L
#define FAX_ERR_MESSAGE_NOT_FOUND                       7009L
#define FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED               7010L
#define FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU               7011L
#define FAX_ERR_VERSION_MISMATCH                        7012L   // Fax client/server versions mismtach

#define FAX_ERR_END                                     7012L   // Last fax specific error code


//
// MessageId: FAX_E_SRV_OUTOFMEMORY
//
// MessageText:
//
//  The fax server failed to allocate memory.
//
#define FAX_E_SRV_OUTOFMEMORY                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_SRV_OUTOFMEMORY)

//
// MessageId: FAX_E_GROUP_NOT_FOUND
//
// MessageText:
//
//  The fax server failed to locate an outbound routing group by name.
//
#define FAX_E_GROUP_NOT_FOUND                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_GROUP_NOT_FOUND)

//
// MessageId: FAX_E_BAD_GROUP_CONFIGURATION
//
// MessageText:
//
//  The fax server encountered an outbound routing group with bad configuration.
//
#define FAX_E_BAD_GROUP_CONFIGURATION        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_BAD_GROUP_CONFIGURATION)

//
// MessageId: FAX_E_GROUP_IN_USE
//
// MessageText:
//
//  The fax server cannot remove an outbound routing group because it is in use by one or more outbound routing rules.
//
#define FAX_E_GROUP_IN_USE                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_GROUP_IN_USE)

//
// MessageId: FAX_E_RULE_NOT_FOUND
//
// MessageText:
//
//  The fax server failed to locate an outbound routing rule by country code and area code.
//
#define FAX_E_RULE_NOT_FOUND                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_RULE_NOT_FOUND)

//
// MessageId: FAX_E_NOT_NTFS
//
// MessageText:
//
//  The fax server cannot set an archive folder to a non-NTFS partition.
//
#define FAX_E_NOT_NTFS                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_NOT_NTFS)

//
// MessageId: FAX_E_DIRECTORY_IN_USE
//
// MessageText:
//
//  The fax server cannot use the same folder for both the inbox and the sent-items archives.
//
#define FAX_E_DIRECTORY_IN_USE               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_DIRECTORY_IN_USE)

//
// MessageId: FAX_E_FILE_ACCESS_DENIED
//
// MessageText:
//
//  The fax server cannot access the specified file or folder.
//
#define FAX_E_FILE_ACCESS_DENIED             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_FILE_ACCESS_DENIED)

//
// MessageId: FAX_E_MESSAGE_NOT_FOUND
//
// MessageText:
//
//  The fax server cannot find the job or message by its ID.
//
#define FAX_E_MESSAGE_NOT_FOUND              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_MESSAGE_NOT_FOUND)

//
// MessageId: FAX_E_DEVICE_NUM_LIMIT_EXCEEDED
//
// MessageText:
//
//  The fax server cannot complete the operation because the number of active fax devices allowed for this version of Windows was exceeded.
//
#define FAX_E_DEVICE_NUM_LIMIT_EXCEEDED      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED)

//
// MessageId: FAX_E_NOT_SUPPORTED_ON_THIS_SKU
//
// MessageText:
//
//  The fax server cannot complete the operation because it is not supported for this version of Windows.
//
#define FAX_E_NOT_SUPPORTED_ON_THIS_SKU      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU)

//
// MessageId: FAX_E_VERSION_MISMATCH
//
// MessageText:
//
//  The fax server API version does not support the requested operation.
//
#define FAX_E_VERSION_MISMATCH               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_VERSION_MISMATCH)

typedef enum
{
    FAXLOG_LEVEL_NONE            = 0,
    FAXLOG_LEVEL_MIN,
    FAXLOG_LEVEL_MED,
    FAXLOG_LEVEL_MAX
} FAX_ENUM_LOG_LEVELS;

typedef enum
{
    FAXLOG_CATEGORY_INIT        = 1,        // Initialization / shutdown
    FAXLOG_CATEGORY_OUTBOUND,               // Outbound messages
    FAXLOG_CATEGORY_INBOUND,                // Inbound messages
    FAXLOG_CATEGORY_UNKNOWN                 // Unknown category (all others)
} FAX_ENUM_LOG_CATEGORIES;

typedef struct _FAX_LOG_CATEGORYA
{
    LPCSTR              Name;                       // logging category name
    DWORD               Category;                   // logging category number
    DWORD               Level;                      // logging level for the category
} FAX_LOG_CATEGORYA, *PFAX_LOG_CATEGORYA;
typedef struct _FAX_LOG_CATEGORYW
{
    LPCWSTR             Name;                       // logging category name
    DWORD               Category;                   // logging category number
    DWORD               Level;                      // logging level for the category
} FAX_LOG_CATEGORYW, *PFAX_LOG_CATEGORYW;
#ifdef UNICODE
typedef FAX_LOG_CATEGORYW FAX_LOG_CATEGORY;
typedef PFAX_LOG_CATEGORYW PFAX_LOG_CATEGORY;
#else
typedef FAX_LOG_CATEGORYA FAX_LOG_CATEGORY;
typedef PFAX_LOG_CATEGORYA PFAX_LOG_CATEGORY;
#endif // UNICODE

typedef struct _FAX_TIME
{
    WORD    Hour;
    WORD    Minute;
} FAX_TIME, *PFAX_TIME;

typedef struct _FAX_CONFIGURATIONA
{
    DWORD               SizeOfStruct;                   // size of this structure
    DWORD               Retries;                        // number of retries for fax send
    DWORD               RetryDelay;                     // number of minutes between retries
    DWORD               DirtyDays;                      // number of days to keep an unsent job in the queue
    BOOL                Branding;                       // fsp should brand outgoing faxes
    BOOL                UseDeviceTsid;                  // server uses device tsid only
    BOOL                ServerCp;                       // clients must use cover pages on the server
    BOOL                PauseServerQueue;               // is the server queue paused?
    FAX_TIME            StartCheapTime;                 // start of discount rate period
    FAX_TIME            StopCheapTime;                  // end of discount rate period
    BOOL                ArchiveOutgoingFaxes;           // whether outgoing faxes should be archived
    LPCSTR              ArchiveDirectory;               // archive directory for outgoing faxes
    LPCSTR              Reserved;                       // Reserved; must be NULL
} FAX_CONFIGURATIONA, *PFAX_CONFIGURATIONA;
typedef struct _FAX_CONFIGURATIONW
{
    DWORD               SizeOfStruct;                   // size of this structure
    DWORD               Retries;                        // number of retries for fax send
    DWORD               RetryDelay;                     // number of minutes between retries
    DWORD               DirtyDays;                      // number of days to keep an unsent job in the queue
    BOOL                Branding;                       // fsp should brand outgoing faxes
    BOOL                UseDeviceTsid;                  // server uses device tsid only
    BOOL                ServerCp;                       // clients must use cover pages on the server
    BOOL                PauseServerQueue;               // is the server queue paused?
    FAX_TIME            StartCheapTime;                 // start of discount rate period
    FAX_TIME            StopCheapTime;                  // end of discount rate period
    BOOL                ArchiveOutgoingFaxes;           // whether outgoing faxes should be archived
    LPCWSTR             ArchiveDirectory;               // archive directory for outgoing faxes
    LPCWSTR             Reserved;                       // Reserved; must be NULL
} FAX_CONFIGURATIONW, *PFAX_CONFIGURATIONW;
#ifdef UNICODE
typedef FAX_CONFIGURATIONW FAX_CONFIGURATION;
typedef PFAX_CONFIGURATIONW PFAX_CONFIGURATION;
#else
typedef FAX_CONFIGURATIONA FAX_CONFIGURATION;
typedef PFAX_CONFIGURATIONA PFAX_CONFIGURATION;
#endif // UNICODE


//
// FaxSetJob() command codes
//

typedef enum
{
    JC_UNKNOWN      = 0,
    JC_DELETE,
    JC_PAUSE,
    JC_RESUME
} FAX_ENUM_JOB_COMMANDS;

#define JC_RESTART   JC_RESUME


//
// job type defines
//

#define JT_UNKNOWN                  0
#define JT_SEND                     1
#define JT_RECEIVE                  2
#define JT_ROUTING                  3
#define JT_FAIL_RECEIVE             4

//
// job status defines
//
#define JS_PENDING                  0x00000000
#define JS_INPROGRESS               0x00000001
#define JS_DELETING                 0x00000002
#define JS_FAILED                   0x00000004
#define JS_PAUSED                   0x00000008
#define JS_NOLINE                   0x00000010
#define JS_RETRYING                 0x00000020
#define JS_RETRIES_EXCEEDED         0x00000040



typedef struct _FAX_DEVICE_STATUSA
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCSTR              CallerId;                   // caller id string
    LPCSTR              Csid;                       // station identifier
    DWORD               CurrentPage;                // current page
    DWORD               DeviceId;                   // permanent line id
    LPCSTR              DeviceName;                 // device name
    LPCSTR              DocumentName;               // document name
    DWORD               JobType;                    // send or receive?
    LPCSTR              PhoneNumber;                // sending phone number
    LPCSTR              RoutingString;              // routing information
    LPCSTR              SenderName;                 // sender name
    LPCSTR              RecipientName;              // recipient name
    DWORD               Size;                       // size in bytes of the document
    FILETIME            StartTime;                  // starting time of the fax send/receive
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    LPCSTR              StatusString;               // status string if the Status field is zero.  this may be NULL.
    FILETIME            SubmittedTime;              // time the document was submitted
    DWORD               TotalPages;                 // total number of pages in this job
    LPCSTR              Tsid;                       // transmitting station identifier
    LPCSTR              UserName;                   // user that submitted the active job
} FAX_DEVICE_STATUSA, *PFAX_DEVICE_STATUSA;
typedef struct _FAX_DEVICE_STATUSW
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCWSTR             CallerId;                   // caller id string
    LPCWSTR             Csid;                       // station identifier
    DWORD               CurrentPage;                // current page
    DWORD               DeviceId;                   // permanent line id
    LPCWSTR             DeviceName;                 // device name
    LPCWSTR             DocumentName;               // document name
    DWORD               JobType;                    // send or receive?
    LPCWSTR             PhoneNumber;                // sending phone number
    LPCWSTR             RoutingString;              // routing information
    LPCWSTR             SenderName;                 // sender name
    LPCWSTR             RecipientName;              // recipient name
    DWORD               Size;                       // size in bytes of the document
    FILETIME            StartTime;                  // starting time of the fax send/receive
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    LPCWSTR             StatusString;               // status string if the Status field is zero.  this may be NULL.
    FILETIME            SubmittedTime;              // time the document was submitted
    DWORD               TotalPages;                 // total number of pages in this job
    LPCWSTR             Tsid;                       // transmitting station identifier
    LPCWSTR             UserName;                   // user that submitted the active job
} FAX_DEVICE_STATUSW, *PFAX_DEVICE_STATUSW;
#ifdef UNICODE
typedef FAX_DEVICE_STATUSW FAX_DEVICE_STATUS;
typedef PFAX_DEVICE_STATUSW PFAX_DEVICE_STATUS;
#else
typedef FAX_DEVICE_STATUSA FAX_DEVICE_STATUS;
typedef PFAX_DEVICE_STATUSA PFAX_DEVICE_STATUS;
#endif // UNICODE

typedef struct _FAX_JOB_ENTRYA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               JobId;                      // fax job id
    LPCSTR              UserName;                   // user who submitted the job
    DWORD               JobType;                    // job type, see JT defines
    DWORD               QueueStatus;                // job queue status, see JS defines
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    DWORD               Size;                       // size in bytes of the document
    DWORD               PageCount;                  // total page count
    LPCSTR              RecipientNumber;            // recipient fax number
    LPCSTR              RecipientName;              // recipient name
    LPCSTR              Tsid;                       // transmitter's id
    LPCSTR              SenderName;                 // sender name
    LPCSTR              SenderCompany;              // sender company
    LPCSTR              SenderDept;                 // sender department
    LPCSTR              BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCSTR              DeliveryReportAddress;      // email address for delivery report (ndr or dr) thru MAPI / SMTP
    LPCSTR              DocumentName;               // document name
} FAX_JOB_ENTRYA, *PFAX_JOB_ENTRYA;
typedef struct _FAX_JOB_ENTRYW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               JobId;                      // fax job id
    LPCWSTR             UserName;                   // user who submitted the job
    DWORD               JobType;                    // job type, see JT defines
    DWORD               QueueStatus;                // job queue status, see JS defines
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    DWORD               Size;                       // size in bytes of the document
    DWORD               PageCount;                  // total page count
    LPCWSTR             RecipientNumber;            // recipient fax number
    LPCWSTR             RecipientName;              // recipient name
    LPCWSTR             Tsid;                       // transmitter's id
    LPCWSTR             SenderName;                 // sender name
    LPCWSTR             SenderCompany;              // sender company
    LPCWSTR             SenderDept;                 // sender department
    LPCWSTR             BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCWSTR             DeliveryReportAddress;      // email address for delivery report (ndr or dr) thru MAPI / SMTP
    LPCWSTR             DocumentName;               // document name
} FAX_JOB_ENTRYW, *PFAX_JOB_ENTRYW;
#ifdef UNICODE
typedef FAX_JOB_ENTRYW FAX_JOB_ENTRY;
typedef PFAX_JOB_ENTRYW PFAX_JOB_ENTRY;
#else
typedef FAX_JOB_ENTRYA FAX_JOB_ENTRY;
typedef PFAX_JOB_ENTRYA PFAX_JOB_ENTRY;
#endif // UNICODE

//
// fax port state masks
//
// if you change these defines the be sure to
// change the resources in the fax service.
//

#define FPS_DIALING              0x20000001
#define FPS_SENDING              0x20000002
#define FPS_RECEIVING            0x20000004
#define FPS_COMPLETED            0x20000008
#define FPS_HANDLED              0x20000010
#define FPS_UNAVAILABLE          0x20000020
#define FPS_BUSY                 0x20000040
#define FPS_NO_ANSWER            0x20000080
#define FPS_BAD_ADDRESS          0x20000100
#define FPS_NO_DIAL_TONE         0x20000200
#define FPS_DISCONNECTED         0x20000400
#define FPS_FATAL_ERROR          0x20000800
#define FPS_NOT_FAX_CALL         0x20001000
#define FPS_CALL_DELAYED         0x20002000
#define FPS_CALL_BLACKLISTED     0x20004000
#define FPS_INITIALIZING         0x20008000
#define FPS_OFFLINE              0x20010000
#define FPS_RINGING              0x20020000

#define FPS_AVAILABLE            0x20100000
#define FPS_ABORTING             0x20200000
#define FPS_ROUTING              0x20400000
#define FPS_ANSWERED             0x20800000

//
// fax port capability mask
//

#define FPF_RECEIVE       0x00000001        // Automatically receive faxes
#define FPF_SEND          0x00000002
#define FPF_VIRTUAL       0x00000004

typedef struct _FAX_PORT_INFOA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // Device ID
    DWORD               State;                      // State of the device
    DWORD               Flags;                      // Device specific flags
    DWORD               Rings;                      // Number of rings before answer
    DWORD               Priority;                   // Device priority
    LPCSTR              DeviceName;                 // Device name
    LPCSTR              Tsid;                       // Device Tsid
    LPCSTR              Csid;                       // Device Csid
} FAX_PORT_INFOA, *PFAX_PORT_INFOA;
typedef struct _FAX_PORT_INFOW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // Device ID
    DWORD               State;                      // State of the device
    DWORD               Flags;                      // Device specific flags
    DWORD               Rings;                      // Number of rings before answer
    DWORD               Priority;                   // Device priority
    LPCWSTR             DeviceName;                 // Device name
    LPCWSTR             Tsid;                       // Device Tsid
    LPCWSTR             Csid;                       // Device Csid
} FAX_PORT_INFOW, *PFAX_PORT_INFOW;
#ifdef UNICODE
typedef FAX_PORT_INFOW FAX_PORT_INFO;
typedef PFAX_PORT_INFOW PFAX_PORT_INFO;
#else
typedef FAX_PORT_INFOA FAX_PORT_INFO;
typedef PFAX_PORT_INFOA PFAX_PORT_INFO;
#endif // UNICODE


typedef struct _FAX_ROUTING_METHODA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // device identifier
    BOOL                Enabled;                    // is this method enabled for this device?
    LPCSTR              DeviceName;                 // device name
    LPCSTR              Guid;                       // guid that identifies this routing method
    LPCSTR              FriendlyName;               // friendly name for this method
    LPCSTR              FunctionName;               // exported function name that identifies this method
    LPCSTR              ExtensionImageName;         // module (dll) name that implements this method
    LPCSTR              ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_ROUTING_METHODA, *PFAX_ROUTING_METHODA;
typedef struct _FAX_ROUTING_METHODW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // device identifier
    BOOL                Enabled;                    // is this method enabled for this device?
    LPCWSTR             DeviceName;                 // device name
    LPCWSTR             Guid;                       // guid that identifies this routing method
    LPCWSTR             FriendlyName;               // friendly name for this method
    LPCWSTR             FunctionName;               // exported function name that identifies this method
    LPCWSTR             ExtensionImageName;         // module (dll) name that implements this method
    LPCWSTR             ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_ROUTING_METHODW, *PFAX_ROUTING_METHODW;
#ifdef UNICODE
typedef FAX_ROUTING_METHODW FAX_ROUTING_METHOD;
typedef PFAX_ROUTING_METHODW PFAX_ROUTING_METHOD;
#else
typedef FAX_ROUTING_METHODA FAX_ROUTING_METHOD;
typedef PFAX_ROUTING_METHODA PFAX_ROUTING_METHOD;
#endif // UNICODE


typedef struct _FAX_GLOBAL_ROUTING_INFOA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               Priority;                   // priority of this device
    LPCSTR              Guid;                       // guid that identifies this routing method
    LPCSTR              FriendlyName;               // friendly name for this method
    LPCSTR              FunctionName;               // exported function name that identifies this method
    LPCSTR              ExtensionImageName;         // module (dll) name that implements this method
    LPCSTR              ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_GLOBAL_ROUTING_INFOA, *PFAX_GLOBAL_ROUTING_INFOA;
typedef struct _FAX_GLOBAL_ROUTING_INFOW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               Priority;                   // priority of this device
    LPCWSTR             Guid;                       // guid that identifies this routing method
    LPCWSTR             FriendlyName;               // friendly name for this method
    LPCWSTR             FunctionName;               // exported function name that identifies this method
    LPCWSTR             ExtensionImageName;         // module (dll) name that implements this method
    LPCWSTR             ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_GLOBAL_ROUTING_INFOW, *PFAX_GLOBAL_ROUTING_INFOW;
#ifdef UNICODE
typedef FAX_GLOBAL_ROUTING_INFOW FAX_GLOBAL_ROUTING_INFO;
typedef PFAX_GLOBAL_ROUTING_INFOW PFAX_GLOBAL_ROUTING_INFO;
#else
typedef FAX_GLOBAL_ROUTING_INFOA FAX_GLOBAL_ROUTING_INFO;
typedef PFAX_GLOBAL_ROUTING_INFOA PFAX_GLOBAL_ROUTING_INFO;
#endif // UNICODE


typedef struct _FAX_COVERPAGE_INFOA
{
    DWORD               SizeOfStruct;               // Size of this structure
    //
    // general
    //
    LPCSTR              CoverPageName;              // coverpage document name
    BOOL                UseServerCoverPage;         // coverpage exists on the fax server
    //
    // Recipient information
    //
    LPCSTR              RecName;                    //
    LPCSTR              RecFaxNumber;               //
    LPCSTR              RecCompany;                 //
    LPCSTR              RecStreetAddress;           //
    LPCSTR              RecCity;                    //
    LPCSTR              RecState;                   //
    LPCSTR              RecZip;                     //
    LPCSTR              RecCountry;                 //
    LPCSTR              RecTitle;                   //
    LPCSTR              RecDepartment;              //
    LPCSTR              RecOfficeLocation;          //
    LPCSTR              RecHomePhone;               //
    LPCSTR              RecOfficePhone;             //
    //
    // Sender information
    //
    LPCSTR              SdrName;                    //
    LPCSTR              SdrFaxNumber;               //
    LPCSTR              SdrCompany;                 //
    LPCSTR              SdrAddress;                 //
    LPCSTR              SdrTitle;                   //
    LPCSTR              SdrDepartment;              //
    LPCSTR              SdrOfficeLocation;          //
    LPCSTR              SdrHomePhone;               //
    LPCSTR              SdrOfficePhone;             //
    //
    // Misc information
    //
    LPCSTR              Note;                       //
    LPCSTR              Subject;                    //
    SYSTEMTIME          TimeSent;                   // Time the fax was sent
    DWORD               PageCount;                  // Number of pages
} FAX_COVERPAGE_INFOA, *PFAX_COVERPAGE_INFOA;
typedef struct _FAX_COVERPAGE_INFOW
{
    DWORD               SizeOfStruct;               // Size of this structure
    //
    // general
    //
    LPCWSTR             CoverPageName;              // coverpage document name
    BOOL                UseServerCoverPage;         // coverpage exists on the fax server
    //
    // Recipient information
    //
    LPCWSTR             RecName;                    //
    LPCWSTR             RecFaxNumber;               //
    LPCWSTR             RecCompany;                 //
    LPCWSTR             RecStreetAddress;           //
    LPCWSTR             RecCity;                    //
    LPCWSTR             RecState;                   //
    LPCWSTR             RecZip;                     //
    LPCWSTR             RecCountry;                 //
    LPCWSTR             RecTitle;                   //
    LPCWSTR             RecDepartment;              //
    LPCWSTR             RecOfficeLocation;          //
    LPCWSTR             RecHomePhone;               //
    LPCWSTR             RecOfficePhone;             //
    //
    // Sender information
    //
    LPCWSTR             SdrName;                    //
    LPCWSTR             SdrFaxNumber;               //
    LPCWSTR             SdrCompany;                 //
    LPCWSTR             SdrAddress;                 //
    LPCWSTR             SdrTitle;                   //
    LPCWSTR             SdrDepartment;              //
    LPCWSTR             SdrOfficeLocation;          //
    LPCWSTR             SdrHomePhone;               //
    LPCWSTR             SdrOfficePhone;             //
    //
    // Misc information
    //
    LPCWSTR             Note;                       //
    LPCWSTR             Subject;                    //
    SYSTEMTIME          TimeSent;                   // Time the fax was sent
    DWORD               PageCount;                  // Number of pages
} FAX_COVERPAGE_INFOW, *PFAX_COVERPAGE_INFOW;
#ifdef UNICODE
typedef FAX_COVERPAGE_INFOW FAX_COVERPAGE_INFO;
typedef PFAX_COVERPAGE_INFOW PFAX_COVERPAGE_INFO;
#else
typedef FAX_COVERPAGE_INFOA FAX_COVERPAGE_INFO;
typedef PFAX_COVERPAGE_INFOA PFAX_COVERPAGE_INFO;
#endif // UNICODE

typedef enum
{
    JSA_NOW                  = 0,   // Send now
    JSA_SPECIFIC_TIME,              // Send at specific time
    JSA_DISCOUNT_PERIOD             // Send at server configured discount period
} FAX_ENUM_JOB_SEND_ATTRIBUTES;

typedef enum
{
    DRT_NONE                = 0x0000,       // Do not send receipt
    DRT_EMAIL               = 0x0001,       // Send receipt by email
    DRT_INBOX               = 0x0002        // send receipt to local inbox
} FAX_ENUM_DELIVERY_REPORT_TYPES;

typedef struct _FAX_JOB_PARAMA
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCSTR              RecipientNumber;            // recipient fax number
    LPCSTR              RecipientName;              // recipient name
    LPCSTR              Tsid;                       // transmitter's id
    LPCSTR              SenderName;                 // sender name
    LPCSTR              SenderCompany;              // sender company
    LPCSTR              SenderDept;                 // sender department
    LPCSTR              BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCSTR              DeliveryReportAddress;      // email address for delivery report (ndr or dr) thru MAPI / SMTP
    LPCSTR              DocumentName;               // document name (optional)
    HCALL               CallHandle;                 // optional call handle
    DWORD_PTR           Reserved[3];                // reserved for ms use only
} FAX_JOB_PARAMA, *PFAX_JOB_PARAMA;
typedef struct _FAX_JOB_PARAMW
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCWSTR             RecipientNumber;            // recipient fax number
    LPCWSTR             RecipientName;              // recipient name
    LPCWSTR             Tsid;                       // transmitter's id
    LPCWSTR             SenderName;                 // sender name
    LPCWSTR             SenderCompany;              // sender company
    LPCWSTR             SenderDept;                 // sender department
    LPCWSTR             BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCWSTR             DeliveryReportAddress;      // email address for delivery report (ndr or dr) thru MAPI / SMTP
    LPCWSTR             DocumentName;               // document name (optional)
    HCALL               CallHandle;                 // optional call handle
    DWORD_PTR           Reserved[3];                // reserved for ms use only
} FAX_JOB_PARAMW, *PFAX_JOB_PARAMW;
#ifdef UNICODE
typedef FAX_JOB_PARAMW FAX_JOB_PARAM;
typedef PFAX_JOB_PARAMW PFAX_JOB_PARAM;
#else
typedef FAX_JOB_PARAMA FAX_JOB_PARAM;
typedef PFAX_JOB_PARAMA PFAX_JOB_PARAM;
#endif // UNICODE

//
// Event Ids
//
// FEI_NEVENTS is the number of events
//

#define FEI_DIALING                 0x00000001
#define FEI_SENDING                 0x00000002
#define FEI_RECEIVING               0x00000003
#define FEI_COMPLETED               0x00000004
#define FEI_BUSY                    0x00000005
#define FEI_NO_ANSWER               0x00000006
#define FEI_BAD_ADDRESS             0x00000007
#define FEI_NO_DIAL_TONE            0x00000008
#define FEI_DISCONNECTED            0x00000009
#define FEI_FATAL_ERROR             0x0000000a
#define FEI_NOT_FAX_CALL            0x0000000b
#define FEI_CALL_DELAYED            0x0000000c
#define FEI_CALL_BLACKLISTED        0x0000000d
#define FEI_RINGING                 0x0000000e
#define FEI_ABORTING                0x0000000f
#define FEI_ROUTING                 0x00000010
#define FEI_MODEM_POWERED_ON        0x00000011
#define FEI_MODEM_POWERED_OFF       0x00000012
#define FEI_IDLE                    0x00000013
#define FEI_FAXSVC_ENDED            0x00000014
#define FEI_ANSWERED                0x00000015
#define FEI_JOB_QUEUED              0x00000016
#define FEI_DELETED                 0x00000017
#define FEI_INITIALIZING            0x00000018
#define FEI_LINE_UNAVAILABLE        0x00000019
#define FEI_HANDLED                 0x0000001a
#define FEI_FAXSVC_STARTED          0x0000001b

#define FEI_NEVENTS                 FEI_FAXSVC_STARTED

typedef struct _FAX_EVENTA
{
    DWORD               SizeOfStruct;               // Size of this structure
    FILETIME            TimeStamp;                  // Timestamp for when the event was generated
    DWORD               DeviceId;                   // Permanent line id
    DWORD               EventId;                    // Current event id
    DWORD               JobId;                      // Fax Job Id, 0xffffffff indicates inactive job
} FAX_EVENTA, *PFAX_EVENTA;
typedef struct _FAX_EVENTW
{
    DWORD               SizeOfStruct;               // Size of this structure
    FILETIME            TimeStamp;                  // Timestamp for when the event was generated
    DWORD               DeviceId;                   // Permanent line id
    DWORD               EventId;                    // Current event id
    DWORD               JobId;                      // Fax Job Id, 0xffffffff indicates inactive job
} FAX_EVENTW, *PFAX_EVENTW;
#ifdef UNICODE
typedef FAX_EVENTW FAX_EVENT;
typedef PFAX_EVENTW PFAX_EVENT;
#else
typedef FAX_EVENTA FAX_EVENT;
typedef PFAX_EVENTA PFAX_EVENT;
#endif // UNICODE


typedef struct _FAX_PRINT_INFOA
{
    DWORD               SizeOfStruct;               // Size of this structure
    LPCSTR              DocName;                    // Document name that appears in the spooler
    LPCSTR              RecipientName;              // Recipient name
    LPCSTR              RecipientNumber;            // Recipient fax number (non-canonical number)
    LPCSTR              SenderName;                 // Sender name
    LPCSTR              SenderCompany;              // Sender company (optional)
    LPCSTR              SenderDept;                 // Sender department
    LPCSTR              SenderBillingCode;          // Billing code
    LPCSTR              Reserved;                   // Reserved; must be NULL
    LPCSTR              DrEmailAddress;             // E.Mail address for delivery report
    LPCSTR              OutputFileName;             // for print to file, resulting file name
} FAX_PRINT_INFOA, *PFAX_PRINT_INFOA;
typedef struct _FAX_PRINT_INFOW
{
    DWORD               SizeOfStruct;               // Size of this structure
    LPCWSTR             DocName;                    // Document name that appears in the spooler
    LPCWSTR             RecipientName;              // Recipient name
    LPCWSTR             RecipientNumber;            // Recipient fax number (non-canonical number)
    LPCWSTR             SenderName;                 // Sender name
    LPCWSTR             SenderCompany;              // Sender company (optional)
    LPCWSTR             SenderDept;                 // Sender department
    LPCWSTR             SenderBillingCode;          // Billing code
    LPCWSTR             Reserved;                   // Reserved; must be NULL
    LPCWSTR             DrEmailAddress;             // E.Mail address for delivery report
    LPCWSTR             OutputFileName;             // for print to file, resulting file name
} FAX_PRINT_INFOW, *PFAX_PRINT_INFOW;
#ifdef UNICODE
typedef FAX_PRINT_INFOW FAX_PRINT_INFO;
typedef PFAX_PRINT_INFOW PFAX_PRINT_INFO;
#else
typedef FAX_PRINT_INFOA FAX_PRINT_INFO;
typedef PFAX_PRINT_INFOA PFAX_PRINT_INFO;
#endif // UNICODE


typedef struct _FAX_CONTEXT_INFOA
{
    DWORD               SizeOfStruct;                           // Size of this structure
    HDC                 hDC;                                    // Device Context
    CHAR                ServerName[MAX_COMPUTERNAME_LENGTH+1];  // Server name
} FAX_CONTEXT_INFOA, *PFAX_CONTEXT_INFOA;
typedef struct _FAX_CONTEXT_INFOW
{
    DWORD               SizeOfStruct;                           // Size of this structure
    HDC                 hDC;                                    // Device Context
    WCHAR               ServerName[MAX_COMPUTERNAME_LENGTH+1];  // Server name
} FAX_CONTEXT_INFOW, *PFAX_CONTEXT_INFOW;
#ifdef UNICODE
typedef FAX_CONTEXT_INFOW FAX_CONTEXT_INFO;
typedef PFAX_CONTEXT_INFOW PFAX_CONTEXT_INFO;
#else
typedef FAX_CONTEXT_INFOA FAX_CONTEXT_INFO;
typedef PFAX_CONTEXT_INFOA PFAX_CONTEXT_INFO;
#endif // UNICODE


//
// prototypes
//

WINFAXAPI
BOOL
WINAPI
FaxConnectFaxServerA(
    IN  LPCSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
WINFAXAPI
BOOL
WINAPI
FaxConnectFaxServerW(
    IN  LPCWSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
#ifdef UNICODE
#define FaxConnectFaxServer  FaxConnectFaxServerW
#else
#define FaxConnectFaxServer  FaxConnectFaxServerA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXCONNECTFAXSERVERA)(
    IN  LPCSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
typedef BOOL
(WINAPI *PFAXCONNECTFAXSERVERW)(
    IN  LPCWSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
#ifdef UNICODE
#define PFAXCONNECTFAXSERVER  PFAXCONNECTFAXSERVERW
#else
#define PFAXCONNECTFAXSERVER  PFAXCONNECTFAXSERVERA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxClose(
    IN HANDLE FaxHandle
    );

typedef BOOL
(WINAPI *PFAXCLOSE)(
    IN HANDLE FaxHandle
    );

typedef enum
{
    PORT_OPEN_QUERY     = 1,
    PORT_OPEN_MODIFY
} FAX_ENUM_PORT_OPEN_TYPE;

WINFAXAPI
BOOL
WINAPI
FaxOpenPort(
    IN  HANDLE FaxHandle,
    IN  DWORD DeviceId,
    IN  DWORD Flags,
    OUT LPHANDLE FaxPortHandle
    );

typedef BOOL
(WINAPI *PFAXOPENPORT)(
    IN  HANDLE FaxHandle,
    IN  DWORD DeviceId,
    IN  DWORD Flags,
    OUT LPHANDLE FaxPortHandle
    );

WINFAXAPI
BOOL
WINAPI
FaxCompleteJobParamsA(
    IN OUT PFAX_JOB_PARAMA *JobParams,
    IN OUT PFAX_COVERPAGE_INFOA *CoverpageInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxCompleteJobParamsW(
    IN OUT PFAX_JOB_PARAMW *JobParams,
    IN OUT PFAX_COVERPAGE_INFOW *CoverpageInfo
    );
#ifdef UNICODE
#define FaxCompleteJobParams  FaxCompleteJobParamsW
#else
#define FaxCompleteJobParams  FaxCompleteJobParamsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXCOMPLETEJOBPARAMSA)(
    IN OUT PFAX_JOB_PARAMA *JobParams,
    IN OUT PFAX_COVERPAGE_INFOA *CoverpageInfo
    );
typedef BOOL
(WINAPI *PFAXCOMPLETEJOBPARAMSW)(
    IN OUT PFAX_JOB_PARAMW *JobParams,
    IN OUT PFAX_COVERPAGE_INFOW *CoverpageInfo
    );
#ifdef UNICODE
#define PFAXCOMPLETEJOBPARAMS  PFAXCOMPLETEJOBPARAMSW
#else
#define PFAXCOMPLETEJOBPARAMS  PFAXCOMPLETEJOBPARAMSA
#endif // !UNICODE



WINFAXAPI
BOOL
WINAPI
FaxSendDocumentA(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    IN PFAX_JOB_PARAMA JobParams,
    IN const FAX_COVERPAGE_INFOA *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
WINFAXAPI
BOOL
WINAPI
FaxSendDocumentW(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    IN PFAX_JOB_PARAMW JobParams,
    IN const FAX_COVERPAGE_INFOW *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
#ifdef UNICODE
#define FaxSendDocument  FaxSendDocumentW
#else
#define FaxSendDocument  FaxSendDocumentA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSENDDOCUMENTA)(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    IN PFAX_JOB_PARAMA JobParams,
    IN const FAX_COVERPAGE_INFOA *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
typedef BOOL
(WINAPI *PFAXSENDDOCUMENTW)(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    IN PFAX_JOB_PARAMW JobParams,
    IN const FAX_COVERPAGE_INFOW *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
#ifdef UNICODE
#define PFAXSENDDOCUMENT  PFAXSENDDOCUMENTW
#else
#define PFAXSENDDOCUMENT  PFAXSENDDOCUMENTA
#endif // !UNICODE

typedef BOOL
(CALLBACK *PFAX_RECIPIENT_CALLBACKA)(
    IN HANDLE FaxHandle,
    IN DWORD RecipientNumber,
    IN LPVOID Context,
    IN OUT PFAX_JOB_PARAMA JobParams,
    IN OUT PFAX_COVERPAGE_INFOA CoverpageInfo OPTIONAL
    );
typedef BOOL
(CALLBACK *PFAX_RECIPIENT_CALLBACKW)(
    IN HANDLE FaxHandle,
    IN DWORD RecipientNumber,
    IN LPVOID Context,
    IN OUT PFAX_JOB_PARAMW JobParams,
    IN OUT PFAX_COVERPAGE_INFOW CoverpageInfo OPTIONAL
    );
#ifdef UNICODE
#define PFAX_RECIPIENT_CALLBACK  PFAX_RECIPIENT_CALLBACKW
#else
#define PFAX_RECIPIENT_CALLBACK  PFAX_RECIPIENT_CALLBACKA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSendDocumentForBroadcastA(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    OUT LPDWORD FaxJobId,
    IN PFAX_RECIPIENT_CALLBACKA FaxRecipientCallback,
    IN LPVOID Context
    );
WINFAXAPI
BOOL
WINAPI
FaxSendDocumentForBroadcastW(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    OUT LPDWORD FaxJobId,
    IN PFAX_RECIPIENT_CALLBACKW FaxRecipientCallback,
    IN LPVOID Context
    );
#ifdef UNICODE
#define FaxSendDocumentForBroadcast  FaxSendDocumentForBroadcastW
#else
#define FaxSendDocumentForBroadcast  FaxSendDocumentForBroadcastA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSENDDOCUMENTFORBROADCASTA)(
    IN  HANDLE FaxHandle,
    IN  LPCSTR FileName,
    OUT LPDWORD FaxJobId,
    IN  PFAX_RECIPIENT_CALLBACKA FaxRecipientCallback,
    IN  LPVOID Context
    );
typedef BOOL
(WINAPI *PFAXSENDDOCUMENTFORBROADCASTW)(
    IN  HANDLE FaxHandle,
    IN  LPCWSTR FileName,
    OUT LPDWORD FaxJobId,
    IN  PFAX_RECIPIENT_CALLBACKW FaxRecipientCallback,
    IN  LPVOID Context
    );
#ifdef UNICODE
#define PFAXSENDDOCUMENTFORBROADCAST  PFAXSENDDOCUMENTFORBROADCASTW
#else
#define PFAXSENDDOCUMENTFORBROADCAST  PFAXSENDDOCUMENTFORBROADCASTA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxEnumJobsA(
    IN  HANDLE FaxHandle,
    OUT PFAX_JOB_ENTRYA *JobEntry,
    OUT LPDWORD JobsReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxEnumJobsW(
    IN  HANDLE FaxHandle,
    OUT PFAX_JOB_ENTRYW *JobEntry,
    OUT LPDWORD JobsReturned
    );
#ifdef UNICODE
#define FaxEnumJobs  FaxEnumJobsW
#else
#define FaxEnumJobs  FaxEnumJobsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENUMJOBSA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_JOB_ENTRYA *JobEntry,
    OUT LPDWORD JobsReturned
    );
typedef BOOL
(WINAPI *PFAXENUMJOBSW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_JOB_ENTRYW *JobEntry,
    OUT LPDWORD JobsReturned
    );
#ifdef UNICODE
#define PFAXENUMJOBS  PFAXENUMJOBSW
#else
#define PFAXENUMJOBS  PFAXENUMJOBSA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxGetJobA(
   IN  HANDLE FaxHandle,
   IN  DWORD JobId,
   OUT PFAX_JOB_ENTRYA *JobEntry
   );
WINFAXAPI
BOOL
WINAPI
FaxGetJobW(
   IN  HANDLE FaxHandle,
   IN  DWORD JobId,
   OUT PFAX_JOB_ENTRYW *JobEntry
   );
#ifdef UNICODE
#define FaxGetJob  FaxGetJobW
#else
#define FaxGetJob  FaxGetJobA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETJOBA)(
    IN  HANDLE FaxHandle,
    IN  DWORD JobId,
    OUT PFAX_JOB_ENTRYA *JobEntry
    );
typedef BOOL
(WINAPI *PFAXGETJOBW)(
    IN  HANDLE FaxHandle,
    IN  DWORD JobId,
    OUT PFAX_JOB_ENTRYW *JobEntry
    );
#ifdef UNICODE
#define PFAXGETJOB  PFAXGETJOBW
#else
#define PFAXGETJOB  PFAXGETJOBA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxSetJobA(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN DWORD Command,
   IN const FAX_JOB_ENTRYA *JobEntry
   );
WINFAXAPI
BOOL
WINAPI
FaxSetJobW(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN DWORD Command,
   IN const FAX_JOB_ENTRYW *JobEntry
   );
#ifdef UNICODE
#define FaxSetJob  FaxSetJobW
#else
#define FaxSetJob  FaxSetJobA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETJOBA)(
    IN HANDLE FaxHandle,
    IN DWORD JobId,
    IN DWORD Command,
    IN const FAX_JOB_ENTRYA *JobEntry
    );
typedef BOOL
(WINAPI *PFAXSETJOBW)(
    IN HANDLE FaxHandle,
    IN DWORD JobId,
    IN DWORD Command,
    IN const FAX_JOB_ENTRYW *JobEntry
    );
#ifdef UNICODE
#define PFAXSETJOB  PFAXSETJOBW
#else
#define PFAXSETJOB  PFAXSETJOBA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetPageData(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   OUT LPBYTE *Buffer,
   OUT LPDWORD BufferSize,
   OUT LPDWORD ImageWidth,
   OUT LPDWORD ImageHeight
   );

typedef BOOL
(WINAPI *PFAXGETPAGEDATA)(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   OUT LPBYTE *Buffer,
   OUT LPDWORD BufferSize,
   OUT LPDWORD ImageWidth,
   OUT LPDWORD ImageHeight
   );

WINFAXAPI
BOOL
WINAPI
FaxGetDeviceStatusA(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSA *DeviceStatus
    );
WINFAXAPI
BOOL
WINAPI
FaxGetDeviceStatusW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSW *DeviceStatus
    );
#ifdef UNICODE
#define FaxGetDeviceStatus  FaxGetDeviceStatusW
#else
#define FaxGetDeviceStatus  FaxGetDeviceStatusA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETDEVICESTATUSA)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSA *DeviceStatus
    );
typedef BOOL
(WINAPI *PFAXGETDEVICESTATUSW)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSW *DeviceStatus
    );
#ifdef UNICODE
#define PFAXGETDEVICESTATUS  PFAXGETDEVICESTATUSW
#else
#define PFAXGETDEVICESTATUS  PFAXGETDEVICESTATUSA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxAbort(
    IN HANDLE FaxHandle,
    IN DWORD JobId
    );

typedef BOOL
(WINAPI *PFAXABORT)(
    IN HANDLE FaxHandle,
    IN DWORD JobId
    );

WINFAXAPI
BOOL
WINAPI
FaxGetConfigurationA(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONA *FaxConfig
    );
WINFAXAPI
BOOL
WINAPI
FaxGetConfigurationW(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define FaxGetConfiguration  FaxGetConfigurationW
#else
#define FaxGetConfiguration  FaxGetConfigurationA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETCONFIGURATIONA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONA *FaxConfig
    );
typedef BOOL
(WINAPI *PFAXGETCONFIGURATIONW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define PFAXGETCONFIGURATION  PFAXGETCONFIGURATIONW
#else
#define PFAXGETCONFIGURATION  PFAXGETCONFIGURATIONA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetConfigurationA(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONA *FaxConfig
    );
WINFAXAPI
BOOL
WINAPI
FaxSetConfigurationW(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define FaxSetConfiguration  FaxSetConfigurationW
#else
#define FaxSetConfiguration  FaxSetConfigurationA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETCONFIGURATIONA)(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONA *FaxConfig
    );
typedef BOOL
(WINAPI *PFAXSETCONFIGURATIONW)(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define PFAXSETCONFIGURATION  PFAXSETCONFIGURATIONW
#else
#define PFAXSETCONFIGURATION  PFAXSETCONFIGURATIONA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetLoggingCategoriesA(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYA *Categories,
    OUT LPDWORD NumberCategories
    );
WINFAXAPI
BOOL
WINAPI
FaxGetLoggingCategoriesW(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYW *Categories,
    OUT LPDWORD NumberCategories
    );
#ifdef UNICODE
#define FaxGetLoggingCategories  FaxGetLoggingCategoriesW
#else
#define FaxGetLoggingCategories  FaxGetLoggingCategoriesA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETLOGGINGCATEGORIESA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYA *Categories,
    OUT LPDWORD NumberCategories
    );
typedef BOOL
(WINAPI *PFAXGETLOGGINGCATEGORIESW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYW *Categories,
    OUT LPDWORD NumberCategories
    );
#ifdef UNICODE
#define PFAXGETLOGGINGCATEGORIES  PFAXGETLOGGINGCATEGORIESW
#else
#define PFAXGETLOGGINGCATEGORIES  PFAXGETLOGGINGCATEGORIESA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetLoggingCategoriesA(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYA *Categories,
    IN  DWORD NumberCategories
    );
WINFAXAPI
BOOL
WINAPI
FaxSetLoggingCategoriesW(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYW *Categories,
    IN  DWORD NumberCategories
    );
#ifdef UNICODE
#define FaxSetLoggingCategories  FaxSetLoggingCategoriesW
#else
#define FaxSetLoggingCategories  FaxSetLoggingCategoriesA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETLOGGINGCATEGORIESA)(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYA *Categories,
    IN  DWORD NumberCategories
    );
typedef BOOL
(WINAPI *PFAXSETLOGGINGCATEGORIESW)(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYW *Categories,
    IN  DWORD NumberCategories
    );
#ifdef UNICODE
#define PFAXSETLOGGINGCATEGORIES  PFAXSETLOGGINGCATEGORIESW
#else
#define PFAXSETLOGGINGCATEGORIES  PFAXSETLOGGINGCATEGORIESA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumPortsA(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOA *PortInfo,
    OUT LPDWORD PortsReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxEnumPortsW(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOW *PortInfo,
    OUT LPDWORD PortsReturned
    );
#ifdef UNICODE
#define FaxEnumPorts  FaxEnumPortsW
#else
#define FaxEnumPorts  FaxEnumPortsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENUMPORTSA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOA *PortInfo,
    OUT LPDWORD PortsReturned
    );
typedef BOOL
(WINAPI *PFAXENUMPORTSW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOW *PortInfo,
    OUT LPDWORD PortsReturned
    );
#ifdef UNICODE
#define PFAXENUMPORTS  PFAXENUMPORTSW
#else
#define PFAXENUMPORTS  PFAXENUMPORTSA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetPortA(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOA *PortInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxGetPortW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define FaxGetPort  FaxGetPortW
#else
#define FaxGetPort  FaxGetPortA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETPORTA)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOA *PortInfo
    );
typedef BOOL
(WINAPI *PFAXGETPORTW)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define PFAXGETPORT  PFAXGETPORTW
#else
#define PFAXGETPORT  PFAXGETPORTA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetPortA(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOA *PortInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxSetPortW(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define FaxSetPort  FaxSetPortW
#else
#define FaxSetPort  FaxSetPortA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETPORTA)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOA *PortInfo
    );
typedef BOOL
(WINAPI *PFAXSETPORTW)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define PFAXSETPORT  PFAXSETPORTW
#else
#define PFAXSETPORT  PFAXSETPORTA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumRoutingMethodsA(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODA *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxEnumRoutingMethodsW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODW *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define FaxEnumRoutingMethods  FaxEnumRoutingMethodsW
#else
#define FaxEnumRoutingMethods  FaxEnumRoutingMethodsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENUMROUTINGMETHODSA)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODA *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
typedef BOOL
(WINAPI *PFAXENUMROUTINGMETHODSW)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODW *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define PFAXENUMROUTINGMETHODS  PFAXENUMROUTINGMETHODSW
#else
#define PFAXENUMROUTINGMETHODS  PFAXENUMROUTINGMETHODSA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnableRoutingMethodA(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  BOOL Enabled
    );
WINFAXAPI
BOOL
WINAPI
FaxEnableRoutingMethodW(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  BOOL Enabled
    );
#ifdef UNICODE
#define FaxEnableRoutingMethod  FaxEnableRoutingMethodW
#else
#define FaxEnableRoutingMethod  FaxEnableRoutingMethodA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENABLEROUTINGMETHODA)(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  BOOL Enabled
    );
typedef BOOL
(WINAPI *PFAXENABLEROUTINGMETHODW)(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  BOOL Enabled
    );
#ifdef UNICODE
#define PFAXENABLEROUTINGMETHOD  PFAXENABLEROUTINGMETHODW
#else
#define PFAXENABLEROUTINGMETHOD  PFAXENABLEROUTINGMETHODA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxEnumGlobalRoutingInfoA(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOA *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxEnumGlobalRoutingInfoW(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOW *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define FaxEnumGlobalRoutingInfo  FaxEnumGlobalRoutingInfoW
#else
#define FaxEnumGlobalRoutingInfo  FaxEnumGlobalRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENUMGLOBALROUTINGINFOA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOA *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
typedef BOOL
(WINAPI *PFAXENUMGLOBALROUTINGINFOW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOW *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define PFAXENUMGLOBALROUTINGINFO  PFAXENUMGLOBALROUTINGINFOW
#else
#define PFAXENUMGLOBALROUTINGINFO  PFAXENUMGLOBALROUTINGINFOA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetGlobalRoutingInfoA(
    IN  HANDLE FaxHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOA *RoutingInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxSetGlobalRoutingInfoW(
    IN  HANDLE FaxHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOW *RoutingInfo
    );
#ifdef UNICODE
#define FaxSetGlobalRoutingInfo  FaxSetGlobalRoutingInfoW
#else
#define FaxSetGlobalRoutingInfo  FaxSetGlobalRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETGLOBALROUTINGINFOA)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOA *RoutingInfo
    );
typedef BOOL
(WINAPI *PFAXSETGLOBALROUTINGINFOW)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOW *RoutingInfo
    );
#ifdef UNICODE
#define PFAXSETGLOBALROUTINGINFO  PFAXSETGLOBALROUTINGINFOW
#else
#define PFAXSETGLOBALROUTINGINFO  PFAXSETGLOBALROUTINGINFOA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetRoutingInfoA(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
WINFAXAPI
BOOL
WINAPI
FaxGetRoutingInfoW(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define FaxGetRoutingInfo  FaxGetRoutingInfoW
#else
#define FaxGetRoutingInfo  FaxGetRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETROUTINGINFOA)(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
typedef BOOL
(WINAPI *PFAXGETROUTINGINFOW)(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define PFAXGETROUTINGINFO  PFAXGETROUTINGINFOW
#else
#define PFAXGETROUTINGINFO  PFAXGETROUTINGINFOA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxSetRoutingInfoA(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
WINFAXAPI
BOOL
WINAPI
FaxSetRoutingInfoW(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define FaxSetRoutingInfo  FaxSetRoutingInfoW
#else
#define FaxSetRoutingInfo  FaxSetRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETROUTINGINFOA)(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
typedef BOOL
(WINAPI *PFAXSETROUTINGINFOW)(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define PFAXSETROUTINGINFO  PFAXSETROUTINGINFOW
#else
#define PFAXSETROUTINGINFO  PFAXSETROUTINGINFOA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxInitializeEventQueue(
    IN HANDLE FaxHandle,
    IN HANDLE CompletionPort,
    IN ULONG_PTR CompletionKey,
    IN HWND hWnd,
    IN UINT MessageStart
    );

typedef BOOL
(WINAPI *PFAXINITIALIZEEVENTQUEUE)(
    IN HANDLE FaxHandle,
    IN HANDLE CompletionPort,
    IN ULONG_PTR CompletionKey,
    IN HWND hWnd,
    IN UINT MessageStart
    );

WINFAXAPI
VOID
WINAPI
FaxFreeBuffer(
    LPVOID Buffer
    );

typedef VOID
(WINAPI *PFAXFREEBUFFER)(
    LPVOID Buffer
    );

WINFAXAPI
BOOL
WINAPI
FaxStartPrintJobA(
    IN  LPCSTR PrinterName,
    IN  const FAX_PRINT_INFOA *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOA FaxContextInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxStartPrintJobW(
    IN  LPCWSTR PrinterName,
    IN  const FAX_PRINT_INFOW *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOW FaxContextInfo
    );
#ifdef UNICODE
#define FaxStartPrintJob  FaxStartPrintJobW
#else
#define FaxStartPrintJob  FaxStartPrintJobA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSTARTPRINTJOBA)(
    IN  LPCSTR PrinterName,
    IN  const FAX_PRINT_INFOA *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOA FaxContextInfo
    );
typedef BOOL
(WINAPI *PFAXSTARTPRINTJOBW)(
    IN  LPCWSTR PrinterName,
    IN  const FAX_PRINT_INFOW *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOW FaxContextInfo
    );
#ifdef UNICODE
#define PFAXSTARTPRINTJOB  PFAXSTARTPRINTJOBW
#else
#define PFAXSTARTPRINTJOB  PFAXSTARTPRINTJOBA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxPrintCoverPageA(
    IN const FAX_CONTEXT_INFOA *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOA *CoverPageInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxPrintCoverPageW(
    IN const FAX_CONTEXT_INFOW *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOW *CoverPageInfo
    );
#ifdef UNICODE
#define FaxPrintCoverPage  FaxPrintCoverPageW
#else
#define FaxPrintCoverPage  FaxPrintCoverPageA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXPRINTCOVERPAGEA)(
    IN const FAX_CONTEXT_INFOA *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOA *CoverPageInfo
    );
typedef BOOL
(WINAPI *PFAXPRINTCOVERPAGEW)(
    IN const FAX_CONTEXT_INFOW *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOW *CoverPageInfo
    );
#ifdef UNICODE
#define PFAXPRINTCOVERPAGE  PFAXPRINTCOVERPAGEW
#else
#define PFAXPRINTCOVERPAGE  PFAXPRINTCOVERPAGEA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxRegisterServiceProviderW(
    IN LPCWSTR DeviceProvider,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN LPCWSTR TspName
    );

#define FaxRegisterServiceProvider  FaxRegisterServiceProviderW

typedef BOOL
(WINAPI *PFAXREGISTERSERVICEPROVIDERW)(
    IN LPCWSTR DeviceProvider,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN LPCWSTR TspName
    );

#define PFAXREGISTERSERVICEPROVIDER PFAXREGISTERSERVICEPROVIDERW

typedef BOOL
(CALLBACK *PFAX_ROUTING_INSTALLATION_CALLBACKW)(
    IN HANDLE FaxHandle,
    IN LPVOID Context,
    IN OUT LPWSTR MethodName,
    IN OUT LPWSTR FriendlyName,
    IN OUT LPWSTR FunctionName,
    IN OUT LPWSTR Guid
    );

#define PFAX_ROUTING_INSTALLATION_CALLBACK PFAX_ROUTING_INSTALLATION_CALLBACKW


WINFAXAPI
BOOL
WINAPI
FaxRegisterRoutingExtensionW(
    IN HANDLE  FaxHandle,
    IN LPCWSTR ExtensionName,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN PFAX_ROUTING_INSTALLATION_CALLBACKW CallBack,
    IN LPVOID Context
    );

#define FaxRegisterRoutingExtension FaxRegisterRoutingExtensionW


typedef BOOL
(WINAPI *PFAXREGISTERROUTINGEXTENSIONW)(
    IN HANDLE  FaxHandle,
    IN LPCWSTR ExtensionName,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN PFAX_ROUTING_INSTALLATION_CALLBACKW CallBack,
    IN LPVOID Context
    );

#define PFAXREGISTERROUTINGEXTENSION PFAXREGISTERROUTINGEXTENSIONW

WINFAXAPI
BOOL
WINAPI
FaxUnregisterRoutingExtensionA(
    IN HANDLE           hFaxHandle,
    IN LPCSTR         lpctstrExtensionName
);
WINFAXAPI
BOOL
WINAPI
FaxUnregisterRoutingExtensionW(
    IN HANDLE           hFaxHandle,
    IN LPCWSTR         lpctstrExtensionName
);
#ifdef UNICODE
#define FaxUnregisterRoutingExtension  FaxUnregisterRoutingExtensionW
#else
#define FaxUnregisterRoutingExtension  FaxUnregisterRoutingExtensionA
#endif // !UNICODE




WINFAXAPI
BOOL
WINAPI
FaxAccessCheck(
    IN HANDLE FaxHandle,
    IN DWORD  AccessMask
    );

typedef BOOL
(WINAPI *PFAXACCESSCHECK)(
    IN HANDLE FaxHandle,
    IN DWORD  AccessMask
    );

//
// Fax Specific Access Rights
//

#define FAX_JOB_SUBMIT          (0x0001)
#define FAX_JOB_QUERY           (0x0002)
#define FAX_CONFIG_QUERY        (0x0004)
#define FAX_CONFIG_SET          (0x0008)
#define FAX_PORT_QUERY          (0x0010)
#define FAX_PORT_SET            (0x0020)
#define FAX_JOB_MANAGE          (0x0040)

#define FAX_READ                (STANDARD_RIGHTS_READ        |\
                                 FAX_JOB_QUERY               |\
                                 FAX_CONFIG_QUERY            |\
                                 FAX_PORT_QUERY)

#define FAX_WRITE               (STANDARD_RIGHTS_WRITE       |\
                                 FAX_JOB_SUBMIT )

#define FAX_ALL_ACCESS          (STANDARD_RIGHTS_ALL         |\
                                 FAX_JOB_SUBMIT              |\
                                 FAX_JOB_QUERY               |\
                                 FAX_CONFIG_QUERY            |\
                                 FAX_CONFIG_SET              |\
                                 FAX_PORT_QUERY              |\
                                 FAX_PORT_SET                |\
                                 FAX_JOB_MANAGE)



#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\placew9x.inc ===
_NTTREE=$(_NTTREE)\..\clients\WIN9X
OVERRIDE_DEFAULT_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\cfgwzrd\faxcfgwzexp.h ===
#ifndef _FAX_CONFIG_WIZARD_EXPORT_H_
#define _FAX_CONFIG_WIZARD_EXPORT_H_

#ifdef __cplusplus
extern "C" {
#endif

// Functions in FaxCfgWz.c
BOOL FaxConfigWizard(BOOL bExplicitLaunch, LPBOOL lpbAbort);

typedef BOOL (*FAX_CONFIG_WIZARD)(BOOL, LPBOOL);

#define FAX_CONFIG_WIZARD_PROC  "FaxConfigWizard"

#define FAX_CONFIG_WIZARD_DLL   TEXT("FxsCfgWz.dll")

#ifdef __cplusplus
}
#endif

#endif // _FAX_CONFIG_WIZARD_EXPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\cfgwzrd\dll.c ===
/*++

Copyright (c) 1999 - 2000  Microsoft Corporation

Module Name:

    dll.c

Abstract:

    Dynamic library entry point

Environment:

    Fax configuration wizard

Revision History:

        03/13/00 -taoyuan-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxcfgwz.h"
#include <shfusion.h>

HINSTANCE          g_hInstance = NULL;         // DLL instance handle

BOOL
DllMain(
    HINSTANCE   hInstance,
    ULONG       ulReason,
    PCONTEXT    pContext
    )
/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    static BOOL bSHFusionInitialized = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("DllMain of Fax Config Wizard"));

    switch (ulReason) 
    {
        case DLL_PROCESS_ATTACH:
            g_hInstance = hInstance;
            DisableThreadLibraryCalls(hInstance);
            if (!SHFusionInitializeFromModuleID(g_hInstance, SXS_MANIFEST_RESOURCE_ID))
            {
                DebugPrintEx(DEBUG_ERR, TEXT("SHFusionInitializeFromModuleID failed."));

            }
            else
            {
                bSHFusionInitialized = TRUE;
            }

            break;

        case DLL_PROCESS_DETACH:
            if (bSHFusionInitialized)
            {
                SHFusionUninitialize();
                bSHFusionInitialized = FALSE;
            }
            break;
    }

    return TRUE;
}

void CALLBACK 
FaxCfgWzrdDllW(
	HWND hwnd, 
	HINSTANCE hinst, 
	LPWSTR lpszCmdLine,
    int nCmdShow
) 
/*++
Routine Description:

	RunDll32.exe entry point

--*/
{
    BOOL bAbort;
    DEBUG_FUNCTION_NAME(TEXT("FaxCfgWzrdDllW()"));
	//
	// Explicit launch
	//
	FaxConfigWizard(TRUE, &bAbort);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\cfgwzrd\faxcfgwz.c ===
/*++

Copyright (c) 1999 - 2000  Microsoft Corporation

Module Name:

    wizard.c

Abstract:

    Fax configuration wizard main function

Environment:

    Fax configuration wizard

Revision History:

    03/13/00 -taoyuan-
            Created it.

    mm/dd/yy -author-
            description

--*/

#include "faxcfgwz.h"

HANDLE          g_hFaxSvcHandle = NULL;
LIST_ENTRY      g_PageList;             // to keep track of the previous page.
BOOL            g_bShowDevicePages = TRUE;
BOOL            g_bShowUserInfo = TRUE; 
WIZARDDATA      g_wizData = {0};
extern PPRINTER_NAMES g_pPrinterNames;
extern DWORD          g_dwNumPrinters;
const LPCTSTR g_RoutingGuids[RM_COUNT] = 
{
    REGVAL_RM_FOLDER_GUID,      // RM_FOLDER
    REGVAL_RM_PRINTING_GUID     // RM_PRINT
};

typedef struct _WIZARDPAGEINFO
{
    INT         pageId;     // page dialog id
    DLGPROC     dlgProc;    // page dialog callback function
    BOOL        bSelected;  // Whether this page is selected in the wizard
    INT         Title;      // title id from the resource file
    INT         SubTitle;   // sub title id from the resource file
} WIZARDPAGEINFO, *PWIZARDPAGEINFO;

//
// all configuration pages are false here, they will be initialized by FaxConfigWizard()
//
static WIZARDPAGEINFO g_FaxWizardPage[] =
{
    { IDD_WIZARD_WELCOME,               WelcomeDlgProc,     TRUE,   0,                          0 },
    { IDD_WIZARD_USER_INFO,             UserInfoDlgProc,    FALSE,  IDS_WIZ_USER_INFO_TITLE,    IDS_WIZ_USER_INFO_SUB },
    { IDD_DEVICE_LIMIT_SELECT,          DevLimitDlgProc,    FALSE,  IDS_DEVICE_LIMIT_TITLE,     IDS_DEVICE_LIMIT_SUB },
    { IDD_ONE_DEVICE_LIMIT,             OneDevLimitDlgProc, FALSE,  IDS_ONE_DEVICE_TITLE,       IDS_ONE_DEVICE_SUB },
    { IDD_WIZARD_SEND_SELECT_DEVICES,   SendDeviceDlgProc,  FALSE,  IDS_WIZ_SEND_DEVICE_TITLE,  IDS_WIZ_SEND_DEVICE_SUB },
    { IDD_WIZARD_SEND_TSID,             SendTsidDlgProc,    FALSE,  IDS_WIZ_SEND_TSID_TITLE,    IDS_WIZ_SEND_TSID_SUB },
    { IDD_WIZARD_RECV_SELECT_DEVICES,   RecvDeviceDlgProc,  FALSE,  IDS_WIZ_RECV_DEVICE_TITLE,  IDS_WIZ_RECV_DEVICE_SUB },
    { IDD_WIZARD_RECV_CSID,             RecvCsidDlgProc,    FALSE,  IDS_WIZ_RECV_CSID_TITLE,    IDS_WIZ_RECV_CSID_SUB },
    { IDD_WIZARD_RECV_ROUTE,            RecvRouteDlgProc,   FALSE,  IDS_WIZ_RECV_ROUTE_TITLE,   IDS_WIZ_RECV_ROUTE_SUB },
    { IDD_WIZARD_COMPLETE,              CompleteDlgProc,    TRUE,   0,                          0 }
};


#define TIME_TO_WAIT_FOR_CONVERSTION 25000
#define NUM_PAGES (sizeof(g_FaxWizardPage)/sizeof(WIZARDPAGEINFO))

enum WIZARD_PAGE 
{ 
    WELCOME = 0, 
    USER_INFO, 
    DEV_LIMIT,
    ONE_DEV_LIMIT,
    SEND_DEVICE, 
    TSID, 
    RECV_DEVICE, 
    CSID,
    ROUTE 
};

#define TITLE_SIZE   600

BOOL LoadDeviceData();
BOOL SaveDeviceData();
void FreeDeviceData();
DWORD ConvertCpeFilesToCov();


BOOL
FillInPropertyPage(
    PROPSHEETPAGE  *psp,
    PWIZARDPAGEINFO pPageInfo
)

/*++

Routine Description:

    Fill out a PROPSHEETPAGE structure with the supplied parameters

Arguments:

    psp - Points to the PROPSHEETPAGE structure to be filled out
    pData - Pointer to the shared data structure

Return Value:

    NONE

--*/

{

    LPTSTR pWizardTitle = NULL;
    LPTSTR pWizardSubTitle = NULL;

    DEBUG_FUNCTION_NAME(TEXT("FillInPropertyPage()"));

    Assert(psp);

    DebugPrintEx(DEBUG_MSG, TEXT("FillInPropertyPage %d"), pPageInfo->pageId);
    
    psp->dwSize = sizeof(PROPSHEETPAGE);

    //
    // Don't show titles if it's the first or last page
    //
    if (0 == pPageInfo->Title && 0 == pPageInfo->SubTitle) 
    {
        psp->dwFlags = PSP_DEFAULT | PSP_HIDEHEADER;
    } 
    else 
    {
        psp->dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    }

    psp->hInstance   = g_hInstance;
    psp->pszTemplate = MAKEINTRESOURCE(pPageInfo->pageId);
    psp->pfnDlgProc  = pPageInfo->dlgProc;

    if (pPageInfo->Title) 
    {
        pWizardTitle = (LPTSTR)MemAlloc(TITLE_SIZE*sizeof(TCHAR));
        if(!pWizardTitle)
        {
            DebugPrintEx(DEBUG_ERR, TEXT("MemAlloc failed"));
            goto error;;
        }

        if (!LoadString(g_hInstance, pPageInfo->Title, pWizardTitle, TITLE_SIZE))
        {
            DebugPrintEx(DEBUG_ERR, 
                         TEXT("LoadString failed. string ID=%d, error=%d"), 
                         pPageInfo->Title,
                         GetLastError());
            goto error;
        }
    }

    if (pPageInfo->SubTitle)
    {
        pWizardSubTitle = (LPTSTR)MemAlloc(TITLE_SIZE*sizeof(TCHAR) );
        if(!pWizardSubTitle)
        {
            DebugPrintEx(DEBUG_ERR, TEXT("MemAlloc failed"));
            goto error;
        }
        ZeroMemory(pWizardSubTitle, TITLE_SIZE*sizeof(TCHAR));

        if(IDS_DEVICE_LIMIT_SUB == pPageInfo->SubTitle && g_wizData.dwDeviceLimit != INFINITE)
        {
            //
            // Format limit device selection page subtitle
            //
            TCHAR tszBuffer[MAX_PATH];
            if (!LoadString(g_hInstance, pPageInfo->SubTitle, tszBuffer, MAX_PATH))
            {
                DebugPrintEx(DEBUG_ERR, 
                             TEXT("LoadString failed. string ID=%d, error=%d"), 
                             pPageInfo->SubTitle,
                             GetLastError());
                goto error;
            }
            _sntprintf(pWizardSubTitle, TITLE_SIZE-1, tszBuffer, g_wizData.dwDeviceLimit);
        }
        else if (!LoadString(g_hInstance, pPageInfo->SubTitle, pWizardSubTitle, TITLE_SIZE))
        {
            DebugPrintEx(DEBUG_ERR, 
                         TEXT("LoadString failed. string ID=%d, error=%d"), 
                         pPageInfo->SubTitle,
                         GetLastError());
            goto error;
        }
    }

    psp->pszHeaderTitle    = pWizardTitle;
    psp->pszHeaderSubTitle = pWizardSubTitle;

    return TRUE;

error:
    MemFree(pWizardTitle);
    MemFree(pWizardSubTitle);

    return FALSE;
}







BOOL
FaxConfigWizard(
    BOOL   bExplicitLaunch,
    LPBOOL lpbAbort
)

/*++

Routine Description:

    Present the Fax Configuration Wizard to the user. 

Arguments:

    bExplicitLaunch - [in]  Fax Config Wizard was launched explicitly
    lpbAbort        - [out] TRUE if the user refused to enter a dialing location and the calling process should abort.

Return Value:

    TRUE if successful, FALSE if there is an error or the user pressed Cancel.

--*/

{
    HWND            hWnd; // window handle of the calling method
    PROPSHEETPAGE   psp[NUM_PAGES] = {0};
    PROPSHEETPAGE*  pspSaved;
    PROPSHEETHEADER psh = {0};
    BOOL            bResult = FALSE;
    HDC             hdc = NULL;
    DWORD           i = 0;
    DWORD           dwPageCount = 0;
    LPTSTR          lptstrResource = NULL;
    BOOL            bLinkWindowRegistered  = FALSE;
    int             nRes;

    INITCOMMONCONTROLSEX CommonControlsEx = { sizeof(INITCOMMONCONTROLSEX), ICC_WIN95_CLASSES  };

    DEBUG_FUNCTION_NAME(TEXT("FaxConfigWizard()"));

    // 
    // initialize the link list for tracing pages
    //
    InitializeListHead(&g_PageList);

    if (!InitCommonControlsEx(&CommonControlsEx))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("InitCommonControlsEx failed"));
        goto exit;
    }

    hWnd = GetActiveWindow();
    g_wizData.hWndParent = hWnd;
    //
    // On first time, convert CPE files from CSIDL_COMMON_APPDATA\Microsoft\Windows NT\MSFax\Common Coverpages
    // to the user personal cover page directory: CSIDL_PERSONAL\Fax\Personal Coverpages
    //
    if (ConvertCpeFilesToCov() != ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("ConvertCpeFilesToCov failed, continue anyways"));
    }


    // 
    // Check if the user has run this wizard before
    //
    if(!bExplicitLaunch)
    {
        BOOL bDeviceConfigured = FALSE;

        //
        // Is the user info already configured?
        //
        if(IsUserInfoConfigured())
        {
            g_bShowUserInfo = FALSE;
        }
        //
        // Are fax devices already configured?
        //
        if(!FaxGetConfigWizardUsed(&bDeviceConfigured))
        {
            if(bExplicitLaunch)
            {
                DisplayMessageDialog(hWnd, 0, 0, IDS_ERR_GENERAL);
            }
            DebugPrintEx(DEBUG_ERR, TEXT("FaxGetConfigWizardUsed failed. ec = %d"), GetLastError());
            goto exit;
        }

        if(bDeviceConfigured)
        {
            g_bShowDevicePages = FALSE;
        }
    }

    if(!g_bShowUserInfo && !g_bShowDevicePages)
    {
        //
        // No pages to show - no error
        //
        bResult = TRUE;
        goto exit;
    }
    //
    // We're going to call into the local fax server - connect to it now.
    //
    if(!Connect())
    {
        if(bExplicitLaunch)
        {
            DisplayMessageDialog(hWnd, 0, 0, IDS_ERR_CANT_CONNECT);
        }
        DebugPrintEx(DEBUG_ERR, TEXT("Can't connect to fax server. ec = %d"), GetLastError());
        goto exit;
    }

    *lpbAbort = FALSE;
    if(g_bShowDevicePages)
    {
        if(FaxAccessCheckEx(g_hFaxSvcHandle, FAX_ACCESS_MANAGE_CONFIG, NULL))
        {
            //
            // IsFaxDeviceInstalled() prompts to install a device if needed
            //
            if(!IsFaxDeviceInstalled(g_wizData.hWndParent, lpbAbort))
            {
                g_bShowDevicePages = FALSE;
            }
        }
        else
        {
            //
            // the user has no manage access
            //
            g_bShowDevicePages = FALSE;
        }
    }

    if (*lpbAbort)
    {
        //
        // the user refused to enter a dialing location and the calling process should abort.
        //
        DebugPrintEx(DEBUG_MSG, 
                     TEXT("The user refused to enter a dialing location and the calling process should abort"));
        return FALSE;
    }

    if(g_bShowDevicePages)
    {
        TCHAR tszPrnName[MAX_PATH];
        if(GetFirstLocalFaxPrinterName(tszPrnName, MAX_PATH-1))
        {
            // TODO: suggest install printer
        }
    }

    if(!g_bShowUserInfo && !g_bShowDevicePages)
    {
        //
        // no pages to show - no error
        //
        bResult = TRUE;
        goto exit;
    }
    //
    // Load shared data
    // 
    if(!LoadWizardData())
    {
        DebugPrintEx(DEBUG_ERR, TEXT("Load data error."));
        goto exit;
    }

    //
    // Set page information depending on user selection as well as checking user access right
    //
    if(g_bShowUserInfo)
    {   
        g_FaxWizardPage[USER_INFO].bSelected = TRUE;
    }

    if(g_bShowDevicePages)
    {   
        Assert(g_wizData.dwDeviceCount);

        if(1 == g_wizData.dwDeviceLimit)
        {
            g_FaxWizardPage[ONE_DEV_LIMIT].bSelected = TRUE;
        }
        else if(g_wizData.dwDeviceLimit < g_wizData.dwDeviceCount)
        {
            g_FaxWizardPage[DEV_LIMIT].bSelected = TRUE;
        }               

        g_FaxWizardPage[SEND_DEVICE].bSelected = (1 < g_wizData.dwDeviceLimit);
        g_FaxWizardPage[TSID].bSelected        = TRUE;
        g_FaxWizardPage[RECV_DEVICE].bSelected = (1 < g_wizData.dwDeviceLimit);
        g_FaxWizardPage[CSID].bSelected        = TRUE;
        g_FaxWizardPage[ROUTE].bSelected       = TRUE;
    }
   
    //
    // Register the link window class
    //
    bLinkWindowRegistered = LinkWindow_RegisterClass();
    if(!bLinkWindowRegistered)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("LinkWindow_RegisterClass() failed - unable to register link window class"));
    }


    //
    //  Fill out one PROPSHEETPAGE structure for every page:
    //  The first page is a welcome page
    //  The last page is a complete page
    //
    pspSaved = psp;
    for(i = 0; i < NUM_PAGES; i++)
    {
        if(g_FaxWizardPage[i].bSelected)
        {
            if(!FillInPropertyPage(pspSaved++, &g_FaxWizardPage[i]))
            {
                DebugPrintEx(DEBUG_ERR, TEXT("FillInPropertyPage failed"));
                goto exit;
            }
            dwPageCount++;
        }
    }

    //
    // Fill out the PROPSHEETHEADER structure
    //
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;

    psh.hwndParent = hWnd;
    psh.hInstance = g_hInstance;
    psh.hIcon = NULL;
    psh.pszCaption = TEXT("");
    psh.nPages = dwPageCount;
    psh.nStartPage = 0;
    psh.ppsp = psp;

    if(hdc = GetDC(NULL)) 
    {
        if(GetDeviceCaps(hdc, BITSPIXEL) >= 8) 
        {
            lptstrResource = MAKEINTRESOURCE(IDB_FAXWIZ_WATERMARK_256);
        }
        else
        {
            lptstrResource = MAKEINTRESOURCE(IDB_FAXWIZ_WATERMARK_16);
        }

        ReleaseDC(NULL,hdc);
        hdc = NULL;
    }

    psh.pszbmHeader = MAKEINTRESOURCE(IDB_FAXWIZ_BITMAP);
    psh.pszbmWatermark = lptstrResource;

    //
    // Display the wizard pages
    //    
    nRes = (int)PropertySheet(&psh);
    if (nRes > 0 && g_wizData.bFinishPressed)
    {
        // 
        // Save new settings here
        //
        if(!SaveWizardData())
        {
            DisplayMessageDialog(hWnd, MB_ICONERROR, 0, IDS_ERR_NOT_SAVE);
            DebugPrintEx(DEBUG_ERR, TEXT("Can't save wizard data."));
            goto exit;
        }
    }
    else if(0 == nRes && !bExplicitLaunch) // Cancel
    {
        if(IDNO == DisplayMessageDialog(hWnd, 
                                        MB_YESNO | MB_ICONQUESTION, 
                                        0, 
                                        IDS_SHOW_NEXT_TIME))
        {
            if (g_bShowUserInfo) 
            { 
                DWORD  dwRes;
                HKEY   hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, 
                                                 REGKEY_FAX_SETUP, 
                                                 TRUE, 
                                                 KEY_ALL_ACCESS);
                if(hRegKey)
                {
                    SetRegistryDword(hRegKey, REGVAL_CFGWZRD_USER_INFO, TRUE);
                    dwRes = RegCloseKey(hRegKey);
                    if(ERROR_SUCCESS != dwRes)
                    {
                        Assert(FALSE);
                        DebugPrintEx(DEBUG_ERR, TEXT("RegCloseKey failed: error=%d"), dwRes);
                    }
                }
                else
                {
                    DebugPrintEx(DEBUG_ERR, 
                                 TEXT("OpenRegistryKey failed: error=%d"), 
                                 GetLastError());
                }

            }

            if (g_bShowDevicePages ||
                FaxAccessCheckEx(g_hFaxSvcHandle, FAX_ACCESS_MANAGE_CONFIG, NULL))
            { 
                //
                // If the user has manage access and does not have a fax device
                // it's mean she refused to install it.
                // So, we should not disturb her
                // with implicit invocation of the Configuration Wizard.
                //
                if(!FaxSetConfigWizardUsed(g_hFaxSvcHandle, TRUE))
                {
                    DebugPrintEx(DEBUG_ERR, TEXT("FaxSetConfigWizardUsed failed with %d"), GetLastError());
                }
            }
        }
    } 
    else if(nRes < 0)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("PropertySheet() failed (ec: %ld)"), GetLastError());
    }

    bResult = TRUE;

exit:    
    //
    // Cleanup properly before exiting
    //
    for (i = 0; i< dwPageCount; i++) 
    {
        MemFree((PVOID)psp[i].pszHeaderTitle );
        MemFree((PVOID)psp[i].pszHeaderSubTitle );
    }

    FreeWizardData();

    ClearPageList();

    if( bLinkWindowRegistered )
    {
        LinkWindow_UnregisterClass( g_hInstance );
    }
    
    DisConnect();

    if (g_pPrinterNames)
    {
        ReleasePrinterNames (g_pPrinterNames, g_dwNumPrinters);
        g_pPrinterNames = NULL;
    }
    return bResult; 
} // FaxConfigWizard

BOOL 
LoadWizardData()
/*++

Routine Description:

    Load the wizard data from the system. 
    If there are more than one device, we load the data for the first available device.

Arguments:


Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("LoadWizardData()"));

    if (g_bShowUserInfo) 
    { 
        if(!LoadUserInfo())
        {
            //
            // no user info
            //
            DebugPrintEx(DEBUG_MSG, TEXT("LoadUserInfo: failed: error=%d"), GetLastError());
        }
    }

    //
    // get the large fonts for wizard97
    // 
    if(!LoadWizardFont())
    {
        DebugPrintEx(DEBUG_MSG, TEXT("LoadWizardFont: failed."));
        goto error;
    }


    if (g_bShowDevicePages) 
    { 
        if(!LoadDeviceData())
        {
            DebugPrintEx(DEBUG_MSG, TEXT("LoadDeviceData: failed."));
            goto error;
        }
    }

    return TRUE;

error:
    FreeWizardData();

    return FALSE;

} // LoadWizardData

BOOL 
LoadWizardFont()
/*++

Routine Description:

    Load the wizard font for the title. 

Arguments:

    pData - Points to the user mode memory structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    HDC             hdc = NULL;
    LOGFONT         lfTitleFont = {0};
    NONCLIENTMETRICS ncm = {0};
    TCHAR           szFontName[MAX_PATH];   
    INT             iFontSize = 12;         // fixed large font size, which is 12

    DEBUG_FUNCTION_NAME(TEXT("LoadWizardFont()"));

    //
    // get the large fonts for wizard97
    // 
    ncm.cbSize = sizeof(ncm);
    if (!SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("SystemParametersInfo failed. ec = 0x%X"), GetLastError());
        goto Error;
    }
    else 
    {

        CopyMemory((LPVOID* )&lfTitleFont, (LPVOID *)&ncm.lfMessageFont, sizeof(lfTitleFont));
        
        if (!LoadString(g_hInstance, IDS_LARGEFONT_NAME, szFontName, MAX_PATH ))
        {
            DebugPrintEx(DEBUG_ERR, 
                         TEXT("LoadString failed: string ID=%d, error=%d"), 
                         IDS_LARGEFONT_NAME,
                         GetLastError());
            goto Error;
        }

        lfTitleFont.lfWeight = FW_BOLD;

        hdc = GetDC(NULL);
        if (!hdc)
        {
            DebugPrintEx(DEBUG_ERR, TEXT("GetDC() failed (ec: ld)"), GetLastError());
            goto Error;
        }
        
        lfTitleFont.lfHeight = 0 - (GetDeviceCaps(hdc, LOGPIXELSY) * iFontSize / 72);
        
        g_wizData.hTitleFont = CreateFontIndirect(&lfTitleFont);

        if (!g_wizData.hTitleFont)
        {
            DebugPrintEx(DEBUG_ERR, 
                         TEXT("CreateFontIndirect(&lfTitleFont) failed (ec: %ld)"), 
                         GetLastError());
            goto Error;
        }

        ReleaseDC( NULL, hdc);
        hdc = NULL;
        
    }

    return TRUE;

Error:

    //
    // Cleanup properly before exiting
    //

    if (hdc)
    {
         ReleaseDC( NULL, hdc);
         hdc = NULL;
    }

    return FALSE; 
} // LoadWizardFont

BOOL 
SaveWizardData()
/*++

Routine Description:

    Save the wizard data to the system. 
    If there are more than one device, all enabled devices will have the same settings.

Arguments:

    pData - Points to the user memory structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    HKEY    hRegKey = 0;

    DEBUG_FUNCTION_NAME(TEXT("SaveConfigData()"));

    if(!g_hFaxSvcHandle)
    {
        Assert(FALSE);
        return FALSE;
    }

    //
    // save user info
    //
    if (g_bShowUserInfo) 
    { 
        if(!SaveUserInfo())
        {
            DebugPrintEx(DEBUG_ERR, TEXT("SaveUserInfo failed"));
            return FALSE;
        }
    }

    //
    // save device info
    //
    if (g_bShowDevicePages)
    { 
        if(!SaveDeviceData())
        {
            DebugPrintEx(DEBUG_ERR, TEXT("SaveDeviceData failed"));
            return FALSE;
        }
    }

    if (g_bShowDevicePages ||
        FaxAccessCheckEx(g_hFaxSvcHandle, FAX_ACCESS_MANAGE_CONFIG, NULL))
    { 
        //
        // If the user has manage access and does not have a fax device
        // it's mean she refused to install it.
        // So, we should not disturb her
        // with implicit invocation of the Configuration Wizard.
        //
        if(!FaxSetConfigWizardUsed(g_hFaxSvcHandle, TRUE))
        {
            DebugPrintEx(DEBUG_ERR, TEXT("FaxSetConfigWizardUsed failed with %d"), GetLastError());
        }
    }

    return TRUE;
} // SaveWizardData

VOID 
FreeWizardData()
/*++

Routine Description:

    Free the wizard data and release the memory. 

Arguments:

    pData - Pointer to the receive data structure

Return Value:

    None.

--*/

{
    DEBUG_FUNCTION_NAME(TEXT("FreeWizardData()"));

    if(g_wizData.hTitleFont)
    {
        DeleteObject(g_wizData.hTitleFont);
    }

    FreeUserInfo();

    FreeDeviceData();

    return;

} // FreeWizardData

BOOL
SetLastPage(
    INT pageId
)

/*++

Routine Description:

    Add one page to the link list to keep track of "go back" information

Arguments:

    pageId - Page id of the page to be added.

Return Value:

    TRUE if successful, FALSE for failure.

--*/

{
    PPAGE_INFO          pPageInfo;

    DEBUG_FUNCTION_NAME(TEXT("SetLastPage()"));

    pPageInfo = (PPAGE_INFO)MemAlloc(sizeof(PAGE_INFO));
    if(pPageInfo == NULL)
    {
        LPCTSTR faxDbgFunction = TEXT("SetLastPage()");
        DebugPrintEx(DEBUG_ERR, TEXT("MemAlloc failed."));
        Assert(FALSE);
        return FALSE;
    }

    pPageInfo->pageId = pageId;

    //
    // add current page as the last page of the list
    //
    InsertTailList(&g_PageList, &pPageInfo->ListEntry);

    return TRUE;
}


BOOL
ClearPageList(
    VOID
    )
/*++

Routine Description:

    Clear the page list and release the allocated memory

Arguments:

    None.

Return Value:

    True if success, false if fails.

--*/

{
    PLIST_ENTRY         Last; // the last page information
    PPAGE_INFO          pPageInfo = NULL;

    DEBUG_FUNCTION_NAME(TEXT("ClearPageList()"));

    while(!IsListEmpty(&g_PageList)) 
    {
        Last = g_PageList.Blink;

        pPageInfo = CONTAINING_RECORD( Last, PAGE_INFO, ListEntry );
        if(pPageInfo)
        {
            RemoveEntryList(&pPageInfo->ListEntry);
            MemFree(pPageInfo);
        }
    }

    return TRUE;
}


BOOL 
RemoveLastPage(
    HWND hwnd
)
/*++

Routine Description:

    Removes last page from the link list to keep track of "go back" information

Arguments:

    hwnd - window handle

Return Value:

    TRUE if successful, FALSE for failure.

--*/
{
    PPAGE_INFO   pPageInfo = NULL;

    DEBUG_FUNCTION_NAME(TEXT("RemoveLastPage()"));

    Assert(hwnd);

    if(!g_PageList.Blink)
    {
        return FALSE;
    }

    pPageInfo = CONTAINING_RECORD( g_PageList.Blink, PAGE_INFO, ListEntry );
    if(!pPageInfo)
    {
        return FALSE;
    }

    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pPageInfo->pageId);
    RemoveEntryList(&pPageInfo->ListEntry);
    MemFree(pPageInfo);

    return TRUE;
}


BOOL 
LoadDeviceData()
/*++

Routine Description:

    Load the fax devices information. 
    If there are more than one device, we load the data for the first available device.

Arguments:


Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    DWORD  dwPorts = 0;
    BOOL   bRes = FALSE;
    DWORD  dw;
    DWORD  dwGroups;       // group number
    DWORD  dwGroupIndex;
    DWORD  dwSndDevIndex=0; // index of the last send    enabled device
    DWORD  dwRcvDevIndex=0; // index of the last receive enabled device
    DWORD  dwCurrentRM;
    LPBYTE pRoutingInfoBuffer;
    DWORD  dwRoutingInfoBufferSize = 0;

    PFAX_PORT_INFO_EX           pPortsInfo = NULL; // for FaxEnumPortsEx
    PFAX_OUTBOUND_ROUTING_GROUP pFaxRoutingGroup = NULL;


    DEBUG_FUNCTION_NAME(TEXT("LoadDeviceData()"));

    g_wizData.dwDeviceLimit = GetDeviceLimit();
    g_wizData.pdwSendDevOrder = NULL;
    g_wizData.szCsid = NULL;
    g_wizData.szTsid = NULL;
    g_wizData.dwDeviceCount = 0;
    g_wizData.pDevInfo = NULL;

    if(!FaxEnumPortsEx(g_hFaxSvcHandle, &pPortsInfo, &dwPorts)) 
    {
        DebugPrintEx(DEBUG_ERR, TEXT("FaxEnumPortsEx failed: error=%d."), GetLastError());
        goto exit;
    }

    if(!dwPorts)
    {
        Assert(dwPorts);
        DebugPrintEx(DEBUG_ERR, TEXT("No available ports."));
        goto exit; 
    }

    g_wizData.dwDeviceCount = dwPorts;

    g_wizData.pDevInfo = (PDEVICEINFO)MemAlloc(dwPorts * sizeof(DEVICEINFO));
    if(!g_wizData.pDevInfo)
    {
        Assert(FALSE);
        DebugPrintEx(DEBUG_ERR, TEXT("MemAlloc() failed."));
        goto exit;
    }
    ZeroMemory(g_wizData.pDevInfo, dwPorts * sizeof(DEVICEINFO));

    // 
    // pick up the first available device, if no one is available
    // choose the first device
    //
    for(dw = 0; dw < dwPorts; ++dw)
    {
        //
        // copy other device info for each device
        //
        g_wizData.pDevInfo[dw].bSend        = pPortsInfo[dw].bSend;
        g_wizData.pDevInfo[dw].ReceiveMode  = pPortsInfo[dw].ReceiveMode;
        g_wizData.pDevInfo[dw].dwDeviceId   = pPortsInfo[dw].dwDeviceID;
        g_wizData.pDevInfo[dw].szDeviceName = StringDup(pPortsInfo[dw].lpctstrDeviceName);
        if(!g_wizData.pDevInfo[dw].szDeviceName)
        {
            DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed.") );
            goto exit;
        }

        if(pPortsInfo[dw].bSend)
        {
            dwSndDevIndex = dw;
        }

        if(FAX_DEVICE_RECEIVE_MODE_OFF != pPortsInfo[dw].ReceiveMode)
        {
            dwRcvDevIndex = dw;
        }
        g_wizData.pDevInfo[dw].bSelected = TRUE;
    }

    //
    // Copy TSID
    //
    g_wizData.szTsid = StringDup(pPortsInfo[dwSndDevIndex].lptstrTsid);
    if(!g_wizData.szTsid)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed.") );
        goto exit;
    }

    //
    // Copy CSID and rings number
    //
    g_wizData.dwRingCount = pPortsInfo[dwRcvDevIndex].dwRings;
    g_wizData.szCsid = StringDup(pPortsInfo[dwRcvDevIndex].lptstrCsid);
    if(!g_wizData.szCsid)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed.") );
        goto exit;
    }


    if (!IsDesktopSKU())
    {
        //
        // get device order
        //
        if(!FaxEnumOutboundGroups(g_hFaxSvcHandle, &pFaxRoutingGroup, &dwGroups))
        {
            DebugPrintEx(DEBUG_ERR, TEXT("FaxEnumOutboundGroups failed: error=%d."), GetLastError());
            Assert(FALSE);
            goto exit;
        }

        for(dwGroupIndex = 0; dwGroupIndex < dwGroups; dwGroupIndex++)
        {
            // search the <All Devices> group
            if(!lstrcmp(pFaxRoutingGroup[dwGroupIndex].lpctstrGroupName, ROUTING_GROUP_ALL_DEVICES))
            {
                // device number must be the same as port number
                Assert(dwPorts == pFaxRoutingGroup[dwGroupIndex].dwNumDevices);

                DebugPrintEx(DEBUG_MSG, TEXT("Total device number is %d."), pFaxRoutingGroup[dwGroupIndex].dwNumDevices);
                DebugPrintEx(DEBUG_MSG, TEXT("Group status is %d."), pFaxRoutingGroup[dwGroupIndex].Status);
            
                // collecting device Id
                g_wizData.pdwSendDevOrder = MemAlloc(pFaxRoutingGroup[dwGroupIndex].dwNumDevices * sizeof(DWORD));
                if(!g_wizData.pdwSendDevOrder)
                {
                    DebugPrintEx(DEBUG_ERR, TEXT("MemAlloc failed."));
                    goto exit;
                }

                memcpy(g_wizData.pdwSendDevOrder, 
                       pFaxRoutingGroup[dwGroupIndex].lpdwDevices, 
                       pFaxRoutingGroup[dwGroupIndex].dwNumDevices * sizeof(DWORD));

                break;
            }
        }

        if(!g_wizData.pdwSendDevOrder)
        {
            DebugPrintEx(DEBUG_ERR, TEXT("No device order information."));
            goto exit;
        }
    }
    //
    // load routing methods
    // the size of each routing methods should not be larger than INFO_SIZE
    // fortunately, it is gurranteed by other fax programs
    //
    for (dwCurrentRM = 0; dwCurrentRM < RM_COUNT; ++dwCurrentRM) 
    {
        LPTSTR lpCurSel; 

        // 
        // Check the validity first in the loop, 
        // then save the routing info
        //
        lpCurSel = g_wizData.pRouteInfo[dwCurrentRM].tszCurSel;

        g_wizData.pRouteInfo[dwCurrentRM].bEnabled = FaxDeviceEnableRoutingMethod( 
                                            g_hFaxSvcHandle, 
                                            g_wizData.pDevInfo[dwRcvDevIndex].dwDeviceId, 
                                            g_RoutingGuids[dwCurrentRM], 
                                            QUERY_STATUS );

        if(FaxGetExtensionData( g_hFaxSvcHandle, 
                                g_wizData.pDevInfo[dwRcvDevIndex].dwDeviceId, 
                                g_RoutingGuids[dwCurrentRM], 
                                &pRoutingInfoBuffer, 
                                &dwRoutingInfoBufferSize))
        {
            // only copy the first MAX_PATH - 1 characters
            CopyMemory((LPBYTE)lpCurSel, 
                       pRoutingInfoBuffer, 
                       dwRoutingInfoBufferSize < MAX_PATH * sizeof(TCHAR) ? 
                       dwRoutingInfoBufferSize : (MAX_PATH - 1) * sizeof(TCHAR));

            FaxFreeBuffer(pRoutingInfoBuffer);
        }
    }

    bRes = TRUE;

exit:
    //
    // Clean up
    //
    if(pPortsInfo) 
    { 
        FaxFreeBuffer(pPortsInfo); 
    }
    if(pFaxRoutingGroup) 
    { 
        FaxFreeBuffer(pFaxRoutingGroup); 
    }

    if(!bRes)
    {
        FreeDeviceData();
    }

    return bRes;

} // LoadDeviceData

BOOL
SaveSingleDeviceData (
    PDEVICEINFO pDeviceInfo
)
{
    BOOL                bRes = TRUE;
    DWORD               dwCurrentRM;
    PFAX_PORT_INFO_EX   pPortInfo = NULL; // stores device info

    DEBUG_FUNCTION_NAME(TEXT("SaveSingleDeviceData"));

    if(FaxGetPortEx(g_hFaxSvcHandle, pDeviceInfo->dwDeviceId, &pPortInfo))
    {
        //
        // Save the data to all devices and enable/disable FPF_RECEIVE depending on the data
        // 
        pPortInfo->bSend         = pDeviceInfo->bSend;
        pPortInfo->ReceiveMode   = pDeviceInfo->ReceiveMode;
        pPortInfo->lptstrCsid    = g_wizData.szCsid;
        pPortInfo->lptstrTsid    = g_wizData.szTsid;
        pPortInfo->dwRings       = g_wizData.dwRingCount;            

        if(!FaxSetPortEx(g_hFaxSvcHandle, pDeviceInfo->dwDeviceId, pPortInfo))
        {
            DebugPrintEx(DEBUG_ERR, TEXT("FaxSetPortEx() failed with %d."), GetLastError());
            bRes = FALSE;
        }

        FaxFreeBuffer(pPortInfo);
    }
    else
    {
        DebugPrintEx(DEBUG_ERR, TEXT("FaxGetPortEx() failed with %d."), GetLastError());
        bRes = FALSE;
    }
    //
    // Save routing methods
    //
    for (dwCurrentRM = 0; dwCurrentRM < RM_COUNT; dwCurrentRM++) 
    {
        LPTSTR   lpCurSel; 
        LPCWSTR  lpcwstrPrinterPath;
        BOOL     bEnabled; 
        // 
        // Check the validity first in the loop, 
        // then save the routing info
        //
        lpCurSel = g_wizData.pRouteInfo[dwCurrentRM].tszCurSel;
        bEnabled = g_wizData.pRouteInfo[dwCurrentRM].bEnabled;

        if ((RM_PRINT == dwCurrentRM) && bEnabled)
        {
            //
            // Attempt to convert printer display name to printer path before we pass it on to the server
            //
            lpcwstrPrinterPath = FindPrinterPathFromName (g_pPrinterNames, g_dwNumPrinters, lpCurSel);
            if (lpcwstrPrinterPath)
            {
                //
                // We have a matching path - replace name with path.
                //
                lstrcpyn (lpCurSel, lpcwstrPrinterPath, MAX_PATH);
            }
        }
        if(!FaxSetExtensionData(g_hFaxSvcHandle, 
                                pDeviceInfo->dwDeviceId, 
                                g_RoutingGuids[dwCurrentRM], 
                                (LPBYTE)lpCurSel, 
                                MAX_PATH * sizeof(TCHAR)) )
        {
            DebugPrintEx(DEBUG_ERR, TEXT("FaxSetExtensionData() failed with %d."), GetLastError());
            bRes = FALSE;
        }

        if(!FaxDeviceEnableRoutingMethod(g_hFaxSvcHandle, 
                                         pDeviceInfo->dwDeviceId, 
                                         g_RoutingGuids[dwCurrentRM], 
                                         bEnabled ? STATUS_ENABLE : STATUS_DISABLE ) )
        {
            DebugPrintEx(DEBUG_ERR, TEXT("FaxDeviceEnableRoutingMethod() failed with %d."), GetLastError());
            bRes = FALSE;
        }
    }
    return bRes;
}   // SaveSingleDeviceData

BOOL 
SaveDeviceData()
/*++

Routine Description:

    Save the fax devices configuration. 
    If there are more than one device, all enabled devices will be set 
    to current settings, except whether they are enabled to send/receive faxes.

Arguments:

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{

    DWORD  dw;
    BOOL   bRes = TRUE;

    FAX_OUTBOUND_ROUTING_GROUP  outRoutGr = {0};

    DEBUG_FUNCTION_NAME(TEXT("SaveDeviceData"));

    //
    // 1st iteration - save disabled devices only
    //
    for(dw = 0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        if (g_wizData.pDevInfo[dw].bSend || (FAX_DEVICE_RECEIVE_MODE_OFF != g_wizData.pDevInfo[dw].ReceiveMode))
        {
            //
            // Device is active - skip it now
            //
            continue;
        }
        if (!SaveSingleDeviceData(&(g_wizData.pDevInfo[dw])))
        {
            bRes = FALSE;
        }
    }
    //
    // 2nd iteration - save enabled devices only
    //
    for(dw = 0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        if (!g_wizData.pDevInfo[dw].bSend && (FAX_DEVICE_RECEIVE_MODE_OFF == g_wizData.pDevInfo[dw].ReceiveMode))
        {
            //
            // Device is inactive - skip it
            //
            continue;
        }
        if (!SaveSingleDeviceData(&(g_wizData.pDevInfo[dw])))
        {
            bRes = FALSE;
        }
    }
    if (!IsDesktopSKU ())
    {
        //
        // Set device order for send
        //
        outRoutGr.dwSizeOfStruct   = sizeof(outRoutGr);
        outRoutGr.lpctstrGroupName = ROUTING_GROUP_ALL_DEVICES;
        outRoutGr.dwNumDevices     = g_wizData.dwDeviceCount;
        outRoutGr.lpdwDevices      = g_wizData.pdwSendDevOrder;
        outRoutGr.Status           = FAX_GROUP_STATUS_ALL_DEV_VALID;

        if(!FaxSetOutboundGroup(g_hFaxSvcHandle, &outRoutGr))
        {
            DebugPrintEx(DEBUG_ERR, TEXT("FaxSetOutboundGroup() failed with %d."), GetLastError());
            bRes = FALSE;
        }
    }
    return bRes;
} // SaveDeviceData

void 
FreeDeviceData()
/*++

Routine Description:

    Free the devices data and release the memory. 

Arguments:

Return Value:

    none

--*/
{
    DWORD dw;

    DEBUG_FUNCTION_NAME(TEXT("FreeDeviceData()"));

    MemFree(g_wizData.szCsid);
    g_wizData.szCsid = NULL;
    MemFree(g_wizData.szTsid);
    g_wizData.szTsid = NULL;
    MemFree(g_wizData.pdwSendDevOrder);
    g_wizData.pdwSendDevOrder = NULL;

    if (g_wizData.pDevInfo)
    {
        for(dw = 0; dw < g_wizData.dwDeviceCount; ++dw)
        {
            MemFree(g_wizData.pDevInfo[dw].szDeviceName);
            g_wizData.pDevInfo[dw].szDeviceName = NULL;
        }

        MemFree(g_wizData.pDevInfo);
        g_wizData.pDevInfo = NULL;
    }
} // FreeDeviceData





///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  ConvertCpeFilesToCov
//
//  Purpose:        Convert all of the *.CPE files from CSIDL_COMMON_APPDATA\Microsoft\Windows NT\MSFax\Common Coverpages
//                  directory to COV files at CSIDL_PERSONAL\Fax\Personal Coverpages.
//                  Mark that the conversion took place in the registry under HKCU so it will happen exactly once per user.
//
//  Params:
//                  None
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//    
///////////////////////////////////////////////////////////////////////////////////////
DWORD ConvertCpeFilesToCov()
{
    DWORD           dwErr                           = ERROR_SUCCESS;
    INT             iErr                            = 0;
    WIN32_FIND_DATA FindFileData;
    HANDLE          hFind                           = INVALID_HANDLE_VALUE;
    TCHAR           szServerCpDir[2*MAX_PATH]       = {0};
    TCHAR           szSearch[MAX_PATH]              = {0};
    HKEY            hRegKey                         = NULL;
    DWORD           dwConverted                     = 0;

    DEBUG_FUNCTION_NAME(_T("ConvertCpeFilesToCov"));
    //
    // Check whether this is the first time the current user call to this function
    //
    hRegKey = OpenRegistryKey(
        HKEY_CURRENT_USER,
        REGKEY_FAX_SETUP,
        TRUE,
        KEY_ALL_ACCESS);
    if(hRegKey)
    {
        dwConverted = GetRegistryDword(hRegKey, REGVAL_CPE_CONVERT);
        if (0 == dwConverted)
        {
            SetRegistryDword(hRegKey, REGVAL_CPE_CONVERT, TRUE);
        }
        RegCloseKey(hRegKey);
    }
        
    if (dwConverted) // We don't have to convert the cpe files, we did already
        return ERROR_SUCCESS;
    
    //
    // the CPE files are in the server cover page directory
    //
    if ( !GetServerCpDir(NULL,szServerCpDir,ARR_SIZE(szServerCpDir)) )
    {
        dwErr = GetLastError();
        DebugPrintEx(DEBUG_ERR,_T("GetServerCpDir failed (ec=%d)"),dwErr);
        return dwErr;
    }
    
    //
    // first we're going to convert the CPEs to COV.
    // this is done by running FXSCOVER.EXE /CONVERT <CPE filename>
    //
    _sntprintf(szSearch, MAX_PATH, _T("%s\\*.cpe"), szServerCpDir);
    hFind = FindFirstFile(szSearch, &FindFileData);
    if (hFind==INVALID_HANDLE_VALUE)
    {
        DebugPrintEx(DEBUG_MSG,_T("No CPEs exist in %s, exit function"),szServerCpDir);
        return NO_ERROR;
    }
    //
    //  Go for each Cover Page 
    //
    do
    {
        //
        //  FindFileData.cFileName
        //
        TCHAR szCmdLineParams[MAX_PATH*2] = {0};
        SHELLEXECUTEINFO sei = {0};
        _sntprintf(szCmdLineParams,ARR_SIZE(szCmdLineParams),_T("/CONVERT \"%s\\%s\""),szServerCpDir,FindFileData.cFileName);
        sei.cbSize = sizeof (SHELLEXECUTEINFO);
        sei.fMask = SEE_MASK_NOCLOSEPROCESS;

        sei.lpVerb = TEXT("open");
        sei.lpFile = FAX_COVER_IMAGE_NAME;
        sei.lpParameters = szCmdLineParams;
        sei.lpDirectory  = TEXT(".");
        sei.nShow  = SW_HIDE;

        //
        // Execute FXSCOVER.EXE and wait for it to end
        //
        if(!ShellExecuteEx(&sei))
        {
            dwErr = GetLastError();
            DebugPrintEx(DEBUG_ERR, TEXT("ShellExecuteEx failed %d"), dwErr);
            break; // don't try to continue with other files
        }
    
        dwErr = WaitForSingleObject(sei.hProcess, TIME_TO_WAIT_FOR_CONVERSTION);
        CloseHandle(sei.hProcess);
        if (WAIT_OBJECT_0 == dwErr)
        {
            //
            // Shell execute completed successfully
            //
            dwErr = ERROR_SUCCESS;
            continue;
        }
        else
        {
            DebugPrintEx(DEBUG_ERR, TEXT("WaitForSingleObject failed with %d"), dwErr);
            DebugPrintEx(DEBUG_ERR, TEXT("WaitForSingleObject failed GetLastError=%d"), GetLastError());
            break; // don't try to continue with other files
        }

    } while(FindNextFile(hFind, &FindFileData));

    DebugPrintEx(DEBUG_MSG, _T("last call to FindNextFile() returns %ld."), GetLastError());

    //
    //  Close Handle
    //
    FindClose(hFind);       
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\cfgwzrd\onedevlimit.c ===
#include "faxcfgwz.h"


DWORD 
GetSelectedDevIndex(
    HWND    hDlg
)
/*++

Routine Description:

    Get selected device index in WIZARDDATA.pDevInfo array

Arguments:

    hDlg - Handle to the "One device limit" page

Return Value:

    Device index in WIZARDDATA.pDevInfo array

--*/
{
    DWORD dwIndex = 0;
    DWORD dwDeviceId = 0;
    DWORD dwDevIndex = 0;
    HWND  hComboModem = NULL;

    DEBUG_FUNCTION_NAME(TEXT("GetSelectedDevIndex()"));

    hComboModem = GetDlgItem(hDlg, IDC_COMBO_MODEM);
    if(!hComboModem)
    {
        Assert(FALSE);
        DebugPrintEx(DEBUG_ERR, TEXT("GetDlgItem(hDlg, IDC_COMBO_MODEM) failed, ec = %d."), GetLastError());
        return dwDevIndex;
    }

    dwIndex = (DWORD)SendMessage(hComboModem, CB_GETCURSEL,0,0);
    if(CB_ERR == dwIndex)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("SendMessage(hComboModem, CB_GETCURSEL,0,0) failed."));
        return dwDevIndex;
    }

    dwDevIndex = (DWORD)SendMessage(hComboModem, CB_GETITEMDATA, dwIndex, 0);
    if(CB_ERR == dwDevIndex)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("SendMessage(hComboModem, CB_GETITEMDATA, dwIndex, 0) failed."));
        return dwDevIndex;
    }

    return dwDevIndex;
}


void
OnReceiveEnable(
    HWND    hDlg
)
/*++

Routine Description:

    Handle "Receive Enable" check button

Arguments:

    hDlg - Handle to the "One device limit" page

Return Value:

    None

--*/
{
    BOOL bRcvEnable;
    BOOL bAutoAnswer;

    DEBUG_FUNCTION_NAME(TEXT("OnReceiveEnable()"));

    bRcvEnable = IsDlgButtonChecked(hDlg, IDC_RECEIVE_ENABLE) == BST_CHECKED;

    if(bRcvEnable &&
       IsDlgButtonChecked(hDlg, IDC_MANUAL_ANSWER) != BST_CHECKED &&
       IsDlgButtonChecked(hDlg, IDC_AUTO_ANSWER)   != BST_CHECKED)
    {
        //
        // Auto answer is the default
        //
        CheckDlgButton(hDlg, IDC_AUTO_ANSWER, BST_CHECKED);
    }

    if (bRcvEnable)
    {
        //
        // Let's see if the device is virtual
        //
        DWORD dwDevIndex = GetSelectedDevIndex(hDlg);
        DWORD dwRes;
        BOOL  bVirtual = FALSE;
        
        dwRes = IsDeviceVirtual (g_hFaxSvcHandle, g_wizData.pDevInfo[dwDevIndex].dwDeviceId, &bVirtual);
        if (ERROR_SUCCESS != dwRes)
        {
            //
            // Assume device is virtual
            //
            bVirtual = TRUE;
        }
        if (bVirtual)
        {
            //
            // A virtual device is set to receive.
            // Enable ONLY auto-answer and set rings to 1.
            //
            EnableWindow (GetDlgItem(hDlg, IDC_MANUAL_ANSWER),  FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_AUTO_ANSWER),    TRUE);
            EnableWindow(GetDlgItem(hDlg, IDCSTATIC_RINGS),     TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_RING_COUNT),      FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_SPIN_RING_COUNT), FALSE);
            SetDlgItemInt(hDlg, IDC_RING_COUNT, 1,  FALSE);
            return;
        }
    }
    bAutoAnswer = IsDlgButtonChecked(hDlg, IDC_AUTO_ANSWER) == BST_CHECKED;

    EnableWindow(GetDlgItem(hDlg, IDC_MANUAL_ANSWER),  bRcvEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_AUTO_ANSWER),    bRcvEnable);
    EnableWindow(GetDlgItem(hDlg, IDCSTATIC_RINGS),    bRcvEnable);

    EnableWindow(GetDlgItem(hDlg, IDC_RING_COUNT),      bRcvEnable && bAutoAnswer);
    EnableWindow(GetDlgItem(hDlg, IDC_SPIN_RING_COUNT), bRcvEnable && bAutoAnswer);
}   // OnReceiveEnable

void
OnDevSelectChanged(
    HWND    hDlg
)
/*++

Routine Description:

    Handle device selection change

Arguments:

    hDlg - Handle to the "One device limit" page

Return Value:

    None

--*/

{
    DWORD dwDevIndex;

    DEBUG_FUNCTION_NAME(TEXT("OnDevSelectChanged()"));

    dwDevIndex = GetSelectedDevIndex(hDlg);

    CheckDlgButton(hDlg, IDC_SEND_ENABLE,    g_wizData.pDevInfo[dwDevIndex].bSend ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(hDlg, 
                   IDC_RECEIVE_ENABLE, 
                   (FAX_DEVICE_RECEIVE_MODE_OFF != g_wizData.pDevInfo[dwDevIndex].ReceiveMode) ? BST_CHECKED : BST_UNCHECKED);

    if(FAX_DEVICE_RECEIVE_MODE_MANUAL == g_wizData.pDevInfo[dwDevIndex].ReceiveMode)
    {
        CheckDlgButton(hDlg, IDC_MANUAL_ANSWER, BST_CHECKED);
        CheckDlgButton(hDlg, IDC_AUTO_ANSWER,   BST_UNCHECKED);
    }
    else if(FAX_DEVICE_RECEIVE_MODE_AUTO == g_wizData.pDevInfo[dwDevIndex].ReceiveMode)
    {
        CheckDlgButton(hDlg, IDC_MANUAL_ANSWER,  BST_UNCHECKED);
        CheckDlgButton(hDlg, IDC_AUTO_ANSWER,    BST_CHECKED);
    }
    else 
    {
        //
        // No answer mode
        //
        CheckDlgButton(hDlg, IDC_MANUAL_ANSWER,  BST_UNCHECKED);
        CheckDlgButton(hDlg, IDC_AUTO_ANSWER,    BST_UNCHECKED);
    }

    OnReceiveEnable(hDlg);
}


VOID
DoInitOneDevLimitDlg(
    HWND    hDlg
)
/*++

Routine Description:

    Init the "One device limit" page

Arguments:

    hDlg - Handle to the "One device limit" page

Return Value:

    None

--*/

{
    DWORD dw;
    DWORD dwItem;
    DWORD dwSelectedItem=0;
    HWND  hComboModem;

    DEBUG_FUNCTION_NAME(TEXT("DoInitOneDevLimitDlg()"));

    hComboModem = GetDlgItem(hDlg, IDC_COMBO_MODEM);
    if(!hComboModem)
    {
        Assert(FALSE);
        return;
    }

    for(dw=0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        dwItem = (DWORD)SendMessage(hComboModem, CB_ADDSTRING, 0, (LPARAM)(g_wizData.pDevInfo[dw].szDeviceName));
        if(CB_ERR != dwItem && CB_ERRSPACE != dwItem)
        {
            SendMessage(hComboModem, CB_SETITEMDATA, dwItem, dw);

            if(g_wizData.pDevInfo[dw].bSend    ||
               (FAX_DEVICE_RECEIVE_MODE_OFF != g_wizData.pDevInfo[dw].ReceiveMode))
            {
                dwSelectedItem = dwItem;                
            }
        }
        else
        {
            DebugPrintEx(DEBUG_ERR, TEXT("SendMessage(hComboModem, CB_ADDSTRING) failed."));
        }
    }

    SendDlgItemMessage(hDlg, 
                       IDC_SPIN_RING_COUNT, 
                       UDM_SETRANGE32, 
                       (WPARAM)FXS_RINGS_LOWER, 
                       (LPARAM)FXS_RINGS_UPPER);

    SendDlgItemMessage(hDlg, IDC_RING_COUNT, EM_SETLIMITTEXT, FXS_RINGS_LENGTH, 0);

    if(!SetDlgItemInt(hDlg, IDC_RING_COUNT, g_wizData.dwRingCount, FALSE))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("SetDlgItemInt(IDC_RING_COUNT) failed with %d."), GetLastError());
    }

    SendMessage(hComboModem, CB_SETCURSEL, dwSelectedItem, 0);
    OnDevSelectChanged(hDlg);
}

void
DoSaveOneDevLimit(
    HWND    hDlg
)
/*++

Routine Description:

    Save the user's choice for devices

Arguments:

    hDlg - Handle to the "One device limit" page

Return Value:

    None

--*/

{
    DWORD dw;
    BOOL  bRes;
    DWORD dwRes;
    DWORD dwDevIndex;

    DEBUG_FUNCTION_NAME(TEXT("DoSaveOneDevLimit()"));

    dwDevIndex = GetSelectedDevIndex(hDlg);

    //
    // disable all devices
    //
    for(dw=0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        g_wizData.pDevInfo[dw].bSend     = FALSE;
        g_wizData.pDevInfo[dw].ReceiveMode  = FAX_DEVICE_RECEIVE_MODE_OFF;
        g_wizData.pDevInfo[dw].bSelected = FALSE;
    }

    //
    // save "Send enable"
    //
    if(IsDlgButtonChecked(hDlg, IDC_SEND_ENABLE) == BST_CHECKED)
    {
        g_wizData.pDevInfo[dwDevIndex].bSend = TRUE;
    }

    //
    // save receive options
    //
    if(IsDlgButtonChecked(hDlg, IDC_RECEIVE_ENABLE) != BST_CHECKED)
    {
        return;
    }

    if(IsDlgButtonChecked(hDlg, IDC_MANUAL_ANSWER) == BST_CHECKED)
    {
        g_wizData.pDevInfo[dwDevIndex].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_MANUAL;
        return;
    }

    //
    // auto answer
    //
    g_wizData.pDevInfo[dwDevIndex].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_AUTO;
    //
    // get ring count
    //
    dwRes = GetDlgItemInt(hDlg, IDC_RING_COUNT, &bRes, FALSE);
    if(!bRes)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("GetDlgItemInt(IDC_RING_COUNT) failed with %d."), GetLastError());
    }
    else
    {
        g_wizData.dwRingCount = dwRes;
    }
}


INT_PTR 
CALLBACK 
OneDevLimitDlgProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "One device limit" page

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            DoInitOneDevLimitDlg(hDlg);
            return TRUE;
        }

    case WM_COMMAND:

        switch(LOWORD(wParam)) 
        {
            case IDC_COMBO_MODEM:

                if(HIWORD(wParam) == CBN_SELCHANGE)
                {
                    OnDevSelectChanged(hDlg);
                }
                break;

            case IDC_MANUAL_ANSWER:
            case IDC_AUTO_ANSWER:
            case IDC_RECEIVE_ENABLE:

                OnReceiveEnable(hDlg);
                break;
        }

        break;

    case WM_NOTIFY :
        {
        LPNMHDR lpnm = (LPNMHDR) lParam;

        switch (lpnm->code)
            {
            case PSN_SETACTIVE : 

                // Enable the Back and Finish button    
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                break;

            case PSN_WIZBACK :
            {
                //
                // Handle a Back button click here
                //
                if(RemoveLastPage(hDlg))
                {
                    return TRUE;
                }
                
                break;
            }

            case PSN_WIZNEXT :
                //
                // Handle a Next button click, if necessary
                //
                if((IsDlgButtonChecked(hDlg, IDC_RECEIVE_ENABLE) == BST_CHECKED) &&
                   (IsDlgButtonChecked(hDlg, IDC_AUTO_ANSWER)    == BST_CHECKED) &&
                   (SendDlgItemMessage(hDlg, IDC_RING_COUNT, WM_GETTEXTLENGTH, 0, 0) == 0))
                {
                    //
                    // If the rings field is empty
                    // go back to this page
                    //
                    DisplayMessageDialog(hDlg, MB_OK | MB_ICONSTOP, 0, IDS_ERR_NO_RINGS);
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    return TRUE; 
                }

                DoSaveOneDevLimit(hDlg);

                SetLastPage(IDD_ONE_DEVICE_LIMIT);

                if(!IsSendEnable())
                {
                    if(IsReceiveEnable())
                    {
                        //
                        // go to the CSID page
                        //
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_WIZARD_RECV_CSID);
                        return TRUE;
                    }
                    else
                    {
                        //
                        // go to the completion page
                        //
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_WIZARD_COMPLETE);
                        return TRUE;
                    }
                }
                
                break;

            case PSN_RESET :
            {
                // Handle a Cancel button click, if necessary
                break;
            }

            default :
                break;
            }
        }
        break;

    default:
        break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\cfgwzrd\complete.c ===
#include "faxcfgwz.h"

#define MAX_SUMMARY_LEN 4096

VOID
AppendSummaryText(
    LPTSTR      pSummaryText,
    INT         iRes,
    ...
    )

/*++

Routine Description:

    Create summary information depending on config settings

Arguments:

    pSummaryText - pointer of summary text
    iRes - resource ID for the text to be added into the summary text
    ... = arguments as required for the formatting

Return Value:

    TRUE if successful, FALSE for failure.

--*/

{
    va_list va;
    TCHAR szBuffer[MAX_SUMMARY_LEN];
    TCHAR szFormat[MAX_PATH + 1] = {0};

    DEBUG_FUNCTION_NAME(TEXT("AppendSummaryText()"));

    if(!LoadString(g_hInstance, iRes, szFormat, MAX_PATH))
    {
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("LoadString failed. string ID=%d, error=%d"), 
                     iRes,
                     GetLastError());
        Assert(FALSE);
        return;
    }

    va_start(va, iRes);
    _vsntprintf(szBuffer, MAX_PATH, szFormat, va);
    va_end(va);

    if(_tcslen(pSummaryText) + _tcslen(szBuffer) >= MAX_SUMMARY_LEN)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("Insufficient buffer"));
        Assert(FALSE);
        return;        
    }

    lstrcat(pSummaryText, szBuffer);

    return;
}

BOOL
ShowSummaryText(
    HWND   hDlg
)

/*++

Routine Description:

    Create summary information depending on config settings

Arguments:

    hDlg - Handle to the complete page

Return Value:

    TRUE if successful, FALSE for failure.

--*/

{
    TCHAR   szSummaryText[MAX_SUMMARY_LEN] = {0};
    HWND    hControl;
    DWORD   dwRoutingEnabled = FALSE; // indicate whether at least one routing method is enabled
    DWORD   dwIndex;

    DEBUG_FUNCTION_NAME(TEXT("ShowSummaryText()"));

    hControl = GetDlgItem(hDlg, IDC_SUMMARY);


    // get the control ID and clear the current content.
    SetWindowText(hControl, TEXT(""));

    // if no device is selected, don't show the summary page.
    if(!IsSendEnable() && !IsReceiveEnable())
    {
        ShowWindow(hControl, SW_HIDE);
        goto exit;
    }

    if(!LoadString(g_hInstance, IDS_SUMMARY, szSummaryText, MAX_PATH))
    {
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("LoadString failed: string ID=%d, error=%d"), 
                     IDS_SUMMARY,
                     GetLastError());

        ShowWindow(hControl, SW_HIDE);
        goto exit;
    }

    //
    // add send device settings
    //
    if(IsSendEnable())
    {
        AppendSummaryText(szSummaryText, IDS_SUMMARY_SEND_DEVICES);
        for(dwIndex = 0; dwIndex < g_wizData.dwDeviceCount; dwIndex++)
        {
            if(g_wizData.pDevInfo[dwIndex].bSend)
            {
                AppendSummaryText(szSummaryText, IDS_SUMMARY_DEVICE_ITEM, 
                                  g_wizData.pDevInfo[dwIndex].szDeviceName);
            }
        }
        
        if(g_wizData.szTsid)
        {
            AppendSummaryText(szSummaryText, IDS_SUMMARY_TSID, g_wizData.szTsid);
        }
    }

    //
    // add receive device settings
    //
    if(IsReceiveEnable())
    {
        BOOL    bAuto = FALSE;
        int     iManualAnswerDeviceIndex = -1;

        AppendSummaryText(szSummaryText, IDS_SUMMARY_RECEIVE_DEVICES);
        for(dwIndex = 0; dwIndex < g_wizData.dwDeviceCount; dwIndex++)
        {
            if(FAX_DEVICE_RECEIVE_MODE_AUTO == g_wizData.pDevInfo[dwIndex].ReceiveMode)
            {
                bAuto = TRUE;
                AppendSummaryText(szSummaryText, IDS_SUMMARY_DEVICE_ITEM, 
                                  g_wizData.pDevInfo[dwIndex].szDeviceName);
            }
            else if (FAX_DEVICE_RECEIVE_MODE_MANUAL == g_wizData.pDevInfo[dwIndex].ReceiveMode)
            {
                iManualAnswerDeviceIndex = dwIndex;
            }
        }
        
        if(bAuto)
        {
            AppendSummaryText(szSummaryText, IDS_SUMMARY_AUTO_ANSWER, g_wizData.dwRingCount);
        }

        if(iManualAnswerDeviceIndex != -1)
        {		
            Assert(!bAuto);

            AppendSummaryText(szSummaryText, 
                              IDS_SUMMARY_DEVICE_ITEM, 
                              g_wizData.pDevInfo[iManualAnswerDeviceIndex].szDeviceName);
            AppendSummaryText(szSummaryText, IDS_SUMMARY_MANUAL_ANSWER);
        }

        if(g_wizData.szCsid)
        {
            AppendSummaryText(szSummaryText, IDS_SUMMARY_CSID, g_wizData.szCsid);
        }

        // check whether user selects routing methods
        for(dwIndex = 0; dwIndex < RM_COUNT; dwIndex++)
        {
            if(g_wizData.pRouteInfo[dwIndex].bEnabled)
            {
                dwRoutingEnabled = TRUE;
                break;
            }
        }

        // add routing information:

        if(dwRoutingEnabled)
        {
            AppendSummaryText(szSummaryText, IDS_SUMMARY_ROUTING_METHODS);

            for(dwIndex = 0; dwIndex < RM_COUNT; dwIndex++)
            {
                BOOL   bEnabled;
                LPTSTR tszCurSel;

                // 
                // if we don't have this kind of method, go to the next one
                //
                tszCurSel = g_wizData.pRouteInfo[dwIndex].tszCurSel;
                bEnabled  = g_wizData.pRouteInfo[dwIndex].bEnabled;

                switch (dwIndex) 
                {
                    case RM_FOLDER:

                        if(bEnabled) 
                        {
                            AppendSummaryText(szSummaryText, IDS_SUMMARY_SAVE_FOLDER, tszCurSel);
                        }
                        break;

                    case RM_PRINT:

                        if(bEnabled) 
                        {
                            AppendSummaryText(szSummaryText, IDS_SUMMARY_PRINT, tszCurSel);
                        }
                        break;
                }
            }
        }
    }

    ShowWindow(hControl, SW_NORMAL);
    SetWindowText(hControl, szSummaryText);

exit:
    return TRUE;
}


INT_PTR CALLBACK 
CompleteDlgProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "Complete" page

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    HWND            hwndControl;

    switch (uMsg)
    {
    case WM_INITDIALOG :
        {             
            // It's an intro/end page, so get the title font
            // from  the shared data and use it for the title control

            hwndControl = GetDlgItem(hDlg, IDCSTATIC_COMPLETE);
            SetWindowFont(hwndControl, g_wizData.hTitleFont, TRUE);

            return TRUE;
        }


    case WM_NOTIFY :
        {
            LPNMHDR lpnm = (LPNMHDR) lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE : // Enable the Back and Finish button    

                    ShowSummaryText(hDlg);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
                    break;

                case PSN_WIZBACK :
                    {
                        //
                        // Handle a Back button click here
                        //                    
                        if(RemoveLastPage(hDlg))
                        {
                            return TRUE;
                        }

                        break;
                    }

                    break;

                case PSN_WIZFINISH :
                
                    //
                    // Handle a Finish button click, if necessary
                    //

                    g_wizData.bFinishPressed = TRUE;

                    break;

                case PSN_RESET :
                {
                    // Handle a Cancel button click, if necessary
                    break;
                }

                default :
                    break;
            }

            break;
        } 

    default:
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\cfgwzrd\devlimit.c ===
#include "faxcfgwz.h"

BOOL g_bInitializing = FALSE; // TRUE during DoInitDevLimitDlg()

DWORD
CountSelectedDev(
    HWND    hDlg
)
/*++

Routine Description:

    Count selected devices

Arguments:

    hDlg - Handle to the "Device limit" page

Return Value:

    Number of the selected devices

--*/

{
    DWORD   dw;
    HWND    hwndLv;
    DWORD   dwSelected=0;    // count selected devices

    DEBUG_FUNCTION_NAME(TEXT("OnDevSelect()"));

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);

    for (dw = 0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        if(ListView_GetCheckState(hwndLv, dw))
        {
            ++dwSelected;
        }
    }

    return dwSelected;
}


VOID
OnDevSelect(
    HWND    hDlg
)
/*++

Routine Description:

    Handle device selection

Arguments:

    hDlg - Handle to the "Device limit" page

Return Value:

    None

--*/

{
    HWND    hwndLv;
    INT     iItem;
    DWORD   dwSelectNum;    // count selected devices

    DEBUG_FUNCTION_NAME(TEXT("OnDevSelect()"));

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);

    dwSelectNum = CountSelectedDev(hDlg);

    if(dwSelectNum > g_wizData.dwDeviceLimit)
    {
        //
        // If the user exceeds the device limit
        // uncheck selected device
        //
        iItem = ListView_GetNextItem(hwndLv, -1, LVNI_ALL | LVNI_SELECTED);
        if(iItem == -1)
        {
            Assert(FALSE);
        }
        else
        {
            ListView_SetCheckState(hwndLv, iItem, FALSE);
        }

        DisplayMessageDialog(hDlg, MB_OK | MB_ICONSTOP, 0, IDS_DEV_LIMIT_ERROR, g_wizData.dwDeviceLimit);
    }

    ShowWindow(GetDlgItem(hDlg, IDCSTATIC_NO_DEVICE_ERR), (dwSelectNum > 0) ? SW_HIDE : SW_SHOW);
    ShowWindow(GetDlgItem(hDlg, IDC_STATIC_NO_DEVICE),    (dwSelectNum > 0) ? SW_HIDE : SW_SHOW);
}

VOID
DoInitDevLimitDlg(
    HWND    hDlg
)
/*++

Routine Description:

    Init the "Device limit" page

Arguments:

    hDlg - Handle to the "Device limit" page

Return Value:

    None

--*/

{
    DWORD   dw;
    DWORD   dwSelected=0;    // count selected devices
    BOOL    bCheck;
    HWND    hwndLv;
    INT     iIndex;
    LV_ITEM lvItem = {0};

    DEBUG_FUNCTION_NAME(TEXT("DoInitDevLimitDlg()"));

    g_bInitializing = TRUE;

    InitDeviceList(hDlg, IDC_DEVICE_LIST);

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);

    //
    // Fill the list of devices and select the first item.
    //
    lvItem.mask    = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvItem.iImage  = DI_Modem;

    for (dw = 0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        lvItem.iItem   = dw;
        lvItem.pszText = g_wizData.pDevInfo[dw].szDeviceName;
        lvItem.lParam  = dw;

        iIndex = ListView_InsertItem(hwndLv, &lvItem);

        bCheck = FALSE;
        if((dwSelected < g_wizData.dwDeviceLimit) && 
           (g_wizData.pDevInfo[dw].bSend    || 
            (FAX_DEVICE_RECEIVE_MODE_OFF != g_wizData.pDevInfo[dw].ReceiveMode)))
        {
            bCheck = TRUE;
            ++dwSelected;
        }

        ListView_SetCheckState(hwndLv, iIndex, bCheck);
    }

    //
    // Select the first item.
    //
    ListView_SetItemState(hwndLv, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

    OnDevSelect(hDlg);

    ListView_SetColumnWidth(hwndLv, 0, LVSCW_AUTOSIZE_USEHEADER );  

    g_bInitializing = FALSE;
}

void
DoSaveDevLimit(
    HWND    hDlg
)
/*++

Routine Description:

    Save the user's choice for devices

Arguments:

    hDlg - Handle to the "Device limit" page

Return Value:

    None

--*/

{
    DWORD   dw;
    HWND    hwndLv;
    BOOL    bSelected;

    DEBUG_FUNCTION_NAME(TEXT("DoSaveDevLimit()"));

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);

    for (dw = 0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        bSelected = ListView_GetCheckState(hwndLv, dw);
    
        g_wizData.pDevInfo[dw].bSelected = bSelected;

        if(!bSelected)
        {
            g_wizData.pDevInfo[dw].bSend    = FALSE;
            g_wizData.pDevInfo[dw].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
        }
    }    
}

INT_PTR 
CALLBACK 
DevLimitDlgProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "Send Device" page

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            DoInitDevLimitDlg(hDlg);
            return TRUE;
        }

    case WM_COMMAND:

        switch(LOWORD(wParam)) 
        {
            default:
                break;
        }

        break;

    case WM_NOTIFY :
        {
        LPNMHDR lpnm = (LPNMHDR) lParam;

        switch (lpnm->code)
            {
            case PSN_SETACTIVE : 

                // Enable the Back and Finish button    
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                break;

            case PSN_WIZBACK :
            {
                //
                // Handle a Back button click here
                //
                if(RemoveLastPage(hDlg))
                {
                    return TRUE;
                }
                
                break;
            }

            case PSN_WIZNEXT :
                //
                // Handle a Next button click, if necessary
                //
                DoSaveDevLimit(hDlg);

                SetLastPage(IDD_DEVICE_LIMIT_SELECT);

                if(CountSelectedDev(hDlg) == 0)
                {
                    //
                    // go to the completion page
                    //
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_WIZARD_COMPLETE);
                    return TRUE;
                }

                break;

            case PSN_RESET :
            {
                // Handle a Cancel button click, if necessary
                break;
            }

            case LVN_ITEMCHANGED:
            {
                //
                // need to validate the control after changing selection by keyboard
                // 
                if(!g_bInitializing)
                {
                    OnDevSelect(hDlg);
                }

                break;
            }

            case NM_DBLCLK:

            {
                //
                // Handle a double click event
                //
                INT   iItem;
                HWND  hwndLv;
                hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);
                iItem = ((LPNMITEMACTIVATE) lParam)->iItem;
                ListView_SetCheckState(hwndLv, iItem, !ListView_GetCheckState(hwndLv, iItem));
                
                // we don't have break here because we'll go through NM_CLICK
            }

            case NM_CLICK:
            {
                //
                // Handle a Click event
                //
                INT   iItem;
                HWND  hwndLv;
                hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);
                iItem = ((LPNMITEMACTIVATE) lParam)->iItem;

                ListView_SetItemState(hwndLv, iItem, LVIS_SELECTED, LVIS_SELECTED);

                break;
            }

            default :
                break;
            }
        }
        break;

    default:
        break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\cfgwzrd\recvwzrd.c ===
/*++

Copyright (c) 1999 - 2000  Microsoft Corporation

Module Name:

    recvwzrd.c

Abstract:

    Fax wizard pages for receiving configuration

Environment:

    Fax configuration wizard

Revision History:

    03/13/00 -taoyuan-
            Created it.

    mm/dd/yy -author-
            description

--*/

#include "faxcfgwz.h"

// functions which will be used only in this file
VOID DoInitRecvDeviceList(HWND);
VOID DoShowRecvDevices(HWND);
VOID DoSaveRecvDevices(HWND);
VOID CheckAnswerOptions(HWND);


VOID 
DoShowRecvDevices(
    HWND  hDlg
)
/*++

Routine Description:

    Load the device information into the list view control

Arguments:

    hDlg - Handle to the Device Send Options property sheet page

Return Value:

    TRUE if successful, FALSE if failed.

--*/
{
    LV_ITEM item = {0};
    INT     iItem = 0;
    INT     iIndex;
    DWORD   dw;
    HWND    hwndLv;

    DEBUG_FUNCTION_NAME(TEXT("DoShowRecvDevices()"));

    hwndLv = GetDlgItem(hDlg, IDC_RECV_DEVICE_LIST);

    ListView_DeleteAllItems(hwndLv);

    //
    // Fill the list of devices and select the first item.
    //
    item.mask    = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    item.iImage  = DI_Modem;

    for (dw = 0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        if(!(g_wizData.pDevInfo[dw].bSelected))
        {
            //
            // skip unselected device
            //
            continue;
        }

        item.iItem   = iItem++;
        item.pszText = g_wizData.pDevInfo[dw].szDeviceName;
        item.lParam  = dw;

        iIndex = ListView_InsertItem(hwndLv, &item );
        ListView_SetCheckState(hwndLv, 
                               iIndex, 
                               (FAX_DEVICE_RECEIVE_MODE_OFF != g_wizData.pDevInfo[dw].ReceiveMode));
    }

    //
    // Select the first item.
    //
    ListView_SetItemState(hwndLv, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

    ListView_SetColumnWidth(hwndLv, 0, LVSCW_AUTOSIZE_USEHEADER );  
}

VOID 
DoSaveRecvDevices(
    HWND   hDlg
)
/*++

Routine Description:

    Save the user's choice for fax receiving devices

Arguments:

    hDlg - Handle to the "Receive Device" page

Return Value:

    TRUE -- if at least one device is selected or confirms for not selecting any receive
    FALSE -- if no device is selected but user chooses to go back.

--*/

{
    DWORD   dw;
    DWORD   dwDevInx;
    DWORD   dwDeviceCount;
    HWND    hwndLv;
    LVITEM  lv = {0};

    DEBUG_FUNCTION_NAME(TEXT("DoSaveRecvDevices()"));

    lv.mask = LVIF_PARAM;

    hwndLv = GetDlgItem(hDlg, IDC_RECV_DEVICE_LIST);

    dwDeviceCount = ListView_GetItemCount(hwndLv);

    //
    // check selected devices
    //
    for(dw = 0; dw < dwDeviceCount; ++dw)
    {
        //
        // Get device index
        //
        lv.iItem = dw;
        ListView_GetItem(hwndLv, &lv);
        dwDevInx = (DWORD)lv.lParam;

        g_wizData.pDevInfo[dwDevInx].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
        if(ListView_GetCheckState(hwndLv, dw))
        {
            if(IsDlgButtonChecked(hDlg,IDC_MANUAL_ANSWER) == BST_CHECKED)
            {
                g_wizData.pDevInfo[dwDevInx].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_MANUAL;
            }
            else
            {
                g_wizData.pDevInfo[dwDevInx].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_AUTO;
            }
        }
    }
}

VOID
CheckAnswerOptions(
    HWND   hDlg
)

/*++

Routine Description:

    Enable/disable the manual and auto answer radio button depending on the device
    number to receive faxes

Arguments:

    hDlg  - Handle to the "Receive Device" page

Return Value:

    None

--*/

{
    HWND    hwndLv; // list view windows
    DWORD   dwDeviceIndex;
    DWORD   dwDeviceCount;
    DWORD   dwSelectNum=0; // number of the selected devices
    BOOL    bManualAnswer = FALSE;
    BOOL    bAllowManualAnswer = TRUE;
    BOOL    bAllVirtual = TRUE; // Are all device virtual

    DEBUG_FUNCTION_NAME(TEXT("CheckAnswerOptions()"));

    hwndLv = GetDlgItem(hDlg, IDC_RECV_DEVICE_LIST);

    dwDeviceCount = ListView_GetItemCount(hwndLv);

    if(dwDeviceCount < 1) // if there isn't device in the list.
    {
        goto exit;
    }

    Assert (g_hFaxSvcHandle);

    for(dwDeviceIndex = 0; dwDeviceIndex < dwDeviceCount; ++dwDeviceIndex)
    {
        if(ListView_GetCheckState(hwndLv, dwDeviceIndex))
        {
            DWORD dwRes;
            BOOL  bVirtual;

            dwRes = IsDeviceVirtual (g_hFaxSvcHandle, g_wizData.pDevInfo[dwDeviceIndex].dwDeviceId, &bVirtual);
            if (ERROR_SUCCESS != dwRes)
            {
                //
                // Assume device is virtual
                //
                bVirtual = TRUE;
            }
            if (!bVirtual)
            {
                bAllVirtual = FALSE;
            }
                
            ++dwSelectNum;

            if(FAX_DEVICE_RECEIVE_MODE_MANUAL == g_wizData.pDevInfo[dwDeviceIndex].ReceiveMode)
            {
                Assert(!bManualAnswer);
                bManualAnswer = TRUE;
            }
        }
    }

    if(dwSelectNum != 1)
    {
        bAllowManualAnswer = FALSE;
    }
    if (bAllVirtual)
    {
        //
        // Virtual devices don't support manual-answer mode
        //
        bAllowManualAnswer = FALSE;
        //
        // Virtual devices always answer after one ring
        //
        SetDlgItemInt (hDlg, IDC_RING_COUNT, 1, FALSE);
    }
        
    if(IsDlgButtonChecked(hDlg,IDC_MANUAL_ANSWER) == BST_CHECKED)
    {
        if (!bAllowManualAnswer)
        {
            //
            // Manual-answer is not a valid option, yet, it is selected.
            // Change to auto-answer mode.
            //
            CheckDlgButton  (hDlg, IDC_MANUAL_ANSWER, FALSE);
            CheckDlgButton  (hDlg, IDC_AUTO_ANSWER, TRUE);
            bManualAnswer = FALSE;
        }
        else
        {
            bManualAnswer = TRUE;
        }
    }

exit:
    // Show/hide answer mode controls

    EnableWindow(GetDlgItem(hDlg, IDC_MANUAL_ANSWER), !bAllVirtual && (dwSelectNum == 1));
    EnableWindow(GetDlgItem(hDlg, IDC_AUTO_ANSWER),   (dwSelectNum > 0));
    EnableWindow(GetDlgItem(hDlg, IDCSTATIC_RINGS),   (dwSelectNum > 0));

    CheckDlgButton  (hDlg, IDC_MANUAL_ANSWER, bManualAnswer ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton  (hDlg, IDC_AUTO_ANSWER, (!bManualAnswer && (dwSelectNum > 0)) ? BST_CHECKED : BST_UNCHECKED);

    EnableWindow(GetDlgItem(hDlg, IDC_RING_COUNT),      !bAllVirtual && (dwSelectNum > 0) && IsDlgButtonChecked(hDlg, IDC_AUTO_ANSWER));
    EnableWindow(GetDlgItem(hDlg, IDC_SPIN_RING_COUNT), !bAllVirtual && (dwSelectNum > 0) && IsDlgButtonChecked(hDlg, IDC_AUTO_ANSWER));

    ShowWindow(GetDlgItem(hDlg, IDCSTATIC_NO_RECV_DEVICE), (dwSelectNum > 0) ? SW_HIDE : SW_SHOW);
    ShowWindow(GetDlgItem(hDlg, IDCSTATIC_NO_DEVICE_ERR),  (dwSelectNum > 0) ? SW_HIDE : SW_SHOW);

    return;
}   // CheckAnswerOptions

INT_PTR 
CALLBACK 
RecvDeviceDlgProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "Receive Device" page

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (uMsg)
    {
        case WM_INITDIALOG :
        {
            //
            // Maximum length for various text fields in the dialog
            //
            static INT textLimits[] = 
            {
                IDC_RING_COUNT,  FXS_RINGS_LENGTH+1,
                0,
            };

            LimitTextFields(hDlg, textLimits);

            //
            // Initiate the spin control. 
            //
            SendDlgItemMessage(hDlg, IDC_SPIN_RING_COUNT, UDM_SETRANGE32, 
                              (WPARAM)FXS_RINGS_LOWER, (LPARAM)FXS_RINGS_UPPER);

            if(g_wizData.dwRingCount > FXS_RINGS_UPPER || (int)(g_wizData.dwRingCount) < FXS_RINGS_LOWER)
            {
                SetDlgItemInt(hDlg, IDC_RING_COUNT, FXS_RINGS_DEFAULT, FALSE);
            }
            else
            {
                SetDlgItemInt(hDlg, IDC_RING_COUNT, g_wizData.dwRingCount, FALSE);
            }

            //
            // init the list view and load device info
            //
            InitDeviceList(hDlg, IDC_RECV_DEVICE_LIST); 
            DoShowRecvDevices(hDlg);
            CheckAnswerOptions(hDlg);

            return TRUE;
        }
        case WM_COMMAND:

            switch(LOWORD(wParam)) 
            {
                case IDC_MANUAL_ANSWER:
                case IDC_AUTO_ANSWER:

                    // at this time, they must be enabled
                    EnableWindow(GetDlgItem(hDlg, IDC_RING_COUNT), 
                                 LOWORD(wParam)==IDC_AUTO_ANSWER);
                    EnableWindow(GetDlgItem(hDlg, IDC_SPIN_RING_COUNT), 
                                 LOWORD(wParam)==IDC_AUTO_ANSWER);
                    break;


                default:
                    break;
            }
            break;

        case WM_NOTIFY :
        {
            LPNMHDR lpnm = (LPNMHDR) lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE : 

                    DoShowRecvDevices(hDlg);

                    // Enable the Back and Finish button    
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

                    break;

                case PSN_WIZBACK :
                {
                    //
                    // Handle a Back button click here
                    //
                    DoSaveRecvDevices(hDlg);

                    if(RemoveLastPage(hDlg))
                    {
                        return TRUE;
                    }
                  
                    break;
                }

                case PSN_WIZNEXT :
                {
                    BOOL bRes;

                    //
                    // Handle a Next button click, if necessary
                    //
                    DoSaveRecvDevices(hDlg);

                    if(IsReceiveEnable() &&
                      (IsDlgButtonChecked(hDlg,IDC_AUTO_ANSWER) == BST_CHECKED) &&
                      (SendDlgItemMessage(hDlg, IDC_RING_COUNT, WM_GETTEXTLENGTH, 0, 0) == 0))
                    {
                        //
                        // If the rings field is empty
                        // go back to this page
                        //
                        DisplayMessageDialog(hDlg, MB_OK | MB_ICONSTOP, 0, IDS_ERR_NO_RINGS);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        return TRUE; 
                    }

                    g_wizData.dwRingCount = GetDlgItemInt(hDlg, IDC_RING_COUNT, &bRes, FALSE);
                    if(!bRes)
                    {
                        DEBUG_FUNCTION_NAME(TEXT("RecvDeviceDlgProc()"));
                        DebugPrintEx(DEBUG_ERR, TEXT("GetDlgItemInt failed: %d."), GetLastError());
                    }

                    if(!IsReceiveEnable())
                    {
                        //
                        // go to the completion page
                        //
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_WIZARD_COMPLETE);
                        SetLastPage(IDD_WIZARD_RECV_SELECT_DEVICES);
                        return TRUE; 
                    }

                    SetLastPage(IDD_WIZARD_RECV_SELECT_DEVICES);
                    break;
                }

                case PSN_RESET :
                {
                    // Handle a Cancel button click, if necessary
                    break;
                }

                case LVN_ITEMCHANGED:
                {
                    CheckAnswerOptions(hDlg);
                    break;
                }

                case NM_DBLCLK:
                {
                    INT  iItem;
                    HWND hwndLv;

                    iItem  = ((LPNMITEMACTIVATE)lParam)->iItem;
                    hwndLv = GetDlgItem(hDlg, IDC_RECV_DEVICE_LIST);

                    ListView_SetCheckState(hwndLv, iItem, 
                                          !ListView_GetCheckState(hwndLv, iItem));

                    // we don't have break here because we'll go through NM_CLICK
                }

                case NM_CLICK:

                    break;

                default :
                    break;
            }
        } // end of case WM_NOTIFY
        break;

    default:
        break;

    } // end of switch (uMsg)

    return FALSE;
}

INT_PTR 
CALLBACK 
RecvCsidDlgProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "CSID" page

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            //
            // Maximum length for various text fields in the dialog
            //

            static INT textLimits[] = {

                IDC_CSID,  FXS_TSID_CSID_MAX_LENGTH + 1,
                0,
            };

            LimitTextFields(hDlg, textLimits);

            if(g_wizData.szCsid)
            {
                SetDlgItemText(hDlg, IDC_CSID, g_wizData.szCsid);
            }

            return TRUE;
        }


    case WM_NOTIFY :
        {
        LPNMHDR lpnm = (LPNMHDR) lParam;

        switch (lpnm->code)
            {
            case PSN_SETACTIVE : //Enable the Back and Finish button    

                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                break;

            case PSN_WIZBACK :
                {
                    //
                    // Handle a Back button click here
                    //
                    if(RemoveLastPage(hDlg))
                    {
                        return TRUE;
                    }
                    
                    break;
                }

            case PSN_WIZNEXT :
            {
                //Handle a Next button click, if necessary

                LPTSTR    pCsid = NULL;

                pCsid = (LPTSTR)MemAlloc((FXS_TSID_CSID_MAX_LENGTH + 1) * sizeof(TCHAR));
                Assert(pCsid);

                if(pCsid)
                {
                    pCsid[0] = '\0';
                    GetDlgItemText(hDlg, IDC_CSID, pCsid, FXS_TSID_CSID_MAX_LENGTH + 1);
                    MemFree(g_wizData.szCsid);
                    g_wizData.szCsid = NULL;
                }
                else
                {
                    LPCTSTR faxDbgFunction = TEXT("RecvCsidDlgProc()");
                    DebugPrintEx(DEBUG_ERR, TEXT("Can't allocate memory for CSID.") );
                }
                g_wizData.szCsid = pCsid;
                SetLastPage(IDD_WIZARD_RECV_CSID);
                break;
            }

            case PSN_RESET :
            {
                // Handle a Cancel button click, if necessary
                break;
            }

            default :
                break;
            }
        }
        break;

    default:
        break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\cfgwzrd\faxcfgwz.h ===
/*++

Copyright (c) 1999 - 2000  Microsoft Corporation

Module Name:

    faxcfgwz.h

Abstract:

    Fax configuration wizard header file

Environment:

    Fax configuration wizard

Revision History:

    03/13/00 -taoyuan-
            Created it.

    mm/dd/yy -author-
            description

--*/

#ifndef _FAX_CONFIG_WIZARD_H_
#define _FAX_CONFIG_WIZARD_H_

#ifdef __cplusplus
extern "C" {
#endif


#include <windows.h>
#include <windowsx.h>

#include <shlobj.h>
#include <shlobjp.h>
#include <shellapi.h>

#include <winspool.h>
#include <commdlg.h>
#include "tchar.h"

#include <faxutil.h>
#include <fxsapip.h>
#include <faxreg.h>
#include <faxroute.h>
#include <faxuiconstants.h>
#include <htmlhelp.h>

//
// our header files
//
#include "resource.h"
#include "FaxCfgWzExp.h"

#define MAX_STRING_LEN      MAX_PATH
#define MAX_MESSAGE_LEN     512

#define MAX_ARCHIVE_DIR     MAX_PATH - 16
#define MAX_DEVICE_NAME     MAX_PATH

#define DI_Modem            0

enum _ROUT_METHODS
{
	RM_FOLDER=0,
	RM_PRINT,
	RM_COUNT	// number of routing methods
};

extern HANDLE           g_hFaxSvcHandle;    // fax handle for send configuration
extern HINSTANCE        g_hInstance;        // DLL instance handle
extern LIST_ENTRY       g_PageList;         // to keep track of the previous page.
extern BOOL				g_bShowDevicePages;
extern BOOL				g_bShowUserInfo; 
extern const LPCTSTR    g_RoutingGuids[RM_COUNT];


typedef BOOL (*PINSTNEWDEV)(HWND, LPGUID, PDWORD);

#define NEW_DEV_DLL         TEXT("hdwwiz.cpl")

// used by GetProcAddress should be ANSI
#define INSTALL_NEW_DEVICE  "InstallNewDevice"


typedef struct _PAGE_INFO 
{
    LIST_ENTRY  ListEntry;
    INT         pageId;
} PAGE_INFO, *PPAGE_INFO;

typedef struct _DEVICEINFO
{
    DWORD                           dwDeviceId;     // Unique device ID for fax device
    LPTSTR                          szDeviceName;   // Name of specific device
    BOOL                            bSend;          // Send enabled
    FAX_ENUM_DEVICE_RECEIVE_MODE    ReceiveMode;    // Receive mode
    BOOL                            bSelected;      // The device is selected for fax operations
} DEVICEINFO, *PDEVICEINFO;

typedef struct _ROUTINFO
{
	BOOL   bEnabled;
	TCHAR  tszCurSel[MAX_PATH];

} ROUTINFO;

typedef struct _WIZARDDATA
{
    HFONT       hTitleFont;             // The title font for the Welcome and Completion pages
    HWND        hWndParent;             // the window handle of the caller function
    BOOL        bFinishPressed;         // whether the user clicks the finish button
    DWORD       dwDeviceLimit;          // maximum number of the fax devices for the current SKU
    
    LPTSTR      szTsid;                 // Transmit station Id
    LPTSTR      szCsid;                 // Caller station Id 
    DWORD       dwRingCount;            // number of rings allow before answering the call
    DWORD       dwDeviceCount;          // number of available devices 
    LPDWORD     pdwSendDevOrder;        // device order for sending faxes
    ROUTINFO    pRouteInfo[RM_COUNT];   // routing info
    PDEVICEINFO pDevInfo;               // pointer to structure of DEVICEINFO, 

    FAX_PERSONAL_PROFILE userInfo;      // user information

} WIZARDDATA, *PWIZARDDATA;

extern WIZARDDATA  g_wizData;

// RunDll32 entry point in dll.c
void CALLBACK FaxCfgWzrdDllW(HWND hwnd, HINSTANCE hinst, LPWSTR lpszCmdLine, int nCmdShow);

// Functions in FaxCfgWz.c
BOOL LoadWizardData();
BOOL SaveWizardData();
VOID FreeWizardData();

BOOL LoadWizardFont();

BOOL SetLastPage(INT pageId);
BOOL ClearPageList(VOID);
BOOL RemoveLastPage(HWND hwnd);

// Functions in userinfo.c
INT_PTR CALLBACK AddressDetailDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK UserInfoDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

BOOL LoadUserInfo();
BOOL SaveUserInfo();
VOID FreeUserInfo();

// Functions in welcome.c
INT_PTR CALLBACK WelcomeDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Functions in devlimit.c
INT_PTR CALLBACK DevLimitDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Functions in onedevlimit.c
INT_PTR CALLBACK OneDevLimitDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Functions in sendwzrd.c
INT_PTR CALLBACK SendDeviceDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SendTsidDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Functions in recvwzrd.c
INT_PTR CALLBACK RecvDeviceDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK RecvCsidDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Functions in route.c
INT_PTR CALLBACK RecvRouteDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Functions in complete.c
INT_PTR CALLBACK CompleteDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Functions in util.c
VOID LimitTextFields(HWND hDlg, INT *pLimitInfo);
INT DisplayMessageDialog(HWND hwndParent, UINT type, INT titleStrId, INT formatStrId,...);
BOOL BrowseForDirectory(HWND hDlg, INT hResource, LPTSTR title);
BOOL Connect(VOID);
VOID DisConnect(VOID);
VOID InstallModem(HWND hWnd);
BOOL StartFaxService(LPTSTR pServerName);
BOOL IsFaxDeviceInstalled(HWND hWnd, LPBOOL);
BOOL IsUserInfoConfigured();
BOOL FaxDeviceEnableRoutingMethod(HANDLE hFaxHandle, DWORD dwDeviceId, LPCTSTR RoutingGuid, LONG Enabled);
VOID ListView_SetDeviceImageList(HWND hwndLv, HINSTANCE hinst);
BOOL IsSendEnable();
BOOL IsReceiveEnable();
int  GetDevIndexByDevId(DWORD dwDeviceId);
VOID  InitDeviceList(HWND hDlg, DWORD dwListViewResId);



#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\faxres\makefile.inc ===
!IF 0

Copyright (c) 1993  Microsoft Corporation

Module Name:

    makefile.inc

Abstract:

    This file is necessary to cause the message file to be compiled.

Author:

    Wesley Witt (wesw)

!ENDIF

faxmsg.h faxmsg.rc msg00001.bin: messages.mc
    copy messages.mc+..\registry\eventlog.mc faxmsg.mc
    mc -v faxmsg.mc

faxsvc.rc: faxmsg.rc msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\cfgwzrd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Copy of faxcfgwz.rc
//
#define IDD_WIZARD_WELCOME              101
#define IDD_WIZARD_USER_INFO            102
#define IDD_WIZARD_SEND_SELECT_DEVICES  103
#define IDD_WIZARD_SEND_TSID            104
#define IDD_WIZARD_RECV_SELECT_DEVICES  105
#define IDD_WIZARD_RECV_CSID            106
#define IDD_WIZARD_RECV_RING_COUNT      107
#define IDD_WIZARD_RECV_ROUTE           108
#define IDD_WIZARD_COMPLETE             109
#define IDI_Up                          111
#define IDI_Down                        112
#define IDB_FAXWIZ_WATERMARK_256        113
#define IDB_FAXWIZ_BITMAP               114
#define IDB_FAXWIZ_WATERMARK_16         115
#define IDI_Unchecked                   116
#define IDI_Checked                     117
#define IDI_DisabledChecked             118
#define IDI_DisabledUnchecked           119
#define IDI_Modem                       120
#define IDI_Adapter                     121
#define IDI_Question                    124
#define IDI_Error                       125
#define IDI_Info                        126
#define IDS_WIZ_RECV_DEVICE_TITLE       500
#define IDS_WIZ_RECV_DEVICE_SUB         501
#define IDS_WIZ_RECV_RINGS_TITLE        502
#define IDS_WIZ_RECV_RINGS_SUB          503
#define IDS_WIZ_RECV_CSID_TITLE         504
#define IDS_WIZ_RECV_CSID_SUB           505
#define IDS_WIZ_RECV_ROUTE_TITLE        506
#define IDS_WIZ_RECV_ROUTE_SUB          507
#define IDS_WIZ_SEND_DEVICE_TITLE       508
#define IDS_WIZ_SEND_DEVICE_SUB         509
#define IDS_WIZ_SEND_TSID_TITLE         510
#define IDS_WIZ_SEND_TSID_SUB           511
#define IDS_WIZ_USER_INFO_TITLE         512
#define IDS_WIZ_USER_INFO_SUB           513
#define IDS_LARGEFONT_NAME              514
#define IDS_ERROR_TITLE                 515
#define IDS_ERR_DIR_TOO_LONG            517
#define IDS_ERR_ARCHIVE_DIR             518
#define IDS_ERR_SELECT_PRINTER          519
#define IDS_ERR_NOT_ENOUGH_MEMORY       521
#define IDS_ERR_ACCESS_DENIED           522
#define IDS_ERR_CANT_CONNECT            523
#define IDS_RECV_BROWSE_DIR             524
#define IDS_NO_DEVICE_SELECTED          525
#define IDS_ERR_NO_DEVICE               526
#define IDS_ERR_CANT_START_SERVICE      527
#define IDS_ERR_CANT_GET_PORT_INFO      528
#define IDS_SUMMARY                     529
#define IDS_SUMMARY_SEND_DEVICES        530
#define IDS_SUMMARY_TSID                531
#define IDS_SUMMARY_RECEIVE_DEVICES     532
#define IDS_SUMMARY_CSID                533
#define IDS_SUMMARY_MANUAL_ANSWER       534
#define IDS_SUMMARY_AUTO_ANSWER         535
#define IDS_SUMMARY_ROUTING_METHODS     536
#define IDS_SUMMARY_PRINT               537
#define IDS_SUMMARY_SAVE_FOLDER         538
#define IDS_SUMMARY_DEVICE_ITEM         540
#define IDS_MMC_CMDLINE                 541
#define IDS_ADMIN_CONSOLE_LINK          542
#define IDS_ADMIN_CONSOLE_TITLE         543
#define IDCSTATIC_AUTO_ANSWER           546
#define IDC_STATIC_STORE_IN_FOLDER      547
#define IDC_ICON_STORE_IN_FOLDER        548
#define IDC_RECV_DEVICE_LIST            1001
#define IDC_RING_COUNT                  1002
#define IDC_SPIN_RING_COUNT             1003
#define IDC_CSID                        1004
#define IDCSTATIC_RECV_WELCOME_TITLE    1005
#define IDC_SEND_DEVICE_LIST            1006
#define IDC_SENDPRI_UP                  1007
#define IDC_SENDPRI_DOWN                1008
#define IDC_TSID                        1009
#define IDCSTATIC_RECV_WELCOME_DESCR    1010
#define IDS_DEVICE_LIMIT_TITLE          1010
#define IDCSTATIC_RECV_NEXT             1011
#define IDS_DEVICE_LIMIT_SUB            1011
#define IDCSTATIC_RING_COUNT            1012
#define IDS_ONE_DEVICE_TITLE            1012
#define IDC_DEVICE_PROP_SEND            1012
#define IDCSTATIC_CSID                  1013
#define IDS_ONE_DEVICE_SUB              1013
#define IDCSTATIC_RECV_DEVICE_DESCR     1014
#define IDD_DEVICE_LIMIT_SELECT         1014
#define IDCSTATIC_RECV_DEVICE_SELECT    1015
#define IDC_STATIC_DEVICE_LIMIT_SELECT  1015
#define IDCSTATIC_RECV_ROUTE_DESCR      1016
#define IDC_DEVICE_LIST                 1016
#define IDD_ONE_DEVICE_LIMIT            1017
#define IDCSTATIC_COMPLETE              1018
#define IDC_STATIC_NO_DEVICE            1018
#define IDCSTATIC_WELCOME_TITLE         1019
#define IDCSTATIC_NEXT                  1020
#define IDCSTATIC_TSID                  1021
#define IDCSTATIC_SEND_DEVICE_DESCR     1022
#define IDCSTATIC_SEND_DEVICE_SELECT    1023
#define IDCSTATIC_WELCOME_DESCR         1024
#define IDCSTATIC_FULLNAME              1025
#define IDC_SENDER_NAME                 1026
#define IDCSTATIC_FAX_NUMBER            1027
#define IDC_SENDER_FAX_NUMBER           1028
#define IDCSTATIC_MAILBOX               1029
#define IDC_SENDER_MAILBOX              1030
#define IDCSTATIC_TITLE                 1031
#define IDC_SENDER_TITLE                1032
#define IDCSTATIC_COMPANY               1033
#define IDC_SENDER_COMPANY              1034
#define IDCSTATIC_OFFICE                1035
#define IDC_SENDER_OFFICE_LOC           1036
#define IDCSTATIC_DEPT                  1037
#define IDC_SENDER_DEPT                 1038
#define IDCSTATIC_HOME_PHONE            1039
#define IDC_SENDER_HOME_TL              1040
#define IDCSTATIC_WORK_PHONE            1041
#define IDC_SENDER_OFFICE_TL            1042
#define IDCSTATIC_BILLING_CODE          1045
#define IDC_SENDER_BILLING_CODE         1046
#define IDCSTATIC_TSID_DESCR            1047
#define IDCSTATIC_FINISH                1048
#define IDC_RECV_PRINT                  1049
#define IDC_RECV_PRINT_TO               1050
#define IDC_RECV_SAVE                   1051
#define IDC_RECV_DEST_FOLDER            1055
#define IDC_RECV_BROWSE_DIR             1056
#define IDCSTATIC_DEVICE_SELECT_ANSWER_MODE 1065
#define IDC_MANUAL_ANSWER               1066
#define IDC_AUTO_ANSWER                 1067
#define IDCSTATIC_RINGS                 1068
#define IDC_SENDER_ADDRESS              1070
#define IDC_ADDRESS_DETAIL              1071
#define IDC_STATIC_NOT_FINISH           1073
#define IDC_STATIC_CLOSE_CONFIRMATION   1074
#define IDC_DEVICE_PROP_RECEIVE         1074
#define IDC_SUMMARY                     1075
#define IDCSTATIC_COMPLETE_SUB          1076
#define IDCSTATIC_NO_SEND_DEVICE        1077
#define IDCSTATIC_NO_RECV_DEVICE        1078
#define IDC_ADMINCONSOLE_LINK           1079
#define IDCSTATIC_AUTO_ANSWER_DESC      1080
#define IDCSTATIC_MANUAL_ANSWER_DESC    1081
#define IDCSTATIC_NO_DEVICE_ERR         1082
#define IDS_ERR_NO_CONFIG_ACCESS        1083
#define IDS_ERR_GENERAL                 1084
#define IDS_SHOW_NEXT_TIME              1085
#define IDS_ERR_NOT_SAVE                1086
#define IDS_ERR_NO_DIALING_LOCATION     1087
#define IDC_STATIC_SELECT_MODEM         1100
#define IDC_COMBO_MODEM                 1101
#define IDC_SEND_ENABLE                 1102    
#define IDC_RECEIVE_ENABLE              1103
#define IDS_DEV_LIMIT_ERROR             1104
#define IDS_ERR_NO_RINGS                1105
#define IDS_BAD_CSID                    1106
#define IDS_BAD_TSID                    1107

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1089
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\cfgwzrd\route.c ===
#include "faxcfgwz.h"
#include <shlwapi.h>


PPRINTER_NAMES      g_pPrinterNames = NULL;
DWORD               g_dwNumPrinters = 0;

BOOL
DirectoryExists(
    LPTSTR  pDirectoryName
    )

/*++

Routine Description:

    Check the existancy of given folder name

Arguments:

    pDirectoryName - point to folder name

Return Value:

    if the folder exists, return TRUE; else, return FALSE.

--*/

{
    DWORD   dwFileAttributes;

    if(!pDirectoryName || lstrlen(pDirectoryName) == 0)
    {
        return FALSE;
    }

    dwFileAttributes = GetFileAttributes(pDirectoryName);

    if ( dwFileAttributes != 0xffffffff &&
         dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) 
    {
        return TRUE;
    }
    return FALSE;
}


VOID
DoInitRouteOptions(
    HWND    hDlg
)

/*++

Routine Description:

    Initializes the "Route" page with information from system

Arguments:

    hDlg - Handle to the "Route" page

Return Value:

    NONE

--*/

{
    HWND                hControl;
    DWORD               CurrentRM;

    DEBUG_FUNCTION_NAME(TEXT("DoInitRouteOptions()"));

    hControl = GetDlgItem( hDlg, IDC_RECV_PRINT_TO );

    SetLTRComboBox(hDlg, IDC_RECV_PRINT_TO);

    //
    // Initialize the list of destination printers
    //
    if (g_pPrinterNames)
    {
        ReleasePrinterNames (g_pPrinterNames, g_dwNumPrinters);
        g_pPrinterNames = NULL;
    }
    g_pPrinterNames = CollectPrinterNames (&g_dwNumPrinters, TRUE);
    if (!g_pPrinterNames)
    {
        if (ERROR_PRINTER_NOT_FOUND == GetLastError ())
        {
            //
            // No printers
            //
        }
        else
        {
            //
            // Real error
            //
        }
        SendMessage(hControl, CB_SETCURSEL, -1, 0);
        SetWindowText(hControl, g_wizData.pRouteInfo[RM_PRINT].tszCurSel);
    }
    else
    {
        //
        // Success - fill in the combo-box
        //
        DWORD dw;
        LPCWSTR lpcwstrMatchingText;

        for (dw = 0; dw < g_dwNumPrinters; dw++)
        {
            SendMessage(hControl, CB_ADDSTRING, 0, (LPARAM) g_pPrinterNames[dw].lpcwstrDisplayName);
        }
        //
        // Now find out if we match the data the server has
        //
        if (lstrlen(g_wizData.pRouteInfo[RM_PRINT].tszCurSel))
        {
            //
            // Server has some name for printer
            //
            lpcwstrMatchingText = FindPrinterNameFromPath (g_pPrinterNames, g_dwNumPrinters, g_wizData.pRouteInfo[RM_PRINT].tszCurSel);
            if (!lpcwstrMatchingText)
            {
                //
                // No match, just fill in the text we got from the server
                //
                SendMessage(hControl, CB_SETCURSEL, -1, 0);
                SetWindowText(hControl, g_wizData.pRouteInfo[RM_PRINT].tszCurSel);
            }
            else
            {
                SendMessage(hControl, CB_SELECTSTRING, -1, (LPARAM) lpcwstrMatchingText);
            }
        }
        else
        {
            //
            // No server configuation - display no selection
            //
        }
    }        
    // 
    // Display routing methods info in the dialog.
    //
    for (CurrentRM = 0; CurrentRM < RM_COUNT; CurrentRM++) 
    {
        BOOL   bEnabled;
        LPTSTR tszCurSel;

        // 
        // if we don't have this kind of method, go to the next one
        //
        tszCurSel = g_wizData.pRouteInfo[CurrentRM].tszCurSel;
        bEnabled  = g_wizData.pRouteInfo[CurrentRM].bEnabled;

        switch (CurrentRM) 
        {
        case RM_FOLDER:

            CheckDlgButton( hDlg, IDC_RECV_SAVE, bEnabled ? BST_CHECKED : BST_UNCHECKED );
            EnableWindow( GetDlgItem( hDlg, IDC_RECV_DEST_FOLDER ), bEnabled );
            EnableWindow( GetDlgItem( hDlg, IDC_RECV_BROWSE_DIR ), bEnabled );
            if (*tszCurSel) 
            {
                SetDlgItemText( hDlg, IDC_RECV_DEST_FOLDER, tszCurSel );
            }

            break;

        case RM_PRINT:
            CheckDlgButton( hDlg, IDC_RECV_PRINT, bEnabled ? BST_CHECKED : BST_UNCHECKED );                
            EnableWindow(GetDlgItem(hDlg, IDC_RECV_PRINT_TO), bEnabled);
            break;
        }
    }
}

BOOL
DoSaveRouteOptions(
    HWND    hDlg
)
/*++

Routine Description:

    Save the information on the "Route" page to system

Arguments:

    hDlg - Handle to the "Route" page

Return Value:

    TRUE if success, else FALSE

--*/
{
    HWND                hControl;
    DWORD               i;
    ROUTINFO            SetInfo[RM_COUNT] = {0};
    LPTSTR              lpCurSel; 
    BOOL*               pbEnabled; 

    DEBUG_FUNCTION_NAME(TEXT("DoSaveRouteOptions()"));

    // 
    // Check the validity first in the loop, 
    // then save the routing info
    //
    for (i = 0; i < RM_COUNT; i++) 
    {
        lpCurSel = SetInfo[i].tszCurSel;
        Assert(lpCurSel);
        pbEnabled =  &(SetInfo[i].bEnabled);
        Assert(pbEnabled);
        *pbEnabled = 0;

        switch (i) 
        {
            case RM_PRINT:

                *pbEnabled = (IsDlgButtonChecked( hDlg, IDC_RECV_PRINT ) == BST_CHECKED);
                if(FALSE == *pbEnabled)
                {
                    break;
                }
                hControl = GetDlgItem(hDlg, IDC_RECV_PRINT_TO);
                lpCurSel[0] = TEXT('\0');
                //
                // Just read-in the selected printer display name
                //
                GetDlgItemText (hDlg, IDC_RECV_PRINT_TO, lpCurSel, MAX_PATH);
                //
                // we will check the validity only when this routing method is enabled
                // but we will save the select change anyway.
                //
                if (*pbEnabled) 
                {
                    if (lpCurSel[0] == 0) 
                    {
                        DisplayMessageDialog( hDlg, 0, 0, IDS_ERR_SELECT_PRINTER );
                        SetFocus(hControl);
                        SetActiveWindow(hControl);
                        goto error;
                    }
                }
                break;

            case RM_FOLDER:
                {
                    HWND    hControl;
                    BOOL    bValid = TRUE;
                    HCURSOR hOldCursor;

                    hControl = GetDlgItem(hDlg, IDC_RECV_DEST_FOLDER);

                    *pbEnabled = (IsDlgButtonChecked( hDlg, IDC_RECV_SAVE ) == BST_CHECKED);
                    if(!*pbEnabled)
                    {
                        break;
                    }

                    GetWindowText( hControl, lpCurSel, MAX_PATH - 1 );

                    //
                    // Validate the directory
                    //
                    hOldCursor = SetCursor (LoadCursor(NULL, IDC_WAIT));
                    if (PathIsRelative(lpCurSel) || !DirectoryExists(lpCurSel))
                    {
                        //
                        // We don't accept relative paths
                        //
                        bValid = FALSE;
                    }
                    SetCursor (hOldCursor);
                    if(!bValid)
                    {
                        DisplayMessageDialog( hDlg, 0, 0, IDS_ERR_ARCHIVE_DIR );
                        // go to the "Browse" button
                        hControl = GetDlgItem(hDlg, IDC_RECV_BROWSE_DIR);
                        SetFocus(hControl);
                        SetActiveWindow(hControl);
                        goto error;
                    }
                }
        }

    }
    // 
    // now save the device and routing info into shared data.
    //
    CopyMemory((LPVOID)(g_wizData.pRouteInfo), (LPVOID)SetInfo, RM_COUNT * sizeof(ROUTINFO));

    return TRUE;

error:
    return FALSE;
}


INT_PTR 
CALLBACK 
RecvRouteDlgProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "Route" page

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

#define EnableRouteWindow( id, idResource ) \
    EnableWindow( GetDlgItem(hDlg, idResource), IsDlgButtonChecked(hDlg, id) )

{

    switch (uMsg)
    {
        case WM_INITDIALOG :
            { 
                //
                // Maximum length for various text fields in the dialog
                //
                static INT textLimits[] = 
                {
                    IDC_RECV_DEST_FOLDER,  MAX_PATH,
                    0,
                };
                LimitTextFields(hDlg, textLimits);
                DoInitRouteOptions(hDlg); 

                SetLTREditDirection(hDlg, IDC_RECV_DEST_FOLDER);
                SHAutoComplete (GetDlgItem(hDlg, IDC_RECV_DEST_FOLDER), SHACF_FILESYSTEM);
                return TRUE;
            }

        case WM_COMMAND:

            switch (GET_WM_COMMAND_CMD(wParam, lParam)) 
            {
                case BN_CLICKED:

                    switch(GET_WM_COMMAND_ID(wParam, lParam)) 
                    {
                        case IDC_RECV_PRINT:
                            EnableRouteWindow(IDC_RECV_PRINT, IDC_RECV_PRINT_TO);
                            break;

                        case IDC_RECV_SAVE:
                            EnableRouteWindow(IDC_RECV_SAVE, IDC_RECV_DEST_FOLDER);
                            EnableRouteWindow(IDC_RECV_SAVE, IDC_RECV_BROWSE_DIR);
                            break;

                        case IDC_RECV_BROWSE_DIR:
                        {
                            TCHAR szTitle[MAX_PATH] = {0};

                            if( !LoadString( g_hInstance, IDS_RECV_BROWSE_DIR, szTitle, MAX_PATH ) )
                            {
                                DEBUG_FUNCTION_NAME(TEXT("RecvRouteDlgProc()"));
                                DebugPrintEx(DEBUG_ERR, 
                                             TEXT("LoadString failed: string ID=%d, error=%d"), 
                                             IDS_RECV_BROWSE_DIR,
                                             GetLastError());
                            }

                            if( !BrowseForDirectory(hDlg, IDC_RECV_DEST_FOLDER, szTitle) )
                            {
                                return FALSE;
                            }

                            break;
                        }
                    }

                    break;

                default:
                    break;
            }
            if (LOWORD(wParam) == IDC_RECV_DEST_FOLDER && HIWORD(wParam) == EN_KILLFOCUS)
            {
                TCHAR szFolder[MAX_PATH * 2];
                TCHAR szResult[MAX_PATH * 2];
                //
                // Edit control lost its focus
                //
                GetDlgItemText (hDlg, IDC_RECV_DEST_FOLDER, szFolder, ARR_SIZE(szFolder));
                if (lstrlen (szFolder))
                {
                    if (GetFullPathName(szFolder, ARR_SIZE(szResult), szResult, NULL))
                    {
                        PathMakePretty (szResult);
                        SetDlgItemText (hDlg, IDC_RECV_DEST_FOLDER, szResult);
                    }
                }
            }

            break;

        case WM_NOTIFY :
            {
            LPNMHDR lpnm = (LPNMHDR) lParam;

            switch (lpnm->code)
                {
                case PSN_SETACTIVE : //Enable the Back and Finish button    

                    //
                    // Check the "Next" button status
                    //
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    break;

                case PSN_WIZBACK :
                {
                    //
                    // Handle a Back button click here
                    //
                    if(RemoveLastPage(hDlg))
                    {
                        return TRUE;
                    }
                
                    break;

                }

                case PSN_WIZNEXT :
                    //Handle a Next button click, if necessary

                    if(!DoSaveRouteOptions(hDlg))
                    {
                        //
                        // not finished with route configuration
                        //
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        return TRUE;
                    }

                    SetLastPage(IDD_WIZARD_RECV_ROUTE);
                    break;

                case PSN_RESET :
                {
                    // Handle a Cancel button click, if necessary
                    break;
                }

                default :
                    break;
                }
            }
            break;

        default:
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\cfgwzrd\util.c ===
/*++

Copyright (c) 1999 - 2000  Microsoft Corporation

Module Name:

    util.c

Abstract:

    Common used functions in fax configuration wizard

Environment:

    Fax configuration wizard

Revision History:

    03/13/00 -taoyuan-
            Created it.

    mm/dd/yy -author-
            description

--*/

#include "faxcfgwz.h"
#include <devguid.h>
#include <shlwapi.h>

//
// Information about list of dependent services which we stopped
//

typedef struct {

    PVOID   pNext;
    TCHAR   serviceName[1];

} DEPENDENT_SERVICE_LIST, *PDEPENDENT_SERVICE_LIST;

//
// offset of field m in a struct s 
// copied from stddef.h, so we don't need to include stddef.h
//

#define offsetof(s,m)       (size_t)( (char *)&(((s *)0)->m) - (char *)0 )


VOID
LimitTextFields(
    HWND    hDlg,
    INT    *pLimitInfo
    )

/*++

Routine Description:

    Limit the maximum length for a number of text fields

Arguments:

    hDlg - Specifies the handle to the dialog window
    pLimitInfo - Array of text field control IDs and their maximum length
        ID for the 1st text field, maximum length for the 1st text field
        ID for the 2nd text field, maximum length for the 2nd text field
        ...
        0
        Note: The maximum length counts the NUL-terminator.

Return Value:

    NONE

--*/

{
    while (*pLimitInfo != 0) {

        SendDlgItemMessage(hDlg, pLimitInfo[0], EM_SETLIMITTEXT, pLimitInfo[1]-1, 0);
        pLimitInfo += 2;
    }
}

INT
DisplayMessageDialog(
    HWND    hwndParent,
    UINT    type,
    INT     titleStrId,
    INT     formatStrId,
    ...
    )

/*++

Routine Description:

    Display a message dialog box

Arguments:

    hwndParent - Specifies a parent window for the error message dialog
    titleStrId - Title string (could be a string resource ID)
    formatStrId - Message format string (could be a string resource ID)
    ...

Return Value:

    NONE

--*/

{
    TCHAR  tszTitle[MAX_TITLE_LEN + 1];
    TCHAR  tszFormat[MAX_STRING_LEN + 1];
    TCHAR  tszMessage[MAX_MESSAGE_LEN + 1];
    va_list ap;

    DEBUG_FUNCTION_NAME(TEXT("DisplayMessageDialog()"));

        //
        // Load dialog box title string resource
        //
    if (titleStrId == 0)
    {
        titleStrId = IDS_ERROR_TITLE;
    }

    if(!LoadString(g_hInstance, titleStrId, tszTitle, ARR_SIZE(tszTitle)))
    {
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("LoadString failed: string ID=%d, error=%d"), 
                     titleStrId,
                     GetLastError());
        return IDCANCEL;
    }
    //
    // Load message format string resource
    //
    if(!LoadString(g_hInstance, formatStrId, tszFormat, ARR_SIZE(tszFormat)))
    {
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("LoadString failed: string ID=%d, error=%d"), 
                     formatStrId,
                     GetLastError());
        return IDCANCEL;
    }

    //
    // Compose the message string
    //
    va_start(ap, formatStrId);
    wvnsprintf(tszMessage, ARR_SIZE(tszMessage), tszFormat, ap);
    va_end(ap);
    //
    // Terminate string with NULL regardless of success / failure of wvnsprintf
    //
    tszMessage[ARR_SIZE(tszMessage) - 1] = TEXT('\0');
    //
    // Display the message box
    //
    if (type == 0) 
    {
        type = MB_OK | MB_ICONERROR;
    }

    return AlignedMessageBox(hwndParent, tszMessage, tszTitle, type);
}

int CALLBACK 
BrowseCallbackProc(
    HWND    hDlg,
    UINT    uMsg,
    LPARAM  lParam,
    LPARAM  dwData
)

/*++

Routine Description:

    We use this callback function to specify the initial folder

Arguments:

    hDlg - Specifies the dialog window on which the Browse button is displayed
    uMsg - Value identifying the event. 
    lParam - Value dependent upon the message contained in the uMsg parameter. 
    dwData - Application-defined value that was specified in the lParam member of the BROWSEINFO structure. 

Return Value:

    Returns zero.

--*/

{
    switch(uMsg)
    {
        case BFFM_INITIALIZED:
            SendMessage(hDlg, BFFM_SETSELECTION, TRUE, dwData);
            break;

        case BFFM_SELCHANGED:
        {
            BOOL bFolderIsOK = FALSE;
            TCHAR szPath [MAX_PATH + 1];

            if (SHGetPathFromIDList ((LPITEMIDLIST) lParam, szPath)) 
            {
                DWORD dwFileAttr = GetFileAttributes(szPath);
                if (-1 != dwFileAttr && (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY))
                {
                    //
                    // The directory exists - enable the 'Ok' button
                    //
                    bFolderIsOK = TRUE;
                }
            }
            //
            // Enable / disable the 'ok' button
            //
            SendMessage(hDlg, BFFM_ENABLEOK , 0, (LPARAM)bFolderIsOK);
            break;
        }

    }

    return 0;
}

BOOL
BrowseForDirectory(
    HWND   hDlg,
    INT    hResource,
    LPTSTR title
    )

/*++

Routine Description:

    Browse for a directory

Arguments:

    hDlg - Specifies the dialog window on which the Browse button is displayed
    hResource - resource id to receive the directory 
    title - the title to be shown in the browse dialog

Return Value:

    TRUE if successful, FALSE if the user presses Cancel

--*/

{
    LPITEMIDLIST    pidl;
    TCHAR           buffer[MAX_PATH];
    BOOL            bResult = FALSE;
    LPMALLOC        pMalloc = NULL;

    BROWSEINFO bi = {

        hDlg,
        NULL,
        buffer,
        title,
        BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE,
        BrowseCallbackProc,
        (LPARAM) buffer,
    };

    DEBUG_FUNCTION_NAME(TEXT("BrowseForDirectory()"));

    if (!GetDlgItemText( hDlg, hResource, buffer, MAX_PATH))
    {
        buffer[0] = 0;
    }

    SHGetMalloc(&pMalloc);

    if (pidl = SHBrowseForFolder(&bi)) 
    {
        if (SHGetPathFromIDList(pidl, buffer)) 
        {
            if (lstrlen(buffer) > MAX_ARCHIVE_DIR)
            {
                DisplayMessageDialog(hDlg, 0, 0,IDS_ERR_DIR_TOO_LONG);
            }
            else 
            {
                SetDlgItemText(hDlg, hResource, buffer);
                bResult = TRUE;
            }
        }

        pMalloc->lpVtbl->Free(pMalloc, (LPVOID)pidl);

    }

    pMalloc->lpVtbl->Release(pMalloc);

    return bResult;
}

VOID
DisConnect(
)
/*++

Routine Description:

    Close current connection to the fax service

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (g_hFaxSvcHandle) {
        FaxClose(g_hFaxSvcHandle);
        g_hFaxSvcHandle = NULL;
    }
}

BOOL
Connect(
)
/*++

Routine Description:

    Connect to the fax service

Arguments:

    None.

Return Value:

    TRUE if successfully connected, FALSE if there is an error.

--*/

{
    DEBUG_FUNCTION_NAME(TEXT("Connect()"));

    //
    // Check if already connected to the fax service
    //
    if (g_hFaxSvcHandle) {
        return TRUE;
    }

    //
    // Connect to the fax service
    //
    if (!FaxConnectFaxServer(NULL, &g_hFaxSvcHandle)) 
    {
        LPCTSTR faxDbgFunction = TEXT("Connect()");
        DebugPrintEx(DEBUG_ERR, TEXT("Can't connect to the fax server, ec = %d."), GetLastError());
        return FALSE;
    }

    return TRUE;
}

DWORD 
DoesTAPIHaveDialingLocation (
    LPBOOL lpbRes
)
/*++

Routine name : DoesTAPIHaveDialingLocation

Routine description:

    Checks if TAPI as at least one dialing location

Author:

    Eran Yariv (EranY), Dec, 2000

Arguments:

    lpbRes [out]    - TRUE if TAPI has at least one dialing location. FALSE if none

Return Value:

    Standard Win32 error code

--*/
{
    DWORD                   dwRes = ERROR_SUCCESS;
    HLINEAPP                hLineApp = HandleToULong(NULL);
    DWORD                   dwNumDevs;
    LINEINITIALIZEEXPARAMS  LineInitializeExParams;
    DWORD                   dwAPIVer = 0x00020000;
    LINETRANSLATECAPS       LineTransCaps;
    HANDLE                  hEvent = NULL;

    DEBUG_FUNCTION_NAME(TEXT("DoesTAPIHaveDialingLocation"));

    //
    // Create a dummy event
    //
    hEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
    if (!hEvent)
    {
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("CreateEvent failed: %#lx"), 
                     GetLastError());
        return GetLastError ();
    }
    //
    // Initialize TAPI
    //
    LineInitializeExParams.dwTotalSize              = sizeof(LINEINITIALIZEEXPARAMS);
    LineInitializeExParams.dwNeededSize             = 0;
    LineInitializeExParams.dwUsedSize               = 0;
    LineInitializeExParams.dwOptions                = LINEINITIALIZEEXOPTION_USEEVENT ;
    LineInitializeExParams.Handles.hEvent           = hEvent;

    dwRes = (DWORD)lineInitializeEx(
        &hLineApp,
        GetModuleHandle(NULL),
        NULL,
        NULL,
        &dwNumDevs,
        &dwAPIVer,
        &LineInitializeExParams
        );
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("lineInitializeEx failed: %#lx"), 
                     dwRes);
        goto exit;    
    }
    LineTransCaps.dwTotalSize = sizeof(LINETRANSLATECAPS);
    dwRes = (DWORD)lineGetTranslateCaps (hLineApp, 0x00020000, &LineTransCaps);
    if ((DWORD)LINEERR_INIFILECORRUPT == dwRes)
    {
        //
        // This is a special return code from TAPI which indicates no dialing rules are defined.
        //
        *lpbRes = FALSE;
    }
    else
    {
        *lpbRes = TRUE;
    }
    dwRes = ERROR_SUCCESS;

exit:
    if (hLineApp)
    {
        lineShutdown (hLineApp);
    }
    if (hEvent)
    {
        CloseHandle (hEvent);
    }
    return dwRes;
}   // DoesTAPIHaveDialingLocation

void 
InstallModem (
    HWND hWnd
    )
/*++

Routine Description:
    Pop up the hardware installation wizard to install a modem.
    
Arguments:

    hWnd - window handle of the caller.

Return Value:

    None.
    
--*/
{

    HINSTANCE hInst = NULL;
    PINSTNEWDEV pInstNewDev;

    DEBUG_FUNCTION_NAME(TEXT("InstallModem()"));

    hInst = LoadLibrary (NEW_DEV_DLL);
    if (NULL == hInst)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("LoadLibrary failed: %#lx"), GetLastError());
        return;
    }

    pInstNewDev = (PINSTNEWDEV)GetProcAddress (hInst, INSTALL_NEW_DEVICE);
    if (NULL != pInstNewDev)
    {
        EnableWindow (hWnd, FALSE);
        pInstNewDev (hWnd, (LPGUID)&GUID_DEVCLASS_MODEM, NULL);
        EnableWindow (hWnd, TRUE);
    }
    else
    {
        DebugPrintEx(DEBUG_ERR, TEXT("GetProcAddress failed: %#lx"), GetLastError());
    }

    FreeLibrary (hInst);

    DebugPrintEx(DEBUG_MSG, TEXT("Exit modem installation."));

    return;
}   // InstallModem


BOOL
StartFaxService(
    LPTSTR  pServerName
    )

/*++

Routine Description:

    Start the fax service  

Arguments:

    pServerName - Specifies the name of the server computer, NULL for local machine

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    BOOL  success = FALSE;

    DEBUG_FUNCTION_NAME(TEXT("StartFaxService()"));
    
    //
    // Start the fax service and wait for it to be in the running state
    //
    if (EnsureFaxServiceIsStarted(pServerName)) 
    {
        success = WaitForServiceRPCServer(60 * 1000);
        if(!success)
        {
            DebugPrintEx(DEBUG_ERR, TEXT("WaitForServiceRPCServer failed: %d"), GetLastError());
        }
    }

    return success;
}

BOOL 
IsUserInfoConfigured()
/*++

Routine Description:

    Check whether it's the first time starting the wizard

Arguments:

Return Value:

    TRUE if User Info Configured, FALSE if not

--*/

{
    // 
    // Set flag in the registry to specify we have done the 
    // fax configuration wizard
    //
    HKEY    hRegKey;
    BOOL    bRes = FALSE;

    DEBUG_FUNCTION_NAME(TEXT("IsUserInfoConfigured()"));

    //
    // Open the user registry key for writing and create it if necessary
    //
    if ((hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_SETUP, TRUE, KEY_QUERY_VALUE)))
    {
        bRes = GetRegistryDword(hRegKey, REGVAL_CFGWZRD_USER_INFO);
            
        //
        // Close the registry key before returning to the caller
        //

        RegCloseKey(hRegKey);
    }
    else
    {
        LPCTSTR faxDbgFunction = TEXT("IsUserInfoConfigured()");
        DebugPrintEx(DEBUG_ERR, TEXT("Can't open registry to set the wizard flag."));
    }

    return bRes;
}

BOOL 
FaxDeviceEnableRoutingMethod(
    HANDLE hFaxHandle,      
    DWORD dwDeviceId,       
    LPCTSTR pRoutingGuid,    
    LONG Enabled            
)

/*++

Routine Description:

    Get or set the current status of a routing method for specific device

Arguments:

    hFaxHandle - fax handle by FaxConnectFaxServer()
    dwDeviceId - device ID
    pRoutingGuid - GUID that identifies the fax routing method
    Enabled - enabled status for the device and method, if Enabled is QUERY_STATUS, 
            it means return value is the current state

Return Value:

    if Enabled is QUERY_STATUS, return the current state of routing method;
    if Enabled is QUERY_ENABLE or QUERY_DISABLE, return TRUE for success, FALSE for failure.

--*/

{    
    BOOL                 bRes = FALSE;
    PFAX_ROUTING_METHOD  pRoutMethod = NULL;
    DWORD                dwMethodsNum;
    HANDLE               hFaxPortHandle = NULL;
    DWORD                dwInx;

    DEBUG_FUNCTION_NAME(TEXT("FaxDeviceEnableRoutingMethod()"));

    if(!hFaxHandle)
    {
        Assert(FALSE);
        return bRes;
    }

    if(!FaxOpenPort(hFaxHandle, 
                    dwDeviceId, 
                    PORT_OPEN_QUERY | PORT_OPEN_MODIFY, 
                    &hFaxPortHandle))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("FaxOpenPort failed: %d."), GetLastError());
        goto exit;
    }

    if(Enabled == QUERY_STATUS)
    {
        if(!FaxEnumRoutingMethods(hFaxPortHandle, &pRoutMethod, &dwMethodsNum))
        {
            DebugPrintEx(DEBUG_ERR, TEXT("FaxEnumRoutingMethods failed: %d."), GetLastError());
            goto exit;
        }

        for(dwInx=0; dwInx < dwMethodsNum; ++dwInx)
        {
            if(!_tcsicmp(pRoutMethod[dwInx].Guid, pRoutingGuid))
            {
                bRes = pRoutMethod[dwInx].Enabled;
                goto exit;
            }
        }
        DebugPrintEx(DEBUG_MSG, TEXT("Routing method not found"));
        goto exit;
    }
    else
    {
        if(!FaxEnableRoutingMethod(hFaxPortHandle, 
                                   pRoutingGuid, 
                                   (Enabled == STATUS_ENABLE) ? TRUE : FALSE))
        {
            DebugPrintEx(DEBUG_ERR, TEXT("FaxEnableRoutingMethod failed: %d."), GetLastError());
            goto exit;
        }
    }


    bRes = TRUE;

exit:
    if(pRoutMethod) 
    { 
        FaxFreeBuffer(pRoutMethod); 
    }

    if(hFaxPortHandle) 
    { 
        FaxClose(hFaxPortHandle); 
    }

    return bRes;
}


BOOL
VerifyDialingLocations (
    HWND hWndParent
)
/*++

Routine name : VerifyDialingLocations

Routine description:

	Makes sure there's at least one TAPI dialing location defined.
    If none are defined, pops the system U/I for defining one.
    If the user cancels that U/I, offer the user a chance to re-enter a dialing location.
    If the user still refuses, return FALSE.

Author:

	Eran Yariv (EranY),	Jan, 2001

Arguments:

	hWndParent   [in]     - Parent window handle

Return Value:

    See discussion on the return value in the description above.

--*/
{
    BOOL                bDialingRulesDefined;
    DWORD               dwRes;
    DEBUG_FUNCTION_NAME(TEXT("VerifyDialingLocations"));

    //
    // Check if there are dialing rules defined
    //
    dwRes = DoesTAPIHaveDialingLocation (&bDialingRulesDefined);
    if (ERROR_SUCCESS != dwRes)
    {
        //
        // Can't detect - return now. 
        // Assume TRUE.
        //
        return TRUE;
    }
    if (bDialingRulesDefined)
    {
        //
        // Good. Return TRUE
        //
        return TRUE;
    }
    for (;;)
    {
        //
        // No dialing rules defined, pop the simple dialing rules dialog
        //
        extern LONG LOpenDialAsst(
            IN HWND    hwnd,
            IN LPCTSTR lpszAddressIn,
            IN BOOL    fSimple, // if TRUE, uses a dialog for dialing locations. Otherwise, uses a property sheet.
            IN BOOL    fSilentInstall );

        EnableWindow (hWndParent, FALSE);
        LOpenDialAsst(hWndParent, NULL, TRUE, TRUE);
        EnableWindow (hWndParent, TRUE);
        //
        // After we popped the system dialing locations dialog, we should check and see if a location was really added.
        //
        dwRes = DoesTAPIHaveDialingLocation (&bDialingRulesDefined);
        if (ERROR_SUCCESS != dwRes)
        {
            //
            // Can't detect - return now.
            // Assume TRUE.
            //
            return TRUE;
        }
        if (bDialingRulesDefined)
        {
            //
            // Good. The user just added a dialing rule
            //
            return TRUE;
        }
        //
        // Oh no - the user canceled.
        // Pop a message box asking him to retry
        //
        if (IDYES == DisplayMessageDialog(hWndParent, 
                                          MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2, 
                                          0, 
                                          IDS_ERR_NO_DIALING_LOCATION))
        {                                       
            //
            // User chose to abort the wizard - return now
            //
            return FALSE;
        }
        //
        // Try again
        //
    }
    ASSERT_FALSE;
}   // VerifyDialingLocations

DWORD
CountFaxDevices ()
/*++

Routine name : CountFaxDevices

Routine description:

	Counts the number of fax devices (ports) the service knows about

Author:

	Eran Yariv (EranY),	Apr, 2001

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    PFAX_PORT_INFO_EX   pPortsInfo = NULL;
    DWORD               dwPorts;
    DEBUG_FUNCTION_NAME(TEXT("CountFaxDevices()"));

    if(!FaxEnumPortsEx(g_hFaxSvcHandle, &pPortsInfo, &dwPorts))
    {
        DebugPrintEx(DEBUG_MSG, TEXT("FaxEnumPortsEx: failed: error=%d."), GetLastError());
        return 0;
    }
    if(pPortsInfo) 
    { 
        FaxFreeBuffer(pPortsInfo); 
    }   
    return dwPorts;
}   // CountFaxDevices

BOOL 
IsFaxDeviceInstalled(
    HWND    hWnd,
    LPBOOL  lpbAbort
)
/*++

Routine Description:

    Checks if some fax devices are installed.
    If not, suggest to the user to install a device.
    Also, checks if TAPI has a dialing location.
    If not, asks the user to add one.
    If the user refuses, sets lpbAbort to TRUE and return FALSE.
    
Arguments:

  hWnd     - [in]  caller window handle
  lpbAbort - [out] TRUE if the user refused to enter a dialing location and the calling process should abort.

Return Value:

    return TRUE for YES, FALSE for NO

--*/
{
    DWORD           dwDevices;
    DEBUG_FUNCTION_NAME(TEXT("IsFaxDeviceInstalled()"));
    //
    // See how many fax devices the server has found
    //
    dwDevices = CountFaxDevices();
    if(0 == dwDevices)
    {
        int iInstallNewModem;
        //
        // no available device, pop up a U/I to install modem
        //
        iInstallNewModem = DisplayMessageDialog(hWnd, 
                                                MB_YESNO | MB_ICONQUESTION, 
                                                0, 
                                                IDS_ERR_NO_DEVICE);
        if(iInstallNewModem == IDYES)
        {
            //
            // Make sure we have at least one TAPI dialing location.
            // If not, pop a system U/I for the dialing locations.
            //
            HCURSOR hOldCursor;
            int i;

            if (!VerifyDialingLocations (hWnd))
            {
                //
                // The user refused to enter a dialing location and the calling process should abort.
                //
                *lpbAbort = TRUE;
                return FALSE;
            }

            hOldCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

            InstallModem(hWnd);
            // 
            // We don't need to restart the service because the 
            // service can detect the addition of new fax devices.
            // Let's wait a while for the service to discover the new device.
            // We wait up to 12 seconds.
            //
            for (i=0; i < 4; i++)
            {
                Sleep (3000);
                dwDevices = CountFaxDevices();
                if (dwDevices)
                {
                    //
                    // Hooray. Device found by service
                    //
                    break;
                }
            }
            SetCursor (hOldCursor);
        }
    }
    else
    {
        //
        // At least one device is already installed.
        // Make sure we have at least one TAPI dialing location.
        // If not, pop a system U/I for the dialing locations.
        //
        if (!VerifyDialingLocations (hWnd))
        {
            //
            // The user refused to enter a dialing location and the calling process should abort.
            //
            *lpbAbort = TRUE;
            return FALSE;
        }
    }
    return (dwDevices != 0);
}   // IsFaxDeviceInstalled

VOID 
ListView_SetDeviceImageList(
    HWND      hwndLv,
    HINSTANCE hinst 
)
/*++

Routine Description:

    Sets ImageList to list view
    
Arguments:

  hwndLv - list view handle
  hinst  - application instance

Return Value:

    none

--*/
{
    HICON      hIcon;
    HIMAGELIST himl;

    himl = ImageList_Create(
               GetSystemMetrics( SM_CXSMICON ),
               GetSystemMetrics( SM_CYSMICON ),
               ILC_MASK, 2, 2 );

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IDI_Modem ) );
    Assert(hIcon);

    ImageList_ReplaceIcon( himl, -1, hIcon );
    DestroyIcon( hIcon );

    ListView_SetImageList( hwndLv, himl, LVSIL_SMALL );
}

BOOL
IsSendEnable()
/*++

Routine Description:

  Determine if the any of the devices configured to send faxes

Arguments:

Return Value:

    TRUE or FALSE

--*/
{
    DWORD dw;

    if(NULL == g_wizData.pDevInfo)
    {
        return FALSE;
    }

    for(dw=0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        if(g_wizData.pDevInfo[dw].bSend)
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL 
IsReceiveEnable()
/*++

Routine Description:

  Determine if the any of the devices configured to receive faxes

Arguments:

Return Value:

    TRUE or FALSE

--*/
{
    DWORD dw;

    if(NULL == g_wizData.pDevInfo)
    {
        return FALSE;
    }

    for(dw=0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        if(FAX_DEVICE_RECEIVE_MODE_OFF != g_wizData.pDevInfo[dw].ReceiveMode)
        {
            return TRUE;
        }
    }

    return FALSE;
}

int
GetDevIndexByDevId(
    DWORD dwDeviceId
)
/*++

Routine Description:

    Finds appropriate item index in WIZARDDATA.pDevInfo array
    by device ID

Arguments:

    dwDeviceId   - device ID

Return Value:

    device index in WIZARDDATA.pDevInfo array
    or -1 on failure

--*/
{
    DWORD dwIndex;

    if(NULL == g_wizData.pDevInfo)
    {
	    Assert(FALSE);
        return -1;
    }

    for(dwIndex = 0; dwIndex < g_wizData.dwDeviceCount; ++dwIndex)
    {
        if(g_wizData.pDevInfo[dwIndex].dwDeviceId == dwDeviceId)
        {
            return (int)dwIndex;
        }
    }

    Assert(FALSE);
    return -1;
}

VOID
InitDeviceList(
    HWND  hDlg,
    DWORD dwListViewResId
)

/*++

Routine Description:

    Initializes devices list view control

Arguments:

    hDlg            - Handle to property page
    dwListViewResId - list view resource ID

Return Value:

    NONE

--*/

{
    HWND      hwndLv;
    LV_COLUMN col = {0};

    DEBUG_FUNCTION_NAME(TEXT("InitDeviceList()"));

    Assert(hDlg);

    hwndLv = GetDlgItem(hDlg, dwListViewResId);
    Assert(hwndLv);

    //
    // Add the modem images.
    //
    ListView_SetDeviceImageList(hwndLv, g_hInstance );

    ListView_SetExtendedListViewStyle(hwndLv, LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT);

    //
    // Add a single column exactly wide enough to fully display
    // the widest member of the list.
    //
    col.mask = LVCF_FMT;
    col.fmt  = LVCFMT_LEFT;
    ListView_InsertColumn(hwndLv, 0, &col );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\cfgwzrd\userinfo.c ===
/*++

Copyright (c) 1999 - 2000  Microsoft Corporation

Module Name:

    userinfo.c

Abstract:

    Functions for handling events in the "User Info" page of
    the fax configuration wizard

Environment:

        Fax configuration wizard

Revision History:

        03/13/00 -taoyuan-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxcfgwz.h"

// functions which will be used only in this file
VOID DoInitUserInfo(HWND hDlg);
BOOL DoSaveUserInfo(HWND hDlg);
DWORD FillInCountryCombo(HWND hDlg);


VOID
DoInitUserInfo(
    HWND   hDlg    
)

/*++

Routine Description:

    Initializes the User Info property sheet page with information from shared data

Arguments:

    hDlg - Handle to the User Info property sheet page

Return Value:

    NONE

--*/

#define InitUserInfoTextField(id, str) SetDlgItemText(hDlg, id, (str) ? str : TEXT(""));

{
    LPTSTR  pszAddressDetail = NULL;
    PFAX_PERSONAL_PROFILE   pUserInfo = NULL;

    DEBUG_FUNCTION_NAME(TEXT("DoInitUserInfo()"));

    pUserInfo = &(g_wizData.userInfo);

    //
    // A numeric edit control should be LTR
    //
    SetLTREditDirection(hDlg, IDC_SENDER_FAX_NUMBER);
    SetLTREditDirection(hDlg, IDC_SENDER_MAILBOX);
    SetLTREditDirection(hDlg, IDC_SENDER_HOME_TL);
    SetLTREditDirection(hDlg, IDC_SENDER_OFFICE_TL);

    //
    // Fill in the edit text fields
    //

    InitUserInfoTextField(IDC_SENDER_NAME,         pUserInfo->lptstrName);
    InitUserInfoTextField(IDC_SENDER_FAX_NUMBER,   pUserInfo->lptstrFaxNumber);
    InitUserInfoTextField(IDC_SENDER_MAILBOX,      pUserInfo->lptstrEmail);
    InitUserInfoTextField(IDC_SENDER_COMPANY,      pUserInfo->lptstrCompany);
    InitUserInfoTextField(IDC_SENDER_TITLE,        pUserInfo->lptstrTitle);
    InitUserInfoTextField(IDC_SENDER_DEPT,         pUserInfo->lptstrDepartment);
    InitUserInfoTextField(IDC_SENDER_OFFICE_LOC,   pUserInfo->lptstrOfficeLocation);
    InitUserInfoTextField(IDC_SENDER_HOME_TL,      pUserInfo->lptstrHomePhone);
    InitUserInfoTextField(IDC_SENDER_OFFICE_TL,    pUserInfo->lptstrOfficePhone);
    InitUserInfoTextField(IDC_SENDER_BILLING_CODE, pUserInfo->lptstrBillingCode);
    InitUserInfoTextField(IDC_ADDRESS_DETAIL,      pUserInfo->lptstrStreetAddress);


    return;
}

BOOL
DoSaveUserInfo(
    HWND  hDlg    
)

/*++

Routine Description:

    Save the information on the User Info property sheet page to shared data

Arguments:

    hDlg - Handle to the User Info property sheet page

Return Value:

    TRUE -- if no error
    FALSE -- if error

--*/

#define SaveUserInfoTextField(id, str)                                  \
        {                                                               \
            if (! GetDlgItemText(hDlg, id, szBuffer, MAX_PATH))         \
            {                                                           \
                szBuffer[0] = 0;                                        \
            }                                                           \
            MemFree(str);                                               \
            str = StringDup(szBuffer);                                  \
            if(!str)                                                    \
            {                                                           \
                DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed.") );    \
                return FALSE;                                           \
            }                                                           \
        }                                                               \
  

{
    TCHAR   szBuffer[MAX_PATH];
    PFAX_PERSONAL_PROFILE   pUserInfo = NULL;

    DEBUG_FUNCTION_NAME(TEXT("DoSaveUserInfo()"));

    pUserInfo = &(g_wizData.userInfo);

    //
    // Save the edit text fields
    //
    SaveUserInfoTextField(IDC_SENDER_NAME,         pUserInfo->lptstrName);
    SaveUserInfoTextField(IDC_SENDER_FAX_NUMBER,   pUserInfo->lptstrFaxNumber);
    SaveUserInfoTextField(IDC_SENDER_MAILBOX,      pUserInfo->lptstrEmail);
    SaveUserInfoTextField(IDC_SENDER_COMPANY,      pUserInfo->lptstrCompany);
    SaveUserInfoTextField(IDC_SENDER_TITLE,        pUserInfo->lptstrTitle);
    SaveUserInfoTextField(IDC_SENDER_DEPT,         pUserInfo->lptstrDepartment);
    SaveUserInfoTextField(IDC_SENDER_OFFICE_LOC,   pUserInfo->lptstrOfficeLocation);
    SaveUserInfoTextField(IDC_SENDER_HOME_TL,      pUserInfo->lptstrHomePhone);
    SaveUserInfoTextField(IDC_SENDER_OFFICE_TL,    pUserInfo->lptstrOfficePhone);
    SaveUserInfoTextField(IDC_SENDER_BILLING_CODE, pUserInfo->lptstrBillingCode);
    SaveUserInfoTextField(IDC_ADDRESS_DETAIL,      pUserInfo->lptstrStreetAddress);

    return TRUE;
}

BOOL 
LoadUserInfo()
/*++

Routine Description:

    Load the user information from the system. 

Arguments:

    pUserInfo - Points to the user mode memory structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define  DuplicateString(dst, src)                                      \
        {                                                               \
            dst = StringDup(src);                                       \
            if(!dst)                                                    \
            {                                                           \
                bRes = FALSE;                                           \
                DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed.") );    \
                goto exit;                                              \
            }                                                           \
        }
{
    BOOL                    bRes = TRUE;
    HRESULT                 hr;
    FAX_PERSONAL_PROFILE    fpp = {0};
    PFAX_PERSONAL_PROFILE   pUserInfo = NULL;

    DEBUG_FUNCTION_NAME(TEXT("LoadUserInfo()"));

    pUserInfo = &(g_wizData.userInfo);

    fpp.dwSizeOfStruct = sizeof(fpp);
    hr = FaxGetSenderInformation(&fpp);
    if (FAILED(hr))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("FaxGetSenderInformation error, ec = %d"), hr);
        return FALSE;
    }
    
    //
    // Copy the user information to shared data
    //
    pUserInfo->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

    DuplicateString(pUserInfo->lptstrName,           fpp.lptstrName);
    DuplicateString(pUserInfo->lptstrFaxNumber,      fpp.lptstrFaxNumber);
    DuplicateString(pUserInfo->lptstrEmail,          fpp.lptstrEmail);
    DuplicateString(pUserInfo->lptstrCompany,        fpp.lptstrCompany);
    DuplicateString(pUserInfo->lptstrTitle,          fpp.lptstrTitle);
    DuplicateString(pUserInfo->lptstrStreetAddress,  fpp.lptstrStreetAddress);
    DuplicateString(pUserInfo->lptstrCity,           fpp.lptstrCity);
    DuplicateString(pUserInfo->lptstrState,          fpp.lptstrState);
    DuplicateString(pUserInfo->lptstrZip,            fpp.lptstrZip);
    DuplicateString(pUserInfo->lptstrCountry,        fpp.lptstrCountry);
    DuplicateString(pUserInfo->lptstrDepartment,     fpp.lptstrDepartment);
    DuplicateString(pUserInfo->lptstrOfficeLocation, fpp.lptstrOfficeLocation);
    DuplicateString(pUserInfo->lptstrHomePhone,      fpp.lptstrHomePhone);
    DuplicateString(pUserInfo->lptstrOfficePhone,    fpp.lptstrOfficePhone);
    DuplicateString(pUserInfo->lptstrBillingCode,    fpp.lptstrBillingCode);

exit:
    hr = FaxFreeSenderInformation(&fpp);
    if (FAILED(hr))
    {
        //
        // Memory leak.
        //
        DebugPrintEx(DEBUG_ERR, TEXT("FaxFreeSenderInformation error, ec = %d"), hr);
    }

    return bRes;
}

BOOL 
SaveUserInfo()
/*++

Routine Description:

    Save the user information to the system. 

Arguments:

    pUserInfo - Points to the user mode memory structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    HRESULT                 hResult;

    DEBUG_FUNCTION_NAME(TEXT("SaveUserInfo()"));

    g_wizData.userInfo.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
    hResult = FaxSetSenderInformation(&(g_wizData.userInfo));

    return (hResult == S_OK);
}

VOID 
FreeUserInfo()
/*++

Routine Description:

    Free the user info data and release the memory. 

Arguments:

    pUserInfo - Pointer to the user info data structure

Return Value:

    none

--*/

{
    FAX_PERSONAL_PROFILE fpp = {0};
    DEBUG_FUNCTION_NAME(TEXT("FreeUserInfo"));

    MemFree(g_wizData.userInfo.lptstrName);
    MemFree(g_wizData.userInfo.lptstrFaxNumber);
    MemFree(g_wizData.userInfo.lptstrCompany);
    MemFree(g_wizData.userInfo.lptstrStreetAddress);
    MemFree(g_wizData.userInfo.lptstrCity);
    MemFree(g_wizData.userInfo.lptstrState);
    MemFree(g_wizData.userInfo.lptstrZip);
    MemFree(g_wizData.userInfo.lptstrCountry);
    MemFree(g_wizData.userInfo.lptstrTitle);
    MemFree(g_wizData.userInfo.lptstrDepartment);
    MemFree(g_wizData.userInfo.lptstrOfficeLocation);
    MemFree(g_wizData.userInfo.lptstrHomePhone);
    MemFree(g_wizData.userInfo.lptstrOfficePhone);
    MemFree(g_wizData.userInfo.lptstrEmail);
    MemFree(g_wizData.userInfo.lptstrBillingCode);
    MemFree(g_wizData.userInfo.lptstrTSID);
    //
    // NULLify all pointer
    //
    g_wizData.userInfo = fpp;

    return;
}


INT_PTR CALLBACK 
UserInfoDlgProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "User Info" tab

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            //
            // Maximum length for various text fields in the dialog
            //

            static INT textLimits[] = {

                IDC_SENDER_NAME,            MAX_USERINFO_FULLNAME,
                IDC_SENDER_FAX_NUMBER,      MAX_USERINFO_FAX_NUMBER,
                IDC_SENDER_MAILBOX,         MAX_USERINFO_MAILBOX,
                IDC_SENDER_COMPANY,         MAX_USERINFO_COMPANY,
                IDC_SENDER_TITLE,           MAX_USERINFO_TITLE,
                IDC_SENDER_DEPT,            MAX_USERINFO_DEPT,
                IDC_SENDER_OFFICE_LOC,      MAX_USERINFO_OFFICE,
                IDC_SENDER_OFFICE_TL,       MAX_USERINFO_WORK_PHONE,
                IDC_SENDER_HOME_TL,         MAX_USERINFO_HOME_PHONE,
                IDC_SENDER_BILLING_CODE,    MAX_USERINFO_BILLING_CODE,
                0,
            };

            LimitTextFields(hDlg, textLimits);
            
            //
            // Initialize the text fields with information from the registry
            //

            DoInitUserInfo(hDlg);

            return TRUE;
        }

    case WM_COMMAND:

        break;

    case WM_NOTIFY :
        {
        LPNMHDR lpnm = (LPNMHDR) lParam;

        switch (lpnm->code)
            {
            case PSN_SETACTIVE : // Enable the Next button    

                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
                break;

            case PSN_WIZBACK:
            {
                //
                // Handle a Back button click here
                //
                if(RemoveLastPage(hDlg))
                {
                    return TRUE;
                }
                
                break;
            }
            case PSN_WIZNEXT :

                //
                // Handle a Next button click here
                //

                DoSaveUserInfo(hDlg);
                SetLastPage(IDD_WIZARD_USER_INFO);

                break;

            case PSN_RESET :
            {
                // Handle a Cancel button click, if necessary
                break;
            }

            default :
                break;
            }
        }
        break;
    default:
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\cfgwzrd\sendwzrd.c ===
/*++

Copyright (c) 1999 - 2000  Microsoft Corporation

Module Name:

    sendwzrd.c

Abstract:

    Fax wizard pages for sending configuration
    plus the welcome and complete page for the wizard.

Environment:

    Fax configuration wizard

Revision History:

    03/13/00 -taoyuan-
            Created it.

    mm/dd/yy -author-
            description

--*/

#include "faxcfgwz.h"

//
// functions which will be used only in this file
//
VOID DoInitSendDeviceList(HWND);
BOOL DoShowSendDevices(HWND);
VOID DoSaveSendDevices(HWND);
BOOL ValidateControl(HWND, INT);
BOOL ChangePriority(HWND, BOOL);
VOID CheckSendDevices(HWND hDlg);


BOOL 
DoShowSendDevices(
    HWND   hDlg
)
/*++

Routine Description:

    Load the device information into the list view control

Arguments:

    hDlg - Handle to the "Send Device" page

Return Value:

    NONE

--*/
{
    LV_ITEM  item;
    INT      iItem = 0;
    INT      iIndex;
    DWORD    dw;
    int      nDevInx;
    HWND     hwndLv;

    DEBUG_FUNCTION_NAME(TEXT("DoShowSendDevices()"));

    hwndLv = GetDlgItem(hDlg, IDC_SEND_DEVICE_LIST);

    ListView_DeleteAllItems(hwndLv );

    //
    // Fill the list of devices and select the first item.
    //

    for (dw = 0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        nDevInx = GetDevIndexByDevId(g_wizData.pdwSendDevOrder[dw]);
        if(nDevInx < 0)
        {
            Assert(FALSE);
            continue;
        }

        if(!(g_wizData.pDevInfo[nDevInx].bSelected))
        {
            //
            // skip unselected device
            //
            continue;
        }

        ZeroMemory( &item, sizeof(item) );
        item.mask    = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        item.iItem   = iItem++;
        item.pszText = g_wizData.pDevInfo[nDevInx].szDeviceName;

        //
        // we only support modem icon right now, if we can distinguish 
        // the type of a specific, add code here
        //
        item.iImage  = DI_Modem;
        item.lParam  = nDevInx;

        iIndex = ListView_InsertItem(hwndLv, &item );

        ListView_SetCheckState(hwndLv, 
                               iIndex, 
                               g_wizData.pDevInfo[nDevInx].bSend);
    }

    //
    // Select the first item and validate the buttons
    //
    ListView_SetItemState(hwndLv, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

    ListView_SetColumnWidth(hwndLv, 0, LVSCW_AUTOSIZE_USEHEADER );  

    ValidateControl(hDlg, 0);

    return TRUE;

}

VOID
DoSaveSendDevices(
    HWND   hDlg
)
/*++

Routine Description:

    Save the user's choice for fax sending devices

Arguments:

    hDlg - Handle to the "Send Device" page

Return Value:

    TRUE -- if at least one device is selected or confirms for disable send
    FALSE -- if no device is selected but user chooses to go back.

--*/

{
    DWORD       dw;
    DWORD       dwOrder;
    LVITEM      lv = {0}; // for getting info of device Id
    DWORD       dwDevInx;
    DWORD       dwDeviceCount;
    HWND        hwndLv;

    DEBUG_FUNCTION_NAME(TEXT("DoSaveSendDevices()"));

    hwndLv = GetDlgItem(hDlg, IDC_SEND_DEVICE_LIST);

    dwDeviceCount = ListView_GetItemCount(hwndLv);


    lv.mask = LVIF_PARAM;


    //
    // check selected devices
    //
    for(dwOrder = 0; dwOrder < dwDeviceCount; ++dwOrder) 
    {
        //
        // Get device index
        //
        lv.iItem = dwOrder;
        ListView_GetItem(hwndLv, &lv);
        dwDevInx = (DWORD)lv.lParam;
            
        //
        // get device selection
        //
        g_wizData.pDevInfo[dwDevInx].bSend = ListView_GetCheckState(hwndLv, dwOrder);

        //
        // save order info
        //
        g_wizData.pdwSendDevOrder[dwOrder] = g_wizData.pDevInfo[dwDevInx].dwDeviceId;
    }

    //
    // Store unselected device order
    //
    for (dw=0; dw < g_wizData.dwDeviceCount && dwOrder < g_wizData.dwDeviceCount; ++dw)
    {
        if(!(g_wizData.pDevInfo[dw].bSelected))
        {
            g_wizData.pdwSendDevOrder[dwOrder] = g_wizData.pDevInfo[dw].dwDeviceId;
            ++dwOrder;
        }
    }
    Assert(dwOrder == g_wizData.dwDeviceCount);
}

BOOL
ValidateControl(
    HWND   hDlg,
    INT    iItem
)
/*++

Routine Description:

    Validate the up and down button in the device select page

Arguments:

    hDlg - Handle to the Device Send Options property sheet page
    iItem - index of the item being selected

Return Value:

    TRUE -- if no error
    FALSE -- if error

--*/

{

    DWORD dwDeviceCount = ListView_GetItemCount(GetDlgItem(hDlg, IDC_SEND_DEVICE_LIST));

    //
    // if there is only one device or we don't click on any item
    // up and down buttons are disabled
    //
    if(dwDeviceCount < 2 || iItem == -1)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_SENDPRI_UP), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SENDPRI_DOWN), FALSE);
        return TRUE;
    }

    EnableWindow(GetDlgItem(hDlg, IDC_SENDPRI_UP),   iItem > 0); // not the top one
    EnableWindow(GetDlgItem(hDlg, IDC_SENDPRI_DOWN), iItem < (INT)dwDeviceCount - 1 ); // not the last one

    if (!IsWindowEnabled (GetFocus()))
    {
        //
        // The currently selected control turned disabled - select the list control
        //
        SetFocus (GetDlgItem (hDlg, IDC_SEND_DEVICE_LIST));
    }
    return TRUE;
}

BOOL
ChangePriority(
    HWND   hDlg,
    BOOL   bMoveUp
)
/*++

Routine Description:

    Validate the up and down button in the device select page

Arguments:

    hDlg - Handle to the Device Send Options property sheet page
    bMoveUp -- TRUE for moving up, FALSE for moving down

Return Value:

    TRUE -- if no error
    FALSE -- if error

--*/

{
    INT         iItem;
    BOOL        rslt;
    LVITEM      lv={0};
    HWND        hwndLv;
    BOOL        bChecked;
    TCHAR       pszText[MAX_DEVICE_NAME];

    DEBUG_FUNCTION_NAME(TEXT("ChangePriority()"));

    hwndLv = GetDlgItem(hDlg, IDC_SEND_DEVICE_LIST);

    iItem = ListView_GetNextItem(hwndLv, -1, LVNI_ALL | LVNI_SELECTED);
    if(iItem == -1)
    {
        return FALSE;
    }

    // 
    // get selected item information and then remove it
    //
    lv.iItem = iItem;
    lv.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lv.stateMask = LVIS_SELECTED;
    lv.pszText = pszText;
    lv.cchTextMax = MAX_DEVICE_NAME;
    ListView_GetItem(hwndLv, &lv);
    bChecked = ListView_GetCheckState(hwndLv, iItem);

    rslt = ListView_DeleteItem(hwndLv, iItem);

    //
    // recalculate the item index;
    //
    if(bMoveUp)
    {
        lv.iItem--;
    }
    else
    {
        lv.iItem++;
    }

    //
    // reinsert the item and validate button state
    //
    iItem = ListView_InsertItem(hwndLv, &lv);
    ListView_SetCheckState(hwndLv, iItem, bChecked);
    ListView_SetItemState(hwndLv, iItem, LVIS_SELECTED, LVIS_SELECTED);
    ValidateControl(hDlg, iItem);

    return TRUE;
}

VOID
CheckSendDevices(
    HWND    hDlg
    )

/*++

Routine Description:

    Display a warning if no device is selected

Arguments:

    hDlg - Handle to the "Send Device" page

Return Value:

    None

--*/

{
    HWND    hwndLv; // list view windows
    DWORD   dwDeviceIndex;
    DWORD   dwDeviceCount;
    BOOL    bDeviceSelect = FALSE; // indicate whether we have at least one device selected.

    DEBUG_FUNCTION_NAME(TEXT("CheckSendDevices()"));

    hwndLv = GetDlgItem(hDlg, IDC_SEND_DEVICE_LIST);

    dwDeviceCount = ListView_GetItemCount(hwndLv);

    if(dwDeviceCount < 1) // if there isn't device in the list.
    {
        goto exit;
    }

    for(dwDeviceIndex = 0; dwDeviceIndex < dwDeviceCount; dwDeviceIndex++)
    {       
        if(ListView_GetCheckState(hwndLv, dwDeviceIndex))
        {
            bDeviceSelect = TRUE;
            break;
        }
    }

exit:

    ShowWindow(GetDlgItem(hDlg, IDCSTATIC_NO_SEND_DEVICE), bDeviceSelect ? SW_HIDE : SW_SHOW);
    ShowWindow(GetDlgItem(hDlg, IDCSTATIC_NO_DEVICE_ERR),  bDeviceSelect ? SW_HIDE : SW_SHOW);

    return;
}

INT_PTR 
CALLBACK 
SendDeviceDlgProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "Send Device" page

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        {             
            // icon handles for up and down arrows.
            HICON  hIconUp, hIconDown;

            hIconUp = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_Up));
            hIconDown = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_Down));

            SendDlgItemMessage(hDlg, IDC_SENDPRI_UP, BM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)hIconUp);
            SendDlgItemMessage(hDlg, IDC_SENDPRI_DOWN, BM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)hIconDown);

            //
            // load device info
            //
            InitDeviceList(hDlg, IDC_SEND_DEVICE_LIST);
            DoShowSendDevices(hDlg);
            CheckSendDevices(hDlg);

            return TRUE;
        }

    case WM_COMMAND:

        switch(LOWORD(wParam)) 
        {
            case IDC_SENDPRI_UP:

                ChangePriority(hDlg, TRUE);
                break;

            case IDC_SENDPRI_DOWN:

                ChangePriority(hDlg, FALSE);
                break;

            default:
                break;
        }

        break;

    case WM_NOTIFY :
        {
        LPNMHDR lpnm = (LPNMHDR) lParam;

        switch (lpnm->code)
            {
            case PSN_SETACTIVE : 

                DoShowSendDevices(hDlg);

                // Enable the Back and Finish button    
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                break;

            case PSN_WIZBACK :
            {
                //
                // Handle a Back button click here
                //
                DoSaveSendDevices(hDlg);

                if(RemoveLastPage(hDlg))
                {
                    return TRUE;
                }
                
                break;
            }

            case PSN_WIZNEXT :
                //
                // Handle a Next button click, if necessary
                //

                DoSaveSendDevices(hDlg);
            
                //
                // switch to appropriate page
                //
                if(!IsSendEnable())
                {
                    //
                    // go to the receive configuration or completion page
                    //
                    if(g_bShowDevicePages)
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_WIZARD_RECV_SELECT_DEVICES);
                    }
                    else
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_WIZARD_COMPLETE);
                    }

                    SetLastPage(IDD_WIZARD_SEND_SELECT_DEVICES);
                    return TRUE; 
                }

                SetLastPage(IDD_WIZARD_SEND_SELECT_DEVICES);
                break;

            case PSN_RESET :
            {
                // Handle a Cancel button click, if necessary
                break;
            }

            case LVN_ITEMCHANGED:
            {
                //
                // need to validate the control after changing selection by keyboard
                // 

                LPNMLISTVIEW pnmv; 

                pnmv = (LPNMLISTVIEW) lParam; 
                ValidateControl(hDlg, pnmv->iItem); 
                CheckSendDevices(hDlg);

                break;
            }

            case NM_DBLCLK:

            {
                //
                // Handle a double click event
                //
                INT   iItem;
                HWND  hwndLv;
                hwndLv = GetDlgItem(hDlg, IDC_SEND_DEVICE_LIST);
                iItem = ((LPNMITEMACTIVATE) lParam)->iItem;
                ListView_SetCheckState(hwndLv, iItem, !ListView_GetCheckState(hwndLv, iItem));
                
                // we don't have break here because we'll go through NM_CLICK
            }

            case NM_CLICK:
            {
                //
                // Handle a Click event
                //
                HWND  hwndLv;
                LPNMITEMACTIVATE lpnmitem;
                
                lpnmitem = (LPNMITEMACTIVATE)lParam;
                hwndLv   = GetDlgItem(hDlg, IDC_SEND_DEVICE_LIST);

                ListView_SetItemState(hwndLv, lpnmitem->iItem, LVIS_SELECTED, LVIS_SELECTED);
                ValidateControl(hDlg, lpnmitem->iItem);
                CheckSendDevices(hDlg);

                break;
            }

            default :
                break;
            }
        }
        break;

    default:
        break;
    }
    return FALSE;
}


INT_PTR CALLBACK 
SendTsidDlgProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "TSID" page

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            //
            // Maximum length for various text fields in the dialog
            //

            static INT textLimits[] = 
            {
                IDC_TSID,  FXS_TSID_CSID_MAX_LENGTH + 1,
                0,
            };

            LimitTextFields(hDlg, textLimits);
            
            if(g_wizData.szTsid)
            {
                SetDlgItemText(hDlg, IDC_TSID, g_wizData.szTsid);
            }

            return TRUE;
        }


    case WM_NOTIFY :
        {
            LPNMHDR lpnm = (LPNMHDR) lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE : //Enable the Back and Finish button    

                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    break;

                case PSN_WIZBACK :
                {
                    //
                    // Handle a Back button click here
                    //
                    if(RemoveLastPage(hDlg))
                    {
                        return TRUE;
                    }

                    break;
                }

                case PSN_WIZNEXT :
                {
                    // Handle a Next button click, if necessary
                    LPTSTR    pTsid;

                    pTsid = (LPTSTR)MemAlloc((FXS_TSID_CSID_MAX_LENGTH + 1) * sizeof(TCHAR));
                    Assert(pTsid);

                    if(pTsid)
                    {
                        pTsid[0] = '\0';
                        GetDlgItemText(hDlg, IDC_TSID, pTsid, FXS_TSID_CSID_MAX_LENGTH + 1);
                
                        MemFree(g_wizData.szTsid);
                        g_wizData.szTsid = NULL;
                    }
                    else
                    {
                        LPCTSTR faxDbgFunction = TEXT("SendTsidDlgProc()");
                        DebugPrintEx(DEBUG_ERR, TEXT("Can't allocate memory for TSID."));
                    }
                    g_wizData.szTsid = pTsid;

                    if(1 == g_wizData.dwDeviceLimit && !IsReceiveEnable())
                    {
                        //
                        // go to the completion page
                        //
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_WIZARD_COMPLETE);
                        SetLastPage(IDD_WIZARD_SEND_TSID);
                        return TRUE;
                    }
                    SetLastPage(IDD_WIZARD_SEND_TSID);
                    break;
                }

                case PSN_RESET :
                {
                    // Handle a Cancel button click, if necessary
                    break;
                }

                default :
                    break;
            }

            break;
        } // WM_NOTIFY

    default:
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\cfgwzrd\welcome.c ===
#include "faxcfgwz.h"


BOOL
OpenAdminConsole(
    HWND    hDlg
    )
{
    DWORD   dwSize = 0;
    HWND    hwndAdminConsole = NULL;
    TCHAR   szAdminWindowTitle[MAX_PATH] = {0};

    DEBUG_FUNCTION_NAME(TEXT("OpenAdminConsole()"));


    if(!LoadString(g_hInstance, IDS_ADMIN_CONSOLE_TITLE, szAdminWindowTitle, MAX_PATH))
    {
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("LoadString failed: string ID=%d, error=%d"), 
                     IDS_ADMIN_CONSOLE_TITLE,
                     GetLastError());
        Assert(FALSE);
    }
    else
    {
        hwndAdminConsole = FindWindow(NULL, szAdminWindowTitle); // MMCMainFrame
    }

    if(hwndAdminConsole)
    {
        // Switch to that window if client console is already running
        ShowWindow(hwndAdminConsole, SW_RESTORE);
        SetForegroundWindow(hwndAdminConsole);
    }
    else
    {        
        ShellExecute(
                        hDlg,
                        TEXT("open"),
                        FAX_ADMIN_CONSOLE_IMAGE_NAME,
                        NULL,
                        NULL,
                        SW_SHOWNORMAL
                    );
    }

    // PropSheet_PressButton( GetParent(hDlg), PSBTN_CANCEL );
    return TRUE;
}


INT_PTR CALLBACK 
WelcomeDlgProc (
        HWND hDlg,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "Welcome" page

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    // Process messages from the Welcome page

    HWND            hwndControl;

    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            TCHAR   szText[1024] = {0}; // text for "Link Window"
            TCHAR   szTemp[1024] = {0};

            // Get the shared data from PROPSHEETPAGE lParam value
            // and load it into GWL_USERDATA
            
            // It's an intro/end page, so get the title font
            // from the shared data and use it for the title control

            Assert(g_wizData.hTitleFont);
            hwndControl = GetDlgItem(hDlg, IDCSTATIC_WELCOME_TITLE);
            SetWindowFont(hwndControl, g_wizData.hTitleFont, TRUE);

            // if there are more than one device, we'll show a warning that the wizard can
            // only config the devices into same settings.
            // will do it later.
            if((g_wizData.dwDeviceCount > 1) && !IsDesktopSKU())
            {
                // if error, we will not show the warning message.
                if(GetDlgItemText(hDlg, IDC_ADMINCONSOLE_LINK, szText, MAX_STRING_LEN))
                {
                    if(!LoadString(g_hInstance, IDS_ADMIN_CONSOLE_LINK, szTemp, MAX_PATH - 1))
                    {
                        DEBUG_FUNCTION_NAME(TEXT("WelcomeDlgProc()"));
                        DebugPrintEx(DEBUG_ERR, 
                                     TEXT("LoadString failed: string ID=%d, error=%d"), 
                                     IDS_ADMIN_CONSOLE_LINK,
                                     GetLastError());
                        Assert(FALSE);
                    }
                    else
                    {
                        _tcsncat(szText, szTemp, ARR_SIZE(szText) - _tcslen(szText)-1);
                        SetDlgItemText(hDlg, IDC_ADMINCONSOLE_LINK, szText);
                    }
                }
            }

            return TRUE;
        }

    case WM_NOTIFY :
        {
        LPNMHDR lpnm = (LPNMHDR) lParam;

        switch (lpnm->code)
            {
            case PSN_SETACTIVE : //Enable the Next button    

                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                break;

            case PSN_WIZNEXT :
                //
                // Handle a Next button click here
                //
                SetLastPage(IDD_WIZARD_WELCOME);

                break;

            case PSN_RESET :                        
                break;

            case NM_RETURN:
            case NM_CLICK:

                if( IDC_ADMINCONSOLE_LINK == lpnm->idFrom )
                {
                    OpenAdminConsole(hDlg);
                }
                break;

            default :
                break;
            }
        }
        break;

    default:
        break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\faxres\faxres.cpp ===
#include <faxres.h>
#include "resource.h"

extern "C" {

HINSTANCE g_hInst;

BOOL WINAPI DllMain(
  HINSTANCE hinstDLL,  // handle to the DLL module
  DWORD fdwReason,     // reason for calling function
  LPVOID lpvReserved   // reserved
)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {

            g_hInst = hinstDLL;
            break;
        }
    }

    return TRUE;
}

HINSTANCE WINAPI GetResInstance(void)
{
    return g_hInst;
}

UINT WINAPI GetRpcErrorStringId(DWORD ec)
{
 
    DWORD uMsgId;

    switch (ec)
    {
        case RPC_S_INVALID_BINDING:
        case EPT_S_CANT_PERFORM_OP:
        case RPC_S_ADDRESS_ERROR:
        case RPC_S_CALL_CANCELLED:
        case RPC_S_CALL_FAILED:
        case RPC_S_CALL_FAILED_DNE:
        case RPC_S_COMM_FAILURE:
        case RPC_S_NO_BINDINGS:
        case RPC_S_SERVER_TOO_BUSY:
        case RPC_S_SERVER_UNAVAILABLE:
            uMsgId = IDS_ERR_CONNECTION_FAILED;
            break;
        case FAX_ERR_DIRECTORY_IN_USE:
            uMsgId = IDS_ERR_DIRECTORY_IN_USE;
            break;
        case ERROR_NOT_ENOUGH_MEMORY:
            uMsgId = IDS_ERR_NO_MEMORY;           
            break;
        case ERROR_ACCESS_DENIED:
            uMsgId = IDS_ERR_ACCESS_DENIED;            
            break;
        case ERROR_PATH_NOT_FOUND:
            uMsgId = IDS_ERR_FOLDER_NOT_FOUND;
            break;
        case FAXUI_ERROR_DEVICE_LIMIT:
        case FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED:
            uMsgId = IDS_ERR_DEVICE_LIMIT;
            break;
        case FAXUI_ERROR_INVALID_RING_COUNT:
            uMsgId = IDS_ERR_INVALID_RING_COUNT;
            break;
        case FAXUI_ERROR_SELECT_PRINTER:
            uMsgId = IDS_ERR_SELECT_PRINTER;
            break;
        case FAXUI_ERROR_NAME_IS_TOO_LONG:
            uMsgId = IDS_ERR_NAME_IS_TOO_LONG;
            break;
        case FAXUI_ERROR_INVALID_RETRIES:
            uMsgId = IDS_ERR_INVALID_RETRIES;
            break;
        case FAXUI_ERROR_INVALID_RETRY_DELAY:
            uMsgId = IDS_ERR_INVALID_RETRY_DELAY;
            break;
        case FAXUI_ERROR_INVALID_DIRTY_DAYS:
            uMsgId = IDS_ERR_INVALID_DIRTY_DAYS;
            break;
        case FAXUI_ERROR_INVALID_TSID:
            uMsgId = IDS_ERR_INVALID_TSID;
            break;
        case FAXUI_ERROR_INVALID_CSID:
            uMsgId = IDS_ERR_INVALID_CSID;
            break;
        default:
            uMsgId = IDS_ERR_OPERATION_FAILED;
            break;
	}
    return uMsgId;
}

}   //  extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\inc\faxschemaconst.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxSchemaConst.h                                       //
//                                                                         //
//  DESCRIPTION   : All strings must be used explicitly of                 //
//                  schema containers.                                     //
//                                                                         //
//                 Do not make any inclusion from this file to others      //
//                 since file included by setup files !!!                  //                                                                      //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jun 16 1999 yossg   create                                         //
//                                                                         //
//  Copyright (C) 1999   Microsoft Corporation   All Rights Reserved       //
/////////////////////////////////////////////////////////////////////////////
#ifndef _H_FAXSCHEMACONST_H_
#define _H_FAXSCHEMACONST_H_

#define SCHEMA_DEVICEDEFAULTS_CONTAINER_NAME L"Fax-DeviceDefaults"

#endif //_H_FAXSCHEMACONST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\faxres\resource.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Definition of resource ID constants

Environment:

        Fax driver user interface

Revision History:

        02/15/01 -ivg-
                Created it.

        dd-mm-yy -author-
                description

--*/

#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#define IDS_ERR_CONNECTION_FAILED   100
#define IDS_ERR_ACCESS_DENIED       101
#define IDS_ERR_NO_MEMORY           102
#define IDS_ERR_OPERATION_FAILED    103
#define IDS_ERR_FOLDER_NOT_FOUND    104
#define IDS_ERR_DEVICE_LIMIT        105
#define IDS_ERR_INVALID_RING_COUNT  106
#define IDS_ERR_SELECT_PRINTER      107
#define IDS_ERR_NAME_IS_TOO_LONG    108
#define IDS_ERR_DIRECTORY_IN_USE    109

//
// The resource identifiers below are referred by value by FXSOCM.INF
// DO NOT CHANGE them without updating the references in FXSOCM.INF !
//
#define IDS_SEND_WIZARD_SHORTCUT        110
#define IDS_SEND_WIZARD_TOOLTIP         111
#define IDS_COVER_PAGE_EDITOR_SHORTCUT  112
#define IDS_COVER_PAGE_EDITOR_TOOLTIP   113
#define IDS_CLIENT_CONSOLE_SHORTCUT     114
#define IDS_CLIENT_CONSOLE_TOOLTIP      115
#define IDS_SERVICE_MANAGER_SHORTCUT    116
#define IDS_SERVICE_MANAGER_TOOLTIP     117
#define IDS_FAX_PROGRAM_GROUP           118
#define IDS_AWD_CONVERTOR_FRIENDLY_TYPE 119
//
// End of resource ids refered by FXSOCM.INF 
//

#define IDS_ERR_INVALID_RETRIES         1000
#define IDS_ERR_INVALID_RETRY_DELAY     1001
#define IDS_ERR_INVALID_DIRTY_DAYS      1002
#define IDS_ERR_INVALID_CSID            1003
#define IDS_ERR_INVALID_TSID            1004


#endif  // !_RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\inc\atlsnap.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATL_SNAPIN_H__
#define __ATL_SNAPIN_H__

#include <mmc.h>
#include <commctrl.h>

#pragma comment(lib, "mmc.lib")
#pragma comment(lib, "comctl32.lib")

template <class T, bool bAutoDelete = true>
class ATL_NO_VTABLE CSnapInPropertyPageImpl : public CDialogImplBase
{
public:
	PROPSHEETPAGE m_psp;

	operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CSnapInPropertyPageImpl(LPCTSTR lpszTitle = NULL)
	{
		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK;
		m_psp.hInstance = _Module.GetResourceInstance();
		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = (DLGPROC)T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
		m_psp.lParam = (LPARAM)this;

		if(lpszTitle != NULL)
		{
			m_psp.pszTitle = lpszTitle;
			m_psp.dwFlags |= PSP_USETITLE;
		}
	}

	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
	{
		ATLASSERT(hWnd == NULL);
		if(uMsg == PSPCB_CREATE)
		{
			CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}
		if (bAutoDelete && uMsg == PSPCB_RELEASE)
		{
			T* pPage = (T*)ppsp->lParam;
			delete pPage;
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		return ::CreatePropertySheetPage(&m_psp);
	}

	BOOL EndDialog(int)
	{
		// do nothing here, calling ::EndDialog will close the whole sheet
		ATLASSERT(FALSE);
		return FALSE;
	}

// Operations
	void CancelToClose()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		::SendMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
	}
	void SetModified(BOOL bChanged = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		if(bChanged)
			::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
		else
			::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0L);
	}
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		return ::SendMessage(GetParent(), PSM_QUERYSIBLINGS, wParam, lParam);
	}

	typedef CSnapInPropertyPageImpl< T, bAutoDelete > thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()

// Message handler
	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		NMHDR* pNMHDR = (NMHDR*)lParam;

		// don't handle messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = (T*)this;
		LRESULT lResult = 0;
		// handle default
		switch(pNMHDR->code)
		{
		case PSN_SETACTIVE:
			lResult = pT->OnSetActive() ? 0 : -1;
			break;
		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;
		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;
		case PSN_RESET:
			pT->OnReset();
			break;
		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;
		case PSN_WIZNEXT:
			lResult = !pT->OnWizardNext();
			break;
		case PSN_WIZBACK:
			lResult = !pT->OnWizardBack();
			break;
		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;
		case PSN_HELP:
			lResult = pT->OnHelp();
			break;
		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

// Overridables
	BOOL OnSetActive()
	{
		return TRUE;
	}
	BOOL OnKillActive()
	{
		return TRUE;
	}
	BOOL OnApply()
	{
		return TRUE;
	}
	void OnReset()
	{
	}
	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	BOOL OnWizardBack()
	{
		return TRUE;
	}
	BOOL OnWizardNext()
	{
		return TRUE;
	}
	BOOL OnWizardFinish()
	{
		return TRUE;
	}
	BOOL OnHelp()
	{
		return TRUE;
	}
};

class CSnapInItem;
class CSnapInObjectRootBase;

class CObjectData
{
public:
	CSnapInItem* m_pItem;
	DATA_OBJECT_TYPES m_type;
};

class ATL_NO_VTABLE CSnapInItem 
{
public:
	virtual ~CSnapInItem()
	{
	}
    STDMETHOD(Notify)(MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM  *pScopeDataItem) = 0;
    
    STDMETHOD(GetResultViewType)(LPOLESTR  *ppViewType,
        long  *pViewOptions) = 0;
    
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM  *pResultDataItem) = 0;
    
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long  *pInsertionAllowed,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(Command)(long lCommandID,	
		CSnapInObjectRootBase* pObj,		
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(SetControlbar)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
		CSimpleMap<UINT, IUnknown*>* pToolbarMap) = 0;
    
    STDMETHOD(ControlbarNotify)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
		CSimpleMap<UINT, IUnknown*>* pToolbarMap,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(GetScopeData)(SCOPEDATAITEM  * *pScopeDataItem) = 0;
    
    STDMETHOD(GetResultData)(RESULTDATAITEM  * *pResultDataItem) = 0;

	STDMETHOD(FillData)(CLIPFORMAT cf, 
		LPSTREAM pStream) = 0;

	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		_ASSERTE(0 && "Override this function in derived class");
	}

	static HRESULT GetDataClass(IDataObject* pDataObj, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
	{
		if (ppItem == NULL)
			return E_POINTER;
		if (pType == NULL)
			return E_POINTER;

		if (IS_SPECIAL_DATAOBJECT(pDataObj))
			return E_NOTIMPL;

		*ppItem = NULL;
		*pType = CCT_UNINITIALIZED;

		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
		FORMATETC formatetc = { m_CCF_SNAPIN_GETOBJECTDATA, 
			NULL, 
			DVASPECT_CONTENT, 
			-1, 
			TYMED_HGLOBAL 
		};

		stgmedium.hGlobal = GlobalAlloc(0, sizeof(CObjectData));
		if (stgmedium.hGlobal == NULL)
			return E_OUTOFMEMORY;

		HRESULT hr = pDataObj->GetDataHere(&formatetc, &stgmedium);
		if (SUCCEEDED(hr))
		{
			CObjectData* pData = (CObjectData*)stgmedium.hGlobal;
			 *ppItem = pData->m_pItem;
			 *pType = pData->m_type;
		}
		
		GlobalFree(stgmedium.hGlobal);
		
		return hr;
	}


	virtual HRESULT STDMETHODCALLTYPE GetDataObject(IDataObject** pDataObj, DATA_OBJECT_TYPES type) = 0;

	static void Init()
	{
		m_CCF_NODETYPE			= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_NODETYPE"));
		m_CCF_SZNODETYPE		= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SZNODETYPE"));  
		m_CCF_DISPLAY_NAME		= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_DISPLAY_NAME")); 
		m_CCF_SNAPIN_CLASSID	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SNAPIN_CLASSID"));
		m_CCF_SNAPIN_GETOBJECTDATA	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_GETOBJECTDATA"));
		m_CCF_MMC_MULTISELECT_DATAOBJECT	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_MMC_MULTISELECT_DATAOBJECT"));
	}
public:
	static CLIPFORMAT m_CCF_NODETYPE;
	static CLIPFORMAT m_CCF_SZNODETYPE;
	static CLIPFORMAT m_CCF_DISPLAY_NAME;
	static CLIPFORMAT m_CCF_SNAPIN_CLASSID;
	static CLIPFORMAT m_CCF_SNAPIN_GETOBJECTDATA;
	static CLIPFORMAT m_CCF_MMC_MULTISELECT_DATAOBJECT;
};

class CSnapInObjectRootBase
{
public:
	CComPtr <IControlbar> m_spControlbar;
	CSimpleMap <UINT, IUnknown*> m_toolbarMap;
	const int m_nType;

	CSnapInObjectRootBase(int n = 0) : m_nType(n)
	{
	}
	HRESULT GetDataClass(IDataObject* pDataObject, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
	{
		return CSnapInItem::GetDataClass(pDataObject, ppItem, pType);
	}
};

template <int n, class ComponentData>
class CSnapInObjectRoot : public CSnapInObjectRootBase
{
public :
	CSnapInObjectRoot() : CSnapInObjectRootBase(n)
	{
		m_pComponentData = NULL;
	}
	ComponentData* m_pComponentData;
};

#define EXTENSION_SNAPIN_DATACLASS(dataClass) dataClass m_##dataClass;

#define BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(classname) \
	HRESULT GetDataClass(IDataObject* pDataObject, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType) \
	{ \
		if (ppItem == NULL) \
			return E_POINTER; \
		if (pType == NULL) \
			return E_POINTER; \
\
		*ppItem = NULL; \
\
		*pType = CCT_UNINITIALIZED; \
\
		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL }; \
		FORMATETC formatetc = { CSnapInItem::m_CCF_NODETYPE, \
			NULL, \
			DVASPECT_CONTENT, \
			-1, \
			TYMED_HGLOBAL \
		}; \
\
		stgmedium.hGlobal = GlobalAlloc(0, sizeof(GUID)); \
		if (stgmedium.hGlobal == NULL) \
			return E_OUTOFMEMORY; \
\
		HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium); \
		if (FAILED(hr)) \
		{ \
			GlobalFree(stgmedium.hGlobal); \
			return hr; \
		} \
\
		GUID guid; \
		memcpy(&guid, stgmedium.hGlobal, sizeof(GUID)); \
\
		GlobalFree(stgmedium.hGlobal); \
		hr = S_OK;

#define EXTENSION_SNAPIN_NODEINFO_ENTRY(dataClass) \
		if (IsEqualGUID(guid, *(GUID*)m_##dataClass.GetNodeType())) \
		{ \
			*ppItem = m_##dataClass.GetExtNodeObject(pDataObject, &m_##dataClass); \
			_ASSERTE(*ppItem != NULL); \
			(*ppItem)->InitDataClass(pDataObject, &m_##dataClass); \
			return hr; \
		}

#define END_EXTENSION_SNAPIN_NODEINFO_MAP() \
			return CSnapInItem::GetDataClass(pDataObject, ppItem, pType); \
	};

class ATL_NO_VTABLE CSnapInDataObjectImpl : public IDataObject,
	public CComObjectRoot
{
public:
	BEGIN_COM_MAP(CSnapInDataObjectImpl)
		COM_INTERFACE_ENTRY(IDataObject)
	END_COM_MAP()
	STDMETHOD(GetData)(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetData\n"));
	}

	STDMETHOD(GetDataHere)(FORMATETC* pformatetc, STGMEDIUM* pmedium)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("SnapInDataObjectImpl::GetDataHere\n"));
		if (pmedium == NULL)
			return E_POINTER;

		HRESULT hr = DV_E_TYMED;
		// Make sure the type medium is HGLOBAL
		if (pmedium->tymed == TYMED_HGLOBAL)
		{
			// Create the stream on the hGlobal passed in
			CComPtr<IStream> spStream;
			hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &spStream);
			if (SUCCEEDED(hr))
				if (pformatetc->cfFormat == CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA)
				{
					hr = DV_E_CLIPFORMAT;
					ULONG uWritten;
					hr = spStream->Write(&m_objectData, sizeof(CObjectData), &uWritten);
				}
				else
					hr = m_objectData.m_pItem->FillData(pformatetc->cfFormat, spStream);
		}
		return hr;
	}

	STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::QueryGetData\n"));
	}
	STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetCanonicalFormatEtc\n"));
	}
	STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::EnumFormatEtc\n"));
	}
	STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
		DWORD *pdwConnection)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(DUnadvise)(DWORD dwConnection)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetDatan\n"));
	}
	STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}

	CObjectData m_objectData;
};


template <class T, class Component>
class ATL_NO_VTABLE IComponentDataImpl : public IComponentData 
{
public :
	IComponentDataImpl()
	{
		m_pNode = NULL;
	}

    STDMETHOD(Initialize)(LPUNKNOWN pUnknown)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentDataImpl::Initialize\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pUnknown != NULL);
		if (pUnknown == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IComponentData::Initialize called with pUnknown == NULL\n"));
		else
		{
			hr = pUnknown->QueryInterface(&m_spConsole);
			if (FAILED(hr))
				ATLTRACE2(atlTraceSnapin, 0, _T("QI for IConsole failed\n"));
		}

		return hr;
	}

	STDMETHOD(CreateComponent)(LPCOMPONENT *ppComponent)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentDataImpl::CreateComponent\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(ppComponent != NULL);
		if (ppComponent == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IComponentData::CreateComponent called with ppComponent == NULL\n"));
		else
		{
			*ppComponent = NULL;
			
			CComObject< Component >* pComponent;
			hr = CComObject< Component >::CreateInstance(&pComponent);
			ATLASSERT(SUCCEEDED(hr));
			if (FAILED(hr))
				ATLTRACE2(atlTraceSnapin, 0, _T("IComponentData::CreateComponent : Could not create IComponent object\n"));
			else
			{
				pComponent->m_pComponentData = static_cast<T*>(this);
				hr = pComponent->QueryInterface(IID_IComponent, (void**)ppComponent);
			}
		}
		return hr;
	}

    
    STDMETHOD(Notify)( 
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentDataImpl::Notify\n"));
		ATLASSERT(lpDataObject != NULL && _T("Override Notify in derived class handle notifications for which lpDataObject == NULL"));
		HRESULT hr = E_POINTER;

		ATLASSERT(lpDataObject != NULL);
		if (lpDataObject == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IComponentData::Notify called with lpDataObject == NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
			ATLASSERT(SUCCEEDED(hr));
			if (SUCCEEDED(hr))
				hr = pItem->Notify(event, arg, param, pT, NULL, type);
		}
		return hr;
	}

    STDMETHOD(Destroy)(void)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentDataImpl::Destroy\n"));

		T* pT = static_cast<T*>(this);
		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		m_spConsole.Release();
		return S_OK;
	}

    STDMETHOD(QueryDataObject)(LONG_PTR cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentDataImpl::QueryDataObject\n"));
		HRESULT hr = E_POINTER;
		
		ATLASSERT(ppDataObject != NULL);
		if (ppDataObject == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IComponentData::QueryDataObject called with ppDataObject == NULL\n"));
		else
		{
			*ppDataObject = NULL;
			
			CSnapInItem* pItem = (CSnapInItem*) cookie;
			if (cookie == NULL)
				pItem = m_pNode;

			hr = pItem->GetDataObject(ppDataObject, type);
		}
		return hr;
	}
    
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM *pScopeDataItem)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentDataImpl::GetDisplayInfo\n"));


		HRESULT hr = E_POINTER;
		
		ATLASSERT(pScopeDataItem != NULL);
		if (pScopeDataItem == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IComponentData::GetDisplayInfo called with pScopeDataItem == NULL\n"));
		else
		{
			CSnapInItem* pItem= (CSnapInItem*) pScopeDataItem->lParam;
			if (pItem == NULL)
				pItem = m_pNode;

			hr = E_UNEXPECTED;
			if (pItem != NULL)
				hr = pItem->GetScopePaneInfo(pScopeDataItem);
		}
		return hr;
	}
    
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
	{
		ATLTRACENOTIMPL(_T("IComponentDataImpl::CompareObjects\n"));
    }

	CComPtr<IConsole> m_spConsole;
	CSnapInItem* m_pNode;
};


template <class T>
class ATL_NO_VTABLE IComponentImpl : public IComponent
{
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentImpl::Initialize\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(lpConsole != NULL);
		if (lpConsole == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("lpConsole is NULL\n"));
		else
		{
			m_spConsole = lpConsole;
	
			CComPtr<IHeaderCtrl> spHeaderCtrl;
			hr = m_spConsole.QueryInterface(&spHeaderCtrl);
			if (FAILED(hr))
				ATLTRACE2(atlTraceSnapin, 0, _T("QI for IHeaderCtrl failed\n"));
			else
			{
				hr = m_spConsole->SetHeader(spHeaderCtrl);
				if (FAILED(hr))
					ATLTRACE2(atlTraceSnapin, 0, _T("IConsole::SetHeader failed (HRESULT = %x)\n"), hr);
			}
		}
		return hr;
	}
    
	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentImpl::Notify\n"));
		ATLASSERT(lpDataObject != NULL && _T("Override Notify in derived class handle notifications for which lpDataObject == NULL"));		
		HRESULT hr = E_POINTER;

		if (lpDataObject == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IComponent::Notify called with lpDataObject==NULL \n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			// Make sure that the object is derived from CSnapInObjectRoot
			hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
			if (SUCCEEDED(hr))
				hr = pItem->Notify(event, arg, param, NULL, pT, type);
		}
		return hr;
	}
    
    STDMETHOD(Destroy)(LONG_PTR cookie)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentImpl::Destroy\n"));

		T* pT = static_cast<T*>(this);

		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		m_spConsole->SetHeader(NULL);
		m_spConsole.Release();
		return S_OK;
	}
    
    STDMETHOD(QueryDataObject)(LONG_PTR cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentImpl::QueryDataObject\n"));

		ATLASSERT(ppDataObject != NULL);
		if (ppDataObject == NULL)
		{
			ATLTRACE2(atlTraceSnapin, 0, _T("IComponent::QueryDataObject called with ppDataObject==NULL \n"));
			return E_POINTER;
		}
		
		if (cookie == NULL)
		{
			ATLTRACE2(atlTraceSnapin, 0, _T("IComponent::QueryDataObject called with cookie==NULL \n"));
			return E_UNEXPECTED;
		}

		*ppDataObject = NULL;
		if (cookie == MMC_MULTI_SELECT_COOKIE)
		{
			ATLTRACE2(atlTraceSnapin, 0, _T("Override QueryDataObject to handle multiselect\n"));
			return E_UNEXPECTED;
		}

		CSnapInItem* pItem = (CSnapInItem*) cookie;
		return pItem->GetDataObject(ppDataObject, type);
	}
    
    STDMETHOD(GetResultViewType)(LONG_PTR cookie,
        LPOLESTR  *ppViewType,
        long  *pViewOptions)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentImpl::GetResultViewType\n"));

		HRESULT hr = E_FAIL;
		if (cookie == NULL)
		{
			T* pT = static_cast<T*> (this);
			ATLASSERT( pT->m_pComponentData != NULL );
			ATLASSERT( pT->m_pComponentData->m_pNode != NULL );
			hr = pT->m_pComponentData->m_pNode->GetResultViewType(ppViewType, pViewOptions);
		}
		else
		{
			CSnapInItem* pItem = (CSnapInItem*)cookie;
			hr = pItem->GetResultViewType(ppViewType, pViewOptions);
		}
		return hr;
	}
    
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM *pResultDataItem)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentImpl::GetDisplayInfo\n"));

		ATLASSERT(pResultDataItem != NULL);
		if (pResultDataItem == NULL)
		{
			ATLTRACE2(atlTraceSnapin, 0, _T("IComponent::GetDisplayInfo called with pResultDataItem==NULL\n"));
			return E_POINTER;
		}

		CSnapInItem* pItem = (CSnapInItem*) pResultDataItem->lParam;

		if (pItem == NULL)
		{
			ATLTRACE2(atlTraceSnapin, 0, _T("Invalid Item\n"));
			return E_UNEXPECTED;
		}
		return pItem->GetResultPaneInfo(pResultDataItem);
	}
    
    STDMETHOD(CompareObjects)( LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
	{
		ATLTRACENOTIMPL(_T("IComponentImpl::CompareObjects\n"));
	}

	CComPtr<IConsole> m_spConsole;
};

template <class T, class D>        
class ATL_NO_VTABLE IResultDataCompareImpl : public IResultDataCompare
{
public:
    STDMETHOD(Compare)(long lUserParam,
        long cookieA,
        long cookieB,
        int *pnResult)
	{
		ATLTRACENOTIMPL(_T("IResultDataCompareImpl::Compare"));
	}
};


template <class T>
class ATL_NO_VTABLE IExtendContextMenuImpl : public IExtendContextMenu
{
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
        LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenuImpl::AddMenuItems\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenu::AddMenuItems called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

			if (SUCCEEDED(hr))
				hr = pItem->AddMenuItems(piCallback, pInsertionAllowed, type);
		}
		return hr;
	}
    
    STDMETHOD(Command)(long lCommandID,
        LPDATAOBJECT pDataObject)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenuImpl::Command\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenu::Command called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);
			
			if (SUCCEEDED(hr))
				hr = pItem->Command(lCommandID, (CSnapInObjectRootBase*)pT, type);
		}
		return hr;
	}
};

template<class T>
class ATL_NO_VTABLE IExtendPropertySheetImpl : public IExtendPropertySheet
{
public:
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        LPDATAOBJECT pDataObject)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IExtendPropertySheetImpl::CreatePropertyPages\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IExtendPropertySheetImpl::CreatePropertyPages called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

			if (SUCCEEDED(hr))
				hr = pItem->CreatePropertyPages(lpProvider, handle, this, type);
		}

		return hr;
	}
    
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IExtendPropertySheetImpl::QueryPagesFor\n"));
		

		HRESULT hr = E_POINTER;
		
		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IExtendPropertySheetImpl::QueryPagesFor called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

			if (SUCCEEDED(hr))
				hr = pItem->QueryPagesFor(type);
		}
		return hr;
	}
};

template <class T>
class ATL_NO_VTABLE IExtendControlbarImpl : public IExtendControlbar
{
public:
	STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IExtendControlbarImpl::SetControlbar\n"));
		T* pT = static_cast<T*>(this);

		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		pT->m_spControlbar = pControlbar;
		return S_OK;
	}
    
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IExtendControlbarImpl::ControlbarNotify\n"));

		CSnapInItem* pItem = NULL;
		DATA_OBJECT_TYPES type;
		HRESULT hr = S_OK;
		T* pT = static_cast<T*>(this);

		if (event == MMCN_BTN_CLICK)
			hr = pT->m_pComponentData->GetDataClass((IDataObject*) arg, &pItem, &type);
		else if (event == MMCN_SELECT)
		{
			hr = pT->m_pComponentData->GetDataClass((IDataObject*) param, &pItem, &type);
			BOOL bSelect = (BOOL) HIWORD (arg);
			BOOL bScope = (BOOL) LOWORD(arg); 
			if (bSelect)
			{
				int n = pT->m_toolbarMap.GetSize();
				for (int i = 0; i < n; i++)
				{
					IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
					 if (pToolbar != NULL)
						pT->m_spControlbar->Detach(pToolbar);
				}
			}
		}

		if (SUCCEEDED(hr))
			hr = pItem->ControlbarNotify(pT->m_spControlbar, this, &(pT->m_toolbarMap), event, arg, param, (CSnapInObjectRootBase*) pT, type);

		return hr;
	}
};

#define SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}

#define EXT_SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}

#define BEGIN_SNAPINCOMMAND_MAP(theClass, bIsExtension) \
	HRESULT ProcessCommand(UINT nID, \
		bool& bHandled, \
		CSnapInObjectRootBase* pObj, \
		DATA_OBJECT_TYPES type) \
	{ \
			bHandled = true; \
			HRESULT hr = S_OK;

#define SNAPINCOMMAND_ENTRY(id, func) \
		if (id == nID) \
		{ \
			hr = func(bHandled, pObj); \
			if (bHandled) \
				return hr; \
		}

#define SNAPINCOMMAND_RANGE_ENTRY(id1, id2, func) \
		if (id1 <= nID && nID <= id2) \
		{ \
			hr = func(nID, bHandled, pObj); \
			if (bHandled) \
				return hr; \
		}

#define CHAIN_SNAPINCOMMAND_MAP(theChainClass) \
	{ \
		hr = theChainClass::ProcessCommand(nID, bHandled, pObj, type); \
		if (bHandled) \
			return hr; \
	}

#define END_SNAPINCOMMAND_MAP() \
			return hr; \
	}

struct CSnapInToolBarData
{
	WORD wVersion;
	WORD wWidth;
	WORD wHeight;
	WORD wItemCount;
	//WORD aItems[wItemCount]

	WORD* items()
		{ return (WORD*)(this+1); }
};

#define RT_TOOLBAR  MAKEINTRESOURCE(241)
	
class CSnapInToolbarInfo
{
public:
	void __stdcall CleanUp(DWORD dw)
	{
		if (m_pStrToolTip)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrToolTip[i];
				m_pStrToolTip[i] = NULL;
			}
			delete [] m_pStrToolTip;
			m_pStrToolTip = NULL;
		}

		if (m_pStrButtonText)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrButtonText[i];
				m_pStrButtonText[i] = NULL;
			}

			delete [] m_pStrButtonText;
			m_pStrButtonText = NULL;
		}
		if (m_pnButtonID)
		{
			delete m_pnButtonID;
			m_pnButtonID = NULL;
		}

		m_nButtonCount = 0;
	}

	OLECHAR** m_pStrToolTip;
	OLECHAR** m_pStrButtonText;
	UINT* m_pnButtonID;
	UINT m_idToolbar;
	UINT m_nButtonCount;
};

#define BEGIN_SNAPINTOOLBARID_MAP(theClass) \
public: \
	static CSnapInToolbarInfo* GetToolbarInfo() \
	{ \
		static CSnapInToolbarInfo m_toolbarInfo[] = \
		{

#define SNAPINTOOLBARID_ENTRY(id) \
			{ NULL, NULL, NULL, id, 0},

#define END_SNAPINTOOLBARID_MAP() \
			{ NULL, NULL, NULL, 0, 0} \
		}; \
		return m_toolbarInfo; \
	}

template <class T, BOOL bIsExtension = FALSE>
class ATL_NO_VTABLE CSnapInItemImpl : public CSnapInItem
{
public:
	CSnapInItemImpl()
	{
	}

	virtual ~CSnapInItemImpl()
	{
	}    

public:

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::Notify"));
	}
    
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem)
	{
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetScopePaneInfo"));
	}
    
    STDMETHOD(GetResultViewType)(LPOLESTR *ppViewType,
        long *pViewOptions)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("CSnapInItemImpl::GetResultViewType\n"));
		*ppViewType = NULL;
		*pViewOptions = MMC_VIEW_OPTIONS_NONE;
		return S_FALSE;
	}
    
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem)
	{
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetResultPaneInfo"));
	}
    
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("CSnapInItemImpl::AddMenuItems\n"));
		T* pT = static_cast<T*>(this);

		if (!bIsExtension)
			pT->SetMenuInsertionFlags(true, pInsertionAllowed);

		UINT menuID = pT->GetMenuID();
		if (menuID == 0)
			return S_OK;

		HMENU hMenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(menuID));
		long insertionID;
		if (hMenu)
		{
			for (int i = 0; 1; i++)
			{
				HMENU hSubMenu = GetSubMenu(hMenu, i);
				if (hSubMenu == NULL)
					break;
				
				MENUITEMINFO menuItemInfo;
				memset(&menuItemInfo, 0, sizeof(menuItemInfo));
				menuItemInfo.cbSize = sizeof(menuItemInfo);

				switch (i)
				{
				case 0:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
					break;

				case 1:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_NEW;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
					break;

				case 2:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
					break;
				case 3:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
					break;
				default:
					{
						insertionID = 0;
						continue;
					}
					break;
				}

				menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
				menuItemInfo.fType = MFT_STRING;
				TCHAR szMenuText[128];

				for (int j = 0; 1; j++)
				{
					menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
					menuItemInfo.fType = MFT_STRING;
					menuItemInfo.cch = 128;
					menuItemInfo.dwTypeData = szMenuText;
					TCHAR szStatusBar[256];

					if (!GetMenuItemInfo(hSubMenu, j, TRUE, &menuItemInfo))
						break;
					if (menuItemInfo.fType != MFT_STRING)
						continue;

					pT->UpdateMenuState(menuItemInfo.wID, szMenuText, &menuItemInfo.fState);
					LoadString(_Module.GetResourceInstance(), menuItemInfo.wID, szStatusBar, 256);

					OLECHAR wszStatusBar[256];
					OLECHAR wszMenuText[128];
					USES_CONVERSION;
					ocscpy(wszMenuText, T2OLE(szMenuText));
					ocscpy(wszStatusBar, T2OLE(szStatusBar));

					CONTEXTMENUITEM contextMenuItem;
					contextMenuItem.strName = wszMenuText;
					contextMenuItem.strStatusBarText = wszStatusBar;
					contextMenuItem.lCommandID = menuItemInfo.wID;
					contextMenuItem.lInsertionPointID = insertionID;
					contextMenuItem.fFlags = menuItemInfo.fState;
					contextMenuItem.fSpecialFlags = 0;
					
					HRESULT hr = piCallback->AddItem(&contextMenuItem);
					ATLASSERT(SUCCEEDED(hr));
				}
			}
			DestroyMenu(hMenu);
		}

		if (!bIsExtension)
			pT->SetMenuInsertionFlags(true, pInsertionAllowed);

		return S_OK;
	}
    
    STDMETHOD(Command)(long lCommandID,
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("CSnapInItemImpl::Command\n"));
		bool bHandled;
		T* pT = static_cast<T*>(this);
		return pT->ProcessCommand(lCommandID, bHandled, pObj, type);
	}
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::CreatePropertyPages"));
	}
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::QueryPagesFor"));
	}

    STDMETHOD(SetControlbar)(IControlbar *pControlbar, 
		IExtendControlbar* pExtendControlBar,
		CSimpleMap<UINT, IUnknown*>* pToolbarMap)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("CSnapInItemImpl::SetControlbar\n"));
		static bool m_bAddTermFunc = false;
		if (!m_bAddTermFunc)
		{
			m_bAddTermFunc = true;
			AtlModuleAddTermFunc(&_Module, CleanUpToolbarInfo, 0);
		}

		T* pT = static_cast<T*>(this);

		CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
		if (pInfo == NULL)
			return S_OK;

		for( ; pInfo->m_idToolbar; pInfo++)
		{
			IToolbar* p = (IToolbar*) pToolbarMap->Lookup(pInfo->m_idToolbar);
			if (p != NULL)
				continue;

			HBITMAP hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar));
			if (hBitmap == NULL)
				return S_OK;

			HRSRC hRsrc = ::FindResource(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar), RT_TOOLBAR);
			if (hRsrc == NULL)
				return S_OK;

			HGLOBAL hGlobal = LoadResource(_Module.GetResourceInstance(), hRsrc);
			if (hGlobal == NULL)
				return S_OK;

			CSnapInToolBarData* pData = (CSnapInToolBarData*)LockResource(hGlobal);
			if (pData == NULL)
				return S_OK;
			ATLASSERT(pData->wVersion == 1);
			ATLASSERT(pData->wWidth == 16);
			ATLASSERT(pData->wHeight == 16);

			pInfo->m_nButtonCount = pData->wItemCount;
			if (pInfo->m_pnButtonID == NULL)
				pInfo->m_pnButtonID = new UINT[pInfo->m_nButtonCount];

			if (pInfo->m_pnButtonID == NULL)
				continue;

			MMCBUTTON *pButtons = new MMCBUTTON[pData->wItemCount];
			if (pButtons == NULL)
			{
				delete []pInfo->m_pnButtonID;
				continue;
			}
			
			if (pInfo->m_pStrToolTip == NULL)
			{
				pInfo->m_pStrToolTip = new OLECHAR* [pData->wItemCount];
				if (pInfo->m_pStrToolTip)
					memset(pInfo->m_pStrToolTip, 0, sizeof(OLECHAR*) * pData->wItemCount);
			}

			if (pInfo->m_pStrToolTip == NULL)
			{
				delete []pInfo->m_pnButtonID;
				delete []pButtons;
				continue;
			}
		
			for (int i = 0, j = 0; i < pData->wItemCount; i++)
			{
				pInfo->m_pnButtonID[i] = pButtons[i].idCommand = pData->items()[i];
				if (pButtons[i].idCommand)
				{
					pButtons[i].nBitmap = j++;
					// get the statusbar string and allow modification of the button state
					TCHAR szStatusBar[512];
					LoadString(_Module.GetResourceInstance(), pButtons[i].idCommand, szStatusBar, 512);

					if (pInfo->m_pStrToolTip[i] == NULL)
						pInfo->m_pStrToolTip[i] = new OLECHAR[lstrlen(szStatusBar) + 1];
					if (pInfo->m_pStrToolTip[i] == NULL)
						continue;
					USES_CONVERSION;
					ocscpy(pInfo->m_pStrToolTip[i], T2OLE(szStatusBar));
					pButtons[i].lpTooltipText = pInfo->m_pStrToolTip[i];
					pButtons[i].lpButtonText = OLESTR("");
					pButtons[i].fsState = TBSTATE_ENABLED;
					pButtons[i].fsType = TBSTYLE_BUTTON;
					pT->SetToolbarButtonInfo(pButtons[i].idCommand, &pButtons[i].fsState, &pButtons[i].fsType);
				}
				else
				{
					pButtons[i].lpTooltipText = OLESTR("");
					pButtons[i].lpButtonText = OLESTR("");
					pButtons[i].fsType = TBSTYLE_SEP;
					pButtons[i].fsState = 0;
				}
			}

			IToolbar* pToolbar;
	        HRESULT hr = pControlbar->Create(TOOLBAR, pExtendControlBar, reinterpret_cast<LPUNKNOWN*>(&pToolbar));
			if (SUCCEEDED(hr))
			{

				hr = pToolbar->AddBitmap(pData->wItemCount, hBitmap, pData->wWidth, pData->wHeight, RGB(192, 192, 192));
				if (SUCCEEDED(hr))
				{
					hr = pToolbar->AddButtons(pData->wItemCount, pButtons);
					if (SUCCEEDED(hr))
					{
						pToolbar->AddRef();
						pToolbarMap->Add(pInfo->m_idToolbar, (IUnknown*)pToolbar);
					}
				}
			}
			pToolbar->Release();
			delete [] pButtons;
		}
		return S_OK;
	}
    
    STDMETHOD(ControlbarNotify)(IControlbar *pControlbar,
        IExtendControlbar *pExtendControlbar,
		CSimpleMap<UINT, IUnknown*>* pToolbarMap,
		MMC_NOTIFY_TYPE event,
        LPARAM arg, 
		LPARAM param,
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("CSnapInItemImpl::ControlbarNotify\n"));
		T* pT = static_cast<T*>(this);

		SetControlbar(pControlbar, pExtendControlbar, pToolbarMap);

		if(event == MMCN_SELECT)
		{
			if (pControlbar == NULL)
				return S_OK;

			BOOL bSelect = (BOOL) HIWORD (arg);
			if (!bSelect)
				return S_OK;
			BOOL bScope = (BOOL) LOWORD(arg); 

			CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
			if (pInfo == NULL)
				return S_OK;

			for(; pInfo->m_idToolbar; pInfo++)
			{
				IToolbar* pToolbar = (IToolbar*)pToolbarMap->Lookup(pInfo->m_idToolbar);
				if (pToolbar == NULL)
					continue;
				pControlbar->Attach(TOOLBAR, pToolbar);
				for (UINT i = 0; i < pInfo->m_nButtonCount; i++)
				{
					if (pInfo->m_pnButtonID[i])
					{
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							ENABLED,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								ENABLED));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							CHECKED,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								CHECKED));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							HIDDEN,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								HIDDEN));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							INDETERMINATE,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								INDETERMINATE));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							BUTTONPRESSED,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								BUTTONPRESSED));
					}
				}
			}
			return S_OK;
		}
		else if (event == MMCN_BTN_CLICK)
		{
			bool bHandled;
			return pT->ProcessCommand((UINT) param, bHandled, pObj, type);
		}

		return E_UNEXPECTED;
	}

	STDMETHOD(GetScopeData)(SCOPEDATAITEM **pScopeDataItem)
	{
		if (pScopeDataItem == NULL)
			return E_FAIL;

		*pScopeDataItem = &m_scopeDataItem;
		return S_OK;
	}
        
    STDMETHOD(GetResultData)(RESULTDATAITEM **pResultDataItem)
	{
		if (pResultDataItem == NULL)
			return E_FAIL;

		*pResultDataItem = &m_resultDataItem;
		return S_OK;
	}

	STDMETHOD(GetDataObject)(IDataObject** pDataObj, DATA_OBJECT_TYPES type)
	{
		CComObject<CSnapInDataObjectImpl>* pData;
		HRESULT hr = CComObject<CSnapInDataObjectImpl>::CreateInstance(&pData);
		if (FAILED(hr))
			return hr;

		T* pT = static_cast<T*> (this);
		pData->m_objectData.m_pItem = pT;
		pData->m_objectData.m_type = type;

		hr = pData->QueryInterface(IID_IDataObject, (void**)(pDataObj));
		return hr;
	}

	void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
	{
		return;
	}

	void SetToolbarButtonInfo(UINT id, BYTE *pfsState, BYTE *pfsType)
	{
		*pfsState = TBSTATE_ENABLED;
		*pfsType = TBSTYLE_BUTTON;
	}

	BOOL UpdateToolbarButton(UINT id, BYTE fsState)
	{
		if (fsState == ENABLED)
			return TRUE;
		return FALSE;
	}

	HRESULT ProcessCommand(UINT nID, 
		bool& bHandled,
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("No handler for item with ID %d\n"), nID);
		return S_OK;
	}

	STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream)
	{
		HRESULT hr = DV_E_CLIPFORMAT;
		ULONG uWritten;

		T* pT = static_cast<T*> (this);

		if (cf == m_CCF_NODETYPE)
		{
			hr = pStream->Write(pT->GetNodeType(), sizeof(GUID), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SZNODETYPE)
		{
			hr = pStream->Write(pT->GetSZNodeType(), (ocslen((OLECHAR*)pT->GetSZNodeType()) + 1 )* sizeof(OLECHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_DISPLAY_NAME)
		{
			hr = pStream->Write(pT->GetDisplayName(), (ocslen((OLECHAR*)pT->GetDisplayName()) + 1) * sizeof(OLECHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SNAPIN_CLASSID)
		{
			hr = pStream->Write(pT->GetSnapInCLSID(), sizeof(GUID), &uWritten);
			return hr;
		}

		return hr;
	}

	static CSnapInToolbarInfo* GetToolbarInfo()
	{
		return NULL;
	}
	static void _stdcall CleanUpToolbarInfo(ULONG_PTR dw)
	{
		for (CSnapInToolbarInfo* pInfo = T::GetToolbarInfo(); pInfo->m_idToolbar != 0; pInfo++)
		{
			pInfo->CleanUp(PtrToUlong(&dw));
		}
	}


	static const UINT GetMenuID() 
	{
		return 0;
	}

	void SetMenuInsertionFlags(bool bBeforeInsertion, long* pInsertionAllowed)
	{
	}

	void* GetNodeType()
	{
		return (void*)T::m_NODETYPE;
	}
	void* GetSZNodeType()
	{
		return (void*)T::m_SZNODETYPE;
	}

	void* GetDisplayName()
	{
		return (void*)T::m_SZDISPLAY_NAME;
	}

	void* GetSnapInCLSID()
	{
		return (void*)T::m_SNAPIN_CLASSID;
	}

	CComBSTR m_bstrDisplayName;
	SCOPEDATAITEM m_scopeDataItem;
	RESULTDATAITEM m_resultDataItem;
};


_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_NODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SZNODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_DISPLAY_NAME = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_CLASSID = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_MMC_MULTISELECT_DATAOBJECT = 0;

#endif //__ATL_SNAPIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\cataloginboundroutingmethod.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CatalogInboundRoutingMethod.h                          //
//                                                                         //
//  DESCRIPTION   : Header file for the InboundRoutingMethod node class.   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan 27 2000 yossg  Create                                          //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXCATALOG_INBOUNDROUTINGMETHOD_H
#define H_FAXCATALOG_INBOUNDROUTINGMETHOD_H

#include "snapin.h"
#include "snpnode.h"

#include "Icons.h"

#include "ppFaxCatalogInboundRoutingMethod.h"

class CppFaxCatalogInboundRoutingMethod;
class CFaxCatalogInboundRoutingMethodsNode;

class CFaxCatalogInboundRoutingMethodNode : public CSnapinNode <CFaxCatalogInboundRoutingMethodNode, FALSE>
{

public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxCatalogInboundRoutingMethodNode, FALSE)
        SNAPINCOMMAND_ENTRY(IDM_CMETHOD_MOVEUP,    OnMoveUp)
        SNAPINCOMMAND_ENTRY(IDM_CMETHOD_MOVEDOWN,  OnMoveDown)
        SNAPINCOMMAND_ENTRY(ID_MOVEUP_BUTTON,   OnMoveUp)
        SNAPINCOMMAND_ENTRY(ID_MOVEDOWN_BUTTON, OnMoveDown)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxCatalogInboundRoutingMethodNode)
        SNAPINTOOLBARID_ENTRY(IDR_TOOLBAR_METHOD_UD)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_CATALOGMETHOD_MENU)

    //
    // Constructor
    //
    CFaxCatalogInboundRoutingMethodNode (CSnapInItem * pParentNode, CSnapin * pComponentData, PFAX_GLOBAL_ROUTING_INFO pMethodConfig) :
        CSnapinNode<CFaxCatalogInboundRoutingMethodNode, FALSE>(pParentNode, pComponentData )
    {
    }

    //
    // Destructor
    //
    ~CFaxCatalogInboundRoutingMethodNode()
    {
    }

    LPOLESTR GetResultPaneColInfo(int nCol);

    void InitParentNode(CFaxCatalogInboundRoutingMethodsNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        IUnknown* pUnk,
        DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }
    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    HRESULT    Init(PFAX_GLOBAL_ROUTING_INFO pMethodConfig);

    VOID       SetOrder(DWORD dwOrder)  { m_dwPriority = dwOrder; return; }

    HRESULT    ReselectItemInView(IConsole *pConsole);

    void       UpdateMenuState (UINT id, LPTSTR pBuf, UINT *flags);

    BOOL       UpdateToolbarButton(UINT id, BYTE fsState);

    //
    // FillData
    //
    STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream);

    //
    // Clipboard Formats
    //
    static CLIPFORMAT m_CFExtensionName;
    static CLIPFORMAT m_CFMethodGuid;
    static CLIPFORMAT m_CFServerName;
    static CLIPFORMAT m_CFDeviceId;

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:
    //
    // Parent Node
    //
    CFaxCatalogInboundRoutingMethodsNode * m_pParentNode;

    //
    // members
    //
    CComBSTR  m_bstrFriendlyName;       //pointer to method's user-friendly name
    CComBSTR  m_bstrExtensionFriendlyName; //pointer to DLL's user-friendly name
    DWORD     m_dwPriority;             
    CComBSTR  m_bstrMethodGUID;         //GUID that uniquely identifies 
    CComBSTR  m_bstrExtensionImageName; //pointer to DLL that implements method

    // currently not in use

    //CComBSTR  m_bstrDeviceName;         //pointer to device name
    //CComBSTR  m_bstrFunctionName;       //pointer to method's function name
    //DWORD     m_dwSizeOfStruct;         //structure size, in bytes
            
    CComBSTR  m_buf; 

    //
    // Menu item handlers
    //
    HRESULT OnMoveUp  (bool &bHandled, CSnapInObjectRootBase *pRoot);
    HRESULT OnMoveDown(bool &bHandled, CSnapInObjectRootBase *pRoot);


    //
    //  Init
    //
    HRESULT  InitMembers (PFAX_GLOBAL_ROUTING_INFO pMethodConfig);
    
};

//typedef CSnapinNode<CFaxCatalogInboundRoutingMethodNode, FALSE> CBaseFaxInboundRoutingMethodNode;

#endif  //H_FAXCATALOG_INBOUNDROUTINGMETHOD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\cataloginboundroutingmethod.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CatalogInboundRoutingMethod.cpp                        //
//                                                                         //
//  DESCRIPTION   : Implementation of the Inbound Routing Method node.     //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan 27 2000 yossg  Create                                          //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "snapin.h"

#include "CatalogInboundRoutingMethod.h"
#include "CatalogInboundRoutingMethods.h"

#include "FaxServer.h"
#include "FaxServerNode.h"


#include "oaidl.h"
#include "urlmon.h"
#include "mshtmhst.h"
#include "exdisp.h"
#include "faxmmc.h"

/////////////////////////////////////////////////////////////////////////////
// {220D2CB0-85A9-4a43-B6E8-9D66B44F1AF5}
static const GUID CFaxCatalogInboundRoutingMethodNodeGUID_NODETYPE = 
{ 0x220d2cb0, 0x85a9, 0x4a43, { 0xb6, 0xe8, 0x9d, 0x66, 0xb4, 0x4f, 0x1a, 0xf5 } };

const GUID*     CFaxCatalogInboundRoutingMethodNode::m_NODETYPE        = &CFaxCatalogInboundRoutingMethodNodeGUID_NODETYPE;
const OLECHAR*  CFaxCatalogInboundRoutingMethodNode::m_SZNODETYPE      = OLESTR("220D2CB0-85A9-4a43-B6E8-9D66B44F1AF5");
const CLSID*    CFaxCatalogInboundRoutingMethodNode::m_SNAPIN_CLASSID  = &CLSID_Snapin;

CLIPFORMAT CFaxCatalogInboundRoutingMethodNode::m_CFExtensionName = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_ROUTEEXT_NAME);
CLIPFORMAT CFaxCatalogInboundRoutingMethodNode::m_CFMethodGuid = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_ROUTING_METHOD_GUID);
CLIPFORMAT CFaxCatalogInboundRoutingMethodNode::m_CFServerName = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_SERVER_NAME);
CLIPFORMAT CFaxCatalogInboundRoutingMethodNode::m_CFDeviceId = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_DEVICE_ID);



/*
 -  CFaxCatalogInboundRoutingMethodNode::Init
 -
 *  Purpose:
 *      Init all members icon etc.
 *
 *  Arguments:
 *      [in]    pMethodConfig - PFAX_GLOBAL_ROUTING_INFO
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCatalogInboundRoutingMethodNode::Init(PFAX_GLOBAL_ROUTING_INFO pMethodConfig)
{

    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodNode::Init"));
    HRESULT hRc = S_OK;

    ATLASSERT(pMethodConfig);

    hRc = InitMembers( pMethodConfig );
    if (FAILED(hRc))
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to InitMembers"));
        
        //NodeMsgBox done by called func.
        
        goto Exit;
    }
    
    //
    // Icon
    //
    m_resultDataItem.nImage = IMAGE_METHOD_ENABLE;

Exit:
    return hRc;
}

/*
 -  CFaxCatalogInboundRoutingMethodNode::InitMembers
 -
 *  Purpose:
 *      Private method to initiate members
 *      Must be called after init of m_pParentNode
 *
 *  Arguments:
 *      [in]    pMethodConfig - PFAX_GLOBAL_ROUTING_INFO structure
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCatalogInboundRoutingMethodNode::InitMembers(PFAX_GLOBAL_ROUTING_INFO pMethodConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodNode::InitMembers"));
    HRESULT hRc = S_OK;

    ATLASSERT(pMethodConfig);
    
    m_dwPriority         = pMethodConfig->Priority;
    
    m_bstrDisplayName    = pMethodConfig->FriendlyName;
    if (!m_bstrDisplayName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    m_bstrFriendlyName   = pMethodConfig->FriendlyName;
    if (!m_bstrFriendlyName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    m_bstrMethodGUID     = pMethodConfig->Guid;
    if (!m_bstrMethodGUID)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    m_bstrExtensionFriendlyName   
                         = pMethodConfig->ExtensionFriendlyName;
    if (!m_bstrExtensionFriendlyName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    m_bstrExtensionImageName   
                         = pMethodConfig->ExtensionImageName;
    if (!m_bstrExtensionImageName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    ATLASSERT(NULL != m_pParentNode);
    if (NULL != m_pParentNode)
    {
        m_pParentNode->NodeMsgBox(IDS_MEMORY);
    }
    
Exit:
    return (hRc);
}

/*
 -  CFaxCatalogInboundRoutingMethodNode::GetResultPaneColInfo
 -
 *  Purpose:
 *      Return the text for specific column
 *      Called for each column in the result pane
 *
 *  Arguments:
 *      [in]    nCol - column number
 *
 *  Return:
 *      String to be displayed in the specific column
 */
LPOLESTR CFaxCatalogInboundRoutingMethodNode::GetResultPaneColInfo(int nCol)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodNode::GetResultPaneColInfo"));
    HRESULT hRc = S_OK;

    WCHAR buff[FXS_DWORD_LEN+1];
    int iCount;

    m_buf.Empty();

    switch (nCol)
    {
    case 0:
            //
            // Name
            //
            if (!m_bstrFriendlyName)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrFriendlyName."));
                goto Error;
            }
            else
            {
                return (m_bstrFriendlyName);
            }

    case 1:
            //
            // Order
            //
            iCount = swprintf(buff, L"%ld", m_dwPriority);
    
            if( iCount <= 0 )
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory - Fail to allocate bstr."));
                goto Error;
            }
            else
            {
                m_buf = buff;
                if (!m_buf)
                {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to read member - m_dwPriority."));
                    hRc = E_OUTOFMEMORY;
                    goto Error;
                }
                return (m_buf);
            }

    case 2:
            //
            // Extension 
            //
            if (!m_bstrExtensionFriendlyName)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrExtensionFriendlyName."));
                goto Error;
            }
            else
            {
                return (m_bstrExtensionFriendlyName);
            }

    default:
            ATLASSERT(0); // "this number of column is not supported "
            return(L"");

    } // endswitch (nCol)

Error:
    return(L"???");

}


/*
 -  CFaxCatalogInboundRoutingMethodNode::CreatePropertyPages
 -
 *  Purpose:
 *      Called when creating a property page of the object
 *
 *  Arguments:
 *      [in]    lpProvider - The property sheet
 *      [in]    handle     - Handle for notification
 *      [in]    pUnk       - Pointer to the data object
 *      [in]    type       - CCT_* (SCOPE, RESULT, ...)
 *
 *  Return:
 *      OLE error code
 */

HRESULT
CFaxCatalogInboundRoutingMethodNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                    LONG_PTR                handle,
                                    IUnknown                *pUnk,
                                    DATA_OBJECT_TYPES       type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodNode::CreatePropertyPages"));
    
    HRESULT hRc = S_OK;

    HPROPSHEETPAGE hPage;
    CppFaxCatalogInboundRoutingMethod * pPropPageMethodGeneral = NULL;


    ATLASSERT(lpProvider);
    ATLASSERT(type == CCT_RESULT || type == CCT_SCOPE);

    //
    // General
    //
    pPropPageMethodGeneral = new CppFaxCatalogInboundRoutingMethod(
												 handle,
                                                 this,
                                                 TRUE,
                                                 _Module.GetResourceInstance());

	if (!pPropPageMethodGeneral)
	{
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
        goto Error;
	}
    
    hRc = pPropPageMethodGeneral->Init(   //m_bstrMethodGUID,
                                          //m_bstrFriendlyName, 
                                          m_bstrExtensionImageName                                            
                                          //,m_bstrExtensionFriendlyName
                                       );
    if (FAILED(hRc))
    {
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
        goto Error;
    }
    
    hPage = pPropPageMethodGeneral->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to Create() property page. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add property page for General tab. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pPropPageMethodGeneral ) 
    {
        delete  pPropPageMethodGeneral;    
        pPropPageMethodGeneral = NULL;    
    }

Exit:
    return hRc;
}


/*
 -  CFaxCatalogInboundRoutingMethodNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxCatalogInboundRoutingMethodNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // Display verbs that we support:
    // 1. Properties
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    //
    // We want the default verb to be Properties
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    return hRc;
}


/*
-  CFaxCatalogInboundRoutingMethodNode::OnMoveDown
-
*  Purpose:
*      Call to move down device
*
*  Arguments:
*
*  Return:
*      OLE error code
*/
HRESULT  CFaxCatalogInboundRoutingMethodNode::OnMoveDown(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodNode::OnMoveDown"));
    DWORD dwMaxOrder;

    ATLASSERT(m_pParentNode);

    //
    // Validity Check
    //
    dwMaxOrder = m_pParentNode->GetMaxOrder();
    if (
         ( 0 == dwMaxOrder ) // list was not populated successfully
        ||
         ( 1 > m_dwPriority ) 
        ||
         ( dwMaxOrder < m_dwPriority+1 )
       )
    {
		DebugPrintEx(
			DEBUG_ERR,
			_T("Invalid operation. Can not move device order down."));
        
        return (S_FALSE);
    }
    else
    {
        return(m_pParentNode->ChangeMethodPriority( 
                                    m_dwPriority, 
                                    m_dwPriority+1, 
                                    m_bstrMethodGUID,
                                    pRoot) );
    }
}

/*
-  CFaxCatalogInboundRoutingMethodNode::OnMoveUp
-
*  Purpose:
*      To move up in the view the device
*
*  Arguments:
*
*  Return:
*      OLE error code
*/
HRESULT  CFaxCatalogInboundRoutingMethodNode::OnMoveUp(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodNode::OnMoveUp"));
    DWORD dwMaxOrder;

    ATLASSERT(m_pParentNode);

    //
    // Validity Check
    //
    dwMaxOrder = m_pParentNode->GetMaxOrder();
    if (
         ( 0 == dwMaxOrder ) // list was not populated successfully
        ||
         ( dwMaxOrder < m_dwPriority )
        ||
         ( 1 > m_dwPriority-1 )
       )
    {
		DebugPrintEx(
			DEBUG_ERR,
			_T("Invalid operation. Can not move device order up."));
        
        return (S_FALSE);
    }
    else
    {
        return (m_pParentNode->ChangeMethodPriority( m_dwPriority, 
                                                  m_dwPriority-1, 
                                                  m_bstrMethodGUID,
                                                  pRoot) );
    }
}


/*
 -  CFaxCatalogInboundRoutingMethodNode::ReselectItemInView
 -
 *  Purpose:
 *      Reselect the node to redraw toolbar buttons
 *
 *  Arguments:
 *      [in]    pConsole - the console interface
 *
 *  Return: OLE error code
 */
HRESULT CFaxCatalogInboundRoutingMethodNode::ReselectItemInView(IConsole *pConsole)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodNode::ReselectItemInView"));
    HRESULT     hRc = S_OK;

    //
    // Need IResultData
    //
    CComQIPtr<IResultData, &IID_IResultData> pResultData(pConsole);
    ATLASSERT(pResultData != NULL);

    //
    // Reselect the node to redraw toolbar buttons.
    //
    hRc = pResultData->ModifyItemState( 0, m_resultDataItem.itemID, LVIS_SELECTED | LVIS_FOCUSED, 0 );
    if ( S_OK != hRc )
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Failure on pResultData->ModifyItemState, (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL2REFRESH_THEVIEW);
        goto Exit;
    }

Exit:
    return hRc;
}

/*
 -  CFaxCatalogInboundRoutingMethodNode::UpdateMenuState
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateMenuState
 *      which only have one line inside it "return;" 
 *      This function implements the grayed\ungrayed view for the 
 *      the Enable and the Disable menus.
 *
 *  Arguments:

 *            [in]  id    - unsigned int with the menu IDM value
 *            [out] pBuf  - string 
 *            [out] flags - pointer to flags state combination unsigned int
 *
 *  Return:
 *      no return value - void function 
 */
void CFaxCatalogInboundRoutingMethodNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodNode::UpdateMenuState"));

    UNREFERENCED_PARAMETER (pBuf);
    
    DWORD dwMaxPriority;
    
    switch (id)
    {
        case IDM_CMETHOD_MOVEUP:

            *flags = ((FXS_FIRST_METHOD_PRIORITY == m_dwPriority) ?  MF_GRAYED : MF_ENABLED );           

            break;

        case IDM_CMETHOD_MOVEDOWN:
            
            ATLASSERT(NULL != m_pParentNode);
            dwMaxPriority = m_pParentNode->GetMaxOrder();

            *flags = ((dwMaxPriority == m_dwPriority)  ?  MF_GRAYED : MF_ENABLED );

            break;

        default:
            break;
    }
    
    return;
}




/*
 -  CFaxCatalogInboundRoutingMethodNode::UpdateToolbarButton
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateToolbarButton
 *      This function aloow us to decide if to the activate\grayed a toolbar button  
 *      It treating only the Enable state.
 *
 *  Arguments:
 *
 *            [in]  id    - unsigned int for the toolbar button ID
 *            [in]  fsState  - state to be cosidered ENABLE ?HIDDEN etc. 
 *
 *  Return:
 *     BOOL TRUE to activate state FALSE to disabled the state for this button 
 */
BOOL CFaxCatalogInboundRoutingMethodNode::UpdateToolbarButton(UINT id, BYTE fsState)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::UpdateToolbarButton"));
    BOOL bRet = FALSE;	
	    
    DWORD dwMaxPriority;

    // Set whether the buttons should be enabled.
    if (fsState == ENABLED)
    {

        switch ( id )
        {
            case ID_MOVEUP_BUTTON:

                bRet = ( (FXS_FIRST_METHOD_PRIORITY == m_dwPriority) ?  FALSE : TRUE );           

                break;

            case ID_MOVEDOWN_BUTTON:
                
                ATLASSERT(NULL != m_pParentNode);
                dwMaxPriority = m_pParentNode->GetMaxOrder();

                bRet = ( (dwMaxPriority == m_dwPriority)  ?  FALSE : TRUE);
                
                break;
        
            default:
                break;

        }

    }

    // For all other possible button ID's and states, 
    // the correct answer here is FALSE.
    return bRet;

}

/*
 +
 +
 *
 *  CFaxCatalogInboundRoutingMethodNode::FillData
 *
 *
 *   Override CSnapInItem::FillData for private cliboard formats
 *
 *
 *   Parameters
 *
 *   Return Values
 *
 -
 -
 */

HRESULT  CFaxCatalogInboundRoutingMethodNode::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodNode::FillData"));
	
    HRESULT hr = DV_E_CLIPFORMAT;
	ULONG uWritten;


    if (cf == m_CFExtensionName)
	{
		hr = pStream->Write((VOID *)(LPWSTR)m_bstrExtensionImageName, 
                            sizeof(WCHAR)*(m_bstrExtensionImageName.Length()+1), 
                            &uWritten);
		return hr;
	}
	if (cf == m_CFMethodGuid)
	{
		hr = pStream->Write((VOID *)(LPWSTR)m_bstrMethodGUID, 
                            sizeof(WCHAR)*(m_bstrMethodGUID.Length()+1), 
                            &uWritten);
		return hr;
	}

	if (cf == m_CFServerName)
	{
		CComBSTR bstrServerName = ((CFaxServerNode *)GetRootNode())->GetServerName();
		hr = pStream->Write((VOID *)(LPWSTR)bstrServerName, 
                            sizeof(WCHAR)*(bstrServerName.Length()+1), 
                            &uWritten);
		return hr;
	}

    if (cf == m_CFDeviceId)
	{
                DWORD dwDeviceID = FXS_GLOBAL_METHOD_DEVICE_ID; //== 0 : Global incoming method sign
                hr = pStream->Write((VOID *)&dwDeviceID, sizeof(DWORD), &uWritten);
		return hr;
	}

    return CSnapInItemImpl<CFaxCatalogInboundRoutingMethodNode>::FillData(cf, pStream);
}   // CFaxCatalogInboundRoutingMethodNode::FillData

/*
 +
 +  CFaxCatalogInboundRoutingMethodNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxCatalogInboundRoutingMethodNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    _TCHAR topicName[MAX_PATH];
    _tcscpy(topicName, helpFile);
    _tcscat(topicName, _T("::/FaxS_C_RcvdFaxRout.htm"));
    
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(topicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, topicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\cataloginboundroutingmethods.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CatalogInboundRoutingMethods.h                         //
//                                                                         //
//  DESCRIPTION   : Header file for the Fax Inbound Routing Methods Node   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan 27 2000 yossg  Create                                          //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXCATALOG_INBOUNDROUTINGMETHODS_H
#define H_FAXCATALOG_INBOUNDROUTINGMETHODS_H

#include "snapin.h"
#include "snpnres.h"


#include "CatalogInboundRoutingMethod.h"
 
class CFaxInboundRoutingNode;
class CFaxCatalogInboundRoutingMethodNode;

class CFaxCatalogInboundRoutingMethodsNode : public CNodeWithResultChildrenList<
                                        CFaxCatalogInboundRoutingMethodsNode,    
                                        CFaxCatalogInboundRoutingMethodNode, 
                                        CSimpleArray<CFaxCatalogInboundRoutingMethodNode*>, 
                                        FALSE>
{

public:

    BEGIN_SNAPINCOMMAND_MAP(CFaxCatalogInboundRoutingMethodNode, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxCatalogInboundRoutingMethodNode)
    END_SNAPINTOOLBARID_MAP()

    //
    // Constructor
    //
    CFaxCatalogInboundRoutingMethodsNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithResultChildrenList<CFaxCatalogInboundRoutingMethodsNode, CFaxCatalogInboundRoutingMethodNode, CSimpleArray<CFaxCatalogInboundRoutingMethodNode*>, FALSE>(pParentNode, pComponentData )
    {
        m_dwNumOfInboundMethods     = 0;
        m_fSuccess = FALSE;
    }

    //
    // Destructor
    //
    ~CFaxCatalogInboundRoutingMethodsNode()
    {
    }

    virtual HRESULT PopulateResultChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl *pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    virtual HRESULT OnRefresh(LPARAM arg,
                              LPARAM param,
                              IComponentData *pComponentData,
                              IComponent * pComponent,
                              DATA_OBJECT_TYPES type);

    HRESULT DoRefresh(CSnapInObjectRootBase *pRoot);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }

    HRESULT InitDisplayName();

    void InitParentNode(CFaxInboundRoutingNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    HRESULT ChangeMethodPriority(DWORD dwOldOrder, DWORD dwNewOrder, CComBSTR bstrMethodGUID, CSnapInObjectRootBase *pRoot);

    DWORD   GetMaxOrder()   
                { return( m_fSuccess ? m_dwNumOfInboundMethods : 0); }

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:
    HRESULT InitRPC(PFAX_GLOBAL_ROUTING_INFO  *pFaxInboundMethodsConfig);

    static CColumnsInfo         m_ColsInfo;
    
    DWORD                       m_dwNumOfInboundMethods;
    
    CFaxInboundRoutingNode *    m_pParentNode;

    // Succeed to populate all methods
    BOOL                        m_fSuccess;  
};

typedef CNodeWithResultChildrenList<CFaxCatalogInboundRoutingMethodsNode, CFaxCatalogInboundRoutingMethodNode, CSimpleArray<CFaxCatalogInboundRoutingMethodNode*>, FALSE>
        CBaseFaxCatalogInboundRoutingMethodsNode;

#endif  //H_FAXCATALOG_INBOUNDROUTINGMETHODS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\cataloginboundroutingmethods.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CatalogInboundRoutingMethods.cpp                       //
//                                                                         //
//  DESCRIPTION   : Fax InboundRoutingMethods MMC node.                    //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan 27 2000 yossg  Create                                          //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "snapin.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "CatalogInboundRoutingMethods.h"
#include "InboundRouting.h"

#include "oaidl.h"
#include "Icons.h"

//////////////////////////////////////////////////////////////
// {3452FECB-E56E-4fca-943D-E8B516F8063E}
static const GUID CFaxCatalogInboundRoutingMethodsNodeGUID_NODETYPE = 
{ 0x3452fecb, 0xe56e, 0x4fca, { 0x94, 0x3d, 0xe8, 0xb5, 0x16, 0xf8, 0x6, 0x3e } };

const GUID*    CFaxCatalogInboundRoutingMethodsNode::m_NODETYPE = &CFaxCatalogInboundRoutingMethodsNodeGUID_NODETYPE;
const OLECHAR* CFaxCatalogInboundRoutingMethodsNode::m_SZNODETYPE = OLESTR("3452FECB-E56E-4fca-943D-E8B516F8063E");
const CLSID*   CFaxCatalogInboundRoutingMethodsNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxCatalogInboundRoutingMethodsNode::m_ColsInfo;

/*
 -  CFaxCatalogInboundRoutingMethodsNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxCatalogInboundRoutingMethodsNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodsNode::InsertColumns"));
    HRESULT  hRc = S_OK;

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_CATALOG_INMETHODS_COL1, FXS_WIDE_COLUMN_WIDTH},
        {IDS_CATALOG_INMETHODS_COL2, AUTO_WIDTH},
        {IDS_CATALOG_INMETHODS_COL3, FXS_LARGE_COLUMN_WIDTH},
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    CHECK_RETURN_VALUE_AND_PRINT_DEBUG (_T("m_ColsInfo.InsertColumnsIntoMMC"))

Cleanup:
    return(hRc);
}

/*
 -  CFaxCatalogInboundRoutingMethodsNode::initRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCatalogInboundRoutingMethodsNode::InitRPC(PFAX_GLOBAL_ROUTING_INFO  *pFaxInboundMethodsConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodsNode::InitRPC"));
    
    HRESULT      hRc        = S_OK;
    DWORD        ec         = ERROR_SUCCESS;

    CFaxServer * pFaxServer = NULL;

    ATLASSERT(NULL == (*pFaxInboundMethodsConfig) );

    //
    // get Fax Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }
    ATLASSERT(NULL != m_pParentNode);
    

    //
	// Retrieve the fax Inbound Methods configuration
	//
    if (!FaxEnumGlobalRoutingInfo(pFaxServer->GetFaxServerHandle(), 
                        pFaxInboundMethodsConfig,
                        &m_dwNumOfInboundMethods)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get inbound methods catalog. (ec: %ld)"), 
			ec);


        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }


        goto Error; 
    }
    //For max verification
    ATLASSERT(pFaxInboundMethodsConfig);

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get Inbound Methods configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);

    NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}


/*
 -  CFaxCatalogInboundRoutingMethodsNode::PopulateResultChildrenList
 -
 *  Purpose:
 *      Create the FaxInboundRoutingMethods children nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCatalogInboundRoutingMethodsNode::PopulateResultChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodsNode::PopulateResultChildrenList"));
    HRESULT hRc = S_OK;

    CFaxCatalogInboundRoutingMethodNode *   pMethod = NULL;
                       
    PFAX_GLOBAL_ROUTING_INFO  pFaxInboundMethodsConfig = NULL ;
    DWORD i;

    //
    // Get the Config. structure 
    //
    hRc = InitRPC(&pFaxInboundMethodsConfig);
    if (FAILED(hRc))
    {
        //DebugPrint and MsgBox by called func.
        
        //to be safe actually done by InitRPC on error.
        pFaxInboundMethodsConfig = NULL;
        
        goto Error;
    }
    ATLASSERT(NULL != pFaxInboundMethodsConfig);
                       
    for ( i=0; i< m_dwNumOfInboundMethods; i++ )
    {
            pMethod = new CFaxCatalogInboundRoutingMethodNode(this, 
                                            m_pComponentData, 
                                            &pFaxInboundMethodsConfig[i]);
            if (!pMethod)
            {
                hRc = E_OUTOFMEMORY;
                NodeMsgBox(IDS_MEMORY);
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. (hRc: %08X)"),
			        hRc);
                goto Error;
            }
            else
            {
	            pMethod->InitParentNode(this);

                hRc = pMethod->Init(&pFaxInboundMethodsConfig[i]);
	            if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to Init property page members. (hRc: %08X)"),
			            hRc);
		            // NodeMsgBox by called func.
                    goto Error;
	            }

	            hRc = this->AddChildToList(pMethod);
	            if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to add property page for General Tab. (hRc: %08X)"),
			            hRc);
		            NodeMsgBox(IDS_FAILTOADD_INBOUNDROUTINGMETHODS);
                    goto Error;
	            }
                else
                {
                    pMethod = NULL;
                }
            }
    }
    ATLASSERT(S_OK == hRc);

    //
    // Success ToPopulateAllDevices to allow 
    // giving total number of devices to each device
    // when asked for reordering purposes
    //
    m_fSuccess = TRUE;

    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pMethod ) 
    {
        delete  pMethod;    
        pMethod = NULL;    
    }
    
    //
    // Get rid of what we had.
    //
    {
        // Delete each node in the list of children
        int iSize = m_ResultChildrenList.GetSize();
        for (int j = 0; j < iSize; j++)
        {
            pMethod = (CFaxCatalogInboundRoutingMethodNode *)
                                    m_ResultChildrenList[j];
            delete pMethod;
            pMethod = NULL;
        }

        // Empty the list
        m_ResultChildrenList.RemoveAll();

        // We no longer have a populated list.
        m_bResultChildrenListPopulated = FALSE;
    }
    
Exit:
    if (NULL != pFaxInboundMethodsConfig)
    {
        FaxFreeBuffer(pFaxInboundMethodsConfig);
    }       
    
    return hRc;
}



/*
 -  CFaxCatalogInboundRoutingMethodsNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxCatalogInboundRoutingMethodsNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    //  Refresh
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 

    return hRc;
}



/*
 -  CFaxCatalogInboundRoutingMethodsNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
/* virtual */HRESULT
CFaxCatalogInboundRoutingMethodsNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodsNode::OnRefresh"));
    HRESULT hRc = S_OK;


    //
    // Call the base class
    //
    hRc = CBaseFaxCatalogInboundRoutingMethodsNode::OnRefresh(arg,
                             param,
                             pComponentData,
                             pComponent,
                             type);
    if ( FAILED(hRc) )
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to call base class's OnRefresh. (hRc: %08X)"),
			hRc);
        goto Exit;
    }


Exit:
    return hRc;
}


/*
 -  CFaxCatalogInboundRoutingMethodsNode::DoRefresh
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxCatalogInboundRoutingMethodsNode::DoRefresh(CSnapInObjectRootBase *pRoot)
{
    CComPtr<IConsole> spConsole;

    //
    // Repopulate childs
    //
    RepopulateResultChildrenList();

    if (pRoot)
    {
        //
        // Get the console pointer
        //
        ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
        if (pRoot->m_nType == 1)
        {
            //
            // m_ntype == 1 means the IComponentData implementation
            //
            CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
            spConsole = pCComponentData->m_spConsole;
        }
        else
        {
            //
            // m_ntype == 2 means the IComponent implementation
            //
            CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
            spConsole = pCComponent->m_spConsole;
        }
    }
    else
    {
        ATLASSERT(m_pComponentData);
        spConsole = m_pComponentData->m_spConsole;
    }

    ATLASSERT(spConsole);
    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return S_OK;
}

/*
 -  CFaxCatalogInboundRoutingMethodsNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCatalogInboundRoutingMethodsNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxCatalogInboundRoutingMethodsNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                        IDS_DISPLAY_STR_METHODSCATALOGNODE))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}



/*
 -  CFaxCatalogInboundRoutingMethodsNode::ChangeMethodPriority
 -
 *  Purpose:
 *      This func moves up or down specific method in the catalog order
 *
 *  Arguments:
 *      [in] dwNewOrder - specifies the new order +1 /-1 inrelative to current order.
 *      [in] bstrMethodGUID - method GUID
 *      [in] pChildNode - the method node object.
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCatalogInboundRoutingMethodsNode::ChangeMethodPriority(DWORD dwOldOrder, DWORD dwNewOrder, CComBSTR bstrMethodGUID, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodsNode::ChangeMethodPriority"));

    HRESULT      hRc        = S_OK;
    DWORD        ec         = ERROR_SUCCESS;

    CFaxServer * pFaxServer = NULL;

    const DWORD dwOldIndex = dwOldOrder-1;
    const DWORD dwNewIndex = dwNewOrder-1; 
    
    DWORD dwN;

    CFaxCatalogInboundRoutingMethodNode * pMethodNode = NULL;

    PFAX_GLOBAL_ROUTING_INFO pRoutingInfo     = NULL;

    PFAX_GLOBAL_ROUTING_INFO pPrimaryMethod;
    PFAX_GLOBAL_ROUTING_INFO pSecondaryMethod;

    CComPtr<IConsole> spConsole;

    //
    // Validity asserts
    //
    ATLASSERT(dwNewIndex< m_dwNumOfInboundMethods);
    ATLASSERT(dwNewIndex>= 0);
    ATLASSERT(dwOldIndex< m_dwNumOfInboundMethods);
    ATLASSERT(dwOldIndex>= 0);
    
    ATLASSERT( ( dwOldIndex-dwNewIndex == 1) 
                    || ( dwOldIndex-dwNewIndex == -1) );


    //
    // RPC change Order
    //   

    //
    // 0) get server handle
    //
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // 1) Get info
    //
    if (!FaxEnumGlobalRoutingInfo(pFaxServer->GetFaxServerHandle(), 
                      &pRoutingInfo,
					  &m_dwNumOfInboundMethods)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get inbound routing method catalog configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(pRoutingInfo);

    //
    // 2) Swap priority between methods 
    //
    pPrimaryMethod   = NULL;
    pSecondaryMethod = NULL;

    for (dwN = 0; dwN < m_dwNumOfInboundMethods; dwN++)
    {
        if ( dwOldOrder == pRoutingInfo[dwN].Priority)
        {
            pPrimaryMethod = &pRoutingInfo[dwN];
        }
        else if ( dwNewOrder == pRoutingInfo[dwN].Priority )
        {
            pSecondaryMethod = &pRoutingInfo[dwN];
        }

        if ((NULL != pSecondaryMethod) && (NULL != pPrimaryMethod))
        {
            break;
        }
    }
    ATLASSERT( (NULL != pPrimaryMethod) && (NULL != pSecondaryMethod) );

    pPrimaryMethod->Priority   = dwNewOrder; 
    pSecondaryMethod->Priority = dwOldOrder; 


    //
    // 3) Set Configuration
    //
    
    //
    // Primary Method
    //
    if (!FaxSetGlobalRoutingInfo(
                        pFaxServer->GetFaxServerHandle(), 
                        pPrimaryMethod) ) 
	{
        ec = GetLastError();

        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to set primary method with new priority. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }
        goto Error; 
    }
    
    
    //
    // Secondary Method
    //
	if (!FaxSetGlobalRoutingInfo(
                        pFaxServer->GetFaxServerHandle(), 
                        pSecondaryMethod) ) 
	{
        ec = GetLastError();

        DebugPrintEx(
			DEBUG_ERR,
			_T("set secondary method with new priority. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }
        goto Error; 
    }
    DebugPrintEx( DEBUG_MSG, _T("Fail to set primary method with new priority"));
    //Success of RPC operations
    
    
    //
    // 4) Now to MMC
    // 
    
    //
    // Local swap
    //
    pMethodNode = m_ResultChildrenList[dwOldIndex];
    m_ResultChildrenList[dwOldIndex] = m_ResultChildrenList[dwNewIndex];
    m_ResultChildrenList[dwNewIndex] = pMethodNode;

    //
    // Fix the order members
    //
    m_ResultChildrenList[dwOldIndex]->SetOrder(dwOldOrder);
    m_ResultChildrenList[dwNewIndex]->SetOrder(dwNewOrder);
    
    
    //
    // Get console
    //
    if (pRoot)
    {
        //
        // Get the console pointer
        //
        ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
        if (pRoot->m_nType == 1)
        {
            //
            // m_ntype == 1 means the IComponentData implementation
            //
            CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
            spConsole = pCComponentData->m_spConsole;
        }
        else
        {
            //
            // m_ntype == 2 means the IComponent implementation
            //
            CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
            spConsole = pCComponent->m_spConsole;
        }
    }
    else
    {
        ATLASSERT(m_pComponentData);
        spConsole = m_pComponentData->m_spConsole;
    }
    ATLASSERT(spConsole);
    
    //
    // UpdateAllViews
    //
    spConsole->UpdateAllViews(NULL, (LPARAM)this, NULL);

    //
    // Reselect the moved item in his new place
    //
    m_ResultChildrenList[dwNewIndex]->ReselectItemInView(spConsole);
        

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to set devices new order for Outbound Routing group."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    if ( NULL != pRoutingInfo )
        FaxFreeBuffer(pRoutingInfo);

    return hRc;
}

/*
 +
 +  CFaxCatalogInboundRoutingMethodsNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxCatalogInboundRoutingMethodsNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    _TCHAR topicName[MAX_PATH];
    
    _tcscpy(topicName, helpFile);
    
    _tcscat(topicName, _T("::/FaxS_C_RcvdFaxRout.htm"));
    
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(topicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, topicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

///////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\coverpage.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CoverPage.h                                            //
//                                                                         //
//  DESCRIPTION   : Header file for the cover page node.                   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Feb  9 2000 yossg  Create                                          //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 2000  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXCOVERPAGE_H
#define H_FAXCOVERPAGE_H

#include "snapin.h"
#include "snpnode.h"

#include "Icons.h"

class CFaxCoverPagesNode;

class CFaxCoverPageNode : public CSnapinNode <CFaxCoverPageNode, FALSE>
{

public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxCoverPageNode, FALSE)
      SNAPINCOMMAND_ENTRY(IDM_EDIT_COVERPAGE,  OnEditCoverPage)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxCoverPageNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_COVERPAGE_MENU)

    //
    // Constructor
    //
    CFaxCoverPageNode (CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CSnapinNode<CFaxCoverPageNode, FALSE>(pParentNode, pComponentData )
    {
    }

    //
    // Destructor
    //
    ~CFaxCoverPageNode()
    {
    }

    LPOLESTR GetResultPaneColInfo(int nCol);

    void InitParentNode(CFaxCoverPagesNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);


    HRESULT OnEditCoverPage(bool &bHandled, CSnapInObjectRootBase *pRoot);
    
    
    virtual HRESULT OnDelete(LPARAM arg, 
                             LPARAM param,
                             IComponentData *pComponentData,
                             IComponent *pComponent,
                             DATA_OBJECT_TYPES type,
                             BOOL fSilent = FALSE);

    virtual HRESULT OnDoubleClick(LPARAM arg, 
                             LPARAM param,
                             IComponentData *pComponentData,
                             IComponent *pComponent,
                             DATA_OBJECT_TYPES type);

    HRESULT    Init(WIN32_FIND_DATA * pCoverPageConfig);

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

    void    UpdateMenuState (UINT id, LPTSTR pBuf, UINT *flags);

private:
    //
    // Parent Node
    //
    CFaxCoverPagesNode * m_pParentNode;

    //
    // members
    //
    CComBSTR               m_bstrTimeFormatted;
    CComBSTR               m_bstrFileSize;
    
};

//typedef CSnapinNode<CFaxCoverPageNode, FALSE> CBaseFaxInboundRoutingMethodNode;

#endif  //H_FAXCOVERPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\coverpage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CoverPage.cpp                                          //
//                                                                         //
//  DESCRIPTION   : Implementation of the cover page result node.          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Feb  9 2000 yossg  Create                                          //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 2000  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "snapin.h"

#include "CoverPage.h"
#include "CoverPages.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "FaxMMCPropertyChange.h"

#include "oaidl.h"
#include "urlmon.h"
#include "mshtmhst.h"
#include "exdisp.h"

#include <windows.h>
#include <shlwapi.h>
#include <faxreg.h>

/////////////////////////////////////////////////////////////////////////////
// {D0F52487-3C98-4d1a-AF15-4033900DCCDC}
static const GUID CFaxCoverPageNodeGUID_NODETYPE = 
{ 0xd0f52487, 0x3c98, 0x4d1a, { 0xaf, 0x15, 0x40, 0x33, 0x90, 0xd, 0xcc, 0xdc } };

const GUID*     CFaxCoverPageNode::m_NODETYPE        = &CFaxCoverPageNodeGUID_NODETYPE;
const OLECHAR*  CFaxCoverPageNode::m_SZNODETYPE      = OLESTR("D0F52487-3C98-4d1a-AF15-4033900DCCDC");
//const OLECHAR* CnotImplemented::m_SZDISPLAY_NAME = OLESTR("Cover Pages");
const CLSID*    CFaxCoverPageNode::m_SNAPIN_CLASSID  = &CLSID_Snapin;


/*
 -  CFaxCoverPageNode::Init
 -
 *  Purpose:
 *      Init all members icon etc.
 *
 *  Arguments:
 *      [in]    pRuleConfig - PFAX_OUTBOUND_ROUTING_RULE
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCoverPageNode::Init(WIN32_FIND_DATA * pCoverPageData)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPageNode::Init"));

    DWORD               ec          = ERROR_SUCCESS;

    _FILETIME           FileTime;
    SYSTEMTIME          SystemTime;
    TCHAR               szLastModifiedTimeStr[MAX_PATH+1];
    TCHAR               szDateBuf[MAX_PATH+1];    

    ULARGE_INTEGER      uliFileSize; 
    CHAR                szFileSize[MAX_PATH+1];

    CComBSTR            bstrDate;
    CComBSTR            bstrTime;


    ATLASSERT(pCoverPageData);

    m_bstrDisplayName = pCoverPageData->cFileName;
    if (!m_bstrDisplayName)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        
        DebugPrintEx( DEBUG_ERR, 
            _T("Null m_bstrDisplayName - out of memory."));
        
        goto Error;
    }

    //
    // Last Modified
    //
	
    if (!FileTimeToLocalFileTime(
                &pCoverPageData->ftLastWriteTime,
                &FileTime
                )
       )
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to convert LocalTimeToFileTime. (ec: %ld)"), 
			ec);

        goto Error;

    }

    if (!FileTimeToSystemTime(
                &FileTime, 
                &SystemTime)
       )
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to convert FileTimeToSystemTime. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // a. Create a string specifying the date
    //
    if (!GetY2KCompliantDate (LOCALE_USER_DEFAULT,                  // Get user's locale
                        DATE_SHORTDATE,                             // Short date format
                        &SystemTime,                                // Source date/time
                        szDateBuf,                                  // Output buffer
                        sizeof(szDateBuf)/ sizeof(szDateBuf[0])     // MAX_PATH Output buffer size
                       ))
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to GetY2KCompliantDate. (ec: %ld)"), 
			ec);

        goto Error;
    }
    else
    {
        bstrDate = szDateBuf;
        if (!bstrDate)
        {
            ec = ERROR_NOT_ENOUGH_MEMORY;
        
            DebugPrintEx( DEBUG_ERR, 
                _T("empty m_bstrTimeFormated - out of memory."));
        
            goto Error;
        }
    }
    //
    // b. Create a string specifying the time
    //
    if (!FaxTimeFormat(
              LOCALE_USER_DEFAULT,    //Locale
              TIME_NOSECONDS,		  //dwFlags options
              &SystemTime,            //CONST SYSTEMTIME time
              NULL,                   //LPCTSTR lpFormat time format string
              szLastModifiedTimeStr,  //formatted string buffer
              sizeof(szLastModifiedTimeStr)/ sizeof(szLastModifiedTimeStr[0])// MAX_PATH// size of string buffer
              )
       )
    {
        ec = GetLastError();
        DebugPrintEx(
          DEBUG_ERR,
          _T("Fail to FaxTimeFormat. (ec: %ld)"), 
          ec);

        goto Error;
    }
    else
    {
        bstrTime = szLastModifiedTimeStr;
        if (!bstrTime)
        {
            ec = ERROR_NOT_ENOUGH_MEMORY;
        
            DebugPrintEx( DEBUG_ERR, 
                _T("empty m_bstrTimeFormated - out of memory."));
        
            goto Error;
        }
    }
    
    m_bstrTimeFormatted =  bstrDate;
    m_bstrTimeFormatted += L" ";
    m_bstrTimeFormatted += bstrTime;
    
    //
    // Size
    //
    uliFileSize.LowPart  = pCoverPageData->nFileSizeLow;
    uliFileSize.HighPart = pCoverPageData->nFileSizeHigh;

    if (!StrFormatByteSize64A(
                              (LONGLONG) uliFileSize.QuadPart, 
                              szFileSize, 
                              sizeof(szFileSize)/ sizeof(szFileSize[0])
                             )
       )
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to convert FileTimeToSystemTime. (ec: %ld)"), 
			ec);

        goto Error;
    }
    else
    {
        m_bstrFileSize = szFileSize;
    }
    
     
    //
    // Icon
    //
    m_resultDataItem.nImage = IMAGE_SRV_COVERPAGE;

    ATLASSERT(ERROR_SUCCESS == ec);
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to init members"));

    ATLASSERT(NULL != m_pParentNode);
    if (NULL != m_pParentNode)
    {
        m_pParentNode->NodeMsgBox(IDS_FAIL2INIT_COVERPAGE_DATA);
    }

    return HRESULT_FROM_WIN32(ec);
    
Exit:
    return S_OK;
}


/*
 -  CFaxCoverPageNode::GetResultPaneColInfo
 -
 *  Purpose:
 *      Return the text for specific column
 *      Called for each column in the result pane
 *
 *  Arguments:
 *      [in]    nCol - column number
 *
 *  Return:
 *      String to be displayed in the specific column
 */
LPOLESTR CFaxCoverPageNode::GetResultPaneColInfo(int nCol)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPageNode::GetResultPaneColInfo"));
    HRESULT hRc = S_OK;

    switch (nCol)
    {
    case 0:
        //
        // Cover page file Name
        //
        if (!m_bstrDisplayName)
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Null memeber BSTR - m_bstrDisplayName."));
            goto Error;
        }
        else
        {
           return (m_bstrDisplayName);
        }

    case 1:
        //
        // Cover page Last Modified
        //
        if (!m_bstrTimeFormatted)
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Null memeber BSTR - m_bstrTimeFormatted."));
            goto Error;
        }
        else
        {
           return (m_bstrTimeFormatted);
        }

    case 2:
        //
        // Cover page file size
        //
        if (!m_bstrFileSize)
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    _T("Null memeber BSTR - m_bstrFileSize."));
            
            goto Error;
        }
        else
        {
           return (m_bstrFileSize);
        }

    default:
        ATLASSERT(0); // "this number of column is not supported "
        return(L"");

    } // endswitch (nCol)

Error:
   return(L"???");

}

/*
 -  CFaxCoverPageNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxCoverPageNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // Display verbs that we support:
    // 1. Delete
    //

    hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
    
    //
    // No default verb
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_NONE); 

    return hRc;
}


HRESULT CFaxCoverPageNode::OnDoubleClick(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CFaxCoverPageNode::::OnDoubleClick -->> Edit CoverPage "));

    HRESULT                     hRc   = S_OK;
    
    bool                        bTemp = true; //UNREFERENCED_PARAMETER
    CSnapInObjectRootBase * pRootTemp = NULL; //UNREFERENCED_PARAMETER
    
    hRc = OnEditCoverPage(bTemp, pRootTemp);
    if ( S_OK != hRc )
    {
		DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to call OnEditCoverPage(). (hRc : %08X)"),
            hRc);
        //msgbox by called func.        
    }

    // Maguire wrote in his code:
    // "Through speaking with Eugene Baucom, I discovered that if you return S_FALSE
    // here, the default verb action will occur when the user double clicks on a node.
    // For the most part we have Properties as default verb, so a double click
    // will cause property sheet on a node to pop up."
    //
    // Hence we return S_OK in any case for now

    return S_OK;
}

/*
 -  CFaxCoverPageNode::OnDelete
 -
 *  Purpose:
 *      Called when deleting this node
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCoverPageNode::OnDelete(
                 LPARAM arg,
                 LPARAM param,
                 IComponentData *pComponentData,
                 IComponent *pComponent,
                 DATA_OBJECT_TYPES type,
                 BOOL fSilent/* = FALSE*/

)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPageNode::OnDelete"));

    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    HRESULT     hRc = S_OK;
    DWORD       ec  = ERROR_SUCCESS;

    WCHAR       pszCovDir[MAX_PATH+1];
    CComBSTR    bstrFullPath;
    WCHAR *     pszServerName;

    //
    // Are you sure?
    //
    if (! fSilent)
    {
        //
        // 1. Use pConsole as owner of the message box
        //
        int res;
        NodeMsgBox(IDS_CONFIRM, MB_YESNO | MB_ICONWARNING, &res);

        if (IDNO == res)
        {
            goto Exit;
        }
    }

    //
    // Prepere the file name to delete
    //
    ATLASSERT(m_pParentNode);
    
    hRc = m_pParentNode->GetServerName(&pszServerName);
    if (S_OK != hRc)
    {
        goto Error;        
    }

    if(!GetServerCpDir(pszServerName, 
			           pszCovDir, 
                       sizeof(pszCovDir)/sizeof(pszCovDir[0])))                  
    {
        ec = GetLastError();
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to get Server Cover-Page Dir. (ec : %ld)"), ec);
        hRc = HRESULT_FROM_WIN32(ec);
        goto Error;
    }
    
    bstrFullPath = pszCovDir;
    if (!bstrFullPath)
    {
        hRc = E_OUTOFMEMORY;
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to allocate string - out of memory"));

        goto Error;
    }
    bstrFullPath += FAX_PATH_SEPARATOR_STR;
    bstrFullPath += m_bstrDisplayName;
    
    //
    // Delete - done by parent node
    //
    hRc = m_pParentNode->DeleteCoverPage(bstrFullPath, this);
    if ( FAILED(hRc) )
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to delete cover page"));
        
        goto Error;
    }
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    
    NodeMsgBox(IDS_FAIL2DELETE_COV);

Exit:
    return hRc;
}


/*
 -  CFaxCoverPageNode::OnEditCoverPage
 -
 *  Purpose:
 *      
 *
 *  Arguments:
 *      [out]   bHandled - Do we handle it?
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */
HRESULT
CFaxCoverPageNode::OnEditCoverPage(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPageNode::OnEditCoverPage"));

    UNREFERENCED_PARAMETER (pRoot);
    UNREFERENCED_PARAMETER (bHandled);

    DWORD       ec         =    ERROR_SUCCESS;
    CComBSTR    bstrFileNameWithQuotes;    
    
    if(!IsFaxComponentInstalled(FAX_COMPONENT_CPE))
    {
        return S_OK;
    }

    ATLASSERT(m_pParentNode);
    
    //
    // Prepare the filename of the cover page
    //
	
    // To avoid problems with space included file names like: "My Cover Page.cov"
    bstrFileNameWithQuotes = L"\"";
    if (!m_bstrTimeFormatted)
    {
		DebugPrintEx(
			    DEBUG_ERR,
			    _T("BSTR allocation failed."));

        NodeMsgBox(IDS_MEMORY);

		return E_OUTOFMEMORY;
    }
	bstrFileNameWithQuotes += m_bstrDisplayName;
	bstrFileNameWithQuotes += L"\"";
	
    //
    // Open cover page editor
    //
    ec = m_pParentNode->OpenCoverPageEditor(bstrFileNameWithQuotes); 
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Fail to OpenCoverPageEditor. (ec : %ld)"), ec);

        return HRESULT_FROM_WIN32( ec );
    }
    return S_OK;
}

/*
 +
 +  CFaxCoverPageNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxCoverPageNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    _TCHAR topicName[MAX_PATH];
    
    _tcscpy(topicName, helpFile);
    
    _tcscat(topicName, _T("::/FaxS_C_CovPages.htm"));
    
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(topicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, topicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

/*
 -  CFaxCoverPageNode::UpdateMenuState
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateMenuState
 *      which only have one line inside it "return;" 
 *      This function implements the grayed\ungrayed view for the 
 *      the Enable and the Disable menus.
 *
 *  Arguments:

 *            [in]  id    - unsigned int with the menu IDM value
 *            [out] pBuf  - string 
 *            [out] flags - pointer to flags state combination unsigned int
 *
 *  Return:
 *      no return value - void function 
 */
void CFaxCoverPageNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPageNode::UpdateMenuState"));

    UNREFERENCED_PARAMETER (pBuf);
    
    switch (id)
    {
        case IDM_EDIT_COVERPAGE:

            *flags = IsFaxComponentInstalled(FAX_COMPONENT_CPE) ? MF_ENABLED : MF_GRAYED;
            break;

        default:
            break;
    }
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\coverpages.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CoverPages.cpp                                         //
//                                                                         //
//  DESCRIPTION   : The implementation of fax cover pages node.            //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Feb  9 2000 yossg  Create                                          //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 2000  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "snapin.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "CoverPages.h"

#include "oaidl.h"
#include "Icons.h"

#include <faxreg.h>
#include <commdlg.h>

#include "CovNotifyWnd.h"

#include <FaxUtil.h>

//////////////////////////////////////////////////////////////
// {4D0480C7-3DE2-46ca-B03F-5C018DF1AF4D}
static const GUID CFaxCoverPagesNodeGUID_NODETYPE = 
{ 0x4d0480c7, 0x3de2, 0x46ca, { 0xb0, 0x3f, 0x5c, 0x1, 0x8d, 0xf1, 0xaf, 0x4d } };

const GUID*    CFaxCoverPagesNode::m_NODETYPE = &CFaxCoverPagesNodeGUID_NODETYPE;
const OLECHAR* CFaxCoverPagesNode::m_SZNODETYPE = OLESTR("4D0480C7-3DE2-46ca-B03F-5C018DF1AF4D");
const CLSID*   CFaxCoverPagesNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

//
// Static members
//
CColumnsInfo CFaxCoverPagesNode::m_ColsInfo;
HANDLE       CFaxCoverPagesNode::m_hStopNotificationThreadEvent = NULL;

/*
 -  CFaxCoverPagesNode::Init
 -
 *  Purpose:
 *      Create Event for shut down notification.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCoverPagesNode::Init()
{
    DEBUG_FUNCTION_NAME(_T("CFaxCoverPagesNode::Init"));
    HRESULT         hRc = S_OK;
    DWORD           ec  = ERROR_SUCCESS;

    WCHAR *         pszServerName = NULL;

    //
    // Get Sever Cover-page Dir for the current administrated server
    //
    ATLASSERT(m_pParentNode); 
    
    hRc = GetServerName(&pszServerName);
    if (S_OK != hRc)
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to get Server Name. (hRc : %08X)"), hRc);
        
        goto Exit;        
    }

    if(!GetServerCpDir(pszServerName, 
			           m_pszCovDir, 
                       sizeof(m_pszCovDir)/sizeof(m_pszCovDir[0])                   //*//
                       )
      )
    {
        ec = GetLastError();
        
        if (ERROR_FILE_NOT_FOUND == ec)
        {
            DebugPrintEx(
		        DEBUG_ERR,
		        _T("Failed to find Server Cover-Page Dir. (ec : %ld)"), ec);

        }
        else
        {
            DebugPrintEx(
		        DEBUG_ERR,
		        _T("Failed to get Server Cover-Page Dir. (ec : %ld)"), ec);
        }
        
        hRc = HRESULT_FROM_WIN32(ec);
        
        goto Exit;
    }

    
    //
    // Create the shutdown event. This event will be signaled when the app is
    // about to quit.
    //
    if (NULL != m_hStopNotificationThreadEvent) // can happen while retargeting
    {
        hRc = RestartNotificationThread();
        if (S_OK != hRc)
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Fail to RestartNotificationThread."));
            
        }
    }
    else //first time here.
    {
        m_hStopNotificationThreadEvent = CreateEvent (NULL,       // No security
                                        TRUE,       // Manual reset
                                        FALSE,      // Starts clear
                                        NULL);      // Unnamed
        if (NULL == m_hStopNotificationThreadEvent)
        {
            ec = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Fail to CreateEvent."));
        
            //CR: NodeMsgBox(IDS_FAIL2CREATE_EVENT);
        
            hRc = HRESULT_FROM_WIN32(ec);

            goto Exit;
        }
    }


Exit:
    return hRc;
}



/*
 -  CFaxCoverPagesNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxCoverPagesNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPagesNode::InsertColumns"));
    HRESULT  hRc = S_OK;

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_COVERPAGES_COL1, FXS_NORMAL_COLUMN_WIDTH},
        {IDS_COVERPAGES_COL2, FXS_NORMAL_COLUMN_WIDTH},
        {IDS_COVERPAGES_COL3, FXS_NORMAL_COLUMN_WIDTH},
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    CHECK_RETURN_VALUE_AND_PRINT_DEBUG (_T("m_ColsInfo.InsertColumnsIntoMMC"))

Cleanup:
    return(hRc);
}

/*
 -  CFaxCoverPagesNode::PopulateResultChildrenList
 -
 *  Purpose:
 *      Create the FaxInboundRoutingMethods children nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCoverPagesNode::PopulateResultChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPagesNode::PopulateResultChildrenList"));
    HRESULT hRc = S_OK;

    CFaxCoverPageNode *   pCoverPage = NULL;
                       
    WCHAR           szFileName[MAX_PATH+1];

    size_t          itFullDirectoryPathLen;
    TCHAR*          pFullDirectoryPathEnd; //pointer to the NULL after dir path with '\'

    WIN32_FIND_DATA findData;

    DWORD           ec;
    BOOL            bFindRes;
    HANDLE          hFile = INVALID_HANDLE_VALUE;

    szFileName[0]= 0;


    ATLASSERT (NULL != m_pszCovDir );
    ATLASSERT ( wcslen(m_pszCovDir) < (MAX_PATH - sizeof(FAX_COVER_PAGE_FILENAME_EXT)/sizeof(WCHAR) - 1) ); 

    //
    // Create cover page mask 
    //
    wcscpy(szFileName, m_pszCovDir);
    wcscat(szFileName, FAX_PATH_SEPARATOR_STR);

    itFullDirectoryPathLen = wcslen(szFileName);
    pFullDirectoryPathEnd = wcschr(szFileName, L'\0');

    wcscat(szFileName, FAX_COVER_PAGE_MASK);

    //
    // Find First File
    //    
    hFile = FindFirstFile(szFileName, &findData);
    if(INVALID_HANDLE_VALUE == hFile)
    {
        ec = GetLastError();
        if(ERROR_FILE_NOT_FOUND != ec)
        {
            hRc = HRESULT_FROM_WIN32(ec);
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("FindFirstFile Failed. (ec: %ld)"), 
			    ec);
            goto Error;
        }
        else
        {
            DebugPrintEx( DEBUG_MSG,
		        _T("No server cover pages were found."));
            goto Exit;
        }
    }
    
    //
    // while loop - add cover pages to the result pane view
    //
    bFindRes = TRUE;
    while(bFindRes)
    {
        if(itFullDirectoryPathLen + _tcslen(findData.cFileName) < MAX_PATH )
        {
            _tcsncpy(pFullDirectoryPathEnd, findData.cFileName, MAX_PATH - itFullDirectoryPathLen);
            
            if (IsValidCoverPage(szFileName)) 
            {
		    
                    //
                    // add the cover page to result pane
                    //
                    pCoverPage = NULL;

                    pCoverPage = new CFaxCoverPageNode(this, m_pComponentData);
                    if (!pCoverPage)
                    {
                        hRc = E_OUTOFMEMORY;
                        NodeMsgBox(IDS_MEMORY);
                        DebugPrintEx(
	                        DEBUG_ERR,
	                        _T("Out of memory. (hRc: %08X)"),
	                        hRc);
                        goto Error;
                    }
                    else
                    {
                    //
                    // Init
                    //
                    pCoverPage->InitParentNode(this);

                    hRc = pCoverPage->Init(&findData);
                    if (FAILED(hRc))
                    {
	                    DebugPrintEx(
	                    DEBUG_ERR,
	                    _T("Fail to init cover page. (hRc: %08X)"),
	                    hRc);
	                    // done by called func NodeMsgBox(IDS_FAIL2INIT_COVERPAGE_DATA);

	                    goto Error;
                    }
                    //
                    // add to list
                    //

                    hRc = this->AddChildToList(pCoverPage);
                    if (FAILED(hRc))
                    {
                      DebugPrintEx(
	                    DEBUG_ERR,
	                    _T("Fail to add property page for General Tab. (hRc: %08X)"),
	                    hRc);

                      NodeMsgBox(IDS_FAIL2ADD_COVERPAGE);
		                      goto Error;
                    }
                    else
                    {
	                    pCoverPage = NULL;
                    }
		        }
	        }
            else
            {
                DebugPrintEx(
	                DEBUG_ERR,
	                _T("File %ws was found to be an invalid *.cov file."), pFullDirectoryPathEnd);
            }
        }
        else
        {
            DebugPrintEx(
	            DEBUG_ERR,
	            _T("The file %ws path is too long"), pFullDirectoryPathEnd);
        }

        //
        // Find Next File
        //
        bFindRes = FindNextFile(hFile, &findData);
        if(!bFindRes)
        {
            ec = GetLastError();
            if (ERROR_NO_MORE_FILES == ec)
            {
            	break;
            }
            else
            {
               DebugPrintEx(
                   DEBUG_ERR,
                   _T("FindNexTFile Failed. (ec: %ld)"),
                   ec);

                hRc = HRESULT_FROM_WIN32(ec);		

                goto Exit;
            }
        }
    } //while(bFindRes)
    
    
    //
    // Create the Server's Cover-Page Directory listener notification thread
    //

    if (m_bIsFirstPopulateCall)
    {
        m_NotifyWin = new CFaxCoverPageNotifyWnd(this);
        if (!m_NotifyWin)
        {
            hRc = E_OUTOFMEMORY;
            NodeMsgBox(IDS_MEMORY);
		    
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Out of memory."));
            
            goto Exit;
        }


        RECT	rcRect;
        ZeroMemory(&rcRect, sizeof(rcRect));

        HWND hWndNotify = m_NotifyWin->Create(NULL,
                                rcRect,
                                NULL,      //LPCTSTR szWindowName
                                WS_POPUP,  //DWORD dwStyle
                                0x0,
                                0);

        if (!(::IsWindow(hWndNotify)))
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Failed to create window."));

            hWndNotify = NULL;
            delete m_NotifyWin;
            m_NotifyWin = NULL;

            goto Exit;
        }

        hRc = StartNotificationThread();
        if( S_OK != hRc)
        {
            //DbgPrint by Called Func.
            m_NotifyWin->DestroyWindow();
            delete m_NotifyWin;
            m_NotifyWin = NULL;

            goto Exit;
        }

        //
        // Update boolean member
        //
        m_bIsFirstPopulateCall = FALSE;

        DebugPrintEx(
            DEBUG_MSG,
            _T("Succeed to create server cover-page directory listener thread and to create notification window"));
    }
    
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pCoverPage ) 
    {
        delete  pCoverPage;    
        pCoverPage = NULL;    
    }
    
    //
    // Get rid of what we had.
    //
    {
        // Delete each node in the list of children
        int iSize = m_ResultChildrenList.GetSize();
        for (int j = 0; j < iSize; j++)
        {
            pCoverPage = (CFaxCoverPageNode *)
                                    m_ResultChildrenList[j];
            ATLASSERT(pCoverPage);
            delete pCoverPage;
            pCoverPage = NULL;
        }

        // Empty the list
        m_ResultChildrenList.RemoveAll();

        // We no longer have a populated list.
        m_bResultChildrenListPopulated = FALSE;
    }
    
Exit:
    
    if (INVALID_HANDLE_VALUE != hFile)
    {
        if (!FindClose(hFile))
        {
            DebugPrintEx(
                DEBUG_MSG,
                _T("Failed to FindClose()(ec: %ld)"),
            GetLastError());
        }
    }

    
    return hRc;
}



/*
 -  CFaxCoverPagesNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxCoverPagesNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 

    return hRc;
}



/*
 -  CFaxCoverPagesNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
/* virtual */HRESULT
CFaxCoverPagesNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPagesNode::OnRefresh"));
    HRESULT hRc = S_OK;

    //
    // Call the base class (do also repopulate)
    //
    hRc = CBaseFaxOutboundRulesNode::OnRefresh(arg,
                             param,
                             pComponentData,
                             pComponent,
                             type);
    if ( FAILED(hRc) )
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to call base class's OnRefresh. (hRc: %08X)"),
			hRc);
        goto Exit;
    }


Exit:
    return hRc;

}

/*
 -  CFaxCoverPagesNode::DoRefresh
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxCoverPagesNode::DoRefresh(CSnapInObjectRootBase *pRoot)
{
    CComPtr<IConsole> spConsole;

    //
    // Repopulate children
    //
    RepopulateResultChildrenList();

    if (pRoot)
    {
        //
        // Get the console pointer
        //
        ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
        if (pRoot->m_nType == 1)
        {
            //
            // m_ntype == 1 means the IComponentData implementation
            //
            CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
            spConsole = pCComponentData->m_spConsole;
        }
        else
        {
            //
            // m_ntype == 2 means the IComponent implementation
            //
            CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
            spConsole = pCComponent->m_spConsole;
        }
    }
    else
    {
        ATLASSERT(m_pComponentData);
        spConsole = m_pComponentData->m_spConsole;
    }

    ATLASSERT(spConsole);
    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return S_OK;
}

HRESULT
CFaxCoverPagesNode::DoRefresh()
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPagesNode::DoRefresh()"));
    HRESULT hRc = S_OK;
    CComPtr<IConsole> spConsole;

    //
    // Repopulate children
    //
    ATLASSERT( m_pComponentData != NULL );
    ATLASSERT( m_pComponentData->m_spConsole != NULL );

    hRc = m_pComponentData->m_spConsole->UpdateAllViews( NULL, NULL, FXS_HINT_DELETE_ALL_RSLT_ITEMS);
    if (FAILED(hRc))
    {
        DebugPrintEx( DEBUG_ERR,
		    _T("Unexpected error - Fail to UpdateAllViews (clear)."));
        NodeMsgBox(IDS_FAIL2REFRESH_THEVIEW);        
    }
    
    RepopulateResultChildrenList();

    hRc = m_pComponentData->m_spConsole->UpdateAllViews( NULL, NULL, NULL);
    if (FAILED(hRc))
    {
        DebugPrintEx( DEBUG_ERR,
		    _T("Unexpected error - Fail to UpdateAllViews."));
        NodeMsgBox(IDS_FAIL2REFRESH_THEVIEW);        
    }

    return hRc;
}

/*
 -  CFaxCoverPagesNode::OnNewCoverPage
 -
 *  Purpose:
 *      
 *
 *  Arguments:
 *      [out]   bHandled - Do we handle it?
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */
HRESULT
CFaxCoverPagesNode::OnNewCoverPage(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPagesNode::OnNewCoverPage"));
    
UNREFERENCED_PARAMETER (pRoot);
    UNREFERENCED_PARAMETER (bHandled);

    DWORD     ec         =    ERROR_SUCCESS;
        
    ec = OpenCoverPageEditor( L"");
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Fail to OpenCoverPageEditor. (ec : %ld)"), ec);

        return HRESULT_FROM_WIN32( ec );
    }
    return S_OK;
}



/*
 -  CFaxCoverPagesNode::OpenCoverPageEditor
 -
 *  Purpose:
 *      Delete cover page
 *
 *  Arguments:
 *      [in]    bstrFileName -         The cover page file name
 *
 *  Assumption:
 *              Setup prepares a shortcut to the cover page editor in the 
 *              registry "App Path". Due to this fact ShellExecute needs only the 
 *              file name of the editor and not its full path.
 *  Return:
 *      Standard Win32 error code
 */
DWORD 
CFaxCoverPagesNode::OpenCoverPageEditor( BSTR bstrFileName)
{
    DEBUG_FUNCTION_NAME(_T("CFaxCoverPagesNode::OpenCoverPageEditor"));
    DWORD       dwRes                   = ERROR_SUCCESS;
    
    CComBSTR    bstrCovEditor;

    HINSTANCE   hCovEditor;

    //
    // get cover pages editor file
    //

    bstrCovEditor = FAX_COVER_IMAGE_NAME;
    if (!bstrCovEditor)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to allocate string - out of memory"));

        goto Exit;
    }
	
    
    //
    // start cover page editor
    //
    hCovEditor = ShellExecute(   NULL, 
                                 TEXT("open"),  // Command 
                                 bstrCovEditor,   
                                 (bstrFileName && lstrlen(bstrFileName)) ? // Do we have a file name?
                                    bstrFileName :          // YES - use it as command line argument
                                    TEXT("/Common"),        // NO  - start the CP editor in the common CP folder 
                                 m_pszCovDir, 
                                 SW_RESTORE 
                              );
    if( (DWORD_PTR)hCovEditor <= 32 )
    {
        // ShellExecute fail
        dwRes = PtrToUlong(hCovEditor);
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to run ShellExecute. (ec : %ld)"), dwRes);

        goto Exit;
    }

        
    ATLASSERT( ERROR_SUCCESS == dwRes);

Exit:
    return dwRes;

} 


/*
 -  CFaxCoverPagesNode::OnAddCoverPageFile
 -
 *  Purpose:
 *      
 *
 *  Arguments:
 *      [out]   bHandled - Do we handle it?
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */
HRESULT
CFaxCoverPagesNode::OnAddCoverPageFile(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPagesNode::OnAddCoverPageFile"));
    HRESULT   hRc        =    S_OK;
    DWORD     ec         =    ERROR_SUCCESS;
    

    //
    // Function Call: browse and copy a cover page
    //
    if (!BrowseAndCopyCoverPage(
                            m_pszCovDir,
                            FAX_COVER_PAGE_EXT_LETTERS
                           ) 
       )
    {
        DebugPrintEx(
		    DEBUG_MSG,
		    _T("BrowseAndCopyCoverPage Canceled by user or Failed."));
        
        return S_OK; //error is teated in the called func. MMC continue as usual.

    }
    else  //Success
    {
        //
        // Repopulate: refresh the entire cover page result pane view
        //

        DoRefresh(pRoot);
    }

    return S_OK;
}


/*
 -  CFaxCoverPagesNode::BrowseAndCopyCoverPage
 -
 *  Purpose:
 *      Presents a common file open dialog for the purpose of selecting a file name
 *
 *  Arguments:
 *      [in]   pInitialDir - server cover page directory path
 *      [in]   pCovPageExtensionLetters - cover page's 3 leeters extension
 *
 *  Return:
 *      TRUE   - got a good file name, user pressed the OK button to override file, file was copy
 *      FALSE  - got nothing or user pressed the CANCEL button, or error occures.
 *
 *   the FileName is changed to have the selected file name.
 */

BOOL
CFaxCoverPagesNode::BrowseAndCopyCoverPage(
    LPTSTR pInitialDir,
    LPWSTR pCovPageExtensionLetters
    )

{   
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPagesNode::BrowseAndCopyCoverPage"));

    DWORD   dwError = ERROR_SUCCESS;
    HRESULT ret     = S_OK;

    WCHAR   filter[FXS_MAX_TITLE_LEN];
    WCHAR   filename[MAX_PATH];
    WCHAR   ftitle[MAX_PATH];
    WCHAR   title[FXS_MAX_TITLE_LEN];
    
    TCHAR   szDestinationFilePath[MAX_PATH];
    TCHAR   szServerCoverPagePath[MAX_PATH];

    LPTSTR  pExtension;
    LPTSTR  pFilename;
    INT     n;

    OPENFILENAME of;
    
    //
    // (1) Init
    //

    //
    // Check in parameters
    //
    ATLASSERT( NULL != pInitialDir && 0 != pInitialDir[0] ); 
    ATLASSERT( NULL != pInitialDir && sizeof(FAX_COVER_PAGE_EXT_LETTERS)/sizeof(WCHAR) != _tcslen(pCovPageExtensionLetters) ); 
    
    //
    // Prepare parameters for the copy operation (later)
    //
    n = _tcslen(pInitialDir); 
    
	wcscpy(szServerCoverPagePath , pInitialDir);
 
    //
    // Prepare the OPENFILE structure fields 
    //

    // Compose the file-type filter string
    if (::LoadString(_Module.GetResourceInstance(), IDS_CP_FILETYPE, title, FXS_MAX_TITLE_LEN) == 0)
    {
        NodeMsgBox(IDS_MEMORY);
        return FALSE;
    }
    wsprintf(filter, TEXT("%s (%s)%c%s%c%c"), title, FAX_COVER_PAGE_MASK, NUL, FAX_COVER_PAGE_MASK, NUL, NUL);

    if (::LoadString(_Module.GetResourceInstance(), IDS_BROWSE_COVERPAGE, title, FXS_MAX_TITLE_LEN) == 0)
    {
        NodeMsgBox(IDS_MEMORY);
        return FALSE;
    }
    
    filename[0] = NUL;
    ftitle[0]   = NUL;

    //
	// Init the OPENFILE structure
	//
	
	of.lStructSize       = sizeof( OPENFILENAME );
    of.hwndOwner         = NULL;                                                    
    of.hInstance         = GetModuleHandle( NULL );
    of.lpstrFilter       = filter;
    of.lpstrCustomFilter = NULL;
    of.nMaxCustFilter    = 0;
    of.nFilterIndex      = 1;
    of.lpstrFile         = filename;
    of.nMaxFile          = MAX_PATH;
    of.lpstrFileTitle    = ftitle;
    of.nMaxFileTitle     = MAX_PATH;
    of.lpstrInitialDir   = pInitialDir;
    of.lpstrTitle        = title;
    of.Flags             = OFN_EXPLORER | OFN_HIDEREADONLY |
                           OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;                   //OFN_ENABLEHOOK ;
    of.nFileOffset       = 0;
    of.nFileExtension    = 0;
    of.lpstrDefExt       = pCovPageExtensionLetters;
    of.lCustData         = 0;
    of.lpfnHook          = NULL;                                                    //BrowseHookProc;
    of.lpTemplateName    = NULL;


    //
    // (2) Call the "Open File" dialog
    //
    if (! GetOpenFileName(&of))
    {
        DebugPrintEx(
		    DEBUG_MSG,
		    _T("GetOpenFileName was canceled by user."));

        return FALSE;
    }

    //
    // (3) Check the output of the source path, filename and extension
    //

    //
    //     a. Make sure the selected filename has the correct extension
    //

    //
    //        Find the filename portion given a filename:
    //        return a pointer to the '.' character if successful
    //        NULL if there is no extension
    //

    pFilename  = &filename[of.nFileOffset];
    
    pExtension = _tcsrchr(filename, _T('.'));
    if (
         (pExtension == NULL) 
        ||
         (_tcsicmp(pExtension, FAX_COVER_PAGE_FILENAME_EXT) != EQUAL_STRING)
       )
    {
        NodeMsgBox(IDS_BAD_CP_EXTENSION);
        return FALSE;
    }

    //
    //     b. Check if the selected file directory is the 
    //        default server cover page directory
    //

    if (_tcsnicmp(filename, szServerCoverPagePath, n) == EQUAL_STRING) 
    {
        NodeMsgBox(IDS_CP_DUPLICATE);  //YESNO
        
        // Work was already done. We are leaving...
        goto Exit;
    }

    //
    //        The check if the selected file is already inside the
    //        cover page directory is done with the copy operation itself.
    //

    //
    //        The check if the destination cover page directory exists done 
    //        while the copy operation itself.
    //


    
    //
    // (4) Copy the selected cover page file to the Server Cover page directory
    //
    
    //
    //     a. prepare from pSelected the destination path 
    //
    
    


    if (n + 1 + _tcslen(pFilename) >= MAX_PATH  || pFilename >= pExtension) 
    {
        NodeMsgBox(IDS_FILENAME_TOOLONG);
        return FALSE;
    }
    wsprintf(szDestinationFilePath, TEXT("%s%s%s%c"), szServerCoverPagePath, FAX_PATH_SEPARATOR_STR, pFilename, NUL);

    //
    //     b. Copy the selected cover page file 
    //        to the server cover page default directory
    //
    if (!CopyFile(filename, szDestinationFilePath, TRUE)) 
    {
        dwError = GetLastError();
        if ( ERROR_FILE_EXISTS == dwError)
        {
            DebugPrintEx(DEBUG_MSG,
			    _T("Copy cover page already exists at destination."));

            ret = NodeMsgBox(IDS_CP_DUP_YESNO, MB_YESNO | MB_ICONQUESTION );
            if ((HRESULT)IDYES == ret)
            {
                //Copy any way
                if (!CopyFile(filename, szDestinationFilePath, FALSE)) 
                {
                    dwError = GetLastError();
                    DebugPrintEx(DEBUG_ERR,
			            _T("Copy cover page Failed (ec = %ld)."), dwError);

                    NodeMsgBox(IDS_FAILED2COPY_COVERPAGE);

                    return FALSE;
                }
                DebugPrintEx(DEBUG_MSG,
			        _T("Copy cover page done any way."));
            }
            else  //ret == IDNO
            {
                DebugPrintEx(DEBUG_MSG,
			        _T("Copy cover page was canceled by user due to file existance at destination."));
                //lets stay friends even after this operation cancel..
				return TRUE;
            }
        } //dwError != ERROR_FILE_EXISTS
        else
        {
            DebugPrintEx(DEBUG_ERR,
			    _T("Copy cover page Failed (ec = %ld)."), dwError);
            NodeMsgBox(IDS_FAILED2COPY_COVERPAGE);
            return FALSE;
        }
    }
    
Exit:

    return TRUE;
}


/*
 -  CFaxCoverPagesNode::DeleteCoverPage
 -
 *  Purpose:
 *      Delete cover page
 *
 *  Arguments:
 *      [in]    bstrName - The cover page full path
 *      [in]    pChildNode - The node to be deleted
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxCoverPagesNode::DeleteCoverPage(BSTR bstrName, CFaxCoverPageNode *pChildNode)
{
    DEBUG_FUNCTION_NAME(_T("CFaxCoverPagesNode::DeleteRule"));
    HRESULT       hRc        = S_OK;
    DWORD         ec         = ERROR_SUCCESS;

    
    ATLASSERT(bstrName);
    ATLASSERT(pChildNode);
    
        
    if (!DeleteFile(bstrName)) 
    {
        ec = GetLastError();
		DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to DeleteFile. (ec: %ld)"),
			ec);

        goto Error;
    } 
    

    //
    // Remove from MMC result pane
    //
    ATLASSERT(pChildNode);
    hRc = RemoveChild(pChildNode);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to remove rule. (hRc: %08X)"),
			hRc);
        //NodeMsgBox by Caller func.
        return hRc;
    }
    
    //
    // Call the group destructor
    //
    delete pChildNode;
    
    
    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("The rule was removed successfully."));
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
	
    //NodeMsgBox by Caller func.;
  
Exit:
    return hRc;
}



/*
 -  CFaxCoverPagesNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displayed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCoverPagesNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxCoverPagesNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                    IDS_DISPLAY_STR_COVERPAGES))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}
  
HRESULT CFaxCoverPagesNode::GetServerName(LPTSTR * ppServerName) 
{ 
    DEBUG_FUNCTION_NAME(_T("CFaxCoverPagesNode::GetServerName"));
    
    ATLASSERT(GetRootNode());

    CComBSTR bstrServerName = ((CFaxServerNode *)GetRootNode())->GetServerName();
    if (!bstrServerName)
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Out of memory. Failed to load string."));
        
        m_pParentNode->NodeMsgBox(IDS_MEMORY);

        *ppServerName = NULL;
        
        return E_OUTOFMEMORY;
    }

    if (0 == bstrServerName.Length())
    {
        *ppServerName = NULL;
        
    }
    else
    {
		*ppServerName = bstrServerName.Copy();
    }
    return S_OK;
}

/*
 -  CFaxCoverPagesNode::NotifyThreadProc
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *          [in]    - pointer to the Fax Cover-Pages Node
 *  Return:
 *      WIN32 error code
 */
DWORD WINAPI CFaxCoverPagesNode::NotifyThreadProc ( LPVOID lpParameter)
{
    DEBUG_FUNCTION_NAME(_T("CFaxCoverPagesNode::NotifyThreadProc"));
    DWORD    dwRes   = ERROR_SUCCESS;
    HRESULT  hRc     = S_OK;

    CFaxCoverPagesNode *pCovFolder = (CFaxCoverPagesNode *)lpParameter;

    ATLASSERT (pCovFolder);


    HANDLE hWaitHandles[2];    
    DWORD dwNotifyFilter = FILE_NOTIFY_CHANGE_FILE_NAME | 
                           FILE_NOTIFY_CHANGE_SIZE      | 
                           FILE_NOTIFY_CHANGE_LAST_WRITE;
    //
    // register for a first folder notification
    //
    hWaitHandles[0] = FindFirstChangeNotification(
                                        pCovFolder->m_pszCovDir, 
                                        FALSE, 
                                        dwNotifyFilter);
    if(INVALID_HANDLE_VALUE == hWaitHandles[0])
    {
        dwRes = GetLastError();
		DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to FindFirstChangeNotification. (ec : %ld)"), 
            dwRes);

        return dwRes;
    }

    while(TRUE)
    {
        hWaitHandles[1] = m_hStopNotificationThreadEvent;
        if (NULL == hWaitHandles[1])
        {
            //
            // We're shutting down
            //
            goto Exit;
        }

        //
        // wait for folder notification or shutdown
        //
		dwRes = WaitForMultipleObjects(2, hWaitHandles, FALSE, INFINITE);

        switch (dwRes)
        {
        case WAIT_OBJECT_0:

            //
            // folder notification 
            //
            if(NULL != pCovFolder->m_NotifyWin && pCovFolder->m_NotifyWin->IsWindow())
            {
                if ( !pCovFolder->m_NotifyWin->PostMessage(WM_NEW_COV))
                {
		            DebugPrintEx(DEBUG_ERR,
			            _T("Fail to PostMessage"));
                    
                    // do not exit. continue!
                }
            }

            break;


        case WAIT_OBJECT_0 + 1:
            //
            // Shutdown is now in progress
            //
		    DebugPrintEx(
			    DEBUG_MSG,
			    _T("Shutdown in progress"));

            dwRes = ERROR_SUCCESS;
            goto Exit;

        case WAIT_FAILED:
            dwRes = GetLastError();
		    DebugPrintEx(
			    DEBUG_ERR,
			    _T("Failed to WaitForMultipleObjects. (ec : %ld)"), 
                dwRes);

            goto Exit;

        case WAIT_TIMEOUT:
		    DebugPrintEx(
			    DEBUG_ERR,
			    _T("Reach WAIT_TIMEOUT in INFINITE wait!"));

            ATLASSERT(FALSE);

            goto Exit;
        default:
		    DebugPrintEx(
			    DEBUG_ERR,
			    _T("Failed. Unexpected error (ec : %ld)"), 
                dwRes);

            ATLASSERT(0);
            goto Exit;
        }

        //
        // register for a next folder notification
        //
        if(!FindNextChangeNotification(hWaitHandles[0]))
        {
            dwRes = GetLastError();
		    DebugPrintEx(
			    DEBUG_ERR,
			    _T("Failed to FindNextChangeNotification (ec : %ld)"), 
                dwRes);

            goto Exit;
        }
    }


Exit:
    //
    // close notification handel
    //
    if(!FindCloseChangeNotification(hWaitHandles[0]))
    {
        dwRes = GetLastError();
		DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to FindCloseChangeNotification. (ec : %ld)"), 
            dwRes);
    }

    return dwRes;

} // NotifyThreadProc



/*
 -  CFaxCoverPagesNode::StartNotificationThread
 -
 *  Purpose:
 *      Start the server cover page directory listning thread.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxCoverPagesNode::StartNotificationThread()
{
    DEBUG_FUNCTION_NAME(_T("CFaxCoverPagesNode::StartNotificationThread"));
    HRESULT       hRc        = S_OK;
    DWORD         ec         = ERROR_SUCCESS;

    //
    // create thread
    //
    DWORD dwThreadId;
    m_hNotifyThread = CreateThread (  
                        NULL,            // No security
                        0,               // Default stack size
                        NotifyThreadProc,// Thread procedure
                        (LPVOID)this,    // Parameter
                        0,               // Normal creation
                        &dwThreadId      // We must have a thread id for win9x
                     );
    if (NULL == m_hNotifyThread)
    {
        ec = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to CreateThread. (ec: %ld)"), 
            ec);
        
        hRc = HRESULT_FROM_WIN32(ec);

        goto Exit;
    }

Exit:
    return hRc;
}


/*
 -  CFaxCoverPagesNode::StopNotificationThread
 -
 *  Purpose:
 *      Stop the server cover page directory listning thread.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxCoverPagesNode::StopNotificationThread()
{
    DEBUG_FUNCTION_NAME(_T("CFaxCoverPagesNode::StopNotificationThread"));
    HRESULT       hRc        = S_OK;
    
    //
    // Signal the event telling all our thread the app. is shutting down
    //
    SetEvent (m_hStopNotificationThreadEvent);

    //
    // wait for the thread
    //
    if (NULL != m_hNotifyThread )
    {
    
        DWORD dwWaitRes = WaitForSingleObject(m_hNotifyThread, INFINITE);
        switch(dwWaitRes)
        {
            case WAIT_OBJECT_0:
		        //Success
                DebugPrintEx(
			        DEBUG_MSG,
			        _T("Succeed to WaitForSingleObject from notify thread. (ec : %ld)"));
                                
                break;

            case WAIT_FAILED:
                dwWaitRes = GetLastError();
                if (ERROR_INVALID_HANDLE != dwWaitRes)
                {
		            DebugPrintEx(
			            DEBUG_ERR,
			            _T("Failed to WaitForSingleObject. (ec : %ld)"), 
                        dwWaitRes);

                    hRc = E_FAIL;
                }
                break;
        
            case WAIT_TIMEOUT:
		        DebugPrintEx(
			        DEBUG_ERR,
			        _T("WAIT_TIMEOUT - Failed to WaitForSingleObject. (ec : %ld)"), 
                    dwWaitRes);

                hRc = E_FAIL;
                
                ATLASSERT(FALSE);

                break;
        
            default:
		        DebugPrintEx(
			        DEBUG_ERR,
			        _T("Failed to WaitForSingleObject. (ec : %ld)"), 
                    dwWaitRes);

                hRc = E_FAIL;

                break;
        }
    
        CloseHandle (m_hNotifyThread);
        m_hNotifyThread = NULL;
    
    }
    



    return hRc;
}


/*
 -  CFaxCoverPagesNode::RestartNotificationThread
 -
 *  Purpose:
 *      Restart the server cover page directory listning thread.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxCoverPagesNode::RestartNotificationThread()
{
    DEBUG_FUNCTION_NAME(_T("CFaxCoverPagesNode::RestartNotificationThread"));
    HRESULT       hRc        = S_OK;

    //
    // Stop
    //
    hRc = StopNotificationThread();
    if (S_OK != hRc)
    {
        //DbgMsg And MsgBox by called func.
        goto Exit;
    }

    //
    // Reset Shutdown Event handle
    //
    if (m_hStopNotificationThreadEvent)
    {
        ResetEvent (m_hStopNotificationThreadEvent);
    }

    //
    // Start
    //
    hRc = StartNotificationThread();
    if (S_OK != hRc)
    {
        //DbgMsg And MsgBox by called func.
        goto Exit;
    }

Exit:
    return hRc;
}


/*
 +
 +  CFaxCoverPagesNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxCoverPagesNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    _TCHAR topicName[MAX_PATH];
    
    _tcscpy(topicName, helpFile);
    
    _tcscat(topicName, _T("::/FaxS_C_CovPages.htm"));
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(topicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, topicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}


///////////////////////////////////////////////////////////////////


/*
 -  CFaxCoverPagesNode::UpdateMenuState
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateMenuState
 *      which only have one line inside it "return;" 
 *      This function implements the grayed\ungrayed view for the 
 *      the Enable and the Disable menus.
 *
 *  Arguments:

 *            [in]  id    - unsigned int with the menu IDM value
 *            [out] pBuf  - string 
 *            [out] flags - pointer to flags state combination unsigned int
 *
 *  Return:
 *      no return value - void function 
 */
void CFaxCoverPagesNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPagesNode::UpdateMenuState"));

    UNREFERENCED_PARAMETER (pBuf);
    
    switch (id)
    {
        case IDM_NEW_COVERPAGE:

            *flags = IsFaxComponentInstalled(FAX_COMPONENT_CPE) ? MF_ENABLED : MF_GRAYED;
            break;

        default:
            break;
    }
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\coverpages.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CoverPages.h                                           //
//                                                                         //
//  DESCRIPTION   : Header file for the fax cover pages node               //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Feb  9 2000 yossg  Create                                          //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 2000  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXCOVERPAGES_H
#define H_FAXCOVERPAGES_H

#include "snapin.h"
#include "snpnres.h"

#include "CoverPage.h"
#include "CovNotifyWnd.h"

class CFaxServerNode;
class CFaxCoverPageNode;
class CFaxCoverPageNotifyWnd;       

class CFaxCoverPagesNode : public CNodeWithResultChildrenList<
                                        CFaxCoverPagesNode,    
                                        CFaxCoverPageNode, 
                                        CSimpleArray<CFaxCoverPageNode*>, 
                                        FALSE>
{

public:

    BEGIN_SNAPINCOMMAND_MAP(CFaxCoverPagesNode, FALSE)
        SNAPINCOMMAND_ENTRY(IDM_OPEN_COVERPAGE, OnAddCoverPageFile)
        SNAPINCOMMAND_ENTRY(IDM_NEW_COVERPAGE,  OnNewCoverPage)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxCoverPagesNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_COVERPAGES_MENU)

    //
    // Constructor
    //
    CFaxCoverPagesNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithResultChildrenList<CFaxCoverPagesNode, CFaxCoverPageNode, CSimpleArray<CFaxCoverPageNode*>, FALSE>(pParentNode, pComponentData )
    {
        m_bIsFirstPopulateCall = TRUE;
        m_NotifyWin = NULL; 
        m_hNotifyThread = NULL;
    }

    //
    // Destructor
    //
    ~CFaxCoverPagesNode()
    {
        DEBUG_FUNCTION_NAME(_T("CFaxCoverPagesNode::~CFaxCoverPagesNode"));
         
        //
        // StopNotificationThread
        //
        HRESULT hRc = StopNotificationThread();
        if (S_OK != hRc)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Failed to StopNotificationThread. (hRc : %08X)"), 
                hRc);
        }
             
        //
        // Close Shutdown Event handle
        //
        if (m_hStopNotificationThreadEvent)
        {
            CloseHandle (m_hStopNotificationThreadEvent);
            m_hStopNotificationThreadEvent = NULL;
        }


        //
        // Destroy Window
        //
        if (NULL != m_NotifyWin)
        {
            if (m_NotifyWin->IsWindow())
            {
                m_NotifyWin->DestroyWindow();
            }
            delete m_NotifyWin;
            m_NotifyWin = NULL;
        }
        

    }

	//
	// get data from RPC 
	//
    virtual HRESULT PopulateResultChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl *pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    void    InitParentNode(CFaxServerNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    virtual HRESULT OnRefresh(LPARAM arg,
                              LPARAM param,
                              IComponentData *pComponentData,
                              IComponent * pComponent,
                              DATA_OBJECT_TYPES type);

    HRESULT DoRefresh(CSnapInObjectRootBase *pRoot);
    HRESULT DoRefresh();

    HRESULT Init();

    HRESULT InitDisplayName();

    HRESULT DeleteCoverPage(BSTR bstrName, CFaxCoverPageNode *pChildNode);

    HRESULT OnNewCoverPage(bool &bHandled, CSnapInObjectRootBase *pRoot);

    HRESULT OnAddCoverPageFile(bool &bHandled, CSnapInObjectRootBase *pRoot);

    DWORD   OpenCoverPageEditor( BSTR bstrFileName);

    HRESULT GetServerName(LPTSTR * ppServerName); 

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

    void    UpdateMenuState (UINT id, LPTSTR pBuf, UINT *flags);

private:

    BOOL    BrowseAndCopyCoverPage( 
                          LPTSTR pInitialDir,
                          LPWSTR pCovPageExtensionLetters
                                  );
    
    //
    // Notification thread
    //
    HRESULT StartNotificationThread();
    HRESULT StopNotificationThread();
    HRESULT RestartNotificationThread();

    //
    // members
    //
    static CColumnsInfo         m_ColsInfo;
    
    CFaxServerNode *            m_pParentNode;

    BOOL                        m_bIsFirstPopulateCall;

    static  HANDLE              m_hStopNotificationThreadEvent;

    HANDLE                      m_hNotifyThread;    // Handle of background notify thread

    static  DWORD WINAPI        NotifyThreadProc (LPVOID lpParameter);

	CFaxCoverPageNotifyWnd *	m_NotifyWin;       //: public CWindowImpl

    WCHAR                       m_pszCovDir[MAX_PATH+1];

};

typedef CNodeWithResultChildrenList<CFaxCoverPagesNode, CFaxCoverPageNode, CSimpleArray<CFaxCoverPageNode*>, FALSE>
        CBaseFaxOutboundRulesNode;

#endif  //H_FAXCOVERPAGES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\covnotifywnd.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CovNotifyWnd.h                                         //
//                                                                         //
//  DESCRIPTION   : The implementation of fax cover page notification      //
//                  window.                                                //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Mar 14 2000 yossg  Create                                          //
//                                                                         //
//  Copyright (C) 2000  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef _H_FAX_COV_NOTIFY_WND_H_
#define _H_FAX_COV_NOTIFY_WND_H_

#include <atlwin.h>


const int WM_NEW_COV = WM_USER + 1; 

class CFaxCoverPagesNode;

class CFaxCoverPageNotifyWnd : public CWindowImpl<CFaxCoverPageNotifyWnd> 
{
public:
    //
    // Constructor
    //
    CFaxCoverPageNotifyWnd(CFaxCoverPagesNode * pParentNode)
    {
        m_pCoverPagesNode = pParentNode;
    }

    //
    // Destructor
    //
    ~CFaxCoverPageNotifyWnd() 
    {
    }

    BEGIN_MSG_MAP(CFaxCoverPageNotifyWnd)
       MESSAGE_HANDLER(WM_NEW_COV, OnServerCovDirChanged)
    END_MSG_MAP()

    LRESULT OnServerCovDirChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    CFaxCoverPagesNode * m_pCoverPagesNode;
};

#endif // _H_FAX_COV_NOTIFY_WND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\c_snapin.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : C_Snapin.h (from Snapin.h)                             //
//                                                                         //
//  DESCRIPTION   : Header file for                                        //
//                    CSnapinPage                                          //
//                    CSnapinData                                          //
//                    CSnapinExtData                                       //
//                    CSnapinComponent                                     //
//                    CSnapin                                              //
//                    CSnapinAbout                                         //
//                                                                         //
//  AUTHOR        : ATL Snapin class wizard                                //
//                                                                         //
//  HISTORY       :                                                        //
//      May 25 1998 adik    Init.                                          //
//      Aug 24 1998 adik    Use Comet version.                             //
//      Sep 14 1998 yossg   seperate common source to an included file     //
//      Oct 18 1998 adik    Merged with new wizard version.                //
//      Jan 12 1999 adik    Add ParentArrayInterfaceFromDataObject.        //
//      Mar 28 1999 adik    Remove persistence support.                    //
//      Mar 30 1999 adik    Supporting ICometSnapinNode.                   //
//      Apr 27 1999 adik    Help support.                                  //
//      May 23 1999 adik    Use ifndef _IN_NEMMCUTIL in few places.        //
//      Jun 10 1999 AvihaiL Fix warnings.                                  //
//      Jun 14 1999 roytal  used UNREFERENCED_PARAMETER to fix build wrn   //
//      Jul 29 1999 adik    Release extensions.                            //
//                                                                         //
//      Oct 13 1999 yossg   Welcome to Fax Server				           //
//      Dec 12 1999 yossg   add CSnapin::Notify						       //
//      Apr 14 2000 yossg   Add support for primary snapin mode            //
//      Jun 25 2000 yossg   Add stream and command line primary snapin 	   //
//                          machine targeting.                             //
//                                                                         //
//  Copyright (C) 1998 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef C_SNAPIN_H_INCLUDED
#define C_SNAPIN_H_INCLUDED

#include <stdio.h>
//#include <ATLSnap.h> 
#include "..\inc\atlsnap.h"
#include "cVerNum.h"

EXTERN_C const CLSID CLSID_Snapin;
EXTERN_C const CLSID CLSID_SnapinAbout;

#define FXS_HINT_DELETE_ALL_RSLT_ITEMS    -1

class CSnapin;

////////////////////////////////////////////////////////////////////
// CSnapinExtData
//
class CSnapinExtData : public CSnapInItemImpl<CSnapinExtData, TRUE>
{
public:
    static const GUID* m_NODETYPE;
    static const OLECHAR* m_SZNODETYPE;
    static const OLECHAR* m_SZDISPLAY_NAME;
    static const CLSID* m_SNAPIN_CLASSID;

    CSnapin *m_pComponentData;

    BEGIN_SNAPINCOMMAND_MAP(CSnapinExtData, FALSE)
    END_SNAPINCOMMAND_MAP()

    SNAPINMENUID(IDR_SNAPIN_MENU)

    BEGIN_SNAPINTOOLBARID_MAP(CSnapinExtData)
        // Create toolbar resources with button dimensions 16x16
        // and add an entry to the MAP. You can add multiple toolbars
        // SNAPINTOOLBARID_ENTRY(Toolbar ID)
    END_SNAPINTOOLBARID_MAP()

    CSnapinExtData()
    {
        memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
        memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CSnapinExtData()
	{
    }

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        IUnknown* pUnk,
        DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }

    IDataObject* m_pDataObject;
    virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
    {
        m_pDataObject = pDataObject;
        UNREFERENCED_PARAMETER(pDefault);
        // The default code stores off the pointer to the Dataobject the class is wrapping
        // at the time.
        // Alternatively you could convert the dataobject to the internal format
        // it represents and store that information
    }

    CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault);
    

}; // endclass CSnapinExtData

////////////////////////////////////////////////////////////////////
// CSnapinComponent
//
class CSnapinComponent :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CSnapInObjectRoot<2, CSnapin>,
    public IExtendPropertySheetImpl<CSnapinComponent>,
    public IExtendContextMenuImpl<CSnapinComponent>,
    public IExtendControlbarImpl<CSnapinComponent>,
    public IComponentImpl<CSnapinComponent>
	//,     public IExtendTaskPadImpl<CSnapinComponent>
{
public:
BEGIN_COM_MAP(CSnapinComponent)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
//    COM_INTERFACE_ENTRY(IExtendTaskPad)
END_COM_MAP()

public:
    // A pointer to the currently selected node used for refreshing views.
    // When we need to update the view, we tell MMC to reselect this node.
    CSnapInItem * m_pSelectedNode;

    CSnapinComponent();

    ~CSnapinComponent();


    // We keep bitmaps strips for node icons around and use them repeatedly
    // rather than loading them from the resources each time we are queried for them.
    HBITMAP m_hBitmap16;
    HBITMAP m_hBitmap32;

    // Handlers for notifications which we want to handle on a
    // per-IComponent basis.
public:
    // We are overiding ATLsnap.h's IComponentImpl implementation of this
    // in order to correctly handle messages which it is incorrectly
    // ignoring (e.g. MMCN_COLUMN_CLICK and MMCN_SNAPINHELP)
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event,
                      LPARAM arg, LPARAM param);

    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA,
                              LPDATAOBJECT lpDataObjectB);

protected:
    virtual HRESULT OnColumnClick(LPARAM arg, LPARAM param);

    virtual HRESULT OnCutOrMove(LPARAM arg, LPARAM param);

    virtual HRESULT OnSnapinHelp(LPARAM arg, LPARAM param);

    virtual HRESULT OnViewChange(LPARAM arg, LPARAM param);

    virtual HRESULT OnPropertyChange(LPARAM arg, LPARAM param);

//    virtual HRESULT OnAddImages(LPARAM arg, LPARAM param);

public:

    // Related to TaskPad implementation.

    // We have to override this because the default implementation
    // gives back the wrong answer when the cookie is NULL.
    // NULL cookie means root node, and for our root node
    // we want a taskpad.
//  STDMETHOD(GetResultViewType)(long cookie,
//                               LPOLESTR  *ppViewType,
//                               long  *pViewOptions);

    STDMETHOD(GetTitle)(LPOLESTR pszGroup,
                        LPOLESTR *pszTitle);

    STDMETHOD(GetBanner)(LPOLESTR pszGroup,
                         LPOLESTR *pszBitmapResource);
}; // endclass CSnapinComponent

class CFaxServerNode;
////////////////////////////////////////////////////////////////////
// CSnapin
//
class CSnapin : public CComObjectRootEx<CComSingleThreadModel>,
    public CSnapInObjectRoot<1, CSnapin>,
    public IComponentDataImpl<CSnapin, CSnapinComponent>,
    public IExtendPropertySheetImpl<CSnapin>,
    public IExtendContextMenuImpl<CSnapin>,
    public IExtendControlbarImpl<CSnapin>,
    public IPersistStream,
    public ISnapinHelp,
    public CComCoClass<CSnapin, &CLSID_Snapin>
{
public:
    CSnapin();

    ~CSnapin();

    EXTENSION_SNAPIN_DATACLASS(CSnapinExtData)

    BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CSnapin)
	    EXTENSION_SNAPIN_NODEINFO_ENTRY(CSnapinExtData)
    END_EXTENSION_SNAPIN_NODEINFO_MAP()

    
    CFaxServerNode*     m_pPrimaryFaxServerNode;
   

BEGIN_COM_MAP(CSnapin)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(ISnapinHelp)
    COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()


    DECLARE_REGISTRY_RESOURCEID(IDR_SNAPIN)


DECLARE_NOT_AGGREGATABLE(CSnapin)

    STDMETHOD(GetClassID)(CLSID *pClassID)
    {
        ATLTRACE(_T("CSnapin::GetClassID"));
        ATLASSERT(pClassID);

        *pClassID = CLSID_Snapin;

        return S_OK;
    }

    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

    static void WINAPI ObjectMain(bool bStarting)
    {
        if (bStarting)
            CSnapInItem::Init();
    }
    
    //
    // ISnapinHelp Interface
    //
    STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);

    virtual WCHAR *GetHelpFile();
    virtual WCHAR *GetHelpTopic();

    //
    // Override IComponentDataImpl's Notify 
    // for lpDataObject == NULL && event == MMCN_PROPERTY_CHANGE
    //
    STDMETHOD(Notify)( 
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param);

    //
    // IPersistStream: 
    // These originally pure virtual functions 
    // must been defined here
    //
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL /*fClearDirty*/);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

private:

    CComBSTR    m_bstrServerName;
	
    BOOL        m_fAllowOverrideServerName;

}; // endclass CSnapin

////////////////////////////////////////////////////////////////////
// CSnapinAbout
//

class ATL_NO_VTABLE CSnapinAbout : public ISnapinAbout,
    public CComObjectRoot,
    public CComCoClass< CSnapinAbout, &CLSID_SnapinAbout>
{
public:
    DECLARE_REGISTRY(CSnapinAbout, _T("SnapinAbout.1"), _T("SnapinAbout.1"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CSnapinAbout)
        COM_INTERFACE_ENTRY(ISnapinAbout)
    END_COM_MAP()

    STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
    {
        USES_CONVERSION;
        TCHAR szBuf[256];
        if (::LoadString(_Module.GetResourceInstance(), IDS_SNAPIN_DESC, szBuf, 256) == 0)
            return E_FAIL;

        *lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
        if (*lpDescription == NULL)
            return E_OUTOFMEMORY;

        ocscpy(*lpDescription, T2OLE(szBuf));

        return S_OK;
    }

    STDMETHOD(GetProvider)(LPOLESTR *lpName)
    {
        USES_CONVERSION;
        WCHAR szBuf[256];
        if (::LoadString(_Module.GetResourceInstance(), IDS_SNAPIN_PROVIDER, szBuf, 256) == 0)
            return E_FAIL;

        *lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
        if (*lpName == NULL)
            return E_OUTOFMEMORY;

        ocscpy(*lpName, T2OLE(szBuf));

        return S_OK;
    }

    STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
    {

        USES_CONVERSION;
        TCHAR szBuf[256];
        TCHAR szFmt[200];
        if (::LoadString(_Module.GetResourceInstance(), IDS_SNAPIN_VERSION, szFmt, 200) == 0)
            return E_FAIL;
        swprintf(szBuf, szFmt, rmj, rmm, rup);
        *lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
        if (*lpVersion == NULL)
            return E_OUTOFMEMORY;

        ocscpy(*lpVersion, T2OLE(szBuf));
    
        return S_OK;
    }

    STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
    {
        *hAppIcon = ::LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_ICON_FAXSERVER));
        return S_OK;
    }

    STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
        HBITMAP *hSmallImageOpen,
        HBITMAP *hLargeImage,
        COLORREF *cMask)
    {
        HINSTANCE hInst = _Module.GetResourceInstance();

        *hSmallImage = ::LoadBitmap(hInst, MAKEINTRESOURCE(IDB_FAX_BITMAP_16));
        *hSmallImageOpen = ::LoadBitmap(hInst, MAKEINTRESOURCE(IDB_FAX_BITMAP_16));
        *hLargeImage = ::LoadBitmap(hInst, MAKEINTRESOURCE(IDB_FAX_BITMAP_32));
        *cMask = RGB(255, 255, 255); // RGB(255, 0, 255);

        return S_OK;
    }
}; // endclass CSnapinAbout

HRESULT AddBitmaps(IImageList *pImageList);

#endif // ! C_SNAPIN_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\covnotifywnd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CovNotifyWnd.cpp                                       //
//                                                                         //
//  DESCRIPTION   : The implementation of fax cover page notification      //
//                  window.                                                //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Mar 14 2000 yossg  Create                                          //
//                                                                         //
//  Copyright (C) 2000  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CovNotifyWnd.h"

#include "CoverPages.h"

LRESULT CFaxCoverPageNotifyWnd::OnServerCovDirChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
      DEBUG_FUNCTION_NAME( _T("CFaxCoverPageNotifyWnd::OnServerCovDirChanged"));
	  ATLASSERT(m_pCoverPagesNode);

      m_pCoverPagesNode->DoRefresh();
      
	  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\c_snapin.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : C_Snapin.cpp (Snapin.cpp)                              //
//                                                                         //
//  DESCRIPTION   : Implementation file for                                //
//                    CSnapin          class                               //
//                    CSnapinComponent class                               //
//                                                                         //
//  AUTHOR        : ATL Snapin wizard                                      //
//                                                                         //
//  HISTORY       :                                                        //
//      May 25 1998 adik    Init.                                          //
//      Aug 24 1998 adik    WEB IVR instead IVR.                           //
//      Sep 14 1998 yossg   seperate common source to an included file     //
//      Oct 18 1998 adik    Merged with new wizard version.                //
//      Jan 12 1999 adik    Add ParentArrayInterfaceFromDataObject.        //
//      Mar 28 1999 adik    Remove persistence support.                    //
//      Mar 30 1999 adik    Support of ICometSnapinNode in IDataObject.    //
//      Apr 27 1999 adik    Help support.                                  //
//      Jun 10 1999 adik    Change bitmap mask to white.                   //
//      Jun 14 1999 roytal  used UNREFERENCED_PARAMETER to fix build wrn   //
//      Jun 21 1999 adik    Handle MMCN_COLUMN_CLICK to avoid ASSERT.      //
//      Jun 22 1999 zvib    change handling of property change             //
//                                                                         //
//      Oct 13 1999 yossg   Welcome to Fax Server				           //
//      Jan 19 2000 yossg   Add CFaxPropertyChangeNotification to          //
//                          CSnapinComponent::Notify MMCN_PROPERTY_CHANGE  //
//      Apr 14 2000 yossg   Add support for primary snapin mode			   //
//      Jun 25 2000 yossg   Add stream and command line primary snapin 	   //
//                          machine targeting.                             //
//                                                                         //
//  Copyright (C) 1998 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "C_Snapin.h"
#include "ResUtil.h"

#include "FaxServerNode.h"  

#include "FaxMMCPropertyChange.h"
#include "FxsValid.h"
#include "Icons.h"

#include <ObjBase.h>
#include <windns.h> //DNS_MAX_NAME_BUFFER_LENGTH



HRESULT
AddBitmaps(IImageList *pImageList)
{
    HBITMAP     hBitmap16 = NULL;
    HBITMAP     hBitmap32 = NULL;
    HINSTANCE   hInst;
    HRESULT     hr;

    // Load bitmaps associated with the scope pane
    // and add them to the image list
    // Loads the default bitmaps generated by the wizard
    // Change as required

    hInst = _Module.GetResourceInstance();

    //
    // Load 16 bits
    //
    hBitmap16 = LoadBitmap(hInst, MAKEINTRESOURCE(IDR_TOOLBAR_16));
    if (hBitmap16 == NULL)
    {
        hr = E_FAIL;
        ATLTRACE(_T("LoadBitmap failed\n"));
        goto Cleanup;
    }

    //
    // Load 32 bits
    //
    hBitmap32 = LoadBitmap(hInst, MAKEINTRESOURCE(IDR_TOOLBAR_32));
    if (hBitmap32 == NULL)
    {
        hr = E_FAIL;
        ATLTRACE(_T("LoadBitmap failed\n"));
        goto Cleanup;
    }

    //
    // Add to image list
    //
    hr = pImageList->ImageListSetStrip(
                        (LONG_PTR*)hBitmap16,
                        (LONG_PTR*)hBitmap32,
                        0,
                        RGB(0, 128, 128));
    if ( FAILED(hr) )
    {
        ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
        goto Cleanup;
    }

Cleanup:

    if (NULL != hBitmap32)
    {
        DeleteObject(hBitmap32);
    }
    if (NULL != hBitmap16)
    {
        DeleteObject(hBitmap16);
    }

    return hr;
}

class CFaxServerNode;
CSnapin::CSnapin()
{
    m_bstrServerName                  = L"";  //LocalMachine as default
    m_fAllowOverrideServerName        = TRUE;

    m_pPrimaryFaxServerNode           = new CFaxServerNode(
                                                NULL, 
                                                this, 
                                                L""); //m_bstrServerName.m_str

    ATLASSERT(m_pPrimaryFaxServerNode != NULL);
    
    m_pPrimaryFaxServerNode->SetIcons(IMAGE_FAX, IMAGE_FAX);

    m_pNode                           = (CSnapInItem *) m_pPrimaryFaxServerNode; 

    m_pComponentData = this;
    
    m_CSnapinExtData.m_pComponentData = this;
}

CSnapin::~CSnapin()
{
    if (NULL != m_pPrimaryFaxServerNode)
    {
        delete m_pPrimaryFaxServerNode;
        m_pPrimaryFaxServerNode = NULL;
    }
    
    m_pNode = NULL;
}




HRESULT
CSnapin::Initialize(LPUNKNOWN pUnknown)
{
    HRESULT hr = IComponentDataImpl<CSnapin, CSnapinComponent >::Initialize(pUnknown);
    if (FAILED(hr))
        return hr;

    CComPtr<IImageList> spImageList;

    if (m_spConsole->QueryScopeImageList(&spImageList) != S_OK)
    {
        ATLTRACE(_T("IConsole::QueryScopeImageList failed\n"));
        return E_UNEXPECTED;
    }

    hr = ::AddBitmaps(spImageList);

    return hr;
}

HRESULT
CSnapinExtData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle,
    IUnknown* pUnk,
    DATA_OBJECT_TYPES type)
{
    UNREFERENCED_PARAMETER (lpProvider);
    UNREFERENCED_PARAMETER (handle);
    UNREFERENCED_PARAMETER (pUnk);

    // override this method.
    if (type == CCT_SCOPE || type == CCT_RESULT)
    {
        return S_OK;
    }
    return E_UNEXPECTED;
}

//////////////////////////////////////////////////////////////////////////////

CSnapinComponent::CSnapinComponent()
{
    m_pSelectedNode = NULL;
    m_hBitmap16 = NULL;
    m_hBitmap32 = NULL;
}

//////////////////////////////////////////////////////////////////////////////

CSnapinComponent::~CSnapinComponent()
{
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::Notify

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSnapinComponent::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    DEBUG_FUNCTION_NAME( _T("CSnapinComponent::Notify"));
    HRESULT hr = S_OK;

    if(lpDataObject != NULL && MMCN_SHOW != event)
    {
        return IComponentImpl<CSnapinComponent>::Notify(lpDataObject, event, arg, param);
    }
    

    //
    // In this routine we handle only
    // lpDataObject ==NULL, or we have a MMCN_SHOW event.
    //


    if(MMCN_SHOW == event)
    {
      //
      // On Show event, we want to keep, or reset
      // the node currenlty selected
      //
      ATLASSERT(lpDataObject != NULL);

      //
      // Retreive the pItem data type
      //
      CSnapInItem* pItem;
      DATA_OBJECT_TYPES type;
      hr = m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);

      if(FAILED(hr))
          return(hr);

      if( arg )
      {
         // We are being selected.
         m_pSelectedNode = pItem;

      }
      else
      {
         // We are being deselected.

         // Check to make sure that our result view doesn't think
         // this node is the currently selected one.
         if( m_pSelectedNode == pItem)
         {
            // We don't want to be the selected node anymore.
            m_pSelectedNode = NULL;
         }

      }

      //
      // Call SnapinItem notification routine
      //
      return IComponentImpl<CSnapinComponent>::Notify(lpDataObject, event, arg, param);
    }

    //
    // lpDataObject == NULL
    //

    // Currently handling only View Change (UpdateAllViews)
    // And PropertyChange

    switch (event)
    {
        case MMCN_VIEW_CHANGE:
            if( ( arg == NULL || (CSnapInItem *) arg == m_pSelectedNode ) && m_pSelectedNode != NULL )
            {
                if ( FXS_HINT_DELETE_ALL_RSLT_ITEMS == param)
                {
                    
                    ATLASSERT(m_spConsole);
                    CComQIPtr<IResultData, &IID_IResultData> pResultData(m_spConsole);
                    ATLASSERT(pResultData);
    
                    hr = pResultData->DeleteAllRsltItems();
                    if( FAILED(hr) )
                    {
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("Fail to DeleteAllRsltItems().(hRc: %08X)"),
                            hr);
                        return( hr );
                    }
                    break;
                }
                
                // We basically tell MMC to simulate reselecting the
                // currently selected node, which causes it to redraw.
                // This will cause MMC to send the MMCN_SHOW notification
                // to the selected node.
                // This function requires an HSCOPEITEM.  This is the ID member
                // of the HSCOPEDATAITEM associated with this node.
                SCOPEDATAITEM *pScopeDataItem;
                m_pSelectedNode->GetScopeData(&pScopeDataItem);
                hr = m_spConsole->SelectScopeItem(pScopeDataItem->ID);
            }
            break;



        case MMCN_PROPERTY_CHANGE:

              CFaxPropertyChangeNotification * pNotification;
              CSnapInItem * pItem;
              pNotification = ( CFaxPropertyChangeNotification * ) param;
              ATLASSERT(pNotification);
              pItem = pNotification->pItem;
              ATLASSERT(pItem);
              hr = pItem->Notify(event, arg, param, NULL, (IComponent*) this, CCT_RESULT);
              break;
              

//              CSnapInItem * pNode;
//              pNode = (CSnapInItem *) param;
//              hr = pNode->Notify(event, arg, param, NULL, (IComponent*) this, CCT_RESULT);
//              break;


//       case MMCN_PROPERTY_CHANGE:
//            {
//
//                CComQIPtr<IResultData, &IID_IResultData> spResultData(m_spConsole);
//                hr = spResultData->UpdateItem((HRESULTITEM)(param));
//            }
//            break;

        case MMCN_SNAPINHELP:
            ATLASSERT(0); // Shouldn't been called since we support ISnapinHelp

            //
            // Call imported method from NeMmcUtl.dll
            //
            OnSnapinHelp(arg, param);
            break;

        case MMCN_COLUMN_CLICK:
            //
            // MMC 1.2 handles this
            //
            break;

        default:
            //
            // Catch un handeled events
            //
            ATLASSERT(0);

    } // endswitch (event)

   return hr;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::CompareObjects

Needed so that IPropertySheetProvider::FindPropertySheet will work.

FindPropertySheet is used to bring a pre-existing property sheet to the foreground
so that we don't open multiple copies of Properties on the same node.

It requires CompareObjects to be implemented on both IComponent and IComponentData.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSnapinComponent::CompareObjects(LPDATAOBJECT lpDataObjectA,
                                 LPDATAOBJECT lpDataObjectB)
{
    ATLTRACE(_T("# CSnapinComponent::CompareObjects\n"));

    HRESULT hr;

    CSnapInItem *pDataA, *pDataB;
    DATA_OBJECT_TYPES typeA, typeB;

    hr = GetDataClass(lpDataObjectA, &pDataA, &typeA);
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = GetDataClass(lpDataObjectB, &pDataB, &typeB);
    if ( FAILED( hr ) )
    {
        return hr;
    }

    if( pDataA == pDataB )
    {
        // They are the same object.
        return S_OK;
    }
    else
    {
        // They are different.
        return S_FALSE;
    }
}

/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::OnColumnClick

HRESULT OnColumnClick(
              LPARAM arg
            , LPARAM param
            )

In our implementation, this method gets called when the MMCN_COLUMN_CLICK
Notify message is sent for our IComponent object.

MMC sends this message when the user clicks on a result-list view column header.


Parameters

    arg
    Column number.

    param
    Sort option flags. By default, the sort is in ascending order. To specify descending order, use the RSI_DESCENDING (0x0001) flag.


Return Values

    Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSnapinComponent::OnColumnClick(LPARAM arg, LPARAM param)
{
    ATLTRACE(_T("# CSnapinComponent::OnColumnClick -- Not implemented\n"));

    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);

    // Check for preconditions:
    // None.

    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::OnCutOrMove

HRESULT OnCutOrMove(
              LPARAM arg
            , LPARAM param
            )

In our implementation, this method gets called when the MMCN_COLUMN_CLICK
Notify message is sent for our IComponent object.

MMC sends this message when the user clicks on a result-list view column header.


Parameters

    arg
    Column number.

    param
    Sort option flags. By default, the sort is in ascending order. To specify descending order, use the RSI_DESCENDING (0x0001) flag.


Return Values

    Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSnapinComponent::OnCutOrMove(LPARAM arg, LPARAM param)
{
    ATLTRACE(_T("# CSnapinComponent::OnCutOrMove\n"));

    // ISSUE: This may need to be changed once the MMC team finalizes their
    // cut and paste protocol -- they seem to be in flux for 1.1 as of 02/16/98.
    // Currently, we will assume that the arg value passed to us is the source item
    // in the cut-and-paste or drag-n-drop operation.  That is, it is the object
    // to be deleted.
    // We supplied this pointer in our response to the MMCN_PASTE notification,
    // when we set param to point to the source IDataObject.

    HRESULT hr;

    if( arg != NULL )
    {

        CSnapInItem* pData;
        DATA_OBJECT_TYPES type;
        hr = CSnapInItem::GetDataClass( (IDataObject *) arg, &pData, &type);

        ATLASSERT(SUCCEEDED(hr));

        if (SUCCEEDED(hr))
        {
            // We need a richer Notify method which has information about the IComponent and IComponentData objects
            //hr = pData->Notify(event, arg, param, TRUE, m_spConsole, NULL, NULL);

            hr = pData->Notify( MMCN_CUTORMOVE, arg, param, NULL, this, type );
        }
    }

//  return E_NOTIMPL;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::OnSnapinHelp

HRESULT OnSnapinHelp(
              LPARAM arg
            , LPARAM param
            )

In our implementation, this method gets called when the MMCN_SNAPINHELP
Notify message is sent for our IComponent object.

MMC sends this message when the user requests help about the snap-in.

Parameters

    arg
    0

    param
    0

Return Values

    Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSnapinComponent::OnSnapinHelp(LPARAM arg, LPARAM param)
{
    ATLTRACE(_T("# CSnapinComponent::OnSnapinHelp\n"));

    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);

    // Check for preconditions:
    _ASSERTE( m_spConsole != NULL );

    ::OnSnapinHelp(m_spConsole);

#if 0
    HRESULT hr;
    //TCHAR   szFileName[MAX_PATH];
    HWND    hWnd;

    // Get HWND from MMC.
    hr = m_spConsole->GetMainWindow( &hWnd );
    _ASSERTE( SUCCEEDED( hr ) && NULL != hWnd );

#ifdef UNICODE_HHCTRL
    // ISSUE: We seemed to have a problem with passing WCHAR's to the hhctrl.ocx
    // installed on this machine -- it appears to be non-unicode.
    //lstrcpy( szFileName, HTMLHELP_NAME );
    //HtmlHelp( hWnd, szFileName, HH_DISPLAY_TOPIC, (DWORD) _T("iasmmc_main_help.htm") );
#else
    //strcpy( (CHAR *) szFileName, HTMLHELP_NAME );
    //HtmlHelp( hWnd, (TCHAR *) szFileName, HH_DISPLAY_TOPIC, (DWORD) "iasmmc_main_help.htm" );
#endif

#endif // 0
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::OnViewChange

HRESULT OnViewChange(
              LPARAM arg
            , LPARAM param
            )

This is where we respond to an MMCN_VIEW_CHANGE notification.

In our implementation, this is a signal to check the currently selected node in
the result pane for this component, and refresh the view if the node happens to
be the same as the pointer to a CSnapInItem passed in through arg.

We do this because you only want to refresh the view of the currently selected
node, and you only want to do that if its children have changed.

If the arg passed in is NULL, we just reselect the currently selected node.


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSnapinComponent::OnViewChange(LPARAM arg, LPARAM param)
{
    ATLTRACE(_T("# CNodeWithResultChildrenList::OnViewChange\n"));

    // Check for preconditions:
    UNREFERENCED_PARAMETER (param);
    _ASSERTE( m_spConsole != NULL );

    HRESULT hr = S_FALSE;

    // What localsec snapin checks for:
    if( ( arg == NULL || (CSnapInItem *) arg == m_pSelectedNode ) && m_pSelectedNode != NULL )
    {
        // We basically tell MMC to simulate reselecting the
        // currently selected node, which causes it to redraw.
        // This will cause MMC to send the MMCN_SHOW notification
        // to the selected node.
        // This function requires an HSCOPEITEM.  This is the ID member
        // of the HSCOPEDATAITEM associated with this node.
        SCOPEDATAITEM *pScopeDataItem;
        m_pSelectedNode->GetScopeData( &pScopeDataItem );
        hr = m_spConsole->SelectScopeItem( pScopeDataItem->ID );
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::OnPropertyChange

HRESULT OnPropertyChange(
              LPARAM arg
            , LPARAM param
            )

This is where we respond to an MMCN_PROPERTY_CHANGE notification.

This notification is sent when we call MMCPropertyChangeNotify.
We call this in our property pages when changes are made to the data
they contain and we may need to update of view of the data.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSnapinComponent::OnPropertyChange(LPARAM arg, LPARAM param)
{
    ATLTRACE(_T("# CSnapinComponent::OnPropertyChange\n"));

    // Check for preconditions:
    _ASSERTE( m_spConsole != NULL );
    UNREFERENCED_PARAMETER (arg);

    HRESULT hr = S_FALSE;

    if( param == NULL )
    {

        // We want to make sure all views get updated.
        hr = m_spConsole->UpdateAllViews( NULL, (LPARAM) m_pSelectedNode, NULL);
    }
    else
    {
        // We passed a pointer to a CSnapInItem in the param argument.
        // We call notify on that node, passing it our own custom event type
        // so that it knows that it must refresh its data.

        CSnapInItem * pSnapInItem = (CSnapInItem *) param;

        // Call notify on this node with the MMCN_PROPERTY_CHANGE notification.
        // We had to use this trick because of the fact that we are using template
        // classes and so we have no common object among all our nodes
        // other than CSnapInItem.  But we can't change CSnapInItem
        // so instead we use the notify method it already has with a new
        // notification.

        // Note:  We are trying to deal gracefully here with the fact that the
        // MMCN_PROPERTY_CHANGE notification doesn't pass us an lpDataObject
        // so we have to have our own protocol for picking out which node
        // needs to update itself.

        hr = pSnapInItem->Notify( MMCN_PROPERTY_CHANGE
                            , NULL
                            , NULL
                            , NULL
                            , NULL
                            , (DATA_OBJECT_TYPES) 0
                            );

        // We want to make sure all views with this node select also get updated.
        hr = m_spConsole->UpdateAllViews( NULL, (LPARAM) pSnapInItem, NULL);
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::OnAddImages

HRESULT OnAddImages(
              LPARAM arg
            , LPARAM param
            )

This is where we respond to an MMCN_ADD_IMAGES notification to
this IComponent object.

We add images to the image list used to display result pane
items corresponding to this IComponent's view.

MMC sends this message to the snap-in's IComponent implementation
to add images for the result pane.

Parameters

    arg
    Pointer to the result pane's image list (IImageList).

    param
    Specifies the HSCOPEITEM of the item that was selected or deselected.


Return Values

    Not used.


Remarks

    The primary snap-in should add images for both folders and leaf
    items. Extension snap-ins should add only folder images.


--*/
//////////////////////////////////////////////////////////////////////////////
/*HRESULT
CSnapinComponent::OnAddImages(LPARAM arg, LPARAM param)
{
    ATLTRACE(_T("# CSnapinComponent::OnAddImages\n"));


    // Check for preconditions:
    UNREFERENCED_PARAMETER (param);
    _ASSERTE( arg != NULL );

    HRESULT hr = S_FALSE;

    // ISSUE: sburns in localsec does a trick where he combines
    // scope and result pane ImageLists into one
    // is this necessary?

    CComPtr<IImageList> spImageList = reinterpret_cast<IImageList*>(arg);
    _ASSERTE( spImageList != NULL );


    if( NULL == m_hBitmap16 )
    {
        m_hBitmap16 = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE( IDR_TOOLBAR_16 ) );
    }

    if( NULL == m_hBitmap32 )
    {
        m_hBitmap32 = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE( IDR_TOOLBAR_32 ) );
    }

    if( m_hBitmap16 != NULL && m_hBitmap32 != NULL )
    {
        hr = spImageList->ImageListSetStrip( (LONG_PTR*) m_hBitmap16, (LONG_PTR*) m_hBitmap32, 0, RGB(0,128,128) );
        if( FAILED( hr ) )
        {
            ATLTRACE(_T("# *** CSnapinNode::OnAddImages  -- Failed to add images.\n"));
        }
    }


    // ISSUE: Where do we release the bitmaps we load here?

    return hr;
}*/

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::GetResultViewType

Used to answer what the view type should be for the result view.

We need to implement this here so that we can override the ATLsnap.h
implementation, which doesn't properly allow for the fact that a NULL cookie
corresponds to the root node, and we may not necessarily want the default
view for the root node.

This problem with ATLsnap.h could not easily be changed as the CSnapinComponentImpl
class has no easy way to find the root node -- it doesn't have a member
variable corresponding to it.

--*/
//////////////////////////////////////////////////////////////////////////////
//STDMETHODIMP CSnapinComponent::GetResultViewType (
//    long cookie
//  , LPOLESTR  *ppViewType
//  , long  *pViewOptions
//  )
//{
//  ATLTRACE(_T("# CSnapinComponent::GetResultViewType\n"));
//
//
//  // Check for preconditions:
//
//
//
//  // Check to see which node we are being asked to give view type for.
//  if (cookie == NULL)
//  {
//      // We are being asked for the result view type of our
//      // root node -- let the root node give back its answer.
//
//      _ASSERTE( m_pComponentData != NULL );
//      _ASSERTE( m_pComponentData->m_pNode != NULL );
//      return m_pComponentData->m_pNode->GetResultViewType(ppViewType, pViewOptions);
//
//  }
//  else
//  {
//      // Cookie was not null, which means we are beng asked about
//      // the result view type for some node other than our root node.
//      // Let that node set whatever view type it wants to.
//      CSnapInItem* pItem = (CSnapInItem*)cookie;
//
//      return pItem->GetResultViewType(ppViewType, pViewOptions);
//  }
//
//}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::GetTitle

IExtendTaskPad interface member.

This is the title that show up under the banner.

ISSUE: Why does this not appear to be working?

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSnapinComponent::GetTitle(LPOLESTR pszGroup, LPOLESTR *pszTitle)
{
    ATLTRACE(_T("# CSnapinComponent::GetTitle\n"));
    UNREFERENCED_PARAMETER (pszGroup);

    // Check for preconditions:
    _ASSERTE( pszTitle != NULL );

    OLECHAR szTitle[256];
    int nLoadStringResult = LoadString(_Module.GetResourceInstance(), IDS_TASKPAD_TITLE, szTitle, 256);
    _ASSERT( nLoadStringResult > 0 );

    *pszTitle= (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(lstrlen(szTitle)+1) );

    if( ! *pszTitle )
    {
        return E_OUTOFMEMORY;
    }

    lstrcpy( *pszTitle, szTitle );

    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::GetBanner

IExtendTaskPad interface member.

We provide the color bar banner that appears at the top of the taskpad.
It is a resource in our snapin DLL.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSnapinComponent::GetBanner (LPOLESTR pszGroup, LPOLESTR *pszBitmapResource)
{
    ATLTRACE(_T("# CSnapinComponent::GetBanner\n"));
    UNREFERENCED_PARAMETER (pszGroup);

    // We are constructing a string pointing to the bitmap resource
    // of the form: "res://D:\MyPath\MySnapin.dll/img\ntbanner.gif"

    OLECHAR szBuffer[MAX_PATH*2]; // A little extra.


    // Get "res://"-type string for bitmap.
    lstrcpy (szBuffer, L"res://");
    OLECHAR * temp = szBuffer + lstrlen(szBuffer);

    // Get our executable's filename.
    HINSTANCE hInstance = _Module.GetResourceInstance();
    ::GetModuleFileName (hInstance, temp, MAX_PATH);

    // Add the name of the image within our resources.
    lstrcat (szBuffer, L"/img\\IASTaskpadBanner.gif");

    // Alloc and copy bitmap resource string.
    *pszBitmapResource = (LPOLESTR) CoTaskMemAlloc(sizeof(OLECHAR)*(lstrlen(szBuffer)+1) );
    if (!*pszBitmapResource)
    {
        return E_OUTOFMEMORY;
    }

    lstrcpy( *pszBitmapResource, szBuffer);

    return S_OK;

}

/*
 -  CSnapin::GetHelpTopic
 -
 *  Purpose:
 *      See MMC help on ISnapinHelp::GetHelpTopic
 *
 *  Arguments:
 *      [out]   lpCompiledHelpFile - Pointer to the address of the NULL-terminated
 *                                   UNICODE string that contains the full path of
 *                                   the compiled help file (.chm) for the snap-in.
 *
 *  Return:
 *      OLE error code
 */
HRESULT STDMETHODCALLTYPE
CSnapin::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
    WCHAR   *pszFilePath;
    WCHAR   *pszTopic;
    HRESULT hRc = S_OK;
    ULONG   ulLen;

    DEBUG_FUNCTION_NAME( _T("CSnapin::GetHelpTopic"));

    ATLASSERT(lpCompiledHelpFile != NULL);

    //
    // Get the CHM file name and the current topic
    //
    pszFilePath = GetHelpFile();
    pszTopic = NULL; //pszTopic = GetHelpTopic(); current implementation.

    if (pszFilePath == NULL)
    {
        hRc = E_OUTOFMEMORY;
        DebugPrintEx(DEBUG_ERR,_T("Failed to GetHelpFile(). (hRc: %08X)"), hRc);
        goto Cleanup;
    }

    //
    // Allocate mem for it
    ulLen = lstrlen(pszFilePath) + 1;
    if (pszTopic && *pszTopic)
    {
        ulLen += 2 /* for "::" */ + lstrlen(pszTopic);
    }
    ulLen *= sizeof(WCHAR);

    *lpCompiledHelpFile = reinterpret_cast<LPOLESTR>(::CoTaskMemAlloc(ulLen));
    if (*lpCompiledHelpFile == NULL)
    {
        hRc = E_OUTOFMEMORY;
        DebugPrintEx(DEBUG_ERR,_T("Failed to do CoTaskMemAlloc. (hRc: %08X)"), hRc);
        goto Cleanup;
    }
    wcscpy(*lpCompiledHelpFile, pszFilePath);

    //
    // Copy the help file::topic
    //
    if (pszTopic && *pszTopic)
    {
        wcscat(*lpCompiledHelpFile, L"::");
        wcscat(*lpCompiledHelpFile, pszTopic);
    }

Cleanup:
    return hRc;
}


WCHAR*
CSnapin::GetHelpFile()
{
    DEBUG_FUNCTION_NAME( _T("CSnapin::GetHelpFile"));

    return ::GetHelpFile();
}


///////////////////////////////////////////////////////////////
//
// IPesistStream
//

/////////////////////////////////////////////////////////////////////
//const WCHAR szOverrideCommandLineEquals[] = _T("/Computer=");	// Not subject to localization
//const WCHAR szOverrideCommandLineColon[] = _T("/Computer:");	// Not subject to localization

const WCHAR g_szFaxOverrideCommandLineEquals[] = _T("/FAX=");	    // Not subject to localization
const WCHAR g_szLocalMachine[] = _T("LocalMachine");		        // Not subject to localization


//we keep the version of persistence information of CSnapin 
//when the persistence format is changed we need to increase this integer number
//we will read persistnce information only if the persistence version in the stream
//matches that of the PERISISTENCE_VERSION.

#define PERISISTENCE_VERSION 100002

//
// The persist stream format is:
// 
// Version (UINT)
// AllowOverride (BOOL)
// Server Name length (UINT)
// Server Name string ( <= WCHAR * DNS_MAX_NAME_BUFFER_LENGTH )
//

/*
 -  CSnapin::Load
 -
 *  Purpose:
 *      Initializes an object from the stream where it was previously saved.
 *
 *  Arguments:
 *      [in] pStm - Pointer to the stream from which the object 
 *                  should be loaded.
 *  Return:
 *      S_OK          - The object was successfully loaded. 
 *      E_OUTOFMEMORY - The object was not loaded due to a lack of memory. 
 *      E_FAIL        - The object was not loaded due to some reason other 
 *                      than a lack of memory.
 *
 */
STDMETHODIMP CSnapin::Load(IStream *pStm)
{
    DEBUG_FUNCTION_NAME( _T("CSnapin::Load"));
	HRESULT    hRc = S_OK;
    
    BOOL       fServerNameFoundInCommandLine = FALSE;
    CComBSTR   bstrCommandLineServerName     = L"";

    LPCWSTR    wcszPersistStreamServerName   = NULL;

    UINT       uiVersion  = 0;
    ULONG      nBytesRead = 0;

	//
    // Pre-conditions
    //
    ATLASSERT( NULL != pStm );

    //
    // A. Read the Stream
    // ==================
    //

    //
    // Read the Version
    //
    hRc = pStm->Read(&uiVersion, sizeof(uiVersion), NULL);
    if( FAILED( hRc ) ) 
    {
        DebugPrintEx( DEBUG_ERR,
			_T("pStm->Read(version). (hRc: %08X)"), hRc);
        
        return E_FAIL;
    }

    if (uiVersion == PERISISTENCE_VERSION)
    {

	    //
        // Read Allow-to-override stream machine-name flag 
        // from command line source
        //
	    hRc = pStm->Read( &m_fAllowOverrideServerName, sizeof(m_fAllowOverrideServerName), NULL );
        if( FAILED( hRc ) ) 
        {
            DebugPrintEx( DEBUG_ERR,
			    _T("pStm->Read(fAllowOverrideServerName). (hRc: %08X)"), hRc);
        
            return E_FAIL;
        }

        //
        // Read the Server Name from stream
        //
	    hRc = pStm->Read (&nBytesRead , sizeof(ULONG), NULL);
        if( FAILED( hRc ) ) 
        {
            DebugPrintEx( DEBUG_ERR,
			    _T("Fail to Read server name length from stream. (hRc: %08X)"), hRc);
            return E_FAIL;
        }
	    ATLASSERT (nBytesRead <= DNS_MAX_NAME_BUFFER_LENGTH * sizeof (WCHAR));
	    wcszPersistStreamServerName = (LPCWSTR) alloca (nBytesRead);

	    hRc = pStm->Read ((PVOID) wcszPersistStreamServerName, nBytesRead, NULL);
        if( FAILED( hRc ) ) 
        {
            DebugPrintEx( DEBUG_ERR,
			    _T("Fail to Read server name from stream. (hRc: %08X)"), hRc);
            return E_FAIL;
        }

    }
    else // version!=PERISISTENCE_VERSION
    {
        //
        // Persistance data will not be readed due to inconsitency.
        //
        
        DebugPrintEx( DEBUG_ERR,
			_T("The current *.msc file version (%ld) is differnt from the\n pesistance version the dll expecting (%ld)."), uiVersion, PERISISTENCE_VERSION);

        
        //
        // Next we'll try to Read ServerName from Command line 
        //
    }

    //
    // B. Try to read from command line
    // ================================
    //
    
    // fServerNameFoundInCommandLine initial state == FALSE
    if (m_fAllowOverrideServerName)
    {
        int      argCount   = 0;
        PWSTR*   argV       = NULL;
        
        const int cchFaxOverrideCommandLine = ( sizeof(g_szFaxOverrideCommandLineEquals) / sizeof(g_szFaxOverrideCommandLineEquals[0]) ) - 1;
    
	    argV = CommandLineToArgvW(GetCommandLine() , &argCount);

        if (argV == NULL)
        {
		    DWORD ec;
		    ec = GetLastError();
		    
		    DebugPrintEx(
			    DEBUG_ERR,
			    _T("Fail to parse Command Line To Argv. (ec: %ld)"), 
			    ec);
		    
		    return E_FAIL;
        }

        //argV[0] is not an argument
	    for (int i = 1; i < argCount; i++)
	    {
		    WCHAR * psz = argV[i]; 

		    if (  0 == wcsnicmp( psz , g_szFaxOverrideCommandLineEquals , cchFaxOverrideCommandLine )  )
		    {
			    fServerNameFoundInCommandLine = TRUE;

	     		psz = _tcsninc(psz, cchFaxOverrideCommandLine);  //psz = psz + cchFaxOverrideCommandLine;
			    if ( 0 != wcscmp( psz , g_szLocalMachine )  )
			    {

                    //
                    // Server Name initial '\\' trancation (if they are there)
                    //
                    if (  ( _tcslen(psz) > 2 ) && ( 0 == wcsncmp( psz , _T("\\\\") , 2 ))   )
                    {
                        psz = _tcsninc(psz, 2); 
                    }
                    
                    if ( _tcslen(psz) >  0)
                    {
                        //
                        // Server Name validity checks
                        //
                        CComBSTR bstrServerNameValidation = psz;
                        UINT  uTmp = 0;
                        if (!IsValidServerNameString(bstrServerNameValidation, &uTmp, TRUE /*DNS Name Length*/))
                        {
                            // Err msg by called func.
                        
                            // As in comupter management we do not pop-up here
                            // but we fix the found flag to be FALSE 
                            fServerNameFoundInCommandLine = FALSE;

                            break;
                        }
                        
			      	    bstrCommandLineServerName = psz;

                        //
                        // we will also check if the explictly inserted Server Name 
                        // is the local Server Name. This check will be done in one place 
                        // the selected readed server name (Command line or Stream)
                        // 

                    }
                    else // the case of argV[2] == "/FAX=" only => LocalMachine
                    {
				        bstrCommandLineServerName = L""; //just to be sure - the default
                    }
			    }
			    else // "/FAX=LocalMachine"
			    {
				    bstrCommandLineServerName = L""; //just to be sure - the default
			    }
			    break;
		    }
        } //if /FAX= was not found bstrCommandLineServerName stays L""


        //
        // free resources
        //
        GlobalFree(argV);

    }

	
    //
    // C. Derived Server name from the results
    // =======================================
    //

    //
    // When there is no command line explicitly request for server name
    //
    // or
    //
    // when we are not allowed to take the command data and to use it 
    // to override the straem server name 
    //
    // just then the server is taken from the stream
    //
	
    ATLASSERT (0 == m_bstrServerName.Length()); 

    if ( 
          (!fServerNameFoundInCommandLine)
        ||
          (!m_fAllowOverrideServerName) 
       ) 
    {
		//
        // We should take the stream server name
        //

        if (NULL != wcszPersistStreamServerName)
        {
            if ( 0 != wcscmp( wcszPersistStreamServerName , g_szLocalMachine )  )
		    {                    
                m_bstrServerName = wcszPersistStreamServerName;
		    }
		    else //LocalMachine
		    {
			    m_bstrServerName = L""; //Just to be sure
		    }
        }
        else
        {
            // not a regular case: 
            // for example can occur while version inconsitancy 
            // and no command line /FAX= server name instruction 
            m_bstrServerName = L""; //Just to be sure this is actually the default
        }
    }
    else
    {
        //
        // We should take the command line server name
        //

        m_bstrServerName = bstrCommandLineServerName; 
    }

    //
    // Checks if the explictly inserted Server Name 
    // is the local Server Name 
    //
	if (m_bstrServerName.Length() > 0 )
	{
		if ( IsLocalServerName(m_bstrServerName.m_str) )
		{
			DebugPrintEx( DEBUG_MSG,
			_T("The computer name %ws is the same as the name of the current managed server."),m_bstrServerName.m_str);
        
			m_bstrServerName = L"";
		}
	}
    

    //
    // We do not check here if the server is on the net 
    // and if fax is installed and running there 
    //

	
    //
    // D. Update FaxServer and FaxServerNode DisplayName with the name 
    // retrieved during the load process
    // =======================================
    //

    ATLASSERT( m_pNode);
    CFaxServerNode * pFaxServerNode = (CFaxServerNode *)m_pNode;
    ATLASSERT( pFaxServerNode);
    

	hRc = pFaxServerNode->UpdateServerName(m_bstrServerName); 
    if (S_OK != hRc)
    {
        DebugPrintEx(DEBUG_MSG,_T("Out of memory - fail to UpdateServerName."));
        
        return hRc; //E_OUTOFMEMORY;
    }
    
    
    hRc = pFaxServerNode->InitDetailedDisplayName();
    if (S_OK != hRc)
    {
        DebugPrintEx(DEBUG_MSG,_T("Out of memory - fail to InitDetailedDisplayName."));
        
        return hRc; //E_OUTOFMEMORY;
    }

    pFaxServerNode->SetIsLaunchedFromSavedMscFile();


    ATLASSERT (S_OK == hRc);
	return hRc;

}


/////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapin::Save(IStream *pStm, BOOL /*fClearDirty*/)
{
    DEBUG_FUNCTION_NAME( _T("CSnapin::Save"));
	HRESULT hRc = S_OK;
    
    UINT uiVersion = PERISISTENCE_VERSION;

	ATLASSERT( NULL != pStm );
    
    //
    // Write the version 
    //
    hRc = pStm->Write((void *)&uiVersion, sizeof(uiVersion), 0);
    if( FAILED( hRc ) )
    {
        DebugPrintEx( DEBUG_ERR,
			_T("pStm->Write(&uiVersion). (hRc: %08X)"), hRc);

        return STG_E_CANTSAVE;
    }

    //
    // Write Allow-to-override machine-name flag to the stream 
    //
    hRc = pStm->Write((void *)&m_fAllowOverrideServerName, sizeof(m_fAllowOverrideServerName), 0);
    if( FAILED( hRc ) )
    {
        DebugPrintEx( DEBUG_ERR,
			_T("pStm->Write(&uiVersion. (hRc: %08X)"), hRc);

        return STG_E_CANTSAVE;
    }

    //
    // Write the Server Name length
    //    
    LPCWSTR wcszMachineName;
    if ( 0 == m_bstrServerName.Length() ) // m_bstrServerName == L"" -> LocalMachine
    {
        wcszMachineName = g_szLocalMachine; // m_bstrServerName = L"LocalMachine"  
    }
    else 
    {
        wcszMachineName = m_bstrServerName;
    }
    DWORD dwLen = (::wcslen (wcszMachineName) + 1) * sizeof (WCHAR);

	hRc = pStm->Write ((void *)&dwLen, sizeof(DWORD), NULL);
	if ( FAILED(hRc) )
	{
        DebugPrintEx( DEBUG_ERR,
			_T("Fail to Write server name length to stream. (hRc: %08X)"), hRc);

        return STG_E_CANTSAVE;
	}
    
    //
    // Write the Server Name 
    //
	hRc = pStm->Write ((void *)wcszMachineName, dwLen, NULL);
	if ( FAILED (hRc) )
	{
        DebugPrintEx( DEBUG_ERR,
			_T("Fail to Write server name to stream. (hRc: %08X)"), hRc);

        return STG_E_CANTSAVE;
	}
    
    ATLASSERT( S_OK == hRc);
    return hRc;

}

STDMETHODIMP CSnapin::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ATLASSERT(pcbSize);

    ULISet32(*pcbSize, (DNS_MAX_NAME_BUFFER_LENGTH * sizeof(WCHAR)) + (2 * sizeof(UINT)) + 1);

    return S_OK;
}



/*
 -  CSnapin::GetSizeMax
 -
 *  Purpose:
 *      Checks the object for changes since it was last saved.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
STDMETHODIMP CSnapin::IsDirty()
{
    // Always save / Always dirty.
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\device.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Device.cpp                                             //
//                                                                         //
//  DESCRIPTION   : Fax Server MMC node creation.                          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 22 1999 yossg   Create                                         //
//      Dec  1 1999 yossg   Change totaly for new mockup version 0.7       //
//      Dec  6 1999 yossg   add  FaxChangeState functionality              //
//      Dec 12 1999 yossg   add  OnPropertyChange functionality            //
//      Aug  3 2000 yossg   Add Device status real-time notification       //
//      Oct 17 2000 yossg                                                  //
//                          Windows XP                                     //
//      Feb 14 2001 yossg   Add Manual Receive support                     //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include <FaxMMC.h>
#include "Device.h"
#include "Devices.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "ppFaxDeviceGeneral.h"

#include "InboundRoutingMethods.h" 

#include "FaxMMCPropertyChange.h"

#include "Icons.h"

#include "oaidl.h"

//Old Num (also in comet) C0548D62-1B45-11d3-B8C0-00104B3FF735
/////////////////////////////////////////////////////////////////////////////
// {3115A19A-6251-46ac-9425-14782858B8C9}
static const GUID CFaxDeviceNodeGUID_NODETYPE = FAXSRV_DEVICE_NODETYPE_GUID;

const GUID*     CFaxDeviceNode::m_NODETYPE        = &CFaxDeviceNodeGUID_NODETYPE;
const OLECHAR*  CFaxDeviceNode::m_SZNODETYPE      = FAXSRV_DEVICE_NODETYPE_GUID_STR;
const CLSID*    CFaxDeviceNode::m_SNAPIN_CLASSID  = &CLSID_Snapin;

CColumnsInfo CFaxDeviceNode::m_ColsInfo;


CLIPFORMAT CFaxDeviceNode::m_CFPermanentDeviceID = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_DEVICE_ID);
CLIPFORMAT CFaxDeviceNode::m_CFFspGuid = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_FSP_GUID);
CLIPFORMAT CFaxDeviceNode::m_CFServerName = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_SERVER_NAME);
DWORD   CFaxDeviceNode::GetDeviceID()     
{ 
	return m_dwDeviceID; 
}

/*
 -  CFaxDeviceNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxDeviceNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    SCODE hRc;

    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::InsertColumns"));

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_FAX_COL_HEAD, FXS_WIDE_COLUMN_WIDTH}, 
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    if (hRc != S_OK)
    {
        DebugPrintEx(DEBUG_ERR,
            _T("m_ColsInfo.InsertColumnsIntoMMC"));

        goto Cleanup;
    }

Cleanup:
    return(hRc);
}


/*
 -  CFaxDeviceNode::PopulateScopeChildrenList
 -
 *  Purpose:
 *      Create the Fax Device Inbound Routing Methods node
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 *		Actually it is the last OLE error code that ocoured 
 *      during processing this method.
 */
HRESULT CFaxDeviceNode::PopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::PopulateScopeChildrenList"));
    HRESULT             hRc = S_OK; 

    CFaxInboundRoutingMethodsNode * pMethods = NULL;

    //
    // Prepare IConsoleNameSpace for case of failure
    //
    ATLASSERT(m_pComponentData);
    ATLASSERT( ((CSnapin*)m_pComponentData)->m_spConsole );
    CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace( ((CSnapin*)m_pComponentData)->m_spConsole );
    ATLASSERT( spConsoleNameSpace );

    //
    // Fax InboundRoutingMethods Node
    //
    pMethods = new CFaxInboundRoutingMethodsNode(this, m_pComponentData);
    if (!pMethods)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Out of memory. (hRc: %08X)"),
			hRc);
        goto Error;
    }
  	else
	{
        pMethods->InitParentNode(this);

        pMethods->SetIcons(IMAGE_METHOD_ENABLE, IMAGE_METHOD_ENABLE);

        hRc = pMethods->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_METHODS);
		    goto Error;
        }

        hRc = AddChild(pMethods, &pMethods->m_scopeDataItem);
		if (FAILED(hRc))
		{
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to add the methods node. (hRc: %08X)"),
			    hRc);
			NodeMsgBox(IDS_FAILTOADD_METHODS);
            goto Error;
		}
	}

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pMethods ) 
    {
        if (0 != pMethods->m_scopeDataItem.ID )
        {
            HRESULT hr = spConsoleNameSpace->DeleteItem(pMethods->m_scopeDataItem.ID, TRUE);
            if (hr != S_OK) // can be only E_UNEXPECTED [MSDN]
            {
                DebugPrintEx(
                     DEBUG_ERR,
                     TEXT("spConsoleNameSpace->DeleteItem() Failed - Unexpected error. (hRc: %08X)"),
                     hr);
                ATLASSERT(FALSE);
            }
        }
        delete pMethods;    
        pMethods = NULL;    
    }

    // Empty the list of all Devices added before the one who failed
    m_ScopeChildrenList.RemoveAll();

    m_bScopeChildrenListPopulated = FALSE;

Exit:
    return hRc;
}
/*
 -  CFaxDeviceNode::GetResultPaneColInfo
 -
 *  Purpose:
 *      Return the text for specific column
 *      Called for each column in the result pane
 *
 *  Arguments:
 *      [in]    nCol - column number
 *
 *  Return:
 *      String to be displayed in the specific column
 */
LPOLESTR CFaxDeviceNode::GetResultPaneColInfo(int nCol)
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::GetResultPaneColInfo"));
    HRESULT hRc = S_OK;

    int iCount;
    WCHAR buff[FXS_MAX_RINGS_LEN+1];
    UINT uiResourceId = 0;

    m_buf.Empty();

    switch (nCol)
    {
    case 0:
            //
            // Name
            //
            if (!m_bstrDisplayName)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrDisplayName."));
                goto Error;
            }
            else
            {
                return (m_bstrDisplayName);
            }
            break;

    case 1:
            //
            // Receive
            //            
            if (m_fManualReceive)
            {
                uiResourceId = IDS_DEVICE_MANUAL;
            }
            else
            {
                uiResourceId = (m_fAutoReceive ? IDS_DEVICE_AUTO : IDS_FXS_NO);
            }
                        
            if (!m_buf.LoadString(_Module.GetResourceInstance(), uiResourceId) )
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to load string for receive value."));

                goto Error;
            }
            else
            {
                return (m_buf);
            }
            break;

    case 2:
            //
            // Send
            //            
            uiResourceId = (m_fSend ? IDS_FXS_YES : IDS_FXS_NO);
                        
            if (!m_buf.LoadString(_Module.GetResourceInstance(), uiResourceId) )
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to load string for send value."));

                goto Error;
            }
            else
            {
                return (m_buf);
            }
            break;

    case 3:
            //
            // Status
            //
            if ( m_dwStatus != 0)
            {
                if ( m_dwStatus & FAX_DEVICE_STATUS_SENDING)
                {
                    if ( m_dwStatus & FAX_DEVICE_STATUS_RECEIVING)
                    {
                        //Sending & Receiving
                        uiResourceId = IDS_DEVICE_STATUS_REC_AND_SEND;
                    }
                    else
                    {
                        //Sending only
                        uiResourceId = IDS_DEVICE_STATUS_SENDING;
                    }
                } 
                else if ( m_dwStatus & FAX_DEVICE_STATUS_RECEIVING)
                {
                    // Receiving
                    uiResourceId = IDS_DEVICE_STATUS_RECEIVING;
                } 
                else if ( m_dwStatus & FAX_DEVICE_STATUS_POWERED_OFF)
                {
                    // Powered Off
                    uiResourceId = IDS_DEVICE_STATUS_POWERED_OFF;
                }
                else
                {
					DebugPrintEx(
						DEBUG_ERR,
						TEXT("Un supported status."));

                    ATLASSERT(FALSE); //non supported bit 
					
					goto Error;
                }
            }
            else //Idle
            {
                uiResourceId = IDS_DEVICE_STATUS_IDLE;
            } //end of m_dwStatus bitwise checks

        
        
            if (!m_buf.LoadString(_Module.GetResourceInstance(), uiResourceId) )
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to load string for receive value."));

                goto Error;
            }
            else
            {
                return (m_buf);
            }
            break;
            
    case 4:
            //
            // Rings
            //
            iCount = swprintf(buff, L"%ld", m_dwRings);
    
            if( iCount <= 0 )
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to read member - m_dwRings."));
                goto Error;
            }
            else
            {
                m_buf = buff;
                return (m_buf);
            }
            break;

    case 5:
            //
            // Provider
            //            
            if (!m_bstrProviderName)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrProviderName."));
                goto Error;
            }
            else
            {
                return (m_bstrProviderName);
            }
            break;

    case 6:
            //
            // Description
            //
            if (!m_bstrDescription)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrDescription."));
                goto Error;
            }
            else
            {
                return (m_bstrDescription);
            }
            break;

    default:
            ATLASSERT(0); // "this number of column is not supported "
            return(L"");

    } // endswitch (nCol)

Error:
    return(L"???");

}


/*
 -  CFaxDeviceNode::CreatePropertyPages
 -
 *  Purpose:
 *      Called when creating a property page of the object
 *
 *  Arguments:
 *      [in]    lpProvider - The property sheet
 *      [in]    handle     - Handle for notification
 *      [in]    pUnk       - Pointer to the data object
 *      [in]    type       - CCT_* (SCOPE, RESULT, ...)
 *
 *  Return:
 *      OLE error code
 */

HRESULT
CFaxDeviceNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                    LONG_PTR                handle,
                                    IUnknown                *pUnk,
                                    DATA_OBJECT_TYPES       type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::CreatePropertyPages"));
    HRESULT hRc = S_OK;


    ATLASSERT(lpProvider);
    ATLASSERT(type == CCT_RESULT || type == CCT_SCOPE);

    m_pFaxDeviceGeneral = NULL;    

    //
    // General
    //
    m_pFaxDeviceGeneral = new CppFaxDeviceGeneral(
												 handle,
                                                 this,
                                                 m_pParentNode,
                                                 m_dwDeviceID,
                                                 _Module.GetResourceInstance());

	if (!m_pFaxDeviceGeneral)
	{
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
        goto Error;
	}
	
    hRc = m_pFaxDeviceGeneral->InitRPC();	
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to call RPC to init property page for the General tab. (hRc: %08X)"),
			hRc);
        goto Error;
    }

    hRc = lpProvider->AddPage(m_pFaxDeviceGeneral->Create());
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add property page for General Tab. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != m_pFaxDeviceGeneral ) 
    {
        delete  m_pFaxDeviceGeneral;    
        m_pFaxDeviceGeneral = NULL;    
    }

Exit:
    return hRc;
}


/*
 -  CFaxDeviceNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxDeviceNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // Display verbs that we support:
    // 1. Properties
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    //
    // We want the default verb to be Properties
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    return hRc;
}


/*
 -  CFaxDeviceNode::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDeviceNode::InitRPC( PFAX_PORT_INFO_EX * pFaxDeviceConfig )
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::InitRPC"));
    
    ATLASSERT(NULL == (*pFaxDeviceConfig) );
    
    HRESULT        hRc        = S_OK;
    DWORD          ec         = ERROR_SUCCESS;

    CFaxServer *   pFaxServer = NULL;
    
    //
    // get RPC Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
	// Retrieve the Device configuration
	//
    if (!FaxGetPortEx(pFaxServer->GetFaxServerHandle(), 
                      m_dwDeviceID, 
                      &( *pFaxDeviceConfig))) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get device configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(*pFaxDeviceConfig);
	
    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get device configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);

    //Important!!!
    *pFaxDeviceConfig = NULL;

    NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}

/*
 -  CFaxDeviceNode::Init
 -
 *  Purpose:
 *      Initiates the private members 
 *      from configuration structure pointer.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDeviceNode::Init( PFAX_PORT_INFO_EX  pFaxDeviceConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::Init"));
        
    ATLASSERT(NULL != (pFaxDeviceConfig) );
    
    HRESULT        hRc        = S_OK;
    
    //
    // Constant device members
    //
    m_dwDeviceID       = pFaxDeviceConfig->dwDeviceID;


    m_bstrDisplayName  = pFaxDeviceConfig->lpctstrDeviceName;
    if (!m_bstrDisplayName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
	
    m_bstrProviderName = pFaxDeviceConfig->lpctstrProviderName;
    if (!m_bstrProviderName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    m_bstrProviderGUID = pFaxDeviceConfig->lpctstrProviderGUID;
    if (!m_bstrProviderGUID)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    //
    // Varied device members
    //
    hRc = UpdateMembers(pFaxDeviceConfig);
    if (S_OK != hRc)
    {
        goto Exit; //dbgmsg + MSgBox by called Func.
    }
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    NodeMsgBox(IDS_MEMORY);
    
Exit:
    return (hRc);
}


/*
 -  CFaxDeviceNode::UpdateMembers
 -
 *  Purpose:
 *      Initiates the private members 
 *      from configuration structure pointer.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDeviceNode::UpdateMembers( PFAX_PORT_INFO_EX  pFaxDeviceConfig )
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::UpdateMembers"));
    
    HRESULT        hRc        = S_OK;
    
    // func. must been called just
    // after a call to retreive config structure 
    // was done successfully!
    ATLASSERT(NULL != pFaxDeviceConfig );
    
    // We are not supporting change of DeviceID
    ATLASSERT(m_dwDeviceID == pFaxDeviceConfig->dwDeviceID);
    
    if(!pFaxDeviceConfig->lptstrDescription)
    {
        m_bstrDescription = L"";
    }
    else
    {
        m_bstrDescription = pFaxDeviceConfig->lptstrDescription;
    }
    if (!m_bstrDescription)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    m_fSend            = pFaxDeviceConfig->bSend;
    
    switch (pFaxDeviceConfig->ReceiveMode)
    {
        case FAX_DEVICE_RECEIVE_MODE_OFF:    // Do not answer to incoming calls
            m_fAutoReceive     = FALSE;
            m_fManualReceive   = FALSE;
            break;

        case FAX_DEVICE_RECEIVE_MODE_AUTO:   // Automatically answer to incoming calls after dwRings rings
            m_fAutoReceive     = TRUE;
            m_fManualReceive   = FALSE;
            break;

        case FAX_DEVICE_RECEIVE_MODE_MANUAL: // Manually answer to incoming calls - only FaxAnswerCall answers the call
            m_fManualReceive   = TRUE;
            m_fAutoReceive     = FALSE;
            break;
        
        default:
            ATLASSERT(FALSE);
		    
            DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Unexpected m_pFaxDeviceConfig->ReceiveMode"));

    }
    
    m_dwRings          = pFaxDeviceConfig->dwRings;

    m_dwStatus         = pFaxDeviceConfig->dwStatus;        

    m_bstrCsid         = pFaxDeviceConfig->lptstrCsid;
    if (!m_bstrCsid)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    m_bstrTsid         = pFaxDeviceConfig->lptstrTsid;
    if (!m_bstrTsid)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
	
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    //Important!!!
    //FaxFreeBuffer by called Func.
    //(*pFaxDeviceConfig) = NULL;

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    NodeMsgBox(IDS_MEMORY);
    
Exit:
    return (hRc);
}


/*
 -  CFaxDeviceNode::UpdateDeviceStatus
 -
 *  Purpose:
 *      UpdateDeviceStatus 
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDeviceNode::UpdateDeviceStatus( DWORD  dwDeviceStatus )
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::UpdateDeviceStatus"));

    m_dwStatus = dwDeviceStatus;
    
    if ( m_dwStatus & FAX_DEVICE_STATUS_POWERED_OFF)
    {
        SetIcons(IMAGE_DEVICE_POWERED_OFF, IMAGE_DEVICE_POWERED_OFF);
    }
    else
    {
        SetIcons(IMAGE_DEVICE, IMAGE_DEVICE);
    }

    return S_OK;
}

/*
 -  CFaxDeviceNode::RefreshAllViews
 -
 *  Purpose:
 *      Call IResultData::UpdateItem
 *
 *  Arguments:
 *      [in]    pConsole - the console interface
 *
 *  Return:
 */
HRESULT
CFaxDeviceNode::RefreshAllViews(IConsole *pConsole)
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::RefreshAllViews"));
    HRESULT     hRc = S_OK;
    
    ATLASSERT( pConsole != NULL );

    hRc = pConsole->UpdateAllViews(NULL, NULL, NULL);

    if ( FAILED(hRc) )
    {
		DebugPrintEx(
			DEBUG_ERR,
            _T("Fail to UpdateAllViews, hRc=%08X"),
            hRc);
        NodeMsgBox(IDS_REFRESH_VIEW);
    }
    return hRc;
}


/*
 -  CFaxDeviceNode::DoRefresh
 -
 *  Purpose:
 *      Refresh the object .
 *      First it gets data structure, inits members 
 *      and frees the structure. 
 *      The last thing is to refresh the view.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxDeviceNode::DoRefresh()
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::DoRefresh"));
    HRESULT              hRc              = S_OK;
    
    PFAX_PORT_INFO_EX    pFaxDeviceConfig = NULL ;

    //
    // Get the Config. structure with FaxGetPortEx
    //
    hRc = InitRPC(&pFaxDeviceConfig);
    if (FAILED(hRc))
    {
        //DebugPrint and MsgBox by called func.
        
        //to be safe actually done by InitRPC on error.
        pFaxDeviceConfig = NULL;
        
        goto Error;
    }
    ATLASSERT(NULL != pFaxDeviceConfig);
    
    //
    // init members
    //    
    hRc = UpdateMembers(pFaxDeviceConfig);
    if (FAILED(hRc))
    {
        //DebugPrint and MsgBox by called func.
        goto Error;
    }

    //
    // Free Buffer - Important!!! 
    // == done on exit  ==
    //

    //
    // Refresh only this device's view
    //
    hRc = RefreshTheView();    
    if (FAILED(hRc))
    {
        //DebugPrint and MsgBox by called func.
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( FAILED(hRc) )
    {
    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to Refresh (hRc : %08X)"),
        hRc);
    }

Exit:
    if (NULL != pFaxDeviceConfig)
    {
        FaxFreeBuffer(pFaxDeviceConfig);
        pFaxDeviceConfig = NULL;
    }//any way function quits with memory allocation freed       

    return hRc;
}


/*
 -  CFaxDeviceNode::OnRefresh
 -
 *  Purpose:
 *      Called by MMC to refresh the object .
 *      First it gets data structure, inits members 
 *      and frees the structure. 
 *      Second thing is recursive refresh. 
 *      The third thing is to refresh the view.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxDeviceNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::OnRefresh"));

    return DoRefresh();
}

/*
 -  CFaxDeviceNode::UpdateMenuState
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateMenuState
 *      which only have one line inside it "return;" 
 *      This function implements an update for the check mark
 *      beside the Receive and the Send menus.
 *
 *  Arguments:

 *            [in]  id    - unsigned int with the menu IDM value
 *            [out] pBuf  - string 
 *            [out] flags - pointer to flags state combination unsigned int
 *
 *  Return:
 *      no return value - void function 
 */
void CFaxDeviceNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::UpdateMenuState"));

    UNREFERENCED_PARAMETER (pBuf); 
    
    ATLASSERT(m_fManualReceive && m_fAutoReceive); //plese see: "[yossg] Please notice" above.
    
    switch (id)
    {
        case IDM_FAX_DEVICE_SEND:
            *flags = (m_fSend ? MF_ENABLED | MF_CHECKED : MF_ENABLED | MF_UNCHECKED);
            break;
        case IDM_FAX_DEVICE_RECEIVE_AUTO: 
            *flags = (m_fAutoReceive ? MF_ENABLED | MF_CHECKED : MF_ENABLED | MF_UNCHECKED);   
            break;
        case IDM_FAX_DEVICE_RECEIVE_MANUAL: 
            *flags = (m_fManualReceive ? MF_ENABLED | MF_CHECKED : MF_ENABLED | MF_UNCHECKED);   
            break;
        default:
            break;
    }
    return;
}

/*
 -  CFaxDeviceNode::OnFaxReceive
 -
 *  Purpose:
 *      Called when Receive Faxes was pushed.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDeviceNode::OnFaxReceive (UINT nID, bool &bHandled, CSnapInObjectRootBase *pRoot)
{ 
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::OnFaxReceive"));
    HRESULT hRc = S_OK;
    
    // The check mark state 
    BOOL fNewState;
    
    
        
    if ( IDM_FAX_DEVICE_RECEIVE_AUTO == nID)
    {
        fNewState = !m_fAutoReceive;
    }
    else if (IDM_FAX_DEVICE_RECEIVE_MANUAL == nID)
    {
        fNewState = !m_fManualReceive;
    }
    else
    {
        ATLASSERT(FALSE);
        
        DebugPrintEx(
            DEBUG_ERR,
            _T("Unexpected function call. (hRc: %08X)"),
            hRc);

        hRc = E_UNEXPECTED;
        goto Exit;
    }

    hRc = FaxChangeState(nID, fNewState);
    if ( S_OK != hRc )
    {
        //DebugPrint in the function layer
        return S_FALSE;
    }

    //
    // Service succeded. now change member
    //
    // Update new state(s) done here by FaxChangeState;

    //
    // In case Manual Receive was taken we do not have to refresh the view
    // In such a case all devices are refreshed !!!
    //
    
Exit:
    return hRc; 
}

/*
 -  CFaxDeviceNode::OnFaxSend
 -
 *  Purpose:
 *      Called when Send Faxes was pushed.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDeviceNode::OnFaxSend(bool &bHandled, CSnapInObjectRootBase *pRoot)
{ 
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::OnFaxSend"));
    HRESULT hRc = S_OK;
    
    // The check mark state 
    BOOL fNewState;
    
    fNewState = !m_fSend;

    hRc = FaxChangeState(IDM_FAX_DEVICE_SEND, fNewState);
    if ( S_OK != hRc )
    {
        //DebugPrint in the function layer
        return S_FALSE;
    }

    //
    // Service succeded. now change member
    //
    m_fSend = fNewState;

    //
    // Refresh the view 
    //
    hRc = RefreshTheView(); 
    if ( S_OK != hRc )
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to RefreshTheView(). (hRc: %08X)"),
            hRc);
        
        goto Exit;
    }

Exit:
    return hRc; 
}

/*
 -  CFaxDeviceNode::FaxChangeState
 -
 *  Purpose:
 *      .
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDeviceNode::FaxChangeState(UINT uiIDM, BOOL fState)
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::FaxChangeState"));
	
    HRESULT            hRc        = S_OK;

    DWORD              ec         = ERROR_SUCCESS;
    CFaxServer *       pFaxServer = NULL;
    
    // check input
    ATLASSERT( 
               (IDM_FAX_DEVICE_RECEIVE == uiIDM) 
              || 
               (IDM_FAX_DEVICE_SEND_AUTO == uiIDM)
              ||
               (IDM_FAX_DEVICE_RECEIVE_MANUAL == uiIDM)
             );

    PFAX_PORT_INFO_EX  pFaxDeviceInfo = NULL;
    
    //
    // Get Configuration
    //

    // get RPC Handle  
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

	// Retrieve the Device configuration
    if (!FaxGetPortEx(pFaxServer->GetFaxServerHandle(), 
                      m_dwDeviceID, 
                      &pFaxDeviceInfo)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get device configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(pFaxDeviceInfo);

    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get device configuration."));

    //
    // Change State 
    //
    switch (uiIDM)
	{
	    case IDM_FAX_DEVICE_SEND:
		    
            pFaxDeviceInfo->bSend = fState;
		    break;

        case IDM_FAX_DEVICE_RECEIVE_AUTO:
		    
            pFaxDeviceInfo->ReceiveMode = 
                ( fState ? FAX_DEVICE_RECEIVE_MODE_AUTO : FAX_DEVICE_RECEIVE_MODE_OFF); 
		    break;

        case IDM_FAX_DEVICE_RECEIVE_MANUAL:
		    
            pFaxDeviceInfo->ReceiveMode = 
                ( fState ? FAX_DEVICE_RECEIVE_MODE_MANUAL : FAX_DEVICE_RECEIVE_MODE_OFF); 
		    break;

    }
    
    //
    // Set Configuration
    //
    if (!FaxSetPortEx(
                pFaxServer->GetFaxServerHandle(),
                m_dwDeviceID,
                pFaxDeviceInfo)) 
	{		
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to Set device configuration. (ec: %ld)"), 
			ec);

        if ( FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED == ec )
        {
            hRc = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            
            NodeMsgBox(IDS_ERR_DEVICE_LIMIT, MB_OK|MB_ICONEXCLAMATION);

            goto Exit;
        }
        
        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }
        
        goto Error;
    }

    //
    // Set members in cases of Receive
    //
    if ( uiIDM == IDM_FAX_DEVICE_RECEIVE_AUTO || uiIDM == IDM_FAX_DEVICE_RECEIVE_MANUAL)
    {
        if ( FAX_DEVICE_RECEIVE_MODE_MANUAL == pFaxDeviceInfo->ReceiveMode )
        {
            ATLASSERT(m_pParentNode);
            hRc = m_pParentNode->DoRefresh();
            if (S_OK != hRc)
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("Fail to call DoRefresh(). (hRc: %08X)"), 
                    hRc);
                
                goto Error;
            }
        }
        else
        {            
            hRc = DoRefresh();
            if ( FAILED(hRc) )
            {
                DebugPrintEx(
			        DEBUG_ERR,
			        _T("Fail to call DoRefresh. (hRc: %08X)"),
			        hRc);
    
            }
        }
    }

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to set device configuration."));
    
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
	
    NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    if ( NULL != pFaxDeviceInfo )
        FaxFreeBuffer(pFaxDeviceInfo);
    
    return hRc;
}

HRESULT
CFaxDeviceNode::RefreshTheView()
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::RefreshTheView"));
    HRESULT     hRc = S_OK;

    ATLASSERT( m_pComponentData != NULL );
    ATLASSERT( m_pComponentData->m_spConsole != NULL );

    CComPtr<IConsole> spConsole;
    spConsole = m_pComponentData->m_spConsole;
    CComQIPtr<IConsoleNameSpace,&IID_IConsoleNameSpace> spNamespace( spConsole );
    
    SCOPEDATAITEM*    pScopeData;

    //
    // Get the updated SCOPEDATAITEM
    //
    hRc = GetScopeData( &pScopeData );
    if (FAILED(hRc))
    {
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to get pScopeData. (hRc: %08X)"),
			hRc);
        goto Error;
    }

    //
    // This will force MMC to redraw the scope group node
    //
    hRc = spNamespace->SetItem( pScopeData );
    if (FAILED(hRc))
    {
       DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to set Item pScopeData. (hRc: %08X)"),
			hRc);

        goto Error;
    }
    ATLASSERT( S_OK != hRc);
    
    goto Exit;

Error:
    NodeMsgBox(IDS_FAIL2REFRESH_DEVICE);

Exit:
    return hRc;
}


/*
 +
 +
 *
 *  CFaxDeviceNode::FillData
 *
 *
 *   Override CSnapInItem::FillData for private cliboard formats
 *
 *
 *   Parameters
 *
 *   Return Values
 *
 -
 -
 */

HRESULT  CFaxDeviceNode::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::FillData"));
	
    HRESULT hr = DV_E_CLIPFORMAT;
	ULONG uWritten;


    if (cf == m_CFPermanentDeviceID)
	{
		DWORD dwDeviceID;
		dwDeviceID = GetDeviceID();
		hr = pStream->Write((VOID *)&dwDeviceID, sizeof(DWORD), &uWritten);
		return hr;
	}

	if (cf == m_CFFspGuid)
	{
		CComBSTR bstrGUID;
		bstrGUID = GetFspGuid();
		hr = pStream->Write((VOID *)(LPWSTR)bstrGUID, sizeof(WCHAR)*(bstrGUID.Length()+1), &uWritten);
		return hr;
	}

	if (cf == m_CFServerName)
	{
                ATLASSERT(GetRootNode());
		CComBSTR bstrServerName = ((CFaxServerNode *)GetRootNode())->GetServerName();
                if (!bstrServerName)
                {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Out of memory. Failed to load string."));
        
                    return E_OUTOFMEMORY;
                }
		hr = pStream->Write((VOID *)(LPWSTR)bstrServerName, sizeof(WCHAR)*(bstrServerName.Length()+1), &uWritten);
		return hr;
	}

	else 
        return CSnapInItemImpl<CFaxDeviceNode>::FillData(cf, pStream);
}


/*
 +
 +  CFaxDeviceNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxDeviceNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    _TCHAR topicName[MAX_PATH];
    
    _tcscpy(topicName, helpFile);
    
    _tcscat(topicName, _T("::/FaxS_C_ManDvices.htm"));
    
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(topicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, topicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\devices.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Devices.h                                              //
//                                                                         //
//  DESCRIPTION   : Header file for CFaxDevicesNode class                  //
//                  This is the "Fax" node in the scope pane.              //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 22 1999 yossg   create                                         //
//      Dec  1 1999 yossg   Change totaly for New Mockup (0.7)             //
//      Aug  3 2000 yossg   Add Device status real-time notification       //
//                          Windows XP                                     //
//      Feb 14 2001 yossg   Add Manual Receive support                     //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_DEVICES_H
#define H_DEVICES_H

#include "snapin.h"
#include "snpnscp.h" //#include "snpnode.h"

class CFaxDevicesAndProvidersNode;

class CFaxDevicesNode : public CNodeWithScopeChildrenList<CFaxDevicesNode, FALSE>
{
public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxDevicesNode, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxDevicesNode)
    END_SNAPINTOOLBARID_MAP()

    CFaxDevicesNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithScopeChildrenList<CFaxDevicesNode, FALSE>(pParentNode, pComponentData )
    {
        m_pFaxDevicesConfig               = NULL;
        m_dwNumOfDevices                  = FXS_ITEMS_NEVER_COUNTED;

        m_bIsCollectingDeviceNotification = FALSE;
    }

    ~CFaxDevicesNode()
    {
        if (m_pFaxDevicesConfig)
        {
            FaxFreeBuffer(m_pFaxDevicesConfig);
        }
    }

	//
	// get data from RPC 
	//
    HRESULT InitRPC();

	//
	// MMC functions
	//
    virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    // virtual
    HRESULT OnPropertyChange(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
    

    // virtual
    HRESULT OnRefresh(LPARAM arg,
                      LPARAM param,
                      IComponentData *pComponentData,
                      IComponent * pComponent,
                      DATA_OBJECT_TYPES type);

    void InitParentNode(CFaxDevicesAndProvidersNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    HRESULT DoRefresh();

    HRESULT InitDisplayName();

    HRESULT RepopulateScopeChildrenList();

    HRESULT UpdateDeviceStatusChange( DWORD dwDeviceId, DWORD dwNewStatus);

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);
private:
    
    static CColumnsInfo             m_ColsInfo;

    CFaxDevicesAndProvidersNode *   m_pParentNode;

    PFAX_PORT_INFO_EX               m_pFaxDevicesConfig;
    DWORD                           m_dwNumOfDevices;

    BOOL                            m_bIsCollectingDeviceNotification;

    HRESULT                         UpdateTheView();
};

typedef CNodeWithScopeChildrenList<CFaxDevicesNode, FALSE>
        CBaseFaxDevicesNode;


#endif  //H_DEVICES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\devices.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Devices.cpp                                            //
//                                                                         //
//  DESCRIPTION   : Fax Devices MMC node.                                  //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 22 1999 yossg   Create                                         //
//      Dec  1 1999 yossg   Change totaly for new mockup version 0.7       //
//      Aug  3 2000 yossg   Add Device status real-time notification       //
//      Oct 17 2000 yossg                                                  //
//                          Windows XP                                     //
//      Feb 14 2001 yossg   Add Manual Receive support                     //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "DevicesAndProviders.h"
#include "Devices.h"
#include "Device.h"

#include "FaxMMCPropertyChange.h"

#include "Icons.h"

#include "oaidl.h"


/////////////////////////////////////////////////////////////////////////////
// {E6246051-92B4-42d1-9EA4-A7FD132A63F0}
static const GUID CFaxDevicesNodeGUID_NODETYPE = 
{ 0xe6246051, 0x92b4, 0x42d1, { 0x9e, 0xa4, 0xa7, 0xfd, 0x13, 0x2a, 0x63, 0xf0 } };

const GUID*    CFaxDevicesNode::m_NODETYPE = &CFaxDevicesNodeGUID_NODETYPE;
const OLECHAR* CFaxDevicesNode::m_SZNODETYPE = OLESTR("E6246051-92B4-42d1-9EA4-A7FD132A63F0");
const CLSID*   CFaxDevicesNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxDevicesNode::m_ColsInfo;


/*
 -  CFaxDevicesNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxDevicesNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    HRESULT hRc = S_OK;
    DEBUG_FUNCTION_NAME( _T("CFaxDevicesNode::InsertColumns"));

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_DEVICES_COL1, FXS_WIDE_COLUMN_WIDTH},
        {IDS_DEVICES_COL2, AUTO_WIDTH},
        {IDS_DEVICES_COL3, AUTO_WIDTH},
        {IDS_DEVICES_COL4, AUTO_WIDTH},
        {IDS_DEVICES_COL5, AUTO_WIDTH},
        {IDS_DEVICES_COL6, AUTO_WIDTH},
        {IDS_DEVICES_COL7, AUTO_WIDTH},
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    CHECK_RETURN_VALUE_AND_PRINT_DEBUG (_T("m_ColsInfo.InsertColumnsIntoMMC"))

Cleanup:
    return(hRc);
}

/*
 -  CFaxDevicesNode::initRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDevicesNode::InitRPC(  )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxDevicesNode::InitRPC"));
    
    HRESULT      hRc        = S_OK;
    DWORD        ec         = ERROR_SUCCESS;

    CFaxServer * pFaxServer = NULL;


    //
    // get Fax Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

	//
	// Retrieve the fax devices configuration
	//
    if (!FaxEnumPortsEx(pFaxServer->GetFaxServerHandle(), 
                        &m_pFaxDevicesConfig,
                        &m_dwNumOfDevices)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get devices configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(m_pFaxDevicesConfig);
	ATLASSERT(FXS_ITEMS_NEVER_COUNTED != m_dwNumOfDevices);

    
    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get devices configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);

    //
    // allow refresh in case of failure
    //
    m_dwNumOfDevices = 0;

    NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}



/*
 -  CFaxDevicesNode::PopulateScopeChildrenList
 -
 *  Purpose:
 *      Create all the Fax Devices nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 *		Actually it is the last OLE error code that ocoured 
 *      during processing this method.
 */
HRESULT CFaxDevicesNode::PopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxDevicesNode::PopulateScopeChildrenList"));
    HRESULT            hRc        = S_OK; 

    CFaxServer     *   pFaxServer = NULL;    
    CFaxDeviceNode *   pDevice;
    DWORD              i;

    //
    // Get the Config. structure 
    //
    hRc = InitRPC();
    if (FAILED(hRc))
    {
        //DebugPrint and MsgBox by called func.
        
        //to be safe actually done by InitRPC on error.
        m_pFaxDevicesConfig = NULL;
        
        goto Exit; //!!!
    }
    ATLASSERT(NULL != m_pFaxDevicesConfig);
    
    for ( i = 0; i < m_dwNumOfDevices; i++ )
    {
            pDevice = NULL;

            pDevice = new CFaxDeviceNode(
                                        this, 
                                        m_pComponentData); 
            if (!pDevice)
            {
                hRc = E_OUTOFMEMORY;
                NodeMsgBox(IDS_MEMORY);
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. (hRc: %08X)"),
			        hRc);
                goto Error;
            }
            else
            {                        
                hRc = pDevice->Init( &m_pFaxDevicesConfig[i]);
                if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to Init() device members. (hRc: %08X)"),
			            hRc);
		            // NodeMsgBox(IDS_FAILTOADD_DEVICES); by called func.
                    goto Error;
	            }


	            pDevice->InitParentNode(this);

                //
                // Get correct icon
                //
                if ( m_pFaxDevicesConfig[i].dwStatus & FAX_DEVICE_STATUS_POWERED_OFF)
                {
                    pDevice->SetIcons(IMAGE_DEVICE_POWERED_OFF, IMAGE_DEVICE_POWERED_OFF);
                }
                else
                {
                    pDevice->SetIcons(IMAGE_DEVICE, IMAGE_DEVICE);
                }
        
	            hRc = AddChild(pDevice, &pDevice->m_scopeDataItem);
	            if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to add device to the scope pane. (hRc: %08X)"),
			            hRc);
		            NodeMsgBox(IDS_FAILTOADD_DEVICES);
                    goto Error;
	            }
                else
                {
                    pDevice = NULL;
                }
            }
    }
    
    //
    // Create the Server Device changes notification window
    //
    if (!m_bIsCollectingDeviceNotification)
    {
        pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
        ATLASSERT(pFaxServer);
        
        //
        // set pointer to device node
        // Try to create the window 
        // and Register to Event Notifications
        //
        hRc = pFaxServer->RegisterForDeviceNotifications(this);
        if (S_OK != hRc)
        {		    
            DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to RegisterForDeviceNotifications"));
            
            //
            // Populate should succeed here
            //
            hRc = S_OK;

            goto Exit;
        }

        //
        // Update boolean member
        //
        m_bIsCollectingDeviceNotification = TRUE;

        DebugPrintEx(
			DEBUG_MSG,
			_T("Succeed to create Device Status Server Event notification window"));
   }
    
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    //
    //Get Rid
    //
    {    
        //from the last one 
        if ( NULL != pDevice ) //(if new succeeded)
        {
            delete  pDevice;    
        }

        //from all the previous (if there are)
        int j = m_ScopeChildrenList.GetSize();
        for (int i = 0; i < j; i++)
        {
            pDevice = (CFaxDeviceNode *)m_ScopeChildrenList[0];

            hRc = RemoveChild(pDevice);
            if (FAILED(hRc))
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("Fail to delete device. (hRc: %08X)"), 
                    hRc);
                goto Error;
            }
            delete pDevice;
        }

        // Empty the list of all Devices added before the one who failed
        // already done one by one inside RemoveChild
        // m_ScopeChildrenList.RemoveAll(); 
    
        m_bScopeChildrenListPopulated = FALSE;
    }
Exit:
    return hRc;
}

/*
 -  CFaxDevicesNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxDevicesNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // Refersh
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 
    
    return hRc;
}

/*
 -  CFaxDevicesNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxDevicesNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxDevicesNode::OnRefresh"));

    HRESULT hRc = S_OK;

    SCOPEDATAITEM*          pScopeData;
    CComPtr<IConsole>       spConsole;

	if (FXS_ITEMS_NEVER_COUNTED != m_dwNumOfDevices)//already Expanded before.
	{
        //
	    // Repopulate Scope Children List
	    //
        hRc = RepopulateScopeChildrenList();
        if (S_OK != hRc)
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to RepopulateScopeChildrenList(). (hRc: %08X)"),
			    hRc);
            // Done by called func. NodeMsgBox(FAIL2REPOPULATE_DEVICES_LIST);

            goto Exit;
        }
	}
    else //never expanded before.
	{
		DebugPrintEx(
			DEBUG_MSG,
			_T("User call refresh before expand node's children."));
        //continue to reselect the node.
	}

    //
	// Get the updated SCOPEDATAITEM
	//
    hRc = GetScopeData( &pScopeData );
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to get pScopeData. (hRc: %08X)"),
			hRc);
        NodeMsgBox(IDS_FAIL2REDRAW_DEVICESNODE);

        goto Exit;
    }

    //
	// This will force MMC to redraw the scope node
	//
    spConsole = m_pComponentData->m_spConsole;
    ATLASSERT(spConsole);
	
    hRc = spConsole->SelectScopeItem( pScopeData->ID );
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to select scope Item. (hRc: %08X)"),
			hRc);
        NodeMsgBox(IDS_FAIL2REDRAW_DEVICESNODE);
    }

Exit:
    return hRc;
}


/*
 -  CFaxDevicesNode::UpdateTheView
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */
HRESULT
CFaxDevicesNode::UpdateTheView()
{
    DEBUG_FUNCTION_NAME( _T("CFaxDevicesNode::UpdateTheView()"));
    HRESULT hRc = S_OK;
    CComPtr<IConsole> spConsole;

    ATLASSERT( m_pComponentData != NULL );
    ATLASSERT( m_pComponentData->m_spConsole != NULL );

    hRc = m_pComponentData->m_spConsole->UpdateAllViews( NULL, NULL, NULL);
    if (S_OK != hRc)
    {
        DebugPrintEx( DEBUG_ERR,
		    _T("Unexpected error - Fail to UpdateAllViews."));
        NodeMsgBox(IDS_FAIL2REFRESH_THEVIEW);        
    }

    return hRc;
}


/*
 -  CFaxDevicesNode::DoRefresh
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */
HRESULT
CFaxDevicesNode::DoRefresh()
{
    DEBUG_FUNCTION_NAME( _T("CFaxDevicesNode::DoRefresh()"));
    HRESULT hRc = S_OK;
    CComPtr<IConsole> spConsole;

    //
    // Repopulate childs
    //
    hRc = RepopulateScopeChildrenList();
    if (S_OK != hRc)
    {
        DebugPrintEx( DEBUG_ERR,
		    _T("Fail to RepopulateScopeChildrenList."));
        //NodeMsgBox by called func.
        
        goto Exit;
    }

    //
    // Refresh Result pane views
    //
    hRc = UpdateTheView();
    if (FAILED(hRc))
    {
        DebugPrintEx( DEBUG_ERR,
		    _T(" Fail to UpdateTheView."));
        //NodeMsgBox by called func.        
    }

Exit:
    return hRc;
}


/*
 -  CFaxDevicesNode::RepopulateScopeChildrenList
 -
 *  Purpose:
 *      RePopulateScopeChildrenList
 *
 *  Arguments:
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxDevicesNode::RepopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxDevicesNode::RepopulateScopeChildrenList"));
    HRESULT                 hRc = S_OK;

    CFaxDeviceNode *        pChildNode ;

    CComPtr<IConsole> spConsole;
    ATLASSERT(m_pComponentData);

    spConsole = ((CSnapin*)m_pComponentData)->m_spConsole;
    ATLASSERT( spConsole != NULL );
    
    CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);

    //
    // Remove device objects from list
    //
    for (int i = 0; i < m_ScopeChildrenList.GetSize(); i++)
    {
        pChildNode = (CFaxDeviceNode *)m_ScopeChildrenList[i];

        hRc = spConsoleNameSpace->DeleteItem(pChildNode->m_scopeDataItem.ID, TRUE);
        if (FAILED(hRc))
        {
            DebugPrintEx(DEBUG_ERR,
                _T("Fail to delete device. (hRc: %08X)"), 
                hRc);
            goto Error;
        }
	delete pChildNode;
    }

    //
    // Empty the list object itself and change it's status
    //
    m_ScopeChildrenList.RemoveAll();

    m_bScopeChildrenListPopulated = FALSE;

    //
    // Rebuild the list
    //
    hRc = PopulateScopeChildrenList();
    if (FAILED(hRc))
    {
        DebugPrintEx(DEBUG_ERR,
            _T("Fail to populate Devices. (hRc: %08X)"), 
            hRc);
        goto Error;
    }

    m_bScopeChildrenListPopulated = TRUE;

    ATLASSERT(S_OK == hRc);
    DebugPrintEx(DEBUG_MSG,
        _T("Succeeded to Re Populate Devices. (hRc: %08X)"), 
        hRc);
    goto Cleanup;
Error:
   NodeMsgBox(IDS_FAIL2REPOPULATE_DEVICES);

Cleanup:
    return hRc;
}


/*
 -  CFaxDevicesNode::UpdateDeviceStatusChange
 -
 *  Purpose:
 *      Update a specific device status or disable its Manual Receive option. 
 *      If device not found repopulate all devices.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDevicesNode::UpdateDeviceStatusChange( DWORD dwDeviceId, DWORD dwNewStatus)
{
    DEBUG_FUNCTION_NAME(_T("CFaxDevicesNode::UpdateDeviceStatusChange"));

    HRESULT            hRc              = S_OK;
    
    CFaxDeviceNode *   pDeviceNode      = NULL;

	DWORD              dwNodeDeviceID   = 0;

    BOOL               fIsDeviceFound   = FALSE;


    for (int i = 0; i < m_ScopeChildrenList.GetSize(); i++)
    {
        pDeviceNode = (CFaxDeviceNode *)m_ScopeChildrenList[i];
		dwNodeDeviceID = pDeviceNode->GetDeviceID();

        if ( dwNodeDeviceID == dwDeviceId )
        {
            fIsDeviceFound = TRUE;
    
            hRc = pDeviceNode->UpdateDeviceStatus(dwNewStatus);
            ATLASSERT(S_OK == hRc);

            break;
        }
    }

    if (fIsDeviceFound) //update single device view.
    {
        //
        // Refresh Result pane views
        //
        hRc = pDeviceNode->RefreshTheView();
        if (FAILED(hRc))
        {
            DebugPrintEx( DEBUG_ERR,
		        _T("Failed to RefreshTheView."));
            //NodeMsgBox by called func.        
        }
    }
    else //(!fIsDeviceFound) >>> RepopulateScopeChildrenList
    {
        DebugPrintEx(DEBUG_MSG,
            _T(">>>> Notification for a non peresented device was acheived.\n Retreived updated device list.\n"));
    
        hRc = DoRefresh(); 
        if (FAILED(hRc))
        {
            DebugPrintEx( DEBUG_ERR,
		        _T("Failed to DoRefresh."));
            //NodeMsgBox by called func.        
        }
    }

    
    
    return hRc;
}


/*
 -  CFaxDevicesNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDevicesNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxDevicesNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                    IDS_DISPLAY_STR_DEVICESNODE))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}
/////////////////////////////////////////////////////////////////////////////
/*
 +
 +
 *
 *  CFaxDevicesNode::OnPropertyChange
 *
 *
 *  In our implementation, this method gets called when the 
 *  MMCN_PROPERTY_CHANGE
 *  Notify message is sent for this node.
 *
 *  When the snap-in uses the MMCPropertyChangeNotify function to notify it's
 *  views about changes, MMC_PROPERTY_CHANGE is sent to the snap-in's
 *  IComponentData and IComponent implementations.
 *
 *  For each device property page, when property page submitted the notification passed to 
 *  to the Devices parent node. This node Refresh all devices if needed (when manual Receive was taken by a device)
 *  or try to locate specific device by its ID from current children list.
 *
 *  Prameters
 *
 *      arg
 *      [in] TRUE if the property change is for a scope pane item.
 *
 *      lParam
 *      This is the param passed into MMCPropertyChangeNotify.
 *
 *
 *  Return Values
 *
 -
 -
 */
//////////////////////////////////////////////////////////////////////////////
HRESULT CFaxDevicesNode::OnPropertyChange(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::OnPropertyChange"));

    HRESULT hRc = S_OK;
    CComPtr<IConsole>   spConsole;

    CFaxDevicePropertyChangeNotification * pNotification;

    //
    // Encode Property Change Notification data
    //
    pNotification = reinterpret_cast<CFaxDevicePropertyChangeNotification *>(param);
    ATLASSERT( pNotification );
    ATLASSERT( DeviceFaxPropNotification == pNotification->enumType );

    BOOL fIsDeviceFound = FALSE;

    if ( !pNotification->fIsToNotifyAdditionalDevices)
    {
        //
        // try to find the device and refresh it only
        // from all the scope children list
        //
        DebugPrintEx(
			DEBUG_MSG,
			_T("Try to locate device by ID"));

        CFaxDeviceNode * pDevice;
        
        int j = m_ScopeChildrenList.GetSize();
        for (int i = 0; i < j; i++)
        {
            pDevice = (CFaxDeviceNode *)m_ScopeChildrenList[i];
            ATLASSERT( pDevice);

            if ( pDevice->GetDeviceID() == pNotification->dwDeviceID )
            {
                DebugPrintEx(
			        DEBUG_MSG,
			        _T("Succeed to locate device by ID"));
                
                fIsDeviceFound = TRUE;
                
                hRc = pDevice->DoRefresh();
                if (S_OK != hRc)
                {
                    DebugPrintEx(
			            DEBUG_ERR,
			            _T("Failed to call OnRefresh()"));

                    //NodeMsgBox called if needed by the called func 

                    goto Exit;
                }

                break;
            }
            pDevice = NULL;
        }
    }
        
    if ( pNotification->fIsToNotifyAdditionalDevices  || !fIsDeviceFound)
    {
        DebugPrintEx(
			DEBUG_MSG,
			_T("Decide to refresh all devices"));

        //
        // Refresh all devices 
        //
        hRc = DoRefresh();  
        if (S_OK != hRc)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Failed to call DoRefresh()"));

            //NodeMsgBox called if needed by the called func 

            goto Exit;
        }
    }
    

Exit:    
    
    //
    // Anyway
    //
    delete pNotification;
    
    
    return hRc;
}

/*
 +
 +  CFaxDevicesNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxDevicesNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    _TCHAR topicName[MAX_PATH];
    
    _tcscpy(topicName, helpFile);
    
    _tcscat(topicName, _T("::/FaxS_C_ManDvices.htm"));
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(topicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, topicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\device.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Device.h                                               //
//                                                                         //
//  DESCRIPTION   : Header file for CFaxDeviceNode class                   //
//                  This is node apears both in the scope pane and         //
//                  with full detailes in the result pane.                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 22 1999 yossg   Create                                         //
//      Dec  1 1999 yossg   Change totaly for New Mockup (0.7)             //
//      Dec  6 1999 yossg   add  FaxChangeState functionality              //
//      Dec 12 1999 yossg   add  OnPropertyChange functionality            //
//      Aug  3 2000 yossg   Add Device status real-time notification       //
//                          Windows XP                                     //
//      Feb 14 2001 yossg   Add Manual Receive support                     //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_DEVICE_H
#define H_DEVICE_H
//#pragma message( "H_DEVICE_H" )

#include "snapin.h"
#include "snpnscp.h"


class CFaxDevicesNode;
class CppFaxDeviceGeneral;
//class CNodeWithScopeChildrenList;

class CFaxDeviceNode : public CNodeWithScopeChildrenList<CFaxDeviceNode, FALSE>
{
public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxDeviceNode, FALSE)
        SNAPINCOMMAND_ENTRY(IDM_FAX_DEVICE_SEND,      OnFaxSend)
        SNAPINCOMMAND_RANGE_ENTRY(IDM_FAX_DEVICE_RECEIVE_AUTO, IDM_FAX_DEVICE_RECEIVE_MANUAL, OnFaxReceive)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxDeviceNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_DEVICE_MENU)

    CFaxDeviceNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithScopeChildrenList<CFaxDeviceNode, FALSE>(pParentNode, pComponentData )
    {
        m_dwDeviceID       = 0;
        m_fSend            = FALSE;
        m_fAutoReceive     = FALSE;
        m_fManualReceive   = FALSE;
        m_dwRings          = 0;
        m_dwStatus         = 0;        
    }

    ~CFaxDeviceNode()
    {
    }

    //
    // Menu item handlers
    //
    HRESULT OnFaxReceive  (UINT nID, bool &bHandled, CSnapInObjectRootBase *pRoot);
    HRESULT OnFaxSend     (bool &bHandled, CSnapInObjectRootBase *pRoot);
    
    HRESULT FaxChangeState(UINT uiIDM, BOOL fState);

    
    virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    LPOLESTR GetResultPaneColInfo(int nCol);


    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        IUnknown* pUnk,
        DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }
             
    // virtual
    HRESULT OnRefresh(LPARAM arg,
                      LPARAM param,
                      IComponentData *pComponentData,
                      IComponent * pComponent,
                      DATA_OBJECT_TYPES type);

    void InitParentNode(CFaxDevicesNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    void    UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags);
 
    HRESULT DoRefresh();

    HRESULT RefreshAllViews(IConsole *pConsole);
    
    HRESULT RefreshTheView();

    HRESULT Init( PFAX_PORT_INFO_EX  pFaxDeviceConfig );

    HRESULT UpdateMembers( PFAX_PORT_INFO_EX  pFaxDeviceConfig );

    HRESULT UpdateDeviceStatus( DWORD  dwDeviceStatus );

    DWORD   GetDeviceID();

	
    //
    // Get methods for CLIPFORMAT FillData
    //
	CComBSTR   GetFspGuid()
	{
		return m_bstrProviderGUID;
	}

    //
    // FillData
    //
    STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream);

    //
    // Clipboard Formats
    //
    static CLIPFORMAT m_CFPermanentDeviceID;
    static CLIPFORMAT m_CFFspGuid;
    static CLIPFORMAT m_CFServerName;

    //
    // inline parent ptr
    //
    inline CFaxDevicesNode * GetParent() /*const*/ 
    { 
        return m_pParentNode;
    };

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);


private:
    
    //
    // Config Structure member
    //
    DWORD                   m_dwDeviceID;
    CComBSTR                m_bstrDescription;
    CComBSTR                m_bstrProviderName;
    CComBSTR                m_bstrProviderGUID;
    BOOL                    m_fSend;
    BOOL                    m_fAutoReceive;
    BOOL                    m_fManualReceive;
    DWORD                   m_dwRings;
    CComBSTR                m_bstrCsid;
    CComBSTR                m_bstrTsid;

    DWORD                   m_dwStatus;

    CComBSTR                m_bstrServerName;

	//
	// get data from RPC 
	//
    /*
     * (in use during refresh only)
     * (private to avoid usage by out functions )
     */
    HRESULT InitRPC( PFAX_PORT_INFO_EX * pFaxDeviceConfig );

    
    CComBSTR                m_buf;

    CppFaxDeviceGeneral *   m_pFaxDeviceGeneral;

    static CColumnsInfo     m_ColsInfo;

    CFaxDevicesNode *       m_pParentNode;
};


#endif  //H_DEVICE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\devicesandproviders.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : AllFaxDevices.cpp                                      //
//                                                                         //
//  DESCRIPTION   : Fax Server MMC node creation.                          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 22 1999 yossg   Create                                         //
//      Dec  9 1999 yossg   Reorganize Populate ChildrenList,              //
//                          and the call to InitDisplayName                //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "DevicesAndProviders.h"
#include "Devices.h"
#include "Providers.h" 


//here to #include Dialog H files

#include "Icons.h"

#include "oaidl.h"


/////////////////////////////////////////////////////////////////////////////
// {CCC43AB5-C788-46df-9268-BB96CA5E3DAC}
static const GUID CFaxDevicesAndProvidersNodeGUID_NODETYPE = 
{ 0xccc43ab5, 0xc788, 0x46df, { 0x92, 0x68, 0xbb, 0x96, 0xca, 0x5e, 0x3d, 0xac } };

const GUID*    CFaxDevicesAndProvidersNode::m_NODETYPE = &CFaxDevicesAndProvidersNodeGUID_NODETYPE;
const OLECHAR* CFaxDevicesAndProvidersNode::m_SZNODETYPE = OLESTR("CCC43AB5-C788-46df-9268-BB96CA5E3DAC");
const CLSID*   CFaxDevicesAndProvidersNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxDevicesAndProvidersNode::m_ColsInfo;

/*
 -  CFaxDevicesAndProvidersNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxDevicesAndProvidersNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    SCODE hRc;

    DEBUG_FUNCTION_NAME( _T("CFaxDevicesAndProvidersNode::InsertColumns"));

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_FAX_COL_HEAD, FXS_LARGE_COLUMN_WIDTH}, 
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    if (hRc != S_OK)
    {
        DebugPrintEx(DEBUG_ERR,_T("m_ColsInfo.InsertColumnsIntoMMC"));
        goto Cleanup;
    }

Cleanup:
    return(hRc);
}


/*
 -  CFaxDevicesAndProvidersNode::PopulateScopeChildrenList
 -
 *  Purpose:
 *      Create all the Fax Devices nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 *		Actually it is the last OLE error code that ocoured 
 *      during processing this method.
 */
HRESULT CFaxDevicesAndProvidersNode::PopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxDevicesAndProvidersNode::PopulateScopeChildrenList"));
    HRESULT             hRc         = S_OK; 

    CFaxDevicesNode *   pDevices    = NULL;
    CFaxProvidersNode * pProviders  = NULL;

    //
    // Fax Devices
    //
    pDevices = new CFaxDevicesNode(this, m_pComponentData);
    if (!pDevices)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Out of memory"));
        goto Error;
    }
	else
	{
        pDevices->InitParentNode(this);
        pDevices->SetIcons(IMAGE_DEVICE, IMAGE_DEVICE);

        hRc = pDevices->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display devices node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_DEVICES);
		    goto Error;
        }

        hRc = AddChild(pDevices, &pDevices->m_scopeDataItem);
		if (FAILED(hRc))
		{
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to add Devices node. (hRc: %08X)"),
			    hRc);
			NodeMsgBox(IDS_FAILTOADD_DEVICES);
            goto Error;
		}
	}

    //
    // Fax Providers
    //
    pProviders = new CFaxProvidersNode(this, m_pComponentData);
    if (!pProviders)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Out of memory"));
        goto Error;
    }
	else
	{
        pProviders->InitParentNode(this);

        pProviders->SetIcons(IMAGE_FSP, IMAGE_FSP);

        hRc = pProviders->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display providers node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_PROVIDERS);
		    goto Error;
        }

        hRc = AddChild(pProviders, &pProviders->m_scopeDataItem);
		if (FAILED(hRc))
		{
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to add providers node. (hRc: %08X)"),
			    hRc);
			NodeMsgBox(IDS_FAILTOADD_PROVIDERS);
            goto Error;
		}
	}

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pDevices ) 
    {
        if (0 != pDevices->m_scopeDataItem.ID )
        {    
            HRESULT hr = RemoveChild(pDevices);
            if (FAILED(hr))
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("Fail to RemoveChild() devices node from node list. (hRc: %08X)"), 
                    hr);
            }
        }
        delete  pDevices;    
        pDevices = NULL;    
    }
    if ( NULL != pProviders ) 
    {
        if (0 != pProviders->m_scopeDataItem.ID )
        {    
            HRESULT hr = RemoveChild(pProviders);
            if (FAILED(hr))
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("Fail to RemoveChild() Providers node from node list. (hRc: %08X)"), 
                    hr);
            }
        }
        delete  pProviders;    
        pProviders = NULL;    
    }

     
    // Empty the list
    //m_ScopeChildrenList.RemoveAll(); done step by step from RemoveChild

    m_bScopeChildrenListPopulated = FALSE;

Exit:
    return hRc;
}




/*
 -  CFaxDevicesAndProvidersNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxDevicesAndProvidersNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{

    HRESULT hRc = S_OK;
    
    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 

    
    return hRc;
}


/*
 -  CFaxDevicesAndProvidersNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDevicesAndProvidersNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxDevicesAndProvidersNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                    IDS_DISPLAY_STR_DEVICESANDPROVIDERSNODE))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}

/*
 +
 +  CFaxDevicesAndProvidersNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxDevicesAndProvidersNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    _TCHAR topicName[MAX_PATH];
    
    _tcscpy(topicName, helpFile);
    
    _tcscat(topicName, _T("::/FaxS_C_ManDvices.htm"));
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(topicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, topicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

///////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\devicesandproviders.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DevicesAndProviders.h                                  //
//                                                                         //
//  DESCRIPTION   : Header file for CFaxDevicesAndProvidersNode class      //
//                  This is the "Fax" node in the scope pane.              //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 22 1999 yossg   Create                                         //
//      Dec  9 1999 yossg   Reorganize Populate ChildrenList,              //
//                          and the call to InitDisplayName                //
//                                                                         //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_DEVICESANDPROVIDERS_H
#define H_DEVICESANDPROVIDERS_H
//#pragma message( "H_DEVICESANDPROVIDERS_H" )


#include "snapin.h"
#include "snpnscp.h"

class CFaxServerNode;

class CFaxDevicesAndProvidersNode : public CNodeWithScopeChildrenList<CFaxDevicesAndProvidersNode, FALSE>
{
public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxDevicesAndProvidersNode, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxDevicesAndProvidersNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_SNAPIN_MENU)

    CFaxDevicesAndProvidersNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithScopeChildrenList<CFaxDevicesAndProvidersNode, FALSE>(pParentNode, pComponentData )
    {
    }

    ~CFaxDevicesAndProvidersNode()
    {
    }

    virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    void InitParentNode(CFaxServerNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    HRESULT InitDisplayName();

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:
    
    static CColumnsInfo    m_ColsInfo;

    CFaxServerNode *       m_pParentNode;
};



#endif  //H_DEVICESANDPROVIDERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\dlgnewdevice.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DlgNewDevice.h                                          //
//                                                                         //
//  DESCRIPTION   : Header file for the CDlgNewFaxOutboundDevice class.     //
//                  The class implement the dialog for new Group.          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan  3 2000 yossg   Create                                         //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef DLGNEWOUTDEVICE_H_INCLUDED
#define DLGNEWOUTDEVICE_H_INCLUDED

/////////////////////////////////////////////////////////////////////////////
// CDlgNewFaxOutboundDevice
class CFaxServer;

class CDlgNewFaxOutboundDevice :
    public CDialogImpl<CDlgNewFaxOutboundDevice>
{
public:
	
    CDlgNewFaxOutboundDevice(CFaxServer * pFaxServer);

    ~CDlgNewFaxOutboundDevice();

    enum { IDD = IDD_DLGNEWDEVICE };

BEGIN_MSG_MAP(CDlgNewFaxOutboundDevice)
    MESSAGE_HANDLER   (WM_INITDIALOG, OnInitDialog)
    
    COMMAND_ID_HANDLER(IDOK,          OnOK)
    COMMAND_ID_HANDLER(IDCANCEL,      OnCancel)
    
    MESSAGE_HANDLER( WM_CONTEXTMENU,  OnHelpRequest)
    MESSAGE_HANDLER( WM_HELP,         OnHelpRequest)

    NOTIFY_HANDLER  (IDC_DEVICE_LISTVIEW,  LVN_ITEMCHANGED,  OnListViewItemChanged)
END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK    (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    HRESULT InitDevices(DWORD dwNumOfDevices, LPDWORD lpdwDeviceID, BSTR bstrGroupName);
    HRESULT InitAssignedDevices(DWORD dwNumOfDevices, LPDWORD lpdwDeviceID);
    HRESULT InitAllDevices( );
    
    HRESULT InitDeviceNameFromID(DWORD dwDeviceID, BSTR * pbstrDeviceName);
    HRESULT InsertDeviceToList(UINT uiIndex, DWORD dwDeviceID);

    LRESULT OnListViewItemChanged (int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    //
    // Methods
    //
    VOID            EnableOK(BOOL fEnable);

    //
    // members
    //
    LPDWORD         m_lpdwAllDeviceID;
    DWORD           m_dwNumOfAllDevices;
    
    LPDWORD         m_lpdwAssignedDeviceID;
    DWORD           m_dwNumOfAssignedDevices;

    DWORD           m_dwNumOfAllAssignedDevices;

    CComBSTR        m_bstrGroupName;
    
    //
    // Controls
    //
    CListViewCtrl   m_DeviceList;

	CFaxServer * m_pFaxServer;
};

#endif // DLGNEWOUTDEVICE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\dlgconfirmpassword.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DlgConfirmPassword.h                                   //
//                                                                         //
//  DESCRIPTION   : Header file for the CDlgConfirmPassword class.         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jul 27 2000 yossg   Create                                         //
//                                                                         //
//		Windows XP                                                         //
//      Feb 11 2001 yossg   Changed to include Credentials and Confirm     //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef DLG_CONFIRM_PASSWORD_INCLUDED
#define DLG_CONFIRM_PASSWORD_INCLUDED

/////////////////////////////////////////////////////////////////////////////
// CDlgConfirmPassword

class CDlgConfirmPassword :
             public CDialogImpl<CDlgConfirmPassword>
{
public:
    CDlgConfirmPassword();

    ~CDlgConfirmPassword();

    enum { IDD = IDD_CONFIRM_PASSWORD };

BEGIN_MSG_MAP(CDlgConfirmPassword)
    MESSAGE_HANDLER   ( WM_INITDIALOG, OnInitDialog)
    
    COMMAND_ID_HANDLER( IDOK,          OnOK)
    COMMAND_ID_HANDLER( IDCANCEL,      OnCancel)
    
    MESSAGE_HANDLER( WM_CONTEXTMENU,   OnHelpRequest)
    MESSAGE_HANDLER( WM_HELP,          OnHelpRequest)

    COMMAND_HANDLER( IDC_SMTP_USERNAME_EDIT, EN_CHANGE,  OnTextChanged)
    COMMAND_HANDLER( IDC_SMTP_PASSWORD_EDIT,    EN_CHANGE,  OnPasswordChanged)
    COMMAND_HANDLER( IDC_CONFIRM_PASSWORD_EDIT, EN_CHANGE,  OnPasswordChanged)
END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK    (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnPasswordChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);    
    LRESULT OnTextChanged (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    HRESULT InitCredentialsDlg(BSTR bstrUserName);

    inline BOOL IsPasswordModified()
    {
        return m_fIsPasswordChangedAndConfirmed;
    }

    inline  WCHAR * GetPassword() 
    {     
        return m_bstrPassword.m_str;
    }
    
    inline const CComBSTR&  GetUserName() 
    {   
        return  m_bstrUserName; 
    }

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    //
    // Methods
    //
    VOID   EnableOK(BOOL fEnable);

    BOOL   IsValidData(
                     BSTR bstrUserName, 
                     BSTR bstrPassword, 
                     /*[OUT]*/int *pCtrlFocus);

    //
    // Controls
    //
    CEdit     m_UserNameBox;
    CEdit     m_PasswordBox;
    CEdit     m_ConfirmPasswordBox;

    //
    // members for data
    //
    BOOL      m_fIsPasswordDirty;
    BOOL      m_fIsConfirmPasswordDirty;
    BOOL      m_fIsPasswordChangedAndConfirmed;
    
    BOOL      m_fIsDialogInitiated;

    CComBSTR  m_bstrUserName;
    CComBSTR  m_bstrPassword;
};

#endif // DLG_CONFIRM_PASSWORD_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\dlgnewdevice.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DlgNewDevice.cpp                                        //
//                                                                         //
//  DESCRIPTION   : The CDlgNewFaxOutboundDevice class implements the       //
//                  dialog for additon of new Group.                       //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan  3 2000 yossg    Create                                        //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "dlgNewDevice.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "dlgutils.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgNewFaxOutboundDevice

CDlgNewFaxOutboundDevice::CDlgNewFaxOutboundDevice(CFaxServer * pFaxServer)
{
    m_lpdwAllDeviceID        = NULL;
    m_dwNumOfAllDevices      = 0;

    m_lpdwAssignedDeviceID   = NULL;    
    m_dwNumOfAssignedDevices = 0;
    
    ATLASSERT(pFaxServer);
    m_pFaxServer = pFaxServer;
}

CDlgNewFaxOutboundDevice::~CDlgNewFaxOutboundDevice()
{
    if (NULL != m_lpdwAllDeviceID)
        delete[] m_lpdwAllDeviceID;

    if (NULL != m_lpdwAssignedDeviceID)
        delete[] m_lpdwAssignedDeviceID;
}

/*
 -  CDlgNewFaxOutboundDevice::initDevices
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call,
 *      and current assined devices own parameters
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CDlgNewFaxOutboundDevice::InitDevices(DWORD dwNumOfDevices, LPDWORD lpdwDeviceID, BSTR bstrGroupName)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundDevice::InitDevices"));
    
    HRESULT hRc = S_OK;
    
    m_bstrGroupName = bstrGroupName;
    if (!m_bstrGroupName )
    {
        DebugPrintEx(DEBUG_ERR,
			_T("Out of memory - Failed to Init m_bstrGroupName. (ec: %0X8)"), hRc);
        //MsgBox by Caller Function
        hRc = E_OUTOFMEMORY;
        goto Exit;
    }
        
        
    hRc = InitAssignedDevices(dwNumOfDevices, lpdwDeviceID);
    if (FAILED(hRc))
    {
        DebugPrintEx(DEBUG_ERR,
			_T("Failed to InitAssignDevices. (ec: %0X8)"), hRc);
        //MsgBox by Caller Function
        goto Exit;
    }
    
    hRc = InitAllDevices( );
    if (FAILED(hRc))
    {
        DebugPrintEx(DEBUG_ERR,
			_T("Failed to InitRPC. (ec: %0X8)"), hRc);
        //MsgBox by Caller Function
        goto Exit;
    }
    

    if ( m_dwNumOfAllDevices  <   m_dwNumOfAssignedDevices)
    {
        DebugPrintEx(DEBUG_MSG,
			_T("+++m_dwNumOfAllDevices <m_dwNumOfAssignedDevices.+++ (ec: %0X8)"), hRc);
        
        hRc = E_UNEXPECTED;
        //MsgBox by Caller Function
        
        goto Exit;
    }
    ATLASSERT(S_OK == hRc);
    
Exit:    
    return hRc;
}

/*
 -  CDlgNewFaxOutboundDevice::initAllDevices
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CDlgNewFaxOutboundDevice::InitAllDevices(  )
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundDevice::InitAllDevices"));
    
    HRESULT      hRc        = S_OK;
    DWORD        ec         = ERROR_SUCCESS;

    PFAX_OUTBOUND_ROUTING_GROUP     pFaxGroupsConfig;
    DWORD                           dwNumOfGroups;
    DWORD        i;  //index
    BOOL         fFound     = FALSE;
    
    //
    // get Fax Handle
    //       
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Retrieve the Outbound Groups configuration
    //
    if (!FaxEnumOutboundGroups(m_pFaxServer->GetFaxServerHandle(), 
                        &pFaxGroupsConfig,
                        &dwNumOfGroups)) 
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get groups configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
    //For max verification
    ATLASSERT(pFaxGroupsConfig);


    for ( i =0; i < dwNumOfGroups; i++  )
    {
        ATLASSERT(NULL != pFaxGroupsConfig);

        if(0 == wcscmp(ROUTING_GROUP_ALL_DEVICES, pFaxGroupsConfig->lpctstrGroupName) )
        {
            fFound = TRUE; 
        }
        else
        {
            pFaxGroupsConfig++;
        }
    }
    
    if(fFound)
    {
        //
        // init m_dwNumOfAllDevices
        //
        m_dwNumOfAllDevices  = pFaxGroupsConfig->dwNumDevices;

        //
        // init m_lpdwAllDeviceID
        //
        if (0 < m_dwNumOfAllDevices)
        {
            m_lpdwAllDeviceID = new DWORD[m_dwNumOfAllDevices];   
            if (NULL == m_lpdwAllDeviceID)
            {
                DebugPrintEx(
			        DEBUG_ERR,
			        _T("Error allocating %ld device ids"),
                    m_dwNumOfAllDevices);
                ec = ERROR_NOT_ENOUGH_MEMORY;
                goto Error;
            }                
            memcpy(m_lpdwAllDeviceID, pFaxGroupsConfig->lpdwDevices, sizeof(DWORD)*m_dwNumOfAllDevices) ;
        }
        else
        {
            DebugPrintEx( DEBUG_MSG, _T("++Empty List++ List of All Devices found to be currrently empty."));
            m_lpdwAllDeviceID = NULL;
        }
    }
    else
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("UNEXPECTED ERROR - ALL DEVICES group was not found."));
        ec = ERROR_BAD_UNIT;
        goto Error;
    }
    
    
    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to init all devices list."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);

   //DlgMsgBox -- NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}


/*
 -  CDlgNewFaxOutboundDevice::initAssignedDevices
 -
 *  Purpose:
 *      Initiates the list from given params.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CDlgNewFaxOutboundDevice::InitAssignedDevices(DWORD dwNumOfDevices, LPDWORD lpdwDeviceID)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundDevice::InitAssignedDevices"));
    
    HRESULT      hRc        = S_OK;

    //
    // init m_dwNumOfAssignedDevices
    //
    m_dwNumOfAssignedDevices  = dwNumOfDevices;

    //
    // init m_lpdwAssignedDeviceID
    //
    if (0 < m_dwNumOfAssignedDevices)
    {
        m_lpdwAssignedDeviceID = new DWORD[m_dwNumOfAssignedDevices];    
        if (NULL == m_lpdwAssignedDeviceID)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Error allocating %ld device ids"),
                m_dwNumOfAssignedDevices);
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }                
        memcpy(m_lpdwAssignedDeviceID, lpdwDeviceID, sizeof(DWORD)*m_dwNumOfAssignedDevices) ;
    }
    else
    {
        DebugPrintEx( DEBUG_MSG, _T("List of Assigned devices found to be empty."));
        m_lpdwAssignedDeviceID = NULL;
    }
    
    return hRc;
}

/*
 +  CDlgNewFaxOutboundDevice::OnInitDialog
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgNewFaxOutboundDevice::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundDevice::OnInitDialog"));
    HRESULT hRc = S_OK;    
    
    BOOL    fAssignedDeviceFound;
    BOOL    fAllAssignedDevicesFound;

    LPDWORD lpdwDevice;
    LPDWORD lpdwAssignedDevice;

    DWORD   tmp;
    UINT    uiFoundIndex;

    
    RECT    Rect;

    //
    // Attach controls
    //
    m_DeviceList.Attach(GetDlgItem(IDC_DEVICE_LISTVIEW));
        
    m_DeviceList.GetClientRect(&Rect);
    m_DeviceList.InsertColumn(1, NULL, LVCFMT_LEFT, (Rect.right-Rect.left), 0);
    
    //
    // Fill the Availble Device List
    //
    fAllAssignedDevicesFound = FALSE;    
    uiFoundIndex             = 0;
    lpdwDevice               = &m_lpdwAllDeviceID[0];

    for ( DWORD i = 0; i < m_dwNumOfAllDevices; i++ )
    {
        if(!fAllAssignedDevicesFound)
        {

            fAssignedDeviceFound =FALSE;
            lpdwAssignedDevice = &m_lpdwAssignedDeviceID[0];
            tmp =0;

            for ( DWORD j = 0; j < m_dwNumOfAssignedDevices; j++  )
            {
                // TO DO create more incremental search here also

                ATLASSERT(NULL != lpdwDevice);
                ATLASSERT(NULL != lpdwAssignedDevice);
                
                if( *lpdwDevice == *lpdwAssignedDevice )
                {              
                    fAssignedDeviceFound = TRUE;

                    //Skip this device - It was already assigned
                    lpdwDevice++;

                    if ( ++tmp == m_dwNumOfAssignedDevices )
                        fAllAssignedDevicesFound = TRUE;
                    break;
                }
                else
                {
                    lpdwAssignedDevice++;
                }
            }
            if (!fAssignedDeviceFound)
			{
                InsertDeviceToList(uiFoundIndex++ , *lpdwDevice);
				lpdwDevice++;
			}
        } 
        else  //all assigned devices found 
        {
            ATLASSERT(lpdwDevice);
            
            //insert the rest of all devices to list
            InsertDeviceToList(uiFoundIndex++ , *lpdwDevice);
            lpdwDevice++;
        }
    }
    
    EnableOK(FALSE);
    return 1;  // Let the system set the focus
}


/*
 -  CDlgNewFaxOutboundDevice::InsertDeviceToList
 -
 *  Purpose:
 *      Populate Avaliable devices list and discovers the devices names
 *
 *  Arguments:
 *      [in] uiIndex - index 
 *      [in] dwDeviceID - device ID  
 *
 *  Return:
 *      OLE error code
 */
HRESULT CDlgNewFaxOutboundDevice::InsertDeviceToList(UINT uiIndex, DWORD dwDeviceID)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundDevice::InsertDeviceToList"));
    
    HRESULT    hRc              = S_OK;
    CComBSTR   bstrDeviceName   = NULL;

    //
    // Discover Device Name
    //
    hRc = InitDeviceNameFromID(dwDeviceID, &bstrDeviceName);
    if (FAILED(hRc))
    {
       //DebugPrint by Called Func.
       goto Exit;
    }

    
    //
    // Insert New line in the list
    //
    m_DeviceList.InsertItem(uiIndex, bstrDeviceName);
    m_DeviceList.SetItemData(uiIndex, dwDeviceID);

Exit:
    return hRc;
}


/*
 -  CDlgNewFaxOutboundDevice::InitDeviceNameFromID
 -
 *  Purpose:
 *      Transslate Device ID to Device Name and insert the data to
 *      m_bstrDeviceName
 *
 *  Arguments:
 *      [in]  dwDeviceID        - device ID
 *      [out] bstrDeviceName    - device Name
 *
 *  Return:
 *      OLE error message 
 */
HRESULT CDlgNewFaxOutboundDevice::InitDeviceNameFromID(DWORD dwDeviceID, BSTR * pbstrDeviceName)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRuleNode::GetDeviceNameFromID"));
    DWORD          ec         = ERROR_SUCCESS;
    HRESULT        hRc        = S_OK;
    
    PFAX_PORT_INFO_EX    pFaxDeviceConfig = NULL ;
    
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Retrieve the Device configuration
    //
    if (!FaxGetPortEx(m_pFaxServer->GetFaxServerHandle(), 
                      dwDeviceID, 
                      &pFaxDeviceConfig)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get device configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(pFaxDeviceConfig);
    
    
    //
	// Main thing - retrieve the Device Name
	//
    *pbstrDeviceName = SysAllocString(pFaxDeviceConfig->lpctstrDeviceName);
    if ( !(*pbstrDeviceName) )
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }
	
    
    
    ATLASSERT(ec == ERROR_SUCCESS);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get device name."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);

    pFaxDeviceConfig = NULL;

    if (ERROR_BAD_UNIT != ec)
	{
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("Device Not Found - Fail to discover device name from device ID."));
	}
	else
	{
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to discover device name from device ID. (ec: %ld)"),
			ec);
	}
    hRc = HRESULT_FROM_WIN32(ec);
    
    
Exit:
    if (NULL != pFaxDeviceConfig)
    {
        FaxFreeBuffer(pFaxDeviceConfig);
    }       
	

    return hRc; 
}


/*
 +  CDlgNewFaxOutboundDevice::OnOK
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgNewFaxOutboundDevice::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundDevice::OnOK"));
    HRESULT       hRc                  = S_OK;
    DWORD         ec                   = ERROR_SUCCESS;

    DWORD         dwIndex;
    UINT          uiSelectedCount;
    int           nItem;

    LPDWORD		  lpdwNewDeviceID;
    LPDWORD       lpdwTmp;
    
    FAX_OUTBOUND_ROUTING_GROUP  FaxGroupConfig;

    //
    // Step 1: Create the new devices combined list
    //
    ATLASSERT( m_DeviceList.GetSelectedCount() > 0);
    ATLASSERT( m_dwNumOfAssignedDevices >= 0);
    
    uiSelectedCount = m_DeviceList.GetSelectedCount();
    m_dwNumOfAllAssignedDevices = (DWORD)uiSelectedCount 
                                           + m_dwNumOfAssignedDevices;

    lpdwNewDeviceID = new DWORD[m_dwNumOfAllAssignedDevices]; 
    if (NULL == lpdwNewDeviceID)
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Error allocating %ld device ids"),
            m_dwNumOfAllAssignedDevices);
        ec = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }

    lpdwTmp = &lpdwNewDeviceID[0];

    DebugPrintEx( DEBUG_MSG,
		_T("    NumOfAllAssignedDevices = %ld \n"), m_dwNumOfAllAssignedDevices);
    //
    // Already assigned part (can be zero size)
    //
    if (m_dwNumOfAssignedDevices > 0)
    {
        memcpy( lpdwNewDeviceID, m_lpdwAssignedDeviceID, sizeof(DWORD)*m_dwNumOfAssignedDevices) ;
        lpdwTmp = lpdwTmp + (int)m_dwNumOfAssignedDevices;
    }
    
    //
    // New devices to assign part (cannot be zero size)
    //
    if (uiSelectedCount > 0)
    {
        nItem = -1; 
        for (dwIndex = m_dwNumOfAssignedDevices; dwIndex < m_dwNumOfAllAssignedDevices; dwIndex++)
        {
            nItem = m_DeviceList.GetNextItem(nItem, LVNI_SELECTED);
            ATLASSERT(nItem != -1);

            *lpdwTmp = (DWORD)m_DeviceList.GetItemData(nItem);
            DebugPrintEx( DEBUG_MSG,
	            _T("    NewDeviceID = %ld.   DeviceOrder=%ld \n"), *lpdwTmp, (dwIndex+1));
            ++lpdwTmp;

        }
    }
    else
    {
        ATLASSERT(0);  //Never reach here
        DlgMsgBox(this, IDS_SELECT_ITEM);
        return 0;
    }

    
    //
    // Step 2: insert the new Id list into the group via RPC call
    //

    //
    // init the group fields and insert the new DeviceIdList  
    //
    ZeroMemory (&FaxGroupConfig, sizeof(FAX_OUTBOUND_ROUTING_GROUP));

    FaxGroupConfig.dwSizeOfStruct   = sizeof(FAX_OUTBOUND_ROUTING_GROUP);
	FaxGroupConfig.lpctstrGroupName = m_bstrGroupName;
    FaxGroupConfig.dwNumDevices     = m_dwNumOfAllAssignedDevices;
	
    //FaxGroupConfig.Status - actually neglected by the service
	FaxGroupConfig.Status           = FAX_GROUP_STATUS_ALL_DEV_VALID;

    FaxGroupConfig.lpdwDevices      = lpdwNewDeviceID;
    
    //
    // get RPC Handle
    //   
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // inject the new device list
    //
    if (!FaxSetOutboundGroup(
                m_pFaxServer->GetFaxServerHandle(),
                &FaxGroupConfig)) 
	{		
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to set the group with new device list. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }
        
        goto Error;
    }


    //
    // Step 3: Close the dialog
    //
    ATLASSERT(S_OK == hRc && ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("The group was added successfully."));

    EndDialog(wID);

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
	
    PageErrorEx(IDS_FAIL_ADD_DEVICE, GetFaxServerErrorMsg(ec), m_hWnd);

    EnableOK(FALSE);
Exit:
    
    return FAILED(hRc) ? 0 : 1;
}

/*
 -  CDlgNewFaxOutboundDevice::OnListViewItemChanged
 -
 *  Purpose:
 *      Enable/Disable the submit button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CDlgNewFaxOutboundDevice::OnListViewItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundDevice::OnListViewItemChanged"));
	
    EnableOK( m_DeviceList.GetSelectedCount() > 0 );
                    
    return 0;
}


/*
 -  CDlgNewFaxOutboundDevice::EnableOK
 -
 *  Purpose:
 *      Enable (disable) apply button.
 *
 *  Arguments:
 *      [in] fEnable - the value to enable the button
 *
 *  Return:
 *      void
 */
VOID
CDlgNewFaxOutboundDevice::EnableOK(BOOL fEnable)
{
    HWND hwndOK = GetDlgItem(IDOK);
    ::EnableWindow(hwndOK, fEnable);
}

/*
 -  CDlgNewFaxOutboundDevice::OnCancel
 -
 *  Purpose:
 *      End dialog OnCancel.
 *
 *  Arguments:
 *
 *  Return:
 *      0
 */
LRESULT
CDlgNewFaxOutboundDevice::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundDevice::OnCancel"));

    EndDialog(wID);
    return 0;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CDlgNewFaxOutboundDevice::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CDlgNewFaxOutboundDevice::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CDlgNewFaxOutboundDevice::OnHelpRequest"));
    
    HELPINFO* helpinfo;
    DWORD     dwHelpId;

    switch (uMsg) 
    { 
        case WM_HELP: 

            helpinfo = (HELPINFO*)lParam;
            if (helpinfo->iContextType == HELPINFO_WINDOW)
            {
                ::WinHelp(
                          (HWND) helpinfo->hItemHandle,
                          FXS_ADMIN_HLP_FILE, 
                          HELP_CONTEXTPOPUP, 
                          (DWORD) helpinfo->dwContextId 
                       ); 
            }
            break; 
 
        case WM_CONTEXTMENU: 
            
            dwHelpId = ::GetWindowContextHelpId((HWND)wParam);
            if (dwHelpId) 
            {
                ::WinHelp
                       (
                         (HWND)wParam,
                         FXS_ADMIN_HLP_FILE, 
                         HELP_CONTEXTPOPUP, 
                         dwHelpId
                       );
            }
            break; 
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\dlgconfirmpassword.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DlgConfirmPassword.cpp                                 //
//                                                                         //
//  DESCRIPTION   : The CDlgConfirmPassword class implements the           //
//                  dialog for additon of new Group.                       //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jul 27 2000 yossg    Create                                        //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "DlgConfirmPassword.h"

#include "FxsValid.h"
#include "dlgutils.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgConfirmPassword

CDlgConfirmPassword::CDlgConfirmPassword()
{
    m_fIsDialogInitiated       = FALSE;
    
    m_fIsPasswordDirty                = FALSE;
    m_fIsConfirmPasswordDirty         = FALSE;
    m_fIsPasswordChangedAndConfirmed  = FALSE;
}

CDlgConfirmPassword::~CDlgConfirmPassword()
{
}


/*
 +  CDlgConfirmPassword::OnInitDialog
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgConfirmPassword::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgConfirmPassword::OnInitDialog"));  
    HRESULT hRc = S_OK;    

    //
    // Attach controls
    //
    m_UserNameBox.Attach(GetDlgItem(IDC_SMTP_USERNAME_EDIT));
    m_PasswordBox.Attach(GetDlgItem(IDC_SMTP_PASSWORD_EDIT));
    m_ConfirmPasswordBox.Attach(GetDlgItem(IDC_CONFIRM_PASSWORD_EDIT));
        
    //
    // Limit text length
    //
    m_UserNameBox.SetLimitText(FXS_MAX_USERNAME_LENGTH);
    m_PasswordBox.SetLimitText(FXS_MAX_PASSWORD_LENGTH);
    m_ConfirmPasswordBox.SetLimitText(FXS_MAX_PASSWORD_LENGTH);

    //
    // Init textboxes
    //
    m_UserNameBox.SetWindowText( m_bstrUserName);
    m_PasswordBox.SetWindowText( TEXT("******"));
    m_ConfirmPasswordBox.SetWindowText( TEXT("******"));

    m_fIsDialogInitiated = TRUE;

    EnableOK(FALSE);

    return 1;  // Let the system set the focus
}

/*
 +  CDlgConfirmPassword::OnOK
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgConfirmPassword::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgConfirmPassword::OnOK"));
    HRESULT     hRc           = S_OK;

    CComBSTR    bstrUserName;
    CComBSTR    bstrPassword;
    
    BOOL        fSkipMessage  = FALSE;
    int         CtrlFocus     = 0; 
    
    m_fIsPasswordChangedAndConfirmed  = FALSE;

    ATLASSERT (m_UserNameBox.GetWindowTextLength() >0 );//avoided by disabling OK button
    if ( !m_UserNameBox.GetWindowText(&bstrUserName))
    {
        CtrlFocus = IDC_SMTP_USERNAME_EDIT;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to GetWindowText(&bstrUserName)"));
        hRc = E_OUTOFMEMORY;

        goto Error;
    }

    //
    // Any credential change should involve password update and confirmation
    // We are supporting only two scenarioes: 1) Password update and 2) full credentilals change.
    //
    if  ( !(m_fIsPasswordDirty && m_fIsConfirmPasswordDirty) )
    {
        if (!m_fIsPasswordDirty)
        {
            CtrlFocus = IDC_SMTP_PASSWORD_EDIT;
        }
        else // !m_fIsConfirmPasswordDirty
        {
            CtrlFocus = IDC_CONFIRM_PASSWORD_EDIT;
        }

        DebugPrintEx(
            DEBUG_WRN,
            TEXT("!(m_fIsPasswordDirty && m_fIsConfirmPasswordDirty)"));        
        
        DlgMsgBox(this, IDS_INVALID_PASSWORD, MB_OK|MB_ICONEXCLAMATION);

        hRc = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        
        fSkipMessage = TRUE;
        
        goto Error;
    }
    else
    {
        //
        // Only is the password changed, we collect the new text from the control.
        // Otherwise, we leave the string as NULL so that the server won't set it.
        //
        if ( !m_PasswordBox.GetWindowText(&bstrPassword))
        {
            CtrlFocus = IDC_SMTP_PASSWORD_EDIT;
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&bstrPassword)"));

            hRc = E_OUTOFMEMORY;

            goto Error;
        }

        //
        // To avoid any non controled password insertion we ask for 
        // password confirmation
        //
        CComBSTR    bstrConfirmedPassword;
        if ( !m_ConfirmPasswordBox.GetWindowText(&bstrConfirmedPassword))
        {
            CtrlFocus = IDC_SMTP_PASSWORD_EDIT;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to GetWindowText(&bstrPassword)"));

            hRc = E_OUTOFMEMORY;

            goto Error;
        }

        //
        // Password Compare
        //
        if ( 0 != wcscmp( bstrConfirmedPassword , bstrPassword )  )
        {
            DebugPrintEx(
                DEBUG_MSG,
                _T("The passwords that were entered are not the same."));
        
            DlgMsgBox(this, IDS_PASSWORD_NOT_MATCH, MB_OK|MB_ICONEXCLAMATION);
        
            goto Exit;
        }
        
        m_fIsPasswordChangedAndConfirmed = TRUE;
     }    

    
    //
    // Step 2: Input Validation
    //
    if (!IsValidData(bstrUserName, bstrPassword, &CtrlFocus))
    {
        hRc = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

        //in this case detailed message box was given by the called functions
        fSkipMessage = TRUE;
        
        goto Error;
    }

    //
    // Step 3: set the bstrs to the member
    //
    m_bstrUserName = bstrUserName;
    if (!m_bstrUserName)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Out of memory: Failed to allocate m_bstrUserName"));

        hRc = E_OUTOFMEMORY;

        goto Error;
    }

    if (m_fIsPasswordChangedAndConfirmed)
    {
        m_bstrPassword = bstrPassword;
        if (!m_bstrPassword)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Out of memory: Failed to allocate m_bstrPassword"));

            hRc = E_OUTOFMEMORY;

            goto Error;
        }
    }

    //
    // Step 4: Close the dialog
    //
    ATLASSERT(S_OK == hRc );

    EndDialog(wID);

    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
	
    if (!fSkipMessage)
    {
        if (E_OUTOFMEMORY == hRc)
        {
            DlgMsgBox(this, IDS_MEMORY);
        }
        else
        {
            DlgMsgBox(this, IDS_FAIL2UPDATE_SMTP_CONFIG);
        }
    }
    ::SetFocus(GetDlgItem(CtrlFocus));
  
Exit:
    
    return FAILED(hRc) ? 0 : 1;
}

/*
 -  CDlgConfirmPassword::OnPasswordChanged
 -
 *  Purpose:
 *      Catch changes to the password edit box.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CDlgConfirmPassword::OnPasswordChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER (wNotifyCode);
    UNREFERENCED_PARAMETER (hWndCtl);
    UNREFERENCED_PARAMETER (bHandled);

    DEBUG_FUNCTION_NAME( _T("CDlgConfirmPassword::OnPasswordChanged"));

    if (!m_fIsDialogInitiated) // Event receieved in a too early stage
    {
        return 0;
    }
    
    switch (wID)
    {
        case IDC_SMTP_PASSWORD_EDIT:
            m_fIsPasswordDirty = TRUE;
            break;

        case IDC_CONFIRM_PASSWORD_EDIT:
            m_fIsConfirmPasswordDirty = TRUE;
            break;

        default:
            ATLASSERT(FALSE);
    }
        
    UINT uEnableOK = ( m_UserNameBox.GetWindowTextLength() );
    
    EnableOK(!!uEnableOK);

    return 1;
}


/*
 -  CDlgConfirmPassword::OnTextChanged
 -
 *  Purpose:
 *      Check the validity of text inside a textbox.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CDlgConfirmPassword::OnTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgConfirmPassword::OnTextChanged"));

    UINT fEnableOK;
	
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }

    fEnableOK = ( m_UserNameBox.GetWindowTextLength() );
    
    EnableOK(!!fEnableOK);

    return 0;
}

/*
 -  CDlgConfirmPassword::EnableOK
 -
 *  Purpose:
 *      Enable (disable) apply button.
 *
 *  Arguments:
 *      [in] fEnable - the value to enable the button
 *
 *  Return:
 *      void
 */
VOID
CDlgConfirmPassword::EnableOK(BOOL fEnable)
{
    HWND hwndOK = GetDlgItem(IDOK);
    ::EnableWindow(hwndOK, fEnable);
}

/*
 -  CDlgConfirmPassword::OnCancel
 -
 *  Purpose:
 *      End dialog OnCancel.
 *
 *  Arguments:
 *
 *  Return:
 *      0
 */
LRESULT
CDlgConfirmPassword::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgConfirmPassword::OnCancel"));

    EndDialog(wID);
    return 0;
}


/*
 -  CDlgConfirmPassword::InitCredentialsDlg
 -
 *  Purpose:
 *      Initiates the configuration from data retereived by RPC,
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CDlgConfirmPassword::InitCredentialsDlg(BSTR bstrUserName)
{
    DEBUG_FUNCTION_NAME( _T("CDlgConfirmPassword::InitCredentialsDlg"));
    
    HRESULT hRc = S_OK;
        
    m_bstrUserName = bstrUserName;
    if (!m_bstrUserName )
    {
        DebugPrintEx(DEBUG_ERR,
			_T("Out of memory - Failed to Init m_bstrUserName. (ec: %0X8)"), hRc);
        //MsgBox by Caller Function
        hRc = E_OUTOFMEMORY;
        goto Exit;
    }
        
    ATLASSERT(S_OK == hRc);
    
Exit:    
    return hRc;
}


/*
 -  CDlgConfirmPassword::IsValidData
 -
 *  Purpose:
 *      To validate all data types before save data.
 *      This level should be responsible that detailed 
 *      error description will be shown to user.
 *
 *  Arguments:
 *      [in]   BSTRs and DWORDs
 *      [out]  iFocus
 *
 *  Return:
 *      BOOOLEAN
 */
BOOL CDlgConfirmPassword::IsValidData(BSTR bstrUserName, BSTR bstrPassword, int * pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CDlgConfirmPassword::IsValidData"));

    UINT    uRetIDS   = 0;

    ATLASSERT(pCtrlFocus);
    
    //
    // User Name
    //
    if (!IsNotEmptyString(bstrUserName))
    {
        DebugPrintEx( DEBUG_ERR,
			_T("Username string empty or spaces only."));
        uRetIDS = IDS_USERNAME_EMPTY;

        *pCtrlFocus = IDC_SMTP_USERNAME_EDIT;
    
        goto Error;
    }

    //
    // Password
    //

    //Currently do noting. empty string is valid also.
    
    ATLASSERT(0 == uRetIDS);
    goto Exit;
    
Error:    
    ATLASSERT(0 != uRetIDS);

    DlgMsgBox(this, uRetIDS);

    return FALSE;
    
Exit:
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CDlgConfirmPassword::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CDlgConfirmPassword::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CDlgSMTPConfig::OnHelpRequest"));
    
    HELPINFO* helpinfo;
    DWORD     dwHelpId;

    switch (uMsg) 
    { 
        case WM_HELP: 

            helpinfo = (HELPINFO*)lParam;
            if (helpinfo->iContextType == HELPINFO_WINDOW)
            {
                ::WinHelp(
                          (HWND) helpinfo->hItemHandle,
                          FXS_ADMIN_HLP_FILE, 
                          HELP_CONTEXTPOPUP, 
                          (DWORD) helpinfo->dwContextId 
                       ); 
            }
            break; 
 
        case WM_CONTEXTMENU: 
            
            dwHelpId = ::GetWindowContextHelpId((HWND)wParam);
            if (dwHelpId) 
            {
                ::WinHelp
                       (
                         (HWND)wParam,
                         FXS_ADMIN_HLP_FILE, 
                         HELP_CONTEXTPOPUP, 
                         dwHelpId
                       );
            }
            break; 
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\dlgnewgroup.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DlgNewGroup.h                                          //
//                                                                         //
//  DESCRIPTION   : Header file for the CDlgNewFaxOutboundGroup class.     //
//                  The class implement the dialog for new Group.          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan  3 2000 yossg   Create                                         //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef DLGNEWOUTGROUP_H_INCLUDED
#define DLGNEWOUTGROUP_H_INCLUDED

/////////////////////////////////////////////////////////////////////////////
// CDlgNewFaxOutboundGroup
class CFaxServer;
class CDlgNewFaxOutboundGroup :
    public CDialogImpl<CDlgNewFaxOutboundGroup>
{
public:
    CDlgNewFaxOutboundGroup(CFaxServer * pFaxServer):m_pFaxServer(pFaxServer)
	{
		ATLASSERT(pFaxServer);
	}

    ~CDlgNewFaxOutboundGroup();

    enum { IDD = IDD_DLGNEWGROUP };

BEGIN_MSG_MAP(CDlgNewFaxOutboundGroup)
    MESSAGE_HANDLER   (WM_INITDIALOG, OnInitDialog)
    
    COMMAND_ID_HANDLER(IDOK,          OnOK)
    COMMAND_ID_HANDLER(IDCANCEL,      OnCancel)
    
    MESSAGE_HANDLER( WM_CONTEXTMENU,  OnHelpRequest)
    MESSAGE_HANDLER( WM_HELP,         OnHelpRequest)

    COMMAND_HANDLER(IDC_GROUPNAME_EDIT, EN_CHANGE, OnTextChanged)
END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK    (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnTextChanged (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    //
    // Methods
    //
    VOID      EnableOK(BOOL fEnable);

    CFaxServer * m_pFaxServer;

    //
    // Controls
    //
    CEdit     m_GroupNameEdit;

    CComBSTR  m_bstrGroupName;    
};

#endif // DLGNEWOUTGROUP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\dlgnewrule.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : dlgNewRule.cpp                                         //
//                                                                         //
//  DESCRIPTION   : The CDlgNewFaxOutboundRule class implements the        //
//                  dialog for additon of new Rule.                        //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 30 1999 yossg    Create                                        //
//      Jan 25 2000 yossg  Change the Dialog Design                        //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "dlgNewRule.h"
#include "DlgSelectCountry.h"

#include "FaxServer.h"
#include "FaxServerNode.h"


#include "FaxMMCUtils.h"
#include "dlgutils.h"

#include "Helper.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgNewFaxOutboundRule

CDlgNewFaxOutboundRule::CDlgNewFaxOutboundRule(CFaxServer * pFaxServer)
{    
    m_pFaxDevicesConfig = NULL;
    m_dwNumOfDevices    = 0;

    m_pFaxGroupsConfig  = NULL;
    m_dwNumOfGroups     = 0;

    m_fAllReadyToApply  = FALSE;

    ATLASSERT(pFaxServer);
    m_pFaxServer = pFaxServer;
}

CDlgNewFaxOutboundRule::~CDlgNewFaxOutboundRule()
{
    if (NULL != m_pFaxDevicesConfig)
        FaxFreeBuffer(m_pFaxDevicesConfig);

    if (NULL != m_pFaxGroupsConfig)
        FaxFreeBuffer(m_pFaxGroupsConfig);
}

/*
 +  CDlgNewFaxOutboundRule::OnInitDialog
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgNewFaxOutboundRule::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundRule::OnInitDialog"));
    HRESULT     hRc = S_OK;
    DWORD       ec  = ERROR_SUCCESS;
    
    int         i , j ,k, l;
    i = j = k = l = 0;

    const int   iAllDevicesComboIndex     = 0;
    int         iAllDevicesRPCIndex       = 0;

    int         iGroupListIndexToSelect   = 0;
    
    HINSTANCE   hInst;
    hInst = _Module.GetResourceInstance();
    
    WCHAR buf[FXS_MAX_DISPLAY_NAME_LEN+1];


    //
    // Attach controls
    //
    m_CountryCodeEdit.Attach(GetDlgItem(IDC_NEWRULE_COUNTRYCODE_EDIT));
    m_AreaCodeEdit.Attach(GetDlgItem(IDC_RULE_AREACODE_EDIT));

    m_DeviceCombo.Attach(GetDlgItem(IDC_DEVICES4RULE_COMBO));
    m_GroupCombo.Attach(GetDlgItem(IDC_GROUP4RULE_COMBO));
        
    //
    // Set length limit to area code
    //
    m_CountryCodeEdit.SetLimitText(FXS_MAX_COUNTRYCODE_LEN - 1); 
    m_AreaCodeEdit.SetLimitText(FXS_MAX_AREACODE_LEN-1);

    //
    // Step 1: Init Lists
    //
    
    //
    // Init Devices
    //
    for (k = 0; (DWORD)k < m_dwNumOfDevices; k++ )
    {   
        hRc = AddComboBoxItem ( m_DeviceCombo, 
                                m_pFaxDevicesConfig[k].lpctstrDeviceName, 
                                m_pFaxDevicesConfig[k].dwDeviceID,
                                hInst);
        if (FAILED(hRc))
        {
		    DebugPrintEx( DEBUG_ERR, _T("Fail to load device list."));
            PageError(IDS_FAIL2LOADDEVICELIST, m_hWnd, hInst);
            ::EnableWindow(GetDlgItem(IDC_DEVICES4RULE_COMBO), FALSE);
            goto Cleanup;
        }

    }
        
    //
    // Init groups
    //
    for (l = 0; (DWORD)l < m_dwNumOfGroups; l++ )
    {   
        if ( 0 == wcscmp(ROUTING_GROUP_ALL_DEVICES, m_pFaxGroupsConfig[l].lpctstrGroupName))
        {
            iAllDevicesRPCIndex = l;
            //Do not do any more;
		}
        else
		{
				hRc = AddComboBoxItem ( m_GroupCombo, 
										m_pFaxGroupsConfig[l].lpctstrGroupName, 
										(DWORD)l,
										hInst);
				if (FAILED(hRc))
				{
		            DebugPrintEx( DEBUG_ERR, _T("Fail to load group list."));
					PageError(IDS_FAIL2LOADDEVICELIST, m_hWnd, hInst);
                    ::EnableWindow(GetDlgItem(IDC_GROUP4RULE_COMBO), FALSE);
					goto Cleanup;
				}
		}
    }

    //
    // Now add "All Devices" Group as the first one
    //

    //
    // Replace <all Devices> string for localization 
    //
    if (!hInst)
    {
        hInst = _Module.GetResourceInstance();
    }
    if (!LoadString(hInst, IDS_ALL_DEVICES, buf, FXS_MAX_DISPLAY_NAME_LEN))
    {
        hRc = E_OUTOFMEMORY;
		DebugPrintEx( DEBUG_ERR, _T("Fail to load string. Out of memory."));
        PageError(IDS_FAXOUTOFMEMORY, m_hWnd, hInst);
        goto Cleanup;
    }
    //
    // insert "All Devices" Group as the first one in the groups list
    //
    ATLASSERT( 0 == iAllDevicesComboIndex );
    hRc = SetComboBoxItem ( m_GroupCombo, 
                            iAllDevicesComboIndex, 
                            buf, 
                            iAllDevicesRPCIndex,
                            hInst);
    if (FAILED(hRc))
    {
		DebugPrintEx( DEBUG_ERR, _T("Fail to load group list."));
        PageError(IDS_FAIL2LOADGROUPLIST, m_hWnd, hInst);
        ::EnableWindow(GetDlgItem(IDC_GROUP4RULE_COMBO), FALSE);
        goto Cleanup;
    }



    //
    // Step 2: Set current status 
    //          (Select items in Lists, select radio button etc.)
    //          (Gray/UnGray controls)
    //

 	m_GroupCombo.SetCurSel (iAllDevicesComboIndex);

    //
    //  Radio buttons, Gray/UnGray
    //
    CheckDlgButton(IDC_COUNTRY_RADIO, BST_CHECKED);
    ::EnableWindow(GetDlgItem(IDC_RULE_AREACODE_EDIT), FALSE);

    CheckDlgButton(IDC_DESTINATION_RADIO2, BST_CHECKED) ;
    ::EnableWindow(GetDlgItem(IDC_DEVICES4RULE_COMBO), FALSE);


Cleanup:
    EnableOK(FALSE);
    return 1;  // Let the system set the focus
}

/*
 +  CDlgNewFaxOutboundRule::OnOK
 +
 *  Purpose:
 *      Submit data
 *      
 *  Arguments:
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgNewFaxOutboundRule::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundRule::OnOK"));
    HRESULT       hRc                  = S_OK;
    DWORD         ec                   = ERROR_SUCCESS;
    BOOL          fSkipMessage         = FALSE;

    CComBSTR      bstrAreaCode;
    CComBSTR      bstrCountryCode;

    int           iCurrentSelectedItem = 0;
    
    DWORD         dwAreaCode           = 0;
    DWORD         dwCountryCode        = 0;

    BOOL          bUseGroup;
    DWORD         dwDeviceID           = 0;
    WCHAR         lpszGroupName[MAX_ROUTING_GROUP_NAME];
    
	LPCTSTR       lpctstrGroupName     = NULL;

    //
    // Step 0: PreApply Checks
    //
    ATLASSERT( TRUE == m_fAllReadyToApply );
    if (!AllReadyToApply(/*fSilent =*/ FALSE))
    {
        EnableOK(FALSE);
        hRc =S_FALSE;
        goto Exit;
    }

    //
    // Step 1: get data
    //

    //
    // Country Code
    //
    if ( !m_CountryCodeEdit.GetWindowText(&bstrCountryCode))
    {
		DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Failed to GetWindowText(&bstrCountryCode)"));
        DlgMsgBox(this, IDS_FAIL2READ_COUNTRYCODE);
        ::SetFocus(GetDlgItem(IDC_RULE_COUNTRYCODE_EDIT));
        hRc = S_FALSE;
        
        goto Exit;
    }
    dwCountryCode = (DWORD)wcstoul( bstrCountryCode, NULL, 10 );

    if (ROUTING_RULE_COUNTRY_CODE_ANY == dwCountryCode)
    {
        //
        // The user try to set the country code to zero
        //
		DebugPrintEx(
			    DEBUG_ERR,
			    TEXT(" CountryCode == ROUTING_RULE_COUNTRY_CODE_ANY "));
        DlgMsgBox(this, IDS_ZERO_COUNTRYCODE);
        ::SetFocus(GetDlgItem(IDC_RULE_COUNTRYCODE_EDIT));
        hRc = S_FALSE;
    
        goto Exit;
    }


    //
    // Area Code
    //
    if ( IsDlgButtonChecked(IDC_COUNTRY_RADIO) == BST_CHECKED )
    {
        dwAreaCode = (DWORD)ROUTING_RULE_AREA_CODE_ANY;
    }
    else // IsDlgButtonChecked(IDC_AREA_RADIO) == BST_CHECKED
    {	
        if ( !m_AreaCodeEdit.GetWindowText(&bstrAreaCode))
        {
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&bstrAreaCode)"));
            DlgMsgBox(this, IDS_FAIL2READ_AREACODE);
            ::SetFocus(GetDlgItem(IDC_RULE_AREACODE_EDIT));
            hRc = S_FALSE;
            
            goto Exit;
        }
        dwAreaCode = (DWORD)wcstoul( bstrAreaCode, NULL, 10 );
    }
  
    if ( IsDlgButtonChecked(IDC_DESTINATION_RADIO1) == BST_CHECKED )
    {
        //
        // Use Group ?
        //
        bUseGroup = FALSE;
        
        //
        // Device
        //
        iCurrentSelectedItem = m_DeviceCombo.GetCurSel();
        ATLASSERT(iCurrentSelectedItem != CB_ERR); //should be chacked pre apply         
        dwDeviceID =  (DWORD)m_DeviceCombo.GetItemData (iCurrentSelectedItem);

    }
    else // IsDlgButtonChecked(IDC_DESTINATION_RADIO2) == BST_CHECKED
    {	
        //
        // Use Group ?
        //
        bUseGroup = TRUE;
 
        //
        // Group
        //
        iCurrentSelectedItem = m_GroupCombo.GetCurSel();
        //ATLASSERT(iCurrentSelectedItem != CB_ERR); //should be chacked pre apply        

        if (0 == iCurrentSelectedItem) //All Devices
        {
            lpctstrGroupName = ROUTING_GROUP_ALL_DEVICES;
        }
        else
        {
            ATLASSERT(MAX_ROUTING_GROUP_NAME > m_GroupCombo.GetLBTextLen(iCurrentSelectedItem)); //should be chacked by service before        
        
            m_GroupCombo.GetLBText( iCurrentSelectedItem, lpszGroupName );
            lpctstrGroupName = (LPCTSTR)lpszGroupName;
        }
    }

    
    //
    // Step 2: Add Rule to service with RPC
    //


    //
    // get RPC Handle
    //   
   
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Add the rule
    //
    if (!FaxAddOutboundRule (
	        m_pFaxServer->GetFaxServerHandle(),
	        dwAreaCode,
	        dwCountryCode,
	        dwDeviceID,
	        lpctstrGroupName,
	        bUseGroup))
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to add rule. (ec: %ld)"), 
			ec);
        if (ERROR_DUP_NAME == ec) 
        {            
            DlgMsgBox(this, IDS_OUTRULE_EXISTS);
            goto Exit;
        }
        
        if (FAX_ERR_BAD_GROUP_CONFIGURATION == ec)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("The group is empty or none of group devices is valid. (ec: %ld)"), 
			    ec);
            
            PageError(IDS_BAD_GROUP_CONFIGURATION,m_hWnd);
            fSkipMessage = TRUE;

            goto Error; 
        }        
        
        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
        
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
        
    //
    // Step 3: Close the dialog
    //
    ATLASSERT(S_OK == hRc && ERROR_SUCCESS == ec);

    DebugPrintEx( DEBUG_MSG,
		_T("The rule was added successfully."));

    EndDialog(wID);

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
	
    if (!fSkipMessage)
    {
        PageErrorEx(IDS_FAIL_ADD_RULE, GetFaxServerErrorMsg(ec), m_hWnd);
    }

  
Exit:    
    return FAILED(hRc) ? 0 : 1;
}

/*
 -  CDlgNewFaxOutboundRule::OnDestenationRadioClicked
 -
 *  Purpose:
 *      Gray/Ungray the folder edit box and the
 *      browse button. Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CDlgNewFaxOutboundRule::OnDestenationRadioClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;

    State = ( IsDlgButtonChecked(IDC_DESTINATION_RADIO1) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_DEVICES4RULE_COMBO), State);    
    
    ATLASSERT(!State == (IsDlgButtonChecked(IDC_DESTINATION_RADIO2) == BST_CHECKED)); 
    ::EnableWindow(GetDlgItem(IDC_GROUP4RULE_COMBO), !State);    

    if (State)//IsDlgButtonChecked(IDC_DESTINATION_RADIO1) == BST_CHECKED
    {
        if ( CB_ERR  ==  m_DeviceCombo.GetCurSel())
        {
            m_fAllReadyToApply = FALSE;
            EnableOK(FALSE);
            goto Exit;
        }
        //else continue to whole controls check
    }
    else //IsDlgButtonChecked(IDC_DESTINATION_RADIO2) == BST_CHECKED
    {
        if ( CB_ERR  ==  m_GroupCombo.GetCurSel())
        {
            m_fAllReadyToApply = FALSE;
            EnableOK(FALSE);
            goto Exit;
        }
        //else continue to whole controls check
    }

    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            EnableOK(TRUE);
        }
        else
        {
            //Should be EnableOK(FALSE);
        }
    }
Exit:
    return(1);
}

/*
 -  CDlgNewFaxOutboundRule::OnRuleTypeRadioClicked
 -
 *  Purpose:
 *      Gray/Ungray the folder edit box and the
 *      browse button. Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CDlgNewFaxOutboundRule::OnRuleTypeRadioClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;

    State = ( IsDlgButtonChecked(IDC_COUNTRY_RADIO) == BST_CHECKED );
    
    ATLASSERT(!State == (IsDlgButtonChecked(IDC_AREA_RADIO) == BST_CHECKED)); 
    ::EnableWindow(GetDlgItem(IDC_RULE_AREACODE_EDIT), !State);    

    if (!State)//IsDlgButtonChecked(IDC_AREA_RADIO) == BST_CHECKED
    {
        if ( !m_AreaCodeEdit.GetWindowTextLength() )
        {
            m_fAllReadyToApply = FALSE;
            EnableOK(FALSE);  
			goto Exit;
        }
		//else continue to whole controls check
    }
	//else //IsDlgButtonChecked(IDC_COUNTRY_RADIO) == BST_CHECKED
    //Do noting - continue to whole controls check

    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            EnableOK(TRUE);
        }
    }

Exit:
    return(1);
}


/*
 -  CDlgNewFaxOutboundRule::OnComboChanged
 -
 *  Purpose:
 *      Gray/Ungray the submit button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT 
CDlgNewFaxOutboundRule::OnComboChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundRule::OnComboChanged"));

    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            EnableOK(TRUE);
        }
    }

    return 1;
}

/*
 -  CDlgNewFaxOutboundRule::OnTextChanged
 -
 *  Purpose:
 *      Enable/Disable the submit button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CDlgNewFaxOutboundRule::OnTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundRule::OnTextChanged"));

    UINT fEnableOK = 0;
	
    switch (wID)
	{
		case IDC_RULE_AREACODE_EDIT:
			fEnableOK = ( m_AreaCodeEdit.GetWindowTextLength() );
			break;

		case IDC_NEWRULE_COUNTRYCODE_EDIT:
			fEnableOK = ( m_CountryCodeEdit.GetWindowTextLength() );
			break;

		default:
			ATLASSERT(FALSE);
	}
                    
    if(!!fEnableOK)
    {
        if (!m_fAllReadyToApply)
        {
            if (AllReadyToApply(TRUE))
            {
                m_fAllReadyToApply = TRUE;
                EnableOK(TRUE);
            }
        }
    }
    else
    {
        EnableOK(FALSE);
        m_fAllReadyToApply = FALSE;
    }

    return 1;
}

/*
 -  CDlgNewFaxOutboundRule::AllReadyToApply
 -
 *  Purpose:
 *      Enable/Disable the submit button.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE if all ready to apply, else FALSE.
 */
BOOL 
CDlgNewFaxOutboundRule::AllReadyToApply(BOOL fSilent)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundRule::AllReadyToApply"));
	
    if ( !m_CountryCodeEdit.GetWindowTextLength() )
    {
        if (!fSilent)
        {
                DlgMsgBox(this, IDS_ZERO_COUNTRYCODE);
                ::SetFocus(GetDlgItem(IDC_NEWRULE_COUNTRYCODE_EDIT));
        }
        return FALSE;    
    }

    if ( IsDlgButtonChecked(IDC_AREA_RADIO) == BST_CHECKED )
    {
        if ( !m_AreaCodeEdit.GetWindowTextLength() )
        {
            if (!fSilent)
            {
                    DlgMsgBox(this, IDS_EMPTY_AREACODE);
                    ::SetFocus(GetDlgItem(IDC_RULE_AREACODE_EDIT));
            }
            return FALSE;    
        }
    }
    //else do noting.

    if ( IsDlgButtonChecked(IDC_DESTINATION_RADIO1) == BST_CHECKED )
    {
        if ( CB_ERR  ==  m_DeviceCombo.GetCurSel())
        {
            if (!fSilent)
            {
                DlgMsgBox(this, IDS_PLEASESELECT_DEVICE);
                ::SetFocus(GetDlgItem(IDC_DEVICES4RULE_COMBO));
            }
            return FALSE;
        }
    }
    else if ( CB_ERR  ==  m_GroupCombo.GetCurSel())
    {
        if (!fSilent)
        {
            DlgMsgBox(this, IDS_PLEASESELECT_GROUP);
            ::SetFocus(GetDlgItem(IDC_GROUP4RULE_COMBO));
        }
        return FALSE;
    }

    //
    // Cheers! 
    //		...every thing ready to apply now.
    //
    return TRUE;           
}

/*
 -  CDlgNewFaxOutboundRule::EnableOK
 -
 *  Purpose:
 *      Enable/Disable the submit button.
 *
 *  Arguments:
 *      [in] fEnable - boolen value tells 
 *                     to Enable or Disable the OK button.
 *
 *  Return:
 *      VOID
 */
VOID
CDlgNewFaxOutboundRule::EnableOK(BOOL fEnable)
{
    HWND hwndOK = GetDlgItem(IDOK);
    ::EnableWindow(hwndOK, fEnable);
}

/*
 -  CDlgNewFaxOutboundRule::OnCancel
 -
 *  Purpose:
 *      End the dialog.
 *
 *  Arguments:
 *
 *  Return:
 *      0
 */
LRESULT
CDlgNewFaxOutboundRule::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundRule::OnCancel"));

    EndDialog(wID);
    return 0;
}

/*
 -  CDlgNewFaxOutboundRule::InitRuleDlg
 -
 *  Purpose:
 *      Init all the members as country list pointer and 
 *      device list pointer
 *
 *  Arguments:
 *      No.
 *
 *  Return:
 *      0
 */
HRESULT CDlgNewFaxOutboundRule::InitRuleDlg()
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundRule::InitRuleDlg"));
    HRESULT      hRc        = S_OK; 
    DWORD        ec         = ERROR_SUCCESS;

    
    //
    // Step 1: Init Lists from RPC
    //

    //
    // get Fax Handle
    //   

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Devices (id, name)
    //
    if (!FaxEnumPortsEx(m_pFaxServer->GetFaxServerHandle(), 
                        &m_pFaxDevicesConfig,
                        &m_dwNumOfDevices)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get devices configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	ATLASSERT(m_pFaxDevicesConfig);


    //
    // Groups (names)
    //
    if (!FaxEnumOutboundGroups(m_pFaxServer->GetFaxServerHandle(), 
                        &m_pFaxGroupsConfig,
                        &m_dwNumOfGroups)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get groups configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	ATLASSERT(m_pFaxGroupsConfig);



    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get all configurations."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
    
    //MsgBox will be done by calling Func.

Exit:
    return hRc;
}


/*
 -  CDlgNewFaxOutboundRule::OnSelectCountryCodeClicked
 -
 *  Purpose:
 *      
 *
 *  Arguments:
 *      [out]   bHandled - Do we handle it?
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */
LRESULT
CDlgNewFaxOutboundRule::OnSelectCountryCodeClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundRule::OnSelectCountryCodeClicked"));
    HRESULT     hRc         =    S_OK;
    INT_PTR     rc          =    IDOK;

    int         iCount      =    0;
    WCHAR       szwCountryCode[FXS_MAX_COUNTRYCODE_LEN+1];
    DWORD       dwCountryCode = 0;

    CDlgSelectCountry  DlgSelectCountry(m_pFaxServer);

    hRc = DlgSelectCountry.InitSelectCountryCodeDlg();
    if (S_OK != hRc)
    {
        //MsgBox + debug print by called func.
        goto Cleanup;
    }

    //
    // Dialog select country code
    //
    rc = DlgSelectCountry.DoModal();
    if (rc != IDOK)
    {
        goto Cleanup;
    }

    //
    // Retreive CountryCode
    //
    dwCountryCode = DlgSelectCountry.GetCountryCode();

    iCount = swprintf(szwCountryCode, L"%ld", dwCountryCode);
    if( iCount <= 0 )
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to read member - m_dwCountryCode."));
        goto Cleanup;
    }
    m_CountryCodeEdit.SetWindowText(szwCountryCode);

    //
    // EnableOK
    //
    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            EnableOK(TRUE);
        }
		else
		{
			//Should be EnableOK(FALSE);
		}
    }

 
Cleanup:
    return hRc;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CDlgNewFaxOutboundRule::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CDlgNewFaxOutboundRule::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CDlgNewFaxOutboundRule::OnHelpRequest"));
    
    HELPINFO* helpinfo;
    DWORD     dwHelpId;

    switch (uMsg) 
    { 
        case WM_HELP: 

            helpinfo = (HELPINFO*)lParam;
            if (helpinfo->iContextType == HELPINFO_WINDOW)
            {
                ::WinHelp(
                          (HWND) helpinfo->hItemHandle,
                          FXS_ADMIN_HLP_FILE, 
                          HELP_CONTEXTPOPUP, 
                          (DWORD) helpinfo->dwContextId 
                       ); 
            }
            break; 
 
        case WM_CONTEXTMENU: 
            
            dwHelpId = ::GetWindowContextHelpId((HWND)wParam);
            if (dwHelpId) 
            {
                ::WinHelp
                       (
                         (HWND)wParam,
                         FXS_ADMIN_HLP_FILE, 
                         HELP_CONTEXTPOPUP, 
                         dwHelpId
                       );
            }
            break; 
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\dlgnewrule.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : dlgNewRule.h                                           //
//                                                                         //
//  DESCRIPTION   : Header file for the CDlgNewFaxOutboundRule class.      //
//                  The class implement the dialog for new Device.         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 30 1999 yossg   Create                                         //
//      Jan 25 2000 yossg  Change the Dialog Design                        //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef DLGNEWOUTRULE_H_INCLUDED
#define DLGNEWOUTRULE_H_INCLUDED

/////////////////////////////////////////////////////////////////////////////
// CDlgNewFaxOutboundRule
class CFaxServer;

class CDlgNewFaxOutboundRule :
    public CDialogImpl<CDlgNewFaxOutboundRule>
{
public:
    CDlgNewFaxOutboundRule(CFaxServer * pFaxServer);
    ~CDlgNewFaxOutboundRule();

    enum { IDD = IDD_DLGNEWRULE };

BEGIN_MSG_MAP(CDlgNewFaxOutboundRule)
    MESSAGE_HANDLER   (WM_INITDIALOG, OnInitDialog)
    
    COMMAND_ID_HANDLER(IDOK,          OnOK)
    COMMAND_ID_HANDLER(IDCANCEL,      OnCancel)
    
    COMMAND_HANDLER(IDC_RULE_AREACODE_EDIT, EN_CHANGE,     OnTextChanged)
    COMMAND_HANDLER(IDC_COUNTRY_RADIO,      BN_CLICKED,    OnRuleTypeRadioClicked)
    COMMAND_HANDLER(IDC_AREA_RADIO,         BN_CLICKED,    OnRuleTypeRadioClicked)
    COMMAND_HANDLER(IDC_DESTINATION_RADIO1, BN_CLICKED,    OnDestenationRadioClicked)
    COMMAND_HANDLER(IDC_DESTINATION_RADIO2, BN_CLICKED,    OnDestenationRadioClicked)

    COMMAND_HANDLER(IDC_NEWRULE_COUNTRYCODE_EDIT,  EN_CHANGE,     OnTextChanged)
    COMMAND_HANDLER(IDC_NEWRULE_SELECT_BUTTON,  BN_CLICKED, OnSelectCountryCodeClicked)

    COMMAND_HANDLER(IDC_DEVICES4RULE_COMBO, CBN_SELCHANGE, OnComboChanged)
    COMMAND_HANDLER(IDC_GROUP4RULE_COMBO,   CBN_SELCHANGE, OnComboChanged)

    MESSAGE_HANDLER( WM_CONTEXTMENU,  OnHelpRequest)
    MESSAGE_HANDLER( WM_HELP,         OnHelpRequest)

END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnTextChanged            (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnComboChanged           (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDestenationRadioClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRuleTypeRadioClicked   (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSelectCountryCodeClicked (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    HRESULT InitRuleDlg();

private:
    //
    // Methods
    //
    VOID    EnableOK(BOOL fEnable);
    BOOL    AllReadyToApply(BOOL fSilent);

    //
    // Members
    //
    CFaxServer * m_pFaxServer;

    PFAX_PORT_INFO_EX               m_pFaxDevicesConfig;
    DWORD                           m_dwNumOfDevices;

    PFAX_OUTBOUND_ROUTING_GROUP     m_pFaxGroupsConfig;
    DWORD                           m_dwNumOfGroups;

    BOOL                            m_fAllReadyToApply;

    //
    // misc members 
    //
    CComBSTR                        m_buf;
    
    //
    // Controls
    //
    CEdit                           m_CountryCodeEdit;
    
    CEdit                           m_AreaCodeEdit;

    CComboBox                       m_DeviceCombo;
    CComboBox                       m_GroupCombo;



};

#endif // DLGNEWOUTRULE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\dlgnewgroup.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DlgNewGroup.cpp                                        //
//                                                                         //
//  DESCRIPTION   : The CDlgNewFaxOutboundGroup class implements the       //
//                  dialog for additon of new Group.                       //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan  3 2000 yossg    Create                                        //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "dlgNewGroup.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "dlgutils.h"

//#include "Helper.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgNewFaxOutboundGroup

CDlgNewFaxOutboundGroup::~CDlgNewFaxOutboundGroup()
{
}

/*
 +  CDlgNewFaxOutboundGroup::OnInitDialog
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgNewFaxOutboundGroup::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundGroup::OnInitDialog"));
    HRESULT hRc = S_OK;    

    //
    // Attach controls
    //
    m_GroupNameEdit.Attach(GetDlgItem(IDC_GROUPNAME_EDIT));
        
    //
    // Set length limit to area code
    //
    m_GroupNameEdit.SetLimitText(MAX_ROUTING_GROUP_NAME - 1);

    //
    // Set focus
    //
    ::SetFocus(GetDlgItem(IDC_GROUPNAME_EDIT));

    EnableOK(FALSE);
    return 1;  // Let the system set the focus
}

/*
 +  CDlgNewFaxOutboundGroup::OnOK
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgNewFaxOutboundGroup::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundGroup::OnOK"));
    HRESULT       hRc                  = S_OK;
    DWORD         ec                   = ERROR_SUCCESS;

    //
    // Step 0: PreApply Checks
    //
/*    
    if (!CheckValidtity())
    {
        EnableOK(FALSE);
        hRc =S_FALSE;
        goto Exit;
    }
*/
    //
    // Step 1: get data
    //
        if ( !m_GroupNameEdit.GetWindowText(&m_bstrGroupName))
        {
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&m_bstrGroupName)"));
            DlgMsgBox(this, IDS_FAIL2READ_GROUPNAME);
            ::SetFocus(GetDlgItem(IDC_GROUPNAME_EDIT));
            hRc = S_FALSE;
            
            goto Exit;
        }

    
    //
    // Step 2: add group via RPC call
    //

    //
    // get RPC Handle
    //   
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Add the group
    //
    if (!FaxAddOutboundGroup (
	        m_pFaxServer->GetFaxServerHandle(),
	        (LPCTSTR)m_bstrGroupName))
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to add group. (ec: %ld)"), 
			ec);
        if (ERROR_DUP_NAME == ec) 
        {            
            DlgMsgBox(this, IDS_OUTGROUP_EXISTS);
            ::SetFocus(GetDlgItem(IDC_GROUPNAME_EDIT));
            goto Exit;
        }
        else if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
        
    //
    // Step 3: Close the dialog
    //
    ATLASSERT(S_OK == hRc && ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("The group was added successfully."));

    EndDialog(wID);

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
	
    PageErrorEx(IDS_FAIL_ADD_RULE, GetFaxServerErrorMsg(ec), m_hWnd);
  
Exit:
    
    return FAILED(hRc) ? 0 : 1;
}

/*
 -  CDlgNewFaxOutboundGroup::OnTextChanged
 -
 *  Purpose:
 *      Check the validity of text in side the text box.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CDlgNewFaxOutboundGroup::OnTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundGroup::OnTextChanged"));

    UINT fEnableOK;
	
    fEnableOK = ( m_GroupNameEdit.GetWindowTextLength() );
    EnableOK(!!fEnableOK);
    return 0;
}

/*
 -  CDlgNewFaxOutboundGroup::EnableOK
 -
 *  Purpose:
 *      Enable (disable) apply button.
 *
 *  Arguments:
 *      [in] fEnable - the value to enable the button
 *
 *  Return:
 *      void
 */
VOID
CDlgNewFaxOutboundGroup::EnableOK(BOOL fEnable)
{
    HWND hwndOK = GetDlgItem(IDOK);
    ::EnableWindow(hwndOK, fEnable);
}

/*
 -  CDlgNewFaxOutboundGroup::OnCancel
 -
 *  Purpose:
 *      End dialog OnCancel.
 *
 *  Arguments:
 *
 *  Return:
 *      0
 */
LRESULT
CDlgNewFaxOutboundGroup::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundGroup::OnCancel"));

    EndDialog(wID);
    return 0;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CDlgNewFaxOutboundGroup::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CDlgNewFaxOutboundGroup::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CDlgNewFaxOutboundGroup::OnHelpRequest"));
    
    HELPINFO* helpinfo;
    DWORD     dwHelpId;

    switch (uMsg) 
    { 
        case WM_HELP: 

            helpinfo = (HELPINFO*)lParam;
            if (helpinfo->iContextType == HELPINFO_WINDOW)
            {
                ::WinHelp(
                          (HWND) helpinfo->hItemHandle,
                          FXS_ADMIN_HLP_FILE, 
                          HELP_CONTEXTPOPUP, 
                          (DWORD) helpinfo->dwContextId 
                       ); 
            }
            break; 
 
        case WM_CONTEXTMENU: 
            
            dwHelpId = ::GetWindowContextHelpId((HWND)wParam);
            if (dwHelpId) 
            {
                ::WinHelp
                       (
                         (HWND)wParam,
                         FXS_ADMIN_HLP_FILE, 
                         HELP_CONTEXTPOPUP, 
                         dwHelpId
                       );
            }
            break; 
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\dlgsmtpconfig.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DlgSMTPConfig.h                                        //
//                                                                         //
//  DESCRIPTION   : Header file for the CDlgSMTPConfig class.              //
//                  The class implement the dialog for new Group.          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jul 20 2000 yossg   Create                                         //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef DLG_SMTP_CONFIG_H_INCLUDED
#define DLG_SMTP_CONFIG_H_INCLUDED

/////////////////////////////////////////////////////////////////////////////
// CDlgSMTPConfig

class CDlgSMTPConfig :
             public CDialogImpl<CDlgSMTPConfig>
{
public:
    CDlgSMTPConfig();

    ~CDlgSMTPConfig();

    enum { IDD = IDD_DLG_SMTP_SET };

BEGIN_MSG_MAP(CDlgSMTPConfig)
    MESSAGE_HANDLER   ( WM_INITDIALOG, OnInitDialog)
    
    COMMAND_ID_HANDLER( IDOK,          OnOK)
    COMMAND_ID_HANDLER( IDCANCEL,      OnCancel)
    
    MESSAGE_HANDLER( WM_CONTEXTMENU,  OnHelpRequest)
    MESSAGE_HANDLER( WM_HELP,         OnHelpRequest)

    COMMAND_HANDLER( IDC_SMTP_ANONIM_RADIO1, BN_CLICKED, OnRadioButtonClicked)
    COMMAND_HANDLER( IDC_SMTP_BASIC_RADIO2,  BN_CLICKED, OnRadioButtonClicked)
    COMMAND_HANDLER( IDC_SMTP_NTLM_RADIO3,   BN_CLICKED, OnRadioButtonClicked)
    
    COMMAND_HANDLER( IDC_SMTP_CREDENTIALS_BASIC_BUTTON, BN_CLICKED, OnCredentialsButtonClicked)
    COMMAND_HANDLER( IDC_SMTP_CREDENTIALS_NTLM_BUTTON,  BN_CLICKED, OnCredentialsButtonClicked)
	    
END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnRadioButtonClicked (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCredentialsButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnOK    (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    HRESULT InitSmtpDlg(FAX_ENUM_SMTP_AUTH_OPTIONS enumAuthOption, BSTR bstrUserName);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    inline const CComBSTR&  GetUserName() { return  m_bstrUserName; }

    inline CComBSTR& GetPassword()
    {     
        return m_bstrPassword;

    }

    
    inline FAX_ENUM_SMTP_AUTH_OPTIONS GetAuthenticationOption()
    {
        return m_enumAuthOption;
    }

    inline BOOL IsPasswordModified()
    {
        return m_fIsPasswordDirty;
    }

private:
    //
    // Methods
    //
    VOID   EnableOK(BOOL fEnable);
    VOID   EnableCredentialsButton(DWORD iIDC);

    //
    // members for data
    //
    BOOL      m_fIsPasswordDirty;

    CComBSTR  m_bstrUserName;
    CComBSTR  m_bstrPassword;
    
    FAX_ENUM_SMTP_AUTH_OPTIONS m_enumAuthOption;

    //
    // Dialog initialization state
    //
    BOOL      m_fIsDialogInitiated;

};

#endif // DLG_SMTP_CONFIG_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\dlgselectcountry.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : dlgSelectCountry.h                                     //
//                                                                         //
//  DESCRIPTION   : Header file for the CDlgSelectCountry class.           //
//                  The class implement the dialog for new Device.         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 30 1999 yossg   Create                                         //
//      Jan 25 2000 yossg  Change the Dialog Design                        //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef DLGSELECTCOUNTRY_H_INCLUDED
#define DLGSELECTCOUNTRY_H_INCLUDED

/////////////////////////////////////////////////////////////////////////////
// CDlgSelectCountry
class CFaxServer;

class CDlgSelectCountry :
    public CDialogImpl<CDlgSelectCountry>
{
public:
    CDlgSelectCountry(CFaxServer * pFaxServer);
    ~CDlgSelectCountry();

    enum { IDD = IDD_SELECT_COUNTRYCODE };

BEGIN_MSG_MAP(CDlgSelectCountry)
    MESSAGE_HANDLER   (WM_INITDIALOG, OnInitDialog)
    
    COMMAND_ID_HANDLER(IDOK,          OnOK)
    COMMAND_ID_HANDLER(IDCANCEL,      OnCancel)
    
    COMMAND_HANDLER(IDC_COUNTRYRULE_COMBO,  CBN_SELCHANGE, OnComboChanged)

    MESSAGE_HANDLER( WM_CONTEXTMENU,  OnHelpRequest)
    MESSAGE_HANDLER( WM_HELP,         OnHelpRequest)

END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnComboChanged           (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    HRESULT InitSelectCountryCodeDlg();

    DWORD GetCountryCode(){ return m_dwCountryCode; }

private:
    //
    // Methods
    //
    VOID    EnableOK(BOOL fEnable);
    BOOL    AllReadyToApply(BOOL fSilent);

    //
    // Members
    //
	CFaxServer *                    m_pFaxServer;

    PFAX_TAPI_LINECOUNTRY_LIST      m_pCountryList;
    DWORD                           m_dwNumOfCountries;

    BOOL                            m_fAllReadyToApply;

    //
    // Controls
    //
    CComboBox                       m_CountryCombo;
    
    DWORD                           m_dwCountryCode;
    
};

#endif // DLGSELECTCOUNTRY_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\faxextensionmethod.h ===
/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//  FILE          : FaxExtensionMethod.h                                   //
//                                                                         //
//  DESCRIPTION   : defines the prototype of Routing method				   //
//					Dialog display function.							   //
//                                                                         //
//  AUTHOR        : kereng                                                 //
//                                                                         //
//  HISTORY       :                                                        //
//      Jun 24 1999 kereng  created.                                       //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef _FAXEXTMETHOD_H_
#define _FAXEXTMETHOD_H_

#include "..\..\common\src\com\msneroot\msneroot.h"

typedef int (FaxMethodDisplayDialog)(IFaxAssociatedRoutingMethod*);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\dlgsmtpconfig.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DlgSMTPConfig.cpp                                      //
//                                                                         //
//  DESCRIPTION   : The CDlgSMTPConfig class implements the                //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jul 20 2000 yossg    Create                                        //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "DlgSMTPConfig.h"
#include "DlgConfirmPassword.h"

#include "FxsValid.h"
#include "dlgutils.h"
#include <htmlHelp.h>
#include <faxreg.h>

/////////////////////////////////////////////////////////////////////////////
// CDlgSMTPConfig

CDlgSMTPConfig::CDlgSMTPConfig()
{
    m_fIsPasswordDirty         = FALSE;
    m_fIsDialogInitiated       = FALSE;
}

CDlgSMTPConfig::~CDlgSMTPConfig()
{
}



/*
 -  CDlgSMTPConfig::InitSmtpDlg
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call,
 *      and current assined devices own parameters
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CDlgSMTPConfig::InitSmtpDlg (FAX_ENUM_SMTP_AUTH_OPTIONS enumAuthOption, BSTR bstrUserName)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSMTPConfig::InitSmtpDlg"));
    
    HRESULT hRc = S_OK;
    
    m_enumAuthOption = enumAuthOption;
    
    m_bstrUserName = bstrUserName;
    if (!m_bstrUserName )
    {
        DebugPrintEx(DEBUG_ERR,
			_T("Out of memory - Failed to Init m_bstrUserName. (ec: %0X8)"), hRc);
        //MsgBox by Caller Function
        hRc = E_OUTOFMEMORY;
        goto Exit;
    }
        
    ATLASSERT(S_OK == hRc);
    
Exit:    
    return hRc;
}

/*
 +  CDlgSMTPConfig::OnInitDialog
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgSMTPConfig::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSMTPConfig::OnInitDialog"));
    HRESULT hRc = S_OK;    

   
    switch (m_enumAuthOption)
    {
        case FAX_SMTP_AUTH_ANONYMOUS :

            CheckDlgButton(IDC_SMTP_ANONIM_RADIO1, BST_CHECKED);
            EnableCredentialsButton(IDC_SMTP_ANONIM_RADIO1);

            break;

        case FAX_SMTP_AUTH_BASIC : 

            CheckDlgButton(IDC_SMTP_BASIC_RADIO2, BST_CHECKED);
            EnableCredentialsButton(IDC_SMTP_BASIC_RADIO2);

            break;

        case FAX_SMTP_AUTH_NTLM : 

            CheckDlgButton(IDC_SMTP_NTLM_RADIO3, BST_CHECKED);
            EnableCredentialsButton(IDC_SMTP_NTLM_RADIO3);

            break;

        default:
            ATLASSERT(0);

    }
    
    m_fIsDialogInitiated = TRUE;

    EnableOK(FALSE);
    return 1;  // Let the system set the focus
}

/*
 +  CDlgSMTPConfig::OnOK
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgSMTPConfig::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSMTPConfig::OnOK"));
    HRESULT     hRc           = S_OK;
    
    //
    // Set data member data
    //
    if (IsDlgButtonChecked(IDC_SMTP_ANONIM_RADIO1) == BST_CHECKED)
    {
        m_enumAuthOption     = FAX_SMTP_AUTH_ANONYMOUS;
    }
    else 
    {
        if (IsDlgButtonChecked(IDC_SMTP_NTLM_RADIO3) == BST_CHECKED)
        {
            m_enumAuthOption = FAX_SMTP_AUTH_NTLM;
        }
        else // IsDlgButtonChecked(IDC_SMTP_BASIC_RADIO2) == BST_CHECKED
        {
            m_enumAuthOption = FAX_SMTP_AUTH_BASIC;
        }
    }

    //
    // Step 4: Close the dialog
    //
    ATLASSERT(S_OK == hRc );

    EndDialog(wID);

    goto Exit;

  
Exit:
    
    return FAILED(hRc) ? 0 : 1;
}

/*
 -  CDlgSMTPConfig::EnableCredentialsButton
 -
 *  Purpose:
 *      Enable/disable Basic Authentication dialog controls.
 *
 *  Arguments:
 *      [in] iIDC - DWORD value for the radio button selected or the 
 *                  radio above the credetials button that should be active.
 *
 *  Return:
 *      void
 */
VOID CDlgSMTPConfig::EnableCredentialsButton(DWORD iIDC)
{
    
    switch (iIDC) 
    { 
        case IDC_SMTP_ANONIM_RADIO1: 
            
            ::EnableWindow(GetDlgItem(IDC_SMTP_CREDENTIALS_BASIC_BUTTON), FALSE);
            ::EnableWindow(GetDlgItem(IDC_SMTP_CREDENTIALS_NTLM_BUTTON), FALSE);
            break;
            
        case IDC_SMTP_BASIC_RADIO2: 

            ::EnableWindow(GetDlgItem(IDC_SMTP_CREDENTIALS_BASIC_BUTTON), TRUE);
            ::EnableWindow(GetDlgItem(IDC_SMTP_CREDENTIALS_NTLM_BUTTON), FALSE);
            break; 
 
        case IDC_SMTP_NTLM_RADIO3: 
            
            ::EnableWindow(GetDlgItem(IDC_SMTP_CREDENTIALS_NTLM_BUTTON), TRUE);
            ::EnableWindow(GetDlgItem(IDC_SMTP_CREDENTIALS_BASIC_BUTTON), FALSE);
            break;
            
        default:

            ATLASSERT( 0 ); // Unexpected value
            
    } 

}


/*
 -  CDlgSMTPConfig::OnRadioButtonClicked
 -
 *  Purpose:
 *      .
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CDlgSMTPConfig::OnRadioButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER (wNotifyCode);
    UNREFERENCED_PARAMETER (hWndCtl);
    UNREFERENCED_PARAMETER (bHandled);

    DEBUG_FUNCTION_NAME( _T("CDlgSMTPConfig::OnRadioButtonClicked"));

    UINT fEnableOK;
    
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
	
    //
    // Activate OK button
    //
    if ( IsDlgButtonChecked(IDC_SMTP_ANONIM_RADIO1) == BST_CHECKED )
    {        
        EnableOK(TRUE);
    }
    else //BASIC or NTLM
    {
        ATLASSERT(IDC_SMTP_BASIC_RADIO2 == wID || IDC_SMTP_NTLM_RADIO3 == wID );
        
        fEnableOK = ( m_bstrUserName.Length() > 0 );
    
        EnableOK(!!fEnableOK);
    }

    //
    // Activate the proper Credentials button
    //
    EnableCredentialsButton(wID);
    
    return 0;
}


/*
 -  CDlgSMTPConfig::OnCredentialsButtonClicked
 -
 *  Purpose:
 *      Allow edit Credentials for the SMTP server configuration .
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CDlgSMTPConfig::OnCredentialsButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSMTPConfig::OnCredentialsButtonClicked"));
    
    INT_PTR  rc    = IDCANCEL;
    HRESULT  hRc   = S_OK;
    DWORD    dwRet = ERROR_SUCCESS;
    
    CDlgConfirmPassword DlgCredentialsConfig;


    //
    // Dialog to configure SMTP authentication mode
    //
    hRc = DlgCredentialsConfig.InitCredentialsDlg(m_bstrUserName);
    if (FAILED(hRc))
    {
        DlgMsgBox(this, IDS_MEMORY);
        goto Cleanup;
    }

    rc = DlgCredentialsConfig.DoModal();
    if (rc != IDOK)
    {
        goto Cleanup;
    }


    m_bstrUserName = DlgCredentialsConfig.GetUserName();
    if (!m_bstrUserName)        
    {
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("Null memeber BSTR - m_bstrUserName."));
    
        DlgMsgBox(this, IDS_MEMORY);

        goto Cleanup;
    }

    if ( DlgCredentialsConfig.IsPasswordModified() ) //If you got here password was also confirmed
    {
        m_bstrPassword  = DlgCredentialsConfig.GetPassword();
        if (!m_bstrPassword)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Out of memory while setting m_bstrPassword"));
           DlgMsgBox(this, IDS_MEMORY);

            goto Cleanup;
        }

        m_fIsPasswordDirty = TRUE;
    }
    else
    {
        m_bstrPassword.Empty();
    }

    EnableOK(TRUE);  


Cleanup:
    return 1;
}


/*
 -  CDlgSMTPConfig::EnableOK
 -
 *  Purpose:
 *      Enable (disable) apply button.
 *
 *  Arguments:
 *      [in] fEnable - the value to enable the button
 *
 *  Return:
 *      void
 */
VOID
CDlgSMTPConfig::EnableOK(BOOL fEnable)
{
    HWND hwndOK = GetDlgItem(IDOK);
    ::EnableWindow(hwndOK, fEnable);
}

/*
 -  CDlgSMTPConfig::OnCancel
 -
 *  Purpose:
 *      End dialog OnCancel.
 *
 *  Arguments:
 *
 *  Return:
 *      0
 */
LRESULT
CDlgSMTPConfig::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSMTPConfig::OnCancel"));

    EndDialog(wID);
    return 0;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CDlgSMTPConfig::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CDlgSMTPConfig::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CDlgSMTPConfig::OnHelpRequest"));
    
    HELPINFO* helpinfo;
    DWORD     dwHelpId;

    switch (uMsg) 
    { 
        case WM_HELP: 

            helpinfo = (HELPINFO*)lParam;
            if (helpinfo->iContextType == HELPINFO_WINDOW)
            {
                ::WinHelp(
                          (HWND) helpinfo->hItemHandle,
                          FXS_ADMIN_HLP_FILE, 
                          HELP_CONTEXTPOPUP, 
                          (DWORD) helpinfo->dwContextId 
                       ); 
            }
            break; 
 
        case WM_CONTEXTMENU: 
            
            dwHelpId = ::GetWindowContextHelpId((HWND)wParam);
            if (dwHelpId) 
            {
                ::WinHelp
                       (
                         (HWND)wParam,
                         FXS_ADMIN_HLP_FILE, 
                         HELP_CONTEXTPOPUP, 
                         dwHelpId
                       );
            }
            break; 
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\dlgutils.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : dlgutils.h                                             //
//                                                                         //
//  DESCRIPTION   : dialog utility functions                               //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Apr 29 1998 zvib    Add AdjustColumns.                             //
//      May 13 1999 roytal  Add GetIpAddrDword                             //
//      Jun 10 1999 AvihaiL Add proxy rule wizard.                         //
//                                                                         //
//      Dec 30 1999 yossg   Welcome to Fax Server.  (reduced version)      //
//      Aug 10 2000 yossg   Add TimeFormat functions                       //
//                                                                         //
//  Copyright (C) 1998 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef _DLGUTLIS_H_
#define _DLGUTLIS_H_

// CONVINIENCE MACRO FOR atl
#define ATTACH_ATL_CONTROL(member, ControlId) member.Attach(GetDlgItem(ControlId));

#define RADIO_CHECKED(idc)  ((IsDlgButtonChecked(idc) == BST_CHECKED))
#define ENABLE_CONTROL(idc, State) ::EnableWindow(GetDlgItem(idc), State);

//int  GetDlgItemTextLength(HWND hDlg, int idc);

HRESULT
ConsoleMsgBox(
	IConsole * pConsole,
	int ids,
	LPTSTR lptstrTitle = NULL,
	UINT fuStyle = MB_OK,
	int *piRetval = NULL,
	BOOL StringFromCommonDll = FALSE);

void PageError(int ids, HWND hWnd, HINSTANCE hInst = NULL);

void PageErrorEx(int idsHeader, int ids, HWND hWnd, HINSTANCE hInst = NULL);

HRESULT 
SetComboBoxItem  (CComboBox    combo, 
                  DWORD        comboBoxIndex, 
                  LPCTSTR      lpctstrFieldText,
                  DWORD        dwItemData,
                  HINSTANCE    hInst = NULL);
HRESULT 
AddComboBoxItem  (CComboBox    combo, 
                  LPCTSTR      lpctstrFieldText,
                  DWORD        dwItemData,
                  HINSTANCE    hInst = NULL);

HRESULT 
SelectComboBoxItemData  (CComboBox combo, DWORD_PTR dwItemData);

//
// Time Format Utils
//
#define FXS_MAX_TIMEFORMAT_LEN      80               //MSDN "LOCALE_STIMEFORMAT" MAX VAL

#endif //_DLGUTLIS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\faxmmcglobals.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxMMCGlobals.h                                        //
//                                                                         //
//  DESCRIPTION   : Header file for all Fax MMC global varaibles           //
//                                                                         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Nov 25 1999 yossg   Init .                                         //
//                                                                         //
//  Copyright (C) 1999  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXMMCGLOBALS_H
#define H_FAXMMCGLOBALS_H

//
// global pointer to CFaxServerNode
// which is the viewable root node of the snap-in
//       
class CFaxServerNode;

#endif  //H_FAXMMCGLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\dlgselectcountry.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : dlgSelectCountry.cpp                                   //
//                                                                         //
//  DESCRIPTION   : The CDlgSelectCountry class implements the             //
//                  dialog for selecting Country code from country ID.     //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 22 2000 yossg    Create                                        //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 2000 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "dlgSelectCountry.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "FaxMMCUtils.h"
#include "dlgutils.h"

#include "Helper.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgSelectCountry

CDlgSelectCountry::CDlgSelectCountry(CFaxServer * pFaxServer)
{    
    m_pCountryList      = NULL;
    m_dwNumOfCountries  = 0;

    m_fAllReadyToApply  = FALSE;

	ATLASSERT(pFaxServer);
	m_pFaxServer = pFaxServer;


}

CDlgSelectCountry::~CDlgSelectCountry()
{
    if (NULL != m_pCountryList)
        FaxFreeBuffer(m_pCountryList);
}

/*
 +  CDlgSelectCountry::OnInitDialog
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgSelectCountry::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSelectCountry::OnInitDialog"));
    HRESULT     hRc = S_OK;
    DWORD       ec  = ERROR_SUCCESS;
        
    HINSTANCE   hInst;
    hInst = _Module.GetResourceInstance();
    
    PFAX_TAPI_LINECOUNTRY_ENTRYW pCountryEntries;
    pCountryEntries = NULL;

    WCHAR buf[FXS_MAX_COUNTRYNAME_LEN //256 == TAPIUTIL MAX_COUNTRY_NAME 
              +3                       // " (" and ")"
              +FXS_MAX_COUNTRYCODE_LEN // 10
              +1];                     //NULL


    //
    // Attach controls
    //
    m_CountryCombo.Attach(GetDlgItem(IDC_COUNTRYRULE_COMBO));
        
    //
    // Step 1: Init List
    //
    
    //
    // Init country drop-down box
    //
    ATLASSERT(m_pCountryList);
	pCountryEntries = m_pCountryList->LineCountryEntries;    
    for (int i = 0; (DWORD)i < m_dwNumOfCountries; i++ )
    {   
		wsprintf(buf, _T("%s (%d)"),
			pCountryEntries[i].lpctstrCountryName,
			pCountryEntries[i].dwCountryCode);
        
        hRc = AddComboBoxItem ( m_CountryCombo, 
                                buf, //pCountryEntries[i].lpctstrCountryName, 
                                pCountryEntries[i].dwCountryCode,
                                hInst);
        if (FAILED(hRc))
        {
		    DebugPrintEx( DEBUG_ERR, _T("Fail to load country list."));
            PageError(IDS_FAIL2LOADCOUNTRYLIST, m_hWnd, hInst);
            ::EnableWindow(GetDlgItem(IDC_COUNTRYRULE_COMBO), FALSE);
            goto Cleanup;
        }

    }


Cleanup:
    EnableOK(FALSE);
    return 1;  // Let the system set the focus
}

/*
 +  CDlgSelectCountry::OnOK
 +
 *  Purpose:
 *      Submit data
 *      
 *  Arguments:
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgSelectCountry::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSelectCountry::OnOK"));
    HRESULT       hRc                  = S_OK;
    DWORD         ec                   = ERROR_SUCCESS;
    BOOL          fSkipMessage         = FALSE;

    int           iCurrentSelectedItem = 0;
    
    DWORD         dwCountryCode        = 0;

    //
    // Step 0: PreApply Checks
    //
    ATLASSERT( TRUE == m_fAllReadyToApply );
    if (!AllReadyToApply(/*fSilent =*/ FALSE))
    {
        EnableOK(FALSE);
        hRc =S_FALSE;
        goto Exit;
    }

    //
    // Step 1: get selected country 
    //
    iCurrentSelectedItem = m_CountryCombo.GetCurSel();
    ATLASSERT(iCurrentSelectedItem != CB_ERR);          
    
    //
    // Step 2: setCountryCode from the ItemData
    //   
    m_dwCountryCode = (DWORD)m_CountryCombo.GetItemData(iCurrentSelectedItem); 

    //
    // Step 3: Close the dialog
    //
    ATLASSERT(S_OK == hRc && ERROR_SUCCESS == ec);

    DebugPrintEx( DEBUG_MSG,
		_T("The rule was added successfully."));

    EndDialog(wID);

    goto Exit;
  
Exit:    
    return FAILED(hRc) ? 0 : 1;
}


/*
 -  CDlgSelectCountry::OnComboChanged
 -
 *  Purpose:
 *      Gray/Ungray the submit button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT 
CDlgSelectCountry::OnComboChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSelectCountry::OnComboChanged"));

    if (AllReadyToApply(TRUE))
    {
        m_fAllReadyToApply = TRUE;
        EnableOK(TRUE);
    }
    else
    {
        m_fAllReadyToApply = FALSE;
        EnableOK(FALSE);
    }

    return 1;
}


/*
 -  CDlgSelectCountry::AllReadyToApply
 -
 *  Purpose:
 *      Enable/Disable the submit button.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE if all ready to apply, else FALSE.
 */
BOOL 
CDlgSelectCountry::AllReadyToApply(BOOL fSilent)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSelectCountry::AllReadyToApply"));
	
    if ( CB_ERR  ==  m_CountryCombo.GetCurSel())
    {
        if (!fSilent)
        {
            DlgMsgBox(this, IDS_PLEASESELECT_COUNTRY);
            ::SetFocus(GetDlgItem(IDC_COUNTRYRULE_COMBO));
        }
        return FALSE;
    }

 
    return TRUE;           
}

/*
 -  CDlgSelectCountry::EnableOK
 -
 *  Purpose:
 *      Enable/Disable the submit button.
 *
 *  Arguments:
 *      [in] fEnable - boolen value tells 
 *                     to Enable or Disable the OK button.
 *
 *  Return:
 *      VOID
 */
VOID
CDlgSelectCountry::EnableOK(BOOL fEnable)
{
    HWND hwndOK = GetDlgItem(IDOK);
    ::EnableWindow(hwndOK, fEnable);
}

/*
 -  CDlgSelectCountry::OnCancel
 -
 *  Purpose:
 *      End the dialog.
 *
 *  Arguments:
 *
 *  Return:
 *      0
 */
LRESULT
CDlgSelectCountry::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSelectCountry::OnCancel"));

    EndDialog(wID);
    return 0;
}

/*
 -  CDlgSelectCountry::InitSelectCountryCodeDlg
 -
 *  Purpose:
 *      Init all the members as country list pointer and 
 *      device list pointer
 *
 *  Arguments:
 *      No.
 *
 *  Return:
 *      0
 */
HRESULT CDlgSelectCountry::InitSelectCountryCodeDlg()
{
    DEBUG_FUNCTION_NAME( _T("CDlgSelectCountry::InitSelectCountryCodeDlg"));
    HRESULT      hRc        = S_OK; 
    DWORD        ec         = ERROR_SUCCESS;

    
    //
    // Step 1: Init Lists from RPC
    //

    //
    // get Fax Handle
    //   

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }


    //
    // Country (code ,name)
    //
    if (!FaxGetCountryList(m_pFaxServer->GetFaxServerHandle(), 
                        &m_pCountryList)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get c TAPI country list. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	ATLASSERT(m_pCountryList);
    m_dwNumOfCountries = m_pCountryList->dwNumCountries;
    

    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get all configurations."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
    
    //MsgBox will be done by calling Func.

Exit:
    return hRc;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CDlgSelectCountry::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CDlgSelectCountry::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CDlgSelectCountry::OnHelpRequest"));
    
    HELPINFO* helpinfo;
    DWORD     dwHelpId;

    switch (uMsg) 
    { 
        case WM_HELP: 

            helpinfo = (HELPINFO*)lParam;
            if (helpinfo->iContextType == HELPINFO_WINDOW)
            {
                ::WinHelp(
                          (HWND) helpinfo->hItemHandle,
                          FXS_ADMIN_HLP_FILE, 
                          HELP_CONTEXTPOPUP, 
                          (DWORD) helpinfo->dwContextId 
                       ); 
            }
            break; 
 
        case WM_CONTEXTMENU: 
            
            dwHelpId = ::GetWindowContextHelpId((HWND)wParam);
            if (dwHelpId) 
            {
                ::WinHelp
                       (
                         (HWND)wParam,
                         FXS_ADMIN_HLP_FILE, 
                         HELP_CONTEXTPOPUP, 
                         dwHelpId
                       );
            }
            break; 
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\dlgutils.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : dlgutils.cpp                                           //
//                                                                         //
//  DESCRIPTION   : dialog utility funcs                                   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 30 1999 yossg   Welcome to Fax Server.                         //
//      Aug 10 2000 yossg   Add TimeFormat functions                       //
//                                                                         //
//  Copyright (C) 1998 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "dlgutils.h"

HRESULT
ConsoleMsgBox(
	IConsole * pConsole,
	int ids,
	LPTSTR lptstrTitle,
	UINT fuStyle,
	int *piRetval,
	BOOL StringFromCommonDll)
{  
    UNREFERENCED_PARAMETER(StringFromCommonDll);

    HRESULT     hr;
    int         dummy, rc;
    WCHAR       szText[256];
    int         *pres = (piRetval)? piRetval: &dummy;
    
    ATLASSERT(pConsole);   

    rc = ::LoadString(
                _Module.GetResourceInstance(),ids, szText, 256);
    if (rc <= 0)
    {        
        return E_FAIL;
    }
    
    //
    // Display the message box 
    //
    if(IsRTLUILanguage())
    {
        fuStyle |= MB_RTLREADING | MB_RIGHT;
    }

    hr = pConsole->MessageBox(szText, lptstrTitle, fuStyle, pres);

    return hr;
}

void PageError(int ids, HWND hWnd, HINSTANCE hInst /* = NULL */)
{
    WCHAR msg[FXS_MAX_ERROR_MSG_LEN+1], title[FXS_MAX_TITLE_LEN+1];
    if (!hInst)
    {
        hInst = _Module.GetResourceInstance();
    }
    LoadString(hInst, ids, msg, FXS_MAX_ERROR_MSG_LEN);
    LoadString(hInst, IDS_ERROR, title, FXS_MAX_TITLE_LEN);
    AlignedMessageBox(hWnd, msg, title, MB_OK|MB_ICONERROR);
}

void PageErrorEx(int idsHeader, int ids, HWND hWnd, HINSTANCE hInst /* = NULL */)
{
    WCHAR msg[FXS_MAX_ERROR_MSG_LEN+1]; 
    WCHAR title[FXS_MAX_TITLE_LEN+1];
    if (!hInst)
    {
        hInst = _Module.GetResourceInstance();
    }
    LoadString(hInst, idsHeader, title, FXS_MAX_TITLE_LEN);
    LoadString(hInst, ids, msg, FXS_MAX_ERROR_MSG_LEN);
    AlignedMessageBox(hWnd, msg, title, MB_OK|MB_ICONERROR);
}

HRESULT 
SetComboBoxItem  (CComboBox    combo, 
                  DWORD        comboBoxIndex, 
                  LPCTSTR      lpctstrFieldText,
                  DWORD        dwItemData,
                  HINSTANCE    hInst)
{
    DEBUG_FUNCTION_NAME( _T("SetComboBoxItem"));

    HRESULT     hRc = S_OK;

    if (!hInst)
    {
        hInst = _Module.GetResourceInstance();
    }


    //
    // place the string in the combobox
    //
    hRc = combo.InsertString (comboBoxIndex, lpctstrFieldText);
    if (hRc == CB_ERR)
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("failed to insert string '%s' to combobox at index %d"), 
               lpctstrFieldText, comboBoxIndex);

        goto Cleanup;
    }

    //
    // attach to the combobox item its index (usually, its his enumerated type)
    //
    hRc = combo.SetItemData (comboBoxIndex, dwItemData);
    if (CB_ERR == hRc)
    {
        DebugPrintEx(
            DEBUG_ERR,
               _T("SetItemData failed when setting items %s data to the value of %d"), 
               lpctstrFieldText, dwItemData);

        goto Cleanup;
    }

Cleanup:
    return hRc;
}


HRESULT 
AddComboBoxItem  (CComboBox    combo, 
                  LPCTSTR      lpctstrFieldText,
                  DWORD        dwItemData,
                  HINSTANCE    hInst)
{
    DEBUG_FUNCTION_NAME( _T("SetComboBoxItem"));

    HRESULT     hRc = S_OK;
    int iIndex;

    if (!hInst)
    {
        hInst = _Module.GetResourceInstance();
    }
    
    //
    // place the string in the combobox
    //
    iIndex = combo.AddString(lpctstrFieldText);
    if (iIndex == CB_ERR)
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("failed to insert string '%s' to combobox "), 
               lpctstrFieldText);
        hRc = S_FALSE;
        goto Cleanup;
    }

    //
    // attach to the combobox item its index (usually, its his enumerated type)
    //
    hRc = combo.SetItemData (iIndex, dwItemData);
    if (CB_ERR == hRc)
    {
        DebugPrintEx(
            DEBUG_ERR,
               _T("SetItemData failed when setting items %s data to the value of %d"), 
               lpctstrFieldText, dwItemData);

        goto Cleanup;
    }
    
    //ATLASSERT( S_OK == hRc);

Cleanup:
    return hRc;
}


HRESULT 
SelectComboBoxItemData (CComboBox combo, DWORD_PTR dwItemData)
{
    HRESULT     hRc = S_OK;
    int         NumItems;
    int         i;
    int         selectedItem;
    DWORD_PTR   currItemData;

    DEBUG_FUNCTION_NAME( _T("SelectComboBoxItemData"));

    //
    // scan the items in the combobox and find the item with the specific data
    //
    i        = 0;
    NumItems = combo.GetCount ();
    
    for (i = 0; i < NumItems; i++)
    {
        currItemData = combo.GetItemData (i);
        ATLASSERT (currItemData != CB_ERR);// Cant get the data of item %d of combobox, i
        if (currItemData == dwItemData)
        {
            //
            // select it
            //
            selectedItem = combo.SetCurSel (i);

            ATLASSERT (selectedItem != CB_ERR); //Cant select item %d of combobox, i
            
            DebugPrintEx(
                    DEBUG_MSG,
                    _T("Selected item %d (with data %d) of combobox"), i, dwItemData);
            
            goto Cleanup;
        }
    }

Cleanup:
    return hRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\faxmmcutils.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxMMCUtils.h                                          //
//                                                                         //
//  DESCRIPTION   : Header file for all Fax MMC private Utilities          //
//                                                                         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Nov 25 1999 yossg   Init .                                         //
//                                                                         //
//  Copyright (C) 1999  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////
#ifndef H_FAXMMCUTILS_H
#define H_FAXMMCUTILS_H

//
//
//
int GetFaxServerErrorMsg(DWORD dwEc);

//
//
//
BOOL IsNetworkError(DWORD dwEc);

//
//
//
int CALLBACK BrowseCallbackProc(HWND hWnd, UINT uMsg, LPARAM lParam, LPARAM lpData);

//
//
//
BOOL
InvokeBrowseDialog( LPTSTR lpszBrowseItem, 
                    LPCTSTR lpszBrowseDlgTitle,
                    unsigned long ulBrowseFlags,
                    CWindow *pWin);

#endif //H_FAXMMCUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\faxserver.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxServer.h                                            //
//                                                                         //
//  DESCRIPTION   : Header file for CFaxServer that contains the           //
//                  Connect / Disconnect functionality to the Fax Server   //
//                                                                         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Nov 25 1999 yossg   Init .                                         //
//      Aug  3 2000 yossg   Add notification window                        //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_MMCFAXSERVER_H
#define H_MMCFAXSERVER_H

class CFaxDevicesNode;
class CFaxGeneralNotifyWnd;

class CFaxServer 
{
public:
    //
    // Constructor
    //
    CFaxServer (LPTSTR lptstrServerName)
    {
        m_hFaxHandle                 = NULL;
        m_bstrServerName             = lptstrServerName;
        
        
        m_pDevicesNode               = NULL;
        m_pNotifyWin                 = NULL;

        m_hDevicesStatusNotification = NULL;
    }

    //
    // Destructor
    //
    ~CFaxServer ()
    {
        Disconnect();

        DestroyNotifyWindow();
    }
    
    HANDLE  GetFaxServerHandle();

    HRESULT Disconnect();

    STDMETHOD      (SetServerName)(BSTR bstrServerName);
    const CComBSTR& GetServerName();
    
    BOOL    IsServerRunningFaxService ();
    BOOL    IsServerFaxServiceStopped ();

    HRESULT RegisterForDeviceNotifications(CFaxDevicesNode * pDevices);

    HRESULT OnNewEvent(PFAX_EVENT_EX pFaxEvent);


private:
    HRESULT Connect();

    HRESULT InternalRegisterForDeviceNotifications();

    DWORD   CreateNotifyWindow();
    DWORD   RegisterForNotifications();
    
    HRESULT UnRegisterForNotifications();
    VOID    DestroyNotifyWindow();

    //
    // members
    //
    HANDLE                m_hFaxHandle;
    CComBSTR              m_bstrServerName;

    CFaxDevicesNode *     m_pDevicesNode;
    CFaxGeneralNotifyWnd* m_pNotifyWin;

    //
    // Notification registration handle
    //
    HANDLE                m_hDevicesStatusNotification;       
};


#endif  //H_MMCFAXSERVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\faxserver.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxServer.cpp                                          //
//                                                                         //
//  DESCRIPTION   : CFaxServer that contains the                           //
//                  Connect / Disconnect functionality to the Fax Server   //
//                                                                         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Nov 25 1999 yossg   Init .                                         //
//      Aug  3 2000 yossg   Add notification window                        //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "FaxServer.h"

#include "Devices.h"
#include "GeneralNotifyWnd.h"

#include <FaxReg.h>

/*
 -  CFaxServer::GetFaxServerHandle
 -
 *  Purpose:
 *      If Handle does not exist re-connect.
 *      Retreives the Fax Server handle.
 *
 *  Arguments:
 *
 *  Return:
 *      Fax Server handle, if failed to connect 
 *      retrieves NULL
 */
HANDLE CFaxServer::GetFaxServerHandle()
{
    if (!m_hFaxHandle)
    {
        ATLASSERT (!m_hDevicesStatusNotification);
        
        HRESULT hRc = Connect();
        if ( FAILED(hRc))
        {
            // DebugPrintEx(DEBUG_ERR) 
            // should been already given by
            // this function caller.
        }
    }
    return m_hFaxHandle;
}

/*
 -  CFaxServer::Connect
 -
 *  Purpose:
 *      Connect to the Fax Server.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
HRESULT CFaxServer::Connect()
{
    DEBUG_FUNCTION_NAME(TEXT("CFaxServer::Connect"));
    DWORD  ec = ERROR_SUCCESS;

    ATLASSERT(!m_hFaxHandle);

    //
    // Connect to server
    //
    if (!FaxConnectFaxServer (m_bstrServerName, &m_hFaxHandle))
    {
        ec= GetLastError();

        DebugPrintEx(
			DEBUG_ERR,
			_T("FaxConnectFaxServer() Failed to %ws. (ec: %ld)"), 
            ((!m_bstrServerName) || (m_bstrServerName == L""))? L"local machine" : m_bstrServerName.m_str,
            ec);
        
        m_hFaxHandle = NULL;
        return HRESULT_FROM_WIN32(ec);
    }
    ATLASSERT(m_hFaxHandle);
    
    //
    // Verify or re-establish (if needed) notification setup
    //
    if (m_pDevicesNode)
    {
        HRESULT hRc = InternalRegisterForDeviceNotifications();
        if (S_OK != hRc)
        {
            DebugPrintEx(
		        DEBUG_ERR,
		            _T("InternalRegisterForDeviceNotifications Failed. (hRc: %08X)"),
                    hRc);
        }
    }
    
    
    DebugPrintEx(
		DEBUG_MSG,
		_T("FaxConnectFaxServer() succeeded. Handle: %08X"),
        m_hFaxHandle);

    return S_OK;
}

/*
 -  CFaxServer::Disconnect
 -
 *  Purpose:
 *      Disconnect from the Fax Server.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
HRESULT CFaxServer::Disconnect()
{
    DEBUG_FUNCTION_NAME(TEXT("CFaxServer::Disconnect"));
    
    HRESULT hRc = S_OK;
    DWORD   ec;

    if (NULL == m_hFaxHandle)
    {
        hRc = E_FAIL;
        DebugPrintEx(
			DEBUG_MSG,
			_T("No connection handle exists. (m_hFaxHandle is NULL)\n Connection may not started or disconnected before.\n "));
        
        return hRc;
    }

    hRc = UnRegisterForNotifications();
    if (S_OK != hRc)
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("UnRegisterForNotifications() failed. (hRc: %0X8)"), 
			hRc);

        // continue!!!
    }

    if (!FaxClose (m_hFaxHandle))
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("FaxClose() failed. (ec: %ld)"), 
			ec);
        
        
        hRc = HRESULT_FROM_WIN32(ec);
        
        goto Cleanup; 
    }

    DebugPrintEx( DEBUG_MSG,
		_T("Succeeded to close connection to Fax. ServerHandle: %08X"),
        m_hFaxHandle);

Cleanup:
    
    m_hFaxHandle = NULL;
    
    return hRc;
}



/*
 -  CFaxServer::SetServerName
 -
 *  Purpose:
 *      Set the Server machine name
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxServer::SetServerName(BSTR bstrServerName)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::SetServerName"));
    HRESULT hRc = S_OK;

    m_bstrServerName = bstrServerName;
    if (!m_bstrServerName)
    {
        hRc = E_OUTOFMEMORY;
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to allocate string - out of memory"));
               
        m_bstrServerName = L"";
    }

    return hRc;
}



/*
 -  CFaxServer::GetServerName
 -
 *  Purpose:
 *      Set the Server machine name
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
const CComBSTR& CFaxServer::GetServerName()
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::GetServerName"));

    return m_bstrServerName;
}


/*
 +
 +
 *  CFaxServer::IsServerRunningFaxService
 *
 *  Purpose:
 *      Contacts the machine and determines if Fax Server Service is running.
 *
 *  Arguments:
 *
 *  Return:
 *      boolean value Running or notruning
 -
 -
 */
BOOL  CFaxServer::IsServerRunningFaxService ( )
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::IsServerRunningFaxService"));
    
    SC_HANDLE       SCMHandle = NULL;
    SC_HANDLE       FXSHandle = NULL;
    SERVICE_STATUS  SStatus;
    BOOL            bRun = FALSE;

    if (
        (SCMHandle = OpenSCManager(m_bstrServerName, NULL, GENERIC_READ)) 
        &&
        (FXSHandle = OpenService(SCMHandle, FAX_SERVICE_NAME, SERVICE_QUERY_STATUS)) 
        &&
        QueryServiceStatus(FXSHandle, &SStatus) 
        &&
        (SERVICE_RUNNING == SStatus.dwCurrentState) 
       )
    {
        bRun = TRUE;
    }  

    if (FXSHandle)
    {
        CloseServiceHandle(FXSHandle);
    }
    else // FXSHandle == NULL
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to Open Fax Server Service. (ec: %ld)"), 
			GetLastError());
    }

    if (SCMHandle)
    {
        CloseServiceHandle(SCMHandle);
    }
    else // SCMHandle == NULL
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to OpenSCManager. (ec: %ld)"), 
			GetLastError());
    }

    return bRun;
}


/*
 +
 +
 *  CFaxServer::IsServerFaxServiceStopped
 *
 *  Purpose:
 *      Contacts the machine and determines if Fax Server Service is already stopped.
 *
 *  Arguments:
 *      [in] bstrServerName - the server name 
 *
 *  Return:
 *      boolean value Running or notruning
 -
 -
 */
BOOL  CFaxServer::IsServerFaxServiceStopped( )
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::IsServerFaxServiceStopped"));
    
    SC_HANDLE       SCMHandle = NULL;
    SC_HANDLE       FXSHandle = NULL;
    SERVICE_STATUS  SStatus;
    BOOL            bRun = FALSE;

    if (
        (SCMHandle = OpenSCManager(m_bstrServerName, NULL, GENERIC_READ)) 
        &&
        (FXSHandle = OpenService(SCMHandle, FAX_SERVICE_NAME, SERVICE_QUERY_STATUS)) 
        &&
        QueryServiceStatus(FXSHandle, &SStatus) 
        &&
        (SERVICE_STOPPED == SStatus.dwCurrentState) 
       )
    {
        bRun = TRUE;
    }  

    if (FXSHandle)
    {
        CloseServiceHandle(FXSHandle);
    }
    else // FXSHandle == NULL
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to Open Fax Server Service. (ec: %ld)"), 
			GetLastError());
    }

    if (SCMHandle)
    {
        CloseServiceHandle(SCMHandle);
    }
    else // SCMHandle == NULL
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to OpenSCManager. (ec: %ld)"), 
			GetLastError());
    }

    return bRun;
}


/*
 +
 +
 *  CFaxServer::CreateNotifyWindow
 *
 *  Purpose:
 *     Init notification window 
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 -
 -
 */
DWORD  CFaxServer::CreateNotifyWindow( )
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::CreateNotifyWindow"));
    
    DWORD   ec = ERROR_SUCCESS;
    RECT	rcRect;
    ZeroMemory(&rcRect, sizeof(rcRect));
    HWND    hDevicesNotifyHandle;

    ATLASSERT(!m_pNotifyWin);
        
    m_pNotifyWin = new CFaxGeneralNotifyWnd(this);
    if (!m_pNotifyWin)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        SetLastError(ec); 
		
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to create CFaxGeneralNotifyWnd - Out of memory."));
        
        goto Exit;
    }


    hDevicesNotifyHandle = m_pNotifyWin->Create(NULL,
                            rcRect,
                            NULL,      //LPCTSTR szWindowName
                            WS_POPUP,  //DWORD dwStyle
                            0x0,
                            0);


    ATLASSERT(m_pNotifyWin->m_hWnd == m_hDevicesNotifyHandle);


    if (!(::IsWindow(hDevicesNotifyHandle)))
    {
		ec = ERROR_INVALID_HANDLE;
        
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to create window."));

        hDevicesNotifyHandle = NULL;
        delete m_pNotifyWin;
        m_pNotifyWin = NULL;

        goto Exit;
    }
    ATLASSERT(ERROR_SUCCESS == ec);
    goto Exit;
 
Exit:
    return ec;

}

/*
 +
 +
 *  CFaxServer::UnRegisterForNotifications
 *
 *  Purpose:
 *     UnRegisterFor Server Event Notifications 
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 -
 -
 */
HRESULT CFaxServer::UnRegisterForNotifications()
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::UnRegisterForNotifications"));

    DWORD ec = ERROR_SUCCESS;

    if (m_hDevicesStatusNotification)
    {
        //
        // Unregister server notifications
        //
        if (!FaxUnregisterForServerEvents (m_hDevicesStatusNotification))
        {
            DWORD ec = GetLastError ();
        
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Fail to Unregister For Device status Server Events. (ec: %ld)"), 
			    ec);

            m_hDevicesStatusNotification = NULL;

            goto Exit;
        }
    }

Exit:
    return HRESULT_FROM_WIN32(ec);
    
}



/*
 +
 +
 *  CFaxServer::RegisterForNotification
 *
 *  Purpose:
 *     RegisterFor Server Event Notifications 
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 -
 -
 */
DWORD CFaxServer::RegisterForNotifications()
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::RegisterForNotifications"));

    DWORD ec = ERROR_SUCCESS;

    //
    // Register for device status notification
    //
    ATLASSERT(!m_hDevicesStatusNotification);
    ATLASSERT(m_pNotifyWin);
    ATLASSERT(m_pNotifyWin->IsWindow());

    if (!FaxRegisterForServerEvents (   
                                      m_hFaxHandle,
                                      FAX_EVENT_TYPE_DEVICE_STATUS,               
                                      NULL,                       
                                      0,                          
                                      m_pNotifyWin->m_hWnd,                    
                                      WM_GENERAL_EVENT_NOTIFICATION, 
                                      &m_hDevicesStatusNotification
                                    )                   
        )
    {
        ec = GetLastError();

        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to Register For Device Status Server Events (ec: %ld)"), ec);

        m_hDevicesStatusNotification = NULL;

        goto Exit;
    }
    ATLASSERT(m_hDevicesStatusNotification);
Exit:
    return ec;
    
}



/*
 +
 +
 *  CFaxServer::InternalRegisterForDeviceNotifications
 *
 *  Purpose:
 *     Call the members to create window and register for device notifications 
 *
 *  Arguments:
 *     non.
 *
 *  Return:
 *     HRESULT
 -
 -
 */
HRESULT CFaxServer::InternalRegisterForDeviceNotifications()
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::InternalRegisterForDeviceNotifications"));
    
    DWORD ec = ERROR_SUCCESS;

    ATLASSERT (m_pDevicesNode);
        
    //
    // Check/Create notification window
    //
    if (!m_pNotifyWin)  
    {
        ATLASSERT(!m_hDevicesStatusNotification);
        
        ec = CreateNotifyWindow();
        if ( ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
			    DEBUG_MSG,
			    _T("Fail to CreateNotifyWindow(). (ec: %ld)"), 
			    ec);

            return HRESULT_FROM_WIN32(ec);
        }
    }
    ATLASSERT(m_pNotifyWin);

    //
    // Check/register to event notification
    //
    if (!m_hDevicesStatusNotification) 
    {
        ec = RegisterForNotifications();
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
		        DEBUG_ERR,
		        _T("Fail to RegisterForNotification()"),
                ec);
        
            ATLASSERT(!m_hDevicesStatusNotification);

            //
            // Keep the notification window alive. 
            // Try next time to register only.
            //

            return HRESULT_FROM_WIN32(ec);
        }
        ATLASSERT(m_hDevicesStatusNotification);
    }

    return S_OK;
}





/*
 +
 +
 *  CFaxServer::OnNewEvent
 *
 *  Purpose:
 *     Called when new registered event reaches window 
 *
 *  Arguments:
 *     pFaxEvent [in] - PFAX_EVENT_EX structure pointer
 *
 *  Return:
 *     OLE error code
 -
 -
 */
HRESULT CFaxServer::OnNewEvent(PFAX_EVENT_EX pFaxEvent)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::OnNewEvent"));
    HRESULT hRc = S_OK;

	//
    // Update "Devices" Node
    //
    if ( FAX_EVENT_TYPE_DEVICE_STATUS == pFaxEvent->EventType )
    {
        ATLASSERT( m_pDevicesNode);

        hRc = m_pDevicesNode->UpdateDeviceStatusChange(
                                    pFaxEvent->EventInfo.DeviceStatus.dwDeviceId, 
                                    pFaxEvent->EventInfo.DeviceStatus.dwNewStatus);
        if (S_OK != hRc)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Failed to UpdateDeviceStatusChange()"));

            goto Exit;
        }
    }
    else
    {
        ATLASSERT(FALSE); //Unsupported EVENT
    }

Exit:
    return hRc;

}

/*
 +
 +
 *  CFaxServer::RegisterForDeviceNotifications
 *
 *  Purpose:
 *     Init Devices notification window 
 *
 *  Arguments:
 *     pDevices [in] - pointer to "devices" node
 *
 *  Return:
 *     OLE error code
 -
 -
 */
HRESULT CFaxServer::RegisterForDeviceNotifications(CFaxDevicesNode * pDevices)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::RegisterForDeviceNotifications"));
    HRESULT hRc = S_OK;

	//
    // Set pointer to Devices node
    //
    m_pDevicesNode = pDevices;

    ATLASSERT (m_pDevicesNode);

    //
    // Now try to do the stages needed for this registration to happen
    //
    hRc = InternalRegisterForDeviceNotifications();
    if (S_OK != hRc)
    {
        DebugPrintEx(
		    DEBUG_ERR,
		        _T("InternalRegisterForDeviceNotifications Failed. (hRc: %08X)"),
                hRc);
    }

    return hRc;
}


/*
 +
 +
 *  CFaxServer::DestroyNotifyWindow
 *
 *  Purpose:
 *     DestroyNotifyWindow 
 *
 *  Arguments:
 *
 *  Return:
 *     VOID
 -
 -
 */
VOID CFaxServer::DestroyNotifyWindow()
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::DestroyNotifyWindow"));

    //
    // Destroy Notification Window
    //
    if (NULL != m_pNotifyWin)
    {
        if (m_pNotifyWin->IsWindow())
        {
            m_pNotifyWin->DestroyWindow();
        }
        delete m_pNotifyWin;
        m_pNotifyWin = NULL;
    }


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\faxservernode.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxServerNode.cpp                                      //
//                                                                         //
//  DESCRIPTION   : Fax Server MMC node creation.                          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 22 1999 yossg   Init .                                         //
//      Nov 24 1999 yossg   Rename file from FaxCfg                        //
//      Dec  9 1999 yossg   Call InitDisplayName from parent               //
//      Feb  7 2000 yossg   Add Call to CreateSecurityPage          	   //
//      Mar 16 2000 yossg   Add service start-stop                         //
//      Jun 25 2000 yossg   Add stream and command line primary snapin 	   //
//                          machine targeting.                             //
//      Oct 17 2000 yossg                                                  //
//      Dec 10 2000 yossg  Update Windows XP                               //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "FaxServerNode.h"
//
//Child Nodes H files
//
#include "DevicesAndProviders.h"
#include "OutboundRouting.h"
#include "InboundRouting.h"
#include "CoverPages.h"

#include "SecurityInfo.h"  //which includes also <aclui.h>

#include "WzConnectToServer.h"
          

#include <faxreg.h>
#include "Icons.h"

#include "oaidl.h"


//
//CFaxServerNode Class
//

/////////////////////////////////////////////////////////////////////////////
// {7A4A6347-A42A-4d36-8538-6634CD3C3B15}
static const GUID CFaxServerNodeGUID_NODETYPE = 
{ 0x7a4a6347, 0xa42a, 0x4d36, { 0x85, 0x38, 0x66, 0x34, 0xcd, 0x3c, 0x3b, 0x15 } };

const GUID*    CFaxServerNode::m_NODETYPE = &CFaxServerNodeGUID_NODETYPE;
const OLECHAR* CFaxServerNode::m_SZNODETYPE = OLESTR("7A4A6347-A42A-4d36-8538-6634CD3C3B15");
const CLSID*   CFaxServerNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxServerNode::m_ColsInfo;

/*
 -  CFaxServerNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxServerNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    HRESULT hRc;

    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::InsertColumns"));

    static ColumnsInfoInitData ColumnsInitData[] =
    {
        {IDS_FAX_COL_HEAD, FXS_LARGE_COLUMN_WIDTH}, 
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    if (hRc != S_OK)
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to InsertColumnsIntoMMC. hRc: %08X "), 
			hRc);
        goto Cleanup;
    }

Cleanup:
    return(hRc);
}

/*
 -  CFaxServerNode::PopulateScopeChildrenList
 -
 *  Purpose:
 *      Create all the Fax nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxServerNode::PopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::PopulateScopeChildrenList"));

    HRESULT   hRc = S_OK;

    CFaxDevicesAndProvidersNode *       pDevicesAndProviders = NULL;
    CFaxInboundRoutingNode *            pIn                  = NULL;
    CFaxOutboundRoutingNode *           pOut                 = NULL;
    CFaxCoverPagesNode *                pCoverPages          = NULL;

    CFaxServer *                        pFaxServer           = NULL;

    //
    // Prepare IConsoleNameSpace for case of failure
    //
    ATLASSERT(m_pComponentData);
    ATLASSERT( ((CSnapin*)m_pComponentData)->m_spConsole );
    CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace( ((CSnapin*)m_pComponentData)->m_spConsole );
    ATLASSERT( spConsoleNameSpace );

    HRESULT hr = S_OK; 

    if (m_IsPrimaryModeSnapin)
    {
        if (m_IsLaunchedFromSavedMscFile)
        {
            hRc = ForceRedrawNode();
            if ( S_OK != hRc )
            {
                //msgbox and dbgerr by called func.
                return hRc;
            }
        }
    }

    //
    // Preliminary connection-test
    //
    pFaxServer = GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        DWORD ec= GetLastError();
        DebugPrintEx(
                  DEBUG_ERR,
                  _T("Failed to check connection to server. (ec: %ld)"), 
                  ec);
        
        pFaxServer->Disconnect();       

        NodeMsgBox(IDS_NETWORK_PROBLEMS, MB_OK|MB_ICONEXCLAMATION);
    }

    //
    //Devices And Providers
    //
    pDevicesAndProviders = new CFaxDevicesAndProvidersNode(this, m_pComponentData);
    if (!pDevicesAndProviders)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
        DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("Out of memory"));
        goto Error;
    }
    else
    {
        pDevicesAndProviders->InitParentNode(this);

        hRc = pDevicesAndProviders->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_AllDEVICES);
		    goto Error;
        }

        pDevicesAndProviders->SetIcons(IMAGE_FOLDER_CLOSE, IMAGE_FOLDER_OPEN);

        hRc = AddChild(pDevicesAndProviders, &pDevicesAndProviders->m_scopeDataItem);
        if (FAILED(hRc))
        {
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("Fail to add devices and providers node. (hRc: %08X)"),
                   hRc);
            NodeMsgBox(IDS_FAILTOADD_AllDEVICES);
            goto Error;
        }
    }

    //
    // Fax Inbound Routing
    //
    pIn = new CFaxInboundRoutingNode(this, m_pComponentData);
    if (!pIn)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
        DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("Out of memory"));
        goto Error;
    }
    else
    {
        pIn->InitParentNode(this);

        pIn->SetIcons(IMAGE_FOLDER_CLOSE, IMAGE_FOLDER_OPEN);

        hRc = pIn->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_INBOUNDROUTING);
		    goto Error;
        }

        hRc = AddChild(pIn, &pIn->m_scopeDataItem);
        if (FAILED(hRc))
        {
            DebugPrintEx(
               DEBUG_ERR,
               TEXT("Fail to add inbound routing node. (hRc: %08X)"),
               hRc);
            NodeMsgBox(IDS_FAILTOADD_INBOUNDROUTING);
            goto Error;
        }
    }

    //
    // Fax Outbound Routing
    //
    pOut = new CFaxOutboundRoutingNode(this, m_pComponentData);
    if (!pOut)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
		DebugPrintEx(
                DEBUG_ERR,
                TEXT("Out of memory"));
        goto Error;
    }
    else
    {
        pOut->InitParentNode(this);

        pOut->SetIcons(IMAGE_FOLDER_CLOSE, IMAGE_FOLDER_OPEN);

        hRc = pOut->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_OUTBOUNDROUTING);
		    goto Error;
        }

        hRc = AddChild(pOut, &pOut->m_scopeDataItem);
        if (FAILED(hRc))
        {
            DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("Fail to add outbound routing node. (hRc: %08X)"),
                 hRc);
            NodeMsgBox(IDS_FAILTOADD_OUTBOUNDROUTING);
            goto Error;
        }
    }

    //
    // CoverPages
    //
    pCoverPages = new CFaxCoverPagesNode(this, m_pComponentData);
    if (!pCoverPages)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Out of memory"));
        goto Error;
    }
    else
    {
        pCoverPages->InitParentNode(this);
        
        hRc = pCoverPages->Init();
        if ( FAILED(hRc) )
        {
            if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hRc)
            {
                DebugPrintEx(
                    DEBUG_ERR, //Dbg Warning only !!!
                    _T("Cover pages folder was not found. (hRc: %08X)"), hRc);                       
		        
                NodeMsgBox(IDS_COVERPAGES_PATH_NOT_FOUND);
            }
            else
            {
                DebugPrintEx(DEBUG_ERR,_T("Failed to Init cover pages class. (hRc: %08X)"), hRc);                       
                NodeMsgBox(IDS_FAILTOADD_COVERPAGES);
            }
            goto Error;

        }

        hRc = pCoverPages->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_COVERPAGES);
		    goto Error;
        }

        pCoverPages->SetIcons(IMAGE_FAX_COVERPAGES, IMAGE_FAX_COVERPAGES);

        hRc = AddChild(pCoverPages, &pCoverPages->m_scopeDataItem);
        if (FAILED(hRc))
        {
            DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("Fail to add reports node. (hRc: %08X)"),
                 hRc);
            NodeMsgBox(IDS_FAILTOADD_COVERPAGES);
            goto Error;
        }
    }
		
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pDevicesAndProviders ) 
    {
        if (0 != pDevicesAndProviders->m_scopeDataItem.ID )
        {
            hr = spConsoleNameSpace->DeleteItem(pDevicesAndProviders->m_scopeDataItem.ID, TRUE);
            if (hr != S_OK) // can be only E_UNEXPECTED [MSDN]
            {
                DebugPrintEx(
                     DEBUG_ERR,
                     TEXT("spConsoleNameSpace->DeleteItem() Failed - Unexpected error. (hRc: %08X)"),
                     hr);
                ATLASSERT(FALSE);
            }
        }
        delete  pDevicesAndProviders;    
        pDevicesAndProviders = NULL;    
    }

    if ( NULL != pIn ) 
    {
        if (0 != pIn->m_scopeDataItem.ID )
        {
            hr = spConsoleNameSpace->DeleteItem(pIn->m_scopeDataItem.ID, TRUE);
            if (hr != S_OK) // can be only E_UNEXPECTED [MSDN]
            {
                DebugPrintEx(
                     DEBUG_ERR,
                     TEXT("spConsoleNameSpace->DeleteItem() Failed - Unexpected error. (hRc: %08X)"),
                     hr);
                ATLASSERT(FALSE);
            }
        }
        delete  pIn;    
        pIn = NULL;    
    }

    if ( NULL != pOut ) 
    {
        if (0 != pOut->m_scopeDataItem.ID )
        {
            hr = spConsoleNameSpace->DeleteItem(pOut->m_scopeDataItem.ID, TRUE);
            if (hr != S_OK) // can be only E_UNEXPECTED [MSDN]
            {
                DebugPrintEx(
                     DEBUG_ERR,
                     TEXT("spConsoleNameSpace->DeleteItem() Failed - Unexpected error. (hRc: %08X)"),
                     hr);
                ATLASSERT(FALSE);
            }
        }
        delete  pOut;    
        pOut = NULL;    
    }
    if ( NULL != pCoverPages ) 
    {
        if (0 != pCoverPages->m_scopeDataItem.ID )
        {
            hr = spConsoleNameSpace->DeleteItem(pCoverPages->m_scopeDataItem.ID, TRUE);
            if (hr != S_OK) // can be only E_UNEXPECTED [MSDN]
            {
                DebugPrintEx(
                     DEBUG_ERR,
                     TEXT("spConsoleNameSpace->DeleteItem() Failed - Unexpected error. (hRc: %08X)"),
                     hr);
                ATLASSERT(FALSE);
            }
        }
        delete  pCoverPages;    
        pCoverPages = NULL;
    }

    // Empty the list
    m_ScopeChildrenList.RemoveAll();

    m_bScopeChildrenListPopulated = FALSE;

Exit:
    return hRc;
}



/*
 -  CFaxServerNode::CreatePropertyPages
 -
 *  Purpose:
 *      Called when creating a property page of the object
 *
 *  Arguments:
 *      [in]    lpProvider - The property sheet
 *      [in]    handle     - Handle for routing notification
 *      [in]    pUnk       - Pointer to the data object
 *      [in]    type       - CCT_* (SCOPE, RESULT, ...)
 *
 *  Return:
 *      OLE error code
 *      Out of memory error or last error occured
 */
HRESULT
CFaxServerNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                    LONG_PTR                handle,
                                    IUnknown                *pUnk,
                                    DATA_OBJECT_TYPES       type)
{
    HRESULT hRc    = S_OK; 
    DWORD   ec     = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::CreatePropertyPages"));

    ATLASSERT(lpProvider);    

    if( type == CCT_SNAPIN_MANAGER ) //invokes wizard
    {
        return CreateSnapinManagerPages(lpProvider, handle);
    }
    
    ATLASSERT(type == CCT_RESULT || type == CCT_SCOPE);

    m_pFaxServerGeneral    = NULL;    
    m_pFaxServerEmail      = NULL;
    m_pFaxServerEvents     = NULL;
    m_pFaxServerLogging    = NULL;
    m_pFaxServerOutbox     = NULL;
    m_pFaxServerInbox      = NULL;
    m_pFaxServerSentItems  = NULL;

    PSECURITY_DESCRIPTOR                pSecurityDescriptor = NULL;
    CFaxSecurityInformation *           pSecurityInfo = NULL;
    CFaxServer *						pFaxServer = NULL;

    HPROPSHEETPAGE                      hPage;

    BOOL                                fIsLocalServer = TRUE;

    //
    // Preliminary Access Check
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        
        NodeMsgBox(GetFaxServerErrorMsg(ec));
		
        hRc = HRESULT_FROM_WIN32(ec);
        goto Error;
    }
    
	
    if (!FaxAccessCheckEx(pFaxServer->GetFaxServerHandle(),
						FAX_ACCESS_QUERY_CONFIG,
						NULL))
    {
        ec = GetLastError();
        if (ERROR_SUCCESS == ec)
        {
            DebugPrintEx(
                 DEBUG_MSG,
                 _T("FaxAccessCheckEx returns ACCESS DENIED for FAX_ACCESS_QUERY_CONFIG."));
		    
            goto Security;
        }
        else 
        {
            DebugPrintEx(
                 DEBUG_ERR,
                 _T("Fail check access for FAX_ACCESS_QUERY_CONFIG."));
            
            NodeMsgBox(GetFaxServerErrorMsg(ec));

            hRc = HRESULT_FROM_WIN32(ec);
            goto Error;
        }
    }
	

    if ( 0 != (pFaxServer->GetServerName()).Length() )
    {
        fIsLocalServer = FALSE;
    }

    //
    // General
    //
    m_pFaxServerGeneral = new CppFaxServerGeneral(
												 handle,
                                                 this,
                                                 TRUE,
                                                 _Module.GetResourceInstance());

    if (!m_pFaxServerGeneral)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
        goto Error;
    }
	
    hRc = m_pFaxServerGeneral->InitRPC();	
    if (FAILED(hRc))
    {
         DebugPrintEx(
             DEBUG_ERR,
             TEXT("Fail to call RPC to init property page for General Tab. (hRc: %08X)"),
             hRc);

        goto Error;
    }


    hPage = NULL;
    hPage = m_pFaxServerGeneral->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to Create() property page. (hRc: %08X)"),
            hRc);
        NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {
        DebugPrintEx(
           DEBUG_ERR,
           TEXT("Fail to add property page for General Tab. (hRc: %08X)"),
           hRc);
        NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    //
    // Receipts - Notification delivery
    //
    m_pFaxServerEmail = new CppFaxServerReceipts(
                                                 handle,
                                                 this,
                                                 TRUE,
                                                 _Module.GetResourceInstance());

    if (!m_pFaxServerEmail)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
		goto Error;
    }
	
    hRc = m_pFaxServerEmail->InitRPC();	
    if (FAILED(hRc))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to call RPC to init property page for mail Tab.(hRc: %08X)"),
            hRc);
        goto Error;
    }


    hPage = NULL;
    hPage = m_pFaxServerEmail->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to Create() property page. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to add property page for Email Tab.(hRc: %08X)"),
            hRc);
        NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    //
    // Event Reports  ("Logging Categories")
    //
    m_pFaxServerEvents = new CppFaxServerEvents(
												 handle,
                                                 this,
                                                 TRUE,
                                                 _Module.GetResourceInstance());

    if (!m_pFaxServerEvents)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
		goto Error;
    }
	
    hRc = m_pFaxServerEvents->InitRPC();	
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to call RPC to init property page for event reports Tab. (hRc: %08X)"),
			hRc);
        goto Error;
    }


    hPage = NULL;
    hPage = m_pFaxServerEvents->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to Create() property page. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add property page for Events Tab.(hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    //
    // Logging
    //
    m_pFaxServerLogging = new CppFaxServerLogging(
												 handle,
                                                 this,
                                                 fIsLocalServer,
                                                 _Module.GetResourceInstance());

    if (!m_pFaxServerLogging)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
		goto Error;
    }
	
    hRc = m_pFaxServerLogging->InitRPC();	
    if (FAILED(hRc))
    {
        DebugPrintEx(
           DEBUG_ERR,
           TEXT("Fail to call RPC to init property page for Logging tab.(hRc: %08X)"),
           hRc);
        goto Error;
    }


    hPage = NULL;
    hPage = m_pFaxServerLogging->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to Create() property page. (hRc: %08X)"),
            hRc);
        NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {		 
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add property page for Logging Tab.(hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    //
    // Outbox
    //
    m_pFaxServerOutbox = new CppFaxServerOutbox(
												 handle,
                                                 this,
                                                 TRUE,
                                                 _Module.GetResourceInstance());

    if (!m_pFaxServerOutbox)
    {
        hRc= E_OUTOFMEMORY;
        NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }
	
    hRc = m_pFaxServerOutbox->InitRPC();	
    if (FAILED(hRc))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to call RPC to init property page for Outbox tab. (hRc: %08X)"),
            hRc);
        goto Error;
    }


    hPage = NULL;
    hPage = m_pFaxServerOutbox->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to Create() property page. (hRc: %08X)"),
            hRc);
        NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to add property page for Outbox Tab.(hRc: %08X)"),
            hRc);
        NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    //
    // Inbox Archive
    //
    m_pFaxServerInbox = new CppFaxServerInbox(
												 handle,
                                                 this,
                                                 fIsLocalServer,
                                                 _Module.GetResourceInstance());


    if (!m_pFaxServerInbox)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
		goto Error;
    }

    hRc = m_pFaxServerInbox->InitRPC();	
    if (FAILED(hRc))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to call RPC to init property page for Inbox Tab.(hRc: %08X)"),
            hRc);
        goto Error;
    }

		

    hPage = NULL;
    hPage = m_pFaxServerInbox->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError()); 
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to Create() property page. (hRc: %08X)"),
			hRc);
        NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add property page for Inbox Tab. (hRc: %08X)"),
			hRc);
        NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    //
    // Sent Items Archive
    //
    
    
    
    
    m_pFaxServerSentItems = new CppFaxServerSentItems(
												 handle,
                                                 this,
                                                 fIsLocalServer,
                                                 _Module.GetResourceInstance());
    if (!m_pFaxServerSentItems)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
        goto Error;
    }
	
    hRc = m_pFaxServerSentItems->InitRPC();	
    if (FAILED(hRc))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to call RPC to init property page for Sent items tab. (hRc: %08X)"),
            hRc);
        goto Error;
    }


    hPage = NULL;
    hPage = m_pFaxServerSentItems->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to Create() property page. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add property page for SentItems Tab. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

Security:  //Must be last tab!!!
    
    //
    // Security
    //
    pSecurityInfo = new CComObject<CFaxSecurityInformation>;
    if (!pSecurityInfo) 
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }	
    pSecurityInfo->Init(this);    
    
	hPage = NULL;
    hPage = CreateSecurityPage( pSecurityInfo );
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to Create() property page. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }
    hRc = lpProvider->AddPage( hPage );
    if (FAILED(hRc))
    {
	    DebugPrintEx(
		    DEBUG_ERR,
		    TEXT("Fail to add property page for Inbox Tab. (hRc: %08X)"),
		    hRc);
	    NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }  


    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != m_pFaxServerGeneral ) 
    {
        delete  m_pFaxServerGeneral;    
        m_pFaxServerGeneral = NULL;    
    }
    if ( NULL != m_pFaxServerEmail ) 
    {
        delete  m_pFaxServerEmail;
        m_pFaxServerEmail = NULL;
    }
    if ( NULL != m_pFaxServerEvents ) 
    {
        delete  m_pFaxServerEvents;
        m_pFaxServerEvents = NULL;
    }
    if ( NULL != m_pFaxServerLogging ) 
    {
        delete  m_pFaxServerLogging;
        m_pFaxServerLogging = NULL;
    }
    if ( NULL != m_pFaxServerOutbox ) 
    {
        delete  m_pFaxServerOutbox;
        m_pFaxServerOutbox = NULL;
    }
    if ( NULL != m_pFaxServerInbox ) 
    {
        delete  m_pFaxServerInbox;
        m_pFaxServerInbox = NULL;
    }
    if ( NULL != m_pFaxServerSentItems ) 
    {
        delete  m_pFaxServerSentItems;
        m_pFaxServerSentItems = NULL;
    }
    if ( NULL != pSecurityInfo ) 
    {
        delete  pSecurityInfo;
        pSecurityInfo = NULL;
    }

Exit:
    if (NULL != pSecurityDescriptor )
    {
        FaxFreeBuffer( (PVOID)pSecurityDescriptor );
    }

    return hRc;
}





/*
 -  CFaxServerNode::CreateSnapinManagerPages
 -
 *  Purpose:
 *      Called to create wizard by snapin manager     
 *      CreatePropertyPages with ( type == CCT_SNAPIN_MANAGER )
 *
 *
 *  Arguments:
 *      [in]    lpProvider - The property sheet
 *      [in]    handle     - Handle for routing notification
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxServerNode::CreateSnapinManagerPages(
                                LPPROPERTYSHEETCALLBACK lpProvider,
                                LONG_PTR handle)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::CreateSnapinManagerPages"));


    HINSTANCE hinst = _Module.GetModuleInstance();
    

    // This page will take care of deleting itself when it
    // receives the PSPCB_RELEASE message.

    CWzConnectToServer * pWzPageConnect = new CWzConnectToServer(handle, this, TRUE, hinst);
        
    HPROPSHEETPAGE   hPage = NULL;
    HRESULT hRc = S_OK;
    hPage = pWzPageConnect->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to Create() property page. (hRc: %08X)"),
			hRc);
        
        PageErrorEx(IDS_FAX_CONNECT, IDS_FAIL_TO_OPEN_TARGETING_WIZARD, NULL);

        return hRc;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add the connect to server property page to wizard. (hRc: %08X)"),
			hRc);
        PageErrorEx(IDS_FAX_CONNECT, IDS_FAIL_TO_OPEN_TARGETING_WIZARD, NULL);
        
        return hRc;
    }

    return hRc;
}

/*
 -  CFaxServerNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxServerNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hr = S_OK;

    //
    // Display verbs that we support:
    // 1. Properties
    //

    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    //
    // We want the default verb to be Properties
    //
    hr = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    return hr;
}


/*
 -  CFaxServerNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxServerNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    return S_OK;
}


/*
 -  CFaxServerNode::UpdateMenuState
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateMenuState
 *      which only have one line inside it "return;" 
 *      This function implements the grayed\ungrayed view for the 
 *      the Enable and the Disable menus.
 *
 *  Arguments:
 *
 *            [in]  id    - unsigned int with the menu IDM value
 *            [out] pBuf  - string 
 *            [out] flags - pointer to flags state combination unsigned int
 *
 *  Return:
 *      no return value - void function 
 */
void CFaxServerNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::UpdateMenuState"));

    UNREFERENCED_PARAMETER (pBuf);
    
    BOOL fIsRunning = FALSE; 
    
    ATLASSERT(GetFaxServer());
    fIsRunning = GetFaxServer()->IsServerRunningFaxService();
    
    switch (id)
    {
        case IDM_SRV_START:
            *flags = (fIsRunning  ?  MF_GRAYED : MF_ENABLED );
            break;

        case IDM_SRV_STOP:

            *flags = (!fIsRunning ?  MF_GRAYED : MF_ENABLED );           
            break;

        case IDM_LAUNCH_CONSOLE:

            *flags = IsFaxComponentInstalled(FAX_COMPONENT_CONSOLE) ? MF_ENABLED : MF_GRAYED;
            break;

        default:
            break;
    }
    
    return;
}

/*
 -  CFaxServerNode::UpdateToolbarButton
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateToolbarButton
 *      This function aloow us to decide if to the activate\grayed a toolbar button  
 *      It treating only the Enable state.
 *
 *  Arguments:
 *
 *            [in]  id    - unsigned int for the toolbar button ID
 *            [in]  fsState  - state to be cosidered ENABLE ?HIDDEN etc. 
 *
 *  Return:
 *     BOOL TRUE to activate state FALSE to disabled the state for this button 
 */
BOOL CFaxServerNode::UpdateToolbarButton(UINT id, BYTE fsState)
{
	DEBUG_FUNCTION_NAME( _T("CFaxServerNode::UpdateToolbarButton"));
    BOOL bRet = FALSE;	
	
    BOOL fIsRunning = FALSE; 
    
    ATLASSERT(GetFaxServer());
    fIsRunning = GetFaxServer()->IsServerRunningFaxService();


	// Set whether the buttons should be enabled.
	if (fsState == ENABLED)
    {

        switch ( id )
        {
            case ID_START_BUTTON:
	            
                bRet = ( fIsRunning ?  FALSE : TRUE );
                break;

            case ID_STOP_BUTTON:
                
                bRet = ( fIsRunning ?  TRUE : FALSE );
                break;
        
            case ID_CLIENTCONSOLE_BUTTON:
	            
                bRet = IsFaxComponentInstalled(FAX_COMPONENT_CONSOLE); 
                break;

            default:
                break;

        }

    }

	// For all other possible button ID's and states, 
    // the correct answer here is FALSE.
	return bRet;

}


/*
-  CFaxServerNode::OnServiceStartCommand
-
*  Purpose:
*      To start Fax Server Service
*
*  Arguments:
*
*  Return:
*      OLE error code
*/
HRESULT  CFaxServerNode::OnServiceStartCommand(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::OnServiceStartCommand"));
    BOOL                    bRet = FALSE;

    HRESULT                 hRc  = S_OK;
    SCOPEDATAITEM*          pScopeData;
    CComPtr<IConsole>       spConsole;

    
    //
    // 0) Service status check
    //
    ATLASSERT(GetFaxServer());
    if (GetFaxServer()->IsServerRunningFaxService())
    {
        DebugPrintEx(
			DEBUG_MSG,
			_T("Service is already running. (ec: %ld)"));
        NodeMsgBox(IDS_SRV_ALREADY_START);
        
        bRet = TRUE; //to allow toolbar refresh to correct state
    }
    else
    {

        //
        // 1) Start the service
        //
        // ATLASSERT(GetFaxServer()); was called above
        bRet = EnsureFaxServiceIsStarted (NULL);
        if (!bRet) 
        { 
            NodeMsgBox(IDS_FAIL2START_SRV); 
        }
    }

    //
    // 2) Update the toolbar.
    //
	if (bRet)
    {
        //
	    // Get the updated SCOPEDATAITEM
	    //
        hRc = GetScopeData( &pScopeData );
        if (FAILED(hRc))
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to get pScopeData. (hRc: %08X)"),
			    hRc);
            NodeMsgBox(IDS_FAIL2UPDATE_SRVSTATUS_TOOLBAR);
        }
        else
        {
            //
	        // This will force MMC to redraw the scope node
	        //
            spConsole = m_pComponentData->m_spConsole;
            ATLASSERT(spConsole);
	        
            hRc = spConsole->SelectScopeItem( pScopeData->ID );
            if (FAILED(hRc))
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to select scope Item. (hRc: %08X)"),
			        hRc);
                NodeMsgBox(IDS_FAIL2UPDATE_SRVSTATUS_TOOLBAR);
            }
        }
    }

    return (bRet ?  S_OK : E_FAIL);
}



/*
-  CFaxServerNode::OnServiceStopCommand
-
*  Purpose:
*      To stop Fax Server Service
*
*  Arguments:
*
*  Return:
*      OLE error code
*/
HRESULT  CFaxServerNode::OnServiceStopCommand(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::OnServiceStopCommand"));

    BOOL                    bRet = FALSE;

    HRESULT                 hRc  = S_OK;
    SCOPEDATAITEM*          pScopeData;
    CComPtr<IConsole>       spConsole;



    //
    // 0) Service status check
    //
    ATLASSERT(GetFaxServer());
    if (GetFaxServer()->IsServerFaxServiceStopped())
    {
        DebugPrintEx(
			DEBUG_MSG,
			_T("Do not have to stop - Fax server service is not started. (ec: %ld)"));
        NodeMsgBox(IDS_SRV_ALREADY_STOP);
        
        bRet = TRUE; //to allow toolbar refresh to correct state
    }
    else
    {
        //
        // 1) Stop the service
        //
        // ATLASSERT(GetFaxServer()); was called above
        bRet = StopService(NULL, FAX_SERVICE_NAME, TRUE);
        if (!bRet) 
        { 
            NodeMsgBox(IDS_FAIL2STOP_SRV); 
        }

    }

    //
    // 2) Update the toolbar.
    //
	if (bRet)
    {
        //
	    // Get the updated SCOPEDATAITEM
	    //
        hRc = GetScopeData( &pScopeData );
        if (FAILED(hRc))
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to get pScopeData. (hRc: %08X)"),
			    hRc);
            NodeMsgBox(IDS_FAIL2UPDATE_SRVSTATUS_TOOLBAR);
        }
        else
        {
            //
	        // This will force MMC to redraw the scope node
	        //
            spConsole = m_pComponentData->m_spConsole;
            ATLASSERT(spConsole);
	        
            hRc = spConsole->SelectScopeItem( pScopeData->ID );
            if (FAILED(hRc))
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to select scope Item. (hRc: %08X)"),
			        hRc);
                NodeMsgBox(IDS_FAIL2UPDATE_SRVSTATUS_TOOLBAR);
            }
        }
    }

    return (bRet ?  S_OK : E_FAIL);
}


/*
 -  CFaxServerNode::OnLaunchClientConsole
 -
 *  Purpose:
 *      To launch client console.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT  CFaxServerNode::OnLaunchClientConsole(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME(_T("CFaxServerNode::OnLaunchClientConsole"));
    DWORD	    dwRes  = ERROR_SUCCESS;
    HINSTANCE   hClientConsole; 
    UINT        idsRet;
    //
    // (-1) GetServerName
    //
    CComBSTR bstrServerName = L"";
    
    bstrServerName = GetServerName();
    if (!bstrServerName)
    {
         DebugPrintEx(
			DEBUG_ERR,
			_T("Launch client console failed due to failure during GetServerName."));
        
        NodeMsgBox(IDS_MEMORY);

        bstrServerName = L"";

        return E_FAIL;
    }
    
    //
    // start cover page editor
    //
    hClientConsole = ShellExecute(   NULL, 
                                 TEXT("open"),  // Command 
                                 FAX_CLIENT_CONSOLE_IMAGE_NAME,   
                                 bstrServerName, 
                                 NULL, 
                                 SW_RESTORE 
                              );
    if( (DWORD_PTR)hClientConsole <= 32 )
    {
        // ShellExecute fail
        dwRes = PtrToUlong(hClientConsole);
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to run ShellExecute. (ec : %ld)"), dwRes);
        
        ATLASSERT(dwRes >= 0);
        
        //
        // Select message to user
        //
        switch (dwRes)
        {
            case 0:                     //The operating system is out of memory or resources. 
            case SE_ERR_OOM:            //There was not enough memory to complete the operation. 
                idsRet = IDS_MEMORY;
                break;

            case ERROR_FILE_NOT_FOUND:  //The specified file was not found. 
            case ERROR_PATH_NOT_FOUND:  //The specified path was not found. 
            case ERROR_BAD_FORMAT:      //The .exe file is invalid (non-Win32 .exe or error in .exe image). 
            //case SE_ERR_PNF: value '3' already used  //The specified path was not found. 
            //case SE_ERR_FNF: value '2' already used  //The specified file was not found.  
            case SE_ERR_ASSOCINCOMPLETE:  //The file name association is incomplete or invalid. 
                idsRet = IDS_FAXCONSOLE_NOTFOUND;
                break;

            case SE_ERR_ACCESSDENIED:   //The operating system denied access to the specified file.  
                idsRet = IDS_FAXCONSOLE_ACCESSDENIED;
                break;

            case SE_ERR_DLLNOTFOUND:    //The specified dynamic-link library was not found.  
            case SE_ERR_SHARE:          //A sharing violation occurred.
            default:
                idsRet = IDS_FAIL2LAUNCH_FAXCONSOLE_GEN;
                break;
        }
        NodeMsgBox(idsRet);

        goto Exit;
    }
        
    ATLASSERT( ERROR_SUCCESS == dwRes);

Exit:
    return HRESULT_FROM_WIN32( dwRes );
}


/*
 -  CFaxServerNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxServerNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxServerNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                        IDS_DISPLAY_STR_FAXSERVERNODE))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}

/*
 -  CFaxServerNode::SetServerNameOnSnapinAddition()
 -
 *  Purpose:
 *      Set server name and init the related node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxServerNode::SetServerNameOnSnapinAddition(BSTR bstrServerName, BOOL fAllowOverrideServerName)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::SetServerNameOnSnapinAddition"));
    HRESULT hRc = S_OK;

    hRc = UpdateServerName(bstrServerName);
    if (S_OK != hRc)
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to UpdateServerName - out of memory"));
        
        goto Exit;
    }

    hRc = 	InitDetailedDisplayName();
    if ( S_OK != hRc)
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to InitDetailedDisplayName. (hRc: %08X)"),
			hRc);
    
        goto Exit;
    }
    ATLASSERT (S_OK == hRc);

    //
    // Update override status
    //
    m_fAllowOverrideServerName = fAllowOverrideServerName;

Exit:
    return hRc;
}


/*
 -  CFaxServerNode::ForceRedrawNode
 -
 *  Purpose:
 *      To show the new node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxServerNode::ForceRedrawNode()
{
    DEBUG_FUNCTION_NAME(_T("CFaxServerNode::ForceRedrawNode"));


    HRESULT hRc = S_OK;
    
    //
    // Get IConsoleNameSpace
    //
    ATLASSERT( m_pComponentData != NULL );
    ATLASSERT( m_pComponentData->m_spConsole != NULL );

    CComPtr<IConsole> spConsole;
    spConsole = m_pComponentData->m_spConsole;
	CComQIPtr<IConsoleNameSpace,&IID_IConsoleNameSpace> spNamespace( spConsole );

	//
	// Get the updated SCOPEDATAITEM
	//
    SCOPEDATAITEM*    pScopeData;

	hRc = GetScopeData( &pScopeData );
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to get pScopeData. (hRc: %08X)"),
			hRc);
        goto Error;
    }
	
    //
    // Update (*pScopeData).displayname
    //
	(*pScopeData).displayname = m_bstrDisplayName;

    //
	// Force MMC to redraw the scope node
	//
	hRc = spNamespace->SetItem( pScopeData );
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to set Item pScopeData. (hRc: %08X)"),
			hRc);
        goto Error;
    }
        
    ATLASSERT(S_OK == hRc);
    goto Exit;


Error:
 	
    NodeMsgBox(IDS_FAIL2RENAME_NODE);
  
Exit:
    return hRc;

}



/*
 -  CFaxServerNode::UpdateServerName
 -
 *  Purpose:
 *      Update the server name for fax Server node and CFaxServer.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxServerNode::UpdateServerName(BSTR bstrServerName)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::UpdateServerName"));
    HRESULT hRc = S_OK;

    ATLASSERT(GetFaxServer());
    hRc = GetFaxServer()->SetServerName(bstrServerName);
    if ( S_OK != hRc)
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed Update FaxServer with the server name. (hRc: %08X)"),
			hRc);
    
        NodeMsgBox(IDS_MEMORY);

    }

    return hRc;
}



/*
 -  CFaxServerNode::InitDetailedDisplayName()
 -
 *  Purpose:
 *      Load the node's Displaed-Name string with the server name.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxServerNode::InitDetailedDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxServerNode::InitDetailedDisplayName"));

    HRESULT hRc = S_OK;

    CComBSTR bstrServerName;
    CComBSTR bstrLeftBracket;
    CComBSTR bstrRightBracket;
    CComBSTR bstrLocal;


    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                        IDS_DISPLAY_STR_FAXSERVERNODE))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
        
    //
    // Retreive the server name
    //    
    bstrServerName = GetServerName();
    if (!bstrServerName)
    {
         DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get the server name."));
        
        NodeMsgBox(IDS_MEMORY);

        bstrServerName = L"";

        hRc = E_OUTOFMEMORY;
        goto Error;
    }


    
    //
    // Appends the sever name
    //

    if (!bstrLeftBracket.LoadString(_Module.GetResourceInstance(), 
                        IDS_LEFTBRACKET_PLUSSPACE))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    if (!bstrRightBracket.LoadString(_Module.GetResourceInstance(), 
                        IDS_RIGHTBRACKET))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    if (!bstrLocal.LoadString(_Module.GetResourceInstance(), 
                        IDS_LOCAL_PLUSBRACKET_PLUSSPACE))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    

    if ( 0 == bstrServerName.Length() ) //if equals L""
    {
        m_bstrDisplayName += bstrLocal;   
    }
    else
    {
        m_bstrDisplayName += bstrLeftBracket;   
        m_bstrDisplayName += bstrServerName;   
        m_bstrDisplayName += bstrRightBracket;   
    }
    
    ATLASSERT( S_OK == hRc);

    //
    // Setting this flag to allow pre connection check
    // during first FaxServerNode expand.
    //
    m_IsPrimaryModeSnapin = TRUE;


    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);


    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}

const CComBSTR&  CFaxServerNode::GetServerName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxServerNode::GetServerName"));

    ATLASSERT(GetFaxServer());
    return  GetFaxServer()->GetServerName();
}

    
/*
 +
 +  CFaxServerNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxServerNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    _TCHAR topicName[MAX_PATH];
    
    _tcscpy(topicName, helpFile);
    
    _tcscat(topicName, _T("::/FaxS_C_FaxIntro.htm"));
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(topicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, topicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}


/////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\fxsvalid.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FxsValid.cpp                                           //
//                                                                         //
//  DESCRIPTION   : Fax Validity checks.                                   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Mar 29 2000 yossg   Create                                         //  
//      Jul  4 2000 yossg   Add IsLocalServerName                                         //  
//                                                                         //
//  Copyright (C) 2000 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "FxsValid.h"

#include <windns.h> //DNS_MAX_NAME_BUFFER_LENGTH

/*
 -  IsNotEmptyString
 -
 *  Purpose:
 *      To validate that a general string is not empty.
 *
 *  Arguments:
 *      [in]  bstrGenStr - input BSTR
 *
 *  Return:
 *      TRUE string is not length 0 or spaces only 
 *      FALSE if not 
 */
BOOL IsNotEmptyString(CComBSTR bstrGenStr)
{
    DEBUG_FUNCTION_NAME( _T("IsValidGeneralString"));

    int iLen = bstrGenStr.Length();
    if (iLen > 0)
    {
        for(int i = 0; i < iLen; i++ )
        {
            if( !iswspace( bstrGenStr[i] ) )
            {
                return(TRUE);
            }
        }
        DebugPrintEx(DEBUG_ERR,
			_T("String contains only spaces."));

        return FALSE;
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,
			_T("String length is zero."));

        return FALSE;
    }
}


/*
 -  IsValidServerNameString
 -
 *  Purpose:
 *      To validate string as a server name string.
 *      This level will return a detailed error message IDS.
 *
 *  Arguments:
 *      [in]  bstrServerName - input BSTR
 *      [out] puIds - pointer to IDS with error message.
 *
 *  Return:
 *      TRUE - the string is a valid server name string
 *      FALSE - if not 
 */
BOOL IsValidServerNameString(CComBSTR bstrServerName, UINT * puIds, BOOL fIsDNSName /*= FALSE*/)
{
    DEBUG_FUNCTION_NAME( _T("IsValidServerNameString"));

    int     iCount, i, iLength;
    BOOL    bFirstNonSpaceIsFound = FALSE;
    
    ATLASSERT(bstrServerName);
    ATLASSERT(puIds);

    //
    // Length == 0
    // 
    if ( 0 == ( iCount = bstrServerName.Length() ) )
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Server name is empty"));
        *puIds = IDS_SERVERNAME_EMPTY_STRING;
        
        return FALSE;
    }

    //
    // Length 
    //
    if ( fIsDNSName == FALSE ) 
    {
        iLength = MAX_COMPUTERNAME_LENGTH;
    }
    else 
    {
        iLength = DNS_MAX_NAME_BUFFER_LENGTH;
    }

    if ( ( iCount = bstrServerName.Length() ) > iLength )
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Server name is too long"));
        *puIds = IDS_SERVERNAME_TOO_LONG;

        return FALSE;
    }
    
    //
    // search for: \ / tabs , ; : " < > * + = | [ ] ?  
    //           
    for (i = 0; i < iCount; i++)
    {
        if (
            (bstrServerName[i] == '\\')
           ||
            (bstrServerName[i] == '/')
           ||
            (bstrServerName[i] == '\t')
           ||
            (bstrServerName[i] == ',')
           ||
            (bstrServerName[i] == ';')
           ||
            (bstrServerName[i] == ':')
           ||
            (bstrServerName[i] == '"')
           ||
            (bstrServerName[i] == '<')
           ||
            (bstrServerName[i] == '>')
           ||
            (bstrServerName[i] == '*')
           ||
            (bstrServerName[i] == '+')
           ||
            (bstrServerName[i] == '=')
           ||
            (bstrServerName[i] == '|')
           ||
            (bstrServerName[i] == '?')
           ||
            (bstrServerName[i] == '[')
           ||
            (bstrServerName[i] == ']')
           )
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Server name contains an invalid character."));
            *puIds = IDS_SERVERNAME_STRING_CONTAINS_INVALID_CHARACTERS;
            
            return FALSE;
        }

        //
        // At the same loop see if all string is spaces
        //
        if (!bFirstNonSpaceIsFound)
        {
           if (bstrServerName[i] != ' ' )
           {
              bFirstNonSpaceIsFound = TRUE;
           }
        }
    }

    if (!bFirstNonSpaceIsFound)
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Server name string includes only spaces."));
        *puIds = IDS_SERVERNAME_EMPTY_STRING;

        return FALSE;
    }

    return TRUE;
}




/*
 -  IsValidPortNumber
 -
 *  Purpose:
 *      To validate that string contains a valid port number.
 *      This level will return a detailed error message IDS.
 *
 *  Arguments:
 *      [in]  bstrPort - input BSTR
 *      [out] pdwPortVal - pointer to DWORD port value 
 *            in case of success.
 *      [out] puIds - pointer to IDS with error message 
 *            in case of failure.
 *
 *  Return:
 *      TRUE - the string containts a valid port number
 *      FALSE  - if not. 
 */
BOOL IsValidPortNumber(CComBSTR bstrPort, DWORD * pdwPortVal, UINT * puIds)
{
    DEBUG_FUNCTION_NAME( _T("IsValidPortNumber"));

    DWORD dwPort;
    
    ATLASSERT(bstrPort);

    //
    // Length == 0
    // 
    if (0 == bstrPort.Length())
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Port string is empty"));
        *puIds = IDS_PORT_EMPTY_STRING;
        
        return FALSE;
    }

    //
    // numerical value;
    //
    if (1 != swscanf (bstrPort, _T("%ld"), &dwPort))
    {
        *puIds = IDS_PORT_NOT_NUMERIC;
        DebugPrintEx(
			DEBUG_ERR,
			_T("port string is not a number"));
        
        return FALSE;
    }
    
    //
    // MIN_PORT_NUM <= dwPort <= MAX_PORT_NUM
    //
    if ( ((int)dwPort > FXS_MAX_PORT_NUM) || ((int)dwPort < FXS_MIN_PORT_NUM))
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Port number is out off allowed values"));
        *puIds = IDS_INVALID_PORT_NUM;

        return FALSE;
    }
    
    *pdwPortVal = dwPort;
    return TRUE;
}


/*
 +  IsLocalComputer
 +
 *  Purpose:
 *      To see if the server name is the local computer name. 
 *      
 *  Arguments:
 *      [in] lpszComputer : the machine name.  
 *
 -  Return:
 -      TRUE or FALSE
 */
BOOL IsLocalServerName(IN LPCTSTR lpszComputer)
{
    DEBUG_FUNCTION_NAME( _T("IsLocalComputer"));
    
    //
    // Pre conditions
    //
    ATLASSERT(lpszComputer);

    if (!lpszComputer || !*lpszComputer)
    {
        return TRUE;
    }

    if ( _tcslen(lpszComputer) > 2 && ( 0 == wcsncmp( lpszComputer , _T("\\\\") , 2 ))   ) 
    {
        lpszComputer = _tcsninc(lpszComputer, 2); 
    }

    //
    // Computer Name Compare
    //
    BOOL    bReturn = FALSE;
    DWORD   dwErr = 0;
    TCHAR   szBuffer[DNS_MAX_NAME_BUFFER_LENGTH];
    DWORD   dwSize = DNS_MAX_NAME_BUFFER_LENGTH;

    // 1st: compare against local Netbios computer name
    if ( !GetComputerNameEx(ComputerNameNetBIOS, szBuffer, &dwSize) )
    {
        dwErr = GetLastError();
    } 
    else
    {
        bReturn = (0 == lstrcmpi(szBuffer, lpszComputer));
        if (!bReturn)
        { 
            // 2nd: compare against local Dns computer name 
            dwSize = DNS_MAX_NAME_BUFFER_LENGTH;
            if (GetComputerNameEx(ComputerNameDnsFullyQualified, szBuffer, &dwSize))
            {
                bReturn = (0 == lstrcmpi(szBuffer, lpszComputer));
            }
            else
            {
                dwErr = GetLastError();
            }
        }
    }

    if (dwErr)
    {
        DebugPrintEx(DEBUG_ERR,
		_T("Failed to discover if is a local server (ec = %x)"), dwErr);
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\faxmmcpropertychange.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxMMCPropertyChange.h                                 //
//                                                                         //
//  DESCRIPTION   : Header file for FaxMMCPropertyNotification structure   //
//                                                                         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan 19 2000 yossg   Init .                                         //
//                          Windows XP                                     //
//      Feb 14 2001 yossg   Add Device class due to Manual Receive support //
//                                                                         //
//  Copyright (C) 2000  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXMMCPROPERTYCHANGE_H
#define H_FAXMMCPROPERTYCHANGE_H

enum ENUM_PROPCHANGE_NOTIFICATION_TYPE
{
    GeneralFaxPropNotification = 0,
    RuleFaxPropNotification,
    DeviceFaxPropNotification
};

//
// the general fax property change notifiction structure
//       
class CFaxPropertyChangeNotification
{
public:
    //
    // Constructor
    //
    CFaxPropertyChangeNotification()
    {
        pItem            = NULL;
        pParentItem      = NULL;
        enumType         = GeneralFaxPropNotification;
    }

    //
    // Destructor
    //
    ~CFaxPropertyChangeNotification()
    {
    }
    
    //
    // members
    //
    CSnapInItem *                       pItem;
    CSnapInItem *                       pParentItem;
    ENUM_PROPCHANGE_NOTIFICATION_TYPE   enumType;
};


//
// The Rule property change notifiction structure
//       
class CFaxRulePropertyChangeNotification: public CFaxPropertyChangeNotification
{
public:

    //
    // Constructor
    //
    CFaxRulePropertyChangeNotification()
    {
        dwCountryCode   = 0;
        dwAreaCode      = 0;
        dwDeviceID      = 0;
        bstrCountryName = L"";
        bstrGroupName   = L"";
    }

    //
    // Destructor
    //
    ~CFaxRulePropertyChangeNotification()
    {
    }

    //
    // members
    //
    DWORD    dwCountryCode;
    DWORD    dwAreaCode;
    CComBSTR bstrCountryName;
    BOOL     fIsGroup;
    CComBSTR bstrGroupName;
    DWORD    dwDeviceID;
};


//
// The device property change notifiction structure
//       
class CFaxDevicePropertyChangeNotification: public CFaxPropertyChangeNotification
{
public:

    //
    // Constructor
    //
    CFaxDevicePropertyChangeNotification()
    {
        dwDeviceID                   = 0;

        fIsToNotifyAdditionalDevices = FALSE;
    }

    //
    // Destructor
    //
    ~CFaxDevicePropertyChangeNotification()
    {
    }

    //
    // members
    //
    DWORD         dwDeviceID;
    BOOL          fIsToNotifyAdditionalDevices;

};



#endif  //H_FAXMMCPROPERTYCHANGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\faxmmcutils.cpp ===
#include "stdafx.h"
#include "FaxMMCUtils.h"
#include <faxres.h>

/*
 -  GetFaxServerErrorMsg
 -
 *  Purpose:
 *      Translate Error Code to IDS.
 *
 *  Arguments:
 *          dwEc - error code DWORD
 *
 *  Return:
 *          integer represents the IDS of error message 
 *          for this ec.
 *      
 */
int GetFaxServerErrorMsg(DWORD dwEc)
{
    DEBUG_FUNCTION_NAME( _T("GetFaxServerErrorMsg"));

    int         iIDS = IDS_GENERAL_FAILURE;

    if (IsNetworkError(dwEc))
    {
                iIDS = IDS_NETWORK_PROBLEMS;           
    }
    else
    {
        switch (dwEc)
        {
            case ERROR_NOT_ENOUGH_MEMORY:
                iIDS = IDS_MEMORY;           
                break;

            case ERROR_INVALID_PARAMETER:
                iIDS = IDS_INVALID_PARAMETER;                    
                break;

            case ERROR_ACCESS_DENIED:
                iIDS = IDS_ACCESS_DENIED;            
                break;

            case ERROR_INVALID_HANDLE:
                //
                // ERROR_INVALID_HANDLE should not been 
                // retreived except of FaxOpenPort while 
                // handle sharing corruption was occoured.
                // This case treated without calling this 
                // function.
                //
                
                ATLASSERT(FALSE);

                //
                // iIDS stays IDS_GENERAL_FAILURE due to 
                // the fact that we are not going report 
                // to the user on an invalid handle issue. 
                // This peace of code here should not been reached
                // ever and this is the reason to the assert. 
                //            
                
                break;

            case ERROR_BAD_UNIT:
                iIDS = IDS_CANNOT_FIND_DEVICE;            
                break;

            case ERROR_DIRECTORY:  //  The directory name is invalid.
                iIDS = IDS_ERROR_DIRECTORY;            
                break;

            case ERROR_BAD_PATHNAME:
                iIDS = IDS_ERROR_BAD_PATHNAME;
                break;

            case ERROR_EAS_NOT_SUPPORTED:
                iIDS = IDS_ERROR_EAS_NOT_SUPPORTED;
                break;

            case ERROR_REGISTRY_CORRUPT:
                iIDS = IDS_ERROR_REGISTRY_CORRUPT;                    
                break;

            case ERROR_PATH_NOT_FOUND:
                iIDS = IDS_ERROR_PATH_NOT_FOUND;                    
                break;

            case FAX_ERR_DIRECTORY_IN_USE:
                iIDS = IDS_FAX_ERR_DIRECTORY_IN_USE;                    
                break;

            case FAX_ERR_RULE_NOT_FOUND:
                iIDS = IDS_FAX_ERR_RULE_NOT_FOUND;                    
                break;

            case FAX_ERR_BAD_GROUP_CONFIGURATION:
                iIDS = IDS_FAX_ERR_BAD_GROUP_CONFIGURATION;                    
                break;

            case FAX_ERR_GROUP_NOT_FOUND:
                iIDS = IDS_FAX_ERR_GROUP_NOT_FOUND;                    
                break;

            case FAX_ERR_SRV_OUTOFMEMORY:
                iIDS = IDS_FAX_ERR_SRV_OUTOFMEMORY;                    
                break;

            case FAXUI_ERROR_INVALID_CSID:
                iIDS = IDS_FAX_ERR_INVALID_CSID;
                break;

            case FAXUI_ERROR_INVALID_TSID:
                iIDS = IDS_FAX_ERR_INVALID_TSID;
                break;

            default:
                break;
	    }
    }
    
    return iIDS;
}

/*
 -  IsNetworkError
 -
 *  Purpose:
 *      Verify if Error Code represents a network error.
 *
 *  Arguments:
 *          dwEc - error code DWORD
 *
 *  Return:
 *          Boolean TRUE if the dwEc represents a 
 *          network error, and FALSE if not.
 *      
 */
BOOL IsNetworkError(DWORD dwEc)
{
    DEBUG_FUNCTION_NAME( _T("IsNetworkError"));

    BOOL bIsNetworkError = FALSE; 
    //Initialized to avoid an option to future mistakes

    switch (dwEc)
    {
        case RPC_S_INVALID_BINDING:
            bIsNetworkError = TRUE;            
            break;

        case EPT_S_CANT_PERFORM_OP:
            bIsNetworkError = TRUE;            
            break;

        case RPC_S_ADDRESS_ERROR:
            bIsNetworkError = TRUE;            
            break;

        case RPC_S_CALL_CANCELLED:
            bIsNetworkError = TRUE;            
            break;

        case RPC_S_CALL_FAILED:
            bIsNetworkError = TRUE;            
            break;

        case RPC_S_CALL_FAILED_DNE:
            bIsNetworkError = TRUE;            
            break;

        case RPC_S_COMM_FAILURE:
            bIsNetworkError = TRUE;            
            break;

        case RPC_S_NO_BINDINGS:
            bIsNetworkError = TRUE;            
            break;

        case RPC_S_SERVER_TOO_BUSY:
            bIsNetworkError = TRUE;            
            break;

        case RPC_S_SERVER_UNAVAILABLE:
            bIsNetworkError = TRUE;            
            break;

	    default:
            bIsNetworkError = FALSE;            
            break;
	}
    return (bIsNetworkError);

}


/*
 -  Routine Description:
 -
 *     Invokes the browse dialog
 *
 *  Arguments:
 *
 *     hwndDlg - Specifies the dialog window on which the Browse button is displayed
 *
 *  Return Value:
 *
 *     TRUE if successful, FALSE if the user presses Cancel
*/


BOOL
InvokeBrowseDialog( LPTSTR lpszBrowseItem, 
                    LPCTSTR lpszBrowseDlgTitle,
                    unsigned long ulBrowseFlags,
                    CWindow *pParentWin)
{

    DEBUG_FUNCTION_NAME( _T("InvokeBrowseDialog"));

    BOOL            fResult = FALSE;

    BROWSEINFO      bi;
    LPITEMIDLIST    pidl;
    LPMALLOC        pMalloc;
    VOID            SHFree(LPVOID);

    ATLASSERT( pParentWin != NULL);
    //
    // Preparing the BROWSEINFO structure.
    // 
    bi.hwndOwner        = (HWND)(*pParentWin); //Parents hWndDlg
    bi.pidlRoot         = NULL;
    bi.pszDisplayName   = lpszBrowseItem;
    bi.lpszTitle        = lpszBrowseDlgTitle;
    bi.ulFlags          = ulBrowseFlags;
    bi.lpfn             = BrowseCallbackProc; 
    bi.lParam           = (LPARAM) (lpszBrowseItem);
	bi.iImage           = 0;

    //
    // Memory check
    //
    if (FAILED(SHGetMalloc(&pMalloc)))
    {
        DlgMsgBox(pParentWin, IDS_MEMORY);
        return fResult;
    }

    //
    // Calling to the BrowseForFolder dialog 
    //
    if(pidl = SHBrowseForFolder(&bi)) //pidl != NULL
    {
        //
        // Retrieving the New Path
        //
        if(SHGetPathFromIDList(pidl, lpszBrowseItem)) 
        {
            ATLASSERT(wcslen(lpszBrowseItem) <= MAX_PATH);

            DebugPrintEx(DEBUG_MSG,
                _T("Succeeded to Retrieve the path from browse dialog."));
            
            // Now the path was retreived successfully to
            // the back parameter lpszBrowseItem
            // and this is the only case in which the calling 
            // function gets TRUE as return value.
            
            fResult = TRUE;
        }

        //
        // Free using shell allocator
        //
        pMalloc->Free(pidl);
        pMalloc->Release();
    }

    return fResult;
}


/*++
Routine Description:

    Callback function for the folder browser

Arguments:

    hwnd     : Handle to the browse dialog box. The callback function can 
               send the following messages to this window:

               BFFM_ENABLEOK      Enables the OK button if the wParam parameter 
                                  is nonzero or disables it if wParam is zero.
               BFFM_SETSELECTION  Selects the specified folder. The lParam 
                                  parameter is the PIDL of the folder to select 
                                  if wParam is FALSE, or it is the path of the 
                                  folder otherwise.
               BFFM_SETSTATUSTEXT Sets the status text to the null-terminated 
                                  string specified by the lParam parameter.
 
    uMsg     : Value identifying the event. This parameter can be one of the 
               following values:

               0                  Initialize dir path.  lParam is the path.

               BFFM_INITIALIZED   The browse dialog box has finished 
                                  initializing. lpData is NULL.
               BFFM_SELCHANGED    The selection has changed. lpData 
                                  is a pointer to the item identifier list for 
                                  the newly selected folder.
 
    lParam   : Message-specific value. For more information, see the 
               description of uMsg.

    lpData   : Application-defined value that was specified in the lParam 
               member of the BROWSEINFO structure.

Return Value:

    0 (1)

--*/
int CALLBACK BrowseCallbackProc(
                                HWND hWnd, 
                                UINT uMsg, 
                                LPARAM lParam, 
                                LPARAM lpData)
{
    int iRet = 0;    
    
    switch(uMsg)
	{

	case BFFM_INITIALIZED:
        // LParam is TRUE since you are passing a path.
        // It would be FALSE if you were passing a pidl.

        // the lpData points to the folder path.
        // It must contain a path.        
		// ASSERT(lpData && _T('\0') != *((LPTSTR)lpData));

        SendMessage(hWnd, BFFM_SETSELECTION, (WPARAM)TRUE, lpData);
        break;

	case BFFM_SELCHANGED:
        {
            BOOL bFolderIsOK = FALSE;
            TCHAR szPath [MAX_PATH + 1];

            if (SHGetPathFromIDList ((LPITEMIDLIST) lParam, szPath)) 
            {
                DWORD dwFileAttr = GetFileAttributes(szPath);

                ::SendMessage(hWnd, BFFM_SETSTATUSTEXT, TRUE, (LPARAM)szPath);

                if (-1 != dwFileAttr && (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY))
                {
                    //
                    // The directory exists - enable the 'Ok' button
                    //
                    bFolderIsOK = TRUE;
                }
            }
            //
            // Enable / disable the 'ok' button
            //
            ::SendMessage(hWnd, BFFM_ENABLEOK , 0, (LPARAM)bFolderIsOK);
            break;
        }


		break;

	case BFFM_VALIDATEFAILED:
		break;

	default:
		ATLTRACE2(atlTraceWindowing, 0, _T("Unknown message received in CFolderDialogImpl::BrowseCallbackProc\n"));
		break;
	}

	return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\faxservernode.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxServerNode.h                                        //
//                                                                         //
//  DESCRIPTION   : Header file for CFaxServerNode snapin node class       //
//                  This is the "Fax" node in the scope pane.              //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 22 1999 yossg   Init .                                         //
//      Nov 24 1999 yossg   Rename file from FaxCfg                        //
//      Dec  9 1999 yossg   Call InitDisplayName from parent		   //
//      Mar 16 2000 yossg   Add service start-stop                         //
//      Jun 25 2000 yossg   add stream and command line primary snapin 	   //
//                          machine targeting.                             //
//                                                                         //
//  Copyright (C) 1998 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXSERVERNODE_H
#define H_FAXSERVERNODE_H

//#pragma message( "H_FAXSERVERNODE_H" )

//
// Dialog H files
//
#include "ppFaxServerGeneral.h"
#include "ppFaxServerReceipts.h"
#include "ppFaxServerLogging.h"
#include "ppFaxServerEvents.h"
#include "ppFaxServerInbox.h"
#include "ppFaxServerOutbox.h"
#include "ppFaxServerSentItems.h"

//
// MMC FaxServer connection class
//
#include "FaxServer.h"
#include "FaxMMCGlobals.h"

#include "snapin.h"
#include "snpnscp.h"


class CppFaxServerGeneral;    
class CppFaxServerReceipts;
class CppFaxServerEvents;
class CppFaxServerLogging;
class CppFaxServerOutbox;
class CppFaxServerInbox;
class CppFaxServerSentItems;


//////////////////////////////////////////////////////////////
//class COutRoutingRulesNode;

class CFaxServerNode : public CNodeWithScopeChildrenList<CFaxServerNode, FALSE>
{
public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxServerNode, FALSE)
        SNAPINCOMMAND_ENTRY(IDM_SRV_START,   OnServiceStartCommand)
        SNAPINCOMMAND_ENTRY(IDM_SRV_STOP,    OnServiceStopCommand)
        SNAPINCOMMAND_ENTRY(ID_START_BUTTON, OnServiceStartCommand)
        SNAPINCOMMAND_ENTRY(ID_STOP_BUTTON,  OnServiceStopCommand)

        SNAPINCOMMAND_ENTRY(ID_CLIENTCONSOLE_BUTTON,  OnLaunchClientConsole)
        SNAPINCOMMAND_ENTRY(IDM_LAUNCH_CONSOLE,       OnLaunchClientConsole)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxServerNode)
        SNAPINTOOLBARID_ENTRY(IDR_TOOLBAR_STARTSTOP)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_FAX_MENU)

    //
    // Constructor
    //
    CFaxServerNode(CSnapInItem * pParentNode, CSnapin * pComponentData, LPTSTR lptstrServerName ) :
        CNodeWithScopeChildrenList<CFaxServerNode, FALSE>(pParentNode, pComponentData ),
        m_FaxServer(lptstrServerName)
    {        
        
        m_pFaxServerGeneral    =  NULL;    
        m_pFaxServerEmail      =  NULL;
        m_pFaxServerEvents     =  NULL;
        m_pFaxServerLogging    =  NULL;
        m_pFaxServerOutbox     =  NULL;
        m_pFaxServerInbox      =  NULL;
        m_pFaxServerSentItems  =  NULL;

	    m_pParentNodeEx = NULL; // we are at the root now

        m_fAllowOverrideServerName   = FALSE;

        m_IsPrimaryModeSnapin        = FALSE;

        m_IsLaunchedFromSavedMscFile = FALSE;
    }

    //
    // Destructor
    //
    ~CFaxServerNode()
    {
    }

    virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    // virtual
    HRESULT OnRefresh(LPARAM arg,
                      LPARAM param,
                      IComponentData *pComponentData,
                      IComponent * pComponent,
                      DATA_OBJECT_TYPES type);

    //
    // Property pages methods
    //
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        IUnknown* pUnk,
        DATA_OBJECT_TYPES type);

    STDMETHOD(CreateSnapinManagerPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                                        LONG_PTR handle);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT || type == CCT_SNAPIN_MANAGER)
            return S_OK;
        return S_FALSE;
    }

    HRESULT   InitDisplayName();

    const CComBSTR&  GetServerName();

    STDMETHOD(SetServerNameOnSnapinAddition)(BSTR bstrServerName, BOOL fAllowOverrideServerName);
    STDMETHOD(UpdateServerName)(BSTR bstrServerName);

    //
    // inline Fax Server ptr
    //
    inline CFaxServer * GetFaxServer() /*const*/ 
    { 
        return &m_FaxServer;
    };

    void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags);
	BOOL UpdateToolbarButton( UINT id, BYTE fsState );

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

    BOOL    GetAllowOverrideServerName() { return m_fAllowOverrideServerName; };

    HRESULT InitDetailedDisplayName(); //Plus ServerName

    void    SetIsLaunchedFromSavedMscFile() { m_IsLaunchedFromSavedMscFile=TRUE; }

private:
    //
    // The property pages members
    //
    CppFaxServerGeneral   *  m_pFaxServerGeneral;    
    CppFaxServerReceipts  *  m_pFaxServerEmail;
    CppFaxServerEvents    *  m_pFaxServerEvents;
    CppFaxServerLogging   *  m_pFaxServerLogging;
    CppFaxServerOutbox    *  m_pFaxServerOutbox;
    CppFaxServerInbox     *  m_pFaxServerInbox;
    CppFaxServerSentItems *  m_pFaxServerSentItems;

    //
    // Handles
    //
    static CColumnsInfo      m_ColsInfo;

    CFaxServer               m_FaxServer;
    
    BOOL                     m_fAllowOverrideServerName;

    BOOL                     m_IsPrimaryModeSnapin;

    BOOL                     m_IsLaunchedFromSavedMscFile;

    //
    // event handlers
    //
    HRESULT OnLaunchClientConsole(bool &bHandled, CSnapInObjectRootBase *pRoot); 
    HRESULT OnServiceStartCommand(bool &bHandled, CSnapInObjectRootBase *pRoot);
    HRESULT OnServiceStopCommand (bool &bHandled, CSnapInObjectRootBase *pRoot);

    HRESULT ForceRedrawNode();
};

typedef CNodeWithScopeChildrenList<CFaxServerNode, FALSE>
        CBaseFaxNode;

#endif  //H_FAXSERVERNODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\fxsvalid.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FxsValid.h                                             //
//                                                                         //
//  DESCRIPTION   : Fax Validity checks.                                   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Mar 29 2000 yossg   Create                                         //  
//      Jul  4 2000 yossg   Add IsLocalServerName                                         //  
//                                                                         //
//  Copyright (C) 2000 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FXSVALID_MMC_H
#define H_FXSVALID_MMC_H


BOOL IsNotEmptyString(CComBSTR bstrGenStr); 

BOOL IsValidServerNameString(CComBSTR bstrServerName, UINT * puIds, BOOL fIsDNSName = FALSE);

BOOL IsValidPortNumber(CComBSTR bstrPort, DWORD * pdwPortVal, UINT * puIds);

BOOL IsLocalServerName(IN LPCTSTR lpszComputer);


#endif  //H_FXSVALID_MMC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\generalnotifywnd.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : GeneralNotifyWnd.h                                      //
//                                                                         //
//  DESCRIPTION   : Header file of fax Device notification window.         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Aug  3 2000 yossg  Create                                          //
//                                                                         //
//  Copyright (C) 2000  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef _H_FAX_DEVICE_NOTIFY_WND_H_
#define _H_FAX_DEVICE_NOTIFY_WND_H_

#include <atlwin.h>

const int WM_GENERAL_EVENT_NOTIFICATION = WM_USER + 3; 

class CFaxDevicesNode;
class CFaxServer;

class CFaxGeneralNotifyWnd : public CWindowImpl<CFaxGeneralNotifyWnd> 
{

public:
    //
    // Constructor
    //
    CFaxGeneralNotifyWnd(CFaxServer * pParent)
    {
        m_pFaxServer = pParent;
    }

    //
    // Destructor
    //
    ~CFaxGeneralNotifyWnd()
    {
    }
 
    BEGIN_MSG_MAP(CFaxGeneralNotifyWnd)
       MESSAGE_HANDLER(WM_GENERAL_EVENT_NOTIFICATION,OnServerEvent)
    END_MSG_MAP()

    LRESULT OnServerEvent( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

private:
    CFaxServer * m_pFaxServer;
};

#endif // _H_FAX_DEVICE_NOTIFY_WND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\generalnotifywnd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : GeneralNotifyWnd.cpp                                    //
//                                                                         //
//  DESCRIPTION   : The implementation of fax Device notification window.  //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Aug  3 2000 yossg  Create                                          //
//                                                                         //
//  Copyright (C) 2000  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "GeneralNotifyWnd.h"

#include "FaxServer.h"



/*
 -  CFaxGeneralNotifyWnd::OnServerDeviceStateChanged
 -
 *  Purpose:
 *     Catch the server event of device status change and 
 *     update the change through Devices node.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CFaxGeneralNotifyWnd::OnServerEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    DEBUG_FUNCTION_NAME( _T("CFaxGeneralNotifyWnd::OnServerEvent"));
    ATLASSERT(m_pDevicesNode);

	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( fHandled );

    HRESULT hRc = S_OK;
    
    ATLASSERT( uiMsg == WM_GENERAL_EVENT_NOTIFICATION );
    
    //
    // Extract event object
    //
    PFAX_EVENT_EX  pFaxEvent = NULL;
	pFaxEvent = reinterpret_cast<PFAX_EVENT_EX>(lParam);
    ATLASSERT( pFaxEvent );
    
	//
    // Update FaxServer object with "Devices" event
    //
    ATLASSERT(m_pFaxServer);
    
    hRc = m_pFaxServer->OnNewEvent(pFaxEvent);
    if (S_OK != hRc)
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to trsport new event to FaxServer object"));
    }

    //
    // Free buffer (any way!)
    //
    if (pFaxEvent) 
    {
        FaxFreeBuffer (pFaxEvent);
        pFaxEvent = NULL;
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\helper.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Helper.cpp                                             //
//                                                                         //
//  DESCRIPTION   : Some helper functions.                                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 27 1999 yossg   move to Fax                                         //
//                                                                         //
//  Copyright (C) 1998 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

int
DlgMsgBox(CWindow *pWin, int ids, UINT nType/*=MB_OK*/)
{
    CComBSTR    bstrTitle;
    WCHAR       szText[256];
    int         rc;

    //
    // Load the string
    //
    rc = ::LoadString(_Module.GetResourceInstance(), ids, szText, 256);
    if (rc <= 0)
    {
        return E_FAIL;
    }

    //
    // Get the window text, to be set as the message box title
    //
    pWin->GetWindowText(bstrTitle.m_str);

    //
    // Show the message box
    //
    if(IsRTLUILanguage())
    {
        nType |= MB_RTLREADING | MB_RIGHT;
    }

    rc = pWin->MessageBox(szText, bstrTitle, nType);

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\hlpres.h ===
// Help ID include file.
// Used by MsFxsSnp.rc
//

//
// IDD_FAXSERVER_RECEIPTS
//
#define HIDC_RECEIPT_ENABLE_SMTP_CHECK    0x80ef03ec           
#define HIDC_RECEIPT_ENABLE_MSGBOX_CHECK  0x80ef03f3           
#define HIDC_ADDRESS_EDIT               0x80e10483           
#define HIDC_ADDRESS_STATIC             HIDC_ADDRESS_EDIT    
#define HIDC_PORT_EDIT                  0x80e10453           
#define HIDC_PORT_STATIC                HIDC_PORT_EDIT       
#define HIDC_SMTP_EDIT                  0x80e1043a           
#define HIDC_SMTP_STATIC                HIDC_SMTP_EDIT       
#define HIDC_SMTP_AUTHEN_BUTTON         0x80e103f3    
#define HIDC_SMTP_ROUTE_CHECK           0x80e1047a

//
// IDD_DLG_SMTP_SET
//
#define HIDC_SMTP_ANONIM_RADIO1         0x80e103ec
#define HIDC_SMTP_ANONYM_STATIC         HIDC_SMTP_ANONIM_RADIO1  
#define HIDC_SMTP_BASIC_RADIO2          0x80e1050d           
#define HIDC_SMTP_BASIC_STATIC          HIDC_SMTP_BASIC_RADIO2 
#define HIDC_SMTP_CREDENTIALS_BASIC_BUTTON  0x80e10500    
#define HIDC_SMTP_NTLM_RADIO3           0x80e1050e           
#define HIDC_SMTP_NTLM_STATIC           HIDC_SMTP_NTLM_RADIO3 
#define HIDC_SMTP_CREDENTIALS_NTLM_BUTTON   0x80e10501    

//
// IDD_CONFIRM_PASSWORD
//
#define HIDC_SMTP_USERNAME_EDIT         0x80e10446           
#define HIDC_SMTP_USERNAME_STATIC       HIDC_SMTP_USERNAME_EDIT   
#define HIDC_SMTP_PASSWORD_EDIT         0x80e1044b           
#define HIDC_SMTP_PASSWORD_STATIC       HIDC_SMTP_PASSWORD_EDIT   
#define HIDC_CONFIRM_PASSWORD_EDIT      HIDC_SMTP_PASSWORD_EDIT   
#define HIDC_CONFIRM_PASSWORD_STATIC    HIDC_SMTP_PASSWORD_EDIT   

//
// IDD_FAXSERVER_INBOX_ARCHIVE
//
#define HIDC_ADAYS_STATIC               HIDC_AUTODEL_EDIT    
#define HIDC_TO_ARCHIVE_CHECK           0x80e504de           
#define HIDC_AUTODEL_CHECK              0x80e504d6           
#define HIDC_AUTODEL_EDIT               0x80e50432           
#define HIDC_QUOTA_HIGH_STATIC          HIDC_HIGH_EDIT       
#define HIDC_HIGH_EDIT                  0x80e50430           
#define HIDC_GENERATE_WARNING_CHECK     0x80e50416           
#define HIDC_QUOTA_LOW_STATIC           HIDC_LOW_EDIT        
#define HIDC_LOW_EDIT                   0x80e504dc           
#define HIDC_INBOX_BROWSE_BUTTON        0x80e50516           
#define HIDC_INBOX_FOLDER_EDIT          0x80e5051f           

//
// IDD_FAXSERVER_OUTBOX
//
#define HIDC_ALLOW_PERSONAL_CHECK       0x80e404d1           
#define HIDC_BRANDING_CHECK             0x80e404e8           
#define HIDC_DAYS_EDIT                  0x80e40431           
#define HIDC_DAYS_STATIC                HIDC_DAYS_EDIT       
#define HIDC_DELETE_CHECK               0x80e40415           
#define HIDC_RETRYDELAY_EDIT            0x80e40428           
#define HIDC_OUTB_RETRYDELAY_STATIC     HIDC_RETRYDELAY_EDIT 
#define HIDC_RETRIES_EDIT               0x80e40426           
#define HIDC_RETRIES_STATIC             HIDC_RETRIES_EDIT    
#define HIDC_TSID_CHECK                 0x80e404ce           
#define HIDC_DISCOUNT_START_TIME        0x80e40521    
#define HIDC_OUTB_DIS_START_STATIC      HIDC_DISCOUNT_START_TIME
#define HIDC_DISCOUNT_STOP_TIME         0x80e40522    
#define HIDC_OUTB_DIS_STOP_STATIC       HIDC_DISCOUNT_STOP_TIME

//
// IDD_FAXOUTRULE_GENERAL
//
#define HIDC_AREA_RADIO1                0x806a03f1           
#define HIDC_COUNTRY_RADIO1             0x806a03eb           
#define HIDC_DESTINATION_RADIO21        0x806a03f9           
#define HIDC_DEVICES4RULE_COMBO1        0x806a049f           
#define HIDC_GROUP4RULE_COMBO1          0x806a04a2           
#define HIDC_RULE_AREACODE_EDIT1        0x806a0506           
#define HIDC_DESTINATION_RADIO11        0x806a03f6           
#define HIDC_RULE_COUNTRYCODE_EDIT1     0x806a049b        
#define HIDC_RULE_SELECT_BUTTON1        0x806a0499        

//
// IDD_FAXDEVICE_GENERAL
//
#define HIDC_DEVICE_CSID_EDIT           0x80d6044d             
#define HIDC_CSID_STATIC                HIDC_DEVICE_CSID_EDIT  
#define HIDC_DEVICE_TSID_EDIT           0x80d60447             
#define HIDC_TSID_STATIC                HIDC_DEVICE_TSID_EDIT  
#define HIDC_DEVICE_RINGS_EDIT          0x80d604eb             
#define HIDC_DEVICE_RINGS_STATIC        HIDC_DEVICE_RINGS_EDIT 
#define HIDC_RECEIVE_CHECK              0x80d6040d             
#define HIDC_RECEIVE_MANUAL_RADIO2      0x80d6040a             
#define HIDC_RECEIVE_AUTO_RADIO1        0x80d6040b             
#define HIDC_SEND_CHECK                 0x80d6047b             
#define HIDC_DEVICE_DESCRIPTION_EDIT    0x80d6043d             
#define HIDC_FAXDEVICE_DESCRIPTION_STATIC \
                                        HIDC_DEVICE_DESCRIPTION_EDIT 

//
// IDD_FAXPROVIDER_GENERAL
//
#define HIDC_FSPVPATH_EDIT              0x80eb044e           
#define HIDC_FSPPATH_STATIC             HIDC_FSPVPATH_EDIT   
#define HIDC_FSPSTATUS_EDIT             0x80eb0448           
#define HIDC_FSPSTATUS_STATIC           HIDC_FSPSTATUS_EDIT  
#define HIDC_FSPVERSION_EDIT            0x80eb0440           
#define HIDC_VERSION_STATIC             HIDC_FSPVERSION_EDIT 

//
// IDD_FAXSERVER_LOGGING
//
#define HIDC_INCOMING_LOG_CHECK         0x80e204bf            
#define HIDC_LOG_BROWSE_BUTTON          0x80e20517            
#define HIDC_LOG_FILE_EDIT              0x80e2043c            
#define HIDC_OUTGOING_LOG_CHECK         0x80e204c0            

//
// IDD_FAXSERVER_SENTITEMS
//
#define HIDC_SENT_AUTODEL_CHECK         0x80e6051e            
#define HIDC_SENT_AUTODEL_EDIT          0x80e6051c            
#define HIDC_SENT_BROWSE_BUTTON         0x80e604c2            
#define HIDC_FOLDER_EDIT                0x80e604d4            
#define HIDC_SENT_GENERATE_WARNING_CHECK 0x80e60457            
#define HIDC_SENT_HIGH_EDIT             0x80e6051b            
#define HIDC_SENT_QUOTA_HIGH_STATIC     HIDC_SENT_HIGH_EDIT   
#define HIDC_SENT_LOW_EDIT              0x80e6051a            
#define HIDC_SENT_QUOTA_LOW_STATIC      HIDC_SENT_LOW_EDIT    
#define HIDC_SENT_TO_ARCHIVE_CHECK      0x80e60456            

//
// IDD_FAXSERVER_EVENTS
//
#define HIDC_GENERAL_STATIC             0x80e304ca            
#define HIDC_INBOUND_STATIC             0x80e304c7            
#define HIDC_INIT_STATIC                0x80e304c9            
#define HIDC_OUTBAND_STATIC             0x80e304c8            
#define HIDC_SLIDER1                    HIDC_GENERAL_STATIC   
#define HIDC_SLIDER2                    HIDC_INBOUND_STATIC   
#define HIDC_SLIDER3                    HIDC_OUTBAND_STATIC   
#define HIDC_SLIDER4                    HIDC_INIT_STATIC      

//
// IDD_FAXSERVER_GENERAL
//
#define HIDC_VERSION_DTEXT              0x80e004b4                  
#define HIDC_GENERAL_HEAD_STATIC        HIDC_VERSION_DTEXT          
#define HIDC_INCOM_INPROC_ROEDIT        0x80e0044f                  
#define HIDC_INCOM_INPROC_STATIC        HIDC_INCOM_INPROC_ROEDIT    
#define HIDC_OUTGOING_INPROC_ROEDIT     0x80e00449                  
#define HIDC_OUTGOING_INPROC_STATIC     HIDC_OUTGOING_INPROC_ROEDIT 
#define HIDC_QUED_ROEDIT                0x80e00441                  
#define HIDC_QUED_STATIC                HIDC_QUED_ROEDIT            
#define HIDC_RECEPTION_CHECK            0x80e00514                  
#define HIDC_SUBMISSION_CHECK           0x80e00512                  
#define HIDC_TRANSSMI_CHECK             0x80e00513                  

//
// IDD_FAXCATALOGMETHOD_GENERAL
//
#define HIDC_EXTENSION_DLL_EDIT         0x80ea043f                 
#define HIDC_CATA_EXTENSION_STATIC      HIDC_EXTENSION_DLL_EDIT    

//
// IDD_FAXINMETHOD_GENERAL
//
#define HIDC_INMETHOD_EXT_H_STATIC      0x80e804f8             
#define HIDC_INMETHOD_STATUS_H_STATIC   0x80e804f7             
#define HIDC_INMETOD_NAME_H_STATIC      0x80e804f6             

//
// IDD_DLGNEWDEVICE
//
#define HIDC_DEVICESLIST_STATIC         HIDC_DEVICE_LISTVIEW   
#define HIDC_DEVICE_LISTVIEW            0x80dd0504             

//
// IDD_DLGNEWGROUP
//
#define HIDC_GROUPNAME_EDIT             0x80d50501             
#define HIDC_GROUPNAME_STATIC           HIDC_GROUPNAME_EDIT    

//
// IDD_DLGNEWRULE
//
#define HIDC_AREA_RADIO                 0x80e903f0             
#define HIDC_AREA_STATIC                HIDC_AREA_RADIO        
#define HIDC_COUNTRY1_STATIC            HIDC_COUNTRYRULE_COMBO 
#define HIDC_COUNTRY_RADIO              0x80e903ea             
#define HIDC_DESTINATION_RADIO1         0x80e903f5             
#define HIDC_DESTINATION_RADIO2         0x80e903f8             
#define HIDC_DEVICES4RULE_COMBO         0x80e9049e             
#define HIDC_GROUP4RULE_COMBO           0x80e904a1             
#define HIDC_RULE_AREACODE_EDIT         0x80e904d1        
#define HIDC_NEWRULE_COUNTRYCODE_EDIT   0x80e904d3        
#define HIDC_NEWRULE_SELECT_BUTTON      0x80e904d5        

//
// SELECT COUNTRY OR REGION
//
#define HIDC_COUNTRYRULE_COMBO          0x80e9049a   


#define HIDOK                           0x80d90001    
#define HIDCANCEL                       0x80d90002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\helper.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Helper.h                                               //
//                                                                         //
//  DESCRIPTION   : Prototype of some helper functions.                    //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jun  2 1999 yossg    add     CHECK_RETURN_VALUE_AND_PRINT_DEBUG    //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_HELPER_H
#define H_HELPER_H

int DlgMsgBox(CWindow *pWin, int ids, UINT nType = MB_OK);

// required:
//  * to be called after decleration of    
//         DEBUG_FUNCTION_NAME( _T("CClass::FuncName"));
//  * hRc the Name of HRESULT
//  * _str - string for DPF = _T("CClass::FuncName")
//  * exit point will be called -- Cleanup:
//   

#define CHECK_RETURN_VALUE_AND_PRINT_DEBUG(_str)           \
{                                                          \
    if (FAILED (hRc))                                      \
    {                                                      \
        DebugPrintEx(DEBUG_ERR,_str, hRc);                 \
        goto Cleanup;                                      \
    }                                                      \
}

#define CHECK_RETURN_VALUE_AND_SEND_NODE_MSGBOX(_ids)      \
{                                                          \
    if (FAILED (hRc))                                      \
    {                                                      \
        NodeMsgBox(_ids);                                  \
        goto Cleanup;                                      \
    }                                                      \
}

#define CHECK_RET_CLEAN if (FAILED(ret)) goto Cleanup;
#define CHECK_HRC_CLEAN if (FAILED(hRc)) goto Cleanup;

#endif  //H_HELPER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\icons.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Icons.h                                                //
//                                                                         //
//  DESCRIPTION   : Enumrate all COMET icons                               //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//	Dec 14 1999 yossg  arrange.				                               //
//                                                                         //
//  Copyright (C) 1998 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef ICONS_H_INCLUDED
#define ICONS_H_INCLUDED

enum FAX_SERVER_ICONS
{
    IMAGE_FOLDER_CLOSE,
    IMAGE_FOLDER_OPEN,
    IMAGE_FAX,
    IMAGE_METHOD_ENABLE,
    IMAGE_METHOD_DISABLE,
    IMAGE_RULE,
    IMAGE_DEVICE,
    IMAGE_RULE_ERROR,
    IMAGE_RULE_WARNING,
    IMAGE_GROUP_ERROR_CLOSE,
    IMAGE_GROUP_ERROR_OPEN,
    IMAGE_GROUP_WARN_CLOSE,
    IMAGE_GROUP_WARN_OPEN,
    IMAGE_FSP,
    IMAGE_FSP_ERROR,
    IMAGE_FAX_COVERPAGES,
    IMAGE_SRV_COVERPAGE,
    IMAGE_DEVICE_ERROR,
    IMAGE_DEVICE_POWERED_OFF,
    IMAGE_LAST  //must be and must be last
};

#endif // ! ICONS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\inboundrouting.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : InboundRouting.cpp                                     //
//                                                                         //
//  DESCRIPTION   : Fax Server - Fax InboundRouting node.                  //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg  Create                                          //
//      Jan 31 2000 yossg  Add full suport to method catalog               //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "InboundRouting.h"

#include "CatalogInboundRoutingMethods.h" 

#include "Icons.h"

//#include "oaidl.h"

/****************************************************

CFaxInboundRoutingNode Class

 ****************************************************/

// {7362F15F-30B2-46a4-A8CB-C1DD29F0B1BB}
static const GUID CFaxInboundRoutingNodeGUID_NODETYPE = 
{ 0x7362f15f, 0x30b2, 0x46a4, { 0xa8, 0xcb, 0xc1, 0xdd, 0x29, 0xf0, 0xb1, 0xbb } };

const GUID*    CFaxInboundRoutingNode::m_NODETYPE = &CFaxInboundRoutingNodeGUID_NODETYPE;
const OLECHAR* CFaxInboundRoutingNode::m_SZNODETYPE = OLESTR("7362F15F-30B2-46a4-A8CB-C1DD29F0B1BB");
const CLSID*   CFaxInboundRoutingNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxInboundRoutingNode::m_ColsInfo;

/*
 -  CFaxInboundRoutingNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxInboundRoutingNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    SCODE hRc;

    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingNode::InsertColumns"));

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_FAX_COL_HEAD, 200}, 
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    if (hRc != S_OK)
    {
        DebugPrintEx(DEBUG_ERR,_T("m_ColsInfo.InsertColumnsIntoMMC. (hRc: %08X)"), hRc);
        goto Cleanup;
    }

Cleanup:
    return(hRc);
}


/*
 -  CFaxInboundRoutingNode::PopulateScopeChildrenList
 -
 *  Purpose:
 *      Create all the Fax Meesages nodes:
 *      Inbox, Outbox, Sent Items, Deleted Items.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxInboundRoutingNode::PopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingNode::PopulateScopeChildrenList"));
    HRESULT             hRc = S_OK;

    
    CFaxCatalogInboundRoutingMethodsNode *  pMethods   = NULL;


    //
    // Fax Inbound routing method catalog
    //
    pMethods = new CFaxCatalogInboundRoutingMethodsNode(this, m_pComponentData);
    if (!pMethods)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Out of memory"));
        goto Error;
    }
	else
	{
        pMethods->InitParentNode(this);

        pMethods->SetIcons(IMAGE_METHOD_ENABLE, IMAGE_METHOD_ENABLE);

        hRc = pMethods->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_ROUTINGRULES);
		    goto Error;
        }

        hRc = AddChild(pMethods, &pMethods->m_scopeDataItem);
		if (FAILED(hRc))
		{
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to add outbound routing rules node. (hRc: %08X)"),
			    hRc);
			NodeMsgBox(IDS_FAILTOADD_ROUTINGRULES);
            goto Error;
		}
	}

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pMethods ) 
    {
        if (0 != pMethods->m_scopeDataItem.ID )
        {    
            HRESULT hr = RemoveChild(pMethods);
            if (FAILED(hr))
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("Fail to RemoveChild() Methods node from node list. (hRc: %08X)"), 
                    hr);
            }
        }
        delete  pMethods;    
        pMethods = NULL;    
    }

    // Empty the list
    // m_ScopeChildrenList.RemoveAll(); done from RemoveChild

    m_bScopeChildrenListPopulated = FALSE;

Exit:
    return hRc;
}


/*
 -  CFaxInboundRoutingNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxInboundRoutingNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 

    return hRc;
}


/*
 -  CFaxInboundRoutingNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxInboundRoutingNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    HRESULT hRc = S_OK;
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingNode::OnRefresh"));

    ATLTRACE(_T("CFaxInboundRoutingNode::OnRefresh"));

    //
    // Call the base class
    //
    hRc = CBaseFaxInboundRoutingNode::OnRefresh(arg,
                             param,
                             pComponentData,
                             pComponent,
                             type);
    CHECK_RETURN_VALUE_AND_PRINT_DEBUG (_T("CBaseFaxInboundRoutingNode::OnRefresh"))

Cleanup:
    return hRc;
}

/*
 -  CFaxInboundRoutingNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxInboundRoutingNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxInboundRoutingNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                                IDS_DISPLAY_STR_INBOUNDROUTINGNODE) )
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    
    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load inbound routing node name-string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}


/*
 +
 +  CFaxInboundRoutingNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxInboundRoutingNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    _TCHAR topicName[MAX_PATH];
    
    _tcscpy(topicName, helpFile);
    
    _tcscat(topicName, _T("::/FaxS_C_ManIncom.htm"));
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(topicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, topicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\inboundroutingmethods.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : InboundRoutingMethods.h                                //
//                                                                         //
//  DESCRIPTION   : Header file for the Fax Inbound Routing Methods Node   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec  1 1999 yossg   Create                                         //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXINBOUNDROUTINGMETHODS_H
#define H_FAXINBOUNDROUTINGMETHODS_H

#include "snapin.h"
#include "snpnres.h"


#include "InboundRoutingMethod.h"
 
class CFaxDeviceNode;
class CFaxInboundRoutingMethodNode;

class CFaxInboundRoutingMethodsNode : public CNodeWithResultChildrenList<
                                        CFaxInboundRoutingMethodsNode,    
                                        CFaxInboundRoutingMethodNode, 
                                        CSimpleArray<CFaxInboundRoutingMethodNode*>, 
                                        FALSE>
{

public:

    BEGIN_SNAPINCOMMAND_MAP(CFaxInboundRoutingMethodsNode, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxInboundRoutingMethodsNode)
    END_SNAPINTOOLBARID_MAP()
    //
    // Constructor
    //
    CFaxInboundRoutingMethodsNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithResultChildrenList<CFaxInboundRoutingMethodsNode, CFaxInboundRoutingMethodNode, CSimpleArray<CFaxInboundRoutingMethodNode*>, FALSE>(pParentNode, pComponentData )
    {
        m_pFaxInboundMethodsConfig  = NULL;

        m_dwNumOfInboundMethods     = 0;
        
    }

    //
    // Destructor
    //
    ~CFaxInboundRoutingMethodsNode()
    {
        if (NULL != m_pFaxInboundMethodsConfig) 
        {
            FaxFreeBuffer(m_pFaxInboundMethodsConfig);
        }

    }

	//
	// get data from RPC 
	//
    HRESULT InitRPC();

    virtual HRESULT PopulateResultChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl *pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    void InitParentNode(CFaxDeviceNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    virtual HRESULT OnRefresh(LPARAM arg,
                              LPARAM param,
                              IComponentData *pComponentData,
                              IComponent * pComponent,
                              DATA_OBJECT_TYPES type);

    HRESULT DoRefresh(CSnapInObjectRootBase *pRoot);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }

    HRESULT InitDisplayName();


    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:

    static CColumnsInfo         m_ColsInfo;
    
    PFAX_ROUTING_METHOD         m_pFaxInboundMethodsConfig;
    DWORD                       m_dwNumOfInboundMethods;
   
    CFaxDeviceNode *            m_pParentNode;
};

typedef CNodeWithResultChildrenList<CFaxInboundRoutingMethodsNode, CFaxInboundRoutingMethodNode, CSimpleArray<CFaxInboundRoutingMethodNode*>, FALSE>
        CBaseFaxInboundRoutingMethodsNode;

#endif  //H_FAXINBOUNDROUTINGMETHODS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\myctrls.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : MyCtrls.cpp                                            //
//                                                                         //
//  DESCRIPTION   : Expand the imlementation of AtlCtrls.h                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Nov 25 1999  yossg    Init.                                        //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "MyCtrls.h"


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
/*
 -  CMyUpDownCtrls::OnInitDialog
 -
 *  Purpose:
 *      Call SetPos with range verification.
 *
 *  Arguments:
 *
 *  Return:
 *      int
 */
int CMyUpDownCtrl::SetPos(int nPos)
{        
    int iMin;
    int iMax;
    
    ATLASSERT(::IsWindow(m_hWnd));
    GetRange32(iMin, iMax);        

    if (nPos > iMax)
    {
        nPos = iMax;
    }
    else if (nPos < iMin)
    {
        nPos = iMin;
    }

    return (CUpDownCtrl::SetPos(nPos));       
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\msfxssnp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : MsFxsSnp.cpp                                           //
//                                                                         //
//  DESCRIPTION   : Implementation of DLL Exports.                         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 27 1999 yossg   create                                         //
//      Nov  3 1999 yossg   add GlobalStringTable                          //   
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f MsFxsSnpps.mk in the project directory.

#include "stdafx.h"
#include "initguid.h"
#include "MsFxsSnp.h"

#include "MsFxsSnp_i.c"
#include "Snapin.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_Snapin, CSnapin)
	OBJECT_ENTRY(CLSID_SnapinAbout, CSnapinAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    DEBUG_FUNCTION_NAME( _T("MsFxsSnp.dll - DllMain"));
	DebugPrintEx(DEBUG_MSG, _T("MsFxsSnp.dll - DllMain, reason=%d"), dwReason );

    if (dwReason == DLL_PROCESS_ATTACH)
	{
 		_Module.Init(ObjectMap, hInstance);
		CSnapInItem::Init();
        InitCommonControls();
		DisableThreadLibraryCalls(hInstance);
/*        if( _Module.GetLockCount() == 0 ) {
            GlobalStringTable = new CStringTable(hInstance);
            if (!GlobalStringTable) {
                return FALSE;
            }
        }
*/	
    }
	else if(dwReason == DLL_PROCESS_DETACH) 
    {
        _Module.Term();
/*        if( _Module.GetLockCount() == 0 ) 
          {
            if(GlobalStringTable != NULL) 
            {
                delete GlobalStringTable;
            }
          }
*/
    }
    
    
    
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\inboundroutingmethods.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : InboundRoutingMethods.cpp                              //
//                                                                         //
//  DESCRIPTION   : Fax InboundRoutingMethods MMC node.                    //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec  1 1999 yossg  Create                                          //
//      Dec 14 1999 yossg  add basic functionality                         //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "snapin.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "InboundRoutingMethods.h"
#include "Device.h"
#include "Devices.h"

#include "oaidl.h"
#include "Icons.h"

//////////////////////////////////////////////////////////////
// {AA94A694-844B-4d3a-A82C-2FCBDE0FF430}
static const GUID CFaxInboundRoutingMethodsNodeGUID_NODETYPE = 
{ 0xaa94a694, 0x844b, 0x4d3a, { 0xa8, 0x2c, 0x2f, 0xcb, 0xde, 0xf, 0xf4, 0x30 } };

const GUID*    CFaxInboundRoutingMethodsNode::m_NODETYPE = &CFaxInboundRoutingMethodsNodeGUID_NODETYPE;
const OLECHAR* CFaxInboundRoutingMethodsNode::m_SZNODETYPE = OLESTR("AA94A694-844B-4d3a-A82C-2FCBDE0FF430");
const CLSID*   CFaxInboundRoutingMethodsNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxInboundRoutingMethodsNode::m_ColsInfo;

/*
 -  CFaxInboundRoutingMethodsNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxInboundRoutingMethodsNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodsNode::InsertColumns"));
    HRESULT  hRc = S_OK;

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_INBOUND_METHODS_COL1, FXS_WIDE_COLUMN_WIDTH},
        {IDS_INBOUND_METHODS_COL2, AUTO_WIDTH},
        {IDS_INBOUND_METHODS_COL3, FXS_LARGE_COLUMN_WIDTH},
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    CHECK_RETURN_VALUE_AND_PRINT_DEBUG (_T("m_ColsInfo.InsertColumnsIntoMMC"))

Cleanup:
    return(hRc);
}

/*
 -  CFaxInboundRoutingMethodsNode::initRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxInboundRoutingMethodsNode::InitRPC(  )
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodsNode::InitRPC"));
    
    HRESULT      hRc        = S_OK;
    DWORD        ec         = ERROR_SUCCESS;
	HANDLE		 hFaxPortHandle = NULL;
    CFaxServer * pFaxServer = NULL;

    //
    // get Fax Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    ATLASSERT(NULL != m_pParentNode);
    
    //
    // get Fax Device Handle
    //   
    
    //
    // only a PORT_OPEN_QUERY is needed to show the methods
    // the handle with PORT_OPEN_MODIFY priviledge will be 
    // given for limited short period for opertion required it.
    //

    if (!FaxOpenPort( pFaxServer->GetFaxServerHandle(), 
                        m_pParentNode->GetDeviceID(), 
                        PORT_OPEN_QUERY, 
                        &hFaxPortHandle )) 
    {
		ec = GetLastError();

        if (ERROR_INVALID_HANDLE ==  ec)
        {
            //Special case of ERROR_INVALID_HANDLE
		    DebugPrintEx(DEBUG_ERR,
			    _T("FaxOpenPort() failed with ERROR_INVALID_HANDLE. (ec:%ld)"),
			    ec);
            
            NodeMsgBox(IDS_OPENPORT_INVALID_HANDLE);
            
            goto Exit;
        }

		DebugPrintEx(
			DEBUG_ERR,
			TEXT("FaxOpenPort() failed. (ec:%ld)"),
			ec);
        goto Error;
    } 
    ATLASSERT(NULL != hFaxPortHandle);

    //
	// Retrieve the fax Inbound Methods configuration
	//
    if (!FaxEnumRoutingMethods(hFaxPortHandle, 
                        &m_pFaxInboundMethodsConfig,
                        &m_dwNumOfInboundMethods)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get Inbound Methods configuration. (ec: %ld)"), 
			ec);


        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(m_pFaxInboundMethodsConfig);

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get Inbound Methods configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:

    //
    // Close Fax Port handle
    // 
    if (NULL != hFaxPortHandle)
    {
        if (!FaxClose( hFaxPortHandle ))
		{
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxClose() on port handle failed (ec: %ld)"),
                GetLastError());
		}
    }

    return (hRc);
}


/*
 -  CFaxInboundRoutingMethodsNode::PopulateResultChildrenList
 -
 *  Purpose:
 *      Create the FaxInboundRoutingMethods children nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxInboundRoutingMethodsNode::PopulateResultChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodsNode::PopulateResultChildrenList"));
    HRESULT                          hRc = S_OK;

    CFaxInboundRoutingMethodNode *   pMethod;
    DWORD                            i;
    
    //
    // Get the Config. structure 
    //
    hRc = InitRPC();
    if (FAILED(hRc))
    {
        //DebugPrint and MsgBox by called func.
        
        //to be safe actually done by InitRPC on error.
        m_pFaxInboundMethodsConfig = NULL;
        
        goto Exit; //!!!
    }
    ATLASSERT(NULL != m_pFaxInboundMethodsConfig);

    
    //
    //
    //
    for ( i = 0; i < m_dwNumOfInboundMethods; i++ )
    {
            pMethod = NULL;

            pMethod = new CFaxInboundRoutingMethodNode(this, 
                                            m_pComponentData, 
                                            &m_pFaxInboundMethodsConfig[i]);
            if (!pMethod)
            {
                hRc = E_OUTOFMEMORY;
                NodeMsgBox(IDS_MEMORY);
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. (hRc: %08X)"),
			        hRc);
                goto Error;
            }
            else
            {
	            pMethod->InitParentNode(this);

                pMethod->Init(&m_pFaxInboundMethodsConfig[i]);

	            hRc = this->AddChildToList(pMethod);
	            if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to add Inbound Routing Method. (hRc: %08X)"),
			            hRc);
		            NodeMsgBox(IDS_FAILTOADD_INBOUNDROUTINGMETHODS);
                    goto Error;
	            }
                else
                {
                    pMethod = NULL;
                }
            }
    }
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pMethod ) 
    {
        delete  pMethod;    
        pMethod = NULL;    
    }
    
    //
    // Get rid of what we had.
    //
    {
        // Delete each node in the list of children
        int iSize = m_ResultChildrenList.GetSize();
        for (int j = 0; j < iSize; j++)
        {
            pMethod = (CFaxInboundRoutingMethodNode *)
                                    m_ResultChildrenList[j];
            delete pMethod;
        }

        // Empty the list
        m_ResultChildrenList.RemoveAll();

        // We no longer have a populated list.
        m_bResultChildrenListPopulated = FALSE;
    }
    
Exit:
    return hRc;
}



/*
 -  CFaxInboundRoutingMethodsNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxInboundRoutingMethodsNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    //  Refresh
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);

    return hRc;
}


/*
 -  CFaxInboundRoutingMethodsNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
/* virtual */HRESULT
CFaxInboundRoutingMethodsNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodsNode::OnRefresh"));
    HRESULT hRc = S_OK;

    //
    // Call the base class
    //
    hRc = CBaseFaxInboundRoutingMethodsNode::OnRefresh(arg,
                             param,
                             pComponentData,
                             pComponent,
                             type);
    if ( FAILED(hRc) )
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to call base class's OnRefresh. (hRc: %08X)"),
			hRc);
        
        int iRes;
        NodeMsgBox(IDS_FAIL2REFERESH_DEVICEINMETHODS, MB_OK | MB_ICONERROR, &iRes);
        
        ATLASSERT(IDOK == iRes);
        if (IDOK == iRes)
        {
            CFaxDevicesNode *   pFaxDevices = NULL;
            
            ATLASSERT(m_pParentNode);
            pFaxDevices = m_pParentNode->GetParent();

            ATLASSERT(pFaxDevices);            
            hRc = pFaxDevices->DoRefresh();
            if ( FAILED(hRc) )
            {
                DebugPrintEx(
			        DEBUG_ERR,
			        _T("Fail to call parent node - Groups DoRefresh. (hRc: %08X)"),
			        hRc);
            
            }

        }

        goto Exit;
    }


Exit:
    return hRc;
}


/*
 -  CFaxInboundRoutingMethodsNode::DoRefresh
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxInboundRoutingMethodsNode::DoRefresh(CSnapInObjectRootBase *pRoot)
{
    CComPtr<IConsole> spConsole;

    //
    // Repopulate childs
    //
    RepopulateResultChildrenList();

    if (pRoot)
    {
        //
        // Get the console pointer
        //
        ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
        if (pRoot->m_nType == 1)
        {
            //
            // m_ntype == 1 means the IComponentData implementation
            //
            CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
            spConsole = pCComponentData->m_spConsole;
        }
        else
        {
            //
            // m_ntype == 2 means the IComponent implementation
            //
            CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
            spConsole = pCComponent->m_spConsole;
        }
    }
    else
    {
        ATLASSERT(m_pComponentData);
        spConsole = m_pComponentData->m_spConsole;
    }

    ATLASSERT(spConsole);
    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return S_OK;
}

/*
 -  CFaxInboundRoutingMethodsNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxInboundRoutingMethodsNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxInboundRoutingMethodsNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                        IDS_DISPLAY_STR_INROUTEMETHODSNODE))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}

/*
 +
 +  CFaxInboundRoutingMethodsNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxInboundRoutingMethodsNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    _TCHAR topicName[MAX_PATH];
    
    _tcscpy(topicName, helpFile);
    
    _tcscat(topicName, _T("::/FaxS_C_RcvdFaxRout.htm"));
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(topicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, topicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

///////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\inboundrouting.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : InboundRouting.h                                       //
//                                                                         //
//  DESCRIPTION   : Header file for CFaxInboundRoutingNode class           //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg   create                                         //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXINBOUNDROUTINGNODE_H
#define H_FAXINBOUNDROUTINGNODE_H


#include "snapin.h"
//#include "snpnode.h"
#include "snpnscp.h"


class CFaxServerNode;

class CFaxInboundRoutingNode : public CNodeWithScopeChildrenList<CFaxInboundRoutingNode, FALSE>
{
public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxInboundRoutingNode, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxInboundRoutingNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_SNAPIN_MENU)

    CFaxInboundRoutingNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithScopeChildrenList<CFaxInboundRoutingNode, FALSE>(pParentNode, pComponentData )
    {
    }

    ~CFaxInboundRoutingNode()
    {
    }

    virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    // virtual
    HRESULT OnRefresh(LPARAM arg,
                      LPARAM param,
                      IComponentData *pComponentData,
                      IComponent * pComponent,
                      DATA_OBJECT_TYPES type);

    void InitParentNode(CFaxServerNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    HRESULT InitDisplayName();

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:
    
    static CColumnsInfo m_ColsInfo;

    CFaxServerNode                 * m_pParentNode;
};

typedef CNodeWithScopeChildrenList<CFaxInboundRoutingNode, FALSE>
        CBaseFaxInboundRoutingNode;


#endif  //H_FAXINBOUNDROUTINGNODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\inboundroutingmethod.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : InboundRoutingMethod.cpp                              //
//                                                                         //
//  DESCRIPTION   : Implementation of the Inbound Routing Method node.    //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec  1 1999 yossg   Created                                        //
//      Dec 14 1999 yossg  add basic functionality                         //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "snapin.h"

#include "InboundRoutingMethod.h"
#include "InboundRoutingMethods.h"

#include "FaxServer.h"
#include "FaxServerNode.h"


#include "oaidl.h"
#include "urlmon.h"
#include "mshtmhst.h"
#include "exdisp.h"
#include "faxmmc.h"

/////////////////////////////////////////////////////////////////////////////
// {220D2CB0-85A9-4a43-B6E8-9D66B44F1AF5}
static const GUID CFaxInboundRoutingMethodNodeGUID_NODETYPE = FAXSRV_ROUTING_METHOD_NODETYPE_GUID;

const GUID*     CFaxInboundRoutingMethodNode::m_NODETYPE        = &CFaxInboundRoutingMethodNodeGUID_NODETYPE;
const OLECHAR*  CFaxInboundRoutingMethodNode::m_SZNODETYPE      = FAXSRV_ROUTING_METHOD_NODETYPE_GUID_STR;
//const OLECHAR* CnotImplemented::m_SZDISPLAY_NAME = OLESTR("Inbound Routing Methods");
const CLSID*    CFaxInboundRoutingMethodNode::m_SNAPIN_CLASSID  = &CLSID_Snapin;

CLIPFORMAT CFaxInboundRoutingMethodNode::m_CFExtensionName = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_ROUTEEXT_NAME);
CLIPFORMAT CFaxInboundRoutingMethodNode::m_CFMethodGuid = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_ROUTING_METHOD_GUID);
CLIPFORMAT CFaxInboundRoutingMethodNode::m_CFServerName = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_SERVER_NAME);
CLIPFORMAT CFaxInboundRoutingMethodNode::m_CFDeviceId = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_DEVICE_ID);

/*
 -  CFaxInboundRoutingMethodNode::Init
 -
 *  Purpose:
 *      Init all members icon etc.
 *
 *  Arguments:
 *      [in]    pMethodConfig - PFAX_ROUTING_METHOD
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxInboundRoutingMethodNode::Init(PFAX_ROUTING_METHOD pMethodConfig)
{

    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodNode::Init"));
    HRESULT hRc = S_OK;

    ATLASSERT(pMethodConfig);

    hRc = InitMembers( pMethodConfig );
    if (FAILED(hRc))
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to InitMembers"));
        
        //NodeMsgBox done by called func.
        
        goto Exit;
    }
    
    //
    // Icon
    //
    m_resultDataItem.nImage = (m_fEnabled ? IMAGE_METHOD_ENABLE : IMAGE_METHOD_DISABLE );

Exit:
    return hRc;
}

/*
 -  CFaxInboundRoutingMethodNode::InitMembers
 -
 *  Purpose:
 *      Private method to initiate members
 *      Must be called after init of m_pParentNode
 *
 *  Arguments:
 *      [in]    pMethodConfig - PFAX_ROUTING_METHOD structure
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxInboundRoutingMethodNode::InitMembers(PFAX_ROUTING_METHOD pMethodConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodNode::InitMembers"));
    HRESULT hRc = S_OK;

    ATLASSERT(pMethodConfig);
    
    m_dwDeviceID         = pMethodConfig->DeviceId;
    
    m_fEnabled           = pMethodConfig->Enabled;

    m_bstrDisplayName    = pMethodConfig->FriendlyName;
    if (!m_bstrDisplayName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    m_bstrFriendlyName   = pMethodConfig->FriendlyName;
    if (!m_bstrFriendlyName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    m_bstrMethodGUID     = pMethodConfig->Guid;
    if (!m_bstrMethodGUID)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    m_bstrExtensionFriendlyName   
                         = pMethodConfig->ExtensionFriendlyName;
    if (!m_bstrExtensionFriendlyName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    m_bstrExtensionImageName   
                         = pMethodConfig->ExtensionImageName;
    if (!m_bstrExtensionImageName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    ATLASSERT(NULL != m_pParentNode);
    if (NULL != m_pParentNode)
    {
        m_pParentNode->NodeMsgBox(IDS_MEMORY);
    }
    
Exit:
    return (hRc);
}

/*
 -  CFaxInboundRoutingMethodNode::GetResultPaneColInfo
 -
 *  Purpose:
 *      Return the text for specific column
 *      Called for each column in the result pane
 *
 *  Arguments:
 *      [in]    nCol - column number
 *
 *  Return:
 *      String to be displayed in the specific column
 */
LPOLESTR CFaxInboundRoutingMethodNode::GetResultPaneColInfo(int nCol)
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodNode::GetResultPaneColInfo"));
    HRESULT hRc = S_OK;

    UINT uiResourceId;

    m_buf.Empty();

    switch (nCol)
    {
    case 0:
            //
            // Name
            //
            if (!m_bstrFriendlyName)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrFriendlyName."));
                goto Error;
            }
            else
            {
                return (m_bstrFriendlyName);
            }

    case 1:
            //
            // Enabled
            //
           uiResourceId = (m_fEnabled ? IDS_FXS_YES : IDS_FXS_NO);
                        
           if (!m_buf.LoadString(_Module.GetResourceInstance(), uiResourceId) )
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to load string for the method enabled value."));

                goto Error;
            }
            else
            {
                return (m_buf);
            }
    case 2:
            //
            // Extension 
            //
            if (!m_bstrExtensionFriendlyName)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrExtensionFriendlyName."));
                goto Error;
            }
            else
            {
                return (m_bstrExtensionFriendlyName);
            }

    default:
            ATLASSERT(0); // "this number of column is not supported "
            return(L"");

    } // endswitch (nCol)

Error:
    return(L"???");

}


/*
 -  CFaxInboundRoutingMethodNode::CreatePropertyPages
 -
 *  Purpose:
 *      Called when creating a property page of the object
 *
 *  Arguments:
 *      [in]    lpProvider - The property sheet
 *      [in]    handle     - Handle for notification
 *      [in]    pUnk       - Pointer to the data object
 *      [in]    type       - CCT_* (SCOPE, RESULT, ...)
 *
 *  Return:
 *      OLE error code
 */

HRESULT
CFaxInboundRoutingMethodNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                    LONG_PTR                handle,
                                    IUnknown                *pUnk,
                                    DATA_OBJECT_TYPES       type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodNode::CreatePropertyPages"));
    HRESULT hRc = S_OK;


    ATLASSERT(lpProvider);
    ATLASSERT(type == CCT_RESULT || type == CCT_SCOPE);

    //
    // Initiate
    //
    m_pInboundRoutingMethodGeneral = NULL;    

    //
    // General
    //
    m_pInboundRoutingMethodGeneral = new CppFaxInboundRoutingMethod(
												 handle,
                                                 this,
                                                 TRUE,
                                                 _Module.GetResourceInstance());

	if (!m_pInboundRoutingMethodGeneral)
	{
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
        goto Error;
	}
	
    /*  
     * not exists : m_pPP..->InitRPC();	
     */


    hRc = lpProvider->AddPage(m_pInboundRoutingMethodGeneral->Create());
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add property page for General tab. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != m_pInboundRoutingMethodGeneral ) 
    {
        delete  m_pInboundRoutingMethodGeneral;    
        m_pInboundRoutingMethodGeneral = NULL;    
    }

Exit:
    return hRc;
}


/*
 -  CFaxInboundRoutingMethodNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxInboundRoutingMethodNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // Display verbs that we support:
    // 1. Properties
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    //
    // We want the default verb to be Properties
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    return hRc;
}


/*
 -  CFaxInboundRoutingMethodNode::OnMethodEnabled
 -
 *  Purpose:
 *      Called when Enable /Disable menu was pushed.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxInboundRoutingMethodNode::OnMethodEnabled (bool &bHandled, CSnapInObjectRootBase *pRoot)
{ 
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodNode::OnMethodEnabled"));
    HRESULT hRc = S_OK;
    
    BOOL fNewState;
    
    fNewState = !m_fEnabled;

    hRc = ChangeEnable( fNewState);
    if ( S_OK != hRc )
    {
            //DebugPrint in the function layer
            return S_FALSE;
    }

    //
    // Service succeded. now change member
    //
    m_fEnabled = fNewState;

    //
    // Refresh the result pane view 
    //
    m_resultDataItem.nImage = (m_fEnabled ? IMAGE_METHOD_ENABLE : IMAGE_METHOD_DISABLE );
    
    hRc = RefreshSingleResultItem(pRoot);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to RefreshSingleResultItem. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TOREFRESH_INMETHOD_NODE);        
    }

    return hRc; 
}

/*
 -  CFaxInboundRoutingMethodNode::ChangeEnable
 -
 *  Purpose:
 *      .
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxInboundRoutingMethodNode::ChangeEnable(BOOL fState)
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodNode::ChangeEnable"));
    	
    HRESULT              hRc            = S_OK;

    DWORD                ec             = ERROR_SUCCESS;

    CFaxServer *         pFaxServer     = NULL;
    HANDLE               hFaxPortHandle = NULL;
    
    //
    // Get RPC Handle
    //
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    
    //
    // Get Fax Device Handle
    //
    
    ATLASSERT(m_pParentNode);
    // only a valid handle with PORT_OPEN_MODIFY accepted here!
    if (!FaxOpenPort( pFaxServer->GetFaxServerHandle(), 
                        m_dwDeviceID, 
                        PORT_OPEN_MODIFY | PORT_OPEN_QUERY, 
                        &hFaxPortHandle )) 
    {         
        ec = GetLastError();
        // if modification handle is currently shared
        // ec == ERROR_INVALID_HANDLE 
        if (ERROR_INVALID_HANDLE ==  ec)
        {
            //Special case of ERROR_INVALID_HANDLE
		    DebugPrintEx(DEBUG_ERR,
			    _T("FaxOpenPort() failed with ERROR_INVALID_HANDLE. (ec:%ld)"),
			    ec);
            
            NodeMsgBox(IDS_OPENPORT_INVALID_HANDLE);
            
            hRc = HRESULT_FROM_WIN32(ec);
            
            goto Exit;
        }
        
		DebugPrintEx(DEBUG_ERR,
			_T("FaxOpenPort() failed with. (ec:%ld)"),
			ec);
        
        goto Error;
    } 
    ATLASSERT(NULL != hFaxPortHandle);

    //
    // Set Enabled
    //
    if (!FaxEnableRoutingMethod(
                hFaxPortHandle,
                m_bstrMethodGUID,
                fState)) 
    {		
        ec = GetLastError();
        
        //
        // 1) Warning
        //
        if (ERROR_BAD_CONFIGURATION == ec && fState)
        {
            DebugPrintEx(
			    DEBUG_WRN,
			    _T("Cannot enable routing method. The method configuration has some invalid data.(ec: %ld)"), 
			    ec);

            hRc = HRESULT_FROM_WIN32(ec);
	        
            NodeMsgBox(IDS_FAIL2ENABLE_METHOD, MB_OK | MB_ICONEXCLAMATION);
                  
            goto Exit;
        }

        //
        // 2) Error
        //

        //
        // 	a) Network Error
        //
        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
            
            goto Error;
        }
            
        //
        // 	b) General Error
        //
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to enable /disable routing method. (ec: %ld)"), 
			ec);

        NodeMsgBox(IDS_FAIL2ENABLE_METHOD_ERR);

        hRc = HRESULT_FROM_WIN32(ec);
            
        goto Exit;
        
    }
    ATLASSERT(ERROR_SUCCESS == ec);
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
	
    NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    //
    // Close Fax Port handle
    // 
    if (NULL != hFaxPortHandle)
    {
        if (!FaxClose( hFaxPortHandle ))
		{
			DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxClose() on port handle failed (ec: %ld)"),
                GetLastError());
		}
    }
    
    return hRc;
}

/*
 -  CFaxInboundRoutingMethodNode::UpdateMenuState
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateMenuState
 *      which only have one line inside it "return;" 
 *      This function implements the grayed\ungrayed view for the 
 *      the Enable and the Disable menus.
 *
 *  Arguments:

 *            [in]  id    - unsigned int with the menu IDM value
 *            [out] pBuf  - string 
 *            [out] flags - pointer to flags state combination unsigned int
 *
 *  Return:
 *      no return value - void function 
 */
void CFaxInboundRoutingMethodNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodNode::UpdateMenuState"));

    UNREFERENCED_PARAMETER (pBuf);     
    
    switch (id)
    {
    case IDM_FAX_INMETHOD_ENABLE:
        *flags = (m_fEnabled ?  MF_GRAYED  : MF_ENABLED  );   
        break;
    case IDM_FAX_INMETHOD_DISABLE:
        *flags = (m_fEnabled ?  MF_ENABLED : MF_GRAYED   );
        break;
    default:
        break;
    }
    
    return;
}

/*
 +
 +
 *
 *  CFaxInboundRoutingMethodNode::FillData
 *
 *
 *   Override CSnapInItem::FillData for private cliboard formats
 *
 *
 *   Parameters
 *
 *   Return Values
 *
 -
 -
 */

HRESULT  CFaxInboundRoutingMethodNode::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodNode::FillData"));
	
    HRESULT hr = DV_E_CLIPFORMAT;
	ULONG uWritten;


    if (cf == m_CFExtensionName)
	{
		hr = pStream->Write((VOID *)(LPWSTR)m_bstrExtensionImageName, 
                            sizeof(WCHAR)*(m_bstrExtensionImageName.Length()+1), 
                            &uWritten);
		return hr;
	}
	if (cf == m_CFMethodGuid)
	{
		hr = pStream->Write((VOID *)(LPWSTR)m_bstrMethodGUID, 
                            sizeof(WCHAR)*(m_bstrMethodGUID.Length()+1), 
                            &uWritten);
		return hr;
	}

	if (cf == m_CFServerName)
	{
		CComBSTR bstrServerName = ((CFaxServerNode *)GetRootNode())->GetServerName();
		hr = pStream->Write((VOID *)(LPWSTR)bstrServerName, 
                            sizeof(WCHAR)*(bstrServerName.Length()+1), 
                            &uWritten);
		return hr;
	}

    if (cf == m_CFDeviceId)
	{
		hr = pStream->Write((VOID *)&m_dwDeviceID, sizeof(DWORD), &uWritten);
		return hr;
	}
    return CSnapInItemImpl<CFaxInboundRoutingMethodNode>::FillData(cf, pStream);
}   // CFaxInboundRoutingMethodNode::FillData

/*
 +
 +  CFaxInboundRoutingMethodNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxInboundRoutingMethodNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    _TCHAR topicName[MAX_PATH];
    
    _tcscpy(topicName, helpFile);
    
    _tcscat(topicName, _T("::/FaxS_C_RcvdFaxRout.htm"));
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(topicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, topicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\inboundroutingmethod.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : InboundRoutingMethod.h                                 //
//                                                                         //
//  DESCRIPTION   : Header file for the InboundRoutingMethod node class.   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 01 1999 yossg  Create                                          //
//      Dec 14 1999 yossg  add basic functionality, menu, changable icon   //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXINBOUNDROUTINGMETHOD_H
#define H_FAXINBOUNDROUTINGMETHOD_H

#include "snapin.h"
#include "snpnode.h"

#include "Icons.h"

#include "ppFaxInboundRoutingMethodGeneral.h"

class CppFaxInboundRoutingMethod;
class CFaxInboundRoutingMethodsNode;

class CFaxInboundRoutingMethodNode : public CSnapinNode <CFaxInboundRoutingMethodNode, FALSE>
{

public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxInboundRoutingMethodNode, FALSE)
        SNAPINCOMMAND_ENTRY(IDM_FAX_INMETHOD_ENABLE,   OnMethodEnabled)
        SNAPINCOMMAND_ENTRY(IDM_FAX_INMETHOD_DISABLE,  OnMethodEnabled)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxInboundRoutingMethodNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_INMETHOD_MENU)

    //
    // Constructor
    //
    CFaxInboundRoutingMethodNode (CSnapInItem * pParentNode, CSnapin * pComponentData, PFAX_ROUTING_METHOD pMethodConfig) :
        CSnapinNode<CFaxInboundRoutingMethodNode, FALSE>(pParentNode, pComponentData )
    {
    }

    //
    // Destructor
    //
    ~CFaxInboundRoutingMethodNode()
    {
    }

    LPOLESTR GetResultPaneColInfo(int nCol);

    void InitParentNode(CFaxInboundRoutingMethodsNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        IUnknown* pUnk,
        DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }
    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    CComBSTR   GetName()           { return m_bstrFriendlyName; }
    BOOL       GetStatus()         { return m_fEnabled; }
    CComBSTR   GetExtensionName()  { return m_bstrExtensionFriendlyName; }

    HRESULT    Init(PFAX_ROUTING_METHOD pMethodConfig);
    void       UpdateMenuState (UINT id, LPTSTR pBuf, UINT *flags);

    //
    // FillData
    //
    STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream);

    //
    // Clipboard Formats
    //
    static CLIPFORMAT m_CFExtensionName;
    static CLIPFORMAT m_CFMethodGuid;
    static CLIPFORMAT m_CFServerName;
    static CLIPFORMAT m_CFDeviceId;


    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:
    //
    // Parent Node
    //
    CFaxInboundRoutingMethodsNode * m_pParentNode;

    //
    // Property Pages
    //
    CppFaxInboundRoutingMethod *    m_pInboundRoutingMethodGeneral;

    //
    // members
    //
    CComBSTR  m_bstrFriendlyName;       //pointer to method's user-friendly name
    CComBSTR  m_bstrExtensionFriendlyName; //pointer to DLL's user-friendly name
    DWORD     m_dwDeviceID;             //line identifier of the device
    BOOL      m_fEnabled;               //fax routing method enable/disable flag
    CComBSTR  m_bstrMethodGUID;         //GUID that uniquely identifies 
    CComBSTR  m_bstrExtensionImageName; //pointer to DLL that implements method
    // currently not in use

    //CComBSTR  m_bstrDeviceName;         //pointer to device name
    //CComBSTR  m_bstrFunctionName;       //pointer to method's function name
    
    //DWORD     m_dwSizeOfStruct;         //structure size, in bytes
            
    CComBSTR  m_buf; 

    //
    // Menu item handlers
    //
    HRESULT OnMethodEnabled (bool &bHandled, CSnapInObjectRootBase *pRoot);
    HRESULT ChangeEnable    (BOOL fState);

    //
    //  Init
    //
    HRESULT  InitMembers (PFAX_ROUTING_METHOD pMethodConfig);
    
};

//typedef CSnapinNode<CFaxInboundRoutingMethodNode, FALSE> CBaseFaxInboundRoutingMethodNode;

#endif  //H_FAXINBOUNDROUTINGMETHOD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\myctrls.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : MyCtrls.h                                              //
//                                                                         //
//  DESCRIPTION   : Expand the imlementation of AtlCtrls.h                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Nov 25 1999  yossg    Init.                                        //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////
#ifndef H_MYCTRLS_H
#define H_MYCTRLS_H


class CMyUpDownCtrl:public CUpDownCtrl
{
public:

    //
    //My implementation of SetPos with range verification
    //
    int SetPos(int nPos);
};


#endif // H_MYCTRLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\outbounddevice.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundDevice.h                                       //
//                                                                         //
//  DESCRIPTION   : Header file for the Outbound Routing Device node.      //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 23 1999 yossg  Create                                          //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXOUTBOUNDROUTINGDEVICE_H
#define H_FAXOUTBOUNDROUTINGDEVICE_H

#include "snapin.h"
#include "snpnode.h"

#include "Icons.h"

//#include "ppFaxInboundRoutingMethodGeneral.h"

//class CppFaxInboundRoutingMethod;
class CFaxOutboundRoutingGroupNode;

class CFaxOutboundRoutingDeviceNode : public CSnapinNode <CFaxOutboundRoutingDeviceNode, FALSE>
{

public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxOutboundRoutingDeviceNode, FALSE)
        SNAPINCOMMAND_ENTRY(IDM_MOVEUP,         OnMoveUp)
        SNAPINCOMMAND_ENTRY(IDM_MOVEDOWN,       OnMoveDown)
        SNAPINCOMMAND_ENTRY(ID_MOVEUP_BUTTON,   OnMoveUp)
        SNAPINCOMMAND_ENTRY(ID_MOVEDOWN_BUTTON, OnMoveDown)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxOutboundRoutingDeviceNode)
        SNAPINTOOLBARID_ENTRY(IDR_TOOLBAR_DEVICE_UD)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_OUTDEVICE_MENU)

    //
    // Constructor
    //
    CFaxOutboundRoutingDeviceNode (CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CSnapinNode<CFaxOutboundRoutingDeviceNode, FALSE>(pParentNode, pComponentData )
    {
        // for any case of ERROR_BAD_UNIT - device not found
        m_bstrDeviceName  = L"???";       
        m_bstrDescription = L"???";   
        m_bstrDescription = L"???";    
        
        m_fIsChildOfAllDevicesGroup = FALSE;
    }

    //
    // Destructor
    //
    ~CFaxOutboundRoutingDeviceNode()
    {
    }

    LPOLESTR GetResultPaneColInfo(int nCol);

    void InitParentNode(CFaxOutboundRoutingGroupNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }
    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    virtual HRESULT OnDelete(LPARAM arg, 
                             LPARAM param,
                             IComponentData *pComponentData,
                             IComponent *pComponent,
                             DATA_OBJECT_TYPES type,
                             BOOL fSilent = FALSE);

    VOID       SetOrder(UINT uiNewOrder)  { m_uiOrder = uiNewOrder; return; }

    VOID       SetOrder(UINT uiNewOrder, UINT uiNewMaxOrder);

    HRESULT    ReselectItemInView(IConsole *pConsole);

    HRESULT    Init(DWORD dwDeviceID, 
                    UINT  uiOrd,
                    UINT  uiMaxOrd,
                    CFaxOutboundRoutingGroupNode * pParentNode);

    VOID       MarkAsChildOfAllDevicesGroup() {m_fIsChildOfAllDevicesGroup = TRUE;}

    void       UpdateMenuState (UINT id, LPTSTR pBuf, UINT *flags);

    BOOL       UpdateToolbarButton(UINT id, BYTE fsState);

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:
    //
    // Parent Node
    //
    CFaxOutboundRoutingGroupNode * m_pParentNode;

    //
    // members
    //
    DWORD     m_dwDeviceID;             
    UINT      m_uiOrder;
    CComBSTR  m_bstrDeviceName;       
    CComBSTR  m_bstrDescription;   
    CComBSTR  m_bstrProviderName;    
    
    UINT      m_uiMaxOrder;
    BOOL      m_fIsChildOfAllDevicesGroup;            
    
    CComBSTR  m_buf; 

    //
    // Menu item handlers
    //
    HRESULT OnMoveUp  (bool &bHandled, CSnapInObjectRootBase *pRoot);
    HRESULT OnMoveDown(bool &bHandled, CSnapInObjectRootBase *pRoot);

    //
    //  Init
    //
    HRESULT  InitRPC     (PFAX_PORT_INFO_EX * pFaxDeviceConfig);

    HRESULT  InitMembers (PFAX_PORT_INFO_EX * pFaxDeviceConfig,
                            DWORD dwDeviceID, 
                            UINT  uiOrd,
                            UINT  uiMaxOrd);

    
};

//typedef CSnapinNode<CFaxOutboundRoutingDeviceNode, FALSE> CBaseFaxInboundRoutingMethodNode;

#endif  H_FAXOUTBOUNDROUTINGDEVICE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\outbounddevice.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundRoutingDevice.cpp                              //
//                                                                         //
//  DESCRIPTION   : Implementation of the Outbound Routing Device node.    //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 23 1999 yossg  Create                                          //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "snapin.h"

#include "OutboundDevice.h"
#include "OutboundGroup.h" //parent

#include "FaxServer.h"
#include "FaxServerNode.h"


#include "oaidl.h"
#include "urlmon.h"
#include "mshtmhst.h"
#include "exdisp.h"

/////////////////////////////////////////////////////////////////////////////
// {2E8B6DD2-6E87-407e-AF70-ABC50A2671EF}
static const GUID CFaxOutboundRoutingDeviceNodeGUID_NODETYPE = 
{ 0x2e8b6dd2, 0x6e87, 0x407e, { 0xaf, 0x70, 0xab, 0xc5, 0xa, 0x26, 0x71, 0xef } };

const GUID*     CFaxOutboundRoutingDeviceNode::m_NODETYPE        = &CFaxOutboundRoutingDeviceNodeGUID_NODETYPE;
const OLECHAR*  CFaxOutboundRoutingDeviceNode::m_SZNODETYPE      = OLESTR("2E8B6DD2-6E87-407e-AF70-ABC50A2671EF");
//const OLECHAR* CFaxOutboundRoutingDeviceNode::m_SZDISPLAY_NAME = OLESTR("Device of Outbound Routing Group");
const CLSID*    CFaxOutboundRoutingDeviceNode::m_SNAPIN_CLASSID  = &CLSID_Snapin;


/*
 -  CFaxOutboundRoutingDeviceNode::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingDeviceNode::InitRPC( PFAX_PORT_INFO_EX * pFaxDeviceConfig )
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::InitRPC"));
    
    ATLASSERT(NULL == (*pFaxDeviceConfig) );
    
    HRESULT        hRc        = S_OK;
    DWORD          ec         = ERROR_SUCCESS;

    CFaxServer *   pFaxServer = NULL;
    
    //
    // get RPC Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Retrieve the Device configuration
    //
    if (!FaxGetPortEx(pFaxServer->GetFaxServerHandle(), 
                      m_dwDeviceID, 
                      &( *pFaxDeviceConfig))) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get device configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(*pFaxDeviceConfig);
    
	
    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get device configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
    //Important!!!
    *pFaxDeviceConfig = NULL;

    if (ERROR_BAD_UNIT != ec)
	{
	    NodeMsgBox(GetFaxServerErrorMsg(ec));
	}
	else
	{
            NodeMsgBox(IDS_FAIL_TO_DISCOVERDEVICEFORGROUP);
	}
    
Exit:
    return (hRc);
}

/*
 -  CFaxOutboundRoutingDeviceNode::InitMembers
 -
 *  Purpose:
 *      Private method to initiate members
 *      Must be called after init of m_pParentNode
 *
 *  Arguments:
 *      [in]    dwDeviceID - unique device ID
 *      [in]    uiOrd      - the device usage order
 *
 *  Return:
 *      OLE error code
 */
HRESULT 
CFaxOutboundRoutingDeviceNode::InitMembers(
                            PFAX_PORT_INFO_EX * pDeviceConfig,
                            DWORD dwDeviceID, 
                            UINT  uiOrd,
                            UINT  uiMaxOrd)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::InitMembers"));
    HRESULT hRc = S_OK;

    ATLASSERT(pDeviceConfig);
    ATLASSERT(uiMaxOrd >= uiOrd);
    
    // done in calling function - to be safe (avoid later bug creation)
    m_dwDeviceID         = dwDeviceID;
    m_uiMaxOrder         = uiMaxOrd;
    m_uiOrder            = uiOrd;
    
    m_bstrDisplayName    = (*pDeviceConfig)->lpctstrDeviceName;
    if (!m_bstrDisplayName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    m_bstrDeviceName = (*pDeviceConfig)->lpctstrDeviceName;
    if (!m_bstrDeviceName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    m_bstrProviderName = (*pDeviceConfig)->lpctstrProviderName;
    if (!m_bstrProviderName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

	if (NULL != (*pDeviceConfig)->lptstrDescription )
	{
		m_bstrDescription = (*pDeviceConfig)->lptstrDescription;
		if (!m_bstrDescription)
		{
			hRc = E_OUTOFMEMORY;
			goto Error;
		}
	}
	else
	{
		m_bstrDescription = L"";
		DebugPrintEx(
			DEBUG_ERR,
			_T("Description value supplied by service is NULL"));
	}

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    ATLASSERT(NULL != m_pParentNode);
    if (NULL != m_pParentNode)
    {
        m_pParentNode->NodeMsgBox(IDS_MEMORY);
    }
    
Exit:
    return (hRc);
}


/*
 -  CFaxOutboundRoutingDeviceNode::Init
 -
 *  Purpose:
 *       This method reterives the from RPC device's data 
 *       and inits the private members with it.
 *
 *  Arguments:
 *      [in]    dwDeviceID - the unique device ID 
 *      [in]    uiOrd - order index
 *      [in]    uiMaxOrd - the maximal order in the group
 *      [in]    pParentNode - pointer to parent node
 *
 *  Return:
 *      OLE error code
 */
HRESULT 
CFaxOutboundRoutingDeviceNode::Init(
                            DWORD dwDeviceID, 
                            UINT  uiOrd,
                            UINT  uiMaxOrd,
                            CFaxOutboundRoutingGroupNode * pParentNode)
{

    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::Init"));
    HRESULT hRc = S_OK;

    FAX_SERVER_ICONS     enumIcon;

    ATLASSERT(pParentNode);
    ATLASSERT(uiMaxOrd >= uiOrd);

    PFAX_PORT_INFO_EX    pFaxDeviceConfig = NULL ;
    
    //
    // init from function parametrs
    //
    m_dwDeviceID = dwDeviceID;
    m_uiOrder    = uiOrd;
    m_uiMaxOrder = uiMaxOrd;

    InitParentNode(pParentNode);

    //
    // Icon - optimistic start point
    //
    enumIcon = IMAGE_DEVICE;

    //
    // Get the Config. structure with FaxGetPortEx
    //
    hRc = InitRPC(&pFaxDeviceConfig);
    if (FAILED(hRc))
    {
        if( ERROR_BAD_UNIT != HRESULT_CODE(hRc) )
        {
            //DebugPrint and MsgBox by called func.
    
            //to be safe actually done by InitRPC on error.
            pFaxDeviceConfig = NULL;
    
            goto Error;
        }
        else
        {
            DebugPrintEx(
			    DEBUG_MSG,
			    TEXT("+++ +++ System can not find one device from the group. (hRc: %08X) +++ +++"),
			    hRc);
            
            // Continue !!! 
            // we will show the bad device
            // but skip it's init-members function
            // the strings to show on error were configured in the constractor

            enumIcon = IMAGE_DEVICE_ERROR;

            goto Error;
        }
    }
    ATLASSERT(NULL != pFaxDeviceConfig);
    
    
    hRc = InitMembers(&pFaxDeviceConfig, dwDeviceID, uiOrd, uiMaxOrd );
    if (FAILED(hRc))
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Failed to InitMembers"));
        
        //NodeMsgBox done by called func.
        
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( FAILED(hRc) )
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Failed to init (hRc : %08X)"),
            hRc);
    }

Exit:
    //
    // Icon
    //
    m_resultDataItem.nImage = enumIcon;

    if (NULL != pFaxDeviceConfig)
    {
        FaxFreeBuffer(pFaxDeviceConfig);
        pFaxDeviceConfig = NULL;
    }//any way function quits with memory allocation freed       

    return hRc;
}

/*
 -  CFaxOutboundRoutingDeviceNode::GetResultPaneColInfo
 -
 *  Purpose:
 *      Return the text for specific column
 *      Called for each column in the result pane
 *
 *  Arguments:
 *      [in]    nCol - column number
 *
 *  Return:
 *      String to be displayed in the specific column
 */
LPOLESTR CFaxOutboundRoutingDeviceNode::GetResultPaneColInfo(int nCol)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::GetResultPaneColInfo"));
    HRESULT hRc = S_OK;

    int   iCount;
    WCHAR buff[FXS_MAX_NUM_OF_DEVICES_LEN+1];

    m_buf.Empty();

    switch (nCol)
    {
    case 0:
            //
            // Name
            //
            if (!m_bstrDeviceName)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrDeviceName."));
                goto Error;
            }
            else
            {
                return (m_bstrDeviceName);
            }
    case 1:
            //
            // Order
            //
            iCount = swprintf(buff, L"%ld", m_uiOrder);
    
            if( iCount <= 0 )
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to read member - m_uiOrder."));
                goto Error;
            }
            else
            {
                m_buf = buff;
                return (m_buf);
            }

    case 2:
            //
            // Description
            //
            if (!m_bstrDescription)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrDescription."));
                goto Error;
            }
            else
            {
                return (m_bstrDescription);
            }
    case 3:
            //
            // Provider
            //
            if (!m_bstrProviderName)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrProviderName."));
                goto Error;
            }
            else
            {
                return (m_bstrProviderName);
            }

    default:
            ATLASSERT(0); // "this number of column is not supported "
            return(L"");

    } // endswitch (nCol)

Error:
    return(L"???");

}


/*
 -  CFaxOutboundRoutingDeviceNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxOutboundRoutingDeviceNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // Display verbs that we support:
    // 1. Delete
    // 2. Refresh
    //
    if (m_fIsChildOfAllDevicesGroup)
    {
        hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN,        FALSE);
        hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, INDETERMINATE, TRUE);
    }
    else
    {
        hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED,       TRUE);
    }

    //
    // leaf node
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_NONE); 
    return hRc;
}


/*
-  CFaxOutboundRoutingDeviceNode::OnMoveDown
-
*  Purpose:
*      Call to move down device
*
*  Arguments:
*
*  Return:
*      OLE error code
*/
HRESULT  CFaxOutboundRoutingDeviceNode::OnMoveDown(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::OnMoveDown"));
    DWORD dwMaxOrder;

    ATLASSERT(m_pParentNode);

    //
    // Validity Check
    //
    dwMaxOrder = m_pParentNode->GetMaxOrder();
    if (
         ( 0 == dwMaxOrder ) // list was not populated successfully
        ||
         ( 1 > (DWORD)m_uiOrder ) 
        ||
         ( dwMaxOrder < (DWORD)(m_uiOrder+1) )
       )
    {
		DebugPrintEx(
			DEBUG_ERR,
			_T("Invalid operation. Can not move device order down."));
        
        return (S_FALSE);
    }
    else
    {
        return(m_pParentNode->ChangeDeviceOrder( 
                                    (DWORD)m_uiOrder, 
                                    (DWORD)(m_uiOrder+1), 
                                    m_dwDeviceID,
                                    pRoot) );
    }
}

/*
-  CFaxOutboundRoutingDeviceNode::OnMoveUp
-
*  Purpose:
*      To move up in the view the device
*
*  Arguments:
*
*  Return:
*      OLE error code
*/
HRESULT  CFaxOutboundRoutingDeviceNode::OnMoveUp(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::OnMoveUp"));
    DWORD dwMaxOrder;

    ATLASSERT(m_pParentNode);

    //
    // Validity Check
    //
    dwMaxOrder = m_pParentNode->GetMaxOrder();
    if (
         ( 0 == dwMaxOrder ) // list was not populated successfully
        ||
         ( dwMaxOrder < (DWORD)m_uiOrder )
        ||
         ( 1 > (DWORD)(m_uiOrder-1) )
       )
    {
		DebugPrintEx(
			DEBUG_ERR,
			_T("Invalid operation. Can not move device order up."));
        
        return (S_FALSE);
    }
    else
    {
        return (m_pParentNode->ChangeDeviceOrder( (DWORD)m_uiOrder, 
                                                  (DWORD)(m_uiOrder-1), 
                                                  m_dwDeviceID,
                                                  pRoot) );
    }
}


/*
 -  CFaxOutboundRoutingDeviceNode::ReselectItemInView
 -
 *  Purpose:
 *      Reselect the node to redraw toolbar buttons
 *
 *  Arguments:
 *      [in]    pConsole - the console interface
 *
 *  Return: OLE error code
 */
HRESULT CFaxOutboundRoutingDeviceNode::ReselectItemInView(IConsole *pConsole)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::ReselectItemInView"));
    HRESULT     hRc = S_OK;

    //
    // Need IResultData
    //
    CComQIPtr<IResultData, &IID_IResultData> pResultData(pConsole);
    ATLASSERT(pResultData != NULL);

    //
    // Reselect the node to redraw toolbar buttons.
    //
    hRc = pResultData->ModifyItemState( 0, m_resultDataItem.itemID, LVIS_SELECTED | LVIS_FOCUSED, 0 );
    if ( S_OK != hRc )
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Failure on pResultData->UpdateItem, (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL2REFRESH_THEVIEW);
        goto Exit;
    }

Exit:
    return hRc;
}


/*
 -  CFaxOutboundRoutingDeviceNode::OnDelete
 -
 *  Purpose:
 *      Called when deleting this node
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */

HRESULT CFaxOutboundRoutingDeviceNode::OnDelete(
                 LPARAM arg,
                 LPARAM param,
                 IComponentData *pComponentData,
                 IComponent *pComponent,
                 DATA_OBJECT_TYPES type,
                 BOOL fSilent/* = FALSE*/

)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::OnDelete"));

    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (type);

    HRESULT           hRc       = S_OK;
    CComPtr<IConsole> spConsole;

    //
    // Are you sure?
    //
    if (! fSilent)
    {
        //
        //  Use pConsole as owner of the message box
        //
        int res;
        NodeMsgBox(IDS_CONFIRM, MB_YESNO | MB_ICONWARNING, &res);

        if (IDNO == res)
        {
            goto Cleanup;
        }
    }
    
    //
    // Delete it
    //
    ATLASSERT(m_pParentNode);
    hRc = m_pParentNode->DeleteDevice(m_dwDeviceID,
                                    this);
    if ( FAILED(hRc) )
    {
        goto Cleanup;
    }

Cleanup:
    return hRc;
}

/*
 -  CFaxOutboundRoutingDeviceNode::UpdateToolbarButton
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateToolbarButton
 *      This function aloow us to decide if to the activate\grayed a toolbar button  
 *      It treating only the Enable state.
 *
 *  Arguments:
 *
 *            [in]  id    - unsigned int for the toolbar button ID
 *            [in]  fsState  - state to be cosidered ENABLE ?HIDDEN etc. 
 *
 *  Return:
 *     BOOL TRUE to activate state FALSE to disabled the state for this button 
 */
BOOL CFaxOutboundRoutingDeviceNode::UpdateToolbarButton(UINT id, BYTE fsState)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::UpdateToolbarButton"));
    BOOL bRet = FALSE;	
	    
    // Set whether the buttons should be enabled.
    if (fsState == ENABLED)
    {

        switch ( id )
        {
            case ID_MOVEUP_BUTTON:

                bRet = ( (FXS_FIRST_DEVICE_ORDER == m_uiOrder) ?  FALSE : TRUE );           

                break;

            case ID_MOVEDOWN_BUTTON:

                bRet = ( (m_uiMaxOrder == m_uiOrder)  ?  FALSE : TRUE);
                
                break;
        
            default:
                break;

        }

    }

    // For all other possible button ID's and states, 
    // the correct answer here is FALSE.
    return bRet;

}



/*
 -  CFaxOutboundRoutingDeviceNode::UpdateMenuState
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateMenuState
 *      which only have one line inside it "return;" 
 *      This function implements the grayed\ungrayed view for the 
 *      the Enable and the Disable menus.
 *
 *  Arguments:

 *            [in]  id    - unsigned int with the menu IDM value
 *            [out] pBuf  - string 
 *            [out] flags - pointer to flags state combination unsigned int
 *
 *  Return:
 *      no return value - void function 
 */
void CFaxOutboundRoutingDeviceNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::UpdateMenuState"));

    UNREFERENCED_PARAMETER (pBuf);
    
    switch (id)
    {
        case IDM_MOVEUP:

            *flags = ((FXS_FIRST_DEVICE_ORDER == m_uiOrder) ?  MF_GRAYED : MF_ENABLED );           
            break;

        case IDM_MOVEDOWN:

            *flags = ((m_uiMaxOrder == m_uiOrder)  ?  MF_GRAYED : MF_ENABLED );
            break;

        default:
            break;
    }
    
    return;
}

/*
 -  CFaxOutboundRoutingDeviceNode::SetOrder
 -
 *  Purpose:
 *      Overload function which allow 
 *      re-setting the order and the MaxOrder 
 *
 *  Arguments:
 *            
 *            [in] uiNewOrder - Device's order.
 *            [in] uiNewMaxOrder - Maximal order in the current list
 *
 *  Return:
 *      no return value - void function 
 */
VOID CFaxOutboundRoutingDeviceNode::SetOrder(UINT uiNewOrder, UINT uiNewMaxOrder)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::UpdateMenuState"));

    m_uiOrder    = uiNewOrder;
    m_uiMaxOrder = uiNewMaxOrder;

    return;
}

/*
 +
 +  CFaxOutboundRoutingDeviceNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxOutboundRoutingDeviceNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    _TCHAR topicName[MAX_PATH];
    
    _tcscpy(topicName, helpFile);
    
    _tcscat(topicName, _T("::/FaxS_C_Groups.htm"));
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(topicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, topicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\outboundgroup.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundGroup.cpp                                      //
//                                                                         //
//  DESCRIPTION   : Fax Outbound Routing Group MMC node.                   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 23 1999 yossg  Create                                          //
//      Jan  3 2000 yossg   add new device(s)                              //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "snapin.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "OutboundGroup.h"

#include "OutboundGroups.h"

#include "dlgNewDevice.h"

//#include "oaidl.h"
#include "Icons.h"

//////////////////////////////////////////////////////////////
// {3E470227-76C1-4b66-9C63-B77DF81C145D}
static const GUID CFaxOutboundRoutingGroupNodeGUID_NODETYPE = 
{ 0x3e470227, 0x76c1, 0x4b66, { 0x9c, 0x63, 0xb7, 0x7d, 0xf8, 0x1c, 0x14, 0x5d } };

const GUID*    CFaxOutboundRoutingGroupNode::m_NODETYPE = &CFaxOutboundRoutingGroupNodeGUID_NODETYPE;
const OLECHAR* CFaxOutboundRoutingGroupNode::m_SZNODETYPE = OLESTR("3E470227-76C1-4b66-9C63-B77DF81C145D");
const CLSID*   CFaxOutboundRoutingGroupNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxOutboundRoutingGroupNode::m_ColsInfo;


/*
 -  CFaxOutboundRoutingGroupNode::RefreshFromRPC
 -
 *  Purpose:
 *      Init all members icon etc. 
 *       - with creation of structure configuration
 *       - Call InitRpc to fill it
 *       - Call InitMembers to init members and icon
 *       - Free structure
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingGroupNode::RefreshFromRPC()
{

    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::RefreshFromRPC()"));

    PFAX_OUTBOUND_ROUTING_GROUP pFaxGroupsConfig = NULL;

    HRESULT      hRc              = S_OK;
    DWORD        ec               = ERROR_SUCCESS;

    CFaxServer * pFaxServer       = NULL;

    DWORD        dwNumOfGroups    = 0; 
    
    BOOL         fFound;
    DWORD        i; //index

    PFAX_OUTBOUND_ROUTING_GROUP   pFaxTmp;
    //
    // get Fax Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
	// Retrieve the Outbound Groups configuration
	//
    if (!FaxEnumOutboundGroups(pFaxServer->GetFaxServerHandle(), 
                        &pFaxGroupsConfig,
                        &dwNumOfGroups)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get groups configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(pFaxGroupsConfig);

    pFaxTmp = pFaxGroupsConfig;
    fFound = FALSE;
    for ( i =0; i < dwNumOfGroups; i++  )
    {
        ATLASSERT(NULL != pFaxTmp);

        if(0 == wcscmp(m_bstrGroupName, pFaxTmp->lpctstrGroupName) )
        {
            fFound = TRUE; 
        }
        else
        {
            pFaxTmp++;
        }
    }
    
    if(fFound)
    {
        //
        // init members
        //
        m_dwNumOfDevices = pFaxTmp->dwNumDevices;

        if (0 < m_dwNumOfDevices)
        {
            if (NULL != m_dwNumOfDevices)
            {
                delete[] m_lpdwDeviceID;
            }
            m_lpdwDeviceID = new DWORD[m_dwNumOfDevices];    
            memcpy(m_lpdwDeviceID, pFaxTmp->lpdwDevices, sizeof(DWORD)*m_dwNumOfDevices) ;
        }
        else
        {
            DebugPrintEx( DEBUG_MSG, _T("Device list found to be currrently empty."));
            if (NULL != m_dwNumOfDevices)
            {
                delete[] m_lpdwDeviceID;
            }
            m_lpdwDeviceID = NULL;
        }
        
        m_enumStatus = pFaxTmp->Status;
        
        InitIcons ();
    }
    else
    {
        ec = FAX_ERR_GROUP_NOT_FOUND;
        DebugPrintEx(
            DEBUG_ERR,
            _T("UEXPECTED ERROR - Group not found."));
        goto Error;
    }


    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to re init group configuration and ."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);

    hRc = HRESULT_FROM_WIN32(ec);
	
    NodeMsgBox(GetFaxServerErrorMsg(ec));
    

Exit:
    if (NULL != pFaxGroupsConfig)
    {
        FaxFreeBuffer(pFaxGroupsConfig);
    }//any way function ends with memory allocation freed       

    return hRc;
}


/*
 -  CFaxOutboundRoutingGroupNode::Init
 -
 *  Purpose:
 *      Init all members icon etc.
 *
 *  Arguments:
 *      [in]    pGroupConfig - FAX_OUTBOUND_ROUTING_GROUP  
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingGroupNode::Init(PFAX_OUTBOUND_ROUTING_GROUP pGroupConfig)
{

    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::Init"));
    HRESULT hRc = S_OK;

    ATLASSERT(pGroupConfig);

    hRc = InitMembers( pGroupConfig );
    if (FAILED(hRc))
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to InitMembers"));
        
        //NodeMsgBox done by called func.
        
        goto Exit;
    }
    

Exit:
    return hRc;
}

/*
 -  CFaxOutboundRoutingGroupNode::InitMembers
 -
 *  Purpose:
 *      Private method to initiate members
 *      Must be called after init of m_pParentNode
 *
 *  Arguments:
 *      [in]    pGroupConfig - FAX_OUTBOUND_ROUTING_GROUP  structure
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingGroupNode::InitMembers(PFAX_OUTBOUND_ROUTING_GROUP pGroupConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::InitMembers"));
    HRESULT hRc = S_OK;

    ATLASSERT(pGroupConfig);

    //    
    // status and Icon   
    //    
    m_enumStatus      = pGroupConfig->Status;

    InitIcons ();

    //
    // Device List
    // 
    m_dwNumOfDevices  = pGroupConfig->dwNumDevices;

    ATLASSERT(0 <= m_dwNumOfDevices);

    

    if (0 < m_dwNumOfDevices)
    {
        //if (NULL != m_dwNumOfDevices)
        //{
        //    delete[] m_lpdwDeviceID;
        //}
        m_lpdwDeviceID  = new DWORD[m_dwNumOfDevices];
        if (NULL == m_lpdwDeviceID)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Error allocating %ld device ids"),
                m_dwNumOfDevices);
            hRc = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto Error;
        }

        memcpy(m_lpdwDeviceID, pGroupConfig->lpdwDevices, sizeof(DWORD)*m_dwNumOfDevices) ;
    }
    else
    {
        DebugPrintEx( DEBUG_MSG, _T("Device list found to be currrently empty."));
        //if (NULL != m_dwNumOfDevices)
        //{
        //    delete[] m_lpdwDeviceID;
        //}
        m_lpdwDeviceID = NULL;
    }

    hRc = InitGroupName(pGroupConfig->lpctstrGroupName);
    if (FAILED(hRc))
    {
        goto Error; 
    }    
   
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    ATLASSERT(NULL != m_pParentNode);
    if (NULL != m_pParentNode)
    {
        m_pParentNode->NodeMsgBox(IDS_MEMORY);
    }
    
Exit:
    return (hRc);
}

/*
 -  CFaxOutboundRoutingGroupNode::InitGroupName
 -
 *  Purpose:
 *      Init the display name and group name from given group name. 
 *      Displayed name may be changed to localized version if it is
 *      the All Devices Group.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingGroupNode::InitGroupName(LPCTSTR lpctstrGroupName)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::InitGroupName"));
    HRESULT hRc = S_OK;

    if ( 0 == wcscmp(ROUTING_GROUP_ALL_DEVICES, lpctstrGroupName))
    {
        //
        // Replace <all Devices> string with the localized string 
        //       
        if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                                    IDS_ALL_DEVICES) )
        {
            hRc = E_OUTOFMEMORY;
            goto Error;
        }
	}
    else
    {
        m_bstrDisplayName = lpctstrGroupName;
        if (!m_bstrDisplayName)
        {
            hRc = E_OUTOFMEMORY;
            goto Error;
        }    
    }
    
    m_bstrGroupName = lpctstrGroupName;
    if (!m_bstrGroupName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }    
   
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    //NodeMsgBox done by Caller func.
    
Exit:
    return (hRc);
}


/*
 -  CFaxOutboundRoutingGroupNode::GetResultPaneColInfo
 -
 *  Purpose:
 *      Return the text for specific column
 *      Called for each column in the result pane
 *
 *  Arguments:
 *      [in]    nCol - column number
 *
 *  Return:
 *      String to be displayed in the specific column
 */
LPOLESTR CFaxOutboundRoutingGroupNode::GetResultPaneColInfo(int nCol)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::GetResultPaneColInfo"));
    HRESULT hRc = S_OK;

    UINT  idsStatus;
    int   iCount;
    WCHAR buff[FXS_MAX_NUM_OF_DEVICES_LEN+1];

    m_buf.Empty();

    switch (nCol)
    {
    case 0:
        //
        // Name
        //
        if (!m_bstrDisplayName)
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Null memeber BSTR - m_bstrGroupName."));
            goto Error;
        }
        else
        {
            return (m_bstrDisplayName);
        }

    case 1:
        //
        // Number of Devices
        //
        iCount = swprintf(buff, L"%ld", m_dwNumOfDevices);

        if( iCount <= 0 )
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to read member - m_dwNumOfDevices."));
            goto Error;
        }
        else
        {
            m_buf = buff;
            return (m_buf);
        }
    
    case 2:
        //
        // Status
        //
        idsStatus = GetStatusIDS(m_enumStatus);
        if ( FXS_IDS_STATUS_ERROR == idsStatus)
        {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Invalid Status value or not supported status value."));
                goto Error;
        }
        else
        {
            if (!m_buf.LoadString(idsStatus))
            {
                hRc = E_OUTOFMEMORY;
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. Failed to load status string."));
                goto Error;
            }
            return m_buf;
        }

    default:
            ATLASSERT(0); // "this number of column is not supported "
            return(L"");

    } // endswitch (nCol)

Error:
    return(L"???");

}

/*
 -  CFaxOutboundRoutingGroupNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxOutboundRoutingGroupNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::InsertColumns"));
    HRESULT  hRc = S_OK;

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_OUTBOUND_DEVICES_COL1, FXS_WIDE_COLUMN_WIDTH},
        {IDS_OUTBOUND_DEVICES_COL2, AUTO_WIDTH},
        {IDS_OUTBOUND_DEVICES_COL3, AUTO_WIDTH},
        {IDS_OUTBOUND_DEVICES_COL4, AUTO_WIDTH},
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    CHECK_RETURN_VALUE_AND_PRINT_DEBUG (_T("m_ColsInfo.InsertColumnsIntoMMC"))

Cleanup:
    return(hRc);
}



/*
 -  CFaxOutboundRoutingGroupNode::PopulateResultChildrenList
 -
 *  Purpose:
 *      Create the FaxOutboundRoutingGroup device nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingGroupNode::PopulateResultChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::PopulateResultChildrenList"));
    HRESULT hRc = S_OK;
    BOOL fIsAllDevicesGroup = FALSE;

    CFaxOutboundRoutingDeviceNode *   pDevice;
                       
    if( 0 == wcscmp(ROUTING_GROUP_ALL_DEVICES, m_bstrGroupName) )
    {
         fIsAllDevicesGroup = TRUE; 
    }


    for ( DWORD i=0; i< m_dwNumOfDevices; i++ )
    {
            pDevice = NULL;

            pDevice = new CFaxOutboundRoutingDeviceNode(this, 
                                            m_pComponentData);
            if (!pDevice)
            {
                hRc = E_OUTOFMEMORY;
                NodeMsgBox(IDS_MEMORY);
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. (hRc: %08X)"),
			        hRc);
                goto Error;
            }
            else
            {                
                //
                // Init parent node ptr, RPC structure, 
                // members displayed name and icon
                //
                hRc = pDevice->Init( m_lpdwDeviceID[i],
                                     i+1,  
                                     (UINT)m_dwNumOfDevices, 
                                     this);
	            if (FAILED(hRc))
	            {
		            if( ERROR_BAD_UNIT != HRESULT_CODE(hRc) )
	                {
                        DebugPrintEx(
			                DEBUG_ERR,
			                TEXT("Fail to add Device Node below Outbound Routing Group. (hRc: %08X)"),
			                hRc);
		                //NodeMsgBox done by called functions
                        goto Error;
	                }
	                else
	                {
                        DebugPrintEx(
			                DEBUG_MSG,
			                TEXT("+++ +++ system can not find one device from the group. (hRc: %08X) +++ +++"),
			                hRc);
                        //Continue - user informed data reay
                        //we will show the bad device
                        hRc = S_OK;
                    }
	            }
                
                if( fIsAllDevicesGroup )
                {
                     pDevice->MarkAsChildOfAllDevicesGroup(); 
                }
            
                hRc = this->AddChildToList(pDevice);
	            if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to add Device Node below Outbound Routing Group. (hRc: %08X)"),
			            hRc);
		            NodeMsgBox(IDS_FAIL_ADD_DEVICE);
                    goto Error;
	            }
                else
                {
                    pDevice = NULL;
                }
            }
    }
    ATLASSERT(S_OK == hRc);
    
    //
    // Success ToPopulateAllDevices to allow 
    // giving total number of devices to each device
    // when asked for reordering purposes
    //
    m_fSuccess = TRUE;

    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pDevice ) 
    {
        delete  pDevice;    
        pDevice = NULL;    
    }
    
    //
    // Get rid of what we had.
    //
    {
        // Delete each node in the list of children
        int iSize = m_ResultChildrenList.GetSize();
        for (int j = 0; j < iSize; j++)
        {
            pDevice = (CFaxOutboundRoutingDeviceNode *)
                                    m_ResultChildrenList[j];
            delete pDevice;
        }

        // Empty the list
        m_ResultChildrenList.RemoveAll();

        // We no longer have a populated list.
        m_bResultChildrenListPopulated = FALSE;
    }
    
Exit:
    return hRc;
}



/*
 -  CFaxOutboundRoutingGroupNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxOutboundRoutingGroupNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // Display verbs that we support:
    // 1. Delete
    // 2. Refresh
    //
    
    if(0 == wcscmp(ROUTING_GROUP_ALL_DEVICES, m_bstrGroupName) )
    {
        hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN,        FALSE);
        hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, INDETERMINATE, TRUE);
    }
    else
    {
        hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED,       TRUE);
    }

    hRc = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 

    return hRc;
}



/*
 -  CFaxOutboundRoutingGroupNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
/* virtual */HRESULT
CFaxOutboundRoutingGroupNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::OnRefresh"));
    HRESULT hRc = S_OK;


    //
    // Refresh from server
    //
    hRc = RefreshFromRPC();
    if (FAILED(hRc))
    {
        //msg by called func.
        {
            hRc = m_pParentNode->DoRefresh();
            if ( FAILED(hRc) )
            {
                DebugPrintEx(
			        DEBUG_ERR,
			        _T("Fail to call parent node - Groups DoRefresh. (hRc: %08X)"),
			        hRc);        
            }
            return hRc;
        }
    }
    else
    {
        //
        // Update Group's icon by reselecting the group node.
        //
        hRc = RefreshNameSpaceNode();
        if (FAILED(hRc))
        {
            DebugPrintEx(
		 DEBUG_ERR,
		 TEXT("Fail to refresh the group node. (hRc: %08X)"),
		 hRc);

            return hRc;
        }
    }

    //
    // Call the base class
    //
    hRc = CBaseFaxOutboundRoutingGroupNode::OnRefresh(arg,
                             param,
                             pComponentData,
                             pComponent,
                             type);
    if ( FAILED(hRc) )
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to call base class's OnRefresh. (hRc: %08X)"),
			hRc);
        
        int iRes;
        NodeMsgBox(IDS_FAIL2REFERESH_GROUP, MB_OK | MB_ICONERROR, &iRes);
        ATLASSERT(IDOK == iRes);
        ATLASSERT(m_pParentNode);
        if (IDOK == iRes)
        {
            hRc = m_pParentNode->DoRefresh();
            if ( FAILED(hRc) )
            {
                DebugPrintEx(
			        DEBUG_ERR,
			        _T("Fail to call parent node - Groups DoRefresh. (hRc: %08X)"),
			        hRc);
        
            }

        }
        
    }

    return hRc;
}


/*
 -  CFaxOutboundRoutingGroupNode::OnNewDevice
 -
 *  Purpose:
 *      
 *
 *  Arguments:
 *      [out]   bHandled - Do we handle it?
 *      [in]    pRoot    - The snapin object root base node
 *
 *  Return:
 *      OLE Error code
 */
HRESULT
CFaxOutboundRoutingGroupNode::OnNewDevice(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::OnNewGroup"));
    HRESULT     hRc         =    S_OK;
    INT_PTR     rc          =    IDOK;

    CDlgNewFaxOutboundDevice      DlgNewDevice(((CFaxServerNode *)GetRootNode())->GetFaxServer());

    //
    // Dialog to add device
    //
    hRc = DlgNewDevice.InitDevices(m_dwNumOfDevices, m_lpdwDeviceID, m_bstrGroupName);
    if (FAILED(hRc))
    {
        NodeMsgBox(IDS_FAIL2OPEN_DLG);
        return hRc;
    }
    
    rc = DlgNewDevice.DoModal();
    if (rc != IDOK)
    {
        goto Cleanup;
    }

    //
    // Refresh the data 
    //      - Get newdata from RPC 
    //      - init members and 
    //      - Set icons
    //
    hRc = RefreshFromRPC();
    if (FAILED(hRc))
    {
        //msg by called func.
        return hRc;
    }

    //
    // Refresh result pane view
    //
    DoRefresh(pRoot);

    //
    // This will force MMC to redraw the scope group node
    //
    hRc = RefreshNameSpaceNode();
    if (FAILED(hRc))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to RefreshNameSpaceNode. (hRc: %08X)"),
            hRc);
        goto Error;
    }
    ATLASSERT( S_OK == hRc);
    goto Cleanup;
    
Error:
    ATLASSERT( S_OK != hRc);
    NodeMsgBox(IDS_FAIL2UPDATEITEM_GROUP);

Cleanup:
    return hRc;
}

/*
 -  CFaxOutboundRoutingGroupNode::DoRefresh
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxOutboundRoutingGroupNode::DoRefresh(CSnapInObjectRootBase *pRoot)
{
    CComPtr<IConsole> spConsole;

    //
    // Repopulate childs
    //
    RepopulateResultChildrenList();

    if (pRoot)
    {
        //
        // Get the console pointer
        //
        ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
        if (pRoot->m_nType == 1)
        {
            //
            // m_ntype == 1 means the IComponentData implementation
            //
            CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
            spConsole = pCComponentData->m_spConsole;
        }
        else
        {
            //
            // m_ntype == 2 means the IComponent implementation
            //
            CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
            spConsole = pCComponent->m_spConsole;
        }
    }
    else
    {
        ATLASSERT(m_pComponentData);
        spConsole = m_pComponentData->m_spConsole;
    }

    ATLASSERT(spConsole);
    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return S_OK;
}


/*
 -  CFaxOutboundRoutingGroupNode::GetStatusIDS
 -
 *  Purpose:
 *      Transslate Status to IDS.
 *
 *  Arguments:
 *
 *            [in]  enumStatus    - unsigned int with the menu IDM value
 *
 *  Return:
 *            IDS of related status message 
 */
UINT CFaxOutboundRoutingGroupNode::GetStatusIDS(FAX_ENUM_GROUP_STATUS enumStatus)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::GetStatusIDS"));

    switch (enumStatus)
    {
        case FAX_GROUP_STATUS_ALL_DEV_VALID:
            return IDS_STATUS_GROUP_ALL_DEV_VALID;

        case FAX_GROUP_STATUS_EMPTY:
            return IDS_STATUS_GROUP_EMPTY;

        case FAX_GROUP_STATUS_ALL_DEV_NOT_VALID:
            return IDS_STATUS_GROUP_ALLDEVICESINVALID;

        case FAX_GROUP_STATUS_SOME_DEV_NOT_VALID:
            return IDS_STATUS_GROUP_SOMEDEVICESINVALID;

        default:
            ATLASSERT(0); // "this enumStatus is not supported "
            return(FXS_IDS_STATUS_ERROR); //currently 999

    } // endswitch (enumStatus)
}


/*
 -  CFaxOutboundRoutingGroupNode::InitIcons
 -
 *  Purpose:
 *      Private method that initiate icons
 *      due to the status member state.
 *
 *  Arguments:
 *      No.
 *
 *  Return:
 *      No.
 */
void CFaxOutboundRoutingGroupNode::InitIcons ()
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::InitIcons"));
    switch (m_enumStatus)
    {
        case FAX_GROUP_STATUS_ALL_DEV_VALID:
            SetIcons(IMAGE_FOLDER_CLOSE, IMAGE_FOLDER_OPEN);
            return;
        case FAX_GROUP_STATUS_SOME_DEV_NOT_VALID:
            SetIcons(IMAGE_GROUP_WARN_CLOSE, IMAGE_GROUP_WARN_OPEN);
            return;

        case FAX_GROUP_STATUS_EMPTY:
        case FAX_GROUP_STATUS_ALL_DEV_NOT_VALID:
            SetIcons(IMAGE_GROUP_ERROR_CLOSE, IMAGE_GROUP_ERROR_OPEN);
            return;

        default:
            ATLASSERT(FALSE); // "this enumStatus is not supported "
            SetIcons(IMAGE_GROUP_ERROR_CLOSE, IMAGE_GROUP_ERROR_OPEN);
            return; //currently 999
    } 
    
}


/*
 -  CFaxOutboundRoutingGroupNode::OnDelete
 -
 *  Purpose:
 *      Called when deleting this node
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingGroupNode::OnDelete(
                 LPARAM arg,
                 LPARAM param,
                 IComponentData *pComponentData,
                 IComponent *pComponent,
                 DATA_OBJECT_TYPES type,
                 BOOL fSilent/* = FALSE*/

)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::OnDelete"));

    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    CComBSTR    bstrName;
    HRESULT     hRc = S_OK;


    //
    // Are you sure?
    //
    if (! fSilent)
    {
        //
        // 1. Use pConsole as owner of the message box
        //
        int res;
        NodeMsgBox(IDS_CONFIRM, MB_YESNO | MB_ICONWARNING, &res);

        if (IDNO == res)
        {
            goto Cleanup;
        }
    }

    //
    // Group name
    //
    if ( !m_bstrGroupName || L"???" == m_bstrGroupName)
    {
        NodeMsgBox(IDS_INVALID_GROUP_NAME);
        goto Cleanup;
    }
    bstrName = m_bstrGroupName;

    //
    // Delete it
    //
    ATLASSERT(m_pParentNode);
    hRc = m_pParentNode->DeleteGroup(bstrName, this);
    if ( FAILED(hRc) )
    {
        goto Cleanup;
    }

Cleanup:
    return hRc;
}

/*
 -  CFaxOutboundRoutingGroupNode::ChangeDeviceOrder
 -
 *  Purpose:
 *      This func moves up or down specific device in the group order
 *
 *  Arguments:
 *      [in] dwNewOrder - specifies the new order +1 /-1 inrelative to current order.
 *      [in] dwDeviceID - Device ID
 *      [in] pChildNode - the device node object.
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingGroupNode::ChangeDeviceOrder(DWORD dwOrder, DWORD dwNewOrder, DWORD dwDeviceID, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::ChangeDeviceOrder"));

    HRESULT      hRc        = S_OK;
    DWORD        ec         = ERROR_SUCCESS;

    CFaxServer * pFaxServer = NULL;

    int iIndex, iNewIndex;

    CFaxOutboundRoutingDeviceNode* tmpChildNode;

    CComPtr<IConsole> spConsole;

    //
    // Validity asserts
    //
    ATLASSERT((dwNewOrder-1)< m_dwNumOfDevices);
    ATLASSERT((dwNewOrder-1)>= 0);
    ATLASSERT((dwOrder-1)< m_dwNumOfDevices);
    ATLASSERT((dwOrder-1)>= 0);
    
    ATLASSERT( ( (dwOrder-1)-(dwNewOrder-1) == 1) 
                    || ( (dwOrder-1)-(dwNewOrder-1) == -1) );

    //
    // init swaped indexes
    //
    iIndex    = (int)(dwOrder-1);
    iNewIndex = (int)(dwNewOrder-1);

    //
    // RPC change Order
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    if (!FaxSetDeviceOrderInGroup(
                        pFaxServer->GetFaxServerHandle(), 
                        m_bstrGroupName/*lpctstrGroupName*/,
			            dwDeviceID,
			            dwNewOrder) ) 
	{
        ec = GetLastError();

        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to Set new order. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }
        goto Error; 
    }
    else // Success of RPC -> Now to MMC
    {
        //
        // Local swap
        //
        tmpChildNode = m_ResultChildrenList[iIndex];
        m_ResultChildrenList[iIndex] = m_ResultChildrenList[iNewIndex];
        m_ResultChildrenList[iNewIndex] = tmpChildNode;

        m_ResultChildrenList[iIndex]->SetOrder((UINT)iIndex+1);
        m_ResultChildrenList[iNewIndex]->SetOrder((UINT)iNewIndex+1);
        
        
        //
        // Get console
        //
        if (pRoot)
        {
            //
            // Get the console pointer
            //
            ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
            if (pRoot->m_nType == 1)
            {
                //
                // m_ntype == 1 means the IComponentData implementation
                //
                CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
                spConsole = pCComponentData->m_spConsole;
            }
            else
            {
                //
                // m_ntype == 2 means the IComponent implementation
                //
                CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
                spConsole = pCComponent->m_spConsole;
            }
        }
        else
        {
            ATLASSERT(m_pComponentData);
            spConsole = m_pComponentData->m_spConsole;
        }
        ATLASSERT(spConsole);
        
        //
        // UpdateAllViews
        //
        spConsole->UpdateAllViews(NULL, (LPARAM)this, NULL);
        
        //
        // Reselect the moved item in his new place
        //
        m_ResultChildrenList[iNewIndex]->ReselectItemInView(spConsole);

    }
    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to set devices new order for Outbound Routing group."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return hRc;
}

/*
 -  CFaxOutboundRoutingGroupNode::SetNewDeviceList
 -
 *  Purpose:
 *      To assign new device list to group.
 *
 *  Arguments:
 *      [in] lpdwNewDeviceId - the new device ID list
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingGroupNode::SetNewDeviceList(LPDWORD lpdwNewDeviceID)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::SetNewDeviceLists"));

    HRESULT     hRc = S_OK;
    DWORD       ec  = ERROR_SUCCESS;

    CFaxServer * pFaxServer;

    FAX_OUTBOUND_ROUTING_GROUP   FaxGroupConfig;

    
    //
    // init the structure's fields and insert the new DeviceIdList  
    //
    ZeroMemory (&FaxGroupConfig, sizeof(FAX_OUTBOUND_ROUTING_GROUP));

    FaxGroupConfig.dwSizeOfStruct   = sizeof(FAX_OUTBOUND_ROUTING_GROUP);
	FaxGroupConfig.lpctstrGroupName = m_bstrGroupName;
    FaxGroupConfig.dwNumDevices     = m_dwNumOfDevices - 1;
	FaxGroupConfig.Status           = m_enumStatus;

    FaxGroupConfig.lpdwDevices      = lpdwNewDeviceID;
    
    //
    // get RPC Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        goto Error;
    }

    //
    // Set Config
    //
    if (!FaxSetOutboundGroup(
                pFaxServer->GetFaxServerHandle(),
                &FaxGroupConfig)) 
	{		
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to set the group with new device list. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }
        
        goto Error;
    }

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to set device configuration."));
    

    goto Exit;

Error:
	ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);

    ATLASSERT(NULL != m_pParentNode);
    NodeMsgBox(GetFaxServerErrorMsg(ec));

Exit:    
    return(hRc);
}

/*
 -  CFaxOutboundRoutingGroupNode::DeleteDevice
 -
 *  Purpose:
 *      Delete Device from the group
 *
 *  Arguments:
 *      [in]    dwDeviceID - The device ID
 *      [in]    pChildNode - The node to be deleted
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxOutboundRoutingGroupNode::DeleteDevice(DWORD dwDeviceIdToRemove, CFaxOutboundRoutingDeviceNode *pChildNode)
{
    DEBUG_FUNCTION_NAME(_T("CFaxOutboundRoutingDeviceNode::DeleteDevice"));
    HRESULT       hRc        = S_OK;
    DWORD         ec         = ERROR_SUCCESS;

    DWORD         dwIndex;    
    DWORD         dwNewIndex;    

    int           j;

    LPDWORD       lpdwNewDeviceID = NULL;
    LPDWORD       lpdwTmp;

    ATLASSERT( 0 < m_dwNumOfDevices);
    
    //
    // Step 1: create new DeviceID array
    //

    //
    // prepare for loop
    //

    lpdwTmp = &m_lpdwDeviceID[0];

    if ((m_dwNumOfDevices - 1) > 0 )
	{
		lpdwNewDeviceID = new DWORD[m_dwNumOfDevices - 1]; 
        if (NULL == lpdwNewDeviceID)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Error allocating %ld device ids"),
                m_dwNumOfDevices - 1);
            hRc = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto Error;
        }
	}
    
    dwNewIndex  = 0;
	for ( dwIndex = 0; dwIndex < m_dwNumOfDevices; dwIndex++, lpdwTmp++)
    {
        //
        // Safty check for last itaration
        //
        if ( dwNewIndex == (m_dwNumOfDevices-1) )
        {
            if ( dwDeviceIdToRemove != *lpdwTmp)
            {
				//unexpected error 
				DebugPrintEx( DEBUG_ERR,
					_T("Unexpected error - The device was not found."));
        
				ATLASSERT(0);

				hRc = S_FALSE;
				goto Error;
            }
            else //Device to remove found as the last one. Do nothing.
			{
				break;
			}
        }


        //
        // main operation
        //
        if ( dwDeviceIdToRemove != *lpdwTmp)
        {
            lpdwNewDeviceID[dwNewIndex] = *lpdwTmp;
			dwNewIndex++;
        }
        // else Found the device to delete. do noting.

    }



    //
    // Step 2: Insert the new device ID array to Group (via RPC)
    //
    
    //
    //          a) Call to Rpc Func.
    //
    hRc = SetNewDeviceList(lpdwNewDeviceID);
    if (FAILED(hRc))
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to set the group with new device list. (RC: %0X8)"), 
			hRc);
        goto Error;
    }

    //
    //          b) Update Group class relevant members and the icon
    //
    
    // 0) Clear old DeviceID array
    if (m_dwNumOfDevices > 0 )
	{
		delete[] m_lpdwDeviceID;
		m_lpdwDeviceID = NULL;
	}

    // 1) update m_dwNumOfDevices
    --m_dwNumOfDevices;
    
    // 2) update m_lpdwDeviceID
    if (m_dwNumOfDevices > 0 )
	{
		m_lpdwDeviceID = new DWORD[m_dwNumOfDevices];
        if (NULL == m_lpdwDeviceID)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Error allocating %ld device ids"),
                m_dwNumOfDevices);
            hRc = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto Error;
        }
	    memcpy(m_lpdwDeviceID , lpdwNewDeviceID, sizeof(DWORD)*m_dwNumOfDevices) ;    
	}
    
    // 3) update icon
    if ( 0 == m_dwNumOfDevices)
    {
        m_enumStatus = FAX_GROUP_STATUS_EMPTY;
        InitIcons();
    }

    //
    // Step 3: Update MMC views 
    //
    //
    //           a) Remove Device from MMC result pane
    //
    ATLASSERT(pChildNode);
    hRc = RemoveChild(pChildNode);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to remove Device from MMC views. (hRc: %08X)"),
			hRc);
        goto Error;
    }
    //
    //           -  Call the Device class destructor
    //
    delete pChildNode;

    //
    //           b) Update Order in the rest devices
    //
    ATLASSERT( m_ResultChildrenList.GetSize() == (int)m_dwNumOfDevices);
    for ( j = 0; j < (int)m_dwNumOfDevices; j++)
    {
        m_ResultChildrenList[j]->SetOrder((UINT)j+1, (UINT)m_dwNumOfDevices);
    }
    
    //
    //           c) Update the group views and the scope pane node itself 
    //
    ATLASSERT( m_pComponentData != NULL );
    ATLASSERT( m_pComponentData->m_spConsole != NULL );

    hRc = m_pComponentData->m_spConsole->UpdateAllViews( NULL, NULL, NULL);
    if (FAILED(hRc))
    {
        DebugPrintEx( DEBUG_ERR,
		    _T("Unexpected error - Fail to UpdateAllViews."));
        NodeMsgBox(IDS_FAIL2UPDATEITEM_GROUP);
        
        goto Exit;
    }

    if ( 0 == m_dwNumOfDevices)
    {
        
        //
	// This will force MMC to redraw scope node
	//
        hRc = RefreshNameSpaceNode();
        if (FAILED(hRc))
        {
            DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("Fail to RefreshNameSpaceNode. (hRc: %08X)"),
                 hRc);
            goto Error;
        }
        
    }

    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("The device was removed successfully."));
    goto Exit;


Error:
	
    NodeMsgBox(IDS_FAIL_TO_REMOVE_DEVICE);
  
Exit:
    return hRc;
}


/*
 -  CFaxOutboundRoutingGroupNode::UpdateMenuState
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateMenuState
 *      which only have one line inside it "return;" 
 *      This function implements the grayed\ungrayed view for the 
 *      the Enable and the Disable menus.
 *
 *  Arguments:
 *
 *            [in]  id    - unsigned int with the menu IDM value
 *            [out] pBuf  - string 
 *            [out] flags - pointer to flags state combination unsigned int
 *
 *  Return:
 *      no return value - void function 
 */
void CFaxOutboundRoutingGroupNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::UpdateMenuState"));

    UNREFERENCED_PARAMETER (pBuf);     
    
    if (IDM_NEW_DEVICES == id)
    {
         if( 0 == wcscmp(ROUTING_GROUP_ALL_DEVICES, m_bstrGroupName) )
         {
            *flags = MF_GRAYED;
         }
         else
         {
            *flags = MF_ENABLED;
         }
    }
    return;
}





/*
 -  CFaxOutboundRoutingGroupNode::RefreshNameSpaceNode
 -
 *  Purpose:
 *      Refresh the NameSpace fields of the node.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */

HRESULT CFaxOutboundRoutingGroupNode::RefreshNameSpaceNode()
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::RefreshNameSpaceNode"));
    HRESULT     hRc = S_OK;

    ATLASSERT( m_pComponentData != NULL );
    ATLASSERT( m_pComponentData->m_spConsole != NULL );

    CComPtr<IConsole> spConsole;
    spConsole = m_pComponentData->m_spConsole;
    CComQIPtr<IConsoleNameSpace,&IID_IConsoleNameSpace> spNamespace( spConsole );
    
    SCOPEDATAITEM*    pScopeData;

    //
    // Get the updated SCOPEDATAITEM
    //
    hRc = GetScopeData( &pScopeData );
    if (FAILED(hRc))
    {
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to get pScopeData. (hRc: %08X)"),
			hRc);
        
        goto Error;
    }

    //
    // This will force MMC to redraw the scope group node
    //
    hRc = spNamespace->SetItem( pScopeData );
    if (FAILED(hRc))
    {
       DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to set Item pScopeData. (hRc: %08X)"),
			hRc);

        goto Error;
    }
    ATLASSERT( S_OK != hRc);
    
    goto Exit;

Error:
    NodeMsgBox(IDS_FAIL2REFRESH_GROUP);

Exit:
    return hRc;
}

/*
 +
 +  CFaxOutboundRoutingGroupNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxOutboundRoutingGroupNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    _TCHAR topicName[MAX_PATH];
    
    _tcscpy(topicName, helpFile);
    
    _tcscat(topicName, _T("::/FaxS_C_Groups.htm"));
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(topicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, topicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}


///////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\outboundgroups.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundGroups.cpp                                     //
//                                                                         //
//  DESCRIPTION   : Fax Server - Fax OutboundGroups node.                  //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg   create                                         //
//      Jan  3 2000 yossg   add new group                                  //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "OutboundGroups.h"
#include "OutboundGroup.h"

#include "dlgNewGroup.h"

#include "Icons.h"

//#include "oaidl.h"

// {1036F509-554F-41b7-BE77-CF8E8E994011}
static const GUID CFaxOutboundGroupsNodeGUID_NODETYPE = 
{ 0x1036f509, 0x554f, 0x41b7, { 0xbe, 0x77, 0xcf, 0x8e, 0x8e, 0x99, 0x40, 0x11 } };

const GUID*    CFaxOutboundGroupsNode::m_NODETYPE = &CFaxOutboundGroupsNodeGUID_NODETYPE;
const OLECHAR* CFaxOutboundGroupsNode::m_SZNODETYPE = OLESTR("1036F509-554F-41b7-BE77-CF8E8E994011");
const CLSID*   CFaxOutboundGroupsNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxOutboundGroupsNode::m_ColsInfo;


/*
 -  CFaxOutboundGroupsNode::initRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundGroupsNode::InitRPC(PFAX_OUTBOUND_ROUTING_GROUP * pFaxGroupsConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundGroupsNode::InitRPC"));
    
    HRESULT      hRc        = S_OK;
    DWORD        ec         = ERROR_SUCCESS;

    CFaxServer * pFaxServer = NULL;

    //
    // get Fax Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

	//
	// Retrieve the Outbound Groups configuration
	//
    if (!FaxEnumOutboundGroups(pFaxServer->GetFaxServerHandle(), 
                        pFaxGroupsConfig,
                        &m_dwNumOfGroups)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get groups configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(*pFaxGroupsConfig);
	ATLASSERT(FXS_ITEMS_NEVER_COUNTED != m_dwNumOfGroups);

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get groups configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);

    //
    // allow refresh in case of failure
    //
    m_dwNumOfGroups = 0;
    
    NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}


/*
 -  CFaxOutboundGroupsNode::PopulateScopeChildrenList
 -
 *  Purpose:
 *      Create all the Fax Outbound Routing Group nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 *		Actually it is the last OLE error code that ocoured 
 *      during processing this method.
 */
HRESULT CFaxOutboundGroupsNode::PopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundGroupsNode::PopulateScopeChildrenList"));
    HRESULT hRc  = S_OK; 

    CFaxOutboundRoutingGroupNode * pGroup = NULL;
                       
    PFAX_OUTBOUND_ROUTING_GROUP pFaxOutboundGroupsConfig = NULL;
    DWORD i;

    //
    // Get the Config. structure 
    //
    hRc = InitRPC(&pFaxOutboundGroupsConfig);
    if (FAILED(hRc))
    {
        //DebugPrint and MsgBox by called func.
        
        //to be safe actually done by InitRPC on error.
        pFaxOutboundGroupsConfig = NULL;
        
        goto Error;
    }
    ATLASSERT(NULL != pFaxOutboundGroupsConfig);

    for (i=0; i< m_dwNumOfGroups; i++ )
    {
        pGroup = new CFaxOutboundRoutingGroupNode(
                                    this, 
                                    m_pComponentData);
        if (!pGroup)
        {
            hRc = E_OUTOFMEMORY;
            NodeMsgBox(IDS_MEMORY);
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Out of memory. (hRc: %08X)"),
			    hRc);
            goto Error;
        }
        else
        {
	        pGroup->InitParentNode(this);

            hRc = pGroup->Init(&pFaxOutboundGroupsConfig[i]);
	        if (FAILED(hRc))
	        {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to init Group. (hRc: %08X)"),
			        hRc);
		        NodeMsgBox(IDS_FAILTOINIT_GROUP);
                goto Error;
	        }

	        hRc = AddChild(pGroup, &pGroup->m_scopeDataItem);
	        if (FAILED(hRc))
	        {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to add Group. (hRc: %08X)"),
			        hRc);
		        NodeMsgBox(IDS_FAILTOADD_GROUP);
                goto Error;
	        }
        }
    }
    
    pGroup = NULL;
    
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    //
    //Get Rid
    //
    {    
        //from the last one 
        if ( NULL != pGroup ) //(if new succeeded)
        {
            delete  pGroup;    
        }

        //from all the previous (if there are)
        int j = m_ScopeChildrenList.GetSize();
        for (int i = 0; i < j; i++)
        {
            pGroup = (CFaxOutboundRoutingGroupNode *)m_ScopeChildrenList[0];

            hRc = RemoveChild(pGroup);
            if (FAILED(hRc))
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("Fail to delete group. (hRc: %08X)"), 
                    hRc);
                goto Error;
            }
            delete pGroup;
        }

        // Empty the list of all groups added before the one who failed
        // already done one by one inside RemoveChild
        // m_ScopeChildrenList.RemoveAll(); 
    
        m_bScopeChildrenListPopulated = FALSE;
    }
Exit:
    if (NULL != pFaxOutboundGroupsConfig)
    {
        FaxFreeBuffer(pFaxOutboundGroupsConfig);
    }       
    
    return hRc;
}

/*
 -  CFaxOutboundGroupsNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxOutboundGroupsNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    SCODE hRc;

    DEBUG_FUNCTION_NAME( _T("CFaxOutboundGroupsNode::InsertColumns"));

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_OUTBOUND_GROUPS_COL1, FXS_WIDE_COLUMN_WIDTH},
        {IDS_OUTBOUND_GROUPS_COL2, AUTO_WIDTH},
        {IDS_OUTBOUND_GROUPS_COL3, AUTO_WIDTH},
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    if (hRc != S_OK)
    {
        DebugPrintEx(DEBUG_ERR,_T("m_ColsInfo.InsertColumnsIntoMMC. (hRc: %08X)"), hRc);
        goto Cleanup;
    }

Cleanup:
    return(hRc);
}


/*
 -  CFaxOutboundGroupsNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxOutboundGroupsNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    //  Refresh
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 
    
    return hRc;
}


/*
 -  CFaxOutboundGroupsNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxOutboundGroupsNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundGroupsNode::OnRefresh"));
    HRESULT hRc = S_OK;

    SCOPEDATAITEM*          pScopeData;
    CComPtr<IConsole>       spConsole;

	if (FXS_ITEMS_NEVER_COUNTED != m_dwNumOfGroups)//already expanded before.
	{

        //
        // Repopulate Scope Children List
        //
        hRc = RepopulateScopeChildrenList();
        if (S_OK != hRc)
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to RepopulateScopeChildrenList(). (hRc: %08X)"),
			    hRc);
            // Done by called func. NodeMsgBox(FAIL2REPOPULATE_GROUP_LIST);

            goto Exit;
        }
    }
	else //never expanded before
    {
		DebugPrintEx(
			DEBUG_MSG,
			_T("User call refresh before expand node's children."));
        //continue to reselect the node.
	}

    //
	// Get the updated SCOPEDATAITEM
	//
    hRc = GetScopeData( &pScopeData );
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to get pScopeData. (hRc: %08X)"),
			hRc);
        NodeMsgBox(IDS_FAIL2REDRAW_GROUPSNODE);

        goto Exit;
    }

    //
	// This will force MMC to redraw the scope node
	//
    spConsole = m_pComponentData->m_spConsole;
    ATLASSERT(spConsole);
	
    hRc = spConsole->SelectScopeItem( pScopeData->ID );
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to select scope Item. (hRc: %08X)"),
			hRc);
        NodeMsgBox(IDS_FAIL2REDRAW_GROUPSNODE);
    }

Exit:
    return hRc;
}


/*
 -  CFaxOutboundGroupsNode::OnNewGroup
 -
 *  Purpose:
 *      
 *
 *  Arguments:
 *      [out]   bHandled - Do we handle it?
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */
HRESULT
CFaxOutboundGroupsNode::OnNewGroup(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundGroup::OnNewGroup"));
    HRESULT     hRc         =    S_OK;
    INT_PTR     rc          =    IDOK;

    CDlgNewFaxOutboundGroup      DlgNewGroup(((CFaxServerNode *)GetRootNode())->GetFaxServer());

    //
    // Dialog to add group
    //
    rc = DlgNewGroup.DoModal();
    if (rc != IDOK)
    {
        goto Cleanup;
    }

    //
    // Repopulate (with RPC) and Refresh the view
    //
    if (m_bScopeChildrenListPopulated)
    {
        DoRefresh(pRoot);
    }

 
Cleanup:
    return hRc;
}

/*
 -  CFaxOutboundGroupsNode::RepopulateScopeChildrenList
 -
 *  Purpose:
 *      RePopulateScopeChildrenList
 *
 *  Arguments:
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxOutboundGroupsNode::RepopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundGroupsNode::RepopulateScopeChildrenList"));
    HRESULT hRc = S_OK;

    CFaxOutboundRoutingGroupNode *pChildNode ;

    CComPtr<IConsole> spConsole;
    ATLASSERT(m_pComponentData);

    spConsole = ((CSnapin*)m_pComponentData)->m_spConsole;
    ATLASSERT( spConsole != NULL );
    
    CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);

    //
    // Remove group objects from list
    //
    for (int i = 0; i < m_ScopeChildrenList.GetSize(); i++)
    {
        pChildNode = (CFaxOutboundRoutingGroupNode *)m_ScopeChildrenList[i];

        hRc = spConsoleNameSpace->DeleteItem(pChildNode->m_scopeDataItem.ID, TRUE);
        if (FAILED(hRc))
        {
            DebugPrintEx(DEBUG_ERR,
                _T("Fail to delete group. (hRc: %08X)"), 
                hRc);
			// This is a very bad place to catch a failure
			// DeleteItem may return S_OK or E_UNEXPECTED
			// We do not pop-up this info to the user.

			goto Error;
        }
		delete pChildNode;
    }

    //
    // Empty the list object itself and change it's status
    //
    m_ScopeChildrenList.RemoveAll();

    m_bScopeChildrenListPopulated = FALSE;

    //
    // Rebuild the list
    //
    hRc = PopulateScopeChildrenList();
    if (FAILED(hRc))
    {
        DebugPrintEx(DEBUG_ERR,
            _T("Fail to Populate groups. (hRc: %08X)"), 
            hRc);
        goto Error;
    }

    m_bScopeChildrenListPopulated = TRUE;

    ATLASSERT(S_OK == hRc);
    DebugPrintEx(DEBUG_MSG,
        _T("Succeeded to Re Populate Groups. (hRc: %08X)"), 
        hRc);
    goto Cleanup;
Error:
   NodeMsgBox(IDS_FAIL2REPOPULATE_GROUPS);

Cleanup:
    return hRc;
}


/*
 -  CFaxOutboundGroupsNode::DoRefresh
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxOutboundGroupsNode::DoRefresh(CSnapInObjectRootBase *pRoot)
{
    CComPtr<IConsole> spConsole;

    //
    // Repopulate childs
    //
    RepopulateScopeChildrenList();

    if (pRoot)
    {
        //
        // Get the console pointer
        //
        ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
        if (pRoot->m_nType == 1)
        {
            //
            // m_ntype == 1 means the IComponentData implementation
            //
            CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
            spConsole = pCComponentData->m_spConsole;
        }
        else
        {
            //
            // m_ntype == 2 means the IComponent implementation
            //
            CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
            spConsole = pCComponent->m_spConsole;
        }
    }
    else
    {
        ATLASSERT(m_pComponentData);
        spConsole = m_pComponentData->m_spConsole;
    }

    ATLASSERT(spConsole);
    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return S_OK;
}


HRESULT
CFaxOutboundGroupsNode::DoRefresh()
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundGroupsNode::DoRefresh()"));
    HRESULT hRc = S_OK;
    CComPtr<IConsole> spConsole;

    //
    // Repopulate childs
    //
    RepopulateScopeChildrenList();

    ATLASSERT( m_pComponentData != NULL );
    ATLASSERT( m_pComponentData->m_spConsole != NULL );

    hRc = m_pComponentData->m_spConsole->UpdateAllViews( NULL, NULL, NULL);
    if (FAILED(hRc))
    {
        DebugPrintEx( DEBUG_ERR,
		    _T("Unexpected error - Fail to UpdateAllViews."));
        NodeMsgBox(IDS_FAIL2REFRESH_THEVIEW);        
    }

    return hRc;
}

/*
 -  CFaxOutboundGroupsNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundGroupsNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxOutboundGroupNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), IDS_DISPLAY_STR_OUTROUTEGROUPSNODE) )
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}

/*
 -  CFaxOutboundGroupsNode::DeleteGroup
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    bstrName   - The Group name
 *      [in]    pChildNode - The node to be deleted
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxOutboundGroupsNode::DeleteGroup(BSTR bstrName, CFaxOutboundRoutingGroupNode *pChildNode)
{
    DEBUG_FUNCTION_NAME(_T("CFaxOutboundGroupsNode::DeleteGroup"));
    HRESULT       hRc        = S_OK;
    DWORD         ec         = ERROR_SUCCESS;
    BOOL         fSkipMessage = FALSE;

    CFaxServer *  pFaxServer = NULL;
    
    //
    // get RPC Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Remove with RPC from the server
    //
    if (!FaxRemoveOutboundGroup (
	        pFaxServer->GetFaxServerHandle(),
	        bstrName))
    {
        ec = GetLastError();

        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to remove group. (ec: %ld)"), 
			ec);

        if (FAX_ERR_GROUP_IN_USE == ec)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("The group is empty or none of group devices is valid. (ec: %ld)"), 
			    ec);
            
            NodeMsgBox(IDS_FAX_ERR_GROUP_IN_USE);
            fSkipMessage = TRUE;

            goto Error; 
        }

        
        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
    

    //
    // Remove from MMC 
    //
    ATLASSERT(pChildNode);
    hRc = RemoveChild(pChildNode);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to remove Group. (hRc: %08X)"),
			hRc);
        NodeMsgBox(IDS_FAIL_TO_REMOVE_GROUP);
        return(hRc);
    }

    //
    // Call the group destructor
    //
    delete pChildNode;

    
    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("The group was removed successfully."));
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
	
    if (!fSkipMessage)
    {
        NodeMsgBox(GetFaxServerErrorMsg(ec));
    }
  
Exit:
    return (hRc);
}

/*
 +
 +  CFaxOutboundGroupsNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxOutboundGroupsNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    _TCHAR topicName[MAX_PATH];
    
    _tcscpy(topicName, helpFile);
    
    _tcscat(topicName, _T("::/FaxS_C_Groups.htm"));
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(topicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, topicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

///////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\outboundgroup.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundGroup.h                                        //
//                                                                         //
//  DESCRIPTION   : Header file for the Fax Outbound Routing Group Node    //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 23 1999 yossg   Create                                         //
//      Jan  3 2000 yossg   add new device(s)                              //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXOUTBOUNDROUTINGGROUP_H
#define H_FAXOUTBOUNDROUTINGGROUP_H

#include "snapin.h"
#include "snpnres.h"


#include "OutboundDevice.h"
 
class CFaxOutboundGroupsNode;
class CFaxOutboundRoutingDeviceNode;

class CFaxOutboundRoutingGroupNode : public CNodeWithResultChildrenList<
                                        CFaxOutboundRoutingGroupNode,    
                                        CFaxOutboundRoutingDeviceNode, 
                                        CSimpleArray<CFaxOutboundRoutingDeviceNode*>, 
                                        FALSE>
{

public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxOutboundRoutingGroupNode, FALSE)
      SNAPINCOMMAND_ENTRY(IDM_NEW_DEVICES, OnNewDevice)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxOutboundRoutingGroupNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_OUTGROUP_MENU)

    //
    // Constructor
    //
    CFaxOutboundRoutingGroupNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithResultChildrenList<CFaxOutboundRoutingGroupNode, CFaxOutboundRoutingDeviceNode, CSimpleArray<CFaxOutboundRoutingDeviceNode*>, FALSE>(pParentNode, pComponentData )
    {
        m_bstrGroupName        = L"";
        m_lpdwDeviceID         = NULL;
        m_dwNumOfDevices       = 0;
        // Succeed ToPopulateAllDevices
        m_fSuccess = FALSE;
    }

    //
    // Destructor
    //
    ~CFaxOutboundRoutingGroupNode()
    {
        if (NULL != m_lpdwDeviceID)
        {
            delete[] m_lpdwDeviceID;
        }
    }

    virtual HRESULT PopulateResultChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl *pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    LPOLESTR GetResultPaneColInfo(int nCol);
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }

    void InitParentNode(CFaxOutboundGroupsNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    HRESULT Init(PFAX_OUTBOUND_ROUTING_GROUP pGroupConfig);

    //
    // Events on the Group
    //

    //delete the group
    virtual HRESULT OnDelete(LPARAM arg, 
                             LPARAM param,
                             IComponentData *pComponentData,
                             IComponent *pComponent,
                             DATA_OBJECT_TYPES type,
                             BOOL fSilent = FALSE);

    virtual HRESULT OnRefresh(LPARAM arg,
                              LPARAM param,
                              IComponentData *pComponentData,
                              IComponent * pComponent,
                              DATA_OBJECT_TYPES type);

    HRESULT DoRefresh(CSnapInObjectRootBase *pRoot);

    //
    // Treat Group Devices
    //

    HRESULT OnNewDevice(bool &bHandled, CSnapInObjectRootBase *pRoot);

    HRESULT DeleteDevice(DWORD dwDeviceIdToRemove, CFaxOutboundRoutingDeviceNode *pChildNode);

    HRESULT ChangeDeviceOrder(DWORD dwOrder, DWORD dwNewOrder, DWORD dwDeviceID, CSnapInObjectRootBase *pRoot);

    HRESULT SetNewDeviceList(LPDWORD lpdwNewDeviceID);

    void    UpdateMenuState (UINT id, LPTSTR pBuf, UINT *flags);

    //
    // Access To private members
    //
    DWORD   GetMaxOrder()   
                { return( m_fSuccess ? m_dwNumOfDevices : 0); }

    LPDWORD GetDeviceIDList()   { return m_lpdwDeviceID; }
    
    DWORD   GetNumOfDevices()   { return m_dwNumOfDevices; }

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:
    static CColumnsInfo         m_ColsInfo;
            
    CFaxOutboundGroupsNode *    m_pParentNode;

    //
    // members
    //
    CComBSTR                    m_bstrGroupName;       
    DWORD                       m_dwNumOfDevices;
    LPDWORD                     m_lpdwDeviceID;   
    FAX_ENUM_GROUP_STATUS       m_enumStatus;

    CComBSTR                    m_buf; 
    
    // Succeed ToPopulateAllDevices
    BOOL                        m_fSuccess;  

    //
    // Methods
    //
    HRESULT  InitMembers  (PFAX_OUTBOUND_ROUTING_GROUP pGroupConfig);

    HRESULT  InitGroupName(LPCTSTR lpctstrGroupName);

    UINT     GetStatusIDS (FAX_ENUM_GROUP_STATUS enumStatus);

    void     InitIcons ();

    //
    // for internal usage. similar to the public init 
    // but creates and frees its own configuration structure
    //
    HRESULT  RefreshFromRPC();

    HRESULT  RefreshNameSpaceNode();
};

typedef CNodeWithResultChildrenList<CFaxOutboundRoutingGroupNode, CFaxOutboundRoutingDeviceNode, CSimpleArray<CFaxOutboundRoutingDeviceNode*>, FALSE>
        CBaseFaxOutboundRoutingGroupNode;

#endif  //H_FAXOUTBOUNDROUTINGGROUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\outboundrouting.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundRouting.h                                      //
//                                                                         //
//  DESCRIPTION   : Header file for CFaxOutboundRoutingNode class          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg   create                                         //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXOUTBOUNDNODE_H
#define H_FAXOUTBOUNDNODE_H

#include "snapin.h"
#include "snpnscp.h" //#include "snpnode.h"

class CFaxServerNode;

class CFaxOutboundRoutingNode : public CNodeWithScopeChildrenList<CFaxOutboundRoutingNode, FALSE>
{
public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxOutboundRoutingNode, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxOutboundRoutingNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_SNAPIN_MENU)

    CFaxOutboundRoutingNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithScopeChildrenList<CFaxOutboundRoutingNode, FALSE>(pParentNode, pComponentData )
    {
    }

    ~CFaxOutboundRoutingNode()
    {
    }

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);

    // virtual
    HRESULT OnRefresh(LPARAM arg,
                      LPARAM param,
                      IComponentData *pComponentData,
                      IComponent * pComponent,
                      DATA_OBJECT_TYPES type);

    void InitParentNode(CFaxServerNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    HRESULT InitDisplayName();


    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:

    static CColumnsInfo      m_ColsInfo;

    CFaxServerNode *         m_pParentNode;
};

//typedef CNodeWithScopeChildrenList<CFaxOutboundRoutingNode, FALSE>
//        CBaseFaxOutboundRoutingNode;


#endif  //H_FAXOUTBOUNDNODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\outboundrouting.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundRouting.cpp                                    //
//                                                                         //
//  DESCRIPTION   : Fax Server - Fax OutboundRouting node.                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg   create                                         //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "OutboundRouting.h"

#include "OutboundRules.h" 
#include "OutboundGroups.h" 

#include "Icons.h"

//#include "oaidl.h"

/****************************************************

CFaxOutboundRoutingNode Class

 ****************************************************/

// {38B04E8F-9BA6-4a22-BEF3-9AD90E3349B2}
static const GUID CFaxOutboundRoutingNodeGUID_NODETYPE = 
{ 0x38b04e8f, 0x9ba6, 0x4a22, { 0xbe, 0xf3, 0x9a, 0xd9, 0xe, 0x33, 0x49, 0xb2 } };

const GUID*    CFaxOutboundRoutingNode::m_NODETYPE = &CFaxOutboundRoutingNodeGUID_NODETYPE;
const OLECHAR* CFaxOutboundRoutingNode::m_SZNODETYPE = OLESTR("38B04E8F-9BA6-4a22-BEF3-9AD90E3349B2");
const CLSID*   CFaxOutboundRoutingNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxOutboundRoutingNode::m_ColsInfo;

/*
 -  CFaxOutboundRoutingNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxOutboundRoutingNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingNode::InsertColumns"));
    HRESULT hRc = S_OK;


    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_FAX_COL_HEAD, FXS_LARGE_COLUMN_WIDTH}, 
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    if (hRc != S_OK)
    {
        DebugPrintEx(DEBUG_ERR,_T("m_ColsInfo.InsertColumnsIntoMMC. (hRc: %08X)"), hRc);
        goto Cleanup;
    }

Cleanup:
    return(hRc);
}


/*
 -  CFaxOutboundRoutingNode::PopulateScopeChildrenList
 -
 *  Purpose:
 *      Create Out bound routing main nodes: Groups and Rules
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingNode::PopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingNode::PopulateScopeChildrenList"));
    HRESULT                  hRc      = S_OK; 

    CFaxOutboundGroupsNode * pGroups  = NULL;
    CFaxOutboundRoutingRulesNode *  pRules   = NULL;

    //
    // Fax OutboundGroups
    //
    pGroups = new CFaxOutboundGroupsNode(this, m_pComponentData);
    if (!pGroups)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Out of memory"));
        goto Error;
    }
	else
	{
        pGroups->InitParentNode(this);
/*
        hRc = pGroups->InitRPC();
        if (FAILED(hRc))
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to call RPC to init groups. (hRc: %08X)"),
			    hRc);
            goto Error;
        }
*/
        pGroups->SetIcons(IMAGE_FOLDER_CLOSE, IMAGE_FOLDER_OPEN);

        hRc = pGroups->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_ROUTINGGROUPS);
		    goto Error;
        }

        hRc = AddChild(pGroups, &pGroups->m_scopeDataItem);
		if (FAILED(hRc))
		{
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to add Devices node. (hRc: %08X)"),
			    hRc);
			NodeMsgBox(IDS_FAILTOADD_ROUTINGGROUPS);
            goto Error;
		}
	}

    //
    // Fax OutboundRules
    //
    pRules = new CFaxOutboundRoutingRulesNode(this, m_pComponentData);
    if (!pRules)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Out of memory"));
        goto Error;
    }
	else
	{
        pRules->InitParentNode(this);

        pRules->SetIcons(IMAGE_RULE, IMAGE_RULE);

        hRc = pRules->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_ROUTINGRULES);
		    goto Error;
        }

        hRc = AddChild(pRules, &pRules->m_scopeDataItem);
		if (FAILED(hRc))
		{
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to add outbound routing rules node. (hRc: %08X)"),
			    hRc);
			NodeMsgBox(IDS_FAILTOADD_ROUTINGRULES);
            goto Error;
		}
	}

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pGroups ) 
    {
        if (0 != pGroups->m_scopeDataItem.ID )
        {    
            HRESULT hr = RemoveChild(pGroups);
            if (FAILED(hr))
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("Fail to RemoveChild() Groups node from node list. (hRc: %08X)"), 
                    hr);
            }
        }
        delete  pGroups;    
        pGroups = NULL;    
    }
    if ( NULL != pRules ) 
    {
        if (0 != pRules->m_scopeDataItem.ID )
        {    
            HRESULT hr = RemoveChild(pRules);
            if (FAILED(hr))
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("Fail to RemoveChild() Rules node from node list. (hRc: %08X)"), 
                    hr);
            }
        }
        delete  pRules;    
        pRules = NULL;    
    }

    // Empty the list
    //m_ScopeChildrenList.RemoveAll(); //Done by RemoveChild

    m_bScopeChildrenListPopulated = FALSE;

Exit:
    return hRc;
}

/*
 -  CFaxOutboundRoutingNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxOutboundRoutingNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 

    return hRc;
}



/*
 -  CFaxOutboundRoutingNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxOutboundRoutingNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingNode::OnRefresh"));
    HRESULT hRc = S_OK;

/*
    
    // TBD

*/
    return hRc;
}

/*
 -  CFaxOutboundRoutingNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxOutboundRoutingNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                                IDS_DISPLAY_STR_OUTBOUNDROUTINGNODE) )
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load Outbound routing node name-string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}


/*
 +
 +  CFaxOutboundRoutingNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxOutboundRoutingNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    _TCHAR topicName[MAX_PATH];
    
    _tcscpy(topicName, helpFile);
    
    _tcscat(topicName, _T("::/FaxS_C_ManOutgo.htm"));
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(topicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, topicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\outboundgroups.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundGroups.h                                       //
//                                                                         //
//  DESCRIPTION   : Header file for CFaxOutboundGroupsNode class           //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg   create                                         //
//      Jan  3 2000 yossg   add new group                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXOUTBOUNDGROUPSNODE_H
#define H_FAXOUTBOUNDGROUPSNODE_H

#include "OutboundRouting.h"

#include "snapin.h"
#include "snpnscp.h" //#include "snpnode.h"

class CFaxOutboundRoutingNode;
class CFaxOutboundRoutingGroupNode;

class CFaxOutboundGroupsNode : public CNodeWithScopeChildrenList<CFaxOutboundGroupsNode, FALSE>
{
public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxOutboundGroupsNode, FALSE)
      SNAPINCOMMAND_ENTRY(IDM_NEW_GROUP, OnNewGroup)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxOutboundGroupsNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_OUTGROUPS_MENU)

    CFaxOutboundGroupsNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithScopeChildrenList<CFaxOutboundGroupsNode, FALSE>(pParentNode, pComponentData )
    {
        m_dwNumOfGroups = FXS_ITEMS_NEVER_COUNTED;
    }

    ~CFaxOutboundGroupsNode()
    {
    }

    HRESULT InitRPC(PFAX_OUTBOUND_ROUTING_GROUP * pFaxGroupsConfig);

    virtual HRESULT PopulateScopeChildrenList();

    HRESULT RepopulateScopeChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }

    // virtual
    HRESULT OnRefresh(LPARAM arg,
                      LPARAM param,
                      IComponentData *pComponentData,
                      IComponent * pComponent,
                      DATA_OBJECT_TYPES type);

    HRESULT DoRefresh(CSnapInObjectRootBase *pRoot);

    HRESULT DoRefresh();

    void InitParentNode(CFaxOutboundRoutingNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    HRESULT InitDisplayName();

    HRESULT DeleteGroup(BSTR bstrName, CFaxOutboundRoutingGroupNode *pChildNode);

    HRESULT OnNewGroup (bool &bHandled, CSnapInObjectRootBase *pRoot);

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:
    
    static CColumnsInfo             m_ColsInfo;

    CFaxOutboundRoutingNode *       m_pParentNode;

    DWORD                           m_dwNumOfGroups;
    
};

typedef CNodeWithScopeChildrenList<CFaxOutboundGroupsNode, FALSE>
        CBaseFaxOutboundGroupsNode;


#endif  //H_FAXOUTBOUNDGROUPSNODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\outboundrule.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundRule.h                                         //
//                                                                         //
//  DESCRIPTION   : Header file for the Outbound Routing Rule node.        //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 24 1999 yossg  Create                                          //
//      Dec 30 1999 yossg  create ADD/REMOVE rule                          //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXOUTBOUNDROUTINGRULE_H
#define H_FAXOUTBOUNDROUTINGRULE_H

#include "snapin.h"
#include "snpnode.h"

#include "Icons.h"


class CppFaxOutboundRoutingRule;
class CFaxOutboundRoutingRulesNode;

class CFaxOutboundRoutingRuleNode : public CSnapinNode <CFaxOutboundRoutingRuleNode, FALSE>
{

public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxOutboundRoutingRuleNode, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxOutboundRoutingRuleNode)
    END_SNAPINTOOLBARID_MAP()

    //
    // Constructor
    //
    CFaxOutboundRoutingRuleNode (CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CSnapinNode<CFaxOutboundRoutingRuleNode, FALSE>(pParentNode, pComponentData )
    {
        m_fIsAllCountries = FALSE; 
    }

    //
    // Destructor
    //
    ~CFaxOutboundRoutingRuleNode()
    {
    }

    LPOLESTR GetResultPaneColInfo(int nCol);

    void InitParentNode(CFaxOutboundRoutingRulesNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        IUnknown* pUnk,
        DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }
    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    virtual HRESULT OnDelete(LPARAM arg, 
                             LPARAM param,
                             IComponentData *pComponentData,
                             IComponent *pComponent,
                             DATA_OBJECT_TYPES type,
                             BOOL fSilent = FALSE);

    virtual HRESULT OnRefresh(LPARAM arg,
                              LPARAM param,
                              IComponentData * pComponentData,
                              IComponent * pComponent,
                              DATA_OBJECT_TYPES type);

    
    DWORD      GetCountryCode()  { return m_dwCountryCode; }
    DWORD      GetAreaCode()     { return m_dwAreaCode; }
    DWORD      GetDeviceID()     { return m_dwDeviceID; }
    CComBSTR   GetGroupName()    { return m_bstrGroupName; }
    BOOL       GetIsGroup()      { return m_fIsGroup; }

    HRESULT    Init(PFAX_OUTBOUND_ROUTING_RULE pRuleConfig);

    // virtual
    HRESULT OnPropertyChange(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:
    //
    // Parent Node
    //
    CFaxOutboundRoutingRulesNode * m_pParentNode;

    //
    // Property Pages
    //
    CppFaxOutboundRoutingRule * m_pRuleGeneralPP;

    //
    // members
    //
    DWORD                  m_dwCountryCode;
    DWORD                  m_dwAreaCode;

    CComBSTR               m_bstrCountryName;

    DWORD                  m_dwDeviceID;
    CComBSTR               m_bstrDeviceName;
    CComBSTR               m_bstrGroupName;

    BOOL                   m_fIsGroup;
    BOOL                   m_fIsAllCountries;

    FAX_ENUM_RULE_STATUS   m_enumStatus;
            
    CComBSTR               m_buf; 

    UINT     GetStatusIDS(FAX_ENUM_RULE_STATUS enumStatus);

    HRESULT  RefreshItemInView(IConsole *pConsole);

    //
    //  Init
    //
    HRESULT  InitMembers (PFAX_OUTBOUND_ROUTING_RULE pRuleConfig);

    DWORD    InitDeviceNameFromID (DWORD dwDeviceID);

    void     InitIcons ();
};

//typedef CSnapinNode<CFaxOutboundRoutingRuleNode, FALSE> CBaseFaxInboundRoutingMethodNode;

#endif  //H_FAXOUTBOUNDROUTINGRULE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\outboundrule.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundRule.cpp                                       //
//                                                                         //
//  DESCRIPTION   : Implementation of the Outbound Routing Rule node.      //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 24 1999 yossg  Create                                          //
//      Dec 30 1999 yossg  create ADD/REMOVE rule                          //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "snapin.h"

#include "OutboundRule.h"
#include "OutboundRules.h"

#include "ppFaxOutboundRoutingRule.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "FaxMMCPropertyChange.h"

#include "oaidl.h"
#include "urlmon.h"
#include "mshtmhst.h"
#include "exdisp.h"

/////////////////////////////////////////////////////////////////////////////
// {4A7636D3-13A4-4496-873F-AD5CB7360D3B}
static const GUID CFaxOutboundRoutingRuleNodeGUID_NODETYPE = 
{ 0x4a7636d3, 0x13a4, 0x4496, { 0x87, 0x3f, 0xad, 0x5c, 0xb7, 0x36, 0xd, 0x3b } };

const GUID*     CFaxOutboundRoutingRuleNode::m_NODETYPE        = &CFaxOutboundRoutingRuleNodeGUID_NODETYPE;
const OLECHAR*  CFaxOutboundRoutingRuleNode::m_SZNODETYPE      = OLESTR("4A7636D3-13A4-4496-873F-AD5CB7360D3B");
//const OLECHAR* CnotImplemented::m_SZDISPLAY_NAME = OLESTR("Outbound Routing Rules");
const CLSID*    CFaxOutboundRoutingRuleNode::m_SNAPIN_CLASSID  = &CLSID_Snapin;


/*
 -  CFaxOutboundRoutingRuleNode::Init
 -
 *  Purpose:
 *      Init all members icon etc.
 *
 *  Arguments:
 *      [in]    pRuleConfig - PFAX_OUTBOUND_ROUTING_RULE
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingRuleNode::Init(PFAX_OUTBOUND_ROUTING_RULE pRuleConfig)
{

    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRuleNode::Init"));
    HRESULT hRc = S_OK;

    ATLASSERT(pRuleConfig);

    hRc = InitMembers( pRuleConfig );
    if (FAILED(hRc))
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to InitMembers"));
        
        //NodeMsgBox done by called func.
        
        goto Exit;
    }
    ATLASSERT(SUCCEEDED(hRc));

    //
    // Icon
    //
    InitIcons();

Exit:
    return hRc;
}

/*
 -  CFaxOutboundRoutingRuleNode::InitIcons
 -
 *  Purpose:
 *      Private method that initiate icons
 *      due to the status member state.
 *
 *  Arguments:
 *      No.
 *
 *  Return:
 *      No.
 */
void CFaxOutboundRoutingRuleNode::InitIcons ()
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRuleNode::InitIcons"));
    switch (m_enumStatus)
    {
        case FAX_RULE_STATUS_VALID:
            m_resultDataItem.nImage = IMAGE_RULE;
            break;
        case FAX_RULE_STATUS_SOME_GROUP_DEV_NOT_VALID:
            m_resultDataItem.nImage = IMAGE_RULE_WARNING;
            break;

        case FAX_RULE_STATUS_EMPTY_GROUP:
        case FAX_RULE_STATUS_ALL_GROUP_DEV_NOT_VALID:
        case FAX_RULE_STATUS_BAD_DEVICE:
            m_resultDataItem.nImage = IMAGE_RULE_ERROR;
            break;

        default:
            ATLASSERT(0); // "this enumStatus is not supported "
            break; //currently 999

    } // endswitch (enumStatus)

    return;
}


/*
 -  CFaxOutboundRoutingRuleNode::InitMembers
 -
 *  Purpose:
 *      Private method to initiate members
 *      Must be called after init of m_pParentNode
 *
 *  Arguments:
 *      [in]    pRuleConfig - PFAX_OUTBOUND_ROUTING_RULE structure
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingRuleNode::InitMembers(PFAX_OUTBOUND_ROUTING_RULE pRuleConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRuleNode::InitMembers"));
    HRESULT hRc = S_OK;

    int iCount;
    WCHAR buff[2*FXS_MAX_CODE_LEN+1];

    ATLASSERT(pRuleConfig);
    
    //    
    // status    
    //    
    m_enumStatus          = pRuleConfig->Status;

    //
    // Country code and name
    //
    m_dwCountryCode       = pRuleConfig->dwCountryCode;
    if (ROUTING_RULE_COUNTRY_CODE_ANY != m_dwCountryCode)
    {
        if (NULL != pRuleConfig->lpctstrCountryName)
        {
            m_bstrCountryName = pRuleConfig->lpctstrCountryName;
            //m_fIsAllCountries = FALSE; done at constructor. here only verify
            ATLASSERT( FALSE == m_fIsAllCountries );
        }    
        else  //special case 
        {
            // Service did not provide the country names of countries with IDs 
            // between 101 to 124
            
            //ec = GetCountryNameFromID(m_dwCountryCode);
            //if ( ERROR_SUCCESS != ec )
            //{
            //}
            m_bstrCountryName = L"";
            ATLASSERT( FALSE == m_fIsAllCountries );
        }
    }
    else  //ROUTING_RULE_COUNTRY_CODE_ANY == m_dwCountryCode
    {
            m_bstrCountryName = L"";
            m_fIsAllCountries = TRUE;
    }
    if ( !m_bstrCountryName )
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    //
    // area code
    //
    m_dwAreaCode          = pRuleConfig->dwAreaCode;

    //
    // Group/Device
    //
    m_fIsGroup            = pRuleConfig->bUseGroup;
    if ( m_fIsGroup )
    {
        m_bstrGroupName = pRuleConfig->Destination.lpcstrGroupName;
        if (!m_bstrGroupName)
        {
            hRc = E_OUTOFMEMORY;
            goto Error;
        }
    }
    else
    {
        m_dwDeviceID     = pRuleConfig->Destination.dwDeviceId;
        DWORD ec         = ERROR_SUCCESS; 
        ec = InitDeviceNameFromID(m_dwDeviceID);
        if ( ERROR_SUCCESS != ec )
        {
            if (ERROR_BAD_UNIT != ec) 
            {
                hRc = HRESULT_FROM_WIN32(ec);
            }
            else //The system cannot find the device specified
            {
                if ( FAX_RULE_STATUS_VALID != m_enumStatus)
                {
                    m_enumStatus = FAX_RULE_STATUS_BAD_DEVICE;
		            DebugPrintEx(
			            DEBUG_MSG,
			            TEXT("m_enumStatus was changed after ERROR_BAD_UNIT failure."));                    
                }
                //hRc stays S_OK !!! since we will intrduce this bad state
            }
            m_bstrDeviceName=L"???";
			//message box done by GetDeviceNameFromID
            goto Exit;
        }
        ATLASSERT(m_bstrDeviceName);
    }

    //
    // Pepare m_bstrDisplayName for NodeMsgBox
    //
    iCount = swprintf(buff, L"+%ld (%ld)", m_dwCountryCode, m_dwAreaCode);

    if( iCount <= 0 )
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to read CountryCode and/or AreaCode."));
        goto Error;
    }
    m_bstrDisplayName = buff;
    if (!m_bstrDisplayName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
     
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    ATLASSERT(NULL != m_pParentNode);
    if (NULL != m_pParentNode)
    {
        m_pParentNode->NodeMsgBox(IDS_MEMORY);
    }
    
Exit:
    return (hRc);
}

/*
 -  CFaxOutboundRoutingRuleNode::GetResultPaneColInfo
 -
 *  Purpose:
 *      Return the text for specific column
 *      Called for each column in the result pane
 *
 *  Arguments:
 *      [in]    nCol - column number
 *
 *  Return:
 *      String to be displayed in the specific column
 */
LPOLESTR CFaxOutboundRoutingRuleNode::GetResultPaneColInfo(int nCol)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRuleNode::GetResultPaneColInfo"));
    HRESULT hRc = S_OK;

    UINT  idsStatus;
    int   iCount;
    WCHAR buffCountryCode[FXS_MAX_CODE_LEN+1];
    WCHAR buffAreaCode[FXS_MAX_CODE_LEN+1];

    m_buf.Empty();

    switch (nCol)
    {
    case 0:
        //
        // Country code
        //
        if (ROUTING_RULE_COUNTRY_CODE_ANY == m_dwCountryCode)
        {
            if (!m_buf.LoadString(IDS_COUNTRY_CODE_ANY))
            {
                hRc = E_OUTOFMEMORY;
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. Failed to load country code string."));
                goto Error;
            }
            return m_buf;
        }
        else
        {
            iCount = swprintf(buffCountryCode, L"%ld", m_dwCountryCode);

            if( iCount <= 0 )
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to read member - CountryCode."));
                goto Error;
            }
            else
            {
                m_buf = buffCountryCode;
                return (m_buf);
            }
        }
    case 1:
        //
        // Area code
        //
        if (ROUTING_RULE_AREA_CODE_ANY == m_dwAreaCode)
        {
            if (!m_buf.LoadString(IDS_ALL_AREAS))
            {
                hRc = E_OUTOFMEMORY;
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. Failed to load area code string."));
                goto Error;
            }
            return m_buf;
        }
        else
        {
            iCount = swprintf(buffAreaCode, L"%ld", m_dwAreaCode);

            if( iCount <= 0 )
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to read member - AreaCode."));
                goto Error;
            }
            else
            {
                m_buf = buffAreaCode;
                return (m_buf);
            }
        }

    case 2:
        //
        // Group/Device
        //
        if (m_fIsGroup)
        {
            if(0 == wcscmp(ROUTING_GROUP_ALL_DEVICES, m_bstrGroupName) )
            {
                if (!m_buf.LoadString(IDS_ALL_DEVICES))
                {
                    hRc = E_OUTOFMEMORY;
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Out of memory. Failed to all-devices group string."));
                    goto Error;
                }
                return m_buf;
            }
            else
            {
                if (!m_bstrGroupName)
                {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Null memeber BSTR - m_bstrGroupName."));
                    goto Error;
                }
                else
                {
                    return (m_bstrGroupName);
                }
            }
        }
        else
        {
            if (!m_bstrDeviceName)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrDeviceName."));
                goto Error;
            }
            else
            {
                return (m_bstrDeviceName);
            }
        }

    case 3:
        //
        // Status
        //
        idsStatus = GetStatusIDS(m_enumStatus);
        if ( FXS_IDS_STATUS_ERROR == idsStatus)
        {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Invalid Status value."));
                goto Error;
        }
        else
        {
            if (!m_buf.LoadString(idsStatus))
            {
                hRc = E_OUTOFMEMORY;
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. Failed to load status string."));
                goto Error;
            }
            return m_buf;
        }


    default:
        ATLASSERT(0); // "this number of column is not supported "
        return(L"");

    } // endswitch (nCol)

Error:
    return(L"???");

}


/*
 -  CFaxOutboundRoutingRuleNode::CreatePropertyPages
 -
 *  Purpose:
 *      Called when creating a property page of the object
 *
 *  Arguments:
 *      [in]    lpProvider - The property sheet
 *      [in]    handle     - Handle for notification
 *      [in]    pUnk       - Pointer to the data object
 *      [in]    type       - CCT_* (SCOPE, RESULT, ...)
 *
 *  Return:
 *      OLE error code
 */

HRESULT
CFaxOutboundRoutingRuleNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                    LONG_PTR                handle,
                                    IUnknown                *pUnk,
                                    DATA_OBJECT_TYPES       type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRuleNode::CreatePropertyPages"));
    HRESULT hRc = S_OK;

    ATLASSERT(lpProvider);
    ATLASSERT(type == CCT_RESULT || type == CCT_SCOPE);

    //
    // Initiate
    //
    m_pRuleGeneralPP = NULL;    

    //
    // General
    //
    m_pRuleGeneralPP = new CppFaxOutboundRoutingRule(
												 handle,
                                                 this,
                                                 TRUE,
                                                 _Module.GetResourceInstance());

	if (!m_pRuleGeneralPP)
	{
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
        goto Error;
	}
	
    hRc = m_pRuleGeneralPP->InitFaxRulePP(this);
    if (FAILED(hRc))
    {
		//DebugPrint by called func
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(m_pRuleGeneralPP->Create());
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add property page for General tab. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != m_pRuleGeneralPP ) 
    {
        delete  m_pRuleGeneralPP;    
        m_pRuleGeneralPP = NULL;    
    }

Exit:
    return hRc;
}


/*
 -  CFaxOutboundRoutingRuleNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxOutboundRoutingRuleNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // Display verbs that we support:
    // 1. Properties
    // 2. Delete
    // 3. Refresh
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    if (ROUTING_RULE_COUNTRY_CODE_ANY == m_dwCountryCode)
    {
		hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN,        FALSE);
        hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, INDETERMINATE, TRUE);
    }
    else
    {
        hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED,       TRUE);
    }
    
    
    
    
    //    hRc = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);


    //
    // We want the default verb to be Properties
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    return hRc;
}


/*
 -  CFaxOutboundRoutingRuleNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
/* virtual */HRESULT
CFaxOutboundRoutingRuleNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    HRESULT             hRc = S_OK;
    CComPtr<IConsole>   spConsole;

    //
    // TBD - At The moment do nothing
    //

    return hRc;
}



/*
 -  CFaxOutboundRoutingRuleNode::GetStatusIDS
 -
 *  Purpose:
 *      Transslate Status to IDS.
 *
 *  Arguments:
 *
 *            [in]  enumStatus    - unsigned int with the menu IDM value
 *
 *  Return:
 *            IDS of related status message 
 */
UINT CFaxOutboundRoutingRuleNode::GetStatusIDS(FAX_ENUM_RULE_STATUS enumStatus)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRuleNode::GetStatusIDS"));

    switch (enumStatus)
    {
        case FAX_RULE_STATUS_VALID:
            return IDS_STATUS_RULE_VALID;

        case FAX_RULE_STATUS_EMPTY_GROUP:
            return IDS_STATUS_RULE_EMPTY;

        case FAX_RULE_STATUS_ALL_GROUP_DEV_NOT_VALID:
            return IDS_STATUS_RULE_ALLDEVICESINVALID;

        case FAX_RULE_STATUS_SOME_GROUP_DEV_NOT_VALID:
            return IDS_STATUS_RULE_SOMEDEVICESINVALID;

        case FAX_RULE_STATUS_BAD_DEVICE:
            return IDS_STATUS_RULE_INVALID_DEVICE;

        default:
            ATLASSERT(0); // "this enumStatus is not supported "
            return(FXS_IDS_STATUS_ERROR); //currently 999

    } // endswitch (enumStatus)
}

/*
 -  CFaxOutboundRoutingRuleNode::InitDeviceNameFromID
 -
 *  Purpose:
 *      Transslate Device ID to Device Name and insert the data to
 *      m_bstrDeviceName
 *
 *  Arguments:
 *
 *            [in]  dwDeviceID    - device ID
 *
 *  Return:
 *            Error Code DWORD //OLE error message 
 */
DWORD CFaxOutboundRoutingRuleNode::InitDeviceNameFromID(DWORD dwDeviceID)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRuleNode::GetDeviceNameFromID"));
    DWORD          ec         = ERROR_SUCCESS;

    CFaxServer *   pFaxServer = NULL;
    PFAX_PORT_INFO_EX    pFaxDeviceConfig = NULL ;
    
    //
    // get RPC Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
	// Retrieve the Device configuration
	//
    if (!FaxGetPortEx(pFaxServer->GetFaxServerHandle(), 
                      m_dwDeviceID, 
                      &pFaxDeviceConfig)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get device configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(pFaxDeviceConfig);
    
    //
	// Retrieve the Device Name
	//
    m_bstrDeviceName = pFaxDeviceConfig->lpctstrDeviceName;
    if (!m_bstrDeviceName)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }
	
    ATLASSERT(ec == ERROR_SUCCESS);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get device configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);

    //Important!!!
    pFaxDeviceConfig = NULL;

    if (ERROR_BAD_UNIT != ec)
	{
	    NodeMsgBox(GetFaxServerErrorMsg(ec));
	}
	else
	{
            NodeMsgBox(IDS_FAIL_TO_DISCOVERDEVICENAME);
	}
    
    
Exit:
    if (NULL != pFaxDeviceConfig)
    {
        FaxFreeBuffer(pFaxDeviceConfig);
        pFaxDeviceConfig = NULL;
    }//any way function quits with memory allocation freed       

    return ec; 
}


/*
 -  CFaxOutboundRoutingRuleNode::OnDelete
 -
 *  Purpose:
 *      Called when deleting this node
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */

HRESULT CFaxOutboundRoutingRuleNode::OnDelete(
                 LPARAM arg,
                 LPARAM param,
                 IComponentData *pComponentData,
                 IComponent *pComponent,
                 DATA_OBJECT_TYPES type,
                 BOOL fSilent/* = FALSE*/

)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::OnDelete"));

    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    HRESULT     hRc = S_OK;


    //
    // Are you sure?
    //
    if (! fSilent)
    {
        //
        // 1. Use pConsole as owner of the message box
        //
        int res;
        NodeMsgBox(IDS_CONFIRM, MB_YESNO | MB_ICONWARNING, &res);

        if (IDNO == res)
        {
            goto Cleanup;
        }
    }

    //
    // validation of rule's AreaCode and CountryCode
    //
/*    if ( !m_bstrRuleName || L"???" == m_bstrRuleName)
    {
        NodeMsgBox(IDS_INVALID_GROUP_NAME);
        goto Cleanup;
    }
*/
    //
    // Delete it
    //
    ATLASSERT(m_pParentNode);
    hRc = m_pParentNode->DeleteRule(m_dwAreaCode,
	                                m_dwCountryCode,
                                    this);
    if ( FAILED(hRc) )
    {
        goto Cleanup;
    }

Cleanup:
    return hRc;
}


/*
 +
 +
 *
 *  CFaxOutboundRoutingRuleNode::OnPropertyChange
 *
 *
    In our implementation, this method gets called when the 
    MMCN_PROPERTY_CHANGE
    Notify message is sent for this node.
 *
    When the snap-in uses the MMCPropertyChangeNotify function to notify it's
    views about changes, MMC_PROPERTY_CHANGE is sent to the snap-in's
    IComponentData and IComponent implementations.
 *
 *
    Parameters

        arg
        [in] TRUE if the property change is for a scope pane item.

        lParam
        This is the param passed into MMCPropertyChangeNotify.


 *  Return Values
 *
 -
 -
 */
//////////////////////////////////////////////////////////////////////////////
HRESULT CFaxOutboundRoutingRuleNode::OnPropertyChange(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    DEBUG_FUNCTION_NAME( _T("FaxOutboundRoutingRuleNode::OnPropertyChange"));
    HRESULT hRc = S_OK;
    CComPtr<IConsole>   spConsole;

    CFaxRulePropertyChangeNotification * pNotification;

    //
    // Encode Property Change Notification data
    //
    pNotification = reinterpret_cast<CFaxRulePropertyChangeNotification *>(param);
    ATLASSERT(pNotification);
    ATLASSERT( RuleFaxPropNotification == pNotification->enumType );

    m_dwCountryCode = pNotification->dwCountryCode;
    
    m_bstrCountryName = pNotification->bstrCountryName;
    if ( !m_bstrCountryName )
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    m_dwAreaCode = pNotification->dwAreaCode;

    m_fIsGroup = pNotification->fIsGroup;
    if (m_fIsGroup)
    {
        m_bstrGroupName = pNotification->bstrGroupName;
    }
    else
    {
        m_dwDeviceID = pNotification->dwDeviceID;

        DWORD ec         = ERROR_SUCCESS; 
        ec = InitDeviceNameFromID(m_dwDeviceID);
        if ( ERROR_SUCCESS != ec )
        {
            if (ERROR_BAD_UNIT != ec) 
            {
                hRc = HRESULT_FROM_WIN32(ec);
            }
            else //The system cannot find the device specified
            {
                if ( FAX_RULE_STATUS_VALID != m_enumStatus)
                {
                    m_enumStatus = FAX_RULE_STATUS_BAD_DEVICE;
		            DebugPrintEx(
			            DEBUG_MSG,
			            TEXT("m_enumStatus was changed after ERROR_BAD_UNIT failure."));                    
                }
                //hRc stays S_OK !!! since we will intrduce this bad state
            }
            m_bstrDeviceName=L"???";
			//message box done by GetDeviceNameFromID
            goto Exit;
        }
        ATLASSERT(m_bstrDeviceName);
    }

        
    //
    // get IConsole
    //

//    if (pComponentData != NULL)
//    {
//         spConsole = ((CSnapin*)pComponentData)->m_spConsole;
//    }
//    else  // We should have a non-null pComponent
//    {
         ATLASSERT(pComponent);         
         spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
//    }

         ATLASSERT(spConsole != NULL);

    hRc = RefreshItemInView(spConsole);
    if ( FAILED(hRc) )
    {
        //msgbox done by called func.
        goto Exit;
    }

    
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    NodeMsgBox(IDS_MEMORY);
    
Exit:
    //
    // any way you get here, memory must be freed
    //
    delete pNotification;
    
    
    return hRc;
}

/*
 -  CFaxOutboundRoutingRuleNode::RefreshItemInView
 -
 *  Purpose:
 *      Call IResultData::UpdateItem for single item
 *
 *  Arguments:
 *      [in]    pConsole - the console interface
 *
 *  Return: OLE error code
 */
HRESULT CFaxOutboundRoutingRuleNode::RefreshItemInView(IConsole *pConsole)
{
    DEBUG_FUNCTION_NAME( _T("FaxOutboundRoutingRuleNode::RefreshItemInView"));
    HRESULT     hRc = S_OK;

    //
    // Need IResultData
    //
    CComQIPtr<IResultData, &IID_IResultData> pResultData(pConsole);
    ATLASSERT(pResultData != NULL);

    //
    // Update the result item
    //
    hRc = pResultData->UpdateItem(m_resultDataItem.itemID);
    if ( FAILED(hRc) )
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Failure on pResultData->UpdateItem, (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL2REFRESH_THEVIEW);
        goto Exit;
    }

Exit:
    return hRc;
}


/*
 +
 +  CFaxOutboundRoutingRuleNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxOutboundRoutingRuleNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    _TCHAR topicName[MAX_PATH];
    
    _tcscpy(topicName, helpFile);
    
    _tcscat(topicName, _T("::/FaxS_C_OutRoute.htm"));
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(topicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, topicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\outboundrules.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundRules.h                                        //
//                                                                         //
//  DESCRIPTION   : Header file for the Fax Outbound Routing Rules Node    //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg  Create                                          //
//      Dec 24 1999 yossg  Reogenize as node with result children list     //
//      Dec 30 1999 yossg  create ADD/REMOVE rule                          //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXOUTBOUNDROUTINGRULES_H
#define H_FAXOUTBOUNDROUTINGRULES_H

#include "snapin.h"
#include "snpnres.h"

#include "OutboundRule.h"
 
class CFaxOutboundRoutingNode;
class CFaxOutboundRoutingRuleNode;

class CFaxOutboundRoutingRulesNode : public CNodeWithResultChildrenList<
                                        CFaxOutboundRoutingRulesNode,    
                                        CFaxOutboundRoutingRuleNode, 
                                        CSimpleArray<CFaxOutboundRoutingRuleNode*>, 
                                        FALSE>
{

public:

    BEGIN_SNAPINCOMMAND_MAP(CFaxOutboundRoutingRuleNode, FALSE)
      SNAPINCOMMAND_ENTRY(IDM_NEW_OUTRULE, OnNewRule)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxOutboundRoutingRuleNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_OUTRULES_MENU)

    //
    // Constructor
    //
    CFaxOutboundRoutingRulesNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithResultChildrenList<CFaxOutboundRoutingRulesNode, CFaxOutboundRoutingRuleNode, CSimpleArray<CFaxOutboundRoutingRuleNode*>, FALSE>(pParentNode, pComponentData )
    {
        m_dwNumOfOutboundRules     = 0;
    }

    //
    // Destructor
    //
    ~CFaxOutboundRoutingRulesNode()
    {
    }

	//
	// get data from RPC 
	//
    HRESULT InitRPC(PFAX_OUTBOUND_ROUTING_RULE  *pFaxRulesConfig);

    virtual HRESULT PopulateResultChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl *pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    void InitParentNode(CFaxOutboundRoutingNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    virtual HRESULT OnRefresh(LPARAM arg,
                              LPARAM param,
                              IComponentData *pComponentData,
                              IComponent * pComponent,
                              DATA_OBJECT_TYPES type);

    HRESULT DoRefresh(CSnapInObjectRootBase *pRoot);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }

    HRESULT InitDisplayName();

    HRESULT DeleteRule(DWORD dwAreaCode, DWORD dwCountryCode, 
                        CFaxOutboundRoutingRuleNode *pChildNode);

    HRESULT OnNewRule (bool &bHandled, CSnapInObjectRootBase *pRoot);


    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:

    static CColumnsInfo         m_ColsInfo;
    
    DWORD                       m_dwNumOfOutboundRules;
        
    CFaxOutboundRoutingNode *   m_pParentNode;
};

typedef CNodeWithResultChildrenList<CFaxOutboundRoutingRulesNode, CFaxOutboundRoutingRuleNode, CSimpleArray<CFaxOutboundRoutingRuleNode*>, FALSE>
        CBaseFaxOutboundRulesNode;

#endif  //H_FAXOUTBOUNDROUTINGRULES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxcataloginboundroutingmethod.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CppFaxCatalogInboundRoutingMethod.h                    //
//                                                                         //
//  DESCRIPTION   : Catalog's Inbox Routing Method Inbox property page     //
//                  header file.                                           //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan 30 2000 yossg  Created                                         //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXCATALOGINBOUNDROUTINGMETHOD_H_
#define _PP_FAXCATALOGINBOUNDROUTINGMETHOD_H_

#include "proppageex.h"
#include "CatalogInboundRoutingMethod.h"

class CFaxCatalogInboundRoutingMethodNode;    
/////////////////////////////////////////////////////////////////////////////
// CppFaxCatalogInboundRoutingMethod dialog

class CppFaxCatalogInboundRoutingMethod : public CPropertyPageExImpl<CppFaxCatalogInboundRoutingMethod>
{

public:
    //
    // Constructor
    //
    CppFaxCatalogInboundRoutingMethod(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           bOwnsNotificationHandle,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxCatalogInboundRoutingMethod();

	enum { IDD = IDD_FAXCATALOGMETHOD_GENERAL };

	BEGIN_MSG_MAP(CppFaxCatalogInboundRoutingMethod)
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )

        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxCatalogInboundRoutingMethod>)
	END_MSG_MAP()


    LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();

    HRESULT Init(CComBSTR bstrPath);

private:
    
    CComBSTR   m_bstrPath;

    LONG_PTR   m_lpNotifyHandle;
 
    LRESULT SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};




#endif // _PP_FAXCATALOGINBOUNDROUTINGMETHOD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\outboundrules.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundRules.cpp                                      //
//                                                                         //
//  DESCRIPTION   : Fax Outbound Rules MMC node.                           //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg  Create                                          //
//      Dec 24 1999 yossg  Reogenize as node with result children list     //
//      Dec 30 1999 yossg  create ADD/REMOVE rule                          //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "snapin.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "OutboundRules.h"
#include "OutboundRouting.h"
#include "dlgNewRule.h"

#include "oaidl.h"
#include "Icons.h"

//////////////////////////////////////////////////////////////
// {D17BA53F-0992-4404-8760-7D2933D9FC46}
static const GUID CFaxOutboundRoutingRulesNodeGUID_NODETYPE = 
{ 0xd17ba53f, 0x992, 0x4404, { 0x87, 0x60, 0x7d, 0x29, 0x33, 0xd9, 0xfc, 0x46 } };

const GUID*    CFaxOutboundRoutingRulesNode::m_NODETYPE = &CFaxOutboundRoutingRulesNodeGUID_NODETYPE;
const OLECHAR* CFaxOutboundRoutingRulesNode::m_SZNODETYPE = OLESTR("D17BA53F-0992-4404-8760-7D2933D9FC46");
const CLSID*   CFaxOutboundRoutingRulesNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxOutboundRoutingRulesNode::m_ColsInfo;

/*
 -  CFaxOutboundRoutingRulesNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxOutboundRoutingRulesNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRulesNode::InsertColumns"));
    HRESULT  hRc = S_OK;

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_OUTRRULES_COL1, AUTO_WIDTH},
        {IDS_OUTRRULES_COL2, AUTO_WIDTH},
        {IDS_OUTRRULES_COL3, FXS_WIDE_COLUMN_WIDTH},
        {IDS_OUTRRULES_COL4, AUTO_WIDTH},
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    CHECK_RETURN_VALUE_AND_PRINT_DEBUG (_T("m_ColsInfo.InsertColumnsIntoMMC"))

Cleanup:
    return(hRc);
}

/*
 -  CFaxOutboundRoutingRulesNode::initRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingRulesNode::InitRPC(PFAX_OUTBOUND_ROUTING_RULE  *pFaxRulesConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRulesNode::InitRPC"));
    
    HRESULT      hRc        = S_OK;
    DWORD        ec         = ERROR_SUCCESS;

    CFaxServer * pFaxServer = NULL;

    ATLASSERT(NULL == (*pFaxRulesConfig) );
    //
    // get Fax Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }
    

    //
	// Retrieve the fax Outbound Rules configuration
	//
    if (!FaxEnumOutboundRules(pFaxServer->GetFaxServerHandle(), 
                        pFaxRulesConfig,
                        &m_dwNumOfOutboundRules)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get Outbound Rules configuration. (ec: %ld)"), 
			ec);


        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }


        goto Error; 
    }
    //For max verification
    ATLASSERT(*pFaxRulesConfig);

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get outbound rules configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    m_pParentNode->NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}


/*
 -  CFaxOutboundRoutingRulesNode::PopulateResultChildrenList
 -
 *  Purpose:
 *      Create the FaxInboundRoutingMethods children nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingRulesNode::PopulateResultChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRulesNode::PopulateResultChildrenList"));
    HRESULT hRc = S_OK;

    CFaxOutboundRoutingRuleNode *   pRule = NULL;
                       
    PFAX_OUTBOUND_ROUTING_RULE  pFaxOutboundRulesConfig = NULL ;
    DWORD i;

    //
    // Get the Config. structure 
    //
    hRc = InitRPC(&pFaxOutboundRulesConfig);
    if (FAILED(hRc))
    {
        //DebugPrint and MsgBox by called func.
        
        //to be safe actually done by InitRPC on error.
        pFaxOutboundRulesConfig = NULL;
        
        goto Error;
    }
    ATLASSERT(NULL != pFaxOutboundRulesConfig);
    ATLASSERT(1 <= m_dwNumOfOutboundRules);

    
    for ( i=0; i< m_dwNumOfOutboundRules; i++ )
    {
            pRule = NULL;

            pRule = new CFaxOutboundRoutingRuleNode(this, m_pComponentData);
            if (!pRule)
            {
                hRc = E_OUTOFMEMORY;
                NodeMsgBox(IDS_MEMORY);
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. (hRc: %08X)"),
			        hRc);
                goto Error;
            }
            else
            {
	            pRule->InitParentNode(this);

                hRc = pRule->Init(&pFaxOutboundRulesConfig[i]);
	            if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to init rule node. (hRc: %08X)"),
			            hRc);
		            NodeMsgBox(IDS_FAIL2INIT_OUTBOUNDRULE);
                    goto Error;
	            }
	            hRc = this->AddChildToList(pRule);
	            if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to add rule to the view. (hRc: %08X)"),
			            hRc);
		            NodeMsgBox(IDS_FAIL2ADD_OUTBOUNDRULE);
                    goto Error;
	            }
                else
                {
                    pRule = NULL;
                }
            }
    }
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pRule ) 
    {
        delete  pRule;    
        pRule = NULL;    
    }
    
    //
    // Get rid of what we had.
    //
    {
        // Delete each node in the list of children
        int iSize = m_ResultChildrenList.GetSize();
        for (int j = 0; j < iSize; j++)
        {
            pRule = (CFaxOutboundRoutingRuleNode *)
                                    m_ResultChildrenList[j];
            ATLASSERT(pRule);
            delete pRule;
            pRule = NULL;
        }

        // Empty the list
        m_ResultChildrenList.RemoveAll();

        // We no longer have a populated list.
        m_bResultChildrenListPopulated = FALSE;
    }
    
Exit:
    if (NULL != pFaxOutboundRulesConfig)
    {
        FaxFreeBuffer(pFaxOutboundRulesConfig);
    }       
    
    return hRc;
}



/*
 -  CFaxOutboundRoutingRulesNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxOutboundRoutingRulesNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    //  Refresh
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 

    return hRc;
}



/*
 -  CFaxOutboundRoutingRulesNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
/* virtual */HRESULT
CFaxOutboundRoutingRulesNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRulesNode::OnRefresh"));
    HRESULT hRc = S_OK;


    //
    // Call the base class
    //
    hRc = CBaseFaxOutboundRulesNode::OnRefresh(arg,
                             param,
                             pComponentData,
                             pComponent,
                             type);
    if ( FAILED(hRc) )
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to call base class's OnRefresh. (hRc: %08X)"),
			hRc);
        goto Cleanup;
    }

Cleanup:

    return hRc;
}

/*
 -  CFaxOutboundRoutingRulesNode::OnNewRule
 -
 *  Purpose:
 *      
 *
 *  Arguments:
 *      [out]   bHandled - Do we handle it?
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */
HRESULT
CFaxOutboundRoutingRulesNode::OnNewRule(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRulesNode::OnNewRule"));
    HRESULT     hRc         =    S_OK;
    INT_PTR     rc          =    IDOK;

    CDlgNewFaxOutboundRule       DlgNewRule( ((CFaxServerNode *)GetRootNode())->GetFaxServer() );

    //
    // Dialog to add rule
    //
    hRc = DlgNewRule.InitRuleDlg();
    if (FAILED(hRc))
    {
        NodeMsgBox(IDS_FAIL2OPEN_DLG);
        return hRc;
    }

    rc = DlgNewRule.DoModal();
    if (rc != IDOK)
    {
        goto Cleanup;
    }


    //
    // Repopulate (with RPC) and Refresh the view
    //
    DoRefresh(pRoot);

Cleanup:
    return S_OK;
}


/*
 -  CFaxOutboundRoutingRulesNode::DoRefresh
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxOutboundRoutingRulesNode::DoRefresh(CSnapInObjectRootBase *pRoot)
{
    CComPtr<IConsole> spConsole;

    //
    // Repopulate childs
    //
    RepopulateResultChildrenList();

    if (pRoot)
    {
        //
        // Get the console pointer
        //
        ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
        if (pRoot->m_nType == 1)
        {
            //
            // m_ntype == 1 means the IComponentData implementation
            //
            CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
            spConsole = pCComponentData->m_spConsole;
        }
        else
        {
            //
            // m_ntype == 2 means the IComponent implementation
            //
            CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
            spConsole = pCComponent->m_spConsole;
        }
    }
    else
    {
        ATLASSERT(m_pComponentData);
        spConsole = m_pComponentData->m_spConsole;
    }

    ATLASSERT(spConsole);
    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return S_OK;
}


/*
 -  CFaxOutboundRoutingRulesNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingRulesNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxOutboundRoutingRulesNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                    IDS_DISPLAY_STR_OUTBOUNDRULES))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}

/*
 -  CFaxOutboundRoutingRulesNode::DeleteRule
 -
 *  Purpose:
 *      Delete rule
 *
 *  Arguments:
 *      [in]    dwAreaCode - The Rule Area Code
 *      [in]    dwCountryCode - The Rule Country Code
 *      [in]    pChildNode - The node to be deleted
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxOutboundRoutingRulesNode::DeleteRule(DWORD dwAreaCode, DWORD dwCountryCode, CFaxOutboundRoutingRuleNode *pChildNode)
{
    DEBUG_FUNCTION_NAME(_T("CFaxOutboundRoutingRulesNode::DeleteRule"));
    HRESULT       hRc        = S_OK;
    DWORD         ec         = ERROR_SUCCESS;

    CFaxServer *  pFaxServer = NULL;
    
    //
    // get RPC Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Remove with RPC from the server
    //
    if (!FaxRemoveOutboundRule (
	        pFaxServer->GetFaxServerHandle(),
	        dwAreaCode,
	        dwCountryCode))
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to remove rule. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
    

    //
    // Remove from MMC result pane
    //
    ATLASSERT(pChildNode);
    hRc = RemoveChild(pChildNode);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to remove rule. (hRc: %08X)"),
			hRc);
        NodeMsgBox(IDS_FAIL_TO_REMOVE_RULE);
        return hRc;
    }
    
    //
    // Call the rule destructor
    //
    delete pChildNode;
    
    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("The rule was removed successfully."));
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
	
    NodeMsgBox(GetFaxServerErrorMsg(ec));
  
Exit:
    return hRc;
}

/*
 +
 +  CFaxOutboundRoutingRulesNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxOutboundRoutingRulesNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    _TCHAR topicName[MAX_PATH];
    
    _tcscpy(topicName, helpFile);
    
    _tcscat(topicName, _T("::/FaxS_C_OutRoute.htm"));
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(topicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, topicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

///////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxcataloginboundroutingmethod.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CppFaxProviderGeneral.cpp                              //
//                                                                         //
//  DESCRIPTION   : prop pages of Catalog's Inbox Routing Method           //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan 30 2000 yossg  Created                                         //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxCatalogInboundRoutingMethod.h"
#include "FaxMMCGlobals.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Constructor
//
CppFaxCatalogInboundRoutingMethod::CppFaxCatalogInboundRoutingMethod(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        bOwnsNotificationHandle,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxCatalogInboundRoutingMethod>(pNode, NULL)
			                	
{
    m_lpNotifyHandle = hNotificationHandle;
}

//
// Destructor
//
CppFaxCatalogInboundRoutingMethod::~CppFaxCatalogInboundRoutingMethod()
{
    // Note - This needs to be called only once per property sheet.  
    // In our convention called in the general tab.
    if (NULL != m_lpNotifyHandle)
    {
        MMCFreeNotifyHandle(m_lpNotifyHandle);
        m_lpNotifyHandle = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CppFaxCatalogInboundRoutingMethod message handlers


/*
 -  CppFaxCatalogInboundRoutingMethod::Init
 -
 *  Purpose:
 *      Initiates all members
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxCatalogInboundRoutingMethod::Init(CComBSTR bstrPath)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxCatalogInboundRoutingMethod::Init"));
    HRESULT hRc = S_OK;

    
    
    m_bstrPath = bstrPath;
    if (!m_bstrPath)
    {
		DebugPrintEx( DEBUG_ERR, _T("Null m_bstrPath - out of memory."));
        goto Error;
    }
    
    goto Exit;

Error:
    hRc = E_OUTOFMEMORY;

Exit:
    return hRc;
}

/*
 -  CppFaxCatalogInboundRoutingMethod::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxCatalogInboundRoutingMethod::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxCatalogInboundRoutingMethod::PageInitDialog"));
    
	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );
    
    //
    // Extension
    //
    SetDlgItemText(IDC_EXTENSION_DLL_EDIT, m_bstrPath);
    	
    return (1);

}

/*
 -  CppFaxCatalogInboundRoutingMethod::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxCatalogInboundRoutingMethod::OnApply()
{

    return TRUE;
}


/*
 -  CppFaxCatalogInboundRoutingMethod::SetApplyButton
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxCatalogInboundRoutingMethod::SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetModified(TRUE);  
    bHandled = TRUE;
    return(1);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxServerSentItems::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxCatalogInboundRoutingMethod::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxCatalogInboundRoutingMethod::OnHelpRequest"));
    
    HELPINFO* helpinfo;
    DWORD     dwHelpId;

    switch (uMsg) 
    { 
        case WM_HELP: 

            helpinfo = (HELPINFO*)lParam;
            if (helpinfo->iContextType == HELPINFO_WINDOW)
            {
                ::WinHelp(
                          (HWND) helpinfo->hItemHandle,
                          FXS_ADMIN_HLP_FILE, 
                          HELP_CONTEXTPOPUP, 
                          (DWORD) helpinfo->dwContextId 
                       ); 
            }
            break; 
 
        case WM_CONTEXTMENU: 
            
            dwHelpId = ::GetWindowContextHelpId((HWND)wParam);
            if (dwHelpId) 
            {
                ::WinHelp
                       (
                         (HWND)wParam,
                         FXS_ADMIN_HLP_FILE, 
                         HELP_CONTEXTPOPUP, 
                         dwHelpId
                       );
            }
            break; 
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxdevicegeneral.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxDeviceGeneral.cpp                                 //
//                                                                         //
//  DESCRIPTION   : prop pages of Inbox archive                            //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 17 2000 yossg                                                  //
//                          Windows XP                                     //
//      Feb 14 2001 yossg   Add Manual Receive support                     //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxDeviceGeneral.h"
#include "Device.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "FaxMMCPropertyChange.h"

#include "FaxMMCGlobals.h"

#include "FxsValid.h"
#include "dlgutils.h"
#include <faxres.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Constructor
//
CppFaxDeviceGeneral::CppFaxDeviceGeneral(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             CSnapInItem *pParentNode,
             DWORD       dwDeviceID,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxDeviceGeneral>(pNode, NULL)
                                
{
    m_lpNotifyHandle   = hNotificationHandle;
    
    m_pParentNode      = NULL; //in case static-cast failed and wont change the pointer
    m_pParentNode      = static_cast <CFaxDeviceNode *> (pNode);

    m_pGrandParentNode = pParentNode; 

    m_dwDeviceID       = dwDeviceID;

    m_pFaxDeviceConfig = NULL;

    m_fAllReadyToApply = FALSE;
    m_fIsDialogInitiated = FALSE;

}

//
// Destructor
//
CppFaxDeviceGeneral::~CppFaxDeviceGeneral()
{
    if (NULL != m_pFaxDeviceConfig)
    {
        FaxFreeBuffer( m_pFaxDeviceConfig );
    }
    
    // Note - This needs to be called only once per property sheet.  
    // In our convention called in the general tab.
    if (NULL != m_lpNotifyHandle)
    {
        MMCFreeNotifyHandle(m_lpNotifyHandle);
        m_lpNotifyHandle = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CppFaxDeviceGeneral message handlers

/*
 -  CppFaxDeviceGeneral::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxDeviceGeneral::InitRPC(  )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxDeviceGeneral::InitRPC"));
    
    HRESULT        hRc        = S_OK;
    DWORD          ec         = ERROR_SUCCESS;

    
    //
    // get RPC Handle
    //   

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            _T("Failed to GetFaxServerHandle. (ec: %ld)"), 
            ec);

        goto Error;
    }

    //
    // Retrieve the Device configuration
    //
    if (!FaxGetPortEx(m_pFaxServer->GetFaxServerHandle(), 
                      m_dwDeviceID, 
                      &m_pFaxDeviceConfig)) 
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to get device configuration. (ec: %ld)"), 
            ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Network Error was found. (ec: %ld)"), 
                ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
    //For max verification
    ATLASSERT(m_pFaxDeviceConfig);

    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
        _T("Succeed to get device configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
    
    PageError(GetFaxServerErrorMsg(ec), m_hWnd);
    
Exit:
    return (hRc);
}


/*
 -  CppFaxDeviceGeneral::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxDeviceGeneral::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxDeviceGeneral::PageInitDialog"));
    
    DWORD   ec  = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER( uiMsg );
    UNREFERENCED_PARAMETER( wParam );
    UNREFERENCED_PARAMETER( lParam );
    UNREFERENCED_PARAMETER( fHandled );

    //
    // init controls
    // 
    m_DescriptionBox.Attach(GetDlgItem(IDC_DEVICE_DESCRIPTION_EDIT));
    m_TSIDBox.Attach(GetDlgItem(IDC_DEVICE_TSID_EDIT));
    m_CSIDBox.Attach(GetDlgItem(IDC_DEVICE_CSID_EDIT));
    m_RingsBox.Attach(GetDlgItem(IDC_DEVICE_RINGS_EDIT));
    m_RingsSpin.Attach(GetDlgItem(IDC_DEVICE_RINGS_SPIN));
   
    m_DescriptionBox.SetLimitText(MAX_FAX_STRING_LEN-1);
    m_TSIDBox.SetLimitText(FXS_TSID_CSID_MAX_LENGTH);
    m_CSIDBox.SetLimitText(FXS_TSID_CSID_MAX_LENGTH);
    m_RingsBox.SetLimitText(FXS_RINGS_LENGTH);


    ATLASSERT(m_pFaxDeviceConfig);

    //
    // Description
    //
    m_DescriptionBox.SetWindowText(m_pFaxDeviceConfig->lptstrDescription);

    //
    // Rings
    //
    m_RingsSpin.SetRange(FXS_RINGS_LOWER, FXS_RINGS_UPPER);
    m_RingsSpin.SetPos((int)m_pFaxDeviceConfig->dwRings);
    
    //
    // CSID
    //
    m_CSIDBox.SetWindowText(m_pFaxDeviceConfig->lptstrCsid);
        
    //
    // Receive
    //
    switch ( m_pFaxDeviceConfig->ReceiveMode ) 
    {
        case FAX_DEVICE_RECEIVE_MODE_OFF:    // Do not answer to incoming calls
            CheckDlgButton(IDC_RECEIVE_CHECK, BST_UNCHECKED);
            CheckDlgButton(IDC_RECEIVE_AUTO_RADIO1, BST_CHECKED);
            EnableReceiveControls (FALSE);    
            break;

        case FAX_DEVICE_RECEIVE_MODE_AUTO:   // Automatically answer to incoming calls after dwRings rings
            CheckDlgButton(IDC_RECEIVE_CHECK, BST_CHECKED);
            CheckDlgButton(IDC_RECEIVE_AUTO_RADIO1, BST_CHECKED);
            EnableRingsControls (TRUE);
            break;

        case FAX_DEVICE_RECEIVE_MODE_MANUAL: // Manually answer to incoming calls - only FaxAnswerCall answers the call
            CheckDlgButton(IDC_RECEIVE_CHECK, BST_CHECKED);
            CheckDlgButton(IDC_RECEIVE_MANUAL_RADIO2, BST_CHECKED);
            EnableRingsControls (FALSE);
            break;
        
        default:
            ATLASSERT(FALSE);
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Unexpected m_pFaxDeviceConfig->ReceiveMode"));

    }
        

    //
    // TSID
    //
    m_TSIDBox.SetWindowText(m_pFaxDeviceConfig->lptstrTsid);
    
    //
    // Send
    //
    if (m_pFaxDeviceConfig->bSend) 
    {
        CheckDlgButton(IDC_SEND_CHECK, BST_CHECKED) ;
    }
    else
    {
        CheckDlgButton(IDC_SEND_CHECK, BST_UNCHECKED) ;
        ::EnableWindow(GetDlgItem(IDC_DEVICE_TSID_EDIT),  FALSE);    
    }

    m_fIsDialogInitiated = TRUE;

    return (1);

}

/*
 -  CppFaxDeviceGeneral::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxDeviceGeneral::SetProps(int *pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxDeviceGeneral::SetProps"));

    HRESULT     hRc = S_OK;
    DWORD       ec  = ERROR_SUCCESS;

    HINSTANCE     hInst     = _Module.GetResourceInstance();

    CComBSTR    bstrDescription = L"";
    CComBSTR    bstrCSID        = L"";
    CComBSTR    bstrTSID        = L"";

    FAX_PORT_INFO_EX   FaxDeviceConfig;

    ATLASSERT(m_dwDeviceID == m_pFaxDeviceConfig->dwDeviceID);

    CFaxDevicePropertyChangeNotification * pDevicePropPageNotification = NULL;

    ATLASSERT(TRUE == m_fAllReadyToApply);
    m_fAllReadyToApply = FALSE;
    
    //
    // Step 1: Collect all data and init the structure's fields 
    // uses Copy() to copy and also allocate before
    //
    ZeroMemory (&FaxDeviceConfig, sizeof(FAX_PORT_INFO_EX));

    FaxDeviceConfig.dwSizeOfStruct      = sizeof(FAX_PORT_INFO_EX);
    FaxDeviceConfig.dwDeviceID          = m_dwDeviceID;
    FaxDeviceConfig.lpctstrDeviceName   = m_pFaxDeviceConfig->lpctstrDeviceName;

    FaxDeviceConfig.lpctstrProviderName = m_pFaxDeviceConfig->lpctstrProviderName;
    FaxDeviceConfig.lpctstrProviderGUID = m_pFaxDeviceConfig->lpctstrProviderGUID;

    //
    // Description
    //
    if ( !m_DescriptionBox.GetWindowText(&bstrDescription))
    {
        *pCtrlFocus = IDC_DEVICE_DESCRIPTION_EDIT;
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to GetWindowText(&bstrDescription)"));
        ec = ERROR_OUTOFMEMORY;
        goto Error;
    }
    // We allow empty description string!
    FaxDeviceConfig.lptstrDescription = bstrDescription;
 
    //
    // Receive
    //
    if (IsDlgButtonChecked(IDC_RECEIVE_CHECK) == BST_CHECKED)   
    {
        if (IsDlgButtonChecked(IDC_RECEIVE_AUTO_RADIO1) == BST_CHECKED)   
        {
            FaxDeviceConfig.ReceiveMode = FAX_DEVICE_RECEIVE_MODE_AUTO;
            
            //
            // new Rings
            //
            FaxDeviceConfig.dwRings    = (DWORD)m_RingsSpin.GetPos();
        }
        else //(IDC_RECEIVE_MANUAL_RADIO2) == BST_CHECKED)
        {
            FaxDeviceConfig.ReceiveMode = FAX_DEVICE_RECEIVE_MODE_MANUAL;
        
            //
            // Rings and CSID stay as is
            //
            FaxDeviceConfig.dwRings    = m_pFaxDeviceConfig->dwRings;
        }

        //
        // new CSID
        //
        if ( !m_CSIDBox.GetWindowText(&bstrCSID))
        {
            *pCtrlFocus = IDC_DEVICE_CSID_EDIT;
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to GetWindowText(&bstrCSID)"));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }
        //We allow empty CSID.
        FaxDeviceConfig.lptstrCsid = bstrCSID;
    }
    else
    {
        FaxDeviceConfig.ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
        
        //
        // Rings and CSID stay as is
        //
        FaxDeviceConfig.dwRings    = m_pFaxDeviceConfig->dwRings;
        FaxDeviceConfig.lptstrCsid = m_pFaxDeviceConfig->lptstrCsid;
    }
    
 
    //
    // Send
    //
    if (IsDlgButtonChecked(IDC_SEND_CHECK) == BST_CHECKED)   
    {
        FaxDeviceConfig.bSend = TRUE;

        //
        // new TSID
        //
        if ( !m_TSIDBox.GetWindowText(&bstrTSID))
        {
            *pCtrlFocus = IDC_DEVICE_TSID_EDIT;
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to GetWindowText(&bstrTSID)"));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }
        //we allow empty TSID!
        FaxDeviceConfig.lptstrTsid = bstrTSID;
        
    }
    else
    {
        FaxDeviceConfig.bSend   = FALSE;
        //
        // TSID stay as is
        //
        FaxDeviceConfig.lptstrTsid = m_pFaxDeviceConfig->lptstrTsid;
    }
   
    //
    // Step 2: Set data via RPC
    //
    
    //
    // get RPC Handle
    //   
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            _T("Failed to GetFaxServerHandle. (ec: %ld)"), 
            ec);
        goto Error;
    }

    //
    // Set Config
    //
    if (!FaxSetPortEx(
                m_pFaxServer->GetFaxServerHandle(),
                m_dwDeviceID,
                &FaxDeviceConfig)) 
    {       
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to Set device configuration. (ec: %ld)"), 
            ec);

        if ( FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED == ec )
        {
            hRc = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            
            DlgMsgBox(this, IDS_ERR_DEVICE_LIMIT, MB_OK|MB_ICONEXCLAMATION);

            goto Exit;
        }
        
        if (IsNetworkError(ec))
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Network Error was found. (ec: %ld)"), 
                ec);
            
            m_pFaxServer->Disconnect();       
        }
        
        goto Error;
    }

    DebugPrintEx( DEBUG_MSG,
        _T("Succeed to set device configuration."));

    //
    // Step 3: Update MMC
    //

    //
    // Prepare the notification fields before submit
    //
    pDevicePropPageNotification = new CFaxDevicePropertyChangeNotification();
    if (!pDevicePropPageNotification)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx( 
            DEBUG_ERR, 
            _T("Out of Memory - fail to operate new for CFaxDevicePropertyChangeNotification"));

        goto Error;
    }

    pDevicePropPageNotification->dwDeviceID = m_dwDeviceID;
    
    //
    // We have decided that we'll refresh all devices on a 
    // manual receive enabling. If it gets FALSE, just the single device is refreshed.
    //
    pDevicePropPageNotification->fIsToNotifyAdditionalDevices = 
        ( (FAX_DEVICE_RECEIVE_MODE_MANUAL == FaxDeviceConfig.ReceiveMode) ? TRUE : FALSE );

    pDevicePropPageNotification->pItem       = m_pGrandParentNode;
    pDevicePropPageNotification->enumType    = DeviceFaxPropNotification;

    //
    // Send notification from the property sheet thread to the main MMC thread
    //
    hRc = MMCPropertyChangeNotify(m_lpNotifyHandle, reinterpret_cast<LPARAM>(pDevicePropPageNotification));
    if (FAILED(hRc))
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to call MMCPropertyChangeNotify. (hRc: %08X)"), 
            hRc);
        
        PageError(IDS_FAIL_NOTIFY_MMCPROPCHANGE,m_hWnd);
        
        goto Exit;
    }

    //
    // To prevent deletion on error since it will be deleted 
    // by the reciever of the notification.
    //
    pDevicePropPageNotification =  NULL; 

    
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);

    PropSheet_SetCurSelByID( GetParent(), IDD);         
    ATLASSERT(::IsWindow(m_hWnd));
    PageError(GetFaxServerErrorMsg(ec),m_hWnd);

Exit:    
    return(hRc);
}

/*
 -  CppFaxDeviceGeneral::PreApply
 -
 *  Purpose:
 *      Checks properties before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxDeviceGeneral::PreApply(int *pCtrlFocus)
{
    HRESULT hRc = S_OK;
    
    //
    // PreApply Checks
    //
    if (!AllReadyToApply(/*fSilent =*/ FALSE))
    {
        m_fAllReadyToApply = FALSE;
        SetModified(FALSE);  
        hRc = E_FAIL ;
    }
    else
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }

    return(hRc);
}


/*
 -  CppFaxDeviceGeneral::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxDeviceGeneral::OnApply()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxDeviceGeneral::OnApply"));


    HRESULT  hRc  = S_OK;
    int     CtrlFocus = 0;

    hRc = PreApply(&CtrlFocus);
    if (FAILED(hRc))
    {
        //Error Msg by called func.
        if (CtrlFocus)
        {
            GotoDlgCtrl(GetDlgItem(CtrlFocus));
        }
        return FALSE;
    }
    else //(Succeeded(hRc))
    {
        hRc = SetProps(&CtrlFocus);
        if (FAILED(hRc)) 
        {
            //Error Msg by called func.
            if (CtrlFocus)
            {
                GotoDlgCtrl(GetDlgItem(CtrlFocus));
            }
            return FALSE;
        }
        else //(Succeeded(hRc))
        {
            return TRUE;
        }
    }

}

/*
 -  CppFaxDeviceGeneral::OnReceiveCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray the sub controls 
 *      Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxDeviceGeneral::OnReceiveCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxDeviceGeneral::OnReceiveCheckboxClicked"));
    BOOL State;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }

    State = ( IsDlgButtonChecked(IDC_RECEIVE_CHECK) == BST_CHECKED );

    EnableReceiveControls(State);
    
    if (m_fAllReadyToApply)//only last change should be considered
    {
        if ( !m_RingsBox.GetWindowTextLength() )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
        else
        {
            SetModified(TRUE);
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
        else
        {
            SetModified(FALSE);
        }
    }

    return 1;
}

/*
 -  CppFaxDeviceGeneral::OnReceiveRadioButtonClicked
 -
 *  Purpose:
 *      Check status OnReceiveRadioButtonClicked
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CppFaxDeviceGeneral::OnReceiveRadioButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER (wNotifyCode);
    UNREFERENCED_PARAMETER (wID);
    UNREFERENCED_PARAMETER (hWndCtl);
    UNREFERENCED_PARAMETER (bHandled);

    DEBUG_FUNCTION_NAME( _T("CppFaxDeviceGeneral::OnReceiveRadioButtonClicked"));
    
    if ( IsDlgButtonChecked(IDC_RECEIVE_AUTO_RADIO1) == BST_CHECKED )
    {        
        EnableRingsControls(TRUE);
        
        ::SetFocus(GetDlgItem(IDC_DEVICE_RINGS_EDIT));
    }
    else //IDC_RECEIVE_MANUAL_RADIO2
    {
        EnableRingsControls(FALSE);
    }
   
    if (m_fAllReadyToApply)//only last change should be considered
    {
        if ( 
             ( IsDlgButtonChecked(IDC_RECEIVE_AUTO_RADIO1) == BST_CHECKED )
             &&
             (!m_RingsBox.GetWindowTextLength() )
           )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
        else
        {
            SetModified(TRUE);
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
        else
        {
            SetModified(FALSE);
        }
    }

    return 1;
}



/*
 +  CppFaxDeviceGeneral::OnSendCheckboxClicked
 +
 *  Purpose:
 *      Gray/Ungray sub copntrols 
 *      Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 -      1
 -
 */
LRESULT CppFaxDeviceGeneral::OnSendCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxDeviceGeneral::OnSendCheckboxClicked"));
    BOOL State;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }

    State = ( IsDlgButtonChecked(IDC_SEND_CHECK) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_DEVICE_TSID_EDIT), State);    
    ::EnableWindow(GetDlgItem(IDC_TSID_STATIC),  State);    
    
    if (AllReadyToApply(TRUE))
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }
    else
    {
        m_fAllReadyToApply = FALSE;
        SetModified(FALSE);  
    }
    //this is due to the fact that we allow empty CSID

    return 1;
}


/*
 -  CppFaxDeviceGeneral::DeviceTextChanged
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxDeviceGeneral::DeviceTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

    if (AllReadyToApply(TRUE))
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }
    else
    {
        m_fAllReadyToApply = FALSE;
        SetModified(FALSE);  
    }

    return(1);
}


/*
 +  CppFaxDeviceGeneral::AllReadyToApply
 +
 *  Purpose:
 *      This function validate that no zero length strings 
 *      are found data areas that should be saved.
 *
 *  Arguments:
 *      [in] fSilent - boolean who defines if to pop up messages (FALSE)
 *           or not.(TRUE)
 *
 *  Return:
 -      BOOOLEAN
 -
 */
BOOL CppFaxDeviceGeneral::AllReadyToApply(BOOL fSilent)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxDeviceGeneral::AllReadyToApply"));
    
    DWORD         ec  = ERROR_SUCCESS;
    
    HINSTANCE     hInst = _Module.GetResourceInstance();
    
    if ( 
         (IsDlgButtonChecked(IDC_RECEIVE_CHECK) == BST_CHECKED)
        &&
         (IsDlgButtonChecked(IDC_RECEIVE_AUTO_RADIO1) == BST_CHECKED)
       )
    {
        if ( !m_RingsBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                _T("Zero text length - m_RingsBox. (ec: %ld)"), 
                ec);
        
            if (!fSilent)
            {
                PageError(IDS_DEVICE_RINGS_EMPTY, m_hWnd, hInst);
                ::SetFocus(GetDlgItem(IDC_DEVICE_RINGS_EDIT));
            }
            return FALSE;    
        }
    }

    //we allow empty tsid
    //we allow empty csid
    //we allow empty description
    
    ATLASSERT(ERROR_SUCCESS == ec);
    
    //
    // Cheers! 
    //      ...every thing ready to apply now.
    //
    return TRUE;           
}

/*
 -  CppFaxDeviceGeneral::EnableRingsControls
 -
 *  Purpose:
 *      Enable/disable the Rings controls.
 *
 *  Arguments:
 *      [in] state - boolean value to enable TRUE or FALSE to disable
 *
 *  Return:
 *      void
 */
void CppFaxDeviceGeneral::EnableRingsControls(BOOL fState)
{

    //
    // enable/disable controls
    //
    ::EnableWindow(GetDlgItem(IDC_DEVICE_RINGS_EDIT),   fState);    
    ::EnableWindow(GetDlgItem(IDC_DEVICE_RINGS_SPIN),   fState);    
    ::EnableWindow(GetDlgItem(IDC_DEVICE_RINGS_STATIC), fState);    
}

/*
 -  CppFaxDeviceGeneral::EnableReceiveControls
 -
 *  Purpose:
 *      Enable/disable the Rings controls.
 *
 *  Arguments:
 *      [in] state - boolean value to enable TRUE or FALSE to disable
 *
 *  Return:
 *      void
 */
void CppFaxDeviceGeneral::EnableReceiveControls(BOOL fState)
{

    //
    // enable/disable controls
    //
    ::EnableWindow(GetDlgItem(IDC_RECEIVE_MANUAL_RADIO2), fState);    
    ::EnableWindow(GetDlgItem(IDC_RECEIVE_AUTO_RADIO1),   fState);        
    
    
    ::EnableWindow(GetDlgItem(IDC_DEVICE_CSID_EDIT), fState);    
    ::EnableWindow(GetDlgItem(IDC_CSID_STATIC),      fState);    

    //
    // Combined state
    //
    fState = fState && (IsDlgButtonChecked(IDC_RECEIVE_AUTO_RADIO1) == BST_CHECKED);
    EnableRingsControls(fState);    
}

//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxDeviceGeneral::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxDeviceGeneral::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxDeviceGeneral::OnHelpRequest"));
    
    HELPINFO* helpinfo;
    DWORD     dwHelpId;

    switch (uMsg) 
    { 
        case WM_HELP: 

            helpinfo = (HELPINFO*)lParam;
            if (helpinfo->iContextType == HELPINFO_WINDOW)
            {
                ::WinHelp(
                          (HWND) helpinfo->hItemHandle,
                          FXS_ADMIN_HLP_FILE, 
                          HELP_CONTEXTPOPUP, 
                          (DWORD) helpinfo->dwContextId 
                       ); 
            }
            break; 
 
        case WM_CONTEXTMENU: 
            
            dwHelpId = ::GetWindowContextHelpId((HWND)wParam);
            if (dwHelpId) 
            {
                ::WinHelp
                       (
                         (HWND)wParam,
                         FXS_ADMIN_HLP_FILE, 
                         HELP_CONTEXTPOPUP, 
                         dwHelpId
                       );
            }
            break; 
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxdevicegeneral.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxDeviceGeneral.h                                   //
//                                                                         //
//  DESCRIPTION   : Fax Server Inbox prop page header file                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 27 1999 yossg  Created                                         //
//      Nov  3 1999 yossg  OnInitDialog, SetProps                          //
//      Nov 15 1999 yossg  Call RPC func                                   //
//                          Windows XP                                     //
//      Feb 14 2001 yossg   Add Manual Receive support                     //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXDEVICE_GENERAL_H_
#define _PP_FAXDEVICE_GENERAL_H_



#include "MyCtrls.h"
#include <proppageex.h>

//#include <windows.h>

class CFaxServer;    
class CFaxServerNode;
    
class CFaxDeviceNode;    
/////////////////////////////////////////////////////////////////////////////
// CppFaxDeviceGeneral dialog

class CppFaxDeviceGeneral : public CPropertyPageExImpl<CppFaxDeviceGeneral>
{

public:
    //
    // Constructor
    //
    CppFaxDeviceGeneral(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             CSnapInItem    *pParentNode,
             DWORD          dwDeviceID,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxDeviceGeneral();

	enum { IDD = IDD_FAXDEVICE_GENERAL };

	BEGIN_MSG_MAP(CppFaxDeviceGeneral)
		MESSAGE_HANDLER( WM_INITDIALOG,                      OnInitDialog )

        COMMAND_HANDLER( IDC_DEVICE_DESCRIPTION_EDIT, 
                                                 EN_CHANGE,  DeviceTextChanged )

        COMMAND_HANDLER( IDC_RECEIVE_CHECK,      BN_CLICKED, OnReceiveCheckboxClicked )
        COMMAND_HANDLER( IDC_RECEIVE_AUTO_RADIO1  ,  BN_CLICKED, OnReceiveRadioButtonClicked)
        COMMAND_HANDLER( IDC_RECEIVE_MANUAL_RADIO2,  BN_CLICKED, OnReceiveRadioButtonClicked)
		COMMAND_HANDLER( IDC_DEVICE_RINGS_EDIT,  EN_CHANGE,  DeviceTextChanged )
        COMMAND_HANDLER( IDC_DEVICE_CSID_EDIT,   EN_CHANGE,  DeviceTextChanged )

		COMMAND_HANDLER( IDC_SEND_CHECK,         BN_CLICKED, OnSendCheckboxClicked )
        COMMAND_HANDLER( IDC_DEVICE_TSID_EDIT,   EN_CHANGE,  DeviceTextChanged )

        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxDeviceGeneral>)
	END_MSG_MAP()

	//
	// Dialog's Handler and events.
	//
	HRESULT InitRPC( );

    LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();


    HRESULT SetProps(int *pCtrlFocus);
    HRESULT PreApply(int *pCtrlFocus);

private:
    //
    // Control members
    //
    CEdit         m_DescriptionBox;
    CEdit         m_CSIDBox;
    CEdit         m_TSIDBox;

    CEdit         m_RingsBox;
    CMyUpDownCtrl m_RingsSpin;

    //
    // Boolean members
    //
    BOOL  m_fAllReadyToApply;
    BOOL  m_fIsDialogInitiated;

    //
    // Config Structure member
    //
    PFAX_PORT_INFO_EX  m_pFaxDeviceConfig;
    DWORD              m_dwDeviceID;

    //
    // Handles
    //
    CFaxDeviceNode *   m_pParentNode;    
    CSnapInItem *      m_pGrandParentNode;
    LONG_PTR           m_lpNotifyHandle;

    //
    // Event methods
    //
    LRESULT OnReceiveCheckboxClicked    (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnReceiveRadioButtonClicked (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSendCheckboxClicked       (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
 
    LRESULT DeviceTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    BOOL AllReadyToApply(BOOL fSilent);
    
    void EnableRingsControls(BOOL fState);
    void EnableReceiveControls(BOOL fState);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};




#endif // _PP_FAXDEVICE_GENERAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxoutboundroutingrule.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxOutboundRoutingRule.h                             //
//                                                                         //
//  DESCRIPTION   : Fax Server Outbound routing rule prop page header file //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan  9 2000 yossg  Created                                         //
//      Jan 25 2000 yossg  Change the Dialog Design                        //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXOUTBOUNDROUTINGRULE_H_
#define _PP_FAXOUTBOUNDROUTINGRULE_H_

#include "OutboundRule.h"
#include "proppageex.h"
class CFaxOutboundRoutingRuleNode;    
/////////////////////////////////////////////////////////////////////////////
// CppFaxOutboundRoutingRule dialog

class CppFaxOutboundRoutingRule : public CPropertyPageExImpl<CppFaxOutboundRoutingRule>
{

public:
    //
    // Constructor
    //
    CppFaxOutboundRoutingRule(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           bOwnsNotificationHandle,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxOutboundRoutingRule();

	enum { IDD = IDD_FAXOUTRULE_GENERAL };

	BEGIN_MSG_MAP(CppFaxOutboundRoutingRule)
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )

        COMMAND_HANDLER(IDC_RULE_AREACODE_EDIT1, EN_CHANGE,     OnTextChanged)
        COMMAND_HANDLER(IDC_COUNTRY_RADIO1,      BN_CLICKED,    OnRuleTypeRadioClicked)
        COMMAND_HANDLER(IDC_AREA_RADIO1,         BN_CLICKED,    OnRuleTypeRadioClicked)
        COMMAND_HANDLER(IDC_DESTINATION_RADIO11, BN_CLICKED,    OnDestenationRadioClicked)
        COMMAND_HANDLER(IDC_DESTINATION_RADIO21, BN_CLICKED,    OnDestenationRadioClicked)

        COMMAND_HANDLER(IDC_RULE_COUNTRYCODE_EDIT1, EN_CHANGE,  OnTextChanged)
        COMMAND_HANDLER(IDC_RULE_SELECT_BUTTON1,    BN_CLICKED, OnSelectCountryCodeClicked)

        COMMAND_HANDLER(IDC_DEVICES4RULE_COMBO1, CBN_SELCHANGE, OnComboChanged)
        COMMAND_HANDLER(IDC_GROUP4RULE_COMBO1,   CBN_SELCHANGE, OnComboChanged)

        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxOutboundRoutingRule>)
	END_MSG_MAP()


    LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();

    LRESULT OnTextChanged            (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnComboChanged           (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDestenationRadioClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRuleTypeRadioClicked   (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSelectCountryCodeClicked (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    HRESULT InitFaxRulePP            (CFaxOutboundRoutingRuleNode * pParentNode);

    HRESULT SetProps(int *pCtrlFocus);
    HRESULT PreApply(int *pCtrlFocus);


private:
    
    //
    // Handles
    //
    CFaxOutboundRoutingRuleNode *   m_pParentNode;    
    LONG_PTR                        m_lpNotifyHandle;
 
    //
    // Methods
    //
    LRESULT  SetApplyButton (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    BOOL     AllReadyToApply(BOOL fSilent);

    HRESULT FaxConfigureRule(BOOL fNewUseGroup, DWORD dwNewDeviceID, LPCTSTR lpctstrNewGroupName);
    HRESULT FaxReplaceRule(DWORD dwNewAreaCode, DWORD dwNewCountryCode, BOOL fNewUseGroup,       
                             DWORD dwNewDeviceID, LPCTSTR lpctstrNewGroupName);

    //
    // List members
    //
    PFAX_PORT_INFO_EX               m_pFaxDevicesConfig;
    DWORD                           m_dwNumOfDevices;

    PFAX_OUTBOUND_ROUTING_GROUP     m_pFaxGroupsConfig;
    DWORD                           m_dwNumOfGroups;

    //
    // Initial state members
    //
    DWORD                           m_dwCountryCode;
    DWORD                           m_dwAreaCode;

    DWORD                           m_dwDeviceID;
    CComBSTR                        m_bstrGroupName;
    BOOL                            m_fIsGroup;

    //
    // misc members 
    //
    CComBSTR                        m_buf;

    BOOL                            m_fAllReadyToApply;
    BOOL                            m_fIsDialogInitiated;
    BOOL                            m_fIsDirty;  

    //
    // Controls
    //
    CEdit                           m_CountryCodeEdit;

    CEdit                           m_AreaCodeEdit;

    CComboBox                       m_DeviceCombo;
    CComboBox                       m_GroupCombo;

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};




#endif // _PP_FAXOUTBOUNDROUTINGRULE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxinboundroutingmethodgeneral.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxInboundRoutingMethodGeneral.h                     //
//                                                                         //
//  DESCRIPTION   : Fax Server Inbox prop page header file                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 15 1999 yossg  Created                                         //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include <proppageex.h>

#ifndef _PP_FAXINBOUNDROUTINGMETHOD_GENERAL_H_
#define _PP_FAXINBOUNDROUTINGMETHOD_GENERAL_H_



#include "InboundRoutingMethod.h"


class CFaxInboundRoutingMethodNode;    
/////////////////////////////////////////////////////////////////////////////
// CppFaxInboundRoutingMethod dialog

class CppFaxInboundRoutingMethod : public CPropertyPageExImpl<CppFaxInboundRoutingMethod>
{

public:
    //
    // Constructor
    //
    CppFaxInboundRoutingMethod(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           bOwnsNotificationHandle,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxInboundRoutingMethod();

	enum { IDD = IDD_FAXINMETHOD_GENERAL };

	BEGIN_MSG_MAP(CppFaxInboundRoutingMethod)
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )

        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxInboundRoutingMethod>)
	END_MSG_MAP()


    LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();


    HRESULT SetProps(int *pCtrlFocus);
    HRESULT PreApply(int *pCtrlFocus);

private:
    
    CComBSTR   m_buf;

    //
    // Handles
    //
    CFaxInboundRoutingMethodNode *   m_pParentNode;    
 
    LONG_PTR   m_lpNotifyHandle;

    
    LRESULT SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};




#endif // _PP_FAXINBOUNDROUTINGMETHOD_GENERAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxprovidergeneral.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CppFaxProviderGeneral.h                                //
//                                                                         //
//  DESCRIPTION   : provider's property page header file.                  //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan 31 2000 yossg  Created                                         //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXPROVIDERGENERAL_H_
#define _PP_FAXPROVIDERGENERAL_H_


#include "Provider.h"
#include "proppageex.h"

class CFaxProviderNode;    
/////////////////////////////////////////////////////////////////////////////
// CppFaxProvider dialog

class CppFaxProvider : public CPropertyPageExImpl<CppFaxProvider>
{

public:
    //
    // Constructor
    //
    CppFaxProvider(
             long           hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           bOwnsNotificationHandle,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxProvider();

	enum { IDD = IDD_FAXPROVIDER_GENERAL };

	BEGIN_MSG_MAP(CppFaxProvider)
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxProvider>)
	END_MSG_MAP()


    LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();

    HRESULT Init(CComBSTR bstrName, CComBSTR bstrStatus, CComBSTR bstrVersion, CComBSTR bstrPath);


private:
    
    //
    // Handles
    // 
    LONG_PTR     m_lpNotifyHandle;

    LRESULT      SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    //
    // Members
    //
    CComBSTR     m_bstrName;
    CComBSTR     m_bstrStatus;    
    CComBSTR     m_bstrVersion;
    CComBSTR     m_bstrPath;


    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};




#endif // _PP_FAXPROVIDERGENERAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxinboundroutingmethodgeneral.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxInboundRoutingMethodGeneral.cpp                   //
//                                                                         //
//  DESCRIPTION   : prop pages of Inbox archive                            //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 15 1999 yossg  Created                                         //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxInboundRoutingMethodGeneral.h"
#include "FaxMMCGlobals.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Constructor
//
CppFaxInboundRoutingMethod::CppFaxInboundRoutingMethod(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        bOwnsNotificationHandle,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxInboundRoutingMethod>(pNode, NULL)
			                	
{
    m_pParentNode      = NULL; //in case static-cast failed and wont change the pointer
    m_pParentNode      = static_cast <CFaxInboundRoutingMethodNode *> (pNode);

    m_lpNotifyHandle   = hNotificationHandle;
}

//
// Destructor
//
CppFaxInboundRoutingMethod::~CppFaxInboundRoutingMethod()
{
    // Note - This needs to be called only once per property sheet.  
    // In our convention called in the general tab.
    if (NULL != m_lpNotifyHandle)
    {
        MMCFreeNotifyHandle(m_lpNotifyHandle);
        m_lpNotifyHandle = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CppFaxInboundRoutingMethod message handlers


/*
 -  CppFaxInboundRoutingMethod::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxInboundRoutingMethod::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxInboundRoutingMethod::PageInitDialog"));
    
	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );
    
    ATLASSERT(NULL != m_pParentNode);

    //
    // Name
    //
    SetDlgItemText(IDC_INMETHOD_NAME_STATIC,   
                     m_pParentNode->GetName());

    //
    // Status
    //    
    UINT uiIDS = ( m_pParentNode->GetStatus() ? IDS_INMETHOD_ENABLE : IDS_INMETHOD_DISABLE);

    if ( !m_buf.LoadString(_Module.GetResourceInstance(), uiIDS) )
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to load string for status value."));
        //can not do nothing more here!
    }
    else
    {
        SetDlgItemText(IDC_INMETHOD_STATUS_STATIC, m_buf);
    }

    //
    // Extension
    //
    SetDlgItemText(IDC_INMETHOD_EXTENSION_STATIC, 
                     m_pParentNode->GetExtensionName());
    	
    return (1);

}

/*
 -  CppFaxInboundRoutingMethod::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxInboundRoutingMethod::SetProps(int *pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxInboundRoutingMethod::SetProps"));

    return (S_OK);
}

/*
 -  CppFaxInboundRoutingMethod::PreApply
 -
 *  Purpose:
 *      Checks properties before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxInboundRoutingMethod::PreApply(int *pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxInboundRoutingMethod::PreApply"));

    return(S_OK);
}


/*
 -  CppFaxInboundRoutingMethod::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxInboundRoutingMethod::OnApply()
{

    return TRUE;
}


/*
 -  CppFaxInboundRoutingMethod::SetApplyButton
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxInboundRoutingMethod::SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetModified(TRUE);  
    bHandled = TRUE;
    return(1);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxInboundRoutingMethod::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxInboundRoutingMethod::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxInboundRoutingMethod::OnHelpRequest"));
    
    HELPINFO* helpinfo;
    DWORD     dwHelpId;

    switch (uMsg) 
    { 
        case WM_HELP: 

            helpinfo = (HELPINFO*)lParam;
            if (helpinfo->iContextType == HELPINFO_WINDOW)
            {
                ::WinHelp(
                          (HWND) helpinfo->hItemHandle,
                          FXS_ADMIN_HLP_FILE, 
                          HELP_CONTEXTPOPUP, 
                          (DWORD) helpinfo->dwContextId 
                       ); 
            }
            break; 
 
        case WM_CONTEXTMENU: 
            
            dwHelpId = ::GetWindowContextHelpId((HWND)wParam);
            if (dwHelpId) 
            {
                ::WinHelp
                       (
                         (HWND)wParam,
                         FXS_ADMIN_HLP_FILE, 
                         HELP_CONTEXTPOPUP, 
                         dwHelpId
                       );
            }
            break; 
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxprovidergeneral.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CppFaxProviderGeneral.cpp                              //
//                                                                         //
//  DESCRIPTION   : prop pages of Catalog's Inbox Routing Method           //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan 31 2000 yossg  Created                                         //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxProviderGeneral.h"
#include "FaxMMCGlobals.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Constructor
//
CppFaxProvider::CppFaxProvider(
             long        hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        bOwnsNotificationHandle,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxProvider>(pNode, NULL)
			                	
{
    m_lpNotifyHandle = hNotificationHandle;
}

//
// Destructor
//
CppFaxProvider::~CppFaxProvider()
{
    // Note - This needs to be called only once per property sheet.  
    // In our convention called in the general tab.
    if (NULL != m_lpNotifyHandle)
    {
        MMCFreeNotifyHandle(m_lpNotifyHandle);
        m_lpNotifyHandle = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CppFaxProvider message handlers


/*
 -  CppFaxProvider::Init
 -
 *  Purpose:
 *      Initiates all members
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxProvider::Init(CComBSTR bstrName, CComBSTR bstrStatus, CComBSTR bstrVersion, CComBSTR bstrPath)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxProvider::Init"));
    HRESULT hRc = S_OK;

    m_bstrName = bstrName;
    if (!m_bstrName)
    {
		DebugPrintEx( DEBUG_ERR, _T("Null m_bstrName - out of memory."));
        goto Error;
    }
    
    m_bstrStatus = bstrStatus;
    if (!m_bstrStatus)
    {
		DebugPrintEx( DEBUG_ERR, _T("Null m_bstrStatus - out of memory."));
        goto Error;
    }
    
    m_bstrVersion = bstrVersion;
    if (!m_bstrVersion)
    {
		DebugPrintEx( DEBUG_ERR, _T("Null m_bstrVersion - out of memory."));
        goto Error;
    }
    
    m_bstrPath = bstrPath;
    if (!m_bstrPath)
    {
		DebugPrintEx( DEBUG_ERR, _T("Null m_bstrPath - out of memory."));
        goto Error;
    }
    
    goto Exit;

Error:
    hRc = E_OUTOFMEMORY;

Exit:
    return hRc;
}



/*
 -  CppFaxProvider::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxProvider::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxProvider::PageInitDialog"));
    
	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );
    
    //
    // Version
    //
    SetDlgItemText(IDC_FSPVERSION_EDIT, m_bstrVersion);
   	
    //
    // Status
    //
    SetDlgItemText(IDC_FSPSTATUS_EDIT, m_bstrStatus);
   	
    //
    // DLL's full path
    //
    SetDlgItemText(IDC_FSPVPATH_EDIT, m_bstrPath);
   	
   	
    return (1);

}


/*
 -  CppFaxProvider::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxProvider::OnApply()
{

    return TRUE;
}


/*
 -  CppFaxProvider::SetApplyButton
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxProvider::SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetModified(TRUE);  
    bHandled = TRUE;
    return(1);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxProvider::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxProvider::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxProvider::OnHelpRequest"));
    
    HELPINFO* helpinfo;
    DWORD     dwHelpId;

    switch (uMsg) 
    { 
        case WM_HELP: 

            helpinfo = (HELPINFO*)lParam;
            if (helpinfo->iContextType == HELPINFO_WINDOW)
            {
                ::WinHelp(
                          (HWND) helpinfo->hItemHandle,
                          FXS_ADMIN_HLP_FILE, 
                          HELP_CONTEXTPOPUP, 
                          (DWORD) helpinfo->dwContextId 
                       ); 
            }
            break; 
 
        case WM_CONTEXTMENU: 
            
            dwHelpId = ::GetWindowContextHelpId((HWND)wParam);
            if (dwHelpId) 
            {
                ::WinHelp
                       (
                         (HWND)wParam,
                         FXS_ADMIN_HLP_FILE, 
                         HELP_CONTEXTPOPUP, 
                         dwHelpId
                       );
            }
            break; 
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxserverevents.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerEvents.h                                    //
//                                                                         //
//  DESCRIPTION   : Fax Server Events prop page header file                //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 27 1999 yossg   created                                        //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXSERVER_EVENTS_H_
#define _PP_FAXSERVER_EVENTS_H_

#include <proppageex.h>

class CFaxServerNode;

/////////////////////////////////////////////////////////////////////////////
// CppFaxServerEvents dialog

class CppFaxServerEvents : public CPropertyPageExImpl<CppFaxServerEvents>
{

public:
    //
    // Constructor
    //
    CppFaxServerEvents(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           bOwnsNotificationHandle,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxServerEvents();

	enum { IDD = IDD_FAXSERVER_EVENTS };

	BEGIN_MSG_MAP(CppFaxServerEvents)
		MESSAGE_HANDLER( WM_INITDIALOG,  OnInitDialog )
		MESSAGE_HANDLER( WM_HSCROLL,     SliderMoved )
		
        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxServerEvents>)
	END_MSG_MAP()

	//
	// Dialog's Handler and events.
	//
	HRESULT InitRPC( );
	LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();


    HRESULT SetProps(int *pCtrlFocus);
    HRESULT PreApply(int *pCtrlFocus);
private:

    //
    // Control members
    //
    CTrackBarCtrl   m_InboundErrSlider;
    CTrackBarCtrl   m_OutboundErrSlider;
    CTrackBarCtrl   m_InitErrSlider;
    CTrackBarCtrl   m_GeneralErrSlider;

    //
    // Config Structure member
    //
    PFAX_LOG_CATEGORY  m_pFaxLogCategories;
    
    //
    // Handles and flags
    //
    CFaxServerNode *        m_pParentNode;    

    BOOL                    m_fIsDialogInitiated;
    BOOL                    m_fIsDirty;

    //
    // Event methods
    //
    LRESULT SliderMoved( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};


#endif // _PP_FAXSERVER_EVENTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxserverevents.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerEvents.cpp                                  //
//                                                                         //
//  DESCRIPTION   : prop pages of event reports  policies                  //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 25 1999 yossg  created                                         //
//      Nov 24 1999 yossg  OnApply create call to all tabs from parent     //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxServerEvents.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Constructor
//
CppFaxServerEvents::CppFaxServerEvents(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        bOwnsNotificationHandle,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxServerEvents>(pNode, NULL)

{
    m_pParentNode           = static_cast <CFaxServerNode *> (pNode);
    m_pFaxLogCategories     = NULL;

    m_fIsDialogInitiated    = FALSE;
    m_fIsDirty              = FALSE;
}								


//
// Destructor
//
CppFaxServerEvents::~CppFaxServerEvents()
{
    if (NULL != m_pFaxLogCategories)
    {
        FaxFreeBuffer( m_pFaxLogCategories);
    }
}

#define FXS_NUM_OF_CATEGORIES 4
/////////////////////////////////////////////////////////////////////////////
// CppFaxServerEvents message handlers

/*
 -  CppFaxServerEvents::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerEvents::InitRPC(  )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerEvents::InitRPC"));
    
    HRESULT    hRc = S_OK;
    DWORD      ec  = ERROR_SUCCESS;




    DWORD dwNumCategories;

    //
    // get RPC Handle
    //   


    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
	// Retrieve the fax Event Reports /Logging Policy configuration
	//
    if (!FaxGetLoggingCategories(m_pFaxServer->GetFaxServerHandle(), 
                           &m_pFaxLogCategories,
                           &dwNumCategories)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get Logging Categories configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	// for max verification
	ATLASSERT(m_pFaxLogCategories);

    // internal assumeption in this version
    ATLASSERT( FXS_NUM_OF_CATEGORIES == dwNumCategories);
	
    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get Logging Categories configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    m_pParentNode->NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}


/*
 -  CppFaxServerEvents::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxServerEvents::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerEvents::OnInitDialog"));
    
	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );

    int     iInboundLevel = 0,
            iOutboundLevel = 0,
            iInitLevel = 0,
            iGeneralLevel = 0;

    // Retrieve the Number of Categories
    const int iNumCategories = FXS_NUM_OF_CATEGORIES;

    int i;   // index

    //
    // Attach Controls
    //
    m_InitErrSlider.Attach(GetDlgItem(IDC_SLIDER4));
    m_InboundErrSlider.Attach(GetDlgItem(IDC_SLIDER2));
    m_OutboundErrSlider.Attach(GetDlgItem(IDC_SLIDER3));
    m_GeneralErrSlider.Attach(GetDlgItem(IDC_SLIDER1));
        
    //
    // Init sliders
    //
    m_InboundErrSlider.SetRange(0,FXS_MAX_LOG_REPORT_LEVEL - 1,TRUE);
    m_OutboundErrSlider.SetRange(0,FXS_MAX_LOG_REPORT_LEVEL - 1,TRUE);
    m_InitErrSlider.SetRange(0,FXS_MAX_LOG_REPORT_LEVEL - 1,TRUE);
    m_GeneralErrSlider.SetRange(0,FXS_MAX_LOG_REPORT_LEVEL - 1,TRUE);
    
    //
	// Verify the Number of Categories is the same 
    // as the code assumes (This version).
    // To avoid replacement of defined contant elsewhere
	//
    ATLASSERT (iNumCategories == 4);
        
    for (i = 0; i < iNumCategories; i++)
    {
        //for each category
        switch (m_pFaxLogCategories[i].Category)
        {
            case FAXLOG_CATEGORY_INIT:
                iInitLevel= m_pFaxLogCategories[i].Level;
                break;
            case FAXLOG_CATEGORY_OUTBOUND:
                iOutboundLevel= m_pFaxLogCategories[i].Level;
                break;
            case FAXLOG_CATEGORY_INBOUND:
                iInboundLevel= m_pFaxLogCategories[i].Level;
                break;
            case FAXLOG_CATEGORY_UNKNOWN:
                 iGeneralLevel= m_pFaxLogCategories[i].Level;
                break;
        }
    }
                
    //
    // Init slider Positions
    //
    m_InboundErrSlider.SetPos(iInboundLevel);
    m_OutboundErrSlider.SetPos(iOutboundLevel);
    m_InitErrSlider.SetPos(iInitLevel);
    m_GeneralErrSlider.SetPos(iGeneralLevel);

    m_fIsDialogInitiated = TRUE;

    return 1;
}

/*
 -  CppFaxServerEvents::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerEvents::SetProps(int *pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerEvents::SetProps"));
    HRESULT     hRc = S_OK;
    DWORD       ec  = ERROR_SUCCESS;



    int     iInboundErrPos, 
            iOutboundErrPos, 
            iInitErrPos, 
            iGeneralErrPos;

    FAX_LOG_CATEGORY  FaxLogCategories[FXS_NUM_OF_CATEGORIES];

    //
    // Our base assumption for this version
    //
    const int iNumCategories = FXS_NUM_OF_CATEGORIES;    
    ATLASSERT (iNumCategories == 4);

    //
    // init structures
    //
    ZeroMemory (&FaxLogCategories, sizeof(FAX_LOG_CATEGORY)*FXS_NUM_OF_CATEGORIES);

    //
    // Collect All Slider Positions
    //
    iInitErrPos     =  m_InitErrSlider.GetPos();
    iInboundErrPos  =  m_InboundErrSlider.GetPos();
    iOutboundErrPos =  m_OutboundErrSlider.GetPos();
    iGeneralErrPos  =  m_GeneralErrSlider.GetPos();

    //
    // Prepare all structure fields
	//
	// notice: legacy EnumLoggingChanges in the server's code depends on the order only!
    //         our code indentifies the categories by their unique id number - the Category DWORD field
    //
    FaxLogCategories[0].Name = L"Initialization/Termination"; //NOT to be localized a registry info only
    FaxLogCategories[0].Category = FAXLOG_CATEGORY_INIT;
    FaxLogCategories[0].Level = (DWORD)iInitErrPos;

    FaxLogCategories[1].Name = L"Outbound"; //NOT to be localized a registry info only
    FaxLogCategories[1].Category = FAXLOG_CATEGORY_OUTBOUND;
    FaxLogCategories[1].Level = (DWORD)iOutboundErrPos;

    FaxLogCategories[2].Name = L"Inbound";  //NOT to be localized a registry info only
    FaxLogCategories[2].Category = FAXLOG_CATEGORY_INBOUND;;
    FaxLogCategories[2].Level = (DWORD)iInboundErrPos;

    FaxLogCategories[3].Name = L"Unknown";  //NOT to be localized a registry info only
    FaxLogCategories[3].Category = FAXLOG_CATEGORY_UNKNOWN;
    FaxLogCategories[3].Level = (DWORD)iGeneralErrPos;

    //
    // get RPC Handle
    //   
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        goto Error;
    }

    //
    // Set Config
    //
    if (!FaxSetLoggingCategories(
                m_pFaxServer->GetFaxServerHandle(),
                FaxLogCategories, 
                (DWORD)iNumCategories)) 
	{		
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to Set Logging Categories. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }
        
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    m_fIsDirty = FALSE;

    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to set Logging Categories configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);

    PropSheet_SetCurSelByID( GetParent(), IDD);         

    ATLASSERT(::IsWindow(m_hWnd));
    PageError(GetFaxServerErrorMsg(ec),m_hWnd);

Exit:    
    return(hRc);
}


/*
 -  CppFaxServerEvents::PreApply
 -
 *  Purpose:
 *      Checks properties before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerEvents::PreApply(int *pCtrlFocus)
{
   return(S_OK);
}

/*
 -  CppFaxServerEvents::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxServerEvents::OnApply()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerEvents::OnApply"));

    HRESULT  hRc  = S_OK;
    int     CtrlFocus = 0;

    if (!m_fIsDirty)
    {
        return TRUE;
    }

    hRc = SetProps(&CtrlFocus);
    if (FAILED(hRc)) 
    {
        //Error Msg by called func.
        if (CtrlFocus)
        {
            GotoDlgCtrl(GetDlgItem(CtrlFocus));
        }
        return FALSE;
    }
    else //(Succeeded(hRc))
    {
        return TRUE;
    }

}

/*
 -  CppFaxServerEvents::SliderMoved
 -
 *  Purpose:
 *      set Apply buttom modified.
 *  Arguments:
 *      IN pParentNode - parent node pointer
 *
 *  Return:
 *      none
 */
LRESULT CppFaxServerEvents::SliderMoved ( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    SetModified(TRUE);  
    fHandled = TRUE;
    return(1);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxServerEvents::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxServerEvents::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxServerEvents::OnHelpRequest"));
    
    HELPINFO* helpinfo;
    DWORD     dwHelpId;

    switch (uMsg) 
    { 
        case WM_HELP: 

            helpinfo = (HELPINFO*)lParam;
            if (helpinfo->iContextType == HELPINFO_WINDOW)
            {
                ::WinHelp(
                          (HWND) helpinfo->hItemHandle,
                          FXS_ADMIN_HLP_FILE, 
                          HELP_CONTEXTPOPUP, 
                          (DWORD) helpinfo->dwContextId 
                       ); 
            }
            break; 
 
        case WM_CONTEXTMENU: 
            
            dwHelpId = ::GetWindowContextHelpId((HWND)wParam);
            if (dwHelpId) 
            {
                ::WinHelp
                       (
                         (HWND)wParam,
                         FXS_ADMIN_HLP_FILE, 
                         HELP_CONTEXTPOPUP, 
                         dwHelpId
                       );
            }
            break; 
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxoutboundroutingrule.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxOutboundRoutingRule.cpp                           //
//                                                                         //
//  DESCRIPTION   : prop pages of Outbound Routing Methods                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan  9 2000 yossg  Created                                         //
//      Jan 25 2000 yossg  Change the Dialog Design                        //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxOutboundRoutingRule.h"
#include "DlgSelectCountry.h"
#include "FaxMMCGlobals.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "dlgutils.h"
#include "FaxMMCPropertyChange.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Constructor
//
CppFaxOutboundRoutingRule::CppFaxOutboundRoutingRule(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        bOwnsNotificationHandle,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxOutboundRoutingRule>(pNode,NULL)
			                	
{
    m_lpNotifyHandle   = hNotificationHandle;

    m_pFaxDevicesConfig = NULL;
    m_dwNumOfDevices    = 0;

    m_pFaxGroupsConfig  = NULL;
    m_dwNumOfGroups     = 0;

    m_fAllReadyToApply  = FALSE;

    m_dwCountryCode     = 0;
    m_dwAreaCode        = 0;
    m_dwDeviceID        = 0;
    m_bstrGroupName     = L"";

    m_fIsDialogInitiated = FALSE;
    m_fIsDirty          = FALSE;

}

//
// Destructor
//
CppFaxOutboundRoutingRule::~CppFaxOutboundRoutingRule()
{
    if (NULL != m_pFaxDevicesConfig)
        FaxFreeBuffer(m_pFaxDevicesConfig);

    if (NULL != m_pFaxGroupsConfig)
        FaxFreeBuffer(m_pFaxGroupsConfig);
    
    // Note - This needs to be called only once per property sheet.  
    // In our convention called in the general tab.
    if (NULL != m_lpNotifyHandle)
    {
        MMCFreeNotifyHandle(m_lpNotifyHandle);
        m_lpNotifyHandle = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CppFaxOutboundRoutingRule message handlers


/*
 -  CppFaxOutboundRoutingRule::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxOutboundRoutingRule::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::PageInitDialog"));
    
	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );
    
    HRESULT hRc = S_OK;

    int k, l;
    k = l = 0;
    
    const int   iAllDevicesComboIndex     = 0;
    int         iAllDevicesRPCIndex       = 0;
    int         iGroupListIndexToSelect   = 0;
    
    HINSTANCE hInst = _Module.GetResourceInstance();
    PFAX_TAPI_LINECOUNTRY_ENTRYW pCountryEntries = NULL;

    WCHAR buf[FXS_MAX_TITLE_LEN+1];

    WCHAR buffAreaCode[FXS_MAX_AREACODE_LEN+1];
    int iCount;

    //
    // Attach controls
    //
    m_CountryCodeEdit.Attach(GetDlgItem(IDC_RULE_COUNTRYCODE_EDIT1));
    m_AreaCodeEdit.Attach(GetDlgItem(IDC_RULE_AREACODE_EDIT1));

    m_DeviceCombo.Attach(GetDlgItem(IDC_DEVICES4RULE_COMBO1));
    m_GroupCombo.Attach(GetDlgItem(IDC_GROUP4RULE_COMBO1));
        
    //
    // Set length limit to area code
    //
    m_CountryCodeEdit.SetLimitText(FXS_MAX_COUNTRYCODE_LEN -1);
    m_AreaCodeEdit.SetLimitText(FXS_MAX_AREACODE_LEN -1);

    //
    // Step 1: Init Lists
    //
    
    //
    // Init Country code edit box (below)
    //

    //
    // Init Devices
    //
    for (k = 0; (DWORD)k < m_dwNumOfDevices; k++ )
    {   
        hRc = AddComboBoxItem ( m_DeviceCombo, 
                                m_pFaxDevicesConfig[k].lpctstrDeviceName, 
                                m_pFaxDevicesConfig[k].dwDeviceID,
                                hInst);
        if (FAILED(hRc))
        {
		    DebugPrintEx(
			    DEBUG_ERR, _T("Fail to load device list."));
            PageError(IDS_FAIL2LOADDEVICELIST, m_hWnd, hInst);
            ::EnableWindow(GetDlgItem(IDC_DEVICES4RULE_COMBO1), FALSE);
            goto Cleanup;
        }

    }
        
    //
    // Init groups
    //
    for (l = 0; (DWORD)l < m_dwNumOfGroups; l++ )
    {   
        if ( 0 == wcscmp(ROUTING_GROUP_ALL_DEVICES, m_pFaxGroupsConfig[l].lpctstrGroupName))
        {
            iAllDevicesRPCIndex = l;
            //Do not do any more;
		}
        else
		{
			hRc = AddComboBoxItem ( m_GroupCombo, 
									m_pFaxGroupsConfig[l].lpctstrGroupName, 
									(DWORD)l,
									hInst);
			if (FAILED(hRc))
			{
		        DebugPrintEx( DEBUG_ERR, _T("Fail to load group list."));
				PageError(IDS_FAIL2LOADDEVICELIST, m_hWnd, hInst);
                ::EnableWindow(GetDlgItem(IDC_GROUP4RULE_COMBO), FALSE);
				goto Cleanup;
			}
		}

        //
        // Moreover we'll pick the the index of selected group
        //
        if ( m_fIsGroup)
        {
            if ( 0 == wcscmp( m_bstrGroupName, m_pFaxGroupsConfig[l].lpctstrGroupName))
            {
                iGroupListIndexToSelect = l;
            }
        }
    }
    if (!LoadString(hInst, IDS_ALL_DEVICES, buf, FXS_MAX_DISPLAY_NAME_LEN))
    {
        hRc = E_OUTOFMEMORY;
		DebugPrintEx( DEBUG_ERR, _T("Fail to load string. Out of memory."));
        PageError(IDS_FAXOUTOFMEMORY, m_hWnd, hInst);
        goto Cleanup;
    }
    //
    // insert "All Devices" Group as the first one in the groups list
    //
    ATLASSERT( 0 == iAllDevicesComboIndex );
    hRc = SetComboBoxItem ( m_GroupCombo, 
                            iAllDevicesComboIndex, 
                            buf, 
                            iAllDevicesRPCIndex,
                            hInst);
    if (FAILED(hRc))
    {
		DebugPrintEx( DEBUG_ERR, _T("Fail to load group list."));
        PageError(IDS_FAIL2LOADGROUPLIST, m_hWnd, hInst);
        ::EnableWindow(GetDlgItem(IDC_GROUP4RULE_COMBO), FALSE);
        goto Cleanup;
    }


    //
    // Step 2: Set current status 
    //          (Select items in Lists, select radio button etc.)
    //          (Gray/UnGray controls)
    //

    //
    // Select Country in the list
    //
    if (ROUTING_RULE_COUNTRY_CODE_ANY != m_dwCountryCode)
    {
        int         iCountSring      =    0;
        WCHAR       szwCountryCode[FXS_MAX_COUNTRYCODE_LEN+1];

        iCountSring = swprintf(szwCountryCode, L"%ld", m_dwCountryCode);
        if( iCountSring <= 0 )
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to read member - m_dwCountryCode."));
            
            PageError(IDS_MEMORY, m_hWnd, hInst);
            
            goto Cleanup;
        }
        m_CountryCodeEdit.SetWindowText(szwCountryCode);

        if (ROUTING_RULE_AREA_CODE_ANY == m_dwAreaCode)
        {
            CheckDlgButton(IDC_COUNTRY_RADIO1, BST_CHECKED);
            ::EnableWindow(GetDlgItem(IDC_RULE_AREACODE_EDIT1), FALSE);
        }
        else
        {
            CheckDlgButton(IDC_AREA_RADIO1, BST_CHECKED);

            //
            // Set Area Code
            //
            iCount = swprintf(buffAreaCode,
                L"%ld", m_dwAreaCode);

            ATLASSERT(iCount > 0);
            if( iCount > 0 )
            {
                m_AreaCodeEdit.SetWindowText(buffAreaCode);
            }        
        }  

    }
    else //m_dwCountryCode == ROUTING_RULE_COUNTRY_CODE_ANY 
    {
        ::EnableWindow(GetDlgItem(IDC_RULETYPE_FSTATIC), FALSE);
        ::EnableWindow(GetDlgItem(IDC_COUNTRY1_STATIC), FALSE);
        ::EnableWindow(GetDlgItem(IDC_AREA_STATIC), FALSE);
        ::EnableWindow(GetDlgItem(IDC_RULE_AREACODE_EDIT1), FALSE);
        ::EnableWindow(GetDlgItem(IDC_RULE_SELECT_BUTTON1), FALSE);
        ::EnableWindow(GetDlgItem(IDC_RULE_COUNTRYCODE_EDIT1), FALSE);
        ::EnableWindow(GetDlgItem(IDC_COUNTRY_RADIO1), FALSE);
        ::EnableWindow(GetDlgItem(IDC_AREA_RADIO1), FALSE);
    }


    if (!m_fIsGroup)
    {
        CheckDlgButton(IDC_DESTINATION_RADIO11, BST_CHECKED);
        
        //
        // Select device in the list
        //
        hRc = SelectComboBoxItemData(m_DeviceCombo, m_dwDeviceID);
        if ( FAILED(hRc))
        {
		    DebugPrintEx( DEBUG_ERR, _T("Fail to select device in combo box."));
            PageError(IDS_FAIL2LOADDEVICELIST, m_hWnd, hInst);
            ::EnableWindow(GetDlgItem(IDC_DEVICES4RULE_COMBO1), FALSE);
            
            goto Cleanup;
        }
        
        ::EnableWindow(GetDlgItem(IDC_GROUP4RULE_COMBO1), FALSE);
    }
    else
    {
        CheckDlgButton(IDC_DESTINATION_RADIO21, BST_CHECKED) ;
        
        //
        // Select Group in list
        //
        hRc = SelectComboBoxItemData(m_GroupCombo, iGroupListIndexToSelect);
        if ( FAILED(hRc))
        {
            DebugPrintEx( DEBUG_ERR, _T("Fail to select group in combo box."));
            PageError(IDS_FAIL2LOADGROUPLIST, m_hWnd, hInst);
            ::EnableWindow(GetDlgItem(IDC_DEVICES4RULE_COMBO1), FALSE);
            
            goto Cleanup;
        }
        
        ::EnableWindow(GetDlgItem(IDC_DEVICES4RULE_COMBO1), FALSE);
        
    }  
    
    ATLASSERT(S_OK == hRc);
    m_fIsDialogInitiated = TRUE;        

Cleanup:

    return (1);

}

/*
 -  CppFaxOutboundRoutingRule::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxOutboundRoutingRule::SetProps(int *pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::SetProps"));

    HRESULT       hRc                  = S_OK;
    DWORD         ec                   = ERROR_SUCCESS;

    CComBSTR      bstrAreaCode;
    int           iCurrentSelectedItem = 0;
    
    DWORD         dwAreaCode           = 0;
    DWORD         dwCountryCode        = 0;

    BOOL          bUseGroup;
    DWORD         dwDeviceID           = 0;
    WCHAR         lpszGroupName[MAX_ROUTING_GROUP_NAME];
    
    LPCTSTR       lpctstrGroupName     = NULL;

    HINSTANCE     hInst;
    hInst = _Module.GetResourceInstance();
    
    CFaxRulePropertyChangeNotification * pRulePropPageNotification = NULL;
    CComBSTR bstrCountryName;
    
    //
    // Step 0: PreApply Checks
    //
    m_fAllReadyToApply = FALSE;
    if (!AllReadyToApply( FALSE))
    {
        SetModified(FALSE);  
        hRc = E_FAIL;
        goto Exit;
    }

    //
    // Step 1: get data
    //
    if (ROUTING_RULE_COUNTRY_CODE_ANY != m_dwCountryCode)
    {
        //
        // Country Code
        //

        CComBSTR bstrCountryCode;

        if ( !m_CountryCodeEdit.GetWindowText(&bstrCountryCode))
        {
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&bstrCountryCode)"));
            DlgMsgBox(this, IDS_FAIL2READ_COUNTRYCODE);
            ::SetFocus(GetDlgItem(IDC_RULE_COUNTRYCODE_EDIT));
            hRc = S_FALSE;
        
            goto Exit;
        }
        dwCountryCode = (DWORD)wcstoul( bstrCountryCode, NULL, 10 );

        if (ROUTING_RULE_COUNTRY_CODE_ANY == dwCountryCode)
        {
            //
            // The user try to replace the country code to zero
            //
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT(" CountryCode == ROUTING_RULE_COUNTRY_CODE_ANY "));
            DlgMsgBox(this, IDS_ZERO_COUNTRYCODE);
            ::SetFocus(GetDlgItem(IDC_RULE_COUNTRYCODE_EDIT));
            hRc = S_FALSE;
        
            goto Exit;
        }

        //
        // Area Code
        //
        if ( IsDlgButtonChecked(IDC_COUNTRY_RADIO1) == BST_CHECKED )
        {
            dwAreaCode = (DWORD)ROUTING_RULE_AREA_CODE_ANY;        
        }
        else // IsDlgButtonChecked(IDC_AREA_RADIO1) == BST_CHECKED
        {	
            if ( !m_AreaCodeEdit.GetWindowText(&bstrAreaCode))
            {
		        DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Failed to GetWindowText(&bstrAreaCode)"));
                PageError(IDS_FAIL2READ_AREACODE, m_hWnd, hInst);
                ::SetFocus(GetDlgItem(IDC_RULE_AREACODE_EDIT1));
                hRc = E_FAIL ;
            
                goto Exit;
            }
            dwAreaCode = (DWORD)wcstoul( bstrAreaCode, NULL, 10 );
        }
        ATLASSERT(bstrCountryName);
    }
  
    if ( IsDlgButtonChecked(IDC_DESTINATION_RADIO11) == BST_CHECKED )
    {
        //
        // Use Group ?
        //
        bUseGroup = FALSE;
        
        //
        // Device
        //
        iCurrentSelectedItem = m_DeviceCombo.GetCurSel();
        ATLASSERT(iCurrentSelectedItem != CB_ERR); //should be chacked pre apply         
        dwDeviceID =  (DWORD)m_DeviceCombo.GetItemData (iCurrentSelectedItem);

    }
    else // IsDlgButtonChecked(IDC_DESTINATION_RADIO21) == BST_CHECKED
    {	
        //
        // Use Group ?
        //
        bUseGroup = TRUE;
 
        //
        // Group
        //
        
        iCurrentSelectedItem = m_GroupCombo.GetCurSel();
        //ATLASSERT(iCurrentSelectedItem != CB_ERR); //should be chacked pre apply        

        if (0 == iCurrentSelectedItem) //All Devices
        {
            lpctstrGroupName = ROUTING_GROUP_ALL_DEVICES;
        }
        else
        {
            ATLASSERT(MAX_ROUTING_GROUP_NAME > m_GroupCombo.GetLBTextLen(iCurrentSelectedItem)); //should be chacked by service before        
        
            m_GroupCombo.GetLBText( iCurrentSelectedItem, lpszGroupName );
            lpctstrGroupName = (LPCTSTR)lpszGroupName;
        }

    }

    
    //
    // Step 2: Configure Rule via RPC call
    //

    if (   
           (dwAreaCode != m_dwAreaCode) 
        || 
           (dwCountryCode != m_dwCountryCode)
       )
    {
        hRc = FaxReplaceRule(
                        dwAreaCode,       
                        dwCountryCode,    
                        bUseGroup,        
                        dwDeviceID,       
	                    lpctstrGroupName  
                        );
        if (FAILED(hRc))
        {
            //DebugPrint and MsgBox by called func.
            goto Exit;
        }
        else
        {
            m_dwAreaCode = dwAreaCode;
            m_dwCountryCode = dwCountryCode;
        }
    }
    else
    {
        //
        //(dwAreaCode == m_dwAreaCode) && 
        //(dwCountryCode == m_dwCountryCode)
        //
        hRc = FaxConfigureRule(
                        bUseGroup,       
                        dwDeviceID,
	                    lpctstrGroupName 
                        );
        if (FAILED(hRc))
        {
            //DebugPrint and MsgBox by called func.
            goto Exit;
        }
    }
    
        
    //
    // Step 3: Send notification to cause MMC view refresh  
    //	                      
   
    //
    // Prepare the notification fields before submit
    //
    pRulePropPageNotification = new CFaxRulePropertyChangeNotification();
    if (!pRulePropPageNotification)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx( DEBUG_ERR, _T("Out of Memory - fail to operate new"));

        goto Error;
    }

    pRulePropPageNotification->dwAreaCode = dwAreaCode;
    pRulePropPageNotification->dwCountryCode = dwCountryCode;
    pRulePropPageNotification->bstrCountryName = bstrCountryName;
    if (!pRulePropPageNotification->bstrCountryName)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx( DEBUG_ERR, _T("Out of Memory - fail to load string."));

        goto Error;
    }
    
    pRulePropPageNotification->fIsGroup = bUseGroup;
    if (pRulePropPageNotification->fIsGroup)
    {
        pRulePropPageNotification->bstrGroupName = lpctstrGroupName;
        if (!pRulePropPageNotification->bstrGroupName)
        {
            ec = ERROR_NOT_ENOUGH_MEMORY;
            DebugPrintEx( DEBUG_ERR, _T("Out of Memory - fail to load string."));

            goto Error;
        }
    }
    else
    {
        pRulePropPageNotification->dwDeviceID = dwDeviceID;
    }

    pRulePropPageNotification->pItem = (CSnapInItem *)m_pParentNode;
    pRulePropPageNotification->enumType = RuleFaxPropNotification;

    //
    // Notify MMC console thread
    //
    hRc = MMCPropertyChangeNotify(m_lpNotifyHandle, reinterpret_cast<LPARAM>(pRulePropPageNotification));
    if (FAILED(hRc))
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to call MMCPropertyChangeNotify. (hRc: %08X)"), 
			hRc);
        
        ATLASSERT(NULL != m_pParentNode);
        PageError(IDS_FAIL_NOTIFY_MMCPROPCHANGE,m_hWnd);
        
        goto Exit;
    }

    //
    // To prevent deletion on error since it will be deleted 
    // by the reciever of the notification.
    //
    pRulePropPageNotification =  NULL; 
        
    ATLASSERT(S_OK == hRc && ERROR_SUCCESS == ec);
    
    m_fIsDirty = FALSE;    
    
    DebugPrintEx( DEBUG_MSG,
		_T("The rule was added successfully."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);

    PropSheet_SetCurSelByID( GetParent(), IDD);         

    ATLASSERT(::IsWindow(m_hWnd));
    PageError(GetFaxServerErrorMsg(ec),m_hWnd);

    if (pRulePropPageNotification)
    {
        delete pRulePropPageNotification;
        pRulePropPageNotification = NULL;
    }

Exit:    
    return(hRc);
}

/*
 -  CppFaxOutboundRoutingRule::PreApply
 -
 *  Purpose:
 *      Checks properties before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxOutboundRoutingRule::PreApply(int *pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::PreApply"));
    HRESULT  hRc  = S_OK;

    //
    // PreApply Checks
    //
    m_fAllReadyToApply = FALSE;
    if (!AllReadyToApply(/*fSilent =*/ FALSE))
    {
        SetModified(FALSE);  
        hRc = E_FAIL ;
    }
    else
    {
        SetModified(TRUE);  
    }

    return(hRc);
}


/*
 -  CppFaxOutboundRoutingRule::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxOutboundRoutingRule::OnApply()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::OnApply"));
    HRESULT  hRc  = S_OK;
    int     CtrlFocus = 0;
        
    if (!m_fIsDirty)
    {
        return TRUE;
    }

    hRc = PreApply(&CtrlFocus);
    if (FAILED(hRc))
    {
        //Error Msg by called func.
        if (CtrlFocus)
        {
            GotoDlgCtrl(GetDlgItem(CtrlFocus));
        }
        return FALSE;
    }
    else //(Succeeded(hRc))
    {
        hRc = SetProps(&CtrlFocus);
        if (FAILED(hRc)) 
        {
            //Error Msg by called func.
            if (CtrlFocus)
            {
                GotoDlgCtrl(GetDlgItem(CtrlFocus));
            }
            return FALSE;
        }
        else //(Succeeded(hRc))
        {
            return TRUE;
        }
    }
}


/*
 -  CppFaxOutboundRoutingRule::SetApplyButton
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1 (0)
 */
LRESULT CppFaxOutboundRoutingRule::SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
      
    m_fIsDirty = TRUE;
    SetModified(TRUE);  
    bHandled = TRUE;
    
    return(1);
}

/*
 -  CppFaxOutboundRoutingRule::OnDestenationRadioClicked
 -
 *  Purpose:
 *      Gray/Ungray the folder edit box and the
 *      browse button. Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxOutboundRoutingRule::OnDestenationRadioClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;


    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    State = ( IsDlgButtonChecked(IDC_DESTINATION_RADIO11) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_DEVICES4RULE_COMBO1), State);    
    
    ATLASSERT(!State == (IsDlgButtonChecked(IDC_DESTINATION_RADIO21) == BST_CHECKED)); 
    ::EnableWindow(GetDlgItem(IDC_GROUP4RULE_COMBO1), !State);    

    if (State)//IsDlgButtonChecked(IDC_DESTINATION_RADIO11) == BST_CHECKED
    {
        if ( CB_ERR  ==  m_DeviceCombo.GetCurSel())
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);  
			goto Exit;
		}
		//else continue to whole controls check
    }
	else //IsDlgButtonChecked(IDC_DESTINATION_RADIO21) == BST_CHECKED
    {
		if ( CB_ERR  ==  m_GroupCombo.GetCurSel())
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);  
			goto Exit;
		}
		//else continue to whole controls check
    }

    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
		else
		{
			//Should be EnableOK(FALSE);
		}
    }
Exit:
    return(1);
}

/*
 -  CppFaxOutboundRoutingRule::OnRuleTypeRadioClicked
 -
 *  Purpose:
 *      Gray/Ungray the folder edit box and the
 *      browse button. Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxOutboundRoutingRule::OnRuleTypeRadioClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;


    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    State = ( IsDlgButtonChecked(IDC_COUNTRY_RADIO1) == BST_CHECKED );
    
    ATLASSERT(!State == ( IsDlgButtonChecked(IDC_AREA_RADIO1) == BST_CHECKED ) ); 
    ::EnableWindow(GetDlgItem(IDC_RULE_AREACODE_EDIT1), !State);    

    if (!State)//IsDlgButtonChecked(IDC_AREA_RADIO1) == BST_CHECKED
    {
        if ( !m_AreaCodeEdit.GetWindowTextLength() )
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);  
			goto Exit;
        }
		//else continue to whole controls check
    }
	//else //IsDlgButtonChecked(IDC_COUNTRY_RADIO1) == BST_CHECKED
    //Do noting - continue to whole controls check

    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

Exit:
    return(1);
}


/*
 -  CppFaxOutboundRoutingRule::OnComboChanged
 -
 *  Purpose:
 *      Gray/Ungray the submit button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT 
CppFaxOutboundRoutingRule::OnComboChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::OnComboChanged"));


    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return 0;
}

/*
 -  CppFaxOutboundRoutingRule::OnTextChanged
 -
 *  Purpose:
 *      Enable/Disable the submit button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CppFaxOutboundRoutingRule::OnTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::OnTextChanged"));

    UINT fEnableOK = 0;
	

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    switch (wID)
	{
		case IDC_RULE_AREACODE_EDIT1:
			fEnableOK = ( m_AreaCodeEdit.GetWindowTextLength() );
			break;

		case IDC_RULE_COUNTRYCODE_EDIT1:
			fEnableOK = ( m_CountryCodeEdit.GetWindowTextLength() );

			break;

		default:
			ATLASSERT(FALSE);
	}
                    
    if(!!fEnableOK)
    {
        if (!m_fAllReadyToApply)
        {
            if (AllReadyToApply(TRUE))
            {
                m_fAllReadyToApply = TRUE;
                SetModified(TRUE);  
            }
        }
    }
    else
    {
        SetModified(FALSE);  
        m_fAllReadyToApply = FALSE;
    }

    return 0;
}

BOOL 
CppFaxOutboundRoutingRule::AllReadyToApply(BOOL fSilent)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::AllReadyToApply"));
	
    HINSTANCE     hInst;
    hInst = _Module.GetResourceInstance();

    if (ROUTING_RULE_COUNTRY_CODE_ANY != m_dwCountryCode)
    {
        if ( !m_CountryCodeEdit.GetWindowTextLength() )
        {
            if (!fSilent)
            {
                PageError(IDS_ZERO_COUNTRYCODE, m_hWnd, hInst);
                ::SetFocus(GetDlgItem(IDC_NEWRULE_COUNTRYCODE_EDIT));
            }
            return FALSE;
        }
        
        if ( IsDlgButtonChecked(IDC_AREA_RADIO1) == BST_CHECKED )
        {
            if ( !m_AreaCodeEdit.GetWindowTextLength() )
            {
                if (!fSilent)
                {
                    PageError(IDS_EMPTY_AREACODE, m_hWnd, hInst);
                    ::SetFocus(GetDlgItem(IDC_RULE_AREACODE_EDIT1));
                }
                return FALSE;    
            }
        }
        //else - Do noting
    }

    if ( IsDlgButtonChecked(IDC_DESTINATION_RADIO11) == BST_CHECKED )
    {
        if ( CB_ERR  ==  m_DeviceCombo.GetCurSel())
        {
            if (!fSilent)
            {
                PageError(IDS_PLEASESELECT_DEVICE, m_hWnd, hInst);
                ::SetFocus(GetDlgItem(IDC_DEVICES4RULE_COMBO1));
            }
            return FALSE;
        }
    }
    else if ( CB_ERR  ==  m_GroupCombo.GetCurSel())
    {
        if (!fSilent)
        {
            PageError(IDS_PLEASESELECT_GROUP, m_hWnd, hInst);
            ::SetFocus(GetDlgItem(IDC_GROUP4RULE_COMBO1));
        }
        return FALSE;
    }

    //
	// Cheers! 
	//		...every thing ready to apply now.
	//
	return TRUE;           
}


HRESULT CppFaxOutboundRoutingRule::InitFaxRulePP(CFaxOutboundRoutingRuleNode * pParentNode)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::InitFaxRulePP"));
    HRESULT      hRc        = S_OK; 
    DWORD        ec         = ERROR_SUCCESS;

    //
    // Step 0: Init Parent
    //
    m_pParentNode = pParentNode;
    
    
    //
    // Step 1: Init Lists from RPC
    //
    
    
    //
    // get Fax Handle
    //   

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }
    
    //
    // Devices (id, name)
    //
    if (!FaxEnumPortsEx(m_pFaxServer->GetFaxServerHandle(), 
                        &m_pFaxDevicesConfig,
                        &m_dwNumOfDevices)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get devices configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	ATLASSERT(m_pFaxDevicesConfig);


    //
    // Groups (names)
    //
    if (!FaxEnumOutboundGroups(m_pFaxServer->GetFaxServerHandle(), 
                        &m_pFaxGroupsConfig,
                        &m_dwNumOfGroups)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get groups configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	ATLASSERT(m_pFaxGroupsConfig);


    //
    // Step 2 : Init members from parent
    //

    ATLASSERT(m_pParentNode);
    
    m_dwCountryCode = m_pParentNode->GetCountryCode();
    m_dwAreaCode    = m_pParentNode->GetAreaCode();
    m_fIsGroup      = m_pParentNode->GetIsGroup();
    
    if (m_fIsGroup)
    {
        m_bstrGroupName = m_pParentNode->GetGroupName();
        if (!m_bstrGroupName)
        {
            hRc = E_OUTOFMEMORY;
            goto Error;
        }
    }
    else
    {
        m_dwDeviceID = m_pParentNode->GetDeviceID();
    }


    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get all configurations."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
    
    //MsgBox will be done by calling Func.

Exit:
    return hRc;
}


/*
 -  CppFaxOutboundRoutingRule::FaxConfigureRule
 -
 *  Purpose:
 *      Configure the rule's device or group.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
HRESULT CppFaxOutboundRoutingRule::FaxConfigureRule(
                        BOOL fNewUseGroup,       
                        DWORD dwNewDeviceID,
	                    LPCTSTR lpctstrNewGroupName)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::FaxConfigureRule"));
    HRESULT      hRc          = S_OK; 
    DWORD        ec           = ERROR_SUCCESS;
    BOOL         fSkipMessage = FALSE;

    FAX_OUTBOUND_ROUTING_RULE     FaxRuleConfig;
    
    //
    // Collect all data and init the structure's fields 
    // uses Copy() to copy and also allocate before
    //
    ZeroMemory (&FaxRuleConfig, sizeof(FAX_OUTBOUND_ROUTING_RULE));

    //
    // Init the needed fields
    //
    FaxRuleConfig.dwSizeOfStruct = sizeof(FAX_OUTBOUND_ROUTING_RULE);

    FaxRuleConfig.dwAreaCode = m_dwAreaCode;
    FaxRuleConfig.dwCountryCode = m_dwCountryCode;

    FaxRuleConfig.bUseGroup = fNewUseGroup;
    if (fNewUseGroup)
    {
        FaxRuleConfig.Destination.lpcstrGroupName = lpctstrNewGroupName;
    }
    else
    {
        FaxRuleConfig.Destination.dwDeviceId = dwNewDeviceID;
    }

    //
    // get RPC Handle
    //   

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        
        goto Error;
    }

    //
    // Configure the rule
    //
    if (!FaxSetOutboundRule (
	        m_pFaxServer->GetFaxServerHandle(),
	        &FaxRuleConfig))
    {
        ec = GetLastError();
        
        // specific
        if (FAX_ERR_BAD_GROUP_CONFIGURATION == ec)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("The group is empty or none of group devices is valid. (ec: %ld)"), 
			    ec);
            
            PageError(IDS_BAD_GROUP_CONFIGURATION, m_hWnd);
            fSkipMessage = TRUE;

            goto Error; 
        }
        
        //general
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to set rule %ld:%ld. (ec: %ld)"), 
			m_dwCountryCode, m_dwAreaCode, ec);
        
        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
    
    ATLASSERT(S_OK == hRc && ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("The rule was configured successfully."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
    
    if (!fSkipMessage)
    {
        PageError(GetFaxServerErrorMsg(ec),m_hWnd);
    }

Exit:    
    return(hRc);
}

/*
 -  CppFaxOutboundRoutingRule::FaxReplaceRule
 -
 *  Purpose:
 *      Configure the rule's device or group.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
HRESULT CppFaxOutboundRoutingRule::FaxReplaceRule(
                        DWORD   dwNewAreaCode,
                        DWORD   dwNewCountryCode,
                        BOOL    fNewUseGroup,       
                        DWORD   dwNewDeviceID,
	                    LPCTSTR lpctstrNewGroupName)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::FaxReplaceRule"));
    HRESULT      hRc        = S_OK; 
    DWORD        ec         = ERROR_SUCCESS;
    BOOL         fSkipMessage = FALSE;

    //
    // get RPC Handle
    //   
    
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Add the rule
    //
    if (!FaxAddOutboundRule (
	        m_pFaxServer->GetFaxServerHandle(),
	        dwNewAreaCode,
	        dwNewCountryCode,
	        dwNewDeviceID,
	        lpctstrNewGroupName,
	        fNewUseGroup))
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to add rule %ld:%ld. (ec: %ld)"), 
			m_dwCountryCode, m_dwAreaCode, ec);

        if (ERROR_DUP_NAME == ec) 
        {            
            DlgMsgBox(this, IDS_OUTRULE_EXISTS);
            goto Exit;
        }

        if (FAX_ERR_BAD_GROUP_CONFIGURATION == ec)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("The group is empty or none of group devices is valid. (ec: %ld)"), 
			    ec);
            
            PageError(IDS_BAD_GROUP_CONFIGURATION, m_hWnd);
            fSkipMessage = TRUE;

            goto Error; 
        }

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }

    ATLASSERT(S_OK == hRc && ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Step 1 - The new rule was added successfully."));
    
    if (!FaxRemoveOutboundRule (
	        m_pFaxServer->GetFaxServerHandle(),
	        m_dwAreaCode,
	        m_dwCountryCode))
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to remove rule. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
    ATLASSERT(S_OK == hRc && ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Step 2 - The old rule was removed successfully."));
    
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
    if (!fSkipMessage)
    {
        PageError(GetFaxServerErrorMsg(ec),m_hWnd);
    }

Exit:    
    return(hRc);
}

/*
 -  CppFaxOutboundRoutingRule::OnSelectCountryCodeClicked
 -
 *  Purpose:
 *      
 *
 *  Arguments:
 *      [out]   bHandled - Do we handle it?
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */
LRESULT
CppFaxOutboundRoutingRule::OnSelectCountryCodeClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)//(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxOutboundRoutingRule::OnSelectCountryCodeClicked"));
    HRESULT     hRc         =    S_OK;
    INT_PTR     rc          =    IDOK;

    int         iCount      =    0;
    WCHAR       szwCountryCode[FXS_MAX_COUNTRYCODE_LEN+1];
    DWORD       dwCountryCode = 0;

    CDlgSelectCountry  DlgSelectCountry(m_pFaxServer);

    hRc = DlgSelectCountry.InitSelectCountryCodeDlg();
    if (S_OK != hRc)
    {
        //MsgBox + debug print by called func.
        goto Cleanup;
    }

    //
    // Dialog select country code
    //
    rc = DlgSelectCountry.DoModal();
    if (rc != IDOK)
    {
        goto Cleanup;
    }

    //
    // Retreive CountryCode
    //
    dwCountryCode = DlgSelectCountry.GetCountryCode();

    iCount = swprintf(szwCountryCode, L"%ld", dwCountryCode);
    if( iCount <= 0 )
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to read member - m_dwCountryCode."));
        goto Cleanup;
    }
    m_CountryCodeEdit.SetWindowText(szwCountryCode);

    //
    // EnableOK
    //
    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
		else
		{
			//Should be EnableOK(FALSE);
		}
    }

 
Cleanup:
    return hRc;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxServerSentItems::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxOutboundRoutingRule::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxOutboundRoutingRule::OnHelpRequest"));
    
    HELPINFO* helpinfo;
    DWORD     dwHelpId;

    switch (uMsg) 
    { 
        case WM_HELP: 

            helpinfo = (HELPINFO*)lParam;
            if (helpinfo->iContextType == HELPINFO_WINDOW)
            {
                ::WinHelp(
                          (HWND) helpinfo->hItemHandle,
                          FXS_ADMIN_HLP_FILE, 
                          HELP_CONTEXTPOPUP, 
                          (DWORD) helpinfo->dwContextId 
                       ); 
            }
            break; 
 
        case WM_CONTEXTMENU: 
            
            dwHelpId = ::GetWindowContextHelpId((HWND)wParam);
            if (dwHelpId) 
            {
                ::WinHelp
                       (
                         (HWND)wParam,
                         FXS_ADMIN_HLP_FILE, 
                         HELP_CONTEXTPOPUP, 
                         dwHelpId
                       );
            }
            break; 
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxservergeneral.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerGeneral.cpp                                 //
//                                                                         //
//  DESCRIPTION   : prop pages of                                          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 25 1999 yossg  created                                         //
//      Nov 22 1999 yossg  Call RPC func                                   //
//      Nov 24 1999 yossg  OnApply create call to all tabs from parent     //
//      Mar 15 2000 yossg  New design add controls                         //
//      Mar 20 2000 yossg  Add activity notification                       //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxServerGeneral.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

class CSnapinNode;

//
// Constructor
//
CppFaxServerGeneral::CppFaxServerGeneral(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        bOwnsNotificationHandle,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxServerGeneral>(pNode, NULL)
			                	
{
	
    m_pParentNode = static_cast<CFaxServerNode *> (pNode);

    m_FaxVersionConfig.dwSizeOfStruct = sizeof(FAX_VERSION);

    m_hActivityNotification = NULL;
    m_fIsDialogInitiated    = FALSE;

    m_fIsDirty              = FALSE;

    m_lpNotifyHandle = hNotificationHandle;
}

//
// Destructor
//
CppFaxServerGeneral::~CppFaxServerGeneral()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerGeneral::~CppFaxServerGeneral()"));
    if (m_hActivityNotification)
    {
        //
        // Unregister server notifications
        //
        if (!FaxUnregisterForServerEvents (m_hActivityNotification))
        {
            DWORD ec = GetLastError ();
            
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Fail to Unregister For Server Events. (ec: %ld)"), 
			    ec);
        }
    }
    
    // Note - This needs to be called only once per property sheet.  
    // In our convention called in the general tab.
    if (NULL != m_lpNotifyHandle)
    {
        MMCFreeNotifyHandle(m_lpNotifyHandle);
        m_lpNotifyHandle = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CppFaxServerGeneral message handlers

/*
 -  CppFaxServerGeneral::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerGeneral::InitRPC(  )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerGeneral::InitRPC"));
    
    HRESULT    hRc = S_OK;
    DWORD      ec  = ERROR_SUCCESS;



    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

	//
	// Retrieve the fax Archive configuration
	//
    if (!FaxGetVersion(m_pFaxServer->GetFaxServerHandle(), 
                        &m_FaxVersionConfig)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get version configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }

    ZeroMemory (&m_FaxServerActivityConfig, sizeof(FAX_SERVER_ACTIVITY));
    m_FaxServerActivityConfig.dwSizeOfStruct = sizeof(FAX_SERVER_ACTIVITY);
    
    if (!FaxGetServerActivity(
                                m_pFaxServer->GetFaxServerHandle(), 
                                &m_FaxServerActivityConfig
                             )
       ) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get Server Activity configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }

    
    
    if (!FaxGetQueueStates(
                                m_pFaxServer->GetFaxServerHandle(), 
                                &m_dwQueueStates
                           )
       ) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get Queue States configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }

	
    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get version configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    m_pParentNode->NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}


/*
 -  CFaxServerNode::UpdateActivityCounters
 -
 *  Purpose:
 *      Inits and updates the activity counters: Queued, outgoing and incoming faxes.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerGeneral::UpdateActivityCounters()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerGeneral::UpdateActivityCounters"));
    HRESULT hRc = S_OK;
    int count;
    
    WCHAR szQueuedMessagesBuff[FXS_DWORD_LEN +1];
    WCHAR szOutgoingMessagesBuff[FXS_DWORD_LEN +1];
    WCHAR szIncomingMessagesBuff[FXS_DWORD_LEN +1];
    
    //
    // QueuedMessages
    //
    count =0;
    count = swprintf( szQueuedMessagesBuff, 
                      L"%ld", 
                      m_FaxServerActivityConfig.dwQueuedMessages
                    );
    
    if( count > 0 )
    {
        m_QueuedEdit.SetWindowText(szQueuedMessagesBuff);
    }
    else
    {
		DebugPrintEx(
			DEBUG_ERR,
			_T("Out of memory. Failed to allocate string."));
        
        PageError(IDS_MEMORY,m_hWnd);

        goto Exit;
    }

    //
    // OutgoingMessages
    //
    count =0;
    count = swprintf( szOutgoingMessagesBuff, 
                      L"%ld", 
                      ( m_FaxServerActivityConfig.dwOutgoingMessages +
                      m_FaxServerActivityConfig.dwDelegatedOutgoingMessages )
                    );
    
    if( count > 0 )
    {
        m_OutgoingEdit.SetWindowText(szOutgoingMessagesBuff);
    }
    else
    {
		DebugPrintEx(
			DEBUG_ERR,
			_T("Out of memory. Failed to allocate string."));
        
        PageError(IDS_MEMORY,m_hWnd); 

        goto Exit;
    }

    //
    // IncomingMessages
    //
    count =0;
    count = swprintf( szIncomingMessagesBuff, 
                      L"%ld", 
                      ( m_FaxServerActivityConfig.dwIncomingMessages + 
                      m_FaxServerActivityConfig.dwRoutingMessages )
                    );
    
    if( count > 0 )
    {
        m_IncomingEdit.SetWindowText(szIncomingMessagesBuff);
    }
    else
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Out of memory. Failed to allocate string."));
        
        PageError(IDS_MEMORY,m_hWnd); 

        goto Exit;
    }    

    
Exit:    
    return hRc;
}

/*
 -  CFaxServerNode::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxServerGeneral::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerGeneral::OnInitDialog"));

    UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );
     
    CComBSTR bstrVersion, bstrChecked;
    // a Buffer to collect all version DWORDs in
    // 256 >> 4*DWORD in chars +3*char ('.') + chars of (" (Checked)")
    WCHAR buffer[256];
    int count;

    DWORD ec = ERROR_SUCCESS;
    HRESULT hRc = S_OK;



    //
    // init controls
    //

    //
    // Version
    //
 
    //bstrVersion = L"5.0.813.0 (Chk)" or L"5.0.813.0"
    count = swprintf(
                  buffer,
                  L"%ld.%ld.%ld.%ld",
                  m_FaxVersionConfig.wMajorVersion,
                  m_FaxVersionConfig.wMinorVersion,
                  m_FaxVersionConfig.wMajorBuildNumber,
                  m_FaxVersionConfig.wMinorBuildNumber
                  );

    bstrVersion = SysAllocString (buffer);

    if (m_FaxVersionConfig.dwFlags & FAX_VER_FLAG_CHECKED)
    {
        
        if (!bstrChecked.LoadString(IDS_CHK))
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    _T("Out of memory. Failed to load string."));
            m_pParentNode->NodeMsgBox(IDS_MEMORY);
            
            goto Exit;
        }
        
        bstrVersion += bstrChecked;
    }
    
    SetDlgItemText(IDC_VERSION_DTEXT, bstrVersion);
    
    //
    // Queue states
    //
    
    // submission
    if( m_dwQueueStates & FAX_OUTBOX_BLOCKED ) 
    {
        CheckDlgButton(IDC_SUBMISSION_CHECK, BST_CHECKED);
    }
    
    //transmission
    if( m_dwQueueStates & FAX_OUTBOX_PAUSED ) 
    {
        CheckDlgButton(IDC_TRANSSMI_CHECK, BST_CHECKED);
    }
    
    // reception
    if( m_dwQueueStates & FAX_INCOMING_BLOCKED ) 
    {
        CheckDlgButton(IDC_RECEPTION_CHECK, BST_CHECKED);
    }

    //
    // Activity
    //
    m_QueuedEdit.Attach(   GetDlgItem(IDC_QUED_ROEDIT)            );
    m_OutgoingEdit.Attach( GetDlgItem(IDC_OUTGOING_INPROC_ROEDIT) );
    m_IncomingEdit.Attach( GetDlgItem(IDC_INCOM_INPROC_ROEDIT)    );

    hRc = UpdateActivityCounters();
    if (S_OK != hRc)
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to UpdateActivityCounters()"));
        
        goto Exit;
    }

    //
    // Register for Queue states changes notification
    //
    ATLASSERT(::IsWindow(m_hWnd));

    if (!m_hActivityNotification)
    {
        //
        // get RPC Handle
        //   

        if (!m_pFaxServer->GetFaxServerHandle())
        {
            ec= GetLastError();
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			    ec);

            goto Exit; //Error;
        }

    
        if (!FaxRegisterForServerEvents (   
                                          m_pFaxServer->GetFaxServerHandle(),
                                          FAX_EVENT_TYPE_ACTIVITY,               
                                          NULL,                       
                                          0,                          
                                          m_hWnd,                     
                                          WM_ACTIVITY_STATUS_CHANGES, 
                                          &m_hActivityNotification
                                        )                   
            )
        {
            ec = GetLastError();

            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Fail to Register For Server Events (ec: %ld)"), ec);
        
            m_hActivityNotification = NULL;
        
            goto Exit;
        }
    }
    m_fIsDialogInitiated = TRUE;
    
Exit:      
    return(1);
}


/*
 -  CFaxServerNode::OnActivityStatusChange
 -
 *  Purpose:
 *      Treats notifications about changes in Queue States.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxServerGeneral::OnActivityStatusChange( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( fHandled );

    DEBUG_FUNCTION_NAME( _T("CppFaxServerGeneral::OnActivityStatusChange"));
    HRESULT hRc = S_OK;
    
    ATLASSERT( uiMsg == WM_ACTIVITY_STATUS_CHANGES );
    
    PFAX_EVENT_EX   pFaxEvent = NULL;
	pFaxEvent = reinterpret_cast<PFAX_EVENT_EX>(lParam);
    ATLASSERT( pFaxEvent );
    
    //
    // Updating the required fields
    //
    m_FaxServerActivityConfig.dwIncomingMessages   = pFaxEvent->EventInfo.ActivityInfo.dwIncomingMessages;
	m_FaxServerActivityConfig.dwRoutingMessages    = pFaxEvent->EventInfo.ActivityInfo.dwRoutingMessages;

    m_FaxServerActivityConfig.dwOutgoingMessages   = pFaxEvent->EventInfo.ActivityInfo.dwOutgoingMessages;
    m_FaxServerActivityConfig.dwDelegatedOutgoingMessages = 
                                        pFaxEvent->EventInfo.ActivityInfo.dwDelegatedOutgoingMessages;

    m_FaxServerActivityConfig.dwQueuedMessages     = pFaxEvent->EventInfo.ActivityInfo.dwQueuedMessages;

    hRc = UpdateActivityCounters();
    if (S_OK != hRc)
    {
        DebugPrintEx(
           DEBUG_ERR,
           _T("Failed to UpdateActivityCounters()"));
    }
    
    
    
    
    if (pFaxEvent) 
    {
        FaxFreeBuffer (pFaxEvent);
        pFaxEvent = NULL;
    }

    return(1);
}

/*
 -  CFaxServerGeneral::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      IN pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerGeneral::SetProps(int *pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerGeneral::SetProps"));

    HRESULT    hRc = S_OK;
    DWORD      ec  = ERROR_SUCCESS;

    DWORD  dwQueueStates;
	
    //
    // Collects Queue states
    //
    
    //init
    dwQueueStates = 0;        
	
    //Submission
    if (IsDlgButtonChecked(IDC_SUBMISSION_CHECK) == BST_CHECKED)   
    {
        dwQueueStates |= FAX_OUTBOX_BLOCKED;
    }
    
    //Transmission
    if (IsDlgButtonChecked(IDC_TRANSSMI_CHECK) == BST_CHECKED)   
    {
        dwQueueStates |= FAX_OUTBOX_PAUSED;
    }
    
    //Reception
    if (IsDlgButtonChecked(IDC_RECEPTION_CHECK) == BST_CHECKED)   
    {
        dwQueueStates |= FAX_INCOMING_BLOCKED;
    }
    
    //
    // Set Queue States through RPC call
    //   

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    
    if (!FaxSetQueue(
                        m_pFaxServer->GetFaxServerHandle(), 
                        dwQueueStates
                    )
       ) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get Queue States configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }

    ATLASSERT(S_OK == hRc);
    m_fIsDirty = FALSE;

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
	
    PropSheet_SetCurSelByID( GetParent(), IDD);         

    ATLASSERT(::IsWindow(m_hWnd));
    PageError(GetFaxServerErrorMsg(ec),m_hWnd);
    
Exit:
    return(hRc);
}

/*
 -  CFaxServerNode::PreApply
 -
 *  Purpose:
 *      Checks properties before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerGeneral::PreApply(int *pCtrlFocus)
{
    return(S_OK);
}

/*
 -  CppFaxServerGeneral::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxServerGeneral::OnApply()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerInbox::OnApply"));

    HRESULT hRc = S_OK;
    int     CtrlFocus = 0;
    
    if (!m_fIsDirty)
    {
        return TRUE;
    }

    hRc = SetProps(&CtrlFocus);
    if (FAILED(hRc)) 
    {
        //Error Msg by called func.
        if (CtrlFocus)
        {
            GotoDlgCtrl(GetDlgItem(CtrlFocus));
        }
        return FALSE;
    }
    else //(Succeeded(hRc))
    {
        return TRUE;
    }
}



/*
 -  CppFaxServerGeneral::SetApplyButton
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerGeneral::SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }
    
    SetModified(TRUE);  
    bHandled = TRUE;
    return(1);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxServerGeneral::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxServerGeneral::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxServerGeneral::OnHelpRequest"));
    
    HELPINFO* helpinfo;
    DWORD     dwHelpId;

    switch (uMsg) 
    { 
        case WM_HELP: 

            helpinfo = (HELPINFO*)lParam;
            if (helpinfo->iContextType == HELPINFO_WINDOW)
            {
                ::WinHelp(
                          (HWND) helpinfo->hItemHandle,
                          FXS_ADMIN_HLP_FILE, 
                          HELP_CONTEXTPOPUP, 
                          (DWORD) helpinfo->dwContextId 
                       ); 
            }
            break; 
 
        case WM_CONTEXTMENU: 
            
            dwHelpId = ::GetWindowContextHelpId((HWND)wParam);
            if (dwHelpId) 
            {
                ::WinHelp
                       (
                         (HWND)wParam,
                         FXS_ADMIN_HLP_FILE, 
                         HELP_CONTEXTPOPUP, 
                         dwHelpId
                       );
            }
            break; 
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxserverlogging.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerLogging.h                                   //
//                                                                         //
//  DESCRIPTION   : Fax Server general prop page header file               //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 27 1999 yossg  created                                         //
//      Nov  3 1999 yossg  OnInitDialog, SetProps                          //
//      Nov 15 1999 yossg  Call RPC func                                   //
//      Dec 10 2000 yossg  Update Windows XP                               //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXSERVER_LOGGING_H_
#define _PP_FAXSERVER_LOGGING_H_

#include <proppageex.h>
class CFaxServerNode;
class CFaxServer;
/////////////////////////////////////////////////////////////////////////////
// CppFaxServerLogging dialog

class CppFaxServerLogging : public CPropertyPageExImpl<CppFaxServerLogging>
{

public:
    //
    // Constructor
    //
    CppFaxServerLogging(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           fIsLocalServer,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxServerLogging();

	enum { IDD = IDD_FAXSERVER_LOGGING };

	BEGIN_MSG_MAP(CppFaxServerLogging)
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )

        COMMAND_HANDLER( IDC_LOG_BROWSE_BUTTON,  BN_CLICKED, BrowseForFile  )
        COMMAND_HANDLER( IDC_INCOMING_LOG_CHECK, BN_CLICKED, OnCheckboxClicked )
        COMMAND_HANDLER( IDC_OUTGOING_LOG_CHECK, BN_CLICKED, OnCheckboxClicked )
        COMMAND_HANDLER( IDC_LOG_FILE_EDIT,      EN_CHANGE,  OnTextChanged )

        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxServerLogging>)
	END_MSG_MAP()

	//
	// Dialog's Handlers and events.
	//
	HRESULT InitRPC( );
	LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL OnApply();

    HRESULT SetProps(int *pCtrlFocus);
    HRESULT PreApply(int *pCtrlFocus, UINT * puIds);

private:
    //
    // Control members
    //
    CEdit   m_LogFileBox;
    
    BOOL    m_fIsDialogInitiated;
    BOOL    m_fIsDirty;

    BOOL    m_fIsLocalServer;

    //
    // Config Structure member
    //
    PFAX_ACTIVITY_LOGGING_CONFIG    m_pFaxActLogConfig;
    
    CComBSTR                        m_bstrLastGoodFolder;

    //
    // Handles
    //
    CFaxServerNode * m_pParentNode;    

    //
    // Browse
    //
    BOOL BrowseForFile(WORD wNotifyCode, WORD wID, HWND hwndDlg, BOOL& bHandled);

    //
    // Event methods
    //
    LRESULT SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    void EnableDataBasePath(BOOL fState);
    
    BOOL AllReadyToApply(BOOL fSilent, int *pCtrlFocus = NULL, UINT *pIds = NULL);
    
    LRESULT OnTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);


    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};

#endif // _PP_FAXSERVER_LOGGING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxserverinbox.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerInbox.cpp                                   //
//                                                                         //
//  DESCRIPTION   : prop pages of Inbox archive                            //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 25 1999 yossg  created                                         //
//      Nov  3 1999 yossg  OnInitDialog, SetProps                          //
//      Nov 15 1999 yossg  Call RPC func                                   //
//      Nov 24 1999 yossg  OnApply create call to all tabs from parent     //
//      Oct 17 2000 yossg                                                  //
//      Dec 10 2000 yossg  Update Windows XP                               //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxServerInbox.h"
#include "FaxMMCGlobals.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "FxsValid.h"
#include "dlgutils.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Constructor
//
CppFaxServerInbox::CppFaxServerInbox(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        fIsLocalServer,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxServerInbox>(pNode, NULL)
			                	
{
    m_pParentNode        = static_cast <CFaxServerNode *> (pNode);
    m_pFaxArchiveConfig  = NULL;

    m_fAllReadyToApply   = FALSE;
    m_fIsDialogInitiated = FALSE;
    
    m_fIsDirty           = FALSE;

    m_fIsLocalServer     = fIsLocalServer;
}

//
// Destructor
//
CppFaxServerInbox::~CppFaxServerInbox()
{
    if (NULL != m_pFaxArchiveConfig)
    {
        FaxFreeBuffer( m_pFaxArchiveConfig );
    }
}

/////////////////////////////////////////////////////////////////////////////
// CppFaxServerInbox message handlers

/*
 -  CppFaxServerInbox::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerInbox::InitRPC(  )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerInbox::InitRPC"));
    
    HRESULT    hRc = S_OK;
    DWORD      ec  = ERROR_SUCCESS;

      //
    // get RPC Handle
    //   

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
	// Retrieve the fax Archive configuration
	//
    if (!FaxGetArchiveConfiguration(m_pFaxServer->GetFaxServerHandle(), 
                                    FAX_MESSAGE_FOLDER_INBOX, 
                                    &m_pFaxArchiveConfig)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get inbox configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(m_pFaxArchiveConfig);

    //
    // Init specific members for set proprties follow-up
    //
    m_dwLastGoodSizeQuotaHighWatermark = m_pFaxArchiveConfig->dwSizeQuotaHighWatermark;
    m_dwLastGoodSizeQuotaLowWatermark  = m_pFaxArchiveConfig->dwSizeQuotaLowWatermark;
    m_bstrLastGoodFolder               = m_pFaxArchiveConfig->lpcstrFolder;
    if (!m_bstrLastGoodFolder)
    {
		DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Failed to allocate string (m_bstrLastGoodFolder)."));
        ec = ERROR_OUTOFMEMORY;
        
        goto Error;
    }

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get inbox configuration."));
	
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    m_pParentNode->NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);

}

/*
 -  CppFaxServerInbox::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxServerInbox::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerInbox::PageInitDialog"));
    
    DWORD   ec  = ERROR_SUCCESS;

	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );

    int  iLow,
         iHigh,
         iAgeLimit;

    ATLASSERT(m_pFaxArchiveConfig);

    //
    // init controls
    // 
    m_FolderBox.Attach(GetDlgItem(IDC_INBOX_FOLDER_EDIT));
    m_FolderBox.SetLimitText(MAX_PATH-1);

    m_HighWatermarkBox.Attach(GetDlgItem(IDC_HIGH_EDIT));
    m_LowWatermarkBox.Attach(GetDlgItem(IDC_LOW_EDIT));
    m_AutoDelBox.Attach(GetDlgItem(IDC_AUTODEL_EDIT));

    m_HighWatermarkBox.SetLimitText(FXS_QUOTA_LENGTH);
    m_LowWatermarkBox.SetLimitText(FXS_QUOTA_LENGTH);
    m_AutoDelBox.SetLimitText(FXS_DIRTYDAYS_LENGTH);

    m_HighWatermarkSpin.Attach(GetDlgItem(IDC_HIGH_SPIN));
    m_LowWatermarkSpin.Attach(GetDlgItem(IDC_LOW_SPIN));
    m_AutoDelSpin.Attach(GetDlgItem(IDC_AUTODEL_SPIN));
   
    //
    // FOLDER_EDIT
    //
    m_FolderBox.SetWindowText(m_pFaxArchiveConfig->lpcstrFolder);

    //
    // Disable Browse button for remote admin
    //
    if (!m_fIsLocalServer)
    {
        ::EnableWindow(GetDlgItem(IDC_INBOX_BROWSE_BUTTON), FALSE); 
    }

    //
    // TO_ARCHIVE_CHECK
    //
    if (m_pFaxArchiveConfig->bUseArchive) 
    {
        CheckDlgButton(IDC_TO_ARCHIVE_CHECK, BST_CHECKED) ;
    }
    else
    {
        CheckDlgButton(IDC_TO_ARCHIVE_CHECK, BST_UNCHECKED) ;
        ::EnableWindow(GetDlgItem(IDC_INBOX_FOLDER_EDIT), FALSE);    
        ::EnableWindow(GetDlgItem(IDC_INBOX_BROWSE_BUTTON), FALSE);    
    }

    //
    // Quota size - Low
    //
    iLow = (int)m_pFaxArchiveConfig->dwSizeQuotaLowWatermark;

    m_LowWatermarkSpin.SetRange(FXS_QUOTA_LOW_LOWER, FXS_QUOTA_LOW_UPPER);
    m_LowWatermarkSpin.SetPos(iLow);
    //
    // Quota size - High
    //    
    iHigh = (int)m_pFaxArchiveConfig->dwSizeQuotaHighWatermark;
    m_HighWatermarkSpin.SetRange(FXS_QUOTA_HIGH_LOWER, FXS_QUOTA_HIGH_UPPER);
    m_HighWatermarkSpin.SetPos(iHigh);// Set Position
    
    //
    //Generate event log warning
    //
    if (m_pFaxArchiveConfig->bSizeQuotaWarning) 
    {
        CheckDlgButton(IDC_GENERATE_WARNING_CHECK, BST_CHECKED) ;
    }
    else
    {
        CheckDlgButton(IDC_GENERATE_WARNING_CHECK, BST_UNCHECKED) ;
        ::EnableWindow(GetDlgItem(IDC_HIGH_EDIT), FALSE);    
        ::EnableWindow(GetDlgItem(IDC_HIGH_SPIN), FALSE);    

        ::EnableWindow(GetDlgItem(IDC_LOW_EDIT), FALSE);    
        ::EnableWindow(GetDlgItem(IDC_LOW_SPIN), FALSE);    
    }


    //
    // message life-time (dirty days)
    //
    iAgeLimit = (int)m_pFaxArchiveConfig->dwAgeLimit;

    m_AutoDelSpin.SetRange(FXS_DIRTYDAYS_LOWER, FXS_DIRTYDAYS_UPPER);
    m_AutoDelSpin.SetPos(iAgeLimit);

    //
    // Auto Delete
    //
    if (FXS_DIRTYDAYS_ZERO == iAgeLimit)
    {
      CheckDlgButton(IDC_AUTODEL_CHECK, BST_UNCHECKED);

      ::EnableWindow(GetDlgItem(IDC_AUTODEL_EDIT), FALSE);
      ::EnableWindow(GetDlgItem(IDC_AUTODEL_SPIN), FALSE);
    }
    else
    {
      CheckDlgButton(IDC_AUTODEL_CHECK, BST_CHECKED);
    }

    m_fIsDialogInitiated = TRUE;
    
    return (1);
}

/*
 -  CppFaxServerInbox::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerInbox::SetProps(int *pCtrlFocus, UINT * puIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerInbox::SetProps"));

    HRESULT      hRc = S_OK;
    DWORD        ec  = ERROR_SUCCESS;
    HINSTANCE    hInst     = _Module.GetResourceInstance();


    CComBSTR     bstrFolder = L"";

    BOOL         fSkipMessage = FALSE;
    
    FAX_ARCHIVE_CONFIG   FaxArchiveConfig;

    ATLASSERT(TRUE == m_fAllReadyToApply);
    m_fAllReadyToApply = FALSE;

    //
    // Collect all data and init the structure's fields 
    // uses Copy() to copy and also allocate before
    //
    ZeroMemory (&FaxArchiveConfig, sizeof(FAX_ARCHIVE_CONFIG));

    //
    // Size of struct.
    //
    FaxArchiveConfig.dwSizeOfStruct = sizeof(FAX_ARCHIVE_CONFIG);

    //
    // IDC_TO_ARCHIVE_CHECK
    //
    if (IsDlgButtonChecked(IDC_TO_ARCHIVE_CHECK) == BST_CHECKED)   
    {
        FaxArchiveConfig.bUseArchive = TRUE;
        
        //IDC_INBOX_FOLDER_EDIT
        if ( !m_FolderBox.GetWindowText(&bstrFolder))
        {
            *pCtrlFocus = IDC_INBOX_FOLDER_EDIT;
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&bstrFolder)"));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }
        if (!IsNotEmptyString(bstrFolder))
        {
            *pCtrlFocus = IDC_INBOX_FOLDER_EDIT;
            *puIds = IDS_INBOX_ARCHIVE_PATH_EMPTY;            

            DebugPrintEx( DEBUG_ERR,
			    _T("Archive path string is empty or includes spaces only."));
            
            fSkipMessage = TRUE;

            ec = ERROR_INVALID_DATA;
        
            goto Error;
        }
        FaxArchiveConfig.lpcstrFolder = bstrFolder;
        
        //
        // follow-up for an OnApply following submition
        // with unchecked IDC_TO_ARCHIVE_CHECK
        //
        m_bstrLastGoodFolder          = bstrFolder; 
        if (!m_bstrLastGoodFolder)
        {
            *pCtrlFocus = IDC_INBOX_FOLDER_EDIT;
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to allocate string (m_bstrLastGoodFolder)."));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }
    }
    else
    {
        FaxArchiveConfig.bUseArchive  = FALSE;
        FaxArchiveConfig.lpcstrFolder = m_bstrLastGoodFolder; 
    }
    
    //
    // IDC_GENERATE_WARNING_CHECK
    //
    if (IsDlgButtonChecked(IDC_GENERATE_WARNING_CHECK) == BST_CHECKED)   
    {
        FaxArchiveConfig.bSizeQuotaWarning = TRUE;

        int iHigh = m_HighWatermarkSpin.GetPos();
        FaxArchiveConfig.dwSizeQuotaHighWatermark = (DWORD) iHigh;

        int iLow = m_LowWatermarkSpin.GetPos();
        FaxArchiveConfig.dwSizeQuotaLowWatermark = (DWORD) iLow;

        if (iHigh <= iLow)
        {
            *pCtrlFocus = IDC_SENT_HIGH_EDIT;
            *puIds = IDS_INBOX_WATERMARK_HI_LOW;            
            
            DebugPrintEx( DEBUG_ERR,
			    _T("Watermark High < Low."));
            
            fSkipMessage = TRUE;

            ec = ERROR_INVALID_DATA;
        
            goto Error;
        }
        //
        // follow-up for an OnApply following submition
        // with unchecked IDC_SENT_GENERATE_WARNING_CHECK
        //
        m_dwLastGoodSizeQuotaHighWatermark = (DWORD)iHigh;
        m_dwLastGoodSizeQuotaLowWatermark  = (DWORD)iLow;
    }
    else
    {
        FaxArchiveConfig.bSizeQuotaWarning = FALSE;

        FaxArchiveConfig.dwSizeQuotaHighWatermark = m_dwLastGoodSizeQuotaHighWatermark;
        FaxArchiveConfig.dwSizeQuotaLowWatermark  = m_dwLastGoodSizeQuotaLowWatermark;
    }
    
    //
    // IDC_AUTODEL_CHECK  - AutoDelete Messages
    //
    if (IsDlgButtonChecked(IDC_AUTODEL_CHECK) == BST_CHECKED)   
    {       
        int iAgeLimit = m_AutoDelSpin.GetPos();
        FaxArchiveConfig.dwAgeLimit = (DWORD) iAgeLimit;
    }
    else
    {
        FaxArchiveConfig.dwAgeLimit = (DWORD)FXS_DIRTYDAYS_ZERO;
    }
    
    //
    // get RPC Handle
    //   
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        goto Error;
    }

    //
    // Set Config
    //
    if (!FaxSetArchiveConfiguration(
                m_pFaxServer->GetFaxServerHandle(),
                FAX_MESSAGE_FOLDER_INBOX,
                &FaxArchiveConfig)) 
	{		
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to Set inbox configuration. (ec: %ld)"), 
			ec);

        
        DWORD dwIDS = 0;
            
        switch (ec)
        {
            case ERROR_PATH_NOT_FOUND:
                
                DebugPrintEx( DEBUG_ERR, _T("ERROR_PATH_NOT_FOUND == ec"));
                dwIDS = IDS_INBOX_ERROR_PATH_NOT_FOUND;
                break;

            case ERROR_DISK_FULL:

                DebugPrintEx( DEBUG_ERR, _T("ERROR_DISK_FULL == ec"));
                dwIDS = IDS_INBOX_ERROR_DISK_FULL;
                break;
    
            case FAX_ERR_FILE_ACCESS_DENIED:

                DebugPrintEx( DEBUG_ERR, _T("FAX_ERR_FILE_ACCESS_DENIED == ec"));
                dwIDS = IDS_INBOX_FAX_ERR_FILE_ACCESS_DENIED;
                break;
        
            case FAX_ERR_NOT_NTFS:
                
                DebugPrintEx( DEBUG_ERR, _T("FAX_ERR_NOT_NTFS == ec"));
                dwIDS = IDS_INBOX_FAX_ERR_NOT_NTFS;
                break;

        }
            
        if ( 0 != dwIDS )
        {
            if (PropSheet_SetCurSelByID( GetParent(), IDD) )
            {
                PageError(dwIDS, m_hWnd);
        
                GotoDlgCtrl(GetDlgItem(IDC_INBOX_FOLDER_EDIT));
            }
            
            fSkipMessage = TRUE;

            goto Error; 
        }
                
        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }
        
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    m_fIsDirty = FALSE;
    
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to set inbox configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
    if (!fSkipMessage)
    {
       PropSheet_SetCurSelByID( GetParent(), IDD);         

       ATLASSERT(::IsWindow(m_hWnd));
       PageError(GetFaxServerErrorMsg(ec),m_hWnd);
    }

Exit:    
    return(hRc);
}

/*
 -  CppFaxServerInbox::PreApply
 -
 *  Purpose:
 *      Checks properties before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerInbox::PreApply(int *pCtrlFocus, UINT * puIds)
{
    HRESULT hRc = S_OK;
    
    //
    // PreApply Checks
    //
    if (!AllReadyToApply(/*fSilent =*/ FALSE, pCtrlFocus , puIds))
    {
        m_fAllReadyToApply = FALSE;
        SetModified(FALSE);  
        hRc = E_FAIL ;
    }
    else
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }

    return(hRc);
}

/*
 -  CppFaxServerInbox::ToArchiveCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray the folder edit box and the
 *      browse button. Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerInbox::ToArchiveCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }


    State = ( IsDlgButtonChecked(IDC_TO_ARCHIVE_CHECK) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_INBOX_FOLDER_EDIT),   State);    
    ::EnableWindow(GetDlgItem(IDC_INBOX_BROWSE_BUTTON), State && m_fIsLocalServer);    

    if (m_fAllReadyToApply)//only last change should be considered
    {
        if ( !m_FolderBox.GetWindowTextLength() )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return 1;
}

/*
 -  CppFaxServerInbox::GenerateEventLogCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray the spin buttons and edit boxes
 *      Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerInbox::GenerateEventLogCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    State = ( IsDlgButtonChecked(IDC_GENERATE_WARNING_CHECK) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_HIGH_EDIT), State);    
    ::EnableWindow(GetDlgItem(IDC_HIGH_SPIN), State);    
    ::EnableWindow(GetDlgItem(IDC_QUOTA_HIGH_STATIC), State);    
    ::EnableWindow(GetDlgItem(IDC_MB1_STATIC), State);    

    ::EnableWindow(GetDlgItem(IDC_LOW_EDIT),  State);    
    ::EnableWindow(GetDlgItem(IDC_LOW_SPIN),  State);    
    ::EnableWindow(GetDlgItem(IDC_QUOTA_LOW_STATIC), State);    
    ::EnableWindow(GetDlgItem(IDC_MB2_STATIC), State);    


    if (m_fAllReadyToApply)//only last change should be considered
    {
        if ( !m_HighWatermarkBox.GetWindowTextLength() )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
        else if ( 0 != HIWORD( m_HighWatermarkSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
        else if ( !m_LowWatermarkBox.GetWindowTextLength() )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return(1);
}

/*
 -  CppFaxServerInbox::AutoDelCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray the spin button and edit box
 *      and enable apply button after Auto Delete Checkbox 
 *      status was changed.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerInbox::AutoDelCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    State = ( IsDlgButtonChecked(IDC_AUTODEL_CHECK) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_AUTODEL_EDIT), State);    
    ::EnableWindow(GetDlgItem(IDC_AUTODEL_SPIN), State);    

    if (m_fAllReadyToApply)//only last change should be considered
    {
        if (State)
		{
			if ( !m_AutoDelBox.GetWindowTextLength() )    
			{
				m_fAllReadyToApply = FALSE;
				SetModified(FALSE);
			}
			else if ( 0 != HIWORD( m_AutoDelSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
			{
				m_fAllReadyToApply = FALSE;
				SetModified(FALSE);
			}
		}
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return(1);
}

/*
 +  Routine Description:
 +
 *      Browse for a directory
 *
 *  Arguments:
 *
 *      hwndDlg - Specifies the dialog window on which the Browse button is displayed
 *
 *  Return Value:
 *  
 *      TRUE if successful, FALSE if the user presses Cancel
 -
 -
 */
BOOL
CppFaxServerInbox::BrowseForDirectory( WORD wNotifyCode, WORD wID, HWND hwndDlg, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER( wNotifyCode );
	UNREFERENCED_PARAMETER( wID );
	UNREFERENCED_PARAMETER( hwndDlg );
	UNREFERENCED_PARAMETER( bHandled );

    DEBUG_FUNCTION_NAME( _T("CppFaxServerInbox::BrowseForDirectory"));

    BOOL            fResult = FALSE;

    WCHAR           szBrowseFolder[MAX_PATH];
    WCHAR           szBrowseDlgTitle[FXS_MAX_TITLE_LEN];
    CComBSTR        bstrOldPath;
    unsigned int    len;

    unsigned long   ulBrowseFlags;

    //
    // Collecting the browse dialog headline
    //
    if (!LoadString( _Module.GetResourceInstance(), 
                IDS_GET_ARCHIVE_DIRECTORY, 
                szBrowseDlgTitle, 
                FXS_MAX_TITLE_LEN))
    {
        DWORD ec;
        ec = GetLastError();
        if (ec == ERROR_NOT_ENOUGH_MEMORY)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Out of Memory - fail to load string."));
            DlgMsgBox(this, IDS_MEMORY);
            return fResult;
        }
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to load titile string - unexpected behavior."));
        
        szBrowseDlgTitle[0] = 0;
    }

    //
    // Collecting the old path from the calling dialog edit box
    //
    if(! GetDlgItemText( IDC_INBOX_FOLDER_EDIT, bstrOldPath.m_str))
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to collect old path from the property page edit box."));
         
        szBrowseFolder[0] = 0;
    }
    else
    {
         len = bstrOldPath.Length();
         if ( len > MAX_PATH )
         {
             DebugPrintEx(
		        DEBUG_ERR,
		        _T("Old Path Length is bigger then alowed maximal path."));
             szBrowseFolder[0] = 0;
         }
         else 
         {
             wcsncpy(szBrowseFolder,bstrOldPath,MAX_PATH);
             szBrowseFolder[MAX_PATH-1]=L'\0';
         }
    }

    //
    // Preparing the browse dialog style flags.
    //
    ulBrowseFlags       = BIF_RETURNONLYFSDIRS | 
                          BIF_STATUSTEXT | 
                          BIF_USENEWUI | 
                          BIF_VALIDATE;

    //
    // Invoke the browse dialog with a function based on 
    // Shell functions.
    //  
    if (InvokeBrowseDialog(  
                    (unsigned short *)&szBrowseFolder, 
                    (const unsigned short *)&szBrowseDlgTitle,
                    ulBrowseFlags,
                    this))
    {
                SetDlgItemText(IDC_INBOX_FOLDER_EDIT, szBrowseFolder);
                fResult = TRUE;
    }

    return fResult;
}


/*
 -  CppFaxServerInbox::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxServerInbox::OnApply()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerInbox::OnApply"));

    HRESULT  hRc  = S_OK;
    int     CtrlFocus = 0;
    UINT    uIds = 0;

    if (!m_fIsDirty)
    {
        return TRUE;
    }

    hRc = PreApply(&CtrlFocus, &uIds);
    if (FAILED(hRc))
    {
        if (PropSheet_SetCurSelByID( GetParent(), IDD) )
        {
            PageError(uIds, m_hWnd, _Module.GetResourceInstance());
            
            if (CtrlFocus)
            {
                GotoDlgCtrl(GetDlgItem(CtrlFocus));
            }
        }
        return FALSE;
    }
    else //(Succeeded(hRc))
    {
        hRc = SetProps(&CtrlFocus, &uIds);
        if (FAILED(hRc)) 
        {
            if (uIds)
            {
                if (PropSheet_SetCurSelByID( GetParent(), IDD) )
                {
                    PageError(uIds, m_hWnd, _Module.GetResourceInstance());
            
                    if (CtrlFocus)
                    {
                        GotoDlgCtrl(GetDlgItem(CtrlFocus));
                    }
                }
            }
            //else Error Msg by called func.
            return FALSE;
        }
        else //(Succeeded(hRc))
        {
            return TRUE;
        }
    }

}


/*
 -  CppFaxServerInbox::EditChanged
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerInbox::EditChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (!m_fIsDialogInitiated)
    {
        return 1;
    }
    else
    {
        m_fIsDirty = TRUE;
    }
        
        
    if (m_fAllReadyToApply) //only last change should be considered
    {
        switch (wID)
        {
            case IDC_INBOX_FOLDER_EDIT:
                if ( !m_FolderBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
				break;

            case IDC_HIGH_EDIT:
                if ( !m_HighWatermarkBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }		
                else if ( 0 != HIWORD( m_HighWatermarkSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
                break;

            case IDC_LOW_EDIT:
                if ( !m_LowWatermarkBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
				break;

            case IDC_AUTODEL_EDIT:
                if ( !m_AutoDelBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
                else if ( 0 != HIWORD( m_AutoDelSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
                {
                    m_fAllReadyToApply = FALSE;
                    SetModified(FALSE);
                }

				break;

            default:
                return 1;
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return 1;
}


/*
 -  CppFaxServerInbox::AllReadyToApply
 -
 *  Purpose:
 *      This function validate that no zero length strings 
 *      are found data areas that should be saved.
 *
 *  Arguments:
 *      [in] fSilent - boolean who defines if to pop up messages (FALSE)
 *           or not.(TRUE)
 *
 *  Return:
 *      BOOOLEAN
 */
BOOL CppFaxServerInbox::AllReadyToApply(BOOL fSilent, int *pCtrlFocus, UINT *pIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerInbox::AllReadyToApply"));
	
    DWORD         ec  = ERROR_SUCCESS;
    
    HINSTANCE     hInst = _Module.GetResourceInstance();
    
    
    if (IsDlgButtonChecked(IDC_TO_ARCHIVE_CHECK) == BST_CHECKED)
    {
        if ( !m_FolderBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Zero text length - m_FolderBox. (ec: %ld)"), 
			    ec);
        
            if (!fSilent)
            {
                *pIds = IDS_INBOX_ARCHIVE_PATH_EMPTY;
                *pCtrlFocus = IDC_INBOX_FOLDER_EDIT;
            }
            return FALSE;    
        }
    }

    if (IsDlgButtonChecked(IDC_GENERATE_WARNING_CHECK) == BST_CHECKED)
    {
        if ( !m_HighWatermarkBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                _T("Zero text length - m_HighWatermarkBox. (ec: %ld)"), 
                ec);
        
            if (!fSilent)
            {
                *pIds = IDS_INBOX_WATERMARK_EMPTY;
                *pCtrlFocus = IDC_HIGH_EDIT;
            }
            return FALSE;    
        }
        else if ( 0 != HIWORD( m_HighWatermarkSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS    
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Zero value - m_HighWatermarkBox. (ec: %ld)"));
        
            if (!fSilent)
            {
                *pIds = IDS_INBOX_HIGH_WATERMARK_ZERO;
                *pCtrlFocus = IDC_HIGH_EDIT;
            }
            return FALSE;    
        }

        if ( !m_LowWatermarkBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                _T("Zero text length - m_LowWatermarkBox. (ec: %ld)"), 
                ec);
        
            if (!fSilent)
            {
                *pIds = IDS_INBOX_WATERMARK_EMPTY;
                *pCtrlFocus = IDC_SENT_LOW_EDIT;
            }
            return FALSE;    
        }
    }

    if (IsDlgButtonChecked(IDC_AUTODEL_CHECK) == BST_CHECKED)
    {
        if ( !m_AutoDelBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                _T("Zero text length - m_AutoDelBox. (ec: %ld)"), 
                ec);
        
            if (!fSilent)
            {
                *pIds = IDS_INBOX_AUTODEL_EMPTY;
                *pCtrlFocus = IDC_AUTODEL_EDIT;
            }
            return FALSE;    
        }
        else if ( 0 != HIWORD( m_AutoDelSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Zero value - m_AutoDelBox."));
        
            if (!fSilent)
            {
                *pIds = IDS_INBOX_AUTODEL_EMPTY;
                *pCtrlFocus = IDC_AUTODEL_EDIT;
            }
            return FALSE;    
        }
    }

    ATLASSERT(ERROR_SUCCESS == ec);
    
    //
	// Cheers! 
	//		...every thing ready to apply now.
	//
	return TRUE;           
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxServerInbox::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxServerInbox::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxServerInbox::OnHelpRequest"));
    
    HELPINFO* helpinfo;
    DWORD     dwHelpId;

    switch (uMsg) 
    { 
        case WM_HELP: 

            helpinfo = (HELPINFO*)lParam;
            if (helpinfo->iContextType == HELPINFO_WINDOW)
            {
                ::WinHelp(
                          (HWND) helpinfo->hItemHandle,
                          FXS_ADMIN_HLP_FILE, 
                          HELP_CONTEXTPOPUP, 
                          (DWORD) helpinfo->dwContextId 
                       ); 
            }
            break; 
 
        case WM_CONTEXTMENU: 
            
            dwHelpId = ::GetWindowContextHelpId((HWND)wParam);
            if (dwHelpId) 
            {
                ::WinHelp
                       (
                         (HWND)wParam,
                         FXS_ADMIN_HLP_FILE, 
                         HELP_CONTEXTPOPUP, 
                         dwHelpId
                       );
            }
            break; 
    } 

    return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxservergeneral.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerGeneral.h                                   //
//                                                                         //
//  DESCRIPTION   : Fax Server general prop page header file               //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 25 1999 yossg  created                                         //
//      Nov 22 1999 yossg  Call RPC func                                   //
//      Mar 15 2000 yossg  New design add controls                         //
//      Mar 20 2000 yossg  Add activity notification                       //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////


#ifndef _PP_FAXSERVER_GENERAL_H_
#define _PP_FAXSERVER_GENERAL_H_

#include "proppageex.h"

const int WM_ACTIVITY_STATUS_CHANGES = WM_USER + 2;



class CFaxServer;
class CFaxServerNode;

/////////////////////////////////////////////////////////////////////////////
// CppFaxServerGeneral dialog

class CppFaxServerGeneral : public CPropertyPageExImpl<CppFaxServerGeneral>
{

public:
    //
    // Construction
    //
    CppFaxServerGeneral(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           bOwnsNotificationHandle,
             HINSTANCE      hInst);

    //
    // Destraction
    //
    ~CppFaxServerGeneral();

	enum { IDD = IDD_FAXSERVER_GENERAL };

	BEGIN_MSG_MAP(CppFaxServerGeneral)
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
		MESSAGE_HANDLER( WM_ACTIVITY_STATUS_CHANGES, OnActivityStatusChange )

        COMMAND_HANDLER( IDC_SUBMISSION_CHECK, BN_CLICKED, SetApplyButton )
		COMMAND_HANDLER( IDC_TRANSSMI_CHECK,   BN_CLICKED, SetApplyButton )
		COMMAND_HANDLER( IDC_RECEPTION_CHECK,  BN_CLICKED, SetApplyButton )

        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxServerGeneral>)
	END_MSG_MAP()

	//
	// Dialog's Handlers 
	//
	HRESULT InitRPC( );
	LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );    
	LRESULT OnActivityStatusChange( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );    
    BOOL    OnApply();

    HRESULT SetProps(int *pCtrlFocus);
    HRESULT PreApply(int *pCtrlFocus);

private:

    //
    // Configuration Structure members
    //
    FAX_VERSION             m_FaxVersionConfig;
    FAX_SERVER_ACTIVITY     m_FaxServerActivityConfig;
    DWORD                   m_dwQueueStates;

    //
    // Handles
    //
    CFaxServerNode *        m_pParentNode; 
    HANDLE                  m_hActivityNotification;       // Notification registration handle
    LONG_PTR                m_lpNotifyHandle;
    
    BOOL                    m_fIsDialogInitiated;
    BOOL                    m_fIsDirty;

    //
    // Controls
    //
    CEdit                   m_QueuedEdit;
    CEdit                   m_OutgoingEdit;
    CEdit                   m_IncomingEdit;
    

    HRESULT UpdateActivityCounters();

    LRESULT SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};


#endif // _PP_FAXSERVER_GENERAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxserverinbox.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerInbox.h                                     //
//                                                                         //
//  DESCRIPTION   : Fax Server Inbox prop page header file                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 27 1999 yossg  Created                                         //
//      Nov  3 1999 yossg  OnInitDialog, SetProps                          //
//      Nov 15 1999 yossg  Call RPC func                                   //
//      Dec 10 2000 yossg  Update Windows XP                               //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXSERVER_INBOX_H_
#define _PP_FAXSERVER_INBOX_H_

#include "MyCtrls.h"
#include <windows.h>
#include <proppageex.h>
    
class CFaxServerNode;
class CFaxServer;
/////////////////////////////////////////////////////////////////////////////
// CppFaxServerInbox dialog

class CppFaxServerInbox : public CPropertyPageExImpl<CppFaxServerInbox>
{

public:
    //
    // Constructor
    //
    CppFaxServerInbox(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           fIsLocalServer,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxServerInbox();

	enum { IDD = IDD_FAXSERVER_INBOX_ARCHIVE };

	BEGIN_MSG_MAP(CppFaxServerInbox)
		MESSAGE_HANDLER( WM_INITDIALOG,     OnInitDialog )

        COMMAND_HANDLER( IDC_INBOX_BROWSE_BUTTON,  BN_CLICKED, BrowseForDirectory)
        
        COMMAND_HANDLER( IDC_TO_ARCHIVE_CHECK,     BN_CLICKED, ToArchiveCheckboxClicked)
		COMMAND_HANDLER( IDC_INBOX_FOLDER_EDIT,    EN_CHANGE,  EditChanged )

		COMMAND_HANDLER( IDC_GENERATE_WARNING_CHECK,  BN_CLICKED, GenerateEventLogCheckboxClicked)
        COMMAND_HANDLER( IDC_LOW_EDIT,             EN_CHANGE,  EditChanged )
		COMMAND_HANDLER( IDC_HIGH_EDIT,            EN_CHANGE,  EditChanged )
		
		COMMAND_HANDLER( IDC_AUTODEL_CHECK,        BN_CLICKED, AutoDelCheckboxClicked)
        COMMAND_HANDLER( IDC_AUTODEL_EDIT,         EN_CHANGE,  EditChanged )

        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxServerInbox>)
	END_MSG_MAP()

	//
	// Dialog's Handler and events.
	//
	HRESULT InitRPC( );
	LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();


    HRESULT SetProps(int *pCtrlFocus, UINT * puIds);
    HRESULT PreApply(int *pCtrlFocus, UINT * puIds);

private:
    //
    // Control members
    //
    CEdit         m_FolderBox;
    CButton       m_BrowseButton;

    CMyUpDownCtrl m_HighWatermarkSpin;
    CMyUpDownCtrl m_LowWatermarkSpin;
    CMyUpDownCtrl m_AutoDelSpin;
    
    CEdit         m_HighWatermarkBox;
    CEdit         m_LowWatermarkBox;
    CEdit         m_AutoDelBox;

    //
    // Boolean members
    //
    BOOL  m_fAllReadyToApply;
    BOOL  m_fIsDialogInitiated;
    BOOL  m_fIsDirty;

    BOOL  m_fIsLocalServer;


    //
    // Config Structure member
    //
    PFAX_ARCHIVE_CONFIG    m_pFaxArchiveConfig ; 
    
    CComBSTR  m_bstrLastGoodFolder;
    DWORD     m_dwLastGoodSizeQuotaHighWatermark;
    DWORD     m_dwLastGoodSizeQuotaLowWatermark;

    //
    // Handles
    //
    CFaxServerNode * m_pParentNode;    

    //
    // Browse
    //
    BOOL BrowseForDirectory(WORD wNotifyCode, WORD wID, HWND hwndDlg, BOOL& bHandled);

    //
    // Event methods
    //
    LRESULT ToArchiveCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT GenerateEventLogCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT AutoDelCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT EditChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    BOOL AllReadyToApply(BOOL fSilent, int *pCtrlFocus = NULL, UINT *pIds = NULL);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};




#endif // _PP_FAXSERVER_INBOX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxserverlogging.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerLogging.cpp                                 //
//                                                                         //
//  DESCRIPTION   : prop pages of                                          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 25 1999 yossg  created                                         //
//      Nov  3 1999 yossg  OnInitDialog, SetProps                          //
//      Nov 15 1999 yossg  Call RPC func                                   //
//      Nov 24 1999 yossg  OnApply create call to all tabs from parent     //
//      Dec 10 2000 yossg  Update Windows XP                               //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxServerLogging.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "FxsValid.h"
#include "dlgutils.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Constructor
//
CppFaxServerLogging::CppFaxServerLogging(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        fIsLocalServer,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxServerLogging>(pNode, NULL)
{
    m_pParentNode        = static_cast <CFaxServerNode *> (pNode);
    m_pFaxActLogConfig   = NULL;

    m_fIsDialogInitiated = FALSE;
    m_fIsDirty           = FALSE;

    m_fIsLocalServer     = fIsLocalServer;
}


//
// Destructor
//
CppFaxServerLogging::~CppFaxServerLogging()
{
    if (NULL != m_pFaxActLogConfig)
    {
        FaxFreeBuffer( m_pFaxActLogConfig );
    }
}

//////////////////////////////////////////////////////////////////////////////
// CppFaxServerLogging message handlers

/*
 -  CppFaxServerLogging::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerLogging::InitRPC(  )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerLogging::InitRPC"));
    
    HRESULT    hRc = S_OK;
    DWORD      ec  = ERROR_SUCCESS;

    //
    // get RPC Handle
    //   
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Retrieve the fax activity logging configuration structure
    //
    if (!FaxGetActivityLoggingConfiguration(m_pFaxServer->GetFaxServerHandle(), 
                                        &m_pFaxActLogConfig)) 
	{		
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get Activity logging configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(m_pFaxActLogConfig);

    m_bstrLastGoodFolder = m_pFaxActLogConfig->lptstrDBPath;
    if (!m_bstrLastGoodFolder)
    {
		DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Failed to allocate string (m_bstrLastGoodFolder)."));
        ec = ERROR_OUTOFMEMORY;
        
        goto Error;
    }

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get acitivity logging configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    m_pParentNode->NodeMsgBox(GetFaxServerErrorMsg(ec));
Exit:
    return (hRc);
}
   

 /*
 -  CppFaxServerLogging::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
LRESULT CppFaxServerLogging::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerLogging::PageInitDialog"));

	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );

    BOOL        fToCheck;
    UINT        CheckState1;
    UINT        CheckState2;


    //
    // Attach & limit length
    //
    m_LogFileBox.Attach(GetDlgItem(IDC_LOG_FILE_EDIT));
    m_LogFileBox.SetLimitText(MAX_PATH-1);
    
    //
    // init controls
    //
    ATLASSERT(NULL != m_pFaxActLogConfig);

    //
    // To-log activity checkboxes
    //    
    fToCheck = m_pFaxActLogConfig->bLogIncoming;
    CheckState1 = (fToCheck) ? BST_CHECKED : BST_UNCHECKED;
    CheckDlgButton(IDC_INCOMING_LOG_CHECK, CheckState1);

    fToCheck = m_pFaxActLogConfig->bLogOutgoing;
    CheckState2 = (fToCheck) ? BST_CHECKED : BST_UNCHECKED;
    CheckDlgButton(IDC_OUTGOING_LOG_CHECK, CheckState2);

    //
    //  Log file address
    //
    m_LogFileBox.SetWindowText(m_pFaxActLogConfig->lptstrDBPath);

    //
    // Inactivate m_LogFileBox
    //
    if ( !(CheckState1 || CheckState2) )
    {
        EnableDataBasePath(FALSE);
    }
    else
    {
        EnableDataBasePath(TRUE); // To check IsLocalServer for Browse button
    }

    m_fIsDialogInitiated = TRUE;

    return(1);
}

/*
 -  CppFaxServerLogging::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      IN pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerLogging::SetProps(int *pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerLogging::SetProps"));
    HRESULT     hRc = S_OK;
    DWORD       ec  = ERROR_SUCCESS;
    BOOL        fSkipMessage = FALSE;

    CComBSTR    bstrLogFile;

    UINT        uRetIDS   = 0;

    FAX_ACTIVITY_LOGGING_CONFIG   FaxActLogConfig;

    HINSTANCE      hInst  = _Module.GetResourceInstance();

    //
    // Collect all data and init the structure's fields 
    // uses Copy() to copy and also allocate before
    //
    ZeroMemory (&FaxActLogConfig, sizeof(FAX_ACTIVITY_LOGGING_CONFIG));

    //
    // Size of struct.
    //
    FaxActLogConfig.dwSizeOfStruct = sizeof(FAX_ACTIVITY_LOGGING_CONFIG);

    //
    // To log incoming activity
    //
    if (IsDlgButtonChecked(IDC_INCOMING_LOG_CHECK) == BST_CHECKED)   
    {
        FaxActLogConfig.bLogIncoming = TRUE;
    }
    else
    {
        FaxActLogConfig.bLogIncoming = FALSE;
    }

    //
    // To log outgoing activity
    //
    if (IsDlgButtonChecked(IDC_OUTGOING_LOG_CHECK) == BST_CHECKED)   
    {
        FaxActLogConfig.bLogOutgoing = TRUE;
    }
    else
    {
        FaxActLogConfig.bLogOutgoing = FALSE;
    }

    if ( FaxActLogConfig.bLogIncoming || FaxActLogConfig.bLogOutgoing )
    {
        //
        // Log file
        //
        if ( !m_LogFileBox.GetWindowText(&bstrLogFile) )
        {
            *pCtrlFocus = IDC_LOG_FILE_EDIT;
            DebugPrintEx(
		            DEBUG_ERR,
		            TEXT("Failed to GetWindowText(&bstrLogFile)"));
        }
        
        if (!IsNotEmptyString(bstrLogFile))
        {
            DebugPrintEx( DEBUG_ERR,
			    _T("Log file path string empty or spaces only."));
            uRetIDS = IDS_LOG_PATH_EMPTY;

            *pCtrlFocus = IDC_LOG_FILE_EDIT;
        
            goto Error;
        }
        FaxActLogConfig.lptstrDBPath = bstrLogFile;
        
        //
        // follow-up for an OnApply following submition
        // with both unchecked IDC_OUTGOING_LOG_CHECK and IDC_INCOMING_LOG_CHECK
        //
        m_bstrLastGoodFolder         = bstrLogFile; 
        if (!m_bstrLastGoodFolder)
        {
            *pCtrlFocus = IDC_LOG_FILE_EDIT;
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to allocate string (m_bstrLastGoodFolder)."));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }
    }
    else
    {
        FaxActLogConfig.lptstrDBPath = m_bstrLastGoodFolder; 
    }

    //
    // get RPC Handle
    //   
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        goto Error;
    }

    //
    // Set Config
    //
    if (!FaxSetActivityLoggingConfiguration(
                            m_pFaxServer->GetFaxServerHandle(),
                            &FaxActLogConfig)) 
	{		
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to Set Activity Logging configuration. (ec: %ld)"), 
			ec);


        DWORD dwIDS = 0;
        switch (ec)
        {
            case ERROR_PATH_NOT_FOUND:
            
                DebugPrintEx( DEBUG_ERR, _T("ERROR_PATH_NOT_FOUND == ec"));
                dwIDS = IDS_LOGGING_ERROR_PATH_NOT_FOUND;
                break;

            case ERROR_DISK_FULL:

                DebugPrintEx( DEBUG_ERR, _T("ERROR_DISK_FULL == ec"));
                dwIDS = IDS_LOGGING_ERROR_DISK_FULL;
                break;
    
            case FAX_ERR_FILE_ACCESS_DENIED:

                DebugPrintEx( DEBUG_ERR, _T("FAX_ERR_FILE_ACCESS_DENIED == ec"));
                dwIDS = IDS_LOGGING_FAX_ERR_FILE_ACCESS_DENIED;
                break;
        
        }
        if ( 0 != dwIDS ) // a specfic error was found
        {
            if (PropSheet_SetCurSelByID( GetParent(), IDD) )
            {
                PageError(dwIDS, m_hWnd);
                GotoDlgCtrl(GetDlgItem(IDC_LOG_FILE_EDIT));
            }
            fSkipMessage = TRUE;

            goto Error; 
        }

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }
        
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    m_fIsDirty = FALSE;

    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to set Activity Logging configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);

    if (!fSkipMessage)
    {
        PropSheet_SetCurSelByID( GetParent(), IDD);         
        ATLASSERT(::IsWindow(m_hWnd));
        PageError(GetFaxServerErrorMsg(ec), m_hWnd);
    }

Exit:    
    return(hRc);
}


/*
 -  CppFaxServerLogging::PreApply
 -
 *  Purpose:
 *      Checks properties before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerLogging::PreApply(int *pCtrlFocus, UINT * puIds)
{
    HRESULT hRc = S_OK;
    
    //
    // PreApply Checks
    //
    if (!AllReadyToApply(/*fSilent =*/ FALSE, pCtrlFocus , puIds))
    {
        SetModified(FALSE);  
        hRc = E_FAIL ;
    }
    else
    {
        SetModified(TRUE);  
    }

    return(hRc);
}

/*
 -  CppFaxServerLogging::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxServerLogging::OnApply()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerLogging::OnApply"));

    HRESULT  hRc  = S_OK;
    int     CtrlFocus = 0;
    UINT    uIds = 0;

    if (!m_fIsDirty)
    {
        return TRUE;
    }

    hRc = PreApply(&CtrlFocus, &uIds);
    if (FAILED(hRc))
    {
        if (PropSheet_SetCurSelByID( GetParent(), IDD) )
        {
            PageError(uIds, m_hWnd, _Module.GetResourceInstance());
            
            if (CtrlFocus)
            {
                GotoDlgCtrl(GetDlgItem(CtrlFocus));
            }
        }
        return FALSE;
    }
    else //(Succeeded(hRc))
    {
        hRc = SetProps(&CtrlFocus);
        if (FAILED(hRc)) 
        {
            //Error Msg by called func.
            if (CtrlFocus)
            {
                GotoDlgCtrl(GetDlgItem(CtrlFocus));
            }
            return FALSE;
        }
        else //(Succeeded(hRc))
        {
            return TRUE;
        }
    }

}


/*
 +  Routine Description:
 +
 *      Browse for a directory
 *
 *  Arguments:
 *
 *      hwndDlg - Specifies the dialog window on which the Browse button is displayed
 *
 *  Return Value:
 *  
 *      TRUE if successful, FALSE if the user presses Cancel
 -
 -
 */
BOOL
CppFaxServerLogging::BrowseForFile( WORD wNotifyCode, WORD wID, HWND hwndDlg, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER( wNotifyCode );
	UNREFERENCED_PARAMETER( wID );
	UNREFERENCED_PARAMETER( hwndDlg );
	UNREFERENCED_PARAMETER( bHandled );

    DEBUG_FUNCTION_NAME( _T("CppFaxServerLogging::BrowseForFile"));

    BOOL            fResult = FALSE;

    WCHAR           szBrowseFile[MAX_PATH];
    WCHAR           szBrowseDlgTitle[FXS_MAX_TITLE_LEN];
    CComBSTR        bstrOldPath;
    unsigned int    len;

    unsigned long   ulBrowseFlags;

    //
    // Collecting the browse dialog headline
    //
    if (!LoadString( _Module.GetResourceInstance(), 
                IDS_GET_LOG_FILE, 
                szBrowseDlgTitle, 
                FXS_MAX_TITLE_LEN))
    {
        DWORD ec;
        ec = GetLastError();
        if (ec == ERROR_NOT_ENOUGH_MEMORY)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Out of Memory - fail to load string."));
            DlgMsgBox(this, IDS_MEMORY);
            return fResult;
        }
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to load titile string - unexpected behavior."));
        
        szBrowseDlgTitle[0] = 0;
    }

    //
    // Collecting the old path from the calling dialog edit box
    //
    if(! GetDlgItemText( IDC_LOG_FILE_EDIT, bstrOldPath.m_str))
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to collect old path from the property page edit box."));
        szBrowseFile[0] = 0;
    }
    else
    {
         len = bstrOldPath.Length();
         if ( len > MAX_PATH )
         {
             DebugPrintEx(
		        DEBUG_ERR,
		        _T("Old Path Length is bigger then alowed maximal path."));
             szBrowseFile[0] = 0;
         }
         else 
         {
             wcsncpy(szBrowseFile,bstrOldPath,MAX_PATH);
             szBrowseFile[MAX_PATH-1]=L'\0';
         }
    }

    //
    // Preparing the browse dialog style flags.
    //
    ulBrowseFlags       = BIF_BROWSEINCLUDEFILES | //the files also flag
                          BIF_STATUSTEXT | 
                          BIF_USENEWUI | 
                          BIF_VALIDATE;

    //
    // Invoke the browse dialog with a function based on 
    // Shell functions.
    //
    if (InvokeBrowseDialog(  
                    (unsigned short *)&szBrowseFile, 
                    (const unsigned short *)&szBrowseDlgTitle,
                    ulBrowseFlags,
                    this))
    {
        SetDlgItemText(IDC_LOG_FILE_EDIT, szBrowseFile);
        fResult = TRUE;
    }


    return fResult;
}

/*
 -  CppFaxServerLogging::SetApplyButton
 -
 *  Purpose:
 *      Modify Apply buttton.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerLogging::SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }
    
    SetModified(TRUE);  
    bHandled = TRUE;
    return(1);
}


/*
 -  CppFaxServerLogging::OnCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray controls
 *      Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerLogging::OnCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL fActivate = FALSE;
    
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 1;
    }
    else
    {
        m_fIsDirty = TRUE;
    }
    

    if ( 
        BST_CHECKED == IsDlgButtonChecked(IDC_INCOMING_LOG_CHECK) 
      ||
        BST_CHECKED == IsDlgButtonChecked(IDC_OUTGOING_LOG_CHECK)  
       )
    {
        if (AllReadyToApply(TRUE))
        {
            SetModified(TRUE);  
        }
        else
        {
            SetModified(FALSE);  
        }
        
        fActivate = TRUE;

    }
    else
    {
        SetModified(TRUE);  
    }
    EnableDataBasePath(fActivate);

    return(1);
}


/*
 -  CppFaxServerLogging::OnCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray controls
 *      Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerLogging::OnTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL fActivate = FALSE;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 1;
    }
    else
    {
        m_fIsDirty = TRUE;
    }
    

    if (AllReadyToApply(TRUE))
    {
        SetModified(TRUE);  
    }
    else
    {
        SetModified(FALSE);  
    }

    return(1);
}


/*
 -  CppFaxServerLogging::AllReadyToApply
 -
 *  Purpose:
 *      This function validate that no zero length strings 
 *      are found data areas that should be saved.
 *
 *  Arguments:
 *      [in] fSilent - boolean who defines if to pop up messages (FALSE)
 *           or not.(TRUE)
 *
 *  Return:
 *      BOOOLEAN
 */
BOOL CppFaxServerLogging::AllReadyToApply(BOOL fSilent, int *pCtrlFocus, UINT *pIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerLogging::AllReadyToApply"));
	
    DWORD  ec  = ERROR_SUCCESS;
    
    if ( 
            BST_CHECKED == IsDlgButtonChecked(IDC_INCOMING_LOG_CHECK) 
          ||
            BST_CHECKED == IsDlgButtonChecked(IDC_OUTGOING_LOG_CHECK)  
        )
    {
        if ( !m_LogFileBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Zero text length - m_LogFileBox. (ec: %ld)"), 
			    ec);
        
            if (!fSilent)
            {
                *pCtrlFocus = IDC_LOG_FILE_EDIT;
                *pIds = IDS_LOG_PATH_EMPTY;
            }
            return FALSE;    
        }
    }

    ATLASSERT(ERROR_SUCCESS == ec);
    
    //
	// Cheers! 
	//		...every thing ready to apply now.
	//
	return TRUE;           
}

/*
 -  CppFaxServerLogging::EnableDataBasePath
 -
 *  Purpose:
 *      Enable/dissable the data base path controls.
 *
 *  Arguments:
 *      [in] state - boolean value to enable TRUE or FALSE to disable
 *
 *  Return:
 *      void
 */
void CppFaxServerLogging::EnableDataBasePath(BOOL fState)
{
    ::EnableWindow(GetDlgItem(IDC_LOG_FILE_EDIT), fState);
    ::EnableWindow(GetDlgItem(IDC_LOG_BROWSE_BUTTON), fState && m_fIsLocalServer);
    ::EnableWindow(GetDlgItem(IDC_DATABASE_FSTATIC), fState);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxServerLogging::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxServerLogging::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxServerLogging::OnHelpRequest"));
    
    HELPINFO* helpinfo;
    DWORD     dwHelpId;

    switch (uMsg) 
    { 
        case WM_HELP: 

            helpinfo = (HELPINFO*)lParam;
            if (helpinfo->iContextType == HELPINFO_WINDOW)
            {
                ::WinHelp(
                          (HWND) helpinfo->hItemHandle,
                          FXS_ADMIN_HLP_FILE, 
                          HELP_CONTEXTPOPUP, 
                          (DWORD) helpinfo->dwContextId 
                       ); 
            }
            break; 
 
        case WM_CONTEXTMENU: 
            
            dwHelpId = ::GetWindowContextHelpId((HWND)wParam);
            if (dwHelpId) 
            {
                ::WinHelp
                       (
                         (HWND)wParam,
                         FXS_ADMIN_HLP_FILE, 
                         HELP_CONTEXTPOPUP, 
                         dwHelpId
                       );
            }
            break; 
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxserveroutbox.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerOutbox.cpp                                  //
//                                                                         //
//  DESCRIPTION   : prop pages of                                          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 25 1999 yossg  created                                         //
//      Nov  3 1999 yossg  OnInitDialog, SetProps                          //
//      Nov 15 1999 yossg  Call RPC func                                   //
//      Nov 24 1999 yossg  OnApply create call to all tabs from parent     //
//                         add Branding                                    //
//      Apr 24 2000 yossg  Add discount rate time                          //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxServerOutbox.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "FxsValid.h"
#include "dlgutils.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Constructor
//
CppFaxServerOutbox::CppFaxServerOutbox(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        bOwnsNotificationHandle,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxServerOutbox>(pNode, NULL)
			                	
{
    m_pParentNode = static_cast <CFaxServerNode *> (pNode);
    m_pFaxOutboxConfig = NULL;

    m_fAllReadyToApply  = FALSE;
    m_fIsDialogInitiated = FALSE;
    
    m_fIsDirty              = FALSE;
}


//
// Destructor
//
CppFaxServerOutbox::~CppFaxServerOutbox()
{
    if (NULL != m_pFaxOutboxConfig)
    {
        FaxFreeBuffer( m_pFaxOutboxConfig );
    }
}


/////////////////////////////////////////////////////////////////////////////
// CppFaxServerOutbox message handlers

/*
 -  CppFaxServerOutbox::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerOutbox::InitRPC(  )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerOutbox::InitRPC"));
    
    HRESULT    hRc = S_OK;
    DWORD      ec  = ERROR_SUCCESS;

    //
    // get RPC Handle
    //   


    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

	//
	// Retrieve the fax Archive configuration
	//
    if (!FaxGetOutboxConfiguration(m_pFaxServer->GetFaxServerHandle(), 
                                    &m_pFaxOutboxConfig)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get SMTP configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(m_pFaxOutboxConfig);


	
    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get outbox configuration."));

    goto Exit;

Error:
	ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    m_pParentNode->NodeMsgBox(GetFaxServerErrorMsg(ec));

Exit:
    return (hRc);
    
}

    
 /*
 -  CppFaxServerOutbox::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
LRESULT CppFaxServerOutbox::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerOutbox::PageInitDialog"));

	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );

    BOOL        fToCheck;
    UINT        CheckState;
    int         iRetries,
                iRetryDelay,
                iAgeLimit;
    
    TCHAR       tszSecondsFreeTimeFormat[FXS_MAX_TIMEFORMAT_LEN];
    SYSTEMTIME  stStart;
    SYSTEMTIME  stStop;


    //
    // Attach controls
    // 
    m_RetriesBox.Attach(GetDlgItem(IDC_RETRIES_EDIT));
    m_RetryDelayBox.Attach(GetDlgItem(IDC_RETRYDELAY_EDIT));
    m_DaysBox.Attach(GetDlgItem(IDC_DAYS_EDIT));

    m_RetriesBox.SetLimitText(FXS_RETRIES_LENGTH);
    m_RetryDelayBox.SetLimitText(FXS_RETRYDELAY_LENGTH);
    m_DaysBox.SetLimitText(FXS_DIRTYDAYS_LENGTH);

    m_RetriesSpin.Attach(GetDlgItem(IDC_RETRIES_SPIN));
    m_RetryDelaySpin.Attach(GetDlgItem(IDC_RETRYDELAY_SPIN));
    m_DaysSpin.Attach(GetDlgItem(IDC_DAYS_SPIN));

    m_StartTimeCtrl.Attach(GetDlgItem(IDC_DISCOUNT_START_TIME));
    m_StopTimeCtrl.Attach(GetDlgItem(IDC_DISCOUNT_STOP_TIME));

    //
    // Set Time Format
    //
    
    //
    // GetSecondsFreeTimeFormat is a util func
    // which builds TimeFormat according UserLocal without seconds 
    // If any internal failure occures - an hardcoded default seconds free 
    // time format ("hh:mm tt") is retreived.
    //
    GetSecondsFreeTimeFormat(tszSecondsFreeTimeFormat, FXS_MAX_TIMEFORMAT_LEN);

    m_StartTimeCtrl.SetFormat(tszSecondsFreeTimeFormat);
    m_StopTimeCtrl.SetFormat(tszSecondsFreeTimeFormat);

    //
    // init controls
    // 
    ATLASSERT(NULL != m_pFaxOutboxConfig);
    
    //
    // Branding
    //
    fToCheck = m_pFaxOutboxConfig->bBranding;
    CheckState = (fToCheck) ? BST_CHECKED : BST_UNCHECKED;
    CheckDlgButton(IDC_BRANDING_CHECK, CheckState) ;

    //
    //ALLOW_PERSONAL_CHECK
    //
    fToCheck = m_pFaxOutboxConfig->bAllowPersonalCP;
    CheckState = (fToCheck) ? BST_CHECKED : BST_UNCHECKED;
    CheckDlgButton(IDC_ALLOW_PERSONAL_CHECK, CheckState) ;

    //
    //TSID_CHECK
    //
    fToCheck = m_pFaxOutboxConfig->bUseDeviceTSID;
    CheckState = (fToCheck) ? BST_CHECKED  : BST_UNCHECKED;
    CheckDlgButton(IDC_TSID_CHECK, CheckState) ;

    //
    // Retries
    //
    iRetries = (int)m_pFaxOutboxConfig->dwRetries;

    m_RetriesSpin.SetRange(FXS_RETRIES_LOWER, FXS_RETRIES_UPPER);
    m_RetriesSpin.SetPos(iRetries);

    //
    // Retry Delay
    //
    iRetryDelay = (int)m_pFaxOutboxConfig->dwRetryDelay;

    m_RetryDelaySpin.SetRange(FXS_RETRYDELAY_LOWER, FXS_RETRYDELAY_UPPER);
    m_RetryDelaySpin.SetPos(iRetryDelay);

    //
    // Message life-time / dirty days / age limit
    //
    iAgeLimit = (int)m_pFaxOutboxConfig->dwAgeLimit;

    m_DaysSpin.SetRange(FXS_DIRTYDAYS_LOWER, FXS_DIRTYDAYS_UPPER);
    m_DaysSpin.SetPos(iAgeLimit);

    //
    // Discount rate time
    //
    ::GetLocalTime(&stStart);
    ::GetLocalTime(&stStop);

    
    stStart.wHour   = m_pFaxOutboxConfig->dtDiscountStart.Hour;
    stStart.wMinute = m_pFaxOutboxConfig->dtDiscountStart.Minute;

    stStop.wHour    = m_pFaxOutboxConfig->dtDiscountEnd.Hour;
    stStop.wMinute  = m_pFaxOutboxConfig->dtDiscountEnd.Minute;

    if (!m_StartTimeCtrl.SetSystemTime(GDT_VALID, &stStart))
	{
		DebugPrintEx(DEBUG_ERR, _T("Fail to SetSystemTime for discount start."));
	}
    if (!m_StopTimeCtrl.SetSystemTime(GDT_VALID, &stStop))
	{
		DebugPrintEx(DEBUG_ERR, _T("Fail to SetSystemTime for discount end."));
	}

    //
    // Auto Delete
    //
    if (FXS_DIRTYDAYS_ZERO == iAgeLimit)
    {
      CheckDlgButton(IDC_DELETE_CHECK, BST_UNCHECKED);

      ::EnableWindow(GetDlgItem(IDC_DAYS_EDIT), FALSE);
      ::EnableWindow(GetDlgItem(IDC_DAYS_SPIN), FALSE);
    }
    else
    {
      CheckDlgButton(IDC_DELETE_CHECK, BST_CHECKED);
    }

    m_fIsDialogInitiated = TRUE;

    return(1);
}

/*
 -  CppFaxServerOutbox::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerOutbox::SetProps(int *pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerOutbox::SetProps"));
    HRESULT     hRc = S_OK;
    DWORD       ec  = ERROR_SUCCESS;

    HINSTANCE   hInst  = _Module.GetResourceInstance();


    SYSTEMTIME  stStart;
    SYSTEMTIME  stStop;

    FAX_OUTBOX_CONFIG   FaxOutboxConfig;

    ATLASSERT(TRUE == m_fAllReadyToApply);
    m_fAllReadyToApply = FALSE;

    //
    // Collect all data and init the structure's fields 
    // uses Copy() to copy and also allocate before
    //
    ZeroMemory (&FaxOutboxConfig, sizeof(FAX_OUTBOX_CONFIG));

    //
    // Size of struct.
    //
    FaxOutboxConfig.dwSizeOfStruct = sizeof(FAX_OUTBOX_CONFIG);

    //
    // Branding
    //
    if (IsDlgButtonChecked(IDC_BRANDING_CHECK) == BST_CHECKED)   
    {
        FaxOutboxConfig.bBranding = TRUE;
    }
    else
    {
        FaxOutboxConfig.bBranding = FALSE;
    }

    //
    // IDC_ALLOW_PERSONAL_CHECK
    //
    if (IsDlgButtonChecked(IDC_ALLOW_PERSONAL_CHECK) == BST_CHECKED)   
    {
        FaxOutboxConfig.bAllowPersonalCP = TRUE;
    }
    else
    {
        FaxOutboxConfig.bAllowPersonalCP = FALSE;
    }
    
    //
    // IDC_TSID_CHECK
    //
    if (IsDlgButtonChecked(IDC_TSID_CHECK) == BST_CHECKED)   
    {
        FaxOutboxConfig.bUseDeviceTSID = TRUE;
    }
    else
    {
        FaxOutboxConfig.bUseDeviceTSID = FALSE;
    }
    
    //
    // Retries, Retry Delay
    //
    int iRetries = m_RetriesSpin.GetPos();
    FaxOutboxConfig.dwRetries = (DWORD) iRetries;

    int iRetryDelay = m_RetryDelaySpin.GetPos();
    FaxOutboxConfig.dwRetryDelay = (DWORD) iRetryDelay;

    //
    // IDC_DELETE_CHECK  - AutoDelete Messages
    //
    if (IsDlgButtonChecked(IDC_DELETE_CHECK) == BST_CHECKED)   
    {
       int iAgeLimit = m_DaysSpin.GetPos();
       FaxOutboxConfig.dwAgeLimit = (DWORD) iAgeLimit;
    }
    else
    {
       FaxOutboxConfig.dwAgeLimit = (DWORD) FXS_DIRTYDAYS_ZERO;
    }
    
    //
    // Discount rate time
    //
    m_StartTimeCtrl.GetSystemTime(&stStart);
    m_StopTimeCtrl.GetSystemTime(&stStop);

    FaxOutboxConfig.dtDiscountStart.Hour    = stStart.wHour;
    FaxOutboxConfig.dtDiscountStart.Minute  = stStart.wMinute;
    FaxOutboxConfig.dtDiscountEnd.Hour      = stStop.wHour;
    FaxOutboxConfig.dtDiscountEnd.Minute    = stStop.wMinute;

    //
    // get RPC Handle
    //   

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        goto Error;
    }

    //
    // Set Config
    //
    if (!FaxSetOutboxConfiguration(
                m_pFaxServer->GetFaxServerHandle(),
                &FaxOutboxConfig)) 
	{		
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to Set outbox configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }
        
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    m_fIsDirty = FALSE;

    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to set outbox configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);

    PropSheet_SetCurSelByID( GetParent(), IDD);         
    ATLASSERT(::IsWindow(m_hWnd));
    PageError(GetFaxServerErrorMsg(ec),m_hWnd);

Exit:    
    return(hRc);
}


/*
 -  CppFaxServerOutbox::PreApply
 -
 *  Purpose:
 *      Checks properties before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerOutbox::PreApply(int *pCtrlFocus, UINT * puIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerOutbox::PreApply"));
    HRESULT hRc = S_OK;
    
    //
    // PreApply Checks
    //
    if (!AllReadyToApply(/*fSilent =*/ FALSE, pCtrlFocus , puIds))
    {
        m_fAllReadyToApply = FALSE;
        SetModified(FALSE);  
        hRc = E_FAIL ;
    }
    else
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }

    return(hRc);
}

/*
 -  CppFaxServerOutbox::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxServerOutbox::OnApply()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerOutbox::OnApply"));


    HRESULT  hRc  = S_OK;
    int     CtrlFocus = 0;
    UINT    uIds = 0;

    if (!m_fIsDirty)
    {
        return TRUE;
    }

    hRc = PreApply(&CtrlFocus, &uIds);
    if (FAILED(hRc))
    {
        if (PropSheet_SetCurSelByID( GetParent(), IDD) )
        {
            PageError(uIds, m_hWnd, _Module.GetResourceInstance());
            
            if (CtrlFocus)
            {
                GotoDlgCtrl(GetDlgItem(CtrlFocus));
            }
        }
        return FALSE;
    }
    else //(Succeeded(hRc))
    {
        hRc = SetProps(&CtrlFocus);
        if (FAILED(hRc)) 
        {
            //Error Msg by called func.
            if (CtrlFocus)
            {
                GotoDlgCtrl(GetDlgItem(CtrlFocus));
            }
            return FALSE;
        }
        else //(Succeeded(hRc))
        {
            return TRUE;
        }
    }

}


/*
 -  CppFaxServerOutbox::OnTimeChange
 -
 *  Purpose:
 *      Gray/Ungray the folder edit box and the
 *      browse button. Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerOutbox::OnTimeChange(int /*idCtrl*/, LPNMHDR /*pnmh*/, BOOL& /*bHandled*/)
{

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }
    

    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return(1);
}

/*
 -  CppFaxServerOutbox::CheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray the folder edit box and the
 *      browse button. Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerOutbox::CheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return(1);
}

/*
 -  CppFaxServerOutbox::AutoDelCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray the spin button and edit box
 *      and enable apply button after Auto Delete Checkbox 
 *      status was changed.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerOutbox::AutoDelCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    State = ( IsDlgButtonChecked(IDC_DELETE_CHECK) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_DAYS_EDIT), State);    
    ::EnableWindow(GetDlgItem(IDC_DAYS_SPIN), State);    

    if (m_fAllReadyToApply)//only last change should be considered
    {
        if ( !m_DaysBox.GetWindowTextLength() )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
        else if ( 0 != HIWORD( m_DaysSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return(1);
}


/*
 -  CppFaxServerOutbox::EditBoxChanged
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerOutbox::EditBoxChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (!m_fIsDialogInitiated)
    {
        return 1;
    }
    else
    {
        m_fIsDirty = TRUE;
    }
        
        
    if (m_fAllReadyToApply) //only last change should be considered
    {
        switch (wID)
        {
            case IDC_RETRIES_EDIT:
                if ( !m_RetriesBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
				break;

            case IDC_RETRYDELAY_EDIT:
                if ( !m_RetryDelayBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
				break;

            case IDC_DAYS_EDIT:
                if ( !m_DaysBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
                else if ( 0 != HIWORD( m_DaysSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
                {
                    m_fAllReadyToApply = FALSE;
                    SetModified(FALSE);
                }
				break;

            default:
                return 1;
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return 1;
}



/*
 -  CppFaxServerOutbox::AllReadyToApply
 -
 *  Purpose:
 *      This function validate that no zero length strings 
 *      are found data areas that should be saved.
 *
 *  Arguments:
 *      [in] fSilent - boolean who defines if to pop up messages (FALSE)
 *           or not.(TRUE)
 *
 *  Return:
 *      BOOOLEAN
 */
BOOL CppFaxServerOutbox::AllReadyToApply(BOOL fSilent, int *pCtrlFocus, UINT *pIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerOutbox::AllReadyToApply"));
	
    DWORD         ec  = ERROR_SUCCESS;
    
    HINSTANCE     hInst = _Module.GetResourceInstance();

    if ( !m_RetriesBox.GetWindowTextLength() )    
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Zero text length - m_RetriesBox. (ec: %ld)"), 
			ec);
    
        if (!fSilent)
        {
            *pIds = IDS_OUTB_RETRIES_EMPTY;
            *pCtrlFocus = IDC_RETRIES_EDIT;
        }
        return FALSE;    
    }

    if ( !m_RetryDelayBox.GetWindowTextLength() )    
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Zero text length - m_RetryDelayBox. (ec: %ld)"), 
			ec);
    
        if (!fSilent)
        {
            *pIds = IDS_OUTB_RETRYDELAY_EMPTY;
            *pCtrlFocus = IDC_RETRYDELAY_EDIT;
        }
        return FALSE;    
    }

    if (IsDlgButtonChecked(IDC_DELETE_CHECK) == BST_CHECKED)
    {
        if ( !m_DaysBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Zero text length - m_DaysBox. (ec: %ld)"), 
			    ec);
        
            if (!fSilent)
            {
                *pIds = IDS_OUTB_DAYS_EMPTY;
                *pCtrlFocus = IDC_DAYS_EDIT;
            }
            return FALSE;    
        }
        else if ( 0 != HIWORD( m_DaysSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Zero value - m_DaysBox."));
        
            if (!fSilent)
            {
                *pIds = IDS_OUTB_DAYS_EMPTY;
                *pCtrlFocus = IDC_DAYS_EDIT;
            }
            return FALSE;    
        }

    }

    ATLASSERT(ERROR_SUCCESS == ec);
    
    //
	// Cheers! 
	//		...every thing ready to apply now.
	//
	return TRUE;           
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxServerOutbox::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxServerOutbox::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxServerOutbox::OnHelpRequest"));
    
    HELPINFO* helpinfo;
    DWORD     dwHelpId;

    switch (uMsg) 
    { 
        case WM_HELP: 

            helpinfo = (HELPINFO*)lParam;
            if (helpinfo->iContextType == HELPINFO_WINDOW)
            {
                ::WinHelp(
                          (HWND) helpinfo->hItemHandle,
                          FXS_ADMIN_HLP_FILE, 
                          HELP_CONTEXTPOPUP, 
                          (DWORD) helpinfo->dwContextId 
                       ); 
            }
            break; 
 
        case WM_CONTEXTMENU: 
            
            dwHelpId = ::GetWindowContextHelpId((HWND)wParam);
            if (dwHelpId) 
            {
                ::WinHelp
                       (
                         (HWND)wParam,
                         FXS_ADMIN_HLP_FILE, 
                         HELP_CONTEXTPOPUP, 
                         dwHelpId
                       );
            }
            break; 
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxserveroutbox.h ===
/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//  DESCRIPTION   : Fax Server Outbox prop page header file                //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 27 1999 yossg  created                                         //
//      Nov  3 1999 yossg  OnInitDialog, SetProps                          //
//      Nov 15 1999 yossg  Call RPC func                                   //
//      Apr 24 2000 yossg  Add discount rate time                          //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXSERVER_OUTBOX_H_
#define _PP_FAXSERVER_OUTBOX_H_

#include "MyCtrls.h"
#include <proppageex.h>

class CFaxServerNode;
class CFaxServer;
/////////////////////////////////////////////////////////////////////////////
// CppFaxServerOutbox dialog

class CppFaxServerOutbox : public CPropertyPageExImpl<CppFaxServerOutbox>
{

public:
    //
    // Constructor
    //
    CppFaxServerOutbox(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           bOwnsNotificationHandle,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxServerOutbox();

	enum { IDD = IDD_FAXSERVER_OUTBOX };

	BEGIN_MSG_MAP(CppFaxServerOutbox)
		MESSAGE_HANDLER( WM_INITDIALOG,     OnInitDialog )

        COMMAND_HANDLER( IDC_BRANDING_CHECK,       BN_CLICKED, CheckboxClicked )
        COMMAND_HANDLER( IDC_ALLOW_PERSONAL_CHECK, BN_CLICKED, CheckboxClicked )

        COMMAND_HANDLER( IDC_TSID_CHECK,           BN_CLICKED, CheckboxClicked )
		
        COMMAND_HANDLER( IDC_RETRIES_EDIT,         EN_CHANGE,  EditBoxChanged  )
		COMMAND_HANDLER( IDC_RETRYDELAY_EDIT,      EN_CHANGE,  EditBoxChanged  )

        COMMAND_HANDLER( IDC_DELETE_CHECK,         BN_CLICKED, AutoDelCheckboxClicked)
        COMMAND_HANDLER( IDC_DAYS_EDIT,            EN_CHANGE,  EditBoxChanged  )

        NOTIFY_HANDLER ( IDC_DISCOUNT_START_TIME,  DTN_DATETIMECHANGE,  OnTimeChange )
        NOTIFY_HANDLER ( IDC_DISCOUNT_STOP_TIME,   DTN_DATETIMECHANGE,  OnTimeChange )

        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxServerOutbox>)
	END_MSG_MAP()

	//
	// Dialog's Handler and events.
	//
	HRESULT InitRPC( );
	LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();

    HRESULT SetProps(int *pCtrlFocus);
    HRESULT PreApply(int *pCtrlFocus, UINT * puIds);

private:
    //
    // Control members
    //
    CMyUpDownCtrl m_RetriesSpin;
    CMyUpDownCtrl m_RetryDelaySpin;
    CMyUpDownCtrl m_DaysSpin;

    CEdit m_RetriesBox;
    CEdit m_RetryDelayBox;
    CEdit m_DaysBox;

    CDateTimePickerCtrl m_StartTimeCtrl;
    CDateTimePickerCtrl m_StopTimeCtrl;

    //
    // Boolean members
    //
    BOOL  m_fAllReadyToApply;
    BOOL  m_fIsDialogInitiated;
    BOOL  m_fIsDirty;

    //
    // Config Structure member
    //
    PFAX_OUTBOX_CONFIG    m_pFaxOutboxConfig;

    //
    // Handles
    //
    CFaxServerNode * m_pParentNode;    

    //
    // Event methods
    //
    LRESULT CheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT EditBoxChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT AutoDelCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnTimeChange(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    BOOL AllReadyToApply(BOOL fSilent, int *pCtrlFocus = NULL, UINT *pIds = NULL);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};


#endif // _PP_FAXSERVER_OUTBOX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxserversentitems.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerSentItems.cpp                               //
//                                                                         //
//  DESCRIPTION   : prop pages of Sent Items Archive                       //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 25 1999 yossg  created                                         //
//      Nov  3 1999 yossg  OnInitDialog, SetProps                          //
//      Nov 15 1999 yossg  Call RPC func                                   //
//      Nov 24 1999 yossg  OnApply create call to all tabs from parent     //
//      Oct 17 2000 yossg                                                  //
//      Dec 10 2000 yossg  Update Windows XP                               //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxServerSentItems.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "FxsValid.h"
#include "dlgutils.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// Constructor
//
CppFaxServerSentItems::CppFaxServerSentItems(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        fIsLocalServer,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxServerSentItems>(pNode, NULL)
{
    m_pParentNode = static_cast <CFaxServerNode *> (pNode);
    m_pFaxArchiveConfig  = NULL;

    m_fAllReadyToApply   = FALSE;
    m_fIsDialogInitiated = FALSE;
    m_fIsDirty           = FALSE;

    m_fIsLocalServer     = fIsLocalServer;
}

//
// Destructor
//
CppFaxServerSentItems::~CppFaxServerSentItems()
{
    if (NULL != m_pFaxArchiveConfig)
    {
        FaxFreeBuffer( m_pFaxArchiveConfig );
    }
}

/////////////////////////////////////////////////////////////////////////////
// CppFaxServerSentItems message handlers
/*
 -  CppFaxServerSentItems::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerSentItems::InitRPC(  )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerSentItems::InitRPC"));
    
    HRESULT    hRc = S_OK;
    DWORD      ec  = ERROR_SUCCESS;

    //
    // get RPC Handle
    //   
    
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

	//
	// Retrieve the fax sent items configuration
	//
    if (!FaxGetArchiveConfiguration(m_pFaxServer->GetFaxServerHandle(), 
                                    FAX_MESSAGE_FOLDER_SENTITEMS, 
                                    &m_pFaxArchiveConfig)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get sent items configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(m_pFaxArchiveConfig);

    //
    // Init specific members for set proprties follow-up
    //
    m_dwLastGoodSizeQuotaHighWatermark = m_pFaxArchiveConfig->dwSizeQuotaHighWatermark;
    m_dwLastGoodSizeQuotaLowWatermark  = m_pFaxArchiveConfig->dwSizeQuotaLowWatermark;
    m_bstrLastGoodFolder               = m_pFaxArchiveConfig->lpcstrFolder;
    if (!m_bstrLastGoodFolder)
    {
		DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Failed to allocate string (m_bstrLastGoodFolder)."));
        ec = ERROR_OUTOFMEMORY;
        
        goto Error;
    }

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get sent items archive configuration."));
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    m_pParentNode->NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}

/*
 -  CppFaxServerSentItems::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
LRESULT CppFaxServerSentItems::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerSentItems::PageInitDialog"));

	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );

    int          iLow,
                 iHigh,
                 iAgeLimit;

    //
    // init controls
    // 
    m_FolderBox.Attach(GetDlgItem(IDC_FOLDER_EDIT));
    m_FolderBox.SetLimitText(MAX_PATH-1);

    m_HighWatermarkBox.Attach(GetDlgItem(IDC_SENT_HIGH_EDIT));
    m_LowWatermarkBox.Attach(GetDlgItem(IDC_SENT_LOW_EDIT));
    m_AutoDelBox.Attach(GetDlgItem(IDC_SENT_AUTODEL_EDIT));

    m_HighWatermarkBox.SetLimitText(FXS_QUOTA_LENGTH);
    m_LowWatermarkBox.SetLimitText(FXS_QUOTA_LENGTH);
    m_AutoDelBox.SetLimitText(FXS_DIRTYDAYS_LENGTH);

    m_HighWatermarkSpin.Attach(GetDlgItem(IDC_SENT_HIGH_SPIN));
    m_LowWatermarkSpin.Attach(GetDlgItem(IDC_SENT_LOW_SPIN));
    m_AutoDelSpin.Attach(GetDlgItem(IDC_SENT_AUTODEL_SPIN));

    ATLASSERT(NULL != m_pFaxArchiveConfig);
    
    //
    // FOLDER_EDIT
    //
    m_FolderBox.SetWindowText(m_pFaxArchiveConfig->lpcstrFolder);

    //
    // Disable Browse button for remote admin
    //
    if (!m_fIsLocalServer)
    {
        ::EnableWindow(GetDlgItem(IDC_SENT_BROWSE_BUTTON), FALSE); 
    }

    //
    // TO_ARCHIVE_CHECK
    //
    if (m_pFaxArchiveConfig->bUseArchive) 
    {
        CheckDlgButton(IDC_SENT_TO_ARCHIVE_CHECK, BST_CHECKED) ;
    }
    else
    {
        CheckDlgButton(IDC_SENT_TO_ARCHIVE_CHECK, BST_UNCHECKED) ;
        ::EnableWindow(GetDlgItem(IDC_FOLDER_EDIT), FALSE);    
        ::EnableWindow(GetDlgItem(IDC_SENT_BROWSE_BUTTON), FALSE);    
    }

    //
    // Quota size - Low
    //
    iLow = (int)m_pFaxArchiveConfig->dwSizeQuotaLowWatermark;

    m_LowWatermarkSpin.SetRange(FXS_QUOTA_LOW_LOWER, FXS_QUOTA_LOW_UPPER);
    m_LowWatermarkSpin.SetPos(iLow);

    //
    // Quota size - High
    //    
    iHigh = (int)m_pFaxArchiveConfig->dwSizeQuotaHighWatermark;

    m_HighWatermarkSpin.SetRange(FXS_QUOTA_HIGH_LOWER, FXS_QUOTA_HIGH_UPPER);
    m_HighWatermarkSpin.SetPos(iHigh);
    
    //
    //Generate event log warning
    //
    if (m_pFaxArchiveConfig->bSizeQuotaWarning) 
    {
        CheckDlgButton(IDC_SENT_GENERATE_WARNING_CHECK, BST_CHECKED) ;
    }
    else
    {
        CheckDlgButton(IDC_SENT_GENERATE_WARNING_CHECK, BST_UNCHECKED) ;
        ::EnableWindow(GetDlgItem(IDC_SENT_HIGH_EDIT), FALSE);    
        ::EnableWindow(GetDlgItem(IDC_SENT_HIGH_SPIN), FALSE);    

        ::EnableWindow(GetDlgItem(IDC_SENT_LOW_EDIT), FALSE);    
        ::EnableWindow(GetDlgItem(IDC_SENT_LOW_SPIN), FALSE);    
    }

    //
    // message Age Limit (dirty days)
    //
    iAgeLimit = (int)m_pFaxArchiveConfig->dwAgeLimit;

    m_AutoDelSpin.SetRange(FXS_DIRTYDAYS_LOWER, FXS_DIRTYDAYS_UPPER);
    m_AutoDelSpin.SetPos(iAgeLimit);

    //
    // Auto Delete
    //
    if (FXS_DIRTYDAYS_ZERO == iAgeLimit)
    {
      CheckDlgButton(IDC_SENT_AUTODEL_CHECK, BST_UNCHECKED);

      ::EnableWindow(GetDlgItem(IDC_SENT_AUTODEL_EDIT), FALSE);
      ::EnableWindow(GetDlgItem(IDC_SENT_AUTODEL_SPIN), FALSE);
    }
    else
    {
      CheckDlgButton(IDC_SENT_AUTODEL_CHECK, BST_CHECKED);
    }

    m_fIsDialogInitiated = TRUE;
    
    return(1);
}

/*
 -  CppFaxServerSentItems::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerSentItems::SetProps(int *pCtrlFocus, UINT * puIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerSentItems::SetProps"));
    HRESULT       hRc = S_OK;
    DWORD         ec  = ERROR_SUCCESS;
    HINSTANCE     hInst     = _Module.GetResourceInstance();


    BOOL          fSkipMessage = FALSE;

    CComBSTR      bstrFolder = L"";

    FAX_ARCHIVE_CONFIG   FaxArchiveConfig;

    ATLASSERT(TRUE == m_fAllReadyToApply);
    m_fAllReadyToApply = FALSE;
    
    //
    // Collect all data and init the structure's fields 
    // uses Copy() to copy and also allocate before
    //
    ZeroMemory (&FaxArchiveConfig, sizeof(FAX_ARCHIVE_CONFIG));

    //
    // Size of struct.
    //
    FaxArchiveConfig.dwSizeOfStruct = sizeof(FAX_ARCHIVE_CONFIG);

    //
    // IDC_SENT_TO_ARCHIVE_CHECK
    //
    if (IsDlgButtonChecked(IDC_SENT_TO_ARCHIVE_CHECK) == BST_CHECKED)   
    {
        FaxArchiveConfig.bUseArchive = TRUE;
        
        //IDC_FOLDER_EDIT
        if ( !m_FolderBox.GetWindowText(&bstrFolder))
        {
            *pCtrlFocus = IDC_FOLDER_EDIT;
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&bstrFolder)"));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }
        if (!IsNotEmptyString(bstrFolder))
        {
            *pCtrlFocus = IDC_FOLDER_EDIT;
            * puIds = IDS_SENT_ARCHIVE_PATH_EMPTY;
            
            DebugPrintEx( DEBUG_ERR,
			    _T("Archive path string is empty or includes spaces only."));
            
            fSkipMessage = TRUE;

            ec = ERROR_INVALID_DATA;
        
            goto Error;
        }
        FaxArchiveConfig.lpcstrFolder = bstrFolder;
        
        //
        // follow-up for an OnApply following submition
        // with unchecked IDC_SENT_TO_ARCHIVE_CHECK
        //
        m_bstrLastGoodFolder          = bstrFolder; 
        if (!m_bstrLastGoodFolder)
        {
            *pCtrlFocus = IDC_FOLDER_EDIT;
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to allocate string (m_bstrLastGoodFolder)."));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }
    }
    else
    {
        FaxArchiveConfig.bUseArchive  = FALSE;
        FaxArchiveConfig.lpcstrFolder = m_bstrLastGoodFolder; 
    }
    
    //
    // IDC_SENT_GENERATE_WARNING_CHECK
    //
    if (IsDlgButtonChecked(IDC_SENT_GENERATE_WARNING_CHECK) == BST_CHECKED)   
    {
        FaxArchiveConfig.bSizeQuotaWarning = TRUE;

        int iHigh = m_HighWatermarkSpin.GetPos();
        FaxArchiveConfig.dwSizeQuotaHighWatermark = (DWORD) iHigh;

        int iLow = m_LowWatermarkSpin.GetPos();
        FaxArchiveConfig.dwSizeQuotaLowWatermark = (DWORD) iLow;

        if (iHigh <= iLow)
        {
            *pCtrlFocus = IDC_SENT_HIGH_EDIT;
            * puIds = IDS_WATERMARK_HI_LOW;
            
            DebugPrintEx( DEBUG_ERR,
			    _T("Watermark High < Low."));
            
            fSkipMessage = TRUE;

            ec = ERROR_INVALID_DATA;
        
            goto Error;
        }
        //
        // follow-up for an OnApply following submition
        // with unchecked IDC_SENT_GENERATE_WARNING_CHECK
        //
        m_dwLastGoodSizeQuotaHighWatermark = (DWORD)iHigh;
        m_dwLastGoodSizeQuotaLowWatermark  = (DWORD)iLow;
    }
    else
    {
        FaxArchiveConfig.bSizeQuotaWarning = FALSE;

        FaxArchiveConfig.dwSizeQuotaHighWatermark = m_dwLastGoodSizeQuotaHighWatermark;
        FaxArchiveConfig.dwSizeQuotaLowWatermark  = m_dwLastGoodSizeQuotaLowWatermark;
    }
    
    //
    // IDC_SENT_AUTODEL_CHECK  - AutoDelete Messages
    //
    if (IsDlgButtonChecked(IDC_SENT_AUTODEL_CHECK) == BST_CHECKED)   
    {       
        int iAgeLimit = m_AutoDelSpin.GetPos();
        FaxArchiveConfig.dwAgeLimit = (DWORD) iAgeLimit;
    }
    else
    {
        FaxArchiveConfig.dwAgeLimit = (DWORD)FXS_DIRTYDAYS_ZERO;
    }
        
    //
    // get RPC Handle
    //   
    
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        goto Error;
    }

    //
    // Set Config
    //
    if (!FaxSetArchiveConfiguration(
                m_pFaxServer->GetFaxServerHandle(),
                FAX_MESSAGE_FOLDER_SENTITEMS,
                &FaxArchiveConfig)) 
    {		
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to Set sent items configuration. (ec: %ld)"), 
			ec);

        DWORD dwIDS = 0;
        switch (ec)
        {
            case ERROR_PATH_NOT_FOUND:
            
                DebugPrintEx( DEBUG_ERR, _T("ERROR_PATH_NOT_FOUND == ec"));
                dwIDS = IDS_SENT_ERROR_PATH_NOT_FOUND;
                break;

            case ERROR_DISK_FULL:

                DebugPrintEx( DEBUG_ERR, _T("ERROR_DISK_FULL == ec"));
                dwIDS = IDS_SENT_ERROR_DISK_FULL;
                break;
    
            case FAX_ERR_FILE_ACCESS_DENIED:

                DebugPrintEx( DEBUG_ERR, _T("FAX_ERR_FILE_ACCESS_DENIED == ec"));
                dwIDS = IDS_SENT_FAX_ERR_FILE_ACCESS_DENIED;
                break;
        
            case FAX_ERR_NOT_NTFS:
                
                DebugPrintEx( DEBUG_ERR, _T("FAX_ERR_NOT_NTFS == ec"));
                dwIDS = IDS_SENT_FAX_ERR_NOT_NTFS;
                break;

        }
        if ( 0 != dwIDS ) // a specfic error was found
        {
            if (PropSheet_SetCurSelByID( GetParent(), IDD) )
            {
                PageError(dwIDS, m_hWnd);
                GotoDlgCtrl(GetDlgItem(IDC_FOLDER_EDIT));
            }
            fSkipMessage = TRUE;

            goto Error; 
        }

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }
        
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    m_fIsDirty = FALSE;

    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to set sent-items archive configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
    if (!fSkipMessage)
    {
        PropSheet_SetCurSelByID( GetParent(), IDD);         
        ATLASSERT(::IsWindow(m_hWnd));
        PageError(GetFaxServerErrorMsg(ec),m_hWnd);
    }

Exit:    
    return(hRc);
}



/*
 -  CppFaxServerSentItems::PreApply
 -
 *  Purpose:
 *      Checks properties before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerSentItems::PreApply(int *pCtrlFocus, UINT * puIds)
{
    HRESULT hRc = S_OK;
    
    //
    // PreApply Checks
    //
    if (!AllReadyToApply(/*fSilent =*/ FALSE, pCtrlFocus , puIds))
    {
        m_fAllReadyToApply = FALSE;
        SetModified(FALSE);  
        hRc = E_FAIL ;
    }
    else
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }

    return(hRc);
}


/*
 -  CppFaxServerSentItems::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxServerSentItems::OnApply()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerSentItems::OnApply"));

    HRESULT  hRc  = S_OK;
    int     CtrlFocus = 0;
    UINT    uIds = 0;

    if (!m_fIsDirty)
    {
        return TRUE;
    }

    hRc = PreApply(&CtrlFocus, &uIds);
    if (FAILED(hRc))
    {
        if (PropSheet_SetCurSelByID( GetParent(), IDD) )
        {
            ATLASSERT(uIds);
            PageError(uIds, m_hWnd, _Module.GetResourceInstance());
            
            if (CtrlFocus)
            {
                GotoDlgCtrl(GetDlgItem(CtrlFocus));
            }
        }
        return FALSE;
    }
    else //(Succeeded(hRc))
    {
        hRc = SetProps(&CtrlFocus, &uIds);
        if (FAILED(hRc)) 
        {
            if (uIds)
            {
                if (PropSheet_SetCurSelByID( GetParent(), IDD) )
                {
                    PageError(uIds, m_hWnd, _Module.GetResourceInstance());
            
                    if (CtrlFocus)
                    {
                        GotoDlgCtrl(GetDlgItem(CtrlFocus));
                    }
                }
            }
            //else Error Msg by called func.
            return FALSE;
        }
        else //(Succeeded(hRc))
        {
            return TRUE;
        }
    }

}

/*
 -  CppFaxServerInbox::ToArchiveCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray the folder edit box and the
 *      browse button. Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerSentItems::ToArchiveCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;
    
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    State = ( IsDlgButtonChecked(IDC_SENT_TO_ARCHIVE_CHECK) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_FOLDER_EDIT), State);    
    ::EnableWindow(GetDlgItem(IDC_SENT_BROWSE_BUTTON), State && m_fIsLocalServer);    

    if (m_fAllReadyToApply)//only last change should be considered
    {
        if ( !m_FolderBox.GetWindowTextLength() )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return 1;
}

/*
 -  CppFaxServerSentItems::GenerateEventLogCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray the spin buttons and edit boxes
 *      Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerSentItems::GenerateEventLogCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }
    
    State = ( IsDlgButtonChecked(IDC_SENT_GENERATE_WARNING_CHECK) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_SENT_HIGH_EDIT), State);    
    ::EnableWindow(GetDlgItem(IDC_SENT_HIGH_SPIN), State);    
    ::EnableWindow(GetDlgItem(IDC_SENT_QUOTA_HIGH_STATIC), State);    
    ::EnableWindow(GetDlgItem(IDC_SENT_MB1_STATIC), State);    

    ::EnableWindow(GetDlgItem(IDC_SENT_LOW_EDIT), State);    
    ::EnableWindow(GetDlgItem(IDC_SENT_LOW_SPIN), State);    
    ::EnableWindow(GetDlgItem(IDC_SENT_QUOTA_LOW_STATIC), State);    
    ::EnableWindow(GetDlgItem(IDC_SENT_MB2_STATIC), State);    

    if (m_fAllReadyToApply)//only last change should be considered
    {
        if ( !m_HighWatermarkBox.GetWindowTextLength() )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
        else if ( 0 != HIWORD( m_HighWatermarkSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
        else if ( !m_LowWatermarkBox.GetWindowTextLength() )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return(1);
}

/*
 -  CppFaxServerSentItems::AutoDelCheckboxClicked
 -
 *  Purpose:
 *      Gray/Ungray the spin button and edit box
 *      and enable apply button after Auto Delete Checkbox 
 *      status was changed.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerSentItems::AutoDelCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    State = ( IsDlgButtonChecked(IDC_SENT_AUTODEL_CHECK) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_SENT_AUTODEL_EDIT), State);    
    ::EnableWindow(GetDlgItem(IDC_SENT_AUTODEL_SPIN), State);    

    if (m_fAllReadyToApply)//only last change should be considered
    {
        if ( !m_AutoDelBox.GetWindowTextLength() )    
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
        else if ( 0 != HIWORD( m_AutoDelSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
        {
            m_fAllReadyToApply = FALSE;
            SetModified(FALSE);
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return(1);
}

/*
 +  Routine Description:
 +
 *      Browse for a directory
 *
 *  Arguments:
 *
 *      hwndDlg - Specifies the dialog window on which the Browse button is displayed
 *
 *  Return Value:
 *  
 *      TRUE if successful, FALSE if the user presses Cancel
 -
 -
 */
BOOL
CppFaxServerSentItems::BrowseForDirectory( WORD wNotifyCode, WORD wID, HWND hwndDlg, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER( wNotifyCode );
	UNREFERENCED_PARAMETER( wID );
	UNREFERENCED_PARAMETER( hwndDlg );
	UNREFERENCED_PARAMETER( bHandled );

    DEBUG_FUNCTION_NAME( _T("CppFaxServerSentItems::BrowseForDirectory"));

    BOOL            fResult = FALSE;

    WCHAR           szBrowseFolder[MAX_PATH];
    WCHAR           szBrowseDlgTitle[FXS_MAX_TITLE_LEN];
    CComBSTR        bstrOldPath;
    unsigned int    len;

    unsigned long   ulBrowseFlags;

    //
    // Collecting the browse dialog headline
    //
    if (!LoadString( _Module.GetResourceInstance(), 
                IDS_GET_ARCHIVE_DIRECTORY, 
                szBrowseDlgTitle, 
                FXS_MAX_TITLE_LEN))
    {
        DWORD ec;
        ec = GetLastError();
        if (ec == ERROR_NOT_ENOUGH_MEMORY)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Out of Memory - fail to load string."));
            DlgMsgBox(this, IDS_MEMORY);
            return fResult;
        }
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to load titile string - unexpected behavior."));
        
        szBrowseDlgTitle[0] = 0;
    }

    //
    // Collecting the old path from the calling dialog edit box
    //
    if(! GetDlgItemText( IDC_FOLDER_EDIT, bstrOldPath.m_str))
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to collect old path from the property page edit box."));
        szBrowseFolder[0] = 0;
    }
    else
    {
         len = bstrOldPath.Length();
         if ( len > MAX_PATH )
         {
             DebugPrintEx(
		        DEBUG_ERR,
		        _T("Old Path Length is bigger then alowed maximal path."));
             szBrowseFolder[0] = 0;
         }
         else 
         {
             wcsncpy(szBrowseFolder,bstrOldPath,MAX_PATH);
             szBrowseFolder[MAX_PATH-1]=L'\0';
         }
    }

    //
    // Preparing the browse dialog style flags.
    //
    ulBrowseFlags       = BIF_RETURNONLYFSDIRS | 
                          BIF_STATUSTEXT | 
                          BIF_USENEWUI | 
                          BIF_VALIDATE;

    //
    // Invoke the browse dialog with a function based on 
    // Shell functions.
    //
    if (InvokeBrowseDialog(  
                    (unsigned short *)&szBrowseFolder, 
                    (const unsigned short *)&szBrowseDlgTitle,
                    ulBrowseFlags,
                    this))
    {
                SetDlgItemText(IDC_FOLDER_EDIT, szBrowseFolder);
                fResult = TRUE;
    }


    return fResult;
}

/*
 -  CppFaxServerSentItems::OnEditBoxChanged
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerSentItems::OnEditBoxChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (!m_fIsDialogInitiated)
    {
        return 1;
    }
    else
    {
        m_fIsDirty = TRUE;
    }
        
        
    if (m_fAllReadyToApply) //only last change should be considered
    {
        switch (wID)
        {
            case IDC_FOLDER_EDIT:
                if ( !m_FolderBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
                break;

            case IDC_SENT_HIGH_EDIT:
                if ( !m_HighWatermarkBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
                else if ( 0 != HIWORD( m_HighWatermarkSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
                break;

            case IDC_SENT_LOW_EDIT:
                if ( !m_LowWatermarkBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
                break;

            case IDC_SENT_AUTODEL_EDIT:
                if ( !m_AutoDelBox.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                    m_fAllReadyToApply = FALSE;
                }
                else if ( 0 != HIWORD( m_AutoDelSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
                {
                    m_fAllReadyToApply = FALSE;
                    SetModified(FALSE);
                }
                break;

            default:
                return 1;
        }
    }
    else //m_fAllReadyToApply == FALSE
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            SetModified(TRUE);  
        }
    }

    return 1;
}


/*
 -  CppFaxServerSentItems::AllReadyToApply
 -
 *  Purpose:
 *      This function validate that no zero length strings 
 *      are found data areas that should be saved.
 *
 *  Arguments:
 *      [in] fSilent - boolean who defines if to pop up messages (FALSE)
 *           or not.(TRUE)
 *
 *  Return:
 *      BOOOLEAN
 */
BOOL CppFaxServerSentItems::AllReadyToApply(BOOL fSilent, int *pCtrlFocus, UINT *pIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerSentItems::AllReadyToApply"));
	
    DWORD         ec  = ERROR_SUCCESS;
    
    if (IsDlgButtonChecked(IDC_SENT_TO_ARCHIVE_CHECK) == BST_CHECKED)
    {
        if ( !m_FolderBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Zero text length - m_FolderBox. (ec: %ld)"), 
			    ec);
        
            if (!fSilent)
            {
                *pCtrlFocus = IDC_FOLDER_EDIT;
                *pIds = IDS_SENT_ARCHIVE_PATH_EMPTY;
            }
            return FALSE;    
        }
    }

    if (IsDlgButtonChecked(IDC_SENT_GENERATE_WARNING_CHECK) == BST_CHECKED)
    {
        if ( !m_HighWatermarkBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                _T("Zero text length - m_HighWatermarkBox. (ec: %ld)"), 
                ec);
        
            if (!fSilent)
            {
                *pCtrlFocus = IDC_SENT_HIGH_EDIT;
                *pIds = IDS_WATERMARK_EMPTY;
            }
            return FALSE;    
        }
        else if ( 0 != HIWORD( m_HighWatermarkSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS    
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Zero value - m_HighWatermarkBox. (ec: %ld)"));
        
            if (!fSilent)
            {
                *pIds = IDS_SENT_HIGH_WATERMARK_ZERO;
                *pCtrlFocus = IDC_SENT_HIGH_EDIT;
            }
            return FALSE;    
        }

        if ( !m_LowWatermarkBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Zero text length - m_LowWatermarkBox. (ec: %ld)"), 
			    ec);
        
            if (!fSilent)
            {
                *pCtrlFocus = IDC_SENT_LOW_EDIT;
                *pIds = IDS_WATERMARK_EMPTY;
            }
            return FALSE;    
        }
    }

    if (IsDlgButtonChecked(IDC_SENT_AUTODEL_CHECK) == BST_CHECKED)
    {
        if ( !m_AutoDelBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Zero text length - m_AutoDelBox. (ec: %ld)"), 
			    ec);
        
            if (!fSilent)
            {
                *pCtrlFocus = IDC_SENT_AUTODEL_EDIT;
                *pIds = IDS_AUTODEL_EMPTY;
            }
            return FALSE;    
        }
        else if ( 0 != HIWORD( m_AutoDelSpin.GetPos() ) ) //occures for out of range such zero. MSDN UDM_GETPOS
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Zero value - m_AutoDelBox."));
        
            if (!fSilent)
            {
                *pCtrlFocus = IDC_SENT_AUTODEL_EDIT;
                *pIds = IDS_AUTODEL_EMPTY;
            }
            return FALSE;    
        }
    }

    ATLASSERT(ERROR_SUCCESS == ec);
    
    //
	// Cheers! 
	//		...every thing ready to apply now.
	//
	return TRUE;           
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxServerSentItems::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxServerSentItems::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxServerSentItems::OnHelpRequest"));
    
    HELPINFO* helpinfo;
    DWORD     dwHelpId;

    switch (uMsg) 
    { 
        case WM_HELP: 

            helpinfo = (HELPINFO*)lParam;
            if (helpinfo->iContextType == HELPINFO_WINDOW)
            {
                ::WinHelp(
                          (HWND) helpinfo->hItemHandle,
                          FXS_ADMIN_HLP_FILE, 
                          HELP_CONTEXTPOPUP, 
                          (DWORD) helpinfo->dwContextId 
                       ); 
            }
            break; 
 
        case WM_CONTEXTMENU: 
            
            dwHelpId = ::GetWindowContextHelpId((HWND)wParam);
            if (dwHelpId) 
            {
                ::WinHelp
                       (
                         (HWND)wParam,
                         FXS_ADMIN_HLP_FILE, 
                         HELP_CONTEXTPOPUP, 
                         (DWORD)dwHelpId
                       );
            }
            break; 
    } 

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxserverreceipts.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerReceipts.h                                  //
//                                                                         //
//  DESCRIPTION   : Fax Server Receipts prop page header file              //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jul 20 2000 yossg  New design - all delivery receipts options      //
//                                                                         //
//  Copyright (C) 2000 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXSERVER_RECEIPTS_H_
#define _PP_FAXSERVER_RECEIPTS_H_

class CFaxServerNode;
class CFaxServer;
/////////////////////////////////////////////////////////////////////////////
// CppFaxServerReceipts dialog

#include <proppageex.h>
class CppFaxServerReceipts : public CPropertyPageExImpl<CppFaxServerReceipts>
{

public:
    //
    // Constructor
    //
    CppFaxServerReceipts(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           bOwnsNotificationHandle,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxServerReceipts();

	enum { IDD = IDD_FAXSERVER_RECEIPTS };

	BEGIN_MSG_MAP(CppFaxServerReceipts)
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )

        COMMAND_HANDLER( IDC_SMTP_EDIT,     EN_CHANGE, OnTextChanged )
		COMMAND_HANDLER( IDC_PORT_EDIT,     EN_CHANGE, OnTextChanged )
		COMMAND_HANDLER( IDC_ADDRESS_EDIT,  EN_CHANGE, OnTextChanged )
		
        COMMAND_HANDLER( IDC_RECEIPT_ENABLE_MSGBOX_CHECK, BN_CLICKED, OnDeliveryOptionChecked)
        COMMAND_HANDLER( IDC_RECEIPT_ENABLE_SMTP_CHECK,   BN_CLICKED, OnDeliveryOptionChecked)
        COMMAND_HANDLER( IDC_SMTP_ROUTE_CHECK,            BN_CLICKED, OnDeliveryOptionChecked)

        COMMAND_HANDLER( IDC_AUTHENTICATION_BUTTON, BN_CLICKED, OnAuthenticationButtonClicked)
	    
        NOTIFY_HANDLER ( IDC_RECEIPTS_HELP_LINK, NM_CLICK, OnHelpLinkClicked)

        MESSAGE_HANDLER( WM_CONTEXTMENU,    OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,           OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxServerReceipts>)
	END_MSG_MAP()


	//
	// Dialog's Handlers and events.
	//
	HRESULT InitRPC( );
	LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();


    HRESULT SetProps(int *pCtrlFocus, UINT * puIds);
    HRESULT PreApply(int *pCtrlFocus, UINT * puIds);

    LRESULT OnHelpLinkClicked(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);
    
private:
    //
    // Control members
    //
    CEdit m_SmtpBox;     // SMTP Server address
    CEdit m_PortBox;     // SMTP port on the server
    CEdit m_AddressBox;  // From e-mail address to send receipts
    
    BOOL  m_fAllReadyToApply;

    BOOL  m_fIsDialogInitiated;

    //
    // members for advance dialog
    //
    FAX_ENUM_SMTP_AUTH_OPTIONS    m_enumSmtpAuthOption;
    
    CComBSTR       m_bstrUserName;
    CComBSTR       m_bstrPassword;

    //
    // Config Structure member
    //
    PFAX_RECEIPTS_CONFIG    m_pFaxReceiptsConfig;
    
    //
    // Handles
    //
    CFaxServerNode *    m_pParentNode;    

    BOOL                m_fIsDirty;
    BOOL                m_fLastGoodIsSMTPRouteConfigured;

    BOOL                m_bLinkWindowRegistered;

    //
    // Event methods
    //
    LRESULT OnDeliveryOptionChecked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnAuthenticationButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    void    EnableSmtpFields(BOOL state);

    BOOL    IsValidData(BSTR bstrSmtpSever, 
                     BSTR bstrPort, 
                     /*[OUT]*/DWORD *pdwPort,
                     BSTR bstrSenderAddress, 
                     /*[OUT]*/int *pCtrlFocus,
                     UINT *pIds);

    BOOL    AllReadyToApply(BOOL fSilent, int *pCtrlFocus = NULL, UINT *pIds = NULL);

    HRESULT IsUnderLocalUserAccount(OUT BOOL * pfIsUnderLocalUserAccount);

    BOOL    IsMsSMTPRoutingMethodStillAssigned();

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};


#endif // _PP_FAXSERVER_RECEIPTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxserversentitems.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerSentItems.h                                 //
//                                                                         //
//  DESCRIPTION   : Fax Server Sent Items prop page header file            //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 27 1999 yossg  created                                         //
//      Nov  3 1999 yossg  OnInitDialog, SetProps                          //
//      Nov 15 1999 yossg  Call RPC func                                   //
//      Dec 10 2000 yossg  Update Windows XP                               //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXSERVER_SENTITEMS_H_
#define _PP_FAXSERVER_SENTITEMS_H_

#include "MyCtrls.h"
#include <windows.h>
#include <proppageex.h>

class CFaxServerNode;
class CFaxServer;
/////////////////////////////////////////////////////////////////////////////
// CppFaxServerSentItems dialog

class CppFaxServerSentItems : public CPropertyPageExImpl<CppFaxServerSentItems>
{

public:
    //
    // Constructor
    //
    CppFaxServerSentItems(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           fIsLocalServer,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxServerSentItems();

	enum { IDD = IDD_FAXSERVER_SENTITEMS };

	BEGIN_MSG_MAP(CppFaxServerSentItems)
		MESSAGE_HANDLER( WM_INITDIALOG,            OnInitDialog )

        COMMAND_HANDLER( IDC_SENT_BROWSE_BUTTON,   BN_CLICKED, BrowseForDirectory)

        COMMAND_HANDLER( IDC_SENT_TO_ARCHIVE_CHECK,   BN_CLICKED, ToArchiveCheckboxClicked)
		COMMAND_HANDLER( IDC_FOLDER_EDIT,          EN_CHANGE,  OnEditBoxChanged )

		COMMAND_HANDLER( IDC_SENT_GENERATE_WARNING_CHECK,  BN_CLICKED, GenerateEventLogCheckboxClicked)
        COMMAND_HANDLER( IDC_SENT_LOW_EDIT,        EN_CHANGE,  OnEditBoxChanged )
		COMMAND_HANDLER( IDC_SENT_HIGH_EDIT,       EN_CHANGE,  OnEditBoxChanged )

		COMMAND_HANDLER( IDC_SENT_AUTODEL_CHECK,   BN_CLICKED, AutoDelCheckboxClicked)
		COMMAND_HANDLER( IDC_SENT_AUTODEL_EDIT,    EN_CHANGE,  OnEditBoxChanged )

        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

		CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxServerSentItems>)
	END_MSG_MAP()

	//
	// Dialog's Handler and events.
	//
	HRESULT InitRPC( );
	LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();

    HRESULT SetProps(int *pCtrlFocus, UINT * puIds);
    HRESULT PreApply(int *pCtrlFocus, UINT * puIds);

private:
    //
    // Control members
    //
    CEdit         m_FolderBox;
    CButton       m_BrowseButton;
    
    CMyUpDownCtrl m_HighWatermarkSpin;
    CMyUpDownCtrl m_LowWatermarkSpin;
    CMyUpDownCtrl m_AutoDelSpin;
    
    CEdit         m_HighWatermarkBox;
    CEdit         m_LowWatermarkBox;
    CEdit         m_AutoDelBox;

    //
    // Boolean members
    //
    BOOL  m_fAllReadyToApply;
    BOOL  m_fIsDialogInitiated;
    BOOL  m_fIsDirty;

    BOOL  m_fIsLocalServer;

    //
    // Config Structure member
    //
    PFAX_ARCHIVE_CONFIG    m_pFaxArchiveConfig;
    
    CComBSTR  m_bstrLastGoodFolder;
    DWORD     m_dwLastGoodSizeQuotaHighWatermark;
    DWORD     m_dwLastGoodSizeQuotaLowWatermark;


    //
    // Handlers
    //
    CFaxServerNode * m_pParentNode;    

    //
    // Browse
    //
    BOOL BrowseForDirectory(WORD wNotifyCode, WORD wID, HWND hwndDlg, BOOL& bHandled);

    //
    // Event methods
    //
    LRESULT ToArchiveCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT GenerateEventLogCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT AutoDelCheckboxClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnEditBoxChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    BOOL AllReadyToApply(BOOL fSilent, int *pCtrlFocus = NULL, UINT *pIds = NULL);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

};


#endif // _PP_FAXSERVER_SENTITEMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\provider.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Provider.h                                             //
//                                                                         //
//  DESCRIPTION   : Header file for the Fax Provider snapin node class.    //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg  Create                                          //
//      Jan 31 2000 yossg  add the functionality                           //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXPROVIDER_H
#define H_FAXPROVIDER_H

#include "snapin.h"
#include "snpnode.h"

#include "DevicesAndProviders.h"
#include "Providers.h"


class CFaxProvidersNode;
class CppFaxProvider;

class CFaxProviderNode : public CSnapinNode <CFaxProviderNode, FALSE>
{

public:


    BEGIN_SNAPINCOMMAND_MAP(CFaxProviderNode, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxProviderNode)
    END_SNAPINTOOLBARID_MAP()

    CFaxProviderNode (CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CSnapinNode<CFaxProviderNode, FALSE>(pParentNode, pComponentData )
    {
    }

    ~CFaxProviderNode()
    {
    }

    LPOLESTR GetResultPaneColInfo(int nCol);

    void InitParentNode(CFaxProvidersNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    HRESULT  Init(PFAX_DEVICE_PROVIDER_INFO pProviderConfig);

    STDMETHOD(CreatePropertyPages)
        (LPPROPERTYSHEETCALLBACK    lpProvider,
         long                       handle,
         IUnknown*                  pUnk,
         DATA_OBJECT_TYPES          type);
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:

    //
    // members
    //
    CComBSTR                          m_bstrProviderName;
    CComBSTR                          m_bstrImageName;

    FAX_ENUM_PROVIDER_STATUS          m_enumStatus;
    CComBSTR                          m_bstrStatus;

    FAX_VERSION                       m_verProviderVersion;
    CComBSTR                          m_bstrVersion;
    
    CComBSTR                          m_buf; 

    //
    // Parent node
    //
    CFaxProvidersNode *               m_pParentNode;

    //
    // Methods
    //
    HRESULT  InitMembers (PFAX_DEVICE_PROVIDER_INFO pProviderConfig);

    void InitIcons ();

    UINT GetStatusIDS(FAX_ENUM_PROVIDER_STATUS enumStatus);

};

//typedef CSnapinNode<CFaxProviderNode, FALSE> CBaseFaxProviderNode;

#endif  //H_OUTROUTINGRULE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\ppfaxserverreceipts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ppFaxServerReceipts.cpp                                //
//                                                                         //
//  DESCRIPTION   : prop pages of Fax Receipts server defaults             //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jul 20 2000 yossg  New design - all delivery receipts options      //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 2000 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxServerReceipts.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "DlgSMTPConfig.h"

#include "FxsValid.h"
#include "dlgutils.h"
#include <windns.h>    //DNS_MAX_NAME_BUFFER_LENGTH
#include <htmlHelp.h>  //HtmlHelp()
#include "resutil.h"
#include <shlobjp.h>
#include <shellapi.h>
#include <faxreg.h>

EXTERN_C BOOL WINAPI LinkWindow_RegisterClass() ;
EXTERN_C BOOL WINAPI LinkWindow_UnregisterClass( HINSTANCE ) ;

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// Constructor
//
CppFaxServerReceipts::CppFaxServerReceipts(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        bOwnsNotificationHandle,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxServerReceipts>(pNode,NULL)
			                	
{
    m_pParentNode        = static_cast <CFaxServerNode *> (pNode);
    m_pFaxReceiptsConfig = NULL;
    
    m_fAllReadyToApply   = FALSE;
    m_fIsDialogInitiated = FALSE;
    
    m_fIsDirty           = FALSE;

    m_enumSmtpAuthOption = FAX_SMTP_AUTH_ANONYMOUS;
    m_bstrUserName       = L"";

    m_fLastGoodIsSMTPRouteConfigured = FALSE;

    m_bLinkWindowRegistered  = FALSE;
}


//
// Destructor
//
CppFaxServerReceipts::~CppFaxServerReceipts()
{
    if (NULL != m_pFaxReceiptsConfig)
    {
        FaxFreeBuffer( m_pFaxReceiptsConfig );
    }

    if (m_bLinkWindowRegistered)
    {
        m_bLinkWindowRegistered = LinkWindow_UnregisterClass(_Module.GetResourceInstance());
        ATLASSERT(m_bLinkWindowRegistered); //verifies LinkWindow_UnregisterClass success
    }
}

/////////////////////////////////////////////////////////////////////////////
// CppFaxServerReceipts message handlers

/*
 -  CppFaxServerReceipts::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerReceipts::InitRPC()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::InitRPC"));
    
    HRESULT    hRc = S_OK;
    DWORD      ec  = ERROR_SUCCESS;

    //
    // get RPC Handle
    //   

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Retrieve the fax SMTP configuration
    //
    if (!FaxGetReceiptsConfiguration(m_pFaxServer->GetFaxServerHandle(),
                                     &m_pFaxReceiptsConfig)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get mail configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
    //For max verification
    ATLASSERT(m_pFaxReceiptsConfig);

    
    //
    // Init members - for advance dialog or save operation
    //
    m_enumSmtpAuthOption = m_pFaxReceiptsConfig->SMTPAuthOption;
    
    m_bstrUserName       = m_pFaxReceiptsConfig->lptstrSMTPUserName;     
    if ( !m_bstrUserName) 
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        
        DebugPrintEx( DEBUG_ERR, 
            _T("Null bstr - out of memory."));
        
        goto Error;

    }
    // m_pszPassword is NULL from the constructor 
    // there is no need to read from the server.

    // init status for unselcting this feature 
    // with still assigned devices to this Microsoft SMTP method
    if ( m_pFaxReceiptsConfig->bIsToUseForMSRouteThroughEmailMethod )
    {
        m_fLastGoodIsSMTPRouteConfigured = TRUE;
    }
    //else //See constructor
    //{
    //    m_fLastGoodIsSMTPRouteConfigured = FALSE;
    //}


    //
    // Register the link window class
    //
    m_bLinkWindowRegistered = LinkWindow_RegisterClass();
    if(!m_bLinkWindowRegistered)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("LinkWindow_RegisterClass() failed - unable to register link window class\n"));

        ec = GetLastError();
        
        goto Error;
    }


    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get mail configuration."));
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    m_pParentNode->NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}

    
    
/*
 -  CppFaxServerReceipts::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxServerReceipts::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::OnInitDialog"));

	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );

    BOOL fIsUnderLocalUserAccount = FALSE;

    WCHAR   buff[100];
    int     count;

    //
    // Attach 
    //
    m_SmtpBox.Attach(GetDlgItem(IDC_SMTP_EDIT));
    m_PortBox.Attach(GetDlgItem(IDC_PORT_EDIT));
    m_AddressBox.Attach(GetDlgItem(IDC_ADDRESS_EDIT));
    
    //
    // Limit text length
    //
    m_PortBox.SetLimitText(FXS_MAX_PORT_NUM_LEN);
    m_SmtpBox.SetLimitText(DNS_MAX_NAME_BUFFER_LENGTH);
    m_AddressBox.SetLimitText(FXS_MAX_EMAIL_ADDRESS);

    //
    // init controls
    //
    ATLASSERT(NULL != m_pFaxReceiptsConfig);
    
    //
    // Port
    //
    count = swprintf(buff,
    L"%ld", m_pFaxReceiptsConfig->dwSMTPPort);
    
    ATLASSERT(count > 0);
    if( count > 0 )
    {
        m_PortBox.SetWindowText(buff);
    }
        
    //
    //
    //
    m_SmtpBox.SetWindowText   (m_pFaxReceiptsConfig->lptstrSMTPServer);
    m_AddressBox.SetWindowText(m_pFaxReceiptsConfig->lptstrSMTPFrom);

    if (m_fLastGoodIsSMTPRouteConfigured)
    {
        CheckDlgButton(IDC_SMTP_ROUTE_CHECK, BST_CHECKED);
    }

    DWORD dwReceiptsOptions = m_pFaxReceiptsConfig->dwAllowedReceipts; 
    if (DRT_NONE == dwReceiptsOptions && !m_fLastGoodIsSMTPRouteConfigured)
    {
        EnableSmtpFields(FALSE);
    }
    else
    {
        if( dwReceiptsOptions & DRT_EMAIL )
        {
            CheckDlgButton(IDC_RECEIPT_ENABLE_SMTP_CHECK, BST_CHECKED);
        }
        else
        {
            CheckDlgButton(IDC_RECEIPT_ENABLE_SMTP_CHECK, BST_UNCHECKED);
            if (!m_fLastGoodIsSMTPRouteConfigured)
            {
                EnableSmtpFields(FALSE); 
            }
            else
            {
                CheckDlgButton(IDC_SMTP_ROUTE_CHECK, BST_CHECKED);
            } 
        }

        if ( dwReceiptsOptions & DRT_MSGBOX ) 
        { 
            CheckDlgButton(IDC_RECEIPT_ENABLE_MSGBOX_CHECK, BST_CHECKED);
        }
        else
        {
            CheckDlgButton(IDC_RECEIPT_ENABLE_MSGBOX_CHECK, BST_UNCHECKED);
        }
    }

    m_fIsDialogInitiated = TRUE;

    return(1);
}

/*
 -  CppFaxServerReceipts::SetProps
 -
 *  Purpose:
 *      Sets properties on apply.
 *
 *  Arguments:
 *      IN pCtrlFocus - focus pointer (int)
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerReceipts::SetProps(int *pCtrlFocus, UINT * puIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::SetProps"));
    HRESULT     hRc = S_OK;
    DWORD       ec  = ERROR_SUCCESS;

    BOOL        fSkipMessage = FALSE;


    CComBSTR    bstrSmtpSever, 
                bstrPort,
                bstrSenderAddress;
    DWORD       dwPort;

    BOOL        fIsSMTPRouteConfigured = FALSE;
    BOOL        fIsSMTPReceiptsConfigured = FALSE;

    FAX_RECEIPTS_CONFIG   FaxReceiptsConfig;

    
    *pCtrlFocus = 0; //safty
    

    ATLASSERT(TRUE == m_fAllReadyToApply);
    m_fAllReadyToApply = FALSE;


    //
    // Collect all data and init the structure's fields 
    // uses Copy() to copy and also allocate before
    //
    
    //
    // This operation is very important for the case of unchecked email option
    // the service will neglect the SMTP fields.
    //
    ZeroMemory (&FaxReceiptsConfig, sizeof(FaxReceiptsConfig));

    FaxReceiptsConfig.dwSizeOfStruct = sizeof(FAX_RECEIPTS_CONFIG);

    FaxReceiptsConfig.dwAllowedReceipts = DRT_NONE; // 0x0000

    fIsSMTPRouteConfigured = (IsDlgButtonChecked(IDC_SMTP_ROUTE_CHECK) == BST_CHECKED);

    //
    // While tring to sumbmit unchecking of IDC_SMTP_ROUTE_CHECK
    // Special search for any left assigned devices' to Microsoft e-mail routing method
    //
    if ( !fIsSMTPRouteConfigured && m_fLastGoodIsSMTPRouteConfigured)
    {
        //Call function that will make loop on all FaxEnumPorts(/Ex) and FaxEnumRoutingMethods
        //and will pop-up ErrMsgBox in case in any Device The SMTP Microsoft Route 
        //Through e-mail method is still enabled while the user tries to unchecked. 
                    
        if (IsMsSMTPRoutingMethodStillAssigned())
        {
            PropSheet_SetCurSelByID( GetParent(), IDD);         
            ATLASSERT(::IsWindow(m_hWnd));
            PageError(IDS_MS_SMTPROUTINGMETHOD_ASSIGNED, m_hWnd);

            fSkipMessage = TRUE;

			goto Error;
        }
    }

    //
    // SMTP server details
    //
    if ( IsDlgButtonChecked(IDC_RECEIPT_ENABLE_SMTP_CHECK) == BST_CHECKED ) 
    {
        fIsSMTPReceiptsConfigured = TRUE;
        FaxReceiptsConfig.dwAllowedReceipts |= DRT_EMAIL;
    }
    
    if (
         fIsSMTPReceiptsConfigured
       ||
         fIsSMTPRouteConfigured 
       ) 
    {
        if ( !m_SmtpBox.GetWindowText(&bstrSmtpSever))
        {
            *pCtrlFocus = IDC_SMTP_EDIT;
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&bstrSmtpSever)"));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }
    
	    if ( !m_PortBox.GetWindowText(&bstrPort))
        {
            *pCtrlFocus = IDC_PORT_EDIT;
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&bstrPort)"));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }

        if ( !m_AddressBox.GetWindowText(&bstrSenderAddress))
        {
            *pCtrlFocus = IDC_SMTP_EDIT;
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&bstrSenderAddress)"));
            ec = ERROR_OUTOFMEMORY;
            goto Error;
        }
    
        //
        // Validation
        //
        if (!IsValidData(bstrSmtpSever, 
                         bstrPort,
                         &dwPort,
                         bstrSenderAddress, 
                         pCtrlFocus,
                         puIds)
           )
        {
            ATLASSERT(pCtrlFocus);
            ATLASSERT(puIds);
            ec = ERROR_INVALID_DATA;

            //in this case detailed message box was given by the called functions
            fSkipMessage = TRUE;
        
            goto Error;
        }
    
        //
        // subtitute all data
        //
        FaxReceiptsConfig.lptstrSMTPServer   = bstrSmtpSever;
    
        FaxReceiptsConfig.dwSMTPPort         = dwPort;

        FaxReceiptsConfig.lptstrSMTPFrom     = bstrSenderAddress;

        FaxReceiptsConfig.SMTPAuthOption     = m_enumSmtpAuthOption;

        FaxReceiptsConfig.lptstrSMTPUserName = m_bstrUserName;

        FaxReceiptsConfig.lptstrSMTPPassword = m_bstrPassword;

    }
    
    //
    // Set dwAllowedReceipts   
    //
    FaxReceiptsConfig.bIsToUseForMSRouteThroughEmailMethod = fIsSMTPRouteConfigured;

    
    //
    // Message box 
    //
    if (IsDlgButtonChecked(IDC_RECEIPT_ENABLE_MSGBOX_CHECK) == BST_CHECKED)
    {
        FaxReceiptsConfig.dwAllowedReceipts |= DRT_MSGBOX;
    }
    
    //
    // get RPC Handle
    //   
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        
        goto Error;
    }
    
    
    //
    // Set Config
    //
    if (!FaxSetReceiptsConfiguration(
                m_pFaxServer->GetFaxServerHandle(),
                &FaxReceiptsConfig)) 
	{		
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to Set receipts configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Network Error was found. (ec: %ld)"), 
                ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }

    ATLASSERT(ERROR_SUCCESS == ec);

    m_fLastGoodIsSMTPRouteConfigured = fIsSMTPRouteConfigured;

    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to set receipts configuration."));

    m_fIsDirty = FALSE;

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);

    if (!fSkipMessage)
    {
        PropSheet_SetCurSelByID( GetParent(), IDD);         
        ATLASSERT(::IsWindow(m_hWnd));
        PageError(GetFaxServerErrorMsg(ec), m_hWnd);
    }

Exit:    
    return hRc;
}


/*
 -  CppFaxServerReceipts::PreApply
 -
 *  Purpose:
 *      Checks data validity before apply.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxServerReceipts::PreApply(int *pCtrlFocus, UINT * puIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::PreApply"));
    HRESULT hRc = S_OK;
    
    //
    // PreApply Checks
    //
    if (!AllReadyToApply(/*fSilent =*/ FALSE, pCtrlFocus , puIds))
    {
        m_fAllReadyToApply = FALSE;
        SetModified(FALSE);  
        hRc = E_FAIL ;
    }
    else
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }

    return(hRc);
}


/*
 -  CppFaxServerReceipts::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxServerReceipts::OnApply()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::OnApply"));
    HRESULT  hRc  = S_OK;
    int     CtrlFocus = 0;
    UINT    uIds = 0;

    if (!m_fIsDirty)
    {
        return TRUE;
    }

    hRc = PreApply(&CtrlFocus, &uIds);
    if (FAILED(hRc))
    {
        if (PropSheet_SetCurSelByID( GetParent(), IDD) )
        {
            PageError(uIds, m_hWnd, _Module.GetResourceInstance());
            
            if (CtrlFocus)
            {
                GotoDlgCtrl(GetDlgItem(CtrlFocus));
            }
        }
        return FALSE;
    }
    else //(Succeeded(hRc))
    {
        hRc = SetProps(&CtrlFocus, &uIds);
        if (FAILED(hRc)) 
        {
            if (uIds)
            {
                if (PropSheet_SetCurSelByID( GetParent(), IDD) )
                {
                    PageError(uIds, m_hWnd, _Module.GetResourceInstance());
            
                    if (CtrlFocus)
                    {
                        GotoDlgCtrl(GetDlgItem(CtrlFocus));
                    }
                }
            }
            //else Error Msg by called func.
            return FALSE;
        }
        else //(Succeeded(hRc))
        {
            return TRUE;
        }
    }

}

/*
 -  CppFaxServerReceipts::SetApplyButton
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerReceipts::SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetModified(TRUE);  
    bHandled = TRUE;
    return(1);
}

/*
 -  CppFaxServerReceipts::EnableSmtpFields
 -
 *  Purpose:
 *      Enable/dissable Authenticated Access dialog controls.
 *
 *  Arguments:
 *      [in] state - boolean value to enable TRUE or FALSE to disable
 *
 *  Return:
 *      void
 */
void CppFaxServerReceipts::EnableSmtpFields(BOOL state)
{

    ::EnableWindow(GetDlgItem(IDC_ADDRESS_STATIC), state);
    ::EnableWindow(GetDlgItem(IDC_ADDRESS_EDIT),   state);

    ::EnableWindow(GetDlgItem(IDC_SMTP_STATIC), state);
    ::EnableWindow(GetDlgItem(IDC_SMTP_EDIT),   state);
    
    ::EnableWindow(GetDlgItem(IDC_PORT_STATIC), state);
    ::EnableWindow(GetDlgItem(IDC_PORT_EDIT),   state);
    
    ::EnableWindow(GetDlgItem(IDC_AUTHENTICATION_BUTTON), state);

}




/*
 -  CppFaxServerReceipts::OnDeliveryOptionChecked
 -
 *  Purpose:
 *      Gray/Ungray controls
 *      Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerReceipts::OnDeliveryOptionChecked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL fState;

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }


    fState = ( 
                IsDlgButtonChecked(IDC_RECEIPT_ENABLE_SMTP_CHECK) == BST_CHECKED
             ||
                IsDlgButtonChecked(IDC_SMTP_ROUTE_CHECK) == BST_CHECKED 
             );

    EnableSmtpFields(fState);

    if (AllReadyToApply(TRUE))
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }
    else
    {
        m_fAllReadyToApply = FALSE;
        SetModified(FALSE);  
    }

    return(1);
}

/*
 -  CppFaxServerReceipts::OnAuthenticationButtonClicked
 -
 *  Purpose:
 *      To allow opening of the advance SMTP configuration server.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerReceipts::OnAuthenticationButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::OnAuthenticationButtonClicked"));
    
    INT_PTR  rc    = IDCANCEL;
    HRESULT  hRc   = S_OK;
    DWORD    dwRet = ERROR_SUCCESS;
    
    CDlgSMTPConfig    DlgSMTPConfig;


    //
    // Dialog to configure SMTP authentication mode
    //
    hRc = DlgSMTPConfig.InitSmtpDlg( 
                            m_enumSmtpAuthOption, 
                            m_bstrUserName);
    if (FAILED(hRc))
    {
        m_pParentNode->NodeMsgBox(IDS_MEMORY);
        goto Cleanup;
    }

    rc = DlgSMTPConfig.DoModal();
    if (rc != IDOK)
    {
        goto Cleanup;
    }

    //else
    m_enumSmtpAuthOption = DlgSMTPConfig.GetAuthenticationOption();

    if ( 
         FAX_SMTP_AUTH_BASIC == m_enumSmtpAuthOption 
       || 
         FAX_SMTP_AUTH_NTLM == m_enumSmtpAuthOption
       )  
    {

        m_bstrUserName = DlgSMTPConfig.GetUserName();
        if (!m_bstrUserName)        
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Null memeber BSTR - m_bstrUserName."));
        
            m_pParentNode->NodeMsgBox(IDS_MEMORY);

            goto Cleanup;
        }
    
        if ( DlgSMTPConfig.IsPasswordModified() )
        {
            m_bstrPassword  = DlgSMTPConfig.GetPassword();
            if (!m_bstrPassword)
            {
                DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory while setting m_bstrPassword"));
                m_pParentNode->NodeMsgBox(IDS_MEMORY);

                goto Cleanup;
            }
        }
        else
        {
            m_bstrPassword.Empty();
        }
    }

    
    m_fIsDirty     = TRUE;
    

    if (AllReadyToApply(TRUE))
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }


Cleanup:
    return 1;
}


/*
 -  CppFaxServerReceipts::IsUnderLocalUserAccount
 -
 *  Purpose:
 *      Check if fax service Is running Under LocalUser Account.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code.
 */
HRESULT CppFaxServerReceipts::IsUnderLocalUserAccount(OUT BOOL * pfIsUnderLocalUserAccount)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::IsUnderLocalUserAccount"));

    HRESULT hRc = S_OK;
    DWORD dwRet = ERROR_SUCCESS;
    
    ATLASSERT(m_pParentNode);
    CComBSTR bstrServerName = m_pParentNode->GetServerName();
    if (!bstrServerName)
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Out of memory. Failed to load server name string."));
        
        m_pParentNode->NodeMsgBox(IDS_MEMORY);
        
        hRc = E_OUTOFMEMORY;
        
        goto Cleanup;
    }
    
    if (0 == bstrServerName.Length())
    {
        dwRet= IsFaxServiceRunningUnderLocalSystemAccount(NULL, pfIsUnderLocalUserAccount);
    }
    else
    {
        dwRet= IsFaxServiceRunningUnderLocalSystemAccount(bstrServerName.m_str, pfIsUnderLocalUserAccount);
    }
    if(ERROR_SUCCESS != dwRet)
    {
        DebugPrintEx(DEBUG_ERR, 
                     _T("IsFaxServiceRunningUnderLocalSystemAccount failed: %d\n"), 
					 dwRet);

        hRc = HRESULT_FROM_WIN32(dwRet);

        goto Cleanup;
    }
    ATLASSERT( S_OK == hRc);

Cleanup:

    return hRc;
}


/*
 -  CppFaxServerReceipts::IsValidData
 -
 *  Purpose:
 *      To validate all data types before save data.
 *      This level should be responsible that detailed 
 *      error description will be shown to user.
 *
 *  Arguments:
 *      [in]   BSTRs and DWORDs
 *      [out]  dwPort pointer to DWORD that 
 *             was derived from the port bstr if validation success.
 *      [out]  iFocus
 *
 *  Return:
 *      BOOOLEAN
 */
BOOL CppFaxServerReceipts::IsValidData(BSTR bstrSmtpSever, 
                                    BSTR bstrPort,
                                    DWORD *pdwPort,
                                    BSTR bstrSenderAddress, 
                                    int *pCtrlFocus,
                                    UINT *pIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::IsValidData"));

    UINT           uRetIDS   = 0;

    ATLASSERT(pdwPort);
    
    if (!IsValidPortNumber(bstrPort, pdwPort, &uRetIDS))
    {
        ATLASSERT(0 != uRetIDS);
        DebugPrintEx( DEBUG_ERR,
			_T("Invalid port number."));
        *pCtrlFocus = IDC_PORT_EDIT;
        
        goto Error;
    }
    
    if (!IsValidServerNameString(bstrSmtpSever, &uRetIDS, TRUE /*DNS NAME LENGTH*/))
    {
        ATLASSERT(0 != uRetIDS);
        DebugPrintEx( DEBUG_ERR,
			_T("Invalid SMTP server name."));
        *pCtrlFocus = IDC_SMTP_USERNAME_EDIT;
        
        goto Error;
    }
    
    if (!IsNotEmptyString(bstrSenderAddress))
    {
        DebugPrintEx( DEBUG_ERR,
			_T("Sender address string empty or spaces only."));
        uRetIDS = IDS_SENDER_ADDRESS_EMPTY;

        *pCtrlFocus = IDC_SMTP_PASSWORD_EDIT;
        
        goto Error;
    }


    ATLASSERT(0 == uRetIDS);
    goto Exit;
    
Error:    
    ATLASSERT(0 != uRetIDS);

    *pIds = uRetIDS;

    return FALSE;

Exit:
    return TRUE;
}



/*
 -  CppFaxServerReceipts::AllReadyToApply
 -
 *  Purpose:
 *      This function validate that no zero length strings 
 *      are found data areas that should be saved.
 *
 *  Arguments:
 *      [in] fSilent - boolean who defines if to pop up messages (FALSE)
 *           or not.(TRUE)
 *
 *  Return:
 *      BOOOLEAN
 */
BOOL CppFaxServerReceipts::AllReadyToApply(BOOL fSilent, int *pCtrlFocus, UINT *pIds)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::AllReadyToApply"));
	
    DWORD   ec  = ERROR_SUCCESS;
     
    if (
         IsDlgButtonChecked(IDC_RECEIPT_ENABLE_SMTP_CHECK) == BST_CHECKED
       ||
         IsDlgButtonChecked(IDC_SMTP_ROUTE_CHECK) == BST_CHECKED 
       ) 
    {
        if ( !m_SmtpBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
		        DEBUG_ERR,
		        _T("Zero text length - m_SmtpBox. (ec: %ld)"), 
		        ec);
    
            if (!fSilent)
            {
                *pIds = IDS_SERVERNAME_EMPTY_STRING;
                *pCtrlFocus = IDC_SMTP_EDIT;
            }
            return FALSE;    
        }

        if ( !m_PortBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
		        DEBUG_ERR,
		        _T("Zero text length - m_PortBox. (ec: %ld)"), 
		        ec);
    
            if (!fSilent)
            {
                *pIds = IDS_PORT_EMPTY_STRING;
                *pCtrlFocus = IDC_PORT_EDIT;
            }
            return FALSE;    
        }

        if ( !m_AddressBox.GetWindowTextLength() )    
        {
            ec = GetLastError();
            DebugPrintEx(
		        DEBUG_ERR,
		        _T("Zero text length - m_AddressBox. (ec: %ld)"), 
		        ec);
    
            if (!fSilent)
            {
                *pIds = IDS_SENDER_ADDRESS_EMPTY;
                *pCtrlFocus = IDC_ADDRESS_EDIT;
            }
            return FALSE;    
        }

    }
    ATLASSERT(ERROR_SUCCESS == ec);
    
    //
	// Cheers! 
	//		...every thing ready to apply now.
	//
	return TRUE;           
}


/*
 -  CppFaxServerReceipts::OnTextChanged
 -
 *  Purpose:
 *      Enable/Disable the submit button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxServerReceipts::OnTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::OnTextChanged"));
                   
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
    else
    {
        m_fIsDirty = TRUE;
    }

    if (AllReadyToApply(TRUE))
    {
        m_fAllReadyToApply = TRUE;
        SetModified(TRUE);  
    }
    else
    {
        m_fAllReadyToApply = FALSE;
        SetModified(FALSE);  
    }

    return 1;
}

/*
 -  CppFaxServerReceipts::IsMsSMTPRoutingMethodStillAssigned
 -
 *  Purpose:
 *      This function makes loop on all FaxEnumPortsEx and FaxEnumRoutingMethods
 *      and should pop-up ErrMsgBox in case in any Device The SMTP Microsoft Route 
 *      Through e-mail method is still enabled while the user tries to unchecked. 
 *
 *  Arguments:
 *
 *  Return:
 *      BOOOLEAN
 */
BOOL CppFaxServerReceipts::IsMsSMTPRoutingMethodStillAssigned()
{
    DEBUG_FUNCTION_NAME( _T("CppFaxServerReceipts::IsMsSMTPRoutingMethodStillAssigned"));
	     
    DWORD                   ec     = ERROR_SUCCESS;

    PFAX_PORT_INFO_EX       pFaxDevicesConfig;
    DWORD                   dwNumOfDevices;

    PFAX_ROUTING_METHOD     pFaxInboundMethodsConfig;
    DWORD                   dwNumOfInboundMethods;

    DWORD                   dwIndex = 0;

    //
    // get Fax Handle
    //   
    ATLASSERT(m_pFaxServer);

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Retrieve the fax devices configuration
    //
    if (!FaxEnumPortsEx(m_pFaxServer->GetFaxServerHandle(), 
                        &pFaxDevicesConfig,
                        &dwNumOfDevices)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get devices configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(pFaxDevicesConfig);

    for (dwIndex = 0; dwIndex < dwNumOfDevices; dwIndex++)
    {
        HANDLE		 hFaxPortHandle = NULL;
        
        //
        // only a PORT_OPEN_QUERY is needed to show the methods
        // the handle with PORT_OPEN_MODIFY priviledge will be 
        // given for limited short period for opertion required it.
        //

        if (!FaxOpenPort( m_pFaxServer->GetFaxServerHandle(), 
                            pFaxDevicesConfig[dwIndex].dwDeviceID, 
                            PORT_OPEN_QUERY, 
                            &hFaxPortHandle )) 
        {
		    ec = GetLastError();

            if (ERROR_INVALID_HANDLE ==  ec)
            {
                //Special case of ERROR_INVALID_HANDLE
		        DebugPrintEx(DEBUG_ERR,
			        _T("FaxOpenPort() failed with ERROR_INVALID_HANDLE. (ec:%ld)"),
			        ec);
            
                PropSheet_SetCurSelByID( GetParent(), IDD);         
                ATLASSERT(::IsWindow(m_hWnd));
                PageError(IDS_OPENPORT_INVALID_HANDLE, m_hWnd);
            
                goto Exit;
            }

		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("FaxOpenPort() failed. (ec:%ld)"),
			    ec);
            
            goto Error;
        } 
        ATLASSERT(NULL != hFaxPortHandle);

        //
        // Retrieve the fax Inbound Methods configuration
        //
        if (!FaxEnumRoutingMethods(hFaxPortHandle, 
                            &pFaxInboundMethodsConfig,
                            &dwNumOfInboundMethods)) 
	    {
            ec = GetLastError();
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Fail to get Inbound Methods configuration. (ec: %ld)"), 
			    ec);
            
            if (NULL != hFaxPortHandle)
            {
                if (!FaxClose( hFaxPortHandle ))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("FaxClose() on port handle failed (ec: %ld)"),
                        GetLastError());
                }
            }


            if (IsNetworkError(ec))
            {
                DebugPrintEx(
			        DEBUG_ERR,
			        _T("Network Error was found. (ec: %ld)"), 
			        ec);
            
                m_pFaxServer->Disconnect();       
            }

            goto Error; 
        }
        //For max verification
        ATLASSERT(pFaxInboundMethodsConfig);

        //
        // Close Fax Port handle
        // 
        if (NULL != hFaxPortHandle)
        {
            if (!FaxClose( hFaxPortHandle ))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxClose() on port handle failed (ec: %ld)"),
                    GetLastError());
            }
        }

        //
        // Main loop search for MS email routing method's GUID
        //
        for ( DWORD dwMethodsIndex = 0; dwMethodsIndex < dwNumOfInboundMethods; dwMethodsIndex++ )
        {
            pFaxInboundMethodsConfig[dwMethodsIndex];
            if (!lstrcmpi(pFaxInboundMethodsConfig[dwMethodsIndex].Guid, REGVAL_RM_EMAIL_GUID))
            {
                if (pFaxInboundMethodsConfig[dwMethodsIndex].Enabled)
                {
                    return TRUE;
                }
            }
        }
    }


    ATLASSERT(ERROR_SUCCESS == ec);

    goto Exit;

Error:


    PropSheet_SetCurSelByID( GetParent(), IDD);         
    ATLASSERT(::IsWindow(m_hWnd));
    PageError(GetFaxServerErrorMsg(ec), m_hWnd);

Exit:

    return FALSE;

}

/*
 -  CppFaxServerReceipts::OnHelpLinkClicked
 -
 *  Purpose:
 *      On HTML like link was clicked open chm help window.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
#define FAX_USER_ACCOUNT_HELP  FAX_ADMIN_HELP_FILE TEXT("::/FaxS_H_UserAcct.htm")
LRESULT CppFaxServerReceipts::OnHelpLinkClicked(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    
    ATLASSERT( IDC_RECEIPTS_HELP_LINK == idCtrl);

    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }

    HtmlHelp(m_hWnd, FAX_USER_ACCOUNT_HELP, HH_DISPLAY_TOC, NULL);

    return 1;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxServerReceipts::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxServerReceipts::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxServerReceipts::OnHelpRequest"));
    
    HELPINFO* helpinfo;
    DWORD     dwHelpId;

    switch (uMsg) 
    { 
        case WM_HELP: 

            helpinfo = (HELPINFO*)lParam;
            if (helpinfo->iContextType == HELPINFO_WINDOW)
            {
                ::WinHelp(
                          (HWND) helpinfo->hItemHandle,
                          FXS_ADMIN_HLP_FILE, 
                          HELP_CONTEXTPOPUP, 
                          (DWORD) helpinfo->dwContextId 
                       ); 
            }
            break; 
 
        case WM_CONTEXTMENU: 
            
            dwHelpId = ::GetWindowContextHelpId((HWND)wParam);
            if (dwHelpId) 
            {
                ::WinHelp
                       (
                         (HWND)wParam,
                         FXS_ADMIN_HLP_FILE, 
                         HELP_CONTEXTPOPUP, 
                         dwHelpId
                       );
            }
            break; 
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\provider.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Provider.cpp                                           //
//                                                                         //
//  DESCRIPTION   : Header file for the Provider snapin node class.        //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg  Create                                          //
//      Jan 31 2000 yossg  add the functionality                           //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "snapin.h"

#include "Provider.h"
#include "Providers.h"

#include "ppFaxProviderGeneral.h"

#include "oaidl.h"
#include "Icons.h"
#include "faxmmc.h"

/////////////////////////////////////////////////////////////////////////////
static const GUID CFaxProviderNodeGUID_NODETYPE = FAXSRV_DEVICE_PROVIDER_NODETYPE_GUID;

const GUID*     CFaxProviderNode::m_NODETYPE        = &CFaxProviderNodeGUID_NODETYPE;
const OLECHAR*  CFaxProviderNode::m_SZNODETYPE      = FAXSRV_DEVICE_PROVIDER_NODETYPE_GUID_STR;
const CLSID*    CFaxProviderNode::m_SNAPIN_CLASSID  = &CLSID_Snapin;

/*
 -  CFaxProviderNode::Init
 -
 *  Purpose:
 *      Init all members icon etc.
 *
 *  Arguments:
 *      [in]    pProviderConfig - PFAX_DEVICE_PROVIDER_INFO
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxProviderNode::Init(PFAX_DEVICE_PROVIDER_INFO pProviderConfig)
{

    DEBUG_FUNCTION_NAME( _T("CFaxProviderNode::Init"));
    HRESULT hRc = S_OK;

    ATLASSERT(pProviderConfig);

    hRc = InitMembers( pProviderConfig );
    if (FAILED(hRc))
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to InitMembers"));
        
        //NodeMsgBox done by called func.
        
        goto Exit;
    }
    ATLASSERT(SUCCEEDED(hRc));

    //
    // Icon
    //
    InitIcons();

Exit:
    return hRc;
}

/*
 -  CFaxProviderNode::InitIcons
 -
 *  Purpose:
 *      Private method that initiate icons
 *      due to the status member state.
 *
 *  Arguments:
 *      No.
 *
 *  Return:
 *      No.
 */
void CFaxProviderNode::InitIcons ()
{
    DEBUG_FUNCTION_NAME( _T("CFaxProviderNode::InitIcons"));
    switch (m_enumStatus)
    {
        case FAX_PROVIDER_STATUS_SUCCESS:
            m_resultDataItem.nImage = IMAGE_FSP;
            break;

        case FAX_PROVIDER_STATUS_SERVER_ERROR:
        case FAX_PROVIDER_STATUS_BAD_GUID:
        case FAX_PROVIDER_STATUS_BAD_VERSION:
        case FAX_PROVIDER_STATUS_CANT_LOAD:
        case FAX_PROVIDER_STATUS_CANT_LINK:
        case FAX_PROVIDER_STATUS_CANT_INIT:
            m_resultDataItem.nImage = IMAGE_FSP_ERROR;
            break;

        default:
            ATLASSERT(0); // "this enumStatus is not supported "
            break; //currently 999

    } // endswitch (enumStatus)

    return;
}


/*
 -  CFaxProviderNode::InitMembers
 -
 *  Purpose:
 *      Private method to initiate members
 *      Must be called after init of m_pParentNode
 *
 *  Arguments:
 *      [in]    pProviderConfig - PFAX_DEVICE_PROVIDER_INFO structure
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxProviderNode::InitMembers(PFAX_DEVICE_PROVIDER_INFO pProviderConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxProviderNode::InitMembers"));
    HRESULT hRc = S_OK;

    int   iCount;

    UINT  idsStatus;

    CComBSTR bstrChk;

    WCHAR lpwszBuff [4*FXS_DWORD_LEN+3/*points*/+1/*NULL*/];
    
    ATLASSERT(pProviderConfig);
    
    //    
    // status    
    //    
    m_enumStatus          = pProviderConfig->Status;

    //    
    // status string   
    //    
    idsStatus = GetStatusIDS(m_enumStatus);
    if ( FXS_IDS_STATUS_ERROR == idsStatus)
    {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Invalid Status value."));
            goto Error;
    }
    else
    {
        if (!m_bstrStatus.LoadString(idsStatus))
        {
            hRc = E_OUTOFMEMORY;
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Out of memory. Failed to load status string."));
            goto Error;
        }
    }

    //
    // Provider name
    //
    m_bstrProviderName = pProviderConfig->lpctstrFriendlyName;
    if ( !m_bstrProviderName )
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    //
    // Version
    //
    m_verProviderVersion = pProviderConfig->Version;  
    
    //
    // Version string
    //
    
    //m_bstrVersion = L"5.0.813.0 (Chk)" or L"5.0.813.0"
    iCount = swprintf(
                  lpwszBuff,
                  L"%ld.%ld.%ld.%ld",
                  m_verProviderVersion.wMajorVersion,
                  m_verProviderVersion.wMinorVersion,
                  m_verProviderVersion.wMajorBuildNumber,
                  m_verProviderVersion.wMinorBuildNumber
                  );
    if( iCount <= 0 )
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to read m_verProviderVersion."));
        goto Error;
    }

    m_bstrVersion = lpwszBuff;
    if (!m_bstrVersion)
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Null memeber BSTR - m_bstrVersion."));
        goto Error;
    }

    
    if (m_verProviderVersion.dwFlags & FAX_VER_FLAG_CHECKED)
    {
        if (!bstrChk.LoadString(IDS_CHK))
        {
            hRc = E_OUTOFMEMORY;
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Out of memory. Failed to load string."));
            goto Error;
        }
        
        m_bstrVersion += bstrChk; //L" (Chk)";

    }

    //
    // Path
    //
    m_bstrImageName = pProviderConfig->lpctstrImageName;
    if ( !m_bstrImageName )
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    ATLASSERT(NULL != m_pParentNode);
    if (NULL != m_pParentNode)
    {
        m_pParentNode->NodeMsgBox(IDS_MEMORY);
    }
    
Exit:
   return (hRc);
}

/*
 -  CFaxProviderNode::GetResultPaneColInfo
 -
 *  Purpose:
 *      Return the text for specific column
 *      Called for each column in the result pane
 *
 *  Arguments:
 *      [in]    nCol - column number
 *
 *  Return:
 *      String to be displayed in the specific column
 */
LPOLESTR CFaxProviderNode::GetResultPaneColInfo(int nCol)
{
    DEBUG_FUNCTION_NAME( _T("CFaxProviderNode::GetResultPaneColInfo"));
    HRESULT hRc = S_OK;

    switch (nCol)
    {
    case 0:
        //
        // Provider Name
        //
        if (!m_bstrProviderName)
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Null memeber BSTR - m_bstrProviderName."));
            goto Error;
        }
        else
        {
           return (m_bstrProviderName);
        }

        
    case 1:
        //
        // Status
        //
        if (!m_bstrStatus)
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Null memeber BSTR - m_bstrStatus."));
            goto Error;
        }
        else
        {
            return (m_bstrStatus);
        }

    case 2:  
        //
        // Version
        //
        if (!m_bstrVersion)
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Null memeber BSTR - m_bstrVersion."));
            goto Error;
        }
        else
        {
            return (m_bstrVersion);
        }
 
    case 3:
        //
        // Path
        //
        if (!m_bstrImageName)
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Null memeber BSTR - m_bstrImageName."));
            goto Error;
        }
        else
        {
           return (m_bstrImageName);
        }

    default:
        ATLASSERT(0); // "this number of column is not supported "
        return(L"");

    } // endswitch (nCol)

Error:
    return(L"???");

}


/*
 -  CFaxProviderNode::CreatePropertyPages
 -
 *  Purpose:
 *      Called when creating a property page of the object
 *
 *  Arguments:
 *      [in]    lpProvider - The property sheet
 *      [in]    handle     - Handle for routing notification
 *      [in]    pUnk       - Pointer to the data object
 *      [in]    type       - CCT_* (SCOPE, RESULT, ...)
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxProviderNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                    long                    handle,
                                    IUnknown                *pUnk,
                                    DATA_OBJECT_TYPES       type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxProviderNode::CreatePropertyPages"));
    HRESULT hRc = S_OK;

    HPROPSHEETPAGE hPage;
    CppFaxProvider * pPropPageProviderGeneral = NULL;
    
    ATLASSERT(lpProvider);
    ATLASSERT(type == CCT_RESULT || type == CCT_SCOPE);


    //
    // General tab
    //
    pPropPageProviderGeneral = new CppFaxProvider(
											 handle,
                                             this,
                                             TRUE,
                                             _Module.GetResourceInstance());

	if (!pPropPageProviderGeneral)
	{
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
        goto Error;
	}
    
    
    hRc = pPropPageProviderGeneral->Init(   m_bstrProviderName, 
                                            m_bstrStatus, 
                                            m_bstrVersion, 
                                            m_bstrImageName);
    if (FAILED(hRc))
    {
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
        goto Error;
    }
    
    hPage = pPropPageProviderGeneral->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to Create() property page. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add property page for General tab. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pPropPageProviderGeneral ) 
    {
        delete  pPropPageProviderGeneral;    
        pPropPageProviderGeneral = NULL;    
    }

Exit:
    return hRc;
}


/*
 -  CFaxProviderNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxProviderNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // Display verbs that we support:
    // 1. Properties
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    //
    // We want the default verb to be Properties
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    return hRc;
}



/*
 -  CFaxProviderNode::GetStatusIDS
 -
 *  Purpose:
 *      Transslate Status to IDS.
 *
 *  Arguments:
 *
 *            [in]  enumStatus    - unsigned int with the menu IDM value
 *
 *  Return:
 *            IDS of related status message 
 */
UINT CFaxProviderNode::GetStatusIDS(FAX_ENUM_PROVIDER_STATUS enumStatus)
{
    DEBUG_FUNCTION_NAME( _T("CFaxProviderNode::GetStatusIDS"));
    
    UINT uiIds;

    switch (enumStatus)
    {
       case FAX_PROVIDER_STATUS_SUCCESS:
            // Provider was successfully loaded
            uiIds = IDS_STATUS_PROVIDER_SUCCESS;
            break;

        case FAX_PROVIDER_STATUS_SERVER_ERROR:
            // An error occured on the server while loading FSP.
            uiIds = IDS_STATUS_PROVIDER_SERVER_ERROR;
            break;

        case FAX_PROVIDER_STATUS_BAD_GUID:
            // Provider's GUID is invalid
            uiIds = IDS_STATUS_PROVIDER_BAD_GUID;
            break;

        case FAX_PROVIDER_STATUS_BAD_VERSION:
            // Provider's API version is invalid
            uiIds = IDS_STATUS_PROVIDER_BAD_VERSION;
            break;

        case FAX_PROVIDER_STATUS_CANT_LOAD:
            // Can't load provider's DLL
            uiIds = IDS_STATUS_PROVIDER_CANT_LOAD;
            break;

        case FAX_PROVIDER_STATUS_CANT_LINK:
            // Can't find required exported function(s) in provider's DLL
            uiIds = IDS_STATUS_PROVIDER_CANT_LINK;
            break;

        case FAX_PROVIDER_STATUS_CANT_INIT:
            // Failed while initializing provider
            uiIds = IDS_STATUS_PROVIDER_CANT_INIT;
            break;

        default:
            ATLASSERT(0); // "this enumStatus is not supported "
            uiIds = FXS_IDS_STATUS_ERROR; //currently 999
            break;

    } // endswitch (enumStatus)
    
    return uiIds; 
}

/*
 +
 +  CFaxProviderNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxProviderNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    _TCHAR topicName[MAX_PATH];
    
    _tcscpy(topicName, helpFile);
    
    _tcscat(topicName, _T("::/FaxS_C_ManDvices.htm"));
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(topicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, topicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\proppageinfocookie.h ===
#ifndef _PROPPAGEINFOCOOKIE_
#define _PROPPAGEINFOCOOKIE_

typedef struct {
    long ItemId;
    long IconId;
} PropPageCookie;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\proppageex.h ===
#include "FaxServer.h"
#include "FaxServerNode.h"

#ifndef _PP_PROPERTYPAGE_EX_
#define _PP_PROPERTYPAGE_EX_

#include <atlsnap.h>
#include <dlgutils.h>


template <class T, bool bAutoDelete = true>	
class ATL_NO_VTABLE CPropertyPageExImpl: public CSnapInPropertyPageImpl<T,bAutoDelete>
{
public:
	CPropertyPageExImpl(CSnapInItem * pParentNode,LPCTSTR lpszTitle = NULL):
		CSnapInPropertyPageImpl<T, bAutoDelete>(lpszTitle)
	{
		CSnapinItemEx * pItemEx;
		pItemEx = dynamic_cast<CSnapinItemEx *>(pParentNode);

		m_pFaxServer = (dynamic_cast<CFaxServerNode *>(pItemEx->GetRootNode()))->GetFaxServer();
		m_spConsole = ((CFaxServerNode *)pParentNode)->m_pComponentData->m_spConsole;
	}

	HRESULT
	ConsoleMsgBox(
		int ids,
		LPTSTR lptstrTitle = NULL,
		UINT fuStyle = MB_OK,
		int *piRetval = NULL,
		BOOL StringFromCommonDll = FALSE)
	{
		return ::ConsoleMsgBox(m_spConsole, ids, lptstrTitle, fuStyle, piRetval,StringFromCommonDll);
	}

protected:
	CComPtr<IConsole> m_spConsole;
	CFaxServer * m_pFaxServer;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\providers.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Providers.h                                            //
//                                                                         //
//  DESCRIPTION   : Header file for the Fax Providers node                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg   Create                                         //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXPROVIDERS_H
#define H_FAXPROVIDERS_H

#include "snapin.h"
#include "snpnres.h"

#include "DevicesAndProviders.h"
#include "Provider.h"

class CFaxDevicesAndProvidersNode;
class CFaxProviderNode;

class CFaxProvidersNode : public CNodeWithResultChildrenList<
                                        CFaxProvidersNode,    
                                        CFaxProviderNode, 
                                        CSimpleArray<CFaxProviderNode*>, 
                                        FALSE>
{

public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxProvidersNode, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxProvidersNode)
    END_SNAPINTOOLBARID_MAP()

    CFaxProvidersNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithResultChildrenList<CFaxProvidersNode, CFaxProviderNode, CSimpleArray<CFaxProviderNode*>, FALSE>(pParentNode, pComponentData )
    {
    }

    ~CFaxProvidersNode()
    {
    }

    virtual HRESULT PopulateResultChildrenList();
    virtual HRESULT InsertColumns(IHeaderCtrl *pHeaderCtrl);
    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }

    HRESULT InitRPC(PFAX_DEVICE_PROVIDER_INFO  *pFaxProvidersConfig);

    void InitParentNode(CFaxDevicesAndProvidersNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    virtual HRESULT OnRefresh(LPARAM arg,
                              LPARAM param,
                              IComponentData *pComponentData,
                              IComponent * pComponent,
                              DATA_OBJECT_TYPES type);

    HRESULT DoRefresh(CSnapInObjectRootBase *pRoot);

    HRESULT InitDisplayName();

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:

    static CColumnsInfo             m_ColsInfo;
    
    DWORD                           m_dwNumOfProviders;

    //pointer to mmc parent node - Devices and Providers
    CFaxDevicesAndProvidersNode   * m_pParentNode;
};

typedef CNodeWithResultChildrenList<CFaxProvidersNode, CFaxProviderNode, CSimpleArray<CFaxProviderNode*>, FALSE>
        CBaseFaxProvidersNode;

#endif  //H_FAXPROVIDERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MsFxsSnp.rc
//
#define IDR_SNAPIN_MENU                 103
#define IDD_SNAPIN                      104
#define IDS_SNAPIN_DESC                 105
#define IDS_SNAPIN_PROVIDER             106
#define IDD_FAXOUTRULE_GENERAL          106
#define IDS_SNAPIN_VERSION              107
#define IDR_SNAPIN                      108
#define IDS_FAX_COL_HEAD                108
#define IDS_OUTRRULES_COL1              109
#define IDS_OUTRRULES_COL2              110
#define IDS_OUTRRULES_COL3              111
#define IDS_OUTRRULES_COL4              112
#define IDS_OUTRRULES_COL5              113
#define IDS_OUTRRULES_COL6              114
#define IDS_TASKPAD_TITLE               116
#define IDS_MPOUTOFMEMORY               118
#define IDS_FAXOUTOFMEMORY              118
#define IDS_CREATE_PROPPAGE             119
#define IDS_GENERAL                     120
#define IDS_ASS_PORTS                   121
#define IDS_PERMISSION                  122
#define IDS_MPFAILTOLOADVERBS           123
#define IDS_CONFIRM                     124
#define IDS_REFRESH_VIEW                129
#define IDS_ADD_DESCRIPTION             136
#define IDS_DEVICE                      137
#define IDS_PROVIDER                    138
#define IDS_OTHER                       139
#define IDS_INTERNATIONAL               140
#define IDS_DOMESTIC                    141
#define IDS_LOCAL                       142
#define IDS_RETRIES_EXCEEDS_LIMIT       144
#define IDS_ALL                         145
#define IDS_EMPTY_OUTRULENAME           146
#define IDS_FAIL_ADD_OUTRULE            147
#define IDS_FAIL_ADD_RULE               147
#define IDS_DEL_OUTRULE                 148
#define IDS_FAIL_TO_REMOVE_RULE         148
#define IDS_OUTRULE_EXISTS              149
#define IDS_FAILTOSAVECHANGES_OUTRULE   150
#define IDS_INVALID_AREACODE            151
#define IDS_DEVICES_COL1                152
#define IDS_DEVICES_COL2                153
#define IDS_DEVICES_COL3                154
#define IDS_DEVICES_COL4                155
#define IDS_DEVICES_COL5                156
#define IDS_DEVICES_COL6                157
#define IDS_DEVICES_COL7                158
#define IDS_DEVICES_COL8                159
#define IDS_DEVICES_COL9                160
#define IDS_DEVICES_COL10               161
#define IDS_FAILTOADD_SENTITEMS         194
#define IDS_FAILTOADD_OUTRULE           195
#define IDS_FAILTOADD_AllDEVICES        196
#define IDS_FAILTOADD_DEVICES           197
#define IDS_ROUTINGMETHODS_COLUMN1      199
#define IDS_ROUTINGMETHODS_COLUMN2      200
#define IDR_TOOLBAR_16                  201
#define IDS_ROUTINGMETHODS_COLUMN3      201
#define IDS_ROUTINGMETHODS_COLUMN4      202
#define IDR_TOOLBAR_32                  203
#define IDS_ROUTINGMETHODS_COLUMN5      203
#define IDR_FAX_MENU                    204
#define IDS_ROUTINGMETHODS_COLUMN6      204
#define IDR_OUTRULES_MENU               205
#define IDS_ROUTINGMETHODS_COLUMN7      205
#define IDS_ROUTINGMETHODS_COLUMN8      206
#define IDD_OUTRULE_GENERAL             209
#define IDS_FAIL_ADD_DEVICE             209
#define IDD_OUTRULE_LOCATION            210
#define IDS_DEL_DEVICE                  210
#define IDI_OUTROUTINGRULES_32          211
#define IDS_DEVICE_EXISTS               211
#define IDI_OUTROUTINGRULES_16          212
#define IDS_FAILTOSAVECHANGES_DEVICE    212
#define IDD_DLGNEWOUTRULE               213
#define IDD_DLGNEWGROUP                 213
#define IDD_FAXDEVICE_GENERAL           214
#define IDD_FAXDEVICE_CONNECT           215
#define IDD_FAXDEVICE_ACTION            216
#define IDR_INMETHOD_MENU               217
#define IDR_OUTGROUP_MENU               218
#define IDR_OUTDEVICE_MENU              219
#define IDS_FAIL_TO_OPEN_OUTBOX         219
#define IDR_GROUPS_MENU                 220
#define IDD_DLGNEWDEVICE                221
#define IDD_FAXDEVICE_ACTION_ADV        222
#define IDR_TOOLBAR_DEVICE_UD           222
#define IDD_MSFAXEXT_PRINT_DIALOG       223
#define IDR_DEVICE_MENU                 223
#define IDD_FAXSERVER_GENERAL           224
#define IDR_TOOLBAR_METHOD_UD           224
#define IDD_FAXSERVER_EMAIL             225
#define IDD_FAXSERVER_RECEIPTS          225
#define IDD_FAXSERVER_LOGGING           226
#define IDD_FAXSERVER_EVENTS            227
#define IDD_FAXSERVER_OUTBOX            228
#define IDD_FAXSERVER_INBOX_ARCHIVE     229
#define IDD_FAXSERVER_SENTITEMS         230
#define IDS_FAILED2ADD_PROVIDER         230
#define IDS_FAILED2INIT_PROVIDER        231
#define IDD_FAXSERVER_SECURITY          231
#define IDD_FAXINMETHOD_GENERAL         232
#define IDS_FAILTOADD_ROUTINGRULES      233
#define IDD_DLGNEWRULE                  233
#define IDS_FAILTOADD_REPORTS           234
#define IDR_OUTGROUPS_MENU              234
#define IDD_FAXCATALOGMETHOD_GENERAL    234
#define IDS_FAILTOADD_COVERPAGES        234
#define IDS_FAILTOADD_DELETEDITEMS      235
#define IDD_FAXPROVIDER_GENERAL         235
#define IDS_FAILTOADD_PROVIDERS         236
#define IDR_OUTRULE_MENU                236
#define IDS_FAILTOADD_INBOUNDROUTING    237
#define IDD_CONNECT_TO_WIZARD           237
#define IDS_FAILTOADD_OUTBOUNDROUTING   238
#define IDS_FAIL_TO_ADD_NODE            239
#define IDR_CATALOGMETHOD_MENU          240
#define IDS_MEMORY                      240
#define IDS_GET_ARCHIVE_DIRECTORY       241
#define IDR_COVERPAGES_MENU             241
#define IDS_CANT_CONNECT                242
#define IDR_COVERPAGE_MENU              242
#define IDS_FAIL_TO_OPEN_PROP_PAGE      243
#define IDS_MEMORY_FAIL_TO_OPEN_PP      244
#define IDS_FAXSERVER_APPLICATION_NAME  245
#define IDS_NETWORK_PROBLEMS            246
#define IDS_GENERAL_FAILURE             247
#define IDS_DISPLAY_STR_FAXSERVERNODE   248
#define IDS_INVALID_PARAMETER           249
#define IDS_ACCESS_DENIED               250
#define IDR_TOOLBAR_STARTSTOP           250
#define IDD_CONFIRM_PASSWORD            251
#define IDS_GET_LOG_FILE                252
#define IDS_INBOUND_METHODS_COL1        253
#define IDS_INBOUND_METHODS_COL2        254
#define IDS_INBOUND_METHODS_COL3        255
#define IDS_INBOUND_METHODS_COL4        256
#define IDS_INBOUND_METHODS_COL5        257
#define IDS_FAILTOADD_METHODS           258
#define IDS_DISPLAY_STR_DEVICESANDPROVIDERSNODE 259
#define IDS_DISPLAY_STR_DEVICESNODE     260
#define IDS_DISPLAY_STR_PROVIDERSNODE   261
#define IDS_DISPLAY_STR_INROUTEMETHODSNODE 262
#define IDS_FXS_YES                     263
#define IDS_FXS_NO                      264
#define IDS_FAIL_NOTIFY_MMCPROPCHANGE   265
#define IDS_FAILTOADD_INBOUNDROUTINGMETHODS 266
#define IDS_INMETHOD_ENABLE             267
#define IDS_INMETHOD_DISABLE            268
#define IDS_FAIL_TOREFRESH_INMETHOD_NODE 269
#define IDS_FAIL2REFRESH_GROUP          270
#define IDS_FAILTOADD_ROUTINGGROUPS     271
#define IDS_OUTBOUND_DEVICES_COL1       272
#define IDS_OUTBOUND_DEVICES_COL2       273
#define IDS_OUTBOUND_DEVICES_COL3       274
#define IDS_OUTBOUND_DEVICES_COL4       275
#define IDS_OUTBOUND_DEVICES_COL5       276
#define IDS_OUTBOUND_DEVICES_COL6       277
#define IDS_OUTBOUND_GROUPS_COL1        278
#define IDS_OUTBOUND_GROUPS_COL2        279
#define IDS_OUTBOUND_GROUPS_COL3        280
#define IDS_OUTBOUND_GROUPS_COL4        281
#define IDS_DISPLAY_STR_OUTBOUNDROUTINGNODE 282
#define IDS_DISPLAY_STR_OUTROUTEGROUPSNODE 283
#define IDS_COUNTRY_CODE_ANY            284
#define IDS_ALL_AREAS                   285
#define IDS_ALL_DEVICES                 286
#define IDS_STATUS_RULE_EMPTY           287
#define IDS_STATUS_RULE_VALID           288
#define IDS_STATUS_RULE_INVALID_DEVICE  289
#define IDS_STATUS_RULE_SOMEDEVICESINVALID 290
#define IDS_STATUS_RULE_ALLDEVICESINVALID 291
#define IDS_DISPLAY_STR_OUTBOUNDRULES   292
#define IDS_FAIL_TO_DISCOVERDEVICENAME  293
#define IDS_STATUS_GROUP_ALL_DEV_VALID  294
#define IDS_STATUS_GROUP_EMPTY          295
#define IDS_STATUS_GROUP_ALLDEVICESINVALID 296
#define IDS_STATUS_GROUP_SOMEDEVICESINVALID 297
#define IDS_CANNOT_FIND_DEVICE          298
#define IDS_FAILTOINIT_GROUP            299
#define IDS_FAILTOADD_GROUP             300
#define IDS_FAIL_TO_DISCOVERDEVICEFORGROUP 301
#define IDS_DISPLAY_STR_INBOUNDROUTINGNODE 302
#define IDS_INVALID_GROUP_NAME          303
#define IDS_FAIL_TO_REMOVE_GROUP        304
#define IDS_FAIL2OPEN_DLG               305
#define IDS_FAIL2LOADCOUNTRYLIST        306
#define IDS_ERROR                       307
#define IDS_FAIL2LOADDEVICELIST         308
#define IDS_FAIL2READ_AREACODE          309
#define IDS_PLEASESELECT_COUNTRY        310
#define IDS_PLEASESELECT_AREACODE       311
#define IDS_FAIL_TO_REMOVE_DEVICE       311
#define IDS_PLEASESELECT_DEVICE         312
#define IDS_PLEASESELECT_GROUP          313
#define IDS_EMPTY_AREACODE              314
#define IDS_FAIL2READ_GROUPNAME         315
#define IDS_OUTGROUP_EXISTS             316
#define IDS_FAIL2REPOPULATE_GROUPS      317
#define IDS_SELECT_ITEM                 318
#define IDS_FAIL2LOADGROUPLIST          319
#define IDS_FAIL2UPDATEITEM_GROUP       320
#define IDS_MODIFYRULE                  321
#define IDS_FAIL2REFRESH_THEVIEW        322
#define IDS_FAIL2ADD_OUTBOUNDRULE       323
#define IDS_FAIL2INIT_OUTBOUNDRULE      324
#define IDS_DISPLAY_STR_METHODSCATALOGNODE 325
#define IDS_CATALOG_INMETHODS_COL1      326
#define IDS_CATALOG_INMETHODS_COL2      327
#define IDS_CATALOG_INMETHODS_COL3      328
#define IDS_CATALOG_INMETHODS_COL4      329
#define IDS_CATALOG_INMETHODS_COL5      330
#define IDS_CATALOG_INMETHODS_COL6      331
#define IDS_CATALOG_INMETHODS_COL7      332
#define IDS_PROVIDERS_COL1              333
#define IDS_PROVIDERS_COL2              334
#define IDS_PROVIDERS_COL3              335
#define IDS_PROVIDERS_COL4              336
#define IDS_PROVIDERS_COL5              337
#define IDS_PROVIDERS_COL6              338
#define IDS_PROVIDERS_COL7              339
#define IDS_PROVIDERS_COL8              340
#define IDS_STATUS_PROVIDER_SUCCESS     341
#define IDS_STATUS_PROVIDER_SERVER_ERROR 342
#define IDS_STATUS_PROVIDER_BAD_GUID    343
#define IDS_STATUS_PROVIDER_BAD_VERSION 344
#define IDS_STATUS_PROVIDER_CANT_LOAD   345
#define IDS_STATUS_PROVIDER_CANT_LINK   346
#define IDS_STATUS_PROVIDER_CANT_INIT   347
#define IDS_CHK                         348
#define IDS_SECURITY_CAT_NODE_DESC      349
#define IDS_FAXSEC_JOB_QRY              350
#define IDS_FAXSEC_JOB_SUB              351
#define IDS_FAXSEC_JOB_MNG              352
#define IDS_FAXSEC_CONFIG_QRY           353
#define IDS_FAXSEC_CONFIG_SET           354
#define IDS_COVERPAGES_COL1             358
#define IDS_COVERPAGES_COL2             359
#define IDS_COVERPAGES_COL3             360
#define IDS_COVERPAGES_COL4             361
#define IDS_COVERPAGES_COL5             362
#define IDS_COVERPAGES_COL6             363
#define IDS_COVERPAGES_COL7             364
#define IDS_FAIL2ADD_COVERPAGE          365
#define IDS_DISPLAY_STR_COVERPAGES      366
#define IDS_FAXSEC_SUB_LOW              367
#define IDS_FAXSEC_SUB_NORMAL           368
#define IDS_FAXSEC_SUB_HIGH             369
#define IDS_FAXSEC_QRY_IN_ARCH          370
#define IDS_FAXSEC_MNG_IN_ARCH          371
#define IDS_FAXSEC_QRY_OUT_ARCH         372
#define IDS_FAXSEC_MNG_OUT_ARCH         373
#define IDS_FAXSEC_CHNG_PERM            374
#define IDS_FAXSEC_CHNG_OWNER           375
#define IDS_FAIL2SET_SECURITYINFO       376
#define IDS_FAXSEC_READ_PERM            378
#define IDS_FAIL2INIT_COVERPAGE_DATA    379
#define IDS_FAIL2DELETE_COV             380
#define IDS_CP_FILETYPE                 381
#define IDS_BROWSE_COVERPAGE            382
#define IDS_BAD_CP_EXTENSION            383
#define IDS_CP_DUPLICATE                384
#define IDS_FAILED2COPY_COVERPAGE       385
#define IDS_FILENAME_TOOLONG            386
#define IDS_CP_DUP_YESNO                387
#define IDS_FAIL2GET_SERVER_CP_DIR      388
#define IDS_FAIL2STOP_SRV               389
#define IDS_FAIL2START_SRV              390
#define IDS_FAIL2UPDATE_SRVSTATUS_TOOLBAR 391
#define IDS_SRV_ALREADY_START           392
#define IDS_SRV_ALREADY_STOP            393
#define IDS_FAXCONSOLE_NOTFOUND         395
#define IDS_FAXCONSOLE_ACCESSDENIED     396
#define IDS_FAIL2LAUNCH_FAXCONSOLE_GEN  397
#define IDS_FAIL2REDRAW_GROUPSNODE      399
#define IDS_FAIL2REFERESH_GROUP         400
#define IDS_FAIL2REPOPULATE_DEVICES     401
#define IDS_FAIL2REDRAW_DEVICESNODE     402
#define IDS_FAIL2REFERESH_DEVICEINMETHODS 403
#define IDS_FAIL2ADD_DEVICENODE         404
#define IDS_SERVERNAME_STRING_CONTAINS_INVALID_CHARACTERS 405
#define IDS_SERVERNAME_EMPTY_STRING     406
#define IDS_SENDER_ADDRESS_EMPTY        407
#define IDS_DOMAIN_EMPTY                408
#define IDS_FAIL2ENABLE_METHOD_ERR      409
#define IDS_USERNAME_EMPTY              410
#define IDS_INVALID_PASSWORD            411
#define IDS_SERVERNAME_TOO_LONG         412
#define IDS_PORT_EMPTY_STRING           413
#define IDS_PORT_NOT_NUMERIC            415
#define IDS_INVALID_PORT_NUM            416
#define IDS_LOG_PATH_EMPTY              417
#define IDS_WATERMARK_EMPTY             418
#define IDI_ICON_FAXSERVER              418
#define IDS_WATERMARK_HI_LOW            419
#define IDI_INFO                        419
#define IDS_AUTODEL_EMPTY               420
#define IDB_FAX_BITMAP_32               420
#define IDS_SENT_ARCHIVE_PATH_EMPTY     421
#define IDB_FAX_BITMAP_16               421
#define IDS_INBOX_ARCHIVE_PATH_EMPTY    422
#define IDI_OUTBOX                      422
#define IDS_INBOX_WATERMARK_EMPTY       423
#define IDI_EVENTREPORT                 423
#define IDS_INBOX_WATERMARK_HI_LOW      424
#define IDS_INBOX_AUTODEL_EMPTY         425
#define IDI_INBOX                       425
#define IDS_OUTB_RETRIES_EMPTY          426
#define IDI_ACTIVITYLOGGING             426
#define IDS_OUTB_RETRYDELAY_EMPTY       427
#define IDI_RECEIPTS                    427
#define IDS_OUTB_DAYS_EMPTY             428
#define IDI_SENTITEMS                   428
#define IDS_DEVICE_RINGS_EMPTY          429
#define IDI_OUTRULE                     429
#define IDS_RESOURSE_IN_USE             430
#define IDI_INMETHOD                    430
#define IDI_DEVICE                      431
#define IDS_ERROR_DIRECTORY             432
#define IDI_PROVIDER                    432
#define IDS_ERROR_BAD_PATHNAME          433
#define IDI_CATALOG_INMETHOD            433
#define IDS_ERROR_EAS_NOT_SUPPORTED     434
#define IDS_LEFTBRACKET_PLUSSPACE       435
#define IDS_RIGHTBRACKET                436
#define IDS_LOCAL_PLUSBRACKET_PLUSSPACE 437
#define IDS_FAIL_TO_OPEN_TARGETING_WIZARD 438
#define IDS_FAIL2RENAME_NODE            439
#define IDS_FAX_CONNECT                 440
#define IDS_OPENPORT_INVALID_HANDLE     441
#define IDD_DLG_SMTP_SET                442
#define IDS_FAIL2UPDATE_SMTP_CONFIG     443
#define IDS_PASSWORD_NOT_MATCH          444
#define IDS_DEVICE_STATUS_REC_AND_SEND  445
#define IDS_DEVICE_STATUS_IDLE          446
#define IDS_DEVICE_STATUS_RECEIVING     447
#define IDS_DEVICE_STATUS_SENDING       448
#define IDS_DEVICE_STATUS_POWERED_OFF   449
#define IDS_INBOX_HIGH_WATERMARK_ZERO   450
#define IDS_SENT_HIGH_WATERMARK_ZERO    451
#define IDS_FAIL2REFRESH_DEVICE         452
#define IDS_FAX_ERR_SRV_OUTOFMEMORY     453
#define IDS_FAX_ERR_GROUP_NOT_FOUND     454
#define IDS_FAX_ERR_BAD_GROUP_CONFIGURATION 455
#define IDS_FAX_ERR_GROUP_IN_USE        456
#define IDS_FAX_ERR_RULE_NOT_FOUND      457
#define IDS_FAX_ERR_DIRECTORY_IN_USE    458
#define IDS_ERROR_PATH_NOT_FOUND        459
#define IDS_ERROR_REGISTRY_CORRUPT      460
#define IDS_BAD_GROUP_CONFIGURATION     461
#define IDS_SENT_FAX_ERR_NOT_NTFS       462  
#define IDS_INBOX_FAX_ERR_NOT_NTFS      463  
#define IDS_SENT_FAX_ERR_FILE_ACCESS_DENIED     465 
#define IDS_INBOX_FAX_ERR_FILE_ACCESS_DENIED    466   
#define IDS_LOGGING_FAX_ERR_FILE_ACCESS_DENIED  467 
#define IDS_SENT_ERROR_DISK_FULL        468   
#define IDS_INBOX_ERROR_DISK_FULL       469  
#define IDS_LOGGING_ERROR_DISK_FULL     470
#define IDS_SENT_ERROR_PATH_NOT_FOUND   471
#define IDS_INBOX_ERROR_PATH_NOT_FOUND  472
#define IDS_LOGGING_ERROR_PATH_NOT_FOUND 473
#define IDD_SELECT_COUNTRYCODE          474
#define IDS_FAIL2READ_COUNTRYCODE       475
#define IDS_MS_SMTPROUTINGMETHOD_ASSIGNED 477
#define IDS_ZERO_COUNTRYCODE            478
#define IDS_FAIL2ENABLE_METHOD          479
#define IDS_EVALUATION                  480
#define IDS_COVERPAGES_PATH_NOT_FOUND   481
#define IDS_DEVICE_AUTO                 482
#define IDS_DEVICE_MANUAL               483
#define IDS_ERR_DEVICE_LIMIT            484
#define IDS_FAX_ERR_INVALID_CSID        485
#define IDS_FAX_ERR_INVALID_TSID        486
#define IDC_LOCATION_RADIO1             1001
#define IDC_COUNTRY_RADIO               1002
#define IDC_COUNTRY_RADIO1              1003
#define IDC_ANONIM_ACCESS_RADIO1        1004
#define IDC_SMTP_ANONIM_RADIO1          1004
#define IDC_RADIO2                      1005
#define IDC_LOCATION_RADIO2             1007
#define IDC_AREA_RADIO                  1008
#define IDC_AREA_RADIO1                 1009
#define IDC_SENT_QUOTA_LOW_STATIC       1010
#define IDC_AUTENTICATE_ACCESS_RADIO2   1011
#define IDC_DESTINATION_RADIO1          1013
#define IDC_DESTINATION_RADIO11         1014
#define IDC_DESTINATION_RADIO2          1016
#define IDC_DESTINATION_RADIO21         1017
#define IDC_RETRIES_SPIN                1027
#define IDC_OUTB_MINUTES_STATIC         1028
#define IDC_PRIORITY_SPIN               1029
#define IDC_RETRYDELAY_SPIN             1032
#define IDC_RINGS_SPIN                  1033
#define IDC_RECEIVE_CHECK               1037
#define IDC_PAUSE_CHECK                 1040
#define IDC_MB2_STATIC                  1041
#define IDC_DELETE_CHECK                1045
#define IDC_GENERATE_WARNING_CHECK      1046
#define IDC_DAYS_STATIC                 1047
#define IDC_HIGH_SPIN                   1048
#define IDC_DAYS_SPIN                   1051
#define IDC_AUTODEL_SPIN                1052
#define IDC_RETRYDELAY_SPIN4            1055
#define IDC_MB2_STATIC2                 1058
#define IDC_SENT_MB2_STATIC             1058
#define IDC_RETRYDELAY_SPIN5            1061
#define IDC_RETRIES_EDIT                1062
#define IDC_RETRYDELAY_EDIT             1064
#define IDC_SPIN2                       1067
#define IDC_RINGS_EDIT                  1069
#define IDC_DAY_EDIT                    1071
#define IDC_HIGH_EDIT                   1072
#define IDC_DAYS_EDIT                   1073
#define IDC_AUTODEL_EDIT                1074
#define IDC_OUTB_RETRYDELAY_STATIC      1076
#define IDC_RETRYDELAY_EDIT4            1077
#define IDC_DESCRIPTION_EDIT            1078
#define IDC_TSID_EDIT                   1079
#define IDC_MSFAXEXT_PRINT_EDIT1        1081
#define IDC_SMTP_EDIT                   1082
#define IDC_QUOTA_LOW_STATIC            1083
#define IDC_LOG_FILE_EDIT               1084
#define IDC_DEVICE_DESCRIPTION_EDIT     1085
#define IDC_RULE_AREACODE_EDIT          1086
#define IDC_EXTENSION_DLL_EDIT          1087
#define IDC_FSPVERSION_EDIT             1088
#define IDC_QUED_ROEDIT                 1089
#define IDC_CSID_EDIT                   1092
#define IDC_SMTP_USERNAME_EDIT          1094
#define IDC_DEVICE_TSID_EDIT            1095
#define IDC_FSPSTATUS_EDIT              1096
#define IDC_OUTGOING_INPROC_ROEDIT      1097
#define IDC_CONFIRM_PASSWORD_EDIT       1098
#define IDC_SMTP_PASSWORD_EDIT          1099
#define IDC_DEVICE_CSID_EDIT            1101
#define IDC_FSPVPATH_EDIT               1102
#define IDC_INCOM_INPROC_ROEDIT         1103
#define IDC_DOMAIN_EDIT                 1105
#define IDC_NAME_EDIT                   1106
#define IDC_PORT_EDIT                   1107
#define IDC_LOCATION_RADIO3             1108
#define IDC_COUNTRYCODE_COMBO           1109
#define IDC_SENT_TO_ARCHIVE_CHECK       1110
#define IDC_SENT_GENERATE_WARNING_CHECK 1111
#define IDC_AREACODE_EDIT               1120
#define IDC_DOMESTIC_RADIO2             1122
#define IDC_DOMESTIC_RADIO1             1123
#define IDC_INTERNATIONAL_RADIO1        1124
#define IDC_INTERNATIONAL_RADIO2        1125
#define IDC_DOMESTIC_FRSTATIC           1126
#define IDC_INTERNATIONAL_FRSTATIC      1127
#define IDC_DEVICES_RADIO1              1128
#define IDC_DEVICES_RADIO2              1129
#define IDC_NAME_STATIC                 1130
#define IDC_DESCRIPTION_STATIC          1131
#define IDC_DEVICEID_STATIC             1132
#define IDC_DEVICES_FRSTATIC            1133
#define IDC_TYPE_STATIC                 1134
#define IDC_M_LINE                      1135
#define IDC_ROUTINGMETHOD_LIST          1136
#define IDC_FAXDEVICE_METHODS_LISTVIEW  1137
#define IDC_FAXDEVICE_NAME_STATIC       1138
#define IDC_FAXDEVICE_NAME_DTEXT        1139
#define IDC_FAXDEVICE_TYPE_DTEXT        1140
#define IDC_FAXDEVICE_EXTNAME_DTEXT     1141
#define IDC_FAXDEVICE_SERVERNAME_DTEXT  1142
#define IDC_FAXDEVICE_TYPE_STATIC       1143
#define IDC_SERVERNAME_STATIC           1144
#define IDC_FAXDEVICE_DESCRIPTION_STATIC 1145
#define IDC_HEADER_STATIC               1146
#define IDC_SEND_CHECK                  1147
#define IDC_SENDRECEIVE_FSTATIC         1149
#define IDC_TSID_STATIC                 1150
#define IDC_CSID_STATIC                 1152
#define IDC_ADDRESS_EDIT                1155
#define IDC_RINGS_STATIC                1156
#define IDC_TSID_FSTATIC                1158
#define IDC_LONGS_FSTATIC               1159
#define IDC_FAXDEVICE_EDIT_BUTTON       1160
#define IDC_NEWDEVICE_NAME_EDIT         1161
#define IDC_NEWDEVICE_ID_EDIT           1162
#define IDC_DEVICETYPE_COMBO            1163
#define IDC_NEWDEVICE_SERVERNAME_EDIT   1164
#define IDC_COUNTRYRULE_COMBO           1178
#define IDC_FOIP_COMBO                  1180
#define IDC_DEVICES4RULE_COMBO          1182
#define IDC_DEVICES4RULE_COMBO1         1183
#define IDC_FAXDEVICE_METHODS_HEADER    1184
#define IDC_GROUP4RULE_COMBO            1185
#define IDC_GROUP4RULE_COMBO1           1186
#define IDC_STATUS_FSTATIC              1187
#define IDC_ACTIVITY2_FSTATIC           1188
#define IDC_VERSION_STATIC              1189
#define IDC_ACTIVITY_FSTATIC            1190
#define IDC_CONFIRM_PASSWORD_STATIC     1191
#define IDC_ACTIVITY_DTEXT              1200
#define IDC_STOP_BUTTON                 1201
#define IDC_START_BUTTON                1202
#define IDC_SERVER_STATIC               1203
#define IDC_VERSION_DTEXT               1204
#define IDC_STATUS_STATIC               1205
#define IDC_STATUS_DTEXT                1206
#define IDC_EMAILSERVER_STATIC          1207
#define IDC_EMAILEXP_STATIC             1208
#define IDC_SMTP_STATIC                 1209
#define IDC_USERNAME                    1210
#define IDC_USERNAME_STATIC             1211
#define IDC_SMTP_USERNAME_STATIC        1211
#define IDC_PORT_STATIC                 1212
#define IDC_LOGGING_HEAD_STATIC         1213
#define IDC_DOMAIN_STATIC               1214
#define IDC_INCOMING_LOG_CHECK          1215
#define IDC_OUTGOING_LOG_CHECK          1216
#define IDC_DATABASE_FSTATIC            1217
#define IDC_SENT_BROWSE_BUTTON          1218
#define IDC_SLIDER1                     1219
#define IDC_SLIDER2                     1220
#define IDC_SLIDER3                     1221
#define IDC_SLIDER4                     1222
#define IDC_INBOUND_STATIC              1223
#define IDC_OUTBAND_STATIC              1224
#define IDC_INIT_STATIC                 1225
#define IDC_GENERAL_STATIC              1226
#define IDC_SENSITIVITY_HEAD_STATIC     1227
#define IDC_OUTBOX_HEADER_STATIC        1228
#define IDC_TRANS_FSTATIC               1229
#define IDC_TSID_CHECK                  1230
#define IDC_RETRIES_STATIC              1231
#define IDC_ACTIVITY_SETTINGS_STATIC    1232
#define IDC_ALLOW_PERSONAL_CHECK        1233
#define IDC_FOLDER_FSTATIC              1234
#define IDC_SENT_QUOTA_HIGH_STATIC      1235
#define IDC_FOLDER_EDIT                 1236
#define IDC_ARCHIVE_QUOTA_FSTATIC       1237
#define IDC_AUTODEL_CHECK               1238
#define IDC_QUOTA_HIGH_STATIC           1239
#define IDC_MB1_STATIC                  1240
#define IDC_ADAYS_STATIC                1241
#define IDC_MB1_STATIC2                 1242
#define IDC_SENT_HEADER_STATIC          1243
#define IDC_LOW_EDIT                    1244
#define IDC_LOW_SPIN                    1245
#define IDC_TBD_STATIC                  1246
#define IDC_TO_ARCHIVE_CHECK            1246
#define IDC_NONE1_STATIC                1247
#define IDC_HIGH1_STATIC                1248
#define IDC_NONE2_STATIC                1249
#define IDC_HIGH2_STATIC                1250
#define IDC_NONE3_STATIC                1251
#define IDC_HIGH3_STATIC                1252
#define IDC_NONE4_STATIC                1253
#define IDC_HIGH4_STATIC                1254
#define IDC_PASSWORD_STATIC             1255
#define IDC_SMTP_PASSWORD_STATIC        1255
#define IDC_BRANDING_CHECK              1256
#define IDC_TRANSSMISS_FSTATIC          1257
#define IDC_DEVICE_RINGS_STATIC         1258
#define IDC_DEVICE_RINGS_EDIT           1259
#define IDC_DEVICE_RINGS_SPIN           1260
#define IDC_GENERAL_HEAD_STATIC         1261
#define IDC_INBOX_HEAD_STATIC           1262
#define IDC_OUTRULE_HEAD_STATIC         1263
#define IDC_NEWOUTRULE_HEAD_STATIC      1264
#define IDC_NEWGROUP_HEAD_STATIC        1265
#define IDC_NEWDEVICE_HEAD_STATIC       1266
#define IDC_INMETHOD_NAME_STATIC        1267
#define IDC_INMETHOD_STATUS_STATIC      1268
#define IDC_INMETHOD_EXTENSION_STATIC   1269
#define IDC_INMETOD_NAME_H_STATIC       1270
#define IDC_INMETHOD_STATUS_H_STATIC    1271
#define IDC_INMETHOD_EXT_H_STATIC       1272
#define IDC_RULE_HEAD_STATIC            1273
#define IDC_RULETYPE_FSTATIC            1274
#define IDC_RULE_HEAD_STATIC2           1275
#define IDC_COUNTRY1_STATIC             1276
#define IDC_COUNTRY2_STATIC             1277
#define IDC_AREA_STATIC                 1278
#define IDC_RULEDESTINATION_STATIC      1279
#define IDC_GROUPNAME_STATIC            1280
#define IDC_GROUPNAME_EDIT              1281
#define IDC_AV_DEVICES_LIST             1282
#define IDC_DEVICESLIST_STATIC          1283
#define IDC_DEVICE_LISTVIEW             1284
#define IDC_SEPARATE_LINE               1285
#define IDC_RULE_AREACODE_EDIT1         1286
#define IDC_CATALOG_INBOX_STATIC        1287
#define IDC_CATA_EXTENSION_STATIC       1288
#define IDC_FSP_HEADER_STATIC           1289
#define IDC_FSPSTATUS_STATIC            1290
#define IDC_FSPPATH_STATIC              1291
#define IDC_ADDRESS_STATIC              1292
#define IDC_BASIC_AUTHEN_RADIO1         1293
#define IDC_SMTP_BASIC_RADIO2           1293
#define IDC_NTLM_AUTHEN_RADIO2          1294
#define IDC_SMTP_NTLM_RADIO3            1294
#define IDC_QUED_STATIC                 1295
#define IDC_OUTGOING_INPROC_STATIC      1296
#define IDC_INCOM_INPROC_STATIC         1297
#define IDC_SUBMISSION_CHECK            1298
#define IDC_TRANSSMI_CHECK              1299
#define IDC_RECEPTION_CHECK             1300
#define IDC_INBOX_BROWSE_BUTTON         1302
#define IDC_LOG_BROWSE_BUTTON           1303
#define IDC_SENT_HIGH_SPIN              1304
#define IDC_SENT_LOW_SPIN               1305
#define IDC_SENT_LOW_EDIT               1306
#define IDC_SENT_HIGH_EDIT              1307
#define IDC_SENT_AUTODEL_EDIT           1308
#define IDC_SENT_AUTODEL_SPIN           1309
#define IDC_SENT_AUTODEL_CHECK          1310
#define IDC_INBOX_FOLDER_EDIT           1311
#define IDC_SENT_MB1_STATIC             1312
#define IDC_DISCOUNT_START_TIME         1313
#define IDC_DISCOUNT_STOP_TIME          1314
#define IDC_OUTB_DIS_START_STATIC       1315
#define IDC_OUTB_DIS_STOP_STATIC        1316
#define IDC_CONNECT_HEADER_STATIC       1317
#define IDC_CONNECT_LOCAL_RADIO1        1318
#define IDC_CONNECT_ANOTHER_RADIO2      1319
#define IDC_CONNECT_COMPUTER_NAME_EDIT  1320
#define IDC_CONNECT_BROWSE4SERVER_BUTTON 1321
#define IDC_CONNECT_OVERRIDE_CHECK      1322
#define IDC_CONNECT_MAIN_FSTATIC        1323
#define IDC_SMTP_ANONYM_STATIC          1323
#define IDC_SMTP_BASIC_STATIC           1324
#define IDC_SMTP_NTLM_STATIC            1325
#define IDC_RECEIPT_ENABLE_SMTP_CHECK   1327
#define IDC_CHECK2                      1328
#define IDC_RECEIPT_ENABLE_MSGBOX_CHECK 1329
#define IDC_SMTP_HEADER_STATIC          1330
#define IDC_AUTHENTICATION_BUTTON       1331
#define IDC_SMTP_HEAD_STATIC            1332
#define IDC_RECEIPTS_ICON               1335
#define IDC_RECEIPTS_HELP_LINK          1337
#define IDC_RECEIPT_SMTP_FSTATIC        1338
#define IDC_RECEIPT_MESSAGEBOX_FSTATIC  1339
#define IDC_CTALOG_INMETHOD_ICON        1342
#define IDC_INBOX_ICON                  1343
#define IDC_SENT_ITEMS_ICON             1344
#define IDC_OUTBOX_ICON                 1345
#define IDC_LOGGING_ICON                1346
#define IDC_EVENTS_ICON                 1347
#define IDC_PROVIDER_ICON               1348
#define IDC_ROUTING_RULE_ICON           1349
#define IDC_INMETHOD_ICON               1350
#define IDC_FAX_DEVICE_ICON             1351
#define IDC_FAXSERVER_ICON              1352
#define IDC_EVENT_REPORT_ICON           1353
#define IDC_SMTP_ROUTE_CHECK            1354
#define IDC_SELECT_HEAD_STATIC          1355
#define IDC_NEWRULE_COUNTRYCODE_EDIT    1356
#define IDC_NEWRULE_SELECT_BUTTON       1357
#define IDC_RULE_COUNTRYCODE_EDIT       1358
#define IDC_RULE_SELECT_BUTTON          1359
#define IDC_RULE_COUNTRYCODE_EDIT1      1360
#define IDC_RULE_SELECT_BUTTON1         1361
#define IDC_SMTP_CREDENTIALS_BASIC_BUTTON   1362
#define IDC_SMTP_CREDENTIALS_NTLM_BUTTON    1363
#define IDC_RECEIVE_MANUAL_RADIO2       1364
#define IDC_RECEIVE_AUTO_RADIO1         1365
#define ID_BUTTON32768                  32768
#define ID_BUTTON32769                  32769
#define ID_BUTTON32770                  32770
#define ID_BUTTON32771                  32771
#define IDM_NEW_OUTRULE                 32772
#define IDM_NEW_FDEVICE                 32773
#define ID_BUTTON32774                  32774
#define ID_BUTTON32775                  32775
#define ID_BUTTON32777                  32777
#define ID_BUTTON32778                  32778
#define ID_BUTTON32779                  32779
#define IDM_FAX_DEVICE_SEND             32781
#define IDM_FAX_INMETHOD_ENABLE         32782
#define IDM_FAX_INMETHOD_DISABLE        32783
#define ID_BUTTON32784                  32784
#define ID_BUTTON32785                  32785
#define ID_BUTTON32786                  32786
#define ID_BUTTON32787                  32787
#define ID_BUTTON32788                  32788
#define ID_BUTTON32789                  32789
#define ID_BUTTON32790                  32790
#define ID_BUTTON32791                  32791
#define ID_BUTTON32792                  32792
#define ID_BUTTON32793                  32793
#define ID_BUTTON32794                  32794
#define IDM_NEW_GROUP                   32795
#define IDM_NEW_DEVICES                 32796
#define ID_MOVEUP_BUTTON                32797
#define ID_MOVEDOWN_BUTTON              32798
#define IDM_MOVEUP                      32799
#define IDM_MOVEDOWN                    32800
#define ID_BUTTON32801                  32801
#define ID_BUTTON32802                  32802
#define ID_BUTTON32803                  32803
#define ID_BUTTON32804                  32804
#define ID_BUTTON32805                  32805
#define ID_BUTTON32806                  32806
#define ID_BUTTON32807                  32807
#define ID_BUTTON32808                  32808
#define IDM_CONFIG_OUTRULE              32809
#define IDM_CMETHOD_MOVEUP              32810
#define IDM_CMETHOD_MOVEDOWN            32811
#define ID_BUTTON32812                  32812
#define ID_BUTTON32813                  32813
#define ID_BUTTON32814                  32814
#define ID_BUTTON32815                  32815
#define ID_BUTTON32816                  32816
#define ID_BUTTON32818                  32818
#define ID_BUTTON32820                  32820
#define ID_BUTTON32821                  32821
#define IDM_OPEN_COVERPAGE              32822
#define IDM_NEW_COVERPAGE               32823
#define IDM_EDIT_COVERPAGE              32824
#define IDM_SRV_START                   32825
#define IDM_SRV_STOP                    32826
#define ID_START_BUTTON                 32827
#define ID_STOP_BUTTON                  32828
#define ID_CLIENTCONSOLE_BUTTON         32829
#define IDM_LAUNCH_CONSOLE              32830
#define IDM_FAX_DEVICE_RECEIVE_AUTO     32831
#define IDM_FAX_DEVICE_RECEIVE_MANUAL   32832

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        485
#define _APS_NEXT_COMMAND_VALUE         32833
#define _APS_NEXT_CONTROL_VALUE         1365
#define _APS_NEXT_SYMED_VALUE           135
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\providers.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Providers.cpp                                          //
//                                                                         //
//  DESCRIPTION   : Fax Providers MMC node.                                //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg   create                                         //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "DevicesAndProviders.h"
#include "Providers.h"
#include "Provider.h"

#include "Icons.h"
#include "oaidl.h"

///////////////////////////////////////////////////////////////////////////////////////////////
// {3EC48359-53C9-4881-8109-AEB3D99BAF23}
static const GUID CFaxProvidersNodeGUID_NODETYPE = 
{ 0x3ec48359, 0x53c9, 0x4881, { 0x81, 0x9, 0xae, 0xb3, 0xd9, 0x9b, 0xaf, 0x23 } };

const GUID*    CFaxProvidersNode::m_NODETYPE = &CFaxProvidersNodeGUID_NODETYPE;
const OLECHAR* CFaxProvidersNode::m_SZNODETYPE = OLESTR("3EC48359-53C9-4881-8109-AEB3D99BAF23");
const CLSID*   CFaxProvidersNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxProvidersNode::m_ColsInfo;

/*
 -  CFaxProvidersNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxProvidersNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    HRESULT hRc = S_OK;
    DEBUG_FUNCTION_NAME( _T("CFaxProvidersNode::InsertColumns"));

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_PROVIDERS_COL1, FXS_LARGE_COLUMN_WIDTH},
        {IDS_PROVIDERS_COL2, AUTO_WIDTH},
        {IDS_PROVIDERS_COL3, FXS_WIDE_COLUMN_WIDTH},
        {IDS_PROVIDERS_COL4, FXS_LARGE_COLUMN_WIDTH},
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    CHECK_RETURN_VALUE_AND_PRINT_DEBUG (_T("m_ColsInfo.InsertColumnsIntoMMC"))

Cleanup:
    return(hRc);
}


/*
 -  CFaxProvidersNode::initRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxProvidersNode::InitRPC(PFAX_DEVICE_PROVIDER_INFO  *pFaxProvidersConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxProvidersNode::InitRPC"));
    
    HRESULT      hRc        = S_OK;
    DWORD        ec         = ERROR_SUCCESS;

    CFaxServer * pFaxServer = NULL;

    ATLASSERT(NULL == (*pFaxProvidersConfig) );
    //
    // get Fax Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }
    

    //
	// Retrieve the fax providers configuration
	//
    if (!FaxEnumerateProviders(pFaxServer->GetFaxServerHandle(), 
                        pFaxProvidersConfig,
                        &m_dwNumOfProviders)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get providers configuration. (ec: %ld)"), 
			ec);


        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }


        goto Error; 
    }
    //For max verification
    ATLASSERT(*pFaxProvidersConfig);

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get providers configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}



/*
 -  CFaxProvidersNode::PopulateResultChildrenList
 -
 *  Purpose:
 *      Create the FaxProviders children nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxProvidersNode::PopulateResultChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxProvidersNode::PopulateResultChildrenList"));
    HRESULT hRc = S_OK;

    CFaxProviderNode *   pProvider = NULL;
                       
    PFAX_DEVICE_PROVIDER_INFO  pFaxProvidersConfig = NULL ;
    DWORD i;

    //
    // Get the Config. structure with FaxEnumerateProviders
    //
    hRc = InitRPC(&pFaxProvidersConfig);
    if (FAILED(hRc))
    {
        //DebugPrint and MsgBox by called func.
        
        //to be safe actually done by InitRPC on error.
        pFaxProvidersConfig = NULL;
        
        goto Error;
    }
    ATLASSERT(NULL != pFaxProvidersConfig);

    
    for ( i=0; i< m_dwNumOfProviders; i++ )
    {
            pProvider = new CFaxProviderNode(this, m_pComponentData);
            if (!pProvider)
            {
                hRc = E_OUTOFMEMORY;
                NodeMsgBox(IDS_MEMORY);
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. (hRc: %08X)"),
			        hRc);
                goto Error;
            }
            else
            {
	            pProvider->InitParentNode(this);

                hRc = pProvider->Init(&pFaxProvidersConfig[i]);
	            if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to add provider node. (hRc: %08X)"),
			            hRc);
		            NodeMsgBox(IDS_FAILED2INIT_PROVIDER);
                    goto Error;
	            }
	            hRc = this->AddChildToList(pProvider);
	            if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to add provider to the view. (hRc: %08X)"),
			            hRc);
		            NodeMsgBox(IDS_FAILED2ADD_PROVIDER);
                    goto Error;
	            }
                else
                {
                    pProvider = NULL;
                }
            }
    }
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pProvider ) 
    {
        delete  pProvider;    
        pProvider = NULL;    
    }
    
    //
    // Get rid of what we had.
    //
    {
        // Delete each node in the list of children
        int iSize = m_ResultChildrenList.GetSize();
        for (int j = 0; j < iSize; j++)
        {
            pProvider = (CFaxProviderNode *)
                                    m_ResultChildrenList[j];
            ATLASSERT(pProvider);
            delete pProvider;
            pProvider = NULL;
        }

        // Empty the list
        m_ResultChildrenList.RemoveAll();

        // We no longer have a populated list.
        m_bResultChildrenListPopulated = FALSE;
    }
    
Exit:
    if (NULL != pFaxProvidersConfig)
    {
        FaxFreeBuffer(pFaxProvidersConfig);
    }       
    
    return hRc;
}


/*
 -  CFaxProvidersNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxProvidersNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    //  Refresh
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 

    return hRc;
}

/*
 -  CFaxProvidersNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
/* virtual */HRESULT
CFaxProvidersNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxProvidersNode::OnRefresh"));
    HRESULT hRc = S_OK;


    //
    // Call the base class
    //
    hRc = CBaseFaxProvidersNode::OnRefresh(arg,
                             param,
                             pComponentData,
                             pComponent,
                             type);
    if ( FAILED(hRc) )
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to call base class's OnRefresh. (hRc: %08X)"),
			hRc);
        goto Exit;
    }


Exit:
    return hRc;
}

/*
 -  CFaxProvidersNode::DoRefresh
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxProvidersNode::DoRefresh(CSnapInObjectRootBase *pRoot)
{
    CComPtr<IConsole> spConsole;

    //
    // Repopulate childs
    //
    RepopulateResultChildrenList();

    if (pRoot)
    {
        //
        // Get the console pointer
        //
        ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
        if (pRoot->m_nType == 1)
        {
            //
            // m_ntype == 1 means the IComponentData implementation
            //
            CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
            spConsole = pCComponentData->m_spConsole;
        }
        else
        {
            //
            // m_ntype == 2 means the IComponent implementation
            //
            CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
            spConsole = pCComponent->m_spConsole;
        }
    }
    else
    {
        ATLASSERT(m_pComponentData);
        spConsole = m_pComponentData->m_spConsole;
    }

    ATLASSERT(spConsole);
    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return S_OK;
}



/*
 -  CFaxProvidersNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxProvidersNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxProvidersNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                    IDS_DISPLAY_STR_PROVIDERSNODE))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}

/*
 +
 +  CFaxProvidersNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxProvidersNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    _TCHAR topicName[MAX_PATH];
    
    _tcscpy(topicName, helpFile);
    
    _tcscat(topicName, _T("::/FaxS_C_ManDvices.htm"));
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(topicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, topicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\root.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Root.h                                                 //
//                                                                         //
//  DESCRIPTION   : Header file for the CSnapinRoot class.                 //
//                  This is the Comet Fax extension root                   //
//                  of Comet snapin                                        //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 16 1998 yossg   first implement for modem pooling              //
//      Jan 12 1999 adik    Add support fot parent array.                  //
//      Mar 30 1999 adik    Supporting ICometSnapinNode.                   //
//                                                                         //
//      Sep 22 1999 yossg   welcome To Fax Server                           //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef ROOT_H_INCLUDED
#define ROOT_H_INCLUDED

#include "snapin.h"
#include "snpnscp.h"

class CSnapinRoot : public CNodeWithScopeChildrenList<CSnapinRoot, TRUE>
{
public:
    BEGIN_SNAPINCOMMAND_MAP(CSnapinRoot, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CSnapinRoot)
    END_SNAPINTOOLBARID_MAP()

    CSnapinRoot(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithScopeChildrenList<CSnapinRoot, TRUE>(pParentNode, pComponentData )
    {
        memset(&m_scopeDataItem,  0, sizeof(SCOPEDATAITEM));
        memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));

        m_bstrServerName       =  L"";
    }

    ~CSnapinRoot()
    {
    }

    //
    // Create the first extention level snapin root nodes
    //
    virtual HRESULT PopulateScopeChildrenList();

    HRESULT SetServerName(BSTR bstrServerName);

//    static const GUID*    m_NODETYPE;
//    static const OLECHAR* m_SZNODETYPE;
//    static const OLECHAR* m_SZDISPLAY_NAME;
//    static const CLSID*   m_SNAPIN_CLASSID;

private:
    //
    // Server Name
    //
    CComBSTR                 m_bstrServerName;

};

#endif // ! ROOT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\resutil.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : resutil.h                                              //
//                                                                         //
//  DESCRIPTION   : resource utility functions for MMC use.                //
//                                                                         //
//  AUTHOR        : zvib                                                   //
//                                                                         //
//  HISTORY       :                                                        //
//      Jun 30 1998 zvib    Init.                                          //
//      Jul 12 1998 adik    Add NEMMCUTIL_EXPORTED                         //
//      Jul 23 1998 adik    Include DefineExported.h                       //
//      Aug 24 1998 adik    Add methods to save and load.                  //
//      Aug 31 1998 adik    Add OnSnapinHelp.                              //
//      Mar 28 1999 adik    Redefine CColumnsInfo.                         //
//      Apr 27 1999 adik    Help support.                                  //
//                                                                         //
//      Oct 14 1999 yossg   Welcome to Fax								   //
//                                                                         //
//  Copyright (C) 1998 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESUTIL_H_
#define __RESUTIL_H_

#include <mmc.h>

#define LAST_IDS    0
struct ColumnsInfoInitData
{
    //
    // String id in the resource, or LAST_IDS.
    //
    int ids;

    //
    // Column width, can be HIDE_COLUMN, AUTO_WIDTH or 
    // specifies the width of the column in pixels.
    //
    int Width;
};

class  CColumnsInfo
{
public:
    CColumnsInfo();
    ~CColumnsInfo();

    //
    // Set the columns in the result pane
    //
    HRESULT InsertColumnsIntoMMC(IHeaderCtrl *pHeaderCtrl,
                                                    HINSTANCE hInst,
                                                    ColumnsInfoInitData aInitData[]);

private:
    //
    // Init the class with specific columns data
    //
    HRESULT Init(HINSTANCE hInst, ColumnsInfoInitData aInitData[]);

    //
    // Keep columns info
    //
    struct ColumnData { int Width; BSTR Header; };
    CSimpleArray<ColumnData> m_Data;

    //
    // One time initialization flag
    //
    BOOL m_IsInitialized;
};


WCHAR * __cdecl GetHelpFile();
HRESULT __cdecl OnSnapinHelp(IConsole *pConsole);

#endif //  __RESUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\securityinfo.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : SecurityInfo.cpp                                       //
//                                                                         //
//  DESCRIPTION   : The ISecurityInformation implmentation used to         //
//                  instantiate a security page.                           //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Feb  7 2000 yossg   Create                                         //
//                                                                         //
//  Copyright (C) 2000 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "SecurityInfo.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "MsFxsSnp.h"


//#pragma hdrstop

const GENERIC_MAPPING gc_FaxGenericMapping =
{
        (STANDARD_RIGHTS_READ | FAX_GENERIC_READ),
        (STANDARD_RIGHTS_WRITE | FAX_GENERIC_WRITE),
        (STANDARD_RIGHTS_EXECUTE | FAX_GENERIC_EXECUTE),
        (READ_CONTROL | WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY | FAX_GENERIC_ALL)
};


//
// siFaxAccesses
//
#define iFaxTotalSecurityEntries 14
#define iFaxDefaultSecurity      1
SI_ACCESS siFaxAccesses[] =
{
    // 0 submit permission
    {   
        &GUID_NULL, 
        FAX_ACCESS_SUBMIT ,
        MAKEINTRESOURCE(IDS_FAXSEC_SUB_LOW),
        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
    },
    // 1 submit normal permission
    {   
        &GUID_NULL, 
        FAX_ACCESS_SUBMIT_NORMAL ,
        MAKEINTRESOURCE(IDS_FAXSEC_SUB_NORMAL),
        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
    },
    // 2 submit high permission
    {   
        &GUID_NULL, 
        FAX_ACCESS_SUBMIT_HIGH ,
        MAKEINTRESOURCE(IDS_FAXSEC_SUB_HIGH),
        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
    },
    // 3 query jobs 
    {   
        &GUID_NULL, 
        FAX_ACCESS_QUERY_JOBS,
        MAKEINTRESOURCE(IDS_FAXSEC_JOB_QRY),    
        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
    },
    // 4 Manage jobs
    {   
        &GUID_NULL, 
        FAX_ACCESS_MANAGE_JOBS,
        MAKEINTRESOURCE(IDS_FAXSEC_JOB_MNG),
        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
    },
    // 5 query configuration
    {   
        &GUID_NULL, 
        FAX_ACCESS_QUERY_CONFIG,
        MAKEINTRESOURCE(IDS_FAXSEC_CONFIG_QRY),    
        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
    },
    // 6 Manage configuration
    {   
        &GUID_NULL, 
        FAX_ACCESS_MANAGE_CONFIG,
        MAKEINTRESOURCE(IDS_FAXSEC_CONFIG_SET),
        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
    },    
    // 7 Query incoming faxes archive
    {   
        &GUID_NULL, 
        FAX_ACCESS_QUERY_IN_ARCHIVE,
        MAKEINTRESOURCE(IDS_FAXSEC_QRY_IN_ARCH),    
        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
    },
    // 8 Manage incoming faxes archive
    {   
        &GUID_NULL, 
        FAX_ACCESS_MANAGE_IN_ARCHIVE,
        MAKEINTRESOURCE(IDS_FAXSEC_MNG_IN_ARCH),    
        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
    },
    // 9 Query outgoing faxes archive
    {   
        &GUID_NULL, 
        FAX_ACCESS_QUERY_OUT_ARCHIVE,
        MAKEINTRESOURCE(IDS_FAXSEC_QRY_OUT_ARCH),    
        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
    },
    // 10 Manage outgoing faxes archive
    {   
        &GUID_NULL, 
        FAX_ACCESS_MANAGE_OUT_ARCHIVE,
        MAKEINTRESOURCE(IDS_FAXSEC_MNG_OUT_ARCH),    
        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
    },
    // specific permissions
    // 11 Read permission
    {   
        &GUID_NULL, 
        READ_CONTROL,
        MAKEINTRESOURCE(IDS_FAXSEC_READ_PERM),
        SI_ACCESS_SPECIFIC 
    },
    // 12 Change Permissions
    {   
        &GUID_NULL, 
        WRITE_DAC,
        MAKEINTRESOURCE(IDS_FAXSEC_CHNG_PERM),
        SI_ACCESS_SPECIFIC 
    },
    // 13 Take ownership
    {   
        &GUID_NULL, 
        WRITE_OWNER,
        MAKEINTRESOURCE(IDS_FAXSEC_CHNG_OWNER),
        SI_ACCESS_SPECIFIC
    }
};


CFaxSecurityInformation::CFaxSecurityInformation()
{
    DebugPrint(( TEXT("CFaxSecurityInfo Created") ));
}

CFaxSecurityInformation::~CFaxSecurityInformation()
{
    DebugPrint(( TEXT("CFaxSecurityInfo Destroyed") ));    
}

/////////////////////////////////////////////////////////////////////////////
// CFaxSecurityInformation
// *** ISecurityInformation methods implementation ***

/*
 -  CFaxSecurityInformation::GetObjectInformation
 -
 *  Purpose:
 *      Performs an access check against the fax service security descriptor
 *
 *  Arguments:
 *      [in]   pObjectInfo      - pointer to object information structure.
 *
 *  Return:
 *      OLE error code
 */
HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::GetObjectInformation(
                                             IN OUT PSI_OBJECT_INFO pObjectInfo 
                                             )
{
    DEBUG_FUNCTION_NAME( _T("CFaxSecurityInformation::GetObjectInformation"));

    DWORD       ec          = ERROR_SUCCESS;
    
    CFaxServer * pFaxServer = NULL;

    CComBSTR    bstrBuff;
    HINSTANCE   hInst;
    CComBSTR    bstrServerName;

    HANDLE      hPrivBeforeSE_TAKE_OWNERSHIP = INVALID_HANDLE_VALUE;
    HANDLE      hPrivBeforeSE_SECURITY       = INVALID_HANDLE_VALUE;

    ATLASSERT( pObjectInfo != NULL );
    if( pObjectInfo == NULL ) 
    {
        DebugPrintEx( DEBUG_ERR,
			_T("Invalid parameter - pObjectInfo == NULL"));
        return E_POINTER;
    }

    //
    // Set Flags
    //
    pObjectInfo->dwFlags =  SI_EDIT_ALL       | 
                            SI_NO_TREE_APPLY  | 
                            SI_NO_ACL_PROTECT |
                            SI_ADVANCED;
    


    pFaxServer = m_pFaxServerNode->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        goto Error;
    }

    //
    // Check if to add SI_READONLY 
    //
    if (!FaxAccessCheckEx(
                        pFaxServer->GetFaxServerHandle(),
                        WRITE_DAC, 
                        NULL))
    {
		ec = GetLastError();
        if (ERROR_SUCCESS == ec)
        {
		    pObjectInfo->dwFlags |= SI_READONLY;
        }
        else 
        {
            DebugPrintEx(
			DEBUG_ERR,
			_T("Fail check access for WRITE_DAC."));
            goto Error;
        }
    }

    //
    // Check if to add SI_OWNER_READONLY 
    //
    hPrivBeforeSE_TAKE_OWNERSHIP = EnablePrivilege (SE_TAKE_OWNERSHIP_NAME);
    //
    // No error checking - If we failed we will get ERROR_ACCESS_DENIED in the access check
    // 
    if (!FaxAccessCheckEx(
                        pFaxServer->GetFaxServerHandle(),
                        WRITE_OWNER, 
                        NULL))
    {
		ec = GetLastError();
        if (ERROR_SUCCESS == ec)
        {
		    pObjectInfo->dwFlags |= SI_OWNER_READONLY;
        }
        else 
        {
            DebugPrintEx(
			DEBUG_ERR,
			_T("Fail check access for WRITE_OWNER."));
            goto Error;
        }
    }

    //
    // Check if to remove SI_EDIT_AUDITS 
    //
    hPrivBeforeSE_SECURITY = EnablePrivilege (SE_SECURITY_NAME);
    //
    // No error checking - If we failed we will get ERROR_ACCESS_DENIED in the access check
    // 

    if (!FaxAccessCheckEx(
                        pFaxServer->GetFaxServerHandle(),
                        ACCESS_SYSTEM_SECURITY, 
                        NULL))
    {
		ec = GetLastError();
        if (ERROR_SUCCESS == ec)
        {
		    pObjectInfo->dwFlags &= ~SI_EDIT_AUDITS;
        }
        else 
        {
            DebugPrintEx(
			DEBUG_ERR,
			_T("Fail check access for ACCESS_SYSTEM_SECURITY."));
            goto Error;
        }
    }


    //
    // Set all other fields
    //
    hInst = _Module.GetResourceInstance();
    pObjectInfo->hInstance = hInst;
    
    bstrServerName ==m_pFaxServerNode->GetServerName();
    if ( 0 == bstrServerName.Length() )
    {
        pObjectInfo->pszServerName = NULL;
		DebugPrintEx( DEBUG_MSG, 
            _T("NULL ServerName ie: Local machine."));
    }
    else
    {
        pObjectInfo->pszServerName = bstrServerName;
		DebugPrintEx( DEBUG_MSG, 
            _T("ServerName is: %s."), 
            pObjectInfo->pszServerName);
    }

    if (!bstrBuff.LoadString(IDS_SECURITY_CAT_NODE_DESC))
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Out of memory. Failed to load string."));
        //GetRootNode()->NodeMsgBox(IDS_MEMORY);

        goto Error;
    }
    pObjectInfo->pszObjectName = bstrBuff;

    ATLASSERT ( ERROR_SUCCESS == ec );
    ReleasePrivilege (hPrivBeforeSE_SECURITY);
    ReleasePrivilege (hPrivBeforeSE_TAKE_OWNERSHIP);
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    ReleasePrivilege (hPrivBeforeSE_SECURITY);
    ReleasePrivilege (hPrivBeforeSE_TAKE_OWNERSHIP);
    return HRESULT_FROM_WIN32(ec);

Exit:
    return S_OK;
}

/*
 -  CFaxSecurityInformation::GetSecurity
 -
 *  Purpose:
 *      requests a security descriptor for the securable object whose 
 *      security descriptor is being edited. The access control editor 
 *      calls this method to retrieve the object's current or default security descriptor.
 *
 *  Arguments:
 *      [in]   RequestedInformation  - security information.
 *      [out]  ppSecurityDescriptor  - pointer to security descriptor.
 *      [in]   fDefault              - not implemented
 *
 *  Return:
 *      OLE error code
 */
HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::GetSecurity(
                                    IN SECURITY_INFORMATION RequestedInformation,
                                    OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                                    IN BOOL fDefault 
                                    )
{
    DEBUG_FUNCTION_NAME( _T("CFaxSecurityInformation::GetSecurity"));
    HRESULT hRc = S_OK;
    CFaxServer *         pFaxServer     = NULL;
	PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD                ec             = ERROR_SUCCESS;
    BOOL                 bResult;
    HANDLE      hPrivBeforeSE_SECURITY       = INVALID_HANDLE_VALUE;


    ATLASSERT( ppSecurityDescriptor);
	   
    if( fDefault == TRUE ) 
    {
        DebugPrintEx( DEBUG_MSG,
			_T("Non implemeted feature -> fDefault == TRUE"));
        return E_NOTIMPL;
    }  

	if (RequestedInformation & SACL_SECURITY_INFORMATION)
	{
		hPrivBeforeSE_SECURITY = EnablePrivilege (SE_SECURITY_NAME);    
	}

    pFaxServer = m_pFaxServerNode->GetFaxServer();
    ATLASSERT(pFaxServer);

	if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        
        hRc = HRESULT_FROM_WIN32(ec);
        goto Exit;
    }

	//
    // Get the current relative descriptor from the fax server
    //
    bResult = FaxGetSecurityEx( pFaxServer->GetFaxServerHandle(), 
                                RequestedInformation,
                                &pSecurityDescriptor);
    if( bResult == FALSE ) 
    {
        ec = GetLastError();
        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. Failed to set security info.(ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }
        else
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Failed while call to FaxGetSecurityEx. (ec: %ld)"), 
			    ec);
        }
        hRc = HRESULT_FROM_WIN32(ec);
        goto Exit;
    }

	//
    // return a self relative descriptor copy allocated with LocalAlloc()
    //
	hRc = MakeSelfRelativeCopy( pSecurityDescriptor, ppSecurityDescriptor );
    if( FAILED( hRc ) ) 
    {
        DebugPrintEx( 
            DEBUG_ERR,
			_T("MakeSelfRelativeCopy Failed. (hRc : %08X)"),
            hRc);
        goto Exit;
    }    
    
    ATLASSERT(S_OK == hRc);
    

Exit:
	if (NULL != pSecurityDescriptor)
	{
		FaxFreeBuffer(pSecurityDescriptor);
	}
	ReleasePrivilege (hPrivBeforeSE_SECURITY);
    return hRc;
}

/*
 -  CFaxSecurityInformation::SetSecurity
 -
 *  Purpose:
 *      Provides a security descriptor containing the security information 
 *      the user wants to apply to the securable object. The access control 
 *      editor calls this method when the user clicks the Okay or Apply buttons.
 *
 *  Arguments:
 *      [in]   SecurityInformation - security information structure.
 *      [in]   pSecurityDescriptor - pointer to security descriptor.
 *
 *  Return:
 *      OLE error code
 */
HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::SetSecurity(
                                    IN SECURITY_INFORMATION SecurityInformation,
                                    IN PSECURITY_DESCRIPTOR pSecurityDescriptor 
                                    )
{
    DEBUG_FUNCTION_NAME( _T("CFaxSecurityInformation::SetSecurity"));
    HRESULT              hRc            = S_OK;
    DWORD                ec             = ERROR_SUCCESS;
    BOOL                 bResult;

    HINSTANCE            hInst = _Module.GetResourceInstance();
    PSECURITY_DESCRIPTOR psdSelfRelativeCopy = NULL;
    
    CFaxServer *         pFaxServer     = NULL;

	HANDLE      hPrivBeforeSE_TAKE_OWNERSHIP = INVALID_HANDLE_VALUE;
    HANDLE      hPrivBeforeSE_SECURITY       = INVALID_HANDLE_VALUE;
 
    ATLASSERT( NULL != pSecurityDescriptor ); 
    ATLASSERT( IsValidSecurityDescriptor( pSecurityDescriptor ) );     
	
	//
    // Prepare self relative descriptor
    //
	hRc = MakeSelfRelativeCopy( pSecurityDescriptor, &psdSelfRelativeCopy );
    if( FAILED( hRc ) ) 
    {
        DebugPrintEx( 
            DEBUG_ERR,
			_T("MakeSelfRelativeCopy Failed. (hRc : %08X)"),
            hRc);
        goto Exit;
    }

	if (SecurityInformation & OWNER_SECURITY_INFORMATION)
	{
		hPrivBeforeSE_TAKE_OWNERSHIP = EnablePrivilege (SE_TAKE_OWNERSHIP_NAME);    
	}

	if (SecurityInformation & SACL_SECURITY_INFORMATION)
	{
		hPrivBeforeSE_SECURITY = EnablePrivilege (SE_SECURITY_NAME);
	}
	
    pFaxServer = m_pFaxServerNode->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        
        hRc = HRESULT_FROM_WIN32(ec);
        goto Exit;
    }

    //
    // save the new relative descriptor to the fax server
    //
    bResult = FaxSetSecurity( pFaxServer->GetFaxServerHandle(), 
                              SecurityInformation,
                              psdSelfRelativeCopy);
    if( bResult == FALSE ) 
    {
        ec = GetLastError();
        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. Failed to set security info.(ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }
        else
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Failed while call to FaxSetSecurity. (ec: %ld)"), 
			    ec);
        }
        hRc = HRESULT_FROM_WIN32(ec);
        goto Exit;
    }

    ATLASSERT( S_OK == hRc || E_ACCESSDENIED == hRc);	

Exit:
    if (NULL != psdSelfRelativeCopy)
	{
		::LocalFree(psdSelfRelativeCopy);
		psdSelfRelativeCopy = NULL;
	}

	ReleasePrivilege (hPrivBeforeSE_SECURITY);
    ReleasePrivilege (hPrivBeforeSE_TAKE_OWNERSHIP);

		
	return hRc;
}

/*
 -  CFaxSecurityInformation::GetAccessRights
 -
 *  Purpose:
 *      Requests information about the access rights that can be 
 *      controlled for a securable object. The access control 
 *      editor calls this method to retrieve display strings and 
 *      other information used to initialize the property pages.
 *
 *  Arguments:
 *      [in] pguidObjectType  - Pointer to a GUID structure that 
 *                              identifies the type of object for which 
 *                              access rights are being requested. 
 *      [in] dwFlags -          A set of bit flags that indicate the property
 *                              page being initialized
 *      [out] ppAccess -        Pointer to a variable that you should 
 *                              set to a pointer to an array of SI_ACCESS 
 *                              structures. 
 *      [out] pcAccesses -      Pointer to a variable that you should set 
 *                              to indicate the number of entries in the ppAccess array. 
 *      [out] piDefaultAccess - Pointer to a variable that you should set 
 *                              to indicate the zero-based index of the array entry that contains 
 *                              the default access rights. 
 *                              The access control editor uses this entry as the initial access rights in a new ACE. 
 *
 *  Return:
 *      OLE error code
 */
HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::GetAccessRights(
                                        IN const GUID* pguidObjectType,
                                        IN DWORD dwFlags, // SI_EDIT_AUDITS, SI_EDIT_PROPERTIES
                                        OUT PSI_ACCESS *ppAccess,
                                        OUT ULONG *pcAccesses,
                                        OUT ULONG *piDefaultAccess 
                                        )
{
    DEBUG_FUNCTION_NAME( _T("CFaxSecurityInformation::GetAccessRights"));

    ATLASSERT( ppAccess );
    ATLASSERT( pcAccesses );
    ATLASSERT( piDefaultAccess );

    *ppAccess        = siFaxAccesses;    
    *pcAccesses      = iFaxTotalSecurityEntries;    
    *piDefaultAccess = iFaxDefaultSecurity;

    return S_OK;
}

/*
 -  CFaxSecurityInformation::MapGeneric
 -
 *  Purpose:
 *      Requests that the generic access rights in an access mask 
 *      be mapped to their corresponding standard and specific access rights.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::MapGeneric(
                                   IN const GUID *pguidObjectType,
                                   IN UCHAR *pAceFlags,
                                   IN OUT ACCESS_MASK *pMask
                                   )
{
    DEBUG_FUNCTION_NAME( _T("CFaxSecurityInformation::MapGeneric"));

    MapGenericMask( pMask, const_cast<PGENERIC_MAPPING>(&gc_FaxGenericMapping) );

    return S_OK;
}


/*
 -  CFaxSecurityInformation::GetInheritTypes
 -
 *  Purpose:
 *      Not implemented. 
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::GetInheritTypes(
                                        OUT PSI_INHERIT_TYPE *ppInheritTypes,
                                        OUT ULONG *pcInheritTypes 
                                        )
{
    DEBUG_FUNCTION_NAME( _T("CFaxSecurityInformation::GetInheritTypes  --- Not implemented"));
    return E_NOTIMPL;
}

/*
 -  CFaxSecurityInformation::PropertySheetPageCallback
 -
 *  Purpose:
 *      Notifies an EditSecurity or CreateSecurityPage caller 
 *      that an access control editor property page is being created or destroyed. 
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT 
STDMETHODCALLTYPE 
CFaxSecurityInformation::PropertySheetPageCallback(
                                                  IN HWND hwnd, 
                                                  IN UINT uMsg, 
                                                  IN SI_PAGE_TYPE uPage 
                                                  )
{
    DEBUG_FUNCTION_NAME( _T("CFaxSecurityInformation::PropertySheetPageCallback"));	
    return S_OK;
}



/*
 -  CFaxSecurityInformation::MakeSelfRelativeCopy
 -
 *  Purpose:
 *      This pravite method copies Security descriptors 
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxSecurityInformation::MakeSelfRelativeCopy(
                                                     PSECURITY_DESCRIPTOR  psdOriginal,
                                                     PSECURITY_DESCRIPTOR* ppsdNew 
                                                     )
{
    DEBUG_FUNCTION_NAME( _T("CFaxSecurityInformation::MakeSelfRelativeCopy"));
    ATLASSERT( NULL != psdOriginal );

    // we have to find out whether the original is already self-relative
    SECURITY_DESCRIPTOR_CONTROL         sdc                 = 0;
    PSECURITY_DESCRIPTOR                psdSelfRelativeCopy = NULL;
    DWORD                               dwRevision          = 0;
    DWORD                               cb                  = 0;

    ATLASSERT( IsValidSecurityDescriptor( psdOriginal ) ); 

    if( !::GetSecurityDescriptorControl( psdOriginal, &sdc, &dwRevision ) ) 
    {
        DWORD err = ::GetLastError();
                    DebugPrintEx( DEBUG_ERR,
			            _T("Invalid security descriptor."));

        return HRESULT_FROM_WIN32( err );
    }

    if( sdc & SE_SELF_RELATIVE )
	{
        // the original is in self-relative format, just byte-copy it

        // get size
        cb = ::GetSecurityDescriptorLength( psdOriginal );

        // alloc the memory
        psdSelfRelativeCopy = (PSECURITY_DESCRIPTOR) ::LocalAlloc( LMEM_ZEROINIT, cb );
        if(NULL == psdSelfRelativeCopy) 
        {
	        DebugPrintEx(
		        DEBUG_ERR,
		        TEXT("Out of memory."));
            //GetRootNode()->NodeMsgBox(IDS_MEMORY);
            return E_OUTOFMEMORY;
        }

        // make the copy
        ::memcpy( psdSelfRelativeCopy, psdOriginal, cb );
    } 
    else 
    {
        // the original is in absolute format, convert-copy it

        // get new size - it will fail and set cb to the correct buffer size
        ::MakeSelfRelativeSD( psdOriginal, NULL, &cb );

        // alloc the new amount of memory
        psdSelfRelativeCopy = (PSECURITY_DESCRIPTOR) ::LocalAlloc( LMEM_ZEROINIT, cb );
        if(NULL == psdSelfRelativeCopy) 
        {
	        DebugPrintEx(
		        DEBUG_ERR,
		        TEXT("Out of memory."));
            //GetRootNode()->NodeMsgBox(IDS_MEMORY);
            return E_OUTOFMEMORY; // just in case the exception is ignored
        }

        if( !::MakeSelfRelativeSD( psdOriginal, psdSelfRelativeCopy, &cb ) ) 
        {
	        DebugPrintEx(
		        DEBUG_ERR,
		        _T("::MakeSelfRelativeSD returned NULL"));

            if( NULL == ::LocalFree( psdSelfRelativeCopy ) ) 
            {
                DWORD err = ::GetLastError();
                return HRESULT_FROM_WIN32( err );
            }
            psdSelfRelativeCopy = NULL;
        }
    }

    *ppsdNew = psdSelfRelativeCopy;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\securityinfo.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : SecurityInfo.cpp                                       //
//                                                                         //
//  DESCRIPTION   : The header file of the ISecurityInformation interface  //
//                  used to instantiate a security page.                   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //                                                                         //
//  HISTORY       :                                                        //
//      Feb  7 2000 yossg   Create                                         //
//                                                                         //
//  Copyright (C) 2000 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __FAX_SECURITY_INFO_H_
#define __FAX_SECURITY_INFO_H_

//#include <atlcom.h>
#include "MsFxsSnp.h"
#include <aclui.h>              // ACL UI editor

class CFaxServerNode; // forward decl

class ATL_NO_VTABLE CFaxSecurityInformation : 
    public CComObjectRootEx<CComSingleThreadModel>,
    //public CComCoClass<CFaxSecurityInformation, &CLSID_FaxSecurityInformation>,
    public ISecurityInformation 
{
public:
    CFaxSecurityInformation::CFaxSecurityInformation();
    CFaxSecurityInformation::~CFaxSecurityInformation();
	void Init(CFaxServerNode * pFaxServerNode)
	{
		ATLASSERT(pFaxServerNode);
		m_pFaxServerNode = pFaxServerNode;
	}

    DECLARE_NOT_AGGREGATABLE(CFaxSecurityInformation)

    BEGIN_COM_MAP(CFaxSecurityInformation)
      //COM_INTERFACE_ENTRY(ISecurityInformation)
      COM_INTERFACE_ENTRY_IID(IID_ISecurityInformation,ISecurityInformation)
    END_COM_MAP()

    public:    
    // *** ISecurityInformation methods ***
    virtual HRESULT STDMETHODCALLTYPE GetObjectInformation(
                                                   OUT PSI_OBJECT_INFO pObjectInfo );

    virtual HRESULT STDMETHODCALLTYPE GetSecurity(
                                                   IN SECURITY_INFORMATION RequestedInformation,
                                                   OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                                                   IN BOOL fDefault );

    virtual HRESULT STDMETHODCALLTYPE SetSecurity(
                                                   IN SECURITY_INFORMATION SecurityInformation,
                                                   IN PSECURITY_DESCRIPTOR pSecurityDescriptor );

    virtual HRESULT STDMETHODCALLTYPE GetAccessRights(
                                                   IN const GUID* pguidObjectType,
                                                   IN DWORD dwFlags, // SI_EDIT_AUDITS, SI_EDIT_PROPERTIES
                                                   OUT PSI_ACCESS *ppAccess,
                                                   OUT ULONG *pcAccesses,
                                                   OUT ULONG *piDefaultAccess );

    virtual HRESULT STDMETHODCALLTYPE MapGeneric(
                                                   IN const GUID *pguidObjectType,
                                                   IN UCHAR *pAceFlags,
                                                   IN OUT ACCESS_MASK *pMask);

    virtual HRESULT STDMETHODCALLTYPE PropertySheetPageCallback(
                                                   IN HWND hwnd, 
                                                   IN UINT uMsg, 
                                                   IN SI_PAGE_TYPE uPage );

    // no need to implement 
    virtual HRESULT STDMETHODCALLTYPE GetInheritTypes(
                                                   OUT PSI_INHERIT_TYPE *ppInheritTypes,
                                                   OUT ULONG *pcInheritTypes );

    // internal methods
	HRESULT MakeSelfRelativeCopy(
                                PSECURITY_DESCRIPTOR  psdOriginal,
                                PSECURITY_DESCRIPTOR* ppsdNew 
                                );

private:
	CFaxServerNode *		m_pFaxServerNode;
};

#endif //__FAX_SECURITY_INFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\snapin.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Snapin.h                                               //
//                                                                         //
//  DESCRIPTION   : Header file for                                        //
//                    includes of comet\inc\c_Snapin.h                     //
//                                                                         //
//  AUTHOR        : ATL Snapin class wizard                                //
//                                                                         //
//  HISTORY       :                                                        //
//      May 25 1998 adik    Init.                                          //
//      Aug 24 1998 adik    Use Comet version.                             //
//      Sep 14 1998 yossg   seperate common source to an included file     //
//                                                                         //
//      Sep 22 1999 yossg   welcome To Fax Server                           //
//																		   //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef SNAPIN_H_INCLUDED
#define SNAPIN_H_INCLUDED

//EXTERN_C const CLSID CLSID_Snapin;
//EXTERN_C const CLSID CLSID_SnapinAbout;

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
#include "C_Snapin.h"
/////////////////////////////////////////////////////////////////////////////


#endif // ! SNAPIN_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\root.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Root.cpp                                               //
//                                                                         //
//  DESCRIPTION   : Implementation of the Fax extension snapin             //
//                  The snapin root is a hidden node that use to extend    //
//                  comet node.                                            //
//                                                                         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 27 1999 yossg   create                                         //
//      Dec  9 1999 yossg   Call InitDisplayName from parent			   //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "snapin.h"
#include "snpnode.h"

#include "Root.h"

#include "FaxServerNode.h"

#include "Icons.h"
#include "resource.h"


/****************************************************

CSnapinRoot Class

 ****************************************************/
// {89A457D1-FDF9-11d2-898A-00104B3FF735}
static const GUID CSnapinRootGUID_NODETYPE = 
{ 0x89a457d1, 0xfdf9, 0x11d2, { 0x89, 0x8a, 0x0, 0x10, 0x4b, 0x3f, 0xf7, 0x35 } };

const GUID*  CSnapinRoot::m_NODETYPE = &CSnapinRootGUID_NODETYPE;
const OLECHAR* CSnapinRoot::m_SZNODETYPE = OLESTR("89A457D1-FDF9-11d2-898A-00104B3FF735");
const OLECHAR* CSnapinRoot::m_SZDISPLAY_NAME = OLESTR("root");
const CLSID* CSnapinRoot::m_SNAPIN_CLASSID = &CLSID_Snapin;


/*
 -  CSnapinRoot::PopulateScopeChildrenList
 -
 *  Purpose:
 *      Create the Fax Server snapin root node
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CSnapinRoot::PopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CSnapinRoot::PopulateScopeChildrenList()"));
    HRESULT hr = S_OK;

    //
    // Add the Fax Node
    //
    CFaxServerNode  *  pI;

    pI = new CFaxServerNode(this, m_pComponentData, m_bstrServerName.m_str);
    if (pI == NULL)
    {
        hr = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
        goto Cleanup;
    }

    pI->SetIcons(IMAGE_FAX, IMAGE_FAX);
    hr = pI->InitDisplayName();
    if ( FAILED(hr) )
    {
        DebugPrintEx(DEBUG_ERR,_T("Failed to display node name. (hRc: %08X)"), hr);                       
        NodeMsgBox(IDS_FAIL_TO_ADD_NODE);
        delete pI;
        goto Cleanup;
    }

    hr = AddChild(pI, &pI->m_scopeDataItem);
    if ( FAILED(hr) )
    {
        DebugPrintEx(DEBUG_ERR,_T("Failed to AddChild. (hRc: %08X)"), hr);                       
        NodeMsgBox(IDS_FAIL_TO_ADD_NODE);
        delete pI;
        goto Cleanup;
    }

Cleanup:
    return hr;
}


/*
 -  CSnapinRoot::SetServerName
 -
 *  Purpose:
 *      Set the Server machine name
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CSnapinRoot::SetServerName(BSTR bstrServerName)
{
    DEBUG_FUNCTION_NAME( _T("CSnapinRoot::SetServerName"));
    HRESULT hRc = S_OK;

    m_bstrServerName = bstrServerName;
    if (!m_bstrServerName)
    {
        hRc = E_OUTOFMEMORY;
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to allocate string - out of memory"));
        
        NodeMsgBox(IDS_MEMORY);
       
        m_bstrServerName = L"";
    }

    return hRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\resutil.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : resutil.cpp                                            //
//                                                                         //
//  DESCRIPTION   : resource utility functions for MMC use.                //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jun 30 1998 zvib    Init.                                          //
//      Aug 24 1998 adik    Add methods to save and load.                  //
//      Aug 31 1998 adik    Add GetChmFile & OnSnapinHelp.                 //
//      Mar 28 1999 adik    Redefine CColumnsInfo.                         //
//      Apr 27 1999 adik    Help support.                                  //
//      Jun 02 1999 adik    Change the path to comet.chm.                  //
//      Jun 22 1999 adik    Change the path to comet.chm to full path.     //
//                                                                         //
//      Oct 14 1999 yossg   Welcome to Fax								   //
//                                                                         //
//  Copyright (C) 1998 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resutil.h"
#include "commctrl.h"
#include <HtmlHelp.h>

#define MAX_COLUMN_LENGTH 300

/*
 -  CColumnsInfo::CColumnsInfo
 -
 *  Purpose:
 *      Constructor
 */

CColumnsInfo::CColumnsInfo()
{
    m_IsInitialized = FALSE;
}

/*
 -  CColumnsInfo::~CColumnsInfo
 -
 *  Purpose:
 *      Destructor
 */

CColumnsInfo::~CColumnsInfo()
{
    int i;

    for (i=0; i < m_Data.GetSize(); i++)
    {
        SysFreeString(m_Data[i].Header);
    }
}

/*
 -  CColumnsInfo::InsertColumnsIntoMMC
 -
 *  Purpose:
 *      Add columns to the default result pane
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - console provided result pane header
 *      [in]    hInst       - resource handle
 *      [in]    aInitData   - columns init data: array of ids & width.
 *                            the last ids must be LAST_IDS.
 *
 *  Return:
 *      S_OK for success
 *      + return value from IHeaderCtrl::InsertColumn
 */
HRESULT
CColumnsInfo::InsertColumnsIntoMMC(IHeaderCtrl *pHeaderCtrl,
                                   HINSTANCE hInst, 
                                   ColumnsInfoInitData aInitData[])
{
     int        i;
     HRESULT    hRc = S_OK;

     DEBUG_FUNCTION_NAME( _T("CColumnsInfo::InsertColumnsIntoMMC"));
     ATLASSERT(pHeaderCtrl);

     //
     // First time init
     //
     if (! m_IsInitialized)
     {
         hRc = Init(hInst, aInitData);
         if ( FAILED(hRc) )
         {
             DebugPrintEx(DEBUG_ERR,_T("Failed to Init. (hRc: %08X)"), hRc);
             goto Cleanup;
         }
     }
     ATLASSERT(m_IsInitialized);

     //
     // Set all columns headers
     //
     for (i=0; i < m_Data.GetSize(); i++ )
     {
         //
         // Insert the column
         //
         hRc = pHeaderCtrl->InsertColumn(i, 
                                         m_Data[i].Header,
                                         LVCFMT_LEFT,
                                         m_Data[i].Width);
         if ( FAILED(hRc) )
         {
             DebugPrintEx(DEBUG_ERR,_T("Failed to InsertColumn. (hRc: %08X)"), hRc);
             goto Cleanup;
         }
     }
Cleanup:
     return hRc;
}

/*
 -  CColumnsInfo::Init
 -
 *  Purpose:
 *      Init the class with columns info
 *
 *  Arguments:
 *      [in]    hInst     - resource handle
 *      [in]    aInitData - columns init data: array of ids & width.
 *                          the last ids must be LAST_IDS.
 *
 *  Return:
 *      S_OK for success
 *      + return value from LoadString
 *      + E_OUTOFMEMORY
 */
HRESULT 
CColumnsInfo::Init(HINSTANCE hInst, ColumnsInfoInitData aInitData[])
{
    WCHAR               buf[MAX_COLUMN_LENGTH];
    ColumnsInfoInitData *pData;
    int                 rc, ind;
    BOOL                fOK;
    HRESULT             hRc = S_OK;
    ColumnData          dummy;
    
    DEBUG_FUNCTION_NAME( _T("CColumnsInfo::Init"));
               
    ATLASSERT(aInitData);
    ATLASSERT(! m_IsInitialized);

    //
    // Insert all column headers
    //
    ZeroMemory(&dummy, sizeof dummy);
    for (pData = &aInitData[0]; pData->ids != LAST_IDS; pData++)
    {
        //
        // Load the string from the resource
        //
        rc = LoadString(hInst, pData->ids , buf, MAX_COLUMN_LENGTH);
        if (rc == 0)
        {
            DWORD dwErr = GetLastError();
            hRc = HRESULT_FROM_WIN32(dwErr);
            DebugPrintEx(DEBUG_ERR,_T("Failed to LoadString. (hRc: %08X)"), hRc);
            goto Cleanup;
        }

        //
        // Duplicates the empty struct into the array
        //
        fOK = m_Data.Add(dummy);
        if (! fOK)
        {
            hRc = E_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR,_T(" m_Data.Add failed. (hRc: %08X)"), hRc);
            goto Cleanup;
        }

        //
        // Set the data
        //
        ind = m_Data.GetSize()-1;
        ATLASSERT(ind >= 0);
        m_Data[ind].Width = pData->Width;
        m_Data[ind].Header = SysAllocString(buf);
        if (! m_Data[ind].Header)
        {
            hRc = E_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR,_T("Failed to SysAllocString. (hRc: %08X)"), hRc);
            goto Cleanup;
        }
    } // endfor

    m_IsInitialized = TRUE;

Cleanup:
    return hRc;
}

/*
 -  GetHelpFile
 -
 *  Purpose:
 *      Get full path to the comet CHM file
 *
 *  Arguments:
 *      [out]   pwszChmFile - fullath of the CHM file
 *
 *  Return:
 *      OLE error code translated from registry open/query error
 */
WCHAR * __cdecl
GetHelpFile()
{
    static  WCHAR szFile[MAX_PATH] = {0};

    DEBUG_FUNCTION_NAME( _T("GetHelpFile"));

    if (szFile[0] == L'\0')
    {
        ExpandEnvironmentStrings(L"%windir%\\help\\FxsAdmin.chm", szFile, MAX_PATH);
    }

    return (szFile[0])? szFile: NULL;
}

/*
 -  OnSnapinHelp
 -
 *  Purpose:
 *      Display Comet.chm help file. This method gets called when the
 *      MMCN_SNAPINHELP Notify message is sent for IComponent object.
 *      MMC sends this message when the user requests help about
 *      the snap-in.
 *
 *  Arguments:
 *      [in]    pConsole - MMC console interface
 *
 *  Return:
 *      Errors returned from GetChmFile
 */
HRESULT __cdecl
OnSnapinHelp(IConsole *pConsole)
{
    WCHAR   *pszChmFile;
    HWND    hWnd = NULL;
    HRESULT hRc = E_FAIL;

    //
    // Get the caller window
    //
    ATLASSERT(pConsole);
    pConsole->GetMainWindow(&hWnd);

    //
    // Get the CHM file name
    //
    pszChmFile = GetHelpFile();

    //
    // Use HtmlHelp API to display the help.
    //
    if ( pszChmFile && *pszChmFile )
    {
        hRc = S_OK;
//        HtmlHelp(hWnd, pszChmFile, HH_DISPLAY_TOPIC,  (DWORD)0);
    }

    return hRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\snapin.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Snapin.cpp                                             //
//                                                                         //
//  DESCRIPTION   : Implementation file for                                //
//                    CSnapin          class                               //
//                    CSnapinComponent class                               //
//                                                                         //
//  AUTHOR        : ATL Snapin wizard                                      //
//                                                                         //
//  HISTORY       :                                                        //
//      May 25 1998 adik    Init.                                          //
//      Sep 14 1998 yossg   seperate common source to an included file     //
//      Mar 28 1999 adik    Remove persistence support (done by mmc 1.2).  //
//                                                                         //
//      Sep 27 1999 yossg   Welcome to Fax Server			   //
//      Dec 12 1999 yossg   add CSnapin::Notify				   //
//      Apr 14 2000 yossg   add support for primary snapin mode		   //
//      Jun 25 2000 yossg   add stream and command line primary snapin 	   //
//                          machine targeting.                             //
//                          Windows XP                                     //
//      Feb 14 2001 yossg   Add Manual Receive support                     //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "resource.h"

#include "MsFxsSnp.h"

#include "Snapin.h"
#include "root.h"

#include "FaxServerNode.h"
#include "FaxMMCPropertyChange.h"

static const GUID CSnapinExtGUID_NODETYPE = 
{ 0x476e6449, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
const GUID*    CSnapinExtData::m_NODETYPE = &CSnapinExtGUID_NODETYPE;
const OLECHAR* CSnapinExtData::m_SZNODETYPE = OLESTR("476e6449-aaff-11d0-b944-00c04fd8d5b0");
const OLECHAR* CSnapinExtData::m_SZDISPLAY_NAME = OLESTR("Fax");
const CLSID*   CSnapinExtData::m_SNAPIN_CLASSID = &CLSID_Snapin;
/////////////////////////////////////////////////////////////////////////////
#include "resutil.h"
#include "c_snapin.cpp"
/////////////////////////////////////////////////////////////////////////////

//
// Clipboard Formats
//
const CLIPFORMAT gx_CCF_COMPUTERNAME = (CLIPFORMAT) RegisterClipboardFormat(_T("MMC_SNAPIN_MACHINE_NAME"));


BOOL ExtractComputerName(IDataObject* pDataObject, BSTR * pVal)
{
    DEBUG_FUNCTION_NAME( _T("ExtractComputerName"));

	//
	// Find the computer name from the ComputerManagement snapin
	//
	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { gx_CCF_COMPUTERNAME, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    //
    // Allocate memory for the stream
    //
    int len = 500;

    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, len);
	if(stgmedium.hGlobal == NULL)
    {
        DebugPrintEx( DEBUG_ERR,
		    _T("GlobalAlloc Fail. stgmedium.hGlobal == NULL, can not extract computerName"));
		return FALSE;
    }


	HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium);

    if (!SUCCEEDED(hr))
    {
        ATLASSERT(FALSE);
        DebugPrintEx( DEBUG_ERR,
		    _T("Fail to GetDataHere"));
		return FALSE;
    }

	//
	// Get the computer name
	//
    *pVal = SysAllocString((WCHAR *)stgmedium.hGlobal);
    if (NULL == *pVal)
    {
        DebugPrintEx( DEBUG_ERR,
		    _T("Out of memory - fail to allocate server name !!!"));
        return FALSE;
    }

	GlobalFree(stgmedium.hGlobal);
    return TRUE;
}


/*
 -  CSnapinExtData::GetExtNodeObject
 -
 *  Purpose:
 *      Connect as an extension to root node.
 *
 *  Arguments
 *
 *  Return:
 *      The HTM path name
 */
CSnapInItem*
CSnapinExtData::GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
{
    DEBUG_FUNCTION_NAME( _T("MsFxsSnp.dll - CSnapinExtData::GetExtNodeObject"));


    CComBSTR        bstrComputer; 

    m_pDataObject = pDataObject;

    CSnapinRoot *pRoot = new CSnapinRoot(this, m_pComponentData);
    if (pRoot == NULL)
    {
        DebugPrintEx(DEBUG_ERR,_T("new CSnapinRoot"), E_OUTOFMEMORY);
        return pDefault;
    }

    if (!ExtractComputerName(pDataObject, &bstrComputer))
    {
		DebugPrintEx( DEBUG_MSG, 
            _T("Fail to extract computer name"));
        delete pRoot;
        pRoot = NULL;
        
        return pDefault;
    }
    ATLASSERT(bstrComputer);

    if (S_OK != pRoot->SetServerName(bstrComputer))
    {
        DebugPrintEx(DEBUG_ERR,_T("pRoot->SetServerName"), E_OUTOFMEMORY);
        delete pRoot;
        pRoot = NULL;
        
        return pDefault;
    }

    return pRoot;
}

/*
 -  CSnapin::GetHelpTopic
 -
 *  Purpose:
 *      Get the HTM file name within comet.chm that contains the info about this node.
 *
 *  Arguments
 *
 *  Return:
 *      The HTM path name
 */
WCHAR*
CSnapin::GetHelpTopic()
{
    return NULL;
}

/*
 -  CSnapin::Notify
 -
 *  Purpose:
 *      Override IComponentDataImpl::Notify for the special case with 
 *      (lpDataObject == NULL) && (event == MMCN_PROPERTY_CHANGE)
 *      were the assumption is that notification got from scope node TYPE == CCT_SCOPE
 *      this was done for the Device scope pane node refreshment of 
 *      result pane colmons data !
 *
 *  Arguments:
 *      [in]    lpDataObject
 *
 *      [in]    event
 *
 *      [in]    arg
 *
 *      [in]    param
 *
 *  Return:
 *      OLE error code.
 *
 */

HRESULT CSnapin::Notify( 
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
{
    DEBUG_FUNCTION_NAME( _T("++<<<<< CSnapin::Notify >>>>>++"));

	HRESULT hr = E_POINTER;
	CSnapInItem* pItem;
	//T* pT = static_cast<T*>(this);
	CSnapin * pT = this;


	if ( (NULL == lpDataObject) && (MMCN_PROPERTY_CHANGE == event) )
    {
        DebugPrintEx( DEBUG_MSG,
		    _T("Special case: (NULL == lpDataObject) && (MMCN_PROPERTY_CHANGE == event)"));

        CFaxPropertyChangeNotification * pNotification;
        pNotification = ( CFaxPropertyChangeNotification * ) param;
        ATLASSERT(pNotification);
          
        pItem = pNotification->pItem;
        ATLASSERT(pItem);
    	
        hr = pItem->Notify(event, arg, param, pT, NULL, CCT_SCOPE);
        
        return hr;
	    
    }
	else
	{
        return IComponentDataImpl<CSnapin, CSnapinComponent>::Notify(
                                            lpDataObject, event, arg, param);
    }
	
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\snpnscp.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    NodeWithScopeChildrenList.h

Abstract:

    This is the header file for CNodeWithScopeChildrenList, a class which
    implements a node that has a list of scope pane children.

    This is an inline template class.
    Include NodeWithScopeChildrenList.cpp in the .cpp files
    of the classes in which you use this template.

Author:

    Original: Michael A. Maguire
    Modifications: RaphiR

Changes:
    Support for Extension snapins
    Enables multiple class of childs

//      Jun 14 1999 roytal  used UNREFERENCED_PARAMETER to fix build wrn   //
//                                                                         //
//      Sep 22 1999 yossg   Welcome To Fax Server                          //
//      Dec 30 1999 yossg   Fix RemoveChild                                //

--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NODE_WITH_SCOPE_CHILDREN_LIST_H_)
#define _NODE_WITH_SCOPE_CHILDREN_LIST_H_


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "snpnode.h"
//
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



template <class T,BOOL bIsExtension>
class CNodeWithScopeChildrenList : public CSnapinNode< T, bIsExtension >
{

public:



    //////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::AddChild

    Adds a child to the list of children.

    This has to be public as it must be accessible even from a separate dialog
    (e.g. a Connect to Server dialog) that may want to add a child.

    Here we add the child item to the list of children and call InsertItem
    to add the child to the scope pane.

    This is one difference between adding nodes into the scope
    pane and the result pane.  When we were inserting a child into
    the result pane, we didn't call InsertItem in the AddChild methods(s)
    because we needed to worry about sending an UpdataAllViews
    notification and repopulating the result pane in each view.

    Because MMC takes care of replicating scope pane changes to all views,
    we don't need to worry about this.  Instead, we just do InsertItem once here.

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT AddChild(CSnapInItem * pChildNode, SCOPEDATAITEM* pScopeDataItem);



    //////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::RemoveChild

    Removes a child from the list of children.

    This has to be public so that child nodes can ask their parent to be deleted
    from the list of children when they receive the MMCN_DELETE notification.

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT RemoveChild(CSnapInItem * pChildNode );



    //////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::OnShow

    Don't override this in your derived class.  Instead, override methods
    which it calls: InsertColumns

    This method is an override of CSnapinNode::OnShow.  When MMC passes the
    MMCN_SHOW method for this node.

    For more information, see CSnapinNode::OnShow.

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT OnShow(
                      LPARAM arg
                    , LPARAM param
                    , IComponentData * pComponentData
                    , IComponent * pComponent
                    , DATA_OBJECT_TYPES type
                    );


    //////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildren::OnExpand

    Don't override this in your derived class.  Instead, override methods
    which it calls: PopulateScopeChildrenList

    This method is an override of CSnapinNode::OnExpand.  When MMC passes the
    MMCN_EXPAND method for this node, we are to add children into the
    scope pane.  In this class we add them from a list we maintain.

    For more information, see CSnapinNode::OnExpand.

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT OnExpand(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );




protected:


    // Array of pointers to children nodes
    CSimpleArray<CSnapInItem*> m_ScopeChildrenList;

    // Flag indicating whether list has been initially populated
    BOOL m_bScopeChildrenListPopulated;


    /////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::CNodeWithScopeChildrenList

    Constructor

    This is an base class which we don't want instantiated on its own,
    so the contructor is protected

    --*/
    //////////////////////////////////////////////////////////////////////////////
    CNodeWithScopeChildrenList(CSnapInItem * pParentNode, CSnapin * pComponentData);



    /////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::~CNodeWithScopeChildrenList

    Destructor

    --*/
    //////////////////////////////////////////////////////////////////////////////
    ~CNodeWithScopeChildrenList();



    /////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::PopulateScopeChildrenList

    Override this in your derived class to populate the list of children nodes.

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT PopulateScopeChildrenList();

    // override in your derived class and do something like:

/*
    virtual HRESULT PopulateScopeChildrenList( void )
    {
        CSomeChildNode *myChild1 = new CSomeChildNode();
        AddChild(myChild1);

        CSomeChildNode *myChild2 = new CSomeChildNode();
        AddChild(myChild2);

        CSomeChildNode *myChild3 = new CSomeChildNode();
        AddChild(myChild3);

        return S_OK;
    }
*/


    //////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::InsertColumns

    Override this in your derived class.

    This method is called by OnShow when it needs you to set the appropriate
    column headers to be displayed in the result pane for this node.

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );


    //////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::OnUnSelect

    Override this in your derived class.

    This method is called by OnShow when the node is unselected.
    Useful to overidde this if to retreive columns header width for example

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT OnUnSelect( IHeaderCtrl* pHeaderCtrl );


    /////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::EnumerateScopeChildren

    Don't override this in your derived class. Instead, override the method
    it calls, PopulateScopeChildrenList.

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT EnumerateScopeChildren( IConsoleNameSpace* pConsoleNameSpace );


};




//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::AddChild

Adds a child to the list of children.

This has to be public as it must be accessible even from a separate dialog
(e.g. a Connect to Server dialog) that may want to add a child.

Here we add the child item to the list of children and call InsertItem
to add the child to the scope pane.

This is one difference between adding nodes into the scope
pane and the result pane.  When we were inserting a child into
the result pane, we didn't call InsertItem in the AddChild methods(s)
because we needed to worry about sending an UpdataAllViews
notification and repopulating the result pane in each view.

Because MMC takes care of replicating scope pane changes to all views,
we don't need to worry about this.  Instead, we just do InsertItem once here.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T,bIsExtension>::AddChild(
                                             CSnapInItem*       pChildNode,
                                             SCOPEDATAITEM*     pScopeDataItem)
{
    DEBUG_FUNCTION_NAME( 
		_T("CNodeWithScopeChildrenList::AddChild"));


    // Check for preconditions:
    // None.


    HRESULT hr = S_OK;

    if( m_ScopeChildrenList.Add( pChildNode ) )
    {

        //
        // Get the Console
        //
        CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(m_pComponentData->m_spConsole);


        // We hand our HSCOPEITEM as the parent ID for this child.
        pScopeDataItem->relativeID = (HSCOPEITEM) m_scopeDataItem.ID;


        hr = spConsoleNameSpace->InsertItem(pScopeDataItem);
        if (FAILED(hr))
        {
            return hr;
        }

        // Check: On return, the ID member of 'm_scopeDataItem'
        // contains the handle to the newly inserted item.
        _ASSERT( NULL != pScopeDataItem->ID);

    }
    else
    {
        // Failed to add => out of memory
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::RemoveChild

Removes a child from the list of children.

This has to be public so that child nodes can ask their parent to be deleted
from the list of children when they receive the MMCN_DELETE notification.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T, bIsExtension>::RemoveChild(CSnapInItem * pChildNode )
{
    DEBUG_FUNCTION_NAME( 
		_T("CNodeWithScopeChildrenList::RemoveChild"));


    // Check for preconditions:
    // None.


    HRESULT hr = S_OK;


    if( m_ScopeChildrenList.Remove( pChildNode ) )
    {
        //
        // Need IConsoleNameSpace
        //
        CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(m_pComponentData->m_spConsole);

        //
        // Need pScopeDataItem
        //
        SCOPEDATAITEM *pScopeDataItem;
        pChildNode->GetScopeData(&pScopeDataItem);

        //
        // DeleteItem
        //
        hr = spConsoleNameSpace->DeleteItem(pScopeDataItem->ID, TRUE );

        if (FAILED(hr))
        {
            return hr;
        }

    }
    else
    {
        // If we failed to remove, probably the child was never in the list
        // ISSUE: determine what do here -- this should never happen
        _ASSERTE( FALSE );

        hr = S_FALSE;
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::CNodeWithScopeChildrenList

Constructor

This is an base class which we don't want instantiated on its own,
so the contructor is protected

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
CNodeWithScopeChildrenList<T,bIsExtension>::CNodeWithScopeChildrenList(CSnapInItem * pParentNode, CSnapin * pComponentData):
                CSnapinNode< T, bIsExtension >(pParentNode, pComponentData)
{
    DEBUG_FUNCTION_NAME(
        _T("CNodeWithScopeChildrenList::CNodeWithScopeChildrenList"));


    // Check for preconditions:
    // None.


    // We have not yet loaded the child nodes' data
    m_bScopeChildrenListPopulated = FALSE;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::~CNodeWithScopeChildrenList

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
CNodeWithScopeChildrenList<T, bIsExtension>::~CNodeWithScopeChildrenList()
{
    DEBUG_FUNCTION_NAME(
        _T("CNodeWithScopeChildrenList::~CNodeWithScopeChildrenList"));


    // Check for preconditions:
    // None.



    // Delete each node in the list of children
    CSnapInItem* pChildNode;
    for (int i = 0; i < m_ScopeChildrenList.GetSize(); i++)
    {
        pChildNode = m_ScopeChildrenList[i];
        delete pChildNode;
    }

    // Empty the list
    m_ScopeChildrenList.RemoveAll();

}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::PopulateScopeChildrenList

Override this in your derived class to populate the list of children nodes.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T, bIsExtension>::PopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME(
        _T("CNodeWithScopeChildrenList::PopulateScopeChildren -- override in your derived class"));


    // Check for preconditions:
    // None.


    // override in your derived class and do something like:
/*
    CSomeChildNode *myChild1 = new CSomeChildNode();
    m_CChildrenList.Add(myChild1);

    CSomeChildNode *myChild2 = new CSomeChildNode();
    m_CChildrenList.Add(myChild2);

    CSomeChildNode *myChild3 = new CSomeChildNode();
    m_CChildrenList.Add(myChild3);
*/
    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::OnShow

Don't override this in your derived class.  Instead, override methods
which it calls: InsertColumns

This method is an override of CSnapinNode::OnShow.  When MMC passes the
MMCN_SHOW method for this node.

For more information, see CSnapinNode::OnShow.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T, bIsExtension>::OnShow(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                )
{
    DEBUG_FUNCTION_NAME( 
		_T("CNodeScopeChildrenList::OnShow"));

    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (type);

    // Check for preconditions:
    _ASSERTE( pComponentData != NULL || pComponent != NULL );


    HRESULT hr = S_FALSE;



    // Need IHeaderCtrl.

    // But to get that, first we need IConsole
    CComPtr<IConsole> spConsole;
    if( pComponentData != NULL )
    {
         spConsole = ((CSnapin*)pComponentData)->m_spConsole;
    }
    else
    {
        // We should have a non-null pComponent
         spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
    }
    _ASSERTE( spConsole != NULL );

    CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeaderCtrl(spConsole);
    _ASSERT( spHeaderCtrl != NULL );

    if( arg )
    {

        // arg <> 0 => we are being selected.
        hr = InsertColumns( spHeaderCtrl );
        _ASSERT( S_OK == hr );

    }
    else
    {
        //
        // We are unselected
        //
        hr = OnUnSelect(spHeaderCtrl);
        _ASSERT( S_OK == hr );
    }

    return hr;


}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::InsertColumns

Override this in your derived class.

This method is called by OnShow when it needs you to set the appropriate
column headers to be displayed in the result pane for this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T,bIsExtension>::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
    DEBUG_FUNCTION_NAME(
        _T("CNodeWithScopeChildrenList::InsertColumns -- override in your derived class"));


    // Check for preconditions:
    _ASSERTE( pHeaderCtrl != NULL );


    HRESULT hr;

    // override in your derived class and do something like:
    hr = pHeaderCtrl->InsertColumn( 0, L"@Column 1 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 120 );
    _ASSERT( S_OK == hr );

    hr = pHeaderCtrl->InsertColumn( 1, L"@Column 2 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 300 );
    _ASSERT( S_OK == hr );

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::OnUnSelect

Override this in your derived class.

This method is called by OnShow when the node is unselected.
Useful to overidde this if to retreive columns header width for example


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T,bIsExtension>::OnUnSelect( IHeaderCtrl* pHeaderCtrl )
{
    UNREFERENCED_PARAMETER (pHeaderCtrl);

    DEBUG_FUNCTION_NAME(
        _T("CNodeWithScopeChildrenList::OnUnSelect -- override in your derived class"));


    // Check for preconditions:
    _ASSERTE( pHeaderCtrl != NULL );


    HRESULT hr = S_OK;

    return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildren::OnExpand

Don't override this in your derived class.  Instead, override methods
which it calls: PopulateScopeChildrenList

This method is an override of CSnapinNode::OnExpand.  When MMC passes the
MMCN_EXPAND method for this node, we are to add children into the
scope pane.  In this class we add them from a list we maintain.

For more information, see CSnapinNode::OnExpand.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T,bIsExtension>::OnExpand(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    DEBUG_FUNCTION_NAME( 
		_T("CNodeWithScopeChildren::OnExpand"));

    UNREFERENCED_PARAMETER (type);

    // Check for preconditions:
    _ASSERTE( pComponentData != NULL || pComponent != NULL );



    HRESULT hr = S_FALSE;

    if( TRUE == arg )
    {

        // Need IConsoleNameSpace

        // But to get that, first we need IConsole
        CComPtr<IConsole> spConsole;
        if( pComponentData != NULL )
        {
             spConsole = ((CSnapin*)pComponentData)->m_spConsole;
        }
        else
        {
            // We should have a non-null pComponent
             spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
        }
        _ASSERTE( spConsole != NULL );


        CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
        _ASSERT( spConsoleNameSpace != NULL );

        if(bIsExtension)
        {
            //
            // For extensions, keep the scope
            //
            ATLASSERT(m_scopeDataItem.ID == 0);
            m_scopeDataItem.ID = (HSCOPEITEM) param;
        }
        else
        {
            m_scopeDataItem.ID = (HSCOPEITEM) param;
        }
        hr = EnumerateScopeChildren( spConsoleNameSpace );
    }
    else    // arg != TRUE so not expanding
    {

        // do nothing for now -- I don't think arg = FALSE is even implemented
        // for MMC v. 1.0 or 1.1

    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::EnumerateScopeChildren

Don't override this in your derived class. Instead, override the method
it calls, PopulateScopeChildrenList.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T,bIsExtension>::EnumerateScopeChildren( IConsoleNameSpace* pConsoleNameSpace )
{
    DEBUG_FUNCTION_NAME( 
		_T("CNodeWithScopeChildrenList::EnumerateScopeChildren"));

    UNREFERENCED_PARAMETER (pConsoleNameSpace);

    // Check for preconditions:
    // None.


    HRESULT hr;

    if ( FALSE == m_bScopeChildrenListPopulated )
    {
        // We have not yet loaded all of our children into our list.
        hr = PopulateScopeChildrenList();
        if( FAILED(hr) )
        {
            return( hr );
        }

        // We've already loaded our children objects with
        // data necessary to populate the result pane.
        m_bScopeChildrenListPopulated = TRUE;   // We only want to do this once.
    }


    // We don't need any code here to InsertItem the children into the
    // scope pane as we did in the EnumerateScopeChildren method
    // for CNodeWithResultChildrenList.
    // This is one difference between adding nodes into the scope
    // pane and the result pane.  Because MMC takes care of replicating
    // scope pane changes to all views, we don't need to worry about
    // sending an UpdateAllViews notification and handling insertion
    // there for each result pane.  Instead, we just do InsertItem once.
    // So for CNodeWithScopePaneChildren, we call InsertItem
    // in the AddChild method which is called by PopulateScopeChildrenList
    // above.

    return S_OK;
}



#endif // _NODE_WITH_SCOPE_CHILDREN_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

//                                                                         //
//      Sep 22 1999 yossg   welcome To Fax Server                           //
//

#if !defined(AFX_STDAFX_H__65929689_4B15_11D2_AC28_0060081EFE5C__INCLUDED_)
#define AFX_STDAFX_H__65929689_4B15_11D2_AC28_0060081EFE5C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _ATL_APARTMENT_THREADED

    //
    // WARNING: THIS MAKES THE CHECKED BINARY TO GROW 
    //
        #define ATL_TRACE_LEVEL 4
        #define ATL_TRACE_CATEGORY 0xFFFFFFFF
    //    #define _ATL_DEBUG_INTERFACES

#include "resource.h"

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;


#include <atlcom.h>
#include <shellapi.h>
#include <shlobj.h>
#include <atlwin.h>
#include <atlbase.h>
#include <atlapp.h>
#include <atlctrls.h>

//#include <ATLSnap.h>
#include "..\inc\atlsnap.h"
#include <faxutil.h>
#include "FaxMMCUtils.h"

#include <fxsapip.h>  

#include "helper.h"
#include <FaxUiConstants.h>
#include "resutil.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__65929689_4B15_11D2_AC28_0060081EFE5C__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\snpnres.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    snpres.h

Abstract:

    This is the header file for CNodeWithResultChildrenList, a class which
    implements a node that has a list of scope pane children.

    This is an inline template class.
    Include NodeWithScopeChildrenList.cpp in the .cpp files
    of the classes in which you use this template.

Author:

    Original: Michael A. Maguire
    Modifications: RaphiR

Changes:
    Support for Extension snapins
    Jun 14 1999 roytal  used UNREFERENCED_PARAMETER to fix build wrn
//                                                                         //
//      Sep 22 1999 yossg   welcome To Fax Server                           //


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NODE_WITH_RESULT_CHILDREN_LIST_H_)
#define _NODE_WITH_RESULT_CHILDREN_LIST_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "snpnode.h"
//
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


template < class T, class CChildNode, class TArray, BOOL bIsExtension>
class CNodeWithResultChildrenList : public CSnapinNode< T, bIsExtension>
{

    // Constructor/Destructor

public:
    CNodeWithResultChildrenList(CSnapInItem * pParentNode, CSnapin * pComponentData);
    ~CNodeWithResultChildrenList();


    // Child list management.

public:
    // Flag indicating whether list has been initially populated
    BOOL m_bResultChildrenListPopulated;

protected:
    // Override these in your derived classes
    virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );
    virtual HRESULT OnUnSelect( IHeaderCtrl* pHeaderCtrl );
    virtual HRESULT PopulateResultChildrenList(void );

    // Stuff which must be accessible to subclasses.  These methods shouldn't need to be overidden.
    // zvib moved to public
    //virtual HRESULT RepopulateResultChildrenList(void);
    // virtual HRESULT AddChildToList( CChildNode * pChildNode );
    //virtual HRESULT EnumerateResultChildren( IResultData * pResultData );
    // zvib

    // Array of pointers to children nodes.
    // This is protected so that it can be visible in the derived classes.
    TArray m_ResultChildrenList;


    // Overrides for standard MMC functionality.
public:

    virtual HRESULT RepopulateResultChildrenList(void);
    virtual HRESULT EnumerateResultChildren( IResultData * pResultData );
    virtual HRESULT AddChildToList( CChildNode * pChildNode );

    //////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::RemoveChild

    Removes a child from the list of children.

    This has to be public so that child nodes can ask their parent to be deleted
    from the list of children when they receive the MMCN_DELETE notification.

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT RemoveChild( CChildNode * pChildNode );

    virtual HRESULT OnShow(
                      LPARAM arg
                    , LPARAM param
                    , IComponentData * pComponentData
                    , IComponent * pComponent
                    , DATA_OBJECT_TYPES type
                    );
    virtual HRESULT OnRefresh(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );

    virtual HRESULT DoRefresh(CSnapInObjectRootBase *pRoot);

};


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::InsertColumns

Override this in your derived class.

This method is called by OnShow when it needs you to set the appropriate
column headers to be displayed in the result pane for this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
    DEBUG_FUNCTION_NAME(
        _T("CNodeWithResultChildrenList::InsertColumns -- override in your derived class"));


    // Check for preconditions:
    _ASSERTE( pHeaderCtrl );


    HRESULT hr;

    // override in your derived class and do something like:
    hr = pHeaderCtrl->InsertColumn( 0, L"@Column 1 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 120 );
    _ASSERT( S_OK == hr );

    hr = pHeaderCtrl->InsertColumn( 1, L"@Column 2 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 300 );
    _ASSERT( S_OK == hr );

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::OnUnSelect

Override this in your derived class.

This method is called by OnShow when the node is unselected.
Useful to overidde this if you want to retreive columns header width for example


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::OnUnSelect( IHeaderCtrl* pHeaderCtrl )
{
    DEBUG_FUNCTION_NAME(
        _T("CNodeWithResultChildrenList::OnUnSelect -- override in your derived class"));

    UNREFERENCED_PARAMETER (pHeaderCtrl);

    // Check for preconditions:
    _ASSERTE( pHeaderCtrl != NULL );


    HRESULT hr = S_OK;

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::PopulateResultChildrenList

Override this in your derived class.

This is called by EnumerateResultChildren which is called by OnShow when
you need to populate the list of children of this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::PopulateResultChildrenList( void )
{
    DEBUG_FUNCTION_NAME(
        _T("CNodeWithResultChildrenList::PopulateResultChildrenList -- override in your derived class"));


    // Check for preconditions:
    // None.


    // override in your derived class and do something like:
/*
    CSomeChildNode *myChild1 = new CSomeChildNode();
    AddChildToList(myChild1);

    CSomeChildNode *myChild2 = new CSomeChildNode();
    AddChildToList(myChild2);

    CSomeChildNode *myChild3 = new CSomeChildNode();
    AddChildToList(myChild3);
*/
    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::RepopulateResultChildrenList

DON'T Override this in your derived class.

Call this to empty the list of children and repopulate it.
This method will call PopulateResultChildrenList, which you should override.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::RepopulateResultChildrenList(void)
{

    DEBUG_FUNCTION_NAME( _T("CNodeWithResultChildrenList<..>::RepopulateResultChildrenList"));
    HRESULT hr;

    // Check for preconditions:
    // None.

    //
    // Clear our node list [Michael A. Maguire]
    //
    
    // Get rid of what we had.

    // Delete each node in the list of children
    CChildNode* pChildNode;
    int iSize = m_ResultChildrenList.GetSize();
    for (int i = 0; i < iSize; i++)
    {
        pChildNode = m_ResultChildrenList[i];
        delete pChildNode;
    }

    // Empty the list
    m_ResultChildrenList.RemoveAll();


    // We no longer have a populated list.
    m_bResultChildrenListPopulated = FALSE;


    // Repopulate the list.
    hr = PopulateResultChildrenList();
    if( FAILED(hr) )
    {
        return( hr );
    }

    // We've already loaded our children ClientNode objects with
    // data necessary to populate the result pane.
    m_bResultChildrenListPopulated = TRUE;  // We only want to do this once.

    return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::CNodeWithResultChildrenList

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
CNodeWithResultChildrenList<T,CChildNode, TArray,bIsExtension>::CNodeWithResultChildrenList(CSnapInItem * pParentNode, CSnapin * pComponentData): CSnapinNode<T,bIsExtension>(pParentNode, pComponentData)
{
    DEBUG_FUNCTION_NAME(
        _T("CNodeWithResultChildrenList::CNodeWithResultChildrenList"));


    // Check for preconditions:
    // None.


    // We have not yet loaded the child nodes' data
    m_bResultChildrenListPopulated = FALSE;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::~CNodeWithResultChildrenList

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::~CNodeWithResultChildrenList()
{
    DEBUG_FUNCTION_NAME(
        _T("CNodeWithResultChildrenList::~CNodeWithResultChildrenList"));


    // Check for preconditions:
    // None.



    // Delete each node in the list of children
    CChildNode* pChildNode;
    int iSize = m_ResultChildrenList.GetSize();
    for (int i = 0; i < iSize; i++)
    {
        pChildNode = m_ResultChildrenList[i];
        delete pChildNode;
    }

    // Empty the list
    m_ResultChildrenList.RemoveAll();

}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::AddChildToList

Adds a child to the list of children.  Does not cause a view update.

Use this in your PopulateResultChildrenList method.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode, TArray, bIsExtension>::AddChildToList( CChildNode * pChildNode )
{


    // Check for preconditions:
    // None.


    HRESULT hr = S_OK;

    if( m_ResultChildrenList.Add(pChildNode ) )
    {

        hr = S_OK;

    }
    else
    {
        // Failed to add => out of memory
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::OnShow

Don't override this in your derived class.  Instead, override methods
which it calls: InsertColumns and (indirectly) PopulateResultChildrenList

This method is an override of CSnapinNode::OnShow.  When MMC passes the
MMCN_SHOW method for this node, we are to add children into the
result pane.  In this class we add them from a list we maintain.

For more information, see CSnapinNode::OnShow.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::OnShow(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                )
{
    DEBUG_FUNCTION_NAME( 
		_T("CNodeWithResultChildrenList::OnShow"));

    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (type);

    // Check for preconditions:
    _ASSERTE( pComponentData != NULL || pComponent != NULL );


    HRESULT hr = S_FALSE;

    T * pT = static_cast<T*>( this );


    // Need IHeaderCtrl.

    // But to get that, first we need IConsole
    CComPtr<IConsole> spConsole;
    if( pComponentData != NULL )
    {
         spConsole = ((CSnapin*)pComponentData)->m_spConsole;
    }
    else
    {
        // We should have a non-null pComponent
         spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
    }
    _ASSERTE( spConsole != NULL );

    CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeaderCtrl(spConsole);
    _ASSERT( spHeaderCtrl != NULL );

    if( arg )
    {

        // arg <> 0 => we are being selected.

        // Note: This method will only get called with
        // arg <> 0 (i.e. selected) if you responded appropriately to
        // the MMCN_ADD_IMAGES method

        // We have been asked to display result pane nodes belonging under this node.

        // It appears we must do IResultData->InsertItems each time we receive
        // the MMCN_SHOW message -- MMC doesn't remember what nodes
        // we have previously inserted.


        // Set the column headers in the results pane
        // Note: if you don't set these, MMC will never
        // bother to put up your result-pane only items

        // When this Notify method is called from IComponentDataImpl, we
        // get pHeader (and pToolbar) passed in as NULL, so we aren't
        // going to bother using it and will instead always
        // QI pConsole for this pointer
        hr = pT->InsertColumns( spHeaderCtrl );
        _ASSERT( S_OK == hr );


        // Display our list of children in the result pane

        // Need IResultData
        CComQIPtr<IResultData, &IID_IResultData> spResultData(spConsole);
        _ASSERT( spResultData != NULL );

        hr = pT->EnumerateResultChildren(spResultData );
    }
    else
    {
        //
        // We are unselected
        //
        hr = OnUnSelect(spHeaderCtrl);
        _ASSERT( S_OK == hr );

    }

    return hr;


}


//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::DoRefresh(CSnapInObjectRootBase *pRoot)
{

    CComPtr<IConsole> spConsole;

    //
    // Repopulate childs
    //
    RepopulateResultChildrenList();

    if (pRoot)
    {
        //
        // Get the console pointer
        //
        ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
        if (pRoot->m_nType == 1)
        {
            //
            // m_ntype == 1 means the IComponentData implementation
            //
            CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
            spConsole = pCComponentData->m_spConsole;
        }
        else
        {
            //
            // m_ntype == 2 means the IComponent implementation
            //
            CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
            spConsole = pCComponent->m_spConsole;
        }
    }
    else
    {
        ATLASSERT(m_pComponentData);
        spConsole = m_pComponentData->m_spConsole;
    }

    ATLASSERT(spConsole);
    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::OnRefresh


You shouldn't need to override this in your derived method.  Simply
enable the MMC_VERB_REFRESH for your node.

In our implementation, this method gets called when the MMCN_REFRESH
Notify message is sent for this node.

For more information, see CSnapinNode::OnRefresh.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::OnRefresh(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    DEBUG_FUNCTION_NAME( 
		_T("CNodeWithResultChildrenList::OnRefresh"));

    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    HRESULT hr;

    // Rebuild our list of nodes from the uderlying data source.
    T * pT = static_cast<T*> (this);
    hr = pT->RepopulateResultChildrenList();


    // Update the views.

    // We weren't passed an IConsole pointer here, so
    // we use the one we saved in out CComponentData object.
    _ASSERTE( m_pComponentData != NULL );
    _ASSERTE( m_pComponentData->m_spConsole != NULL );

    // We pass in a pointer to 'this' because we want each
    // of our CComponent objects to update its result pane
    // view if 'this' node is the same as the saved currently
    // selected node.
    m_pComponentData->m_spConsole->UpdateAllViews( NULL,(LPARAM) this, NULL);

    return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::EnumerateResultChildren

Don't override this in your derived class. Instead, override the method
it calls, PopulateResultChildrenList.

This is called by the OnShow method.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::EnumerateResultChildren( IResultData * pResultData )
{
    DEBUG_FUNCTION_NAME( 
		_T("CNodeWithResultChildrenList::EnumerateResultChildren"));


    // Check for preconditions:
    _ASSERTE( pResultData != NULL );


    HRESULT hr = S_OK;

    T * pT = static_cast<T*> (this);

    if ( FALSE == m_bResultChildrenListPopulated )
    {
        // We have not yet loaded all of our children into our list.
        // This call will add items to the list from whatever data source.
        hr = pT->PopulateResultChildrenList();
        if( FAILED(hr) )
        {
            return( hr );
        }

        // We've already loaded our children ClientNode objects with
        // data necessary to populate the result pane.
        m_bResultChildrenListPopulated = TRUE;  // We only want to do this once.

    }


    // From MeanGene's Step4 -- need to first remove all items from result pane
    hr = pResultData->DeleteAllRsltItems();
    if( FAILED(hr) )
    {
        return hr;
    }

    // The ResultChildrenList is already populated, so we
    // just need to show the CChildNode objects to the world
    // by populating the result pane.

    CChildNode* pChildNode;
    for (int i = 0; i < m_ResultChildrenList.GetSize(); i++)
    {
        pChildNode = m_ResultChildrenList[i];
        if ( NULL == pChildNode )
        {
            continue;
        }

        // Insert the item into the result pane.
        hr = pResultData->InsertItem( &(pChildNode->m_resultDataItem) );
        if (FAILED(hr))
        {
            return hr;
        }

        // Check: On return, the itemID member of 'm_resultDataItem'
        // contains the handle to the newly inserted item.
        _ASSERT( NULL != pChildNode->m_resultDataItem.itemID );

    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::RemoveChild

Removes a child from the list of children.

This is declared public because it must be accessed from a child node when that
node receives the MMCN_DELETE message and tries to delete itself.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::RemoveChild( CChildNode * pChildNode )
{
    DEBUG_FUNCTION_NAME( 
		_T("CNodeWithResultChildrenList::RemoveChild"));


    // Check for preconditions:
    // None.


    HRESULT hr = S_OK;

    if( m_ResultChildrenList.Remove( pChildNode ) )
    {

        // We don't remove the item directly from the result pane now
        // using IResultData->RemoveItem, as we have no way of
        // removing it from all the possible views.
        // Instead, we call IConsole->UpdateAllViews which will
        // cause MMC to call Notify on each of our IComponent objects
        // with the MMCN_VIEW_CHANGE notification, and we will
        // repopulate the result view when we handle that notification.

        // We weren't passed an IConsole pointer here, so
        // we use the one we saved in out CComponentData object.
        _ASSERTE( m_pComponentData != NULL );
        _ASSERTE( m_pComponentData->m_spConsole != NULL );

        // We pass in a pointer to 'this' because we want each
        // of our CComponent objects to update its result pane
        // view if 'this' node is the same as the saved currently
        // selected node.
        m_pComponentData->m_spConsole->UpdateAllViews( NULL,(LPARAM) this, NULL);

    }
    else
    {
        // If we failed to remove, probably the child was never in the list
        // ISSUE: determine what do here -- this should never happen
        _ASSERTE( FALSE );
        hr = S_FALSE;
    }

    return hr;
}


#endif // _NODE_WITH_RESULT_CHILDREN_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\snpnode.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    snpnode.h

Abstract:

    Header for the CSnapinNode class.

    This is our virtual base class for an MMC Snap-in node.

    As this is a template class and is all implemented inline,
    there is no SnapinNode.cpp for implementation.


Author:

    Original: Michael A. Maguire
    Modifications: RaphiR

Changes:
    Specific MSMQ support:
        Default images
        Default columns
    Support for Extension snapins
    Add a CComponentData pointer
    SetIcons method
    Move m_pParentNode to CSnapinItem

    zvib - Add RefreshSingleResultItem

    Jun 10 1999 adik    Change bitmap mask to white.
    Jun 14 1999 roytal  used UNREFERENCED_PARAMETER to fix build wrn
    Jun 24 1999 adik    Handle MMCN_COLUMNS_CHANGED
    Jun 30 1999 adik    More detailed DPF in CSnapinNode::Notify

//                                                                         //
//      Sep 22 1999 yossg   welcome To Fax Server                           //
//      Oct 11 1999 yossg   replace DPF with fax's DebugPrintfEx           //
--*/
/////////////////////////////////////////////////////////////////////////////

#if !defined(_SNAPIN_NODE_H_)
#define _SNAPIN_NODE_H_

#include <dlgutils.h>
class CSnapin;



class CSnapinItemEx
{

protected:
	
		CSnapinItemEx * m_pParentNodeEx;
public:

	CSnapinItemEx(CSnapinItemEx * pParent)
	{
		m_pParentNodeEx = (CSnapinItemEx *)pParent;
	}
	CSnapinItemEx * GetRootNode()
	{
		if (m_pParentNodeEx)
		{
			return m_pParentNodeEx->GetRootNode();
		}
		else
		{
			return this;
		}
	}
	virtual void dummy(){}; // To support dynamic_cast

	CSnapinItemEx  * GetParent()
	{
		return m_pParentNodeEx;
	}
};



template <class T, BOOL bIsExtension>
class CSnapinNode : public CSnapInItemImpl< T, bIsExtension>,
					public CSnapinItemEx
{
protected:
    // Constructor/Destructor
    CSnapinNode(CSnapInItem *pParentNode, CSnapin *pComponentData);
    ~CSnapinNode();

public:
    // For IDataObject handling.
    IDataObject* m_pDataObject;
    void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault);

    //
    // Change the default icon id
    //
    void SetIcons(DWORD idStandard, DWORD idOpen);

    // Clipboard formats which IDataObjects on all MMC nodes must support.
    static const GUID* m_NODETYPE;
    static const TCHAR* m_SZNODETYPE;
    static const TCHAR* m_SZDISPLAY_NAME;
    static const CLSID* m_SNAPIN_CLASSID;

    // Pointer to parent node.  This is passed in the call to our
    // constructor.  Needed so that a node can access its parent.
    // For example, when we receive the MMCN_DELETE notification, we might tell
    // our parent node to remove us from its list of children.
    // The member is initialize in the constructor of CSnapinNode
    CSnapInItem * m_pParentNode;

    //
    // Pointer to the component data. Allow us to
    // access Snapin global data
    //
    CSnapin *     m_pComponentData;

    HRESULT NodeMsgBox(int ids, UINT fuStyle = MB_OK | MB_ICONERROR, int *piRetval = NULL, BOOL StringFromCommonDll = FALSE);
    HRESULT RefreshSingleResultItem(CSnapInObjectRootBase *pRoot);
    HRESULT RefreshSingleResultItem(IConsole *spConsole);
    HRESULT RefreshSingleResultItem(IComponentData *pComponentData, IComponent * pComponent);

public:
    // Standard MMC functionality -- override if you need to.
    STDMETHOD(CreatePropertyPages)(
          LPPROPERTYSHEETCALLBACK lpProvider
        , LONG_PTR handle
        , IUnknown* pUnk
        , DATA_OBJECT_TYPES type
        );
    STDMETHOD(QueryPagesFor)( DATA_OBJECT_TYPES type );
    void* GetDisplayName();
    STDMETHOD(GetScopePaneInfo)( SCOPEDATAITEM *pScopeDataItem );
    STDMETHOD(GetResultPaneInfo)( RESULTDATAITEM *pResultDataItem );
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
    virtual HRESULT SetVerbs( IConsoleVerb * pConsoleVerb );


    // Notify method will call notification handlers below -- shouldn't need to override.
    STDMETHOD( Notify ) (
              MMC_NOTIFY_TYPE event
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );


    // Notification handlers -- override when you want to intercept.
    virtual HRESULT OnActivate(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnAddImages(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnButtonClick(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnClick(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnContextHelp(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnShowContextHelp(
                  IDisplayHelp* pDisplayHelp
                , LPOLESTR helpFile);
    virtual HRESULT OnContextMenu(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnDoubleClick(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnDelete(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                , BOOL fSilent = FALSE
                );
    virtual HRESULT OnExpand(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnHelp(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnMenuButtonClick(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnMinimized(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnPaste(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnPropertyChange(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnQueryPaste(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnRefresh(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnRemoveChildren(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnRename(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnSelect(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnShow(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnViewChange(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );
    virtual HRESULT OnColumnsChanged(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );


    // Special notification handler -- saves off the currently selected node.
    HRESULT PreOnShow(
                  LPARAM arg
                , LPARAM param
                , IComponentData * pComponentData
                , IComponent * pComponent
                , DATA_OBJECT_TYPES type
                );



    // Taskpad functionality.
    STDMETHOD(TaskNotify)(
                  IDataObject * pDataObject
                , VARIANT * pvarg
                , VARIANT * pvparam
                );
    STDMETHOD(EnumTasks)(
                  IDataObject * pDataObject
                , BSTR szTaskGroup
                , IEnumTASK** ppEnumTASK
                );
};




//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:SetIcons

    Specify the Open and Close icons of the snapin node

Remarks:


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
void CSnapinNode<T, bIsExtension>::SetIcons(DWORD idStandard, DWORD idOpen)
{
    m_scopeDataItem.nImage = idStandard;
    m_scopeDataItem.nOpenImage = idOpen;

    m_resultDataItem.nImage = idStandard;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:CreatePropertyPages

Adds pages to a property sheet.


HRESULT CreatePropertyPages(
  LPPROPERTYSHEETCALLBACK lpProvider,
                              // Pointer to the callback interface
  long handle,                // Handle for routing notification
  LPDATAOBJECT lpIDataObject  // Pointer to the data object
);


Remarks:


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::CreatePropertyPages(
      LPPROPERTYSHEETCALLBACK lpProvider
    , LONG_PTR handle
    , IUnknown* pUnk
    , DATA_OBJECT_TYPES type
    )
{
    DEBUG_FUNCTION_NAME(TEXT("CreatePropertyPages"));

    UNREFERENCED_PARAMETER (lpProvider);
    UNREFERENCED_PARAMETER (handle);
    UNREFERENCED_PARAMETER (pUnk);
    UNREFERENCED_PARAMETER (type);

    DebugPrintEx(DEBUG_MSG,
        _T("CSnapinNode::CreatePropertyPages -- override in your derived class"));

    return E_NOTIMPL;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:QueryPagesFor

Determines whether the object requires pages.


HRESULT QueryPagesFor(  DATA_OBJECT_TYPES type  );


Parameters

    void


Return Value

    S_OK
    Properties exist for this cookie.

    E_UNEXPECTED
    An unexpected error occurred.

    E_INVALID
    The parameter is invalid.

    ISSUE: So what do we return if an item doesn't have property pages?
        S_FALSE is used in sburns' localsec code

Remarks

    The console calls this method to determine whether the Properties menu
    item should be added to the context menu.


  Override this in your derived class, if your object supports menu

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::QueryPagesFor( DATA_OBJECT_TYPES type )
{
    DEBUG_FUNCTION_NAME(TEXT("QueryPagesFor"));
	
	UNREFERENCED_PARAMETER (type);

    DebugPrintEx(DEBUG_MSG,
        _T("CSnapinNode::QueryPagesFor -- override in your derived class if you have property pages"));

    // this method should be overriden and should return S_OK if you
    // have property pages for this node otherwise it should return S_FALSE.

    return S_FALSE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:InitDataClass

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
void CSnapinNode<T, bIsExtension>::InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
{
    UNREFERENCED_PARAMETER (pDefault);

    // The default code stores off the pointer to the Dataobject the class is wrapping
    // at the time.
    // Alternatively you could convert the dataobject to the internal format
    // it represents and store that information

    m_pDataObject = pDataObject;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetDisplayName

ISSUE: what are the parameters to this function?  Why not void?

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
void* CSnapinNode<T, bIsExtension>::GetDisplayName()
{
    DEBUG_FUNCTION_NAME( 
		_T("CSnapinNode::GetDisplayName"));

//      ISSUE: It looks as thought the m_SZDISPLAY_NAME is a totally
//      bogus variable -- we should think about eliminating it
//      Problematic -- const m_SZDISPLAY_NAME can't be localized
//      return (void*)m_SZDISPLAY_NAME;

    return (void*)m_bstrDisplayName;
}

//  void* GetSnapInCLSID()
//  {
//      DPF(5, DBG_MMC,(_T("CSnapinNode::GetSnapInCLSID"));
//
//      return (void*)m_SNAPIN_CLASSID;
//  }



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetScopePaneInfo


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::GetScopePaneInfo( SCOPEDATAITEM *pScopeDataItem )
{
//    DEBUG_FUNCTION_NAME( _T("CSnapinNode::GetScopePaneInfo"));

    if (pScopeDataItem->mask & SDI_STR)
        pScopeDataItem->displayname = m_bstrDisplayName;
    if (pScopeDataItem->mask & SDI_IMAGE)
        pScopeDataItem->nImage = m_scopeDataItem.nImage;
    if (pScopeDataItem->mask & SDI_OPENIMAGE)
        pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
    if (pScopeDataItem->mask & SDI_PARAM)
        pScopeDataItem->lParam = m_scopeDataItem.lParam;
    if (pScopeDataItem->mask & SDI_STATE )
        pScopeDataItem->nState = m_scopeDataItem.nState;

    // TODO : Add code for SDI_CHILDREN
    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetResultPaneInfo


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::GetResultPaneInfo( RESULTDATAITEM *pResultDataItem )
{
    DEBUG_FUNCTION_NAME( _T("CSnapinNode::GetResultPaneInfo"));

    if (pResultDataItem->bScopeItem)
    {
        if (pResultDataItem->mask & RDI_STR)
        {
            pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
        }
        if (pResultDataItem->mask & RDI_IMAGE)
        {
            pResultDataItem->nImage = m_scopeDataItem.nImage;
        }
        if (pResultDataItem->mask & RDI_PARAM)
        {
            pResultDataItem->lParam = m_scopeDataItem.lParam;
        }

        return S_OK;
    }

    if (pResultDataItem->mask & RDI_STR)
    {
        pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
    }
    if (pResultDataItem->mask & RDI_IMAGE)
    {
        pResultDataItem->nImage = m_resultDataItem.nImage;
    }
    if (pResultDataItem->mask & RDI_PARAM)
    {
        pResultDataItem->lParam = m_resultDataItem.lParam;
    }
    if (pResultDataItem->mask & RDI_INDEX)
    {
        pResultDataItem->nIndex = m_resultDataItem.nIndex;
    }

    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::Notify


This method is this node's response to the MMC calling Notify on
IComponent or IComponentData.


STDMETHOD( Notify ) (
          MMC_NOTIFY_TYPE event
        , LPARAM arg
        , LPARAM param
        , IComponentData * pComponentData
        , IComponent * pComponent
        , DATA_OBJECT_TYPES type


        )


Parameters

    event
    [in] Identifies an action taken by a user. IComponent::Notify and
    IComponentData::Notify can receive the following notifications for a
    specific node:

        MMCN_ACTIVATE
        MMCN_ADD_IMAGES
        MMCN_BTN_CLICK
        MMCN_CLICK
        MMCN_CONTEXTMENU
        MMCN_DBLCLICK
        MMCN_DELETE
        MMCN_EXPAND
        MMCN_HELP
        MMCN_MENU_BTNCLICK
        MMCN_MINIMIZED
        MMCN_PROPERTY_CHANGE
        MMCN_REFRESH
        MMCN_REMOVE_CHILDREN
        MMCN_RENAME
        MMCN_SELECT
        MMCN_SHOW
        MMCN_VIEW_CHANGE
        MMCN_CONTEXTHELP

    See CSnapinNode::OnActivate, OnAddImages, OnButtonClick, etc. for
    a detailed explanation of each of these notify events

    arg
    Depends on the notification type.

    param
    Depends on the notification type.


Return Values

    S_OK
    Depends on the notification type.

    E_UNEXPECTED
    An unexpected error occurred.


Remarks

    Our IComponentData and IComponent implementations were passed a LPDATAOBJECT
    which corresponds to a node.  This was converted to a pointer to
    a node object.  Below is the Notify method on this node object, were
    the node object can deal with the Notify event itself.

    Our implementation of Notify is a large switch statement which delegates the
    task of dealing with virtual OnXxxxxx methods which can overridden in
    derived classes.  As all events are dealt with this way here, you shouldn't
    need to implement a Notify method for any of your derived nodes.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>:: Notify (
          MMC_NOTIFY_TYPE event
        , LPARAM arg
        , LPARAM param
        , IComponentData * pComponentData
        , IComponent * pComponent
        , DATA_OBJECT_TYPES type
        )
{
    DEBUG_FUNCTION_NAME(TEXT("CSnapinNode<..>:: Notify"));

    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (type);
        
	DebugPrintEx(DEBUG_MSG,
        _T("CSnapinNode::Notify, event=0x%X, pComponentData=0x%X, pComponent=0x%X"), 
        event, pComponentData, pComponent);

    HRESULT hr = S_FALSE;

    // this makes for faster code.
    T* pT = static_cast<T*> (this);

    switch( event )
    {

    case MMCN_ACTIVATE:
        hr = pT->OnActivate( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_ADD_IMAGES:
        hr = pT->OnAddImages( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_BTN_CLICK:
        hr = pT->OnButtonClick( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_CLICK:
        hr = pT->OnClick( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_CONTEXTHELP:
        hr = pT->OnContextHelp( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_CONTEXTMENU:
        hr = pT->OnContextMenu( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_CUTORMOVE:
        hr = pT->OnDelete( arg, param, pComponentData, pComponent, type, TRUE );
        break;

    case MMCN_DBLCLICK:
        hr = pT->OnDoubleClick( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_DELETE:
        hr = pT->OnDelete( arg, param, pComponentData, pComponent, type, FALSE );
        break;

    case MMCN_EXPAND:
        hr = pT->OnExpand( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_HELP:
        hr = pT->OnHelp( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_MENU_BTNCLICK:
        hr = pT->OnMenuButtonClick( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_MINIMIZED:
        hr = pT->OnMinimized( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_PASTE:
        hr = pT->OnPaste( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_PROPERTY_CHANGE:
		DebugPrintEx(DEBUG_MSG,_T("+++ MMCN_PROPERTY_CHANGE +++ \n"));
        hr = pT->OnPropertyChange( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_QUERY_PASTE:
        hr = pT->OnQueryPaste( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_REFRESH:
        hr = pT->OnRefresh( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_REMOVE_CHILDREN:
        hr = pT->OnRemoveChildren( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_RENAME:
        hr = pT->OnRename( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_SELECT:
        // For nodes with result-pane children
        hr = pT->OnSelect( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_SHOW:
        // For nodes with result-pane children
        // We call PreOnShow which will then call OnShow.
        // PreOnShow will save away the selected node in a member variable
        // of out CComponent class.
        //hr = pT->PreOnShow( arg, param, pComponentData, pComponent, type );
        hr = pT->OnShow( arg, param, pComponentData, pComponent, type );
        break;

    case MMCN_VIEW_CHANGE:
        hr = pT->OnViewChange( arg, param, pComponentData, pComponent, type );
        break;

    //
    // MMC 1.2, Win200 build 2059 support
    //
    case MMCN_COLUMNS_CHANGED:
        hr = pT->OnColumnsChanged(arg, param, pComponentData, pComponent, type);
        break;

    default:
        // Unhandled notify event.
        //  MMC wants E_NOTIMPL if you can't do something or it will crash
        hr = E_NOTIMPL;
        break;

    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:CSnapinNode

Constructor

This class is to be the virtual base class for all our nodes
We never want people instantiating it so the constructor is protected

--*/
//////////////////////////////////////////////////////////////////////////////
class CSnapinNode;

template <class T, BOOL bIsExtension>
CSnapinNode<T, bIsExtension>::CSnapinNode(CSnapInItem *pParentNode, CSnapin * pComponentData)
                            : CSnapInItemImpl<T, bIsExtension>(),
							  CSnapinItemEx(dynamic_cast<CSnapinItemEx *>(pParentNode))

{
    DEBUG_FUNCTION_NAME(_T("CSnapinNode::CSnapinNode"));
		
	DebugPrintEx(DEBUG_MSG,
		_T("CSnapinNode::CSnapinNode, this=0x%X"), this);

    // Set the componet data
    m_pComponentData = pComponentData;

    // Set the parent node (in the base class CSnapinItem)
    m_pParentNode = pParentNode;

    // We set cookie for both scope and result pane data items,
    // as this class can be subclassed for either a scope-pane
    // or a result-pane-only node.

    // Sridhar moved this initialization code out of SnapInItemImpl
    memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
    m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
    m_scopeDataItem.displayname = MMC_CALLBACK;
    m_scopeDataItem.nImage = 0;         // May need modification
    m_scopeDataItem.nOpenImage = 0;     // May need modification
    // If this node is inserted in to the scope pane using
    // IConsoleNamespace->InsertItem, the value stored in lParam
    // will be what MMC later passes back as the cookie for this node.
    m_scopeDataItem.lParam = (LPARAM) this;

    // Sridhar moved this initialization code out of SnapInItemImpl
    memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
    m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
    m_resultDataItem.str = MMC_CALLBACK;
    m_resultDataItem.nImage = 0;        // May need modification
    // If this node is inserted in to the result pane using
    // IResultData->InsertItem, the value stored in lParam will
    // be what MMC later passes back as the cookie for this node.
    m_resultDataItem.lParam = (LPARAM) this;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:~CSnapinNode

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
CSnapinNode<T, bIsExtension>::~CSnapinNode()
{
    DEBUG_FUNCTION_NAME( _T("--- CSnapinNode::~CSnapinNode"));
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetResultPaneColInfo


  By default, we return the display name in the first column, and blank ("")
  for other columns.
  Override in your derived class if you want more columns support
--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
LPOLESTR CSnapinNode<T, bIsExtension>::GetResultPaneColInfo(int nCol)
{
    DEBUG_FUNCTION_NAME( _T("CSnapinNode::GetResultPaneColInf"));

    if (nCol == 0)
    {
        return m_bstrDisplayName;
    }

    // Return the blank for other columns
    return OLESTR(" ");
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnActivate

virtual HRESULT OnActivate(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_ACTIVATE
Notify message is sent for this node.

MMC sends this message to the snap-in's IComponent::Notify method when a window is
being activated or deactivated.


Parameters

    arg
    TRUE if the window is activated; otherwise, it is FALSE.

    param
    Not used.


Return Values

    Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnActivate(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME( _T("CSnapinNode::OnActivate  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnAddImages

virtual HRESULT OnAddImages(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

We have chosen to handle this on a per-IComponent object basis, since it has
very little to do (for us at least) with the particular IDataObject.

See CComponent::OnAddImages for where we add images.


This method loads the default ImageList we have
Override this, if you want different imagelist

By default, Loads specific images for this project

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnAddImages(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnAddImages"));

    HRESULT hr;

    IImageList* pImageList = (IImageList*) arg;
    hr = E_FAIL;
    // Load bitmaps associated with the scope pane
    // and add them to the image list
    // Loads the default bitmaps generated by the wizard
    // Change as required
    HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_TOOLBAR_16));
    if (hBitmap16 != NULL)
    {
        HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_TOOLBAR_32));
        if (hBitmap32 != NULL)
        {
            hr = pImageList->ImageListSetStrip((LONG_PTR*)hBitmap16,
                                               (LONG_PTR*)hBitmap32,
                                               0, 
                                               RGB(0, 128, 128));
            if (FAILED(hr))
            {
                DebugPrintEx(DEBUG_ERR, 
					_T("IImageList::ImageListSetStrip failed"));
            }

            DeleteObject(hBitmap32);
        }
        DeleteObject(hBitmap16);
    }
    return(hr);
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnButtonClick

virtual HRESULT OnButtonClick(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_BTN_CLICK Notify message is
sent for this node.

MMC sends this message to the snap-in's IComponent, IComponentData,
or IExtendControlbar implementation when a user clicks on one of the
toolbar buttons.


Parameters

For IComponent::Notify or IComponentData::Notify:

    arg
    Must be zero.

    param
    CmdID of the button equal to a value of the MMC_CONSOLE_VERB enumeration.

For IExtendControlBar::ControlbarNotify:

    arg
    Data object of the currently selected scope or result pane item.

    param
    [in] CmdID of the button equal to a value of the MMC_CONSOLE_VERB enumeration.


Return Values

    Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnButtonClick(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnButtonClick  -- Override in your derived class"));

    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnClick

virtual HRESULT OnClick(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_CLICK Notify message is
sent for this node.

MMC sends this message to IComponent when a user clicks a mouse button
on a list view item.


Parameters

    arg
    Not used.

    param
    Not used.


Return Values

    Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnClick(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnClick  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnContextHelp

virtual HRESULT OnContextHelp(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_CONTEXTHELP Notify message is
sent for this node.

MMC sends this message when the user requests help about a selected item


Parameters

    arg
    0.

    param
    0.


Return Values

  Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnContextHelp(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    HRESULT hr;
    PWSTR pszFilePath = ::GetHelpFile();

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnContextHelp"));

    // But to get that, first we need IConsole
    CComPtr<IConsole> spConsole;
    if( pComponentData != NULL )
    {
         spConsole = ((CSnapin*)pComponentData)->m_spConsole;
    }
    else
    {
        // We should have a non-null pComponent
         spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
    }
    ATLASSERT( spConsole != NULL );
    CComPtr<IDisplayHelp> spDisplayHelp;

    hr = spConsole->QueryInterface(IID_IDisplayHelp, (void**)&spDisplayHelp);
    if(FAILED(hr))
    return hr;

    return OnShowContextHelp(spDisplayHelp, pszFilePath);
}

template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnShowContextHelp(
              IDisplayHelp* /*pDisplayHelp*/, LPOLESTR /*helpFile*/)
{
     DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnShowContextHelp -- Override in your derived class"));


     return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnContextMenu

virtual HRESULT OnContextMenu(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_CONTEXTMENU Notify
message is sent for this node.

In the Fall 97 Platform SDK documentation, this event is listed as not used.


Parameters

    arg
    TBD

    param
    TBD

Return Values

    Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnContextMenu(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnContextMenu  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnDoubleClick

virtual HRESULT OnDoubleClick(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_DBLCLICK Notify message is
sent for this node.

MMC sends this message to IComponent when a user double clicks a mouse
button on a list view item.


Parameters

    arg
    Not used.

    param
    Not used.


Return Values

    Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnDoubleClick(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnDoubleClick  -- Override in your derived class if you don't want default verb action"));

    // Through speaking with Eugene Baucom, I discovered that if you return S_FALSE
    // here, the default verb action will occur when the user double clicks on a node.
    // For the most part we have Properties as default verb, so a double click
    // will cause property sheet on a node to pop up.
    return S_FALSE;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnDelete

virtual HRESULT OnDelete(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_DELETE Notify
message is sent for this node.

MMC sends this message to the snap-in's IComponent and IComponentData implementation to inform the snap-in that the object should be deleted.


Parameters

    arg
    Not used.

    param
    Not used.

Return Values

    Not used.


Remarks

    This message is generated when the user presses the delete key or uses
    the mouse to click on the toolbar's delete button.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnDelete(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            , BOOL fSilent
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);
    UNREFERENCED_PARAMETER (fSilent);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnDelete  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnExpand

virtual HRESULT OnExpand(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

If your node will have scope-pane children,
this method should be overidden in your derived class.

In our implementation, this method gets called when the MMCN_EXPAND Notify message is
sent for this node.

MMC sends this message to the snap-in's IComponentData
implementation when a folder node needs to be expanded or contracted.


Parameters

    arg
    [in] If TRUE, the folder needs to be expanded. If FALSE, the folder needs to be contracted.

    Param
    [in] The HSCOPEITEM of the item that needs to be expanded.


Return Values

    HRESULT


Remarks

    On receipt of this notification the snap-in should enumerate the
    children (sub-containers only) of the specified scope item, if any,
    using IConsoleNameSpace methods. Subsequently, if a new item is added to
    or deleted from this scope object through some external means, then
    that item should also be added to or deleted from the console's
    namespace using IConsoleNameSpace methods.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnExpand(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnExpand  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnHelp

virtual HRESULT OnHelp(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_HELP Notify
message is sent for this node.

In the Fall 97 Platform SDK documentation, this event is listed as not used.

MMC sends this message when the user presses the F1 help key.


Parameters

    arg
    TBD

    param
    Pointer to a GUID. If NULL, the NodeType is used instead.


Return Values

    Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnHelp(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnHelp  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnMenuButtonClick

virtual HRESULT OnMenuButtonClick(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )


In our implementation, this method gets called when the MMCN_MENU_BTNCLICK Notify
message is sent for this node.

MMC sends this ify message is sent Sent to the snap-in's IExtendControlbar
interface when a user clicks on a menu button.


Parameters

    arg
    Data object of currently selected scope or result pane item.

    param
    [in] Pointer to a MENUBUTTONDATA structure.


Return Values

      Not Used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnMenuButtonClick(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnMenuButtonClick  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnMinimized

virtual HRESULT OnMinimized(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )


In our implementation, this method gets called when the MMCN_MINIMIZED Notify message is
sent for this node.

MMC sends this message to the snap-in's IComponent implementation when
a window is being minimized or maximized.


Parameters

    arg
    TRUE if the window has been minimized; otherwise, it is FALSE.

    Param
    Not used.


Return Values

  Not Used


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnMinimized(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnMinimized  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnPaste

virtual HRESULT OnPaste(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_PASTE
Notify message is sent for this node.

Called to ask the snap-ins folder to paste the selected items.


Parameters

    pDataobject
    The data object in which to paste the selected items provided by the snap-in.
    arg
    The data object of the selected item(s) provided by the source snap-in that need to be pasted.
    param
    NULL for move (as opposed to cut).
    For a single-item paste:

    BOOL* pPasted = (BOOL*)param; Set this to TRUE here if the item was successfully pasted.

    For a multiitem paste:

    LPDATAOBJECT* ppDataObj = (LPDATAOBJECT*)param;

    Use this to return a pointer to a data object consisting of the items successfully pasted. See MMCN_CUTORMOVE.


Return Values

    Not used.


See Also

    MMCN_CUTORMOVE


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnPaste(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnPaste  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnPropertyChange


  virtual HRESULT OnPropertyChange(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_PROPERTY_CHANGE
Notify message is sent for this node.

When the snap-in uses the MMCPropertyChangeNotify function to notify it's
views about changes, MMC_PROPERTY_CHANGE is sent to the snap-in's
IComponentData and IComponent implementations.


Parameters

    arg
    [in] TRUE if the property change is for a scope pane item.

    lParam
    This is the param passed into MMCPropertyChangeNotify.


Return Values

      Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnPropertyChange(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnPropertyChange  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnQueryPaste

virtual HRESULT OnQueryPaste(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_QUERY_PASTE
Notify message is sent for this node.

Sent to the snap-in before pasting into the snap-in's folder to determine if the
snap-in can accept the data.


Parameters

    pdataobject
    The dataobject of the selected item provided by the snap-in.
    arg
    The dataobject of the item(s) provided by the source snap-in that need to be pasted.
    param
    Not used.


Return Values

    Not used.


See Also

    MMCN_PASTE


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnQueryPaste(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnQueryPaste  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnRefresh

virtual HRESULT OnRefresh(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_REFRESH
Notify message is sent for this node.

In the Fall 97 Platform SDK documentation, this event is listed as TBD.


Parameters


Return Values

    Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnRefresh(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnRefresh  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnRemoveChildren

virtual HRESULT OnRemoveChildren(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_REMOVE_CHILDREN
Notify message is sent for this node.

MMC sends this message to the snap-in's IComponentData implementation to inform
the snap-in that it must delete all the cookies (the entire subtree) it has
added below the specified node.


Parameters

    arg
    Specifies the HSCOPEITEM of the node whose children need to be deleted.

    param
    Not used.


Return Values

      Not used.


Remarks

    Use IConsoleNameSpace methods GetChildItem and GetNextItem to traverse
    the tree and determine the cookies to be deleted.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnRemoveChildren(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnRemoveChildren  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnRename

virtual HRESULT OnRename(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_RENAME Notify
message is sent for this node.

ISSUE: I do not seem to be seeing the two-call behaviour documented below

MMC sends this message the first time to query for a rename and the
second time to do the rename.


Parameters

    arg
    Not used.

    param
    LPOLESTR for containing the new name.

Return Values

    S_OK
    Allows the rename.

    S_FALSE
    Disallows the rename.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnRename(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnRename  -- Override in your derived class"));

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnSelect

virtual HRESULT OnSelect(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

You shouldn't need to override this method.  The OnSelect method has common
behaviour for all nodes, only the verbs to be set are different.  Rather
than overriding OnSelect in each node, simply override SetVerbs, which this
implementation of OnSelect calls.

In our implementation, this method gets called when the MMCN_SELECT Notify message is
sent through IComponent::Notify for this node.

Note: MMC also sends the MMCN_SELECT message through IExtendControlbar::ControlbarNotify
but we don't respond to that here -- See CSnapInItem::ControlbarNotify for that.


Parameters

For IComponent::Notify:

    arg
    BOOL bScope = (BOOL) LOWORD(arg);
    BOOL bSelec = (BOOL) HIWORD(arg);

    bScope
    TRUE if an item in the scope pane is selected.
    FALSE if an item in the result view pane is selected.

    bSelect
    TRUE if the item is selected.
    FALSE if the item is deselected.

    param
    This parameter is ignored.

Return Values

    Not used.


Remarks

    When an IComponent::Notify method receives the MMCN_SELECT notification
    it should update the standard verbs.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnSelect(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    DEBUG_FUNCTION_NAME( _T("CSnapinNode::OnSelect"));

    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (type);

    _ASSERTE( pComponentData != NULL || pComponent != NULL );


    HRESULT hr = S_FALSE;
    CComPtr<IConsoleVerb> spConsoleVerb;

    BOOL bSelected = (BOOL) HIWORD( arg );

    if( bSelected )
    {

        // Need IConsoleVerb

        // But to get that, first we need IConsole
        CComPtr<IConsole> spConsole;
        if( pComponentData != NULL )
        {
             spConsole = ((CSnapin*)pComponentData)->m_spConsole;
        }
        else
        {
            // We should have a non-null pComponent
             spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
        }
        _ASSERTE( spConsole != NULL );

        hr = spConsole->QueryConsoleVerb( &spConsoleVerb );
        _ASSERT( SUCCEEDED( hr ) );

        hr = SetVerbs( spConsoleVerb );

    }
    else
    {

        // Anything to do here? Don't think so -- see sburns localsec example.

        hr = S_OK;

    }


    return hr;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::SetVerbs

virtual HRESULT SetVerbs( IConsoleVerb * pConsoleVerb )

Override this method in your derived class.

This method is called by our default implementation of OnSelect
when the verbs for this node need to be set.

Parameters

    IConsoleVerb * pConsoleVerb


Return Values

    HRESULT


Remarks

    The OnSelect method has common behaviour for all nodes, only the verbs
    to be set are different.  Rather than duplicate code by implementing OnSelect
    in each node, simply override this SetVerbs method

    Every time an item is selected, the verb states for all the commands
    are returned to disabled and visible. It is up to the snap-in writer
    to use IConsoleVerb to update the verb state every time an item is selected.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::SetVerbs( IConsoleVerb * pConsoleVerb )
{
    UNREFERENCED_PARAMETER (pConsoleVerb);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::SetVerbs -- Override in your derived class"));

    HRESULT hr = S_OK;

    // Override in your derived class and do something like:
/*
    // We want the user to be able to choose properties on this node
    hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );

    // We want the default verb to be Properties
    hr = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    // We want the user to be able to rename this node
    hr = pConsoleVerb->SetVerbState( MMC_VERB_RENAME, ENABLED, TRUE );
*/
    return hr;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::PreOnShow

virtual HRESULT PreOnShow(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

We call this instead of OnShow, so that we can save away the selected node.

This method will then just call OnShow.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::PreOnShow(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    DEBUG_FUNCTION_NAME(
         _T("CSnapinNode::PreOnShow  -- Don't override in your derived class"));


    if( NULL != pComponent )
    {

        CSnapinComponent * pMyComponent = static_cast<CSnapinComponent *>( pComponent );

        if( arg )
        {
            // We are being selected.

            // Save our 'this' pointer as the currently selected node for this result view.
            pMyComponent->m_pSelectedNode = static_cast<CSnapInItem *>( this );

        }
        else
        {
            // We are being deselected.

            // Check to make sure that our result view doesn't think
            // this node is the currently selected one.
            if( pMyComponent->m_pSelectedNode == static_cast<CSnapInItem *>( this ) )
            {
                // We don't want to be the selected node anymore.
                pMyComponent->m_pSelectedNode = NULL;
            }

        }

    }

    return OnShow( arg, param, pComponentData, pComponent, type );
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnShow

virtual HRESULT OnShow(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

If your node will have result-pane children,
this method should be overidden in your derived class.

In our implementation, this method gets called when the MMCN_SHOW Notify message is
sent for this node.

MMC sends this message when a scope item is selected or deselected for the
first time.


Parameters

    arg
    TRUE (<>0 ) if selecting; True indicates that the snap-in should set
    up the result pane and add the enumerated items.
    FALSE (0) if deselecting. indicates that the snap-in is going out of
    focus and that it should clean up all cookies the right hand side
    (the result pane), because current result pane will be replaced by a new one.

    param
    The HSCOPEITEM of the selected or deselected item.


Return Values

    Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnShow(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnShow  -- Override in your derived class"));

    // Returning E_NOTIMPL seems to be a bad thing here.
    // It caused all kinds of problems with toolbar buttons persisting to
    // the wrong node, as well as verbs not getting set correctly for nodes.
    // Basically, if you don't respond with S_OK to the MMCN_SHOW notification,
    // you won't get sent the appropriate MMCN_SELECT notification.
    // return E_NOTIMPL;
    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnViewChange

virtual HRESULT OnViewChange(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_VIEW_CHANGE Notify
message is sent for this node.

MMC sends this message to the snap-in's IComponent implementation so it
can update all views when a change occurs.  This node data object passed
to IConsole::UpdateAllViews.


Parameters

    arg
    [in] The data parameter passed to IConsole::UpdateAllViews.

    param
    [in] The hint parameter passed to IConsole::UpdateAllViews.


Return Values

    Not used.


Remarks

    This notification is generated when the snap-in (IComponent or
    IComponentData) calls IConsole::UpdateAllViews.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnViewChange(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CSnapinNode::OnViewChange  -- Override in your derived class"));

    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnColumnsChanged

virtual HRESULT OnColumnsChanged(
            , LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )

In our implementation, this method gets called when the MMCN_COLUMNS_CHANGED Notify
message is sent for this node.

MMC sends this message to the snap-in's IComponent implementation so it
can decide if it can accept the column changes.
If snapin refuses to accept column changes then it is upto the snapin to display a message box
explaining the user why it is unable to do so.



Parameters

    arg
    [in] The data parameter passed to IConsole::UpdateAllViews.

    param
    [in] The hint parameter passed to IConsole::UpdateAllViews.


Return Values

    S_OK, 
    A node can override this by returning E_UNEXPECTED that 
    discard user changes. In such a case display a message box
    explaining the user why it is unable to do so.


Remarks

    This notification is generated when the snap-in (IComponent or
    IComponentData) calls IConsole::UpdateAllViews.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::OnColumnsChanged(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::TaskNotify

Called when MMC wants to notify us that the user clicked on a task
on a taskpad belonging to this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::TaskNotify(
              IDataObject * pDataObject
            , VARIANT * pvarg
            , VARIANT * pvparam
            )
{
    UNREFERENCED_PARAMETER (pDataObject);
    UNREFERENCED_PARAMETER (pvarg);
    UNREFERENCED_PARAMETER (pvparam);

    DEBUG_FUNCTION_NAME( 
		_T("CSnapInItemImpl::TaskNotify - not impleneted"));

    return E_NOTIMPL;

}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::EnumTasks

Called when MMC wants us to enumerate the tasks on a taskpad
belonging to this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::EnumTasks(
              IDataObject * pDataObject
            , BSTR szTaskGroup
            , IEnumTASK** ppEnumTASK
            )
{
    UNREFERENCED_PARAMETER (pDataObject);
    UNREFERENCED_PARAMETER (szTaskGroup);
    UNREFERENCED_PARAMETER (ppEnumTASK);

    DEBUG_FUNCTION_NAME( 
		_T("CSnapInItemImpl::EnumTasks  - not impleneted"));

    return E_NOTIMPL;
}

#define COMET_MMC_COMMON_DLL L"nemmcutl.dll"

/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::NodeMsgBox

Calls IConsole::MessageBox


Parameters

    ids
    [in] string table (in rc) id of the text

    fuStyle
    [in] MB_* mask. See Win32 MessageBox

    piRetval
    [out] Message return value (see IConsole::MessageBox)

    StringFromCommonDll
    [in] if true the resource is taken from nemmcutil.dll (zvib)


Return Values

    The same as IConsole::MessageBox


Remarks

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension> HRESULT
CSnapinNode<T, bIsExtension>::NodeMsgBox(int ids,
                                         UINT fuStyle/*=MB_OK*/,
                                         int *piRetval/*=NULL*/,
                                         BOOL StringFromCommonDll
                                         )
{
	
	ATLASSERT(m_pComponentData);
	ATLASSERT(m_pComponentData->m_spConsole);
	return ::ConsoleMsgBox(m_pComponentData->m_spConsole, ids, m_bstrDisplayName, fuStyle, piRetval,StringFromCommonDll);

}

template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::RefreshSingleResultItem(CSnapInObjectRootBase *pRoot)
{
    HRESULT     hr = S_OK;
    CComPtr<IConsole>   spConsole;
    CSnapinComponent *pComponent;

//[yg] Dec 15 1999
//compiler err
//    error C2683: dynamic_cast : 'CSnapInObjectRootBase' is not a polymorphic type"    
//in code:
//    pComponent = dynamic_cast<CSnapinComponent*>(pRoot);
//changed to:

    pComponent =(CSnapinComponent*)(pRoot);

    _ASSERTE(pComponent != NULL);
    spConsole = pComponent->m_spConsole;
    _ASSERTE(spConsole != NULL);

    hr = RefreshSingleResultItem(spConsole);
    return(hr);
}

template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::RefreshSingleResultItem(IComponentData *pComponentData, IComponent * pComponent)
{
    HRESULT     hr = S_OK;
    CComPtr<IConsole>   spConsole;

    if ((pComponentData != NULL))
    {
        spConsole = ((CSnapin*)pComponentData)->m_spConsole;
    }
    else
    {
       // We should have a non-null pComponent
       spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
    }

    _ASSERTE(spConsole != NULL);
    hr = RefreshSingleResultItem(spConsole);
    return(hr);

}
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::RefreshSingleResultItem(IConsole *spConsole)
{
    HRESULT hr = S_OK;
    // Need IResultData
    CComQIPtr<IResultData, &IID_IResultData> pResultData(spConsole);
    ATLASSERT(pResultData != NULL);

    // Update the item
    hr = pResultData->SetItem(&m_resultDataItem);
    if (SUCCEEDED(hr))
        hr = pResultData->UpdateItem(m_resultDataItem.itemID);
    return(hr);
}

#endif // _SNAPIN_NODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\wzconnecttoserver.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : WzConnectToServer.cpp                                 //
//                                                                         //
//  DESCRIPTION   : This file implements the dialog for retargeting to     //
//                  another running Microsoft Fax Server.                  //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jun 26 2000 yossg    Create                                        //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "WzConnectToServer.h"

#include "Snapin.h"

#include "FxsValid.h"
#include "dlgutils.h"

#include <Objsel.h> //DSOP_SCOPE_INIT_INFO for DsObjectPicker

#include <windns.h> //DNS_MAX_NAME_BUFFER_LENGTH
/////////////////////////////////////////////////////////////////////////////
// CWzConnectToServer

CWzConnectToServer::CWzConnectToServer(
             LONG_PTR       hNotificationHandle,
             CSnapInItem   *pNode,
             BOOL           bOwnsNotificationHandle,
             HINSTANCE      hInst)
             : CSnapInPropertyPageImpl<CWzConnectToServer>(NULL) 
{
    m_pRoot = static_cast<CFaxServerNode *>(pNode);
}



CWzConnectToServer::~CWzConnectToServer()
{
}

/*
 +  CWzConnectToServer::OnInitDialog
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CWzConnectToServer::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CWzConnectToServer::OnInitDialog"));
    HRESULT hRc = S_OK;    

    //
    // Attach controls
    //
    m_ServerNameEdit.Attach(GetDlgItem(IDC_CONNECT_COMPUTER_NAME_EDIT));
        
    //
    // Set length limit 
    //
    m_ServerNameEdit.SetLimitText(DNS_MAX_NAME_BUFFER_LENGTH);
    
	//
	// Init the other controls
	//
	CheckDlgButton(IDC_CONNECT_LOCAL_RADIO1, BST_CHECKED);
    
	// the code line above create event for OnComputerRadioButtonClicked
    // which called the line:
    //    EnableSpecifiedServerControls(FALSE);
    // (FALSE due to: (IsDlgButtonChecked(IDC_CONNECT_ANOTHER_RADIO2) == BST_CHECKED))
    
	CheckDlgButton(IDC_CONNECT_OVERRIDE_CHECK, BST_UNCHECKED);

    return 1;  
}

/*
 +  CWzConnectToServer::OnSetActive
 +
 *  Purpose:
 *      
 *      
 *  Arguments:
 *
 -  Return:
 -      TRUE or FALSE
 */
BOOL CWzConnectToServer::OnSetActive()
{
    DEBUG_FUNCTION_NAME( _T("CWzConnectToServer::OnSetActive"));

    //
	// Must use post message during the setactive message.
	//
    CWindow( GetParent() ).PostMessage( PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH );
	
	return TRUE;
}

/*
 +  CWzConnectToServer::OnWizardFinish
 +
 *  Purpose:
 *      To apply data when wizard finish .
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
BOOL CWzConnectToServer::OnWizardFinish()
{
    DEBUG_FUNCTION_NAME( _T("CWzConnectToServer::OnWizardFinish"));
    
    ATLASSERT (m_pRoot);

    HRESULT       hRc                       = S_OK;
    DWORD         ec                        = ERROR_SUCCESS;
    BOOL          fIsLocalServer            = TRUE;
    CComBSTR      bstrServerName            = L"";
    BOOL          fAllowOverrideServerName  = FALSE;

    //
    // Step 1: get data
    //
    fIsLocalServer = ( IsDlgButtonChecked(IDC_CONNECT_LOCAL_RADIO1) == BST_CHECKED );

    if(fIsLocalServer)
    {
        bstrServerName = L"";
        if (!bstrServerName) 
        {
           hRc = E_OUTOFMEMORY;

           goto Exit;
        }
    }
    else //!fIsLocalServer => the other server radio button was clicked.
    {
        //
        // 1.a: PreApply Checks
        //
        if ( !m_ServerNameEdit.GetWindowText(&bstrServerName))
        {
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&m_bstrGroupName)"));
            DlgMsgBox(this, IDS_FAIL2READ_GROUPNAME);
            ::SetFocus(GetDlgItem(IDC_CONNECT_COMPUTER_NAME_EDIT));
            hRc = S_FALSE;
            
            goto Exit;
        }

        //
        // Server Name initial \\ trancation (if they are there)
        //
        if (  ( _tcslen(bstrServerName.m_str) > 2 ) && ( 0 == wcsncmp( bstrServerName.m_str , _T("\\\\") , 2 ))   )
        {
            CComBSTR bstrTmp = _tcsninc(bstrServerName.m_str, 2);
            if (!bstrTmp)
            {
                DebugPrintEx(DEBUG_ERR,
			            _T("Out of memory -bstr allocation error."));
                DlgMsgBox(this, IDS_MEMORY);
                ::SetFocus(GetDlgItem(IDC_CONNECT_COMPUTER_NAME_EDIT));

                hRc = S_FALSE;
                goto Exit;
            }
            bstrServerName.Empty();
            bstrServerName = bstrTmp; // operator = is actually copy() here.
        }

        //
        // Server Name validity checks
        //
        UINT uRetIDS   = 0;
    
        if (!IsValidServerNameString(bstrServerName, &uRetIDS, TRUE /*DNS Name Length*/))
        {
		    ATLASSERT ( 0 == uRetIDS); 
            DebugPrintEx(DEBUG_ERR,
			        _T("Non valid server name."));
            DlgMsgBox(this, uRetIDS);
            ::SetFocus(GetDlgItem(IDC_CONNECT_COMPUTER_NAME_EDIT));
            hRc = S_FALSE;
 
   
            goto Exit;
        }
        


        if ( IsLocalServerName(bstrServerName.m_str) )
        {
            DebugPrintEx( DEBUG_MSG,
		    _T("The computer name %ws is the same as the name of the current managed server."),
            bstrServerName.m_str);
        
            bstrServerName = L"";
        }
    }

    //
    // Allow override
    //
    if (IsDlgButtonChecked(IDC_CONNECT_OVERRIDE_CHECK) == BST_CHECKED)   
    {
        fAllowOverrideServerName = TRUE;
    }
    //else: fAllowOverrideServerName = FALSE is the default;

    
    //
    // Step 2: passed the machine name and the permission to override
    //
    
    //
    // Redraw main node display name
    //
	hRc = m_pRoot->SetServerNameOnSnapinAddition(bstrServerName, fAllowOverrideServerName);
    if (S_OK != hRc )
    {
        //error message given by the called function
		DebugPrintEx( DEBUG_ERR,
		_T("Failed to SetServerNameOnSnapinAddition(bstrServerName)"));

        goto Exit;
    }
                        
    //
    // Step 3: Close the dialog
    //
    ATLASSERT(S_OK == hRc && ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("The connection to the new server was done successfully."));
    goto Exit;

Exit:
    
    return (S_OK != hRc) ? FALSE : TRUE;
}


/*
 -  CWzConnectToServer::OnComputerRadioButtonClicked
 -
 *  Purpose:
 *      Check status OnComputerRadioButtonClicked
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CWzConnectToServer::OnComputerRadioButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER (wNotifyCode);
    UNREFERENCED_PARAMETER (wID);
    UNREFERENCED_PARAMETER (hWndCtl);
    UNREFERENCED_PARAMETER (bHandled);

    DEBUG_FUNCTION_NAME( _T("CWzConnectToServer::OnComputerRadioButtonClicked"));
	
    if ( IsDlgButtonChecked(IDC_CONNECT_ANOTHER_RADIO2) == BST_CHECKED )
    {        
        EnableSpecifiedServerControls(TRUE);
	    
        ::SetFocus(GetDlgItem(IDC_CONNECT_COMPUTER_NAME_EDIT));
    }
    else //connect to local server
    {
        EnableSpecifiedServerControls(FALSE);
    }

    return 1;
}


/*
 -  CWzConnectToServer::OnTextChanged
 -
 *  Purpose:
 *      Check the validity of text in side the text box.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CWzConnectToServer::OnTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER (wNotifyCode);
    UNREFERENCED_PARAMETER (wID);
    UNREFERENCED_PARAMETER (hWndCtl);
    UNREFERENCED_PARAMETER (bHandled);

    DEBUG_FUNCTION_NAME( _T("CWzConnectToServer::OnTextChanged"));

    //actually in the current design, do nothing

    return 1;
}

/*
 -  CWzConnectToServer::EnableSpecifiedServerControls
 -
 *  Purpose:
 *      Enable/disable the specified server controls.
 *
 *  Arguments:
 *      [in] state - boolean value to enable TRUE or FALSE to disable
 *
 *  Return:
 *      void
 */
void CWzConnectToServer::EnableSpecifiedServerControls(BOOL fState)
{

    //
    // enable/disable controls
    //
    ::EnableWindow(GetDlgItem(IDC_CONNECT_COMPUTER_NAME_EDIT),   fState);
    ::EnableWindow(GetDlgItem(IDC_CONNECT_BROWSE4SERVER_BUTTON), fState);
}


/*
 -  CWzConnectToServer::OnBrowseForMachine
 -
 *  Purpose:
 *      Enable/disable the specified server controls.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
static UINT g_cfDsObjectPicker =
        RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

LRESULT CWzConnectToServer::OnBrowseForMachine(UINT /*uMsg*/, WPARAM /*wParam*/, HWND /*hwnd*/, BOOL& /*bHandled*/)
{
    HRESULT hr = S_OK;
    static const int     SCOPE_INIT_COUNT = 1;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    DEBUG_FUNCTION_NAME( _T("CWzConnectToServer::OnBrowseForMachine"));
    
    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Since we just want computer objects from every scope, combine them
    // all in a single scope initializer.
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                           | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                           | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_WORKGROUP
                           | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                           | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    IDsObjectPicker *pDsObjectPicker = NULL;
    IDataObject *pdo = NULL;
    bool fGotStgMedium = false;
    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    do
    {
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &pDsObjectPicker);
        if(FAILED(hr))
            break;

        hr = pDsObjectPicker->Initialize(&InitInfo);
        if(FAILED(hr))
            break;

        hr = pDsObjectPicker->InvokeDialog(m_hWnd, &pdo);
        if(FAILED(hr))
            break;
        // Quit if user hit Cancel

        if (hr == S_FALSE)
        {
            break;
        }

        FORMATETC formatetc =
        {
            (CLIPFORMAT)g_cfDsObjectPicker,
            NULL,
            DVASPECT_CONTENT,
            -1,
            TYMED_HGLOBAL
        };

        hr = pdo->GetData(&formatetc, &stgmedium);
        if(FAILED(hr))
            break;

        fGotStgMedium = true;

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        if (!pDsSelList)
        {
            break;
        }

        ATLASSERT(pDsSelList->cItems == 1);

        //
        // Put the machine name in the edit control
        //

        SetDlgItemText(IDC_CONNECT_COMPUTER_NAME_EDIT, pDsSelList->aDsSelection[0].pwzName);
        
        GlobalUnlock(stgmedium.hGlobal);

    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\mmc\wzconnecttoserver.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : WzConnectToServer.h                                   //
//                                                                         //
//  DESCRIPTION   : Header file for the CWzConnectToServer class.         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jun 26 2000 yossg   Create                                         //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef WZ_CONNECT2SERVER_H_INCLUDED
#define WZ_CONNECT2SERVER_H_INCLUDED

#include "proppageex.h"

/////////////////////////////////////////////////////////////////////////////
// CWzConnectToServer
class CFaxServerNode;

class CWzConnectToServer : public CSnapInPropertyPageImpl<CWzConnectToServer>
{
public:
    
    //
    // Constructor
    //
    CWzConnectToServer(
             LONG_PTR      hNotificationHandle,
             CSnapInItem   *pNode,
             BOOL           bOwnsNotificationHandle,
             HINSTANCE      hInst);


    ~CWzConnectToServer();

    enum { IDD = IDD_CONNECT_TO_WIZARD };

BEGIN_MSG_MAP(CWzConnectToServer)
    MESSAGE_HANDLER( WM_INITDIALOG,  OnInitDialog)
        
    COMMAND_HANDLER(IDC_CONNECT_COMPUTER_NAME_EDIT,    EN_CHANGE,  OnTextChanged)
    COMMAND_HANDLER(IDC_CONNECT_LOCAL_RADIO1  ,        BN_CLICKED, OnComputerRadioButtonClicked)
    COMMAND_HANDLER(IDC_CONNECT_ANOTHER_RADIO2,        BN_CLICKED, OnComputerRadioButtonClicked)

    COMMAND_HANDLER(IDC_CONNECT_BROWSE4SERVER_BUTTON,  BN_CLICKED, OnBrowseForMachine)
    
    CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CWzConnectToServer>)
END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    BOOL    OnWizardFinish(); //when the wizard finishes

    BOOL    OnSetActive();
    
    LRESULT OnTextChanged                (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnComputerRadioButtonClicked (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnBrowseForMachine(UINT uMsg, WPARAM wParam, HWND hwnd, BOOL& bHandled);

private:
    //
    // Methods
    //
    VOID      EnableSpecifiedServerControls(BOOL fState);

    //
    // Controls
    //
    CEdit     m_ServerNameEdit;

    //
    // Pointer to the node
    //
    CFaxServerNode * m_pRoot;
};

#endif // WZ_CONNECT2SERVER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\routingext\devicemethods\emailconfigpage.cpp ===
#include "stdafx.h"
#include "RoutingMethodProp.h"
#include "RoutingMethodConfig.h"
#include <faxutil.h>
#include <faxreg.h>
#include <faxres.h>
#include <EmailConfigPage.h>
#include <Util.h>

HRESULT 
CEmailConfigPage::Init(
    LPCTSTR lpctstrServerName,
    DWORD dwDeviceId
)
{
    DEBUG_FUNCTION_NAME(TEXT("CEmailConfigPage::Init"));
    
    DWORD ec = ERROR_SUCCESS;

    m_bstrServerName = lpctstrServerName;
    m_dwDeviceId = dwDeviceId;
    if (!m_bstrServerName)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Out of memory while copying server name (ec: %ld)")
        );
        ec = ERROR_NOT_ENOUGH_MEMORY;
        DisplayRpcErrorMessage(ERROR_NOT_ENOUGH_MEMORY, IDS_EMAIL_TITLE, m_hWnd);
        goto exit;
    }

    if (!FaxConnectFaxServer(lpctstrServerName, &m_hFax))
    {
        DWORD ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxConnectFaxServer failed (ec: %ld)"),
            ec);
        DisplayRpcErrorMessage(ec, IDS_EMAIL_TITLE, m_hWnd);
        goto exit;
    }
    //
    // Retrieve the data
    //
    ec = ReadExtStringData (
                    m_hFax,
                    m_dwDeviceId,
                    REGVAL_RM_EMAIL_GUID,
                    m_bstrMailTo,
                    TEXT(""),
                    IDS_EMAIL_TITLE,
                    m_hWnd);

exit:

    if ((ERROR_SUCCESS != ec) && m_hFax)
    {
        if (!FaxClose(m_hFax))
        {
            DWORD ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxClose() failed on fax handle (0x%08X : %s). (ec: %ld)"),
                m_hFax,
                m_bstrServerName,
                ec);
        }
        m_hFax = NULL;
    }
    return HRESULT_FROM_WIN32(ec);
}   // CEmailConfigPage::Init

LRESULT CEmailConfigPage::OnInitDialog( 
            UINT uiMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL& fHandled
)
{
    DEBUG_FUNCTION_NAME( _T("CEmailConfigPage::OnInitDialog"));

    //
    // Attach and set values to the controls
    //
    m_edtMailTo.Attach (GetDlgItem (IDC_EDIT_MAILTO));
    m_edtMailTo.SetWindowText (m_bstrMailTo);

    m_fIsDialogInitiated = TRUE;

    return 1;
}


BOOL 
CEmailConfigPage::OnApply()
{
    DEBUG_FUNCTION_NAME(TEXT("CEmailConfigPage::OnApply"));

    if (!m_fIsDirty)
    {
        return TRUE;
    }

    //
    // Collect data from the controls
    //
    m_edtMailTo.GetWindowText (m_bstrMailTo.m_str);
    //
    // Check data validity
    //
    if (!m_bstrMailTo.Length())
    {
        DisplayErrorMessage (IDS_EMAIL_TITLE, IDS_EMAIL_ADDR_INVALID, FALSE, m_hWnd);
        return FALSE;
    }
    //
    // Validation passed. Now write the data using RPC
    //        
    if (ERROR_SUCCESS != WriteExtData (m_hFax,
                                       m_dwDeviceId, 
                                       REGVAL_RM_EMAIL_GUID, 
                                       (LPBYTE)(LPCWSTR)m_bstrMailTo, 
                                       sizeof (WCHAR) * (1 + m_bstrMailTo.Length()),
                                       IDS_EMAIL_TITLE,
                                       m_hWnd))
    {
        return FALSE;
    }
    
        
    //Success
    m_fIsDirty = FALSE;
    
    return TRUE;
}   // CEmailConfigPage::OnApply
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\routingext\devicemethods\inboxconfigpage.h ===
#ifndef __INBOX_CONFIG_PAGE_H_
#define __INBOX_CONFIG_PAGE_H_
#include "resource.h"
//#include <atlsnap.h>
#include "..\..\inc\atlsnap.h"
#include <atlapp.h>
#include <atlctrls.h>
#include <faxmmc.h>
#include <faxutil.h>
#include <fxsapip.h>
#include <RoutingMethodConfig.h>

class CInboxConfigPage : public CSnapInPropertyPageImpl<CInboxConfigPage>
{
public :
    CInboxConfigPage(LONG_PTR lNotifyHandle, bool bDeleteHandle = false, TCHAR* pTitle = NULL ) : 
        m_lNotifyHandle(lNotifyHandle),
        m_bDeleteHandle(bDeleteHandle) // Should be true for only page.
    {
        m_hFax = NULL;

        m_fIsDialogInitiated = FALSE;
        m_fIsDirty           = FALSE;
    }

    HRESULT Init(LPCTSTR lpctstrServerName, DWORD dwDeviceId);

    ~CInboxConfigPage()
    {

        DEBUG_FUNCTION_NAME(TEXT("CInboxConfigPage::~CInboxConfigPage"));
        if (m_hFax)
        {
            if (!FaxClose(m_hFax))
            {
                DWORD ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxClose() failed on fax handle (0x%08X : %s). (ec: %ld)"),
                    m_hFax,
                    m_bstrServerName,
                    ec);
            }
            m_hFax = NULL;
        }
        if (m_bDeleteHandle)
        {
            MMCFreeNotifyHandle(m_lNotifyHandle);
        }
    }

    enum { IDD = IDD_INBOX };

BEGIN_MSG_MAP(CInboxConfigPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog )
    CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CInboxConfigPage>)
    COMMAND_HANDLER(IDC_PROFILES, LBN_SELCHANGE,  OnFieldChange)
    NOTIFY_HANDLER(IDC_USER_ACCOUNT_HELP_LINK, NM_CLICK, OnHelpLink)
END_MSG_MAP()

    HRESULT PropertyChangeNotify(long param)
    {
        return MMCPropertyChangeNotify(m_lNotifyHandle, param);
    }

    BOOL OnApply();
    LRESULT OnHelpLink(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnFieldChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        if (!m_fIsDialogInitiated) //event receieved in too early stage
        {
            return 0;
        }
        else
        {
            m_fIsDirty = TRUE;
            SetModified(TRUE);
            return 0;
        }
    }

    LRESULT OnInitDialog( 
            UINT uiMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL& fHandled );


public:
    LONG_PTR m_lNotifyHandle;
    bool m_bDeleteHandle;

    static CComBSTR &GetProfile ()  { return m_bstrProfile; }

private:
    HANDLE   m_hFax;  // Handle to fax server connection
    CComBSTR m_bstrServerName;
    DWORD    m_dwDeviceId;

    static CComBSTR m_bstrProfile;   // We're refering to this variable in the callback function BrowseCallbackProc

    //
    // Controls
    //
    CComboBox  m_cmbProfiles;
   
    BOOL  m_fIsDialogInitiated;
    BOOL  m_fIsDirty;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\routingext\devicemethods\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RoutingMethodPropsheetext.rc
//
#define IDC_STATIC                      (-1)

#define IDS_PROJNAME                    100
#define IDD_ROUTINGMETHODCONFIG         101
#define IDD_STORE                       101
#define IDS_ROUTINGMETHODCONFIG_DESC    102
#define IDS_ROUTINGMETHODCONFIG_PROVIDER 103
#define IDS_ROUTINGMETHODCONFIG_VERSION 104
#define IDR_ROUTINGMETHODCONFIG         105
#define IDS_ERR_BAD_ROUTINGMETHOD_CONFIGURATION 106
#define IDS_STORE_TITLE                 107
#define IDS_PRINT_TITLE                 108
#define IDS_EMAIL_TITLE                 109
#define IDS_FOLDER_EMPTY                110
#define IDS_PRINTER_INVALID             111
#define IDS_EMAIL_ADDR_INVALID          112
#define IDS_FAIL2LOADPRINTERLIST        113
#define IDS_MEMORY                      114
#define IDS_SELECT_FOLDER       	119
#define IDS_FAIL2READPRINTER            120
#define IDS_EMPTY_PRINTERNAME           121
#define IDS_FOLDER_INVALID              122

#define IDI_SMTP                        151
#define IDI_STORE                       152
#define IDI_PRINT                       153
#define IDI_Info                        154

#define IDC_EDIT_FOLDER                 201
#define IDD_PRINT                       201
#define IDC_BUT_BROWSE                  202
#define IDD_EMAIL                       202
#define IDC_PRINTERS_COMBO              203
#define IDC_EDIT_MAILTO                 205
#define IDC_USER_ACCOUNT_HELP_LINK      209    
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         210
#define _APS_NEXT_SYMED_VALUE           123
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\routingext\devicemethods\emailconfigpage.h ===
#ifndef __EMAIL_CONFIG_PAGE_H_
#define __EMAIL_CONFIG_PAGE_H_
#include "resource.h"
//#include <atlsnap.h>
#include "..\..\inc\atlsnap.h"
#include <atlapp.h>
#include <atlctrls.h>
#include <faxmmc.h>
#include <faxutil.h>
#include <fxsapip.h>
#include <RoutingMethodConfig.h>

class CEmailConfigPage : public CSnapInPropertyPageImpl<CEmailConfigPage>
{
public :
    CEmailConfigPage(LONG_PTR lNotifyHandle, bool bDeleteHandle = false, TCHAR* pTitle = NULL ) : 
        m_lNotifyHandle(lNotifyHandle),
        m_bDeleteHandle(bDeleteHandle) // Should be true for only page.
    {
        m_hFax = NULL;

        m_fIsDialogInitiated = FALSE;
        m_fIsDirty           = FALSE;
    }

    HRESULT Init(LPCTSTR lpctstrServerName, DWORD dwDeviceId);

    ~CEmailConfigPage()
    {

        DEBUG_FUNCTION_NAME(TEXT("CEmailConfigPage::~CEmailConfigPage"));
        if (m_hFax)
        {
            if (!FaxClose(m_hFax))
            {
                DWORD ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxClose() failed on fax handle (0x%08X : %s). (ec: %ld)"),
                    m_hFax,
                    m_bstrServerName,
                    ec);
            }
            m_hFax = NULL;
        }
        if (m_bDeleteHandle)
        {
            MMCFreeNotifyHandle(m_lNotifyHandle);
        }
    }

    enum { IDD = IDD_EMAIL };

BEGIN_MSG_MAP(CEmailConfigPage)
    MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog )
    CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CEmailConfigPage>)
    COMMAND_HANDLER(IDC_EDIT_MAILTO,        EN_CHANGE,  OnFieldChange)
END_MSG_MAP()

    HRESULT PropertyChangeNotify(long param)
    {
        return MMCPropertyChangeNotify(m_lNotifyHandle, param);
    }

    BOOL OnApply();

    LRESULT OnFieldChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        if (!m_fIsDialogInitiated) //event receieved in too early stage
        {
            return 0;
        }
        else
        {
            m_fIsDirty = TRUE;
            SetModified(TRUE);
            return 0;
        }
    }

    LRESULT OnInitDialog( 
            UINT uiMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL& fHandled );


public:
    LONG_PTR m_lNotifyHandle;
    bool m_bDeleteHandle;

private:
    HANDLE   m_hFax;  // Handle to fax server connection
    CComBSTR m_bstrServerName;
    DWORD    m_dwDeviceId;

    CComBSTR m_bstrMailTo;

    //
    // Controls
    //
    CEdit    m_edtMailTo;
    
    BOOL  m_fIsDialogInitiated;
    BOOL  m_fIsDirty;


};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\routingext\devicemethods\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\routingext\devicemethods\printconfigpage.h ===
#ifndef __PRINT_CONFIG_PAGE_H_
#define __PRINT_CONFIG_PAGE_H_
#include "resource.h"
//#include <atlsnap.h>
#include "..\..\inc\atlsnap.h"
#include <atlapp.h>
#include <atlctrls.h>
#include <faxmmc.h>
#include <faxutil.h>
#include <fxsapip.h>
#include <RoutingMethodConfig.h>

class CPrintConfigPage : public CSnapInPropertyPageImpl<CPrintConfigPage>
{
public :
    CPrintConfigPage(LONG_PTR lNotifyHandle, bool bDeleteHandle = false, TCHAR* pTitle = NULL ) : 
        m_lNotifyHandle(lNotifyHandle),
        m_bDeleteHandle(bDeleteHandle), // Should be true for only page.
        m_pPrinterNames(NULL),
        m_hFax(NULL),
        m_fIsDialogInitiated(FALSE),
        m_fIsDirty(FALSE),
        m_dwNumOfPrinters(0)
    {}

    HRESULT Init(LPCTSTR lpctstrServerName, DWORD dwDeviceId);

    ~CPrintConfigPage()
    {

        DEBUG_FUNCTION_NAME(TEXT("CPrintConfigPage::~CPrintConfigPage"));

        if (m_pPrinterNames)
        {
            ReleasePrinterNames (m_pPrinterNames, m_dwNumOfPrinters);
        }

        if (m_hFax)
        {
            if (!FaxClose(m_hFax))
            {
                DWORD ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxClose() failed on fax handle (0x%08X : %s). (ec: %ld)"),
                    m_hFax,
                    m_bstrServerName,
                    ec);
            }
            m_hFax = NULL;
        }
        if (m_bDeleteHandle)
        {
            MMCFreeNotifyHandle(m_lNotifyHandle);
        }

    }

    enum { IDD = IDD_PRINT };

BEGIN_MSG_MAP(CPrintConfigPage)
    MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog )
    CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CPrintConfigPage>)
    COMMAND_HANDLER(IDC_PRINTERS_COMBO, CBN_SELCHANGE, OnComboChanged)
    COMMAND_HANDLER(IDC_PRINTERS_COMBO, CBN_EDITCHANGE,OnComboChanged)
END_MSG_MAP()

    HRESULT PropertyChangeNotify(long param)
    {
        return MMCPropertyChangeNotify(m_lNotifyHandle, param);
    }

    BOOL OnApply();

    LRESULT OnFieldChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        if (!m_fIsDialogInitiated) //event receieved in too early stage
        {
            return 0;
        }
        else
        {
            m_fIsDirty = TRUE;
            SetModified(TRUE);
            return 0;
        }

    }

    LRESULT OnInitDialog( 
            UINT uiMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL& fHandled );

    LRESULT OnComboChanged           (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

public:
    LONG_PTR m_lNotifyHandle;
    bool m_bDeleteHandle;

private:
    HANDLE   m_hFax;  // Handle to fax server connection
    CComBSTR m_bstrServerName;
    DWORD    m_dwDeviceId;

    CComBSTR m_bstrPrinter;

    DWORD          m_dwNumOfPrinters;
    PPRINTER_NAMES m_pPrinterNames;
    
    //
    // Controls
    //
    CComboBox     m_PrintersCombo;

    BOOL          m_fIsDialogInitiated;
    BOOL          m_fIsDirty;

};



HRESULT 
SetComboBoxItem  (CComboBox    combo, 
                  DWORD        comboBoxIndex, 
                  LPCTSTR      lpctstrFieldText,
                  DWORD        dwItemData,
                  HINSTANCE    hInst = NULL);
HRESULT 
AddComboBoxItem  (CComboBox    combo, 
                  LPCTSTR      lpctstrFieldText,
                  DWORD        dwItemData,
                  HINSTANCE    hInst = NULL);

HRESULT 
SelectComboBoxItemData  (CComboBox combo, DWORD_PTR dwItemData);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\routingext\devicemethods\printconfigpage.cpp ===
#include "stdafx.h"
#include "RoutingMethodProp.h"
#include "RoutingMethodConfig.h"
#include <faxutil.h>
#include <faxreg.h>
#include <faxres.h>
#include <PrintConfigPage.h>
#include <Util.h>

HRESULT 
CPrintConfigPage::Init(
    LPCTSTR lpctstrServerName,
    DWORD dwDeviceId
)
{
    DEBUG_FUNCTION_NAME(TEXT("CPrintConfigPage::Init"));
    
    DWORD ec = ERROR_SUCCESS;

    m_bstrServerName = lpctstrServerName;
    m_dwDeviceId = dwDeviceId;
    if (!m_bstrServerName)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Out of memory while copying server name (ec: %ld)")
        );
        ec = ERROR_NOT_ENOUGH_MEMORY;
        DisplayRpcErrorMessage(ERROR_NOT_ENOUGH_MEMORY, IDS_PRINT_TITLE, m_hWnd);
        goto exit;
    }

    if (!FaxConnectFaxServer(lpctstrServerName, &m_hFax))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxConnectFaxServer failed (ec: %ld)"),
            ec);
        DisplayRpcErrorMessage(ec, IDS_PRINT_TITLE, m_hWnd);
        goto exit;
    }
    //
    // Retrieve the data
    //
    ec = ReadExtStringData (
                    m_hFax,
                    m_dwDeviceId,
                    REGVAL_RM_PRINTING_GUID,
                    m_bstrPrinter,
                    TEXT(""),
                    IDS_PRINT_TITLE,
                    m_hWnd);
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("ReadExtStringData() failed. (ec: %ld)"),
                ec);

        goto exit;
    }

exit:

    if ((ERROR_SUCCESS != ec) && m_hFax)
    {
        if (!FaxClose(m_hFax))
        {
            DWORD ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxClose() failed on fax handle (0x%08X : %s). (ec: %ld)"),
                m_hFax,
                m_bstrServerName,
                ec);
        }
        m_hFax = NULL;
    }
    return HRESULT_FROM_WIN32(ec);
}   // CPrintConfigPage::Init

LRESULT CPrintConfigPage::OnInitDialog( 
            UINT uiMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL& fHandled
)
{
    DEBUG_FUNCTION_NAME( _T("CPrintConfigPage::OnInitDialog"));
    HINSTANCE   hInst = _Module.GetResourceInstance();
 
    SetLTRComboBox(m_hWnd, IDC_PRINTERS_COMBO);

    //
    // Attach controls
    //
    m_PrintersCombo.Attach(GetDlgItem(IDC_PRINTERS_COMBO));
    m_PrintersCombo.LimitText(MAX_PATH-1);
    //
    // Init printers drop-down box
    //
    m_pPrinterNames = CollectPrinterNames (&m_dwNumOfPrinters, TRUE);
    if (!m_pPrinterNames)
    {
        if (ERROR_PRINTER_NOT_FOUND == GetLastError ())
        {
            //
            // No printers
            //
        }
        else
        {
            //
            // Real error
            //
        }
        m_PrintersCombo.SetCurSel(-1);
        m_PrintersCombo.SetWindowText(m_bstrPrinter);
    }
    else
    {
        //
        // Success - fill in the combo-box
        //
        DWORD dw;
        LPCWSTR lpcwstrMatchingText;

        for (dw = 0; dw < m_dwNumOfPrinters; dw++)
        {
            m_PrintersCombo.AddString (m_pPrinterNames[dw].lpcwstrDisplayName);
        }
        //
        // Now find out if we match the data the server has
        //
        if (lstrlen(m_bstrPrinter))
        {
            //
            // Server has some name for printer
            //
            lpcwstrMatchingText = FindPrinterNameFromPath (m_pPrinterNames, m_dwNumOfPrinters, m_bstrPrinter);
            if (!lpcwstrMatchingText)
            {
                //
                // No match, just fill in the text we got from the server
                //
                m_PrintersCombo.SetCurSel(-1);
                m_PrintersCombo.SetWindowText(m_bstrPrinter);
            }
            else
            {
                m_PrintersCombo.SelectString(-1, lpcwstrMatchingText);
            }
        }
        else
        {
            //
            // No server configuation - select nothing
            //
        }
    }        
    m_fIsDialogInitiated = TRUE;
    return 1;
}


BOOL 
CPrintConfigPage::OnApply()
{
    DEBUG_FUNCTION_NAME(TEXT("CPrintConfigPage::OnApply"));

    if (!m_fIsDirty)
    {
        return TRUE;
    }
    //
    // Get the selected printer name
    //
    if (!m_PrintersCombo.GetWindowText(&m_bstrPrinter))
    {
        DebugPrintEx( DEBUG_ERR, _T("Out of Memory - fail to set string."));
        DisplayErrorMessage (IDS_PRINT_TITLE, IDS_FAIL2READPRINTER, FALSE, m_hWnd);
        return FALSE;
    }
    //
    // Check data validity
    //
    if (0 == m_bstrPrinter.Length())
    {
        DebugPrintEx( DEBUG_ERR, _T("Zero length string."));
        DisplayErrorMessage (IDS_PRINT_TITLE, IDS_EMPTY_PRINTERNAME, FALSE, m_hWnd);
        return FALSE;
    }
    //
    // Attempt to convert printer name to path 
    //
    LPCWSTR lpcwstrPrinterPath = FindPrinterPathFromName (m_pPrinterNames, m_dwNumOfPrinters, m_bstrPrinter);
    if (lpcwstrPrinterPath)
    {
        //
        // We have a matching path - replace name with path.
        //
        m_bstrPrinter = lpcwstrPrinterPath;
        if (!m_bstrPrinter)
        {
            DebugPrintEx( DEBUG_ERR, _T("Out of Memory - fail to alloc string."));
            DisplayErrorMessage (IDS_PRINT_TITLE, IDS_FAIL2READPRINTER, FALSE, m_hWnd);
            return FALSE;
        }
    }
    //
    // Write the data using RPC
    //        
    if (ERROR_SUCCESS != WriteExtData (m_hFax,
                                       m_dwDeviceId, 
                                       REGVAL_RM_PRINTING_GUID, 
                                       (LPBYTE)(LPCWSTR)m_bstrPrinter, 
                                       sizeof (WCHAR) * (1 + m_bstrPrinter.Length()),
                                       IDS_PRINT_TITLE,
                                       m_hWnd))
    {
        return FALSE;
    }
    //        
    // Success
    //
    m_fIsDirty = FALSE;
    return TRUE;
}   // CPrintConfigPage::OnApply


/*
 +
 +
 *  CPrintConfigPage::OnComboChanged
 -
 -      
 */
LRESULT 
CPrintConfigPage::OnComboChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CPrintConfigPage::OnComboChanged"));


    if (!m_fIsDialogInitiated) //event was receieved in a too early stage
    {
        return 0;
    }
    else
    {
        switch (wNotifyCode)
        {
            case CBN_SELCHANGE:  //assumption: all the registered printer names are valid
                SetModified(TRUE);  
                m_fIsDirty = TRUE;

                break;

            case CBN_EDITCHANGE:
                if ( 0 == m_PrintersCombo.GetWindowTextLength() )
                {
                    SetModified(FALSE);
                }
                else
                {
                    SetModified(TRUE);
                    m_fIsDirty = TRUE;
                }
                break;

            default:
                ATLASSERT(FALSE);
         }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\routingext\devicemethods\routingmethodconfig.cpp ===
#include "stdafx.h"
#include "RoutingMethodProp.h"
#include "RoutingMethodConfig.h"
#include <faxutil.h>
#include <faxreg.h>
#include <faxres.h>
#include <StoreConfigPage.h>
#include <PrintConfigPage.h>
#include <EmailConfigPage.h>
#include <Util.h>

/////////////////////////////////////////////////////////////////////////////
// CRoutingMethodConfigComponentData
static const GUID CRoutingMethodConfigExtGUID_NODETYPE = FAXSRV_ROUTING_METHOD_NODETYPE_GUID;

const GUID*    CRoutingMethodConfigExtData::m_NODETYPE = &CRoutingMethodConfigExtGUID_NODETYPE;
const OLECHAR* CRoutingMethodConfigExtData::m_SZNODETYPE = FAXSRV_ROUTING_METHOD_NODETYPE_GUID_STR;
const OLECHAR* CRoutingMethodConfigExtData::m_SZDISPLAY_NAME = OLESTR("RoutingMethodConfig");
const CLSID*   CRoutingMethodConfigExtData::m_SNAPIN_CLASSID = &CLSID_RoutingMethodConfig;

HRESULT 
CRoutingMethodConfigExtData::QueryPagesFor(
    DATA_OBJECT_TYPES type
)
{
    DEBUG_FUNCTION_NAME(TEXT("CRoutingMethodConfigExtData::QueryPagesFor"));
    return S_OK;
}   // CRoutingMethodConfigExtData::QueryPagesFor

HRESULT 
CRoutingMethodConfigExtData::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR                handle, 
    IUnknown               *pUnk,
    DATA_OBJECT_TYPES       type
)
{
    DEBUG_FUNCTION_NAME(TEXT("CRoutingMethodConfigExtData::CreatePropertyPages"));

    WCHAR szMethodGuid[FAXSRV_MAX_GUID_LEN + 1];
    WCHAR szServer[FAXSRV_MAX_SERVER_NAME + 1];
    DWORD dwDeviceId;

    HRESULT hr;


    hr = GetDWORDFromDataObject(m_pDataObject,m_CCF_DEVICE_ID,&dwDeviceId);
    if (FAILED(hr))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetDeviceIdFromDataObject failed. hr = 0x%08X"),
            hr);
        return hr;
    }

    //
    // only for device incoming methods 
    // will not showup while called under the catalog of the global methods
    //
    if (dwDeviceId == 0) //==FXS_GLOBAL_METHOD_DEVICE_ID
    {
        return E_UNEXPECTED;
    }

    hr = GetStringFromDataObject(m_pDataObject,
                                 m_CCF_METHOD_GUID, 
                                 szMethodGuid, 
                                 sizeof(szMethodGuid)/sizeof(WCHAR));
    if (FAILED(hr))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetStringFromDataObject for m_CCF_METHOD_GUID failed. hr = 0x%08X"),
            hr);
        return hr;
    }
    hr = GetStringFromDataObject(m_pDataObject, 
                                 m_CCF_SERVER_NAME, 
                                 szServer,
                                 sizeof(szServer)/sizeof(WCHAR));
    if (FAILED(hr))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetStringFromDataObject for m_CCF_SERVER_NAME failed. hr = 0x%08X"),
            hr);
        return hr;
    }

    //
    // This snap-in configures the following methods: Store / Print / Email
    //            
    CComBSTR bstrPageTitle;
    if (!lstrcmpi(szMethodGuid, REGVAL_RM_FOLDER_GUID))
    {
        bstrPageTitle.LoadString(IDS_STORE_TITLE);
        if (!bstrPageTitle)
        {
            return E_UNEXPECTED;
        }
        CStoreConfigPage* pPage = new CStoreConfigPage(handle, true, bstrPageTitle); // true = only one page
        if (!pPage)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate CStoreConfigPage")
                );
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
        hr = pPage->Init(szServer, dwDeviceId);
        if (FAILED(hr))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to Init CStoreConfigPage (hr = 0x%08x)"),
                hr
                );
            delete pPage;
            return hr;
        }
        HPROPSHEETPAGE hPage = pPage->Create ();
        if (NULL == hPage)
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to Create CStoreConfigPage (hr = 0x%08x)"),
                hr
                );
            delete pPage;
            return hr;
        }
        hr = lpProvider->AddPage (hPage);
        if (FAILED(hr))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to add page (hr = 0x%08x)"),
                hr
                );
            DestroyPropertySheetPage (hPage);
            delete pPage;
            return hr;
        }
    }
    else if (!lstrcmpi(szMethodGuid, REGVAL_RM_PRINTING_GUID))
    {
    
        bstrPageTitle.LoadString(IDS_PRINT_TITLE);
        if (!bstrPageTitle)
        {
            return E_UNEXPECTED;
        }
        CPrintConfigPage* pPage = new CPrintConfigPage(handle, true, bstrPageTitle); // true = only one page
        if (!pPage)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate CPrintConfigPage")
                );
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
        hr = pPage->Init(szServer, dwDeviceId);
        if (FAILED(hr))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to Init CPrintConfigPage (hr = 0x%08x)"),
                hr
                );
            delete pPage;
            return hr;
        }
        HPROPSHEETPAGE hPage = pPage->Create ();
        if (NULL == hPage)
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to Create CPrintConfigPage (hr = 0x%08x)"),
                hr
                );
            delete pPage;
            return hr;
        }
        hr = lpProvider->AddPage (hPage);
        if (FAILED(hr))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to add page (hr = 0x%08x)"),
                hr
                );
            DestroyPropertySheetPage (hPage);
            delete pPage;
            return hr;
        }
    }
    else if (!lstrcmpi(szMethodGuid, REGVAL_RM_EMAIL_GUID))
    {
    
        bstrPageTitle.LoadString(IDS_EMAIL_TITLE);
        if (!bstrPageTitle)
        {
            return E_UNEXPECTED;
        }
        CEmailConfigPage* pPage = new CEmailConfigPage(handle, true, bstrPageTitle); // true = only one page
        if (!pPage)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate CEmailConfigPage")
                );
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
        hr = pPage->Init(szServer, dwDeviceId);
        if (FAILED(hr))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to Init CEmailConfigPage (hr = 0x%08x)"),
                hr
                );
            delete pPage;
            return hr;
        }
        HPROPSHEETPAGE hPage = pPage->Create ();
        if (NULL == hPage)
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to Create CEmailConfigPage (hr = 0x%08x)"),
                hr
                );
            delete pPage;
            return hr;
        }
        hr = lpProvider->AddPage (hPage);
        if (FAILED(hr))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to add page (hr = 0x%08x)"),
                hr
                );
            DestroyPropertySheetPage (hPage);
            delete pPage;
            return hr;
        }
    }
    else
    {
        //
        // Unsupported routing method
        //
        return S_FALSE;
    }
    return S_OK;
}   // CRoutingMethodConfigExtData::CreatePropertyPages
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\routingext\devicemethods\routingmethodconfig.h ===
#ifndef __ROUTINGMETHODCONFIG_H_
#define __ROUTINGMETHODCONFIG_H_
#include "resource.h"
//#include <atlsnap.h>
#include "..\..\inc\atlsnap.h"
#include <atlapp.h>
#include <atlctrls.h>
#include <faxmmc.h>
#include <faxutil.h>
#include <fxsapip.h>

class CRoutingMethodConfigExtData : public CSnapInItemImpl<CRoutingMethodConfigExtData, TRUE>
{
public:
    static const GUID* m_NODETYPE;
    static const OLECHAR* m_SZNODETYPE;
    static const OLECHAR* m_SZDISPLAY_NAME;
    static const CLSID* m_SNAPIN_CLASSID;
 
    CLIPFORMAT m_CCF_METHOD_GUID;
    CLIPFORMAT m_CCF_SERVER_NAME;
    CLIPFORMAT m_CCF_DEVICE_ID;

    
    CRoutingMethodConfigExtData()
    {
        memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
        memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
        m_CCF_METHOD_GUID = 0;
        m_CCF_SERVER_NAME = 0;
        m_CCF_DEVICE_ID = 0;
    }

    ~CRoutingMethodConfigExtData()
    {
    }

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
        IUnknown* pUnk,
        DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type);

    IDataObject* m_pDataObject;
    virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
    {
        DEBUG_FUNCTION_NAME(TEXT("CRoutingMethodConfigExtData::InitDataClass"));
        m_pDataObject = pDataObject;
        // The default code stores off the pointer to the Dataobject the class is wrapping
        // at the time. 
        // Alternatively you could convert the dataobject to the internal format
        // it represents and store that information
        //
        // Register clipboard formats if they are not registered yet
        if (!m_CCF_METHOD_GUID)
        {
            m_CCF_METHOD_GUID = (CLIPFORMAT) RegisterClipboardFormat(CF_MSFAXSRV_ROUTING_METHOD_GUID);
            if (!m_CCF_METHOD_GUID)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to registet clipformat : %s (ec: %ld)"),
                    CF_MSFAXSRV_ROUTING_METHOD_GUID,
                    GetLastError());
            }
        }

        if (!m_CCF_SERVER_NAME)
        {
            m_CCF_SERVER_NAME = (CLIPFORMAT) RegisterClipboardFormat(CF_MSFAXSRV_SERVER_NAME);
            if (!m_CCF_SERVER_NAME)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to registet clipformat : %s (ec: %ld)"),
                    CF_MSFAXSRV_SERVER_NAME,
                    GetLastError());
            }
        }

        if (!m_CCF_DEVICE_ID)
        {
            m_CCF_DEVICE_ID = (CLIPFORMAT) RegisterClipboardFormat(CF_MSFAXSRV_DEVICE_ID);
            if (!m_CCF_DEVICE_ID)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to registet clipformat : %s (ec: %ld)"),
                    CF_MSFAXSRV_DEVICE_ID,
                    GetLastError());
            }
        }


    }

    CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
    {
        // Modify to return a different CSnapInItem* pointer.
        return pDefault;
    }

};
class CRoutingMethodConfig : public CComObjectRootEx<CComSingleThreadModel>,
public CSnapInObjectRoot<0, CRoutingMethodConfig>,
    public IExtendPropertySheetImpl<CRoutingMethodConfig>,
    public CComCoClass<CRoutingMethodConfig, &CLSID_RoutingMethodConfig>
{
public:
    CRoutingMethodConfig()
    {
        m_pComponentData = this;
    }

EXTENSION_SNAPIN_DATACLASS(CRoutingMethodConfigExtData)

BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CRoutingMethodConfig)
    EXTENSION_SNAPIN_NODEINFO_ENTRY(CRoutingMethodConfigExtData)
END_EXTENSION_SNAPIN_NODEINFO_MAP()

BEGIN_COM_MAP(CRoutingMethodConfig)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_ROUTINGMETHODCONFIG)

DECLARE_NOT_AGGREGATABLE(CRoutingMethodConfig)


    static void WINAPI ObjectMain(bool bStarting)
    {
        if (bStarting)
            CSnapInItem::Init();
    }
};

class ATL_NO_VTABLE CRoutingMethodConfigAbout : public ISnapinAbout,
    public CComObjectRoot,
    public CComCoClass< CRoutingMethodConfigAbout, &CLSID_RoutingMethodConfigAbout>
{
public:
    DECLARE_REGISTRY(CRoutingMethodConfigAbout, _T("RoutingMethodConfigAbout.1"), _T("RoutingMethodConfigAbout.1"), IDS_ROUTINGMETHODCONFIG_DESC, THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CRoutingMethodConfigAbout)
        COM_INTERFACE_ENTRY(ISnapinAbout)
    END_COM_MAP()

    STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
    {
        USES_CONVERSION;
        TCHAR szBuf[256];
        if (::LoadString(_Module.GetResourceInstance(), IDS_ROUTINGMETHODCONFIG_DESC, szBuf, 256) == 0)
            return E_FAIL;

        *lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
        if (*lpDescription == NULL)
            return E_OUTOFMEMORY;

        ocscpy(*lpDescription, T2OLE(szBuf));

        return S_OK;
    }

    STDMETHOD(GetProvider)(LPOLESTR *lpName)
    {
        USES_CONVERSION;
        TCHAR szBuf[256];
        if (::LoadString(_Module.GetResourceInstance(), IDS_ROUTINGMETHODCONFIG_PROVIDER, szBuf, 256) == 0)
            return E_FAIL;

        *lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
        if (*lpName == NULL)
            return E_OUTOFMEMORY;

        ocscpy(*lpName, T2OLE(szBuf));

        return S_OK;
    }

    STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
    {
        USES_CONVERSION;
        TCHAR szBuf[256];
        if (::LoadString(_Module.GetResourceInstance(), IDS_ROUTINGMETHODCONFIG_VERSION, szBuf, 256) == 0)
            return E_FAIL;

        *lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
        if (*lpVersion == NULL)
            return E_OUTOFMEMORY;

        ocscpy(*lpVersion, T2OLE(szBuf));

        return S_OK;
    }

    STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
    {
        *hAppIcon = NULL;
        return S_OK;
    }

    STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
        HBITMAP *hSmallImageOpen,
        HBITMAP *hLargeImage,
        COLORREF *cMask)
    {
        *hSmallImageOpen = *hLargeImage = *hLargeImage = 0;
        return S_OK;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\routingext\devicemethods\inboxconfigpage.cpp ===
#include "stdafx.h"
#include "RoutingMethodProp.h"
#include "RoutingMethodConfig.h"
#include <shlobj.h>
#include <faxutil.h>
#include <faxreg.h>
#include <faxres.h>
#include <InboxConfigPage.h>
#include <Util.h>
#include <shlobjp.h>
#include <HtmlHelp.h>

HRESULT 
CInboxConfigPage::Init(
    LPCTSTR lpctstrServerName,
    DWORD dwDeviceId
)
{
    DEBUG_FUNCTION_NAME(TEXT("CInboxConfigPage::Init"));
    
    DWORD ec = ERROR_SUCCESS;

    m_bstrServerName = lpctstrServerName;
    m_dwDeviceId = dwDeviceId;
    if (!m_bstrServerName)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Out of memory while copying server name (ec: %ld)")
        );
        ec = ERROR_NOT_ENOUGH_MEMORY;
        DisplayRpcErrorMessage(ERROR_NOT_ENOUGH_MEMORY, IDS_INBOX_TITLE, m_hWnd);
        goto exit;
    }

    if (!FaxConnectFaxServer(lpctstrServerName, &m_hFax))
    {
        DWORD ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxConnectFaxServer failed (ec: %ld)"),
            ec);
        DisplayRpcErrorMessage(ec, IDS_INBOX_TITLE, m_hWnd);
        goto exit;
    }
    //
    // Register link control
    //
    if (!LinkWindow_RegisterClass())
    {
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("LinkWindow_RegisterClass() failed with %ld"),
                     GetLastError ());
    }

    //
    // Retrieve the data
    //
    ec = ReadExtStringData (
                    m_hFax,
                    m_dwDeviceId,
                    REGVAL_RM_INBOX_GUID,
                    m_bstrProfile,
                    TEXT(""),
                    IDS_INBOX_TITLE,
                    m_hWnd);

exit:

    if ((ERROR_SUCCESS != ec) && m_hFax)
    {
        if (!FaxClose(m_hFax))
        {
            DWORD ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxClose() failed on fax handle (0x%08X : %s). (ec: %ld)"),
                m_hFax,
                m_bstrServerName,
                ec);
        }
        m_hFax = NULL;
    }
    return HRESULT_FROM_WIN32(ec);
}   // CInboxConfigPage::Init

LRESULT CInboxConfigPage::OnInitDialog( 
            UINT uiMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL& fHandled
)
{
    LPWSTR lpwstrProfiles = NULL;
    DWORD ec;
    int  iCurrentProfileIndex = -1;
    BOOL    bCurrentConfigIsValid = (m_bstrProfile.Length()) > 0 ? TRUE : FALSE;
    DEBUG_FUNCTION_NAME( _T("CInboxConfigPage::OnInitDialog"));

    //
    // Attach and set values to the controls
    //
    m_cmbProfiles.Attach (GetDlgItem (IDC_PROFILES));
    //
    // Get MAPI profiles from server
    //
    if (!FaxGetMapiProfiles (m_hFax, &lpwstrProfiles))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxGetMapiProfiles() failed with %ld"),
            ec);
    }
    else
    {
        //
        // Fill combo-box
        //
	    LPTSTR lptstrProfile = lpwstrProfiles;
        while (*lptstrProfile) 
        {
            if (!lstrlen (lptstrProfile))
            {
                ASSERT_FALSE;
                continue;
            }
		    int iResult = m_cmbProfiles.AddString (lptstrProfile);
    		if ((CB_ERR == iResult) || (CB_ERRSPACE == iResult))
		    {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to add profile %s to combo box (Result = %d)"),
                    lptstrProfile,
                    iResult);
		    }
            else
            {
                if (bCurrentConfigIsValid && !lstrcmp (lptstrProfile, m_bstrProfile))
                {
                    iCurrentProfileIndex = iResult;
                }
            }
            lptstrProfile += _tcslen(lptstrProfile) + 1;
        }
    }
    if (m_cmbProfiles.GetCount())
    {
        if (bCurrentConfigIsValid && (iCurrentProfileIndex >= 0))
        {
            //
            // Select currently configured profile
            //
            m_cmbProfiles.SetCurSel (iCurrentProfileIndex);
        }
        else
        {
            //
            // Select 1st item and turn on dirty flag so the user can 'Apply'.
            //
            m_cmbProfiles.SetCurSel (0);
            ::PostMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
            m_fIsDirty = TRUE;
        }
    }
    else
    {
        m_cmbProfiles.EnableWindow (FALSE);
    }

    BOOL bShowWarning = FALSE;
    LPCTSTR lpctstrMachine = m_bstrServerName;
    if (IsLocalMachineName (m_bstrServerName))
    {
        lpctstrMachine = NULL;
    }
    BOOL bServerRunningUserLocalSystemAccount;
    ec = IsFaxServiceRunningUnderLocalSystemAccount(lpctstrMachine, &bServerRunningUserLocalSystemAccount);
    if(ERROR_SUCCESS != ec)
    {
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("IsFaxServiceRunningUnderLocalSystemAccount failed: %d\n"), 
					 ec);
        bServerRunningUserLocalSystemAccount = FALSE;
    }
    if(bServerRunningUserLocalSystemAccount)
    {
        //
        // The machine we're configuring is having our service running under the Local-System-Account.
        // As such, the service won't be able to access any user MAPI profiles.
        // This is why we show a warning icon and text + link to help topic explaining how to set this up
        // correctly.
        //
        bShowWarning = TRUE;
    }
    if (!bShowWarning)
    {
	    ::ShowWindow(::GetDlgItem(m_hWnd, IDC_ICON_NO_INBOX_ROUTE), SW_HIDE);
	    ::ShowWindow(::GetDlgItem(m_hWnd, IDC_STATIC_NO_INBOX_ROUTE), SW_HIDE);
        ::ShowWindow(::GetDlgItem(m_hWnd, IDC_USER_ACCOUNT_HELP_LINK), SW_HIDE);
    }
    m_fIsDialogInitiated = TRUE;
    return 1;
}


BOOL 
CInboxConfigPage::OnApply()
{
    DEBUG_FUNCTION_NAME(TEXT("CInboxConfigPage::OnApply"));

    if (!m_fIsDirty)
    {
        return TRUE;
    }
    //
    // Collect data from the controls
    //
    int iCurSelIndex = m_cmbProfiles.GetCurSel();
    if (LB_ERR == iCurSelIndex)
    {
        //
        // Nothing is selected
        //
        DisplayErrorMessage (IDS_INBOX_TITLE, IDS_PROFILE_EMPTY, FALSE, m_hWnd);
        return FALSE;
    }
    //
    // Get text
    //
    CComBSTR bstrSelectedText;
    if (!m_cmbProfiles.GetLBTextBSTR(iCurSelIndex, (BSTR&)bstrSelectedText))
    {
        DisplayRpcErrorMessage(ERROR_NOT_ENOUGH_MEMORY, IDS_INBOX_TITLE, m_hWnd);
        return FALSE;
    }
    if (!bstrSelectedText.Length())
    {
        //
        // Zero length string?
        //
        DisplayErrorMessage (IDS_INBOX_TITLE, IDS_PROFILE_EMPTY, FALSE, m_hWnd);
        return FALSE;
    }
    //
    // Validation passed. Now write the data using RPC
    //        
    if (ERROR_SUCCESS != WriteExtData (m_hFax,
                                       m_dwDeviceId, 
                                       REGVAL_RM_INBOX_GUID, 
                                       (LPBYTE)(LPCWSTR)bstrSelectedText, 
                                       sizeof (WCHAR) * (1 + bstrSelectedText.Length()),
                                       IDS_INBOX_TITLE,
                                       m_hWnd))
    {
        return FALSE;
    }
    //Success
    m_fIsDirty = FALSE;
    return TRUE;
}   // CInboxConfigPage::OnApply

#define FAX_USER_ACCOUNT_HELP  FAX_ADMIN_HELP_FILE TEXT("::/FaxS_H_HowTo.htm")

LRESULT 
CInboxConfigPage::OnHelpLink(
    int idCtrl, 
    LPNMHDR pnmh, 
    BOOL& bHandled
)
{
    if( IDC_USER_ACCOUNT_HELP_LINK == idCtrl )
    {
        HtmlHelp(m_hWnd, FAX_USER_ACCOUNT_HELP, HH_DISPLAY_TOC, NULL);
    }
    return 0;
}   // CInboxConfigPage::OnHelpLink

CComBSTR CInboxConfigPage::m_bstrProfile;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\t30ext\makefile.inc ===
!IF 0

Copyright (c) 1993  Microsoft Corporation

Module Name:

    makefile.inc

Abstract:

    This file is necessary to cause the message file to be compiled.

Author:

    Wesley Witt (wesw)

!ENDIF

faxmsg.h faxmsg.rc msg00001.bin: messages.mc
    copy messages.mc+..\registry\eventlog.mc faxmsg.mc
    mc -v faxmsg.mc

faxsvc.rc: faxmsg.rc msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\t30ext\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\routingext\devicemethods\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A10F8379_F7DD_40F2_9C23_5D7A631C3565__INCLUDED_)
#define AFX_STDAFX_H__A10F8379_F7DD_40F2_9C23_5D7A631C3565__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A10F8379_F7DD_40F2_9C23_5D7A631C3565__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\routingext\devicemethods\routingmethodpropsheetext.cpp ===
// RoutingMethodPropSheetExt.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f RoutingMethodPropSheetExtps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "RoutingMethodProp.h"
#include "RoutingMethodProp_i.c"
#include "RoutingMethodConfig.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_RoutingMethodConfig,      CRoutingMethodConfig)
OBJECT_ENTRY(CLSID_RoutingMethodConfigAbout, CRoutingMethodConfigAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_ROUTINGMETHODPROPSHEETEXTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\routingext\devicemethods\storeconfigpage.cpp ===
#include "stdafx.h"
#include "RoutingMethodProp.h"
#include "RoutingMethodConfig.h"
#include <shlobj.h>
#include <faxutil.h>
#include <faxreg.h>
#include <faxres.h>
#include <StoreConfigPage.h>
#include <Util.h>

HRESULT 
CStoreConfigPage::Init(
    LPCTSTR lpctstrServerName,
    DWORD dwDeviceId
)
{
    DEBUG_FUNCTION_NAME(TEXT("CStoreConfigPage::Init"));
    
    DWORD ec = ERROR_SUCCESS;

    m_bstrServerName = lpctstrServerName;
    m_dwDeviceId = dwDeviceId;
    if (!m_bstrServerName)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Out of memory while copying server name (ec: %ld)")
        );
        ec = ERROR_NOT_ENOUGH_MEMORY;
        DisplayRpcErrorMessage(ERROR_NOT_ENOUGH_MEMORY, IDS_STORE_TITLE, m_hWnd);
        goto exit;
    }

    if (!FaxConnectFaxServer(lpctstrServerName, &m_hFax))
    {
        DWORD ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxConnectFaxServer failed (ec: %ld)"),
            ec);
        DisplayRpcErrorMessage(ec, IDS_STORE_TITLE, m_hWnd);
        goto exit;
    }
    //
    // Retrieve the data
    //
    ec = ReadExtStringData (
                    m_hFax,
                    m_dwDeviceId,
                    REGVAL_RM_FOLDER_GUID,
                    m_bstrFolder,
                    TEXT(""),
                    IDS_STORE_TITLE,
                    m_hWnd);

exit:

    if ((ERROR_SUCCESS != ec) && m_hFax)
    {
        if (!FaxClose(m_hFax))
        {
            DWORD ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxClose() failed on fax handle (0x%08X : %s). (ec: %ld)"),
                m_hFax,
                m_bstrServerName,
                ec);
        }
        m_hFax = NULL;
    }
    return HRESULT_FROM_WIN32(ec);
}   // CStoreConfigPage::Init

LRESULT CStoreConfigPage::OnInitDialog( 
            UINT uiMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL& fHandled
)
{
    DEBUG_FUNCTION_NAME( _T("CStoreConfigPage::OnInitDialog"));

    //
    // Attach and set values to the controls
    //
    m_edtFolder.Attach (GetDlgItem (IDC_EDIT_FOLDER));
    m_edtFolder.SetWindowText (m_bstrFolder);
    m_edtFolder.SetLimitText (MAX_PATH);
    SHAutoComplete (GetDlgItem (IDC_EDIT_FOLDER), SHACF_FILESYSTEM);

    m_fIsDialogInitiated = TRUE;

    if ( 0 != m_bstrServerName.Length()) //not a local server
    {
        ::EnableWindow(GetDlgItem(IDC_BUT_BROWSE), FALSE); 
    }

    return 1;
}

BOOL
DirectoryExists(
    LPTSTR  pDirectoryName
    )

/*++

Routine Description:

    Check the existancy of given folder name

Arguments:

    pDirectoryName - point to folder name

Return Value:

    if the folder exists, return TRUE; else, return FALSE.

--*/

{
    DWORD   dwFileAttributes;

    if(!pDirectoryName || lstrlen(pDirectoryName) == 0)
    {
        return FALSE;
    }

    dwFileAttributes = GetFileAttributes(pDirectoryName);

    if ( dwFileAttributes != 0xffffffff &&
         dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) 
    {
        return TRUE;
    }
    return FALSE;
}


BOOL 
CStoreConfigPage::OnApply()
{
    DEBUG_FUNCTION_NAME(TEXT("CStoreConfigPage::OnApply"));

    if (!m_fIsDirty)
    {
        return TRUE;
    }

    //
    // Collect data from the controls
    //
    m_edtFolder.GetWindowText (m_bstrFolder.m_str);
    //
    // Check data validity
    //
    if (PathIsRelative(m_bstrFolder) || !DirectoryExists(m_bstrFolder))
    {
        DisplayErrorMessage (IDS_STORE_TITLE, IDS_FOLDER_INVALID, FALSE, m_hWnd);
        return FALSE;
    }

    if (!m_bstrFolder.Length())
    {
        DisplayErrorMessage (IDS_STORE_TITLE, IDS_FOLDER_EMPTY, FALSE, m_hWnd);
        return FALSE;
    }
    //
    // Validation passed. Now write the data using RPC
    //        
    if (ERROR_SUCCESS != WriteExtData (m_hFax,
                                       m_dwDeviceId, 
                                       REGVAL_RM_FOLDER_GUID, 
                                       (LPBYTE)(LPCWSTR)m_bstrFolder, 
                                       sizeof (WCHAR) * (1 + m_bstrFolder.Length()),
                                       IDS_STORE_TITLE,
                                       m_hWnd))
    {
        return FALSE;
    }
        
        
    //Success
    m_fIsDirty = FALSE;
    
    return TRUE;

}   // CStoreConfigPage::OnApply

CComBSTR CStoreConfigPage::m_bstrFolder;

int CALLBACK
BrowseCallbackProc(
    HWND hwnd,
    UINT uMsg,
    LPARAM lp, 
    LPARAM pData
) 
{
    switch(uMsg) 
    {
        case BFFM_INITIALIZED: 
        {
            LPCWSTR lpcwstrCurrentFolder = CStoreConfigPage::GetFolder();
            ::SendMessage (hwnd, 
                           BFFM_SETSELECTION,
                           TRUE,    // Passing a path string and not a pidl.
                           (LPARAM)(lpcwstrCurrentFolder));
            break;
        }

        case BFFM_SELCHANGED:
        {
            BOOL bFolderIsOK = FALSE;
            TCHAR szPath [MAX_PATH + 1];

            if (SHGetPathFromIDList ((LPITEMIDLIST) lp, szPath)) 
            {
                DWORD dwFileAttr = GetFileAttributes(szPath);
                if (-1 != dwFileAttr && (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY))
                {
                    //
                    // The directory exists - enable the 'Ok' button
                    //
                    bFolderIsOK = TRUE;
                }
            }
            //
            // Enable / disable the 'ok' button
            //
            ::SendMessage(hwnd, BFFM_ENABLEOK , 0, (LPARAM)bFolderIsOK);
            break;
        }


        default:
            break;
    }
    return 0;
}   // BrowseCallbackProc


LRESULT 
CStoreConfigPage::OnBrowseForFolder(
    WORD wNotifyCode, 
    WORD wID, 
    HWND hWndCtl, 
    BOOL& bHandled
)
{
    DEBUG_FUNCTION_NAME(TEXT("CStoreConfigPage::OnBrowseForFolder"));

    CComBSTR bstrSelectedFolder;
    BROWSEINFO bi = {0};
	HRESULT hr = NOERROR;
    TCHAR szDisplayName[MAX_PATH + 1];

    bi.hwndOwner = hWndCtl;
    bi.pidlRoot = NULL;
    bi.pszDisplayName = szDisplayName;
    bi.lpszTitle = AllocateAndLoadString (_pModule->m_hInstResource, IDS_SELECT_FOLDER);
    bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;
    bi.lpfn = BrowseCallbackProc;

    m_edtFolder.GetWindowText (m_bstrFolder.m_str);

    LPITEMIDLIST pItemIdList = SHBrowseForFolder (&bi);
    MemFree ((LPVOID)bi.lpszTitle);
    if (NULL == pItemIdList)
    {
        //
        // User pressed cancel
        //
        return hr;
    }
	if(!::SHGetPathFromIDList(pItemIdList, szDisplayName))
    {
        hr = HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE);
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SHGetPathFromIDList() failed. (hr = 0x%08X)"),
            hr);
    }
    else
    {
        m_edtFolder.SetWindowText (szDisplayName);
        SetModified(TRUE);
    }
    //
    // free pItemIdList
    //
	LPMALLOC pMalloc;
	HRESULT hRes = ::SHGetMalloc(&pMalloc);
    if(E_FAIL == hRes)
    {
        hr = HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE);
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SHGetMalloc() failed. (hr = 0x%08X)"),
            hr);
    }
    else
    {
	    pMalloc->Free(pItemIdList);
	    pMalloc->Release();
    }
    return hr;
}   // CStoreConfigPage::OnBrowseForFolder
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\t30ext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by T30PropSheetExt.rc
//
#define IDS_PROJNAME                    100
#define IDB_T30CONFIG_16                101
#define IDB_T30CONFIG_32                102
#define IDD_T30CONFIG                   103
#define IDS_T30CONFIG_DESC              104
#define IDS_T30CONFIG_PROVIDER          105
#define IDS_T30CONFIG_VERSION           106
#define IDR_T30CONFIG                   107
#define IDS_T30PAGE_TITLE               107
#define IDS_ERR_BAD_T30_CONFIGURATION   108
#define IDC_ADAPTIVE_ANSWERING          201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         202
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\routingext\devicemethods\util.h ===
#ifndef _UTIL_H_
#define _UTIL_H_


DWORD 
WriteExtData(
    HANDLE          hFax,
    DWORD           dwDeviceId,
    LPCWSTR         lpcwstrGUID,
    LPBYTE          lpData,
    DWORD           dwDataSize,
    UINT            uTitleId,
    HWND            hWnd
);

DWORD 
ReadExtDWORDData(
    HANDLE          hFax,
    DWORD           dwDeviceId,
    LPCWSTR         lpcwstrGUID,
    DWORD          &dwResult,
    DWORD           dwDefault,
    UINT            uTitleId,
    HWND            hWnd
);

DWORD
ReadExtStringData(
    HANDLE          hFax,
    DWORD           dwDeviceId,
    LPCWSTR         lpcwstrGUID,
    CComBSTR       &bstrResult,
    LPCWSTR         lpcwstrDefault,
    UINT            uTitleId,
    HWND            hWnd
);

HRESULT 
GetDWORDFromDataObject(
    IDataObject * lpDataObject, 
    CLIPFORMAT uFormat,
    LPDWORD lpdwValue
);

HRESULT 
GetStringFromDataObject(
    IDataObject * lpDataObject, 
    CLIPFORMAT uFormat,
    LPWSTR lpwstrBuf, 
    DWORD dwBufLen
);

void 
DisplayRpcErrorMessage(
    DWORD ec,
    UINT uTitleId,
    HWND hWnd
);

void 
DisplayErrorMessage(
    UINT uTitleId,
    UINT uMsgId, 
    BOOL bCommon,
    HWND hWnd
);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\routingext\devicemethods\storeconfigpage.h ===
#ifndef __STORE_CONFIG_PAGE_H_
#define __STORE_CONFIG_PAGE_H_
#include "resource.h"
//#include <atlsnap.h>
#include "..\..\inc\atlsnap.h"
#include <atlapp.h>
#include <atlctrls.h>
#include <faxmmc.h>
#include <faxutil.h>
#include <fxsapip.h>
#include <RoutingMethodConfig.h>

class CStoreConfigPage : public CSnapInPropertyPageImpl<CStoreConfigPage>
{
public :
    CStoreConfigPage(LONG_PTR lNotifyHandle, bool bDeleteHandle = false, TCHAR* pTitle = NULL ) : 
        m_lNotifyHandle(lNotifyHandle),
        m_bDeleteHandle(bDeleteHandle) // Should be true for only page.
    {
        m_hFax = NULL;

        m_fIsDialogInitiated = FALSE;
        m_fIsDirty           = FALSE;
    }

    HRESULT Init(LPCTSTR lpctstrServerName, DWORD dwDeviceId);

    ~CStoreConfigPage()
    {

        DEBUG_FUNCTION_NAME(TEXT("CStoreConfigPage::~CStoreConfigPage"));
        if (m_hFax)
        {
            if (!FaxClose(m_hFax))
            {
                DWORD ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxClose() failed on fax handle (0x%08X : %s). (ec: %ld)"),
                    m_hFax,
                    m_bstrServerName,
                    ec);
            }
            m_hFax = NULL;
        }
        if (m_bDeleteHandle)
        {
            MMCFreeNotifyHandle(m_lNotifyHandle);
        }
    }

    enum { IDD = IDD_STORE };

BEGIN_MSG_MAP(CStoreConfigPage)
    MESSAGE_HANDLER(WM_INITDIALOG,                    OnInitDialog )
    CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CStoreConfigPage>)
    COMMAND_HANDLER(IDC_EDIT_FOLDER,        EN_CHANGE,  OnFieldChange)
    COMMAND_HANDLER(IDC_BUT_BROWSE,         BN_CLICKED, OnBrowseForFolder)
END_MSG_MAP()

    LRESULT OnBrowseForFolder(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    HRESULT PropertyChangeNotify(long param)
    {
        return MMCPropertyChangeNotify(m_lNotifyHandle, param);
    }

    BOOL OnApply();

    LRESULT OnFieldChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        if (!m_fIsDialogInitiated) //event receieved in too early stage
        {
            return 0;
        }
        else
        {
            m_fIsDirty = TRUE;
            SetModified(TRUE);
            return 0;
        }
    }

    LRESULT OnInitDialog( 
            UINT uiMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL& fHandled );


public:
    LONG_PTR m_lNotifyHandle;
    bool m_bDeleteHandle;

    static CComBSTR &GetFolder ()  { return m_bstrFolder; }

private:
    HANDLE   m_hFax;  // Handle to fax server connection
    CComBSTR m_bstrServerName;
    DWORD    m_dwDeviceId;

    static CComBSTR m_bstrFolder;   // We're refering to this variable in the callback function BrowseCallbackProc

    //
    // Controls
    //
    CEdit    m_edtFolder;
   
    BOOL  m_fIsDialogInitiated;
    BOOL  m_fIsDirty;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\routingext\devicemethods\util.cpp ===
#include "stdafx.h"
#include "RoutingMethodProp.h"
#include "RoutingMethodConfig.h"
#include <faxutil.h>
#include <fxsapip.h>
#include <faxreg.h>
#include <faxres.h>
#include "Util.h"

DWORD 
WriteExtData(
    HANDLE          hFax,
    DWORD           dwDeviceId,
    LPCWSTR         lpcwstrGUID,
    LPBYTE          lpData,
    DWORD           dwDataSize,
    UINT            uTitleId,
    HWND            hWnd
)
{
    DEBUG_FUNCTION_NAME(TEXT("WriteExtData"));

    DWORD  ec = ERROR_SUCCESS;

    if (!FaxSetExtensionData (
            hFax,                       // Connection handle
            dwDeviceId,                 // Global extension data
            lpcwstrGUID,                // Data GUID
            lpData,                     // Buffer
            dwDataSize                  // Buffer size
    ))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxSetExtensionData() failed for GUID = %s (ec: %ld)"),
            lpcwstrGUID,
            ec);
        DisplayRpcErrorMessage(ec, uTitleId, hWnd);
    }
    return ec;
}   // WriteExtDWORDData

DWORD 
ReadExtDWORDData(
    HANDLE          hFax,
    DWORD           dwDeviceId,
    LPCWSTR         lpcwstrGUID,
    DWORD          &dwResult,
    DWORD           dwDefault,
    UINT            uTitleId,
    HWND            hWnd
)
{
    DEBUG_FUNCTION_NAME(TEXT("ReadExtDWORDData"));

    DWORD  dwDataSize = 0;
    DWORD  ec = ERROR_SUCCESS;
    LPBYTE lpExtData = NULL;

    if (!FaxGetExtensionData (
            hFax,                       // Connection handle
            dwDeviceId,                 // Global extension data
            lpcwstrGUID,                // Data GUID
            (PVOID *)&lpExtData,        // Buffer
            &dwDataSize                 // Buffer size
    ))
    {
        ec = GetLastError();
        lpExtData = NULL;
        if (ERROR_FILE_NOT_FOUND == ec)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ROUTINGEXT Data not found for GUID: %s. Using default value (%ld)"),
                lpcwstrGUID,
                dwDefault);
            ec = ERROR_SUCCESS;
            dwResult = dwDefault;
            goto exit;
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ROUTINGEXT FaxGetExtensionData() failed for GUID = %s (ec: %ld)"),
                lpcwstrGUID,
                ec);
            DisplayRpcErrorMessage(ec, uTitleId, hWnd);
        }
        goto exit;
    }
    if (sizeof (DWORD) != dwDataSize)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("ROUTINGEXT FaxGetExtensionData() for GUID = %s retieved %ld bytes while expecting a DWORD"),
            lpcwstrGUID,
            dwDataSize);
        ec = ERROR_BADDB;    
        DisplayRpcErrorMessage(ec, uTitleId, hWnd);
        goto exit;
    }

    dwResult = *((LPDWORD)lpExtData);

exit:
    FaxFreeBuffer(lpExtData);
    return ec;
}   // ReadExtDWORDData

DWORD
ReadExtStringData(
    HANDLE          hFax,
    DWORD           dwDeviceId,
    LPCWSTR         lpcwstrGUID,
    CComBSTR       &bstrResult,
    LPCWSTR         lpcwstrDefault,
    UINT            uTitleId,
    HWND            hWnd
)
{
    DEBUG_FUNCTION_NAME(TEXT("ReadExtStringData"));

    DWORD  dwDataSize = 0;
    DWORD  ec = ERROR_SUCCESS;
    LPBYTE lpExtData = NULL;

    if (!FaxGetExtensionData (
            hFax,                       // Connection handle
            dwDeviceId,                 // Global extension data
            lpcwstrGUID,                // Data GUID
            (PVOID *)&lpExtData,        // Buffer
            &dwDataSize                 // Buffer size
    ))
    {
        ec = GetLastError();
        lpExtData = NULL;
        if (ERROR_FILE_NOT_FOUND == ec)
        {
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("ROUTINGEXT Data not found for GUID: %s. Using default value (%s)"),
                lpcwstrGUID,
                lpcwstrDefault);
            ec = ERROR_SUCCESS;
            bstrResult = lpcwstrDefault;
            goto exit;
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ROUTINGEXT FaxGetExtensionData() failed for GUID = %s (ec: %ld)"),
                lpcwstrGUID,
                ec);
            DisplayRpcErrorMessage(ec, uTitleId, hWnd);
        }
        goto exit;
    }
    bstrResult = (LPCWSTR)lpExtData;

exit:
    FaxFreeBuffer(lpExtData);
    return ec;
}   // ReadExtStringData

HRESULT 
GetDWORDFromDataObject(
    IDataObject * lpDataObject, 
    CLIPFORMAT uFormat,
    LPDWORD lpdwValue
)
{
    DEBUG_FUNCTION_NAME(TEXT("GetDWORDFromDataObject"));

    Assert(lpdwValue);
    Assert(0 != uFormat);

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = 
    { 
        uFormat, 
        NULL, 
        DVASPECT_CONTENT, 
        -1, 
        TYMED_HGLOBAL 
    };

    stgmedium.hGlobal = GlobalAlloc(0, sizeof(DWORD));
    if (stgmedium.hGlobal == NULL)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GlobalAlloc() failed. (ec: %ld)"),
            GetLastError());
        return E_OUTOFMEMORY;
    }

    HRESULT hr = lpDataObject->GetDataHere(&formatetc, &stgmedium);
    if (SUCCEEDED(hr))
    {
        *lpdwValue = *((LPDWORD)stgmedium.hGlobal);
    }
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetDataHere() failed. (hr = 0x%08X)"),
            hr);
    }
    GlobalFree(stgmedium.hGlobal);
    return hr;
}   // GetDWORDFromDataObject

HRESULT 
GetStringFromDataObject(
    IDataObject * lpDataObject, 
    CLIPFORMAT uFormat,
    LPWSTR lpwstrBuf, 
    DWORD dwBufLen
)
{
    DEBUG_FUNCTION_NAME(TEXT("GetStringFromDataObject"));
    Assert(lpDataObject);
    Assert(lpwstrBuf);
    Assert(dwBufLen>0);

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = 
        {   
            uFormat, 
            NULL, 
            DVASPECT_CONTENT, 
            -1, 
            TYMED_HGLOBAL 
        };

    stgmedium.hGlobal = GlobalAlloc(0, dwBufLen*sizeof(WCHAR));
    if (stgmedium.hGlobal == NULL)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GlobalAlloc() failed. (ec: %ld)"),
            GetLastError());
        return E_OUTOFMEMORY;
    }

    HRESULT hr = lpDataObject->GetDataHere(&formatetc, &stgmedium);
    if (SUCCEEDED(hr))
    {
        lstrcpyn(lpwstrBuf,(LPWSTR)stgmedium.hGlobal,dwBufLen);
        lpwstrBuf[dwBufLen-1]=L'\0';
    }
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetDataHere() failed. (hr = 0x%08X)"),
            hr);
    }
    GlobalFree(stgmedium.hGlobal);
    return hr;
}   // GetStringFromDataObject

void 
DisplayRpcErrorMessage(
    DWORD ec,
    UINT uTitleId,
    HWND hWnd
)
{
    
    UINT uMsgId;
    uMsgId = GetRpcErrorStringId(ec);
    DisplayErrorMessage(uTitleId, uMsgId, TRUE, hWnd); // use the common error messages DLL
}   // DisplayRpcErrorMessage

void 
DisplayErrorMessage(
    UINT uTitleId,
    UINT uMsgId, 
    BOOL bCommon,
    HWND hWnd
)
{
    static HINSTANCE hInst = NULL;
    static CComBSTR bstrCaption = TEXT("");
    CComBSTR bstrMsg;
    
    if (!hInst && bCommon)
    {
        hInst = GetResInstance();
    }

    if (!lstrcmp(bstrCaption.m_str,TEXT("")))
    {
        bstrCaption.LoadString(uTitleId);
        if (!bstrCaption)
        {
            bstrCaption = TEXT("");
            return;
        }
    }
    if (bCommon) 
    {
        bstrMsg.LoadString(hInst,uMsgId);
    }
    else
    {
        bstrMsg.LoadString(uMsgId);
    }
    if (bstrMsg)
    {
        AlignedMessageBox(hWnd, bstrMsg, bstrCaption, MB_OK | MB_ICONEXCLAMATION);
    }
}   // DisplayErrorMessage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\t30ext\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A10F8379_F7DD_40F2_9C23_5D7A631C3565__INCLUDED_)
#define AFX_STDAFX_H__A10F8379_F7DD_40F2_9C23_5D7A631C3565__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A10F8379_F7DD_40F2_9C23_5D7A631C3565__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\t30ext\t30config.h ===
#ifndef __T30CONFIG_H_
#define __T30CONFIG_H_
#include "resource.h"
//#include <atlsnap.h>
#include "..\inc\atlsnap.h"
#include <atlapp.h>
#include <atlctrls.h>
#include <faxmmc.h>
#include <faxutil.h>
#include <fxsapip.h>
class CT30ConfigPage : public CSnapInPropertyPageImpl<CT30ConfigPage>
{
public :
	CT30ConfigPage(LONG_PTR lNotifyHandle, bool bDeleteHandle = false, TCHAR* pTitle = NULL ) : 
		CSnapInPropertyPageImpl<CT30ConfigPage> (pTitle),
		m_lNotifyHandle(lNotifyHandle),
		m_bDeleteHandle(bDeleteHandle) // Should be true for only page.
	{
        m_hFax = NULL;
        m_dwDeviceId = 0;
        m_bAdaptiveAnsweringEnabled = 0;

	}

    HRESULT Init(LPCTSTR lpctstrServerName, DWORD dwDeviceId);

    

	~CT30ConfigPage()
	{

        DEBUG_FUNCTION_NAME(TEXT("CT30ConfigPage::~CT30ConfigPage"));
        if (m_hFax)
        {
            if (!FaxClose(m_hFax))
            {
                DWORD ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxClose() failed on fax handle (0x%08X : %s). (ec: %ld)"),
                    m_hFax,
                    m_bstrServerName,
                    ec);
            }
            m_hFax = NULL;
        }
        if (m_bDeleteHandle)
			MMCFreeNotifyHandle(m_lNotifyHandle);
	}

	enum { IDD = IDD_T30CONFIG };

BEGIN_MSG_MAP(CT30ConfigPage)
    MESSAGE_HANDLER( WM_INITDIALOG,            OnInitDialog )
    COMMAND_HANDLER(IDC_ADAPTIVE_ANSWERING, BN_CLICKED, OnClickedAdaptiveAnswering)
	CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CT30ConfigPage>)
    
	
END_MSG_MAP()
// Handler prototypes:
//	LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//	LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//	LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	HRESULT PropertyChangeNotify(long param)
	{
		return MMCPropertyChangeNotify(m_lNotifyHandle, param);
	}

    BOOL OnApply();

    LRESULT OnClickedAdaptiveAnswering(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
        SetModified(TRUE);
		return 0;
	}
    LRESULT OnInitDialog( 
            UINT uiMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL& fHandled );


public:
	LONG_PTR m_lNotifyHandle;
	bool m_bDeleteHandle;
	

private:
    CComBSTR m_bstrServerName;
    HANDLE m_hFax;  // Handle to fax server connection
    DWORD m_dwDeviceId; // The device id for which the properties are displayed
    BOOL m_bAdaptiveAnsweringEnabled; // Holds the AdaptiveAnswerEnable value untill we can put it in the ui.
    //
    // Controls
    //
    CButton m_btnAdaptiveEnabled;
    
};


class CT30ConfigExtData : public CSnapInItemImpl<CT30ConfigExtData, TRUE>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;
 
    CLIPFORMAT m_CCF_FSP_GUID;
    CLIPFORMAT m_CCF_FSP_DEVICE_ID;
    CLIPFORMAT m_CCF_SERVER_NAME;


    
	CT30ConfigExtData()
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
        m_CCF_FSP_GUID = 0;
        m_CCF_FSP_DEVICE_ID = 0;
        m_CCF_SERVER_NAME = 0;

	}

	~CT30ConfigExtData()
	{
	}

	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
		LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

	STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type);
	

	IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
        DEBUG_FUNCTION_NAME(TEXT("CT30ConfigExtData::InitDataClass"));
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
        //
        // Register clipboard formats if they are not registered yet
        if (!m_CCF_FSP_GUID)
        {
            m_CCF_FSP_GUID = (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_FSP_GUID);
            if (!m_CCF_FSP_GUID)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to registet clipformat : %s (ec: %ld)"),
                    CF_MSFAXSRV_FSP_GUID,
                    GetLastError());
            }
        }

        if (!m_CCF_FSP_DEVICE_ID)
        {
            m_CCF_FSP_DEVICE_ID = (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_DEVICE_ID);
            if (!m_CCF_FSP_DEVICE_ID)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to registet clipformat : %s (ec: %ld)"),
                    CF_MSFAXSRV_DEVICE_ID,
                    GetLastError());
            }
        }

        if (!m_CCF_SERVER_NAME)
        {
            m_CCF_SERVER_NAME = (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_SERVER_NAME);
            if (!m_CCF_SERVER_NAME)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to registet clipformat : %s (ec: %ld)"),
                    CF_MSFAXSRV_SERVER_NAME,
                    GetLastError());
            }
        }


	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		// Modify to return a different CSnapInItem* pointer.
		return pDefault;
	}

};
class CT30Config : public CComObjectRootEx<CComSingleThreadModel>,
public CSnapInObjectRoot<0, CT30Config>,
	public IExtendPropertySheetImpl<CT30Config>,
	public CComCoClass<CT30Config, &CLSID_T30Config>
{
public:
	CT30Config()
	{
		m_pComponentData = this;
	}

EXTENSION_SNAPIN_DATACLASS(CT30ConfigExtData)

BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CT30Config)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CT30ConfigExtData)
END_EXTENSION_SNAPIN_NODEINFO_MAP()

BEGIN_COM_MAP(CT30Config)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_T30CONFIG)

DECLARE_NOT_AGGREGATABLE(CT30Config)


	static void WINAPI ObjectMain(bool bStarting)
	{
		if (bStarting)
			CSnapInItem::Init();
	}
};

class ATL_NO_VTABLE CT30ConfigAbout : public ISnapinAbout,
	public CComObjectRoot,
	public CComCoClass< CT30ConfigAbout, &CLSID_T30ConfigAbout>
{
public:
	DECLARE_REGISTRY(CT30ConfigAbout, _T("T30ConfigAbout.1"), _T("T30ConfigAbout.1"), IDS_T30CONFIG_DESC, THREADFLAGS_BOTH);

	BEGIN_COM_MAP(CT30ConfigAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

	STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_T30CONFIG_DESC, szBuf, 256) == 0)
			return E_FAIL;

		*lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpDescription == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpDescription, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetProvider)(LPOLESTR *lpName)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_T30CONFIG_PROVIDER, szBuf, 256) == 0)
			return E_FAIL;

		*lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpName == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpName, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_T30CONFIG_VERSION, szBuf, 256) == 0)
			return E_FAIL;

		*lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpVersion == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpVersion, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
	{
		*hAppIcon = NULL;
		return S_OK;
	}

	STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
		HBITMAP *hSmallImageOpen,
		HBITMAP *hLargeImage,
		COLORREF *cMask)
	{
		*hSmallImageOpen = *hLargeImage = *hLargeImage = 0;
		return S_OK;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\t30ext\t30propsheetext.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Mon Dec 27 10:27:28 1999
 */
/* Compiler settings for t30propsheetext.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __t30propsheetext_h__
#define __t30propsheetext_h__

/* Forward Declarations */ 

#ifndef __T30Config_FWD_DEFINED__
#define __T30Config_FWD_DEFINED__

#ifdef __cplusplus
typedef class T30Config T30Config;
#else
typedef struct T30Config T30Config;
#endif /* __cplusplus */

#endif 	/* __T30Config_FWD_DEFINED__ */


#ifndef __T30ConfigAbout_FWD_DEFINED__
#define __T30ConfigAbout_FWD_DEFINED__

#ifdef __cplusplus
typedef class T30ConfigAbout T30ConfigAbout;
#else
typedef struct T30ConfigAbout T30ConfigAbout;
#endif /* __cplusplus */

#endif 	/* __T30ConfigAbout_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __T30PROPSHEETEXTLib_LIBRARY_DEFINED__
#define __T30PROPSHEETEXTLib_LIBRARY_DEFINED__

/* library T30PROPSHEETEXTLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_T30PROPSHEETEXTLib;

EXTERN_C const CLSID CLSID_T30Config;

#ifdef __cplusplus

class DECLSPEC_UUID("84125C25-AD95-4A51-A472-41864AEC775E")
T30Config;
#endif

EXTERN_C const CLSID CLSID_T30ConfigAbout;

#ifdef __cplusplus

class DECLSPEC_UUID("B37E13AA-75DF-4EDF-900C-2D2E0B884DE8")
T30ConfigAbout;
#endif
#endif /* __T30PROPSHEETEXTLib_LIBRA